{"buggy_code": ["2018-04-14  Karl Berry  <karl@tug.org>\n\n\t* Version 5.998 for TeX Live 2018 release.\n\n2018-02-20  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* color.c (colorpage),\n\t* dospecial.c (bangspecial),\n\t* dvips.h (header_list):\t\n\tdon't use ersatz array as last struct member; change usage.\n\tReported (implicitly, as part of)\n\thttps://trac.macports.org/ticket/53974\n\n2018-01-27  Hironobu Yamashita  <h.y.acetaminophen@gmail.com>\n\n\t* tfmload.c, dvips.h: Support new JFM spec (3-byte characters\n\tin TYPE > 0).\n\n2017-05-19  Karl Berry  <karl@tug.org>\n\n\t* Version 5.997 for TeX Live 2017 release.\n\n2017-03-27  Karl Berry  <karl@freefriends.org>\n\n\t* Makefile.am (AM_TESTS_ENVIRONMENT): use instead of TESTS_ENVIRONMENT.\n\n2017-03-22  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi: don't claim -q quiets standard error.\n\tReport from Igor Liferenko.\n\n2017-03-21  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* dvips.c: Show information and exit if dvips finds options\n\t--help or --version. Report from Igor Liferenko:\n\thttp://tug.org/pipermail/tex-k/2017-March/002748.html\n\n2017-03-18  Karl Berry  <karl@tug.org>\n\n\t* configure.ac,\n\t* NEWS\n\t* dvips.c,\n\t* dvips.h,\n\t* afm2tfm.c,\n\t* dvips.texi: version 5.997 for TL17.\n\n2017-02-28  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* dvips.c: In the case of -T option, reverse the default in the change\n\tmade on 2016-11-01. Thanks Ulrike Fischer:\n\thttp://tug.org/pipermail/tex-live/2017-February/039743.html.\n\n2016-12-13  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* emspecial.c: Fix a bug in emspecial(), reported by Norbert Klingen:\n\thttp://tug.org/pipermail/tex-live/2016-December/039483.html.\n\n2016-11-08  Karl Berry  <karl@freefriends.org>\n\n\t* dvips.texi,\n\t* NEWS: document new papersize special behavior and options.\n\tOriginal report at http://tex.stackexchange.com/questions/336545.\n\n2016-11-01  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* dospecial.c, dvips.c, dvips.help, protos.h, resident.c:\n\tAdd a new option -L*  Last special papersize wins.\n\tdvips -L0 ... gives the old behavior.\n\n2016-10-30  Karl Berry  <karl@tug.org>\n\n\t* output.c (INVALID_EPOCH_VALUE): define as (time_t) -1,\n\tto avoid warning with huge unsigned value on 32-bit systems.\n\t(open_output): don't duplicate writing of %%CreationDate.\n\n\t* dvips.texi (Invoking Dvips): TEXCONFIG does not include\n\t. by default.\n\n2016-07-15  Karl Berry  <karl@tug.org>\n\n\t* config.ps (ieeecs): new paper size for IEEE Computer Society\n\tJournals, requested by Michael Shell for his IEEEtran,\n\t13 Jul 2016 20:04:25.\n\n2016-06-29  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi: remove idvi reference, long gone.\n\n2016-05-20  Karl Berry  <karl@tug.org>\n\n\t* Version 5.996 for TeX Live 2016.\n\n2016-05-06  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* output.c: Avoid to crash for too large a value of SOURCE_DATE_EPOCH\n\t(w32 only). \n\n2016-05-04  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* output.c: Support SOURCE_DATE_EPOCH for %%CreationDate.\n\n2016-03-24  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* writet1.c: Fix one-byte buffer overflow bug reported by Hanno Boeck:\n\thttp://tug.org/pipermail/tex-live/2016-January/037686.html.\n\n2016-02-01  Karl Berry  <karl@tug.org>\n\n\t* dvips.1,\n\t* afm2tfm.1: ask for bug reports to go to tex-k.\n\n2016-01-21  Karl Berry  <karl@freefriends.org>\n\n\t* dvips.texi (Afm2tfm options) <-a>: document new option.\n\t* afm2tfm.c (openfiles): new option -a.\n\t(USAGE): include it in list for --help.\n\t(noaccentheightadjust): new global to remember it.\n\t(texheight): do nothing if -a is specified,\n\tor if the heuristically-guessed height is less than the original.\n\tBug report from Michael Sharpe.\n\n2015-07-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* test-dvips (removed): Renamed ...\n\t* test-dvips.test (new): ... into this.\n\t* Makefile.am: Better dependencies for 'make check'.\n\n2015-07-08  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am: Better dependencies for 'make check'.\n\n2015-05-21  Karl Berry  <karl@tug.org>\n\n\t* version 5.995 for TL'15.\n\n2015-04-17  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am (EXTRA_DIST): Adapted.\n\n2015-04-17  Karl Berry  <karl@tug.org>\n\n\t* contrib/PSTricks: remove this ancient copy of a PSTricks README.\n\t* special.lpro (/psfts, /startTexFig, /doclip, /endTexFig):\n\tremove these defns from (obsolete and nonfree) psfig.\n\t* testdata/special.pro: regenerate.\n\t* dvips.texi (Why Dvips): remove paragraph about psfig and\n\tother features that are no longer especially interesting.\n\tReport from Werner Fink, 14 Apr 2015 17:16:23.\n\n2015-03-15  Karl Berry  <karl@tug.org>\n\n\t* configure.ac,\n\t* NEWS\n\t* dvips.c,\n\t* dvips.h,\n\t* afm2tfm.c,\n\t* dvips.texi: version 5.995 for TL'15.\n\n2015-02-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am: Use the fragment ../../am/dist_hook.am.\n\n2014-07-15  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* t1part.c, t1part.h: Rename _HUGE => BORLAND_HUGE to avoid\n\tconflicting names.\n\n2014-06-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* afm2tfm.c, dospecial.c, emspecial.c, resident.c, writet1.c:\n\tAvoid undefined behaviour when char is signed.\n\n2014-06-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* {,squeeze/}Makefile.am: Drop the obsolete ACLOCAL_AMFLAGS.\n\n2014-04-17  Karl Berry  <karl@tug.org>\n\n\t* version 5.994 for TL'14.\n\n2014-01-27  TANAKA Takuji  <KXD02663@nifty.ne.jp>\n\n\t* dvips.c: Revise procedure of reading command line arguments.\n\t(Windows only)\n\n2014-01-13  TANAKA Takuji  <KXD02663@nifty.ne.jp>\n\n\t* dvips.c, resident.c: Allow multibyte string with 0x5c\n\tin CP932-like system. (Windows only)\n\t* dvips.c, output.c, search.c: Allow Unicode file names.\n\t(Windows only)\n\n2013-09-16  Karl Berry  <karl@tug.org>\n\n\t* writet1.c: formatting tweaks.\n\n2013-08-31  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* writet1.c (t1_subset_ascii_part): Remove UniqueID.\n\tReport from Christian Zietz (czietz/gmx/net),\n\ttex-k 01 Sep 2013 11:25:47 and previous.\n\n2013-08-05  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* bbox.c: Fix a bug in bbdopage() to obtain correct BoundingBox in\n\tvertical mode of pTeX.\n\n2013-05-30  Karl Berry  <karl@tug.org>\n\t\n\t* version 5.993 for TL'13.\n\n2013-04-07  Karl Berry  <karl@tug.org>\n\n\t* resident.c (getdefaults) <m>: if <= 0, set to INT_MAX.\n\tBug report from Stepan Orevkov and Bruno Delprat, as part\n\tof their Mayan TeX system (info on which:\n\thttp://tug.org/TUGboat/tb33-3/tb105delprat.pdf).\n\t\n        It seems there is a bug related to Dvips' section splitting and\n        partial font downloading/font reuse, such that only the\n        characters from the first section are available through the\n        entire output.  I wasn't up for dealing with that; as a\n        workaround, the above maximizes Dvips' memory available, so no\n        splitting is done.\n         \n2013-04-05  Karl Berry  <karl@tug.org>\n\n\t* configure.ac,\n\t* dvips.texi,\n\t* dvips.h,\n\t* afm2tfm.2c: 5.993 to prepare for TL'13 pretest.\n\n2013-03-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* same-name.test: New test with oname == iname.\n\t* Makefile.am: Add the new test.\n\n2013-03-18  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* dvips.c: Check if oname != iname.\n\n2013-02-08  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am (prologdir): Change texmf => texmf-dist.\n\n2013-01-21  Karl Berry  <karl@tug.org>\n\n\t* test-dvips: rename from dvips.test, to avoid new Automake 1.13\n\tmake check failure, since it can't create dvips.log in the\n\tevent that dvips.log already exists (from running dvips.texi).\n\tEven though one is in the srcdir and one in the builddir ...\n\tUse test-dvips rather than dvips-test just to help filename completion.\n\t* Makefile.am (TESTS): rename.\n\n2013-01-18  Karl Berry  <karl@tug.org>\n\n\t* writet1.c: apply diffs (cast removals) from pdftex.\n\n2012-12-17  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* squeeze/Makefile.am: Enable silent rules.\n\n2012-12-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* finclude.c: Drop unused variable (gcc-4.6 warning).\n\n2012-11-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am: Avoid use of deprecated INCLUDES.\n\n2012-08-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* ptexmac.h: Drop unused definition of M_PI & Co.\n\n2012-07-01  Karl Berry <karl@freefriends.org>\n\n\t* Release of 5.992 for TeX Live 2012.\n\n2012-04-01  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* dvips.c: do not free getenved string.\n\n2012-03-30  Norbert Preining  <preining@logic.at>\n\n\t* resident.c: add new directive \"c<filename> to config files, allowing\n\tto include other config files.\n\t* dvips.texi: document it.\n\t* contrib/config.proto: add example.\n\t \n2012-03-15  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am: Fixed a typo (in comment).\n\n2011-12-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am: Replace ${prefix}/texmf => $(datarootdir)/texmf.\n\n2011-10-20  Werner Fink <werner@suse.de>\n\n\t* dospecial.c (fgetboundingbox): Increase `buf' size to avoid\n\toverrun.\n\n2011-10-04  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am (EXTRA_DIST, DISTCLEANFILES): Make sure that\n\t'make distclean' removes all generated files.\n\n2011-07-26  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* bbox.c, dopage.c, dvips.c, pprescan.c, scanpage.c, dvips.1,\n\tdvips.help, dvips.info and dvips.texi: pTeX with otf package\n\tby S. Saito requires set2, put2, and independent options\n\t-noomega and -noptex.\n\n2011-06-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* afm2tfm.c (openfiles), resident.c (residentfont): Allow\n\tfind_suffix() to return a const string.\n\n2011-06-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* protos.h, loadfont.c (pkopen), search.c (pksearch): Declare\n\tfont name as const.\n\n2011-05-06  Karl Berry  <karl@tug.org>\n\n\t* writet1.c: update copyright as in pdftexdir.\n\n2011-04-25  Karl Berry  <karl@tug.org>\n\n\t* afm2tfm.c (version),\n\t* dvips.h (BANNER): 5.991 for TeX Live 2011.\n\t\n\t* dvips.texi,\n\t* dvips.1: do not suggest that the default output is to lpr.\n\n2011-02-25  Karl Berry  <karl@tug.org>\n\n\t* drawPS.c (flushDashedPath): cast to double before squaring,\n\tto avoid integer overflow.  (I guess this was hidden before by the\n\tassignment cast to float?  Said to work in 2009, failed in 2010.)\n\t* eepic-nan.test,\n\t* testdata/eepic-nan.tex,\n\t* testdata/eepic-nan.dvi,\n\t* testdata/config.pdf,\n\t* testdata/alt-rule.pro,\n\t* testdata/tex.pro: new files to test.  Report from Stefan Moser\n\tto mactex-support, 20 Oct 2010 02:37:45.\n\t* Makefile.am (tests): add eepic-nan,\n\t(EXTRA_DIST): add new files.\n\n2011-02-14  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* output.c: print R2 mode message only when secure == 2.\n\n2011-01-29  Karl Berry  <karl@tug.org>\n\n\t* search.c (search): report the actual popen call if D_FILES.\n\t* quotecmd.tex: make test filename match quotecmd-test.pl.\n\t* quotecmd.dvi: regenerate.\n\t* quotecmd-test.pl: doc fixes.\n\n2011-01-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am: Add testdata/quotecmd.dvi to EXTRA_DIST.\n\n2011-01-28  Karl Berry  <karl@tug.org>\n\n\t* quotecmd-test.pl, testdata/quotecmd.tex: doc fixes.\n\t* testdata/quotecmd.dvi: add to repo, since the test relies on\n\tthis file existing.\n\n2010-12-01  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writet1.c: Still more tweaks. Remove unused code and vars.\n\n2010-11-29  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writet1.c: Further reduce diffs against pdftex's writet1.c.\n\tDeclare t1_encoding as enum instead of int.\n\tChange t1_builtin_enc() from void to char **.\n\n\t* writet1.c, protos.h: Replace void load_enc(char *, const char **)\n\tby char **load_enc_file(char *).\n\t* download.c (getEncoding): Adapt, and change result to non-const.\n\tSomewhat better use of DOWNLOAD_USING_PDFTEX.\n\n2010-11-29  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writet1.c (t1_check_unusual_charstring): Drop unused variable.\n\n2010-11-26  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writet1.c: Still more minor tweaks.\n\n2010-11-26  Thanh Han The  <thanh@river-valley.org>\n\n\t* writet1.c (t1_check_unusual_charstring): switch EOL to space\n\tbefore appending.\n\n2010-11-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writet1.c: Still more formatting tweaks.\n\n2010-11-14  Karl Berry  <karl@tug.org>\n\n\t* writet1.c: endless formatting tweaks.\n\n2010-11-13  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* download.c: Change i<MAX_CHAR_CODE into i<=MAX_CHAR_CODE, because\n\tMAX_CHAR_CODE is 255 now.\n\n2010-11-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* download.c [MAX_CHAR_CODE]: Define as 255 (not 256).\n\n\t* writet1.c: More formatting and other trivial changes, to\n\tfurther reduce diffs against pdftex's writet1.c.\n\n2010-11-12  Karl Berry  <karl@tug.org>\n\n\t* writet1.c: formatting changes only, to reduce diffs against\n\tpdftex's writet1.c.\n\n2010-11-11  Thanh Han The  <thanh@river-valley.org>\n\n\t* writet1.c (t1_check_unusual_charstring): new fn.\n\t(t1_subset_charstrings): call it.  This resolves a bug reported by\n\tKnuth when there is a newline between the /CharStrings and the\n\tfollowing number (dict size).\n\n2010-10-23  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* output.c (hvpos): simplify the change 2010-10-22.\n\tMany thanks Peter.\n\n2010-10-22  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* output.c (hvpos): recover the old code in hvpos() for japanese\n\tbecause the changed code leads to incorrect result in some cases.\n\tother cases than japanese are not affected.\n\n2010-10-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* search.c (selfautoloc_prog): #include <kpathsea/concatn.h>\n\tfor WIN32 and drop cast of concatn() results.\n\n2010-06-19  Yan Li  <yan.i.li@intel.com>\n\n\t* tfmload.c (name): increase size to 500.\n\t(tfmopen): check for name length overflow.\n\n2010-06-13  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi: update for 2010.\n\n2010-06-04  Karl Berry  <karl@tug.org>\n\n\t* afm2tfm.c (version),\n\t* dvips.h (BANNER): 5.99 for TeX Live 2010 (pretest 2, maybe final).\n\n2010-05-25  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* config.ps: include cid-base.map.\n\n2010-05-25  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* search.c: quote command in W32 case to allow path name\n\twith spaces.\n\n2010-05-18  Karl Berry  <karl@tug.org>\n\n\t* config.h (type1path): rename from type1.\n\t* writet1.c (t1_open): use type1path, not headerpath.\n\n\t* configure.ac (AC_INIT),\n\t* afm2tfm.c: (version),\n\t* dvips.c (main), \n\t* dvips.h (BANNER): 5.99/pretest, 2010.\n\n2010-05-14  Karl Berry  <karl@tug.org>\n\n\t* resident.c,\n\t* output.c: more sprintf -> snprintf.\n\n2010-05-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* dvips.h [SET_BINARY]: Add cast to void.\n\t* afm2tfm.c, finclude.c, output.c, search.c (SET_BINARY): Once\n\tagain remove casts to void.\n\n2010-05-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* all files: Remove more useless casts to void.\n\n\t* afm2tfm.c, finclude.c, output.c, search.c: Reintroduce a few\n\tcasts to void, to avoid warnings (statement has no effect).\n\n2010-05-10  Karl Berry  <karl@tug.org>\n\n\t* drawPS.c,\n\t* flib.c,\n\t* finclude.c,\n\t* afm2tfm.c,\n\t* hps.c,\n\t* emspecial.c,\n\t* dospecial.c: more snprintf.\n\n\t* all files: remove useless casts to void.\n\n\t* dosection.c (dosection),\n\t* dospecial.c (dospecial): use snprintf, just in case.\n\n2010-05-07  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* output.c: correct wrong boundary values of characters.\n\t(from Takuji Tanaka <KXD02663@nifty.ne.jp>.)\n\t* protos.h, dvips.c, output.c, resident.c: remove unnecessary SJIS option.\n\t(from Takuji Tanaka <KXD02663@nifty.ne.jp>.)\n\t(a commit r18123 seemes to be eliminated, so try again)\n\n2010-05-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* dosection.c (dosection): Add newline before \"@start\".\n\t* testdata/*.pro, testdata/*.xps: Updated.\n\n2010-05-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* bbox.c: Declare functions used only in this file as static,\n\tremove trailing whitespace.\n\t* color.c: The same.\n\t* dosection.c: The same.\n\t* dospecial.c: The same.\n\t* dpicheck.c: The same.\n\t* drawPS.c: The same.\n\t* dviinput.c: The same.\n\t* dvips.c: The same.\n\t* emspecial.c: The same.\n\t* finclude.c: The same.\n\t* header.c: The same.\n\t* hps.c: The same.\n\t* loadfont.c: The same.\n\t* output.c: The same.\n\t* papersiz.c: The same.\n\t* repack.c: The same.\n\t* resident.c: The same.\n\t* t1part.c: The same.\n\t* tfmload.c: The same.\n\t* unpack.c: The same.\n\t* virtualfont.c: The same.\n\t* writet1.c: The same. Skip compilation of unused functions.\n\t* protos.h: Remove all these extern declarations.\n\t* t1part.h: Remove unused K&R function declarations.\n\n2010-05-06  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi: use p@TeX{} for the manual.\n\n2010-05-05  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* output.c: revert cmdout() and remove lastspecial=1 in jscout().\n\tThanks Peter.\n\n2010-05-05  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* output.c: rewrite the previous fix not to change the output format\n\tfor non-pTeX dvi.\n\n2010-05-05  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* output.c: minor fix of the function cmdout(). Without the fix, broken\n\tps is generated for pTeX's dvi.\n\n2010-05-05  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tImplement pTeX extensions, based on patches sent by Akira.\n\tModified to reproduce former output files. Added -noptex option.\n\t* bbox.c, color.c, dopage.c, dospecial.c, download.c, drawPS.c,\n\tdvips.[ch], finclude.c, fontdef.c, loadfont.c, output.c,\n\tpprescan.c, prescan.c, protos.h, protos_add.h, repack.c,\n\tresident.c, scanpage.c, search.c, skippage.c, tex.lpro,\n\ttfmload.c, virtualfont.c: pTeX extensions.\n\t* dvips.1, dvips.help, dvips.texi: Documentation.\n\n2010-05-03  Jan Lieskovsky  <jlieskov@redhat.com>\n\n\t* dospecial.c (predospecial, bbdospecial): avoid numeric overflow.\n\ttetex-3.0-CVE-2010-0739,1440-integer-overflows.patch,\n\tfrom Ludwig Nussel, Karel Srot.\n\ttlsecurity mail 30 Apr 2010 16:59:37.\t\n\n2010-04-26  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* afm2tfm.c: (write16()): cast argument to short to avoid warning.\n\n2010-04-25  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* writet1.c (edecrypt()): cast argument to byte to avoid warning.\n\t* dvips.c: Use IS_DIR_SEP for the test of a directory separator.\n\n2010-04-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am (EXTRA_DIST): Add afm2tfm-test.pl.\n\n2010-04-11  Karl Berry  <karl@tug.org>\n\n\t* afm2tfm.c (staticligkern): restore spaces around semicolons,\n\taccidentally removed in source cleanup.\n\t\n        * afm2tfm.c (throughout): use snprintf where needed.\n\n\t* afm2tfm-test.pl: New test script for afm2tfm.\n\n\t* Makefile.am (TESTS): Add the new test.\n\n2010-03-29  Karl Berry  <karl@tug.org>\n\n\t* loadfont.c,\n\t* tfmload.c,\n\t* virtualfont.c: concatn terminates with NULL.  From Akira.\n\n2010-03-28  Karl Berry  <karl@tug.org>\n\n\t* all files: no spaces before semicolons.\n\n\t* loadfont.c,\n\t* tfmload.c,\n\t* virtualfont.c,\n\t* bbox.c,\n\t* writet1.c,\n\t* dvips.c,\n\t* header.c: dynamically concatenate more error strings.\n\t* protos.h (errbuf): increase.\n\n2010-03-26  Karl Berry  <karl@tug.org>\n\n\t* virtualfont.c (badvf, virtualfont): use concat[n] instead of\n\t\tsprintf for error messages.\n\t(<kpathsea/concatn.h>): #include.\n\n\t* virtualfont.c (vfopen): do not sprintf too long of a name.\n\tCVE-2010-0827, found by Dan Rosenberg.\n\n\t* dospecial.c (predospecial): avoid seg fault from integer overflow.\n\tCVE-2010-0739, found by Marc Schoenefeld, patch prepared\n\tby Jindrich Novy.\n\n2010-02-26  Karl Berry  <karl@tug.org>\n\n\t* search.c (selfautoloc_prog, quote_name): remove kpse_ prefix for\n\tthe time being, since it seems web2c's safeness stuff can't be\n\teasily factored into using them.\n\n2010-02-23  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* search.c: #include <kpathsea/variable.h> for kpse_var_value.\n\n2010-02-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am (EXTRA_DIST): Add the new files.\n\n2010-02-19  Karl Berry  <karl@tug.org>\n\n\t* search.c (kpse_self_autoloc_prog) [WIN32]: p needs to be\n\twritable.  From Akira.\n\n2010-02-18  Karl Berry  <karl@tug.org>\n\n\t* Makefile.am (TESTS): add quotecmd-test.pl.\n\t* quotecmd-test.pl,\n\t* testdata/quotecmd.tex: new files.\n\t* search.c (search): selfautoloc gunzip, and quote name before\n\tcalling popen.\n\t(kpse_quote_name, kpse_self_autoloc_prog): new fns,\n\tonly temporarily here until we factor out the common code from\n\ttexmfmp.c.\n\n2010-02-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* dvips.c (main): Add '#if defined(KPSE_DEBUG)' to allow\n\tcompilation with '-DNO_DEBUG'.\n\n2010-02-12  Karl Berry  <karl@tug.org>\n\n\t* search.c: remove non-KPATHSEA code.  It just got too confusing\n\tto keep track of which conditional we were in.  (And non-KPATHSEA\n\thasn't actually worked or been used for many years, as far as I know.)\n\n2010-02-01  Karl Berry  <karl@tug.org>\n\n\t* dvips.h: switch banner to 5.98dev\n\t* writet1.c (append_cs_return): cast to byte * to avoid warning.\n\n2010-01-03  Karl Berry  <karl@tug.org>\n\n\t* output.c (copyfile_general) <default>: write newline\n\tafter writing possibleDSCLine.\n\t* beginfontk1.test,\n\t* testdata/beginfontk1.{tex,eps}: new test.\t\n\tReport from T S, 1 Jan 2010 16:32:16,\n\tfix from Akira Kakuto, 02 Jan 2010 09:07:19.\n\n\t* Makefile.am (TESTS_ENVIRONMENT): set TEXFONTS instead of\n\tTFMFONTS, VFFONTS, and TEXFONTMAPS.\n\n2010-01-02  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi (Debug options),\n\t* dvips.1: update.\n\tReport at http://bugs.debian.org/269638.\n\n2009-12-24  Karl Berry  <karl@tug.org>\n\n\t* INSTALLATION: rm stale file.\n\t* reencode: remove stale dir, except ...\n\t* contrib/treen.sh, contrib.treen2.sh: ... preserve this.\n\t* Makefile.am (EXTRA_DIST): update\n\n\t* AUTHORS, README, dvips.1, contrib/config.proto: doc updates.\n\t* INSTALL: remove, completely stale.\n\n2009-12-22  Karl Berry  <karl@tug.org>\n\n\t* debug.h (D_MEM): disable completely by defining to 0.\n\tMemory allocations just don't seem to be interesting.\n\n2009-12-21  Karl Berry  <karl@tug.org>\n\n\t* protos.h (fil2ps): remove decl.\n\t* dospecial.c (fil2ps): remove fn.\n\t(dospecial): warn if iff2ps or tek2ps specials are noticed.\n\tThe goal here was to avoid executing external programs, with that\n\tinhererent security risk, when (we believe) no one is actually\n\tusing the functionality.\n\n2009-12-14  Karl Berry  <karl@tug.org>\n\n\t* emspecial.c (emspecial):\n\tIncrease size of emunit to 30.\n\tIncrease size of emstr to 250.\n\tAttempt to check that we don't overflow emstr.\t\n\tReport from Alexander, tlsec 02 Dec 2009 00:28:33.\n\n\t* pc: remove obsolete subdir.\n\t* Makefile.am (EXTRA_DIST): rm.\n\n2009-12-11  Alexander Cherepanov  <cherepan@mccme.ru>\n\n\t* protos.h (hash): change decl.\n\t* resident.c (hash): return and use unsigned instead of int.\n\ttlsec mail, 05 Dec 2009 19:09:56.\n\n2009-09-26  Karl Berry  <karl@tug.org>\n\n\t* config/config.ps (unknown): move to before nopaper; else\n\tnonstandard paper sizes, e.g., with the geometry package,\n\tend up unrecognized.\n\n2009-08-26  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* testdata/dvipstst.xps, pfbincl.xps: Update for version 5.98.\n\n2009-08-25  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tAvoid maximal compiler warnings. Done in steps.\n\n\tStep 1: Move all extern decls for global variables to headers.\n\t* Makefile.am: Additional file 'protos_add.h'.\n\t* protos.h: Add prototype for fliparse() from flib.c.\n\tRemove prototypes from squeeze.c (now in squeeze/).\n\tAdd extern decls for globals from dopage.c, dosection.c,\n\tdvips.c, flib.c, hps.c, loadfont.c, output.c, pprescan.c,\n\trepack.c, resident.c, search.c, and tfmload.c.\n\t* color.c, dosection.c, dospecial.c, download.c, dpicheck.c,\n\tdrawPS.c, dviinput.c, emspecial.c, finclude.c, fontdef.c,\n\theader.c, makefont.c, output.c, paths.h, pprescan.c,\n\tprescan.c, repack.c, resident.c, scanpage.c, skippage.c,\n\ttfmload.c, virtualfont.c: Drop extern declarations.\n\t* writet1.c: Remove '#ifndef pdfTeX' sections of code.\n\tDrop extern declarations.\n\t* dvips.c, hps.c: #include \"protos.h\" before defining globals.\n\tDrop extern declarations.\n\t* protos_add.h (new): First #include \"protos.h\", then add\n\textern decls for stack from dopage.c and name from loadfont.c.\n\t* bbox.c, dopage.c, flib.c, loadfont.c, search.c:\n\t#include \"protos_add.h\" (instead of protos.h). Drop externs.\n\n\tStep 2: Avoid warnings: declaration of 'xxx' shadows a parameter\n\tor previous local:\n\t* dospecial.c (predospecial): Rename local numbytes=>num_bytes,\n\tnot to shadow function param.\n\tDrop inner local j, not to shadow previous local.\n\n\tStep 3:\n\t* afm2tfm.c (vlevout, vlevnlout), download.c (clearExtraGlyphList):\n\tANSI C function definitions, i.e., '()'=>'(void)'.\n\n\tStep 4: Constification of strings:\n\tStep 4a: Struct members\n\t* afm2tfm.c (encoding.name, encoding.vec, adobeinfo.adobename,\n\tlig.succ, lig.sub, kern.succ, pcc.partname),\n\tdospecial.c (KeyDesc.Entry),\n\tdownload.c (seenEncodings.name, seenEncodings.glyphs),\n\tdvips.h (header_list.Hname, papsiz.name, papsiz.specdat),\n\temspecial.c (emunit.unit), t1part.c (tablecommand.command,\n\ttypefonts.extension, type_key.name).\n\tStep 4b: Global or static variables\n\t* afm2tfm.c (staticligkern, vplligops, encligops, fontname,\n\tcodingscheme, interesting, accents), dospecial.c (ValStr, tasks),\n\tdvips.c (oname, infont, headerfile, helparr),\n\temspecial.c (extarr), output.c (hxdata), papersiz.c (scalenames),\n\tresident.c (psmapfile),\n\tt1part.c (RefKey, hexstr, AfmKey, InfoKey),\n\twritet1.c (hexdigits), protos.h.\n\tStep 4c: Function parameter/results and local variables\n\t* afm2tfm.c (error, interest, expect, findadobe, makebcpl,\n\tchecksum, texheight),\n\tdospecial.c (specerror, IsSame, dospecial, fil2ps),\n\tdownload.c (getEncoding, addGlyph, downpsfont),\n\tdvips.c (help, error_with_perror, error, initialize, newstring,\n\tmain),\n\tfinclude.c (scan_fontnames, scanfontusage, scanfontcomments),\n\theader.c (add_name, add_name_general, checkhmem, add_header,\n\tadd_header), hps.c (set_bitfile), loadfont.c (badpk),\n\toutput.c (copyfile_general, copyfile, cmdout, mhexout, nlcmdout,\n\tncstrcmp, paperspec), papersiz.c (myatodim[B\n\tresident.c (bad_config, getdefaults, getpsinfo),\n\tsearch.c (search, pksearch, my_real_fopen), tfmload.c (badtfm),\n\tunpack.c (unpack), virtualfont.c (badvf),\n\twritet1.c (pdftex_fail, pdftex_warn, load_enc, t1_open_fontfile,\n\tt1_subset), protos.h.\n\tStep 4d: Work around modifying const strings (e.g., modify\n\tmalloc'ed or strdup'ed strings before assigning them to a const\n\tstring variable):\n\t* afm2tfm.c (openfiles), dvips.c (newstring, newoutname),\n\tresident.c (getdefaults).\n\n2009-08-22  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* afm2tfm.c, dvips.c: #include <kpathsea/version.h> and drop\n\tnested extern decls.\n\n2009-07-17  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writet1.c (t1_flush_cs): cast ptr diff to unsigned long for\n\tprinting.\n\tNB: sizeof(ptr)==sizeof(long) for both 32Bit and 64Bit systems.\n\n2009-07-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* squeeze/squeeze.c (__CYGWIN__): #include <unistd.h> and <io.h>\n\tfor isatty and setmode.\n\n2009-06-22  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am (AM_CFLAGS): enable compiler warnings.\n\n\t* Use ANSI C function definitions and prototypes instead of\n\tP[1-9][CH] macros, declare some functions as static.\n\t* config.h, writet1.c: no need to #include <kpathsea/c-proto.h>.\n\t* writet1.c: #include <stdarg.h>, not <kpathsea/c-vararg.h>.\n\n\t* dpicheck.c: #include \"protos.h\".\n\n\t* t1part.c (Reeverse, KillUnique): declare as static.\n\n\t* writet1.c: #include \"protos.h\".\n\t(append_cs_return): remove unused variable 'i'.\n\t(t1_flush_cs): avoid uninitialized warning.\n\t* protos.h: add prototypes for writet1(), t1_free(), and\n\tt1_subset() from writet1.c.\n\n\t* Avoid inconsistent arg1 in KPATHSEA version of pksearch (was\n\tunused but different in prototype, declaration, and call).\n\t* loadfont.c: remove arg1 of pksearch.\n\t* protos.h: use prototype for pksearch as defined in search.c.\n\t* search.c: #include \"protos.h\", remove prototype for newstring.\n\t(pksearch): remove unused arg1.\n\n2009-06-22  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am (AM_CPPFLAGS): remove -DNeedFunctionPrototypes.\n\t* config.h, dvips.h: always use ANSI C function definitions.\n\n2009-06-12  Francois Charette  <firmicus@ankabut.net>\n\n\t* afm2tfm.c: rename getline to texlive_getline.\n\n2009-06-01  Karl Berry  <karl@tug.org>\n\n\t* Update version numbers to 5.98.\n\n2009-05-30  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* texc.script: use correct invocation of sed.\n\n2009-05-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tAdapt to TL2009 build system.\n\n2009-05-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* testdata/*: recover old test data and add missing pieces.\n\t* texc.script: use sed instead of ed (which may be missing).\n\n2009-05-24  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi (Configuration file commands): document -G,\n\tincluding its obsolesence.\n\t* Master/texmf/dvips/tetex/config.pdf: remove the G setting,\n\tnow actively problematic.  Report from Uwe Siart,\n\t04 May 2009 09:27:27.\n\n2009-05-08  Karl Berry  <karl@tug.org>\n\n\t* resident.c (getpsinfo): avoid accessing unallocated downbuf[-1].\n\t* dvips.c (main): do not check iname[-1] if there is no iname.\n\tReports from Akira.\n\tAlso prettify some related error messages.\n\n2009-04-04  Karl Berry  <karl@tug.org>\n\n\t* writet1.c (append_cs_return): new fn.\n\t(cs_mark): check for missing return in subr.\n\t(t1_flush_cs): repair missing return.\n\t(t1_scan_param): check for negative lenIV.\n\tThese changes from Thanh, following more investigation by Melissa,\n\tChoF, and Thanh.\n\n2009-03-24  Karl Berry  <karl@tug.org>\n\n\t* writet1.c (t1_flush_cs): t1_lenIV >= 0, not\n\tt1_lenIV > 0, to fix subset problems on Macs.  Found by Melissa\n\tO'Neill.  Reported on ntg-pdftex@ntg.nl and pdftex@tug.org,\n\t21 March, 2009 13:45:12.\n\n2009-02-16  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi (Config file paper sizes): document.\n\t* config.ps (nopaper): new paper size to put no paper size\n\tcommands in the output, e.g., for multi-page EPS.\n\tReport from John Bowman for Asymptote.\n\n2008-11-02  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi (psfonts.map): apparently {somefile.pfb} was never\n\tused to report partial downloading; also mention vf's a bit more.\n\n2008-09-24  Karl Berry  <karl@tug.org>\n\n\t* hps.c, hps.lpro: Mark (doyle/aps/org) does not want to be\n\tnotified of changes any longer (or for the past decade or so :).\n\n2008-09-22  Karl Berry  <karl@tug.org>\n\n\t* hps.c (do_html): get scale factors right.\n\t(hoff, voff): remove, hh and vv are already calculated by using\n\thoff and voff in dopage.c.\n\tFrom Akira.  Report from John Frampton through tex-eplain;\n\tusing -O made -z fail.\n\n2008-09-20  Karl Berry  <karl@tug.org>\n\n\t* papersiz.c (myatol): do not require a leading zero, to match the doc.\n\tFrom Akira.  Report from John Frampton through tex-eplain.\n\n2008-07-10  Karl Berry  <karl@tug.org>\n\n\t* dvips.h (BANNER): 5.97, 2008.\n\t* dvips.c (main): use BANNER.\n\t* afm2tfm.c: 5.97.\n\t* dvips.texi (version): 5.97.\n\t\n2008-05-07  David M. Jones  <dmj@ams.org>\n\n\t* output.c (copyfile_general): pass through binary characters such\n\tas CTRL-D inside %%BeginFont, else embedded pfb's can get mangled.\n\ttex-live mail 5 May 2008 13:11:10, tex-k mail 5 May 2008 14:08:04.\n\n2008-05-01  Karl Berry  <karl@tug.org>\n\n\t* squeeze.c [O_BINARY]: conditionalize calls to SET_BINARY.\n\n2008-04-30  Karl Berry  <karl@tug.org>\n\n\t* squeeze.c (SET_BINARY) [O_BINARY]: conditionalize #define.\n\tCast call to specialout.  (From Akira.)\n\n2008-04-29  Karl Berry  <karl@tug.org>\n\n\t* Makefile.in (install-data): do not cd $(srcdir) in any rule,\n\tthat fails when the install program is specified by a relative path.\n\n\t* squeeze.c: avoid all old-system conditionals, linking with\n\tkpathsea, etc.\n\n2008-04-28  Karl Berry  <karl@tug.org>\n\n\t* dvips.h: id.\n\t* squeeze.c [!KPATHSEA]: conditionalize #undef fopen,\n\tand add decl with return type.\n\t* afm2tfm.c: semi-prototype fopen if it got #undef'd.\n\tBug report from vvv, 27 Apr 2008 13:43:37.\n\n2008-02-29  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* acconfig.h: removed.\n\n2008-02-17  Karl Berry  <karl@tug.org>\n\n\t* config.ps (smallbook): new paper size for Texinfo.\n\n2008-01-31  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tConvert from autoconf-2.13 to autoconf-2.59+:\n\t* Makefile.in: Add @configure_input@ line.\n\t* aclocal.m4 (new): Generated (aclocal -I ../m4).\n\t* configure: Regenerated (autoconf).\n\n2007-12-23  Karl Berry  <karl@tug.org>\n\n\t* dvips.c (helparr): Start options with -, include url.\n\n2007-12-02  Karl Berry  <karl@tug.org>\n\n\t* skippage.c (skippage): do not test for noomega here; we aren't\n\tactually parsing the DVI operations, so argument bytes can\n\terroneously cause complaints.\n\tReport on tex-live from W. Fleischer, 27 Nov 2007 17:43:47.\n\n2007-10-24  Karl Berry  <karl@tug.org>\n\n\t* config.ps (unknown): duplicated entry, remove one.\n\n2007-10-22  Karl Berry  <karl@tug.org>\n\n\t* hps.c (stamp_external, stamp_hps): protext against long strings.\n\tFrom Bastien Roucaries via Norbert, 21 Oct 2007 13:22:19,\n\tDebian bug 447081.\n\n2007-10-12  Karl Berry  <karl@tug.org>\n\n\t* resident.c (i): declare as int, in case tfmload() returns 65536\n\tfor an ofm font.\n\tFrom Akira, 11 Oct 2007 11:39:52.\n\n2007-09-24  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi (psfile special): document llx/lly/urx/ury, based on\n\ta description from Tom R.\n\n2007-08-28  Karl Berry  <karl@tug.org>\n\n\t* dvips.h: clarify license (again).\n\n2007-06-13  Karl Berry  <karl@tug.org>\n\n\t* config.ps: use integral mm values (from Akira).\n\n2007-06-10  Karl Berry  <karl@tug.org>\n\n\t* dospecial.c: implement ps::nobreak for Scott (Pakin); we need\n\tto break by default because pstricks is written to assume that,\n\tand we can't ask Herbert to rewrite thousands of lines of code.\n\n2007-05-31  Karl Berry  <karl@tug.org>\n\n\t* hps.c (finish_hps): remove head.tmp and body.tmp unless\n\twe are debugging.  Report from Dan Luecking, 25 May 2007 13:00:17,\n\tfix from Akira.\n\n2007-05-09  Karl Berry  <karl@tug.org>\n\n\t* dvips.c, finclude.c: cleanups of my patching from Akira.\n\n2007-05-06  Karl Berry  <karl@tug.org>\n\n\t* finclude.c, dvips.c: keep track of last-unused psname (Akira).\n\t* dvips.c (DEFRES): move down.\n\t* dvips.c (--help): just mention Tom R.\n\n2007-05-05  Karl Berry  <karl@tug.org>\n\n\t* dvips.h (DOWNLOADEDPSSIZE): new constant.\n\t* dvips.c (downloadedpsname): new global array.\n\t* finclude.c: set it up as we download.\n\t* download.c: use it to avoid downloading fonts as both header\n\tand font.  (From Akira.)\n\n2007-05-04  Karl Berry  <karl@tug.org>\n\n\t* dvips.h (BANNER): change to 5.96dev to distinguish from the release.\n\n\t* header.c (add_name, add_header): cast result of\n\tadd_header_general to int and return it.  From Akira.\n\n2007-03-23  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi: document it.\n\t* dvips.c, loadfont.c, resident.c: also report map files\n\tand config files, if the envvar DVIPSDEBUG is set.  From Akira.\n\n2007-03-20  Karl Berry  <karl@tug.org>\n\n\t* download.c, output.c, emspecial.c: report full pathnames,\n\tto help debugging and for consistency with TeX.  From Akira.\n\n2007-03-19  Karl Berry  <karl@tug.org>\n\n\t* config.ps (screen): add this, 8.25x11, for powerdot.  (From Akira.)\n\n2006-12-09  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi (Config file paper sizes): best match now.  (From Akira.)\n\n2006-12-07  Karl Berry  <karl@tug.org>\n\n\t* Changes made and accumulated by Akira:\n(1) security problem\n    -R0  : shell escape and absolute path are allowed\n    -R1  : shell escape is forbidden and absolute path is allowed\n           (default)\n    -R2  : shell escape and absolute path are forbidden\n\n(2) line breaking problem in ps: special (Scott Pakin).\n\n(3) Heiko's change of hps.lpro.\n\n(4) paper size problem:\n  *   Is the dimension close enough for a match?  We use a quarter inch\n  *   as a match; this is 65536*72.27/4 or 1,184,072 scaled points.\n--->\n  *   Is the dimension close enough for a match?  We use 5bp\n  *   as a match; this is 65536*72.27*5/72 or 328909 scaled points.\nand dvips now finds the best match rather than the first match.\n\n2006-12-06  Karl Berry  <karl@tug.org>\n\n\t* output.c (copyfile_general): add removingBytes=0, to avoid\n\tomitting the line after %%EndData or %%EndBinary with -K1.\n\ttex-k mail from t s, 29 Nov 2006 21:11:14.\n\n2006-12-05  Karl Berry  <karl@tug.org>\n\n\t* dvips.h (BANNER): bump version to 5.96 for 2006, why not.\n\n2006-07-06  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi: mention -tunknown to avoid floating to predefined\n\tpaper size. From Vincent Fourmond, tex-k mail, 25apr06.\n\n2006-06-02  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi: typo\n\n2004-05-10  Karl Berry  <karl@tug.org>\n\n\tFrom Matthew Swift <swift@alum.mit.edu>, via Debian bug 181065:\n\t* config.ps: improve comments.\n\t* output.c (open_output) [DJGPP]: do not disable writing to a pipe\n\t\twhen secure; we don't do that in the non-DJGPP case.\n\t* dvips.texi (Option details): -R does not disable output to a pipe.\n\t(Configuration file commands): typo in `o' doc.\t\t\n\nWARNING:  THIS CHANGELOG IS WAY OUT OF DATE.\n\n2001-06-02  Sebastian Rahtz  <sebastian.rahtz@computing-services.oxford.ac.uk>\n\n\t* resident.c: added option to config file ('z') to have the same\n\teffect as -R (secure mode)\n\nMon Jan 10 21:39:20 CET 2000\n\t* from pdftex distribution: improved partial font downloading\n\tported back\n\t* .notdef related fixes for afm2tfm\n\nSun Apr 11 09:03:29 CEST 1999\n\t* output.c: (from Tom Rokicki)\n\tFaster inclusion of DOS EPSF files. Use byte counter to avoid\n\tcalling ftell().\n\nWed Apr  7 01:07:41 CEST 1999\n\t* Makefile.in: added -DSHIFTLOWCHARS to compiler flags\n\t* output.c: corrected T1Char function for SHIFTLOWCHARS\n\nMon Mar  9 10:31:44 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* clean reencoding/asex.enc; small fix to copyright year (from\n\tThomas Esser)\n\nFri Mar  6 10:56:28 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* dvips.h (BANNER): changed to 5.78, as per Tom. also afm2tfm.c\n\tand dvips.c\n\n\t* tex.lpro: (from Tom Rokicki)\n\tRichard Sites of Adobe found a bug in dvips that\n \tcauses dvips-generated output, when piped through Distiller, to\n \tfail.  The problem is that dvips uses names in its encoding array\n \tthat are `illegal' according to distiller.  I've encouraged him to\n \tpatch up distiller to `do the right thing', but I need to fix\n \tdvips too. The patch I've come up with is to change, in tex.lpro,\n\n\t    0 1 255 {IE S 1 string dup 0 3 index put cvn put} for\n\t to\n\n\t 2 string 0 1 255 { IE S dup 360 add 36 4 index cvrs cvn put } for pop\n\nTue Mar  3 10:15:37 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* afm2tfm.c: Tom Browder <tbrowde@asi-fwb.com>. To fix the case\n\twhere the afm file has a -1 for the CC encoding position\n\nWed Feb 25 10:52:19 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* patches to add facility to shift characters below 32 to higher\n\tpositions, if possible, activated by -G. By default, this is not\n\tactivated, needs -DSHIFTLOWCHARS in the Makefile, as I am not sure\n\tabout it, but the conditional code is there to study for those who\n\twant to experiment\n\nTue Feb 24 11:56:52 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* Makefile.in: clean up check target to be self-contained\n\nMon Feb 23 10:11:57 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* resident.c: changed parsing of \"<<\" so that the font is passed\n\tthrough to be treated as a font, not a procset. it will still be\n\tpartially downloaded, though.\n\nTue Feb 17 10:17:40 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* dvips.c: logic of #ifdef Omega was reversed for help message,\n\tcorrected\n\nMon Feb 16 12:33:30 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* afm2tfm.c: fixes for explicit extension by Thomas Esser:\n\tSeveral things did not work as expected:\n  - removing the suffix by putting \\0 at the position found by\n    find_suffix(outname) does not work, as find_suffix returns the\n    position *after* the last dot\n  - memmove(outname, p, strlen(p)) (where p = basename(outname))\n    should be memmove(outname, p, strlen(p)+1), but I think that\n    we should just use two strcpy calls since memmove is not\n    available on every platform.\n\n\nMon Feb  9 10:56:25 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* put data files for \"make check\" into testdata/, to avoid them\n\tbeing zapped by \"make extraclean\"\n\n\t* patch to dvips.texi from Thomas Esser\n\t\nMon Feb  2 11:32:32 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* small fix in make check target of Makefile.in\n\nTue Jan 27 14:32:25 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* configure etc: new configure.in, c-auto.in, Makefile.in from\n\tOlaf Weber\n\t\nTue Jan 27 13:49:11 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* ChangeLog: changes to \"check\" target (explicit -D\n\t300). regenerated .xps file.\n\nMon Jan 19 20:45:15 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* renamed contrib/volker config.* files to *.cfg, and to shorter\n\tnames (screen to scr) for DOS 8+3 naming\n\n\t* added .tfm and .vf files for make check to directory;\n\tchanged permissions of dvips.texi\n\nSat Jan 17 15:08:57 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t*  assorted patches from Peter Breitenlohner, Olaf Weber, \n \tFabrice Popineau etc. Hope it all still works.\n\nFri Jan 16 21:28:44 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* dvips.c: patch from John Plaice for odvips, to flag odvips as program\n\tname \n\nThu Jan  1 10:59:29 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* provided prebuilt dvipstst.xdv and dvipstst.xps to allow\n\tcheck target to work. \n\nWed Aug 27 20:18:20 1997  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* stamp-auto: Remove this file, should be in build tree, not in\n\tsource tree.\n\n\t* configure.in: Make `configure' rebuild the `stamp-auto' file.\n\nSun Aug 24 18:04:14 1997  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.in: Allow `make check' when $(srcdir) is not `.'.\n\nFri Mar 07 12:10:46 1997  Fabrice POPINEAU  <popineau@ese-metz.fr>\n\n\t* config.h: introduce prototyping when __STDC__ is defined.\n\t* dvips.h: defines a PROTO() macro according to __STDC__.\n\t* dvips.h: getenv() is declared here.\n\n\t* dvips.c:\n\t* emspecial.c:\n\t* output.c:\n\t* resident.c: use the PROTO() declaration.\n\t* resident.c: bad_config was called whitout argument.\n\t* squeeze.c: exit() declaration.\n\t\nThu Feb  6 17:34:06 1997  Karl Berry  <karl@cs.umb.edu>\n\n\t* Version 5.66a.\n\nSat Feb  1 17:15:39 1997  Karl Berry  <karl@cs.umb.edu>\n\n\t* t1part.c: Changes to avoid compiler warnings.  From Tom.\n\n\t* Makefile.in (program_files): dvipstst.dvi should be included\n\tfor make check.\n\tFrom: Joern Clausen <joern@techfak.uni-bielefeld.de>.\n\nSun Jan 19 12:47:37 1997  Karl Berry  <karl@cs.umb.edu>\n\n\t* Makefile.in (version): Now 5.66a.\n\t* dvips.texi: Update version number.\n\t* download, finclude.c, output.c: Update for new version.\n\nFri Jan 17 10:06:25 1997  Karl Berry  <karl@cs.umb.edu>\n\n\t* Makefile.in (version): Now 5.64a.\n\n\t* finclude.c, t1part.[ch], resident.c, output.c, download.c,\n\t\tdopage.c: Update for dvips 5.64.\n\n\t* afm2tfm.c (writevpl): No vname in CHARACTER property.\n\t(version): Now 8.1.\n\nTue Jan 14 14:50:27 1997  Karl Berry  <karl@cs.umb.edu>\n\n\t* hps.c (PAGESIZE): #undef.\n\nMon Jan 13 14:25:07 1997  Karl Berry  <karl@cs.umb.edu>\n\n\t* dvips.h (BANNER): Add www.radicaleye.com per Tom.\n\nSun Jan 12 10:57:34 1997  Karl Berry  <karl@cs.umb.edu>\n\n\t* texps.lpro: Change /setfont line to use cvx instead of load.\n\tFix from Tom, reported by poortom@apmisc.ibm.co.jp for the QMS 1725.\n\nSun Jan  5 12:05:54 1997  Karl Berry  <karl@cs.umb.edu>\n\n\t* Makefile.in: Remove special case for t1part.c, and add it to\n\tobjects.  We compile it normally now.\n\t* bbox.c, dospecial.c, drawPS.c, dvips.c, dvips.h, tex/epsf.tex,\n\tsearch.c, virtualfont.c, tex.lpro, finclude.c\n\tafm2tfm.c: Updates for dvips 5.62.\n\nMon Dec  9 17:24:58 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* t1part.c (CHAR) [WIN32]: #define as CHARACTER to work around\n\t<windows.h> typedef.\n\nSat Dec  7 17:21:37 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* dospecial.c (system): Don't bother to declare, it returns an int.\n\n\t* afm2tfm.c, dvips.c, emspecial.c, output.c, resident.c: Various\n\tWIN32 changes from Fabrice.\n\nTue Dec  3 01:25:28 1996  Ulrik Vieth  <vieth@thphy.uni-duesseldorf.de>\n\n\t* afm2tfm.c: Fix version message.\n\nMon Dec  9 01:29:41 1996  Ulrik Vieth  <vieth@thphy.uni-duesseldorf.de>\n\n\t* afm2tfm.c: Reformat usage message slightly for consistency.\n\tIssue \"Try --help\" message if called with no args.\n\nTue Dec  3 01:25:28 1996  Ulrik Vieth  <vieth@thphy.uni-duesseldorf.de>\n\n\t* afm2tfm.c: Fix version message.\n\nThu Nov 28 09:33:13 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* resident.c: Pass explicit error strings to bad_config.\n\t* dvips.h (INT_FORMAT) [SHORTINT]: Define as %ld or %d.\n\n\t* t1part.c (ScanChars): Cast label[counter].select, which is a char,\n\tto int, for the sake of machines where char is unsigned by default,\n\tsuch as the RS/6000.\n\nWed Nov 27 10:06:27 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* Makefile.in (program_files): Don't bother to include dvipstst.dvi.\n\nFri Nov 15 16:22:42 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* Makefile.in (install-exec): Use INSTALL_LIBTOOL_PROG for\n\tbinaries.\n\nSun Nov 10 16:29:31 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* t1part.c (PartialPFB): Return value from fread is an int,\n\tnot a pointer, so don't compare to NULL.\n\nThu Nov  7 14:53:08 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* papersiz.c (myatodim, myatol): If error, give the erroneous string.\n\nSun Oct 27 16:20:58 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* Makefile.in (check): Don't run TeX.\n\t(program_files): Distribute dvipstst.dvi.\n\n\t* resident.c (c_lineno): Remove invalid second declaration.\n\n\t* t1part.c (PartialPFA): Cast UniRealloc result to avoid warning\n\tfrom SunOS cc.\n\t(UniRealloc) [KPATHSEA_TYPES_H]: Define as xrealloc, not just realloc.\n\nSun Oct 20 11:25:27 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* Makefile.in (install-data): mkdirchain dvips_plain_macrodir.\n\t(post-dist): Link in tex.\n\t*.tex: Move to tex/ subdirectory.\n\nFri Oct 18 14:51:03 1996  Karl Berry  <karl@cs.umb.edu>\n\n\tFrom: Marek Rouchal <marek@btfmd1.fs.uni-bayreuth.de>.\n\tThese changes finish implementing multiple epsf output files.\n\t* bbox.c (findbb): Pass in bop location.\n\t* dvips.c: for -i, default section size to one page.\n\tChange call to initprinter.\n\t* output.c (epsftest): Change call to findbb.\n\t(initprinter): Take sectiontype as parameter instead of page count.\n\nMon Oct 14 11:25:13 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* Changes for NT from Fabrice POPINEAU <popineau@esemetz.ese-metz.fr>.\n\t* hps.c: Rename Rectangle to dvipsRectangle.\n\t* dvips.h (ERROR, NO_ERROR): #undef.\n\t* paths.h (DVIPSRC) [WIN32]: Define as dvips.ini\n\t* output.c: WIN32 conditionals a la MSDOS.\n\nSun Oct 13 13:40:26 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* dvips.c (main),\n\t* output.c (epsftest): Remove condition that document be a single\n \tpage for -E.\n \tSuggested by: Marek Rouchal <marek@btfmd1.fs.uni-bayreuth.de>.\n\n\t* bbox.c, dosection.c, download.c, drawPS.c, dvips.c, finclude.c,\n        fontdef.c, prescan.c, resident.c, virtualfont.c: Keep mag as a\n\treal instead of an integer.\n\tFrom: \"Melissa O'Neill\" <oneill@cs.sfu.ca>.\n\nTue Oct  8 16:47:13 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* Makefile.in (version_files): Add dvips.c.\n\nSat Oct  5 17:00:53 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* dvips.c (main),\n\t* afm2tfm.c (version): Change to the new standard GNU format.\n\n\t* Makefile.in (install-data): Call install-info.\n\t* dvips.texi: Use @url, @email, and @dircategory/@direntry.\n\t\nSat Sep  7 16:01:38 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* dvips.c (help): Include bug reporting address.\n\t* afm2tfm.c (usage): Likewise.\n\nFri Sep  6 19:05:23 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* output.c, dospecial: Call output_with_perror for PostScript\n\toutput file open failure.\n\t* dvips.c (error_with_perror): New routine.\n\nFri Aug 23 16:57:39 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* dvips.c (main): Better bad first/last page errors.\n\nSun Aug  4 15:56:50 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* dospecial.c: Updates from d.love, PAGEUS_INTERUPPTUS is now\n\tpage_interrupt, etc.\n\n\t* hps.c: Use mymalloc instead of malloc where we don't check the\n\treturn value.\n\n\t* dvips.c (main): Also print kpathsea_version_string if --version.\n\nFri Jul 26 15:47:20 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* Makefile.in: Remove co.make.\n\nThu Jul 11 19:17:52 1996  Karl Berry  <karl@laurie>\n\n\t* resident.c: Include variable.h.\n\nMon Jun 10 11:00:35 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* hps.c: Update again from Dave, the last patch got corrupted.\n\nFri Jun  7 18:46:46 1996  K. Berry  <kb@cs.umb.edu>\n\n\t* Makefile.in (afm2tfm, $(program)): Use $(kpathsea_link).\n        (squeeze): Include $(XLOADLIBES).\n\nSat Jun  1 14:36:39 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* resident.c (getdefaults): Use envvar/config value DVIPSRC if set.\n\nThu May 16 22:41:15 1996  Dave Love  <d.love@dl.ac.uk>\n\n\t* texc.lpro: Update to dvihps 0.4 (mostly robuster anchors?).\n\t* dopage.c, hps.c: Likewise.\n\nWed May  1 16:37:00 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * paths.h (DVIPSRC): Prepend $HOME/, so we only search for .dvips\n        in the user's home directory. (Original dvips behavior,\n        unwittingly changed, just noted by Michel Goossens.)\n\nFri Apr 26 13:36:25 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in (install-data): Install the plain macro files in\n        $(dvips_plain_macrodir), and avoid $(CP_R).\n\tFrom: Pierre Asselin <pa@magtsm.tdh.qntm.com>.\n\nSun Apr 21 16:32:43 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c (main): Do not pass in !dontmakefont to kpse_init_prog.\n        In 'M' command line case, call the new kpse_set_enabled fn.\n\nFri Mar  8 14:39:03 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * hps.c: qoutes -> quotes.\n\n        * dospecial.c: Don't complain about unknown specials if TEX_HUSH.\n\nThu Mar  7 11:15:34 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c (check_checksum): New routine.\n        * bbox.c, loadfont.c, tfmload.c, virtualfont.c: Call it.\n\n        * t1part.c (perror): Remove spurious #define, and change return's\n        to exit's after calling perror.\n        New copyright notice from Sergey.\n\nSun Mar  3 12:26:01 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * t1part.c: New version (1.59) from Sergey, fixing the problem\n        with lbma.\n\nWed Feb 28 15:19:30 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.texi: Document the new MISSFONT_LOG variable.\n\n        * Installed following update from Dave Love:\n        \nTue Jan 23 13:55:52 1996  D.J.G.Love  <d.love@dl.ac.uk>\n\n        * hps.c (PAGESIZE): Don't hardcode.\n\nMon Jan 22 19:34:38 1996  Dave Love  <d.love@dl.ac.uk>\n\n        * dopage.c: Update to dvihps 0.3c.\n        * dospecial.c: Likewise.\n        * hps.c: Likewise.\n        * hps.lpro: Likewise.\n\nTue Feb 27 17:06:42 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * afm2tfm.c (main): Need to call kpse_set_progname now that we are\n        using the afm search path.\n\n        * resident.c (addentry): Oops, another mistake in the partial\n        download merge.\n\nSun Feb 18 15:59:18 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * afm2tfm.c: Search for AFM file along new AFM path.\n\n        * hps.c: Use mymalloc, not plain malloc.\n        And replace dup_str with the existing xstrdup.\n\nThu Feb 15 13:56:07 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c (main): Set kpse_make_tex_discard_errors = quiet.\n\nSat Feb 10 14:03:12 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * afm2tfm.c (assignchars): Avoid creating texnum's > 255, since we\n         can't handle it.  Happens with an AFM line like:\n         C 256 ; WX 402 ; N c256 ; B 4 0 402 630 ;\n        Also, don't try to output kern equivalences for unencoded characters.\n        From: \"Dr Peter J. Braam\" <braam@stlawrence.maths.ox.ac.uk>.\n\nFri Feb  9 15:28:03 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * afm2tfm.c (usage): Include kpathsea_version_string in output.\n        Recognize --version and --help.\n\n        * tex.lpro: I had fixed texc.lpro, but that's not a source file.\n\n        * hps.c (PAGESIZE): Compute dynamically.\n        From: Dave Love <d.love@dl.ac.uk>.\n\nSat Feb  3 15:44:19 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in (DEFS): Moved to common.make.\n\nFri Dec 29 17:17:14 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in: misc.make is now clean.make.\n\nTue Dec 26 17:18:39 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c (initialize): Initialize dontmakefont to\n        !MAKE_TEX_PK_BY_DEFAULT.\n\nWed Dec 20 15:38:31 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in (INSTALL): Use -D INSTALLONLY, rather than sed.\n        Manual changes to match.\n\nWed Dec 13 14:29:11 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c (DEFRES): Change to 600.\n\n        * afm2tfm.c: Do oslash <> o and Oslash <> O.\n        From: \"Young U. Ryu\" <ryoung@utdallas.edu>.\n\nSun Dec 10 16:41:05 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * dospecial.c (specerror): Hint that they're using an unsupported\n        macro package, most likely.\n\nFri Dec  1 16:08:52 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * test.tex: Rename to dvipstst.tex for clarity and include in\n        distribution.\n\tFrom: Joern Clausen <joern@techfak.uni-bielefeld.de>.\n\t\nThu Nov 16 13:32:50 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * search.c: Avoid popen on the Amiga.\n        * dvips.h (close_file): Make function declaration extern for the\n        Amiga. From Andreas Scherer.\n\nTue Nov 14 14:07:17 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * loadfont.c (pkopen): If font was substituted, don't say chars\n        will be left blank (they won't).\n\n        * resident.c (getdefaults): For R case, use line as a string,\n        changing whitespaces to colons, instead of doing numbers here.\n\nMon Nov 13 17:22:20 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c: Set kpathsea debugging bits even if -d is not first.\n\nSat Nov 11 16:01:24 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * texc.lpro: Add `Color LaserWriter 12/600 PS' to the list of\n        products that need the alternate rule definition.\n\n        * loadfont.c, dvips.c, virtualfont.c: Remove remaining MEM debugs\n        as too voluminous and not useful enough.\n        * debug.h (D_CONFIG): Reuse the D_MEM bit.\n        * resident.c (getdefaults): Output debugging info if requested.\n\nSun Oct 22 16:57:56 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in (squeeze): Use LIBS instead of LOADLIBES.\n\nSun Sep 24 13:49:43 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c (mymalloc): Test a local variable for debug output,\n        instead of DD_MEM.\n\nFri Sep 22 13:43:38 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c: If invalid option given, say what it was, and don't try\n        to list all the valid ones.\n        \n        * dvips.c (case o): make -o - output to stdout.\n\nThu Sep 14 14:49:53 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * config.ps: The default paper size cannot use setpagedevice.\n        From te.\n\nSat Sep  9 13:12:24 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * drawPS.c: Merge hyperdvi changes.\n        From: Dave Love <d.love@dl.ac.uk>.\n        \n        * config.h: Define TPIC and EMTEX by default.\n        * Makefile.in (DEFS): Instead of in DEFS.\n\nSat Sep  2 11:37:40 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * tex.lpro: Oops, missing if in the new code.\n\n        * epsf.tex: Don't do \\new... if we've already been read.\n\n        * config.ps: Update from Yves.\n\nWed Aug 23 11:55:59 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * config.h (headerpath): This is now kpse_ps_header_format, since\n        xdvi uses it, too.\n\n        * search.c (search): Try assigning to name and realnameoffile,\n        instead of copying.\n        * tfmload.c (name): Remove this static.\n        * loadfont.c (name): Declare as a pointer, instead of a fixed-size\n        array.\n\nSat Aug 12 13:42:22 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * tex.lpro: Check for LaserWriter 16/600 as well as Display and\n        NeXT when setting RMat.  From Tom R., reported by Rik Faith.\n\nFri Aug 11 14:42:14 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * resident.c (N): If we're doing -E, don't disable them.\n\nThu Aug 10 13:28:37 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * header.c, dvips.c (lastheadermem): Remove this global. It's no\n        longer used.\n        From: \"Christopher J. Duncan\" <cduncan@phys.psu.edu>\n        \n        * dvips.texi: Many updates.\n\nTue Aug  8 19:25:18 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in (post-dist): Include a README in reencode, update\n        for new fontname organization, don't include adobe file or fonts.\n        (install-data): Don't install fonts.\n\nMon Aug  7 17:46:43 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c: Rearrange help message.\n\nMon May 29 15:56:43 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in (install-data): Use $(srcdir)/{tex,fonts}; from zoo.\n        (But, we probably won't have inputs or fonts by release time anyway.)\n\nMon Apr 17 10:02:30 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in (squeeze, afm2tfm, $(program)): Use link_command.\n\nMon Mar 20 11:07:32 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * output.c: Print the > after reading the file, not before.\n\nFri Mar  3 14:49:16 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * afm2tfm.c (checksum): Use cyclic left shift, so we're not just\n        using the last four characters. From Piet.\n        (vname): New routine to better document the ligtable in the vpl.\n        (writevpl): If the base encoding is the same as the output\n        encoding, only output it once.\n        Also, don't output checksums; let vptovf and vftovp do that.\n        (addkern): New routine.\n        (checkligkern): If <>, make one character's kerning (Zcaron) be\n        the same as another's (Z).\n        (staticligkern): Define the default kerning equivalents.\n\nFri Feb 24 14:03:02 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c (main): Don't give `W' output if -q(uiet).\n\n        * config.ps (N): Don't define this by default.\n\nFri Feb 10 15:39:50 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c: Doc fix.\n\n        * Makefile.in (texc.lpro): Use $(srcdir)/tex.lpro. From Andreas.\n\nSun Jan  8 12:13:48 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * Version 5.58f.\n\nSun Jan  1 14:16:52 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in (DEFS): Include -DEMTEX by default. Suggested by Joachim.\n\nSat Dec 31 17:33:14 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in: Don't include tmptk.make any more.\n        (install-exec): Don't depend on install-MakeTeXPK, either.\n\nMon Dec 26 07:58:37 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c (main): Don't set mfmode to / here, do it in kpse_init_prog.\n\nSat Dec 24 15:20:50 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * emspecial.c (TRUE, FALSE) [TRUE]: Make definitions conditional.\n        From Joachim Schrod <schrod@iti.informatik.th-darmstadt.de>.\n\nWed Dec 14 15:16:53 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * Version 5.58e.\n\nMon Dec 12 07:11:14 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * MakeTeXPK.in (pattern): Give right name in error message. From\n        nickc@cs.st-andrews.ac.uk.\n\nMon Dec  5 15:32:48 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * MakeTeXPK.in: Use $SAVEPWD instead of $PWD, for bash's sake.\n        From bas@phys.uva.nl (Bas de Bakker).\n\nSun Dec  4 16:34:59 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * dospecial.c (predospecial): Avoid scanning compressed files for\n        font comments. From Peter Whaite <peta@cim.mcgill.ca>.\n\nSun Nov 27 11:39:42 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * output.c: Remove unmatched ( in output.c.  From Philippe\n        Charnier <charnier@lirmm.fr>.\n\n        * Makefile.in (install-data): Test for nonexistence of config.ps\n        and psfonts.map before grepping in them, to avoid spurious error\n        or unnecessary redirection.\n\n        * config.h (MFMODE): Don't bother with this.\n        * dvips.c (main): If mfmode is not set, set it to /, not a\n        compile-time default.\n\nFri Nov 25 11:05:58 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * resident.c (getdefaults): Don't set oname in case 'o' if the\n        cmdline already did.\n        * dvips.c (oname_option): New global.\n        (main): Set if.\n\n        * dvips.c, resident.c: Make config.$PRINTER mode value override\n        config.ps. From heiko@lotte.sax.de and Michael\n        C. Grant <mcgrant@rascals.stanford.edu> (independently).\n\n        * MakeTeXPK.in: Restore the umask 0. Requested by\n        Yves.Arrouye@imag.fr and others.\n\n        * texc.script: Don't pass single - arg to ed; Linux loses.  From\n        heiko@lotte.sax.de (Heiko Schlittermann).\n\nTue Nov 15 16:20:48 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in (targets.make): This is split up now.\n\nSun Nov  6 16:10:33 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * configure.in: Run autoupdate.\n\nSun Oct 30 16:17:22 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in (post-dist): Remove texc.lpro. From\n        interran@uluru.Stanford.EDU.\n\nTue Oct 25 17:47:48 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * Version 5.58c.\n\nSun Oct 23 17:41:24 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * config.h (MFMODE) [!MFMODE]: Define to be \"cx\".\n        * dvips.c (mfmode): Initalize to MFMODE, new option -mode to set it.\n        * resident.c (getdefaults): For case M, only get the new mode if\n        it wasn't specified on the command line.\n\nTue Oct 18 07:15:42 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * MakeTeXPK.in: Reformat the MakeTeXPK.site line so Autoconf will\n        substitute for both occurrences. (Actually, I think was my bug in\n        make/targets.make for not doing global sed substitutions.)\n\nSun Oct 16 20:42:47 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.texi: Distinguish somewhat more clearly between dvips and\n        Dvipsk.\n\n        * dospecial.c (dospecial): In \" case, there was never supposed to\n        *be* a closing quote in the \\special, so go back to the original.\n\nFri Oct 14 10:32:38 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * Version 5.58b.\n\nTue Oct 11 15:28:44 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in (install-exec): mkdirchain $(fontdir), for the sake\n        of MakeTeXPK.\n\n        * dospecial.c (dospecial): In \"...\" case, don't send closing quote.\n\nSun Oct  9 16:57:25 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * MakeTeXPK.in: Source $psheaderdir/MakeTeXPK.site if it exists.\n        Also, add pk/ into the default destination path if we have map files.\n\nThu Oct  6 14:36:41 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c: Don't call help () twice for -?, and support --help and\n        --version.\n\nSun Oct  2 16:42:25 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * resident.c (SET_CLIENT_PATH): New macro; strdup path values from\n        the config file.\n        (getdefaults): Call it.\n\n        * psfonts.map: Add more obliques for the standard fonts.  From\n        te@informatik.uni-hannover.de.\n\n        * search.c (secure) [SECURE]: Put this back.  From\n        hank@automat.uni-essen.de.\n\nSat Oct  1 20:25:42 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * MakeTeXPK.in: Make egrep pattern search for the base font, not\n        just $NAME.\n\nSat Sep 24 16:53:36 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c (o and f cases): Do not set noenv.  This makes dvips\n        always read the config files.\n\nThu Sep 22 15:35:22 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c: Remove `got a new papersize' messages.\n        * resident.c (getpsinfo): Allow multiple spec's a la download's.\n\nMon Sep 19 11:55:13 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (post-dist): Just link to the fontname dvips\n        directory, since it has all the encoding files.\n\nMon Sep 12 11:04:46 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Version 5.58a.\n\n        * dospecial.c: Remove my warning stuff; Tom did it his way.\n\nSun Sep 11 14:49:31 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Update for dvips 558.\n\n        * Makefile.in (psconfigfile): Remove this variable, and just use\n        config.ps; we would never install anything else anyway.\n        (uninstall-data): Install psfonts.map and config.ps if they didn't\n        exist.\n\nSat Sep 10 13:45:28 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * MakeTeXPK.in (ps_to_pk case): Only parse psfonts.map if we are ps2pk.\n\n        * dvips.texi: Fix overfull boxes.\n\n        * Makefile.in (post-dist-*): Include .aux/.cps in distribution.\n\nWed Sep  7 12:04:36 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Version 5.55b.\n\n        * afm2tfm.c (assignchars): Forget the outenname stuff; I just\n        noticed -u (pedantic).\n\nSun Sep  4 07:19:05 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * loadfont.c: Include c-pathmx.h.\n\nSat Sep  3 13:03:55 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (install-data): Install the .enc files.\n        (uninstall-data): And uninstall them.\n\nFri Sep  2 11:55:34 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (default): New target.\n        (makeargs): No need for this.\n\n        * psfonts.map: Include entries for *0, to accomodate the !@#$% latex2e.\n\nTue Aug 30 14:21:42 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * dospecial.c (dospecial, GetKeyVal): Add case for warning.\n\n        * dvips.texi (Special Font Effects): Mention outlined fonts.\n\n        * bbox.c (floor): Do not declare this.\n\n        * Makefile.in (distclean): Don't need this.\n\nMon Aug 29 16:53:48 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * configure.in (AC_OUTPUT): No more fonts/Makefile.\n        * Makefile.in (install-data): Use CP_R.\n\nThu Aug 25 14:19:18 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * config.h (D_SEARCH): New debug bit.\n        * dvips.c (dvips): Set it.\n        * dvips.texi: Document it.\n\nTue Aug 23 14:21:06 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * afm2tfm.c (assignchars): Don't add additional characters if\n        an explicit output encoding was specified.\n\n        * MakeTeXPK.in: Remove ;landscape hacks.\n\nSun Aug 21 10:58:11 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (mtp_destroot): Toss this.\n        (MakeTeXPK): Substitute fontdir instead.\n\nSat Aug 20 16:13:28 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * MakeTeXPK.in (DESTDIR): Deal with ;landscape in the mode.\n\nFri Aug 19 13:42:22 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * MakeTeXPK.in: Consistently use mf instead of $mf.\n        (MODE): If `default', guess, so users can specify a destdir with\n        no mode.\n\nTue Aug 16 09:28:35 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (sauterdir): Change to .../src.\n        (MakeTeXPK): Substitute for it.\n\n        * MakeTeXPK.in: Don't echo the args; let kpathsea do it.\n\nSat Aug 13 17:14:54 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in: Use $@ where possible.\n\nFri Aug 12 10:54:19 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * dopage.c (floor): Do not declare.\n\nTue Aug  9 13:53:12 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * dvips.c (-D): Set mfmode to the empty string.\n\n        * MakeTeXPK.in: Don't bother trying at +-1 now.\n        * fontdef.c (newfontdesc): kpse_magstep_fix the dpi calculation.\n\nSun Aug  7 19:34:57 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * loadfont.c (pkopen): Free the filename if necessary.\n\nTue Aug  2 15:02:59 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * config.h, dvips.c (D_DB_BUILD): Replace with D_HASH.\n\nSun Jul 31 14:49:22 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * special.lpro (startTexFig): Set magscale to true. From Tom.\n\n        * MakeTeXPK.in (pointsize): Improve sed expression to extract\n        this. From jsacco@ssl.com.\n\nFri Jul 29 12:01:50 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in: Use ac_include.\n        (install-{exec,data}): Different strategy for ensuring always-true\n        exit status.\n\nThu Jul 28 15:38:04 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (install-exec): Check for MakeTeXPK in $(scriptdir),\n        not $(bindir). From john@minster.york.ac.uk.\n\nFri Jul 15 11:46:20 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * virtualfont.c (vfopen): Don't append .vf here, kpathsea does it.\n        * tfmload.c (tfmopen): Likewise.\n\n        * dvips.c (main): Call kpse_set_progname first.\n\nTue Jul  5 14:01:33 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * MakeTeXPK.in (DVIPSHEADERS): Set this, and export it for\n        gsftopk.\n\nFri Jun 24 17:09:19 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * config.h (D_*): Add defns to pass to kpathsea.\n        (*path): Define as the kpse enum constants.\n        * most files: Remove extern char * decls of path variables.\n        * search.c: Pass in the format, not the path.\n        * resident.c (checkenv): #if 0 out.\n\nThu Jun 23 16:56:50 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * loadfont.c (pkopen): Don't set the ..._ENABLED bit; kpathsea\n        does that now.\n        * paths.h (*_ENVS): Move these to kpathsea.\n        * dvips.c (tfmpath, pkpath, etc.): Delete these; they're in the\n        kpathsea structure now.\n\nTue Jun 14 12:41:48 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (depend_encies): Remove.\n\nMon Jun 13 10:09:09 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * loadfont.c (pkopen): Don't call kpse_set_maketex_mag here,\n        let kpathsea do it. Also don't set MAKETEX_DPI, it's not used.\n\nSat May 28 19:08:50 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * PSfonts: Rename to fonts, for consistency with dviljk.\n        * Makefile.in: Change the cd's.\n\nThu May 26 16:29:54 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * loadfont.c (name): Make size be PATH_MAX.\n        * search.c (search, pksearch): Set name.\n        * virtualfont.c (name): Replace definition with extern.\n\n        * virtualfont.c (virtualfont) [DEBUG]: Print memory stats if\n        D_MEM, not D_FONTS.\n        * loadfont.c (loadfont): Likewise.\n\n        * resident.c (getpsinfo): Ignore whitespace after a <.\n\nTue May 24 13:14:08 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * resident.c (checkenv): Always set MAKETEX_BASE_DPI, for the sake\n        of missfont.log, even if dontmakefont.\n\nThu Apr 28 12:14:50 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * output.c (cleanprinter): Call perror if file writing failed.\n\nThu Apr 21 13:24:58 1994  Karl Berry  (karl@ra.cs.umb.edu)\n\n        * config.h (SHORTINT): Define if SIZEOF_INT < 4.\n\nSun Apr 17 16:13:16 1994  Karl Berry  (karl@ra.cs.umb.edu)\n\n        * debug.h (fopen): Do not define this; we'll use kpathsea's fopen\n        debugging support now.\n        * dvips.c (main): 'd' flag calls KPSE_DEBUG_SET (KPSE_DEBUG_FOPEN).\n\n        * Makefile.in (texc.lpro): Use $(SHELL) to run texc.script.\n        (top_srcdir): Define this for configure to substitute.\n\nTue Apr  5 11:51:32 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * MakeTeXPK.in (sauterdir): Substitute for this value.\n        Various other Sauter fixes from barthel@uaimzm.Mathematik.Uni-Mainz.DE.\n        * Makefile.in (sauterdir): Make it a variable.\n\nSun Apr  3 10:21:41 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Version 5.55a.\n\nFri Apr  1 11:52:42 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * resident.c (checkenv): Allow envvars {DVIPS,TEX}SIZES to\n        override the R config file line.\n\n        * Update for dvips 5.55.\n\nThu Mar 24 10:43:03 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * search.c (search): must_exist is false for VF files.\n\nTue Mar 15 07:21:04 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (distclean): Remove PSfonts/Makefile. From John I.\n\nFri Mar 11 14:51:04 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * MakeTeXPK.in: Echo `gsftopk failed' to stderr, not stdout.\n\nThu Mar  3 08:51:50 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Version 5.528a.\n\nThu Feb 24 16:19:55 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (installargs): Pass fontdir and ps_fontdir.\n\nTue Feb 22 11:41:13 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (c-auto.h.in): Include SMART_PUTENV.\n\nMon Feb 21 16:47:21 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * MakeTeXPK.in: Default to appending the mode, and allow an extra\n        arg to specify the destination directory. From neal.\n\n        * dvips.c (newoutname): | means pipe.\n\n        * afm2tfm.c: Remove declarations of exit.\n\n        * loadfont.c (pkopen): Cast args to kpse_bitmap_tolerance for the\n        sake of non-ANSI compilers.\n\nSun Feb 13 11:32:48 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Update for dvips 5.528.\n\nWed Feb  2 09:06:20 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Version 5.526b.\n\n        * loadfont.c (pkopen): Don't complain if the two dpi's can\n        tolerate each other.\n\n        * dvips.c (helparr): Mention -pp.\n\n        * dvips.1: Change char92 to \\. From karney@theory.pppl.gov.\n\nTue Feb  1 11:31:30 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (install-data): Add || true to the install_fonts, so\n        Ultrix make doesn't quit prematurely.\n\n        * Makefile.in (c-auto.h.in): New target.\n\nSat Jan 22 14:25:02 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Version 5.526a.\n\n        * loadfont.c (pkopen): Set dontmakefont=1 at the first failure.\n\nThu Jan 20 14:17:04 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * search.c (search) [SECURE]: Don't allow reading of an absolute_p\n        file. From maj@cl.cam.ac.uk.\n\nSun Jan 16 14:55:08 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (mtp_destdir): Change to $(fontdir)/pk.\n\nFri Jan 14 15:27:17 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Update for dvips 5.523.\n\n        * MakeTeXPK (MODE): Remove guess for lview monitor, that no one in\n        the world uses but me.\n\nSat Dec 18 12:49:10 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* dvips.texi (Config File Options): Enumerate the envvars that\n\toverride the P path. (From worsch@ira.uka.de.)\n\nThu Dec 16 12:32:21 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK.in: Say where gsftopk can be ftp'd.\n\nFri Dec 10 15:29:34 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* finclude.c (scanvm): Remove declaration of atol, as it causes\n\ttrouble with glibc.  From kayvan@satyr.sylvan.com.\n\nThu Dec  9 09:44:34 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK.in: Add gsftopk stuff, guess ljfour for 600 dpi, allow\n\tuser envvars to override, other cleanups. gsftopk stuff from\n\tR.Kooijman@et.tudelft.nl.\n\nTue Dec  7 14:01:30 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* loadfont.c (pkopen): Call kpse_set_maketex_mag instead of\n\tfind_mag_str.\n\t* Makefile.in (objects): Remove makefont.o.\n\n\t* dvips.texi (Installation): Mention that MakeTeXPK's interface is\n\tdifferent in dvipsk.\n\n\t* dvips.c (main): Make -v print the version number and exit.\n\nSat Nov 27 14:55:28 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* resident.c (INIT_PATH): Use the current value for the default,\n\talso. Change calls.\n\n\t* resident.c (getdefaults): Improve error message.\n\t(getpath): Expand a default value here; change callers to pass\n\tcompile-time default, instead of previous value.\n\nSun Nov 21 15:34:21 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* resident.c (checkenv) [DEBUG]: Correct #endif placement.  From\n\tpnoma@wk.estec.esa.nl.\n\nSun Nov 14 11:56:19 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (mtp_destdir): texfontdir has been renamed.\n\nFri Nov 12 19:42:21 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK.in: Document the final echo in no uncertain terms.\n\nThu Nov 11 10:58:41 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK.in (pointsize): Don't assume the fontname starts with `cm'.\n\nSat Nov  6 07:15:17 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK.in: test $d should have been test -d.\n\nWed Nov  3 14:43:05 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.521a.\n\nFri Oct 29 13:24:01 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (program_rm): Take out paths.h.\n\nTue Oct 26 11:38:35 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* drawPS.c (arc): Consistently check for nonsquare aspect ratios.\n\tFrom Ulf.Niemeyer@fernuni-hagen.de.\n\nSun Oct 24 19:26:37 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* resident.c (checkenv): Let TEXCONFIG override the config path,\n\tas it's supposed to.\n\nSat Oct 23 14:51:37 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK.in: Check for the GF file being at +1 or -1 of the dpi\n\twe were asked for. Apparently the DC fonts are generated this way.\n\nFri Oct 22 13:09:29 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* resident.c (checkenv): Set kpse_override_path to pkpath, so a\n\tconfig file value will be found.\n\n\t* emspecial.c, dospecial.c (atoi): Do not declare here, as it\n\tconflicts with the Linux system decl.\n\n\t* dvips.texi (Install): Be more precise about when config.ps and\n\tMakeTeXPK are overwritten.  From gv@me.umn.edu.\n\n\t* paths.h.in: Move paths to kpathsea/paths.h.in, and rename to paths.h.\n\t* Makefile.in (paths.h): Remove this dependency.\n\n\t* Makefile.in ($(kpathsea)): Depend on files in kpathsea_srcdir.\n\t(install-exec): MakeTeXPK is not in srcdir anymore.\n\t(install-data): The prologues aren't in srcdir. The info files\n\tmight be in either place.\n\tFrom simon@lia.di.epfl.ch.\n\nTue Oct 19 12:07:25 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MACHINES: New entries from simon.\n\nSat Oct  9 07:06:26 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (MakeTeXPK): Make executable.\n\n\t* Makefile.in (distclean): MakeTeXPK removed at mostlyclean now.\n\nThu Oct  7 09:58:48 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK.in: Missing \", and don't assume sauterdir exists.\n\nWed Oct  6 08:50:06 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.519b.\n\nSat Oct  2 17:30:45 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (install-*): Don't reassign PATH, just invoke\n\tmkdirchain explicitly.\n\n\t* Makefile.in (dvips_makeargs): Delete, since now unused.\n\nFri Oct  1 07:09:29 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK.in: Don't try to put the MF command into a variable;\n\tquoting rules are too confused.\n\nWed Sep 29 15:21:49 1993    (karl@terminus.cs.umb.edu)\n\n\t* Version 5.519a.\n\nTue Sep 28 13:23:45 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* resident.c (print_path): Don't compare char to NULL.\n\n\t* resident.c (lastresortsizes): Declare as an unsigned array.\n\n\t* loadfont.c (pkopen): ifdef out the dead code.\n\nSat Sep 25 11:33:21 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (mtp_destdir): New variable.\n\t(MakeTeXPK): New target.\n\t* MakeTeXPK.in: New file.\n\n\t* resident.c (getdefaults): Set envvar MAKETEX_MODE in M case.\n\nFri Sep 24 11:47:55 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* resident.c (checkenv): Initialize kpse_fallback_font.\n\nThu Sep 23 17:53:48 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* resident.c (checkenv): Check for DVIPSFONTS.\n\t* dvips.texi (Environment variables): Document it.\n\nSun Aug 29 11:45:52 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* resident.c: No leading spaces before #'s.\n\n\t* Makefile.in (install-*): Use $(PATH) instead of $$PATH.\n\n\t* config.h (DEBUG) [NO_DEBUG]: Define this.\n\nFri Aug 27 10:27:34 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* paths.h.in (DVIPS_{HEADER,PICT}_ENVS): New defines.\n\t* resident.c (getpath): Make a copy.\n\t(getdefaults): Go back to calling getpath.\n\t(checkenv): Change kpse_init_path calls to pass default.\n\t* dvips.c (*path): Initialize to default paths.\n\n\t* dvips.c (tfmpath, pkpath, vfpath, figpath, headerpath): All\n\tstrings now, not string *'s.\n\t* tfmload.c (tfmpath): Likewise.\n\nWed Aug 25 14:35:30 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Update for dvips 5.519.\n\nSun Aug 22 19:13:42 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (install-data): Install the fonts last.\n\n\t* Makefile.in (install-*): mkdirchain is in the top level.\n\nTue Aug 10 10:34:30 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in: Remove reference to -DFONTLIB.\n\t(objects): Remove flib.o.\n\nFri Aug  6 09:04:45 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* resident.c (checkenv): Look for DVIPSHEADERS.\n\nThu Aug  5 09:03:31 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.518a.\n\n\t* Makefile.in (default_config_path): Add ~.\n\nWed Aug  4 13:50:36 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK: Announce that we're running.\n\n\t* Makefile.in: Major surgery to conform to new scheme.\n\nSat Jul 31 11:36:15 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* configure.in: Remove AC_PREFIX.\n\nTue Jul 27 15:00:44 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Update for dvips 5.518.\n\nSun Jul 25 10:43:45 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (install*): Add $(srcdir) to PATH for mkdirchain, not .\n\nWed Jul 21 19:46:22 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (configclean): New target.\n\nSun Jul 11 16:20:41 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK: Output the filename we generate to stdout, if we succeed.\n\nTue Jul  6 08:40:25 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK: Send all output to stderr.\n\nMon Jul  5 09:32:30 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in: Various configuration changes from xdvik.\n\n\t* paths.h.in (DEFAULT_{TFM,PK,VF}_PATH): Remove.\n\nFri Jul  2 12:00:05 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* configure.in: sinclude common.ac.\n\nTue May 25 10:09:02 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* configure.in (AC_HAVE_HEADERS): Test for `pwd.h'.\n\nSat May 22 11:21:34 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (dist): Run gzip -9.\n\nFri May 21 10:14:25 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* resident.c: Change #if DEBUG to #ifdef.\n\nThu May 20 11:48:28 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* psfonts.map: Add URW fonts.\n\nTue May 18 13:58:55 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (install-*): mkdirchain on install dirs, and put\n\tmkdirchain in the dist.\n\nSun May 16 17:47:26 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* dvips.texi: Do paragraph indentation from command.\n\t* Makefile.in (MAKEINFO_FLAGS): New variable.\n\nMon May 10 07:13:29 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.516a.\n\nSun May  9 10:35:58 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (extraclean): add *.i and *.s.\n\nSat May  8 13:11:16 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (dist): Rewrite for kpathsea.\n\t* <many>.c, config.h: Use <kpathsea/foo.h> instead of \"foo.h\".\n\nTue May  4 14:56:57 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (info, dvi): New targets.\n\nSat May  1 16:21:41 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Update for dvips 5.516, and kpathsea library.\n\nFri Apr 23 16:46:29 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* configure.in (AC_CONST): Add this.\n\nTue Apr 20 06:58:31 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* pathshare from web2c.\n\nSun Apr 11 18:57:39 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.515b.\n\nSat Apr 10 14:58:56 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* config.h (UNIX_ST_NLINK): Define unless on foreign OS.\n\n\t* Makefile.in (uninstall*): New targets.\n\n\t* Makefile.in (scriptdir): New variable.\n        (install): Install MakeTeXPK there.\n\n\t* configure.in: Do AC_XENIR_DIR after AC_DIR_HEADER.\n\nMon Mar 29 08:28:22 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.515a.\n\n\t* Makefile.in (default_tfm_path): Put . first.\n\nSun Mar 28 16:43:50 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Update for dvips 5.515.\n\nMon Mar 22 06:12:25 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.12c.\n\nSun Mar 14 14:51:03 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK (MFINPUTS): Append a colon to be sure and get the\n\tsystem default path.\n\nSat Mar 13 11:04:26 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (CPPFLAGS): Add @DEFS@, for -DHAVE_CONFIG_H.\n\nMon Mar  8 06:27:11 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.12b.\n\nMon Mar  1 06:26:28 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.512a.\n\nSun Feb 28 12:03:16 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (dist): Get lucida.sty.\n\nThu Feb 25 14:02:02 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK (MFINPUTS): Include the old cwd before changing to\n\tTEMPDIR.\n\nTue Feb 23 16:51:38 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (dist): Copy info files to my local info directory.\n\nMon Feb 22 06:19:46 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.499c.\n\nWed Feb 17 06:45:29 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (INSTALL): Use tr instead of grep to remove the\n\tInfo control characters.\n\nSun Feb 14 17:11:10 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (install): Split into install-exec and install-data.\n\nFri Feb 12 08:34:45 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* dvips.1: Don't refer to dvips.tex.\n\nTue Feb  9 20:27:50 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK: Create DESTDIR if it doesn't exist.\n\nSun Feb  7 10:01:25 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.499b.\n\n\t* Makefile.in (install): dir is a shell variable, not a make\n\tvariable; fix logic for original MakeTeXPK, etc.\n\nTue Feb  2 11:41:10 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (install): Don't install over a modified MakeTeXPK,\n\tconfig.ps, or psfonts.map.\n\n\t* Version 5.499a.\n\nSun Jan 31 07:08:44 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (install): Allow install_subdirs to be empty.\n\nFri Jan 29 17:38:04 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (CPPFLAGS): Don't bother with `-I.'.\n\nWed Jan 20 07:53:36 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* config.h (FATAL*): Now in lib.h.\n\n\t* Version 5.497c.\n\nMon Jan 18 08:19:57 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* PSfonts: Merge PStfms and PSvfs.\n\nSat Jan  9 15:21:30 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (configure, config.status): cd $(srcdir) first.\n\nSun Jan  3 19:43:20 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* config.h: Move some includes to c-std.h.\n\nFri Jan  1 13:57:24 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* configure.in, c-auto.h.in, c-memstr.h, dirio.h: Changes for\n\tnew Autoconf.\n\nWed Dec 23 06:57:20 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.497b.\n\nThu Dec 17 07:13:35 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* dvips.c (main) [DEBUG]: Missing part of fprintf.\n\n\t* resident.c (checkenv) [DEBUG]: Had figpath instead of pkpath.\n\nMon Dec 14 07:27:39 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.497a.\n\nFri Dec 11 15:23:58 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* afm2tfm.c, dospecial.c, emspecial.c, finclude.c: Change ctype\n\treferences to use uppercase macros.\n\nThu Dec 10 10:36:13 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* GNUmakefile.in (GNUmakefile): Add $(srcdir) to dependency, and\n\tuse $(SHELL) instead of sh.\n        (config.status): Use $(SHELL).\n\nTue Dec  8 07:19:52 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (.texi.info): Add `-o $@'.\n\nSat Dec  5 18:50:09 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* Update for version 5.497.\n\nSun Nov 29 17:25:52 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* finclude.c (atof) [!STDC_HEADERS]: Make declaration conditional.\n\nSun Nov 22 11:11:24 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (install): Test for non-null install_subdirs.\n\nSat Oct 31 07:56:41 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* encodings/texm{sym,ital,ext}.enc: New files.\n\n\t* dvips.texi: Remove the `eg$ ' from examples.\n\nWed Oct 28 07:43:50 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.495b.\n\nTue Oct 27 06:07:20 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (.lpro.pro): Depend on squeeze; also, use a temp\n\tfile to avoid creating empty files.\n\n\t* Makefile.in (checkenv) [DEBUG]: Conditionalize use of D_PATH.\n\n\t* Makefile.in (.texi.info): New suffix rule, to avoid use of $< in\n\tnormal rules.\n\n\t* Makefile.in (distclean): Remove */Makefile.\n\nSat Oct 24 11:48:14 1992  Karl Berry  (karl@ds3.cs.umb.edu)\n\n\t* Makefile.in (install): Quote $(install_subdirs), in case it's\n\tbeen set to empty.\n\n\t* Makefile.in (texfontdir): New variable.\n        (install): mkdir it and the ps subdirectories.\n\nSat Oct 17 16:39:02 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (install_subdirs, subdirs): New variables.\n        (install): make install in $(install_subdirs).\n        (dist): Dist $(subdirs).\n        (installargs): Make arguments to pass to subdirs.\n        (ps{tfm,vf}dir): New target directories.\n        * configure.in (AC_OUTPUT): Create Makefiles in the install subdirs.\n\n\t* Makefile.in (paths.h): Don't depend on Makefile and Makefile.in\n\t-- they change too often for other reasons than paths.\n\n\t* Makefile.in (check): New target.\n\n\t* Makefile.in (objects): Include `emspecial.o'.\n\n\t* Update for dvips 5.495.\n\nThu Oct 15 08:34:33 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* configure: Ran Autoconf 1.2.\n\nSat Oct 10 12:20:02 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (dist): Don't copy any subdirs.\n        * README: Document what we've changed and what we haven't.\n\nWed Sep 23 07:51:13 1992  Karl Berry  (karl@cs.umb.edu)\n\n        * Version 5.493c.\n\nSun Sep 20 12:52:24 1992  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (config.status): use sh to run configure --no-create.\n\n        * Makefile.in (realclean): OK, don't remove configure.\n\nThu Sep 17 07:40:27 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.493b.\n\nMon Sep 14 17:59:53 1992  Karl Berry  (karl@hayley)\n\n        * Makefile.in (config.status): new target.\n        (Makefile): depend on config.status.\n\nThu Sep 10 08:57:33 1992  Karl Berry  (karl@hayley)\n\n        * Makefile.in (dist): include COPYING*.\n\n        * Makefile.in (realclean): remove configure.\n\n        * MakeTeXPK: run gftopk ./<filename>, in case an old version of\n          gftopk is installed.\n\nWed Sep  9 06:26:30 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.493a.\n\nTue Sep  8 16:51:25 1992  Karl Berry  (karl@hayley)\n\n        * c-auto.h.in (_MINIX, _{ALL,POSIX,POSIX_1}_SOURCE): add #undef's\n          for configure to define.\n\n        * configure.in: test for more Unix variants.\n\nFri Sep  4 17:27:52 1992  Karl Berry  (karl@hayley)\n\n        * Makefile.in (extraclean): new target.\n\n        * Update to version 5.493.\n\nThu Aug 27 08:57:06 1992  Karl Berry  (karl@hayley)\n\n        * configure: regenerated from Autoconf 1.1.\n\nTue Aug 11 07:00:15 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.490s.\n\n        * Makefile.in (dist): copy MakeTeXPK.\n\nFri Jul 31 19:14:15 1992  Karl Berry  (karl@hayley)\n\n        * Makefile.in (dist): include our aclocal.m4.\n\nWed Jul 29 08:52:01 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.490r (ran pathshare).\n\nFri Jul 24 06:49:56 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.490q.\n\nWed Jul 22 09:10:03 1992  Karl Berry  (karl@hayley)\n\n        * configure.in: update for Autoconf 1.0.\n\nTue Jul 21 08:52:21 1992  Karl Berry  (karl@hayley)\n\n        * resident.c (print_path): new function.\n        (checkenv): call it, if we are debugging paths.\n\n        * resident.c (checkenv): don't reset envvars if they are already set.\n        (getdefaults): pass the user envvars when setting values from the\n          config files, so they will override.\n\nThu Jul 16 06:56:31 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.490p.\n\nSun Jul 12 06:20:11 1992  Karl Berry  (karl@hayley)\n\n        * Makefile.in (dist): forgot to include the config files.\n\nSat Jul 11 11:52:48 1992  Karl Berry  (karl@hayley)\n\n        * Makefile.in (dist): copy texinfo.tex and `adobe' from their\n          original directory, instead of using the versions here.\n\nFri Jul 10 06:52:51 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.490o.\n\nThu Jul  2 15:25:00 1992  Karl Berry  (karl@hayley)\n\n        * Makefile.in (CPPFLAGS): new variable.\n        (.c.o): use it.\n        (CFLAGS): define as -g.\n        (cdebug): remove.\n        (LDFLAGS): use CFLAGS instead of cdebug.\n\n        * Run Autoconf 0.119.\n\nWed Jul  1 07:48:33 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.490n.\n\nSat Jun 27 11:03:09 1992  Karl Berry  (karl@hayley)\n\n        * Makefile.in (paths.h): depend on Makefile.in and Makefile.\n\nThu Jun 25 09:57:54 1992  Karl Berry  (karl@hayley)\n\n        * All these $(srcdir) changes from or inspired by zoo@cygnus.com.\n\n        * Makefile.in (paths.h): use $(srcdir) for paths.h.in.\n\nWed Jun 24 11:57:21 1992  Karl Berry  (karl@hayley)\n\n        * structures.h (BANNER): name this program kdvips.\n        * Makefile.in (distdir): ditto for the directory.\n\n        * Makefile.in (CCFLAGS): new variable to replace $(CFLAGS).\n        (.c.o): new implicit rule to use it.\n        (.lpro.pro): use $< instead of $*.lpro, since I\n          guess it's marginally more portable.\n        (texc.lpro, install): use $(srcdir).\n        (Makefile): new target.\n\n        * Makefile (install): mkdir more of the top level directories.\n\n        * Makefile (dist): distribute the config* files (except\n          config.status).\n\n        * README: say that %-specifiers don't work.\n\nTue Jun 23 08:50:06 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.490m.\n\nFri Jun 19 09:26:14 1992  Karl Berry  (karl@hayley)\n\n        * psfonts.map: update for new (old by now, actually) change in the\n          way ExtendFont and SlantFont work.\n\nTue Jun 16 06:13:31 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.490l.\n\nSat Jun 13 07:13:07 1992  Karl Berry  (karl@hayley)\n\n        * loadfont.c (pkopen): fix remaining sprintf-with-too-many-%'s.\n\nThu Jun 11 08:45:25 1992  Karl Berry  (karl@hayley)\n\n        * Makefile.in (.NOEXPORT): new target, since Autoconf doesn't add\n          it automatically any more.\n\nWed Jun 10 06:34:24 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.490k.\n\nFri Jun  5 07:58:45 1992  Karl Berry  (karl@hayley)\n\n        * squeeze.c, afm2tfm.c (main): `return 0' instead of `exit (0)'.\n          (From Paul Eggert)  Also declare as `int'.\n\n        * Makefile (install): `black.tex' is now `blackdvi.tex', etc.\n\nThu Jun  4 08:25:51 1992  Karl Berry  (karl@hayley)\n\n        * main.c (main): `return 0' instead of `exit (0)'.  (From Paul Eggert)\n\n        * Update for dvips 5.490.\n\n        * configure.in (AC_HEADER_FILE): rename to AC_CONFIG_HEADER, for\n          Autoconf 0.115.\n\nWed Jun  3 08:19:53 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.487l.\n\nFri May 29 11:28:16 1992  Karl Berry  (karl@hayley)\n\n        * Below changes from Paul Eggert.\n\n        * dvips.c (main): declare as returning an int.\n\n        * dvips.c (exit): do not declare.\n\n        * resident.c (pagecopies) [DEBUG]: declare unconditionally.\n\n        * resident.c (exit): do not declare.\n\n        * unpack.c (flip): don't use a variable `howmany', since Sun has a\n          macro called that.\n\n        * config.h (FATAL): don't assume an ANSI cpp.\n", "/*\nCopyright 1996-2013 Han The Thanh <thanh@pdftex.org>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see  <http://www.gnu.org/licenses/>.  */\n\n#include \"dvips.h\"\n/*\n *   The external declarations:\n */\n#include \"protos.h\"\n#include \"ptexmac.h\"\n#undef  fm_extend\n#define fm_extend(f)        0\n#undef  fm_slant\n#define fm_slant(f)         0\n#undef  is_reencoded\n#define is_reencoded(f)     (cur_enc_name != NULL)\n#undef  is_subsetted\n#define is_subsetted(f)     true\n#undef  is_included\n#define is_included(f)      true\n#undef  set_cur_file_name\n#define set_cur_file_name(s)    cur_file_name = s\n#define external_enc()      ext_glyph_names\n#define full_file_name()    cur_file_name\n#define is_used_char(c)     (grid[c] == 1)\n#define end_last_eexec_line()       \\\n    hexline_length = HEXLINE_WIDTH; \\\n    end_hexline();                  \\\n    t1_eexec_encrypt = false\n#define t1_scan_only()\n#define t1_scan_keys()\n#define embed_all_glyphs(tex_font)  false\n#undef pdfmovechars\n#ifdef SHIFTLOWCHARS\n#define pdfmovechars shiftlowchars\n#define t1_char(c)          T1Char(c)\n#else /* SHIFTLOWCHARS */\n#define t1_char(c)          c\n#define pdfmovechars 0\n#endif /* SHIFTLOWCHARS */\n#define extra_charset()     dvips_extra_charset\n#define make_subset_tag(a, b)\n#define update_subset_tag()\n\nstatic char *dvips_extra_charset;\nstatic char *cur_file_name;\nstatic char *cur_enc_name;\nstatic unsigned char *grid;\nstatic char *ext_glyph_names[256];\nstatic char print_buf[PRINTF_BUF_SIZE];\nstatic int  hexline_length;\nstatic char notdef[] = \".notdef\";\nstatic size_t last_ptr_index;\n\n#include <stdarg.h>\n\n#define t1_log(str) \n#define get_length1()\n#define get_length2()\n#define get_length3()\n#define save_offset()\n\n#define t1_open()           \\\n    ((t1_file = search(type1path, cur_file_name, FOPEN_RBIN_MODE)) != NULL)\n#define t1_close()       xfclose(t1_file, cur_file_name)\n#define t1_getchar()     getc(t1_file)\n#define t1_putchar(c)    fputc(c, bitfile)\n#define t1_ungetchar(c)  ungetc(c, t1_file)\n#define t1_eof()         feof(t1_file)\n\n#define str_prefix(s1, s2) (strncmp(s1, s2, strlen(s2)) == 0)\n#define t1_prefix(s)     str_prefix(t1_line_array, s)\n#define t1_buf_prefix(s) str_prefix(t1_buf_array, s)\n#define t1_suffix(s)     str_suffix(t1_line_array, t1_line_ptr, s)\n#define t1_buf_suffix(s) str_suffix(t1_buf_array, t1_buf_ptr, s)\n#define t1_charstrings() strstr(t1_line_array, charstringname)\n#define t1_subrs()       t1_prefix(\"/Subrs\")\n#define t1_end_eexec()   t1_suffix(\"mark currentfile closefile\")\n#define t1_cleartomark() t1_prefix(\"cleartomark\")\n\n#define enc_open()           \\\n    ((enc_file = search(encpath, cur_file_name, FOPEN_RBIN_MODE)) != NULL)\n#define enc_close()      xfclose(enc_file, cur_file_name)\n#define enc_getchar()    getc(enc_file)\n#define enc_eof()        feof(enc_file)\n\n#define valid_code(c)    (c >= 0 && c < 256)\n#define fixedcontent     true /* false for pdfTeX, true for dvips */\n\nstatic const char *standard_glyph_names[256] = {\n    /* 0x00 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0x10 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0x20 */\n    \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\",\n    \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\", \"asterisk\",\n    \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\",\n    /* 0x30 */\n    \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\",\n    \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\",\n    /* 0x40 */\n    \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\",\n    \"O\",\n    /* 0x50 */\n    \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\",\n    \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\",\n    /* 0x60 */\n    \"quoteleft\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\",\n    \"m\", \"n\", \"o\",\n    /* 0x70 */\n    \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\",\n    \"braceright\", \"asciitilde\", notdef,\n    /* 0x80 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0x90 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0xa0 */\n    notdef, \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\", \"florin\",\n    \"section\", \"currency\", \"quotesingle\", \"quotedblleft\", \"guillemotleft\",\n    \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\",\n    /* 0xb0 */\n    notdef, \"endash\", \"dagger\", \"daggerdbl\", \"periodcentered\", notdef,\n    \"paragraph\", \"bullet\", \"quotesinglbase\", \"quotedblbase\",\n    \"quotedblright\", \"guillemotright\", \"ellipsis\", \"perthousand\", notdef,\n    \"questiondown\",\n    /* 0xc0 */\n    notdef, \"grave\", \"acute\", \"circumflex\", \"tilde\", \"macron\", \"breve\",\n    \"dotaccent\", \"dieresis\", notdef,\n    \"ring\", \"cedilla\", notdef, \"hungarumlaut\", \"ogonek\", \"caron\",\n    /* 0xd0 */\n    \"emdash\", notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0xe0 */\n    notdef, \"AE\", notdef, \"ordfeminine\", notdef, notdef, notdef, notdef,\n    \"Lslash\", \"Oslash\", \"OE\", \"ordmasculine\", notdef, notdef, notdef,\n    notdef,\n    /* 0xf0 */\n    notdef, \"ae\", notdef, notdef, notdef, \"dotlessi\", notdef, notdef, \"lslash\",\n    \"oslash\", \"oe\", \"germandbls\", notdef, notdef, notdef, notdef\n};\n\nchar **t1_glyph_names;\nchar *t1_builtin_glyph_names[256];\nstatic boolean read_encoding_only;\n\nstatic char charstringname[] = \"/CharStrings\";\n\nenum { ENC_STANDARD, ENC_BUILTIN } t1_encoding;\n\n#define T1_BUF_SIZE      0x10\n#define ENC_BUF_SIZE     0x1000\n\n#define CS_HSTEM         1\n#define CS_VSTEM         3\n#define CS_VMOVETO       4\n#define CS_RLINETO       5\n#define CS_HLINETO       6\n#define CS_VLINETO       7\n#define CS_RRCURVETO     8\n#define CS_CLOSEPATH     9\n#define CS_CALLSUBR      10\n#define CS_RETURN        11\n#define CS_ESCAPE        12\n#define CS_HSBW          13\n#define CS_ENDCHAR       14\n#define CS_RMOVETO       21\n#define CS_HMOVETO       22\n#define CS_VHCURVETO     30\n#define CS_HVCURVETO     31\n#define CS_1BYTE_MAX     (CS_HVCURVETO + 1)\n\n#define CS_DOTSECTION    CS_1BYTE_MAX + 0\n#define CS_VSTEM3        CS_1BYTE_MAX + 1\n#define CS_HSTEM3        CS_1BYTE_MAX + 2\n#define CS_SEAC          CS_1BYTE_MAX + 6\n#define CS_SBW           CS_1BYTE_MAX + 7\n#define CS_DIV           CS_1BYTE_MAX + 12\n#define CS_CALLOTHERSUBR CS_1BYTE_MAX + 16\n#define CS_POP           CS_1BYTE_MAX + 17\n#define CS_SETCURRENTPOINT CS_1BYTE_MAX + 33\n#define CS_2BYTE_MAX     (CS_SETCURRENTPOINT + 1)\n#define CS_MAX           CS_2BYTE_MAX\n\ntypedef unsigned char byte;\n\ntypedef struct {\n    byte nargs;                 /* number of arguments */\n    boolean bottom;             /* take arguments from bottom of stack? */\n    boolean clear;              /* clear stack? */\n    boolean valid;\n} cc_entry;                     /* CharString Command */\n\ntypedef struct {\n    char *name;                 /* glyph name (or notdef for Subrs entry) */\n    byte *data;\n    unsigned short len;         /* length of the whole string */\n    unsigned short cslen;       /* length of the encoded part of the string */\n    boolean used;\n    boolean valid;\n} cs_entry;\n\nstatic unsigned short t1_dr, t1_er;\nstatic const unsigned short t1_c1 = 52845, t1_c2 = 22719;\nstatic unsigned short t1_cslen;\nstatic short t1_lenIV;\nstatic char enc_line[ENC_BUF_SIZE];\n\n/* define t1_line_ptr, t1_line_array & t1_line_limit */\ntypedef char t1_line_entry;\ndefine_array(t1_line);\n\n/* define t1_buf_ptr, t1_buf_array & t1_buf_limit */\ntypedef char t1_buf_entry;\ndefine_array(t1_buf);\n\nstatic int cs_start;\n\nstatic cs_entry *cs_tab, *cs_ptr, *cs_notdef;\nstatic char *cs_dict_start, *cs_dict_end;\nstatic int cs_count, cs_size, cs_size_pos;\n\nstatic cs_entry *subr_tab;\nstatic char *subr_array_start, *subr_array_end;\nstatic int subr_max, subr_size, subr_size_pos;\n\n/* This list contains the begin/end tokens commonly used in the */\n/* /Subrs array of a Type 1 font.                               */\n\nstatic const char *cs_token_pairs_list[][2] = {\n    {\" RD\", \"NP\"},\n    {\" -|\", \"|\"},\n    {\" RD\", \"noaccess put\"},\n    {\" -|\", \"noaccess put\"},\n    {NULL, NULL}\n};\nstatic const char **cs_token_pair;\n\nstatic boolean t1_pfa, t1_cs, t1_scan, t1_eexec_encrypt, t1_synthetic;\nstatic int t1_in_eexec;         /* 0 before eexec-encrypted, 1 during, 2 after */\nstatic long t1_block_length;\nstatic int last_hexbyte;\nstatic FILE *t1_file;\nstatic FILE *enc_file;\n\nstatic void pdftex_fail(const char *fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    fputs(\"\\nError: module writet1\", stderr);\n    if (cur_file_name)\n        fprintf(stderr, \" (file %s)\", cur_file_name);\n    fputs(\": \", stderr);\n    vsprintf(print_buf, fmt, args);\n    fputs(print_buf, stderr);\n    fputs(\"\\n ==> Fatal error occurred, the output PS file is not finished!\\n\", stderr);\n    va_end(args);\n    exit(-1);\n}\n\nstatic void pdftex_warn(const char *fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    fputs(\"\\nWarning: module writet1 of dvips\", stderr);\n    if (cur_file_name)\n        fprintf(stderr, \" (file %s)\", cur_file_name);\n    fputs(\": \", stderr);\n    vsprintf(print_buf, fmt, args);\n    fputs(print_buf, stderr);\n    fputs(\"\\n\", stderr);\n    va_end(args);\n}\n\n#define HEXLINE_WIDTH 64\n\nstatic void end_hexline(void)\n{\n    if (hexline_length == HEXLINE_WIDTH) {\n        fputs(\"\\n\", bitfile);\n        hexline_length = 0;\n    }\n}\n\nstatic void t1_outhex(byte b)\n{\n    static const char *hexdigits = \"0123456789ABCDEF\";\n    t1_putchar(hexdigits[b/16]);\n    t1_putchar(hexdigits[b%16]);\n    hexline_length += 2;\n    end_hexline();\n}\n\n\nstatic void enc_getline(void)\n{\n    char *p;\n    int c;\n  restart:\n    if (enc_eof())\n        pdftex_fail(\"unexpected end of file\");\n    p = enc_line;\n    do {\n        c = enc_getchar();\n        append_char_to_buf(c, p, enc_line, ENC_BUF_SIZE);\n    } while (c != 10);\n    append_eol(p, enc_line, ENC_BUF_SIZE);\n    if (p - enc_line < 2 || *enc_line == '%')\n        goto restart;\n}\n\n/* read encoding from .enc file, return glyph_names array, or pdffail() */\n\nchar **load_enc_file(char *enc_name)\n{\n    char buf[ENC_BUF_SIZE], *p, *r;\n    int i, names_count;\n    char **glyph_names;\n    set_cur_file_name(enc_name);\n    glyph_names = (char **) mymalloc(256 * sizeof(char *));\n    for (i = 0; i < 256; i++)\n        glyph_names[i] = notdef;\n    if (!enc_open()) {\n        pdftex_warn(\"cannot open encoding file for reading\");\n        cur_file_name = NULL;\n        return glyph_names;\n    }\n    t1_log(\"{\");\n    t1_log(cur_file_name = full_file_name());\n    enc_getline();\n    if (*enc_line != '/' || (r = strchr(enc_line, '[')) == NULL) {\n        remove_eol(r, enc_line);\n        pdftex_fail\n           (\"invalid encoding vector (a name or `[' missing): `%s'\", enc_line);\n    }\n    names_count = 0;\n    r++;                        /* skip '[' */\n    skip(r, ' ');\n    for (;;) {\n        while (*r == '/') {\n            for (p = buf, r++;\n                 *r != ' ' && *r != 10 && *r != ']' && *r != '/'; *p++ = *r++);\n            *p = 0;\n            skip(r, ' ');\n            if (names_count > 255)\n                pdftex_fail(\"encoding vector contains more than 256 names\");\n            if (strcmp(buf, notdef) != 0)\n                glyph_names[names_count] = xstrdup(buf);\n            names_count++;\n        }\n        if (*r != 10 && *r != '%') {\n            if (str_prefix(r, \"] def\"))\n                goto done;\n            else {\n                remove_eol(r, enc_line);\n                pdftex_fail\n       (\"invalid encoding vector: a name or `] def' expected: `%s'\", enc_line);\n            }\n        }\n        enc_getline();\n        r = enc_line;\n    }\n  done:\n    enc_close();\n    t1_log(\"}\");\n    cur_file_name = NULL;\n    return glyph_names;\n}\n\nstatic void t1_check_pfa(void)\n{\n    const int c = t1_getchar();\n    t1_pfa = (c != 128) ? true : false;\n    t1_ungetchar(c);\n}\n\nstatic int t1_getbyte(void)\n{\n    int c = t1_getchar();\n    if (t1_pfa)\n        return c;\n    if (t1_block_length == 0) {\n        if (c != 128)\n            pdftex_fail(\"invalid marker\");\n        c = t1_getchar();\n        if (c == 3) {\n            while (!t1_eof())\n                t1_getchar();\n            return EOF;\n        }\n        t1_block_length = t1_getchar() & 0xff;\n        t1_block_length |= (t1_getchar() & 0xff) << 8;\n        t1_block_length |= (t1_getchar() & 0xff) << 16;\n        t1_block_length |= (t1_getchar() & 0xff) << 24;\n        c = t1_getchar();\n    }\n    t1_block_length--;\n    return c;\n}\n\nstatic int hexval(int c)\n{\n    if (c >= 'A' && c <= 'F')\n        return c - 'A' + 10;\n    else if (c >= 'a' && c <= 'f')\n        return c - 'a' + 10;\n    else if (c >= '0' && c <= '9')\n        return c - '0';\n    else\n        return -1;\n}\n\nstatic byte edecrypt(byte cipher)\n{\n    byte plain;\n    if (t1_pfa) {\n        while (cipher == 10 || cipher == 13)\n            cipher = t1_getbyte();\n        last_hexbyte = cipher = (hexval(cipher) << 4) + hexval(t1_getbyte());\n    }\n    plain = (cipher ^ (t1_dr >> 8));\n    t1_dr = (cipher + t1_dr) * t1_c1 + t1_c2;\n    return plain;\n}\n\nstatic byte cdecrypt(byte cipher, unsigned short *cr)\n{\n    const byte plain = (cipher ^ (*cr >> 8));\n    *cr = (cipher + *cr) * t1_c1 + t1_c2;\n    return plain;\n}\n\nstatic byte eencrypt(byte plain)\n{\n    const byte cipher = (plain ^ (t1_er >> 8));\n    t1_er = (cipher + t1_er) * t1_c1 + t1_c2;\n    return cipher;\n}\n\nstatic byte cencrypt(byte plain, unsigned short *cr)\n{\n    const byte cipher = (plain ^ (*cr >> 8));\n    *cr = (cipher + *cr) * t1_c1 + t1_c2;\n    return cipher;\n}\n\nstatic char *eol(char *s)\n{\n    char *p = strend(s);\n    if (p - s > 1 && p[-1] != 10) {\n        *p++ = 10;\n        *p = 0;\n    }\n    return p;\n}\n\nstatic float t1_scan_num(char *p, char **r)\n{\n    float f;\n    skip(p, ' ');\n    if (sscanf(p, \"%g\", &f) != 1) {\n        remove_eol(p, t1_line_array);\n        pdftex_fail(\"a number expected: `%s'\", t1_line_array);\n    }\n    if (r != NULL) {\n        for (; isdigit((unsigned char)*p) || *p == '.' ||\n             *p == 'e' || *p == 'E' || *p == '+' || *p == '-'; p++);\n        *r = p;\n    }\n    return f;\n}\n\nstatic boolean str_suffix(const char *begin_buf, const char *end_buf,\n                          const char *s)\n{\n    const char *s1 = end_buf - 1, *s2 = strend(s) - 1;\n    if (*s1 == 10)\n        s1--;\n    while (s1 >= begin_buf && s2 >= s) {\n        if (*s1-- != *s2--)\n            return false;\n    }\n    return s2 < s;\n}\n\nstatic void t1_getline(void)\n{\n    int c, l, eexec_scan;\n    char *p;\n    static const char eexec_str[] = \"currentfile eexec\";\n    static int eexec_len = 17;  /* strlen(eexec_str) */\n  restart:\n    if (t1_eof())\n        pdftex_fail(\"unexpected end of file\");\n    t1_line_ptr = t1_line_array;\n    alloc_array(t1_line, 1, T1_BUF_SIZE);\n    t1_cslen = 0;\n    eexec_scan = 0;\n    c = t1_getbyte();\n    if (c == EOF)\n        goto exit;\n    while (!t1_eof()) {\n        if (t1_in_eexec == 1)\n            c = edecrypt((byte)c);\n        alloc_array(t1_line, 1, T1_BUF_SIZE);\n        append_char_to_buf(c, t1_line_ptr, t1_line_array, t1_line_limit);\n        if (t1_in_eexec == 0 && eexec_scan >= 0 && eexec_scan < eexec_len) {\n            if (t1_line_array[eexec_scan] == eexec_str[eexec_scan])\n                eexec_scan++;\n            else\n                eexec_scan = -1;\n        }\n        if (c == 10 || (t1_pfa && eexec_scan == eexec_len && c == 32))\n            break;\n        if (t1_cs && t1_cslen == 0 && (t1_line_ptr - t1_line_array > 4) &&\n            (t1_suffix(\" RD \") || t1_suffix(\" -| \"))) {\n            p = t1_line_ptr - 5;\n            while (*p != ' ')\n                p--;\n            t1_cslen = l = t1_scan_num(p + 1, 0);\n            cs_start = t1_line_ptr - t1_line_array;     /* cs_start is an index now */\n            alloc_array(t1_line, l, T1_BUF_SIZE);\n            while (l-- > 0)\n                *t1_line_ptr++ = edecrypt((byte)t1_getbyte());\n        }\n        c = t1_getbyte();\n    }\n    alloc_array(t1_line, 2, T1_BUF_SIZE);       /* append_eol can append 2 chars */\n    append_eol(t1_line_ptr, t1_line_array, t1_line_limit);\n    if (t1_line_ptr - t1_line_array < 2)\n        goto restart;\n    if (eexec_scan == eexec_len)\n        t1_in_eexec = 1;\n  exit:\n    /* ensure that t1_buf_array has as much room as t1_line_array */\n    t1_buf_ptr = t1_buf_array;\n    alloc_array(t1_buf, t1_line_limit, t1_line_limit);\n}\n\nstatic void t1_putline(void)\n{\n    char *p = t1_line_array;\n    if (t1_line_ptr - t1_line_array <= 1)\n        return;\n    if (t1_eexec_encrypt) {\n        while (p < t1_line_ptr)\n            t1_outhex(eencrypt(*p++)); /* dvips outputs hex, unlike pdftex */\n    } else\n        while (p < t1_line_ptr)\n            t1_putchar(*p++);\n}\n\nstatic void t1_puts(const char *s)\n{\n    if (s != t1_line_array)\n        strcpy(t1_line_array, s);\n    t1_line_ptr = strend(t1_line_array);\n    t1_putline();\n}\n\nstatic void t1_printf(const char *fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    vsprintf(t1_line_array, fmt, args);\n    t1_puts(t1_line_array);\n    va_end(args);\n}\n\nstatic void t1_init_params(const char *open_name_prefix)\n{\n    t1_log(open_name_prefix);\n    t1_log(cur_file_name);\n    t1_lenIV = 4;\n    t1_dr = 55665;\n    t1_er = 55665;\n    t1_in_eexec = 0;\n    t1_cs = false;\n    t1_scan = true;\n    t1_synthetic = false;\n    t1_eexec_encrypt = false;\n    t1_block_length = 0;\n    t1_check_pfa();\n}\n\nstatic void t1_close_font_file(const char *close_name_suffix)\n{\n    t1_log(close_name_suffix);\n    t1_close();\n    cur_file_name = NULL;\n}\n\nstatic void t1_check_block_len(boolean decrypt)\n{\n    int l, c;\n    if (t1_block_length == 0)\n        return;\n    c = t1_getbyte();\n    if (decrypt)\n        c = edecrypt((byte)c);\n    l = t1_block_length;\n    if (!(l == 0 && (c == 10 || c == 13))) {\n        pdftex_warn(\"%i bytes more than expected were ignored\", l + 1);\n        while (l-- > 0)\n            t1_getbyte();\n    }\n}\n\nstatic void t1_start_eexec(void)\n{\n    int i;\n    if (is_included(fm_cur)) {\n        get_length1();\n        save_offset();\n    }\n    if (!t1_pfa)\n        t1_check_block_len(false);\n    for (t1_line_ptr = t1_line_array, i = 0; i < 4; i++) {\n        edecrypt((byte)t1_getbyte());\n        *t1_line_ptr++ = 0;\n    }\n    t1_eexec_encrypt = true;\n    if (is_included(fm_cur))\n        t1_putline(); /* to put the first four bytes */\n}\n\nstatic void t1_stop_eexec(void)\n{\n    int c;\n    if (is_included(fm_cur)) {\n        get_length2();\n        save_offset();\n    }\n    end_last_eexec_line();\n    if (!t1_pfa)\n        t1_check_block_len(true);\n    else {\n        c = edecrypt((byte)t1_getbyte());\n        if (!(c == 10 || c == 13)) {\n            if (last_hexbyte == 0)\n                t1_puts(\"00\");\n            else\n                pdftex_warn(\"unexpected data after eexec\");\n        }\n    }\n    t1_cs = false;\n    t1_in_eexec = 2;\n}\n\nstatic void t1_scan_param(void)\n{\n    static const char *lenIV = \"/lenIV\";\n    if (!t1_scan || *t1_line_array != '/')\n        return;\n    if (t1_prefix(lenIV)) {\n        t1_lenIV = t1_scan_num(t1_line_array + strlen(lenIV), 0);\n        if (t1_lenIV < 0)\n            pdftex_fail(\"negative value of lenIV is not supported\");\n        return;\n    }\n    t1_scan_keys();\n}\n\nstatic void copy_glyph_names(char **glyph_names, int a, int b)\n{\n    if (glyph_names[b] != notdef) {\n        xfree(glyph_names[b]);\n        glyph_names[b] = notdef;\n    }\n    if (glyph_names[a] != notdef) {\n        glyph_names[b] = xstrdup(glyph_names[a]);\n    }\n}\n\n/* read encoding from Type1 font file, return glyph_names array, or pdffail() */\n\nstatic char **t1_builtin_enc(void)\n{\n    int i, a, b, c, counter = 0;\n    char *r, *p, **glyph_names;\n    /* At this moment \"/Encoding\" is the prefix of t1_line_array */\n    glyph_names = t1_builtin_glyph_names;\n    for (i = 0; i < 256; i++)\n        glyph_names[i] = notdef;\n    if (t1_suffix(\"def\")) {     /* predefined encoding */\n        if (sscanf(t1_line_array + strlen(\"/Encoding\"), \"%255s\", t1_buf_array) == 1\n            && strcmp(t1_buf_array, \"StandardEncoding\") == 0) {\n            t1_encoding = ENC_STANDARD;\n            for (i = 0; i < 256; i++) {\n                if (standard_glyph_names[i] != notdef)\n                    glyph_names[i] = xstrdup(standard_glyph_names[i]);\n            }\n            return glyph_names;\n        }\n        pdftex_fail(\"cannot subset font (unknown predefined encoding `%s')\",\n                    t1_buf_array);\n    }\n    /* At this moment \"/Encoding\" is the prefix of t1_line_array, and the encoding is\n     * not a predefined encoding.\n     *\n     * We have two possible forms of Encoding vector. The first case is\n     *\n     *     /Encoding [/a /b /c...] readonly def\n     *\n     * and the second case can look like\n     *\n     *     /Encoding 256 array 0 1 255 {1 index exch /.notdef put} for\n     *     dup 0 /x put\n     *     dup 1 /y put\n     *     ...\n     *     readonly def\n     */\n    t1_encoding = ENC_BUILTIN;\n    if (t1_prefix(\"/Encoding [\") || t1_prefix(\"/Encoding[\")) {  /* the first case */\n        r = strchr(t1_line_array, '[') + 1;\n        skip(r, ' ');\n        for (;;) {\n            while (*r == '/') {\n                for (p = t1_buf_array, r++;\n                     *r != 32 && *r != 10 && *r != ']' && *r != '/';\n                     *p++ = *r++);\n                *p = 0;\n                skip(r, ' ');\n                if (counter > 255)\n                    pdftex_fail(\"encoding vector contains more than 256 names\");\n                if (strcmp(t1_buf_array, notdef) != 0)\n                    glyph_names[counter] = xstrdup(t1_buf_array);\n                counter++;\n            }\n            if (*r != 10 && *r != '%') {\n                if (str_prefix(r, \"] def\") || str_prefix(r, \"] readonly def\"))\n                    break;\n                else {\n                    remove_eol(r, t1_line_array);\n                    pdftex_fail\n       (\"a name or `] def' or `] readonly def' expected: `%s'\", t1_line_array);\n                }\n            }\n            t1_getline();\n            r = t1_line_array;\n        }\n    } else {                    /* the second case */\n        p = strchr(t1_line_array, 10);\n        for (;;) {\n            if (*p == 10) {\n                t1_getline();\n                p = t1_line_array;\n            }\n            /*\n               check for `dup <index> <glyph> put'\n             */\n            if (sscanf(p, \"dup %i%255s put\", &i, t1_buf_array) == 2 &&\n                *t1_buf_array == '/' && valid_code(i)) {\n                if (strcmp(t1_buf_array + 1, notdef) != 0)\n                    glyph_names[i] = xstrdup(t1_buf_array + 1);\n                p = strstr(p, \" put\") + strlen(\" put\");\n                skip(p, ' ');\n            }\n            /*\n               check for `dup dup <to> exch <from> get put'\n             */\n            else if (sscanf(p, \"dup dup %i exch %i get put\", &b, &a) == 2\n                     && valid_code(a) && valid_code(b)) {\n                copy_glyph_names(glyph_names, a, b);\n                p = strstr(p, \" get put\") + strlen(\" get put\");\n                skip(p, ' ');\n            }\n            /*\n               check for `dup dup <from> <size> getinterval <to> exch putinterval'\n             */\n            else if (sscanf(p, \"dup dup %i %i getinterval %i exch putinterval\",\n                            &a, &c, &b) == 3\n                     && valid_code(a) && valid_code(b) && valid_code(c)) {\n                for (i = 0; i < c; i++)\n                    copy_glyph_names(glyph_names, a + i, b + i);\n                p = strstr(p, \" putinterval\") + strlen(\" putinterval\");\n                skip(p, ' ');\n            }\n            /*\n               check for `def' or `readonly def'\n             */\n            else if ((p == t1_line_array || (p > t1_line_array && p[-1] == ' '))\n                     && strcmp(p, \"def\\n\") == 0)\n                return glyph_names;\n            /*\n               skip an unrecognizable word\n             */\n            else {\n                while (*p != ' ' && *p != 10)\n                    p++;\n                skip(p, ' ');\n            }\n        }\n    }\n    return glyph_names;\n}\n\nstatic void t1_check_end(void)\n{\n    if (t1_eof())\n        return;\n    t1_getline();\n    if (t1_prefix(\"{restore}\"))\n        t1_putline();\n}\n\nstatic boolean t1_open_fontfile(const char *open_name_prefix)\n{\n    if (!t1_open()) {\n       char *msg = concat (\"! Couldn't find font file \", cur_file_name);\n       error(msg);\n    }\n    t1_init_params(open_name_prefix);\n    return true;                /* font file found */\n}\n\n#define t1_include()\n\n#define check_subr(subr) \\\n    if (subr >= subr_size || subr < 0) \\\n        pdftex_fail(\"Subrs array: entry index out of range (%i)\",  subr);\n\nstatic const char **check_cs_token_pair(void)\n{\n    const char **p = (const char **) cs_token_pairs_list;\n    for (; p[0] != NULL; ++p)\n        if (t1_buf_prefix(p[0]) && t1_buf_suffix(p[1]))\n            return p;\n    return NULL;\n}\n\nstatic void cs_store(boolean is_subr)\n{\n    char *p;\n    cs_entry *ptr;\n    int subr;\n    for (p = t1_line_array, t1_buf_ptr = t1_buf_array; *p != ' ';\n         *t1_buf_ptr++ = *p++);\n    *t1_buf_ptr = 0;\n    if (is_subr) {\n        subr = t1_scan_num(p + 1, 0);\n        check_subr(subr);\n        ptr = subr_tab + subr;\n    } else {\n        ptr = cs_ptr++;\n        if (cs_ptr - cs_tab > cs_size)\n            pdftex_fail\n                (\"CharStrings dict: more entries than dict size (%i)\", cs_size);\n        if (strcmp(t1_buf_array + 1, notdef) == 0)      /* skip the slash */\n            ptr->name = notdef;\n        else\n            ptr->name = xstrdup(t1_buf_array + 1);\n    }\n    /* copy \" RD \" + cs data to t1_buf_array */\n    memcpy(t1_buf_array, t1_line_array + cs_start - 4,\n           (unsigned) (t1_cslen + 4));\n    /* copy the end of cs data to t1_buf_array */\n    for (p = t1_line_array + cs_start + t1_cslen,\n           t1_buf_ptr = t1_buf_array + t1_cslen + 4;\n         *p != 10; *t1_buf_ptr++ = *p++);\n    *t1_buf_ptr++ = 10;\n    if (is_subr && cs_token_pair == NULL)\n        cs_token_pair = check_cs_token_pair();\n    ptr->len = t1_buf_ptr - t1_buf_array;\n    ptr->cslen = t1_cslen;\n    ptr->data = xtalloc(ptr->len, byte);\n    memcpy(ptr->data, t1_buf_array, ptr->len);\n    ptr->valid = true;\n}\n\n#define store_subr()     cs_store(true)\n#define store_cs()       cs_store(false)\n\n#define CC_STACK_SIZE    24\n\nstatic integer cc_stack[CC_STACK_SIZE], *stack_ptr = cc_stack;\nstatic cc_entry cc_tab[CS_MAX];\nstatic boolean is_cc_init = false;\n\n#define cc_pop(N)                   \\\n    if (stack_ptr - cc_stack < (N)) \\\n        stack_error(N);             \\\n    stack_ptr -= N\n\n#define stack_error(N) {            \\\n    pdftex_fail(\"CharString: invalid access (%i) to stack (%i entries)\", \\\n                (int) N, (int)(stack_ptr - cc_stack));                  \\\n    goto cs_error;                  \\\n}\n\n/*\nstatic integer cc_get(integer index)\n{\n    if (index <  0) {\n        if (stack_ptr + index < cc_stack )\n            stack_error(stack_ptr - cc_stack + index);\n        return *(stack_ptr + index);\n    }\n    else {\n        if (cc_stack  + index >= stack_ptr)\n            stack_error(index);\n        return cc_stack[index];\n    }\n}\n*/\n\n#define cc_get(N)   ((N) < 0 ? *(stack_ptr + (N)) : *(cc_stack + (N)))\n#define cc_push(V)  *stack_ptr++ = V\n#define cc_clear()  stack_ptr = cc_stack\n#define set_cc(N, B, A, C) \\\n    cc_tab[N].nargs = A;   \\\n    cc_tab[N].bottom = B;  \\\n    cc_tab[N].clear = C;   \\\n    cc_tab[N].valid = true\n\nstatic void cc_init(void)\n{\n    int i;\n    if (is_cc_init)\n        return;\n    for (i = 0; i < CS_MAX; i++)\n        cc_tab[i].valid = false;\n    set_cc(CS_HSTEM, true, 2, true);\n    set_cc(CS_VSTEM, true, 2, true);\n    set_cc(CS_VMOVETO, true, 1, true);\n    set_cc(CS_RLINETO, true, 2, true);\n    set_cc(CS_HLINETO, true, 1, true);\n    set_cc(CS_VLINETO, true, 1, true);\n    set_cc(CS_RRCURVETO, true, 6, true);\n    set_cc(CS_CLOSEPATH, false, 0, true);\n    set_cc(CS_CALLSUBR, false, 1, false);\n    set_cc(CS_RETURN, false, 0, false);\n    /*\n       set_cc(CS_ESCAPE, false, 0, false);\n     */\n    set_cc(CS_HSBW, true, 2, true);\n    set_cc(CS_ENDCHAR, false, 0, true);\n    set_cc(CS_RMOVETO, true, 2, true);\n    set_cc(CS_HMOVETO, true, 1, true);\n    set_cc(CS_VHCURVETO, true, 4, true);\n    set_cc(CS_HVCURVETO, true, 4, true);\n    set_cc(CS_DOTSECTION, false, 0, true);\n    set_cc(CS_VSTEM3, true, 6, true);\n    set_cc(CS_HSTEM3, true, 6, true);\n    set_cc(CS_SEAC, true, 5, true);\n    set_cc(CS_SBW, true, 4, true);\n    set_cc(CS_DIV, false, 2, false);\n    set_cc(CS_CALLOTHERSUBR, false, 0, false);\n    set_cc(CS_POP, false, 0, false);\n    set_cc(CS_SETCURRENTPOINT, true, 2, true);\n    is_cc_init = true;\n}\n\n#define cs_getchar()     cdecrypt(*data++, &cr)\n\n#define mark_subr(n)     cs_mark(0, n)\n#define mark_cs(s)       cs_mark(s, 0)\n\nstatic void cs_fail(const char *cs_name, int subr, const char *fmt, ...)\n{\n    char buf[SMALL_BUF_SIZE];\n    va_list args;\n    va_start(args, fmt);\n    vsprintf(buf, fmt, args);\n    va_end(args);\n    if (cs_name == NULL)\n        pdftex_warn(\"Subr (%i): %s\", (int) subr, buf);\n    else\n        pdftex_warn(\"CharString (/%s): %s\", cs_name, buf);\n}\n\n/* fix a return-less subr by appending CS_RETURN */\nstatic void append_cs_return(cs_entry *ptr)\n{\n    unsigned short cr;\n    int i;\n    byte *p, *q, *data, *new_data;\n    assert(ptr != NULL && ptr->valid && ptr->used);\n\n    /* decrypt the cs data to t1_buf_array, append CS_RETURN */\n    p = (byte *) t1_buf_array;\n    data = ptr->data + 4;\n    cr = 4330;\n    for (i = 0; i < ptr->cslen; i++)\n        *p++ = cs_getchar();\n    *p = CS_RETURN;\n\n    /* encrypt the new cs data to new_data */\n    new_data = xtalloc(ptr->len + 1, byte);\n    memcpy(new_data, ptr->data, 4);\n    p = new_data + 4;\n    q = (byte *) t1_buf_array;\n    cr = 4330;\n    for (i = 0; i < ptr->cslen + 1; i++)\n        *p++ = cencrypt(*q++, &cr);\n    memcpy(p, ptr->data + 4 + ptr->cslen, ptr->len - ptr->cslen - 4);\n\n    /* update *ptr */\n    xfree(ptr->data);\n    ptr->data = new_data;\n    ptr->len++;\n    ptr->cslen++;\n}\n\nstatic void cs_mark(const char *cs_name, int subr)\n{\n    byte *data;\n    int i, b, cs_len;\n    int last_cmd = 0;\n    integer a, a1, a2;\n    unsigned short cr;\n    static integer lastargOtherSubr3 = 3;       /* the argument of last call to\n                                                   OtherSubrs[3] */\n    cs_entry *ptr;\n    cc_entry *cc;\n    if (cs_name == NULL) {\n        check_subr(subr);\n        ptr = subr_tab + subr;\n        if (!ptr->valid)\n            return;\n    } else {\n        if (cs_notdef != NULL &&\n            (cs_name == notdef || strcmp(cs_name, notdef) == 0))\n            ptr = cs_notdef;\n        else {\n            for (ptr = cs_tab; ptr < cs_ptr; ptr++)\n                if (strcmp(ptr->name, cs_name) == 0)\n                    break;\n            if (ptr == cs_ptr) {\n                pdftex_warn(\"glyph `%s' undefined\", cs_name);\n                return;\n            }\n            if (ptr->name == notdef)\n                cs_notdef = ptr;\n        }\n    }\n    /* only marked CharString entries and invalid entries can be skipped;\n       valid marked subrs must be parsed to keep the stack in sync */\n    if (!ptr->valid || (ptr->used && cs_name != NULL))\n        return;\n    ptr->used = true;\n    cr = 4330;\n    cs_len = ptr->cslen;\n    data = ptr->data + 4;\n    for (i = 0; i < t1_lenIV; i++, cs_len--)\n        cs_getchar();\n    while (cs_len > 0) {\n        --cs_len;\n        b = cs_getchar();\n        if (b >= 32) {\n            if (b <= 246)\n                a = b - 139;\n            else if (b <= 250) {\n                --cs_len;\n                a = ((b - 247) << 8) + 108 + cs_getchar();\n            } else if (b <= 254) {\n                --cs_len;\n                a = -((b - 251) << 8) - 108 - cs_getchar();\n            } else {\n                cs_len -= 4;\n                a = (cs_getchar() & 0xff) << 24;\n                a |= (cs_getchar() & 0xff) << 16;\n                a |= (cs_getchar() & 0xff) << 8;\n                a |= (cs_getchar() & 0xff) << 0;\n                if (sizeof(integer) > 4 && (a & 0x80000000))\n                    a |= ~0x7FFFFFFF;\n            }\n            cc_push(a);\n        } else {\n            if (b == CS_ESCAPE) {\n                b = cs_getchar() + CS_1BYTE_MAX;\n                cs_len--;\n            }\n            if (b >= CS_MAX) {\n                cs_fail(cs_name, subr, \"command value out of range: %i\",\n                        (int) b);\n                goto cs_error;\n            }\n            cc = cc_tab + b;\n            if (!cc->valid) {\n                cs_fail(cs_name, subr, \"command not valid: %i\", (int) b);\n                goto cs_error;\n            }\n            if (cc->bottom) {\n                if (stack_ptr - cc_stack < cc->nargs)\n                    cs_fail(cs_name, subr,\n                            \"less arguments on stack (%i) than required (%i)\",\n                            (int) (stack_ptr - cc_stack), (int) cc->nargs);\n                else if (stack_ptr - cc_stack > cc->nargs)\n                    cs_fail(cs_name, subr,\n                            \"more arguments on stack (%i) than required (%i)\",\n                            (int) (stack_ptr - cc_stack), (int) cc->nargs);\n            }\n            last_cmd = b;\n            switch (cc - cc_tab) {\n            case CS_CALLSUBR:\n                a1 = cc_get(-1);\n                cc_pop(1);\n                mark_subr(a1);\n                if (!subr_tab[a1].valid) {\n                    cs_fail(cs_name, subr, \"cannot call subr (%i)\", (int) a1);\n                    goto cs_error;\n                }\n                break;\n            case CS_DIV:\n                cc_pop(2);\n                cc_push(0);\n                break;\n            case CS_CALLOTHERSUBR:\n                if (cc_get(-1) == 3)\n                    lastargOtherSubr3 = cc_get(-3);\n                a1 = cc_get(-2) + 2;\n                cc_pop(a1);\n                break;\n            case CS_POP:\n                cc_push(lastargOtherSubr3);\n                /* the only case when we care about the value being pushed onto\n                   stack is when POP follows CALLOTHERSUBR (changing hints by\n                   OtherSubrs[3])\n                 */\n                break;\n            case CS_SEAC:\n                a1 = cc_get(3);\n                a2 = cc_get(4);\n                cc_clear();\n                mark_cs(standard_glyph_names[a1]);\n                mark_cs(standard_glyph_names[a2]);\n                break;\n            default:\n                if (cc->clear)\n                    cc_clear();\n            }\n        }\n    }\n    if (cs_name == NULL && last_cmd != CS_RETURN) {\n        pdftex_warn(\"last command in subr `%i' is not a RETURN; \"\n                    \"I will add it now but please consider fixing the font\",\n                    (int) subr);\n        append_cs_return(ptr);\n    }\n    return;\n  cs_error:                    /* an error occured during parsing */\n    cc_clear();\n    ptr->valid = false;\n    ptr->used = false;\n}\n\nstatic void t1_subset_ascii_part(void)\n{\n    int i, j;\n    t1_getline();\n    while (!t1_prefix(\"/Encoding\")) {\n        t1_scan_param();\n        if (!(t1_prefix(\"/UniqueID\")\n              && !strncmp(t1_line_array + strlen(t1_line_array) -4, \"def\", 3)))\n            t1_putline();\n        t1_getline();\n    }\n    if (is_reencoded(fm_cur))\n        t1_glyph_names = external_enc();\n    else\n        t1_glyph_names = t1_builtin_enc();\n    if (is_included(fm_cur) && is_subsetted(fm_cur)) {\n        make_subset_tag(fm_cur, t1_glyph_names);\n        update_subset_tag();\n    }\n    if (t1_encoding == ENC_STANDARD)\n        t1_puts(\"/Encoding StandardEncoding def\\n\");\n    else {\n        t1_puts\n            (\"/Encoding 256 array\\n0 1 255 {1 index exch /.notdef put} for\\n\");\n        for (i = 0, j = 0; i < 256; i++) {\n            if (is_used_char(i) && t1_glyph_names[i] != notdef) {\n                j++;\n                t1_printf(\"dup %i /%s put\\n\", (int)t1_char(i), t1_glyph_names[i]);\n            }\n        }\n        if (j == 0)\n            /* We didn't mark anything for the Encoding array. */\n            /* We add \"dup 0 /.notdef put\" for compatibility   */\n            /* with Acrobat 5.0.                               */\n            t1_puts(\"dup 0 /.notdef put\\n\");\n        t1_puts(\"readonly def\\n\");\n    }\n    do {\n        t1_getline();\n        t1_scan_param();\n        if (!t1_prefix(\"/UniqueID\"))    /* ignore UniqueID for subsetted fonts */\n            t1_putline();\n    } while (t1_in_eexec == 0);\n}\n\nstatic void cs_init(void)\n{\n    cs_ptr = cs_tab = NULL;\n    cs_dict_start = cs_dict_end = NULL;\n    cs_count = cs_size = cs_size_pos = 0;\n    cs_token_pair = NULL;\n    subr_tab = NULL;\n    subr_array_start = subr_array_end = NULL;\n    subr_max = subr_size = subr_size_pos = 0;\n}\n\nstatic void init_cs_entry(cs_entry *cs)\n{\n    cs->data = NULL;\n    cs->name = NULL;\n    cs->len = 0;\n    cs->cslen = 0;\n    cs->used = false;\n    cs->valid = false;\n}\n\nstatic void t1_read_subrs(void)\n{\n    int i, s;\n    cs_entry *ptr;\n    t1_getline();\n    while (!(t1_charstrings() || t1_subrs())) {\n        t1_scan_param();\n        t1_putline();\n        t1_getline();\n    }\n  found:\n    t1_cs = true;\n    t1_scan = false;\n    if (!t1_subrs())\n        return;\n    subr_size_pos = strlen(\"/Subrs\") + 1;\n    /* subr_size_pos points to the number indicating dict size after \"/Subrs\" */\n    subr_size = t1_scan_num(t1_line_array + subr_size_pos, 0);\n    if (subr_size == 0) {\n        while (!t1_charstrings())\n            t1_getline();\n        return;\n    }\n    subr_tab = xtalloc(subr_size, cs_entry);\n    for (ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n        init_cs_entry(ptr);\n    subr_array_start = xstrdup(t1_line_array);\n    t1_getline();\n    while (t1_cslen) {\n        store_subr();\n        t1_getline();\n    }\n    /* mark the first four entries without parsing */\n    for (i = 0; i < subr_size && i < 4; i++)\n        subr_tab[i].used = true;\n    /* the end of the Subrs array might have more than one line so we need to\n       concatnate them to subr_array_end. Unfortunately some fonts don't have\n       the Subrs array followed by the CharStrings dict immediately (synthetic\n       fonts). If we cannot find CharStrings in next POST_SUBRS_SCAN lines then\n       we will treat the font as synthetic and ignore everything until next\n       Subrs is found\n     */\n\n#define POST_SUBRS_SCAN  5\n\n    s = 0;\n    *t1_buf_array = 0;\n    for (i = 0; i < POST_SUBRS_SCAN; i++) {\n        if (t1_charstrings())\n            break;\n        s += t1_line_ptr - t1_line_array;\n        alloc_array(t1_buf, s, T1_BUF_SIZE);\n        strcat(t1_buf_array, t1_line_array);\n        t1_getline();\n    }\n    subr_array_end = xstrdup(t1_buf_array);\n    if (i == POST_SUBRS_SCAN) { /* CharStrings not found;\n                                   suppose synthetic font */\n        for (ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n            if (ptr->valid)\n                xfree(ptr->data);\n        xfree(subr_tab);\n        xfree(subr_array_start);\n        xfree(subr_array_end);\n        cs_init();\n        t1_cs = false;\n        t1_synthetic = true;\n        while (!(t1_charstrings() || t1_subrs()))\n            t1_getline();\n        goto found;\n    }\n}\n\n#define t1_subr_flush()  t1_flush_cs(true)\n#define t1_cs_flush()    t1_flush_cs(false)\n\nstatic void t1_flush_cs(boolean is_subr)\n{\n    char *p;\n    byte *r, *return_cs = NULL;\n    cs_entry *tab, *end_tab, *ptr;\n    char *start_line, *line_end;\n    int count, size_pos;\n    unsigned short cr, cs_len = 0;      /* to avoid warning about uninitialized use of cs_len */\n    if (is_subr) {\n        start_line = subr_array_start;\n        line_end = subr_array_end;\n        size_pos = subr_size_pos;\n        tab = subr_tab;\n        count = subr_max + 1;\n        end_tab = subr_tab + count;\n    } else {\n        start_line = cs_dict_start;\n        line_end = cs_dict_end;\n        size_pos = cs_size_pos;\n        tab = cs_tab;\n        end_tab = cs_ptr;\n        count = cs_count;\n    }\n    t1_line_ptr = t1_line_array;\n    for (p = start_line; p - start_line < size_pos;)\n        *t1_line_ptr++ = *p++;\n    while (isdigit((unsigned char)*p))\n        p++;\n    sprintf(t1_line_ptr, \"%u\", count);\n    strcat(t1_line_ptr, p);\n    t1_line_ptr = eol(t1_line_array);\n    t1_putline();\n\n    /* create return_cs to replace unused subr's */\n    if (is_subr) {\n        cr = 4330;\n        cs_len = 0;\n        /* at this point we have t1_lenIV >= 0;\n         * a negative value would be caught in t1_scan_param() */\n        return_cs = xtalloc(t1_lenIV + 1, byte);\n        for (cs_len = 0, r = return_cs; cs_len < t1_lenIV; cs_len++, r++)\n            *r = cencrypt(0x00, &cr);\n        *r = cencrypt(CS_RETURN, &cr);\n        cs_len++;\n    }\n\n    for (ptr = tab; ptr < end_tab; ptr++) {\n        if (ptr->used) {\n            if (is_subr)\n                sprintf(t1_line_array, \"dup %lu %u\",\n                        (unsigned long) (ptr - tab), ptr->cslen);\n            else\n                sprintf(t1_line_array, \"/%s %u\", ptr->name, ptr->cslen);\n            p = strend(t1_line_array);\n            memcpy(p, ptr->data, ptr->len);\n            t1_line_ptr = p + ptr->len;\n            t1_putline();\n        } else {\n            /* replace unsused subr's by return_cs */\n            if (is_subr) {\n                sprintf(t1_line_array, \"dup %lu %u%s \",\n                        (unsigned long) (ptr - tab), cs_len, cs_token_pair[0]);\n                p = strend(t1_line_array);\n                memcpy(p, return_cs, cs_len);\n                t1_line_ptr = p + cs_len;\n                t1_putline();\n                sprintf(t1_line_array, \" %s\", cs_token_pair[1]);\n                t1_line_ptr = eol(t1_line_array);\n                t1_putline();\n            }\n        }\n        xfree(ptr->data);\n        if (ptr->name != notdef)\n            xfree(ptr->name);\n    }\n    sprintf(t1_line_array, \"%s\", line_end);\n    t1_line_ptr = eol(t1_line_array);\n    t1_putline();\n    if (is_subr)\n        xfree(return_cs);\n    xfree(tab);\n    xfree(start_line);\n    xfree(line_end);\n}\n\nstatic void t1_mark_glyphs(void)\n{\n    int i;\n    char *charset = extra_charset();\n    char *g, *s, *r;\n    cs_entry *ptr;\n    if (t1_synthetic || embed_all_glyphs(tex_font)) { /* mark everything */\n        if (cs_tab != NULL)\n            for (ptr = cs_tab; ptr < cs_ptr; ptr++)\n                if (ptr->valid)\n                    ptr->used = true;\n        if (subr_tab != NULL) {\n            for (ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n                if (ptr->valid)\n                    ptr->used = true;\n            subr_max = subr_size - 1;\n        }\n        return;\n    }\n    mark_cs(notdef);\n    for (i = 0; i < 256; i++)\n        if (is_used_char(i)) {\n            if (t1_glyph_names[i] == notdef)\n                pdftex_warn(\"character %i is mapped to %s\", i, notdef);\n            else\n                mark_cs(t1_glyph_names[i]);\n        }\n    if (charset == NULL)\n        goto set_subr_max;\n    g = s = charset + 1; /* skip the first '/' */\n    r = strend(g);\n    while (g < r) {\n        while (*s != '/' && s < r)\n            s++;\n        *s = 0; /* terminate g by rewriting '/' to 0 */\n        mark_cs(g);\n        g = s + 1;\n    }\n  set_subr_max:\n    if (subr_tab != NULL)\n        for (subr_max = -1, ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n            if (ptr->used && ptr - subr_tab > subr_max)\n                subr_max = ptr - subr_tab;\n}\n\nstatic void t1_check_unusual_charstring(void)\n{\n    char *p = strstr(t1_line_array, charstringname) + strlen(charstringname);\n    int i;\n    /* if no number follows \"/CharStrings\", let's read the next line */\n    if (sscanf(p, \"%i\", &i) != 1) {\n        /* pdftex_warn(\"no number found after `%s', I assume it's on the next line\",\n                    charstringname); */\n        strcpy(t1_buf_array, t1_line_array);\n\n        /* t1_getline always appends EOL to t1_line_array; let's change it to\n         * space before appending the next line\n         */\n        *(strend(t1_buf_array) - 1) = ' ';\n\n        t1_getline();\n        strcat(t1_buf_array, t1_line_array);\n        strcpy(t1_line_array, t1_buf_array);\n        t1_line_ptr = eol(t1_line_array);\n    }\n}\n\nstatic void t1_subset_charstrings(void)\n{\n    cs_entry *ptr;\n\n    /* at this point t1_line_array contains \"/CharStrings\".\n       when we hit a case like this:\n         dup/CharStrings\n         229 dict dup begin\n       we read the next line and concatenate to t1_line_array before moving on\n    */\n    t1_check_unusual_charstring();\n\n    cs_size_pos = strstr(t1_line_array, charstringname)\n                  + strlen(charstringname) - t1_line_array + 1;\n    /* cs_size_pos points to the number indicating\n       dict size after \"/CharStrings\" */\n    cs_size = t1_scan_num(t1_line_array + cs_size_pos, 0);\n    cs_ptr = cs_tab = xtalloc(cs_size, cs_entry);\n    for (ptr = cs_tab; ptr - cs_tab < cs_size; ptr++)\n        init_cs_entry(ptr);\n    cs_notdef = NULL;\n    cs_dict_start = xstrdup(t1_line_array);\n    t1_getline();\n    while (t1_cslen) {\n        store_cs();\n        t1_getline();\n    }\n    cs_dict_end = xstrdup(t1_line_array);\n    t1_mark_glyphs();\n    if (subr_tab != NULL) {\n        if (cs_token_pair == NULL)\n            pdftex_fail\n                (\"This Type 1 font uses mismatched subroutine begin/end token pairs.\");\n        t1_subr_flush();\n    }\n    for (cs_count = 0, ptr = cs_tab; ptr < cs_ptr; ptr++)\n        if (ptr->used)\n            cs_count++;\n    t1_cs_flush();\n}\n\nstatic void t1_subset_end(void)\n{\n    if (t1_synthetic) {         /* copy to \"dup /FontName get exch definefont pop\" */\n        while (!strstr(t1_line_array, \"definefont\")) {\n            t1_getline();\n            t1_putline();\n        }\n        while (!t1_end_eexec())\n            t1_getline();       /* ignore the rest */\n        t1_putline();           /* write \"mark currentfile closefile\" */\n    } else\n        while (!t1_end_eexec()) {       /* copy to \"mark currentfile closefile\" */\n            t1_getline();\n            t1_putline();\n        }\n    t1_stop_eexec();\n    if (fixedcontent) {         /* copy 512 zeros (not needed for PDF) */\n        while (!t1_cleartomark()) {\n            t1_getline();\n            t1_putline();\n        }\n        if (!t1_synthetic)      /* don't check \"{restore}if\" for synthetic fonts */\n            t1_check_end();     /* write \"{restore}if\" if found */\n    }\n    get_length3();\n}\n\nstatic void writet1(void)\n{\n    read_encoding_only = false;\n    if (!is_included(fm_cur)) { /* scan parameters from font file */\n        if (!t1_open_fontfile(\"{\"))\n            return;\n        t1_scan_only();\n        t1_close_font_file(\"}\");\n        return;\n    }\n    if (!is_subsetted(fm_cur)) { /* include entire font */\n        if (!t1_open_fontfile(\"<<\"))\n            return;\n        t1_include();\n        t1_close_font_file(\">>\");\n        return;\n    }\n    /* partial downloading */\n    if (!t1_open_fontfile(\"<\"))\n        return;\n    t1_subset_ascii_part();\n    t1_start_eexec();\n    cc_init();\n    cs_init();\n    t1_read_subrs();\n    t1_subset_charstrings();\n    t1_subset_end();\n    t1_close_font_file(\">\");\n}\n\nboolean t1_subset_2(char *fontfile, unsigned char *g, char *extraGlyphs)\n{\n    int i;\n    for (i = 0; i < 256; i++)\n        ext_glyph_names[i] = (char*) notdef;\n    grid = g;\n    cur_file_name = fontfile;\n    hexline_length = 0;\n    dvips_extra_charset = extraGlyphs;\n    writet1();\n    for (i = 0; i < 256; i++)\n        if (ext_glyph_names[i] != notdef)\n            free(ext_glyph_names[i]);\n    return 1; /* note:  there *is* no unsuccessful return */\n}\n", "2018-08-27 Luigi Scarso <luigi.scarso@gmail.com>\n\t* dropped dependency from gmp and mpfr\n\n\n2017-11-02 Luigi Scarso <luigi.scarso@gmail.com>\n\tLuaFilesystem 1.7.0\n\n2017-10-03  Luigi Scarso <luigi.scarso@gmail.com>\n\tA not exhaustive list of changes:\n\n\t* luaffi/: Fix to compile with gcc 7.1, \n\tpatch for callbacks.\n\t* lpeg/: version 1.0.1\n\n\t* luatex.c: We conform to the way Web2c does handle trailing tabs and spaces. This\n\tdecade old behaviour was changed in September 2017 and can introduce\n\tcompatibility issues in existing workflows. Because we don't want too\n\tmany differences with upstream TeXlive we just follow up on that patch\n\tand it's up to macro packages to deal with possible issues (which can be\n\tdone via the usual callbacks. One can wonder why we then still prune\n\tspaces but we leave that to the reader.\n\n\t* option to set exit code (status.setexitcode) (HH). Changed paths:\n\tluatexdir/tex/errors.h, luatexdir/tex/errors.w\n\n\t* missing_glyph callback (HH). Changed paths:\n\tluatexdir/font/texfont.h, luatexdir/font/texfont.w,luatexdir/lua/lcallbacklib.c\n\tluatexdir/luatexcallbackids.h, \tluatexdir/pdf/pdffont.w, luatexdir/pdf/pdfglyph.w;\n\n\t* \\mathdelimitersmode (see manual) (HH). Changed paths:\n\tluatexdir/tex/mlist.w, luatexdir/tex/texnodes.h\n\n\t* fixes in protect/unprotect and list support in set/getglue (HH). Changed paths:\n\tluatexdir/lua/lnodelib.c\n\n\t* 'class' string in pdf vf command optional (HH). Changed paths:\n\tluatexdir/font/luafont.w\n\n\t* cleanup expansion (HH). Changed paths:\n\tluatexdir/font/luafont.w, luatexdir/font/texfont.h, luatexdir/font/texfont.w\n\tluatexdir/lua/lfontlib.c, luatexdir/lua/luatex-api.h, luatexdir/tex/dumpdata.w\n\n\t* possibly better fix for extended font embedding (HH). Changed paths:\n\tluatexdir/font/writefont.w\n\n\t* protect_glyphs accepts range and also made consistent with manual (HH). Changed path:\n\tluatexdir/lua/lnodelib.c\n\n\t* some more control over syntex fields (HH). Changed paths:\n\tluatexdir/tex/texnodes.w\n\n\t* fix for neg display skips (HH). Changed paths:\n\tluatexdir/tex/texmath.w\n\n\t* \\breakafterdirmode (value 1 will honor glue breaks after a dir node) (HH). Changed paths:\n\tluatexdir/tex/commands.w, luatexdir/tex/dumpdata.w, luatexdir/tex/equivalents.h,\n\tluatexdir/tex/linebreak.w, luatexdir/tex/texnodes.h\n\n\t* fix width array of extended font (shared with normal)(HH). Changed paths:\n\tluatexdir/font/writefont.w\n\n\n\n2017-02-07  Luigi Scarso <luigi.scarso@gmail.com>\n\n\t* luaffi/: First attempt to implement the ffi module in lua\n\tcompatible with the ffi module of luajit.\n\n\n2015-11-01  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* luatex.c: Improve a little (w32 only).\n\n2015-10-31  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* tex/inputstack.w: Sync with the upstream.\n\n2015-10-13  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* tex/mlist.w: Sync with the upstream.\n\n2015-10-09  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* luatex.c: Sync with the upstream.\n\t* font/luatexfont.h, font/writetype2.w: Sync with the upstream.\n\n2015-10-08  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* lua/lepdflib.cc, tex/texnodes.h, tex/texnodes.w, NEWS:\n\tSync with the upstream.\n\t* luatex.c: beta-0.81.0.\n\n2015-10-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am, am/luafontforge.am: Rearrange to compile the\n\tluafontloader/src/* files as part of liblua(jit)tex.a, such that\n\tthere is only one libff.a used for LuaTeX and LuaJITTeX.\n\n2015-10-07  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* Sync with the upstream trunk.\n\t* image/epdf.h: Support Visual Studio 2010 for log().\n\n2015-10-05  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* Completely sync with the upstream trunk.\n\tChanged files are\n\tfont/writecff.w, font/writefont.w,\n\tlua/lnodelib.c, lua/lpdflib.c, lua/luatoken.w,\n\tluafontloader/fontforge/fontforge/lookups.c,\n\tluafontloader/fontforge/fontforge/parsettf.c,\n\tluafontloader/fontforge/fontforge/parsettfatt.c,\n\tluafontloader/fontforge/fontforge/splinefont.h,\n\tluafontloader/fontforge/fontforge/tottf.c,\n\tluafontloader/src/luafflib.c,\n\tluatex.c,\n\ttex/commands.w, tex/dumpdata.w, tex/equivalents.h, tex/filename.w,\n\ttex/maincontrol.w, tex/printing.w, tex/texmath.w.\n\n2015-10-01  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdf/pdfgen.w: Sync with the upstream trunk.\n\n2015-09-01  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/lepdflib.cc: Drop useless casts 'const char *' -> 'char *'\n\twhen poppler has Object::initCmd(const char*).\n\n2015-08-31  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/lepdflib.cc: Bugfix: m_Object_dictAdd() must use a copy of\n\tthe Lua string s, otherwise m_Dict_remove() would destroy it.\n\n2015-08-29  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/epdf.h, lua/lepdflib.cc: Drop HAVE_STRUCTTREEROOT_H,\n\twe now require poppler 0.30 better.\n\t\n2015-08-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am: Enable g++ warnings.\n\t* image/epdf.h, image/pdftoepdf.w, lua/lepdflib.cc: Avoid most\n\tg++ warnings.\n\n2015-08-27  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/pdftoepdf.w: Drop useless casts to avoid warnings.\n\t* lua/lpdfscannerlib.cc: Unconstify Token.string to avoid warning.\n\t* lua/lepdflib.cc: Drop useless casts to avoid some warnings.\n\n2015-08-27  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* tex/mlist.w: Sync with the trunk.\n\tSee http://tug.org/pipermail/luatex/2015-August/005319.html\n\t* tex/printing.w: Do not write to a log file for the\n\t--[no-]parse-first-line option, since the option actually does not\n\texist in lua(jit)tex, although superficially it remains for compatibility\n\twith existing scripts etc.\n\n2015-07-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luatex.am: Dependencies for 'make check'.\n\n2015-07-03  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/lkpselib.c: Also used for MFLua and MFLuaJIT.\n\n2015-03-31  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luazip/src/luazip.c (zip_close): Sync with the upstream.\n\n2015-03-19 Luigi Scarso <luigi.scarso@gmail.com>\n\n\tNew library newtokenlib; several bugs fixed.\n\n2015-01-14 Luigi Scarso <luigi.scarso@gmail.com>\n\n\ttex/mlist.w: mlist_to_hlist(pointer mlist, boolean penalties, int cur_style)\n\tHH-LS: was cur_mu = x_over_n(get_math_quad(cur_size), 18);\n\tThis is an old bug so the fix can influence outcome       \n\tThe current mu is instead\n\tcur_mu = x_over_n(get_math_quad(cur_style), 18);\n\tThanks to joseph.wright <joseph.wright@morningstar2.co.uk>\n\n2014-12-21  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* lua/lnodelib.c: Sync with the upstream. Luigi fixes 'print' for\n\talink(n) when n is an attribute node.\n\n2014-12-20  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* tex/texnodes.w: Sync with the upstream. Luigi makes minor changes.\n\n2014-12-18  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* tex/texnodes.w: Sync with the upstream. Luigi makes minor changes.\n\n2014-12-17  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* tex/texnodes.w: Sync with the upstream.\n\tLuigi fixes a bug on cached attributes.\n\n2014-12-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tAvoid implicit function declarations.\n\t* am/luafontforge.am (libjitff_a_CPPFLAGS): Add -DLuajitTeX.\n\t* am/luamisc.am (libluajitmisc_a_CPPFLAGS: Add -DLuajitTeX.\n\t* lua/liolibext.c, lua/lnodelib.c, luafontloader/src/luafflib.c,\n\tslnunicode/slnunico.c: Include lauxlib_bridge.h for LuaJITTeX or\n\tlauxlib.h for LuaTeX.\n\t* luafontloader/fontforge/fontforge/fontviewbase.c:\n\tInclude gfile.h.\t\n\n2014-12-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tSync with https://foundry.supelec.fr/svn/luatex/trunk/source/\n\t                  texk/web2c/luatexdir/ r5092.\n\n2014-11-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.c: Avoid MinGW64 warnings (INVALID_SOCKET => -1).\n\n2014-11-03  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* luatex.c: Indentation.\n\n2014-10-31  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.[ch] [W32TEX]: Handle DLLPROC as for TeX & Co.\n\t* am/luatex.am: Define LuajitTeX.\n\n2014-10-13  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.[ch]: More sync with ../texmfmp.h and ../lib/texmfmp.c.\n\n2014-10-09  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.c: Apply some code from W32TeX.\n\n2014-10-08  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.c: Sync with some recent changes in ../lib/texmfmp.c\n\t(and luatexfirst.c from W32TeX).\n\n2014-09-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luatex.am: Factor out common *_LDADD and *_DEPENDENCIES.\n\n2014-08-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/writepng.w: Avoid PNG warnings.\n\n2014-07-15  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/epdf.h, lua/lepdflib.cc: Use code for poppler >= 0.25\n\twith <StructTreeRoot.h> or code for poppler <= 0.24 without.\n\t* fake/StructTreeRoot.h (removed): Obsolete.\n\t* am/libluatex.am: Adapted.\n\n2014-07-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luasocket/src/wsocket.h: Avoid redefinition of _WIN32_WINNT.\n\n2014-07-11  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am: Compiling liblua(jit)tex.a requires mplib.h;\n\tadd libmplib.a as dependency.\n\n2014-06-20  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am: Remove ../mplibdir/lmplib.c from sources and\n\tdependency on libmplib.a.\n\t* am/luatex.am: Add ../mplibdir/lmplib.c to sources, dependency\n\ton libmplib.a, and -DpdfTeX to CPPFLAGS.\n\n\t* am/luatex.am: Adapt to MetaPost 1.999 (libgmp and libmpfr).\n\n2014-06-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* font/mapfile.w, font/tounicode.w, font/writet1.w,\n\tfont/writettf.w, lang/texlang.w, pdf/pdfgen.w: Avoid undefined\n\tbehaviour when char is signed.\n\n2014-06-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/luatex-api.h: Use '#define LUAI_HASHLIMIT 5' as default,\n\tas in ../../libs/lua52/lua-5.2.3/src/lstring.c and in\n\t../../libs/luajit/LuaJIT-2.0.3/src/lj_str.c.\n\t* lua/lstatslib.c, tex/printing.w: Use LUAI_HASHLIMIT instead of\n\tLUATEX_HASHCHARS and LUAJITTEX_HASHCHARS.\n\n\t* lua/luatex-api.h: Define MyName as \"LuajitTeX\"/\"LuaTeX\" and\n\tmy_name as \"luajittex\"/\"luatex\".\n\t* lua/luainit.w, luatex.c, tex/printing.w: Use MyName, my_name.\n\n2014-05-14  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* tex/filename.w: Avoid redefinition of promptfilenamehelpmsg,\n\t(re)use definition in ../cpascal.h.\n\n2014-05-13  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* tex/filename.w: Print the usual TeX promptfilenamehelpmsg also\n\tin lua(jit)tex.\n\n2014-04-10  Taco Hoekwater  <taco@luatex.org>\n\n\t* luatex.c: hardwire the compilation date, preventing the \n\tluatex binary from constantly changing after recompilation\n\n2014-03-29  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdf/pdfgen.[hw]: Declare get_pdf_table_string() as\n\t'static const char *'.\n\n2014-03-29  Taco Hoekwater  <taco@luatex.org>\n\n\tImport LuaTeX 0.79.1 from LuaTeX repository (released)\n\n2014-03-28  Taco Hoekwater  <taco@luatex.org>\n\n\tImport LuaTeX 0.79.0 from LuaTeX repository (released)\n\n2014-03-15  Taco Hoekwater  <taco@luatex.org>\n\n\tImport LuaTeX snapshot 0.79.0 from LuaTeX repository (r4903).\n\n2014-02-10  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* lua/luatex-api.h: MSC version has luaopen_bit32() in dll.\n\n2014-02-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/luatex-api.h: Declare luaopen_bit32();\n\n2014-02-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am, am/luafontforge.am, am/luamisc.am,\n\tam/luasocket.am, am/luatex.am: Add rules for LuaJITTeX.\n\n\t* luajittex.test, luajitimage.test: New tests for LuaJITTeX.\n\n\tAvoid compiler warnings.\n\t* lua/liolibext.c, lua/luajitstuff.w: Drop compilation of\n\tunused static functions.  Avoid to compute unused value.\n\t* lua/texluajitc.w: Include header for luac_main() prototype.\n\t* lua/luatex-api.h: Drop duplicate luac_main() prototype.\n\n2014-02-04  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* lua/luainit.w: Change a little for LuaJITTeX.\n\n2014-02-01  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tImport LuaTeX snapshot 0.78.3 from LuaTeX repository (r4772).\n\n\t* luatexfont.h: Keep the prototype for auto_expand_font() as\n\tlong as the function remains in vfovf.w.\n\n\t* liolibext.c [__MINGW32__]: Don't redefine l_fseek etc.\n\n2014-02-01  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am, am/luafontforge.am, am/luamisc.am,\n\tam/luasocket.am, am/luatex.am: Prepare for LuaJITTeX.\n\n2014-01-31  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* tex/printing.w (print_cs): Bug fix from TeX 3.14159265.\n\n2014-01-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/writepng.w: Allow libpng >= 1.6.3 to read images with\n\tincorrect CMF bytes.\n\n2013-12-23  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdf/pdfgen.w (pdf_end_stream): Always write \"\\nendstream\" for\n\tPDF/A-1b compliance.\n\n2013-12-19  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* lua/liolibext.c: Large files in lua.\n\n2013-12-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/epdf.h, lua/lepdflib.cc: Adapt for poppler-0.25.x.\n\t* fake/StructTreeRoot.h (new): Provide 0.24.4 compatibility.\n\t* am/libluatex.am: Adapted.\n\n2013-12-08  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* font/writet3.w: More cast arg2 of setpdffloat to int64_t.\n\t* pdf/pdfpage.w: Fix i32round() => i64round().\n\n2013-12-07  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* lua/liolibext.c: Large files in lua.\n\n2013-12-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tFix a serious bug related to large numbers in pdfimages.\n\tMail from Akira Kakuto <kakuto@fuk.kindai.ac.jp>, 6 Dec 2013.\n\t* pdf/pdftypes.h: Change pdffloat.m from long to int64_t.\n\tDefine i32round(a) and i64round(a) instead of lround(a).\n\t* font/writet3.w: Cast arg2 of setpdffloat to int64_t.\n\t* image/writejp2.w: Use uint64_t instead of unsigned long long.\n\t* image/pdftoepdf.w, pdf/pdfgen.w, pdf/pdfglyph.w,\n\tpdf/pdfimage.w, pdf/pdfpage.w, pdf/pdfrule.w: Replace lround(a)\n\tby i32round(a) or i64round(a).\n\n2013-09-20  Karl Berry  <karl@tug.org>\n\n\t* lua/luainit.w (lua_initialize) [NATIVE_TEXLIVE_BUILD]: omit date.\n\t* tex/printing.w (print_banner) [NATIVE_TEXLIVE_BUILD]: replace\n\tdate with WEB2CVERSION for TL binaries.\n\n2013-08-06  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* font/writecff.w: Fix a bug in write_cid_cff(). There was not\n\tpdf_end_dict() for the corresponding pdf_begin_dict().\n\n2013-07-30  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* font/writettf.w: Treat unknown 'post' table versions\n\t(found in some broken fonts) as 3.0, i.e., no Glyph names.\n\n2013-07-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luatex.am, tests/luaimage.tex: Add a .pdf image.\n\n2013-07-05  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdf/pdfgen.w: Use \"%\"LONGINTEGER_PRI\"d\" format specifier to\n\tprint (LONGINTEGER_TYPE) casted longinteger and off_t variables.\n\n2013-07-05  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/luainit.w (init_kpse, lua_initialize):\n\tUse kpse_program_basename().\n\n2013-07-04  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luaimage.test, tests/luaimage.tex: New test and data.\n\t* am/luatex.am: Add the new test.\n\n2013-07-02  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* luatex.c : Replace lines between \"#if defined (TeX) && defined (IPC)\"\n\tand \"#endif /* TeX && IPC */\" with those in texmfmp.c.\n\n2013-07-01  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* luatex.c, ptexlib.h: Revert the previous change.\n\t* luatex.c [MSVC]: Undef timezone before including <time.h>.\n\n2013-06-28  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* luatex.c, ptexlib.h: Slightly modify because Visual Studio cannot\n\tcompile luatex.c.\n\n2013-06-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/lcallbacklib.c, lua/luainit.w: Replace index() => strchr().\n\n\t* ptexlib.h: More general cases for not been included first.\n\n\t* lang/hyphen.h: Do not '#include \"ptexlib.h\"'.\n\t* lang/hyphen.w: Include ptexlib.h instead of lang/hyphen.h.\n\n2013-06-28  Karl Berry  <karl@tug.org>\n\n\t* ptexlib.h: complain if various common things are #defined;\n\tthis must be the first #include.\n\n2013-06-27  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tBug fix for LuaTeX crash on 32bit Unix systems from Taco,\n\ttlbuild mail 26 Jun 2013 16:10:35,\n\thttp://tug.org/pipermail/tex-live/2013-June/033782.html\n\t* image/writejbig2.w, image/writejp2.w, image/writejpg.w,\n\timage/writepng.w: Always first include ptexlib.h.\n\n2013-06-26  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am, am/luasocket.am, am/luatex.am:\n\tCorrect dependencies for build `on demand'.\n\n2013-06-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua52/: Moved to ../../../libs/lua52/.\n\t* am/libluatex.am: Adapted.\n\t* am/liblua52.am: Removed.\n\n2013-06-18  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/epdf.h, image/writeimg.w, lua/limglib.c,\n\tlua/lpdfscannerlib.cc, lua/lstrlibext.c, lua/luatex-api.h,\n\tlua/texluac.w, ptexlib.h: Replace 'lua52/lua.h' => 'lua.h'.\n\n2013-06-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/lpdfscannerlib.cc: Include <poppler-config.h> instead of\n\t<poppler/poppler-config.h>.\n\n2013-04-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/luainit.w: Handle '--luac' and '--luaconly' (from Akira).\n\n2013-04-16  Elie Roux  <elie.roux@telecom-bretagne.eu>\n\n\t* font/tfmofm.w: check for .ofm as well as .tfm.\n\t* tex/mainbody.w: check for !ini_version before initialize().\n\n2013-04-16  Karl Berry  <karl@tug.org>\n\n\t* lua/luainit.w (parse_options): GPLv2+, not just GPLv2 (after\n\tdiscussion with Taco).\n\n2013-04-14  Karl Berry  <karl@tug.org>\n\n\t* lua/luainit.w: 2013\n\n2013-04-08  Taco Hoekwater  <taco@luatex.org>\n\n\t* luasocket/src/smtp.lua: uncomment require 'coroutine'\n\t* luasocket/src/smtp_lua.c: regenerated\n\n2013-04-05  Taco Hoekwater  <taco@luatex.org>\n\n\tImport luatex beta 0.76.0 (released version)\n\n2013-04-04  Karl Berry  <karl@tug.org>\n\n\t* lua52/liolib.c: #include <unistd.h>.  Needed on FreeBSD\n\tper Nikola Lecic, tlbuild 1 Apr 2013 02:10:08.\n\n2013-03-21  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tImport LuaTeX beta-0.75.0 from LuaTeX repository (r4604).\n\n2013-03-20  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luafontforge.am (EXTRA_DIST): Drop unused files.\n\n2013-03-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua52/*, am/liblua52.am (new): Add lua-5.2.1 for 0.75.0.\n\n2013-01-29  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luatex.am: Allow subdir-objects.\n\n2013-01-19  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdf/pdftables.h: Support large files (from Martin).\n\n2013-01-18  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.c (mk_shellcmdlist): Simplify (sync with texmfmp.c).\n\n2013-01-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdf/pdfgen.w (write_stream_length): Cast length for printing.\n\n2012-12-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am (luatex_*_ctangle, pdflua.c):\n\tEnable silent rules.\n\n2012-11-20  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/lkpselib.c: Use kpse_readable_file() with non-const arg.\n\n2012-11-20  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/lepdflib.cc: No need to test for Annot::decRefCnt with\n\tpoppler 0.18 or better.\n\n2012-11-06  Akira Kakuto  <kakuto@fuk.kinidai.ac.jp>\n\n\t* pdf/pdflistout.w: sync with r4471 (a bug fix by H. Henkel).\n\n2012-10-13  Akira Kakuto  <kakuto@fuk.kinidai.ac.jp>\n\n\t* tex/texfileio.w: input by pipe was impossible. enable it.\n\n2012-10-11  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/luainit.w (lua_initialize): Free two malloc()ed strings.\n\n2012-10-10  Akira Kakuto  <kakuto@fuk.kinidai.ac.jp>\n\n\t* luatex.c: Modify determination of fullpath for restricted shell\n\tescape commands.\n\n2012-10-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tAvoid TL vs W32TeX differences (from Akira).\n\t* luatex.h: Include \"ptexlib.h\" instead of <luatexdir/ptexlib.h>\n\tas in all other cases.\n\t* ptexlib.h: Use _MSC_VER instead of MSVC.\n\t* image/epdf.h: Change arg3 of extern void pdf_begin_obj() from\n\tbool to int, as declared and defined in pdf/pdfgen.[hw].\n\tFIXME: There should be only one extern declaration in one file.\n\n2012-10-09  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tThe openbsd compat library is no longer used.\n\t* image/epdf.h, lua/luainit.w, ptexlib.h, utils/utils.w:\n\tDrop #include \"openbsd-compat.h\".\n\t* am/libluatex.am, am/luatex.am: Remove OBSDCOMPAT_*.\n\n2012-09-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/luainit.w (parse_options): Avoid cast const => non-const.\n\n2012-09-13  Akira Kakuto  <kakuto@fuk.kinidai.ac.jp>\n\n\t* lua/luainit.w (parse_options): allow lualatex \"\\input\" \"a b\" on\n\tWindows.\n\n2012-09-08  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex-api.h: Avoid conflicting extern declaration of environ,\n\tdeclared in <stdlib.h> for WIN32 (from W32TeX).\n\n2012-08-21  Akira Kakuto  <kakuto@fuk.kinidai.ac.jp>\n\n\t* tex/texdeffont.w (tex_def_font): Recover the old code, because the\n\tnew code seems not to work.\n\n2012-08-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* ptexlib.h: Drop unused definition of M_PI.\n\n2012-08-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* tex/dumpdata.h: Remove the swap_items() prototype.\n\t* luatex.c (swap_items): Moved from here ...\n\t* tex/texfileio.w (swap_items): ... to here and declared static.\n\n\t* luatex.c (input_line) [WIN32]: Sync with ../lib/texmfmp.c.\n\tDetect and skip Byte order marks.\n\t* tex/texfileio.[ch] [WIN32]: Use Poptr to record pipe input.\n\n2012-08-03  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.[ch] [W32TeX]: Use DLLPROC for luatex.dll.\n\t* pdf/pdfgen.w [WIN32]: Convert file names '\\\\' -> '/'.\n\n2012-08-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* tex/texdeffont.w (tex_def_font): Better tracing of font\n\tdefinitions, adapted from e-TeX version 2.5.\n\n2012-07-31  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdf/pdfpage.w (print_pdffloat): Cope with broken snprintf().\n\t* lua/luastuff.w (luatex_error): Drop snprintf() return value.\n\n2012-07-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/luainit.w (lua_initialize): Avoid using asprintf().\n\t* utils/utils.w (initversionstring): Avoid using asprintf().\n\n\tOne and only one prototype per function.\n\t* image/epdf.h, utils/utils.h: Add #include \"luatex-common.h\"\n\tand move pdftex_{fail,warn} prototypes from here ...\n\t* luatex-common.h (new): ... to here.\n\t* am/libluatex.am (libluatex_a_SOURCES): Add the new file.\n\n2012-07-26  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/loslibext.c os_gettimeofday): Use int64_t (from W32TeX).\n\n2012-07-25  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/pdftoepdf.cc (get_file_checksum): Use uint64_t and PRIu64.\n\t* image/writejp2.w, lua/loslibext.c: Use uint64_t.\n\n2012-07-23  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* tex/texfileio.w (runpopen): Sync with ../lib/texmfmp.c.\n\n2012-07-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/writejbig2.w: Use LONGINTEGER_PRI, not LONGINTEGER_PRId.\n\t* pdf/pdfgen.w: Use LONGINTEGER_PRI, not LONGINTEGER_PRIi.\n\n2012-07-14  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils/utils.w: Use EXIT_FAILURE instead of EX_SOFTWARE.\n\n2012-07-13  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdf/pdfgen.w: Cast xfseeko() arg2 to avoid MSVC warning.\n\n2012-07-09  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* tex/texfileio.w (runpopen): Sync with ../lib/texmfmp.c.\n\n2012-07-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.c (shell_cmd_is_allowed): Change Arg1 from 'const char **'\n\tinto 'const char *'; sync with ../lib/texmfmp.c.\n\t* luatex.h, lua/liolib.c, lua/loslibext.c, tex/texfileio.w: Adapt.\n\n\t* lua/liolib.c, luascripts/txt2zlib.w: Use binary file io mode.\n\tFrom Akira Kakuto <kakuto@fuk.kindai.ac.jp> (W32TeX).\n\n2012-05-22  Taco Hoekwater  <taco@luatex.org>\n\n\t* lua/lkpselib.c: new function kpse.default_texmfcnf() that\n\treports the value of DEFAULT_TEXMFCNF, for the benefit of\n\tcontext mkiv on Debian.\n\n2012-05-22  Taco Hoekwater  <taco@luatex.org>\n\n\t* luafontloader/fontforge/fontforge/splinesave.c,\n\tluafontloader/fontforge/fontforge/splinefont.h: drop parts of the\n\tType1 saving routines (unused) to remove a compiler warning.\n\n\t* pdf/pdftypes.h, lua/limglib.c, image/epdf.h, image/writeimg.w,\n\timage/writejbig2.w, ptexlib.h: more off_t trouble.\n\n2012-05-21  Taco Hoekwater  <taco@luatex.org>\n\n\t* tex/printing.w, lua/ltokenlib.c, lua/llanglib.c, lua/llualib.c,\n\tlua/lnodelib.c, lua/luainit.w, lua/ltexiolib.c,\n\tlua/lcallbacklib.c, lua/lstatslib.c, lua/ltexlib.c,\n\tlua/loslibext.c, lua/lkpselib.c, lua/luatoken.w, lua/llfslibext.c,\n\tlua/lfontlib.c, lua/luanode.w, lua/lpdflib.c, lua/luastuff.w:\n\twhen loading both \"ptexlib.h\" and \"lua/luatex-api.h\", make sure\n\tthat \"ptexlib.h\" is loaded first because that reads config.h\n\twhich affects loading of system headers (via Large File Support,\n\tspecifically).\n\n2012-05-20  Khaled Hosny  <khaledhosny@eglug.org>\n\n\t* tex/mlist.w: fix \"warning: 'ext' might be used uninitialized\".\n\n2012-05-18  Taco Hoekwater  <taco@luatex.org>\n\n\t* lua/ltexlib.c: fix a ConTeXt crash on `\\endinput \\end`.\n\n2012-05-18  Khaled Hosny  <khaledhosny@eglug.org>\n\n\t* tex/commands.h, tex/commands.w, tex/maincontrol.h,\n\ttex/maincontrol.w, tex/mathcodes.h, tex/mathcodes.w, tex/scanning.w, \n\ttex/texmath.w, tex/mlist.w: backport math relatex changes from 0.71\n\t* luatex.c: bump version to 0.70.1\n\n2012-05-10  Hartmut Henkel  <hartmut@luatex.org>\n\tand Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/lepdflib.cc: Adapt for poppler 0.19.4.\n\n2012-05-09  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/luainit.w (lua_initialize): Use WEB2CVERSION.\n\t* tex/printing.w (print_banner, log_banner): Same.\n\n2012-02-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.h: Remove definition of WRITE_OUT, now in ../cpascal.h.\n\n2012-01-18  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/writejbig2.w (getstreamlen): Change type to `off_t'.\n\tUse LONGINTEGER_TYPE and LONGINTEGER_PRId for printing.\n\n2012-01-11  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tConsistent support for large JBIG2 files.\n\t* image/writejbig2.w: Change type of various struct members, local\n\tvariables and findstreamstart() from `long' or `unsigned long'\n\tto `off_t'.  Do not use xfseek and xfseeko for the same file.\n\n2011-10-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/lepdflib.cc: Test poppler 0.16.x / 0.17.x features.\n\n2011-10-04  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am: Avoid to `clean' ../mplibdir/lmplib.c.\n\n\t* am/txt2zlib.am (noinst_PROGRAMS): Conditionally add txt2zlib,\n\tsuch that txt2zlib$(EXEEXT) gets cleaned.\n\n2011-09-30  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* tex/printing.w (print_file_line): Bug fix: avoid uninitialized\n\tlineno - from ../tex.ch.\n\t* tex/inputstack.w: Slightly reformulate printing of current\n\tline - from ../etexdir/etex.ch.\n\n2011-08-04  Magnus Granberg  <zorry@gentoo.org>\n\n\t* luatex.c: Do not #include empty file <kpathsea/recorder.h>.\n\n2011-06-17  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tReduce memory leaks.\n\t* lua/lkpselib.c (do_lua_kpathsea_lookup): Free string no longer\n\tused.\n\n2011-06-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tlua/lkpselib.c (find_dpi): Allow find_suffix() to return a\n\tconst string.\n\n2011-05-19  Taco Hoekwater  <taco@luatex.org>\n\n\t* lua/ltexlib.c: fix a bug on negative catcode table arguments.\n\t* luatex.c, NEWS: luatex is now version 0.70.1\n\t* luatex_svnversion.h: updated to reflect latest luatex revision (4277)\n\n2011-05-18  Taco Hoekwater  <taco@luatex.org>\n\n\t* font/writefont.w (write_fontdescriptor):  Fix for non-embedded\n\tfonts in the PDF output.\n\t* image/writeimg.w (read_img): Fix for non-existent images that\n\tcould case a crash.\n\t* luatex_svnversion.h: updated to reflect latest luatex revision (4273)\n\n2011-05-18  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.c (ipcpage): Add 'free(cwd)', remove Aleph comment.\n\n2011-05-17  Taco Hoekwater  <taco@luatex.org>\n\n\t* tex/texfileio.w (luatex_synctex_get_current_name): switch to xgetcwd()\n\tfrom kpathsea\n\t* luatex_svnversion.h: updated to reflect latest luatex revision (4272)\n\n2011-05-15  Taco Hoekwater  <taco@luatex.org>\n\n\t* tex/texfileio.w (luatex_synctex_get_current_name): work around a \n\tbug in getcwd().\n\t* luatex_svnversion.h: updated to reflect latest luatex revision (4267)\n\n2011-05-13  Taco Hoekwater  <taco@luatex.org>\n\n\t* lua/luainit.w: change the copyright year to 2011.\n\t* luatex_svnversion.h: updated to reflect latest luatex revision (4264)\n\t* NEWS: forgot to mention synctex change\n\t\n2011-05-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/writepng.w: #define PNG_FP_1 for libpng < 1.5.0.\n\n2011-05-11  Taco Hoekwater  <taco@luatex.org>\n\n\t* image/writepng.w: fix for 16bit images in pdf 1.4 (8bit) mode.\n\t* luatex_svnversion.h: updated to reflect latest luatex revision (4258)\n\n2011-05-09  Taco Hoekwater  <taco@luatex.org>\n\n\t* tex/texfileio.[hw]: file relative filenames in synctex output.\n\t* luatex_svnversion.h: updated to reflect latest luatex revision (4256)\n\n2011-05-08  Taco Hoekwater  <taco@luatex.org>\n\n\t* dvi/dvigen.w, pdf/pdfgen.w: fix missing newline after\n\t'No pages of output' message.\n\t   \n2011-05-08  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* lua/luainit.w, tex/texfileio.w: fix recorder location.\n\n2011-05-05  Taco Hoekwater  <taco@luatex.org>\n\n\t* image/writepng.w: fixes for libpng 1.5.2.\n\t* lua/lnodelib.c (lua_nodelib_fields): fix field count for \n\tnodes without subtype.\n\t* lua/llfslibext.c: fix an variable type and a compiler warning.\n\t* lua/loslibext.c (os_execute): fix non-argument use of os.execute.\n\t* lua/ltexlib.c (do_luacprint): fix use of bad catcode tables.\n\t* lua/luainit.w (HAVE_ASPRINTF): superfluous test removed.\n\t* luatex.c: bump version to 0.70, remove SOCK_NONBLOCK definition.\n\t* luatex_svnversion.h (luatex_svn_revision): now at 4247.\n\t* NEWS: updated for luatex 0.70.0 release.\n\t* tex/texfileio.w: patch from bug 615 (recorder filename location).\n\t* tex/texmath.w: fix display alignment in TRT mode.\n\t* utils/utils.w (HAVE_ASPRINTF): superfluous test removed.\n\n2011-04-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils/synctex{-common.h,.c,.h} (removed): Use copies from\n\t../synctexdir.\n\t* synctex-luatex.h: Moved from here to ../../synctexdir.\n\t* ptexlib.h, am/libluatex.am, am/luatex.am: Adapted. \n\n2011-04-13  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils/utils.w (POPPLER_VERSION): Now defined in\n\tpoppler-config.h for poppler from the TeX Live tree, or in the\n\tMakefile for an installed version.\n\n2011-04-13  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am, am/txt2zlib.am: When cross compiling skip\n\ttxt2zlib and use installed luascripts/pdflua.c.\n\n\tNeed poppler at least 0.12 for PDFDoc::getPDF*Version().\n\t* image/pdftoepdf.cc: Remove code for older poppler versions.\n\n2011-04-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/writepng.w: Fix to build with png-1.5 (and avoid\n\t`deprecated' warnings with png-1.4). The transformations part\n\tis removed on recommendation by John Bowler (a png developer).\n\tMail from Thomas Klausner <tk@giga.or.at>, Sun, 30 Jan 2011.\n\n\t* pdf/pdfgen.w: ANSI C function definitions.\n\n\t* pdf/pdfluaapi.w (new_pdflua): Declare zp as const.\n\n\t* am/libluatex.am (EXTRA_DIST): Distribute luascripts/pdflua.lua.\n\t* am/txt2zlib.am (EXTRA_DIST): Distribute luascripts/txt2zlib.w.\n\n2011-04-12  Taco Hoekwater  <taco@luatex.org>\n\n\t* import of luatex 0.66.0, released version\n\n2011-03-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am: Use AM_CFLAGS instead of libluatex_a_CFLAGS.\n\t* am/luatex.am: Use AM_CFLAGS instead of luatex_CFLAGS.\n\n2011-03-14  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am (libluatex_a_CPPFLAGS): Remove `-Iluatexdir'\n\tand add `-DSYNCTEX_ENGINE_H='<utils/synctex-luatex.h>''.\n\t* am/luatex.am (luatex_CPPFLAGS): The same.\n\n\t* utils/synctex.c: Fix several typos in comments to reduce diffs\n\tbetween files in synctexdir/ and luatexdir/utils/.\n\n2011-02-15  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luatex.am [WIN32]: Add texlua.exe and texluac.exe wrappers\n\tfor MinGW.\n\n2010-12-23  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luatex.am: install-exec-hook and uninstall-hook rules now\n\tin ../Makefile.am; append required symlinks to bin_links.\n\n2010-09-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.test (new): Just testing 'luatex -credits'.\n\t* luatexdir/am/luatex.am: Adjusted.\n\n2010-07-12  Taco Hoekwater <taco@luatex.org>\n\n\t* luafontloader/src/luafflib.c: quick fix for crashes triggered\n\tby invalid panose data in Open/TrueType fonts.\n\t* luatex_svnversion.h: new version (rev 3736).\n\n2010-07-01  Taco Hoekwater <taco@luatex.org>\n\n\t* lang/texlang.w, lua/lnodelib.c, luatex.c, luatex_svnversion.h,\n\tpdf/pdfglyph.w, pdf/pdfpage.w, NEWS: new versions from released 0.60.2\n\t\n2010-06-18  Taco Hoekwater <taco@luatex.org>\n\n\t* tex/textoken.h (smemory_word): add endiannes test\n\t* font/texfont.h (liginfo, kerninfo): add endianness test\n\t* luatex_svnversion.h: new version\n\n2010-06-13  Taco Hoekwater <taco@luatex.org>\n\n\t* tex/inputstack.h (in_state_record): force two bitfields to be signed,\n\tafter a bug report from Vladimir Volovich <vvv@vsu.ru>\n\t* luatex_svnversion.h: new version\n\n2010-06-11  Taco Hoekwater <taco@luatex.org>\n\n\t* font/sfnt.w, font/sfnt.h, \n\tluafontloader/fontforge/Unicode/ucharmap.c,\n\tluafontloader/fontforge/fontforge/python.c, \n\tluafontloader/fontforge/inc/basics.h: change include of \"config.h\"\n\tto <w2c/config.h>.\n\t* image/epdf.h, lua51/luaconf.h: change include of \"c-auto.h\"\n\tto <w2c/c-auto.h>.\n\t\n2010-06-10  Taco Hoekwater <taco@luatex.org>\n\n\t* luatex.c (swap_items): debugged.\n\t* tex/texfileio.w (do_zdump): reswap the swapped items to avoid\n\tcrashes when called as |dump_things|.\n\n2010-06-10  Taco Hoekwater <taco@luatex.org>\n\n\t* luafilesystem/src/lfs.c(get_dir): do not assume Gnu C compiler.\n\n2010-06-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am (libluatex_a_CPPFLAGS): Add $(AM_CPPFLAGS).\n\t* am/luafontforge.am (libff_a_CPPFLAGS): Add $(AM_CPPFLAGS).\n\t* am/luatex.am (luatex_CPPFLAGS): Add $(AM_CPPFLAGS).\n\n2010-06-10  Taco Hoekwater <taco@luatex.org>\n\n\t* luasocket/src/options.c, luafontloader/fontforge/fontforge/parsettfatt.c,\n\tluafontloader/fontforge/fontforge/parsettf.c,\n\tluafontloader/fontforge/fontforge/lookups.c: enlarge static buffers\n\tfor sprintf().\n\t\n2010-06-04  Taco Hoekwater <taco@luatex.org>\n\n\t* luatex.c (shell_cmd_is_allowed): make sure only commands with\n\tabsolute path names are executed on win32 in restricted mode --\n\tpatch from Akira Katuto.\n\n2010-05-28  Taco Hoekwater <taco@luatex.org>\n\n\t* luamd5/md.5c: bring in a new version from kepler to fix a\n\tportability problem with stdint.h.\n\t* luafontloader/src/ffdummies.c, lua/texluac.w: guard __attribute__\n\tusage, which is a GNUC only feature.\n\t    \n2010-05-19  Taco Hoekwater <taco@luatex.org>\n\n\t* printing.w (print_banner, log_banner), luainit.w (lua_initialize):\n\tadd WEB2CVERSION to the banner.\n\n2010-05-13  Taco Hoekwater <taco@luatex.org>\n\n\t* utils/synctex.c, utils/synctex-luatex.h: update from J\u5ee8ome\n\tLaurens, bringing luatex in-line with the core synctex distribution\n\t* luatex_svnversion.h: updated to reflect the version of 0.60.x branch\n\t\n2010-05-06  Taco Hoekwater <taco@luatex.org>\n\n\t* luatex.c (calledit): use ifdef __MINGW32__ instead of WIN32.\n\t* luatex_svnversion.h: updated to reflect the version of 0.60.x branch\n\n2010-04-28  Taco Hoekwater <taco@luatex.org>\n\n\t* tex/maincontrol.w: Fixed the error message for improper \n\tuse of \\protected, reported by Heiko Oberdiek \n\t<heiko.oberdiek@googlemail.com>.\n\n2010-04-28  Taco Hoekwater  <taco@luatex>\n\n\t* import of luatex 0.60.1, released version\n\n2010-04-25  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/epdf.h, lua51/luaconf.h: #include <c-auto.h> instead of\n\t<web2c/c-auto.h>.\n\n2010-04-24  Taco Hoekwater  <taco@luatex>\n\n\t* lua/loslibext.c: fix os.exec() and os.spawn(), twice\n\n2010-04-23  Taco Hoekwater  <taco@luatex>\n\n\t* lua/loslibext.c: fix os.exec() and os.spawn() once more\n\n2010-04-23  Taco Hoekwater  <taco@luatex>\n\n\t* lua/loslibext.c: fix os.exec() and os.spawn()\n\t* luatex_svnversion.h: updated to reflect the version of 0.60.x branch\n\n2010-04-23  Taco Hoekwater  <taco@luatex>\n\n\t* new import from luatex repository (HEAD of 0.60.x branch)\n\n2010-04-20  Taco Hoekwater  <taco@luatex>\n\n\t* new import from luatex repository (HEAD of 0.60.x branch)\n\n2010-04-13  Taco Hoekwater  <taco@luatex>\n\n\t* am/luafontforge.am: delete three lines.\n\t* luafontloader/fontforge/Unicode/dump.c: deleted\n\t* luafontloader/fontforge/Unicode/backtrns.c: deleted\n\t* luafontloader/fontforge/Unicode/unialt.c: deleted\n\n2010-04-13  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/pdftoepdf.cc: Fix building with libpoppler.\n\t* luatex.c: Fix building for MinGW32.\n\n\t* luatex.c (ipcpage): Avoid compiler warning.\n\t(catch_interrupt): Declare as static.\n\t* pdf/pdflistout.w (init_*_backend_functions): ANSI C func defs.\n\n2010-04-13  Taco Hoekwater  <taco@luatex>\n\n\t* new import from luatex repository (HEAD of 0.60.x branch)\n\n2010-04-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luatex.am: Remove libmplib.a from $($(luatex_OBJECTS)'s\n\tdependencies ...\n\t* am/libluatex.am: and add to $(libluatex_a_OBJECTS)'s\n\tdependencies; otherwise parallel builds may fail.\n\n2010-04-04  Taco Hoekwater  <taco@luatex>\n\n\t* import of luatex 0.60.0, with a few local changes:\n\t* luatex.c (ipcpage): fix fetching of 'name'.\n\t* dvi/dvigen.w (dvi_end_page): fix IPC flushing.\n\t* image/pdftoepdf.cc (write_epdf1): comment out use of \n\tpage->getResourcesNF() and page->getMetadataNF().\n\n2010-03-09  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatangle.ch: Use kpse_set_program_name(argv[0], nil) instead\n\tof kpse_set_progname(argv[0]).\n\n2010-02-15  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luamisc.am (libluamisc_a_CPPFLAGS): Adapt to zziplib now\n\tin ../../../libs/zziplib/.\n\n2010-01-31  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tMoved zziplib/ to ../../../libs/zziplib.\n\t* am/luamisc.am (libluamisc_a_DEPENDENCIES): Adapt.\n\t* am/luatex.am (luatex_ldadd): Adapt.\n\n2010-01-29  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tClarify dependencies between luaTeX libraries:\n\t* am/libzzip.am: Remove dependency on liblua51.a.\n\tRemove memdisk.[ch] and mmapped.[ch] from libzzip_a_SOURCES and\n\tadd them to EXTRA_DIST.\n\t* am/luamisc.am: Add dependency on libzzip.a.\n\t* am/luasocket.am: Replace dependency on libzzip.a by liblua51.a.\n\n2010-01-27  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils/avl.c (avl_copy): Proper handling of const.\n\n2010-01-27  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luafontloader/src/luafflib.h: New file with prototypes used\n\tby libluatex.\n\t* luafontloader/src/luafflib.c: #include \"luafflib.h\".\n\t* font/writecff.c, font/writetype2.c: Remove the extern decls\n\tand #include <luafontloader/src/luafflib.h>.\n\t* font/writecff.c (writetype1w): Change tfm_size integer=>int.\n\t* am/luafontforge.am: Add the new file.\n\n\t* luatex-api.h: Add prototype for utf8_idpb(), renamed\n\tlua_utf8_idpb to avoid name conflicts with fontforge library.\n\t* lang/texlang.c: Declare utf8_idpb() as non-static.\n\t* tex/filename.c: Remove prototype for utf8_idpb().\n\n\t* tex/filename.c (scan_file_name): Don't assume a null byte\n\tafter string created by utf8_idpb().\n\n2010-01-26  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* font/writettf.c: Remove extern charsetstr[].\n\t* lua/lkpselib.c: Remove extern luainit.\n\t* lua/luainit.c: Remove extern normalize_quotes(), argc, argv.\n\t* tex/textoken.c: Remove extern insert_vj_template().\n\n\t* utils/utils.h: Add extern declaration of fb_array ...\n\t* font/writet1.c, font/writettf.c: ... removed from here.\n\t* luatex-api.h: Add extern declaration of program_name_set ...\n\t* lua/luainit.c, lua/luatex.c: ... removed from here.\n\t* luatex-api.h: Add extern declaration of startup_filename,\n\tsafer_option, and nosocket_option ...\n\t* lua/luastuff.c: ... removed from here.\n\t* lua/llualib.c (luabytecode_max): Change integer=>int.\n\t* luatex-api.h: Add extern declaration of luabytecode_max,\n\tluabytecode_bytes, luastate_bytes, callback_count, and\n\tsaved_callback_count ...\n\t* lstatslib.c: ... removed from here.\n\n2010-01-25  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luatex.am (luatex_CFLAGS, luatex_CXXFLAGS),\n\tam/libluatex.am (libluatex_a_CFLAGS): Enable compiler warnings.\n\n\tAvoid most compiler warnings:\n\n\t* font/luatexfont.h, luatexdir/hyphen.h, image/writeimg.h,\n\timage/writejbig2.h, luatex.h, pdf/pagetree.h, pdf/pdfpage.h,\n\tutils/avlstuff.h, utils/utils.h: ANSI C function prototypes.\n\t* font/mapfile.c, font/writeenc.c, font/writefont.c,\n\tfont/writet1.c, font/writettf.c, image/writeimg.c,\n\timage/writejbig2.c, lang/hyphen.c, pdf/pagetree.c,\n\tpdf/pdfpage.c, utils/avlstuff.c, utils/utils.c: ANSI C function\n\tdefinitions.\n\n\t* font/luafont.c, lang/texlang.c, lua/lcallbacklib.c,\n\tlua/lfontlib.c, lua/limglib.c, lua/lkpselib.c, lua/llualib.c,\n\tlua/lnodelib.c, lua/loslibext.c, lua/lpdflib.c, lua/lstatslib.c,\n\tlua/ltexiolib.c, lua/ltexlib.c, lua/ltokenlib.c, lua/luanode.c,\n\tlua/luatoken.c: Remove 'char *' or 'unsigned char *'  casts of\n\tLua strings.\n\n\t* font/texfont.h, font/writecff.h, luatex-api.h, luatex.h,\n\tnodes.h, primitive.h, ptexlib.h, utils/utils.h, font/dofont.c,\n\tfont/luafont.c, font/tfmofm.c, font/vfovf.c, font/writecff.c,\n\tfont/writefont.c, font/writet1.c, font/writettf.[ch],\n\tlang/hyphen.c, lang/texlang.c, lua/lcallbacklib.c,\n\tlua/lfontlib.c, lua/limglib.c, lua/lkpselib.c, lua/llualib.c,\n\tlua/lnodelib.c, lua/loslibext.c, lua/lpdflib.c, lua/lstatslib.c,\n\tlua/ltexiolib.c, lua/ltexlib.c, lua/ltokenlib.c, lua/luainit.c,\n\tlua/luanode.c, lua/luastuff.c, lua/luatex.c, lua/luatoken.c,\n\tluatex.ch, tex/filename.c, tex/linebreak.c, tex/math.c,\n\ttex/mlist.c, tex/primitive.c, tex/texdeffont.c, tex/texnodes.c,\n\ttex/textoken.c, utils/utils.c: Declare various function params\n\tand args, local and global vars, and struct members as const.\n\n\t* font/luafont.c, font/texfont.c, font/tfmofm.c, font/vfovf.c,\n\tfont/writeenc.c, font/writefont.c, font/writet1.c,\n\tfont/vfpacket.c, font/writettf.c, font/writetype2.c,\n\timage/writeimg.c, lang/hyphen.c, lang/texlang.c, lua/limglib.c,\n\tlua/llualib.c, lua/lnodelib.c, lua/loslibext.c, lua/lpdflib.c,\n\tlua/lstatslib.c, lua/ltexlib.c, lua/luainit.c, lua/luanode.c,\n\tlua/luastuff.c, mathcodes.c, tex/linebreak.c, tex/math.c,\n\ttex/mlist.c, tex/primitive.c, tex/texdeffont.c, tex/texnodes.c,\n\ttex/textoken.c, utils/synctex.c, utils/utils.c:\n\tDeclare functions and global vars as static.\n\n\t* font/texfont.c: #include \"luatexfont.h\" and remove externs.\n\t* image/writejpg.c: #include \"writejpg.h\".\n\t* image/writepng.c: #include \"writepng.h\".\n\t* lang/hnjalloc.c: #include \"hnjalloc.h\".\n\t* lua/texluac.c: #include \"luatex-api.h\".\n\t* utils/synctex.c: #include \"synctex.h\".\n\t* utils/utils.c: #include \"utils.h\".\n\n\t* lua/lcallbacklib.c: Remove prototype for lua_traceback().\n\t* ptexlib.h: Add prototype for get_command_id() ...\n\t* lua/ltokenlib.c: ... removed from here.\n\t* nodes.h: Add prototype for list_node_mem_usage() ...\n\t* lua/lnodelib.c: ... removed from here.\n\t* managed-sa.h: Add prototype for rawset_sa_item() ...\n\t* mathcodes.c, tex/math.c: ... removed from here.\n\n\t* inc-epdf.h: New file with prototypes for epdf_mark_glyphs(),\n\tepdf_create_fontdescriptor(), and epdf_write_enc() ...\n\t* image/epdf.h: ... removed from here.\n\t* image/epdf.h, font/writeenc.c: #include inc-epdf.h.\n\t* inc-vfovf.h: New file with prototype for make_vf_table() ...\n\t* lua/lfontlib.c: ... removed from here.\n\t* font/vfovf.c, lua/lfontlib.c: #include inc-vfovf.h.\n\t* inc-extra.h: New file with prototypes for check_isnode()\n\tand lua_nodelib_push_fast() ...\n\t* lua/limglib.c, lua/llanglib.c, lua/lstatslib.c, lua/ltexlib.c:\n\t... removed from here.\n\t* lua/limglib.c, lua/llanglib.c, lua/lnodelib.c,\n\tlua/lstatslib.c, lua/ltexlib.c: #include \"inc-extra.h\".\n\t* am/libluatex.am (libluatex_a_SOURCES): Add the new files.\n\n\t* font/texfont.c (lua_char_exists_callback),\n\tfont/vfovf.c (is_letterspaced_font),\n\tfont/vfpacket.c (packet_command_names),\n\tfont/writet1.c (free_glyph_names),\n\timage/writeimg.c (image_group_ref),\n\tlua/ltexlib.c (get_something_internal),\n\ttex/texnodes.c (print_free_chain),\n\ttextcodes.c (clearcatcodestack):\n\tSkip unused static funcs and vars (via #if 0 ... #endif).\n\n\t* lua/luainit.c (lua_initialize): Replace string constant\n\targuments of putenv() by non-const static string variables.\n\n\t* utils/avl.c (avl_delete): Don't reuse const input param for\n\tnon-const return value.\n\n\t* utils/synctex.c: Rename synctexchar => synctex_char and\n\tsynctexnode => synctex_node as declared in utils/synctex.h.\n\n2010-01-22  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatangle.ch: Declare web_name, chg_name, pascal_name, and\n\tpool_name as const_c_string.\n\n\t* lua/lkpselib.c (readable_file, lua_kpathsea_readable_file):\n\tDrop non-const cast of {kpse,kpathsea}_readable_file() result.\n\n2010-01-03  Karl Berry  <karl@tug.org>\n\n\t* luatex.ch: propagate \"executed safely\" wording change.\n\n2009-12-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luatex.am: Replace the obsolete $(mkdir_p) by $(MKDIR_P).\n\n2009-12-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/loslibext.c (do_mkdtemp): Declare as static and skip\n\tcompilation when not used.\n\n2009-12-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdf/pagetree.c, utils/utils.c: Drop #ifdef HAVE_ASPRINTF and\n\t#include <stdio.h>.\n\n2009-12-04  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils/synctex.c: Remove (already commented) extern declaration\n\tof gettexstring().\n\n2009-10-24  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.web: Use kpse_{in,out}_name_ok(), now in Kpathsea,\n\tinstead of open{in,out}nameok().\n\t* luatex.defines: Replace open_{in,out}_name_ok by\n\tkpse_{in,out}_name_ok.\n\n2009-10-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/pdftoepdf.cc: Adapt to poppler-0.12.\n\n\t* FIXME: image/epdf.h, utils/utils.h: Multiple prototypes for\n\tpdftex_fail, pdftex_warn, and probably others.\n\n2009-09-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luatex.am: Adapt to new makecpool with one argument.\n\n2009-09-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/luainit.c (dump_name, c_job_name, last_source_name,\n\tlast_lineno): Drop extern declarations (now in texmfmp.h).\n\t(user_progname): Constify string.\n\t(lua_initialize): Avoid modifying the const_string 'dump_name'.\n\n2009-09-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils/synctex.c (synctex_suffix*): Constify strings.\n\n2009-09-04  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatangle.ch: Eliminate the unused |end_of_TANGLE| label.\n\n2009-09-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libzzip.am: Enable compiler warnings.\n\t* am/liblua51.am, am/libluatex.am, am/luafontforge.am,\n\tam/luamisc.am, am/luasocket.am, am/luatex.am: Prepare compiler\n\twarnings.\n\n2009-08-20  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/lstatslib.c, lua/luainit.c: Drop extern decl of ptexbanner.\n\t* utils/utils.c: #include <kpathsea/version.h> and drop extern\n\tdecls.\n\n2009-08-17  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/liolib.c (io_popen): Changed Arg1 of shell_cmd_is_allowed().\n\t* lua/loslibext.c (os_exec, os_spawn, os_execute): Same.\n\n2009-08-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luatangle.am: Adapt to web2c-sh.\n\t* am/luatex.am (luatex_tangle): Use tangle-sh.\n\tAdapt to tangle-sh and web2c-sh.\n\n2009-06-26  Taco Hoekwater <taco@luatex.org>\n\n\t* lua51/lcoco.c, lua51/lcoco.h: disable the coco patch on\n\tlinux+ppc because it crashes the executable.\n\n2009-06-25  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* font/writet1.c, image/epdf.[ch], utils/avlstuff.c:\n\tremove #include <kpathsea/c-proto.h>.\n \t\n2009-06-25  Taco Hoekwater <taco@luatex.org>\n \t\n\t* luatexdir: import of luatex release 0.40.6.\n\n2009-06-23  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/luatex.c: drop P?C, P?H, use ANSI C function declarations.\n\n2009-06-23  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* font/writet1.c, image/epdf.c, utils/avlstuff.c:\n\t#include <stdarg.h>, not <kpathsea/c-vararg.h>.\n\n2009-06-09  Taco Hoekwater <taco@luatex.org>\n \t\n\t* luatexdir: import of luatex release 0.40.4.\n\n2009-06-08  Taco Hoekwater <taco@luatex.org>\n \t\n\t* luatexdir: import of luatex release 0.40.3.\n\tThis affects many files in subdirectories.\n\n2009-06-04  Taco Hoekwater <taco@luatex.org>\n\t\n\t* luatexdir: \"avoid variable declaration after statement\" patch\n\tfrom Vladimir Volovich\n\n2009-06-03  Taco Hoekwater <taco@luatex.org>\n \t\n\t* luatexdir/luafontloader/fontforge/fontforge/namelist.c (psaltnames): add\n\ta dimension specifier, for AIX portability.\n\n2009-06-03  Taco Hoekwater <taco@luatex.org>\n \t\n\t* luatexdir: import of luatex release 0.40.2.\n\tThis affects many files in subdirectories.\n\n2009-05-30  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* am/luatex.am (install-exec-hook, uninstall-hook):\n\tavoid dangling symlinks.\n\n2009-05-25  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* am/luatex.am (uninstall-hook): new target to uninstall texlua[c]\n\tsymlinks.\n\n2009-05-25  Karl Berry  <karl@tug.org>\n\n\t* am/luatex.am (install-exec-hook): new target to install texlua[c]\n\tsymlinks.\n\n2009-05-08  Taco Hoekwater <taco@luatex.org>\n \t\n\t* luatexdir: import of the current state of luatex, 0.40.1.\n\tThis affects many files in subdirectories.\n\n2009-05-05  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* image/pdftoepdf.cc, utils/utils.c: adapt for poppler.\n\n\tpatches from Norbert Preinig <preining@logic.at>\n\n2009-04-27  Taco Hoekwater <taco@luatex.org>\n\n\t* pdf/pdfpage.c: rename exp10 to exp10_arr to solve a \n\tconflict with cygwin's <math.h>.\n\t* font/texfont.h: add #undef quad before definition to suppress a\n\tcompiler warning under cygwin. \n\n2009-04-22  Taco Hoekwater <taco@luatex.org>\n\n\t* luatexdir: import of the current state of luatex, 0.40.0. \n\tThis affects many files in subdirectories.\n\n2009-04-16  Taco Hoekwater <taco@luatex.org>\n\n\t* image/image.h: remove the trick that forced a local png.h\n\n2009-04-16  Taco Hoekwater <taco@luatex.org>\n\n\t* luatexdir: import of the current state of luatex, 0.39.0. \n\tThis affects many files in subdirectories.\n\n2009-03-27  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* am/luatex.am (luatex_c_h): avoid to split the C code\n\t(from Taco).\n\n2009-03-27  Taco Hoekwater <taco@luatex.org>\n\n\t* luatexdir: import of the current state of luatex, 0.37.0. \n\tThis affects many files in subdirectories.\n\n2009-03-05  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* image/pdftoepdf.cc: Uninclude <config.h>, included later\n\tby \"epdf.h\".\n\n2009-03-03  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatangle.ch: use kpse_open_file to locate input files,\n\tin order to respect WEBINPUTS (ported from tangle.ch).\n", "/*\n\nCopyright 1996-2006 Han The Thanh <thanh@pdftex.org>\nCopyright 2006-2009 Taco Hoekwater <taco@luatex.org>\n\nThis file is part of LuaTeX.\n\nLuaTeX is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2 of the License, or (at your\noption) any later version.\n\nLuaTeX is distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\nLicense for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith LuaTeX; if not, see <http://www.gnu.org/licenses/>.\n\n*/\n\n#include \"ptexlib.h\"\n#include <string.h>\n\n#define get_length1()              t1_length1 = t1_offset() - t1_save_offset\n#define get_length2()              t1_length2 = t1_offset() - t1_save_offset\n#define get_length3()              t1_length3 = fixedcontent? t1_offset() - t1_save_offset : 0\n#define save_offset()              t1_save_offset = t1_offset()\n#define t1_putchar(A)              strbuf_putchar(pdf->fb, (A))\n#define t1_offset()                strbuf_offset(pdf->fb)\n#define out_eexec_char             t1_putchar\n#define end_last_eexec_line()      t1_eexec_encrypt = false\n#define t1_char(c)                 c\n#define embed_all_glyphs(tex_font) fm_cur->all_glyphs\n#define extra_charset()            fm_cur->charset\n#define fixedcontent               false\n\nint t1_length1, t1_length2, t1_length3;\nstatic int t1_save_offset;\nstatic int t1_fontname_offset;\n\nstatic unsigned char *t1_buffer = NULL;\nstatic int t1_size = 0;\nstatic int t1_curbyte = 0;\n\n#define t1_read_file()   readbinfile(t1_file,&t1_buffer,&t1_size)\n#define t1_close()       xfclose(t1_file,cur_file_name)\n#define t1_getchar()     t1_buffer[t1_curbyte++]\n#define t1_ungetchar(c)  t1_curbyte--\n#define t1_eof()         (t1_curbyte>t1_size)\n\n#define t1_prefix(s)     str_prefix(t1_line_array, s)\n#define t1_buf_prefix(s) str_prefix(t1_buf_array, s)\n#define t1_suffix(s)     str_suffix(t1_line_array, t1_line_ptr, s)\n#define t1_buf_suffix(s) str_suffix(t1_buf_array, t1_buf_ptr, s)\n#define t1_charstrings() strstr(t1_line_array, charstringname)\n#define t1_subrs()       t1_prefix(\"/Subrs\")\n#define t1_end_eexec()   t1_suffix(\"mark currentfile closefile\")\n#define t1_cleartomark() t1_prefix(\"cleartomark\")\n\nstatic unsigned char *enc_buffer = NULL;\nstatic int enc_size = 0;\nstatic int enc_curbyte = 0;\n\n#define enc_open(a)     (enc_file = fopen((char *)(a), FOPEN_RBIN_MODE))\n#define enc_read_file() readbinfile(enc_file,&enc_buffer,&enc_size)\n#define enc_close()     xfclose(enc_file,cur_file_name)\n#define enc_getchar()   enc_buffer[enc_curbyte++]\n#define enc_eof()       (enc_curbyte>enc_size)\n\n#define valid_code(c)  (c >= 0 && c < 256)\n#define fixedcontent    false\n\nstatic const char *standard_glyph_names[256] = {\n    /* 0x00 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0x10 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0x20 */\n    \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\",\n    \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\", \"asterisk\",\n    \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\",\n    /* 0x30 */\n    \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\",\n    \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\",\n    /* 0x40 */\n    \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\",\n    \"O\",\n    /* 0x50 */\n    \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\",\n    \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\",\n    /* 0x60 */\n    \"quoteleft\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\",\n    \"m\", \"n\", \"o\",\n    /* 0x70 */\n    \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\",\n    \"braceright\", \"asciitilde\", notdef,\n    /* 0x80 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0x90 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0xa0 */\n    notdef, \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\", \"florin\",\n    \"section\", \"currency\", \"quotesingle\", \"quotedblleft\", \"guillemotleft\",\n    \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\",\n    /* 0xb0 */\n    notdef, \"endash\", \"dagger\", \"daggerdbl\", \"periodcentered\", notdef,\n    \"paragraph\", \"bullet\", \"quotesinglbase\", \"quotedblbase\",\n    \"quotedblright\", \"guillemotright\", \"ellipsis\", \"perthousand\", notdef,\n    \"questiondown\",\n    /* 0xc0 */\n    notdef, \"grave\", \"acute\", \"circumflex\", \"tilde\", \"macron\", \"breve\",\n    \"dotaccent\", \"dieresis\", notdef,\n    \"ring\", \"cedilla\", notdef, \"hungarumlaut\", \"ogonek\", \"caron\",\n    /* 0xd0 */\n    \"emdash\", notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0xe0 */\n    notdef, \"AE\", notdef, \"ordfeminine\", notdef, notdef, notdef, notdef,\n    \"Lslash\", \"Oslash\", \"OE\", \"ordmasculine\", notdef, notdef, notdef,\n    notdef,\n    /* 0xf0 */\n    notdef, \"ae\", notdef, notdef, notdef, \"dotlessi\", notdef, notdef, \"lslash\",\n    \"oslash\", \"oe\", \"germandbls\", notdef, notdef, notdef, notdef\n};\n\nstatic fd_entry *fd_cur;\n\nstatic char charstringname[] = \"/CharStrings\";\n\nenum { ENC_STANDARD, ENC_BUILTIN } t1_encoding;\n\n#define T1_BUF_SIZE   0x0010\n#define ENC_BUF_SIZE  0x1000\n\n#define CS_HSTEM             1\n#define CS_VSTEM             3\n#define CS_VMOVETO           4\n#define CS_RLINETO           5\n#define CS_HLINETO           6\n#define CS_VLINETO           7\n#define CS_RRCURVETO         8\n#define CS_CLOSEPATH         9\n#define CS_CALLSUBR         10\n#define CS_RETURN           11\n#define CS_ESCAPE           12\n#define CS_HSBW             13\n#define CS_ENDCHAR          14\n#define CS_RMOVETO          21\n#define CS_HMOVETO          22\n#define CS_VHCURVETO        30\n#define CS_HVCURVETO        31\n#define CS_1BYTE_MAX        (CS_HVCURVETO + 1)\n\n#define CS_DOTSECTION       CS_1BYTE_MAX +  0\n#define CS_VSTEM3           CS_1BYTE_MAX +  1\n#define CS_HSTEM3           CS_1BYTE_MAX +  2\n#define CS_SEAC             CS_1BYTE_MAX +  6\n#define CS_SBW              CS_1BYTE_MAX +  7\n#define CS_DIV              CS_1BYTE_MAX + 12\n#define CS_CALLOTHERSUBR    CS_1BYTE_MAX + 16\n#define CS_POP              CS_1BYTE_MAX + 17\n#define CS_SETCURRENTPOINT  CS_1BYTE_MAX + 33\n#define CS_2BYTE_MAX        (CS_SETCURRENTPOINT + 1)\n#define CS_MAX              CS_2BYTE_MAX\n\ntypedef unsigned char byte;\n\n/*tex A |CharString| command: */\n\ntypedef struct {\n    /*tex number of arguments */\n    byte nargs;\n    /*tex take arguments from bottom of stack? */\n    boolean bottom;\n    /*tex clear stack? */\n    boolean clear;\n    boolean valid;\n} cc_entry;\n\ntypedef struct {\n    /*tex glyph name (or |notdef| for |Subrs| entry) */\n    char *name;\n    byte *data;\n    /*tex length of the whole string */\n    unsigned short len;\n    /*tex length of the encoded part of the string */\n    unsigned short cslen;\n    boolean used;\n    boolean valid;\n} cs_entry;\n\nstatic unsigned short t1_dr, t1_er;\nstatic const unsigned short t1_c1 = 52845, t1_c2 = 22719;\nstatic unsigned short t1_cslen;\nstatic short t1_lenIV;\nstatic char enc_line[ENC_BUF_SIZE];\n\n#define t1_line_entry char\ndefine_array(t1_line);\n\n#define t1_buf_entry char\ndefine_array(t1_buf);\n\nstatic int cs_start;\n\nstatic cs_entry *cs_tab, *cs_ptr, *cs_notdef;\nstatic char *cs_dict_start, *cs_dict_end;\nstatic int cs_counter, cs_size, cs_size_pos;\n\nstatic cs_entry *subr_tab;\nstatic char *subr_array_start, *subr_array_end;\nstatic int subr_max, subr_size, subr_size_pos;\n\n/*tex\n\n    This list contains the begin/end tokens commonly used in the |/Subrs| array of\n    a Type 1 font.\n\n*/\n\nstatic const char *cs_token_pairs_list[][2] = {\n    { \" RD\", \"NP\" },\n    { \" -|\", \"|\" },\n    { \" RD\", \"noaccess put\" },\n    { \" -|\", \"noaccess put\" },\n    { NULL,  NULL }\n};\n\nstatic const char **cs_token_pair;\n\nstatic boolean t1_pfa, t1_cs, t1_scan, t1_eexec_encrypt, t1_synthetic;\n\n/*tex This one becomes 0 before 1 during and 2 after |eexec| encryption. */\n\nstatic int t1_in_eexec;\n\nstatic long t1_block_length;\nstatic int last_hexbyte;\nstatic FILE *t1_file;\nstatic FILE *enc_file;\n\nstatic void enc_getline(void)\n{\n    char *p;\n    char c;\n  restart:\n    if (enc_eof())\n        normal_error(\"type 1\",\"unexpected end of file\");\n    p = enc_line;\n    do {\n        c = (char) enc_getchar();\n        append_char_to_buf(c, p, enc_line, ENC_BUF_SIZE);\n    }\n    while (c != 10 && !enc_eof());\n    append_eol(p, enc_line, ENC_BUF_SIZE);\n    if (p - enc_line < 2 || *enc_line == '%')\n        goto restart;\n}\n\n/*tex\n\n    Read encoding from .enc file, return |glyph_names array|, or |pdffail|.\n\n*/\n\nchar **load_enc_file(char *enc_name)\n{\n    int callback_id = 0;\n    int file_opened = 0;\n    char buf[ENC_BUF_SIZE], *p, *r;\n    int i, names_count;\n    char **glyph_names;\n    cur_file_name = luatex_find_file(enc_name, find_enc_file_callback);\n    if (cur_file_name == NULL) {\n        formatted_error(\"type 1\",\"cannot find encoding file '%s' for reading\", enc_name);\n    }\n    callback_id = callback_defined(read_enc_file_callback);\n    enc_curbyte = 0;\n    enc_size = 0;\n    if (callback_id > 0) {\n        if (run_callback(callback_id, \"S->bSd\", cur_file_name, &file_opened, &enc_buffer, &enc_size)) {\n            if ((!file_opened) || enc_size == 0) {\n                formatted_error(\"type 1\",\"cannot open encoding file '%s' for reading\", cur_file_name);\n            }\n        }\n    } else {\n        if (!enc_open(cur_file_name)) {\n            formatted_error(\"type 1\",\"cannot open encoding file '%s' for reading\", cur_file_name);\n        }\n        enc_read_file();\n        enc_close();\n    }\n    glyph_names = xtalloc(256, char *);\n    for (i = 0; i < 256; i++)\n        glyph_names[i] = (char *) notdef;\n    report_start_file(filetype_map,cur_file_name);\n    enc_getline();\n    if (*enc_line != '/' || (r = strchr(enc_line, '[')) == NULL) {\n        remove_eol(r, enc_line);\n        formatted_error(\"type 1\",\"invalid encoding vector (a name or '[' missing): '%s'\", enc_line);\n    }\n    names_count = 0;\n    /*tex Skip |[|: */\n    r++;\n    skip_char(r, ' ');\n    for (;;) {\n        while (*r == '/') {\n            for (p = buf, r++;\n                 *r != ' ' && *r != 10 && *r != ']' && *r != '/'; *p++ = *r++);\n            *p = 0;\n            skip_char(r, ' ');\n            if (names_count >= 256)\n                normal_error(\"type 1\",\"encoding vector contains more than 256 names\");\n            if (strcmp(buf, notdef) != 0)\n                glyph_names[names_count] = xstrdup(buf);\n            names_count++;\n        }\n        if (*r != 10 && *r != '%') {\n            if (strncmp(r, \"] def\", strlen(\"] def\")) == 0)\n                goto done;\n            else {\n                remove_eol(r, enc_line);\n                formatted_error(\"type 1\",\"invalid encoding vector: a name or '] def' expected: `%s'\",enc_line);\n            }\n        }\n        enc_getline();\n        r = enc_line;\n    }\n  done:\n    report_stop_file(filetype_map);\n    cur_file_name = NULL;\n    xfree(enc_buffer);\n    return glyph_names;\n}\n\nstatic void t1_check_pfa(void)\n{\n    const int c = t1_getchar();\n    t1_pfa = (c != 128) ? true : false;\n    t1_ungetchar(c);\n}\n\nstatic int t1_getbyte(void)\n{\n    int c = t1_getchar();\n    if (t1_pfa)\n        return c;\n    if (t1_block_length == 0) {\n        if (c != 128)\n            normal_error(\"type 1\",\"invalid marker\");\n        c = t1_getchar();\n        if (c == 3) {\n            while (!t1_eof())\n                (void) t1_getchar();\n            return EOF;\n        }\n        t1_block_length = t1_getchar() & 0xff;\n        t1_block_length |= (t1_getchar() & 0xff) << 8;\n        t1_block_length |= (t1_getchar() & 0xff) << 16;\n        t1_block_length |= (t1_getchar() & 0xff) << 24;\n        c = t1_getchar();\n    }\n    t1_block_length--;\n    return c;\n}\n\nstatic int hexval(int c)\n{\n    if (c >= 'A' && c <= 'F')\n        return c - 'A' + 10;\n    else if (c >= 'a' && c <= 'f')\n        return c - 'a' + 10;\n    else if (c >= '0' && c <= '9')\n        return c - '0';\n    else\n        return -1;\n}\n\nstatic byte edecrypt(byte cipher)\n{\n    byte plain;\n    if (t1_pfa) {\n        while (cipher == 10 || cipher == 13)\n            cipher = (byte) t1_getbyte();\n        last_hexbyte = cipher = (byte) ((hexval(cipher) << 4) + hexval(t1_getbyte()));\n    }\n    plain = (byte) (cipher ^ (t1_dr >> 8));\n    t1_dr = (unsigned short) ((cipher + t1_dr) * t1_c1 + t1_c2);\n    return plain;\n}\n\nstatic byte cdecrypt(byte cipher, unsigned short *cr)\n{\n    const byte plain = (byte) (cipher ^ (*cr >> 8));\n    *cr = (unsigned short) ((cipher + *cr) * t1_c1 + t1_c2);\n    return plain;\n}\n\nstatic byte eencrypt(byte plain)\n{\n    const byte cipher = (byte) (plain ^ (t1_er >> 8));\n    t1_er = (unsigned short) ((cipher + t1_er) * t1_c1 + t1_c2);\n    return cipher;\n}\n\nstatic byte cencrypt(byte plain, unsigned short *cr)\n{\n    const byte cipher = (byte) (plain ^ (*cr >> 8));\n    *cr = (unsigned short) ((cipher + *cr) * t1_c1 + t1_c2);\n    return cipher;\n}\n\nstatic char *eol(char *s)\n{\n    char *p = strend(s);\n    if (p - s > 1 && p[-1] != 10) {\n        *p++ = 10;\n        *p = 0;\n    }\n    return p;\n}\n\nstatic float t1_scan_num(char *p, char **r)\n{\n    float f;\n    skip_char(p, ' ');\n    if (sscanf(p, \"%g\", &f) != 1) {\n        remove_eol(p, t1_line_array);\n        formatted_error(\"type 1\",\"a number expected: '%s'\", t1_line_array);\n    }\n    if (r != NULL) {\n        for (; isdigit((unsigned char)*p) || *p == '.' ||\n             *p == 'e' || *p == 'E' || *p == '+' || *p == '-'; p++);\n        *r = p;\n    }\n    return f;\n}\n\nstatic boolean str_suffix(const char *begin_buf, const char *end_buf, const char *s)\n{\n    const char *s1 = end_buf - 1, *s2 = strend(s) - 1;\n    if (*s1 == 10)\n        s1--;\n    while (s1 >= begin_buf && s2 >= s) {\n        if (*s1-- != *s2--)\n            return false;\n    }\n    return s2 < s;\n}\n\nstatic void t1_getline(void)\n{\n    int c, l, eexec_scan;\n    char *p;\n    static const char eexec_str[] = \"currentfile eexec\";\n    static int eexec_len = 17;\n  restart:\n    if (t1_eof())\n        normal_error(\"type 1\",\"unexpected end of file\");\n    t1_line_ptr = t1_line_array;\n    alloc_array(t1_line, 1, T1_BUF_SIZE);\n    t1_cslen = 0;\n    eexec_scan = 0;\n    c = t1_getbyte();\n    if (c == EOF)\n        goto exit;\n    while (!t1_eof()) {\n        if (t1_in_eexec == 1)\n            c = edecrypt((byte) c);\n        alloc_array(t1_line, 1, T1_BUF_SIZE);\n        {\n            char cc = (char) c;\n            append_char_to_buf(cc, t1_line_ptr, t1_line_array, t1_line_limit);\n        }\n        if (t1_in_eexec == 0 && eexec_scan >= 0 && eexec_scan < eexec_len) {\n            if (t1_line_array[eexec_scan] == eexec_str[eexec_scan])\n                eexec_scan++;\n            else\n                eexec_scan = -1;\n        }\n        if (c == 10 || c == 13\n            || (t1_pfa && eexec_scan == eexec_len && c == 32)) {\n            break;\n        }\n        if (t1_cs && t1_cslen == 0 && (t1_line_ptr - t1_line_array > 4) &&\n            (t1_suffix(\" RD \") || t1_suffix(\" -| \"))) {\n            p = t1_line_ptr - 5;\n            while (*p != ' ')\n                p--;\n            l = (int) t1_scan_num(p + 1, 0);\n            t1_cslen = (unsigned short) l;\n            /*tex |cs_start| is an index now */\n            cs_start = (int) (t1_line_ptr - t1_line_array);\n            alloc_array(t1_line, l, T1_BUF_SIZE);\n            while (l-- > 0)\n                *t1_line_ptr++ = (t1_line_entry) edecrypt((byte) t1_getbyte());\n        }\n        c = t1_getbyte();\n    }\n    /*tex |append_eol| can append 2 chars */\n    alloc_array(t1_line, 2, T1_BUF_SIZE);\n    append_eol(t1_line_ptr, t1_line_array, t1_line_limit);\n    if (t1_line_ptr - t1_line_array < 2)\n        goto restart;\n    if (eexec_scan == eexec_len)\n        t1_in_eexec = 1;\n  exit:\n    /*tex Ensure that |t1_buf_array| has as much room as |t1_line_array|. */\n    t1_buf_ptr = t1_buf_array;\n    alloc_array(t1_buf, t1_line_limit, t1_line_limit);\n}\n\nstatic void t1_putline(PDF pdf)\n{\n    char *p = t1_line_array;\n    if (t1_line_ptr - t1_line_array <= 1)\n        return;\n    if (t1_eexec_encrypt) {\n        while (p < t1_line_ptr)\n            t1_putchar((eight_bits) eencrypt((byte) * p++));\n    } else\n        while (p < t1_line_ptr)\n            t1_putchar((eight_bits) * p++);\n}\n\nstatic void t1_puts(PDF pdf, const char *s)\n{\n    if (s != t1_line_array)\n        strcpy(t1_line_array, s);\n    t1_line_ptr = strend(t1_line_array);\n    t1_putline(pdf);\n}\n\n__attribute__ ((format(printf, 2, 3)))\nstatic void t1_printf(PDF pdf, const char *fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    vsprintf(t1_line_array, fmt, args);\n    t1_puts(pdf, t1_line_array);\n    va_end(args);\n}\n\nstatic void t1_init_params(int open_name_prefix)\n{\n    report_start_file(open_name_prefix,cur_file_name);\n    t1_lenIV = 4;\n    t1_dr = 55665;\n    t1_er = 55665;\n    t1_in_eexec = 0;\n    t1_cs = false;\n    t1_scan = true;\n    t1_synthetic = false;\n    t1_eexec_encrypt = false;\n    t1_block_length = 0;\n    t1_check_pfa();\n}\n\nstatic void t1_close_font_file(int close_name_suffix)\n{\n    report_stop_file(close_name_suffix);\n    cur_file_name = NULL;\n}\n\nstatic void t1_check_block_len(boolean decrypt)\n{\n    int l, c;\n    if (t1_block_length == 0)\n        return;\n    c = t1_getbyte();\n    if (decrypt)\n        c = edecrypt((byte) c);\n    l = (int) t1_block_length;\n    if (!(l == 0 && (c == 10 || c == 13))) {\n        formatted_error(\"type 1\",\"%i bytes more than expected were ignored\", l + 1);\n    }\n}\n\nstatic void t1_start_eexec(PDF pdf)\n{\n    int i;\n    get_length1();\n    save_offset();\n    if (!t1_pfa)\n        t1_check_block_len(false);\n    for (t1_line_ptr = t1_line_array, i = 0; i < 4; i++) {\n        edecrypt((byte) t1_getbyte());\n        *t1_line_ptr++ = 0;\n    }\n    t1_eexec_encrypt = true;\n    /*tex To put the first four bytes: */\n    t1_putline(pdf);\n}\n\nstatic void t1_stop_eexec(PDF pdf)\n{\n    int c;\n    get_length2();\n    save_offset();\n    t1_eexec_encrypt = false;\n    if (!t1_pfa)\n        t1_check_block_len(true);\n    else {\n        c = edecrypt((byte) t1_getbyte());\n        if (!(c == 10 || c == 13)) {\n            if (last_hexbyte == 0)\n                t1_puts(pdf, \"00\");\n            else\n                normal_error(\"type 1\",\"unexpected data after eexec\");\n        }\n    }\n    t1_cs = false;\n    t1_in_eexec = 2;\n}\n\n/*tex Macros for various transforms; unused, left for reference: */\n\n#ifdef T1TRANSFORMMACROS\n#  define do_xshift(x,a) {x[4]+=a;}\n#  define do_yshift(x,a) {x[5]+=a;}\n#  define do_xscale(x,a) {x[0]*=a; x[2]*=a; x[4]*=a;}\n#  define do_yscale(x,a) {x[1]*=a; x[3]*=a; x[5]*=a;}\n#  define do_extend(x,a) {do_xscale(x,a);}\n#  define do_scale(x,a)  {do_xscale(x,a); do_yscale(x,a);}\n#  define do_slant(x,a)  {x[0]+=x[1]*(a); x[2]+=x[3]*(a); x[4]+=x[5]*(a);}\n#  define do_shear(x,a)  {x[1]+=x[0]*(a); x[3]+=x[2]*(a); x[5]+=x[4]*(a);}\n\n#  define do_rotate(x,a) {        \\\n    float t, u=cos(a), v=sin(a);  \\\n    t    =x[0]*u+x[1]*-v;         \\\n    x[1] =x[0]*v+x[1]* u; x[0]=t; \\\n    t    =x[2]*u+x[3]*-v;         \\\n    x[3] =x[2]*v+x[3]* u; x[2]=t; \\\n    t    =x[4]*u+x[5]*-v;         \\\n    x[5] =x[4]*v+x[5]* u; x[4]=t; \\\n}\n#endif\n\nstatic void t1_scan_keys(PDF pdf)\n{\n    int i, k;\n    char *p, *q, *r;\n    const key_entry *key;\n    if (t1_prefix(\"/FontType\")) {\n        p = t1_line_array + strlen(\"FontType\") + 1;\n        if ((i = (int) t1_scan_num(p, 0)) != 1)\n            formatted_error(\"type 1\",\"Type%d fonts unsupported by backend\", i);\n        return;\n    }\n    for (key = (const key_entry *) font_key; key - font_key < FONT_KEYS_NUM;\n         key++) {\n        if (key->t1name[0] != '\\0'\n            && str_prefix(t1_line_array + 1, key->t1name))\n            break;\n    }\n    if (key - font_key == FONT_KEYS_NUM)\n        return;\n    p = t1_line_array + strlen(key->t1name) + 1;\n    skip_char(p, ' ');\n    if ((k = (int) (key - font_key)) == FONTNAME_CODE) {\n        if (*p != '/') {\n            remove_eol(p, t1_line_array);\n            formatted_error(\"type 1\",\"a name expected: '%s'\", t1_line_array);\n        }\n        /*tex Skip the slash. */\n        r = ++p;\n        for (q = t1_buf_array; *p != ' ' && *p != 10; *q++ = *p++);\n        *q = 0;\n        xfree(fd_cur->fontname);\n        fd_cur->fontname = xstrdup(t1_buf_array);\n        /*tex\n\n            At this moment we cannot call |make_subset_tag| yet, as the encoding\n            is not read; thus we mark the offset of the subset tag and write it\n            later.\n\n        */\n        if (is_subsetted(fd_cur->fm)) {\n            t1_fontname_offset = (int) (t1_offset() + (r - t1_line_array));\n            strcpy(t1_buf_array, p);\n            sprintf(r, \"ABCDEF+%s%s\", fd_cur->fontname, t1_buf_array);\n            t1_line_ptr = eol(r);\n        }\n        return;\n    }\n    if ((k == STEMV_CODE || k == FONTBBOX1_CODE) && (*p == '[' || *p == '{'))\n        p++;\n    if (k == FONTBBOX1_CODE) {\n        for (i = 0; i < 4; i++, k++) {\n            fd_cur->font_dim[k].val = (int) t1_scan_num(p, &r);\n            fd_cur->font_dim[k].set = true;\n            p = r;\n        }\n        return;\n    }\n    fd_cur->font_dim[k].val = (int) t1_scan_num(p, 0);\n    fd_cur->font_dim[k].set = true;\n}\n\nstatic void t1_scan_param(PDF pdf)\n{\n    static const char *lenIV = \"/lenIV\";\n    if (!t1_scan || *t1_line_array != '/')\n        return;\n    if (t1_prefix(lenIV)) {\n        t1_lenIV = (short) t1_scan_num(t1_line_array + strlen(lenIV), 0);\n        if (t1_lenIV < 0)\n            normal_error(\"type 1\",\"negative value of lenIV is not supported\");\n        return;\n    }\n    t1_scan_keys(pdf);\n}\n\nstatic void copy_glyph_names(char **glyph_names, int a, int b)\n{\n    if (glyph_names[b] != notdef) {\n        xfree(glyph_names[b]);\n        glyph_names[b] = (char *) notdef;\n    }\n    if (glyph_names[a] != notdef) {\n        glyph_names[b] = xstrdup(glyph_names[a]);\n    }\n}\n\n/*tex Read encoding from Type1 font file, return |glyph_names| array, or |pdffail|. */\n\nstatic char **t1_builtin_enc(void)\n{\n    int i, a, b, c, counter = 0;\n    char *r, *p, **glyph_names;\n    /*tex At this moment |/Encoding| is the prefix of |t1_line_array|. */\n    glyph_names = xtalloc(256, char *);\n    for (i = 0; i < 256; i++)\n        glyph_names[i] = (char *) notdef;\n    if (t1_suffix(\"def\")) {\n        /*tex A predefined encoding: */\n        sscanf(t1_line_array + strlen(\"/Encoding\"), \"%255s\", t1_buf_array);\n        if (strcmp(t1_buf_array, \"StandardEncoding\") == 0) {\n            t1_encoding = ENC_STANDARD;\n            for (i = 0; i < 256; i++) {\n                if (standard_glyph_names[i] != notdef)\n                    glyph_names[i] = xstrdup(standard_glyph_names[i]);\n            }\n            return glyph_names;\n        } else\n            formatted_error(\"type 1\",\"cannot subset font (unknown predefined encoding '%s')\",t1_buf_array);\n    }\n    /*\n\n        At this moment |/Encoding| is the prefix of |t1_line_array|, and the\n        encoding is not a predefined encoding. We have two possible forms of\n        vector. The first case is\n\n        \\starttyping\n        /Encoding [\n            /a /b /c ...\n        ] readonly def\n        \\stoptyping\n\n        and the second case can look like\n\n        \\starttyping\n        /Encoding 256 array 0 1 255 {\n            1 index exch /.notdef put} for\n            dup 0 /x put\n            dup 1 /y put\n            ...\n        } readonly def\n        \\stoptyping\n\n    */\n    t1_encoding = ENC_BUILTIN;\n    if (t1_prefix(\"/Encoding [\") || t1_prefix(\"/Encoding[\")) {  /* the first case */\n        r = strchr(t1_line_array, '[') + 1;\n        skip_char(r, ' ');\n        for (;;) {\n            while (*r == '/') {\n                for (p = t1_buf_array, r++; *r != 32 && *r != 10 && *r != ']' && *r != '/'; *p++ = *r++);\n                *p = 0;\n                skip_char(r, ' ');\n                if (counter > 255)\n                    normal_error(\"type 1\",\"encoding vector contains more than 256 names\");\n                if (strcmp(t1_buf_array, notdef) != 0)\n                    glyph_names[counter] = xstrdup(t1_buf_array);\n                counter++;\n            }\n            if (*r != 10 && *r != '%') {\n                if (str_prefix(r, \"] def\") || str_prefix(r, \"] readonly def\"))\n                    break;\n                else {\n                    remove_eol(r, t1_line_array);\n                    formatted_error(\"type 1\",\"a name or '] def' or '] readonly def' expected: '%s'\", t1_line_array);\n                }\n            }\n            t1_getline();\n            r = t1_line_array;\n        }\n    } else {\n        /*tex The second case. */\n        p = strchr(t1_line_array, 10);\n        for (;;) {\n            if (*p == 10) {\n                t1_getline();\n                p = t1_line_array;\n            }\n            /*tex Check for |dup <index> <glyph> put|. */\n            if (sscanf(p, \"dup %i%255s put\", &i, t1_buf_array) == 2 &&\n                *t1_buf_array == '/' && valid_code(i)) {\n                if (strcmp(t1_buf_array + 1, notdef) != 0)\n                    glyph_names[i] = xstrdup(t1_buf_array + 1);\n                p = strstr(p, \" put\") + strlen(\" put\");\n                skip_char(p, ' ');\n            }\n            /*tex Check for |dup dup <to> exch <from> get put|. */\n            else if (sscanf(p, \"dup dup %i exch %i get put\", &b, &a) == 2 && valid_code(a) && valid_code(b)) {\n                copy_glyph_names(glyph_names, a, b);\n                p = strstr(p, \" get put\") + strlen(\" get put\");\n                skip_char(p, ' ');\n            }\n            /*tex Check for |dup dup <from> <size> getinterval <to> exch putinterval|. */\n            else if (sscanf(p, \"dup dup %i %i getinterval %i exch putinterval\",\n                    &a, &c, &b) == 3 && valid_code(a) && valid_code(b) && valid_code(c)) {\n                for (i = 0; i < c; i++)\n                    copy_glyph_names(glyph_names, a + i, b + i);\n                p = strstr(p, \" putinterval\") + strlen(\" putinterval\");\n                skip_char(p, ' ');\n            }\n            /*tex Check for |def or |readonly def|. */\n            else if ((p == t1_line_array || (p > t1_line_array && p[-1] == ' ')) && strcmp(p, \"def\\n\") == 0) {\n                return glyph_names;\n            } else {\n                /*tex Skip an unrecognizable word. */\n                while (*p != ' ' && *p != 10)\n                    p++;\n                skip_char(p, ' ');\n            }\n        }\n    }\n    return glyph_names;\n}\n\nstatic void t1_check_end(PDF pdf)\n{\n    if (t1_eof())\n        return;\n    t1_getline();\n    if (t1_prefix(\"{restore}\"))\n        t1_putline(pdf);\n}\n\nstatic boolean t1_open_fontfile(int open_name_prefix)\n{\n    ff_entry *ff;\n    int callback_id = 0;\n    int file_opened = 0;\n    t1_curbyte = 0;\n    t1_size = 0;\n    ff = check_ff_exist(fd_cur->fm->ff_name, is_truetype(fd_cur->fm));\n    if (ff->ff_path == NULL) {\n        formatted_error(\"type 1\",\"cannot open file for reading '%s'\",fd_cur->fm->ff_name);\n        return false;\n    }\n    cur_file_name = luatex_find_file(ff->ff_path, find_type1_file_callback);\n    if (cur_file_name == NULL) {\n        formatted_error(\"type 1\",\"cannot open file for reading '%s'\", ff->ff_path);\n        return false;\n    }\n    callback_id = callback_defined(read_type1_file_callback);\n    if (callback_id > 0) {\n        if (!run_callback(callback_id, \"S->bSd\", cur_file_name, &file_opened, &t1_buffer, &t1_size)\n            && file_opened && t1_size > 0) {\n            formatted_warning(\"type 1\",\"cannot open file for reading '%s'\",cur_file_name);\n            return false;\n        }\n    } else {\n        t1_file = xfopen(cur_file_name, FOPEN_RBIN_MODE);\n        t1_read_file();\n        t1_close();\n    }\n    recorder_record_input(cur_file_name);\n    t1_init_params(open_name_prefix);\n    return true;\n}\n\nstatic void t1_include(PDF pdf)\n{\n    do {\n        t1_getline();\n        t1_scan_param(pdf);\n        t1_putline(pdf);\n    }\n    while (t1_in_eexec == 0);\n    t1_start_eexec(pdf);\n    do {\n        t1_getline();\n        t1_scan_param(pdf);\n        t1_putline(pdf);\n    }\n    while (!(t1_charstrings() || t1_subrs()));\n    t1_cs = true;\n    do {\n        t1_getline();\n        t1_putline(pdf);\n    }\n    while (!t1_end_eexec());\n    t1_stop_eexec(pdf);\n    if (fixedcontent) {\n        /*tex Copy 512 zeros (not needed for \\PDF). */\n        do {\n            t1_getline();\n            t1_putline(pdf);\n        }\n        while (!t1_cleartomark());\n        /*tex Write |{restore} if| if found. */\n        t1_check_end(pdf);\n    }\n    get_length3();\n}\n\n#define check_subr(subr) \\\n    if (subr >= subr_size || subr < 0) \\\n        formatted_error(\"type 1\",\"Subrs array: entry index out of range '%i'\", subr);\n\nstatic const char **check_cs_token_pair(void)\n{\n    const char **p = (const char **) cs_token_pairs_list;\n    for (; p[0] != NULL; ++p)\n        if (t1_buf_prefix(p[0]) && t1_buf_suffix(p[1]))\n            return p;\n    return NULL;\n}\n\nstatic void cs_store(boolean is_subr)\n{\n    char *p;\n    cs_entry *ptr;\n    int subr;\n    for (p = t1_line_array, t1_buf_ptr = t1_buf_array; *p != ' ';\n         *t1_buf_ptr++ = *p++);\n    *t1_buf_ptr = 0;\n    if (is_subr) {\n        subr = (int) t1_scan_num(p + 1, 0);\n        check_subr(subr);\n        ptr = subr_tab + subr;\n    } else {\n        ptr = cs_ptr++;\n        if (cs_ptr - cs_tab > cs_size)\n            formatted_error(\"type 1\",\"CharStrings dict: more entries than dict size '%i'\", cs_size);\n        if (strcmp(t1_buf_array + 1, notdef) == 0)      /* skip the slash */\n            ptr->name = (char *) notdef;\n        else\n            ptr->name = xstrdup(t1_buf_array + 1);\n    }\n    /*tex Copy |\" RD \" + cs data| to |t1_buf_array|. */\n    memcpy(t1_buf_array, t1_line_array + cs_start - 4, (unsigned) (t1_cslen + 4));\n    /*tex Copy the end of cs data to |t1_buf_array|. */\n    for (p = t1_line_array + cs_start + t1_cslen, t1_buf_ptr =\n         t1_buf_array + t1_cslen + 4; *p != 10; *t1_buf_ptr++ = *p++);\n    *t1_buf_ptr++ = 10;\n    if (is_subr && cs_token_pair == NULL)\n        cs_token_pair = check_cs_token_pair();\n    ptr->len = (unsigned short) (t1_buf_ptr - t1_buf_array);\n    ptr->cslen = t1_cslen;\n    xfree(ptr->data);\n    ptr->data = xtalloc(ptr->len, byte);\n    memcpy(ptr->data, t1_buf_array, ptr->len);\n    ptr->valid = true;\n}\n\n#define store_subr() cs_store(true)\n#define store_cs()   cs_store(false)\n\n#define CC_STACK_SIZE 24\n\nstatic int cc_stack[CC_STACK_SIZE], *stack_ptr = cc_stack;\nstatic cc_entry cc_tab[CS_MAX];\nstatic boolean is_cc_init = false;\n\n#define cc_pop(N) \\\n    if (stack_ptr - cc_stack < (N)) \\\n        stack_error(N); \\\n    stack_ptr -= N\n\n#define stack_error(N) { \\\n    formatted_error(\"type 1\",\"CharString: invalid access '%i' to stack, '%i' entries\", (int) N, (int)(stack_ptr - cc_stack)); \\\n    goto cs_error; \\\n}\n\n#define cc_get(N)  ((N) < 0 ? *(stack_ptr + (N)) : *(cc_stack + (N)))\n#define cc_push(V) *stack_ptr++ = V\n#define cc_clear() stack_ptr = cc_stack\n\n#define set_cc(N, B, A, C) \\\n    cc_tab[N].nargs = A;   \\\n    cc_tab[N].bottom = B;  \\\n    cc_tab[N].clear = C;   \\\n    cc_tab[N].valid = true\n\nstatic void cc_init(void)\n{\n    int i;\n    if (is_cc_init)\n        return;\n    for (i = 0; i < CS_MAX; i++)\n        cc_tab[i].valid = false;\n    set_cc(CS_HSTEM, true, 2, true);\n    set_cc(CS_VSTEM, true, 2, true);\n    set_cc(CS_VMOVETO, true, 1, true);\n    set_cc(CS_RLINETO, true, 2, true);\n    set_cc(CS_HLINETO, true, 1, true);\n    set_cc(CS_VLINETO, true, 1, true);\n    set_cc(CS_RRCURVETO, true, 6, true);\n    set_cc(CS_CLOSEPATH, false, 0, true);\n    set_cc(CS_CALLSUBR, false, 1, false);\n    set_cc(CS_RETURN, false, 0, false);\n    set_cc(CS_HSBW, true, 2, true);\n    set_cc(CS_ENDCHAR, false, 0, true);\n    set_cc(CS_RMOVETO, true, 2, true);\n    set_cc(CS_HMOVETO, true, 1, true);\n    set_cc(CS_VHCURVETO, true, 4, true);\n    set_cc(CS_HVCURVETO, true, 4, true);\n    set_cc(CS_DOTSECTION, false, 0, true);\n    set_cc(CS_VSTEM3, true, 6, true);\n    set_cc(CS_HSTEM3, true, 6, true);\n    set_cc(CS_SEAC, true, 5, true);\n    set_cc(CS_SBW, true, 4, true);\n    set_cc(CS_DIV, false, 2, false);\n    set_cc(CS_CALLOTHERSUBR, false, 0, false);\n    set_cc(CS_POP, false, 0, false);\n    set_cc(CS_SETCURRENTPOINT, true, 2, true);\n    is_cc_init = true;\n}\n\n#define cs_getchar()    cdecrypt(*data++, &cr)\n\n#define mark_subr(n)    cs_mark(0, n)\n#define mark_cs(s)      cs_mark(s, 0)\n\nstatic void cs_fail(const char *cs_name, int subr, const char *fmt, ...)\n{\n    char buf[SMALL_BUF_SIZE];\n    va_list args;\n    va_start(args, fmt);\n    vsprintf(buf, fmt, args);\n    va_end(args);\n    if (cs_name == NULL)\n        formatted_error(\"type 1\",\"Subr '%i': %s\", (int) subr, buf);\n    else\n        formatted_error(\"type 1\",\"CharString (/%s): %s\", cs_name, buf);\n}\n\n/*tex Fix a return-less subr by appending |CS_RETURN|. */\n\nstatic void append_cs_return(cs_entry * ptr)\n{\n    unsigned short cr;\n    int i;\n    byte *p, *q, *data, *new_data;\n    /*tex Decrypt the cs data to |t1_buf_array|, append |CS_RETURN|. */\n    p = (byte *) t1_buf_array;\n    data = ptr->data + 4;\n    cr = 4330;\n    for (i = 0; i < ptr->cslen; i++)\n        *p++ = cs_getchar();\n    *p = CS_RETURN;\n    /*tex Encrypt the new cs data to |new_data|. */\n    new_data = xtalloc((unsigned) (ptr->len + 1), byte);\n    memcpy(new_data, ptr->data, 4);\n    p = new_data + 4;\n    q = (byte *) t1_buf_array;\n    cr = 4330;\n    for (i = 0; i < ptr->cslen + 1; i++)\n        *p++ = cencrypt(*q++, &cr);\n    memcpy(p, ptr->data + 4 + ptr->cslen, (size_t) (ptr->len - ptr->cslen - 4));\n    /*tex Update |*ptr|. */\n    xfree(ptr->data);\n    ptr->data = new_data;\n    ptr->len++;\n    ptr->cslen++;\n}\n\nstatic void cs_mark(const char *cs_name, int subr)\n{\n    byte *data;\n    int i, b, cs_len;\n    int last_cmd = 0;\n    int a, a1, a2;\n    unsigned short cr;\n    /*tex The argument of last call to |OtherSubrs[3]|. */\n    static int lastargOtherSubr3 = 3;\n    cs_entry *ptr;\n    cc_entry *cc;\n    if (cs_name == NULL) {\n        check_subr(subr);\n        ptr = subr_tab + subr;\n        if (!ptr->valid)\n            return;\n    } else if (cs_notdef != NULL && (cs_name == notdef || strcmp(cs_name, notdef) == 0)) {\n        ptr = cs_notdef;\n    }else {\n        for (ptr = cs_tab; ptr < cs_ptr; ptr++)\n            if (strcmp(ptr->name, cs_name) == 0)\n                break;\n        if (ptr == cs_ptr) {\n            formatted_warning(\"type 1\",\"glyph '%s' undefined\", cs_name);\n            return;\n        }\n        if (ptr->name == notdef)\n            cs_notdef = ptr;\n    }\n    /*tex\n        Only marked CharString entries and invalid entries can be skipped; valid\n        marked subrs must be parsed to keep the stack in sync.\n    */\n    if (!ptr->valid || (ptr->used && cs_name != NULL))\n        return;\n    ptr->used = true;\n    cr = 4330;\n    cs_len = ptr->cslen;\n    data = ptr->data + 4;\n    for (i = 0; i < t1_lenIV; i++, cs_len--)\n        cs_getchar();\n    while (cs_len > 0) {\n        --cs_len;\n        b = cs_getchar();\n        if (b >= 32) {\n            if (b <= 246)\n                a = b - 139;\n            else if (b <= 250) {\n                --cs_len;\n                a = ((b - 247) << 8) + 108 + cs_getchar();\n            } else if (b <= 254) {\n                --cs_len;\n                a = -((b - 251) << 8) - 108 - cs_getchar();\n            } else {\n                cs_len -= 4;\n                a = (cs_getchar() & 0xff) << 24;\n                a |= (cs_getchar() & 0xff) << 16;\n                a |= (cs_getchar() & 0xff) << 8;\n                a |= (cs_getchar() & 0xff) << 0;\n                if (sizeof(int) > 4 && (a & 0x80000000))\n                    a |= ~0x7FFFFFFF;\n            }\n            cc_push(a);\n        } else {\n            if (b == CS_ESCAPE) {\n                b = cs_getchar() + CS_1BYTE_MAX;\n                cs_len--;\n            }\n            if (b >= CS_MAX) {\n                cs_fail(cs_name, subr, \"command value out of range: %i\", (int) b);\n                goto cs_error;\n            }\n            cc = cc_tab + b;\n            if (!cc->valid) {\n                cs_fail(cs_name, subr, \"command not valid: %i\", (int) b);\n                goto cs_error;\n            }\n            if (cc->bottom) {\n                if (stack_ptr - cc_stack < cc->nargs)\n                    cs_fail(cs_name, subr,\n                            \"less arguments on stack '%i' than required '%i'\",\n                            (int) (stack_ptr - cc_stack), (int) cc->nargs);\n                else if (stack_ptr - cc_stack > cc->nargs)\n                    cs_fail(cs_name, subr,\n                            \"more arguments on stack '%i' than required '%i'\",\n                            (int) (stack_ptr - cc_stack), (int) cc->nargs);\n            }\n            last_cmd = b;\n            switch (cc - cc_tab) {\n                case CS_CALLSUBR:\n                    a1 = cc_get(-1);\n                    cc_pop(1);\n                    mark_subr(a1);\n                    if (!subr_tab[a1].valid) {\n                        cs_fail(cs_name, subr, \"cannot call subr '%i'\", (int) a1);\n                        goto cs_error;\n                    }\n                    break;\n                case CS_DIV:\n                    cc_pop(2);\n                    cc_push(0);\n                    break;\n                case CS_CALLOTHERSUBR:\n                    if (cc_get(-1) == 3)\n                        lastargOtherSubr3 = cc_get(-3);\n                    a1 = cc_get(-2) + 2;\n                    cc_pop(a1);\n                    break;\n                case CS_POP:\n                    cc_push(lastargOtherSubr3);\n                    /*tex\n                        The only case when we care about the value being pushed\n                        onto stack is when |POP| follows |CALLOTHERSUBR| changing\n                        hints by |OtherSubrs[3]|.\n                    */\n                    break;\n                case CS_SEAC:\n                    a1 = cc_get(3);\n                    a2 = cc_get(4);\n                    cc_clear();\n                    mark_cs(standard_glyph_names[a1]);\n                    mark_cs(standard_glyph_names[a2]);\n                    break;\n                default:\n                    if (cc->clear)\n                        cc_clear();\n            }\n        }\n    }\n    if (cs_name == NULL && last_cmd != CS_RETURN) {\n        formatted_warning(\"type 1\",\n            \"last command in subr '%i' is not a RETURN; I will add it now but please consider fixing the font\",\n            (int) subr);\n        append_cs_return(ptr);\n    }\n    return;\n    /*tex An error occured during parsing: */\n  cs_error:\n    cc_clear();\n    ptr->valid = false;\n    ptr->used = false;\n}\n\n/* AVL search tree for glyph code by glyph name. */\n\nstatic int comp_t1_glyphs(const void *pa, const void *pb, void *p\n    __attribute__ ((unused)))\n{\n    return strcmp(*(const char *const *) pa, *(const char *const *) pb);\n}\n\nstatic struct avl_table *create_t1_glyph_tree(char **glyph_names)\n{\n    int i;\n    void **aa;\n    static struct avl_table *gl_tree;\n    gl_tree = avl_create(comp_t1_glyphs, NULL, &avl_xallocator);\n    for (i = 0; i < 256; i++) {\n        if (glyph_names[i] != notdef &&\n            (char **) avl_find(gl_tree, &glyph_names[i]) == NULL) {\n            /*tex No |strdup| here, just point to the |glyph_names| array members. */\n            aa = avl_probe(gl_tree, &glyph_names[i]);\n            if (aa == NULL) {\n                /*tex Is this a problem? */\n            }\n        }\n    }\n    return gl_tree;\n}\n\nstatic void destroy_t1_glyph_tree(struct avl_table *gl_tree)\n{\n    avl_destroy(gl_tree, NULL);\n}\n\nstatic void t1_subset_ascii_part(PDF pdf)\n{\n    int j, *p;\n    char *glyph, **gg, **glyph_names;\n    struct avl_table *gl_tree;\n    struct avl_traverser t;\n    void **aa;\n    t1_getline();\n    while (!t1_prefix(\"/Encoding\")) {\n        t1_scan_param(pdf);\n        t1_putline(pdf);\n        t1_getline();\n    }\n    glyph_names = t1_builtin_enc();\n    fd_cur->builtin_glyph_names = glyph_names;\n    if (is_subsetted(fd_cur->fm)) {\n        if (fd_cur->tx_tree != NULL) {\n            /*tex Take over collected non-reencoded characters from \\TeX. */\n            avl_t_init(&t, fd_cur->tx_tree);\n            for (p = (int *) avl_t_first(&t, fd_cur->tx_tree); p != NULL;\n                 p = (int *) avl_t_next(&t)) {\n                if ((char *) avl_find(fd_cur->gl_tree, glyph_names[*p]) == NULL) {\n                    glyph = xstrdup(glyph_names[*p]);\n                    aa = avl_probe(fd_cur->gl_tree, glyph);\n                    assert(aa != NULL);\n                }\n            }\n        }\n        make_subset_tag(fd_cur);\n        strncpy((char *) pdf->fb->data + t1_fontname_offset, fd_cur->subset_tag,6);\n    }\n    /*tex Now really all glyphs needed from this font are in the |fd_cur->gl_tree|. */\n    if (t1_encoding == ENC_STANDARD)\n        t1_puts(pdf, \"/Encoding StandardEncoding def\\n\");\n    else {\n        t1_puts(pdf,\"/Encoding 256 array\\n0 1 255 {1 index exch /.notdef put} for\\n\");\n        gl_tree = create_t1_glyph_tree(glyph_names);\n        avl_t_init(&t, fd_cur->gl_tree);\n        j = 0;\n        for (glyph = (char *) avl_t_first(&t, fd_cur->gl_tree); glyph != NULL;\n             glyph = (char *) avl_t_next(&t)) {\n            if ((gg = (char **) avl_find(gl_tree, &glyph)) != NULL) {\n                t1_printf(pdf, \"dup %i /%s put\\n\", (int) (gg - glyph_names),*gg);\n                j++;\n            }\n        }\n        destroy_t1_glyph_tree(gl_tree);\n        if (j == 0) {\n            /*tex\n                We didn't mark anything for the Encoding array. We add |{dup 0\n                /.notdef put}| for compatibility with Acrobat 5.0.\n            */\n            t1_puts(pdf, \"dup 0 /.notdef put\\n\");\n        }\n        t1_puts(pdf, \"readonly def\\n\");\n    }\n    do {\n        t1_getline();\n        t1_scan_param(pdf);\n        if (!t1_prefix(\"/UniqueID\")) {\n            /*tex Ignore |/UniqueID| for subsetted fonts. */\n            t1_putline(pdf);\n        }\n    }\n    while (t1_in_eexec == 0);\n}\n\nstatic void cs_init(void)\n{\n    cs_ptr = cs_tab = NULL;\n    cs_dict_start = cs_dict_end = NULL;\n    cs_counter = cs_size = cs_size_pos = 0;\n    cs_token_pair = NULL;\n    subr_tab = NULL;\n    subr_array_start = subr_array_end = NULL;\n    subr_max = subr_size = subr_size_pos = 0;\n}\n\nstatic void init_cs_entry(cs_entry * cs)\n{\n    cs->data = NULL;\n    cs->name = NULL;\n    cs->len = 0;\n    cs->cslen = 0;\n    cs->used = false;\n    cs->valid = false;\n}\n\nstatic void t1_read_subrs(PDF pdf)\n{\n    int i, s;\n    cs_entry *ptr;\n    t1_getline();\n    while (!(t1_charstrings() || t1_subrs())) {\n        t1_scan_param(pdf);\n        if (!t1_prefix(\"/UniqueID\")) {\n            /*tex Ignore |/UniqueID| for subsetted fonts. */\n            t1_putline(pdf);\n        }\n        t1_getline();\n    }\n  found:\n    t1_cs = true;\n    t1_scan = false;\n    if (!t1_subrs())\n        return;\n    subr_size_pos = strlen(\"/Subrs\") + 1;\n    /*tex |subr_size_pos| points to the number indicating dict size after |Subrs|. */\n    subr_size = (int) t1_scan_num(t1_line_array + subr_size_pos, 0);\n    if (subr_size == 0) {\n        while (!t1_charstrings())\n            t1_getline();\n        return;\n    }\n    subr_tab = xtalloc((unsigned) subr_size, cs_entry);\n    for (ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n        init_cs_entry(ptr);\n    subr_array_start = xstrdup(t1_line_array);\n    t1_getline();\n    while (t1_cslen) {\n        store_subr();\n        t1_getline();\n    }\n    /*tex Mark the first four entries without parsing. */\n    for (i = 0; i < subr_size && i < 4; i++)\n        subr_tab[i].used = true;\n    /*tex\n\n        The end of the |Subrs| array might have more than one line so we need to\n        concatenate them to |subr_array_end|. Unfortunately some fonts don't have\n        the |Subrs| array followed by the |CharStrings| dict immediately (synthetic\n        fonts). If we cannot find |CharStrings| in next |POST_SUBRS_SCAN| lines\n        then we will treat the font as synthetic and ignore everything until next\n        |Subrs| is found.\n\n     */\n#define POST_SUBRS_SCAN 5\n    s = 0;\n    *t1_buf_array = 0;\n    for (i = 0; i < POST_SUBRS_SCAN; i++) {\n        if (t1_charstrings())\n            break;\n        s = (int) (s + t1_line_ptr - t1_line_array);\n        alloc_array(t1_buf, s, T1_BUF_SIZE);\n        strcat(t1_buf_array, t1_line_array);\n        t1_getline();\n    }\n    subr_array_end = xstrdup(t1_buf_array);\n    if (i == POST_SUBRS_SCAN) {\n        /*tex |CharStrings| not found: assume a synthetic font. */\n        for (ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n            if (ptr->valid)\n                xfree(ptr->data);\n        xfree(subr_tab);\n        xfree(subr_array_start);\n        xfree(subr_array_end);\n        cs_init();\n        t1_cs = false;\n        t1_synthetic = true;\n        while (!(t1_charstrings() || t1_subrs()))\n            t1_getline();\n        goto found;\n    }\n}\n\n#define t1_subr_flush()  t1_flush_cs(pdf, true)\n#define t1_cs_flush()    t1_flush_cs(pdf, false)\n\nstatic void t1_flush_cs(PDF pdf, boolean is_subr)\n{\n    char *p;\n    byte *r, *return_cs = NULL;\n    cs_entry *tab, *end_tab, *ptr;\n    char *start_line, *line_end;\n    int count, size_pos;\n    unsigned short cr, cs_len;\n    if (is_subr) {\n        start_line = subr_array_start;\n        line_end = subr_array_end;\n        size_pos = subr_size_pos;\n        tab = subr_tab;\n        count = subr_max + 1;\n        end_tab = subr_tab + count;\n    } else {\n        start_line = cs_dict_start;\n        line_end = cs_dict_end;\n        size_pos = cs_size_pos;\n        tab = cs_tab;\n        end_tab = cs_ptr;\n        count = cs_counter;\n    }\n    t1_line_ptr = t1_line_array;\n    for (p = start_line; p - start_line < size_pos;)\n        *t1_line_ptr++ = *p++;\n    while (isdigit((unsigned char)*p))\n        p++;\n    sprintf(t1_line_ptr, \"%u\", count);\n    strcat(t1_line_ptr, p);\n    t1_line_ptr = eol(t1_line_array);\n    t1_putline(pdf);\n    /*tex For |-Wall|. */\n    cs_len = 0;\n    /*tex Create |return_cs| to replace unsused |subr|s. */\n    if (is_subr) {\n        cr = 4330;\n        cs_len = 0;\n        /*tex\n            At this point we have |t1_lenIV >= 0;| a negative value would be\n            caught in |t1_scan_param|.\n        */\n        return_cs = xtalloc((unsigned) (t1_lenIV + 1), byte);\n        for (cs_len = 0, r = return_cs; cs_len < t1_lenIV; cs_len++, r++)\n            *r = cencrypt(0x00, &cr);\n        *r = cencrypt(CS_RETURN, &cr);\n        cs_len++;\n    }\n    for (ptr = tab; ptr < end_tab; ptr++) {\n        if (ptr->used) {\n            if (is_subr)\n                sprintf(t1_line_array, \"dup %li %u\", (long int) (ptr - tab),\n                        ptr->cslen);\n            else\n                sprintf(t1_line_array, \"/%s %u\", ptr->name, ptr->cslen);\n            p = strend(t1_line_array);\n            memcpy(p, ptr->data, ptr->len);\n            t1_line_ptr = p + ptr->len;\n            t1_putline(pdf);\n        } else {\n            /*tex Replace unsused subr's by |return_cs|. */\n            if (is_subr) {\n                sprintf(t1_line_array, \"dup %li %u%s \", (long int) (ptr - tab),\n                        cs_len, cs_token_pair[0]);\n                p = strend(t1_line_array);\n                memcpy(p, return_cs, cs_len);\n                t1_line_ptr = p + cs_len;\n                t1_putline(pdf);\n                sprintf(t1_line_array, \" %s\", cs_token_pair[1]);\n                t1_line_ptr = eol(t1_line_array);\n                t1_putline(pdf);\n            }\n        }\n        xfree(ptr->data);\n        if (is_subr)\n            ptr->valid = false;\n        if (ptr->name != notdef)\n            xfree(ptr->name);\n    }\n    sprintf(t1_line_array, \"%s\", line_end);\n    t1_line_ptr = eol(t1_line_array);\n    t1_putline(pdf);\n    if (is_subr) {\n        end_tab = subr_tab + subr_size;\n        for (ptr = tab; ptr < end_tab; ptr++) {\n            if (ptr->valid) {\n                xfree(ptr->data);\n                if (ptr->name != notdef)\n                    xfree(ptr->name);\n            }\n        }\n        xfree(return_cs);\n    }\n    xfree(tab);\n    xfree(start_line);\n    xfree(line_end);\n}\n\nstatic void t1_mark_glyphs(void)\n{\n    char *glyph;\n    struct avl_traverser t;\n    cs_entry *ptr;\n    if (t1_synthetic || fd_cur->all_glyphs) {\n        /*tex Mark everything. */\n        if (cs_tab != NULL)\n            for (ptr = cs_tab; ptr < cs_ptr; ptr++)\n                if (ptr->valid)\n                    ptr->used = true;\n        if (subr_tab != NULL) {\n            for (ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n                if (ptr->valid)\n                    ptr->used = true;\n            subr_max = subr_size - 1;\n        }\n        return;\n    }\n    mark_cs(notdef);\n    avl_t_init(&t, fd_cur->gl_tree);\n    for (glyph = (char *) avl_t_first(&t, fd_cur->gl_tree); glyph != NULL;\n         glyph = (char *) avl_t_next(&t)) {\n        mark_cs(glyph);\n    }\n    if (subr_tab != NULL)\n        for (subr_max = -1, ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n            if (ptr->used && ptr - subr_tab > subr_max)\n                subr_max = (int) (ptr - subr_tab);\n}\n\n\n/*tex\n\n    When |t1_subset_charstrings| is called, the |t1_line_array| contains\n    |/CharStrings|. When we hit a case like this:\n\n    \\starttyping\n     dup/CharStrings\n     229 dict dup begin\n    \\stoptyping\n\n    we read the next line and concatenate to |t1_line_array| before moving on.\n    That is what |t1_check_unusual_charstring| is for.\n\n*/\n\nstatic void t1_check_unusual_charstring(void)\n{\n    char *p = strstr(t1_line_array, charstringname) + strlen(charstringname);\n    int i;\n    /*tex If no number follows |/CharStrings|, let's read the next line. */\n    if (sscanf(p, \"%i\", &i) != 1) {\n        strcpy(t1_buf_array, t1_line_array);\n        t1_getline();\n        strcat(t1_buf_array, t1_line_array);\n        strcpy(t1_line_array, t1_buf_array);\n        t1_line_ptr = eol(t1_line_array);\n    }\n}\n\nstatic void t1_subset_charstrings(PDF pdf)\n{\n    cs_entry *ptr;\n    t1_check_unusual_charstring();\n    cs_size_pos = (int) (strstr(t1_line_array, charstringname) + strlen(charstringname) - t1_line_array + 1);\n    /*tex |cs_size_pos| points to the number indicating dict size after |/CharStrings|. */\n    cs_size = (int) t1_scan_num(t1_line_array + cs_size_pos, 0);\n    cs_ptr = cs_tab = xtalloc((unsigned) cs_size, cs_entry);\n    for (ptr = cs_tab; ptr - cs_tab < cs_size; ptr++)\n        init_cs_entry(ptr);\n    cs_notdef = NULL;\n    cs_dict_start = xstrdup(t1_line_array);\n    t1_getline();\n    while (t1_cslen) {\n        store_cs();\n        t1_getline();\n    }\n    cs_dict_end = xstrdup(t1_line_array);\n    t1_mark_glyphs();\n    if (subr_tab != NULL) {\n        if (cs_token_pair == NULL)\n            formatted_error(\"type 1\",\"mismatched subroutine begin/end token pairs\");\n        t1_subr_flush();\n    }\n    for (cs_counter = 0, ptr = cs_tab; ptr < cs_ptr; ptr++)\n        if (ptr->used)\n            cs_counter++;\n    t1_cs_flush();\n}\n\nstatic void t1_subset_end(PDF pdf)\n{\n    if (t1_synthetic) {\n        /*tex Copy to |dup /FontName get exch definefont pop|. */\n        while (!strstr(t1_line_array, \"definefont\")) {\n            t1_getline();\n            t1_putline(pdf);\n        }\n        while (!t1_end_eexec()) {\n            /*tex Ignore the rest. */\n            t1_getline();\n        }\n        /*tex Write \\.{mark currentfile closefile}. */\n        t1_putline(pdf);\n    } else {\n        while (!t1_end_eexec()) {\n            /*tex Copy to \\.{mark currentfile closefile}. */\n            t1_getline();\n            t1_putline(pdf);\n        }\n    }\n    t1_stop_eexec(pdf);\n    if (fixedcontent) {\n        /*tex Copy 512 zeros (not needed for PDF). */\n        while (!t1_cleartomark()) {\n            t1_getline();\n            t1_putline(pdf);\n        }\n        /*tex Don't check \\.{{restore}if} for synthetic fonts. */\n        if (!t1_synthetic) {\n            /*tex Write \\.{{restore}if} if found. */\n            t1_check_end(pdf);\n        }\n    }\n    get_length3();\n}\n\nvoid writet1(PDF pdf, fd_entry * fd)\n{\n    /*tex |fd_cur| is global inside |writet1.c|. */\n    fd_cur = fd;\n    assert(fd_cur->fm != NULL);\n    assert(is_type1(fd->fm));\n    assert(is_included(fd->fm));\n\n    t1_save_offset = 0;\n    if (!is_subsetted(fd_cur->fm)) {\n        /*tex Include entire font. */\n        if (!(fd->ff_found = t1_open_fontfile(filetype_font)))\n            return;\n        t1_include(pdf);\n        t1_close_font_file(filetype_font);\n        xfree(t1_buffer);\n        return;\n    }\n    /*tex Partial downloading. */\n    if (!(fd->ff_found = t1_open_fontfile(filetype_subset)))\n        return;\n    t1_subset_ascii_part(pdf);\n    t1_start_eexec(pdf);\n    cc_init();\n    cs_init();\n    t1_read_subrs(pdf);\n    t1_subset_charstrings(pdf);\n    t1_subset_end(pdf);\n    t1_close_font_file(filetype_subset);\n    xfree(t1_buffer);\n}\n\nvoid t1_free(void)\n{\n    xfree(t1_line_array);\n    xfree(t1_buf_array);\n}\n", "2018-09-09  Karl Berry  <karl@tug.org>\n\n\t* expanded.test,\n\t* ttf2afm.test: LC_ALL=LANGUAGE=C.\n\n2018-07-09  Karl Berry  <karl@freefriends.org>\n\n\t* writefont.c (write_fontdescriptor) [ENABLE_PDF_CHARSET]:\n\tcompile-time conditional for re-enabling output of PDF /CharSet,\n\twhich is now disabled by default.\n\n2018-06-13  TANAKA Takuji  <ttk@t-lab.opal.ne.jp>\n\n\t* ptexlib.h: Output correct Unicode strings on console\n\t(w32 only).\n\n2018-06-12  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftoepdf.cc: Free unused memory (w32 only).\n\n2018-06-11  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftoepdf.cc: Remove xfree(file_name) in order to avoid\n\tto output garbage.\n\t* pdftoepdf-newpoppler.cc: Remove _WIN32 changes, since\n\tutf-8 names are transformed to Unicode and _wopened\n\tin poppler.\n\n2018-06-10  TANAKA Takuji  <ttk@t-lab.opal.ne.jp>\n\n\t* ptexlib.h, pdftoepdf.cc, pdftoepdf-newpoppler.cc:\n\tAllow non-ascii file names for pdfTeX with UTF-8 source files\n\t(w32 only). The function is enabled by setting\n\t'command_line_encoding=utf-8' in texmf.cnf.\n\n2018-05-29  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* ptexlib.h: Discard the changes on 2018-05-11, since\n\t'command_line_encoding=utf-8' is not so natural for\n\tpdfTeX (w32 only).\n\n2018-05-13  Joseph Wright  <joseph.wright@morningstar2.co.uk>\n\n\t* pdftex.web: New primitive \\expanded based on original\n\t  suggestion by Heiko Oberdiek, and with work by\n\t  Bruno Le Floch and David Carlisle (on behalf of The LaTeX Project).\n        (expanded_code): new @d, new cases.\n        https://mailman.ntg.nl/pipermail/ntg-pdftex/2018-May/004233.html\n\n2018-05-11  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* ptexlib.h: Allow non-ascii file names in pdfTeX (w32 only).\n\n2018-04-28  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftoepdf-newpoppler.cc, pdftosrc-newpoppler.cc:\n\tSupport poppler 0.64.0.\n\n2018-04-14  Karl Berry  <karl@tug.org>\n\n\t* TeX Live 2018 release, pdftex 1.40.19.\n\n2018-04-04  Jerry James  <loganjerry@gmail.com>\n\n\t* pdftoepdf-newpoppler.cc: Do not copy a Dict, get a reference instead.\n\n2018-03-24  Hironobu Yamashita  <h.y.acetaminophen@gmail.com>\n            Hironori Kitagawa  <h_kitagawa2001@yahoo.co.jp>\n\n\t* pdftex.ch: Recover the right \\lastnodetype initialization\n\tvalue ignored by tex.ch.\n\n2018-03-20  Hans Hagen  <pragma@wxs.nl>\n\n\t* pdftex.web (Glob...): defined saved_pdf_cur_form.\n\t(Write out pending forms): save and restore the form.\n\tOriginal report from Alexander Grahn,\n\thttp://tug.org/pipermail/tex-live/2018-March/041210.html.\n\n2018-03-06  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftex.web: pdftex_revision==\"19\".\n\tReported by Uwe Siart, 2018-03-06.\n\n2018-01-25  Hironobu Yamashita  <h.y.acetaminophen@gmail.com>\n        and Karl Berry  <karl@freefriends.org>\n\n\t* writefont.c (font_is_used): import LuaTeX's font_has_subset\n\twith different name.\n\t(dopdffont): call it, to avoid failed assertion. (tests/09-fontobjnum)\n\tOriginal report from Enrico Gregorio,\n\t  tug.org/pipermail/tex-live/2018-January/040966.html\n\tfollowup with patch at\n\t  mailman.ntg.nl/pipermail/ntg-pdftex/2018-January/004209.html\n\n2018-01-06  Karl Berry  <karl@freefriends.org>\n\n\t* pdftex.web (literal): if a non-PDF special is ignored,\n\talso output \"<special> \" and the first 64 characters of the special.\n\t(slow_print_substr): new procedure, although surely there's\n\talready a way to print a substring of a pool string.\n\n2018-01-01  Pali Roh\\'ar  <pali.rohar@gmail.com>\n\n\tPatch 1: explicitly detect bitmap PK font in fm_scan_line,\n\tinstead of the implicit check of ps_name and ff_name being NULL.\n\t* ptexmac.h (F_PK, set_pk, unset_pk, is_pk): new macros.\n\t* writefont.c (dopdffont): call writet3 if is_pk.\n\t* mapfile.c (fm_scan_line): call set_pk if no fontfile\n\tand no ps_name on encoding line.\n\n\tPatch 2: Always embed bitmap fonts with different sizes\n\tseparately, even if it has a fontmap entry; i.e., no geometric\n\tscaling in the generated PDF.\n\t* pdftex.defines (isscalable),\n\t* ptexlib.h (isscalable),\n\t* mapfile.c (isscalable): new fn.\n\t* pdftex.web: call isscalable instead of hasfmentry\n\tin all cases except @<Output fonts definition@>.\n\t\t\n\tPatch 3: Allow .enc files for bitmap PK fonts.\n\t* ptexlib.h (writet3): take additional fm_entry* parameter.\n\t* writefont.c (dopdffont): change call.\n\t* writet3.c (writet3): change definition;\n\twrite_tounicode and encoding vector if we can.\n\t(remove_duplicate_glyph_names): new fn.\n\t\n\tPatch 4: Additional checks for PK fonts in map file.\n\t* mapfile.c (check_fm_entry): \n\n\tChangeLog entry, some comments, error messages written or tweaked\n\tby Karl Berry; all substantive code by Pali. Patch posted at\n\thttps://mailman.ntg.nl/pipermail/ntg-pdftex/2017-August/004183.html.\n\tSee test-pkmap.tex for more references and some tests.\n\n2017-12-16  Hironori Kitagawa  <h_kitagawa2001@yahoo.co.jp>\n\n\t* pdftex.web (compare_strings): Fix \\pdfstrcmp error message\n        \"! File ended while ...\" to report control sequence correctly.\n\thttp://tug.org/pipermail/tex-k/2017-December/002838.html\n\n2017-12-15  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* tounicode.c (deftounicode): check that value is in range [0,10FFFF].\n\tOriginal report from Ross Moore, ntg-pdftex 30 May 2017 06:03:04.\n\n2017-12-02  Karl Berry  <karl@tug.org>\n\n\t* am/pdftex.am (pdftex.pdf, pdftex.tex): new convenience targets\n\tfor simple weave && pdftex to generate typeset output.\n\n2017-11-28  Hironori KITAGAWA <h_kitagawa2001@yahoo.co.jp>\n\n\tStop \\pdfprimitive\\vrule\\q from swallowing q, by moving prim_eqtb\n\tinto the end of region 2 of eqtb instead of being a separate table.\n\t* pdftex.ch (frozen_null_font): add prim_size.\n\t* pdftex.web (prim_size): move to other region 2 definitions.\n\t(prim_eqtb_base): new constant.\n\t(prim_eq_level, prim_eq_type, prim_equiv): use prim_eqtb_base.\n\t(prim_eqtb): remove array.\n\t(Set init...): remove initializations.\n\t(Basic printing...),\n\t(Basic printing procedures): handle primitives after prim_eqtb_base.\n\t(Implement \\.{\\\\pdfprimitive}): do not give error if argument is\n\t not a primitive, just do nothing.\n\t(Reset |cur_tok| for unexpandable primitives, goto restart):\n\t handle primitive lookups via prim_eqtb_base instead of cur_cmd*@'400.\n\t(Cases of |main_control| that are not part of the inner loop):\n\t<not undefined_primitive>: also set cur_tok.\n\t(Dump the hash table): do not dump prim_eqtb.\n\t(Undump the hash table): do not undump prim_eqtb.\n\t\n2017-11-14  Anders Kaseorg  <andersk@mit.edu>\n\n\t* utils.c (printID): Do not hash the current directory name into\n\tthe PDF ID field, since any variability in it leads to\n\tnon-reproducible builds.\n\tpdftex mailing list, 2 Sep 2017 01:52:43\n\thttps://bugs.debian.org/874102\n\n2017-10-17  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftosrc.cc: Support also xpdf-3.04 if XPDF304 is defined.\n\t* pdftoepdf-newpoppler.cc, pdftosrc-newpoppler.cc: New files\n\tadded in order to support poppler 0.59.0 or newer versions.\n\tPOPPLER_VERSION should be defined. At present, simply overwrite\n\tpdftoepdf.cc and pdftosrc.cc by pdftoepdf-newpoppler.cc and\n\tpdftosrc-newpoppler.cc, respectively, in order to use these\n\tfiles.\n\tThe current pdftoepdf.cc and pdftosrc.cc support\n\txpdf-4.00 by default, xpdf-3.04 if XPDF304 is defined, and\n\tpoppler 0.57.0 or older versions if POPPLER_VERSION is\n\tdefined.\n\n2017-10-10  Shreevatsa R <shreevatsa.public@gmail.com>\n\n\t* pdftex.web: formatting-only fixes to make weave-able.\n\tPosted to ntg-pdftex, 15 Aug 2017 09:49:59.\n\n2017-09-24  Hironori Kitagawa  <h_kitagawa2001@yahoo.co.jp>\n\n\t* pdftex.web: Avoid overwriting prim_* entries by primitive().\n\n2017-09-14  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftosrc.cc: Fix a potential bug which I introduced on\n\t2017-08-13.\n\n2017-08-13  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftosrc.cc: Remove a line, which I believe is not necessary,\n\tto avoid a crash for xpdf-4.00.\n\n2017-04-19  Karl Berry  <karl@freefriends.org>\n\n\t* mapfile.c (read_field): new parameter buf_size,\n\tand check buffer for overflow, as in append_char_to_buf.\n\t(fm_scan_line): change read_field calls;\n\tset tfm_name to empty string instead of leaving NULL.\n\t(check_fm_entry): remove checks of tfm_name on every print;\n\tcheck for empty tfm_name rather than lack of ps_name and font file;\n\tcheck for non-empty tfm_name on slant/extend warnings.\n\n2017-04-12  Karl Berry  <karl@freefriends.org>\n\n\t* mapfile.c (check_fm_entry): do not try to print fm->tfm_name,\n\tetc., in warnings if null.\n\t(fm_scan_line): goto bad_line if a null tfm_name,\n\teven if check_fm_entry returns true.\n\n2017-04-12  Pali Roh\\'ar <pali.rohar@gmail.com>\n\n\t* ptexmac.h (set_subfont, unset_subfont, is_subfont): remove\n        these duplicate macros.\n\n2017-03-29  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n        * writepng.c: Fix the size of memory to allocate when writing\n        SMask in write_png_rgb_alpha. Reported by David Fifield:\n        http://tug.org/pipermail/pdftex/2017-March/009100.html\n\n2017-03-18  Karl Berry  <karl@tug.org>\n\n        * NEWS,\n        * pdftex_version.h,\n        * pdftex.web (pdftex_revision, pdftex_version_string):\n        version [1.40.]18 for TL17.\n\n2017-02-18  Heiko Oberdiek  <heiko.oberdiek@googlemail.com>\n\n\t* pdftex.web (substr_of_str): move earlier.\n\t(Write out page object): if \\MediaBox was given in \\pdfpageattr,\n\tdo not output our own.\n\tMail from Michael Altmann to pdftex, 9 Feb 2017 13:19:05.\n\thttp://tug.org/pipermail/pdftex/2017-February/009097.html\n\n2017-02-16  Karl Berry  <karl@freefriends.org>\n\n\t* regex/regex_internal.h (alloca) [!alloca]: do not try\n\tto #define if already #defined.\n\tReport from Vincent Torri on tex-live list, 7 Jul 2016 10:48:15.\n\t(pdftex r765)\n\n2016-11-05  Karl Berry  <karl@tug.org>\n\n\t* pdftoepdf.cc: doc fix.\n\n2016-07-16  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftoepdf.cc: Use zround(stemV->getNum()) instead of stemV->getInt()\n\tin epdf_create_fontdescriptor(), since the value of stemV may be real\n\tin general.\n\n2016-06-12  Karl Berry  <karl@freefriends.org>\n        and Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* utils.c (last_match_succeeded): new static boolean.\n\t(matchstrings): set it.\n\t(getmatch): use it, plus check for non-NULL match_string sooner,\n\tplus check that rm_eo >= rm_so.\n\tOriginal bug report from David Carlisle,\n        http://tug.org/pipermail/tex-live/2016-June/038664.html\n        (pdftex r759)\n\n2016-06-12  Karl Berry  <karl@freefriends.org>\n        and Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* utils.c (last_match_succeeded): new static boolean.\n\t(matchstrings): set it.\n\t(getmatch): use it, plus check for non-NULL match_string sooner,\n\tplus check that rm_eo >= rm_so.\n\tOriginal bug report from David Carlisle,\n        http://tug.org/pipermail/tex-live/2016-June/038664.html\n\n2016-05-20  Karl Berry  <karl@tug.org>\n\n\t* TeX Live 2016 release.\n\n2016-04-06  Karl Berry  <karl@tug.org>\n\n\t* pdftexextra.h (COPYRIGHT_HOLDER): don't specifically mention peb\n\tand e-TeX, as there are many other copyright holders of other pieces\n\tanyway, and Peter passed away in 2015.\n\n2016-03-24  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* writet1.c: Fix one-byte buffer overflow bug reported by Hanno Boeck:\n\thttp://tug.org/pipermail/tex-live/2016-January/037686.html.\n\n2016-03-21  Karl Berry  <karl@tug.org>\n\n\t* NEWS,\n\t* pdftex_version.h,\n\t* pdftex.web (pdftex_revision, pdftex_version_string): [1.40.]17\n\tfor TL'16.\n\n2016-02-15  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftex.web, pdftoepdf.cc: Add \\pdfsuppressptexinfo, imported from\n\tthe upstream.\n\n2016-01-19  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftex.web: Avoid to crash for unusual virtual fonts which lead to\n\tfont size >= 2048pt.\n\n2015-08-27  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libpdftex.am, am/pdftosrc.am: Enable g++ warnings.\n\t* pdftoepdf.cc, pdftosrc.cc: Avoid g++ warnings.\n\t* tounicode.c: Avoid gcc warnings.\n\n2015-07-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* ptexmac.h: Avoid possible integer overflow.\n\t* writettf.h: No reason to use 'long' for 32-bit integers.\n\t* writettf.c: No reason to use the (possibly 64-bit) 'integer'.\n\n2015-07-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am, am/pdftosrc.am, am/ttf2afm.am: Dependencies for\n\t'make check'.\n\n2015-07-02  Hironori Kitagawa  <h_kitagawa2001@yahoo.co.jp>\n\n\t* utils.c: Moved convertStringToHexString() and getmd5sum()\n\tfrom here to ../lib/texmfmp.c.\n\n2015-06-30  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.defines, ptexlib.h, pdftex.web, utils.c: Sync with\n\tupstream r724.\n\n2015-06-22  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am: Use $(tie_c).\n\n2015-03-07  Karl Berry  <karl@tug.org>\n\n\t* NEWS,\n\t* pdftex_version.h,\n\t* pdftex.web (pdftex_revision, pdftex_version_string): [1.40.]16\n\tfor TL'15.\n\n2015-02-16  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* writejpg.c: support JPEG Exif in addition to JFIF.\n\t(borrowed from dvipdfm-x).\n\n2014-12-12  Karl Berry  <karl@gnu.org>\n\n\t* pdftoepdf.cc (read_pdf_info): do not even warn if\n\tpdf_inclusion_errorlevel (aka \\pdfinclusionerrorlevel) is negative.\n\tDiscussed with Thanh, 31 May 2011 10:17:35.\n\n2014-11-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* regex/regcomp.c [WIN64]: Use __int64 (not long) as intptr_t.\n\n2014-08-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writepng.c: Avoid PNG warnings.\n\n2014-06-26  Thanh Han The  <thanh@river-valley.org>\n\n\t* pdftoepdf.cc: Put a line-ending character after writing a group dict.\n\t(Report from Ross Moore on pdftex list,\n\thttp://tug.org/pipermail/pdftex/2014-June/008911.html)\n\n2014-06-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* mapfile.c, tounicode.c, writet1.c, writettf: Avoid undefined\n\tbehaviour when char is signed.\n\n2014-06-18  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* ttf2afm.c: Avoid undefined behaviour when char is signed.\n\n2014-06-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftosrc.cc: Adapt to xpdf-3.04.\n\n2012-05-20  Thanh Han The  <thanh@river-valley.org>\n\n\t* pdftex.web: do not try to avoid printing 0 0 Td.\n\tE.g., \\rlap fails.\n\t(Report from Heiko on pdftex list, 21 May 2014 22:11:21.)\n\n2014-05-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tUpdate to e-pTeX and e-upTeX from Akira Kakuto.\n\t* ptexlib.h (getfiledump): Move declaration also used by\n\te-(u)pTeX from here to ../texmfmp.h.\n\t* utils.c (getfiledump): Move definition also used by\n\te-(u)pTeX from here to ../lib/texmfmp.c.\n\n2014-03-18  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftex.web and writefont.c: Import from r704.\n\n2014-03-17  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftoepdf.cc, pdftosrc.cc: Kpathsea headers and <w2c/config.h>\n\tare now C++ safe.\n\n2014-03-07  Karl Berry  <karl@tug.org>\n\n\t* pdftex_version.h,\n\t* pdftex.web (pdftex_revision, pdftex_version_string): [1.40.]15.\n\n2014-02-14  Karl Berry  <karl@gnu.org>\n\n\t* pdftex.web (pdf_suppress_warning_page_group): new primitive\n\tparameter \\pdfsuppresswarningpagegroup.\n\t(get_pdf_suppress_warning_page_group): new fn to get its value.\n\t* pdftopdf.cc (write_epdf): check it before issuing warning.\n\n2014-01-20  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tTeX tuneup of 2014.\n\t* pdftex.web, tex.ch0: Adapt to TeX Version 3.14159265.\n\n2014-01-09  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftoepdf.cc (copyObject): Always write \"\\nendstream\" for\n\tPDF/A-1b compliance.\n\n2014-01-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writepng.c: Allow libpng >= 1.6.3 to read images with\n\tincorrect CMF bytes.\n\n2014-01-01  Karl Berry  <karl@tug.org>\n\n\t* All source files: update copyright years to include 2014.\n\n2013-12-23  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web (pdf_end_stream): Always write \"\\nendstream\" for\n\tPDF/A-1b compliance.\n\n2013-12-17  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Always write \"\\n\" after \"obj\" and before \"endobj\".\n\tSuggested by Vincent Immler (http://sarovar.org/tracker/#4341).\n\n2013-12-04  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tUpdate to e-TeX Version 2.6 [2013-11-21].\n\t* etex_version.h, pdftex.web: Enable hyphenation of text between\n\t\\beginL and \\endL or between \\beginR and \\endR.\n\n2013-09-27  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* writet1.c (t1_subset_ascii_part): Remove UniqueID in subsets.\n\tReport from Christian Zietz (czietz/gmx/net),\n\ttex-k 01 Sep 2013 11:25:47 and previous.\n\t(Imported from dvipsk.)\n\n2013-08-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* ttf2afm.test, tests/postV[37].{afm.ttf}: New test and data.\n\t* am/ttf2afm.am: Add the new test.\n\n2013-07-30  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* ttf2afm.c, writettf.c: Treat unknown 'post' table versions\n\t(found in some broken fonts) as 3.0, i.e., no Glyph names.\n\n2013-07-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am, tests/pdfimage.tex: Add a .pdf image.\n\n2013-07-04  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdfimage.test, tests/pdfimage.tex: New test and data.\n\t* am/pdftex.am: Add the new test.\n\n2013-06-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* mapfile.c: First #include <w2c/config.h> via \"ptexlib.h\".\n\t* pdftosrc.cc: First #include <w2c/config.h>.\n\n2013-06-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tUpdate to e-pTeX and e-upTeX 130605 from Hironori Kitagawa.\n\t* ptexlib.h (initstarttime, makecstring, makecfilename,\n\tgetcreationdate, getfilemoddate, getfilesize): Move declarations\n\tof functions also used by e-(u)pTeX from here to ../texmfmp.h.\n\t* utils.c (initstarttime, makecstring, makecfilename,\n\tgetcreationdate, getfilemoddate, getfilesize): Move definition\n\tof these functions from here to ../lib/texmfmp.c.\n\n2013-04-22  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftex.web: pdftex_revision = \"14\"\n\n2013-04-09  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: 1.40.13 ---> 1.40.14 for TL 2013.\n\n2013-03-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Typos.\n\n2013-03-04  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am: Better rules for {pdf,e}tex_version.h.\n\n2013-02-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Adapt to e-TeX 2.5.\n\n2013-02-23  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* etex_version.h: New file extracted from pdftex.web.\n\t* am/pdftex.am, pdftexextra.h: Adjust.\n\n2013-01-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils.c: Include <w2c/config.h> first for large file support.\n\n2013-01-24  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* wprob.test: Avoid spurious failure of parallel-tests.\n\t* am/pdftex.am: Renamed wprob.{tex,log} => pwprob.{tex,log}.\n\n2013-01-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* macnames.c, pdftex-common.h, pdftoepdf.cc, ttf2afm.c,\n\twritet1.c: Change 'const char notdef[]' -> 'char notdef[]' and\n\tremove casts (const char *) -> (char *).\n\n\t* mapfile.c (dummy_fm_entry): Delare const_fm_entry as non-const\n\tand remove the cast.\n\n\t* utils.c (writestreamlength): Cast length for printing.\n\n2012-12-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am (pdftex_version.h): Enable silent rules.\n\n2012-11-05  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Change program name into PDFTEX (not ETEX).\n\t* pdftex.ch: Remove the contents of ../tex-binpool.ch.\n\t* am/pdftex.am (pdftex_ch_srcs): Add tex-binpool.ch.\n\n2012-10-19  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftoepdf.cc: In MSVC 5.0 getNewObjectNumber() requires an int\n\treturn value.\n\n2012-10-18  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftoepdf.cc: #include <w2c/config.h> early to avoid problems\n\twith the definition of boolean in <rpcndr.h> for MINGW32.\n\n2012-10-09  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tThe openbsd compat library is no longer used.\n\t* pdftoepdf.cc, ptexlib.h, utils.c:\n\tDrop #include \"openbsd-compat.h\".\n\t* am/pdftex.am, am/pdftosrc.am: Remove OBSDCOMPAT_*.\n\n2012-10-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tAvoid (most) MinGW compiler warnings from regex code.\n\t* regcomp.c, regexec.c: ANSI C function definitions.\n\t* regcomp.c (init_dfa): Declare codeset_name as const.\n\t* regex_internal.c (re_string_reconstruct, re_dfa_add_node):\n\tAvoid unused variables (for !RE_ENABLE_I18N).\n\t* regexec.c (regexec, re_search_stub, prune_impossible_nodes):\n\tAvoid unused variables (for !_LIBC or !RE_ENABLE_I18N).\n\t(re_search_2_stub): Avoid cast const => non-const.\n\n2012-09-03  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils.c [WIN32] (printID): Convert file names '\\\\' -> '/'.\n\n2012-08-25  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* ttf2afm.c: Drop '#include <libgen.h>', we use xbasename().\n\t* ptexmac.h: Avoid C++ style comment.\n\n2012-08-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* ptexmac.h: Drop unused definition of M_PI & Co.\n\n2012-08-08  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* ptexlib.h: extern void writestreamlength(longinteger, longinteger);\n\tfor largefile.\n\textern void storepacket(internalfontnumber, integer, strnumber); to\n\tavoid a compiler warning.\n\t* utils.c: void writestreamlength(longinteger length, longinteger offset)\n\tfor largefile.\n\t* vfpacket.c: void storepacket(internalfontnumber f, integer c, strnumber s)\n\tto avoid a compiler warning.\n\n2012-08-03  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftex.web: Update eTeX_revision and eTeX_version_string.\n\n2012-08-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Adapt to e-TeX Version 2.5.\n\t* am/pdftex.am: Clarify *tex_version.h dependencies.\n\n2012-07-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils.c (initversionstring): Avoid using asprintf().\n\n2012-07-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am: Distribute pdftex_version.h.\n\t* pdftexextra.h: Use ../etexdir/etex_version.h.\n\n2012-07-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writejbig2.c: Use LONGINTEGER_PRI instead of LONGINTEGER_PRId.\n\n2012-07-15  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* ttf2afm.c: Pass program name string to kpse_set_program_name.\n\n2012-07-15  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftexextra.c: Must #define DLLPROC before reading pdftexd.h.\n\n2012-07-14  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils.c: Use EXIT_FAILURE instead of EX_SOFTWARE.\n\n2012-07-13  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writejbig2.c: Cast xfseeko() arg2 to avoid MSVC warning.\n\n2012-06-30  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftexextra.c [W32TeX]: #define DLLPROC for pdftex.dll.\n\n2012-06-29  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils.c [__MINGW32__]: #include <regex.h> as for Unix instead\n\tof <regex/regex.h>.\n\t* am/libpdftex.am (libpdftex_a_CPPFLAGS): Change accordingly.\n\n2012-06-21  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftosrc.cc: Use XRef::getNumObjects instead of XRef::getSize,\n\trequired for poppler >= 0.19.0.\n\n2012-05-20  Thanh Han The  <thanh@river-valley.org>\n\n\t* pdftex.defines (get/setimagegroupref): these replace imagegroupref.\n\t* ptexlib.h: likewise.\n\t* writeimg.c: define them, and check for page group\n\twithout object number.\n\t* pdftex.web: change calls.\n\t* pdftoepdf.cc: more page-group changes.\n\tThis is all related to http://bugs.debian.org/672951.\n\n2012-05-11  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Adapted to e-TeX Version 2.4.\n\n2012-04-15  Karl Berry  <karl@tug.org>\n\n\t* pdftex.web (pdftex_revision, pdftex_version_string): 1.40.13.\n\n2012-04-12  Thanh Han The  <thanh@river-valley.org>\n\n\t* ttf2afm.c (print_str): new macro, replacing function.\n\t(escape_eol): new fn, replacing print_str, now returning a string.\n\n\t* writettf.c (ttf_reindex_glyphs): use %n to sscanf forms\n\tuniABCD and index123.\n\n\t* mapfile.c (suppress_warn): way to avoid dup warnings.\n\t\n\t* pdftex.web (pdf_suppress_warning_dup_dest_code,\n\tpdf_suppress_warning_dup_dest_code): new primitives\n\t\\pdfsuppresswarningdupdest and \\pdfsuppresswarningdupmap.\n\t(get_pdf_suppress_warning_dup_map): new fn.\n\t(warn_dest_dup): check pdf_suppress_warning_dup_dest.\n\n2012-04-11  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Fixed a typo in TeX text (for e-TeX).\n\n2012-01-18  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writejbig2.c (getstreamlen): Change type to `off_t'.\n\tUse LONGINTEGER_TYPE and LONGINTEGER_PRId for printing.\n\n2012-01-11  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tConsistent support for large JBIG2 files.\n\t* writejbig2.c: Change type of various struct members, local\n\tvariables and findstreamstart() from `long' or `unsigned long'\n\tto `off_t'.  Do not use xfseek and xfseeko for the same file.\n\n2011-12-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Change type of pdf_ptr: longinteger => integer.\n\t* pdftex-common.h: Change type of pdfptr accordingly.\n\n2011-12-15  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils.c (getfiledump): Drop `off_t' cast from arg2 of fseek().\n\t* ttf2afm.c, writettf.c: Typo in comment.\n\n2011-12-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writejbig2.h (removed): Declarations moved ...\n\t* writejbig2.c: ... to here.  Declare most functions as static.\n\t* am/libpdftex.am (libpdftex_a_SOURCES): Remove writejbig2.h.\n\n2011-10-11  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftosrc.cc: Always use new logic for Object Streams\n\t(for xpdf without patch-40-objectStream-support-for-pdftosrc).\n\n2011-09-30  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* wprob.test: New shell script to test for uninitialized line.\n\t* am/pdftex.am: Add the new test.\t\n\n2011-09-30  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftosrc.test: Shell script for a new test.\n\t* tests/test-{13,15}.{pdf,xref} (new): Test input and expected\n\toutput (from Hartmut Henkel <hartmut_henkel@gmx,de>).\n\t* am/pdftosrc.am: Adjust.\n\n2011-07-25  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftoepdf.cc, pdftosrc.cc: #include <assert.h> for both xpdf\n\tand poppler.\n\n2011-07-11  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftosrc.cc: Rewrite the Object Stream handling for poppler\n\t(or xpdf without patch-40-objectStream-support-for-pdftosrc).\n\n\t* pdftoepdf.cc: Replace `#ifdef HAVE_GETPDFMAJORVERSION' by\n\t'#ifdef POPPLER_VERSION' for poppler >= 0.12.\n\n2011-05-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writepng.c: #define PNG_FP_1 for libpng < 1.5.0.\n\n2011-05-11  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writepng.c: Fix for 16bit images in pdf 1.4 (8bit) mode,\n\tfrom Hartmut Henkel.  Expand the png_* macros introduced for\n\tlibpng-1.2.x => 1.4.x => 1.5.x.\n\n2011-05-09  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writepng.c: Fixes for libpng 1.5.2 copied/adapted from luaTeX.\n\n2011-05-05  Karl Berry  <karl@tug.org>\n\n\t* pdftex.web (pdfTeX_banner): etex version before pdftex version.\n\t(pdftex_revision, pdftex_version_string): bump to 12.\n\t* pdftexextra.h (BANNER): change redundantly-specified banner\n\tagain and again.\n\t(These changes approved by Thanh.)\n\n2011-05-03  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web, tex.ch0: Remove pdfeTeX_banner, no more pdfeTeX.\n\n2011-05-02  Akira Kakuto <kakuto@fuk.kindai.ac.jp>  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Append eTeX_version_string to pdfTeX_banner.\n\n2011-05-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tAvoid \"deprecated conversion from string constant to 'char*'\"\n\twarnings from g++-4.4.\n\tUnfortunately both xpdf and poppler declare lots of function\n\tparameters as 'char *' that should actually be 'const char *'.\n\tCompiling just the parts required for TeX Live with g++-4.4\n\tyields >10000 such warnings for each of xpdf and poppler.\n\n\t* pdftoepdf.cc, pdftosrc.cc: Cast string constants to 'char *'\n\tin order to avoid more such warnings when compiling pdfTeX.\n\n2011-04-29  Karl Berry  <karl@tug.org>\n\n\t* all files: update copyright notices.\n\n2011-04-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Adapted to e-TeX Version 2.3.\n\n2011-04-03  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Adapt to ../etexdir/etex.ch: simplify e-pTeX.\n\n\t* am/pdftex.am (etex_version.h): Derive from pdftex.web instead\n\tof ../etexdir/etex.ch.\n\n2011-03-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libpdftex.am: Use AM_CFLAGS instead of libpdftex_a_CFLAGS.\n\t* am/pdftex.am: Use AM_CFLAGS instead of pdftex_CFLAGS.\n\t* am/ttf2afm.am: Use AM_CFLAGS instead of ttf2afm_CFLAGS.\n\n2011-03-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils.c (pdftex_fail, pdftex_warn): `program_invocation_name'\n\thas been renamed into `kpse_invocation_name'.\n\n2011-01-31  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writepng.c: Remove png-1.2 cruft.\n\n2011-01-31  Thomas Klausner  <tk@giga.or.at>\n\n\t* writepng.c: Fix to build with png-1.5 (and avoid `deprecated'\n\twarnings with png-1.4). The transformations part is removed on\n\trecommendation by John Bowler (a png developer).\n\n2011-01-14  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Adapt to ../etexdir/etex.ch:\n\tMention \\protected in error and help messages only when in\n\tin extended mode.\n\n2011-01-11  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.mak, pdftex.mk (removed): Obsolete.\n\n2011-01-08  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am (pdftex_ch_srcs): Added enctex.ch.\n\n2011-01-01  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftexextra.in: Renamed ...\n\t* pdftexextra.h: ... into this; #include {e,pdf}tex_version.h\n\tfor {E,PDF}TEX_VERSION.\n\n\t* pdftexextra.c (new): #include <pdftexd.h> and <lib/texmfmp.c>.\n\n\t* am/pdftex.am: pdftexextra.[ch] are now distributed;\n\tcreate {e,pdf}tex_version.h instead of {e,pdf}tex.version.\n\n2010-12-01  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writet1.c: Drop unreachable code (after pdftex_fail).\n\tDrop unused free_glyph_names() function.\n\n2010-11-29  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writet1.c (t1_check_unusual_charstring): Drop unused variable.\n\n2010-11-26  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writet1.c: Still more minor tweaks.\n\n2010-11-26  Thanh Han The  <thanh@river-valley.org>\n\n\t* writet1.c (t1_check_unusual_charstring): switch EOL to space\n\tbefore appending.\n\n2010-11-26  Heiko Oberdiek  <heiko.oberdiek@googlemail.com>\n\n\t* pdftex.web (Display the whatsit...): avoid erroneous return.\n\thttp://sarovar.org/tracker/?func=detail&group_id=106&aid=4317&atid=493\n\n2010-11-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web (pdf_out_colorstack): There are no 'othercases'.\n\tFix from Heiko Oberdiek <heiko.oberdiek@googlemail.com>.\n\n2010-11-14  Karl Berry  <karl@tug.org>\n\n\t* writet1.c: endless formatting tweaks.\n\n2010-11-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writet1.c (load_enc_file): Bug fix (using glyph_names[256]).\n\n\t* writet1.c: Formatting and other trivial changes, to reduce\n\tdiffs against dvipsk's writet1.c.\n\n2010-11-11  Thanh Han The  <thanh@river-valley.org>\n\n\t* writet1.c (t1_check_unusual_charstring): new fn.\n\t(t1_subset_charstrings): call it.  This resolves a bug reported by\n\tKnuth when there is a newline between the /CharStrings and the\n\tfollowing number (dict size).\n\n2010-09-29  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writeimg.c: Use png_get_*() instead of directly accessing\n\tfields of the png_info and png_ptr structs.\n\n2010-09-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.test (new): Just testing 'pdftex -version'.\n\t* pdftexdir/am/pdftex.am: Adjusted.\n\n2010-06-22  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tPrepare for libpng-1.4.x.\n\t* writepng.c: Define and use macros to access bit_depth and the\n\tother fields of the png_info and png_ptr structs.\n\n2010-06-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am (pdftex_cppflags): Add $(AM_CPPFLAGS).\n\t* am/ttf2afm.am (ttf2afm_CPPFLAGS): Add $(AM_CPPFLAGS).\n\n2010-06-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tReorganize web2c headers.\n\t* pdftoepdf.cc: #include <w2c/c-auto.h> instead of <c-auto.h>\n\tand <w2c/config.h> instead of \"../config.h\".\n\n2010-06-07  Karl Berry  <karl@tug.org>\n\n\t* pdftex.web: (pdftex_version_string): let's be optimistic and\n\t drop the -beta.\n\n2010-05-20  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftoepdf.cc: #include \"../config.h\" instead of <config.h>,\n\trequired for Mac OS X Leopard.\n\n2010-05-18  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Adapt to ../etexdir/etex.ch:\n\tMore error message with \\protected, from Heiko.\n\n2010-04-30  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex-common.h (xstrdup): Remove decl (in <kpathsea/lib.h>).\n\t(pdfosmode): Declare as boolean as generated by Web2C.\n\t* pdftoepdf.h (deleted): Moved contents ...\n\t* pdftoepdf.cc: ... to here.\n\t#include \"openbsd-compat.h\" as early as possible.\n\tAdd #include <kpathsea/lib.h> and drop decl of const_string.\n\tAvoid MINGW32's typedef of boolean, conflicting with the\n\tdefinition in <kpathsea/types.h>.\n\t* am/libpdftex.am: Adjusted.\n\n\t* pdftex-common.h, writeimg.c (epdf_selected_page,\n\tepdf_num_pages, epdf_page_box): Change from integer to int.\n\t* pdftoepdf.cc: Remove '(int)' casts.\n\n2010-04-29  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* epdf.c, pdftoepdf.cc, writeenc.c: Change various function\n\tparams, return values, and struct members from integer to int.\n\n\tAvoid duplicate function prototypes in different headers.\n\t* epdf.c: Drop #include \"inc-epdf.h\".\n\t* inc-extra.h (deleted): Move prototypes ...\n\t* ptexlib.h: #include \"pdftex-common.h\", move some prototypes ...\n\t* epdf.h: #include \"pdftex-common.h\" instead of \"inc-epdf.h\" and\n\t\"inc-extra.h\", \tmove some prototypes ...\n\t* image.h: Move some prototypes ...\n\t* pdftex-common.h (new): ... to here.\n\n\t* epdf.h (deleted): Renamed ...\n\t* pdftoepdf.h (new): ... into this.\n\t* pdftex.web (pdf_last_byte): Changed type to eight_bits.\n\t* pdftoepdf.cc (notdef): Added (char *) cast.\n\t* pdftoepdf.h, ptexlib.h: Moved declarations from here ...\n\t* pdftex-common.h: ... to here, dropped a few unused ones.\n\t* am/libpdftex.am: Adjusted.\n\n\t* pdftex-common.h: #define pdfosgetosbuf and pdfbeginobj as\n\tin pdftexcoerce.h (generated by Web2C).\n\t* pdftoepdf.cc: Use pdfbeginobj instead of zpdfbeginobj.\n\t* ptexmac.h: Use pdfosgetosbuf instead of zpdfosgetosbuf.\n\n2010-04-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Adapt to ../etexdir/etex.ch:\n\tFixed the error message for improper use of \\protected,\n\treported by Heiko Oberdiek <heiko.oberdiek@googlemail.com>.\n\n2010-04-23  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* epdf.h: #include <c-auto.h> instead of <web2c/c-auto.h> etc.\n\n2010-04-22  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am (EXTRA_DIST): Add etexdir/etex.ch.\n\tUse pdftexdir/etex.version instead of etexdir/etex.version.\n\n2010-04-20  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* ptexlib.h: Move extern declaration of ptexbanner to here\n\tfrom ../lib/lib.h (instatiated in ../lib/texmfmp.c).\n\n2010-03-09  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* ttf2afm.c: Use kpse_set_program_name(argv[0], NULL) instead of\n\tkpse_set_progname(argv[0]).\n\n2010-02-14  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writet1.c (append_cs_return): Cast to byte * to avoid warning.\n\n2010-02-01  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libpdftex.am (libpdftex_a_OBJECTS): Add dependency on\n\t$(ZLIB_DEPEND) and $(LIBPNG_DEPEND).\n\t* am/pdftex.am (pdftex_OBJECTS): Remove explicit dependency on\n\t$(ZLIB_DEPEND) alread implied by libpdftex.a.\n\n2010-01-27  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* avl.c (avl_copy): Proper handling of const.\n\n2010-01-25  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libpdftex.am (libpdftex_a_CFLAGS): Enable compiler warnings.\n\n\tAvoid most compiler warnings:\n\n\t* ptexlib.h, writejbig2.h: ANSI C function prototypes.\n\t* avlstuff.c, mapfile.c, utils.c, vfpacket.c, writeenc.c,\n\twritefont.c, writeimg.c, writejbig2.c, writet1.c, writettf.c:\n\tANSI C function definitions.\n\n\t* avlstuff.c, mapfile.c, utils.c, writeenc.c, writefont.c,\n\twritejbig2.c, writepng.c, writet1.c, writettf.c: Declare\n\tfunctions as static.\n\n\t* ptexlib.h: Add prototype for imagecolor().\n\t* inc-epdf.h: New file with prototypes for is_subsetable(),\n\tepdf_check_mem(), epdf_create_fontdescriptor(),\n\tepdf_mark_glyphs(), get_fd_objnum(), get_fn_objnum(), and\n\tembed_whole_font() ...\n\t* epdf.[ch]: ... removed from here.\n\t* epdf.[ch]: #include \"inc-epdf.h\".\n\t* inc-extra.h: New file with prototypes for stripzeros() and\n\tepdf_write_enc() ...\n\t* epdf.h: ... removed from here.\n\t* epdf.c, utils.c, writeenc.c: #include \"inc-extra.h\".\n\t* am/libpdftex.am (libpdftex_a_SOURCES): Add the new files.\n\n\t* writejbig2.c: Avoid use of possibly uninitialized variables.\n\n\t* utils.c, writefont.c, writet1.c, writettf.c:\n\tDeclare various function params and args, local vars, and struct\n\tmembers as const.\n\n\t* writet1.c (append_cs_return): Drop unused local variable 'k'.\n\n\t* avlstuff.c (destroy_oentry, PdfObjTree_free),\n\twritet1.c (free_glyph_names):\n\tSkip unused static functions (via #if 0 ... #endif).\n\n\t* utils.c (newcolorstack): Don't use value of xretalloc(),\n\txretalloc(addr, n, t) already assigns the new pointer to addr.\n\n\t* avl.c (avl_delete): Don't reuse const input param for\n\tnon-const return value.\n\n2010-01-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libpdftex.am: Add dependency on $(XPDF_DEPEND).\n\t* am/pdftosrc.am: Remove dependency on libpdftex.a.\n\n2010-01-18  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* epdf.c: Remove extern delaration of register_fd_entry().\n\t* pkin.c: Remove extern delaration of t3_file.\n\t* writet1.c: Remove extern delaration of fb_array.\n\t* writettf.c: Remove extern delarations of fb_array and\n\tcharsetstr.\n\t* ptexlib.h: Add extern delarations of fb_array, t3_file, and\n\tregister_fd_entry().\n\n2009-12-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am: Replace the obsolete $(mkdir_p) by $(MKDIR_P).\n\n2009-12-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils.c: Drop #ifdef HAVE_ASPRINTF and #include <stdio.h>.\n\n2009-12-01  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* NEWS, README: Update to version 3.1415926-1.40.10.\n\n2009-10-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftoepdf.cc: Adapt to poppler-0.12.\n\n\t* FIXME: epdf.h, ptexlib.h: Multiple prototypes for pdftex_fail,\n\tpdftex_warn, and probably others.\n\n2009-10-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am, am/ttf2afm.am: Enable compiler warnings.\n\n\t* mapfile.c, ptexlib.h: Declare pdfinitmapfile() param string\n\tas const.\n\t* pdftex.ch (get_strings_started): Drop unused variables.\n\t* ttf2afm.c: All functions: ANSI C definition, declare as static.\n\t(ttf_fail): Declare as noreturn.\n\t(ttf_fail, ttf_warn, name_lookup, ttf_seek_tab, ttf_seek_off):\n\tDeclare param strings as const.\n\t(get_kern_value): Comment out unused function.\n\n2009-10-04  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.ch (do_extension): Recover variables unused by TeX.\n\n2009-09-16  Han The Thanh <hanthethanh@gmail.com>\n\n\t* writettf.c: patch for TTC from Liu Yubao <yubao.liu@gmail.com>\n\n2009-09-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am: Adapt to new makecpool with one argument.\n\n2009-09-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libpdftex.am, am/pdftosrc.am: Prepare compiler warnings.\n\n2009-08-20  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils.c: #include <kpathsea/version.h> and drop extern decls.\n\n2009-08-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/ttf2afm.am (ttf2afm_DEPENDENCIES): Use default_dependencies.\n\n2009-08-18  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am: SyncTeX now integrated into ../texmfmp.h.\n\n2009-08-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am (pdf_tangle): Use tangle-sh.\n\tAdapt to tangle-sh and web2c-sh.\n\n2009-08-13  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am (pdftex_c_h): avoid to split the C code.\n\n2009-08-12  Karl Berry  <karl@tug.org>\n\n\t* pdftex.web (sup_dest_names_size): increase to 500000;\n\ttest document from Peter Abbott to Karl, 12 Aug 2009 12:24:43.\n\n2009-07-13  Han The Thanh <hanthethanh@gmail.com>\n\n\t* mapfile.c: treat TTC fonts as TTF\n\t* writejpg.c: fix bitmap resolution\n\t* writettf.c: fix segfault for certain TTF fonts\n\t* pdftex.web: enable pk generation by default\n\n2009-06-26  Han The Thanh <hanthethanh@gmail.com>\n\n\t* pdftex.web: bugfix from Hartmut: fix \\pdfobj file {foo} for files\n\t          foo that don't end with '\\n'\n\n2009-06-25  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* epdf.h, ttf2afm.c, writet1.c:\n\tremoved #include <kpathsea/c-proto.h>.\n\t* avlstuff.c, epdf.c: removed #include <kpathsea/c-proto.h> and\n\t#include <stdarg.h>.\n\n2009-06-23  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* avlstuff.c, epdf.c, ttf2afm.c, writet1.c: #include <stdarg.h>,\n\tnot <kpathsea/c-vararg.h>.\n\n2009-06-04  Karl Berry  <karl@tug.org>\n\n\t* am/pdftex.am (pdftex_LDADD): add libpdftex.a here.\n\t(pdftex_ldadd): remove it from here, so we do not try\n\tto link pdftosrc with it.\n\tReport from vvv, tlbuild mail 03 Jun 2009 21:45:00.\n\n2009-05-07  Norbert Preining <preining@logic.at>\n\n\t* pdftosrc.cc: add warning that poppler version doesn't support\n\tobject streams.\n\n2009-05-05  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* pdftoepdf.cc, pdftosrc.cc, utils.c: adapt for poppler.\n\n\tpatches from Norbert Preining <preining@logic.at>\n\n2009-02-18  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* pdftoepdf.cc: Uninclude <config.h>, included later by \"epdf.h\".\n\n2004-08-21  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* pdfetex.ch2: Adapted to e-TeX version 2.2.\n\n2004-08-26  Olaf Weber  <olaf@infovore.xs4all.nl>\n\n\t* pdfetexextra.in: File was renamed from pdftexextra.h; the\n\tcurrent pdfTeX and e-TeX versions are substituted from\n\t../pdftexdir/pdftex.version and ../etexdir/etex.version.  Variant\n\tof code supplied by Peter Breitenlohner <peb@mppmu.mpg.de>.\n\n\t* pdfetex.mk: Added rule to insert pdfTeX and e-TeX versions into\n\tpdfetexextra.h.  Variant of code supplied by Peter Breitenlohner\n\t<peb@mppmu.mpg.de>.\n\n2004-08-25  Olaf Weber  <olaf@infovore.xs4all.nl>\n\n\t* pdfetex.mk: vadjust.ch moved from pdfxtexdir to pdftexdir.\n\n2004-08-17  Olaf Weber  <olaf@infovore.xs4all.nl>\n\n\t* pdfetex.mk: Resurrected etex.fix, there is again a need to\n\tinclude late-breaking changes.\n\n2004-07-29  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* pdfetex.ch[12]: Somewhat rearrange handling of kern and math\n\tnodes in order to reduce interference between eTeX and pdfTeX\n\tchange files.\n\n\t* pdfetex.ch1 (hlist_out): Keep full mixed direction typesetting\n\tcode.\n\n2004-07-25  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* pdfetex.ch[12]: Reorganize additional command codes for convert\n\tand last_item in order to reduce interference between eTeX and\n\tpdfTeX change files.\n\n2004-07-23  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* pdfetex.ch[12], tex.ch[01]: Reorganize handling of banner\n\tstring in order to reduce interference between eTeX, pdfTeX,\n\tand web2c change files.\n\n2004-07-22  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* pdfetex.ch[12]: Removed unused token types for pdfTeX's\n\tadditional token list parameters.\n\n2004-07-19  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* pdfetex.ch[12], tex.ch0: Reorganize handling of additional\n\ttoken list and integer parameters and e-TeX's additional\n\tpenalties in order to reduce interference between eTeX, pdfTeX,\n\tand web2c change files.\n\n\t* pdfetex.mk (pdfetex.ch): Remove tex.ch2 from build rules.\n\n\t* tex.ch2: Removed.\n\n2004-07-17  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* pdfetex.mk: Rewrite build rules for pdfetex.{web,ch},\n\tremove etex.{ch0,ch1,fix}, tex.ch2, and several non-dependencies.\n\n\t* pdfetex.ch2: Adapt to eTeX changes.\n\n\t* ChangeLog: New file.\n\n(This file public domain.)\n", "/*\nCopyright 1996-2014 Han The Thanh <thanh@pdftex.org>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see  <http://www.gnu.org/licenses/>.  */\n\n#include \"ptexlib.h\"\n#include <stdarg.h>\n#include <string.h>\n\n#define t1_log(str)      tex_printf(\"%s\",str)\n#define get_length1()    t1_length1 = t1_offset() - t1_save_offset\n#define get_length2()    t1_length2 = t1_offset() - t1_save_offset\n#define get_length3()    t1_length3 = fixedcontent? t1_offset() - t1_save_offset : 0\n#define save_offset()    t1_save_offset = t1_offset()\n\n#define t1_open()        open_input(&t1_file, kpse_type1_format, FOPEN_RBIN_MODE)\n#define t1_close()       xfclose(t1_file, cur_file_name)\n#define t1_getchar()     getc(t1_file)\n#define t1_putchar       fb_putchar\n#define t1_offset        fb_offset\n#define t1_ungetchar(c)  ungetc(c, t1_file)\n#define t1_eof()         feof(t1_file)\n\n#define t1_prefix(s)     str_prefix(t1_line_array, s)\n#define t1_buf_prefix(s) str_prefix(t1_buf_array, s)\n#define t1_suffix(s)     str_suffix(t1_line_array, t1_line_ptr, s)\n#define t1_buf_suffix(s) str_suffix(t1_buf_array, t1_buf_ptr, s)\n#define t1_charstrings() strstr(t1_line_array, charstringname)\n#define t1_subrs()       t1_prefix(\"/Subrs\")\n#define t1_end_eexec()   t1_suffix(\"mark currentfile closefile\")\n#define t1_cleartomark() t1_prefix(\"cleartomark\")\n\n#define enc_open()       open_input(&enc_file, kpse_enc_format, FOPEN_RBIN_MODE)\n#define enc_close()      xfclose(enc_file, cur_file_name)\n#define enc_getchar()    getc(enc_file)\n#define enc_eof()        feof(enc_file)\n\n#define valid_code(c)    (c >= 0 && c < 256)\n#define fixedcontent     false /* false for pdfTeX, true for dvips */\n\nstatic const char *standard_glyph_names[256] = {\n    /* 0x00 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0x10 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0x20 */\n    \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\",\n    \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\", \"asterisk\",\n    \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\",\n    /* 0x30 */\n    \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\",\n    \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\",\n    /* 0x40 */\n    \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\",\n    \"O\",\n    /* 0x50 */\n    \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\",\n    \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\",\n    /* 0x60 */\n    \"quoteleft\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\",\n    \"m\", \"n\", \"o\",\n    /* 0x70 */\n    \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\",\n    \"braceright\", \"asciitilde\", notdef,\n    /* 0x80 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0x90 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0xa0 */\n    notdef, \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\", \"florin\",\n    \"section\", \"currency\", \"quotesingle\", \"quotedblleft\", \"guillemotleft\",\n    \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\",\n    /* 0xb0 */\n    notdef, \"endash\", \"dagger\", \"daggerdbl\", \"periodcentered\", notdef,\n    \"paragraph\", \"bullet\", \"quotesinglbase\", \"quotedblbase\",\n    \"quotedblright\", \"guillemotright\", \"ellipsis\", \"perthousand\", notdef,\n    \"questiondown\",\n    /* 0xc0 */\n    notdef, \"grave\", \"acute\", \"circumflex\", \"tilde\", \"macron\", \"breve\",\n    \"dotaccent\", \"dieresis\", notdef,\n    \"ring\", \"cedilla\", notdef, \"hungarumlaut\", \"ogonek\", \"caron\",\n    /* 0xd0 */\n    \"emdash\", notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0xe0 */\n    notdef, \"AE\", notdef, \"ordfeminine\", notdef, notdef, notdef, notdef,\n    \"Lslash\", \"Oslash\", \"OE\", \"ordmasculine\", notdef, notdef, notdef,\n    notdef,\n    /* 0xf0 */\n    notdef, \"ae\", notdef, notdef, notdef, \"dotlessi\", notdef, notdef, \"lslash\",\n    \"oslash\", \"oe\", \"germandbls\", notdef, notdef, notdef, notdef\n};\n\ninteger t1_length1, t1_length2, t1_length3;\nstatic integer t1_save_offset;\nstatic integer t1_fontname_offset;\nstatic fd_entry *fd_cur;\n\nstatic char charstringname[] = \"/CharStrings\";\n\nenum { ENC_STANDARD, ENC_BUILTIN } t1_encoding;\n\n#define T1_BUF_SIZE      0x10\n#define ENC_BUF_SIZE     0x1000\n\n#define CS_HSTEM         1\n#define CS_VSTEM         3\n#define CS_VMOVETO       4\n#define CS_RLINETO       5\n#define CS_HLINETO       6\n#define CS_VLINETO       7\n#define CS_RRCURVETO     8\n#define CS_CLOSEPATH     9\n#define CS_CALLSUBR      10\n#define CS_RETURN        11\n#define CS_ESCAPE        12\n#define CS_HSBW          13\n#define CS_ENDCHAR       14\n#define CS_RMOVETO       21\n#define CS_HMOVETO       22\n#define CS_VHCURVETO     30\n#define CS_HVCURVETO     31\n#define CS_1BYTE_MAX     (CS_HVCURVETO + 1)\n\n#define CS_DOTSECTION    CS_1BYTE_MAX + 0\n#define CS_VSTEM3        CS_1BYTE_MAX + 1\n#define CS_HSTEM3        CS_1BYTE_MAX + 2\n#define CS_SEAC          CS_1BYTE_MAX + 6\n#define CS_SBW           CS_1BYTE_MAX + 7\n#define CS_DIV           CS_1BYTE_MAX + 12\n#define CS_CALLOTHERSUBR CS_1BYTE_MAX + 16\n#define CS_POP           CS_1BYTE_MAX + 17\n#define CS_SETCURRENTPOINT CS_1BYTE_MAX + 33\n#define CS_2BYTE_MAX     (CS_SETCURRENTPOINT + 1)\n#define CS_MAX           CS_2BYTE_MAX\n\ntypedef unsigned char byte;\n\ntypedef struct {\n    byte nargs;                 /* number of arguments */\n    boolean bottom;             /* take arguments from bottom of stack? */\n    boolean clear;              /* clear stack? */\n    boolean valid;\n} cc_entry;                     /* CharString Command */\n\ntypedef struct {\n    char *name;                 /* glyph name (or notdef for Subrs entry) */\n    byte *data;\n    unsigned short len;         /* length of the whole string */\n    unsigned short cslen;       /* length of the encoded part of the string */\n    boolean used;\n    boolean valid;\n} cs_entry;\n\nstatic unsigned short t1_dr, t1_er;\nstatic const unsigned short t1_c1 = 52845, t1_c2 = 22719;\nstatic unsigned short t1_cslen;\nstatic short t1_lenIV;\nstatic char enc_line[ENC_BUF_SIZE];\n\n/* define t1_line_ptr, t1_line_array & t1_line_limit */\ntypedef char t1_line_entry;\ndefine_array(t1_line);\n\n/* define t1_buf_ptr, t1_buf_array & t1_buf_limit */\ntypedef char t1_buf_entry;\ndefine_array(t1_buf);\n\nstatic int cs_start;\n\nstatic cs_entry *cs_tab, *cs_ptr, *cs_notdef;\nstatic char *cs_dict_start, *cs_dict_end;\nstatic int cs_count, cs_size, cs_size_pos;\n\nstatic cs_entry *subr_tab;\nstatic char *subr_array_start, *subr_array_end;\nstatic int subr_max, subr_size, subr_size_pos;\n\n/* This list contains the begin/end tokens commonly used in the */\n/* /Subrs array of a Type 1 font.                               */\n\nstatic const char *cs_token_pairs_list[][2] = {\n    {\" RD\", \"NP\"},\n    {\" -|\", \"|\"},\n    {\" RD\", \"noaccess put\"},\n    {\" -|\", \"noaccess put\"},\n    {NULL, NULL}\n};\nstatic const char **cs_token_pair;\n\nstatic boolean t1_pfa, t1_cs, t1_scan, t1_eexec_encrypt, t1_synthetic;\nstatic int t1_in_eexec;         /* 0 before eexec-encrypted, 1 during, 2 after */\nstatic long t1_block_length;\nstatic int last_hexbyte;\nstatic FILE *t1_file;\nstatic FILE *enc_file;\n\nstatic void enc_getline(void)\n{\n    char *p;\n    int c;\n  restart:\n    if (enc_eof())\n        pdftex_fail(\"unexpected end of file\");\n    p = enc_line;\n    do {\n        c = enc_getchar();\n        append_char_to_buf(c, p, enc_line, ENC_BUF_SIZE);\n    } while (c != 10);\n    append_eol(p, enc_line, ENC_BUF_SIZE);\n    if (p - enc_line < 2 || *enc_line == '%')\n        goto restart;\n}\n\n/* read encoding from .enc file, return glyph_names array, or pdffail() */\n\nchar **load_enc_file(char *enc_name)\n{\n    char buf[ENC_BUF_SIZE], *p, *r;\n    int i, names_count;\n    char **glyph_names;\n    set_cur_file_name(enc_name);\n    if (!enc_open()) {\n        pdftex_fail(\"cannot open encoding file for reading\");\n    }\n    glyph_names = xtalloc(256, char *);\n    for (i = 0; i < 256; i++)\n        glyph_names[i] = notdef;\n    t1_log(\"{\");\n    t1_log(cur_file_name = (char *) nameoffile + 1);\n    enc_getline();\n    if (*enc_line != '/' || (r = strchr(enc_line, '[')) == NULL) {\n        remove_eol(r, enc_line);\n        pdftex_fail\n           (\"invalid encoding vector (a name or `[' missing): `%s'\", enc_line);\n    }\n    names_count = 0;\n    r++;                        /* skip '[' */\n    skip(r, ' ');\n    for (;;) {\n        while (*r == '/') {\n            for (p = buf, r++;\n                 *r != ' ' && *r != 10 && *r != ']' && *r != '/'; *p++ = *r++);\n            *p = 0;\n            skip(r, ' ');\n            if (names_count > 255)\n                pdftex_fail(\"encoding vector contains more than 256 names\");\n            if (strcmp(buf, notdef) != 0)\n                glyph_names[names_count] = xstrdup(buf);\n            names_count++;\n        }\n        if (*r != 10 && *r != '%') {\n            if (str_prefix(r, \"] def\"))\n                goto done;\n            else {\n                remove_eol(r, enc_line);\n                pdftex_fail\n       (\"invalid encoding vector: a name or `] def' expected: `%s'\", enc_line);\n            }\n        }\n        enc_getline();\n        r = enc_line;\n    }\n  done:\n    enc_close();\n    t1_log(\"}\");\n    cur_file_name = NULL;\n    return glyph_names;\n}\n\nstatic void t1_check_pfa(void)\n{\n    const int c = t1_getchar();\n    t1_pfa = (c != 128) ? true : false;\n    t1_ungetchar(c);\n}\n\nstatic int t1_getbyte(void)\n{\n    int c = t1_getchar();\n    if (t1_pfa)\n        return c;\n    if (t1_block_length == 0) {\n        if (c != 128)\n            pdftex_fail(\"invalid marker\");\n        c = t1_getchar();\n        if (c == 3) {\n            while (!t1_eof())\n                t1_getchar();\n            return EOF;\n        }\n        t1_block_length = t1_getchar() & 0xff;\n        t1_block_length |= (t1_getchar() & 0xff) << 8;\n        t1_block_length |= (t1_getchar() & 0xff) << 16;\n        t1_block_length |= (t1_getchar() & 0xff) << 24;\n        c = t1_getchar();\n    }\n    t1_block_length--;\n    return c;\n}\n\nstatic int hexval(int c)\n{\n    if (c >= 'A' && c <= 'F')\n        return c - 'A' + 10;\n    else if (c >= 'a' && c <= 'f')\n        return c - 'a' + 10;\n    else if (c >= '0' && c <= '9')\n        return c - '0';\n    else\n        return -1;\n}\n\nstatic byte edecrypt(byte cipher)\n{\n    byte plain;\n    if (t1_pfa) {\n        while (cipher == 10 || cipher == 13)\n            cipher = t1_getbyte();\n        last_hexbyte = cipher = (hexval(cipher) << 4) + hexval(t1_getbyte());\n    }\n    plain = (cipher ^ (t1_dr >> 8));\n    t1_dr = (cipher + t1_dr) * t1_c1 + t1_c2;\n    return plain;\n}\n\nstatic byte cdecrypt(byte cipher, unsigned short *cr)\n{\n    const byte plain = (cipher ^ (*cr >> 8));\n    *cr = (cipher + *cr) * t1_c1 + t1_c2;\n    return plain;\n}\n\nstatic byte eencrypt(byte plain)\n{\n    const byte cipher = (plain ^ (t1_er >> 8));\n    t1_er = (cipher + t1_er) * t1_c1 + t1_c2;\n    return cipher;\n}\n\nstatic byte cencrypt(byte plain, unsigned short *cr)\n{\n    const byte cipher = (plain ^ (*cr >> 8));\n    *cr = (cipher + *cr) * t1_c1 + t1_c2;\n    return cipher;\n}\n\nstatic char *eol(char *s)\n{\n    char *p = strend(s);\n    if (p - s > 1 && p[-1] != 10) {\n        *p++ = 10;\n        *p = 0;\n    }\n    return p;\n}\n\nstatic float t1_scan_num(char *p, char **r)\n{\n    float f;\n    skip(p, ' ');\n    if (sscanf(p, \"%g\", &f) != 1) {\n        remove_eol(p, t1_line_array);\n        pdftex_fail(\"a number expected: `%s'\", t1_line_array);\n    }\n    if (r != NULL) {\n        for (; isdigit((unsigned char)*p) || *p == '.' ||\n             *p == 'e' || *p == 'E' || *p == '+' || *p == '-'; p++);\n        *r = p;\n    }\n    return f;\n}\n\nstatic boolean str_suffix(const char *begin_buf, const char *end_buf,\n                          const char *s)\n{\n    const char *s1 = end_buf - 1, *s2 = strend(s) - 1;\n    if (*s1 == 10)\n        s1--;\n    while (s1 >= begin_buf && s2 >= s) {\n        if (*s1-- != *s2--)\n            return false;\n    }\n    return s2 < s;\n}\n\nstatic void t1_getline(void)\n{\n    int c, l, eexec_scan;\n    char *p;\n    static const char eexec_str[] = \"currentfile eexec\";\n    static int eexec_len = 17;  /* strlen(eexec_str) */\n  restart:\n    if (t1_eof())\n        pdftex_fail(\"unexpected end of file\");\n    t1_line_ptr = t1_line_array;\n    alloc_array(t1_line, 1, T1_BUF_SIZE);\n    t1_cslen = 0;\n    eexec_scan = 0;\n    c = t1_getbyte();\n    if (c == EOF)\n        goto exit;\n    while (!t1_eof()) {\n        if (t1_in_eexec == 1)\n            c = edecrypt((byte)c);\n        alloc_array(t1_line, 1, T1_BUF_SIZE);\n        append_char_to_buf(c, t1_line_ptr, t1_line_array, t1_line_limit);\n        if (t1_in_eexec == 0 && eexec_scan >= 0 && eexec_scan < eexec_len) {\n            if (t1_line_array[eexec_scan] == eexec_str[eexec_scan])\n                eexec_scan++;\n            else\n                eexec_scan = -1;\n        }\n        if (c == 10 || (t1_pfa && eexec_scan == eexec_len && c == 32))\n            break;\n        if (t1_cs && t1_cslen == 0 && (t1_line_ptr - t1_line_array > 4) &&\n            (t1_suffix(\" RD \") || t1_suffix(\" -| \"))) {\n            p = t1_line_ptr - 5;\n            while (*p != ' ')\n                p--;\n            t1_cslen = l = t1_scan_num(p + 1, 0);\n            cs_start = t1_line_ptr - t1_line_array;     /* cs_start is an index now */\n            alloc_array(t1_line, l, T1_BUF_SIZE);\n            while (l-- > 0)\n                *t1_line_ptr++ = edecrypt((byte)t1_getbyte());\n        }\n        c = t1_getbyte();\n    }\n    alloc_array(t1_line, 2, T1_BUF_SIZE);       /* append_eol can append 2 chars */\n    append_eol(t1_line_ptr, t1_line_array, t1_line_limit);\n    if (t1_line_ptr - t1_line_array < 2)\n        goto restart;\n    if (eexec_scan == eexec_len)\n        t1_in_eexec = 1;\n  exit:\n    /* ensure that t1_buf_array has as much room as t1_line_array */\n    t1_buf_ptr = t1_buf_array;\n    alloc_array(t1_buf, t1_line_limit, t1_line_limit);\n}\n\nstatic void t1_putline(void)\n{\n    char *p = t1_line_array;\n    if (t1_line_ptr - t1_line_array <= 1)\n        return;\n    if (t1_eexec_encrypt) {\n        while (p < t1_line_ptr)\n            t1_putchar(eencrypt(*p++));\n    } else\n        while (p < t1_line_ptr)\n            t1_putchar(*p++);\n}\n\nstatic void t1_puts(const char *s)\n{\n    if (s != t1_line_array)\n        strcpy(t1_line_array, s);\n    t1_line_ptr = strend(t1_line_array);\n    t1_putline();\n}\n\n__attribute__ ((format(printf, 1, 2)))\nstatic void t1_printf(const char *fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    vsprintf(t1_line_array, fmt, args);\n    t1_puts(t1_line_array);\n    va_end(args);\n}\n\nstatic void t1_init_params(const char *open_name_prefix)\n{\n    t1_log(open_name_prefix);\n    t1_log(cur_file_name);\n    t1_lenIV = 4;\n    t1_dr = 55665;\n    t1_er = 55665;\n    t1_in_eexec = 0;\n    t1_cs = false;\n    t1_scan = true;\n    t1_synthetic = false;\n    t1_eexec_encrypt = false;\n    t1_block_length = 0;\n    t1_check_pfa();\n}\n\nstatic void t1_close_font_file(const char *close_name_suffix)\n{\n    t1_log(close_name_suffix);\n    t1_close();\n    cur_file_name = NULL;\n}\n\nstatic void t1_check_block_len(boolean decrypt)\n{\n    int l, c;\n    if (t1_block_length == 0)\n        return;\n    c = t1_getbyte();\n    if (decrypt)\n        c = edecrypt((byte)c);\n    l = t1_block_length;\n    if (!(l == 0 && (c == 10 || c == 13))) {\n        pdftex_fail(\"%i bytes more than expected\", l + 1);\n    }\n}\n\nstatic void t1_start_eexec(void)\n{\n    int i;\n    assert(is_included(fd_cur->fm));\n    get_length1();\n    save_offset();\n    if (!t1_pfa)\n        t1_check_block_len(false);\n    for (t1_line_ptr = t1_line_array, i = 0; i < 4; i++) {\n        edecrypt((byte)t1_getbyte());\n        *t1_line_ptr++ = 0;\n    }\n    t1_eexec_encrypt = true;\n    t1_putline();               /* to put the first four bytes */\n}\n\nstatic void t1_stop_eexec(void)\n{\n    int c;\n    assert(is_included(fd_cur->fm));\n    get_length2();\n    save_offset();\n    t1_eexec_encrypt = false;\n    if (!t1_pfa)\n        t1_check_block_len(true);\n    else {\n        c = edecrypt((byte)t1_getbyte());\n        if (!(c == 10 || c == 13)) {\n            if (last_hexbyte == 0)\n                t1_puts(\"00\");\n            else\n                pdftex_fail(\"unexpected data after eexec\");\n        }\n    }\n    t1_cs = false;\n    t1_in_eexec = 2;\n}\n\n/* macros for various transforms; currently only slant and extend are used */\n\n#define do_xshift(x,a) {x[4]+=a;}\n#define do_yshift(x,a) {x[5]+=a;}\n#define do_xscale(x,a) {x[0]*=a; x[2]*=a; x[4]*=a;}\n#define do_yscale(x,a) {x[1]*=a; x[3]*=a; x[5]*=a;}\n#define do_extend(x,a) {do_xscale(x,a);}\n#define do_scale(x,a)  {do_xscale(x,a); do_yscale(x,a);}\n#define do_slant(x,a)  {x[0]+=x[1]*(a); x[2]+=x[3]*(a); x[4]+=x[5]*(a);}\n#define do_shear(x,a)  {x[1]+=x[0]*(a); x[3]+=x[2]*(a); x[5]+=x[4]*(a);}\n#define do_rotate(x,a)          \\\n  {float t, u=cos(a), v=sin(a); \\\n  t    =x[0]*u+x[1]*-v;         \\\n  x[1] =x[0]*v+x[1]* u; x[0]=t; \\\n  t    =x[2]*u+x[3]*-v;         \\\n  x[3] =x[2]*v+x[3]* u; x[2]=t; \\\n  t    =x[4]*u+x[5]*-v;         \\\n  x[5] =x[4]*v+x[5]* u; x[4]=t;}\n\nstatic void t1_modify_fm(void)\n{\n    /*\n     * font matrix is given as six numbers a0..a5, which stands for the matrix\n     *\n     *           a0 a1 0\n     *     M =   a2 a3 0\n     *           a4 a5 1\n     *\n     * ExtendFont is given as\n     *\n     *           e 0 0\n     *     E =   0 1 0\n     *           0 0 1\n     *\n     * SlantFont is given as\n     *\n     *           1 0 0\n     *     S =   s 1 0\n     *           0 0 1\n     *\n     * The slant transform must be done _before_ the extend transform\n     * for compatibility!\n     */\n    float a[6];\n    int i, c;\n    char *p, *q, *r;\n    if ((p = strchr(t1_line_array, '[')) == 0)\n        if ((p = strchr(t1_line_array, '{')) == 0) {\n            remove_eol(p, t1_line_array);\n            pdftex_fail(\"FontMatrix: an array expected: `%s'\", t1_line_array);\n        }\n    c = *p++;                   /* save the character '[' resp. '{' */\n    strncpy(t1_buf_array, t1_line_array, (size_t) (p - t1_line_array));\n    r = t1_buf_array + (p - t1_line_array);\n    for (i = 0; i < 6; i++) {\n        a[i] = t1_scan_num(p, &q);\n        p = q;\n    }\n    if (fm_slant(fd_cur->fm) != 0)\n        do_slant(a, fm_slant(fd_cur->fm) * 1E-3);\n    if (fm_extend(fd_cur->fm) != 0)\n        do_extend(a, fm_extend(fd_cur->fm) * 1E-3);\n    for (i = 0; i < 6; i++) {\n        sprintf(r, \"%g \", a[i]);\n        r = strend(r);\n    }\n    if (c == '[') {\n        while (*p != ']' && *p != 0)\n            p++;\n    } else {\n        while (*p != '}' && *p != 0)\n            p++;\n    }\n    if (*p == 0) {\n        remove_eol(p, t1_line_array);\n        pdftex_fail\n            (\"FontMatrix: cannot find the corresponding character to '%c': `%s'\",\n             c, t1_line_array);\n    }\n    strcpy(r, p);\n    strcpy(t1_line_array, t1_buf_array);\n    t1_line_ptr = eol(t1_line_array);\n}\n\nstatic void t1_modify_italic(void)\n{\n    float a;\n    char *p, *r;\n    if (fm_slant(fd_cur->fm) == 0)\n        return;\n    p = strchr(t1_line_array, ' ');\n    strncpy(t1_buf_array, t1_line_array, (size_t) (p - t1_line_array + 1));\n    a = t1_scan_num(p + 1, &r);\n    a -= atan(fm_slant(fd_cur->fm) * 1E-3) * (180 / M_PI);\n    sprintf(t1_buf_array + (p - t1_line_array + 1), \"%g\", a);\n    strcpy(strend(t1_buf_array), r);\n    strcpy(t1_line_array, t1_buf_array);\n    t1_line_ptr = eol(t1_line_array);\n    fd_cur->font_dim[ITALIC_ANGLE_CODE].val = round(a);\n    fd_cur->font_dim[ITALIC_ANGLE_CODE].set = true;\n}\n\nstatic void t1_scan_keys(void)\n{\n    int i, k;\n    char *p, *q, *r;\n    const key_entry *key;\n    if (fm_extend(fd_cur->fm) != 0 || fm_slant(fd_cur->fm) != 0) {\n        if (t1_prefix(\"/FontMatrix\")) {\n            t1_modify_fm();\n            return;\n        }\n        if (t1_prefix(\"/ItalicAngle\")) {\n            t1_modify_italic();\n            return;\n        }\n    }\n    if (t1_prefix(\"/FontType\")) {\n        p = t1_line_array + strlen(\"FontType\") + 1;\n        if ((i = t1_scan_num(p, 0)) != 1)\n            pdftex_fail(\"Type%d fonts unsupported by pdfTeX\", i);\n        return;\n    }\n    for (key = font_key; key - font_key < FONT_KEYS_NUM; key++) {\n        if (key->t1name[0] != '\\0' &&\n            str_prefix(t1_line_array + 1, key->t1name))\n            break;\n    }\n    if (key - font_key == FONT_KEYS_NUM)\n        return;\n    p = t1_line_array + strlen(key->t1name) + 1;\n    skip(p, ' ');\n    if ((k = key - font_key) == FONTNAME_CODE) {\n        if (*p != '/') {\n            remove_eol(p, t1_line_array);\n            pdftex_fail(\"a name expected: `%s'\", t1_line_array);\n        }\n        r = ++p;                /* skip the slash */\n        for (q = t1_buf_array; *p != ' ' && *p != 10; *q++ = *p++);\n        *q = 0;\n        if (fm_slant(fd_cur->fm) != 0) {\n            sprintf(q, \"-Slant_%i\", (int) fm_slant(fd_cur->fm));\n            q = strend(q);\n        }\n        if (fm_extend(fd_cur->fm) != 0) {\n            sprintf(q, \"-Extend_%i\", (int) fm_extend(fd_cur->fm));\n        }\n        xfree(fd_cur->fontname);\n        fd_cur->fontname = xstrdup(t1_buf_array);\n        /* at this moment we cannot call make_subset_tag() yet, as the encoding\n         * is not read; thus we mark the offset of the subset tag and write it\n         * later */\n        if (is_subsetted(fd_cur->fm)) {\n            assert(is_included(fd_cur->fm));\n            t1_fontname_offset = t1_offset() + (r - t1_line_array);\n            strcpy(t1_buf_array, p);\n            sprintf(r, \"ABCDEF+%s%s\", fd_cur->fontname, t1_buf_array);\n            t1_line_ptr = eol(r);\n        }\n        return;\n    }\n    if ((k == STEMV_CODE || k == FONTBBOX1_CODE)\n        && (*p == '[' || *p == '{'))\n        p++;\n    if (k == FONTBBOX1_CODE) {\n        for (i = 0; i < 4; i++, k++) {\n            fd_cur->font_dim[k].val = t1_scan_num(p, &r);\n            fd_cur->font_dim[k].set = true;\n            p = r;\n        }\n        return;\n    }\n    fd_cur->font_dim[k].val = t1_scan_num(p, 0);\n    fd_cur->font_dim[k].set = true;\n}\n\nstatic void t1_scan_param(void)\n{\n    static const char *lenIV = \"/lenIV\";\n    if (!t1_scan || *t1_line_array != '/')\n        return;\n    if (t1_prefix(lenIV)) {\n        t1_lenIV = t1_scan_num(t1_line_array + strlen(lenIV), 0);\n        if (t1_lenIV < 0)\n            pdftex_fail(\"negative value of lenIV is not supported\");\n        return;\n    }\n    t1_scan_keys();\n}\n\nstatic void copy_glyph_names(char **glyph_names, int a, int b)\n{\n    if (glyph_names[b] != notdef) {\n        xfree(glyph_names[b]);\n        glyph_names[b] = notdef;\n    }\n    if (glyph_names[a] != notdef) {\n        glyph_names[b] = xstrdup(glyph_names[a]);\n    }\n}\n\n/* read encoding from Type1 font file, return glyph_names array, or pdffail() */\n\nstatic char **t1_builtin_enc(void)\n{\n    int i, a, b, c, counter = 0;\n    char *r, *p, **glyph_names;\n    /* At this moment \"/Encoding\" is the prefix of t1_line_array */\n    glyph_names = xtalloc(256, char *);\n    for (i = 0; i < 256; i++)\n        glyph_names[i] = notdef;\n    if (t1_suffix(\"def\")) {     /* predefined encoding */\n        if (sscanf(t1_line_array + strlen(\"/Encoding\"), \"%255s\", t1_buf_array) == 1\n            && strcmp(t1_buf_array, \"StandardEncoding\") == 0) {\n            t1_encoding = ENC_STANDARD;\n            for (i = 0; i < 256; i++) {\n                if (standard_glyph_names[i] != notdef)\n                    glyph_names[i] = xstrdup(standard_glyph_names[i]);\n            }\n            return glyph_names;\n        }\n        pdftex_fail(\"cannot subset font (unknown predefined encoding `%s')\",\n                    t1_buf_array);\n    }\n    /* At this moment \"/Encoding\" is the prefix of t1_line_array, and the encoding is\n     * not a predefined encoding.\n     *\n     * We have two possible forms of Encoding vector. The first case is\n     *\n     *     /Encoding [/a /b /c...] readonly def\n     *\n     * and the second case can look like\n     *\n     *     /Encoding 256 array 0 1 255 {1 index exch /.notdef put} for\n     *     dup 0 /x put\n     *     dup 1 /y put\n     *     ...\n     *     readonly def\n     */\n    t1_encoding = ENC_BUILTIN;\n    if (t1_prefix(\"/Encoding [\") || t1_prefix(\"/Encoding[\")) {  /* the first case */\n        r = strchr(t1_line_array, '[') + 1;\n        skip(r, ' ');\n        for (;;) {\n            while (*r == '/') {\n                for (p = t1_buf_array, r++;\n                     *r != 32 && *r != 10 && *r != ']' && *r != '/';\n                     *p++ = *r++);\n                *p = 0;\n                skip(r, ' ');\n                if (counter > 255)\n                    pdftex_fail(\"encoding vector contains more than 256 names\");\n                if (strcmp(t1_buf_array, notdef) != 0)\n                    glyph_names[counter] = xstrdup(t1_buf_array);\n                counter++;\n            }\n            if (*r != 10 && *r != '%') {\n                if (str_prefix(r, \"] def\") || str_prefix(r, \"] readonly def\"))\n                    break;\n                else {\n                    remove_eol(r, t1_line_array);\n                    pdftex_fail\n       (\"a name or `] def' or `] readonly def' expected: `%s'\", t1_line_array);\n                }\n            }\n            t1_getline();\n            r = t1_line_array;\n        }\n    } else {                    /* the second case */\n        p = strchr(t1_line_array, 10);\n        for (;;) {\n            if (*p == 10) {\n                t1_getline();\n                p = t1_line_array;\n            }\n            /*\n               check for `dup <index> <glyph> put'\n             */\n            if (sscanf(p, \"dup %i%255s put\", &i, t1_buf_array) == 2 &&\n                *t1_buf_array == '/' && valid_code(i)) {\n                if (strcmp(t1_buf_array + 1, notdef) != 0)\n                    glyph_names[i] = xstrdup(t1_buf_array + 1);\n                p = strstr(p, \" put\") + strlen(\" put\");\n                skip(p, ' ');\n            }\n            /*\n               check for `dup dup <to> exch <from> get put'\n             */\n            else if (sscanf(p, \"dup dup %i exch %i get put\", &b, &a) == 2\n                     && valid_code(a) && valid_code(b)) {\n                copy_glyph_names(glyph_names, a, b);\n                p = strstr(p, \" get put\") + strlen(\" get put\");\n                skip(p, ' ');\n            }\n            /*\n               check for `dup dup <from> <size> getinterval <to> exch putinterval'\n             */\n            else if (sscanf(p, \"dup dup %i %i getinterval %i exch putinterval\",\n                            &a, &c, &b) == 3\n                     && valid_code(a) && valid_code(b) && valid_code(c)) {\n                for (i = 0; i < c; i++)\n                    copy_glyph_names(glyph_names, a + i, b + i);\n                p = strstr(p, \" putinterval\") + strlen(\" putinterval\");\n                skip(p, ' ');\n            }\n            /*\n               check for `def' or `readonly def'\n             */\n            else if ((p == t1_line_array || (p > t1_line_array && p[-1] == ' '))\n                     && strcmp(p, \"def\\n\") == 0)\n                return glyph_names;\n            /*\n               skip an unrecognizable word\n             */\n            else {\n                while (*p != ' ' && *p != 10)\n                    p++;\n                skip(p, ' ');\n            }\n        }\n    }\n    return glyph_names;\n}\n\nstatic void t1_check_end(void)\n{\n    if (t1_eof())\n        return;\n    t1_getline();\n    if (t1_prefix(\"{restore}\"))\n        t1_putline();\n}\n\nstatic boolean t1_open_fontfile(const char *open_name_prefix)\n{\n    ff_entry *ff;\n    ff = check_ff_exist(fd_cur->fm->ff_name, is_truetype(fd_cur->fm));\n    if (ff->ff_path != NULL) {\n        t1_file = xfopen(cur_file_name = ff->ff_path, FOPEN_RBIN_MODE);\n        recorder_record_input(ff->ff_path);\n    } else {\n        set_cur_file_name(fd_cur->fm->ff_name);\n        pdftex_fail(\"cannot open Type 1 font file for reading\");\n    }\n    t1_init_params(open_name_prefix);\n    return true;                /* font file found */\n}\n\nstatic void t1_include(void)\n{\n    do {\n        t1_getline();\n        t1_scan_param();\n        t1_putline();\n    } while (t1_in_eexec == 0);\n    t1_start_eexec();\n    do {\n        t1_getline();\n        t1_scan_param();\n        t1_putline();\n    } while (!(t1_charstrings() || t1_subrs()));\n    t1_cs = true;\n    do {\n        t1_getline();\n        t1_putline();\n    } while (!t1_end_eexec());\n    t1_stop_eexec();\n    if (fixedcontent) {         /* copy 512 zeros (not needed for PDF) */\n        do {\n            t1_getline();\n            t1_putline();\n        } while (!t1_cleartomark());\n        t1_check_end();         /* write \"{restore}if\" if found */\n    }\n    get_length3();\n}\n\n#define check_subr(subr) \\\n    if (subr >= subr_size || subr < 0) \\\n        pdftex_fail(\"Subrs array: entry index out of range (%i)\",  subr);\n\nstatic const char **check_cs_token_pair(void)\n{\n    const char **p = (const char **) cs_token_pairs_list;\n    for (; p[0] != NULL; ++p)\n        if (t1_buf_prefix(p[0]) && t1_buf_suffix(p[1]))\n            return p;\n    return NULL;\n}\n\nstatic void cs_store(boolean is_subr)\n{\n    char *p;\n    cs_entry *ptr;\n    int subr;\n    for (p = t1_line_array, t1_buf_ptr = t1_buf_array; *p != ' ';\n         *t1_buf_ptr++ = *p++);\n    *t1_buf_ptr = 0;\n    if (is_subr) {\n        subr = t1_scan_num(p + 1, 0);\n        check_subr(subr);\n        ptr = subr_tab + subr;\n    } else {\n        ptr = cs_ptr++;\n        if (cs_ptr - cs_tab > cs_size)\n            pdftex_fail\n                (\"CharStrings dict: more entries than dict size (%i)\", cs_size);\n        if (strcmp(t1_buf_array + 1, notdef) == 0)      /* skip the slash */\n            ptr->name = notdef;\n        else\n            ptr->name = xstrdup(t1_buf_array + 1);\n    }\n    /* copy \" RD \" + cs data to t1_buf_array */\n    memcpy(t1_buf_array, t1_line_array + cs_start - 4,\n           (unsigned) (t1_cslen + 4));\n    /* copy the end of cs data to t1_buf_array */\n    for (p = t1_line_array + cs_start + t1_cslen,\n           t1_buf_ptr = t1_buf_array + t1_cslen + 4;\n         *p != 10; *t1_buf_ptr++ = *p++);\n    *t1_buf_ptr++ = 10;\n    if (is_subr && cs_token_pair == NULL)\n        cs_token_pair = check_cs_token_pair();\n    ptr->len = t1_buf_ptr - t1_buf_array;\n    ptr->cslen = t1_cslen;\n    ptr->data = xtalloc(ptr->len, byte);\n    memcpy(ptr->data, t1_buf_array, ptr->len);\n    ptr->valid = true;\n}\n\n#define store_subr()     cs_store(true)\n#define store_cs()       cs_store(false)\n\n#define CC_STACK_SIZE    24\n\nstatic integer cc_stack[CC_STACK_SIZE], *stack_ptr = cc_stack;\nstatic cc_entry cc_tab[CS_MAX];\nstatic boolean is_cc_init = false;\n\n#define cc_pop(N)                   \\\n    if (stack_ptr - cc_stack < (N)) \\\n        stack_error(N);             \\\n    stack_ptr -= N\n\n#define stack_error(N) {            \\\n    pdftex_fail(\"CharString: invalid access (%i) to stack (%i entries)\", \\\n                (int) N, (int)(stack_ptr - cc_stack));                  \\\n    goto cs_error;                  \\\n}\n\n/*\nstatic integer cc_get(integer index)\n{\n    if (index <  0) {\n        if (stack_ptr + index < cc_stack )\n            stack_error(stack_ptr - cc_stack + index);\n        return *(stack_ptr + index);\n    }\n    else {\n        if (cc_stack  + index >= stack_ptr)\n            stack_error(index);\n        return cc_stack[index];\n    }\n}\n*/\n\n#define cc_get(N)   ((N) < 0 ? *(stack_ptr + (N)) : *(cc_stack + (N)))\n#define cc_push(V)  *stack_ptr++ = V\n#define cc_clear()  stack_ptr = cc_stack\n#define set_cc(N, B, A, C) \\\n    cc_tab[N].nargs = A;   \\\n    cc_tab[N].bottom = B;  \\\n    cc_tab[N].clear = C;   \\\n    cc_tab[N].valid = true\n\nstatic void cc_init(void)\n{\n    int i;\n    if (is_cc_init)\n        return;\n    for (i = 0; i < CS_MAX; i++)\n        cc_tab[i].valid = false;\n    set_cc(CS_HSTEM, true, 2, true);\n    set_cc(CS_VSTEM, true, 2, true);\n    set_cc(CS_VMOVETO, true, 1, true);\n    set_cc(CS_RLINETO, true, 2, true);\n    set_cc(CS_HLINETO, true, 1, true);\n    set_cc(CS_VLINETO, true, 1, true);\n    set_cc(CS_RRCURVETO, true, 6, true);\n    set_cc(CS_CLOSEPATH, false, 0, true);\n    set_cc(CS_CALLSUBR, false, 1, false);\n    set_cc(CS_RETURN, false, 0, false);\n    /*\n       set_cc(CS_ESCAPE, false, 0, false);\n     */\n    set_cc(CS_HSBW, true, 2, true);\n    set_cc(CS_ENDCHAR, false, 0, true);\n    set_cc(CS_RMOVETO, true, 2, true);\n    set_cc(CS_HMOVETO, true, 1, true);\n    set_cc(CS_VHCURVETO, true, 4, true);\n    set_cc(CS_HVCURVETO, true, 4, true);\n    set_cc(CS_DOTSECTION, false, 0, true);\n    set_cc(CS_VSTEM3, true, 6, true);\n    set_cc(CS_HSTEM3, true, 6, true);\n    set_cc(CS_SEAC, true, 5, true);\n    set_cc(CS_SBW, true, 4, true);\n    set_cc(CS_DIV, false, 2, false);\n    set_cc(CS_CALLOTHERSUBR, false, 0, false);\n    set_cc(CS_POP, false, 0, false);\n    set_cc(CS_SETCURRENTPOINT, true, 2, true);\n    is_cc_init = true;\n}\n\n#define cs_getchar()     cdecrypt(*data++, &cr)\n\n#define mark_subr(n)     cs_mark(0, n)\n#define mark_cs(s)       cs_mark(s, 0)\n\n__attribute__ ((format(printf, 3, 4)))\nstatic void cs_fail(const char *cs_name, int subr, const char *fmt, ...)\n{\n    char buf[SMALL_BUF_SIZE];\n    va_list args;\n    va_start(args, fmt);\n    vsprintf(buf, fmt, args);\n    va_end(args);\n    if (cs_name == NULL)\n        pdftex_fail(\"Subr (%i): %s\", (int) subr, buf);\n    else\n        pdftex_fail(\"CharString (/%s): %s\", cs_name, buf);\n}\n\n/* fix a return-less subr by appending CS_RETURN */\nstatic void append_cs_return(cs_entry *ptr)\n{\n    unsigned short cr;\n    int i;\n    byte *p, *q, *data, *new_data;\n    assert(ptr != NULL && ptr->valid && ptr->used);\n\n    /* decrypt the cs data to t1_buf_array, append CS_RETURN */\n    p = (byte *) t1_buf_array;\n    data = ptr->data + 4;\n    cr = 4330;\n    for (i = 0; i < ptr->cslen; i++)\n        *p++ = cs_getchar();\n    *p = CS_RETURN;\n\n    /* encrypt the new cs data to new_data */\n    new_data = xtalloc(ptr->len + 1, byte);\n    memcpy(new_data, ptr->data, 4);\n    p = new_data + 4;\n    q = (byte *) t1_buf_array;\n    cr = 4330;\n    for (i = 0; i < ptr->cslen + 1; i++)\n        *p++ = cencrypt(*q++, &cr);\n    memcpy(p, ptr->data + 4 + ptr->cslen, ptr->len - ptr->cslen - 4);\n\n    /* update *ptr */\n    xfree(ptr->data);\n    ptr->data = new_data;\n    ptr->len++;\n    ptr->cslen++;\n}\n\nstatic void cs_mark(const char *cs_name, int subr)\n{\n    byte *data;\n    int i, b, cs_len;\n    int last_cmd = 0;\n    integer a, a1, a2;\n    unsigned short cr;\n    static integer lastargOtherSubr3 = 3;       /* the argument of last call to\n                                                   OtherSubrs[3] */\n    cs_entry *ptr;\n    cc_entry *cc;\n    if (cs_name == NULL) {\n        check_subr(subr);\n        ptr = subr_tab + subr;\n        if (!ptr->valid)\n            return;\n    } else {\n        if (cs_notdef != NULL &&\n            (cs_name == notdef || strcmp(cs_name, notdef) == 0))\n            ptr = cs_notdef;\n        else {\n            for (ptr = cs_tab; ptr < cs_ptr; ptr++)\n                if (strcmp(ptr->name, cs_name) == 0)\n                    break;\n            if (ptr == cs_ptr) {\n                pdftex_warn(\"glyph `%s' undefined\", cs_name);\n                return;\n            }\n            if (ptr->name == notdef)\n                cs_notdef = ptr;\n        }\n    }\n    /* only marked CharString entries and invalid entries can be skipped;\n       valid marked subrs must be parsed to keep the stack in sync */\n    if (!ptr->valid || (ptr->used && cs_name != NULL))\n        return;\n    ptr->used = true;\n    cr = 4330;\n    cs_len = ptr->cslen;\n    data = ptr->data + 4;\n    for (i = 0; i < t1_lenIV; i++, cs_len--)\n        cs_getchar();\n    while (cs_len > 0) {\n        --cs_len;\n        b = cs_getchar();\n        if (b >= 32) {\n            if (b <= 246)\n                a = b - 139;\n            else if (b <= 250) {\n                --cs_len;\n                a = ((b - 247) << 8) + 108 + cs_getchar();\n            } else if (b <= 254) {\n                --cs_len;\n                a = -((b - 251) << 8) - 108 - cs_getchar();\n            } else {\n                cs_len -= 4;\n                a = (cs_getchar() & 0xff) << 24;\n                a |= (cs_getchar() & 0xff) << 16;\n                a |= (cs_getchar() & 0xff) << 8;\n                a |= (cs_getchar() & 0xff) << 0;\n                if (sizeof(integer) > 4 && (a & 0x80000000))\n                    a |= ~0x7FFFFFFF;\n            }\n            cc_push(a);\n        } else {\n            if (b == CS_ESCAPE) {\n                b = cs_getchar() + CS_1BYTE_MAX;\n                cs_len--;\n            }\n            if (b >= CS_MAX) {\n                cs_fail(cs_name, subr, \"command value out of range: %i\",\n                        (int) b);\n                goto cs_error;\n            }\n            cc = cc_tab + b;\n            if (!cc->valid) {\n                cs_fail(cs_name, subr, \"command not valid: %i\", (int) b);\n                goto cs_error;\n            }\n            if (cc->bottom) {\n                if (stack_ptr - cc_stack < cc->nargs)\n                    cs_fail(cs_name, subr,\n                            \"less arguments on stack (%i) than required (%i)\",\n                            (int) (stack_ptr - cc_stack), (int) cc->nargs);\n                else if (stack_ptr - cc_stack > cc->nargs)\n                    cs_fail(cs_name, subr,\n                            \"more arguments on stack (%i) than required (%i)\",\n                            (int) (stack_ptr - cc_stack), (int) cc->nargs);\n            }\n            last_cmd = b;\n            switch (cc - cc_tab) {\n            case CS_CALLSUBR:\n                a1 = cc_get(-1);\n                cc_pop(1);\n                mark_subr(a1);\n                if (!subr_tab[a1].valid) {\n                    cs_fail(cs_name, subr, \"cannot call subr (%i)\", (int) a1);\n                    goto cs_error;\n                }\n                break;\n            case CS_DIV:\n                cc_pop(2);\n                cc_push(0);\n                break;\n            case CS_CALLOTHERSUBR:\n                if (cc_get(-1) == 3)\n                    lastargOtherSubr3 = cc_get(-3);\n                a1 = cc_get(-2) + 2;\n                cc_pop(a1);\n                break;\n            case CS_POP:\n                cc_push(lastargOtherSubr3);\n                /* the only case when we care about the value being pushed onto\n                   stack is when POP follows CALLOTHERSUBR (changing hints by\n                   OtherSubrs[3])\n                 */\n                break;\n            case CS_SEAC:\n                a1 = cc_get(3);\n                a2 = cc_get(4);\n                cc_clear();\n                mark_cs(standard_glyph_names[a1]);\n                mark_cs(standard_glyph_names[a2]);\n                break;\n            default:\n                if (cc->clear)\n                    cc_clear();\n            }\n        }\n    }\n    if (cs_name == NULL && last_cmd != CS_RETURN) {\n        pdftex_warn(\"last command in subr `%i' is not a RETURN; \"\n                    \"I will add it now but please consider fixing the font\",\n                    (int) subr);\n        append_cs_return(ptr);\n    }\n    return;\n  cs_error:                    /* an error occured during parsing */\n    cc_clear();\n    ptr->valid = false;\n    ptr->used = false;\n}\n\n/**********************************************************************/\n/* AVL search tree for glyph code by glyph name */\n\nstatic int comp_t1_glyphs(const void *pa, const void *pb, void *p)\n{\n    return strcmp(*((const char * const *) pa), *((const char * const *) pb));\n}\n\nstatic struct avl_table *create_t1_glyph_tree(char **glyph_names)\n{\n    int i;\n    void **aa;\n    static struct avl_table *gl_tree;\n    gl_tree = avl_create(comp_t1_glyphs, NULL, &avl_xallocator);\n    assert(gl_tree != NULL);\n    for (i = 0; i < 256; i++) {\n        if (glyph_names[i] != notdef &&\n            (char **) avl_find(gl_tree, &glyph_names[i]) == NULL) {\n            /* no strdup here, just point to the glyph_names array members */\n            aa = avl_probe(gl_tree, &glyph_names[i]);\n            assert(aa != NULL);\n        }\n    }\n    return gl_tree;\n}\n\nstatic void destroy_t1_glyph_tree(struct avl_table *gl_tree)\n{\n    assert(gl_tree != NULL);\n    avl_destroy(gl_tree, NULL);\n}\n\n/**********************************************************************/\n\nstatic void t1_subset_ascii_part(void)\n{\n    int j, *p;\n    char *glyph, **gg, **glyph_names;\n    struct avl_table *gl_tree;\n    struct avl_traverser t;\n    void **aa;\n    assert(fd_cur != NULL);\n    assert(fd_cur->gl_tree != NULL);\n    t1_getline();\n    while (!t1_prefix(\"/Encoding\")) {\n        t1_scan_param();\n        if (!(t1_prefix(\"/UniqueID\")\n              && !strncmp(t1_line_array + strlen(t1_line_array) -4, \"def\", 3)))\n            t1_putline();\n        t1_getline();\n    }\n    glyph_names = t1_builtin_enc();\n    fd_cur->builtin_glyph_names = glyph_names;\n    if (is_subsetted(fd_cur->fm)) {\n        assert(is_included(fd_cur->fm));\n        if (fd_cur->tx_tree != NULL) {\n            /* take over collected non-reencoded characters from TeX */\n            avl_t_init(&t, fd_cur->tx_tree);\n            for (p = (int *) avl_t_first(&t, fd_cur->tx_tree); p != NULL;\n                 p = (int *) avl_t_next(&t)) {\n                if ((char *) avl_find(fd_cur->gl_tree, glyph_names[*p]) == NULL) {\n                    glyph = xstrdup(glyph_names[*p]);\n                    aa = avl_probe(fd_cur->gl_tree, glyph);\n                    assert(aa != NULL);\n                }\n            }\n        }\n        make_subset_tag(fd_cur);\n        assert(t1_fontname_offset != 0);\n        strncpy(fb_array + t1_fontname_offset, fd_cur->subset_tag, 6);\n    }\n    /* now really all glyphs needed from this font are in the fd_cur->gl_tree */\n    if (t1_encoding == ENC_STANDARD)\n        t1_puts(\"/Encoding StandardEncoding def\\n\");\n    else {\n        t1_puts\n            (\"/Encoding 256 array\\n0 1 255 {1 index exch /.notdef put} for\\n\");\n        gl_tree = create_t1_glyph_tree(glyph_names);\n        avl_t_init(&t, fd_cur->gl_tree);\n        j = 0;\n        for (glyph = (char *) avl_t_first(&t, fd_cur->gl_tree); glyph != NULL;\n             glyph = (char *) avl_t_next(&t)) {\n            if ((gg = (char **) avl_find(gl_tree, &glyph)) != NULL) {\n                t1_printf(\"dup %i /%s put\\n\", (int) (gg - glyph_names), *gg);\n                j++;\n            }\n        }\n        destroy_t1_glyph_tree(gl_tree);\n        if (j == 0)\n            /* We didn't mark anything for the Encoding array. */\n            /* We add \"dup 0 /.notdef put\" for compatibility   */\n            /* with Acrobat 5.0.                               */\n            t1_puts(\"dup 0 /.notdef put\\n\");\n        t1_puts(\"readonly def\\n\");\n    }\n    do {\n        t1_getline();\n        t1_scan_param();\n        if (!t1_prefix(\"/UniqueID\"))    /* ignore UniqueID for subsetted fonts */\n            t1_putline();\n    } while (t1_in_eexec == 0);\n}\n\nstatic void cs_init(void)\n{\n    cs_ptr = cs_tab = NULL;\n    cs_dict_start = cs_dict_end = NULL;\n    cs_count = cs_size = cs_size_pos = 0;\n    cs_token_pair = NULL;\n    subr_tab = NULL;\n    subr_array_start = subr_array_end = NULL;\n    subr_max = subr_size = subr_size_pos = 0;\n}\n\nstatic void init_cs_entry(cs_entry *cs)\n{\n    cs->data = NULL;\n    cs->name = NULL;\n    cs->len = 0;\n    cs->cslen = 0;\n    cs->used = false;\n    cs->valid = false;\n}\n\nstatic void t1_read_subrs(void)\n{\n    int i, s;\n    cs_entry *ptr;\n    t1_getline();\n    while (!(t1_charstrings() || t1_subrs())) {\n        t1_scan_param();\n        if (!t1_prefix(\"/UniqueID\"))    /* ignore UniqueID for subsetted fonts */\n            t1_putline();\n        t1_getline();\n    }\n  found:\n    t1_cs = true;\n    t1_scan = false;\n    if (!t1_subrs())\n        return;\n    subr_size_pos = strlen(\"/Subrs\") + 1;\n    /* subr_size_pos points to the number indicating dict size after \"/Subrs\" */\n    subr_size = t1_scan_num(t1_line_array + subr_size_pos, 0);\n    if (subr_size == 0) {\n        while (!t1_charstrings())\n            t1_getline();\n        return;\n    }\n    subr_tab = xtalloc(subr_size, cs_entry);\n    for (ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n        init_cs_entry(ptr);\n    subr_array_start = xstrdup(t1_line_array);\n    t1_getline();\n    while (t1_cslen) {\n        store_subr();\n        t1_getline();\n    }\n    /* mark the first four entries without parsing */\n    for (i = 0; i < subr_size && i < 4; i++)\n        subr_tab[i].used = true;\n    /* the end of the Subrs array might have more than one line so we need to\n       concatnate them to subr_array_end. Unfortunately some fonts don't have\n       the Subrs array followed by the CharStrings dict immediately (synthetic\n       fonts). If we cannot find CharStrings in next POST_SUBRS_SCAN lines then\n       we will treat the font as synthetic and ignore everything until next\n       Subrs is found\n     */\n\n#define POST_SUBRS_SCAN  5\n\n    s = 0;\n    *t1_buf_array = 0;\n    for (i = 0; i < POST_SUBRS_SCAN; i++) {\n        if (t1_charstrings())\n            break;\n        s += t1_line_ptr - t1_line_array;\n        alloc_array(t1_buf, s, T1_BUF_SIZE);\n        strcat(t1_buf_array, t1_line_array);\n        t1_getline();\n    }\n    subr_array_end = xstrdup(t1_buf_array);\n    if (i == POST_SUBRS_SCAN) { /* CharStrings not found;\n                                   suppose synthetic font */\n        for (ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n            if (ptr->valid)\n                xfree(ptr->data);\n        xfree(subr_tab);\n        xfree(subr_array_start);\n        xfree(subr_array_end);\n        cs_init();\n        t1_cs = false;\n        t1_synthetic = true;\n        while (!(t1_charstrings() || t1_subrs()))\n            t1_getline();\n        goto found;\n    }\n}\n\n#define t1_subr_flush()  t1_flush_cs(true)\n#define t1_cs_flush()    t1_flush_cs(false)\n\nstatic void t1_flush_cs(boolean is_subr)\n{\n    char *p;\n    byte *r, *return_cs = NULL;\n    cs_entry *tab, *end_tab, *ptr;\n    char *start_line, *line_end;\n    int count, size_pos;\n    unsigned short cr, cs_len = 0;      /* to avoid warning about uninitialized use of cs_len */\n    if (is_subr) {\n        start_line = subr_array_start;\n        line_end = subr_array_end;\n        size_pos = subr_size_pos;\n        tab = subr_tab;\n        count = subr_max + 1;\n        end_tab = subr_tab + count;\n    } else {\n        start_line = cs_dict_start;\n        line_end = cs_dict_end;\n        size_pos = cs_size_pos;\n        tab = cs_tab;\n        end_tab = cs_ptr;\n        count = cs_count;\n    }\n    t1_line_ptr = t1_line_array;\n    for (p = start_line; p - start_line < size_pos;)\n        *t1_line_ptr++ = *p++;\n    while (isdigit((unsigned char)*p))\n        p++;\n    sprintf(t1_line_ptr, \"%u\", count);\n    strcat(t1_line_ptr, p);\n    t1_line_ptr = eol(t1_line_array);\n    t1_putline();\n\n    /* create return_cs to replace unused subr's */\n    if (is_subr) {\n        cr = 4330;\n        cs_len = 0;\n        /* at this point we have t1_lenIV >= 0;\n         * a negative value would be caught in t1_scan_param() */\n        return_cs = xtalloc(t1_lenIV + 1, byte);\n        for (cs_len = 0, r = return_cs; cs_len < t1_lenIV; cs_len++, r++)\n            *r = cencrypt(0x00, &cr);\n        *r = cencrypt(CS_RETURN, &cr);\n        cs_len++;\n    }\n\n    for (ptr = tab; ptr < end_tab; ptr++) {\n        if (ptr->used) {\n            if (is_subr)\n                sprintf(t1_line_array, \"dup %lu %u\",\n                        (unsigned long) (ptr - tab), ptr->cslen);\n            else\n                sprintf(t1_line_array, \"/%s %u\", ptr->name, ptr->cslen);\n            p = strend(t1_line_array);\n            memcpy(p, ptr->data, ptr->len);\n            t1_line_ptr = p + ptr->len;\n            t1_putline();\n        } else {\n            /* replace unsused subr's by return_cs */\n            if (is_subr) {\n                sprintf(t1_line_array, \"dup %lu %u%s \",\n                        (unsigned long) (ptr - tab), cs_len, cs_token_pair[0]);\n                p = strend(t1_line_array);\n                memcpy(p, return_cs, cs_len);\n                t1_line_ptr = p + cs_len;\n                t1_putline();\n                sprintf(t1_line_array, \" %s\", cs_token_pair[1]);\n                t1_line_ptr = eol(t1_line_array);\n                t1_putline();\n            }\n        }\n        xfree(ptr->data);\n        if (ptr->name != notdef)\n            xfree(ptr->name);\n    }\n    sprintf(t1_line_array, \"%s\", line_end);\n    t1_line_ptr = eol(t1_line_array);\n    t1_putline();\n    if (is_subr)\n        xfree(return_cs);\n    xfree(tab);\n    xfree(start_line);\n    xfree(line_end);\n}\n\nstatic void t1_mark_glyphs(void)\n{\n    char *glyph;\n    struct avl_traverser t;\n    cs_entry *ptr;\n    if (t1_synthetic || fd_cur->all_glyphs) {   /* mark everything */\n        if (cs_tab != NULL)\n            for (ptr = cs_tab; ptr < cs_ptr; ptr++)\n                if (ptr->valid)\n                    ptr->used = true;\n        if (subr_tab != NULL) {\n            for (ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n                if (ptr->valid)\n                    ptr->used = true;\n            subr_max = subr_size - 1;\n        }\n        return;\n    }\n    mark_cs(notdef);\n    avl_t_init(&t, fd_cur->gl_tree);\n    for (glyph = (char *) avl_t_first(&t, fd_cur->gl_tree); glyph != NULL;\n         glyph = (char *) avl_t_next(&t)) {\n        mark_cs(glyph);\n    }\n    if (subr_tab != NULL)\n        for (subr_max = -1, ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n            if (ptr->used && ptr - subr_tab > subr_max)\n                subr_max = ptr - subr_tab;\n}\n\nstatic void t1_check_unusual_charstring(void)\n{\n    char *p = strstr(t1_line_array, charstringname) + strlen(charstringname);\n    int i;\n    /* if no number follows \"/CharStrings\", let's read the next line */\n    if (sscanf(p, \"%i\", &i) != 1) {\n        /* pdftex_warn(\"no number found after `%s', I assume it's on the next line\",\n                    charstringname); */\n        strcpy(t1_buf_array, t1_line_array);\n\n        /* t1_getline always appends EOL to t1_line_array; let's change it to\n         * space before appending the next line\n         */\n        *(strend(t1_buf_array) - 1) = ' ';\n\n        t1_getline();\n        strcat(t1_buf_array, t1_line_array);\n        strcpy(t1_line_array, t1_buf_array);\n        t1_line_ptr = eol(t1_line_array);\n    }\n}\n\nstatic void t1_subset_charstrings(void)\n{\n    cs_entry *ptr;\n\n    /* at this point t1_line_array contains \"/CharStrings\".\n       when we hit a case like this:\n         dup/CharStrings\n         229 dict dup begin\n       we read the next line and concatenate to t1_line_array before moving on\n    */\n    t1_check_unusual_charstring();\n\n    cs_size_pos = strstr(t1_line_array, charstringname)\n                  + strlen(charstringname) - t1_line_array + 1;\n    /* cs_size_pos points to the number indicating\n       dict size after \"/CharStrings\" */\n    cs_size = t1_scan_num(t1_line_array + cs_size_pos, 0);\n    cs_ptr = cs_tab = xtalloc(cs_size, cs_entry);\n    for (ptr = cs_tab; ptr - cs_tab < cs_size; ptr++)\n        init_cs_entry(ptr);\n    cs_notdef = NULL;\n    cs_dict_start = xstrdup(t1_line_array);\n    t1_getline();\n    while (t1_cslen) {\n        store_cs();\n        t1_getline();\n    }\n    cs_dict_end = xstrdup(t1_line_array);\n    t1_mark_glyphs();\n    if (subr_tab != NULL) {\n        if (cs_token_pair == NULL)\n            pdftex_fail\n                (\"This Type 1 font uses mismatched subroutine begin/end token pairs.\");\n        t1_subr_flush();\n    }\n    for (cs_count = 0, ptr = cs_tab; ptr < cs_ptr; ptr++)\n        if (ptr->used)\n            cs_count++;\n    t1_cs_flush();\n}\n\nstatic void t1_subset_end(void)\n{\n    if (t1_synthetic) {         /* copy to \"dup /FontName get exch definefont pop\" */\n        while (!strstr(t1_line_array, \"definefont\")) {\n            t1_getline();\n            t1_putline();\n        }\n        while (!t1_end_eexec())\n            t1_getline();       /* ignore the rest */\n        t1_putline();           /* write \"mark currentfile closefile\" */\n    } else\n        while (!t1_end_eexec()) {       /* copy to \"mark currentfile closefile\" */\n            t1_getline();\n            t1_putline();\n        }\n    t1_stop_eexec();\n    if (fixedcontent) {         /* copy 512 zeros (not needed for PDF) */\n        while (!t1_cleartomark()) {\n            t1_getline();\n            t1_putline();\n        }\n        if (!t1_synthetic)      /* don't check \"{restore}if\" for synthetic fonts */\n            t1_check_end();     /* write \"{restore}if\" if found */\n    }\n    get_length3();\n}\n\nvoid writet1(fd_entry *fd)\n{\n    fd_cur = fd;                /* fd_cur is global inside writet1.c */\n    assert(fd_cur->fm != NULL);\n    assert(is_type1(fd->fm));\n    assert(is_included(fd->fm));\n\n    t1_save_offset = 0;\n    if (!is_subsetted(fd_cur->fm)) {    /* include entire font */\n        if (!(fd->ff_found = t1_open_fontfile(\"<<\")))\n            return;\n        t1_include();\n        t1_close_font_file(\">>\");\n        return;\n    }\n    /* partial downloading */\n    if (!(fd->ff_found = t1_open_fontfile(\"<\")))\n        return;\n    t1_subset_ascii_part();\n    t1_start_eexec();\n    cc_init();\n    cs_init();\n    t1_read_subrs();\n    t1_subset_charstrings();\n    t1_subset_end();\n    t1_close_font_file(\">\");\n}\n\nvoid t1_free(void)\n{\n    xfree(t1_line_array);\n    xfree(t1_buf_array);\n}\n"], "fixing_code": ["2018-09-18  Nick Roessler  <nicholas.e.roessler@gmail.com>\n\n\t* writet1.c (t1_check_unusual_charstring): protect against buffer\n\toverflow.\n\n2018-04-14  Karl Berry  <karl@tug.org>\n\n\t* Version 5.998 for TeX Live 2018 release.\n\n2018-02-20  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* color.c (colorpage),\n\t* dospecial.c (bangspecial),\n\t* dvips.h (header_list):\t\n\tdon't use ersatz array as last struct member; change usage.\n\tReported (implicitly, as part of)\n\thttps://trac.macports.org/ticket/53974\n\n2018-01-27  Hironobu Yamashita  <h.y.acetaminophen@gmail.com>\n\n\t* tfmload.c, dvips.h: Support new JFM spec (3-byte characters\n\tin TYPE > 0).\n\n2017-05-19  Karl Berry  <karl@tug.org>\n\n\t* Version 5.997 for TeX Live 2017 release.\n\n2017-03-27  Karl Berry  <karl@freefriends.org>\n\n\t* Makefile.am (AM_TESTS_ENVIRONMENT): use instead of TESTS_ENVIRONMENT.\n\n2017-03-22  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi: don't claim -q quiets standard error.\n\tReport from Igor Liferenko.\n\n2017-03-21  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* dvips.c: Show information and exit if dvips finds options\n\t--help or --version. Report from Igor Liferenko:\n\thttp://tug.org/pipermail/tex-k/2017-March/002748.html\n\n2017-03-18  Karl Berry  <karl@tug.org>\n\n\t* configure.ac,\n\t* NEWS\n\t* dvips.c,\n\t* dvips.h,\n\t* afm2tfm.c,\n\t* dvips.texi: version 5.997 for TL17.\n\n2017-02-28  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* dvips.c: In the case of -T option, reverse the default in the change\n\tmade on 2016-11-01. Thanks Ulrike Fischer:\n\thttp://tug.org/pipermail/tex-live/2017-February/039743.html.\n\n2016-12-13  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* emspecial.c: Fix a bug in emspecial(), reported by Norbert Klingen:\n\thttp://tug.org/pipermail/tex-live/2016-December/039483.html.\n\n2016-11-08  Karl Berry  <karl@freefriends.org>\n\n\t* dvips.texi,\n\t* NEWS: document new papersize special behavior and options.\n\tOriginal report at http://tex.stackexchange.com/questions/336545.\n\n2016-11-01  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* dospecial.c, dvips.c, dvips.help, protos.h, resident.c:\n\tAdd a new option -L*  Last special papersize wins.\n\tdvips -L0 ... gives the old behavior.\n\n2016-10-30  Karl Berry  <karl@tug.org>\n\n\t* output.c (INVALID_EPOCH_VALUE): define as (time_t) -1,\n\tto avoid warning with huge unsigned value on 32-bit systems.\n\t(open_output): don't duplicate writing of %%CreationDate.\n\n\t* dvips.texi (Invoking Dvips): TEXCONFIG does not include\n\t. by default.\n\n2016-07-15  Karl Berry  <karl@tug.org>\n\n\t* config.ps (ieeecs): new paper size for IEEE Computer Society\n\tJournals, requested by Michael Shell for his IEEEtran,\n\t13 Jul 2016 20:04:25.\n\n2016-06-29  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi: remove idvi reference, long gone.\n\n2016-05-20  Karl Berry  <karl@tug.org>\n\n\t* Version 5.996 for TeX Live 2016.\n\n2016-05-06  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* output.c: Avoid to crash for too large a value of SOURCE_DATE_EPOCH\n\t(w32 only). \n\n2016-05-04  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* output.c: Support SOURCE_DATE_EPOCH for %%CreationDate.\n\n2016-03-24  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* writet1.c: Fix one-byte buffer overflow bug reported by Hanno Boeck:\n\thttp://tug.org/pipermail/tex-live/2016-January/037686.html.\n\n2016-02-01  Karl Berry  <karl@tug.org>\n\n\t* dvips.1,\n\t* afm2tfm.1: ask for bug reports to go to tex-k.\n\n2016-01-21  Karl Berry  <karl@freefriends.org>\n\n\t* dvips.texi (Afm2tfm options) <-a>: document new option.\n\t* afm2tfm.c (openfiles): new option -a.\n\t(USAGE): include it in list for --help.\n\t(noaccentheightadjust): new global to remember it.\n\t(texheight): do nothing if -a is specified,\n\tor if the heuristically-guessed height is less than the original.\n\tBug report from Michael Sharpe.\n\n2015-07-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* test-dvips (removed): Renamed ...\n\t* test-dvips.test (new): ... into this.\n\t* Makefile.am: Better dependencies for 'make check'.\n\n2015-07-08  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am: Better dependencies for 'make check'.\n\n2015-05-21  Karl Berry  <karl@tug.org>\n\n\t* version 5.995 for TL'15.\n\n2015-04-17  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am (EXTRA_DIST): Adapted.\n\n2015-04-17  Karl Berry  <karl@tug.org>\n\n\t* contrib/PSTricks: remove this ancient copy of a PSTricks README.\n\t* special.lpro (/psfts, /startTexFig, /doclip, /endTexFig):\n\tremove these defns from (obsolete and nonfree) psfig.\n\t* testdata/special.pro: regenerate.\n\t* dvips.texi (Why Dvips): remove paragraph about psfig and\n\tother features that are no longer especially interesting.\n\tReport from Werner Fink, 14 Apr 2015 17:16:23.\n\n2015-03-15  Karl Berry  <karl@tug.org>\n\n\t* configure.ac,\n\t* NEWS\n\t* dvips.c,\n\t* dvips.h,\n\t* afm2tfm.c,\n\t* dvips.texi: version 5.995 for TL'15.\n\n2015-02-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am: Use the fragment ../../am/dist_hook.am.\n\n2014-07-15  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* t1part.c, t1part.h: Rename _HUGE => BORLAND_HUGE to avoid\n\tconflicting names.\n\n2014-06-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* afm2tfm.c, dospecial.c, emspecial.c, resident.c, writet1.c:\n\tAvoid undefined behaviour when char is signed.\n\n2014-06-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* {,squeeze/}Makefile.am: Drop the obsolete ACLOCAL_AMFLAGS.\n\n2014-04-17  Karl Berry  <karl@tug.org>\n\n\t* version 5.994 for TL'14.\n\n2014-01-27  TANAKA Takuji  <KXD02663@nifty.ne.jp>\n\n\t* dvips.c: Revise procedure of reading command line arguments.\n\t(Windows only)\n\n2014-01-13  TANAKA Takuji  <KXD02663@nifty.ne.jp>\n\n\t* dvips.c, resident.c: Allow multibyte string with 0x5c\n\tin CP932-like system. (Windows only)\n\t* dvips.c, output.c, search.c: Allow Unicode file names.\n\t(Windows only)\n\n2013-09-16  Karl Berry  <karl@tug.org>\n\n\t* writet1.c: formatting tweaks.\n\n2013-08-31  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* writet1.c (t1_subset_ascii_part): Remove UniqueID.\n\tReport from Christian Zietz (czietz/gmx/net),\n\ttex-k 01 Sep 2013 11:25:47 and previous.\n\n2013-08-05  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* bbox.c: Fix a bug in bbdopage() to obtain correct BoundingBox in\n\tvertical mode of pTeX.\n\n2013-05-30  Karl Berry  <karl@tug.org>\n\t\n\t* version 5.993 for TL'13.\n\n2013-04-07  Karl Berry  <karl@tug.org>\n\n\t* resident.c (getdefaults) <m>: if <= 0, set to INT_MAX.\n\tBug report from Stepan Orevkov and Bruno Delprat, as part\n\tof their Mayan TeX system (info on which:\n\thttp://tug.org/TUGboat/tb33-3/tb105delprat.pdf).\n\t\n        It seems there is a bug related to Dvips' section splitting and\n        partial font downloading/font reuse, such that only the\n        characters from the first section are available through the\n        entire output.  I wasn't up for dealing with that; as a\n        workaround, the above maximizes Dvips' memory available, so no\n        splitting is done.\n         \n2013-04-05  Karl Berry  <karl@tug.org>\n\n\t* configure.ac,\n\t* dvips.texi,\n\t* dvips.h,\n\t* afm2tfm.2c: 5.993 to prepare for TL'13 pretest.\n\n2013-03-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* same-name.test: New test with oname == iname.\n\t* Makefile.am: Add the new test.\n\n2013-03-18  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* dvips.c: Check if oname != iname.\n\n2013-02-08  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am (prologdir): Change texmf => texmf-dist.\n\n2013-01-21  Karl Berry  <karl@tug.org>\n\n\t* test-dvips: rename from dvips.test, to avoid new Automake 1.13\n\tmake check failure, since it can't create dvips.log in the\n\tevent that dvips.log already exists (from running dvips.texi).\n\tEven though one is in the srcdir and one in the builddir ...\n\tUse test-dvips rather than dvips-test just to help filename completion.\n\t* Makefile.am (TESTS): rename.\n\n2013-01-18  Karl Berry  <karl@tug.org>\n\n\t* writet1.c: apply diffs (cast removals) from pdftex.\n\n2012-12-17  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* squeeze/Makefile.am: Enable silent rules.\n\n2012-12-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* finclude.c: Drop unused variable (gcc-4.6 warning).\n\n2012-11-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am: Avoid use of deprecated INCLUDES.\n\n2012-08-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* ptexmac.h: Drop unused definition of M_PI & Co.\n\n2012-07-01  Karl Berry <karl@freefriends.org>\n\n\t* Release of 5.992 for TeX Live 2012.\n\n2012-04-01  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* dvips.c: do not free getenved string.\n\n2012-03-30  Norbert Preining  <preining@logic.at>\n\n\t* resident.c: add new directive \"c<filename> to config files, allowing\n\tto include other config files.\n\t* dvips.texi: document it.\n\t* contrib/config.proto: add example.\n\t \n2012-03-15  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am: Fixed a typo (in comment).\n\n2011-12-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am: Replace ${prefix}/texmf => $(datarootdir)/texmf.\n\n2011-10-20  Werner Fink <werner@suse.de>\n\n\t* dospecial.c (fgetboundingbox): Increase `buf' size to avoid\n\toverrun.\n\n2011-10-04  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am (EXTRA_DIST, DISTCLEANFILES): Make sure that\n\t'make distclean' removes all generated files.\n\n2011-07-26  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* bbox.c, dopage.c, dvips.c, pprescan.c, scanpage.c, dvips.1,\n\tdvips.help, dvips.info and dvips.texi: pTeX with otf package\n\tby S. Saito requires set2, put2, and independent options\n\t-noomega and -noptex.\n\n2011-06-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* afm2tfm.c (openfiles), resident.c (residentfont): Allow\n\tfind_suffix() to return a const string.\n\n2011-06-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* protos.h, loadfont.c (pkopen), search.c (pksearch): Declare\n\tfont name as const.\n\n2011-05-06  Karl Berry  <karl@tug.org>\n\n\t* writet1.c: update copyright as in pdftexdir.\n\n2011-04-25  Karl Berry  <karl@tug.org>\n\n\t* afm2tfm.c (version),\n\t* dvips.h (BANNER): 5.991 for TeX Live 2011.\n\t\n\t* dvips.texi,\n\t* dvips.1: do not suggest that the default output is to lpr.\n\n2011-02-25  Karl Berry  <karl@tug.org>\n\n\t* drawPS.c (flushDashedPath): cast to double before squaring,\n\tto avoid integer overflow.  (I guess this was hidden before by the\n\tassignment cast to float?  Said to work in 2009, failed in 2010.)\n\t* eepic-nan.test,\n\t* testdata/eepic-nan.tex,\n\t* testdata/eepic-nan.dvi,\n\t* testdata/config.pdf,\n\t* testdata/alt-rule.pro,\n\t* testdata/tex.pro: new files to test.  Report from Stefan Moser\n\tto mactex-support, 20 Oct 2010 02:37:45.\n\t* Makefile.am (tests): add eepic-nan,\n\t(EXTRA_DIST): add new files.\n\n2011-02-14  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* output.c: print R2 mode message only when secure == 2.\n\n2011-01-29  Karl Berry  <karl@tug.org>\n\n\t* search.c (search): report the actual popen call if D_FILES.\n\t* quotecmd.tex: make test filename match quotecmd-test.pl.\n\t* quotecmd.dvi: regenerate.\n\t* quotecmd-test.pl: doc fixes.\n\n2011-01-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am: Add testdata/quotecmd.dvi to EXTRA_DIST.\n\n2011-01-28  Karl Berry  <karl@tug.org>\n\n\t* quotecmd-test.pl, testdata/quotecmd.tex: doc fixes.\n\t* testdata/quotecmd.dvi: add to repo, since the test relies on\n\tthis file existing.\n\n2010-12-01  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writet1.c: Still more tweaks. Remove unused code and vars.\n\n2010-11-29  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writet1.c: Further reduce diffs against pdftex's writet1.c.\n\tDeclare t1_encoding as enum instead of int.\n\tChange t1_builtin_enc() from void to char **.\n\n\t* writet1.c, protos.h: Replace void load_enc(char *, const char **)\n\tby char **load_enc_file(char *).\n\t* download.c (getEncoding): Adapt, and change result to non-const.\n\tSomewhat better use of DOWNLOAD_USING_PDFTEX.\n\n2010-11-29  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writet1.c (t1_check_unusual_charstring): Drop unused variable.\n\n2010-11-26  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writet1.c: Still more minor tweaks.\n\n2010-11-26  Thanh Han The  <thanh@river-valley.org>\n\n\t* writet1.c (t1_check_unusual_charstring): switch EOL to space\n\tbefore appending.\n\n2010-11-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writet1.c: Still more formatting tweaks.\n\n2010-11-14  Karl Berry  <karl@tug.org>\n\n\t* writet1.c: endless formatting tweaks.\n\n2010-11-13  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* download.c: Change i<MAX_CHAR_CODE into i<=MAX_CHAR_CODE, because\n\tMAX_CHAR_CODE is 255 now.\n\n2010-11-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* download.c [MAX_CHAR_CODE]: Define as 255 (not 256).\n\n\t* writet1.c: More formatting and other trivial changes, to\n\tfurther reduce diffs against pdftex's writet1.c.\n\n2010-11-12  Karl Berry  <karl@tug.org>\n\n\t* writet1.c: formatting changes only, to reduce diffs against\n\tpdftex's writet1.c.\n\n2010-11-11  Thanh Han The  <thanh@river-valley.org>\n\n\t* writet1.c (t1_check_unusual_charstring): new fn.\n\t(t1_subset_charstrings): call it.  This resolves a bug reported by\n\tKnuth when there is a newline between the /CharStrings and the\n\tfollowing number (dict size).\n\n2010-10-23  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* output.c (hvpos): simplify the change 2010-10-22.\n\tMany thanks Peter.\n\n2010-10-22  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* output.c (hvpos): recover the old code in hvpos() for japanese\n\tbecause the changed code leads to incorrect result in some cases.\n\tother cases than japanese are not affected.\n\n2010-10-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* search.c (selfautoloc_prog): #include <kpathsea/concatn.h>\n\tfor WIN32 and drop cast of concatn() results.\n\n2010-06-19  Yan Li  <yan.i.li@intel.com>\n\n\t* tfmload.c (name): increase size to 500.\n\t(tfmopen): check for name length overflow.\n\n2010-06-13  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi: update for 2010.\n\n2010-06-04  Karl Berry  <karl@tug.org>\n\n\t* afm2tfm.c (version),\n\t* dvips.h (BANNER): 5.99 for TeX Live 2010 (pretest 2, maybe final).\n\n2010-05-25  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* config.ps: include cid-base.map.\n\n2010-05-25  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* search.c: quote command in W32 case to allow path name\n\twith spaces.\n\n2010-05-18  Karl Berry  <karl@tug.org>\n\n\t* config.h (type1path): rename from type1.\n\t* writet1.c (t1_open): use type1path, not headerpath.\n\n\t* configure.ac (AC_INIT),\n\t* afm2tfm.c: (version),\n\t* dvips.c (main), \n\t* dvips.h (BANNER): 5.99/pretest, 2010.\n\n2010-05-14  Karl Berry  <karl@tug.org>\n\n\t* resident.c,\n\t* output.c: more sprintf -> snprintf.\n\n2010-05-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* dvips.h [SET_BINARY]: Add cast to void.\n\t* afm2tfm.c, finclude.c, output.c, search.c (SET_BINARY): Once\n\tagain remove casts to void.\n\n2010-05-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* all files: Remove more useless casts to void.\n\n\t* afm2tfm.c, finclude.c, output.c, search.c: Reintroduce a few\n\tcasts to void, to avoid warnings (statement has no effect).\n\n2010-05-10  Karl Berry  <karl@tug.org>\n\n\t* drawPS.c,\n\t* flib.c,\n\t* finclude.c,\n\t* afm2tfm.c,\n\t* hps.c,\n\t* emspecial.c,\n\t* dospecial.c: more snprintf.\n\n\t* all files: remove useless casts to void.\n\n\t* dosection.c (dosection),\n\t* dospecial.c (dospecial): use snprintf, just in case.\n\n2010-05-07  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* output.c: correct wrong boundary values of characters.\n\t(from Takuji Tanaka <KXD02663@nifty.ne.jp>.)\n\t* protos.h, dvips.c, output.c, resident.c: remove unnecessary SJIS option.\n\t(from Takuji Tanaka <KXD02663@nifty.ne.jp>.)\n\t(a commit r18123 seemes to be eliminated, so try again)\n\n2010-05-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* dosection.c (dosection): Add newline before \"@start\".\n\t* testdata/*.pro, testdata/*.xps: Updated.\n\n2010-05-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* bbox.c: Declare functions used only in this file as static,\n\tremove trailing whitespace.\n\t* color.c: The same.\n\t* dosection.c: The same.\n\t* dospecial.c: The same.\n\t* dpicheck.c: The same.\n\t* drawPS.c: The same.\n\t* dviinput.c: The same.\n\t* dvips.c: The same.\n\t* emspecial.c: The same.\n\t* finclude.c: The same.\n\t* header.c: The same.\n\t* hps.c: The same.\n\t* loadfont.c: The same.\n\t* output.c: The same.\n\t* papersiz.c: The same.\n\t* repack.c: The same.\n\t* resident.c: The same.\n\t* t1part.c: The same.\n\t* tfmload.c: The same.\n\t* unpack.c: The same.\n\t* virtualfont.c: The same.\n\t* writet1.c: The same. Skip compilation of unused functions.\n\t* protos.h: Remove all these extern declarations.\n\t* t1part.h: Remove unused K&R function declarations.\n\n2010-05-06  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi: use p@TeX{} for the manual.\n\n2010-05-05  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* output.c: revert cmdout() and remove lastspecial=1 in jscout().\n\tThanks Peter.\n\n2010-05-05  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* output.c: rewrite the previous fix not to change the output format\n\tfor non-pTeX dvi.\n\n2010-05-05  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* output.c: minor fix of the function cmdout(). Without the fix, broken\n\tps is generated for pTeX's dvi.\n\n2010-05-05  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tImplement pTeX extensions, based on patches sent by Akira.\n\tModified to reproduce former output files. Added -noptex option.\n\t* bbox.c, color.c, dopage.c, dospecial.c, download.c, drawPS.c,\n\tdvips.[ch], finclude.c, fontdef.c, loadfont.c, output.c,\n\tpprescan.c, prescan.c, protos.h, protos_add.h, repack.c,\n\tresident.c, scanpage.c, search.c, skippage.c, tex.lpro,\n\ttfmload.c, virtualfont.c: pTeX extensions.\n\t* dvips.1, dvips.help, dvips.texi: Documentation.\n\n2010-05-03  Jan Lieskovsky  <jlieskov@redhat.com>\n\n\t* dospecial.c (predospecial, bbdospecial): avoid numeric overflow.\n\ttetex-3.0-CVE-2010-0739,1440-integer-overflows.patch,\n\tfrom Ludwig Nussel, Karel Srot.\n\ttlsecurity mail 30 Apr 2010 16:59:37.\t\n\n2010-04-26  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* afm2tfm.c: (write16()): cast argument to short to avoid warning.\n\n2010-04-25  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* writet1.c (edecrypt()): cast argument to byte to avoid warning.\n\t* dvips.c: Use IS_DIR_SEP for the test of a directory separator.\n\n2010-04-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am (EXTRA_DIST): Add afm2tfm-test.pl.\n\n2010-04-11  Karl Berry  <karl@tug.org>\n\n\t* afm2tfm.c (staticligkern): restore spaces around semicolons,\n\taccidentally removed in source cleanup.\n\t\n        * afm2tfm.c (throughout): use snprintf where needed.\n\n\t* afm2tfm-test.pl: New test script for afm2tfm.\n\n\t* Makefile.am (TESTS): Add the new test.\n\n2010-03-29  Karl Berry  <karl@tug.org>\n\n\t* loadfont.c,\n\t* tfmload.c,\n\t* virtualfont.c: concatn terminates with NULL.  From Akira.\n\n2010-03-28  Karl Berry  <karl@tug.org>\n\n\t* all files: no spaces before semicolons.\n\n\t* loadfont.c,\n\t* tfmload.c,\n\t* virtualfont.c,\n\t* bbox.c,\n\t* writet1.c,\n\t* dvips.c,\n\t* header.c: dynamically concatenate more error strings.\n\t* protos.h (errbuf): increase.\n\n2010-03-26  Karl Berry  <karl@tug.org>\n\n\t* virtualfont.c (badvf, virtualfont): use concat[n] instead of\n\t\tsprintf for error messages.\n\t(<kpathsea/concatn.h>): #include.\n\n\t* virtualfont.c (vfopen): do not sprintf too long of a name.\n\tCVE-2010-0827, found by Dan Rosenberg.\n\n\t* dospecial.c (predospecial): avoid seg fault from integer overflow.\n\tCVE-2010-0739, found by Marc Schoenefeld, patch prepared\n\tby Jindrich Novy.\n\n2010-02-26  Karl Berry  <karl@tug.org>\n\n\t* search.c (selfautoloc_prog, quote_name): remove kpse_ prefix for\n\tthe time being, since it seems web2c's safeness stuff can't be\n\teasily factored into using them.\n\n2010-02-23  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* search.c: #include <kpathsea/variable.h> for kpse_var_value.\n\n2010-02-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am (EXTRA_DIST): Add the new files.\n\n2010-02-19  Karl Berry  <karl@tug.org>\n\n\t* search.c (kpse_self_autoloc_prog) [WIN32]: p needs to be\n\twritable.  From Akira.\n\n2010-02-18  Karl Berry  <karl@tug.org>\n\n\t* Makefile.am (TESTS): add quotecmd-test.pl.\n\t* quotecmd-test.pl,\n\t* testdata/quotecmd.tex: new files.\n\t* search.c (search): selfautoloc gunzip, and quote name before\n\tcalling popen.\n\t(kpse_quote_name, kpse_self_autoloc_prog): new fns,\n\tonly temporarily here until we factor out the common code from\n\ttexmfmp.c.\n\n2010-02-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* dvips.c (main): Add '#if defined(KPSE_DEBUG)' to allow\n\tcompilation with '-DNO_DEBUG'.\n\n2010-02-12  Karl Berry  <karl@tug.org>\n\n\t* search.c: remove non-KPATHSEA code.  It just got too confusing\n\tto keep track of which conditional we were in.  (And non-KPATHSEA\n\thasn't actually worked or been used for many years, as far as I know.)\n\n2010-02-01  Karl Berry  <karl@tug.org>\n\n\t* dvips.h: switch banner to 5.98dev\n\t* writet1.c (append_cs_return): cast to byte * to avoid warning.\n\n2010-01-03  Karl Berry  <karl@tug.org>\n\n\t* output.c (copyfile_general) <default>: write newline\n\tafter writing possibleDSCLine.\n\t* beginfontk1.test,\n\t* testdata/beginfontk1.{tex,eps}: new test.\t\n\tReport from T S, 1 Jan 2010 16:32:16,\n\tfix from Akira Kakuto, 02 Jan 2010 09:07:19.\n\n\t* Makefile.am (TESTS_ENVIRONMENT): set TEXFONTS instead of\n\tTFMFONTS, VFFONTS, and TEXFONTMAPS.\n\n2010-01-02  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi (Debug options),\n\t* dvips.1: update.\n\tReport at http://bugs.debian.org/269638.\n\n2009-12-24  Karl Berry  <karl@tug.org>\n\n\t* INSTALLATION: rm stale file.\n\t* reencode: remove stale dir, except ...\n\t* contrib/treen.sh, contrib.treen2.sh: ... preserve this.\n\t* Makefile.am (EXTRA_DIST): update\n\n\t* AUTHORS, README, dvips.1, contrib/config.proto: doc updates.\n\t* INSTALL: remove, completely stale.\n\n2009-12-22  Karl Berry  <karl@tug.org>\n\n\t* debug.h (D_MEM): disable completely by defining to 0.\n\tMemory allocations just don't seem to be interesting.\n\n2009-12-21  Karl Berry  <karl@tug.org>\n\n\t* protos.h (fil2ps): remove decl.\n\t* dospecial.c (fil2ps): remove fn.\n\t(dospecial): warn if iff2ps or tek2ps specials are noticed.\n\tThe goal here was to avoid executing external programs, with that\n\tinhererent security risk, when (we believe) no one is actually\n\tusing the functionality.\n\n2009-12-14  Karl Berry  <karl@tug.org>\n\n\t* emspecial.c (emspecial):\n\tIncrease size of emunit to 30.\n\tIncrease size of emstr to 250.\n\tAttempt to check that we don't overflow emstr.\t\n\tReport from Alexander, tlsec 02 Dec 2009 00:28:33.\n\n\t* pc: remove obsolete subdir.\n\t* Makefile.am (EXTRA_DIST): rm.\n\n2009-12-11  Alexander Cherepanov  <cherepan@mccme.ru>\n\n\t* protos.h (hash): change decl.\n\t* resident.c (hash): return and use unsigned instead of int.\n\ttlsec mail, 05 Dec 2009 19:09:56.\n\n2009-09-26  Karl Berry  <karl@tug.org>\n\n\t* config/config.ps (unknown): move to before nopaper; else\n\tnonstandard paper sizes, e.g., with the geometry package,\n\tend up unrecognized.\n\n2009-08-26  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* testdata/dvipstst.xps, pfbincl.xps: Update for version 5.98.\n\n2009-08-25  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tAvoid maximal compiler warnings. Done in steps.\n\n\tStep 1: Move all extern decls for global variables to headers.\n\t* Makefile.am: Additional file 'protos_add.h'.\n\t* protos.h: Add prototype for fliparse() from flib.c.\n\tRemove prototypes from squeeze.c (now in squeeze/).\n\tAdd extern decls for globals from dopage.c, dosection.c,\n\tdvips.c, flib.c, hps.c, loadfont.c, output.c, pprescan.c,\n\trepack.c, resident.c, search.c, and tfmload.c.\n\t* color.c, dosection.c, dospecial.c, download.c, dpicheck.c,\n\tdrawPS.c, dviinput.c, emspecial.c, finclude.c, fontdef.c,\n\theader.c, makefont.c, output.c, paths.h, pprescan.c,\n\tprescan.c, repack.c, resident.c, scanpage.c, skippage.c,\n\ttfmload.c, virtualfont.c: Drop extern declarations.\n\t* writet1.c: Remove '#ifndef pdfTeX' sections of code.\n\tDrop extern declarations.\n\t* dvips.c, hps.c: #include \"protos.h\" before defining globals.\n\tDrop extern declarations.\n\t* protos_add.h (new): First #include \"protos.h\", then add\n\textern decls for stack from dopage.c and name from loadfont.c.\n\t* bbox.c, dopage.c, flib.c, loadfont.c, search.c:\n\t#include \"protos_add.h\" (instead of protos.h). Drop externs.\n\n\tStep 2: Avoid warnings: declaration of 'xxx' shadows a parameter\n\tor previous local:\n\t* dospecial.c (predospecial): Rename local numbytes=>num_bytes,\n\tnot to shadow function param.\n\tDrop inner local j, not to shadow previous local.\n\n\tStep 3:\n\t* afm2tfm.c (vlevout, vlevnlout), download.c (clearExtraGlyphList):\n\tANSI C function definitions, i.e., '()'=>'(void)'.\n\n\tStep 4: Constification of strings:\n\tStep 4a: Struct members\n\t* afm2tfm.c (encoding.name, encoding.vec, adobeinfo.adobename,\n\tlig.succ, lig.sub, kern.succ, pcc.partname),\n\tdospecial.c (KeyDesc.Entry),\n\tdownload.c (seenEncodings.name, seenEncodings.glyphs),\n\tdvips.h (header_list.Hname, papsiz.name, papsiz.specdat),\n\temspecial.c (emunit.unit), t1part.c (tablecommand.command,\n\ttypefonts.extension, type_key.name).\n\tStep 4b: Global or static variables\n\t* afm2tfm.c (staticligkern, vplligops, encligops, fontname,\n\tcodingscheme, interesting, accents), dospecial.c (ValStr, tasks),\n\tdvips.c (oname, infont, headerfile, helparr),\n\temspecial.c (extarr), output.c (hxdata), papersiz.c (scalenames),\n\tresident.c (psmapfile),\n\tt1part.c (RefKey, hexstr, AfmKey, InfoKey),\n\twritet1.c (hexdigits), protos.h.\n\tStep 4c: Function parameter/results and local variables\n\t* afm2tfm.c (error, interest, expect, findadobe, makebcpl,\n\tchecksum, texheight),\n\tdospecial.c (specerror, IsSame, dospecial, fil2ps),\n\tdownload.c (getEncoding, addGlyph, downpsfont),\n\tdvips.c (help, error_with_perror, error, initialize, newstring,\n\tmain),\n\tfinclude.c (scan_fontnames, scanfontusage, scanfontcomments),\n\theader.c (add_name, add_name_general, checkhmem, add_header,\n\tadd_header), hps.c (set_bitfile), loadfont.c (badpk),\n\toutput.c (copyfile_general, copyfile, cmdout, mhexout, nlcmdout,\n\tncstrcmp, paperspec), papersiz.c (myatodim[B\n\tresident.c (bad_config, getdefaults, getpsinfo),\n\tsearch.c (search, pksearch, my_real_fopen), tfmload.c (badtfm),\n\tunpack.c (unpack), virtualfont.c (badvf),\n\twritet1.c (pdftex_fail, pdftex_warn, load_enc, t1_open_fontfile,\n\tt1_subset), protos.h.\n\tStep 4d: Work around modifying const strings (e.g., modify\n\tmalloc'ed or strdup'ed strings before assigning them to a const\n\tstring variable):\n\t* afm2tfm.c (openfiles), dvips.c (newstring, newoutname),\n\tresident.c (getdefaults).\n\n2009-08-22  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* afm2tfm.c, dvips.c: #include <kpathsea/version.h> and drop\n\tnested extern decls.\n\n2009-07-17  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writet1.c (t1_flush_cs): cast ptr diff to unsigned long for\n\tprinting.\n\tNB: sizeof(ptr)==sizeof(long) for both 32Bit and 64Bit systems.\n\n2009-07-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* squeeze/squeeze.c (__CYGWIN__): #include <unistd.h> and <io.h>\n\tfor isatty and setmode.\n\n2009-06-22  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am (AM_CFLAGS): enable compiler warnings.\n\n\t* Use ANSI C function definitions and prototypes instead of\n\tP[1-9][CH] macros, declare some functions as static.\n\t* config.h, writet1.c: no need to #include <kpathsea/c-proto.h>.\n\t* writet1.c: #include <stdarg.h>, not <kpathsea/c-vararg.h>.\n\n\t* dpicheck.c: #include \"protos.h\".\n\n\t* t1part.c (Reeverse, KillUnique): declare as static.\n\n\t* writet1.c: #include \"protos.h\".\n\t(append_cs_return): remove unused variable 'i'.\n\t(t1_flush_cs): avoid uninitialized warning.\n\t* protos.h: add prototypes for writet1(), t1_free(), and\n\tt1_subset() from writet1.c.\n\n\t* Avoid inconsistent arg1 in KPATHSEA version of pksearch (was\n\tunused but different in prototype, declaration, and call).\n\t* loadfont.c: remove arg1 of pksearch.\n\t* protos.h: use prototype for pksearch as defined in search.c.\n\t* search.c: #include \"protos.h\", remove prototype for newstring.\n\t(pksearch): remove unused arg1.\n\n2009-06-22  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.am (AM_CPPFLAGS): remove -DNeedFunctionPrototypes.\n\t* config.h, dvips.h: always use ANSI C function definitions.\n\n2009-06-12  Francois Charette  <firmicus@ankabut.net>\n\n\t* afm2tfm.c: rename getline to texlive_getline.\n\n2009-06-01  Karl Berry  <karl@tug.org>\n\n\t* Update version numbers to 5.98.\n\n2009-05-30  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* texc.script: use correct invocation of sed.\n\n2009-05-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tAdapt to TL2009 build system.\n\n2009-05-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* testdata/*: recover old test data and add missing pieces.\n\t* texc.script: use sed instead of ed (which may be missing).\n\n2009-05-24  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi (Configuration file commands): document -G,\n\tincluding its obsolesence.\n\t* Master/texmf/dvips/tetex/config.pdf: remove the G setting,\n\tnow actively problematic.  Report from Uwe Siart,\n\t04 May 2009 09:27:27.\n\n2009-05-08  Karl Berry  <karl@tug.org>\n\n\t* resident.c (getpsinfo): avoid accessing unallocated downbuf[-1].\n\t* dvips.c (main): do not check iname[-1] if there is no iname.\n\tReports from Akira.\n\tAlso prettify some related error messages.\n\n2009-04-04  Karl Berry  <karl@tug.org>\n\n\t* writet1.c (append_cs_return): new fn.\n\t(cs_mark): check for missing return in subr.\n\t(t1_flush_cs): repair missing return.\n\t(t1_scan_param): check for negative lenIV.\n\tThese changes from Thanh, following more investigation by Melissa,\n\tChoF, and Thanh.\n\n2009-03-24  Karl Berry  <karl@tug.org>\n\n\t* writet1.c (t1_flush_cs): t1_lenIV >= 0, not\n\tt1_lenIV > 0, to fix subset problems on Macs.  Found by Melissa\n\tO'Neill.  Reported on ntg-pdftex@ntg.nl and pdftex@tug.org,\n\t21 March, 2009 13:45:12.\n\n2009-02-16  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi (Config file paper sizes): document.\n\t* config.ps (nopaper): new paper size to put no paper size\n\tcommands in the output, e.g., for multi-page EPS.\n\tReport from John Bowman for Asymptote.\n\n2008-11-02  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi (psfonts.map): apparently {somefile.pfb} was never\n\tused to report partial downloading; also mention vf's a bit more.\n\n2008-09-24  Karl Berry  <karl@tug.org>\n\n\t* hps.c, hps.lpro: Mark (doyle/aps/org) does not want to be\n\tnotified of changes any longer (or for the past decade or so :).\n\n2008-09-22  Karl Berry  <karl@tug.org>\n\n\t* hps.c (do_html): get scale factors right.\n\t(hoff, voff): remove, hh and vv are already calculated by using\n\thoff and voff in dopage.c.\n\tFrom Akira.  Report from John Frampton through tex-eplain;\n\tusing -O made -z fail.\n\n2008-09-20  Karl Berry  <karl@tug.org>\n\n\t* papersiz.c (myatol): do not require a leading zero, to match the doc.\n\tFrom Akira.  Report from John Frampton through tex-eplain.\n\n2008-07-10  Karl Berry  <karl@tug.org>\n\n\t* dvips.h (BANNER): 5.97, 2008.\n\t* dvips.c (main): use BANNER.\n\t* afm2tfm.c: 5.97.\n\t* dvips.texi (version): 5.97.\n\t\n2008-05-07  David M. Jones  <dmj@ams.org>\n\n\t* output.c (copyfile_general): pass through binary characters such\n\tas CTRL-D inside %%BeginFont, else embedded pfb's can get mangled.\n\ttex-live mail 5 May 2008 13:11:10, tex-k mail 5 May 2008 14:08:04.\n\n2008-05-01  Karl Berry  <karl@tug.org>\n\n\t* squeeze.c [O_BINARY]: conditionalize calls to SET_BINARY.\n\n2008-04-30  Karl Berry  <karl@tug.org>\n\n\t* squeeze.c (SET_BINARY) [O_BINARY]: conditionalize #define.\n\tCast call to specialout.  (From Akira.)\n\n2008-04-29  Karl Berry  <karl@tug.org>\n\n\t* Makefile.in (install-data): do not cd $(srcdir) in any rule,\n\tthat fails when the install program is specified by a relative path.\n\n\t* squeeze.c: avoid all old-system conditionals, linking with\n\tkpathsea, etc.\n\n2008-04-28  Karl Berry  <karl@tug.org>\n\n\t* dvips.h: id.\n\t* squeeze.c [!KPATHSEA]: conditionalize #undef fopen,\n\tand add decl with return type.\n\t* afm2tfm.c: semi-prototype fopen if it got #undef'd.\n\tBug report from vvv, 27 Apr 2008 13:43:37.\n\n2008-02-29  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* acconfig.h: removed.\n\n2008-02-17  Karl Berry  <karl@tug.org>\n\n\t* config.ps (smallbook): new paper size for Texinfo.\n\n2008-01-31  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tConvert from autoconf-2.13 to autoconf-2.59+:\n\t* Makefile.in: Add @configure_input@ line.\n\t* aclocal.m4 (new): Generated (aclocal -I ../m4).\n\t* configure: Regenerated (autoconf).\n\n2007-12-23  Karl Berry  <karl@tug.org>\n\n\t* dvips.c (helparr): Start options with -, include url.\n\n2007-12-02  Karl Berry  <karl@tug.org>\n\n\t* skippage.c (skippage): do not test for noomega here; we aren't\n\tactually parsing the DVI operations, so argument bytes can\n\terroneously cause complaints.\n\tReport on tex-live from W. Fleischer, 27 Nov 2007 17:43:47.\n\n2007-10-24  Karl Berry  <karl@tug.org>\n\n\t* config.ps (unknown): duplicated entry, remove one.\n\n2007-10-22  Karl Berry  <karl@tug.org>\n\n\t* hps.c (stamp_external, stamp_hps): protext against long strings.\n\tFrom Bastien Roucaries via Norbert, 21 Oct 2007 13:22:19,\n\tDebian bug 447081.\n\n2007-10-12  Karl Berry  <karl@tug.org>\n\n\t* resident.c (i): declare as int, in case tfmload() returns 65536\n\tfor an ofm font.\n\tFrom Akira, 11 Oct 2007 11:39:52.\n\n2007-09-24  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi (psfile special): document llx/lly/urx/ury, based on\n\ta description from Tom R.\n\n2007-08-28  Karl Berry  <karl@tug.org>\n\n\t* dvips.h: clarify license (again).\n\n2007-06-13  Karl Berry  <karl@tug.org>\n\n\t* config.ps: use integral mm values (from Akira).\n\n2007-06-10  Karl Berry  <karl@tug.org>\n\n\t* dospecial.c: implement ps::nobreak for Scott (Pakin); we need\n\tto break by default because pstricks is written to assume that,\n\tand we can't ask Herbert to rewrite thousands of lines of code.\n\n2007-05-31  Karl Berry  <karl@tug.org>\n\n\t* hps.c (finish_hps): remove head.tmp and body.tmp unless\n\twe are debugging.  Report from Dan Luecking, 25 May 2007 13:00:17,\n\tfix from Akira.\n\n2007-05-09  Karl Berry  <karl@tug.org>\n\n\t* dvips.c, finclude.c: cleanups of my patching from Akira.\n\n2007-05-06  Karl Berry  <karl@tug.org>\n\n\t* finclude.c, dvips.c: keep track of last-unused psname (Akira).\n\t* dvips.c (DEFRES): move down.\n\t* dvips.c (--help): just mention Tom R.\n\n2007-05-05  Karl Berry  <karl@tug.org>\n\n\t* dvips.h (DOWNLOADEDPSSIZE): new constant.\n\t* dvips.c (downloadedpsname): new global array.\n\t* finclude.c: set it up as we download.\n\t* download.c: use it to avoid downloading fonts as both header\n\tand font.  (From Akira.)\n\n2007-05-04  Karl Berry  <karl@tug.org>\n\n\t* dvips.h (BANNER): change to 5.96dev to distinguish from the release.\n\n\t* header.c (add_name, add_header): cast result of\n\tadd_header_general to int and return it.  From Akira.\n\n2007-03-23  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi: document it.\n\t* dvips.c, loadfont.c, resident.c: also report map files\n\tand config files, if the envvar DVIPSDEBUG is set.  From Akira.\n\n2007-03-20  Karl Berry  <karl@tug.org>\n\n\t* download.c, output.c, emspecial.c: report full pathnames,\n\tto help debugging and for consistency with TeX.  From Akira.\n\n2007-03-19  Karl Berry  <karl@tug.org>\n\n\t* config.ps (screen): add this, 8.25x11, for powerdot.  (From Akira.)\n\n2006-12-09  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi (Config file paper sizes): best match now.  (From Akira.)\n\n2006-12-07  Karl Berry  <karl@tug.org>\n\n\t* Changes made and accumulated by Akira:\n(1) security problem\n    -R0  : shell escape and absolute path are allowed\n    -R1  : shell escape is forbidden and absolute path is allowed\n           (default)\n    -R2  : shell escape and absolute path are forbidden\n\n(2) line breaking problem in ps: special (Scott Pakin).\n\n(3) Heiko's change of hps.lpro.\n\n(4) paper size problem:\n  *   Is the dimension close enough for a match?  We use a quarter inch\n  *   as a match; this is 65536*72.27/4 or 1,184,072 scaled points.\n--->\n  *   Is the dimension close enough for a match?  We use 5bp\n  *   as a match; this is 65536*72.27*5/72 or 328909 scaled points.\nand dvips now finds the best match rather than the first match.\n\n2006-12-06  Karl Berry  <karl@tug.org>\n\n\t* output.c (copyfile_general): add removingBytes=0, to avoid\n\tomitting the line after %%EndData or %%EndBinary with -K1.\n\ttex-k mail from t s, 29 Nov 2006 21:11:14.\n\n2006-12-05  Karl Berry  <karl@tug.org>\n\n\t* dvips.h (BANNER): bump version to 5.96 for 2006, why not.\n\n2006-07-06  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi: mention -tunknown to avoid floating to predefined\n\tpaper size. From Vincent Fourmond, tex-k mail, 25apr06.\n\n2006-06-02  Karl Berry  <karl@tug.org>\n\n\t* dvips.texi: typo\n\n2004-05-10  Karl Berry  <karl@tug.org>\n\n\tFrom Matthew Swift <swift@alum.mit.edu>, via Debian bug 181065:\n\t* config.ps: improve comments.\n\t* output.c (open_output) [DJGPP]: do not disable writing to a pipe\n\t\twhen secure; we don't do that in the non-DJGPP case.\n\t* dvips.texi (Option details): -R does not disable output to a pipe.\n\t(Configuration file commands): typo in `o' doc.\t\t\n\nWARNING:  THIS CHANGELOG IS WAY OUT OF DATE.\n\n2001-06-02  Sebastian Rahtz  <sebastian.rahtz@computing-services.oxford.ac.uk>\n\n\t* resident.c: added option to config file ('z') to have the same\n\teffect as -R (secure mode)\n\nMon Jan 10 21:39:20 CET 2000\n\t* from pdftex distribution: improved partial font downloading\n\tported back\n\t* .notdef related fixes for afm2tfm\n\nSun Apr 11 09:03:29 CEST 1999\n\t* output.c: (from Tom Rokicki)\n\tFaster inclusion of DOS EPSF files. Use byte counter to avoid\n\tcalling ftell().\n\nWed Apr  7 01:07:41 CEST 1999\n\t* Makefile.in: added -DSHIFTLOWCHARS to compiler flags\n\t* output.c: corrected T1Char function for SHIFTLOWCHARS\n\nMon Mar  9 10:31:44 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* clean reencoding/asex.enc; small fix to copyright year (from\n\tThomas Esser)\n\nFri Mar  6 10:56:28 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* dvips.h (BANNER): changed to 5.78, as per Tom. also afm2tfm.c\n\tand dvips.c\n\n\t* tex.lpro: (from Tom Rokicki)\n\tRichard Sites of Adobe found a bug in dvips that\n \tcauses dvips-generated output, when piped through Distiller, to\n \tfail.  The problem is that dvips uses names in its encoding array\n \tthat are `illegal' according to distiller.  I've encouraged him to\n \tpatch up distiller to `do the right thing', but I need to fix\n \tdvips too. The patch I've come up with is to change, in tex.lpro,\n\n\t    0 1 255 {IE S 1 string dup 0 3 index put cvn put} for\n\t to\n\n\t 2 string 0 1 255 { IE S dup 360 add 36 4 index cvrs cvn put } for pop\n\nTue Mar  3 10:15:37 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* afm2tfm.c: Tom Browder <tbrowde@asi-fwb.com>. To fix the case\n\twhere the afm file has a -1 for the CC encoding position\n\nWed Feb 25 10:52:19 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* patches to add facility to shift characters below 32 to higher\n\tpositions, if possible, activated by -G. By default, this is not\n\tactivated, needs -DSHIFTLOWCHARS in the Makefile, as I am not sure\n\tabout it, but the conditional code is there to study for those who\n\twant to experiment\n\nTue Feb 24 11:56:52 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* Makefile.in: clean up check target to be self-contained\n\nMon Feb 23 10:11:57 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* resident.c: changed parsing of \"<<\" so that the font is passed\n\tthrough to be treated as a font, not a procset. it will still be\n\tpartially downloaded, though.\n\nTue Feb 17 10:17:40 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* dvips.c: logic of #ifdef Omega was reversed for help message,\n\tcorrected\n\nMon Feb 16 12:33:30 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* afm2tfm.c: fixes for explicit extension by Thomas Esser:\n\tSeveral things did not work as expected:\n  - removing the suffix by putting \\0 at the position found by\n    find_suffix(outname) does not work, as find_suffix returns the\n    position *after* the last dot\n  - memmove(outname, p, strlen(p)) (where p = basename(outname))\n    should be memmove(outname, p, strlen(p)+1), but I think that\n    we should just use two strcpy calls since memmove is not\n    available on every platform.\n\n\nMon Feb  9 10:56:25 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* put data files for \"make check\" into testdata/, to avoid them\n\tbeing zapped by \"make extraclean\"\n\n\t* patch to dvips.texi from Thomas Esser\n\t\nMon Feb  2 11:32:32 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* small fix in make check target of Makefile.in\n\nTue Jan 27 14:32:25 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* configure etc: new configure.in, c-auto.in, Makefile.in from\n\tOlaf Weber\n\t\nTue Jan 27 13:49:11 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* ChangeLog: changes to \"check\" target (explicit -D\n\t300). regenerated .xps file.\n\nMon Jan 19 20:45:15 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* renamed contrib/volker config.* files to *.cfg, and to shorter\n\tnames (screen to scr) for DOS 8+3 naming\n\n\t* added .tfm and .vf files for make check to directory;\n\tchanged permissions of dvips.texi\n\nSat Jan 17 15:08:57 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t*  assorted patches from Peter Breitenlohner, Olaf Weber, \n \tFabrice Popineau etc. Hope it all still works.\n\nFri Jan 16 21:28:44 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* dvips.c: patch from John Plaice for odvips, to flag odvips as program\n\tname \n\nThu Jan  1 10:59:29 1998  Sebastian Rahtz  <s.rahtz@elsevier.co.uk>\n\n\t* provided prebuilt dvipstst.xdv and dvipstst.xps to allow\n\tcheck target to work. \n\nWed Aug 27 20:18:20 1997  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* stamp-auto: Remove this file, should be in build tree, not in\n\tsource tree.\n\n\t* configure.in: Make `configure' rebuild the `stamp-auto' file.\n\nSun Aug 24 18:04:14 1997  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* Makefile.in: Allow `make check' when $(srcdir) is not `.'.\n\nFri Mar 07 12:10:46 1997  Fabrice POPINEAU  <popineau@ese-metz.fr>\n\n\t* config.h: introduce prototyping when __STDC__ is defined.\n\t* dvips.h: defines a PROTO() macro according to __STDC__.\n\t* dvips.h: getenv() is declared here.\n\n\t* dvips.c:\n\t* emspecial.c:\n\t* output.c:\n\t* resident.c: use the PROTO() declaration.\n\t* resident.c: bad_config was called whitout argument.\n\t* squeeze.c: exit() declaration.\n\t\nThu Feb  6 17:34:06 1997  Karl Berry  <karl@cs.umb.edu>\n\n\t* Version 5.66a.\n\nSat Feb  1 17:15:39 1997  Karl Berry  <karl@cs.umb.edu>\n\n\t* t1part.c: Changes to avoid compiler warnings.  From Tom.\n\n\t* Makefile.in (program_files): dvipstst.dvi should be included\n\tfor make check.\n\tFrom: Joern Clausen <joern@techfak.uni-bielefeld.de>.\n\nSun Jan 19 12:47:37 1997  Karl Berry  <karl@cs.umb.edu>\n\n\t* Makefile.in (version): Now 5.66a.\n\t* dvips.texi: Update version number.\n\t* download, finclude.c, output.c: Update for new version.\n\nFri Jan 17 10:06:25 1997  Karl Berry  <karl@cs.umb.edu>\n\n\t* Makefile.in (version): Now 5.64a.\n\n\t* finclude.c, t1part.[ch], resident.c, output.c, download.c,\n\t\tdopage.c: Update for dvips 5.64.\n\n\t* afm2tfm.c (writevpl): No vname in CHARACTER property.\n\t(version): Now 8.1.\n\nTue Jan 14 14:50:27 1997  Karl Berry  <karl@cs.umb.edu>\n\n\t* hps.c (PAGESIZE): #undef.\n\nMon Jan 13 14:25:07 1997  Karl Berry  <karl@cs.umb.edu>\n\n\t* dvips.h (BANNER): Add www.radicaleye.com per Tom.\n\nSun Jan 12 10:57:34 1997  Karl Berry  <karl@cs.umb.edu>\n\n\t* texps.lpro: Change /setfont line to use cvx instead of load.\n\tFix from Tom, reported by poortom@apmisc.ibm.co.jp for the QMS 1725.\n\nSun Jan  5 12:05:54 1997  Karl Berry  <karl@cs.umb.edu>\n\n\t* Makefile.in: Remove special case for t1part.c, and add it to\n\tobjects.  We compile it normally now.\n\t* bbox.c, dospecial.c, drawPS.c, dvips.c, dvips.h, tex/epsf.tex,\n\tsearch.c, virtualfont.c, tex.lpro, finclude.c\n\tafm2tfm.c: Updates for dvips 5.62.\n\nMon Dec  9 17:24:58 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* t1part.c (CHAR) [WIN32]: #define as CHARACTER to work around\n\t<windows.h> typedef.\n\nSat Dec  7 17:21:37 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* dospecial.c (system): Don't bother to declare, it returns an int.\n\n\t* afm2tfm.c, dvips.c, emspecial.c, output.c, resident.c: Various\n\tWIN32 changes from Fabrice.\n\nTue Dec  3 01:25:28 1996  Ulrik Vieth  <vieth@thphy.uni-duesseldorf.de>\n\n\t* afm2tfm.c: Fix version message.\n\nMon Dec  9 01:29:41 1996  Ulrik Vieth  <vieth@thphy.uni-duesseldorf.de>\n\n\t* afm2tfm.c: Reformat usage message slightly for consistency.\n\tIssue \"Try --help\" message if called with no args.\n\nTue Dec  3 01:25:28 1996  Ulrik Vieth  <vieth@thphy.uni-duesseldorf.de>\n\n\t* afm2tfm.c: Fix version message.\n\nThu Nov 28 09:33:13 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* resident.c: Pass explicit error strings to bad_config.\n\t* dvips.h (INT_FORMAT) [SHORTINT]: Define as %ld or %d.\n\n\t* t1part.c (ScanChars): Cast label[counter].select, which is a char,\n\tto int, for the sake of machines where char is unsigned by default,\n\tsuch as the RS/6000.\n\nWed Nov 27 10:06:27 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* Makefile.in (program_files): Don't bother to include dvipstst.dvi.\n\nFri Nov 15 16:22:42 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* Makefile.in (install-exec): Use INSTALL_LIBTOOL_PROG for\n\tbinaries.\n\nSun Nov 10 16:29:31 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* t1part.c (PartialPFB): Return value from fread is an int,\n\tnot a pointer, so don't compare to NULL.\n\nThu Nov  7 14:53:08 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* papersiz.c (myatodim, myatol): If error, give the erroneous string.\n\nSun Oct 27 16:20:58 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* Makefile.in (check): Don't run TeX.\n\t(program_files): Distribute dvipstst.dvi.\n\n\t* resident.c (c_lineno): Remove invalid second declaration.\n\n\t* t1part.c (PartialPFA): Cast UniRealloc result to avoid warning\n\tfrom SunOS cc.\n\t(UniRealloc) [KPATHSEA_TYPES_H]: Define as xrealloc, not just realloc.\n\nSun Oct 20 11:25:27 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* Makefile.in (install-data): mkdirchain dvips_plain_macrodir.\n\t(post-dist): Link in tex.\n\t*.tex: Move to tex/ subdirectory.\n\nFri Oct 18 14:51:03 1996  Karl Berry  <karl@cs.umb.edu>\n\n\tFrom: Marek Rouchal <marek@btfmd1.fs.uni-bayreuth.de>.\n\tThese changes finish implementing multiple epsf output files.\n\t* bbox.c (findbb): Pass in bop location.\n\t* dvips.c: for -i, default section size to one page.\n\tChange call to initprinter.\n\t* output.c (epsftest): Change call to findbb.\n\t(initprinter): Take sectiontype as parameter instead of page count.\n\nMon Oct 14 11:25:13 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* Changes for NT from Fabrice POPINEAU <popineau@esemetz.ese-metz.fr>.\n\t* hps.c: Rename Rectangle to dvipsRectangle.\n\t* dvips.h (ERROR, NO_ERROR): #undef.\n\t* paths.h (DVIPSRC) [WIN32]: Define as dvips.ini\n\t* output.c: WIN32 conditionals a la MSDOS.\n\nSun Oct 13 13:40:26 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* dvips.c (main),\n\t* output.c (epsftest): Remove condition that document be a single\n \tpage for -E.\n \tSuggested by: Marek Rouchal <marek@btfmd1.fs.uni-bayreuth.de>.\n\n\t* bbox.c, dosection.c, download.c, drawPS.c, dvips.c, finclude.c,\n        fontdef.c, prescan.c, resident.c, virtualfont.c: Keep mag as a\n\treal instead of an integer.\n\tFrom: \"Melissa O'Neill\" <oneill@cs.sfu.ca>.\n\nTue Oct  8 16:47:13 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* Makefile.in (version_files): Add dvips.c.\n\nSat Oct  5 17:00:53 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* dvips.c (main),\n\t* afm2tfm.c (version): Change to the new standard GNU format.\n\n\t* Makefile.in (install-data): Call install-info.\n\t* dvips.texi: Use @url, @email, and @dircategory/@direntry.\n\t\nSat Sep  7 16:01:38 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* dvips.c (help): Include bug reporting address.\n\t* afm2tfm.c (usage): Likewise.\n\nFri Sep  6 19:05:23 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* output.c, dospecial: Call output_with_perror for PostScript\n\toutput file open failure.\n\t* dvips.c (error_with_perror): New routine.\n\nFri Aug 23 16:57:39 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* dvips.c (main): Better bad first/last page errors.\n\nSun Aug  4 15:56:50 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* dospecial.c: Updates from d.love, PAGEUS_INTERUPPTUS is now\n\tpage_interrupt, etc.\n\n\t* hps.c: Use mymalloc instead of malloc where we don't check the\n\treturn value.\n\n\t* dvips.c (main): Also print kpathsea_version_string if --version.\n\nFri Jul 26 15:47:20 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* Makefile.in: Remove co.make.\n\nThu Jul 11 19:17:52 1996  Karl Berry  <karl@laurie>\n\n\t* resident.c: Include variable.h.\n\nMon Jun 10 11:00:35 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* hps.c: Update again from Dave, the last patch got corrupted.\n\nFri Jun  7 18:46:46 1996  K. Berry  <kb@cs.umb.edu>\n\n\t* Makefile.in (afm2tfm, $(program)): Use $(kpathsea_link).\n        (squeeze): Include $(XLOADLIBES).\n\nSat Jun  1 14:36:39 1996  Karl Berry  <karl@cs.umb.edu>\n\n\t* resident.c (getdefaults): Use envvar/config value DVIPSRC if set.\n\nThu May 16 22:41:15 1996  Dave Love  <d.love@dl.ac.uk>\n\n\t* texc.lpro: Update to dvihps 0.4 (mostly robuster anchors?).\n\t* dopage.c, hps.c: Likewise.\n\nWed May  1 16:37:00 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * paths.h (DVIPSRC): Prepend $HOME/, so we only search for .dvips\n        in the user's home directory. (Original dvips behavior,\n        unwittingly changed, just noted by Michel Goossens.)\n\nFri Apr 26 13:36:25 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in (install-data): Install the plain macro files in\n        $(dvips_plain_macrodir), and avoid $(CP_R).\n\tFrom: Pierre Asselin <pa@magtsm.tdh.qntm.com>.\n\nSun Apr 21 16:32:43 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c (main): Do not pass in !dontmakefont to kpse_init_prog.\n        In 'M' command line case, call the new kpse_set_enabled fn.\n\nFri Mar  8 14:39:03 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * hps.c: qoutes -> quotes.\n\n        * dospecial.c: Don't complain about unknown specials if TEX_HUSH.\n\nThu Mar  7 11:15:34 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c (check_checksum): New routine.\n        * bbox.c, loadfont.c, tfmload.c, virtualfont.c: Call it.\n\n        * t1part.c (perror): Remove spurious #define, and change return's\n        to exit's after calling perror.\n        New copyright notice from Sergey.\n\nSun Mar  3 12:26:01 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * t1part.c: New version (1.59) from Sergey, fixing the problem\n        with lbma.\n\nWed Feb 28 15:19:30 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.texi: Document the new MISSFONT_LOG variable.\n\n        * Installed following update from Dave Love:\n        \nTue Jan 23 13:55:52 1996  D.J.G.Love  <d.love@dl.ac.uk>\n\n        * hps.c (PAGESIZE): Don't hardcode.\n\nMon Jan 22 19:34:38 1996  Dave Love  <d.love@dl.ac.uk>\n\n        * dopage.c: Update to dvihps 0.3c.\n        * dospecial.c: Likewise.\n        * hps.c: Likewise.\n        * hps.lpro: Likewise.\n\nTue Feb 27 17:06:42 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * afm2tfm.c (main): Need to call kpse_set_progname now that we are\n        using the afm search path.\n\n        * resident.c (addentry): Oops, another mistake in the partial\n        download merge.\n\nSun Feb 18 15:59:18 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * afm2tfm.c: Search for AFM file along new AFM path.\n\n        * hps.c: Use mymalloc, not plain malloc.\n        And replace dup_str with the existing xstrdup.\n\nThu Feb 15 13:56:07 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c (main): Set kpse_make_tex_discard_errors = quiet.\n\nSat Feb 10 14:03:12 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * afm2tfm.c (assignchars): Avoid creating texnum's > 255, since we\n         can't handle it.  Happens with an AFM line like:\n         C 256 ; WX 402 ; N c256 ; B 4 0 402 630 ;\n        Also, don't try to output kern equivalences for unencoded characters.\n        From: \"Dr Peter J. Braam\" <braam@stlawrence.maths.ox.ac.uk>.\n\nFri Feb  9 15:28:03 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * afm2tfm.c (usage): Include kpathsea_version_string in output.\n        Recognize --version and --help.\n\n        * tex.lpro: I had fixed texc.lpro, but that's not a source file.\n\n        * hps.c (PAGESIZE): Compute dynamically.\n        From: Dave Love <d.love@dl.ac.uk>.\n\nSat Feb  3 15:44:19 1996  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in (DEFS): Moved to common.make.\n\nFri Dec 29 17:17:14 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in: misc.make is now clean.make.\n\nTue Dec 26 17:18:39 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c (initialize): Initialize dontmakefont to\n        !MAKE_TEX_PK_BY_DEFAULT.\n\nWed Dec 20 15:38:31 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in (INSTALL): Use -D INSTALLONLY, rather than sed.\n        Manual changes to match.\n\nWed Dec 13 14:29:11 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c (DEFRES): Change to 600.\n\n        * afm2tfm.c: Do oslash <> o and Oslash <> O.\n        From: \"Young U. Ryu\" <ryoung@utdallas.edu>.\n\nSun Dec 10 16:41:05 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * dospecial.c (specerror): Hint that they're using an unsupported\n        macro package, most likely.\n\nFri Dec  1 16:08:52 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * test.tex: Rename to dvipstst.tex for clarity and include in\n        distribution.\n\tFrom: Joern Clausen <joern@techfak.uni-bielefeld.de>.\n\t\nThu Nov 16 13:32:50 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * search.c: Avoid popen on the Amiga.\n        * dvips.h (close_file): Make function declaration extern for the\n        Amiga. From Andreas Scherer.\n\nTue Nov 14 14:07:17 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * loadfont.c (pkopen): If font was substituted, don't say chars\n        will be left blank (they won't).\n\n        * resident.c (getdefaults): For R case, use line as a string,\n        changing whitespaces to colons, instead of doing numbers here.\n\nMon Nov 13 17:22:20 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c: Set kpathsea debugging bits even if -d is not first.\n\nSat Nov 11 16:01:24 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * texc.lpro: Add `Color LaserWriter 12/600 PS' to the list of\n        products that need the alternate rule definition.\n\n        * loadfont.c, dvips.c, virtualfont.c: Remove remaining MEM debugs\n        as too voluminous and not useful enough.\n        * debug.h (D_CONFIG): Reuse the D_MEM bit.\n        * resident.c (getdefaults): Output debugging info if requested.\n\nSun Oct 22 16:57:56 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in (squeeze): Use LIBS instead of LOADLIBES.\n\nSun Sep 24 13:49:43 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c (mymalloc): Test a local variable for debug output,\n        instead of DD_MEM.\n\nFri Sep 22 13:43:38 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c: If invalid option given, say what it was, and don't try\n        to list all the valid ones.\n        \n        * dvips.c (case o): make -o - output to stdout.\n\nThu Sep 14 14:49:53 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * config.ps: The default paper size cannot use setpagedevice.\n        From te.\n\nSat Sep  9 13:12:24 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * drawPS.c: Merge hyperdvi changes.\n        From: Dave Love <d.love@dl.ac.uk>.\n        \n        * config.h: Define TPIC and EMTEX by default.\n        * Makefile.in (DEFS): Instead of in DEFS.\n\nSat Sep  2 11:37:40 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * tex.lpro: Oops, missing if in the new code.\n\n        * epsf.tex: Don't do \\new... if we've already been read.\n\n        * config.ps: Update from Yves.\n\nWed Aug 23 11:55:59 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * config.h (headerpath): This is now kpse_ps_header_format, since\n        xdvi uses it, too.\n\n        * search.c (search): Try assigning to name and realnameoffile,\n        instead of copying.\n        * tfmload.c (name): Remove this static.\n        * loadfont.c (name): Declare as a pointer, instead of a fixed-size\n        array.\n\nSat Aug 12 13:42:22 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * tex.lpro: Check for LaserWriter 16/600 as well as Display and\n        NeXT when setting RMat.  From Tom R., reported by Rik Faith.\n\nFri Aug 11 14:42:14 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * resident.c (N): If we're doing -E, don't disable them.\n\nThu Aug 10 13:28:37 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * header.c, dvips.c (lastheadermem): Remove this global. It's no\n        longer used.\n        From: \"Christopher J. Duncan\" <cduncan@phys.psu.edu>\n        \n        * dvips.texi: Many updates.\n\nTue Aug  8 19:25:18 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in (post-dist): Include a README in reencode, update\n        for new fontname organization, don't include adobe file or fonts.\n        (install-data): Don't install fonts.\n\nMon Aug  7 17:46:43 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c: Rearrange help message.\n\nMon May 29 15:56:43 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in (install-data): Use $(srcdir)/{tex,fonts}; from zoo.\n        (But, we probably won't have inputs or fonts by release time anyway.)\n\nMon Apr 17 10:02:30 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in (squeeze, afm2tfm, $(program)): Use link_command.\n\nMon Mar 20 11:07:32 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * output.c: Print the > after reading the file, not before.\n\nFri Mar  3 14:49:16 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * afm2tfm.c (checksum): Use cyclic left shift, so we're not just\n        using the last four characters. From Piet.\n        (vname): New routine to better document the ligtable in the vpl.\n        (writevpl): If the base encoding is the same as the output\n        encoding, only output it once.\n        Also, don't output checksums; let vptovf and vftovp do that.\n        (addkern): New routine.\n        (checkligkern): If <>, make one character's kerning (Zcaron) be\n        the same as another's (Z).\n        (staticligkern): Define the default kerning equivalents.\n\nFri Feb 24 14:03:02 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c (main): Don't give `W' output if -q(uiet).\n\n        * config.ps (N): Don't define this by default.\n\nFri Feb 10 15:39:50 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c: Doc fix.\n\n        * Makefile.in (texc.lpro): Use $(srcdir)/tex.lpro. From Andreas.\n\nSun Jan  8 12:13:48 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * Version 5.58f.\n\nSun Jan  1 14:16:52 1995  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in (DEFS): Include -DEMTEX by default. Suggested by Joachim.\n\nSat Dec 31 17:33:14 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in: Don't include tmptk.make any more.\n        (install-exec): Don't depend on install-MakeTeXPK, either.\n\nMon Dec 26 07:58:37 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c (main): Don't set mfmode to / here, do it in kpse_init_prog.\n\nSat Dec 24 15:20:50 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * emspecial.c (TRUE, FALSE) [TRUE]: Make definitions conditional.\n        From Joachim Schrod <schrod@iti.informatik.th-darmstadt.de>.\n\nWed Dec 14 15:16:53 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * Version 5.58e.\n\nMon Dec 12 07:11:14 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * MakeTeXPK.in (pattern): Give right name in error message. From\n        nickc@cs.st-andrews.ac.uk.\n\nMon Dec  5 15:32:48 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * MakeTeXPK.in: Use $SAVEPWD instead of $PWD, for bash's sake.\n        From bas@phys.uva.nl (Bas de Bakker).\n\nSun Dec  4 16:34:59 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * dospecial.c (predospecial): Avoid scanning compressed files for\n        font comments. From Peter Whaite <peta@cim.mcgill.ca>.\n\nSun Nov 27 11:39:42 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * output.c: Remove unmatched ( in output.c.  From Philippe\n        Charnier <charnier@lirmm.fr>.\n\n        * Makefile.in (install-data): Test for nonexistence of config.ps\n        and psfonts.map before grepping in them, to avoid spurious error\n        or unnecessary redirection.\n\n        * config.h (MFMODE): Don't bother with this.\n        * dvips.c (main): If mfmode is not set, set it to /, not a\n        compile-time default.\n\nFri Nov 25 11:05:58 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * resident.c (getdefaults): Don't set oname in case 'o' if the\n        cmdline already did.\n        * dvips.c (oname_option): New global.\n        (main): Set if.\n\n        * dvips.c, resident.c: Make config.$PRINTER mode value override\n        config.ps. From heiko@lotte.sax.de and Michael\n        C. Grant <mcgrant@rascals.stanford.edu> (independently).\n\n        * MakeTeXPK.in: Restore the umask 0. Requested by\n        Yves.Arrouye@imag.fr and others.\n\n        * texc.script: Don't pass single - arg to ed; Linux loses.  From\n        heiko@lotte.sax.de (Heiko Schlittermann).\n\nTue Nov 15 16:20:48 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in (targets.make): This is split up now.\n\nSun Nov  6 16:10:33 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * configure.in: Run autoupdate.\n\nSun Oct 30 16:17:22 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in (post-dist): Remove texc.lpro. From\n        interran@uluru.Stanford.EDU.\n\nTue Oct 25 17:47:48 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * Version 5.58c.\n\nSun Oct 23 17:41:24 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * config.h (MFMODE) [!MFMODE]: Define to be \"cx\".\n        * dvips.c (mfmode): Initalize to MFMODE, new option -mode to set it.\n        * resident.c (getdefaults): For case M, only get the new mode if\n        it wasn't specified on the command line.\n\nTue Oct 18 07:15:42 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * MakeTeXPK.in: Reformat the MakeTeXPK.site line so Autoconf will\n        substitute for both occurrences. (Actually, I think was my bug in\n        make/targets.make for not doing global sed substitutions.)\n\nSun Oct 16 20:42:47 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.texi: Distinguish somewhat more clearly between dvips and\n        Dvipsk.\n\n        * dospecial.c (dospecial): In \" case, there was never supposed to\n        *be* a closing quote in the \\special, so go back to the original.\n\nFri Oct 14 10:32:38 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * Version 5.58b.\n\nTue Oct 11 15:28:44 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * Makefile.in (install-exec): mkdirchain $(fontdir), for the sake\n        of MakeTeXPK.\n\n        * dospecial.c (dospecial): In \"...\" case, don't send closing quote.\n\nSun Oct  9 16:57:25 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * MakeTeXPK.in: Source $psheaderdir/MakeTeXPK.site if it exists.\n        Also, add pk/ into the default destination path if we have map files.\n\nThu Oct  6 14:36:41 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c: Don't call help () twice for -?, and support --help and\n        --version.\n\nSun Oct  2 16:42:25 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * resident.c (SET_CLIENT_PATH): New macro; strdup path values from\n        the config file.\n        (getdefaults): Call it.\n\n        * psfonts.map: Add more obliques for the standard fonts.  From\n        te@informatik.uni-hannover.de.\n\n        * search.c (secure) [SECURE]: Put this back.  From\n        hank@automat.uni-essen.de.\n\nSat Oct  1 20:25:42 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * MakeTeXPK.in: Make egrep pattern search for the base font, not\n        just $NAME.\n\nSat Sep 24 16:53:36 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c (o and f cases): Do not set noenv.  This makes dvips\n        always read the config files.\n\nThu Sep 22 15:35:22 1994  Karl Berry  <karl@cs.umb.edu>\n\n        * dvips.c: Remove `got a new papersize' messages.\n        * resident.c (getpsinfo): Allow multiple spec's a la download's.\n\nMon Sep 19 11:55:13 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (post-dist): Just link to the fontname dvips\n        directory, since it has all the encoding files.\n\nMon Sep 12 11:04:46 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Version 5.58a.\n\n        * dospecial.c: Remove my warning stuff; Tom did it his way.\n\nSun Sep 11 14:49:31 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Update for dvips 558.\n\n        * Makefile.in (psconfigfile): Remove this variable, and just use\n        config.ps; we would never install anything else anyway.\n        (uninstall-data): Install psfonts.map and config.ps if they didn't\n        exist.\n\nSat Sep 10 13:45:28 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * MakeTeXPK.in (ps_to_pk case): Only parse psfonts.map if we are ps2pk.\n\n        * dvips.texi: Fix overfull boxes.\n\n        * Makefile.in (post-dist-*): Include .aux/.cps in distribution.\n\nWed Sep  7 12:04:36 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Version 5.55b.\n\n        * afm2tfm.c (assignchars): Forget the outenname stuff; I just\n        noticed -u (pedantic).\n\nSun Sep  4 07:19:05 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * loadfont.c: Include c-pathmx.h.\n\nSat Sep  3 13:03:55 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (install-data): Install the .enc files.\n        (uninstall-data): And uninstall them.\n\nFri Sep  2 11:55:34 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (default): New target.\n        (makeargs): No need for this.\n\n        * psfonts.map: Include entries for *0, to accomodate the !@#$% latex2e.\n\nTue Aug 30 14:21:42 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * dospecial.c (dospecial, GetKeyVal): Add case for warning.\n\n        * dvips.texi (Special Font Effects): Mention outlined fonts.\n\n        * bbox.c (floor): Do not declare this.\n\n        * Makefile.in (distclean): Don't need this.\n\nMon Aug 29 16:53:48 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * configure.in (AC_OUTPUT): No more fonts/Makefile.\n        * Makefile.in (install-data): Use CP_R.\n\nThu Aug 25 14:19:18 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * config.h (D_SEARCH): New debug bit.\n        * dvips.c (dvips): Set it.\n        * dvips.texi: Document it.\n\nTue Aug 23 14:21:06 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * afm2tfm.c (assignchars): Don't add additional characters if\n        an explicit output encoding was specified.\n\n        * MakeTeXPK.in: Remove ;landscape hacks.\n\nSun Aug 21 10:58:11 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (mtp_destroot): Toss this.\n        (MakeTeXPK): Substitute fontdir instead.\n\nSat Aug 20 16:13:28 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * MakeTeXPK.in (DESTDIR): Deal with ;landscape in the mode.\n\nFri Aug 19 13:42:22 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * MakeTeXPK.in: Consistently use mf instead of $mf.\n        (MODE): If `default', guess, so users can specify a destdir with\n        no mode.\n\nTue Aug 16 09:28:35 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (sauterdir): Change to .../src.\n        (MakeTeXPK): Substitute for it.\n\n        * MakeTeXPK.in: Don't echo the args; let kpathsea do it.\n\nSat Aug 13 17:14:54 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in: Use $@ where possible.\n\nFri Aug 12 10:54:19 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * dopage.c (floor): Do not declare.\n\nTue Aug  9 13:53:12 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * dvips.c (-D): Set mfmode to the empty string.\n\n        * MakeTeXPK.in: Don't bother trying at +-1 now.\n        * fontdef.c (newfontdesc): kpse_magstep_fix the dpi calculation.\n\nSun Aug  7 19:34:57 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * loadfont.c (pkopen): Free the filename if necessary.\n\nTue Aug  2 15:02:59 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * config.h, dvips.c (D_DB_BUILD): Replace with D_HASH.\n\nSun Jul 31 14:49:22 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * special.lpro (startTexFig): Set magscale to true. From Tom.\n\n        * MakeTeXPK.in (pointsize): Improve sed expression to extract\n        this. From jsacco@ssl.com.\n\nFri Jul 29 12:01:50 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in: Use ac_include.\n        (install-{exec,data}): Different strategy for ensuring always-true\n        exit status.\n\nThu Jul 28 15:38:04 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (install-exec): Check for MakeTeXPK in $(scriptdir),\n        not $(bindir). From john@minster.york.ac.uk.\n\nFri Jul 15 11:46:20 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * virtualfont.c (vfopen): Don't append .vf here, kpathsea does it.\n        * tfmload.c (tfmopen): Likewise.\n\n        * dvips.c (main): Call kpse_set_progname first.\n\nTue Jul  5 14:01:33 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * MakeTeXPK.in (DVIPSHEADERS): Set this, and export it for\n        gsftopk.\n\nFri Jun 24 17:09:19 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * config.h (D_*): Add defns to pass to kpathsea.\n        (*path): Define as the kpse enum constants.\n        * most files: Remove extern char * decls of path variables.\n        * search.c: Pass in the format, not the path.\n        * resident.c (checkenv): #if 0 out.\n\nThu Jun 23 16:56:50 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * loadfont.c (pkopen): Don't set the ..._ENABLED bit; kpathsea\n        does that now.\n        * paths.h (*_ENVS): Move these to kpathsea.\n        * dvips.c (tfmpath, pkpath, etc.): Delete these; they're in the\n        kpathsea structure now.\n\nTue Jun 14 12:41:48 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (depend_encies): Remove.\n\nMon Jun 13 10:09:09 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * loadfont.c (pkopen): Don't call kpse_set_maketex_mag here,\n        let kpathsea do it. Also don't set MAKETEX_DPI, it's not used.\n\nSat May 28 19:08:50 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * PSfonts: Rename to fonts, for consistency with dviljk.\n        * Makefile.in: Change the cd's.\n\nThu May 26 16:29:54 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * loadfont.c (name): Make size be PATH_MAX.\n        * search.c (search, pksearch): Set name.\n        * virtualfont.c (name): Replace definition with extern.\n\n        * virtualfont.c (virtualfont) [DEBUG]: Print memory stats if\n        D_MEM, not D_FONTS.\n        * loadfont.c (loadfont): Likewise.\n\n        * resident.c (getpsinfo): Ignore whitespace after a <.\n\nTue May 24 13:14:08 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * resident.c (checkenv): Always set MAKETEX_BASE_DPI, for the sake\n        of missfont.log, even if dontmakefont.\n\nThu Apr 28 12:14:50 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * output.c (cleanprinter): Call perror if file writing failed.\n\nThu Apr 21 13:24:58 1994  Karl Berry  (karl@ra.cs.umb.edu)\n\n        * config.h (SHORTINT): Define if SIZEOF_INT < 4.\n\nSun Apr 17 16:13:16 1994  Karl Berry  (karl@ra.cs.umb.edu)\n\n        * debug.h (fopen): Do not define this; we'll use kpathsea's fopen\n        debugging support now.\n        * dvips.c (main): 'd' flag calls KPSE_DEBUG_SET (KPSE_DEBUG_FOPEN).\n\n        * Makefile.in (texc.lpro): Use $(SHELL) to run texc.script.\n        (top_srcdir): Define this for configure to substitute.\n\nTue Apr  5 11:51:32 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * MakeTeXPK.in (sauterdir): Substitute for this value.\n        Various other Sauter fixes from barthel@uaimzm.Mathematik.Uni-Mainz.DE.\n        * Makefile.in (sauterdir): Make it a variable.\n\nSun Apr  3 10:21:41 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Version 5.55a.\n\nFri Apr  1 11:52:42 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * resident.c (checkenv): Allow envvars {DVIPS,TEX}SIZES to\n        override the R config file line.\n\n        * Update for dvips 5.55.\n\nThu Mar 24 10:43:03 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * search.c (search): must_exist is false for VF files.\n\nTue Mar 15 07:21:04 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (distclean): Remove PSfonts/Makefile. From John I.\n\nFri Mar 11 14:51:04 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * MakeTeXPK.in: Echo `gsftopk failed' to stderr, not stdout.\n\nThu Mar  3 08:51:50 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Version 5.528a.\n\nThu Feb 24 16:19:55 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (installargs): Pass fontdir and ps_fontdir.\n\nTue Feb 22 11:41:13 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (c-auto.h.in): Include SMART_PUTENV.\n\nMon Feb 21 16:47:21 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * MakeTeXPK.in: Default to appending the mode, and allow an extra\n        arg to specify the destination directory. From neal.\n\n        * dvips.c (newoutname): | means pipe.\n\n        * afm2tfm.c: Remove declarations of exit.\n\n        * loadfont.c (pkopen): Cast args to kpse_bitmap_tolerance for the\n        sake of non-ANSI compilers.\n\nSun Feb 13 11:32:48 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Update for dvips 5.528.\n\nWed Feb  2 09:06:20 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Version 5.526b.\n\n        * loadfont.c (pkopen): Don't complain if the two dpi's can\n        tolerate each other.\n\n        * dvips.c (helparr): Mention -pp.\n\n        * dvips.1: Change char92 to \\. From karney@theory.pppl.gov.\n\nTue Feb  1 11:31:30 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (install-data): Add || true to the install_fonts, so\n        Ultrix make doesn't quit prematurely.\n\n        * Makefile.in (c-auto.h.in): New target.\n\nSat Jan 22 14:25:02 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Version 5.526a.\n\n        * loadfont.c (pkopen): Set dontmakefont=1 at the first failure.\n\nThu Jan 20 14:17:04 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * search.c (search) [SECURE]: Don't allow reading of an absolute_p\n        file. From maj@cl.cam.ac.uk.\n\nSun Jan 16 14:55:08 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (mtp_destdir): Change to $(fontdir)/pk.\n\nFri Jan 14 15:27:17 1994  Karl Berry  (karl@cs.umb.edu)\n\n        * Update for dvips 5.523.\n\n        * MakeTeXPK (MODE): Remove guess for lview monitor, that no one in\n        the world uses but me.\n\nSat Dec 18 12:49:10 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* dvips.texi (Config File Options): Enumerate the envvars that\n\toverride the P path. (From worsch@ira.uka.de.)\n\nThu Dec 16 12:32:21 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK.in: Say where gsftopk can be ftp'd.\n\nFri Dec 10 15:29:34 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* finclude.c (scanvm): Remove declaration of atol, as it causes\n\ttrouble with glibc.  From kayvan@satyr.sylvan.com.\n\nThu Dec  9 09:44:34 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK.in: Add gsftopk stuff, guess ljfour for 600 dpi, allow\n\tuser envvars to override, other cleanups. gsftopk stuff from\n\tR.Kooijman@et.tudelft.nl.\n\nTue Dec  7 14:01:30 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* loadfont.c (pkopen): Call kpse_set_maketex_mag instead of\n\tfind_mag_str.\n\t* Makefile.in (objects): Remove makefont.o.\n\n\t* dvips.texi (Installation): Mention that MakeTeXPK's interface is\n\tdifferent in dvipsk.\n\n\t* dvips.c (main): Make -v print the version number and exit.\n\nSat Nov 27 14:55:28 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* resident.c (INIT_PATH): Use the current value for the default,\n\talso. Change calls.\n\n\t* resident.c (getdefaults): Improve error message.\n\t(getpath): Expand a default value here; change callers to pass\n\tcompile-time default, instead of previous value.\n\nSun Nov 21 15:34:21 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* resident.c (checkenv) [DEBUG]: Correct #endif placement.  From\n\tpnoma@wk.estec.esa.nl.\n\nSun Nov 14 11:56:19 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (mtp_destdir): texfontdir has been renamed.\n\nFri Nov 12 19:42:21 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK.in: Document the final echo in no uncertain terms.\n\nThu Nov 11 10:58:41 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK.in (pointsize): Don't assume the fontname starts with `cm'.\n\nSat Nov  6 07:15:17 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK.in: test $d should have been test -d.\n\nWed Nov  3 14:43:05 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.521a.\n\nFri Oct 29 13:24:01 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (program_rm): Take out paths.h.\n\nTue Oct 26 11:38:35 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* drawPS.c (arc): Consistently check for nonsquare aspect ratios.\n\tFrom Ulf.Niemeyer@fernuni-hagen.de.\n\nSun Oct 24 19:26:37 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* resident.c (checkenv): Let TEXCONFIG override the config path,\n\tas it's supposed to.\n\nSat Oct 23 14:51:37 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK.in: Check for the GF file being at +1 or -1 of the dpi\n\twe were asked for. Apparently the DC fonts are generated this way.\n\nFri Oct 22 13:09:29 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* resident.c (checkenv): Set kpse_override_path to pkpath, so a\n\tconfig file value will be found.\n\n\t* emspecial.c, dospecial.c (atoi): Do not declare here, as it\n\tconflicts with the Linux system decl.\n\n\t* dvips.texi (Install): Be more precise about when config.ps and\n\tMakeTeXPK are overwritten.  From gv@me.umn.edu.\n\n\t* paths.h.in: Move paths to kpathsea/paths.h.in, and rename to paths.h.\n\t* Makefile.in (paths.h): Remove this dependency.\n\n\t* Makefile.in ($(kpathsea)): Depend on files in kpathsea_srcdir.\n\t(install-exec): MakeTeXPK is not in srcdir anymore.\n\t(install-data): The prologues aren't in srcdir. The info files\n\tmight be in either place.\n\tFrom simon@lia.di.epfl.ch.\n\nTue Oct 19 12:07:25 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MACHINES: New entries from simon.\n\nSat Oct  9 07:06:26 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (MakeTeXPK): Make executable.\n\n\t* Makefile.in (distclean): MakeTeXPK removed at mostlyclean now.\n\nThu Oct  7 09:58:48 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK.in: Missing \", and don't assume sauterdir exists.\n\nWed Oct  6 08:50:06 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.519b.\n\nSat Oct  2 17:30:45 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (install-*): Don't reassign PATH, just invoke\n\tmkdirchain explicitly.\n\n\t* Makefile.in (dvips_makeargs): Delete, since now unused.\n\nFri Oct  1 07:09:29 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK.in: Don't try to put the MF command into a variable;\n\tquoting rules are too confused.\n\nWed Sep 29 15:21:49 1993    (karl@terminus.cs.umb.edu)\n\n\t* Version 5.519a.\n\nTue Sep 28 13:23:45 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* resident.c (print_path): Don't compare char to NULL.\n\n\t* resident.c (lastresortsizes): Declare as an unsigned array.\n\n\t* loadfont.c (pkopen): ifdef out the dead code.\n\nSat Sep 25 11:33:21 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (mtp_destdir): New variable.\n\t(MakeTeXPK): New target.\n\t* MakeTeXPK.in: New file.\n\n\t* resident.c (getdefaults): Set envvar MAKETEX_MODE in M case.\n\nFri Sep 24 11:47:55 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* resident.c (checkenv): Initialize kpse_fallback_font.\n\nThu Sep 23 17:53:48 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* resident.c (checkenv): Check for DVIPSFONTS.\n\t* dvips.texi (Environment variables): Document it.\n\nSun Aug 29 11:45:52 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* resident.c: No leading spaces before #'s.\n\n\t* Makefile.in (install-*): Use $(PATH) instead of $$PATH.\n\n\t* config.h (DEBUG) [NO_DEBUG]: Define this.\n\nFri Aug 27 10:27:34 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* paths.h.in (DVIPS_{HEADER,PICT}_ENVS): New defines.\n\t* resident.c (getpath): Make a copy.\n\t(getdefaults): Go back to calling getpath.\n\t(checkenv): Change kpse_init_path calls to pass default.\n\t* dvips.c (*path): Initialize to default paths.\n\n\t* dvips.c (tfmpath, pkpath, vfpath, figpath, headerpath): All\n\tstrings now, not string *'s.\n\t* tfmload.c (tfmpath): Likewise.\n\nWed Aug 25 14:35:30 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Update for dvips 5.519.\n\nSun Aug 22 19:13:42 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (install-data): Install the fonts last.\n\n\t* Makefile.in (install-*): mkdirchain is in the top level.\n\nTue Aug 10 10:34:30 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in: Remove reference to -DFONTLIB.\n\t(objects): Remove flib.o.\n\nFri Aug  6 09:04:45 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* resident.c (checkenv): Look for DVIPSHEADERS.\n\nThu Aug  5 09:03:31 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.518a.\n\n\t* Makefile.in (default_config_path): Add ~.\n\nWed Aug  4 13:50:36 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK: Announce that we're running.\n\n\t* Makefile.in: Major surgery to conform to new scheme.\n\nSat Jul 31 11:36:15 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* configure.in: Remove AC_PREFIX.\n\nTue Jul 27 15:00:44 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Update for dvips 5.518.\n\nSun Jul 25 10:43:45 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (install*): Add $(srcdir) to PATH for mkdirchain, not .\n\nWed Jul 21 19:46:22 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (configclean): New target.\n\nSun Jul 11 16:20:41 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK: Output the filename we generate to stdout, if we succeed.\n\nTue Jul  6 08:40:25 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK: Send all output to stderr.\n\nMon Jul  5 09:32:30 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in: Various configuration changes from xdvik.\n\n\t* paths.h.in (DEFAULT_{TFM,PK,VF}_PATH): Remove.\n\nFri Jul  2 12:00:05 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* configure.in: sinclude common.ac.\n\nTue May 25 10:09:02 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* configure.in (AC_HAVE_HEADERS): Test for `pwd.h'.\n\nSat May 22 11:21:34 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (dist): Run gzip -9.\n\nFri May 21 10:14:25 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* resident.c: Change #if DEBUG to #ifdef.\n\nThu May 20 11:48:28 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* psfonts.map: Add URW fonts.\n\nTue May 18 13:58:55 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (install-*): mkdirchain on install dirs, and put\n\tmkdirchain in the dist.\n\nSun May 16 17:47:26 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* dvips.texi: Do paragraph indentation from command.\n\t* Makefile.in (MAKEINFO_FLAGS): New variable.\n\nMon May 10 07:13:29 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.516a.\n\nSun May  9 10:35:58 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (extraclean): add *.i and *.s.\n\nSat May  8 13:11:16 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (dist): Rewrite for kpathsea.\n\t* <many>.c, config.h: Use <kpathsea/foo.h> instead of \"foo.h\".\n\nTue May  4 14:56:57 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (info, dvi): New targets.\n\nSat May  1 16:21:41 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Update for dvips 5.516, and kpathsea library.\n\nFri Apr 23 16:46:29 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* configure.in (AC_CONST): Add this.\n\nTue Apr 20 06:58:31 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* pathshare from web2c.\n\nSun Apr 11 18:57:39 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.515b.\n\nSat Apr 10 14:58:56 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* config.h (UNIX_ST_NLINK): Define unless on foreign OS.\n\n\t* Makefile.in (uninstall*): New targets.\n\n\t* Makefile.in (scriptdir): New variable.\n        (install): Install MakeTeXPK there.\n\n\t* configure.in: Do AC_XENIR_DIR after AC_DIR_HEADER.\n\nMon Mar 29 08:28:22 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.515a.\n\n\t* Makefile.in (default_tfm_path): Put . first.\n\nSun Mar 28 16:43:50 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Update for dvips 5.515.\n\nMon Mar 22 06:12:25 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.12c.\n\nSun Mar 14 14:51:03 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK (MFINPUTS): Append a colon to be sure and get the\n\tsystem default path.\n\nSat Mar 13 11:04:26 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (CPPFLAGS): Add @DEFS@, for -DHAVE_CONFIG_H.\n\nMon Mar  8 06:27:11 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.12b.\n\nMon Mar  1 06:26:28 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.512a.\n\nSun Feb 28 12:03:16 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (dist): Get lucida.sty.\n\nThu Feb 25 14:02:02 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK (MFINPUTS): Include the old cwd before changing to\n\tTEMPDIR.\n\nTue Feb 23 16:51:38 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (dist): Copy info files to my local info directory.\n\nMon Feb 22 06:19:46 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.499c.\n\nWed Feb 17 06:45:29 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (INSTALL): Use tr instead of grep to remove the\n\tInfo control characters.\n\nSun Feb 14 17:11:10 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (install): Split into install-exec and install-data.\n\nFri Feb 12 08:34:45 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* dvips.1: Don't refer to dvips.tex.\n\nTue Feb  9 20:27:50 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* MakeTeXPK: Create DESTDIR if it doesn't exist.\n\nSun Feb  7 10:01:25 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.499b.\n\n\t* Makefile.in (install): dir is a shell variable, not a make\n\tvariable; fix logic for original MakeTeXPK, etc.\n\nTue Feb  2 11:41:10 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (install): Don't install over a modified MakeTeXPK,\n\tconfig.ps, or psfonts.map.\n\n\t* Version 5.499a.\n\nSun Jan 31 07:08:44 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (install): Allow install_subdirs to be empty.\n\nFri Jan 29 17:38:04 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (CPPFLAGS): Don't bother with `-I.'.\n\nWed Jan 20 07:53:36 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* config.h (FATAL*): Now in lib.h.\n\n\t* Version 5.497c.\n\nMon Jan 18 08:19:57 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* PSfonts: Merge PStfms and PSvfs.\n\nSat Jan  9 15:21:30 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (configure, config.status): cd $(srcdir) first.\n\nSun Jan  3 19:43:20 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* config.h: Move some includes to c-std.h.\n\nFri Jan  1 13:57:24 1993  Karl Berry  (karl@cs.umb.edu)\n\n\t* configure.in, c-auto.h.in, c-memstr.h, dirio.h: Changes for\n\tnew Autoconf.\n\nWed Dec 23 06:57:20 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.497b.\n\nThu Dec 17 07:13:35 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* dvips.c (main) [DEBUG]: Missing part of fprintf.\n\n\t* resident.c (checkenv) [DEBUG]: Had figpath instead of pkpath.\n\nMon Dec 14 07:27:39 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.497a.\n\nFri Dec 11 15:23:58 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* afm2tfm.c, dospecial.c, emspecial.c, finclude.c: Change ctype\n\treferences to use uppercase macros.\n\nThu Dec 10 10:36:13 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* GNUmakefile.in (GNUmakefile): Add $(srcdir) to dependency, and\n\tuse $(SHELL) instead of sh.\n        (config.status): Use $(SHELL).\n\nTue Dec  8 07:19:52 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (.texi.info): Add `-o $@'.\n\nSat Dec  5 18:50:09 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* Update for version 5.497.\n\nSun Nov 29 17:25:52 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* finclude.c (atof) [!STDC_HEADERS]: Make declaration conditional.\n\nSun Nov 22 11:11:24 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (install): Test for non-null install_subdirs.\n\nSat Oct 31 07:56:41 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* encodings/texm{sym,ital,ext}.enc: New files.\n\n\t* dvips.texi: Remove the `eg$ ' from examples.\n\nWed Oct 28 07:43:50 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* Version 5.495b.\n\nTue Oct 27 06:07:20 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (.lpro.pro): Depend on squeeze; also, use a temp\n\tfile to avoid creating empty files.\n\n\t* Makefile.in (checkenv) [DEBUG]: Conditionalize use of D_PATH.\n\n\t* Makefile.in (.texi.info): New suffix rule, to avoid use of $< in\n\tnormal rules.\n\n\t* Makefile.in (distclean): Remove */Makefile.\n\nSat Oct 24 11:48:14 1992  Karl Berry  (karl@ds3.cs.umb.edu)\n\n\t* Makefile.in (install): Quote $(install_subdirs), in case it's\n\tbeen set to empty.\n\n\t* Makefile.in (texfontdir): New variable.\n        (install): mkdir it and the ps subdirectories.\n\nSat Oct 17 16:39:02 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (install_subdirs, subdirs): New variables.\n        (install): make install in $(install_subdirs).\n        (dist): Dist $(subdirs).\n        (installargs): Make arguments to pass to subdirs.\n        (ps{tfm,vf}dir): New target directories.\n        * configure.in (AC_OUTPUT): Create Makefiles in the install subdirs.\n\n\t* Makefile.in (paths.h): Don't depend on Makefile and Makefile.in\n\t-- they change too often for other reasons than paths.\n\n\t* Makefile.in (check): New target.\n\n\t* Makefile.in (objects): Include `emspecial.o'.\n\n\t* Update for dvips 5.495.\n\nThu Oct 15 08:34:33 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* configure: Ran Autoconf 1.2.\n\nSat Oct 10 12:20:02 1992  Karl Berry  (karl@cs.umb.edu)\n\n\t* Makefile.in (dist): Don't copy any subdirs.\n        * README: Document what we've changed and what we haven't.\n\nWed Sep 23 07:51:13 1992  Karl Berry  (karl@cs.umb.edu)\n\n        * Version 5.493c.\n\nSun Sep 20 12:52:24 1992  Karl Berry  (karl@cs.umb.edu)\n\n        * Makefile.in (config.status): use sh to run configure --no-create.\n\n        * Makefile.in (realclean): OK, don't remove configure.\n\nThu Sep 17 07:40:27 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.493b.\n\nMon Sep 14 17:59:53 1992  Karl Berry  (karl@hayley)\n\n        * Makefile.in (config.status): new target.\n        (Makefile): depend on config.status.\n\nThu Sep 10 08:57:33 1992  Karl Berry  (karl@hayley)\n\n        * Makefile.in (dist): include COPYING*.\n\n        * Makefile.in (realclean): remove configure.\n\n        * MakeTeXPK: run gftopk ./<filename>, in case an old version of\n          gftopk is installed.\n\nWed Sep  9 06:26:30 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.493a.\n\nTue Sep  8 16:51:25 1992  Karl Berry  (karl@hayley)\n\n        * c-auto.h.in (_MINIX, _{ALL,POSIX,POSIX_1}_SOURCE): add #undef's\n          for configure to define.\n\n        * configure.in: test for more Unix variants.\n\nFri Sep  4 17:27:52 1992  Karl Berry  (karl@hayley)\n\n        * Makefile.in (extraclean): new target.\n\n        * Update to version 5.493.\n\nThu Aug 27 08:57:06 1992  Karl Berry  (karl@hayley)\n\n        * configure: regenerated from Autoconf 1.1.\n\nTue Aug 11 07:00:15 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.490s.\n\n        * Makefile.in (dist): copy MakeTeXPK.\n\nFri Jul 31 19:14:15 1992  Karl Berry  (karl@hayley)\n\n        * Makefile.in (dist): include our aclocal.m4.\n\nWed Jul 29 08:52:01 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.490r (ran pathshare).\n\nFri Jul 24 06:49:56 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.490q.\n\nWed Jul 22 09:10:03 1992  Karl Berry  (karl@hayley)\n\n        * configure.in: update for Autoconf 1.0.\n\nTue Jul 21 08:52:21 1992  Karl Berry  (karl@hayley)\n\n        * resident.c (print_path): new function.\n        (checkenv): call it, if we are debugging paths.\n\n        * resident.c (checkenv): don't reset envvars if they are already set.\n        (getdefaults): pass the user envvars when setting values from the\n          config files, so they will override.\n\nThu Jul 16 06:56:31 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.490p.\n\nSun Jul 12 06:20:11 1992  Karl Berry  (karl@hayley)\n\n        * Makefile.in (dist): forgot to include the config files.\n\nSat Jul 11 11:52:48 1992  Karl Berry  (karl@hayley)\n\n        * Makefile.in (dist): copy texinfo.tex and `adobe' from their\n          original directory, instead of using the versions here.\n\nFri Jul 10 06:52:51 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.490o.\n\nThu Jul  2 15:25:00 1992  Karl Berry  (karl@hayley)\n\n        * Makefile.in (CPPFLAGS): new variable.\n        (.c.o): use it.\n        (CFLAGS): define as -g.\n        (cdebug): remove.\n        (LDFLAGS): use CFLAGS instead of cdebug.\n\n        * Run Autoconf 0.119.\n\nWed Jul  1 07:48:33 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.490n.\n\nSat Jun 27 11:03:09 1992  Karl Berry  (karl@hayley)\n\n        * Makefile.in (paths.h): depend on Makefile.in and Makefile.\n\nThu Jun 25 09:57:54 1992  Karl Berry  (karl@hayley)\n\n        * All these $(srcdir) changes from or inspired by zoo@cygnus.com.\n\n        * Makefile.in (paths.h): use $(srcdir) for paths.h.in.\n\nWed Jun 24 11:57:21 1992  Karl Berry  (karl@hayley)\n\n        * structures.h (BANNER): name this program kdvips.\n        * Makefile.in (distdir): ditto for the directory.\n\n        * Makefile.in (CCFLAGS): new variable to replace $(CFLAGS).\n        (.c.o): new implicit rule to use it.\n        (.lpro.pro): use $< instead of $*.lpro, since I\n          guess it's marginally more portable.\n        (texc.lpro, install): use $(srcdir).\n        (Makefile): new target.\n\n        * Makefile (install): mkdir more of the top level directories.\n\n        * Makefile (dist): distribute the config* files (except\n          config.status).\n\n        * README: say that %-specifiers don't work.\n\nTue Jun 23 08:50:06 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.490m.\n\nFri Jun 19 09:26:14 1992  Karl Berry  (karl@hayley)\n\n        * psfonts.map: update for new (old by now, actually) change in the\n          way ExtendFont and SlantFont work.\n\nTue Jun 16 06:13:31 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.490l.\n\nSat Jun 13 07:13:07 1992  Karl Berry  (karl@hayley)\n\n        * loadfont.c (pkopen): fix remaining sprintf-with-too-many-%'s.\n\nThu Jun 11 08:45:25 1992  Karl Berry  (karl@hayley)\n\n        * Makefile.in (.NOEXPORT): new target, since Autoconf doesn't add\n          it automatically any more.\n\nWed Jun 10 06:34:24 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.490k.\n\nFri Jun  5 07:58:45 1992  Karl Berry  (karl@hayley)\n\n        * squeeze.c, afm2tfm.c (main): `return 0' instead of `exit (0)'.\n          (From Paul Eggert)  Also declare as `int'.\n\n        * Makefile (install): `black.tex' is now `blackdvi.tex', etc.\n\nThu Jun  4 08:25:51 1992  Karl Berry  (karl@hayley)\n\n        * main.c (main): `return 0' instead of `exit (0)'.  (From Paul Eggert)\n\n        * Update for dvips 5.490.\n\n        * configure.in (AC_HEADER_FILE): rename to AC_CONFIG_HEADER, for\n          Autoconf 0.115.\n\nWed Jun  3 08:19:53 1992  Karl Berry  (karl@hayley)\n\n        * Version 5.487l.\n\nFri May 29 11:28:16 1992  Karl Berry  (karl@hayley)\n\n        * Below changes from Paul Eggert.\n\n        * dvips.c (main): declare as returning an int.\n\n        * dvips.c (exit): do not declare.\n\n        * resident.c (pagecopies) [DEBUG]: declare unconditionally.\n\n        * resident.c (exit): do not declare.\n\n        * unpack.c (flip): don't use a variable `howmany', since Sun has a\n          macro called that.\n\n        * config.h (FATAL): don't assume an ANSI cpp.\n", "/*\nCopyright 1996-2013 Han The Thanh <thanh@pdftex.org>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see  <http://www.gnu.org/licenses/>.  */\n\n#include \"dvips.h\"\n/*\n *   The external declarations:\n */\n#include \"protos.h\"\n#include \"ptexmac.h\"\n#undef  fm_extend\n#define fm_extend(f)        0\n#undef  fm_slant\n#define fm_slant(f)         0\n#undef  is_reencoded\n#define is_reencoded(f)     (cur_enc_name != NULL)\n#undef  is_subsetted\n#define is_subsetted(f)     true\n#undef  is_included\n#define is_included(f)      true\n#undef  set_cur_file_name\n#define set_cur_file_name(s)    cur_file_name = s\n#define external_enc()      ext_glyph_names\n#define full_file_name()    cur_file_name\n#define is_used_char(c)     (grid[c] == 1)\n#define end_last_eexec_line()       \\\n    hexline_length = HEXLINE_WIDTH; \\\n    end_hexline();                  \\\n    t1_eexec_encrypt = false\n#define t1_scan_only()\n#define t1_scan_keys()\n#define embed_all_glyphs(tex_font)  false\n#undef pdfmovechars\n#ifdef SHIFTLOWCHARS\n#define pdfmovechars shiftlowchars\n#define t1_char(c)          T1Char(c)\n#else /* SHIFTLOWCHARS */\n#define t1_char(c)          c\n#define pdfmovechars 0\n#endif /* SHIFTLOWCHARS */\n#define extra_charset()     dvips_extra_charset\n#define make_subset_tag(a, b)\n#define update_subset_tag()\n\nstatic char *dvips_extra_charset;\nstatic char *cur_file_name;\nstatic char *cur_enc_name;\nstatic unsigned char *grid;\nstatic char *ext_glyph_names[256];\nstatic char print_buf[PRINTF_BUF_SIZE];\nstatic int  hexline_length;\nstatic char notdef[] = \".notdef\";\nstatic size_t last_ptr_index;\n\n#include <stdarg.h>\n\n#define t1_log(str) \n#define get_length1()\n#define get_length2()\n#define get_length3()\n#define save_offset()\n\n#define t1_open()           \\\n    ((t1_file = search(type1path, cur_file_name, FOPEN_RBIN_MODE)) != NULL)\n#define t1_close()       xfclose(t1_file, cur_file_name)\n#define t1_getchar()     getc(t1_file)\n#define t1_putchar(c)    fputc(c, bitfile)\n#define t1_ungetchar(c)  ungetc(c, t1_file)\n#define t1_eof()         feof(t1_file)\n\n#define str_prefix(s1, s2) (strncmp(s1, s2, strlen(s2)) == 0)\n#define t1_prefix(s)     str_prefix(t1_line_array, s)\n#define t1_buf_prefix(s) str_prefix(t1_buf_array, s)\n#define t1_suffix(s)     str_suffix(t1_line_array, t1_line_ptr, s)\n#define t1_buf_suffix(s) str_suffix(t1_buf_array, t1_buf_ptr, s)\n#define t1_charstrings() strstr(t1_line_array, charstringname)\n#define t1_subrs()       t1_prefix(\"/Subrs\")\n#define t1_end_eexec()   t1_suffix(\"mark currentfile closefile\")\n#define t1_cleartomark() t1_prefix(\"cleartomark\")\n\n#define enc_open()           \\\n    ((enc_file = search(encpath, cur_file_name, FOPEN_RBIN_MODE)) != NULL)\n#define enc_close()      xfclose(enc_file, cur_file_name)\n#define enc_getchar()    getc(enc_file)\n#define enc_eof()        feof(enc_file)\n\n#define valid_code(c)    (c >= 0 && c < 256)\n#define fixedcontent     true /* false for pdfTeX, true for dvips */\n\nstatic const char *standard_glyph_names[256] = {\n    /* 0x00 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0x10 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0x20 */\n    \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\",\n    \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\", \"asterisk\",\n    \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\",\n    /* 0x30 */\n    \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\",\n    \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\",\n    /* 0x40 */\n    \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\",\n    \"O\",\n    /* 0x50 */\n    \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\",\n    \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\",\n    /* 0x60 */\n    \"quoteleft\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\",\n    \"m\", \"n\", \"o\",\n    /* 0x70 */\n    \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\",\n    \"braceright\", \"asciitilde\", notdef,\n    /* 0x80 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0x90 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0xa0 */\n    notdef, \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\", \"florin\",\n    \"section\", \"currency\", \"quotesingle\", \"quotedblleft\", \"guillemotleft\",\n    \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\",\n    /* 0xb0 */\n    notdef, \"endash\", \"dagger\", \"daggerdbl\", \"periodcentered\", notdef,\n    \"paragraph\", \"bullet\", \"quotesinglbase\", \"quotedblbase\",\n    \"quotedblright\", \"guillemotright\", \"ellipsis\", \"perthousand\", notdef,\n    \"questiondown\",\n    /* 0xc0 */\n    notdef, \"grave\", \"acute\", \"circumflex\", \"tilde\", \"macron\", \"breve\",\n    \"dotaccent\", \"dieresis\", notdef,\n    \"ring\", \"cedilla\", notdef, \"hungarumlaut\", \"ogonek\", \"caron\",\n    /* 0xd0 */\n    \"emdash\", notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0xe0 */\n    notdef, \"AE\", notdef, \"ordfeminine\", notdef, notdef, notdef, notdef,\n    \"Lslash\", \"Oslash\", \"OE\", \"ordmasculine\", notdef, notdef, notdef,\n    notdef,\n    /* 0xf0 */\n    notdef, \"ae\", notdef, notdef, notdef, \"dotlessi\", notdef, notdef, \"lslash\",\n    \"oslash\", \"oe\", \"germandbls\", notdef, notdef, notdef, notdef\n};\n\nchar **t1_glyph_names;\nchar *t1_builtin_glyph_names[256];\nstatic boolean read_encoding_only;\n\nstatic char charstringname[] = \"/CharStrings\";\n\nenum { ENC_STANDARD, ENC_BUILTIN } t1_encoding;\n\n#define T1_BUF_SIZE      0x10\n#define ENC_BUF_SIZE     0x1000\n\n#define CS_HSTEM         1\n#define CS_VSTEM         3\n#define CS_VMOVETO       4\n#define CS_RLINETO       5\n#define CS_HLINETO       6\n#define CS_VLINETO       7\n#define CS_RRCURVETO     8\n#define CS_CLOSEPATH     9\n#define CS_CALLSUBR      10\n#define CS_RETURN        11\n#define CS_ESCAPE        12\n#define CS_HSBW          13\n#define CS_ENDCHAR       14\n#define CS_RMOVETO       21\n#define CS_HMOVETO       22\n#define CS_VHCURVETO     30\n#define CS_HVCURVETO     31\n#define CS_1BYTE_MAX     (CS_HVCURVETO + 1)\n\n#define CS_DOTSECTION    CS_1BYTE_MAX + 0\n#define CS_VSTEM3        CS_1BYTE_MAX + 1\n#define CS_HSTEM3        CS_1BYTE_MAX + 2\n#define CS_SEAC          CS_1BYTE_MAX + 6\n#define CS_SBW           CS_1BYTE_MAX + 7\n#define CS_DIV           CS_1BYTE_MAX + 12\n#define CS_CALLOTHERSUBR CS_1BYTE_MAX + 16\n#define CS_POP           CS_1BYTE_MAX + 17\n#define CS_SETCURRENTPOINT CS_1BYTE_MAX + 33\n#define CS_2BYTE_MAX     (CS_SETCURRENTPOINT + 1)\n#define CS_MAX           CS_2BYTE_MAX\n\ntypedef unsigned char byte;\n\ntypedef struct {\n    byte nargs;                 /* number of arguments */\n    boolean bottom;             /* take arguments from bottom of stack? */\n    boolean clear;              /* clear stack? */\n    boolean valid;\n} cc_entry;                     /* CharString Command */\n\ntypedef struct {\n    char *name;                 /* glyph name (or notdef for Subrs entry) */\n    byte *data;\n    unsigned short len;         /* length of the whole string */\n    unsigned short cslen;       /* length of the encoded part of the string */\n    boolean used;\n    boolean valid;\n} cs_entry;\n\nstatic unsigned short t1_dr, t1_er;\nstatic const unsigned short t1_c1 = 52845, t1_c2 = 22719;\nstatic unsigned short t1_cslen;\nstatic short t1_lenIV;\nstatic char enc_line[ENC_BUF_SIZE];\n\n/* define t1_line_ptr, t1_line_array & t1_line_limit */\ntypedef char t1_line_entry;\ndefine_array(t1_line);\n\n/* define t1_buf_ptr, t1_buf_array & t1_buf_limit */\ntypedef char t1_buf_entry;\ndefine_array(t1_buf);\n\nstatic int cs_start;\n\nstatic cs_entry *cs_tab, *cs_ptr, *cs_notdef;\nstatic char *cs_dict_start, *cs_dict_end;\nstatic int cs_count, cs_size, cs_size_pos;\n\nstatic cs_entry *subr_tab;\nstatic char *subr_array_start, *subr_array_end;\nstatic int subr_max, subr_size, subr_size_pos;\n\n/* This list contains the begin/end tokens commonly used in the */\n/* /Subrs array of a Type 1 font.                               */\n\nstatic const char *cs_token_pairs_list[][2] = {\n    {\" RD\", \"NP\"},\n    {\" -|\", \"|\"},\n    {\" RD\", \"noaccess put\"},\n    {\" -|\", \"noaccess put\"},\n    {NULL, NULL}\n};\nstatic const char **cs_token_pair;\n\nstatic boolean t1_pfa, t1_cs, t1_scan, t1_eexec_encrypt, t1_synthetic;\nstatic int t1_in_eexec;         /* 0 before eexec-encrypted, 1 during, 2 after */\nstatic long t1_block_length;\nstatic int last_hexbyte;\nstatic FILE *t1_file;\nstatic FILE *enc_file;\n\nstatic void pdftex_fail(const char *fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    fputs(\"\\nError: module writet1\", stderr);\n    if (cur_file_name)\n        fprintf(stderr, \" (file %s)\", cur_file_name);\n    fputs(\": \", stderr);\n    vsprintf(print_buf, fmt, args);\n    fputs(print_buf, stderr);\n    fputs(\"\\n ==> Fatal error occurred, the output PS file is not finished!\\n\", stderr);\n    va_end(args);\n    exit(-1);\n}\n\nstatic void pdftex_warn(const char *fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    fputs(\"\\nWarning: module writet1 of dvips\", stderr);\n    if (cur_file_name)\n        fprintf(stderr, \" (file %s)\", cur_file_name);\n    fputs(\": \", stderr);\n    vsprintf(print_buf, fmt, args);\n    fputs(print_buf, stderr);\n    fputs(\"\\n\", stderr);\n    va_end(args);\n}\n\n#define HEXLINE_WIDTH 64\n\nstatic void end_hexline(void)\n{\n    if (hexline_length == HEXLINE_WIDTH) {\n        fputs(\"\\n\", bitfile);\n        hexline_length = 0;\n    }\n}\n\nstatic void t1_outhex(byte b)\n{\n    static const char *hexdigits = \"0123456789ABCDEF\";\n    t1_putchar(hexdigits[b/16]);\n    t1_putchar(hexdigits[b%16]);\n    hexline_length += 2;\n    end_hexline();\n}\n\n\nstatic void enc_getline(void)\n{\n    char *p;\n    int c;\n  restart:\n    if (enc_eof())\n        pdftex_fail(\"unexpected end of file\");\n    p = enc_line;\n    do {\n        c = enc_getchar();\n        append_char_to_buf(c, p, enc_line, ENC_BUF_SIZE);\n    } while (c != 10);\n    append_eol(p, enc_line, ENC_BUF_SIZE);\n    if (p - enc_line < 2 || *enc_line == '%')\n        goto restart;\n}\n\n/* read encoding from .enc file, return glyph_names array, or pdffail() */\n\nchar **load_enc_file(char *enc_name)\n{\n    char buf[ENC_BUF_SIZE], *p, *r;\n    int i, names_count;\n    char **glyph_names;\n    set_cur_file_name(enc_name);\n    glyph_names = (char **) mymalloc(256 * sizeof(char *));\n    for (i = 0; i < 256; i++)\n        glyph_names[i] = notdef;\n    if (!enc_open()) {\n        pdftex_warn(\"cannot open encoding file for reading\");\n        cur_file_name = NULL;\n        return glyph_names;\n    }\n    t1_log(\"{\");\n    t1_log(cur_file_name = full_file_name());\n    enc_getline();\n    if (*enc_line != '/' || (r = strchr(enc_line, '[')) == NULL) {\n        remove_eol(r, enc_line);\n        pdftex_fail\n           (\"invalid encoding vector (a name or `[' missing): `%s'\", enc_line);\n    }\n    names_count = 0;\n    r++;                        /* skip '[' */\n    skip(r, ' ');\n    for (;;) {\n        while (*r == '/') {\n            for (p = buf, r++;\n                 *r != ' ' && *r != 10 && *r != ']' && *r != '/'; *p++ = *r++);\n            *p = 0;\n            skip(r, ' ');\n            if (names_count > 255)\n                pdftex_fail(\"encoding vector contains more than 256 names\");\n            if (strcmp(buf, notdef) != 0)\n                glyph_names[names_count] = xstrdup(buf);\n            names_count++;\n        }\n        if (*r != 10 && *r != '%') {\n            if (str_prefix(r, \"] def\"))\n                goto done;\n            else {\n                remove_eol(r, enc_line);\n                pdftex_fail\n       (\"invalid encoding vector: a name or `] def' expected: `%s'\", enc_line);\n            }\n        }\n        enc_getline();\n        r = enc_line;\n    }\n  done:\n    enc_close();\n    t1_log(\"}\");\n    cur_file_name = NULL;\n    return glyph_names;\n}\n\nstatic void t1_check_pfa(void)\n{\n    const int c = t1_getchar();\n    t1_pfa = (c != 128) ? true : false;\n    t1_ungetchar(c);\n}\n\nstatic int t1_getbyte(void)\n{\n    int c = t1_getchar();\n    if (t1_pfa)\n        return c;\n    if (t1_block_length == 0) {\n        if (c != 128)\n            pdftex_fail(\"invalid marker\");\n        c = t1_getchar();\n        if (c == 3) {\n            while (!t1_eof())\n                t1_getchar();\n            return EOF;\n        }\n        t1_block_length = t1_getchar() & 0xff;\n        t1_block_length |= (t1_getchar() & 0xff) << 8;\n        t1_block_length |= (t1_getchar() & 0xff) << 16;\n        t1_block_length |= (t1_getchar() & 0xff) << 24;\n        c = t1_getchar();\n    }\n    t1_block_length--;\n    return c;\n}\n\nstatic int hexval(int c)\n{\n    if (c >= 'A' && c <= 'F')\n        return c - 'A' + 10;\n    else if (c >= 'a' && c <= 'f')\n        return c - 'a' + 10;\n    else if (c >= '0' && c <= '9')\n        return c - '0';\n    else\n        return -1;\n}\n\nstatic byte edecrypt(byte cipher)\n{\n    byte plain;\n    if (t1_pfa) {\n        while (cipher == 10 || cipher == 13)\n            cipher = t1_getbyte();\n        last_hexbyte = cipher = (hexval(cipher) << 4) + hexval(t1_getbyte());\n    }\n    plain = (cipher ^ (t1_dr >> 8));\n    t1_dr = (cipher + t1_dr) * t1_c1 + t1_c2;\n    return plain;\n}\n\nstatic byte cdecrypt(byte cipher, unsigned short *cr)\n{\n    const byte plain = (cipher ^ (*cr >> 8));\n    *cr = (cipher + *cr) * t1_c1 + t1_c2;\n    return plain;\n}\n\nstatic byte eencrypt(byte plain)\n{\n    const byte cipher = (plain ^ (t1_er >> 8));\n    t1_er = (cipher + t1_er) * t1_c1 + t1_c2;\n    return cipher;\n}\n\nstatic byte cencrypt(byte plain, unsigned short *cr)\n{\n    const byte cipher = (plain ^ (*cr >> 8));\n    *cr = (cipher + *cr) * t1_c1 + t1_c2;\n    return cipher;\n}\n\nstatic char *eol(char *s)\n{\n    char *p = strend(s);\n    if (p - s > 1 && p[-1] != 10) {\n        *p++ = 10;\n        *p = 0;\n    }\n    return p;\n}\n\nstatic float t1_scan_num(char *p, char **r)\n{\n    float f;\n    skip(p, ' ');\n    if (sscanf(p, \"%g\", &f) != 1) {\n        remove_eol(p, t1_line_array);\n        pdftex_fail(\"a number expected: `%s'\", t1_line_array);\n    }\n    if (r != NULL) {\n        for (; isdigit((unsigned char)*p) || *p == '.' ||\n             *p == 'e' || *p == 'E' || *p == '+' || *p == '-'; p++);\n        *r = p;\n    }\n    return f;\n}\n\nstatic boolean str_suffix(const char *begin_buf, const char *end_buf,\n                          const char *s)\n{\n    const char *s1 = end_buf - 1, *s2 = strend(s) - 1;\n    if (*s1 == 10)\n        s1--;\n    while (s1 >= begin_buf && s2 >= s) {\n        if (*s1-- != *s2--)\n            return false;\n    }\n    return s2 < s;\n}\n\nstatic void t1_getline(void)\n{\n    int c, l, eexec_scan;\n    char *p;\n    static const char eexec_str[] = \"currentfile eexec\";\n    static int eexec_len = 17;  /* strlen(eexec_str) */\n  restart:\n    if (t1_eof())\n        pdftex_fail(\"unexpected end of file\");\n    t1_line_ptr = t1_line_array;\n    alloc_array(t1_line, 1, T1_BUF_SIZE);\n    t1_cslen = 0;\n    eexec_scan = 0;\n    c = t1_getbyte();\n    if (c == EOF)\n        goto exit;\n    while (!t1_eof()) {\n        if (t1_in_eexec == 1)\n            c = edecrypt((byte)c);\n        alloc_array(t1_line, 1, T1_BUF_SIZE);\n        append_char_to_buf(c, t1_line_ptr, t1_line_array, t1_line_limit);\n        if (t1_in_eexec == 0 && eexec_scan >= 0 && eexec_scan < eexec_len) {\n            if (t1_line_array[eexec_scan] == eexec_str[eexec_scan])\n                eexec_scan++;\n            else\n                eexec_scan = -1;\n        }\n        if (c == 10 || (t1_pfa && eexec_scan == eexec_len && c == 32))\n            break;\n        if (t1_cs && t1_cslen == 0 && (t1_line_ptr - t1_line_array > 4) &&\n            (t1_suffix(\" RD \") || t1_suffix(\" -| \"))) {\n            p = t1_line_ptr - 5;\n            while (*p != ' ')\n                p--;\n            t1_cslen = l = t1_scan_num(p + 1, 0);\n            cs_start = t1_line_ptr - t1_line_array;     /* cs_start is an index now */\n            alloc_array(t1_line, l, T1_BUF_SIZE);\n            while (l-- > 0)\n                *t1_line_ptr++ = edecrypt((byte)t1_getbyte());\n        }\n        c = t1_getbyte();\n    }\n    alloc_array(t1_line, 2, T1_BUF_SIZE);       /* append_eol can append 2 chars */\n    append_eol(t1_line_ptr, t1_line_array, t1_line_limit);\n    if (t1_line_ptr - t1_line_array < 2)\n        goto restart;\n    if (eexec_scan == eexec_len)\n        t1_in_eexec = 1;\n  exit:\n    /* ensure that t1_buf_array has as much room as t1_line_array */\n    t1_buf_ptr = t1_buf_array;\n    alloc_array(t1_buf, t1_line_limit, t1_line_limit);\n}\n\nstatic void t1_putline(void)\n{\n    char *p = t1_line_array;\n    if (t1_line_ptr - t1_line_array <= 1)\n        return;\n    if (t1_eexec_encrypt) {\n        while (p < t1_line_ptr)\n            t1_outhex(eencrypt(*p++)); /* dvips outputs hex, unlike pdftex */\n    } else\n        while (p < t1_line_ptr)\n            t1_putchar(*p++);\n}\n\nstatic void t1_puts(const char *s)\n{\n    if (s != t1_line_array)\n        strcpy(t1_line_array, s);\n    t1_line_ptr = strend(t1_line_array);\n    t1_putline();\n}\n\nstatic void t1_printf(const char *fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    vsprintf(t1_line_array, fmt, args);\n    t1_puts(t1_line_array);\n    va_end(args);\n}\n\nstatic void t1_init_params(const char *open_name_prefix)\n{\n    t1_log(open_name_prefix);\n    t1_log(cur_file_name);\n    t1_lenIV = 4;\n    t1_dr = 55665;\n    t1_er = 55665;\n    t1_in_eexec = 0;\n    t1_cs = false;\n    t1_scan = true;\n    t1_synthetic = false;\n    t1_eexec_encrypt = false;\n    t1_block_length = 0;\n    t1_check_pfa();\n}\n\nstatic void t1_close_font_file(const char *close_name_suffix)\n{\n    t1_log(close_name_suffix);\n    t1_close();\n    cur_file_name = NULL;\n}\n\nstatic void t1_check_block_len(boolean decrypt)\n{\n    int l, c;\n    if (t1_block_length == 0)\n        return;\n    c = t1_getbyte();\n    if (decrypt)\n        c = edecrypt((byte)c);\n    l = t1_block_length;\n    if (!(l == 0 && (c == 10 || c == 13))) {\n        pdftex_warn(\"%i bytes more than expected were ignored\", l + 1);\n        while (l-- > 0)\n            t1_getbyte();\n    }\n}\n\nstatic void t1_start_eexec(void)\n{\n    int i;\n    if (is_included(fm_cur)) {\n        get_length1();\n        save_offset();\n    }\n    if (!t1_pfa)\n        t1_check_block_len(false);\n    for (t1_line_ptr = t1_line_array, i = 0; i < 4; i++) {\n        edecrypt((byte)t1_getbyte());\n        *t1_line_ptr++ = 0;\n    }\n    t1_eexec_encrypt = true;\n    if (is_included(fm_cur))\n        t1_putline(); /* to put the first four bytes */\n}\n\nstatic void t1_stop_eexec(void)\n{\n    int c;\n    if (is_included(fm_cur)) {\n        get_length2();\n        save_offset();\n    }\n    end_last_eexec_line();\n    if (!t1_pfa)\n        t1_check_block_len(true);\n    else {\n        c = edecrypt((byte)t1_getbyte());\n        if (!(c == 10 || c == 13)) {\n            if (last_hexbyte == 0)\n                t1_puts(\"00\");\n            else\n                pdftex_warn(\"unexpected data after eexec\");\n        }\n    }\n    t1_cs = false;\n    t1_in_eexec = 2;\n}\n\nstatic void t1_scan_param(void)\n{\n    static const char *lenIV = \"/lenIV\";\n    if (!t1_scan || *t1_line_array != '/')\n        return;\n    if (t1_prefix(lenIV)) {\n        t1_lenIV = t1_scan_num(t1_line_array + strlen(lenIV), 0);\n        if (t1_lenIV < 0)\n            pdftex_fail(\"negative value of lenIV is not supported\");\n        return;\n    }\n    t1_scan_keys();\n}\n\nstatic void copy_glyph_names(char **glyph_names, int a, int b)\n{\n    if (glyph_names[b] != notdef) {\n        xfree(glyph_names[b]);\n        glyph_names[b] = notdef;\n    }\n    if (glyph_names[a] != notdef) {\n        glyph_names[b] = xstrdup(glyph_names[a]);\n    }\n}\n\n/* read encoding from Type1 font file, return glyph_names array, or pdffail() */\n\nstatic char **t1_builtin_enc(void)\n{\n    int i, a, b, c, counter = 0;\n    char *r, *p, **glyph_names;\n    /* At this moment \"/Encoding\" is the prefix of t1_line_array */\n    glyph_names = t1_builtin_glyph_names;\n    for (i = 0; i < 256; i++)\n        glyph_names[i] = notdef;\n    if (t1_suffix(\"def\")) {     /* predefined encoding */\n        if (sscanf(t1_line_array + strlen(\"/Encoding\"), \"%255s\", t1_buf_array) == 1\n            && strcmp(t1_buf_array, \"StandardEncoding\") == 0) {\n            t1_encoding = ENC_STANDARD;\n            for (i = 0; i < 256; i++) {\n                if (standard_glyph_names[i] != notdef)\n                    glyph_names[i] = xstrdup(standard_glyph_names[i]);\n            }\n            return glyph_names;\n        }\n        pdftex_fail(\"cannot subset font (unknown predefined encoding `%s')\",\n                    t1_buf_array);\n    }\n    /* At this moment \"/Encoding\" is the prefix of t1_line_array, and the encoding is\n     * not a predefined encoding.\n     *\n     * We have two possible forms of Encoding vector. The first case is\n     *\n     *     /Encoding [/a /b /c...] readonly def\n     *\n     * and the second case can look like\n     *\n     *     /Encoding 256 array 0 1 255 {1 index exch /.notdef put} for\n     *     dup 0 /x put\n     *     dup 1 /y put\n     *     ...\n     *     readonly def\n     */\n    t1_encoding = ENC_BUILTIN;\n    if (t1_prefix(\"/Encoding [\") || t1_prefix(\"/Encoding[\")) {  /* the first case */\n        r = strchr(t1_line_array, '[') + 1;\n        skip(r, ' ');\n        for (;;) {\n            while (*r == '/') {\n                for (p = t1_buf_array, r++;\n                     *r != 32 && *r != 10 && *r != ']' && *r != '/';\n                     *p++ = *r++);\n                *p = 0;\n                skip(r, ' ');\n                if (counter > 255)\n                    pdftex_fail(\"encoding vector contains more than 256 names\");\n                if (strcmp(t1_buf_array, notdef) != 0)\n                    glyph_names[counter] = xstrdup(t1_buf_array);\n                counter++;\n            }\n            if (*r != 10 && *r != '%') {\n                if (str_prefix(r, \"] def\") || str_prefix(r, \"] readonly def\"))\n                    break;\n                else {\n                    remove_eol(r, t1_line_array);\n                    pdftex_fail\n       (\"a name or `] def' or `] readonly def' expected: `%s'\", t1_line_array);\n                }\n            }\n            t1_getline();\n            r = t1_line_array;\n        }\n    } else {                    /* the second case */\n        p = strchr(t1_line_array, 10);\n        for (;;) {\n            if (*p == 10) {\n                t1_getline();\n                p = t1_line_array;\n            }\n            /*\n               check for `dup <index> <glyph> put'\n             */\n            if (sscanf(p, \"dup %i%255s put\", &i, t1_buf_array) == 2 &&\n                *t1_buf_array == '/' && valid_code(i)) {\n                if (strcmp(t1_buf_array + 1, notdef) != 0)\n                    glyph_names[i] = xstrdup(t1_buf_array + 1);\n                p = strstr(p, \" put\") + strlen(\" put\");\n                skip(p, ' ');\n            }\n            /*\n               check for `dup dup <to> exch <from> get put'\n             */\n            else if (sscanf(p, \"dup dup %i exch %i get put\", &b, &a) == 2\n                     && valid_code(a) && valid_code(b)) {\n                copy_glyph_names(glyph_names, a, b);\n                p = strstr(p, \" get put\") + strlen(\" get put\");\n                skip(p, ' ');\n            }\n            /*\n               check for `dup dup <from> <size> getinterval <to> exch putinterval'\n             */\n            else if (sscanf(p, \"dup dup %i %i getinterval %i exch putinterval\",\n                            &a, &c, &b) == 3\n                     && valid_code(a) && valid_code(b) && valid_code(c)) {\n                for (i = 0; i < c; i++)\n                    copy_glyph_names(glyph_names, a + i, b + i);\n                p = strstr(p, \" putinterval\") + strlen(\" putinterval\");\n                skip(p, ' ');\n            }\n            /*\n               check for `def' or `readonly def'\n             */\n            else if ((p == t1_line_array || (p > t1_line_array && p[-1] == ' '))\n                     && strcmp(p, \"def\\n\") == 0)\n                return glyph_names;\n            /*\n               skip an unrecognizable word\n             */\n            else {\n                while (*p != ' ' && *p != 10)\n                    p++;\n                skip(p, ' ');\n            }\n        }\n    }\n    return glyph_names;\n}\n\nstatic void t1_check_end(void)\n{\n    if (t1_eof())\n        return;\n    t1_getline();\n    if (t1_prefix(\"{restore}\"))\n        t1_putline();\n}\n\nstatic boolean t1_open_fontfile(const char *open_name_prefix)\n{\n    if (!t1_open()) {\n       char *msg = concat (\"! Couldn't find font file \", cur_file_name);\n       error(msg);\n    }\n    t1_init_params(open_name_prefix);\n    return true;                /* font file found */\n}\n\n#define t1_include()\n\n#define check_subr(subr) \\\n    if (subr >= subr_size || subr < 0) \\\n        pdftex_fail(\"Subrs array: entry index out of range (%i)\",  subr);\n\nstatic const char **check_cs_token_pair(void)\n{\n    const char **p = (const char **) cs_token_pairs_list;\n    for (; p[0] != NULL; ++p)\n        if (t1_buf_prefix(p[0]) && t1_buf_suffix(p[1]))\n            return p;\n    return NULL;\n}\n\nstatic void cs_store(boolean is_subr)\n{\n    char *p;\n    cs_entry *ptr;\n    int subr;\n    for (p = t1_line_array, t1_buf_ptr = t1_buf_array; *p != ' ';\n         *t1_buf_ptr++ = *p++);\n    *t1_buf_ptr = 0;\n    if (is_subr) {\n        subr = t1_scan_num(p + 1, 0);\n        check_subr(subr);\n        ptr = subr_tab + subr;\n    } else {\n        ptr = cs_ptr++;\n        if (cs_ptr - cs_tab > cs_size)\n            pdftex_fail\n                (\"CharStrings dict: more entries than dict size (%i)\", cs_size);\n        if (strcmp(t1_buf_array + 1, notdef) == 0)      /* skip the slash */\n            ptr->name = notdef;\n        else\n            ptr->name = xstrdup(t1_buf_array + 1);\n    }\n    /* copy \" RD \" + cs data to t1_buf_array */\n    memcpy(t1_buf_array, t1_line_array + cs_start - 4,\n           (unsigned) (t1_cslen + 4));\n    /* copy the end of cs data to t1_buf_array */\n    for (p = t1_line_array + cs_start + t1_cslen,\n           t1_buf_ptr = t1_buf_array + t1_cslen + 4;\n         *p != 10; *t1_buf_ptr++ = *p++);\n    *t1_buf_ptr++ = 10;\n    if (is_subr && cs_token_pair == NULL)\n        cs_token_pair = check_cs_token_pair();\n    ptr->len = t1_buf_ptr - t1_buf_array;\n    ptr->cslen = t1_cslen;\n    ptr->data = xtalloc(ptr->len, byte);\n    memcpy(ptr->data, t1_buf_array, ptr->len);\n    ptr->valid = true;\n}\n\n#define store_subr()     cs_store(true)\n#define store_cs()       cs_store(false)\n\n#define CC_STACK_SIZE    24\n\nstatic integer cc_stack[CC_STACK_SIZE], *stack_ptr = cc_stack;\nstatic cc_entry cc_tab[CS_MAX];\nstatic boolean is_cc_init = false;\n\n#define cc_pop(N)                   \\\n    if (stack_ptr - cc_stack < (N)) \\\n        stack_error(N);             \\\n    stack_ptr -= N\n\n#define stack_error(N) {            \\\n    pdftex_fail(\"CharString: invalid access (%i) to stack (%i entries)\", \\\n                (int) N, (int)(stack_ptr - cc_stack));                  \\\n    goto cs_error;                  \\\n}\n\n/*\nstatic integer cc_get(integer index)\n{\n    if (index <  0) {\n        if (stack_ptr + index < cc_stack )\n            stack_error(stack_ptr - cc_stack + index);\n        return *(stack_ptr + index);\n    }\n    else {\n        if (cc_stack  + index >= stack_ptr)\n            stack_error(index);\n        return cc_stack[index];\n    }\n}\n*/\n\n#define cc_get(N)   ((N) < 0 ? *(stack_ptr + (N)) : *(cc_stack + (N)))\n#define cc_push(V)  *stack_ptr++ = V\n#define cc_clear()  stack_ptr = cc_stack\n#define set_cc(N, B, A, C) \\\n    cc_tab[N].nargs = A;   \\\n    cc_tab[N].bottom = B;  \\\n    cc_tab[N].clear = C;   \\\n    cc_tab[N].valid = true\n\nstatic void cc_init(void)\n{\n    int i;\n    if (is_cc_init)\n        return;\n    for (i = 0; i < CS_MAX; i++)\n        cc_tab[i].valid = false;\n    set_cc(CS_HSTEM, true, 2, true);\n    set_cc(CS_VSTEM, true, 2, true);\n    set_cc(CS_VMOVETO, true, 1, true);\n    set_cc(CS_RLINETO, true, 2, true);\n    set_cc(CS_HLINETO, true, 1, true);\n    set_cc(CS_VLINETO, true, 1, true);\n    set_cc(CS_RRCURVETO, true, 6, true);\n    set_cc(CS_CLOSEPATH, false, 0, true);\n    set_cc(CS_CALLSUBR, false, 1, false);\n    set_cc(CS_RETURN, false, 0, false);\n    /*\n       set_cc(CS_ESCAPE, false, 0, false);\n     */\n    set_cc(CS_HSBW, true, 2, true);\n    set_cc(CS_ENDCHAR, false, 0, true);\n    set_cc(CS_RMOVETO, true, 2, true);\n    set_cc(CS_HMOVETO, true, 1, true);\n    set_cc(CS_VHCURVETO, true, 4, true);\n    set_cc(CS_HVCURVETO, true, 4, true);\n    set_cc(CS_DOTSECTION, false, 0, true);\n    set_cc(CS_VSTEM3, true, 6, true);\n    set_cc(CS_HSTEM3, true, 6, true);\n    set_cc(CS_SEAC, true, 5, true);\n    set_cc(CS_SBW, true, 4, true);\n    set_cc(CS_DIV, false, 2, false);\n    set_cc(CS_CALLOTHERSUBR, false, 0, false);\n    set_cc(CS_POP, false, 0, false);\n    set_cc(CS_SETCURRENTPOINT, true, 2, true);\n    is_cc_init = true;\n}\n\n#define cs_getchar()     cdecrypt(*data++, &cr)\n\n#define mark_subr(n)     cs_mark(0, n)\n#define mark_cs(s)       cs_mark(s, 0)\n\nstatic void cs_fail(const char *cs_name, int subr, const char *fmt, ...)\n{\n    char buf[SMALL_BUF_SIZE];\n    va_list args;\n    va_start(args, fmt);\n    vsprintf(buf, fmt, args);\n    va_end(args);\n    if (cs_name == NULL)\n        pdftex_warn(\"Subr (%i): %s\", (int) subr, buf);\n    else\n        pdftex_warn(\"CharString (/%s): %s\", cs_name, buf);\n}\n\n/* fix a return-less subr by appending CS_RETURN */\nstatic void append_cs_return(cs_entry *ptr)\n{\n    unsigned short cr;\n    int i;\n    byte *p, *q, *data, *new_data;\n    assert(ptr != NULL && ptr->valid && ptr->used);\n\n    /* decrypt the cs data to t1_buf_array, append CS_RETURN */\n    p = (byte *) t1_buf_array;\n    data = ptr->data + 4;\n    cr = 4330;\n    for (i = 0; i < ptr->cslen; i++)\n        *p++ = cs_getchar();\n    *p = CS_RETURN;\n\n    /* encrypt the new cs data to new_data */\n    new_data = xtalloc(ptr->len + 1, byte);\n    memcpy(new_data, ptr->data, 4);\n    p = new_data + 4;\n    q = (byte *) t1_buf_array;\n    cr = 4330;\n    for (i = 0; i < ptr->cslen + 1; i++)\n        *p++ = cencrypt(*q++, &cr);\n    memcpy(p, ptr->data + 4 + ptr->cslen, ptr->len - ptr->cslen - 4);\n\n    /* update *ptr */\n    xfree(ptr->data);\n    ptr->data = new_data;\n    ptr->len++;\n    ptr->cslen++;\n}\n\nstatic void cs_mark(const char *cs_name, int subr)\n{\n    byte *data;\n    int i, b, cs_len;\n    int last_cmd = 0;\n    integer a, a1, a2;\n    unsigned short cr;\n    static integer lastargOtherSubr3 = 3;       /* the argument of last call to\n                                                   OtherSubrs[3] */\n    cs_entry *ptr;\n    cc_entry *cc;\n    if (cs_name == NULL) {\n        check_subr(subr);\n        ptr = subr_tab + subr;\n        if (!ptr->valid)\n            return;\n    } else {\n        if (cs_notdef != NULL &&\n            (cs_name == notdef || strcmp(cs_name, notdef) == 0))\n            ptr = cs_notdef;\n        else {\n            for (ptr = cs_tab; ptr < cs_ptr; ptr++)\n                if (strcmp(ptr->name, cs_name) == 0)\n                    break;\n            if (ptr == cs_ptr) {\n                pdftex_warn(\"glyph `%s' undefined\", cs_name);\n                return;\n            }\n            if (ptr->name == notdef)\n                cs_notdef = ptr;\n        }\n    }\n    /* only marked CharString entries and invalid entries can be skipped;\n       valid marked subrs must be parsed to keep the stack in sync */\n    if (!ptr->valid || (ptr->used && cs_name != NULL))\n        return;\n    ptr->used = true;\n    cr = 4330;\n    cs_len = ptr->cslen;\n    data = ptr->data + 4;\n    for (i = 0; i < t1_lenIV; i++, cs_len--)\n        cs_getchar();\n    while (cs_len > 0) {\n        --cs_len;\n        b = cs_getchar();\n        if (b >= 32) {\n            if (b <= 246)\n                a = b - 139;\n            else if (b <= 250) {\n                --cs_len;\n                a = ((b - 247) << 8) + 108 + cs_getchar();\n            } else if (b <= 254) {\n                --cs_len;\n                a = -((b - 251) << 8) - 108 - cs_getchar();\n            } else {\n                cs_len -= 4;\n                a = (cs_getchar() & 0xff) << 24;\n                a |= (cs_getchar() & 0xff) << 16;\n                a |= (cs_getchar() & 0xff) << 8;\n                a |= (cs_getchar() & 0xff) << 0;\n                if (sizeof(integer) > 4 && (a & 0x80000000))\n                    a |= ~0x7FFFFFFF;\n            }\n            cc_push(a);\n        } else {\n            if (b == CS_ESCAPE) {\n                b = cs_getchar() + CS_1BYTE_MAX;\n                cs_len--;\n            }\n            if (b >= CS_MAX) {\n                cs_fail(cs_name, subr, \"command value out of range: %i\",\n                        (int) b);\n                goto cs_error;\n            }\n            cc = cc_tab + b;\n            if (!cc->valid) {\n                cs_fail(cs_name, subr, \"command not valid: %i\", (int) b);\n                goto cs_error;\n            }\n            if (cc->bottom) {\n                if (stack_ptr - cc_stack < cc->nargs)\n                    cs_fail(cs_name, subr,\n                            \"less arguments on stack (%i) than required (%i)\",\n                            (int) (stack_ptr - cc_stack), (int) cc->nargs);\n                else if (stack_ptr - cc_stack > cc->nargs)\n                    cs_fail(cs_name, subr,\n                            \"more arguments on stack (%i) than required (%i)\",\n                            (int) (stack_ptr - cc_stack), (int) cc->nargs);\n            }\n            last_cmd = b;\n            switch (cc - cc_tab) {\n            case CS_CALLSUBR:\n                a1 = cc_get(-1);\n                cc_pop(1);\n                mark_subr(a1);\n                if (!subr_tab[a1].valid) {\n                    cs_fail(cs_name, subr, \"cannot call subr (%i)\", (int) a1);\n                    goto cs_error;\n                }\n                break;\n            case CS_DIV:\n                cc_pop(2);\n                cc_push(0);\n                break;\n            case CS_CALLOTHERSUBR:\n                if (cc_get(-1) == 3)\n                    lastargOtherSubr3 = cc_get(-3);\n                a1 = cc_get(-2) + 2;\n                cc_pop(a1);\n                break;\n            case CS_POP:\n                cc_push(lastargOtherSubr3);\n                /* the only case when we care about the value being pushed onto\n                   stack is when POP follows CALLOTHERSUBR (changing hints by\n                   OtherSubrs[3])\n                 */\n                break;\n            case CS_SEAC:\n                a1 = cc_get(3);\n                a2 = cc_get(4);\n                cc_clear();\n                mark_cs(standard_glyph_names[a1]);\n                mark_cs(standard_glyph_names[a2]);\n                break;\n            default:\n                if (cc->clear)\n                    cc_clear();\n            }\n        }\n    }\n    if (cs_name == NULL && last_cmd != CS_RETURN) {\n        pdftex_warn(\"last command in subr `%i' is not a RETURN; \"\n                    \"I will add it now but please consider fixing the font\",\n                    (int) subr);\n        append_cs_return(ptr);\n    }\n    return;\n  cs_error:                    /* an error occured during parsing */\n    cc_clear();\n    ptr->valid = false;\n    ptr->used = false;\n}\n\nstatic void t1_subset_ascii_part(void)\n{\n    int i, j;\n    t1_getline();\n    while (!t1_prefix(\"/Encoding\")) {\n        t1_scan_param();\n        if (!(t1_prefix(\"/UniqueID\")\n              && !strncmp(t1_line_array + strlen(t1_line_array) -4, \"def\", 3)))\n            t1_putline();\n        t1_getline();\n    }\n    if (is_reencoded(fm_cur))\n        t1_glyph_names = external_enc();\n    else\n        t1_glyph_names = t1_builtin_enc();\n    if (is_included(fm_cur) && is_subsetted(fm_cur)) {\n        make_subset_tag(fm_cur, t1_glyph_names);\n        update_subset_tag();\n    }\n    if (t1_encoding == ENC_STANDARD)\n        t1_puts(\"/Encoding StandardEncoding def\\n\");\n    else {\n        t1_puts\n            (\"/Encoding 256 array\\n0 1 255 {1 index exch /.notdef put} for\\n\");\n        for (i = 0, j = 0; i < 256; i++) {\n            if (is_used_char(i) && t1_glyph_names[i] != notdef) {\n                j++;\n                t1_printf(\"dup %i /%s put\\n\", (int)t1_char(i), t1_glyph_names[i]);\n            }\n        }\n        if (j == 0)\n            /* We didn't mark anything for the Encoding array. */\n            /* We add \"dup 0 /.notdef put\" for compatibility   */\n            /* with Acrobat 5.0.                               */\n            t1_puts(\"dup 0 /.notdef put\\n\");\n        t1_puts(\"readonly def\\n\");\n    }\n    do {\n        t1_getline();\n        t1_scan_param();\n        if (!t1_prefix(\"/UniqueID\"))    /* ignore UniqueID for subsetted fonts */\n            t1_putline();\n    } while (t1_in_eexec == 0);\n}\n\nstatic void cs_init(void)\n{\n    cs_ptr = cs_tab = NULL;\n    cs_dict_start = cs_dict_end = NULL;\n    cs_count = cs_size = cs_size_pos = 0;\n    cs_token_pair = NULL;\n    subr_tab = NULL;\n    subr_array_start = subr_array_end = NULL;\n    subr_max = subr_size = subr_size_pos = 0;\n}\n\nstatic void init_cs_entry(cs_entry *cs)\n{\n    cs->data = NULL;\n    cs->name = NULL;\n    cs->len = 0;\n    cs->cslen = 0;\n    cs->used = false;\n    cs->valid = false;\n}\n\nstatic void t1_read_subrs(void)\n{\n    int i, s;\n    cs_entry *ptr;\n    t1_getline();\n    while (!(t1_charstrings() || t1_subrs())) {\n        t1_scan_param();\n        t1_putline();\n        t1_getline();\n    }\n  found:\n    t1_cs = true;\n    t1_scan = false;\n    if (!t1_subrs())\n        return;\n    subr_size_pos = strlen(\"/Subrs\") + 1;\n    /* subr_size_pos points to the number indicating dict size after \"/Subrs\" */\n    subr_size = t1_scan_num(t1_line_array + subr_size_pos, 0);\n    if (subr_size == 0) {\n        while (!t1_charstrings())\n            t1_getline();\n        return;\n    }\n    subr_tab = xtalloc(subr_size, cs_entry);\n    for (ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n        init_cs_entry(ptr);\n    subr_array_start = xstrdup(t1_line_array);\n    t1_getline();\n    while (t1_cslen) {\n        store_subr();\n        t1_getline();\n    }\n    /* mark the first four entries without parsing */\n    for (i = 0; i < subr_size && i < 4; i++)\n        subr_tab[i].used = true;\n    /* the end of the Subrs array might have more than one line so we need to\n       concatnate them to subr_array_end. Unfortunately some fonts don't have\n       the Subrs array followed by the CharStrings dict immediately (synthetic\n       fonts). If we cannot find CharStrings in next POST_SUBRS_SCAN lines then\n       we will treat the font as synthetic and ignore everything until next\n       Subrs is found\n     */\n\n#define POST_SUBRS_SCAN  5\n\n    s = 0;\n    *t1_buf_array = 0;\n    for (i = 0; i < POST_SUBRS_SCAN; i++) {\n        if (t1_charstrings())\n            break;\n        s += t1_line_ptr - t1_line_array;\n        alloc_array(t1_buf, s, T1_BUF_SIZE);\n        strcat(t1_buf_array, t1_line_array);\n        t1_getline();\n    }\n    subr_array_end = xstrdup(t1_buf_array);\n    if (i == POST_SUBRS_SCAN) { /* CharStrings not found;\n                                   suppose synthetic font */\n        for (ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n            if (ptr->valid)\n                xfree(ptr->data);\n        xfree(subr_tab);\n        xfree(subr_array_start);\n        xfree(subr_array_end);\n        cs_init();\n        t1_cs = false;\n        t1_synthetic = true;\n        while (!(t1_charstrings() || t1_subrs()))\n            t1_getline();\n        goto found;\n    }\n}\n\n#define t1_subr_flush()  t1_flush_cs(true)\n#define t1_cs_flush()    t1_flush_cs(false)\n\nstatic void t1_flush_cs(boolean is_subr)\n{\n    char *p;\n    byte *r, *return_cs = NULL;\n    cs_entry *tab, *end_tab, *ptr;\n    char *start_line, *line_end;\n    int count, size_pos;\n    unsigned short cr, cs_len = 0;      /* to avoid warning about uninitialized use of cs_len */\n    if (is_subr) {\n        start_line = subr_array_start;\n        line_end = subr_array_end;\n        size_pos = subr_size_pos;\n        tab = subr_tab;\n        count = subr_max + 1;\n        end_tab = subr_tab + count;\n    } else {\n        start_line = cs_dict_start;\n        line_end = cs_dict_end;\n        size_pos = cs_size_pos;\n        tab = cs_tab;\n        end_tab = cs_ptr;\n        count = cs_count;\n    }\n    t1_line_ptr = t1_line_array;\n    for (p = start_line; p - start_line < size_pos;)\n        *t1_line_ptr++ = *p++;\n    while (isdigit((unsigned char)*p))\n        p++;\n    sprintf(t1_line_ptr, \"%u\", count);\n    strcat(t1_line_ptr, p);\n    t1_line_ptr = eol(t1_line_array);\n    t1_putline();\n\n    /* create return_cs to replace unused subr's */\n    if (is_subr) {\n        cr = 4330;\n        cs_len = 0;\n        /* at this point we have t1_lenIV >= 0;\n         * a negative value would be caught in t1_scan_param() */\n        return_cs = xtalloc(t1_lenIV + 1, byte);\n        for (cs_len = 0, r = return_cs; cs_len < t1_lenIV; cs_len++, r++)\n            *r = cencrypt(0x00, &cr);\n        *r = cencrypt(CS_RETURN, &cr);\n        cs_len++;\n    }\n\n    for (ptr = tab; ptr < end_tab; ptr++) {\n        if (ptr->used) {\n            if (is_subr)\n                sprintf(t1_line_array, \"dup %lu %u\",\n                        (unsigned long) (ptr - tab), ptr->cslen);\n            else\n                sprintf(t1_line_array, \"/%s %u\", ptr->name, ptr->cslen);\n            p = strend(t1_line_array);\n            memcpy(p, ptr->data, ptr->len);\n            t1_line_ptr = p + ptr->len;\n            t1_putline();\n        } else {\n            /* replace unsused subr's by return_cs */\n            if (is_subr) {\n                sprintf(t1_line_array, \"dup %lu %u%s \",\n                        (unsigned long) (ptr - tab), cs_len, cs_token_pair[0]);\n                p = strend(t1_line_array);\n                memcpy(p, return_cs, cs_len);\n                t1_line_ptr = p + cs_len;\n                t1_putline();\n                sprintf(t1_line_array, \" %s\", cs_token_pair[1]);\n                t1_line_ptr = eol(t1_line_array);\n                t1_putline();\n            }\n        }\n        xfree(ptr->data);\n        if (ptr->name != notdef)\n            xfree(ptr->name);\n    }\n    sprintf(t1_line_array, \"%s\", line_end);\n    t1_line_ptr = eol(t1_line_array);\n    t1_putline();\n    if (is_subr)\n        xfree(return_cs);\n    xfree(tab);\n    xfree(start_line);\n    xfree(line_end);\n}\n\nstatic void t1_mark_glyphs(void)\n{\n    int i;\n    char *charset = extra_charset();\n    char *g, *s, *r;\n    cs_entry *ptr;\n    if (t1_synthetic || embed_all_glyphs(tex_font)) { /* mark everything */\n        if (cs_tab != NULL)\n            for (ptr = cs_tab; ptr < cs_ptr; ptr++)\n                if (ptr->valid)\n                    ptr->used = true;\n        if (subr_tab != NULL) {\n            for (ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n                if (ptr->valid)\n                    ptr->used = true;\n            subr_max = subr_size - 1;\n        }\n        return;\n    }\n    mark_cs(notdef);\n    for (i = 0; i < 256; i++)\n        if (is_used_char(i)) {\n            if (t1_glyph_names[i] == notdef)\n                pdftex_warn(\"character %i is mapped to %s\", i, notdef);\n            else\n                mark_cs(t1_glyph_names[i]);\n        }\n    if (charset == NULL)\n        goto set_subr_max;\n    g = s = charset + 1; /* skip the first '/' */\n    r = strend(g);\n    while (g < r) {\n        while (*s != '/' && s < r)\n            s++;\n        *s = 0; /* terminate g by rewriting '/' to 0 */\n        mark_cs(g);\n        g = s + 1;\n    }\n  set_subr_max:\n    if (subr_tab != NULL)\n        for (subr_max = -1, ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n            if (ptr->used && ptr - subr_tab > subr_max)\n                subr_max = ptr - subr_tab;\n}\n\nstatic void t1_check_unusual_charstring(void)\n{\n    char *p = strstr(t1_line_array, charstringname) + strlen(charstringname);\n    int i;\n    /* if no number follows \"/CharStrings\", let's read the next line */\n    if (sscanf(p, \"%i\", &i) != 1) {\n        /* pdftex_warn(\"no number found after `%s', I assume it's on the next line\",\n                    charstringname); */\n        strcpy(t1_buf_array, t1_line_array);\n\n        /* t1_getline always appends EOL to t1_line_array; let's change it to\n         * space before appending the next line\n         */\n        *(strend(t1_buf_array) - 1) = ' ';\n\n        t1_getline();\n        alloc_array(t1_buf, strlen(t1_line_array) + strlen(t1_buf_array) + 1, T1_BUF_SIZE);\n        strcat(t1_buf_array, t1_line_array);\n        alloc_array(t1_line, strlen(t1_buf_array) + 1, T1_BUF_SIZE);\n        strcpy(t1_line_array, t1_buf_array);\n        t1_line_ptr = eol(t1_line_array);\n    }\n}\n\nstatic void t1_subset_charstrings(void)\n{\n    cs_entry *ptr;\n\n    /* at this point t1_line_array contains \"/CharStrings\".\n       when we hit a case like this:\n         dup/CharStrings\n         229 dict dup begin\n       we read the next line and concatenate to t1_line_array before moving on\n    */\n    t1_check_unusual_charstring();\n\n    cs_size_pos = strstr(t1_line_array, charstringname)\n                  + strlen(charstringname) - t1_line_array + 1;\n    /* cs_size_pos points to the number indicating\n       dict size after \"/CharStrings\" */\n    cs_size = t1_scan_num(t1_line_array + cs_size_pos, 0);\n    cs_ptr = cs_tab = xtalloc(cs_size, cs_entry);\n    for (ptr = cs_tab; ptr - cs_tab < cs_size; ptr++)\n        init_cs_entry(ptr);\n    cs_notdef = NULL;\n    cs_dict_start = xstrdup(t1_line_array);\n    t1_getline();\n    while (t1_cslen) {\n        store_cs();\n        t1_getline();\n    }\n    cs_dict_end = xstrdup(t1_line_array);\n    t1_mark_glyphs();\n    if (subr_tab != NULL) {\n        if (cs_token_pair == NULL)\n            pdftex_fail\n                (\"This Type 1 font uses mismatched subroutine begin/end token pairs.\");\n        t1_subr_flush();\n    }\n    for (cs_count = 0, ptr = cs_tab; ptr < cs_ptr; ptr++)\n        if (ptr->used)\n            cs_count++;\n    t1_cs_flush();\n}\n\nstatic void t1_subset_end(void)\n{\n    if (t1_synthetic) {         /* copy to \"dup /FontName get exch definefont pop\" */\n        while (!strstr(t1_line_array, \"definefont\")) {\n            t1_getline();\n            t1_putline();\n        }\n        while (!t1_end_eexec())\n            t1_getline();       /* ignore the rest */\n        t1_putline();           /* write \"mark currentfile closefile\" */\n    } else\n        while (!t1_end_eexec()) {       /* copy to \"mark currentfile closefile\" */\n            t1_getline();\n            t1_putline();\n        }\n    t1_stop_eexec();\n    if (fixedcontent) {         /* copy 512 zeros (not needed for PDF) */\n        while (!t1_cleartomark()) {\n            t1_getline();\n            t1_putline();\n        }\n        if (!t1_synthetic)      /* don't check \"{restore}if\" for synthetic fonts */\n            t1_check_end();     /* write \"{restore}if\" if found */\n    }\n    get_length3();\n}\n\nstatic void writet1(void)\n{\n    read_encoding_only = false;\n    if (!is_included(fm_cur)) { /* scan parameters from font file */\n        if (!t1_open_fontfile(\"{\"))\n            return;\n        t1_scan_only();\n        t1_close_font_file(\"}\");\n        return;\n    }\n    if (!is_subsetted(fm_cur)) { /* include entire font */\n        if (!t1_open_fontfile(\"<<\"))\n            return;\n        t1_include();\n        t1_close_font_file(\">>\");\n        return;\n    }\n    /* partial downloading */\n    if (!t1_open_fontfile(\"<\"))\n        return;\n    t1_subset_ascii_part();\n    t1_start_eexec();\n    cc_init();\n    cs_init();\n    t1_read_subrs();\n    t1_subset_charstrings();\n    t1_subset_end();\n    t1_close_font_file(\">\");\n}\n\nboolean t1_subset_2(char *fontfile, unsigned char *g, char *extraGlyphs)\n{\n    int i;\n    for (i = 0; i < 256; i++)\n        ext_glyph_names[i] = (char*) notdef;\n    grid = g;\n    cur_file_name = fontfile;\n    hexline_length = 0;\n    dvips_extra_charset = extraGlyphs;\n    writet1();\n    for (i = 0; i < 256; i++)\n        if (ext_glyph_names[i] != notdef)\n            free(ext_glyph_names[i]);\n    return 1; /* note:  there *is* no unsuccessful return */\n}\n", "2018-09-18 Nick Roessler <nicholas.e.roessler@gmail.com>\n\t* fonts/writet1.w (t1_check_unusual_charstring): protect against\n\tbuffer overflow.\n\n2018-08-27 Luigi Scarso <luigi.scarso@gmail.com>\n\t* dropped dependency from gmp and mpfr\n\n\n2017-11-02 Luigi Scarso <luigi.scarso@gmail.com>\n\tLuaFilesystem 1.7.0\n\n2017-10-03  Luigi Scarso <luigi.scarso@gmail.com>\n\tA not exhaustive list of changes:\n\n\t* luaffi/: Fix to compile with gcc 7.1, \n\tpatch for callbacks.\n\t* lpeg/: version 1.0.1\n\n\t* luatex.c: We conform to the way Web2c does handle trailing tabs and spaces. This\n\tdecade old behaviour was changed in September 2017 and can introduce\n\tcompatibility issues in existing workflows. Because we don't want too\n\tmany differences with upstream TeXlive we just follow up on that patch\n\tand it's up to macro packages to deal with possible issues (which can be\n\tdone via the usual callbacks. One can wonder why we then still prune\n\tspaces but we leave that to the reader.\n\n\t* option to set exit code (status.setexitcode) (HH). Changed paths:\n\tluatexdir/tex/errors.h, luatexdir/tex/errors.w\n\n\t* missing_glyph callback (HH). Changed paths:\n\tluatexdir/font/texfont.h, luatexdir/font/texfont.w,luatexdir/lua/lcallbacklib.c\n\tluatexdir/luatexcallbackids.h, \tluatexdir/pdf/pdffont.w, luatexdir/pdf/pdfglyph.w;\n\n\t* \\mathdelimitersmode (see manual) (HH). Changed paths:\n\tluatexdir/tex/mlist.w, luatexdir/tex/texnodes.h\n\n\t* fixes in protect/unprotect and list support in set/getglue (HH). Changed paths:\n\tluatexdir/lua/lnodelib.c\n\n\t* 'class' string in pdf vf command optional (HH). Changed paths:\n\tluatexdir/font/luafont.w\n\n\t* cleanup expansion (HH). Changed paths:\n\tluatexdir/font/luafont.w, luatexdir/font/texfont.h, luatexdir/font/texfont.w\n\tluatexdir/lua/lfontlib.c, luatexdir/lua/luatex-api.h, luatexdir/tex/dumpdata.w\n\n\t* possibly better fix for extended font embedding (HH). Changed paths:\n\tluatexdir/font/writefont.w\n\n\t* protect_glyphs accepts range and also made consistent with manual (HH). Changed path:\n\tluatexdir/lua/lnodelib.c\n\n\t* some more control over syntex fields (HH). Changed paths:\n\tluatexdir/tex/texnodes.w\n\n\t* fix for neg display skips (HH). Changed paths:\n\tluatexdir/tex/texmath.w\n\n\t* \\breakafterdirmode (value 1 will honor glue breaks after a dir node) (HH). Changed paths:\n\tluatexdir/tex/commands.w, luatexdir/tex/dumpdata.w, luatexdir/tex/equivalents.h,\n\tluatexdir/tex/linebreak.w, luatexdir/tex/texnodes.h\n\n\t* fix width array of extended font (shared with normal)(HH). Changed paths:\n\tluatexdir/font/writefont.w\n\n\n\n2017-02-07  Luigi Scarso <luigi.scarso@gmail.com>\n\n\t* luaffi/: First attempt to implement the ffi module in lua\n\tcompatible with the ffi module of luajit.\n\n\n2015-11-01  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* luatex.c: Improve a little (w32 only).\n\n2015-10-31  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* tex/inputstack.w: Sync with the upstream.\n\n2015-10-13  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* tex/mlist.w: Sync with the upstream.\n\n2015-10-09  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* luatex.c: Sync with the upstream.\n\t* font/luatexfont.h, font/writetype2.w: Sync with the upstream.\n\n2015-10-08  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* lua/lepdflib.cc, tex/texnodes.h, tex/texnodes.w, NEWS:\n\tSync with the upstream.\n\t* luatex.c: beta-0.81.0.\n\n2015-10-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am, am/luafontforge.am: Rearrange to compile the\n\tluafontloader/src/* files as part of liblua(jit)tex.a, such that\n\tthere is only one libff.a used for LuaTeX and LuaJITTeX.\n\n2015-10-07  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* Sync with the upstream trunk.\n\t* image/epdf.h: Support Visual Studio 2010 for log().\n\n2015-10-05  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* Completely sync with the upstream trunk.\n\tChanged files are\n\tfont/writecff.w, font/writefont.w,\n\tlua/lnodelib.c, lua/lpdflib.c, lua/luatoken.w,\n\tluafontloader/fontforge/fontforge/lookups.c,\n\tluafontloader/fontforge/fontforge/parsettf.c,\n\tluafontloader/fontforge/fontforge/parsettfatt.c,\n\tluafontloader/fontforge/fontforge/splinefont.h,\n\tluafontloader/fontforge/fontforge/tottf.c,\n\tluafontloader/src/luafflib.c,\n\tluatex.c,\n\ttex/commands.w, tex/dumpdata.w, tex/equivalents.h, tex/filename.w,\n\ttex/maincontrol.w, tex/printing.w, tex/texmath.w.\n\n2015-10-01  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdf/pdfgen.w: Sync with the upstream trunk.\n\n2015-09-01  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/lepdflib.cc: Drop useless casts 'const char *' -> 'char *'\n\twhen poppler has Object::initCmd(const char*).\n\n2015-08-31  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/lepdflib.cc: Bugfix: m_Object_dictAdd() must use a copy of\n\tthe Lua string s, otherwise m_Dict_remove() would destroy it.\n\n2015-08-29  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/epdf.h, lua/lepdflib.cc: Drop HAVE_STRUCTTREEROOT_H,\n\twe now require poppler 0.30 better.\n\t\n2015-08-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am: Enable g++ warnings.\n\t* image/epdf.h, image/pdftoepdf.w, lua/lepdflib.cc: Avoid most\n\tg++ warnings.\n\n2015-08-27  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/pdftoepdf.w: Drop useless casts to avoid warnings.\n\t* lua/lpdfscannerlib.cc: Unconstify Token.string to avoid warning.\n\t* lua/lepdflib.cc: Drop useless casts to avoid some warnings.\n\n2015-08-27  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* tex/mlist.w: Sync with the trunk.\n\tSee http://tug.org/pipermail/luatex/2015-August/005319.html\n\t* tex/printing.w: Do not write to a log file for the\n\t--[no-]parse-first-line option, since the option actually does not\n\texist in lua(jit)tex, although superficially it remains for compatibility\n\twith existing scripts etc.\n\n2015-07-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luatex.am: Dependencies for 'make check'.\n\n2015-07-03  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/lkpselib.c: Also used for MFLua and MFLuaJIT.\n\n2015-03-31  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luazip/src/luazip.c (zip_close): Sync with the upstream.\n\n2015-03-19 Luigi Scarso <luigi.scarso@gmail.com>\n\n\tNew library newtokenlib; several bugs fixed.\n\n2015-01-14 Luigi Scarso <luigi.scarso@gmail.com>\n\n\ttex/mlist.w: mlist_to_hlist(pointer mlist, boolean penalties, int cur_style)\n\tHH-LS: was cur_mu = x_over_n(get_math_quad(cur_size), 18);\n\tThis is an old bug so the fix can influence outcome       \n\tThe current mu is instead\n\tcur_mu = x_over_n(get_math_quad(cur_style), 18);\n\tThanks to joseph.wright <joseph.wright@morningstar2.co.uk>\n\n2014-12-21  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* lua/lnodelib.c: Sync with the upstream. Luigi fixes 'print' for\n\talink(n) when n is an attribute node.\n\n2014-12-20  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* tex/texnodes.w: Sync with the upstream. Luigi makes minor changes.\n\n2014-12-18  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* tex/texnodes.w: Sync with the upstream. Luigi makes minor changes.\n\n2014-12-17  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* tex/texnodes.w: Sync with the upstream.\n\tLuigi fixes a bug on cached attributes.\n\n2014-12-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tAvoid implicit function declarations.\n\t* am/luafontforge.am (libjitff_a_CPPFLAGS): Add -DLuajitTeX.\n\t* am/luamisc.am (libluajitmisc_a_CPPFLAGS: Add -DLuajitTeX.\n\t* lua/liolibext.c, lua/lnodelib.c, luafontloader/src/luafflib.c,\n\tslnunicode/slnunico.c: Include lauxlib_bridge.h for LuaJITTeX or\n\tlauxlib.h for LuaTeX.\n\t* luafontloader/fontforge/fontforge/fontviewbase.c:\n\tInclude gfile.h.\t\n\n2014-12-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tSync with https://foundry.supelec.fr/svn/luatex/trunk/source/\n\t                  texk/web2c/luatexdir/ r5092.\n\n2014-11-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.c: Avoid MinGW64 warnings (INVALID_SOCKET => -1).\n\n2014-11-03  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* luatex.c: Indentation.\n\n2014-10-31  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.[ch] [W32TEX]: Handle DLLPROC as for TeX & Co.\n\t* am/luatex.am: Define LuajitTeX.\n\n2014-10-13  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.[ch]: More sync with ../texmfmp.h and ../lib/texmfmp.c.\n\n2014-10-09  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.c: Apply some code from W32TeX.\n\n2014-10-08  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.c: Sync with some recent changes in ../lib/texmfmp.c\n\t(and luatexfirst.c from W32TeX).\n\n2014-09-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luatex.am: Factor out common *_LDADD and *_DEPENDENCIES.\n\n2014-08-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/writepng.w: Avoid PNG warnings.\n\n2014-07-15  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/epdf.h, lua/lepdflib.cc: Use code for poppler >= 0.25\n\twith <StructTreeRoot.h> or code for poppler <= 0.24 without.\n\t* fake/StructTreeRoot.h (removed): Obsolete.\n\t* am/libluatex.am: Adapted.\n\n2014-07-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luasocket/src/wsocket.h: Avoid redefinition of _WIN32_WINNT.\n\n2014-07-11  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am: Compiling liblua(jit)tex.a requires mplib.h;\n\tadd libmplib.a as dependency.\n\n2014-06-20  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am: Remove ../mplibdir/lmplib.c from sources and\n\tdependency on libmplib.a.\n\t* am/luatex.am: Add ../mplibdir/lmplib.c to sources, dependency\n\ton libmplib.a, and -DpdfTeX to CPPFLAGS.\n\n\t* am/luatex.am: Adapt to MetaPost 1.999 (libgmp and libmpfr).\n\n2014-06-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* font/mapfile.w, font/tounicode.w, font/writet1.w,\n\tfont/writettf.w, lang/texlang.w, pdf/pdfgen.w: Avoid undefined\n\tbehaviour when char is signed.\n\n2014-06-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/luatex-api.h: Use '#define LUAI_HASHLIMIT 5' as default,\n\tas in ../../libs/lua52/lua-5.2.3/src/lstring.c and in\n\t../../libs/luajit/LuaJIT-2.0.3/src/lj_str.c.\n\t* lua/lstatslib.c, tex/printing.w: Use LUAI_HASHLIMIT instead of\n\tLUATEX_HASHCHARS and LUAJITTEX_HASHCHARS.\n\n\t* lua/luatex-api.h: Define MyName as \"LuajitTeX\"/\"LuaTeX\" and\n\tmy_name as \"luajittex\"/\"luatex\".\n\t* lua/luainit.w, luatex.c, tex/printing.w: Use MyName, my_name.\n\n2014-05-14  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* tex/filename.w: Avoid redefinition of promptfilenamehelpmsg,\n\t(re)use definition in ../cpascal.h.\n\n2014-05-13  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* tex/filename.w: Print the usual TeX promptfilenamehelpmsg also\n\tin lua(jit)tex.\n\n2014-04-10  Taco Hoekwater  <taco@luatex.org>\n\n\t* luatex.c: hardwire the compilation date, preventing the \n\tluatex binary from constantly changing after recompilation\n\n2014-03-29  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdf/pdfgen.[hw]: Declare get_pdf_table_string() as\n\t'static const char *'.\n\n2014-03-29  Taco Hoekwater  <taco@luatex.org>\n\n\tImport LuaTeX 0.79.1 from LuaTeX repository (released)\n\n2014-03-28  Taco Hoekwater  <taco@luatex.org>\n\n\tImport LuaTeX 0.79.0 from LuaTeX repository (released)\n\n2014-03-15  Taco Hoekwater  <taco@luatex.org>\n\n\tImport LuaTeX snapshot 0.79.0 from LuaTeX repository (r4903).\n\n2014-02-10  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* lua/luatex-api.h: MSC version has luaopen_bit32() in dll.\n\n2014-02-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/luatex-api.h: Declare luaopen_bit32();\n\n2014-02-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am, am/luafontforge.am, am/luamisc.am,\n\tam/luasocket.am, am/luatex.am: Add rules for LuaJITTeX.\n\n\t* luajittex.test, luajitimage.test: New tests for LuaJITTeX.\n\n\tAvoid compiler warnings.\n\t* lua/liolibext.c, lua/luajitstuff.w: Drop compilation of\n\tunused static functions.  Avoid to compute unused value.\n\t* lua/texluajitc.w: Include header for luac_main() prototype.\n\t* lua/luatex-api.h: Drop duplicate luac_main() prototype.\n\n2014-02-04  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* lua/luainit.w: Change a little for LuaJITTeX.\n\n2014-02-01  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tImport LuaTeX snapshot 0.78.3 from LuaTeX repository (r4772).\n\n\t* luatexfont.h: Keep the prototype for auto_expand_font() as\n\tlong as the function remains in vfovf.w.\n\n\t* liolibext.c [__MINGW32__]: Don't redefine l_fseek etc.\n\n2014-02-01  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am, am/luafontforge.am, am/luamisc.am,\n\tam/luasocket.am, am/luatex.am: Prepare for LuaJITTeX.\n\n2014-01-31  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* tex/printing.w (print_cs): Bug fix from TeX 3.14159265.\n\n2014-01-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/writepng.w: Allow libpng >= 1.6.3 to read images with\n\tincorrect CMF bytes.\n\n2013-12-23  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdf/pdfgen.w (pdf_end_stream): Always write \"\\nendstream\" for\n\tPDF/A-1b compliance.\n\n2013-12-19  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* lua/liolibext.c: Large files in lua.\n\n2013-12-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/epdf.h, lua/lepdflib.cc: Adapt for poppler-0.25.x.\n\t* fake/StructTreeRoot.h (new): Provide 0.24.4 compatibility.\n\t* am/libluatex.am: Adapted.\n\n2013-12-08  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* font/writet3.w: More cast arg2 of setpdffloat to int64_t.\n\t* pdf/pdfpage.w: Fix i32round() => i64round().\n\n2013-12-07  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* lua/liolibext.c: Large files in lua.\n\n2013-12-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tFix a serious bug related to large numbers in pdfimages.\n\tMail from Akira Kakuto <kakuto@fuk.kindai.ac.jp>, 6 Dec 2013.\n\t* pdf/pdftypes.h: Change pdffloat.m from long to int64_t.\n\tDefine i32round(a) and i64round(a) instead of lround(a).\n\t* font/writet3.w: Cast arg2 of setpdffloat to int64_t.\n\t* image/writejp2.w: Use uint64_t instead of unsigned long long.\n\t* image/pdftoepdf.w, pdf/pdfgen.w, pdf/pdfglyph.w,\n\tpdf/pdfimage.w, pdf/pdfpage.w, pdf/pdfrule.w: Replace lround(a)\n\tby i32round(a) or i64round(a).\n\n2013-09-20  Karl Berry  <karl@tug.org>\n\n\t* lua/luainit.w (lua_initialize) [NATIVE_TEXLIVE_BUILD]: omit date.\n\t* tex/printing.w (print_banner) [NATIVE_TEXLIVE_BUILD]: replace\n\tdate with WEB2CVERSION for TL binaries.\n\n2013-08-06  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* font/writecff.w: Fix a bug in write_cid_cff(). There was not\n\tpdf_end_dict() for the corresponding pdf_begin_dict().\n\n2013-07-30  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* font/writettf.w: Treat unknown 'post' table versions\n\t(found in some broken fonts) as 3.0, i.e., no Glyph names.\n\n2013-07-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luatex.am, tests/luaimage.tex: Add a .pdf image.\n\n2013-07-05  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdf/pdfgen.w: Use \"%\"LONGINTEGER_PRI\"d\" format specifier to\n\tprint (LONGINTEGER_TYPE) casted longinteger and off_t variables.\n\n2013-07-05  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/luainit.w (init_kpse, lua_initialize):\n\tUse kpse_program_basename().\n\n2013-07-04  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luaimage.test, tests/luaimage.tex: New test and data.\n\t* am/luatex.am: Add the new test.\n\n2013-07-02  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* luatex.c : Replace lines between \"#if defined (TeX) && defined (IPC)\"\n\tand \"#endif /* TeX && IPC */\" with those in texmfmp.c.\n\n2013-07-01  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* luatex.c, ptexlib.h: Revert the previous change.\n\t* luatex.c [MSVC]: Undef timezone before including <time.h>.\n\n2013-06-28  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* luatex.c, ptexlib.h: Slightly modify because Visual Studio cannot\n\tcompile luatex.c.\n\n2013-06-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/lcallbacklib.c, lua/luainit.w: Replace index() => strchr().\n\n\t* ptexlib.h: More general cases for not been included first.\n\n\t* lang/hyphen.h: Do not '#include \"ptexlib.h\"'.\n\t* lang/hyphen.w: Include ptexlib.h instead of lang/hyphen.h.\n\n2013-06-28  Karl Berry  <karl@tug.org>\n\n\t* ptexlib.h: complain if various common things are #defined;\n\tthis must be the first #include.\n\n2013-06-27  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tBug fix for LuaTeX crash on 32bit Unix systems from Taco,\n\ttlbuild mail 26 Jun 2013 16:10:35,\n\thttp://tug.org/pipermail/tex-live/2013-June/033782.html\n\t* image/writejbig2.w, image/writejp2.w, image/writejpg.w,\n\timage/writepng.w: Always first include ptexlib.h.\n\n2013-06-26  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am, am/luasocket.am, am/luatex.am:\n\tCorrect dependencies for build `on demand'.\n\n2013-06-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua52/: Moved to ../../../libs/lua52/.\n\t* am/libluatex.am: Adapted.\n\t* am/liblua52.am: Removed.\n\n2013-06-18  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/epdf.h, image/writeimg.w, lua/limglib.c,\n\tlua/lpdfscannerlib.cc, lua/lstrlibext.c, lua/luatex-api.h,\n\tlua/texluac.w, ptexlib.h: Replace 'lua52/lua.h' => 'lua.h'.\n\n2013-06-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/lpdfscannerlib.cc: Include <poppler-config.h> instead of\n\t<poppler/poppler-config.h>.\n\n2013-04-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/luainit.w: Handle '--luac' and '--luaconly' (from Akira).\n\n2013-04-16  Elie Roux  <elie.roux@telecom-bretagne.eu>\n\n\t* font/tfmofm.w: check for .ofm as well as .tfm.\n\t* tex/mainbody.w: check for !ini_version before initialize().\n\n2013-04-16  Karl Berry  <karl@tug.org>\n\n\t* lua/luainit.w (parse_options): GPLv2+, not just GPLv2 (after\n\tdiscussion with Taco).\n\n2013-04-14  Karl Berry  <karl@tug.org>\n\n\t* lua/luainit.w: 2013\n\n2013-04-08  Taco Hoekwater  <taco@luatex.org>\n\n\t* luasocket/src/smtp.lua: uncomment require 'coroutine'\n\t* luasocket/src/smtp_lua.c: regenerated\n\n2013-04-05  Taco Hoekwater  <taco@luatex.org>\n\n\tImport luatex beta 0.76.0 (released version)\n\n2013-04-04  Karl Berry  <karl@tug.org>\n\n\t* lua52/liolib.c: #include <unistd.h>.  Needed on FreeBSD\n\tper Nikola Lecic, tlbuild 1 Apr 2013 02:10:08.\n\n2013-03-21  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tImport LuaTeX beta-0.75.0 from LuaTeX repository (r4604).\n\n2013-03-20  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luafontforge.am (EXTRA_DIST): Drop unused files.\n\n2013-03-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua52/*, am/liblua52.am (new): Add lua-5.2.1 for 0.75.0.\n\n2013-01-29  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luatex.am: Allow subdir-objects.\n\n2013-01-19  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdf/pdftables.h: Support large files (from Martin).\n\n2013-01-18  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.c (mk_shellcmdlist): Simplify (sync with texmfmp.c).\n\n2013-01-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdf/pdfgen.w (write_stream_length): Cast length for printing.\n\n2012-12-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am (luatex_*_ctangle, pdflua.c):\n\tEnable silent rules.\n\n2012-11-20  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/lkpselib.c: Use kpse_readable_file() with non-const arg.\n\n2012-11-20  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/lepdflib.cc: No need to test for Annot::decRefCnt with\n\tpoppler 0.18 or better.\n\n2012-11-06  Akira Kakuto  <kakuto@fuk.kinidai.ac.jp>\n\n\t* pdf/pdflistout.w: sync with r4471 (a bug fix by H. Henkel).\n\n2012-10-13  Akira Kakuto  <kakuto@fuk.kinidai.ac.jp>\n\n\t* tex/texfileio.w: input by pipe was impossible. enable it.\n\n2012-10-11  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/luainit.w (lua_initialize): Free two malloc()ed strings.\n\n2012-10-10  Akira Kakuto  <kakuto@fuk.kinidai.ac.jp>\n\n\t* luatex.c: Modify determination of fullpath for restricted shell\n\tescape commands.\n\n2012-10-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tAvoid TL vs W32TeX differences (from Akira).\n\t* luatex.h: Include \"ptexlib.h\" instead of <luatexdir/ptexlib.h>\n\tas in all other cases.\n\t* ptexlib.h: Use _MSC_VER instead of MSVC.\n\t* image/epdf.h: Change arg3 of extern void pdf_begin_obj() from\n\tbool to int, as declared and defined in pdf/pdfgen.[hw].\n\tFIXME: There should be only one extern declaration in one file.\n\n2012-10-09  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tThe openbsd compat library is no longer used.\n\t* image/epdf.h, lua/luainit.w, ptexlib.h, utils/utils.w:\n\tDrop #include \"openbsd-compat.h\".\n\t* am/libluatex.am, am/luatex.am: Remove OBSDCOMPAT_*.\n\n2012-09-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/luainit.w (parse_options): Avoid cast const => non-const.\n\n2012-09-13  Akira Kakuto  <kakuto@fuk.kinidai.ac.jp>\n\n\t* lua/luainit.w (parse_options): allow lualatex \"\\input\" \"a b\" on\n\tWindows.\n\n2012-09-08  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex-api.h: Avoid conflicting extern declaration of environ,\n\tdeclared in <stdlib.h> for WIN32 (from W32TeX).\n\n2012-08-21  Akira Kakuto  <kakuto@fuk.kinidai.ac.jp>\n\n\t* tex/texdeffont.w (tex_def_font): Recover the old code, because the\n\tnew code seems not to work.\n\n2012-08-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* ptexlib.h: Drop unused definition of M_PI.\n\n2012-08-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* tex/dumpdata.h: Remove the swap_items() prototype.\n\t* luatex.c (swap_items): Moved from here ...\n\t* tex/texfileio.w (swap_items): ... to here and declared static.\n\n\t* luatex.c (input_line) [WIN32]: Sync with ../lib/texmfmp.c.\n\tDetect and skip Byte order marks.\n\t* tex/texfileio.[ch] [WIN32]: Use Poptr to record pipe input.\n\n2012-08-03  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.[ch] [W32TeX]: Use DLLPROC for luatex.dll.\n\t* pdf/pdfgen.w [WIN32]: Convert file names '\\\\' -> '/'.\n\n2012-08-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* tex/texdeffont.w (tex_def_font): Better tracing of font\n\tdefinitions, adapted from e-TeX version 2.5.\n\n2012-07-31  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdf/pdfpage.w (print_pdffloat): Cope with broken snprintf().\n\t* lua/luastuff.w (luatex_error): Drop snprintf() return value.\n\n2012-07-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/luainit.w (lua_initialize): Avoid using asprintf().\n\t* utils/utils.w (initversionstring): Avoid using asprintf().\n\n\tOne and only one prototype per function.\n\t* image/epdf.h, utils/utils.h: Add #include \"luatex-common.h\"\n\tand move pdftex_{fail,warn} prototypes from here ...\n\t* luatex-common.h (new): ... to here.\n\t* am/libluatex.am (libluatex_a_SOURCES): Add the new file.\n\n2012-07-26  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/loslibext.c os_gettimeofday): Use int64_t (from W32TeX).\n\n2012-07-25  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/pdftoepdf.cc (get_file_checksum): Use uint64_t and PRIu64.\n\t* image/writejp2.w, lua/loslibext.c: Use uint64_t.\n\n2012-07-23  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* tex/texfileio.w (runpopen): Sync with ../lib/texmfmp.c.\n\n2012-07-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/writejbig2.w: Use LONGINTEGER_PRI, not LONGINTEGER_PRId.\n\t* pdf/pdfgen.w: Use LONGINTEGER_PRI, not LONGINTEGER_PRIi.\n\n2012-07-14  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils/utils.w: Use EXIT_FAILURE instead of EX_SOFTWARE.\n\n2012-07-13  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdf/pdfgen.w: Cast xfseeko() arg2 to avoid MSVC warning.\n\n2012-07-09  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* tex/texfileio.w (runpopen): Sync with ../lib/texmfmp.c.\n\n2012-07-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.c (shell_cmd_is_allowed): Change Arg1 from 'const char **'\n\tinto 'const char *'; sync with ../lib/texmfmp.c.\n\t* luatex.h, lua/liolib.c, lua/loslibext.c, tex/texfileio.w: Adapt.\n\n\t* lua/liolib.c, luascripts/txt2zlib.w: Use binary file io mode.\n\tFrom Akira Kakuto <kakuto@fuk.kindai.ac.jp> (W32TeX).\n\n2012-05-22  Taco Hoekwater  <taco@luatex.org>\n\n\t* lua/lkpselib.c: new function kpse.default_texmfcnf() that\n\treports the value of DEFAULT_TEXMFCNF, for the benefit of\n\tcontext mkiv on Debian.\n\n2012-05-22  Taco Hoekwater  <taco@luatex.org>\n\n\t* luafontloader/fontforge/fontforge/splinesave.c,\n\tluafontloader/fontforge/fontforge/splinefont.h: drop parts of the\n\tType1 saving routines (unused) to remove a compiler warning.\n\n\t* pdf/pdftypes.h, lua/limglib.c, image/epdf.h, image/writeimg.w,\n\timage/writejbig2.w, ptexlib.h: more off_t trouble.\n\n2012-05-21  Taco Hoekwater  <taco@luatex.org>\n\n\t* tex/printing.w, lua/ltokenlib.c, lua/llanglib.c, lua/llualib.c,\n\tlua/lnodelib.c, lua/luainit.w, lua/ltexiolib.c,\n\tlua/lcallbacklib.c, lua/lstatslib.c, lua/ltexlib.c,\n\tlua/loslibext.c, lua/lkpselib.c, lua/luatoken.w, lua/llfslibext.c,\n\tlua/lfontlib.c, lua/luanode.w, lua/lpdflib.c, lua/luastuff.w:\n\twhen loading both \"ptexlib.h\" and \"lua/luatex-api.h\", make sure\n\tthat \"ptexlib.h\" is loaded first because that reads config.h\n\twhich affects loading of system headers (via Large File Support,\n\tspecifically).\n\n2012-05-20  Khaled Hosny  <khaledhosny@eglug.org>\n\n\t* tex/mlist.w: fix \"warning: 'ext' might be used uninitialized\".\n\n2012-05-18  Taco Hoekwater  <taco@luatex.org>\n\n\t* lua/ltexlib.c: fix a ConTeXt crash on `\\endinput \\end`.\n\n2012-05-18  Khaled Hosny  <khaledhosny@eglug.org>\n\n\t* tex/commands.h, tex/commands.w, tex/maincontrol.h,\n\ttex/maincontrol.w, tex/mathcodes.h, tex/mathcodes.w, tex/scanning.w, \n\ttex/texmath.w, tex/mlist.w: backport math relatex changes from 0.71\n\t* luatex.c: bump version to 0.70.1\n\n2012-05-10  Hartmut Henkel  <hartmut@luatex.org>\n\tand Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/lepdflib.cc: Adapt for poppler 0.19.4.\n\n2012-05-09  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/luainit.w (lua_initialize): Use WEB2CVERSION.\n\t* tex/printing.w (print_banner, log_banner): Same.\n\n2012-02-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.h: Remove definition of WRITE_OUT, now in ../cpascal.h.\n\n2012-01-18  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/writejbig2.w (getstreamlen): Change type to `off_t'.\n\tUse LONGINTEGER_TYPE and LONGINTEGER_PRId for printing.\n\n2012-01-11  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tConsistent support for large JBIG2 files.\n\t* image/writejbig2.w: Change type of various struct members, local\n\tvariables and findstreamstart() from `long' or `unsigned long'\n\tto `off_t'.  Do not use xfseek and xfseeko for the same file.\n\n2011-10-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/lepdflib.cc: Test poppler 0.16.x / 0.17.x features.\n\n2011-10-04  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am: Avoid to `clean' ../mplibdir/lmplib.c.\n\n\t* am/txt2zlib.am (noinst_PROGRAMS): Conditionally add txt2zlib,\n\tsuch that txt2zlib$(EXEEXT) gets cleaned.\n\n2011-09-30  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* tex/printing.w (print_file_line): Bug fix: avoid uninitialized\n\tlineno - from ../tex.ch.\n\t* tex/inputstack.w: Slightly reformulate printing of current\n\tline - from ../etexdir/etex.ch.\n\n2011-08-04  Magnus Granberg  <zorry@gentoo.org>\n\n\t* luatex.c: Do not #include empty file <kpathsea/recorder.h>.\n\n2011-06-17  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tReduce memory leaks.\n\t* lua/lkpselib.c (do_lua_kpathsea_lookup): Free string no longer\n\tused.\n\n2011-06-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tlua/lkpselib.c (find_dpi): Allow find_suffix() to return a\n\tconst string.\n\n2011-05-19  Taco Hoekwater  <taco@luatex.org>\n\n\t* lua/ltexlib.c: fix a bug on negative catcode table arguments.\n\t* luatex.c, NEWS: luatex is now version 0.70.1\n\t* luatex_svnversion.h: updated to reflect latest luatex revision (4277)\n\n2011-05-18  Taco Hoekwater  <taco@luatex.org>\n\n\t* font/writefont.w (write_fontdescriptor):  Fix for non-embedded\n\tfonts in the PDF output.\n\t* image/writeimg.w (read_img): Fix for non-existent images that\n\tcould case a crash.\n\t* luatex_svnversion.h: updated to reflect latest luatex revision (4273)\n\n2011-05-18  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.c (ipcpage): Add 'free(cwd)', remove Aleph comment.\n\n2011-05-17  Taco Hoekwater  <taco@luatex.org>\n\n\t* tex/texfileio.w (luatex_synctex_get_current_name): switch to xgetcwd()\n\tfrom kpathsea\n\t* luatex_svnversion.h: updated to reflect latest luatex revision (4272)\n\n2011-05-15  Taco Hoekwater  <taco@luatex.org>\n\n\t* tex/texfileio.w (luatex_synctex_get_current_name): work around a \n\tbug in getcwd().\n\t* luatex_svnversion.h: updated to reflect latest luatex revision (4267)\n\n2011-05-13  Taco Hoekwater  <taco@luatex.org>\n\n\t* lua/luainit.w: change the copyright year to 2011.\n\t* luatex_svnversion.h: updated to reflect latest luatex revision (4264)\n\t* NEWS: forgot to mention synctex change\n\t\n2011-05-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/writepng.w: #define PNG_FP_1 for libpng < 1.5.0.\n\n2011-05-11  Taco Hoekwater  <taco@luatex.org>\n\n\t* image/writepng.w: fix for 16bit images in pdf 1.4 (8bit) mode.\n\t* luatex_svnversion.h: updated to reflect latest luatex revision (4258)\n\n2011-05-09  Taco Hoekwater  <taco@luatex.org>\n\n\t* tex/texfileio.[hw]: file relative filenames in synctex output.\n\t* luatex_svnversion.h: updated to reflect latest luatex revision (4256)\n\n2011-05-08  Taco Hoekwater  <taco@luatex.org>\n\n\t* dvi/dvigen.w, pdf/pdfgen.w: fix missing newline after\n\t'No pages of output' message.\n\t   \n2011-05-08  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* lua/luainit.w, tex/texfileio.w: fix recorder location.\n\n2011-05-05  Taco Hoekwater  <taco@luatex.org>\n\n\t* image/writepng.w: fixes for libpng 1.5.2.\n\t* lua/lnodelib.c (lua_nodelib_fields): fix field count for \n\tnodes without subtype.\n\t* lua/llfslibext.c: fix an variable type and a compiler warning.\n\t* lua/loslibext.c (os_execute): fix non-argument use of os.execute.\n\t* lua/ltexlib.c (do_luacprint): fix use of bad catcode tables.\n\t* lua/luainit.w (HAVE_ASPRINTF): superfluous test removed.\n\t* luatex.c: bump version to 0.70, remove SOCK_NONBLOCK definition.\n\t* luatex_svnversion.h (luatex_svn_revision): now at 4247.\n\t* NEWS: updated for luatex 0.70.0 release.\n\t* tex/texfileio.w: patch from bug 615 (recorder filename location).\n\t* tex/texmath.w: fix display alignment in TRT mode.\n\t* utils/utils.w (HAVE_ASPRINTF): superfluous test removed.\n\n2011-04-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils/synctex{-common.h,.c,.h} (removed): Use copies from\n\t../synctexdir.\n\t* synctex-luatex.h: Moved from here to ../../synctexdir.\n\t* ptexlib.h, am/libluatex.am, am/luatex.am: Adapted. \n\n2011-04-13  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils/utils.w (POPPLER_VERSION): Now defined in\n\tpoppler-config.h for poppler from the TeX Live tree, or in the\n\tMakefile for an installed version.\n\n2011-04-13  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am, am/txt2zlib.am: When cross compiling skip\n\ttxt2zlib and use installed luascripts/pdflua.c.\n\n\tNeed poppler at least 0.12 for PDFDoc::getPDF*Version().\n\t* image/pdftoepdf.cc: Remove code for older poppler versions.\n\n2011-04-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/writepng.w: Fix to build with png-1.5 (and avoid\n\t`deprecated' warnings with png-1.4). The transformations part\n\tis removed on recommendation by John Bowler (a png developer).\n\tMail from Thomas Klausner <tk@giga.or.at>, Sun, 30 Jan 2011.\n\n\t* pdf/pdfgen.w: ANSI C function definitions.\n\n\t* pdf/pdfluaapi.w (new_pdflua): Declare zp as const.\n\n\t* am/libluatex.am (EXTRA_DIST): Distribute luascripts/pdflua.lua.\n\t* am/txt2zlib.am (EXTRA_DIST): Distribute luascripts/txt2zlib.w.\n\n2011-04-12  Taco Hoekwater  <taco@luatex.org>\n\n\t* import of luatex 0.66.0, released version\n\n2011-03-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am: Use AM_CFLAGS instead of libluatex_a_CFLAGS.\n\t* am/luatex.am: Use AM_CFLAGS instead of luatex_CFLAGS.\n\n2011-03-14  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am (libluatex_a_CPPFLAGS): Remove `-Iluatexdir'\n\tand add `-DSYNCTEX_ENGINE_H='<utils/synctex-luatex.h>''.\n\t* am/luatex.am (luatex_CPPFLAGS): The same.\n\n\t* utils/synctex.c: Fix several typos in comments to reduce diffs\n\tbetween files in synctexdir/ and luatexdir/utils/.\n\n2011-02-15  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luatex.am [WIN32]: Add texlua.exe and texluac.exe wrappers\n\tfor MinGW.\n\n2010-12-23  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luatex.am: install-exec-hook and uninstall-hook rules now\n\tin ../Makefile.am; append required symlinks to bin_links.\n\n2010-09-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.test (new): Just testing 'luatex -credits'.\n\t* luatexdir/am/luatex.am: Adjusted.\n\n2010-07-12  Taco Hoekwater <taco@luatex.org>\n\n\t* luafontloader/src/luafflib.c: quick fix for crashes triggered\n\tby invalid panose data in Open/TrueType fonts.\n\t* luatex_svnversion.h: new version (rev 3736).\n\n2010-07-01  Taco Hoekwater <taco@luatex.org>\n\n\t* lang/texlang.w, lua/lnodelib.c, luatex.c, luatex_svnversion.h,\n\tpdf/pdfglyph.w, pdf/pdfpage.w, NEWS: new versions from released 0.60.2\n\t\n2010-06-18  Taco Hoekwater <taco@luatex.org>\n\n\t* tex/textoken.h (smemory_word): add endiannes test\n\t* font/texfont.h (liginfo, kerninfo): add endianness test\n\t* luatex_svnversion.h: new version\n\n2010-06-13  Taco Hoekwater <taco@luatex.org>\n\n\t* tex/inputstack.h (in_state_record): force two bitfields to be signed,\n\tafter a bug report from Vladimir Volovich <vvv@vsu.ru>\n\t* luatex_svnversion.h: new version\n\n2010-06-11  Taco Hoekwater <taco@luatex.org>\n\n\t* font/sfnt.w, font/sfnt.h, \n\tluafontloader/fontforge/Unicode/ucharmap.c,\n\tluafontloader/fontforge/fontforge/python.c, \n\tluafontloader/fontforge/inc/basics.h: change include of \"config.h\"\n\tto <w2c/config.h>.\n\t* image/epdf.h, lua51/luaconf.h: change include of \"c-auto.h\"\n\tto <w2c/c-auto.h>.\n\t\n2010-06-10  Taco Hoekwater <taco@luatex.org>\n\n\t* luatex.c (swap_items): debugged.\n\t* tex/texfileio.w (do_zdump): reswap the swapped items to avoid\n\tcrashes when called as |dump_things|.\n\n2010-06-10  Taco Hoekwater <taco@luatex.org>\n\n\t* luafilesystem/src/lfs.c(get_dir): do not assume Gnu C compiler.\n\n2010-06-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libluatex.am (libluatex_a_CPPFLAGS): Add $(AM_CPPFLAGS).\n\t* am/luafontforge.am (libff_a_CPPFLAGS): Add $(AM_CPPFLAGS).\n\t* am/luatex.am (luatex_CPPFLAGS): Add $(AM_CPPFLAGS).\n\n2010-06-10  Taco Hoekwater <taco@luatex.org>\n\n\t* luasocket/src/options.c, luafontloader/fontforge/fontforge/parsettfatt.c,\n\tluafontloader/fontforge/fontforge/parsettf.c,\n\tluafontloader/fontforge/fontforge/lookups.c: enlarge static buffers\n\tfor sprintf().\n\t\n2010-06-04  Taco Hoekwater <taco@luatex.org>\n\n\t* luatex.c (shell_cmd_is_allowed): make sure only commands with\n\tabsolute path names are executed on win32 in restricted mode --\n\tpatch from Akira Katuto.\n\n2010-05-28  Taco Hoekwater <taco@luatex.org>\n\n\t* luamd5/md.5c: bring in a new version from kepler to fix a\n\tportability problem with stdint.h.\n\t* luafontloader/src/ffdummies.c, lua/texluac.w: guard __attribute__\n\tusage, which is a GNUC only feature.\n\t    \n2010-05-19  Taco Hoekwater <taco@luatex.org>\n\n\t* printing.w (print_banner, log_banner), luainit.w (lua_initialize):\n\tadd WEB2CVERSION to the banner.\n\n2010-05-13  Taco Hoekwater <taco@luatex.org>\n\n\t* utils/synctex.c, utils/synctex-luatex.h: update from J\u00e9rome\n\tLaurens, bringing luatex in-line with the core synctex distribution\n\t* luatex_svnversion.h: updated to reflect the version of 0.60.x branch\n\t\n2010-05-06  Taco Hoekwater <taco@luatex.org>\n\n\t* luatex.c (calledit): use ifdef __MINGW32__ instead of WIN32.\n\t* luatex_svnversion.h: updated to reflect the version of 0.60.x branch\n\n2010-04-28  Taco Hoekwater <taco@luatex.org>\n\n\t* tex/maincontrol.w: Fixed the error message for improper \n\tuse of \\protected, reported by Heiko Oberdiek \n\t<heiko.oberdiek@googlemail.com>.\n\n2010-04-28  Taco Hoekwater  <taco@luatex>\n\n\t* import of luatex 0.60.1, released version\n\n2010-04-25  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/epdf.h, lua51/luaconf.h: #include <c-auto.h> instead of\n\t<web2c/c-auto.h>.\n\n2010-04-24  Taco Hoekwater  <taco@luatex>\n\n\t* lua/loslibext.c: fix os.exec() and os.spawn(), twice\n\n2010-04-23  Taco Hoekwater  <taco@luatex>\n\n\t* lua/loslibext.c: fix os.exec() and os.spawn() once more\n\n2010-04-23  Taco Hoekwater  <taco@luatex>\n\n\t* lua/loslibext.c: fix os.exec() and os.spawn()\n\t* luatex_svnversion.h: updated to reflect the version of 0.60.x branch\n\n2010-04-23  Taco Hoekwater  <taco@luatex>\n\n\t* new import from luatex repository (HEAD of 0.60.x branch)\n\n2010-04-20  Taco Hoekwater  <taco@luatex>\n\n\t* new import from luatex repository (HEAD of 0.60.x branch)\n\n2010-04-13  Taco Hoekwater  <taco@luatex>\n\n\t* am/luafontforge.am: delete three lines.\n\t* luafontloader/fontforge/Unicode/dump.c: deleted\n\t* luafontloader/fontforge/Unicode/backtrns.c: deleted\n\t* luafontloader/fontforge/Unicode/unialt.c: deleted\n\n2010-04-13  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/pdftoepdf.cc: Fix building with libpoppler.\n\t* luatex.c: Fix building for MinGW32.\n\n\t* luatex.c (ipcpage): Avoid compiler warning.\n\t(catch_interrupt): Declare as static.\n\t* pdf/pdflistout.w (init_*_backend_functions): ANSI C func defs.\n\n2010-04-13  Taco Hoekwater  <taco@luatex>\n\n\t* new import from luatex repository (HEAD of 0.60.x branch)\n\n2010-04-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luatex.am: Remove libmplib.a from $($(luatex_OBJECTS)'s\n\tdependencies ...\n\t* am/libluatex.am: and add to $(libluatex_a_OBJECTS)'s\n\tdependencies; otherwise parallel builds may fail.\n\n2010-04-04  Taco Hoekwater  <taco@luatex>\n\n\t* import of luatex 0.60.0, with a few local changes:\n\t* luatex.c (ipcpage): fix fetching of 'name'.\n\t* dvi/dvigen.w (dvi_end_page): fix IPC flushing.\n\t* image/pdftoepdf.cc (write_epdf1): comment out use of \n\tpage->getResourcesNF() and page->getMetadataNF().\n\n2010-03-09  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatangle.ch: Use kpse_set_program_name(argv[0], nil) instead\n\tof kpse_set_progname(argv[0]).\n\n2010-02-15  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luamisc.am (libluamisc_a_CPPFLAGS): Adapt to zziplib now\n\tin ../../../libs/zziplib/.\n\n2010-01-31  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tMoved zziplib/ to ../../../libs/zziplib.\n\t* am/luamisc.am (libluamisc_a_DEPENDENCIES): Adapt.\n\t* am/luatex.am (luatex_ldadd): Adapt.\n\n2010-01-29  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tClarify dependencies between luaTeX libraries:\n\t* am/libzzip.am: Remove dependency on liblua51.a.\n\tRemove memdisk.[ch] and mmapped.[ch] from libzzip_a_SOURCES and\n\tadd them to EXTRA_DIST.\n\t* am/luamisc.am: Add dependency on libzzip.a.\n\t* am/luasocket.am: Replace dependency on libzzip.a by liblua51.a.\n\n2010-01-27  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils/avl.c (avl_copy): Proper handling of const.\n\n2010-01-27  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luafontloader/src/luafflib.h: New file with prototypes used\n\tby libluatex.\n\t* luafontloader/src/luafflib.c: #include \"luafflib.h\".\n\t* font/writecff.c, font/writetype2.c: Remove the extern decls\n\tand #include <luafontloader/src/luafflib.h>.\n\t* font/writecff.c (writetype1w): Change tfm_size integer=>int.\n\t* am/luafontforge.am: Add the new file.\n\n\t* luatex-api.h: Add prototype for utf8_idpb(), renamed\n\tlua_utf8_idpb to avoid name conflicts with fontforge library.\n\t* lang/texlang.c: Declare utf8_idpb() as non-static.\n\t* tex/filename.c: Remove prototype for utf8_idpb().\n\n\t* tex/filename.c (scan_file_name): Don't assume a null byte\n\tafter string created by utf8_idpb().\n\n2010-01-26  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* font/writettf.c: Remove extern charsetstr[].\n\t* lua/lkpselib.c: Remove extern luainit.\n\t* lua/luainit.c: Remove extern normalize_quotes(), argc, argv.\n\t* tex/textoken.c: Remove extern insert_vj_template().\n\n\t* utils/utils.h: Add extern declaration of fb_array ...\n\t* font/writet1.c, font/writettf.c: ... removed from here.\n\t* luatex-api.h: Add extern declaration of program_name_set ...\n\t* lua/luainit.c, lua/luatex.c: ... removed from here.\n\t* luatex-api.h: Add extern declaration of startup_filename,\n\tsafer_option, and nosocket_option ...\n\t* lua/luastuff.c: ... removed from here.\n\t* lua/llualib.c (luabytecode_max): Change integer=>int.\n\t* luatex-api.h: Add extern declaration of luabytecode_max,\n\tluabytecode_bytes, luastate_bytes, callback_count, and\n\tsaved_callback_count ...\n\t* lstatslib.c: ... removed from here.\n\n2010-01-25  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luatex.am (luatex_CFLAGS, luatex_CXXFLAGS),\n\tam/libluatex.am (libluatex_a_CFLAGS): Enable compiler warnings.\n\n\tAvoid most compiler warnings:\n\n\t* font/luatexfont.h, luatexdir/hyphen.h, image/writeimg.h,\n\timage/writejbig2.h, luatex.h, pdf/pagetree.h, pdf/pdfpage.h,\n\tutils/avlstuff.h, utils/utils.h: ANSI C function prototypes.\n\t* font/mapfile.c, font/writeenc.c, font/writefont.c,\n\tfont/writet1.c, font/writettf.c, image/writeimg.c,\n\timage/writejbig2.c, lang/hyphen.c, pdf/pagetree.c,\n\tpdf/pdfpage.c, utils/avlstuff.c, utils/utils.c: ANSI C function\n\tdefinitions.\n\n\t* font/luafont.c, lang/texlang.c, lua/lcallbacklib.c,\n\tlua/lfontlib.c, lua/limglib.c, lua/lkpselib.c, lua/llualib.c,\n\tlua/lnodelib.c, lua/loslibext.c, lua/lpdflib.c, lua/lstatslib.c,\n\tlua/ltexiolib.c, lua/ltexlib.c, lua/ltokenlib.c, lua/luanode.c,\n\tlua/luatoken.c: Remove 'char *' or 'unsigned char *'  casts of\n\tLua strings.\n\n\t* font/texfont.h, font/writecff.h, luatex-api.h, luatex.h,\n\tnodes.h, primitive.h, ptexlib.h, utils/utils.h, font/dofont.c,\n\tfont/luafont.c, font/tfmofm.c, font/vfovf.c, font/writecff.c,\n\tfont/writefont.c, font/writet1.c, font/writettf.[ch],\n\tlang/hyphen.c, lang/texlang.c, lua/lcallbacklib.c,\n\tlua/lfontlib.c, lua/limglib.c, lua/lkpselib.c, lua/llualib.c,\n\tlua/lnodelib.c, lua/loslibext.c, lua/lpdflib.c, lua/lstatslib.c,\n\tlua/ltexiolib.c, lua/ltexlib.c, lua/ltokenlib.c, lua/luainit.c,\n\tlua/luanode.c, lua/luastuff.c, lua/luatex.c, lua/luatoken.c,\n\tluatex.ch, tex/filename.c, tex/linebreak.c, tex/math.c,\n\ttex/mlist.c, tex/primitive.c, tex/texdeffont.c, tex/texnodes.c,\n\ttex/textoken.c, utils/utils.c: Declare various function params\n\tand args, local and global vars, and struct members as const.\n\n\t* font/luafont.c, font/texfont.c, font/tfmofm.c, font/vfovf.c,\n\tfont/writeenc.c, font/writefont.c, font/writet1.c,\n\tfont/vfpacket.c, font/writettf.c, font/writetype2.c,\n\timage/writeimg.c, lang/hyphen.c, lang/texlang.c, lua/limglib.c,\n\tlua/llualib.c, lua/lnodelib.c, lua/loslibext.c, lua/lpdflib.c,\n\tlua/lstatslib.c, lua/ltexlib.c, lua/luainit.c, lua/luanode.c,\n\tlua/luastuff.c, mathcodes.c, tex/linebreak.c, tex/math.c,\n\ttex/mlist.c, tex/primitive.c, tex/texdeffont.c, tex/texnodes.c,\n\ttex/textoken.c, utils/synctex.c, utils/utils.c:\n\tDeclare functions and global vars as static.\n\n\t* font/texfont.c: #include \"luatexfont.h\" and remove externs.\n\t* image/writejpg.c: #include \"writejpg.h\".\n\t* image/writepng.c: #include \"writepng.h\".\n\t* lang/hnjalloc.c: #include \"hnjalloc.h\".\n\t* lua/texluac.c: #include \"luatex-api.h\".\n\t* utils/synctex.c: #include \"synctex.h\".\n\t* utils/utils.c: #include \"utils.h\".\n\n\t* lua/lcallbacklib.c: Remove prototype for lua_traceback().\n\t* ptexlib.h: Add prototype for get_command_id() ...\n\t* lua/ltokenlib.c: ... removed from here.\n\t* nodes.h: Add prototype for list_node_mem_usage() ...\n\t* lua/lnodelib.c: ... removed from here.\n\t* managed-sa.h: Add prototype for rawset_sa_item() ...\n\t* mathcodes.c, tex/math.c: ... removed from here.\n\n\t* inc-epdf.h: New file with prototypes for epdf_mark_glyphs(),\n\tepdf_create_fontdescriptor(), and epdf_write_enc() ...\n\t* image/epdf.h: ... removed from here.\n\t* image/epdf.h, font/writeenc.c: #include inc-epdf.h.\n\t* inc-vfovf.h: New file with prototype for make_vf_table() ...\n\t* lua/lfontlib.c: ... removed from here.\n\t* font/vfovf.c, lua/lfontlib.c: #include inc-vfovf.h.\n\t* inc-extra.h: New file with prototypes for check_isnode()\n\tand lua_nodelib_push_fast() ...\n\t* lua/limglib.c, lua/llanglib.c, lua/lstatslib.c, lua/ltexlib.c:\n\t... removed from here.\n\t* lua/limglib.c, lua/llanglib.c, lua/lnodelib.c,\n\tlua/lstatslib.c, lua/ltexlib.c: #include \"inc-extra.h\".\n\t* am/libluatex.am (libluatex_a_SOURCES): Add the new files.\n\n\t* font/texfont.c (lua_char_exists_callback),\n\tfont/vfovf.c (is_letterspaced_font),\n\tfont/vfpacket.c (packet_command_names),\n\tfont/writet1.c (free_glyph_names),\n\timage/writeimg.c (image_group_ref),\n\tlua/ltexlib.c (get_something_internal),\n\ttex/texnodes.c (print_free_chain),\n\ttextcodes.c (clearcatcodestack):\n\tSkip unused static funcs and vars (via #if 0 ... #endif).\n\n\t* lua/luainit.c (lua_initialize): Replace string constant\n\targuments of putenv() by non-const static string variables.\n\n\t* utils/avl.c (avl_delete): Don't reuse const input param for\n\tnon-const return value.\n\n\t* utils/synctex.c: Rename synctexchar => synctex_char and\n\tsynctexnode => synctex_node as declared in utils/synctex.h.\n\n2010-01-22  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatangle.ch: Declare web_name, chg_name, pascal_name, and\n\tpool_name as const_c_string.\n\n\t* lua/lkpselib.c (readable_file, lua_kpathsea_readable_file):\n\tDrop non-const cast of {kpse,kpathsea}_readable_file() result.\n\n2010-01-03  Karl Berry  <karl@tug.org>\n\n\t* luatex.ch: propagate \"executed safely\" wording change.\n\n2009-12-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luatex.am: Replace the obsolete $(mkdir_p) by $(MKDIR_P).\n\n2009-12-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/loslibext.c (do_mkdtemp): Declare as static and skip\n\tcompilation when not used.\n\n2009-12-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdf/pagetree.c, utils/utils.c: Drop #ifdef HAVE_ASPRINTF and\n\t#include <stdio.h>.\n\n2009-12-04  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils/synctex.c: Remove (already commented) extern declaration\n\tof gettexstring().\n\n2009-10-24  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatex.web: Use kpse_{in,out}_name_ok(), now in Kpathsea,\n\tinstead of open{in,out}nameok().\n\t* luatex.defines: Replace open_{in,out}_name_ok by\n\tkpse_{in,out}_name_ok.\n\n2009-10-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* image/pdftoepdf.cc: Adapt to poppler-0.12.\n\n\t* FIXME: image/epdf.h, utils/utils.h: Multiple prototypes for\n\tpdftex_fail, pdftex_warn, and probably others.\n\n2009-09-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luatex.am: Adapt to new makecpool with one argument.\n\n2009-09-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/luainit.c (dump_name, c_job_name, last_source_name,\n\tlast_lineno): Drop extern declarations (now in texmfmp.h).\n\t(user_progname): Constify string.\n\t(lua_initialize): Avoid modifying the const_string 'dump_name'.\n\n2009-09-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils/synctex.c (synctex_suffix*): Constify strings.\n\n2009-09-04  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatangle.ch: Eliminate the unused |end_of_TANGLE| label.\n\n2009-09-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libzzip.am: Enable compiler warnings.\n\t* am/liblua51.am, am/libluatex.am, am/luafontforge.am,\n\tam/luamisc.am, am/luasocket.am, am/luatex.am: Prepare compiler\n\twarnings.\n\n2009-08-20  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/lstatslib.c, lua/luainit.c: Drop extern decl of ptexbanner.\n\t* utils/utils.c: #include <kpathsea/version.h> and drop extern\n\tdecls.\n\n2009-08-17  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/liolib.c (io_popen): Changed Arg1 of shell_cmd_is_allowed().\n\t* lua/loslibext.c (os_exec, os_spawn, os_execute): Same.\n\n2009-08-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/luatangle.am: Adapt to web2c-sh.\n\t* am/luatex.am (luatex_tangle): Use tangle-sh.\n\tAdapt to tangle-sh and web2c-sh.\n\n2009-06-26  Taco Hoekwater <taco@luatex.org>\n\n\t* lua51/lcoco.c, lua51/lcoco.h: disable the coco patch on\n\tlinux+ppc because it crashes the executable.\n\n2009-06-25  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* font/writet1.c, image/epdf.[ch], utils/avlstuff.c:\n\tremove #include <kpathsea/c-proto.h>.\n \t\n2009-06-25  Taco Hoekwater <taco@luatex.org>\n \t\n\t* luatexdir: import of luatex release 0.40.6.\n\n2009-06-23  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* lua/luatex.c: drop P?C, P?H, use ANSI C function declarations.\n\n2009-06-23  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* font/writet1.c, image/epdf.c, utils/avlstuff.c:\n\t#include <stdarg.h>, not <kpathsea/c-vararg.h>.\n\n2009-06-09  Taco Hoekwater <taco@luatex.org>\n \t\n\t* luatexdir: import of luatex release 0.40.4.\n\n2009-06-08  Taco Hoekwater <taco@luatex.org>\n \t\n\t* luatexdir: import of luatex release 0.40.3.\n\tThis affects many files in subdirectories.\n\n2009-06-04  Taco Hoekwater <taco@luatex.org>\n\t\n\t* luatexdir: \"avoid variable declaration after statement\" patch\n\tfrom Vladimir Volovich\n\n2009-06-03  Taco Hoekwater <taco@luatex.org>\n \t\n\t* luatexdir/luafontloader/fontforge/fontforge/namelist.c (psaltnames): add\n\ta dimension specifier, for AIX portability.\n\n2009-06-03  Taco Hoekwater <taco@luatex.org>\n \t\n\t* luatexdir: import of luatex release 0.40.2.\n\tThis affects many files in subdirectories.\n\n2009-05-30  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* am/luatex.am (install-exec-hook, uninstall-hook):\n\tavoid dangling symlinks.\n\n2009-05-25  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* am/luatex.am (uninstall-hook): new target to uninstall texlua[c]\n\tsymlinks.\n\n2009-05-25  Karl Berry  <karl@tug.org>\n\n\t* am/luatex.am (install-exec-hook): new target to install texlua[c]\n\tsymlinks.\n\n2009-05-08  Taco Hoekwater <taco@luatex.org>\n \t\n\t* luatexdir: import of the current state of luatex, 0.40.1.\n\tThis affects many files in subdirectories.\n\n2009-05-05  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* image/pdftoepdf.cc, utils/utils.c: adapt for poppler.\n\n\tpatches from Norbert Preinig <preining@logic.at>\n\n2009-04-27  Taco Hoekwater <taco@luatex.org>\n\n\t* pdf/pdfpage.c: rename exp10 to exp10_arr to solve a \n\tconflict with cygwin's <math.h>.\n\t* font/texfont.h: add #undef quad before definition to suppress a\n\tcompiler warning under cygwin. \n\n2009-04-22  Taco Hoekwater <taco@luatex.org>\n\n\t* luatexdir: import of the current state of luatex, 0.40.0. \n\tThis affects many files in subdirectories.\n\n2009-04-16  Taco Hoekwater <taco@luatex.org>\n\n\t* image/image.h: remove the trick that forced a local png.h\n\n2009-04-16  Taco Hoekwater <taco@luatex.org>\n\n\t* luatexdir: import of the current state of luatex, 0.39.0. \n\tThis affects many files in subdirectories.\n\n2009-03-27  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* am/luatex.am (luatex_c_h): avoid to split the C code\n\t(from Taco).\n\n2009-03-27  Taco Hoekwater <taco@luatex.org>\n\n\t* luatexdir: import of the current state of luatex, 0.37.0. \n\tThis affects many files in subdirectories.\n\n2009-03-05  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* image/pdftoepdf.cc: Uninclude <config.h>, included later\n\tby \"epdf.h\".\n\n2009-03-03  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* luatangle.ch: use kpse_open_file to locate input files,\n\tin order to respect WEBINPUTS (ported from tangle.ch).\n", "/*\n\nCopyright 1996-2006 Han The Thanh <thanh@pdftex.org>\nCopyright 2006-2009 Taco Hoekwater <taco@luatex.org>\n\nThis file is part of LuaTeX.\n\nLuaTeX is free software; you can redistribute it and/or modify it under\nthe terms of the GNU General Public License as published by the Free\nSoftware Foundation; either version 2 of the License, or (at your\noption) any later version.\n\nLuaTeX is distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public\nLicense for more details.\n\nYou should have received a copy of the GNU General Public License along\nwith LuaTeX; if not, see <http://www.gnu.org/licenses/>.\n\n*/\n\n#include \"ptexlib.h\"\n#include <string.h>\n\n#define get_length1()              t1_length1 = t1_offset() - t1_save_offset\n#define get_length2()              t1_length2 = t1_offset() - t1_save_offset\n#define get_length3()              t1_length3 = fixedcontent? t1_offset() - t1_save_offset : 0\n#define save_offset()              t1_save_offset = t1_offset()\n#define t1_putchar(A)              strbuf_putchar(pdf->fb, (A))\n#define t1_offset()                strbuf_offset(pdf->fb)\n#define out_eexec_char             t1_putchar\n#define end_last_eexec_line()      t1_eexec_encrypt = false\n#define t1_char(c)                 c\n#define embed_all_glyphs(tex_font) fm_cur->all_glyphs\n#define extra_charset()            fm_cur->charset\n#define fixedcontent               false\n\nint t1_length1, t1_length2, t1_length3;\nstatic int t1_save_offset;\nstatic int t1_fontname_offset;\n\nstatic unsigned char *t1_buffer = NULL;\nstatic int t1_size = 0;\nstatic int t1_curbyte = 0;\n\n#define t1_read_file()   readbinfile(t1_file,&t1_buffer,&t1_size)\n#define t1_close()       xfclose(t1_file,cur_file_name)\n#define t1_getchar()     t1_buffer[t1_curbyte++]\n#define t1_ungetchar(c)  t1_curbyte--\n#define t1_eof()         (t1_curbyte>t1_size)\n\n#define t1_prefix(s)     str_prefix(t1_line_array, s)\n#define t1_buf_prefix(s) str_prefix(t1_buf_array, s)\n#define t1_suffix(s)     str_suffix(t1_line_array, t1_line_ptr, s)\n#define t1_buf_suffix(s) str_suffix(t1_buf_array, t1_buf_ptr, s)\n#define t1_charstrings() strstr(t1_line_array, charstringname)\n#define t1_subrs()       t1_prefix(\"/Subrs\")\n#define t1_end_eexec()   t1_suffix(\"mark currentfile closefile\")\n#define t1_cleartomark() t1_prefix(\"cleartomark\")\n\nstatic unsigned char *enc_buffer = NULL;\nstatic int enc_size = 0;\nstatic int enc_curbyte = 0;\n\n#define enc_open(a)     (enc_file = fopen((char *)(a), FOPEN_RBIN_MODE))\n#define enc_read_file() readbinfile(enc_file,&enc_buffer,&enc_size)\n#define enc_close()     xfclose(enc_file,cur_file_name)\n#define enc_getchar()   enc_buffer[enc_curbyte++]\n#define enc_eof()       (enc_curbyte>enc_size)\n\n#define valid_code(c)  (c >= 0 && c < 256)\n#define fixedcontent    false\n\nstatic const char *standard_glyph_names[256] = {\n    /* 0x00 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0x10 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0x20 */\n    \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\",\n    \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\", \"asterisk\",\n    \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\",\n    /* 0x30 */\n    \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\",\n    \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\",\n    /* 0x40 */\n    \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\",\n    \"O\",\n    /* 0x50 */\n    \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\",\n    \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\",\n    /* 0x60 */\n    \"quoteleft\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\",\n    \"m\", \"n\", \"o\",\n    /* 0x70 */\n    \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\",\n    \"braceright\", \"asciitilde\", notdef,\n    /* 0x80 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0x90 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0xa0 */\n    notdef, \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\", \"florin\",\n    \"section\", \"currency\", \"quotesingle\", \"quotedblleft\", \"guillemotleft\",\n    \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\",\n    /* 0xb0 */\n    notdef, \"endash\", \"dagger\", \"daggerdbl\", \"periodcentered\", notdef,\n    \"paragraph\", \"bullet\", \"quotesinglbase\", \"quotedblbase\",\n    \"quotedblright\", \"guillemotright\", \"ellipsis\", \"perthousand\", notdef,\n    \"questiondown\",\n    /* 0xc0 */\n    notdef, \"grave\", \"acute\", \"circumflex\", \"tilde\", \"macron\", \"breve\",\n    \"dotaccent\", \"dieresis\", notdef,\n    \"ring\", \"cedilla\", notdef, \"hungarumlaut\", \"ogonek\", \"caron\",\n    /* 0xd0 */\n    \"emdash\", notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0xe0 */\n    notdef, \"AE\", notdef, \"ordfeminine\", notdef, notdef, notdef, notdef,\n    \"Lslash\", \"Oslash\", \"OE\", \"ordmasculine\", notdef, notdef, notdef,\n    notdef,\n    /* 0xf0 */\n    notdef, \"ae\", notdef, notdef, notdef, \"dotlessi\", notdef, notdef, \"lslash\",\n    \"oslash\", \"oe\", \"germandbls\", notdef, notdef, notdef, notdef\n};\n\nstatic fd_entry *fd_cur;\n\nstatic char charstringname[] = \"/CharStrings\";\n\nenum { ENC_STANDARD, ENC_BUILTIN } t1_encoding;\n\n#define T1_BUF_SIZE   0x0010\n#define ENC_BUF_SIZE  0x1000\n\n#define CS_HSTEM             1\n#define CS_VSTEM             3\n#define CS_VMOVETO           4\n#define CS_RLINETO           5\n#define CS_HLINETO           6\n#define CS_VLINETO           7\n#define CS_RRCURVETO         8\n#define CS_CLOSEPATH         9\n#define CS_CALLSUBR         10\n#define CS_RETURN           11\n#define CS_ESCAPE           12\n#define CS_HSBW             13\n#define CS_ENDCHAR          14\n#define CS_RMOVETO          21\n#define CS_HMOVETO          22\n#define CS_VHCURVETO        30\n#define CS_HVCURVETO        31\n#define CS_1BYTE_MAX        (CS_HVCURVETO + 1)\n\n#define CS_DOTSECTION       CS_1BYTE_MAX +  0\n#define CS_VSTEM3           CS_1BYTE_MAX +  1\n#define CS_HSTEM3           CS_1BYTE_MAX +  2\n#define CS_SEAC             CS_1BYTE_MAX +  6\n#define CS_SBW              CS_1BYTE_MAX +  7\n#define CS_DIV              CS_1BYTE_MAX + 12\n#define CS_CALLOTHERSUBR    CS_1BYTE_MAX + 16\n#define CS_POP              CS_1BYTE_MAX + 17\n#define CS_SETCURRENTPOINT  CS_1BYTE_MAX + 33\n#define CS_2BYTE_MAX        (CS_SETCURRENTPOINT + 1)\n#define CS_MAX              CS_2BYTE_MAX\n\ntypedef unsigned char byte;\n\n/*tex A |CharString| command: */\n\ntypedef struct {\n    /*tex number of arguments */\n    byte nargs;\n    /*tex take arguments from bottom of stack? */\n    boolean bottom;\n    /*tex clear stack? */\n    boolean clear;\n    boolean valid;\n} cc_entry;\n\ntypedef struct {\n    /*tex glyph name (or |notdef| for |Subrs| entry) */\n    char *name;\n    byte *data;\n    /*tex length of the whole string */\n    unsigned short len;\n    /*tex length of the encoded part of the string */\n    unsigned short cslen;\n    boolean used;\n    boolean valid;\n} cs_entry;\n\nstatic unsigned short t1_dr, t1_er;\nstatic const unsigned short t1_c1 = 52845, t1_c2 = 22719;\nstatic unsigned short t1_cslen;\nstatic short t1_lenIV;\nstatic char enc_line[ENC_BUF_SIZE];\n\n#define t1_line_entry char\ndefine_array(t1_line);\n\n#define t1_buf_entry char\ndefine_array(t1_buf);\n\nstatic int cs_start;\n\nstatic cs_entry *cs_tab, *cs_ptr, *cs_notdef;\nstatic char *cs_dict_start, *cs_dict_end;\nstatic int cs_counter, cs_size, cs_size_pos;\n\nstatic cs_entry *subr_tab;\nstatic char *subr_array_start, *subr_array_end;\nstatic int subr_max, subr_size, subr_size_pos;\n\n/*tex\n\n    This list contains the begin/end tokens commonly used in the |/Subrs| array of\n    a Type 1 font.\n\n*/\n\nstatic const char *cs_token_pairs_list[][2] = {\n    { \" RD\", \"NP\" },\n    { \" -|\", \"|\" },\n    { \" RD\", \"noaccess put\" },\n    { \" -|\", \"noaccess put\" },\n    { NULL,  NULL }\n};\n\nstatic const char **cs_token_pair;\n\nstatic boolean t1_pfa, t1_cs, t1_scan, t1_eexec_encrypt, t1_synthetic;\n\n/*tex This one becomes 0 before 1 during and 2 after |eexec| encryption. */\n\nstatic int t1_in_eexec;\n\nstatic long t1_block_length;\nstatic int last_hexbyte;\nstatic FILE *t1_file;\nstatic FILE *enc_file;\n\nstatic void enc_getline(void)\n{\n    char *p;\n    char c;\n  restart:\n    if (enc_eof())\n        normal_error(\"type 1\",\"unexpected end of file\");\n    p = enc_line;\n    do {\n        c = (char) enc_getchar();\n        append_char_to_buf(c, p, enc_line, ENC_BUF_SIZE);\n    }\n    while (c != 10 && !enc_eof());\n    append_eol(p, enc_line, ENC_BUF_SIZE);\n    if (p - enc_line < 2 || *enc_line == '%')\n        goto restart;\n}\n\n/*tex\n\n    Read encoding from .enc file, return |glyph_names array|, or |pdffail|.\n\n*/\n\nchar **load_enc_file(char *enc_name)\n{\n    int callback_id = 0;\n    int file_opened = 0;\n    char buf[ENC_BUF_SIZE], *p, *r;\n    int i, names_count;\n    char **glyph_names;\n    cur_file_name = luatex_find_file(enc_name, find_enc_file_callback);\n    if (cur_file_name == NULL) {\n        formatted_error(\"type 1\",\"cannot find encoding file '%s' for reading\", enc_name);\n    }\n    callback_id = callback_defined(read_enc_file_callback);\n    enc_curbyte = 0;\n    enc_size = 0;\n    if (callback_id > 0) {\n        if (run_callback(callback_id, \"S->bSd\", cur_file_name, &file_opened, &enc_buffer, &enc_size)) {\n            if ((!file_opened) || enc_size == 0) {\n                formatted_error(\"type 1\",\"cannot open encoding file '%s' for reading\", cur_file_name);\n            }\n        }\n    } else {\n        if (!enc_open(cur_file_name)) {\n            formatted_error(\"type 1\",\"cannot open encoding file '%s' for reading\", cur_file_name);\n        }\n        enc_read_file();\n        enc_close();\n    }\n    glyph_names = xtalloc(256, char *);\n    for (i = 0; i < 256; i++)\n        glyph_names[i] = (char *) notdef;\n    report_start_file(filetype_map,cur_file_name);\n    enc_getline();\n    if (*enc_line != '/' || (r = strchr(enc_line, '[')) == NULL) {\n        remove_eol(r, enc_line);\n        formatted_error(\"type 1\",\"invalid encoding vector (a name or '[' missing): '%s'\", enc_line);\n    }\n    names_count = 0;\n    /*tex Skip |[|: */\n    r++;\n    skip_char(r, ' ');\n    for (;;) {\n        while (*r == '/') {\n            for (p = buf, r++;\n                 *r != ' ' && *r != 10 && *r != ']' && *r != '/'; *p++ = *r++);\n            *p = 0;\n            skip_char(r, ' ');\n            if (names_count >= 256)\n                normal_error(\"type 1\",\"encoding vector contains more than 256 names\");\n            if (strcmp(buf, notdef) != 0)\n                glyph_names[names_count] = xstrdup(buf);\n            names_count++;\n        }\n        if (*r != 10 && *r != '%') {\n            if (strncmp(r, \"] def\", strlen(\"] def\")) == 0)\n                goto done;\n            else {\n                remove_eol(r, enc_line);\n                formatted_error(\"type 1\",\"invalid encoding vector: a name or '] def' expected: `%s'\",enc_line);\n            }\n        }\n        enc_getline();\n        r = enc_line;\n    }\n  done:\n    report_stop_file(filetype_map);\n    cur_file_name = NULL;\n    xfree(enc_buffer);\n    return glyph_names;\n}\n\nstatic void t1_check_pfa(void)\n{\n    const int c = t1_getchar();\n    t1_pfa = (c != 128) ? true : false;\n    t1_ungetchar(c);\n}\n\nstatic int t1_getbyte(void)\n{\n    int c = t1_getchar();\n    if (t1_pfa)\n        return c;\n    if (t1_block_length == 0) {\n        if (c != 128)\n            normal_error(\"type 1\",\"invalid marker\");\n        c = t1_getchar();\n        if (c == 3) {\n            while (!t1_eof())\n                (void) t1_getchar();\n            return EOF;\n        }\n        t1_block_length = t1_getchar() & 0xff;\n        t1_block_length |= (t1_getchar() & 0xff) << 8;\n        t1_block_length |= (t1_getchar() & 0xff) << 16;\n        t1_block_length |= (t1_getchar() & 0xff) << 24;\n        c = t1_getchar();\n    }\n    t1_block_length--;\n    return c;\n}\n\nstatic int hexval(int c)\n{\n    if (c >= 'A' && c <= 'F')\n        return c - 'A' + 10;\n    else if (c >= 'a' && c <= 'f')\n        return c - 'a' + 10;\n    else if (c >= '0' && c <= '9')\n        return c - '0';\n    else\n        return -1;\n}\n\nstatic byte edecrypt(byte cipher)\n{\n    byte plain;\n    if (t1_pfa) {\n        while (cipher == 10 || cipher == 13)\n            cipher = (byte) t1_getbyte();\n        last_hexbyte = cipher = (byte) ((hexval(cipher) << 4) + hexval(t1_getbyte()));\n    }\n    plain = (byte) (cipher ^ (t1_dr >> 8));\n    t1_dr = (unsigned short) ((cipher + t1_dr) * t1_c1 + t1_c2);\n    return plain;\n}\n\nstatic byte cdecrypt(byte cipher, unsigned short *cr)\n{\n    const byte plain = (byte) (cipher ^ (*cr >> 8));\n    *cr = (unsigned short) ((cipher + *cr) * t1_c1 + t1_c2);\n    return plain;\n}\n\nstatic byte eencrypt(byte plain)\n{\n    const byte cipher = (byte) (plain ^ (t1_er >> 8));\n    t1_er = (unsigned short) ((cipher + t1_er) * t1_c1 + t1_c2);\n    return cipher;\n}\n\nstatic byte cencrypt(byte plain, unsigned short *cr)\n{\n    const byte cipher = (byte) (plain ^ (*cr >> 8));\n    *cr = (unsigned short) ((cipher + *cr) * t1_c1 + t1_c2);\n    return cipher;\n}\n\nstatic char *eol(char *s)\n{\n    char *p = strend(s);\n    if (p - s > 1 && p[-1] != 10) {\n        *p++ = 10;\n        *p = 0;\n    }\n    return p;\n}\n\nstatic float t1_scan_num(char *p, char **r)\n{\n    float f;\n    skip_char(p, ' ');\n    if (sscanf(p, \"%g\", &f) != 1) {\n        remove_eol(p, t1_line_array);\n        formatted_error(\"type 1\",\"a number expected: '%s'\", t1_line_array);\n    }\n    if (r != NULL) {\n        for (; isdigit((unsigned char)*p) || *p == '.' ||\n             *p == 'e' || *p == 'E' || *p == '+' || *p == '-'; p++);\n        *r = p;\n    }\n    return f;\n}\n\nstatic boolean str_suffix(const char *begin_buf, const char *end_buf, const char *s)\n{\n    const char *s1 = end_buf - 1, *s2 = strend(s) - 1;\n    if (*s1 == 10)\n        s1--;\n    while (s1 >= begin_buf && s2 >= s) {\n        if (*s1-- != *s2--)\n            return false;\n    }\n    return s2 < s;\n}\n\nstatic void t1_getline(void)\n{\n    int c, l, eexec_scan;\n    char *p;\n    static const char eexec_str[] = \"currentfile eexec\";\n    static int eexec_len = 17;\n  restart:\n    if (t1_eof())\n        normal_error(\"type 1\",\"unexpected end of file\");\n    t1_line_ptr = t1_line_array;\n    alloc_array(t1_line, 1, T1_BUF_SIZE);\n    t1_cslen = 0;\n    eexec_scan = 0;\n    c = t1_getbyte();\n    if (c == EOF)\n        goto exit;\n    while (!t1_eof()) {\n        if (t1_in_eexec == 1)\n            c = edecrypt((byte) c);\n        alloc_array(t1_line, 1, T1_BUF_SIZE);\n        {\n            char cc = (char) c;\n            append_char_to_buf(cc, t1_line_ptr, t1_line_array, t1_line_limit);\n        }\n        if (t1_in_eexec == 0 && eexec_scan >= 0 && eexec_scan < eexec_len) {\n            if (t1_line_array[eexec_scan] == eexec_str[eexec_scan])\n                eexec_scan++;\n            else\n                eexec_scan = -1;\n        }\n        if (c == 10 || c == 13\n            || (t1_pfa && eexec_scan == eexec_len && c == 32)) {\n            break;\n        }\n        if (t1_cs && t1_cslen == 0 && (t1_line_ptr - t1_line_array > 4) &&\n            (t1_suffix(\" RD \") || t1_suffix(\" -| \"))) {\n            p = t1_line_ptr - 5;\n            while (*p != ' ')\n                p--;\n            l = (int) t1_scan_num(p + 1, 0);\n            t1_cslen = (unsigned short) l;\n            /*tex |cs_start| is an index now */\n            cs_start = (int) (t1_line_ptr - t1_line_array);\n            alloc_array(t1_line, l, T1_BUF_SIZE);\n            while (l-- > 0)\n                *t1_line_ptr++ = (t1_line_entry) edecrypt((byte) t1_getbyte());\n        }\n        c = t1_getbyte();\n    }\n    /*tex |append_eol| can append 2 chars */\n    alloc_array(t1_line, 2, T1_BUF_SIZE);\n    append_eol(t1_line_ptr, t1_line_array, t1_line_limit);\n    if (t1_line_ptr - t1_line_array < 2)\n        goto restart;\n    if (eexec_scan == eexec_len)\n        t1_in_eexec = 1;\n  exit:\n    /*tex Ensure that |t1_buf_array| has as much room as |t1_line_array|. */\n    t1_buf_ptr = t1_buf_array;\n    alloc_array(t1_buf, t1_line_limit, t1_line_limit);\n}\n\nstatic void t1_putline(PDF pdf)\n{\n    char *p = t1_line_array;\n    if (t1_line_ptr - t1_line_array <= 1)\n        return;\n    if (t1_eexec_encrypt) {\n        while (p < t1_line_ptr)\n            t1_putchar((eight_bits) eencrypt((byte) * p++));\n    } else\n        while (p < t1_line_ptr)\n            t1_putchar((eight_bits) * p++);\n}\n\nstatic void t1_puts(PDF pdf, const char *s)\n{\n    if (s != t1_line_array)\n        strcpy(t1_line_array, s);\n    t1_line_ptr = strend(t1_line_array);\n    t1_putline(pdf);\n}\n\n__attribute__ ((format(printf, 2, 3)))\nstatic void t1_printf(PDF pdf, const char *fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    vsprintf(t1_line_array, fmt, args);\n    t1_puts(pdf, t1_line_array);\n    va_end(args);\n}\n\nstatic void t1_init_params(int open_name_prefix)\n{\n    report_start_file(open_name_prefix,cur_file_name);\n    t1_lenIV = 4;\n    t1_dr = 55665;\n    t1_er = 55665;\n    t1_in_eexec = 0;\n    t1_cs = false;\n    t1_scan = true;\n    t1_synthetic = false;\n    t1_eexec_encrypt = false;\n    t1_block_length = 0;\n    t1_check_pfa();\n}\n\nstatic void t1_close_font_file(int close_name_suffix)\n{\n    report_stop_file(close_name_suffix);\n    cur_file_name = NULL;\n}\n\nstatic void t1_check_block_len(boolean decrypt)\n{\n    int l, c;\n    if (t1_block_length == 0)\n        return;\n    c = t1_getbyte();\n    if (decrypt)\n        c = edecrypt((byte) c);\n    l = (int) t1_block_length;\n    if (!(l == 0 && (c == 10 || c == 13))) {\n        formatted_error(\"type 1\",\"%i bytes more than expected were ignored\", l + 1);\n    }\n}\n\nstatic void t1_start_eexec(PDF pdf)\n{\n    int i;\n    get_length1();\n    save_offset();\n    if (!t1_pfa)\n        t1_check_block_len(false);\n    for (t1_line_ptr = t1_line_array, i = 0; i < 4; i++) {\n        edecrypt((byte) t1_getbyte());\n        *t1_line_ptr++ = 0;\n    }\n    t1_eexec_encrypt = true;\n    /*tex To put the first four bytes: */\n    t1_putline(pdf);\n}\n\nstatic void t1_stop_eexec(PDF pdf)\n{\n    int c;\n    get_length2();\n    save_offset();\n    t1_eexec_encrypt = false;\n    if (!t1_pfa)\n        t1_check_block_len(true);\n    else {\n        c = edecrypt((byte) t1_getbyte());\n        if (!(c == 10 || c == 13)) {\n            if (last_hexbyte == 0)\n                t1_puts(pdf, \"00\");\n            else\n                normal_error(\"type 1\",\"unexpected data after eexec\");\n        }\n    }\n    t1_cs = false;\n    t1_in_eexec = 2;\n}\n\n/*tex Macros for various transforms; unused, left for reference: */\n\n#ifdef T1TRANSFORMMACROS\n#  define do_xshift(x,a) {x[4]+=a;}\n#  define do_yshift(x,a) {x[5]+=a;}\n#  define do_xscale(x,a) {x[0]*=a; x[2]*=a; x[4]*=a;}\n#  define do_yscale(x,a) {x[1]*=a; x[3]*=a; x[5]*=a;}\n#  define do_extend(x,a) {do_xscale(x,a);}\n#  define do_scale(x,a)  {do_xscale(x,a); do_yscale(x,a);}\n#  define do_slant(x,a)  {x[0]+=x[1]*(a); x[2]+=x[3]*(a); x[4]+=x[5]*(a);}\n#  define do_shear(x,a)  {x[1]+=x[0]*(a); x[3]+=x[2]*(a); x[5]+=x[4]*(a);}\n\n#  define do_rotate(x,a) {        \\\n    float t, u=cos(a), v=sin(a);  \\\n    t    =x[0]*u+x[1]*-v;         \\\n    x[1] =x[0]*v+x[1]* u; x[0]=t; \\\n    t    =x[2]*u+x[3]*-v;         \\\n    x[3] =x[2]*v+x[3]* u; x[2]=t; \\\n    t    =x[4]*u+x[5]*-v;         \\\n    x[5] =x[4]*v+x[5]* u; x[4]=t; \\\n}\n#endif\n\nstatic void t1_scan_keys(PDF pdf)\n{\n    int i, k;\n    char *p, *q, *r;\n    const key_entry *key;\n    if (t1_prefix(\"/FontType\")) {\n        p = t1_line_array + strlen(\"FontType\") + 1;\n        if ((i = (int) t1_scan_num(p, 0)) != 1)\n            formatted_error(\"type 1\",\"Type%d fonts unsupported by backend\", i);\n        return;\n    }\n    for (key = (const key_entry *) font_key; key - font_key < FONT_KEYS_NUM;\n         key++) {\n        if (key->t1name[0] != '\\0'\n            && str_prefix(t1_line_array + 1, key->t1name))\n            break;\n    }\n    if (key - font_key == FONT_KEYS_NUM)\n        return;\n    p = t1_line_array + strlen(key->t1name) + 1;\n    skip_char(p, ' ');\n    if ((k = (int) (key - font_key)) == FONTNAME_CODE) {\n        if (*p != '/') {\n            remove_eol(p, t1_line_array);\n            formatted_error(\"type 1\",\"a name expected: '%s'\", t1_line_array);\n        }\n        /*tex Skip the slash. */\n        r = ++p;\n        for (q = t1_buf_array; *p != ' ' && *p != 10; *q++ = *p++);\n        *q = 0;\n        xfree(fd_cur->fontname);\n        fd_cur->fontname = xstrdup(t1_buf_array);\n        /*tex\n\n            At this moment we cannot call |make_subset_tag| yet, as the encoding\n            is not read; thus we mark the offset of the subset tag and write it\n            later.\n\n        */\n        if (is_subsetted(fd_cur->fm)) {\n            t1_fontname_offset = (int) (t1_offset() + (r - t1_line_array));\n            strcpy(t1_buf_array, p);\n            sprintf(r, \"ABCDEF+%s%s\", fd_cur->fontname, t1_buf_array);\n            t1_line_ptr = eol(r);\n        }\n        return;\n    }\n    if ((k == STEMV_CODE || k == FONTBBOX1_CODE) && (*p == '[' || *p == '{'))\n        p++;\n    if (k == FONTBBOX1_CODE) {\n        for (i = 0; i < 4; i++, k++) {\n            fd_cur->font_dim[k].val = (int) t1_scan_num(p, &r);\n            fd_cur->font_dim[k].set = true;\n            p = r;\n        }\n        return;\n    }\n    fd_cur->font_dim[k].val = (int) t1_scan_num(p, 0);\n    fd_cur->font_dim[k].set = true;\n}\n\nstatic void t1_scan_param(PDF pdf)\n{\n    static const char *lenIV = \"/lenIV\";\n    if (!t1_scan || *t1_line_array != '/')\n        return;\n    if (t1_prefix(lenIV)) {\n        t1_lenIV = (short) t1_scan_num(t1_line_array + strlen(lenIV), 0);\n        if (t1_lenIV < 0)\n            normal_error(\"type 1\",\"negative value of lenIV is not supported\");\n        return;\n    }\n    t1_scan_keys(pdf);\n}\n\nstatic void copy_glyph_names(char **glyph_names, int a, int b)\n{\n    if (glyph_names[b] != notdef) {\n        xfree(glyph_names[b]);\n        glyph_names[b] = (char *) notdef;\n    }\n    if (glyph_names[a] != notdef) {\n        glyph_names[b] = xstrdup(glyph_names[a]);\n    }\n}\n\n/*tex Read encoding from Type1 font file, return |glyph_names| array, or |pdffail|. */\n\nstatic char **t1_builtin_enc(void)\n{\n    int i, a, b, c, counter = 0;\n    char *r, *p, **glyph_names;\n    /*tex At this moment |/Encoding| is the prefix of |t1_line_array|. */\n    glyph_names = xtalloc(256, char *);\n    for (i = 0; i < 256; i++)\n        glyph_names[i] = (char *) notdef;\n    if (t1_suffix(\"def\")) {\n        /*tex A predefined encoding: */\n        sscanf(t1_line_array + strlen(\"/Encoding\"), \"%255s\", t1_buf_array);\n        if (strcmp(t1_buf_array, \"StandardEncoding\") == 0) {\n            t1_encoding = ENC_STANDARD;\n            for (i = 0; i < 256; i++) {\n                if (standard_glyph_names[i] != notdef)\n                    glyph_names[i] = xstrdup(standard_glyph_names[i]);\n            }\n            return glyph_names;\n        } else\n            formatted_error(\"type 1\",\"cannot subset font (unknown predefined encoding '%s')\",t1_buf_array);\n    }\n    /*\n\n        At this moment |/Encoding| is the prefix of |t1_line_array|, and the\n        encoding is not a predefined encoding. We have two possible forms of\n        vector. The first case is\n\n        \\starttyping\n        /Encoding [\n            /a /b /c ...\n        ] readonly def\n        \\stoptyping\n\n        and the second case can look like\n\n        \\starttyping\n        /Encoding 256 array 0 1 255 {\n            1 index exch /.notdef put} for\n            dup 0 /x put\n            dup 1 /y put\n            ...\n        } readonly def\n        \\stoptyping\n\n    */\n    t1_encoding = ENC_BUILTIN;\n    if (t1_prefix(\"/Encoding [\") || t1_prefix(\"/Encoding[\")) {  /* the first case */\n        r = strchr(t1_line_array, '[') + 1;\n        skip_char(r, ' ');\n        for (;;) {\n            while (*r == '/') {\n                for (p = t1_buf_array, r++; *r != 32 && *r != 10 && *r != ']' && *r != '/'; *p++ = *r++);\n                *p = 0;\n                skip_char(r, ' ');\n                if (counter > 255)\n                    normal_error(\"type 1\",\"encoding vector contains more than 256 names\");\n                if (strcmp(t1_buf_array, notdef) != 0)\n                    glyph_names[counter] = xstrdup(t1_buf_array);\n                counter++;\n            }\n            if (*r != 10 && *r != '%') {\n                if (str_prefix(r, \"] def\") || str_prefix(r, \"] readonly def\"))\n                    break;\n                else {\n                    remove_eol(r, t1_line_array);\n                    formatted_error(\"type 1\",\"a name or '] def' or '] readonly def' expected: '%s'\", t1_line_array);\n                }\n            }\n            t1_getline();\n            r = t1_line_array;\n        }\n    } else {\n        /*tex The second case. */\n        p = strchr(t1_line_array, 10);\n        for (;;) {\n            if (*p == 10) {\n                t1_getline();\n                p = t1_line_array;\n            }\n            /*tex Check for |dup <index> <glyph> put|. */\n            if (sscanf(p, \"dup %i%255s put\", &i, t1_buf_array) == 2 &&\n                *t1_buf_array == '/' && valid_code(i)) {\n                if (strcmp(t1_buf_array + 1, notdef) != 0)\n                    glyph_names[i] = xstrdup(t1_buf_array + 1);\n                p = strstr(p, \" put\") + strlen(\" put\");\n                skip_char(p, ' ');\n            }\n            /*tex Check for |dup dup <to> exch <from> get put|. */\n            else if (sscanf(p, \"dup dup %i exch %i get put\", &b, &a) == 2 && valid_code(a) && valid_code(b)) {\n                copy_glyph_names(glyph_names, a, b);\n                p = strstr(p, \" get put\") + strlen(\" get put\");\n                skip_char(p, ' ');\n            }\n            /*tex Check for |dup dup <from> <size> getinterval <to> exch putinterval|. */\n            else if (sscanf(p, \"dup dup %i %i getinterval %i exch putinterval\",\n                    &a, &c, &b) == 3 && valid_code(a) && valid_code(b) && valid_code(c)) {\n                for (i = 0; i < c; i++)\n                    copy_glyph_names(glyph_names, a + i, b + i);\n                p = strstr(p, \" putinterval\") + strlen(\" putinterval\");\n                skip_char(p, ' ');\n            }\n            /*tex Check for |def or |readonly def|. */\n            else if ((p == t1_line_array || (p > t1_line_array && p[-1] == ' ')) && strcmp(p, \"def\\n\") == 0) {\n                return glyph_names;\n            } else {\n                /*tex Skip an unrecognizable word. */\n                while (*p != ' ' && *p != 10)\n                    p++;\n                skip_char(p, ' ');\n            }\n        }\n    }\n    return glyph_names;\n}\n\nstatic void t1_check_end(PDF pdf)\n{\n    if (t1_eof())\n        return;\n    t1_getline();\n    if (t1_prefix(\"{restore}\"))\n        t1_putline(pdf);\n}\n\nstatic boolean t1_open_fontfile(int open_name_prefix)\n{\n    ff_entry *ff;\n    int callback_id = 0;\n    int file_opened = 0;\n    t1_curbyte = 0;\n    t1_size = 0;\n    ff = check_ff_exist(fd_cur->fm->ff_name, is_truetype(fd_cur->fm));\n    if (ff->ff_path == NULL) {\n        formatted_error(\"type 1\",\"cannot open file for reading '%s'\",fd_cur->fm->ff_name);\n        return false;\n    }\n    cur_file_name = luatex_find_file(ff->ff_path, find_type1_file_callback);\n    if (cur_file_name == NULL) {\n        formatted_error(\"type 1\",\"cannot open file for reading '%s'\", ff->ff_path);\n        return false;\n    }\n    callback_id = callback_defined(read_type1_file_callback);\n    if (callback_id > 0) {\n        if (!run_callback(callback_id, \"S->bSd\", cur_file_name, &file_opened, &t1_buffer, &t1_size)\n            && file_opened && t1_size > 0) {\n            formatted_warning(\"type 1\",\"cannot open file for reading '%s'\",cur_file_name);\n            return false;\n        }\n    } else {\n        t1_file = xfopen(cur_file_name, FOPEN_RBIN_MODE);\n        t1_read_file();\n        t1_close();\n    }\n    recorder_record_input(cur_file_name);\n    t1_init_params(open_name_prefix);\n    return true;\n}\n\nstatic void t1_include(PDF pdf)\n{\n    do {\n        t1_getline();\n        t1_scan_param(pdf);\n        t1_putline(pdf);\n    }\n    while (t1_in_eexec == 0);\n    t1_start_eexec(pdf);\n    do {\n        t1_getline();\n        t1_scan_param(pdf);\n        t1_putline(pdf);\n    }\n    while (!(t1_charstrings() || t1_subrs()));\n    t1_cs = true;\n    do {\n        t1_getline();\n        t1_putline(pdf);\n    }\n    while (!t1_end_eexec());\n    t1_stop_eexec(pdf);\n    if (fixedcontent) {\n        /*tex Copy 512 zeros (not needed for \\PDF). */\n        do {\n            t1_getline();\n            t1_putline(pdf);\n        }\n        while (!t1_cleartomark());\n        /*tex Write |{restore} if| if found. */\n        t1_check_end(pdf);\n    }\n    get_length3();\n}\n\n#define check_subr(subr) \\\n    if (subr >= subr_size || subr < 0) \\\n        formatted_error(\"type 1\",\"Subrs array: entry index out of range '%i'\", subr);\n\nstatic const char **check_cs_token_pair(void)\n{\n    const char **p = (const char **) cs_token_pairs_list;\n    for (; p[0] != NULL; ++p)\n        if (t1_buf_prefix(p[0]) && t1_buf_suffix(p[1]))\n            return p;\n    return NULL;\n}\n\nstatic void cs_store(boolean is_subr)\n{\n    char *p;\n    cs_entry *ptr;\n    int subr;\n    for (p = t1_line_array, t1_buf_ptr = t1_buf_array; *p != ' ';\n         *t1_buf_ptr++ = *p++);\n    *t1_buf_ptr = 0;\n    if (is_subr) {\n        subr = (int) t1_scan_num(p + 1, 0);\n        check_subr(subr);\n        ptr = subr_tab + subr;\n    } else {\n        ptr = cs_ptr++;\n        if (cs_ptr - cs_tab > cs_size)\n            formatted_error(\"type 1\",\"CharStrings dict: more entries than dict size '%i'\", cs_size);\n        if (strcmp(t1_buf_array + 1, notdef) == 0)      /* skip the slash */\n            ptr->name = (char *) notdef;\n        else\n            ptr->name = xstrdup(t1_buf_array + 1);\n    }\n    /*tex Copy |\" RD \" + cs data| to |t1_buf_array|. */\n    memcpy(t1_buf_array, t1_line_array + cs_start - 4, (unsigned) (t1_cslen + 4));\n    /*tex Copy the end of cs data to |t1_buf_array|. */\n    for (p = t1_line_array + cs_start + t1_cslen, t1_buf_ptr =\n         t1_buf_array + t1_cslen + 4; *p != 10; *t1_buf_ptr++ = *p++);\n    *t1_buf_ptr++ = 10;\n    if (is_subr && cs_token_pair == NULL)\n        cs_token_pair = check_cs_token_pair();\n    ptr->len = (unsigned short) (t1_buf_ptr - t1_buf_array);\n    ptr->cslen = t1_cslen;\n    xfree(ptr->data);\n    ptr->data = xtalloc(ptr->len, byte);\n    memcpy(ptr->data, t1_buf_array, ptr->len);\n    ptr->valid = true;\n}\n\n#define store_subr() cs_store(true)\n#define store_cs()   cs_store(false)\n\n#define CC_STACK_SIZE 24\n\nstatic int cc_stack[CC_STACK_SIZE], *stack_ptr = cc_stack;\nstatic cc_entry cc_tab[CS_MAX];\nstatic boolean is_cc_init = false;\n\n#define cc_pop(N) \\\n    if (stack_ptr - cc_stack < (N)) \\\n        stack_error(N); \\\n    stack_ptr -= N\n\n#define stack_error(N) { \\\n    formatted_error(\"type 1\",\"CharString: invalid access '%i' to stack, '%i' entries\", (int) N, (int)(stack_ptr - cc_stack)); \\\n    goto cs_error; \\\n}\n\n#define cc_get(N)  ((N) < 0 ? *(stack_ptr + (N)) : *(cc_stack + (N)))\n#define cc_push(V) *stack_ptr++ = V\n#define cc_clear() stack_ptr = cc_stack\n\n#define set_cc(N, B, A, C) \\\n    cc_tab[N].nargs = A;   \\\n    cc_tab[N].bottom = B;  \\\n    cc_tab[N].clear = C;   \\\n    cc_tab[N].valid = true\n\nstatic void cc_init(void)\n{\n    int i;\n    if (is_cc_init)\n        return;\n    for (i = 0; i < CS_MAX; i++)\n        cc_tab[i].valid = false;\n    set_cc(CS_HSTEM, true, 2, true);\n    set_cc(CS_VSTEM, true, 2, true);\n    set_cc(CS_VMOVETO, true, 1, true);\n    set_cc(CS_RLINETO, true, 2, true);\n    set_cc(CS_HLINETO, true, 1, true);\n    set_cc(CS_VLINETO, true, 1, true);\n    set_cc(CS_RRCURVETO, true, 6, true);\n    set_cc(CS_CLOSEPATH, false, 0, true);\n    set_cc(CS_CALLSUBR, false, 1, false);\n    set_cc(CS_RETURN, false, 0, false);\n    set_cc(CS_HSBW, true, 2, true);\n    set_cc(CS_ENDCHAR, false, 0, true);\n    set_cc(CS_RMOVETO, true, 2, true);\n    set_cc(CS_HMOVETO, true, 1, true);\n    set_cc(CS_VHCURVETO, true, 4, true);\n    set_cc(CS_HVCURVETO, true, 4, true);\n    set_cc(CS_DOTSECTION, false, 0, true);\n    set_cc(CS_VSTEM3, true, 6, true);\n    set_cc(CS_HSTEM3, true, 6, true);\n    set_cc(CS_SEAC, true, 5, true);\n    set_cc(CS_SBW, true, 4, true);\n    set_cc(CS_DIV, false, 2, false);\n    set_cc(CS_CALLOTHERSUBR, false, 0, false);\n    set_cc(CS_POP, false, 0, false);\n    set_cc(CS_SETCURRENTPOINT, true, 2, true);\n    is_cc_init = true;\n}\n\n#define cs_getchar()    cdecrypt(*data++, &cr)\n\n#define mark_subr(n)    cs_mark(0, n)\n#define mark_cs(s)      cs_mark(s, 0)\n\nstatic void cs_fail(const char *cs_name, int subr, const char *fmt, ...)\n{\n    char buf[SMALL_BUF_SIZE];\n    va_list args;\n    va_start(args, fmt);\n    vsprintf(buf, fmt, args);\n    va_end(args);\n    if (cs_name == NULL)\n        formatted_error(\"type 1\",\"Subr '%i': %s\", (int) subr, buf);\n    else\n        formatted_error(\"type 1\",\"CharString (/%s): %s\", cs_name, buf);\n}\n\n/*tex Fix a return-less subr by appending |CS_RETURN|. */\n\nstatic void append_cs_return(cs_entry * ptr)\n{\n    unsigned short cr;\n    int i;\n    byte *p, *q, *data, *new_data;\n    /*tex Decrypt the cs data to |t1_buf_array|, append |CS_RETURN|. */\n    p = (byte *) t1_buf_array;\n    data = ptr->data + 4;\n    cr = 4330;\n    for (i = 0; i < ptr->cslen; i++)\n        *p++ = cs_getchar();\n    *p = CS_RETURN;\n    /*tex Encrypt the new cs data to |new_data|. */\n    new_data = xtalloc((unsigned) (ptr->len + 1), byte);\n    memcpy(new_data, ptr->data, 4);\n    p = new_data + 4;\n    q = (byte *) t1_buf_array;\n    cr = 4330;\n    for (i = 0; i < ptr->cslen + 1; i++)\n        *p++ = cencrypt(*q++, &cr);\n    memcpy(p, ptr->data + 4 + ptr->cslen, (size_t) (ptr->len - ptr->cslen - 4));\n    /*tex Update |*ptr|. */\n    xfree(ptr->data);\n    ptr->data = new_data;\n    ptr->len++;\n    ptr->cslen++;\n}\n\nstatic void cs_mark(const char *cs_name, int subr)\n{\n    byte *data;\n    int i, b, cs_len;\n    int last_cmd = 0;\n    int a, a1, a2;\n    unsigned short cr;\n    /*tex The argument of last call to |OtherSubrs[3]|. */\n    static int lastargOtherSubr3 = 3;\n    cs_entry *ptr;\n    cc_entry *cc;\n    if (cs_name == NULL) {\n        check_subr(subr);\n        ptr = subr_tab + subr;\n        if (!ptr->valid)\n            return;\n    } else if (cs_notdef != NULL && (cs_name == notdef || strcmp(cs_name, notdef) == 0)) {\n        ptr = cs_notdef;\n    }else {\n        for (ptr = cs_tab; ptr < cs_ptr; ptr++)\n            if (strcmp(ptr->name, cs_name) == 0)\n                break;\n        if (ptr == cs_ptr) {\n            formatted_warning(\"type 1\",\"glyph '%s' undefined\", cs_name);\n            return;\n        }\n        if (ptr->name == notdef)\n            cs_notdef = ptr;\n    }\n    /*tex\n        Only marked CharString entries and invalid entries can be skipped; valid\n        marked subrs must be parsed to keep the stack in sync.\n    */\n    if (!ptr->valid || (ptr->used && cs_name != NULL))\n        return;\n    ptr->used = true;\n    cr = 4330;\n    cs_len = ptr->cslen;\n    data = ptr->data + 4;\n    for (i = 0; i < t1_lenIV; i++, cs_len--)\n        cs_getchar();\n    while (cs_len > 0) {\n        --cs_len;\n        b = cs_getchar();\n        if (b >= 32) {\n            if (b <= 246)\n                a = b - 139;\n            else if (b <= 250) {\n                --cs_len;\n                a = ((b - 247) << 8) + 108 + cs_getchar();\n            } else if (b <= 254) {\n                --cs_len;\n                a = -((b - 251) << 8) - 108 - cs_getchar();\n            } else {\n                cs_len -= 4;\n                a = (cs_getchar() & 0xff) << 24;\n                a |= (cs_getchar() & 0xff) << 16;\n                a |= (cs_getchar() & 0xff) << 8;\n                a |= (cs_getchar() & 0xff) << 0;\n                if (sizeof(int) > 4 && (a & 0x80000000))\n                    a |= ~0x7FFFFFFF;\n            }\n            cc_push(a);\n        } else {\n            if (b == CS_ESCAPE) {\n                b = cs_getchar() + CS_1BYTE_MAX;\n                cs_len--;\n            }\n            if (b >= CS_MAX) {\n                cs_fail(cs_name, subr, \"command value out of range: %i\", (int) b);\n                goto cs_error;\n            }\n            cc = cc_tab + b;\n            if (!cc->valid) {\n                cs_fail(cs_name, subr, \"command not valid: %i\", (int) b);\n                goto cs_error;\n            }\n            if (cc->bottom) {\n                if (stack_ptr - cc_stack < cc->nargs)\n                    cs_fail(cs_name, subr,\n                            \"less arguments on stack '%i' than required '%i'\",\n                            (int) (stack_ptr - cc_stack), (int) cc->nargs);\n                else if (stack_ptr - cc_stack > cc->nargs)\n                    cs_fail(cs_name, subr,\n                            \"more arguments on stack '%i' than required '%i'\",\n                            (int) (stack_ptr - cc_stack), (int) cc->nargs);\n            }\n            last_cmd = b;\n            switch (cc - cc_tab) {\n                case CS_CALLSUBR:\n                    a1 = cc_get(-1);\n                    cc_pop(1);\n                    mark_subr(a1);\n                    if (!subr_tab[a1].valid) {\n                        cs_fail(cs_name, subr, \"cannot call subr '%i'\", (int) a1);\n                        goto cs_error;\n                    }\n                    break;\n                case CS_DIV:\n                    cc_pop(2);\n                    cc_push(0);\n                    break;\n                case CS_CALLOTHERSUBR:\n                    if (cc_get(-1) == 3)\n                        lastargOtherSubr3 = cc_get(-3);\n                    a1 = cc_get(-2) + 2;\n                    cc_pop(a1);\n                    break;\n                case CS_POP:\n                    cc_push(lastargOtherSubr3);\n                    /*tex\n                        The only case when we care about the value being pushed\n                        onto stack is when |POP| follows |CALLOTHERSUBR| changing\n                        hints by |OtherSubrs[3]|.\n                    */\n                    break;\n                case CS_SEAC:\n                    a1 = cc_get(3);\n                    a2 = cc_get(4);\n                    cc_clear();\n                    mark_cs(standard_glyph_names[a1]);\n                    mark_cs(standard_glyph_names[a2]);\n                    break;\n                default:\n                    if (cc->clear)\n                        cc_clear();\n            }\n        }\n    }\n    if (cs_name == NULL && last_cmd != CS_RETURN) {\n        formatted_warning(\"type 1\",\n            \"last command in subr '%i' is not a RETURN; I will add it now but please consider fixing the font\",\n            (int) subr);\n        append_cs_return(ptr);\n    }\n    return;\n    /*tex An error occured during parsing: */\n  cs_error:\n    cc_clear();\n    ptr->valid = false;\n    ptr->used = false;\n}\n\n/* AVL search tree for glyph code by glyph name. */\n\nstatic int comp_t1_glyphs(const void *pa, const void *pb, void *p\n    __attribute__ ((unused)))\n{\n    return strcmp(*(const char *const *) pa, *(const char *const *) pb);\n}\n\nstatic struct avl_table *create_t1_glyph_tree(char **glyph_names)\n{\n    int i;\n    void **aa;\n    static struct avl_table *gl_tree;\n    gl_tree = avl_create(comp_t1_glyphs, NULL, &avl_xallocator);\n    for (i = 0; i < 256; i++) {\n        if (glyph_names[i] != notdef &&\n            (char **) avl_find(gl_tree, &glyph_names[i]) == NULL) {\n            /*tex No |strdup| here, just point to the |glyph_names| array members. */\n            aa = avl_probe(gl_tree, &glyph_names[i]);\n            if (aa == NULL) {\n                /*tex Is this a problem? */\n            }\n        }\n    }\n    return gl_tree;\n}\n\nstatic void destroy_t1_glyph_tree(struct avl_table *gl_tree)\n{\n    avl_destroy(gl_tree, NULL);\n}\n\nstatic void t1_subset_ascii_part(PDF pdf)\n{\n    int j, *p;\n    char *glyph, **gg, **glyph_names;\n    struct avl_table *gl_tree;\n    struct avl_traverser t;\n    void **aa;\n    t1_getline();\n    while (!t1_prefix(\"/Encoding\")) {\n        t1_scan_param(pdf);\n        t1_putline(pdf);\n        t1_getline();\n    }\n    glyph_names = t1_builtin_enc();\n    fd_cur->builtin_glyph_names = glyph_names;\n    if (is_subsetted(fd_cur->fm)) {\n        if (fd_cur->tx_tree != NULL) {\n            /*tex Take over collected non-reencoded characters from \\TeX. */\n            avl_t_init(&t, fd_cur->tx_tree);\n            for (p = (int *) avl_t_first(&t, fd_cur->tx_tree); p != NULL;\n                 p = (int *) avl_t_next(&t)) {\n                if ((char *) avl_find(fd_cur->gl_tree, glyph_names[*p]) == NULL) {\n                    glyph = xstrdup(glyph_names[*p]);\n                    aa = avl_probe(fd_cur->gl_tree, glyph);\n                    assert(aa != NULL);\n                }\n            }\n        }\n        make_subset_tag(fd_cur);\n        strncpy((char *) pdf->fb->data + t1_fontname_offset, fd_cur->subset_tag,6);\n    }\n    /*tex Now really all glyphs needed from this font are in the |fd_cur->gl_tree|. */\n    if (t1_encoding == ENC_STANDARD)\n        t1_puts(pdf, \"/Encoding StandardEncoding def\\n\");\n    else {\n        t1_puts(pdf,\"/Encoding 256 array\\n0 1 255 {1 index exch /.notdef put} for\\n\");\n        gl_tree = create_t1_glyph_tree(glyph_names);\n        avl_t_init(&t, fd_cur->gl_tree);\n        j = 0;\n        for (glyph = (char *) avl_t_first(&t, fd_cur->gl_tree); glyph != NULL;\n             glyph = (char *) avl_t_next(&t)) {\n            if ((gg = (char **) avl_find(gl_tree, &glyph)) != NULL) {\n                t1_printf(pdf, \"dup %i /%s put\\n\", (int) (gg - glyph_names),*gg);\n                j++;\n            }\n        }\n        destroy_t1_glyph_tree(gl_tree);\n        if (j == 0) {\n            /*tex\n                We didn't mark anything for the Encoding array. We add |{dup 0\n                /.notdef put}| for compatibility with Acrobat 5.0.\n            */\n            t1_puts(pdf, \"dup 0 /.notdef put\\n\");\n        }\n        t1_puts(pdf, \"readonly def\\n\");\n    }\n    do {\n        t1_getline();\n        t1_scan_param(pdf);\n        if (!t1_prefix(\"/UniqueID\")) {\n            /*tex Ignore |/UniqueID| for subsetted fonts. */\n            t1_putline(pdf);\n        }\n    }\n    while (t1_in_eexec == 0);\n}\n\nstatic void cs_init(void)\n{\n    cs_ptr = cs_tab = NULL;\n    cs_dict_start = cs_dict_end = NULL;\n    cs_counter = cs_size = cs_size_pos = 0;\n    cs_token_pair = NULL;\n    subr_tab = NULL;\n    subr_array_start = subr_array_end = NULL;\n    subr_max = subr_size = subr_size_pos = 0;\n}\n\nstatic void init_cs_entry(cs_entry * cs)\n{\n    cs->data = NULL;\n    cs->name = NULL;\n    cs->len = 0;\n    cs->cslen = 0;\n    cs->used = false;\n    cs->valid = false;\n}\n\nstatic void t1_read_subrs(PDF pdf)\n{\n    int i, s;\n    cs_entry *ptr;\n    t1_getline();\n    while (!(t1_charstrings() || t1_subrs())) {\n        t1_scan_param(pdf);\n        if (!t1_prefix(\"/UniqueID\")) {\n            /*tex Ignore |/UniqueID| for subsetted fonts. */\n            t1_putline(pdf);\n        }\n        t1_getline();\n    }\n  found:\n    t1_cs = true;\n    t1_scan = false;\n    if (!t1_subrs())\n        return;\n    subr_size_pos = strlen(\"/Subrs\") + 1;\n    /*tex |subr_size_pos| points to the number indicating dict size after |Subrs|. */\n    subr_size = (int) t1_scan_num(t1_line_array + subr_size_pos, 0);\n    if (subr_size == 0) {\n        while (!t1_charstrings())\n            t1_getline();\n        return;\n    }\n    subr_tab = xtalloc((unsigned) subr_size, cs_entry);\n    for (ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n        init_cs_entry(ptr);\n    subr_array_start = xstrdup(t1_line_array);\n    t1_getline();\n    while (t1_cslen) {\n        store_subr();\n        t1_getline();\n    }\n    /*tex Mark the first four entries without parsing. */\n    for (i = 0; i < subr_size && i < 4; i++)\n        subr_tab[i].used = true;\n    /*tex\n\n        The end of the |Subrs| array might have more than one line so we need to\n        concatenate them to |subr_array_end|. Unfortunately some fonts don't have\n        the |Subrs| array followed by the |CharStrings| dict immediately (synthetic\n        fonts). If we cannot find |CharStrings| in next |POST_SUBRS_SCAN| lines\n        then we will treat the font as synthetic and ignore everything until next\n        |Subrs| is found.\n\n     */\n#define POST_SUBRS_SCAN 5\n    s = 0;\n    *t1_buf_array = 0;\n    for (i = 0; i < POST_SUBRS_SCAN; i++) {\n        if (t1_charstrings())\n            break;\n        s = (int) (s + t1_line_ptr - t1_line_array);\n        alloc_array(t1_buf, s, T1_BUF_SIZE);\n        strcat(t1_buf_array, t1_line_array);\n        t1_getline();\n    }\n    subr_array_end = xstrdup(t1_buf_array);\n    if (i == POST_SUBRS_SCAN) {\n        /*tex |CharStrings| not found: assume a synthetic font. */\n        for (ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n            if (ptr->valid)\n                xfree(ptr->data);\n        xfree(subr_tab);\n        xfree(subr_array_start);\n        xfree(subr_array_end);\n        cs_init();\n        t1_cs = false;\n        t1_synthetic = true;\n        while (!(t1_charstrings() || t1_subrs()))\n            t1_getline();\n        goto found;\n    }\n}\n\n#define t1_subr_flush()  t1_flush_cs(pdf, true)\n#define t1_cs_flush()    t1_flush_cs(pdf, false)\n\nstatic void t1_flush_cs(PDF pdf, boolean is_subr)\n{\n    char *p;\n    byte *r, *return_cs = NULL;\n    cs_entry *tab, *end_tab, *ptr;\n    char *start_line, *line_end;\n    int count, size_pos;\n    unsigned short cr, cs_len;\n    if (is_subr) {\n        start_line = subr_array_start;\n        line_end = subr_array_end;\n        size_pos = subr_size_pos;\n        tab = subr_tab;\n        count = subr_max + 1;\n        end_tab = subr_tab + count;\n    } else {\n        start_line = cs_dict_start;\n        line_end = cs_dict_end;\n        size_pos = cs_size_pos;\n        tab = cs_tab;\n        end_tab = cs_ptr;\n        count = cs_counter;\n    }\n    t1_line_ptr = t1_line_array;\n    for (p = start_line; p - start_line < size_pos;)\n        *t1_line_ptr++ = *p++;\n    while (isdigit((unsigned char)*p))\n        p++;\n    sprintf(t1_line_ptr, \"%u\", count);\n    strcat(t1_line_ptr, p);\n    t1_line_ptr = eol(t1_line_array);\n    t1_putline(pdf);\n    /*tex For |-Wall|. */\n    cs_len = 0;\n    /*tex Create |return_cs| to replace unsused |subr|s. */\n    if (is_subr) {\n        cr = 4330;\n        cs_len = 0;\n        /*tex\n            At this point we have |t1_lenIV >= 0;| a negative value would be\n            caught in |t1_scan_param|.\n        */\n        return_cs = xtalloc((unsigned) (t1_lenIV + 1), byte);\n        for (cs_len = 0, r = return_cs; cs_len < t1_lenIV; cs_len++, r++)\n            *r = cencrypt(0x00, &cr);\n        *r = cencrypt(CS_RETURN, &cr);\n        cs_len++;\n    }\n    for (ptr = tab; ptr < end_tab; ptr++) {\n        if (ptr->used) {\n            if (is_subr)\n                sprintf(t1_line_array, \"dup %li %u\", (long int) (ptr - tab),\n                        ptr->cslen);\n            else\n                sprintf(t1_line_array, \"/%s %u\", ptr->name, ptr->cslen);\n            p = strend(t1_line_array);\n            memcpy(p, ptr->data, ptr->len);\n            t1_line_ptr = p + ptr->len;\n            t1_putline(pdf);\n        } else {\n            /*tex Replace unsused subr's by |return_cs|. */\n            if (is_subr) {\n                sprintf(t1_line_array, \"dup %li %u%s \", (long int) (ptr - tab),\n                        cs_len, cs_token_pair[0]);\n                p = strend(t1_line_array);\n                memcpy(p, return_cs, cs_len);\n                t1_line_ptr = p + cs_len;\n                t1_putline(pdf);\n                sprintf(t1_line_array, \" %s\", cs_token_pair[1]);\n                t1_line_ptr = eol(t1_line_array);\n                t1_putline(pdf);\n            }\n        }\n        xfree(ptr->data);\n        if (is_subr)\n            ptr->valid = false;\n        if (ptr->name != notdef)\n            xfree(ptr->name);\n    }\n    sprintf(t1_line_array, \"%s\", line_end);\n    t1_line_ptr = eol(t1_line_array);\n    t1_putline(pdf);\n    if (is_subr) {\n        end_tab = subr_tab + subr_size;\n        for (ptr = tab; ptr < end_tab; ptr++) {\n            if (ptr->valid) {\n                xfree(ptr->data);\n                if (ptr->name != notdef)\n                    xfree(ptr->name);\n            }\n        }\n        xfree(return_cs);\n    }\n    xfree(tab);\n    xfree(start_line);\n    xfree(line_end);\n}\n\nstatic void t1_mark_glyphs(void)\n{\n    char *glyph;\n    struct avl_traverser t;\n    cs_entry *ptr;\n    if (t1_synthetic || fd_cur->all_glyphs) {\n        /*tex Mark everything. */\n        if (cs_tab != NULL)\n            for (ptr = cs_tab; ptr < cs_ptr; ptr++)\n                if (ptr->valid)\n                    ptr->used = true;\n        if (subr_tab != NULL) {\n            for (ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n                if (ptr->valid)\n                    ptr->used = true;\n            subr_max = subr_size - 1;\n        }\n        return;\n    }\n    mark_cs(notdef);\n    avl_t_init(&t, fd_cur->gl_tree);\n    for (glyph = (char *) avl_t_first(&t, fd_cur->gl_tree); glyph != NULL;\n         glyph = (char *) avl_t_next(&t)) {\n        mark_cs(glyph);\n    }\n    if (subr_tab != NULL)\n        for (subr_max = -1, ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n            if (ptr->used && ptr - subr_tab > subr_max)\n                subr_max = (int) (ptr - subr_tab);\n}\n\n\n/*tex\n\n    When |t1_subset_charstrings| is called, the |t1_line_array| contains\n    |/CharStrings|. When we hit a case like this:\n\n    \\starttyping\n     dup/CharStrings\n     229 dict dup begin\n    \\stoptyping\n\n    we read the next line and concatenate to |t1_line_array| before moving on.\n    That is what |t1_check_unusual_charstring| is for.\n\n*/\n\nstatic void t1_check_unusual_charstring(void)\n{\n    char *p = strstr(t1_line_array, charstringname) + strlen(charstringname);\n    int i;\n    /*tex If no number follows |/CharStrings|, let's read the next line. */\n    if (sscanf(p, \"%i\", &i) != 1) {\n        strcpy(t1_buf_array, t1_line_array);\n        t1_getline();\n        alloc_array(t1_buf, strlen(t1_line_array) + strlen(t1_buf_array) + 1, T1_BUF_SIZE);\n        strcat(t1_buf_array, t1_line_array);\n        alloc_array(t1_line, strlen(t1_buf_array) + 1, T1_BUF_SIZE);\n        strcpy(t1_line_array, t1_buf_array);\n        t1_line_ptr = eol(t1_line_array);\n    }\n}\n\nstatic void t1_subset_charstrings(PDF pdf)\n{\n    cs_entry *ptr;\n    t1_check_unusual_charstring();\n    cs_size_pos = (int) (strstr(t1_line_array, charstringname) + strlen(charstringname) - t1_line_array + 1);\n    /*tex |cs_size_pos| points to the number indicating dict size after |/CharStrings|. */\n    cs_size = (int) t1_scan_num(t1_line_array + cs_size_pos, 0);\n    cs_ptr = cs_tab = xtalloc((unsigned) cs_size, cs_entry);\n    for (ptr = cs_tab; ptr - cs_tab < cs_size; ptr++)\n        init_cs_entry(ptr);\n    cs_notdef = NULL;\n    cs_dict_start = xstrdup(t1_line_array);\n    t1_getline();\n    while (t1_cslen) {\n        store_cs();\n        t1_getline();\n    }\n    cs_dict_end = xstrdup(t1_line_array);\n    t1_mark_glyphs();\n    if (subr_tab != NULL) {\n        if (cs_token_pair == NULL)\n            formatted_error(\"type 1\",\"mismatched subroutine begin/end token pairs\");\n        t1_subr_flush();\n    }\n    for (cs_counter = 0, ptr = cs_tab; ptr < cs_ptr; ptr++)\n        if (ptr->used)\n            cs_counter++;\n    t1_cs_flush();\n}\n\nstatic void t1_subset_end(PDF pdf)\n{\n    if (t1_synthetic) {\n        /*tex Copy to |dup /FontName get exch definefont pop|. */\n        while (!strstr(t1_line_array, \"definefont\")) {\n            t1_getline();\n            t1_putline(pdf);\n        }\n        while (!t1_end_eexec()) {\n            /*tex Ignore the rest. */\n            t1_getline();\n        }\n        /*tex Write \\.{mark currentfile closefile}. */\n        t1_putline(pdf);\n    } else {\n        while (!t1_end_eexec()) {\n            /*tex Copy to \\.{mark currentfile closefile}. */\n            t1_getline();\n            t1_putline(pdf);\n        }\n    }\n    t1_stop_eexec(pdf);\n    if (fixedcontent) {\n        /*tex Copy 512 zeros (not needed for PDF). */\n        while (!t1_cleartomark()) {\n            t1_getline();\n            t1_putline(pdf);\n        }\n        /*tex Don't check \\.{{restore}if} for synthetic fonts. */\n        if (!t1_synthetic) {\n            /*tex Write \\.{{restore}if} if found. */\n            t1_check_end(pdf);\n        }\n    }\n    get_length3();\n}\n\nvoid writet1(PDF pdf, fd_entry * fd)\n{\n    /*tex |fd_cur| is global inside |writet1.c|. */\n    fd_cur = fd;\n    assert(fd_cur->fm != NULL);\n    assert(is_type1(fd->fm));\n    assert(is_included(fd->fm));\n\n    t1_save_offset = 0;\n    if (!is_subsetted(fd_cur->fm)) {\n        /*tex Include entire font. */\n        if (!(fd->ff_found = t1_open_fontfile(filetype_font)))\n            return;\n        t1_include(pdf);\n        t1_close_font_file(filetype_font);\n        xfree(t1_buffer);\n        return;\n    }\n    /*tex Partial downloading. */\n    if (!(fd->ff_found = t1_open_fontfile(filetype_subset)))\n        return;\n    t1_subset_ascii_part(pdf);\n    t1_start_eexec(pdf);\n    cc_init();\n    cs_init();\n    t1_read_subrs(pdf);\n    t1_subset_charstrings(pdf);\n    t1_subset_end(pdf);\n    t1_close_font_file(filetype_subset);\n    xfree(t1_buffer);\n}\n\nvoid t1_free(void)\n{\n    xfree(t1_line_array);\n    xfree(t1_buf_array);\n}\n", "2018-09-18  Nick Roessler  <nicholas.e.roessler@gmail.com>\n\n\t* writet1.c (t1_check_unusual_charstring): protect against buffer\n\toverflow.\n\n2018-09-09  Karl Berry  <karl@tug.org>\n\n\t* expanded.test,\n\t* ttf2afm.test: LC_ALL=LANGUAGE=C.\n\n2018-07-09  Karl Berry  <karl@freefriends.org>\n\n\t* writefont.c (write_fontdescriptor) [ENABLE_PDF_CHARSET]:\n\tcompile-time conditional for re-enabling output of PDF /CharSet,\n\twhich is now disabled by default.\n\n2018-06-13  TANAKA Takuji  <ttk@t-lab.opal.ne.jp>\n\n\t* ptexlib.h: Output correct Unicode strings on console\n\t(w32 only).\n\n2018-06-12  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftoepdf.cc: Free unused memory (w32 only).\n\n2018-06-11  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftoepdf.cc: Remove xfree(file_name) in order to avoid\n\tto output garbage.\n\t* pdftoepdf-newpoppler.cc: Remove _WIN32 changes, since\n\tutf-8 names are transformed to Unicode and _wopened\n\tin poppler.\n\n2018-06-10  TANAKA Takuji  <ttk@t-lab.opal.ne.jp>\n\n\t* ptexlib.h, pdftoepdf.cc, pdftoepdf-newpoppler.cc:\n\tAllow non-ascii file names for pdfTeX with UTF-8 source files\n\t(w32 only). The function is enabled by setting\n\t'command_line_encoding=utf-8' in texmf.cnf.\n\n2018-05-29  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* ptexlib.h: Discard the changes on 2018-05-11, since\n\t'command_line_encoding=utf-8' is not so natural for\n\tpdfTeX (w32 only).\n\n2018-05-13  Joseph Wright  <joseph.wright@morningstar2.co.uk>\n\n\t* pdftex.web: New primitive \\expanded based on original\n\t  suggestion by Heiko Oberdiek, and with work by\n\t  Bruno Le Floch and David Carlisle (on behalf of The LaTeX Project).\n        (expanded_code): new @d, new cases.\n        https://mailman.ntg.nl/pipermail/ntg-pdftex/2018-May/004233.html\n\n2018-05-11  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* ptexlib.h: Allow non-ascii file names in pdfTeX (w32 only).\n\n2018-04-28  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftoepdf-newpoppler.cc, pdftosrc-newpoppler.cc:\n\tSupport poppler 0.64.0.\n\n2018-04-14  Karl Berry  <karl@tug.org>\n\n\t* TeX Live 2018 release, pdftex 1.40.19.\n\n2018-04-04  Jerry James  <loganjerry@gmail.com>\n\n\t* pdftoepdf-newpoppler.cc: Do not copy a Dict, get a reference instead.\n\n2018-03-24  Hironobu Yamashita  <h.y.acetaminophen@gmail.com>\n            Hironori Kitagawa  <h_kitagawa2001@yahoo.co.jp>\n\n\t* pdftex.ch: Recover the right \\lastnodetype initialization\n\tvalue ignored by tex.ch.\n\n2018-03-20  Hans Hagen  <pragma@wxs.nl>\n\n\t* pdftex.web (Glob...): defined saved_pdf_cur_form.\n\t(Write out pending forms): save and restore the form.\n\tOriginal report from Alexander Grahn,\n\thttp://tug.org/pipermail/tex-live/2018-March/041210.html.\n\n2018-03-06  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftex.web: pdftex_revision==\"19\".\n\tReported by Uwe Siart, 2018-03-06.\n\n2018-01-25  Hironobu Yamashita  <h.y.acetaminophen@gmail.com>\n        and Karl Berry  <karl@freefriends.org>\n\n\t* writefont.c (font_is_used): import LuaTeX's font_has_subset\n\twith different name.\n\t(dopdffont): call it, to avoid failed assertion. (tests/09-fontobjnum)\n\tOriginal report from Enrico Gregorio,\n\t  tug.org/pipermail/tex-live/2018-January/040966.html\n\tfollowup with patch at\n\t  mailman.ntg.nl/pipermail/ntg-pdftex/2018-January/004209.html\n\n2018-01-06  Karl Berry  <karl@freefriends.org>\n\n\t* pdftex.web (literal): if a non-PDF special is ignored,\n\talso output \"<special> \" and the first 64 characters of the special.\n\t(slow_print_substr): new procedure, although surely there's\n\talready a way to print a substring of a pool string.\n\n2018-01-01  Pali Roh\\'ar  <pali.rohar@gmail.com>\n\n\tPatch 1: explicitly detect bitmap PK font in fm_scan_line,\n\tinstead of the implicit check of ps_name and ff_name being NULL.\n\t* ptexmac.h (F_PK, set_pk, unset_pk, is_pk): new macros.\n\t* writefont.c (dopdffont): call writet3 if is_pk.\n\t* mapfile.c (fm_scan_line): call set_pk if no fontfile\n\tand no ps_name on encoding line.\n\n\tPatch 2: Always embed bitmap fonts with different sizes\n\tseparately, even if it has a fontmap entry; i.e., no geometric\n\tscaling in the generated PDF.\n\t* pdftex.defines (isscalable),\n\t* ptexlib.h (isscalable),\n\t* mapfile.c (isscalable): new fn.\n\t* pdftex.web: call isscalable instead of hasfmentry\n\tin all cases except @<Output fonts definition@>.\n\t\t\n\tPatch 3: Allow .enc files for bitmap PK fonts.\n\t* ptexlib.h (writet3): take additional fm_entry* parameter.\n\t* writefont.c (dopdffont): change call.\n\t* writet3.c (writet3): change definition;\n\twrite_tounicode and encoding vector if we can.\n\t(remove_duplicate_glyph_names): new fn.\n\t\n\tPatch 4: Additional checks for PK fonts in map file.\n\t* mapfile.c (check_fm_entry): \n\n\tChangeLog entry, some comments, error messages written or tweaked\n\tby Karl Berry; all substantive code by Pali. Patch posted at\n\thttps://mailman.ntg.nl/pipermail/ntg-pdftex/2017-August/004183.html.\n\tSee test-pkmap.tex for more references and some tests.\n\n2017-12-16  Hironori Kitagawa  <h_kitagawa2001@yahoo.co.jp>\n\n\t* pdftex.web (compare_strings): Fix \\pdfstrcmp error message\n        \"! File ended while ...\" to report control sequence correctly.\n\thttp://tug.org/pipermail/tex-k/2017-December/002838.html\n\n2017-12-15  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* tounicode.c (deftounicode): check that value is in range [0,10FFFF].\n\tOriginal report from Ross Moore, ntg-pdftex 30 May 2017 06:03:04.\n\n2017-12-02  Karl Berry  <karl@tug.org>\n\n\t* am/pdftex.am (pdftex.pdf, pdftex.tex): new convenience targets\n\tfor simple weave && pdftex to generate typeset output.\n\n2017-11-28  Hironori KITAGAWA <h_kitagawa2001@yahoo.co.jp>\n\n\tStop \\pdfprimitive\\vrule\\q from swallowing q, by moving prim_eqtb\n\tinto the end of region 2 of eqtb instead of being a separate table.\n\t* pdftex.ch (frozen_null_font): add prim_size.\n\t* pdftex.web (prim_size): move to other region 2 definitions.\n\t(prim_eqtb_base): new constant.\n\t(prim_eq_level, prim_eq_type, prim_equiv): use prim_eqtb_base.\n\t(prim_eqtb): remove array.\n\t(Set init...): remove initializations.\n\t(Basic printing...),\n\t(Basic printing procedures): handle primitives after prim_eqtb_base.\n\t(Implement \\.{\\\\pdfprimitive}): do not give error if argument is\n\t not a primitive, just do nothing.\n\t(Reset |cur_tok| for unexpandable primitives, goto restart):\n\t handle primitive lookups via prim_eqtb_base instead of cur_cmd*@'400.\n\t(Cases of |main_control| that are not part of the inner loop):\n\t<not undefined_primitive>: also set cur_tok.\n\t(Dump the hash table): do not dump prim_eqtb.\n\t(Undump the hash table): do not undump prim_eqtb.\n\t\n2017-11-14  Anders Kaseorg  <andersk@mit.edu>\n\n\t* utils.c (printID): Do not hash the current directory name into\n\tthe PDF ID field, since any variability in it leads to\n\tnon-reproducible builds.\n\tpdftex mailing list, 2 Sep 2017 01:52:43\n\thttps://bugs.debian.org/874102\n\n2017-10-17  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftosrc.cc: Support also xpdf-3.04 if XPDF304 is defined.\n\t* pdftoepdf-newpoppler.cc, pdftosrc-newpoppler.cc: New files\n\tadded in order to support poppler 0.59.0 or newer versions.\n\tPOPPLER_VERSION should be defined. At present, simply overwrite\n\tpdftoepdf.cc and pdftosrc.cc by pdftoepdf-newpoppler.cc and\n\tpdftosrc-newpoppler.cc, respectively, in order to use these\n\tfiles.\n\tThe current pdftoepdf.cc and pdftosrc.cc support\n\txpdf-4.00 by default, xpdf-3.04 if XPDF304 is defined, and\n\tpoppler 0.57.0 or older versions if POPPLER_VERSION is\n\tdefined.\n\n2017-10-10  Shreevatsa R <shreevatsa.public@gmail.com>\n\n\t* pdftex.web: formatting-only fixes to make weave-able.\n\tPosted to ntg-pdftex, 15 Aug 2017 09:49:59.\n\n2017-09-24  Hironori Kitagawa  <h_kitagawa2001@yahoo.co.jp>\n\n\t* pdftex.web: Avoid overwriting prim_* entries by primitive().\n\n2017-09-14  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftosrc.cc: Fix a potential bug which I introduced on\n\t2017-08-13.\n\n2017-08-13  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftosrc.cc: Remove a line, which I believe is not necessary,\n\tto avoid a crash for xpdf-4.00.\n\n2017-04-19  Karl Berry  <karl@freefriends.org>\n\n\t* mapfile.c (read_field): new parameter buf_size,\n\tand check buffer for overflow, as in append_char_to_buf.\n\t(fm_scan_line): change read_field calls;\n\tset tfm_name to empty string instead of leaving NULL.\n\t(check_fm_entry): remove checks of tfm_name on every print;\n\tcheck for empty tfm_name rather than lack of ps_name and font file;\n\tcheck for non-empty tfm_name on slant/extend warnings.\n\n2017-04-12  Karl Berry  <karl@freefriends.org>\n\n\t* mapfile.c (check_fm_entry): do not try to print fm->tfm_name,\n\tetc., in warnings if null.\n\t(fm_scan_line): goto bad_line if a null tfm_name,\n\teven if check_fm_entry returns true.\n\n2017-04-12  Pali Roh\\'ar <pali.rohar@gmail.com>\n\n\t* ptexmac.h (set_subfont, unset_subfont, is_subfont): remove\n        these duplicate macros.\n\n2017-03-29  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n        * writepng.c: Fix the size of memory to allocate when writing\n        SMask in write_png_rgb_alpha. Reported by David Fifield:\n        http://tug.org/pipermail/pdftex/2017-March/009100.html\n\n2017-03-18  Karl Berry  <karl@tug.org>\n\n        * NEWS,\n        * pdftex_version.h,\n        * pdftex.web (pdftex_revision, pdftex_version_string):\n        version [1.40.]18 for TL17.\n\n2017-02-18  Heiko Oberdiek  <heiko.oberdiek@googlemail.com>\n\n\t* pdftex.web (substr_of_str): move earlier.\n\t(Write out page object): if \\MediaBox was given in \\pdfpageattr,\n\tdo not output our own.\n\tMail from Michael Altmann to pdftex, 9 Feb 2017 13:19:05.\n\thttp://tug.org/pipermail/pdftex/2017-February/009097.html\n\n2017-02-16  Karl Berry  <karl@freefriends.org>\n\n\t* regex/regex_internal.h (alloca) [!alloca]: do not try\n\tto #define if already #defined.\n\tReport from Vincent Torri on tex-live list, 7 Jul 2016 10:48:15.\n\t(pdftex r765)\n\n2016-11-05  Karl Berry  <karl@tug.org>\n\n\t* pdftoepdf.cc: doc fix.\n\n2016-07-16  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftoepdf.cc: Use zround(stemV->getNum()) instead of stemV->getInt()\n\tin epdf_create_fontdescriptor(), since the value of stemV may be real\n\tin general.\n\n2016-06-12  Karl Berry  <karl@freefriends.org>\n        and Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* utils.c (last_match_succeeded): new static boolean.\n\t(matchstrings): set it.\n\t(getmatch): use it, plus check for non-NULL match_string sooner,\n\tplus check that rm_eo >= rm_so.\n\tOriginal bug report from David Carlisle,\n        http://tug.org/pipermail/tex-live/2016-June/038664.html\n        (pdftex r759)\n\n2016-06-12  Karl Berry  <karl@freefriends.org>\n        and Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* utils.c (last_match_succeeded): new static boolean.\n\t(matchstrings): set it.\n\t(getmatch): use it, plus check for non-NULL match_string sooner,\n\tplus check that rm_eo >= rm_so.\n\tOriginal bug report from David Carlisle,\n        http://tug.org/pipermail/tex-live/2016-June/038664.html\n\n2016-05-20  Karl Berry  <karl@tug.org>\n\n\t* TeX Live 2016 release.\n\n2016-04-06  Karl Berry  <karl@tug.org>\n\n\t* pdftexextra.h (COPYRIGHT_HOLDER): don't specifically mention peb\n\tand e-TeX, as there are many other copyright holders of other pieces\n\tanyway, and Peter passed away in 2015.\n\n2016-03-24  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* writet1.c: Fix one-byte buffer overflow bug reported by Hanno Boeck:\n\thttp://tug.org/pipermail/tex-live/2016-January/037686.html.\n\n2016-03-21  Karl Berry  <karl@tug.org>\n\n\t* NEWS,\n\t* pdftex_version.h,\n\t* pdftex.web (pdftex_revision, pdftex_version_string): [1.40.]17\n\tfor TL'16.\n\n2016-02-15  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftex.web, pdftoepdf.cc: Add \\pdfsuppressptexinfo, imported from\n\tthe upstream.\n\n2016-01-19  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftex.web: Avoid to crash for unusual virtual fonts which lead to\n\tfont size >= 2048pt.\n\n2015-08-27  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libpdftex.am, am/pdftosrc.am: Enable g++ warnings.\n\t* pdftoepdf.cc, pdftosrc.cc: Avoid g++ warnings.\n\t* tounicode.c: Avoid gcc warnings.\n\n2015-07-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* ptexmac.h: Avoid possible integer overflow.\n\t* writettf.h: No reason to use 'long' for 32-bit integers.\n\t* writettf.c: No reason to use the (possibly 64-bit) 'integer'.\n\n2015-07-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am, am/pdftosrc.am, am/ttf2afm.am: Dependencies for\n\t'make check'.\n\n2015-07-02  Hironori Kitagawa  <h_kitagawa2001@yahoo.co.jp>\n\n\t* utils.c: Moved convertStringToHexString() and getmd5sum()\n\tfrom here to ../lib/texmfmp.c.\n\n2015-06-30  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.defines, ptexlib.h, pdftex.web, utils.c: Sync with\n\tupstream r724.\n\n2015-06-22  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am: Use $(tie_c).\n\n2015-03-07  Karl Berry  <karl@tug.org>\n\n\t* NEWS,\n\t* pdftex_version.h,\n\t* pdftex.web (pdftex_revision, pdftex_version_string): [1.40.]16\n\tfor TL'15.\n\n2015-02-16  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* writejpg.c: support JPEG Exif in addition to JFIF.\n\t(borrowed from dvipdfm-x).\n\n2014-12-12  Karl Berry  <karl@gnu.org>\n\n\t* pdftoepdf.cc (read_pdf_info): do not even warn if\n\tpdf_inclusion_errorlevel (aka \\pdfinclusionerrorlevel) is negative.\n\tDiscussed with Thanh, 31 May 2011 10:17:35.\n\n2014-11-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* regex/regcomp.c [WIN64]: Use __int64 (not long) as intptr_t.\n\n2014-08-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writepng.c: Avoid PNG warnings.\n\n2014-06-26  Thanh Han The  <thanh@river-valley.org>\n\n\t* pdftoepdf.cc: Put a line-ending character after writing a group dict.\n\t(Report from Ross Moore on pdftex list,\n\thttp://tug.org/pipermail/pdftex/2014-June/008911.html)\n\n2014-06-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* mapfile.c, tounicode.c, writet1.c, writettf: Avoid undefined\n\tbehaviour when char is signed.\n\n2014-06-18  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* ttf2afm.c: Avoid undefined behaviour when char is signed.\n\n2014-06-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftosrc.cc: Adapt to xpdf-3.04.\n\n2012-05-20  Thanh Han The  <thanh@river-valley.org>\n\n\t* pdftex.web: do not try to avoid printing 0 0 Td.\n\tE.g., \\rlap fails.\n\t(Report from Heiko on pdftex list, 21 May 2014 22:11:21.)\n\n2014-05-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tUpdate to e-pTeX and e-upTeX from Akira Kakuto.\n\t* ptexlib.h (getfiledump): Move declaration also used by\n\te-(u)pTeX from here to ../texmfmp.h.\n\t* utils.c (getfiledump): Move definition also used by\n\te-(u)pTeX from here to ../lib/texmfmp.c.\n\n2014-03-18  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftex.web and writefont.c: Import from r704.\n\n2014-03-17  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftoepdf.cc, pdftosrc.cc: Kpathsea headers and <w2c/config.h>\n\tare now C++ safe.\n\n2014-03-07  Karl Berry  <karl@tug.org>\n\n\t* pdftex_version.h,\n\t* pdftex.web (pdftex_revision, pdftex_version_string): [1.40.]15.\n\n2014-02-14  Karl Berry  <karl@gnu.org>\n\n\t* pdftex.web (pdf_suppress_warning_page_group): new primitive\n\tparameter \\pdfsuppresswarningpagegroup.\n\t(get_pdf_suppress_warning_page_group): new fn to get its value.\n\t* pdftopdf.cc (write_epdf): check it before issuing warning.\n\n2014-01-20  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tTeX tuneup of 2014.\n\t* pdftex.web, tex.ch0: Adapt to TeX Version 3.14159265.\n\n2014-01-09  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftoepdf.cc (copyObject): Always write \"\\nendstream\" for\n\tPDF/A-1b compliance.\n\n2014-01-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writepng.c: Allow libpng >= 1.6.3 to read images with\n\tincorrect CMF bytes.\n\n2014-01-01  Karl Berry  <karl@tug.org>\n\n\t* All source files: update copyright years to include 2014.\n\n2013-12-23  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web (pdf_end_stream): Always write \"\\nendstream\" for\n\tPDF/A-1b compliance.\n\n2013-12-17  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Always write \"\\n\" after \"obj\" and before \"endobj\".\n\tSuggested by Vincent Immler (http://sarovar.org/tracker/#4341).\n\n2013-12-04  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tUpdate to e-TeX Version 2.6 [2013-11-21].\n\t* etex_version.h, pdftex.web: Enable hyphenation of text between\n\t\\beginL and \\endL or between \\beginR and \\endR.\n\n2013-09-27  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* writet1.c (t1_subset_ascii_part): Remove UniqueID in subsets.\n\tReport from Christian Zietz (czietz/gmx/net),\n\ttex-k 01 Sep 2013 11:25:47 and previous.\n\t(Imported from dvipsk.)\n\n2013-08-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* ttf2afm.test, tests/postV[37].{afm.ttf}: New test and data.\n\t* am/ttf2afm.am: Add the new test.\n\n2013-07-30  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* ttf2afm.c, writettf.c: Treat unknown 'post' table versions\n\t(found in some broken fonts) as 3.0, i.e., no Glyph names.\n\n2013-07-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am, tests/pdfimage.tex: Add a .pdf image.\n\n2013-07-04  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdfimage.test, tests/pdfimage.tex: New test and data.\n\t* am/pdftex.am: Add the new test.\n\n2013-06-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* mapfile.c: First #include <w2c/config.h> via \"ptexlib.h\".\n\t* pdftosrc.cc: First #include <w2c/config.h>.\n\n2013-06-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tUpdate to e-pTeX and e-upTeX 130605 from Hironori Kitagawa.\n\t* ptexlib.h (initstarttime, makecstring, makecfilename,\n\tgetcreationdate, getfilemoddate, getfilesize): Move declarations\n\tof functions also used by e-(u)pTeX from here to ../texmfmp.h.\n\t* utils.c (initstarttime, makecstring, makecfilename,\n\tgetcreationdate, getfilemoddate, getfilesize): Move definition\n\tof these functions from here to ../lib/texmfmp.c.\n\n2013-04-22  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftex.web: pdftex_revision = \"14\"\n\n2013-04-09  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: 1.40.13 ---> 1.40.14 for TL 2013.\n\n2013-03-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Typos.\n\n2013-03-04  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am: Better rules for {pdf,e}tex_version.h.\n\n2013-02-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Adapt to e-TeX 2.5.\n\n2013-02-23  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* etex_version.h: New file extracted from pdftex.web.\n\t* am/pdftex.am, pdftexextra.h: Adjust.\n\n2013-01-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils.c: Include <w2c/config.h> first for large file support.\n\n2013-01-24  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* wprob.test: Avoid spurious failure of parallel-tests.\n\t* am/pdftex.am: Renamed wprob.{tex,log} => pwprob.{tex,log}.\n\n2013-01-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* macnames.c, pdftex-common.h, pdftoepdf.cc, ttf2afm.c,\n\twritet1.c: Change 'const char notdef[]' -> 'char notdef[]' and\n\tremove casts (const char *) -> (char *).\n\n\t* mapfile.c (dummy_fm_entry): Delare const_fm_entry as non-const\n\tand remove the cast.\n\n\t* utils.c (writestreamlength): Cast length for printing.\n\n2012-12-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am (pdftex_version.h): Enable silent rules.\n\n2012-11-05  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Change program name into PDFTEX (not ETEX).\n\t* pdftex.ch: Remove the contents of ../tex-binpool.ch.\n\t* am/pdftex.am (pdftex_ch_srcs): Add tex-binpool.ch.\n\n2012-10-19  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftoepdf.cc: In MSVC 5.0 getNewObjectNumber() requires an int\n\treturn value.\n\n2012-10-18  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftoepdf.cc: #include <w2c/config.h> early to avoid problems\n\twith the definition of boolean in <rpcndr.h> for MINGW32.\n\n2012-10-09  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tThe openbsd compat library is no longer used.\n\t* pdftoepdf.cc, ptexlib.h, utils.c:\n\tDrop #include \"openbsd-compat.h\".\n\t* am/pdftex.am, am/pdftosrc.am: Remove OBSDCOMPAT_*.\n\n2012-10-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tAvoid (most) MinGW compiler warnings from regex code.\n\t* regcomp.c, regexec.c: ANSI C function definitions.\n\t* regcomp.c (init_dfa): Declare codeset_name as const.\n\t* regex_internal.c (re_string_reconstruct, re_dfa_add_node):\n\tAvoid unused variables (for !RE_ENABLE_I18N).\n\t* regexec.c (regexec, re_search_stub, prune_impossible_nodes):\n\tAvoid unused variables (for !_LIBC or !RE_ENABLE_I18N).\n\t(re_search_2_stub): Avoid cast const => non-const.\n\n2012-09-03  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils.c [WIN32] (printID): Convert file names '\\\\' -> '/'.\n\n2012-08-25  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* ttf2afm.c: Drop '#include <libgen.h>', we use xbasename().\n\t* ptexmac.h: Avoid C++ style comment.\n\n2012-08-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* ptexmac.h: Drop unused definition of M_PI & Co.\n\n2012-08-08  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* ptexlib.h: extern void writestreamlength(longinteger, longinteger);\n\tfor largefile.\n\textern void storepacket(internalfontnumber, integer, strnumber); to\n\tavoid a compiler warning.\n\t* utils.c: void writestreamlength(longinteger length, longinteger offset)\n\tfor largefile.\n\t* vfpacket.c: void storepacket(internalfontnumber f, integer c, strnumber s)\n\tto avoid a compiler warning.\n\n2012-08-03  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftex.web: Update eTeX_revision and eTeX_version_string.\n\n2012-08-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Adapt to e-TeX Version 2.5.\n\t* am/pdftex.am: Clarify *tex_version.h dependencies.\n\n2012-07-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils.c (initversionstring): Avoid using asprintf().\n\n2012-07-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am: Distribute pdftex_version.h.\n\t* pdftexextra.h: Use ../etexdir/etex_version.h.\n\n2012-07-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writejbig2.c: Use LONGINTEGER_PRI instead of LONGINTEGER_PRId.\n\n2012-07-15  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* ttf2afm.c: Pass program name string to kpse_set_program_name.\n\n2012-07-15  Akira Kakuto  <kakuto@fuk.kindai.ac.jp>\n\n\t* pdftexextra.c: Must #define DLLPROC before reading pdftexd.h.\n\n2012-07-14  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils.c: Use EXIT_FAILURE instead of EX_SOFTWARE.\n\n2012-07-13  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writejbig2.c: Cast xfseeko() arg2 to avoid MSVC warning.\n\n2012-06-30  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftexextra.c [W32TeX]: #define DLLPROC for pdftex.dll.\n\n2012-06-29  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils.c [__MINGW32__]: #include <regex.h> as for Unix instead\n\tof <regex/regex.h>.\n\t* am/libpdftex.am (libpdftex_a_CPPFLAGS): Change accordingly.\n\n2012-06-21  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftosrc.cc: Use XRef::getNumObjects instead of XRef::getSize,\n\trequired for poppler >= 0.19.0.\n\n2012-05-20  Thanh Han The  <thanh@river-valley.org>\n\n\t* pdftex.defines (get/setimagegroupref): these replace imagegroupref.\n\t* ptexlib.h: likewise.\n\t* writeimg.c: define them, and check for page group\n\twithout object number.\n\t* pdftex.web: change calls.\n\t* pdftoepdf.cc: more page-group changes.\n\tThis is all related to http://bugs.debian.org/672951.\n\n2012-05-11  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Adapted to e-TeX Version 2.4.\n\n2012-04-15  Karl Berry  <karl@tug.org>\n\n\t* pdftex.web (pdftex_revision, pdftex_version_string): 1.40.13.\n\n2012-04-12  Thanh Han The  <thanh@river-valley.org>\n\n\t* ttf2afm.c (print_str): new macro, replacing function.\n\t(escape_eol): new fn, replacing print_str, now returning a string.\n\n\t* writettf.c (ttf_reindex_glyphs): use %n to sscanf forms\n\tuniABCD and index123.\n\n\t* mapfile.c (suppress_warn): way to avoid dup warnings.\n\t\n\t* pdftex.web (pdf_suppress_warning_dup_dest_code,\n\tpdf_suppress_warning_dup_dest_code): new primitives\n\t\\pdfsuppresswarningdupdest and \\pdfsuppresswarningdupmap.\n\t(get_pdf_suppress_warning_dup_map): new fn.\n\t(warn_dest_dup): check pdf_suppress_warning_dup_dest.\n\n2012-04-11  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Fixed a typo in TeX text (for e-TeX).\n\n2012-01-18  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writejbig2.c (getstreamlen): Change type to `off_t'.\n\tUse LONGINTEGER_TYPE and LONGINTEGER_PRId for printing.\n\n2012-01-11  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tConsistent support for large JBIG2 files.\n\t* writejbig2.c: Change type of various struct members, local\n\tvariables and findstreamstart() from `long' or `unsigned long'\n\tto `off_t'.  Do not use xfseek and xfseeko for the same file.\n\n2011-12-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Change type of pdf_ptr: longinteger => integer.\n\t* pdftex-common.h: Change type of pdfptr accordingly.\n\n2011-12-15  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils.c (getfiledump): Drop `off_t' cast from arg2 of fseek().\n\t* ttf2afm.c, writettf.c: Typo in comment.\n\n2011-12-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writejbig2.h (removed): Declarations moved ...\n\t* writejbig2.c: ... to here.  Declare most functions as static.\n\t* am/libpdftex.am (libpdftex_a_SOURCES): Remove writejbig2.h.\n\n2011-10-11  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftosrc.cc: Always use new logic for Object Streams\n\t(for xpdf without patch-40-objectStream-support-for-pdftosrc).\n\n2011-09-30  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* wprob.test: New shell script to test for uninitialized line.\n\t* am/pdftex.am: Add the new test.\t\n\n2011-09-30  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftosrc.test: Shell script for a new test.\n\t* tests/test-{13,15}.{pdf,xref} (new): Test input and expected\n\toutput (from Hartmut Henkel <hartmut_henkel@gmx,de>).\n\t* am/pdftosrc.am: Adjust.\n\n2011-07-25  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftoepdf.cc, pdftosrc.cc: #include <assert.h> for both xpdf\n\tand poppler.\n\n2011-07-11  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftosrc.cc: Rewrite the Object Stream handling for poppler\n\t(or xpdf without patch-40-objectStream-support-for-pdftosrc).\n\n\t* pdftoepdf.cc: Replace `#ifdef HAVE_GETPDFMAJORVERSION' by\n\t'#ifdef POPPLER_VERSION' for poppler >= 0.12.\n\n2011-05-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writepng.c: #define PNG_FP_1 for libpng < 1.5.0.\n\n2011-05-11  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writepng.c: Fix for 16bit images in pdf 1.4 (8bit) mode,\n\tfrom Hartmut Henkel.  Expand the png_* macros introduced for\n\tlibpng-1.2.x => 1.4.x => 1.5.x.\n\n2011-05-09  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writepng.c: Fixes for libpng 1.5.2 copied/adapted from luaTeX.\n\n2011-05-05  Karl Berry  <karl@tug.org>\n\n\t* pdftex.web (pdfTeX_banner): etex version before pdftex version.\n\t(pdftex_revision, pdftex_version_string): bump to 12.\n\t* pdftexextra.h (BANNER): change redundantly-specified banner\n\tagain and again.\n\t(These changes approved by Thanh.)\n\n2011-05-03  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web, tex.ch0: Remove pdfeTeX_banner, no more pdfeTeX.\n\n2011-05-02  Akira Kakuto <kakuto@fuk.kindai.ac.jp>  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Append eTeX_version_string to pdfTeX_banner.\n\n2011-05-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tAvoid \"deprecated conversion from string constant to 'char*'\"\n\twarnings from g++-4.4.\n\tUnfortunately both xpdf and poppler declare lots of function\n\tparameters as 'char *' that should actually be 'const char *'.\n\tCompiling just the parts required for TeX Live with g++-4.4\n\tyields >10000 such warnings for each of xpdf and poppler.\n\n\t* pdftoepdf.cc, pdftosrc.cc: Cast string constants to 'char *'\n\tin order to avoid more such warnings when compiling pdfTeX.\n\n2011-04-29  Karl Berry  <karl@tug.org>\n\n\t* all files: update copyright notices.\n\n2011-04-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Adapted to e-TeX Version 2.3.\n\n2011-04-03  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Adapt to ../etexdir/etex.ch: simplify e-pTeX.\n\n\t* am/pdftex.am (etex_version.h): Derive from pdftex.web instead\n\tof ../etexdir/etex.ch.\n\n2011-03-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libpdftex.am: Use AM_CFLAGS instead of libpdftex_a_CFLAGS.\n\t* am/pdftex.am: Use AM_CFLAGS instead of pdftex_CFLAGS.\n\t* am/ttf2afm.am: Use AM_CFLAGS instead of ttf2afm_CFLAGS.\n\n2011-03-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils.c (pdftex_fail, pdftex_warn): `program_invocation_name'\n\thas been renamed into `kpse_invocation_name'.\n\n2011-01-31  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writepng.c: Remove png-1.2 cruft.\n\n2011-01-31  Thomas Klausner  <tk@giga.or.at>\n\n\t* writepng.c: Fix to build with png-1.5 (and avoid `deprecated'\n\twarnings with png-1.4). The transformations part is removed on\n\trecommendation by John Bowler (a png developer).\n\n2011-01-14  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Adapt to ../etexdir/etex.ch:\n\tMention \\protected in error and help messages only when in\n\tin extended mode.\n\n2011-01-11  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.mak, pdftex.mk (removed): Obsolete.\n\n2011-01-08  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am (pdftex_ch_srcs): Added enctex.ch.\n\n2011-01-01  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftexextra.in: Renamed ...\n\t* pdftexextra.h: ... into this; #include {e,pdf}tex_version.h\n\tfor {E,PDF}TEX_VERSION.\n\n\t* pdftexextra.c (new): #include <pdftexd.h> and <lib/texmfmp.c>.\n\n\t* am/pdftex.am: pdftexextra.[ch] are now distributed;\n\tcreate {e,pdf}tex_version.h instead of {e,pdf}tex.version.\n\n2010-12-01  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writet1.c: Drop unreachable code (after pdftex_fail).\n\tDrop unused free_glyph_names() function.\n\n2010-11-29  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writet1.c (t1_check_unusual_charstring): Drop unused variable.\n\n2010-11-26  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writet1.c: Still more minor tweaks.\n\n2010-11-26  Thanh Han The  <thanh@river-valley.org>\n\n\t* writet1.c (t1_check_unusual_charstring): switch EOL to space\n\tbefore appending.\n\n2010-11-26  Heiko Oberdiek  <heiko.oberdiek@googlemail.com>\n\n\t* pdftex.web (Display the whatsit...): avoid erroneous return.\n\thttp://sarovar.org/tracker/?func=detail&group_id=106&aid=4317&atid=493\n\n2010-11-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web (pdf_out_colorstack): There are no 'othercases'.\n\tFix from Heiko Oberdiek <heiko.oberdiek@googlemail.com>.\n\n2010-11-14  Karl Berry  <karl@tug.org>\n\n\t* writet1.c: endless formatting tweaks.\n\n2010-11-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writet1.c (load_enc_file): Bug fix (using glyph_names[256]).\n\n\t* writet1.c: Formatting and other trivial changes, to reduce\n\tdiffs against dvipsk's writet1.c.\n\n2010-11-11  Thanh Han The  <thanh@river-valley.org>\n\n\t* writet1.c (t1_check_unusual_charstring): new fn.\n\t(t1_subset_charstrings): call it.  This resolves a bug reported by\n\tKnuth when there is a newline between the /CharStrings and the\n\tfollowing number (dict size).\n\n2010-09-29  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writeimg.c: Use png_get_*() instead of directly accessing\n\tfields of the png_info and png_ptr structs.\n\n2010-09-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.test (new): Just testing 'pdftex -version'.\n\t* pdftexdir/am/pdftex.am: Adjusted.\n\n2010-06-22  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tPrepare for libpng-1.4.x.\n\t* writepng.c: Define and use macros to access bit_depth and the\n\tother fields of the png_info and png_ptr structs.\n\n2010-06-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am (pdftex_cppflags): Add $(AM_CPPFLAGS).\n\t* am/ttf2afm.am (ttf2afm_CPPFLAGS): Add $(AM_CPPFLAGS).\n\n2010-06-10  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\tReorganize web2c headers.\n\t* pdftoepdf.cc: #include <w2c/c-auto.h> instead of <c-auto.h>\n\tand <w2c/config.h> instead of \"../config.h\".\n\n2010-06-07  Karl Berry  <karl@tug.org>\n\n\t* pdftex.web: (pdftex_version_string): let's be optimistic and\n\t drop the -beta.\n\n2010-05-20  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftoepdf.cc: #include \"../config.h\" instead of <config.h>,\n\trequired for Mac OS X Leopard.\n\n2010-05-18  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Adapt to ../etexdir/etex.ch:\n\tMore error message with \\protected, from Heiko.\n\n2010-04-30  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex-common.h (xstrdup): Remove decl (in <kpathsea/lib.h>).\n\t(pdfosmode): Declare as boolean as generated by Web2C.\n\t* pdftoepdf.h (deleted): Moved contents ...\n\t* pdftoepdf.cc: ... to here.\n\t#include \"openbsd-compat.h\" as early as possible.\n\tAdd #include <kpathsea/lib.h> and drop decl of const_string.\n\tAvoid MINGW32's typedef of boolean, conflicting with the\n\tdefinition in <kpathsea/types.h>.\n\t* am/libpdftex.am: Adjusted.\n\n\t* pdftex-common.h, writeimg.c (epdf_selected_page,\n\tepdf_num_pages, epdf_page_box): Change from integer to int.\n\t* pdftoepdf.cc: Remove '(int)' casts.\n\n2010-04-29  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* epdf.c, pdftoepdf.cc, writeenc.c: Change various function\n\tparams, return values, and struct members from integer to int.\n\n\tAvoid duplicate function prototypes in different headers.\n\t* epdf.c: Drop #include \"inc-epdf.h\".\n\t* inc-extra.h (deleted): Move prototypes ...\n\t* ptexlib.h: #include \"pdftex-common.h\", move some prototypes ...\n\t* epdf.h: #include \"pdftex-common.h\" instead of \"inc-epdf.h\" and\n\t\"inc-extra.h\", \tmove some prototypes ...\n\t* image.h: Move some prototypes ...\n\t* pdftex-common.h (new): ... to here.\n\n\t* epdf.h (deleted): Renamed ...\n\t* pdftoepdf.h (new): ... into this.\n\t* pdftex.web (pdf_last_byte): Changed type to eight_bits.\n\t* pdftoepdf.cc (notdef): Added (char *) cast.\n\t* pdftoepdf.h, ptexlib.h: Moved declarations from here ...\n\t* pdftex-common.h: ... to here, dropped a few unused ones.\n\t* am/libpdftex.am: Adjusted.\n\n\t* pdftex-common.h: #define pdfosgetosbuf and pdfbeginobj as\n\tin pdftexcoerce.h (generated by Web2C).\n\t* pdftoepdf.cc: Use pdfbeginobj instead of zpdfbeginobj.\n\t* ptexmac.h: Use pdfosgetosbuf instead of zpdfosgetosbuf.\n\n2010-04-28  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.web: Adapt to ../etexdir/etex.ch:\n\tFixed the error message for improper use of \\protected,\n\treported by Heiko Oberdiek <heiko.oberdiek@googlemail.com>.\n\n2010-04-23  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* epdf.h: #include <c-auto.h> instead of <web2c/c-auto.h> etc.\n\n2010-04-22  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am (EXTRA_DIST): Add etexdir/etex.ch.\n\tUse pdftexdir/etex.version instead of etexdir/etex.version.\n\n2010-04-20  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* ptexlib.h: Move extern declaration of ptexbanner to here\n\tfrom ../lib/lib.h (instatiated in ../lib/texmfmp.c).\n\n2010-03-09  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* ttf2afm.c: Use kpse_set_program_name(argv[0], NULL) instead of\n\tkpse_set_progname(argv[0]).\n\n2010-02-14  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* writet1.c (append_cs_return): Cast to byte * to avoid warning.\n\n2010-02-01  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libpdftex.am (libpdftex_a_OBJECTS): Add dependency on\n\t$(ZLIB_DEPEND) and $(LIBPNG_DEPEND).\n\t* am/pdftex.am (pdftex_OBJECTS): Remove explicit dependency on\n\t$(ZLIB_DEPEND) alread implied by libpdftex.a.\n\n2010-01-27  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* avl.c (avl_copy): Proper handling of const.\n\n2010-01-25  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libpdftex.am (libpdftex_a_CFLAGS): Enable compiler warnings.\n\n\tAvoid most compiler warnings:\n\n\t* ptexlib.h, writejbig2.h: ANSI C function prototypes.\n\t* avlstuff.c, mapfile.c, utils.c, vfpacket.c, writeenc.c,\n\twritefont.c, writeimg.c, writejbig2.c, writet1.c, writettf.c:\n\tANSI C function definitions.\n\n\t* avlstuff.c, mapfile.c, utils.c, writeenc.c, writefont.c,\n\twritejbig2.c, writepng.c, writet1.c, writettf.c: Declare\n\tfunctions as static.\n\n\t* ptexlib.h: Add prototype for imagecolor().\n\t* inc-epdf.h: New file with prototypes for is_subsetable(),\n\tepdf_check_mem(), epdf_create_fontdescriptor(),\n\tepdf_mark_glyphs(), get_fd_objnum(), get_fn_objnum(), and\n\tembed_whole_font() ...\n\t* epdf.[ch]: ... removed from here.\n\t* epdf.[ch]: #include \"inc-epdf.h\".\n\t* inc-extra.h: New file with prototypes for stripzeros() and\n\tepdf_write_enc() ...\n\t* epdf.h: ... removed from here.\n\t* epdf.c, utils.c, writeenc.c: #include \"inc-extra.h\".\n\t* am/libpdftex.am (libpdftex_a_SOURCES): Add the new files.\n\n\t* writejbig2.c: Avoid use of possibly uninitialized variables.\n\n\t* utils.c, writefont.c, writet1.c, writettf.c:\n\tDeclare various function params and args, local vars, and struct\n\tmembers as const.\n\n\t* writet1.c (append_cs_return): Drop unused local variable 'k'.\n\n\t* avlstuff.c (destroy_oentry, PdfObjTree_free),\n\twritet1.c (free_glyph_names):\n\tSkip unused static functions (via #if 0 ... #endif).\n\n\t* utils.c (newcolorstack): Don't use value of xretalloc(),\n\txretalloc(addr, n, t) already assigns the new pointer to addr.\n\n\t* avl.c (avl_delete): Don't reuse const input param for\n\tnon-const return value.\n\n2010-01-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libpdftex.am: Add dependency on $(XPDF_DEPEND).\n\t* am/pdftosrc.am: Remove dependency on libpdftex.a.\n\n2010-01-18  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* epdf.c: Remove extern delaration of register_fd_entry().\n\t* pkin.c: Remove extern delaration of t3_file.\n\t* writet1.c: Remove extern delaration of fb_array.\n\t* writettf.c: Remove extern delarations of fb_array and\n\tcharsetstr.\n\t* ptexlib.h: Add extern delarations of fb_array, t3_file, and\n\tregister_fd_entry().\n\n2009-12-12  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am: Replace the obsolete $(mkdir_p) by $(MKDIR_P).\n\n2009-12-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils.c: Drop #ifdef HAVE_ASPRINTF and #include <stdio.h>.\n\n2009-12-01  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* NEWS, README: Update to version 3.1415926-1.40.10.\n\n2009-10-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftoepdf.cc: Adapt to poppler-0.12.\n\n\t* FIXME: epdf.h, ptexlib.h: Multiple prototypes for pdftex_fail,\n\tpdftex_warn, and probably others.\n\n2009-10-07  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am, am/ttf2afm.am: Enable compiler warnings.\n\n\t* mapfile.c, ptexlib.h: Declare pdfinitmapfile() param string\n\tas const.\n\t* pdftex.ch (get_strings_started): Drop unused variables.\n\t* ttf2afm.c: All functions: ANSI C definition, declare as static.\n\t(ttf_fail): Declare as noreturn.\n\t(ttf_fail, ttf_warn, name_lookup, ttf_seek_tab, ttf_seek_off):\n\tDeclare param strings as const.\n\t(get_kern_value): Comment out unused function.\n\n2009-10-04  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* pdftex.ch (do_extension): Recover variables unused by TeX.\n\n2009-09-16  Han The Thanh <hanthethanh@gmail.com>\n\n\t* writettf.c: patch for TTC from Liu Yubao <yubao.liu@gmail.com>\n\n2009-09-06  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am: Adapt to new makecpool with one argument.\n\n2009-09-02  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/libpdftex.am, am/pdftosrc.am: Prepare compiler warnings.\n\n2009-08-20  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* utils.c: #include <kpathsea/version.h> and drop extern decls.\n\n2009-08-19  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/ttf2afm.am (ttf2afm_DEPENDENCIES): Use default_dependencies.\n\n2009-08-18  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am: SyncTeX now integrated into ../texmfmp.h.\n\n2009-08-16  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am (pdf_tangle): Use tangle-sh.\n\tAdapt to tangle-sh and web2c-sh.\n\n2009-08-13  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* am/pdftex.am (pdftex_c_h): avoid to split the C code.\n\n2009-08-12  Karl Berry  <karl@tug.org>\n\n\t* pdftex.web (sup_dest_names_size): increase to 500000;\n\ttest document from Peter Abbott to Karl, 12 Aug 2009 12:24:43.\n\n2009-07-13  Han The Thanh <hanthethanh@gmail.com>\n\n\t* mapfile.c: treat TTC fonts as TTF\n\t* writejpg.c: fix bitmap resolution\n\t* writettf.c: fix segfault for certain TTF fonts\n\t* pdftex.web: enable pk generation by default\n\n2009-06-26  Han The Thanh <hanthethanh@gmail.com>\n\n\t* pdftex.web: bugfix from Hartmut: fix \\pdfobj file {foo} for files\n\t          foo that don't end with '\\n'\n\n2009-06-25  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* epdf.h, ttf2afm.c, writet1.c:\n\tremoved #include <kpathsea/c-proto.h>.\n\t* avlstuff.c, epdf.c: removed #include <kpathsea/c-proto.h> and\n\t#include <stdarg.h>.\n\n2009-06-23  Peter Breitenlohner  <peb@mppmu.mpg.de>\n\n\t* avlstuff.c, epdf.c, ttf2afm.c, writet1.c: #include <stdarg.h>,\n\tnot <kpathsea/c-vararg.h>.\n\n2009-06-04  Karl Berry  <karl@tug.org>\n\n\t* am/pdftex.am (pdftex_LDADD): add libpdftex.a here.\n\t(pdftex_ldadd): remove it from here, so we do not try\n\tto link pdftosrc with it.\n\tReport from vvv, tlbuild mail 03 Jun 2009 21:45:00.\n\n2009-05-07  Norbert Preining <preining@logic.at>\n\n\t* pdftosrc.cc: add warning that poppler version doesn't support\n\tobject streams.\n\n2009-05-05  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* pdftoepdf.cc, pdftosrc.cc, utils.c: adapt for poppler.\n\n\tpatches from Norbert Preining <preining@logic.at>\n\n2009-02-18  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* pdftoepdf.cc: Uninclude <config.h>, included later by \"epdf.h\".\n\n2004-08-21  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* pdfetex.ch2: Adapted to e-TeX version 2.2.\n\n2004-08-26  Olaf Weber  <olaf@infovore.xs4all.nl>\n\n\t* pdfetexextra.in: File was renamed from pdftexextra.h; the\n\tcurrent pdfTeX and e-TeX versions are substituted from\n\t../pdftexdir/pdftex.version and ../etexdir/etex.version.  Variant\n\tof code supplied by Peter Breitenlohner <peb@mppmu.mpg.de>.\n\n\t* pdfetex.mk: Added rule to insert pdfTeX and e-TeX versions into\n\tpdfetexextra.h.  Variant of code supplied by Peter Breitenlohner\n\t<peb@mppmu.mpg.de>.\n\n2004-08-25  Olaf Weber  <olaf@infovore.xs4all.nl>\n\n\t* pdfetex.mk: vadjust.ch moved from pdfxtexdir to pdftexdir.\n\n2004-08-17  Olaf Weber  <olaf@infovore.xs4all.nl>\n\n\t* pdfetex.mk: Resurrected etex.fix, there is again a need to\n\tinclude late-breaking changes.\n\n2004-07-29  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* pdfetex.ch[12]: Somewhat rearrange handling of kern and math\n\tnodes in order to reduce interference between eTeX and pdfTeX\n\tchange files.\n\n\t* pdfetex.ch1 (hlist_out): Keep full mixed direction typesetting\n\tcode.\n\n2004-07-25  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* pdfetex.ch[12]: Reorganize additional command codes for convert\n\tand last_item in order to reduce interference between eTeX and\n\tpdfTeX change files.\n\n2004-07-23  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* pdfetex.ch[12], tex.ch[01]: Reorganize handling of banner\n\tstring in order to reduce interference between eTeX, pdfTeX,\n\tand web2c change files.\n\n2004-07-22  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* pdfetex.ch[12]: Removed unused token types for pdfTeX's\n\tadditional token list parameters.\n\n2004-07-19  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* pdfetex.ch[12], tex.ch0: Reorganize handling of additional\n\ttoken list and integer parameters and e-TeX's additional\n\tpenalties in order to reduce interference between eTeX, pdfTeX,\n\tand web2c change files.\n\n\t* pdfetex.mk (pdfetex.ch): Remove tex.ch2 from build rules.\n\n\t* tex.ch2: Removed.\n\n2004-07-17  Peter Breitenlohner <peb@mppmu.mpg.de>\n\n\t* pdfetex.mk: Rewrite build rules for pdfetex.{web,ch},\n\tremove etex.{ch0,ch1,fix}, tex.ch2, and several non-dependencies.\n\n\t* pdfetex.ch2: Adapt to eTeX changes.\n\n\t* ChangeLog: New file.\n\n(This file public domain.)\n", "/*\nCopyright 1996-2014 Han The Thanh <thanh@pdftex.org>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see  <http://www.gnu.org/licenses/>.  */\n\n#include \"ptexlib.h\"\n#include <stdarg.h>\n#include <string.h>\n\n#define t1_log(str)      tex_printf(\"%s\",str)\n#define get_length1()    t1_length1 = t1_offset() - t1_save_offset\n#define get_length2()    t1_length2 = t1_offset() - t1_save_offset\n#define get_length3()    t1_length3 = fixedcontent? t1_offset() - t1_save_offset : 0\n#define save_offset()    t1_save_offset = t1_offset()\n\n#define t1_open()        open_input(&t1_file, kpse_type1_format, FOPEN_RBIN_MODE)\n#define t1_close()       xfclose(t1_file, cur_file_name)\n#define t1_getchar()     getc(t1_file)\n#define t1_putchar       fb_putchar\n#define t1_offset        fb_offset\n#define t1_ungetchar(c)  ungetc(c, t1_file)\n#define t1_eof()         feof(t1_file)\n\n#define t1_prefix(s)     str_prefix(t1_line_array, s)\n#define t1_buf_prefix(s) str_prefix(t1_buf_array, s)\n#define t1_suffix(s)     str_suffix(t1_line_array, t1_line_ptr, s)\n#define t1_buf_suffix(s) str_suffix(t1_buf_array, t1_buf_ptr, s)\n#define t1_charstrings() strstr(t1_line_array, charstringname)\n#define t1_subrs()       t1_prefix(\"/Subrs\")\n#define t1_end_eexec()   t1_suffix(\"mark currentfile closefile\")\n#define t1_cleartomark() t1_prefix(\"cleartomark\")\n\n#define enc_open()       open_input(&enc_file, kpse_enc_format, FOPEN_RBIN_MODE)\n#define enc_close()      xfclose(enc_file, cur_file_name)\n#define enc_getchar()    getc(enc_file)\n#define enc_eof()        feof(enc_file)\n\n#define valid_code(c)    (c >= 0 && c < 256)\n#define fixedcontent     false /* false for pdfTeX, true for dvips */\n\nstatic const char *standard_glyph_names[256] = {\n    /* 0x00 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0x10 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0x20 */\n    \"space\", \"exclam\", \"quotedbl\", \"numbersign\", \"dollar\", \"percent\",\n    \"ampersand\", \"quoteright\", \"parenleft\", \"parenright\", \"asterisk\",\n    \"plus\", \"comma\", \"hyphen\", \"period\", \"slash\",\n    /* 0x30 */\n    \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\",\n    \"nine\", \"colon\", \"semicolon\", \"less\", \"equal\", \"greater\", \"question\",\n    /* 0x40 */\n    \"at\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\",\n    \"O\",\n    /* 0x50 */\n    \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"bracketleft\",\n    \"backslash\", \"bracketright\", \"asciicircum\", \"underscore\",\n    /* 0x60 */\n    \"quoteleft\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\",\n    \"m\", \"n\", \"o\",\n    /* 0x70 */\n    \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"braceleft\", \"bar\",\n    \"braceright\", \"asciitilde\", notdef,\n    /* 0x80 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0x90 */\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0xa0 */\n    notdef, \"exclamdown\", \"cent\", \"sterling\", \"fraction\", \"yen\", \"florin\",\n    \"section\", \"currency\", \"quotesingle\", \"quotedblleft\", \"guillemotleft\",\n    \"guilsinglleft\", \"guilsinglright\", \"fi\", \"fl\",\n    /* 0xb0 */\n    notdef, \"endash\", \"dagger\", \"daggerdbl\", \"periodcentered\", notdef,\n    \"paragraph\", \"bullet\", \"quotesinglbase\", \"quotedblbase\",\n    \"quotedblright\", \"guillemotright\", \"ellipsis\", \"perthousand\", notdef,\n    \"questiondown\",\n    /* 0xc0 */\n    notdef, \"grave\", \"acute\", \"circumflex\", \"tilde\", \"macron\", \"breve\",\n    \"dotaccent\", \"dieresis\", notdef,\n    \"ring\", \"cedilla\", notdef, \"hungarumlaut\", \"ogonek\", \"caron\",\n    /* 0xd0 */\n    \"emdash\", notdef, notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    notdef, notdef, notdef, notdef, notdef, notdef, notdef,\n    /* 0xe0 */\n    notdef, \"AE\", notdef, \"ordfeminine\", notdef, notdef, notdef, notdef,\n    \"Lslash\", \"Oslash\", \"OE\", \"ordmasculine\", notdef, notdef, notdef,\n    notdef,\n    /* 0xf0 */\n    notdef, \"ae\", notdef, notdef, notdef, \"dotlessi\", notdef, notdef, \"lslash\",\n    \"oslash\", \"oe\", \"germandbls\", notdef, notdef, notdef, notdef\n};\n\ninteger t1_length1, t1_length2, t1_length3;\nstatic integer t1_save_offset;\nstatic integer t1_fontname_offset;\nstatic fd_entry *fd_cur;\n\nstatic char charstringname[] = \"/CharStrings\";\n\nenum { ENC_STANDARD, ENC_BUILTIN } t1_encoding;\n\n#define T1_BUF_SIZE      0x10\n#define ENC_BUF_SIZE     0x1000\n\n#define CS_HSTEM         1\n#define CS_VSTEM         3\n#define CS_VMOVETO       4\n#define CS_RLINETO       5\n#define CS_HLINETO       6\n#define CS_VLINETO       7\n#define CS_RRCURVETO     8\n#define CS_CLOSEPATH     9\n#define CS_CALLSUBR      10\n#define CS_RETURN        11\n#define CS_ESCAPE        12\n#define CS_HSBW          13\n#define CS_ENDCHAR       14\n#define CS_RMOVETO       21\n#define CS_HMOVETO       22\n#define CS_VHCURVETO     30\n#define CS_HVCURVETO     31\n#define CS_1BYTE_MAX     (CS_HVCURVETO + 1)\n\n#define CS_DOTSECTION    CS_1BYTE_MAX + 0\n#define CS_VSTEM3        CS_1BYTE_MAX + 1\n#define CS_HSTEM3        CS_1BYTE_MAX + 2\n#define CS_SEAC          CS_1BYTE_MAX + 6\n#define CS_SBW           CS_1BYTE_MAX + 7\n#define CS_DIV           CS_1BYTE_MAX + 12\n#define CS_CALLOTHERSUBR CS_1BYTE_MAX + 16\n#define CS_POP           CS_1BYTE_MAX + 17\n#define CS_SETCURRENTPOINT CS_1BYTE_MAX + 33\n#define CS_2BYTE_MAX     (CS_SETCURRENTPOINT + 1)\n#define CS_MAX           CS_2BYTE_MAX\n\ntypedef unsigned char byte;\n\ntypedef struct {\n    byte nargs;                 /* number of arguments */\n    boolean bottom;             /* take arguments from bottom of stack? */\n    boolean clear;              /* clear stack? */\n    boolean valid;\n} cc_entry;                     /* CharString Command */\n\ntypedef struct {\n    char *name;                 /* glyph name (or notdef for Subrs entry) */\n    byte *data;\n    unsigned short len;         /* length of the whole string */\n    unsigned short cslen;       /* length of the encoded part of the string */\n    boolean used;\n    boolean valid;\n} cs_entry;\n\nstatic unsigned short t1_dr, t1_er;\nstatic const unsigned short t1_c1 = 52845, t1_c2 = 22719;\nstatic unsigned short t1_cslen;\nstatic short t1_lenIV;\nstatic char enc_line[ENC_BUF_SIZE];\n\n/* define t1_line_ptr, t1_line_array & t1_line_limit */\ntypedef char t1_line_entry;\ndefine_array(t1_line);\n\n/* define t1_buf_ptr, t1_buf_array & t1_buf_limit */\ntypedef char t1_buf_entry;\ndefine_array(t1_buf);\n\nstatic int cs_start;\n\nstatic cs_entry *cs_tab, *cs_ptr, *cs_notdef;\nstatic char *cs_dict_start, *cs_dict_end;\nstatic int cs_count, cs_size, cs_size_pos;\n\nstatic cs_entry *subr_tab;\nstatic char *subr_array_start, *subr_array_end;\nstatic int subr_max, subr_size, subr_size_pos;\n\n/* This list contains the begin/end tokens commonly used in the */\n/* /Subrs array of a Type 1 font.                               */\n\nstatic const char *cs_token_pairs_list[][2] = {\n    {\" RD\", \"NP\"},\n    {\" -|\", \"|\"},\n    {\" RD\", \"noaccess put\"},\n    {\" -|\", \"noaccess put\"},\n    {NULL, NULL}\n};\nstatic const char **cs_token_pair;\n\nstatic boolean t1_pfa, t1_cs, t1_scan, t1_eexec_encrypt, t1_synthetic;\nstatic int t1_in_eexec;         /* 0 before eexec-encrypted, 1 during, 2 after */\nstatic long t1_block_length;\nstatic int last_hexbyte;\nstatic FILE *t1_file;\nstatic FILE *enc_file;\n\nstatic void enc_getline(void)\n{\n    char *p;\n    int c;\n  restart:\n    if (enc_eof())\n        pdftex_fail(\"unexpected end of file\");\n    p = enc_line;\n    do {\n        c = enc_getchar();\n        append_char_to_buf(c, p, enc_line, ENC_BUF_SIZE);\n    } while (c != 10);\n    append_eol(p, enc_line, ENC_BUF_SIZE);\n    if (p - enc_line < 2 || *enc_line == '%')\n        goto restart;\n}\n\n/* read encoding from .enc file, return glyph_names array, or pdffail() */\n\nchar **load_enc_file(char *enc_name)\n{\n    char buf[ENC_BUF_SIZE], *p, *r;\n    int i, names_count;\n    char **glyph_names;\n    set_cur_file_name(enc_name);\n    if (!enc_open()) {\n        pdftex_fail(\"cannot open encoding file for reading\");\n    }\n    glyph_names = xtalloc(256, char *);\n    for (i = 0; i < 256; i++)\n        glyph_names[i] = notdef;\n    t1_log(\"{\");\n    t1_log(cur_file_name = (char *) nameoffile + 1);\n    enc_getline();\n    if (*enc_line != '/' || (r = strchr(enc_line, '[')) == NULL) {\n        remove_eol(r, enc_line);\n        pdftex_fail\n           (\"invalid encoding vector (a name or `[' missing): `%s'\", enc_line);\n    }\n    names_count = 0;\n    r++;                        /* skip '[' */\n    skip(r, ' ');\n    for (;;) {\n        while (*r == '/') {\n            for (p = buf, r++;\n                 *r != ' ' && *r != 10 && *r != ']' && *r != '/'; *p++ = *r++);\n            *p = 0;\n            skip(r, ' ');\n            if (names_count > 255)\n                pdftex_fail(\"encoding vector contains more than 256 names\");\n            if (strcmp(buf, notdef) != 0)\n                glyph_names[names_count] = xstrdup(buf);\n            names_count++;\n        }\n        if (*r != 10 && *r != '%') {\n            if (str_prefix(r, \"] def\"))\n                goto done;\n            else {\n                remove_eol(r, enc_line);\n                pdftex_fail\n       (\"invalid encoding vector: a name or `] def' expected: `%s'\", enc_line);\n            }\n        }\n        enc_getline();\n        r = enc_line;\n    }\n  done:\n    enc_close();\n    t1_log(\"}\");\n    cur_file_name = NULL;\n    return glyph_names;\n}\n\nstatic void t1_check_pfa(void)\n{\n    const int c = t1_getchar();\n    t1_pfa = (c != 128) ? true : false;\n    t1_ungetchar(c);\n}\n\nstatic int t1_getbyte(void)\n{\n    int c = t1_getchar();\n    if (t1_pfa)\n        return c;\n    if (t1_block_length == 0) {\n        if (c != 128)\n            pdftex_fail(\"invalid marker\");\n        c = t1_getchar();\n        if (c == 3) {\n            while (!t1_eof())\n                t1_getchar();\n            return EOF;\n        }\n        t1_block_length = t1_getchar() & 0xff;\n        t1_block_length |= (t1_getchar() & 0xff) << 8;\n        t1_block_length |= (t1_getchar() & 0xff) << 16;\n        t1_block_length |= (t1_getchar() & 0xff) << 24;\n        c = t1_getchar();\n    }\n    t1_block_length--;\n    return c;\n}\n\nstatic int hexval(int c)\n{\n    if (c >= 'A' && c <= 'F')\n        return c - 'A' + 10;\n    else if (c >= 'a' && c <= 'f')\n        return c - 'a' + 10;\n    else if (c >= '0' && c <= '9')\n        return c - '0';\n    else\n        return -1;\n}\n\nstatic byte edecrypt(byte cipher)\n{\n    byte plain;\n    if (t1_pfa) {\n        while (cipher == 10 || cipher == 13)\n            cipher = t1_getbyte();\n        last_hexbyte = cipher = (hexval(cipher) << 4) + hexval(t1_getbyte());\n    }\n    plain = (cipher ^ (t1_dr >> 8));\n    t1_dr = (cipher + t1_dr) * t1_c1 + t1_c2;\n    return plain;\n}\n\nstatic byte cdecrypt(byte cipher, unsigned short *cr)\n{\n    const byte plain = (cipher ^ (*cr >> 8));\n    *cr = (cipher + *cr) * t1_c1 + t1_c2;\n    return plain;\n}\n\nstatic byte eencrypt(byte plain)\n{\n    const byte cipher = (plain ^ (t1_er >> 8));\n    t1_er = (cipher + t1_er) * t1_c1 + t1_c2;\n    return cipher;\n}\n\nstatic byte cencrypt(byte plain, unsigned short *cr)\n{\n    const byte cipher = (plain ^ (*cr >> 8));\n    *cr = (cipher + *cr) * t1_c1 + t1_c2;\n    return cipher;\n}\n\nstatic char *eol(char *s)\n{\n    char *p = strend(s);\n    if (p - s > 1 && p[-1] != 10) {\n        *p++ = 10;\n        *p = 0;\n    }\n    return p;\n}\n\nstatic float t1_scan_num(char *p, char **r)\n{\n    float f;\n    skip(p, ' ');\n    if (sscanf(p, \"%g\", &f) != 1) {\n        remove_eol(p, t1_line_array);\n        pdftex_fail(\"a number expected: `%s'\", t1_line_array);\n    }\n    if (r != NULL) {\n        for (; isdigit((unsigned char)*p) || *p == '.' ||\n             *p == 'e' || *p == 'E' || *p == '+' || *p == '-'; p++);\n        *r = p;\n    }\n    return f;\n}\n\nstatic boolean str_suffix(const char *begin_buf, const char *end_buf,\n                          const char *s)\n{\n    const char *s1 = end_buf - 1, *s2 = strend(s) - 1;\n    if (*s1 == 10)\n        s1--;\n    while (s1 >= begin_buf && s2 >= s) {\n        if (*s1-- != *s2--)\n            return false;\n    }\n    return s2 < s;\n}\n\nstatic void t1_getline(void)\n{\n    int c, l, eexec_scan;\n    char *p;\n    static const char eexec_str[] = \"currentfile eexec\";\n    static int eexec_len = 17;  /* strlen(eexec_str) */\n  restart:\n    if (t1_eof())\n        pdftex_fail(\"unexpected end of file\");\n    t1_line_ptr = t1_line_array;\n    alloc_array(t1_line, 1, T1_BUF_SIZE);\n    t1_cslen = 0;\n    eexec_scan = 0;\n    c = t1_getbyte();\n    if (c == EOF)\n        goto exit;\n    while (!t1_eof()) {\n        if (t1_in_eexec == 1)\n            c = edecrypt((byte)c);\n        alloc_array(t1_line, 1, T1_BUF_SIZE);\n        append_char_to_buf(c, t1_line_ptr, t1_line_array, t1_line_limit);\n        if (t1_in_eexec == 0 && eexec_scan >= 0 && eexec_scan < eexec_len) {\n            if (t1_line_array[eexec_scan] == eexec_str[eexec_scan])\n                eexec_scan++;\n            else\n                eexec_scan = -1;\n        }\n        if (c == 10 || (t1_pfa && eexec_scan == eexec_len && c == 32))\n            break;\n        if (t1_cs && t1_cslen == 0 && (t1_line_ptr - t1_line_array > 4) &&\n            (t1_suffix(\" RD \") || t1_suffix(\" -| \"))) {\n            p = t1_line_ptr - 5;\n            while (*p != ' ')\n                p--;\n            t1_cslen = l = t1_scan_num(p + 1, 0);\n            cs_start = t1_line_ptr - t1_line_array;     /* cs_start is an index now */\n            alloc_array(t1_line, l, T1_BUF_SIZE);\n            while (l-- > 0)\n                *t1_line_ptr++ = edecrypt((byte)t1_getbyte());\n        }\n        c = t1_getbyte();\n    }\n    alloc_array(t1_line, 2, T1_BUF_SIZE);       /* append_eol can append 2 chars */\n    append_eol(t1_line_ptr, t1_line_array, t1_line_limit);\n    if (t1_line_ptr - t1_line_array < 2)\n        goto restart;\n    if (eexec_scan == eexec_len)\n        t1_in_eexec = 1;\n  exit:\n    /* ensure that t1_buf_array has as much room as t1_line_array */\n    t1_buf_ptr = t1_buf_array;\n    alloc_array(t1_buf, t1_line_limit, t1_line_limit);\n}\n\nstatic void t1_putline(void)\n{\n    char *p = t1_line_array;\n    if (t1_line_ptr - t1_line_array <= 1)\n        return;\n    if (t1_eexec_encrypt) {\n        while (p < t1_line_ptr)\n            t1_putchar(eencrypt(*p++));\n    } else\n        while (p < t1_line_ptr)\n            t1_putchar(*p++);\n}\n\nstatic void t1_puts(const char *s)\n{\n    if (s != t1_line_array)\n        strcpy(t1_line_array, s);\n    t1_line_ptr = strend(t1_line_array);\n    t1_putline();\n}\n\n__attribute__ ((format(printf, 1, 2)))\nstatic void t1_printf(const char *fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    vsprintf(t1_line_array, fmt, args);\n    t1_puts(t1_line_array);\n    va_end(args);\n}\n\nstatic void t1_init_params(const char *open_name_prefix)\n{\n    t1_log(open_name_prefix);\n    t1_log(cur_file_name);\n    t1_lenIV = 4;\n    t1_dr = 55665;\n    t1_er = 55665;\n    t1_in_eexec = 0;\n    t1_cs = false;\n    t1_scan = true;\n    t1_synthetic = false;\n    t1_eexec_encrypt = false;\n    t1_block_length = 0;\n    t1_check_pfa();\n}\n\nstatic void t1_close_font_file(const char *close_name_suffix)\n{\n    t1_log(close_name_suffix);\n    t1_close();\n    cur_file_name = NULL;\n}\n\nstatic void t1_check_block_len(boolean decrypt)\n{\n    int l, c;\n    if (t1_block_length == 0)\n        return;\n    c = t1_getbyte();\n    if (decrypt)\n        c = edecrypt((byte)c);\n    l = t1_block_length;\n    if (!(l == 0 && (c == 10 || c == 13))) {\n        pdftex_fail(\"%i bytes more than expected\", l + 1);\n    }\n}\n\nstatic void t1_start_eexec(void)\n{\n    int i;\n    assert(is_included(fd_cur->fm));\n    get_length1();\n    save_offset();\n    if (!t1_pfa)\n        t1_check_block_len(false);\n    for (t1_line_ptr = t1_line_array, i = 0; i < 4; i++) {\n        edecrypt((byte)t1_getbyte());\n        *t1_line_ptr++ = 0;\n    }\n    t1_eexec_encrypt = true;\n    t1_putline();               /* to put the first four bytes */\n}\n\nstatic void t1_stop_eexec(void)\n{\n    int c;\n    assert(is_included(fd_cur->fm));\n    get_length2();\n    save_offset();\n    t1_eexec_encrypt = false;\n    if (!t1_pfa)\n        t1_check_block_len(true);\n    else {\n        c = edecrypt((byte)t1_getbyte());\n        if (!(c == 10 || c == 13)) {\n            if (last_hexbyte == 0)\n                t1_puts(\"00\");\n            else\n                pdftex_fail(\"unexpected data after eexec\");\n        }\n    }\n    t1_cs = false;\n    t1_in_eexec = 2;\n}\n\n/* macros for various transforms; currently only slant and extend are used */\n\n#define do_xshift(x,a) {x[4]+=a;}\n#define do_yshift(x,a) {x[5]+=a;}\n#define do_xscale(x,a) {x[0]*=a; x[2]*=a; x[4]*=a;}\n#define do_yscale(x,a) {x[1]*=a; x[3]*=a; x[5]*=a;}\n#define do_extend(x,a) {do_xscale(x,a);}\n#define do_scale(x,a)  {do_xscale(x,a); do_yscale(x,a);}\n#define do_slant(x,a)  {x[0]+=x[1]*(a); x[2]+=x[3]*(a); x[4]+=x[5]*(a);}\n#define do_shear(x,a)  {x[1]+=x[0]*(a); x[3]+=x[2]*(a); x[5]+=x[4]*(a);}\n#define do_rotate(x,a)          \\\n  {float t, u=cos(a), v=sin(a); \\\n  t    =x[0]*u+x[1]*-v;         \\\n  x[1] =x[0]*v+x[1]* u; x[0]=t; \\\n  t    =x[2]*u+x[3]*-v;         \\\n  x[3] =x[2]*v+x[3]* u; x[2]=t; \\\n  t    =x[4]*u+x[5]*-v;         \\\n  x[5] =x[4]*v+x[5]* u; x[4]=t;}\n\nstatic void t1_modify_fm(void)\n{\n    /*\n     * font matrix is given as six numbers a0..a5, which stands for the matrix\n     *\n     *           a0 a1 0\n     *     M =   a2 a3 0\n     *           a4 a5 1\n     *\n     * ExtendFont is given as\n     *\n     *           e 0 0\n     *     E =   0 1 0\n     *           0 0 1\n     *\n     * SlantFont is given as\n     *\n     *           1 0 0\n     *     S =   s 1 0\n     *           0 0 1\n     *\n     * The slant transform must be done _before_ the extend transform\n     * for compatibility!\n     */\n    float a[6];\n    int i, c;\n    char *p, *q, *r;\n    if ((p = strchr(t1_line_array, '[')) == 0)\n        if ((p = strchr(t1_line_array, '{')) == 0) {\n            remove_eol(p, t1_line_array);\n            pdftex_fail(\"FontMatrix: an array expected: `%s'\", t1_line_array);\n        }\n    c = *p++;                   /* save the character '[' resp. '{' */\n    strncpy(t1_buf_array, t1_line_array, (size_t) (p - t1_line_array));\n    r = t1_buf_array + (p - t1_line_array);\n    for (i = 0; i < 6; i++) {\n        a[i] = t1_scan_num(p, &q);\n        p = q;\n    }\n    if (fm_slant(fd_cur->fm) != 0)\n        do_slant(a, fm_slant(fd_cur->fm) * 1E-3);\n    if (fm_extend(fd_cur->fm) != 0)\n        do_extend(a, fm_extend(fd_cur->fm) * 1E-3);\n    for (i = 0; i < 6; i++) {\n        sprintf(r, \"%g \", a[i]);\n        r = strend(r);\n    }\n    if (c == '[') {\n        while (*p != ']' && *p != 0)\n            p++;\n    } else {\n        while (*p != '}' && *p != 0)\n            p++;\n    }\n    if (*p == 0) {\n        remove_eol(p, t1_line_array);\n        pdftex_fail\n            (\"FontMatrix: cannot find the corresponding character to '%c': `%s'\",\n             c, t1_line_array);\n    }\n    strcpy(r, p);\n    strcpy(t1_line_array, t1_buf_array);\n    t1_line_ptr = eol(t1_line_array);\n}\n\nstatic void t1_modify_italic(void)\n{\n    float a;\n    char *p, *r;\n    if (fm_slant(fd_cur->fm) == 0)\n        return;\n    p = strchr(t1_line_array, ' ');\n    strncpy(t1_buf_array, t1_line_array, (size_t) (p - t1_line_array + 1));\n    a = t1_scan_num(p + 1, &r);\n    a -= atan(fm_slant(fd_cur->fm) * 1E-3) * (180 / M_PI);\n    sprintf(t1_buf_array + (p - t1_line_array + 1), \"%g\", a);\n    strcpy(strend(t1_buf_array), r);\n    strcpy(t1_line_array, t1_buf_array);\n    t1_line_ptr = eol(t1_line_array);\n    fd_cur->font_dim[ITALIC_ANGLE_CODE].val = round(a);\n    fd_cur->font_dim[ITALIC_ANGLE_CODE].set = true;\n}\n\nstatic void t1_scan_keys(void)\n{\n    int i, k;\n    char *p, *q, *r;\n    const key_entry *key;\n    if (fm_extend(fd_cur->fm) != 0 || fm_slant(fd_cur->fm) != 0) {\n        if (t1_prefix(\"/FontMatrix\")) {\n            t1_modify_fm();\n            return;\n        }\n        if (t1_prefix(\"/ItalicAngle\")) {\n            t1_modify_italic();\n            return;\n        }\n    }\n    if (t1_prefix(\"/FontType\")) {\n        p = t1_line_array + strlen(\"FontType\") + 1;\n        if ((i = t1_scan_num(p, 0)) != 1)\n            pdftex_fail(\"Type%d fonts unsupported by pdfTeX\", i);\n        return;\n    }\n    for (key = font_key; key - font_key < FONT_KEYS_NUM; key++) {\n        if (key->t1name[0] != '\\0' &&\n            str_prefix(t1_line_array + 1, key->t1name))\n            break;\n    }\n    if (key - font_key == FONT_KEYS_NUM)\n        return;\n    p = t1_line_array + strlen(key->t1name) + 1;\n    skip(p, ' ');\n    if ((k = key - font_key) == FONTNAME_CODE) {\n        if (*p != '/') {\n            remove_eol(p, t1_line_array);\n            pdftex_fail(\"a name expected: `%s'\", t1_line_array);\n        }\n        r = ++p;                /* skip the slash */\n        for (q = t1_buf_array; *p != ' ' && *p != 10; *q++ = *p++);\n        *q = 0;\n        if (fm_slant(fd_cur->fm) != 0) {\n            sprintf(q, \"-Slant_%i\", (int) fm_slant(fd_cur->fm));\n            q = strend(q);\n        }\n        if (fm_extend(fd_cur->fm) != 0) {\n            sprintf(q, \"-Extend_%i\", (int) fm_extend(fd_cur->fm));\n        }\n        xfree(fd_cur->fontname);\n        fd_cur->fontname = xstrdup(t1_buf_array);\n        /* at this moment we cannot call make_subset_tag() yet, as the encoding\n         * is not read; thus we mark the offset of the subset tag and write it\n         * later */\n        if (is_subsetted(fd_cur->fm)) {\n            assert(is_included(fd_cur->fm));\n            t1_fontname_offset = t1_offset() + (r - t1_line_array);\n            strcpy(t1_buf_array, p);\n            sprintf(r, \"ABCDEF+%s%s\", fd_cur->fontname, t1_buf_array);\n            t1_line_ptr = eol(r);\n        }\n        return;\n    }\n    if ((k == STEMV_CODE || k == FONTBBOX1_CODE)\n        && (*p == '[' || *p == '{'))\n        p++;\n    if (k == FONTBBOX1_CODE) {\n        for (i = 0; i < 4; i++, k++) {\n            fd_cur->font_dim[k].val = t1_scan_num(p, &r);\n            fd_cur->font_dim[k].set = true;\n            p = r;\n        }\n        return;\n    }\n    fd_cur->font_dim[k].val = t1_scan_num(p, 0);\n    fd_cur->font_dim[k].set = true;\n}\n\nstatic void t1_scan_param(void)\n{\n    static const char *lenIV = \"/lenIV\";\n    if (!t1_scan || *t1_line_array != '/')\n        return;\n    if (t1_prefix(lenIV)) {\n        t1_lenIV = t1_scan_num(t1_line_array + strlen(lenIV), 0);\n        if (t1_lenIV < 0)\n            pdftex_fail(\"negative value of lenIV is not supported\");\n        return;\n    }\n    t1_scan_keys();\n}\n\nstatic void copy_glyph_names(char **glyph_names, int a, int b)\n{\n    if (glyph_names[b] != notdef) {\n        xfree(glyph_names[b]);\n        glyph_names[b] = notdef;\n    }\n    if (glyph_names[a] != notdef) {\n        glyph_names[b] = xstrdup(glyph_names[a]);\n    }\n}\n\n/* read encoding from Type1 font file, return glyph_names array, or pdffail() */\n\nstatic char **t1_builtin_enc(void)\n{\n    int i, a, b, c, counter = 0;\n    char *r, *p, **glyph_names;\n    /* At this moment \"/Encoding\" is the prefix of t1_line_array */\n    glyph_names = xtalloc(256, char *);\n    for (i = 0; i < 256; i++)\n        glyph_names[i] = notdef;\n    if (t1_suffix(\"def\")) {     /* predefined encoding */\n        if (sscanf(t1_line_array + strlen(\"/Encoding\"), \"%255s\", t1_buf_array) == 1\n            && strcmp(t1_buf_array, \"StandardEncoding\") == 0) {\n            t1_encoding = ENC_STANDARD;\n            for (i = 0; i < 256; i++) {\n                if (standard_glyph_names[i] != notdef)\n                    glyph_names[i] = xstrdup(standard_glyph_names[i]);\n            }\n            return glyph_names;\n        }\n        pdftex_fail(\"cannot subset font (unknown predefined encoding `%s')\",\n                    t1_buf_array);\n    }\n    /* At this moment \"/Encoding\" is the prefix of t1_line_array, and the encoding is\n     * not a predefined encoding.\n     *\n     * We have two possible forms of Encoding vector. The first case is\n     *\n     *     /Encoding [/a /b /c...] readonly def\n     *\n     * and the second case can look like\n     *\n     *     /Encoding 256 array 0 1 255 {1 index exch /.notdef put} for\n     *     dup 0 /x put\n     *     dup 1 /y put\n     *     ...\n     *     readonly def\n     */\n    t1_encoding = ENC_BUILTIN;\n    if (t1_prefix(\"/Encoding [\") || t1_prefix(\"/Encoding[\")) {  /* the first case */\n        r = strchr(t1_line_array, '[') + 1;\n        skip(r, ' ');\n        for (;;) {\n            while (*r == '/') {\n                for (p = t1_buf_array, r++;\n                     *r != 32 && *r != 10 && *r != ']' && *r != '/';\n                     *p++ = *r++);\n                *p = 0;\n                skip(r, ' ');\n                if (counter > 255)\n                    pdftex_fail(\"encoding vector contains more than 256 names\");\n                if (strcmp(t1_buf_array, notdef) != 0)\n                    glyph_names[counter] = xstrdup(t1_buf_array);\n                counter++;\n            }\n            if (*r != 10 && *r != '%') {\n                if (str_prefix(r, \"] def\") || str_prefix(r, \"] readonly def\"))\n                    break;\n                else {\n                    remove_eol(r, t1_line_array);\n                    pdftex_fail\n       (\"a name or `] def' or `] readonly def' expected: `%s'\", t1_line_array);\n                }\n            }\n            t1_getline();\n            r = t1_line_array;\n        }\n    } else {                    /* the second case */\n        p = strchr(t1_line_array, 10);\n        for (;;) {\n            if (*p == 10) {\n                t1_getline();\n                p = t1_line_array;\n            }\n            /*\n               check for `dup <index> <glyph> put'\n             */\n            if (sscanf(p, \"dup %i%255s put\", &i, t1_buf_array) == 2 &&\n                *t1_buf_array == '/' && valid_code(i)) {\n                if (strcmp(t1_buf_array + 1, notdef) != 0)\n                    glyph_names[i] = xstrdup(t1_buf_array + 1);\n                p = strstr(p, \" put\") + strlen(\" put\");\n                skip(p, ' ');\n            }\n            /*\n               check for `dup dup <to> exch <from> get put'\n             */\n            else if (sscanf(p, \"dup dup %i exch %i get put\", &b, &a) == 2\n                     && valid_code(a) && valid_code(b)) {\n                copy_glyph_names(glyph_names, a, b);\n                p = strstr(p, \" get put\") + strlen(\" get put\");\n                skip(p, ' ');\n            }\n            /*\n               check for `dup dup <from> <size> getinterval <to> exch putinterval'\n             */\n            else if (sscanf(p, \"dup dup %i %i getinterval %i exch putinterval\",\n                            &a, &c, &b) == 3\n                     && valid_code(a) && valid_code(b) && valid_code(c)) {\n                for (i = 0; i < c; i++)\n                    copy_glyph_names(glyph_names, a + i, b + i);\n                p = strstr(p, \" putinterval\") + strlen(\" putinterval\");\n                skip(p, ' ');\n            }\n            /*\n               check for `def' or `readonly def'\n             */\n            else if ((p == t1_line_array || (p > t1_line_array && p[-1] == ' '))\n                     && strcmp(p, \"def\\n\") == 0)\n                return glyph_names;\n            /*\n               skip an unrecognizable word\n             */\n            else {\n                while (*p != ' ' && *p != 10)\n                    p++;\n                skip(p, ' ');\n            }\n        }\n    }\n    return glyph_names;\n}\n\nstatic void t1_check_end(void)\n{\n    if (t1_eof())\n        return;\n    t1_getline();\n    if (t1_prefix(\"{restore}\"))\n        t1_putline();\n}\n\nstatic boolean t1_open_fontfile(const char *open_name_prefix)\n{\n    ff_entry *ff;\n    ff = check_ff_exist(fd_cur->fm->ff_name, is_truetype(fd_cur->fm));\n    if (ff->ff_path != NULL) {\n        t1_file = xfopen(cur_file_name = ff->ff_path, FOPEN_RBIN_MODE);\n        recorder_record_input(ff->ff_path);\n    } else {\n        set_cur_file_name(fd_cur->fm->ff_name);\n        pdftex_fail(\"cannot open Type 1 font file for reading\");\n    }\n    t1_init_params(open_name_prefix);\n    return true;                /* font file found */\n}\n\nstatic void t1_include(void)\n{\n    do {\n        t1_getline();\n        t1_scan_param();\n        t1_putline();\n    } while (t1_in_eexec == 0);\n    t1_start_eexec();\n    do {\n        t1_getline();\n        t1_scan_param();\n        t1_putline();\n    } while (!(t1_charstrings() || t1_subrs()));\n    t1_cs = true;\n    do {\n        t1_getline();\n        t1_putline();\n    } while (!t1_end_eexec());\n    t1_stop_eexec();\n    if (fixedcontent) {         /* copy 512 zeros (not needed for PDF) */\n        do {\n            t1_getline();\n            t1_putline();\n        } while (!t1_cleartomark());\n        t1_check_end();         /* write \"{restore}if\" if found */\n    }\n    get_length3();\n}\n\n#define check_subr(subr) \\\n    if (subr >= subr_size || subr < 0) \\\n        pdftex_fail(\"Subrs array: entry index out of range (%i)\",  subr);\n\nstatic const char **check_cs_token_pair(void)\n{\n    const char **p = (const char **) cs_token_pairs_list;\n    for (; p[0] != NULL; ++p)\n        if (t1_buf_prefix(p[0]) && t1_buf_suffix(p[1]))\n            return p;\n    return NULL;\n}\n\nstatic void cs_store(boolean is_subr)\n{\n    char *p;\n    cs_entry *ptr;\n    int subr;\n    for (p = t1_line_array, t1_buf_ptr = t1_buf_array; *p != ' ';\n         *t1_buf_ptr++ = *p++);\n    *t1_buf_ptr = 0;\n    if (is_subr) {\n        subr = t1_scan_num(p + 1, 0);\n        check_subr(subr);\n        ptr = subr_tab + subr;\n    } else {\n        ptr = cs_ptr++;\n        if (cs_ptr - cs_tab > cs_size)\n            pdftex_fail\n                (\"CharStrings dict: more entries than dict size (%i)\", cs_size);\n        if (strcmp(t1_buf_array + 1, notdef) == 0)      /* skip the slash */\n            ptr->name = notdef;\n        else\n            ptr->name = xstrdup(t1_buf_array + 1);\n    }\n    /* copy \" RD \" + cs data to t1_buf_array */\n    memcpy(t1_buf_array, t1_line_array + cs_start - 4,\n           (unsigned) (t1_cslen + 4));\n    /* copy the end of cs data to t1_buf_array */\n    for (p = t1_line_array + cs_start + t1_cslen,\n           t1_buf_ptr = t1_buf_array + t1_cslen + 4;\n         *p != 10; *t1_buf_ptr++ = *p++);\n    *t1_buf_ptr++ = 10;\n    if (is_subr && cs_token_pair == NULL)\n        cs_token_pair = check_cs_token_pair();\n    ptr->len = t1_buf_ptr - t1_buf_array;\n    ptr->cslen = t1_cslen;\n    ptr->data = xtalloc(ptr->len, byte);\n    memcpy(ptr->data, t1_buf_array, ptr->len);\n    ptr->valid = true;\n}\n\n#define store_subr()     cs_store(true)\n#define store_cs()       cs_store(false)\n\n#define CC_STACK_SIZE    24\n\nstatic integer cc_stack[CC_STACK_SIZE], *stack_ptr = cc_stack;\nstatic cc_entry cc_tab[CS_MAX];\nstatic boolean is_cc_init = false;\n\n#define cc_pop(N)                   \\\n    if (stack_ptr - cc_stack < (N)) \\\n        stack_error(N);             \\\n    stack_ptr -= N\n\n#define stack_error(N) {            \\\n    pdftex_fail(\"CharString: invalid access (%i) to stack (%i entries)\", \\\n                (int) N, (int)(stack_ptr - cc_stack));                  \\\n    goto cs_error;                  \\\n}\n\n/*\nstatic integer cc_get(integer index)\n{\n    if (index <  0) {\n        if (stack_ptr + index < cc_stack )\n            stack_error(stack_ptr - cc_stack + index);\n        return *(stack_ptr + index);\n    }\n    else {\n        if (cc_stack  + index >= stack_ptr)\n            stack_error(index);\n        return cc_stack[index];\n    }\n}\n*/\n\n#define cc_get(N)   ((N) < 0 ? *(stack_ptr + (N)) : *(cc_stack + (N)))\n#define cc_push(V)  *stack_ptr++ = V\n#define cc_clear()  stack_ptr = cc_stack\n#define set_cc(N, B, A, C) \\\n    cc_tab[N].nargs = A;   \\\n    cc_tab[N].bottom = B;  \\\n    cc_tab[N].clear = C;   \\\n    cc_tab[N].valid = true\n\nstatic void cc_init(void)\n{\n    int i;\n    if (is_cc_init)\n        return;\n    for (i = 0; i < CS_MAX; i++)\n        cc_tab[i].valid = false;\n    set_cc(CS_HSTEM, true, 2, true);\n    set_cc(CS_VSTEM, true, 2, true);\n    set_cc(CS_VMOVETO, true, 1, true);\n    set_cc(CS_RLINETO, true, 2, true);\n    set_cc(CS_HLINETO, true, 1, true);\n    set_cc(CS_VLINETO, true, 1, true);\n    set_cc(CS_RRCURVETO, true, 6, true);\n    set_cc(CS_CLOSEPATH, false, 0, true);\n    set_cc(CS_CALLSUBR, false, 1, false);\n    set_cc(CS_RETURN, false, 0, false);\n    /*\n       set_cc(CS_ESCAPE, false, 0, false);\n     */\n    set_cc(CS_HSBW, true, 2, true);\n    set_cc(CS_ENDCHAR, false, 0, true);\n    set_cc(CS_RMOVETO, true, 2, true);\n    set_cc(CS_HMOVETO, true, 1, true);\n    set_cc(CS_VHCURVETO, true, 4, true);\n    set_cc(CS_HVCURVETO, true, 4, true);\n    set_cc(CS_DOTSECTION, false, 0, true);\n    set_cc(CS_VSTEM3, true, 6, true);\n    set_cc(CS_HSTEM3, true, 6, true);\n    set_cc(CS_SEAC, true, 5, true);\n    set_cc(CS_SBW, true, 4, true);\n    set_cc(CS_DIV, false, 2, false);\n    set_cc(CS_CALLOTHERSUBR, false, 0, false);\n    set_cc(CS_POP, false, 0, false);\n    set_cc(CS_SETCURRENTPOINT, true, 2, true);\n    is_cc_init = true;\n}\n\n#define cs_getchar()     cdecrypt(*data++, &cr)\n\n#define mark_subr(n)     cs_mark(0, n)\n#define mark_cs(s)       cs_mark(s, 0)\n\n__attribute__ ((format(printf, 3, 4)))\nstatic void cs_fail(const char *cs_name, int subr, const char *fmt, ...)\n{\n    char buf[SMALL_BUF_SIZE];\n    va_list args;\n    va_start(args, fmt);\n    vsprintf(buf, fmt, args);\n    va_end(args);\n    if (cs_name == NULL)\n        pdftex_fail(\"Subr (%i): %s\", (int) subr, buf);\n    else\n        pdftex_fail(\"CharString (/%s): %s\", cs_name, buf);\n}\n\n/* fix a return-less subr by appending CS_RETURN */\nstatic void append_cs_return(cs_entry *ptr)\n{\n    unsigned short cr;\n    int i;\n    byte *p, *q, *data, *new_data;\n    assert(ptr != NULL && ptr->valid && ptr->used);\n\n    /* decrypt the cs data to t1_buf_array, append CS_RETURN */\n    p = (byte *) t1_buf_array;\n    data = ptr->data + 4;\n    cr = 4330;\n    for (i = 0; i < ptr->cslen; i++)\n        *p++ = cs_getchar();\n    *p = CS_RETURN;\n\n    /* encrypt the new cs data to new_data */\n    new_data = xtalloc(ptr->len + 1, byte);\n    memcpy(new_data, ptr->data, 4);\n    p = new_data + 4;\n    q = (byte *) t1_buf_array;\n    cr = 4330;\n    for (i = 0; i < ptr->cslen + 1; i++)\n        *p++ = cencrypt(*q++, &cr);\n    memcpy(p, ptr->data + 4 + ptr->cslen, ptr->len - ptr->cslen - 4);\n\n    /* update *ptr */\n    xfree(ptr->data);\n    ptr->data = new_data;\n    ptr->len++;\n    ptr->cslen++;\n}\n\nstatic void cs_mark(const char *cs_name, int subr)\n{\n    byte *data;\n    int i, b, cs_len;\n    int last_cmd = 0;\n    integer a, a1, a2;\n    unsigned short cr;\n    static integer lastargOtherSubr3 = 3;       /* the argument of last call to\n                                                   OtherSubrs[3] */\n    cs_entry *ptr;\n    cc_entry *cc;\n    if (cs_name == NULL) {\n        check_subr(subr);\n        ptr = subr_tab + subr;\n        if (!ptr->valid)\n            return;\n    } else {\n        if (cs_notdef != NULL &&\n            (cs_name == notdef || strcmp(cs_name, notdef) == 0))\n            ptr = cs_notdef;\n        else {\n            for (ptr = cs_tab; ptr < cs_ptr; ptr++)\n                if (strcmp(ptr->name, cs_name) == 0)\n                    break;\n            if (ptr == cs_ptr) {\n                pdftex_warn(\"glyph `%s' undefined\", cs_name);\n                return;\n            }\n            if (ptr->name == notdef)\n                cs_notdef = ptr;\n        }\n    }\n    /* only marked CharString entries and invalid entries can be skipped;\n       valid marked subrs must be parsed to keep the stack in sync */\n    if (!ptr->valid || (ptr->used && cs_name != NULL))\n        return;\n    ptr->used = true;\n    cr = 4330;\n    cs_len = ptr->cslen;\n    data = ptr->data + 4;\n    for (i = 0; i < t1_lenIV; i++, cs_len--)\n        cs_getchar();\n    while (cs_len > 0) {\n        --cs_len;\n        b = cs_getchar();\n        if (b >= 32) {\n            if (b <= 246)\n                a = b - 139;\n            else if (b <= 250) {\n                --cs_len;\n                a = ((b - 247) << 8) + 108 + cs_getchar();\n            } else if (b <= 254) {\n                --cs_len;\n                a = -((b - 251) << 8) - 108 - cs_getchar();\n            } else {\n                cs_len -= 4;\n                a = (cs_getchar() & 0xff) << 24;\n                a |= (cs_getchar() & 0xff) << 16;\n                a |= (cs_getchar() & 0xff) << 8;\n                a |= (cs_getchar() & 0xff) << 0;\n                if (sizeof(integer) > 4 && (a & 0x80000000))\n                    a |= ~0x7FFFFFFF;\n            }\n            cc_push(a);\n        } else {\n            if (b == CS_ESCAPE) {\n                b = cs_getchar() + CS_1BYTE_MAX;\n                cs_len--;\n            }\n            if (b >= CS_MAX) {\n                cs_fail(cs_name, subr, \"command value out of range: %i\",\n                        (int) b);\n                goto cs_error;\n            }\n            cc = cc_tab + b;\n            if (!cc->valid) {\n                cs_fail(cs_name, subr, \"command not valid: %i\", (int) b);\n                goto cs_error;\n            }\n            if (cc->bottom) {\n                if (stack_ptr - cc_stack < cc->nargs)\n                    cs_fail(cs_name, subr,\n                            \"less arguments on stack (%i) than required (%i)\",\n                            (int) (stack_ptr - cc_stack), (int) cc->nargs);\n                else if (stack_ptr - cc_stack > cc->nargs)\n                    cs_fail(cs_name, subr,\n                            \"more arguments on stack (%i) than required (%i)\",\n                            (int) (stack_ptr - cc_stack), (int) cc->nargs);\n            }\n            last_cmd = b;\n            switch (cc - cc_tab) {\n            case CS_CALLSUBR:\n                a1 = cc_get(-1);\n                cc_pop(1);\n                mark_subr(a1);\n                if (!subr_tab[a1].valid) {\n                    cs_fail(cs_name, subr, \"cannot call subr (%i)\", (int) a1);\n                    goto cs_error;\n                }\n                break;\n            case CS_DIV:\n                cc_pop(2);\n                cc_push(0);\n                break;\n            case CS_CALLOTHERSUBR:\n                if (cc_get(-1) == 3)\n                    lastargOtherSubr3 = cc_get(-3);\n                a1 = cc_get(-2) + 2;\n                cc_pop(a1);\n                break;\n            case CS_POP:\n                cc_push(lastargOtherSubr3);\n                /* the only case when we care about the value being pushed onto\n                   stack is when POP follows CALLOTHERSUBR (changing hints by\n                   OtherSubrs[3])\n                 */\n                break;\n            case CS_SEAC:\n                a1 = cc_get(3);\n                a2 = cc_get(4);\n                cc_clear();\n                mark_cs(standard_glyph_names[a1]);\n                mark_cs(standard_glyph_names[a2]);\n                break;\n            default:\n                if (cc->clear)\n                    cc_clear();\n            }\n        }\n    }\n    if (cs_name == NULL && last_cmd != CS_RETURN) {\n        pdftex_warn(\"last command in subr `%i' is not a RETURN; \"\n                    \"I will add it now but please consider fixing the font\",\n                    (int) subr);\n        append_cs_return(ptr);\n    }\n    return;\n  cs_error:                    /* an error occured during parsing */\n    cc_clear();\n    ptr->valid = false;\n    ptr->used = false;\n}\n\n/**********************************************************************/\n/* AVL search tree for glyph code by glyph name */\n\nstatic int comp_t1_glyphs(const void *pa, const void *pb, void *p)\n{\n    return strcmp(*((const char * const *) pa), *((const char * const *) pb));\n}\n\nstatic struct avl_table *create_t1_glyph_tree(char **glyph_names)\n{\n    int i;\n    void **aa;\n    static struct avl_table *gl_tree;\n    gl_tree = avl_create(comp_t1_glyphs, NULL, &avl_xallocator);\n    assert(gl_tree != NULL);\n    for (i = 0; i < 256; i++) {\n        if (glyph_names[i] != notdef &&\n            (char **) avl_find(gl_tree, &glyph_names[i]) == NULL) {\n            /* no strdup here, just point to the glyph_names array members */\n            aa = avl_probe(gl_tree, &glyph_names[i]);\n            assert(aa != NULL);\n        }\n    }\n    return gl_tree;\n}\n\nstatic void destroy_t1_glyph_tree(struct avl_table *gl_tree)\n{\n    assert(gl_tree != NULL);\n    avl_destroy(gl_tree, NULL);\n}\n\n/**********************************************************************/\n\nstatic void t1_subset_ascii_part(void)\n{\n    int j, *p;\n    char *glyph, **gg, **glyph_names;\n    struct avl_table *gl_tree;\n    struct avl_traverser t;\n    void **aa;\n    assert(fd_cur != NULL);\n    assert(fd_cur->gl_tree != NULL);\n    t1_getline();\n    while (!t1_prefix(\"/Encoding\")) {\n        t1_scan_param();\n        if (!(t1_prefix(\"/UniqueID\")\n              && !strncmp(t1_line_array + strlen(t1_line_array) -4, \"def\", 3)))\n            t1_putline();\n        t1_getline();\n    }\n    glyph_names = t1_builtin_enc();\n    fd_cur->builtin_glyph_names = glyph_names;\n    if (is_subsetted(fd_cur->fm)) {\n        assert(is_included(fd_cur->fm));\n        if (fd_cur->tx_tree != NULL) {\n            /* take over collected non-reencoded characters from TeX */\n            avl_t_init(&t, fd_cur->tx_tree);\n            for (p = (int *) avl_t_first(&t, fd_cur->tx_tree); p != NULL;\n                 p = (int *) avl_t_next(&t)) {\n                if ((char *) avl_find(fd_cur->gl_tree, glyph_names[*p]) == NULL) {\n                    glyph = xstrdup(glyph_names[*p]);\n                    aa = avl_probe(fd_cur->gl_tree, glyph);\n                    assert(aa != NULL);\n                }\n            }\n        }\n        make_subset_tag(fd_cur);\n        assert(t1_fontname_offset != 0);\n        strncpy(fb_array + t1_fontname_offset, fd_cur->subset_tag, 6);\n    }\n    /* now really all glyphs needed from this font are in the fd_cur->gl_tree */\n    if (t1_encoding == ENC_STANDARD)\n        t1_puts(\"/Encoding StandardEncoding def\\n\");\n    else {\n        t1_puts\n            (\"/Encoding 256 array\\n0 1 255 {1 index exch /.notdef put} for\\n\");\n        gl_tree = create_t1_glyph_tree(glyph_names);\n        avl_t_init(&t, fd_cur->gl_tree);\n        j = 0;\n        for (glyph = (char *) avl_t_first(&t, fd_cur->gl_tree); glyph != NULL;\n             glyph = (char *) avl_t_next(&t)) {\n            if ((gg = (char **) avl_find(gl_tree, &glyph)) != NULL) {\n                t1_printf(\"dup %i /%s put\\n\", (int) (gg - glyph_names), *gg);\n                j++;\n            }\n        }\n        destroy_t1_glyph_tree(gl_tree);\n        if (j == 0)\n            /* We didn't mark anything for the Encoding array. */\n            /* We add \"dup 0 /.notdef put\" for compatibility   */\n            /* with Acrobat 5.0.                               */\n            t1_puts(\"dup 0 /.notdef put\\n\");\n        t1_puts(\"readonly def\\n\");\n    }\n    do {\n        t1_getline();\n        t1_scan_param();\n        if (!t1_prefix(\"/UniqueID\"))    /* ignore UniqueID for subsetted fonts */\n            t1_putline();\n    } while (t1_in_eexec == 0);\n}\n\nstatic void cs_init(void)\n{\n    cs_ptr = cs_tab = NULL;\n    cs_dict_start = cs_dict_end = NULL;\n    cs_count = cs_size = cs_size_pos = 0;\n    cs_token_pair = NULL;\n    subr_tab = NULL;\n    subr_array_start = subr_array_end = NULL;\n    subr_max = subr_size = subr_size_pos = 0;\n}\n\nstatic void init_cs_entry(cs_entry *cs)\n{\n    cs->data = NULL;\n    cs->name = NULL;\n    cs->len = 0;\n    cs->cslen = 0;\n    cs->used = false;\n    cs->valid = false;\n}\n\nstatic void t1_read_subrs(void)\n{\n    int i, s;\n    cs_entry *ptr;\n    t1_getline();\n    while (!(t1_charstrings() || t1_subrs())) {\n        t1_scan_param();\n        if (!t1_prefix(\"/UniqueID\"))    /* ignore UniqueID for subsetted fonts */\n            t1_putline();\n        t1_getline();\n    }\n  found:\n    t1_cs = true;\n    t1_scan = false;\n    if (!t1_subrs())\n        return;\n    subr_size_pos = strlen(\"/Subrs\") + 1;\n    /* subr_size_pos points to the number indicating dict size after \"/Subrs\" */\n    subr_size = t1_scan_num(t1_line_array + subr_size_pos, 0);\n    if (subr_size == 0) {\n        while (!t1_charstrings())\n            t1_getline();\n        return;\n    }\n    subr_tab = xtalloc(subr_size, cs_entry);\n    for (ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n        init_cs_entry(ptr);\n    subr_array_start = xstrdup(t1_line_array);\n    t1_getline();\n    while (t1_cslen) {\n        store_subr();\n        t1_getline();\n    }\n    /* mark the first four entries without parsing */\n    for (i = 0; i < subr_size && i < 4; i++)\n        subr_tab[i].used = true;\n    /* the end of the Subrs array might have more than one line so we need to\n       concatnate them to subr_array_end. Unfortunately some fonts don't have\n       the Subrs array followed by the CharStrings dict immediately (synthetic\n       fonts). If we cannot find CharStrings in next POST_SUBRS_SCAN lines then\n       we will treat the font as synthetic and ignore everything until next\n       Subrs is found\n     */\n\n#define POST_SUBRS_SCAN  5\n\n    s = 0;\n    *t1_buf_array = 0;\n    for (i = 0; i < POST_SUBRS_SCAN; i++) {\n        if (t1_charstrings())\n            break;\n        s += t1_line_ptr - t1_line_array;\n        alloc_array(t1_buf, s, T1_BUF_SIZE);\n        strcat(t1_buf_array, t1_line_array);\n        t1_getline();\n    }\n    subr_array_end = xstrdup(t1_buf_array);\n    if (i == POST_SUBRS_SCAN) { /* CharStrings not found;\n                                   suppose synthetic font */\n        for (ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n            if (ptr->valid)\n                xfree(ptr->data);\n        xfree(subr_tab);\n        xfree(subr_array_start);\n        xfree(subr_array_end);\n        cs_init();\n        t1_cs = false;\n        t1_synthetic = true;\n        while (!(t1_charstrings() || t1_subrs()))\n            t1_getline();\n        goto found;\n    }\n}\n\n#define t1_subr_flush()  t1_flush_cs(true)\n#define t1_cs_flush()    t1_flush_cs(false)\n\nstatic void t1_flush_cs(boolean is_subr)\n{\n    char *p;\n    byte *r, *return_cs = NULL;\n    cs_entry *tab, *end_tab, *ptr;\n    char *start_line, *line_end;\n    int count, size_pos;\n    unsigned short cr, cs_len = 0;      /* to avoid warning about uninitialized use of cs_len */\n    if (is_subr) {\n        start_line = subr_array_start;\n        line_end = subr_array_end;\n        size_pos = subr_size_pos;\n        tab = subr_tab;\n        count = subr_max + 1;\n        end_tab = subr_tab + count;\n    } else {\n        start_line = cs_dict_start;\n        line_end = cs_dict_end;\n        size_pos = cs_size_pos;\n        tab = cs_tab;\n        end_tab = cs_ptr;\n        count = cs_count;\n    }\n    t1_line_ptr = t1_line_array;\n    for (p = start_line; p - start_line < size_pos;)\n        *t1_line_ptr++ = *p++;\n    while (isdigit((unsigned char)*p))\n        p++;\n    sprintf(t1_line_ptr, \"%u\", count);\n    strcat(t1_line_ptr, p);\n    t1_line_ptr = eol(t1_line_array);\n    t1_putline();\n\n    /* create return_cs to replace unused subr's */\n    if (is_subr) {\n        cr = 4330;\n        cs_len = 0;\n        /* at this point we have t1_lenIV >= 0;\n         * a negative value would be caught in t1_scan_param() */\n        return_cs = xtalloc(t1_lenIV + 1, byte);\n        for (cs_len = 0, r = return_cs; cs_len < t1_lenIV; cs_len++, r++)\n            *r = cencrypt(0x00, &cr);\n        *r = cencrypt(CS_RETURN, &cr);\n        cs_len++;\n    }\n\n    for (ptr = tab; ptr < end_tab; ptr++) {\n        if (ptr->used) {\n            if (is_subr)\n                sprintf(t1_line_array, \"dup %lu %u\",\n                        (unsigned long) (ptr - tab), ptr->cslen);\n            else\n                sprintf(t1_line_array, \"/%s %u\", ptr->name, ptr->cslen);\n            p = strend(t1_line_array);\n            memcpy(p, ptr->data, ptr->len);\n            t1_line_ptr = p + ptr->len;\n            t1_putline();\n        } else {\n            /* replace unsused subr's by return_cs */\n            if (is_subr) {\n                sprintf(t1_line_array, \"dup %lu %u%s \",\n                        (unsigned long) (ptr - tab), cs_len, cs_token_pair[0]);\n                p = strend(t1_line_array);\n                memcpy(p, return_cs, cs_len);\n                t1_line_ptr = p + cs_len;\n                t1_putline();\n                sprintf(t1_line_array, \" %s\", cs_token_pair[1]);\n                t1_line_ptr = eol(t1_line_array);\n                t1_putline();\n            }\n        }\n        xfree(ptr->data);\n        if (ptr->name != notdef)\n            xfree(ptr->name);\n    }\n    sprintf(t1_line_array, \"%s\", line_end);\n    t1_line_ptr = eol(t1_line_array);\n    t1_putline();\n    if (is_subr)\n        xfree(return_cs);\n    xfree(tab);\n    xfree(start_line);\n    xfree(line_end);\n}\n\nstatic void t1_mark_glyphs(void)\n{\n    char *glyph;\n    struct avl_traverser t;\n    cs_entry *ptr;\n    if (t1_synthetic || fd_cur->all_glyphs) {   /* mark everything */\n        if (cs_tab != NULL)\n            for (ptr = cs_tab; ptr < cs_ptr; ptr++)\n                if (ptr->valid)\n                    ptr->used = true;\n        if (subr_tab != NULL) {\n            for (ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n                if (ptr->valid)\n                    ptr->used = true;\n            subr_max = subr_size - 1;\n        }\n        return;\n    }\n    mark_cs(notdef);\n    avl_t_init(&t, fd_cur->gl_tree);\n    for (glyph = (char *) avl_t_first(&t, fd_cur->gl_tree); glyph != NULL;\n         glyph = (char *) avl_t_next(&t)) {\n        mark_cs(glyph);\n    }\n    if (subr_tab != NULL)\n        for (subr_max = -1, ptr = subr_tab; ptr - subr_tab < subr_size; ptr++)\n            if (ptr->used && ptr - subr_tab > subr_max)\n                subr_max = ptr - subr_tab;\n}\n\nstatic void t1_check_unusual_charstring(void)\n{\n    char *p = strstr(t1_line_array, charstringname) + strlen(charstringname);\n    int i;\n    /* if no number follows \"/CharStrings\", let's read the next line */\n    if (sscanf(p, \"%i\", &i) != 1) {\n        /* pdftex_warn(\"no number found after `%s', I assume it's on the next line\",\n                    charstringname); */\n        strcpy(t1_buf_array, t1_line_array);\n\n        /* t1_getline always appends EOL to t1_line_array; let's change it to\n         * space before appending the next line\n         */\n        *(strend(t1_buf_array) - 1) = ' ';\n\n        t1_getline();\n        alloc_array(t1_buf, strlen(t1_line_array) + strlen(t1_buf_array) + 1, T1_BUF_SIZE);\n        strcat(t1_buf_array, t1_line_array);\n        alloc_array(t1_line, strlen(t1_buf_array) + 1, T1_BUF_SIZE);\n        strcpy(t1_line_array, t1_buf_array);\n        t1_line_ptr = eol(t1_line_array);\n    }\n}\n\nstatic void t1_subset_charstrings(void)\n{\n    cs_entry *ptr;\n\n    /* at this point t1_line_array contains \"/CharStrings\".\n       when we hit a case like this:\n         dup/CharStrings\n         229 dict dup begin\n       we read the next line and concatenate to t1_line_array before moving on\n    */\n    t1_check_unusual_charstring();\n\n    cs_size_pos = strstr(t1_line_array, charstringname)\n                  + strlen(charstringname) - t1_line_array + 1;\n    /* cs_size_pos points to the number indicating\n       dict size after \"/CharStrings\" */\n    cs_size = t1_scan_num(t1_line_array + cs_size_pos, 0);\n    cs_ptr = cs_tab = xtalloc(cs_size, cs_entry);\n    for (ptr = cs_tab; ptr - cs_tab < cs_size; ptr++)\n        init_cs_entry(ptr);\n    cs_notdef = NULL;\n    cs_dict_start = xstrdup(t1_line_array);\n    t1_getline();\n    while (t1_cslen) {\n        store_cs();\n        t1_getline();\n    }\n    cs_dict_end = xstrdup(t1_line_array);\n    t1_mark_glyphs();\n    if (subr_tab != NULL) {\n        if (cs_token_pair == NULL)\n            pdftex_fail\n                (\"This Type 1 font uses mismatched subroutine begin/end token pairs.\");\n        t1_subr_flush();\n    }\n    for (cs_count = 0, ptr = cs_tab; ptr < cs_ptr; ptr++)\n        if (ptr->used)\n            cs_count++;\n    t1_cs_flush();\n}\n\nstatic void t1_subset_end(void)\n{\n    if (t1_synthetic) {         /* copy to \"dup /FontName get exch definefont pop\" */\n        while (!strstr(t1_line_array, \"definefont\")) {\n            t1_getline();\n            t1_putline();\n        }\n        while (!t1_end_eexec())\n            t1_getline();       /* ignore the rest */\n        t1_putline();           /* write \"mark currentfile closefile\" */\n    } else\n        while (!t1_end_eexec()) {       /* copy to \"mark currentfile closefile\" */\n            t1_getline();\n            t1_putline();\n        }\n    t1_stop_eexec();\n    if (fixedcontent) {         /* copy 512 zeros (not needed for PDF) */\n        while (!t1_cleartomark()) {\n            t1_getline();\n            t1_putline();\n        }\n        if (!t1_synthetic)      /* don't check \"{restore}if\" for synthetic fonts */\n            t1_check_end();     /* write \"{restore}if\" if found */\n    }\n    get_length3();\n}\n\nvoid writet1(fd_entry *fd)\n{\n    fd_cur = fd;                /* fd_cur is global inside writet1.c */\n    assert(fd_cur->fm != NULL);\n    assert(is_type1(fd->fm));\n    assert(is_included(fd->fm));\n\n    t1_save_offset = 0;\n    if (!is_subsetted(fd_cur->fm)) {    /* include entire font */\n        if (!(fd->ff_found = t1_open_fontfile(\"<<\")))\n            return;\n        t1_include();\n        t1_close_font_file(\">>\");\n        return;\n    }\n    /* partial downloading */\n    if (!(fd->ff_found = t1_open_fontfile(\"<\")))\n        return;\n    t1_subset_ascii_part();\n    t1_start_eexec();\n    cc_init();\n    cs_init();\n    t1_read_subrs();\n    t1_subset_charstrings();\n    t1_subset_end();\n    t1_close_font_file(\">\");\n}\n\nvoid t1_free(void)\n{\n    xfree(t1_line_array);\n    xfree(t1_buf_array);\n}\n"], "filenames": ["texk/dvipsk/ChangeLog", "texk/dvipsk/writet1.c", "texk/web2c/luatexdir/ChangeLog", "texk/web2c/luatexdir/font/writet1.c", "texk/web2c/pdftexdir/ChangeLog", "texk/web2c/pdftexdir/writet1.c"], "buggy_code_start_loc": [0, 1451, 0, 1583, 0, 1600], "buggy_code_end_loc": [0, 1452, 1033, 1584, 0, 1601], "fixing_code_start_loc": [1, 1452, 1, 1584, 1, 1601], "fixing_code_end_loc": [6, 1455, 1037, 1587, 6, 1604], "type": "CWE-119", "message": "An issue was discovered in t1_check_unusual_charstring functions in writet1.c files in TeX Live before 2018-09-21. A buffer overflow in the handling of Type 1 fonts allows arbitrary code execution when a malicious font is loaded by one of the vulnerable tools: pdflatex, pdftex, dvips, or luatex.", "other": {"cve": {"id": "CVE-2018-17407", "sourceIdentifier": "cve@mitre.org", "published": "2018-09-23T21:29:00.280", "lastModified": "2018-11-15T16:11:25.753", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in t1_check_unusual_charstring functions in writet1.c files in TeX Live before 2018-09-21. A buffer overflow in the handling of Type 1 fonts allows arbitrary code execution when a malicious font is loaded by one of the vulnerable tools: pdflatex, pdftex, dvips, or luatex."}, {"lang": "es", "value": "Se ha descubierto un problema en las funciones t1_check_unusual_charstring en los archivos writet1.c en TeX Live en versiones anteriores al 21/09/2018. Un desbordamiento de b\u00fafer en el manejo de fuentes Type 1 permite la ejecuci\u00f3n arbitraria de c\u00f3digo cuando una fuente maliciosa es cargada por una de las herramientas vulnerables: pdflatex, pdftex, dvips o luatex."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tug:tex_live:*:*:*:*:*:*:*:*", "versionEndExcluding": "2018-09-21", "matchCriteriaId": "245444DF-98E7-44A1-B5DC-09097716C314"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/TeX-Live/texlive-source/commit/6ed0077520e2b0da1fd060c7f88db7b2e6068e4c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-security-announce/2018/msg00230.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3788-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3788-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4299", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/TeX-Live/texlive-source/commit/6ed0077520e2b0da1fd060c7f88db7b2e6068e4c"}}