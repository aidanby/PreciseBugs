{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%        CCCC   OOO   M   M  PPPP    OOO   SSSSS  IIIII  TTTTT  EEEEE         %\n%       C      O   O  MM MM  P   P  O   O  SS       I      T    E             %\n%       C      O   O  M M M  PPPP   O   O   SSS     I      T    EEE           %\n%       C      O   O  M   M  P      O   O     SS    I      T    E             %\n%        CCCC   OOO   M   M  P       OOO   SSSSS  IIIII    T    EEEEE         %\n%                                                                             %\n%                                                                             %\n%                     MagickCore Image Composite Methods                      %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2015 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/fx.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/resample.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/threshold.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#include \"MagickCore/version.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C o m p o s i t e I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CompositeImage() returns the second image composited onto the first\n%  at the specified offset, using the specified composite method.\n%\n%  The format of the CompositeImage method is:\n%\n%      MagickBooleanType CompositeImage(Image *image,\n%        const Image *composite_image,const CompositeOperator compose,\n%        const MagickBooleanType clip_to_self,const ssize_t x_offset,\n%        const ssize_t y_offset,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the destination image, modified by he composition\n%\n%    o composite_image: the composite (source) image.\n%\n%    o compose: This operator affects how the composite is applied to\n%      the image.  The operators and how they are utilized are listed here\n%      http://www.w3.org/TR/SVG12/#compositing.\n%\n%    o clip_to_self: set to MagickTrue to limit composition to area composed.\n%\n%    o x_offset: the column offset of the composited image.\n%\n%    o y_offset: the row offset of the composited image.\n%\n%  Extra Controls from Image meta-data in 'image' (artifacts)\n%\n%    o \"compose:args\"\n%        A string containing extra numerical arguments for specific compose\n%        methods, generally expressed as a 'geometry' or a comma separated list\n%        of numbers.\n%\n%        Compose methods needing such arguments include \"BlendCompositeOp\" and\n%        \"DisplaceCompositeOp\".\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n/*\n   Composition based on the SVG specification:\n\n   A Composition is defined by...\n      Color Function :  f(Sc,Dc)  where Sc and Dc are the normizalized colors\n      Blending areas :  X = 1     for area of overlap, ie: f(Sc,Dc)\n                        Y = 1     for source preserved\n                        Z = 1     for destination preserved\n\n   Conversion to transparency (then optimized)\n      Dca' = f(Sc, Dc)*Sa*Da + Y*Sca*(1-Da) + Z*Dca*(1-Sa)\n      Da'  = X*Sa*Da + Y*Sa*(1-Da) + Z*Da*(1-Sa)\n\n   Where...\n      Sca = Sc*Sa     normalized Source color divided by Source alpha\n      Dca = Dc*Da     normalized Dest color divided by Dest alpha\n      Dc' = Dca'/Da'  the desired color value for this channel.\n\n   Da' in in the follow formula as 'gamma'  The resulting alpla value.\n\n   Most functions use a blending mode of over (X=1,Y=1,Z=1) this results in\n   the following optimizations...\n      gamma = Sa+Da-Sa*Da;\n      gamma = 1 - QuantiumScale*alpha * QuantiumScale*beta;\n      opacity = QuantiumScale*alpha*beta;  // over blend, optimized 1-Gamma\n\n   The above SVG definitions also definate that Mathematical Composition\n   methods should use a 'Over' blending mode for Alpha Channel.\n   It however was not applied for composition modes of 'Plus', 'Minus',\n   the modulus versions of 'Add' and 'Subtract'.\n\n   Mathematical operator changes to be applied from IM v6.7...\n\n    1) Modulus modes 'Add' and 'Subtract' are obsoleted and renamed\n       'ModulusAdd' and 'ModulusSubtract' for clarity.\n\n    2) All mathematical compositions work as per the SVG specification\n       with regard to blending.  This now includes 'ModulusAdd' and\n       'ModulusSubtract'.\n\n    3) When the special channel flag 'sync' (syncronize channel updates)\n       is turned off (enabled by default) then mathematical compositions are\n       only performed on the channels specified, and are applied\n       independantally of each other.  In other words the mathematics is\n       performed as 'pure' mathematical operations, rather than as image\n       operations.\n*/\n\nstatic void HCLComposite(const MagickRealType hue,const MagickRealType chroma,\n  const MagickRealType luma,MagickRealType *red,MagickRealType *green,\n  MagickRealType *blue)\n{\n  MagickRealType\n    b,\n    c,\n    g,\n    h,\n    m,\n    r,\n    x;\n\n  /*\n    Convert HCL to RGB colorspace.\n  */\n  assert(red != (MagickRealType *) NULL);\n  assert(green != (MagickRealType *) NULL);\n  assert(blue != (MagickRealType *) NULL);\n  h=6.0*hue;\n  c=chroma;\n  x=c*(1.0-fabs(fmod(h,2.0)-1.0));\n  r=0.0;\n  g=0.0;\n  b=0.0;\n  if ((0.0 <= h) && (h < 1.0))\n    {\n      r=c;\n      g=x;\n    }\n  else\n    if ((1.0 <= h) && (h < 2.0))\n      {\n        r=x;\n        g=c;\n      }\n    else\n      if ((2.0 <= h) && (h < 3.0))\n        {\n          g=c;\n          b=x;\n        }\n      else\n        if ((3.0 <= h) && (h < 4.0))\n          {\n            g=x;\n            b=c;\n          }\n        else\n          if ((4.0 <= h) && (h < 5.0))\n            {\n              r=x;\n              b=c;\n            }\n          else\n            if ((5.0 <= h) && (h < 6.0))\n              {\n                r=c;\n                b=x;\n              }\n  m=luma-(0.298839*r+0.586811*g+0.114350*b);\n  *red=QuantumRange*(r+m);\n  *green=QuantumRange*(g+m);\n  *blue=QuantumRange*(b+m);\n}\n\nstatic void CompositeHCL(const MagickRealType red,const MagickRealType green,\n  const MagickRealType blue,MagickRealType *hue,MagickRealType *chroma,\n  MagickRealType *luma)\n{\n  MagickRealType\n    b,\n    c,\n    g,\n    h,\n    max,\n    r;\n\n  /*\n    Convert RGB to HCL colorspace.\n  */\n  assert(hue != (MagickRealType *) NULL);\n  assert(chroma != (MagickRealType *) NULL);\n  assert(luma != (MagickRealType *) NULL);\n  r=red;\n  g=green;\n  b=blue;\n  max=MagickMax(r,MagickMax(g,b));\n  c=max-(MagickRealType) MagickMin(r,MagickMin(g,b));\n  h=0.0;\n  if (c == 0)\n    h=0.0;\n  else\n    if (red == max)\n      h=fmod((g-b)/c+6.0,6.0);\n    else\n      if (green == max)\n        h=((b-r)/c)+2.0;\n      else\n        if (blue == max)\n          h=((r-g)/c)+4.0;\n  *hue=(h/6.0);\n  *chroma=QuantumScale*c;\n  *luma=QuantumScale*(0.298839*r+0.586811*g+0.114350*b);\n}\n\nstatic MagickBooleanType CompositeOverImage(Image *image,\n  const Image *composite_image,const MagickBooleanType clip_to_self,\n  const ssize_t x_offset,const ssize_t y_offset,ExceptionInfo *exception)\n{\n#define CompositeImageTag  \"Composite/Image\"\n\n  CacheView\n    *composite_view,\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  /*\n    Composite image.\n  */\n  status=MagickTrue;\n  progress=0;\n  composite_view=AcquireVirtualCacheView(composite_image,exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(composite_image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const Quantum\n      *pixels;\n\n    register const Quantum\n      *restrict p;\n\n    register Quantum\n      *restrict q;\n\n    register ssize_t\n      x;\n\n    size_t\n      channels;\n\n    if (status == MagickFalse)\n      continue;\n    if (clip_to_self != MagickFalse)\n      {\n        if (y < y_offset)\n          continue;\n        if ((y-y_offset) >= (ssize_t) composite_image->rows)\n          continue;\n      }\n    /*\n      If pixels is NULL, y is outside overlay region.\n    */\n    pixels=(Quantum *) NULL;\n    p=(Quantum *) NULL;\n    if ((y >= y_offset) && ((y-y_offset) < (ssize_t) composite_image->rows))\n      {\n        p=GetCacheViewVirtualPixels(composite_view,0,y-y_offset,\n          composite_image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        pixels=p;\n        if (x_offset < 0)\n          p-=x_offset*GetPixelChannels(composite_image);\n      }\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      MagickRealType\n        Da,\n        Dc,\n        Dca,\n        Sa,\n        Sc,\n        Sca;\n\n      register ssize_t\n        i;\n\n      if (clip_to_self != MagickFalse)\n        {\n          if (x < x_offset)\n            {\n              q+=GetPixelChannels(image);\n              continue;\n            }\n          if ((x-x_offset) >= (ssize_t) composite_image->columns)\n            break;\n        }\n      if ((pixels == (Quantum *) NULL) || (x < x_offset) ||\n          ((x-x_offset) >= (ssize_t) composite_image->columns))\n        {\n          Quantum\n            source[MaxPixelChannels];\n\n          /*\n            Virtual composite:\n              Sc: source color.\n              Dc: destination color.\n          */\n          if (GetPixelReadMask(image,q) == 0)\n            {\n              q+=GetPixelChannels(image);\n              continue;\n            }\n          (void) GetOneVirtualPixel(composite_image,x-x_offset,y-y_offset,\n            source,exception);\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            PixelTrait traits=GetPixelChannelTraits(image,channel);\n            PixelTrait composite_traits=GetPixelChannelTraits(composite_image,\n              channel);\n            if ((traits == UndefinedPixelTrait) ||\n                (composite_traits == UndefinedPixelTrait))\n              continue;\n            q[i]=source[channel];\n          }\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      /*\n        Authentic composite:\n          Sa:  normalized source alpha.\n          Da:  normalized destination alpha.\n      */\n      if (GetPixelReadMask(composite_image,p) == 0)\n        {\n          p+=GetPixelChannels(composite_image);\n          channels=GetPixelChannels(composite_image);\n          if (p >= (pixels+channels*composite_image->columns))\n            p=pixels;\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      Sa=QuantumScale*GetPixelAlpha(composite_image,p);\n      Da=QuantumScale*GetPixelAlpha(image,q);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait composite_traits=GetPixelChannelTraits(composite_image,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (composite_traits == UndefinedPixelTrait))\n          continue;\n        if ((traits & CopyPixelTrait) != 0)\n          {\n            /*\n              Copy channel.\n            */\n            q[i]=GetPixelChannel(composite_image,channel,p);\n            continue;\n          }\n        if (channel == AlphaPixelChannel)\n          {\n            /*\n              Set alpha channel.\n            */\n            q[i]=ClampToQuantum(QuantumRange*(Sa+Da-Sa*Da));\n            continue;\n          }\n        /*\n          Sc: source color.\n          Dc: destination color.\n        */\n        Sc=(MagickRealType) GetPixelChannel(composite_image,channel,p);\n        Dc=(MagickRealType) q[i];\n        Sca=QuantumScale*Sa*Sc;\n        Dca=QuantumScale*Da*Dc;\n        q[i]=ClampToQuantum(QuantumRange*(Sca+Dca*(1.0-Sa)));\n      }\n      p+=GetPixelChannels(composite_image);\n      channels=GetPixelChannels(composite_image);\n      if (p >= (pixels+channels*composite_image->columns))\n        p=pixels;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_CompositeImage)\n#endif\n        proceed=SetImageProgress(image,CompositeImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  composite_view=DestroyCacheView(composite_view);\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nMagickExport MagickBooleanType CompositeImage(Image *image,\n  const Image *composite,const CompositeOperator compose,\n  const MagickBooleanType clip_to_self,const ssize_t x_offset,\n  const ssize_t y_offset,ExceptionInfo *exception)\n{\n#define CompositeImageTag  \"Composite/Image\"\n\n  CacheView\n    *composite_view,\n    *image_view;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *composite_image,\n    *destination_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MagickRealType\n    amount,\n    destination_dissolve,\n    midpoint,\n    percent_luma,\n    percent_chroma,\n    source_dissolve,\n    threshold;\n\n  MagickStatusType\n    flags;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(composite!= (Image *) NULL);\n  assert(composite->signature == MagickSignature);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  composite_image=CloneImage(composite,0,0,MagickTrue,exception);\n  if (composite_image == (const Image *) NULL)\n    return(MagickFalse);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  (void) SetImageColorspace(composite_image,image->colorspace,exception);\n  if ((image->alpha_trait != UndefinedPixelTrait) &&\n      (composite_image->alpha_trait == UndefinedPixelTrait))\n    (void) SetImageAlphaChannel(composite_image,SetAlphaChannel,exception);\nif (0)\n  if ((compose == OverCompositeOp) || (compose == SrcOverCompositeOp))\n    {\n      status=CompositeOverImage(image,composite_image,clip_to_self,x_offset,\n        y_offset,exception);\n      composite_image=DestroyImage(composite_image);\n      return(status);\n    }\n  destination_image=(Image *) NULL;\n  amount=0.5;\n  destination_dissolve=1.0;\n  percent_luma=100.0;\n  percent_chroma=100.0;\n  source_dissolve=1.0;\n  threshold=0.05f;\n  switch (compose)\n  {\n    case CopyCompositeOp:\n    {\n      if ((x_offset < 0) || (y_offset < 0))\n        break;\n      if ((x_offset+(ssize_t) composite_image->columns) > (ssize_t) image->columns)\n        break;\n      if ((y_offset+(ssize_t) composite_image->rows) > (ssize_t) image->rows)\n        break;\n      status=MagickTrue;\n      composite_view=AcquireVirtualCacheView(composite_image,exception);\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        magick_threads(composite_image,image,composite_image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) composite_image->rows; y++)\n      {\n        MagickBooleanType\n          sync;\n\n        register const Quantum\n          *p;\n\n        register Quantum\n          *q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        p=GetCacheViewVirtualPixels(composite_view,0,y,composite_image->columns,\n          1,exception);\n        q=GetCacheViewAuthenticPixels(image_view,x_offset,y+y_offset,\n          composite_image->columns,1,exception);\n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) composite_image->columns; x++)\n        {\n          register ssize_t\n            i;\n\n          if (GetPixelReadMask(composite_image,p) == 0)\n            {\n              p+=GetPixelChannels(composite_image);\n              q+=GetPixelChannels(image);\n              continue;\n            }\n          for (i=0; i < (ssize_t) GetPixelChannels(composite_image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(composite_image,i);\n            PixelTrait composite_traits=GetPixelChannelTraits(composite_image,\n              channel);\n            PixelTrait traits=GetPixelChannelTraits(image,channel);\n            if ((traits == UndefinedPixelTrait) ||\n                (composite_traits == UndefinedPixelTrait))\n              continue;\n            SetPixelChannel(image,channel,p[i],q);\n          }\n          p+=GetPixelChannels(composite_image);\n          q+=GetPixelChannels(image);\n        }\n        sync=SyncCacheViewAuthenticPixels(image_view,exception);\n        if (sync == MagickFalse)\n          status=MagickFalse;\n        if (image->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp critical (MagickCore_CompositeImage)\n#endif\n            proceed=SetImageProgress(image,CompositeImageTag,\n              (MagickOffsetType) y,image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n      composite_view=DestroyCacheView(composite_view);\n      image_view=DestroyCacheView(image_view);\n      composite_image=DestroyImage(composite_image);\n      return(status);\n    }\n    case IntensityCompositeOp:\n    {\n      if ((x_offset < 0) || (y_offset < 0))\n        break;\n      if ((x_offset+(ssize_t) composite_image->columns) > (ssize_t) image->columns)\n        break;\n      if ((y_offset+(ssize_t) composite_image->rows) > (ssize_t) image->rows)\n        break;\n      status=MagickTrue;\n      composite_view=AcquireVirtualCacheView(composite_image,exception);\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        magick_threads(composite_image,image,composite_image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) composite_image->rows; y++)\n      {\n        MagickBooleanType\n          sync;\n\n        register const Quantum\n          *p;\n\n        register Quantum\n          *q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        p=GetCacheViewVirtualPixels(composite_view,0,y,composite_image->columns,\n          1,exception);\n        q=GetCacheViewAuthenticPixels(image_view,x_offset,y+y_offset,\n          composite_image->columns,1,exception);\n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) composite_image->columns; x++)\n        {\n          if (GetPixelReadMask(composite_image,p) == 0)\n            {\n              p+=GetPixelChannels(composite_image);\n              q+=GetPixelChannels(image);\n              continue;\n            }\n          SetPixelAlpha(image,ClampToQuantum(GetPixelIntensity(composite_image,\n            p)),q);\n          p+=GetPixelChannels(composite_image);\n          q+=GetPixelChannels(image);\n        }\n        sync=SyncCacheViewAuthenticPixels(image_view,exception);\n        if (sync == MagickFalse)\n          status=MagickFalse;\n        if (image->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp critical (MagickCore_CompositeImage)\n#endif\n            proceed=SetImageProgress(image,CompositeImageTag,\n              (MagickOffsetType) y,image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n      composite_view=DestroyCacheView(composite_view);\n      image_view=DestroyCacheView(image_view);\n      composite_image=DestroyImage(composite_image);\n      return(status);\n    }\n    case CopyAlphaCompositeOp:\n    case ChangeMaskCompositeOp:\n    {\n      /*\n        Modify destination outside the overlaid region and require an alpha\n        channel to exist, to add transparency.\n      */\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      break;\n    }\n    case BlurCompositeOp:\n    {\n      CacheView\n        *composite_view,\n        *destination_view;\n\n      const char\n        *value;\n\n      MagickRealType\n        angle_range,\n        angle_start,\n        height,\n        width;\n\n      PixelInfo\n        pixel;\n\n      ResampleFilter\n        *resample_filter;\n\n      SegmentInfo\n        blur;\n\n      /*\n        Blur Image by resampling.\n\n        Blur Image dictated by an overlay gradient map: X = red_channel;\n          Y = green_channel; compose:args =  x_scale[,y_scale[,angle]].\n      */\n      destination_image=CloneImage(image,image->columns,image->rows,MagickTrue,\n        exception);\n      if (destination_image == (Image *) NULL)\n        {\n          composite_image=DestroyImage(composite_image);\n          return(MagickFalse);\n        }\n      /*\n        Gather the maximum blur sigma values from user.\n      */\n      SetGeometryInfo(&geometry_info);\n      flags=NoValue;\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (const char *) NULL)\n        flags=ParseGeometry(value,&geometry_info);\n      if ((flags & WidthValue) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n            \"InvalidSetting\",\"'%s' '%s'\",\"compose:args\",value);\n          composite_image=DestroyImage(composite_image);\n          destination_image=DestroyImage(destination_image);\n          return(MagickFalse);\n        }\n      /*\n        Users input sigma now needs to be converted to the EWA ellipse size.\n        The filter defaults to a sigma of 0.5 so to make this match the\n        users input the ellipse size needs to be doubled.\n      */\n      width=height=geometry_info.rho*2.0;\n      if ((flags & HeightValue) != 0 )\n        height=geometry_info.sigma*2.0;\n      /*\n        Default the unrotated ellipse width and height axis vectors.\n      */\n      blur.x1=width;\n      blur.x2=0.0;\n      blur.y1=0.0;\n      blur.y2=height;\n      /* rotate vectors if a rotation angle is given */\n      if ((flags & XValue) != 0 )\n        {\n          MagickRealType\n            angle;\n\n          angle=DegreesToRadians(geometry_info.xi);\n          blur.x1=width*cos(angle);\n          blur.x2=width*sin(angle);\n          blur.y1=(-height*sin(angle));\n          blur.y2=height*cos(angle);\n        }\n      /* Otherwise lets set a angle range and calculate in the loop */\n      angle_start=0.0;\n      angle_range=0.0;\n      if ((flags & YValue) != 0 )\n        {\n          angle_start=DegreesToRadians(geometry_info.xi);\n          angle_range=DegreesToRadians(geometry_info.psi)-angle_start;\n        }\n      /*\n        Set up a gaussian cylindrical filter for EWA Bluring.\n\n        As the minimum ellipse radius of support*1.0 the EWA algorithm\n        can only produce a minimum blur of 0.5 for Gaussian (support=2.0)\n        This means that even 'No Blur' will be still a little blurry!\n\n        The solution (as well as the problem of preventing any user\n        expert filter settings, is to set our own user settings, then\n        restore them afterwards.\n      */\n      resample_filter=AcquireResampleFilter(image,exception);\n      SetResampleFilter(resample_filter,GaussianFilter);\n\n      /* do the variable blurring of each pixel in image */\n      GetPixelInfo(image,&pixel);\n      composite_view=AcquireVirtualCacheView(composite_image,exception);\n      destination_view=AcquireAuthenticCacheView(destination_image,exception);\n      for (y=0; y < (ssize_t) composite_image->rows; y++)\n      {\n        MagickBooleanType\n          sync;\n\n        register const Quantum\n          *restrict p;\n\n        register Quantum\n          *restrict q;\n\n        register ssize_t\n          x;\n\n        if (((y+y_offset) < 0) || ((y+y_offset) >= (ssize_t) image->rows))\n          continue;\n        p=GetCacheViewVirtualPixels(composite_view,0,y,composite_image->columns,\n          1,exception);\n        q=QueueCacheViewAuthenticPixels(destination_view,0,y,\n          destination_image->columns,1,exception);\n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n          break;\n        for (x=0; x < (ssize_t) composite_image->columns; x++)\n        {\n          if (((x_offset+x) < 0) || ((x_offset+x) >= (ssize_t) image->columns))\n            {\n              p+=GetPixelChannels(composite_image);\n              continue;\n            }\n          if (fabs((double) angle_range) > MagickEpsilon)\n            {\n              MagickRealType\n                angle;\n\n              angle=angle_start+angle_range*QuantumScale*\n                GetPixelBlue(composite_image,p);\n              blur.x1=width*cos(angle);\n              blur.x2=width*sin(angle);\n              blur.y1=(-height*sin(angle));\n              blur.y2=height*cos(angle);\n            }\n#if 0\n          if ( x == 10 && y == 60 ) {\n            (void) fprintf(stderr, \"blur.x=%lf,%lf, blur.y=%lf,%lf\\n\",blur.x1,\n              blur.x2,blur.y1, blur.y2);\n            (void) fprintf(stderr, \"scaled by=%lf,%lf\\n\",QuantumScale*\n              GetPixelRed(p),QuantumScale*GetPixelGreen(p));\n#endif\n          ScaleResampleFilter(resample_filter,\n            blur.x1*QuantumScale*GetPixelRed(composite_image,p),\n            blur.y1*QuantumScale*GetPixelGreen(composite_image,p),\n            blur.x2*QuantumScale*GetPixelRed(composite_image,p),\n            blur.y2*QuantumScale*GetPixelGreen(composite_image,p) );\n          (void) ResamplePixelColor(resample_filter,(double) x_offset+x,\n            (double) y_offset+y,&pixel,exception);\n          SetPixelViaPixelInfo(destination_image,&pixel,q);\n          p+=GetPixelChannels(composite_image);\n          q+=GetPixelChannels(destination_image);\n        }\n        sync=SyncCacheViewAuthenticPixels(destination_view,exception);\n        if (sync == MagickFalse)\n          break;\n      }\n      resample_filter=DestroyResampleFilter(resample_filter);\n      composite_view=DestroyCacheView(composite_view);\n      destination_view=DestroyCacheView(destination_view);\n      composite_image=DestroyImage(composite_image);\n      composite_image=destination_image;\n      break;\n    }\n    case DisplaceCompositeOp:\n    case DistortCompositeOp:\n    {\n      CacheView\n        *composite_view,\n        *destination_view,\n        *image_view;\n\n      const char\n        *value;\n\n      PixelInfo\n        pixel;\n\n      MagickRealType\n        horizontal_scale,\n        vertical_scale;\n\n      PointInfo\n        center,\n        offset;\n\n      /*\n        Displace/Distort based on overlay gradient map:\n          X = red_channel;  Y = green_channel;\n          compose:args = x_scale[,y_scale[,center.x,center.y]]\n      */\n      destination_image=CloneImage(image,image->columns,image->rows,MagickTrue,\n        exception);\n      if (destination_image == (Image *) NULL)\n        {\n          composite_image=DestroyImage(composite_image);\n          return(MagickFalse);\n        }\n      SetGeometryInfo(&geometry_info);\n      flags=NoValue;\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        flags=ParseGeometry(value,&geometry_info);\n      if ((flags & (WidthValue|HeightValue)) == 0 )\n        {\n          if ((flags & AspectValue) == 0)\n            {\n              horizontal_scale=(MagickRealType) (composite_image->columns-1.0)/\n                2.0;\n              vertical_scale=(MagickRealType) (composite_image->rows-1.0)/2.0;\n            }\n          else\n            {\n              horizontal_scale=(MagickRealType) (image->columns-1.0)/2.0;\n              vertical_scale=(MagickRealType) (image->rows-1.0)/2.0;\n            }\n        }\n      else\n        {\n          horizontal_scale=geometry_info.rho;\n          vertical_scale=geometry_info.sigma;\n          if ((flags & PercentValue) != 0)\n            {\n              if ((flags & AspectValue) == 0)\n                {\n                  horizontal_scale*=(composite_image->columns-1.0)/200.0;\n                  vertical_scale*=(composite_image->rows-1.0)/200.0;\n                }\n              else\n                {\n                  horizontal_scale*=(image->columns-1.0)/200.0;\n                  vertical_scale*=(image->rows-1.0)/200.0;\n                }\n            }\n          if ((flags & HeightValue) == 0)\n            vertical_scale=horizontal_scale;\n        }\n      /*\n        Determine fixed center point for absolute distortion map\n         Absolute distort ==\n           Displace offset relative to a fixed absolute point\n           Select that point according to +X+Y user inputs.\n           default = center of overlay image\n           arg flag '!' = locations/percentage relative to background image\n      */\n      center.x=(MagickRealType) x_offset;\n      center.y=(MagickRealType) y_offset;\n      if (compose == DistortCompositeOp)\n        {\n          if ((flags & XValue) == 0)\n            if ((flags & AspectValue) == 0)\n              center.x=(MagickRealType) (x_offset+(composite_image->columns-1)/\n                2.0);\n            else\n              center.x=(MagickRealType) ((image->columns-1)/2);\n          else\n            if ((flags & AspectValue) == 0)\n              center.x=(MagickRealType) x_offset+geometry_info.xi;\n            else\n              center.x=geometry_info.xi;\n          if ((flags & YValue) == 0)\n            if ((flags & AspectValue) == 0)\n              center.y=(MagickRealType) (y_offset+(composite_image->rows-1)/\n                2.0);\n            else\n              center.y=(MagickRealType) ((image->rows-1)/2);\n          else\n            if ((flags & AspectValue) == 0)\n              center.y=(MagickRealType) y_offset+geometry_info.psi;\n            else\n              center.y=geometry_info.psi;\n        }\n      /*\n        Shift the pixel offset point as defined by the provided,\n        displacement/distortion map.  -- Like a lens...\n      */\n      GetPixelInfo(image,&pixel);\n      image_view=AcquireVirtualCacheView(image,exception);\n      composite_view=AcquireVirtualCacheView(composite_image,exception);\n      destination_view=AcquireAuthenticCacheView(destination_image,exception);\n      for (y=0; y < (ssize_t) composite_image->rows; y++)\n      {\n        MagickBooleanType\n          sync;\n\n        register const Quantum\n          *restrict p;\n\n        register Quantum\n          *restrict q;\n\n        register ssize_t\n          x;\n\n        if (((y+y_offset) < 0) || ((y+y_offset) >= (ssize_t) image->rows))\n          continue;\n        p=GetCacheViewVirtualPixels(composite_view,0,y,composite_image->columns,\n          1,exception);\n        q=QueueCacheViewAuthenticPixels(destination_view,0,y,\n          destination_image->columns,1,exception);\n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n          break;\n        for (x=0; x < (ssize_t) composite_image->columns; x++)\n        {\n          if (((x_offset+x) < 0) || ((x_offset+x) >= (ssize_t) image->columns))\n            {\n              p+=GetPixelChannels(composite_image);\n              continue;\n            }\n          /*\n            Displace the offset.\n          */\n          offset.x=(double) (horizontal_scale*(GetPixelRed(composite_image,p)-\n            (((MagickRealType) QuantumRange+1.0)/2.0)))/(((MagickRealType)\n            QuantumRange+1.0)/2.0)+center.x+((compose == DisplaceCompositeOp) ?\n            x : 0);\n          offset.y=(double) (vertical_scale*(GetPixelGreen(composite_image,p)-\n            (((MagickRealType) QuantumRange+1.0)/2.0)))/(((MagickRealType)\n            QuantumRange+1.0)/2.0)+center.y+((compose == DisplaceCompositeOp) ?\n            y : 0);\n          (void) InterpolatePixelInfo(image,image_view,\n            UndefinedInterpolatePixel,(double) offset.x,(double) offset.y,\n            &pixel,exception);\n          /*\n            Mask with the 'invalid pixel mask' in alpha channel.\n          */\n          pixel.alpha=(MagickRealType) QuantumRange*(1.0-(1.0-QuantumScale*\n            pixel.alpha)*(1.0-QuantumScale*GetPixelAlpha(composite_image,p)));\n          SetPixelViaPixelInfo(destination_image,&pixel,q);\n          p+=GetPixelChannels(composite_image);\n          q+=GetPixelChannels(destination_image);\n        }\n        sync=SyncCacheViewAuthenticPixels(destination_view,exception);\n        if (sync == MagickFalse)\n          break;\n      }\n      destination_view=DestroyCacheView(destination_view);\n      composite_view=DestroyCacheView(composite_view);\n      image_view=DestroyCacheView(image_view);\n      composite_image=DestroyImage(composite_image);\n      composite_image=destination_image;\n      break;\n    }\n    case DissolveCompositeOp:\n    {\n      const char\n        *value;\n\n      /*\n        Geometry arguments to dissolve factors.\n      */\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        {\n          flags=ParseGeometry(value,&geometry_info);\n          source_dissolve=geometry_info.rho/100.0;\n          destination_dissolve=1.0;\n          if ((source_dissolve-MagickEpsilon) < 0.0)\n            source_dissolve=0.0;\n          if ((source_dissolve+MagickEpsilon) > 1.0)\n            {\n              destination_dissolve=2.0-source_dissolve;\n              source_dissolve=1.0;\n            }\n          if ((flags & SigmaValue) != 0)\n            destination_dissolve=geometry_info.sigma/100.0;\n          if ((destination_dissolve-MagickEpsilon) < 0.0)\n            destination_dissolve=0.0;\n        }\n      break;\n    }\n    case BlendCompositeOp:\n    {\n      const char\n        *value;\n\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        {\n          flags=ParseGeometry(value,&geometry_info);\n          source_dissolve=geometry_info.rho/100.0;\n          destination_dissolve=1.0-source_dissolve;\n          if ((flags & SigmaValue) != 0)\n            destination_dissolve=geometry_info.sigma/100.0;\n        }\n      break;\n    }\n    case MathematicsCompositeOp:\n    {\n      const char\n        *value;\n\n      /*\n        Just collect the values from \"compose:args\", setting.\n        Unused values are set to zero automagically.\n\n        Arguments are normally a comma separated list, so this probably should\n        be changed to some 'general comma list' parser, (with a minimum\n        number of values)\n      */\n      SetGeometryInfo(&geometry_info);\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        (void) ParseGeometry(value,&geometry_info);\n      break;\n    }\n    case ModulateCompositeOp:\n    {\n      const char\n        *value;\n\n      /*\n        Determine the luma and chroma scale.\n      */\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        {\n          flags=ParseGeometry(value,&geometry_info);\n          percent_luma=geometry_info.rho;\n          if ((flags & SigmaValue) != 0)\n            percent_chroma=geometry_info.sigma;\n        }\n      break;\n    }\n    case ThresholdCompositeOp:\n    {\n      const char\n        *value;\n\n      /*\n        Determine the amount and threshold.\n      */\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        {\n          flags=ParseGeometry(value,&geometry_info);\n          amount=geometry_info.rho;\n          threshold=geometry_info.sigma;\n          if ((flags & SigmaValue) == 0)\n            threshold=0.05f;\n        }\n      threshold*=QuantumRange;\n      break;\n    }\n    default:\n      break;\n  }\n  /*\n    Composite image.\n  */\n  status=MagickTrue;\n  progress=0;\n  midpoint=((MagickRealType) QuantumRange+1.0)/2;\n  composite_view=AcquireVirtualCacheView(composite_image,exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(composite_image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const Quantum\n      *pixels;\n\n    MagickRealType\n      blue,\n      luma,\n      green,\n      hue,\n      red,\n      chroma;\n\n    PixelInfo\n      destination_pixel,\n      source_pixel;\n\n    register const Quantum\n      *restrict p;\n\n    register Quantum\n      *restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    if (clip_to_self != MagickFalse)\n      {\n        if (y < y_offset)\n          continue;\n        if ((y-y_offset) >= (ssize_t) composite_image->rows)\n          continue;\n      }\n    /*\n      If pixels is NULL, y is outside overlay region.\n    */\n    pixels=(Quantum *) NULL;\n    p=(Quantum *) NULL;\n    if ((y >= y_offset) && ((y-y_offset) < (ssize_t) composite_image->rows))\n      {\n        p=GetCacheViewVirtualPixels(composite_view,0,y-y_offset,\n          composite_image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        pixels=p;\n        if (x_offset < 0)\n          p-=x_offset*GetPixelChannels(composite_image);\n      }\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    hue=0.0;\n    chroma=0.0;\n    luma=0.0;\n    GetPixelInfo(image,&destination_pixel);\n    GetPixelInfo(composite_image,&source_pixel);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      MagickRealType\n        alpha,\n        Da,\n        Dc,\n        Dca,\n        Sa,\n        Sc,\n        Sca;\n\n      register ssize_t\n        i;\n\n      size_t\n        channels;\n\n      if (clip_to_self != MagickFalse)\n        {\n          if (x < x_offset)\n            {\n              q+=GetPixelChannels(image);\n              continue;\n            }\n          if ((x-x_offset) >= (ssize_t) composite_image->columns)\n            break;\n        }\n      if ((pixels == (Quantum *) NULL) || (x < x_offset) ||\n          ((x-x_offset) >= (ssize_t) composite_image->columns))\n        {\n          Quantum\n            source[MaxPixelChannels];\n\n          /*\n            Virtual composite:\n              Sc: source color.\n              Dc: destination color.\n          */\n          (void) GetOneVirtualPixel(composite_image,x-x_offset,y-y_offset,\n            source,exception);\n          if (GetPixelReadMask(image,q) == 0)\n            {\n              q+=GetPixelChannels(image);\n              continue;\n            }\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            MagickRealType\n              pixel;\n\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            PixelTrait traits=GetPixelChannelTraits(image,channel);\n            PixelTrait composite_traits=GetPixelChannelTraits(composite_image,\n              channel);\n            if ((traits == UndefinedPixelTrait) ||\n                (composite_traits == UndefinedPixelTrait))\n              continue;\n            switch (compose)\n            {\n              case AlphaCompositeOp:\n              case ChangeMaskCompositeOp:\n              case CopyAlphaCompositeOp:\n              case DstAtopCompositeOp:\n              case DstInCompositeOp:\n              case InCompositeOp:\n              case OutCompositeOp:\n              case SrcInCompositeOp:\n              case SrcOutCompositeOp:\n              {\n                if (channel == AlphaPixelChannel)\n                  pixel=(MagickRealType) TransparentAlpha;\n                else\n                  pixel=(MagickRealType) q[i];\n                break;\n              }\n              case ClearCompositeOp:\n              case CopyCompositeOp:\n              case ReplaceCompositeOp:\n              case SrcCompositeOp:\n              {\n                if (channel == AlphaPixelChannel)\n                  pixel=(MagickRealType) TransparentAlpha;\n                else\n                  pixel=0.0;\n                break;\n              }\n              case BlendCompositeOp:\n              case DissolveCompositeOp:\n              {\n                if (channel == AlphaPixelChannel)\n                  pixel=destination_dissolve*GetPixelAlpha(composite_image,\n                    source);\n                else\n                  pixel=(MagickRealType) source[channel];\n                break;\n              }\n              default:\n              {\n                pixel=(MagickRealType) source[channel];\n                break;\n              }\n            }\n            q[i]=ClampToQuantum(pixel);\n          }\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      /*\n        Authentic composite:\n          Sa:  normalized source alpha.\n          Da:  normalized destination alpha.\n      */\n      Sa=QuantumScale*GetPixelAlpha(composite_image,p);\n      Da=QuantumScale*GetPixelAlpha(image,q);\n      switch (compose)\n      {\n        case BumpmapCompositeOp:\n        {\n          alpha=GetPixelIntensity(composite_image,p)*Sa;\n          break;\n        }\n        case ColorBurnCompositeOp:\n        case ColorDodgeCompositeOp:\n        case DarkenCompositeOp:\n        case DifferenceCompositeOp:\n        case DivideDstCompositeOp:\n        case DivideSrcCompositeOp:\n        case ExclusionCompositeOp:\n        case HardLightCompositeOp:\n        case HardMixCompositeOp:\n        case LinearBurnCompositeOp:\n        case LinearDodgeCompositeOp:\n        case LinearLightCompositeOp:\n        case LightenCompositeOp:\n        case MathematicsCompositeOp:\n        case MinusDstCompositeOp:\n        case MinusSrcCompositeOp:\n        case ModulusAddCompositeOp:\n        case ModulusSubtractCompositeOp:\n        case MultiplyCompositeOp:\n        case OverlayCompositeOp:\n        case PegtopLightCompositeOp:\n        case PinLightCompositeOp:\n        case ScreenCompositeOp:\n        case SoftLightCompositeOp:\n        case VividLightCompositeOp:\n        {\n          alpha=RoundToUnity(Sa+Da-Sa*Da);\n          break;\n        }\n        case DstAtopCompositeOp:\n        case DstInCompositeOp:\n        case InCompositeOp:\n        case SrcInCompositeOp:\n        {\n          alpha=Sa*Da;\n          break;\n        }\n        case DissolveCompositeOp:\n        {\n          alpha=source_dissolve*Sa*(-destination_dissolve*Da)+source_dissolve*\n            Sa+destination_dissolve*Da;\n          break;\n        }\n        case DstOverCompositeOp:\n        {\n          alpha=Sa+Da-Sa*Da;\n          break;\n        }\n        case DstOutCompositeOp:\n        {\n          alpha=Da*(1.0-Sa);\n          break;\n        }\n        case OutCompositeOp:\n        case SrcOutCompositeOp:\n        {\n          alpha=Sa*(1.0-Da);\n          break;\n        }\n        case OverCompositeOp:\n        case SrcOverCompositeOp:\n        {\n          alpha=Sa+Da-Sa*Da;\n          break;\n        }\n        case BlendCompositeOp:\n        case PlusCompositeOp:\n        {\n          alpha=RoundToUnity(Sa+Da);\n          break;\n        }\n        case XorCompositeOp:\n        {\n          alpha=Sa+Da-2.0*Sa*Da;\n          break;\n        }\n        default:\n        {\n          alpha=1.0;\n          break;\n        }\n      }\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          p+=GetPixelChannels(composite_image);\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      switch (compose)\n      {\n        case ColorizeCompositeOp:\n        case HueCompositeOp:\n        case LuminizeCompositeOp:\n        case ModulateCompositeOp:\n        case SaturateCompositeOp:\n        {\n          GetPixelInfoPixel(composite_image,p,&source_pixel);\n          GetPixelInfoPixel(image,q,&destination_pixel);\n          break;\n        }\n        default:\n          break;\n      }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        MagickRealType\n          pixel,\n          sans;\n\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait composite_traits=GetPixelChannelTraits(composite_image,\n          channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if ((composite_traits == UndefinedPixelTrait) &&\n             (((compose != CopyAlphaCompositeOp) &&\n               (compose != ChangeMaskCompositeOp)) ||\n              (channel != AlphaPixelChannel)))\n            continue;\n        /*\n          Sc: source color.\n          Dc: destination color.\n        */\n        Sc=(MagickRealType) GetPixelChannel(composite_image,channel,p);\n        Dc=(MagickRealType) q[i];\n        if ((traits & CopyPixelTrait) != 0)\n          {\n            /*\n              Copy channel.\n            */\n            q[i]=ClampToQuantum(Sc);\n            continue;\n          }\n        if (channel == AlphaPixelChannel)\n          {\n            /*\n              Set alpha channel.\n            */\n            switch (compose)\n            {\n              case AlphaCompositeOp:\n              {\n                pixel=QuantumRange*Sa;\n                break;\n              }\n              case AtopCompositeOp:\n              case CopyBlackCompositeOp:\n              case CopyBlueCompositeOp:\n              case CopyCyanCompositeOp:\n              case CopyGreenCompositeOp:\n              case CopyMagentaCompositeOp:\n              case CopyRedCompositeOp:\n              case CopyYellowCompositeOp:\n              case SrcAtopCompositeOp:\n              case DstCompositeOp:\n              case NoCompositeOp:\n              {\n                pixel=QuantumRange*Da;\n                break;\n              }\n              case ChangeMaskCompositeOp:\n              {\n                MagickBooleanType\n                  equivalent;\n\n                if (Da > ((MagickRealType) QuantumRange/2.0))\n                  {\n                    pixel=(MagickRealType) TransparentAlpha;\n                    break;\n                  }\n                equivalent=IsFuzzyEquivalencePixel(composite_image,p,image,q);\n                if (equivalent != MagickFalse)\n                  pixel=(MagickRealType) TransparentAlpha;\n                else\n                  pixel=(MagickRealType) OpaqueAlpha;\n                break;\n              }\n              case ClearCompositeOp:\n              {\n                pixel=(MagickRealType) TransparentAlpha;\n                break;\n              }\n              case ColorizeCompositeOp:\n              case HueCompositeOp:\n              case LuminizeCompositeOp:\n              case SaturateCompositeOp:\n              {\n                if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n                  {\n                    pixel=QuantumRange*Da;\n                    break;\n                  }\n                if (fabs((double) (QuantumRange*Da-TransparentAlpha)) < MagickEpsilon)\n                  {\n                    pixel=QuantumRange*Sa;\n                    break;\n                  }\n                if (Sa < Da)\n                  {\n                    pixel=QuantumRange*Da;\n                    break;\n                  }\n                pixel=QuantumRange*Sa;\n                break;\n              }\n              case CopyAlphaCompositeOp:\n              {\n                if (composite_traits == UndefinedPixelTrait)\n                  pixel=GetPixelIntensity(composite_image,p);\n                else\n                  pixel=QuantumRange*Sa;\n                break;\n              }\n              case CopyCompositeOp:\n              case DisplaceCompositeOp:\n              case DistortCompositeOp:\n              case DstAtopCompositeOp:\n              case ReplaceCompositeOp:\n              case SrcCompositeOp:\n              {\n                pixel=QuantumRange*Sa;\n                break;\n              }\n              case DarkenIntensityCompositeOp:\n              {\n                pixel=Sa*GetPixelIntensity(composite_image,p) <\n                  Da*GetPixelIntensity(image,q) ? Sa : Da;\n                break;\n              }\n              case LightenIntensityCompositeOp:\n              {\n                pixel=Sa*GetPixelIntensity(composite_image,p) >\n                  Da*GetPixelIntensity(image,q) ? Sa : Da;\n                break;\n              }\n              case ModulateCompositeOp:\n              {\n                if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n                  {\n                    pixel=QuantumRange*Da;\n                    break;\n                  }\n                pixel=QuantumRange*Da;\n                break;\n              }\n              default:\n              {\n                pixel=QuantumRange*alpha;\n                break;\n              }\n            }\n            q[i]=ClampToQuantum(pixel);\n            continue;\n          }\n        /*\n          Porter-Duff compositions:\n            Sca: source normalized color multiplied by alpha.\n            Dca: normalized destination color multiplied by alpha.\n        */\n        Sca=QuantumScale*Sa*Sc;\n        Dca=QuantumScale*Da*Dc;\n        switch (compose)\n        {\n          case DarkenCompositeOp:\n          case LightenCompositeOp:\n          case ModulusSubtractCompositeOp:\n          {\n            gamma=1.0-alpha;\n            break;\n          }\n          default:\n            break;\n        }\n        gamma=PerceptibleReciprocal(alpha);\n        pixel=Dc;\n        switch (compose)\n        {\n          case AlphaCompositeOp:\n          {\n            pixel=QuantumRange*Sa;\n            break;\n          }\n          case AtopCompositeOp:\n          case SrcAtopCompositeOp:\n          {\n            pixel=QuantumRange*(Sca*Da+Dca*(1.0-Sa));\n            break;\n          }\n          case BlendCompositeOp:\n          {\n            pixel=gamma*(source_dissolve*Sa*Sc+destination_dissolve*Da*Dc);\n            break;\n          }\n          case BlurCompositeOp:\n          case DisplaceCompositeOp:\n          case DistortCompositeOp:\n          case CopyCompositeOp:\n          case ReplaceCompositeOp:\n          case SrcCompositeOp:\n          {\n            pixel=QuantumRange*Sca;\n            break;\n          }\n          case BumpmapCompositeOp:\n          {\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            pixel=QuantumScale*GetPixelIntensity(composite_image,p)*Dc;\n            break;\n          }\n          case ChangeMaskCompositeOp:\n          {\n            pixel=Dc;\n            break;\n          }\n          case ClearCompositeOp:\n          {\n            pixel=0.0;\n            break;\n          }\n          case ColorBurnCompositeOp:\n          {\n            if ((Sca == 0.0) && (Dca == Da))\n              {\n                pixel=QuantumRange*(Sa*Da+Dca*(1.0-Sa));\n                break;\n              }\n            if (Sca == 0.0)\n              {\n                pixel=QuantumRange*(Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Sa*Da-Sa*Da*MagickMin(1.0,(1.0-Dca/Da)*Sa/Sca)+\n              Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case ColorDodgeCompositeOp:\n          {\n            if ((Sca == Sa) && (Dca == 0.0))\n              {\n                pixel=QuantumRange*(Sca*(1.0-Da));\n                break;\n              }\n            if (Sca == Sa)\n              {\n                pixel=QuantumRange*(Sa*Da+Sca*(1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Sa*Da*MagickMin(1.0,Dca/Da*Sa/(Sa-Sca)));\n            break;\n          }\n          case ColorizeCompositeOp:\n          {\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            if (fabs((double) (QuantumRange*Da-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Sc;\n                break;\n              }\n            CompositeHCL(destination_pixel.red,destination_pixel.green,\n              destination_pixel.blue,&sans,&sans,&luma);\n            CompositeHCL(source_pixel.red,source_pixel.green,source_pixel.blue,\n              &hue,&chroma,&sans);\n            HCLComposite(hue,chroma,luma,&red,&green,&blue);\n            switch (channel)\n            {\n              case RedPixelChannel: pixel=red; break;\n              case GreenPixelChannel: pixel=green; break;\n              case BluePixelChannel: pixel=blue; break;\n              default: pixel=Dc; break;\n            }\n            break;\n          }\n          case CopyAlphaCompositeOp:\n          {\n            pixel=Dc;\n            break;\n          }\n          case CopyBlackCompositeOp:\n          {\n            if (channel == BlackPixelChannel)\n              pixel=(MagickRealType) (QuantumRange-\n                GetPixelBlack(composite_image,p));\n            break;\n          }\n          case CopyBlueCompositeOp:\n          case CopyYellowCompositeOp:\n          {\n            if (channel == BluePixelChannel)\n              pixel=(MagickRealType) GetPixelBlue(composite_image,p);\n            break;\n          }\n          case CopyGreenCompositeOp:\n          case CopyMagentaCompositeOp:\n          {\n            if (channel == GreenPixelChannel)\n              pixel=(MagickRealType) GetPixelGreen(composite_image,p);\n            break;\n          }\n          case CopyRedCompositeOp:\n          case CopyCyanCompositeOp:\n          {\n            if (channel == RedPixelChannel)\n              pixel=(MagickRealType) GetPixelRed(composite_image,p);\n            break;\n          }\n          case DarkenCompositeOp:\n          {\n            /*\n              Darken is equivalent to a 'Minimum' method\n                OR a greyscale version of a binary 'Or'\n                OR the 'Intersection' of pixel sets.\n            */\n            if ((Sca*Da) < (Dca*Sa))\n              {\n                pixel=QuantumRange*(Sca+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Dca+Sca*(1.0-Da));\n            break;\n          }\n          case DarkenIntensityCompositeOp:\n          {\n            pixel=Sa*GetPixelIntensity(composite_image,p) <\n              Da*GetPixelIntensity(image,q) ? Sc : Dc;\n            break;\n          }\n          case DifferenceCompositeOp:\n          {\n            pixel=QuantumRange*(Sca+Dca-2.0*MagickMin(Sca*Da,Dca*Sa));\n            break;\n          }\n          case DissolveCompositeOp:\n          {\n            pixel=gamma*(source_dissolve*Sa*Sc-source_dissolve*Sa*\n              destination_dissolve*Da*Dc+destination_dissolve*Da*Dc);\n            break;\n          }\n          case DivideDstCompositeOp:\n          {\n            if ((fabs((double) Sca) < MagickEpsilon) &&\n                (fabs((double) Dca) < MagickEpsilon))\n              {\n                pixel=QuantumRange*(Sca*(1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            if (fabs((double) Dca) < MagickEpsilon)\n              {\n                pixel=QuantumRange*(Sa*Da+Sca*(1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Sca*Da*Da/Dca+Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case DivideSrcCompositeOp:\n          {\n            if ((fabs((double) Dca) < MagickEpsilon) &&\n                (fabs((double) Sca) < MagickEpsilon))\n              {\n                pixel=QuantumRange*(Dca*(1.0-Sa)+Sca*(1.0-Da));\n                break;\n              }\n            if (fabs((double) Sca) < MagickEpsilon)\n              {\n                pixel=QuantumRange*(Da*Sa+Dca*(1.0-Sa)+Sca*(1.0-Da));\n                break;\n              }\n            pixel=QuantumRange*(Dca*Sa*Sa/Sca+Dca*(1.0-Sa)+Sca*(1.0-Da));\n            break;\n          }\n          case DstAtopCompositeOp:\n          {\n            pixel=QuantumRange*(Dca*Sa+Sca*(1.0-Da));\n            break;\n          }\n          case DstCompositeOp:\n          case NoCompositeOp:\n          {\n            pixel=QuantumRange*Dca;\n            break;\n          }\n          case DstInCompositeOp:\n          {\n            pixel=QuantumRange*(Dca*Sa);\n            break;\n          }\n          case DstOutCompositeOp:\n          {\n            pixel=QuantumRange*(Dca*(1.0-Sa));\n            break;\n          }\n          case DstOverCompositeOp:\n          {\n            pixel=QuantumRange*(Dca+Sca*(1.0-Da));\n            break;\n          }\n          case ExclusionCompositeOp:\n          {\n            pixel=QuantumRange*(Sca*Da+Dca*Sa-2.0*Sca*Dca+Sca*(1.0-Da)+Dca*\n              (1.0-Sa));\n            break;\n          }\n          case HardLightCompositeOp:\n          {\n            if ((2.0*Sca) < Sa)\n              {\n                pixel=QuantumRange*(2.0*Sca*Dca+Sca*(1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Sa*Da-2.0*(Da-Dca)*(Sa-Sca)+Sca*(1.0-Da)+Dca*\n              (1.0-Sa));\n            break;\n          }\n          case HardMixCompositeOp:\n          {\n            double\n              gamma;\n\n            if ((Sa+Da) < 1.0)\n              gamma=0.0;\n            else\n              gamma=1.0;\n            pixel=(gamma*(1.0-Sca)*(1.0-Dca))+Sa*(1.0-Sca)*Dca+Da*(1.0-Dca)*Sca;\n            break;\n          }\n          case HueCompositeOp:\n          {\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            if (fabs((double) (QuantumRange*Da-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Sc;\n                break;\n              }\n            CompositeHCL(destination_pixel.red,destination_pixel.green,\n              destination_pixel.blue,&hue,&chroma,&luma);\n            CompositeHCL(source_pixel.red,source_pixel.green,source_pixel.blue,\n              &hue,&sans,&sans);\n            HCLComposite(hue,chroma,luma,&red,&green,&blue);\n            switch (channel)\n            {\n              case RedPixelChannel: pixel=red; break;\n              case GreenPixelChannel: pixel=green; break;\n              case BluePixelChannel: pixel=blue; break;\n              default: pixel=Dc; break;\n            }\n            break;\n          }\n          case InCompositeOp:\n          case SrcInCompositeOp:\n          {\n            pixel=QuantumRange*(Sca*Da);\n            break;\n          }\n          case LinearBurnCompositeOp:\n          {\n            /*\n              LinearBurn: as defined by Abode Photoshop, according to\n              http://www.simplefilter.de/en/basics/mixmods.html is:\n\n                f(Sc,Dc) = Sc + Dc - 1\n            */\n            pixel=QuantumRange*(Sca+Dca-Sa*Da);\n            break;\n          }\n          case LinearDodgeCompositeOp:\n          {\n            pixel=(Sa*Sc+Da*Dc);\n            break;\n          }\n          case LinearLightCompositeOp:\n          {\n            /*\n              LinearLight: as defined by Abode Photoshop, according to\n              http://www.simplefilter.de/en/basics/mixmods.html is:\n\n                f(Sc,Dc) = Dc + 2*Sc - 1\n            */\n            pixel=QuantumRange*((Sca-Sa)*Da+Sca+Dca);\n            break;\n          }\n          case LightenCompositeOp:\n          {\n            if ((Sca*Da) > (Dca*Sa))\n              {\n                pixel=QuantumRange*(Sca+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Dca+Sca*(1.0-Da));\n            break;\n          }\n          case LightenIntensityCompositeOp:\n          {\n            /*\n              Lighten is equivalent to a 'Maximum' method\n                OR a greyscale version of a binary 'And'\n                OR the 'Union' of pixel sets.\n            */\n            pixel=Sa*GetPixelIntensity(composite_image,p) >\n              Da*GetPixelIntensity(image,q) ? Sc : Dc;\n            break;\n          }\n          case LuminizeCompositeOp:\n          {\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            if (fabs((double) (QuantumRange*Da-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Sc;\n                break;\n              }\n            CompositeHCL(destination_pixel.red,destination_pixel.green,\n              destination_pixel.blue,&hue,&chroma,&luma);\n            CompositeHCL(source_pixel.red,source_pixel.green,source_pixel.blue,\n              &sans,&sans,&luma);\n            HCLComposite(hue,chroma,luma,&red,&green,&blue);\n            switch (channel)\n            {\n              case RedPixelChannel: pixel=red; break;\n              case GreenPixelChannel: pixel=green; break;\n              case BluePixelChannel: pixel=blue; break;\n              default: pixel=Dc; break;\n            }\n            break;\n          }\n          case MathematicsCompositeOp:\n          {\n            /*\n              'Mathematics' a free form user control mathematical composition\n              is defined as...\n\n                f(Sc,Dc) = A*Sc*Dc + B*Sc + C*Dc + D\n\n              Where the arguments A,B,C,D are (currently) passed to composite\n              as a command separated 'geometry' string in \"compose:args\" image\n              artifact.\n\n                 A = a->rho,   B = a->sigma,  C = a->xi,  D = a->psi\n\n              Applying the SVG transparency formula (see above), we get...\n\n               Dca' = Sa*Da*f(Sc,Dc) + Sca*(1.0-Da) + Dca*(1.0-Sa)\n\n               Dca' = A*Sca*Dca + B*Sca*Da + C*Dca*Sa + D*Sa*Da + Sca*(1.0-Da) +\n                 Dca*(1.0-Sa)\n            */\n            pixel=gamma*geometry_info.rho*Sa*Sc*Da*Dc+geometry_info.sigma*\n              Sa*Sc*Da+geometry_info.xi*Da*Dc*Sa+geometry_info.psi*Sa*Da+\n              Sa*Sc*(1.0-Da)+Da*Dc*(1.0-Sa);\n            break;\n          }\n          case MinusDstCompositeOp:\n          {\n            pixel=gamma*(Sa*Sc+Da*Dc-2.0*Da*Dc*Sa);\n            break;\n          }\n          case MinusSrcCompositeOp:\n          {\n            /*\n              Minus source from destination.\n\n                f(Sc,Dc) = Sc - Dc\n            */\n            pixel=QuantumRange*(Da*Dc+Sa*Sc-2.0*Sa*Sc*Da);\n            break;\n          }\n          case ModulateCompositeOp:\n          {\n            ssize_t\n              offset;\n\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            offset=(ssize_t) (GetPixelIntensity(composite_image,p)-midpoint);\n            if (offset == 0)\n              {\n                pixel=Dc;\n                break;\n              }\n            CompositeHCL(destination_pixel.red,destination_pixel.green,\n              destination_pixel.blue,&hue,&chroma,&luma);\n            luma+=(0.01*percent_luma*offset)/midpoint;\n            chroma*=0.01*percent_chroma;\n            HCLComposite(hue,chroma,luma,&red,&green,&blue);\n            switch (channel)\n            {\n              case RedPixelChannel: pixel=red; break;\n              case GreenPixelChannel: pixel=green; break;\n              case BluePixelChannel: pixel=blue; break;\n              default: pixel=Dc; break;\n            }\n            break;\n          }\n          case ModulusAddCompositeOp:\n          {\n            pixel=Sc+Dc;\n            if (pixel > QuantumRange)\n              pixel-=QuantumRange;\n            pixel=gamma*(Sa*Da*pixel+Sa*Sc*(1.0-Da)+Da*Dc*(1.0-Sa));\n            break;\n          }\n          case ModulusSubtractCompositeOp:\n          {\n            pixel=Sc-Dc;\n            if (pixel < 0.0)\n              pixel+=QuantumRange;\n            pixel=gamma*(Sa*Da*pixel+Sa*Sc*(1.0-Da)+Da*Dc*(1.0-Sa));\n            break;\n          }\n          case MultiplyCompositeOp:\n          {\n            pixel=QuantumRange*(Sca*Dca+Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case OutCompositeOp:\n          case SrcOutCompositeOp:\n          {\n            pixel=QuantumRange*(Sca*(1.0-Da));\n            break;\n          }\n          case OverCompositeOp:\n          case SrcOverCompositeOp:\n          {\n            pixel=QuantumRange*(Sca+Dca*(1.0-Sa));\n            break;\n          }\n          case OverlayCompositeOp:\n          {\n            if ((2.0*Dca) <= Da)\n              {\n                pixel=QuantumRange*(2.0*Sca*Dca+Sca*(1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Sa*Da-2.0*(Da-Dca)*(Sa-Sca)+Sca*(1.0-Da)+Dca*\n              (1.0-Sa));\n            break;\n          }\n          case PegtopLightCompositeOp:\n          {\n            /*\n              PegTop: A Soft-Light alternative: A continuous version of the\n              Softlight function, producing very similar results.\n\n                f(Sc,Dc) = Dc^2*(1-2*Sc) + 2*Sc*Dc\n\n              http://www.pegtop.net/delphi/articles/blendmodes/softlight.htm.\n            */\n            if (fabs((double) Da) < MagickEpsilon)\n              {\n                pixel=QuantumRange*(Sca);\n                break;\n              }\n            pixel=QuantumRange*(Dca*Dca*(Sa-2.0*Sca)/Da+Sca*(2.0*Dca+1.0-Da)+\n              Dca*(1.0-Sa));\n            break;\n          }\n          case PinLightCompositeOp:\n          {\n            /*\n              PinLight: A Photoshop 7 composition method\n              http://www.simplefilter.de/en/basics/mixmods.html\n\n                f(Sc,Dc) = Dc<2*Sc-1 ? 2*Sc-1 : Dc>2*Sc   ? 2*Sc : Dc\n            */\n            if ((Dca*Sa) < (Da*(2.0*Sca-Sa)))\n              {\n                pixel=QuantumRange*(Sca*(Da+1.0)-Sa*Da+Dca*(1.0-Sa));\n                break;\n              }\n            if ((Dca*Sa) > (2.0*Sca*Da))\n              {\n                pixel=QuantumRange*(Sca*Da+Sca+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Sca*(1.0-Da)+Dca);\n            break;\n          }\n          case PlusCompositeOp:\n          {\n            pixel=QuantumRange*(Sca+Dca);\n            break;\n          }\n          case SaturateCompositeOp:\n          {\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            if (fabs((double) (QuantumRange*Da-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Sc;\n                break;\n              }\n            CompositeHCL(destination_pixel.red,destination_pixel.green,\n              destination_pixel.blue,&hue,&chroma,&luma);\n            CompositeHCL(source_pixel.red,source_pixel.green,source_pixel.blue,\n              &sans,&chroma,&sans);\n            HCLComposite(hue,chroma,luma,&red,&green,&blue);\n            switch (channel)\n            {\n              case RedPixelChannel: pixel=red; break;\n              case GreenPixelChannel: pixel=green; break;\n              case BluePixelChannel: pixel=blue; break;\n              default: pixel=Dc; break;\n            }\n            break;\n          }\n          case ScreenCompositeOp:\n          {\n            /*\n              Screen:  a negated multiply:\n\n                f(Sc,Dc) = 1.0-(1.0-Sc)*(1.0-Dc)\n            */\n            pixel=QuantumRange*(Sca+Dca-Sca*Dca);\n            break;\n          }\n          case SoftLightCompositeOp:\n          {\n            if ((2.0*Sca) < Sa)\n              {\n                pixel=QuantumRange*(Dca*(Sa+(2.0*Sca-Sa)*(1.0-(Dca/Da)))+Sca*\n                  (1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            if (((2.0*Sca) > Sa) && ((4.0*Dca) <= Da))\n              {\n                pixel=QuantumRange*(Dca*Sa+Da*(2.0*Sca-Sa)*(4.0*(Dca/Da)*(4.0*\n                  (Dca/Da)+1.0)*((Dca/Da)-1.0)+7.0*(Dca/Da))+Sca*(1.0-Da)+Dca*\n                  (1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Dca*Sa+Da*(2.0*Sca-Sa)*(pow((Dca/Da),0.5)-(Dca/\n              Da))+Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case ThresholdCompositeOp:\n          {\n            MagickRealType\n              delta;\n\n            delta=Sc-Dc;\n            if ((MagickRealType) fabs((double) (2.0*delta)) < threshold)\n              {\n                pixel=gamma*Dc;\n                break;\n              }\n            pixel=gamma*(Dc+delta*amount);\n            break;\n          }\n          case VividLightCompositeOp:\n          {\n            /*\n              VividLight: A Photoshop 7 composition method.  See\n              http://www.simplefilter.de/en/basics/mixmods.html.\n\n                f(Sc,Dc) = (2*Sc < 1) ? 1-(1-Dc)/(2*Sc) : Dc/(2*(1-Sc))\n            */\n            if ((fabs((double) Sa) < MagickEpsilon) ||\n                (fabs((double) (Sca-Sa)) < MagickEpsilon))\n              {\n                pixel=QuantumRange*(Sa*Da+Sca*(1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            if ((2.0*Sca) <= Sa)\n              {\n                pixel=QuantumRange*(Sa*(Da+Sa*(Dca-Da)/(2.0*Sca))+Sca*(1.0-Da)+\n                  Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Dca*Sa*Sa/(2.0*(Sa-Sca))+Sca*(1.0-Da)+Dca*\n              (1.0-Sa));\n            break;\n          }\n          case XorCompositeOp:\n          {\n            pixel=QuantumRange*(Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          default:\n          {\n            pixel=Sc;\n            break;\n          }\n        }\n        q[i]=ClampToQuantum(pixel);\n      }\n      p+=GetPixelChannels(composite_image);\n      channels=GetPixelChannels(composite_image);\n      if (p >= (pixels+channels*composite_image->columns))\n        p=pixels;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_CompositeImage)\n#endif\n        proceed=SetImageProgress(image,CompositeImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  composite_view=DestroyCacheView(composite_view);\n  image_view=DestroyCacheView(image_view);\n  if (destination_image != (Image * ) NULL)\n    destination_image=DestroyImage(destination_image);\n  else\n    composite_image=DestroyImage(composite_image);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     T e x t u r e I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TextureImage() repeatedly tiles the texture image across and down the image\n%  canvas.\n%\n%  The format of the TextureImage method is:\n%\n%      MagickBooleanType TextureImage(Image *image,const Image *texture,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o texture_image: This image is the texture to layer on the background.\n%\n*/\nMagickExport MagickBooleanType TextureImage(Image *image,const Image *texture,\n  ExceptionInfo *exception)\n{\n#define TextureImageTag  \"Texture/Image\"\n\n  CacheView\n    *image_view,\n    *texture_view;\n\n  Image\n    *texture_image;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  if (texture == (const Image *) NULL)\n    return(MagickFalse);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  texture_image=CloneImage(texture,0,0,MagickTrue,exception);\n  if (texture_image == (const Image *) NULL)\n    return(MagickFalse);\n  (void) TransformImageColorspace(texture_image,image->colorspace,exception);\n  (void) SetImageVirtualPixelMethod(texture_image,TileVirtualPixelMethod,\n    exception);\n  status=MagickTrue;\n  if ((image->compose != CopyCompositeOp) &&\n      ((image->compose != OverCompositeOp) ||\n       (image->alpha_trait != UndefinedPixelTrait) ||\n       (texture_image->alpha_trait != UndefinedPixelTrait)))\n    {\n      /*\n        Tile texture onto the image background.\n      */\n      for (y=0; y < (ssize_t) image->rows; y+=(ssize_t) texture_image->rows)\n      {\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        for (x=0; x < (ssize_t) image->columns; x+=(ssize_t) texture_image->columns)\n        {\n          MagickBooleanType\n            thread_status;\n\n          thread_status=CompositeImage(image,texture_image,image->compose,\n            MagickFalse,x+texture_image->tile_offset.x,y+\n            texture_image->tile_offset.y,exception);\n          if (thread_status == MagickFalse)\n            {\n              status=thread_status;\n              break;\n            }\n        }\n        if (image->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n            proceed=SetImageProgress(image,TextureImageTag,(MagickOffsetType)\n              y,image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n      (void) SetImageProgress(image,TextureImageTag,(MagickOffsetType)\n        image->rows,image->rows);\n      texture_image=DestroyImage(texture_image);\n      return(status);\n    }\n  /*\n    Tile texture onto the image background (optimized).\n  */\n  status=MagickTrue;\n  texture_view=AcquireVirtualCacheView(texture_image,exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(texture_image,image,1,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    MagickBooleanType\n      sync;\n\n    register const Quantum\n      *p,\n      *pixels;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *q;\n\n    size_t\n      width;\n\n    if (status == MagickFalse)\n      continue;\n    pixels=GetCacheViewVirtualPixels(texture_view,texture_image->tile_offset.x,\n      (y+texture_image->tile_offset.y) % texture_image->rows,\n      texture_image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if ((pixels == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x+=(ssize_t) texture_image->columns)\n    {\n      register ssize_t\n        j;\n\n      p=pixels;\n      width=texture_image->columns;\n      if ((x+(ssize_t) width) > (ssize_t) image->columns)\n        width=image->columns-x;\n      for (j=0; j < (ssize_t) width; j++)\n      {\n        register ssize_t\n          i;\n\n        if (GetPixelReadMask(image,q) == 0)\n          {\n            p+=GetPixelChannels(texture_image);\n            q+=GetPixelChannels(image);\n            continue;\n          }\n        for (i=0; i < (ssize_t) GetPixelChannels(texture_image); i++)\n        {\n          PixelChannel channel=GetPixelChannelChannel(texture_image,i);\n          PixelTrait traits=GetPixelChannelTraits(image,channel);\n          PixelTrait texture_traits=GetPixelChannelTraits(texture_image,\n            channel);\n          if ((traits == UndefinedPixelTrait) ||\n              (texture_traits == UndefinedPixelTrait))\n            continue;\n          SetPixelChannel(image,channel,p[i],q);\n        }\n        p+=GetPixelChannels(texture_image);\n        q+=GetPixelChannels(image);\n      }\n    }\n    sync=SyncCacheViewAuthenticPixels(image_view,exception);\n    if (sync == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n        proceed=SetImageProgress(image,TextureImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  texture_view=DestroyCacheView(texture_view);\n  image_view=DestroyCacheView(image_view);\n  texture_image=DestroyImage(texture_image);\n  return(status);\n}\n", "/*\n  Copyright 1999-2015 ImageMagick Studio LLC, a non-profit organization\n  dedicated to making software imaging solutions freely available.\n\n  You may not use this file except in compliance with the License.\n  obtain a copy of the License at\n\n    http://www.imagemagick.org/script/license.php\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n  MagickCore pixel accessor methods.\n*/\n#ifndef _MAGICKCORE_PIXEL_ACCESSOR_H\n#define _MAGICKCORE_PIXEL_ACCESSOR_H\n\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/image.h\"\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#undef index\n\nstatic inline Quantum GetPixela(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[aPixelChannel].offset]);\n}\n\nstatic inline Quantum GetPixelAlpha(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  if (image->channel_map[AlphaPixelChannel].traits == UndefinedPixelTrait)\n    return(OpaqueAlpha);\n  return(pixel[image->channel_map[AlphaPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelAlphaTraits(const Image *restrict image)\n{\n  return(image->channel_map[AlphaPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelb(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[bPixelChannel].offset]);\n}\n\nstatic inline Quantum GetPixelBlack(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  if (image->channel_map[BlackPixelChannel].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[BlackPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelBlackTraits(const Image *restrict image)\n{\n  return(image->channel_map[BlackPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelBlue(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[BluePixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelBlueTraits(const Image *restrict image)\n{\n  return(image->channel_map[BluePixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelCb(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[CbPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelCbTraits(const Image *restrict image)\n{\n  return(image->channel_map[CbPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelChannel(const Image *restrict image,\n  const PixelChannel channel,const Quantum *restrict pixel)\n{\n  if (image->channel_map[channel].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[channel].offset]);\n}\n\nstatic inline PixelChannel GetPixelChannelChannel(const Image *restrict image,\n  const ssize_t offset)\n{\n  return(image->channel_map[offset].channel);\n}\n\nstatic inline ssize_t GetPixelChannelOffset(const Image *restrict image,\n  const PixelChannel channel)\n{\n  return(image->channel_map[channel].offset);\n}\n\nstatic inline PixelTrait GetPixelChannelTraits(const Image *restrict image,\n  const PixelChannel channel)\n{\n  return(image->channel_map[channel].traits);\n}\n\nstatic inline size_t GetPixelChannels(const Image *restrict image)\n{\n  return(image->number_channels);\n}\n\nstatic inline Quantum GetPixelCr(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[CrPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelCrTraits(const Image *restrict image)\n{\n  return(image->channel_map[CrPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelCyan(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[CyanPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelCyanTraits(const Image *restrict image)\n{\n  return(image->channel_map[CyanPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelGray(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[GrayPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelGrayTraits(const Image *restrict image)\n{\n  return(image->channel_map[GrayPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelGreen(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[GreenPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelGreenTraits(const Image *restrict image)\n{\n  return(image->channel_map[GreenPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelIndex(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  if (image->channel_map[IndexPixelChannel].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[IndexPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelIndexTraits(const Image *restrict image)\n{\n  return(image->channel_map[IndexPixelChannel].traits);\n}\n\nstatic inline MagickRealType GetPixelInfoChannel(\n  const PixelInfo *restrict pixel_info,const PixelChannel channel)\n{\n  switch (channel)\n  {\n    case RedPixelChannel: return(pixel_info->red);\n    case GreenPixelChannel: return(pixel_info->green);\n    case BluePixelChannel: return(pixel_info->blue);\n    case BlackPixelChannel: return(pixel_info->black);\n    case AlphaPixelChannel: return(pixel_info->alpha);\n    case IndexPixelChannel: return(pixel_info->index);\n    default: return((MagickRealType) 0.0);\n  }\n}\n\nstatic inline MagickRealType GetPixelInfoLuma(const PixelInfo *restrict pixel)\n{\n  MagickRealType\n    blue,\n    green,\n    red;\n\n  if (pixel->colorspace == GRAYColorspace)\n    return(pixel->red);\n  if (pixel->colorspace == sRGBColorspace)\n    return(0.212656f*pixel->red+0.715158f*pixel->green+0.072186f*pixel->blue);\n  red=EncodePixelGamma(pixel->red);\n  green=EncodePixelGamma(pixel->green);\n  blue=EncodePixelGamma(pixel->blue);\n  return(0.212656f*red+0.715158f*green+0.072186f*blue);\n}\n\nstatic inline MagickRealType GetPixelInfoLuminance(\n  const PixelInfo *restrict pixel)\n{\n  MagickRealType\n    blue,\n    green,\n    red;\n\n  if (pixel->colorspace == GRAYColorspace)\n    return(pixel->red);\n  if (pixel->colorspace != sRGBColorspace)\n    return(0.212656f*pixel->red+0.715158f*pixel->green+0.072186f*pixel->blue);\n  red=DecodePixelGamma(pixel->red);\n  green=DecodePixelGamma(pixel->green);\n  blue=DecodePixelGamma(pixel->blue);\n  return(0.212656f*red+0.715158f*green+0.072186f*blue);\n}\n\nstatic inline Quantum GetPixelL(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[LPixelChannel].offset]);\n}\n\nstatic inline MagickRealType GetPixelLuma(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  if (image->colorspace == GRAYColorspace)\n    return((MagickRealType) pixel[image->channel_map[GrayPixelChannel].offset]);\n  return(0.212656f*pixel[image->channel_map[RedPixelChannel].offset]+\n    0.715158f*pixel[image->channel_map[GreenPixelChannel].offset]+\n    0.072186f*pixel[image->channel_map[BluePixelChannel].offset]);  /* Rec709 */\n}\n\nstatic inline MagickRealType GetPixelLuminance(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  MagickRealType\n    blue,\n    green,\n    red;\n\n  if (image->colorspace == GRAYColorspace)\n    return((MagickRealType) pixel[image->channel_map[GrayPixelChannel].offset]);\n  if (image->colorspace != sRGBColorspace)\n    return(0.212656f*pixel[image->channel_map[RedPixelChannel].offset]+\n      0.715158f*pixel[image->channel_map[GreenPixelChannel].offset]+\n      0.072186f*pixel[image->channel_map[BluePixelChannel].offset]);\n  red=DecodePixelGamma((MagickRealType)\n    pixel[image->channel_map[RedPixelChannel].offset]);\n  green=DecodePixelGamma((MagickRealType)\n    pixel[image->channel_map[GreenPixelChannel].offset]);\n  blue=DecodePixelGamma((MagickRealType)\n    pixel[image->channel_map[BluePixelChannel].offset]);\n  return(0.212656f*red+0.715158f*green+0.072186f*blue);  /* Rec709 */\n}\n\nstatic inline Quantum GetPixelMagenta(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[MagentaPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelMagentaTraits(const Image *restrict image)\n{\n  return(image->channel_map[MagentaPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelReadMask(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  if (image->channel_map[ReadMaskPixelChannel].traits == UndefinedPixelTrait)\n    return((Quantum) QuantumRange);\n  return(pixel[image->channel_map[ReadMaskPixelChannel].offset]);\n}\n\nstatic inline Quantum GetPixelWriteMask(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  if (image->channel_map[WriteMaskPixelChannel].traits == UndefinedPixelTrait)\n    return((Quantum) QuantumRange);\n  return(pixel[image->channel_map[WriteMaskPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelReadMaskTraits(const Image *restrict image)\n{\n  return(image->channel_map[ReadMaskPixelChannel].traits);\n}\n\nstatic inline size_t GetPixelMetaChannels(const Image *restrict image)\n{\n  return(image->number_meta_channels);\n}\n\nstatic inline size_t GetPixelMetacontentExtent(const Image *restrict image)\n{\n  return(image->metacontent_extent);\n}\n\nstatic inline Quantum GetPixelOpacity(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  if (image->channel_map[AlphaPixelChannel].traits != BlendPixelTrait)\n    return(QuantumRange-OpaqueAlpha);\n  return(QuantumRange-pixel[image->channel_map[AlphaPixelChannel].offset]);\n}\n\nstatic inline Quantum GetPixelRed(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[RedPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelRedTraits(const Image *restrict image)\n{\n  return(image->channel_map[RedPixelChannel].traits);\n}\n\nstatic inline void GetPixelInfoPixel(const Image *restrict image,\n  const Quantum *restrict pixel,PixelInfo *restrict pixel_info)\n{\n  pixel_info->colorspace=image->colorspace;\n  pixel_info->fuzz=image->fuzz;\n  pixel_info->red=(MagickRealType)\n    pixel[image->channel_map[RedPixelChannel].offset];\n  pixel_info->green=(MagickRealType)\n    pixel[image->channel_map[GreenPixelChannel].offset];\n  pixel_info->blue=(MagickRealType)\n    pixel[image->channel_map[BluePixelChannel].offset];\n  pixel_info->black=0.0f;\n  if (image->channel_map[BlackPixelChannel].traits != UndefinedPixelTrait)\n    pixel_info->black=(MagickRealType)\n      pixel[image->channel_map[BlackPixelChannel].offset];\n  pixel_info->alpha=(MagickRealType) OpaqueAlpha;\n  pixel_info->alpha_trait=UndefinedPixelTrait;\n  if (image->channel_map[AlphaPixelChannel].traits != UndefinedPixelTrait)\n    {\n      pixel_info->alpha=(MagickRealType)\n        pixel[image->channel_map[AlphaPixelChannel].offset];\n      pixel_info->alpha_trait=BlendPixelTrait;\n    }\n  pixel_info->index=0.0f;\n  if (image->channel_map[IndexPixelChannel].traits != UndefinedPixelTrait)\n    pixel_info->index=(MagickRealType)\n      pixel[image->channel_map[IndexPixelChannel].offset];\n}\n\nstatic inline PixelTrait GetPixelTraits(const Image *restrict image,\n  const PixelChannel channel)\n{\n  return(image->channel_map[channel].traits);\n}\n\nstatic inline Quantum GetPixelY(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[YPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelYTraits(const Image *restrict image)\n{\n  return(image->channel_map[YPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelYellow(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[YellowPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelYellowTraits(const Image *restrict image)\n{\n  return(image->channel_map[YellowPixelChannel].traits);\n}\n\nstatic inline MagickRealType AbsolutePixelValue(const MagickRealType x)\n{\n  return(x < 0.0f ? -x : x);\n}\n\nstatic inline MagickBooleanType IsPixelAtDepth(const Quantum pixel,\n  const QuantumAny range)\n{\n  Quantum\n    quantum;\n\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  quantum=(Quantum) (((MagickRealType) QuantumRange*((QuantumAny) \n    (((MagickRealType) range*pixel)/QuantumRange+0.5)))/range+0.5);\n#else\n  quantum=(Quantum) (((MagickRealType) QuantumRange*((QuantumAny) \n    (((MagickRealType) range*pixel)/QuantumRange+0.5)))/range);\n#endif\n  return(pixel == quantum ? MagickTrue : MagickFalse);\n}\n\nstatic inline MagickBooleanType IsPixelEquivalent(const Image *restrict image,\n  const Quantum *restrict p,const PixelInfo *restrict q)\n{\n  MagickRealType\n    blue,\n    green,\n    red;\n\n  red=(MagickRealType) p[image->channel_map[RedPixelChannel].offset];\n  green=(MagickRealType) p[image->channel_map[GreenPixelChannel].offset];\n  blue=(MagickRealType) p[image->channel_map[BluePixelChannel].offset];\n  if ((AbsolutePixelValue(red-q->red) < MagickEpsilon) &&\n      (AbsolutePixelValue(green-q->green) < MagickEpsilon) &&\n      (AbsolutePixelValue(blue-q->blue) < MagickEpsilon))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic inline MagickBooleanType IsPixelGray(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  MagickRealType\n    blue,\n    green,\n    red;\n\n  red=(MagickRealType) pixel[image->channel_map[RedPixelChannel].offset];\n  green=(MagickRealType) pixel[image->channel_map[GreenPixelChannel].offset];\n  blue=(MagickRealType) pixel[image->channel_map[BluePixelChannel].offset];\n  if ((AbsolutePixelValue(red-green) < MagickEpsilon) &&\n      (AbsolutePixelValue(green-blue) < MagickEpsilon))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic inline MagickBooleanType IsPixelInfoEquivalent(\n  const PixelInfo *restrict p,const PixelInfo *restrict q)\n{\n  if ((p->alpha_trait != UndefinedPixelTrait) &&\n      (q->alpha_trait == UndefinedPixelTrait) &&\n      (AbsolutePixelValue(p->alpha-OpaqueAlpha) >= MagickEpsilon))\n    return(MagickFalse);\n  if ((q->alpha_trait != UndefinedPixelTrait) &&\n      (p->alpha_trait == UndefinedPixelTrait) &&\n      (AbsolutePixelValue(q->alpha-OpaqueAlpha)) >= MagickEpsilon)\n    return(MagickFalse);\n  if ((p->alpha_trait != UndefinedPixelTrait) &&\n      (q->alpha_trait != UndefinedPixelTrait))\n    {\n      if (AbsolutePixelValue(p->alpha-q->alpha) >= MagickEpsilon)\n        return(MagickFalse);\n      if (AbsolutePixelValue(p->alpha-TransparentAlpha) < MagickEpsilon)\n        return(MagickTrue);\n    }\n  if (AbsolutePixelValue(p->red-q->red) >= MagickEpsilon)\n    return(MagickFalse);\n  if (AbsolutePixelValue(p->green-q->green) >= MagickEpsilon)\n    return(MagickFalse);\n  if (AbsolutePixelValue(p->blue-q->blue) >= MagickEpsilon)\n    return(MagickFalse);\n  if ((p->colorspace == CMYKColorspace) &&\n      (AbsolutePixelValue(p->black-q->black) >= MagickEpsilon))\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\nstatic inline MagickBooleanType IsPixelMonochrome(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  MagickRealType\n    blue,\n    green,\n    red;\n\n  red=(MagickRealType) pixel[image->channel_map[RedPixelChannel].offset];\n  if ((AbsolutePixelValue(red) >= MagickEpsilon) ||\n      (AbsolutePixelValue(red-QuantumRange) >= MagickEpsilon))\n    return(MagickFalse);\n  green=(MagickRealType) pixel[image->channel_map[GreenPixelChannel].offset];\n  blue=(MagickRealType) pixel[image->channel_map[BluePixelChannel].offset];\n  if ((AbsolutePixelValue(red-green) < MagickEpsilon) &&\n      (AbsolutePixelValue(green-blue) < MagickEpsilon))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic inline MagickBooleanType IsPixelInfoGray(\n  const PixelInfo *restrict pixel_info)\n{\n  if ((pixel_info->colorspace != GRAYColorspace) &&\n      (pixel_info->colorspace != RGBColorspace))\n    return(MagickFalse);\n  if ((AbsolutePixelValue(pixel_info->red-pixel_info->green) < MagickEpsilon) &&\n      (AbsolutePixelValue(pixel_info->green-pixel_info->blue) < MagickEpsilon))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic inline MagickBooleanType IsPixelInfoMonochrome(\n  const PixelInfo *restrict pixel_info)\n{\n  if ((pixel_info->colorspace != GRAYColorspace) &&\n      (pixel_info->colorspace != RGBColorspace))\n    return(MagickFalse);\n  if ((AbsolutePixelValue(pixel_info->red) >= MagickEpsilon) ||\n      (AbsolutePixelValue(pixel_info->red-QuantumRange) >= MagickEpsilon))\n    return(MagickFalse);\n  if ((AbsolutePixelValue(pixel_info->red-pixel_info->green) < MagickEpsilon) &&\n      (AbsolutePixelValue(pixel_info->green-pixel_info->blue) < MagickEpsilon))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic inline void SetPixela(const Image *restrict image,\n  const Quantum a,Quantum *restrict pixel)\n{\n  if (image->channel_map[aPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[aPixelChannel].offset]=a;\n}\n\nstatic inline void SetPixelAlpha(const Image *restrict image,\n  const Quantum alpha,Quantum *restrict pixel)\n{\n  if (image->channel_map[AlphaPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[AlphaPixelChannel].offset]=alpha;\n}\n\nstatic inline void SetPixelAlphaTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[AlphaPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelb(const Image *restrict image,\n  const Quantum b,Quantum *restrict pixel)\n{\n  if (image->channel_map[bPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[bPixelChannel].offset]=b;\n}\n\nstatic inline void SetPixelBackgoundColor(const Image *restrict image,\n  Quantum *restrict pixel)\n{\n  register ssize_t\n    i;\n\n  for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n    pixel[i]=0;\n  pixel[image->channel_map[RedPixelChannel].offset]=\n    ClampToQuantum(image->background_color.red);\n  pixel[image->channel_map[GreenPixelChannel].offset]=\n    ClampToQuantum(image->background_color.green);\n  pixel[image->channel_map[BluePixelChannel].offset]=\n    ClampToQuantum(image->background_color.blue);\n  if (image->channel_map[BlackPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[BlackPixelChannel].offset]=\n      ClampToQuantum(image->background_color.black);\n  if (image->channel_map[AlphaPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[AlphaPixelChannel].offset]=\n      image->background_color.alpha_trait == UndefinedPixelTrait ? OpaqueAlpha :\n      ClampToQuantum(image->background_color.alpha);\n}\n\nstatic inline void SetPixelBlack(const Image *restrict image,\n  const Quantum black,Quantum *restrict pixel)\n{\n  if (image->channel_map[BlackPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[BlackPixelChannel].offset]=black;\n}\n\nstatic inline void SetPixelBlackTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[BlackPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelBlue(const Image *restrict image,const Quantum blue,\n  Quantum *restrict pixel)\n{\n  pixel[image->channel_map[BluePixelChannel].offset]=blue;\n}\n\nstatic inline void SetPixelBlueTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[BluePixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelCb(const Image *restrict image,const Quantum cb,\n  Quantum *restrict pixel)\n{\n  pixel[image->channel_map[CbPixelChannel].offset]=cb;\n}\n\nstatic inline void SetPixelCbTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[CbPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelChannel(const Image *restrict image,\n  const PixelChannel channel,const Quantum quantum,Quantum *restrict pixel)\n{\n  if (image->channel_map[channel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[channel].offset]=quantum;\n}\n\nstatic inline void SetPixelChannelAttributes(const Image *restrict image,\n  const PixelChannel channel,const PixelTrait traits,const ssize_t offset)\n{\n  image->channel_map[offset].channel=channel;\n  image->channel_map[channel].offset=offset;\n  image->channel_map[channel].traits=traits;\n}\n\nstatic inline void SetPixelChannelChannel(const Image *restrict image,\n  const PixelChannel channel,const ssize_t offset)\n{\n  image->channel_map[offset].channel=channel;\n  image->channel_map[channel].offset=offset;\n}\n\nstatic inline void SetPixelChannels(Image *image,const size_t number_channels)\n{\n  image->number_channels=number_channels;\n}\n\nstatic inline void SetPixelChannelTraits(Image *image,\n  const PixelChannel channel,const PixelTrait traits)\n{\n  image->channel_map[channel].traits=traits;\n}\n\nstatic inline void SetPixelCr(const Image *restrict image,const Quantum cr,\n  Quantum *restrict pixel)\n{\n  pixel[image->channel_map[CrPixelChannel].offset]=cr;\n}\n\nstatic inline void SetPixelCrTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[CrPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelCyan(const Image *restrict image,const Quantum cyan,\n  Quantum *restrict pixel)\n{\n  pixel[image->channel_map[CyanPixelChannel].offset]=cyan;\n}\n\nstatic inline void SetPixelGray(const Image *restrict image,const Quantum gray,\n  Quantum *restrict pixel)\n{\n  pixel[image->channel_map[GrayPixelChannel].offset]=gray;\n}\n\nstatic inline void SetPixelGrayTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[GrayPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelGreen(const Image *restrict image,\n  const Quantum green,Quantum *restrict pixel)\n{\n  pixel[image->channel_map[GreenPixelChannel].offset]=green;\n}\n\nstatic inline void SetPixelGreenTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[GreenPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelIndex(const Image *restrict image,\n  const Quantum index,Quantum *restrict pixel)\n{\n  if (image->channel_map[IndexPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[IndexPixelChannel].offset]=index;\n}\n\nstatic inline void SetPixelIndexTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[IndexPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelViaPixelInfo(const Image *restrict image,\n  const PixelInfo *restrict pixel_info,Quantum *restrict pixel)\n{\n  pixel[image->channel_map[RedPixelChannel].offset]=\n    ClampToQuantum(pixel_info->red);\n  pixel[image->channel_map[GreenPixelChannel].offset]=\n    ClampToQuantum(pixel_info->green);\n  pixel[image->channel_map[BluePixelChannel].offset]=\n    ClampToQuantum(pixel_info->blue);\n  if (image->channel_map[BlackPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[BlackPixelChannel].offset]=\n      ClampToQuantum(pixel_info->black);\n  if (image->channel_map[AlphaPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[AlphaPixelChannel].offset]=\n      pixel_info->alpha_trait == UndefinedPixelTrait ? OpaqueAlpha :\n      ClampToQuantum(pixel_info->alpha);\n}\n\nstatic inline void SetPixelL(const Image *restrict image,const Quantum L,\n  Quantum *restrict pixel)\n{\n  if (image->channel_map[LPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[LPixelChannel].offset]=L;\n}\n\nstatic inline void SetPixelMagenta(const Image *restrict image,\n  const Quantum magenta,Quantum *restrict pixel)\n{\n  pixel[image->channel_map[MagentaPixelChannel].offset]=magenta;\n}\n\nstatic inline void SetPixelMagentaTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[MagentaPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelReadMask(const Image *restrict image,\n  const Quantum mask,Quantum *restrict pixel)\n{\n  if (image->channel_map[ReadMaskPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[ReadMaskPixelChannel].offset]=mask;\n}\n\nstatic inline void SetPixelWriteMask(const Image *restrict image,\n  const Quantum mask,Quantum *restrict pixel)\n{\n  if (image->channel_map[WriteMaskPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[WriteMaskPixelChannel].offset]=mask;\n}\n\nstatic inline void SetPixelMetacontentExtent(Image *image,const size_t extent)\n{\n  image->metacontent_extent=extent;\n}\n\nstatic inline void SetPixelOpacity(const Image *restrict image,\n  const Quantum alpha,Quantum *restrict pixel)\n{\n  if (image->channel_map[AlphaPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[AlphaPixelChannel].offset]=QuantumRange-alpha;\n}\n\nstatic inline void SetPixelRed(const Image *restrict image,const Quantum red,\n  Quantum *restrict pixel)\n{\n  pixel[image->channel_map[RedPixelChannel].offset]=red;\n}\n\nstatic inline void SetPixelRedTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[RedPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelYellow(const Image *restrict image,\n  const Quantum yellow,Quantum *restrict pixel)\n{\n  pixel[image->channel_map[YellowPixelChannel].offset]=yellow;\n}\n\nstatic inline void SetPixelYellowTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[YellowPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelY(const Image *restrict image,const Quantum y,\n  Quantum *restrict pixel)\n{\n  pixel[image->channel_map[YPixelChannel].offset]=y;\n}\n\nstatic inline void SetPixelYTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[YPixelChannel].traits=traits;\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\n#endif\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%       TTTTT  H   H  RRRR   EEEEE  SSSSS  H   H   OOO   L      DDDD          %\n%         T    H   H  R   R  E      SS     H   H  O   O  L      D   D         %\n%         T    HHHHH  RRRR   EEE     SSS   HHHHH  O   O  L      D   D         %\n%         T    H   H  R R    E         SS  H   H  O   O  L      D   D         %\n%         T    H   H  R  R   EEEEE  SSSSS  H   H   OOO   LLLLL  DDDD          %\n%                                                                             %\n%                                                                             %\n%                      MagickCore Image Threshold Methods                     %\n%                                                                             %\n%                               Software Design                               %\n%                                    Cristy                                   %\n%                                 October 1996                                %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2015 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/configure.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/decorate.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/effect.h\"\n#include \"MagickCore/fx.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/montage.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/random_.h\"\n#include \"MagickCore/random-private.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/segment.h\"\n#include \"MagickCore/shear.h\"\n#include \"MagickCore/signature-private.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/threshold.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/xml-tree.h\"\n#include \"MagickCore/xml-tree-private.h\"\n\f\n/*\n  Define declarations.\n*/\n#define ThresholdsFilename  \"thresholds.xml\"\n\f\n/*\n  Typedef declarations.\n*/\nstruct _ThresholdMap\n{\n  char\n    *map_id,\n    *description;\n\n  size_t\n    width,\n    height;\n\n  ssize_t\n    divisor,\n    *levels;\n};\n\f\n/*\n  Static declarations.\n*/\nstatic const char\n  *MinimalThresholdMap =\n    \"<?xml version=\\\"1.0\\\"?>\"\n    \"<thresholds>\"\n    \"  <threshold map=\\\"threshold\\\" alias=\\\"1x1\\\">\"\n    \"    <description>Threshold 1x1 (non-dither)</description>\"\n    \"    <levels width=\\\"1\\\" height=\\\"1\\\" divisor=\\\"2\\\">\"\n    \"        1\"\n    \"    </levels>\"\n    \"  </threshold>\"\n    \"  <threshold map=\\\"checks\\\" alias=\\\"2x1\\\">\"\n    \"    <description>Checkerboard 2x1 (dither)</description>\"\n    \"    <levels width=\\\"2\\\" height=\\\"2\\\" divisor=\\\"3\\\">\"\n    \"       1 2\"\n    \"       2 1\"\n    \"    </levels>\"\n    \"  </threshold>\"\n    \"</thresholds>\";\n\f\n/*\n  Forward declarations.\n*/\nstatic ThresholdMap\n  *GetThresholdMapFile(const char *,const char *,const char *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     A d a p t i v e T h r e s h o l d I m a g e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AdaptiveThresholdImage() selects an individual threshold for each pixel\n%  based on the range of intensity values in its local neighborhood.  This\n%  allows for thresholding of an image whose global intensity histogram\n%  doesn't contain distinctive peaks.\n%\n%  The format of the AdaptiveThresholdImage method is:\n%\n%      Image *AdaptiveThresholdImage(const Image *image,const size_t width,\n%        const size_t height,const double bias,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o width: the width of the local neighborhood.\n%\n%    o height: the height of the local neighborhood.\n%\n%    o bias: the mean bias.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *AdaptiveThresholdImage(const Image *image,\n  const size_t width,const size_t height,const double bias,\n  ExceptionInfo *exception)\n{\n#define AdaptiveThresholdImageTag  \"AdaptiveThreshold/Image\"\n\n  CacheView\n    *image_view,\n    *threshold_view;\n\n  Image\n    *threshold_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MagickSizeType\n    number_pixels;\n\n  ssize_t\n    y;\n\n  /*\n    Initialize threshold image attributes.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  threshold_image=CloneImage(image,image->columns,image->rows,MagickTrue,\n    exception);\n  if (threshold_image == (Image *) NULL)\n    return((Image *) NULL);\n  status=SetImageStorageClass(threshold_image,DirectClass,exception);\n  if (status == MagickFalse)\n    {\n      threshold_image=DestroyImage(threshold_image);\n      return((Image *) NULL);\n    }\n  /*\n    Threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  number_pixels=(MagickSizeType) width*height;\n  image_view=AcquireVirtualCacheView(image,exception);\n  threshold_view=AcquireAuthenticCacheView(threshold_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,threshold_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    double\n      channel_bias[MaxPixelChannels],\n      channel_sum[MaxPixelChannels];\n\n    register const Quantum\n      *restrict p,\n      *restrict pixels;\n\n    register Quantum\n      *restrict q;\n\n    register ssize_t\n      i,\n      x;\n\n    ssize_t\n      center,\n      u,\n      v;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) width/2L),y-(ssize_t)\n      (height/2L),image->columns+width,height,exception);\n    q=QueueCacheViewAuthenticPixels(threshold_view,0,y,threshold_image->columns,\n      1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    center=(ssize_t) GetPixelChannels(image)*(image->columns+width)*(height/2L)+\n      GetPixelChannels(image)*(width/2);\n    for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n    {\n      PixelChannel channel=GetPixelChannelChannel(image,i);\n      PixelTrait traits=GetPixelChannelTraits(image,channel);\n      PixelTrait threshold_traits=GetPixelChannelTraits(threshold_image,\n        channel);\n      if ((traits == UndefinedPixelTrait) ||\n          (threshold_traits == UndefinedPixelTrait))\n        continue;\n      if (((threshold_traits & CopyPixelTrait) != 0) ||\n          (GetPixelReadMask(image,p) == 0))\n        {\n          SetPixelChannel(threshold_image,channel,p[center+i],q);\n          continue;\n        }\n      pixels=p;\n      channel_bias[channel]=0.0;\n      channel_sum[channel]=0.0;\n      for (v=0; v < (ssize_t) height; v++)\n      {\n        for (u=0; u < (ssize_t) width; u++)\n        {\n          if (u == (ssize_t) (width-1))\n            channel_bias[channel]+=pixels[i];\n          channel_sum[channel]+=pixels[i];\n          pixels+=GetPixelChannels(image);\n        }\n        pixels+=GetPixelChannels(image)*image->columns;\n      }\n    }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        double\n          mean;\n\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait threshold_traits=GetPixelChannelTraits(threshold_image,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (threshold_traits == UndefinedPixelTrait))\n          continue;\n        if (((threshold_traits & CopyPixelTrait) != 0) ||\n            (GetPixelReadMask(image,p) == 0))\n          {\n            SetPixelChannel(threshold_image,channel,p[center+i],q);\n            continue;\n          }\n        channel_sum[channel]-=channel_bias[channel];\n        channel_bias[channel]=0.0;\n        pixels=p;\n        for (v=0; v < (ssize_t) height; v++)\n        {\n          channel_bias[channel]+=pixels[i];\n          pixels+=(width-1)*GetPixelChannels(image);\n          channel_sum[channel]+=pixels[i];\n          pixels+=GetPixelChannels(image)*(image->columns+1);\n        }\n        mean=(double) (channel_sum[channel]/number_pixels+bias);\n        SetPixelChannel(threshold_image,channel,(Quantum) ((double)\n          p[center+i] <= mean ? 0 : QuantumRange),q);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(threshold_image);\n    }\n    if (SyncCacheViewAuthenticPixels(threshold_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_AdaptiveThresholdImage)\n#endif\n        proceed=SetImageProgress(image,AdaptiveThresholdImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  threshold_image->type=image->type;\n  threshold_view=DestroyCacheView(threshold_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    threshold_image=DestroyImage(threshold_image);\n  return(threshold_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     B i l e v e l I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  BilevelImage() changes the value of individual pixels based on the\n%  intensity of each pixel channel.  The result is a high-contrast image.\n%\n%  More precisely each channel value of the image is 'thresholded' so that if\n%  it is equal to or less than the given value it is set to zero, while any\n%  value greater than that give is set to it maximum or QuantumRange.\n%\n%  This function is what is used to implement the \"-threshold\" operator for\n%  the command line API.\n%\n%  If the default channel setting is given the image is thresholded using just\n%  the gray 'intensity' of the image, rather than the individual channels.\n%\n%  The format of the BilevelImage method is:\n%\n%      MagickBooleanType BilevelImage(Image *image,const double threshold,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o threshold: define the threshold values.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n%  Aside: You can get the same results as operator using LevelImages()\n%  with the 'threshold' value for both the black_point and the white_point.\n%\n*/\nMagickExport MagickBooleanType BilevelImage(Image *image,const double threshold,\n  ExceptionInfo *exception)\n{\n#define ThresholdImageTag  \"Threshold/Image\"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Bilevel threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        pixel;\n\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      pixel=GetPixelIntensity(image,q);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if (image->channel_mask != DefaultChannels)\n          pixel=(double) q[i];\n        q[i]=(Quantum) (pixel <= threshold ? 0 : QuantumRange);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_BilevelImage)\n#endif\n        proceed=SetImageProgress(image,ThresholdImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     B l a c k T h r e s h o l d I m a g e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  BlackThresholdImage() is like ThresholdImage() but forces all pixels below\n%  the threshold into black while leaving all pixels at or above the threshold\n%  unchanged.\n%\n%  The format of the BlackThresholdImage method is:\n%\n%      MagickBooleanType BlackThresholdImage(Image *image,\n%        const char *threshold,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o threshold: define the threshold value.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType BlackThresholdImage(Image *image,\n  const char *thresholds,ExceptionInfo *exception)\n{\n#define ThresholdImageTag  \"Threshold/Image\"\n\n  CacheView\n    *image_view;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PixelInfo\n    threshold;\n\n  MagickStatusType\n    flags;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (thresholds == (const char *) NULL)\n    return(MagickTrue);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  GetPixelInfo(image,&threshold);\n  flags=ParseGeometry(thresholds,&geometry_info);\n  threshold.red=geometry_info.rho;\n  threshold.green=geometry_info.rho;\n  threshold.blue=geometry_info.rho;\n  threshold.black=geometry_info.rho;\n  threshold.alpha=100.0;\n  if ((flags & SigmaValue) != 0)\n    threshold.green=geometry_info.sigma;\n  if ((flags & XiValue) != 0)\n    threshold.blue=geometry_info.xi;\n  if ((flags & PsiValue) != 0)\n    threshold.alpha=geometry_info.psi;\n  if (threshold.colorspace == CMYKColorspace)\n    {\n      if ((flags & PsiValue) != 0)\n        threshold.black=geometry_info.psi;\n      if ((flags & ChiValue) != 0)\n        threshold.alpha=geometry_info.chi;\n    }\n  if ((flags & PercentValue) != 0)\n    {\n      threshold.red*=(MagickRealType) (QuantumRange/100.0);\n      threshold.green*=(MagickRealType) (QuantumRange/100.0);\n      threshold.blue*=(MagickRealType) (QuantumRange/100.0);\n      threshold.black*=(MagickRealType) (QuantumRange/100.0);\n      threshold.alpha*=(MagickRealType) (QuantumRange/100.0);\n    }\n  /*\n    White threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        pixel;\n\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      pixel=GetPixelIntensity(image,q);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if (image->channel_mask != DefaultChannels)\n          pixel=(double) q[i];\n        if (pixel <= GetPixelInfoChannel(&threshold,channel))\n          q[i]=(Quantum) 0;\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_BlackThresholdImage)\n#endif\n        proceed=SetImageProgress(image,ThresholdImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     C l a m p I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClampImage() set each pixel whose value is below zero to zero and any the\n%  pixel whose value is above the quantum range to the quantum range (e.g.\n%  65535) otherwise the pixel value remains unchanged.\n%\n%  The format of the ClampImage method is:\n%\n%      MagickBooleanType ClampImage(Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline Quantum ClampPixel(const MagickRealType value)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((Quantum) value);\n#else\n  if (value < 0.0f)\n    return(0.0);\n  if (value >= (MagickRealType) QuantumRange)\n    return((Quantum) QuantumRange);\n  return(value);\n#endif\n}\n\nMagickExport MagickBooleanType ClampImage(Image *image,ExceptionInfo *exception)\n{\n#define ClampImageTag  \"Clamp/Image\"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->storage_class == PseudoClass)\n    {\n      register ssize_t\n        i;\n\n      register PixelInfo\n        *restrict q;\n\n      q=image->colormap;\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        q->red=(double) ClampPixel(q->red);\n        q->green=(double) ClampPixel(q->green);\n        q->blue=(double) ClampPixel(q->blue);\n        q->alpha=(double) ClampPixel(q->alpha);\n        q++;\n      }\n      return(SyncImage(image,exception));\n    }\n  /*\n    Clamp image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        q[i]=ClampPixel(q[i]);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_ClampImage)\n#endif\n        proceed=SetImageProgress(image,ClampImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  D e s t r o y T h r e s h o l d M a p                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyThresholdMap() de-allocate the given ThresholdMap\n%\n%  The format of the ListThresholdMaps method is:\n%\n%      ThresholdMap *DestroyThresholdMap(Threshold *map)\n%\n%  A description of each parameter follows.\n%\n%    o map:    Pointer to the Threshold map to destroy\n%\n*/\nMagickExport ThresholdMap *DestroyThresholdMap(ThresholdMap *map)\n{\n  assert(map != (ThresholdMap *) NULL);\n  if (map->map_id != (char *) NULL)\n    map->map_id=DestroyString(map->map_id);\n  if (map->description != (char *) NULL)\n    map->description=DestroyString(map->description);\n  if (map->levels != (ssize_t *) NULL)\n    map->levels=(ssize_t *) RelinquishMagickMemory(map->levels);\n  map=(ThresholdMap *) RelinquishMagickMemory(map);\n  return(map);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  G e t T h r e s h o l d M a p                                              %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetThresholdMap() loads and searches one or more threshold map files for the\n%  map matching the given name or alias.\n%\n%  The format of the GetThresholdMap method is:\n%\n%      ThresholdMap *GetThresholdMap(const char *map_id,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o map_id:  ID of the map to look for.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport ThresholdMap *GetThresholdMap(const char *map_id,\n  ExceptionInfo *exception)\n{\n  const StringInfo\n    *option;\n\n  LinkedListInfo\n    *options;\n\n  ThresholdMap\n    *map;\n\n  map=GetThresholdMapFile(MinimalThresholdMap,\"built-in\",map_id,exception);\n  if (map != (ThresholdMap *) NULL)\n    return(map);\n  options=GetConfigureOptions(ThresholdsFilename,exception);\n  option=(const StringInfo *) GetNextValueInLinkedList(options);\n  while (option != (const StringInfo *) NULL)\n  {\n    map=GetThresholdMapFile((const char *) GetStringInfoDatum(option),\n      GetStringInfoPath(option),map_id,exception);\n    if (map != (ThresholdMap *) NULL)\n      break;\n    option=(const StringInfo *) GetNextValueInLinkedList(options);\n  }\n  options=DestroyConfigureOptions(options);\n  return(map);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  G e t T h r e s h o l d M a p F i l e                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetThresholdMapFile() look for a given threshold map name or alias in the\n%  given XML file data, and return the allocated the map when found.\n%\n%  The format of the ListThresholdMaps method is:\n%\n%      ThresholdMap *GetThresholdMap(const char *xml,const char *filename,\n%         const char *map_id,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o xml:  The threshold map list in XML format.\n%\n%    o filename:  The threshold map XML filename.\n%\n%    o map_id:  ID of the map to look for in XML list.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic ThresholdMap *GetThresholdMapFile(const char *xml,const char *filename,\n  const char *map_id,ExceptionInfo *exception)\n{\n  char\n    *p;\n\n  const char\n    *attribute,\n    *content;\n\n  double\n    value;\n\n  register ssize_t\n    i;\n\n  ThresholdMap\n    *map;\n\n  XMLTreeInfo\n    *description,\n    *levels,\n    *threshold,\n    *thresholds;\n\n  (void) LogMagickEvent(ConfigureEvent,GetMagickModule(),\n    \"Loading threshold map file \\\"%s\\\" ...\",filename);\n  map=(ThresholdMap *) NULL;\n  thresholds=NewXMLTree(xml,exception);\n  if (thresholds == (XMLTreeInfo *) NULL)\n    return(map);\n  for (threshold=GetXMLTreeChild(thresholds,\"threshold\");\n       threshold != (XMLTreeInfo *) NULL;\n       threshold=GetNextXMLTreeTag(threshold))\n  {\n    attribute=GetXMLTreeAttribute(threshold,\"map\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(map_id,attribute) == 0))\n      break;\n    attribute=GetXMLTreeAttribute(threshold,\"alias\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(map_id,attribute) == 0))\n      break;\n  }\n  if (threshold == (XMLTreeInfo *) NULL)\n    {\n      thresholds=DestroyXMLTree(thresholds);\n      return(map);\n    }\n  description=GetXMLTreeChild(threshold,\"description\");\n  if (description == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\", \"<description>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      return(map);\n    }\n  levels=GetXMLTreeChild(threshold,\"levels\");\n  if (levels == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\", \"<levels>, map \\\"%s\\\"\", map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      return(map);\n    }\n  map=(ThresholdMap *) AcquireMagickMemory(sizeof(ThresholdMap));\n  if (map == (ThresholdMap *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToAcquireThresholdMap\");\n  map->map_id=(char *) NULL;\n  map->description=(char *) NULL;\n  map->levels=(ssize_t *) NULL;\n  attribute=GetXMLTreeAttribute(threshold,\"map\");\n  if (attribute != (char *) NULL)\n    map->map_id=ConstantString(attribute);\n  content=GetXMLTreeContent(description);\n  if (content != (char *) NULL)\n    map->description=ConstantString(content);\n  attribute=GetXMLTreeAttribute(levels,\"width\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\", \"<levels width>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  map->width=StringToUnsignedLong(attribute);\n  if (map->width == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n       \"XmlInvalidAttribute\", \"<levels width>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"height\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\", \"<levels height>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  map->height=StringToUnsignedLong(attribute);\n  if (map->height == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\", \"<levels height>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"divisor\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\", \"<levels divisor>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  map->divisor=(ssize_t) StringToLong(attribute);\n  if (map->divisor < 2)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\", \"<levels divisor>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  content=GetXMLTreeContent(levels);\n  if (content == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingContent\", \"<levels>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  map->levels=(ssize_t *) AcquireQuantumMemory((size_t) map->width,map->height*\n    sizeof(*map->levels));\n  if (map->levels == (ssize_t *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToAcquireThresholdMap\");\n  for (i=0; i < (ssize_t) (map->width*map->height); i++)\n  {\n    map->levels[i]=(ssize_t) strtol(content,&p,10);\n    if (p == content)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"XmlInvalidContent\", \"<level> too few values, map \\\"%s\\\"\",map_id);\n        thresholds=DestroyXMLTree(thresholds);\n        map=DestroyThresholdMap(map);\n        return(map);\n      }\n    if ((map->levels[i] < 0) || (map->levels[i] > map->divisor))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"XmlInvalidContent\", \"<level> %.20g out of range, map \\\"%s\\\"\",\n          (double) map->levels[i],map_id);\n        thresholds=DestroyXMLTree(thresholds);\n        map=DestroyThresholdMap(map);\n        return(map);\n      }\n    content=p;\n  }\n  value=(double) strtol(content,&p,10);\n  (void) value;\n  if (p != content)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidContent\", \"<level> too many values, map \\\"%s\\\"\",map_id);\n     thresholds=DestroyXMLTree(thresholds);\n     map=DestroyThresholdMap(map);\n     return(map);\n   }\n  thresholds=DestroyXMLTree(thresholds);\n  return(map);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  L i s t T h r e s h o l d M a p F i l e                                    %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ListThresholdMapFile() lists the threshold maps and their descriptions\n%  in the given XML file data.\n%\n%  The format of the ListThresholdMaps method is:\n%\n%      MagickBooleanType ListThresholdMaps(FILE *file,const char*xml,\n%         const char *filename,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o file:  An pointer to the output FILE.\n%\n%    o xml:  The threshold map list in XML format.\n%\n%    o filename:  The threshold map XML filename.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickBooleanType ListThresholdMapFile(FILE *file,const char *xml,\n  const char *filename,ExceptionInfo *exception)\n{\n  const char\n    *alias,\n    *content,\n    *map;\n\n  XMLTreeInfo\n    *description,\n    *threshold,\n    *thresholds;\n\n  assert( xml != (char *) NULL );\n  assert( file != (FILE *) NULL );\n  (void) LogMagickEvent(ConfigureEvent,GetMagickModule(),\n    \"Loading threshold map file \\\"%s\\\" ...\",filename);\n  thresholds=NewXMLTree(xml,exception);\n  if ( thresholds == (XMLTreeInfo *) NULL )\n    return(MagickFalse);\n  (void) FormatLocaleFile(file,\"%-16s %-12s %s\\n\",\"Map\",\"Alias\",\"Description\");\n  (void) FormatLocaleFile(file,\n    \"----------------------------------------------------\\n\");\n  threshold=GetXMLTreeChild(thresholds,\"threshold\");\n  for ( ; threshold != (XMLTreeInfo *) NULL;\n          threshold=GetNextXMLTreeTag(threshold))\n  {\n    map=GetXMLTreeAttribute(threshold,\"map\");\n    if (map == (char *) NULL)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"XmlMissingAttribute\", \"<map>\");\n        thresholds=DestroyXMLTree(thresholds);\n        return(MagickFalse);\n      }\n    alias=GetXMLTreeAttribute(threshold,\"alias\");\n    description=GetXMLTreeChild(threshold,\"description\");\n    if (description == (XMLTreeInfo *) NULL)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"XmlMissingElement\", \"<description>, map \\\"%s\\\"\",map);\n        thresholds=DestroyXMLTree(thresholds);\n        return(MagickFalse);\n      }\n    content=GetXMLTreeContent(description);\n    if (content == (char *) NULL)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"XmlMissingContent\", \"<description>, map \\\"%s\\\"\", map);\n        thresholds=DestroyXMLTree(thresholds);\n        return(MagickFalse);\n      }\n    (void) FormatLocaleFile(file,\"%-16s %-12s %s\\n\",map,alias ? alias : \"\",\n      content);\n  }\n  thresholds=DestroyXMLTree(thresholds);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  L i s t T h r e s h o l d M a p s                                          %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ListThresholdMaps() lists the threshold maps and their descriptions\n%  as defined by \"threshold.xml\" to a file.\n%\n%  The format of the ListThresholdMaps method is:\n%\n%      MagickBooleanType ListThresholdMaps(FILE *file,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o file:  An pointer to the output FILE.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType ListThresholdMaps(FILE *file,\n  ExceptionInfo *exception)\n{\n  const StringInfo\n    *option;\n\n  LinkedListInfo\n    *options;\n\n  MagickStatusType\n    status;\n\n  status=MagickTrue;\n  if (file == (FILE *) NULL)\n    file=stdout;\n  options=GetConfigureOptions(ThresholdsFilename,exception);\n  (void) FormatLocaleFile(file,\n    \"\\n   Threshold Maps for Ordered Dither Operations\\n\");\n  option=(const StringInfo *) GetNextValueInLinkedList(options);\n  while (option != (const StringInfo *) NULL)\n  {\n    (void) FormatLocaleFile(file,\"\\nPath: %s\\n\\n\",GetStringInfoPath(option));\n    status&=ListThresholdMapFile(file,(const char *) GetStringInfoDatum(option),\n      GetStringInfoPath(option),exception);\n    option=(const StringInfo *) GetNextValueInLinkedList(options);\n  }\n  options=DestroyConfigureOptions(options);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     O r d e r e d P o s t e r i z e I m a g e                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  OrderedPosterizeImage() will perform a ordered dither based on a number\n%  of pre-defined dithering threshold maps, but over multiple intensity\n%  levels, which can be different for different channels, according to the\n%  input argument.\n%\n%  The format of the OrderedPosterizeImage method is:\n%\n%      MagickBooleanType OrderedPosterizeImage(Image *image,\n%        const char *threshold_map,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o threshold_map: A string containing the name of the threshold dither\n%      map to use, followed by zero or more numbers representing the number\n%      of color levels tho dither between.\n%\n%      Any level number less than 2 will be equivalent to 2, and means only\n%      binary dithering will be applied to each color channel.\n%\n%      No numbers also means a 2 level (bitmap) dither will be applied to all\n%      channels, while a single number is the number of levels applied to each\n%      channel in sequence.  More numbers will be applied in turn to each of\n%      the color channels.\n%\n%      For example: \"o3x3,6\" will generate a 6 level posterization of the\n%      image with a ordered 3x3 diffused pixel dither being applied between\n%      each level. While checker,8,8,4 will produce a 332 colormaped image\n%      with only a single checkerboard hash pattern (50% grey) between each\n%      color level, to basically double the number of color levels with\n%      a bare minimim of dithering.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType OrderedPosterizeImage(Image *image,\n  const char *threshold_map,ExceptionInfo *exception)\n{\n#define DitherImageTag  \"Dither/Image\"\n\n  CacheView\n    *image_view;\n\n  char\n    token[MaxTextExtent];\n\n  const char\n    *p;\n\n  double\n    levels[CompositePixelChannel];\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  ThresholdMap\n    *map;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  if (threshold_map == (const char *) NULL)\n    return(MagickTrue);\n  p=(char *) threshold_map;\n  while (((isspace((int) ((unsigned char) *p)) != 0) || (*p == ',')) &&\n         (*p != '\\0'))\n    p++;\n  threshold_map=p;\n  while (((isspace((int) ((unsigned char) *p)) == 0) && (*p != ',')) &&\n         (*p != '\\0'))\n  {\n    if ((p-threshold_map) >= (MaxTextExtent-1))\n      break;\n    token[p-threshold_map]=(*p);\n    p++;\n  }\n  token[p-threshold_map]='\\0';\n  map=GetThresholdMap(token,exception);\n  if (map == (ThresholdMap *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"InvalidArgument\",\"%s : '%s'\",\"ordered-dither\",threshold_map);\n      return(MagickFalse);\n    }\n  for (i=0; i < MaxPixelChannels; i++)\n    levels[i]=2.0;\n  p=strchr((char *) threshold_map,',');\n  if ((p != (char *) NULL) && (isdigit((int) ((unsigned char) *(++p))) != 0))\n    for (i=0; (*p != '\\0') && (i < MaxPixelChannels); i++)\n    {\n      GetMagickToken(p,&p,token);\n      if (*token == ',')\n        GetMagickToken(p,&p,token);\n      levels[i]=StringToDouble(token,(char **) NULL);\n    }\n  for (i=0; i < MaxPixelChannels; i++)\n    if (fabs(levels[i]) >= 1)\n      levels[i]-=1.0;\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      ssize_t\n        n;\n\n      n=0;\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        ssize_t\n          level,\n          threshold;\n\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if (fabs(levels[n++]) < MagickEpsilon)\n          continue;\n        threshold=(ssize_t) (QuantumScale*q[i]*(levels[n]*(map->divisor-1)+1));\n        level=threshold/(map->divisor-1);\n        threshold-=level*(map->divisor-1);\n        q[i]=ClampToQuantum((double) (level+(threshold >=\n          map->levels[(x % map->width)+map->width*(y % map->height)]))*\n          QuantumRange/levels[n]);\n        n++;\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_OrderedPosterizeImage)\n#endif\n        proceed=SetImageProgress(image,DitherImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  map=DestroyThresholdMap(map);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     P e r c e p t i b l e I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PerceptibleImage() set each pixel whose value is less than |epsilon| to\n%  epsilon or -epsilon (whichever is closer) otherwise the pixel value remains\n%  unchanged.\n%\n%  The format of the PerceptibleImage method is:\n%\n%      MagickBooleanType PerceptibleImage(Image *image,const double epsilon,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o epsilon: the epsilon threshold (e.g. 1.0e-9).\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline Quantum PerceptibleThreshold(const Quantum quantum,\n  const double epsilon)\n{\n  double\n    sign;\n\n  sign=(double) quantum < 0.0 ? -1.0 : 1.0;\n  if ((sign*quantum) >= epsilon)\n    return(quantum);\n  return((Quantum) (sign*epsilon));\n}\n\nMagickExport MagickBooleanType PerceptibleImage(Image *image,\n  const double epsilon,ExceptionInfo *exception)\n{\n#define PerceptibleImageTag  \"Perceptible/Image\"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->storage_class == PseudoClass)\n    {\n      register ssize_t\n        i;\n\n      register PixelInfo\n        *restrict q;\n\n      q=image->colormap;\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        q->red=(double) PerceptibleThreshold(ClampToQuantum(q->red),\n          epsilon);\n        q->green=(double) PerceptibleThreshold(ClampToQuantum(q->green),\n          epsilon);\n        q->blue=(double) PerceptibleThreshold(ClampToQuantum(q->blue),\n          epsilon);\n        q->alpha=(double) PerceptibleThreshold(ClampToQuantum(q->alpha),\n          epsilon);\n        q++;\n      }\n      return(SyncImage(image,exception));\n    }\n  /*\n    Perceptible image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        q[i]=PerceptibleThreshold(q[i],epsilon);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_PerceptibleImage)\n#endif\n        proceed=SetImageProgress(image,PerceptibleImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     R a n d o m T h r e s h o l d I m a g e                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RandomThresholdImage() changes the value of individual pixels based on the\n%  intensity of each pixel compared to a random threshold.  The result is a\n%  low-contrast, two color image.\n%\n%  The format of the RandomThresholdImage method is:\n%\n%      MagickBooleanType RandomThresholdImage(Image *image,\n%        const char *thresholds,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o thresholds: a geometry string containing low,high thresholds.  If the\n%      string contains 2x2, 3x3, or 4x4, an ordered dither of order 2, 3, or 4\n%      is performed instead.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType RandomThresholdImage(Image *image,\n  const char *thresholds,ExceptionInfo *exception)\n{\n#define ThresholdImageTag  \"Threshold/Image\"\n\n  CacheView\n    *image_view;\n\n  double\n    min_threshold,\n    max_threshold;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickStatusType\n    flags;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PixelInfo\n    threshold;\n\n  RandomInfo\n    **restrict random_info;\n\n  ssize_t\n    y;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  unsigned long\n    key;\n#endif\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  if (thresholds == (const char *) NULL)\n    return(MagickTrue);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  GetPixelInfo(image,&threshold);\n  min_threshold=0.0;\n  max_threshold=(double) QuantumRange;\n  flags=ParseGeometry(thresholds,&geometry_info);\n  min_threshold=geometry_info.rho;\n  max_threshold=geometry_info.sigma;\n  if ((flags & SigmaValue) == 0)\n    max_threshold=min_threshold;\n  if (strchr(thresholds,'%') != (char *) NULL)\n    {\n      max_threshold*=(double) (0.01*QuantumRange);\n      min_threshold*=(double) (0.01*QuantumRange);\n    }\n  /*\n    Random threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  random_info=AcquireRandomInfoThreadSet();\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  key=GetRandomSecretKey(random_info[0]);\n#endif\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,key == ~0UL)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    register Quantum\n      *restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        double\n          threshold;\n\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if ((double) q[i] < min_threshold)\n          threshold=min_threshold;\n        else\n          if ((double) q[i] > max_threshold)\n            threshold=max_threshold;\n          else\n            threshold=(double) (QuantumRange*\n              GetPseudoRandomValue(random_info[id]));\n        q[i]=(double) q[i] <= threshold ? 0 : QuantumRange;\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_RandomThresholdImage)\n#endif\n        proceed=SetImageProgress(image,ThresholdImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  random_info=DestroyRandomInfoThreadSet(random_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     W h i t e T h r e s h o l d I m a g e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WhiteThresholdImage() is like ThresholdImage() but forces all pixels above\n%  the threshold into white while leaving all pixels at or below the threshold\n%  unchanged.\n%\n%  The format of the WhiteThresholdImage method is:\n%\n%      MagickBooleanType WhiteThresholdImage(Image *image,\n%        const char *threshold,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o threshold: Define the threshold value.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType WhiteThresholdImage(Image *image,\n  const char *thresholds,ExceptionInfo *exception)\n{\n#define ThresholdImageTag  \"Threshold/Image\"\n\n  CacheView\n    *image_view;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PixelInfo\n    threshold;\n\n  MagickStatusType\n    flags;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (thresholds == (const char *) NULL)\n    return(MagickTrue);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  GetPixelInfo(image,&threshold);\n  flags=ParseGeometry(thresholds,&geometry_info);\n  threshold.red=geometry_info.rho;\n  threshold.green=geometry_info.rho;\n  threshold.blue=geometry_info.rho;\n  threshold.black=geometry_info.rho;\n  threshold.alpha=100.0;\n  if ((flags & SigmaValue) != 0)\n    threshold.green=geometry_info.sigma;\n  if ((flags & XiValue) != 0)\n    threshold.blue=geometry_info.xi;\n  if ((flags & PsiValue) != 0)\n    threshold.alpha=geometry_info.psi;\n  if (threshold.colorspace == CMYKColorspace)\n    {\n      if ((flags & PsiValue) != 0)\n        threshold.black=geometry_info.psi;\n      if ((flags & ChiValue) != 0)\n        threshold.alpha=geometry_info.chi;\n    }\n  if ((flags & PercentValue) != 0)\n    {\n      threshold.red*=(MagickRealType) (QuantumRange/100.0);\n      threshold.green*=(MagickRealType) (QuantumRange/100.0);\n      threshold.blue*=(MagickRealType) (QuantumRange/100.0);\n      threshold.black*=(MagickRealType) (QuantumRange/100.0);\n      threshold.alpha*=(MagickRealType) (QuantumRange/100.0);\n    }\n  /*\n    White threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        pixel;\n\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      pixel=GetPixelIntensity(image,q);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if (image->channel_mask != DefaultChannels)\n          pixel=(double) q[i];\n        if (pixel > GetPixelInfoChannel(&threshold,channel))\n          q[i]=QuantumRange;\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_WhiteThresholdImage)\n#endif\n        proceed=SetImageProgress(image,ThresholdImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            SSSSS  U   U  N   N                              %\n%                            SS     U   U  NN  N                              %\n%                             SSS   U   U  N N N                              %\n%                               SS  U   U  N  NN                              %\n%                            SSSSS   UUU   N   N                              %\n%                                                                             %\n%                                                                             %\n%                    Read/Write Sun Rasterfile Image Format                   %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2015 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteSUNImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s S U N                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsSUN() returns MagickTrue if the image format type, identified by the\n%  magick string, is SUN.\n%\n%  The format of the IsSUN method is:\n%\n%      MagickBooleanType IsSUN(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsSUN(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\131\\246\\152\\225\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DecodeImage unpacks the packed image pixels into  runlength-encoded pixel\n%  packets.\n%\n%  The format of the DecodeImage method is:\n%\n%      MagickBooleanType DecodeImage(const unsigned char *compressed_pixels,\n%        const size_t length,unsigned char *pixels)\n%\n%  A description of each parameter follows:\n%\n%    o compressed_pixels:  The address of a byte (8 bits) array of compressed\n%      pixel data.\n%\n%    o length:  An integer value that is the total number of bytes of the\n%      source image (as just read by ReadBlob)\n%\n%    o pixels:  The address of a byte (8 bits) array of pixel data created by\n%      the uncompression process.  The number of bytes in this array\n%      must be at least equal to the number columns times the number of rows\n%      of the source pixels.\n%\n*/\nstatic MagickBooleanType DecodeImage(const unsigned char *compressed_pixels,\n  const size_t length,unsigned char *pixels,size_t maxpixels)\n{\n  register const unsigned char\n    *l,\n    *p;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    count;\n\n  unsigned char\n    byte;\n\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(compressed_pixels != (unsigned char *) NULL);\n  assert(pixels != (unsigned char *) NULL);\n  p=compressed_pixels;\n  q=pixels;\n  l=q+maxpixels;\n  while (((size_t) (p-compressed_pixels) < length) && (q < l))\n  {\n    byte=(*p++);\n    if (byte != 128U)\n      *q++=byte;\n    else\n      {\n        /*\n          Runlength-encoded packet: <count><byte>\n        */\n        count=(ssize_t) (*p++);\n        if (count > 0)\n          byte=(*p++);\n        while ((count >= 0) && (q < l))\n        {\n          *q++=byte;\n          count--;\n        }\n     }\n  }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d S U N I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadSUNImage() reads a SUN image file and returns it.  It allocates\n%  the memory necessary for the new Image structure and returns a pointer to\n%  the new image.\n%\n%  The format of the ReadSUNImage method is:\n%\n%      Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define RMT_EQUAL_RGB  1\n#define RMT_NONE  0\n#define RMT_RAW  2\n#define RT_STANDARD  1\n#define RT_ENCODED  2\n#define RT_FORMAT_RGB  3\n\n  typedef struct _SUNInfo\n  {\n    unsigned int\n      magic,\n      width,\n      height,\n      depth,\n      length,\n      type,\n      maptype,\n      maplength;\n  } SUNInfo;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_line,\n    extent,\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  SUNInfo\n    sun_info;\n\n  unsigned char\n    *sun_data,\n    *sun_pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SUN raster header.\n  */\n  (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));\n  sun_info.magic=ReadBlobMSBLong(image);\n  do\n  {\n    /*\n      Verify SUN identifier.\n    */\n    if (sun_info.magic != 0x59a66a95)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    sun_info.width=ReadBlobMSBLong(image);\n    sun_info.height=ReadBlobMSBLong(image);\n    sun_info.depth=ReadBlobMSBLong(image);\n    sun_info.length=ReadBlobMSBLong(image);\n    sun_info.type=ReadBlobMSBLong(image);\n    sun_info.maptype=ReadBlobMSBLong(image);\n    sun_info.maplength=ReadBlobMSBLong(image);\n    extent=sun_info.height*sun_info.width;\n    if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&\n        (sun_info.type != RT_FORMAT_RGB))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.depth == 0) || (sun_info.depth > 32))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&\n        (sun_info.maptype != RMT_RAW))\n      ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    image->depth=sun_info.depth <= 8 ? sun_info.depth :\n      MAGICKCORE_QUANTUM_DEPTH;\n    if (sun_info.depth < 24)\n      {\n        size_t\n          one;\n\n        image->colors=sun_info.maplength;\n        one=1;\n        if (sun_info.maptype == RMT_NONE)\n          image->colors=one << sun_info.depth;\n        if (sun_info.maptype == RMT_EQUAL_RGB)\n          image->colors=sun_info.maplength/3;\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    switch (sun_info.maptype)\n    {\n      case RMT_EQUAL_RGB:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      case RMT_RAW:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,sun_info.maplength,sun_colormap);\n        if (count != (ssize_t) sun_info.maplength)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    if ((sun_info.length*sizeof(*sun_data))/sizeof(*sun_data) !=\n        sun_info.length || !sun_info.length)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((sun_info.type != RT_ENCODED) && (sun_info.depth >= 8) &&\n        ((number_pixels*((sun_info.depth+7)/8)) > sun_info.length))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    bytes_per_line=sun_info.width*sun_info.depth;\n    sun_data=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(\n      sun_info.length,bytes_per_line*sun_info.width),sizeof(*sun_data));\n    if (sun_data == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);\n    if (count != (ssize_t) sun_info.length)\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    sun_pixels=sun_data;\n    bytes_per_line=0;\n    if (sun_info.type == RT_ENCODED)\n      {\n        size_t\n          height;\n\n        /*\n          Read run-length encoded raster pixels.\n        */\n        height=sun_info.height;\n        if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||\n            ((bytes_per_line/sun_info.depth) != sun_info.width))\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        bytes_per_line+=15;\n        bytes_per_line<<=1;\n        if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15))\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        bytes_per_line>>=4;\n        sun_pixels=(unsigned char *) AcquireQuantumMemory(height,\n          bytes_per_line*sizeof(*sun_pixels));\n        if (sun_pixels == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line*\n          height);\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n      }\n    /*\n      Convert SUN raster image to pixel packets.\n    */\n    p=sun_pixels;\n    if (sun_info.depth == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=7; bit >= 0; bit--)\n          {\n            SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),\n              q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)\n            {\n              SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 :\n                0x01),q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n        if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)\n          p++;\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        {\n          if (bytes_per_line == 0)\n            bytes_per_line=image->columns;\n          length=image->rows*(image->columns+image->columns % 2);\n          if (((sun_info.type == RT_ENCODED) &&\n               (length > (bytes_per_line*image->rows))) ||\n              ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,*p++,q);\n              q+=GetPixelChannels(image);\n            }\n            if ((image->columns % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        {\n          size_t\n            bytes_per_pixel;\n\n          bytes_per_pixel=3;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            bytes_per_pixel++;\n          if (bytes_per_line == 0)\n            bytes_per_line=bytes_per_pixel*image->columns;\n          length=image->rows*(bytes_per_line+image->columns % 2);\n          if (((sun_info.type == RT_ENCODED) &&\n               (length > (bytes_per_line*image->rows))) ||\n              ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (image->alpha_trait != UndefinedPixelTrait)\n                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n              if (sun_info.type == RT_STANDARD)\n                {\n                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                }\n              else\n                {\n                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                }\n              if (image->colors != 0)\n                {\n                  SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelRed(image,q)].red),q);\n                  SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelGreen(image,q)].green),q);\n                  SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelBlue(image,q)].blue),q);\n                }\n              q+=GetPixelChannels(image);\n            }\n            if (((bytes_per_pixel*image->columns) % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    sun_info.magic=ReadBlobMSBLong(image);\n    if (sun_info.magic == 0x59a66a95)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (sun_info.magic == 0x59a66a95);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r S U N I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterSUNImage() adds attributes for the SUN image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterSUNImage method is:\n%\n%      size_t RegisterSUNImage(void)\n%\n*/\nModuleExport size_t RegisterSUNImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"RAS\");\n  entry->decoder=(DecodeImageHandler *) ReadSUNImage;\n  entry->encoder=(EncodeImageHandler *) WriteSUNImage;\n  entry->magick=(IsImageFormatHandler *) IsSUN;\n  entry->description=ConstantString(\"SUN Rasterfile\");\n  entry->module=ConstantString(\"SUN\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"SUN\");\n  entry->decoder=(DecodeImageHandler *) ReadSUNImage;\n  entry->encoder=(EncodeImageHandler *) WriteSUNImage;\n  entry->description=ConstantString(\"SUN Rasterfile\");\n  entry->module=ConstantString(\"SUN\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r S U N I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterSUNImage() removes format registrations made by the\n%  SUN module from the list of supported formats.\n%\n%  The format of the UnregisterSUNImage method is:\n%\n%      UnregisterSUNImage(void)\n%\n*/\nModuleExport void UnregisterSUNImage(void)\n{\n  (void) UnregisterMagickInfo(\"RAS\");\n  (void) UnregisterMagickInfo(\"SUN\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e S U N I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteSUNImage() writes an image in the SUN rasterfile format.\n%\n%  The format of the WriteSUNImage method is:\n%\n%      MagickBooleanType WriteSUNImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteSUNImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n#define RMT_EQUAL_RGB  1\n#define RMT_NONE  0\n#define RMT_RAW  2\n#define RT_STANDARD  1\n#define RT_FORMAT_RGB  3\n\n  typedef struct _SUNInfo\n  {\n    unsigned int\n      magic,\n      width,\n      height,\n      depth,\n      length,\n      type,\n      maptype,\n      maplength;\n  } SUNInfo;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MagickSizeType\n    number_pixels;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  SUNInfo\n    sun_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  do\n  {\n    /*\n      Initialize SUN raster file header.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    sun_info.magic=0x59a66a95;\n    if ((image->columns != (unsigned int) image->columns) ||\n        (image->rows != (unsigned int) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    sun_info.width=(unsigned int) image->columns;\n    sun_info.height=(unsigned int) image->rows;\n    sun_info.type=(unsigned int)\n      (image->storage_class == DirectClass ? RT_FORMAT_RGB : RT_STANDARD);\n    sun_info.maptype=RMT_NONE;\n    sun_info.maplength=0;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((4*number_pixels) != (size_t) (4*number_pixels))\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color SUN raster.\n        */\n        sun_info.depth=(unsigned int) image->alpha_trait != UndefinedPixelTrait ?\n          32U : 24U;\n        sun_info.length=(unsigned int) ((image->alpha_trait != UndefinedPixelTrait ?\n          4 : 3)*number_pixels);\n        sun_info.length+=sun_info.length & 0x01 ? (unsigned int) image->rows :\n          0;\n      }\n    else\n      if (IsImageMonochrome(image,exception) != MagickFalse)\n        {\n          /*\n            Monochrome SUN raster.\n          */\n          sun_info.depth=1;\n          sun_info.length=(unsigned int) (((image->columns+7) >> 3)*\n            image->rows);\n          sun_info.length+=(unsigned int) (((image->columns/8)+(image->columns %\n            8 ? 1 : 0)) % 2 ? image->rows : 0);\n        }\n      else\n        {\n          /*\n            Colormapped SUN raster.\n          */\n          sun_info.depth=8;\n          sun_info.length=(unsigned int) number_pixels;\n          sun_info.length+=(unsigned int) (image->columns & 0x01 ? image->rows :\n            0);\n          sun_info.maptype=RMT_EQUAL_RGB;\n          sun_info.maplength=(unsigned int) (3*image->colors);\n        }\n    /*\n      Write SUN header.\n    */\n    (void) WriteBlobMSBLong(image,sun_info.magic);\n    (void) WriteBlobMSBLong(image,sun_info.width);\n    (void) WriteBlobMSBLong(image,sun_info.height);\n    (void) WriteBlobMSBLong(image,sun_info.depth);\n    (void) WriteBlobMSBLong(image,sun_info.length);\n    (void) WriteBlobMSBLong(image,sun_info.type);\n    (void) WriteBlobMSBLong(image,sun_info.maptype);\n    (void) WriteBlobMSBLong(image,sun_info.maplength);\n    /*\n      Convert MIFF to SUN raster pixels.\n    */\n    x=0;\n    y=0;\n    if (image->storage_class == DirectClass)\n      {\n        register unsigned char\n          *q;\n\n        size_t\n          bytes_per_pixel,\n          length;\n\n        unsigned char\n          *pixels;\n\n        /*\n          Allocate memory for pixels.\n        */\n        bytes_per_pixel=3;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          bytes_per_pixel++;\n        length=image->columns;\n        pixels=(unsigned char *) AcquireQuantumMemory(length,4*sizeof(*pixels));\n        if (pixels == (unsigned char *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Convert DirectClass packet to SUN RGB pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            p+=GetPixelChannels(image);\n          }\n          if (((bytes_per_pixel*image->columns) & 0x01) != 0)\n            *q++='\\0';  /* pad scanline */\n          (void) WriteBlob(image,(size_t) (q-pixels),pixels);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      }\n    else\n      if (IsImageMonochrome(image,exception) != MagickFalse)\n        {\n          register unsigned char\n            bit,\n            byte;\n\n          /*\n            Convert PseudoClass image to a SUN monochrome image.\n          */\n          (void) SetImageType(image,BilevelType,exception);\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            bit=0;\n            byte=0;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              byte<<=1;\n              if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n                byte|=0x01;\n              bit++;\n              if (bit == 8)\n                {\n                  (void) WriteBlobByte(image,byte);\n                  bit=0;\n                  byte=0;\n                }\n              p+=GetPixelChannels(image);\n            }\n            if (bit != 0)\n              (void) WriteBlobByte(image,(unsigned char) (byte << (8-bit)));\n            if ((((image->columns/8)+\n                (image->columns % 8 ? 1 : 0)) % 2) != 0)\n              (void) WriteBlobByte(image,0);  /* pad scanline */\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        {\n          /*\n            Dump colormap to file.\n          */\n          for (i=0; i < (ssize_t) image->colors; i++)\n            (void) WriteBlobByte(image,ScaleQuantumToChar(\n              ClampToQuantum(image->colormap[i].red)));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            (void) WriteBlobByte(image,ScaleQuantumToChar(\n              ClampToQuantum(image->colormap[i].green)));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            (void) WriteBlobByte(image,ScaleQuantumToChar(\n              ClampToQuantum(image->colormap[i].blue)));\n          /*\n            Convert PseudoClass packet to SUN colormapped pixel.\n          */\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              (void) WriteBlobByte(image,(unsigned char)\n                GetPixelIndex(image,p));\n              p+=GetPixelChannels(image);\n            }\n            if (image->columns & 0x01)\n              (void) WriteBlobByte(image,0);  /* pad scanline */\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%        CCCC   OOO   M   M  PPPP    OOO   SSSSS  IIIII  TTTTT  EEEEE         %\n%       C      O   O  MM MM  P   P  O   O  SS       I      T    E             %\n%       C      O   O  M M M  PPPP   O   O   SSS     I      T    EEE           %\n%       C      O   O  M   M  P      O   O     SS    I      T    E             %\n%        CCCC   OOO   M   M  P       OOO   SSSSS  IIIII    T    EEEEE         %\n%                                                                             %\n%                                                                             %\n%                     MagickCore Image Composite Methods                      %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2015 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/fx.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/resample.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/threshold.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#include \"MagickCore/version.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C o m p o s i t e I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CompositeImage() returns the second image composited onto the first\n%  at the specified offset, using the specified composite method.\n%\n%  The format of the CompositeImage method is:\n%\n%      MagickBooleanType CompositeImage(Image *image,\n%        const Image *composite_image,const CompositeOperator compose,\n%        const MagickBooleanType clip_to_self,const ssize_t x_offset,\n%        const ssize_t y_offset,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the destination image, modified by he composition\n%\n%    o composite_image: the composite (source) image.\n%\n%    o compose: This operator affects how the composite is applied to\n%      the image.  The operators and how they are utilized are listed here\n%      http://www.w3.org/TR/SVG12/#compositing.\n%\n%    o clip_to_self: set to MagickTrue to limit composition to area composed.\n%\n%    o x_offset: the column offset of the composited image.\n%\n%    o y_offset: the row offset of the composited image.\n%\n%  Extra Controls from Image meta-data in 'image' (artifacts)\n%\n%    o \"compose:args\"\n%        A string containing extra numerical arguments for specific compose\n%        methods, generally expressed as a 'geometry' or a comma separated list\n%        of numbers.\n%\n%        Compose methods needing such arguments include \"BlendCompositeOp\" and\n%        \"DisplaceCompositeOp\".\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n/*\n   Composition based on the SVG specification:\n\n   A Composition is defined by...\n      Color Function :  f(Sc,Dc)  where Sc and Dc are the normizalized colors\n      Blending areas :  X = 1     for area of overlap, ie: f(Sc,Dc)\n                        Y = 1     for source preserved\n                        Z = 1     for destination preserved\n\n   Conversion to transparency (then optimized)\n      Dca' = f(Sc, Dc)*Sa*Da + Y*Sca*(1-Da) + Z*Dca*(1-Sa)\n      Da'  = X*Sa*Da + Y*Sa*(1-Da) + Z*Da*(1-Sa)\n\n   Where...\n      Sca = Sc*Sa     normalized Source color divided by Source alpha\n      Dca = Dc*Da     normalized Dest color divided by Dest alpha\n      Dc' = Dca'/Da'  the desired color value for this channel.\n\n   Da' in in the follow formula as 'gamma'  The resulting alpla value.\n\n   Most functions use a blending mode of over (X=1,Y=1,Z=1) this results in\n   the following optimizations...\n      gamma = Sa+Da-Sa*Da;\n      gamma = 1 - QuantiumScale*alpha * QuantiumScale*beta;\n      opacity = QuantiumScale*alpha*beta;  // over blend, optimized 1-Gamma\n\n   The above SVG definitions also definate that Mathematical Composition\n   methods should use a 'Over' blending mode for Alpha Channel.\n   It however was not applied for composition modes of 'Plus', 'Minus',\n   the modulus versions of 'Add' and 'Subtract'.\n\n   Mathematical operator changes to be applied from IM v6.7...\n\n    1) Modulus modes 'Add' and 'Subtract' are obsoleted and renamed\n       'ModulusAdd' and 'ModulusSubtract' for clarity.\n\n    2) All mathematical compositions work as per the SVG specification\n       with regard to blending.  This now includes 'ModulusAdd' and\n       'ModulusSubtract'.\n\n    3) When the special channel flag 'sync' (syncronize channel updates)\n       is turned off (enabled by default) then mathematical compositions are\n       only performed on the channels specified, and are applied\n       independantally of each other.  In other words the mathematics is\n       performed as 'pure' mathematical operations, rather than as image\n       operations.\n*/\n\nstatic void HCLComposite(const MagickRealType hue,const MagickRealType chroma,\n  const MagickRealType luma,MagickRealType *red,MagickRealType *green,\n  MagickRealType *blue)\n{\n  MagickRealType\n    b,\n    c,\n    g,\n    h,\n    m,\n    r,\n    x;\n\n  /*\n    Convert HCL to RGB colorspace.\n  */\n  assert(red != (MagickRealType *) NULL);\n  assert(green != (MagickRealType *) NULL);\n  assert(blue != (MagickRealType *) NULL);\n  h=6.0*hue;\n  c=chroma;\n  x=c*(1.0-fabs(fmod(h,2.0)-1.0));\n  r=0.0;\n  g=0.0;\n  b=0.0;\n  if ((0.0 <= h) && (h < 1.0))\n    {\n      r=c;\n      g=x;\n    }\n  else\n    if ((1.0 <= h) && (h < 2.0))\n      {\n        r=x;\n        g=c;\n      }\n    else\n      if ((2.0 <= h) && (h < 3.0))\n        {\n          g=c;\n          b=x;\n        }\n      else\n        if ((3.0 <= h) && (h < 4.0))\n          {\n            g=x;\n            b=c;\n          }\n        else\n          if ((4.0 <= h) && (h < 5.0))\n            {\n              r=x;\n              b=c;\n            }\n          else\n            if ((5.0 <= h) && (h < 6.0))\n              {\n                r=c;\n                b=x;\n              }\n  m=luma-(0.298839*r+0.586811*g+0.114350*b);\n  *red=QuantumRange*(r+m);\n  *green=QuantumRange*(g+m);\n  *blue=QuantumRange*(b+m);\n}\n\nstatic void CompositeHCL(const MagickRealType red,const MagickRealType green,\n  const MagickRealType blue,MagickRealType *hue,MagickRealType *chroma,\n  MagickRealType *luma)\n{\n  MagickRealType\n    b,\n    c,\n    g,\n    h,\n    max,\n    r;\n\n  /*\n    Convert RGB to HCL colorspace.\n  */\n  assert(hue != (MagickRealType *) NULL);\n  assert(chroma != (MagickRealType *) NULL);\n  assert(luma != (MagickRealType *) NULL);\n  r=red;\n  g=green;\n  b=blue;\n  max=MagickMax(r,MagickMax(g,b));\n  c=max-(MagickRealType) MagickMin(r,MagickMin(g,b));\n  h=0.0;\n  if (c == 0)\n    h=0.0;\n  else\n    if (red == max)\n      h=fmod((g-b)/c+6.0,6.0);\n    else\n      if (green == max)\n        h=((b-r)/c)+2.0;\n      else\n        if (blue == max)\n          h=((r-g)/c)+4.0;\n  *hue=(h/6.0);\n  *chroma=QuantumScale*c;\n  *luma=QuantumScale*(0.298839*r+0.586811*g+0.114350*b);\n}\n\nstatic MagickBooleanType CompositeOverImage(Image *image,\n  const Image *composite_image,const MagickBooleanType clip_to_self,\n  const ssize_t x_offset,const ssize_t y_offset,ExceptionInfo *exception)\n{\n#define CompositeImageTag  \"Composite/Image\"\n\n  CacheView\n    *composite_view,\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  /*\n    Composite image.\n  */\n  status=MagickTrue;\n  progress=0;\n  composite_view=AcquireVirtualCacheView(composite_image,exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(composite_image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const Quantum\n      *pixels;\n\n    register const Quantum\n      *restrict p;\n\n    register Quantum\n      *restrict q;\n\n    register ssize_t\n      x;\n\n    size_t\n      channels;\n\n    if (status == MagickFalse)\n      continue;\n    if (clip_to_self != MagickFalse)\n      {\n        if (y < y_offset)\n          continue;\n        if ((y-y_offset) >= (ssize_t) composite_image->rows)\n          continue;\n      }\n    /*\n      If pixels is NULL, y is outside overlay region.\n    */\n    pixels=(Quantum *) NULL;\n    p=(Quantum *) NULL;\n    if ((y >= y_offset) && ((y-y_offset) < (ssize_t) composite_image->rows))\n      {\n        p=GetCacheViewVirtualPixels(composite_view,0,y-y_offset,\n          composite_image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        pixels=p;\n        if (x_offset < 0)\n          p-=x_offset*GetPixelChannels(composite_image);\n      }\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      MagickRealType\n        Da,\n        Dc,\n        Dca,\n        Sa,\n        Sc,\n        Sca;\n\n      register ssize_t\n        i;\n\n      if (clip_to_self != MagickFalse)\n        {\n          if (x < x_offset)\n            {\n              q+=GetPixelChannels(image);\n              continue;\n            }\n          if ((x-x_offset) >= (ssize_t) composite_image->columns)\n            break;\n        }\n      if ((pixels == (Quantum *) NULL) || (x < x_offset) ||\n          ((x-x_offset) >= (ssize_t) composite_image->columns))\n        {\n          Quantum\n            source[MaxPixelChannels];\n\n          /*\n            Virtual composite:\n              Sc: source color.\n              Dc: destination color.\n          */\n          if (GetPixelReadMask(image,q) == 0)\n            {\n              q+=GetPixelChannels(image);\n              continue;\n            }\n          (void) GetOneVirtualPixel(composite_image,x-x_offset,y-y_offset,\n            source,exception);\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            PixelTrait traits=GetPixelChannelTraits(image,channel);\n            PixelTrait composite_traits=GetPixelChannelTraits(composite_image,\n              channel);\n            if ((traits == UndefinedPixelTrait) ||\n                (composite_traits == UndefinedPixelTrait))\n              continue;\n            q[i]=source[channel];\n          }\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      /*\n        Authentic composite:\n          Sa:  normalized source alpha.\n          Da:  normalized destination alpha.\n      */\n      if (GetPixelReadMask(composite_image,p) == 0)\n        {\n          p+=GetPixelChannels(composite_image);\n          channels=GetPixelChannels(composite_image);\n          if (p >= (pixels+channels*composite_image->columns))\n            p=pixels;\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      Sa=QuantumScale*GetPixelAlpha(composite_image,p);\n      Da=QuantumScale*GetPixelAlpha(image,q);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait composite_traits=GetPixelChannelTraits(composite_image,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (composite_traits == UndefinedPixelTrait))\n          continue;\n        if ((traits & CopyPixelTrait) != 0)\n          {\n            /*\n              Copy channel.\n            */\n            q[i]=GetPixelChannel(composite_image,channel,p);\n            continue;\n          }\n        if (channel == AlphaPixelChannel)\n          {\n            /*\n              Set alpha channel.\n            */\n            q[i]=ClampToQuantum(QuantumRange*(Sa+Da-Sa*Da));\n            continue;\n          }\n        /*\n          Sc: source color.\n          Dc: destination color.\n        */\n        Sc=(MagickRealType) GetPixelChannel(composite_image,channel,p);\n        Dc=(MagickRealType) q[i];\n        Sca=QuantumScale*Sa*Sc;\n        Dca=QuantumScale*Da*Dc;\n        q[i]=ClampToQuantum(QuantumRange*(Sca+Dca*(1.0-Sa)));\n      }\n      p+=GetPixelChannels(composite_image);\n      channels=GetPixelChannels(composite_image);\n      if (p >= (pixels+channels*composite_image->columns))\n        p=pixels;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_CompositeImage)\n#endif\n        proceed=SetImageProgress(image,CompositeImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  composite_view=DestroyCacheView(composite_view);\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nMagickExport MagickBooleanType CompositeImage(Image *image,\n  const Image *composite,const CompositeOperator compose,\n  const MagickBooleanType clip_to_self,const ssize_t x_offset,\n  const ssize_t y_offset,ExceptionInfo *exception)\n{\n#define CompositeImageTag  \"Composite/Image\"\n\n  CacheView\n    *composite_view,\n    *image_view;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *composite_image,\n    *destination_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MagickRealType\n    amount,\n    destination_dissolve,\n    midpoint,\n    percent_luma,\n    percent_chroma,\n    source_dissolve,\n    threshold;\n\n  MagickStatusType\n    flags;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(composite!= (Image *) NULL);\n  assert(composite->signature == MagickSignature);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  composite_image=CloneImage(composite,0,0,MagickTrue,exception);\n  if (composite_image == (const Image *) NULL)\n    return(MagickFalse);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  (void) SetImageColorspace(composite_image,image->colorspace,exception);\n  if ((image->alpha_trait != UndefinedPixelTrait) &&\n      (composite_image->alpha_trait == UndefinedPixelTrait))\n    (void) SetImageAlphaChannel(composite_image,SetAlphaChannel,exception);\nif (0)\n  if ((compose == OverCompositeOp) || (compose == SrcOverCompositeOp))\n    {\n      status=CompositeOverImage(image,composite_image,clip_to_self,x_offset,\n        y_offset,exception);\n      composite_image=DestroyImage(composite_image);\n      return(status);\n    }\n  destination_image=(Image *) NULL;\n  amount=0.5;\n  destination_dissolve=1.0;\n  percent_luma=100.0;\n  percent_chroma=100.0;\n  source_dissolve=1.0;\n  threshold=0.05f;\n  switch (compose)\n  {\n    case CopyCompositeOp:\n    {\n      if ((x_offset < 0) || (y_offset < 0))\n        break;\n      if ((x_offset+(ssize_t) composite_image->columns) > (ssize_t) image->columns)\n        break;\n      if ((y_offset+(ssize_t) composite_image->rows) > (ssize_t) image->rows)\n        break;\n      status=MagickTrue;\n      composite_view=AcquireVirtualCacheView(composite_image,exception);\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        magick_threads(composite_image,image,composite_image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) composite_image->rows; y++)\n      {\n        MagickBooleanType\n          sync;\n\n        register const Quantum\n          *p;\n\n        register Quantum\n          *q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        p=GetCacheViewVirtualPixels(composite_view,0,y,composite_image->columns,\n          1,exception);\n        q=GetCacheViewAuthenticPixels(image_view,x_offset,y+y_offset,\n          composite_image->columns,1,exception);\n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) composite_image->columns; x++)\n        {\n          register ssize_t\n            i;\n\n          if (GetPixelReadMask(composite_image,p) == 0)\n            {\n              p+=GetPixelChannels(composite_image);\n              q+=GetPixelChannels(image);\n              continue;\n            }\n          for (i=0; i < (ssize_t) GetPixelChannels(composite_image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(composite_image,i);\n            PixelTrait composite_traits=GetPixelChannelTraits(composite_image,\n              channel);\n            PixelTrait traits=GetPixelChannelTraits(image,channel);\n            if ((traits == UndefinedPixelTrait) ||\n                (composite_traits == UndefinedPixelTrait))\n              continue;\n            SetPixelChannel(image,channel,p[i],q);\n          }\n          p+=GetPixelChannels(composite_image);\n          q+=GetPixelChannels(image);\n        }\n        sync=SyncCacheViewAuthenticPixels(image_view,exception);\n        if (sync == MagickFalse)\n          status=MagickFalse;\n        if (image->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp critical (MagickCore_CompositeImage)\n#endif\n            proceed=SetImageProgress(image,CompositeImageTag,\n              (MagickOffsetType) y,image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n      composite_view=DestroyCacheView(composite_view);\n      image_view=DestroyCacheView(image_view);\n      composite_image=DestroyImage(composite_image);\n      return(status);\n    }\n    case IntensityCompositeOp:\n    {\n      if ((x_offset < 0) || (y_offset < 0))\n        break;\n      if ((x_offset+(ssize_t) composite_image->columns) > (ssize_t) image->columns)\n        break;\n      if ((y_offset+(ssize_t) composite_image->rows) > (ssize_t) image->rows)\n        break;\n      status=MagickTrue;\n      composite_view=AcquireVirtualCacheView(composite_image,exception);\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        magick_threads(composite_image,image,composite_image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) composite_image->rows; y++)\n      {\n        MagickBooleanType\n          sync;\n\n        register const Quantum\n          *p;\n\n        register Quantum\n          *q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        p=GetCacheViewVirtualPixels(composite_view,0,y,composite_image->columns,\n          1,exception);\n        q=GetCacheViewAuthenticPixels(image_view,x_offset,y+y_offset,\n          composite_image->columns,1,exception);\n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) composite_image->columns; x++)\n        {\n          if (GetPixelReadMask(composite_image,p) == 0)\n            {\n              p+=GetPixelChannels(composite_image);\n              q+=GetPixelChannels(image);\n              continue;\n            }\n          SetPixelAlpha(image,ClampToQuantum(GetPixelIntensity(composite_image,\n            p)),q);\n          p+=GetPixelChannels(composite_image);\n          q+=GetPixelChannels(image);\n        }\n        sync=SyncCacheViewAuthenticPixels(image_view,exception);\n        if (sync == MagickFalse)\n          status=MagickFalse;\n        if (image->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp critical (MagickCore_CompositeImage)\n#endif\n            proceed=SetImageProgress(image,CompositeImageTag,\n              (MagickOffsetType) y,image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n      composite_view=DestroyCacheView(composite_view);\n      image_view=DestroyCacheView(image_view);\n      composite_image=DestroyImage(composite_image);\n      return(status);\n    }\n    case CopyAlphaCompositeOp:\n    case ChangeMaskCompositeOp:\n    {\n      /*\n        Modify destination outside the overlaid region and require an alpha\n        channel to exist, to add transparency.\n      */\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      break;\n    }\n    case BlurCompositeOp:\n    {\n      CacheView\n        *composite_view,\n        *destination_view;\n\n      const char\n        *value;\n\n      MagickRealType\n        angle_range,\n        angle_start,\n        height,\n        width;\n\n      PixelInfo\n        pixel;\n\n      ResampleFilter\n        *resample_filter;\n\n      SegmentInfo\n        blur;\n\n      /*\n        Blur Image by resampling.\n\n        Blur Image dictated by an overlay gradient map: X = red_channel;\n          Y = green_channel; compose:args =  x_scale[,y_scale[,angle]].\n      */\n      destination_image=CloneImage(image,image->columns,image->rows,MagickTrue,\n        exception);\n      if (destination_image == (Image *) NULL)\n        {\n          composite_image=DestroyImage(composite_image);\n          return(MagickFalse);\n        }\n      /*\n        Gather the maximum blur sigma values from user.\n      */\n      SetGeometryInfo(&geometry_info);\n      flags=NoValue;\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (const char *) NULL)\n        flags=ParseGeometry(value,&geometry_info);\n      if ((flags & WidthValue) == 0)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n            \"InvalidSetting\",\"'%s' '%s'\",\"compose:args\",value);\n          composite_image=DestroyImage(composite_image);\n          destination_image=DestroyImage(destination_image);\n          return(MagickFalse);\n        }\n      /*\n        Users input sigma now needs to be converted to the EWA ellipse size.\n        The filter defaults to a sigma of 0.5 so to make this match the\n        users input the ellipse size needs to be doubled.\n      */\n      width=height=geometry_info.rho*2.0;\n      if ((flags & HeightValue) != 0 )\n        height=geometry_info.sigma*2.0;\n      /*\n        Default the unrotated ellipse width and height axis vectors.\n      */\n      blur.x1=width;\n      blur.x2=0.0;\n      blur.y1=0.0;\n      blur.y2=height;\n      /* rotate vectors if a rotation angle is given */\n      if ((flags & XValue) != 0 )\n        {\n          MagickRealType\n            angle;\n\n          angle=DegreesToRadians(geometry_info.xi);\n          blur.x1=width*cos(angle);\n          blur.x2=width*sin(angle);\n          blur.y1=(-height*sin(angle));\n          blur.y2=height*cos(angle);\n        }\n      /* Otherwise lets set a angle range and calculate in the loop */\n      angle_start=0.0;\n      angle_range=0.0;\n      if ((flags & YValue) != 0 )\n        {\n          angle_start=DegreesToRadians(geometry_info.xi);\n          angle_range=DegreesToRadians(geometry_info.psi)-angle_start;\n        }\n      /*\n        Set up a gaussian cylindrical filter for EWA Bluring.\n\n        As the minimum ellipse radius of support*1.0 the EWA algorithm\n        can only produce a minimum blur of 0.5 for Gaussian (support=2.0)\n        This means that even 'No Blur' will be still a little blurry!\n\n        The solution (as well as the problem of preventing any user\n        expert filter settings, is to set our own user settings, then\n        restore them afterwards.\n      */\n      resample_filter=AcquireResampleFilter(image,exception);\n      SetResampleFilter(resample_filter,GaussianFilter);\n\n      /* do the variable blurring of each pixel in image */\n      GetPixelInfo(image,&pixel);\n      composite_view=AcquireVirtualCacheView(composite_image,exception);\n      destination_view=AcquireAuthenticCacheView(destination_image,exception);\n      for (y=0; y < (ssize_t) composite_image->rows; y++)\n      {\n        MagickBooleanType\n          sync;\n\n        register const Quantum\n          *restrict p;\n\n        register Quantum\n          *restrict q;\n\n        register ssize_t\n          x;\n\n        if (((y+y_offset) < 0) || ((y+y_offset) >= (ssize_t) image->rows))\n          continue;\n        p=GetCacheViewVirtualPixels(composite_view,0,y,composite_image->columns,\n          1,exception);\n        q=QueueCacheViewAuthenticPixels(destination_view,0,y,\n          destination_image->columns,1,exception);\n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n          break;\n        for (x=0; x < (ssize_t) composite_image->columns; x++)\n        {\n          if (((x_offset+x) < 0) || ((x_offset+x) >= (ssize_t) image->columns))\n            {\n              p+=GetPixelChannels(composite_image);\n              continue;\n            }\n          if (fabs((double) angle_range) > MagickEpsilon)\n            {\n              MagickRealType\n                angle;\n\n              angle=angle_start+angle_range*QuantumScale*\n                GetPixelBlue(composite_image,p);\n              blur.x1=width*cos(angle);\n              blur.x2=width*sin(angle);\n              blur.y1=(-height*sin(angle));\n              blur.y2=height*cos(angle);\n            }\n#if 0\n          if ( x == 10 && y == 60 ) {\n            (void) fprintf(stderr, \"blur.x=%lf,%lf, blur.y=%lf,%lf\\n\",blur.x1,\n              blur.x2,blur.y1, blur.y2);\n            (void) fprintf(stderr, \"scaled by=%lf,%lf\\n\",QuantumScale*\n              GetPixelRed(p),QuantumScale*GetPixelGreen(p));\n#endif\n          ScaleResampleFilter(resample_filter,\n            blur.x1*QuantumScale*GetPixelRed(composite_image,p),\n            blur.y1*QuantumScale*GetPixelGreen(composite_image,p),\n            blur.x2*QuantumScale*GetPixelRed(composite_image,p),\n            blur.y2*QuantumScale*GetPixelGreen(composite_image,p) );\n          (void) ResamplePixelColor(resample_filter,(double) x_offset+x,\n            (double) y_offset+y,&pixel,exception);\n          SetPixelViaPixelInfo(destination_image,&pixel,q);\n          p+=GetPixelChannels(composite_image);\n          q+=GetPixelChannels(destination_image);\n        }\n        sync=SyncCacheViewAuthenticPixels(destination_view,exception);\n        if (sync == MagickFalse)\n          break;\n      }\n      resample_filter=DestroyResampleFilter(resample_filter);\n      composite_view=DestroyCacheView(composite_view);\n      destination_view=DestroyCacheView(destination_view);\n      composite_image=DestroyImage(composite_image);\n      composite_image=destination_image;\n      break;\n    }\n    case DisplaceCompositeOp:\n    case DistortCompositeOp:\n    {\n      CacheView\n        *composite_view,\n        *destination_view,\n        *image_view;\n\n      const char\n        *value;\n\n      PixelInfo\n        pixel;\n\n      MagickRealType\n        horizontal_scale,\n        vertical_scale;\n\n      PointInfo\n        center,\n        offset;\n\n      /*\n        Displace/Distort based on overlay gradient map:\n          X = red_channel;  Y = green_channel;\n          compose:args = x_scale[,y_scale[,center.x,center.y]]\n      */\n      destination_image=CloneImage(image,image->columns,image->rows,MagickTrue,\n        exception);\n      if (destination_image == (Image *) NULL)\n        {\n          composite_image=DestroyImage(composite_image);\n          return(MagickFalse);\n        }\n      SetGeometryInfo(&geometry_info);\n      flags=NoValue;\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        flags=ParseGeometry(value,&geometry_info);\n      if ((flags & (WidthValue|HeightValue)) == 0 )\n        {\n          if ((flags & AspectValue) == 0)\n            {\n              horizontal_scale=(MagickRealType) (composite_image->columns-1.0)/\n                2.0;\n              vertical_scale=(MagickRealType) (composite_image->rows-1.0)/2.0;\n            }\n          else\n            {\n              horizontal_scale=(MagickRealType) (image->columns-1.0)/2.0;\n              vertical_scale=(MagickRealType) (image->rows-1.0)/2.0;\n            }\n        }\n      else\n        {\n          horizontal_scale=geometry_info.rho;\n          vertical_scale=geometry_info.sigma;\n          if ((flags & PercentValue) != 0)\n            {\n              if ((flags & AspectValue) == 0)\n                {\n                  horizontal_scale*=(composite_image->columns-1.0)/200.0;\n                  vertical_scale*=(composite_image->rows-1.0)/200.0;\n                }\n              else\n                {\n                  horizontal_scale*=(image->columns-1.0)/200.0;\n                  vertical_scale*=(image->rows-1.0)/200.0;\n                }\n            }\n          if ((flags & HeightValue) == 0)\n            vertical_scale=horizontal_scale;\n        }\n      /*\n        Determine fixed center point for absolute distortion map\n         Absolute distort ==\n           Displace offset relative to a fixed absolute point\n           Select that point according to +X+Y user inputs.\n           default = center of overlay image\n           arg flag '!' = locations/percentage relative to background image\n      */\n      center.x=(MagickRealType) x_offset;\n      center.y=(MagickRealType) y_offset;\n      if (compose == DistortCompositeOp)\n        {\n          if ((flags & XValue) == 0)\n            if ((flags & AspectValue) == 0)\n              center.x=(MagickRealType) (x_offset+(composite_image->columns-1)/\n                2.0);\n            else\n              center.x=(MagickRealType) ((image->columns-1)/2);\n          else\n            if ((flags & AspectValue) == 0)\n              center.x=(MagickRealType) x_offset+geometry_info.xi;\n            else\n              center.x=geometry_info.xi;\n          if ((flags & YValue) == 0)\n            if ((flags & AspectValue) == 0)\n              center.y=(MagickRealType) (y_offset+(composite_image->rows-1)/\n                2.0);\n            else\n              center.y=(MagickRealType) ((image->rows-1)/2);\n          else\n            if ((flags & AspectValue) == 0)\n              center.y=(MagickRealType) y_offset+geometry_info.psi;\n            else\n              center.y=geometry_info.psi;\n        }\n      /*\n        Shift the pixel offset point as defined by the provided,\n        displacement/distortion map.  -- Like a lens...\n      */\n      GetPixelInfo(image,&pixel);\n      image_view=AcquireVirtualCacheView(image,exception);\n      composite_view=AcquireVirtualCacheView(composite_image,exception);\n      destination_view=AcquireAuthenticCacheView(destination_image,exception);\n      for (y=0; y < (ssize_t) composite_image->rows; y++)\n      {\n        MagickBooleanType\n          sync;\n\n        register const Quantum\n          *restrict p;\n\n        register Quantum\n          *restrict q;\n\n        register ssize_t\n          x;\n\n        if (((y+y_offset) < 0) || ((y+y_offset) >= (ssize_t) image->rows))\n          continue;\n        p=GetCacheViewVirtualPixels(composite_view,0,y,composite_image->columns,\n          1,exception);\n        q=QueueCacheViewAuthenticPixels(destination_view,0,y,\n          destination_image->columns,1,exception);\n        if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n          break;\n        for (x=0; x < (ssize_t) composite_image->columns; x++)\n        {\n          if (((x_offset+x) < 0) || ((x_offset+x) >= (ssize_t) image->columns))\n            {\n              p+=GetPixelChannels(composite_image);\n              continue;\n            }\n          /*\n            Displace the offset.\n          */\n          offset.x=(double) (horizontal_scale*(GetPixelRed(composite_image,p)-\n            (((MagickRealType) QuantumRange+1.0)/2.0)))/(((MagickRealType)\n            QuantumRange+1.0)/2.0)+center.x+((compose == DisplaceCompositeOp) ?\n            x : 0);\n          offset.y=(double) (vertical_scale*(GetPixelGreen(composite_image,p)-\n            (((MagickRealType) QuantumRange+1.0)/2.0)))/(((MagickRealType)\n            QuantumRange+1.0)/2.0)+center.y+((compose == DisplaceCompositeOp) ?\n            y : 0);\n          (void) InterpolatePixelInfo(image,image_view,\n            UndefinedInterpolatePixel,(double) offset.x,(double) offset.y,\n            &pixel,exception);\n          /*\n            Mask with the 'invalid pixel mask' in alpha channel.\n          */\n          pixel.alpha=(MagickRealType) QuantumRange*(1.0-(1.0-QuantumScale*\n            pixel.alpha)*(1.0-QuantumScale*GetPixelAlpha(composite_image,p)));\n          SetPixelViaPixelInfo(destination_image,&pixel,q);\n          p+=GetPixelChannels(composite_image);\n          q+=GetPixelChannels(destination_image);\n        }\n        sync=SyncCacheViewAuthenticPixels(destination_view,exception);\n        if (sync == MagickFalse)\n          break;\n      }\n      destination_view=DestroyCacheView(destination_view);\n      composite_view=DestroyCacheView(composite_view);\n      image_view=DestroyCacheView(image_view);\n      composite_image=DestroyImage(composite_image);\n      composite_image=destination_image;\n      break;\n    }\n    case DissolveCompositeOp:\n    {\n      const char\n        *value;\n\n      /*\n        Geometry arguments to dissolve factors.\n      */\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        {\n          flags=ParseGeometry(value,&geometry_info);\n          source_dissolve=geometry_info.rho/100.0;\n          destination_dissolve=1.0;\n          if ((source_dissolve-MagickEpsilon) < 0.0)\n            source_dissolve=0.0;\n          if ((source_dissolve+MagickEpsilon) > 1.0)\n            {\n              destination_dissolve=2.0-source_dissolve;\n              source_dissolve=1.0;\n            }\n          if ((flags & SigmaValue) != 0)\n            destination_dissolve=geometry_info.sigma/100.0;\n          if ((destination_dissolve-MagickEpsilon) < 0.0)\n            destination_dissolve=0.0;\n        }\n      break;\n    }\n    case BlendCompositeOp:\n    {\n      const char\n        *value;\n\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        {\n          flags=ParseGeometry(value,&geometry_info);\n          source_dissolve=geometry_info.rho/100.0;\n          destination_dissolve=1.0-source_dissolve;\n          if ((flags & SigmaValue) != 0)\n            destination_dissolve=geometry_info.sigma/100.0;\n        }\n      break;\n    }\n    case MathematicsCompositeOp:\n    {\n      const char\n        *value;\n\n      /*\n        Just collect the values from \"compose:args\", setting.\n        Unused values are set to zero automagically.\n\n        Arguments are normally a comma separated list, so this probably should\n        be changed to some 'general comma list' parser, (with a minimum\n        number of values)\n      */\n      SetGeometryInfo(&geometry_info);\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        (void) ParseGeometry(value,&geometry_info);\n      break;\n    }\n    case ModulateCompositeOp:\n    {\n      const char\n        *value;\n\n      /*\n        Determine the luma and chroma scale.\n      */\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        {\n          flags=ParseGeometry(value,&geometry_info);\n          percent_luma=geometry_info.rho;\n          if ((flags & SigmaValue) != 0)\n            percent_chroma=geometry_info.sigma;\n        }\n      break;\n    }\n    case ThresholdCompositeOp:\n    {\n      const char\n        *value;\n\n      /*\n        Determine the amount and threshold.\n      */\n      value=GetImageArtifact(image,\"compose:args\");\n      if (value != (char *) NULL)\n        {\n          flags=ParseGeometry(value,&geometry_info);\n          amount=geometry_info.rho;\n          threshold=geometry_info.sigma;\n          if ((flags & SigmaValue) == 0)\n            threshold=0.05f;\n        }\n      threshold*=QuantumRange;\n      break;\n    }\n    default:\n      break;\n  }\n  /*\n    Composite image.\n  */\n  status=MagickTrue;\n  progress=0;\n  midpoint=((MagickRealType) QuantumRange+1.0)/2;\n  composite_view=AcquireVirtualCacheView(composite_image,exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(composite_image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const Quantum\n      *pixels;\n\n    MagickRealType\n      blue,\n      luma,\n      green,\n      hue,\n      red,\n      chroma;\n\n    PixelInfo\n      destination_pixel,\n      source_pixel;\n\n    register const Quantum\n      *restrict p;\n\n    register Quantum\n      *restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    if (clip_to_self != MagickFalse)\n      {\n        if (y < y_offset)\n          continue;\n        if ((y-y_offset) >= (ssize_t) composite_image->rows)\n          continue;\n      }\n    /*\n      If pixels is NULL, y is outside overlay region.\n    */\n    pixels=(Quantum *) NULL;\n    p=(Quantum *) NULL;\n    if ((y >= y_offset) && ((y-y_offset) < (ssize_t) composite_image->rows))\n      {\n        p=GetCacheViewVirtualPixels(composite_view,0,y-y_offset,\n          composite_image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        pixels=p;\n        if (x_offset < 0)\n          p-=x_offset*GetPixelChannels(composite_image);\n      }\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    hue=0.0;\n    chroma=0.0;\n    luma=0.0;\n    GetPixelInfo(image,&destination_pixel);\n    GetPixelInfo(composite_image,&source_pixel);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      MagickRealType\n        alpha,\n        Da,\n        Dc,\n        Dca,\n        Sa,\n        Sc,\n        Sca;\n\n      register ssize_t\n        i;\n\n      size_t\n        channels;\n\n      if (clip_to_self != MagickFalse)\n        {\n          if (x < x_offset)\n            {\n              q+=GetPixelChannels(image);\n              continue;\n            }\n          if ((x-x_offset) >= (ssize_t) composite_image->columns)\n            break;\n        }\n      if ((pixels == (Quantum *) NULL) || (x < x_offset) ||\n          ((x-x_offset) >= (ssize_t) composite_image->columns))\n        {\n          Quantum\n            source[MaxPixelChannels];\n\n          /*\n            Virtual composite:\n              Sc: source color.\n              Dc: destination color.\n          */\n          (void) GetOneVirtualPixel(composite_image,x-x_offset,y-y_offset,\n            source,exception);\n          if (GetPixelReadMask(image,q) == 0)\n            {\n              q+=GetPixelChannels(image);\n              continue;\n            }\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            MagickRealType\n              pixel;\n\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            PixelTrait traits=GetPixelChannelTraits(image,channel);\n            PixelTrait composite_traits=GetPixelChannelTraits(composite_image,\n              channel);\n            if ((traits == UndefinedPixelTrait) ||\n                (composite_traits == UndefinedPixelTrait))\n              continue;\n            switch (compose)\n            {\n              case AlphaCompositeOp:\n              case ChangeMaskCompositeOp:\n              case CopyAlphaCompositeOp:\n              case DstAtopCompositeOp:\n              case DstInCompositeOp:\n              case InCompositeOp:\n              case OutCompositeOp:\n              case SrcInCompositeOp:\n              case SrcOutCompositeOp:\n              {\n                if (channel == AlphaPixelChannel)\n                  pixel=(MagickRealType) TransparentAlpha;\n                else\n                  pixel=(MagickRealType) q[i];\n                break;\n              }\n              case ClearCompositeOp:\n              case CopyCompositeOp:\n              case ReplaceCompositeOp:\n              case SrcCompositeOp:\n              {\n                if (channel == AlphaPixelChannel)\n                  pixel=(MagickRealType) TransparentAlpha;\n                else\n                  pixel=0.0;\n                break;\n              }\n              case BlendCompositeOp:\n              case DissolveCompositeOp:\n              {\n                if (channel == AlphaPixelChannel)\n                  pixel=destination_dissolve*GetPixelAlpha(composite_image,\n                    source);\n                else\n                  pixel=(MagickRealType) source[channel];\n                break;\n              }\n              default:\n              {\n                pixel=(MagickRealType) source[channel];\n                break;\n              }\n            }\n            q[i]=ClampToQuantum(pixel);\n          }\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      /*\n        Authentic composite:\n          Sa:  normalized source alpha.\n          Da:  normalized destination alpha.\n      */\n      Sa=QuantumScale*GetPixelAlpha(composite_image,p);\n      Da=QuantumScale*GetPixelAlpha(image,q);\n      switch (compose)\n      {\n        case BumpmapCompositeOp:\n        {\n          alpha=GetPixelIntensity(composite_image,p)*Sa;\n          break;\n        }\n        case ColorBurnCompositeOp:\n        case ColorDodgeCompositeOp:\n        case DarkenCompositeOp:\n        case DifferenceCompositeOp:\n        case DivideDstCompositeOp:\n        case DivideSrcCompositeOp:\n        case ExclusionCompositeOp:\n        case HardLightCompositeOp:\n        case HardMixCompositeOp:\n        case LinearBurnCompositeOp:\n        case LinearDodgeCompositeOp:\n        case LinearLightCompositeOp:\n        case LightenCompositeOp:\n        case MathematicsCompositeOp:\n        case MinusDstCompositeOp:\n        case MinusSrcCompositeOp:\n        case ModulusAddCompositeOp:\n        case ModulusSubtractCompositeOp:\n        case MultiplyCompositeOp:\n        case OverlayCompositeOp:\n        case PegtopLightCompositeOp:\n        case PinLightCompositeOp:\n        case ScreenCompositeOp:\n        case SoftLightCompositeOp:\n        case VividLightCompositeOp:\n        {\n          alpha=RoundToUnity(Sa+Da-Sa*Da);\n          break;\n        }\n        case DstAtopCompositeOp:\n        case DstInCompositeOp:\n        case InCompositeOp:\n        case SrcInCompositeOp:\n        {\n          alpha=Sa*Da;\n          break;\n        }\n        case DissolveCompositeOp:\n        {\n          alpha=source_dissolve*Sa*(-destination_dissolve*Da)+source_dissolve*\n            Sa+destination_dissolve*Da;\n          break;\n        }\n        case DstOverCompositeOp:\n        {\n          alpha=Sa+Da-Sa*Da;\n          break;\n        }\n        case DstOutCompositeOp:\n        {\n          alpha=Da*(1.0-Sa);\n          break;\n        }\n        case OutCompositeOp:\n        case SrcOutCompositeOp:\n        {\n          alpha=Sa*(1.0-Da);\n          break;\n        }\n        case OverCompositeOp:\n        case SrcOverCompositeOp:\n        {\n          alpha=Sa+Da-Sa*Da;\n          break;\n        }\n        case BlendCompositeOp:\n        case PlusCompositeOp:\n        {\n          alpha=RoundToUnity(Sa+Da);\n          break;\n        }\n        case XorCompositeOp:\n        {\n          alpha=Sa+Da-2.0*Sa*Da;\n          break;\n        }\n        default:\n        {\n          alpha=1.0;\n          break;\n        }\n      }\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          p+=GetPixelChannels(composite_image);\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      switch (compose)\n      {\n        case ColorizeCompositeOp:\n        case HueCompositeOp:\n        case LuminizeCompositeOp:\n        case ModulateCompositeOp:\n        case SaturateCompositeOp:\n        {\n          GetPixelInfoPixel(composite_image,p,&source_pixel);\n          GetPixelInfoPixel(image,q,&destination_pixel);\n          break;\n        }\n        default:\n          break;\n      }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        MagickRealType\n          pixel,\n          sans;\n\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait composite_traits=GetPixelChannelTraits(composite_image,\n          channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        if ((composite_traits == UndefinedPixelTrait) &&\n             (((compose != CopyAlphaCompositeOp) &&\n               (compose != ChangeMaskCompositeOp)) ||\n              (channel != AlphaPixelChannel)))\n            continue;\n        /*\n          Sc: source color.\n          Dc: destination color.\n        */\n        Sc=(MagickRealType) GetPixelChannel(composite_image,channel,p);\n        Dc=(MagickRealType) q[i];\n        if ((traits & CopyPixelTrait) != 0)\n          {\n            /*\n              Copy channel.\n            */\n            q[i]=ClampToQuantum(Sc);\n            continue;\n          }\n        if (channel == AlphaPixelChannel)\n          {\n            /*\n              Set alpha channel.\n            */\n            switch (compose)\n            {\n              case AlphaCompositeOp:\n              {\n                pixel=QuantumRange*Sa;\n                break;\n              }\n              case AtopCompositeOp:\n              case CopyBlackCompositeOp:\n              case CopyBlueCompositeOp:\n              case CopyCyanCompositeOp:\n              case CopyGreenCompositeOp:\n              case CopyMagentaCompositeOp:\n              case CopyRedCompositeOp:\n              case CopyYellowCompositeOp:\n              case SrcAtopCompositeOp:\n              case DstCompositeOp:\n              case NoCompositeOp:\n              {\n                pixel=QuantumRange*Da;\n                break;\n              }\n              case ChangeMaskCompositeOp:\n              {\n                MagickBooleanType\n                  equivalent;\n\n                if (Da > ((MagickRealType) QuantumRange/2.0))\n                  {\n                    pixel=(MagickRealType) TransparentAlpha;\n                    break;\n                  }\n                equivalent=IsFuzzyEquivalencePixel(composite_image,p,image,q);\n                if (equivalent != MagickFalse)\n                  pixel=(MagickRealType) TransparentAlpha;\n                else\n                  pixel=(MagickRealType) OpaqueAlpha;\n                break;\n              }\n              case ClearCompositeOp:\n              {\n                pixel=(MagickRealType) TransparentAlpha;\n                break;\n              }\n              case ColorizeCompositeOp:\n              case HueCompositeOp:\n              case LuminizeCompositeOp:\n              case SaturateCompositeOp:\n              {\n                if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n                  {\n                    pixel=QuantumRange*Da;\n                    break;\n                  }\n                if (fabs((double) (QuantumRange*Da-TransparentAlpha)) < MagickEpsilon)\n                  {\n                    pixel=QuantumRange*Sa;\n                    break;\n                  }\n                if (Sa < Da)\n                  {\n                    pixel=QuantumRange*Da;\n                    break;\n                  }\n                pixel=QuantumRange*Sa;\n                break;\n              }\n              case CopyAlphaCompositeOp:\n              {\n                if (composite_traits == UndefinedPixelTrait)\n                  pixel=GetPixelIntensity(composite_image,p);\n                else\n                  pixel=QuantumRange*Sa;\n                break;\n              }\n              case CopyCompositeOp:\n              case DisplaceCompositeOp:\n              case DistortCompositeOp:\n              case DstAtopCompositeOp:\n              case ReplaceCompositeOp:\n              case SrcCompositeOp:\n              {\n                pixel=QuantumRange*Sa;\n                break;\n              }\n              case DarkenIntensityCompositeOp:\n              {\n                pixel=Sa*GetPixelIntensity(composite_image,p) <\n                  Da*GetPixelIntensity(image,q) ? Sa : Da;\n                break;\n              }\n              case LightenIntensityCompositeOp:\n              {\n                pixel=Sa*GetPixelIntensity(composite_image,p) >\n                  Da*GetPixelIntensity(image,q) ? Sa : Da;\n                break;\n              }\n              case ModulateCompositeOp:\n              {\n                if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n                  {\n                    pixel=QuantumRange*Da;\n                    break;\n                  }\n                pixel=QuantumRange*Da;\n                break;\n              }\n              default:\n              {\n                pixel=QuantumRange*alpha;\n                break;\n              }\n            }\n            q[i]=ClampToQuantum(pixel);\n            continue;\n          }\n        /*\n          Porter-Duff compositions:\n            Sca: source normalized color multiplied by alpha.\n            Dca: normalized destination color multiplied by alpha.\n        */\n        Sca=QuantumScale*Sa*Sc;\n        Dca=QuantumScale*Da*Dc;\n        switch (compose)\n        {\n          case DarkenCompositeOp:\n          case LightenCompositeOp:\n          case ModulusSubtractCompositeOp:\n          {\n            gamma=1.0-alpha;\n            break;\n          }\n          default:\n            break;\n        }\n        gamma=PerceptibleReciprocal(alpha);\n        pixel=Dc;\n        switch (compose)\n        {\n          case AlphaCompositeOp:\n          {\n            pixel=QuantumRange*Sa;\n            break;\n          }\n          case AtopCompositeOp:\n          case SrcAtopCompositeOp:\n          {\n            pixel=QuantumRange*(Sca*Da+Dca*(1.0-Sa));\n            break;\n          }\n          case BlendCompositeOp:\n          {\n            pixel=gamma*(source_dissolve*Sa*Sc+destination_dissolve*Da*Dc);\n            break;\n          }\n          case BlurCompositeOp:\n          case DisplaceCompositeOp:\n          case DistortCompositeOp:\n          case CopyCompositeOp:\n          case ReplaceCompositeOp:\n          case SrcCompositeOp:\n          {\n            pixel=QuantumRange*Sca;\n            break;\n          }\n          case BumpmapCompositeOp:\n          {\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            pixel=QuantumScale*GetPixelIntensity(composite_image,p)*Dc;\n            break;\n          }\n          case ChangeMaskCompositeOp:\n          {\n            pixel=Dc;\n            break;\n          }\n          case ClearCompositeOp:\n          {\n            pixel=0.0;\n            break;\n          }\n          case ColorBurnCompositeOp:\n          {\n            if ((Sca == 0.0) && (Dca == Da))\n              {\n                pixel=QuantumRange*(Sa*Da+Dca*(1.0-Sa));\n                break;\n              }\n            if (Sca == 0.0)\n              {\n                pixel=QuantumRange*(Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Sa*Da-Sa*Da*MagickMin(1.0,(1.0-Dca/Da)*Sa/Sca)+\n              Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case ColorDodgeCompositeOp:\n          {\n            if ((Sca == Sa) && (Dca == 0.0))\n              {\n                pixel=QuantumRange*(Sca*(1.0-Da));\n                break;\n              }\n            if (Sca == Sa)\n              {\n                pixel=QuantumRange*(Sa*Da+Sca*(1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Sa*Da*MagickMin(1.0,Dca/Da*Sa/(Sa-Sca)));\n            break;\n          }\n          case ColorizeCompositeOp:\n          {\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            if (fabs((double) (QuantumRange*Da-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Sc;\n                break;\n              }\n            CompositeHCL(destination_pixel.red,destination_pixel.green,\n              destination_pixel.blue,&sans,&sans,&luma);\n            CompositeHCL(source_pixel.red,source_pixel.green,source_pixel.blue,\n              &hue,&chroma,&sans);\n            HCLComposite(hue,chroma,luma,&red,&green,&blue);\n            switch (channel)\n            {\n              case RedPixelChannel: pixel=red; break;\n              case GreenPixelChannel: pixel=green; break;\n              case BluePixelChannel: pixel=blue; break;\n              default: pixel=Dc; break;\n            }\n            break;\n          }\n          case CopyAlphaCompositeOp:\n          {\n            pixel=Dc;\n            break;\n          }\n          case CopyBlackCompositeOp:\n          {\n            if (channel == BlackPixelChannel)\n              pixel=(MagickRealType) (QuantumRange-\n                GetPixelBlack(composite_image,p));\n            break;\n          }\n          case CopyBlueCompositeOp:\n          case CopyYellowCompositeOp:\n          {\n            if (channel == BluePixelChannel)\n              pixel=(MagickRealType) GetPixelBlue(composite_image,p);\n            break;\n          }\n          case CopyGreenCompositeOp:\n          case CopyMagentaCompositeOp:\n          {\n            if (channel == GreenPixelChannel)\n              pixel=(MagickRealType) GetPixelGreen(composite_image,p);\n            break;\n          }\n          case CopyRedCompositeOp:\n          case CopyCyanCompositeOp:\n          {\n            if (channel == RedPixelChannel)\n              pixel=(MagickRealType) GetPixelRed(composite_image,p);\n            break;\n          }\n          case DarkenCompositeOp:\n          {\n            /*\n              Darken is equivalent to a 'Minimum' method\n                OR a greyscale version of a binary 'Or'\n                OR the 'Intersection' of pixel sets.\n            */\n            if ((Sca*Da) < (Dca*Sa))\n              {\n                pixel=QuantumRange*(Sca+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Dca+Sca*(1.0-Da));\n            break;\n          }\n          case DarkenIntensityCompositeOp:\n          {\n            pixel=Sa*GetPixelIntensity(composite_image,p) <\n              Da*GetPixelIntensity(image,q) ? Sc : Dc;\n            break;\n          }\n          case DifferenceCompositeOp:\n          {\n            pixel=QuantumRange*(Sca+Dca-2.0*MagickMin(Sca*Da,Dca*Sa));\n            break;\n          }\n          case DissolveCompositeOp:\n          {\n            pixel=gamma*(source_dissolve*Sa*Sc-source_dissolve*Sa*\n              destination_dissolve*Da*Dc+destination_dissolve*Da*Dc);\n            break;\n          }\n          case DivideDstCompositeOp:\n          {\n            if ((fabs((double) Sca) < MagickEpsilon) &&\n                (fabs((double) Dca) < MagickEpsilon))\n              {\n                pixel=QuantumRange*(Sca*(1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            if (fabs((double) Dca) < MagickEpsilon)\n              {\n                pixel=QuantumRange*(Sa*Da+Sca*(1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Sca*Da*Da/Dca+Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case DivideSrcCompositeOp:\n          {\n            if ((fabs((double) Dca) < MagickEpsilon) &&\n                (fabs((double) Sca) < MagickEpsilon))\n              {\n                pixel=QuantumRange*(Dca*(1.0-Sa)+Sca*(1.0-Da));\n                break;\n              }\n            if (fabs((double) Sca) < MagickEpsilon)\n              {\n                pixel=QuantumRange*(Da*Sa+Dca*(1.0-Sa)+Sca*(1.0-Da));\n                break;\n              }\n            pixel=QuantumRange*(Dca*Sa*Sa/Sca+Dca*(1.0-Sa)+Sca*(1.0-Da));\n            break;\n          }\n          case DstAtopCompositeOp:\n          {\n            pixel=QuantumRange*(Dca*Sa+Sca*(1.0-Da));\n            break;\n          }\n          case DstCompositeOp:\n          case NoCompositeOp:\n          {\n            pixel=QuantumRange*Dca;\n            break;\n          }\n          case DstInCompositeOp:\n          {\n            pixel=QuantumRange*(Dca*Sa);\n            break;\n          }\n          case DstOutCompositeOp:\n          {\n            pixel=QuantumRange*(Dca*(1.0-Sa));\n            break;\n          }\n          case DstOverCompositeOp:\n          {\n            pixel=QuantumRange*(Dca+Sca*(1.0-Da));\n            break;\n          }\n          case ExclusionCompositeOp:\n          {\n            pixel=QuantumRange*(Sca*Da+Dca*Sa-2.0*Sca*Dca+Sca*(1.0-Da)+Dca*\n              (1.0-Sa));\n            break;\n          }\n          case HardLightCompositeOp:\n          {\n            if ((2.0*Sca) < Sa)\n              {\n                pixel=QuantumRange*(2.0*Sca*Dca+Sca*(1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Sa*Da-2.0*(Da-Dca)*(Sa-Sca)+Sca*(1.0-Da)+Dca*\n              (1.0-Sa));\n            break;\n          }\n          case HardMixCompositeOp:\n          {\n            double\n              gamma;\n\n            if ((Sa+Da) < 1.0)\n              gamma=0.0;\n            else\n              gamma=1.0;\n            pixel=(gamma*(1.0-Sca)*(1.0-Dca))+Sa*(1.0-Sca)*Dca+Da*(1.0-Dca)*Sca;\n            break;\n          }\n          case HueCompositeOp:\n          {\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            if (fabs((double) (QuantumRange*Da-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Sc;\n                break;\n              }\n            CompositeHCL(destination_pixel.red,destination_pixel.green,\n              destination_pixel.blue,&hue,&chroma,&luma);\n            CompositeHCL(source_pixel.red,source_pixel.green,source_pixel.blue,\n              &hue,&sans,&sans);\n            HCLComposite(hue,chroma,luma,&red,&green,&blue);\n            switch (channel)\n            {\n              case RedPixelChannel: pixel=red; break;\n              case GreenPixelChannel: pixel=green; break;\n              case BluePixelChannel: pixel=blue; break;\n              default: pixel=Dc; break;\n            }\n            break;\n          }\n          case InCompositeOp:\n          case SrcInCompositeOp:\n          {\n            pixel=QuantumRange*(Sca*Da);\n            break;\n          }\n          case LinearBurnCompositeOp:\n          {\n            /*\n              LinearBurn: as defined by Abode Photoshop, according to\n              http://www.simplefilter.de/en/basics/mixmods.html is:\n\n                f(Sc,Dc) = Sc + Dc - 1\n            */\n            pixel=QuantumRange*(Sca+Dca-Sa*Da);\n            break;\n          }\n          case LinearDodgeCompositeOp:\n          {\n            pixel=(Sa*Sc+Da*Dc);\n            break;\n          }\n          case LinearLightCompositeOp:\n          {\n            /*\n              LinearLight: as defined by Abode Photoshop, according to\n              http://www.simplefilter.de/en/basics/mixmods.html is:\n\n                f(Sc,Dc) = Dc + 2*Sc - 1\n            */\n            pixel=QuantumRange*((Sca-Sa)*Da+Sca+Dca);\n            break;\n          }\n          case LightenCompositeOp:\n          {\n            if ((Sca*Da) > (Dca*Sa))\n              {\n                pixel=QuantumRange*(Sca+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Dca+Sca*(1.0-Da));\n            break;\n          }\n          case LightenIntensityCompositeOp:\n          {\n            /*\n              Lighten is equivalent to a 'Maximum' method\n                OR a greyscale version of a binary 'And'\n                OR the 'Union' of pixel sets.\n            */\n            pixel=Sa*GetPixelIntensity(composite_image,p) >\n              Da*GetPixelIntensity(image,q) ? Sc : Dc;\n            break;\n          }\n          case LuminizeCompositeOp:\n          {\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            if (fabs((double) (QuantumRange*Da-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Sc;\n                break;\n              }\n            CompositeHCL(destination_pixel.red,destination_pixel.green,\n              destination_pixel.blue,&hue,&chroma,&luma);\n            CompositeHCL(source_pixel.red,source_pixel.green,source_pixel.blue,\n              &sans,&sans,&luma);\n            HCLComposite(hue,chroma,luma,&red,&green,&blue);\n            switch (channel)\n            {\n              case RedPixelChannel: pixel=red; break;\n              case GreenPixelChannel: pixel=green; break;\n              case BluePixelChannel: pixel=blue; break;\n              default: pixel=Dc; break;\n            }\n            break;\n          }\n          case MathematicsCompositeOp:\n          {\n            /*\n              'Mathematics' a free form user control mathematical composition\n              is defined as...\n\n                f(Sc,Dc) = A*Sc*Dc + B*Sc + C*Dc + D\n\n              Where the arguments A,B,C,D are (currently) passed to composite\n              as a command separated 'geometry' string in \"compose:args\" image\n              artifact.\n\n                 A = a->rho,   B = a->sigma,  C = a->xi,  D = a->psi\n\n              Applying the SVG transparency formula (see above), we get...\n\n               Dca' = Sa*Da*f(Sc,Dc) + Sca*(1.0-Da) + Dca*(1.0-Sa)\n\n               Dca' = A*Sca*Dca + B*Sca*Da + C*Dca*Sa + D*Sa*Da + Sca*(1.0-Da) +\n                 Dca*(1.0-Sa)\n            */\n            pixel=gamma*geometry_info.rho*Sa*Sc*Da*Dc+geometry_info.sigma*\n              Sa*Sc*Da+geometry_info.xi*Da*Dc*Sa+geometry_info.psi*Sa*Da+\n              Sa*Sc*(1.0-Da)+Da*Dc*(1.0-Sa);\n            break;\n          }\n          case MinusDstCompositeOp:\n          {\n            pixel=gamma*(Sa*Sc+Da*Dc-2.0*Da*Dc*Sa);\n            break;\n          }\n          case MinusSrcCompositeOp:\n          {\n            /*\n              Minus source from destination.\n\n                f(Sc,Dc) = Sc - Dc\n            */\n            pixel=QuantumRange*(Da*Dc+Sa*Sc-2.0*Sa*Sc*Da);\n            break;\n          }\n          case ModulateCompositeOp:\n          {\n            ssize_t\n              offset;\n\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            offset=(ssize_t) (GetPixelIntensity(composite_image,p)-midpoint);\n            if (offset == 0)\n              {\n                pixel=Dc;\n                break;\n              }\n            CompositeHCL(destination_pixel.red,destination_pixel.green,\n              destination_pixel.blue,&hue,&chroma,&luma);\n            luma+=(0.01*percent_luma*offset)/midpoint;\n            chroma*=0.01*percent_chroma;\n            HCLComposite(hue,chroma,luma,&red,&green,&blue);\n            switch (channel)\n            {\n              case RedPixelChannel: pixel=red; break;\n              case GreenPixelChannel: pixel=green; break;\n              case BluePixelChannel: pixel=blue; break;\n              default: pixel=Dc; break;\n            }\n            break;\n          }\n          case ModulusAddCompositeOp:\n          {\n            pixel=Sc+Dc;\n            if (pixel > QuantumRange)\n              pixel-=QuantumRange;\n            pixel=gamma*(Sa*Da*pixel+Sa*Sc*(1.0-Da)+Da*Dc*(1.0-Sa));\n            break;\n          }\n          case ModulusSubtractCompositeOp:\n          {\n            pixel=Sc-Dc;\n            if (pixel < 0.0)\n              pixel+=QuantumRange;\n            pixel=gamma*(Sa*Da*pixel+Sa*Sc*(1.0-Da)+Da*Dc*(1.0-Sa));\n            break;\n          }\n          case MultiplyCompositeOp:\n          {\n            pixel=QuantumRange*(Sca*Dca+Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case OutCompositeOp:\n          case SrcOutCompositeOp:\n          {\n            pixel=QuantumRange*(Sca*(1.0-Da));\n            break;\n          }\n          case OverCompositeOp:\n          case SrcOverCompositeOp:\n          {\n            pixel=QuantumRange*(Sca+Dca*(1.0-Sa));\n            break;\n          }\n          case OverlayCompositeOp:\n          {\n            if ((2.0*Dca) <= Da)\n              {\n                pixel=QuantumRange*(2.0*Sca*Dca+Sca*(1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Sa*Da-2.0*(Da-Dca)*(Sa-Sca)+Sca*(1.0-Da)+Dca*\n              (1.0-Sa));\n            break;\n          }\n          case PegtopLightCompositeOp:\n          {\n            /*\n              PegTop: A Soft-Light alternative: A continuous version of the\n              Softlight function, producing very similar results.\n\n                f(Sc,Dc) = Dc^2*(1-2*Sc) + 2*Sc*Dc\n\n              http://www.pegtop.net/delphi/articles/blendmodes/softlight.htm.\n            */\n            if (fabs((double) Da) < MagickEpsilon)\n              {\n                pixel=QuantumRange*(Sca);\n                break;\n              }\n            pixel=QuantumRange*(Dca*Dca*(Sa-2.0*Sca)/Da+Sca*(2.0*Dca+1.0-Da)+\n              Dca*(1.0-Sa));\n            break;\n          }\n          case PinLightCompositeOp:\n          {\n            /*\n              PinLight: A Photoshop 7 composition method\n              http://www.simplefilter.de/en/basics/mixmods.html\n\n                f(Sc,Dc) = Dc<2*Sc-1 ? 2*Sc-1 : Dc>2*Sc   ? 2*Sc : Dc\n            */\n            if ((Dca*Sa) < (Da*(2.0*Sca-Sa)))\n              {\n                pixel=QuantumRange*(Sca*(Da+1.0)-Sa*Da+Dca*(1.0-Sa));\n                break;\n              }\n            if ((Dca*Sa) > (2.0*Sca*Da))\n              {\n                pixel=QuantumRange*(Sca*Da+Sca+Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Sca*(1.0-Da)+Dca);\n            break;\n          }\n          case PlusCompositeOp:\n          {\n            pixel=QuantumRange*(Sca+Dca);\n            break;\n          }\n          case SaturateCompositeOp:\n          {\n            if (fabs((double) (QuantumRange*Sa-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Dc;\n                break;\n              }\n            if (fabs((double) (QuantumRange*Da-TransparentAlpha)) < MagickEpsilon)\n              {\n                pixel=Sc;\n                break;\n              }\n            CompositeHCL(destination_pixel.red,destination_pixel.green,\n              destination_pixel.blue,&hue,&chroma,&luma);\n            CompositeHCL(source_pixel.red,source_pixel.green,source_pixel.blue,\n              &sans,&chroma,&sans);\n            HCLComposite(hue,chroma,luma,&red,&green,&blue);\n            switch (channel)\n            {\n              case RedPixelChannel: pixel=red; break;\n              case GreenPixelChannel: pixel=green; break;\n              case BluePixelChannel: pixel=blue; break;\n              default: pixel=Dc; break;\n            }\n            break;\n          }\n          case ScreenCompositeOp:\n          {\n            /*\n              Screen:  a negated multiply:\n\n                f(Sc,Dc) = 1.0-(1.0-Sc)*(1.0-Dc)\n            */\n            pixel=QuantumRange*(Sca+Dca-Sca*Dca);\n            break;\n          }\n          case SoftLightCompositeOp:\n          {\n            if ((2.0*Sca) < Sa)\n              {\n                pixel=QuantumRange*(Dca*(Sa+(2.0*Sca-Sa)*(1.0-(Dca/Da)))+Sca*\n                  (1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            if (((2.0*Sca) > Sa) && ((4.0*Dca) <= Da))\n              {\n                pixel=QuantumRange*(Dca*Sa+Da*(2.0*Sca-Sa)*(4.0*(Dca/Da)*(4.0*\n                  (Dca/Da)+1.0)*((Dca/Da)-1.0)+7.0*(Dca/Da))+Sca*(1.0-Da)+Dca*\n                  (1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Dca*Sa+Da*(2.0*Sca-Sa)*(pow((Dca/Da),0.5)-(Dca/\n              Da))+Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          case ThresholdCompositeOp:\n          {\n            MagickRealType\n              delta;\n\n            delta=Sc-Dc;\n            if ((MagickRealType) fabs((double) (2.0*delta)) < threshold)\n              {\n                pixel=gamma*Dc;\n                break;\n              }\n            pixel=gamma*(Dc+delta*amount);\n            break;\n          }\n          case VividLightCompositeOp:\n          {\n            /*\n              VividLight: A Photoshop 7 composition method.  See\n              http://www.simplefilter.de/en/basics/mixmods.html.\n\n                f(Sc,Dc) = (2*Sc < 1) ? 1-(1-Dc)/(2*Sc) : Dc/(2*(1-Sc))\n            */\n            if ((fabs((double) Sa) < MagickEpsilon) ||\n                (fabs((double) (Sca-Sa)) < MagickEpsilon))\n              {\n                pixel=QuantumRange*(Sa*Da+Sca*(1.0-Da)+Dca*(1.0-Sa));\n                break;\n              }\n            if ((2.0*Sca) <= Sa)\n              {\n                pixel=QuantumRange*(Sa*(Da+Sa*(Dca-Da)/(2.0*Sca))+Sca*(1.0-Da)+\n                  Dca*(1.0-Sa));\n                break;\n              }\n            pixel=QuantumRange*(Dca*Sa*Sa/(2.0*(Sa-Sca))+Sca*(1.0-Da)+Dca*\n              (1.0-Sa));\n            break;\n          }\n          case XorCompositeOp:\n          {\n            pixel=QuantumRange*(Sca*(1.0-Da)+Dca*(1.0-Sa));\n            break;\n          }\n          default:\n          {\n            pixel=Sc;\n            break;\n          }\n        }\n        q[i]=ClampPixel(pixel);\n      }\n      p+=GetPixelChannels(composite_image);\n      channels=GetPixelChannels(composite_image);\n      if (p >= (pixels+channels*composite_image->columns))\n        p=pixels;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_CompositeImage)\n#endif\n        proceed=SetImageProgress(image,CompositeImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  composite_view=DestroyCacheView(composite_view);\n  image_view=DestroyCacheView(image_view);\n  if (destination_image != (Image * ) NULL)\n    destination_image=DestroyImage(destination_image);\n  else\n    composite_image=DestroyImage(composite_image);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     T e x t u r e I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  TextureImage() repeatedly tiles the texture image across and down the image\n%  canvas.\n%\n%  The format of the TextureImage method is:\n%\n%      MagickBooleanType TextureImage(Image *image,const Image *texture,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o texture_image: This image is the texture to layer on the background.\n%\n*/\nMagickExport MagickBooleanType TextureImage(Image *image,const Image *texture,\n  ExceptionInfo *exception)\n{\n#define TextureImageTag  \"Texture/Image\"\n\n  CacheView\n    *image_view,\n    *texture_view;\n\n  Image\n    *texture_image;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  if (texture == (const Image *) NULL)\n    return(MagickFalse);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  texture_image=CloneImage(texture,0,0,MagickTrue,exception);\n  if (texture_image == (const Image *) NULL)\n    return(MagickFalse);\n  (void) TransformImageColorspace(texture_image,image->colorspace,exception);\n  (void) SetImageVirtualPixelMethod(texture_image,TileVirtualPixelMethod,\n    exception);\n  status=MagickTrue;\n  if ((image->compose != CopyCompositeOp) &&\n      ((image->compose != OverCompositeOp) ||\n       (image->alpha_trait != UndefinedPixelTrait) ||\n       (texture_image->alpha_trait != UndefinedPixelTrait)))\n    {\n      /*\n        Tile texture onto the image background.\n      */\n      for (y=0; y < (ssize_t) image->rows; y+=(ssize_t) texture_image->rows)\n      {\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        for (x=0; x < (ssize_t) image->columns; x+=(ssize_t) texture_image->columns)\n        {\n          MagickBooleanType\n            thread_status;\n\n          thread_status=CompositeImage(image,texture_image,image->compose,\n            MagickFalse,x+texture_image->tile_offset.x,y+\n            texture_image->tile_offset.y,exception);\n          if (thread_status == MagickFalse)\n            {\n              status=thread_status;\n              break;\n            }\n        }\n        if (image->progress_monitor != (MagickProgressMonitor) NULL)\n          {\n            MagickBooleanType\n              proceed;\n\n            proceed=SetImageProgress(image,TextureImageTag,(MagickOffsetType)\n              y,image->rows);\n            if (proceed == MagickFalse)\n              status=MagickFalse;\n          }\n      }\n      (void) SetImageProgress(image,TextureImageTag,(MagickOffsetType)\n        image->rows,image->rows);\n      texture_image=DestroyImage(texture_image);\n      return(status);\n    }\n  /*\n    Tile texture onto the image background (optimized).\n  */\n  status=MagickTrue;\n  texture_view=AcquireVirtualCacheView(texture_image,exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(texture_image,image,1,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    MagickBooleanType\n      sync;\n\n    register const Quantum\n      *p,\n      *pixels;\n\n    register ssize_t\n      x;\n\n    register Quantum\n      *q;\n\n    size_t\n      width;\n\n    if (status == MagickFalse)\n      continue;\n    pixels=GetCacheViewVirtualPixels(texture_view,texture_image->tile_offset.x,\n      (y+texture_image->tile_offset.y) % texture_image->rows,\n      texture_image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if ((pixels == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x+=(ssize_t) texture_image->columns)\n    {\n      register ssize_t\n        j;\n\n      p=pixels;\n      width=texture_image->columns;\n      if ((x+(ssize_t) width) > (ssize_t) image->columns)\n        width=image->columns-x;\n      for (j=0; j < (ssize_t) width; j++)\n      {\n        register ssize_t\n          i;\n\n        if (GetPixelReadMask(image,q) == 0)\n          {\n            p+=GetPixelChannels(texture_image);\n            q+=GetPixelChannels(image);\n            continue;\n          }\n        for (i=0; i < (ssize_t) GetPixelChannels(texture_image); i++)\n        {\n          PixelChannel channel=GetPixelChannelChannel(texture_image,i);\n          PixelTrait traits=GetPixelChannelTraits(image,channel);\n          PixelTrait texture_traits=GetPixelChannelTraits(texture_image,\n            channel);\n          if ((traits == UndefinedPixelTrait) ||\n              (texture_traits == UndefinedPixelTrait))\n            continue;\n          SetPixelChannel(image,channel,p[i],q);\n        }\n        p+=GetPixelChannels(texture_image);\n        q+=GetPixelChannels(image);\n      }\n    }\n    sync=SyncCacheViewAuthenticPixels(image_view,exception);\n    if (sync == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n        proceed=SetImageProgress(image,TextureImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  texture_view=DestroyCacheView(texture_view);\n  image_view=DestroyCacheView(image_view);\n  texture_image=DestroyImage(texture_image);\n  return(status);\n}\n", "/*\n  Copyright 1999-2015 ImageMagick Studio LLC, a non-profit organization\n  dedicated to making software imaging solutions freely available.\n\n  You may not use this file except in compliance with the License.\n  obtain a copy of the License at\n\n    http://www.imagemagick.org/script/license.php\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n  MagickCore pixel accessor methods.\n*/\n#ifndef _MAGICKCORE_PIXEL_ACCESSOR_H\n#define _MAGICKCORE_PIXEL_ACCESSOR_H\n\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/image.h\"\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#undef index\n\nstatic inline Quantum ClampPixel(const MagickRealType value)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((Quantum) value);\n#else\n  if (value < 0.0)\n    return((Quantum) 0.0);\n  if (value >= (MagickRealType) QuantumRange)\n    return((Quantum) QuantumRange);\n  return((Quantum) value);\n#endif\n}\n\nstatic inline Quantum GetPixela(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[aPixelChannel].offset]);\n}\n\nstatic inline Quantum GetPixelAlpha(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  if (image->channel_map[AlphaPixelChannel].traits == UndefinedPixelTrait)\n    return(OpaqueAlpha);\n  return(pixel[image->channel_map[AlphaPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelAlphaTraits(const Image *restrict image)\n{\n  return(image->channel_map[AlphaPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelb(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[bPixelChannel].offset]);\n}\n\nstatic inline Quantum GetPixelBlack(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  if (image->channel_map[BlackPixelChannel].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[BlackPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelBlackTraits(const Image *restrict image)\n{\n  return(image->channel_map[BlackPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelBlue(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[BluePixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelBlueTraits(const Image *restrict image)\n{\n  return(image->channel_map[BluePixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelCb(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[CbPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelCbTraits(const Image *restrict image)\n{\n  return(image->channel_map[CbPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelChannel(const Image *restrict image,\n  const PixelChannel channel,const Quantum *restrict pixel)\n{\n  if (image->channel_map[channel].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[channel].offset]);\n}\n\nstatic inline PixelChannel GetPixelChannelChannel(const Image *restrict image,\n  const ssize_t offset)\n{\n  return(image->channel_map[offset].channel);\n}\n\nstatic inline ssize_t GetPixelChannelOffset(const Image *restrict image,\n  const PixelChannel channel)\n{\n  return(image->channel_map[channel].offset);\n}\n\nstatic inline PixelTrait GetPixelChannelTraits(const Image *restrict image,\n  const PixelChannel channel)\n{\n  return(image->channel_map[channel].traits);\n}\n\nstatic inline size_t GetPixelChannels(const Image *restrict image)\n{\n  return(image->number_channels);\n}\n\nstatic inline Quantum GetPixelCr(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[CrPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelCrTraits(const Image *restrict image)\n{\n  return(image->channel_map[CrPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelCyan(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[CyanPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelCyanTraits(const Image *restrict image)\n{\n  return(image->channel_map[CyanPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelGray(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[GrayPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelGrayTraits(const Image *restrict image)\n{\n  return(image->channel_map[GrayPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelGreen(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[GreenPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelGreenTraits(const Image *restrict image)\n{\n  return(image->channel_map[GreenPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelIndex(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  if (image->channel_map[IndexPixelChannel].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[IndexPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelIndexTraits(const Image *restrict image)\n{\n  return(image->channel_map[IndexPixelChannel].traits);\n}\n\nstatic inline MagickRealType GetPixelInfoChannel(\n  const PixelInfo *restrict pixel_info,const PixelChannel channel)\n{\n  switch (channel)\n  {\n    case RedPixelChannel: return(pixel_info->red);\n    case GreenPixelChannel: return(pixel_info->green);\n    case BluePixelChannel: return(pixel_info->blue);\n    case BlackPixelChannel: return(pixel_info->black);\n    case AlphaPixelChannel: return(pixel_info->alpha);\n    case IndexPixelChannel: return(pixel_info->index);\n    default: return((MagickRealType) 0.0);\n  }\n}\n\nstatic inline MagickRealType GetPixelInfoLuma(const PixelInfo *restrict pixel)\n{\n  MagickRealType\n    blue,\n    green,\n    red;\n\n  if (pixel->colorspace == GRAYColorspace)\n    return(pixel->red);\n  if (pixel->colorspace == sRGBColorspace)\n    return(0.212656f*pixel->red+0.715158f*pixel->green+0.072186f*pixel->blue);\n  red=EncodePixelGamma(pixel->red);\n  green=EncodePixelGamma(pixel->green);\n  blue=EncodePixelGamma(pixel->blue);\n  return(0.212656f*red+0.715158f*green+0.072186f*blue);\n}\n\nstatic inline MagickRealType GetPixelInfoLuminance(\n  const PixelInfo *restrict pixel)\n{\n  MagickRealType\n    blue,\n    green,\n    red;\n\n  if (pixel->colorspace == GRAYColorspace)\n    return(pixel->red);\n  if (pixel->colorspace != sRGBColorspace)\n    return(0.212656f*pixel->red+0.715158f*pixel->green+0.072186f*pixel->blue);\n  red=DecodePixelGamma(pixel->red);\n  green=DecodePixelGamma(pixel->green);\n  blue=DecodePixelGamma(pixel->blue);\n  return(0.212656f*red+0.715158f*green+0.072186f*blue);\n}\n\nstatic inline Quantum GetPixelL(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[LPixelChannel].offset]);\n}\n\nstatic inline MagickRealType GetPixelLuma(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  if (image->colorspace == GRAYColorspace)\n    return((MagickRealType) pixel[image->channel_map[GrayPixelChannel].offset]);\n  return(0.212656f*pixel[image->channel_map[RedPixelChannel].offset]+\n    0.715158f*pixel[image->channel_map[GreenPixelChannel].offset]+\n    0.072186f*pixel[image->channel_map[BluePixelChannel].offset]);  /* Rec709 */\n}\n\nstatic inline MagickRealType GetPixelLuminance(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  MagickRealType\n    blue,\n    green,\n    red;\n\n  if (image->colorspace == GRAYColorspace)\n    return((MagickRealType) pixel[image->channel_map[GrayPixelChannel].offset]);\n  if (image->colorspace != sRGBColorspace)\n    return(0.212656f*pixel[image->channel_map[RedPixelChannel].offset]+\n      0.715158f*pixel[image->channel_map[GreenPixelChannel].offset]+\n      0.072186f*pixel[image->channel_map[BluePixelChannel].offset]);\n  red=DecodePixelGamma((MagickRealType)\n    pixel[image->channel_map[RedPixelChannel].offset]);\n  green=DecodePixelGamma((MagickRealType)\n    pixel[image->channel_map[GreenPixelChannel].offset]);\n  blue=DecodePixelGamma((MagickRealType)\n    pixel[image->channel_map[BluePixelChannel].offset]);\n  return(0.212656f*red+0.715158f*green+0.072186f*blue);  /* Rec709 */\n}\n\nstatic inline Quantum GetPixelMagenta(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[MagentaPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelMagentaTraits(const Image *restrict image)\n{\n  return(image->channel_map[MagentaPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelReadMask(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  if (image->channel_map[ReadMaskPixelChannel].traits == UndefinedPixelTrait)\n    return((Quantum) QuantumRange);\n  return(pixel[image->channel_map[ReadMaskPixelChannel].offset]);\n}\n\nstatic inline Quantum GetPixelWriteMask(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  if (image->channel_map[WriteMaskPixelChannel].traits == UndefinedPixelTrait)\n    return((Quantum) QuantumRange);\n  return(pixel[image->channel_map[WriteMaskPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelReadMaskTraits(const Image *restrict image)\n{\n  return(image->channel_map[ReadMaskPixelChannel].traits);\n}\n\nstatic inline size_t GetPixelMetaChannels(const Image *restrict image)\n{\n  return(image->number_meta_channels);\n}\n\nstatic inline size_t GetPixelMetacontentExtent(const Image *restrict image)\n{\n  return(image->metacontent_extent);\n}\n\nstatic inline Quantum GetPixelOpacity(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  if (image->channel_map[AlphaPixelChannel].traits != BlendPixelTrait)\n    return(QuantumRange-OpaqueAlpha);\n  return(QuantumRange-pixel[image->channel_map[AlphaPixelChannel].offset]);\n}\n\nstatic inline Quantum GetPixelRed(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[RedPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelRedTraits(const Image *restrict image)\n{\n  return(image->channel_map[RedPixelChannel].traits);\n}\n\nstatic inline void GetPixelInfoPixel(const Image *restrict image,\n  const Quantum *restrict pixel,PixelInfo *restrict pixel_info)\n{\n  pixel_info->colorspace=image->colorspace;\n  pixel_info->fuzz=image->fuzz;\n  pixel_info->red=(MagickRealType)\n    pixel[image->channel_map[RedPixelChannel].offset];\n  pixel_info->green=(MagickRealType)\n    pixel[image->channel_map[GreenPixelChannel].offset];\n  pixel_info->blue=(MagickRealType)\n    pixel[image->channel_map[BluePixelChannel].offset];\n  pixel_info->black=0.0f;\n  if (image->channel_map[BlackPixelChannel].traits != UndefinedPixelTrait)\n    pixel_info->black=(MagickRealType)\n      pixel[image->channel_map[BlackPixelChannel].offset];\n  pixel_info->alpha=(MagickRealType) OpaqueAlpha;\n  pixel_info->alpha_trait=UndefinedPixelTrait;\n  if (image->channel_map[AlphaPixelChannel].traits != UndefinedPixelTrait)\n    {\n      pixel_info->alpha=(MagickRealType)\n        pixel[image->channel_map[AlphaPixelChannel].offset];\n      pixel_info->alpha_trait=BlendPixelTrait;\n    }\n  pixel_info->index=0.0f;\n  if (image->channel_map[IndexPixelChannel].traits != UndefinedPixelTrait)\n    pixel_info->index=(MagickRealType)\n      pixel[image->channel_map[IndexPixelChannel].offset];\n}\n\nstatic inline PixelTrait GetPixelTraits(const Image *restrict image,\n  const PixelChannel channel)\n{\n  return(image->channel_map[channel].traits);\n}\n\nstatic inline Quantum GetPixelY(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[YPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelYTraits(const Image *restrict image)\n{\n  return(image->channel_map[YPixelChannel].traits);\n}\n\nstatic inline Quantum GetPixelYellow(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  return(pixel[image->channel_map[YellowPixelChannel].offset]);\n}\n\nstatic inline PixelTrait GetPixelYellowTraits(const Image *restrict image)\n{\n  return(image->channel_map[YellowPixelChannel].traits);\n}\n\nstatic inline MagickRealType AbsolutePixelValue(const MagickRealType x)\n{\n  return(x < 0.0f ? -x : x);\n}\n\nstatic inline MagickBooleanType IsPixelAtDepth(const Quantum pixel,\n  const QuantumAny range)\n{\n  Quantum\n    quantum;\n\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  quantum=(Quantum) (((MagickRealType) QuantumRange*((QuantumAny) \n    (((MagickRealType) range*pixel)/QuantumRange+0.5)))/range+0.5);\n#else\n  quantum=(Quantum) (((MagickRealType) QuantumRange*((QuantumAny) \n    (((MagickRealType) range*pixel)/QuantumRange+0.5)))/range);\n#endif\n  return(pixel == quantum ? MagickTrue : MagickFalse);\n}\n\nstatic inline MagickBooleanType IsPixelEquivalent(const Image *restrict image,\n  const Quantum *restrict p,const PixelInfo *restrict q)\n{\n  MagickRealType\n    blue,\n    green,\n    red;\n\n  red=(MagickRealType) p[image->channel_map[RedPixelChannel].offset];\n  green=(MagickRealType) p[image->channel_map[GreenPixelChannel].offset];\n  blue=(MagickRealType) p[image->channel_map[BluePixelChannel].offset];\n  if ((AbsolutePixelValue(red-q->red) < MagickEpsilon) &&\n      (AbsolutePixelValue(green-q->green) < MagickEpsilon) &&\n      (AbsolutePixelValue(blue-q->blue) < MagickEpsilon))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic inline MagickBooleanType IsPixelGray(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  MagickRealType\n    blue,\n    green,\n    red;\n\n  red=(MagickRealType) pixel[image->channel_map[RedPixelChannel].offset];\n  green=(MagickRealType) pixel[image->channel_map[GreenPixelChannel].offset];\n  blue=(MagickRealType) pixel[image->channel_map[BluePixelChannel].offset];\n  if ((AbsolutePixelValue(red-green) < MagickEpsilon) &&\n      (AbsolutePixelValue(green-blue) < MagickEpsilon))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic inline MagickBooleanType IsPixelInfoEquivalent(\n  const PixelInfo *restrict p,const PixelInfo *restrict q)\n{\n  if ((p->alpha_trait != UndefinedPixelTrait) &&\n      (q->alpha_trait == UndefinedPixelTrait) &&\n      (AbsolutePixelValue(p->alpha-OpaqueAlpha) >= MagickEpsilon))\n    return(MagickFalse);\n  if ((q->alpha_trait != UndefinedPixelTrait) &&\n      (p->alpha_trait == UndefinedPixelTrait) &&\n      (AbsolutePixelValue(q->alpha-OpaqueAlpha)) >= MagickEpsilon)\n    return(MagickFalse);\n  if ((p->alpha_trait != UndefinedPixelTrait) &&\n      (q->alpha_trait != UndefinedPixelTrait))\n    {\n      if (AbsolutePixelValue(p->alpha-q->alpha) >= MagickEpsilon)\n        return(MagickFalse);\n      if (AbsolutePixelValue(p->alpha-TransparentAlpha) < MagickEpsilon)\n        return(MagickTrue);\n    }\n  if (AbsolutePixelValue(p->red-q->red) >= MagickEpsilon)\n    return(MagickFalse);\n  if (AbsolutePixelValue(p->green-q->green) >= MagickEpsilon)\n    return(MagickFalse);\n  if (AbsolutePixelValue(p->blue-q->blue) >= MagickEpsilon)\n    return(MagickFalse);\n  if ((p->colorspace == CMYKColorspace) &&\n      (AbsolutePixelValue(p->black-q->black) >= MagickEpsilon))\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\nstatic inline MagickBooleanType IsPixelMonochrome(const Image *restrict image,\n  const Quantum *restrict pixel)\n{\n  MagickRealType\n    blue,\n    green,\n    red;\n\n  red=(MagickRealType) pixel[image->channel_map[RedPixelChannel].offset];\n  if ((AbsolutePixelValue(red) >= MagickEpsilon) ||\n      (AbsolutePixelValue(red-QuantumRange) >= MagickEpsilon))\n    return(MagickFalse);\n  green=(MagickRealType) pixel[image->channel_map[GreenPixelChannel].offset];\n  blue=(MagickRealType) pixel[image->channel_map[BluePixelChannel].offset];\n  if ((AbsolutePixelValue(red-green) < MagickEpsilon) &&\n      (AbsolutePixelValue(green-blue) < MagickEpsilon))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic inline MagickBooleanType IsPixelInfoGray(\n  const PixelInfo *restrict pixel_info)\n{\n  if ((pixel_info->colorspace != GRAYColorspace) &&\n      (pixel_info->colorspace != RGBColorspace))\n    return(MagickFalse);\n  if ((AbsolutePixelValue(pixel_info->red-pixel_info->green) < MagickEpsilon) &&\n      (AbsolutePixelValue(pixel_info->green-pixel_info->blue) < MagickEpsilon))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic inline MagickBooleanType IsPixelInfoMonochrome(\n  const PixelInfo *restrict pixel_info)\n{\n  if ((pixel_info->colorspace != GRAYColorspace) &&\n      (pixel_info->colorspace != RGBColorspace))\n    return(MagickFalse);\n  if ((AbsolutePixelValue(pixel_info->red) >= MagickEpsilon) ||\n      (AbsolutePixelValue(pixel_info->red-QuantumRange) >= MagickEpsilon))\n    return(MagickFalse);\n  if ((AbsolutePixelValue(pixel_info->red-pixel_info->green) < MagickEpsilon) &&\n      (AbsolutePixelValue(pixel_info->green-pixel_info->blue) < MagickEpsilon))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\nstatic inline void SetPixela(const Image *restrict image,\n  const Quantum a,Quantum *restrict pixel)\n{\n  if (image->channel_map[aPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[aPixelChannel].offset]=a;\n}\n\nstatic inline void SetPixelAlpha(const Image *restrict image,\n  const Quantum alpha,Quantum *restrict pixel)\n{\n  if (image->channel_map[AlphaPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[AlphaPixelChannel].offset]=alpha;\n}\n\nstatic inline void SetPixelAlphaTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[AlphaPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelb(const Image *restrict image,\n  const Quantum b,Quantum *restrict pixel)\n{\n  if (image->channel_map[bPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[bPixelChannel].offset]=b;\n}\n\nstatic inline void SetPixelBackgoundColor(const Image *restrict image,\n  Quantum *restrict pixel)\n{\n  register ssize_t\n    i;\n\n  for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n    pixel[i]=0;\n  pixel[image->channel_map[RedPixelChannel].offset]=\n    ClampToQuantum(image->background_color.red);\n  pixel[image->channel_map[GreenPixelChannel].offset]=\n    ClampToQuantum(image->background_color.green);\n  pixel[image->channel_map[BluePixelChannel].offset]=\n    ClampToQuantum(image->background_color.blue);\n  if (image->channel_map[BlackPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[BlackPixelChannel].offset]=\n      ClampToQuantum(image->background_color.black);\n  if (image->channel_map[AlphaPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[AlphaPixelChannel].offset]=\n      image->background_color.alpha_trait == UndefinedPixelTrait ? OpaqueAlpha :\n      ClampToQuantum(image->background_color.alpha);\n}\n\nstatic inline void SetPixelBlack(const Image *restrict image,\n  const Quantum black,Quantum *restrict pixel)\n{\n  if (image->channel_map[BlackPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[BlackPixelChannel].offset]=black;\n}\n\nstatic inline void SetPixelBlackTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[BlackPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelBlue(const Image *restrict image,const Quantum blue,\n  Quantum *restrict pixel)\n{\n  pixel[image->channel_map[BluePixelChannel].offset]=blue;\n}\n\nstatic inline void SetPixelBlueTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[BluePixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelCb(const Image *restrict image,const Quantum cb,\n  Quantum *restrict pixel)\n{\n  pixel[image->channel_map[CbPixelChannel].offset]=cb;\n}\n\nstatic inline void SetPixelCbTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[CbPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelChannel(const Image *restrict image,\n  const PixelChannel channel,const Quantum quantum,Quantum *restrict pixel)\n{\n  if (image->channel_map[channel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[channel].offset]=quantum;\n}\n\nstatic inline void SetPixelChannelAttributes(const Image *restrict image,\n  const PixelChannel channel,const PixelTrait traits,const ssize_t offset)\n{\n  image->channel_map[offset].channel=channel;\n  image->channel_map[channel].offset=offset;\n  image->channel_map[channel].traits=traits;\n}\n\nstatic inline void SetPixelChannelChannel(const Image *restrict image,\n  const PixelChannel channel,const ssize_t offset)\n{\n  image->channel_map[offset].channel=channel;\n  image->channel_map[channel].offset=offset;\n}\n\nstatic inline void SetPixelChannels(Image *image,const size_t number_channels)\n{\n  image->number_channels=number_channels;\n}\n\nstatic inline void SetPixelChannelTraits(Image *image,\n  const PixelChannel channel,const PixelTrait traits)\n{\n  image->channel_map[channel].traits=traits;\n}\n\nstatic inline void SetPixelCr(const Image *restrict image,const Quantum cr,\n  Quantum *restrict pixel)\n{\n  pixel[image->channel_map[CrPixelChannel].offset]=cr;\n}\n\nstatic inline void SetPixelCrTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[CrPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelCyan(const Image *restrict image,const Quantum cyan,\n  Quantum *restrict pixel)\n{\n  pixel[image->channel_map[CyanPixelChannel].offset]=cyan;\n}\n\nstatic inline void SetPixelGray(const Image *restrict image,const Quantum gray,\n  Quantum *restrict pixel)\n{\n  pixel[image->channel_map[GrayPixelChannel].offset]=gray;\n}\n\nstatic inline void SetPixelGrayTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[GrayPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelGreen(const Image *restrict image,\n  const Quantum green,Quantum *restrict pixel)\n{\n  pixel[image->channel_map[GreenPixelChannel].offset]=green;\n}\n\nstatic inline void SetPixelGreenTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[GreenPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelIndex(const Image *restrict image,\n  const Quantum index,Quantum *restrict pixel)\n{\n  if (image->channel_map[IndexPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[IndexPixelChannel].offset]=index;\n}\n\nstatic inline void SetPixelIndexTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[IndexPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelViaPixelInfo(const Image *restrict image,\n  const PixelInfo *restrict pixel_info,Quantum *restrict pixel)\n{\n  pixel[image->channel_map[RedPixelChannel].offset]=\n    ClampToQuantum(pixel_info->red);\n  pixel[image->channel_map[GreenPixelChannel].offset]=\n    ClampToQuantum(pixel_info->green);\n  pixel[image->channel_map[BluePixelChannel].offset]=\n    ClampToQuantum(pixel_info->blue);\n  if (image->channel_map[BlackPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[BlackPixelChannel].offset]=\n      ClampToQuantum(pixel_info->black);\n  if (image->channel_map[AlphaPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[AlphaPixelChannel].offset]=\n      pixel_info->alpha_trait == UndefinedPixelTrait ? OpaqueAlpha :\n      ClampToQuantum(pixel_info->alpha);\n}\n\nstatic inline void SetPixelL(const Image *restrict image,const Quantum L,\n  Quantum *restrict pixel)\n{\n  if (image->channel_map[LPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[LPixelChannel].offset]=L;\n}\n\nstatic inline void SetPixelMagenta(const Image *restrict image,\n  const Quantum magenta,Quantum *restrict pixel)\n{\n  pixel[image->channel_map[MagentaPixelChannel].offset]=magenta;\n}\n\nstatic inline void SetPixelMagentaTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[MagentaPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelReadMask(const Image *restrict image,\n  const Quantum mask,Quantum *restrict pixel)\n{\n  if (image->channel_map[ReadMaskPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[ReadMaskPixelChannel].offset]=mask;\n}\n\nstatic inline void SetPixelWriteMask(const Image *restrict image,\n  const Quantum mask,Quantum *restrict pixel)\n{\n  if (image->channel_map[WriteMaskPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[WriteMaskPixelChannel].offset]=mask;\n}\n\nstatic inline void SetPixelMetacontentExtent(Image *image,const size_t extent)\n{\n  image->metacontent_extent=extent;\n}\n\nstatic inline void SetPixelOpacity(const Image *restrict image,\n  const Quantum alpha,Quantum *restrict pixel)\n{\n  if (image->channel_map[AlphaPixelChannel].traits != UndefinedPixelTrait)\n    pixel[image->channel_map[AlphaPixelChannel].offset]=QuantumRange-alpha;\n}\n\nstatic inline void SetPixelRed(const Image *restrict image,const Quantum red,\n  Quantum *restrict pixel)\n{\n  pixel[image->channel_map[RedPixelChannel].offset]=red;\n}\n\nstatic inline void SetPixelRedTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[RedPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelYellow(const Image *restrict image,\n  const Quantum yellow,Quantum *restrict pixel)\n{\n  pixel[image->channel_map[YellowPixelChannel].offset]=yellow;\n}\n\nstatic inline void SetPixelYellowTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[YellowPixelChannel].traits=traits;\n}\n\nstatic inline void SetPixelY(const Image *restrict image,const Quantum y,\n  Quantum *restrict pixel)\n{\n  pixel[image->channel_map[YPixelChannel].offset]=y;\n}\n\nstatic inline void SetPixelYTraits(Image *image,const PixelTrait traits)\n{\n  image->channel_map[YPixelChannel].traits=traits;\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\n#endif\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%       TTTTT  H   H  RRRR   EEEEE  SSSSS  H   H   OOO   L      DDDD          %\n%         T    H   H  R   R  E      SS     H   H  O   O  L      D   D         %\n%         T    HHHHH  RRRR   EEE     SSS   HHHHH  O   O  L      D   D         %\n%         T    H   H  R R    E         SS  H   H  O   O  L      D   D         %\n%         T    H   H  R  R   EEEEE  SSSSS  H   H   OOO   LLLLL  DDDD          %\n%                                                                             %\n%                                                                             %\n%                      MagickCore Image Threshold Methods                     %\n%                                                                             %\n%                               Software Design                               %\n%                                    Cristy                                   %\n%                                 October 1996                                %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2015 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/configure.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/decorate.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/effect.h\"\n#include \"MagickCore/fx.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/montage.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/random_.h\"\n#include \"MagickCore/random-private.h\"\n#include \"MagickCore/resize.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/segment.h\"\n#include \"MagickCore/shear.h\"\n#include \"MagickCore/signature-private.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/threshold.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/xml-tree.h\"\n#include \"MagickCore/xml-tree-private.h\"\n\f\n/*\n  Define declarations.\n*/\n#define ThresholdsFilename  \"thresholds.xml\"\n\f\n/*\n  Typedef declarations.\n*/\nstruct _ThresholdMap\n{\n  char\n    *map_id,\n    *description;\n\n  size_t\n    width,\n    height;\n\n  ssize_t\n    divisor,\n    *levels;\n};\n\f\n/*\n  Static declarations.\n*/\nstatic const char\n  *MinimalThresholdMap =\n    \"<?xml version=\\\"1.0\\\"?>\"\n    \"<thresholds>\"\n    \"  <threshold map=\\\"threshold\\\" alias=\\\"1x1\\\">\"\n    \"    <description>Threshold 1x1 (non-dither)</description>\"\n    \"    <levels width=\\\"1\\\" height=\\\"1\\\" divisor=\\\"2\\\">\"\n    \"        1\"\n    \"    </levels>\"\n    \"  </threshold>\"\n    \"  <threshold map=\\\"checks\\\" alias=\\\"2x1\\\">\"\n    \"    <description>Checkerboard 2x1 (dither)</description>\"\n    \"    <levels width=\\\"2\\\" height=\\\"2\\\" divisor=\\\"3\\\">\"\n    \"       1 2\"\n    \"       2 1\"\n    \"    </levels>\"\n    \"  </threshold>\"\n    \"</thresholds>\";\n\f\n/*\n  Forward declarations.\n*/\nstatic ThresholdMap\n  *GetThresholdMapFile(const char *,const char *,const char *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     A d a p t i v e T h r e s h o l d I m a g e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AdaptiveThresholdImage() selects an individual threshold for each pixel\n%  based on the range of intensity values in its local neighborhood.  This\n%  allows for thresholding of an image whose global intensity histogram\n%  doesn't contain distinctive peaks.\n%\n%  The format of the AdaptiveThresholdImage method is:\n%\n%      Image *AdaptiveThresholdImage(const Image *image,const size_t width,\n%        const size_t height,const double bias,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o width: the width of the local neighborhood.\n%\n%    o height: the height of the local neighborhood.\n%\n%    o bias: the mean bias.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *AdaptiveThresholdImage(const Image *image,\n  const size_t width,const size_t height,const double bias,\n  ExceptionInfo *exception)\n{\n#define AdaptiveThresholdImageTag  \"AdaptiveThreshold/Image\"\n\n  CacheView\n    *image_view,\n    *threshold_view;\n\n  Image\n    *threshold_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MagickSizeType\n    number_pixels;\n\n  ssize_t\n    y;\n\n  /*\n    Initialize threshold image attributes.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  threshold_image=CloneImage(image,image->columns,image->rows,MagickTrue,\n    exception);\n  if (threshold_image == (Image *) NULL)\n    return((Image *) NULL);\n  status=SetImageStorageClass(threshold_image,DirectClass,exception);\n  if (status == MagickFalse)\n    {\n      threshold_image=DestroyImage(threshold_image);\n      return((Image *) NULL);\n    }\n  /*\n    Threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  number_pixels=(MagickSizeType) width*height;\n  image_view=AcquireVirtualCacheView(image,exception);\n  threshold_view=AcquireAuthenticCacheView(threshold_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,threshold_image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    double\n      channel_bias[MaxPixelChannels],\n      channel_sum[MaxPixelChannels];\n\n    register const Quantum\n      *restrict p,\n      *restrict pixels;\n\n    register Quantum\n      *restrict q;\n\n    register ssize_t\n      i,\n      x;\n\n    ssize_t\n      center,\n      u,\n      v;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) width/2L),y-(ssize_t)\n      (height/2L),image->columns+width,height,exception);\n    q=QueueCacheViewAuthenticPixels(threshold_view,0,y,threshold_image->columns,\n      1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    center=(ssize_t) GetPixelChannels(image)*(image->columns+width)*(height/2L)+\n      GetPixelChannels(image)*(width/2);\n    for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n    {\n      PixelChannel channel=GetPixelChannelChannel(image,i);\n      PixelTrait traits=GetPixelChannelTraits(image,channel);\n      PixelTrait threshold_traits=GetPixelChannelTraits(threshold_image,\n        channel);\n      if ((traits == UndefinedPixelTrait) ||\n          (threshold_traits == UndefinedPixelTrait))\n        continue;\n      if (((threshold_traits & CopyPixelTrait) != 0) ||\n          (GetPixelReadMask(image,p) == 0))\n        {\n          SetPixelChannel(threshold_image,channel,p[center+i],q);\n          continue;\n        }\n      pixels=p;\n      channel_bias[channel]=0.0;\n      channel_sum[channel]=0.0;\n      for (v=0; v < (ssize_t) height; v++)\n      {\n        for (u=0; u < (ssize_t) width; u++)\n        {\n          if (u == (ssize_t) (width-1))\n            channel_bias[channel]+=pixels[i];\n          channel_sum[channel]+=pixels[i];\n          pixels+=GetPixelChannels(image);\n        }\n        pixels+=GetPixelChannels(image)*image->columns;\n      }\n    }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        double\n          mean;\n\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        PixelTrait threshold_traits=GetPixelChannelTraits(threshold_image,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (threshold_traits == UndefinedPixelTrait))\n          continue;\n        if (((threshold_traits & CopyPixelTrait) != 0) ||\n            (GetPixelReadMask(image,p) == 0))\n          {\n            SetPixelChannel(threshold_image,channel,p[center+i],q);\n            continue;\n          }\n        channel_sum[channel]-=channel_bias[channel];\n        channel_bias[channel]=0.0;\n        pixels=p;\n        for (v=0; v < (ssize_t) height; v++)\n        {\n          channel_bias[channel]+=pixels[i];\n          pixels+=(width-1)*GetPixelChannels(image);\n          channel_sum[channel]+=pixels[i];\n          pixels+=GetPixelChannels(image)*(image->columns+1);\n        }\n        mean=(double) (channel_sum[channel]/number_pixels+bias);\n        SetPixelChannel(threshold_image,channel,(Quantum) ((double)\n          p[center+i] <= mean ? 0 : QuantumRange),q);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(threshold_image);\n    }\n    if (SyncCacheViewAuthenticPixels(threshold_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_AdaptiveThresholdImage)\n#endif\n        proceed=SetImageProgress(image,AdaptiveThresholdImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  threshold_image->type=image->type;\n  threshold_view=DestroyCacheView(threshold_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    threshold_image=DestroyImage(threshold_image);\n  return(threshold_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     B i l e v e l I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  BilevelImage() changes the value of individual pixels based on the\n%  intensity of each pixel channel.  The result is a high-contrast image.\n%\n%  More precisely each channel value of the image is 'thresholded' so that if\n%  it is equal to or less than the given value it is set to zero, while any\n%  value greater than that give is set to it maximum or QuantumRange.\n%\n%  This function is what is used to implement the \"-threshold\" operator for\n%  the command line API.\n%\n%  If the default channel setting is given the image is thresholded using just\n%  the gray 'intensity' of the image, rather than the individual channels.\n%\n%  The format of the BilevelImage method is:\n%\n%      MagickBooleanType BilevelImage(Image *image,const double threshold,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o threshold: define the threshold values.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n%  Aside: You can get the same results as operator using LevelImages()\n%  with the 'threshold' value for both the black_point and the white_point.\n%\n*/\nMagickExport MagickBooleanType BilevelImage(Image *image,const double threshold,\n  ExceptionInfo *exception)\n{\n#define ThresholdImageTag  \"Threshold/Image\"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Bilevel threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        pixel;\n\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      pixel=GetPixelIntensity(image,q);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if (image->channel_mask != DefaultChannels)\n          pixel=(double) q[i];\n        q[i]=(Quantum) (pixel <= threshold ? 0 : QuantumRange);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_BilevelImage)\n#endif\n        proceed=SetImageProgress(image,ThresholdImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     B l a c k T h r e s h o l d I m a g e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  BlackThresholdImage() is like ThresholdImage() but forces all pixels below\n%  the threshold into black while leaving all pixels at or above the threshold\n%  unchanged.\n%\n%  The format of the BlackThresholdImage method is:\n%\n%      MagickBooleanType BlackThresholdImage(Image *image,\n%        const char *threshold,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o threshold: define the threshold value.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType BlackThresholdImage(Image *image,\n  const char *thresholds,ExceptionInfo *exception)\n{\n#define ThresholdImageTag  \"Threshold/Image\"\n\n  CacheView\n    *image_view;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PixelInfo\n    threshold;\n\n  MagickStatusType\n    flags;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (thresholds == (const char *) NULL)\n    return(MagickTrue);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  GetPixelInfo(image,&threshold);\n  flags=ParseGeometry(thresholds,&geometry_info);\n  threshold.red=geometry_info.rho;\n  threshold.green=geometry_info.rho;\n  threshold.blue=geometry_info.rho;\n  threshold.black=geometry_info.rho;\n  threshold.alpha=100.0;\n  if ((flags & SigmaValue) != 0)\n    threshold.green=geometry_info.sigma;\n  if ((flags & XiValue) != 0)\n    threshold.blue=geometry_info.xi;\n  if ((flags & PsiValue) != 0)\n    threshold.alpha=geometry_info.psi;\n  if (threshold.colorspace == CMYKColorspace)\n    {\n      if ((flags & PsiValue) != 0)\n        threshold.black=geometry_info.psi;\n      if ((flags & ChiValue) != 0)\n        threshold.alpha=geometry_info.chi;\n    }\n  if ((flags & PercentValue) != 0)\n    {\n      threshold.red*=(MagickRealType) (QuantumRange/100.0);\n      threshold.green*=(MagickRealType) (QuantumRange/100.0);\n      threshold.blue*=(MagickRealType) (QuantumRange/100.0);\n      threshold.black*=(MagickRealType) (QuantumRange/100.0);\n      threshold.alpha*=(MagickRealType) (QuantumRange/100.0);\n    }\n  /*\n    White threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        pixel;\n\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      pixel=GetPixelIntensity(image,q);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if (image->channel_mask != DefaultChannels)\n          pixel=(double) q[i];\n        if (pixel <= GetPixelInfoChannel(&threshold,channel))\n          q[i]=(Quantum) 0;\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_BlackThresholdImage)\n#endif\n        proceed=SetImageProgress(image,ThresholdImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     C l a m p I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClampImage() set each pixel whose value is below zero to zero and any the\n%  pixel whose value is above the quantum range to the quantum range (e.g.\n%  65535) otherwise the pixel value remains unchanged.\n%\n%  The format of the ClampImage method is:\n%\n%      MagickBooleanType ClampImage(Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nMagickExport MagickBooleanType ClampImage(Image *image,ExceptionInfo *exception)\n{\n#define ClampImageTag  \"Clamp/Image\"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->storage_class == PseudoClass)\n    {\n      register ssize_t\n        i;\n\n      register PixelInfo\n        *restrict q;\n\n      q=image->colormap;\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        q->red=(double) ClampPixel(q->red);\n        q->green=(double) ClampPixel(q->green);\n        q->blue=(double) ClampPixel(q->blue);\n        q->alpha=(double) ClampPixel(q->alpha);\n        q++;\n      }\n      return(SyncImage(image,exception));\n    }\n  /*\n    Clamp image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        q[i]=ClampPixel(q[i]);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_ClampImage)\n#endif\n        proceed=SetImageProgress(image,ClampImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  D e s t r o y T h r e s h o l d M a p                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyThresholdMap() de-allocate the given ThresholdMap\n%\n%  The format of the ListThresholdMaps method is:\n%\n%      ThresholdMap *DestroyThresholdMap(Threshold *map)\n%\n%  A description of each parameter follows.\n%\n%    o map:    Pointer to the Threshold map to destroy\n%\n*/\nMagickExport ThresholdMap *DestroyThresholdMap(ThresholdMap *map)\n{\n  assert(map != (ThresholdMap *) NULL);\n  if (map->map_id != (char *) NULL)\n    map->map_id=DestroyString(map->map_id);\n  if (map->description != (char *) NULL)\n    map->description=DestroyString(map->description);\n  if (map->levels != (ssize_t *) NULL)\n    map->levels=(ssize_t *) RelinquishMagickMemory(map->levels);\n  map=(ThresholdMap *) RelinquishMagickMemory(map);\n  return(map);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  G e t T h r e s h o l d M a p                                              %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetThresholdMap() loads and searches one or more threshold map files for the\n%  map matching the given name or alias.\n%\n%  The format of the GetThresholdMap method is:\n%\n%      ThresholdMap *GetThresholdMap(const char *map_id,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o map_id:  ID of the map to look for.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport ThresholdMap *GetThresholdMap(const char *map_id,\n  ExceptionInfo *exception)\n{\n  const StringInfo\n    *option;\n\n  LinkedListInfo\n    *options;\n\n  ThresholdMap\n    *map;\n\n  map=GetThresholdMapFile(MinimalThresholdMap,\"built-in\",map_id,exception);\n  if (map != (ThresholdMap *) NULL)\n    return(map);\n  options=GetConfigureOptions(ThresholdsFilename,exception);\n  option=(const StringInfo *) GetNextValueInLinkedList(options);\n  while (option != (const StringInfo *) NULL)\n  {\n    map=GetThresholdMapFile((const char *) GetStringInfoDatum(option),\n      GetStringInfoPath(option),map_id,exception);\n    if (map != (ThresholdMap *) NULL)\n      break;\n    option=(const StringInfo *) GetNextValueInLinkedList(options);\n  }\n  options=DestroyConfigureOptions(options);\n  return(map);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  G e t T h r e s h o l d M a p F i l e                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetThresholdMapFile() look for a given threshold map name or alias in the\n%  given XML file data, and return the allocated the map when found.\n%\n%  The format of the ListThresholdMaps method is:\n%\n%      ThresholdMap *GetThresholdMap(const char *xml,const char *filename,\n%         const char *map_id,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o xml:  The threshold map list in XML format.\n%\n%    o filename:  The threshold map XML filename.\n%\n%    o map_id:  ID of the map to look for in XML list.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic ThresholdMap *GetThresholdMapFile(const char *xml,const char *filename,\n  const char *map_id,ExceptionInfo *exception)\n{\n  char\n    *p;\n\n  const char\n    *attribute,\n    *content;\n\n  double\n    value;\n\n  register ssize_t\n    i;\n\n  ThresholdMap\n    *map;\n\n  XMLTreeInfo\n    *description,\n    *levels,\n    *threshold,\n    *thresholds;\n\n  (void) LogMagickEvent(ConfigureEvent,GetMagickModule(),\n    \"Loading threshold map file \\\"%s\\\" ...\",filename);\n  map=(ThresholdMap *) NULL;\n  thresholds=NewXMLTree(xml,exception);\n  if (thresholds == (XMLTreeInfo *) NULL)\n    return(map);\n  for (threshold=GetXMLTreeChild(thresholds,\"threshold\");\n       threshold != (XMLTreeInfo *) NULL;\n       threshold=GetNextXMLTreeTag(threshold))\n  {\n    attribute=GetXMLTreeAttribute(threshold,\"map\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(map_id,attribute) == 0))\n      break;\n    attribute=GetXMLTreeAttribute(threshold,\"alias\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(map_id,attribute) == 0))\n      break;\n  }\n  if (threshold == (XMLTreeInfo *) NULL)\n    {\n      thresholds=DestroyXMLTree(thresholds);\n      return(map);\n    }\n  description=GetXMLTreeChild(threshold,\"description\");\n  if (description == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\", \"<description>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      return(map);\n    }\n  levels=GetXMLTreeChild(threshold,\"levels\");\n  if (levels == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\", \"<levels>, map \\\"%s\\\"\", map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      return(map);\n    }\n  map=(ThresholdMap *) AcquireMagickMemory(sizeof(ThresholdMap));\n  if (map == (ThresholdMap *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToAcquireThresholdMap\");\n  map->map_id=(char *) NULL;\n  map->description=(char *) NULL;\n  map->levels=(ssize_t *) NULL;\n  attribute=GetXMLTreeAttribute(threshold,\"map\");\n  if (attribute != (char *) NULL)\n    map->map_id=ConstantString(attribute);\n  content=GetXMLTreeContent(description);\n  if (content != (char *) NULL)\n    map->description=ConstantString(content);\n  attribute=GetXMLTreeAttribute(levels,\"width\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\", \"<levels width>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  map->width=StringToUnsignedLong(attribute);\n  if (map->width == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n       \"XmlInvalidAttribute\", \"<levels width>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"height\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\", \"<levels height>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  map->height=StringToUnsignedLong(attribute);\n  if (map->height == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\", \"<levels height>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"divisor\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\", \"<levels divisor>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  map->divisor=(ssize_t) StringToLong(attribute);\n  if (map->divisor < 2)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\", \"<levels divisor>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  content=GetXMLTreeContent(levels);\n  if (content == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingContent\", \"<levels>, map \\\"%s\\\"\",map_id);\n      thresholds=DestroyXMLTree(thresholds);\n      map=DestroyThresholdMap(map);\n      return(map);\n    }\n  map->levels=(ssize_t *) AcquireQuantumMemory((size_t) map->width,map->height*\n    sizeof(*map->levels));\n  if (map->levels == (ssize_t *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToAcquireThresholdMap\");\n  for (i=0; i < (ssize_t) (map->width*map->height); i++)\n  {\n    map->levels[i]=(ssize_t) strtol(content,&p,10);\n    if (p == content)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"XmlInvalidContent\", \"<level> too few values, map \\\"%s\\\"\",map_id);\n        thresholds=DestroyXMLTree(thresholds);\n        map=DestroyThresholdMap(map);\n        return(map);\n      }\n    if ((map->levels[i] < 0) || (map->levels[i] > map->divisor))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"XmlInvalidContent\", \"<level> %.20g out of range, map \\\"%s\\\"\",\n          (double) map->levels[i],map_id);\n        thresholds=DestroyXMLTree(thresholds);\n        map=DestroyThresholdMap(map);\n        return(map);\n      }\n    content=p;\n  }\n  value=(double) strtol(content,&p,10);\n  (void) value;\n  if (p != content)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidContent\", \"<level> too many values, map \\\"%s\\\"\",map_id);\n     thresholds=DestroyXMLTree(thresholds);\n     map=DestroyThresholdMap(map);\n     return(map);\n   }\n  thresholds=DestroyXMLTree(thresholds);\n  return(map);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  L i s t T h r e s h o l d M a p F i l e                                    %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ListThresholdMapFile() lists the threshold maps and their descriptions\n%  in the given XML file data.\n%\n%  The format of the ListThresholdMaps method is:\n%\n%      MagickBooleanType ListThresholdMaps(FILE *file,const char*xml,\n%         const char *filename,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o file:  An pointer to the output FILE.\n%\n%    o xml:  The threshold map list in XML format.\n%\n%    o filename:  The threshold map XML filename.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickBooleanType ListThresholdMapFile(FILE *file,const char *xml,\n  const char *filename,ExceptionInfo *exception)\n{\n  const char\n    *alias,\n    *content,\n    *map;\n\n  XMLTreeInfo\n    *description,\n    *threshold,\n    *thresholds;\n\n  assert( xml != (char *) NULL );\n  assert( file != (FILE *) NULL );\n  (void) LogMagickEvent(ConfigureEvent,GetMagickModule(),\n    \"Loading threshold map file \\\"%s\\\" ...\",filename);\n  thresholds=NewXMLTree(xml,exception);\n  if ( thresholds == (XMLTreeInfo *) NULL )\n    return(MagickFalse);\n  (void) FormatLocaleFile(file,\"%-16s %-12s %s\\n\",\"Map\",\"Alias\",\"Description\");\n  (void) FormatLocaleFile(file,\n    \"----------------------------------------------------\\n\");\n  threshold=GetXMLTreeChild(thresholds,\"threshold\");\n  for ( ; threshold != (XMLTreeInfo *) NULL;\n          threshold=GetNextXMLTreeTag(threshold))\n  {\n    map=GetXMLTreeAttribute(threshold,\"map\");\n    if (map == (char *) NULL)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"XmlMissingAttribute\", \"<map>\");\n        thresholds=DestroyXMLTree(thresholds);\n        return(MagickFalse);\n      }\n    alias=GetXMLTreeAttribute(threshold,\"alias\");\n    description=GetXMLTreeChild(threshold,\"description\");\n    if (description == (XMLTreeInfo *) NULL)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"XmlMissingElement\", \"<description>, map \\\"%s\\\"\",map);\n        thresholds=DestroyXMLTree(thresholds);\n        return(MagickFalse);\n      }\n    content=GetXMLTreeContent(description);\n    if (content == (char *) NULL)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"XmlMissingContent\", \"<description>, map \\\"%s\\\"\", map);\n        thresholds=DestroyXMLTree(thresholds);\n        return(MagickFalse);\n      }\n    (void) FormatLocaleFile(file,\"%-16s %-12s %s\\n\",map,alias ? alias : \"\",\n      content);\n  }\n  thresholds=DestroyXMLTree(thresholds);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  L i s t T h r e s h o l d M a p s                                          %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ListThresholdMaps() lists the threshold maps and their descriptions\n%  as defined by \"threshold.xml\" to a file.\n%\n%  The format of the ListThresholdMaps method is:\n%\n%      MagickBooleanType ListThresholdMaps(FILE *file,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o file:  An pointer to the output FILE.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType ListThresholdMaps(FILE *file,\n  ExceptionInfo *exception)\n{\n  const StringInfo\n    *option;\n\n  LinkedListInfo\n    *options;\n\n  MagickStatusType\n    status;\n\n  status=MagickTrue;\n  if (file == (FILE *) NULL)\n    file=stdout;\n  options=GetConfigureOptions(ThresholdsFilename,exception);\n  (void) FormatLocaleFile(file,\n    \"\\n   Threshold Maps for Ordered Dither Operations\\n\");\n  option=(const StringInfo *) GetNextValueInLinkedList(options);\n  while (option != (const StringInfo *) NULL)\n  {\n    (void) FormatLocaleFile(file,\"\\nPath: %s\\n\\n\",GetStringInfoPath(option));\n    status&=ListThresholdMapFile(file,(const char *) GetStringInfoDatum(option),\n      GetStringInfoPath(option),exception);\n    option=(const StringInfo *) GetNextValueInLinkedList(options);\n  }\n  options=DestroyConfigureOptions(options);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     O r d e r e d P o s t e r i z e I m a g e                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  OrderedPosterizeImage() will perform a ordered dither based on a number\n%  of pre-defined dithering threshold maps, but over multiple intensity\n%  levels, which can be different for different channels, according to the\n%  input argument.\n%\n%  The format of the OrderedPosterizeImage method is:\n%\n%      MagickBooleanType OrderedPosterizeImage(Image *image,\n%        const char *threshold_map,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o threshold_map: A string containing the name of the threshold dither\n%      map to use, followed by zero or more numbers representing the number\n%      of color levels tho dither between.\n%\n%      Any level number less than 2 will be equivalent to 2, and means only\n%      binary dithering will be applied to each color channel.\n%\n%      No numbers also means a 2 level (bitmap) dither will be applied to all\n%      channels, while a single number is the number of levels applied to each\n%      channel in sequence.  More numbers will be applied in turn to each of\n%      the color channels.\n%\n%      For example: \"o3x3,6\" will generate a 6 level posterization of the\n%      image with a ordered 3x3 diffused pixel dither being applied between\n%      each level. While checker,8,8,4 will produce a 332 colormaped image\n%      with only a single checkerboard hash pattern (50% grey) between each\n%      color level, to basically double the number of color levels with\n%      a bare minimim of dithering.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType OrderedPosterizeImage(Image *image,\n  const char *threshold_map,ExceptionInfo *exception)\n{\n#define DitherImageTag  \"Dither/Image\"\n\n  CacheView\n    *image_view;\n\n  char\n    token[MaxTextExtent];\n\n  const char\n    *p;\n\n  double\n    levels[CompositePixelChannel];\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  ThresholdMap\n    *map;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  if (threshold_map == (const char *) NULL)\n    return(MagickTrue);\n  p=(char *) threshold_map;\n  while (((isspace((int) ((unsigned char) *p)) != 0) || (*p == ',')) &&\n         (*p != '\\0'))\n    p++;\n  threshold_map=p;\n  while (((isspace((int) ((unsigned char) *p)) == 0) && (*p != ',')) &&\n         (*p != '\\0'))\n  {\n    if ((p-threshold_map) >= (MaxTextExtent-1))\n      break;\n    token[p-threshold_map]=(*p);\n    p++;\n  }\n  token[p-threshold_map]='\\0';\n  map=GetThresholdMap(token,exception);\n  if (map == (ThresholdMap *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"InvalidArgument\",\"%s : '%s'\",\"ordered-dither\",threshold_map);\n      return(MagickFalse);\n    }\n  for (i=0; i < MaxPixelChannels; i++)\n    levels[i]=2.0;\n  p=strchr((char *) threshold_map,',');\n  if ((p != (char *) NULL) && (isdigit((int) ((unsigned char) *(++p))) != 0))\n    for (i=0; (*p != '\\0') && (i < MaxPixelChannels); i++)\n    {\n      GetMagickToken(p,&p,token);\n      if (*token == ',')\n        GetMagickToken(p,&p,token);\n      levels[i]=StringToDouble(token,(char **) NULL);\n    }\n  for (i=0; i < MaxPixelChannels; i++)\n    if (fabs(levels[i]) >= 1)\n      levels[i]-=1.0;\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      ssize_t\n        n;\n\n      n=0;\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        ssize_t\n          level,\n          threshold;\n\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if (fabs(levels[n++]) < MagickEpsilon)\n          continue;\n        threshold=(ssize_t) (QuantumScale*q[i]*(levels[n]*(map->divisor-1)+1));\n        level=threshold/(map->divisor-1);\n        threshold-=level*(map->divisor-1);\n        q[i]=ClampToQuantum((double) (level+(threshold >=\n          map->levels[(x % map->width)+map->width*(y % map->height)]))*\n          QuantumRange/levels[n]);\n        n++;\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_OrderedPosterizeImage)\n#endif\n        proceed=SetImageProgress(image,DitherImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  map=DestroyThresholdMap(map);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     P e r c e p t i b l e I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PerceptibleImage() set each pixel whose value is less than |epsilon| to\n%  epsilon or -epsilon (whichever is closer) otherwise the pixel value remains\n%  unchanged.\n%\n%  The format of the PerceptibleImage method is:\n%\n%      MagickBooleanType PerceptibleImage(Image *image,const double epsilon,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o epsilon: the epsilon threshold (e.g. 1.0e-9).\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline Quantum PerceptibleThreshold(const Quantum quantum,\n  const double epsilon)\n{\n  double\n    sign;\n\n  sign=(double) quantum < 0.0 ? -1.0 : 1.0;\n  if ((sign*quantum) >= epsilon)\n    return(quantum);\n  return((Quantum) (sign*epsilon));\n}\n\nMagickExport MagickBooleanType PerceptibleImage(Image *image,\n  const double epsilon,ExceptionInfo *exception)\n{\n#define PerceptibleImageTag  \"Perceptible/Image\"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->storage_class == PseudoClass)\n    {\n      register ssize_t\n        i;\n\n      register PixelInfo\n        *restrict q;\n\n      q=image->colormap;\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        q->red=(double) PerceptibleThreshold(ClampToQuantum(q->red),\n          epsilon);\n        q->green=(double) PerceptibleThreshold(ClampToQuantum(q->green),\n          epsilon);\n        q->blue=(double) PerceptibleThreshold(ClampToQuantum(q->blue),\n          epsilon);\n        q->alpha=(double) PerceptibleThreshold(ClampToQuantum(q->alpha),\n          epsilon);\n        q++;\n      }\n      return(SyncImage(image,exception));\n    }\n  /*\n    Perceptible image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if (traits == UndefinedPixelTrait)\n          continue;\n        q[i]=PerceptibleThreshold(q[i],epsilon);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_PerceptibleImage)\n#endif\n        proceed=SetImageProgress(image,PerceptibleImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     R a n d o m T h r e s h o l d I m a g e                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RandomThresholdImage() changes the value of individual pixels based on the\n%  intensity of each pixel compared to a random threshold.  The result is a\n%  low-contrast, two color image.\n%\n%  The format of the RandomThresholdImage method is:\n%\n%      MagickBooleanType RandomThresholdImage(Image *image,\n%        const char *thresholds,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o thresholds: a geometry string containing low,high thresholds.  If the\n%      string contains 2x2, 3x3, or 4x4, an ordered dither of order 2, 3, or 4\n%      is performed instead.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType RandomThresholdImage(Image *image,\n  const char *thresholds,ExceptionInfo *exception)\n{\n#define ThresholdImageTag  \"Threshold/Image\"\n\n  CacheView\n    *image_view;\n\n  double\n    min_threshold,\n    max_threshold;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickStatusType\n    flags;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PixelInfo\n    threshold;\n\n  RandomInfo\n    **restrict random_info;\n\n  ssize_t\n    y;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  unsigned long\n    key;\n#endif\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  if (thresholds == (const char *) NULL)\n    return(MagickTrue);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  GetPixelInfo(image,&threshold);\n  min_threshold=0.0;\n  max_threshold=(double) QuantumRange;\n  flags=ParseGeometry(thresholds,&geometry_info);\n  min_threshold=geometry_info.rho;\n  max_threshold=geometry_info.sigma;\n  if ((flags & SigmaValue) == 0)\n    max_threshold=min_threshold;\n  if (strchr(thresholds,'%') != (char *) NULL)\n    {\n      max_threshold*=(double) (0.01*QuantumRange);\n      min_threshold*=(double) (0.01*QuantumRange);\n    }\n  /*\n    Random threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  random_info=AcquireRandomInfoThreadSet();\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  key=GetRandomSecretKey(random_info[0]);\n#endif\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,key == ~0UL)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    register Quantum\n      *restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        double\n          threshold;\n\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if ((double) q[i] < min_threshold)\n          threshold=min_threshold;\n        else\n          if ((double) q[i] > max_threshold)\n            threshold=max_threshold;\n          else\n            threshold=(double) (QuantumRange*\n              GetPseudoRandomValue(random_info[id]));\n        q[i]=(double) q[i] <= threshold ? 0 : QuantumRange;\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_RandomThresholdImage)\n#endif\n        proceed=SetImageProgress(image,ThresholdImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  random_info=DestroyRandomInfoThreadSet(random_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     W h i t e T h r e s h o l d I m a g e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WhiteThresholdImage() is like ThresholdImage() but forces all pixels above\n%  the threshold into white while leaving all pixels at or below the threshold\n%  unchanged.\n%\n%  The format of the WhiteThresholdImage method is:\n%\n%      MagickBooleanType WhiteThresholdImage(Image *image,\n%        const char *threshold,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o threshold: Define the threshold value.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType WhiteThresholdImage(Image *image,\n  const char *thresholds,ExceptionInfo *exception)\n{\n#define ThresholdImageTag  \"Threshold/Image\"\n\n  CacheView\n    *image_view;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  PixelInfo\n    threshold;\n\n  MagickStatusType\n    flags;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (thresholds == (const char *) NULL)\n    return(MagickTrue);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    return(MagickFalse);\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  GetPixelInfo(image,&threshold);\n  flags=ParseGeometry(thresholds,&geometry_info);\n  threshold.red=geometry_info.rho;\n  threshold.green=geometry_info.rho;\n  threshold.blue=geometry_info.rho;\n  threshold.black=geometry_info.rho;\n  threshold.alpha=100.0;\n  if ((flags & SigmaValue) != 0)\n    threshold.green=geometry_info.sigma;\n  if ((flags & XiValue) != 0)\n    threshold.blue=geometry_info.xi;\n  if ((flags & PsiValue) != 0)\n    threshold.alpha=geometry_info.psi;\n  if (threshold.colorspace == CMYKColorspace)\n    {\n      if ((flags & PsiValue) != 0)\n        threshold.black=geometry_info.psi;\n      if ((flags & ChiValue) != 0)\n        threshold.alpha=geometry_info.chi;\n    }\n  if ((flags & PercentValue) != 0)\n    {\n      threshold.red*=(MagickRealType) (QuantumRange/100.0);\n      threshold.green*=(MagickRealType) (QuantumRange/100.0);\n      threshold.blue*=(MagickRealType) (QuantumRange/100.0);\n      threshold.black*=(MagickRealType) (QuantumRange/100.0);\n      threshold.alpha*=(MagickRealType) (QuantumRange/100.0);\n    }\n  /*\n    White threshold image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        pixel;\n\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      pixel=GetPixelIntensity(image,q);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        if (image->channel_mask != DefaultChannels)\n          pixel=(double) q[i];\n        if (pixel > GetPixelInfoChannel(&threshold,channel))\n          q[i]=QuantumRange;\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_WhiteThresholdImage)\n#endif\n        proceed=SetImageProgress(image,ThresholdImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            SSSSS  U   U  N   N                              %\n%                            SS     U   U  NN  N                              %\n%                             SSS   U   U  N N N                              %\n%                               SS  U   U  N  NN                              %\n%                            SSSSS   UUU   N   N                              %\n%                                                                             %\n%                                                                             %\n%                    Read/Write Sun Rasterfile Image Format                   %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2015 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteSUNImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s S U N                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsSUN() returns MagickTrue if the image format type, identified by the\n%  magick string, is SUN.\n%\n%  The format of the IsSUN method is:\n%\n%      MagickBooleanType IsSUN(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsSUN(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\131\\246\\152\\225\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DecodeImage unpacks the packed image pixels into  runlength-encoded pixel\n%  packets.\n%\n%  The format of the DecodeImage method is:\n%\n%      MagickBooleanType DecodeImage(const unsigned char *compressed_pixels,\n%        const size_t length,unsigned char *pixels)\n%\n%  A description of each parameter follows:\n%\n%    o compressed_pixels:  The address of a byte (8 bits) array of compressed\n%      pixel data.\n%\n%    o length:  An integer value that is the total number of bytes of the\n%      source image (as just read by ReadBlob)\n%\n%    o pixels:  The address of a byte (8 bits) array of pixel data created by\n%      the uncompression process.  The number of bytes in this array\n%      must be at least equal to the number columns times the number of rows\n%      of the source pixels.\n%\n*/\nstatic MagickBooleanType DecodeImage(const unsigned char *compressed_pixels,\n  const size_t length,unsigned char *pixels,size_t maxpixels)\n{\n  register const unsigned char\n    *l,\n    *p;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    count;\n\n  unsigned char\n    byte;\n\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(compressed_pixels != (unsigned char *) NULL);\n  assert(pixels != (unsigned char *) NULL);\n  p=compressed_pixels;\n  q=pixels;\n  l=q+maxpixels;\n  while (((size_t) (p-compressed_pixels) < length) && (q < l))\n  {\n    byte=(*p++);\n    if (byte != 128U)\n      *q++=byte;\n    else\n      {\n        /*\n          Runlength-encoded packet: <count><byte>\n        */\n        count=(ssize_t) (*p++);\n        if (count > 0)\n          byte=(*p++);\n        while ((count >= 0) && (q < l))\n        {\n          *q++=byte;\n          count--;\n        }\n     }\n  }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d S U N I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadSUNImage() reads a SUN image file and returns it.  It allocates\n%  the memory necessary for the new Image structure and returns a pointer to\n%  the new image.\n%\n%  The format of the ReadSUNImage method is:\n%\n%      Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define RMT_EQUAL_RGB  1\n#define RMT_NONE  0\n#define RMT_RAW  2\n#define RT_STANDARD  1\n#define RT_ENCODED  2\n#define RT_FORMAT_RGB  3\n\n  typedef struct _SUNInfo\n  {\n    unsigned int\n      magic,\n      width,\n      height,\n      depth,\n      length,\n      type,\n      maptype,\n      maplength;\n  } SUNInfo;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_line,\n    extent,\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  SUNInfo\n    sun_info;\n\n  unsigned char\n    *sun_data,\n    *sun_pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SUN raster header.\n  */\n  (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));\n  sun_info.magic=ReadBlobMSBLong(image);\n  do\n  {\n    /*\n      Verify SUN identifier.\n    */\n    if (sun_info.magic != 0x59a66a95)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    sun_info.width=ReadBlobMSBLong(image);\n    sun_info.height=ReadBlobMSBLong(image);\n    sun_info.depth=ReadBlobMSBLong(image);\n    sun_info.length=ReadBlobMSBLong(image);\n    sun_info.type=ReadBlobMSBLong(image);\n    sun_info.maptype=ReadBlobMSBLong(image);\n    sun_info.maplength=ReadBlobMSBLong(image);\n    extent=sun_info.height*sun_info.width;\n    if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&\n        (sun_info.type != RT_FORMAT_RGB))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.depth == 0) || (sun_info.depth > 32))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&\n        (sun_info.maptype != RMT_RAW))\n      ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    image->depth=sun_info.depth <= 8 ? sun_info.depth :\n      MAGICKCORE_QUANTUM_DEPTH;\n    if (sun_info.depth < 24)\n      {\n        size_t\n          one;\n\n        image->colors=sun_info.maplength;\n        one=1;\n        if (sun_info.maptype == RMT_NONE)\n          image->colors=one << sun_info.depth;\n        if (sun_info.maptype == RMT_EQUAL_RGB)\n          image->colors=sun_info.maplength/3;\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    switch (sun_info.maptype)\n    {\n      case RMT_NONE:\n        break;\n      case RMT_EQUAL_RGB:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      case RMT_RAW:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,sun_info.maplength,sun_colormap);\n        if (count != (ssize_t) sun_info.maplength)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    if ((sun_info.length*sizeof(*sun_data))/sizeof(*sun_data) !=\n        sun_info.length || !sun_info.length)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((sun_info.type != RT_ENCODED) && (sun_info.depth >= 8) &&\n        ((number_pixels*((sun_info.depth+7)/8)) > sun_info.length))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    bytes_per_line=sun_info.width*sun_info.depth;\n    sun_data=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(\n      sun_info.length,bytes_per_line*sun_info.width),sizeof(*sun_data));\n    if (sun_data == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);\n    if (count != (ssize_t) sun_info.length)\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    sun_pixels=sun_data;\n    bytes_per_line=0;\n    if (sun_info.type == RT_ENCODED)\n      {\n        size_t\n          height;\n\n        /*\n          Read run-length encoded raster pixels.\n        */\n        height=sun_info.height;\n        if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||\n            ((bytes_per_line/sun_info.depth) != sun_info.width))\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        bytes_per_line+=15;\n        bytes_per_line<<=1;\n        if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15))\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        bytes_per_line>>=4;\n        sun_pixels=(unsigned char *) AcquireQuantumMemory(height,\n          bytes_per_line*sizeof(*sun_pixels));\n        if (sun_pixels == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line*\n          height);\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n      }\n    /*\n      Convert SUN raster image to pixel packets.\n    */\n    p=sun_pixels;\n    if (sun_info.depth == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=7; bit >= 0; bit--)\n          {\n            SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),\n              q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)\n            {\n              SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 :\n                0x01),q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n        if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)\n          p++;\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        {\n          if (bytes_per_line == 0)\n            bytes_per_line=image->columns;\n          length=image->rows*(image->columns+image->columns % 2);\n          if (((sun_info.type == RT_ENCODED) &&\n               (length > (bytes_per_line*image->rows))) ||\n              ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,*p++,q);\n              q+=GetPixelChannels(image);\n            }\n            if ((image->columns % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        {\n          size_t\n            bytes_per_pixel;\n\n          bytes_per_pixel=3;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            bytes_per_pixel++;\n          if (bytes_per_line == 0)\n            bytes_per_line=bytes_per_pixel*image->columns;\n          length=image->rows*(bytes_per_line+image->columns % 2);\n          if (((sun_info.type == RT_ENCODED) &&\n               (length > (bytes_per_line*image->rows))) ||\n              ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))\n            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (image->alpha_trait != UndefinedPixelTrait)\n                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n              if (sun_info.type == RT_STANDARD)\n                {\n                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                }\n              else\n                {\n                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                }\n              if (image->colors != 0)\n                {\n                  SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelRed(image,q)].red),q);\n                  SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelGreen(image,q)].green),q);\n                  SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelBlue(image,q)].blue),q);\n                }\n              q+=GetPixelChannels(image);\n            }\n            if (((bytes_per_pixel*image->columns) % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    sun_info.magic=ReadBlobMSBLong(image);\n    if (sun_info.magic == 0x59a66a95)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (sun_info.magic == 0x59a66a95);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r S U N I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterSUNImage() adds attributes for the SUN image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterSUNImage method is:\n%\n%      size_t RegisterSUNImage(void)\n%\n*/\nModuleExport size_t RegisterSUNImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"RAS\");\n  entry->decoder=(DecodeImageHandler *) ReadSUNImage;\n  entry->encoder=(EncodeImageHandler *) WriteSUNImage;\n  entry->magick=(IsImageFormatHandler *) IsSUN;\n  entry->description=ConstantString(\"SUN Rasterfile\");\n  entry->module=ConstantString(\"SUN\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"SUN\");\n  entry->decoder=(DecodeImageHandler *) ReadSUNImage;\n  entry->encoder=(EncodeImageHandler *) WriteSUNImage;\n  entry->description=ConstantString(\"SUN Rasterfile\");\n  entry->module=ConstantString(\"SUN\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r S U N I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterSUNImage() removes format registrations made by the\n%  SUN module from the list of supported formats.\n%\n%  The format of the UnregisterSUNImage method is:\n%\n%      UnregisterSUNImage(void)\n%\n*/\nModuleExport void UnregisterSUNImage(void)\n{\n  (void) UnregisterMagickInfo(\"RAS\");\n  (void) UnregisterMagickInfo(\"SUN\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e S U N I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteSUNImage() writes an image in the SUN rasterfile format.\n%\n%  The format of the WriteSUNImage method is:\n%\n%      MagickBooleanType WriteSUNImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteSUNImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n#define RMT_EQUAL_RGB  1\n#define RMT_NONE  0\n#define RMT_RAW  2\n#define RT_STANDARD  1\n#define RT_FORMAT_RGB  3\n\n  typedef struct _SUNInfo\n  {\n    unsigned int\n      magic,\n      width,\n      height,\n      depth,\n      length,\n      type,\n      maptype,\n      maplength;\n  } SUNInfo;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MagickSizeType\n    number_pixels;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  SUNInfo\n    sun_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  do\n  {\n    /*\n      Initialize SUN raster file header.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    sun_info.magic=0x59a66a95;\n    if ((image->columns != (unsigned int) image->columns) ||\n        (image->rows != (unsigned int) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    sun_info.width=(unsigned int) image->columns;\n    sun_info.height=(unsigned int) image->rows;\n    sun_info.type=(unsigned int)\n      (image->storage_class == DirectClass ? RT_FORMAT_RGB : RT_STANDARD);\n    sun_info.maptype=RMT_NONE;\n    sun_info.maplength=0;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((4*number_pixels) != (size_t) (4*number_pixels))\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color SUN raster.\n        */\n        sun_info.depth=(unsigned int) image->alpha_trait != UndefinedPixelTrait ?\n          32U : 24U;\n        sun_info.length=(unsigned int) ((image->alpha_trait != UndefinedPixelTrait ?\n          4 : 3)*number_pixels);\n        sun_info.length+=sun_info.length & 0x01 ? (unsigned int) image->rows :\n          0;\n      }\n    else\n      if (IsImageMonochrome(image,exception) != MagickFalse)\n        {\n          /*\n            Monochrome SUN raster.\n          */\n          sun_info.depth=1;\n          sun_info.length=(unsigned int) (((image->columns+7) >> 3)*\n            image->rows);\n          sun_info.length+=(unsigned int) (((image->columns/8)+(image->columns %\n            8 ? 1 : 0)) % 2 ? image->rows : 0);\n        }\n      else\n        {\n          /*\n            Colormapped SUN raster.\n          */\n          sun_info.depth=8;\n          sun_info.length=(unsigned int) number_pixels;\n          sun_info.length+=(unsigned int) (image->columns & 0x01 ? image->rows :\n            0);\n          sun_info.maptype=RMT_EQUAL_RGB;\n          sun_info.maplength=(unsigned int) (3*image->colors);\n        }\n    /*\n      Write SUN header.\n    */\n    (void) WriteBlobMSBLong(image,sun_info.magic);\n    (void) WriteBlobMSBLong(image,sun_info.width);\n    (void) WriteBlobMSBLong(image,sun_info.height);\n    (void) WriteBlobMSBLong(image,sun_info.depth);\n    (void) WriteBlobMSBLong(image,sun_info.length);\n    (void) WriteBlobMSBLong(image,sun_info.type);\n    (void) WriteBlobMSBLong(image,sun_info.maptype);\n    (void) WriteBlobMSBLong(image,sun_info.maplength);\n    /*\n      Convert MIFF to SUN raster pixels.\n    */\n    x=0;\n    y=0;\n    if (image->storage_class == DirectClass)\n      {\n        register unsigned char\n          *q;\n\n        size_t\n          bytes_per_pixel,\n          length;\n\n        unsigned char\n          *pixels;\n\n        /*\n          Allocate memory for pixels.\n        */\n        bytes_per_pixel=3;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          bytes_per_pixel++;\n        length=image->columns;\n        pixels=(unsigned char *) AcquireQuantumMemory(length,4*sizeof(*pixels));\n        if (pixels == (unsigned char *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Convert DirectClass packet to SUN RGB pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            p+=GetPixelChannels(image);\n          }\n          if (((bytes_per_pixel*image->columns) & 0x01) != 0)\n            *q++='\\0';  /* pad scanline */\n          (void) WriteBlob(image,(size_t) (q-pixels),pixels);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      }\n    else\n      if (IsImageMonochrome(image,exception) != MagickFalse)\n        {\n          register unsigned char\n            bit,\n            byte;\n\n          /*\n            Convert PseudoClass image to a SUN monochrome image.\n          */\n          (void) SetImageType(image,BilevelType,exception);\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            bit=0;\n            byte=0;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              byte<<=1;\n              if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n                byte|=0x01;\n              bit++;\n              if (bit == 8)\n                {\n                  (void) WriteBlobByte(image,byte);\n                  bit=0;\n                  byte=0;\n                }\n              p+=GetPixelChannels(image);\n            }\n            if (bit != 0)\n              (void) WriteBlobByte(image,(unsigned char) (byte << (8-bit)));\n            if ((((image->columns/8)+\n                (image->columns % 8 ? 1 : 0)) % 2) != 0)\n              (void) WriteBlobByte(image,0);  /* pad scanline */\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        {\n          /*\n            Dump colormap to file.\n          */\n          for (i=0; i < (ssize_t) image->colors; i++)\n            (void) WriteBlobByte(image,ScaleQuantumToChar(\n              ClampToQuantum(image->colormap[i].red)));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            (void) WriteBlobByte(image,ScaleQuantumToChar(\n              ClampToQuantum(image->colormap[i].green)));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            (void) WriteBlobByte(image,ScaleQuantumToChar(\n              ClampToQuantum(image->colormap[i].blue)));\n          /*\n            Convert PseudoClass packet to SUN colormapped pixel.\n          */\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              (void) WriteBlobByte(image,(unsigned char)\n                GetPixelIndex(image,p));\n              p+=GetPixelChannels(image);\n            }\n            if (image->columns & 0x01)\n              (void) WriteBlobByte(image,0);  /* pad scanline */\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["MagickCore/composite.c", "MagickCore/pixel-accessor.h", "MagickCore/threshold.c", "coders/sun.c"], "buggy_code_start_loc": [2310, 32, 697, 344], "buggy_code_end_loc": [2311, 32, 710, 344], "fixing_code_start_loc": [2310, 33, 696, 345], "fixing_code_end_loc": [2311, 46, 696, 347], "type": "CWE-119", "message": "Buffer overflow in ImageMagick before 6.9.0-4 Beta allows remote attackers to cause a denial of service (application crash) via a crafted SUN file.", "other": {"cve": {"id": "CVE-2015-8957", "sourceIdentifier": "security@debian.org", "published": "2017-04-20T18:59:00.157", "lastModified": "2017-05-09T12:40:21.167", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Buffer overflow in ImageMagick before 6.9.0-4 Beta allows remote attackers to cause a denial of service (application crash) via a crafted SUN file."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer en ImageMagick en versiones anteriores a 6.9.0-4 Beta permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda de la aplicaci\u00f3n) a trav\u00e9s de un archivo SUN manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.9.0-3", "matchCriteriaId": "2A650014-7267-4057-BABC-4F7E33586702"}]}]}], "references": [{"url": "http://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=26838", "source": "security@debian.org", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/09/22/2", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93125", "source": "security@debian.org", "tags": ["VDB Entry", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1378735", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/450bd716ed3b9186dd10f9e60f630a3d9eeea2a4", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/78f82d9d1c2944725a279acd573a22168dc6e22a", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/bd96074b254c6607a0f7731e59f923ad19d5a46d", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/450bd716ed3b9186dd10f9e60f630a3d9eeea2a4"}}