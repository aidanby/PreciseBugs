{"buggy_code": ["/******************************************************************************\n *\n * Module Name: nsutils - Utilities for accessing ACPI namespace, accessing\n *                        parents and siblings and Scope manipulation\n *\n *****************************************************************************/\n\n/******************************************************************************\n *\n * 1. Copyright Notice\n *\n * Some or all of this work - Copyright (c) 1999 - 2017, Intel Corp.\n * All rights reserved.\n *\n * 2. License\n *\n * 2.1. This is your license from Intel Corp. under its intellectual property\n * rights. You may have additional license terms from the party that provided\n * you this software, covering your right to use that party's intellectual\n * property rights.\n *\n * 2.2. Intel grants, free of charge, to any person (\"Licensee\") obtaining a\n * copy of the source code appearing in this file (\"Covered Code\") an\n * irrevocable, perpetual, worldwide license under Intel's copyrights in the\n * base code distributed originally by Intel (\"Original Intel Code\") to copy,\n * make derivatives, distribute, use and display any portion of the Covered\n * Code in any form, with the right to sublicense such rights; and\n *\n * 2.3. Intel grants Licensee a non-exclusive and non-transferable patent\n * license (with the right to sublicense), under only those claims of Intel\n * patents that are infringed by the Original Intel Code, to make, use, sell,\n * offer to sell, and import the Covered Code and derivative works thereof\n * solely to the minimum extent necessary to exercise the above copyright\n * license, and in no event shall the patent license extend to any additions\n * to or modifications of the Original Intel Code. No other license or right\n * is granted directly or by implication, estoppel or otherwise;\n *\n * The above copyright and patent license is granted only if the following\n * conditions are met:\n *\n * 3. Conditions\n *\n * 3.1. Redistribution of Source with Rights to Further Distribute Source.\n * Redistribution of source code of any substantial portion of the Covered\n * Code or modification with rights to further distribute source must include\n * the above Copyright Notice, the above License, this list of Conditions,\n * and the following Disclaimer and Export Compliance provision. In addition,\n * Licensee must cause all Covered Code to which Licensee contributes to\n * contain a file documenting the changes Licensee made to create that Covered\n * Code and the date of any change. Licensee must include in that file the\n * documentation of any changes made by any predecessor Licensee. Licensee\n * must include a prominent statement that the modification is derived,\n * directly or indirectly, from Original Intel Code.\n *\n * 3.2. Redistribution of Source with no Rights to Further Distribute Source.\n * Redistribution of source code of any substantial portion of the Covered\n * Code or modification without rights to further distribute source must\n * include the following Disclaimer and Export Compliance provision in the\n * documentation and/or other materials provided with distribution. In\n * addition, Licensee may not authorize further sublicense of source of any\n * portion of the Covered Code, and must include terms to the effect that the\n * license from Licensee to its licensee is limited to the intellectual\n * property embodied in the software Licensee provides to its licensee, and\n * not to intellectual property embodied in modifications its licensee may\n * make.\n *\n * 3.3. Redistribution of Executable. Redistribution in executable form of any\n * substantial portion of the Covered Code or modification must reproduce the\n * above Copyright Notice, and the following Disclaimer and Export Compliance\n * provision in the documentation and/or other materials provided with the\n * distribution.\n *\n * 3.4. Intel retains all right, title, and interest in and to the Original\n * Intel Code.\n *\n * 3.5. Neither the name Intel nor any other trademark owned or controlled by\n * Intel shall be used in advertising or otherwise to promote the sale, use or\n * other dealings in products derived from or relating to the Covered Code\n * without prior written authorization from Intel.\n *\n * 4. Disclaimer and Export Compliance\n *\n * 4.1. INTEL MAKES NO WARRANTY OF ANY KIND REGARDING ANY SOFTWARE PROVIDED\n * HERE. ANY SOFTWARE ORIGINATING FROM INTEL OR DERIVED FROM INTEL SOFTWARE\n * IS PROVIDED \"AS IS,\" AND INTEL WILL NOT PROVIDE ANY SUPPORT, ASSISTANCE,\n * INSTALLATION, TRAINING OR OTHER SERVICES. INTEL WILL NOT PROVIDE ANY\n * UPDATES, ENHANCEMENTS OR EXTENSIONS. INTEL SPECIFICALLY DISCLAIMS ANY\n * IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGEMENT AND FITNESS FOR A\n * PARTICULAR PURPOSE.\n *\n * 4.2. IN NO EVENT SHALL INTEL HAVE ANY LIABILITY TO LICENSEE, ITS LICENSEES\n * OR ANY OTHER THIRD PARTY, FOR ANY LOST PROFITS, LOST DATA, LOSS OF USE OR\n * COSTS OF PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, OR FOR ANY INDIRECT,\n * SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THIS AGREEMENT, UNDER ANY\n * CAUSE OF ACTION OR THEORY OF LIABILITY, AND IRRESPECTIVE OF WHETHER INTEL\n * HAS ADVANCE NOTICE OF THE POSSIBILITY OF SUCH DAMAGES. THESE LIMITATIONS\n * SHALL APPLY NOTWITHSTANDING THE FAILURE OF THE ESSENTIAL PURPOSE OF ANY\n * LIMITED REMEDY.\n *\n * 4.3. Licensee shall not export, either directly or indirectly, any of this\n * software or system incorporating such software without first obtaining any\n * required license or other approval from the U. S. Department of Commerce or\n * any other agency or department of the United States Government. In the\n * event Licensee exports any such software from the United States or\n * re-exports any such software from a foreign destination, Licensee shall\n * ensure that the distribution and export/re-export of the software is in\n * compliance with all laws, regulations, orders, or other restrictions of the\n * U.S. Export Administration Regulations. Licensee agrees that neither it nor\n * any of its subsidiaries will export/re-export any technical data, process,\n * software, or service, directly or indirectly, to any country for which the\n * United States government or any agency thereof requires an export license,\n * other governmental approval, or letter of assurance, without first obtaining\n * such license, approval or letter.\n *\n *****************************************************************************/\n\n#include \"acpi.h\"\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n#include \"amlcode.h\"\n\n#define _COMPONENT          ACPI_NAMESPACE\n        ACPI_MODULE_NAME    (\"nsutils\")\n\n/* Local prototypes */\n\n#ifdef ACPI_OBSOLETE_FUNCTIONS\nACPI_NAME\nAcpiNsFindParentName (\n    ACPI_NAMESPACE_NODE     *NodeToSearch);\n#endif\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsPrintNodePathname\n *\n * PARAMETERS:  Node            - Object\n *              Message         - Prefix message\n *\n * DESCRIPTION: Print an object's full namespace pathname\n *              Manages allocation/freeing of a pathname buffer\n *\n ******************************************************************************/\n\nvoid\nAcpiNsPrintNodePathname (\n    ACPI_NAMESPACE_NODE     *Node,\n    const char              *Message)\n{\n    ACPI_BUFFER             Buffer;\n    ACPI_STATUS             Status;\n\n\n    if (!Node)\n    {\n        AcpiOsPrintf (\"[NULL NAME]\");\n        return;\n    }\n\n    /* Convert handle to full pathname and print it (with supplied message) */\n\n    Buffer.Length = ACPI_ALLOCATE_LOCAL_BUFFER;\n\n    Status = AcpiNsHandleToPathname (Node, &Buffer, TRUE);\n    if (ACPI_SUCCESS (Status))\n    {\n        if (Message)\n        {\n            AcpiOsPrintf (\"%s \", Message);\n        }\n\n        AcpiOsPrintf (\"[%s] (Node %p)\", (char *) Buffer.Pointer, Node);\n        ACPI_FREE (Buffer.Pointer);\n    }\n}\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsGetType\n *\n * PARAMETERS:  Node        - Parent Node to be examined\n *\n * RETURN:      Type field from Node whose handle is passed\n *\n * DESCRIPTION: Return the type of a Namespace node\n *\n ******************************************************************************/\n\nACPI_OBJECT_TYPE\nAcpiNsGetType (\n    ACPI_NAMESPACE_NODE     *Node)\n{\n    ACPI_FUNCTION_TRACE (NsGetType);\n\n\n    if (!Node)\n    {\n        ACPI_WARNING ((AE_INFO, \"Null Node parameter\"));\n        return_UINT8 (ACPI_TYPE_ANY);\n    }\n\n    return_UINT8 (Node->Type);\n}\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsLocal\n *\n * PARAMETERS:  Type        - A namespace object type\n *\n * RETURN:      LOCAL if names must be found locally in objects of the\n *              passed type, 0 if enclosing scopes should be searched\n *\n * DESCRIPTION: Returns scope rule for the given object type.\n *\n ******************************************************************************/\n\nUINT32\nAcpiNsLocal (\n    ACPI_OBJECT_TYPE        Type)\n{\n    ACPI_FUNCTION_TRACE (NsLocal);\n\n\n    if (!AcpiUtValidObjectType (Type))\n    {\n        /* Type code out of range  */\n\n        ACPI_WARNING ((AE_INFO, \"Invalid Object Type 0x%X\", Type));\n        return_UINT32 (ACPI_NS_NORMAL);\n    }\n\n    return_UINT32 (AcpiGbl_NsProperties[Type] & ACPI_NS_LOCAL);\n}\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsGetInternalNameLength\n *\n * PARAMETERS:  Info            - Info struct initialized with the\n *                                external name pointer.\n *\n * RETURN:      None\n *\n * DESCRIPTION: Calculate the length of the internal (AML) namestring\n *              corresponding to the external (ASL) namestring.\n *\n ******************************************************************************/\n\nvoid\nAcpiNsGetInternalNameLength (\n    ACPI_NAMESTRING_INFO    *Info)\n{\n    const char              *NextExternalChar;\n    UINT32                  i;\n\n\n    ACPI_FUNCTION_ENTRY ();\n\n\n    NextExternalChar = Info->ExternalName;\n    Info->NumCarats = 0;\n    Info->NumSegments = 0;\n    Info->FullyQualified = FALSE;\n\n    /*\n     * For the internal name, the required length is 4 bytes per segment,\n     * plus 1 each for RootPrefix, MultiNamePrefixOp, segment count,\n     * trailing null (which is not really needed, but no there's harm in\n     * putting it there)\n     *\n     * strlen() + 1 covers the first NameSeg, which has no path separator\n     */\n    if (ACPI_IS_ROOT_PREFIX (*NextExternalChar))\n    {\n        Info->FullyQualified = TRUE;\n        NextExternalChar++;\n\n        /* Skip redundant RootPrefix, like \\\\_SB.PCI0.SBRG.EC0 */\n\n        while (ACPI_IS_ROOT_PREFIX (*NextExternalChar))\n        {\n            NextExternalChar++;\n        }\n    }\n    else\n    {\n        /* Handle Carat prefixes */\n\n        while (ACPI_IS_PARENT_PREFIX (*NextExternalChar))\n        {\n            Info->NumCarats++;\n            NextExternalChar++;\n        }\n    }\n\n    /*\n     * Determine the number of ACPI name \"segments\" by counting the number of\n     * path separators within the string. Start with one segment since the\n     * segment count is [(# separators) + 1], and zero separators is ok.\n     */\n    if (*NextExternalChar)\n    {\n        Info->NumSegments = 1;\n        for (i = 0; NextExternalChar[i]; i++)\n        {\n            if (ACPI_IS_PATH_SEPARATOR (NextExternalChar[i]))\n            {\n                Info->NumSegments++;\n            }\n        }\n    }\n\n    Info->Length = (ACPI_NAME_SIZE * Info->NumSegments) +\n        4 + Info->NumCarats;\n\n    Info->NextExternalChar = NextExternalChar;\n}\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsBuildInternalName\n *\n * PARAMETERS:  Info            - Info struct fully initialized\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Construct the internal (AML) namestring\n *              corresponding to the external (ASL) namestring.\n *\n ******************************************************************************/\n\nACPI_STATUS\nAcpiNsBuildInternalName (\n    ACPI_NAMESTRING_INFO    *Info)\n{\n    UINT32                  NumSegments = Info->NumSegments;\n    char                    *InternalName = Info->InternalName;\n    const char              *ExternalName = Info->NextExternalChar;\n    char                    *Result = NULL;\n    UINT32                  i;\n\n\n    ACPI_FUNCTION_TRACE (NsBuildInternalName);\n\n\n    /* Setup the correct prefixes, counts, and pointers */\n\n    if (Info->FullyQualified)\n    {\n        InternalName[0] = AML_ROOT_PREFIX;\n\n        if (NumSegments <= 1)\n        {\n            Result = &InternalName[1];\n        }\n        else if (NumSegments == 2)\n        {\n            InternalName[1] = AML_DUAL_NAME_PREFIX;\n            Result = &InternalName[2];\n        }\n        else\n        {\n            InternalName[1] = AML_MULTI_NAME_PREFIX_OP;\n            InternalName[2] = (char) NumSegments;\n            Result = &InternalName[3];\n        }\n    }\n    else\n    {\n        /*\n         * Not fully qualified.\n         * Handle Carats first, then append the name segments\n         */\n        i = 0;\n        if (Info->NumCarats)\n        {\n            for (i = 0; i < Info->NumCarats; i++)\n            {\n                InternalName[i] = AML_PARENT_PREFIX;\n            }\n        }\n\n        if (NumSegments <= 1)\n        {\n            Result = &InternalName[i];\n        }\n        else if (NumSegments == 2)\n        {\n            InternalName[i] = AML_DUAL_NAME_PREFIX;\n            Result = &InternalName[(ACPI_SIZE) i+1];\n        }\n        else\n        {\n            InternalName[i] = AML_MULTI_NAME_PREFIX_OP;\n            InternalName[(ACPI_SIZE) i+1] = (char) NumSegments;\n            Result = &InternalName[(ACPI_SIZE) i+2];\n        }\n    }\n\n    /* Build the name (minus path separators) */\n\n    for (; NumSegments; NumSegments--)\n    {\n        for (i = 0; i < ACPI_NAME_SIZE; i++)\n        {\n            if (ACPI_IS_PATH_SEPARATOR (*ExternalName) ||\n               (*ExternalName == 0))\n            {\n                /* Pad the segment with underscore(s) if segment is short */\n\n                Result[i] = '_';\n            }\n            else\n            {\n                /* Convert the character to uppercase and save it */\n\n                Result[i] = (char) toupper ((int) *ExternalName);\n                ExternalName++;\n            }\n        }\n\n        /* Now we must have a path separator, or the pathname is bad */\n\n        if (!ACPI_IS_PATH_SEPARATOR (*ExternalName) &&\n            (*ExternalName != 0))\n        {\n            return_ACPI_STATUS (AE_BAD_PATHNAME);\n        }\n\n        /* Move on the next segment */\n\n        ExternalName++;\n        Result += ACPI_NAME_SIZE;\n    }\n\n    /* Terminate the string */\n\n    *Result = 0;\n\n    if (Info->FullyQualified)\n    {\n        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, \"Returning [%p] (abs) \\\"\\\\%s\\\"\\n\",\n            InternalName, InternalName));\n    }\n    else\n    {\n        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, \"Returning [%p] (rel) \\\"%s\\\"\\n\",\n            InternalName, InternalName));\n    }\n\n    return_ACPI_STATUS (AE_OK);\n}\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsInternalizeName\n *\n * PARAMETERS:  *ExternalName           - External representation of name\n *              **Converted Name        - Where to return the resulting\n *                                        internal represention of the name\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Convert an external representation (e.g. \"\\_PR_.CPU0\")\n *              to internal form (e.g. 5c 2f 02 5f 50 52 5f 43 50 55 30)\n *\n *******************************************************************************/\n\nACPI_STATUS\nAcpiNsInternalizeName (\n    const char              *ExternalName,\n    char                    **ConvertedName)\n{\n    char                    *InternalName;\n    ACPI_NAMESTRING_INFO    Info;\n    ACPI_STATUS             Status;\n\n\n    ACPI_FUNCTION_TRACE (NsInternalizeName);\n\n\n    if ((!ExternalName)      ||\n        (*ExternalName == 0) ||\n        (!ConvertedName))\n    {\n        return_ACPI_STATUS (AE_BAD_PARAMETER);\n    }\n\n    /* Get the length of the new internal name */\n\n    Info.ExternalName = ExternalName;\n    AcpiNsGetInternalNameLength (&Info);\n\n    /* We need a segment to store the internal  name */\n\n    InternalName = ACPI_ALLOCATE_ZEROED (Info.Length);\n    if (!InternalName)\n    {\n        return_ACPI_STATUS (AE_NO_MEMORY);\n    }\n\n    /* Build the name */\n\n    Info.InternalName = InternalName;\n    Status = AcpiNsBuildInternalName (&Info);\n    if (ACPI_FAILURE (Status))\n    {\n        ACPI_FREE (InternalName);\n        return_ACPI_STATUS (Status);\n    }\n\n    *ConvertedName = InternalName;\n    return_ACPI_STATUS (AE_OK);\n}\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsExternalizeName\n *\n * PARAMETERS:  InternalNameLength  - Lenth of the internal name below\n *              InternalName        - Internal representation of name\n *              ConvertedNameLength - Where the length is returned\n *              ConvertedName       - Where the resulting external name\n *                                    is returned\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Convert internal name (e.g. 5c 2f 02 5f 50 52 5f 43 50 55 30)\n *              to its external (printable) form (e.g. \"\\_PR_.CPU0\")\n *\n ******************************************************************************/\n\nACPI_STATUS\nAcpiNsExternalizeName (\n    UINT32                  InternalNameLength,\n    const char              *InternalName,\n    UINT32                  *ConvertedNameLength,\n    char                    **ConvertedName)\n{\n    UINT32                  NamesIndex = 0;\n    UINT32                  NumSegments = 0;\n    UINT32                  RequiredLength;\n    UINT32                  PrefixLength = 0;\n    UINT32                  i = 0;\n    UINT32                  j = 0;\n\n\n    ACPI_FUNCTION_TRACE (NsExternalizeName);\n\n\n    if (!InternalNameLength     ||\n        !InternalName           ||\n        !ConvertedName)\n    {\n        return_ACPI_STATUS (AE_BAD_PARAMETER);\n    }\n\n    /* Check for a prefix (one '\\' | one or more '^') */\n\n    switch (InternalName[0])\n    {\n    case AML_ROOT_PREFIX:\n\n        PrefixLength = 1;\n        break;\n\n    case AML_PARENT_PREFIX:\n\n        for (i = 0; i < InternalNameLength; i++)\n        {\n            if (ACPI_IS_PARENT_PREFIX (InternalName[i]))\n            {\n                PrefixLength = i + 1;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        if (i == InternalNameLength)\n        {\n            PrefixLength = i;\n        }\n\n        break;\n\n    default:\n\n        break;\n    }\n\n    /*\n     * Check for object names. Note that there could be 0-255 of these\n     * 4-byte elements.\n     */\n    if (PrefixLength < InternalNameLength)\n    {\n        switch (InternalName[PrefixLength])\n        {\n        case AML_MULTI_NAME_PREFIX_OP:\n\n            /* <count> 4-byte names */\n\n            NamesIndex = PrefixLength + 2;\n            NumSegments = (UINT8)\n                InternalName[(ACPI_SIZE) PrefixLength + 1];\n            break;\n\n        case AML_DUAL_NAME_PREFIX:\n\n            /* Two 4-byte names */\n\n            NamesIndex = PrefixLength + 1;\n            NumSegments = 2;\n            break;\n\n        case 0:\n\n            /* NullName */\n\n            NamesIndex = 0;\n            NumSegments = 0;\n            break;\n\n        default:\n\n            /* one 4-byte name */\n\n            NamesIndex = PrefixLength;\n            NumSegments = 1;\n            break;\n        }\n    }\n\n    /*\n     * Calculate the length of ConvertedName, which equals the length\n     * of the prefix, length of all object names, length of any required\n     * punctuation ('.') between object names, plus the NULL terminator.\n     */\n    RequiredLength = PrefixLength + (4 * NumSegments) +\n        ((NumSegments > 0) ? (NumSegments - 1) : 0) + 1;\n\n    /*\n     * Check to see if we're still in bounds. If not, there's a problem\n     * with InternalName (invalid format).\n     */\n    if (RequiredLength > InternalNameLength)\n    {\n        ACPI_ERROR ((AE_INFO, \"Invalid internal name\"));\n        return_ACPI_STATUS (AE_BAD_PATHNAME);\n    }\n\n    /* Build the ConvertedName */\n\n    *ConvertedName = ACPI_ALLOCATE_ZEROED (RequiredLength);\n    if (!(*ConvertedName))\n    {\n        return_ACPI_STATUS (AE_NO_MEMORY);\n    }\n\n    j = 0;\n\n    for (i = 0; i < PrefixLength; i++)\n    {\n        (*ConvertedName)[j++] = InternalName[i];\n    }\n\n    if (NumSegments > 0)\n    {\n        for (i = 0; i < NumSegments; i++)\n        {\n            if (i > 0)\n            {\n                (*ConvertedName)[j++] = '.';\n            }\n\n            /* Copy and validate the 4-char name segment */\n\n            ACPI_MOVE_NAME (&(*ConvertedName)[j],\n                &InternalName[NamesIndex]);\n            AcpiUtRepairName (&(*ConvertedName)[j]);\n\n            j += ACPI_NAME_SIZE;\n            NamesIndex += ACPI_NAME_SIZE;\n        }\n    }\n\n    if (ConvertedNameLength)\n    {\n        *ConvertedNameLength = (UINT32) RequiredLength;\n    }\n\n    return_ACPI_STATUS (AE_OK);\n}\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsValidateHandle\n *\n * PARAMETERS:  Handle          - Handle to be validated and typecast to a\n *                                namespace node.\n *\n * RETURN:      A pointer to a namespace node\n *\n * DESCRIPTION: Convert a namespace handle to a namespace node. Handles special\n *              cases for the root node.\n *\n * NOTE: Real integer handles would allow for more verification\n *       and keep all pointers within this subsystem - however this introduces\n *       more overhead and has not been necessary to this point. Drivers\n *       holding handles are typically notified before a node becomes invalid\n *       due to a table unload.\n *\n ******************************************************************************/\n\nACPI_NAMESPACE_NODE *\nAcpiNsValidateHandle (\n    ACPI_HANDLE             Handle)\n{\n\n    ACPI_FUNCTION_ENTRY ();\n\n\n    /* Parameter validation */\n\n    if ((!Handle) || (Handle == ACPI_ROOT_OBJECT))\n    {\n        return (AcpiGbl_RootNode);\n    }\n\n    /* We can at least attempt to verify the handle */\n\n    if (ACPI_GET_DESCRIPTOR_TYPE (Handle) != ACPI_DESC_TYPE_NAMED)\n    {\n        return (NULL);\n    }\n\n    return (ACPI_CAST_PTR (ACPI_NAMESPACE_NODE, Handle));\n}\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsTerminate\n *\n * PARAMETERS:  none\n *\n * RETURN:      none\n *\n * DESCRIPTION: free memory allocated for namespace and ACPI table storage.\n *\n ******************************************************************************/\n\nvoid\nAcpiNsTerminate (\n    void)\n{\n    ACPI_STATUS             Status;\n\n\n    ACPI_FUNCTION_TRACE (NsTerminate);\n\n\n#ifdef ACPI_EXEC_APP\n    {\n        ACPI_OPERAND_OBJECT     *Prev;\n        ACPI_OPERAND_OBJECT     *Next;\n\n        /* Delete any module-level code blocks */\n\n        Next = AcpiGbl_ModuleCodeList;\n        while (Next)\n        {\n            Prev = Next;\n            Next = Next->Method.Mutex;\n            Prev->Method.Mutex = NULL; /* Clear the Mutex (cheated) field */\n            AcpiUtRemoveReference (Prev);\n        }\n    }\n#endif\n\n    /*\n     * Free the entire namespace -- all nodes and all objects\n     * attached to the nodes\n     */\n    AcpiNsDeleteNamespaceSubtree (AcpiGbl_RootNode);\n\n    /* Delete any objects attached to the root node */\n\n    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);\n    if (ACPI_FAILURE (Status))\n    {\n        return_VOID;\n    }\n\n    AcpiNsDeleteNode (AcpiGbl_RootNode);\n    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);\n\n    ACPI_DEBUG_PRINT ((ACPI_DB_INFO, \"Namespace freed\\n\"));\n    return_VOID;\n}\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsOpensScope\n *\n * PARAMETERS:  Type        - A valid namespace type\n *\n * RETURN:      NEWSCOPE if the passed type \"opens a name scope\" according\n *              to the ACPI specification, else 0\n *\n ******************************************************************************/\n\nUINT32\nAcpiNsOpensScope (\n    ACPI_OBJECT_TYPE        Type)\n{\n    ACPI_FUNCTION_ENTRY ();\n\n\n    if (Type > ACPI_TYPE_LOCAL_MAX)\n    {\n        /* type code out of range  */\n\n        ACPI_WARNING ((AE_INFO, \"Invalid Object Type 0x%X\", Type));\n        return (ACPI_NS_NORMAL);\n    }\n\n    return (((UINT32) AcpiGbl_NsProperties[Type]) & ACPI_NS_NEWSCOPE);\n}\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsGetNodeUnlocked\n *\n * PARAMETERS:  *Pathname   - Name to be found, in external (ASL) format. The\n *                            \\ (backslash) and ^ (carat) prefixes, and the\n *                            . (period) to separate segments are supported.\n *              PrefixNode   - Root of subtree to be searched, or NS_ALL for the\n *                            root of the name space. If Name is fully\n *                            qualified (first INT8 is '\\'), the passed value\n *                            of Scope will not be accessed.\n *              Flags       - Used to indicate whether to perform upsearch or\n *                            not.\n *              ReturnNode  - Where the Node is returned\n *\n * DESCRIPTION: Look up a name relative to a given scope and return the\n *              corresponding Node. NOTE: Scope can be null.\n *\n * MUTEX:       Doesn't locks namespace\n *\n ******************************************************************************/\n\nACPI_STATUS\nAcpiNsGetNodeUnlocked (\n    ACPI_NAMESPACE_NODE     *PrefixNode,\n    const char              *Pathname,\n    UINT32                  Flags,\n    ACPI_NAMESPACE_NODE     **ReturnNode)\n{\n    ACPI_GENERIC_STATE      ScopeInfo;\n    ACPI_STATUS             Status;\n    char                    *InternalPath;\n\n\n    ACPI_FUNCTION_TRACE_PTR (NsGetNodeUnlocked, ACPI_CAST_PTR (char, Pathname));\n\n\n    /* Simplest case is a null pathname */\n\n    if (!Pathname)\n    {\n        *ReturnNode = PrefixNode;\n        if (!PrefixNode)\n        {\n            *ReturnNode = AcpiGbl_RootNode;\n        }\n\n        return_ACPI_STATUS (AE_OK);\n    }\n\n    /* Quick check for a reference to the root */\n\n    if (ACPI_IS_ROOT_PREFIX (Pathname[0]) && (!Pathname[1]))\n    {\n        *ReturnNode = AcpiGbl_RootNode;\n        return_ACPI_STATUS (AE_OK);\n    }\n\n    /* Convert path to internal representation */\n\n    Status = AcpiNsInternalizeName (Pathname, &InternalPath);\n    if (ACPI_FAILURE (Status))\n    {\n        return_ACPI_STATUS (Status);\n    }\n\n    /* Setup lookup scope (search starting point) */\n\n    ScopeInfo.Scope.Node = PrefixNode;\n\n    /* Lookup the name in the namespace */\n\n    Status = AcpiNsLookup (&ScopeInfo, InternalPath, ACPI_TYPE_ANY,\n        ACPI_IMODE_EXECUTE, (Flags | ACPI_NS_DONT_OPEN_SCOPE),\n        NULL, ReturnNode);\n    if (ACPI_FAILURE (Status))\n    {\n        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, \"%s, %s\\n\",\n            Pathname, AcpiFormatException (Status)));\n    }\n\n    ACPI_FREE (InternalPath);\n    return_ACPI_STATUS (Status);\n}\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsGetNode\n *\n * PARAMETERS:  *Pathname   - Name to be found, in external (ASL) format. The\n *                            \\ (backslash) and ^ (carat) prefixes, and the\n *                            . (period) to separate segments are supported.\n *              PrefixNode   - Root of subtree to be searched, or NS_ALL for the\n *                            root of the name space. If Name is fully\n *                            qualified (first INT8 is '\\'), the passed value\n *                            of Scope will not be accessed.\n *              Flags       - Used to indicate whether to perform upsearch or\n *                            not.\n *              ReturnNode  - Where the Node is returned\n *\n * DESCRIPTION: Look up a name relative to a given scope and return the\n *              corresponding Node. NOTE: Scope can be null.\n *\n * MUTEX:       Locks namespace\n *\n ******************************************************************************/\n\nACPI_STATUS\nAcpiNsGetNode (\n    ACPI_NAMESPACE_NODE     *PrefixNode,\n    const char              *Pathname,\n    UINT32                  Flags,\n    ACPI_NAMESPACE_NODE     **ReturnNode)\n{\n    ACPI_STATUS             Status;\n\n\n    ACPI_FUNCTION_TRACE_PTR (NsGetNode, ACPI_CAST_PTR (char, Pathname));\n\n\n    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);\n    if (ACPI_FAILURE (Status))\n    {\n        return_ACPI_STATUS (Status);\n    }\n\n    Status = AcpiNsGetNodeUnlocked (PrefixNode, Pathname,\n        Flags, ReturnNode);\n\n    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);\n    return_ACPI_STATUS (Status);\n}\n"], "fixing_code": ["/******************************************************************************\n *\n * Module Name: nsutils - Utilities for accessing ACPI namespace, accessing\n *                        parents and siblings and Scope manipulation\n *\n *****************************************************************************/\n\n/******************************************************************************\n *\n * 1. Copyright Notice\n *\n * Some or all of this work - Copyright (c) 1999 - 2017, Intel Corp.\n * All rights reserved.\n *\n * 2. License\n *\n * 2.1. This is your license from Intel Corp. under its intellectual property\n * rights. You may have additional license terms from the party that provided\n * you this software, covering your right to use that party's intellectual\n * property rights.\n *\n * 2.2. Intel grants, free of charge, to any person (\"Licensee\") obtaining a\n * copy of the source code appearing in this file (\"Covered Code\") an\n * irrevocable, perpetual, worldwide license under Intel's copyrights in the\n * base code distributed originally by Intel (\"Original Intel Code\") to copy,\n * make derivatives, distribute, use and display any portion of the Covered\n * Code in any form, with the right to sublicense such rights; and\n *\n * 2.3. Intel grants Licensee a non-exclusive and non-transferable patent\n * license (with the right to sublicense), under only those claims of Intel\n * patents that are infringed by the Original Intel Code, to make, use, sell,\n * offer to sell, and import the Covered Code and derivative works thereof\n * solely to the minimum extent necessary to exercise the above copyright\n * license, and in no event shall the patent license extend to any additions\n * to or modifications of the Original Intel Code. No other license or right\n * is granted directly or by implication, estoppel or otherwise;\n *\n * The above copyright and patent license is granted only if the following\n * conditions are met:\n *\n * 3. Conditions\n *\n * 3.1. Redistribution of Source with Rights to Further Distribute Source.\n * Redistribution of source code of any substantial portion of the Covered\n * Code or modification with rights to further distribute source must include\n * the above Copyright Notice, the above License, this list of Conditions,\n * and the following Disclaimer and Export Compliance provision. In addition,\n * Licensee must cause all Covered Code to which Licensee contributes to\n * contain a file documenting the changes Licensee made to create that Covered\n * Code and the date of any change. Licensee must include in that file the\n * documentation of any changes made by any predecessor Licensee. Licensee\n * must include a prominent statement that the modification is derived,\n * directly or indirectly, from Original Intel Code.\n *\n * 3.2. Redistribution of Source with no Rights to Further Distribute Source.\n * Redistribution of source code of any substantial portion of the Covered\n * Code or modification without rights to further distribute source must\n * include the following Disclaimer and Export Compliance provision in the\n * documentation and/or other materials provided with distribution. In\n * addition, Licensee may not authorize further sublicense of source of any\n * portion of the Covered Code, and must include terms to the effect that the\n * license from Licensee to its licensee is limited to the intellectual\n * property embodied in the software Licensee provides to its licensee, and\n * not to intellectual property embodied in modifications its licensee may\n * make.\n *\n * 3.3. Redistribution of Executable. Redistribution in executable form of any\n * substantial portion of the Covered Code or modification must reproduce the\n * above Copyright Notice, and the following Disclaimer and Export Compliance\n * provision in the documentation and/or other materials provided with the\n * distribution.\n *\n * 3.4. Intel retains all right, title, and interest in and to the Original\n * Intel Code.\n *\n * 3.5. Neither the name Intel nor any other trademark owned or controlled by\n * Intel shall be used in advertising or otherwise to promote the sale, use or\n * other dealings in products derived from or relating to the Covered Code\n * without prior written authorization from Intel.\n *\n * 4. Disclaimer and Export Compliance\n *\n * 4.1. INTEL MAKES NO WARRANTY OF ANY KIND REGARDING ANY SOFTWARE PROVIDED\n * HERE. ANY SOFTWARE ORIGINATING FROM INTEL OR DERIVED FROM INTEL SOFTWARE\n * IS PROVIDED \"AS IS,\" AND INTEL WILL NOT PROVIDE ANY SUPPORT, ASSISTANCE,\n * INSTALLATION, TRAINING OR OTHER SERVICES. INTEL WILL NOT PROVIDE ANY\n * UPDATES, ENHANCEMENTS OR EXTENSIONS. INTEL SPECIFICALLY DISCLAIMS ANY\n * IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGEMENT AND FITNESS FOR A\n * PARTICULAR PURPOSE.\n *\n * 4.2. IN NO EVENT SHALL INTEL HAVE ANY LIABILITY TO LICENSEE, ITS LICENSEES\n * OR ANY OTHER THIRD PARTY, FOR ANY LOST PROFITS, LOST DATA, LOSS OF USE OR\n * COSTS OF PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, OR FOR ANY INDIRECT,\n * SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THIS AGREEMENT, UNDER ANY\n * CAUSE OF ACTION OR THEORY OF LIABILITY, AND IRRESPECTIVE OF WHETHER INTEL\n * HAS ADVANCE NOTICE OF THE POSSIBILITY OF SUCH DAMAGES. THESE LIMITATIONS\n * SHALL APPLY NOTWITHSTANDING THE FAILURE OF THE ESSENTIAL PURPOSE OF ANY\n * LIMITED REMEDY.\n *\n * 4.3. Licensee shall not export, either directly or indirectly, any of this\n * software or system incorporating such software without first obtaining any\n * required license or other approval from the U. S. Department of Commerce or\n * any other agency or department of the United States Government. In the\n * event Licensee exports any such software from the United States or\n * re-exports any such software from a foreign destination, Licensee shall\n * ensure that the distribution and export/re-export of the software is in\n * compliance with all laws, regulations, orders, or other restrictions of the\n * U.S. Export Administration Regulations. Licensee agrees that neither it nor\n * any of its subsidiaries will export/re-export any technical data, process,\n * software, or service, directly or indirectly, to any country for which the\n * United States government or any agency thereof requires an export license,\n * other governmental approval, or letter of assurance, without first obtaining\n * such license, approval or letter.\n *\n *****************************************************************************/\n\n#include \"acpi.h\"\n#include \"accommon.h\"\n#include \"acnamesp.h\"\n#include \"amlcode.h\"\n\n#define _COMPONENT          ACPI_NAMESPACE\n        ACPI_MODULE_NAME    (\"nsutils\")\n\n/* Local prototypes */\n\n#ifdef ACPI_OBSOLETE_FUNCTIONS\nACPI_NAME\nAcpiNsFindParentName (\n    ACPI_NAMESPACE_NODE     *NodeToSearch);\n#endif\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsPrintNodePathname\n *\n * PARAMETERS:  Node            - Object\n *              Message         - Prefix message\n *\n * DESCRIPTION: Print an object's full namespace pathname\n *              Manages allocation/freeing of a pathname buffer\n *\n ******************************************************************************/\n\nvoid\nAcpiNsPrintNodePathname (\n    ACPI_NAMESPACE_NODE     *Node,\n    const char              *Message)\n{\n    ACPI_BUFFER             Buffer;\n    ACPI_STATUS             Status;\n\n\n    if (!Node)\n    {\n        AcpiOsPrintf (\"[NULL NAME]\");\n        return;\n    }\n\n    /* Convert handle to full pathname and print it (with supplied message) */\n\n    Buffer.Length = ACPI_ALLOCATE_LOCAL_BUFFER;\n\n    Status = AcpiNsHandleToPathname (Node, &Buffer, TRUE);\n    if (ACPI_SUCCESS (Status))\n    {\n        if (Message)\n        {\n            AcpiOsPrintf (\"%s \", Message);\n        }\n\n        AcpiOsPrintf (\"[%s] (Node %p)\", (char *) Buffer.Pointer, Node);\n        ACPI_FREE (Buffer.Pointer);\n    }\n}\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsGetType\n *\n * PARAMETERS:  Node        - Parent Node to be examined\n *\n * RETURN:      Type field from Node whose handle is passed\n *\n * DESCRIPTION: Return the type of a Namespace node\n *\n ******************************************************************************/\n\nACPI_OBJECT_TYPE\nAcpiNsGetType (\n    ACPI_NAMESPACE_NODE     *Node)\n{\n    ACPI_FUNCTION_TRACE (NsGetType);\n\n\n    if (!Node)\n    {\n        ACPI_WARNING ((AE_INFO, \"Null Node parameter\"));\n        return_UINT8 (ACPI_TYPE_ANY);\n    }\n\n    return_UINT8 (Node->Type);\n}\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsLocal\n *\n * PARAMETERS:  Type        - A namespace object type\n *\n * RETURN:      LOCAL if names must be found locally in objects of the\n *              passed type, 0 if enclosing scopes should be searched\n *\n * DESCRIPTION: Returns scope rule for the given object type.\n *\n ******************************************************************************/\n\nUINT32\nAcpiNsLocal (\n    ACPI_OBJECT_TYPE        Type)\n{\n    ACPI_FUNCTION_TRACE (NsLocal);\n\n\n    if (!AcpiUtValidObjectType (Type))\n    {\n        /* Type code out of range  */\n\n        ACPI_WARNING ((AE_INFO, \"Invalid Object Type 0x%X\", Type));\n        return_UINT32 (ACPI_NS_NORMAL);\n    }\n\n    return_UINT32 (AcpiGbl_NsProperties[Type] & ACPI_NS_LOCAL);\n}\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsGetInternalNameLength\n *\n * PARAMETERS:  Info            - Info struct initialized with the\n *                                external name pointer.\n *\n * RETURN:      None\n *\n * DESCRIPTION: Calculate the length of the internal (AML) namestring\n *              corresponding to the external (ASL) namestring.\n *\n ******************************************************************************/\n\nvoid\nAcpiNsGetInternalNameLength (\n    ACPI_NAMESTRING_INFO    *Info)\n{\n    const char              *NextExternalChar;\n    UINT32                  i;\n\n\n    ACPI_FUNCTION_ENTRY ();\n\n\n    NextExternalChar = Info->ExternalName;\n    Info->NumCarats = 0;\n    Info->NumSegments = 0;\n    Info->FullyQualified = FALSE;\n\n    /*\n     * For the internal name, the required length is 4 bytes per segment,\n     * plus 1 each for RootPrefix, MultiNamePrefixOp, segment count,\n     * trailing null (which is not really needed, but no there's harm in\n     * putting it there)\n     *\n     * strlen() + 1 covers the first NameSeg, which has no path separator\n     */\n    if (ACPI_IS_ROOT_PREFIX (*NextExternalChar))\n    {\n        Info->FullyQualified = TRUE;\n        NextExternalChar++;\n\n        /* Skip redundant RootPrefix, like \\\\_SB.PCI0.SBRG.EC0 */\n\n        while (ACPI_IS_ROOT_PREFIX (*NextExternalChar))\n        {\n            NextExternalChar++;\n        }\n    }\n    else\n    {\n        /* Handle Carat prefixes */\n\n        while (ACPI_IS_PARENT_PREFIX (*NextExternalChar))\n        {\n            Info->NumCarats++;\n            NextExternalChar++;\n        }\n    }\n\n    /*\n     * Determine the number of ACPI name \"segments\" by counting the number of\n     * path separators within the string. Start with one segment since the\n     * segment count is [(# separators) + 1], and zero separators is ok.\n     */\n    if (*NextExternalChar)\n    {\n        Info->NumSegments = 1;\n        for (i = 0; NextExternalChar[i]; i++)\n        {\n            if (ACPI_IS_PATH_SEPARATOR (NextExternalChar[i]))\n            {\n                Info->NumSegments++;\n            }\n        }\n    }\n\n    Info->Length = (ACPI_NAME_SIZE * Info->NumSegments) +\n        4 + Info->NumCarats;\n\n    Info->NextExternalChar = NextExternalChar;\n}\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsBuildInternalName\n *\n * PARAMETERS:  Info            - Info struct fully initialized\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Construct the internal (AML) namestring\n *              corresponding to the external (ASL) namestring.\n *\n ******************************************************************************/\n\nACPI_STATUS\nAcpiNsBuildInternalName (\n    ACPI_NAMESTRING_INFO    *Info)\n{\n    UINT32                  NumSegments = Info->NumSegments;\n    char                    *InternalName = Info->InternalName;\n    const char              *ExternalName = Info->NextExternalChar;\n    char                    *Result = NULL;\n    UINT32                  i;\n\n\n    ACPI_FUNCTION_TRACE (NsBuildInternalName);\n\n\n    /* Setup the correct prefixes, counts, and pointers */\n\n    if (Info->FullyQualified)\n    {\n        InternalName[0] = AML_ROOT_PREFIX;\n\n        if (NumSegments <= 1)\n        {\n            Result = &InternalName[1];\n        }\n        else if (NumSegments == 2)\n        {\n            InternalName[1] = AML_DUAL_NAME_PREFIX;\n            Result = &InternalName[2];\n        }\n        else\n        {\n            InternalName[1] = AML_MULTI_NAME_PREFIX_OP;\n            InternalName[2] = (char) NumSegments;\n            Result = &InternalName[3];\n        }\n    }\n    else\n    {\n        /*\n         * Not fully qualified.\n         * Handle Carats first, then append the name segments\n         */\n        i = 0;\n        if (Info->NumCarats)\n        {\n            for (i = 0; i < Info->NumCarats; i++)\n            {\n                InternalName[i] = AML_PARENT_PREFIX;\n            }\n        }\n\n        if (NumSegments <= 1)\n        {\n            Result = &InternalName[i];\n        }\n        else if (NumSegments == 2)\n        {\n            InternalName[i] = AML_DUAL_NAME_PREFIX;\n            Result = &InternalName[(ACPI_SIZE) i+1];\n        }\n        else\n        {\n            InternalName[i] = AML_MULTI_NAME_PREFIX_OP;\n            InternalName[(ACPI_SIZE) i+1] = (char) NumSegments;\n            Result = &InternalName[(ACPI_SIZE) i+2];\n        }\n    }\n\n    /* Build the name (minus path separators) */\n\n    for (; NumSegments; NumSegments--)\n    {\n        for (i = 0; i < ACPI_NAME_SIZE; i++)\n        {\n            if (ACPI_IS_PATH_SEPARATOR (*ExternalName) ||\n               (*ExternalName == 0))\n            {\n                /* Pad the segment with underscore(s) if segment is short */\n\n                Result[i] = '_';\n            }\n            else\n            {\n                /* Convert the character to uppercase and save it */\n\n                Result[i] = (char) toupper ((int) *ExternalName);\n                ExternalName++;\n            }\n        }\n\n        /* Now we must have a path separator, or the pathname is bad */\n\n        if (!ACPI_IS_PATH_SEPARATOR (*ExternalName) &&\n            (*ExternalName != 0))\n        {\n            return_ACPI_STATUS (AE_BAD_PATHNAME);\n        }\n\n        /* Move on the next segment */\n\n        ExternalName++;\n        Result += ACPI_NAME_SIZE;\n    }\n\n    /* Terminate the string */\n\n    *Result = 0;\n\n    if (Info->FullyQualified)\n    {\n        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, \"Returning [%p] (abs) \\\"\\\\%s\\\"\\n\",\n            InternalName, InternalName));\n    }\n    else\n    {\n        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, \"Returning [%p] (rel) \\\"%s\\\"\\n\",\n            InternalName, InternalName));\n    }\n\n    return_ACPI_STATUS (AE_OK);\n}\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsInternalizeName\n *\n * PARAMETERS:  *ExternalName           - External representation of name\n *              **Converted Name        - Where to return the resulting\n *                                        internal represention of the name\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Convert an external representation (e.g. \"\\_PR_.CPU0\")\n *              to internal form (e.g. 5c 2f 02 5f 50 52 5f 43 50 55 30)\n *\n *******************************************************************************/\n\nACPI_STATUS\nAcpiNsInternalizeName (\n    const char              *ExternalName,\n    char                    **ConvertedName)\n{\n    char                    *InternalName;\n    ACPI_NAMESTRING_INFO    Info;\n    ACPI_STATUS             Status;\n\n\n    ACPI_FUNCTION_TRACE (NsInternalizeName);\n\n\n    if ((!ExternalName)      ||\n        (*ExternalName == 0) ||\n        (!ConvertedName))\n    {\n        return_ACPI_STATUS (AE_BAD_PARAMETER);\n    }\n\n    /* Get the length of the new internal name */\n\n    Info.ExternalName = ExternalName;\n    AcpiNsGetInternalNameLength (&Info);\n\n    /* We need a segment to store the internal  name */\n\n    InternalName = ACPI_ALLOCATE_ZEROED (Info.Length);\n    if (!InternalName)\n    {\n        return_ACPI_STATUS (AE_NO_MEMORY);\n    }\n\n    /* Build the name */\n\n    Info.InternalName = InternalName;\n    Status = AcpiNsBuildInternalName (&Info);\n    if (ACPI_FAILURE (Status))\n    {\n        ACPI_FREE (InternalName);\n        return_ACPI_STATUS (Status);\n    }\n\n    *ConvertedName = InternalName;\n    return_ACPI_STATUS (AE_OK);\n}\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsExternalizeName\n *\n * PARAMETERS:  InternalNameLength  - Lenth of the internal name below\n *              InternalName        - Internal representation of name\n *              ConvertedNameLength - Where the length is returned\n *              ConvertedName       - Where the resulting external name\n *                                    is returned\n *\n * RETURN:      Status\n *\n * DESCRIPTION: Convert internal name (e.g. 5c 2f 02 5f 50 52 5f 43 50 55 30)\n *              to its external (printable) form (e.g. \"\\_PR_.CPU0\")\n *\n ******************************************************************************/\n\nACPI_STATUS\nAcpiNsExternalizeName (\n    UINT32                  InternalNameLength,\n    const char              *InternalName,\n    UINT32                  *ConvertedNameLength,\n    char                    **ConvertedName)\n{\n    UINT32                  NamesIndex = 0;\n    UINT32                  NumSegments = 0;\n    UINT32                  RequiredLength;\n    UINT32                  PrefixLength = 0;\n    UINT32                  i = 0;\n    UINT32                  j = 0;\n\n\n    ACPI_FUNCTION_TRACE (NsExternalizeName);\n\n\n    if (!InternalNameLength     ||\n        !InternalName           ||\n        !ConvertedName)\n    {\n        return_ACPI_STATUS (AE_BAD_PARAMETER);\n    }\n\n    /* Check for a prefix (one '\\' | one or more '^') */\n\n    switch (InternalName[0])\n    {\n    case AML_ROOT_PREFIX:\n\n        PrefixLength = 1;\n        break;\n\n    case AML_PARENT_PREFIX:\n\n        for (i = 0; i < InternalNameLength; i++)\n        {\n            if (ACPI_IS_PARENT_PREFIX (InternalName[i]))\n            {\n                PrefixLength = i + 1;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        if (i == InternalNameLength)\n        {\n            PrefixLength = i;\n        }\n\n        break;\n\n    default:\n\n        break;\n    }\n\n    /*\n     * Check for object names. Note that there could be 0-255 of these\n     * 4-byte elements.\n     */\n    if (PrefixLength < InternalNameLength)\n    {\n        switch (InternalName[PrefixLength])\n        {\n        case AML_MULTI_NAME_PREFIX_OP:\n\n            /* <count> 4-byte names */\n\n            NamesIndex = PrefixLength + 2;\n            NumSegments = (UINT8)\n                InternalName[(ACPI_SIZE) PrefixLength + 1];\n            break;\n\n        case AML_DUAL_NAME_PREFIX:\n\n            /* Two 4-byte names */\n\n            NamesIndex = PrefixLength + 1;\n            NumSegments = 2;\n            break;\n\n        case 0:\n\n            /* NullName */\n\n            NamesIndex = 0;\n            NumSegments = 0;\n            break;\n\n        default:\n\n            /* one 4-byte name */\n\n            NamesIndex = PrefixLength;\n            NumSegments = 1;\n            break;\n        }\n    }\n\n    /*\n     * Calculate the length of ConvertedName, which equals the length\n     * of the prefix, length of all object names, length of any required\n     * punctuation ('.') between object names, plus the NULL terminator.\n     */\n    RequiredLength = PrefixLength + (4 * NumSegments) +\n        ((NumSegments > 0) ? (NumSegments - 1) : 0) + 1;\n\n    /*\n     * Check to see if we're still in bounds. If not, there's a problem\n     * with InternalName (invalid format).\n     */\n    if (RequiredLength > InternalNameLength)\n    {\n        ACPI_ERROR ((AE_INFO, \"Invalid internal name\"));\n        return_ACPI_STATUS (AE_BAD_PATHNAME);\n    }\n\n    /* Build the ConvertedName */\n\n    *ConvertedName = ACPI_ALLOCATE_ZEROED (RequiredLength);\n    if (!(*ConvertedName))\n    {\n        return_ACPI_STATUS (AE_NO_MEMORY);\n    }\n\n    j = 0;\n\n    for (i = 0; i < PrefixLength; i++)\n    {\n        (*ConvertedName)[j++] = InternalName[i];\n    }\n\n    if (NumSegments > 0)\n    {\n        for (i = 0; i < NumSegments; i++)\n        {\n            if (i > 0)\n            {\n                (*ConvertedName)[j++] = '.';\n            }\n\n            /* Copy and validate the 4-char name segment */\n\n            ACPI_MOVE_NAME (&(*ConvertedName)[j],\n                &InternalName[NamesIndex]);\n            AcpiUtRepairName (&(*ConvertedName)[j]);\n\n            j += ACPI_NAME_SIZE;\n            NamesIndex += ACPI_NAME_SIZE;\n        }\n    }\n\n    if (ConvertedNameLength)\n    {\n        *ConvertedNameLength = (UINT32) RequiredLength;\n    }\n\n    return_ACPI_STATUS (AE_OK);\n}\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsValidateHandle\n *\n * PARAMETERS:  Handle          - Handle to be validated and typecast to a\n *                                namespace node.\n *\n * RETURN:      A pointer to a namespace node\n *\n * DESCRIPTION: Convert a namespace handle to a namespace node. Handles special\n *              cases for the root node.\n *\n * NOTE: Real integer handles would allow for more verification\n *       and keep all pointers within this subsystem - however this introduces\n *       more overhead and has not been necessary to this point. Drivers\n *       holding handles are typically notified before a node becomes invalid\n *       due to a table unload.\n *\n ******************************************************************************/\n\nACPI_NAMESPACE_NODE *\nAcpiNsValidateHandle (\n    ACPI_HANDLE             Handle)\n{\n\n    ACPI_FUNCTION_ENTRY ();\n\n\n    /* Parameter validation */\n\n    if ((!Handle) || (Handle == ACPI_ROOT_OBJECT))\n    {\n        return (AcpiGbl_RootNode);\n    }\n\n    /* We can at least attempt to verify the handle */\n\n    if (ACPI_GET_DESCRIPTOR_TYPE (Handle) != ACPI_DESC_TYPE_NAMED)\n    {\n        return (NULL);\n    }\n\n    return (ACPI_CAST_PTR (ACPI_NAMESPACE_NODE, Handle));\n}\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsTerminate\n *\n * PARAMETERS:  none\n *\n * RETURN:      none\n *\n * DESCRIPTION: free memory allocated for namespace and ACPI table storage.\n *\n ******************************************************************************/\n\nvoid\nAcpiNsTerminate (\n    void)\n{\n    ACPI_STATUS             Status;\n    ACPI_OPERAND_OBJECT     *Prev;\n    ACPI_OPERAND_OBJECT     *Next;\n\n\n    ACPI_FUNCTION_TRACE (NsTerminate);\n\n\n    /* Delete any module-level code blocks */\n\n    Next = AcpiGbl_ModuleCodeList;\n    while (Next)\n    {\n        Prev = Next;\n        Next = Next->Method.Mutex;\n        Prev->Method.Mutex = NULL; /* Clear the Mutex (cheated) field */\n        AcpiUtRemoveReference (Prev);\n    }\n\n    /*\n     * Free the entire namespace -- all nodes and all objects\n     * attached to the nodes\n     */\n    AcpiNsDeleteNamespaceSubtree (AcpiGbl_RootNode);\n\n    /* Delete any objects attached to the root node */\n\n    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);\n    if (ACPI_FAILURE (Status))\n    {\n        return_VOID;\n    }\n\n    AcpiNsDeleteNode (AcpiGbl_RootNode);\n    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);\n\n    ACPI_DEBUG_PRINT ((ACPI_DB_INFO, \"Namespace freed\\n\"));\n    return_VOID;\n}\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsOpensScope\n *\n * PARAMETERS:  Type        - A valid namespace type\n *\n * RETURN:      NEWSCOPE if the passed type \"opens a name scope\" according\n *              to the ACPI specification, else 0\n *\n ******************************************************************************/\n\nUINT32\nAcpiNsOpensScope (\n    ACPI_OBJECT_TYPE        Type)\n{\n    ACPI_FUNCTION_ENTRY ();\n\n\n    if (Type > ACPI_TYPE_LOCAL_MAX)\n    {\n        /* type code out of range  */\n\n        ACPI_WARNING ((AE_INFO, \"Invalid Object Type 0x%X\", Type));\n        return (ACPI_NS_NORMAL);\n    }\n\n    return (((UINT32) AcpiGbl_NsProperties[Type]) & ACPI_NS_NEWSCOPE);\n}\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsGetNodeUnlocked\n *\n * PARAMETERS:  *Pathname   - Name to be found, in external (ASL) format. The\n *                            \\ (backslash) and ^ (carat) prefixes, and the\n *                            . (period) to separate segments are supported.\n *              PrefixNode   - Root of subtree to be searched, or NS_ALL for the\n *                            root of the name space. If Name is fully\n *                            qualified (first INT8 is '\\'), the passed value\n *                            of Scope will not be accessed.\n *              Flags       - Used to indicate whether to perform upsearch or\n *                            not.\n *              ReturnNode  - Where the Node is returned\n *\n * DESCRIPTION: Look up a name relative to a given scope and return the\n *              corresponding Node. NOTE: Scope can be null.\n *\n * MUTEX:       Doesn't locks namespace\n *\n ******************************************************************************/\n\nACPI_STATUS\nAcpiNsGetNodeUnlocked (\n    ACPI_NAMESPACE_NODE     *PrefixNode,\n    const char              *Pathname,\n    UINT32                  Flags,\n    ACPI_NAMESPACE_NODE     **ReturnNode)\n{\n    ACPI_GENERIC_STATE      ScopeInfo;\n    ACPI_STATUS             Status;\n    char                    *InternalPath;\n\n\n    ACPI_FUNCTION_TRACE_PTR (NsGetNodeUnlocked, ACPI_CAST_PTR (char, Pathname));\n\n\n    /* Simplest case is a null pathname */\n\n    if (!Pathname)\n    {\n        *ReturnNode = PrefixNode;\n        if (!PrefixNode)\n        {\n            *ReturnNode = AcpiGbl_RootNode;\n        }\n\n        return_ACPI_STATUS (AE_OK);\n    }\n\n    /* Quick check for a reference to the root */\n\n    if (ACPI_IS_ROOT_PREFIX (Pathname[0]) && (!Pathname[1]))\n    {\n        *ReturnNode = AcpiGbl_RootNode;\n        return_ACPI_STATUS (AE_OK);\n    }\n\n    /* Convert path to internal representation */\n\n    Status = AcpiNsInternalizeName (Pathname, &InternalPath);\n    if (ACPI_FAILURE (Status))\n    {\n        return_ACPI_STATUS (Status);\n    }\n\n    /* Setup lookup scope (search starting point) */\n\n    ScopeInfo.Scope.Node = PrefixNode;\n\n    /* Lookup the name in the namespace */\n\n    Status = AcpiNsLookup (&ScopeInfo, InternalPath, ACPI_TYPE_ANY,\n        ACPI_IMODE_EXECUTE, (Flags | ACPI_NS_DONT_OPEN_SCOPE),\n        NULL, ReturnNode);\n    if (ACPI_FAILURE (Status))\n    {\n        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, \"%s, %s\\n\",\n            Pathname, AcpiFormatException (Status)));\n    }\n\n    ACPI_FREE (InternalPath);\n    return_ACPI_STATUS (Status);\n}\n\n\n/*******************************************************************************\n *\n * FUNCTION:    AcpiNsGetNode\n *\n * PARAMETERS:  *Pathname   - Name to be found, in external (ASL) format. The\n *                            \\ (backslash) and ^ (carat) prefixes, and the\n *                            . (period) to separate segments are supported.\n *              PrefixNode   - Root of subtree to be searched, or NS_ALL for the\n *                            root of the name space. If Name is fully\n *                            qualified (first INT8 is '\\'), the passed value\n *                            of Scope will not be accessed.\n *              Flags       - Used to indicate whether to perform upsearch or\n *                            not.\n *              ReturnNode  - Where the Node is returned\n *\n * DESCRIPTION: Look up a name relative to a given scope and return the\n *              corresponding Node. NOTE: Scope can be null.\n *\n * MUTEX:       Locks namespace\n *\n ******************************************************************************/\n\nACPI_STATUS\nAcpiNsGetNode (\n    ACPI_NAMESPACE_NODE     *PrefixNode,\n    const char              *Pathname,\n    UINT32                  Flags,\n    ACPI_NAMESPACE_NODE     **ReturnNode)\n{\n    ACPI_STATUS             Status;\n\n\n    ACPI_FUNCTION_TRACE_PTR (NsGetNode, ACPI_CAST_PTR (char, Pathname));\n\n\n    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);\n    if (ACPI_FAILURE (Status))\n    {\n        return_ACPI_STATUS (Status);\n    }\n\n    Status = AcpiNsGetNodeUnlocked (PrefixNode, Pathname,\n        Flags, ReturnNode);\n\n    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);\n    return_ACPI_STATUS (Status);\n}\n"], "filenames": ["source/components/namespace/nsutils.c"], "buggy_code_start_loc": [768], "buggy_code_end_loc": [791], "fixing_code_start_loc": [769], "fixing_code_end_loc": [786], "type": "CWE-755", "message": "The acpi_ns_terminate() function in drivers/acpi/acpica/nsutils.c in the Linux kernel before 4.12 does not flush the operand cache and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.", "other": {"cve": {"id": "CVE-2017-11472", "sourceIdentifier": "cve@mitre.org", "published": "2017-07-20T04:29:00.283", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The acpi_ns_terminate() function in drivers/acpi/acpica/nsutils.c in the Linux kernel before 4.12 does not flush the operand cache and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table."}, {"lang": "es", "value": "La funci\u00f3n acpi_ns_terminate() en el archivo drivers/acpi/acpica/nsutils.c en el kernel de Linux anterior a versi\u00f3n 4.12, no limpia la cach\u00e9 operand y causa un volcado de pila del kernel, que permite a los usuarios locales obtener informaci\u00f3n confidencial de la memoria del kernel y omitir el mecanismo de protecci\u00f3n KASLR (en el kernel hasta versi\u00f3n 4.9) por medio de una tabla ACPI creada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.11.9", "matchCriteriaId": "F52D90B6-7027-46F8-9696-3783E7F7A0B7"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=3b2d69114fefa474fca542e51119036dceb4aa6f", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/acpica/acpica/commit/a23325b2e583556eae88ed3f764e457786bf4df6", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/3b2d69114fefa474fca542e51119036dceb4aa6f", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3619-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3619-2/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3754-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/acpica/acpica/commit/a23325b2e583556eae88ed3f764e457786bf4df6"}}