{"buggy_code": ["import { getAssociatedTokenAddress } from '@solana/spl-token';\nimport {\n    ConfirmedTransactionMeta,\n    Connection,\n    Finality,\n    LAMPORTS_PER_SOL,\n    Message,\n    TransactionResponse,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport BigNumber from 'bignumber.js';\nimport { Amount, Memo, Recipient, References, SPLToken } from './types';\n\n/**\n * Thrown when a transaction doesn't contain a valid Solana Pay transfer.\n */\nexport class ValidateTransferError extends Error {\n    name = 'ValidateTransferError';\n}\n\n/**\n * Fields of a Solana Pay transfer request to validate.\n */\nexport interface ValidateTransferFields {\n    /** `recipient` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#recipient). */\n    recipient: Recipient;\n    /** `amount` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#amount). */\n    amount: Amount;\n    /** `spl-token` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#spl-token). */\n    splToken?: SPLToken;\n    /** `reference` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#reference). */\n    reference?: References;\n    /** `memo` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#memo). */\n    memo?: Memo;\n}\n\n/**\n * Check that a given transaction contains a valid Solana Pay transfer.\n *\n * @param connection - A connection to the cluster.\n * @param signature - The signature of the transaction to validate.\n * @param fields - Fields of a Solana Pay transfer request to validate.\n * @param options - Options for `getTransaction`.\n *\n * @throws {ValidateTransferError}\n */\nexport async function validateTransfer(\n    connection: Connection,\n    signature: TransactionSignature,\n    { recipient, amount, splToken, reference, memo }: ValidateTransferFields,\n    options?: { commitment?: Finality }\n): Promise<TransactionResponse> {\n    const response = await connection.getTransaction(signature, options);\n    if (!response) throw new ValidateTransferError('not found');\n\n    const message = response.transaction.message;\n    const meta = response.meta;\n    if (!meta) throw new ValidateTransferError('missing meta');\n    if (meta.err) throw meta.err;\n\n    const [preAmount, postAmount] = splToken\n        ? await validateSPLTokenTransfer(message, meta, recipient, splToken)\n        : await validateSystemTransfer(message, meta, recipient);\n\n    if (postAmount.minus(preAmount).lt(amount)) throw new ValidateTransferError('amount not transferred');\n\n    if (reference) {\n        if (!Array.isArray(reference)) {\n            reference = [reference];\n        }\n\n        for (const pubkey of reference) {\n            if (!message.accountKeys.some((accountKey) => accountKey.equals(pubkey)))\n                throw new ValidateTransferError('reference not found');\n        }\n    }\n\n    // FIXME: add memo check\n\n    return response;\n}\n\nasync function validateSystemTransfer(\n    message: Message,\n    meta: ConfirmedTransactionMeta,\n    recipient: Recipient\n): Promise<[BigNumber, BigNumber]> {\n    const accountIndex = message.accountKeys.findIndex((pubkey) => pubkey.equals(recipient));\n    if (accountIndex === -1) throw new ValidateTransferError('recipient not found');\n\n    return [\n        new BigNumber(meta.preBalances[accountIndex] || 0).div(LAMPORTS_PER_SOL),\n        new BigNumber(meta.postBalances[accountIndex] || 0).div(LAMPORTS_PER_SOL),\n    ];\n}\n\nasync function validateSPLTokenTransfer(\n    message: Message,\n    meta: ConfirmedTransactionMeta,\n    recipient: Recipient,\n    splToken: SPLToken\n): Promise<[BigNumber, BigNumber]> {\n    const recipientATA = await getAssociatedTokenAddress(splToken, recipient);\n    const accountIndex = message.accountKeys.findIndex((pubkey) => pubkey.equals(recipientATA));\n    if (accountIndex === -1) throw new ValidateTransferError('recipient not found');\n\n    const preBalance = meta.preTokenBalances?.find((x) => x.accountIndex === accountIndex);\n    const postBalance = meta.postTokenBalances?.find((x) => x.accountIndex === accountIndex);\n\n    return [\n        new BigNumber(preBalance?.uiTokenAmount.uiAmountString || 0),\n        new BigNumber(postBalance?.uiTokenAmount.uiAmountString || 0),\n    ];\n}\n"], "fixing_code": ["import {\n    decodeInstruction,\n    getAssociatedTokenAddress,\n    isTransferCheckedInstruction,\n    isTransferInstruction,\n} from '@solana/spl-token';\nimport {\n    ConfirmedTransactionMeta,\n    Connection,\n    Finality,\n    LAMPORTS_PER_SOL,\n    Message,\n    SystemInstruction,\n    Transaction,\n    TransactionResponse,\n    TransactionSignature,\n} from '@solana/web3.js';\nimport BigNumber from 'bignumber.js';\nimport { MEMO_PROGRAM_ID } from './constants';\nimport { Amount, Memo, Recipient, Reference, References, SPLToken } from './types';\n\n/**\n * Thrown when a transaction doesn't contain a valid Solana Pay transfer.\n */\nexport class ValidateTransferError extends Error {\n    name = 'ValidateTransferError';\n}\n\n/**\n * Fields of a Solana Pay transfer request to validate.\n */\nexport interface ValidateTransferFields {\n    /** `recipient` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#recipient). */\n    recipient: Recipient;\n    /** `amount` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#amount). */\n    amount: Amount;\n    /** `spl-token` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#spl-token). */\n    splToken?: SPLToken;\n    /** `reference` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#reference). */\n    reference?: References;\n    /** `memo` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#memo). */\n    memo?: Memo;\n}\n\n/**\n * Check that a given transaction contains a valid Solana Pay transfer.\n *\n * @param connection - A connection to the cluster.\n * @param signature - The signature of the transaction to validate.\n * @param fields - Fields of a Solana Pay transfer request to validate.\n * @param options - Options for `getTransaction`.\n *\n * @throws {ValidateTransferError}\n */\nexport async function validateTransfer(\n    connection: Connection,\n    signature: TransactionSignature,\n    { recipient, amount, splToken, reference, memo }: ValidateTransferFields,\n    options?: { commitment?: Finality }\n): Promise<TransactionResponse> {\n    const response = await connection.getTransaction(signature, options);\n    if (!response) throw new ValidateTransferError('not found');\n\n    const message = response.transaction.message;\n    const meta = response.meta;\n    if (!meta) throw new ValidateTransferError('missing meta');\n    if (meta.err) throw meta.err;\n\n    if (reference && !Array.isArray(reference)) {\n        reference = [reference];\n    }\n\n    const [preAmount, postAmount] = splToken\n        ? await validateSPLTokenTransfer(message, meta, recipient, splToken, reference)\n        : await validateSystemTransfer(message, meta, recipient, reference);\n    if (postAmount.minus(preAmount).lt(amount)) throw new ValidateTransferError('amount not transferred');\n\n    if (memo) {\n        // Check that the second instruction is a memo instruction with the expected memo.\n        const transaction = Transaction.populate(message);\n        const instruction = transaction.instructions[1];\n        if (!instruction) throw new ValidateTransferError('missing memo instruction');\n        if (!instruction.programId.equals(MEMO_PROGRAM_ID)) throw new ValidateTransferError('invalid memo program');\n        if (!instruction.data.equals(Buffer.from(memo, 'utf8'))) throw new ValidateTransferError('invalid memo');\n    }\n\n    return response;\n}\n\nasync function validateSystemTransfer(\n    message: Message,\n    meta: ConfirmedTransactionMeta,\n    recipient: Recipient,\n    references?: Reference[]\n): Promise<[BigNumber, BigNumber]> {\n    if (references) {\n        // Check that the first instruction is a system transfer instruction.\n        const transaction = Transaction.populate(message);\n        const instruction = transaction.instructions[0];\n        SystemInstruction.decodeTransfer(instruction);\n\n        // Check that the expected reference keys exactly match the extra keys provided to the instruction.\n        const [_from, _to, ...extraKeys] = instruction.keys;\n        const length = extraKeys.length;\n        if (length !== references.length) throw new ValidateTransferError('invalid references');\n\n        for (let i = 0; i < length; i++) {\n            if (!extraKeys[i].pubkey.equals(references[i])) throw new ValidateTransferError(`invalid reference ${i}`);\n        }\n    }\n\n    const accountIndex = message.accountKeys.findIndex((pubkey) => pubkey.equals(recipient));\n    if (accountIndex === -1) throw new ValidateTransferError('recipient not found');\n\n    return [\n        new BigNumber(meta.preBalances[accountIndex] || 0).div(LAMPORTS_PER_SOL),\n        new BigNumber(meta.postBalances[accountIndex] || 0).div(LAMPORTS_PER_SOL),\n    ];\n}\n\nasync function validateSPLTokenTransfer(\n    message: Message,\n    meta: ConfirmedTransactionMeta,\n    recipient: Recipient,\n    splToken: SPLToken,\n    references?: Reference[]\n): Promise<[BigNumber, BigNumber]> {\n    if (references) {\n        // Check that the first instruction is an SPL token transfer instruction.\n        const transaction = Transaction.populate(message);\n        const instruction = decodeInstruction(transaction.instructions[0]);\n        if (!isTransferCheckedInstruction(instruction) && !isTransferInstruction(instruction))\n            throw new ValidateTransferError('invalid transfer');\n\n        // Check that the expected reference keys exactly match the extra keys provided to the instruction.\n        const extraKeys = instruction.keys.multiSigners;\n        const length = extraKeys.length;\n        if (length !== references.length) throw new ValidateTransferError('invalid references');\n\n        for (let i = 0; i < length; i++) {\n            if (!extraKeys[i].pubkey.equals(references[i])) throw new ValidateTransferError(`invalid reference ${i}`);\n        }\n    }\n\n    const recipientATA = await getAssociatedTokenAddress(splToken, recipient);\n    const accountIndex = message.accountKeys.findIndex((pubkey) => pubkey.equals(recipientATA));\n    if (accountIndex === -1) throw new ValidateTransferError('recipient not found');\n\n    const preBalance = meta.preTokenBalances?.find((x) => x.accountIndex === accountIndex);\n    const postBalance = meta.postTokenBalances?.find((x) => x.accountIndex === accountIndex);\n\n    return [\n        new BigNumber(preBalance?.uiTokenAmount.uiAmountString || 0),\n        new BigNumber(postBalance?.uiTokenAmount.uiAmountString || 0),\n    ];\n}\n"], "filenames": ["core/src/validateTransfer.ts"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [102], "fixing_code_start_loc": [1], "fixing_code_end_loc": [145], "type": "CWE-670", "message": "Solana Pay is a protocol and set of reference implementations that enable developers to incorporate decentralized payments into their apps and services. When a Solana Pay transaction is located using a reference key, it may be checked to represent a transfer of the desired amount to the recipient, using the supplied `validateTransfer` function. An edge case regarding this mechanism could cause the validation logic to validate multiple transfers. This issue has been patched as of version `0.2.1`. Users of the Solana Pay SDK should upgrade to it. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-35917", "sourceIdentifier": "security-advisories@github.com", "published": "2022-08-01T22:15:10.157", "lastModified": "2023-05-16T11:00:41.427", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Solana Pay is a protocol and set of reference implementations that enable developers to incorporate decentralized payments into their apps and services. When a Solana Pay transaction is located using a reference key, it may be checked to represent a transfer of the desired amount to the recipient, using the supplied `validateTransfer` function. An edge case regarding this mechanism could cause the validation logic to validate multiple transfers. This issue has been patched as of version `0.2.1`. Users of the Solana Pay SDK should upgrade to it. There are no known workarounds for this issue."}, {"lang": "es", "value": "Solana Pay es un protocolo y un conjunto de implementaciones de referencia que permiten a desarrolladores incorporar pagos descentralizados en sus aplicaciones y servicios. Cuando es localizada una transacci\u00f3n de Solana Pay usando una clave de referencia, puede comprobarse que representa una transferencia del importe deseado al destinatario, usando la funci\u00f3n suministrada \"validateTransfer\". Un caso de borde en relaci\u00f3n con este mecanismo podr\u00eda causar a la l\u00f3gica de comprobaci\u00f3n, comprobar m\u00faltiples transferencias. Este problema ha sido corregido a partir de la versi\u00f3n \"0.2.1\". Los usuarios del SDK de Solana Pay deber\u00edan actualizarlo. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-670"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:solanalabs:pay:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.2.1", "matchCriteriaId": "BA0D8FFF-0C7B-45CE-B3FD-FF53A6147F8B"}]}]}], "references": [{"url": "https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#reference", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/solana-labs/solana-pay/blob/master/core/src/validateTransfer.ts", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/solana-labs/solana-pay/commit/ac6ce0d0a81137700874a8bf5a7caac3be999fad", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/solana-labs/solana-pay/security/advisories/GHSA-j47c-j42c-mwqq", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/solana-labs/solana-pay/commit/ac6ce0d0a81137700874a8bf5a7caac3be999fad"}}