{"buggy_code": ["<?php\r\n\t/**\r\n\t * upload.php\r\n\t *\r\n\t * Copyright 2009, Moxiecode Systems AB\r\n\t * Released under GPL License.\r\n\t *\r\n\t * License: http://www.plupload.com/license\r\n\t * Contributing: http://www.plupload.com/contributing\r\n\t */\r\n\r\n// HTTP headers for no cache etc\r\n\r\n\t$_E107['no_online'] = true;\r\n\tdefine('e_MINIMAL', true);\r\n\tdefine('FLOODPROTECT', false);\r\n\trequire_once(\"../../../class2.php\");\r\n\r\n\tif(!ADMIN)\r\n\t{\r\n\t\texit;\r\n\t}\r\n\r\n\theader(\"Expires: Mon, 26 Jul 1997 05:00:00 GMT\");\r\n\theader(\"Last-Modified: \" . gmdate(\"D, d M Y H:i:s\") . \" GMT\");\r\n\theader(\"Cache-Control: no-store, no-cache, must-revalidate\");\r\n\theader(\"Cache-Control: post-check=0, pre-check=0\", false);\r\n\theader(\"Pragma: no-cache\");\r\n\r\n// Settings\r\n// $targetDir = ini_get(\"upload_tmp_dir\") . DIRECTORY_SEPARATOR . \"plupload\";\r\n\t$targetDir = e_IMPORT;\r\n//$targetDir = 'uploads';\r\n\r\n\t$cleanupTargetDir = true; // Remove old files\r\n\t$maxFileAge = 5 * 3600; // Temp file age in seconds\r\n\r\n// 5 minutes execution time\r\n\t@set_time_limit(5 * 60);\r\n\r\n// Uncomment this one to fake upload time\r\n// usleep(5000);\r\n\r\n// Get parameters\r\n\t$chunk = isset($_REQUEST[\"chunk\"]) ? intval($_REQUEST[\"chunk\"]) : 0;\r\n\t$chunks = isset($_REQUEST[\"chunks\"]) ? intval($_REQUEST[\"chunks\"]) : 0;\r\n\t$fileName = isset($_REQUEST[\"name\"]) ? $_REQUEST[\"name\"] : '';\r\n\r\n\r\n\r\n// Clean the fileName for security reasons\r\n\t$fileName = preg_replace('/[^\\w\\._]+/', '_', $fileName);\r\n\r\n\t$fileName= 'hello.jpg';\r\n\r\n\tif(!empty($_FILES['file']['name'])) // dropzone support v2.1.9\r\n\t{\r\n\t\t$fileName = $_FILES['file']['name'];\r\n\t}\r\n\r\n// Make sure the fileName is unique but only if chunking is disabled\r\n\tif($chunks < 2 && file_exists($targetDir . DIRECTORY_SEPARATOR . $fileName))\r\n\t{\r\n\t\t$ext = strrpos($fileName, '.');\r\n\t\t$fileName_a = substr($fileName, 0, $ext);\r\n\t\t$fileName_b = substr($fileName, $ext);\r\n\r\n\t\t$count = 1;\r\n\t\twhile(file_exists($targetDir . DIRECTORY_SEPARATOR . $fileName_a . '_' . $count . $fileName_b))\r\n\t\t{\r\n\t\t\t$count++;\r\n\t\t}\r\n\r\n\t\t$fileName = $fileName_a . '_' . $count . $fileName_b;\r\n\t}\r\n\r\n\t$filePath = $targetDir . DIRECTORY_SEPARATOR . $fileName;\r\n\r\n// Create target dir\r\n\tif(!file_exists($targetDir))\r\n\t{\r\n\t\t@mkdir($targetDir);\r\n\t}\r\n\r\n// Remove old temp files\t\r\n\tif($cleanupTargetDir && is_dir($targetDir) && ($dir = opendir($targetDir)))\r\n\t{\r\n\t\twhile(($file = readdir($dir)) !== false)\r\n\t\t{\r\n\t\t\t$tmpfilePath = $targetDir . DIRECTORY_SEPARATOR . $file;\r\n\r\n\t\t\t// Remove temp file if it is older than the max age and is not the current file\r\n\t\t\tif(preg_match('/\\.part$/', $file) && (filemtime($tmpfilePath) < time() - $maxFileAge) && ($tmpfilePath != \"{$filePath}.part\"))\r\n\t\t\t{\r\n\t\t\t\t@unlink($tmpfilePath);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tclosedir($dir);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tdie('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 100, \"message\": \"Failed to open temp directory.\"}, \"id\" : \"id\"}');\r\n\t}\r\n\r\n\r\n// Look for the content type header\r\n\tif(isset($_SERVER[\"HTTP_CONTENT_TYPE\"]))\r\n\t{\r\n\t\t$contentType = $_SERVER[\"HTTP_CONTENT_TYPE\"];\r\n\t}\r\n\r\n\tif(isset($_SERVER[\"CONTENT_TYPE\"]))\r\n\t{\r\n\t\t$contentType = $_SERVER[\"CONTENT_TYPE\"];\r\n\t}\r\n\r\n// Handle non multipart uploads older WebKit versions didn't support multipart in HTML5\r\n\tif(strpos($contentType, \"multipart\") !== false)\r\n\t{\r\n\t\tif(isset($_FILES['file']['tmp_name']) && is_uploaded_file($_FILES['file']['tmp_name']))\r\n\t\t{\r\n\t\t\t// Open temp file\r\n\t\t\t$out = fopen(\"{$filePath}.part\", $chunk == 0 ? \"wb\" : \"ab\");\r\n\r\n\t\t\tif($out)\r\n\t\t\t{\r\n\t\t\t\t// Read binary input stream and append it to temp file\r\n\t\t\t\t$tmpName = e107::getParser()->filter($_FILES['file']['tmp_name'],'str');\r\n\t\t\t\t$in = fopen($tmpName, \"rb\");\r\n\r\n\t\t\t\tif($in)\r\n\t\t\t\t{\r\n\t\t\t\t\twhile($buff = fread($in, 4096))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfwrite($out, $buff);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tdie('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 101, \"message\": \"Failed to open input stream.\"}, \"id\" : \"id\"}');\r\n\t\t\t\t}\r\n\t\t\t\tfclose($in);\r\n\t\t\t\tfclose($out);\r\n\t\t\t\t@unlink($tmpName);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tdie('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 102, \"message\": \"Failed to open output stream.\"}, \"id\" : \"id\"}');\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tdie('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 103, \"message\": \"Failed to move uploaded file. '.ini_get('upload_max_filesize').'\"}, \"id\" : \"id\"}');\r\n\t\t}\r\n\r\n\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Open temp file\r\n\t\t$out = fopen(\"{$filePath}.part\", $chunk == 0 ? \"wb\" : \"ab\");\r\n\t\tif($out)\r\n\t\t{\r\n\t\t\t// Read binary input stream and append it to temp file\r\n\t\t\t$in = fopen(\"php://input\", \"rb\");\r\n\r\n\t\t\tif($in)\r\n\t\t\t{\r\n\t\t\t\twhile($buff = fread($in, 4096))\r\n\t\t\t\t{\r\n\t\t\t\t\tfwrite($out, $buff);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tdie('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 101, \"message\": \"Failed to open input stream.\"}, \"id\" : \"id\"}');\r\n\t\t\t}\r\n\r\n\t\t\tfclose($in);\r\n\t\t\tfclose($out);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tdie('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 102, \"message\": \"Failed to open output stream.\"}, \"id\" : \"id\"}');\r\n\t\t}\r\n\t}\r\n\r\n// Check if file has been uploaded\r\n\tif(!$chunks || $chunk == $chunks - 1)\r\n\t{\r\n\t\t// Strip the temp .part suffix off\r\n\t\trename(\"{$filePath}.part\", $filePath);\r\n\t}\r\n\r\n\t$filePath = str_replace('//','/',$filePath); // cleanup .\r\n\r\n\t$convertToJpeg = e107::getPref('convert_to_jpeg', 0);\r\n\t$fileSize = filesize($filePath);\r\n\r\n\tif(varset($_GET['for']) !== '_icon' && !empty($convertToJpeg))\r\n\t{\r\n\t\tif($jpegFile = e107::getMedia()->convertImageToJpeg($filePath, true))\r\n\t\t{\r\n\t\t\t$filePath = $jpegFile;\r\n\t\t\t$fileName = basename($filePath);\r\n\t\t\t$fileSize = filesize($jpegFile);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif($_GET['for'] != '') // leave in upload directory if no category given.\r\n\t{\r\n\t\t$uploadPath = varset($_GET['path'],null);\r\n\t\t$result = e107::getMedia()->importFile($fileName, $_GET['for'], array('path'=>$uploadPath));\r\n\t}\r\n\r\n\r\n\t$log = e107::getParser()->filter($_GET,'str');\r\n\t$log['filepath'] = str_replace('../','',$filePath);\r\n\t$log['filename'] = $fileName;\r\n\t$log['filesize'] = $fileSize;\r\n\t$log['status'] = ($result) ? 'ok' : 'failed';\r\n\t$log['_files'] = $_FILES;\r\n//\t$log['_get'] = $_GET;\r\n//\t$log['_post'] = $_POST;\r\n\r\n\r\n\r\n\t\r\n\r\n\t$type = ($result) ? E_LOG_INFORMATIVE : E_LOG_WARNING;\r\n\r\n\te107::getLog()->add('LAN_AL_MEDIA_01', print_r($log, true), $type, 'MEDIA_01');\r\n\r\n\r\n\t$preview = e107::getMedia()->previewTag($result);\r\n\t$array = array(\"jsonrpc\" => \"2.0\", \"result\" => $result, \"id\" => \"id\", 'preview' => $preview, 'data'=>$_FILES );\r\n\r\n\techo json_encode($array);\r\n// Return JSON-RPC response\r\n// die('{\"jsonrpc\" : \"2.0\", \"result\" : null, \"id\" : \"id\"}');\r\n\r\n\r\n?>"], "fixing_code": ["<?php\r\n\t/**\r\n\t * upload.php\r\n\t *\r\n\t * Copyright 2009, Moxiecode Systems AB\r\n\t * Released under GPL License.\r\n\t *\r\n\t * License: http://www.plupload.com/license\r\n\t * Contributing: http://www.plupload.com/contributing\r\n\t */\r\n\r\n// HTTP headers for no cache etc\r\n\r\n\t$_E107['no_online'] = true;\r\n\tdefine('e_MINIMAL', true);\r\n\tdefine('FLOODPROTECT', false);\r\n\trequire_once(\"../../../class2.php\");\r\n\r\n\tif(!ADMIN)\r\n\t{\r\n\t\texit;\r\n\t}\r\n\r\n\theader(\"Expires: Mon, 26 Jul 1997 05:00:00 GMT\");\r\n\theader(\"Last-Modified: \" . gmdate(\"D, d M Y H:i:s\") . \" GMT\");\r\n\theader(\"Cache-Control: no-store, no-cache, must-revalidate\");\r\n\theader(\"Cache-Control: post-check=0, pre-check=0\", false);\r\n\theader(\"Pragma: no-cache\");\r\n\r\n// Settings\r\n// $targetDir = ini_get(\"upload_tmp_dir\") . DIRECTORY_SEPARATOR . \"plupload\";\r\n\t$targetDir = e_IMPORT;\r\n//$targetDir = 'uploads';\r\n\r\n\t$cleanupTargetDir = true; // Remove old files\r\n\t$maxFileAge = 5 * 3600; // Temp file age in seconds\r\n\r\n// 5 minutes execution time\r\n\t@set_time_limit(5 * 60);\r\n\r\n// Uncomment this one to fake upload time\r\n// usleep(5000);\r\n\r\n// Get parameters\r\n\t$chunk = isset($_REQUEST[\"chunk\"]) ? intval($_REQUEST[\"chunk\"]) : 0;\r\n\t$chunks = isset($_REQUEST[\"chunks\"]) ? intval($_REQUEST[\"chunks\"]) : 0;\r\n\t$fileName = isset($_REQUEST[\"name\"]) ? $_REQUEST[\"name\"] : '';\r\n\r\n// Clean the fileName for security reasons\r\n\t$fileName = preg_replace('/[^\\w\\._]+/', '_', $fileName);\r\n\r\n\tif(!empty($_FILES['file']['name'])) // dropzone support v2.1.9\r\n\t{\r\n\t\t$fileName = $_FILES['file']['name'];\r\n\t}\r\n\r\n// Make sure the fileName is unique but only if chunking is disabled\r\n\tif($chunks < 2 && file_exists($targetDir . DIRECTORY_SEPARATOR . $fileName))\r\n\t{\r\n\t\t$ext = strrpos($fileName, '.');\r\n\t\t$fileName_a = substr($fileName, 0, $ext);\r\n\t\t$fileName_b = substr($fileName, $ext);\r\n\r\n\t\t$count = 1;\r\n\t\twhile(file_exists($targetDir . DIRECTORY_SEPARATOR . $fileName_a . '_' . $count . $fileName_b))\r\n\t\t{\r\n\t\t\t$count++;\r\n\t\t}\r\n\r\n\t\t$fileName = $fileName_a . '_' . $count . $fileName_b;\r\n\t}\r\n\r\n\t$filePath = $targetDir . DIRECTORY_SEPARATOR . $fileName;\r\n\r\n// Create target dir\r\n\tif(!file_exists($targetDir))\r\n\t{\r\n\t\t@mkdir($targetDir);\r\n\t}\r\n\r\n// Remove old temp files\t\r\n\tif($cleanupTargetDir && is_dir($targetDir) && ($dir = opendir($targetDir)))\r\n\t{\r\n\t\twhile(($file = readdir($dir)) !== false)\r\n\t\t{\r\n\t\t\t$tmpfilePath = $targetDir . DIRECTORY_SEPARATOR . $file;\r\n\r\n\t\t\t// Remove temp file if it is older than the max age and is not the current file\r\n\t\t\tif(preg_match('/\\.part$/', $file) && (filemtime($tmpfilePath) < time() - $maxFileAge) && ($tmpfilePath != \"{$filePath}.part\"))\r\n\t\t\t{\r\n\t\t\t\t@unlink($tmpfilePath);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tclosedir($dir);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tdie('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 100, \"message\": \"Failed to open temp directory.\"}, \"id\" : \"id\"}');\r\n\t}\r\n\r\n\r\n// Look for the content type header\r\n\tif(isset($_SERVER[\"HTTP_CONTENT_TYPE\"]))\r\n\t{\r\n\t\t$contentType = $_SERVER[\"HTTP_CONTENT_TYPE\"];\r\n\t}\r\n\r\n\tif(isset($_SERVER[\"CONTENT_TYPE\"]))\r\n\t{\r\n\t\t$contentType = $_SERVER[\"CONTENT_TYPE\"];\r\n\t}\r\n\r\n// Handle non multipart uploads older WebKit versions didn't support multipart in HTML5\r\n\tif(strpos($contentType, \"multipart\") !== false)\r\n\t{\r\n\t\tif(isset($_FILES['file']['tmp_name']) && is_uploaded_file($_FILES['file']['tmp_name']))\r\n\t\t{\r\n\t\t\t// Open temp file\r\n\t\t\t$out = fopen(\"{$filePath}.part\", $chunk == 0 ? \"wb\" : \"ab\");\r\n\r\n\t\t\tif($out)\r\n\t\t\t{\r\n\t\t\t\t// Read binary input stream and append it to temp file\r\n\t\t\t\t$tmpName = e107::getParser()->filter($_FILES['file']['tmp_name'],'str');\r\n\t\t\t\t$in = fopen($tmpName, \"rb\");\r\n\r\n\t\t\t\tif($in)\r\n\t\t\t\t{\r\n\t\t\t\t\twhile($buff = fread($in, 4096))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfwrite($out, $buff);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tdie('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 101, \"message\": \"Failed to open input stream.\"}, \"id\" : \"id\"}');\r\n\t\t\t\t}\r\n\t\t\t\tfclose($in);\r\n\t\t\t\tfclose($out);\r\n\t\t\t\t@unlink($tmpName);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tdie('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 102, \"message\": \"Failed to open output stream.\"}, \"id\" : \"id\"}');\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tdie('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 103, \"message\": \"Failed to move uploaded file. '.ini_get('upload_max_filesize').'\"}, \"id\" : \"id\"}');\r\n\t\t}\r\n\r\n\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Open temp file\r\n\t\t$out = fopen(\"{$filePath}.part\", $chunk == 0 ? \"wb\" : \"ab\");\r\n\t\tif($out)\r\n\t\t{\r\n\t\t\t// Read binary input stream and append it to temp file\r\n\t\t\t$in = fopen(\"php://input\", \"rb\");\r\n\r\n\t\t\tif($in)\r\n\t\t\t{\r\n\t\t\t\twhile($buff = fread($in, 4096))\r\n\t\t\t\t{\r\n\t\t\t\t\tfwrite($out, $buff);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tdie('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 101, \"message\": \"Failed to open input stream.\"}, \"id\" : \"id\"}');\r\n\t\t\t}\r\n\r\n\t\t\tfclose($in);\r\n\t\t\tfclose($out);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tdie('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 102, \"message\": \"Failed to open output stream.\"}, \"id\" : \"id\"}');\r\n\t\t}\r\n\t}\r\n\r\n// Check if file has been uploaded\r\n\tif(!$chunks || $chunk == $chunks - 1)\r\n\t{\r\n\t\t// Strip the temp .part suffix off\r\n\t\trename(\"{$filePath}.part\", $filePath);\r\n\t}\r\n\r\n\t$filePath = str_replace('//','/',$filePath); // cleanup .\r\n\r\n\r\n\tif(e107::getFile()->isClean($filePath) !== true)\r\n\t{\r\n\t\t@unlink($filePath);\r\n\t\tdie('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 103, \"message\": \"Bad File Detected.\"}, \"id\" : \"id\"}');\r\n\t}\r\n\r\n\r\n\t$convertToJpeg = e107::getPref('convert_to_jpeg', 0);\r\n\t$fileSize = filesize($filePath);\r\n\r\n\tif(varset($_GET['for']) !== '_icon' && !empty($convertToJpeg))\r\n\t{\r\n\t\tif($jpegFile = e107::getMedia()->convertImageToJpeg($filePath, true))\r\n\t\t{\r\n\t\t\t$filePath = $jpegFile;\r\n\t\t\t$fileName = basename($filePath);\r\n\t\t\t$fileSize = filesize($jpegFile);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\r\n\r\n\tif($_GET['for'] != '') // leave in upload directory if no category given.\r\n\t{\r\n\t\t$uploadPath = varset($_GET['path'],null);\r\n\t\t$result = e107::getMedia()->importFile($fileName, $_GET['for'], array('path'=>$uploadPath));\r\n\t}\r\n\r\n\r\n\t$log = e107::getParser()->filter($_GET,'str');\r\n\t$log['filepath'] = str_replace('../','',$filePath);\r\n\t$log['filename'] = $fileName;\r\n\t$log['filesize'] = $fileSize;\r\n\t$log['status'] = ($result) ? 'ok' : 'failed';\r\n\t$log['_files'] = $_FILES;\r\n//\t$log['_get'] = $_GET;\r\n//\t$log['_post'] = $_POST;\r\n\r\n\r\n\r\n\t\r\n\r\n\t$type = ($result) ? E_LOG_INFORMATIVE : E_LOG_WARNING;\r\n\r\n\te107::getLog()->add('LAN_AL_MEDIA_01', print_r($log, true), $type, 'MEDIA_01');\r\n\r\n\r\n\t$preview = e107::getMedia()->previewTag($result);\r\n\t$array = array(\"jsonrpc\" => \"2.0\", \"result\" => $result, \"id\" => \"id\", 'preview' => $preview, 'data'=>$_FILES );\r\n\r\n\techo json_encode($array);\r\n// Return JSON-RPC response\r\n// die('{\"jsonrpc\" : \"2.0\", \"result\" : null, \"id\" : \"id\"}');\r\n\r\n\r\n?>"], "filenames": ["e107_web/js/plupload/upload.php"], "buggy_code_start_loc": [49], "buggy_code_end_loc": [210], "fixing_code_start_loc": [48], "fixing_code_end_loc": [218], "type": "CWE-434", "message": "e107_web/js/plupload/upload.php in e107 2.1.8 allows remote attackers to execute arbitrary PHP code by uploading a .php filename with the image/jpeg content type.", "other": {"cve": {"id": "CVE-2018-16388", "sourceIdentifier": "cve@mitre.org", "published": "2018-09-12T16:29:02.317", "lastModified": "2018-11-02T18:38:45.750", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "e107_web/js/plupload/upload.php in e107 2.1.8 allows remote attackers to execute arbitrary PHP code by uploading a .php filename with the image/jpeg content type."}, {"lang": "es", "value": "e107_web/js/plupload/upload.php en e107 2.1.8 permite que atacantes remotos ejecuten c\u00f3digo PHP arbitrario mediante la subida de un nombre de archivo .php con el tipo de contenido image/jpeg."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:e107:e107:2.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "6C0ECC71-9F7A-4634-B3DD-A6C60C1DA78C"}]}]}], "references": [{"url": "https://gist.github.com/ommadawn46/5cb22e7c66cc32a5c7734a8064b4d3f5", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/e107inc/e107/commit/e5bb5297f68e56537c004cdbb48a30892e9f6f4c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/e107inc/e107/commit/e5bb5297f68e56537c004cdbb48a30892e9f6f4c"}}