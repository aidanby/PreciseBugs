{"buggy_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* lib/krb5/krb/pac.c */\n/*\n * Copyright 2008 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n\n#include \"k5-int.h\"\n#include \"int-proto.h\"\n#include \"authdata.h\"\n\n/* draft-brezak-win2k-krb-authz-00 */\n\n/*\n * Add a buffer to the provided PAC and update header.\n */\nkrb5_error_code\nk5_pac_add_buffer(krb5_context context,\n                  krb5_pac pac,\n                  krb5_ui_4 type,\n                  const krb5_data *data,\n                  krb5_boolean zerofill,\n                  krb5_data *out_data)\n{\n    PACTYPE *header;\n    size_t header_len, i, pad = 0;\n    char *pac_data;\n\n    assert((data->data == NULL) == zerofill);\n\n    /* Check there isn't already a buffer of this type */\n    if (k5_pac_locate_buffer(context, pac, type, NULL) == 0) {\n        return EEXIST;\n    }\n\n    header = (PACTYPE *)realloc(pac->pac,\n                                sizeof(PACTYPE) +\n                                (pac->pac->cBuffers * sizeof(PAC_INFO_BUFFER)));\n    if (header == NULL) {\n        return ENOMEM;\n    }\n    pac->pac = header;\n\n    header_len = PACTYPE_LENGTH + (pac->pac->cBuffers * PAC_INFO_BUFFER_LENGTH);\n\n    if (data->length % PAC_ALIGNMENT)\n        pad = PAC_ALIGNMENT - (data->length % PAC_ALIGNMENT);\n\n    pac_data = realloc(pac->data.data,\n                       pac->data.length + PAC_INFO_BUFFER_LENGTH + data->length + pad);\n    if (pac_data == NULL) {\n        return ENOMEM;\n    }\n    pac->data.data = pac_data;\n\n    /* Update offsets of existing buffers */\n    for (i = 0; i < pac->pac->cBuffers; i++)\n        pac->pac->Buffers[i].Offset += PAC_INFO_BUFFER_LENGTH;\n\n    /* Make room for new PAC_INFO_BUFFER */\n    memmove(pac->data.data + header_len + PAC_INFO_BUFFER_LENGTH,\n            pac->data.data + header_len,\n            pac->data.length - header_len);\n    memset(pac->data.data + header_len, 0, PAC_INFO_BUFFER_LENGTH);\n\n    /* Initialise new PAC_INFO_BUFFER */\n    pac->pac->Buffers[i].ulType = type;\n    pac->pac->Buffers[i].cbBufferSize = data->length;\n    pac->pac->Buffers[i].Offset = pac->data.length + PAC_INFO_BUFFER_LENGTH;\n    assert((pac->pac->Buffers[i].Offset % PAC_ALIGNMENT) == 0);\n\n    /* Copy in new PAC data and zero padding bytes */\n    if (zerofill)\n        memset(pac->data.data + pac->pac->Buffers[i].Offset, 0, data->length);\n    else\n        memcpy(pac->data.data + pac->pac->Buffers[i].Offset, data->data, data->length);\n\n    memset(pac->data.data + pac->pac->Buffers[i].Offset + data->length, 0, pad);\n\n    pac->pac->cBuffers++;\n    pac->data.length += PAC_INFO_BUFFER_LENGTH + data->length + pad;\n\n    if (out_data != NULL) {\n        out_data->data = pac->data.data + pac->pac->Buffers[i].Offset;\n        out_data->length = data->length;\n    }\n\n    pac->verified = FALSE;\n\n    return 0;\n}\n\nkrb5_error_code KRB5_CALLCONV\nkrb5_pac_add_buffer(krb5_context context,\n                    krb5_pac pac,\n                    krb5_ui_4 type,\n                    const krb5_data *data)\n{\n    return k5_pac_add_buffer(context, pac, type, data, FALSE, NULL);\n}\n\n/*\n * Free a PAC\n */\nvoid KRB5_CALLCONV\nkrb5_pac_free(krb5_context context,\n              krb5_pac pac)\n{\n    if (pac != NULL) {\n        zapfree(pac->data.data, pac->data.length);\n        free(pac->pac);\n        zapfree(pac, sizeof(*pac));\n    }\n}\n\nkrb5_error_code\nk5_pac_locate_buffer(krb5_context context,\n                     const krb5_pac pac,\n                     krb5_ui_4 type,\n                     krb5_data *data)\n{\n    PAC_INFO_BUFFER *buffer = NULL;\n    size_t i;\n\n    if (pac == NULL)\n        return EINVAL;\n\n    for (i = 0; i < pac->pac->cBuffers; i++) {\n        if (pac->pac->Buffers[i].ulType == type) {\n            if (buffer == NULL)\n                buffer = &pac->pac->Buffers[i];\n            else\n                return EINVAL;\n        }\n    }\n\n    if (buffer == NULL)\n        return ENOENT;\n\n    assert(buffer->Offset + buffer->cbBufferSize <= pac->data.length);\n\n    if (data != NULL) {\n        data->length = buffer->cbBufferSize;\n        data->data = pac->data.data + buffer->Offset;\n    }\n\n    return 0;\n}\n\n/*\n * Find a buffer and copy data into output\n */\nkrb5_error_code KRB5_CALLCONV\nkrb5_pac_get_buffer(krb5_context context,\n                    krb5_pac pac,\n                    krb5_ui_4 type,\n                    krb5_data *data)\n{\n    krb5_data d;\n    krb5_error_code ret;\n\n    ret = k5_pac_locate_buffer(context, pac, type, &d);\n    if (ret != 0)\n        return ret;\n\n    data->data = k5memdup(d.data, d.length, &ret);\n    if (data->data == NULL)\n        return ret;\n    data->length = d.length;\n\n    return 0;\n}\n\n/*\n * Return an array of the types of data in the PAC\n */\nkrb5_error_code KRB5_CALLCONV\nkrb5_pac_get_types(krb5_context context,\n                   krb5_pac pac,\n                   size_t *len,\n                   krb5_ui_4 **types)\n{\n    size_t i;\n\n    *types = (krb5_ui_4 *)malloc(pac->pac->cBuffers * sizeof(krb5_ui_4));\n    if (*types == NULL)\n        return ENOMEM;\n\n    *len = pac->pac->cBuffers;\n\n    for (i = 0; i < pac->pac->cBuffers; i++)\n        (*types)[i] = pac->pac->Buffers[i].ulType;\n\n    return 0;\n}\n\n/*\n * Initialize PAC\n */\nkrb5_error_code KRB5_CALLCONV\nkrb5_pac_init(krb5_context context,\n              krb5_pac *ppac)\n{\n    krb5_pac pac;\n\n    pac = (krb5_pac)malloc(sizeof(*pac));\n    if (pac == NULL)\n        return ENOMEM;\n\n    pac->pac = (PACTYPE *)malloc(sizeof(PACTYPE));\n    if (pac->pac == NULL) {\n        free(pac);\n        return ENOMEM;\n    }\n\n    pac->pac->cBuffers = 0;\n    pac->pac->Version = 0;\n\n    pac->data.length = PACTYPE_LENGTH;\n    pac->data.data = calloc(1, pac->data.length);\n    if (pac->data.data == NULL) {\n        krb5_pac_free(context, pac);\n        return ENOMEM;\n    }\n\n    pac->verified = FALSE;\n\n    *ppac = pac;\n\n    return 0;\n}\n\nstatic krb5_error_code\nk5_pac_copy(krb5_context context,\n            krb5_pac src,\n            krb5_pac *dst)\n{\n    size_t header_len;\n    krb5_ui_4 cbuffers;\n    krb5_error_code code;\n    krb5_pac pac;\n\n    cbuffers = src->pac->cBuffers;\n    if (cbuffers != 0)\n        cbuffers--;\n\n    header_len = sizeof(PACTYPE) + cbuffers * sizeof(PAC_INFO_BUFFER);\n\n    pac = (krb5_pac)malloc(sizeof(*pac));\n    if (pac == NULL)\n        return ENOMEM;\n\n    pac->pac = k5memdup(src->pac, header_len, &code);\n    if (pac->pac == NULL) {\n        free(pac);\n        return code;\n    }\n\n    code = krb5int_copy_data_contents(context, &src->data, &pac->data);\n    if (code != 0) {\n        free(pac->pac);\n        free(pac);\n        return ENOMEM;\n    }\n\n    pac->verified = src->verified;\n    *dst = pac;\n\n    return 0;\n}\n\n/*\n * Parse the supplied data into the PAC allocated by this function\n */\nkrb5_error_code KRB5_CALLCONV\nkrb5_pac_parse(krb5_context context,\n               const void *ptr,\n               size_t len,\n               krb5_pac *ppac)\n{\n    krb5_error_code ret;\n    size_t i;\n    const unsigned char *p = (const unsigned char *)ptr;\n    krb5_pac pac;\n    size_t header_len;\n    krb5_ui_4 cbuffers, version;\n\n    *ppac = NULL;\n\n    if (len < PACTYPE_LENGTH)\n        return ERANGE;\n\n    cbuffers = load_32_le(p);\n    p += 4;\n    version = load_32_le(p);\n    p += 4;\n\n    if (version != 0)\n        return EINVAL;\n\n    header_len = PACTYPE_LENGTH + (cbuffers * PAC_INFO_BUFFER_LENGTH);\n    if (len < header_len)\n        return ERANGE;\n\n    ret = krb5_pac_init(context, &pac);\n    if (ret != 0)\n        return ret;\n\n    pac->pac = (PACTYPE *)realloc(pac->pac,\n                                  sizeof(PACTYPE) + ((cbuffers - 1) * sizeof(PAC_INFO_BUFFER)));\n    if (pac->pac == NULL) {\n        krb5_pac_free(context, pac);\n        return ENOMEM;\n    }\n\n    pac->pac->cBuffers = cbuffers;\n    pac->pac->Version = version;\n\n    for (i = 0; i < pac->pac->cBuffers; i++) {\n        PAC_INFO_BUFFER *buffer = &pac->pac->Buffers[i];\n\n        buffer->ulType = load_32_le(p);\n        p += 4;\n        buffer->cbBufferSize = load_32_le(p);\n        p += 4;\n        buffer->Offset = load_64_le(p);\n        p += 8;\n\n        if (buffer->Offset % PAC_ALIGNMENT) {\n            krb5_pac_free(context, pac);\n            return EINVAL;\n        }\n        if (buffer->Offset < header_len ||\n            buffer->Offset + buffer->cbBufferSize > len) {\n            krb5_pac_free(context, pac);\n            return ERANGE;\n        }\n    }\n\n    pac->data.data = realloc(pac->data.data, len);\n    if (pac->data.data == NULL) {\n        krb5_pac_free(context, pac);\n        return ENOMEM;\n    }\n    memcpy(pac->data.data, ptr, len);\n\n    pac->data.length = len;\n\n    *ppac = pac;\n\n    return 0;\n}\n\nstatic krb5_error_code\nk5_time_to_seconds_since_1970(uint64_t ntTime, krb5_timestamp *elapsedSeconds)\n{\n    uint64_t abstime = ntTime / 10000000 - NT_TIME_EPOCH;\n\n    if (abstime > UINT32_MAX)\n        return ERANGE;\n    *elapsedSeconds = abstime;\n    return 0;\n}\n\nkrb5_error_code\nk5_seconds_since_1970_to_time(krb5_timestamp elapsedSeconds, uint64_t *ntTime)\n{\n    *ntTime = (uint32_t)elapsedSeconds;\n    *ntTime += NT_TIME_EPOCH;\n    *ntTime *= 10000000;\n    return 0;\n}\n\nkrb5_error_code KRB5_CALLCONV\nkrb5_pac_get_client_info(krb5_context context,\n                         const krb5_pac pac,\n                         krb5_timestamp *authtime_out,\n                         char **princname_out)\n{\n    krb5_error_code ret;\n    krb5_data client_info;\n    char *pac_princname;\n    unsigned char *p;\n    krb5_timestamp pac_authtime;\n    krb5_ui_2 pac_princname_length;\n    uint64_t pac_nt_authtime;\n\n    if (authtime_out != NULL)\n        *authtime_out = 0;\n    *princname_out = NULL;\n\n    ret = k5_pac_locate_buffer(context, pac, KRB5_PAC_CLIENT_INFO,\n                               &client_info);\n    if (ret != 0)\n        return ret;\n\n    if (client_info.length < PAC_CLIENT_INFO_LENGTH)\n        return ERANGE;\n\n    p = (unsigned char *)client_info.data;\n    pac_nt_authtime = load_64_le(p);\n    p += 8;\n    pac_princname_length = load_16_le(p);\n    p += 2;\n\n    ret = k5_time_to_seconds_since_1970(pac_nt_authtime, &pac_authtime);\n    if (ret != 0)\n        return ret;\n\n    if (client_info.length < PAC_CLIENT_INFO_LENGTH + pac_princname_length ||\n        pac_princname_length % 2)\n        return ERANGE;\n\n    ret = k5_utf16le_to_utf8(p, pac_princname_length, &pac_princname);\n    if (ret != 0)\n        return ret;\n\n    if (authtime_out != NULL)\n        *authtime_out = pac_authtime;\n    *princname_out = pac_princname;\n\n    return 0;\n}\n\nkrb5_error_code\nk5_pac_validate_client(krb5_context context,\n                       const krb5_pac pac,\n                       krb5_timestamp authtime,\n                       krb5_const_principal principal,\n                       krb5_boolean with_realm)\n{\n    krb5_error_code ret;\n    char *pac_princname, *princname;\n    krb5_timestamp pac_authtime;\n    int flags = 0;\n\n    ret = krb5_pac_get_client_info(context, pac, &pac_authtime,\n                                   &pac_princname);\n    if (ret != 0)\n        return ret;\n\n    flags = KRB5_PRINCIPAL_UNPARSE_DISPLAY;\n    if (!with_realm)\n        flags |= KRB5_PRINCIPAL_UNPARSE_NO_REALM;\n\n    ret = krb5_unparse_name_flags(context, principal, flags, &princname);\n    if (ret != 0) {\n        free(pac_princname);\n        return ret;\n    }\n\n    if (pac_authtime != authtime || strcmp(pac_princname, princname) != 0)\n        ret = KRB5KRB_AP_WRONG_PRINC;\n\n    free(pac_princname);\n    krb5_free_unparsed_name(context, princname);\n\n    return ret;\n}\n\nstatic krb5_error_code\nzero_signature(krb5_context context, const krb5_pac pac, krb5_ui_4 type,\n               krb5_data *data)\n{\n    PAC_INFO_BUFFER *buffer = NULL;\n    size_t i;\n\n    assert(type == KRB5_PAC_SERVER_CHECKSUM ||\n           type == KRB5_PAC_PRIVSVR_CHECKSUM);\n    assert(data->length >= pac->data.length);\n\n    for (i = 0; i < pac->pac->cBuffers; i++) {\n        if (pac->pac->Buffers[i].ulType == type) {\n            buffer = &pac->pac->Buffers[i];\n            break;\n        }\n    }\n\n    if (buffer == NULL)\n        return ENOENT;\n\n    if (buffer->Offset + buffer->cbBufferSize > pac->data.length)\n        return ERANGE;\n\n    if (buffer->cbBufferSize < PAC_SIGNATURE_DATA_LENGTH)\n        return KRB5_BAD_MSIZE;\n\n    /* Zero out the data portion of the checksum only */\n    memset(data->data + buffer->Offset + PAC_SIGNATURE_DATA_LENGTH,\n           0,\n           buffer->cbBufferSize - PAC_SIGNATURE_DATA_LENGTH);\n\n    return 0;\n}\n\nstatic krb5_error_code\nverify_checksum(krb5_context context, const krb5_pac pac, uint32_t buffer_type,\n                const krb5_keyblock *key, krb5_keyusage usage,\n                const krb5_data *data)\n{\n    krb5_error_code ret;\n    krb5_data buffer;\n    krb5_cksumtype cksumtype;\n    krb5_checksum checksum;\n    krb5_boolean valid;\n    size_t cksumlen;\n\n    ret = k5_pac_locate_buffer(context, pac, buffer_type, &buffer);\n    if (ret != 0)\n        return ret;\n    if (buffer.length < PAC_SIGNATURE_DATA_LENGTH)\n        return KRB5_BAD_MSIZE;\n\n    cksumtype = load_32_le(buffer.data);\n    if (buffer_type == KRB5_PAC_SERVER_CHECKSUM && cksumtype == CKSUMTYPE_SHA1)\n        return KRB5KDC_ERR_SUMTYPE_NOSUPP;\n    if (!krb5_c_is_keyed_cksum(cksumtype))\n        return KRB5KRB_ERR_GENERIC;\n\n    /* There may be an RODCIdentifier trailer (see [MS-PAC] 2.8), so look up\n     * the length of the checksum by its type. */\n    ret = krb5_c_checksum_length(context, cksumtype, &cksumlen);\n    if (ret)\n        return ret;\n    if (cksumlen > buffer.length - PAC_SIGNATURE_DATA_LENGTH)\n        return KRB5_BAD_MSIZE;\n    checksum.checksum_type = cksumtype;\n    checksum.length = cksumlen;\n    checksum.contents = (uint8_t *)buffer.data + PAC_SIGNATURE_DATA_LENGTH;\n\n    ret = krb5_c_verify_checksum(context, key, usage, data, &checksum, &valid);\n    return ret ? ret : (valid ? 0 : KRB5KRB_AP_ERR_MODIFIED);\n}\n\nstatic krb5_error_code\nverify_server_checksum(krb5_context context, const krb5_pac pac,\n                       const krb5_keyblock *server)\n{\n    krb5_error_code ret;\n    krb5_data copy;             /* PAC with zeroed checksums */\n\n    ret = krb5int_copy_data_contents(context, &pac->data, &copy);\n    if (ret)\n        return ret;\n\n    /* Zero out both checksum buffers */\n    ret = zero_signature(context, pac, KRB5_PAC_SERVER_CHECKSUM, &copy);\n    if (ret)\n        goto cleanup;\n    ret = zero_signature(context, pac, KRB5_PAC_PRIVSVR_CHECKSUM, &copy);\n    if (ret)\n        goto cleanup;\n\n    ret = verify_checksum(context, pac, KRB5_PAC_SERVER_CHECKSUM, server,\n                          KRB5_KEYUSAGE_APP_DATA_CKSUM, &copy);\n\ncleanup:\n    free(copy.data);\n    return ret;\n}\n\nstatic krb5_error_code\nverify_kdc_checksum(krb5_context context, const krb5_pac pac,\n                    const krb5_keyblock *privsvr)\n{\n    krb5_error_code ret;\n    krb5_data server_checksum;\n\n    ret = k5_pac_locate_buffer(context, pac, KRB5_PAC_SERVER_CHECKSUM,\n                               &server_checksum);\n    if (ret)\n        return ret;\n    if (server_checksum.length < PAC_SIGNATURE_DATA_LENGTH)\n        return KRB5_BAD_MSIZE;\n    server_checksum.data += PAC_SIGNATURE_DATA_LENGTH;\n    server_checksum.length -= PAC_SIGNATURE_DATA_LENGTH;\n\n    return verify_checksum(context, pac, KRB5_PAC_PRIVSVR_CHECKSUM, privsvr,\n                           KRB5_KEYUSAGE_APP_DATA_CKSUM, &server_checksum);\n}\n\n/* Per MS-PAC 2.8.3, tickets encrypted to TGS and password change principals\n * should not have ticket signatures. */\nkrb5_boolean\nk5_pac_should_have_ticket_signature(krb5_const_principal sprinc)\n{\n    if (IS_TGS_PRINC(sprinc))\n        return FALSE;\n    if (sprinc->length == 2 && data_eq_string(sprinc->data[0], \"kadmin\") &&\n        data_eq_string(sprinc->data[1], \"changepw\"))\n        return FALSE;\n    return TRUE;\n}\n\nkrb5_error_code KRB5_CALLCONV\nkrb5_kdc_verify_ticket(krb5_context context, const krb5_enc_tkt_part *enc_tkt,\n                       krb5_const_principal server_princ,\n                       const krb5_keyblock *server,\n                       const krb5_keyblock *privsvr, krb5_pac *pac_out)\n{\n    krb5_error_code ret;\n    krb5_pac pac = NULL;\n    krb5_data *recoded_tkt = NULL;\n    krb5_authdata **authdata, *orig, **ifrel = NULL, **recoded_ifrel = NULL;\n    uint8_t z = 0;\n    krb5_authdata zpac = { KV5M_AUTHDATA, KRB5_AUTHDATA_WIN2K_PAC, 1, &z };\n    size_t i, j;\n\n    *pac_out = NULL;\n\n    /*\n     * Find the position of the PAC in the ticket authdata.  ifrel will be the\n     * decoded AD-IF-RELEVANT container at position i containing a PAC, and j\n     * will be the offset within the container.\n     */\n    authdata = enc_tkt->authorization_data;\n    for (i = 0; authdata != NULL && authdata[i] != NULL; i++) {\n        if (authdata[i]->ad_type != KRB5_AUTHDATA_IF_RELEVANT)\n            continue;\n\n        ret = krb5_decode_authdata_container(context,\n                                             KRB5_AUTHDATA_IF_RELEVANT,\n                                             authdata[i], &ifrel);\n        if (ret)\n            goto cleanup;\n\n        for (j = 0; ifrel[j] != NULL; j++) {\n            if (ifrel[j]->ad_type == KRB5_AUTHDATA_WIN2K_PAC)\n                break;\n        }\n        if (ifrel[j] != NULL)\n            break;\n\n        krb5_free_authdata(context, ifrel);\n        ifrel = NULL;\n    }\n\n    /* Stop and return successfully if we didn't find a PAC. */\n    if (ifrel == NULL) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    ret = krb5_pac_parse(context, ifrel[j]->contents, ifrel[j]->length, &pac);\n    if (ret)\n        goto cleanup;\n\n    if (privsvr != NULL && k5_pac_should_have_ticket_signature(server_princ)) {\n        /* To check the PAC ticket signatures, re-encode the ticket with the\n         * PAC contents replaced by a single zero. */\n        orig = ifrel[j];\n        ifrel[j] = &zpac;\n        ret = krb5_encode_authdata_container(context,\n                                             KRB5_AUTHDATA_IF_RELEVANT,\n                                             ifrel, &recoded_ifrel);\n        ifrel[j] = orig;\n        if (ret)\n            goto cleanup;\n        orig = authdata[i];\n        authdata[i] = recoded_ifrel[0];\n        ret = encode_krb5_enc_tkt_part(enc_tkt, &recoded_tkt);\n        authdata[i] = orig;\n        if (ret)\n            goto cleanup;\n\n        ret = verify_checksum(context, pac, KRB5_PAC_TICKET_CHECKSUM, privsvr,\n                              KRB5_KEYUSAGE_APP_DATA_CKSUM, recoded_tkt);\n        if (ret)\n            goto cleanup;\n    }\n\n    ret = krb5_pac_verify_ext(context, pac, enc_tkt->times.authtime, NULL,\n                              server, privsvr, FALSE);\n\n    *pac_out = pac;\n    pac = NULL;\n\ncleanup:\n    krb5_pac_free(context, pac);\n    krb5_free_data(context, recoded_tkt);\n    krb5_free_authdata(context, ifrel);\n    krb5_free_authdata(context, recoded_ifrel);\n    return ret;\n}\n\nkrb5_error_code KRB5_CALLCONV\nkrb5_pac_verify(krb5_context context,\n                const krb5_pac pac,\n                krb5_timestamp authtime,\n                krb5_const_principal principal,\n                const krb5_keyblock *server,\n                const krb5_keyblock *privsvr)\n{\n    return krb5_pac_verify_ext(context, pac, authtime, principal, server,\n                               privsvr, FALSE);\n}\n\nkrb5_error_code KRB5_CALLCONV\nkrb5_pac_verify_ext(krb5_context context,\n                    const krb5_pac pac,\n                    krb5_timestamp authtime,\n                    krb5_const_principal principal,\n                    const krb5_keyblock *server,\n                    const krb5_keyblock *privsvr,\n                    krb5_boolean with_realm)\n{\n    krb5_error_code ret;\n\n    if (server != NULL) {\n        ret = verify_server_checksum(context, pac, server);\n        if (ret != 0)\n            return ret;\n    }\n\n    if (privsvr != NULL) {\n        ret = verify_kdc_checksum(context, pac, privsvr);\n        if (ret != 0)\n            return ret;\n    }\n\n    if (principal != NULL) {\n        ret = k5_pac_validate_client(context, pac, authtime,\n                                     principal, with_realm);\n        if (ret != 0)\n            return ret;\n    }\n\n    pac->verified = TRUE;\n\n    return 0;\n}\n\n/*\n * PAC auth data attribute backend\n */\nstruct mspac_context {\n    krb5_pac pac;\n};\n\nstatic krb5_error_code\nmspac_init(krb5_context kcontext, void **plugin_context)\n{\n    *plugin_context = NULL;\n    return 0;\n}\n\nstatic void\nmspac_flags(krb5_context kcontext,\n            void *plugin_context,\n            krb5_authdatatype ad_type,\n            krb5_flags *flags)\n{\n    *flags = AD_USAGE_TGS_REQ;\n}\n\nstatic void\nmspac_fini(krb5_context kcontext, void *plugin_context)\n{\n    return;\n}\n\nstatic krb5_error_code\nmspac_request_init(krb5_context kcontext,\n                   krb5_authdata_context context,\n                   void *plugin_context,\n                   void **request_context)\n{\n    struct mspac_context *pacctx;\n\n    pacctx = (struct mspac_context *)malloc(sizeof(*pacctx));\n    if (pacctx == NULL)\n        return ENOMEM;\n\n    pacctx->pac = NULL;\n\n    *request_context = pacctx;\n\n    return 0;\n}\n\nstatic krb5_error_code\nmspac_import_authdata(krb5_context kcontext,\n                      krb5_authdata_context context,\n                      void *plugin_context,\n                      void *request_context,\n                      krb5_authdata **authdata,\n                      krb5_boolean kdc_issued,\n                      krb5_const_principal kdc_issuer)\n{\n    krb5_error_code code;\n    struct mspac_context *pacctx = (struct mspac_context *)request_context;\n\n    if (kdc_issued)\n        return EINVAL;\n\n    if (pacctx->pac != NULL) {\n        krb5_pac_free(kcontext, pacctx->pac);\n        pacctx->pac = NULL;\n    }\n\n    assert(authdata[0] != NULL);\n    assert((authdata[0]->ad_type & AD_TYPE_FIELD_TYPE_MASK) ==\n           KRB5_AUTHDATA_WIN2K_PAC);\n\n    code = krb5_pac_parse(kcontext, authdata[0]->contents,\n                          authdata[0]->length, &pacctx->pac);\n\n    return code;\n}\n\nstatic krb5_error_code\nmspac_export_authdata(krb5_context kcontext,\n                      krb5_authdata_context context,\n                      void *plugin_context,\n                      void *request_context,\n                      krb5_flags usage,\n                      krb5_authdata ***out_authdata)\n{\n    struct mspac_context *pacctx = (struct mspac_context *)request_context;\n    krb5_error_code code;\n    krb5_authdata **authdata;\n    krb5_data data;\n\n    if (pacctx->pac == NULL)\n        return 0;\n\n    authdata = calloc(2, sizeof(krb5_authdata *));\n    if (authdata == NULL)\n        return ENOMEM;\n\n    authdata[0] = calloc(1, sizeof(krb5_authdata));\n    if (authdata[0] == NULL) {\n        free(authdata);\n        return ENOMEM;\n    }\n    authdata[1] = NULL;\n\n    code = krb5int_copy_data_contents(kcontext, &pacctx->pac->data, &data);\n    if (code != 0) {\n        krb5_free_authdata(kcontext, authdata);\n        return code;\n    }\n\n    authdata[0]->magic = KV5M_AUTHDATA;\n    authdata[0]->ad_type = KRB5_AUTHDATA_WIN2K_PAC;\n    authdata[0]->length = data.length;\n    authdata[0]->contents = (krb5_octet *)data.data;\n\n    authdata[1] = NULL;\n\n    *out_authdata = authdata;\n\n    return 0;\n}\n\nstatic krb5_error_code\nmspac_verify(krb5_context kcontext,\n             krb5_authdata_context context,\n             void *plugin_context,\n             void *request_context,\n             const krb5_auth_context *auth_context,\n             const krb5_keyblock *key,\n             const krb5_ap_req *req)\n{\n    krb5_error_code code;\n    struct mspac_context *pacctx = (struct mspac_context *)request_context;\n\n    if (pacctx->pac == NULL)\n        return EINVAL;\n\n    code = krb5_pac_verify(kcontext, pacctx->pac,\n                           req->ticket->enc_part2->times.authtime,\n                           req->ticket->enc_part2->client, key, NULL);\n    if (code != 0)\n        TRACE_MSPAC_VERIFY_FAIL(kcontext, code);\n\n    /*\n     * If the above verification failed, don't fail the whole authentication,\n     * just don't mark the PAC as verified.  A checksum mismatch can occur if\n     * the PAC was copied from a cross-realm TGT by an ignorant KDC, and Apple\n     * macOS Server Open Directory (as of 10.6) generates PACs with no server\n     * checksum at all.\n     */\n    return 0;\n}\n\nstatic void\nmspac_request_fini(krb5_context kcontext,\n                   krb5_authdata_context context,\n                   void *plugin_context,\n                   void *request_context)\n{\n    struct mspac_context *pacctx = (struct mspac_context *)request_context;\n\n    if (pacctx != NULL) {\n        if (pacctx->pac != NULL)\n            krb5_pac_free(kcontext, pacctx->pac);\n\n        free(pacctx);\n    }\n}\n\n#define STRLENOF(x) (sizeof((x)) - 1)\n\nstatic struct {\n    krb5_ui_4 type;\n    krb5_data attribute;\n} mspac_attribute_types[] = {\n    { (krb5_ui_4)-1,            { KV5M_DATA, STRLENOF(\"urn:mspac:\"),\n                                  \"urn:mspac:\" } },\n    { KRB5_PAC_LOGON_INFO,       { KV5M_DATA,\n                                   STRLENOF(\"urn:mspac:logon-info\"),\n                                   \"urn:mspac:logon-info\" } },\n    { KRB5_PAC_CREDENTIALS_INFO, { KV5M_DATA,\n                                   STRLENOF(\"urn:mspac:credentials-info\"),\n                                   \"urn:mspac:credentials-info\" } },\n    { KRB5_PAC_SERVER_CHECKSUM,  { KV5M_DATA,\n                                   STRLENOF(\"urn:mspac:server-checksum\"),\n                                   \"urn:mspac:server-checksum\" } },\n    { KRB5_PAC_PRIVSVR_CHECKSUM, { KV5M_DATA,\n                                   STRLENOF(\"urn:mspac:privsvr-checksum\"),\n                                   \"urn:mspac:privsvr-checksum\" } },\n    { KRB5_PAC_CLIENT_INFO,      { KV5M_DATA,\n                                   STRLENOF(\"urn:mspac:client-info\"),\n                                   \"urn:mspac:client-info\" } },\n    { KRB5_PAC_DELEGATION_INFO,  { KV5M_DATA,\n                                   STRLENOF(\"urn:mspac:delegation-info\"),\n                                   \"urn:mspac:delegation-info\" } },\n    { KRB5_PAC_UPN_DNS_INFO,     { KV5M_DATA,\n                                   STRLENOF(\"urn:mspac:upn-dns-info\"),\n                                   \"urn:mspac:upn-dns-info\" } },\n};\n\n#define MSPAC_ATTRIBUTE_COUNT   (sizeof(mspac_attribute_types)/sizeof(mspac_attribute_types[0]))\n\nstatic krb5_error_code\nmspac_type2attr(krb5_ui_4 type, krb5_data *attr)\n{\n    unsigned int i;\n\n    for (i = 0; i < MSPAC_ATTRIBUTE_COUNT; i++) {\n        if (mspac_attribute_types[i].type == type) {\n            *attr = mspac_attribute_types[i].attribute;\n            return 0;\n        }\n    }\n\n    return ENOENT;\n}\n\nstatic krb5_error_code\nmspac_attr2type(const krb5_data *attr, krb5_ui_4 *type)\n{\n    unsigned int i;\n\n    for (i = 0; i < MSPAC_ATTRIBUTE_COUNT; i++) {\n        if (attr->length == mspac_attribute_types[i].attribute.length &&\n            strncasecmp(attr->data, mspac_attribute_types[i].attribute.data, attr->length) == 0) {\n            *type = mspac_attribute_types[i].type;\n            return 0;\n        }\n    }\n\n    if (attr->length > STRLENOF(\"urn:mspac:\") &&\n        strncasecmp(attr->data, \"urn:mspac:\", STRLENOF(\"urn:mspac:\")) == 0)\n    {\n        char *p = &attr->data[STRLENOF(\"urn:mspac:\")];\n        char *endptr;\n\n        *type = strtoul(p, &endptr, 10);\n        if (*type != 0 && *endptr == '\\0')\n            return 0;\n    }\n\n    return ENOENT;\n}\n\nstatic krb5_error_code\nmspac_get_attribute_types(krb5_context kcontext,\n                          krb5_authdata_context context,\n                          void *plugin_context,\n                          void *request_context,\n                          krb5_data **out_attrs)\n{\n    struct mspac_context *pacctx = (struct mspac_context *)request_context;\n    unsigned int i, j;\n    krb5_data *attrs;\n    krb5_error_code code;\n\n    if (pacctx->pac == NULL)\n        return ENOENT;\n\n    attrs = calloc(1 + pacctx->pac->pac->cBuffers + 1, sizeof(krb5_data));\n    if (attrs == NULL)\n        return ENOMEM;\n\n    j = 0;\n\n    /* The entire PAC */\n    code = krb5int_copy_data_contents(kcontext,\n                                      &mspac_attribute_types[0].attribute,\n                                      &attrs[j++]);\n    if (code != 0) {\n        free(attrs);\n        return code;\n    }\n\n    /* PAC buffers */\n    for (i = 0; i < pacctx->pac->pac->cBuffers; i++) {\n        krb5_data attr;\n\n        code = mspac_type2attr(pacctx->pac->pac->Buffers[i].ulType, &attr);\n        if (code == 0) {\n            code = krb5int_copy_data_contents(kcontext, &attr, &attrs[j++]);\n            if (code != 0) {\n                krb5int_free_data_list(kcontext, attrs);\n                return code;\n            }\n        } else {\n            int length;\n\n            length = asprintf(&attrs[j].data, \"urn:mspac:%d\",\n                              pacctx->pac->pac->Buffers[i].ulType);\n            if (length < 0) {\n                krb5int_free_data_list(kcontext, attrs);\n                return ENOMEM;\n            }\n            attrs[j++].length = length;\n        }\n    }\n    attrs[j].data = NULL;\n    attrs[j].length = 0;\n\n    *out_attrs = attrs;\n\n    return 0;\n}\n\nstatic krb5_error_code\nmspac_get_attribute(krb5_context kcontext,\n                    krb5_authdata_context context,\n                    void *plugin_context,\n                    void *request_context,\n                    const krb5_data *attribute,\n                    krb5_boolean *authenticated,\n                    krb5_boolean *complete,\n                    krb5_data *value,\n                    krb5_data *display_value,\n                    int *more)\n{\n    struct mspac_context *pacctx = (struct mspac_context *)request_context;\n    krb5_error_code code;\n    krb5_ui_4 type;\n\n    if (display_value != NULL) {\n        display_value->data = NULL;\n        display_value->length = 0;\n    }\n\n    if (*more != -1 || pacctx->pac == NULL)\n        return ENOENT;\n\n    /* If it didn't verify, pretend it didn't exist. */\n    if (!pacctx->pac->verified) {\n        TRACE_MSPAC_DISCARD_UNVERF(kcontext);\n        return ENOENT;\n    }\n\n    code = mspac_attr2type(attribute, &type);\n    if (code != 0)\n        return code;\n\n    /* -1 is a magic type that refers to the entire PAC */\n    if (type == (krb5_ui_4)-1) {\n        if (value != NULL)\n            code = krb5int_copy_data_contents(kcontext,\n                                              &pacctx->pac->data,\n                                              value);\n        else\n            code = 0;\n    } else {\n        if (value != NULL)\n            code = krb5_pac_get_buffer(kcontext, pacctx->pac, type, value);\n        else\n            code = k5_pac_locate_buffer(kcontext, pacctx->pac, type, NULL);\n    }\n    if (code == 0) {\n        *authenticated = pacctx->pac->verified;\n        *complete = TRUE;\n    }\n\n    *more = 0;\n\n    return code;\n}\n\nstatic krb5_error_code\nmspac_set_attribute(krb5_context kcontext,\n                    krb5_authdata_context context,\n                    void *plugin_context,\n                    void *request_context,\n                    krb5_boolean complete,\n                    const krb5_data *attribute,\n                    const krb5_data *value)\n{\n    struct mspac_context *pacctx = (struct mspac_context *)request_context;\n    krb5_error_code code;\n    krb5_ui_4 type;\n\n    if (pacctx->pac == NULL)\n        return ENOENT;\n\n    code = mspac_attr2type(attribute, &type);\n    if (code != 0)\n        return code;\n\n    /* -1 is a magic type that refers to the entire PAC */\n    if (type == (krb5_ui_4)-1) {\n        krb5_pac newpac;\n\n        code = krb5_pac_parse(kcontext, value->data, value->length, &newpac);\n        if (code != 0)\n            return code;\n\n        krb5_pac_free(kcontext, pacctx->pac);\n        pacctx->pac = newpac;\n    } else {\n        code = krb5_pac_add_buffer(kcontext, pacctx->pac, type, value);\n    }\n\n    return code;\n}\n\nstatic krb5_error_code\nmspac_export_internal(krb5_context kcontext,\n                      krb5_authdata_context context,\n                      void *plugin_context,\n                      void *request_context,\n                      krb5_boolean restrict_authenticated,\n                      void **ptr)\n{\n    struct mspac_context *pacctx = (struct mspac_context *)request_context;\n    krb5_error_code code;\n    krb5_pac pac;\n\n    *ptr = NULL;\n\n    if (pacctx->pac == NULL)\n        return ENOENT;\n\n    if (restrict_authenticated && (pacctx->pac->verified) == FALSE)\n        return ENOENT;\n\n    code = krb5_pac_parse(kcontext, pacctx->pac->data.data,\n                          pacctx->pac->data.length, &pac);\n    if (code == 0) {\n        pac->verified = pacctx->pac->verified;\n        *ptr = pac;\n    }\n\n    return code;\n}\n\nstatic void\nmspac_free_internal(krb5_context kcontext,\n                    krb5_authdata_context context,\n                    void *plugin_context,\n                    void *request_context,\n                    void *ptr)\n{\n    if (ptr != NULL)\n        krb5_pac_free(kcontext, (krb5_pac)ptr);\n\n    return;\n}\n\nstatic krb5_error_code\nmspac_size(krb5_context kcontext,\n           krb5_authdata_context context,\n           void *plugin_context,\n           void *request_context,\n           size_t *sizep)\n{\n    struct mspac_context *pacctx = (struct mspac_context *)request_context;\n\n    *sizep += sizeof(krb5_int32);\n\n    if (pacctx->pac != NULL)\n        *sizep += pacctx->pac->data.length;\n\n    *sizep += sizeof(krb5_int32);\n\n    return 0;\n}\n\nstatic krb5_error_code\nmspac_externalize(krb5_context kcontext,\n                  krb5_authdata_context context,\n                  void *plugin_context,\n                  void *request_context,\n                  krb5_octet **buffer,\n                  size_t *lenremain)\n{\n    krb5_error_code code = 0;\n    struct mspac_context *pacctx = (struct mspac_context *)request_context;\n    size_t required = 0;\n    krb5_octet *bp;\n    size_t remain;\n\n    bp = *buffer;\n    remain = *lenremain;\n\n    if (pacctx->pac != NULL) {\n        mspac_size(kcontext, context, plugin_context,\n                   request_context, &required);\n\n        if (required <= remain) {\n            krb5_ser_pack_int32((krb5_int32)pacctx->pac->data.length,\n                                &bp, &remain);\n            krb5_ser_pack_bytes((krb5_octet *)pacctx->pac->data.data,\n                                (size_t)pacctx->pac->data.length,\n                                &bp, &remain);\n            krb5_ser_pack_int32((krb5_int32)pacctx->pac->verified,\n                                &bp, &remain);\n        } else {\n            code = ENOMEM;\n        }\n    } else {\n        krb5_ser_pack_int32(0, &bp, &remain); /* length */\n        krb5_ser_pack_int32(0, &bp, &remain); /* verified */\n    }\n\n    *buffer = bp;\n    *lenremain = remain;\n\n    return code;\n}\n\nstatic krb5_error_code\nmspac_internalize(krb5_context kcontext,\n                  krb5_authdata_context context,\n                  void *plugin_context,\n                  void *request_context,\n                  krb5_octet **buffer,\n                  size_t *lenremain)\n{\n    struct mspac_context *pacctx = (struct mspac_context *)request_context;\n    krb5_error_code code;\n    krb5_int32 ibuf;\n    krb5_octet *bp;\n    size_t remain;\n    krb5_pac pac = NULL;\n\n    bp = *buffer;\n    remain = *lenremain;\n\n    /* length */\n    code = krb5_ser_unpack_int32(&ibuf, &bp, &remain);\n    if (code != 0)\n        return code;\n\n    if (ibuf != 0) {\n        code = krb5_pac_parse(kcontext, bp, ibuf, &pac);\n        if (code != 0)\n            return code;\n\n        bp += ibuf;\n        remain -= ibuf;\n    }\n\n    /* verified */\n    code = krb5_ser_unpack_int32(&ibuf, &bp, &remain);\n    if (code != 0) {\n        krb5_pac_free(kcontext, pac);\n        return code;\n    }\n\n    if (pac != NULL) {\n        pac->verified = (ibuf != 0);\n    }\n\n    if (pacctx->pac != NULL) {\n        krb5_pac_free(kcontext, pacctx->pac);\n    }\n\n    pacctx->pac = pac;\n\n    *buffer = bp;\n    *lenremain = remain;\n\n    return 0;\n}\n\nstatic krb5_error_code\nmspac_copy(krb5_context kcontext,\n           krb5_authdata_context context,\n           void *plugin_context,\n           void *request_context,\n           void *dst_plugin_context,\n           void *dst_request_context)\n{\n    struct mspac_context *srcctx = (struct mspac_context *)request_context;\n    struct mspac_context *dstctx = (struct mspac_context *)dst_request_context;\n    krb5_error_code code = 0;\n\n    assert(dstctx != NULL);\n    assert(dstctx->pac == NULL);\n\n    if (srcctx->pac != NULL)\n        code = k5_pac_copy(kcontext, srcctx->pac, &dstctx->pac);\n\n    return code;\n}\n\nstatic krb5_authdatatype mspac_ad_types[] = { KRB5_AUTHDATA_WIN2K_PAC, 0 };\n\nkrb5plugin_authdata_client_ftable_v0 k5_mspac_ad_client_ftable = {\n    \"mspac\",\n    mspac_ad_types,\n    mspac_init,\n    mspac_fini,\n    mspac_flags,\n    mspac_request_init,\n    mspac_request_fini,\n    mspac_get_attribute_types,\n    mspac_get_attribute,\n    mspac_set_attribute,\n    NULL, /* delete_attribute_proc */\n    mspac_export_authdata,\n    mspac_import_authdata,\n    mspac_export_internal,\n    mspac_free_internal,\n    mspac_verify,\n    mspac_size,\n    mspac_externalize,\n    mspac_internalize,\n    mspac_copy\n};\n", "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * Copyright (c) 2006 Kungliga Tekniska H\u00f6gskolan\n * (Royal Institute of Technology, Stockholm, Sweden).\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the Institute nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"k5-int.h\"\n\n#define U(x) (uint8_t *)x\n\n/*\n * This PAC and keys are copied (with permission) from Samba torture\n * regression test suite, they where created by Andrew Bartlet.\n */\n\nstatic const unsigned char saved_pac[] = {\n    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xd8, 0x01, 0x00, 0x00,\n    0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,\n    0x20, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,\n    0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,\n    0x58, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x10, 0x08, 0x00, 0xcc, 0xcc, 0xcc, 0xcc,\n    0xc8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x30, 0xdf, 0xa6, 0xcb,\n    0x4f, 0x7d, 0xc5, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0xc0, 0x3c, 0x4e, 0x59, 0x62, 0x73, 0xc5, 0x01, 0xc0, 0x3c, 0x4e, 0x59,\n    0x62, 0x73, 0xc5, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x16, 0x00, 0x16, 0x00,\n    0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0c, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x14, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x02, 0x00, 0x65, 0x00, 0x00, 0x00,\n    0xed, 0x03, 0x00, 0x00, 0x04, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x02, 0x00,\n    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x16, 0x00, 0x20, 0x00, 0x02, 0x00, 0x16, 0x00, 0x18, 0x00,\n    0x24, 0x00, 0x02, 0x00, 0x28, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x01, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,\n    0x57, 0x00, 0x32, 0x00, 0x30, 0x00, 0x30, 0x00, 0x33, 0x00, 0x46, 0x00, 0x49, 0x00, 0x4e, 0x00,\n    0x41, 0x00, 0x4c, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,\n    0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x57, 0x00, 0x32, 0x00,\n    0x30, 0x00, 0x30, 0x00, 0x33, 0x00, 0x46, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x41, 0x00, 0x4c, 0x00,\n    0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x57, 0x00, 0x49, 0x00,\n    0x4e, 0x00, 0x32, 0x00, 0x4b, 0x00, 0x33, 0x00, 0x54, 0x00, 0x48, 0x00, 0x49, 0x00, 0x4e, 0x00,\n    0x4b, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,\n    0x15, 0x00, 0x00, 0x00, 0x11, 0x2f, 0xaf, 0xb5, 0x90, 0x04, 0x1b, 0xec, 0x50, 0x3b, 0xec, 0xdc,\n    0x01, 0x00, 0x00, 0x00, 0x30, 0x00, 0x02, 0x00, 0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,\n    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x80, 0x66, 0x28, 0xea, 0x37, 0x80, 0xc5, 0x01, 0x16, 0x00, 0x77, 0x00, 0x32, 0x00, 0x30, 0x00,\n    0x30, 0x00, 0x33, 0x00, 0x66, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x61, 0x00, 0x6c, 0x00, 0x24, 0x00,\n    0x76, 0xff, 0xff, 0xff, 0x37, 0xd5, 0xb0, 0xf7, 0x24, 0xf0, 0xd6, 0xd4, 0xec, 0x09, 0x86, 0x5a,\n    0xa0, 0xe8, 0xc3, 0xa9, 0x00, 0x00, 0x00, 0x00, 0x76, 0xff, 0xff, 0xff, 0xb4, 0xd8, 0xb8, 0xfe,\n    0x83, 0xb3, 0x13, 0x3f, 0xfc, 0x5c, 0x41, 0xad, 0xe2, 0x64, 0x83, 0xe0, 0x00, 0x00, 0x00, 0x00\n};\n\nstatic unsigned int type_1_length = 472;\n\nstatic const krb5_keyblock kdc_keyblock = {\n    0, ENCTYPE_ARCFOUR_HMAC,\n    16, U(\"\\xB2\\x86\\x75\\x71\\x48\\xAF\\x7F\\xD2\\x52\\xC5\\x36\\x03\\xA1\\x50\\xB7\\xE7\")\n};\n\nstatic const krb5_keyblock member_keyblock = {\n    0, ENCTYPE_ARCFOUR_HMAC,\n    16, U(\"\\xD2\\x17\\xFA\\xEA\\xE5\\xE6\\xB5\\xF9\\x5C\\xCC\\x94\\x07\\x7A\\xB8\\xA5\\xFC\")\n};\n\nstatic time_t authtime = 1120440609;\nstatic const char *user = \"w2003final$@WIN2K3.THINKER.LOCAL\";\n\n/* The S4U2Self PACs below were collected by debugging krb5-mit code on\n * Linux, talking with a Windows 2008 KDC server over the network. */\n\nstatic const unsigned char s4u_pac_regular[] = {\n    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x01, 0x00, 0x00, 0x00, 0xa0, 0x01, 0x00, 0x00,\n    0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0a, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,\n    0xf8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0c, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,\n    0x10, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x06, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,\n    0x48, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x07, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,\n    0x58, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x01, 0x10, 0x08, 0x00, 0xcc, 0xcc, 0xcc, 0xcc,\n    0x90, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0xc9, 0x36, 0xfd, 0x57,\n    0x5b, 0x59, 0xd4, 0x01, 0xc9, 0x36, 0xfd, 0x57,\n    0x5b, 0x59, 0xd4, 0x01, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0x0a, 0x00, 0x0a, 0x00,\n    0x04, 0x00, 0x02, 0x00, 0x0a, 0x00, 0x0a, 0x00,\n    0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0c, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x14, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x18, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x76, 0x04, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00,\n    0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x02, 0x00,\n    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x08, 0x00,\n    0x20, 0x00, 0x02, 0x00, 0x08, 0x00, 0x0a, 0x00,\n    0x24, 0x00, 0x02, 0x00, 0x28, 0x00, 0x02, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x10, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,\n    0x01, 0x02, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,\n    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x03, 0x00, 0x00, 0x00, 0x57, 0x00, 0x44, 0x00,\n    0x43, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n    0x41, 0x00, 0x43, 0x00, 0x4d, 0x00, 0x45, 0x00,\n    0x04, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x05, 0x15, 0x00, 0x00, 0x00,\n    0x74, 0xa0, 0x8d, 0x00, 0x3f, 0xa5, 0xc2, 0xe9,\n    0x60, 0x91, 0xe1, 0x22, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x89, 0xa1, 0x25, 0xd0, 0x59, 0xd4, 0x01,\n    0x0a, 0x00, 0x77, 0x00, 0x32, 0x00, 0x6b, 0x00,\n    0x38, 0x00, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x12, 0x00, 0x10, 0x00, 0x10, 0x00, 0x28, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x40, 0x00, 0x61, 0x00, 0x62, 0x00,\n    0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x41, 0x00, 0x43, 0x00, 0x4d, 0x00, 0x45, 0x00,\n    0x2e, 0x00, 0x43, 0x00, 0x4f, 0x00, 0x4d, 0x00,\n    0x10, 0x00, 0x00, 0x00, 0x88, 0x1d, 0x40, 0x84,\n    0x7a, 0x01, 0x7c, 0x80, 0x74, 0xe3, 0x6a, 0x6b,\n    0x76, 0xff, 0xff, 0xff, 0x1a, 0x1d, 0x97, 0xd2,\n    0x39, 0xf4, 0xb8, 0xb2, 0x53, 0xae, 0x77, 0xdb,\n    0x6c, 0x02, 0xd4, 0x3d, 0x00, 0x00, 0x00, 0x00\n};\n\nstatic const unsigned char s4u_pac_enterprise[] = {\n    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x01, 0x00, 0x00, 0x00, 0xa0, 0x01, 0x00, 0x00,\n    0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0a, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00,\n    0xf8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0c, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,\n    0x18, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x06, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,\n    0x50, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x07, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,\n    0x60, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x01, 0x10, 0x08, 0x00, 0xcc, 0xcc, 0xcc, 0xcc,\n    0x90, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0xc9, 0x36, 0xfd, 0x57,\n    0x5b, 0x59, 0xd4, 0x01, 0xc9, 0x36, 0xfd, 0x57,\n    0x5b, 0x59, 0xd4, 0x01, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0x0a, 0x00, 0x0a, 0x00,\n    0x04, 0x00, 0x02, 0x00, 0x0a, 0x00, 0x0a, 0x00,\n    0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0c, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x14, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x18, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x76, 0x04, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00,\n    0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x02, 0x00,\n    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x08, 0x00,\n    0x20, 0x00, 0x02, 0x00, 0x08, 0x00, 0x0a, 0x00,\n    0x24, 0x00, 0x02, 0x00, 0x28, 0x00, 0x02, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x10, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,\n    0x01, 0x02, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,\n    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x03, 0x00, 0x00, 0x00, 0x57, 0x00, 0x44, 0x00,\n    0x43, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n    0x41, 0x00, 0x43, 0x00, 0x4d, 0x00, 0x45, 0x00,\n    0x04, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x05, 0x15, 0x00, 0x00, 0x00,\n    0x74, 0xa0, 0x8d, 0x00, 0x3f, 0xa5, 0xc2, 0xe9,\n    0x60, 0x91, 0xe1, 0x22, 0x00, 0x00, 0x00, 0x00,\n    0x80, 0xe1, 0x9b, 0xe2, 0xe0, 0x59, 0xd4, 0x01,\n    0x12, 0x00, 0x77, 0x00, 0x32, 0x00, 0x6b, 0x00,\n    0x38, 0x00, 0x75, 0x00, 0x40, 0x00, 0x61, 0x00,\n    0x62, 0x00, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x12, 0x00, 0x10, 0x00, 0x10, 0x00, 0x28, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x40, 0x00, 0x61, 0x00, 0x62, 0x00,\n    0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x41, 0x00, 0x43, 0x00, 0x4d, 0x00, 0x45, 0x00,\n    0x2e, 0x00, 0x43, 0x00, 0x4f, 0x00, 0x4d, 0x00,\n    0x10, 0x00, 0x00, 0x00, 0xfb, 0xe5, 0x03, 0x12,\n    0x13, 0x00, 0x6c, 0x8e, 0x81, 0x97, 0x09, 0xea,\n    0x76, 0xff, 0xff, 0xff, 0xba, 0xcd, 0x3a, 0xbc,\n    0x67, 0x61, 0x16, 0x9f, 0xb8, 0x96, 0xbc, 0xe1,\n    0xbe, 0x34, 0xe1, 0x77, 0x00, 0x00, 0x00, 0x00\n};\n\nstatic const unsigned char s4u_pac_xrealm[] = {\n    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x01, 0x00, 0x00, 0x00, 0xa0, 0x01, 0x00, 0x00,\n    0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0a, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00,\n    0xf8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0c, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,\n    0x20, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x06, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,\n    0x58, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x07, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,\n    0x68, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x01, 0x10, 0x08, 0x00, 0xcc, 0xcc, 0xcc, 0xcc,\n    0x90, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0xc9, 0x36, 0xfd, 0x57,\n    0x5b, 0x59, 0xd4, 0x01, 0xc9, 0x36, 0xfd, 0x57,\n    0x5b, 0x59, 0xd4, 0x01, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0x0a, 0x00, 0x0a, 0x00,\n    0x04, 0x00, 0x02, 0x00, 0x0a, 0x00, 0x0a, 0x00,\n    0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0c, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x14, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x18, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x76, 0x04, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00,\n    0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x02, 0x00,\n    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x08, 0x00,\n    0x20, 0x00, 0x02, 0x00, 0x08, 0x00, 0x0a, 0x00,\n    0x24, 0x00, 0x02, 0x00, 0x28, 0x00, 0x02, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x10, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,\n    0x01, 0x02, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,\n    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x03, 0x00, 0x00, 0x00, 0x57, 0x00, 0x44, 0x00,\n    0x43, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n    0x41, 0x00, 0x43, 0x00, 0x4d, 0x00, 0x45, 0x00,\n    0x04, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x05, 0x15, 0x00, 0x00, 0x00,\n    0x74, 0xa0, 0x8d, 0x00, 0x3f, 0xa5, 0xc2, 0xe9,\n    0x60, 0x91, 0xe1, 0x22, 0x00, 0x00, 0x00, 0x00,\n    0x80, 0xa8, 0x60, 0x1b, 0x2b, 0x5a, 0xd4, 0x01,\n    0x1c, 0x00, 0x77, 0x00, 0x32, 0x00, 0x6b, 0x00,\n    0x38, 0x00, 0x75, 0x00, 0x40, 0x00, 0x41, 0x00,\n    0x43, 0x00, 0x4d, 0x00, 0x45, 0x00, 0x2e, 0x00,\n    0x43, 0x00, 0x4f, 0x00, 0x4d, 0x00, 0x00, 0x00,\n    0x12, 0x00, 0x10, 0x00, 0x10, 0x00, 0x28, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x40, 0x00, 0x61, 0x00, 0x62, 0x00,\n    0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x41, 0x00, 0x43, 0x00, 0x4d, 0x00, 0x45, 0x00,\n    0x2e, 0x00, 0x43, 0x00, 0x4f, 0x00, 0x4d, 0x00,\n    0x10, 0x00, 0x00, 0x00, 0x11, 0x27, 0x3a, 0xa5,\n    0x41, 0x84, 0x87, 0xdf, 0xc6, 0xd7, 0x29, 0x26,\n    0x76, 0xff, 0xff, 0xff, 0xba, 0x7c, 0x7a, 0x84,\n    0xd2, 0x2b, 0x9c, 0x58, 0xed, 0x2f, 0xdf, 0x23,\n    0x09, 0x15, 0x05, 0x6b, 0x00, 0x00, 0x00, 0x00\n};\n\nstatic const unsigned char s4u_pac_ent_xrealm[] = {\n    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x01, 0x00, 0x00, 0x00, 0xa0, 0x01, 0x00, 0x00,\n    0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0a, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00,\n    0xf8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0c, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,\n    0x28, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x06, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,\n    0x60, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x07, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,\n    0x70, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x01, 0x10, 0x08, 0x00, 0xcc, 0xcc, 0xcc, 0xcc,\n    0x90, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0xc9, 0x36, 0xfd, 0x57,\n    0x5b, 0x59, 0xd4, 0x01, 0xc9, 0x36, 0xfd, 0x57,\n    0x5b, 0x59, 0xd4, 0x01, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0x0a, 0x00, 0x0a, 0x00,\n    0x04, 0x00, 0x02, 0x00, 0x0a, 0x00, 0x0a, 0x00,\n    0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0c, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x14, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x18, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x76, 0x04, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00,\n    0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x02, 0x00,\n    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x08, 0x00,\n    0x20, 0x00, 0x02, 0x00, 0x08, 0x00, 0x0a, 0x00,\n    0x24, 0x00, 0x02, 0x00, 0x28, 0x00, 0x02, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x10, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,\n    0x01, 0x02, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,\n    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x03, 0x00, 0x00, 0x00, 0x57, 0x00, 0x44, 0x00,\n    0x43, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n    0x41, 0x00, 0x43, 0x00, 0x4d, 0x00, 0x45, 0x00,\n    0x04, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x05, 0x15, 0x00, 0x00, 0x00,\n    0x74, 0xa0, 0x8d, 0x00, 0x3f, 0xa5, 0xc2, 0xe9,\n    0x60, 0x91, 0xe1, 0x22, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x87, 0x39, 0x5b, 0x4f, 0x5a, 0xd4, 0x01,\n    0x24, 0x00, 0x77, 0x00, 0x32, 0x00, 0x6b, 0x00,\n    0x38, 0x00, 0x75, 0x00, 0x40, 0x00, 0x61, 0x00,\n    0x62, 0x00, 0x63, 0x00, 0x40, 0x00, 0x41, 0x00,\n    0x43, 0x00, 0x4d, 0x00, 0x45, 0x00, 0x2e, 0x00,\n    0x43, 0x00, 0x4f, 0x00, 0x4d, 0x00, 0x00, 0x00,\n    0x12, 0x00, 0x10, 0x00, 0x10, 0x00, 0x28, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x40, 0x00, 0x61, 0x00, 0x62, 0x00,\n    0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x41, 0x00, 0x43, 0x00, 0x4d, 0x00, 0x45, 0x00,\n    0x2e, 0x00, 0x43, 0x00, 0x4f, 0x00, 0x4d, 0x00,\n    0x10, 0x00, 0x00, 0x00, 0xa3, 0x5d, 0xc5, 0xfe,\n    0x80, 0x6b, 0x62, 0x0c, 0xb1, 0x2f, 0x43, 0xa2,\n    0x76, 0xff, 0xff, 0xff, 0x95, 0x40, 0x76, 0xe4,\n    0x0a, 0x0a, 0xb9, 0xe7, 0x93, 0x0f, 0x05, 0xf8,\n    0x8a, 0x81, 0x9c, 0x9c, 0x00, 0x00, 0x00, 0x00\n};\n\nstatic const char *s4u_principal = \"w2k8u@ACME.COM\";\nstatic const char *s4u_enterprise = \"w2k8u@abc@ACME.COM\";\n\nstatic const krb5_keyblock s4u_srv_key = {\n    0, ENCTYPE_AES256_CTS_HMAC_SHA1_96,\n    32, U(\"\\x14\\xDF\\xB5\\xB2\\xCD\\xB4\\x2C\\x88\\x94\\xDA\\x2F\\xA8\\x82\\xE9\\x72\\x9F\"\n          \"\\x4A\\x4D\\xC7\\x4B\\xA0\\x2A\\x24\\x2C\\xC6\\xA8\\xD7\\x10\\x79\\xB9\\xAD\\x9A\")\n};\n\nstatic const krb5_keyblock s4u_tgt_srv_key = {\n    0, ENCTYPE_AES256_CTS_HMAC_SHA1_96,\n    32, U(\"\\x42\\x0C\\x39\\xC5\\x1A\\x17\\x54\\x04\\x45\\x1F\\x95\\x6B\\x8C\\x58\\xE0\\xF4\"\n          \"\\x1B\\xCA\\x66\\x9A\\x64\\x47\\x95\\xCA\\x6E\\x3A\\xD5\\x5A\\x3B\\x91\\x8C\\x9F\")\n};\n\nstatic size_t s4u_logon_info_buffer_len = 416;\n\nstruct pac_and_info {\n    time_t authtime;\n    krb5_boolean is_enterprise;\n    krb5_boolean is_xrealm;\n    const unsigned char *data;\n    size_t length;\n};\n\nstatic const struct pac_and_info s4u_pacs[] = {\n    { 1538430362, 0, 0, s4u_pac_regular, sizeof(s4u_pac_regular) },\n    { 1538437551, 1, 0, s4u_pac_enterprise, sizeof(s4u_pac_enterprise) },\n    { 1538469429, 0, 1, s4u_pac_xrealm, sizeof(s4u_pac_xrealm) },\n    { 1538484998, 1, 1, s4u_pac_ent_xrealm, sizeof(s4u_pac_ent_xrealm) },\n    { 0, 0, 0, NULL, 0 }\n};\n\n#if !defined(__cplusplus) && (__GNUC__ > 2)\nstatic void err(krb5_context ctx, krb5_error_code code, const char *fmt, ...)\n    __attribute__((__format__(__printf__, 3, 0)));\n#endif\n\nstatic void\nerr(krb5_context ctx, krb5_error_code code, const char *fmt, ...)\n{\n    va_list ap;\n    char *msg;\n    const char *errmsg = NULL;\n\n    va_start(ap, fmt);\n    if (vasprintf(&msg, fmt, ap) < 0)\n        exit(1);\n    va_end(ap);\n    if (ctx && code)\n        errmsg = krb5_get_error_message(ctx, code);\n    if (errmsg)\n        fprintf(stderr, \"t_pac: %s: %s\\n\", msg, errmsg);\n    else\n        fprintf(stderr, \"t_pac: %s\\n\", msg);\n    exit(1);\n}\n\nstatic void\ncheck_pac(krb5_context context, int index, const unsigned char *pdata,\n          size_t plen, time_t auth_time, krb5_principal p,\n          size_t type_one_buffer_length, krb5_boolean with_realm,\n          const krb5_keyblock *server_key, const krb5_keyblock *kdc_key)\n{\n    krb5_error_code ret;\n    const krb5_keyblock *kdc_sign_key;\n    krb5_data data;\n    krb5_pac pac;\n\n    /* If we don't have the KDC key (S4U cases), just use another key as we'd\n     * skip the KDC signature when verifying. */\n    kdc_sign_key = (kdc_key == NULL) ? &kdc_keyblock : kdc_key;\n\n    ret = krb5_pac_parse(context, pdata, plen, &pac);\n    if (ret)\n        err(context, ret, \"[pac: %d] krb5_pac_parse\", index);\n\n    ret = krb5_pac_verify_ext(context, pac, auth_time, p, server_key, kdc_key,\n                              with_realm);\n    if (ret)\n        err(context, ret, \"[pac: %d] krb5_pac_verify_ext\", index);\n\n    ret = krb5_pac_sign_ext(context, pac, auth_time, p, server_key,\n                            kdc_sign_key, with_realm, &data);\n    if (ret)\n        err(context, ret, \"[pac: %d] krb5_pac_sign_ext\", index);\n\n    krb5_pac_free(context, pac);\n\n    ret = krb5_pac_parse(context, data.data, data.length, &pac);\n    krb5_free_data_contents(context, &data);\n    if (ret)\n        err(context, ret, \"[pac: %d] krb5_pac_parse 2\", index);\n\n    ret = krb5_pac_verify_ext(context, pac, auth_time, p, server_key, kdc_key,\n                              with_realm);\n    if (ret)\n        err(context, ret, \"[pac: %d] krb5_pac_verify_ext 2\", index);\n\n    /* make a copy and try to reproduce it */\n    {\n        uint32_t *list;\n        size_t len, i;\n        krb5_pac pac2;\n\n        ret = krb5_pac_init(context, &pac2);\n        if (ret)\n            err(context, ret, \"[pac: %d] krb5_pac_init\", index);\n\n        /* our two user buffer plus the three \"system\" buffers */\n        ret = krb5_pac_get_types(context, pac, &len, &list);\n        if (ret)\n            err(context, ret, \"[pac: %d] krb5_pac_get_types\", index);\n\n        for (i = 0; i < len; i++) {\n            /* skip server_cksum, privsvr_cksum, and logon_name */\n            if (list[i] == 6 || list[i] == 7 || list[i] == 10)\n                continue;\n\n            ret = krb5_pac_get_buffer(context, pac, list[i], &data);\n            if (ret)\n                err(context, ret, \"[pac: %d] krb5_pac_get_buffer\", index);\n\n            if (list[i] == 1) {\n                if (type_one_buffer_length != data.length) {\n                    err(context, 0, \"[pac: %d] type 1 have wrong length: %lu\",\n                        index, (unsigned long)data.length);\n                }\n            } else if (list[i] != 12) {\n                err(context, 0, \"[pac: %d] unknown type %lu\",\n                    index, (unsigned long)list[i]);\n            }\n\n            ret = krb5_pac_add_buffer(context, pac2, list[i], &data);\n            if (ret)\n                err(context, ret, \"[pac: %d] krb5_pac_add_buffer\", index);\n            krb5_free_data_contents(context, &data);\n        }\n        free(list);\n\n        ret = krb5_pac_sign_ext(context, pac2, auth_time, p, server_key,\n                                kdc_sign_key, with_realm, &data);\n        if (ret)\n            err(context, ret, \"[pac: %d] krb5_pac_sign_ext 4\", index);\n\n        krb5_pac_free(context, pac2);\n\n        ret = krb5_pac_parse(context, data.data, data.length, &pac2);\n        if (ret)\n            err(context, ret, \"[pac: %d] krb5_pac_parse 4\", index);\n\n        ret = krb5_pac_verify_ext(context, pac2, auth_time, p, server_key,\n                                  kdc_key, with_realm);\n        if (ret)\n            err(context, ret, \"[pac: %d] krb5_pac_verify_ext 4\", index);\n\n        krb5_free_data_contents(context, &data);\n\n        krb5_pac_free(context, pac2);\n    }\n\n    krb5_pac_free(context, pac);\n}\n\nstatic const krb5_keyblock ticket_sig_krbtgt_key = {\n    0, ENCTYPE_AES256_CTS_HMAC_SHA1_96,\n    32, U(\"\\x7a\\x58\\x98\\xd2\\xaf\\xa6\\xaf\\xc0\\x6a\\xce\\x06\\x04\\x4b\\xc2\\x70\\x84\"\n          \"\\x9b\\x8e\\x0a\\x6c\\x4c\\x07\\xdc\\x6f\\xbb\\x48\\x43\\xe1\\xd2\\xaa\\x97\\xf7\")\n};\n\nstatic const krb5_keyblock ticket_sig_server_key = {\n    0, ENCTYPE_ARCFOUR_HMAC,\n    16, U(\"\\xed\\x23\\x11\\x20\\x7a\\x21\\x44\\x20\\xbf\\xc0\\x8d\\x36\\xf7\\xf6\\xb2\\x3e\")\n};\n\nstatic const krb5_data ticket_data = {\n    .length = 972, .data =\n    \"\\x61\\x82\\x03\\xC8\\x30\\x82\\x03\\xC4\\xA0\\x03\\x02\\x01\\x05\\xA1\\x0A\\x1B\"\n    \"\\x08\\x43\\x44\\x4F\\x4D\\x2E\\x43\\x4F\\x4D\\xA2\\x0F\\x30\\x0D\\xA0\\x03\\x02\"\n    \"\\x01\\x01\\xA1\\x06\\x30\\x04\\x1B\\x02\\x73\\x31\\xA3\\x82\\x03\\x9E\\x30\\x82\"\n    \"\\x03\\x9A\\xA0\\x03\\x02\\x01\\x17\\xA1\\x03\\x02\\x01\\x03\\xA2\\x82\\x03\\x8C\"\n    \"\\x04\\x82\\x03\\x88\\x44\\x31\\x61\\x20\\x17\\xC9\\xFE\\xBC\\xAC\\x46\\xB5\\x77\"\n    \"\\xE9\\x68\\x04\\x4C\\x9B\\x31\\x91\\x0C\\xC1\\xD4\\xDD\\xEF\\xC7\\x34\\x20\\x08\"\n    \"\\x90\\x91\\xE8\\x79\\xE0\\xB5\\x03\\x26\\xA4\\x65\\xDE\\xEC\\x47\\x03\\x2A\\x8F\"\n    \"\\x61\\xE7\\x4D\\x38\\x5A\\x42\\x95\\x5A\\xF9\\x2F\\x41\\x2C\\x2A\\x6E\\x60\\xA1\"\n    \"\\xEB\\x51\\xB3\\xBD\\x4C\\x00\\x41\\x2A\\x44\\x76\\x08\\x37\\x1A\\x51\\xFD\\x65\"\n    \"\\x67\\x7E\\xBF\\x3D\\x90\\x86\\xE3\\x9A\\x54\\x6B\\x67\\xA8\\x08\\x7A\\x73\\xCC\"\n    \"\\xC3\\xB7\\x4B\\xD5\\x5C\\x3A\\x14\\x6C\\xC1\\x5F\\x54\\x4B\\x92\\x55\\xB4\\xB7\"\n    \"\\x92\\x23\\x3F\\x53\\x89\\x47\\x8E\\x1F\\x8B\\xB9\\xDB\\x3B\\x93\\xE8\\x70\\xE4\"\n    \"\\x24\\xB8\\x9D\\xF0\\x0E\\x35\\x28\\xF8\\x7A\\x27\\x5D\\xF7\\x25\\x97\\x9C\\xF5\"\n    \"\\x9F\\x9F\\x64\\x04\\xF2\\xA3\\xAB\\x11\\x15\\xB6\\xDA\\x18\\xD6\\x46\\xD5\\xE6\"\n    \"\\xB8\\x08\\xDE\\x0A\\x62\\xFD\\xF8\\xAA\\x52\\x90\\xD9\\x67\\x29\\xB2\\xCD\\x06\"\n    \"\\xB6\\xB0\\x50\\x2B\\x3F\\x0F\\xA3\\xA5\\xBF\\xAA\\x6E\\x40\\x03\\xD6\\x5F\\x02\"\n    \"\\xBC\\xD8\\x18\\x47\\x97\\x09\\xD7\\xE4\\x96\\x3B\\xCB\\xEB\\x92\\x2C\\x3C\\x49\"\n    \"\\xFF\\x1F\\x71\\xE0\\x52\\x94\\x0F\\x8B\\x9F\\xB8\\x2A\\xBB\\x9C\\xE2\\xA3\\xDD\"\n    \"\\x38\\x89\\xE2\\xB1\\x0B\\x9E\\x1F\\x7A\\xB3\\xE3\\xD2\\xB0\\x94\\xDC\\x87\\xBE\"\n    \"\\x37\\xA6\\xD3\\xB3\\x29\\x35\\x9A\\x72\\xC3\\x7A\\xF1\\xA9\\xE6\\xC5\\xD1\\x26\"\n    \"\\x83\\x65\\x44\\x17\\xBA\\x55\\xA8\\x5E\\x94\\x26\\xED\\xE9\\x8A\\x93\\x11\\x5D\"\n    \"\\x7E\\x20\\x1B\\x9C\\x15\\x9E\\x13\\x37\\x03\\x4D\\xDD\\x99\\x51\\xD8\\x66\\x29\"\n    \"\\x6A\\xB9\\xFB\\x49\\xFE\\x52\\x78\\xDA\\x86\\x85\\xA9\\xA3\\xB9\\xEF\\xEC\\xAD\"\n    \"\\x35\\xA6\\x8D\\xAC\\x0F\\x75\\x22\\xBB\\x0B\\x49\\x1C\\x13\\x52\\x40\\xC9\\x52\"\n    \"\\x69\\x09\\x54\\xD1\\x0F\\x94\\x3F\\x22\\x48\\x67\\xB0\\x96\\x28\\xAA\\xE6\\x28\"\n    \"\\xD9\\x0C\\x08\\xEF\\x51\\xED\\x15\\x5E\\xA2\\x53\\x59\\xA5\\x03\\xB4\\x06\\x20\"\n    \"\\x3D\\xCC\\xB4\\xC5\\xF8\\x8C\\x73\\x67\\xA3\\x21\\x3D\\x19\\xCD\\xD4\\x12\\x28\"\n    \"\\xD2\\x93\\xDE\\x0D\\xF0\\x71\\x10\\x50\\xD6\\x33\\x35\\x04\\x11\\x64\\x43\\x39\"\n    \"\\xC3\\xDF\\x96\\xE3\\x66\\xE3\\x85\\xCA\\xE7\\x67\\x14\\x3A\\xF0\\x43\\xAA\\xBB\"\n    \"\\xD4\\x1D\\xB5\\x24\\xB5\\x74\\x90\\x25\\xA7\\x87\\x7E\\xDB\\xD3\\x83\\x8A\\x3A\"\n    \"\\x69\\xA8\\x2D\\xAF\\xB7\\xB8\\xF3\\xDC\\x13\\xAF\\x45\\x61\\x3F\\x59\\x39\\x7E\"\n    \"\\x69\\xDE\\x0C\\x04\\xF1\\x10\\x6B\\xB4\\x56\\xFA\\x21\\x9F\\x72\\x2B\\x60\\x86\"\n    \"\\xE3\\x23\\x0E\\xC4\\x51\\xF6\\xBE\\xD8\\xE1\\x5F\\xEE\\x73\\x4C\\x17\\x4C\\x2C\"\n    \"\\x1B\\xFB\\x9F\\x1F\\x7A\\x3B\\x07\\x5B\\x8E\\xF1\\x01\\xAC\\xD6\\x30\\x94\\x8A\"\n    \"\\x5D\\x22\\x6F\\x08\\xCE\\xED\\x5E\\xB6\\xDB\\x86\\x8C\\x87\\xEB\\x8D\\x91\\xFF\"\n    \"\\x0A\\x86\\x30\\xBD\\xC0\\xF8\\x25\\xE7\\xAE\\x24\\x35\\xF2\\xFC\\xE5\\xFD\\x1B\"\n    \"\\xB0\\x05\\x4A\\xA3\\xE5\\xEB\\x2E\\x05\\xAD\\x99\\x67\\x49\\x87\\xE6\\xB3\\x87\"\n    \"\\x82\\xA4\\x59\\xA7\\x6E\\xDD\\xF2\\xB6\\x66\\xE8\\xF7\\x70\\xF5\\xBD\\xC9\\x0E\"\n    \"\\xFA\\x9C\\x79\\x84\\xD4\\x9B\\x05\\x0E\\xBB\\xF5\\xDB\\xEF\\xFC\\xCC\\x26\\xF2\"\n    \"\\x93\\xCF\\xD2\\x04\\x3C\\xA9\\x2C\\x65\\x42\\x97\\x86\\xD8\\x38\\x0A\\x1E\\xF6\"\n    \"\\xD6\\xCA\\x30\\xB5\\x1A\\xEC\\xFB\\xBA\\x3B\\x84\\x57\\xB0\\xFD\\xFB\\xE6\\xBC\"\n    \"\\xF2\\x76\\xF6\\x4C\\xBB\\xAB\\xB1\\x31\\xA1\\x27\\x7C\\xE6\\xE6\\x81\\xB6\\xCE\"\n    \"\\x84\\x86\\x40\\xB6\\x40\\x33\\xC4\\xF8\\xB4\\x15\\xCF\\xAA\\xA5\\x51\\x78\\xB9\"\n    \"\\x8B\\x50\\x25\\xB2\\x88\\x86\\x96\\x72\\x8C\\x71\\x4D\\xB5\\x3A\\x94\\x86\\x77\"\n    \"\\x0E\\x95\\x9B\\x16\\x93\\xEF\\x3A\\x11\\x79\\xBA\\x83\\xF7\\x74\\xD3\\x8D\\xBA\"\n    \"\\x15\\xE1\\x2C\\x04\\x57\\xA8\\x92\\x1E\\x9D\\x00\\x8E\\x20\\xFD\\x30\\x70\\xE7\"\n    \"\\xF5\\x65\\x2F\\x19\\x0C\\x94\\xBA\\x03\\x71\\x12\\x96\\xCD\\xC8\\xB4\\x96\\xDB\"\n    \"\\xCE\\x19\\xC2\\xDF\\x3C\\xC2\\xF6\\x3D\\x53\\xED\\x98\\xA5\\x41\\x72\\x2A\\x22\"\n    \"\\x7B\\xF3\\x2B\\x17\\x6C\\xE1\\x39\\x7D\\xAE\\x9B\\x11\\xF9\\xC1\\xA6\\x9E\\x9F\"\n    \"\\x89\\x3C\\x12\\xAA\\x94\\x74\\xA7\\x4F\\x70\\xE8\\xB9\\xDE\\x04\\xF0\\x9D\\x39\"\n    \"\\x24\\x2D\\x92\\xE8\\x46\\x2D\\x2E\\xF0\\x40\\x66\\x1A\\xD9\\x27\\xF9\\x98\\xF1\"\n    \"\\x81\\x1D\\x70\\x62\\x63\\x30\\x6D\\xCD\\x84\\x04\\x5F\\xFA\\x83\\xD3\\xEC\\x8D\"\n    \"\\x86\\xFB\\x40\\x61\\xC1\\x8A\\x45\\xFF\\x7B\\xD9\\xD4\\x18\\x61\\x7F\\x51\\xE3\"\n    \"\\xFC\\x1E\\x18\\xF0\\xAF\\xC6\\x18\\x2C\\xE1\\x6D\\x5D\\xF9\\x62\\xFC\\x20\\xA3\"\n    \"\\xB2\\x8A\\x5F\\xE5\\xBB\\x29\\x0F\\x99\\x63\\x07\\x88\\x38\\x3A\\x3B\\x73\\x2A\"\n    \"\\x6D\\xDA\\x3D\\xA8\\x0D\\x8F\\x56\\x41\\x89\\x82\\xE5\\xB8\\x61\\x00\\x64\\x7D\"\n    \"\\x17\\x0C\\xCE\\x03\\x55\\x8F\\xF4\\x5B\\x0D\\x50\\xF2\\xEB\\x05\\x67\\xBE\\xDB\"\n    \"\\x7B\\x75\\xC5\\xEA\\xA1\\xAB\\x1D\\xB0\\x3C\\x6D\\x42\\x08\\x0B\\x9A\\x45\\x20\"\n    \"\\xA8\\x8F\\xE5\\x67\\x47\\x30\\xDE\\x93\\x5F\\x43\\x05\\xEB\\xA8\\x2D\\x80\\xF5\"\n    \"\\x1A\\xB8\\x4A\\x4E\\x42\\x2D\\x0B\\x7A\\xDC\\x46\\x20\\x2D\\x13\\x17\\xDD\\x4B\"\n    \"\\x94\\x96\\xAA\\x1F\\x06\\x0C\\x1F\\x62\\x07\\x9C\\x40\\xA1\"\n};\n\nstatic void\ntest_pac_ticket_signature(krb5_context context)\n{\n    krb5_error_code ret;\n    krb5_ticket *ticket;\n    krb5_principal sprinc;\n    krb5_authdata **authdata1, **authdata2;\n    krb5_pac pac, pac2, pac3;\n    uint32_t *list;\n    size_t len, i;\n    krb5_data data;\n\n    ret = krb5_decode_ticket(&ticket_data, &ticket);\n    if (ret)\n        err(context, ret, \"while decoding ticket\");\n\n    ret = krb5_decrypt_tkt_part(context, &ticket_sig_server_key, ticket);\n    if (ret)\n        err(context, ret, \"while decrypting ticket\");\n\n    ret = krb5_parse_name(context, \"s1@CDOM.COM\", &sprinc);\n    if (ret)\n        err(context, ret, \"krb5_parse_name\");\n\n    ret = krb5_kdc_verify_ticket(context, ticket->enc_part2, sprinc,\n                                 &ticket_sig_server_key,\n                                 &ticket_sig_krbtgt_key, &pac);\n    if (ret)\n        err(context, ret, \"while verifying ticket\");\n\n    /* In this test, the server is also the client. */\n    ret = krb5_pac_verify(context, pac, ticket->enc_part2->times.authtime,\n                          ticket->server, NULL, NULL);\n    if (ret)\n        err(context, ret, \"while verifying PAC client info\");\n\n    /* We know there is only a PAC in this test's ticket. */\n    authdata1 = ticket->enc_part2->authorization_data;\n    ticket->enc_part2->authorization_data = NULL;\n\n    ret = krb5_kdc_sign_ticket(context, ticket->enc_part2, pac, sprinc,\n                               sprinc, &ticket_sig_server_key,\n                               &ticket_sig_krbtgt_key, FALSE);\n    if (ret)\n        err(context, ret, \"while signing ticket\");\n\n    authdata2 = ticket->enc_part2->authorization_data;\n    assert(authdata2 != NULL);\n    assert(authdata2[1] == NULL);\n\n    assert(authdata1[0]->length == authdata2[0]->length);\n    assert(memcmp(authdata1[0]->contents, authdata2[0]->contents,\n                  authdata1[0]->length) == 0);\n\n    /* Test adding signatures to a new PAC. */\n    ret = krb5_pac_init(context, &pac2);\n    if (ret)\n        err(context, ret, \"krb5_pac_init\");\n\n    ret = krb5_pac_get_types(context, pac, &len, &list);\n    if (ret)\n        err(context, ret, \"krb5_pac_get_types\");\n\n    for (i = 0; i < len; i++) {\n        /* Skip server_cksum, privsvr_cksum, and ticket_cksum. */\n        if (list[i] == 6 || list[i] == 7 || list[i] == 16)\n            continue;\n\n        ret = krb5_pac_get_buffer(context, pac, list[i], &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_get_buffer\");\n\n        ret = krb5_pac_add_buffer(context, pac2, list[i], &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_add_buffer\");\n\n        krb5_free_data_contents(context, &data);\n    }\n    free(list);\n\n    krb5_free_authdata(context, authdata1);\n    krb5_free_authdata(context, ticket->enc_part2->authorization_data);\n    ticket->enc_part2->authorization_data = NULL;\n\n    ret = krb5_kdc_sign_ticket(context, ticket->enc_part2, pac2, sprinc, NULL,\n                               &ticket_sig_server_key, &ticket_sig_krbtgt_key,\n                               FALSE);\n    if (ret)\n        err(context, ret, \"while signing ticket\");\n\n    /* We can't compare the data since the order of the buffers may differ. */\n    ret = krb5_kdc_verify_ticket(context, ticket->enc_part2, sprinc,\n                                 &ticket_sig_server_key,\n                                 &ticket_sig_krbtgt_key, &pac3);\n    if (ret)\n        err(context, ret, \"while verifying ticket\");\n\n    krb5_pac_free(context, pac);\n    krb5_pac_free(context, pac2);\n    krb5_pac_free(context, pac3);\n    krb5_free_principal(context, sprinc);\n    krb5_free_ticket(context, ticket);\n}\n\nint\nmain(int argc, char **argv)\n{\n    krb5_error_code ret;\n    krb5_context context;\n    krb5_pac pac;\n    krb5_data data;\n    krb5_principal p;\n\n    ret = krb5_init_context(&context);\n    if (ret)\n        err(NULL, 0, \"krb5_init_contex\");\n\n    test_pac_ticket_signature(context);\n\n    ret = krb5_set_default_realm(context, \"WIN2K3.THINKER.LOCAL\");\n    if (ret)\n        err(context, ret, \"krb5_set_default_realm\");\n\n    ret = krb5_parse_name(context, user, &p);\n    if (ret)\n        err(context, ret, \"krb5_parse_name\");\n\n    /* Check a pre-saved PAC. */\n    check_pac(context, -1, saved_pac, sizeof(saved_pac), authtime, p,\n              type_1_length, 0, &member_keyblock, &kdc_keyblock);\n\n    /* Check S4U2Self PACs. */\n    {\n        krb5_principal sp;\n        krb5_principal sep;\n        const struct pac_and_info *pi;\n\n        ret = krb5_parse_name(context, s4u_principal, &sp);\n        if (ret)\n            err(context, ret, \"krb5_parse_name\");\n\n        ret = krb5_parse_name_flags(context, s4u_enterprise,\n                                    KRB5_PRINCIPAL_PARSE_ENTERPRISE, &sep);\n        if (ret)\n            err(context, ret, \"krb5_parse_name_flags\");\n\n        for (pi = s4u_pacs; pi->data != NULL; pi++) {\n            check_pac(context, pi - s4u_pacs, pi->data, pi->length,\n                      pi->authtime, pi->is_enterprise ? sep : sp,\n                      s4u_logon_info_buffer_len, pi->is_xrealm,\n                      pi->is_xrealm ? &s4u_tgt_srv_key : &s4u_srv_key, NULL);\n        }\n\n        krb5_free_principal(context, sp);\n        krb5_free_principal(context, sep);\n    }\n\n    /*\n     * Test empty free\n     */\n\n    ret = krb5_pac_init(context, &pac);\n    if (ret)\n        err(context, ret, \"krb5_pac_init\");\n    krb5_pac_free(context, pac);\n\n    /*\n     * Test add remove buffer\n     */\n\n    ret = krb5_pac_init(context, &pac);\n    if (ret)\n        err(context, ret, \"krb5_pac_init\");\n\n    {\n        const krb5_data cdata = { 0, 2, \"\\x00\\x01\" } ;\n\n        ret = krb5_pac_add_buffer(context, pac, 1, &cdata);\n        if (ret)\n            err(context, ret, \"krb5_pac_add_buffer\");\n    }\n    {\n        ret = krb5_pac_get_buffer(context, pac, 1, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_get_buffer\");\n        if (data.length != 2 || memcmp(data.data, \"\\x00\\x01\", 2) != 0)\n            err(context, 0, \"krb5_pac_get_buffer data not the same\");\n        krb5_free_data_contents(context, &data);\n    }\n\n    {\n        const krb5_data cdata = { 0, 2, \"\\x02\\x00\" } ;\n\n        ret = krb5_pac_add_buffer(context, pac, 2, &cdata);\n        if (ret)\n            err(context, ret, \"krb5_pac_add_buffer\");\n    }\n    {\n        ret = krb5_pac_get_buffer(context, pac, 1, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_get_buffer\");\n        if (data.length != 2 || memcmp(data.data, \"\\x00\\x01\", 2) != 0)\n            err(context, 0, \"krb5_pac_get_buffer data not the same\");\n        krb5_free_data_contents(context, &data);\n        /* */\n        ret = krb5_pac_get_buffer(context, pac, 2, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_get_buffer\");\n        if (data.length != 2 || memcmp(data.data, \"\\x02\\x00\", 2) != 0)\n            err(context, 0, \"krb5_pac_get_buffer data not the same\");\n        krb5_free_data_contents(context, &data);\n    }\n\n    ret = krb5_pac_sign(context, pac, authtime, p,\n                        &member_keyblock, &kdc_keyblock, &data);\n    if (ret)\n        err(context, ret, \"krb5_pac_sign\");\n\n    krb5_pac_free(context, pac);\n\n    ret = krb5_pac_parse(context, data.data, data.length, &pac);\n    krb5_free_data_contents(context, &data);\n    if (ret)\n        err(context, ret, \"krb5_pac_parse 3\");\n\n    ret = krb5_pac_verify(context, pac, authtime, p,\n                          &member_keyblock, &kdc_keyblock);\n    if (ret)\n        err(context, ret, \"krb5_pac_verify 3\");\n\n    {\n        uint32_t *list;\n        size_t len;\n\n        /* our two user buffer plus the three \"system\" buffers */\n        ret = krb5_pac_get_types(context, pac, &len, &list);\n        if (ret)\n            err(context, ret, \"krb5_pac_get_types\");\n        if (len != 5)\n            err(context, 0, \"list wrong length\");\n        free(list);\n    }\n\n    {\n        krb5_principal ep, np;\n\n        ret = krb5_parse_name_flags(context, user,\n                                    KRB5_PRINCIPAL_PARSE_ENTERPRISE, &ep);\n        if (ret)\n            err(context, ret, \"krb5_parse_name_flags\");\n\n        ret = krb5_copy_principal(context, ep, &np);\n        if (ret)\n            err(context, ret, \"krb5_copy_principal\");\n        np->type = KRB5_NT_MS_PRINCIPAL;\n\n        /* Try to verify as enterprise. */\n        ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock,\n                              &kdc_keyblock);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify should have failed\");\n\n        ret = krb5_pac_sign(context, pac, authtime, ep, &member_keyblock,\n                            &kdc_keyblock, &data);\n        if (!ret)\n            err(context, ret, \"krb5_pac_sign should have failed\");\n\n        /* Try to verify with realm. */\n        ret = krb5_pac_verify_ext(context, pac, authtime, p, &member_keyblock,\n                                  &kdc_keyblock, TRUE);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify_ext with realm should fail\");\n\n        /* Currently we can't re-sign the PAC with realm (although that could\n         * be useful), only sign a new one. */\n        ret = krb5_pac_sign_ext(context, pac, authtime, p, &member_keyblock,\n                                &kdc_keyblock, TRUE, &data);\n        if (!ret)\n            err(context, ret, \"krb5_pac_sign_ext with realm should fail\");\n\n        krb5_pac_free(context, pac);\n\n        /* Test enterprise. */\n        ret = krb5_pac_init(context, &pac);\n        if (ret)\n            err(context, ret, \"krb5_pac_init\");\n\n        ret = krb5_pac_sign(context, pac, authtime, ep, &member_keyblock,\n                            &kdc_keyblock, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_sign enterprise failed\");\n\n        krb5_pac_free(context, pac);\n\n        ret = krb5_pac_parse(context, data.data, data.length, &pac);\n        krb5_free_data_contents(context, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_parse failed\");\n\n        ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock,\n                              &kdc_keyblock);\n        if (ret)\n            err(context, ret, \"krb5_pac_verify enterprise failed\");\n\n        /* Also verify enterprise as KRB5_NT_MS_PRINCIPAL. */\n        ret = krb5_pac_verify(context, pac, authtime, np, &member_keyblock,\n                              &kdc_keyblock);\n        if (ret)\n            err(context, ret, \"krb5_pac_verify enterprise as nt-ms failed\");\n\n        ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock,\n                              &kdc_keyblock);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify should have failed\");\n\n        krb5_pac_free(context, pac);\n\n        /* Test nt-ms-principal. */\n        ret = krb5_pac_init(context, &pac);\n        if (ret)\n            err(context, ret, \"krb5_pac_init\");\n\n        ret = krb5_pac_sign(context, pac, authtime, np, &member_keyblock,\n                            &kdc_keyblock, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_sign enterprise failed\");\n\n        krb5_pac_free(context, pac);\n\n        ret = krb5_pac_parse(context, data.data, data.length, &pac);\n        krb5_free_data_contents(context, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_parse failed\");\n\n        ret = krb5_pac_verify(context, pac, authtime, np, &member_keyblock,\n                              &kdc_keyblock);\n        if (ret)\n            err(context, ret, \"krb5_pac_verify enterprise failed\");\n\n        /* Also verify as enterprise principal. */\n        ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock,\n                              &kdc_keyblock);\n        if (ret)\n            err(context, ret, \"krb5_pac_verify nt-ms as enterprise failed\");\n\n        ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock,\n                              &kdc_keyblock);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify should have failed\");\n\n        krb5_pac_free(context, pac);\n\n        /* Test with realm. */\n        ret = krb5_pac_init(context, &pac);\n        if (ret)\n            err(context, ret, \"krb5_pac_init\");\n\n        ret = krb5_pac_sign_ext(context, pac, authtime, p, &member_keyblock,\n                                &kdc_keyblock, TRUE, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_sign_ext with realm failed\");\n\n        krb5_pac_free(context, pac);\n\n        ret = krb5_pac_parse(context, data.data, data.length, &pac);\n        krb5_free_data_contents(context, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_parse failed\");\n\n        ret = krb5_pac_verify_ext(context, pac, authtime, p, &member_keyblock,\n                                  &kdc_keyblock, TRUE);\n        if (ret)\n            err(context, ret, \"krb5_pac_verify_ext with realm failed\");\n\n        ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock,\n                              &kdc_keyblock);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify should have failed\");\n\n        krb5_pac_free(context, pac);\n\n        /* Test enterprise with realm. */\n        ret = krb5_pac_init(context, &pac);\n        if (ret)\n            err(context, ret, \"krb5_pac_init\");\n\n        ret = krb5_pac_sign_ext(context, pac, authtime, ep, &member_keyblock,\n                                &kdc_keyblock, TRUE, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_sign_ext ent with realm failed\");\n\n        krb5_pac_free(context, pac);\n\n        ret = krb5_pac_parse(context, data.data, data.length, &pac);\n        krb5_free_data_contents(context, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_parse failed\");\n\n        ret = krb5_pac_verify_ext(context, pac, authtime, ep, &member_keyblock,\n                                  &kdc_keyblock, TRUE);\n        if (ret)\n            err(context, ret, \"krb5_pac_verify_ext ent with realm failed\");\n\n        ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock,\n                              &kdc_keyblock);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify should have failed\");\n\n        ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock,\n                              &kdc_keyblock);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify should have failed\");\n\n        ret = krb5_pac_verify_ext(context, pac, authtime, p, &member_keyblock,\n                                  &kdc_keyblock, TRUE);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify_ext should have failed\");\n\n        krb5_free_principal(context, ep);\n        krb5_free_principal(context, np);\n    }\n\n    krb5_pac_free(context, pac);\n\n    krb5_free_principal(context, p);\n    krb5_free_context(context);\n\n    return 0;\n}\n"], "fixing_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* lib/krb5/krb/pac.c */\n/*\n * Copyright 2008 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n\n#include \"k5-int.h\"\n#include \"int-proto.h\"\n#include \"authdata.h\"\n\n#define MAX_BUFFERS 4096\n\n/* draft-brezak-win2k-krb-authz-00 */\n\n/*\n * Add a buffer to the provided PAC and update header.\n */\nkrb5_error_code\nk5_pac_add_buffer(krb5_context context,\n                  krb5_pac pac,\n                  krb5_ui_4 type,\n                  const krb5_data *data,\n                  krb5_boolean zerofill,\n                  krb5_data *out_data)\n{\n    PACTYPE *header;\n    size_t header_len, i, pad = 0;\n    char *pac_data;\n\n    assert((data->data == NULL) == zerofill);\n\n    /* Check there isn't already a buffer of this type */\n    if (k5_pac_locate_buffer(context, pac, type, NULL) == 0) {\n        return EEXIST;\n    }\n\n    header = (PACTYPE *)realloc(pac->pac,\n                                sizeof(PACTYPE) +\n                                (pac->pac->cBuffers * sizeof(PAC_INFO_BUFFER)));\n    if (header == NULL) {\n        return ENOMEM;\n    }\n    pac->pac = header;\n\n    header_len = PACTYPE_LENGTH + (pac->pac->cBuffers * PAC_INFO_BUFFER_LENGTH);\n\n    if (data->length % PAC_ALIGNMENT)\n        pad = PAC_ALIGNMENT - (data->length % PAC_ALIGNMENT);\n\n    pac_data = realloc(pac->data.data,\n                       pac->data.length + PAC_INFO_BUFFER_LENGTH + data->length + pad);\n    if (pac_data == NULL) {\n        return ENOMEM;\n    }\n    pac->data.data = pac_data;\n\n    /* Update offsets of existing buffers */\n    for (i = 0; i < pac->pac->cBuffers; i++)\n        pac->pac->Buffers[i].Offset += PAC_INFO_BUFFER_LENGTH;\n\n    /* Make room for new PAC_INFO_BUFFER */\n    memmove(pac->data.data + header_len + PAC_INFO_BUFFER_LENGTH,\n            pac->data.data + header_len,\n            pac->data.length - header_len);\n    memset(pac->data.data + header_len, 0, PAC_INFO_BUFFER_LENGTH);\n\n    /* Initialise new PAC_INFO_BUFFER */\n    pac->pac->Buffers[i].ulType = type;\n    pac->pac->Buffers[i].cbBufferSize = data->length;\n    pac->pac->Buffers[i].Offset = pac->data.length + PAC_INFO_BUFFER_LENGTH;\n    assert((pac->pac->Buffers[i].Offset % PAC_ALIGNMENT) == 0);\n\n    /* Copy in new PAC data and zero padding bytes */\n    if (zerofill)\n        memset(pac->data.data + pac->pac->Buffers[i].Offset, 0, data->length);\n    else\n        memcpy(pac->data.data + pac->pac->Buffers[i].Offset, data->data, data->length);\n\n    memset(pac->data.data + pac->pac->Buffers[i].Offset + data->length, 0, pad);\n\n    pac->pac->cBuffers++;\n    pac->data.length += PAC_INFO_BUFFER_LENGTH + data->length + pad;\n\n    if (out_data != NULL) {\n        out_data->data = pac->data.data + pac->pac->Buffers[i].Offset;\n        out_data->length = data->length;\n    }\n\n    pac->verified = FALSE;\n\n    return 0;\n}\n\nkrb5_error_code KRB5_CALLCONV\nkrb5_pac_add_buffer(krb5_context context,\n                    krb5_pac pac,\n                    krb5_ui_4 type,\n                    const krb5_data *data)\n{\n    return k5_pac_add_buffer(context, pac, type, data, FALSE, NULL);\n}\n\n/*\n * Free a PAC\n */\nvoid KRB5_CALLCONV\nkrb5_pac_free(krb5_context context,\n              krb5_pac pac)\n{\n    if (pac != NULL) {\n        zapfree(pac->data.data, pac->data.length);\n        free(pac->pac);\n        zapfree(pac, sizeof(*pac));\n    }\n}\n\nkrb5_error_code\nk5_pac_locate_buffer(krb5_context context,\n                     const krb5_pac pac,\n                     krb5_ui_4 type,\n                     krb5_data *data)\n{\n    PAC_INFO_BUFFER *buffer = NULL;\n    size_t i;\n\n    if (pac == NULL)\n        return EINVAL;\n\n    for (i = 0; i < pac->pac->cBuffers; i++) {\n        if (pac->pac->Buffers[i].ulType == type) {\n            if (buffer == NULL)\n                buffer = &pac->pac->Buffers[i];\n            else\n                return EINVAL;\n        }\n    }\n\n    if (buffer == NULL)\n        return ENOENT;\n\n    assert(buffer->Offset + buffer->cbBufferSize <= pac->data.length);\n\n    if (data != NULL) {\n        data->length = buffer->cbBufferSize;\n        data->data = pac->data.data + buffer->Offset;\n    }\n\n    return 0;\n}\n\n/*\n * Find a buffer and copy data into output\n */\nkrb5_error_code KRB5_CALLCONV\nkrb5_pac_get_buffer(krb5_context context,\n                    krb5_pac pac,\n                    krb5_ui_4 type,\n                    krb5_data *data)\n{\n    krb5_data d;\n    krb5_error_code ret;\n\n    ret = k5_pac_locate_buffer(context, pac, type, &d);\n    if (ret != 0)\n        return ret;\n\n    data->data = k5memdup(d.data, d.length, &ret);\n    if (data->data == NULL)\n        return ret;\n    data->length = d.length;\n\n    return 0;\n}\n\n/*\n * Return an array of the types of data in the PAC\n */\nkrb5_error_code KRB5_CALLCONV\nkrb5_pac_get_types(krb5_context context,\n                   krb5_pac pac,\n                   size_t *len,\n                   krb5_ui_4 **types)\n{\n    size_t i;\n\n    *types = (krb5_ui_4 *)malloc(pac->pac->cBuffers * sizeof(krb5_ui_4));\n    if (*types == NULL)\n        return ENOMEM;\n\n    *len = pac->pac->cBuffers;\n\n    for (i = 0; i < pac->pac->cBuffers; i++)\n        (*types)[i] = pac->pac->Buffers[i].ulType;\n\n    return 0;\n}\n\n/*\n * Initialize PAC\n */\nkrb5_error_code KRB5_CALLCONV\nkrb5_pac_init(krb5_context context,\n              krb5_pac *ppac)\n{\n    krb5_pac pac;\n\n    pac = (krb5_pac)malloc(sizeof(*pac));\n    if (pac == NULL)\n        return ENOMEM;\n\n    pac->pac = (PACTYPE *)malloc(sizeof(PACTYPE));\n    if (pac->pac == NULL) {\n        free(pac);\n        return ENOMEM;\n    }\n\n    pac->pac->cBuffers = 0;\n    pac->pac->Version = 0;\n\n    pac->data.length = PACTYPE_LENGTH;\n    pac->data.data = calloc(1, pac->data.length);\n    if (pac->data.data == NULL) {\n        krb5_pac_free(context, pac);\n        return ENOMEM;\n    }\n\n    pac->verified = FALSE;\n\n    *ppac = pac;\n\n    return 0;\n}\n\nstatic krb5_error_code\nk5_pac_copy(krb5_context context,\n            krb5_pac src,\n            krb5_pac *dst)\n{\n    size_t header_len;\n    krb5_ui_4 cbuffers;\n    krb5_error_code code;\n    krb5_pac pac;\n\n    cbuffers = src->pac->cBuffers;\n    if (cbuffers != 0)\n        cbuffers--;\n\n    header_len = sizeof(PACTYPE) + cbuffers * sizeof(PAC_INFO_BUFFER);\n\n    pac = (krb5_pac)malloc(sizeof(*pac));\n    if (pac == NULL)\n        return ENOMEM;\n\n    pac->pac = k5memdup(src->pac, header_len, &code);\n    if (pac->pac == NULL) {\n        free(pac);\n        return code;\n    }\n\n    code = krb5int_copy_data_contents(context, &src->data, &pac->data);\n    if (code != 0) {\n        free(pac->pac);\n        free(pac);\n        return ENOMEM;\n    }\n\n    pac->verified = src->verified;\n    *dst = pac;\n\n    return 0;\n}\n\n/*\n * Parse the supplied data into the PAC allocated by this function\n */\nkrb5_error_code KRB5_CALLCONV\nkrb5_pac_parse(krb5_context context,\n               const void *ptr,\n               size_t len,\n               krb5_pac *ppac)\n{\n    krb5_error_code ret;\n    size_t i;\n    const unsigned char *p = (const unsigned char *)ptr;\n    krb5_pac pac;\n    size_t header_len;\n    krb5_ui_4 cbuffers, version;\n\n    *ppac = NULL;\n\n    if (len < PACTYPE_LENGTH)\n        return ERANGE;\n\n    cbuffers = load_32_le(p);\n    p += 4;\n    version = load_32_le(p);\n    p += 4;\n\n    if (version != 0)\n        return EINVAL;\n\n    if (cbuffers < 1 || cbuffers > MAX_BUFFERS)\n        return ERANGE;\n\n    header_len = PACTYPE_LENGTH + (cbuffers * PAC_INFO_BUFFER_LENGTH);\n    if (len < header_len)\n        return ERANGE;\n\n    ret = krb5_pac_init(context, &pac);\n    if (ret != 0)\n        return ret;\n\n    pac->pac = (PACTYPE *)realloc(pac->pac,\n                                  sizeof(PACTYPE) + ((cbuffers - 1) * sizeof(PAC_INFO_BUFFER)));\n    if (pac->pac == NULL) {\n        krb5_pac_free(context, pac);\n        return ENOMEM;\n    }\n\n    pac->pac->cBuffers = cbuffers;\n    pac->pac->Version = version;\n\n    for (i = 0; i < pac->pac->cBuffers; i++) {\n        PAC_INFO_BUFFER *buffer = &pac->pac->Buffers[i];\n\n        buffer->ulType = load_32_le(p);\n        p += 4;\n        buffer->cbBufferSize = load_32_le(p);\n        p += 4;\n        buffer->Offset = load_64_le(p);\n        p += 8;\n\n        if (buffer->Offset % PAC_ALIGNMENT) {\n            krb5_pac_free(context, pac);\n            return EINVAL;\n        }\n        if (buffer->Offset < header_len || buffer->Offset > len ||\n            buffer->cbBufferSize > len - buffer->Offset) {\n            krb5_pac_free(context, pac);\n            return ERANGE;\n        }\n    }\n\n    pac->data.data = realloc(pac->data.data, len);\n    if (pac->data.data == NULL) {\n        krb5_pac_free(context, pac);\n        return ENOMEM;\n    }\n    memcpy(pac->data.data, ptr, len);\n\n    pac->data.length = len;\n\n    *ppac = pac;\n\n    return 0;\n}\n\nstatic krb5_error_code\nk5_time_to_seconds_since_1970(uint64_t ntTime, krb5_timestamp *elapsedSeconds)\n{\n    uint64_t abstime = ntTime / 10000000 - NT_TIME_EPOCH;\n\n    if (abstime > UINT32_MAX)\n        return ERANGE;\n    *elapsedSeconds = abstime;\n    return 0;\n}\n\nkrb5_error_code\nk5_seconds_since_1970_to_time(krb5_timestamp elapsedSeconds, uint64_t *ntTime)\n{\n    *ntTime = (uint32_t)elapsedSeconds;\n    *ntTime += NT_TIME_EPOCH;\n    *ntTime *= 10000000;\n    return 0;\n}\n\nkrb5_error_code KRB5_CALLCONV\nkrb5_pac_get_client_info(krb5_context context,\n                         const krb5_pac pac,\n                         krb5_timestamp *authtime_out,\n                         char **princname_out)\n{\n    krb5_error_code ret;\n    krb5_data client_info;\n    char *pac_princname;\n    unsigned char *p;\n    krb5_timestamp pac_authtime;\n    krb5_ui_2 pac_princname_length;\n    uint64_t pac_nt_authtime;\n\n    if (authtime_out != NULL)\n        *authtime_out = 0;\n    *princname_out = NULL;\n\n    ret = k5_pac_locate_buffer(context, pac, KRB5_PAC_CLIENT_INFO,\n                               &client_info);\n    if (ret != 0)\n        return ret;\n\n    if (client_info.length < PAC_CLIENT_INFO_LENGTH)\n        return ERANGE;\n\n    p = (unsigned char *)client_info.data;\n    pac_nt_authtime = load_64_le(p);\n    p += 8;\n    pac_princname_length = load_16_le(p);\n    p += 2;\n\n    ret = k5_time_to_seconds_since_1970(pac_nt_authtime, &pac_authtime);\n    if (ret != 0)\n        return ret;\n\n    if (client_info.length < PAC_CLIENT_INFO_LENGTH + pac_princname_length ||\n        pac_princname_length % 2)\n        return ERANGE;\n\n    ret = k5_utf16le_to_utf8(p, pac_princname_length, &pac_princname);\n    if (ret != 0)\n        return ret;\n\n    if (authtime_out != NULL)\n        *authtime_out = pac_authtime;\n    *princname_out = pac_princname;\n\n    return 0;\n}\n\nkrb5_error_code\nk5_pac_validate_client(krb5_context context,\n                       const krb5_pac pac,\n                       krb5_timestamp authtime,\n                       krb5_const_principal principal,\n                       krb5_boolean with_realm)\n{\n    krb5_error_code ret;\n    char *pac_princname, *princname;\n    krb5_timestamp pac_authtime;\n    int flags = 0;\n\n    ret = krb5_pac_get_client_info(context, pac, &pac_authtime,\n                                   &pac_princname);\n    if (ret != 0)\n        return ret;\n\n    flags = KRB5_PRINCIPAL_UNPARSE_DISPLAY;\n    if (!with_realm)\n        flags |= KRB5_PRINCIPAL_UNPARSE_NO_REALM;\n\n    ret = krb5_unparse_name_flags(context, principal, flags, &princname);\n    if (ret != 0) {\n        free(pac_princname);\n        return ret;\n    }\n\n    if (pac_authtime != authtime || strcmp(pac_princname, princname) != 0)\n        ret = KRB5KRB_AP_WRONG_PRINC;\n\n    free(pac_princname);\n    krb5_free_unparsed_name(context, princname);\n\n    return ret;\n}\n\nstatic krb5_error_code\nzero_signature(krb5_context context, const krb5_pac pac, krb5_ui_4 type,\n               krb5_data *data)\n{\n    PAC_INFO_BUFFER *buffer = NULL;\n    size_t i;\n\n    assert(type == KRB5_PAC_SERVER_CHECKSUM ||\n           type == KRB5_PAC_PRIVSVR_CHECKSUM);\n    assert(data->length >= pac->data.length);\n\n    for (i = 0; i < pac->pac->cBuffers; i++) {\n        if (pac->pac->Buffers[i].ulType == type) {\n            buffer = &pac->pac->Buffers[i];\n            break;\n        }\n    }\n\n    if (buffer == NULL)\n        return ENOENT;\n\n    if (buffer->Offset + buffer->cbBufferSize > pac->data.length)\n        return ERANGE;\n\n    if (buffer->cbBufferSize < PAC_SIGNATURE_DATA_LENGTH)\n        return KRB5_BAD_MSIZE;\n\n    /* Zero out the data portion of the checksum only */\n    memset(data->data + buffer->Offset + PAC_SIGNATURE_DATA_LENGTH,\n           0,\n           buffer->cbBufferSize - PAC_SIGNATURE_DATA_LENGTH);\n\n    return 0;\n}\n\nstatic krb5_error_code\nverify_checksum(krb5_context context, const krb5_pac pac, uint32_t buffer_type,\n                const krb5_keyblock *key, krb5_keyusage usage,\n                const krb5_data *data)\n{\n    krb5_error_code ret;\n    krb5_data buffer;\n    krb5_cksumtype cksumtype;\n    krb5_checksum checksum;\n    krb5_boolean valid;\n    size_t cksumlen;\n\n    ret = k5_pac_locate_buffer(context, pac, buffer_type, &buffer);\n    if (ret != 0)\n        return ret;\n    if (buffer.length < PAC_SIGNATURE_DATA_LENGTH)\n        return KRB5_BAD_MSIZE;\n\n    cksumtype = load_32_le(buffer.data);\n    if (buffer_type == KRB5_PAC_SERVER_CHECKSUM && cksumtype == CKSUMTYPE_SHA1)\n        return KRB5KDC_ERR_SUMTYPE_NOSUPP;\n    if (!krb5_c_is_keyed_cksum(cksumtype))\n        return KRB5KRB_ERR_GENERIC;\n\n    /* There may be an RODCIdentifier trailer (see [MS-PAC] 2.8), so look up\n     * the length of the checksum by its type. */\n    ret = krb5_c_checksum_length(context, cksumtype, &cksumlen);\n    if (ret)\n        return ret;\n    if (cksumlen > buffer.length - PAC_SIGNATURE_DATA_LENGTH)\n        return KRB5_BAD_MSIZE;\n    checksum.checksum_type = cksumtype;\n    checksum.length = cksumlen;\n    checksum.contents = (uint8_t *)buffer.data + PAC_SIGNATURE_DATA_LENGTH;\n\n    ret = krb5_c_verify_checksum(context, key, usage, data, &checksum, &valid);\n    return ret ? ret : (valid ? 0 : KRB5KRB_AP_ERR_MODIFIED);\n}\n\nstatic krb5_error_code\nverify_server_checksum(krb5_context context, const krb5_pac pac,\n                       const krb5_keyblock *server)\n{\n    krb5_error_code ret;\n    krb5_data copy;             /* PAC with zeroed checksums */\n\n    ret = krb5int_copy_data_contents(context, &pac->data, &copy);\n    if (ret)\n        return ret;\n\n    /* Zero out both checksum buffers */\n    ret = zero_signature(context, pac, KRB5_PAC_SERVER_CHECKSUM, &copy);\n    if (ret)\n        goto cleanup;\n    ret = zero_signature(context, pac, KRB5_PAC_PRIVSVR_CHECKSUM, &copy);\n    if (ret)\n        goto cleanup;\n\n    ret = verify_checksum(context, pac, KRB5_PAC_SERVER_CHECKSUM, server,\n                          KRB5_KEYUSAGE_APP_DATA_CKSUM, &copy);\n\ncleanup:\n    free(copy.data);\n    return ret;\n}\n\nstatic krb5_error_code\nverify_kdc_checksum(krb5_context context, const krb5_pac pac,\n                    const krb5_keyblock *privsvr)\n{\n    krb5_error_code ret;\n    krb5_data server_checksum;\n\n    ret = k5_pac_locate_buffer(context, pac, KRB5_PAC_SERVER_CHECKSUM,\n                               &server_checksum);\n    if (ret)\n        return ret;\n    if (server_checksum.length < PAC_SIGNATURE_DATA_LENGTH)\n        return KRB5_BAD_MSIZE;\n    server_checksum.data += PAC_SIGNATURE_DATA_LENGTH;\n    server_checksum.length -= PAC_SIGNATURE_DATA_LENGTH;\n\n    return verify_checksum(context, pac, KRB5_PAC_PRIVSVR_CHECKSUM, privsvr,\n                           KRB5_KEYUSAGE_APP_DATA_CKSUM, &server_checksum);\n}\n\n/* Per MS-PAC 2.8.3, tickets encrypted to TGS and password change principals\n * should not have ticket signatures. */\nkrb5_boolean\nk5_pac_should_have_ticket_signature(krb5_const_principal sprinc)\n{\n    if (IS_TGS_PRINC(sprinc))\n        return FALSE;\n    if (sprinc->length == 2 && data_eq_string(sprinc->data[0], \"kadmin\") &&\n        data_eq_string(sprinc->data[1], \"changepw\"))\n        return FALSE;\n    return TRUE;\n}\n\nkrb5_error_code KRB5_CALLCONV\nkrb5_kdc_verify_ticket(krb5_context context, const krb5_enc_tkt_part *enc_tkt,\n                       krb5_const_principal server_princ,\n                       const krb5_keyblock *server,\n                       const krb5_keyblock *privsvr, krb5_pac *pac_out)\n{\n    krb5_error_code ret;\n    krb5_pac pac = NULL;\n    krb5_data *recoded_tkt = NULL;\n    krb5_authdata **authdata, *orig, **ifrel = NULL, **recoded_ifrel = NULL;\n    uint8_t z = 0;\n    krb5_authdata zpac = { KV5M_AUTHDATA, KRB5_AUTHDATA_WIN2K_PAC, 1, &z };\n    size_t i, j;\n\n    *pac_out = NULL;\n\n    /*\n     * Find the position of the PAC in the ticket authdata.  ifrel will be the\n     * decoded AD-IF-RELEVANT container at position i containing a PAC, and j\n     * will be the offset within the container.\n     */\n    authdata = enc_tkt->authorization_data;\n    for (i = 0; authdata != NULL && authdata[i] != NULL; i++) {\n        if (authdata[i]->ad_type != KRB5_AUTHDATA_IF_RELEVANT)\n            continue;\n\n        ret = krb5_decode_authdata_container(context,\n                                             KRB5_AUTHDATA_IF_RELEVANT,\n                                             authdata[i], &ifrel);\n        if (ret)\n            goto cleanup;\n\n        for (j = 0; ifrel[j] != NULL; j++) {\n            if (ifrel[j]->ad_type == KRB5_AUTHDATA_WIN2K_PAC)\n                break;\n        }\n        if (ifrel[j] != NULL)\n            break;\n\n        krb5_free_authdata(context, ifrel);\n        ifrel = NULL;\n    }\n\n    /* Stop and return successfully if we didn't find a PAC. */\n    if (ifrel == NULL) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    ret = krb5_pac_parse(context, ifrel[j]->contents, ifrel[j]->length, &pac);\n    if (ret)\n        goto cleanup;\n\n    if (privsvr != NULL && k5_pac_should_have_ticket_signature(server_princ)) {\n        /* To check the PAC ticket signatures, re-encode the ticket with the\n         * PAC contents replaced by a single zero. */\n        orig = ifrel[j];\n        ifrel[j] = &zpac;\n        ret = krb5_encode_authdata_container(context,\n                                             KRB5_AUTHDATA_IF_RELEVANT,\n                                             ifrel, &recoded_ifrel);\n        ifrel[j] = orig;\n        if (ret)\n            goto cleanup;\n        orig = authdata[i];\n        authdata[i] = recoded_ifrel[0];\n        ret = encode_krb5_enc_tkt_part(enc_tkt, &recoded_tkt);\n        authdata[i] = orig;\n        if (ret)\n            goto cleanup;\n\n        ret = verify_checksum(context, pac, KRB5_PAC_TICKET_CHECKSUM, privsvr,\n                              KRB5_KEYUSAGE_APP_DATA_CKSUM, recoded_tkt);\n        if (ret)\n            goto cleanup;\n    }\n\n    ret = krb5_pac_verify_ext(context, pac, enc_tkt->times.authtime, NULL,\n                              server, privsvr, FALSE);\n\n    *pac_out = pac;\n    pac = NULL;\n\ncleanup:\n    krb5_pac_free(context, pac);\n    krb5_free_data(context, recoded_tkt);\n    krb5_free_authdata(context, ifrel);\n    krb5_free_authdata(context, recoded_ifrel);\n    return ret;\n}\n\nkrb5_error_code KRB5_CALLCONV\nkrb5_pac_verify(krb5_context context,\n                const krb5_pac pac,\n                krb5_timestamp authtime,\n                krb5_const_principal principal,\n                const krb5_keyblock *server,\n                const krb5_keyblock *privsvr)\n{\n    return krb5_pac_verify_ext(context, pac, authtime, principal, server,\n                               privsvr, FALSE);\n}\n\nkrb5_error_code KRB5_CALLCONV\nkrb5_pac_verify_ext(krb5_context context,\n                    const krb5_pac pac,\n                    krb5_timestamp authtime,\n                    krb5_const_principal principal,\n                    const krb5_keyblock *server,\n                    const krb5_keyblock *privsvr,\n                    krb5_boolean with_realm)\n{\n    krb5_error_code ret;\n\n    if (server != NULL) {\n        ret = verify_server_checksum(context, pac, server);\n        if (ret != 0)\n            return ret;\n    }\n\n    if (privsvr != NULL) {\n        ret = verify_kdc_checksum(context, pac, privsvr);\n        if (ret != 0)\n            return ret;\n    }\n\n    if (principal != NULL) {\n        ret = k5_pac_validate_client(context, pac, authtime,\n                                     principal, with_realm);\n        if (ret != 0)\n            return ret;\n    }\n\n    pac->verified = TRUE;\n\n    return 0;\n}\n\n/*\n * PAC auth data attribute backend\n */\nstruct mspac_context {\n    krb5_pac pac;\n};\n\nstatic krb5_error_code\nmspac_init(krb5_context kcontext, void **plugin_context)\n{\n    *plugin_context = NULL;\n    return 0;\n}\n\nstatic void\nmspac_flags(krb5_context kcontext,\n            void *plugin_context,\n            krb5_authdatatype ad_type,\n            krb5_flags *flags)\n{\n    *flags = AD_USAGE_TGS_REQ;\n}\n\nstatic void\nmspac_fini(krb5_context kcontext, void *plugin_context)\n{\n    return;\n}\n\nstatic krb5_error_code\nmspac_request_init(krb5_context kcontext,\n                   krb5_authdata_context context,\n                   void *plugin_context,\n                   void **request_context)\n{\n    struct mspac_context *pacctx;\n\n    pacctx = (struct mspac_context *)malloc(sizeof(*pacctx));\n    if (pacctx == NULL)\n        return ENOMEM;\n\n    pacctx->pac = NULL;\n\n    *request_context = pacctx;\n\n    return 0;\n}\n\nstatic krb5_error_code\nmspac_import_authdata(krb5_context kcontext,\n                      krb5_authdata_context context,\n                      void *plugin_context,\n                      void *request_context,\n                      krb5_authdata **authdata,\n                      krb5_boolean kdc_issued,\n                      krb5_const_principal kdc_issuer)\n{\n    krb5_error_code code;\n    struct mspac_context *pacctx = (struct mspac_context *)request_context;\n\n    if (kdc_issued)\n        return EINVAL;\n\n    if (pacctx->pac != NULL) {\n        krb5_pac_free(kcontext, pacctx->pac);\n        pacctx->pac = NULL;\n    }\n\n    assert(authdata[0] != NULL);\n    assert((authdata[0]->ad_type & AD_TYPE_FIELD_TYPE_MASK) ==\n           KRB5_AUTHDATA_WIN2K_PAC);\n\n    code = krb5_pac_parse(kcontext, authdata[0]->contents,\n                          authdata[0]->length, &pacctx->pac);\n\n    return code;\n}\n\nstatic krb5_error_code\nmspac_export_authdata(krb5_context kcontext,\n                      krb5_authdata_context context,\n                      void *plugin_context,\n                      void *request_context,\n                      krb5_flags usage,\n                      krb5_authdata ***out_authdata)\n{\n    struct mspac_context *pacctx = (struct mspac_context *)request_context;\n    krb5_error_code code;\n    krb5_authdata **authdata;\n    krb5_data data;\n\n    if (pacctx->pac == NULL)\n        return 0;\n\n    authdata = calloc(2, sizeof(krb5_authdata *));\n    if (authdata == NULL)\n        return ENOMEM;\n\n    authdata[0] = calloc(1, sizeof(krb5_authdata));\n    if (authdata[0] == NULL) {\n        free(authdata);\n        return ENOMEM;\n    }\n    authdata[1] = NULL;\n\n    code = krb5int_copy_data_contents(kcontext, &pacctx->pac->data, &data);\n    if (code != 0) {\n        krb5_free_authdata(kcontext, authdata);\n        return code;\n    }\n\n    authdata[0]->magic = KV5M_AUTHDATA;\n    authdata[0]->ad_type = KRB5_AUTHDATA_WIN2K_PAC;\n    authdata[0]->length = data.length;\n    authdata[0]->contents = (krb5_octet *)data.data;\n\n    authdata[1] = NULL;\n\n    *out_authdata = authdata;\n\n    return 0;\n}\n\nstatic krb5_error_code\nmspac_verify(krb5_context kcontext,\n             krb5_authdata_context context,\n             void *plugin_context,\n             void *request_context,\n             const krb5_auth_context *auth_context,\n             const krb5_keyblock *key,\n             const krb5_ap_req *req)\n{\n    krb5_error_code code;\n    struct mspac_context *pacctx = (struct mspac_context *)request_context;\n\n    if (pacctx->pac == NULL)\n        return EINVAL;\n\n    code = krb5_pac_verify(kcontext, pacctx->pac,\n                           req->ticket->enc_part2->times.authtime,\n                           req->ticket->enc_part2->client, key, NULL);\n    if (code != 0)\n        TRACE_MSPAC_VERIFY_FAIL(kcontext, code);\n\n    /*\n     * If the above verification failed, don't fail the whole authentication,\n     * just don't mark the PAC as verified.  A checksum mismatch can occur if\n     * the PAC was copied from a cross-realm TGT by an ignorant KDC, and Apple\n     * macOS Server Open Directory (as of 10.6) generates PACs with no server\n     * checksum at all.\n     */\n    return 0;\n}\n\nstatic void\nmspac_request_fini(krb5_context kcontext,\n                   krb5_authdata_context context,\n                   void *plugin_context,\n                   void *request_context)\n{\n    struct mspac_context *pacctx = (struct mspac_context *)request_context;\n\n    if (pacctx != NULL) {\n        if (pacctx->pac != NULL)\n            krb5_pac_free(kcontext, pacctx->pac);\n\n        free(pacctx);\n    }\n}\n\n#define STRLENOF(x) (sizeof((x)) - 1)\n\nstatic struct {\n    krb5_ui_4 type;\n    krb5_data attribute;\n} mspac_attribute_types[] = {\n    { (krb5_ui_4)-1,            { KV5M_DATA, STRLENOF(\"urn:mspac:\"),\n                                  \"urn:mspac:\" } },\n    { KRB5_PAC_LOGON_INFO,       { KV5M_DATA,\n                                   STRLENOF(\"urn:mspac:logon-info\"),\n                                   \"urn:mspac:logon-info\" } },\n    { KRB5_PAC_CREDENTIALS_INFO, { KV5M_DATA,\n                                   STRLENOF(\"urn:mspac:credentials-info\"),\n                                   \"urn:mspac:credentials-info\" } },\n    { KRB5_PAC_SERVER_CHECKSUM,  { KV5M_DATA,\n                                   STRLENOF(\"urn:mspac:server-checksum\"),\n                                   \"urn:mspac:server-checksum\" } },\n    { KRB5_PAC_PRIVSVR_CHECKSUM, { KV5M_DATA,\n                                   STRLENOF(\"urn:mspac:privsvr-checksum\"),\n                                   \"urn:mspac:privsvr-checksum\" } },\n    { KRB5_PAC_CLIENT_INFO,      { KV5M_DATA,\n                                   STRLENOF(\"urn:mspac:client-info\"),\n                                   \"urn:mspac:client-info\" } },\n    { KRB5_PAC_DELEGATION_INFO,  { KV5M_DATA,\n                                   STRLENOF(\"urn:mspac:delegation-info\"),\n                                   \"urn:mspac:delegation-info\" } },\n    { KRB5_PAC_UPN_DNS_INFO,     { KV5M_DATA,\n                                   STRLENOF(\"urn:mspac:upn-dns-info\"),\n                                   \"urn:mspac:upn-dns-info\" } },\n};\n\n#define MSPAC_ATTRIBUTE_COUNT   (sizeof(mspac_attribute_types)/sizeof(mspac_attribute_types[0]))\n\nstatic krb5_error_code\nmspac_type2attr(krb5_ui_4 type, krb5_data *attr)\n{\n    unsigned int i;\n\n    for (i = 0; i < MSPAC_ATTRIBUTE_COUNT; i++) {\n        if (mspac_attribute_types[i].type == type) {\n            *attr = mspac_attribute_types[i].attribute;\n            return 0;\n        }\n    }\n\n    return ENOENT;\n}\n\nstatic krb5_error_code\nmspac_attr2type(const krb5_data *attr, krb5_ui_4 *type)\n{\n    unsigned int i;\n\n    for (i = 0; i < MSPAC_ATTRIBUTE_COUNT; i++) {\n        if (attr->length == mspac_attribute_types[i].attribute.length &&\n            strncasecmp(attr->data, mspac_attribute_types[i].attribute.data, attr->length) == 0) {\n            *type = mspac_attribute_types[i].type;\n            return 0;\n        }\n    }\n\n    if (attr->length > STRLENOF(\"urn:mspac:\") &&\n        strncasecmp(attr->data, \"urn:mspac:\", STRLENOF(\"urn:mspac:\")) == 0)\n    {\n        char *p = &attr->data[STRLENOF(\"urn:mspac:\")];\n        char *endptr;\n\n        *type = strtoul(p, &endptr, 10);\n        if (*type != 0 && *endptr == '\\0')\n            return 0;\n    }\n\n    return ENOENT;\n}\n\nstatic krb5_error_code\nmspac_get_attribute_types(krb5_context kcontext,\n                          krb5_authdata_context context,\n                          void *plugin_context,\n                          void *request_context,\n                          krb5_data **out_attrs)\n{\n    struct mspac_context *pacctx = (struct mspac_context *)request_context;\n    unsigned int i, j;\n    krb5_data *attrs;\n    krb5_error_code code;\n\n    if (pacctx->pac == NULL)\n        return ENOENT;\n\n    attrs = calloc(1 + pacctx->pac->pac->cBuffers + 1, sizeof(krb5_data));\n    if (attrs == NULL)\n        return ENOMEM;\n\n    j = 0;\n\n    /* The entire PAC */\n    code = krb5int_copy_data_contents(kcontext,\n                                      &mspac_attribute_types[0].attribute,\n                                      &attrs[j++]);\n    if (code != 0) {\n        free(attrs);\n        return code;\n    }\n\n    /* PAC buffers */\n    for (i = 0; i < pacctx->pac->pac->cBuffers; i++) {\n        krb5_data attr;\n\n        code = mspac_type2attr(pacctx->pac->pac->Buffers[i].ulType, &attr);\n        if (code == 0) {\n            code = krb5int_copy_data_contents(kcontext, &attr, &attrs[j++]);\n            if (code != 0) {\n                krb5int_free_data_list(kcontext, attrs);\n                return code;\n            }\n        } else {\n            int length;\n\n            length = asprintf(&attrs[j].data, \"urn:mspac:%d\",\n                              pacctx->pac->pac->Buffers[i].ulType);\n            if (length < 0) {\n                krb5int_free_data_list(kcontext, attrs);\n                return ENOMEM;\n            }\n            attrs[j++].length = length;\n        }\n    }\n    attrs[j].data = NULL;\n    attrs[j].length = 0;\n\n    *out_attrs = attrs;\n\n    return 0;\n}\n\nstatic krb5_error_code\nmspac_get_attribute(krb5_context kcontext,\n                    krb5_authdata_context context,\n                    void *plugin_context,\n                    void *request_context,\n                    const krb5_data *attribute,\n                    krb5_boolean *authenticated,\n                    krb5_boolean *complete,\n                    krb5_data *value,\n                    krb5_data *display_value,\n                    int *more)\n{\n    struct mspac_context *pacctx = (struct mspac_context *)request_context;\n    krb5_error_code code;\n    krb5_ui_4 type;\n\n    if (display_value != NULL) {\n        display_value->data = NULL;\n        display_value->length = 0;\n    }\n\n    if (*more != -1 || pacctx->pac == NULL)\n        return ENOENT;\n\n    /* If it didn't verify, pretend it didn't exist. */\n    if (!pacctx->pac->verified) {\n        TRACE_MSPAC_DISCARD_UNVERF(kcontext);\n        return ENOENT;\n    }\n\n    code = mspac_attr2type(attribute, &type);\n    if (code != 0)\n        return code;\n\n    /* -1 is a magic type that refers to the entire PAC */\n    if (type == (krb5_ui_4)-1) {\n        if (value != NULL)\n            code = krb5int_copy_data_contents(kcontext,\n                                              &pacctx->pac->data,\n                                              value);\n        else\n            code = 0;\n    } else {\n        if (value != NULL)\n            code = krb5_pac_get_buffer(kcontext, pacctx->pac, type, value);\n        else\n            code = k5_pac_locate_buffer(kcontext, pacctx->pac, type, NULL);\n    }\n    if (code == 0) {\n        *authenticated = pacctx->pac->verified;\n        *complete = TRUE;\n    }\n\n    *more = 0;\n\n    return code;\n}\n\nstatic krb5_error_code\nmspac_set_attribute(krb5_context kcontext,\n                    krb5_authdata_context context,\n                    void *plugin_context,\n                    void *request_context,\n                    krb5_boolean complete,\n                    const krb5_data *attribute,\n                    const krb5_data *value)\n{\n    struct mspac_context *pacctx = (struct mspac_context *)request_context;\n    krb5_error_code code;\n    krb5_ui_4 type;\n\n    if (pacctx->pac == NULL)\n        return ENOENT;\n\n    code = mspac_attr2type(attribute, &type);\n    if (code != 0)\n        return code;\n\n    /* -1 is a magic type that refers to the entire PAC */\n    if (type == (krb5_ui_4)-1) {\n        krb5_pac newpac;\n\n        code = krb5_pac_parse(kcontext, value->data, value->length, &newpac);\n        if (code != 0)\n            return code;\n\n        krb5_pac_free(kcontext, pacctx->pac);\n        pacctx->pac = newpac;\n    } else {\n        code = krb5_pac_add_buffer(kcontext, pacctx->pac, type, value);\n    }\n\n    return code;\n}\n\nstatic krb5_error_code\nmspac_export_internal(krb5_context kcontext,\n                      krb5_authdata_context context,\n                      void *plugin_context,\n                      void *request_context,\n                      krb5_boolean restrict_authenticated,\n                      void **ptr)\n{\n    struct mspac_context *pacctx = (struct mspac_context *)request_context;\n    krb5_error_code code;\n    krb5_pac pac;\n\n    *ptr = NULL;\n\n    if (pacctx->pac == NULL)\n        return ENOENT;\n\n    if (restrict_authenticated && (pacctx->pac->verified) == FALSE)\n        return ENOENT;\n\n    code = krb5_pac_parse(kcontext, pacctx->pac->data.data,\n                          pacctx->pac->data.length, &pac);\n    if (code == 0) {\n        pac->verified = pacctx->pac->verified;\n        *ptr = pac;\n    }\n\n    return code;\n}\n\nstatic void\nmspac_free_internal(krb5_context kcontext,\n                    krb5_authdata_context context,\n                    void *plugin_context,\n                    void *request_context,\n                    void *ptr)\n{\n    if (ptr != NULL)\n        krb5_pac_free(kcontext, (krb5_pac)ptr);\n\n    return;\n}\n\nstatic krb5_error_code\nmspac_size(krb5_context kcontext,\n           krb5_authdata_context context,\n           void *plugin_context,\n           void *request_context,\n           size_t *sizep)\n{\n    struct mspac_context *pacctx = (struct mspac_context *)request_context;\n\n    *sizep += sizeof(krb5_int32);\n\n    if (pacctx->pac != NULL)\n        *sizep += pacctx->pac->data.length;\n\n    *sizep += sizeof(krb5_int32);\n\n    return 0;\n}\n\nstatic krb5_error_code\nmspac_externalize(krb5_context kcontext,\n                  krb5_authdata_context context,\n                  void *plugin_context,\n                  void *request_context,\n                  krb5_octet **buffer,\n                  size_t *lenremain)\n{\n    krb5_error_code code = 0;\n    struct mspac_context *pacctx = (struct mspac_context *)request_context;\n    size_t required = 0;\n    krb5_octet *bp;\n    size_t remain;\n\n    bp = *buffer;\n    remain = *lenremain;\n\n    if (pacctx->pac != NULL) {\n        mspac_size(kcontext, context, plugin_context,\n                   request_context, &required);\n\n        if (required <= remain) {\n            krb5_ser_pack_int32((krb5_int32)pacctx->pac->data.length,\n                                &bp, &remain);\n            krb5_ser_pack_bytes((krb5_octet *)pacctx->pac->data.data,\n                                (size_t)pacctx->pac->data.length,\n                                &bp, &remain);\n            krb5_ser_pack_int32((krb5_int32)pacctx->pac->verified,\n                                &bp, &remain);\n        } else {\n            code = ENOMEM;\n        }\n    } else {\n        krb5_ser_pack_int32(0, &bp, &remain); /* length */\n        krb5_ser_pack_int32(0, &bp, &remain); /* verified */\n    }\n\n    *buffer = bp;\n    *lenremain = remain;\n\n    return code;\n}\n\nstatic krb5_error_code\nmspac_internalize(krb5_context kcontext,\n                  krb5_authdata_context context,\n                  void *plugin_context,\n                  void *request_context,\n                  krb5_octet **buffer,\n                  size_t *lenremain)\n{\n    struct mspac_context *pacctx = (struct mspac_context *)request_context;\n    krb5_error_code code;\n    krb5_int32 ibuf;\n    krb5_octet *bp;\n    size_t remain;\n    krb5_pac pac = NULL;\n\n    bp = *buffer;\n    remain = *lenremain;\n\n    /* length */\n    code = krb5_ser_unpack_int32(&ibuf, &bp, &remain);\n    if (code != 0)\n        return code;\n\n    if (ibuf != 0) {\n        code = krb5_pac_parse(kcontext, bp, ibuf, &pac);\n        if (code != 0)\n            return code;\n\n        bp += ibuf;\n        remain -= ibuf;\n    }\n\n    /* verified */\n    code = krb5_ser_unpack_int32(&ibuf, &bp, &remain);\n    if (code != 0) {\n        krb5_pac_free(kcontext, pac);\n        return code;\n    }\n\n    if (pac != NULL) {\n        pac->verified = (ibuf != 0);\n    }\n\n    if (pacctx->pac != NULL) {\n        krb5_pac_free(kcontext, pacctx->pac);\n    }\n\n    pacctx->pac = pac;\n\n    *buffer = bp;\n    *lenremain = remain;\n\n    return 0;\n}\n\nstatic krb5_error_code\nmspac_copy(krb5_context kcontext,\n           krb5_authdata_context context,\n           void *plugin_context,\n           void *request_context,\n           void *dst_plugin_context,\n           void *dst_request_context)\n{\n    struct mspac_context *srcctx = (struct mspac_context *)request_context;\n    struct mspac_context *dstctx = (struct mspac_context *)dst_request_context;\n    krb5_error_code code = 0;\n\n    assert(dstctx != NULL);\n    assert(dstctx->pac == NULL);\n\n    if (srcctx->pac != NULL)\n        code = k5_pac_copy(kcontext, srcctx->pac, &dstctx->pac);\n\n    return code;\n}\n\nstatic krb5_authdatatype mspac_ad_types[] = { KRB5_AUTHDATA_WIN2K_PAC, 0 };\n\nkrb5plugin_authdata_client_ftable_v0 k5_mspac_ad_client_ftable = {\n    \"mspac\",\n    mspac_ad_types,\n    mspac_init,\n    mspac_fini,\n    mspac_flags,\n    mspac_request_init,\n    mspac_request_fini,\n    mspac_get_attribute_types,\n    mspac_get_attribute,\n    mspac_set_attribute,\n    NULL, /* delete_attribute_proc */\n    mspac_export_authdata,\n    mspac_import_authdata,\n    mspac_export_internal,\n    mspac_free_internal,\n    mspac_verify,\n    mspac_size,\n    mspac_externalize,\n    mspac_internalize,\n    mspac_copy\n};\n", "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * Copyright (c) 2006 Kungliga Tekniska H\u00f6gskolan\n * (Royal Institute of Technology, Stockholm, Sweden).\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the Institute nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"k5-int.h\"\n\n#define U(x) (uint8_t *)x\n\n/*\n * This PAC and keys are copied (with permission) from Samba torture\n * regression test suite, they where created by Andrew Bartlet.\n */\n\nstatic const unsigned char saved_pac[] = {\n    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xd8, 0x01, 0x00, 0x00,\n    0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,\n    0x20, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,\n    0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,\n    0x58, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x10, 0x08, 0x00, 0xcc, 0xcc, 0xcc, 0xcc,\n    0xc8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x30, 0xdf, 0xa6, 0xcb,\n    0x4f, 0x7d, 0xc5, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0xc0, 0x3c, 0x4e, 0x59, 0x62, 0x73, 0xc5, 0x01, 0xc0, 0x3c, 0x4e, 0x59,\n    0x62, 0x73, 0xc5, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x16, 0x00, 0x16, 0x00,\n    0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0c, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x14, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x02, 0x00, 0x65, 0x00, 0x00, 0x00,\n    0xed, 0x03, 0x00, 0x00, 0x04, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x02, 0x00,\n    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x16, 0x00, 0x20, 0x00, 0x02, 0x00, 0x16, 0x00, 0x18, 0x00,\n    0x24, 0x00, 0x02, 0x00, 0x28, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x01, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00,\n    0x57, 0x00, 0x32, 0x00, 0x30, 0x00, 0x30, 0x00, 0x33, 0x00, 0x46, 0x00, 0x49, 0x00, 0x4e, 0x00,\n    0x41, 0x00, 0x4c, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,\n    0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x57, 0x00, 0x32, 0x00,\n    0x30, 0x00, 0x30, 0x00, 0x33, 0x00, 0x46, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x41, 0x00, 0x4c, 0x00,\n    0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x57, 0x00, 0x49, 0x00,\n    0x4e, 0x00, 0x32, 0x00, 0x4b, 0x00, 0x33, 0x00, 0x54, 0x00, 0x48, 0x00, 0x49, 0x00, 0x4e, 0x00,\n    0x4b, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,\n    0x15, 0x00, 0x00, 0x00, 0x11, 0x2f, 0xaf, 0xb5, 0x90, 0x04, 0x1b, 0xec, 0x50, 0x3b, 0xec, 0xdc,\n    0x01, 0x00, 0x00, 0x00, 0x30, 0x00, 0x02, 0x00, 0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,\n    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x80, 0x66, 0x28, 0xea, 0x37, 0x80, 0xc5, 0x01, 0x16, 0x00, 0x77, 0x00, 0x32, 0x00, 0x30, 0x00,\n    0x30, 0x00, 0x33, 0x00, 0x66, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x61, 0x00, 0x6c, 0x00, 0x24, 0x00,\n    0x76, 0xff, 0xff, 0xff, 0x37, 0xd5, 0xb0, 0xf7, 0x24, 0xf0, 0xd6, 0xd4, 0xec, 0x09, 0x86, 0x5a,\n    0xa0, 0xe8, 0xc3, 0xa9, 0x00, 0x00, 0x00, 0x00, 0x76, 0xff, 0xff, 0xff, 0xb4, 0xd8, 0xb8, 0xfe,\n    0x83, 0xb3, 0x13, 0x3f, 0xfc, 0x5c, 0x41, 0xad, 0xe2, 0x64, 0x83, 0xe0, 0x00, 0x00, 0x00, 0x00\n};\n\nstatic unsigned int type_1_length = 472;\n\nstatic const krb5_keyblock kdc_keyblock = {\n    0, ENCTYPE_ARCFOUR_HMAC,\n    16, U(\"\\xB2\\x86\\x75\\x71\\x48\\xAF\\x7F\\xD2\\x52\\xC5\\x36\\x03\\xA1\\x50\\xB7\\xE7\")\n};\n\nstatic const krb5_keyblock member_keyblock = {\n    0, ENCTYPE_ARCFOUR_HMAC,\n    16, U(\"\\xD2\\x17\\xFA\\xEA\\xE5\\xE6\\xB5\\xF9\\x5C\\xCC\\x94\\x07\\x7A\\xB8\\xA5\\xFC\")\n};\n\nstatic time_t authtime = 1120440609;\nstatic const char *user = \"w2003final$@WIN2K3.THINKER.LOCAL\";\n\n/* The S4U2Self PACs below were collected by debugging krb5-mit code on\n * Linux, talking with a Windows 2008 KDC server over the network. */\n\nstatic const unsigned char s4u_pac_regular[] = {\n    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x01, 0x00, 0x00, 0x00, 0xa0, 0x01, 0x00, 0x00,\n    0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0a, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,\n    0xf8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0c, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,\n    0x10, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x06, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,\n    0x48, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x07, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,\n    0x58, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x01, 0x10, 0x08, 0x00, 0xcc, 0xcc, 0xcc, 0xcc,\n    0x90, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0xc9, 0x36, 0xfd, 0x57,\n    0x5b, 0x59, 0xd4, 0x01, 0xc9, 0x36, 0xfd, 0x57,\n    0x5b, 0x59, 0xd4, 0x01, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0x0a, 0x00, 0x0a, 0x00,\n    0x04, 0x00, 0x02, 0x00, 0x0a, 0x00, 0x0a, 0x00,\n    0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0c, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x14, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x18, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x76, 0x04, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00,\n    0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x02, 0x00,\n    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x08, 0x00,\n    0x20, 0x00, 0x02, 0x00, 0x08, 0x00, 0x0a, 0x00,\n    0x24, 0x00, 0x02, 0x00, 0x28, 0x00, 0x02, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x10, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,\n    0x01, 0x02, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,\n    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x03, 0x00, 0x00, 0x00, 0x57, 0x00, 0x44, 0x00,\n    0x43, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n    0x41, 0x00, 0x43, 0x00, 0x4d, 0x00, 0x45, 0x00,\n    0x04, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x05, 0x15, 0x00, 0x00, 0x00,\n    0x74, 0xa0, 0x8d, 0x00, 0x3f, 0xa5, 0xc2, 0xe9,\n    0x60, 0x91, 0xe1, 0x22, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x89, 0xa1, 0x25, 0xd0, 0x59, 0xd4, 0x01,\n    0x0a, 0x00, 0x77, 0x00, 0x32, 0x00, 0x6b, 0x00,\n    0x38, 0x00, 0x75, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x12, 0x00, 0x10, 0x00, 0x10, 0x00, 0x28, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x40, 0x00, 0x61, 0x00, 0x62, 0x00,\n    0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x41, 0x00, 0x43, 0x00, 0x4d, 0x00, 0x45, 0x00,\n    0x2e, 0x00, 0x43, 0x00, 0x4f, 0x00, 0x4d, 0x00,\n    0x10, 0x00, 0x00, 0x00, 0x88, 0x1d, 0x40, 0x84,\n    0x7a, 0x01, 0x7c, 0x80, 0x74, 0xe3, 0x6a, 0x6b,\n    0x76, 0xff, 0xff, 0xff, 0x1a, 0x1d, 0x97, 0xd2,\n    0x39, 0xf4, 0xb8, 0xb2, 0x53, 0xae, 0x77, 0xdb,\n    0x6c, 0x02, 0xd4, 0x3d, 0x00, 0x00, 0x00, 0x00\n};\n\nstatic const unsigned char s4u_pac_enterprise[] = {\n    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x01, 0x00, 0x00, 0x00, 0xa0, 0x01, 0x00, 0x00,\n    0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0a, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00,\n    0xf8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0c, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,\n    0x18, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x06, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,\n    0x50, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x07, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,\n    0x60, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x01, 0x10, 0x08, 0x00, 0xcc, 0xcc, 0xcc, 0xcc,\n    0x90, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0xc9, 0x36, 0xfd, 0x57,\n    0x5b, 0x59, 0xd4, 0x01, 0xc9, 0x36, 0xfd, 0x57,\n    0x5b, 0x59, 0xd4, 0x01, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0x0a, 0x00, 0x0a, 0x00,\n    0x04, 0x00, 0x02, 0x00, 0x0a, 0x00, 0x0a, 0x00,\n    0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0c, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x14, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x18, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x76, 0x04, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00,\n    0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x02, 0x00,\n    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x08, 0x00,\n    0x20, 0x00, 0x02, 0x00, 0x08, 0x00, 0x0a, 0x00,\n    0x24, 0x00, 0x02, 0x00, 0x28, 0x00, 0x02, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x10, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,\n    0x01, 0x02, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,\n    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x03, 0x00, 0x00, 0x00, 0x57, 0x00, 0x44, 0x00,\n    0x43, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n    0x41, 0x00, 0x43, 0x00, 0x4d, 0x00, 0x45, 0x00,\n    0x04, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x05, 0x15, 0x00, 0x00, 0x00,\n    0x74, 0xa0, 0x8d, 0x00, 0x3f, 0xa5, 0xc2, 0xe9,\n    0x60, 0x91, 0xe1, 0x22, 0x00, 0x00, 0x00, 0x00,\n    0x80, 0xe1, 0x9b, 0xe2, 0xe0, 0x59, 0xd4, 0x01,\n    0x12, 0x00, 0x77, 0x00, 0x32, 0x00, 0x6b, 0x00,\n    0x38, 0x00, 0x75, 0x00, 0x40, 0x00, 0x61, 0x00,\n    0x62, 0x00, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x12, 0x00, 0x10, 0x00, 0x10, 0x00, 0x28, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x40, 0x00, 0x61, 0x00, 0x62, 0x00,\n    0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x41, 0x00, 0x43, 0x00, 0x4d, 0x00, 0x45, 0x00,\n    0x2e, 0x00, 0x43, 0x00, 0x4f, 0x00, 0x4d, 0x00,\n    0x10, 0x00, 0x00, 0x00, 0xfb, 0xe5, 0x03, 0x12,\n    0x13, 0x00, 0x6c, 0x8e, 0x81, 0x97, 0x09, 0xea,\n    0x76, 0xff, 0xff, 0xff, 0xba, 0xcd, 0x3a, 0xbc,\n    0x67, 0x61, 0x16, 0x9f, 0xb8, 0x96, 0xbc, 0xe1,\n    0xbe, 0x34, 0xe1, 0x77, 0x00, 0x00, 0x00, 0x00\n};\n\nstatic const unsigned char s4u_pac_xrealm[] = {\n    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x01, 0x00, 0x00, 0x00, 0xa0, 0x01, 0x00, 0x00,\n    0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0a, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00,\n    0xf8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0c, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,\n    0x20, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x06, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,\n    0x58, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x07, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,\n    0x68, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x01, 0x10, 0x08, 0x00, 0xcc, 0xcc, 0xcc, 0xcc,\n    0x90, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0xc9, 0x36, 0xfd, 0x57,\n    0x5b, 0x59, 0xd4, 0x01, 0xc9, 0x36, 0xfd, 0x57,\n    0x5b, 0x59, 0xd4, 0x01, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0x0a, 0x00, 0x0a, 0x00,\n    0x04, 0x00, 0x02, 0x00, 0x0a, 0x00, 0x0a, 0x00,\n    0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0c, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x14, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x18, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x76, 0x04, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00,\n    0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x02, 0x00,\n    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x08, 0x00,\n    0x20, 0x00, 0x02, 0x00, 0x08, 0x00, 0x0a, 0x00,\n    0x24, 0x00, 0x02, 0x00, 0x28, 0x00, 0x02, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x10, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,\n    0x01, 0x02, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,\n    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x03, 0x00, 0x00, 0x00, 0x57, 0x00, 0x44, 0x00,\n    0x43, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n    0x41, 0x00, 0x43, 0x00, 0x4d, 0x00, 0x45, 0x00,\n    0x04, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x05, 0x15, 0x00, 0x00, 0x00,\n    0x74, 0xa0, 0x8d, 0x00, 0x3f, 0xa5, 0xc2, 0xe9,\n    0x60, 0x91, 0xe1, 0x22, 0x00, 0x00, 0x00, 0x00,\n    0x80, 0xa8, 0x60, 0x1b, 0x2b, 0x5a, 0xd4, 0x01,\n    0x1c, 0x00, 0x77, 0x00, 0x32, 0x00, 0x6b, 0x00,\n    0x38, 0x00, 0x75, 0x00, 0x40, 0x00, 0x41, 0x00,\n    0x43, 0x00, 0x4d, 0x00, 0x45, 0x00, 0x2e, 0x00,\n    0x43, 0x00, 0x4f, 0x00, 0x4d, 0x00, 0x00, 0x00,\n    0x12, 0x00, 0x10, 0x00, 0x10, 0x00, 0x28, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x40, 0x00, 0x61, 0x00, 0x62, 0x00,\n    0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x41, 0x00, 0x43, 0x00, 0x4d, 0x00, 0x45, 0x00,\n    0x2e, 0x00, 0x43, 0x00, 0x4f, 0x00, 0x4d, 0x00,\n    0x10, 0x00, 0x00, 0x00, 0x11, 0x27, 0x3a, 0xa5,\n    0x41, 0x84, 0x87, 0xdf, 0xc6, 0xd7, 0x29, 0x26,\n    0x76, 0xff, 0xff, 0xff, 0xba, 0x7c, 0x7a, 0x84,\n    0xd2, 0x2b, 0x9c, 0x58, 0xed, 0x2f, 0xdf, 0x23,\n    0x09, 0x15, 0x05, 0x6b, 0x00, 0x00, 0x00, 0x00\n};\n\nstatic const unsigned char s4u_pac_ent_xrealm[] = {\n    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x01, 0x00, 0x00, 0x00, 0xa0, 0x01, 0x00, 0x00,\n    0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0a, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00,\n    0xf8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0c, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,\n    0x28, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x06, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,\n    0x60, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x07, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,\n    0x70, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x01, 0x10, 0x08, 0x00, 0xcc, 0xcc, 0xcc, 0xcc,\n    0x90, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0xc9, 0x36, 0xfd, 0x57,\n    0x5b, 0x59, 0xd4, 0x01, 0xc9, 0x36, 0xfd, 0x57,\n    0x5b, 0x59, 0xd4, 0x01, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0x7f, 0x0a, 0x00, 0x0a, 0x00,\n    0x04, 0x00, 0x02, 0x00, 0x0a, 0x00, 0x0a, 0x00,\n    0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x0c, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x14, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x18, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x76, 0x04, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00,\n    0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x02, 0x00,\n    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x08, 0x00,\n    0x20, 0x00, 0x02, 0x00, 0x08, 0x00, 0x0a, 0x00,\n    0x24, 0x00, 0x02, 0x00, 0x28, 0x00, 0x02, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x10, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,\n    0x01, 0x02, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,\n    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x03, 0x00, 0x00, 0x00, 0x57, 0x00, 0x44, 0x00,\n    0x43, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n    0x41, 0x00, 0x43, 0x00, 0x4d, 0x00, 0x45, 0x00,\n    0x04, 0x00, 0x00, 0x00, 0x01, 0x04, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x05, 0x15, 0x00, 0x00, 0x00,\n    0x74, 0xa0, 0x8d, 0x00, 0x3f, 0xa5, 0xc2, 0xe9,\n    0x60, 0x91, 0xe1, 0x22, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x87, 0x39, 0x5b, 0x4f, 0x5a, 0xd4, 0x01,\n    0x24, 0x00, 0x77, 0x00, 0x32, 0x00, 0x6b, 0x00,\n    0x38, 0x00, 0x75, 0x00, 0x40, 0x00, 0x61, 0x00,\n    0x62, 0x00, 0x63, 0x00, 0x40, 0x00, 0x41, 0x00,\n    0x43, 0x00, 0x4d, 0x00, 0x45, 0x00, 0x2e, 0x00,\n    0x43, 0x00, 0x4f, 0x00, 0x4d, 0x00, 0x00, 0x00,\n    0x12, 0x00, 0x10, 0x00, 0x10, 0x00, 0x28, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x77, 0x00, 0x32, 0x00, 0x6b, 0x00, 0x38, 0x00,\n    0x75, 0x00, 0x40, 0x00, 0x61, 0x00, 0x62, 0x00,\n    0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x41, 0x00, 0x43, 0x00, 0x4d, 0x00, 0x45, 0x00,\n    0x2e, 0x00, 0x43, 0x00, 0x4f, 0x00, 0x4d, 0x00,\n    0x10, 0x00, 0x00, 0x00, 0xa3, 0x5d, 0xc5, 0xfe,\n    0x80, 0x6b, 0x62, 0x0c, 0xb1, 0x2f, 0x43, 0xa2,\n    0x76, 0xff, 0xff, 0xff, 0x95, 0x40, 0x76, 0xe4,\n    0x0a, 0x0a, 0xb9, 0xe7, 0x93, 0x0f, 0x05, 0xf8,\n    0x8a, 0x81, 0x9c, 0x9c, 0x00, 0x00, 0x00, 0x00\n};\n\nstatic const unsigned char fuzz1[] = {\n    0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,\n    0x06, 0xff, 0xff, 0xff, 0x00, 0x00, 0xf5\n};\n\nstatic const unsigned char fuzz2[] = {\n    0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,\n    0x20, 0x20\n};\n\nstatic const char *s4u_principal = \"w2k8u@ACME.COM\";\nstatic const char *s4u_enterprise = \"w2k8u@abc@ACME.COM\";\n\nstatic const krb5_keyblock s4u_srv_key = {\n    0, ENCTYPE_AES256_CTS_HMAC_SHA1_96,\n    32, U(\"\\x14\\xDF\\xB5\\xB2\\xCD\\xB4\\x2C\\x88\\x94\\xDA\\x2F\\xA8\\x82\\xE9\\x72\\x9F\"\n          \"\\x4A\\x4D\\xC7\\x4B\\xA0\\x2A\\x24\\x2C\\xC6\\xA8\\xD7\\x10\\x79\\xB9\\xAD\\x9A\")\n};\n\nstatic const krb5_keyblock s4u_tgt_srv_key = {\n    0, ENCTYPE_AES256_CTS_HMAC_SHA1_96,\n    32, U(\"\\x42\\x0C\\x39\\xC5\\x1A\\x17\\x54\\x04\\x45\\x1F\\x95\\x6B\\x8C\\x58\\xE0\\xF4\"\n          \"\\x1B\\xCA\\x66\\x9A\\x64\\x47\\x95\\xCA\\x6E\\x3A\\xD5\\x5A\\x3B\\x91\\x8C\\x9F\")\n};\n\nstatic size_t s4u_logon_info_buffer_len = 416;\n\nstruct pac_and_info {\n    time_t authtime;\n    krb5_boolean is_enterprise;\n    krb5_boolean is_xrealm;\n    const unsigned char *data;\n    size_t length;\n};\n\nstatic const struct pac_and_info s4u_pacs[] = {\n    { 1538430362, 0, 0, s4u_pac_regular, sizeof(s4u_pac_regular) },\n    { 1538437551, 1, 0, s4u_pac_enterprise, sizeof(s4u_pac_enterprise) },\n    { 1538469429, 0, 1, s4u_pac_xrealm, sizeof(s4u_pac_xrealm) },\n    { 1538484998, 1, 1, s4u_pac_ent_xrealm, sizeof(s4u_pac_ent_xrealm) },\n    { 0, 0, 0, NULL, 0 }\n};\n\n#if !defined(__cplusplus) && (__GNUC__ > 2)\nstatic void err(krb5_context ctx, krb5_error_code code, const char *fmt, ...)\n    __attribute__((__format__(__printf__, 3, 0)));\n#endif\n\nstatic void\nerr(krb5_context ctx, krb5_error_code code, const char *fmt, ...)\n{\n    va_list ap;\n    char *msg;\n    const char *errmsg = NULL;\n\n    va_start(ap, fmt);\n    if (vasprintf(&msg, fmt, ap) < 0)\n        exit(1);\n    va_end(ap);\n    if (ctx && code)\n        errmsg = krb5_get_error_message(ctx, code);\n    if (errmsg)\n        fprintf(stderr, \"t_pac: %s: %s\\n\", msg, errmsg);\n    else\n        fprintf(stderr, \"t_pac: %s\\n\", msg);\n    exit(1);\n}\n\nstatic void\ncheck_pac(krb5_context context, int index, const unsigned char *pdata,\n          size_t plen, time_t auth_time, krb5_principal p,\n          size_t type_one_buffer_length, krb5_boolean with_realm,\n          const krb5_keyblock *server_key, const krb5_keyblock *kdc_key)\n{\n    krb5_error_code ret;\n    const krb5_keyblock *kdc_sign_key;\n    krb5_data data;\n    krb5_pac pac;\n\n    /* If we don't have the KDC key (S4U cases), just use another key as we'd\n     * skip the KDC signature when verifying. */\n    kdc_sign_key = (kdc_key == NULL) ? &kdc_keyblock : kdc_key;\n\n    ret = krb5_pac_parse(context, pdata, plen, &pac);\n    if (ret)\n        err(context, ret, \"[pac: %d] krb5_pac_parse\", index);\n\n    ret = krb5_pac_verify_ext(context, pac, auth_time, p, server_key, kdc_key,\n                              with_realm);\n    if (ret)\n        err(context, ret, \"[pac: %d] krb5_pac_verify_ext\", index);\n\n    ret = krb5_pac_sign_ext(context, pac, auth_time, p, server_key,\n                            kdc_sign_key, with_realm, &data);\n    if (ret)\n        err(context, ret, \"[pac: %d] krb5_pac_sign_ext\", index);\n\n    krb5_pac_free(context, pac);\n\n    ret = krb5_pac_parse(context, data.data, data.length, &pac);\n    krb5_free_data_contents(context, &data);\n    if (ret)\n        err(context, ret, \"[pac: %d] krb5_pac_parse 2\", index);\n\n    ret = krb5_pac_verify_ext(context, pac, auth_time, p, server_key, kdc_key,\n                              with_realm);\n    if (ret)\n        err(context, ret, \"[pac: %d] krb5_pac_verify_ext 2\", index);\n\n    /* make a copy and try to reproduce it */\n    {\n        uint32_t *list;\n        size_t len, i;\n        krb5_pac pac2;\n\n        ret = krb5_pac_init(context, &pac2);\n        if (ret)\n            err(context, ret, \"[pac: %d] krb5_pac_init\", index);\n\n        /* our two user buffer plus the three \"system\" buffers */\n        ret = krb5_pac_get_types(context, pac, &len, &list);\n        if (ret)\n            err(context, ret, \"[pac: %d] krb5_pac_get_types\", index);\n\n        for (i = 0; i < len; i++) {\n            /* skip server_cksum, privsvr_cksum, and logon_name */\n            if (list[i] == 6 || list[i] == 7 || list[i] == 10)\n                continue;\n\n            ret = krb5_pac_get_buffer(context, pac, list[i], &data);\n            if (ret)\n                err(context, ret, \"[pac: %d] krb5_pac_get_buffer\", index);\n\n            if (list[i] == 1) {\n                if (type_one_buffer_length != data.length) {\n                    err(context, 0, \"[pac: %d] type 1 have wrong length: %lu\",\n                        index, (unsigned long)data.length);\n                }\n            } else if (list[i] != 12) {\n                err(context, 0, \"[pac: %d] unknown type %lu\",\n                    index, (unsigned long)list[i]);\n            }\n\n            ret = krb5_pac_add_buffer(context, pac2, list[i], &data);\n            if (ret)\n                err(context, ret, \"[pac: %d] krb5_pac_add_buffer\", index);\n            krb5_free_data_contents(context, &data);\n        }\n        free(list);\n\n        ret = krb5_pac_sign_ext(context, pac2, auth_time, p, server_key,\n                                kdc_sign_key, with_realm, &data);\n        if (ret)\n            err(context, ret, \"[pac: %d] krb5_pac_sign_ext 4\", index);\n\n        krb5_pac_free(context, pac2);\n\n        ret = krb5_pac_parse(context, data.data, data.length, &pac2);\n        if (ret)\n            err(context, ret, \"[pac: %d] krb5_pac_parse 4\", index);\n\n        ret = krb5_pac_verify_ext(context, pac2, auth_time, p, server_key,\n                                  kdc_key, with_realm);\n        if (ret)\n            err(context, ret, \"[pac: %d] krb5_pac_verify_ext 4\", index);\n\n        krb5_free_data_contents(context, &data);\n\n        krb5_pac_free(context, pac2);\n    }\n\n    krb5_pac_free(context, pac);\n}\n\nstatic const krb5_keyblock ticket_sig_krbtgt_key = {\n    0, ENCTYPE_AES256_CTS_HMAC_SHA1_96,\n    32, U(\"\\x7a\\x58\\x98\\xd2\\xaf\\xa6\\xaf\\xc0\\x6a\\xce\\x06\\x04\\x4b\\xc2\\x70\\x84\"\n          \"\\x9b\\x8e\\x0a\\x6c\\x4c\\x07\\xdc\\x6f\\xbb\\x48\\x43\\xe1\\xd2\\xaa\\x97\\xf7\")\n};\n\nstatic const krb5_keyblock ticket_sig_server_key = {\n    0, ENCTYPE_ARCFOUR_HMAC,\n    16, U(\"\\xed\\x23\\x11\\x20\\x7a\\x21\\x44\\x20\\xbf\\xc0\\x8d\\x36\\xf7\\xf6\\xb2\\x3e\")\n};\n\nstatic const krb5_data ticket_data = {\n    .length = 972, .data =\n    \"\\x61\\x82\\x03\\xC8\\x30\\x82\\x03\\xC4\\xA0\\x03\\x02\\x01\\x05\\xA1\\x0A\\x1B\"\n    \"\\x08\\x43\\x44\\x4F\\x4D\\x2E\\x43\\x4F\\x4D\\xA2\\x0F\\x30\\x0D\\xA0\\x03\\x02\"\n    \"\\x01\\x01\\xA1\\x06\\x30\\x04\\x1B\\x02\\x73\\x31\\xA3\\x82\\x03\\x9E\\x30\\x82\"\n    \"\\x03\\x9A\\xA0\\x03\\x02\\x01\\x17\\xA1\\x03\\x02\\x01\\x03\\xA2\\x82\\x03\\x8C\"\n    \"\\x04\\x82\\x03\\x88\\x44\\x31\\x61\\x20\\x17\\xC9\\xFE\\xBC\\xAC\\x46\\xB5\\x77\"\n    \"\\xE9\\x68\\x04\\x4C\\x9B\\x31\\x91\\x0C\\xC1\\xD4\\xDD\\xEF\\xC7\\x34\\x20\\x08\"\n    \"\\x90\\x91\\xE8\\x79\\xE0\\xB5\\x03\\x26\\xA4\\x65\\xDE\\xEC\\x47\\x03\\x2A\\x8F\"\n    \"\\x61\\xE7\\x4D\\x38\\x5A\\x42\\x95\\x5A\\xF9\\x2F\\x41\\x2C\\x2A\\x6E\\x60\\xA1\"\n    \"\\xEB\\x51\\xB3\\xBD\\x4C\\x00\\x41\\x2A\\x44\\x76\\x08\\x37\\x1A\\x51\\xFD\\x65\"\n    \"\\x67\\x7E\\xBF\\x3D\\x90\\x86\\xE3\\x9A\\x54\\x6B\\x67\\xA8\\x08\\x7A\\x73\\xCC\"\n    \"\\xC3\\xB7\\x4B\\xD5\\x5C\\x3A\\x14\\x6C\\xC1\\x5F\\x54\\x4B\\x92\\x55\\xB4\\xB7\"\n    \"\\x92\\x23\\x3F\\x53\\x89\\x47\\x8E\\x1F\\x8B\\xB9\\xDB\\x3B\\x93\\xE8\\x70\\xE4\"\n    \"\\x24\\xB8\\x9D\\xF0\\x0E\\x35\\x28\\xF8\\x7A\\x27\\x5D\\xF7\\x25\\x97\\x9C\\xF5\"\n    \"\\x9F\\x9F\\x64\\x04\\xF2\\xA3\\xAB\\x11\\x15\\xB6\\xDA\\x18\\xD6\\x46\\xD5\\xE6\"\n    \"\\xB8\\x08\\xDE\\x0A\\x62\\xFD\\xF8\\xAA\\x52\\x90\\xD9\\x67\\x29\\xB2\\xCD\\x06\"\n    \"\\xB6\\xB0\\x50\\x2B\\x3F\\x0F\\xA3\\xA5\\xBF\\xAA\\x6E\\x40\\x03\\xD6\\x5F\\x02\"\n    \"\\xBC\\xD8\\x18\\x47\\x97\\x09\\xD7\\xE4\\x96\\x3B\\xCB\\xEB\\x92\\x2C\\x3C\\x49\"\n    \"\\xFF\\x1F\\x71\\xE0\\x52\\x94\\x0F\\x8B\\x9F\\xB8\\x2A\\xBB\\x9C\\xE2\\xA3\\xDD\"\n    \"\\x38\\x89\\xE2\\xB1\\x0B\\x9E\\x1F\\x7A\\xB3\\xE3\\xD2\\xB0\\x94\\xDC\\x87\\xBE\"\n    \"\\x37\\xA6\\xD3\\xB3\\x29\\x35\\x9A\\x72\\xC3\\x7A\\xF1\\xA9\\xE6\\xC5\\xD1\\x26\"\n    \"\\x83\\x65\\x44\\x17\\xBA\\x55\\xA8\\x5E\\x94\\x26\\xED\\xE9\\x8A\\x93\\x11\\x5D\"\n    \"\\x7E\\x20\\x1B\\x9C\\x15\\x9E\\x13\\x37\\x03\\x4D\\xDD\\x99\\x51\\xD8\\x66\\x29\"\n    \"\\x6A\\xB9\\xFB\\x49\\xFE\\x52\\x78\\xDA\\x86\\x85\\xA9\\xA3\\xB9\\xEF\\xEC\\xAD\"\n    \"\\x35\\xA6\\x8D\\xAC\\x0F\\x75\\x22\\xBB\\x0B\\x49\\x1C\\x13\\x52\\x40\\xC9\\x52\"\n    \"\\x69\\x09\\x54\\xD1\\x0F\\x94\\x3F\\x22\\x48\\x67\\xB0\\x96\\x28\\xAA\\xE6\\x28\"\n    \"\\xD9\\x0C\\x08\\xEF\\x51\\xED\\x15\\x5E\\xA2\\x53\\x59\\xA5\\x03\\xB4\\x06\\x20\"\n    \"\\x3D\\xCC\\xB4\\xC5\\xF8\\x8C\\x73\\x67\\xA3\\x21\\x3D\\x19\\xCD\\xD4\\x12\\x28\"\n    \"\\xD2\\x93\\xDE\\x0D\\xF0\\x71\\x10\\x50\\xD6\\x33\\x35\\x04\\x11\\x64\\x43\\x39\"\n    \"\\xC3\\xDF\\x96\\xE3\\x66\\xE3\\x85\\xCA\\xE7\\x67\\x14\\x3A\\xF0\\x43\\xAA\\xBB\"\n    \"\\xD4\\x1D\\xB5\\x24\\xB5\\x74\\x90\\x25\\xA7\\x87\\x7E\\xDB\\xD3\\x83\\x8A\\x3A\"\n    \"\\x69\\xA8\\x2D\\xAF\\xB7\\xB8\\xF3\\xDC\\x13\\xAF\\x45\\x61\\x3F\\x59\\x39\\x7E\"\n    \"\\x69\\xDE\\x0C\\x04\\xF1\\x10\\x6B\\xB4\\x56\\xFA\\x21\\x9F\\x72\\x2B\\x60\\x86\"\n    \"\\xE3\\x23\\x0E\\xC4\\x51\\xF6\\xBE\\xD8\\xE1\\x5F\\xEE\\x73\\x4C\\x17\\x4C\\x2C\"\n    \"\\x1B\\xFB\\x9F\\x1F\\x7A\\x3B\\x07\\x5B\\x8E\\xF1\\x01\\xAC\\xD6\\x30\\x94\\x8A\"\n    \"\\x5D\\x22\\x6F\\x08\\xCE\\xED\\x5E\\xB6\\xDB\\x86\\x8C\\x87\\xEB\\x8D\\x91\\xFF\"\n    \"\\x0A\\x86\\x30\\xBD\\xC0\\xF8\\x25\\xE7\\xAE\\x24\\x35\\xF2\\xFC\\xE5\\xFD\\x1B\"\n    \"\\xB0\\x05\\x4A\\xA3\\xE5\\xEB\\x2E\\x05\\xAD\\x99\\x67\\x49\\x87\\xE6\\xB3\\x87\"\n    \"\\x82\\xA4\\x59\\xA7\\x6E\\xDD\\xF2\\xB6\\x66\\xE8\\xF7\\x70\\xF5\\xBD\\xC9\\x0E\"\n    \"\\xFA\\x9C\\x79\\x84\\xD4\\x9B\\x05\\x0E\\xBB\\xF5\\xDB\\xEF\\xFC\\xCC\\x26\\xF2\"\n    \"\\x93\\xCF\\xD2\\x04\\x3C\\xA9\\x2C\\x65\\x42\\x97\\x86\\xD8\\x38\\x0A\\x1E\\xF6\"\n    \"\\xD6\\xCA\\x30\\xB5\\x1A\\xEC\\xFB\\xBA\\x3B\\x84\\x57\\xB0\\xFD\\xFB\\xE6\\xBC\"\n    \"\\xF2\\x76\\xF6\\x4C\\xBB\\xAB\\xB1\\x31\\xA1\\x27\\x7C\\xE6\\xE6\\x81\\xB6\\xCE\"\n    \"\\x84\\x86\\x40\\xB6\\x40\\x33\\xC4\\xF8\\xB4\\x15\\xCF\\xAA\\xA5\\x51\\x78\\xB9\"\n    \"\\x8B\\x50\\x25\\xB2\\x88\\x86\\x96\\x72\\x8C\\x71\\x4D\\xB5\\x3A\\x94\\x86\\x77\"\n    \"\\x0E\\x95\\x9B\\x16\\x93\\xEF\\x3A\\x11\\x79\\xBA\\x83\\xF7\\x74\\xD3\\x8D\\xBA\"\n    \"\\x15\\xE1\\x2C\\x04\\x57\\xA8\\x92\\x1E\\x9D\\x00\\x8E\\x20\\xFD\\x30\\x70\\xE7\"\n    \"\\xF5\\x65\\x2F\\x19\\x0C\\x94\\xBA\\x03\\x71\\x12\\x96\\xCD\\xC8\\xB4\\x96\\xDB\"\n    \"\\xCE\\x19\\xC2\\xDF\\x3C\\xC2\\xF6\\x3D\\x53\\xED\\x98\\xA5\\x41\\x72\\x2A\\x22\"\n    \"\\x7B\\xF3\\x2B\\x17\\x6C\\xE1\\x39\\x7D\\xAE\\x9B\\x11\\xF9\\xC1\\xA6\\x9E\\x9F\"\n    \"\\x89\\x3C\\x12\\xAA\\x94\\x74\\xA7\\x4F\\x70\\xE8\\xB9\\xDE\\x04\\xF0\\x9D\\x39\"\n    \"\\x24\\x2D\\x92\\xE8\\x46\\x2D\\x2E\\xF0\\x40\\x66\\x1A\\xD9\\x27\\xF9\\x98\\xF1\"\n    \"\\x81\\x1D\\x70\\x62\\x63\\x30\\x6D\\xCD\\x84\\x04\\x5F\\xFA\\x83\\xD3\\xEC\\x8D\"\n    \"\\x86\\xFB\\x40\\x61\\xC1\\x8A\\x45\\xFF\\x7B\\xD9\\xD4\\x18\\x61\\x7F\\x51\\xE3\"\n    \"\\xFC\\x1E\\x18\\xF0\\xAF\\xC6\\x18\\x2C\\xE1\\x6D\\x5D\\xF9\\x62\\xFC\\x20\\xA3\"\n    \"\\xB2\\x8A\\x5F\\xE5\\xBB\\x29\\x0F\\x99\\x63\\x07\\x88\\x38\\x3A\\x3B\\x73\\x2A\"\n    \"\\x6D\\xDA\\x3D\\xA8\\x0D\\x8F\\x56\\x41\\x89\\x82\\xE5\\xB8\\x61\\x00\\x64\\x7D\"\n    \"\\x17\\x0C\\xCE\\x03\\x55\\x8F\\xF4\\x5B\\x0D\\x50\\xF2\\xEB\\x05\\x67\\xBE\\xDB\"\n    \"\\x7B\\x75\\xC5\\xEA\\xA1\\xAB\\x1D\\xB0\\x3C\\x6D\\x42\\x08\\x0B\\x9A\\x45\\x20\"\n    \"\\xA8\\x8F\\xE5\\x67\\x47\\x30\\xDE\\x93\\x5F\\x43\\x05\\xEB\\xA8\\x2D\\x80\\xF5\"\n    \"\\x1A\\xB8\\x4A\\x4E\\x42\\x2D\\x0B\\x7A\\xDC\\x46\\x20\\x2D\\x13\\x17\\xDD\\x4B\"\n    \"\\x94\\x96\\xAA\\x1F\\x06\\x0C\\x1F\\x62\\x07\\x9C\\x40\\xA1\"\n};\n\nstatic void\ntest_pac_ticket_signature(krb5_context context)\n{\n    krb5_error_code ret;\n    krb5_ticket *ticket;\n    krb5_principal sprinc;\n    krb5_authdata **authdata1, **authdata2;\n    krb5_pac pac, pac2, pac3;\n    uint32_t *list;\n    size_t len, i;\n    krb5_data data;\n\n    ret = krb5_decode_ticket(&ticket_data, &ticket);\n    if (ret)\n        err(context, ret, \"while decoding ticket\");\n\n    ret = krb5_decrypt_tkt_part(context, &ticket_sig_server_key, ticket);\n    if (ret)\n        err(context, ret, \"while decrypting ticket\");\n\n    ret = krb5_parse_name(context, \"s1@CDOM.COM\", &sprinc);\n    if (ret)\n        err(context, ret, \"krb5_parse_name\");\n\n    ret = krb5_kdc_verify_ticket(context, ticket->enc_part2, sprinc,\n                                 &ticket_sig_server_key,\n                                 &ticket_sig_krbtgt_key, &pac);\n    if (ret)\n        err(context, ret, \"while verifying ticket\");\n\n    /* In this test, the server is also the client. */\n    ret = krb5_pac_verify(context, pac, ticket->enc_part2->times.authtime,\n                          ticket->server, NULL, NULL);\n    if (ret)\n        err(context, ret, \"while verifying PAC client info\");\n\n    /* We know there is only a PAC in this test's ticket. */\n    authdata1 = ticket->enc_part2->authorization_data;\n    ticket->enc_part2->authorization_data = NULL;\n\n    ret = krb5_kdc_sign_ticket(context, ticket->enc_part2, pac, sprinc,\n                               sprinc, &ticket_sig_server_key,\n                               &ticket_sig_krbtgt_key, FALSE);\n    if (ret)\n        err(context, ret, \"while signing ticket\");\n\n    authdata2 = ticket->enc_part2->authorization_data;\n    assert(authdata2 != NULL);\n    assert(authdata2[1] == NULL);\n\n    assert(authdata1[0]->length == authdata2[0]->length);\n    assert(memcmp(authdata1[0]->contents, authdata2[0]->contents,\n                  authdata1[0]->length) == 0);\n\n    /* Test adding signatures to a new PAC. */\n    ret = krb5_pac_init(context, &pac2);\n    if (ret)\n        err(context, ret, \"krb5_pac_init\");\n\n    ret = krb5_pac_get_types(context, pac, &len, &list);\n    if (ret)\n        err(context, ret, \"krb5_pac_get_types\");\n\n    for (i = 0; i < len; i++) {\n        /* Skip server_cksum, privsvr_cksum, and ticket_cksum. */\n        if (list[i] == 6 || list[i] == 7 || list[i] == 16)\n            continue;\n\n        ret = krb5_pac_get_buffer(context, pac, list[i], &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_get_buffer\");\n\n        ret = krb5_pac_add_buffer(context, pac2, list[i], &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_add_buffer\");\n\n        krb5_free_data_contents(context, &data);\n    }\n    free(list);\n\n    krb5_free_authdata(context, authdata1);\n    krb5_free_authdata(context, ticket->enc_part2->authorization_data);\n    ticket->enc_part2->authorization_data = NULL;\n\n    ret = krb5_kdc_sign_ticket(context, ticket->enc_part2, pac2, sprinc, NULL,\n                               &ticket_sig_server_key, &ticket_sig_krbtgt_key,\n                               FALSE);\n    if (ret)\n        err(context, ret, \"while signing ticket\");\n\n    /* We can't compare the data since the order of the buffers may differ. */\n    ret = krb5_kdc_verify_ticket(context, ticket->enc_part2, sprinc,\n                                 &ticket_sig_server_key,\n                                 &ticket_sig_krbtgt_key, &pac3);\n    if (ret)\n        err(context, ret, \"while verifying ticket\");\n\n    krb5_pac_free(context, pac);\n    krb5_pac_free(context, pac2);\n    krb5_pac_free(context, pac3);\n    krb5_free_principal(context, sprinc);\n    krb5_free_ticket(context, ticket);\n}\n\nint\nmain(int argc, char **argv)\n{\n    krb5_error_code ret;\n    krb5_context context;\n    krb5_pac pac;\n    krb5_data data;\n    krb5_principal p;\n\n    ret = krb5_init_context(&context);\n    if (ret)\n        err(NULL, 0, \"krb5_init_contex\");\n\n    test_pac_ticket_signature(context);\n\n    ret = krb5_set_default_realm(context, \"WIN2K3.THINKER.LOCAL\");\n    if (ret)\n        err(context, ret, \"krb5_set_default_realm\");\n\n    ret = krb5_parse_name(context, user, &p);\n    if (ret)\n        err(context, ret, \"krb5_parse_name\");\n\n    /* Check a pre-saved PAC. */\n    check_pac(context, -1, saved_pac, sizeof(saved_pac), authtime, p,\n              type_1_length, 0, &member_keyblock, &kdc_keyblock);\n\n    /* Check S4U2Self PACs. */\n    {\n        krb5_principal sp;\n        krb5_principal sep;\n        const struct pac_and_info *pi;\n\n        ret = krb5_parse_name(context, s4u_principal, &sp);\n        if (ret)\n            err(context, ret, \"krb5_parse_name\");\n\n        ret = krb5_parse_name_flags(context, s4u_enterprise,\n                                    KRB5_PRINCIPAL_PARSE_ENTERPRISE, &sep);\n        if (ret)\n            err(context, ret, \"krb5_parse_name_flags\");\n\n        for (pi = s4u_pacs; pi->data != NULL; pi++) {\n            check_pac(context, pi - s4u_pacs, pi->data, pi->length,\n                      pi->authtime, pi->is_enterprise ? sep : sp,\n                      s4u_logon_info_buffer_len, pi->is_xrealm,\n                      pi->is_xrealm ? &s4u_tgt_srv_key : &s4u_srv_key, NULL);\n        }\n\n        krb5_free_principal(context, sp);\n        krb5_free_principal(context, sep);\n    }\n\n    /* Check problematic PACs found by fuzzing. */\n    ret = krb5_pac_parse(context, fuzz1, sizeof(fuzz1), &pac);\n    if (!ret)\n        err(context, ret, \"krb5_pac_parse should have failed\");\n    ret = krb5_pac_parse(context, fuzz2, sizeof(fuzz2), &pac);\n    if (!ret)\n        err(context, ret, \"krb5_pac_parse should have failed\");\n\n    /*\n     * Test empty free\n     */\n\n    ret = krb5_pac_init(context, &pac);\n    if (ret)\n        err(context, ret, \"krb5_pac_init\");\n    krb5_pac_free(context, pac);\n\n    /*\n     * Test add remove buffer\n     */\n\n    ret = krb5_pac_init(context, &pac);\n    if (ret)\n        err(context, ret, \"krb5_pac_init\");\n\n    {\n        const krb5_data cdata = { 0, 2, \"\\x00\\x01\" } ;\n\n        ret = krb5_pac_add_buffer(context, pac, 1, &cdata);\n        if (ret)\n            err(context, ret, \"krb5_pac_add_buffer\");\n    }\n    {\n        ret = krb5_pac_get_buffer(context, pac, 1, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_get_buffer\");\n        if (data.length != 2 || memcmp(data.data, \"\\x00\\x01\", 2) != 0)\n            err(context, 0, \"krb5_pac_get_buffer data not the same\");\n        krb5_free_data_contents(context, &data);\n    }\n\n    {\n        const krb5_data cdata = { 0, 2, \"\\x02\\x00\" } ;\n\n        ret = krb5_pac_add_buffer(context, pac, 2, &cdata);\n        if (ret)\n            err(context, ret, \"krb5_pac_add_buffer\");\n    }\n    {\n        ret = krb5_pac_get_buffer(context, pac, 1, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_get_buffer\");\n        if (data.length != 2 || memcmp(data.data, \"\\x00\\x01\", 2) != 0)\n            err(context, 0, \"krb5_pac_get_buffer data not the same\");\n        krb5_free_data_contents(context, &data);\n        /* */\n        ret = krb5_pac_get_buffer(context, pac, 2, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_get_buffer\");\n        if (data.length != 2 || memcmp(data.data, \"\\x02\\x00\", 2) != 0)\n            err(context, 0, \"krb5_pac_get_buffer data not the same\");\n        krb5_free_data_contents(context, &data);\n    }\n\n    ret = krb5_pac_sign(context, pac, authtime, p,\n                        &member_keyblock, &kdc_keyblock, &data);\n    if (ret)\n        err(context, ret, \"krb5_pac_sign\");\n\n    krb5_pac_free(context, pac);\n\n    ret = krb5_pac_parse(context, data.data, data.length, &pac);\n    krb5_free_data_contents(context, &data);\n    if (ret)\n        err(context, ret, \"krb5_pac_parse 3\");\n\n    ret = krb5_pac_verify(context, pac, authtime, p,\n                          &member_keyblock, &kdc_keyblock);\n    if (ret)\n        err(context, ret, \"krb5_pac_verify 3\");\n\n    {\n        uint32_t *list;\n        size_t len;\n\n        /* our two user buffer plus the three \"system\" buffers */\n        ret = krb5_pac_get_types(context, pac, &len, &list);\n        if (ret)\n            err(context, ret, \"krb5_pac_get_types\");\n        if (len != 5)\n            err(context, 0, \"list wrong length\");\n        free(list);\n    }\n\n    {\n        krb5_principal ep, np;\n\n        ret = krb5_parse_name_flags(context, user,\n                                    KRB5_PRINCIPAL_PARSE_ENTERPRISE, &ep);\n        if (ret)\n            err(context, ret, \"krb5_parse_name_flags\");\n\n        ret = krb5_copy_principal(context, ep, &np);\n        if (ret)\n            err(context, ret, \"krb5_copy_principal\");\n        np->type = KRB5_NT_MS_PRINCIPAL;\n\n        /* Try to verify as enterprise. */\n        ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock,\n                              &kdc_keyblock);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify should have failed\");\n\n        ret = krb5_pac_sign(context, pac, authtime, ep, &member_keyblock,\n                            &kdc_keyblock, &data);\n        if (!ret)\n            err(context, ret, \"krb5_pac_sign should have failed\");\n\n        /* Try to verify with realm. */\n        ret = krb5_pac_verify_ext(context, pac, authtime, p, &member_keyblock,\n                                  &kdc_keyblock, TRUE);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify_ext with realm should fail\");\n\n        /* Currently we can't re-sign the PAC with realm (although that could\n         * be useful), only sign a new one. */\n        ret = krb5_pac_sign_ext(context, pac, authtime, p, &member_keyblock,\n                                &kdc_keyblock, TRUE, &data);\n        if (!ret)\n            err(context, ret, \"krb5_pac_sign_ext with realm should fail\");\n\n        krb5_pac_free(context, pac);\n\n        /* Test enterprise. */\n        ret = krb5_pac_init(context, &pac);\n        if (ret)\n            err(context, ret, \"krb5_pac_init\");\n\n        ret = krb5_pac_sign(context, pac, authtime, ep, &member_keyblock,\n                            &kdc_keyblock, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_sign enterprise failed\");\n\n        krb5_pac_free(context, pac);\n\n        ret = krb5_pac_parse(context, data.data, data.length, &pac);\n        krb5_free_data_contents(context, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_parse failed\");\n\n        ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock,\n                              &kdc_keyblock);\n        if (ret)\n            err(context, ret, \"krb5_pac_verify enterprise failed\");\n\n        /* Also verify enterprise as KRB5_NT_MS_PRINCIPAL. */\n        ret = krb5_pac_verify(context, pac, authtime, np, &member_keyblock,\n                              &kdc_keyblock);\n        if (ret)\n            err(context, ret, \"krb5_pac_verify enterprise as nt-ms failed\");\n\n        ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock,\n                              &kdc_keyblock);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify should have failed\");\n\n        krb5_pac_free(context, pac);\n\n        /* Test nt-ms-principal. */\n        ret = krb5_pac_init(context, &pac);\n        if (ret)\n            err(context, ret, \"krb5_pac_init\");\n\n        ret = krb5_pac_sign(context, pac, authtime, np, &member_keyblock,\n                            &kdc_keyblock, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_sign enterprise failed\");\n\n        krb5_pac_free(context, pac);\n\n        ret = krb5_pac_parse(context, data.data, data.length, &pac);\n        krb5_free_data_contents(context, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_parse failed\");\n\n        ret = krb5_pac_verify(context, pac, authtime, np, &member_keyblock,\n                              &kdc_keyblock);\n        if (ret)\n            err(context, ret, \"krb5_pac_verify enterprise failed\");\n\n        /* Also verify as enterprise principal. */\n        ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock,\n                              &kdc_keyblock);\n        if (ret)\n            err(context, ret, \"krb5_pac_verify nt-ms as enterprise failed\");\n\n        ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock,\n                              &kdc_keyblock);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify should have failed\");\n\n        krb5_pac_free(context, pac);\n\n        /* Test with realm. */\n        ret = krb5_pac_init(context, &pac);\n        if (ret)\n            err(context, ret, \"krb5_pac_init\");\n\n        ret = krb5_pac_sign_ext(context, pac, authtime, p, &member_keyblock,\n                                &kdc_keyblock, TRUE, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_sign_ext with realm failed\");\n\n        krb5_pac_free(context, pac);\n\n        ret = krb5_pac_parse(context, data.data, data.length, &pac);\n        krb5_free_data_contents(context, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_parse failed\");\n\n        ret = krb5_pac_verify_ext(context, pac, authtime, p, &member_keyblock,\n                                  &kdc_keyblock, TRUE);\n        if (ret)\n            err(context, ret, \"krb5_pac_verify_ext with realm failed\");\n\n        ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock,\n                              &kdc_keyblock);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify should have failed\");\n\n        krb5_pac_free(context, pac);\n\n        /* Test enterprise with realm. */\n        ret = krb5_pac_init(context, &pac);\n        if (ret)\n            err(context, ret, \"krb5_pac_init\");\n\n        ret = krb5_pac_sign_ext(context, pac, authtime, ep, &member_keyblock,\n                                &kdc_keyblock, TRUE, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_sign_ext ent with realm failed\");\n\n        krb5_pac_free(context, pac);\n\n        ret = krb5_pac_parse(context, data.data, data.length, &pac);\n        krb5_free_data_contents(context, &data);\n        if (ret)\n            err(context, ret, \"krb5_pac_parse failed\");\n\n        ret = krb5_pac_verify_ext(context, pac, authtime, ep, &member_keyblock,\n                                  &kdc_keyblock, TRUE);\n        if (ret)\n            err(context, ret, \"krb5_pac_verify_ext ent with realm failed\");\n\n        ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock,\n                              &kdc_keyblock);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify should have failed\");\n\n        ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock,\n                              &kdc_keyblock);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify should have failed\");\n\n        ret = krb5_pac_verify_ext(context, pac, authtime, p, &member_keyblock,\n                                  &kdc_keyblock, TRUE);\n        if (!ret)\n            err(context, ret, \"krb5_pac_verify_ext should have failed\");\n\n        krb5_free_principal(context, ep);\n        krb5_free_principal(context, np);\n    }\n\n    krb5_pac_free(context, pac);\n\n    krb5_free_principal(context, p);\n    krb5_free_context(context);\n\n    return 0;\n}\n"], "filenames": ["src/lib/krb5/krb/pac.c", "src/lib/krb5/krb/t_pac.c"], "buggy_code_start_loc": [30, 431], "buggy_code_end_loc": [354, 830], "fixing_code_start_loc": [31, 432], "fixing_code_end_loc": [359, 849], "type": "CWE-190", "message": "PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has \"a similar bug.\"", "other": {"cve": {"id": "CVE-2022-42898", "sourceIdentifier": "cve@mitre.org", "published": "2022-12-25T06:15:09.427", "lastModified": "2023-02-23T19:15:11.650", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has \"a similar bug.\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.8", "versionEndExcluding": "1.19.4", "matchCriteriaId": "7DDDCA5D-623C-47CD-A5D3-BD16A066BEBC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.20:-:*:*:*:*:*:*", "matchCriteriaId": "C4D88C23-3917-4891-B9D0-694FCC55B6A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.20:beta1:*:*:*:*:*:*", "matchCriteriaId": "BEDE8B47-EBE0-487C-A52A-8D5F0F5AD851"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:heimdal_project:heimdal:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.7.1", "matchCriteriaId": "537FE65E-6E3F-4441-8B35-7B48214EA04D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:samba:samba:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.15.12", "matchCriteriaId": "659BA682-BA94-493F-8EE1-235661CC958D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:samba:samba:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.16.0", "versionEndExcluding": "4.16.7", "matchCriteriaId": "5D8363DE-B7A3-409B-A485-29B4FA053BFB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:samba:samba:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.17.0", "versionEndExcluding": "4.17.3", "matchCriteriaId": "663B7A0D-CCBB-4EDC-A0E3-97F03E636BD2"}]}]}], "references": [{"url": "https://bugzilla.samba.org/show_bug.cgi?id=15203", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/heimdal/heimdal/security/advisories/GHSA-64mq-fvfj-5x3c", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/krb5/krb5/commit/ea92d2f0fcceb54a70910fa32e9a0d7a5afc3583", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230216-0008/", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20230223-0001/", "source": "cve@mitre.org"}, {"url": "https://web.mit.edu/kerberos/advisories/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://web.mit.edu/kerberos/krb5-1.19/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://web.mit.edu/kerberos/krb5-1.20/README-1.20.1.txt", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://www.samba.org/samba/security/CVE-2022-42898.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/ea92d2f0fcceb54a70910fa32e9a0d7a5afc3583"}}