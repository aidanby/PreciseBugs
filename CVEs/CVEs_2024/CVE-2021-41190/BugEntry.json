{"buggy_code": ["# Open Container Initiative Distribution Specification\n\n## Table of Contents\n\n- [Overview](#overview)\n\t- [Introduction](#introduction)\n\t- [Historical Context](#historical-context)\n\t- [Definitions](#definitions)\n- [Use Cases](#use-cases)\n- [Notational Conventions](#notational-conventions)\n- [Conformance](#conformance)\n\t- [Minimum Requirements](#minimum-requirements)\n\t- [Official Certification](#official-certification)\n\t- [Workflow Categories](#workflow-categories)\n\t\t1. [Pull](#pull)\n\t\t2. [Push](#push)\n\t\t3. [Content Discovery](#content-discovery)\n\t\t4. [Content Management](#content-management)\n- [API](#api)\n\t- [Endpoints](#endpoints)\n\t- [Error Codes](#error-codes)\n- [Appendix](#appendix)\n\n\n## Overview\n\n### Introduction\n\nThe **Open Container Initiative Distribution Specification** (a.k.a. \"OCI Distribution Spec\") defines an API protocol to facilitate and standardize the distribution of content.\n\nWhile OCI Image is the most prominent, the specification is designed to be agnostic of content types. Concepts such as \"manifests\" and \"digests\",\nare currently defined in the [Open Container Initiative Image Format Specification](https://github.com/opencontainers/image-spec) (a.k.a. \"OCI Image Spec\").\n\nTo support other artifact types, please see the [Open Container Initiative Artifact Authors Guide](https://github.com/opencontainers/artifacts) (a.k.a. \"OCI Artifacts\").\n\n### Historical Context\n\nThe spec is based on the specification for the Docker Registry HTTP API V2 protocol <sup>[apdx-1](#appendix)</sup>.\n\nFor relevant details and a history leading up to this specification, please see the following issues:\n\n- [moby/moby#8093](https://github.com/moby/moby/issues/8093)\n- [moby/moby#9015](https://github.com/moby/moby/issues/9015)\n- [docker/docker-registry#612](https://github.com/docker/docker-registry/issues/612)\n\n#### Legacy Docker support HTTP headers\n\nBecause of the origins this specification, the client MAY encounter Docker-specific headers, such as `Docker-Content-Digest`,\nor `Docker-Distribution-API-Version`. These headers are OPTIONAL and clients SHOULD NOT depend on them.\n\n### Definitions\n\nSeveral terms are used frequently in this document and warrant basic definitions:\n\n- **Registry**: a service that handles the required APIs defined in this specification\n- **Client**: a tool that communicates with Registries\n- **Push**: the act of uploading Blobs and Manifests to a Registry\n- **Pull**: the act of downloading Blobs and Manifests from a Registry\n- **Blob**: the binary form of content that is stored by a Registry, addressable by a Digest\n- **Manifest**: a JSON document which defines an Artifact. Manifests are defined under the OCI Image Spec <sup>[apdx-2](#appendix)</sup>\n- **Config**: a blob referenced in the Manifest which contains Artifact metadata. Config is defined under the OCI Image Spec <sup>[apdx-4](#appendix)</sup>\n- **Artifact**: one conceptual piece of content stored as Blobs with an accompanying Manifest containing a Config\n- **Digest**: a unique identifier created from a cryptographic hash of a Blob's content. Digests are defined under the OCI Image Spec <sup>[apdx-3](#appendix)</sup>\n- **Tag**: a custom, human-readable Manifest identifier\n\n## Notational Conventions\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" are to be interpreted as described in [RFC 2119](http://tools.ietf.org/html/rfc2119) (Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997).\n\n## Use Cases\n\n### Artifact Verification\n\nA container engine would like to run verified image named \"library/ubuntu\", with the tag \"latest\".\nThe engine contacts the registry, requesting the manifest for \"library/ubuntu:latest\".\nAn untrusted registry returns a manifest.\nAfter each layer is downloaded, the engine verifies the digest of the layer, ensuring that the content matches that specified by the manifest.\n\n### Resumable Push\n\nCompany X's build servers lose connectivity to a distribution endpoint before completing an artifact layer transfer.\nAfter connectivity returns, the build server attempts to re-upload the artifact.\nThe registry notifies the build server that the upload has already been partially attempted.\nThe build server responds by only sending the remaining data to complete the artifact file.\n\n### Resumable Pull\n\nCompany X is having more connectivity problems but this time in their deployment datacenter.\nWhen downloading an artifact, the connection is interrupted before completion.\nThe client keeps the partial data and uses http `Range` requests to avoid downloading repeated data.\n\n### Layer Upload De-duplication\n\nCompany Y's build system creates two identical layers from build processes A and B.\nBuild process A completes uploading the layer before B.\nWhen process B attempts to upload the layer, the registry indicates that its not necessary because the layer is already known.\n\nIf process A and B upload the same layer at the same time, both operations will proceed and the first to complete will be stored in the registry.\nEven in the case where both uploads are accepted, the registry may securely only store one copy of the layer since the computed digests match.\n\n## Conformance\n\nFor more information on testing for conformance, please see the [conformance README](./conformance/README.md)\n\n### Official Certification\n\nRegistry providers can self-certify by submitting conformance results to [opencontainers/oci-conformance](https://github.com/opencontainers/oci-conformance).\n\n### Requirements\n\nRegistry conformance applies to the following workflow categories:\n\n1. **Pull** - Clients are able to pull from the registry\n2. **Push** - Clients are able to push to the registry\n3. **Content Discovery** - Clients are able to list or otherwise query the content stored in the registry\n4. **Content Management** - Clients are able to control the full life-cycle of the content stored in the registry\n\nAll registries conforming to this specification MUST support, at a minimum, all APIs in the **Pull** category.\n\nRegistries SHOULD also support the **Push**, **Content Discovery**, and **Content Management** categories.\nA registry claiming conformance with one of these specification categories MUST implement all APIs in the claimed category.\n\nIn order to test a registry's conformance against these workflow categories, please use the [conformance testing tool](./conformance/).\n\n### Workflow Categories\n\n#### Pull\n\nThe process of pulling an artifact centers around retrieving two components: the manifest and one or more blobs.\n\nTypically, the first step in pulling an artifact is to retrieve the manifest. However, you MAY retrieve content from the registry in any order.\n\n##### Pulling manifests\n\nTo pull a manifest, perform a `GET` request to a URL in the following form:\n`/v2/<name>/manifests/<reference>` <sup>[end-3](#endpoints)</sup>\n\n`<name>` refers to the namespace of the repository. `<reference>` MUST be either (a) the digest of the manifest or (b) a tag name.\nThe `<reference>` MUST NOT be in any other format. Throughout this document, `<name>` MUST match the following regular expression:\n\n`[a-z0-9]+([._-][a-z0-9]+)*(/[a-z0-9]+([._-][a-z0-9]+)*)*`\n\nThe client SHOULD include an `Accept` header indicating which manifest content types it supports.\nIn a successful response, the `Content-Type` header will indicate the type of the returned manifest.\nFor more information on the use of `Accept` headers and content negotiation, please see [Content Negotiation](./content-negotiation.md)\n\nA GET request to an existing manifest URL MUST provide the expected manifest, with a response code that MUST be `200 OK`.\nA successful response SHOULD contain the digest of the uploaded blob in the header `Docker-Content-Digest`.\n\nThe `Docker-Content-Digest` header, if present on the response, returns the canonical\ndigest of the uploaded blob which MAY differ from the provided digest. If the digest does differ, it MAY be the case that\nthe hashing algorithms used do not match. See [Content Digests](https://github.com/opencontainers/image-spec/blob/v1.0.1/descriptor.md#digests) <sup>[apdx-3](#appendix)</sup> for information on how to detect the hashing\nalgorithm in use. Most clients MAY ignore the value, but if it is used, the client MUST verify the value against the uploaded\nblob data.\n\nIf the manifest is not found in the registry, the response code MUST be `404 Not Found`.\n\n##### Pulling blobs\n\nTo pull a blob, perform a `GET` request to a URL in the following form:\n`/v2/<name>/blobs/<digest>` <sup>[end-2](#endpoints)</sup>\n\n`<name>` is the namespace of the repository, and `<digest>` is the blob's digest.\n\nA GET request to an existing blob URL MUST provide the expected blob, with a response code that MUST be `200 OK`.\nA successful response SHOULD contain the digest of the uploaded blob in the header `Docker-Content-Digest`. If present,\nthe value of this header MUST be a digest matching that of the response body.\n\nIf the blob is not found in the registry, the response code MUST be `404 Not Found`.\n\n##### Checking if content exists in the registry\n\nIn order to verify that a repository contains a given manifest or blob, make a `HEAD` request to a URL in the following form:\n\n`/v2/<name>/manifests/<reference>` <sup>[end-3](#endpoints)</sup> (for manifests), or\n\n`/v2/<name>/blobs/<digest>` <sup>[end-2](#endpoints)</sup> (for blobs).\n\nA HEAD request to an existing blob or manifest URL MUST return `200 OK`. A successful response SHOULD contain the digest\nof the uploaded blob in the header `Docker-Content-Digest`.\n\nIf the blob or manifest is not found in the registry, the response code MUST be `404 Not Found`.\n\n#### Push\n\nPushing an artifact typically works in the opposite order as a pull: the blobs making up the artifact are uploaded first,\nand the manifest last. Strictly speaking, content can be uploaded to the registry in any order, but a registry MAY reject\na manifest if it references blobs that are not yet uploaded, resulting in a `BLOB_UNKNOWN` error <sup>[code-1](#error-codes)</sup>.\nA useful diagram is provided [here](https://github.com/google/go-containerregistry/tree/d7f8d06c87ed209507dd5f2d723267fe35b38a9f/pkg/v1/remote#anatomy-of-an-image-upload).\n\n##### Pushing blobs\n\nThere are two ways to push blobs: chunked or monolithic.\n\n##### Pushing a blob monolithically\n\nThere are two ways to push a blob monolithically:\n1. A `POST` request followed by a `PUT` request\n2. A single `POST` request\n\n---\n\n###### POST then PUT\n\nTo push a blob monolithically by using a POST request followed by a PUT request, there are two steps:\n1. Obtain a session id (upload URL)\n2. Upload the blob to said URL\n\nTo obtain a session ID, perform a `POST` request to a URL in the following format:\n\n`/v2/<name>/blobs/uploads/` <sup>[end-4a](#endpoints)</sup>\n\nHere, `<name>` refers to the namespace of the repository. Upon success, the response MUST have a code of `202 Accepted`, and MUST include the following header:\n\n```\nLocation: <location>\n```\n\nThe `<location>` MUST contain a UUID representing a unique session ID for the upload to follow. The `<location>` does not necessarily need to be provided by the registry itself. In fact, offloading to another server can be a [better strategy](https://www.backblaze.com/blog/design-thinking-b2-apis-the-hidden-costs-of-s3-compatibility/).\n\nOptionally, the location MAY be absolute (containing the protocol and/or hostname), or it MAY be relative (containing just the URL path). For more information,\nsee [RFC 7231](https://tools.ietf.org/html/rfc7231#section-7.1.2).\n\nOnce the `<location>` has been obtained, perform the upload proper by making a `PUT` request to the following URL path, and with the following headers and body:\n\n`<location>?digest=<digest>` <sup>[end-6](#endpoints)</sup>\n```\nContent-Length: <length>\nContent-Type: application/octet-stream\n```\n```\n<upload byte stream>\n```\n\nThe `<location>` MAY contain critical query parameters. Additionally, it SHOULD match exactly the `<location>` obtained from the `POST` request. It SHOULD NOT be assembled manually by clients except where absolute/relative conversion is necessary.\n\nHere, `<digest>` is the digest of the blob being uploaded, and `<length>` is its size in bytes.\n\nUpon successful completion of the request, the response MUST have code `201 Created` and MUST have the following header:\n\n```\nLocation: <blob-location>\n```\n\nWith `<blob-location>` being a pullable blob URL.\n\n---\n\n###### Single POST\n\nRegistries MAY support pushing blobs using a single POST request.\n\nTo push a blob monolithically by using a single POST request, perform a `POST` request to a URL in the following form, and with the following headers and body:\n\n`/v2/<name>/blobs/uploads/?digest=<digest>` <sup>[end-4b](#endpoints)</sup>\n```\nContent-Length: <length>\nContent-Type: application/octet-stream\n```\n```\n<upload byte stream>\n```\n\nHere, `<name>` is the repository's namespace, `<digest>` is the blob's digest, and `<length>` is the size (in bytes) of the blob.\n\nThe `Content-Length` header MUST match the blob's actual content length. Likewise, the `<digest>` MUST match the blob's digest.\n\nRegistries that do not support single request monolithic uploads SHOULD return a `202 Accepted` status code and `Location` header and clients SHOULD proceed with a subsequent PUT request, as described by the [POST then PUT upload method](#post-then-put).\n\nSuccessful completion of the request MUST return a `201 Created` and MUST include the following header:\n\n```\nLocation: <blob-location>\n```\n\nHere, `<blob-location>` is a pullable blob URL. This location does not necessarily have to be served by your register, for example, in the case of a signed URL from\nsome cloud storage provider that your registry generates.\n\n\n##### Pushing a blob in chunks\n\nA chunked blob upload is accomplished in three phases:\n1. Obtain a session ID (upload URL) (`POST`)\n2. Upload the chunks (`PATCH`)\n3. Close the session (`PUT`)\n\nFor information on obtaining a session ID, reference the above section on pushing a blob monolithically via the `POST`/`PUT` method. The process remains unchanged for chunked upload, except that the post request MUST include the following header:\n\n```\nContent-Length: 0\n```\n\nPlease reference the above section for restrictions on the `<location>`.\n\n---\nTo upload a chunk, issue a `PATCH` request to a URL path in the following format, and with the following headers and body:\n\nURL path: `<location>` <sup>[end-5](#endpoints)</sup>\n```\nContent-Type: application/octet-stream\nContent-Range: <range>\nContent-Length: <length>\n```\n```\n<upload byte stream of chunk>\n```\n\nThe `<location>` refers to the URL obtained from the preceding `POST` request.\n\nThe `<range>` refers to the byte range of the chunk, and MUST be inclusive on both ends. The first chunk's range MUST begin with `0`. It MUST match the following regular expression:\n\n```regexp\n^[0-9]+-[0-9]+$\n```\n\nThe `<length>` is the content-length, in bytes, of the current chunk.\n\nEach successful chunk upload MUST have a `202 Accepted` response code, and MUST have the following header:\n\n```\nLocation <location>\n```\n\nEach consecutive chunk upload SHOULD use the `<location>` provided in the response to the previous chunk upload.\n\nChunks MUST be uploaded in order, with the first byte of a chunk being the last chunk's `<end-of-range>` plus one. If a chunk is uploaded out of order, the registry MUST respond with a `416 Requested Range Not Satisfiable` code.\n\nThe final chunk MAY be uploaded using a `PATCH` request or it MAY be uploaded in the closing `PUT` request. Regardless of how the final chunk is uploaded, the session MUST be closed with a `PUT` request.\n\n---\n\nTo close the session, issue a `PUT` request to a url in the following format, and with the following headers (and optional body, depending on whether or not the final chunk was uploaded already via a `PATCH` request):\n\n`<location>?digest=<digest>`\n```\nContent-Length: <length of chunk, if present>\nContent-Range: <range of chunk, if present>\nContent-Type: application/octet-stream <if chunk provided>\n```\n```\nOPTIONAL: <final chunk byte stream>\n```\n\nThe closing `PUT` request MUST include the `<digest>` of the whole blob (not the final chunk) as a query parameter.\n\nThe response to a successful closing of the session MUST be `201 Created`, and MUST contain the following header:\n```\nLocation: <blob-location>\n```\n\nHere, `<blob-location>` is a pullable blob URL.\n\n\n##### Mounting a blob from another repository\n\nIf a necessary blob exists already in another repository, it can be mounted into a different repository via a `POST`\nrequest in the following format:\n\n`/v2/<name>/blobs/uploads/?mount=<digest>&from=<other_name>`  <sup>[end-11](#endpoints)</sup>.\n\nIn this case, `<name>` is the namespace to which the blob will be mounted. `<digest>` is the digest of the blob to mount,\nand `<other_name>` is the namespace from which the blob should be mounted. This step is usually taken in place of the\npreviously-described `POST` request to `/v2/<name>/blobs/uploads/` <sup>[end-4a](#endpoints)</sup> (which is used to initiate an\nupload session).\n\nThe response to a successful mount MUST be `201 Created`, and MUST contain the following header:\n```\nLocation: <blob-location>\n```\n\nThe Location header will contain the registry URL to access the accepted layer file. The Docker-Content-Digest\nheader returns the canonical digest of the uploaded blob which MAY differ from the provided digest. Most clients MAY\nignore the value but if it is used, the client SHOULD verify the value against the uploaded blob data.\n\nAlternatively, if a registry does not support cross-repository mounting or is unable to mount the requested blob,\nit SHOULD return a `202`. This indicates that the upload session has begun and that the client MAY proceed with the upload.\n\n##### Pushing Manifests\n\nTo push a manifest, perform a `PUT` request to a path in the following format, and with the following headers\nand body:\n`/v2/<name>/manifests/<reference>` <sup>[end-7](#endpoints)</sup>\n```\nContent-Type: application/vnd.oci.image.manifest.v1+json\n```\n```\n<manifest byte stream>\n```\n\n`<name>` is the namespace of the repository, and the `<reference>` MUST be either a) a digest or b) a tag.\n\nThe uploaded manifest MUST reference any blobs that make up the artifact. However, the list of blobs MAY\nbe empty. Upon a successful upload, the registry MUST return response code `201 Created`, and MUST have the\nfollowing header:\n\n```\nLocation: <location>\n```\n\nThe `<location>` is a pullable manifest URL.\n\nAn attempt to pull a nonexistent repository MUST return response code `404 Not Found`\n\n#### Content Discovery\n\nCurrently, the only functionality provided by this workflow is the ability to discover tags.\n\nTo fetch the list of tags, perform a `GET` request to a path in the following format:\n`/v2/<name>/tags/list` <sup>[end-8a](#endpoints)</sup>\n\n`<name>` is the namespace of the repository. Assuming a repository is found, this request MUST return a\n`200 OK` response code. The list of tags MAY be empty if there are no tags on the repository. If the list is not empty,\nthe tags MUST be in lexical order (i.e. case-insensitive alphanumeric order).\n\nUpon success, the response MUST be a json body in the following format:\n```json\n{\n  \"name\": \"<name>\",\n  \"tags\": [\n    \"<tag1>\",\n    \"<tag2>\",\n    \"<tag3>\"\n  ]\n}\n```\n\n`<name>` is the namespace of the repository, and `<tag1>`, `<tag2>`, and `<tag3>` are each tags on the repository.\n\nIn addition to fetching the whole list of tags, a subset of the tags can be fetched by providing the `n` query parameter.\nIn this case, the path will look like the following:\n`/v2/<name>/tags/list?n=<int>` <sup>[end-8b](#endpoints)</sup>\n\n`<name>` is the namespace of the repository, and `<int>` is an integer specifying the number of tags requested. The response\nto such a request MAY return fewer than `<int>` results, but only when the total number of tags attached to the repository\nis less than `<int>`. Otherwise, the response MUST include `<int>` results. When `n` is zero, this endpoint MUST return\nan empty list, and MUST NOT include a `Link` header. Without the `last` query parameter (described next), the list returned will\nstart at the beginning of the list and include `<int>` results. As above, the tags MUST be in lexical order.\n\nThe `last` query parameter provides further means for limiting the number of tags. It is usually used in combination with the\n`n` parameter:\n`/v2/<name>/tags/list?n=<int>&last=<tagname>` <sup>[end-8b](#endpoints)</sup>\n\n`<name>` is the namespace of the repository, `<int>` is the number of tags requested, and `<tagname>` is the *value* of\nthe last tag. `<tagname>` MUST NOT be a numerical index, but rather it MUST be a proper tag. A request of this sort will return\nup to `<int>` tags, beginning non-inclusively with `<tagname>`. That is to say, `<tagname>` will not be included in the\nresults, but up to `<int>` tags *after* `<tagname>` will be returned. The tags MUST be in lexical order.\n\nWhen using the `last` query parameter, the `n` parameter is OPTIONAL.\n\n#### Content Management\n\nContent management refers to the deletion of blobs, tags, and manifests. Registries MAY implement deletion or they MAY\ndisable it. Similarly, a registry MAY implement tag deletion, while others MAY allow deletion only by manifest.\n\n##### Deleting tags\n\n`<name>` is the namespace of the repository, and `<tag>` is the name of the tag to be deleted. Upon success, the registry\nMUST respond with a `202 Accepted` code. If tag deletion is disabled, the registry MUST respond with either a\n`400 Bad Request` or a `405 Method Not Allowed`.\n\nTo delete a tag, perform a `DELETE` request to a path in the following format:\n`/v2/<name>/manifests/<tag>` <sup>[end-9](#endpoints)</sup>\n\n##### Deleting Manifests\n\nTo delete a manifest, perform a `DELETE` request to a path in the following format:\n`/v2/<name>/manifests/<digest>` <sup>[end-9](#endpoints)</sup>\n\n`<name>` is the namespace of the repository, and `<digest>` is the digest of the manifest to be deleted. Upon success, the registry\nMUST respond with a `202 Accepted` code. If the repository does not exist, the response MUST return `404 Not Found`.\n\n##### Deleting Blobs\n\nTo delete a blob, perform a `DELETE` request to a path in the following format:\n`/v2/<name>/blobs/<digest>` <sup>[end-10](#endpoints)</sup>\n\n`<name>` is the namespace of the repository, and `<digest>` is the digest of the blob to be deleted. Upon success, the\nregistry MUST respond with code `202 Accepted`. If the blob is not found, a `404 Not Found` code MUST be returned.\n\n### API\n\nThe API operates over HTTP. Below is a summary of the endpoints used by the API.\n\n#### Determining Support\n\nTo check whether or not the registry implements this specification, perform a `GET` request to the following endpoint:\n`/v2/` <sup>[end-1](#endpoints)</sup>.\n\nIf the response is `200 OK`, then the registry implements this specification.\n\nThis endpoint MAY be used for authentication/authorization purposes, but this is out of the purview\nof this specification.\n\n#### Endpoints\n\n| ID     | Method         | API Endpoint                                                      | Success     | Failure           |\n| ------ | -------------- | ------------------------------------------------------------ | ----------- | ----------------- |\n| end-1  | `GET`          | `/v2/`                                                       | `200`       | `404`/`401`       |\n| end-2  | `GET` / `HEAD` | `/v2/<name>/blobs/<digest>`                                  | `200`       | `404`             |\n| end-3  | `GET` / `HEAD` | `/v2/<name>/manifests/<reference>`                           | `200`       | `404`             |\n| end-4a | `POST`         | `/v2/<name>/blobs/uploads/`                                  | `202`       | `404`             |\n| end-4b | `POST`         | `/v2/<name>/blobs/uploads/?digest=<digest>`                  | `201`/`202` | `404`/`400`       |\n| end-5  | `PATCH`        | `/v2/<name>/blobs/uploads/<reference>`                       | `202`       | `404`/`416`       |\n| end-6  | `PUT`          | `/v2/<name>/blobs/uploads/<reference>?digest=<digest>`       | `201`       | `404`/`400`       |\n| end-7  | `PUT`          | `/v2/<name>/manifests/<reference>`                           | `201`       | `404`             |\n| end-8a | `GET`          | `/v2/<name>/tags/list`                                       | `200`       | `404`             |\n| end-8b | `GET`          | `/v2/<name>/tags/list?n=<integer>&last=<integer>`            | `200`       | `404`             |\n| end-9  | `DELETE`       | `/v2/<name>/manifests/<reference>`                           | `202`       | `404`/`400`/`405` |\n| end-10 | `DELETE`       | `/v2/<name>/blobs/<digest>`                                  | `202`       | `404`/`405`       |\n| end-11 | `POST`         | `/v2/<name>/blobs/uploads/?mount=<digest>&from=<other_name>` | `201`       | `404`             |\n\n#### Error Codes\n\nA `4XX` response code from the registry MAY return a body in any format. If the response body is in JSON format, it MUST\nhave the following format:\n\n```json\n    {\n        \"errors\": [\n            {\n                \"code\": \"<error identifier, see below>\",\n                \"message\": \"<message describing condition>\",\n                \"detail\": \"<unstructured>\"\n            },\n            ...\n        ]\n    }\n```\n\nThe `code` field MUST be a unique identifier, containing only uppercase alphabetic characters and underscores. The\n`message` field is OPTIONAL, and if present, it SHOULD be a human readable string or MAY be empty. The `detail` field is\nOPTIONAL and MAY contain arbitrary JSON data providing information the client can use to resolve the issue.\n\nThe `code` field MUST be one of the following:\n\n| ID      | Code                    | Description                                    |\n|-------- | ------------------------|------------------------------------------------|\n| code-1  | `BLOB_UNKNOWN`          | blob unknown to registry                       |\n| code-2  | `BLOB_UPLOAD_INVALID`   | blob upload invalid                            |\n| code-3  | `BLOB_UPLOAD_UNKNOWN`   | blob upload unknown to registry                |\n| code-4  | `DIGEST_INVALID`        | provided digest did not match uploaded content |\n| code-5  | `MANIFEST_BLOB_UNKNOWN` | blob unknown to registry                       |\n| code-6  | `MANIFEST_INVALID`      | manifest invalid                               |\n| code-7  | `MANIFEST_UNKNOWN`      | manifest unknown                               |\n| code-8  | `NAME_INVALID`          | invalid repository name                        |\n| code-9  | `NAME_UNKNOWN`          | repository name not known to registry          |\n| code-10 | `SIZE_INVALID`          | provided length did not match content length   |\n| code-12 | `UNAUTHORIZED`          | authentication required                        |\n| code-13 | `DENIED`                | requested access to the resource is denied     |\n| code-14 | `UNSUPPORTED`           | the operation is unsupported                   |\n| code-15 | `TOOMANYREQUESTS`       | too many requests                              |\n\n### Appendix\n\nThe following is a list of documents referenced in this spec:\n\n| ID     | Title | Description |\n| ------ | ----- | ----------- |\n| apdx-1 | [Docker Registry HTTP API V2](https://github.com/docker/distribution/blob/5cb406d511b7b9163bff9b6439072e4892e5ae3b/docs/spec/api.md) | The original document upon which this spec was based |\n| apdx-1 | [Details](./detail.md) | Historical document describing original API endpoints and requests in detail |\n| apdx-2 | [OCI Image Spec - manifests](https://github.com/opencontainers/image-spec/blob/v1.0.1/manifest.md) | Description of manifests, defined by the OCI Image Spec |\n| apdx-3 | [OCI Image Spec - digests](https://github.com/opencontainers/image-spec/blob/v1.0.1/descriptor.md#digests) | Description of digests, defined by the OCI Image Spec |\n| apdx-4 | [OCI Image Spec - config](https://github.com/opencontainers/image-spec/blob/v1.0.1/config.md) | Description of configs, defined by the OCI Image Spec |\n"], "fixing_code": ["# Open Container Initiative Distribution Specification\n\n## Table of Contents\n\n- [Overview](#overview)\n\t- [Introduction](#introduction)\n\t- [Historical Context](#historical-context)\n\t- [Definitions](#definitions)\n- [Use Cases](#use-cases)\n- [Notational Conventions](#notational-conventions)\n- [Conformance](#conformance)\n\t- [Minimum Requirements](#minimum-requirements)\n\t- [Official Certification](#official-certification)\n\t- [Workflow Categories](#workflow-categories)\n\t\t1. [Pull](#pull)\n\t\t2. [Push](#push)\n\t\t3. [Content Discovery](#content-discovery)\n\t\t4. [Content Management](#content-management)\n- [API](#api)\n\t- [Endpoints](#endpoints)\n\t- [Error Codes](#error-codes)\n- [Appendix](#appendix)\n\n\n## Overview\n\n### Introduction\n\nThe **Open Container Initiative Distribution Specification** (a.k.a. \"OCI Distribution Spec\") defines an API protocol to facilitate and standardize the distribution of content.\n\nWhile OCI Image is the most prominent, the specification is designed to be agnostic of content types. Concepts such as \"manifests\" and \"digests\",\nare currently defined in the [Open Container Initiative Image Format Specification](https://github.com/opencontainers/image-spec) (a.k.a. \"OCI Image Spec\").\n\nTo support other artifact types, please see the [Open Container Initiative Artifact Authors Guide](https://github.com/opencontainers/artifacts) (a.k.a. \"OCI Artifacts\").\n\n### Historical Context\n\nThe spec is based on the specification for the Docker Registry HTTP API V2 protocol <sup>[apdx-1](#appendix)</sup>.\n\nFor relevant details and a history leading up to this specification, please see the following issues:\n\n- [moby/moby#8093](https://github.com/moby/moby/issues/8093)\n- [moby/moby#9015](https://github.com/moby/moby/issues/9015)\n- [docker/docker-registry#612](https://github.com/docker/docker-registry/issues/612)\n\n#### Legacy Docker support HTTP headers\n\nBecause of the origins this specification, the client MAY encounter Docker-specific headers, such as `Docker-Content-Digest`,\nor `Docker-Distribution-API-Version`. These headers are OPTIONAL and clients SHOULD NOT depend on them.\n\n### Definitions\n\nSeveral terms are used frequently in this document and warrant basic definitions:\n\n- **Registry**: a service that handles the required APIs defined in this specification\n- **Client**: a tool that communicates with Registries\n- **Push**: the act of uploading Blobs and Manifests to a Registry\n- **Pull**: the act of downloading Blobs and Manifests from a Registry\n- **Blob**: the binary form of content that is stored by a Registry, addressable by a Digest\n- **Manifest**: a JSON document which defines an Artifact. Manifests are defined under the OCI Image Spec <sup>[apdx-2](#appendix)</sup>\n- **Config**: a blob referenced in the Manifest which contains Artifact metadata. Config is defined under the OCI Image Spec <sup>[apdx-4](#appendix)</sup>\n- **Artifact**: one conceptual piece of content stored as Blobs with an accompanying Manifest containing a Config\n- **Digest**: a unique identifier created from a cryptographic hash of a Blob's content. Digests are defined under the OCI Image Spec <sup>[apdx-3](#appendix)</sup>\n- **Tag**: a custom, human-readable Manifest identifier\n\n## Notational Conventions\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" are to be interpreted as described in [RFC 2119](http://tools.ietf.org/html/rfc2119) (Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997).\n\n## Use Cases\n\n### Artifact Verification\n\nA container engine would like to run verified image named \"library/ubuntu\", with the tag \"latest\".\nThe engine contacts the registry, requesting the manifest for \"library/ubuntu:latest\".\nAn untrusted registry returns a manifest.\nAfter each layer is downloaded, the engine verifies the digest of the layer, ensuring that the content matches that specified by the manifest.\n\n### Resumable Push\n\nCompany X's build servers lose connectivity to a distribution endpoint before completing an artifact layer transfer.\nAfter connectivity returns, the build server attempts to re-upload the artifact.\nThe registry notifies the build server that the upload has already been partially attempted.\nThe build server responds by only sending the remaining data to complete the artifact file.\n\n### Resumable Pull\n\nCompany X is having more connectivity problems but this time in their deployment datacenter.\nWhen downloading an artifact, the connection is interrupted before completion.\nThe client keeps the partial data and uses http `Range` requests to avoid downloading repeated data.\n\n### Layer Upload De-duplication\n\nCompany Y's build system creates two identical layers from build processes A and B.\nBuild process A completes uploading the layer before B.\nWhen process B attempts to upload the layer, the registry indicates that its not necessary because the layer is already known.\n\nIf process A and B upload the same layer at the same time, both operations will proceed and the first to complete will be stored in the registry.\nEven in the case where both uploads are accepted, the registry may securely only store one copy of the layer since the computed digests match.\n\n## Conformance\n\nFor more information on testing for conformance, please see the [conformance README](./conformance/README.md)\n\n### Official Certification\n\nRegistry providers can self-certify by submitting conformance results to [opencontainers/oci-conformance](https://github.com/opencontainers/oci-conformance).\n\n### Requirements\n\nRegistry conformance applies to the following workflow categories:\n\n1. **Pull** - Clients are able to pull from the registry\n2. **Push** - Clients are able to push to the registry\n3. **Content Discovery** - Clients are able to list or otherwise query the content stored in the registry\n4. **Content Management** - Clients are able to control the full life-cycle of the content stored in the registry\n\nAll registries conforming to this specification MUST support, at a minimum, all APIs in the **Pull** category.\n\nRegistries SHOULD also support the **Push**, **Content Discovery**, and **Content Management** categories.\nA registry claiming conformance with one of these specification categories MUST implement all APIs in the claimed category.\n\nIn order to test a registry's conformance against these workflow categories, please use the [conformance testing tool](./conformance/).\n\n### Workflow Categories\n\n#### Pull\n\nThe process of pulling an artifact centers around retrieving two components: the manifest and one or more blobs.\n\nTypically, the first step in pulling an artifact is to retrieve the manifest. However, you MAY retrieve content from the registry in any order.\n\n##### Pulling manifests\n\nTo pull a manifest, perform a `GET` request to a URL in the following form:\n`/v2/<name>/manifests/<reference>` <sup>[end-3](#endpoints)</sup>\n\n`<name>` refers to the namespace of the repository. `<reference>` MUST be either (a) the digest of the manifest or (b) a tag name.\nThe `<reference>` MUST NOT be in any other format. Throughout this document, `<name>` MUST match the following regular expression:\n\n`[a-z0-9]+([._-][a-z0-9]+)*(/[a-z0-9]+([._-][a-z0-9]+)*)*`\n\nThe client SHOULD include an `Accept` header indicating which manifest content types it supports.\nIn a successful response, the `Content-Type` header will indicate the type of the returned manifest.\nThe `Content-Type` header SHOULD match what the client [pushed as the manifest's `Content-Type`](#pushing-manifests).\nIf the manifest has a `mediaType` field, clients SHOULD reject unless the `mediaType` field's value matches the type specified by the `Content-Type` header.\nFor more information on the use of `Accept` headers and content negotiation, please see [Content Negotiation](./content-negotiation.md).\n\nA GET request to an existing manifest URL MUST provide the expected manifest, with a response code that MUST be `200 OK`.\nA successful response SHOULD contain the digest of the uploaded blob in the header `Docker-Content-Digest`.\n\nThe `Docker-Content-Digest` header, if present on the response, returns the canonical\ndigest of the uploaded blob which MAY differ from the provided digest. If the digest does differ, it MAY be the case that\nthe hashing algorithms used do not match. See [Content Digests](https://github.com/opencontainers/image-spec/blob/v1.0.1/descriptor.md#digests) <sup>[apdx-3](#appendix)</sup> for information on how to detect the hashing\nalgorithm in use. Most clients MAY ignore the value, but if it is used, the client MUST verify the value against the uploaded\nblob data.\n\nIf the manifest is not found in the registry, the response code MUST be `404 Not Found`.\n\n##### Pulling blobs\n\nTo pull a blob, perform a `GET` request to a URL in the following form:\n`/v2/<name>/blobs/<digest>` <sup>[end-2](#endpoints)</sup>\n\n`<name>` is the namespace of the repository, and `<digest>` is the blob's digest.\n\nA GET request to an existing blob URL MUST provide the expected blob, with a response code that MUST be `200 OK`.\nA successful response SHOULD contain the digest of the uploaded blob in the header `Docker-Content-Digest`. If present,\nthe value of this header MUST be a digest matching that of the response body.\n\nIf the blob is not found in the registry, the response code MUST be `404 Not Found`.\n\n##### Checking if content exists in the registry\n\nIn order to verify that a repository contains a given manifest or blob, make a `HEAD` request to a URL in the following form:\n\n`/v2/<name>/manifests/<reference>` <sup>[end-3](#endpoints)</sup> (for manifests), or\n\n`/v2/<name>/blobs/<digest>` <sup>[end-2](#endpoints)</sup> (for blobs).\n\nA HEAD request to an existing blob or manifest URL MUST return `200 OK`. A successful response SHOULD contain the digest\nof the uploaded blob in the header `Docker-Content-Digest`.\n\nIf the blob or manifest is not found in the registry, the response code MUST be `404 Not Found`.\n\n#### Push\n\nPushing an artifact typically works in the opposite order as a pull: the blobs making up the artifact are uploaded first,\nand the manifest last. Strictly speaking, content can be uploaded to the registry in any order, but a registry MAY reject\na manifest if it references blobs that are not yet uploaded, resulting in a `BLOB_UNKNOWN` error <sup>[code-1](#error-codes)</sup>.\nA useful diagram is provided [here](https://github.com/google/go-containerregistry/tree/d7f8d06c87ed209507dd5f2d723267fe35b38a9f/pkg/v1/remote#anatomy-of-an-image-upload).\n\n##### Pushing blobs\n\nThere are two ways to push blobs: chunked or monolithic.\n\n##### Pushing a blob monolithically\n\nThere are two ways to push a blob monolithically:\n1. A `POST` request followed by a `PUT` request\n2. A single `POST` request\n\n---\n\n###### POST then PUT\n\nTo push a blob monolithically by using a POST request followed by a PUT request, there are two steps:\n1. Obtain a session id (upload URL)\n2. Upload the blob to said URL\n\nTo obtain a session ID, perform a `POST` request to a URL in the following format:\n\n`/v2/<name>/blobs/uploads/` <sup>[end-4a](#endpoints)</sup>\n\nHere, `<name>` refers to the namespace of the repository. Upon success, the response MUST have a code of `202 Accepted`, and MUST include the following header:\n\n```\nLocation: <location>\n```\n\nThe `<location>` MUST contain a UUID representing a unique session ID for the upload to follow. The `<location>` does not necessarily need to be provided by the registry itself. In fact, offloading to another server can be a [better strategy](https://www.backblaze.com/blog/design-thinking-b2-apis-the-hidden-costs-of-s3-compatibility/).\n\nOptionally, the location MAY be absolute (containing the protocol and/or hostname), or it MAY be relative (containing just the URL path). For more information,\nsee [RFC 7231](https://tools.ietf.org/html/rfc7231#section-7.1.2).\n\nOnce the `<location>` has been obtained, perform the upload proper by making a `PUT` request to the following URL path, and with the following headers and body:\n\n`<location>?digest=<digest>` <sup>[end-6](#endpoints)</sup>\n```\nContent-Length: <length>\nContent-Type: application/octet-stream\n```\n```\n<upload byte stream>\n```\n\nThe `<location>` MAY contain critical query parameters. Additionally, it SHOULD match exactly the `<location>` obtained from the `POST` request. It SHOULD NOT be assembled manually by clients except where absolute/relative conversion is necessary.\n\nHere, `<digest>` is the digest of the blob being uploaded, and `<length>` is its size in bytes.\n\nUpon successful completion of the request, the response MUST have code `201 Created` and MUST have the following header:\n\n```\nLocation: <blob-location>\n```\n\nWith `<blob-location>` being a pullable blob URL.\n\n---\n\n###### Single POST\n\nRegistries MAY support pushing blobs using a single POST request.\n\nTo push a blob monolithically by using a single POST request, perform a `POST` request to a URL in the following form, and with the following headers and body:\n\n`/v2/<name>/blobs/uploads/?digest=<digest>` <sup>[end-4b](#endpoints)</sup>\n```\nContent-Length: <length>\nContent-Type: application/octet-stream\n```\n```\n<upload byte stream>\n```\n\nHere, `<name>` is the repository's namespace, `<digest>` is the blob's digest, and `<length>` is the size (in bytes) of the blob.\n\nThe `Content-Length` header MUST match the blob's actual content length. Likewise, the `<digest>` MUST match the blob's digest.\n\nRegistries that do not support single request monolithic uploads SHOULD return a `202 Accepted` status code and `Location` header and clients SHOULD proceed with a subsequent PUT request, as described by the [POST then PUT upload method](#post-then-put).\n\nSuccessful completion of the request MUST return a `201 Created` and MUST include the following header:\n\n```\nLocation: <blob-location>\n```\n\nHere, `<blob-location>` is a pullable blob URL. This location does not necessarily have to be served by your register, for example, in the case of a signed URL from\nsome cloud storage provider that your registry generates.\n\n\n##### Pushing a blob in chunks\n\nA chunked blob upload is accomplished in three phases:\n1. Obtain a session ID (upload URL) (`POST`)\n2. Upload the chunks (`PATCH`)\n3. Close the session (`PUT`)\n\nFor information on obtaining a session ID, reference the above section on pushing a blob monolithically via the `POST`/`PUT` method. The process remains unchanged for chunked upload, except that the post request MUST include the following header:\n\n```\nContent-Length: 0\n```\n\nPlease reference the above section for restrictions on the `<location>`.\n\n---\nTo upload a chunk, issue a `PATCH` request to a URL path in the following format, and with the following headers and body:\n\nURL path: `<location>` <sup>[end-5](#endpoints)</sup>\n```\nContent-Type: application/octet-stream\nContent-Range: <range>\nContent-Length: <length>\n```\n```\n<upload byte stream of chunk>\n```\n\nThe `<location>` refers to the URL obtained from the preceding `POST` request.\n\nThe `<range>` refers to the byte range of the chunk, and MUST be inclusive on both ends. The first chunk's range MUST begin with `0`. It MUST match the following regular expression:\n\n```regexp\n^[0-9]+-[0-9]+$\n```\n\nThe `<length>` is the content-length, in bytes, of the current chunk.\n\nEach successful chunk upload MUST have a `202 Accepted` response code, and MUST have the following header:\n\n```\nLocation <location>\n```\n\nEach consecutive chunk upload SHOULD use the `<location>` provided in the response to the previous chunk upload.\n\nChunks MUST be uploaded in order, with the first byte of a chunk being the last chunk's `<end-of-range>` plus one. If a chunk is uploaded out of order, the registry MUST respond with a `416 Requested Range Not Satisfiable` code.\n\nThe final chunk MAY be uploaded using a `PATCH` request or it MAY be uploaded in the closing `PUT` request. Regardless of how the final chunk is uploaded, the session MUST be closed with a `PUT` request.\n\n---\n\nTo close the session, issue a `PUT` request to a url in the following format, and with the following headers (and optional body, depending on whether or not the final chunk was uploaded already via a `PATCH` request):\n\n`<location>?digest=<digest>`\n```\nContent-Length: <length of chunk, if present>\nContent-Range: <range of chunk, if present>\nContent-Type: application/octet-stream <if chunk provided>\n```\n```\nOPTIONAL: <final chunk byte stream>\n```\n\nThe closing `PUT` request MUST include the `<digest>` of the whole blob (not the final chunk) as a query parameter.\n\nThe response to a successful closing of the session MUST be `201 Created`, and MUST contain the following header:\n```\nLocation: <blob-location>\n```\n\nHere, `<blob-location>` is a pullable blob URL.\n\n\n##### Mounting a blob from another repository\n\nIf a necessary blob exists already in another repository, it can be mounted into a different repository via a `POST`\nrequest in the following format:\n\n`/v2/<name>/blobs/uploads/?mount=<digest>&from=<other_name>`  <sup>[end-11](#endpoints)</sup>.\n\nIn this case, `<name>` is the namespace to which the blob will be mounted. `<digest>` is the digest of the blob to mount,\nand `<other_name>` is the namespace from which the blob should be mounted. This step is usually taken in place of the\npreviously-described `POST` request to `/v2/<name>/blobs/uploads/` <sup>[end-4a](#endpoints)</sup> (which is used to initiate an\nupload session).\n\nThe response to a successful mount MUST be `201 Created`, and MUST contain the following header:\n```\nLocation: <blob-location>\n```\n\nThe Location header will contain the registry URL to access the accepted layer file. The Docker-Content-Digest\nheader returns the canonical digest of the uploaded blob which MAY differ from the provided digest. Most clients MAY\nignore the value but if it is used, the client SHOULD verify the value against the uploaded blob data.\n\nAlternatively, if a registry does not support cross-repository mounting or is unable to mount the requested blob,\nit SHOULD return a `202`. This indicates that the upload session has begun and that the client MAY proceed with the upload.\n\n##### Pushing Manifests\n\nTo push a manifest, perform a `PUT` request to a path in the following format, and with the following headers\nand body:\n`/v2/<name>/manifests/<reference>` <sup>[end-7](#endpoints)</sup>\n\nClients SHOULD set the `Content-Type` header to the type of the manifest being pushed.\nAll manifests SHOULD include a `mediaType` field declaring the type of the manifest being pushed.\nIf a manifest includes a `mediaType` field, clients MUST set the `Content-Type` header to the value specified by the `mediaType` field.\n\n```\nContent-Type: application/vnd.oci.image.manifest.v1+json\n```\nManifest byte stream:\n```\n{\n  \"mediaType\": \"application/vnd.oci.image.manifest.v1+json\",\n  ...\n}\n```\n\n`<name>` is the namespace of the repository, and the `<reference>` MUST be either a) a digest or b) a tag.\n\nThe uploaded manifest MUST reference any blobs that make up the artifact. However, the list of blobs MAY\nbe empty. Upon a successful upload, the registry MUST return response code `201 Created`, and MUST have the\nfollowing header:\n\n```\nLocation: <location>\n```\n\nThe `<location>` is a pullable manifest URL.\n\nAn attempt to pull a nonexistent repository MUST return response code `404 Not Found`\n\n#### Content Discovery\n\nCurrently, the only functionality provided by this workflow is the ability to discover tags.\n\nTo fetch the list of tags, perform a `GET` request to a path in the following format:\n`/v2/<name>/tags/list` <sup>[end-8a](#endpoints)</sup>\n\n`<name>` is the namespace of the repository. Assuming a repository is found, this request MUST return a\n`200 OK` response code. The list of tags MAY be empty if there are no tags on the repository. If the list is not empty,\nthe tags MUST be in lexical order (i.e. case-insensitive alphanumeric order).\n\nUpon success, the response MUST be a json body in the following format:\n```json\n{\n  \"name\": \"<name>\",\n  \"tags\": [\n    \"<tag1>\",\n    \"<tag2>\",\n    \"<tag3>\"\n  ]\n}\n```\n\n`<name>` is the namespace of the repository, and `<tag1>`, `<tag2>`, and `<tag3>` are each tags on the repository.\n\nIn addition to fetching the whole list of tags, a subset of the tags can be fetched by providing the `n` query parameter.\nIn this case, the path will look like the following:\n`/v2/<name>/tags/list?n=<int>` <sup>[end-8b](#endpoints)</sup>\n\n`<name>` is the namespace of the repository, and `<int>` is an integer specifying the number of tags requested. The response\nto such a request MAY return fewer than `<int>` results, but only when the total number of tags attached to the repository\nis less than `<int>`. Otherwise, the response MUST include `<int>` results. When `n` is zero, this endpoint MUST return\nan empty list, and MUST NOT include a `Link` header. Without the `last` query parameter (described next), the list returned will\nstart at the beginning of the list and include `<int>` results. As above, the tags MUST be in lexical order.\n\nThe `last` query parameter provides further means for limiting the number of tags. It is usually used in combination with the\n`n` parameter:\n`/v2/<name>/tags/list?n=<int>&last=<tagname>` <sup>[end-8b](#endpoints)</sup>\n\n`<name>` is the namespace of the repository, `<int>` is the number of tags requested, and `<tagname>` is the *value* of\nthe last tag. `<tagname>` MUST NOT be a numerical index, but rather it MUST be a proper tag. A request of this sort will return\nup to `<int>` tags, beginning non-inclusively with `<tagname>`. That is to say, `<tagname>` will not be included in the\nresults, but up to `<int>` tags *after* `<tagname>` will be returned. The tags MUST be in lexical order.\n\nWhen using the `last` query parameter, the `n` parameter is OPTIONAL.\n\n#### Content Management\n\nContent management refers to the deletion of blobs, tags, and manifests. Registries MAY implement deletion or they MAY\ndisable it. Similarly, a registry MAY implement tag deletion, while others MAY allow deletion only by manifest.\n\n##### Deleting tags\n\n`<name>` is the namespace of the repository, and `<tag>` is the name of the tag to be deleted. Upon success, the registry\nMUST respond with a `202 Accepted` code. If tag deletion is disabled, the registry MUST respond with either a\n`400 Bad Request` or a `405 Method Not Allowed`.\n\nTo delete a tag, perform a `DELETE` request to a path in the following format:\n`/v2/<name>/manifests/<tag>` <sup>[end-9](#endpoints)</sup>\n\n##### Deleting Manifests\n\nTo delete a manifest, perform a `DELETE` request to a path in the following format:\n`/v2/<name>/manifests/<digest>` <sup>[end-9](#endpoints)</sup>\n\n`<name>` is the namespace of the repository, and `<digest>` is the digest of the manifest to be deleted. Upon success, the registry\nMUST respond with a `202 Accepted` code. If the repository does not exist, the response MUST return `404 Not Found`.\n\n##### Deleting Blobs\n\nTo delete a blob, perform a `DELETE` request to a path in the following format:\n`/v2/<name>/blobs/<digest>` <sup>[end-10](#endpoints)</sup>\n\n`<name>` is the namespace of the repository, and `<digest>` is the digest of the blob to be deleted. Upon success, the\nregistry MUST respond with code `202 Accepted`. If the blob is not found, a `404 Not Found` code MUST be returned.\n\n### API\n\nThe API operates over HTTP. Below is a summary of the endpoints used by the API.\n\n#### Determining Support\n\nTo check whether or not the registry implements this specification, perform a `GET` request to the following endpoint:\n`/v2/` <sup>[end-1](#endpoints)</sup>.\n\nIf the response is `200 OK`, then the registry implements this specification.\n\nThis endpoint MAY be used for authentication/authorization purposes, but this is out of the purview\nof this specification.\n\n#### Endpoints\n\n| ID     | Method         | API Endpoint                                                      | Success     | Failure           |\n| ------ | -------------- | ------------------------------------------------------------ | ----------- | ----------------- |\n| end-1  | `GET`          | `/v2/`                                                       | `200`       | `404`/`401`       |\n| end-2  | `GET` / `HEAD` | `/v2/<name>/blobs/<digest>`                                  | `200`       | `404`             |\n| end-3  | `GET` / `HEAD` | `/v2/<name>/manifests/<reference>`                           | `200`       | `404`             |\n| end-4a | `POST`         | `/v2/<name>/blobs/uploads/`                                  | `202`       | `404`             |\n| end-4b | `POST`         | `/v2/<name>/blobs/uploads/?digest=<digest>`                  | `201`/`202` | `404`/`400`       |\n| end-5  | `PATCH`        | `/v2/<name>/blobs/uploads/<reference>`                       | `202`       | `404`/`416`       |\n| end-6  | `PUT`          | `/v2/<name>/blobs/uploads/<reference>?digest=<digest>`       | `201`       | `404`/`400`       |\n| end-7  | `PUT`          | `/v2/<name>/manifests/<reference>`                           | `201`       | `404`             |\n| end-8a | `GET`          | `/v2/<name>/tags/list`                                       | `200`       | `404`             |\n| end-8b | `GET`          | `/v2/<name>/tags/list?n=<integer>&last=<integer>`            | `200`       | `404`             |\n| end-9  | `DELETE`       | `/v2/<name>/manifests/<reference>`                           | `202`       | `404`/`400`/`405` |\n| end-10 | `DELETE`       | `/v2/<name>/blobs/<digest>`                                  | `202`       | `404`/`405`       |\n| end-11 | `POST`         | `/v2/<name>/blobs/uploads/?mount=<digest>&from=<other_name>` | `201`       | `404`             |\n\n#### Error Codes\n\nA `4XX` response code from the registry MAY return a body in any format. If the response body is in JSON format, it MUST\nhave the following format:\n\n```json\n    {\n        \"errors\": [\n            {\n                \"code\": \"<error identifier, see below>\",\n                \"message\": \"<message describing condition>\",\n                \"detail\": \"<unstructured>\"\n            },\n            ...\n        ]\n    }\n```\n\nThe `code` field MUST be a unique identifier, containing only uppercase alphabetic characters and underscores. The\n`message` field is OPTIONAL, and if present, it SHOULD be a human readable string or MAY be empty. The `detail` field is\nOPTIONAL and MAY contain arbitrary JSON data providing information the client can use to resolve the issue.\n\nThe `code` field MUST be one of the following:\n\n| ID      | Code                    | Description                                    |\n|-------- | ------------------------|------------------------------------------------|\n| code-1  | `BLOB_UNKNOWN`          | blob unknown to registry                       |\n| code-2  | `BLOB_UPLOAD_INVALID`   | blob upload invalid                            |\n| code-3  | `BLOB_UPLOAD_UNKNOWN`   | blob upload unknown to registry                |\n| code-4  | `DIGEST_INVALID`        | provided digest did not match uploaded content |\n| code-5  | `MANIFEST_BLOB_UNKNOWN` | blob unknown to registry                       |\n| code-6  | `MANIFEST_INVALID`      | manifest invalid                               |\n| code-7  | `MANIFEST_UNKNOWN`      | manifest unknown                               |\n| code-8  | `NAME_INVALID`          | invalid repository name                        |\n| code-9  | `NAME_UNKNOWN`          | repository name not known to registry          |\n| code-10 | `SIZE_INVALID`          | provided length did not match content length   |\n| code-12 | `UNAUTHORIZED`          | authentication required                        |\n| code-13 | `DENIED`                | requested access to the resource is denied     |\n| code-14 | `UNSUPPORTED`           | the operation is unsupported                   |\n| code-15 | `TOOMANYREQUESTS`       | too many requests                              |\n\n### Appendix\n\nThe following is a list of documents referenced in this spec:\n\n| ID     | Title | Description |\n| ------ | ----- | ----------- |\n| apdx-1 | [Docker Registry HTTP API V2](https://github.com/docker/distribution/blob/5cb406d511b7b9163bff9b6439072e4892e5ae3b/docs/spec/api.md) | The original document upon which this spec was based |\n| apdx-1 | [Details](./detail.md) | Historical document describing original API endpoints and requests in detail |\n| apdx-2 | [OCI Image Spec - manifests](https://github.com/opencontainers/image-spec/blob/v1.0.1/manifest.md) | Description of manifests, defined by the OCI Image Spec |\n| apdx-3 | [OCI Image Spec - digests](https://github.com/opencontainers/image-spec/blob/v1.0.1/descriptor.md#digests) | Description of digests, defined by the OCI Image Spec |\n| apdx-4 | [OCI Image Spec - config](https://github.com/opencontainers/image-spec/blob/v1.0.1/config.md) | Description of configs, defined by the OCI Image Spec |\n"], "filenames": ["spec.md"], "buggy_code_start_loc": [145], "buggy_code_end_loc": [388], "fixing_code_start_loc": [145], "fixing_code_end_loc": [399], "type": "CWE-843", "message": "The OCI Distribution Spec project defines an API protocol to facilitate and standardize the distribution of content. In the OCI Distribution Specification version 1.0.0 and prior, the Content-Type header alone was used to determine the type of document during push and pull operations. Documents that contain both \u201cmanifests\u201d and \u201clayers\u201d fields could be interpreted as either a manifest or an index in the absence of an accompanying Content-Type header. If a Content-Type header changed between two pulls of the same digest, a client may interpret the resulting content differently. The OCI Distribution Specification has been updated to require that a mediaType value present in a manifest or index match the Content-Type header used during the push and pull operations. Clients pulling from a registry may distrust the Content-Type header and reject an ambiguous document that contains both \u201cmanifests\u201d and \u201clayers\u201d fields or \u201cmanifests\u201d and \u201cconfig\u201d fields if they are unable to update to version 1.0.1 of the spec.", "other": {"cve": {"id": "CVE-2021-41190", "sourceIdentifier": "security-advisories@github.com", "published": "2021-11-17T20:15:10.333", "lastModified": "2021-12-10T17:08:30.557", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The OCI Distribution Spec project defines an API protocol to facilitate and standardize the distribution of content. In the OCI Distribution Specification version 1.0.0 and prior, the Content-Type header alone was used to determine the type of document during push and pull operations. Documents that contain both \u201cmanifests\u201d and \u201clayers\u201d fields could be interpreted as either a manifest or an index in the absence of an accompanying Content-Type header. If a Content-Type header changed between two pulls of the same digest, a client may interpret the resulting content differently. The OCI Distribution Specification has been updated to require that a mediaType value present in a manifest or index match the Content-Type header used during the push and pull operations. Clients pulling from a registry may distrust the Content-Type header and reject an ambiguous document that contains both \u201cmanifests\u201d and \u201clayers\u201d fields or \u201cmanifests\u201d and \u201cconfig\u201d fields if they are unable to update to version 1.0.1 of the spec."}, {"lang": "es", "value": "El proyecto OCI Distribution Spec define un protocolo API para facilitar y estandarizar la distribuci\u00f3n de contenidos. En la versi\u00f3n 1.0.0 de OCI Distribution Specification y anteriores, se utilizaba \u00fanicamente la cabecera Content-Type para determinar el tipo de documento durante las operaciones push y pull. Los documentos que conten\u00edan campos \"manifiestos\" y \"capas\" pod\u00edan interpretarse como un manifiesto o un \u00edndice en ausencia de una cabecera Content-Type que los acompa\u00f1ara. Si una cabecera Content-Type cambiaba entre dos pulls del mismo compendio, un cliente podr\u00eda interpretar el contenido resultante de forma diferente. La especificaci\u00f3n de distribuci\u00f3n de la OCI se ha actualizado para exigir que el valor de mediaType presente en un manifiesto o \u00edndice coincida con la cabecera Content-Type utilizada durante las operaciones push y pull. Los clientes que extraen de un registro pueden desconfiar de la cabecera Content-Type y rechazar un documento ambiguo que contenga campos \"manifiestos\" y \"capas\" o campos \"manifiestos\" y \"config\" si no pueden actualizarse a la versi\u00f3n 1.0.1 de la especificaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.1, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.0, "baseSeverity": "LOW"}, "exploitabilityScore": 1.3, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-843"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-843"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:open_container_initiative_distribution_specification:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.0", "matchCriteriaId": "CEA62E19-78AE-4FD8-8888-B347544BB7A9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:open_container_initiative_image_format_specification:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.1", "matchCriteriaId": "1355CC51-5D8D-4C5A-AA67-93157ED1ADAE"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2021/11/19/10", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/opencontainers/distribution-spec/commit/ac28cac0557bcd3084714ab09f9f2356fe504923", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/opencontainers/distribution-spec/security/advisories/GHSA-mc8v-mgrf-8f4m", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3TUZNDAH2B26VPBK342UC3BHZNLBUXGX/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4334HT7AZPLWNYHW4ARU6JBUF3VZJPZN/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/A2RRFNTMFYKOTRKD37F5ANMCIO3GGJML/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DX63GRWFEI5RVMYV6XLMCG4OHPWZML27/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RZTO6N55WHKHIZI4IMLY2QFBPMVTAERM/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/SQBCYJUIM5GVCMFUPRWKRZNXMMI5EFA4/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/T4OJ764CKKCWCVONHD4YXTGR7HZ7LRUV/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YIGVQWOA5XXCQXEOOKZX4CDAGLBDRPRX/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/opencontainers/distribution-spec/commit/ac28cac0557bcd3084714ab09f9f2356fe504923"}}