{"buggy_code": ["Changelog\n=========\n\nFor changes before version 3.0, see ``HISTORY.rst``.\n\n6.2 (unreleased)\n----------------\n\n\n6.1 (2023-05-22)\n----------------\n- Update C header files for ``ExtensionClass`` and ``Acquisition``\n  from the original packages where needed.\n  (`#140 <https://github.com/zopefoundation/AccessControl/issues/140>`_)\n\n- Add preliminary support for Python 3.12a5.\n\n\n6.0 (2023-01-12)\n----------------\n\n- Build Linux binary wheels for Python 3.11\n\n- Drop support for Python 2.7, 3.5, 3.6.\n\n\n5.7 (2022-11-17)\n----------------\n\n- Add support for building arm64 wheels on macOS.\n\n\n5.6 (2022-11-03)\n----------------\n\n- Add support for final Python 3.11 release.\n\n\n5.5 (2022-10-10)\n----------------\n\n- Switch from ``-Ofast`` to ``-O3`` when compiling code for Linux wheels.\n  (`#133 <https://github.com/zopefoundation/AccessControl/pull/133>`_)\n\n- Add support for Python 3.11 (as of 3.11.0rc2).\n\n\n5.4 (2022-08-26)\n----------------\n\n- Add support for Python 3.11 (as of 3.11.0b5).\n\n- Support ``default`` argument in ``next`` built-in function.\n  (`#131 <https://github.com/zopefoundation/AccessControl/pull/131>`_)\n\n\n5.3.1 (2022-03-29)\n------------------\n\n- Prevent race condition in guarded_import\n  (`#123 <https://github.com/zopefoundation/AccessControl/issues/123>`_)\n\n\n5.3 (2022-02-25)\n----------------\n\n- Provide ``AccessControl.get_safe_globals`` to facilitate safe use.\n\n- Honor ``PURE_PYTHON`` environment variable to enable python implementation\n  during runtime.\n\n- Add support for Python 3.10.\n\n\n5.2 (2021-07-30)\n----------------\n\n- Fix Appveyor configuration so tests can run and wheels build.\n\n\n5.1 (2021-07-30)\n----------------\nNOTE: This release has been yanked from PyPI due to wheel build issues.\n\n- Fix a remote code execution issue by preventing access to\n  ``string.Formatter`` from restricted code.\n\n\n5.0 (2020-10-07)\n----------------\n\n- Add support for Python 3.9.\n\n- Remove deprecated classes and functions in\n  (see `#32 <https://github.com/zopefoundation/AccessControl/issues/32>`_):\n\n  + ``AccessControl/DTML.py``\n  + ``AccessControl/Owned.py``\n  + ``AccessControl/Role.py``\n  + ``AccessControl/Permissions.py``\n\n- Add deprecation warnings for BBB imports in:\n\n  + ``AccessControl/AuthEncoding.py``\n  + ``AccessControl/Owned.py``\n  + ``AccessControl/Role.py``\n  + ``AccessControl/User.py``\n\n- Although this version might run on Zope 4, it is no longer supported because\n  of the dropped deprecation warnings.\n\n\n4.2 (2020-04-20)\n----------------\n\n- Add missing permission ``Manage WebDAV Locks``\n\n- Fix regression for BBB import of ```users.UnrestrictedUser``\n  (`#94 <https://github.com/zopefoundation/AccessControl/issues/94>`_)\n\n- Add a check if database is present in ``.owner.ownerInfo``.\n  (`#91 <https://github.com/zopefoundation/AccessControl/issues/91>`_).\n\n\n4.1 (2019-09-02)\n----------------\n\n- Python 3: Allow iteration over the result of ``dict.{keys,values,items}``\n  (`#89 <https://github.com/zopefoundation/AccessControl/issues/89>`_).\n\n\n4.0 (2019-05-08)\n----------------\n\nChanges since 3.0.12:\n\n- Add support for Python 3.5, 3.6, 3.7 and 3.8.\n\n- Restore simple access to bytes methods in Python 3\n  (`#83 <https://github.com/zopefoundation/AccessControl/issues/83>`_)\n\n- Clarify deprecation warnings for several BBB shims.\n  (`#32 <https://github.com/zopefoundation/AccessControl/issues/32>`_)\n\n- Add a test to prove that a user folder flag cannot be acquired elsewhere.\n  (`#7 <https://github.com/zopefoundation/AccessControl/issues/7>`_)\n\n- Tighten basic auth string handling in ``BasicUserFolder.identify``\n  (`#56 <https://github.com/zopefoundation/AccessControl/issues/56>`_)\n\n- Prevent the Zope 4 ZMI from showing an add dialog for the user folder.\n  (`#82 <https://github.com/zopefoundation/AccessControl/issues/82>`_)\n\n- Fix order of roles returned by\n  ``AccessControl.rolemanager.RoleManager.userdefined_roles``.\n\n- Add configuration for `zodbupdate`.\n\n- Add ``TaintedBytes`` besides ``TaintedString`` in ``AccessControl.tainted``.\n  (`#57 <https://github.com/zopefoundation/AccessControl/issues/57>`_)\n\n- Security fix: In ``str.format``, check the security for attributes that are\n  accessed. (Ported from 2.13).\n\n- Port ``override_container`` context manager here from 2.13.\n\n- Add AppVeyor configuration to automate building Windows eggs.\n\n- Fix for compilers that only support C89 syntax (e.g. on Windows).\n\n- Sanitize and test `RoleManager` role handling.\n\n- Depend on RestrictedPython >= 4.0.\n\n- #16: Fixed permission handling by avoiding column and row numbers as\n  identifiers for permissions and roles.\n\n- Extract ``.AuthEncoding`` to its own package for reuse.\n\n- Declare missing dependency on BTrees.\n\n- Drop `Record` dependency, which now does its own security declaration.\n\n- Remove leftovers from history support dropped in Zope.\n\n- Remove duplicate guard against * imports.\n  (`#60 <https://github.com/zopefoundation/AccessControl/issues/60>`_)\n\n\n3.0.12 (2015-12-21)\n-------------------\n\n- Avoid acquiring ``access`` from module wrapped by\n  ``SecurityInfo._ModuleSecurityInfo``.  See:\n  https://github.com/zopefoundation/AccessControl/issues/12\n\n3.0.11 (2014-11-02)\n-------------------\n\n- Harden test fix for machines that do not define `localhost`.\n\n3.0.10 (2014-11-02)\n-------------------\n\n- Test fix for machines that do not define `localhost`.\n\n3.0.9 (2014-08-08)\n------------------\n\n- GitHub #6: Do not pass SecurityInfo instance itself to declarePublic/declarePrivate\n  when using the public/private decorator. This fixes ``Conflicting security declarations``\n  warnings on Zope startup.\n\n- LP #1248529: Leave existing security manager in place inside\n  ``RoleManager.manage_getUserRolesAndPermissions``.\n\n3.0.8 (2013-07-16)\n------------------\n\n- LP #1169923:  ensure initialization of shared ``ImplPython`` state\n  (used by ``ImplC``) when using the \"C\" security policy.  Thanks to\n  Arnaud Fontaine for the patch.\n\n3.0.7 (2013-05-14)\n------------------\n\n- Remove long-deprecated 'Shared' roles support (pre-dates Zope, never\n  used by Zope itself)\n\n- Prevent infinite loop when looking up local roles in an acquisition chain\n  with cycles.\n\n3.0.6 (2012-10-31)\n------------------\n\n- LP #1071067: Use a stronger random number generator and a constant time\n  comparison function.\n\n3.0.5 (2012-10-21)\n------------------\n\n- LP #966101: Recognize special `zope2.Private` permission in ZCML\n  role directive.\n\n3.0.4 (2012-09-09)\n------------------\n\n- LP #1047318: Tighten import restrictions for restricted code.\n\n3.0.3 (2012-08-23)\n------------------\n\n- Fix a bug in ZopeSecurityPolicy.py. Global variable `rolesForPermissionOn`\n  could be overridden if `__role__` had custom rolesForPermissionOn.\n\n3.0.2 (2012-06-22)\n------------------\n\n- Add Anonymous as a default role for Public permission.\n\n3.0.1 (2012-05-24)\n------------------\n\n- Fix tests under Python 2.6.\n\n3.0 (2012-05-12)\n----------------\n\n- Added decorators for public, private and protected security declarations.\n\n- Update tests to take advantage of automatic test suite discovery.\n", "##############################################################################\n#\n# Copyright (c) 2002 Zope Foundation and Contributors.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE\n#\n##############################################################################\n\n# This has to happen early so things get initialized properly\nfrom AccessControl.Implementation import setImplementation\nfrom AccessControl.safe_formatter import safe_format\nfrom AccessControl.SecurityInfo import ACCESS_NONE\nfrom AccessControl.SecurityInfo import ACCESS_PRIVATE\nfrom AccessControl.SecurityInfo import ACCESS_PUBLIC\nfrom AccessControl.SecurityInfo import ClassSecurityInfo\nfrom AccessControl.SecurityInfo import ModuleSecurityInfo\nfrom AccessControl.SecurityInfo import allow_class\nfrom AccessControl.SecurityInfo import allow_module\nfrom AccessControl.SecurityInfo import secureModule\nfrom AccessControl.SecurityManagement import getSecurityManager\nfrom AccessControl.SecurityManagement import setSecurityPolicy\nfrom AccessControl.SimpleObjectPolicies import allow_type\nfrom AccessControl.unauthorized import Unauthorized\nfrom AccessControl.ZopeGuards import full_write_guard\nfrom AccessControl.ZopeGuards import get_safe_globals\nfrom AccessControl.ZopeGuards import safe_builtins\n\n\nModuleSecurityInfo('AccessControl').declarePublic('getSecurityManager')  # NOQA\n\n# allow imports of utility_builtins\n\nfor name in ('string', 'math', 'random', 'sets'):\n    ModuleSecurityInfo(name).setDefaultAccess('allow')\n\nModuleSecurityInfo('DateTime').declarePublic('DateTime')  # NOQA: D001\n\n# We want to allow all methods on string type except \"format\".\n# That one needs special handling to avoid access to attributes.\nrules = {m: True for m in dir(str) if not m.startswith('_')}\nrules['format'] = safe_format\nallow_type(str, rules)\n\nzodbupdate_decode_dict = {\n    'AccessControl.users User name': 'utf-8',\n    'AccessControl.users User __': 'utf-8',\n}\n", "import string\nfrom collections.abc import Mapping\n\nimport _string\n\nfrom AccessControl.ZopeGuards import guarded_getattr\nfrom AccessControl.ZopeGuards import guarded_getitem\n\n\ndef formatter_field_name_split(field_name):\n    return _string.formatter_field_name_split(field_name)\n\n\nclass _MagicFormatMapping(Mapping):\n    \"\"\"Pulled from Jinja2.\n\n    This class implements a dummy wrapper to fix a bug in the Python\n    standard library for string formatting.\n\n    See http://bugs.python.org/issue13598 for information about why\n    this is necessary.\n    \"\"\"\n\n    def __init__(self, args, kwargs):\n        self._args = args\n        self._kwargs = kwargs\n        self._last_index = 0\n\n    def __getitem__(self, key):\n        if key == '':\n            idx = self._last_index\n            self._last_index += 1\n            try:\n                return self._args[idx]\n            except LookupError:\n                pass\n            key = str(idx)\n        return self._kwargs[key]\n\n    def __iter__(self):\n        return iter(self._kwargs)\n\n    def __len__(self):\n        return len(self._kwargs)\n\n\nclass SafeFormatter(string.Formatter):\n    \"\"\"Formatter using guarded access.\"\"\"\n\n    def __init__(self, value):\n        self.value = value\n        super().__init__()\n\n    def get_field(self, field_name, args, kwargs):\n        \"\"\"Get the field value using guarded methods.\"\"\"\n        first, rest = formatter_field_name_split(field_name)\n\n        obj = self.get_value(first, args, kwargs)\n\n        # loop through the rest of the field_name, doing\n        #  getattr or getitem as needed\n        for is_attr, i in rest:\n            if is_attr:\n                obj = guarded_getattr(obj, i)\n            else:\n                obj = guarded_getitem(obj, i)\n\n        return obj, first\n\n    def safe_format(self, *args, **kwargs):\n        \"\"\"Safe variant of `format` method.\"\"\"\n        kwargs = _MagicFormatMapping(args, kwargs)\n        return self.vformat(self.value, args, kwargs)\n\n\ndef safe_format(inst, method):\n    \"\"\"Use our SafeFormatter that uses guarded_getattr for attribute access.\"\"\"\n    return SafeFormatter(inst).safe_format\n", "import unittest\n\nfrom persistent import Persistent\nfrom zExceptions import Unauthorized\n\n\nSliceType = type(slice(0))\n\n\nclass Item(Persistent):\n\n    def __init__(self, id, private=False):\n        self.id = id\n        if private:\n            self.__roles__ = ['Manager']\n        else:\n            self.__roles__ = ['Anonymous']\n\n    def __repr__(self):\n        return f'<Item {self.id}>'\n\n\nclass Folder(Persistent):\n\n    def __init__(self, id):\n        self.id = id\n        self.item_dict = {}\n        self.item_list = []\n\n    def addItem(self, name, private=False):\n        item = Item(name, private)\n        # add as attribute for testing attribute access:\n        setattr(self, name, item)\n        # add in dict for testing named item access:\n        self.item_dict[name] = item\n        # add in list for testing numeric item access:\n        self.item_list.append(item)\n\n    def __getitem__(self, key):\n        # key can be a slice.\n        if isinstance(key, SliceType):\n            return self.item_list[key]\n        # Is this numeric (integer) access or string access?\n        if isinstance(key, int):\n            return self.item_list[key]\n        return self.item_dict[key]\n\n\nclass FormatterTest(unittest.TestCase):\n    \"\"\"Test SafeFormatter and SafeStr.\n\n    There are some integration tests in Zope2 itself.\n    \"\"\"\n\n    def _create_folder_with_mixed_contents(self):\n        \"\"\"Create a folder with mixed public and private contents.\"\"\"\n        folder = Folder('folder')\n        folder.addItem('public1')\n        folder.addItem('private', private=True)\n        folder.addItem('public2')\n        return folder\n\n    def test_positional_argument_regression(self):\n        \"\"\"Testing fix of http://bugs.python.org/issue13598 issue.\"\"\"\n        from AccessControl.safe_formatter import SafeFormatter\n        self.assertEqual(\n            SafeFormatter('{} {}').safe_format('foo', 'bar'),  # NOQA: P103\n            'foo bar')\n        self.assertEqual(SafeFormatter('{0} {1}').safe_format('foo', 'bar'),\n                         'foo bar')\n        self.assertEqual(SafeFormatter('{1} {0}').safe_format('foo', 'bar'),\n                         'bar foo')\n\n    def test_prevents_bad_string_formatting_attribute(self):\n        from AccessControl.safe_formatter import SafeFormatter\n\n        # Accessing basic Python attributes on a basic Python type is fine.\n        formatted = SafeFormatter('{0.upper}').safe_format('foo')\n        self.assertTrue(formatted.startswith('<built-in method upper'))\n        # unless the name is protected\n        self.assertRaises(Unauthorized,\n                          SafeFormatter('{0.__class__}').safe_format, 'foo')\n        # But for non-basic items or non-basic lists, we want run checks.\n        folder = self._create_folder_with_mixed_contents()\n        # We can get the public items just fine:\n        self.assertEqual(SafeFormatter('{0.public1}').safe_format(folder),\n                         '<Item public1>')\n        self.assertEqual(SafeFormatter('{0.public2}').safe_format(folder),\n                         '<Item public2>')\n        # But not the private item:\n        self.assertRaises(Unauthorized,\n                          SafeFormatter('{0.private}').safe_format,\n                          folder)\n\n    def test_prevents_bad_unicode_formatting_attribute(self):\n        from AccessControl.safe_formatter import SafeFormatter\n\n        # Accessing basic Python attributes on a basic Python type is fine.\n        formatted = SafeFormatter('{0.upper}').safe_format('foo')\n        self.assertTrue(formatted.startswith('<built-in method upper'))\n        # unless the name is protected\n        self.assertRaises(Unauthorized,\n                          SafeFormatter('{0.__class__}').safe_format, 'foo')\n        # But for non-basic items or non-basic lists, we want run checks.\n        folder = self._create_folder_with_mixed_contents()\n        # We can get the public items just fine:\n        self.assertEqual(SafeFormatter('{0.public1}').safe_format(folder),\n                         '<Item public1>')\n        self.assertEqual(SafeFormatter('{0.public2}').safe_format(folder),\n                         '<Item public2>')\n        # But not the private item:\n        self.assertRaises(Unauthorized,\n                          SafeFormatter('{0.private}').safe_format,\n                          folder)\n\n    def test_prevents_bad_string_formatting_item(self):\n        from AccessControl.safe_formatter import SafeFormatter\n\n        # Accessing basic Python types in a basic Python dict is fine.\n        foo = {'bar': 'Can you see me?'}\n        self.assertEqual(SafeFormatter('{0[bar]}').safe_format(foo),\n                         'Can you see me?')\n        # But for non-basic items or non-basic lists, we want run checks.\n        folder = self._create_folder_with_mixed_contents()\n        # We can get the public items just fine:\n        self.assertEqual(SafeFormatter('{0[public1]}').safe_format(folder),\n                         '<Item public1>')\n        self.assertEqual(SafeFormatter('{0[public2]}').safe_format(folder),\n                         '<Item public2>')\n        # But not the private item:\n        self.assertRaises(Unauthorized,\n                          SafeFormatter('{0[private]}').safe_format,\n                          folder)\n\n    def test_prevents_bad_unicode_formatting_item(self):\n        from AccessControl.safe_formatter import SafeFormatter\n\n        # Accessing basic Python types in a basic Python dict is fine.\n        foo = {'bar': 'Can you see me?'}\n        self.assertEqual(SafeFormatter('{0[bar]}').safe_format(foo),\n                         'Can you see me?')\n        # But for non-basic items or non-basic lists, we want run checks.\n        folder = self._create_folder_with_mixed_contents()\n        # We can get the public items just fine:\n        self.assertEqual(SafeFormatter('{0[public1]}').safe_format(folder),\n                         '<Item public1>')\n        self.assertEqual(SafeFormatter('{0[public2]}').safe_format(folder),\n                         '<Item public2>')\n        # But not the private item:\n        self.assertRaises(Unauthorized,\n                          SafeFormatter('{0[private]}').safe_format,\n                          folder)\n\n    def test_prevents_bad_string_formatting_key(self):\n        from persistent.list import PersistentList\n\n        from AccessControl.safe_formatter import SafeFormatter\n        from AccessControl.ZopeGuards import guarded_getitem\n\n        # Accessing basic Python types in a basic Python list is fine.\n        foo = list(['bar'])\n        self.assertEqual(SafeFormatter('{0[0]}').safe_format(foo),\n                         'bar')\n        self.assertEqual(guarded_getitem(foo, 0), 'bar')\n        # For basic Python types in a non-basic list, we guard the access.\n        foo = PersistentList(foo)\n        self.assertRaises(Unauthorized, guarded_getitem, foo, 0)\n        self.assertRaises(Unauthorized,\n                          SafeFormatter('{0[0]}').safe_format, foo)\n        # though we could allow access if we want:\n        foo.__allow_access_to_unprotected_subobjects__ = 1\n        self.assertEqual(guarded_getitem(foo, 0), 'bar')\n        self.assertEqual(SafeFormatter('{0[0]}').safe_format(foo),\n                         'bar')\n        # For non-basic items we want run checks too.\n        folder = self._create_folder_with_mixed_contents()\n        # We can get the public items just fine:\n        self.assertEqual(SafeFormatter('{0[0]}').safe_format(folder),\n                         '<Item public1>')\n        self.assertEqual(SafeFormatter('{0[2]}').safe_format(folder),\n                         '<Item public2>')\n        # But not the private item:\n        self.assertRaises(Unauthorized,\n                          SafeFormatter('{0[1]}').safe_format,\n                          folder)\n\n    def test_prevents_bad_unicode_formatting_key(self):\n        from AccessControl.safe_formatter import SafeFormatter\n\n        # Accessing basic Python types in a basic Python list is fine.\n        foo = list(['bar'])\n        self.assertEqual(SafeFormatter('{0[0]}').safe_format(foo),\n                         'bar')\n        # But for non-basic items or non-basic lists, we want run checks.\n        folder = self._create_folder_with_mixed_contents()\n        # We can get the public items just fine:\n        self.assertEqual(SafeFormatter('{0[0]}').safe_format(folder),\n                         '<Item public1>')\n        self.assertEqual(SafeFormatter('{0[2]}').safe_format(folder),\n                         '<Item public2>')\n        # But not the private item:\n        self.assertRaises(Unauthorized,\n                          SafeFormatter('{0[1]}').safe_format,\n                          folder)\n"], "fixing_code": ["Changelog\n=========\n\nFor changes before version 3.0, see ``HISTORY.rst``.\n\n6.2 (unreleased)\n----------------\n\n- Fix information disclosure through ``str.format_map``.\n  (CVE-2023-41050)\n\n\n6.1 (2023-05-22)\n----------------\n- Update C header files for ``ExtensionClass`` and ``Acquisition``\n  from the original packages where needed.\n  (`#140 <https://github.com/zopefoundation/AccessControl/issues/140>`_)\n\n- Add preliminary support for Python 3.12a5.\n\n\n6.0 (2023-01-12)\n----------------\n\n- Build Linux binary wheels for Python 3.11\n\n- Drop support for Python 2.7, 3.5, 3.6.\n\n\n5.7 (2022-11-17)\n----------------\n\n- Add support for building arm64 wheels on macOS.\n\n\n5.6 (2022-11-03)\n----------------\n\n- Add support for final Python 3.11 release.\n\n\n5.5 (2022-10-10)\n----------------\n\n- Switch from ``-Ofast`` to ``-O3`` when compiling code for Linux wheels.\n  (`#133 <https://github.com/zopefoundation/AccessControl/pull/133>`_)\n\n- Add support for Python 3.11 (as of 3.11.0rc2).\n\n\n5.4 (2022-08-26)\n----------------\n\n- Add support for Python 3.11 (as of 3.11.0b5).\n\n- Support ``default`` argument in ``next`` built-in function.\n  (`#131 <https://github.com/zopefoundation/AccessControl/pull/131>`_)\n\n\n5.3.1 (2022-03-29)\n------------------\n\n- Prevent race condition in guarded_import\n  (`#123 <https://github.com/zopefoundation/AccessControl/issues/123>`_)\n\n\n5.3 (2022-02-25)\n----------------\n\n- Provide ``AccessControl.get_safe_globals`` to facilitate safe use.\n\n- Honor ``PURE_PYTHON`` environment variable to enable python implementation\n  during runtime.\n\n- Add support for Python 3.10.\n\n\n5.2 (2021-07-30)\n----------------\n\n- Fix Appveyor configuration so tests can run and wheels build.\n\n\n5.1 (2021-07-30)\n----------------\nNOTE: This release has been yanked from PyPI due to wheel build issues.\n\n- Fix a remote code execution issue by preventing access to\n  ``string.Formatter`` from restricted code.\n\n\n5.0 (2020-10-07)\n----------------\n\n- Add support for Python 3.9.\n\n- Remove deprecated classes and functions in\n  (see `#32 <https://github.com/zopefoundation/AccessControl/issues/32>`_):\n\n  + ``AccessControl/DTML.py``\n  + ``AccessControl/Owned.py``\n  + ``AccessControl/Role.py``\n  + ``AccessControl/Permissions.py``\n\n- Add deprecation warnings for BBB imports in:\n\n  + ``AccessControl/AuthEncoding.py``\n  + ``AccessControl/Owned.py``\n  + ``AccessControl/Role.py``\n  + ``AccessControl/User.py``\n\n- Although this version might run on Zope 4, it is no longer supported because\n  of the dropped deprecation warnings.\n\n\n4.2 (2020-04-20)\n----------------\n\n- Add missing permission ``Manage WebDAV Locks``\n\n- Fix regression for BBB import of ```users.UnrestrictedUser``\n  (`#94 <https://github.com/zopefoundation/AccessControl/issues/94>`_)\n\n- Add a check if database is present in ``.owner.ownerInfo``.\n  (`#91 <https://github.com/zopefoundation/AccessControl/issues/91>`_).\n\n\n4.1 (2019-09-02)\n----------------\n\n- Python 3: Allow iteration over the result of ``dict.{keys,values,items}``\n  (`#89 <https://github.com/zopefoundation/AccessControl/issues/89>`_).\n\n\n4.0 (2019-05-08)\n----------------\n\nChanges since 3.0.12:\n\n- Add support for Python 3.5, 3.6, 3.7 and 3.8.\n\n- Restore simple access to bytes methods in Python 3\n  (`#83 <https://github.com/zopefoundation/AccessControl/issues/83>`_)\n\n- Clarify deprecation warnings for several BBB shims.\n  (`#32 <https://github.com/zopefoundation/AccessControl/issues/32>`_)\n\n- Add a test to prove that a user folder flag cannot be acquired elsewhere.\n  (`#7 <https://github.com/zopefoundation/AccessControl/issues/7>`_)\n\n- Tighten basic auth string handling in ``BasicUserFolder.identify``\n  (`#56 <https://github.com/zopefoundation/AccessControl/issues/56>`_)\n\n- Prevent the Zope 4 ZMI from showing an add dialog for the user folder.\n  (`#82 <https://github.com/zopefoundation/AccessControl/issues/82>`_)\n\n- Fix order of roles returned by\n  ``AccessControl.rolemanager.RoleManager.userdefined_roles``.\n\n- Add configuration for `zodbupdate`.\n\n- Add ``TaintedBytes`` besides ``TaintedString`` in ``AccessControl.tainted``.\n  (`#57 <https://github.com/zopefoundation/AccessControl/issues/57>`_)\n\n- Security fix: In ``str.format``, check the security for attributes that are\n  accessed. (Ported from 2.13).\n\n- Port ``override_container`` context manager here from 2.13.\n\n- Add AppVeyor configuration to automate building Windows eggs.\n\n- Fix for compilers that only support C89 syntax (e.g. on Windows).\n\n- Sanitize and test `RoleManager` role handling.\n\n- Depend on RestrictedPython >= 4.0.\n\n- #16: Fixed permission handling by avoiding column and row numbers as\n  identifiers for permissions and roles.\n\n- Extract ``.AuthEncoding`` to its own package for reuse.\n\n- Declare missing dependency on BTrees.\n\n- Drop `Record` dependency, which now does its own security declaration.\n\n- Remove leftovers from history support dropped in Zope.\n\n- Remove duplicate guard against * imports.\n  (`#60 <https://github.com/zopefoundation/AccessControl/issues/60>`_)\n\n\n3.0.12 (2015-12-21)\n-------------------\n\n- Avoid acquiring ``access`` from module wrapped by\n  ``SecurityInfo._ModuleSecurityInfo``.  See:\n  https://github.com/zopefoundation/AccessControl/issues/12\n\n3.0.11 (2014-11-02)\n-------------------\n\n- Harden test fix for machines that do not define `localhost`.\n\n3.0.10 (2014-11-02)\n-------------------\n\n- Test fix for machines that do not define `localhost`.\n\n3.0.9 (2014-08-08)\n------------------\n\n- GitHub #6: Do not pass SecurityInfo instance itself to declarePublic/declarePrivate\n  when using the public/private decorator. This fixes ``Conflicting security declarations``\n  warnings on Zope startup.\n\n- LP #1248529: Leave existing security manager in place inside\n  ``RoleManager.manage_getUserRolesAndPermissions``.\n\n3.0.8 (2013-07-16)\n------------------\n\n- LP #1169923:  ensure initialization of shared ``ImplPython`` state\n  (used by ``ImplC``) when using the \"C\" security policy.  Thanks to\n  Arnaud Fontaine for the patch.\n\n3.0.7 (2013-05-14)\n------------------\n\n- Remove long-deprecated 'Shared' roles support (pre-dates Zope, never\n  used by Zope itself)\n\n- Prevent infinite loop when looking up local roles in an acquisition chain\n  with cycles.\n\n3.0.6 (2012-10-31)\n------------------\n\n- LP #1071067: Use a stronger random number generator and a constant time\n  comparison function.\n\n3.0.5 (2012-10-21)\n------------------\n\n- LP #966101: Recognize special `zope2.Private` permission in ZCML\n  role directive.\n\n3.0.4 (2012-09-09)\n------------------\n\n- LP #1047318: Tighten import restrictions for restricted code.\n\n3.0.3 (2012-08-23)\n------------------\n\n- Fix a bug in ZopeSecurityPolicy.py. Global variable `rolesForPermissionOn`\n  could be overridden if `__role__` had custom rolesForPermissionOn.\n\n3.0.2 (2012-06-22)\n------------------\n\n- Add Anonymous as a default role for Public permission.\n\n3.0.1 (2012-05-24)\n------------------\n\n- Fix tests under Python 2.6.\n\n3.0 (2012-05-12)\n----------------\n\n- Added decorators for public, private and protected security declarations.\n\n- Update tests to take advantage of automatic test suite discovery.\n", "##############################################################################\n#\n# Copyright (c) 2002 Zope Foundation and Contributors.\n#\n# This software is subject to the provisions of the Zope Public License,\n# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.\n# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED\n# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS\n# FOR A PARTICULAR PURPOSE\n#\n##############################################################################\n\n# This has to happen early so things get initialized properly\nfrom AccessControl.Implementation import setImplementation\nfrom AccessControl.safe_formatter import safe_format\nfrom AccessControl.safe_formatter import safe_format_map\nfrom AccessControl.SecurityInfo import ACCESS_NONE\nfrom AccessControl.SecurityInfo import ACCESS_PRIVATE\nfrom AccessControl.SecurityInfo import ACCESS_PUBLIC\nfrom AccessControl.SecurityInfo import ClassSecurityInfo\nfrom AccessControl.SecurityInfo import ModuleSecurityInfo\nfrom AccessControl.SecurityInfo import allow_class\nfrom AccessControl.SecurityInfo import allow_module\nfrom AccessControl.SecurityInfo import secureModule\nfrom AccessControl.SecurityManagement import getSecurityManager\nfrom AccessControl.SecurityManagement import setSecurityPolicy\nfrom AccessControl.SimpleObjectPolicies import allow_type\nfrom AccessControl.unauthorized import Unauthorized\nfrom AccessControl.ZopeGuards import full_write_guard\nfrom AccessControl.ZopeGuards import get_safe_globals\nfrom AccessControl.ZopeGuards import safe_builtins\n\n\nModuleSecurityInfo('AccessControl').declarePublic('getSecurityManager')  # NOQA\n\n# allow imports of utility_builtins\n\nfor name in ('string', 'math', 'random', 'sets'):\n    ModuleSecurityInfo(name).setDefaultAccess('allow')\n\nModuleSecurityInfo('DateTime').declarePublic('DateTime')  # NOQA: D001\n\n# We want to allow all methods on string type except \"format\".\n# That one needs special handling to avoid access to attributes.\nrules = {m: True for m in dir(str) if not m.startswith('_')}\nrules['format'] = safe_format\nrules['format_map'] = safe_format_map\nallow_type(str, rules)\n\nzodbupdate_decode_dict = {\n    'AccessControl.users User name': 'utf-8',\n    'AccessControl.users User __': 'utf-8',\n}\n", "import string\nfrom collections.abc import Mapping\n\nimport _string\n\nfrom AccessControl.ZopeGuards import guarded_getattr\nfrom AccessControl.ZopeGuards import guarded_getitem\n\n\ndef formatter_field_name_split(field_name):\n    return _string.formatter_field_name_split(field_name)\n\n\nclass _MagicFormatMapping(Mapping):\n    \"\"\"Pulled from Jinja2.\n\n    This class implements a dummy wrapper to fix a bug in the Python\n    standard library for string formatting.\n\n    See http://bugs.python.org/issue13598 for information about why\n    this is necessary.\n    \"\"\"\n\n    def __init__(self, args, kwargs):\n        self._args = args\n        self._kwargs = kwargs\n        self._last_index = 0\n\n    def __getitem__(self, key):\n        if key == '':\n            idx = self._last_index\n            self._last_index += 1\n            try:\n                return self._args[idx]\n            except LookupError:\n                pass\n            key = str(idx)\n        return self._kwargs[key]\n\n    def __iter__(self):\n        return iter(self._kwargs)\n\n    def __len__(self):\n        return len(self._kwargs)\n\n\nclass SafeFormatter(string.Formatter):\n    \"\"\"Formatter using guarded access.\"\"\"\n\n    def __init__(self, value):\n        self.value = value\n        super().__init__()\n\n    def get_field(self, field_name, args, kwargs):\n        \"\"\"Get the field value using guarded methods.\"\"\"\n        first, rest = formatter_field_name_split(field_name)\n\n        obj = self.get_value(first, args, kwargs)\n\n        # loop through the rest of the field_name, doing\n        #  getattr or getitem as needed\n        for is_attr, i in rest:\n            if is_attr:\n                obj = guarded_getattr(obj, i)\n            else:\n                obj = guarded_getitem(obj, i)\n\n        return obj, first\n\n    def safe_format(self, *args, **kwargs):\n        \"\"\"Safe variant of `format` method.\"\"\"\n        kwargs = _MagicFormatMapping(args, kwargs)\n        return self.vformat(self.value, args, kwargs)\n\n    def safe_format_map(self, kw):\n        kwargs = _MagicFormatMapping((), kw)\n        return self.vformat(self.value, (), kwargs)\n\n\ndef safe_format(inst, method):\n    \"\"\"Use our SafeFormatter that uses guarded_getattr for attribute access.\"\"\"\n    return SafeFormatter(inst).safe_format\n\n\ndef safe_format_map(inst, method):\n    return SafeFormatter(inst).safe_format_map\n", "import unittest\n\nfrom persistent import Persistent\nfrom zExceptions import Unauthorized\n\n\nSliceType = type(slice(0))\n\n\nclass Item(Persistent):\n\n    def __init__(self, id, private=False):\n        self.id = id\n        if private:\n            self.__roles__ = ['Manager']\n        else:\n            self.__roles__ = ['Anonymous']\n\n    def __repr__(self):\n        return f'<Item {self.id}>'\n\n\nclass Folder(Persistent):\n\n    def __init__(self, id):\n        self.id = id\n        self.item_dict = {}\n        self.item_list = []\n\n    def addItem(self, name, private=False):\n        item = Item(name, private)\n        # add as attribute for testing attribute access:\n        setattr(self, name, item)\n        # add in dict for testing named item access:\n        self.item_dict[name] = item\n        # add in list for testing numeric item access:\n        self.item_list.append(item)\n\n    def __getitem__(self, key):\n        # key can be a slice.\n        if isinstance(key, SliceType):\n            return self.item_list[key]\n        # Is this numeric (integer) access or string access?\n        if isinstance(key, int):\n            return self.item_list[key]\n        return self.item_dict[key]\n\n\nclass FormatterTest(unittest.TestCase):\n    \"\"\"Test SafeFormatter and SafeStr.\n\n    There are some integration tests in Zope2 itself.\n    \"\"\"\n\n    def _create_folder_with_mixed_contents(self):\n        \"\"\"Create a folder with mixed public and private contents.\"\"\"\n        folder = Folder('folder')\n        folder.addItem('public1')\n        folder.addItem('private', private=True)\n        folder.addItem('public2')\n        return folder\n\n    def test_positional_argument_regression(self):\n        \"\"\"Testing fix of http://bugs.python.org/issue13598 issue.\"\"\"\n        from AccessControl.safe_formatter import SafeFormatter\n        self.assertEqual(\n            SafeFormatter('{} {}').safe_format('foo', 'bar'),  # NOQA: P103\n            'foo bar')\n        self.assertEqual(SafeFormatter('{0} {1}').safe_format('foo', 'bar'),\n                         'foo bar')\n        self.assertEqual(SafeFormatter('{1} {0}').safe_format('foo', 'bar'),\n                         'bar foo')\n\n    def test_prevents_bad_string_formatting_attribute(self):\n        from AccessControl.safe_formatter import SafeFormatter\n\n        # Accessing basic Python attributes on a basic Python type is fine.\n        formatted = SafeFormatter('{0.upper}').safe_format('foo')\n        self.assertTrue(formatted.startswith('<built-in method upper'))\n        # unless the name is protected\n        self.assertRaises(Unauthorized,\n                          SafeFormatter('{0.__class__}').safe_format, 'foo')\n        # But for non-basic items or non-basic lists, we want run checks.\n        folder = self._create_folder_with_mixed_contents()\n        # We can get the public items just fine:\n        self.assertEqual(SafeFormatter('{0.public1}').safe_format(folder),\n                         '<Item public1>')\n        self.assertEqual(SafeFormatter('{0.public2}').safe_format(folder),\n                         '<Item public2>')\n        # But not the private item:\n        self.assertRaises(Unauthorized,\n                          SafeFormatter('{0.private}').safe_format,\n                          folder)\n\n    def test_prevents_bad_unicode_formatting_attribute(self):\n        from AccessControl.safe_formatter import SafeFormatter\n\n        # Accessing basic Python attributes on a basic Python type is fine.\n        formatted = SafeFormatter('{0.upper}').safe_format('foo')\n        self.assertTrue(formatted.startswith('<built-in method upper'))\n        # unless the name is protected\n        self.assertRaises(Unauthorized,\n                          SafeFormatter('{0.__class__}').safe_format, 'foo')\n        # But for non-basic items or non-basic lists, we want run checks.\n        folder = self._create_folder_with_mixed_contents()\n        # We can get the public items just fine:\n        self.assertEqual(SafeFormatter('{0.public1}').safe_format(folder),\n                         '<Item public1>')\n        self.assertEqual(SafeFormatter('{0.public2}').safe_format(folder),\n                         '<Item public2>')\n        # But not the private item:\n        self.assertRaises(Unauthorized,\n                          SafeFormatter('{0.private}').safe_format,\n                          folder)\n\n    def test_prevents_bad_string_formatting_item(self):\n        from AccessControl.safe_formatter import SafeFormatter\n\n        # Accessing basic Python types in a basic Python dict is fine.\n        foo = {'bar': 'Can you see me?'}\n        self.assertEqual(SafeFormatter('{0[bar]}').safe_format(foo),\n                         'Can you see me?')\n        # But for non-basic items or non-basic lists, we want run checks.\n        folder = self._create_folder_with_mixed_contents()\n        # We can get the public items just fine:\n        self.assertEqual(SafeFormatter('{0[public1]}').safe_format(folder),\n                         '<Item public1>')\n        self.assertEqual(SafeFormatter('{0[public2]}').safe_format(folder),\n                         '<Item public2>')\n        # But not the private item:\n        self.assertRaises(Unauthorized,\n                          SafeFormatter('{0[private]}').safe_format,\n                          folder)\n\n    def test_prevents_bad_unicode_formatting_item(self):\n        from AccessControl.safe_formatter import SafeFormatter\n\n        # Accessing basic Python types in a basic Python dict is fine.\n        foo = {'bar': 'Can you see me?'}\n        self.assertEqual(SafeFormatter('{0[bar]}').safe_format(foo),\n                         'Can you see me?')\n        # But for non-basic items or non-basic lists, we want run checks.\n        folder = self._create_folder_with_mixed_contents()\n        # We can get the public items just fine:\n        self.assertEqual(SafeFormatter('{0[public1]}').safe_format(folder),\n                         '<Item public1>')\n        self.assertEqual(SafeFormatter('{0[public2]}').safe_format(folder),\n                         '<Item public2>')\n        # But not the private item:\n        self.assertRaises(Unauthorized,\n                          SafeFormatter('{0[private]}').safe_format,\n                          folder)\n\n    def test_prevents_bad_string_formatting_key(self):\n        from persistent.list import PersistentList\n\n        from AccessControl.safe_formatter import SafeFormatter\n        from AccessControl.ZopeGuards import guarded_getitem\n\n        # Accessing basic Python types in a basic Python list is fine.\n        foo = list(['bar'])\n        self.assertEqual(SafeFormatter('{0[0]}').safe_format(foo),\n                         'bar')\n        self.assertEqual(guarded_getitem(foo, 0), 'bar')\n        # For basic Python types in a non-basic list, we guard the access.\n        foo = PersistentList(foo)\n        self.assertRaises(Unauthorized, guarded_getitem, foo, 0)\n        self.assertRaises(Unauthorized,\n                          SafeFormatter('{0[0]}').safe_format, foo)\n        # though we could allow access if we want:\n        foo.__allow_access_to_unprotected_subobjects__ = 1\n        self.assertEqual(guarded_getitem(foo, 0), 'bar')\n        self.assertEqual(SafeFormatter('{0[0]}').safe_format(foo),\n                         'bar')\n        # For non-basic items we want run checks too.\n        folder = self._create_folder_with_mixed_contents()\n        # We can get the public items just fine:\n        self.assertEqual(SafeFormatter('{0[0]}').safe_format(folder),\n                         '<Item public1>')\n        self.assertEqual(SafeFormatter('{0[2]}').safe_format(folder),\n                         '<Item public2>')\n        # But not the private item:\n        self.assertRaises(Unauthorized,\n                          SafeFormatter('{0[1]}').safe_format,\n                          folder)\n\n    def test_prevents_bad_unicode_formatting_key(self):\n        from AccessControl.safe_formatter import SafeFormatter\n\n        # Accessing basic Python types in a basic Python list is fine.\n        foo = list(['bar'])\n        self.assertEqual(SafeFormatter('{0[0]}').safe_format(foo),\n                         'bar')\n        # But for non-basic items or non-basic lists, we want run checks.\n        folder = self._create_folder_with_mixed_contents()\n        # We can get the public items just fine:\n        self.assertEqual(SafeFormatter('{0[0]}').safe_format(folder),\n                         '<Item public1>')\n        self.assertEqual(SafeFormatter('{0[2]}').safe_format(folder),\n                         '<Item public2>')\n        # But not the private item:\n        self.assertRaises(Unauthorized,\n                          SafeFormatter('{0[1]}').safe_format,\n                          folder)\n\n    def test_format_map(self):\n        from AccessControl.safe_formatter import SafeFormatter\n\n        # Accessing basic Python types in a basic Python list is fine.\n        foo = list(['bar'])\n        self.assertEqual(SafeFormatter('{foo[0]}')\n                         .safe_format_map(dict(foo=foo)),\n                         'bar')\n        # But for non-basic items or non-basic lists, we want run checks.\n        folder = self._create_folder_with_mixed_contents()\n        # We can get the public items just fine:\n        self.assertEqual(SafeFormatter('{foo[0]}')\n                         .safe_format_map(dict(foo=folder)),\n                         '<Item public1>')\n        self.assertEqual(SafeFormatter('{foo[2]}')\n                         .safe_format_map(dict(foo=folder)),\n                         '<Item public2>')\n        # But not the private item:\n        self.assertRaises(Unauthorized,\n                          SafeFormatter('{foo[1]}').safe_format_map,\n                          dict(foo=folder))\n"], "filenames": ["CHANGES.rst", "src/AccessControl/__init__.py", "src/AccessControl/safe_formatter.py", "src/AccessControl/tests/test_safe_formatter.py"], "buggy_code_start_loc": [7, 16, 74, 204], "buggy_code_end_loc": [7, 46, 78, 204], "fixing_code_start_loc": [8, 17, 75, 205], "fixing_code_end_loc": [11, 49, 87, 227], "type": "CWE-200", "message": "AccessControl provides a general security framework for use in Zope. Python's \"format\" functionality allows someone controlling the format string to \"read\" objects accessible (recursively) via attribute access and subscription from accessible objects. Those attribute accesses and subscriptions use Python's full blown `getattr` and `getitem`, not the policy restricted `AccessControl` variants `_getattr_` and `_getitem_`. This can lead to critical information disclosure. `AccessControl` already provides a safe variant for `str.format` and denies access to `string.Formatter`. However, `str.format_map` is still unsafe. Affected are all users who allow untrusted users to create `AccessControl` controlled Python code and execute it. A fix has been introduced in versions 4.4, 5.8 and 6.2. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-41050", "sourceIdentifier": "security-advisories@github.com", "published": "2023-09-06T18:15:08.847", "lastModified": "2023-09-13T02:47:08.580", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "AccessControl provides a general security framework for use in Zope. Python's \"format\" functionality allows someone controlling the format string to \"read\" objects accessible (recursively) via attribute access and subscription from accessible objects. Those attribute accesses and subscriptions use Python's full blown `getattr` and `getitem`, not the policy restricted `AccessControl` variants `_getattr_` and `_getitem_`. This can lead to critical information disclosure. `AccessControl` already provides a safe variant for `str.format` and denies access to `string.Formatter`. However, `str.format_map` is still unsafe. Affected are all users who allow untrusted users to create `AccessControl` controlled Python code and execute it. A fix has been introduced in versions 4.4, 5.8 and 6.2. Users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "AccessControl proporciona un marco de seguridad general para su uso en Zope. La funcionalidad \"format\" de Python permite que alguien que controle la cadena de formato \"lea\" objetos accesibles (recursivamente) mediante acceso a atributos y suscripci\u00f3n desde objetos accesibles. Esos accesos a atributos y suscripciones utilizan las variantes `getattr` y `getitem` completas de Python, no las variantes `_getattr_` y `_getitem_` restringidas por pol\u00edticas de `AccessControl`. Esto puede conducir a la divulgaci\u00f3n de informaci\u00f3n cr\u00edtica. `AccessControl` ya proporciona una variante segura para `str.format` y niega el acceso a `string.Formatter`. Sin embargo, `str.format_map` todav\u00eda no es seguro. Los afectados son todos los usuarios que permiten a usuarios no confiables crear c\u00f3digo Python controlado por `AccessControl` y ejecutarlo. Se ha introducido una soluci\u00f3n en las versiones 4.4, 5.8 y 6.2. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 4.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zope:accesscontrol:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.4", "matchCriteriaId": "80528419-1860-4426-8384-A9DC16FF770F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zope:accesscontrol:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0", "versionEndExcluding": "5.8", "matchCriteriaId": "3E2BAF08-A726-4A9F-909D-733829F76FA2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zope:accesscontrol:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0", "versionEndExcluding": "6.2", "matchCriteriaId": "B49795D9-E2CD-4F45-A486-3B8D199BE3CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zope:zope:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.8.9", "matchCriteriaId": "9EABFCB8-F6C1-4425-B7D4-3241531B0FC6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zope:zope:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0", "versionEndExcluding": "5.8.4", "matchCriteriaId": "373E139B-C96D-4CDA-8961-284CCE134B0D"}]}]}], "references": [{"url": "https://github.com/zopefoundation/AccessControl/commit/6bc32692e0d4b8d5cf64eae3d19de987c7375bc9", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/zopefoundation/AccessControl/security/advisories/GHSA-8xv7-89vj-q48c", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/zopefoundation/AccessControl/commit/6bc32692e0d4b8d5cf64eae3d19de987c7375bc9"}}