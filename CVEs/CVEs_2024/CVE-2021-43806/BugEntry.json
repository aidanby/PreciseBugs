{"buggy_code": ["<?php\n/**\n * Copyright (c) Enalean, 2013 - Present. All Rights Reserved.\n * Copyright 1999-2000 (c) The SourceForge Crew\n * SourceForge: Breaking Down the Barriers to Open Source Development\n *\n * This file is a part of Tuleap.\n *\n * Tuleap is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Tuleap is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Tuleap. If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n\n    Commits Manager\n    By Thierry Jacquin, Nov 2003\n\n*/\n\nfunction uniformat_date($format, $date)\n{\n    if (preg_match(\"/([0-9]{4})-?([0-9]{2})-?([0-9]{2}) ?([0-9]{2}):?([0-9]{2}):?([0-9]{2})/\", $date, $gp)) {\n        [, $y, $m, $d, $h, $min, $s] = $gp;\n        $time                        = mktime($h, $min, $s, $m, $d, $y);\n        $date                        = date($format, $time);\n    }\n    return $date;\n}\n\nfunction commits_footer($params)\n{\n    site_project_footer($params);\n}\n\nfunction commits_branches_box($group_id, $name = 'branch', $checked = 'xzxz', $text_100 = 'None')\n{\n    if (! $group_id) {\n        return _('ERROR - no group_id');\n    } else {\n        $sql = \"SELECT unix_group_name from `groups` where group_id=\" . db_ei($group_id);\n\n        $result         = db_query($sql);\n        $projectname    = db_result($result, 0, 'unix_group_name');\n        $cvs_repository = db_es('/cvsroot/' . $projectname);\n     /*\n      List of possible commits_categories set up for the project\n     */\n        $sql    = \"select distinct cvs_branches.* FROM cvs_branches, cvs_checkins, cvs_repositories  where \" .\n        \"cvs_checkins.repositoryid=cvs_repositories.id AND cvs_repositories.repository='$cvs_repository' \" .\n        \"AND cvs_checkins.branchid=cvs_branches.id\";\n        $result = db_query($sql);\n\n        return html_build_select_box($result, $name, $checked, true, $text_100);\n    }\n}\n\nfunction commits_data_get_technicians($projectname)\n{\n    // Get list of all people who once committed something in the CVS\n    // including those who may have been removed from the project since then.\n    $cvs_repository = db_es('%/' . $projectname);\n    $sql            = \"SELECT DISTINCT user.user_name, user.user_name \" .\n        \"FROM cvs_checkins, cvs_repositories, user \" .\n        \"WHERE (cvs_repositories.repository like '$cvs_repository') AND (cvs_repositories.id = cvs_checkins.repositoryid) AND (cvs_checkins.whoid=user.user_id) \" .\n        \"ORDER BY user.user_name ASC\";\n    return db_query($sql);\n}\n\nfunction commits_technician_box($projectname, $name = '_commiter', $checked = 'xzxz', $text_100 = 'None')\n{\n    if (! $projectname) {\n        return _('ERROR - no group_id');\n    } else {\n        $result = commits_data_get_technicians($projectname);\n        if (! in_array($checked, util_result_column_to_array($result))) {\n            // Selected 'my commits' but never commited\n            $checked = 'xzxz';\n        }\n        return html_build_select_box($result, $name, $checked, true, $text_100);\n    }\n}\n\nfunction commits_tags_box($group_id, $name = '_tag', $checked = 'xzxz', $text_100 = 'None')\n{\n    $sql = \"SELECT unix_group_name from `groups` where group_id=\" . db_ei($group_id);\n\n    $result      = db_query($sql);\n    $projectname = db_result($result, 0, 'unix_group_name');\n\n    $cvs_repository = db_es('/cvsroot/' . $projectname);\n    $sql            = \"select distinct stickytag, stickytag from cvs_checkins, cvs_repositories where cvs_checkins.repositoryid=cvs_repositories.id AND cvs_repositories.repository='$cvs_repository'\";\n    $result         = db_query($sql);\n    return html_build_select_box($result, $name, $checked, true, $text_100);\n}\n\nfunction show_commitslist(\n    $group_id,\n    $result,\n    $offset,\n    $total_rows,\n    $set = 'any',\n    $commiter = '100',\n    $tag = '100',\n    $branch = '100',\n    $srch = '',\n    $chunksz = 15,\n    $morder = '',\n    $msort = 0,\n) {\n    /*\n        Accepts a result set from the commits table. Should include all columns from\n        the table, and it should be joined to USER to get the user_name.\n    */\n    $url = '?func=browse&group_id=' . urlencode($group_id) . '&set=' . urlencode($set) . '&msort=' . urlencode($msort);\n\n    if ($set == 'custom') {\n        $url .= $pref_stg;\n    }\n\n    $url_nomorder = $url;\n    $url         .= \"&morder=\" . urlencode($morder);\n\n    if ($morder != '') {\n        $orderstr = ' ' . _('sorted by') . ' ' . commit_criteria_list_to_text($morder, $url_nomorder);\n    } else {\n        $orderstr = '';\n    }\n    echo '<A name=\"results\"></A>';\n    echo '<h3>' . $total_rows . ' ' . _('matching commits') . ($total_rows > 1 ? 's' : '') . $orderstr . '</h3>';\n\n    $nav_bar  = '<table width= \"100%\"><tr>';\n    $nav_bar .= '<td width=\"20%\" align =\"left\">';\n\n    if ($msort) {\n        $url_alternate_sort = str_replace('msort=1', 'msort=0', $url) .\n        '&order=#results';\n        $text               = _('deactivate');\n    } else {\n        $url_alternate_sort = str_replace('msort=0', 'msort=1', $url) .\n        '&order=#results';\n        $text               = _('activate');\n    }\n\n    echo '<P>' . sprintf(_('Click a column heading to sort results (up or down), or <A HREF=\"%1$s\"><b>Reset sort</b></a>. You can also <a href=\"%2$s\"><b>%3$s multicolumn sort</b></a>.'), $url . '&order=#results', $url_alternate_sort, $text);\n\n    $purifier = Codendi_HTMLPurifier::instance();\n\n    // If all bugs on screen so no prev/begin pointer at all\n    if ($total_rows > $chunksz) {\n        if ($offset > 0) {\n            $nav_bar .=\n            '<A HREF=\"' . $purifier->purify($url) . '&offset=0#results\"><B>&lt;&lt;  ' . $GLOBALS['Language']->getText('global', 'begin') . '</B></A>' .\n            '&nbsp;&nbsp;&nbsp;&nbsp;' .\n            '<A HREF=\"' . $purifier->purify($url) . '&offset=' . $purifier->purify(urlencode($offset - $chunksz)) .\n            '#results\"><B>< ' . $GLOBALS['Language']->getText('global', 'prev') . ' ' . $chunksz . '</B></A></td>';\n        } else {\n            $nav_bar .=\n            '<span class=\"disable\">&lt;&lt; ' . $GLOBALS['Language']->getText('global', 'begin') . '&nbsp;&nbsp;&lt; ' . $GLOBALS['Language']->getText('global', 'prev') . ' ' . $chunksz . '</span>';\n        }\n    }\n\n    $nav_bar .= '</td>';\n\n    $offset_last = min($offset + $chunksz - 1, $total_rows - 1);\n    $nav_bar    .= '<td width= \"60% \" align = \"center\" class=\"small\">Items ' . $purifier->purify($offset + 1) . ' - ' .\n                $purifier->purify($offset_last + 1) . \"</td>\\n\";\n\n    $nav_bar .= '<td width=\"20%\" align =\"right\">';\n\n    // If all bugs on screen, no next/end pointer at all\n    if ($total_rows > $chunksz) {\n        if (($offset + $chunksz) < $total_rows) {\n            $offset_end = ($total_rows - ($total_rows % $chunksz));\n            if ($offset_end == $total_rows) {\n                $offset_end -= $chunksz;\n            }\n\n            $nav_bar .=\n            '<A HREF=\"' . $purifier->purify($url) . '&offset=' . $purifier->purify(urlencode($offset + $chunksz)) .\n            '#results\" class=\"small\"><B>' . $GLOBALS['Language']->getText('global', 'next') . ' ' . $purifier->purify($chunksz) . ' &gt;</B></A>' .\n            '&nbsp;&nbsp;&nbsp;&nbsp;' .\n            '<A HREF=\"' . $url . '&offset=' . ($offset_end) .\n            '#results\" class=\"small\"><B>' . $GLOBALS['Language']->getText('global', 'end') . ' &gt;&gt;</B></A></td>';\n        } else {\n            $nav_bar .=\n            '<span class=\"disable\">' . $GLOBALS['Language']->getText('global', 'next') . ' ' . $purifier->purify($chunksz) .\n            ' &gt;&nbsp;&nbsp;' . $GLOBALS['Language']->getText('global', 'end') . ' &gt;&gt;</span>';\n        }\n    }\n    $nav_bar .= '</td>';\n    $nav_bar .= \"</tr></table>\\n\";\n\n    echo $nav_bar;\n\n    $filter_str = '';\n    if ($commiter != '100') {\n        $filter_str = \"&commiter='$commiter'\";\n    }\n    if ($tag != '100') {\n        $filter_str = $filter_str . \"&tag='$tag'\";\n    }\n    if ($branch != '100') {\n        $filter_str = $filter_str . \"&branch='$branch'\";\n    }\n    if ($srch != '') {\n        $filter_str = $filter_str . \"&srch='$srch'\";\n    }\n\n    $rows        = db_numrows($result);\n    $url        .= \"&order=\";\n    $title_arr   = [];\n    $title_arr[] = _('ID');\n    $title_arr[] = _('Description');\n    $title_arr[] = _('Date');\n    $title_arr[] = _('Submitted by');\n\n    $links_arr   = [];\n    $links_arr[] = $url . 'id#results';\n    $links_arr[] = $url . 'description#results';\n    $links_arr[] = $url . 'f_when#results';\n    $links_arr[] = $url . 'user_name#results';\n\n    $url_nomorder = $url;\n    $url         .= \"&morder=$morder\";\n\n    echo html_build_list_table_top($title_arr, $links_arr);\n\n    for ($i = 0; $i < $rows; $i++) {\n        $filename = db_result($result, $i, 'filename');\n        if (! $filename) {\n            $filename = '';\n        }\n        // $commits_url = '<A HREF=\"/commits/download.php/Commits'.$commit_id.'.txt?commit_id='.$id.'\">'.$filename.'</a>';\n\n        // if (commits.id == '0', will fetch on desc id, else on commit_id\n        $id_str     = db_result($result, $i, 'id');\n        $id_link    = '&commit_id=' . urlencode($id_str);\n        $id_sublink = '';\n        if ($id_str == '0') {\n            $id_str  = ' ? ';\n            $id_link = \"&checkin_id=\" . db_result($result, $i, 'did') .\n            \"&when=\" . db_result($result, $i, 'c_when') . $filter_str;\n        }\n\n        echo '\n\t\t\t<TR class=\"' . util_get_alt_row_color($i) . '\">' .\n        '<TD class=\"small\"><b><A HREF=\"?func=detailcommit&group_id=' . $purifier->purify(urlencode($group_id) . $id_link . $filter_str) . '\">' . $id_str .\n        '</b></A></TD>' .\n        '<TD class=\"small\">' . $purifier->purify(implode('<br>', preg_split(\"/\\n/D\", db_result($result, $i, 'description'))), CODENDI_PURIFIER_BASIC_NOBR, $group_id) . $id_sublink . '</TD>' .\n      // '<TD class=\"small\">'.$commits_url.'</TD>'.\n        '<TD class=\"small\">' . uniformat_date($GLOBALS['Language']->getText('system', 'datefmt'), db_result($result, $i, 'c_when')) . '</TD>' .\n      // '<TD class=\"small\">'.util_user_link(db_result($result,$i,'assigned_to_user')).'</TD>'.\n        '<TD class=\"small\">' . util_user_link(db_result($result, $i, 'who')) . '</TD></TR>';\n    }\n\n    /*\n        Show extra rows for <-- Prev / Next -->\n    */\n    echo '</TD></TR></TABLE>';\n    echo $nav_bar;\n}\n\nfunction makeCvsLink($group_id, $filename, $text, $rev = '', $displayfunc = '')\n{\n    $res_grp = db_query(\"SELECT * FROM `groups` WHERE group_id=\" . db_ei($group_id));\n\n    $view_str = $displayfunc;\n    if ($rev) {\n        $view_str .= '&revision=' . $rev;\n    }\n\n    $row_grp    = db_fetch_array($res_grp);\n    $group_name = $row_grp['unix_group_name'];\n    return '<A HREF=\"/cvs/viewvc.php/' . $filename . '?root=' . $group_name . '&roottype=cvs' . $view_str . '\"><B>' . $text . \"</B></A>\";\n}\n\nfunction makeCvsDirLink($group_id, $filename, $text, $dir = '')\n{\n    $res_grp    = db_query(\"SELECT * FROM `groups` WHERE group_id=\" . db_ei($group_id));\n    $row_grp    = db_fetch_array($res_grp);\n    $group_name = $row_grp['unix_group_name'];\n    return '<A HREF=\"/cvs/viewvc.php/' . $dir . '?root=' . $group_name . '&roottype=cvs\"><B>' . $text . '</B></A>';\n}\n\n// Check is a sort criteria is already in the list of comma\n// separated criterias. If so invert the sort order, if not then\n// simply add it\nfunction commit_add_sort_criteria($criteria_list, $order, $msort)\n{\n    $found = false;\n    if ($criteria_list) {\n        $arr = explode(',', $criteria_list);\n        $i   = 0;\n        foreach ($arr as $attr) {\n            preg_match(\"/\\s*([^<>]*)([<>]*)/\", $attr, $match);\n            [, $mattr, $mdir] = $match;\n            //echo \"<br><pre>DBG \\$mattr=$mattr,\\$mdir=$mdir</pre>\";\n            if ($mattr == $order) {\n                if (($mdir == '>') || (! isset($mdir))) {\n                    $arr[$i] = $order . '<';\n                } else {\n                    $arr[$i] = $order . '>';\n                }\n                $found = true;\n            }\n            $i++;\n        }\n    }\n\n    if (! $found) {\n        if (! $msort) {\n            unset($arr);\n        }\n        $arr[] = $order . '<';\n    }\n\n    return(join(',', $arr));\n}\n\n/**\n * @psalm-return array<array{order:\"ASC\"|\"DESC\", column: \"id\"|\"revision\"|\"did\"|\"description\"|\"c_when\"|\"date\"|\"f_when\"|\"who\"}>\n */\nfunction commit_criteria_list_to_query(string $criteria_list): array\n{\n    $order_list = [];\n    foreach (explode(',', $criteria_list) as $criteria) {\n        if (preg_match('/^(?<column>[a-z]+)(?<order>[<>]?)$/', $criteria, $matches) === 1) {\n            $column = $matches['column'];\n            if (! in_array($column, ['id', 'revision', 'did', 'description', 'c_when', 'date', 'f_when', 'who'], true)) {\n                continue;\n            }\n            $order = 'ASC';\n            if ($matches['order'] === '<') {\n                $order = 'DESC';\n            }\n            $order_list[] = ['order' => $order, 'column' => $column];\n        }\n    }\n    return $order_list;\n}\n\n// Transform criteria list to readable text statement\n// $url must not contain the morder parameter\nfunction commit_criteria_list_to_text($criteria_list, $url)\n{\n    if ($criteria_list) {\n        $arr    = explode(',', $criteria_list);\n        $morder = '';\n\n        $purifier = Codendi_HTMLPurifier::instance();\n\n        foreach ($arr as $crit) {\n            $morder .= ($morder ? \",\" . $crit : $crit);\n            $attr    = str_replace('>', '', $crit);\n            $attr    = str_replace('<', '', $attr);\n\n            $arr_text[] = '<a href=\"' . $url . '&morder=' . $purifier->purify(urlencode($morder)) . '#results\">' .\n            $purifier->purify(commit_field_get_label($attr)) . '</a><img src=\"' . util_get_dir_image_theme() .\n            ((substr($crit, -1) == '<') ? 'dn' : 'up') .\n            '_arrow.png\" border=\"0\">';\n        }\n    }\n\n    return join(' > ', $arr_text);\n}\n\nfunction commit_field_get_label($sortField)\n{\n    if ($sortField == \"id\") {\n        return _('ID');\n    }\n    if ($sortField == \"f_when\") {\n        return _('Date');\n    }\n    return $sortField;\n}\n\n\nfunction show_commit_details($group_id, $commit_id, $result)\n{\n    /*\n        Accepts a result set from the commits table. Should include all columns from\n        the table, and it should be joined to USER to get the user_name.\n    */\n\n    $rows     = db_numrows($result);\n    $purifier = Codendi_HTMLPurifier::instance();\n    $url      = \"/cvs/?func=detailcommit&commit_id=\" . $purifier->purify(urlencode($commit_id)) . \"&group_id=\" . $purifier->purify(urlencode($group_id)) . \"&order=\";\n    $list_log = '<pre>' . $purifier->purify(util_line_wrap(db_result($result, 0, 'description')), CODENDI_PURIFIER_BASIC_NOBR, $group_id) . '</pre>';\n\n    if ($commit_id) {\n        $hdr = '[' . _('Commit #') . $purifier->purify($commit_id) . '] - ';\n    } else {\n        $hdr = _('Checkin -') . ' ';\n    }\n    echo '<div class=\"cvs-commit\">';\n    echo '<h2>' . $hdr . uniformat_date($GLOBALS['Language']->getText('system', 'datefmt'), db_result($result, 0, 'c_when')) . '</h2></h2>';\n    echo '<table WIDTH=\"100%\" BORDER=\"0\" CELLSPACING=\"1\" CELLPADDING=\"2\"><tr class=\"' . util_get_alt_row_color(0) . '\"><td>' . $list_log . '</td></tr></table>';\n\n    $crossref_fact = new CrossReferenceFactory($commit_id, ReferenceManager::REFERENCE_NATURE_CVSCOMMIT, $group_id);\n    $crossref_fact->fetchDatas();\n    if ($crossref_fact->getNbReferences() > 0) {\n        echo '<h3> ' . $GLOBALS['Language']->getText('cross_ref_fact_include', 'references') . '</h3>';\n        $crossref_fact->DisplayCrossRefs();\n    }\n\n    echo '<h3>' . _('List of impacted files') . '</h3>';\n    $title_arr   = [];\n    $title_arr[] = _('File');\n    $title_arr[] = _('Revision');\n    $title_arr[] = _('Branch');\n    $title_arr[] = _('Type');\n    $title_arr[] = _('Added Lines');\n    $title_arr[] = _('Removed Lines');\n\n    $links_arr   = [];\n    $links_arr[] = $url . 'filename';\n    $links_arr[] = $url . 'revision';\n    $links_arr[] = $url . 'branch';\n    $links_arr[] = $url . 'type';\n    $links_arr[] = $url . 'addedlines';\n    $links_arr[] = $url . 'removedlines';\n\n    echo html_build_list_table_top($title_arr, $links_arr);\n\n    for ($i = 0; $i < $rows; $i++) {\n        $commit_id = db_result($result, $i, 'id');\n        $type      = db_result($result, $i, 'type');\n        $added     = db_result($result, $i, 'addedlines');\n        $removed   = db_result($result, $i, 'removedlines');\n        $revision  = db_result($result, $i, 'revision');\n        $filename  = db_result($result, $i, 'dir') . '/' . db_result($result, $i, 'file');\n\n        if ('remove' === strtolower($type)) {\n            $type_text = _('Delete');\n        } elseif ('add' === strtolower($type)) {\n            $type_text = _('Add');\n        } else {\n            $type_text = _('Change');\n        }\n\n        if (\n            ($type == \"Change\") &&\n            ($added == 999) &&\n            ($removed == 999)\n        ) { // the default values\n          // back to rcs to complete\n            $repo    = db_result($result, $i, 'repository');\n            $command = \"rlog -r\" . escapeshellarg($revision) . \" \" . escapeshellarg($repo . \"/\" . $filename);\n            $output  = [];\n            exec($command, $output, $ret);\n            $added   = 0;\n            $removed = 0;\n            $l       = 0;\n            while ($l < count($output)) { // parse the rlog result till getting \"state: Exp;  lines:\"\n                $line = $output[$l];\n                $l++;\n                if (preg_match('/state: +Exp; +lines: +\\+([0-9]*) +\\-([0-9]*)$/', $line, $na)) {\n                       $added         = db_ei($na[1]);\n                       $removed       = db_ei($na[2]);\n                       $repository_id = db_ei(db_result($result, $i, 'repositoryid'));\n                       $dir_id        = db_ei(db_result($result, $i, 'dirid'));\n                       $file_id       = db_ei(db_result($result, $i, 'fileid'));\n                       $sql_up        = \"UPDATE cvs_checkins SET addedlines=\" . $added . \", removedlines=\" . $removed . \" WHERE repositoryid=\" . $repository_id . \" AND dirid=\" . $dir_id . \" AND fileid=\" . $file_id . \" AND revision='\" . db_es($revision) . \"'\";\n                       $res           = db_query($sql_up);\n                       break;\n                }\n            }\n        }\n\n        if (! $filename) {\n            $filename = '';\n        } else {\n            if ($type == 'Remove') {\n                $filename = makeCvsDirLink($group_id, db_result($result, $i, 'file'), $filename, db_result($result, $i, 'dir'));\n                $rev_text = '';\n            } else {\n        // Clean file path to remove duplicate separators\n                $filename = preg_replace('/\\/\\//', '/', $filename);\n                $filename = preg_replace('/\\.\\//', '', $filename);\n\n                if ($type == 'Change') {\n                          // horrible hack to 'guess previous revision' to diff with\n                          $prev = explode(\".\", $revision);\n\n                          $lastIndex = sizeof($prev);\n                          $lastIndex = $lastIndex - 1;\n                    if ($prev[$lastIndex] != '1') {\n                        $prev[$lastIndex] = $prev[$lastIndex] - 1;\n                        $previous         = join(\".\", $prev);\n                    } else {\n                        $index    = 0;\n                        $new_prev = [];\n                        while ($index <= $lastIndex - 2) {\n                            $new_prev[$index] = $prev[$index];\n                            $index++;\n                        }\n                        $previous = join('.', $new_prev);\n                    }\n                    $type = makeCvsLink($group_id, $filename, $type_text, '', '&r1=' . $previous . '&r2=' . $revision);\n                }\n\n                $rev_text = makeCvsLink($group_id, $filename, $revision, $revision, '&view=markup');\n                $filename = makeCvsLink($group_id, $filename, $filename, '', '&view=log');\n            }\n        }\n        // $commits_url = '<A HREF=\"/commits/download.php/Commits'.$commit_id.'.txt?commit_id='.$id.'\">'.$filename.'</a>';\n\n        echo '\n\t\t\t<TR class=\"' . util_get_alt_row_color($i) . '\">' .\n        '<TD class=\"small\"><b>' . $filename . '</b></TD>' .\n        '<TD class=\"small\">' . $rev_text . '</TD>' .\n        '<TD class=\"small\">' . db_result($result, $i, 'branch') . '</TD>' .\n        '<TD class=\"small\">' . $type . '</TD>' .\n        '<TD class=\"small\">' . $added . '</TD>' .\n        '<TD class=\"small\">' . $removed . '</TD></TR>';\n    }\n\n    /*\n        Show extra rows for <-- Prev / Next -->\n    */\n    echo '\n\t\t<TR><TD COLSPAN=\"2\" class=\"small\">';\n    if ($offset > 0) {\n        echo '<A HREF=\"?func=browse&group_id=' . $purifier->purify(urlencode($group_id)) . '&set=' . $set . '&offset=' . $purifier->purify(urlencode($offset - 50)) . '\"><B>&lt; ' . $GLOBALS['Language']->getText('global', 'prev') . '</B></A>';\n    } else {\n        echo '&nbsp;';\n    }\n    echo '</TD><TD>&nbsp;</TD><TD COLSPAN=\"2\" class=\"small\">';\n\n    if ($rows == 50) {\n        echo '<A HREF=\"?func=browse&group_id=' . $purifier->purify(urlencode($group_id)) . '&set=' . $set . '&offset=' . $purifier->purify(urlencode($offset + 50)) . '\"><B>' . $GLOBALS['Language']->getText('global', 'prev') . ' 50 &gt;</B></A>';\n    } else {\n        echo '&nbsp;';\n    }\n    echo '</TD></TR></TABLE>';\n    echo '</div>';\n}\n\n\n// Are there any commits in the cvs history ?\nfunction format_cvs_history($group_id)\n{\n    $res_cvsfullhist = get_cvs_history($group_id);\n\n    if (! $res_cvsfullhist || db_numrows($res_cvsfullhist) < 1) {\n        $output = '<P>' . _('This project has no CVS history.');\n    } else {\n        $cvshist = [];\n        while ($row_cvsfullhist = db_fetch_array($res_cvsfullhist)) {\n            $cvshist[$row_cvsfullhist['user_name']]['full'] = $row_cvsfullhist['commits'];\n            $cvshist[$row_cvsfullhist['user_name']]['last'] = 0;\n        }\n\n      // Now over the last 7 days\n        $res_cvslasthist = get_cvs_history($group_id, 7 * 24 * 3600);\n\n        while ($row_cvslasthist = db_fetch_array($res_cvslasthist)) {\n            $cvshist[$row_cvslasthist['user_name']]['last'] = $row_cvslasthist['commits'];\n        }\n\n      // Format output\n        $output = '<P><b>' . _('Developer Commits (Last 7 days/Total)') . '</b><BR>&nbsp;';\n        foreach ($cvshist as $user => $value) {\n            $output .= '<BR>' . $user . ' (' . $cvshist[$user]['last'] . '/'\n            . $cvshist[$user]['full'] . ')';\n        }\n    }\n    return $output;\n}\n\n\n// list the number of commits by user either since the beginning of\n// history if the period argument is not given or if it is given then\n// over the last \"period\" of time.\n// period is expressed in seconds\nfunction get_cvs_history($group_id, $period = false)\n{\n    $pm    = ProjectManager::instance();\n    $group = $pm->getProject($group_id);\n\n    if ($period) {\n      // All times in cvs tables are stored in UTC ???\n        $date_clause = \"AND co.comm_when >= \" . date(\"YmdHis\", (gmdate('U') - $period)) . \" \";\n    } else {\n        $date_clause = \"\";\n    }\n    $cvs_repository = db_es('/cvsroot/' . $group->getUnixName(false));\n    $query          = \"SELECT u.user_name, count(co.id) as commits \" .\n    \"FROM cvs_commits co, user u, cvs_repositories repo, cvs_checkins ci \" .\n    \"WHERE co.whoid=u.user_id \" .\n    \"AND repo.repository='$cvs_repository' \" .\n    \"AND ci.repositoryid=repo.id \" .\n    \"AND ci.whoid=co.whoid \" .\n    \"AND ci.commitid=co.id \" .\n    $date_clause .\n    \"GROUP BY co.whoid ORDER BY user_name\";\n    $result         = db_query($query);\n    return($result);\n}\n\nfunction get_user_shell($user_id)\n{\n    $user_id  = db_ei($user_id);\n    $res_user = db_query(\"SELECT shell FROM user WHERE user_id=$user_id\");\n    $row_user = db_fetch_array($res_user);\n    return $row_user['shell'];\n}\n\nfunction check_cvs_access($username, $group_name, $cvspath)\n{\n    $pm      = ProjectManager::instance();\n    $project = $pm->getProjectByUnixName($group_name);\n\n  //accept old url containing a .diff at the end of the filename\n    if (strpos($cvspath, '.diff') == (strlen($cvspath) - 5)) {\n        $cvspath = substr($cvspath, 0, (strlen($cvspath) - 5));\n    }\n\n  // if the file path exists as such then it's a directory\n  // else add the ,v extension because it's a file\n    $path = \"/cvsroot/\" . $group_name . '/' . $cvspath;\n    if (! is_dir($path)) {\n        $path = $path . ',v';\n    }\n    $mode = fileperms($path);\n\n  // Also check permissions on top directory (in case of private repo)\n    $mode_top = fileperms(\"/cvsroot/\" . $group_name);\n\n  // A directory that is not world readable can only be viewed\n  // through viewvc if the user is a project member\n    if ($project && (($mode_top & 0x0004) == 0 || ($mode & 0x0004) == 0) && ! user_ismember($project->getID())) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\n\n// Return the group ID from a repository name\n// Repository names look like '/cvsroot/groupname', without trailing slash!\nfunction get_group_id_from_repository($repository)\n{\n    $pm      = ProjectManager::instance();\n    $project = $pm->getProjectByUnixName(basename($repository));\n    if (! $project) {\n        return false;\n    }\n\n    return $project->getID();\n}\n\n/**\n * @psalm-param array<array{order:\"ASC\"|\"DESC\", column: \"id\"|\"revision\"|\"did\"|\"description\"|\"c_when\"|\"date\"|\"f_when\"|\"who\"}> $order_by\n */\nfunction cvs_get_revisions($project, $offset, $chunksz, $_tag = 100, $_branch = 100, $_commit_id = '', $_commiter = 100, $_srch = '', array $order_by = [], $pv = 0)\n{\n    //if status selected, and more to where clause\n    if ($_branch != 100) {\n        //for open tasks, add status=100 to make sure we show all\n        $branch_str = \"AND cvs_checkins.branchid=\" . db_ei($_branch);\n    } else {\n        //no status was chosen, so don't add it to where clause\n        $branch_str = '';\n    }\n\n    //if assigned to selected, and more to where clause\n    if ($_commit_id != '') {\n        $_commit_id = db_ei($_commit_id);\n        $commit_str = \"AND cvs_commits.id=$_commit_id AND cvs_checkins.commitid != 0 \";\n    } else {\n        $commit_str = '';\n    }\n\n    if ($_commiter != 100) {\n        $_commiter    = db_es($_commiter);\n        $commiter_str = \"AND user.user_id=cvs_checkins.whoid \" .\n          \"AND user.user_name='$_commiter' \";\n    } else {\n        //no assigned to was chosen, so don't add it to where clause\n        $commiter_str = '';\n    }\n\n    if ($_srch != '') {\n        $_srch    = db_es('%' . $_srch . '%');\n        $srch_str = \"AND cvs_descs.description like '$_srch' \";\n    } else {\n        $srch_str = \"\";\n    }\n\n    //build page title to make bookmarking easier\n    //if a user was selected, add the user_name to the title\n    //same for status\n\n    //commits_header(array('title'=>'Browse Commits'.\n    //    (($_assigned_to)?' For: '.user_getname($_assigned_to):'').\n    //    (($_tag && ($_tag != 100))?' By Status: '. get_commits_status_nam//e($_status):''),\n    //           'help' => 'CommitsManager.html'));\n\n    // get repository id\n    $cvs_repository = db_es('/cvsroot/' . $project->getUnixName(false));\n    $query          = \"SELECT id from cvs_repositories where cvs_repositories.repository='$cvs_repository' \";\n    $rs             = db_query($query);\n    $repo_id        = db_result($rs, 0, 0);\n    $repo_id        = $repo_id ? $repo_id : -1;\n\n    $select = 'SELECT distinct cvs_checkins.commitid as id, cvs_checkins.commitid as revision, cvs_descs.id as did, cvs_descs.description, cvs_commits.comm_when as c_when, cvs_commits.comm_when as date, cvs_commits.comm_when as f_when, user.user_name as who ';\n    $from   = \"FROM cvs_descs, cvs_checkins, user, cvs_commits \";\n    $where  = \"WHERE cvs_checkins.descid=cvs_descs.id \" .\n    \"AND \" . (check_cvs_access(user_getname(), $project->getUnixName(false), '') ? 1 : 0) . \" \" .\n        \"AND cvs_checkins.commitid=cvs_commits.id \" .\n        \"AND user.user_id=cvs_checkins.whoid \" .\n            \"AND cvs_checkins.repositoryid=\" . $repo_id . \" \" .\n        \"$commiter_str \" .\n            \"$commit_str \" .\n        \"$srch_str \" .\n        \"$branch_str \";\n\n    $limit = '';\n    if (! $pv) {\n        $limit = \" LIMIT $offset,$chunksz\";\n    }\n\n    if (empty($order_by)) {\n        $order_by_sql = ' ORDER BY id desc, f_when desc ';\n    } else {\n        $order_by_sql  = ' ORDER BY ';\n        $order_by_sql .= implode(\n            ',',\n            array_map(\n                static function (array $order_by_row) {\n                    return $order_by_row['column'] . ' ' . $order_by_row['order'];\n                },\n                $order_by\n            )\n        );\n        $order_by_sql .= ' ';\n    }\n\n    $sql = $select .\n    $from .\n    $where .\n    $order_by_sql .\n    $limit;\n\n    $result = db_query($sql);\n\n    /* expensive way to have total rows number didn'get a cheaper one */\n\n    $sql1      = $select .\n    $from .\n    $where;\n    $result1   = db_query($sql1);\n    $totalrows = db_numrows($result1);\n\n    return [$result, $totalrows];\n}\n\nfunction cvs_get_revision_detail($commit_id)\n{\n    $commit_id = db_ei($commit_id);\n    $sql       = \"SELECT repository, cvs_commits.comm_when as c_when, repositoryid, description, file, fileid, dir, dirid, type, branch, revision, addedlines, removedlines \" .\n                    \"FROM cvs_dirs, cvs_descs, cvs_files, cvs_checkins, cvs_branches, cvs_repositories, cvs_commits \" .\n                    \"WHERE cvs_checkins.fileid=cvs_files.id \" .\n                    \"   AND cvs_checkins.dirid=cvs_dirs.id \" .\n                    \"   AND cvs_checkins.commitid=cvs_commits.id \" .\n                    \"   AND cvs_checkins.branchid=cvs_branches.id \" .\n                    \"   AND cvs_checkins.descid=cvs_descs.id \" .\n                    \"   AND cvs_checkins.repositoryid=cvs_repositories.id \" .\n                    \"   AND cvs_checkins.commitid=$commit_id \";\n    $result    = db_query($sql);\n    return $result;\n}\n"], "fixing_code": ["<?php\n/**\n * Copyright (c) Enalean, 2013 - Present. All Rights Reserved.\n * Copyright 1999-2000 (c) The SourceForge Crew\n * SourceForge: Breaking Down the Barriers to Open Source Development\n *\n * This file is a part of Tuleap.\n *\n * Tuleap is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Tuleap is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Tuleap. If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n\n    Commits Manager\n    By Thierry Jacquin, Nov 2003\n\n*/\n\nfunction uniformat_date($format, $date)\n{\n    if (preg_match(\"/([0-9]{4})-?([0-9]{2})-?([0-9]{2}) ?([0-9]{2}):?([0-9]{2}):?([0-9]{2})/\", $date, $gp)) {\n        [, $y, $m, $d, $h, $min, $s] = $gp;\n        $time                        = mktime($h, $min, $s, $m, $d, $y);\n        $date                        = date($format, $time);\n    }\n    return $date;\n}\n\nfunction commits_footer($params)\n{\n    site_project_footer($params);\n}\n\nfunction commits_branches_box($group_id, $name = 'branch', $checked = 'xzxz', $text_100 = 'None')\n{\n    if (! $group_id) {\n        return _('ERROR - no group_id');\n    } else {\n        $sql = \"SELECT unix_group_name from `groups` where group_id=\" . db_ei($group_id);\n\n        $result         = db_query($sql);\n        $projectname    = db_result($result, 0, 'unix_group_name');\n        $cvs_repository = db_es('/cvsroot/' . $projectname);\n     /*\n      List of possible commits_categories set up for the project\n     */\n        $sql    = \"select distinct cvs_branches.* FROM cvs_branches, cvs_checkins, cvs_repositories  where \" .\n        \"cvs_checkins.repositoryid=cvs_repositories.id AND cvs_repositories.repository='$cvs_repository' \" .\n        \"AND cvs_checkins.branchid=cvs_branches.id\";\n        $result = db_query($sql);\n\n        return html_build_select_box($result, $name, $checked, true, $text_100);\n    }\n}\n\nfunction commits_data_get_technicians($projectname)\n{\n    // Get list of all people who once committed something in the CVS\n    // including those who may have been removed from the project since then.\n    $cvs_repository = db_es('%/' . $projectname);\n    $sql            = \"SELECT DISTINCT user.user_name, user.user_name \" .\n        \"FROM cvs_checkins, cvs_repositories, user \" .\n        \"WHERE (cvs_repositories.repository like '$cvs_repository') AND (cvs_repositories.id = cvs_checkins.repositoryid) AND (cvs_checkins.whoid=user.user_id) \" .\n        \"ORDER BY user.user_name ASC\";\n    return db_query($sql);\n}\n\nfunction commits_technician_box($projectname, $name = '_commiter', $checked = 'xzxz', $text_100 = 'None')\n{\n    if (! $projectname) {\n        return _('ERROR - no group_id');\n    } else {\n        $result = commits_data_get_technicians($projectname);\n        if (! in_array($checked, util_result_column_to_array($result))) {\n            // Selected 'my commits' but never commited\n            $checked = 'xzxz';\n        }\n        return html_build_select_box($result, $name, $checked, true, $text_100);\n    }\n}\n\nfunction commits_tags_box($group_id, $name = '_tag', $checked = 'xzxz', $text_100 = 'None')\n{\n    $sql = \"SELECT unix_group_name from `groups` where group_id=\" . db_ei($group_id);\n\n    $result      = db_query($sql);\n    $projectname = db_result($result, 0, 'unix_group_name');\n\n    $cvs_repository = db_es('/cvsroot/' . $projectname);\n    $sql            = \"select distinct stickytag, stickytag from cvs_checkins, cvs_repositories where cvs_checkins.repositoryid=cvs_repositories.id AND cvs_repositories.repository='$cvs_repository'\";\n    $result         = db_query($sql);\n    return html_build_select_box($result, $name, $checked, true, $text_100);\n}\n\nfunction show_commitslist(\n    $group_id,\n    $result,\n    $offset,\n    $total_rows,\n    $set = 'any',\n    $commiter = '100',\n    $tag = '100',\n    $branch = '100',\n    $srch = '',\n    $chunksz = 15,\n    $morder = '',\n    $msort = 0,\n) {\n    /*\n        Accepts a result set from the commits table. Should include all columns from\n        the table, and it should be joined to USER to get the user_name.\n    */\n    $url = '?func=browse&group_id=' . urlencode($group_id) . '&set=' . urlencode($set) . '&msort=' . urlencode($msort);\n\n    if ($set == 'custom') {\n        $url .= $pref_stg;\n    }\n\n    $url_nomorder = $url;\n    $url         .= \"&morder=\" . urlencode($morder);\n\n    if ($morder != '') {\n        $orderstr = ' ' . _('sorted by') . ' ' . commit_criteria_list_to_text($morder, $url_nomorder);\n    } else {\n        $orderstr = '';\n    }\n    echo '<A name=\"results\"></A>';\n    echo '<h3>' . $total_rows . ' ' . _('matching commits') . ($total_rows > 1 ? 's' : '') . $orderstr . '</h3>';\n\n    $nav_bar  = '<table width= \"100%\"><tr>';\n    $nav_bar .= '<td width=\"20%\" align =\"left\">';\n\n    if ($msort) {\n        $url_alternate_sort = str_replace('msort=1', 'msort=0', $url) .\n        '&order=#results';\n        $text               = _('deactivate');\n    } else {\n        $url_alternate_sort = str_replace('msort=0', 'msort=1', $url) .\n        '&order=#results';\n        $text               = _('activate');\n    }\n\n    echo '<P>' . sprintf(_('Click a column heading to sort results (up or down), or <A HREF=\"%1$s\"><b>Reset sort</b></a>. You can also <a href=\"%2$s\"><b>%3$s multicolumn sort</b></a>.'), $url . '&order=#results', $url_alternate_sort, $text);\n\n    $purifier = Codendi_HTMLPurifier::instance();\n\n    // If all bugs on screen so no prev/begin pointer at all\n    if ($total_rows > $chunksz) {\n        if ($offset > 0) {\n            $nav_bar .=\n            '<A HREF=\"' . $purifier->purify($url) . '&offset=0#results\"><B>&lt;&lt;  ' . $GLOBALS['Language']->getText('global', 'begin') . '</B></A>' .\n            '&nbsp;&nbsp;&nbsp;&nbsp;' .\n            '<A HREF=\"' . $purifier->purify($url) . '&offset=' . $purifier->purify(urlencode($offset - $chunksz)) .\n            '#results\"><B>< ' . $GLOBALS['Language']->getText('global', 'prev') . ' ' . $chunksz . '</B></A></td>';\n        } else {\n            $nav_bar .=\n            '<span class=\"disable\">&lt;&lt; ' . $GLOBALS['Language']->getText('global', 'begin') . '&nbsp;&nbsp;&lt; ' . $GLOBALS['Language']->getText('global', 'prev') . ' ' . $chunksz . '</span>';\n        }\n    }\n\n    $nav_bar .= '</td>';\n\n    $offset_last = min($offset + $chunksz - 1, $total_rows - 1);\n    $nav_bar    .= '<td width= \"60% \" align = \"center\" class=\"small\">Items ' . $purifier->purify($offset + 1) . ' - ' .\n                $purifier->purify($offset_last + 1) . \"</td>\\n\";\n\n    $nav_bar .= '<td width=\"20%\" align =\"right\">';\n\n    // If all bugs on screen, no next/end pointer at all\n    if ($total_rows > $chunksz) {\n        if (($offset + $chunksz) < $total_rows) {\n            $offset_end = ($total_rows - ($total_rows % $chunksz));\n            if ($offset_end == $total_rows) {\n                $offset_end -= $chunksz;\n            }\n\n            $nav_bar .=\n            '<A HREF=\"' . $purifier->purify($url) . '&offset=' . $purifier->purify(urlencode($offset + $chunksz)) .\n            '#results\" class=\"small\"><B>' . $GLOBALS['Language']->getText('global', 'next') . ' ' . $purifier->purify($chunksz) . ' &gt;</B></A>' .\n            '&nbsp;&nbsp;&nbsp;&nbsp;' .\n            '<A HREF=\"' . $url . '&offset=' . ($offset_end) .\n            '#results\" class=\"small\"><B>' . $GLOBALS['Language']->getText('global', 'end') . ' &gt;&gt;</B></A></td>';\n        } else {\n            $nav_bar .=\n            '<span class=\"disable\">' . $GLOBALS['Language']->getText('global', 'next') . ' ' . $purifier->purify($chunksz) .\n            ' &gt;&nbsp;&nbsp;' . $GLOBALS['Language']->getText('global', 'end') . ' &gt;&gt;</span>';\n        }\n    }\n    $nav_bar .= '</td>';\n    $nav_bar .= \"</tr></table>\\n\";\n\n    echo $nav_bar;\n\n    $filter_str = '';\n    if ($commiter != '100') {\n        $filter_str = \"&commiter='$commiter'\";\n    }\n    if ($tag != '100') {\n        $filter_str = $filter_str . \"&tag='$tag'\";\n    }\n    if ($branch != '100') {\n        $filter_str = $filter_str . \"&branch='$branch'\";\n    }\n    if ($srch != '') {\n        $filter_str = $filter_str . \"&srch='$srch'\";\n    }\n\n    $rows        = db_numrows($result);\n    $url        .= \"&order=\";\n    $title_arr   = [];\n    $title_arr[] = _('ID');\n    $title_arr[] = _('Description');\n    $title_arr[] = _('Date');\n    $title_arr[] = _('Submitted by');\n\n    $links_arr   = [];\n    $links_arr[] = $url . 'id#results';\n    $links_arr[] = $url . 'description#results';\n    $links_arr[] = $url . 'f_when#results';\n    $links_arr[] = $url . 'user_name#results';\n\n    $url_nomorder = $url;\n    $url         .= \"&morder=$morder\";\n\n    echo html_build_list_table_top($title_arr, $links_arr);\n\n    for ($i = 0; $i < $rows; $i++) {\n        $filename = db_result($result, $i, 'filename');\n        if (! $filename) {\n            $filename = '';\n        }\n        // $commits_url = '<A HREF=\"/commits/download.php/Commits'.$commit_id.'.txt?commit_id='.$id.'\">'.$filename.'</a>';\n\n        // if (commits.id == '0', will fetch on desc id, else on commit_id\n        $id_str     = db_result($result, $i, 'id');\n        $id_link    = '&commit_id=' . urlencode($id_str);\n        $id_sublink = '';\n        if ($id_str == '0') {\n            $id_str  = ' ? ';\n            $id_link = \"&checkin_id=\" . db_result($result, $i, 'did') .\n            \"&when=\" . db_result($result, $i, 'c_when') . $filter_str;\n        }\n\n        echo '\n\t\t\t<TR class=\"' . util_get_alt_row_color($i) . '\">' .\n        '<TD class=\"small\"><b><A HREF=\"?func=detailcommit&group_id=' . $purifier->purify(urlencode($group_id) . $id_link . $filter_str) . '\">' . $id_str .\n        '</b></A></TD>' .\n        '<TD class=\"small\">' . $purifier->purify(implode('<br>', preg_split(\"/\\n/D\", db_result($result, $i, 'description'))), CODENDI_PURIFIER_BASIC_NOBR, $group_id) . $id_sublink . '</TD>' .\n      // '<TD class=\"small\">'.$commits_url.'</TD>'.\n        '<TD class=\"small\">' . uniformat_date($GLOBALS['Language']->getText('system', 'datefmt'), db_result($result, $i, 'c_when')) . '</TD>' .\n      // '<TD class=\"small\">'.util_user_link(db_result($result,$i,'assigned_to_user')).'</TD>'.\n        '<TD class=\"small\">' . util_user_link(db_result($result, $i, 'who')) . '</TD></TR>';\n    }\n\n    /*\n        Show extra rows for <-- Prev / Next -->\n    */\n    echo '</TD></TR></TABLE>';\n    echo $nav_bar;\n}\n\nfunction makeCvsLink($group_id, $filename, $text, $rev = '', $displayfunc = '')\n{\n    $res_grp = db_query(\"SELECT * FROM `groups` WHERE group_id=\" . db_ei($group_id));\n\n    $view_str = $displayfunc;\n    if ($rev) {\n        $view_str .= '&revision=' . $rev;\n    }\n\n    $row_grp    = db_fetch_array($res_grp);\n    $group_name = $row_grp['unix_group_name'];\n    return '<A HREF=\"/cvs/viewvc.php/' . $filename . '?root=' . $group_name . '&roottype=cvs' . $view_str . '\"><B>' . $text . \"</B></A>\";\n}\n\nfunction makeCvsDirLink($group_id, $filename, $text, $dir = '')\n{\n    $res_grp    = db_query(\"SELECT * FROM `groups` WHERE group_id=\" . db_ei($group_id));\n    $row_grp    = db_fetch_array($res_grp);\n    $group_name = $row_grp['unix_group_name'];\n    return '<A HREF=\"/cvs/viewvc.php/' . $dir . '?root=' . $group_name . '&roottype=cvs\"><B>' . $text . '</B></A>';\n}\n\n// Check is a sort criteria is already in the list of comma\n// separated criterias. If so invert the sort order, if not then\n// simply add it\nfunction commit_add_sort_criteria($criteria_list, $order, $msort)\n{\n    $found = false;\n    if ($criteria_list) {\n        $arr = explode(',', $criteria_list);\n        $i   = 0;\n        foreach ($arr as $attr) {\n            preg_match(\"/\\s*([^<>]*)([<>]*)/\", $attr, $match);\n            [, $mattr, $mdir] = $match;\n            //echo \"<br><pre>DBG \\$mattr=$mattr,\\$mdir=$mdir</pre>\";\n            if ($mattr == $order) {\n                if (($mdir == '>') || (! isset($mdir))) {\n                    $arr[$i] = $order . '<';\n                } else {\n                    $arr[$i] = $order . '>';\n                }\n                $found = true;\n            }\n            $i++;\n        }\n    }\n\n    if (! $found) {\n        if (! $msort) {\n            unset($arr);\n        }\n        $arr[] = $order . '<';\n    }\n\n    return(join(',', $arr));\n}\n\n/**\n * @psalm-return array<array{order:\"ASC\"|\"DESC\", column: \"id\"|\"revision\"|\"did\"|\"description\"|\"c_when\"|\"date\"|\"f_when\"|\"who\"}>\n */\nfunction commit_criteria_list_to_query(string $criteria_list): array\n{\n    $order_list = [];\n    foreach (explode(',', $criteria_list) as $criteria) {\n        if (preg_match('/^(?<column>[a-z]+)(?<order>[<>]?)$/', $criteria, $matches) === 1) {\n            $column = $matches['column'];\n            if (! in_array($column, ['id', 'revision', 'did', 'description', 'c_when', 'date', 'f_when', 'who'], true)) {\n                continue;\n            }\n            $order = 'ASC';\n            if ($matches['order'] === '<') {\n                $order = 'DESC';\n            }\n            $order_list[] = ['order' => $order, 'column' => $column];\n        }\n    }\n    return $order_list;\n}\n\n// Transform criteria list to readable text statement\n// $url must not contain the morder parameter\nfunction commit_criteria_list_to_text($criteria_list, $url)\n{\n    if ($criteria_list) {\n        $arr    = explode(',', $criteria_list);\n        $morder = '';\n\n        $purifier = Codendi_HTMLPurifier::instance();\n\n        foreach ($arr as $crit) {\n            $morder .= ($morder ? \",\" . $crit : $crit);\n            $attr    = str_replace('>', '', $crit);\n            $attr    = str_replace('<', '', $attr);\n\n            $arr_text[] = '<a href=\"' . $url . '&morder=' . $purifier->purify(urlencode($morder)) . '#results\">' .\n            $purifier->purify(commit_field_get_label($attr)) . '</a><img src=\"' . util_get_dir_image_theme() .\n            ((substr($crit, -1) == '<') ? 'dn' : 'up') .\n            '_arrow.png\" border=\"0\">';\n        }\n    }\n\n    return join(' > ', $arr_text);\n}\n\nfunction commit_field_get_label($sortField)\n{\n    if ($sortField == \"id\") {\n        return _('ID');\n    }\n    if ($sortField == \"f_when\") {\n        return _('Date');\n    }\n    return $sortField;\n}\n\n\nfunction show_commit_details($group_id, $commit_id, $result)\n{\n    /*\n        Accepts a result set from the commits table. Should include all columns from\n        the table, and it should be joined to USER to get the user_name.\n    */\n\n    $rows     = db_numrows($result);\n    $purifier = Codendi_HTMLPurifier::instance();\n    $url      = \"/cvs/?func=detailcommit&commit_id=\" . $purifier->purify(urlencode($commit_id)) . \"&group_id=\" . $purifier->purify(urlencode($group_id)) . \"&order=\";\n    $list_log = '<pre>' . $purifier->purify(util_line_wrap(db_result($result, 0, 'description')), CODENDI_PURIFIER_BASIC_NOBR, $group_id) . '</pre>';\n\n    if ($commit_id) {\n        $hdr = '[' . _('Commit #') . $purifier->purify($commit_id) . '] - ';\n    } else {\n        $hdr = _('Checkin -') . ' ';\n    }\n    echo '<div class=\"cvs-commit\">';\n    echo '<h2>' . $hdr . uniformat_date($GLOBALS['Language']->getText('system', 'datefmt'), db_result($result, 0, 'c_when')) . '</h2></h2>';\n    echo '<table WIDTH=\"100%\" BORDER=\"0\" CELLSPACING=\"1\" CELLPADDING=\"2\"><tr class=\"' . util_get_alt_row_color(0) . '\"><td>' . $list_log . '</td></tr></table>';\n\n    $crossref_fact = new CrossReferenceFactory($commit_id, ReferenceManager::REFERENCE_NATURE_CVSCOMMIT, $group_id);\n    $crossref_fact->fetchDatas();\n    if ($crossref_fact->getNbReferences() > 0) {\n        echo '<h3> ' . $GLOBALS['Language']->getText('cross_ref_fact_include', 'references') . '</h3>';\n        $crossref_fact->DisplayCrossRefs();\n    }\n\n    echo '<h3>' . _('List of impacted files') . '</h3>';\n    $title_arr   = [];\n    $title_arr[] = _('File');\n    $title_arr[] = _('Revision');\n    $title_arr[] = _('Branch');\n    $title_arr[] = _('Type');\n    $title_arr[] = _('Added Lines');\n    $title_arr[] = _('Removed Lines');\n\n    $links_arr   = [];\n    $links_arr[] = $url . 'filename';\n    $links_arr[] = $url . 'revision';\n    $links_arr[] = $url . 'branch';\n    $links_arr[] = $url . 'type';\n    $links_arr[] = $url . 'addedlines';\n    $links_arr[] = $url . 'removedlines';\n\n    echo html_build_list_table_top($title_arr, $links_arr);\n\n    for ($i = 0; $i < $rows; $i++) {\n        $commit_id = db_result($result, $i, 'id');\n        $type      = db_result($result, $i, 'type');\n        $added     = db_result($result, $i, 'addedlines');\n        $removed   = db_result($result, $i, 'removedlines');\n        $revision  = db_result($result, $i, 'revision');\n        $filename  = db_result($result, $i, 'dir') . '/' . db_result($result, $i, 'file');\n\n        if ('remove' === strtolower($type)) {\n            $type_text = _('Delete');\n        } elseif ('add' === strtolower($type)) {\n            $type_text = _('Add');\n        } else {\n            $type_text = _('Change');\n        }\n\n        if (\n            ($type == \"Change\") &&\n            ($added == 999) &&\n            ($removed == 999)\n        ) { // the default values\n          // back to rcs to complete\n            $repo    = db_result($result, $i, 'repository');\n            $command = \"rlog -r\" . escapeshellarg($revision) . \" \" . escapeshellarg($repo . \"/\" . $filename);\n            $output  = [];\n            exec($command, $output, $ret);\n            $added   = 0;\n            $removed = 0;\n            $l       = 0;\n            while ($l < count($output)) { // parse the rlog result till getting \"state: Exp;  lines:\"\n                $line = $output[$l];\n                $l++;\n                if (preg_match('/state: +Exp; +lines: +\\+([0-9]*) +\\-([0-9]*)$/', $line, $na)) {\n                       $added         = db_ei($na[1]);\n                       $removed       = db_ei($na[2]);\n                       $repository_id = db_ei(db_result($result, $i, 'repositoryid'));\n                       $dir_id        = db_ei(db_result($result, $i, 'dirid'));\n                       $file_id       = db_ei(db_result($result, $i, 'fileid'));\n                       $sql_up        = \"UPDATE cvs_checkins SET addedlines=\" . $added . \", removedlines=\" . $removed . \" WHERE repositoryid=\" . $repository_id . \" AND dirid=\" . $dir_id . \" AND fileid=\" . $file_id . \" AND revision='\" . db_es($revision) . \"'\";\n                       $res           = db_query($sql_up);\n                       break;\n                }\n            }\n        }\n\n        if (! $filename) {\n            $filename = '';\n        } else {\n            if ($type == 'Remove') {\n                $filename = makeCvsDirLink($group_id, db_result($result, $i, 'file'), $filename, db_result($result, $i, 'dir'));\n                $rev_text = '';\n            } else {\n        // Clean file path to remove duplicate separators\n                $filename = preg_replace('/\\/\\//', '/', $filename);\n                $filename = preg_replace('/\\.\\//', '', $filename);\n\n                if ($type == 'Change') {\n                          // horrible hack to 'guess previous revision' to diff with\n                          $prev = explode(\".\", $revision);\n\n                          $lastIndex = sizeof($prev);\n                          $lastIndex = $lastIndex - 1;\n                    if ($prev[$lastIndex] != '1') {\n                        $prev[$lastIndex] = $prev[$lastIndex] - 1;\n                        $previous         = join(\".\", $prev);\n                    } else {\n                        $index    = 0;\n                        $new_prev = [];\n                        while ($index <= $lastIndex - 2) {\n                            $new_prev[$index] = $prev[$index];\n                            $index++;\n                        }\n                        $previous = join('.', $new_prev);\n                    }\n                    $type = makeCvsLink($group_id, $filename, $type_text, '', '&r1=' . $previous . '&r2=' . $revision);\n                }\n\n                $rev_text = makeCvsLink($group_id, $filename, $revision, $revision, '&view=markup');\n                $filename = makeCvsLink($group_id, $filename, $filename, '', '&view=log');\n            }\n        }\n        // $commits_url = '<A HREF=\"/commits/download.php/Commits'.$commit_id.'.txt?commit_id='.$id.'\">'.$filename.'</a>';\n\n        echo '\n\t\t\t<TR class=\"' . util_get_alt_row_color($i) . '\">' .\n        '<TD class=\"small\"><b>' . $filename . '</b></TD>' .\n        '<TD class=\"small\">' . $rev_text . '</TD>' .\n        '<TD class=\"small\">' . db_result($result, $i, 'branch') . '</TD>' .\n        '<TD class=\"small\">' . $type . '</TD>' .\n        '<TD class=\"small\">' . $added . '</TD>' .\n        '<TD class=\"small\">' . $removed . '</TD></TR>';\n    }\n\n    /*\n        Show extra rows for <-- Prev / Next -->\n    */\n    echo '\n\t\t<TR><TD COLSPAN=\"2\" class=\"small\">';\n    if ($offset > 0) {\n        echo '<A HREF=\"?func=browse&group_id=' . $purifier->purify(urlencode($group_id)) . '&set=' . $set . '&offset=' . $purifier->purify(urlencode($offset - 50)) . '\"><B>&lt; ' . $GLOBALS['Language']->getText('global', 'prev') . '</B></A>';\n    } else {\n        echo '&nbsp;';\n    }\n    echo '</TD><TD>&nbsp;</TD><TD COLSPAN=\"2\" class=\"small\">';\n\n    if ($rows == 50) {\n        echo '<A HREF=\"?func=browse&group_id=' . $purifier->purify(urlencode($group_id)) . '&set=' . $set . '&offset=' . $purifier->purify(urlencode($offset + 50)) . '\"><B>' . $GLOBALS['Language']->getText('global', 'prev') . ' 50 &gt;</B></A>';\n    } else {\n        echo '&nbsp;';\n    }\n    echo '</TD></TR></TABLE>';\n    echo '</div>';\n}\n\n\n// Are there any commits in the cvs history ?\nfunction format_cvs_history($group_id)\n{\n    $res_cvsfullhist = get_cvs_history($group_id);\n\n    if (! $res_cvsfullhist || db_numrows($res_cvsfullhist) < 1) {\n        $output = '<P>' . _('This project has no CVS history.');\n    } else {\n        $cvshist = [];\n        while ($row_cvsfullhist = db_fetch_array($res_cvsfullhist)) {\n            $cvshist[$row_cvsfullhist['user_name']]['full'] = $row_cvsfullhist['commits'];\n            $cvshist[$row_cvsfullhist['user_name']]['last'] = 0;\n        }\n\n      // Now over the last 7 days\n        $res_cvslasthist = get_cvs_history($group_id, 7 * 24 * 3600);\n\n        while ($row_cvslasthist = db_fetch_array($res_cvslasthist)) {\n            $cvshist[$row_cvslasthist['user_name']]['last'] = $row_cvslasthist['commits'];\n        }\n\n      // Format output\n        $output = '<P><b>' . _('Developer Commits (Last 7 days/Total)') . '</b><BR>&nbsp;';\n        foreach ($cvshist as $user => $value) {\n            $output .= '<BR>' . $user . ' (' . $cvshist[$user]['last'] . '/'\n            . $cvshist[$user]['full'] . ')';\n        }\n    }\n    return $output;\n}\n\n\n// list the number of commits by user either since the beginning of\n// history if the period argument is not given or if it is given then\n// over the last \"period\" of time.\n// period is expressed in seconds\nfunction get_cvs_history($group_id, $period = false)\n{\n    $pm    = ProjectManager::instance();\n    $group = $pm->getProject($group_id);\n\n    if ($period) {\n      // All times in cvs tables are stored in UTC ???\n        $date_clause = \"AND co.comm_when >= \" . date(\"YmdHis\", (gmdate('U') - $period)) . \" \";\n    } else {\n        $date_clause = \"\";\n    }\n    $cvs_repository = db_es('/cvsroot/' . $group->getUnixName(false));\n    $query          = \"SELECT u.user_name, count(co.id) as commits \" .\n    \"FROM cvs_commits co, user u, cvs_repositories repo, cvs_checkins ci \" .\n    \"WHERE co.whoid=u.user_id \" .\n    \"AND repo.repository='$cvs_repository' \" .\n    \"AND ci.repositoryid=repo.id \" .\n    \"AND ci.whoid=co.whoid \" .\n    \"AND ci.commitid=co.id \" .\n    $date_clause .\n    \"GROUP BY co.whoid ORDER BY user_name\";\n    $result         = db_query($query);\n    return($result);\n}\n\nfunction get_user_shell($user_id)\n{\n    $user_id  = db_ei($user_id);\n    $res_user = db_query(\"SELECT shell FROM user WHERE user_id=$user_id\");\n    $row_user = db_fetch_array($res_user);\n    return $row_user['shell'];\n}\n\nfunction check_cvs_access($username, $group_name, $cvspath)\n{\n    $pm      = ProjectManager::instance();\n    $project = $pm->getProjectByUnixName($group_name);\n\n  //accept old url containing a .diff at the end of the filename\n    if (strpos($cvspath, '.diff') == (strlen($cvspath) - 5)) {\n        $cvspath = substr($cvspath, 0, (strlen($cvspath) - 5));\n    }\n\n  // if the file path exists as such then it's a directory\n  // else add the ,v extension because it's a file\n    $path = \"/cvsroot/\" . $group_name . '/' . $cvspath;\n    if (! is_dir($path)) {\n        $path = $path . ',v';\n    }\n    $mode = fileperms($path);\n\n  // Also check permissions on top directory (in case of private repo)\n    $mode_top = fileperms(\"/cvsroot/\" . $group_name);\n\n  // A directory that is not world readable can only be viewed\n  // through viewvc if the user is a project member\n    if ($project && (($mode_top & 0x0004) == 0 || ($mode & 0x0004) == 0) && ! user_ismember($project->getID())) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\n\n// Return the group ID from a repository name\n// Repository names look like '/cvsroot/groupname', without trailing slash!\nfunction get_group_id_from_repository($repository)\n{\n    $pm      = ProjectManager::instance();\n    $project = $pm->getProjectByUnixName(basename($repository));\n    if (! $project) {\n        return false;\n    }\n\n    return $project->getID();\n}\n\n/**\n * @psalm-param array<array{order:\"ASC\"|\"DESC\", column: \"id\"|\"revision\"|\"did\"|\"description\"|\"c_when\"|\"date\"|\"f_when\"|\"who\"}> $order_by\n */\nfunction cvs_get_revisions($project, $offset, $chunksz, $_tag = 100, $_branch = 100, $_commit_id = '', $_commiter = 100, $_srch = '', array $order_by = [], $pv = 0)\n{\n    //if status selected, and more to where clause\n    if ($_branch != 100) {\n        //for open tasks, add status=100 to make sure we show all\n        $branch_str = \"AND cvs_checkins.branchid=\" . db_ei($_branch);\n    } else {\n        //no status was chosen, so don't add it to where clause\n        $branch_str = '';\n    }\n\n    //if assigned to selected, and more to where clause\n    if ($_commit_id != '') {\n        $_commit_id = db_ei($_commit_id);\n        $commit_str = \"AND cvs_commits.id=$_commit_id AND cvs_checkins.commitid != 0 \";\n    } else {\n        $commit_str = '';\n    }\n\n    if ($_commiter != 100) {\n        $_commiter    = db_es($_commiter);\n        $commiter_str = \"AND user.user_id=cvs_checkins.whoid \" .\n          \"AND user.user_name='$_commiter' \";\n    } else {\n        //no assigned to was chosen, so don't add it to where clause\n        $commiter_str = '';\n    }\n\n    if ($_srch != '') {\n        $_srch    = db_es('%' . $_srch . '%');\n        $srch_str = \"AND cvs_descs.description like '$_srch' \";\n    } else {\n        $srch_str = \"\";\n    }\n\n    //build page title to make bookmarking easier\n    //if a user was selected, add the user_name to the title\n    //same for status\n\n    //commits_header(array('title'=>'Browse Commits'.\n    //    (($_assigned_to)?' For: '.user_getname($_assigned_to):'').\n    //    (($_tag && ($_tag != 100))?' By Status: '. get_commits_status_nam//e($_status):''),\n    //           'help' => 'CommitsManager.html'));\n\n    // get repository id\n    $cvs_repository = db_es('/cvsroot/' . $project->getUnixName(false));\n    $query          = \"SELECT id from cvs_repositories where cvs_repositories.repository='$cvs_repository' \";\n    $rs             = db_query($query);\n    $repo_id        = db_result($rs, 0, 0);\n    $repo_id        = db_ei($repo_id ? $repo_id : -1);\n\n    $select = 'SELECT distinct cvs_checkins.commitid as id, cvs_checkins.commitid as revision, cvs_descs.id as did, cvs_descs.description, cvs_commits.comm_when as c_when, cvs_commits.comm_when as date, cvs_commits.comm_when as f_when, user.user_name as who ';\n    $from   = \"FROM cvs_descs, cvs_checkins, user, cvs_commits \";\n    $where  = \"WHERE cvs_checkins.descid=cvs_descs.id \" .\n    \"AND \" . db_ei(check_cvs_access(user_getname(), $project->getUnixName(false), '') ? 1 : 0) . \" \" .\n        \"AND cvs_checkins.commitid=cvs_commits.id \" .\n        \"AND user.user_id=cvs_checkins.whoid \" .\n            \"AND cvs_checkins.repositoryid=\" . $repo_id . \" \" .\n        \"$commiter_str \" .\n            \"$commit_str \" .\n        \"$srch_str \" .\n        \"$branch_str \";\n\n    $limit = '';\n    if (! $pv) {\n        $limit = \" LIMIT \" . db_ei($offset) . ',' . db_ei($chunksz);\n    }\n\n    if (empty($order_by)) {\n        $order_by_sql = ' ORDER BY id desc, f_when desc ';\n    } else {\n        $order_by_sql  = ' ORDER BY ';\n        $order_by_sql .= implode(\n            ',',\n            array_map(\n                static function (array $order_by_row) {\n                    return $order_by_row['column'] . ' ' . $order_by_row['order'];\n                },\n                $order_by\n            )\n        );\n        $order_by_sql .= ' ';\n    }\n\n    $sql = $select .\n    $from .\n    $where .\n    $order_by_sql .\n    $limit;\n\n    $result = db_query($sql);\n\n    /* expensive way to have total rows number didn'get a cheaper one */\n\n    $sql1      = $select .\n    $from .\n    $where;\n    $result1   = db_query($sql1);\n    $totalrows = db_numrows($result1);\n\n    return [$result, $totalrows];\n}\n\nfunction cvs_get_revision_detail($commit_id)\n{\n    $commit_id = db_ei($commit_id);\n    $sql       = \"SELECT repository, cvs_commits.comm_when as c_when, repositoryid, description, file, fileid, dir, dirid, type, branch, revision, addedlines, removedlines \" .\n                    \"FROM cvs_dirs, cvs_descs, cvs_files, cvs_checkins, cvs_branches, cvs_repositories, cvs_commits \" .\n                    \"WHERE cvs_checkins.fileid=cvs_files.id \" .\n                    \"   AND cvs_checkins.dirid=cvs_dirs.id \" .\n                    \"   AND cvs_checkins.commitid=cvs_commits.id \" .\n                    \"   AND cvs_checkins.branchid=cvs_branches.id \" .\n                    \"   AND cvs_checkins.descid=cvs_descs.id \" .\n                    \"   AND cvs_checkins.repositoryid=cvs_repositories.id \" .\n                    \"   AND cvs_checkins.commitid=$commit_id \";\n    $result    = db_query($sql);\n    return $result;\n}\n"], "filenames": ["src/www/cvs/commit_utils.php"], "buggy_code_start_loc": [716], "buggy_code_end_loc": [733], "fixing_code_start_loc": [716], "fixing_code_end_loc": [733], "type": "CWE-89", "message": "Tuleap is a Libre and Open Source tool for end to end traceability of application and system developments. In affected versions Tuleap does not sanitize properly user settings when constructing the SQL query to browse and search commits in the CVS repositories. A authenticated malicious user with read access to a CVS repository could execute arbitrary SQL queries. Tuleap instances without an active CVS repositories are not impacted. The following versions contain the fix: Tuleap Community Edition 13.2.99.155, Tuleap Enterprise Edition 13.1-7, and Tuleap Enterprise Edition 13.2-6.", "other": {"cve": {"id": "CVE-2021-43806", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-15T20:15:08.557", "lastModified": "2021-12-21T17:32:29.580", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Tuleap is a Libre and Open Source tool for end to end traceability of application and system developments. In affected versions Tuleap does not sanitize properly user settings when constructing the SQL query to browse and search commits in the CVS repositories. A authenticated malicious user with read access to a CVS repository could execute arbitrary SQL queries. Tuleap instances without an active CVS repositories are not impacted. The following versions contain the fix: Tuleap Community Edition 13.2.99.155, Tuleap Enterprise Edition 13.1-7, and Tuleap Enterprise Edition 13.2-6."}, {"lang": "es", "value": "Tuleap es una herramienta libre y de c\u00f3digo abierto para la trazabilidad de extremo a extremo de los desarrollos de aplicaciones y sistemas. En las versiones afectadas, Tuleap no sanea correctamente la configuraci\u00f3n del usuario cuando construye la consulta SQL para navegar y buscar commits en los repositorios CVS. Un usuario malicioso autenticado con acceso de lectura a un repositorio CVS podr\u00eda ejecutar consultas SQL arbitrarias. Las instancias de Tuleap sin repositorios CVS activos no est\u00e1n afectadas. Las siguientes versiones contienen la correcci\u00f3n: Tuleap Community Edition versi\u00f3n 13.2.99.155, Tuleap Enterprise Edition versi\u00f3n 13.1-7, y Tuleap Enterprise Edition versi\u00f3n 13.2-6"}], "metrics": {"cvssMetricV31": [{"source": "security-advisories@github.com", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:enalean:tuleap:*:*:*:*:community:*:*:*", "versionEndExcluding": "13.2.99.155", "matchCriteriaId": "DA4C134F-B28D-4009-91B1-43C9B908D698"}, {"vulnerable": true, "criteria": "cpe:2.3:a:enalean:tuleap:*:*:*:*:enterprise:*:*:*", "versionStartIncluding": "13.1-1", "versionEndExcluding": "13.1-7", "matchCriteriaId": "391F50C0-C8BC-4F96-B1D0-E6242F6BBB2E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:enalean:tuleap:*:*:*:*:enterprise:*:*:*", "versionStartIncluding": "13.2-1", "versionEndExcluding": "13.2-6", "matchCriteriaId": "98DD6F86-A298-4E2A-B4C2-65E11A70FA3B"}]}]}], "references": [{"url": "https://github.com/Enalean/tuleap/commit/b82be896b00a787ed46a77bd4700e8fccfe2e5ba", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Enalean/tuleap/security/advisories/GHSA-x8fr-8gvw-cc4v", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://tuleap.net/plugins/git/tuleap/tuleap/stable?a=commit&h=b82be896b00a787ed46a77bd4700e8fccfe2e5ba", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://tuleap.net/plugins/tracker/?aid=24202", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/Enalean/tuleap/commit/b82be896b00a787ed46a77bd4700e8fccfe2e5ba"}}