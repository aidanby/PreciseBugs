{"buggy_code": ["/*\n   +----------------------------------------------------------------------+\n   | PHP Version 5                                                        |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 1997-2014 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Authors: The typical suspects                                        |\n   |          Pollita <pollita@php.net>                                   |\n   |          Marcus Boerger <helly@php.net>                              |\n   +----------------------------------------------------------------------+\n */\n\n/* $Id$ */\n\n/* {{{ includes */\n#include \"php.h\"\n#include \"php_network.h\"\n\n#if HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n\n#ifdef PHP_WIN32\n# include \"win32/inet.h\"\n# include <winsock2.h>\n# include <windows.h>\n# include <Ws2tcpip.h>\n#else\t/* This holds good for NetWare too, both for Winsock and Berkeley sockets */\n#include <netinet/in.h>\n#if HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n#include <netdb.h>\n#ifdef _OSD_POSIX\n#undef STATUS\n#undef T_UNSPEC\n#endif\n#if HAVE_ARPA_NAMESER_H\n#ifdef DARWIN\n# define BIND_8_COMPAT 1\n#endif\n#include <arpa/nameser.h>\n#endif\n#if HAVE_RESOLV_H\n#include <resolv.h>\n#endif\n#ifdef HAVE_DNS_H\n#include <dns.h>\n#endif\n#endif\n\n/* Borrowed from SYS/SOCKET.H */\n#if defined(NETWARE) && defined(USE_WINSOCK)\n#define AF_INET 2   /* internetwork: UDP, TCP, etc. */\n#endif\n\n#ifndef MAXHOSTNAMELEN\n#define MAXHOSTNAMELEN 255\n#endif\n\n/* For the local hostname obtained via gethostname which is different from the\n   dns-related MAXHOSTNAMELEN constant above */\n#ifndef HOST_NAME_MAX\n#define HOST_NAME_MAX 255\n#endif\n\n#include \"php_dns.h\"\n\n/* type compat */\n#ifndef DNS_T_A\n#define DNS_T_A\t\t1\n#endif\n#ifndef DNS_T_NS\n#define DNS_T_NS\t2\n#endif\n#ifndef DNS_T_CNAME\n#define DNS_T_CNAME\t5\n#endif\n#ifndef DNS_T_SOA\n#define DNS_T_SOA\t6\n#endif\n#ifndef DNS_T_PTR\n#define DNS_T_PTR\t12\n#endif\n#ifndef DNS_T_HINFO\n#define DNS_T_HINFO\t13\n#endif\n#ifndef DNS_T_MINFO\n#define DNS_T_MINFO\t14\n#endif\n#ifndef DNS_T_MX\n#define DNS_T_MX\t15\n#endif\n#ifndef DNS_T_TXT\n#define DNS_T_TXT\t16\n#endif\n#ifndef DNS_T_AAAA\n#define DNS_T_AAAA\t28\n#endif\n#ifndef DNS_T_SRV\n#define DNS_T_SRV\t33\n#endif\n#ifndef DNS_T_NAPTR\n#define DNS_T_NAPTR\t35\n#endif\n#ifndef DNS_T_A6\n#define DNS_T_A6\t38\n#endif\n\n#ifndef DNS_T_ANY\n#define DNS_T_ANY\t255\n#endif\n/* }}} */\n\nstatic char *php_gethostbyaddr(char *ip);\nstatic char *php_gethostbyname(char *name);\n\n#ifdef HAVE_GETHOSTNAME\n/* {{{ proto string gethostname()\n   Get the host name of the current machine */\nPHP_FUNCTION(gethostname)\n{\n\tchar buf[HOST_NAME_MAX];\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (gethostname(buf, sizeof(buf) - 1)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"unable to fetch host [%d]: %s\", errno, strerror(errno));\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_STRING(buf, 1);\n}\n/* }}} */\n#endif\n\n/* TODO: Reimplement the gethostby* functions using the new winxp+ API, in dns_win32.c, then\n we can have a dns.c, dns_unix.c and dns_win32.c instead of a messy dns.c full of #ifdef\n*/\n\n/* {{{ proto string gethostbyaddr(string ip_address)\n   Get the Internet host name corresponding to a given IP address */\nPHP_FUNCTION(gethostbyaddr)\n{\n\tchar *addr;\n\tint addr_len;\n\tchar *hostname;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &addr, &addr_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\thostname = php_gethostbyaddr(addr);\n\n\tif (hostname == NULL) {\n#if HAVE_IPV6 && HAVE_INET_PTON\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Address is not a valid IPv4 or IPv6 address\");\n#else\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Address is not in a.b.c.d form\");\n#endif\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tRETVAL_STRING(hostname, 0);\n\t}\n}\n/* }}} */\n\n/* {{{ php_gethostbyaddr */\nstatic char *php_gethostbyaddr(char *ip)\n{\n#if HAVE_IPV6 && HAVE_INET_PTON\n\tstruct in6_addr addr6;\n#endif\n\tstruct in_addr addr;\n\tstruct hostent *hp;\n\n#if HAVE_IPV6 && HAVE_INET_PTON\n\tif (inet_pton(AF_INET6, ip, &addr6)) {\n\t\thp = gethostbyaddr((char *) &addr6, sizeof(addr6), AF_INET6);\n\t} else if (inet_pton(AF_INET, ip, &addr)) {\n\t\thp = gethostbyaddr((char *) &addr, sizeof(addr), AF_INET);\n\t} else {\n\t\treturn NULL;\n\t}\n#else\n\taddr.s_addr = inet_addr(ip);\n\n\tif (addr.s_addr == -1) {\n\t\treturn NULL;\n\t}\n\n\thp = gethostbyaddr((char *) &addr, sizeof(addr), AF_INET);\n#endif\n\n\tif (!hp || hp->h_name == NULL || hp->h_name[0] == '\\0') {\n\t\treturn estrdup(ip);\n\t}\n\n\treturn estrdup(hp->h_name);\n}\n/* }}} */\n\n/* {{{ proto string gethostbyname(string hostname)\n   Get the IP address corresponding to a given Internet host name */\nPHP_FUNCTION(gethostbyname)\n{\n\tchar *hostname;\n\tint hostname_len;\n\tchar *addr;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &hostname, &hostname_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\taddr = php_gethostbyname(hostname);\n\n\tRETVAL_STRING(addr, 0);\n}\n/* }}} */\n\n/* {{{ proto array gethostbynamel(string hostname)\n   Return a list of IP addresses that a given hostname resolves to. */\nPHP_FUNCTION(gethostbynamel)\n{\n\tchar *hostname;\n\tint hostname_len;\n\tstruct hostent *hp;\n\tstruct in_addr in;\n\tint i;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &hostname, &hostname_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\thp = gethostbyname(hostname);\n\tif (hp == NULL || hp->h_addr_list == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init(return_value);\n\n\tfor (i = 0 ; hp->h_addr_list[i] != 0 ; i++) {\n\t\tin = *(struct in_addr *) hp->h_addr_list[i];\n\t\tadd_next_index_string(return_value, inet_ntoa(in), 1);\n\t}\n}\n/* }}} */\n\n/* {{{ php_gethostbyname */\nstatic char *php_gethostbyname(char *name)\n{\n\tstruct hostent *hp;\n\tstruct in_addr in;\n\n\thp = gethostbyname(name);\n\n\tif (!hp || !*(hp->h_addr_list)) {\n\t\treturn estrdup(name);\n\t}\n\n\tmemcpy(&in.s_addr, *(hp->h_addr_list), sizeof(in.s_addr));\n\n\treturn estrdup(inet_ntoa(in));\n}\n/* }}} */\n\n#if HAVE_FULL_DNS_FUNCS || defined(PHP_WIN32)\n# define PHP_DNS_NUM_TYPES\t12\t/* Number of DNS Types Supported by PHP currently */\n\n# define PHP_DNS_A      0x00000001\n# define PHP_DNS_NS     0x00000002\n# define PHP_DNS_CNAME  0x00000010\n# define PHP_DNS_SOA    0x00000020\n# define PHP_DNS_PTR    0x00000800\n# define PHP_DNS_HINFO  0x00001000\n# define PHP_DNS_MX     0x00004000\n# define PHP_DNS_TXT    0x00008000\n# define PHP_DNS_A6     0x01000000\n# define PHP_DNS_SRV    0x02000000\n# define PHP_DNS_NAPTR  0x04000000\n# define PHP_DNS_AAAA   0x08000000\n# define PHP_DNS_ANY    0x10000000\n# define PHP_DNS_ALL    (PHP_DNS_A|PHP_DNS_NS|PHP_DNS_CNAME|PHP_DNS_SOA|PHP_DNS_PTR|PHP_DNS_HINFO|PHP_DNS_MX|PHP_DNS_TXT|PHP_DNS_A6|PHP_DNS_SRV|PHP_DNS_NAPTR|PHP_DNS_AAAA)\n#endif /* HAVE_FULL_DNS_FUNCS || defined(PHP_WIN32) */\n\n/* Note: These functions are defined in ext/standard/dns_win32.c for Windows! */\n#if !defined(PHP_WIN32) && (HAVE_DNS_SEARCH_FUNC && !(defined(__BEOS__) || defined(NETWARE)))\n  \n#ifndef HFIXEDSZ\n#define HFIXEDSZ        12      /* fixed data in header <arpa/nameser.h> */\n#endif /* HFIXEDSZ */\n\n#ifndef QFIXEDSZ\n#define QFIXEDSZ        4       /* fixed data in query <arpa/nameser.h> */\n#endif /* QFIXEDSZ */\n\n#undef MAXHOSTNAMELEN\n#define MAXHOSTNAMELEN  1024\n\n#ifndef MAXRESOURCERECORDS\n#define MAXRESOURCERECORDS\t64\n#endif /* MAXRESOURCERECORDS */\n\ntypedef union {\n\tHEADER qb1;\n\tu_char qb2[65536];\n} querybuf;\n\n/* just a hack to free resources allocated by glibc in __res_nsend()\n * See also:\n *   res_thread_freeres() in glibc/resolv/res_init.c\n *   __libc_res_nsend()   in resolv/res_send.c\n * */\n\n#if defined(__GLIBC__) && !defined(HAVE_DEPRECATED_DNS_FUNCS)\n#define php_dns_free_res(__res__) _php_dns_free_res(__res__)\nstatic void _php_dns_free_res(struct __res_state res) { /* {{{ */\n\tint ns;\n\tfor (ns = 0; ns < MAXNS; ns++) {\n\t\tif (res._u._ext.nsaddrs[ns] != NULL) {\n\t\t\tfree (res._u._ext.nsaddrs[ns]);\n\t\t\tres._u._ext.nsaddrs[ns] = NULL;\n\t\t}\n\t}\n} /* }}} */\n#else\n#define php_dns_free_res(__res__)\n#endif\n\n/* {{{ proto bool dns_check_record(string host [, string type])\n   Check DNS records corresponding to a given Internet host name or IP address */\nPHP_FUNCTION(dns_check_record)\n{\n#ifndef MAXPACKET\n#define MAXPACKET  8192 /* max packet size used internally by BIND */\n#endif\n\tu_char ans[MAXPACKET];\n\tchar *hostname, *rectype = NULL;\n\tint hostname_len, rectype_len = 0;\n\tint type = T_MX, i;\n#if defined(HAVE_DNS_SEARCH)\n\tstruct sockaddr_storage from;\n\tuint32_t fromsize = sizeof(from);\n\tdns_handle_t handle;\n#elif defined(HAVE_RES_NSEARCH)\n\tstruct __res_state state;\n\tstruct __res_state *handle = &state;\n#endif\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|s\", &hostname, &hostname_len, &rectype, &rectype_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (hostname_len == 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Host cannot be empty\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (rectype) {\n\t\tif (!strcasecmp(\"A\",     rectype)) type = T_A;\n\t\telse if (!strcasecmp(\"NS\",    rectype)) type = DNS_T_NS;\n\t\telse if (!strcasecmp(\"MX\",    rectype)) type = DNS_T_MX;\n\t\telse if (!strcasecmp(\"PTR\",   rectype)) type = DNS_T_PTR;\n\t\telse if (!strcasecmp(\"ANY\",   rectype)) type = DNS_T_ANY;\n\t\telse if (!strcasecmp(\"SOA\",   rectype)) type = DNS_T_SOA;\n\t\telse if (!strcasecmp(\"TXT\",   rectype)) type = DNS_T_TXT;\n\t\telse if (!strcasecmp(\"CNAME\", rectype)) type = DNS_T_CNAME;\n\t\telse if (!strcasecmp(\"AAAA\",  rectype)) type = DNS_T_AAAA;\n\t\telse if (!strcasecmp(\"SRV\",   rectype)) type = DNS_T_SRV;\n\t\telse if (!strcasecmp(\"NAPTR\", rectype)) type = DNS_T_NAPTR;\n\t\telse if (!strcasecmp(\"A6\",    rectype)) type = DNS_T_A6;\n\t\telse {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Type '%s' not supported\", rectype);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n#if defined(HAVE_DNS_SEARCH)\n\thandle = dns_open(NULL);\n\tif (handle == NULL) {\n\t\tRETURN_FALSE;\n\t}\n#elif defined(HAVE_RES_NSEARCH)\n    memset(&state, 0, sizeof(state));\n    if (res_ninit(handle)) {\n\t\t\tRETURN_FALSE;\n\t}\n#else\n\tres_init();\n#endif\n\n\tRETVAL_TRUE;\n\ti = php_dns_search(handle, hostname, C_IN, type, ans, sizeof(ans));\n\n\tif (i < 0) {\n\t\tRETVAL_FALSE;\n\t}\n\n\tphp_dns_free_handle(handle);\n}\n/* }}} */\n\n#if HAVE_FULL_DNS_FUNCS\n\n/* {{{ php_parserr */\nstatic u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int store, int raw, zval **subarray)\n{\n\tu_short type, class, dlen;\n\tu_long ttl;\n\tlong n, i;\n\tu_short s;\n\tu_char *tp, *p;\n\tchar name[MAXHOSTNAMELEN];\n\tint have_v6_break = 0, in_v6_break = 0;\n\n\t*subarray = NULL;\n\n\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, sizeof(name) - 2);\n\tif (n < 0) {\n\t\treturn NULL;\n\t}\n\tcp += n;\n\n\tGETSHORT(type, cp);\n\tGETSHORT(class, cp);\n\tGETLONG(ttl, cp);\n\tGETSHORT(dlen, cp);\n\tif (type_to_fetch != T_ANY && type != type_to_fetch) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tif (!store) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tALLOC_INIT_ZVAL(*subarray);\n\tarray_init(*subarray);\n\n\tadd_assoc_string(*subarray, \"host\", name, 1);\n\tadd_assoc_string(*subarray, \"class\", \"IN\", 1);\n\tadd_assoc_long(*subarray, \"ttl\", ttl);\n\n\tif (raw) {\n\t\tadd_assoc_long(*subarray, \"type\", type);\n\t\tadd_assoc_stringl(*subarray, \"data\", (char*) cp, (uint) dlen, 1);\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tswitch (type) {\n\t\tcase DNS_T_A:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"A\", 1);\n\t\t\tsnprintf(name, sizeof(name), \"%d.%d.%d.%d\", cp[0], cp[1], cp[2], cp[3]);\n\t\t\tadd_assoc_string(*subarray, \"ip\", name, 1);\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t\tcase DNS_T_MX:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"MX\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\t/* no break; */\n\t\tcase DNS_T_CNAME:\n\t\t\tif (type == DNS_T_CNAME) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"CNAME\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_NS:\n\t\t\tif (type == DNS_T_NS) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"NS\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_PTR:\n\t\t\tif (type == DNS_T_PTR) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"PTR\", 1);\n\t\t\t}\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_HINFO:\n\t\t\t/* See RFC 1010 for values */\n\t\t\tadd_assoc_string(*subarray, \"type\", \"HINFO\", 1);\n\t\t\tn = *cp & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_stringl(*subarray, \"cpu\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = *cp & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_stringl(*subarray, \"os\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\t\t\tbreak;\n\t\tcase DNS_T_TXT:\n\t\t\t{\n\t\t\t\tint ll = 0;\n\t\t\t\tzval *entries = NULL;\n\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"TXT\", 1);\n\t\t\t\ttp = emalloc(dlen + 1);\n\t\t\t\t\n\t\t\t\tMAKE_STD_ZVAL(entries);\n\t\t\t\tarray_init(entries);\n\t\t\t\t\n\t\t\t\twhile (ll < dlen) {\n\t\t\t\t\tn = cp[ll];\n\t\t\t\t\tmemcpy(tp + ll , cp + ll + 1, n);\n\t\t\t\t\tadd_next_index_stringl(entries, cp + ll + 1, n, 1);\n\t\t\t\t\tll = ll + n + 1;\n\t\t\t\t}\n\t\t\t\ttp[dlen] = '\\0';\n\t\t\t\tcp += dlen;\n\n\t\t\t\tadd_assoc_stringl(*subarray, \"txt\", tp, (dlen>0)?dlen - 1:0, 0);\n\t\t\t\tadd_assoc_zval(*subarray, \"entries\", entries);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_T_SOA:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"SOA\", 1);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) -2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"mname\", name, 1);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) -2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"rname\", name, 1);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"serial\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"refresh\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"retry\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"expire\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"minimum-ttl\", n);\n\t\t\tbreak;\n\t\tcase DNS_T_AAAA:\n\t\t\ttp = (u_char*)name;\n\t\t\tfor(i=0; i < 8; i++) {\n\t\t\t\tGETSHORT(s, cp);\n\t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"type\", \"AAAA\", 1);\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_A6:\n\t\t\tp = cp;\n\t\t\tadd_assoc_string(*subarray, \"type\", \"A6\", 1);\n\t\t\tn = ((int)cp[0]) & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_long(*subarray, \"masklen\", n);\n\t\t\ttp = (u_char*)name;\n\t\t\tif (n > 15) {\n\t\t\t\thave_v6_break = 1;\n\t\t\t\tin_v6_break = 1;\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\tif (n % 16 > 8) {\n\t\t\t\t/* Partial short */\n\t\t\t\tif (cp[0] != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\tsprintf((char*)tp, \"%x\", cp[0] & 0xFF);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcp++;\n\t\t\t}\n\t\t\tfor (i = (n + 8) / 16; i < 8; i++) {\n\t\t\t\tGETSHORT(s, cp);\n\t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tif (cp < p + dlen) {\n\t\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\t\tif (n < 0) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tcp += n;\n\t\t\t\tadd_assoc_string(*subarray, \"chain\", name, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_T_SRV:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"SRV\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"weight\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"port\", n);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_NAPTR:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"NAPTR\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"order\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pref\", n);\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"flags\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"services\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"regex\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"replacement\", name, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzval_ptr_dtor(subarray);\n\t\t\t*subarray = NULL;\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t}\n\n\treturn cp;\n}\n/* }}} */\n\n/* {{{ proto array|false dns_get_record(string hostname [, int type[, array authns, array addtl]])\n   Get any Resource Record corresponding to a given Internet host name */\nPHP_FUNCTION(dns_get_record)\n{\n\tchar *hostname;\n\tint hostname_len;\n\tlong type_param = PHP_DNS_ANY;\n\tzval *authns = NULL, *addtl = NULL;\n\tint type_to_fetch;\n#if defined(HAVE_DNS_SEARCH)\n\tstruct sockaddr_storage from;\n\tuint32_t fromsize = sizeof(from);\n\tdns_handle_t handle;\n#elif defined(HAVE_RES_NSEARCH)\n\tstruct __res_state state;\n\tstruct __res_state *handle = &state;\n#endif\n\tHEADER *hp;\n\tquerybuf answer;\n\tu_char *cp = NULL, *end = NULL;\n\tint n, qd, an, ns = 0, ar = 0;\n\tint type, first_query = 1, store_results = 1;\n\tzend_bool raw = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|lz!z!b\",\n\t\t\t&hostname, &hostname_len, &type_param, &authns, &addtl, &raw) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (authns) {\n\t\tzval_dtor(authns);\n\t\tarray_init(authns);\n\t}\n\tif (addtl) {\n\t\tzval_dtor(addtl);\n\t\tarray_init(addtl);\n\t}\n\n\tif (!raw) {\n\t\tif ((type_param & ~PHP_DNS_ALL) && (type_param != PHP_DNS_ANY)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Type '%ld' not supported\", type_param);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tif ((type_param < 1) || (type_param > 0xFFFF)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\n\t\t\t\t\"Numeric DNS record type must be between 1 and 65535, '%ld' given\", type_param);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\t/* Initialize the return array */\n\tarray_init(return_value);\n\n\t/* - We emulate an or'ed type mask by querying type by type. (Steps 0 - NUMTYPES-1 )\n\t *   If additional info is wanted we check again with DNS_T_ANY (step NUMTYPES / NUMTYPES+1 )\n\t *   store_results is used to skip storing the results retrieved in step\n\t *   NUMTYPES+1 when results were already fetched.\n\t * - In case of PHP_DNS_ANY we use the directly fetch DNS_T_ANY. (step NUMTYPES+1 )\n\t * - In case of raw mode, we query only the requestd type instead of looping type by type\n\t *   before going with the additional info stuff.\n\t */\n\n\tif (raw) {\n\t\ttype = -1;\n\t} else if (type_param == PHP_DNS_ANY) {\n\t\ttype = PHP_DNS_NUM_TYPES + 1;\n\t} else {\n\t\ttype = 0;\n\t}\n\n\tfor ( ;\n\t\ttype < (addtl ? (PHP_DNS_NUM_TYPES + 2) : PHP_DNS_NUM_TYPES) || first_query;\n\t\ttype++\n\t) {\n\t\tfirst_query = 0;\n\t\tswitch (type) {\n\t\t\tcase -1: /* raw */\n\t\t\t\ttype_to_fetch = type_param;\n\t\t\t\t/* skip over the rest and go directly to additional records */\n\t\t\t\ttype = PHP_DNS_NUM_TYPES - 1;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_A     ? DNS_T_A     : 0;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_NS    ? DNS_T_NS    : 0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_CNAME ? DNS_T_CNAME : 0;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_SOA   ? DNS_T_SOA   : 0;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_PTR   ? DNS_T_PTR   : 0;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_HINFO ? DNS_T_HINFO : 0;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_MX    ? DNS_T_MX    : 0;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_TXT   ? DNS_T_TXT   : 0;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_AAAA\t ? DNS_T_AAAA  : 0;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_SRV   ? DNS_T_SRV   : 0;\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_NAPTR ? DNS_T_NAPTR : 0;\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_A6\t ? DNS_T_A6 : 0;\n\t\t\t\tbreak;\n\t\t\tcase PHP_DNS_NUM_TYPES:\n\t\t\t\tstore_results = 0;\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\tcase (PHP_DNS_NUM_TYPES + 1):\n\t\t\t\ttype_to_fetch = DNS_T_ANY;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (type_to_fetch) {\n#if defined(HAVE_DNS_SEARCH)\n\t\t\thandle = dns_open(NULL);\n\t\t\tif (handle == NULL) {\n\t\t\t\tzval_dtor(return_value);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n#elif defined(HAVE_RES_NSEARCH)\n\t\t    memset(&state, 0, sizeof(state));\n\t\t    if (res_ninit(handle)) {\n\t\t    \tzval_dtor(return_value);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n#else\n\t\t\tres_init();\n#endif\n\n\t\t\tn = php_dns_search(handle, hostname, C_IN, type_to_fetch, answer.qb2, sizeof answer);\n\n\t\t\tif (n < 0) {\n\t\t\t\tphp_dns_free_handle(handle);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcp = answer.qb2 + HFIXEDSZ;\n\t\t\tend = answer.qb2 + n;\n\t\t\thp = (HEADER *)&answer;\n\t\t\tqd = ntohs(hp->qdcount);\n\t\t\tan = ntohs(hp->ancount);\n\t\t\tns = ntohs(hp->nscount);\n\t\t\tar = ntohs(hp->arcount);\n\n\t\t\t/* Skip QD entries, they're only used by dn_expand later on */\n\t\t\twhile (qd-- > 0) {\n\t\t\t\tn = dn_skipname(cp, end);\n\t\t\t\tif (n < 0) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to parse DNS data received\");\n\t\t\t\t\tzval_dtor(return_value);\n\t\t\t\t\tphp_dns_free_handle(handle);\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t\tcp += n + QFIXEDSZ;\n\t\t\t}\n\n\t\t\t/* YAY! Our real answers! */\n\t\t\twhile (an-- && cp && cp < end) {\n\t\t\t\tzval *retval;\n\n\t\t\t\tcp = php_parserr(cp, &answer, type_to_fetch, store_results, raw, &retval);\n\t\t\t\tif (retval != NULL && store_results) {\n\t\t\t\t\tadd_next_index_zval(return_value, retval);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (authns || addtl) {\n\t\t\t\t/* List of Authoritative Name Servers\n\t\t\t\t * Process when only requesting addtl so that we can skip through the section\n\t\t\t\t */\n\t\t\t\twhile (ns-- > 0 && cp && cp < end) {\n\t\t\t\t\tzval *retval = NULL;\n\n\t\t\t\t\tcp = php_parserr(cp, &answer, DNS_T_ANY, authns != NULL, raw, &retval);\n\t\t\t\t\tif (retval != NULL) {\n\t\t\t\t\t\tadd_next_index_zval(authns, retval);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (addtl) {\n\t\t\t\t/* Additional records associated with authoritative name servers */\n\t\t\t\twhile (ar-- > 0 && cp && cp < end) {\n\t\t\t\t\tzval *retval = NULL;\n\n\t\t\t\t\tcp = php_parserr(cp, &answer, DNS_T_ANY, 1, raw, &retval);\n\t\t\t\t\tif (retval != NULL) {\n\t\t\t\t\t\tadd_next_index_zval(addtl, retval);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tphp_dns_free_handle(handle);\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool dns_get_mx(string hostname, array mxhosts [, array weight])\n   Get MX records corresponding to a given Internet host name */\nPHP_FUNCTION(dns_get_mx)\n{\n\tchar *hostname;\n\tint hostname_len;\n\tzval *mx_list, *weight_list = NULL;\n\tint count, qdc;\n\tu_short type, weight;\n\tu_char ans[MAXPACKET];\n\tchar buf[MAXHOSTNAMELEN];\n\tHEADER *hp;\n\tu_char *cp, *end;\n\tint i;\n#if defined(HAVE_DNS_SEARCH)\n\tstruct sockaddr_storage from;\n\tuint32_t fromsize = sizeof(from);\n\tdns_handle_t handle;\n#elif defined(HAVE_RES_NSEARCH)\n\tstruct __res_state state;\n\tstruct __res_state *handle = &state;\n#endif\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sz|z\", &hostname, &hostname_len, &mx_list, &weight_list) == FAILURE) {\n\t\treturn;\n\t}\n\n\tzval_dtor(mx_list);\n\tarray_init(mx_list);\n\n\tif (weight_list) {\n\t\tzval_dtor(weight_list);\n\t\tarray_init(weight_list);\n\t}\n\n#if defined(HAVE_DNS_SEARCH)\n\thandle = dns_open(NULL);\n\tif (handle == NULL) {\n\t\tRETURN_FALSE;\n\t}\n#elif defined(HAVE_RES_NSEARCH)\n    memset(&state, 0, sizeof(state));\n    if (res_ninit(handle)) {\n\t\t\tRETURN_FALSE;\n\t}\n#else\n\tres_init();\n#endif\n\n\ti = php_dns_search(handle, hostname, C_IN, DNS_T_MX, (u_char *)&ans, sizeof(ans));\n\tif (i < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tif (i > (int)sizeof(ans)) {\n\t\ti = sizeof(ans);\n\t}\n\thp = (HEADER *)&ans;\n\tcp = (u_char *)&ans + HFIXEDSZ;\n\tend = (u_char *)&ans +i;\n\tfor (qdc = ntohs((unsigned short)hp->qdcount); qdc--; cp += i + QFIXEDSZ) {\n\t\tif ((i = dn_skipname(cp, end)) < 0 ) {\n\t\t\tphp_dns_free_handle(handle);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\tcount = ntohs((unsigned short)hp->ancount);\n\twhile (--count >= 0 && cp < end) {\n\t\tif ((i = dn_skipname(cp, end)) < 0 ) {\n\t\t\tphp_dns_free_handle(handle);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tcp += i;\n\t\tGETSHORT(type, cp);\n\t\tcp += INT16SZ + INT32SZ;\n\t\tGETSHORT(i, cp);\n\t\tif (type != DNS_T_MX) {\n\t\t\tcp += i;\n\t\t\tcontinue;\n\t\t}\n\t\tGETSHORT(weight, cp);\n\t\tif ((i = dn_expand(ans, end, cp, buf, sizeof(buf)-1)) < 0) {\n\t\t\tphp_dns_free_handle(handle);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tcp += i;\n\t\tadd_next_index_string(mx_list, buf, 1);\n\t\tif (weight_list) {\n\t\t\tadd_next_index_long(weight_list, weight);\n\t\t}\n\t}\n\tphp_dns_free_handle(handle);\n\tRETURN_TRUE;\n}\n/* }}} */\n#endif /* HAVE_FULL_DNS_FUNCS */\n#endif /* !defined(PHP_WIN32) && (HAVE_DNS_SEARCH_FUNC && !(defined(__BEOS__) || defined(NETWARE))) */\n\n#if HAVE_FULL_DNS_FUNCS || defined(PHP_WIN32)\nPHP_MINIT_FUNCTION(dns) {\n\tREGISTER_LONG_CONSTANT(\"DNS_A\",     PHP_DNS_A,     CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_NS\",    PHP_DNS_NS,    CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_CNAME\", PHP_DNS_CNAME, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_SOA\",   PHP_DNS_SOA,   CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_PTR\",   PHP_DNS_PTR,   CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_HINFO\", PHP_DNS_HINFO, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_MX\",    PHP_DNS_MX,    CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_TXT\",   PHP_DNS_TXT,   CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_SRV\",   PHP_DNS_SRV,   CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_NAPTR\", PHP_DNS_NAPTR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_AAAA\",  PHP_DNS_AAAA,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_A6\",    PHP_DNS_A6,    CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_ANY\",   PHP_DNS_ANY,   CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_ALL\",   PHP_DNS_ALL,   CONST_CS | CONST_PERSISTENT);\n\treturn SUCCESS;\n}\n#endif /* HAVE_FULL_DNS_FUNCS */\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: sw=4 ts=4 fdm=marker\n * vim<600: sw=4 ts=4\n */\n"], "fixing_code": ["/*\n   +----------------------------------------------------------------------+\n   | PHP Version 5                                                        |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 1997-2014 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Authors: The typical suspects                                        |\n   |          Pollita <pollita@php.net>                                   |\n   |          Marcus Boerger <helly@php.net>                              |\n   +----------------------------------------------------------------------+\n */\n\n/* $Id$ */\n\n/* {{{ includes */\n#include \"php.h\"\n#include \"php_network.h\"\n\n#if HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n\n#ifdef PHP_WIN32\n# include \"win32/inet.h\"\n# include <winsock2.h>\n# include <windows.h>\n# include <Ws2tcpip.h>\n#else\t/* This holds good for NetWare too, both for Winsock and Berkeley sockets */\n#include <netinet/in.h>\n#if HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n#include <netdb.h>\n#ifdef _OSD_POSIX\n#undef STATUS\n#undef T_UNSPEC\n#endif\n#if HAVE_ARPA_NAMESER_H\n#ifdef DARWIN\n# define BIND_8_COMPAT 1\n#endif\n#include <arpa/nameser.h>\n#endif\n#if HAVE_RESOLV_H\n#include <resolv.h>\n#endif\n#ifdef HAVE_DNS_H\n#include <dns.h>\n#endif\n#endif\n\n/* Borrowed from SYS/SOCKET.H */\n#if defined(NETWARE) && defined(USE_WINSOCK)\n#define AF_INET 2   /* internetwork: UDP, TCP, etc. */\n#endif\n\n#ifndef MAXHOSTNAMELEN\n#define MAXHOSTNAMELEN 255\n#endif\n\n/* For the local hostname obtained via gethostname which is different from the\n   dns-related MAXHOSTNAMELEN constant above */\n#ifndef HOST_NAME_MAX\n#define HOST_NAME_MAX 255\n#endif\n\n#include \"php_dns.h\"\n\n/* type compat */\n#ifndef DNS_T_A\n#define DNS_T_A\t\t1\n#endif\n#ifndef DNS_T_NS\n#define DNS_T_NS\t2\n#endif\n#ifndef DNS_T_CNAME\n#define DNS_T_CNAME\t5\n#endif\n#ifndef DNS_T_SOA\n#define DNS_T_SOA\t6\n#endif\n#ifndef DNS_T_PTR\n#define DNS_T_PTR\t12\n#endif\n#ifndef DNS_T_HINFO\n#define DNS_T_HINFO\t13\n#endif\n#ifndef DNS_T_MINFO\n#define DNS_T_MINFO\t14\n#endif\n#ifndef DNS_T_MX\n#define DNS_T_MX\t15\n#endif\n#ifndef DNS_T_TXT\n#define DNS_T_TXT\t16\n#endif\n#ifndef DNS_T_AAAA\n#define DNS_T_AAAA\t28\n#endif\n#ifndef DNS_T_SRV\n#define DNS_T_SRV\t33\n#endif\n#ifndef DNS_T_NAPTR\n#define DNS_T_NAPTR\t35\n#endif\n#ifndef DNS_T_A6\n#define DNS_T_A6\t38\n#endif\n\n#ifndef DNS_T_ANY\n#define DNS_T_ANY\t255\n#endif\n/* }}} */\n\nstatic char *php_gethostbyaddr(char *ip);\nstatic char *php_gethostbyname(char *name);\n\n#ifdef HAVE_GETHOSTNAME\n/* {{{ proto string gethostname()\n   Get the host name of the current machine */\nPHP_FUNCTION(gethostname)\n{\n\tchar buf[HOST_NAME_MAX];\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (gethostname(buf, sizeof(buf) - 1)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"unable to fetch host [%d]: %s\", errno, strerror(errno));\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_STRING(buf, 1);\n}\n/* }}} */\n#endif\n\n/* TODO: Reimplement the gethostby* functions using the new winxp+ API, in dns_win32.c, then\n we can have a dns.c, dns_unix.c and dns_win32.c instead of a messy dns.c full of #ifdef\n*/\n\n/* {{{ proto string gethostbyaddr(string ip_address)\n   Get the Internet host name corresponding to a given IP address */\nPHP_FUNCTION(gethostbyaddr)\n{\n\tchar *addr;\n\tint addr_len;\n\tchar *hostname;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &addr, &addr_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\thostname = php_gethostbyaddr(addr);\n\n\tif (hostname == NULL) {\n#if HAVE_IPV6 && HAVE_INET_PTON\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Address is not a valid IPv4 or IPv6 address\");\n#else\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Address is not in a.b.c.d form\");\n#endif\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tRETVAL_STRING(hostname, 0);\n\t}\n}\n/* }}} */\n\n/* {{{ php_gethostbyaddr */\nstatic char *php_gethostbyaddr(char *ip)\n{\n#if HAVE_IPV6 && HAVE_INET_PTON\n\tstruct in6_addr addr6;\n#endif\n\tstruct in_addr addr;\n\tstruct hostent *hp;\n\n#if HAVE_IPV6 && HAVE_INET_PTON\n\tif (inet_pton(AF_INET6, ip, &addr6)) {\n\t\thp = gethostbyaddr((char *) &addr6, sizeof(addr6), AF_INET6);\n\t} else if (inet_pton(AF_INET, ip, &addr)) {\n\t\thp = gethostbyaddr((char *) &addr, sizeof(addr), AF_INET);\n\t} else {\n\t\treturn NULL;\n\t}\n#else\n\taddr.s_addr = inet_addr(ip);\n\n\tif (addr.s_addr == -1) {\n\t\treturn NULL;\n\t}\n\n\thp = gethostbyaddr((char *) &addr, sizeof(addr), AF_INET);\n#endif\n\n\tif (!hp || hp->h_name == NULL || hp->h_name[0] == '\\0') {\n\t\treturn estrdup(ip);\n\t}\n\n\treturn estrdup(hp->h_name);\n}\n/* }}} */\n\n/* {{{ proto string gethostbyname(string hostname)\n   Get the IP address corresponding to a given Internet host name */\nPHP_FUNCTION(gethostbyname)\n{\n\tchar *hostname;\n\tint hostname_len;\n\tchar *addr;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &hostname, &hostname_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\taddr = php_gethostbyname(hostname);\n\n\tRETVAL_STRING(addr, 0);\n}\n/* }}} */\n\n/* {{{ proto array gethostbynamel(string hostname)\n   Return a list of IP addresses that a given hostname resolves to. */\nPHP_FUNCTION(gethostbynamel)\n{\n\tchar *hostname;\n\tint hostname_len;\n\tstruct hostent *hp;\n\tstruct in_addr in;\n\tint i;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &hostname, &hostname_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\thp = gethostbyname(hostname);\n\tif (hp == NULL || hp->h_addr_list == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init(return_value);\n\n\tfor (i = 0 ; hp->h_addr_list[i] != 0 ; i++) {\n\t\tin = *(struct in_addr *) hp->h_addr_list[i];\n\t\tadd_next_index_string(return_value, inet_ntoa(in), 1);\n\t}\n}\n/* }}} */\n\n/* {{{ php_gethostbyname */\nstatic char *php_gethostbyname(char *name)\n{\n\tstruct hostent *hp;\n\tstruct in_addr in;\n\n\thp = gethostbyname(name);\n\n\tif (!hp || !*(hp->h_addr_list)) {\n\t\treturn estrdup(name);\n\t}\n\n\tmemcpy(&in.s_addr, *(hp->h_addr_list), sizeof(in.s_addr));\n\n\treturn estrdup(inet_ntoa(in));\n}\n/* }}} */\n\n#if HAVE_FULL_DNS_FUNCS || defined(PHP_WIN32)\n# define PHP_DNS_NUM_TYPES\t12\t/* Number of DNS Types Supported by PHP currently */\n\n# define PHP_DNS_A      0x00000001\n# define PHP_DNS_NS     0x00000002\n# define PHP_DNS_CNAME  0x00000010\n# define PHP_DNS_SOA    0x00000020\n# define PHP_DNS_PTR    0x00000800\n# define PHP_DNS_HINFO  0x00001000\n# define PHP_DNS_MX     0x00004000\n# define PHP_DNS_TXT    0x00008000\n# define PHP_DNS_A6     0x01000000\n# define PHP_DNS_SRV    0x02000000\n# define PHP_DNS_NAPTR  0x04000000\n# define PHP_DNS_AAAA   0x08000000\n# define PHP_DNS_ANY    0x10000000\n# define PHP_DNS_ALL    (PHP_DNS_A|PHP_DNS_NS|PHP_DNS_CNAME|PHP_DNS_SOA|PHP_DNS_PTR|PHP_DNS_HINFO|PHP_DNS_MX|PHP_DNS_TXT|PHP_DNS_A6|PHP_DNS_SRV|PHP_DNS_NAPTR|PHP_DNS_AAAA)\n#endif /* HAVE_FULL_DNS_FUNCS || defined(PHP_WIN32) */\n\n/* Note: These functions are defined in ext/standard/dns_win32.c for Windows! */\n#if !defined(PHP_WIN32) && (HAVE_DNS_SEARCH_FUNC && !(defined(__BEOS__) || defined(NETWARE)))\n  \n#ifndef HFIXEDSZ\n#define HFIXEDSZ        12      /* fixed data in header <arpa/nameser.h> */\n#endif /* HFIXEDSZ */\n\n#ifndef QFIXEDSZ\n#define QFIXEDSZ        4       /* fixed data in query <arpa/nameser.h> */\n#endif /* QFIXEDSZ */\n\n#undef MAXHOSTNAMELEN\n#define MAXHOSTNAMELEN  1024\n\n#ifndef MAXRESOURCERECORDS\n#define MAXRESOURCERECORDS\t64\n#endif /* MAXRESOURCERECORDS */\n\ntypedef union {\n\tHEADER qb1;\n\tu_char qb2[65536];\n} querybuf;\n\n/* just a hack to free resources allocated by glibc in __res_nsend()\n * See also:\n *   res_thread_freeres() in glibc/resolv/res_init.c\n *   __libc_res_nsend()   in resolv/res_send.c\n * */\n\n#if defined(__GLIBC__) && !defined(HAVE_DEPRECATED_DNS_FUNCS)\n#define php_dns_free_res(__res__) _php_dns_free_res(__res__)\nstatic void _php_dns_free_res(struct __res_state res) { /* {{{ */\n\tint ns;\n\tfor (ns = 0; ns < MAXNS; ns++) {\n\t\tif (res._u._ext.nsaddrs[ns] != NULL) {\n\t\t\tfree (res._u._ext.nsaddrs[ns]);\n\t\t\tres._u._ext.nsaddrs[ns] = NULL;\n\t\t}\n\t}\n} /* }}} */\n#else\n#define php_dns_free_res(__res__)\n#endif\n\n/* {{{ proto bool dns_check_record(string host [, string type])\n   Check DNS records corresponding to a given Internet host name or IP address */\nPHP_FUNCTION(dns_check_record)\n{\n#ifndef MAXPACKET\n#define MAXPACKET  8192 /* max packet size used internally by BIND */\n#endif\n\tu_char ans[MAXPACKET];\n\tchar *hostname, *rectype = NULL;\n\tint hostname_len, rectype_len = 0;\n\tint type = T_MX, i;\n#if defined(HAVE_DNS_SEARCH)\n\tstruct sockaddr_storage from;\n\tuint32_t fromsize = sizeof(from);\n\tdns_handle_t handle;\n#elif defined(HAVE_RES_NSEARCH)\n\tstruct __res_state state;\n\tstruct __res_state *handle = &state;\n#endif\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|s\", &hostname, &hostname_len, &rectype, &rectype_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (hostname_len == 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Host cannot be empty\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (rectype) {\n\t\tif (!strcasecmp(\"A\",     rectype)) type = T_A;\n\t\telse if (!strcasecmp(\"NS\",    rectype)) type = DNS_T_NS;\n\t\telse if (!strcasecmp(\"MX\",    rectype)) type = DNS_T_MX;\n\t\telse if (!strcasecmp(\"PTR\",   rectype)) type = DNS_T_PTR;\n\t\telse if (!strcasecmp(\"ANY\",   rectype)) type = DNS_T_ANY;\n\t\telse if (!strcasecmp(\"SOA\",   rectype)) type = DNS_T_SOA;\n\t\telse if (!strcasecmp(\"TXT\",   rectype)) type = DNS_T_TXT;\n\t\telse if (!strcasecmp(\"CNAME\", rectype)) type = DNS_T_CNAME;\n\t\telse if (!strcasecmp(\"AAAA\",  rectype)) type = DNS_T_AAAA;\n\t\telse if (!strcasecmp(\"SRV\",   rectype)) type = DNS_T_SRV;\n\t\telse if (!strcasecmp(\"NAPTR\", rectype)) type = DNS_T_NAPTR;\n\t\telse if (!strcasecmp(\"A6\",    rectype)) type = DNS_T_A6;\n\t\telse {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Type '%s' not supported\", rectype);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n#if defined(HAVE_DNS_SEARCH)\n\thandle = dns_open(NULL);\n\tif (handle == NULL) {\n\t\tRETURN_FALSE;\n\t}\n#elif defined(HAVE_RES_NSEARCH)\n    memset(&state, 0, sizeof(state));\n    if (res_ninit(handle)) {\n\t\t\tRETURN_FALSE;\n\t}\n#else\n\tres_init();\n#endif\n\n\tRETVAL_TRUE;\n\ti = php_dns_search(handle, hostname, C_IN, type, ans, sizeof(ans));\n\n\tif (i < 0) {\n\t\tRETVAL_FALSE;\n\t}\n\n\tphp_dns_free_handle(handle);\n}\n/* }}} */\n\n#if HAVE_FULL_DNS_FUNCS\n\n/* {{{ php_parserr */\nstatic u_char *php_parserr(u_char *cp, querybuf *answer, int type_to_fetch, int store, int raw, zval **subarray)\n{\n\tu_short type, class, dlen;\n\tu_long ttl;\n\tlong n, i;\n\tu_short s;\n\tu_char *tp, *p;\n\tchar name[MAXHOSTNAMELEN];\n\tint have_v6_break = 0, in_v6_break = 0;\n\n\t*subarray = NULL;\n\n\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, sizeof(name) - 2);\n\tif (n < 0) {\n\t\treturn NULL;\n\t}\n\tcp += n;\n\n\tGETSHORT(type, cp);\n\tGETSHORT(class, cp);\n\tGETLONG(ttl, cp);\n\tGETSHORT(dlen, cp);\n\tif (type_to_fetch != T_ANY && type != type_to_fetch) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tif (!store) {\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tALLOC_INIT_ZVAL(*subarray);\n\tarray_init(*subarray);\n\n\tadd_assoc_string(*subarray, \"host\", name, 1);\n\tadd_assoc_string(*subarray, \"class\", \"IN\", 1);\n\tadd_assoc_long(*subarray, \"ttl\", ttl);\n\n\tif (raw) {\n\t\tadd_assoc_long(*subarray, \"type\", type);\n\t\tadd_assoc_stringl(*subarray, \"data\", (char*) cp, (uint) dlen, 1);\n\t\tcp += dlen;\n\t\treturn cp;\n\t}\n\n\tswitch (type) {\n\t\tcase DNS_T_A:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"A\", 1);\n\t\t\tsnprintf(name, sizeof(name), \"%d.%d.%d.%d\", cp[0], cp[1], cp[2], cp[3]);\n\t\t\tadd_assoc_string(*subarray, \"ip\", name, 1);\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t\tcase DNS_T_MX:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"MX\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\t/* no break; */\n\t\tcase DNS_T_CNAME:\n\t\t\tif (type == DNS_T_CNAME) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"CNAME\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_NS:\n\t\t\tif (type == DNS_T_NS) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"NS\", 1);\n\t\t\t}\n\t\t\t/* no break; */\n\t\tcase DNS_T_PTR:\n\t\t\tif (type == DNS_T_PTR) {\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"PTR\", 1);\n\t\t\t}\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_HINFO:\n\t\t\t/* See RFC 1010 for values */\n\t\t\tadd_assoc_string(*subarray, \"type\", \"HINFO\", 1);\n\t\t\tn = *cp & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_stringl(*subarray, \"cpu\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = *cp & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_stringl(*subarray, \"os\", (char*)cp, n, 1);\n\t\t\tcp += n;\n\t\t\tbreak;\n\t\tcase DNS_T_TXT:\n\t\t\t{\n\t\t\t\tint ll = 0;\n\t\t\t\tzval *entries = NULL;\n\n\t\t\t\tadd_assoc_string(*subarray, \"type\", \"TXT\", 1);\n\t\t\t\ttp = emalloc(dlen + 1);\n\t\t\t\t\n\t\t\t\tMAKE_STD_ZVAL(entries);\n\t\t\t\tarray_init(entries);\n\t\t\t\t\n\t\t\t\twhile (ll < dlen) {\n\t\t\t\t\tn = cp[ll];\n\t\t\t\t\tif ((ll + n) >= dlen) {\n\t\t\t\t\t\t// Invalid chunk length, truncate\n\t\t\t\t\t\tn = dlen - (ll + 1);\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(tp + ll , cp + ll + 1, n);\n\t\t\t\t\tadd_next_index_stringl(entries, cp + ll + 1, n, 1);\n\t\t\t\t\tll = ll + n + 1;\n\t\t\t\t}\n\t\t\t\ttp[dlen] = '\\0';\n\t\t\t\tcp += dlen;\n\n\t\t\t\tadd_assoc_stringl(*subarray, \"txt\", tp, (dlen>0)?dlen - 1:0, 0);\n\t\t\t\tadd_assoc_zval(*subarray, \"entries\", entries);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_T_SOA:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"SOA\", 1);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) -2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"mname\", name, 1);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) -2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"rname\", name, 1);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"serial\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"refresh\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"retry\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"expire\", n);\n\t\t\tGETLONG(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"minimum-ttl\", n);\n\t\t\tbreak;\n\t\tcase DNS_T_AAAA:\n\t\t\ttp = (u_char*)name;\n\t\t\tfor(i=0; i < 8; i++) {\n\t\t\t\tGETSHORT(s, cp);\n\t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"type\", \"AAAA\", 1);\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_A6:\n\t\t\tp = cp;\n\t\t\tadd_assoc_string(*subarray, \"type\", \"A6\", 1);\n\t\t\tn = ((int)cp[0]) & 0xFF;\n\t\t\tcp++;\n\t\t\tadd_assoc_long(*subarray, \"masklen\", n);\n\t\t\ttp = (u_char*)name;\n\t\t\tif (n > 15) {\n\t\t\t\thave_v6_break = 1;\n\t\t\t\tin_v6_break = 1;\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\tif (n % 16 > 8) {\n\t\t\t\t/* Partial short */\n\t\t\t\tif (cp[0] != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\tsprintf((char*)tp, \"%x\", cp[0] & 0xFF);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcp++;\n\t\t\t}\n\t\t\tfor (i = (n + 8) / 16; i < 8; i++) {\n\t\t\t\tGETSHORT(s, cp);\n\t\t\t\tif (s != 0) {\n\t\t\t\t\tif (tp > (u_char *)name) {\n\t\t\t\t\t\tin_v6_break = 0;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t\ttp += sprintf((char*)tp,\"%x\",s);\n\t\t\t\t} else {\n\t\t\t\t\tif (!have_v6_break) {\n\t\t\t\t\t\thave_v6_break = 1;\n\t\t\t\t\t\tin_v6_break = 1;\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t} else if (!in_v6_break) {\n\t\t\t\t\t\ttp[0] = ':';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t\ttp[0] = '0';\n\t\t\t\t\t\ttp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_v6_break && in_v6_break) {\n\t\t\t\ttp[0] = ':';\n\t\t\t\ttp++;\n\t\t\t}\n\t\t\ttp[0] = '\\0';\n\t\t\tadd_assoc_string(*subarray, \"ipv6\", name, 1);\n\t\t\tif (cp < p + dlen) {\n\t\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\t\tif (n < 0) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tcp += n;\n\t\t\t\tadd_assoc_string(*subarray, \"chain\", name, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_T_SRV:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"SRV\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pri\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"weight\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"port\", n);\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"target\", name, 1);\n\t\t\tbreak;\n\t\tcase DNS_T_NAPTR:\n\t\t\tadd_assoc_string(*subarray, \"type\", \"NAPTR\", 1);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"order\", n);\n\t\t\tGETSHORT(n, cp);\n\t\t\tadd_assoc_long(*subarray, \"pref\", n);\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"flags\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"services\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = (cp[0] & 0xFF);\n\t\t\tadd_assoc_stringl(*subarray, \"regex\", (char*)++cp, n, 1);\n\t\t\tcp += n;\n\t\t\tn = dn_expand(answer->qb2, answer->qb2+65536, cp, name, (sizeof name) - 2);\n\t\t\tif (n < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcp += n;\n\t\t\tadd_assoc_string(*subarray, \"replacement\", name, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzval_ptr_dtor(subarray);\n\t\t\t*subarray = NULL;\n\t\t\tcp += dlen;\n\t\t\tbreak;\n\t}\n\n\treturn cp;\n}\n/* }}} */\n\n/* {{{ proto array|false dns_get_record(string hostname [, int type[, array authns, array addtl]])\n   Get any Resource Record corresponding to a given Internet host name */\nPHP_FUNCTION(dns_get_record)\n{\n\tchar *hostname;\n\tint hostname_len;\n\tlong type_param = PHP_DNS_ANY;\n\tzval *authns = NULL, *addtl = NULL;\n\tint type_to_fetch;\n#if defined(HAVE_DNS_SEARCH)\n\tstruct sockaddr_storage from;\n\tuint32_t fromsize = sizeof(from);\n\tdns_handle_t handle;\n#elif defined(HAVE_RES_NSEARCH)\n\tstruct __res_state state;\n\tstruct __res_state *handle = &state;\n#endif\n\tHEADER *hp;\n\tquerybuf answer;\n\tu_char *cp = NULL, *end = NULL;\n\tint n, qd, an, ns = 0, ar = 0;\n\tint type, first_query = 1, store_results = 1;\n\tzend_bool raw = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|lz!z!b\",\n\t\t\t&hostname, &hostname_len, &type_param, &authns, &addtl, &raw) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (authns) {\n\t\tzval_dtor(authns);\n\t\tarray_init(authns);\n\t}\n\tif (addtl) {\n\t\tzval_dtor(addtl);\n\t\tarray_init(addtl);\n\t}\n\n\tif (!raw) {\n\t\tif ((type_param & ~PHP_DNS_ALL) && (type_param != PHP_DNS_ANY)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Type '%ld' not supported\", type_param);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tif ((type_param < 1) || (type_param > 0xFFFF)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\n\t\t\t\t\"Numeric DNS record type must be between 1 and 65535, '%ld' given\", type_param);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\t/* Initialize the return array */\n\tarray_init(return_value);\n\n\t/* - We emulate an or'ed type mask by querying type by type. (Steps 0 - NUMTYPES-1 )\n\t *   If additional info is wanted we check again with DNS_T_ANY (step NUMTYPES / NUMTYPES+1 )\n\t *   store_results is used to skip storing the results retrieved in step\n\t *   NUMTYPES+1 when results were already fetched.\n\t * - In case of PHP_DNS_ANY we use the directly fetch DNS_T_ANY. (step NUMTYPES+1 )\n\t * - In case of raw mode, we query only the requestd type instead of looping type by type\n\t *   before going with the additional info stuff.\n\t */\n\n\tif (raw) {\n\t\ttype = -1;\n\t} else if (type_param == PHP_DNS_ANY) {\n\t\ttype = PHP_DNS_NUM_TYPES + 1;\n\t} else {\n\t\ttype = 0;\n\t}\n\n\tfor ( ;\n\t\ttype < (addtl ? (PHP_DNS_NUM_TYPES + 2) : PHP_DNS_NUM_TYPES) || first_query;\n\t\ttype++\n\t) {\n\t\tfirst_query = 0;\n\t\tswitch (type) {\n\t\t\tcase -1: /* raw */\n\t\t\t\ttype_to_fetch = type_param;\n\t\t\t\t/* skip over the rest and go directly to additional records */\n\t\t\t\ttype = PHP_DNS_NUM_TYPES - 1;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_A     ? DNS_T_A     : 0;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_NS    ? DNS_T_NS    : 0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_CNAME ? DNS_T_CNAME : 0;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_SOA   ? DNS_T_SOA   : 0;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_PTR   ? DNS_T_PTR   : 0;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_HINFO ? DNS_T_HINFO : 0;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_MX    ? DNS_T_MX    : 0;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_TXT   ? DNS_T_TXT   : 0;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_AAAA\t ? DNS_T_AAAA  : 0;\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_SRV   ? DNS_T_SRV   : 0;\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_NAPTR ? DNS_T_NAPTR : 0;\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\ttype_to_fetch = type_param&PHP_DNS_A6\t ? DNS_T_A6 : 0;\n\t\t\t\tbreak;\n\t\t\tcase PHP_DNS_NUM_TYPES:\n\t\t\t\tstore_results = 0;\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\tcase (PHP_DNS_NUM_TYPES + 1):\n\t\t\t\ttype_to_fetch = DNS_T_ANY;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (type_to_fetch) {\n#if defined(HAVE_DNS_SEARCH)\n\t\t\thandle = dns_open(NULL);\n\t\t\tif (handle == NULL) {\n\t\t\t\tzval_dtor(return_value);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n#elif defined(HAVE_RES_NSEARCH)\n\t\t    memset(&state, 0, sizeof(state));\n\t\t    if (res_ninit(handle)) {\n\t\t    \tzval_dtor(return_value);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n#else\n\t\t\tres_init();\n#endif\n\n\t\t\tn = php_dns_search(handle, hostname, C_IN, type_to_fetch, answer.qb2, sizeof answer);\n\n\t\t\tif (n < 0) {\n\t\t\t\tphp_dns_free_handle(handle);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcp = answer.qb2 + HFIXEDSZ;\n\t\t\tend = answer.qb2 + n;\n\t\t\thp = (HEADER *)&answer;\n\t\t\tqd = ntohs(hp->qdcount);\n\t\t\tan = ntohs(hp->ancount);\n\t\t\tns = ntohs(hp->nscount);\n\t\t\tar = ntohs(hp->arcount);\n\n\t\t\t/* Skip QD entries, they're only used by dn_expand later on */\n\t\t\twhile (qd-- > 0) {\n\t\t\t\tn = dn_skipname(cp, end);\n\t\t\t\tif (n < 0) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to parse DNS data received\");\n\t\t\t\t\tzval_dtor(return_value);\n\t\t\t\t\tphp_dns_free_handle(handle);\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t\tcp += n + QFIXEDSZ;\n\t\t\t}\n\n\t\t\t/* YAY! Our real answers! */\n\t\t\twhile (an-- && cp && cp < end) {\n\t\t\t\tzval *retval;\n\n\t\t\t\tcp = php_parserr(cp, &answer, type_to_fetch, store_results, raw, &retval);\n\t\t\t\tif (retval != NULL && store_results) {\n\t\t\t\t\tadd_next_index_zval(return_value, retval);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (authns || addtl) {\n\t\t\t\t/* List of Authoritative Name Servers\n\t\t\t\t * Process when only requesting addtl so that we can skip through the section\n\t\t\t\t */\n\t\t\t\twhile (ns-- > 0 && cp && cp < end) {\n\t\t\t\t\tzval *retval = NULL;\n\n\t\t\t\t\tcp = php_parserr(cp, &answer, DNS_T_ANY, authns != NULL, raw, &retval);\n\t\t\t\t\tif (retval != NULL) {\n\t\t\t\t\t\tadd_next_index_zval(authns, retval);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (addtl) {\n\t\t\t\t/* Additional records associated with authoritative name servers */\n\t\t\t\twhile (ar-- > 0 && cp && cp < end) {\n\t\t\t\t\tzval *retval = NULL;\n\n\t\t\t\t\tcp = php_parserr(cp, &answer, DNS_T_ANY, 1, raw, &retval);\n\t\t\t\t\tif (retval != NULL) {\n\t\t\t\t\t\tadd_next_index_zval(addtl, retval);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tphp_dns_free_handle(handle);\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool dns_get_mx(string hostname, array mxhosts [, array weight])\n   Get MX records corresponding to a given Internet host name */\nPHP_FUNCTION(dns_get_mx)\n{\n\tchar *hostname;\n\tint hostname_len;\n\tzval *mx_list, *weight_list = NULL;\n\tint count, qdc;\n\tu_short type, weight;\n\tu_char ans[MAXPACKET];\n\tchar buf[MAXHOSTNAMELEN];\n\tHEADER *hp;\n\tu_char *cp, *end;\n\tint i;\n#if defined(HAVE_DNS_SEARCH)\n\tstruct sockaddr_storage from;\n\tuint32_t fromsize = sizeof(from);\n\tdns_handle_t handle;\n#elif defined(HAVE_RES_NSEARCH)\n\tstruct __res_state state;\n\tstruct __res_state *handle = &state;\n#endif\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sz|z\", &hostname, &hostname_len, &mx_list, &weight_list) == FAILURE) {\n\t\treturn;\n\t}\n\n\tzval_dtor(mx_list);\n\tarray_init(mx_list);\n\n\tif (weight_list) {\n\t\tzval_dtor(weight_list);\n\t\tarray_init(weight_list);\n\t}\n\n#if defined(HAVE_DNS_SEARCH)\n\thandle = dns_open(NULL);\n\tif (handle == NULL) {\n\t\tRETURN_FALSE;\n\t}\n#elif defined(HAVE_RES_NSEARCH)\n    memset(&state, 0, sizeof(state));\n    if (res_ninit(handle)) {\n\t\t\tRETURN_FALSE;\n\t}\n#else\n\tres_init();\n#endif\n\n\ti = php_dns_search(handle, hostname, C_IN, DNS_T_MX, (u_char *)&ans, sizeof(ans));\n\tif (i < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tif (i > (int)sizeof(ans)) {\n\t\ti = sizeof(ans);\n\t}\n\thp = (HEADER *)&ans;\n\tcp = (u_char *)&ans + HFIXEDSZ;\n\tend = (u_char *)&ans +i;\n\tfor (qdc = ntohs((unsigned short)hp->qdcount); qdc--; cp += i + QFIXEDSZ) {\n\t\tif ((i = dn_skipname(cp, end)) < 0 ) {\n\t\t\tphp_dns_free_handle(handle);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\tcount = ntohs((unsigned short)hp->ancount);\n\twhile (--count >= 0 && cp < end) {\n\t\tif ((i = dn_skipname(cp, end)) < 0 ) {\n\t\t\tphp_dns_free_handle(handle);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tcp += i;\n\t\tGETSHORT(type, cp);\n\t\tcp += INT16SZ + INT32SZ;\n\t\tGETSHORT(i, cp);\n\t\tif (type != DNS_T_MX) {\n\t\t\tcp += i;\n\t\t\tcontinue;\n\t\t}\n\t\tGETSHORT(weight, cp);\n\t\tif ((i = dn_expand(ans, end, cp, buf, sizeof(buf)-1)) < 0) {\n\t\t\tphp_dns_free_handle(handle);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tcp += i;\n\t\tadd_next_index_string(mx_list, buf, 1);\n\t\tif (weight_list) {\n\t\t\tadd_next_index_long(weight_list, weight);\n\t\t}\n\t}\n\tphp_dns_free_handle(handle);\n\tRETURN_TRUE;\n}\n/* }}} */\n#endif /* HAVE_FULL_DNS_FUNCS */\n#endif /* !defined(PHP_WIN32) && (HAVE_DNS_SEARCH_FUNC && !(defined(__BEOS__) || defined(NETWARE))) */\n\n#if HAVE_FULL_DNS_FUNCS || defined(PHP_WIN32)\nPHP_MINIT_FUNCTION(dns) {\n\tREGISTER_LONG_CONSTANT(\"DNS_A\",     PHP_DNS_A,     CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_NS\",    PHP_DNS_NS,    CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_CNAME\", PHP_DNS_CNAME, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_SOA\",   PHP_DNS_SOA,   CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_PTR\",   PHP_DNS_PTR,   CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_HINFO\", PHP_DNS_HINFO, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_MX\",    PHP_DNS_MX,    CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_TXT\",   PHP_DNS_TXT,   CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_SRV\",   PHP_DNS_SRV,   CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_NAPTR\", PHP_DNS_NAPTR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_AAAA\",  PHP_DNS_AAAA,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_A6\",    PHP_DNS_A6,    CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_ANY\",   PHP_DNS_ANY,   CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"DNS_ALL\",   PHP_DNS_ALL,   CONST_CS | CONST_PERSISTENT);\n\treturn SUCCESS;\n}\n#endif /* HAVE_FULL_DNS_FUNCS */\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: sw=4 ts=4 fdm=marker\n * vim<600: sw=4 ts=4\n */\n"], "filenames": ["ext/standard/dns.c"], "buggy_code_start_loc": [519], "buggy_code_end_loc": [519], "fixing_code_start_loc": [520], "fixing_code_end_loc": [524], "type": "CWE-119", "message": "Heap-based buffer overflow in the php_parserr function in ext/standard/dns.c in PHP 5.6.0beta4 and earlier allows remote servers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted DNS TXT record, related to the dns_get_record function.", "other": {"cve": {"id": "CVE-2014-4049", "sourceIdentifier": "cve@mitre.org", "published": "2014-06-18T19:55:05.683", "lastModified": "2022-08-29T20:05:23.073", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap-based buffer overflow in the php_parserr function in ext/standard/dns.c in PHP 5.6.0beta4 and earlier allows remote servers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted DNS TXT record, related to the dns_get_record function."}, {"lang": "es", "value": "Desbordamiento de buffer basado en memoria din\u00e1mica en la funci\u00f3n php_parserr en ext/standard/dns.c en PHP 5.6.0beta4 y anteriores permite a servidores remotos causar una denegaci\u00f3n de servicio (ca\u00edda) y posiblemente ejecutar c\u00f3digo arbitrario a trav\u00e9s de un registro DNS TXT manipulado, relacionado con la funci\u00f3n dns_get_record."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.1}, "baseSeverity": "MEDIUM", "exploitabilityScore": 4.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:11.3:*:*:*:*:*:*:*", "matchCriteriaId": "5646FDE9-CF21-46A9-B89D-F5BBDB4249AF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.3.0", "versionEndExcluding": "5.3.29", "matchCriteriaId": "B61C8E39-DB8E-4636-91E5-2473B0915FBD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.4.0", "versionEndExcluding": "5.4.30", "matchCriteriaId": "AD052020-AA37-4F49-A0FE-EA99616C12C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.5.0", "versionEndExcluding": "5.5.14", "matchCriteriaId": "4ADC6057-9D35-4D87-B15D-F6F52A283464"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.6.0:alpha1:*:*:*:*:*:*", "matchCriteriaId": "5BF4E8FF-A3EC-43E8-A0C1-FD38AFCB77B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.6.0:alpha2:*:*:*:*:*:*", "matchCriteriaId": "54ADECFC-3C07-43BC-B296-6C25AC7F1C95"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.6.0:alpha3:*:*:*:*:*:*", "matchCriteriaId": "FE192054-2FBB-4388-A52A-422E20DEA2D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.6.0:alpha4:*:*:*:*:*:*", "matchCriteriaId": "F0195D48-3B42-4AC0-B9C5-436E01C63879"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.6.0:alpha5:*:*:*:*:*:*", "matchCriteriaId": "BF0E5D67-ABC1-41A5-94E1-7DD3CDB51D81"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.6.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "319E0573-B1AD-40B6-B4BC-8BE67ED3EFDB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.6.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "1A7C00EB-87B7-4EB7-A4AC-8665D8C78467"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:5.6.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "21BFCF10-786A-4D1E-9C37-50A1EC6056F1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://lists.apple.com/archives/security-announce/2015/Apr/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-07/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-07/msg00002.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2014-06/msg00051.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2014-07/msg00032.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://marc.info/?l=bugtraq&m=141017844705317&w=2", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-1765.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-1766.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://secunia.com/advisories/59329", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://secunia.com/advisories/59418", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://secunia.com/advisories/59496", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://secunia.com/advisories/59513", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://secunia.com/advisories/60998", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://support.apple.com/kb/HT6443", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www-01.ibm.com/support/docview.wss?uid=swg21683486", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2014/dsa-2961", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/06/13/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/bulletinjan2015-2370101.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/68007", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1030435", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1108447", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/php/php-src/commit/b34d7849ed90ced9345f8ea1c59bc8d101c18468", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://support.apple.com/HT204659", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/php/php-src/commit/b34d7849ed90ced9345f8ea1c59bc8d101c18468"}}