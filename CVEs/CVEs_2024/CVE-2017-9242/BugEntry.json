{"buggy_code": ["/*\n *\tIPv6 output functions\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tBased on linux/net/ipv4/ip_output.c\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n *\n *\tChanges:\n *\tA.N.Kuznetsov\t:\tairthmetics in fragmentation.\n *\t\t\t\textension headers are implemented.\n *\t\t\t\troute changes now work.\n *\t\t\t\tip6_forward does not confuse sniffers.\n *\t\t\t\tetc.\n *\n *      H. von Brand    :       Added missing #include <linux/string.h>\n *\tImran Patel\t:\tfrag id should be in NBO\n *      Kazunori MIYAZAWA @USAGI\n *\t\t\t:       add ip6_append_data and related functions\n *\t\t\t\tfor datagram xmit\n */\n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/in6.h>\n#include <linux/tcp.h>\n#include <linux/route.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <linux/bpf-cgroup.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv6.h>\n\n#include <net/sock.h>\n#include <net/snmp.h>\n\n#include <net/ipv6.h>\n#include <net/ndisc.h>\n#include <net/protocol.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/rawv6.h>\n#include <net/icmp.h>\n#include <net/xfrm.h>\n#include <net/checksum.h>\n#include <linux/mroute6.h>\n#include <net/l3mdev.h>\n#include <net/lwtunnel.h>\n\nstatic int ip6_finish_output2(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct net_device *dev = dst->dev;\n\tstruct neighbour *neigh;\n\tstruct in6_addr *nexthop;\n\tint ret;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\tskb->dev = dev;\n\n\tif (ipv6_addr_is_multicast(&ipv6_hdr(skb)->daddr)) {\n\t\tstruct inet6_dev *idev = ip6_dst_idev(skb_dst(skb));\n\n\t\tif (!(dev->flags & IFF_LOOPBACK) && sk_mc_loop(sk) &&\n\t\t    ((mroute6_socket(net, skb) &&\n\t\t     !(IP6CB(skb)->flags & IP6SKB_FORWARDED)) ||\n\t\t     ipv6_chk_mcast_addr(dev, &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t &ipv6_hdr(skb)->saddr))) {\n\t\t\tstruct sk_buff *newskb = skb_clone(skb, GFP_ATOMIC);\n\n\t\t\t/* Do not check for IFF_ALLMULTI; multicast routing\n\t\t\t   is not supported in any case.\n\t\t\t */\n\t\t\tif (newskb)\n\t\t\t\tNF_HOOK(NFPROTO_IPV6, NF_INET_POST_ROUTING,\n\t\t\t\t\tnet, sk, newskb, NULL, newskb->dev,\n\t\t\t\t\tdev_loopback_xmit);\n\n\t\t\tif (ipv6_hdr(skb)->hop_limit == 0) {\n\t\t\t\tIP6_INC_STATS(net, idev,\n\t\t\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tIP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_OUTMCAST, skb->len);\n\n\t\tif (IPV6_ADDR_MC_SCOPE(&ipv6_hdr(skb)->daddr) <=\n\t\t    IPV6_ADDR_SCOPE_NODELOCAL &&\n\t\t    !(dev->flags & IFF_LOOPBACK)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (lwtunnel_xmit_redirect(dst->lwtstate)) {\n\t\tint res = lwtunnel_xmit(skb);\n\n\t\tif (res < 0 || res == LWTUNNEL_XMIT_DONE)\n\t\t\treturn res;\n\t}\n\n\trcu_read_lock_bh();\n\tnexthop = rt6_nexthop((struct rt6_info *)dst, &ipv6_hdr(skb)->daddr);\n\tneigh = __ipv6_neigh_lookup_noref(dst->dev, nexthop);\n\tif (unlikely(!neigh))\n\t\tneigh = __neigh_create(&nd_tbl, nexthop, dst->dev, false);\n\tif (!IS_ERR(neigh)) {\n\t\tsock_confirm_neigh(skb, neigh);\n\t\tret = neigh_output(neigh, skb);\n\t\trcu_read_unlock_bh();\n\t\treturn ret;\n\t}\n\trcu_read_unlock_bh();\n\n\tIP6_INC_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_OUTNOROUTES);\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic int ip6_finish_output(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tint ret;\n\n\tret = BPF_CGROUP_RUN_PROG_INET_EGRESS(sk, skb);\n\tif (ret) {\n\t\tkfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tif ((skb->len > ip6_skb_dst_mtu(skb) && !skb_is_gso(skb)) ||\n\t    dst_allfrag(skb_dst(skb)) ||\n\t    (IP6CB(skb)->frag_max_size && skb->len > IP6CB(skb)->frag_max_size))\n\t\treturn ip6_fragment(net, sk, skb, ip6_finish_output2);\n\telse\n\t\treturn ip6_finish_output2(net, sk, skb);\n}\n\nint ip6_output(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb_dst(skb)->dev;\n\tstruct inet6_dev *idev = ip6_dst_idev(skb_dst(skb));\n\n\tif (unlikely(idev->cnf.disable_ipv6)) {\n\t\tIP6_INC_STATS(net, idev, IPSTATS_MIB_OUTDISCARDS);\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\treturn NF_HOOK_COND(NFPROTO_IPV6, NF_INET_POST_ROUTING,\n\t\t\t    net, sk, skb, NULL, dev,\n\t\t\t    ip6_finish_output,\n\t\t\t    !(IP6CB(skb)->flags & IP6SKB_REROUTED));\n}\n\n/*\n * xmit an sk_buff (used by TCP, SCTP and DCCP)\n * Note : socket lock is not held for SYNACK packets, but might be modified\n * by calls to skb_set_owner_w() and ipv6_local_error(),\n * which are using proper atomic operations or spinlocks.\n */\nint ip6_xmit(const struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6,\n\t     __u32 mark, struct ipv6_txoptions *opt, int tclass)\n{\n\tstruct net *net = sock_net(sk);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *first_hop = &fl6->daddr;\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct ipv6hdr *hdr;\n\tu8  proto = fl6->flowi6_proto;\n\tint seg_len = skb->len;\n\tint hlimit = -1;\n\tu32 mtu;\n\n\tif (opt) {\n\t\tunsigned int head_room;\n\n\t\t/* First: exthdrs may take lots of space (~8K for now)\n\t\t   MAX_HEADER is not enough.\n\t\t */\n\t\thead_room = opt->opt_nflen + opt->opt_flen;\n\t\tseg_len += head_room;\n\t\thead_room += sizeof(struct ipv6hdr) + LL_RESERVED_SPACE(dst->dev);\n\n\t\tif (skb_headroom(skb) < head_room) {\n\t\t\tstruct sk_buff *skb2 = skb_realloc_headroom(skb, head_room);\n\t\t\tif (!skb2) {\n\t\t\t\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn -ENOBUFS;\n\t\t\t}\n\t\t\tconsume_skb(skb);\n\t\t\tskb = skb2;\n\t\t\t/* skb_set_owner_w() changes sk->sk_wmem_alloc atomically,\n\t\t\t * it is safe to call in our context (socket lock not held)\n\t\t\t */\n\t\t\tskb_set_owner_w(skb, (struct sock *)sk);\n\t\t}\n\t\tif (opt->opt_flen)\n\t\t\tipv6_push_frag_opts(skb, opt, &proto);\n\t\tif (opt->opt_nflen)\n\t\t\tipv6_push_nfrag_opts(skb, opt, &proto, &first_hop,\n\t\t\t\t\t     &fl6->saddr);\n\t}\n\n\tskb_push(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\thdr = ipv6_hdr(skb);\n\n\t/*\n\t *\tFill in the IPv6 header\n\t */\n\tif (np)\n\t\thlimit = np->hop_limit;\n\tif (hlimit < 0)\n\t\thlimit = ip6_dst_hoplimit(dst);\n\n\tip6_flow_hdr(hdr, tclass, ip6_make_flowlabel(net, skb, fl6->flowlabel,\n\t\t\t\t\t\t     np->autoflowlabel, fl6));\n\n\thdr->payload_len = htons(seg_len);\n\thdr->nexthdr = proto;\n\thdr->hop_limit = hlimit;\n\n\thdr->saddr = fl6->saddr;\n\thdr->daddr = *first_hop;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\tskb->priority = sk->sk_priority;\n\tskb->mark = mark;\n\n\tmtu = dst_mtu(dst);\n\tif ((skb->len <= mtu) || skb->ignore_df || skb_is_gso(skb)) {\n\t\tIP6_UPD_PO_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t      IPSTATS_MIB_OUT, skb->len);\n\n\t\t/* if egress device is enslaved to an L3 master device pass the\n\t\t * skb to its handler for processing\n\t\t */\n\t\tskb = l3mdev_ip6_out((struct sock *)sk, skb);\n\t\tif (unlikely(!skb))\n\t\t\treturn 0;\n\n\t\t/* hooks should never assume socket lock is held.\n\t\t * we promote our socket to non const\n\t\t */\n\t\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT,\n\t\t\t       net, (struct sock *)sk, skb, NULL, dst->dev,\n\t\t\t       dst_output);\n\t}\n\n\tskb->dev = dst->dev;\n\t/* ipv6_local_error() does not require socket lock,\n\t * we promote our socket to non const\n\t */\n\tipv6_local_error((struct sock *)sk, EMSGSIZE, fl6, mtu);\n\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_FRAGFAILS);\n\tkfree_skb(skb);\n\treturn -EMSGSIZE;\n}\nEXPORT_SYMBOL(ip6_xmit);\n\nstatic int ip6_call_ra_chain(struct sk_buff *skb, int sel)\n{\n\tstruct ip6_ra_chain *ra;\n\tstruct sock *last = NULL;\n\n\tread_lock(&ip6_ra_lock);\n\tfor (ra = ip6_ra_chain; ra; ra = ra->next) {\n\t\tstruct sock *sk = ra->sk;\n\t\tif (sk && ra->sel == sel &&\n\t\t    (!sk->sk_bound_dev_if ||\n\t\t     sk->sk_bound_dev_if == skb->dev->ifindex)) {\n\t\t\tif (last) {\n\t\t\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\tif (skb2)\n\t\t\t\t\trawv6_rcv(last, skb2);\n\t\t\t}\n\t\t\tlast = sk;\n\t\t}\n\t}\n\n\tif (last) {\n\t\trawv6_rcv(last, skb);\n\t\tread_unlock(&ip6_ra_lock);\n\t\treturn 1;\n\t}\n\tread_unlock(&ip6_ra_lock);\n\treturn 0;\n}\n\nstatic int ip6_forward_proxy_check(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\tu8 nexthdr = hdr->nexthdr;\n\t__be16 frag_off;\n\tint offset;\n\n\tif (ipv6_ext_hdr(nexthdr)) {\n\t\toffset = ipv6_skip_exthdr(skb, sizeof(*hdr), &nexthdr, &frag_off);\n\t\tif (offset < 0)\n\t\t\treturn 0;\n\t} else\n\t\toffset = sizeof(struct ipv6hdr);\n\n\tif (nexthdr == IPPROTO_ICMPV6) {\n\t\tstruct icmp6hdr *icmp6;\n\n\t\tif (!pskb_may_pull(skb, (skb_network_header(skb) +\n\t\t\t\t\t offset + 1 - skb->data)))\n\t\t\treturn 0;\n\n\t\ticmp6 = (struct icmp6hdr *)(skb_network_header(skb) + offset);\n\n\t\tswitch (icmp6->icmp6_type) {\n\t\tcase NDISC_ROUTER_SOLICITATION:\n\t\tcase NDISC_ROUTER_ADVERTISEMENT:\n\t\tcase NDISC_NEIGHBOUR_SOLICITATION:\n\t\tcase NDISC_NEIGHBOUR_ADVERTISEMENT:\n\t\tcase NDISC_REDIRECT:\n\t\t\t/* For reaction involving unicast neighbor discovery\n\t\t\t * message destined to the proxied address, pass it to\n\t\t\t * input function.\n\t\t\t */\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * The proxying router can't forward traffic sent to a link-local\n\t * address, so signal the sender and discard the packet. This\n\t * behavior is clarified by the MIPv6 specification.\n\t */\n\tif (ipv6_addr_type(&hdr->daddr) & IPV6_ADDR_LINKLOCAL) {\n\t\tdst_link_failure(skb);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int ip6_forward_finish(struct net *net, struct sock *sk,\n\t\t\t\t     struct sk_buff *skb)\n{\n\treturn dst_output(net, sk, skb);\n}\n\nstatic unsigned int ip6_dst_mtu_forward(const struct dst_entry *dst)\n{\n\tunsigned int mtu;\n\tstruct inet6_dev *idev;\n\n\tif (dst_metric_locked(dst, RTAX_MTU)) {\n\t\tmtu = dst_metric_raw(dst, RTAX_MTU);\n\t\tif (mtu)\n\t\t\treturn mtu;\n\t}\n\n\tmtu = IPV6_MIN_MTU;\n\trcu_read_lock();\n\tidev = __in6_dev_get(dst->dev);\n\tif (idev)\n\t\tmtu = idev->cnf.mtu6;\n\trcu_read_unlock();\n\n\treturn mtu;\n}\n\nstatic bool ip6_pkt_too_big(const struct sk_buff *skb, unsigned int mtu)\n{\n\tif (skb->len <= mtu)\n\t\treturn false;\n\n\t/* ipv6 conntrack defrag sets max_frag_size + ignore_df */\n\tif (IP6CB(skb)->frag_max_size && IP6CB(skb)->frag_max_size > mtu)\n\t\treturn true;\n\n\tif (skb->ignore_df)\n\t\treturn false;\n\n\tif (skb_is_gso(skb) && skb_gso_validate_mtu(skb, mtu))\n\t\treturn false;\n\n\treturn true;\n}\n\nint ip6_forward(struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tstruct net *net = dev_net(dst->dev);\n\tu32 mtu;\n\n\tif (net->ipv6.devconf_all->forwarding == 0)\n\t\tgoto error;\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto drop;\n\n\tif (unlikely(skb->sk))\n\t\tgoto drop;\n\n\tif (skb_warn_if_lro(skb))\n\t\tgoto drop;\n\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_FWD, skb)) {\n\t\t__IP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t\tIPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\n\tskb_forward_csum(skb);\n\n\t/*\n\t *\tWe DO NOT make any processing on\n\t *\tRA packets, pushing them to user level AS IS\n\t *\twithout ane WARRANTY that application will be able\n\t *\tto interpret them. The reason is that we\n\t *\tcannot make anything clever here.\n\t *\n\t *\tWe are not end-node, so that if packet contains\n\t *\tAH/ESP, we cannot make anything.\n\t *\tDefragmentation also would be mistake, RA packets\n\t *\tcannot be fragmented, because there is no warranty\n\t *\tthat different fragments will go along one path. --ANK\n\t */\n\tif (unlikely(opt->flags & IP6SKB_ROUTERALERT)) {\n\t\tif (ip6_call_ra_chain(skb, ntohs(opt->ra)))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t *\tcheck and decrement ttl\n\t */\n\tif (hdr->hop_limit <= 1) {\n\t\t/* Force OUTPUT device used as source address */\n\t\tskb->dev = dst->dev;\n\t\ticmpv6_send(skb, ICMPV6_TIME_EXCEED, ICMPV6_EXC_HOPLIMIT, 0);\n\t\t__IP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t\tIPSTATS_MIB_INHDRERRORS);\n\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t/* XXX: idev->cnf.proxy_ndp? */\n\tif (net->ipv6.devconf_all->proxy_ndp &&\n\t    pneigh_lookup(&nd_tbl, net, &hdr->daddr, skb->dev, 0)) {\n\t\tint proxied = ip6_forward_proxy_check(skb);\n\t\tif (proxied > 0)\n\t\t\treturn ip6_input(skb);\n\t\telse if (proxied < 0) {\n\t\t\t__IP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t\t\tIPSTATS_MIB_INDISCARDS);\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (!xfrm6_route_forward(skb)) {\n\t\t__IP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t\tIPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\tdst = skb_dst(skb);\n\n\t/* IPv6 specs say nothing about it, but it is clear that we cannot\n\t   send redirects to source routed frames.\n\t   We don't send redirects to frames decapsulated from IPsec.\n\t */\n\tif (skb->dev == dst->dev && opt->srcrt == 0 && !skb_sec_path(skb)) {\n\t\tstruct in6_addr *target = NULL;\n\t\tstruct inet_peer *peer;\n\t\tstruct rt6_info *rt;\n\n\t\t/*\n\t\t *\tincoming and outgoing devices are the same\n\t\t *\tsend a redirect.\n\t\t */\n\n\t\trt = (struct rt6_info *) dst;\n\t\tif (rt->rt6i_flags & RTF_GATEWAY)\n\t\t\ttarget = &rt->rt6i_gateway;\n\t\telse\n\t\t\ttarget = &hdr->daddr;\n\n\t\tpeer = inet_getpeer_v6(net->ipv6.peers, &hdr->daddr, 1);\n\n\t\t/* Limit redirects both by destination (here)\n\t\t   and by source (inside ndisc_send_redirect)\n\t\t */\n\t\tif (inet_peer_xrlim_allow(peer, 1*HZ))\n\t\t\tndisc_send_redirect(skb, target);\n\t\tif (peer)\n\t\t\tinet_putpeer(peer);\n\t} else {\n\t\tint addrtype = ipv6_addr_type(&hdr->saddr);\n\n\t\t/* This check is security critical. */\n\t\tif (addrtype == IPV6_ADDR_ANY ||\n\t\t    addrtype & (IPV6_ADDR_MULTICAST | IPV6_ADDR_LOOPBACK))\n\t\t\tgoto error;\n\t\tif (addrtype & IPV6_ADDR_LINKLOCAL) {\n\t\t\ticmpv6_send(skb, ICMPV6_DEST_UNREACH,\n\t\t\t\t    ICMPV6_NOT_NEIGHBOUR, 0);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tmtu = ip6_dst_mtu_forward(dst);\n\tif (mtu < IPV6_MIN_MTU)\n\t\tmtu = IPV6_MIN_MTU;\n\n\tif (ip6_pkt_too_big(skb, mtu)) {\n\t\t/* Again, force OUTPUT device used as source address */\n\t\tskb->dev = dst->dev;\n\t\ticmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\n\t\t__IP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t\tIPSTATS_MIB_INTOOBIGERRORS);\n\t\t__IP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t\tIPSTATS_MIB_FRAGFAILS);\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (skb_cow(skb, dst->dev->hard_header_len)) {\n\t\t__IP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t\tIPSTATS_MIB_OUTDISCARDS);\n\t\tgoto drop;\n\t}\n\n\thdr = ipv6_hdr(skb);\n\n\t/* Mangling hops number delayed to point after skb COW */\n\n\thdr->hop_limit--;\n\n\t__IP6_INC_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_OUTFORWDATAGRAMS);\n\t__IP6_ADD_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_OUTOCTETS, skb->len);\n\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_FORWARD,\n\t\t       net, NULL, skb, skb->dev, dst->dev,\n\t\t       ip6_forward_finish);\n\nerror:\n\t__IP6_INC_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_INADDRERRORS);\ndrop:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic void ip6_copy_metadata(struct sk_buff *to, struct sk_buff *from)\n{\n\tto->pkt_type = from->pkt_type;\n\tto->priority = from->priority;\n\tto->protocol = from->protocol;\n\tskb_dst_drop(to);\n\tskb_dst_set(to, dst_clone(skb_dst(from)));\n\tto->dev = from->dev;\n\tto->mark = from->mark;\n\n#ifdef CONFIG_NET_SCHED\n\tto->tc_index = from->tc_index;\n#endif\n\tnf_copy(to, from);\n\tskb_copy_secmark(to, from);\n}\n\nint ip6_fragment(struct net *net, struct sock *sk, struct sk_buff *skb,\n\t\t int (*output)(struct net *, struct sock *, struct sk_buff *))\n{\n\tstruct sk_buff *frag;\n\tstruct rt6_info *rt = (struct rt6_info *)skb_dst(skb);\n\tstruct ipv6_pinfo *np = skb->sk && !dev_recursion_level() ?\n\t\t\t\tinet6_sk(skb->sk) : NULL;\n\tstruct ipv6hdr *tmp_hdr;\n\tstruct frag_hdr *fh;\n\tunsigned int mtu, hlen, left, len;\n\tint hroom, troom;\n\t__be32 frag_id;\n\tint ptr, offset = 0, err = 0;\n\tu8 *prevhdr, nexthdr = 0;\n\n\terr = ip6_find_1stfragopt(skb, &prevhdr);\n\tif (err < 0)\n\t\tgoto fail;\n\thlen = err;\n\tnexthdr = *prevhdr;\n\n\tmtu = ip6_skb_dst_mtu(skb);\n\n\t/* We must not fragment if the socket is set to force MTU discovery\n\t * or if the skb it not generated by a local socket.\n\t */\n\tif (unlikely(!skb->ignore_df && skb->len > mtu))\n\t\tgoto fail_toobig;\n\n\tif (IP6CB(skb)->frag_max_size) {\n\t\tif (IP6CB(skb)->frag_max_size > mtu)\n\t\t\tgoto fail_toobig;\n\n\t\t/* don't send fragments larger than what we received */\n\t\tmtu = IP6CB(skb)->frag_max_size;\n\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\tmtu = IPV6_MIN_MTU;\n\t}\n\n\tif (np && np->frag_size < mtu) {\n\t\tif (np->frag_size)\n\t\t\tmtu = np->frag_size;\n\t}\n\tif (mtu < hlen + sizeof(struct frag_hdr) + 8)\n\t\tgoto fail_toobig;\n\tmtu -= hlen + sizeof(struct frag_hdr);\n\n\tfrag_id = ipv6_select_ident(net, &ipv6_hdr(skb)->daddr,\n\t\t\t\t    &ipv6_hdr(skb)->saddr);\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL &&\n\t    (err = skb_checksum_help(skb)))\n\t\tgoto fail;\n\n\throom = LL_RESERVED_SPACE(rt->dst.dev);\n\tif (skb_has_frag_list(skb)) {\n\t\tunsigned int first_len = skb_pagelen(skb);\n\t\tstruct sk_buff *frag2;\n\n\t\tif (first_len - hlen > mtu ||\n\t\t    ((first_len - hlen) & 7) ||\n\t\t    skb_cloned(skb) ||\n\t\t    skb_headroom(skb) < (hroom + sizeof(struct frag_hdr)))\n\t\t\tgoto slow_path;\n\n\t\tskb_walk_frags(skb, frag) {\n\t\t\t/* Correct geometry. */\n\t\t\tif (frag->len > mtu ||\n\t\t\t    ((frag->len & 7) && frag->next) ||\n\t\t\t    skb_headroom(frag) < (hlen + hroom + sizeof(struct frag_hdr)))\n\t\t\t\tgoto slow_path_clean;\n\n\t\t\t/* Partially cloned skb? */\n\t\t\tif (skb_shared(frag))\n\t\t\t\tgoto slow_path_clean;\n\n\t\t\tBUG_ON(frag->sk);\n\t\t\tif (skb->sk) {\n\t\t\t\tfrag->sk = skb->sk;\n\t\t\t\tfrag->destructor = sock_wfree;\n\t\t\t}\n\t\t\tskb->truesize -= frag->truesize;\n\t\t}\n\n\t\terr = 0;\n\t\toffset = 0;\n\t\t/* BUILD HEADER */\n\n\t\t*prevhdr = NEXTHDR_FRAGMENT;\n\t\ttmp_hdr = kmemdup(skb_network_header(skb), hlen, GFP_ATOMIC);\n\t\tif (!tmp_hdr) {\n\t\t\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t      IPSTATS_MIB_FRAGFAILS);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tfrag = skb_shinfo(skb)->frag_list;\n\t\tskb_frag_list_init(skb);\n\n\t\t__skb_pull(skb, hlen);\n\t\tfh = (struct frag_hdr *)__skb_push(skb, sizeof(struct frag_hdr));\n\t\t__skb_push(skb, hlen);\n\t\tskb_reset_network_header(skb);\n\t\tmemcpy(skb_network_header(skb), tmp_hdr, hlen);\n\n\t\tfh->nexthdr = nexthdr;\n\t\tfh->reserved = 0;\n\t\tfh->frag_off = htons(IP6_MF);\n\t\tfh->identification = frag_id;\n\n\t\tfirst_len = skb_pagelen(skb);\n\t\tskb->data_len = first_len - skb_headlen(skb);\n\t\tskb->len = first_len;\n\t\tipv6_hdr(skb)->payload_len = htons(first_len -\n\t\t\t\t\t\t   sizeof(struct ipv6hdr));\n\n\t\tdst_hold(&rt->dst);\n\n\t\tfor (;;) {\n\t\t\t/* Prepare header of the next frame,\n\t\t\t * before previous one went down. */\n\t\t\tif (frag) {\n\t\t\t\tfrag->ip_summed = CHECKSUM_NONE;\n\t\t\t\tskb_reset_transport_header(frag);\n\t\t\t\tfh = (struct frag_hdr *)__skb_push(frag, sizeof(struct frag_hdr));\n\t\t\t\t__skb_push(frag, hlen);\n\t\t\t\tskb_reset_network_header(frag);\n\t\t\t\tmemcpy(skb_network_header(frag), tmp_hdr,\n\t\t\t\t       hlen);\n\t\t\t\toffset += skb->len - hlen - sizeof(struct frag_hdr);\n\t\t\t\tfh->nexthdr = nexthdr;\n\t\t\t\tfh->reserved = 0;\n\t\t\t\tfh->frag_off = htons(offset);\n\t\t\t\tif (frag->next)\n\t\t\t\t\tfh->frag_off |= htons(IP6_MF);\n\t\t\t\tfh->identification = frag_id;\n\t\t\t\tipv6_hdr(frag)->payload_len =\n\t\t\t\t\t\thtons(frag->len -\n\t\t\t\t\t\t      sizeof(struct ipv6hdr));\n\t\t\t\tip6_copy_metadata(frag, skb);\n\t\t\t}\n\n\t\t\terr = output(net, sk, skb);\n\t\t\tif (!err)\n\t\t\t\tIP6_INC_STATS(net, ip6_dst_idev(&rt->dst),\n\t\t\t\t\t      IPSTATS_MIB_FRAGCREATES);\n\n\t\t\tif (err || !frag)\n\t\t\t\tbreak;\n\n\t\t\tskb = frag;\n\t\t\tfrag = skb->next;\n\t\t\tskb->next = NULL;\n\t\t}\n\n\t\tkfree(tmp_hdr);\n\n\t\tif (err == 0) {\n\t\t\tIP6_INC_STATS(net, ip6_dst_idev(&rt->dst),\n\t\t\t\t      IPSTATS_MIB_FRAGOKS);\n\t\t\tip6_rt_put(rt);\n\t\t\treturn 0;\n\t\t}\n\n\t\tkfree_skb_list(frag);\n\n\t\tIP6_INC_STATS(net, ip6_dst_idev(&rt->dst),\n\t\t\t      IPSTATS_MIB_FRAGFAILS);\n\t\tip6_rt_put(rt);\n\t\treturn err;\n\nslow_path_clean:\n\t\tskb_walk_frags(skb, frag2) {\n\t\t\tif (frag2 == frag)\n\t\t\t\tbreak;\n\t\t\tfrag2->sk = NULL;\n\t\t\tfrag2->destructor = NULL;\n\t\t\tskb->truesize += frag2->truesize;\n\t\t}\n\t}\n\nslow_path:\n\tleft = skb->len - hlen;\t\t/* Space per frame */\n\tptr = hlen;\t\t\t/* Where to start from */\n\n\t/*\n\t *\tFragment the datagram.\n\t */\n\n\ttroom = rt->dst.dev->needed_tailroom;\n\n\t/*\n\t *\tKeep copying data until we run out.\n\t */\n\twhile (left > 0)\t{\n\t\tu8 *fragnexthdr_offset;\n\n\t\tlen = left;\n\t\t/* IF: it doesn't fit, use 'mtu' - the data space left */\n\t\tif (len > mtu)\n\t\t\tlen = mtu;\n\t\t/* IF: we are not sending up to and including the packet end\n\t\t   then align the next start on an eight byte boundary */\n\t\tif (len < left)\t{\n\t\t\tlen &= ~7;\n\t\t}\n\n\t\t/* Allocate buffer */\n\t\tfrag = alloc_skb(len + hlen + sizeof(struct frag_hdr) +\n\t\t\t\t hroom + troom, GFP_ATOMIC);\n\t\tif (!frag) {\n\t\t\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t      IPSTATS_MIB_FRAGFAILS);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t *\tSet up data on packet\n\t\t */\n\n\t\tip6_copy_metadata(frag, skb);\n\t\tskb_reserve(frag, hroom);\n\t\tskb_put(frag, len + hlen + sizeof(struct frag_hdr));\n\t\tskb_reset_network_header(frag);\n\t\tfh = (struct frag_hdr *)(skb_network_header(frag) + hlen);\n\t\tfrag->transport_header = (frag->network_header + hlen +\n\t\t\t\t\t  sizeof(struct frag_hdr));\n\n\t\t/*\n\t\t *\tCharge the memory for the fragment to any owner\n\t\t *\tit might possess\n\t\t */\n\t\tif (skb->sk)\n\t\t\tskb_set_owner_w(frag, skb->sk);\n\n\t\t/*\n\t\t *\tCopy the packet header into the new buffer.\n\t\t */\n\t\tskb_copy_from_linear_data(skb, skb_network_header(frag), hlen);\n\n\t\tfragnexthdr_offset = skb_network_header(frag);\n\t\tfragnexthdr_offset += prevhdr - skb_network_header(skb);\n\t\t*fragnexthdr_offset = NEXTHDR_FRAGMENT;\n\n\t\t/*\n\t\t *\tBuild fragment header.\n\t\t */\n\t\tfh->nexthdr = nexthdr;\n\t\tfh->reserved = 0;\n\t\tfh->identification = frag_id;\n\n\t\t/*\n\t\t *\tCopy a block of the IP datagram.\n\t\t */\n\t\tBUG_ON(skb_copy_bits(skb, ptr, skb_transport_header(frag),\n\t\t\t\t     len));\n\t\tleft -= len;\n\n\t\tfh->frag_off = htons(offset);\n\t\tif (left > 0)\n\t\t\tfh->frag_off |= htons(IP6_MF);\n\t\tipv6_hdr(frag)->payload_len = htons(frag->len -\n\t\t\t\t\t\t    sizeof(struct ipv6hdr));\n\n\t\tptr += len;\n\t\toffset += len;\n\n\t\t/*\n\t\t *\tPut this fragment into the sending queue.\n\t\t */\n\t\terr = output(net, sk, frag);\n\t\tif (err)\n\t\t\tgoto fail;\n\n\t\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t      IPSTATS_MIB_FRAGCREATES);\n\t}\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t      IPSTATS_MIB_FRAGOKS);\n\tconsume_skb(skb);\n\treturn err;\n\nfail_toobig:\n\tif (skb->sk && dst_allfrag(skb_dst(skb)))\n\t\tsk_nocaps_add(skb->sk, NETIF_F_GSO_MASK);\n\n\tskb->dev = skb_dst(skb)->dev;\n\ticmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\n\terr = -EMSGSIZE;\n\nfail:\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t      IPSTATS_MIB_FRAGFAILS);\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic inline int ip6_rt_check(const struct rt6key *rt_key,\n\t\t\t       const struct in6_addr *fl_addr,\n\t\t\t       const struct in6_addr *addr_cache)\n{\n\treturn (rt_key->plen != 128 || !ipv6_addr_equal(fl_addr, &rt_key->addr)) &&\n\t\t(!addr_cache || !ipv6_addr_equal(fl_addr, addr_cache));\n}\n\nstatic struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  const struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt;\n\n\tif (!dst)\n\t\tgoto out;\n\n\tif (dst->ops->family != AF_INET6) {\n\t\tdst_release(dst);\n\t\treturn NULL;\n\t}\n\n\trt = (struct rt6_info *)dst;\n\t/* Yes, checking route validity in not connected\n\t * case is not very simple. Take into account,\n\t * that we do not support routing by source, TOS,\n\t * and MSG_DONTROUTE\t\t--ANK (980726)\n\t *\n\t * 1. ip6_rt_check(): If route was host route,\n\t *    check that cached destination is current.\n\t *    If it is network route, we still may\n\t *    check its validity using saved pointer\n\t *    to the last used address: daddr_cache.\n\t *    We do not want to save whole address now,\n\t *    (because main consumer of this service\n\t *    is tcp, which has not this problem),\n\t *    so that the last trick works only on connected\n\t *    sockets.\n\t * 2. oif also should be the same.\n\t */\n\tif (ip6_rt_check(&rt->rt6i_dst, &fl6->daddr, np->daddr_cache) ||\n#ifdef CONFIG_IPV6_SUBTREES\n\t    ip6_rt_check(&rt->rt6i_src, &fl6->saddr, np->saddr_cache) ||\n#endif\n\t   (!(fl6->flowi6_flags & FLOWI_FLAG_SKIP_NH_OIF) &&\n\t      (fl6->flowi6_oif && fl6->flowi6_oif != dst->dev->ifindex))) {\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\n\nout:\n\treturn dst;\n}\n\nstatic int ip6_dst_lookup_tail(struct net *net, const struct sock *sk,\n\t\t\t       struct dst_entry **dst, struct flowi6 *fl6)\n{\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\n\tstruct neighbour *n;\n\tstruct rt6_info *rt;\n#endif\n\tint err;\n\tint flags = 0;\n\n\t/* The correct way to handle this would be to do\n\t * ip6_route_get_saddr, and then ip6_route_output; however,\n\t * the route-specific preferred source forces the\n\t * ip6_route_output call _before_ ip6_route_get_saddr.\n\t *\n\t * In source specific routing (no src=any default route),\n\t * ip6_route_output will fail given src=any saddr, though, so\n\t * that's why we try it again later.\n\t */\n\tif (ipv6_addr_any(&fl6->saddr) && (!*dst || !(*dst)->error)) {\n\t\tstruct rt6_info *rt;\n\t\tbool had_dst = *dst != NULL;\n\n\t\tif (!had_dst)\n\t\t\t*dst = ip6_route_output(net, sk, fl6);\n\t\trt = (*dst)->error ? NULL : (struct rt6_info *)*dst;\n\t\terr = ip6_route_get_saddr(net, rt, &fl6->daddr,\n\t\t\t\t\t  sk ? inet6_sk(sk)->srcprefs : 0,\n\t\t\t\t\t  &fl6->saddr);\n\t\tif (err)\n\t\t\tgoto out_err_release;\n\n\t\t/* If we had an erroneous initial result, pretend it\n\t\t * never existed and let the SA-enabled version take\n\t\t * over.\n\t\t */\n\t\tif (!had_dst && (*dst)->error) {\n\t\t\tdst_release(*dst);\n\t\t\t*dst = NULL;\n\t\t}\n\n\t\tif (fl6->flowi6_oif)\n\t\t\tflags |= RT6_LOOKUP_F_IFACE;\n\t}\n\n\tif (!*dst)\n\t\t*dst = ip6_route_output_flags(net, sk, fl6, flags);\n\n\terr = (*dst)->error;\n\tif (err)\n\t\tgoto out_err_release;\n\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\n\t/*\n\t * Here if the dst entry we've looked up\n\t * has a neighbour entry that is in the INCOMPLETE\n\t * state and the src address from the flow is\n\t * marked as OPTIMISTIC, we release the found\n\t * dst entry and replace it instead with the\n\t * dst entry of the nexthop router\n\t */\n\trt = (struct rt6_info *) *dst;\n\trcu_read_lock_bh();\n\tn = __ipv6_neigh_lookup_noref(rt->dst.dev,\n\t\t\t\t      rt6_nexthop(rt, &fl6->daddr));\n\terr = n && !(n->nud_state & NUD_VALID) ? -EINVAL : 0;\n\trcu_read_unlock_bh();\n\n\tif (err) {\n\t\tstruct inet6_ifaddr *ifp;\n\t\tstruct flowi6 fl_gw6;\n\t\tint redirect;\n\n\t\tifp = ipv6_get_ifaddr(net, &fl6->saddr,\n\t\t\t\t      (*dst)->dev, 1);\n\n\t\tredirect = (ifp && ifp->flags & IFA_F_OPTIMISTIC);\n\t\tif (ifp)\n\t\t\tin6_ifa_put(ifp);\n\n\t\tif (redirect) {\n\t\t\t/*\n\t\t\t * We need to get the dst entry for the\n\t\t\t * default router instead\n\t\t\t */\n\t\t\tdst_release(*dst);\n\t\t\tmemcpy(&fl_gw6, fl6, sizeof(struct flowi6));\n\t\t\tmemset(&fl_gw6.daddr, 0, sizeof(struct in6_addr));\n\t\t\t*dst = ip6_route_output(net, sk, &fl_gw6);\n\t\t\terr = (*dst)->error;\n\t\t\tif (err)\n\t\t\t\tgoto out_err_release;\n\t\t}\n\t}\n#endif\n\tif (ipv6_addr_v4mapped(&fl6->saddr) &&\n\t    !(ipv6_addr_v4mapped(&fl6->daddr) || ipv6_addr_any(&fl6->daddr))) {\n\t\terr = -EAFNOSUPPORT;\n\t\tgoto out_err_release;\n\t}\n\n\treturn 0;\n\nout_err_release:\n\tdst_release(*dst);\n\t*dst = NULL;\n\n\tif (err == -ENETUNREACH)\n\t\tIP6_INC_STATS(net, NULL, IPSTATS_MIB_OUTNOROUTES);\n\treturn err;\n}\n\n/**\n *\tip6_dst_lookup - perform route lookup on flow\n *\t@sk: socket which provides route info\n *\t@dst: pointer to dst_entry * for result\n *\t@fl6: flow to lookup\n *\n *\tThis function performs a route lookup on the given flow.\n *\n *\tIt returns zero on success, or a standard errno code on error.\n */\nint ip6_dst_lookup(struct net *net, struct sock *sk, struct dst_entry **dst,\n\t\t   struct flowi6 *fl6)\n{\n\t*dst = NULL;\n\treturn ip6_dst_lookup_tail(net, sk, dst, fl6);\n}\nEXPORT_SYMBOL_GPL(ip6_dst_lookup);\n\n/**\n *\tip6_dst_lookup_flow - perform route lookup on flow with ipsec\n *\t@sk: socket which provides route info\n *\t@fl6: flow to lookup\n *\t@final_dst: final destination address for ipsec lookup\n *\n *\tThis function performs a route lookup on the given flow.\n *\n *\tIt returns a valid dst pointer on success, or a pointer encoded\n *\terror code.\n */\nstruct dst_entry *ip6_dst_lookup_flow(const struct sock *sk, struct flowi6 *fl6,\n\t\t\t\t      const struct in6_addr *final_dst)\n{\n\tstruct dst_entry *dst = NULL;\n\tint err;\n\n\terr = ip6_dst_lookup_tail(sock_net(sk), sk, &dst, fl6);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tif (final_dst)\n\t\tfl6->daddr = *final_dst;\n\n\treturn xfrm_lookup_route(sock_net(sk), dst, flowi6_to_flowi(fl6), sk, 0);\n}\nEXPORT_SYMBOL_GPL(ip6_dst_lookup_flow);\n\n/**\n *\tip6_sk_dst_lookup_flow - perform socket cached route lookup on flow\n *\t@sk: socket which provides the dst cache and route info\n *\t@fl6: flow to lookup\n *\t@final_dst: final destination address for ipsec lookup\n *\n *\tThis function performs a route lookup on the given flow with the\n *\tpossibility of using the cached route in the socket if it is valid.\n *\tIt will take the socket dst lock when operating on the dst cache.\n *\tAs a result, this function can only be used in process context.\n *\n *\tIt returns a valid dst pointer on success, or a pointer encoded\n *\terror code.\n */\nstruct dst_entry *ip6_sk_dst_lookup_flow(struct sock *sk, struct flowi6 *fl6,\n\t\t\t\t\t const struct in6_addr *final_dst)\n{\n\tstruct dst_entry *dst = sk_dst_check(sk, inet6_sk(sk)->dst_cookie);\n\n\tdst = ip6_sk_dst_check(sk, dst, fl6);\n\tif (!dst)\n\t\tdst = ip6_dst_lookup_flow(sk, fl6, final_dst);\n\n\treturn dst;\n}\nEXPORT_SYMBOL_GPL(ip6_sk_dst_lookup_flow);\n\nstatic inline int ip6_ufo_append_data(struct sock *sk,\n\t\t\tstruct sk_buff_head *queue,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\tint odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint exthdrlen, int transhdrlen, int mtu,\n\t\t\tunsigned int flags, const struct flowi6 *fl6)\n\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\t/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n\t * udp datagram\n\t */\n\tskb = skb_peek_tail(queue);\n\tif (!skb) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (!skb)\n\t\t\treturn err;\n\n\t\t/* reserve space for Hardware header */\n\t\tskb_reserve(skb, hh_len);\n\n\t\t/* create space for UDP/IP header */\n\t\tskb_put(skb, fragheaderlen + transhdrlen);\n\n\t\t/* initialize network header pointer */\n\t\tskb_set_network_header(skb, exthdrlen);\n\n\t\t/* initialize protocol header pointer */\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->csum = 0;\n\n\t\tif (flags & MSG_CONFIRM)\n\t\t\tskb_set_dst_pending_confirm(skb, 1);\n\n\t\t__skb_queue_tail(queue, skb);\n\t} else if (skb_is_gso(skb)) {\n\t\tgoto append;\n\t}\n\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t/* Specify the length of each IPv6 datagram fragment.\n\t * It has to be a multiple of 8.\n\t */\n\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\tskb_shinfo(skb)->ip6_frag_id = ipv6_select_ident(sock_net(sk),\n\t\t\t\t\t\t\t &fl6->daddr,\n\t\t\t\t\t\t\t &fl6->saddr);\n\nappend:\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}\n\nstatic inline struct ipv6_opt_hdr *ip6_opt_dup(struct ipv6_opt_hdr *src,\n\t\t\t\t\t       gfp_t gfp)\n{\n\treturn src ? kmemdup(src, (src->hdrlen + 1) * 8, gfp) : NULL;\n}\n\nstatic inline struct ipv6_rt_hdr *ip6_rthdr_dup(struct ipv6_rt_hdr *src,\n\t\t\t\t\t\tgfp_t gfp)\n{\n\treturn src ? kmemdup(src, (src->hdrlen + 1) * 8, gfp) : NULL;\n}\n\nstatic void ip6_append_data_mtu(unsigned int *mtu,\n\t\t\t\tint *maxfraglen,\n\t\t\t\tunsigned int fragheaderlen,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct rt6_info *rt,\n\t\t\t\tunsigned int orig_mtu)\n{\n\tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n\t\tif (!skb) {\n\t\t\t/* first fragment, reserve header_len */\n\t\t\t*mtu = orig_mtu - rt->dst.header_len;\n\n\t\t} else {\n\t\t\t/*\n\t\t\t * this fragment is not first, the headers\n\t\t\t * space is regarded as data space.\n\t\t\t */\n\t\t\t*mtu = orig_mtu;\n\t\t}\n\t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n\t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n\t}\n}\n\nstatic int ip6_setup_cork(struct sock *sk, struct inet_cork_full *cork,\n\t\t\t  struct inet6_cork *v6_cork, struct ipcm6_cookie *ipc6,\n\t\t\t  struct rt6_info *rt, struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tunsigned int mtu;\n\tstruct ipv6_txoptions *opt = ipc6->opt;\n\n\t/*\n\t * setup for corking\n\t */\n\tif (opt) {\n\t\tif (WARN_ON(v6_cork->opt))\n\t\t\treturn -EINVAL;\n\n\t\tv6_cork->opt = kzalloc(opt->tot_len, sk->sk_allocation);\n\t\tif (unlikely(!v6_cork->opt))\n\t\t\treturn -ENOBUFS;\n\n\t\tv6_cork->opt->tot_len = opt->tot_len;\n\t\tv6_cork->opt->opt_flen = opt->opt_flen;\n\t\tv6_cork->opt->opt_nflen = opt->opt_nflen;\n\n\t\tv6_cork->opt->dst0opt = ip6_opt_dup(opt->dst0opt,\n\t\t\t\t\t\t    sk->sk_allocation);\n\t\tif (opt->dst0opt && !v6_cork->opt->dst0opt)\n\t\t\treturn -ENOBUFS;\n\n\t\tv6_cork->opt->dst1opt = ip6_opt_dup(opt->dst1opt,\n\t\t\t\t\t\t    sk->sk_allocation);\n\t\tif (opt->dst1opt && !v6_cork->opt->dst1opt)\n\t\t\treturn -ENOBUFS;\n\n\t\tv6_cork->opt->hopopt = ip6_opt_dup(opt->hopopt,\n\t\t\t\t\t\t   sk->sk_allocation);\n\t\tif (opt->hopopt && !v6_cork->opt->hopopt)\n\t\t\treturn -ENOBUFS;\n\n\t\tv6_cork->opt->srcrt = ip6_rthdr_dup(opt->srcrt,\n\t\t\t\t\t\t    sk->sk_allocation);\n\t\tif (opt->srcrt && !v6_cork->opt->srcrt)\n\t\t\treturn -ENOBUFS;\n\n\t\t/* need source address above miyazawa*/\n\t}\n\tdst_hold(&rt->dst);\n\tcork->base.dst = &rt->dst;\n\tcork->fl.u.ip6 = *fl6;\n\tv6_cork->hop_limit = ipc6->hlimit;\n\tv6_cork->tclass = ipc6->tclass;\n\tif (rt->dst.flags & DST_XFRM_TUNNEL)\n\t\tmtu = np->pmtudisc >= IPV6_PMTUDISC_PROBE ?\n\t\t      rt->dst.dev->mtu : dst_mtu(&rt->dst);\n\telse\n\t\tmtu = np->pmtudisc >= IPV6_PMTUDISC_PROBE ?\n\t\t      rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\tif (np->frag_size < mtu) {\n\t\tif (np->frag_size)\n\t\t\tmtu = np->frag_size;\n\t}\n\tcork->base.fragsize = mtu;\n\tif (dst_allfrag(rt->dst.path))\n\t\tcork->base.flags |= IPCORK_ALLFRAG;\n\tcork->base.length = 0;\n\n\treturn 0;\n}\n\nstatic int __ip6_append_data(struct sock *sk,\n\t\t\t     struct flowi6 *fl6,\n\t\t\t     struct sk_buff_head *queue,\n\t\t\t     struct inet_cork *cork,\n\t\t\t     struct inet6_cork *v6_cork,\n\t\t\t     struct page_frag *pfrag,\n\t\t\t     int getfrag(void *from, char *to, int offset,\n\t\t\t\t\t int len, int odd, struct sk_buff *skb),\n\t\t\t     void *from, int length, int transhdrlen,\n\t\t\t     unsigned int flags, struct ipcm6_cookie *ipc6,\n\t\t\t     const struct sockcm_cookie *sockc)\n{\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\tunsigned int maxfraglen, fragheaderlen, mtu, orig_mtu;\n\tint exthdrlen = 0;\n\tint dst_exthdrlen = 0;\n\tint hh_len;\n\tint copy;\n\tint err;\n\tint offset = 0;\n\t__u8 tx_flags = 0;\n\tu32 tskey = 0;\n\tstruct rt6_info *rt = (struct rt6_info *)cork->dst;\n\tstruct ipv6_txoptions *opt = v6_cork->opt;\n\tint csummode = CHECKSUM_NONE;\n\tunsigned int maxnonfragsize, headersize;\n\n\tskb = skb_peek_tail(queue);\n\tif (!skb) {\n\t\texthdrlen = opt ? opt->opt_flen : 0;\n\t\tdst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;\n\t}\n\n\tmtu = cork->fragsize;\n\torig_mtu = mtu;\n\n\thh_len = LL_RESERVED_SPACE(rt->dst.dev);\n\n\tfragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len +\n\t\t\t(opt ? opt->opt_nflen : 0);\n\tmaxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen -\n\t\t     sizeof(struct frag_hdr);\n\n\theadersize = sizeof(struct ipv6hdr) +\n\t\t     (opt ? opt->opt_flen + opt->opt_nflen : 0) +\n\t\t     (dst_allfrag(&rt->dst) ?\n\t\t      sizeof(struct frag_hdr) : 0) +\n\t\t     rt->rt6i_nfheader_len;\n\n\tif (cork->length + length > mtu - headersize && ipc6->dontfrag &&\n\t    (sk->sk_protocol == IPPROTO_UDP ||\n\t     sk->sk_protocol == IPPROTO_RAW)) {\n\t\tipv6_local_rxpmtu(sk, fl6, mtu - headersize +\n\t\t\t\tsizeof(struct ipv6hdr));\n\t\tgoto emsgsize;\n\t}\n\n\tif (ip6_sk_ignore_df(sk))\n\t\tmaxnonfragsize = sizeof(struct ipv6hdr) + IPV6_MAXPLEN;\n\telse\n\t\tmaxnonfragsize = mtu;\n\n\tif (cork->length + length > maxnonfragsize - headersize) {\nemsgsize:\n\t\tipv6_local_error(sk, EMSGSIZE, fl6,\n\t\t\t\t mtu - headersize +\n\t\t\t\t sizeof(struct ipv6hdr));\n\t\treturn -EMSGSIZE;\n\t}\n\n\t/* CHECKSUM_PARTIAL only with no extension headers and when\n\t * we are not going to fragment\n\t */\n\tif (transhdrlen && sk->sk_protocol == IPPROTO_UDP &&\n\t    headersize == sizeof(struct ipv6hdr) &&\n\t    length <= mtu - headersize &&\n\t    !(flags & MSG_MORE) &&\n\t    rt->dst.dev->features & (NETIF_F_IPV6_CSUM | NETIF_F_HW_CSUM))\n\t\tcsummode = CHECKSUM_PARTIAL;\n\n\tif (sk->sk_type == SOCK_DGRAM || sk->sk_type == SOCK_RAW) {\n\t\tsock_tx_timestamp(sk, sockc->tsflags, &tx_flags);\n\t\tif (tx_flags & SKBTX_ANY_SW_TSTAMP &&\n\t\t    sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)\n\t\t\ttskey = sk->sk_tskey++;\n\t}\n\n\t/*\n\t * Let's try using as much space as possible.\n\t * Use MTU if total length of the message fits into the MTU.\n\t * Otherwise, we need to reserve fragment header and\n\t * fragment alignment (= 8-15 octects, in total).\n\t *\n\t * Note that we may need to \"move\" the data from the tail of\n\t * of the buffer to the new fragment when we split\n\t * the message.\n\t *\n\t * FIXME: It may be fragmented into multiple chunks\n\t *        at once if non-fragmentable extension headers\n\t *        are too large.\n\t * --yoshfuji\n\t */\n\n\tcork->length += length;\n\tif ((((length + fragheaderlen) > mtu) ||\n\t     (skb && skb_is_gso(skb))) &&\n\t    (sk->sk_protocol == IPPROTO_UDP) &&\n\t    (rt->dst.dev->features & NETIF_F_UFO) && !dst_xfrm(&rt->dst) &&\n\t    (sk->sk_type == SOCK_DGRAM) && !udp_get_no_check6_tx(sk)) {\n\t\terr = ip6_ufo_append_data(sk, queue, getfrag, from, length,\n\t\t\t\t\t  hh_len, fragheaderlen, exthdrlen,\n\t\t\t\t\t  transhdrlen, mtu, flags, fl6);\n\t\tif (err)\n\t\t\tgoto error;\n\t\treturn 0;\n\t}\n\n\tif (!skb)\n\t\tgoto alloc_new_skb;\n\n\twhile (length > 0) {\n\t\t/* Check if the remaining data fits into current packet. */\n\t\tcopy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;\n\t\tif (copy < length)\n\t\t\tcopy = maxfraglen - skb->len;\n\n\t\tif (copy <= 0) {\n\t\t\tchar *data;\n\t\t\tunsigned int datalen;\n\t\t\tunsigned int fraglen;\n\t\t\tunsigned int fraggap;\n\t\t\tunsigned int alloclen;\nalloc_new_skb:\n\t\t\t/* There's no room in the current skb */\n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t/* update mtu and maxfraglen if necessary */\n\t\t\tif (!skb || !skb_prev)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt,\n\t\t\t\t\t\t    orig_mtu);\n\n\t\t\tskb_prev = skb;\n\n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t */\n\t\t\tdatalen = length + fraggap;\n\n\t\t\tif (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)\n\t\t\t\tdatalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;\n\t\t\tif ((flags & MSG_MORE) &&\n\t\t\t    !(rt->dst.dev->features&NETIF_F_SG))\n\t\t\t\talloclen = mtu;\n\t\t\telse\n\t\t\t\talloclen = datalen + fragheaderlen;\n\n\t\t\talloclen += dst_exthdrlen;\n\n\t\t\tif (datalen != length + fraggap) {\n\t\t\t\t/*\n\t\t\t\t * this is not the last fragment, the trailer\n\t\t\t\t * space is regarded as data space.\n\t\t\t\t */\n\t\t\t\tdatalen += rt->dst.trailer_len;\n\t\t\t}\n\n\t\t\talloclen += rt->dst.trailer_len;\n\t\t\tfraglen = datalen + fragheaderlen;\n\n\t\t\t/*\n\t\t\t * We just reserve space for fragment header.\n\t\t\t * Note: this may be overallocation if the message\n\t\t\t * (without MSG_MORE) fits into the MTU.\n\t\t\t */\n\t\t\talloclen += sizeof(struct frag_hdr);\n\n\t\t\tif (transhdrlen) {\n\t\t\t\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t\t\talloclen + hh_len,\n\t\t\t\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t\tif (atomic_read(&sk->sk_wmem_alloc) <=\n\t\t\t\t    2 * sk->sk_sndbuf)\n\t\t\t\t\tskb = sock_wmalloc(sk,\n\t\t\t\t\t\t\t   alloclen + hh_len, 1,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\t\tif (unlikely(!skb))\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t}\n\t\t\tif (!skb)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t *\tFill in the control structures\n\t\t\t */\n\t\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\t\tskb->ip_summed = csummode;\n\t\t\tskb->csum = 0;\n\t\t\t/* reserve for fragmentation and ipsec header */\n\t\t\tskb_reserve(skb, hh_len + sizeof(struct frag_hdr) +\n\t\t\t\t    dst_exthdrlen);\n\n\t\t\t/* Only the initial fragment is time stamped */\n\t\t\tskb_shinfo(skb)->tx_flags = tx_flags;\n\t\t\ttx_flags = 0;\n\t\t\tskb_shinfo(skb)->tskey = tskey;\n\t\t\ttskey = 0;\n\n\t\t\t/*\n\t\t\t *\tFind where to start putting bytes\n\t\t\t */\n\t\t\tdata = skb_put(skb, fraglen);\n\t\t\tskb_set_network_header(skb, exthdrlen);\n\t\t\tdata += fragheaderlen;\n\t\t\tskb->transport_header = (skb->network_header +\n\t\t\t\t\t\t fragheaderlen);\n\t\t\tif (fraggap) {\n\t\t\t\tskb->csum = skb_copy_and_csum_bits(\n\t\t\t\t\tskb_prev, maxfraglen,\n\t\t\t\t\tdata + transhdrlen, fraggap, 0);\n\t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,\n\t\t\t\t\t\t\t  skb->csum);\n\t\t\t\tdata += fraggap;\n\t\t\t\tpskb_trim_unique(skb_prev, maxfraglen);\n\t\t\t}\n\t\t\tcopy = datalen - transhdrlen - fraggap;\n\n\t\t\tif (copy < 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t} else if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\toffset += copy;\n\t\t\tlength -= datalen - fraggap;\n\t\t\ttranshdrlen = 0;\n\t\t\texthdrlen = 0;\n\t\t\tdst_exthdrlen = 0;\n\n\t\t\tif ((flags & MSG_CONFIRM) && !skb_prev)\n\t\t\t\tskb_set_dst_pending_confirm(skb, 1);\n\n\t\t\t/*\n\t\t\t * Put the packet on the pending queue\n\t\t\t */\n\t\t\t__skb_queue_tail(queue, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (copy > length)\n\t\t\tcopy = length;\n\n\t\tif (!(rt->dst.dev->features&NETIF_F_SG)) {\n\t\t\tunsigned int off;\n\n\t\t\toff = skb->len;\n\t\t\tif (getfrag(from, skb_put(skb, copy),\n\t\t\t\t\t\toffset, copy, off, skb) < 0) {\n\t\t\t\t__skb_trim(skb, off);\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tint i = skb_shinfo(skb)->nr_frags;\n\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sk_page_frag_refill(sk, pfrag))\n\t\t\t\tgoto error;\n\n\t\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n\t\t\t\t\t      pfrag->offset)) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tif (i == MAX_SKB_FRAGS)\n\t\t\t\t\tgoto error;\n\n\t\t\t\t__skb_fill_page_desc(skb, i, pfrag->page,\n\t\t\t\t\t\t     pfrag->offset, 0);\n\t\t\t\tskb_shinfo(skb)->nr_frags = ++i;\n\t\t\t\tget_page(pfrag->page);\n\t\t\t}\n\t\t\tcopy = min_t(int, copy, pfrag->size - pfrag->offset);\n\t\t\tif (getfrag(from,\n\t\t\t\t    page_address(pfrag->page) + pfrag->offset,\n\t\t\t\t    offset, copy, skb->len, skb) < 0)\n\t\t\t\tgoto error_efault;\n\n\t\t\tpfrag->offset += copy;\n\t\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n\t\t\tskb->len += copy;\n\t\t\tskb->data_len += copy;\n\t\t\tskb->truesize += copy;\n\t\t\tatomic_add(copy, &sk->sk_wmem_alloc);\n\t\t}\n\t\toffset += copy;\n\t\tlength -= copy;\n\t}\n\n\treturn 0;\n\nerror_efault:\n\terr = -EFAULT;\nerror:\n\tcork->length -= length;\n\tIP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\treturn err;\n}\n\nint ip6_append_data(struct sock *sk,\n\t\t    int getfrag(void *from, char *to, int offset, int len,\n\t\t\t\tint odd, struct sk_buff *skb),\n\t\t    void *from, int length, int transhdrlen,\n\t\t    struct ipcm6_cookie *ipc6, struct flowi6 *fl6,\n\t\t    struct rt6_info *rt, unsigned int flags,\n\t\t    const struct sockcm_cookie *sockc)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tint exthdrlen;\n\tint err;\n\n\tif (flags&MSG_PROBE)\n\t\treturn 0;\n\tif (skb_queue_empty(&sk->sk_write_queue)) {\n\t\t/*\n\t\t * setup for corking\n\t\t */\n\t\terr = ip6_setup_cork(sk, &inet->cork, &np->cork,\n\t\t\t\t     ipc6, rt, fl6);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\texthdrlen = (ipc6->opt ? ipc6->opt->opt_flen : 0);\n\t\tlength += exthdrlen;\n\t\ttranshdrlen += exthdrlen;\n\t} else {\n\t\tfl6 = &inet->cork.fl.u.ip6;\n\t\ttranshdrlen = 0;\n\t}\n\n\treturn __ip6_append_data(sk, fl6, &sk->sk_write_queue, &inet->cork.base,\n\t\t\t\t &np->cork, sk_page_frag(sk), getfrag,\n\t\t\t\t from, length, transhdrlen, flags, ipc6, sockc);\n}\nEXPORT_SYMBOL_GPL(ip6_append_data);\n\nstatic void ip6_cork_release(struct inet_cork_full *cork,\n\t\t\t     struct inet6_cork *v6_cork)\n{\n\tif (v6_cork->opt) {\n\t\tkfree(v6_cork->opt->dst0opt);\n\t\tkfree(v6_cork->opt->dst1opt);\n\t\tkfree(v6_cork->opt->hopopt);\n\t\tkfree(v6_cork->opt->srcrt);\n\t\tkfree(v6_cork->opt);\n\t\tv6_cork->opt = NULL;\n\t}\n\n\tif (cork->base.dst) {\n\t\tdst_release(cork->base.dst);\n\t\tcork->base.dst = NULL;\n\t\tcork->base.flags &= ~IPCORK_ALLFRAG;\n\t}\n\tmemset(&cork->fl, 0, sizeof(cork->fl));\n}\n\nstruct sk_buff *__ip6_make_skb(struct sock *sk,\n\t\t\t       struct sk_buff_head *queue,\n\t\t\t       struct inet_cork_full *cork,\n\t\t\t       struct inet6_cork *v6_cork)\n{\n\tstruct sk_buff *skb, *tmp_skb;\n\tstruct sk_buff **tail_skb;\n\tstruct in6_addr final_dst_buf, *final_dst = &final_dst_buf;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct ipv6hdr *hdr;\n\tstruct ipv6_txoptions *opt = v6_cork->opt;\n\tstruct rt6_info *rt = (struct rt6_info *)cork->base.dst;\n\tstruct flowi6 *fl6 = &cork->fl.u.ip6;\n\tunsigned char proto = fl6->flowi6_proto;\n\n\tskb = __skb_dequeue(queue);\n\tif (!skb)\n\t\tgoto out;\n\ttail_skb = &(skb_shinfo(skb)->frag_list);\n\n\t/* move skb->data to ip header from ext header */\n\tif (skb->data < skb_network_header(skb))\n\t\t__skb_pull(skb, skb_network_offset(skb));\n\twhile ((tmp_skb = __skb_dequeue(queue)) != NULL) {\n\t\t__skb_pull(tmp_skb, skb_network_header_len(skb));\n\t\t*tail_skb = tmp_skb;\n\t\ttail_skb = &(tmp_skb->next);\n\t\tskb->len += tmp_skb->len;\n\t\tskb->data_len += tmp_skb->len;\n\t\tskb->truesize += tmp_skb->truesize;\n\t\ttmp_skb->destructor = NULL;\n\t\ttmp_skb->sk = NULL;\n\t}\n\n\t/* Allow local fragmentation. */\n\tskb->ignore_df = ip6_sk_ignore_df(sk);\n\n\t*final_dst = fl6->daddr;\n\t__skb_pull(skb, skb_network_header_len(skb));\n\tif (opt && opt->opt_flen)\n\t\tipv6_push_frag_opts(skb, opt, &proto);\n\tif (opt && opt->opt_nflen)\n\t\tipv6_push_nfrag_opts(skb, opt, &proto, &final_dst, &fl6->saddr);\n\n\tskb_push(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\thdr = ipv6_hdr(skb);\n\n\tip6_flow_hdr(hdr, v6_cork->tclass,\n\t\t     ip6_make_flowlabel(net, skb, fl6->flowlabel,\n\t\t\t\t\tnp->autoflowlabel, fl6));\n\thdr->hop_limit = v6_cork->hop_limit;\n\thdr->nexthdr = proto;\n\thdr->saddr = fl6->saddr;\n\thdr->daddr = *final_dst;\n\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\n\tskb_dst_set(skb, dst_clone(&rt->dst));\n\tIP6_UPD_PO_STATS(net, rt->rt6i_idev, IPSTATS_MIB_OUT, skb->len);\n\tif (proto == IPPROTO_ICMPV6) {\n\t\tstruct inet6_dev *idev = ip6_dst_idev(skb_dst(skb));\n\n\t\tICMP6MSGOUT_INC_STATS(net, idev, icmp6_hdr(skb)->icmp6_type);\n\t\tICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTMSGS);\n\t}\n\n\tip6_cork_release(cork, v6_cork);\nout:\n\treturn skb;\n}\n\nint ip6_send_skb(struct sk_buff *skb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct rt6_info *rt = (struct rt6_info *)skb_dst(skb);\n\tint err;\n\n\terr = ip6_local_out(net, skb->sk, skb);\n\tif (err) {\n\t\tif (err > 0)\n\t\t\terr = net_xmit_errno(err);\n\t\tif (err)\n\t\t\tIP6_INC_STATS(net, rt->rt6i_idev,\n\t\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t}\n\n\treturn err;\n}\n\nint ip6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\n\tskb = ip6_finish_skb(sk);\n\tif (!skb)\n\t\treturn 0;\n\n\treturn ip6_send_skb(skb);\n}\nEXPORT_SYMBOL_GPL(ip6_push_pending_frames);\n\nstatic void __ip6_flush_pending_frames(struct sock *sk,\n\t\t\t\t       struct sk_buff_head *queue,\n\t\t\t\t       struct inet_cork_full *cork,\n\t\t\t\t       struct inet6_cork *v6_cork)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = __skb_dequeue_tail(queue)) != NULL) {\n\t\tif (skb_dst(skb))\n\t\t\tIP6_INC_STATS(sock_net(sk), ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t\tkfree_skb(skb);\n\t}\n\n\tip6_cork_release(cork, v6_cork);\n}\n\nvoid ip6_flush_pending_frames(struct sock *sk)\n{\n\t__ip6_flush_pending_frames(sk, &sk->sk_write_queue,\n\t\t\t\t   &inet_sk(sk)->cork, &inet6_sk(sk)->cork);\n}\nEXPORT_SYMBOL_GPL(ip6_flush_pending_frames);\n\nstruct sk_buff *ip6_make_skb(struct sock *sk,\n\t\t\t     int getfrag(void *from, char *to, int offset,\n\t\t\t\t\t int len, int odd, struct sk_buff *skb),\n\t\t\t     void *from, int length, int transhdrlen,\n\t\t\t     struct ipcm6_cookie *ipc6, struct flowi6 *fl6,\n\t\t\t     struct rt6_info *rt, unsigned int flags,\n\t\t\t     const struct sockcm_cookie *sockc)\n{\n\tstruct inet_cork_full cork;\n\tstruct inet6_cork v6_cork;\n\tstruct sk_buff_head queue;\n\tint exthdrlen = (ipc6->opt ? ipc6->opt->opt_flen : 0);\n\tint err;\n\n\tif (flags & MSG_PROBE)\n\t\treturn NULL;\n\n\t__skb_queue_head_init(&queue);\n\n\tcork.base.flags = 0;\n\tcork.base.addr = 0;\n\tcork.base.opt = NULL;\n\tv6_cork.opt = NULL;\n\terr = ip6_setup_cork(sk, &cork, &v6_cork, ipc6, rt, fl6);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif (ipc6->dontfrag < 0)\n\t\tipc6->dontfrag = inet6_sk(sk)->dontfrag;\n\n\terr = __ip6_append_data(sk, fl6, &queue, &cork.base, &v6_cork,\n\t\t\t\t&current->task_frag, getfrag, from,\n\t\t\t\tlength + exthdrlen, transhdrlen + exthdrlen,\n\t\t\t\tflags, ipc6, sockc);\n\tif (err) {\n\t\t__ip6_flush_pending_frames(sk, &queue, &cork, &v6_cork);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn __ip6_make_skb(sk, &queue, &cork, &v6_cork);\n}\n"], "fixing_code": ["/*\n *\tIPv6 output functions\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tBased on linux/net/ipv4/ip_output.c\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n *\n *\tChanges:\n *\tA.N.Kuznetsov\t:\tairthmetics in fragmentation.\n *\t\t\t\textension headers are implemented.\n *\t\t\t\troute changes now work.\n *\t\t\t\tip6_forward does not confuse sniffers.\n *\t\t\t\tetc.\n *\n *      H. von Brand    :       Added missing #include <linux/string.h>\n *\tImran Patel\t:\tfrag id should be in NBO\n *      Kazunori MIYAZAWA @USAGI\n *\t\t\t:       add ip6_append_data and related functions\n *\t\t\t\tfor datagram xmit\n */\n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/in6.h>\n#include <linux/tcp.h>\n#include <linux/route.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <linux/bpf-cgroup.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv6.h>\n\n#include <net/sock.h>\n#include <net/snmp.h>\n\n#include <net/ipv6.h>\n#include <net/ndisc.h>\n#include <net/protocol.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/rawv6.h>\n#include <net/icmp.h>\n#include <net/xfrm.h>\n#include <net/checksum.h>\n#include <linux/mroute6.h>\n#include <net/l3mdev.h>\n#include <net/lwtunnel.h>\n\nstatic int ip6_finish_output2(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct net_device *dev = dst->dev;\n\tstruct neighbour *neigh;\n\tstruct in6_addr *nexthop;\n\tint ret;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\tskb->dev = dev;\n\n\tif (ipv6_addr_is_multicast(&ipv6_hdr(skb)->daddr)) {\n\t\tstruct inet6_dev *idev = ip6_dst_idev(skb_dst(skb));\n\n\t\tif (!(dev->flags & IFF_LOOPBACK) && sk_mc_loop(sk) &&\n\t\t    ((mroute6_socket(net, skb) &&\n\t\t     !(IP6CB(skb)->flags & IP6SKB_FORWARDED)) ||\n\t\t     ipv6_chk_mcast_addr(dev, &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t &ipv6_hdr(skb)->saddr))) {\n\t\t\tstruct sk_buff *newskb = skb_clone(skb, GFP_ATOMIC);\n\n\t\t\t/* Do not check for IFF_ALLMULTI; multicast routing\n\t\t\t   is not supported in any case.\n\t\t\t */\n\t\t\tif (newskb)\n\t\t\t\tNF_HOOK(NFPROTO_IPV6, NF_INET_POST_ROUTING,\n\t\t\t\t\tnet, sk, newskb, NULL, newskb->dev,\n\t\t\t\t\tdev_loopback_xmit);\n\n\t\t\tif (ipv6_hdr(skb)->hop_limit == 0) {\n\t\t\t\tIP6_INC_STATS(net, idev,\n\t\t\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tIP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_OUTMCAST, skb->len);\n\n\t\tif (IPV6_ADDR_MC_SCOPE(&ipv6_hdr(skb)->daddr) <=\n\t\t    IPV6_ADDR_SCOPE_NODELOCAL &&\n\t\t    !(dev->flags & IFF_LOOPBACK)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (lwtunnel_xmit_redirect(dst->lwtstate)) {\n\t\tint res = lwtunnel_xmit(skb);\n\n\t\tif (res < 0 || res == LWTUNNEL_XMIT_DONE)\n\t\t\treturn res;\n\t}\n\n\trcu_read_lock_bh();\n\tnexthop = rt6_nexthop((struct rt6_info *)dst, &ipv6_hdr(skb)->daddr);\n\tneigh = __ipv6_neigh_lookup_noref(dst->dev, nexthop);\n\tif (unlikely(!neigh))\n\t\tneigh = __neigh_create(&nd_tbl, nexthop, dst->dev, false);\n\tif (!IS_ERR(neigh)) {\n\t\tsock_confirm_neigh(skb, neigh);\n\t\tret = neigh_output(neigh, skb);\n\t\trcu_read_unlock_bh();\n\t\treturn ret;\n\t}\n\trcu_read_unlock_bh();\n\n\tIP6_INC_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_OUTNOROUTES);\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic int ip6_finish_output(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tint ret;\n\n\tret = BPF_CGROUP_RUN_PROG_INET_EGRESS(sk, skb);\n\tif (ret) {\n\t\tkfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tif ((skb->len > ip6_skb_dst_mtu(skb) && !skb_is_gso(skb)) ||\n\t    dst_allfrag(skb_dst(skb)) ||\n\t    (IP6CB(skb)->frag_max_size && skb->len > IP6CB(skb)->frag_max_size))\n\t\treturn ip6_fragment(net, sk, skb, ip6_finish_output2);\n\telse\n\t\treturn ip6_finish_output2(net, sk, skb);\n}\n\nint ip6_output(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb_dst(skb)->dev;\n\tstruct inet6_dev *idev = ip6_dst_idev(skb_dst(skb));\n\n\tif (unlikely(idev->cnf.disable_ipv6)) {\n\t\tIP6_INC_STATS(net, idev, IPSTATS_MIB_OUTDISCARDS);\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\treturn NF_HOOK_COND(NFPROTO_IPV6, NF_INET_POST_ROUTING,\n\t\t\t    net, sk, skb, NULL, dev,\n\t\t\t    ip6_finish_output,\n\t\t\t    !(IP6CB(skb)->flags & IP6SKB_REROUTED));\n}\n\n/*\n * xmit an sk_buff (used by TCP, SCTP and DCCP)\n * Note : socket lock is not held for SYNACK packets, but might be modified\n * by calls to skb_set_owner_w() and ipv6_local_error(),\n * which are using proper atomic operations or spinlocks.\n */\nint ip6_xmit(const struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6,\n\t     __u32 mark, struct ipv6_txoptions *opt, int tclass)\n{\n\tstruct net *net = sock_net(sk);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *first_hop = &fl6->daddr;\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct ipv6hdr *hdr;\n\tu8  proto = fl6->flowi6_proto;\n\tint seg_len = skb->len;\n\tint hlimit = -1;\n\tu32 mtu;\n\n\tif (opt) {\n\t\tunsigned int head_room;\n\n\t\t/* First: exthdrs may take lots of space (~8K for now)\n\t\t   MAX_HEADER is not enough.\n\t\t */\n\t\thead_room = opt->opt_nflen + opt->opt_flen;\n\t\tseg_len += head_room;\n\t\thead_room += sizeof(struct ipv6hdr) + LL_RESERVED_SPACE(dst->dev);\n\n\t\tif (skb_headroom(skb) < head_room) {\n\t\t\tstruct sk_buff *skb2 = skb_realloc_headroom(skb, head_room);\n\t\t\tif (!skb2) {\n\t\t\t\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn -ENOBUFS;\n\t\t\t}\n\t\t\tconsume_skb(skb);\n\t\t\tskb = skb2;\n\t\t\t/* skb_set_owner_w() changes sk->sk_wmem_alloc atomically,\n\t\t\t * it is safe to call in our context (socket lock not held)\n\t\t\t */\n\t\t\tskb_set_owner_w(skb, (struct sock *)sk);\n\t\t}\n\t\tif (opt->opt_flen)\n\t\t\tipv6_push_frag_opts(skb, opt, &proto);\n\t\tif (opt->opt_nflen)\n\t\t\tipv6_push_nfrag_opts(skb, opt, &proto, &first_hop,\n\t\t\t\t\t     &fl6->saddr);\n\t}\n\n\tskb_push(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\thdr = ipv6_hdr(skb);\n\n\t/*\n\t *\tFill in the IPv6 header\n\t */\n\tif (np)\n\t\thlimit = np->hop_limit;\n\tif (hlimit < 0)\n\t\thlimit = ip6_dst_hoplimit(dst);\n\n\tip6_flow_hdr(hdr, tclass, ip6_make_flowlabel(net, skb, fl6->flowlabel,\n\t\t\t\t\t\t     np->autoflowlabel, fl6));\n\n\thdr->payload_len = htons(seg_len);\n\thdr->nexthdr = proto;\n\thdr->hop_limit = hlimit;\n\n\thdr->saddr = fl6->saddr;\n\thdr->daddr = *first_hop;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\tskb->priority = sk->sk_priority;\n\tskb->mark = mark;\n\n\tmtu = dst_mtu(dst);\n\tif ((skb->len <= mtu) || skb->ignore_df || skb_is_gso(skb)) {\n\t\tIP6_UPD_PO_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t      IPSTATS_MIB_OUT, skb->len);\n\n\t\t/* if egress device is enslaved to an L3 master device pass the\n\t\t * skb to its handler for processing\n\t\t */\n\t\tskb = l3mdev_ip6_out((struct sock *)sk, skb);\n\t\tif (unlikely(!skb))\n\t\t\treturn 0;\n\n\t\t/* hooks should never assume socket lock is held.\n\t\t * we promote our socket to non const\n\t\t */\n\t\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT,\n\t\t\t       net, (struct sock *)sk, skb, NULL, dst->dev,\n\t\t\t       dst_output);\n\t}\n\n\tskb->dev = dst->dev;\n\t/* ipv6_local_error() does not require socket lock,\n\t * we promote our socket to non const\n\t */\n\tipv6_local_error((struct sock *)sk, EMSGSIZE, fl6, mtu);\n\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_FRAGFAILS);\n\tkfree_skb(skb);\n\treturn -EMSGSIZE;\n}\nEXPORT_SYMBOL(ip6_xmit);\n\nstatic int ip6_call_ra_chain(struct sk_buff *skb, int sel)\n{\n\tstruct ip6_ra_chain *ra;\n\tstruct sock *last = NULL;\n\n\tread_lock(&ip6_ra_lock);\n\tfor (ra = ip6_ra_chain; ra; ra = ra->next) {\n\t\tstruct sock *sk = ra->sk;\n\t\tif (sk && ra->sel == sel &&\n\t\t    (!sk->sk_bound_dev_if ||\n\t\t     sk->sk_bound_dev_if == skb->dev->ifindex)) {\n\t\t\tif (last) {\n\t\t\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\tif (skb2)\n\t\t\t\t\trawv6_rcv(last, skb2);\n\t\t\t}\n\t\t\tlast = sk;\n\t\t}\n\t}\n\n\tif (last) {\n\t\trawv6_rcv(last, skb);\n\t\tread_unlock(&ip6_ra_lock);\n\t\treturn 1;\n\t}\n\tread_unlock(&ip6_ra_lock);\n\treturn 0;\n}\n\nstatic int ip6_forward_proxy_check(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\tu8 nexthdr = hdr->nexthdr;\n\t__be16 frag_off;\n\tint offset;\n\n\tif (ipv6_ext_hdr(nexthdr)) {\n\t\toffset = ipv6_skip_exthdr(skb, sizeof(*hdr), &nexthdr, &frag_off);\n\t\tif (offset < 0)\n\t\t\treturn 0;\n\t} else\n\t\toffset = sizeof(struct ipv6hdr);\n\n\tif (nexthdr == IPPROTO_ICMPV6) {\n\t\tstruct icmp6hdr *icmp6;\n\n\t\tif (!pskb_may_pull(skb, (skb_network_header(skb) +\n\t\t\t\t\t offset + 1 - skb->data)))\n\t\t\treturn 0;\n\n\t\ticmp6 = (struct icmp6hdr *)(skb_network_header(skb) + offset);\n\n\t\tswitch (icmp6->icmp6_type) {\n\t\tcase NDISC_ROUTER_SOLICITATION:\n\t\tcase NDISC_ROUTER_ADVERTISEMENT:\n\t\tcase NDISC_NEIGHBOUR_SOLICITATION:\n\t\tcase NDISC_NEIGHBOUR_ADVERTISEMENT:\n\t\tcase NDISC_REDIRECT:\n\t\t\t/* For reaction involving unicast neighbor discovery\n\t\t\t * message destined to the proxied address, pass it to\n\t\t\t * input function.\n\t\t\t */\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * The proxying router can't forward traffic sent to a link-local\n\t * address, so signal the sender and discard the packet. This\n\t * behavior is clarified by the MIPv6 specification.\n\t */\n\tif (ipv6_addr_type(&hdr->daddr) & IPV6_ADDR_LINKLOCAL) {\n\t\tdst_link_failure(skb);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int ip6_forward_finish(struct net *net, struct sock *sk,\n\t\t\t\t     struct sk_buff *skb)\n{\n\treturn dst_output(net, sk, skb);\n}\n\nstatic unsigned int ip6_dst_mtu_forward(const struct dst_entry *dst)\n{\n\tunsigned int mtu;\n\tstruct inet6_dev *idev;\n\n\tif (dst_metric_locked(dst, RTAX_MTU)) {\n\t\tmtu = dst_metric_raw(dst, RTAX_MTU);\n\t\tif (mtu)\n\t\t\treturn mtu;\n\t}\n\n\tmtu = IPV6_MIN_MTU;\n\trcu_read_lock();\n\tidev = __in6_dev_get(dst->dev);\n\tif (idev)\n\t\tmtu = idev->cnf.mtu6;\n\trcu_read_unlock();\n\n\treturn mtu;\n}\n\nstatic bool ip6_pkt_too_big(const struct sk_buff *skb, unsigned int mtu)\n{\n\tif (skb->len <= mtu)\n\t\treturn false;\n\n\t/* ipv6 conntrack defrag sets max_frag_size + ignore_df */\n\tif (IP6CB(skb)->frag_max_size && IP6CB(skb)->frag_max_size > mtu)\n\t\treturn true;\n\n\tif (skb->ignore_df)\n\t\treturn false;\n\n\tif (skb_is_gso(skb) && skb_gso_validate_mtu(skb, mtu))\n\t\treturn false;\n\n\treturn true;\n}\n\nint ip6_forward(struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tstruct net *net = dev_net(dst->dev);\n\tu32 mtu;\n\n\tif (net->ipv6.devconf_all->forwarding == 0)\n\t\tgoto error;\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto drop;\n\n\tif (unlikely(skb->sk))\n\t\tgoto drop;\n\n\tif (skb_warn_if_lro(skb))\n\t\tgoto drop;\n\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_FWD, skb)) {\n\t\t__IP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t\tIPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\n\tskb_forward_csum(skb);\n\n\t/*\n\t *\tWe DO NOT make any processing on\n\t *\tRA packets, pushing them to user level AS IS\n\t *\twithout ane WARRANTY that application will be able\n\t *\tto interpret them. The reason is that we\n\t *\tcannot make anything clever here.\n\t *\n\t *\tWe are not end-node, so that if packet contains\n\t *\tAH/ESP, we cannot make anything.\n\t *\tDefragmentation also would be mistake, RA packets\n\t *\tcannot be fragmented, because there is no warranty\n\t *\tthat different fragments will go along one path. --ANK\n\t */\n\tif (unlikely(opt->flags & IP6SKB_ROUTERALERT)) {\n\t\tif (ip6_call_ra_chain(skb, ntohs(opt->ra)))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t *\tcheck and decrement ttl\n\t */\n\tif (hdr->hop_limit <= 1) {\n\t\t/* Force OUTPUT device used as source address */\n\t\tskb->dev = dst->dev;\n\t\ticmpv6_send(skb, ICMPV6_TIME_EXCEED, ICMPV6_EXC_HOPLIMIT, 0);\n\t\t__IP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t\tIPSTATS_MIB_INHDRERRORS);\n\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t/* XXX: idev->cnf.proxy_ndp? */\n\tif (net->ipv6.devconf_all->proxy_ndp &&\n\t    pneigh_lookup(&nd_tbl, net, &hdr->daddr, skb->dev, 0)) {\n\t\tint proxied = ip6_forward_proxy_check(skb);\n\t\tif (proxied > 0)\n\t\t\treturn ip6_input(skb);\n\t\telse if (proxied < 0) {\n\t\t\t__IP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t\t\tIPSTATS_MIB_INDISCARDS);\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (!xfrm6_route_forward(skb)) {\n\t\t__IP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t\tIPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\tdst = skb_dst(skb);\n\n\t/* IPv6 specs say nothing about it, but it is clear that we cannot\n\t   send redirects to source routed frames.\n\t   We don't send redirects to frames decapsulated from IPsec.\n\t */\n\tif (skb->dev == dst->dev && opt->srcrt == 0 && !skb_sec_path(skb)) {\n\t\tstruct in6_addr *target = NULL;\n\t\tstruct inet_peer *peer;\n\t\tstruct rt6_info *rt;\n\n\t\t/*\n\t\t *\tincoming and outgoing devices are the same\n\t\t *\tsend a redirect.\n\t\t */\n\n\t\trt = (struct rt6_info *) dst;\n\t\tif (rt->rt6i_flags & RTF_GATEWAY)\n\t\t\ttarget = &rt->rt6i_gateway;\n\t\telse\n\t\t\ttarget = &hdr->daddr;\n\n\t\tpeer = inet_getpeer_v6(net->ipv6.peers, &hdr->daddr, 1);\n\n\t\t/* Limit redirects both by destination (here)\n\t\t   and by source (inside ndisc_send_redirect)\n\t\t */\n\t\tif (inet_peer_xrlim_allow(peer, 1*HZ))\n\t\t\tndisc_send_redirect(skb, target);\n\t\tif (peer)\n\t\t\tinet_putpeer(peer);\n\t} else {\n\t\tint addrtype = ipv6_addr_type(&hdr->saddr);\n\n\t\t/* This check is security critical. */\n\t\tif (addrtype == IPV6_ADDR_ANY ||\n\t\t    addrtype & (IPV6_ADDR_MULTICAST | IPV6_ADDR_LOOPBACK))\n\t\t\tgoto error;\n\t\tif (addrtype & IPV6_ADDR_LINKLOCAL) {\n\t\t\ticmpv6_send(skb, ICMPV6_DEST_UNREACH,\n\t\t\t\t    ICMPV6_NOT_NEIGHBOUR, 0);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tmtu = ip6_dst_mtu_forward(dst);\n\tif (mtu < IPV6_MIN_MTU)\n\t\tmtu = IPV6_MIN_MTU;\n\n\tif (ip6_pkt_too_big(skb, mtu)) {\n\t\t/* Again, force OUTPUT device used as source address */\n\t\tskb->dev = dst->dev;\n\t\ticmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\n\t\t__IP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t\tIPSTATS_MIB_INTOOBIGERRORS);\n\t\t__IP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t\tIPSTATS_MIB_FRAGFAILS);\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (skb_cow(skb, dst->dev->hard_header_len)) {\n\t\t__IP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t\tIPSTATS_MIB_OUTDISCARDS);\n\t\tgoto drop;\n\t}\n\n\thdr = ipv6_hdr(skb);\n\n\t/* Mangling hops number delayed to point after skb COW */\n\n\thdr->hop_limit--;\n\n\t__IP6_INC_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_OUTFORWDATAGRAMS);\n\t__IP6_ADD_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_OUTOCTETS, skb->len);\n\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_FORWARD,\n\t\t       net, NULL, skb, skb->dev, dst->dev,\n\t\t       ip6_forward_finish);\n\nerror:\n\t__IP6_INC_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_INADDRERRORS);\ndrop:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic void ip6_copy_metadata(struct sk_buff *to, struct sk_buff *from)\n{\n\tto->pkt_type = from->pkt_type;\n\tto->priority = from->priority;\n\tto->protocol = from->protocol;\n\tskb_dst_drop(to);\n\tskb_dst_set(to, dst_clone(skb_dst(from)));\n\tto->dev = from->dev;\n\tto->mark = from->mark;\n\n#ifdef CONFIG_NET_SCHED\n\tto->tc_index = from->tc_index;\n#endif\n\tnf_copy(to, from);\n\tskb_copy_secmark(to, from);\n}\n\nint ip6_fragment(struct net *net, struct sock *sk, struct sk_buff *skb,\n\t\t int (*output)(struct net *, struct sock *, struct sk_buff *))\n{\n\tstruct sk_buff *frag;\n\tstruct rt6_info *rt = (struct rt6_info *)skb_dst(skb);\n\tstruct ipv6_pinfo *np = skb->sk && !dev_recursion_level() ?\n\t\t\t\tinet6_sk(skb->sk) : NULL;\n\tstruct ipv6hdr *tmp_hdr;\n\tstruct frag_hdr *fh;\n\tunsigned int mtu, hlen, left, len;\n\tint hroom, troom;\n\t__be32 frag_id;\n\tint ptr, offset = 0, err = 0;\n\tu8 *prevhdr, nexthdr = 0;\n\n\terr = ip6_find_1stfragopt(skb, &prevhdr);\n\tif (err < 0)\n\t\tgoto fail;\n\thlen = err;\n\tnexthdr = *prevhdr;\n\n\tmtu = ip6_skb_dst_mtu(skb);\n\n\t/* We must not fragment if the socket is set to force MTU discovery\n\t * or if the skb it not generated by a local socket.\n\t */\n\tif (unlikely(!skb->ignore_df && skb->len > mtu))\n\t\tgoto fail_toobig;\n\n\tif (IP6CB(skb)->frag_max_size) {\n\t\tif (IP6CB(skb)->frag_max_size > mtu)\n\t\t\tgoto fail_toobig;\n\n\t\t/* don't send fragments larger than what we received */\n\t\tmtu = IP6CB(skb)->frag_max_size;\n\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\tmtu = IPV6_MIN_MTU;\n\t}\n\n\tif (np && np->frag_size < mtu) {\n\t\tif (np->frag_size)\n\t\t\tmtu = np->frag_size;\n\t}\n\tif (mtu < hlen + sizeof(struct frag_hdr) + 8)\n\t\tgoto fail_toobig;\n\tmtu -= hlen + sizeof(struct frag_hdr);\n\n\tfrag_id = ipv6_select_ident(net, &ipv6_hdr(skb)->daddr,\n\t\t\t\t    &ipv6_hdr(skb)->saddr);\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL &&\n\t    (err = skb_checksum_help(skb)))\n\t\tgoto fail;\n\n\throom = LL_RESERVED_SPACE(rt->dst.dev);\n\tif (skb_has_frag_list(skb)) {\n\t\tunsigned int first_len = skb_pagelen(skb);\n\t\tstruct sk_buff *frag2;\n\n\t\tif (first_len - hlen > mtu ||\n\t\t    ((first_len - hlen) & 7) ||\n\t\t    skb_cloned(skb) ||\n\t\t    skb_headroom(skb) < (hroom + sizeof(struct frag_hdr)))\n\t\t\tgoto slow_path;\n\n\t\tskb_walk_frags(skb, frag) {\n\t\t\t/* Correct geometry. */\n\t\t\tif (frag->len > mtu ||\n\t\t\t    ((frag->len & 7) && frag->next) ||\n\t\t\t    skb_headroom(frag) < (hlen + hroom + sizeof(struct frag_hdr)))\n\t\t\t\tgoto slow_path_clean;\n\n\t\t\t/* Partially cloned skb? */\n\t\t\tif (skb_shared(frag))\n\t\t\t\tgoto slow_path_clean;\n\n\t\t\tBUG_ON(frag->sk);\n\t\t\tif (skb->sk) {\n\t\t\t\tfrag->sk = skb->sk;\n\t\t\t\tfrag->destructor = sock_wfree;\n\t\t\t}\n\t\t\tskb->truesize -= frag->truesize;\n\t\t}\n\n\t\terr = 0;\n\t\toffset = 0;\n\t\t/* BUILD HEADER */\n\n\t\t*prevhdr = NEXTHDR_FRAGMENT;\n\t\ttmp_hdr = kmemdup(skb_network_header(skb), hlen, GFP_ATOMIC);\n\t\tif (!tmp_hdr) {\n\t\t\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t      IPSTATS_MIB_FRAGFAILS);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tfrag = skb_shinfo(skb)->frag_list;\n\t\tskb_frag_list_init(skb);\n\n\t\t__skb_pull(skb, hlen);\n\t\tfh = (struct frag_hdr *)__skb_push(skb, sizeof(struct frag_hdr));\n\t\t__skb_push(skb, hlen);\n\t\tskb_reset_network_header(skb);\n\t\tmemcpy(skb_network_header(skb), tmp_hdr, hlen);\n\n\t\tfh->nexthdr = nexthdr;\n\t\tfh->reserved = 0;\n\t\tfh->frag_off = htons(IP6_MF);\n\t\tfh->identification = frag_id;\n\n\t\tfirst_len = skb_pagelen(skb);\n\t\tskb->data_len = first_len - skb_headlen(skb);\n\t\tskb->len = first_len;\n\t\tipv6_hdr(skb)->payload_len = htons(first_len -\n\t\t\t\t\t\t   sizeof(struct ipv6hdr));\n\n\t\tdst_hold(&rt->dst);\n\n\t\tfor (;;) {\n\t\t\t/* Prepare header of the next frame,\n\t\t\t * before previous one went down. */\n\t\t\tif (frag) {\n\t\t\t\tfrag->ip_summed = CHECKSUM_NONE;\n\t\t\t\tskb_reset_transport_header(frag);\n\t\t\t\tfh = (struct frag_hdr *)__skb_push(frag, sizeof(struct frag_hdr));\n\t\t\t\t__skb_push(frag, hlen);\n\t\t\t\tskb_reset_network_header(frag);\n\t\t\t\tmemcpy(skb_network_header(frag), tmp_hdr,\n\t\t\t\t       hlen);\n\t\t\t\toffset += skb->len - hlen - sizeof(struct frag_hdr);\n\t\t\t\tfh->nexthdr = nexthdr;\n\t\t\t\tfh->reserved = 0;\n\t\t\t\tfh->frag_off = htons(offset);\n\t\t\t\tif (frag->next)\n\t\t\t\t\tfh->frag_off |= htons(IP6_MF);\n\t\t\t\tfh->identification = frag_id;\n\t\t\t\tipv6_hdr(frag)->payload_len =\n\t\t\t\t\t\thtons(frag->len -\n\t\t\t\t\t\t      sizeof(struct ipv6hdr));\n\t\t\t\tip6_copy_metadata(frag, skb);\n\t\t\t}\n\n\t\t\terr = output(net, sk, skb);\n\t\t\tif (!err)\n\t\t\t\tIP6_INC_STATS(net, ip6_dst_idev(&rt->dst),\n\t\t\t\t\t      IPSTATS_MIB_FRAGCREATES);\n\n\t\t\tif (err || !frag)\n\t\t\t\tbreak;\n\n\t\t\tskb = frag;\n\t\t\tfrag = skb->next;\n\t\t\tskb->next = NULL;\n\t\t}\n\n\t\tkfree(tmp_hdr);\n\n\t\tif (err == 0) {\n\t\t\tIP6_INC_STATS(net, ip6_dst_idev(&rt->dst),\n\t\t\t\t      IPSTATS_MIB_FRAGOKS);\n\t\t\tip6_rt_put(rt);\n\t\t\treturn 0;\n\t\t}\n\n\t\tkfree_skb_list(frag);\n\n\t\tIP6_INC_STATS(net, ip6_dst_idev(&rt->dst),\n\t\t\t      IPSTATS_MIB_FRAGFAILS);\n\t\tip6_rt_put(rt);\n\t\treturn err;\n\nslow_path_clean:\n\t\tskb_walk_frags(skb, frag2) {\n\t\t\tif (frag2 == frag)\n\t\t\t\tbreak;\n\t\t\tfrag2->sk = NULL;\n\t\t\tfrag2->destructor = NULL;\n\t\t\tskb->truesize += frag2->truesize;\n\t\t}\n\t}\n\nslow_path:\n\tleft = skb->len - hlen;\t\t/* Space per frame */\n\tptr = hlen;\t\t\t/* Where to start from */\n\n\t/*\n\t *\tFragment the datagram.\n\t */\n\n\ttroom = rt->dst.dev->needed_tailroom;\n\n\t/*\n\t *\tKeep copying data until we run out.\n\t */\n\twhile (left > 0)\t{\n\t\tu8 *fragnexthdr_offset;\n\n\t\tlen = left;\n\t\t/* IF: it doesn't fit, use 'mtu' - the data space left */\n\t\tif (len > mtu)\n\t\t\tlen = mtu;\n\t\t/* IF: we are not sending up to and including the packet end\n\t\t   then align the next start on an eight byte boundary */\n\t\tif (len < left)\t{\n\t\t\tlen &= ~7;\n\t\t}\n\n\t\t/* Allocate buffer */\n\t\tfrag = alloc_skb(len + hlen + sizeof(struct frag_hdr) +\n\t\t\t\t hroom + troom, GFP_ATOMIC);\n\t\tif (!frag) {\n\t\t\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t      IPSTATS_MIB_FRAGFAILS);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t *\tSet up data on packet\n\t\t */\n\n\t\tip6_copy_metadata(frag, skb);\n\t\tskb_reserve(frag, hroom);\n\t\tskb_put(frag, len + hlen + sizeof(struct frag_hdr));\n\t\tskb_reset_network_header(frag);\n\t\tfh = (struct frag_hdr *)(skb_network_header(frag) + hlen);\n\t\tfrag->transport_header = (frag->network_header + hlen +\n\t\t\t\t\t  sizeof(struct frag_hdr));\n\n\t\t/*\n\t\t *\tCharge the memory for the fragment to any owner\n\t\t *\tit might possess\n\t\t */\n\t\tif (skb->sk)\n\t\t\tskb_set_owner_w(frag, skb->sk);\n\n\t\t/*\n\t\t *\tCopy the packet header into the new buffer.\n\t\t */\n\t\tskb_copy_from_linear_data(skb, skb_network_header(frag), hlen);\n\n\t\tfragnexthdr_offset = skb_network_header(frag);\n\t\tfragnexthdr_offset += prevhdr - skb_network_header(skb);\n\t\t*fragnexthdr_offset = NEXTHDR_FRAGMENT;\n\n\t\t/*\n\t\t *\tBuild fragment header.\n\t\t */\n\t\tfh->nexthdr = nexthdr;\n\t\tfh->reserved = 0;\n\t\tfh->identification = frag_id;\n\n\t\t/*\n\t\t *\tCopy a block of the IP datagram.\n\t\t */\n\t\tBUG_ON(skb_copy_bits(skb, ptr, skb_transport_header(frag),\n\t\t\t\t     len));\n\t\tleft -= len;\n\n\t\tfh->frag_off = htons(offset);\n\t\tif (left > 0)\n\t\t\tfh->frag_off |= htons(IP6_MF);\n\t\tipv6_hdr(frag)->payload_len = htons(frag->len -\n\t\t\t\t\t\t    sizeof(struct ipv6hdr));\n\n\t\tptr += len;\n\t\toffset += len;\n\n\t\t/*\n\t\t *\tPut this fragment into the sending queue.\n\t\t */\n\t\terr = output(net, sk, frag);\n\t\tif (err)\n\t\t\tgoto fail;\n\n\t\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t      IPSTATS_MIB_FRAGCREATES);\n\t}\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t      IPSTATS_MIB_FRAGOKS);\n\tconsume_skb(skb);\n\treturn err;\n\nfail_toobig:\n\tif (skb->sk && dst_allfrag(skb_dst(skb)))\n\t\tsk_nocaps_add(skb->sk, NETIF_F_GSO_MASK);\n\n\tskb->dev = skb_dst(skb)->dev;\n\ticmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\n\terr = -EMSGSIZE;\n\nfail:\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t      IPSTATS_MIB_FRAGFAILS);\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic inline int ip6_rt_check(const struct rt6key *rt_key,\n\t\t\t       const struct in6_addr *fl_addr,\n\t\t\t       const struct in6_addr *addr_cache)\n{\n\treturn (rt_key->plen != 128 || !ipv6_addr_equal(fl_addr, &rt_key->addr)) &&\n\t\t(!addr_cache || !ipv6_addr_equal(fl_addr, addr_cache));\n}\n\nstatic struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  const struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt;\n\n\tif (!dst)\n\t\tgoto out;\n\n\tif (dst->ops->family != AF_INET6) {\n\t\tdst_release(dst);\n\t\treturn NULL;\n\t}\n\n\trt = (struct rt6_info *)dst;\n\t/* Yes, checking route validity in not connected\n\t * case is not very simple. Take into account,\n\t * that we do not support routing by source, TOS,\n\t * and MSG_DONTROUTE\t\t--ANK (980726)\n\t *\n\t * 1. ip6_rt_check(): If route was host route,\n\t *    check that cached destination is current.\n\t *    If it is network route, we still may\n\t *    check its validity using saved pointer\n\t *    to the last used address: daddr_cache.\n\t *    We do not want to save whole address now,\n\t *    (because main consumer of this service\n\t *    is tcp, which has not this problem),\n\t *    so that the last trick works only on connected\n\t *    sockets.\n\t * 2. oif also should be the same.\n\t */\n\tif (ip6_rt_check(&rt->rt6i_dst, &fl6->daddr, np->daddr_cache) ||\n#ifdef CONFIG_IPV6_SUBTREES\n\t    ip6_rt_check(&rt->rt6i_src, &fl6->saddr, np->saddr_cache) ||\n#endif\n\t   (!(fl6->flowi6_flags & FLOWI_FLAG_SKIP_NH_OIF) &&\n\t      (fl6->flowi6_oif && fl6->flowi6_oif != dst->dev->ifindex))) {\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\n\nout:\n\treturn dst;\n}\n\nstatic int ip6_dst_lookup_tail(struct net *net, const struct sock *sk,\n\t\t\t       struct dst_entry **dst, struct flowi6 *fl6)\n{\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\n\tstruct neighbour *n;\n\tstruct rt6_info *rt;\n#endif\n\tint err;\n\tint flags = 0;\n\n\t/* The correct way to handle this would be to do\n\t * ip6_route_get_saddr, and then ip6_route_output; however,\n\t * the route-specific preferred source forces the\n\t * ip6_route_output call _before_ ip6_route_get_saddr.\n\t *\n\t * In source specific routing (no src=any default route),\n\t * ip6_route_output will fail given src=any saddr, though, so\n\t * that's why we try it again later.\n\t */\n\tif (ipv6_addr_any(&fl6->saddr) && (!*dst || !(*dst)->error)) {\n\t\tstruct rt6_info *rt;\n\t\tbool had_dst = *dst != NULL;\n\n\t\tif (!had_dst)\n\t\t\t*dst = ip6_route_output(net, sk, fl6);\n\t\trt = (*dst)->error ? NULL : (struct rt6_info *)*dst;\n\t\terr = ip6_route_get_saddr(net, rt, &fl6->daddr,\n\t\t\t\t\t  sk ? inet6_sk(sk)->srcprefs : 0,\n\t\t\t\t\t  &fl6->saddr);\n\t\tif (err)\n\t\t\tgoto out_err_release;\n\n\t\t/* If we had an erroneous initial result, pretend it\n\t\t * never existed and let the SA-enabled version take\n\t\t * over.\n\t\t */\n\t\tif (!had_dst && (*dst)->error) {\n\t\t\tdst_release(*dst);\n\t\t\t*dst = NULL;\n\t\t}\n\n\t\tif (fl6->flowi6_oif)\n\t\t\tflags |= RT6_LOOKUP_F_IFACE;\n\t}\n\n\tif (!*dst)\n\t\t*dst = ip6_route_output_flags(net, sk, fl6, flags);\n\n\terr = (*dst)->error;\n\tif (err)\n\t\tgoto out_err_release;\n\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\n\t/*\n\t * Here if the dst entry we've looked up\n\t * has a neighbour entry that is in the INCOMPLETE\n\t * state and the src address from the flow is\n\t * marked as OPTIMISTIC, we release the found\n\t * dst entry and replace it instead with the\n\t * dst entry of the nexthop router\n\t */\n\trt = (struct rt6_info *) *dst;\n\trcu_read_lock_bh();\n\tn = __ipv6_neigh_lookup_noref(rt->dst.dev,\n\t\t\t\t      rt6_nexthop(rt, &fl6->daddr));\n\terr = n && !(n->nud_state & NUD_VALID) ? -EINVAL : 0;\n\trcu_read_unlock_bh();\n\n\tif (err) {\n\t\tstruct inet6_ifaddr *ifp;\n\t\tstruct flowi6 fl_gw6;\n\t\tint redirect;\n\n\t\tifp = ipv6_get_ifaddr(net, &fl6->saddr,\n\t\t\t\t      (*dst)->dev, 1);\n\n\t\tredirect = (ifp && ifp->flags & IFA_F_OPTIMISTIC);\n\t\tif (ifp)\n\t\t\tin6_ifa_put(ifp);\n\n\t\tif (redirect) {\n\t\t\t/*\n\t\t\t * We need to get the dst entry for the\n\t\t\t * default router instead\n\t\t\t */\n\t\t\tdst_release(*dst);\n\t\t\tmemcpy(&fl_gw6, fl6, sizeof(struct flowi6));\n\t\t\tmemset(&fl_gw6.daddr, 0, sizeof(struct in6_addr));\n\t\t\t*dst = ip6_route_output(net, sk, &fl_gw6);\n\t\t\terr = (*dst)->error;\n\t\t\tif (err)\n\t\t\t\tgoto out_err_release;\n\t\t}\n\t}\n#endif\n\tif (ipv6_addr_v4mapped(&fl6->saddr) &&\n\t    !(ipv6_addr_v4mapped(&fl6->daddr) || ipv6_addr_any(&fl6->daddr))) {\n\t\terr = -EAFNOSUPPORT;\n\t\tgoto out_err_release;\n\t}\n\n\treturn 0;\n\nout_err_release:\n\tdst_release(*dst);\n\t*dst = NULL;\n\n\tif (err == -ENETUNREACH)\n\t\tIP6_INC_STATS(net, NULL, IPSTATS_MIB_OUTNOROUTES);\n\treturn err;\n}\n\n/**\n *\tip6_dst_lookup - perform route lookup on flow\n *\t@sk: socket which provides route info\n *\t@dst: pointer to dst_entry * for result\n *\t@fl6: flow to lookup\n *\n *\tThis function performs a route lookup on the given flow.\n *\n *\tIt returns zero on success, or a standard errno code on error.\n */\nint ip6_dst_lookup(struct net *net, struct sock *sk, struct dst_entry **dst,\n\t\t   struct flowi6 *fl6)\n{\n\t*dst = NULL;\n\treturn ip6_dst_lookup_tail(net, sk, dst, fl6);\n}\nEXPORT_SYMBOL_GPL(ip6_dst_lookup);\n\n/**\n *\tip6_dst_lookup_flow - perform route lookup on flow with ipsec\n *\t@sk: socket which provides route info\n *\t@fl6: flow to lookup\n *\t@final_dst: final destination address for ipsec lookup\n *\n *\tThis function performs a route lookup on the given flow.\n *\n *\tIt returns a valid dst pointer on success, or a pointer encoded\n *\terror code.\n */\nstruct dst_entry *ip6_dst_lookup_flow(const struct sock *sk, struct flowi6 *fl6,\n\t\t\t\t      const struct in6_addr *final_dst)\n{\n\tstruct dst_entry *dst = NULL;\n\tint err;\n\n\terr = ip6_dst_lookup_tail(sock_net(sk), sk, &dst, fl6);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tif (final_dst)\n\t\tfl6->daddr = *final_dst;\n\n\treturn xfrm_lookup_route(sock_net(sk), dst, flowi6_to_flowi(fl6), sk, 0);\n}\nEXPORT_SYMBOL_GPL(ip6_dst_lookup_flow);\n\n/**\n *\tip6_sk_dst_lookup_flow - perform socket cached route lookup on flow\n *\t@sk: socket which provides the dst cache and route info\n *\t@fl6: flow to lookup\n *\t@final_dst: final destination address for ipsec lookup\n *\n *\tThis function performs a route lookup on the given flow with the\n *\tpossibility of using the cached route in the socket if it is valid.\n *\tIt will take the socket dst lock when operating on the dst cache.\n *\tAs a result, this function can only be used in process context.\n *\n *\tIt returns a valid dst pointer on success, or a pointer encoded\n *\terror code.\n */\nstruct dst_entry *ip6_sk_dst_lookup_flow(struct sock *sk, struct flowi6 *fl6,\n\t\t\t\t\t const struct in6_addr *final_dst)\n{\n\tstruct dst_entry *dst = sk_dst_check(sk, inet6_sk(sk)->dst_cookie);\n\n\tdst = ip6_sk_dst_check(sk, dst, fl6);\n\tif (!dst)\n\t\tdst = ip6_dst_lookup_flow(sk, fl6, final_dst);\n\n\treturn dst;\n}\nEXPORT_SYMBOL_GPL(ip6_sk_dst_lookup_flow);\n\nstatic inline int ip6_ufo_append_data(struct sock *sk,\n\t\t\tstruct sk_buff_head *queue,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\tint odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint exthdrlen, int transhdrlen, int mtu,\n\t\t\tunsigned int flags, const struct flowi6 *fl6)\n\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\t/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n\t * udp datagram\n\t */\n\tskb = skb_peek_tail(queue);\n\tif (!skb) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (!skb)\n\t\t\treturn err;\n\n\t\t/* reserve space for Hardware header */\n\t\tskb_reserve(skb, hh_len);\n\n\t\t/* create space for UDP/IP header */\n\t\tskb_put(skb, fragheaderlen + transhdrlen);\n\n\t\t/* initialize network header pointer */\n\t\tskb_set_network_header(skb, exthdrlen);\n\n\t\t/* initialize protocol header pointer */\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->csum = 0;\n\n\t\tif (flags & MSG_CONFIRM)\n\t\t\tskb_set_dst_pending_confirm(skb, 1);\n\n\t\t__skb_queue_tail(queue, skb);\n\t} else if (skb_is_gso(skb)) {\n\t\tgoto append;\n\t}\n\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t/* Specify the length of each IPv6 datagram fragment.\n\t * It has to be a multiple of 8.\n\t */\n\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\tskb_shinfo(skb)->ip6_frag_id = ipv6_select_ident(sock_net(sk),\n\t\t\t\t\t\t\t &fl6->daddr,\n\t\t\t\t\t\t\t &fl6->saddr);\n\nappend:\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}\n\nstatic inline struct ipv6_opt_hdr *ip6_opt_dup(struct ipv6_opt_hdr *src,\n\t\t\t\t\t       gfp_t gfp)\n{\n\treturn src ? kmemdup(src, (src->hdrlen + 1) * 8, gfp) : NULL;\n}\n\nstatic inline struct ipv6_rt_hdr *ip6_rthdr_dup(struct ipv6_rt_hdr *src,\n\t\t\t\t\t\tgfp_t gfp)\n{\n\treturn src ? kmemdup(src, (src->hdrlen + 1) * 8, gfp) : NULL;\n}\n\nstatic void ip6_append_data_mtu(unsigned int *mtu,\n\t\t\t\tint *maxfraglen,\n\t\t\t\tunsigned int fragheaderlen,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct rt6_info *rt,\n\t\t\t\tunsigned int orig_mtu)\n{\n\tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n\t\tif (!skb) {\n\t\t\t/* first fragment, reserve header_len */\n\t\t\t*mtu = orig_mtu - rt->dst.header_len;\n\n\t\t} else {\n\t\t\t/*\n\t\t\t * this fragment is not first, the headers\n\t\t\t * space is regarded as data space.\n\t\t\t */\n\t\t\t*mtu = orig_mtu;\n\t\t}\n\t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n\t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n\t}\n}\n\nstatic int ip6_setup_cork(struct sock *sk, struct inet_cork_full *cork,\n\t\t\t  struct inet6_cork *v6_cork, struct ipcm6_cookie *ipc6,\n\t\t\t  struct rt6_info *rt, struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tunsigned int mtu;\n\tstruct ipv6_txoptions *opt = ipc6->opt;\n\n\t/*\n\t * setup for corking\n\t */\n\tif (opt) {\n\t\tif (WARN_ON(v6_cork->opt))\n\t\t\treturn -EINVAL;\n\n\t\tv6_cork->opt = kzalloc(opt->tot_len, sk->sk_allocation);\n\t\tif (unlikely(!v6_cork->opt))\n\t\t\treturn -ENOBUFS;\n\n\t\tv6_cork->opt->tot_len = opt->tot_len;\n\t\tv6_cork->opt->opt_flen = opt->opt_flen;\n\t\tv6_cork->opt->opt_nflen = opt->opt_nflen;\n\n\t\tv6_cork->opt->dst0opt = ip6_opt_dup(opt->dst0opt,\n\t\t\t\t\t\t    sk->sk_allocation);\n\t\tif (opt->dst0opt && !v6_cork->opt->dst0opt)\n\t\t\treturn -ENOBUFS;\n\n\t\tv6_cork->opt->dst1opt = ip6_opt_dup(opt->dst1opt,\n\t\t\t\t\t\t    sk->sk_allocation);\n\t\tif (opt->dst1opt && !v6_cork->opt->dst1opt)\n\t\t\treturn -ENOBUFS;\n\n\t\tv6_cork->opt->hopopt = ip6_opt_dup(opt->hopopt,\n\t\t\t\t\t\t   sk->sk_allocation);\n\t\tif (opt->hopopt && !v6_cork->opt->hopopt)\n\t\t\treturn -ENOBUFS;\n\n\t\tv6_cork->opt->srcrt = ip6_rthdr_dup(opt->srcrt,\n\t\t\t\t\t\t    sk->sk_allocation);\n\t\tif (opt->srcrt && !v6_cork->opt->srcrt)\n\t\t\treturn -ENOBUFS;\n\n\t\t/* need source address above miyazawa*/\n\t}\n\tdst_hold(&rt->dst);\n\tcork->base.dst = &rt->dst;\n\tcork->fl.u.ip6 = *fl6;\n\tv6_cork->hop_limit = ipc6->hlimit;\n\tv6_cork->tclass = ipc6->tclass;\n\tif (rt->dst.flags & DST_XFRM_TUNNEL)\n\t\tmtu = np->pmtudisc >= IPV6_PMTUDISC_PROBE ?\n\t\t      rt->dst.dev->mtu : dst_mtu(&rt->dst);\n\telse\n\t\tmtu = np->pmtudisc >= IPV6_PMTUDISC_PROBE ?\n\t\t      rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\tif (np->frag_size < mtu) {\n\t\tif (np->frag_size)\n\t\t\tmtu = np->frag_size;\n\t}\n\tcork->base.fragsize = mtu;\n\tif (dst_allfrag(rt->dst.path))\n\t\tcork->base.flags |= IPCORK_ALLFRAG;\n\tcork->base.length = 0;\n\n\treturn 0;\n}\n\nstatic int __ip6_append_data(struct sock *sk,\n\t\t\t     struct flowi6 *fl6,\n\t\t\t     struct sk_buff_head *queue,\n\t\t\t     struct inet_cork *cork,\n\t\t\t     struct inet6_cork *v6_cork,\n\t\t\t     struct page_frag *pfrag,\n\t\t\t     int getfrag(void *from, char *to, int offset,\n\t\t\t\t\t int len, int odd, struct sk_buff *skb),\n\t\t\t     void *from, int length, int transhdrlen,\n\t\t\t     unsigned int flags, struct ipcm6_cookie *ipc6,\n\t\t\t     const struct sockcm_cookie *sockc)\n{\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\tunsigned int maxfraglen, fragheaderlen, mtu, orig_mtu;\n\tint exthdrlen = 0;\n\tint dst_exthdrlen = 0;\n\tint hh_len;\n\tint copy;\n\tint err;\n\tint offset = 0;\n\t__u8 tx_flags = 0;\n\tu32 tskey = 0;\n\tstruct rt6_info *rt = (struct rt6_info *)cork->dst;\n\tstruct ipv6_txoptions *opt = v6_cork->opt;\n\tint csummode = CHECKSUM_NONE;\n\tunsigned int maxnonfragsize, headersize;\n\n\tskb = skb_peek_tail(queue);\n\tif (!skb) {\n\t\texthdrlen = opt ? opt->opt_flen : 0;\n\t\tdst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;\n\t}\n\n\tmtu = cork->fragsize;\n\torig_mtu = mtu;\n\n\thh_len = LL_RESERVED_SPACE(rt->dst.dev);\n\n\tfragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len +\n\t\t\t(opt ? opt->opt_nflen : 0);\n\tmaxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen -\n\t\t     sizeof(struct frag_hdr);\n\n\theadersize = sizeof(struct ipv6hdr) +\n\t\t     (opt ? opt->opt_flen + opt->opt_nflen : 0) +\n\t\t     (dst_allfrag(&rt->dst) ?\n\t\t      sizeof(struct frag_hdr) : 0) +\n\t\t     rt->rt6i_nfheader_len;\n\n\tif (cork->length + length > mtu - headersize && ipc6->dontfrag &&\n\t    (sk->sk_protocol == IPPROTO_UDP ||\n\t     sk->sk_protocol == IPPROTO_RAW)) {\n\t\tipv6_local_rxpmtu(sk, fl6, mtu - headersize +\n\t\t\t\tsizeof(struct ipv6hdr));\n\t\tgoto emsgsize;\n\t}\n\n\tif (ip6_sk_ignore_df(sk))\n\t\tmaxnonfragsize = sizeof(struct ipv6hdr) + IPV6_MAXPLEN;\n\telse\n\t\tmaxnonfragsize = mtu;\n\n\tif (cork->length + length > maxnonfragsize - headersize) {\nemsgsize:\n\t\tipv6_local_error(sk, EMSGSIZE, fl6,\n\t\t\t\t mtu - headersize +\n\t\t\t\t sizeof(struct ipv6hdr));\n\t\treturn -EMSGSIZE;\n\t}\n\n\t/* CHECKSUM_PARTIAL only with no extension headers and when\n\t * we are not going to fragment\n\t */\n\tif (transhdrlen && sk->sk_protocol == IPPROTO_UDP &&\n\t    headersize == sizeof(struct ipv6hdr) &&\n\t    length <= mtu - headersize &&\n\t    !(flags & MSG_MORE) &&\n\t    rt->dst.dev->features & (NETIF_F_IPV6_CSUM | NETIF_F_HW_CSUM))\n\t\tcsummode = CHECKSUM_PARTIAL;\n\n\tif (sk->sk_type == SOCK_DGRAM || sk->sk_type == SOCK_RAW) {\n\t\tsock_tx_timestamp(sk, sockc->tsflags, &tx_flags);\n\t\tif (tx_flags & SKBTX_ANY_SW_TSTAMP &&\n\t\t    sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)\n\t\t\ttskey = sk->sk_tskey++;\n\t}\n\n\t/*\n\t * Let's try using as much space as possible.\n\t * Use MTU if total length of the message fits into the MTU.\n\t * Otherwise, we need to reserve fragment header and\n\t * fragment alignment (= 8-15 octects, in total).\n\t *\n\t * Note that we may need to \"move\" the data from the tail of\n\t * of the buffer to the new fragment when we split\n\t * the message.\n\t *\n\t * FIXME: It may be fragmented into multiple chunks\n\t *        at once if non-fragmentable extension headers\n\t *        are too large.\n\t * --yoshfuji\n\t */\n\n\tcork->length += length;\n\tif ((((length + fragheaderlen) > mtu) ||\n\t     (skb && skb_is_gso(skb))) &&\n\t    (sk->sk_protocol == IPPROTO_UDP) &&\n\t    (rt->dst.dev->features & NETIF_F_UFO) && !dst_xfrm(&rt->dst) &&\n\t    (sk->sk_type == SOCK_DGRAM) && !udp_get_no_check6_tx(sk)) {\n\t\terr = ip6_ufo_append_data(sk, queue, getfrag, from, length,\n\t\t\t\t\t  hh_len, fragheaderlen, exthdrlen,\n\t\t\t\t\t  transhdrlen, mtu, flags, fl6);\n\t\tif (err)\n\t\t\tgoto error;\n\t\treturn 0;\n\t}\n\n\tif (!skb)\n\t\tgoto alloc_new_skb;\n\n\twhile (length > 0) {\n\t\t/* Check if the remaining data fits into current packet. */\n\t\tcopy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;\n\t\tif (copy < length)\n\t\t\tcopy = maxfraglen - skb->len;\n\n\t\tif (copy <= 0) {\n\t\t\tchar *data;\n\t\t\tunsigned int datalen;\n\t\t\tunsigned int fraglen;\n\t\t\tunsigned int fraggap;\n\t\t\tunsigned int alloclen;\nalloc_new_skb:\n\t\t\t/* There's no room in the current skb */\n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t/* update mtu and maxfraglen if necessary */\n\t\t\tif (!skb || !skb_prev)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt,\n\t\t\t\t\t\t    orig_mtu);\n\n\t\t\tskb_prev = skb;\n\n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t */\n\t\t\tdatalen = length + fraggap;\n\n\t\t\tif (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)\n\t\t\t\tdatalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;\n\t\t\tif ((flags & MSG_MORE) &&\n\t\t\t    !(rt->dst.dev->features&NETIF_F_SG))\n\t\t\t\talloclen = mtu;\n\t\t\telse\n\t\t\t\talloclen = datalen + fragheaderlen;\n\n\t\t\talloclen += dst_exthdrlen;\n\n\t\t\tif (datalen != length + fraggap) {\n\t\t\t\t/*\n\t\t\t\t * this is not the last fragment, the trailer\n\t\t\t\t * space is regarded as data space.\n\t\t\t\t */\n\t\t\t\tdatalen += rt->dst.trailer_len;\n\t\t\t}\n\n\t\t\talloclen += rt->dst.trailer_len;\n\t\t\tfraglen = datalen + fragheaderlen;\n\n\t\t\t/*\n\t\t\t * We just reserve space for fragment header.\n\t\t\t * Note: this may be overallocation if the message\n\t\t\t * (without MSG_MORE) fits into the MTU.\n\t\t\t */\n\t\t\talloclen += sizeof(struct frag_hdr);\n\n\t\t\tcopy = datalen - transhdrlen - fraggap;\n\t\t\tif (copy < 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (transhdrlen) {\n\t\t\t\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t\t\talloclen + hh_len,\n\t\t\t\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t\tif (atomic_read(&sk->sk_wmem_alloc) <=\n\t\t\t\t    2 * sk->sk_sndbuf)\n\t\t\t\t\tskb = sock_wmalloc(sk,\n\t\t\t\t\t\t\t   alloclen + hh_len, 1,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\t\tif (unlikely(!skb))\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t}\n\t\t\tif (!skb)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t *\tFill in the control structures\n\t\t\t */\n\t\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\t\tskb->ip_summed = csummode;\n\t\t\tskb->csum = 0;\n\t\t\t/* reserve for fragmentation and ipsec header */\n\t\t\tskb_reserve(skb, hh_len + sizeof(struct frag_hdr) +\n\t\t\t\t    dst_exthdrlen);\n\n\t\t\t/* Only the initial fragment is time stamped */\n\t\t\tskb_shinfo(skb)->tx_flags = tx_flags;\n\t\t\ttx_flags = 0;\n\t\t\tskb_shinfo(skb)->tskey = tskey;\n\t\t\ttskey = 0;\n\n\t\t\t/*\n\t\t\t *\tFind where to start putting bytes\n\t\t\t */\n\t\t\tdata = skb_put(skb, fraglen);\n\t\t\tskb_set_network_header(skb, exthdrlen);\n\t\t\tdata += fragheaderlen;\n\t\t\tskb->transport_header = (skb->network_header +\n\t\t\t\t\t\t fragheaderlen);\n\t\t\tif (fraggap) {\n\t\t\t\tskb->csum = skb_copy_and_csum_bits(\n\t\t\t\t\tskb_prev, maxfraglen,\n\t\t\t\t\tdata + transhdrlen, fraggap, 0);\n\t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,\n\t\t\t\t\t\t\t  skb->csum);\n\t\t\t\tdata += fraggap;\n\t\t\t\tpskb_trim_unique(skb_prev, maxfraglen);\n\t\t\t}\n\t\t\tif (copy > 0 &&\n\t\t\t    getfrag(from, data + transhdrlen, offset,\n\t\t\t\t    copy, fraggap, skb) < 0) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\toffset += copy;\n\t\t\tlength -= datalen - fraggap;\n\t\t\ttranshdrlen = 0;\n\t\t\texthdrlen = 0;\n\t\t\tdst_exthdrlen = 0;\n\n\t\t\tif ((flags & MSG_CONFIRM) && !skb_prev)\n\t\t\t\tskb_set_dst_pending_confirm(skb, 1);\n\n\t\t\t/*\n\t\t\t * Put the packet on the pending queue\n\t\t\t */\n\t\t\t__skb_queue_tail(queue, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (copy > length)\n\t\t\tcopy = length;\n\n\t\tif (!(rt->dst.dev->features&NETIF_F_SG)) {\n\t\t\tunsigned int off;\n\n\t\t\toff = skb->len;\n\t\t\tif (getfrag(from, skb_put(skb, copy),\n\t\t\t\t\t\toffset, copy, off, skb) < 0) {\n\t\t\t\t__skb_trim(skb, off);\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tint i = skb_shinfo(skb)->nr_frags;\n\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sk_page_frag_refill(sk, pfrag))\n\t\t\t\tgoto error;\n\n\t\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n\t\t\t\t\t      pfrag->offset)) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tif (i == MAX_SKB_FRAGS)\n\t\t\t\t\tgoto error;\n\n\t\t\t\t__skb_fill_page_desc(skb, i, pfrag->page,\n\t\t\t\t\t\t     pfrag->offset, 0);\n\t\t\t\tskb_shinfo(skb)->nr_frags = ++i;\n\t\t\t\tget_page(pfrag->page);\n\t\t\t}\n\t\t\tcopy = min_t(int, copy, pfrag->size - pfrag->offset);\n\t\t\tif (getfrag(from,\n\t\t\t\t    page_address(pfrag->page) + pfrag->offset,\n\t\t\t\t    offset, copy, skb->len, skb) < 0)\n\t\t\t\tgoto error_efault;\n\n\t\t\tpfrag->offset += copy;\n\t\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n\t\t\tskb->len += copy;\n\t\t\tskb->data_len += copy;\n\t\t\tskb->truesize += copy;\n\t\t\tatomic_add(copy, &sk->sk_wmem_alloc);\n\t\t}\n\t\toffset += copy;\n\t\tlength -= copy;\n\t}\n\n\treturn 0;\n\nerror_efault:\n\terr = -EFAULT;\nerror:\n\tcork->length -= length;\n\tIP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\treturn err;\n}\n\nint ip6_append_data(struct sock *sk,\n\t\t    int getfrag(void *from, char *to, int offset, int len,\n\t\t\t\tint odd, struct sk_buff *skb),\n\t\t    void *from, int length, int transhdrlen,\n\t\t    struct ipcm6_cookie *ipc6, struct flowi6 *fl6,\n\t\t    struct rt6_info *rt, unsigned int flags,\n\t\t    const struct sockcm_cookie *sockc)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tint exthdrlen;\n\tint err;\n\n\tif (flags&MSG_PROBE)\n\t\treturn 0;\n\tif (skb_queue_empty(&sk->sk_write_queue)) {\n\t\t/*\n\t\t * setup for corking\n\t\t */\n\t\terr = ip6_setup_cork(sk, &inet->cork, &np->cork,\n\t\t\t\t     ipc6, rt, fl6);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\texthdrlen = (ipc6->opt ? ipc6->opt->opt_flen : 0);\n\t\tlength += exthdrlen;\n\t\ttranshdrlen += exthdrlen;\n\t} else {\n\t\tfl6 = &inet->cork.fl.u.ip6;\n\t\ttranshdrlen = 0;\n\t}\n\n\treturn __ip6_append_data(sk, fl6, &sk->sk_write_queue, &inet->cork.base,\n\t\t\t\t &np->cork, sk_page_frag(sk), getfrag,\n\t\t\t\t from, length, transhdrlen, flags, ipc6, sockc);\n}\nEXPORT_SYMBOL_GPL(ip6_append_data);\n\nstatic void ip6_cork_release(struct inet_cork_full *cork,\n\t\t\t     struct inet6_cork *v6_cork)\n{\n\tif (v6_cork->opt) {\n\t\tkfree(v6_cork->opt->dst0opt);\n\t\tkfree(v6_cork->opt->dst1opt);\n\t\tkfree(v6_cork->opt->hopopt);\n\t\tkfree(v6_cork->opt->srcrt);\n\t\tkfree(v6_cork->opt);\n\t\tv6_cork->opt = NULL;\n\t}\n\n\tif (cork->base.dst) {\n\t\tdst_release(cork->base.dst);\n\t\tcork->base.dst = NULL;\n\t\tcork->base.flags &= ~IPCORK_ALLFRAG;\n\t}\n\tmemset(&cork->fl, 0, sizeof(cork->fl));\n}\n\nstruct sk_buff *__ip6_make_skb(struct sock *sk,\n\t\t\t       struct sk_buff_head *queue,\n\t\t\t       struct inet_cork_full *cork,\n\t\t\t       struct inet6_cork *v6_cork)\n{\n\tstruct sk_buff *skb, *tmp_skb;\n\tstruct sk_buff **tail_skb;\n\tstruct in6_addr final_dst_buf, *final_dst = &final_dst_buf;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct ipv6hdr *hdr;\n\tstruct ipv6_txoptions *opt = v6_cork->opt;\n\tstruct rt6_info *rt = (struct rt6_info *)cork->base.dst;\n\tstruct flowi6 *fl6 = &cork->fl.u.ip6;\n\tunsigned char proto = fl6->flowi6_proto;\n\n\tskb = __skb_dequeue(queue);\n\tif (!skb)\n\t\tgoto out;\n\ttail_skb = &(skb_shinfo(skb)->frag_list);\n\n\t/* move skb->data to ip header from ext header */\n\tif (skb->data < skb_network_header(skb))\n\t\t__skb_pull(skb, skb_network_offset(skb));\n\twhile ((tmp_skb = __skb_dequeue(queue)) != NULL) {\n\t\t__skb_pull(tmp_skb, skb_network_header_len(skb));\n\t\t*tail_skb = tmp_skb;\n\t\ttail_skb = &(tmp_skb->next);\n\t\tskb->len += tmp_skb->len;\n\t\tskb->data_len += tmp_skb->len;\n\t\tskb->truesize += tmp_skb->truesize;\n\t\ttmp_skb->destructor = NULL;\n\t\ttmp_skb->sk = NULL;\n\t}\n\n\t/* Allow local fragmentation. */\n\tskb->ignore_df = ip6_sk_ignore_df(sk);\n\n\t*final_dst = fl6->daddr;\n\t__skb_pull(skb, skb_network_header_len(skb));\n\tif (opt && opt->opt_flen)\n\t\tipv6_push_frag_opts(skb, opt, &proto);\n\tif (opt && opt->opt_nflen)\n\t\tipv6_push_nfrag_opts(skb, opt, &proto, &final_dst, &fl6->saddr);\n\n\tskb_push(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\thdr = ipv6_hdr(skb);\n\n\tip6_flow_hdr(hdr, v6_cork->tclass,\n\t\t     ip6_make_flowlabel(net, skb, fl6->flowlabel,\n\t\t\t\t\tnp->autoflowlabel, fl6));\n\thdr->hop_limit = v6_cork->hop_limit;\n\thdr->nexthdr = proto;\n\thdr->saddr = fl6->saddr;\n\thdr->daddr = *final_dst;\n\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\n\tskb_dst_set(skb, dst_clone(&rt->dst));\n\tIP6_UPD_PO_STATS(net, rt->rt6i_idev, IPSTATS_MIB_OUT, skb->len);\n\tif (proto == IPPROTO_ICMPV6) {\n\t\tstruct inet6_dev *idev = ip6_dst_idev(skb_dst(skb));\n\n\t\tICMP6MSGOUT_INC_STATS(net, idev, icmp6_hdr(skb)->icmp6_type);\n\t\tICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTMSGS);\n\t}\n\n\tip6_cork_release(cork, v6_cork);\nout:\n\treturn skb;\n}\n\nint ip6_send_skb(struct sk_buff *skb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct rt6_info *rt = (struct rt6_info *)skb_dst(skb);\n\tint err;\n\n\terr = ip6_local_out(net, skb->sk, skb);\n\tif (err) {\n\t\tif (err > 0)\n\t\t\terr = net_xmit_errno(err);\n\t\tif (err)\n\t\t\tIP6_INC_STATS(net, rt->rt6i_idev,\n\t\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t}\n\n\treturn err;\n}\n\nint ip6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\n\tskb = ip6_finish_skb(sk);\n\tif (!skb)\n\t\treturn 0;\n\n\treturn ip6_send_skb(skb);\n}\nEXPORT_SYMBOL_GPL(ip6_push_pending_frames);\n\nstatic void __ip6_flush_pending_frames(struct sock *sk,\n\t\t\t\t       struct sk_buff_head *queue,\n\t\t\t\t       struct inet_cork_full *cork,\n\t\t\t\t       struct inet6_cork *v6_cork)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = __skb_dequeue_tail(queue)) != NULL) {\n\t\tif (skb_dst(skb))\n\t\t\tIP6_INC_STATS(sock_net(sk), ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t\tkfree_skb(skb);\n\t}\n\n\tip6_cork_release(cork, v6_cork);\n}\n\nvoid ip6_flush_pending_frames(struct sock *sk)\n{\n\t__ip6_flush_pending_frames(sk, &sk->sk_write_queue,\n\t\t\t\t   &inet_sk(sk)->cork, &inet6_sk(sk)->cork);\n}\nEXPORT_SYMBOL_GPL(ip6_flush_pending_frames);\n\nstruct sk_buff *ip6_make_skb(struct sock *sk,\n\t\t\t     int getfrag(void *from, char *to, int offset,\n\t\t\t\t\t int len, int odd, struct sk_buff *skb),\n\t\t\t     void *from, int length, int transhdrlen,\n\t\t\t     struct ipcm6_cookie *ipc6, struct flowi6 *fl6,\n\t\t\t     struct rt6_info *rt, unsigned int flags,\n\t\t\t     const struct sockcm_cookie *sockc)\n{\n\tstruct inet_cork_full cork;\n\tstruct inet6_cork v6_cork;\n\tstruct sk_buff_head queue;\n\tint exthdrlen = (ipc6->opt ? ipc6->opt->opt_flen : 0);\n\tint err;\n\n\tif (flags & MSG_PROBE)\n\t\treturn NULL;\n\n\t__skb_queue_head_init(&queue);\n\n\tcork.base.flags = 0;\n\tcork.base.addr = 0;\n\tcork.base.opt = NULL;\n\tv6_cork.opt = NULL;\n\terr = ip6_setup_cork(sk, &cork, &v6_cork, ipc6, rt, fl6);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif (ipc6->dontfrag < 0)\n\t\tipc6->dontfrag = inet6_sk(sk)->dontfrag;\n\n\terr = __ip6_append_data(sk, fl6, &queue, &cork.base, &v6_cork,\n\t\t\t\t&current->task_frag, getfrag, from,\n\t\t\t\tlength + exthdrlen, transhdrlen + exthdrlen,\n\t\t\t\tflags, ipc6, sockc);\n\tif (err) {\n\t\t__ip6_flush_pending_frames(sk, &queue, &cork, &v6_cork);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn __ip6_make_skb(sk, &queue, &cork, &v6_cork);\n}\n"], "filenames": ["net/ipv6/ip6_output.c"], "buggy_code_start_loc": [1468], "buggy_code_end_loc": [1525], "fixing_code_start_loc": [1469], "fixing_code_end_loc": [1526], "type": "CWE-20", "message": "The __ip6_append_data function in net/ipv6/ip6_output.c in the Linux kernel through 4.11.3 is too late in checking whether an overwrite of an skb data structure may occur, which allows local users to cause a denial of service (system crash) via crafted system calls.", "other": {"cve": {"id": "CVE-2017-9242", "sourceIdentifier": "cve@mitre.org", "published": "2017-05-27T01:29:02.513", "lastModified": "2018-01-05T02:31:54.620", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The __ip6_append_data function in net/ipv6/ip6_output.c in the Linux kernel through 4.11.3 is too late in checking whether an overwrite of an skb data structure may occur, which allows local users to cause a denial of service (system crash) via crafted system calls."}, {"lang": "es", "value": "La funci\u00f3n __ip6_append_data en el archivo net/ipv6/ip6_output.c en el kernel de Linux hasta versi\u00f3n 4.11.3, es demasiado tard\u00eda para comprobar si se puede sobrescribir una estructura de datos skb, lo que permite a los usuarios locales causar una denegaci\u00f3n de servicio (bloqueo del sistema) por medio de unas llamadas de sistema dise\u00f1adas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.11.3", "matchCriteriaId": "366CA732-03B0-4C72-8880-BA229C7B2DF8"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=232cd35d0804cc241eb887bb8d4d9b3b9881c64a", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.debian.org/security/2017/dsa-3886", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/98731", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1842", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2077", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/232cd35d0804cc241eb887bb8d4d9b3b9881c64a", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://patchwork.ozlabs.org/patch/764880/", "source": "cve@mitre.org", "tags": ["Broken Link"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/232cd35d0804cc241eb887bb8d4d9b3b9881c64a"}}