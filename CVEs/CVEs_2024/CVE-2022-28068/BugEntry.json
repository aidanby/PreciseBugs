{"buggy_code": ["/* radare - LGPL - Copyright 2012-2021 - houndthe */\n\n#include \"base_types.h\"\n#include <sdb.h>\n#include <r_anal.h>\n#include <r_bin_dwarf.h>\n#include <string.h>\n\ntypedef struct dwarf_parse_context_t {\n\tconst RAnal *anal;\n\tconst RBinDwarfDie *all_dies;\n\tconst ut64 count;\n\tSdb *sdb;\n\tHtUP/*<ut64 offset, DwarfDie *die>*/ *die_map;\n\tHtUP/*<offset, RBinDwarfLocList*>*/  *locations;\n\tconst char *lang; // for demangling\n} Context;\n\ntypedef struct dwarf_function_t {\n\tut64 addr;\n\tconst char *name;\n\tconst char *signature;\n\tbool is_external;\n\tbool is_method;\n\tbool is_virtual;\n\tbool is_trampoline; // intermediary in making call to another func\n\tut8 access; // public = 1, protected = 2, private = 3, if not set assume private\n\tut64 vtable_addr; // location description\n\tut64 call_conv; // normal || program || nocall\n} Function;\n\ntypedef enum dwarf_location_kind {\n\tLOCATION_UNKNOWN = 0,\n\tLOCATION_GLOBAL = 1,\n\tLOCATION_BP = 2,\n\tLOCATION_SP = 3,\n\tLOCATION_REGISTER = 4,\n} VariableLocationKind;\ntypedef struct dwarf_var_location_t {\n\tVariableLocationKind kind;\n\tut64 address;\n\tut64 reg_num;\n\tst64 offset;\n\tconst char *reg_name; /* string literal */\n} VariableLocation;\n\ntypedef struct dwarf_variable_t {\n\tVariableLocation *location;\n\tchar *name;\n\tchar *type;\n} Variable;\n\nstatic void variable_free(Variable *var) {\n\tfree (var->name);\n\tfree (var->location);\n\tfree (var->type);\n\tfree (var);\n}\n\n/* return -1 if attr isn't found */\nstatic inline st32 find_attr_idx(const RBinDwarfDie *die, st32 attr_name) {\n\tst32 i;\n\tr_return_val_if_fail (die, -1);\n\tfor (i = 0; i < die->count; i++) {\n\t\tif (die->attr_values[i].attr_name == attr_name) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/* return NULL if attr isn't found */\nstatic RBinDwarfAttrValue *find_attr(const RBinDwarfDie *die, st32 attr_name) {\n\tst32 i;\n\tr_return_val_if_fail (die, NULL);\n\tfor (i = 0; i < die->count; i++) {\n\t\tif (die->attr_values[i].attr_name == attr_name) {\n\t\t\treturn &die->attr_values[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/**\n * @brief Pasted from r_strbuf_*\n *        Prepends string before a last occurence of character c\n * \t      Used to replicate proper C declaration for function pointers\n * @param sb\n * @param s\n * @param c\n */\nstatic bool strbuf_rev_prepend_char(RStrBuf *sb, const char *s, int c) {\n\tr_return_val_if_fail (sb && s, false);\n\tsize_t l = strlen (s);\n\t// fast path if no chars to append\n\tif (l == 0) {\n\t\treturn true;\n\t}\n\tsize_t newlen = l + sb->len;\n\tchar *ns = malloc (newlen + 1);\n\tbool ret = false;\n\tchar *sb_str = sb->ptr ? sb->ptr : sb->buf;\n\tchar *pivot = strrchr (sb_str, c);\n\tif (!pivot) {\n\t\tfree (ns);\n\t\treturn false;\n\t}\n\tsize_t idx = pivot - sb_str;\n\tif (ns) {\n\t\tmemcpy (ns, sb_str, idx);\n\t\tmemcpy (ns + idx, s, l);\n\t\tmemcpy (ns + idx + l, sb_str + idx, sb->len - idx);\n\t\tns[newlen] = 0;\n\t\tret = r_strbuf_set (sb, ns) != NULL;\n\t\tfree (ns);\n\t}\n\treturn ret;\n}\n/**\n * @brief Pasted from r_strbuf_*\n * \t      Appends string after a first occurence of character c\n * \t      Used to replicate proper C declaration for function pointers\n * @param sb\n * @param s\n * @param needle\n */\nstatic bool strbuf_rev_append_char(RStrBuf *sb, const char *s, const char *needle) {\n\tr_return_val_if_fail (sb && s, false);\n\tsize_t l = strlen (s);\n\t// fast path if no chars to append\n\tif (l == 0) {\n\t\treturn true;\n\t}\n\tbool ret = false;\n\tchar *sb_str = sb->ptr ? sb->ptr : sb->buf;\n\tchar *pivot = strstr (sb_str, needle);\n\tif (!pivot) {\n\t\treturn false;\n\t}\n\tpivot += strlen (needle);\n\tsize_t idx = pivot - sb_str;\n\tsize_t newlen = l + sb->len;\n\tchar *ns = malloc (newlen + 1);\n\tif (ns) {\n\t\tmemcpy (ns, sb_str, idx);\n\t\tmemcpy (ns + idx, s, l);\n\t\tmemcpy (ns + idx + l, sb_str + idx, sb->len - idx);\n\t\tns[newlen] = 0;\n\t\tret = r_strbuf_set (sb, ns) != NULL;\n\t\tfree (ns);\n\t}\n\treturn ret;\n}\n\nstatic inline char *create_type_name_from_offset(ut64 offset) {\n\treturn r_str_newf (\"type_0x%\" PFMT64x, offset);\n}\n\n/**\n * @brief Get the DIE name or create unique one from it's offset\n *\n * @param die\n * @return char* DIEs name or NULL if error\n */\nstatic char *get_die_name(const RBinDwarfDie *die) {\n\tchar *name = NULL;\n\tst32 name_attr_idx = find_attr_idx (die, DW_AT_name);\n\tif (name_attr_idx < 0 || name_attr_idx >= die->count) {\n\t\treturn NULL;\n\t}\n\tRBinDwarfAttrValue *av = &die->attr_values[name_attr_idx];\n\tif (av->kind == DW_AT_KIND_STRING && name_attr_idx != -1 && av->string.content) {\n\t\tname = strdup (av->string.content);\n\t} else {\n\t\tname = create_type_name_from_offset (die->offset);\n\t}\n\treturn name;\n}\n\n/**\n * @brief Get the DIE size in bits\n *\n * @param die\n * @return ut64 size in bits or 0 if not found\n */\nstatic ut64 get_die_size(const RBinDwarfDie *die) {\n\tut64 size = 0;\n\tst32 byte_size_idx = find_attr_idx (die, DW_AT_byte_size);\n\n\tif (byte_size_idx != -1) {\n\t\tsize = die->attr_values[byte_size_idx].uconstant * CHAR_BIT;\n\t} else {\n\t\tst32 bit_size_idx = find_attr_idx (die, DW_AT_bit_size);\n\n\t\tif (bit_size_idx != -1) {\n\t\t\tsize = die->attr_values[bit_size_idx].uconstant;\n\t\t}\n\t}\n\treturn size;\n}\n\n/**\n * @brief Parses array type entry signature into strbuf\n *\n * @param ctx\n * @param idx index of the current entry\n * @param strbuf strbuf to store the type into\n * @return st32 -1 if error else 0\n */\nstatic st32 parse_array_type(Context *ctx, ut64 idx, RStrBuf *strbuf) {\n\tconst RBinDwarfDie *die = &ctx->all_dies[idx++];\n\n\tif (die->has_children) {\n\t\tint child_depth = 1;\n\t\tsize_t j;\n\t\tfor (j = idx; child_depth > 0 && j < ctx->count; j++) {\n\t\t\tconst RBinDwarfDie *child_die = &ctx->all_dies[j];\n\t\t\t// right now we skip non direct descendats of the structure\n\t\t\t// can be also DW_TAG_suprogram for class methods or tag for templates\n\t\t\tif (child_depth == 1 && child_die->tag == DW_TAG_subrange_type) {\n\t\t\t\tsize_t i;\n\t\t\t\tfor (i = 0; i < child_die->count; i++) {\n\t\t\t\t\tconst RBinDwarfAttrValue *value = &child_die->attr_values[i];\n\t\t\t\t\tswitch (value->attr_name) {\n\t\t\t\t\tcase DW_AT_upper_bound:\n\t\t\t\t\tcase DW_AT_count:\n\t\t\t\t\t\tr_strbuf_appendf (strbuf, \"[%\" PFMT64d \"]\", value->uconstant + 1);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (child_die->has_children) {\n\t\t\t\tchild_depth++;\n\t\t\t}\n\t\t\t// sibling list is terminated by null entry\n\t\t\tif (child_die->abbrev_code == 0) {\n\t\t\t\tchild_depth--;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * @brief Recursively parses type entry of a certain offset into strbuf\n *        saves type size into *size\n *\n * @param ctx\n * @param offset offset of the type entry\n * @param strbuf string to store the type into\n * @param size ptr to size of a type to fill up (can be NULL if unwanted)\n * @return st32 -1 if error else DW_TAG of the entry\n *\n * TODO make cache for type entries, one type is usually referenced\n * multiple times which means it's parsed multiple times instead of once\n */\nstatic st32 parse_type(Context *ctx, const ut64 offset, RStrBuf *strbuf, ut64 *size, HtUP **visited) {\n\tr_return_val_if_fail (strbuf, -1);\n\tRBinDwarfDie *die = ht_up_find (ctx->die_map, offset, NULL);\n\tif (!die) {\n\t\treturn -1;\n\t}\n\tbool root = false;\n\n\tif (!visited) {\n\t\troot = true;\n\t\tSetU *su = set_u_new ();\n\t\tvisited = malloc (sizeof (void*));\n\t\t*visited = su;\n\t}\n\tif (visited && set_u_contains (*visited, offset)) {\n\t\teprintf (\"Warning: anal.dwarf.parse_type: infinite recursion detected.\\n\");\n\t\treturn -1;\n\t}\n\tset_u_add (*visited, offset);\n\n\tst32 type_idx;\n\tst32 tag;\n\tchar *name = NULL;\n\t// get size of first type DIE that has size\n\tif (size && *size == 0) {\n\t\t*size = get_die_size (die);\n\t}\n\tswitch (die->tag) {\n\t// this should be recursive search for the type until you find base/user defined type\n\tcase DW_TAG_pointer_type:\n\t\ttype_idx = find_attr_idx (die, DW_AT_type);\n\t\tif (type_idx == -1) {\n\t\t\tr_strbuf_append (strbuf, \"void\");\n\t\t\tr_strbuf_append (strbuf, \" *\");\n\t\t} else {\n\t\t\ttag = parse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);\n\t\t\tif (tag == DW_TAG_subroutine_type) {\n\t\t\t\tstrbuf_rev_prepend_char (strbuf, \"(*)\", '(');\n\t\t\t} else if (tag == DW_TAG_pointer_type) {\n\t\t\t\tif (!strbuf_rev_append_char (strbuf, \"*\", \"(*\")) {\n\t\t\t\t\tstrbuf_rev_prepend_char (strbuf, \"*\", '*');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_strbuf_append (strbuf, \" *\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t// We won't parse them as a complete type, because that will already be done\n\t// so just a name now\n\tcase DW_TAG_typedef:\n\tcase DW_TAG_base_type:\n\tcase DW_TAG_structure_type:\n\tcase DW_TAG_enumeration_type:\n\tcase DW_TAG_union_type:\n\tcase DW_TAG_class_type:\n\t\tname = get_die_name (die);\n\t\tif (name) {\n\t\t\tr_strbuf_append (strbuf, name);\n\t\t\tfree (name);\n\t\t}\n\t\tbreak;\n\tcase DW_TAG_subroutine_type:\n\t\ttype_idx = find_attr_idx (die, DW_AT_type);\n\t\tif (type_idx == -1) {\n\t\t\tr_strbuf_append (strbuf, \"void\");\n\t\t} else {\n\t\t\tparse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);\n\t\t}\n\t\tr_strbuf_append (strbuf, \" (\");\n\t\tif (die->has_children) { // has parameters\n\t\t}\n\t\tr_strbuf_append (strbuf, \")\");\n\t\tbreak;\n\tcase DW_TAG_array_type:\n\t\ttype_idx = find_attr_idx (die, DW_AT_type);\n\t\tif (type_idx != -1) {\n\t\t\tparse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);\n\t\t}\n\t\tparse_array_type (ctx, die - ctx->all_dies, strbuf);\n\t\tbreak;\n\tcase DW_TAG_const_type:\n\t\ttype_idx = find_attr_idx (die, DW_AT_type);\n\t\tif (type_idx != -1) {\n\t\t\tparse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);\n\t\t}\n\t\tr_strbuf_append (strbuf, \" const\");\n\t\tbreak;\n\tcase DW_TAG_volatile_type:\n\t\ttype_idx = find_attr_idx (die, DW_AT_type);\n\t\tif (type_idx != -1) {\n\t\t\tparse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);\n\t\t}\n\t\tr_strbuf_append (strbuf, \" volatile\");\n\t\tbreak;\n\tcase DW_TAG_restrict_type:\n\t\ttype_idx = find_attr_idx (die, DW_AT_type);\n\t\tif (type_idx != -1) {\n\t\t\tparse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);\n\t\t}\n\t\tr_strbuf_append (strbuf, \" restrict\");\n\t\tbreak;\n\tcase DW_TAG_rvalue_reference_type:\n\t\ttype_idx = find_attr_idx (die, DW_AT_type);\n\t\tif (type_idx != -1) {\n\t\t\tparse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);\n\t\t}\n\t\tr_strbuf_append (strbuf, \" &&\");\n\t\tbreak;\n\tcase DW_TAG_reference_type:\n\t\ttype_idx = find_attr_idx (die, DW_AT_type);\n\t\tif (type_idx != -1) {\n\t\t\tparse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);\n\t\t}\n\t\tr_strbuf_append (strbuf, \" &\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (root) {\n\t\tset_u_free (*visited);\n\t}\n\treturn (st32)die->tag;\n}\n\n/**\n * @brief Parses structured entry into *result RAnalStructMember\n * http://www.dwarfstd.org/doc/DWARF4.pdf#page=102&zoom=100,0,0\n *\n * @param ctx\n * @param idx index of the current entry\n * @param result ptr to result member to fill up\n * @return RAnalStructMember* ptr to parsed Member\n */\nstatic RAnalStructMember *parse_struct_member (Context *ctx, ut64 idx, RAnalStructMember *result) {\n\tr_return_val_if_fail (result, NULL);\n\tconst RBinDwarfDie *die = &ctx->all_dies[idx];\n\n\tchar *name = NULL;\n\tchar *type = NULL;\n\tut64 offset = 0;\n\tut64 size = 0;\n\tRStrBuf strbuf;\n\tr_strbuf_init (&strbuf);\n\tsize_t i;\n\tfor (i = 0; i < die->count; i++) {\n\t\tRBinDwarfAttrValue *value = &die->attr_values[i];\n\t\tswitch (die->attr_values[i].attr_name) {\n\t\tcase DW_AT_name:\n\t\t\tfree (name);\n\t\t\tname = get_die_name (die);\n\t\t\tif (!name) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DW_AT_type:\n\t\t\tparse_type (ctx, value->reference, &strbuf, &size, NULL);\n\t\t\tfree (type);\n\t\t\ttype = r_strbuf_drain_nofree (&strbuf);\n\t\t\tif (!type || !*type) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DW_AT_data_member_location:\n\t\t\t/*\n\t\t\t\t2 cases, 1.: If val is integer, it offset in bytes from\n\t\t\t\tthe beginning of containing entity. If containing entity has\n\t\t\t\ta bit offset, member has that bit offset aswell\n\t\t\t\t2.: value is a location description\n\t\t\t\thttp://www.dwarfstd.org/doc/DWARF4.pdf#page=39&zoom=100,0,0\n\t\t\t*/\n\t\t\toffset = value->uconstant;\n\t\t\tbreak;\n\t\tcase DW_AT_accessibility: // private, public etc.\n\t\tcase DW_AT_mutable: // flag is it is mutable\n\t\tcase DW_AT_data_bit_offset:\n\t\t\t/*\n\t\t\t\tint that specifies the number of bits from beginning\n\t\t\t\tof containing entity to the beginning of the data member\n\t\t\t*/\n\t\t\tbreak;\n\t\t// If the size of a data member is not the same as the\n\t\t//  size of the type given for the data member\n\t\tcase DW_AT_byte_size:\n\t\t\tsize = value->uconstant * CHAR_BIT;\n\t\t\tbreak;\n\t\tcase DW_AT_bit_size:\n\t\t\tsize = value->uconstant;\n\t\t\tbreak;\n\t\tcase DW_AT_containing_type:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tresult->name = name;\n\tresult->type = type;\n\tresult->offset = offset;\n\tresult->size = size;\n\treturn result;\ncleanup:\n\tfree (name);\n\tfree (type);\n\treturn NULL;\n}\n\n/**\n * @brief  Parses enum entry into *result RAnalEnumCase\n * http://www.dwarfstd.org/doc/DWARF4.pdf#page=110&zoom=100,0,0\n *\n * @param ctx\n * @param idx index of the current entry\n * @param result ptr to result case to fill up\n * @return RAnalEnumCase* Ptr to parsed enum case\n */\nstatic RAnalEnumCase *parse_enumerator(Context *ctx, ut64 idx, RAnalEnumCase *result) {\n\tconst RBinDwarfDie *die = &ctx->all_dies[idx];\n\n\tchar *name = NULL;\n\tint val = 0;\n\tsize_t i;\n\n\t// Enumerator has DW_AT_name and DW_AT_const_value\n\tfor (i = 0; i < die->count; i++) {\n\t\tRBinDwarfAttrValue *value = &die->attr_values[i];\n\t\tswitch (die->attr_values[i].attr_name) {\n\t\tcase DW_AT_name:\n\t\t\tname = get_die_name (die);\n\t\t\tif (!name) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DW_AT_const_value:\n\t\t\t// ?? can be block, sdata, data, string w/e\n\t\t\tval = value->uconstant; // TODO solve the encoding, I don't know in which union member is it store\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tresult->name = name;\n\tresult->val = (int)val;\n\treturn result;\ncleanup:\n\tfree (name);\n\treturn NULL;\n}\n\n/**\n * @brief  Parses a structured entry (structs, classes, unions) into\n *         RAnalBaseType and saves it using r_anal_save_base_type ()\n *\n * @param ctx\n * @param idx index of the current entry\n */\n// http://www.dwarfstd.org/doc/DWARF4.pdf#page=102&zoom=100,0,0\nstatic void parse_structure_type(Context *ctx, ut64 idx) {\n\tconst RBinDwarfDie *die = &ctx->all_dies[idx];\n\n\tRAnalBaseTypeKind kind;\n\tif (die->tag == DW_TAG_union_type) {\n\t\tkind = R_ANAL_BASE_TYPE_KIND_UNION;\n\t} else {\n\t\tkind = R_ANAL_BASE_TYPE_KIND_STRUCT;\n\t}\n\n\tRAnalBaseType *base_type = r_anal_base_type_new (kind);\n\tif (!base_type) {\n\t\treturn;\n\t}\n\n\tbase_type->name = get_die_name (die);\n\tif (!base_type->name) {\n\t\tgoto cleanup;\n\t}\n\n\t// if it is definition of previous declaration (TODO Fix, big ugly hotfix addition)\n\tst32 spec_attr_idx = find_attr_idx (die, DW_AT_specification);\n\tif (spec_attr_idx != -1) {\n\t\tRBinDwarfDie *decl_die = ht_up_find (ctx->die_map, die->attr_values[spec_attr_idx].reference, NULL);\n\t\tif (!decl_die) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tst32 name_attr_idx = find_attr_idx (decl_die, DW_AT_name);\n\t\tif (name_attr_idx != -1) {\n\t\t\tfree (base_type->name);\n\t\t\tbase_type->name = get_die_name (decl_die);\n\t\t}\n\t}\n\n\tbase_type->size = get_die_size (die);\n\n\tRAnalStructMember member = { 0 };\n\t// Parse out all members, can this in someway be extracted to a function?\n\tif (die->has_children) {\n\t\tint child_depth = 1; // Direct children of the node\n\t\tsize_t j;\n\t\tidx++; // Move to the first children node\n\t\tfor (j = idx; child_depth > 0 && j < ctx->count; j++) {\n\t\t\tconst RBinDwarfDie *child_die = &ctx->all_dies[j];\n\t\t\t// we take only direct descendats of the structure\n\t\t\t// can be also DW_TAG_suprogram for class methods or tag for templates\n\t\t\tif (child_depth == 1 && child_die->tag == DW_TAG_member) {\n\t\t\t\tRAnalStructMember *result = parse_struct_member (ctx, j, &member);\n\t\t\t\tif (!result) {\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t} else {\n\t\t\t\t\tvoid *element = r_vector_push (&base_type->struct_data.members, &member);\n\t\t\t\t\tif (!element) {\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (child_die->has_children) {\n\t\t\t\tchild_depth++;\n\t\t\t}\n\t\t\tif (child_die->abbrev_code == 0) { // siblings terminator\n\t\t\t\tchild_depth--;\n\t\t\t}\n\t\t}\n\t}\n\tr_anal_save_base_type (ctx->anal, base_type);\ncleanup:\n\tr_anal_base_type_free (base_type);\n}\n\n/**\n * @brief Parses a enum entry into RAnalBaseType and saves it\n *        int Sdb using r_anal_save_base_type ()\n *\n * @param ctx\n * @param idx index of the current entry\n */\nstatic void parse_enum_type(Context *ctx, ut64 idx) {\n\tconst RBinDwarfDie *die = &ctx->all_dies[idx];\n\n\tRAnalBaseType *base_type = r_anal_base_type_new (R_ANAL_BASE_TYPE_KIND_ENUM);\n\tif (!base_type) {\n\t\treturn;\n\t}\n\n\tbase_type->name = get_die_name (die);\n\tif (!base_type->name) {\n\t\tgoto cleanup;\n\t}\n\tbase_type->size = get_die_size (die);\n\n\tst32 type_attr_idx = find_attr_idx (die, DW_AT_type);\n\tif (type_attr_idx != -1) {\n\t\tRStrBuf strbuf;\n\t\tr_strbuf_init (&strbuf);\n\t\tparse_type (ctx, die->attr_values[type_attr_idx].reference, &strbuf, &base_type->size, NULL);\n\t\tbase_type->type = r_strbuf_drain_nofree (&strbuf);\n\t}\n\n\tRAnalEnumCase cas;\n\tif (die->has_children) {\n\t\tint child_depth = 1; // Direct children of the node\n\t\tsize_t j;\n\t\tidx++; // Move to the first children node\n\t\tfor (j = idx; child_depth > 0 && j < ctx->count; j++) {\n\t\t\tconst RBinDwarfDie *child_die = &ctx->all_dies[j];\n\t\t\t// we take only direct descendats of the structure\n\t\t\tif (child_depth == 1 && child_die->tag == DW_TAG_enumerator) {\n\t\t\t\tRAnalEnumCase *result = parse_enumerator (ctx, j, &cas);\n\t\t\t\tif (!result) {\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t} else {\n\t\t\t\t\tvoid *element = r_vector_push (&base_type->enum_data.cases, &cas);\n\t\t\t\t\tif (!element) {\n\t\t\t\t\t\tenum_type_case_free (result, NULL);\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (child_die->has_children) {\n\t\t\t\tchild_depth++;\n\t\t\t}\n\t\t\t// sibling list is terminated by null entry\n\t\t\tif (child_die->abbrev_code == 0) {\n\t\t\t\tchild_depth--;\n\t\t\t}\n\t\t}\n\t}\n\tr_anal_save_base_type (ctx->anal, base_type);\ncleanup:\n\tr_anal_base_type_free (base_type);\n}\n\n/**\n * @brief Parses a typedef entry into RAnalBaseType and saves it\n *        using r_anal_save_base_type ()\n *\n * http://www.dwarfstd.org/doc/DWARF4.pdf#page=96&zoom=100,0,0\n *\n * @param ctx\n * @param idx index of the current entry\n */\nstatic void parse_typedef(Context *ctx, ut64 idx) {\n\tconst RBinDwarfDie *die = &ctx->all_dies[idx];\n\n\tchar *name = NULL;\n\tchar *type = NULL;\n\tut64 size = 0;\n\tRStrBuf strbuf;\n\tr_strbuf_init (&strbuf);\n\tsize_t i;\n\n\tfor (i = 0; i < die->count; i++) {\n\t\tRBinDwarfAttrValue *value = &die->attr_values[i];\n\t\tswitch (die->attr_values[i].attr_name) {\n\t\tcase DW_AT_name:\n\t\t\tfree (name);\n\t\t\tname = get_die_name (die);\n\t\t\tif (!name) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DW_AT_type:\n\t\t\tparse_type (ctx, value->reference, &strbuf, &size, NULL);\n\t\t\tfree (type);\n\t\t\ttype = r_strbuf_drain_nofree (&strbuf);\n\t\t\tif (!type) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!name) { // type has to have a name for now\n\t\tgoto cleanup;\n\t}\n\tRAnalBaseType *base_type = r_anal_base_type_new (R_ANAL_BASE_TYPE_KIND_TYPEDEF);\n\tif (!base_type) {\n\t\tgoto cleanup;\n\t}\n\tbase_type->name = name;\n\tbase_type->type = type;\n\tr_anal_save_base_type (ctx->anal, base_type);\n\tr_anal_base_type_free (base_type);\n\tr_strbuf_fini (&strbuf);\n\treturn;\ncleanup:\n\tfree (name);\n\tfree (type);\n\tr_strbuf_fini (&strbuf);\n}\n\nstatic void parse_atomic_type(Context *ctx, ut64 idx) {\n\tconst RBinDwarfDie *die = &ctx->all_dies[idx];\n\n\tchar *name = NULL;\n\tut64 size = 0;\n\tsize_t i;\n\t// TODO support endiannity and encoding in future?\n\tfor (i = 0; i < die->count; i++) {\n\t\tRBinDwarfAttrValue *value = &die->attr_values[i];\n\t\tswitch (die->attr_values[i].attr_name) {\n\t\tcase DW_AT_name:\n\t\t\tR_FREE (name);\n\t\t\tif (value->kind == DW_AT_KIND_STRING) {\n\t\t\t\tif (!value->string.content) {\n\t\t\t\t\tname = create_type_name_from_offset (die->offset);\n\t\t\t\t} else {\n\t\t\t\t\tname = strdup (value->string.content);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!name) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DW_AT_byte_size:\n\t\t\tsize = value->uconstant * CHAR_BIT;\n\t\t\tbreak;\n\t\tcase DW_AT_bit_size:\n\t\t\tsize = value->uconstant;\n\t\t\tbreak;\n\t\tcase DW_AT_encoding:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!name) { // type has to have a name for now\n\t\treturn;\n\t}\n\tRAnalBaseType *base_type = r_anal_base_type_new (R_ANAL_BASE_TYPE_KIND_ATOMIC);\n\tif (!base_type) {\n\t\tfree (name);\n\t\treturn;\n\t}\n\tbase_type->name = name;\n\tbase_type->size = size;\n\tr_anal_save_base_type (ctx->anal, base_type);\n\tr_anal_base_type_free (base_type);\n}\n\nstatic const char *get_specification_die_name(const RBinDwarfDie *die) {\n\tst32 linkage_name_attr_idx = find_attr_idx (die, DW_AT_linkage_name);\n\tif (linkage_name_attr_idx != -1 && die->attr_values[linkage_name_attr_idx].string.content) {\n\t\treturn die->attr_values[linkage_name_attr_idx].string.content;\n\t}\n\tst32 name_attr_idx = find_attr_idx (die, DW_AT_name);\n\tif (name_attr_idx != -1 && die->attr_values[name_attr_idx].string.content) {\n\t\treturn die->attr_values[name_attr_idx].string.content;\n\t}\n\treturn NULL;\n}\n\nstatic void get_spec_die_type(Context *ctx, RBinDwarfDie *die, RStrBuf *ret_type) {\n\tst32 attr_idx = find_attr_idx (die, DW_AT_type);\n\tif (attr_idx != -1) {\n\t\tut64 size = 0;\n\t\tparse_type (ctx, die->attr_values[attr_idx].reference, ret_type, &size, NULL);\n\t}\n}\n\n/* For some languages linkage name is more informative like C++,\n   but for Rust it's rubbish and the normal name is fine */\nstatic bool prefer_linkage_name(const char *lang) {\n\tif (lang == NULL) {\n\t\treturn false;\n\t} else if (!strcmp (lang, \"rust\")) {\n\t\treturn false;\n\t} else if (!strcmp (lang, \"ada\")) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void parse_abstract_origin(Context *ctx, ut64 offset, RStrBuf *type, const char **name) {\n\tRBinDwarfDie *die = ht_up_find (ctx->die_map, offset, NULL);\n\tif (die) {\n\t\tsize_t i;\n\t\tut64 size = 0;\n\t\tbool has_linkage_name = false;\n\t\tbool get_linkage_name = prefer_linkage_name (ctx->lang);\n\t\tfor (i = 0; i < die->count; i++) {\n\t\t\tconst RBinDwarfAttrValue *val = &die->attr_values[i];\n\t\t\tswitch (val->attr_name) {\n\t\t\tcase DW_AT_name:\n\t\t\t\tif (!get_linkage_name || !has_linkage_name) {\n\t\t\t\t\t*name = val->string.content;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DW_AT_linkage_name:\n\t\t\tcase DW_AT_MIPS_linkage_name:\n\t\t\t\t*name = val->string.content;\n\t\t\t\thas_linkage_name = true;\n\t\t\t\tbreak;\n\t\t\tcase DW_AT_type:\n\t\t\t\tparse_type (ctx, val->reference, type, &size, NULL);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* x86_64 https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf */\nstatic const char *map_dwarf_reg_to_x86_64_reg(ut64 reg_num, VariableLocationKind *kind) {\n\t*kind = LOCATION_REGISTER;\n\tswitch (reg_num) {\n\t\tcase 0: return \"rax\";\n\t\tcase 1: return \"rdx\";\n\t\tcase 2: return \"rcx\";\n\t\tcase 3: return \"rbx\";\n\t\tcase 4: return \"rsi\";\n\t\tcase 5: return \"rdi\";\n\t\tcase 6:\n\t\t\t*kind = LOCATION_BP;\n\t\t\treturn \"rbp\";\n\t\tcase 7:\n\t\t\t*kind = LOCATION_SP;\n\t\t\treturn \"rsp\";\n\t\tcase 8: return \"r8\";\n\t\tcase 9: return \"r9\";\n\t\tcase 10: return \"r10\";\n\t\tcase 11: return \"r11\";\n\t\tcase 12: return \"r12\";\n\t\tcase 13: return \"r13\";\n\t\tcase 14: return \"r14\";\n\t\tcase 15: return \"r15\";\n\t\tcase 17: return \"xmm0\";\n\t\tcase 18: return \"xmm1\";\n\t\tcase 19: return \"xmm2\";\n\t\tcase 20: return \"xmm3\";\n\t\tcase 21: return \"xmm4\";\n\t\tcase 22: return \"xmm5\";\n\t\tcase 23: return \"xmm6\";\n\t\tcase 24: return \"xmm7\";\n\t\tdefault:\n\t\t\t*kind = LOCATION_UNKNOWN;\n\t\t\treturn \"unsupported_reg\";\n\t}\n}\n\n/* x86 https://01.org/sites/default/files/file_attach/intel386-psabi-1.0.pdf */\nstatic const char *map_dwarf_reg_to_x86_reg(ut64 reg_num, VariableLocationKind *kind) {\n\t*kind = LOCATION_REGISTER;\n\tswitch (reg_num) {\n\t\tcase 0: return \"eax\";\n\t\tcase 1: return \"edx\";\n\t\tcase 2: return \"ecx\";\n\t\tcase 3: return \"ebx\";\n\t\tcase 4:\n\t\t\t*kind = LOCATION_SP;\n\t\t\treturn \"esp\";\n\t\tcase 5:\n\t\t\t*kind = LOCATION_BP;\n\t\t\treturn \"ebp\";\n\t\tcase 6: return \"esi\";\n\t\tcase 7: return \"edi\";\n\t\tcase 21: return \"xmm0\";\n\t\tcase 22: return \"xmm1\";\n\t\tcase 23: return \"xmm2\";\n\t\tcase 24: return \"xmm3\";\n\t\tcase 25: return \"xmm4\";\n\t\tcase 26: return \"xmm5\";\n\t\tcase 27: return \"xmm6\";\n\t\tcase 28: return \"xmm7\";\n\t\tdefault:\n\t\t\tr_warn_if_reached ();\n\t\t\t*kind = LOCATION_UNKNOWN;\n\t\t\treturn \"unsupported_reg\";\n\t}\n}\n\n/* https://refspecs.linuxfoundation.org/ELF/ppc64/PPC-elf64abi-1.9.html#DW-REG */\nstatic const char *map_dwarf_reg_to_ppc64_reg(ut64 reg_num, VariableLocationKind *kind) {\n\t*kind = LOCATION_REGISTER;\n\tswitch (reg_num) {\n\t\tcase 0: return \"r0\";\n\t\tcase 1:\n\t\t\t*kind = LOCATION_SP;\n\t\t\treturn \"r1\";\n\t\tcase 2: return \"r2\";\n\t\tcase 3: return \"r3\";\n\t\tcase 4: return \"r4\";\n\t\tcase 5: return \"r5\";\n\t\tcase 6: return \"r6\";\n\t\tcase 7: return \"r7\";\n\t\tcase 8: return \"r8\";\n\t\tcase 9: return \"r9\";\n\t\tcase 10: return \"r10\";\n\t\tcase 11: return \"r11\";\n\t\tcase 12: return \"r12\";\n\t\tcase 13: return \"r13\";\n\t\tcase 14: return \"r14\";\n\t\tcase 15: return \"r15\";\n\t\tcase 16: return \"r16\";\n\t\tcase 17: return \"r17\";\n\t\tcase 18: return \"r18\";\n\t\tcase 19: return \"r19\";\n\t\tcase 20: return \"r20\";\n\t\tcase 21: return \"r21\";\n\t\tcase 22: return \"r22\";\n\t\tcase 23: return \"r23\";\n\t\tcase 24: return \"r24\";\n\t\tcase 25: return \"r25\";\n\t\tcase 26: return \"r26\";\n\t\tcase 27: return \"r27\";\n\t\tcase 28: return \"r28\";\n\t\tcase 29: return \"r29\";\n\t\tcase 30: return \"r30\";\n\t\tcase 31: return \"r31\";\n\t\tdefault:\n\t\t\tr_warn_if_reached ();\n\t\t\t*kind = LOCATION_UNKNOWN;\n\t\t\treturn \"unsupported_reg\";\n\t}\n}\n\n/* returns string literal register name!\n   TODO add more arches                 */\nstatic const char *get_dwarf_reg_name(char *arch, int reg_num, VariableLocationKind *kind, int bits) {\n\tif (!strcmp (arch, \"x86\")) {\n\t\tif (bits == 64) {\n\t\t\treturn map_dwarf_reg_to_x86_64_reg (reg_num, kind);\n\t\t} else {\n\t\t\treturn map_dwarf_reg_to_x86_reg (reg_num, kind);\n\t\t}\n\t} else if (!strcmp (arch, \"ppc\")) {\n\t\tif (bits == 64) {\n\t\t\treturn map_dwarf_reg_to_ppc64_reg (reg_num, kind);\n\t\t}\n\t}\n\t*kind = LOCATION_UNKNOWN;\n\treturn \"unsupported_reg\";\n}\n\nstatic RBinDwarfLocRange *find_largest_loc_range (RList *loc_list) {\n\tRBinDwarfLocRange *largest = NULL;\n\tut64 max_range_size = 0;\n\tRListIter *iter;\n\tRBinDwarfLocRange *range;\n\tr_list_foreach (loc_list, iter, range) {\n\t\tut64 diff = range->end - range->start;\n\t\tif (diff > max_range_size) {\n\t\t\tmax_range_size = diff ;\n\t\t\tlargest = range;\n\t\t}\n\t}\n\treturn largest;\n}\n\n/* TODO move a lot of the parsing here into dwarf.c and do only processing here */\nstatic VariableLocation *parse_dwarf_location (Context *ctx, const RBinDwarfAttrValue *loc, const RBinDwarfAttrValue *frame_base) {\n\t/* reg5 - val is in register 5\n\tfbreg <leb> - offset from frame base\n\tregx <leb> - contents is in register X\n\taddr <addr> - contents is in at addr\n\tbregXX <leb> - contents is at offset from specified register\n\t- we now support 3 options: SP, BP and register based arguments */\n\n\t/* Loclist offset is usually CONSTANT or REFERENCE at older DWARF versions, new one has LocListPtr for that */\n\tif (loc->kind != DW_AT_KIND_BLOCK && loc->kind != DW_AT_KIND_LOCLISTPTR && loc->kind != DW_AT_KIND_REFERENCE && loc->kind != DW_AT_KIND_CONSTANT) {\n\t\treturn NULL;\n\t}\n\tRBinDwarfBlock block;\n\tif (loc->kind == DW_AT_KIND_LOCLISTPTR || loc->kind == DW_AT_KIND_REFERENCE || loc->kind == DW_AT_KIND_CONSTANT) {\n\t\tut64 offset = loc->reference;\n\t\tRBinDwarfLocList *range_list = ht_up_find (ctx->locations, offset, NULL);\n\t\tif (!range_list) { /* for some reason offset isn't there, wrong parsing or malformed dwarf */\n\t\t\treturn NULL;\n\t\t}\n\t\t/* use the largest range as a variable */\n\t\tRBinDwarfLocRange *range = find_largest_loc_range (range_list->list);\n\t\tif (!range) {\n\t\t\treturn NULL;\n\t\t}\n\t\t/* Very rough and sloppy, refactor this hacked up stuff */\n\t\tblock = *range->expression;\n\t\t// range->expression... etc\n\t} else {\n\t\tblock = loc->block;\n\t}\n\tVariableLocationKind kind = LOCATION_UNKNOWN;\n\tst64 offset = 0;\n\tut64 address = 0;\n\tut64 reg_num = -1;\n\tconst char *reg_name = NULL; /* literal */\n\tsize_t i;\n\tfor (i = 0; i < block.length; i++) {\n\t\tswitch (block.data[i]) {\n\t\tcase DW_OP_fbreg: {\n\t\t/* TODO sometimes CFA is referenced, but we don't parse that yet\n\t\t   just an offset involving framebase of a function*/\n\t\t\tif (i == block.length - 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tconst ut8 *dump = &block.data[++i];\n\t\t\toffset = r_sleb128 (&dump, &block.data[loc->block.length]);\n\t\t\tif (frame_base) {\n\t\t\t\t/* recursive parsing, but frame_base should be only one, but someone\n\t\t\t\t   could make malicious resource exhaustion attack, so a depth counter might be cool? */\n\t\t\t\tVariableLocation *location = parse_dwarf_location (ctx, frame_base, NULL);\n\t\t\t\tif (location) {\n\t\t\t\t\tlocation->offset += offset;\n\t\t\t\t\treturn location;\n\t\t\t\t}\n\t\t\t\treturn NULL;\n\t\t\t} else {\n\t\t\t\t/* Might happen if frame_base has a frame_base reference? I don't think it can tho */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase DW_OP_reg0:\n\t\tcase DW_OP_reg1:\n\t\tcase DW_OP_reg2:\n\t\tcase DW_OP_reg3:\n\t\tcase DW_OP_reg4:\n\t\tcase DW_OP_reg5:\n\t\tcase DW_OP_reg6:\n\t\tcase DW_OP_reg7:\n\t\tcase DW_OP_reg8:\n\t\tcase DW_OP_reg9:\n\t\tcase DW_OP_reg10:\n\t\tcase DW_OP_reg11:\n\t\tcase DW_OP_reg12:\n\t\tcase DW_OP_reg13:\n\t\tcase DW_OP_reg14:\n\t\tcase DW_OP_reg15:\n\t\tcase DW_OP_reg16:\n\t\tcase DW_OP_reg17:\n\t\tcase DW_OP_reg18:\n\t\tcase DW_OP_reg19:\n\t\tcase DW_OP_reg20:\n\t\tcase DW_OP_reg21:\n\t\tcase DW_OP_reg22:\n\t\tcase DW_OP_reg23:\n\t\tcase DW_OP_reg24:\n\t\tcase DW_OP_reg25:\n\t\tcase DW_OP_reg26:\n\t\tcase DW_OP_reg27:\n\t\tcase DW_OP_reg28:\n\t\tcase DW_OP_reg29:\n\t\tcase DW_OP_reg30:\n\t\tcase DW_OP_reg31: {\n\t\t\t/* Will mostly be used for SP based arguments */\n\t\t\t/* TODO I need to find binaries that uses this so I can test it out*/\n\t\t\treg_num = block.data[i] - DW_OP_reg0; // get the reg number\n\t\t\treg_name = get_dwarf_reg_name (ctx->anal->cpu, reg_num, &kind, ctx->anal->bits);\n\t\t\tbreak;\n\t\t}\n\t\tcase DW_OP_breg0:\n\t\tcase DW_OP_breg1:\n\t\tcase DW_OP_breg2:\n\t\tcase DW_OP_breg3:\n\t\tcase DW_OP_breg4:\n\t\tcase DW_OP_breg5:\n\t\tcase DW_OP_breg6:\n\t\tcase DW_OP_breg7:\n\t\tcase DW_OP_breg8:\n\t\tcase DW_OP_breg9:\n\t\tcase DW_OP_breg10:\n\t\tcase DW_OP_breg11:\n\t\tcase DW_OP_breg12:\n\t\tcase DW_OP_breg13:\n\t\tcase DW_OP_breg14:\n\t\tcase DW_OP_breg15:\n\t\tcase DW_OP_breg16:\n\t\tcase DW_OP_breg17:\n\t\tcase DW_OP_breg18:\n\t\tcase DW_OP_breg19:\n\t\tcase DW_OP_breg20:\n\t\tcase DW_OP_breg21:\n\t\tcase DW_OP_breg22:\n\t\tcase DW_OP_breg23:\n\t\tcase DW_OP_breg24:\n\t\tcase DW_OP_breg25:\n\t\tcase DW_OP_breg26:\n\t\tcase DW_OP_breg27:\n\t\tcase DW_OP_breg28:\n\t\tcase DW_OP_breg29:\n\t\tcase DW_OP_breg30:\n\t\tcase DW_OP_breg31: {\n\t\t\tif (i == block.length - 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t/* The single operand of the DW_OP_bregn operations provides\n\t\t\tsigned LEB128 offset from the specified register.  */\n\t\t\treg_num = block.data[i] - DW_OP_breg0; // get the reg number\n\t\t\tconst ut8 *buffer = &block.data[++i];\n\t\t\toffset = r_sleb128 (&buffer, &block.data[block.length]);\n\t\t\t/* TODO do a proper expression parsing, move by the amount of bytes sleb reads */\n\t\t\ti += buffer - &block.data[0];\n\t\t\treg_name = get_dwarf_reg_name (ctx->anal->cpu, reg_num, &kind, ctx->anal->bits);\n\t\t\tbreak;\n\t\t}\n\t\tcase DW_OP_bregx: {\n\t\t\tif (i == block.length - 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t/* 2 operands, reg_number, offset*/\n\t\t\t/* I need to find binaries that uses this so I can test it out*/\n\t\t\tconst ut8 *buffer = &block.data[++i];\n\t\t\tconst ut8 *buf_end = &block.data[block.length];\n\t\t\tbuffer = r_uleb128 (buffer, buf_end - buffer, &reg_num, NULL);\n\t\t\tif (buffer == buf_end) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\toffset = r_sleb128 (&buffer, buf_end);\n\t\t\treg_name = get_dwarf_reg_name (ctx->anal->cpu, reg_num, &kind, ctx->anal->bits);\n\t\t\tbreak;\n\t\t}\n\t\tcase DW_OP_addr: {\n\t\t\t/* The DW_OP_addr operation has a single operand that encodes a machine address and whose\n\t\t\tsize is the size of an address on the target machine.  */\n\t\t\tconst int addr_size = ctx->anal->bits / 8;\n\t\t\tconst ut8 *dump = &block.data[++i];\n\t\t\t/* malformed, not enough bytes to represent address */\n\t\t\tif (block.length - i < addr_size) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tswitch (addr_size) {\n\t\t\tcase 1:\n\t\t\t\taddress = r_read_ble8 (dump);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\taddress = r_read_ble16 (dump, ctx->anal->big_endian);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\taddress = r_read_ble32 (dump, ctx->anal->big_endian);\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\taddress = r_read_ble64 (dump, ctx->anal->big_endian);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr_warn_if_reached (); /* weird addr_size */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tkind = LOCATION_GLOBAL; // address\n\t\t\tbreak;\n\t\t}\n\t\tcase DW_OP_call_frame_cfa: {\n\t\t\t// REMOVE XXX\n\t\t\tkind = LOCATION_BP;\n\t\t\toffset += 16;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (kind == LOCATION_UNKNOWN) {\n\t\treturn NULL;\n\t}\n\tVariableLocation *location = R_NEW0 (VariableLocation);\n\tif (location) {\n\t\tlocation->reg_name = reg_name;\n\t\tlocation->reg_num = reg_num;\n\t\tlocation->kind = kind;\n\t\tlocation->offset = offset;\n\t\tlocation->address = address;\n\t}\n\treturn location;\n}\n\nstatic st32 parse_function_args_and_vars(Context *ctx, ut64 idx, RStrBuf *args, RList/*<Variable*>*/ *variables) {\n\tconst RBinDwarfDie *die = &ctx->all_dies[idx++];\n\n\tif (die->has_children) {\n\t\tint child_depth = 1;\n\n\t\tbool get_linkage_name = prefer_linkage_name (ctx->lang);\n\t\tbool has_linkage_name = false;\n\t\tint argNumber = 1;\n\t\tsize_t j;\n\t\tfor (j = idx; child_depth > 0 && j < ctx->count; j++) {\n\t\t\tconst RBinDwarfDie *child_die = &ctx->all_dies[j];\n\t\t\tRStrBuf type;\n\t\t\tr_strbuf_init (&type);\n\t\t\tconst char *name = NULL;\n\t\t\tif (child_die->tag == DW_TAG_formal_parameter || child_die->tag == DW_TAG_variable) {\n\t\t\t\tVariable *var = R_NEW0 (Variable);\n\t\t\t\tsize_t i;\n\t\t\t\tfor (i = 0; i < child_die->count; i++) {\n\t\t\t\t\tconst RBinDwarfAttrValue *val = &child_die->attr_values[i];\n\t\t\t\t\tswitch (val->attr_name) {\n\t\t\t\t\tcase DW_AT_name:\n\t\t\t\t\t\tif (!get_linkage_name || !has_linkage_name) {\n\t\t\t\t\t\t\tname = val->string.content;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DW_AT_linkage_name:\n\t\t\t\t\tcase DW_AT_MIPS_linkage_name:\n\t\t\t\t\t\tname = val->string.content;\n\t\t\t\t\t\thas_linkage_name = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DW_AT_type:\n\t\t\t\t\t\tparse_type (ctx, val->reference, &type, NULL, NULL);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// abstract origin is supposed to have omitted information\n\t\t\t\t\tcase DW_AT_abstract_origin:\n\t\t\t\t\t\tparse_abstract_origin (ctx, val->reference, &type, &name);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DW_AT_location:\n\t\t\t\t\t\tvar->location = parse_dwarf_location (ctx, val, find_attr (die, DW_AT_frame_base));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (child_die->tag == DW_TAG_formal_parameter && child_depth == 1) {\n\t\t\t\t\t/* arguments sometimes have only type, create generic argX */\n\t\t\t\t\tif (type.len) {\n\t\t\t\t\t\tif (!name) {\n\t\t\t\t\t\t\tvar->name = r_str_newf (\"arg%d\", argNumber);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar->name = strdup (name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_strbuf_appendf (args, \"%s %s,\", r_strbuf_get (&type), var->name);\n\t\t\t\t\t\tvar->type = strdup (r_strbuf_get (&type));\n\t\t\t\t\t\tr_list_append (variables, var);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvariable_free (var);\n\t\t\t\t\t}\n\t\t\t\t\targNumber++;\n\t\t\t\t} else { /* DW_TAG_variable */\n\t\t\t\t\tif (name && type.len) {\n\t\t\t\t\t\tvar->name = strdup (name);\n\t\t\t\t\t\tvar->type = strdup (r_strbuf_get (&type));\n\t\t\t\t\t\tr_list_append (variables, var);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvariable_free (var);\n\t\t\t\t\t}\n\t\t\t\t\tr_strbuf_fini (&type);\n\t\t\t\t}\n\t\t\t} else if (child_depth == 1 && child_die->tag == DW_TAG_unspecified_parameters) {\n\t\t\t\tr_strbuf_appendf (args, \"va_args ...,\");\n\t\t\t}\n\t\t\tif (child_die->has_children) {\n\t\t\t\tchild_depth++;\n\t\t\t}\n\t\t\tif (child_die->abbrev_code == 0) { /* sibling list is terminated by null entry */\n\t\t\t\tchild_depth--;\n\t\t\t}\n\t\t\tr_strbuf_fini (&type);\n\t\t}\n\t\tif (args->len > 0) {\n\t\t\tr_strbuf_slice (args, 0, args->len - 1);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void sdb_save_dwarf_function(Function *dwarf_fcn, RList/*<Variable*>*/ *variables, Sdb *sdb) {\n\tchar *sname = r_str_sanitize_sdb_key (dwarf_fcn->name);\n\tsdb_set (sdb, sname, \"fcn\", 0);\n\n\tchar *addr_key = r_str_newf (\"fcn.%s.addr\", sname);\n\tchar *addr_val = r_str_newf (\"0x%\" PFMT64x \"\", dwarf_fcn->addr);\n\tsdb_set (sdb, addr_key, addr_val, 0);\n\tfree (addr_key);\n\tfree (addr_val);\n\n\t/* so we can have name without sanitization */\n\tchar *name_key = r_str_newf (\"fcn.%s.name\", sname);\n\tchar *name_val = r_str_newf (\"%s\", dwarf_fcn->name);\n\tsdb_set (sdb, name_key, name_val, 0);\n\tfree (name_key);\n\tfree (name_val);\n\n\tchar *signature_key = r_str_newf (\"fcn.%s.sig\", sname);\n\tsdb_set (sdb, signature_key, dwarf_fcn->signature, 0);\n\tfree (signature_key);\n\n\tRStrBuf vars;\n\tr_strbuf_init (&vars);\n\tRListIter *iter;\n\tVariable *var;\n\tr_list_foreach (variables, iter, var) {\n\t\tif (!var->location) {\n\t\t\t/* NULL location probably means optimized out, maybe put a comment there */\n\t\t\tcontinue;\n\t\t}\n\t\tchar *key = NULL;\n\t\tchar *val = NULL;\n\t\tswitch (var->location->kind) {\n\t\tcase LOCATION_BP: {\n\t\t\t/* value = \"type, storage, additional info based on storage (offset)\" */\n\n\t\t\tr_strbuf_appendf (&vars, \"%s,\", var->name);\n\t\t\tkey = r_str_newf (\"fcn.%s.var.%s\", sname, var->name);\n\t\t\tval = r_str_newf (\"%s,%\" PFMT64d \",%s\", \"b\", var->location->offset, var->type);\n\t\t\tsdb_set (sdb, key, val, 0);\n\t\t\tbreak;\n\t\t}\n\t\tcase LOCATION_SP: {\n\t\t\t/* value = \"type, storage, additional info based on storage (offset)\" */\n\n\t\t\tr_strbuf_appendf (&vars, \"%s,\", var->name);\n\t\t\tkey = r_str_newf (\"fcn.%s.var.%s\", sname, var->name);\n\t\t\tval = r_str_newf (\"%s,%\" PFMT64d \",%s\", \"s\", var->location->offset, var->type);\n\t\t\tsdb_set (sdb, key, val, 0);\n\t\t\tbreak;\n\t\t}\n\t\tcase LOCATION_GLOBAL: {\n\t\t\t/* value = \"type, storage, additional info based on storage (address)\" */\n\n\t\t\tr_strbuf_appendf (&vars, \"%s,\", var->name);\n\t\t\tkey = r_str_newf (\"fcn.%s.var.%s\", sname, var->name);\n\t\t\tval = r_str_newf (\"%s,%\" PFMT64u \",%s\", \"g\", var->location->address, var->type);\n\t\t\tsdb_set (sdb, key, val, 0);\n\t\t\tbreak;\n\t\t}\n\t\tcase LOCATION_REGISTER: {\n\t\t\t/* value = \"type, storage, additional info based on storage (register name)\" */\n\n\t\t\tr_strbuf_appendf (&vars, \"%s,\", var->name);\n\t\t\tkey = r_str_newf (\"fcn.%s.var.%s\", sname, var->name);\n\t\t\tval = r_str_newf (\"%s,%s,%s\", \"r\", var->location->reg_name, var->type);\n\t\t\tsdb_set (sdb, key, val, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\t/* else location is unknown (optimized out), skip the var */\n\t\t\tbreak;\n\t\t}\n\t\tfree (key);\n\t\tfree (val);\n\t}\n\tif (vars.len > 0) { /* remove the extra , */\n\t\tr_strbuf_slice (&vars, 0, vars.len - 1); /* leaks? */\n\t}\n\tchar *vars_key = r_str_newf (\"fcn.%s.vars\", sname);\n\tchar *vars_val = r_str_newf (\"%s\", r_strbuf_get (&vars));\n\tsdb_set (sdb, vars_key, vars_val, 0);\n\tfree (vars_key);\n\tfree (vars_val);\n\tr_strbuf_fini (&vars);\n\tfree (sname);\n}\n\n/**\n * @brief Parse function,it's arguments, variables and\n *        save the information into the Sdb\n *\n * @param ctx\n * @param idx Current entry index\n */\nstatic void parse_function(Context *ctx, ut64 idx) {\n\tconst RBinDwarfDie *die = &ctx->all_dies[idx];\n\n\tFunction fcn = { 0 };\n\tbool has_linkage_name = false;\n\tbool get_linkage_name = prefer_linkage_name (ctx->lang);\n\tRStrBuf ret_type;\n\tr_strbuf_init (&ret_type);\n\tif (find_attr_idx (die, DW_AT_declaration) != -1) {\n\t\treturn; /* just declaration skip */\n\t}\n\tsize_t i;\n\t/* For rust binaries prefer regular name not linkage TODO */\n\tfor (i = 0; i < die->count; i++) {\n\t\tRBinDwarfAttrValue *val = &die->attr_values[i];\n\t\tswitch (die->attr_values[i].attr_name) {\n\t\tcase DW_AT_name:\n\t\t\tif (!get_linkage_name || !has_linkage_name) {\n\t\t\t\tfcn.name = val->string.content;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DW_AT_linkage_name:\n\t\tcase DW_AT_MIPS_linkage_name:\n\t\t\tfcn.name = val->string.content;\n\t\t\thas_linkage_name = true;\n\t\t\tbreak;\n\t\tcase DW_AT_low_pc:\n\t\tcase DW_AT_entry_pc:\n\t\t\tfcn.addr = val->address;\n\t\t\tbreak;\n\t\tcase DW_AT_specification: /* reference to declaration DIE with more info */\n\t\t{\n\t\t\tRBinDwarfDie *spec_die = ht_up_find (ctx->die_map, val->reference, NULL);\n\t\t\tif (spec_die) {\n\t\t\t\tfcn.name = get_specification_die_name (spec_die); /* I assume that if specification has a name, this DIE hasn't */\n\t\t\t\tget_spec_die_type (ctx, spec_die, &ret_type);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase DW_AT_type:\n\t\t\tparse_type (ctx, val->reference, &ret_type, NULL, NULL);\n\t\t\tbreak;\n\t\tcase DW_AT_virtuality:\n\t\t\tfcn.is_method = true; /* method specific attr */\n\t\t\tfcn.is_virtual = true;\n\t\t\tbreak;\n\t\tcase DW_AT_object_pointer:\n\t\t\tfcn.is_method = true;\n\t\t\tbreak;\n\t\tcase DW_AT_vtable_elem_location:\n\t\t\tfcn.is_method = true;\n\t\t\tfcn.vtable_addr = 0; /* TODO we might use this information */\n\t\t\tbreak;\n\t\tcase DW_AT_accessibility:\n\t\t\tfcn.is_method = true;\n\t\t\tfcn.access = (ut8)val->uconstant;\n\t\t\tbreak;\n\t\tcase DW_AT_external:\n\t\t\tfcn.is_external = true;\n\t\t\tbreak;\n\t\tcase DW_AT_trampoline:\n\t\t\tfcn.is_trampoline = true;\n\t\t\tbreak;\n\t\tcase DW_AT_ranges:\n\t\tcase DW_AT_high_pc:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!fcn.name || !fcn.addr) { /* we need a name, faddr */\n\t\tgoto cleanup;\n\t}\n\tRStrBuf args;\n\tr_strbuf_init (&args);\n\t/* TODO do the same for arguments in future so we can use their location */\n\tRList/*<Variable*>*/  *variables = r_list_new ();\n\tparse_function_args_and_vars (ctx, idx, &args, variables);\n\n\tif (ret_type.len == 0) { /* DW_AT_type is omitted in case of `void` ret type */\n\t\tr_strbuf_append (&ret_type, \"void\");\n\t}\n\tr_warn_if_fail (ctx->lang);\n\tchar *new_name = ctx->anal->binb.demangle (NULL, ctx->lang, fcn.name, fcn.addr, false);\n\tfcn.name = new_name ? new_name : strdup (fcn.name);\n\tfcn.signature = r_str_newf (\"%s %s(%s);\", r_strbuf_get (&ret_type), fcn.name, r_strbuf_get (&args));\n\tsdb_save_dwarf_function (&fcn, variables, ctx->sdb);\n\n\tfree ((char *)fcn.signature);\n\tfree ((char *)fcn.name);\n\n\tRListIter *iter;\n\tVariable *var;\n\tr_list_foreach (variables, iter, var) {\n\t\tvariable_free (var);\n\t}\n\tr_list_free (variables);\n\tr_strbuf_fini (&args);\ncleanup:\n\tr_strbuf_fini (&ret_type);\n}\n\n/**\n * @brief Get's language from comp unit for demangling\n *\n * @param die\n * @return char* string literal language represantation for demangling BinDemangle\n */\nstatic const char *parse_comp_unit_lang(const RBinDwarfDie *die) {\n\tr_return_val_if_fail (die, NULL);\n\n\tint idx = find_attr_idx (die, DW_AT_language);\n\tconst char *lang = \"cxx\"; // default fallback\n\tif (idx == -1) {\n\t\t/* What to do now, it should have  one?, just assume C++ */\n\t\treturn lang;\n\t}\n\tconst RBinDwarfAttrValue *val = &die->attr_values[idx];\n\tr_warn_if_fail (val->kind == DW_AT_KIND_CONSTANT);\n\n\tswitch (val->uconstant)\n\t{\n\tcase DW_LANG_Java:\n\t\treturn \"java\";\n\tcase DW_LANG_ObjC:\n\t/* subideal, TODO research if dwarf gives me enough info to properly separate C++ and ObjC mangling */\n\tcase DW_LANG_ObjC_plus_plus:\n\t\treturn \"objc\";\n\tcase DW_LANG_D:\n\t\treturn \"dlang\";\n\tcase DW_LANG_Rust:\n\t\treturn \"rust\";\n\tcase DW_LANG_C_plus_plus:\n\tcase DW_LANG_C_plus_plus_14:\n\t/* no demangling available */\n\tcase DW_LANG_Ada83:\n\tcase DW_LANG_Cobol74:\n\tcase DW_LANG_Cobol85:\n\tcase DW_LANG_Fortran77:\n\tcase DW_LANG_Fortran90:\n\tcase DW_LANG_Pascal83:\n\tcase DW_LANG_Modula2:\n\tcase DW_LANG_Ada95:\n\tcase DW_LANG_Fortran95:\n\tcase DW_LANG_PLI:\n\tcase DW_LANG_Python:\n\tcase DW_LANG_Swift:\n\tcase DW_LANG_Julia:\n\tcase DW_LANG_Dylan:\n\tcase DW_LANG_Fortran03:\n\tcase DW_LANG_Fortran08:\n\tcase DW_LANG_UPC:\n\tcase DW_LANG_C:\n\tcase DW_LANG_C89:\n\tcase DW_LANG_C99:\n\tcase DW_LANG_C11:\n\tdefault:\n\t\treturn lang;\n\t}\n\treturn lang;\n}\n\n/**\n * @brief Delegates DIE to it's proper parsing method\n *\n * @param ctx\n * @param idx index of the current entry\n */\nstatic void parse_type_entry(Context *ctx, ut64 idx) {\n\tr_return_if_fail (ctx);\n\n\tconst RBinDwarfDie *die = &ctx->all_dies[idx];\n\tswitch (die->tag) {\n\tcase DW_TAG_structure_type:\n\tcase DW_TAG_union_type:\n\tcase DW_TAG_class_type:\n\t\tparse_structure_type (ctx, idx);\n\t\tbreak;\n\tcase DW_TAG_enumeration_type:\n\t\tparse_enum_type (ctx, idx);\n\t\tbreak;\n\tcase DW_TAG_typedef:\n\t\tparse_typedef (ctx, idx);\n\t\tbreak;\n\tcase DW_TAG_base_type:\n\t\tparse_atomic_type (ctx, idx);\n\t\tbreak;\n\tcase DW_TAG_subprogram:\n\t\tparse_function (ctx, idx);\n\t\tbreak;\n\tcase DW_TAG_compile_unit:\n\t\t/* used for name demangling */\n\t\tctx->lang = parse_comp_unit_lang (die);\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/**\n * @brief Parses type and function information out of DWARF entries\n *        and stores them to the sdb for further use\n *\n * @param anal\n * @param ctx\n */\nR_API void r_anal_dwarf_process_info(const RAnal *anal, RAnalDwarfContext *ctx) {\n\tr_return_if_fail (ctx && anal);\n\tSdb *dwarf_sdb =  sdb_ns (anal->sdb, \"dwarf\", 1);\n\tsize_t i, j;\n\tconst RBinDwarfDebugInfo *info = ctx->info;\n\tfor (i = 0; i < info->count; i++) {\n\t\tRBinDwarfCompUnit *unit = &info->comp_units[i];\n\t\tContext dw_context = { // context per unit?\n\t\t\t.anal = anal,\n\t\t\t.all_dies = unit->dies,\n\t\t\t.count = unit->count,\n\t\t\t.die_map = info->lookup_table,\n\t\t\t.sdb = dwarf_sdb,\n\t\t\t.locations = ctx->loc,\n\t\t\t.lang = NULL\n\t\t};\n\t\tfor (j = 0; j < unit->count; j++) {\n\t\t\tparse_type_entry (&dw_context, j);\n\t\t}\n\t}\n}\n\nbool filter_sdb_function_names(void *user, const char *k, const char *v) {\n\t(void) user;\n\t(void) k;\n\treturn !strcmp (v, \"fcn\");\n}\n\n/**\n * @brief Use parsed DWARF function info from Sdb in the anal functions\n *  XXX right now we only save parsed name and variables, we can't use signature now\n *  XXX refactor to be more readable\n * @param anal\n * @param dwarf_sdb\n */\nR_API void r_anal_dwarf_integrate_functions(RAnal *anal, RFlag *flags, Sdb *dwarf_sdb) {\n\tr_return_if_fail (anal && dwarf_sdb);\n\n\t/* get all entries with value == func */\n\tSdbList *sdb_list = sdb_foreach_list_filter (dwarf_sdb, filter_sdb_function_names, false);\n\tSdbListIter *it;\n\tSdbKv *kv;\n\t/* iterate all function entries */\n\tls_foreach (sdb_list, it, kv) {\n\t\tchar *func_sname = kv->base.key;\n\n\t\tchar *addr_key = r_str_newf (\"fcn.%s.addr\", func_sname);\n\t\tut64 faddr = sdb_num_get (dwarf_sdb, addr_key, 0);\n\t\tfree (addr_key);\n\n\t\t/* if the function is analyzed so we can edit */\n\t\tRAnalFunction *fcn = r_anal_get_function_at (anal, faddr);\n\t\tif (fcn) {\n\t\t\t/* prepend dwarf debug info stuff with dbg. */\n\t\t\tchar *real_name_key = r_str_newf (\"fcn.%s.name\", func_sname);\n\t\t\tchar *real_name = sdb_get (dwarf_sdb, real_name_key, 0);\n\t\t\tfree (real_name_key);\n\n\t\t\tchar *dwf_name = r_str_newf (\"dbg.%s\", real_name);\n\t\t\tfree (real_name);\n\n\t\t\tr_anal_function_rename (fcn, dwf_name);\n\t\t\tfree (dwf_name);\n\n\t\t\tchar *tmp = r_str_newf (\"fcn.%s.sig\", func_sname);\n\t\t\tchar *fcnstr = sdb_get (dwarf_sdb, tmp, 0);\n\t\t\tfree (tmp);\n\t\t\t/* Apply signature as a comment at a function address */\n\t\t\tr_meta_set_string (anal, R_META_TYPE_COMMENT, faddr, fcnstr);\n\t\t\tfree (fcnstr);\n\t\t}\n\t\tchar *var_names_key = r_str_newf (\"fcn.%s.vars\", func_sname);\n\t\tchar *vars = sdb_get (dwarf_sdb, var_names_key, NULL);\n\t\tchar *var_name;\n\t\tsdb_aforeach (var_name, vars) {\n\t\t\tchar *var_key = r_str_newf (\"fcn.%s.var.%s\", func_sname, var_name);\n\t\t\tchar *var_data = sdb_get (dwarf_sdb, var_key, NULL);\n\t\t\tif (!var_data) {\n\t\t\t\tgoto loop_end;\n\t\t\t}\n\t\t\tchar *extra = NULL;\n\t\t\tchar *kind = sdb_anext (var_data, &extra);\n\t\t\tchar *type = NULL;\n\t\t\textra = sdb_anext (extra, &type);\n\t\t\tst64 offset = 0;\n\t\t\tif (*kind != 'r') {\n\t\t\t\toffset = strtol (extra, NULL, 10);\n\t\t\t}\n\t\t\tif (*kind == 'g') { /* global, fixed addr TODO add size to variables? */\n\t\t\t\tchar *global_name = r_str_newf (\"global_%s\", var_name);\n\t\t\t\tr_flag_unset_off (flags, offset);\n\t\t\t\tr_flag_set_next (flags, global_name, offset, 4);\n\t\t\t\tfree (global_name);\n\t\t\t} else if (*kind == 's' && fcn) {\n\t\t\t\tr_anal_function_set_var (fcn, offset - fcn->maxstack, *kind, type, 4, false, var_name);\n\t\t\t} else if (*kind == 'r' && fcn) {\n\t\t\t\tRRegItem *i = r_reg_get (anal->reg, extra, -1);\n\t\t\t\tif (!i) {\n\t\t\t\t\tgoto loop_end;\n\t\t\t\t}\n\t\t\t\tr_anal_function_set_var (fcn, i->index, *kind, type, 4, false, var_name);\n\t\t\t} else if (fcn) { /* kind == 'b' */\n\t\t\t\tr_anal_function_set_var (fcn, offset - fcn->bp_off, *kind, type, 4, false, var_name);\n\t\t\t}\n\t\t\tfree (var_key);\n\t\t\tfree (var_data);\n\t\tloop_end:\n\t\t\tsdb_aforeach_next (var_name);\n\t\t}\n\t\tfree (var_names_key);\n\t\tfree (vars);\n\t}\n\tls_free (sdb_list);\n}\n", "/* radare - LGPL - Copyright 2012-2018 - pancake, Fedor Sakharov */\n\n#define D0 if(1)\n#define D1 if(1)\n\n#include <errno.h>\n\n#define DWARF_DUMP 0\n\n#if DWARF_DUMP\n#define DBGFD stdout\n#else\n#define DBGFD NULL\n#endif\n\n#include <r_bin.h>\n#include <r_bin_dwarf.h>\n#include <r_core.h>\n\n#define STANDARD_OPERAND_COUNT_DWARF2 9\n#define STANDARD_OPERAND_COUNT_DWARF3 12\n#define R_BIN_DWARF_INFO 1\n\n// endianness setting global\nstatic bool big_end = false;\n\n/* This macro seems bad regarding to endianess XXX, use only for single byte */\n#define READ(buf, type)                                             \\\n\t(((buf) + sizeof (type) < buf_end) ? *((type *)(buf)) : 0); \\\n\t(buf) += sizeof (type)\n#define READ8(buf)                                                \\\n\t(((buf) + sizeof (ut8) < buf_end) ? ((ut8 *)buf)[0] : 0); \\\n\t(buf) += sizeof (ut8)\n#define READ16(buf)                                                            \\\n\t(((buf) + sizeof (ut16) < buf_end) ? r_read_ble16 (buf, big_end) : 0); \\\n\t(buf) += sizeof (ut16)\n#define READ32(buf)                                                            \\\n\t(((buf) + sizeof (ut32) < buf_end) ? r_read_ble32 (buf, big_end) : 0); \\\n\t(buf) += sizeof (ut32)\n#define READ64(buf)                                                            \\\n\t(((buf) + sizeof (ut64) < buf_end) ? r_read_ble64 (buf, big_end) : 0); \\\n\t(buf) += sizeof (ut64)\n\nstatic const char *dwarf_tag_name_encodings[] = {\n\t[DW_TAG_null_entry] = \"DW_TAG_null_entry\",\n\t[DW_TAG_array_type] = \"DW_TAG_array_type\",\n\t[DW_TAG_class_type] = \"DW_TAG_class_type\",\n\t[DW_TAG_entry_point] = \"DW_TAG_entry_point\",\n\t[DW_TAG_enumeration_type] = \"DW_TAG_enumeration_type\",\n\t[DW_TAG_formal_parameter] = \"DW_TAG_formal_parameter\",\n\t[DW_TAG_imported_declaration] = \"DW_TAG_imported_declaration\",\n\t[DW_TAG_label] = \"DW_TAG_label\",\n\t[DW_TAG_lexical_block] = \"DW_TAG_lexical_block\",\n\t[DW_TAG_member] = \"DW_TAG_member\",\n\t[DW_TAG_pointer_type] = \"DW_TAG_pointer_type\",\n\t[DW_TAG_reference_type] = \"DW_TAG_reference_type\",\n\t[DW_TAG_compile_unit] = \"DW_TAG_compile_unit\",\n\t[DW_TAG_string_type] = \"DW_TAG_string_type\",\n\t[DW_TAG_structure_type] = \"DW_TAG_structure_type\",\n\t[DW_TAG_subroutine_type] = \"DW_TAG_subroutine_type\",\n\t[DW_TAG_typedef] = \"DW_TAG_typedef\",\n\t[DW_TAG_union_type] = \"DW_TAG_union_type\",\n\t[DW_TAG_unspecified_parameters] = \"DW_TAG_unspecified_parameters\",\n\t[DW_TAG_variant] = \"DW_TAG_variant\",\n\t[DW_TAG_common_block] = \"DW_TAG_common_block\",\n\t[DW_TAG_common_inclusion] = \"DW_TAG_common_inclusion\",\n\t[DW_TAG_inheritance] = \"DW_TAG_inheritance\",\n\t[DW_TAG_inlined_subroutine] = \"DW_TAG_inlined_subroutine\",\n\t[DW_TAG_module] = \"DW_TAG_module\",\n\t[DW_TAG_ptr_to_member_type] = \"DW_TAG_ptr_to_member_type\",\n\t[DW_TAG_set_type] = \"DW_TAG_set_type\",\n\t[DW_TAG_subrange_type] = \"DW_TAG_subrange_type\",\n\t[DW_TAG_with_stmt] = \"DW_TAG_with_stmt\",\n\t[DW_TAG_access_declaration] = \"DW_TAG_access_declaration\",\n\t[DW_TAG_base_type] = \"DW_TAG_base_type\",\n\t[DW_TAG_catch_block] = \"DW_TAG_catch_block\",\n\t[DW_TAG_const_type] = \"DW_TAG_const_type\",\n\t[DW_TAG_constant] = \"DW_TAG_constant\",\n\t[DW_TAG_enumerator] = \"DW_TAG_enumerator\",\n\t[DW_TAG_file_type] = \"DW_TAG_file_type\",\n\t[DW_TAG_friend] = \"DW_TAG_friend\",\n\t[DW_TAG_namelist] = \"DW_TAG_namelist\",\n\t[DW_TAG_namelist_item] = \"DW_TAG_namelist_item\",\n\t[DW_TAG_packed_type] = \"DW_TAG_packed_type\",\n\t[DW_TAG_subprogram] = \"DW_TAG_subprogram\",\n\t[DW_TAG_template_type_param] = \"DW_TAG_template_type_param\",\n\t[DW_TAG_template_value_param] = \"DW_TAG_template_value_param\",\n\t[DW_TAG_thrown_type] = \"DW_TAG_thrown_type\",\n\t[DW_TAG_try_block] = \"DW_TAG_try_block\",\n\t[DW_TAG_variant_part] = \"DW_TAG_variant_part\",\n\t[DW_TAG_variable] = \"DW_TAG_variable\",\n\t[DW_TAG_volatile_type] = \"DW_TAG_volatile_type\",\n\t[DW_TAG_dwarf_procedure] = \"DW_TAG_dwarf_procedure\",\n\t[DW_TAG_restrict_type] = \"DW_TAG_restrict_type\",\n\t[DW_TAG_interface_type] = \"DW_TAG_interface_type\",\n\t[DW_TAG_namespace] = \"DW_TAG_namespace\",\n\t[DW_TAG_imported_module] = \"DW_TAG_imported_module\",\n\t[DW_TAG_unspecified_type] = \"DW_TAG_unspecified_type\",\n\t[DW_TAG_partial_unit] = \"DW_TAG_partial_unit\",\n\t[DW_TAG_imported_unit] = \"DW_TAG_imported_unit\",\n\t[DW_TAG_mutable_type] = \"DW_TAG_mutable_type\",\n\t[DW_TAG_condition] = \"DW_TAG_condition\",\n\t[DW_TAG_shared_type] = \"DW_TAG_shared_type\",\n\t[DW_TAG_type_unit] = \"DW_TAG_type_unit\",\n\t[DW_TAG_rvalue_reference_type] = \"DW_TAG_rvalue_reference_type\",\n\t[DW_TAG_template_alias] = \"DW_TAG_template_alias\",\n\t[DW_TAG_LAST] = \"DW_TAG_LAST\",\n};\n\nstatic const char *dwarf_attr_encodings[] = {\n\t[DW_AT_sibling] = \"DW_AT_siblings\",\n\t[DW_AT_location] = \"DW_AT_location\",\n\t[DW_AT_name] = \"DW_AT_name\",\n\t[DW_AT_ordering] = \"DW_AT_ordering\",\n\t[DW_AT_byte_size] = \"DW_AT_byte_size\",\n\t[DW_AT_bit_size] = \"DW_AT_bit_size\",\n\t[DW_AT_stmt_list] = \"DW_AT_stmt_list\",\n\t[DW_AT_low_pc] = \"DW_AT_low_pc\",\n\t[DW_AT_high_pc] = \"DW_AT_high_pc\",\n\t[DW_AT_language] = \"DW_AT_language\",\n\t[DW_AT_discr] = \"DW_AT_discr\",\n\t[DW_AT_discr_value] = \"DW_AT_discr_value\",\n\t[DW_AT_visibility] = \"DW_AT_visibility\",\n\t[DW_AT_import] = \"DW_AT_import\",\n\t[DW_AT_string_length] = \"DW_AT_string_length\",\n\t[DW_AT_common_reference] = \"DW_AT_common_reference\",\n\t[DW_AT_comp_dir] = \"DW_AT_comp_dir\",\n\t[DW_AT_const_value] = \"DW_AT_const_value\",\n\t[DW_AT_containing_type] = \"DW_AT_containing_type\",\n\t[DW_AT_default_value] = \"DW_AT_default_value\",\n\t[DW_AT_inline] = \"DW_AT_inline\",\n\t[DW_AT_is_optional] = \"DW_AT_is_optional\",\n\t[DW_AT_lower_bound] = \"DW_AT_lower_bound\",\n\t[DW_AT_producer] = \"DW_AT_producer\",\n\t[DW_AT_prototyped] = \"DW_AT_prototyped\",\n\t[DW_AT_return_addr] = \"DW_AT_return_addr\",\n\t[DW_AT_start_scope] = \"DW_AT_start_scope\",\n\t[DW_AT_stride_size] = \"DW_AT_stride_size\",\n\t[DW_AT_upper_bound] = \"DW_AT_upper_bound\",\n\t[DW_AT_abstract_origin] = \"DW_AT_abstract_origin\",\n\t[DW_AT_accessibility] = \"DW_AT_accessibility\",\n\t[DW_AT_address_class] = \"DW_AT_address_class\",\n\t[DW_AT_artificial] = \"DW_AT_artificial\",\n\t[DW_AT_base_types] = \"DW_AT_base_types\",\n\t[DW_AT_calling_convention] = \"DW_AT_calling_convention\",\n\t[DW_AT_count] = \"DW_AT_count\",\n\t[DW_AT_data_member_location] = \"DW_AT_data_member_location\",\n\t[DW_AT_decl_column] = \"DW_AT_decl_column\",\n\t[DW_AT_decl_file] = \"DW_AT_decl_file\",\n\t[DW_AT_decl_line] = \"DW_AT_decl_line\",\n\t[DW_AT_declaration] = \"DW_AT_declaration\",\n\t[DW_AT_discr_list] = \"DW_AT_discr_list\",\n\t[DW_AT_encoding] = \"DW_AT_encoding\",\n\t[DW_AT_external] = \"DW_AT_external\",\n\t[DW_AT_frame_base] = \"DW_AT_frame_base\",\n\t[DW_AT_friend] = \"DW_AT_friend\",\n\t[DW_AT_identifier_case] = \"DW_AT_identifier_case\",\n\t[DW_AT_macro_info] = \"DW_AT_macro_info\",\n\t[DW_AT_namelist_item] = \"DW_AT_namelist_item\",\n\t[DW_AT_priority] = \"DW_AT_priority\",\n\t[DW_AT_segment] = \"DW_AT_segment\",\n\t[DW_AT_specification] = \"DW_AT_specification\",\n\t[DW_AT_static_link] = \"DW_AT_static_link\",\n\t[DW_AT_type] = \"DW_AT_type\",\n\t[DW_AT_use_location] = \"DW_AT_use_location\",\n\t[DW_AT_variable_parameter] = \"DW_AT_variable_parameter\",\n\t[DW_AT_virtuality] = \"DW_AT_virtuality\",\n\t[DW_AT_vtable_elem_location] = \"DW_AT_vtable_elem_location\",\n\t[DW_AT_allocated] = \"DW_AT_allocated\",\n\t[DW_AT_associated] = \"DW_AT_associated\",\n\t[DW_AT_data_location] = \"DW_AT_data_location\",\n\t[DW_AT_byte_stride] = \"DW_AT_byte_stride\",\n\t[DW_AT_entry_pc] = \"DW_AT_entry_pc\",\n\t[DW_AT_use_UTF8] = \"DW_AT_use_UTF8\",\n\t[DW_AT_extension] = \"DW_AT_extension\",\n\t[DW_AT_ranges] = \"DW_AT_ranges\",\n\t[DW_AT_trampoline] = \"DW_AT_trampoline\",\n\t[DW_AT_call_column] = \"DW_AT_call_column\",\n\t[DW_AT_call_file] = \"DW_AT_call_file\",\n\t[DW_AT_call_line] = \"DW_AT_call_line\",\n\t[DW_AT_description] = \"DW_AT_description\",\n\t[DW_AT_binary_scale] = \"DW_AT_binary_scale\",\n\t[DW_AT_decimal_scale] = \"DW_AT_decimal_scale\",\n\t[DW_AT_small] = \"DW_AT_small\",\n\t[DW_AT_decimal_sign] = \"DW_AT_decimal_sign\",\n\t[DW_AT_digit_count] = \"DW_AT_digit_count\",\n\t[DW_AT_picture_string] = \"DW_AT_picture_string\",\n\t[DW_AT_mutable] = \"DW_AT_mutable\",\n\t[DW_AT_threads_scaled] = \"DW_AT_threads_scaled\",\n\t[DW_AT_explicit] = \"DW_AT_explicit\",\n\t[DW_AT_object_pointer] = \"DW_AT_object_pointer\",\n\t[DW_AT_endianity] = \"DW_AT_endianity\",\n\t[DW_AT_elemental] = \"DW_AT_elemental\",\n\t[DW_AT_pure] = \"DW_AT_pure\",\n\t[DW_AT_recursive] = \"DW_AT_recursive\",\n\t[DW_AT_signature] = \"DW_AT_signature\",\n\t[DW_AT_main_subprogram] = \"DW_AT_main_subprogram\",\n\t[DW_AT_data_bit_offset] = \"DW_AT_data_big_offset\",\n\t[DW_AT_const_expr] = \"DW_AT_const_expr\",\n\t[DW_AT_enum_class] = \"DW_AT_enum_class\",\n\t[DW_AT_linkage_name] = \"DW_AT_linkage_name\",\n\t[DW_AT_string_length_bit_size] = \"DW_AT_string_length_bit_size\",\n\t[DW_AT_string_length_byte_size] = \"DW_AT_string_length_byte_size\",\n\t[DW_AT_rank] = \"DW_AT_rank\",\n\t[DW_AT_str_offsets_base] = \"DW_AT_str_offsets_base\",\n\t[DW_AT_addr_base] = \"DW_AT_addr_base\",\n\t[DW_AT_rnglists_base] = \"DW_AT_rnglists_base\",\n\t[DW_AT_dwo_name] = \"DW_AT_dwo_name\",\n\t[DW_AT_reference] = \"DW_AT_reference\",\n\t[DW_AT_rvalue_reference] = \"DW_AT_rvalue_reference\",\n\t[DW_AT_macros] = \"DW_AT_macros\",\n\t[DW_AT_call_all_calls] = \"DW_AT_call_all_calls\",\n\t[DW_AT_call_all_source_calls] = \"DW_AT_call_all_source_calls\",\n\t[DW_AT_call_all_tail_calls] = \"DW_AT_call_all_tail_calls\",\n\t[DW_AT_call_return_pc] = \"DW_AT_call_return_pc\",\n\t[DW_AT_call_value] = \"DW_AT_call_value\",\n\t[DW_AT_call_origin] = \"DW_AT_call_origin\",\n\t[DW_AT_call_parameter] = \"DW_AT_call_parameter\",\n\t[DW_AT_call_pc] = \"DW_AT_call_pc\",\n\t[DW_AT_call_tail_call] = \"DW_AT_call_tail_call\",\n\t[DW_AT_call_target] = \"DW_AT_call_target\",\n\t[DW_AT_call_target_clobbered] = \"DW_AT_call_target_clobbered\",\n\t[DW_AT_call_data_location] = \"DW_AT_call_data_location\",\n\t[DW_AT_call_data_value] = \"DW_AT_call_data_value\",\n\t[DW_AT_noreturn] = \"DW_AT_noreturn\",\n\t[DW_AT_alignment] = \"DW_AT_alignment\",\n\t[DW_AT_export_symbols] = \"DW_AT_export_symbols\",\n\t[DW_AT_deleted] = \"DW_AT_deleted\",\n\t[DW_AT_defaulted] = \"DW_AT_defaulted\",\n\t[DW_AT_loclists_base] = \"DW_AT_loclists_base\",\n\n\t[DW_AT_lo_user] = \"DW_AT_lo_user\",\n\t[DW_AT_MIPS_linkage_name] = \"DW_AT_MIPS_linkage_name\",\n\t[DW_AT_GNU_call_site_value] = \"DW_AT_GNU_call_site_value\",\n\t[DW_AT_GNU_call_site_data_value] = \"DW_AT_GNU_call_site_data_value\",\n\t[DW_AT_GNU_call_site_target] = \"DW_AT_GNU_call_site_target\",\n\t[DW_AT_GNU_call_site_target_clobbered] = \"DW_AT_GNU_call_site_target_clobbered\",\n\t[DW_AT_GNU_tail_call] = \"DW_AT_GNU_tail_call\",\n\t[DW_AT_GNU_all_tail_call_sites] = \"DW_AT_GNU_all_tail_call_sites\",\n\t[DW_AT_GNU_all_call_sites] = \"DW_AT_GNU_all_call_sites\",\n\t[DW_AT_GNU_all_source_call_sites] = \"DW_AT_GNU_all_source_call_sites\",\n\t[DW_AT_GNU_macros] = \"DW_AT_GNU_macros\",\n\t[DW_AT_GNU_deleted] = \"DW_AT_GNU_deleted\",\n\t[DW_AT_GNU_dwo_name] = \"DW_AT_GNU_dwo_name\",\n\t[DW_AT_GNU_dwo_id] = \"DW_AT_GNU_dwo_id\",\n\t[DW_AT_GNU_ranges_base] = \"DW_AT_GNU_ranges_base\",\n\t[DW_AT_GNU_addr_base] = \"DW_AT_GNU_addr_base\",\n\t[DW_AT_GNU_pubnames] = \"DW_AT_GNU_pubnames\",\n\t[DW_AT_GNU_pubtypes] = \"DW_AT_GNU_pubtypes\",\n\t[DW_AT_hi_user] = \"DW_AT_hi_user\",\n};\n\nstatic const char *dwarf_attr_form_encodings[] = {\n\t[DW_FORM_addr] = \"DW_FORM_addr\",\n\t[DW_FORM_block2] = \"DW_FORM_block2\",\n\t[DW_FORM_block4] = \"DW_FORM_block4\",\n\t[DW_FORM_data2] = \"DW_FORM_data2\",\n\t[DW_FORM_data4] = \"DW_FORM_data4\",\n\t[DW_FORM_data8] = \"DW_FORM_data8\",\n\t[DW_FORM_string] = \"DW_FORM_string\",\n\t[DW_FORM_block] = \"DW_FORM_block\",\n\t[DW_FORM_block1] = \"DW_FORM_block1\",\n\t[DW_FORM_data1] = \"DW_FORM_data1\",\n\t[DW_FORM_flag] = \"DW_FORM_flag\",\n\t[DW_FORM_sdata] = \"DW_FORM_sdata\",\n\t[DW_FORM_strp] = \"DW_FORM_strp\",\n\t[DW_FORM_udata] = \"DW_FORM_udata\",\n\t[DW_FORM_ref_addr] = \"DW_FORM_ref_addr\",\n\t[DW_FORM_ref1] = \"DW_FORM_ref1\",\n\t[DW_FORM_ref2] = \"DW_FORM_ref2\",\n\t[DW_FORM_ref4] = \"DW_FORM_ref4\",\n\t[DW_FORM_ref8] = \"DW_FORM_ref8\",\n\t[DW_FORM_ref_udata] = \"DW_FORM_ref_udata\",\n\t[DW_FORM_indirect] = \"DW_FORM_indirect\",\n\t[DW_FORM_sec_offset] = \"DW_FORM_sec_offset\",\n\t[DW_FORM_exprloc] = \"DW_FORM_exprloc\",\n\t[DW_FORM_flag_present] = \"DW_FORM_flag_present\",\n\t[DW_FORM_strx] = \"DW_FORM_strx\",\n\t[DW_FORM_addrx] = \"DW_FORM_addrx\",\n\t[DW_FORM_ref_sup4] = \"DW_FORM_ref_sup4\",\n\t[DW_FORM_strp_sup] = \"DW_FORM_strp_sup\",\n\t[DW_FORM_data16] = \"DW_FORM_data16\",\n\t[DW_FORM_line_ptr] = \"DW_FORM_line_ptr\",\n\t[DW_FORM_ref_sig8] = \"DW_FORM_ref_sig8\",\n\t[DW_FORM_implicit_const] = \"DW_FORM_implicit_const\",\n\t[DW_FORM_loclistx] = \"DW_FORM_loclistx\",\n\t[DW_FORM_rnglistx] = \"DW_FORM_rnglistx\",\n\t[DW_FORM_ref_sup8] = \"DW_FORM_ref_sup8\",\n\t[DW_FORM_strx1] = \"DW_FORM_strx1\",\n\t[DW_FORM_strx2] = \"DW_FORM_strx2\",\n\t[DW_FORM_strx3] = \"DW_FORM_strx3\",\n\t[DW_FORM_strx4] = \"DW_FORM_strx4\",\n\t[DW_FORM_addrx1] = \"DW_FORM_addrx1\",\n\t[DW_FORM_addrx2] = \"DW_FORM_addrx2\",\n\t[DW_FORM_addrx3] = \"DW_FORM_addrx3\",\n\t[DW_FORM_addrx4] = \"DW_FORM_addrx4\",\n};\n\nstatic const char *dwarf_langs[] = {\n\t[DW_LANG_C89] = \"C89\",\n\t[DW_LANG_C] = \"C\",\n\t[DW_LANG_Ada83] = \"Ada83\",\n\t[DW_LANG_C_plus_plus] = \"C++\",\n\t[DW_LANG_Cobol74] = \"Cobol74\",\n\t[DW_LANG_Cobol85] = \"Cobol85\",\n\t[DW_LANG_Fortran77] = \"Fortran77\",\n\t[DW_LANG_Fortran90] = \"Fortran90\",\n\t[DW_LANG_Pascal83] = \"Pascal83\",\n\t[DW_LANG_Modula2] = \"Modula2\",\n\t[DW_LANG_Java] = \"Java\",\n\t[DW_LANG_C99] = \"C99\",\n\t[DW_LANG_Ada95] = \"Ada95\",\n\t[DW_LANG_Fortran95] = \"Fortran95\",\n\t[DW_LANG_PLI] = \"PLI\",\n\t[DW_LANG_ObjC] = \"ObjC\",\n\t[DW_LANG_ObjC_plus_plus] = \"ObjC_plus_plus\",\n\t[DW_LANG_UPC] = \"UPC\",\n\t[DW_LANG_D] = \"D\",\n\t[DW_LANG_Python] = \"Python\",\n\t[DW_LANG_Rust] = \"Rust\",\n\t[DW_LANG_C11] = \"C11\",\n\t[DW_LANG_Swift] = \"Swift\",\n\t[DW_LANG_Julia] = \"Julia\",\n\t[DW_LANG_Dylan] = \"Dylan\",\n\t[DW_LANG_C_plus_plus_14] = \"C++14\",\n\t[DW_LANG_Fortran03] = \"Fortran03\",\n\t[DW_LANG_Fortran08] = \"Fortran08\"\n};\n\nstatic const char *dwarf_unit_types[] = {\n\t[DW_UT_compile] = \"DW_UT_compile\",\n\t[DW_UT_type] = \"DW_UT_type\",\n\t[DW_UT_partial] = \"DW_UT_partial\",\n\t[DW_UT_skeleton] = \"DW_UT_skeleton\",\n\t[DW_UT_split_compile] = \"DW_UT_split_compile\",\n\t[DW_UT_split_type] = \"DW_UT_split_type\",\n\t[DW_UT_lo_user] = \"DW_UT_lo_user\",\n\t[DW_UT_hi_user] = \"DW_UT_hi_user\",\n};\n\nstatic int abbrev_cmp(const void *a, const void *b) {\n\tconst RBinDwarfAbbrevDecl *first = a;\n\tconst RBinDwarfAbbrevDecl *second = b;\n\n\tif (first->offset > second->offset) {\n\t\treturn 1;\n\t} else if (first->offset < second->offset) {\n\t\treturn -1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic inline bool is_printable_attr(ut64 attr_code) {\n\treturn (attr_code >= DW_AT_sibling && attr_code <= DW_AT_loclists_base) ||\n\t\t\tattr_code == DW_AT_MIPS_linkage_name ||\n\t\t\t(attr_code >= DW_AT_GNU_call_site_value && attr_code <= DW_AT_GNU_deleted) ||\n\t\t\t(attr_code >= DW_AT_GNU_dwo_name && attr_code <= DW_AT_GNU_pubtypes);\n}\n\nstatic inline bool is_printable_form(ut64 form_code) {\n\treturn form_code >= DW_FORM_addr && form_code <= DW_FORM_addrx4;\n}\n\nstatic inline bool is_printable_tag(ut64 attr_code) {\n\treturn attr_code <= DW_TAG_LAST;\n}\n\nstatic inline bool is_printable_unit_type(ut64 unit_type) {\n\treturn unit_type > 0 && unit_type <= DW_UT_split_type;\n}\n\n/**\n * @brief Reads 64/32 bit unsigned based on format\n *\n * @param is_64bit Format of the comp unit\n * @param buf Pointer to the buffer to read from, to update after read\n * @param buf_end To check the boundary /for READ macro/\n * @return ut64 Read value\n */\nstatic inline ut64 dwarf_read_offset(bool is_64bit, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tif (is_64bit) {\n\t\tresult = READ64 (*buf);\n\t} else {\n\t\tresult = READ32 (*buf);\n\t}\n\treturn result;\n}\n\nstatic inline ut64 dwarf_read_address(size_t size, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tswitch (size) {\n\t\tcase 2:\n\t\tresult = READ16 (*buf); break;\n\t\tcase 4:\n\t\tresult = READ32 (*buf); break;\n\t\tcase 8:\n\t\tresult = READ64 (*buf); break;\n\t\tdefault:\n\t\tresult = 0;\n\t\t*buf += size;\n\t\teprintf (\"Weird dwarf address size: %zu.\", size);\n\t}\n\treturn result;\n}\n\nstatic int add_sdb_include_dir(Sdb *s, const char *incl, int idx) {\n\tif (!s || !incl) {\n\t\treturn false;\n\t}\n\treturn sdb_array_set (s, \"includedirs\", idx, incl, 0);\n}\n\nstatic void line_header_fini(RBinDwarfLineHeader *hdr) {\n\tif (hdr) {\n\t\tsize_t i;\n\n\t\tfor (i = 0; i < hdr->file_names_count; i ++) {\n\t\t\tfree (hdr->file_names[i].name);\n\t\t}\n\n\t\tfree (hdr->std_opcode_lengths);\n\t\tfree (hdr->file_names);\n\t}\n}\n\n// Parses source file header of DWARF version <= 4\nstatic const ut8 *parse_line_header_source(RBinFile *bf, const ut8 *buf, const ut8 *buf_end,\n\tRBinDwarfLineHeader *hdr, Sdb *sdb, int mode, PrintfCallback print) {\n\tint i = 0;\n\tsize_t count;\n\tconst ut8 *tmp_buf = NULL;\n\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\" The Directory Table:\\n\");\n\t}\n\twhile (buf + 1 < buf_end) {\n\t\tsize_t maxlen = R_MIN ((size_t) (buf_end - buf) - 1, 0xfff);\n\t\tsize_t len = r_str_nlen ((const char *)buf, maxlen);\n\t\tchar *str = r_str_ndup ((const char *)buf, len);\n\t\tif (len < 1 || len >= 0xfff || !str) {\n\t\t\tbuf += 1;\n\t\t\tfree (str);\n\t\t\tbreak;\n\t\t}\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"  %d     %s\\n\", i + 1, str);\n\t\t}\n\t\tadd_sdb_include_dir (sdb, str, i);\n\t\tfree (str);\n\t\ti++;\n\t\tbuf += len + 1;\n\t}\n\n\ttmp_buf = buf;\n\tcount = 0;\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"\\n\");\n\t\tprint (\" The File Name Table:\\n\");\n\t\tprint (\"  Entry Dir     Time      Size       Name\\n\");\n\t}\n\tint entry_index = 1; // used for printing information\n\n\tfor (i = 0; i < 2; i++) {\n\t\twhile (buf + 1 < buf_end) {\n\t\t\tconst char *filename = (const char *)buf;\n\t\t\tsize_t maxlen = R_MIN ((size_t) (buf_end - buf - 1), 0xfff);\n\t\t\tut64 id_idx, mod_time, file_len;\n\t\t\tsize_t len = r_str_nlen (filename, maxlen);\n\n\t\t\tif (!len) {\n\t\t\t\tbuf++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf += len + 1;\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &id_idx, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &mod_time, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &file_len, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tif (i) {\n\t\t\t\tchar *include_dir = NULL, *comp_dir = NULL, *pinclude_dir = NULL;\n\t\t\t\tif (id_idx > 0) {\n\t\t\t\t\tinclude_dir = pinclude_dir = sdb_array_get (sdb, \"includedirs\", id_idx - 1, 0);\n\t\t\t\t\tif (include_dir && include_dir[0] != '/') {\n\t\t\t\t\t\tcomp_dir = sdb_get (bf->sdb_addrinfo, \"DW_AT_comp_dir\", 0);\n\t\t\t\t\t\tif (comp_dir) {\n\t\t\t\t\t\t\tinclude_dir = r_str_newf(\"%s/%s/\", comp_dir, include_dir);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tinclude_dir = pinclude_dir = sdb_get (bf->sdb_addrinfo, \"DW_AT_comp_dir\", 0);\n\t\t\t\t\tif (!include_dir) {\n\t\t\t\t\t\tinclude_dir = \"./\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (hdr->file_names) {\n\t\t\t\t\thdr->file_names[count].name = r_str_newf(\"%s/%s\", r_str_get (include_dir), filename);\n\t\t\t\t\thdr->file_names[count].id_idx = id_idx;\n\t\t\t\t\thdr->file_names[count].mod_time = mod_time;\n\t\t\t\t\thdr->file_names[count].file_len = file_len;\n\t\t\t\t}\n\t\t\t\tif (comp_dir) {\n\t\t\t\t\tR_FREE (include_dir);\n\t\t\t\t\tR_FREE (comp_dir);\n\t\t\t\t}\n\t\t\t\tR_FREE (pinclude_dir);\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (mode == R_MODE_PRINT && i) {\n\t\t\t\tprint (\"  %d     %\" PFMT64d \"       %\" PFMT64d \"         %\" PFMT64d \"          %s\\n\", entry_index++, id_idx, mod_time, file_len, filename);\n\t\t\t}\n\t\t}\n\t\tif (i == 0) {\n\t\t\tif (count > 0) {\n\t\t\t\thdr->file_names = calloc (sizeof (file_entry), count);\n\t\t\t} else {\n\t\t\t\thdr->file_names = NULL;\n\t\t\t}\n\t\t\thdr->file_names_count = count;\n\t\t\tbuf = tmp_buf;\n\t\t\tcount = 0;\n\t\t}\n\t}\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"\\n\");\n\t}\n\nbeach:\n\tsdb_free (sdb);\n\n\treturn buf;\n}\n// TODO DWARF 5 line header parsing, very different from ver. 4\n// Because this function needs ability to parse a lot of FORMS just like debug info\n// I'll complete this function after completing debug_info parsing and merging\n// for the meanwhile I am skipping the space.\nstatic const ut8 *parse_line_header_source_dwarf5(RBinFile *bf, const ut8 *buf, const ut8 *buf_end,\n\tRBinDwarfLineHeader *hdr, Sdb *sdb, int mode) {\n// \tint i = 0;\n// \tsize_t count;\n// \tconst ut8 *tmp_buf = NULL;\n\n// \tut8 dir_entry_count = READ8 (buf);\n// \t// uleb128 pairs\n// \tut8 dir_count = READ8 (buf);\n\n// \t// dirs\n\n// \tut8 file_entry_count = READ8 (buf);\n// \t// uleb128 pairs\n// \tut8 file_count = READ8 (buf);\n// \t// file names\n\n// beach:\n// \tsdb_free (sdb);\n\n\treturn NULL;\n}\n\nstatic const ut8 *parse_line_header (\n\tRBinFile *bf, const ut8 *buf, const ut8 *buf_end,\n\tRBinDwarfLineHeader *hdr, int mode, PrintfCallback print) {\n\n\tr_return_val_if_fail(hdr && bf && buf, NULL);\n\n\thdr->is_64bit = false;\n\thdr->unit_length = READ32 (buf);\n\n\tif (hdr->unit_length == DWARF_INIT_LEN_64) {\n\t\thdr->unit_length = READ64 (buf);\n\t\thdr->is_64bit = true;\n\t}\n\n\thdr->version = READ16 (buf);\n\n\tif (hdr->version == 5) {\n\t\thdr->address_size = READ8 (buf);\n\t\thdr->segment_selector_size = READ8 (buf);\n\t}\n\n\thdr->header_length = dwarf_read_offset(hdr->is_64bit, &buf, buf_end);\n\n\tconst ut8 *tmp_buf = buf; // So I can skip parsing DWARF 5 headers for now\n\n\tif (buf_end - buf < 8) {\n\t\treturn NULL;\n\t}\n\thdr->min_inst_len = READ8 (buf);\n\tif (hdr->version >= 4) {\n\t\thdr->max_ops_per_inst = READ8 (buf);\n\t}\n\thdr->default_is_stmt = READ8 (buf);\n\thdr->line_base = READ (buf, int8_t); // signed\n\thdr->line_range = READ8 (buf);\n\thdr->opcode_base = READ8 (buf);\n\n\thdr->file_names_count = 0;\n\thdr->file_names = NULL;\n\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\" Header information:\\n\");\n\t\tprint (\"  Length:                             %\" PFMT64u \"\\n\", hdr->unit_length);\n\t\tprint (\"  DWARF Version:                      %d\\n\", hdr->version);\n\t\tprint (\"  Header Length:                      %\" PFMT64d \"\\n\", hdr->header_length);\n\t\tprint (\"  Minimum Instruction Length:         %d\\n\", hdr->min_inst_len);\n\t\tprint (\"  Maximum Operations per Instruction: %d\\n\", hdr->max_ops_per_inst);\n\t\tprint (\"  Initial value of 'is_stmt':         %d\\n\", hdr->default_is_stmt);\n\t\tprint (\"  Line Base:                          %d\\n\", hdr->line_base);\n\t\tprint (\"  Line Range:                         %d\\n\", hdr->line_range);\n\t\tprint (\"  Opcode Base:                        %d\\n\\n\", hdr->opcode_base);\n\t}\n\n\tif (hdr->opcode_base > 0) {\n\t\thdr->std_opcode_lengths = calloc (sizeof (ut8), hdr->opcode_base);\n\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\" Opcodes:\\n\");\n\t\t}\n\t\tsize_t i;\n\t\tfor (i = 1; i < hdr->opcode_base; i++) {\n\t\t\tif (buf + 2 > buf_end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thdr->std_opcode_lengths[i] = READ (buf, ut8);\n\t\t\tif (mode == R_MODE_PRINT) {\n\t\t\t\tprint (\"  Opcode %zu has %d arg\\n\", i, hdr->std_opcode_lengths[i]);\n\t\t\t}\n\t\t}\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"\\n\");\n\t\t}\n\t} else {\n\t\thdr->std_opcode_lengths = NULL;\n\t}\n\t// TODO finish parsing of source files out of DWARF 5 header\n\t// for now we skip\n\tif (hdr->version == 5) {\n\t\ttmp_buf += hdr->header_length;\n\t\treturn tmp_buf;\n\t}\n\n\tSdb *sdb = sdb_new (NULL, NULL, 0);\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\n\tif (hdr->version <= 4) {\n\t\tbuf = parse_line_header_source (bf, buf, buf_end, hdr, sdb, mode, print);\n\t} else { // because Version 5 source files are very different\n\t\tbuf = parse_line_header_source_dwarf5 (bf, buf, buf_end, hdr, sdb, mode);\n\t}\n\n\treturn buf;\n}\n\nstatic inline void add_sdb_addrline(Sdb *s, ut64 addr, const char *file, ut64 line, int mode, PrintfCallback print) {\n\tconst char *p;\n\tchar *fileline;\n\tchar offset[64];\n\tchar *offset_ptr;\n\n\tif (!s || !file) {\n\t\treturn;\n\t}\n\tp = r_str_rchr (file, NULL, '/');\n\tif (p) {\n\t\tp++;\n\t} else {\n\t\tp = file;\n\t}\n\t// includedirs and properly check full paths\n\tswitch (mode) {\n\tcase 1:\n\tcase 'r':\n\tcase '*':\n\t\tprint (\"CL %s:%d 0x%08\"PFMT64x\"\\n\", p, (int)line, addr);\n\t\tbreak;\n\t}\n#if 0\n\t/* THIS IS TOO SLOW */\n\tif (r_file_exists (file)) {\n\t\tp = file;\n\t}\n#else\n\tp = file;\n#endif\n\tfileline = r_str_newf (\"%s|%\"PFMT64d, p, line);\n\toffset_ptr = sdb_itoa (addr, offset, 16);\n\tsdb_add (s, offset_ptr, fileline, 0);\n\tsdb_add (s, fileline, offset_ptr, 0);\n\tfree (fileline);\n}\n\nstatic const ut8 *parse_ext_opcode(const RBin *bin, const ut8 *obuf,\n\tsize_t len, const RBinDwarfLineHeader *hdr,\n\tRBinDwarfSMRegisters *regs, int mode) {\n\n\tr_return_val_if_fail (bin && bin->cur && obuf && hdr && regs, NULL);\n\n\tPrintfCallback print = bin->cb_printf;\n\tconst ut8 *buf;\n\tconst ut8 *buf_end;\n\tut8 opcode;\n\tut64 addr;\n\tbuf = obuf;\n\tst64 op_len;\n\tRBinFile *binfile = bin->cur;\n\tRBinObject *o = binfile->o;\n\tut32 addr_size = o && o->info && o->info->bits ? o->info->bits / 8 : 4;\n\tconst char *filename;\n\n\tbuf_end = buf + len;\n\tbuf = r_leb128 (buf, len, &op_len);\n\tif (buf >= buf_end) {\n\t\treturn NULL;\n\t}\n\n\topcode = *buf++;\n\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"  Extended opcode %d: \", opcode);\n\t}\n\n\tswitch (opcode) {\n\tcase DW_LNE_end_sequence:\n\t\tregs->end_sequence = DWARF_TRUE;\n\n\t\tif (binfile && binfile->sdb_addrinfo && hdr->file_names) {\n\t\t\tint fnidx = regs->file - 1;\n\t\t\tif (fnidx >= 0 && fnidx < hdr->file_names_count) {\n\t\t\t\tadd_sdb_addrline(binfile->sdb_addrinfo, regs->address,\n\t\t\t\t\t\thdr->file_names[fnidx].name, regs->line, mode, print);\n\t\t\t}\n\t\t}\n\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"End of Sequence\\n\");\n\t\t}\n\t\tbreak;\n\tcase DW_LNE_set_address:\n\t\tif (addr_size == 8) {\n\t\t\taddr = READ64 (buf);\n\t\t} else {\n\t\t\taddr = READ32 (buf);\n\t\t}\n\t\tregs->address = addr;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set Address to 0x%\"PFMT64x\"\\n\", addr);\n\t\t}\n\t\tbreak;\n\tcase DW_LNE_define_file:\n\t\tfilename = (const char*)buf;\n\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"define_file\\n\");\n\t\t\tprint (\"filename %s\\n\", filename);\n\t\t}\n\n\t\tbuf += (strlen (filename) + 1);\n\t\tut64 dir_idx;\n\t\tut64 ignore;\n\t\tif (buf + 1 < buf_end) {\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &dir_idx, NULL);\n\t\t}\n\t\tif (buf + 1 < buf_end) {\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &ignore, NULL);\n\t\t}\n\t\tif (buf + 1 < buf_end) {\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &ignore, NULL);\n\t\t}\n\t\tbreak;\n\tcase DW_LNE_set_discriminator:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &addr, NULL);\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set Discriminator to %\"PFMT64d\"\\n\", addr);\n\t\t}\n\t\tregs->discriminator = addr;\n\t\tbreak;\n\tdefault:\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Unexpected ext opcode %d\\n\", opcode);\n\t\t}\n\t\tbuf = NULL;\n\t\tbreak;\n\t}\n\n\treturn buf;\n}\n\nstatic const ut8 *parse_spec_opcode(\n\tconst RBin *bin, const ut8 *obuf, size_t len,\n\tconst RBinDwarfLineHeader *hdr,\n\tRBinDwarfSMRegisters *regs,\n\tut8 opcode, int mode) {\n\n\tr_return_val_if_fail (bin && obuf && hdr && regs, NULL);\n\n\tPrintfCallback print = bin->cb_printf;\n\tRBinFile *binfile = bin->cur;\n\tconst ut8 *buf = obuf;\n\tut8 adj_opcode = 0;\n\tut64 advance_adr;\n\n\tadj_opcode = opcode - hdr->opcode_base;\n\tif (!hdr->line_range) {\n\t\t// line line-range information. move away\n\t\treturn NULL;\n\t}\n\tadvance_adr = (adj_opcode / hdr->line_range) * hdr->min_inst_len;\n\tregs->address += advance_adr;\n\tint line_increment =  hdr->line_base + (adj_opcode % hdr->line_range);\n\tregs->line += line_increment;\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"  Special opcode %d: \", adj_opcode);\n\t\tprint (\"advance Address by %\"PFMT64d\" to 0x%\"PFMT64x\" and Line by %d to %\"PFMT64d\"\\n\",\n\t\t\tadvance_adr, regs->address, line_increment, regs->line);\n\t}\n\tif (binfile && binfile->sdb_addrinfo && hdr->file_names) {\n\t\tint idx = regs->file -1;\n\t\tif (idx >= 0 && idx < hdr->file_names_count) {\n\t\t\tadd_sdb_addrline (binfile->sdb_addrinfo, regs->address,\n\t\t\t\t\thdr->file_names[idx].name,\n\t\t\t\t\tregs->line, mode, print);\n\t\t}\n\t}\n\tregs->basic_block = DWARF_FALSE;\n\tregs->prologue_end = DWARF_FALSE;\n\tregs->epilogue_begin = DWARF_FALSE;\n\tregs->discriminator = 0;\n\n\treturn buf;\n}\n\nstatic const ut8 *parse_std_opcode(\n\tconst RBin *bin, const ut8 *obuf, size_t len,\n\tconst RBinDwarfLineHeader *hdr, RBinDwarfSMRegisters *regs,\n\tut8 opcode, int mode) {\n\n\tr_return_val_if_fail (bin && bin->cur && obuf && hdr && regs, NULL);\n\n\tPrintfCallback print = bin->cb_printf;\n\tRBinFile *binfile = bin->cur;\n\tconst ut8* buf = obuf;\n\tconst ut8* buf_end = obuf + len;\n\tut64 addr = 0LL;\n\tst64 sbuf;\n\tut8 adj_opcode;\n\tut64 op_advance;\n\tut16 operand;\n\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"  \"); // formatting\n\t}\n\tswitch (opcode) {\n\tcase DW_LNS_copy:\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Copy\\n\");\n\t\t}\n\t\tif (binfile && binfile->sdb_addrinfo && hdr->file_names) {\n\t\t\tint fnidx = regs->file - 1;\n\t\t\tif (fnidx >= 0 && fnidx < hdr->file_names_count) {\n\t\t\t\tadd_sdb_addrline (binfile->sdb_addrinfo,\n\t\t\t\t\tregs->address,\n\t\t\t\t\thdr->file_names[fnidx].name,\n\t\t\t\t\tregs->line, mode, print);\n\t\t\t}\n\t\t}\n\t\tregs->basic_block = DWARF_FALSE;\n\t\tbreak;\n\tcase DW_LNS_advance_pc:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &addr, NULL);\n\t\tregs->address += addr * hdr->min_inst_len;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Advance PC by %\"PFMT64d\" to 0x%\"PFMT64x\"\\n\",\n\t\t\t\taddr * hdr->min_inst_len, regs->address);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_advance_line:\n\t\tbuf = r_leb128(buf, buf_end - buf, &sbuf);\n\t\tregs->line += sbuf;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Advance line by %\"PFMT64d\", to %\"PFMT64d\"\\n\", sbuf, regs->line);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_file:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &addr, NULL);\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Set file to %\"PFMT64d\"\\n\", addr);\n\t\t}\n\t\tregs->file = addr;\n\t\tbreak;\n\tcase DW_LNS_set_column:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &addr, NULL);\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Set column to %\"PFMT64d\"\\n\", addr);\n\t\t}\n\t\tregs->column = addr;\n\t\tbreak;\n\tcase DW_LNS_negate_stmt:\n\t\tregs->is_stmt = regs->is_stmt ? DWARF_FALSE : DWARF_TRUE;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Set is_stmt to %d\\n\", regs->is_stmt);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_basic_block:\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set_basic_block\\n\");\n\t\t}\n\t\tregs->basic_block = DWARF_TRUE;\n\t\tbreak;\n\tcase DW_LNS_const_add_pc:\n\t\tadj_opcode = 255 - hdr->opcode_base;\n\t\tif (hdr->line_range > 0) { // to dodge division by zero\n\t\t\top_advance = (adj_opcode / hdr->line_range) * hdr->min_inst_len;\n\t\t} else {\n\t\t\top_advance = 0;\n\t\t}\n\t\tregs->address += op_advance;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Advance PC by constant %\"PFMT64d\" to 0x%\"PFMT64x\"\\n\",\n\t\t\t\top_advance, regs->address);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_fixed_advance_pc:\n\t\toperand = READ16 (buf);\n\t\tregs->address += operand;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Fixed advance pc to %\"PFMT64d\"\\n\", regs->address);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_prologue_end:\n\t\tregs->prologue_end = ~0;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set_prologue_end\\n\");\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_epilogue_begin:\n\t\tregs->epilogue_begin = ~0;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set_epilogue_begin\\n\");\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_isa:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &addr, NULL);\n\t\tregs->isa = addr;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set_isa\\n\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Unexpected std opcode %d\\n\", opcode);\n\t\t}\n\t\tbreak;\n\t}\n\treturn buf;\n}\n\nstatic void set_regs_default(const RBinDwarfLineHeader *hdr, RBinDwarfSMRegisters *regs) {\n\tregs->address = 0;\n\tregs->file = 1;\n\tregs->line = 1;\n\tregs->column = 0;\n\tregs->is_stmt = hdr->default_is_stmt;\n\tregs->basic_block = DWARF_FALSE;\n\tregs->end_sequence = DWARF_FALSE;\n\tregs->prologue_end = DWARF_FALSE;\n\tregs->epilogue_begin = DWARF_FALSE;\n\tregs->isa = 0;\n}\n\n// Passing bin should be unnecessary (after we stop printing inside bin_dwarf)\nstatic size_t parse_opcodes(const RBin *bin, const ut8 *obuf,\n\t\tsize_t len, const RBinDwarfLineHeader *hdr,\n\t\tRBinDwarfSMRegisters *regs, int mode) {\n\tconst ut8 *buf, *buf_end;\n\tut8 opcode, ext_opcode;\n\n\tif (!bin || !obuf || len < 8) {\n\t\treturn 0;\n\t}\n\tbuf = obuf;\n\tbuf_end = obuf + len;\n\n\twhile (buf && buf + 1 < buf_end) {\n\t\topcode = *buf++;\n\t\tlen--;\n\t\tif (!opcode) {\n\t\t\text_opcode = *buf;\n\t\t\tbuf = parse_ext_opcode (bin, buf, len, hdr, regs, mode);\n\t\t\tif (!buf || ext_opcode == DW_LNE_end_sequence) {\n\t\t\t\tset_regs_default (hdr, regs); // end_sequence should reset regs to default\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (opcode >= hdr->opcode_base) {\n\t\t\tbuf = parse_spec_opcode (bin, buf, len, hdr, regs, opcode, mode);\n\t\t} else {\n\t\t\tbuf = parse_std_opcode (bin, buf, len, hdr, regs, opcode, mode);\n\t\t}\n\t\tlen = (size_t)(buf_end - buf);\n\t}\n\tif (mode == R_MODE_PRINT) {\n\t\tbin->cb_printf (\"\\n\"); // formatting of the output\n\t}\n\tif (!buf) {\n\t\treturn 0;\n\t}\n\treturn (size_t) (buf - obuf); // number of bytes we've moved by\n}\n\nstatic bool parse_line_raw(const RBin *a, const ut8 *obuf, ut64 len, int mode) {\n\tr_return_val_if_fail(a && obuf, false);\n\tPrintfCallback print = a->cb_printf;\n\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"Raw dump of debug contents of section .debug_line:\\n\\n\");\n\t}\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + len;\n\tconst ut8 *tmpbuf = NULL;\n\n\tRBinDwarfLineHeader hdr = { 0 };\n\tut64 buf_size;\n\n\t// each iteration we read one header AKA comp. unit\n\twhile (buf <= buf_end) {\n\t\t// How much did we read from the compilation unit\n\t\tsize_t bytes_read = 0;\n\t\t// calculate how much we've read by parsing header\n\t\t// because header unit_length includes itself\n\t\tbuf_size = buf_end - buf;\n\n\t\ttmpbuf = buf;\n\t\tbuf = parse_line_header (a->cur, buf, buf_end, &hdr, mode, print);\n\t\tif (!buf) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\" Line Number Statements:\\n\");\n\t\t}\n\t\tbytes_read = buf - tmpbuf;\n\n\t\tRBinDwarfSMRegisters regs;\n\t\tset_regs_default (&hdr, &regs);\n\n\t\t// If there is more bytes in the buffer than size of the header\n\t\t// It means that there has to be another header/comp.unit\n\t\tif (buf_size > hdr.unit_length) {\n\t\t\tbuf_size = hdr.unit_length + (hdr.is_64bit * 8 + 4); // we dif against bytes_read, but\n\t\t\t\t// unit_length doesn't account unit_length field\n\t\t}\n\t\t// this deals with a case that there is compilation unit with any line information\n\t\tif (buf_size == bytes_read) {\n\t\t\tif (mode == R_MODE_PRINT) {\n\t\t\t\tprint (\" Line table is present, but no lines present\\n\");\n\t\t\t}\n\t\t\tline_header_fini (&hdr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf_size > (buf_end - buf) + bytes_read || buf > buf_end) {\n\t\t\tline_header_fini (&hdr);\n\t\t\treturn false;\n\t\t}\n\t\tsize_t tmp_read = 0;\n\t\t// we read the whole compilation unit (that might be composed of more sequences)\n\t\tdo {\n\t\t\t// reads one whole sequence\n\t\t\ttmp_read = parse_opcodes (a, buf, buf_end - buf, &hdr, &regs, mode);\n\t\t\tbytes_read += tmp_read;\n\t\t\tbuf += tmp_read; // Move in the buffer forward\n\t\t} while (bytes_read < buf_size && tmp_read != 0); // if nothing is read -> error, exit\n\n\t\tline_header_fini (&hdr);\n\t\tif (!tmp_read) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n#define READ_BUF(x,y) if (idx+sizeof(y)>=len) { return false;} \\\n\t(x)=*(y*)buf; idx+=sizeof(y);buf+=sizeof(y)\n\n#define READ_BUF64(x) if (idx+sizeof(ut64)>=len) { return false;} \\\n\t(x)=r_read_ble64(buf, big_end); idx+=sizeof(ut64);buf+=sizeof(ut64)\n#define READ_BUF32(x) if (idx+sizeof(ut32)>=len) { return false;} \\\n\t(x)=r_read_ble32(buf, big_end); idx+=sizeof(ut32);buf+=sizeof(ut32)\n#define READ_BUF16(x) if (idx+sizeof(ut16)>=len) { return false;} \\\n\t(x)=r_read_ble16(buf, big_end); idx+=sizeof(ut16);buf+=sizeof(ut16)\n\nstatic int parse_aranges_raw(const ut8 *obuf, int len, int mode, PrintfCallback print) {\n\tut32 length, offset;\n\tut16 version;\n\tut32 debug_info_offset;\n\tut8 address_size, segment_size;\n\tconst ut8 *buf = obuf;\n\tint idx = 0;\n\n\tif (!buf || len< 4) {\n\t\treturn false;\n\t}\n\n\tREAD_BUF32 (length);\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"parse_aranges\\n\");\n\t\tprint (\"length 0x%x\\n\", length);\n\t}\n\n\tif (idx + 12 >= len) {\n\t\treturn false;\n\t}\n\n\tREAD_BUF16 (version);\n\tif (mode == R_MODE_PRINT) {\n\t\tprint(\"Version %d\\n\", version);\n\t}\n\n\tREAD_BUF32 (debug_info_offset);\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"Debug info offset %d\\n\", debug_info_offset);\n\t}\n\n\tREAD_BUF (address_size, ut8);\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"address size %d\\n\", (int)address_size);\n\t}\n\n\tREAD_BUF (segment_size, ut8);\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"segment size %d\\n\", (int)segment_size);\n\t}\n\n\toffset = segment_size + address_size * 2;\n\n\tif (offset) {\n\t\tut64 n = (((ut64) (size_t)buf / offset) + 1) * offset - ((ut64)(size_t)buf);\n\t\tif (idx+n>=len) {\n\t\t\treturn false;\n\t\t}\n\t\tbuf += n;\n\t\tidx += n;\n\t}\n\n\twhile ((buf - obuf) < len) {\n\t\tut64 adr, length;\n\t\tif ((idx+8)>=len) {\n\t\t\tbreak;\n\t\t}\n\t\tREAD_BUF64 (adr);\n\t\tREAD_BUF64 (length);\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"length 0x%\" PFMT64x \" address 0x%\" PFMT64x \"\\n\", length, adr);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int init_debug_info(RBinDwarfDebugInfo *inf) {\n\tif (!inf) {\n\t\treturn -1;\n\t}\n\tinf->comp_units = calloc (sizeof (RBinDwarfCompUnit), DEBUG_INFO_CAPACITY);\n\n\tinf->lookup_table = ht_up_new0 ();\n\n\tif (!inf->comp_units) {\n\t\treturn -1;\n\t}\n\n\tinf->capacity = DEBUG_INFO_CAPACITY;\n\tinf->count = 0;\n\treturn true;\n}\n\nstatic int init_die(RBinDwarfDie *die, ut64 abbr_code, ut64 attr_count) {\n\tif (!die) {\n\t\treturn -1;\n\t}\n\tdie->attr_values = calloc (sizeof (RBinDwarfAttrValue), attr_count);\n\tif (!die->attr_values) {\n\t\treturn -1;\n\t}\n\tdie->abbrev_code = abbr_code;\n\tdie->capacity = attr_count;\n\tdie->count = 0;\n\treturn 0;\n}\n\nstatic int init_comp_unit(RBinDwarfCompUnit *cu) {\n\tif (!cu) {\n\t\treturn -EINVAL;\n\t}\n\tcu->dies = calloc (sizeof (RBinDwarfDie), COMP_UNIT_CAPACITY);\n\tif (!cu->dies) {\n\t\treturn -ENOMEM;\n\t}\n\tcu->capacity = COMP_UNIT_CAPACITY;\n\tcu->count = 0;\n\treturn 0;\n}\n\nstatic int expand_cu(RBinDwarfCompUnit *cu) {\n\tRBinDwarfDie *tmp;\n\n\tif (!cu || cu->capacity == 0 || cu->capacity != cu->count) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RBinDwarfDie *)realloc (cu->dies,\n\t\tcu->capacity * 2 * sizeof (RBinDwarfDie));\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset ((ut8 *)tmp + cu->capacity * sizeof (RBinDwarfDie),\n\t\t0, cu->capacity * sizeof (RBinDwarfDie));\n\tcu->dies = tmp;\n\tcu->capacity *= 2;\n\n\treturn 0;\n}\n\nstatic int init_abbrev_decl(RBinDwarfAbbrevDecl *ad) {\n\tif (!ad) {\n\t\treturn -EINVAL;\n\t}\n\tad->defs = calloc (sizeof (RBinDwarfAttrDef), ABBREV_DECL_CAP);\n\n\tif (!ad->defs) {\n\t\treturn -ENOMEM;\n\t}\n\n\tad->capacity = ABBREV_DECL_CAP;\n\tad->count = 0;\n\n\treturn 0;\n}\n\nstatic int expand_abbrev_decl(RBinDwarfAbbrevDecl *ad) {\n\tRBinDwarfAttrDef *tmp;\n\n\tif (!ad || !ad->capacity || ad->capacity != ad->count) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RBinDwarfAttrDef *)realloc (ad->defs,\n\t\tad->capacity * 2 * sizeof (RBinDwarfAttrDef));\n\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\n\t// Set the area in the buffer past the length to 0\n\tmemset ((ut8 *)tmp + ad->capacity * sizeof (RBinDwarfAttrDef),\n\t\t0, ad->capacity * sizeof (RBinDwarfAttrDef));\n\tad->defs = tmp;\n\tad->capacity *= 2;\n\n\treturn 0;\n}\n\nstatic int init_debug_abbrev(RBinDwarfDebugAbbrev *da) {\n\tif (!da) {\n\t\treturn -EINVAL;\n\t}\n\tda->decls = calloc (sizeof (RBinDwarfAbbrevDecl), DEBUG_ABBREV_CAP);\n\tif (!da->decls) {\n\t\treturn -ENOMEM;\n\t}\n\tda->capacity = DEBUG_ABBREV_CAP;\n\tda->count = 0;\n\n\treturn 0;\n}\n\nstatic int expand_debug_abbrev(RBinDwarfDebugAbbrev *da) {\n\tRBinDwarfAbbrevDecl *tmp;\n\n\tif (!da || da->capacity == 0 || da->capacity != da->count) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RBinDwarfAbbrevDecl *)realloc (da->decls,\n\t\tda->capacity * 2 * sizeof (RBinDwarfAbbrevDecl));\n\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\tmemset ((ut8 *)tmp + da->capacity * sizeof (RBinDwarfAbbrevDecl),\n\t\t0, da->capacity * sizeof (RBinDwarfAbbrevDecl));\n\n\tda->decls = tmp;\n\tda->capacity *= 2;\n\n\treturn 0;\n}\n\nstatic void print_abbrev_section(RBinDwarfDebugAbbrev *da, PrintfCallback print) {\n\tsize_t i, j;\n\tut64 attr_name, attr_form;\n\n\tif (!da) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < da->count; i++) {\n\t\tint declstag = da->decls[i].tag;\n\t\tprint (\"   %-4\"PFMT64d\" \", da->decls[i].code);\n\t\tif (declstag>=0 && declstag < DW_TAG_LAST) {\n\t\t\tprint (\"  %-25s \", dwarf_tag_name_encodings[declstag]);\n\t\t}\n\t\tprint (\"[%s]\", da->decls[i].has_children ?\n\t\t\t\t\"has children\" : \"no children\");\n\t\tprint (\" (0x%\"PFMT64x\")\\n\", da->decls[i].offset);\n\n\t\tif (da->decls[i].defs) {\n\t\t\tfor (j = 0; j < da->decls[i].count; j++) {\n\t\t\t\tattr_name = da->decls[i].defs[j].attr_name;\n\t\t\t\tattr_form = da->decls[i].defs[j].attr_form;\n\t\t\t\tif (is_printable_attr(attr_name) && is_printable_form(attr_form)) {\n\t\t\t\t\tprint (\"    %-30s %-30s\\n\",\n\t\t\t\t\t\t\tdwarf_attr_encodings[attr_name],\n\t\t\t\t\t\t\tdwarf_attr_form_encodings[attr_form]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nR_API void r_bin_dwarf_free_debug_abbrev(RBinDwarfDebugAbbrev *da) {\n\tsize_t i;\n\tif (!da) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < da->count; i++) {\n\t\tR_FREE (da->decls[i].defs);\n\t}\n\tR_FREE (da->decls);\n\tfree (da);\n}\n\nstatic void free_attr_value(RBinDwarfAttrValue *val) {\n\t// TODO adjust to new forms, now we're leaking\n\tif (!val) {\n\t\treturn;\n\t}\n\tswitch (val->attr_form) {\n\tcase DW_FORM_strp:\n\tcase DW_FORM_string:\n\t\tR_FREE (val->string.content);\n\t\tbreak;\n\tcase DW_FORM_exprloc:\n\tcase DW_FORM_block:\n\tcase DW_FORM_block1:\n\tcase DW_FORM_block2:\n\tcase DW_FORM_block4:\n\t\tR_FREE (val->block.data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t};\n}\n\nstatic void free_die(RBinDwarfDie *die) {\n\tsize_t i;\n\tif (!die) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < die->count; i++) {\n\t\tfree_attr_value (&die->attr_values[i]);\n\t}\n\tR_FREE (die->attr_values);\n}\n\nstatic void free_comp_unit(RBinDwarfCompUnit *cu) {\n\tsize_t i;\n\tif (!cu) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < cu->count; i++) {\n\t\tif (cu->dies) {\n\t\t\tfree_die (&cu->dies[i]);\n\t\t}\n\t}\n\tR_FREE (cu->dies);\n}\n\nR_API void r_bin_dwarf_free_debug_info(RBinDwarfDebugInfo *inf) {\n\tsize_t i;\n\tif (!inf) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < inf->count; i++) {\n\t\tfree_comp_unit (&inf->comp_units[i]);\n\t}\n\tht_up_free (inf->lookup_table);\n\tfree (inf->comp_units);\n\tfree(inf);\n}\n\nstatic void print_attr_value(const RBinDwarfAttrValue *val, PrintfCallback print) {\n\tsize_t i;\n\tr_return_if_fail(val);\n\n\tswitch (val->attr_form) {\n\tcase DW_FORM_block:\n\tcase DW_FORM_block1:\n\tcase DW_FORM_block2:\n\tcase DW_FORM_block4:\n\tcase DW_FORM_exprloc:\n\t\tprint (\"%\"PFMT64u\" byte block:\", val->block.length);\n\t\tfor (i = 0; i < val->block.length; i++) {\n\t\t\tprint (\" 0x%02x\", val->block.data[i]);\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_data1:\n\tcase DW_FORM_data2:\n\tcase DW_FORM_data4:\n\tcase DW_FORM_data8:\n\tcase DW_FORM_data16:\n\t\tprint (\"%\"PFMT64u\"\", val->uconstant);\n\t\tif (val->attr_name == DW_AT_language) {\n\t\t\tprint (\"   (%s)\", dwarf_langs[val->uconstant]);\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_string:\n\t\tif (val->string.content) {\n\t\t\tprint (\"%s\", val->string.content);\n\t\t} else {\n\t\t\tprint (\"No string found\");\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tprint (\"%u\", val->flag);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tprint (\"%\"PFMT64d\"\", val->sconstant);\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\tprint (\"%\"PFMT64u\"\", val->uconstant);\n\t\tbreak;\n\tcase DW_FORM_ref_addr:\n\tcase DW_FORM_ref1:\n\tcase DW_FORM_ref2:\n\tcase DW_FORM_ref4:\n\tcase DW_FORM_ref8:\n\tcase DW_FORM_ref_sig8:\n\tcase DW_FORM_ref_udata:\n\tcase DW_FORM_ref_sup4:\n\tcase DW_FORM_ref_sup8:\n\tcase DW_FORM_sec_offset:\n\t\tprint (\"<0x%\"PFMT64x\">\", val->reference);\n\t\tbreak;\n\tcase DW_FORM_flag_present:\n\t\tprint (\"1\");\n\t\tbreak;\n\tcase DW_FORM_strx:\n\tcase DW_FORM_strx1:\n\tcase DW_FORM_strx2:\n\tcase DW_FORM_strx3:\n\tcase DW_FORM_strx4:\n\tcase DW_FORM_line_ptr:\n\tcase DW_FORM_strp_sup:\n\tcase DW_FORM_strp:\n\t\tprint (\"(indirect string, offset: 0x%\"PFMT64x\"): %s\",\n\t\t\tval->string.offset, val->string.content);\n\t\tbreak;\n\tcase DW_FORM_addr:\n\tcase DW_FORM_addrx:\n\tcase DW_FORM_addrx1:\n\tcase DW_FORM_addrx2:\n\tcase DW_FORM_addrx3:\n\tcase DW_FORM_addrx4:\n\tcase DW_FORM_loclistx:\n\tcase DW_FORM_rnglistx:\n\t\tprint (\"0x%\"PFMT64x\"\", val->address);\n\t\tbreak;\n\tcase DW_FORM_implicit_const:\n\t\tprint (\"0x%\"PFMT64d\"\", val->uconstant);\n\t\tbreak;\n\tdefault:\n\t\tprint (\"Unknown attr value form %\"PFMT64d\"\\n\", val->attr_form);\n\t\tbreak;\n\t};\n}\n\nstatic void print_debug_info(const RBinDwarfDebugInfo *inf, PrintfCallback print) {\n\tsize_t i, j, k;\n\tRBinDwarfDie *dies;\n\tRBinDwarfAttrValue *values;\n\n\tr_return_if_fail(inf);\n\n\tfor (i = 0; i < inf->count; i++) {\n\t\tprint (\"\\n\");\n\t\tprint (\"  Compilation Unit @ offset 0x%\" PFMT64x \":\\n\", inf->comp_units[i].offset);\n\t\tprint (\"   Length:        0x%\" PFMT64x \"\\n\", inf->comp_units[i].hdr.length);\n\t\tprint (\"   Version:       %d\\n\", inf->comp_units[i].hdr.version);\n\t\tprint (\"   Abbrev Offset: 0x%\" PFMT64x \"\\n\", inf->comp_units[i].hdr.abbrev_offset);\n\t\tprint (\"   Pointer Size:  %d\\n\", inf->comp_units[i].hdr.address_size);\n\t\tif (is_printable_unit_type(inf->comp_units[i].hdr.unit_type)) {\n\t\t\tprint (\"   Unit Type:     %s\\n\", dwarf_unit_types[inf->comp_units[i].hdr.unit_type]);\n\t\t}\n\t\tprint (\"\\n\");\n\n\t\tdies = inf->comp_units[i].dies;\n\n\t\tfor (j = 0; j < inf->comp_units[i].count; j++) {\n\t\t\tprint (\"<0x%\"PFMT64x\">: Abbrev Number: %-4\" PFMT64u \" \", dies[j].offset,dies[j].abbrev_code);\n\n\t\t\tif (is_printable_tag (dies[j].tag)) {\n\t\t\t\tprint (\"(%s)\\n\", dwarf_tag_name_encodings[dies[j].tag]);\n\t\t\t} else {\n\t\t\t\tprint (\"(Unknown abbrev tag)\\n\");\n\t\t\t}\n\n\t\t\tif (!dies[j].abbrev_code) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvalues = dies[j].attr_values;\n\n\t\t\tfor (k = 0; k < dies[j].count; k++) {\n\t\t\t\tif (!values[k].attr_name) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (is_printable_attr (values[k].attr_name)) {\n\t\t\t\t\tprint (\"     %-25s : \", dwarf_attr_encodings[values[k].attr_name]);\n\t\t\t\t} else {\n\t\t\t\t\tprint (\"     AT_UNKWN [0x%-3\" PFMT64x \"]\\t : \", values[k].attr_name);\n\t\t\t\t}\n\t\t\t\tprint_attr_value (&values[k], print);\n\t\t\t\tprint (\"\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic const ut8 *fill_block_data(const ut8 *buf, const ut8 *buf_end, RBinDwarfBlock *block) {\n\tblock->data = calloc (sizeof (ut8), block->length);\n\tif (!block->data) {\n\t\treturn NULL;\n\t}\n\t/* Maybe unroll this as an optimization in future? */\n\tif (block->data) {\n\t\tsize_t j = 0;\n\t\tfor (j = 0; j < block->length; j++) {\n\t\t\tblock->data[j] = READ (buf, ut8);\n\t\t}\n\t}\n\treturn buf;\n}\n\n/**\n * This function is quite incomplete and requires lot of work\n * With parsing various new FORM values\n * @brief Parses attribute value based on its definition\n *        and stores it into `value`\n *\n * @param obuf\n * @param obuf_len Buffer max capacity\n * @param def Attribute definition\n * @param value Parsed value storage\n * @param hdr Current unit header\n * @param debug_str Ptr to string section start\n * @param debug_str_len Length of the string section\n * @return const ut8* Updated buffer\n */\nstatic const ut8 *parse_attr_value(const ut8 *obuf, int obuf_len,\n\t\tRBinDwarfAttrDef *def, RBinDwarfAttrValue *value,\n\t\tconst RBinDwarfCompUnitHdr *hdr,\n\t\tconst ut8 *debug_str, size_t debug_str_len) {\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + obuf_len;\n\tsize_t j;\n\n\tr_return_val_if_fail(def && value && hdr && obuf && obuf_len >= 1, NULL);\n\n\tvalue->attr_form = def->attr_form;\n\tvalue->attr_name = def->attr_name;\n\tvalue->block.data = NULL;\n\tvalue->string.content = NULL;\n\tvalue->string.offset = 0;\n\n\t// http://www.dwarfstd.org/doc/DWARF4.pdf#page=161&zoom=100,0,560\n\tswitch (def->attr_form) {\n\tcase DW_FORM_addr:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tswitch (hdr->address_size) {\n\t\tcase 1:\n\t\t\tvalue->address = READ8 (buf);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvalue->address = READ16 (buf);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tvalue->address = READ32 (buf);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalue->address = READ64 (buf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"DWARF: Unexpected pointer size: %u\\n\", (unsigned)hdr->address_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_data1:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_data2:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_data4:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_data8:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_data16: // TODO Fix this, right now I just read the data, but I need to make storage for it\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64 (buf);\n\t\tvalue->uconstant = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = r_leb128 (buf, buf_end - buf, &value->sconstant);\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->uconstant, NULL);\n\t\tbreak;\n\tcase DW_FORM_string:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.content = *buf ? strdup ((const char *)buf) : NULL;\n\t\tbuf += (strlen ((const char *)buf) + 1);\n\t\tbreak;\n\tcase DW_FORM_block1:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ8 (buf);\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block2:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ16 (buf);\n\t\tif (value->block.length > 0) {\n\t\t\tvalue->block.data = calloc (sizeof (ut8), value->block.length);\n\t\t\tif (!value->block.data) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block4:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ32 (buf);\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block: // variable length ULEB128\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = READ (buf, ut8);\n\t\tbreak;\n\t// offset in .debug_str\n\tcase DW_FORM_strp:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset(hdr->is_64bit, &buf, buf_end);\n\t\tif (debug_str && value->string.offset < debug_str_len) {\n\t\t\tvalue->string.content =\n\t\t\t\tstrdup ((const char *)(debug_str + value->string.offset));\n\t\t} else {\n\t\t\tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t}\n\t\tbreak;\n\t// offset in .debug_info\n\tcase DW_FORM_ref_addr:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset(hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t// This type of reference is an offset from the first byte of the compilation\n\t// header for the compilation unit containing the reference\n\tcase DW_FORM_ref1:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref2:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_udata:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\t// uleb128 is enough to fit into ut64?\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->reference, NULL);\n\t\tvalue->reference += hdr->unit_offset;\n\t\tbreak;\n\t// offset in a section other than .debug_info or .debug_str\n\tcase DW_FORM_sec_offset:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset(hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\tcase DW_FORM_exprloc:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\t// this means that the flag is present, nothing is read\n\tcase DW_FORM_flag_present:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = true;\n\t\tbreak;\n\tcase DW_FORM_ref_sig8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// offset into .debug_line_str section, can't parse the section now, so we just skip\n\tcase DW_FORM_strx:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\t// value->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdup ((const char *)(debug_str + value->string.offset));\n\t\t// } else {\n\t\t// \tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t// }\n\t\tbreak;\n\tcase DW_FORM_strx1:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx2:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx3: // TODO Add 3 byte int read\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_strx4:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_implicit_const:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = def->special;\n\t\tbreak;\n\t/*  addrx* forms : The index is relative to the value of the\n\t\tDW_AT_addr_base attribute of the associated compilation unit.\n\t    index into an array of addresses in the .debug_addr section.*/\n\tcase DW_FORM_addrx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tcase DW_FORM_addrx1:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx2:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx3:\n\t\t// I need to add 3byte endianess free read here TODO\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_addrx4:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_line_ptr: // offset in a section .debug_line_str\n\tcase DW_FORM_strp_sup: // offset in a section .debug_line_str\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdupsts\n\t\tbreak;\n\t// offset in the supplementary object file\n\tcase DW_FORM_ref_sup4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_sup8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// An index into the .debug_loc\n\tcase DW_FORM_loclistx:\n\t\tvalue->kind = DW_AT_KIND_LOCLISTPTR;\n\t\tvalue->reference = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t // An index into the .debug_rnglists\n\tcase DW_FORM_rnglistx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Unknown DW_FORM 0x%02\" PFMT64x \"\\n\", def->attr_form);\n\t\tvalue->uconstant = 0;\n\t\treturn NULL;\n\t}\n\treturn buf;\n}\n\n/**\n * @brief\n *\n * @param buf Start of the DIE data\n * @param buf_end\n * @param abbrev Abbreviation of the DIE\n * @param hdr Unit header\n * @param die DIE to store the parsed info into\n * @param debug_str Ptr to string section start\n * @param debug_str_len Length of the string section\n * @param sdb\n * @return const ut8* Updated buffer\n */\nstatic const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RBinDwarfAbbrevDecl *abbrev,\n\t\tRBinDwarfCompUnitHdr *hdr, RBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, Sdb *sdb) {\n\tsize_t i;\n\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\tmemset (&die->attr_values[i], 0, sizeof (die->attr_values[i]));\n\n\t\tbuf = parse_attr_value (buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len);\n\n\t\tRBinDwarfAttrValue *attribute = &die->attr_values[i];\n\n\t\tbool is_valid_string_form = (attribute->attr_form == DW_FORM_strp ||\n\t\t\tattribute->attr_form == DW_FORM_string) &&\n\t\t\tattribute->string.content;\n\t\t// TODO  does this have a purpose anymore?\n\t\t// Or atleast it needs to rework becase there will be\n\t\t// more comp units -> more comp dirs and only the last one will be kept\n\t\tif (attribute->attr_name == DW_AT_comp_dir && is_valid_string_form) {\n\t\t\tconst char *name = attribute->string.content;\n\t\t\tsdb_set (sdb, \"DW_AT_comp_dir\", name, 0);\n\t\t}\n\t\tdie->count++;\n\t}\n\n\treturn buf;\n}\n\n/**\n * @brief Reads throught comp_unit buffer and parses all its DIEntries\n *\n * @param sdb\n * @param buf_start Start of the compilation unit data\n * @param unit Unit to store the newly parsed information\n * @param abbrevs Parsed abbrev section info of *all* abbreviations\n * @param first_abbr_idx index for first abbrev of the current comp unit in abbrev array\n * @param debug_str Ptr to string section start\n * @param debug_str_len Length of the string section\n *\n * @return const ut8* Update buffer\n */\nstatic const ut8 *parse_comp_unit(RBinDwarfDebugInfo *info, Sdb *sdb, const ut8 *buf_start,\n\t\tRBinDwarfCompUnit *unit, const RBinDwarfDebugAbbrev *abbrevs,\n\t\tsize_t first_abbr_idx, const ut8 *debug_str, size_t debug_str_len) {\n\n\tconst ut8 *buf = buf_start;\n\tconst ut8 *buf_end = buf_start + unit->hdr.length - unit->hdr.header_size;\n\n\twhile (buf && buf < buf_end && buf >= buf_start) {\n\t\tif (unit->count && unit->capacity == unit->count) {\n\t\t\texpand_cu (unit);\n\t\t}\n\t\tRBinDwarfDie *die = &unit->dies[unit->count];\n\t\t// add header size to the offset;\n\t\tdie->offset = buf - buf_start + unit->hdr.header_size + unit->offset;\n\t\tdie->offset += unit->hdr.is_64bit ? 12 : 4;\n\n\t\t// DIE starts with ULEB128 with the abbreviation code\n\t\tut64 abbr_code;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &abbr_code, NULL);\n\n\t\tif (abbr_code > abbrevs->count || !buf) { // something invalid\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (buf >= buf_end) {\n\t\t\tunit->count++; // we wanna store this entry too, usually the last one is null_entry\n\t\t\treturn buf; // return the buffer to parse next compilation units\n\t\t}\n\t\t// there can be \"null\" entries that have abbr_code == 0\n\t\tif (!abbr_code) {\n\t\t\tunit->count++;\n\t\t\tcontinue;\n\t\t}\n\t\tut64 abbr_idx = first_abbr_idx + abbr_code;\n\n\t\tif (abbrevs->count < abbr_idx) {\n\t\t\treturn NULL;\n\t\t}\n\t\tRBinDwarfAbbrevDecl *abbrev = &abbrevs->decls[abbr_idx - 1];\n\n\t\tif (init_die (die, abbr_code, abbrev->count)) {\n\t\t\treturn NULL; // error\n\t\t}\n\t\tdie->tag = abbrev->tag;\n\t\tdie->has_children = abbrev->has_children;\n\n\t\tbuf = parse_die (buf, buf_end, abbrev, &unit->hdr, die, debug_str, debug_str_len, sdb);\n\t\tif (!buf) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tunit->count++;\n\t}\n\treturn buf;\n}\n\n/**\n * @brief Reads all information about compilation unit header\n *\n * @param buf Start of the buffer\n * @param buf_end Upper bound of the buffer\n * @param unit Unit to read information into\n * @return ut8* Advanced position in a buffer\n */\nstatic const ut8 *info_comp_unit_read_hdr(const ut8 *buf, const ut8 *buf_end, RBinDwarfCompUnitHdr *hdr) {\n\t// 32-bit vs 64-bit dwarf formats\n\t// http://www.dwarfstd.org/doc/Dwarf3.pdf section 7.4\n\thdr->length = READ32 (buf);\n\tif (hdr->length == (ut32)DWARF_INIT_LEN_64) { // then its 64bit\n\t\thdr->length = READ64 (buf);\n\t\thdr->is_64bit = true;\n\t}\n\tconst ut8 *tmp = buf; // to calculate header size\n\thdr->version = READ16 (buf);\n\tif (hdr->version == 5) {\n\t\thdr->unit_type = READ8 (buf);\n\t\thdr->address_size = READ8 (buf);\n\t\thdr->abbrev_offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\n\t\tif (hdr->unit_type == DW_UT_skeleton || hdr->unit_type == DW_UT_split_compile) {\n\t\t\thdr->dwo_id = READ8 (buf);\n\t\t} else if (hdr->unit_type == DW_UT_type || hdr->unit_type == DW_UT_split_type) {\n\t\t\thdr->type_sig = READ64 (buf);\n\t\t\thdr->type_offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t}\n\t} else {\n\t\thdr->abbrev_offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\thdr->address_size = READ8 (buf);\n\t}\n\thdr->header_size = buf - tmp; // header size excluding length field\n\treturn buf;\n}\nstatic int expand_info(RBinDwarfDebugInfo *info) {\n\tr_return_val_if_fail (info && info->capacity == info->count, -1);\n\n\tRBinDwarfCompUnit *tmp = realloc (info->comp_units,\n\t\tinfo->capacity * 2 * sizeof (RBinDwarfCompUnit));\n\tif (!tmp) {\n\t\treturn -1;\n\t}\n\n\tmemset ((ut8 *)tmp + info->capacity * sizeof (RBinDwarfCompUnit),\n\t\t0, info->capacity * sizeof (RBinDwarfCompUnit));\n\n\tinfo->comp_units = tmp;\n\tinfo->capacity *= 2;\n\n\treturn 0;\n}\n\n/**\n * @brief Parses whole .debug_info section\n *\n * @param sdb Sdb to store line related information into\n * @param da Parsed Abbreviations\n * @param obuf .debug_info section buffer start\n * @param len length of the section buffer\n * @param debug_str start of the .debug_str section\n * @param debug_str_len length of the debug_str section\n * @param mode\n * @return R_API* parse_info_raw Parsed information\n */\nstatic RBinDwarfDebugInfo *parse_info_raw(Sdb *sdb, RBinDwarfDebugAbbrev *da,\n\t\tconst ut8 *obuf, size_t len,\n\t\tconst ut8 *debug_str, size_t debug_str_len) {\n\n\tr_return_val_if_fail (da && sdb && obuf, false);\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + len;\n\n\tRBinDwarfDebugInfo *info = R_NEW0 (RBinDwarfDebugInfo);\n\tif (!info) {\n\t\treturn NULL;\n\t}\n\tif (init_debug_info (info) < 0) {\n\t\tgoto cleanup;\n\t}\n\tint unit_idx = 0;\n\n\twhile (buf < buf_end) {\n\t\tif (info->count >= info->capacity) {\n\t\t\tif (expand_info (info)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tRBinDwarfCompUnit *unit = &info->comp_units[unit_idx];\n\t\tif (init_comp_unit (unit) < 0) {\n\t\t\tunit_idx--;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tinfo->count++;\n\n\t\tunit->offset = buf - obuf;\n\t\t// small redundancy, because it was easiest solution at a time\n\t\tunit->hdr.unit_offset = buf - obuf;\n\n\t\tbuf = info_comp_unit_read_hdr (buf, buf_end, &unit->hdr);\n\n\t\tif (unit->hdr.length > len) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (da->decls->count >= da->capacity) {\n\t\t\teprintf (\"Warning: malformed dwarf have not enough buckets for decls.\\n\");\n\t\t}\n\t\tr_warn_if_fail (da->count <= da->capacity);\n\n\t\t// find abbrev start for current comp unit\n\t\t// we could also do naive, ((char *)da->decls) + abbrev_offset,\n\t\t// but this is more bulletproof to invalid DWARF\n\t\tRBinDwarfAbbrevDecl key = { .offset = unit->hdr.abbrev_offset };\n\t\tRBinDwarfAbbrevDecl *abbrev_start = bsearch (&key, da->decls, da->count, sizeof (key), abbrev_cmp);\n\t\tif (!abbrev_start) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\t// They point to the same array object, so should be def. behaviour\n\t\tsize_t first_abbr_idx = abbrev_start - da->decls;\n\n\t\tbuf = parse_comp_unit (info, sdb, buf, unit, da, first_abbr_idx, debug_str, debug_str_len);\n\n\t\tif (!buf) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tunit_idx++;\n\t}\n\n\treturn info;\n\ncleanup:\n\tr_bin_dwarf_free_debug_info (info);\n\treturn NULL;\n}\n\nstatic RBinDwarfDebugAbbrev *parse_abbrev_raw(const ut8 *obuf, size_t len) {\n\tconst ut8 *buf = obuf, *buf_end = obuf + len;\n\tut64 tmp, attr_code, attr_form, offset;\n\tst64 special;\n\tut8 has_children;\n\tRBinDwarfAbbrevDecl *tmpdecl;\n\n\t// XXX - Set a suitable value here.\n\tif (!obuf || len < 3) {\n\t\treturn NULL;\n\t}\n\tRBinDwarfDebugAbbrev *da = R_NEW0 (RBinDwarfDebugAbbrev);\n\n\tinit_debug_abbrev (da);\n\n\twhile (buf && buf+1 < buf_end) {\n\t\toffset = buf - obuf;\n\t\tbuf = r_uleb128 (buf, (size_t)(buf_end-buf), &tmp, NULL);\n\t\tif (!buf || !tmp || buf >= buf_end) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (da->count == da->capacity) {\n\t\t\texpand_debug_abbrev(da);\n\t\t}\n\t\ttmpdecl = &da->decls[da->count];\n\t\tinit_abbrev_decl (tmpdecl);\n\n\t\ttmpdecl->code = tmp;\n\t\tbuf = r_uleb128 (buf, (size_t)(buf_end-buf), &tmp, NULL);\n\t\ttmpdecl->tag = tmp;\n\n\t\ttmpdecl->offset = offset;\n\t\tif (buf >= buf_end) {\n\t\t\tbreak;\n\t\t}\n\t\thas_children = READ (buf, ut8);\n\t\ttmpdecl->has_children = has_children;\n\t\tdo {\n\t\t\tif (tmpdecl->count == tmpdecl->capacity) {\n\t\t\t\texpand_abbrev_decl (tmpdecl);\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, (size_t)(buf_end - buf), &attr_code, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, (size_t)(buf_end - buf), &attr_form, NULL);\n\t\t\t// http://www.dwarfstd.org/doc/DWARF5.pdf#page=225\n\t\t\tif (attr_form == DW_FORM_implicit_const) {\n\t\t\t\tbuf = r_leb128 (buf, (size_t)(buf_end - buf), &special);\n\t\t\t\ttmpdecl->defs[tmpdecl->count].special = special;\n\t\t\t}\n\t\t\ttmpdecl->defs[tmpdecl->count].attr_name = attr_code;\n\t\t\ttmpdecl->defs[tmpdecl->count].attr_form = attr_form;\n\t\t\ttmpdecl->count++;\n\t\t} while (attr_code && attr_form);\n\n\t\tda->count++;\n\t}\n\treturn da;\n}\n\nRBinSection *getsection(RBin *a, const char *sn) {\n\tRListIter *iter;\n\tRBinSection *section = NULL;\n\tRBinFile *binfile = a ? a->cur: NULL;\n\tRBinObject *o = binfile ? binfile->o : NULL;\n\n\tif ( o && o->sections) {\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tif (strstr (section->name, sn)) {\n\t\t\t\treturn section;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic ut8 *get_section_bytes(RBin *bin, const char *sect_name, size_t *len) {\n\tRBinSection *section = getsection (bin, sect_name);\n\tRBinFile *binfile = bin ? bin->cur: NULL;\n\tif (!section || !binfile) {\n\t\treturn NULL;\n\t}\n\tif (section->size > binfile->size) {\n\t\treturn NULL;\n\t}\n\t*len = section->size;\n\tut8 *buf = calloc (1,*len);\n\tr_buf_read_at (binfile->buf, section->paddr, buf, *len);\n\treturn buf;\n}\n\n/**\n * @brief Parses .debug_info section\n *\n * @param da Parsed abbreviations\n * @param bin\n * @param mode R_MODE_PRINT to print\n * @return RBinDwarfDebugInfo* Parsed information, NULL if error\n */\nR_API RBinDwarfDebugInfo *r_bin_dwarf_parse_info(RBinDwarfDebugAbbrev *da, RBin *bin, int mode) {\n\tRBinDwarfDebugInfo *info = NULL;\n\tRBinSection *debug_str;\n\tRBinSection *section = getsection (bin, \"debug_info\");\n\tRBinFile *binfile = bin ? bin->cur : NULL;\n\n\tut64 debug_str_len = 0;\n\tut8 *debug_str_buf = NULL;\n\n\tif (binfile && section) {\n\t\tdebug_str = getsection (bin, \"debug_str\");\n\t\tif (debug_str) {\n\t\t\tdebug_str_len = debug_str->size;\n\t\t\tdebug_str_buf = calloc (1, debug_str_len + 1);\n\t\t\tif (!debug_str_buf) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tst64 ret = r_buf_read_at (binfile->buf, debug_str->paddr,\n\t\t\t\tdebug_str_buf, debug_str_len);\n\t\t\tif (!ret) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tut64 len = section->size;\n\t\t// what is this checking for?\n\t\tif (len > (UT32_MAX >> 1) || len < 1) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tut8 *buf = calloc (1, len);\n\t\tif (!buf) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (!r_buf_read_at (binfile->buf, section->paddr, buf, len)) {\n\t\t\tfree (buf);\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* set the endianity global [HOTFIX] */\n\t\tbig_end = r_bin_is_big_endian (bin);\n\t\tinfo = parse_info_raw (binfile->sdb_addrinfo, da, buf, len,\n\t\t\tdebug_str_buf, debug_str_len);\n\n\t\tif (mode == R_MODE_PRINT && info) {\n\t\t\tprint_debug_info (info, bin->cb_printf);\n\t\t}\n\t\t// build hashtable after whole parsing because of possible relocations\n\t\tif (info) {\n\t\t\tsize_t i, j;\n\t\t\tfor (i = 0; i < info->count; i++) {\n\t\t\t\tRBinDwarfCompUnit *unit = &info->comp_units[i];\n\t\t\t\tfor (j = 0; j < unit->count; j++) {\n\t\t\t\t\tRBinDwarfDie *die = &unit->dies[j];\n\t\t\t\t\tht_up_insert (info->lookup_table, die->offset, die); // optimization for further processing}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree (debug_str_buf);\n\t\tfree (buf);\n\t\treturn info;\n\t}\ncleanup:\n\tfree (debug_str_buf);\n\treturn NULL;\n}\n\nstatic RBinDwarfRow *row_new(ut64 addr, const char *file, int line, int col) {\n\tRBinDwarfRow *row = R_NEW0 (RBinDwarfRow);\n\tif (!row) {\n\t\treturn NULL;\n\t}\n\trow->file = strdup (file);\n\trow->address = addr;\n\trow->line = line;\n\trow->column = 0;\n\treturn row;\n}\n\nstatic void row_free(void *p) {\n\tRBinDwarfRow *row = (RBinDwarfRow*)p;\n\tfree (row->file);\n\tfree (row);\n}\n\nR_API RList *r_bin_dwarf_parse_line(RBin *bin, int mode) {\n\tut8 *buf;\n\tRList *list = NULL;\n\tint len, ret;\n\tRBinSection *section = getsection (bin, \"debug_line\");\n\tRBinFile *binfile = bin ? bin->cur: NULL;\n\tif (binfile && section) {\n\t\tlen = section->size;\n\t\tif (len < 1) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = calloc (1, len + 1);\n\t\tif (!buf) {\n\t\t\treturn NULL;\n\t\t}\n\t\tret = r_buf_read_at (binfile->buf, section->paddr, buf, len);\n\t\tif (ret != len) {\n\t\t\tfree (buf);\n\t\t\treturn NULL;\n\t\t}\n\t\tlist = r_list_newf (row_free);\n\t\tif (!list) {\n\t\t\tfree (buf);\n\t\t\treturn NULL;\n\t\t}\n\t\t/* set the endianity global [HOTFIX] */\n\t\tbig_end = r_bin_is_big_endian (bin);\n\t\t// Actually parse the section\n\t\tparse_line_raw (bin, buf, len, mode);\n\t\t// k bin/cur/addrinfo/*\n\t\tSdbListIter *iter;\n\t\tSdbKv *kv;\n\t\tSdbList *ls = sdb_foreach_list (binfile->sdb_addrinfo, false);\n\t\t// Use the parsed information from _raw and transform it to more useful format\n\t\tls_foreach (ls, iter, kv) {\n\t\t\tif (!strncmp (sdbkv_key (kv), \"0x\", 2)) {\n\t\t\t\tut64 addr;\n\t\t\t\tRBinDwarfRow *row;\n\t\t\t\tint line;\n\t\t\t\tchar *file = strdup (sdbkv_value (kv));\n\t\t\t\tif (!file) {\n\t\t\t\t\tfree (buf);\n\t\t\t\t\tls_free (ls);\n\t\t\t\t\tr_list_free (list);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tchar *tok = strchr (file, '|');\n\t\t\t\tif (tok) {\n\t\t\t\t\t*tok++ = 0;\n\t\t\t\t\tline = atoi (tok);\n\t\t\t\t\taddr = r_num_math (NULL, sdbkv_key (kv));\n\t\t\t\t\trow = row_new (addr, file, line, 0);\n\t\t\t\t\tr_list_append (list, row);\n\t\t\t\t}\n\t\t\t\tfree (file);\n\t\t\t}\n\t\t}\n\t\tls_free (ls);\n\t\tfree (buf);\n\t}\n\treturn list;\n}\n\nR_API RList *r_bin_dwarf_parse_aranges(RBin *bin, int mode) {\n\tut8 *buf;\n\tint ret;\n\tsize_t len;\n\tRBinSection *section = getsection (bin, \"debug_aranges\");\n\tRBinFile *binfile = bin ? bin->cur: NULL;\n\n\tif (binfile && section) {\n\t\tlen = section->size;\n\t\tif (len < 1 || len > ST32_MAX) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = calloc (1, len);\n\t\tret = r_buf_read_at (binfile->buf, section->paddr, buf, len);\n\t\tif (!ret) {\n\t\t\tfree (buf);\n\t\t\treturn NULL;\n\t\t}\n\t\t/* set the endianity global [HOTFIX] */\n\t\tbig_end = r_bin_is_big_endian (bin);\n\t\tparse_aranges_raw (buf, len, mode, bin->cb_printf);\n\n\t\tfree (buf);\n\t}\n\treturn NULL;\n}\n\nR_API RBinDwarfDebugAbbrev *r_bin_dwarf_parse_abbrev(RBin *bin, int mode) {\n\tsize_t len = 0;\n\tut8 *buf = get_section_bytes (bin, \"debug_abbrev\", &len);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tRBinDwarfDebugAbbrev *abbrevs = parse_abbrev_raw (buf, len);\n\n\tif (mode == R_MODE_PRINT && abbrevs) {\n\t\tprint_abbrev_section (abbrevs, bin->cb_printf);\n\t}\n\tfree (buf);\n\treturn abbrevs;\n}\n\nstatic inline ut64 get_max_offset(size_t addr_size) {\n\tswitch (addr_size) {\n\t\tcase 2:\n\t\treturn UT16_MAX;\n\t\tcase 4:\n\t\treturn UT32_MAX;\n\t\tcase 8:\n\t\treturn UT64_MAX;\n\t}\n\treturn 0;\n}\n\nstatic inline RBinDwarfLocList *create_loc_list(ut64 offset) {\n\tRBinDwarfLocList *list = R_NEW0 (RBinDwarfLocList);\n\tif (list) {\n\t\tlist->list = r_list_new ();\n\t\tlist->offset = offset;\n\t}\n\treturn list;\n}\n\nstatic inline RBinDwarfLocRange *create_loc_range(ut64 start, ut64 end, RBinDwarfBlock *block) {\n\tRBinDwarfLocRange *range = R_NEW0 (RBinDwarfLocRange);\n\tif (range) {\n\t\trange->start = start;\n\t\trange->end = end;\n\t\trange->expression = block;\n\t}\n\treturn range;\n}\n\nstatic void free_loc_table_list(RBinDwarfLocList *loc_list) {\n\tRListIter *iter;\n\tRBinDwarfLocRange *range;\n\tr_list_foreach (loc_list->list, iter, range) {\n\t\tfree (range->expression->data);\n\t\tfree (range->expression);\n\t\tfree (range);\n\t}\n\tr_list_free (loc_list->list);\n\tfree (loc_list);\n}\n\nstatic HtUP *parse_loc_raw(HtUP/*<offset, List *<LocListEntry>*/ *loc_table, const ut8 *buf, size_t len, size_t addr_size) {\n\t/* GNU has their own extensions GNU locviews that we can't parse */\n\tconst ut8 *const buf_start = buf;\n\tconst ut8 *buf_end = buf + len;\n\t/* for recognizing Base address entry */\n\tut64 max_offset = get_max_offset (addr_size);\n\n\tut64 address_base = 0; /* remember base of the loclist */\n\tut64 list_offset = 0;\n\n\tRBinDwarfLocList *loc_list = NULL;\n\tRBinDwarfLocRange *range = NULL;\n\twhile (buf && buf < buf_end) {\n\t\tut64 start_addr = dwarf_read_address (addr_size, &buf, buf_end);\n\t\tut64 end_addr = dwarf_read_address (addr_size, &buf, buf_end);\n\n\t\tif (start_addr == 0 && end_addr == 0) { /* end of list entry: 0, 0 */\n\t\t\tif (loc_list) {\n\t\t\t\tht_up_insert (loc_table, loc_list->offset, loc_list);\n\t\t\t\tlist_offset = buf - buf_start;\n\t\t\t\tloc_list = NULL;\n\t\t\t}\n\t\t\taddress_base = 0;\n\t\t\tcontinue;\n\t\t} else if (start_addr == max_offset && end_addr != max_offset) {\n\t\t\t/* base address, DWARF2 doesn't have this type of entry, these entries shouldn't\n\t\t\t   be in the list, they are just informational entries for further parsing (address_base) */\n\t\t\taddress_base = end_addr;\n\t\t} else { /* location list entry: */\n\t\t\tif (!loc_list) {\n\t\t\t\tloc_list = create_loc_list (list_offset);\n\t\t\t}\n\t\t\t/* TODO in future parse expressions to better structure in dwarf.c and not in dwarf_process.c */\n\t\t\tRBinDwarfBlock *block = R_NEW0 (RBinDwarfBlock);\n\t\t\tblock->length = READ16 (buf);\n\t\t\tbuf = fill_block_data (buf, buf_end, block);\n\t\t\trange = create_loc_range (start_addr + address_base, end_addr + address_base, block);\n\t\t\tr_list_append (loc_list->list, range);\n\t\t\trange = NULL;\n\t\t}\n\t}\n\t/* if for some reason end of list is missing, then loc_list would leak */\n\tif (loc_list) {\n\t\tfree_loc_table_list (loc_list);\n\t}\n\treturn loc_table;\n}\n\n/**\n * @brief Parses out the .debug_loc section into a table that maps each list as\n *        offset of a list -> LocationList\n *\n * @param bin\n * @param addr_size machine address size used in executable (necessary for parsing)\n * @return R_API*\n */\nR_API HtUP/*<offset, RBinDwarfLocList*/ *r_bin_dwarf_parse_loc(RBin *bin, int addr_size) {\n\tr_return_val_if_fail  (bin, NULL);\n\t/* The standarparse_loc_raw_frame, not sure why is that */\n\tsize_t len = 0;\n\tut8 *buf = get_section_bytes (bin, \"debug_loc\", &len);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\t/* set the endianity global [HOTFIX] */\n\tbig_end = r_bin_is_big_endian (bin);\n\tHtUP /*<offset, RBinDwarfLocList*/ *loc_table = ht_up_new0 ();\n\tif (!loc_table) {\n\t\tfree (buf);\n\t\treturn NULL;\n\t}\n\tloc_table = parse_loc_raw (loc_table, buf, len, addr_size);\n\tfree (buf);\n\treturn loc_table;\n}\n\nstatic int offset_comp(const void *a, const void *b) {\n\tconst RBinDwarfLocList *f = a;\n\tconst RBinDwarfLocList *s = b;\n\tut64 first = f->offset;\n\tut64 second = s->offset;\n\tif (first < second) {\n\t\treturn -1;\n\t}\n\tif (first > second) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic bool sort_loclists(void *user, const ut64 key, const void *value) {\n\tRBinDwarfLocList *loc_list = (RBinDwarfLocList *)value;\n\tRList *sort_list = user;\n\tr_list_add_sorted (sort_list, loc_list, offset_comp);\n\treturn true;\n}\n\nR_API void r_bin_dwarf_print_loc(HtUP /*<offset, RBinDwarfLocList*/ *loc_table, int addr_size, PrintfCallback print) {\n\tr_return_if_fail (loc_table && print);\n\tprint (\"\\nContents of the .debug_loc section:\\n\");\n\tRList /*<RBinDwarfLocList *>*/ *sort_list = r_list_new ();\n\t/* sort the table contents by offset and print sorted\n\t   a bit ugly, but I wanted to decouple the parsing and printing */\n\tht_up_foreach (loc_table, sort_loclists, sort_list);\n\tRListIter *i;\n\tRBinDwarfLocList *loc_list;\n\tr_list_foreach (sort_list, i, loc_list) {\n\t\tRListIter *j;\n\t\tRBinDwarfLocRange *range;\n\t\tut64 base_offset = loc_list->offset;\n\t\tr_list_foreach (loc_list->list, j, range) {\n\t\t\tprint (\"0x%\" PFMT64x \" 0x%\" PFMT64x \" 0x%\" PFMT64x \"\\n\", base_offset, range->start, range->end);\n\t\t\tbase_offset += addr_size * 2;\n\t\t\tif (range->expression) {\n\t\t\t\tbase_offset += 2 + range->expression->length; /* 2 bytes for expr length */\n\t\t\t}\n\t\t}\n\t\tprint (\"0x%\" PFMT64x \" <End of list>\\n\", base_offset);\n\t}\n\tprint (\"\\n\");\n\tr_list_free (sort_list);\n}\n\nstatic void free_loc_table_entry(HtUPKv *kv) {\n\tif (kv) {\n\t\tfree_loc_table_list (kv->value);\n\t}\n}\n\nR_API void r_bin_dwarf_free_loc(HtUP /*<offset, RBinDwarfLocList*>*/ *loc_table) {\n\tr_return_if_fail (loc_table);\n\tloc_table->opt.freefn = free_loc_table_entry;\n\tht_up_free (loc_table);\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2012-2021 - houndthe */\n\n#include \"base_types.h\"\n#include <sdb.h>\n#include <r_anal.h>\n#include <r_bin_dwarf.h>\n#include <string.h>\n\ntypedef struct dwarf_parse_context_t {\n\tconst RAnal *anal;\n\tconst RBinDwarfDie *all_dies;\n\tconst ut64 count;\n\tSdb *sdb;\n\tHtUP/*<ut64 offset, DwarfDie *die>*/ *die_map;\n\tHtUP/*<offset, RBinDwarfLocList*>*/  *locations;\n\tconst char *lang; // for demangling\n} Context;\n\ntypedef struct dwarf_function_t {\n\tut64 addr;\n\tconst char *name;\n\tconst char *signature;\n\tbool is_external;\n\tbool is_method;\n\tbool is_virtual;\n\tbool is_trampoline; // intermediary in making call to another func\n\tut8 access; // public = 1, protected = 2, private = 3, if not set assume private\n\tut64 vtable_addr; // location description\n\tut64 call_conv; // normal || program || nocall\n} Function;\n\ntypedef enum dwarf_location_kind {\n\tLOCATION_UNKNOWN = 0,\n\tLOCATION_GLOBAL = 1,\n\tLOCATION_BP = 2,\n\tLOCATION_SP = 3,\n\tLOCATION_REGISTER = 4,\n} VariableLocationKind;\ntypedef struct dwarf_var_location_t {\n\tVariableLocationKind kind;\n\tut64 address;\n\tut64 reg_num;\n\tst64 offset;\n\tconst char *reg_name; /* string literal */\n} VariableLocation;\n\ntypedef struct dwarf_variable_t {\n\tVariableLocation *location;\n\tchar *name;\n\tchar *type;\n} Variable;\n\nstatic void variable_free(Variable *var) {\n\tfree (var->name);\n\tfree (var->location);\n\tfree (var->type);\n\tfree (var);\n}\n\n/* return -1 if attr isn't found */\nstatic inline st32 find_attr_idx(const RBinDwarfDie *die, st32 attr_name) {\n\tst32 i;\n\tr_return_val_if_fail (die, -1);\n\tfor (i = 0; i < die->count; i++) {\n\t\tif (die->attr_values[i].attr_name == attr_name) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/* return NULL if attr isn't found */\nstatic RBinDwarfAttrValue *find_attr(const RBinDwarfDie *die, st32 attr_name) {\n\tst32 i;\n\tr_return_val_if_fail (die, NULL);\n\tfor (i = 0; i < die->count; i++) {\n\t\tif (die->attr_values[i].attr_name == attr_name) {\n\t\t\treturn &die->attr_values[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/**\n * @brief Pasted from r_strbuf_*\n *        Prepends string before a last occurence of character c\n * \t      Used to replicate proper C declaration for function pointers\n * @param sb\n * @param s\n * @param c\n */\nstatic bool strbuf_rev_prepend_char(RStrBuf *sb, const char *s, int c) {\n\tr_return_val_if_fail (sb && s, false);\n\tsize_t l = strlen (s);\n\t// fast path if no chars to append\n\tif (l == 0) {\n\t\treturn true;\n\t}\n\tsize_t newlen = l + sb->len;\n\tchar *ns = malloc (newlen + 1);\n\tbool ret = false;\n\tchar *sb_str = sb->ptr ? sb->ptr : sb->buf;\n\tchar *pivot = strrchr (sb_str, c);\n\tif (!pivot) {\n\t\tfree (ns);\n\t\treturn false;\n\t}\n\tsize_t idx = pivot - sb_str;\n\tif (ns) {\n\t\tmemcpy (ns, sb_str, idx);\n\t\tmemcpy (ns + idx, s, l);\n\t\tmemcpy (ns + idx + l, sb_str + idx, sb->len - idx);\n\t\tns[newlen] = 0;\n\t\tret = r_strbuf_set (sb, ns) != NULL;\n\t\tfree (ns);\n\t}\n\treturn ret;\n}\n/**\n * @brief Pasted from r_strbuf_*\n * \t      Appends string after a first occurence of character c\n * \t      Used to replicate proper C declaration for function pointers\n * @param sb\n * @param s\n * @param needle\n */\nstatic bool strbuf_rev_append_char(RStrBuf *sb, const char *s, const char *needle) {\n\tr_return_val_if_fail (sb && s, false);\n\tsize_t l = strlen (s);\n\t// fast path if no chars to append\n\tif (l == 0) {\n\t\treturn true;\n\t}\n\tbool ret = false;\n\tchar *sb_str = sb->ptr ? sb->ptr : sb->buf;\n\tchar *pivot = strstr (sb_str, needle);\n\tif (!pivot) {\n\t\treturn false;\n\t}\n\tpivot += strlen (needle);\n\tsize_t idx = pivot - sb_str;\n\tsize_t newlen = l + sb->len;\n\tchar *ns = malloc (newlen + 1);\n\tif (ns) {\n\t\tmemcpy (ns, sb_str, idx);\n\t\tmemcpy (ns + idx, s, l);\n\t\tmemcpy (ns + idx + l, sb_str + idx, sb->len - idx);\n\t\tns[newlen] = 0;\n\t\tret = r_strbuf_set (sb, ns) != NULL;\n\t\tfree (ns);\n\t}\n\treturn ret;\n}\n\nstatic inline char *create_type_name_from_offset(ut64 offset) {\n\treturn r_str_newf (\"type_0x%\" PFMT64x, offset);\n}\n\n/**\n * @brief Get the DIE name or create unique one from it's offset\n *\n * @param die\n * @return char* DIEs name or NULL if error\n */\nstatic char *get_die_name(const RBinDwarfDie *die) {\n\tchar *name = NULL;\n\tst32 name_attr_idx = find_attr_idx (die, DW_AT_name);\n\tif (name_attr_idx < 0 || name_attr_idx >= die->count) {\n\t\treturn NULL;\n\t}\n\tRBinDwarfAttrValue *av = &die->attr_values[name_attr_idx];\n\tif (av->kind == DW_AT_KIND_STRING && name_attr_idx != -1 && av->string.content) {\n\t\tname = strdup (av->string.content);\n\t} else {\n\t\tname = create_type_name_from_offset (die->offset);\n\t}\n\treturn name;\n}\n\n/**\n * @brief Get the DIE size in bits\n *\n * @param die\n * @return ut64 size in bits or 0 if not found\n */\nstatic ut64 get_die_size(const RBinDwarfDie *die) {\n\tut64 size = 0;\n\tst32 byte_size_idx = find_attr_idx (die, DW_AT_byte_size);\n\n\tif (byte_size_idx != -1) {\n\t\tsize = die->attr_values[byte_size_idx].uconstant * CHAR_BIT;\n\t} else {\n\t\tst32 bit_size_idx = find_attr_idx (die, DW_AT_bit_size);\n\n\t\tif (bit_size_idx != -1) {\n\t\t\tsize = die->attr_values[bit_size_idx].uconstant;\n\t\t}\n\t}\n\treturn size;\n}\n\n/**\n * @brief Parses array type entry signature into strbuf\n *\n * @param ctx\n * @param idx index of the current entry\n * @param strbuf strbuf to store the type into\n * @return st32 -1 if error else 0\n */\nstatic st32 parse_array_type(Context *ctx, ut64 idx, RStrBuf *strbuf) {\n\tconst RBinDwarfDie *die = &ctx->all_dies[idx++];\n\n\tif (die->has_children) {\n\t\tint child_depth = 1;\n\t\tsize_t j;\n\t\tfor (j = idx; child_depth > 0 && j < ctx->count; j++) {\n\t\t\tconst RBinDwarfDie *child_die = &ctx->all_dies[j];\n\t\t\t// right now we skip non direct descendats of the structure\n\t\t\t// can be also DW_TAG_suprogram for class methods or tag for templates\n\t\t\tif (child_depth == 1 && child_die->tag == DW_TAG_subrange_type) {\n\t\t\t\tsize_t i;\n\t\t\t\tfor (i = 0; i < child_die->count; i++) {\n\t\t\t\t\tconst RBinDwarfAttrValue *value = &child_die->attr_values[i];\n\t\t\t\t\tswitch (value->attr_name) {\n\t\t\t\t\tcase DW_AT_upper_bound:\n\t\t\t\t\tcase DW_AT_count:\n\t\t\t\t\t\tr_strbuf_appendf (strbuf, \"[%\" PFMT64d \"]\", value->uconstant + 1);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (child_die->has_children) {\n\t\t\t\tchild_depth++;\n\t\t\t}\n\t\t\t// sibling list is terminated by null entry\n\t\t\tif (child_die->abbrev_code == 0) {\n\t\t\t\tchild_depth--;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * @brief Recursively parses type entry of a certain offset into strbuf\n *        saves type size into *size\n *\n * @param ctx\n * @param offset offset of the type entry\n * @param strbuf string to store the type into\n * @param size ptr to size of a type to fill up (can be NULL if unwanted)\n * @return st32 -1 if error else DW_TAG of the entry\n *\n * TODO make cache for type entries, one type is usually referenced\n * multiple times which means it's parsed multiple times instead of once\n */\nstatic st32 parse_type(Context *ctx, const ut64 offset, RStrBuf *strbuf, ut64 *size, HtUP **visited) {\n\tr_return_val_if_fail (strbuf, -1);\n\tRBinDwarfDie *die = ht_up_find (ctx->die_map, offset, NULL);\n\tif (!die) {\n\t\treturn -1;\n\t}\n\tbool root = false;\n\n\tif (!visited) {\n\t\troot = true;\n\t\tSetU *su = set_u_new ();\n\t\tvisited = malloc (sizeof (void*));\n\t\t*visited = su;\n\t}\n\tif (visited && set_u_contains (*visited, offset)) {\n\t\teprintf (\"Warning: anal.dwarf.parse_type: infinite recursion detected.\\n\");\n\t\treturn -1;\n\t}\n\tset_u_add (*visited, offset);\n\n\tst32 type_idx;\n\tst32 tag;\n\tchar *name = NULL;\n\t// get size of first type DIE that has size\n\tif (size && *size == 0) {\n\t\t*size = get_die_size (die);\n\t}\n\tswitch (die->tag) {\n\t// this should be recursive search for the type until you find base/user defined type\n\tcase DW_TAG_pointer_type:\n\t\ttype_idx = find_attr_idx (die, DW_AT_type);\n\t\tif (type_idx == -1) {\n\t\t\tr_strbuf_append (strbuf, \"void\");\n\t\t\tr_strbuf_append (strbuf, \" *\");\n\t\t} else {\n\t\t\ttag = parse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);\n\t\t\tif (tag == DW_TAG_subroutine_type) {\n\t\t\t\tstrbuf_rev_prepend_char (strbuf, \"(*)\", '(');\n\t\t\t} else if (tag == DW_TAG_pointer_type) {\n\t\t\t\tif (!strbuf_rev_append_char (strbuf, \"*\", \"(*\")) {\n\t\t\t\t\tstrbuf_rev_prepend_char (strbuf, \"*\", '*');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_strbuf_append (strbuf, \" *\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t// We won't parse them as a complete type, because that will already be done\n\t// so just a name now\n\tcase DW_TAG_typedef:\n\tcase DW_TAG_base_type:\n\tcase DW_TAG_structure_type:\n\tcase DW_TAG_enumeration_type:\n\tcase DW_TAG_union_type:\n\tcase DW_TAG_class_type:\n\t\tname = get_die_name (die);\n\t\tif (name) {\n\t\t\tr_strbuf_append (strbuf, name);\n\t\t\tfree (name);\n\t\t}\n\t\tbreak;\n\tcase DW_TAG_subroutine_type:\n\t\ttype_idx = find_attr_idx (die, DW_AT_type);\n\t\tif (type_idx == -1) {\n\t\t\tr_strbuf_append (strbuf, \"void\");\n\t\t} else {\n\t\t\tparse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);\n\t\t}\n\t\tr_strbuf_append (strbuf, \" (\");\n\t\tif (die->has_children) { // has parameters\n\t\t}\n\t\tr_strbuf_append (strbuf, \")\");\n\t\tbreak;\n\tcase DW_TAG_array_type:\n\t\ttype_idx = find_attr_idx (die, DW_AT_type);\n\t\tif (type_idx != -1) {\n\t\t\tparse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);\n\t\t}\n\t\tparse_array_type (ctx, die - ctx->all_dies, strbuf);\n\t\tbreak;\n\tcase DW_TAG_const_type:\n\t\ttype_idx = find_attr_idx (die, DW_AT_type);\n\t\tif (type_idx != -1) {\n\t\t\tparse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);\n\t\t}\n\t\tr_strbuf_append (strbuf, \" const\");\n\t\tbreak;\n\tcase DW_TAG_volatile_type:\n\t\ttype_idx = find_attr_idx (die, DW_AT_type);\n\t\tif (type_idx != -1) {\n\t\t\tparse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);\n\t\t}\n\t\tr_strbuf_append (strbuf, \" volatile\");\n\t\tbreak;\n\tcase DW_TAG_restrict_type:\n\t\ttype_idx = find_attr_idx (die, DW_AT_type);\n\t\tif (type_idx != -1) {\n\t\t\tparse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);\n\t\t}\n\t\tr_strbuf_append (strbuf, \" restrict\");\n\t\tbreak;\n\tcase DW_TAG_rvalue_reference_type:\n\t\ttype_idx = find_attr_idx (die, DW_AT_type);\n\t\tif (type_idx != -1) {\n\t\t\tparse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);\n\t\t}\n\t\tr_strbuf_append (strbuf, \" &&\");\n\t\tbreak;\n\tcase DW_TAG_reference_type:\n\t\ttype_idx = find_attr_idx (die, DW_AT_type);\n\t\tif (type_idx != -1) {\n\t\t\tparse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);\n\t\t}\n\t\tr_strbuf_append (strbuf, \" &\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (root) {\n\t\tset_u_free (*visited);\n\t}\n\treturn (st32)die->tag;\n}\n\n/**\n * @brief Parses structured entry into *result RAnalStructMember\n * http://www.dwarfstd.org/doc/DWARF4.pdf#page=102&zoom=100,0,0\n *\n * @param ctx\n * @param idx index of the current entry\n * @param result ptr to result member to fill up\n * @return RAnalStructMember* ptr to parsed Member\n */\nstatic RAnalStructMember *parse_struct_member (Context *ctx, ut64 idx, RAnalStructMember *result) {\n\tr_return_val_if_fail (result, NULL);\n\tconst RBinDwarfDie *die = &ctx->all_dies[idx];\n\n\tchar *name = NULL;\n\tchar *type = NULL;\n\tut64 offset = 0;\n\tut64 size = 0;\n\tRStrBuf strbuf;\n\tr_strbuf_init (&strbuf);\n\tsize_t i;\n\tfor (i = 0; i < die->count; i++) {\n\t\tRBinDwarfAttrValue *value = &die->attr_values[i];\n\t\tswitch (die->attr_values[i].attr_name) {\n\t\tcase DW_AT_name:\n\t\t\tfree (name);\n\t\t\tname = get_die_name (die);\n\t\t\tif (!name) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DW_AT_type:\n\t\t\tparse_type (ctx, value->reference, &strbuf, &size, NULL);\n\t\t\tfree (type);\n\t\t\ttype = r_strbuf_drain_nofree (&strbuf);\n\t\t\tif (!type || !*type) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DW_AT_data_member_location:\n\t\t\t/*\n\t\t\t\t2 cases, 1.: If val is integer, it offset in bytes from\n\t\t\t\tthe beginning of containing entity. If containing entity has\n\t\t\t\ta bit offset, member has that bit offset aswell\n\t\t\t\t2.: value is a location description\n\t\t\t\thttp://www.dwarfstd.org/doc/DWARF4.pdf#page=39&zoom=100,0,0\n\t\t\t*/\n\t\t\toffset = value->uconstant;\n\t\t\tbreak;\n\t\tcase DW_AT_accessibility: // private, public etc.\n\t\tcase DW_AT_mutable: // flag is it is mutable\n\t\tcase DW_AT_data_bit_offset:\n\t\t\t/*\n\t\t\t\tint that specifies the number of bits from beginning\n\t\t\t\tof containing entity to the beginning of the data member\n\t\t\t*/\n\t\t\tbreak;\n\t\t// If the size of a data member is not the same as the\n\t\t//  size of the type given for the data member\n\t\tcase DW_AT_byte_size:\n\t\t\tsize = value->uconstant * CHAR_BIT;\n\t\t\tbreak;\n\t\tcase DW_AT_bit_size:\n\t\t\tsize = value->uconstant;\n\t\t\tbreak;\n\t\tcase DW_AT_containing_type:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tresult->name = name;\n\tresult->type = type;\n\tresult->offset = offset;\n\tresult->size = size;\n\treturn result;\ncleanup:\n\tfree (name);\n\tfree (type);\n\treturn NULL;\n}\n\n/**\n * @brief  Parses enum entry into *result RAnalEnumCase\n * http://www.dwarfstd.org/doc/DWARF4.pdf#page=110&zoom=100,0,0\n *\n * @param ctx\n * @param idx index of the current entry\n * @param result ptr to result case to fill up\n * @return RAnalEnumCase* Ptr to parsed enum case\n */\nstatic RAnalEnumCase *parse_enumerator(Context *ctx, ut64 idx, RAnalEnumCase *result) {\n\tconst RBinDwarfDie *die = &ctx->all_dies[idx];\n\n\tchar *name = NULL;\n\tint val = 0;\n\tsize_t i;\n\n\t// Enumerator has DW_AT_name and DW_AT_const_value\n\tfor (i = 0; i < die->count; i++) {\n\t\tRBinDwarfAttrValue *value = &die->attr_values[i];\n\t\tswitch (die->attr_values[i].attr_name) {\n\t\tcase DW_AT_name:\n\t\t\tname = get_die_name (die);\n\t\t\tif (!name) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DW_AT_const_value:\n\t\t\t// ?? can be block, sdata, data, string w/e\n\t\t\tval = value->uconstant; // TODO solve the encoding, I don't know in which union member is it store\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tresult->name = name;\n\tresult->val = (int)val;\n\treturn result;\ncleanup:\n\tfree (name);\n\treturn NULL;\n}\n\n/**\n * @brief  Parses a structured entry (structs, classes, unions) into\n *         RAnalBaseType and saves it using r_anal_save_base_type ()\n *\n * @param ctx\n * @param idx index of the current entry\n */\n// http://www.dwarfstd.org/doc/DWARF4.pdf#page=102&zoom=100,0,0\nstatic void parse_structure_type(Context *ctx, ut64 idx) {\n\tconst RBinDwarfDie *die = &ctx->all_dies[idx];\n\n\tRAnalBaseTypeKind kind;\n\tif (die->tag == DW_TAG_union_type) {\n\t\tkind = R_ANAL_BASE_TYPE_KIND_UNION;\n\t} else {\n\t\tkind = R_ANAL_BASE_TYPE_KIND_STRUCT;\n\t}\n\n\tRAnalBaseType *base_type = r_anal_base_type_new (kind);\n\tif (!base_type) {\n\t\treturn;\n\t}\n\n\tbase_type->name = get_die_name (die);\n\tif (!base_type->name) {\n\t\tgoto cleanup;\n\t}\n\n\t// if it is definition of previous declaration (TODO Fix, big ugly hotfix addition)\n\tst32 spec_attr_idx = find_attr_idx (die, DW_AT_specification);\n\tif (spec_attr_idx != -1) {\n\t\tRBinDwarfDie *decl_die = ht_up_find (ctx->die_map, die->attr_values[spec_attr_idx].reference, NULL);\n\t\tif (!decl_die) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tst32 name_attr_idx = find_attr_idx (decl_die, DW_AT_name);\n\t\tif (name_attr_idx != -1) {\n\t\t\tfree (base_type->name);\n\t\t\tbase_type->name = get_die_name (decl_die);\n\t\t}\n\t}\n\n\tbase_type->size = get_die_size (die);\n\n\tRAnalStructMember member = { 0 };\n\t// Parse out all members, can this in someway be extracted to a function?\n\tif (die->has_children) {\n\t\tint child_depth = 1; // Direct children of the node\n\t\tsize_t j;\n\t\tidx++; // Move to the first children node\n\t\tfor (j = idx; child_depth > 0 && j < ctx->count; j++) {\n\t\t\tconst RBinDwarfDie *child_die = &ctx->all_dies[j];\n\t\t\t// we take only direct descendats of the structure\n\t\t\t// can be also DW_TAG_suprogram for class methods or tag for templates\n\t\t\tif (child_depth == 1 && child_die->tag == DW_TAG_member) {\n\t\t\t\tRAnalStructMember *result = parse_struct_member (ctx, j, &member);\n\t\t\t\tif (!result) {\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t} else {\n\t\t\t\t\tvoid *element = r_vector_push (&base_type->struct_data.members, &member);\n\t\t\t\t\tif (!element) {\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (child_die->has_children) {\n\t\t\t\tchild_depth++;\n\t\t\t}\n\t\t\tif (child_die->abbrev_code == 0) { // siblings terminator\n\t\t\t\tchild_depth--;\n\t\t\t}\n\t\t}\n\t}\n\tr_anal_save_base_type (ctx->anal, base_type);\ncleanup:\n\tr_anal_base_type_free (base_type);\n}\n\n/**\n * @brief Parses a enum entry into RAnalBaseType and saves it\n *        int Sdb using r_anal_save_base_type ()\n *\n * @param ctx\n * @param idx index of the current entry\n */\nstatic void parse_enum_type(Context *ctx, ut64 idx) {\n\tconst RBinDwarfDie *die = &ctx->all_dies[idx];\n\n\tRAnalBaseType *base_type = r_anal_base_type_new (R_ANAL_BASE_TYPE_KIND_ENUM);\n\tif (!base_type) {\n\t\treturn;\n\t}\n\n\tbase_type->name = get_die_name (die);\n\tif (!base_type->name) {\n\t\tgoto cleanup;\n\t}\n\tbase_type->size = get_die_size (die);\n\n\tst32 type_attr_idx = find_attr_idx (die, DW_AT_type);\n\tif (type_attr_idx != -1) {\n\t\tRStrBuf strbuf;\n\t\tr_strbuf_init (&strbuf);\n\t\tparse_type (ctx, die->attr_values[type_attr_idx].reference, &strbuf, &base_type->size, NULL);\n\t\tbase_type->type = r_strbuf_drain_nofree (&strbuf);\n\t}\n\n\tRAnalEnumCase cas;\n\tif (die->has_children) {\n\t\tint child_depth = 1; // Direct children of the node\n\t\tsize_t j;\n\t\tidx++; // Move to the first children node\n\t\tfor (j = idx; child_depth > 0 && j < ctx->count; j++) {\n\t\t\tconst RBinDwarfDie *child_die = &ctx->all_dies[j];\n\t\t\t// we take only direct descendats of the structure\n\t\t\tif (child_depth == 1 && child_die->tag == DW_TAG_enumerator) {\n\t\t\t\tRAnalEnumCase *result = parse_enumerator (ctx, j, &cas);\n\t\t\t\tif (!result) {\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t} else {\n\t\t\t\t\tvoid *element = r_vector_push (&base_type->enum_data.cases, &cas);\n\t\t\t\t\tif (!element) {\n\t\t\t\t\t\tenum_type_case_free (result, NULL);\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (child_die->has_children) {\n\t\t\t\tchild_depth++;\n\t\t\t}\n\t\t\t// sibling list is terminated by null entry\n\t\t\tif (child_die->abbrev_code == 0) {\n\t\t\t\tchild_depth--;\n\t\t\t}\n\t\t}\n\t}\n\tr_anal_save_base_type (ctx->anal, base_type);\ncleanup:\n\tr_anal_base_type_free (base_type);\n}\n\n/**\n * @brief Parses a typedef entry into RAnalBaseType and saves it\n *        using r_anal_save_base_type ()\n *\n * http://www.dwarfstd.org/doc/DWARF4.pdf#page=96&zoom=100,0,0\n *\n * @param ctx\n * @param idx index of the current entry\n */\nstatic void parse_typedef(Context *ctx, ut64 idx) {\n\tconst RBinDwarfDie *die = &ctx->all_dies[idx];\n\n\tchar *name = NULL;\n\tchar *type = NULL;\n\tut64 size = 0;\n\tRStrBuf strbuf;\n\tr_strbuf_init (&strbuf);\n\tsize_t i;\n\n\tfor (i = 0; i < die->count; i++) {\n\t\tRBinDwarfAttrValue *value = &die->attr_values[i];\n\t\tswitch (die->attr_values[i].attr_name) {\n\t\tcase DW_AT_name:\n\t\t\tfree (name);\n\t\t\tname = get_die_name (die);\n\t\t\tif (!name) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DW_AT_type:\n\t\t\tparse_type (ctx, value->reference, &strbuf, &size, NULL);\n\t\t\tfree (type);\n\t\t\ttype = r_strbuf_drain_nofree (&strbuf);\n\t\t\tif (!type) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!name) { // type has to have a name for now\n\t\tgoto cleanup;\n\t}\n\tRAnalBaseType *base_type = r_anal_base_type_new (R_ANAL_BASE_TYPE_KIND_TYPEDEF);\n\tif (!base_type) {\n\t\tgoto cleanup;\n\t}\n\tbase_type->name = name;\n\tbase_type->type = type;\n\tr_anal_save_base_type (ctx->anal, base_type);\n\tr_anal_base_type_free (base_type);\n\tr_strbuf_fini (&strbuf);\n\treturn;\ncleanup:\n\tfree (name);\n\tfree (type);\n\tr_strbuf_fini (&strbuf);\n}\n\nstatic void parse_atomic_type(Context *ctx, ut64 idx) {\n\tconst RBinDwarfDie *die = &ctx->all_dies[idx];\n\n\tchar *name = NULL;\n\tut64 size = 0;\n\tsize_t i;\n\t// TODO support endiannity and encoding in future?\n\tfor (i = 0; i < die->count; i++) {\n\t\tRBinDwarfAttrValue *value = &die->attr_values[i];\n\t\tswitch (die->attr_values[i].attr_name) {\n\t\tcase DW_AT_name:\n\t\t\tR_FREE (name);\n\t\t\tif (value->kind == DW_AT_KIND_STRING) {\n\t\t\t\tif (!value->string.content) {\n\t\t\t\t\tname = create_type_name_from_offset (die->offset);\n\t\t\t\t} else {\n\t\t\t\t\tname = strdup (value->string.content);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!name) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DW_AT_byte_size:\n\t\t\tsize = value->uconstant * CHAR_BIT;\n\t\t\tbreak;\n\t\tcase DW_AT_bit_size:\n\t\t\tsize = value->uconstant;\n\t\t\tbreak;\n\t\tcase DW_AT_encoding:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!name) { // type has to have a name for now\n\t\treturn;\n\t}\n\tRAnalBaseType *base_type = r_anal_base_type_new (R_ANAL_BASE_TYPE_KIND_ATOMIC);\n\tif (!base_type) {\n\t\tfree (name);\n\t\treturn;\n\t}\n\tbase_type->name = name;\n\tbase_type->size = size;\n\tr_anal_save_base_type (ctx->anal, base_type);\n\tr_anal_base_type_free (base_type);\n}\n\nstatic const char *get_specification_die_name(const RBinDwarfDie *die) {\n\tst32 linkage_name_attr_idx = find_attr_idx (die, DW_AT_linkage_name);\n\tif (linkage_name_attr_idx != -1 && die->attr_values[linkage_name_attr_idx].string.content) {\n\t\treturn die->attr_values[linkage_name_attr_idx].string.content;\n\t}\n\tst32 name_attr_idx = find_attr_idx (die, DW_AT_name);\n\tif (name_attr_idx != -1 && die->attr_values[name_attr_idx].string.content) {\n\t\treturn die->attr_values[name_attr_idx].string.content;\n\t}\n\treturn NULL;\n}\n\nstatic void get_spec_die_type(Context *ctx, RBinDwarfDie *die, RStrBuf *ret_type) {\n\tst32 attr_idx = find_attr_idx (die, DW_AT_type);\n\tif (attr_idx != -1) {\n\t\tut64 size = 0;\n\t\tparse_type (ctx, die->attr_values[attr_idx].reference, ret_type, &size, NULL);\n\t}\n}\n\n/* For some languages linkage name is more informative like C++,\n   but for Rust it's rubbish and the normal name is fine */\nstatic bool prefer_linkage_name(const char *lang) {\n\tif (lang == NULL) {\n\t\treturn false;\n\t} else if (!strcmp (lang, \"rust\")) {\n\t\treturn false;\n\t} else if (!strcmp (lang, \"ada\")) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void parse_abstract_origin(Context *ctx, ut64 offset, RStrBuf *type, const char **name) {\n\tRBinDwarfDie *die = ht_up_find (ctx->die_map, offset, NULL);\n\tif (die) {\n\t\tsize_t i;\n\t\tut64 size = 0;\n\t\tbool has_linkage_name = false;\n\t\tbool get_linkage_name = prefer_linkage_name (ctx->lang);\n\t\tfor (i = 0; i < die->count; i++) {\n\t\t\tconst RBinDwarfAttrValue *val = &die->attr_values[i];\n\t\t\tswitch (val->attr_name) {\n\t\t\tcase DW_AT_name:\n\t\t\t\tif (!get_linkage_name || !has_linkage_name) {\n\t\t\t\t\t*name = val->string.content;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase DW_AT_linkage_name:\n\t\t\tcase DW_AT_MIPS_linkage_name:\n\t\t\t\t*name = val->string.content;\n\t\t\t\thas_linkage_name = true;\n\t\t\t\tbreak;\n\t\t\tcase DW_AT_type:\n\t\t\t\tparse_type (ctx, val->reference, type, &size, NULL);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* x86_64 https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf */\nstatic const char *map_dwarf_reg_to_x86_64_reg(ut64 reg_num, VariableLocationKind *kind) {\n\t*kind = LOCATION_REGISTER;\n\tswitch (reg_num) {\n\t\tcase 0: return \"rax\";\n\t\tcase 1: return \"rdx\";\n\t\tcase 2: return \"rcx\";\n\t\tcase 3: return \"rbx\";\n\t\tcase 4: return \"rsi\";\n\t\tcase 5: return \"rdi\";\n\t\tcase 6:\n\t\t\t*kind = LOCATION_BP;\n\t\t\treturn \"rbp\";\n\t\tcase 7:\n\t\t\t*kind = LOCATION_SP;\n\t\t\treturn \"rsp\";\n\t\tcase 8: return \"r8\";\n\t\tcase 9: return \"r9\";\n\t\tcase 10: return \"r10\";\n\t\tcase 11: return \"r11\";\n\t\tcase 12: return \"r12\";\n\t\tcase 13: return \"r13\";\n\t\tcase 14: return \"r14\";\n\t\tcase 15: return \"r15\";\n\t\tcase 17: return \"xmm0\";\n\t\tcase 18: return \"xmm1\";\n\t\tcase 19: return \"xmm2\";\n\t\tcase 20: return \"xmm3\";\n\t\tcase 21: return \"xmm4\";\n\t\tcase 22: return \"xmm5\";\n\t\tcase 23: return \"xmm6\";\n\t\tcase 24: return \"xmm7\";\n\t\tdefault:\n\t\t\t*kind = LOCATION_UNKNOWN;\n\t\t\treturn \"unsupported_reg\";\n\t}\n}\n\n/* x86 https://01.org/sites/default/files/file_attach/intel386-psabi-1.0.pdf */\nstatic const char *map_dwarf_reg_to_x86_reg(ut64 reg_num, VariableLocationKind *kind) {\n\t*kind = LOCATION_REGISTER;\n\tswitch (reg_num) {\n\t\tcase 0: return \"eax\";\n\t\tcase 1: return \"edx\";\n\t\tcase 2: return \"ecx\";\n\t\tcase 3: return \"ebx\";\n\t\tcase 4:\n\t\t\t*kind = LOCATION_SP;\n\t\t\treturn \"esp\";\n\t\tcase 5:\n\t\t\t*kind = LOCATION_BP;\n\t\t\treturn \"ebp\";\n\t\tcase 6: return \"esi\";\n\t\tcase 7: return \"edi\";\n\t\tcase 21: return \"xmm0\";\n\t\tcase 22: return \"xmm1\";\n\t\tcase 23: return \"xmm2\";\n\t\tcase 24: return \"xmm3\";\n\t\tcase 25: return \"xmm4\";\n\t\tcase 26: return \"xmm5\";\n\t\tcase 27: return \"xmm6\";\n\t\tcase 28: return \"xmm7\";\n\t\tdefault:\n\t\t\tr_warn_if_reached ();\n\t\t\t*kind = LOCATION_UNKNOWN;\n\t\t\treturn \"unsupported_reg\";\n\t}\n}\n\n/* https://refspecs.linuxfoundation.org/ELF/ppc64/PPC-elf64abi-1.9.html#DW-REG */\nstatic const char *map_dwarf_reg_to_ppc64_reg(ut64 reg_num, VariableLocationKind *kind) {\n\t*kind = LOCATION_REGISTER;\n\tswitch (reg_num) {\n\t\tcase 0: return \"r0\";\n\t\tcase 1:\n\t\t\t*kind = LOCATION_SP;\n\t\t\treturn \"r1\";\n\t\tcase 2: return \"r2\";\n\t\tcase 3: return \"r3\";\n\t\tcase 4: return \"r4\";\n\t\tcase 5: return \"r5\";\n\t\tcase 6: return \"r6\";\n\t\tcase 7: return \"r7\";\n\t\tcase 8: return \"r8\";\n\t\tcase 9: return \"r9\";\n\t\tcase 10: return \"r10\";\n\t\tcase 11: return \"r11\";\n\t\tcase 12: return \"r12\";\n\t\tcase 13: return \"r13\";\n\t\tcase 14: return \"r14\";\n\t\tcase 15: return \"r15\";\n\t\tcase 16: return \"r16\";\n\t\tcase 17: return \"r17\";\n\t\tcase 18: return \"r18\";\n\t\tcase 19: return \"r19\";\n\t\tcase 20: return \"r20\";\n\t\tcase 21: return \"r21\";\n\t\tcase 22: return \"r22\";\n\t\tcase 23: return \"r23\";\n\t\tcase 24: return \"r24\";\n\t\tcase 25: return \"r25\";\n\t\tcase 26: return \"r26\";\n\t\tcase 27: return \"r27\";\n\t\tcase 28: return \"r28\";\n\t\tcase 29: return \"r29\";\n\t\tcase 30: return \"r30\";\n\t\tcase 31: return \"r31\";\n\t\tdefault:\n\t\t\tr_warn_if_reached ();\n\t\t\t*kind = LOCATION_UNKNOWN;\n\t\t\treturn \"unsupported_reg\";\n\t}\n}\n\n/* returns string literal register name!\n   TODO add more arches                 */\nstatic const char *get_dwarf_reg_name(char *arch, int reg_num, VariableLocationKind *kind, int bits) {\n\tif (!strcmp (arch, \"x86\")) {\n\t\tif (bits == 64) {\n\t\t\treturn map_dwarf_reg_to_x86_64_reg (reg_num, kind);\n\t\t} else {\n\t\t\treturn map_dwarf_reg_to_x86_reg (reg_num, kind);\n\t\t}\n\t} else if (!strcmp (arch, \"ppc\")) {\n\t\tif (bits == 64) {\n\t\t\treturn map_dwarf_reg_to_ppc64_reg (reg_num, kind);\n\t\t}\n\t}\n\t*kind = LOCATION_UNKNOWN;\n\treturn \"unsupported_reg\";\n}\n\nstatic RBinDwarfLocRange *find_largest_loc_range (RList *loc_list) {\n\tRBinDwarfLocRange *largest = NULL;\n\tut64 max_range_size = 0;\n\tRListIter *iter;\n\tRBinDwarfLocRange *range;\n\tr_list_foreach (loc_list, iter, range) {\n\t\tut64 diff = range->end - range->start;\n\t\tif (diff > max_range_size) {\n\t\t\tmax_range_size = diff ;\n\t\t\tlargest = range;\n\t\t}\n\t}\n\treturn largest;\n}\n\n/* TODO move a lot of the parsing here into dwarf.c and do only processing here */\nstatic VariableLocation *parse_dwarf_location (Context *ctx, const RBinDwarfAttrValue *loc, const RBinDwarfAttrValue *frame_base) {\n\t/* reg5 - val is in register 5\n\tfbreg <leb> - offset from frame base\n\tregx <leb> - contents is in register X\n\taddr <addr> - contents is in at addr\n\tbregXX <leb> - contents is at offset from specified register\n\t- we now support 3 options: SP, BP and register based arguments */\n\n\t/* Loclist offset is usually CONSTANT or REFERENCE at older DWARF versions, new one has LocListPtr for that */\n\tif (loc->kind != DW_AT_KIND_BLOCK && loc->kind != DW_AT_KIND_LOCLISTPTR && loc->kind != DW_AT_KIND_REFERENCE && loc->kind != DW_AT_KIND_CONSTANT) {\n\t\treturn NULL;\n\t}\n\tRBinDwarfBlock block;\n\tif (loc->kind == DW_AT_KIND_LOCLISTPTR || loc->kind == DW_AT_KIND_REFERENCE || loc->kind == DW_AT_KIND_CONSTANT) {\n\t\tut64 offset = loc->reference;\n\t\tRBinDwarfLocList *range_list = ht_up_find (ctx->locations, offset, NULL);\n\t\tif (!range_list) { /* for some reason offset isn't there, wrong parsing or malformed dwarf */\n\t\t\treturn NULL;\n\t\t}\n\t\t/* use the largest range as a variable */\n\t\tRBinDwarfLocRange *range = find_largest_loc_range (range_list->list);\n\t\tif (!range) {\n\t\t\treturn NULL;\n\t\t}\n\t\t/* Very rough and sloppy, refactor this hacked up stuff */\n\t\tblock = *range->expression;\n\t\t// range->expression... etc\n\t} else {\n\t\tblock = loc->block;\n\t}\n\tVariableLocationKind kind = LOCATION_UNKNOWN;\n\tst64 offset = 0;\n\tut64 address = 0;\n\tut64 reg_num = -1;\n\tconst char *reg_name = NULL; /* literal */\n\tsize_t i;\n\tfor (i = 0; i < block.length; i++) {\n\t\tswitch (block.data[i]) {\n\t\tcase DW_OP_fbreg: {\n\t\t\t/* TODO sometimes CFA is referenced, but we don't parse that yet\n\t\t\t   just an offset involving framebase of a function*/\n\t\t\tif (i == block.length - 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ti++;\n\t\t\tconst ut8 *dump = block.data + i;\n\t\t\tif (loc->block.length > block.length) {\n\t\t\t\t// eprintf (\"skip = %d%c\", loc->block.length, 10);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\toffset = r_sleb128 (&dump, block.data + loc->block.length);\n\t\t\tif (frame_base) {\n\t\t\t\t/* recursive parsing, but frame_base should be only one, but someone\n\t\t\t\t   could make malicious resource exhaustion attack, so a depth counter might be cool? */\n\t\t\t\tVariableLocation *location = parse_dwarf_location (ctx, frame_base, NULL);\n\t\t\t\tif (location) {\n\t\t\t\t\tlocation->offset += offset;\n\t\t\t\t\treturn location;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Might happen if frame_base has a frame_base reference? I don't think it can tho */\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\tcase DW_OP_reg0:\n\t\tcase DW_OP_reg1:\n\t\tcase DW_OP_reg2:\n\t\tcase DW_OP_reg3:\n\t\tcase DW_OP_reg4:\n\t\tcase DW_OP_reg5:\n\t\tcase DW_OP_reg6:\n\t\tcase DW_OP_reg7:\n\t\tcase DW_OP_reg8:\n\t\tcase DW_OP_reg9:\n\t\tcase DW_OP_reg10:\n\t\tcase DW_OP_reg11:\n\t\tcase DW_OP_reg12:\n\t\tcase DW_OP_reg13:\n\t\tcase DW_OP_reg14:\n\t\tcase DW_OP_reg15:\n\t\tcase DW_OP_reg16:\n\t\tcase DW_OP_reg17:\n\t\tcase DW_OP_reg18:\n\t\tcase DW_OP_reg19:\n\t\tcase DW_OP_reg20:\n\t\tcase DW_OP_reg21:\n\t\tcase DW_OP_reg22:\n\t\tcase DW_OP_reg23:\n\t\tcase DW_OP_reg24:\n\t\tcase DW_OP_reg25:\n\t\tcase DW_OP_reg26:\n\t\tcase DW_OP_reg27:\n\t\tcase DW_OP_reg28:\n\t\tcase DW_OP_reg29:\n\t\tcase DW_OP_reg30:\n\t\tcase DW_OP_reg31: {\n\t\t\t/* Will mostly be used for SP based arguments */\n\t\t\t/* TODO I need to find binaries that uses this so I can test it out*/\n\t\t\treg_num = block.data[i] - DW_OP_reg0; // get the reg number\n\t\t\treg_name = get_dwarf_reg_name (ctx->anal->cpu, reg_num, &kind, ctx->anal->bits);\n\t\t\tbreak;\n\t\t}\n\t\tcase DW_OP_breg0:\n\t\tcase DW_OP_breg1:\n\t\tcase DW_OP_breg2:\n\t\tcase DW_OP_breg3:\n\t\tcase DW_OP_breg4:\n\t\tcase DW_OP_breg5:\n\t\tcase DW_OP_breg6:\n\t\tcase DW_OP_breg7:\n\t\tcase DW_OP_breg8:\n\t\tcase DW_OP_breg9:\n\t\tcase DW_OP_breg10:\n\t\tcase DW_OP_breg11:\n\t\tcase DW_OP_breg12:\n\t\tcase DW_OP_breg13:\n\t\tcase DW_OP_breg14:\n\t\tcase DW_OP_breg15:\n\t\tcase DW_OP_breg16:\n\t\tcase DW_OP_breg17:\n\t\tcase DW_OP_breg18:\n\t\tcase DW_OP_breg19:\n\t\tcase DW_OP_breg20:\n\t\tcase DW_OP_breg21:\n\t\tcase DW_OP_breg22:\n\t\tcase DW_OP_breg23:\n\t\tcase DW_OP_breg24:\n\t\tcase DW_OP_breg25:\n\t\tcase DW_OP_breg26:\n\t\tcase DW_OP_breg27:\n\t\tcase DW_OP_breg28:\n\t\tcase DW_OP_breg29:\n\t\tcase DW_OP_breg30:\n\t\tcase DW_OP_breg31: {\n\t\t\tif (i == block.length - 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t/* The single operand of the DW_OP_bregn operations provides\n\t\t\tsigned LEB128 offset from the specified register.  */\n\t\t\treg_num = block.data[i] - DW_OP_breg0; // get the reg number\n\t\t\tconst ut8 *buffer = &block.data[++i];\n\t\t\toffset = r_sleb128 (&buffer, &block.data[block.length]);\n\t\t\t/* TODO do a proper expression parsing, move by the amount of bytes sleb reads */\n\t\t\ti += buffer - &block.data[0];\n\t\t\treg_name = get_dwarf_reg_name (ctx->anal->cpu, reg_num, &kind, ctx->anal->bits);\n\t\t\tbreak;\n\t\t}\n\t\tcase DW_OP_bregx: {\n\t\t\tif (i == block.length - 1) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t/* 2 operands, reg_number, offset*/\n\t\t\t/* I need to find binaries that uses this so I can test it out*/\n\t\t\tconst ut8 *buffer = &block.data[++i];\n\t\t\tconst ut8 *buf_end = &block.data[block.length];\n\t\t\tbuffer = r_uleb128 (buffer, buf_end - buffer, &reg_num, NULL);\n\t\t\tif (buffer == buf_end) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\toffset = r_sleb128 (&buffer, buf_end);\n\t\t\treg_name = get_dwarf_reg_name (ctx->anal->cpu, reg_num, &kind, ctx->anal->bits);\n\t\t\tbreak;\n\t\t}\n\t\tcase DW_OP_addr: {\n\t\t\t/* The DW_OP_addr operation has a single operand that encodes a machine address and whose\n\t\t\tsize is the size of an address on the target machine.  */\n\t\t\tconst int addr_size = ctx->anal->bits / 8;\n\t\t\tconst ut8 *dump = &block.data[++i];\n\t\t\t/* malformed, not enough bytes to represent address */\n\t\t\tif (block.length - i < addr_size) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tswitch (addr_size) {\n\t\t\tcase 1:\n\t\t\t\taddress = r_read_ble8 (dump);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\taddress = r_read_ble16 (dump, ctx->anal->big_endian);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\taddress = r_read_ble32 (dump, ctx->anal->big_endian);\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\taddress = r_read_ble64 (dump, ctx->anal->big_endian);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr_warn_if_reached (); /* weird addr_size */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tkind = LOCATION_GLOBAL; // address\n\t\t\tbreak;\n\t\t}\n\t\tcase DW_OP_call_frame_cfa: {\n\t\t\t// REMOVE XXX\n\t\t\tkind = LOCATION_BP;\n\t\t\toffset += 16;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (kind == LOCATION_UNKNOWN) {\n\t\treturn NULL;\n\t}\n\tVariableLocation *location = R_NEW0 (VariableLocation);\n\tif (location) {\n\t\tlocation->reg_name = reg_name;\n\t\tlocation->reg_num = reg_num;\n\t\tlocation->kind = kind;\n\t\tlocation->offset = offset;\n\t\tlocation->address = address;\n\t}\n\treturn location;\n}\n\nstatic st32 parse_function_args_and_vars(Context *ctx, ut64 idx, RStrBuf *args, RList/*<Variable*>*/ *variables) {\n\tconst RBinDwarfDie *die = &ctx->all_dies[idx++];\n\n\tif (die->has_children) {\n\t\tint child_depth = 1;\n\n\t\tbool get_linkage_name = prefer_linkage_name (ctx->lang);\n\t\tbool has_linkage_name = false;\n\t\tint argNumber = 1;\n\t\tsize_t j;\n\t\tfor (j = idx; child_depth > 0 && j < ctx->count; j++) {\n\t\t\tconst RBinDwarfDie *child_die = &ctx->all_dies[j];\n\t\t\tRStrBuf type;\n\t\t\tr_strbuf_init (&type);\n\t\t\tconst char *name = NULL;\n\t\t\tif (child_die->tag == DW_TAG_formal_parameter || child_die->tag == DW_TAG_variable) {\n\t\t\t\tVariable *var = R_NEW0 (Variable);\n\t\t\t\tsize_t i;\n\t\t\t\tfor (i = 0; i < child_die->count; i++) {\n\t\t\t\t\tconst RBinDwarfAttrValue *val = &child_die->attr_values[i];\n\t\t\t\t\tswitch (val->attr_name) {\n\t\t\t\t\tcase DW_AT_name:\n\t\t\t\t\t\tif (!get_linkage_name || !has_linkage_name) {\n\t\t\t\t\t\t\tname = val->string.content;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DW_AT_linkage_name:\n\t\t\t\t\tcase DW_AT_MIPS_linkage_name:\n\t\t\t\t\t\tname = val->string.content;\n\t\t\t\t\t\thas_linkage_name = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DW_AT_type:\n\t\t\t\t\t\tparse_type (ctx, val->reference, &type, NULL, NULL);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// abstract origin is supposed to have omitted information\n\t\t\t\t\tcase DW_AT_abstract_origin:\n\t\t\t\t\t\tparse_abstract_origin (ctx, val->reference, &type, &name);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DW_AT_location:\n\t\t\t\t\t\tvar->location = parse_dwarf_location (ctx, val, find_attr (die, DW_AT_frame_base));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (child_die->tag == DW_TAG_formal_parameter && child_depth == 1) {\n\t\t\t\t\t/* arguments sometimes have only type, create generic argX */\n\t\t\t\t\tif (type.len) {\n\t\t\t\t\t\tif (!name) {\n\t\t\t\t\t\t\tvar->name = r_str_newf (\"arg%d\", argNumber);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar->name = strdup (name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_strbuf_appendf (args, \"%s %s,\", r_strbuf_get (&type), var->name);\n\t\t\t\t\t\tvar->type = strdup (r_strbuf_get (&type));\n\t\t\t\t\t\tr_list_append (variables, var);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvariable_free (var);\n\t\t\t\t\t}\n\t\t\t\t\targNumber++;\n\t\t\t\t} else { /* DW_TAG_variable */\n\t\t\t\t\tif (name && type.len) {\n\t\t\t\t\t\tvar->name = strdup (name);\n\t\t\t\t\t\tvar->type = strdup (r_strbuf_get (&type));\n\t\t\t\t\t\tr_list_append (variables, var);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvariable_free (var);\n\t\t\t\t\t}\n\t\t\t\t\tr_strbuf_fini (&type);\n\t\t\t\t}\n\t\t\t} else if (child_depth == 1 && child_die->tag == DW_TAG_unspecified_parameters) {\n\t\t\t\tr_strbuf_appendf (args, \"va_args ...,\");\n\t\t\t}\n\t\t\tif (child_die->has_children) {\n\t\t\t\tchild_depth++;\n\t\t\t}\n\t\t\tif (child_die->abbrev_code == 0) { /* sibling list is terminated by null entry */\n\t\t\t\tchild_depth--;\n\t\t\t}\n\t\t\tr_strbuf_fini (&type);\n\t\t}\n\t\tif (args->len > 0) {\n\t\t\tr_strbuf_slice (args, 0, args->len - 1);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void sdb_save_dwarf_function(Function *dwarf_fcn, RList/*<Variable*>*/ *variables, Sdb *sdb) {\n\tchar *sname = r_str_sanitize_sdb_key (dwarf_fcn->name);\n\tsdb_set (sdb, sname, \"fcn\", 0);\n\n\tchar *addr_key = r_str_newf (\"fcn.%s.addr\", sname);\n\tchar *addr_val = r_str_newf (\"0x%\" PFMT64x \"\", dwarf_fcn->addr);\n\tsdb_set (sdb, addr_key, addr_val, 0);\n\tfree (addr_key);\n\tfree (addr_val);\n\n\t/* so we can have name without sanitization */\n\tchar *name_key = r_str_newf (\"fcn.%s.name\", sname);\n\tchar *name_val = r_str_newf (\"%s\", dwarf_fcn->name);\n\tsdb_set (sdb, name_key, name_val, 0);\n\tfree (name_key);\n\tfree (name_val);\n\n\tchar *signature_key = r_str_newf (\"fcn.%s.sig\", sname);\n\tsdb_set (sdb, signature_key, dwarf_fcn->signature, 0);\n\tfree (signature_key);\n\n\tRStrBuf vars;\n\tr_strbuf_init (&vars);\n\tRListIter *iter;\n\tVariable *var;\n\tr_list_foreach (variables, iter, var) {\n\t\tif (!var->location) {\n\t\t\t/* NULL location probably means optimized out, maybe put a comment there */\n\t\t\tcontinue;\n\t\t}\n\t\tchar *key = NULL;\n\t\tchar *val = NULL;\n\t\tswitch (var->location->kind) {\n\t\tcase LOCATION_BP: {\n\t\t\t/* value = \"type, storage, additional info based on storage (offset)\" */\n\n\t\t\tr_strbuf_appendf (&vars, \"%s,\", var->name);\n\t\t\tkey = r_str_newf (\"fcn.%s.var.%s\", sname, var->name);\n\t\t\tval = r_str_newf (\"%s,%\" PFMT64d \",%s\", \"b\", var->location->offset, var->type);\n\t\t\tsdb_set (sdb, key, val, 0);\n\t\t\tbreak;\n\t\t}\n\t\tcase LOCATION_SP: {\n\t\t\t/* value = \"type, storage, additional info based on storage (offset)\" */\n\n\t\t\tr_strbuf_appendf (&vars, \"%s,\", var->name);\n\t\t\tkey = r_str_newf (\"fcn.%s.var.%s\", sname, var->name);\n\t\t\tval = r_str_newf (\"%s,%\" PFMT64d \",%s\", \"s\", var->location->offset, var->type);\n\t\t\tsdb_set (sdb, key, val, 0);\n\t\t\tbreak;\n\t\t}\n\t\tcase LOCATION_GLOBAL: {\n\t\t\t/* value = \"type, storage, additional info based on storage (address)\" */\n\n\t\t\tr_strbuf_appendf (&vars, \"%s,\", var->name);\n\t\t\tkey = r_str_newf (\"fcn.%s.var.%s\", sname, var->name);\n\t\t\tval = r_str_newf (\"%s,%\" PFMT64u \",%s\", \"g\", var->location->address, var->type);\n\t\t\tsdb_set (sdb, key, val, 0);\n\t\t\tbreak;\n\t\t}\n\t\tcase LOCATION_REGISTER: {\n\t\t\t/* value = \"type, storage, additional info based on storage (register name)\" */\n\n\t\t\tr_strbuf_appendf (&vars, \"%s,\", var->name);\n\t\t\tkey = r_str_newf (\"fcn.%s.var.%s\", sname, var->name);\n\t\t\tval = r_str_newf (\"%s,%s,%s\", \"r\", var->location->reg_name, var->type);\n\t\t\tsdb_set (sdb, key, val, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\t/* else location is unknown (optimized out), skip the var */\n\t\t\tbreak;\n\t\t}\n\t\tfree (key);\n\t\tfree (val);\n\t}\n\tif (vars.len > 0) { /* remove the extra , */\n\t\tr_strbuf_slice (&vars, 0, vars.len - 1); /* leaks? */\n\t}\n\tchar *vars_key = r_str_newf (\"fcn.%s.vars\", sname);\n\tchar *vars_val = r_str_newf (\"%s\", r_strbuf_get (&vars));\n\tsdb_set (sdb, vars_key, vars_val, 0);\n\tfree (vars_key);\n\tfree (vars_val);\n\tr_strbuf_fini (&vars);\n\tfree (sname);\n}\n\n/**\n * @brief Parse function,it's arguments, variables and\n *        save the information into the Sdb\n *\n * @param ctx\n * @param idx Current entry index\n */\nstatic void parse_function(Context *ctx, ut64 idx) {\n\tconst RBinDwarfDie *die = &ctx->all_dies[idx];\n\n\tFunction fcn = { 0 };\n\tbool has_linkage_name = false;\n\tbool get_linkage_name = prefer_linkage_name (ctx->lang);\n\tRStrBuf ret_type;\n\tr_strbuf_init (&ret_type);\n\tif (find_attr_idx (die, DW_AT_declaration) != -1) {\n\t\treturn; /* just declaration skip */\n\t}\n\tsize_t i;\n\t/* For rust binaries prefer regular name not linkage TODO */\n\tfor (i = 0; i < die->count; i++) {\n\t\tRBinDwarfAttrValue *val = &die->attr_values[i];\n\t\tswitch (die->attr_values[i].attr_name) {\n\t\tcase DW_AT_name:\n\t\t\tif (!get_linkage_name || !has_linkage_name) {\n\t\t\t\tfcn.name = val->string.content;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DW_AT_linkage_name:\n\t\tcase DW_AT_MIPS_linkage_name:\n\t\t\tfcn.name = val->string.content;\n\t\t\thas_linkage_name = true;\n\t\t\tbreak;\n\t\tcase DW_AT_low_pc:\n\t\tcase DW_AT_entry_pc:\n\t\t\tfcn.addr = val->address;\n\t\t\tbreak;\n\t\tcase DW_AT_specification: /* reference to declaration DIE with more info */\n\t\t{\n\t\t\tRBinDwarfDie *spec_die = ht_up_find (ctx->die_map, val->reference, NULL);\n\t\t\tif (spec_die) {\n\t\t\t\tfcn.name = get_specification_die_name (spec_die); /* I assume that if specification has a name, this DIE hasn't */\n\t\t\t\tget_spec_die_type (ctx, spec_die, &ret_type);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase DW_AT_type:\n\t\t\tparse_type (ctx, val->reference, &ret_type, NULL, NULL);\n\t\t\tbreak;\n\t\tcase DW_AT_virtuality:\n\t\t\tfcn.is_method = true; /* method specific attr */\n\t\t\tfcn.is_virtual = true;\n\t\t\tbreak;\n\t\tcase DW_AT_object_pointer:\n\t\t\tfcn.is_method = true;\n\t\t\tbreak;\n\t\tcase DW_AT_vtable_elem_location:\n\t\t\tfcn.is_method = true;\n\t\t\tfcn.vtable_addr = 0; /* TODO we might use this information */\n\t\t\tbreak;\n\t\tcase DW_AT_accessibility:\n\t\t\tfcn.is_method = true;\n\t\t\tfcn.access = (ut8)val->uconstant;\n\t\t\tbreak;\n\t\tcase DW_AT_external:\n\t\t\tfcn.is_external = true;\n\t\t\tbreak;\n\t\tcase DW_AT_trampoline:\n\t\t\tfcn.is_trampoline = true;\n\t\t\tbreak;\n\t\tcase DW_AT_ranges:\n\t\tcase DW_AT_high_pc:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!fcn.name || !fcn.addr) { /* we need a name, faddr */\n\t\tgoto cleanup;\n\t}\n\tRStrBuf args;\n\tr_strbuf_init (&args);\n\t/* TODO do the same for arguments in future so we can use their location */\n\tRList/*<Variable*>*/  *variables = r_list_new ();\n\tparse_function_args_and_vars (ctx, idx, &args, variables);\n\n\tif (ret_type.len == 0) { /* DW_AT_type is omitted in case of `void` ret type */\n\t\tr_strbuf_append (&ret_type, \"void\");\n\t}\n\tr_warn_if_fail (ctx->lang);\n\tchar *new_name = ctx->anal->binb.demangle (NULL, ctx->lang, fcn.name, fcn.addr, false);\n\tfcn.name = new_name ? new_name : strdup (fcn.name);\n\tfcn.signature = r_str_newf (\"%s %s(%s);\", r_strbuf_get (&ret_type), fcn.name, r_strbuf_get (&args));\n\tsdb_save_dwarf_function (&fcn, variables, ctx->sdb);\n\n\tfree ((char *)fcn.signature);\n\tfree ((char *)fcn.name);\n\n\tRListIter *iter;\n\tVariable *var;\n\tr_list_foreach (variables, iter, var) {\n\t\tvariable_free (var);\n\t}\n\tr_list_free (variables);\n\tr_strbuf_fini (&args);\ncleanup:\n\tr_strbuf_fini (&ret_type);\n}\n\n/**\n * @brief Get's language from comp unit for demangling\n *\n * @param die\n * @return char* string literal language represantation for demangling BinDemangle\n */\nstatic const char *parse_comp_unit_lang(const RBinDwarfDie *die) {\n\tr_return_val_if_fail (die, NULL);\n\n\tint idx = find_attr_idx (die, DW_AT_language);\n\tconst char *lang = \"cxx\"; // default fallback\n\tif (idx == -1) {\n\t\t/* What to do now, it should have  one?, just assume C++ */\n\t\treturn lang;\n\t}\n\tconst RBinDwarfAttrValue *val = &die->attr_values[idx];\n\tr_warn_if_fail (val->kind == DW_AT_KIND_CONSTANT);\n\n\tswitch (val->uconstant)\n\t{\n\tcase DW_LANG_Java:\n\t\treturn \"java\";\n\tcase DW_LANG_ObjC:\n\t/* subideal, TODO research if dwarf gives me enough info to properly separate C++ and ObjC mangling */\n\tcase DW_LANG_ObjC_plus_plus:\n\t\treturn \"objc\";\n\tcase DW_LANG_D:\n\t\treturn \"dlang\";\n\tcase DW_LANG_Rust:\n\t\treturn \"rust\";\n\tcase DW_LANG_C_plus_plus:\n\tcase DW_LANG_C_plus_plus_14:\n\t/* no demangling available */\n\tcase DW_LANG_Ada83:\n\tcase DW_LANG_Cobol74:\n\tcase DW_LANG_Cobol85:\n\tcase DW_LANG_Fortran77:\n\tcase DW_LANG_Fortran90:\n\tcase DW_LANG_Pascal83:\n\tcase DW_LANG_Modula2:\n\tcase DW_LANG_Ada95:\n\tcase DW_LANG_Fortran95:\n\tcase DW_LANG_PLI:\n\tcase DW_LANG_Python:\n\tcase DW_LANG_Swift:\n\tcase DW_LANG_Julia:\n\tcase DW_LANG_Dylan:\n\tcase DW_LANG_Fortran03:\n\tcase DW_LANG_Fortran08:\n\tcase DW_LANG_UPC:\n\tcase DW_LANG_C:\n\tcase DW_LANG_C89:\n\tcase DW_LANG_C99:\n\tcase DW_LANG_C11:\n\tdefault:\n\t\treturn lang;\n\t}\n\treturn lang;\n}\n\n/**\n * @brief Delegates DIE to it's proper parsing method\n *\n * @param ctx\n * @param idx index of the current entry\n */\nstatic void parse_type_entry(Context *ctx, ut64 idx) {\n\tr_return_if_fail (ctx);\n\n\tconst RBinDwarfDie *die = &ctx->all_dies[idx];\n\tswitch (die->tag) {\n\tcase DW_TAG_structure_type:\n\tcase DW_TAG_union_type:\n\tcase DW_TAG_class_type:\n\t\tparse_structure_type (ctx, idx);\n\t\tbreak;\n\tcase DW_TAG_enumeration_type:\n\t\tparse_enum_type (ctx, idx);\n\t\tbreak;\n\tcase DW_TAG_typedef:\n\t\tparse_typedef (ctx, idx);\n\t\tbreak;\n\tcase DW_TAG_base_type:\n\t\tparse_atomic_type (ctx, idx);\n\t\tbreak;\n\tcase DW_TAG_subprogram:\n\t\tparse_function (ctx, idx);\n\t\tbreak;\n\tcase DW_TAG_compile_unit:\n\t\t/* used for name demangling */\n\t\tctx->lang = parse_comp_unit_lang (die);\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/**\n * @brief Parses type and function information out of DWARF entries\n *        and stores them to the sdb for further use\n *\n * @param anal\n * @param ctx\n */\nR_API void r_anal_dwarf_process_info(const RAnal *anal, RAnalDwarfContext *ctx) {\n\tr_return_if_fail (ctx && anal);\n\tSdb *dwarf_sdb =  sdb_ns (anal->sdb, \"dwarf\", 1);\n\tsize_t i, j;\n\tconst RBinDwarfDebugInfo *info = ctx->info;\n\tfor (i = 0; i < info->count; i++) {\n\t\tRBinDwarfCompUnit *unit = &info->comp_units[i];\n\t\tContext dw_context = { // context per unit?\n\t\t\t.anal = anal,\n\t\t\t.all_dies = unit->dies,\n\t\t\t.count = unit->count,\n\t\t\t.die_map = info->lookup_table,\n\t\t\t.sdb = dwarf_sdb,\n\t\t\t.locations = ctx->loc,\n\t\t\t.lang = NULL\n\t\t};\n\t\tfor (j = 0; j < unit->count; j++) {\n\t\t\tparse_type_entry (&dw_context, j);\n\t\t}\n\t}\n}\n\nbool filter_sdb_function_names(void *user, const char *k, const char *v) {\n\t(void) user;\n\t(void) k;\n\treturn !strcmp (v, \"fcn\");\n}\n\n/**\n * @brief Use parsed DWARF function info from Sdb in the anal functions\n *  XXX right now we only save parsed name and variables, we can't use signature now\n *  XXX refactor to be more readable\n * @param anal\n * @param dwarf_sdb\n */\nR_API void r_anal_dwarf_integrate_functions(RAnal *anal, RFlag *flags, Sdb *dwarf_sdb) {\n\tr_return_if_fail (anal && dwarf_sdb);\n\n\t/* get all entries with value == func */\n\tSdbList *sdb_list = sdb_foreach_list_filter (dwarf_sdb, filter_sdb_function_names, false);\n\tSdbListIter *it;\n\tSdbKv *kv;\n\t/* iterate all function entries */\n\tls_foreach (sdb_list, it, kv) {\n\t\tchar *func_sname = kv->base.key;\n\n\t\tchar *addr_key = r_str_newf (\"fcn.%s.addr\", func_sname);\n\t\tut64 faddr = sdb_num_get (dwarf_sdb, addr_key, 0);\n\t\tfree (addr_key);\n\n\t\t/* if the function is analyzed so we can edit */\n\t\tRAnalFunction *fcn = r_anal_get_function_at (anal, faddr);\n\t\tif (fcn) {\n\t\t\t/* prepend dwarf debug info stuff with dbg. */\n\t\t\tchar *real_name_key = r_str_newf (\"fcn.%s.name\", func_sname);\n\t\t\tchar *real_name = sdb_get (dwarf_sdb, real_name_key, 0);\n\t\t\tfree (real_name_key);\n\n\t\t\tchar *dwf_name = r_str_newf (\"dbg.%s\", real_name);\n\t\t\tfree (real_name);\n\n\t\t\tr_anal_function_rename (fcn, dwf_name);\n\t\t\tfree (dwf_name);\n\n\t\t\tchar *tmp = r_str_newf (\"fcn.%s.sig\", func_sname);\n\t\t\tchar *fcnstr = sdb_get (dwarf_sdb, tmp, 0);\n\t\t\tfree (tmp);\n\t\t\t/* Apply signature as a comment at a function address */\n\t\t\tr_meta_set_string (anal, R_META_TYPE_COMMENT, faddr, fcnstr);\n\t\t\tfree (fcnstr);\n\t\t}\n\t\tchar *var_names_key = r_str_newf (\"fcn.%s.vars\", func_sname);\n\t\tchar *vars = sdb_get (dwarf_sdb, var_names_key, NULL);\n\t\tchar *var_name;\n\t\tsdb_aforeach (var_name, vars) {\n\t\t\tchar *var_key = r_str_newf (\"fcn.%s.var.%s\", func_sname, var_name);\n\t\t\tchar *var_data = sdb_get (dwarf_sdb, var_key, NULL);\n\t\t\tif (!var_data) {\n\t\t\t\tgoto loop_end;\n\t\t\t}\n\t\t\tchar *extra = NULL;\n\t\t\tchar *kind = sdb_anext (var_data, &extra);\n\t\t\tchar *type = NULL;\n\t\t\textra = sdb_anext (extra, &type);\n\t\t\tst64 offset = 0;\n\t\t\tif (*kind != 'r') {\n\t\t\t\toffset = strtol (extra, NULL, 10);\n\t\t\t}\n\t\t\tif (*kind == 'g') { /* global, fixed addr TODO add size to variables? */\n\t\t\t\tchar *global_name = r_str_newf (\"global_%s\", var_name);\n\t\t\t\tr_flag_unset_off (flags, offset);\n\t\t\t\tr_flag_set_next (flags, global_name, offset, 4);\n\t\t\t\tfree (global_name);\n\t\t\t} else if (*kind == 's' && fcn) {\n\t\t\t\tr_anal_function_set_var (fcn, offset - fcn->maxstack, *kind, type, 4, false, var_name);\n\t\t\t} else if (*kind == 'r' && fcn) {\n\t\t\t\tRRegItem *i = r_reg_get (anal->reg, extra, -1);\n\t\t\t\tif (!i) {\n\t\t\t\t\tgoto loop_end;\n\t\t\t\t}\n\t\t\t\tr_anal_function_set_var (fcn, i->index, *kind, type, 4, false, var_name);\n\t\t\t} else if (fcn) { /* kind == 'b' */\n\t\t\t\tr_anal_function_set_var (fcn, offset - fcn->bp_off, *kind, type, 4, false, var_name);\n\t\t\t}\n\t\t\tfree (var_key);\n\t\t\tfree (var_data);\n\t\tloop_end:\n\t\t\tsdb_aforeach_next (var_name);\n\t\t}\n\t\tfree (var_names_key);\n\t\tfree (vars);\n\t}\n\tls_free (sdb_list);\n}\n", "/* radare - LGPL - Copyright 2012-2018 - pancake, Fedor Sakharov */\n\n#define D0 if(1)\n#define D1 if(1)\n\n#include <errno.h>\n\n#define DWARF_DUMP 0\n\n#if DWARF_DUMP\n#define DBGFD stdout\n#else\n#define DBGFD NULL\n#endif\n\n#include <r_bin.h>\n#include <r_bin_dwarf.h>\n#include <r_core.h>\n\n#define STANDARD_OPERAND_COUNT_DWARF2 9\n#define STANDARD_OPERAND_COUNT_DWARF3 12\n#define R_BIN_DWARF_INFO 1\n\n// endianness setting global\nstatic bool big_end = false;\n\n/* This macro seems bad regarding to endianess XXX, use only for single byte */\n#define READ(buf, type)                                             \\\n\t(((buf) + sizeof (type) < buf_end) ? *((type *)(buf)) : 0); \\\n\t(buf) += sizeof (type)\n#define READ8(buf)                                                \\\n\t(((buf) + sizeof (ut8) < buf_end) ? ((ut8 *)buf)[0] : 0); \\\n\t(buf) += sizeof (ut8)\n#define READ16(buf)                                                            \\\n\t(((buf) + sizeof (ut16) < buf_end) ? r_read_ble16 (buf, big_end) : 0); \\\n\t(buf) += sizeof (ut16)\n#define READ32(buf)                                                            \\\n\t(((buf) + sizeof (ut32) < buf_end) ? r_read_ble32 (buf, big_end) : 0); \\\n\t(buf) += sizeof (ut32)\n#define READ64(buf)                                                            \\\n\t(((buf) + sizeof (ut64) < buf_end) ? r_read_ble64 (buf, big_end) : 0); \\\n\t(buf) += sizeof (ut64)\n\nstatic const char *dwarf_tag_name_encodings[] = {\n\t[DW_TAG_null_entry] = \"DW_TAG_null_entry\",\n\t[DW_TAG_array_type] = \"DW_TAG_array_type\",\n\t[DW_TAG_class_type] = \"DW_TAG_class_type\",\n\t[DW_TAG_entry_point] = \"DW_TAG_entry_point\",\n\t[DW_TAG_enumeration_type] = \"DW_TAG_enumeration_type\",\n\t[DW_TAG_formal_parameter] = \"DW_TAG_formal_parameter\",\n\t[DW_TAG_imported_declaration] = \"DW_TAG_imported_declaration\",\n\t[DW_TAG_label] = \"DW_TAG_label\",\n\t[DW_TAG_lexical_block] = \"DW_TAG_lexical_block\",\n\t[DW_TAG_member] = \"DW_TAG_member\",\n\t[DW_TAG_pointer_type] = \"DW_TAG_pointer_type\",\n\t[DW_TAG_reference_type] = \"DW_TAG_reference_type\",\n\t[DW_TAG_compile_unit] = \"DW_TAG_compile_unit\",\n\t[DW_TAG_string_type] = \"DW_TAG_string_type\",\n\t[DW_TAG_structure_type] = \"DW_TAG_structure_type\",\n\t[DW_TAG_subroutine_type] = \"DW_TAG_subroutine_type\",\n\t[DW_TAG_typedef] = \"DW_TAG_typedef\",\n\t[DW_TAG_union_type] = \"DW_TAG_union_type\",\n\t[DW_TAG_unspecified_parameters] = \"DW_TAG_unspecified_parameters\",\n\t[DW_TAG_variant] = \"DW_TAG_variant\",\n\t[DW_TAG_common_block] = \"DW_TAG_common_block\",\n\t[DW_TAG_common_inclusion] = \"DW_TAG_common_inclusion\",\n\t[DW_TAG_inheritance] = \"DW_TAG_inheritance\",\n\t[DW_TAG_inlined_subroutine] = \"DW_TAG_inlined_subroutine\",\n\t[DW_TAG_module] = \"DW_TAG_module\",\n\t[DW_TAG_ptr_to_member_type] = \"DW_TAG_ptr_to_member_type\",\n\t[DW_TAG_set_type] = \"DW_TAG_set_type\",\n\t[DW_TAG_subrange_type] = \"DW_TAG_subrange_type\",\n\t[DW_TAG_with_stmt] = \"DW_TAG_with_stmt\",\n\t[DW_TAG_access_declaration] = \"DW_TAG_access_declaration\",\n\t[DW_TAG_base_type] = \"DW_TAG_base_type\",\n\t[DW_TAG_catch_block] = \"DW_TAG_catch_block\",\n\t[DW_TAG_const_type] = \"DW_TAG_const_type\",\n\t[DW_TAG_constant] = \"DW_TAG_constant\",\n\t[DW_TAG_enumerator] = \"DW_TAG_enumerator\",\n\t[DW_TAG_file_type] = \"DW_TAG_file_type\",\n\t[DW_TAG_friend] = \"DW_TAG_friend\",\n\t[DW_TAG_namelist] = \"DW_TAG_namelist\",\n\t[DW_TAG_namelist_item] = \"DW_TAG_namelist_item\",\n\t[DW_TAG_packed_type] = \"DW_TAG_packed_type\",\n\t[DW_TAG_subprogram] = \"DW_TAG_subprogram\",\n\t[DW_TAG_template_type_param] = \"DW_TAG_template_type_param\",\n\t[DW_TAG_template_value_param] = \"DW_TAG_template_value_param\",\n\t[DW_TAG_thrown_type] = \"DW_TAG_thrown_type\",\n\t[DW_TAG_try_block] = \"DW_TAG_try_block\",\n\t[DW_TAG_variant_part] = \"DW_TAG_variant_part\",\n\t[DW_TAG_variable] = \"DW_TAG_variable\",\n\t[DW_TAG_volatile_type] = \"DW_TAG_volatile_type\",\n\t[DW_TAG_dwarf_procedure] = \"DW_TAG_dwarf_procedure\",\n\t[DW_TAG_restrict_type] = \"DW_TAG_restrict_type\",\n\t[DW_TAG_interface_type] = \"DW_TAG_interface_type\",\n\t[DW_TAG_namespace] = \"DW_TAG_namespace\",\n\t[DW_TAG_imported_module] = \"DW_TAG_imported_module\",\n\t[DW_TAG_unspecified_type] = \"DW_TAG_unspecified_type\",\n\t[DW_TAG_partial_unit] = \"DW_TAG_partial_unit\",\n\t[DW_TAG_imported_unit] = \"DW_TAG_imported_unit\",\n\t[DW_TAG_mutable_type] = \"DW_TAG_mutable_type\",\n\t[DW_TAG_condition] = \"DW_TAG_condition\",\n\t[DW_TAG_shared_type] = \"DW_TAG_shared_type\",\n\t[DW_TAG_type_unit] = \"DW_TAG_type_unit\",\n\t[DW_TAG_rvalue_reference_type] = \"DW_TAG_rvalue_reference_type\",\n\t[DW_TAG_template_alias] = \"DW_TAG_template_alias\",\n\t[DW_TAG_LAST] = \"DW_TAG_LAST\",\n};\n\nstatic const char *dwarf_attr_encodings[] = {\n\t[DW_AT_sibling] = \"DW_AT_siblings\",\n\t[DW_AT_location] = \"DW_AT_location\",\n\t[DW_AT_name] = \"DW_AT_name\",\n\t[DW_AT_ordering] = \"DW_AT_ordering\",\n\t[DW_AT_byte_size] = \"DW_AT_byte_size\",\n\t[DW_AT_bit_size] = \"DW_AT_bit_size\",\n\t[DW_AT_stmt_list] = \"DW_AT_stmt_list\",\n\t[DW_AT_low_pc] = \"DW_AT_low_pc\",\n\t[DW_AT_high_pc] = \"DW_AT_high_pc\",\n\t[DW_AT_language] = \"DW_AT_language\",\n\t[DW_AT_discr] = \"DW_AT_discr\",\n\t[DW_AT_discr_value] = \"DW_AT_discr_value\",\n\t[DW_AT_visibility] = \"DW_AT_visibility\",\n\t[DW_AT_import] = \"DW_AT_import\",\n\t[DW_AT_string_length] = \"DW_AT_string_length\",\n\t[DW_AT_common_reference] = \"DW_AT_common_reference\",\n\t[DW_AT_comp_dir] = \"DW_AT_comp_dir\",\n\t[DW_AT_const_value] = \"DW_AT_const_value\",\n\t[DW_AT_containing_type] = \"DW_AT_containing_type\",\n\t[DW_AT_default_value] = \"DW_AT_default_value\",\n\t[DW_AT_inline] = \"DW_AT_inline\",\n\t[DW_AT_is_optional] = \"DW_AT_is_optional\",\n\t[DW_AT_lower_bound] = \"DW_AT_lower_bound\",\n\t[DW_AT_producer] = \"DW_AT_producer\",\n\t[DW_AT_prototyped] = \"DW_AT_prototyped\",\n\t[DW_AT_return_addr] = \"DW_AT_return_addr\",\n\t[DW_AT_start_scope] = \"DW_AT_start_scope\",\n\t[DW_AT_stride_size] = \"DW_AT_stride_size\",\n\t[DW_AT_upper_bound] = \"DW_AT_upper_bound\",\n\t[DW_AT_abstract_origin] = \"DW_AT_abstract_origin\",\n\t[DW_AT_accessibility] = \"DW_AT_accessibility\",\n\t[DW_AT_address_class] = \"DW_AT_address_class\",\n\t[DW_AT_artificial] = \"DW_AT_artificial\",\n\t[DW_AT_base_types] = \"DW_AT_base_types\",\n\t[DW_AT_calling_convention] = \"DW_AT_calling_convention\",\n\t[DW_AT_count] = \"DW_AT_count\",\n\t[DW_AT_data_member_location] = \"DW_AT_data_member_location\",\n\t[DW_AT_decl_column] = \"DW_AT_decl_column\",\n\t[DW_AT_decl_file] = \"DW_AT_decl_file\",\n\t[DW_AT_decl_line] = \"DW_AT_decl_line\",\n\t[DW_AT_declaration] = \"DW_AT_declaration\",\n\t[DW_AT_discr_list] = \"DW_AT_discr_list\",\n\t[DW_AT_encoding] = \"DW_AT_encoding\",\n\t[DW_AT_external] = \"DW_AT_external\",\n\t[DW_AT_frame_base] = \"DW_AT_frame_base\",\n\t[DW_AT_friend] = \"DW_AT_friend\",\n\t[DW_AT_identifier_case] = \"DW_AT_identifier_case\",\n\t[DW_AT_macro_info] = \"DW_AT_macro_info\",\n\t[DW_AT_namelist_item] = \"DW_AT_namelist_item\",\n\t[DW_AT_priority] = \"DW_AT_priority\",\n\t[DW_AT_segment] = \"DW_AT_segment\",\n\t[DW_AT_specification] = \"DW_AT_specification\",\n\t[DW_AT_static_link] = \"DW_AT_static_link\",\n\t[DW_AT_type] = \"DW_AT_type\",\n\t[DW_AT_use_location] = \"DW_AT_use_location\",\n\t[DW_AT_variable_parameter] = \"DW_AT_variable_parameter\",\n\t[DW_AT_virtuality] = \"DW_AT_virtuality\",\n\t[DW_AT_vtable_elem_location] = \"DW_AT_vtable_elem_location\",\n\t[DW_AT_allocated] = \"DW_AT_allocated\",\n\t[DW_AT_associated] = \"DW_AT_associated\",\n\t[DW_AT_data_location] = \"DW_AT_data_location\",\n\t[DW_AT_byte_stride] = \"DW_AT_byte_stride\",\n\t[DW_AT_entry_pc] = \"DW_AT_entry_pc\",\n\t[DW_AT_use_UTF8] = \"DW_AT_use_UTF8\",\n\t[DW_AT_extension] = \"DW_AT_extension\",\n\t[DW_AT_ranges] = \"DW_AT_ranges\",\n\t[DW_AT_trampoline] = \"DW_AT_trampoline\",\n\t[DW_AT_call_column] = \"DW_AT_call_column\",\n\t[DW_AT_call_file] = \"DW_AT_call_file\",\n\t[DW_AT_call_line] = \"DW_AT_call_line\",\n\t[DW_AT_description] = \"DW_AT_description\",\n\t[DW_AT_binary_scale] = \"DW_AT_binary_scale\",\n\t[DW_AT_decimal_scale] = \"DW_AT_decimal_scale\",\n\t[DW_AT_small] = \"DW_AT_small\",\n\t[DW_AT_decimal_sign] = \"DW_AT_decimal_sign\",\n\t[DW_AT_digit_count] = \"DW_AT_digit_count\",\n\t[DW_AT_picture_string] = \"DW_AT_picture_string\",\n\t[DW_AT_mutable] = \"DW_AT_mutable\",\n\t[DW_AT_threads_scaled] = \"DW_AT_threads_scaled\",\n\t[DW_AT_explicit] = \"DW_AT_explicit\",\n\t[DW_AT_object_pointer] = \"DW_AT_object_pointer\",\n\t[DW_AT_endianity] = \"DW_AT_endianity\",\n\t[DW_AT_elemental] = \"DW_AT_elemental\",\n\t[DW_AT_pure] = \"DW_AT_pure\",\n\t[DW_AT_recursive] = \"DW_AT_recursive\",\n\t[DW_AT_signature] = \"DW_AT_signature\",\n\t[DW_AT_main_subprogram] = \"DW_AT_main_subprogram\",\n\t[DW_AT_data_bit_offset] = \"DW_AT_data_big_offset\",\n\t[DW_AT_const_expr] = \"DW_AT_const_expr\",\n\t[DW_AT_enum_class] = \"DW_AT_enum_class\",\n\t[DW_AT_linkage_name] = \"DW_AT_linkage_name\",\n\t[DW_AT_string_length_bit_size] = \"DW_AT_string_length_bit_size\",\n\t[DW_AT_string_length_byte_size] = \"DW_AT_string_length_byte_size\",\n\t[DW_AT_rank] = \"DW_AT_rank\",\n\t[DW_AT_str_offsets_base] = \"DW_AT_str_offsets_base\",\n\t[DW_AT_addr_base] = \"DW_AT_addr_base\",\n\t[DW_AT_rnglists_base] = \"DW_AT_rnglists_base\",\n\t[DW_AT_dwo_name] = \"DW_AT_dwo_name\",\n\t[DW_AT_reference] = \"DW_AT_reference\",\n\t[DW_AT_rvalue_reference] = \"DW_AT_rvalue_reference\",\n\t[DW_AT_macros] = \"DW_AT_macros\",\n\t[DW_AT_call_all_calls] = \"DW_AT_call_all_calls\",\n\t[DW_AT_call_all_source_calls] = \"DW_AT_call_all_source_calls\",\n\t[DW_AT_call_all_tail_calls] = \"DW_AT_call_all_tail_calls\",\n\t[DW_AT_call_return_pc] = \"DW_AT_call_return_pc\",\n\t[DW_AT_call_value] = \"DW_AT_call_value\",\n\t[DW_AT_call_origin] = \"DW_AT_call_origin\",\n\t[DW_AT_call_parameter] = \"DW_AT_call_parameter\",\n\t[DW_AT_call_pc] = \"DW_AT_call_pc\",\n\t[DW_AT_call_tail_call] = \"DW_AT_call_tail_call\",\n\t[DW_AT_call_target] = \"DW_AT_call_target\",\n\t[DW_AT_call_target_clobbered] = \"DW_AT_call_target_clobbered\",\n\t[DW_AT_call_data_location] = \"DW_AT_call_data_location\",\n\t[DW_AT_call_data_value] = \"DW_AT_call_data_value\",\n\t[DW_AT_noreturn] = \"DW_AT_noreturn\",\n\t[DW_AT_alignment] = \"DW_AT_alignment\",\n\t[DW_AT_export_symbols] = \"DW_AT_export_symbols\",\n\t[DW_AT_deleted] = \"DW_AT_deleted\",\n\t[DW_AT_defaulted] = \"DW_AT_defaulted\",\n\t[DW_AT_loclists_base] = \"DW_AT_loclists_base\",\n\n\t[DW_AT_lo_user] = \"DW_AT_lo_user\",\n\t[DW_AT_MIPS_linkage_name] = \"DW_AT_MIPS_linkage_name\",\n\t[DW_AT_GNU_call_site_value] = \"DW_AT_GNU_call_site_value\",\n\t[DW_AT_GNU_call_site_data_value] = \"DW_AT_GNU_call_site_data_value\",\n\t[DW_AT_GNU_call_site_target] = \"DW_AT_GNU_call_site_target\",\n\t[DW_AT_GNU_call_site_target_clobbered] = \"DW_AT_GNU_call_site_target_clobbered\",\n\t[DW_AT_GNU_tail_call] = \"DW_AT_GNU_tail_call\",\n\t[DW_AT_GNU_all_tail_call_sites] = \"DW_AT_GNU_all_tail_call_sites\",\n\t[DW_AT_GNU_all_call_sites] = \"DW_AT_GNU_all_call_sites\",\n\t[DW_AT_GNU_all_source_call_sites] = \"DW_AT_GNU_all_source_call_sites\",\n\t[DW_AT_GNU_macros] = \"DW_AT_GNU_macros\",\n\t[DW_AT_GNU_deleted] = \"DW_AT_GNU_deleted\",\n\t[DW_AT_GNU_dwo_name] = \"DW_AT_GNU_dwo_name\",\n\t[DW_AT_GNU_dwo_id] = \"DW_AT_GNU_dwo_id\",\n\t[DW_AT_GNU_ranges_base] = \"DW_AT_GNU_ranges_base\",\n\t[DW_AT_GNU_addr_base] = \"DW_AT_GNU_addr_base\",\n\t[DW_AT_GNU_pubnames] = \"DW_AT_GNU_pubnames\",\n\t[DW_AT_GNU_pubtypes] = \"DW_AT_GNU_pubtypes\",\n\t[DW_AT_hi_user] = \"DW_AT_hi_user\",\n};\n\nstatic const char *dwarf_attr_form_encodings[] = {\n\t[DW_FORM_addr] = \"DW_FORM_addr\",\n\t[DW_FORM_block2] = \"DW_FORM_block2\",\n\t[DW_FORM_block4] = \"DW_FORM_block4\",\n\t[DW_FORM_data2] = \"DW_FORM_data2\",\n\t[DW_FORM_data4] = \"DW_FORM_data4\",\n\t[DW_FORM_data8] = \"DW_FORM_data8\",\n\t[DW_FORM_string] = \"DW_FORM_string\",\n\t[DW_FORM_block] = \"DW_FORM_block\",\n\t[DW_FORM_block1] = \"DW_FORM_block1\",\n\t[DW_FORM_data1] = \"DW_FORM_data1\",\n\t[DW_FORM_flag] = \"DW_FORM_flag\",\n\t[DW_FORM_sdata] = \"DW_FORM_sdata\",\n\t[DW_FORM_strp] = \"DW_FORM_strp\",\n\t[DW_FORM_udata] = \"DW_FORM_udata\",\n\t[DW_FORM_ref_addr] = \"DW_FORM_ref_addr\",\n\t[DW_FORM_ref1] = \"DW_FORM_ref1\",\n\t[DW_FORM_ref2] = \"DW_FORM_ref2\",\n\t[DW_FORM_ref4] = \"DW_FORM_ref4\",\n\t[DW_FORM_ref8] = \"DW_FORM_ref8\",\n\t[DW_FORM_ref_udata] = \"DW_FORM_ref_udata\",\n\t[DW_FORM_indirect] = \"DW_FORM_indirect\",\n\t[DW_FORM_sec_offset] = \"DW_FORM_sec_offset\",\n\t[DW_FORM_exprloc] = \"DW_FORM_exprloc\",\n\t[DW_FORM_flag_present] = \"DW_FORM_flag_present\",\n\t[DW_FORM_strx] = \"DW_FORM_strx\",\n\t[DW_FORM_addrx] = \"DW_FORM_addrx\",\n\t[DW_FORM_ref_sup4] = \"DW_FORM_ref_sup4\",\n\t[DW_FORM_strp_sup] = \"DW_FORM_strp_sup\",\n\t[DW_FORM_data16] = \"DW_FORM_data16\",\n\t[DW_FORM_line_ptr] = \"DW_FORM_line_ptr\",\n\t[DW_FORM_ref_sig8] = \"DW_FORM_ref_sig8\",\n\t[DW_FORM_implicit_const] = \"DW_FORM_implicit_const\",\n\t[DW_FORM_loclistx] = \"DW_FORM_loclistx\",\n\t[DW_FORM_rnglistx] = \"DW_FORM_rnglistx\",\n\t[DW_FORM_ref_sup8] = \"DW_FORM_ref_sup8\",\n\t[DW_FORM_strx1] = \"DW_FORM_strx1\",\n\t[DW_FORM_strx2] = \"DW_FORM_strx2\",\n\t[DW_FORM_strx3] = \"DW_FORM_strx3\",\n\t[DW_FORM_strx4] = \"DW_FORM_strx4\",\n\t[DW_FORM_addrx1] = \"DW_FORM_addrx1\",\n\t[DW_FORM_addrx2] = \"DW_FORM_addrx2\",\n\t[DW_FORM_addrx3] = \"DW_FORM_addrx3\",\n\t[DW_FORM_addrx4] = \"DW_FORM_addrx4\",\n};\n\nstatic const char *dwarf_langs[] = {\n\t[DW_LANG_C89] = \"C89\",\n\t[DW_LANG_C] = \"C\",\n\t[DW_LANG_Ada83] = \"Ada83\",\n\t[DW_LANG_C_plus_plus] = \"C++\",\n\t[DW_LANG_Cobol74] = \"Cobol74\",\n\t[DW_LANG_Cobol85] = \"Cobol85\",\n\t[DW_LANG_Fortran77] = \"Fortran77\",\n\t[DW_LANG_Fortran90] = \"Fortran90\",\n\t[DW_LANG_Pascal83] = \"Pascal83\",\n\t[DW_LANG_Modula2] = \"Modula2\",\n\t[DW_LANG_Java] = \"Java\",\n\t[DW_LANG_C99] = \"C99\",\n\t[DW_LANG_Ada95] = \"Ada95\",\n\t[DW_LANG_Fortran95] = \"Fortran95\",\n\t[DW_LANG_PLI] = \"PLI\",\n\t[DW_LANG_ObjC] = \"ObjC\",\n\t[DW_LANG_ObjC_plus_plus] = \"ObjC_plus_plus\",\n\t[DW_LANG_UPC] = \"UPC\",\n\t[DW_LANG_D] = \"D\",\n\t[DW_LANG_Python] = \"Python\",\n\t[DW_LANG_Rust] = \"Rust\",\n\t[DW_LANG_C11] = \"C11\",\n\t[DW_LANG_Swift] = \"Swift\",\n\t[DW_LANG_Julia] = \"Julia\",\n\t[DW_LANG_Dylan] = \"Dylan\",\n\t[DW_LANG_C_plus_plus_14] = \"C++14\",\n\t[DW_LANG_Fortran03] = \"Fortran03\",\n\t[DW_LANG_Fortran08] = \"Fortran08\"\n};\n\nstatic const char *dwarf_unit_types[] = {\n\t[DW_UT_compile] = \"DW_UT_compile\",\n\t[DW_UT_type] = \"DW_UT_type\",\n\t[DW_UT_partial] = \"DW_UT_partial\",\n\t[DW_UT_skeleton] = \"DW_UT_skeleton\",\n\t[DW_UT_split_compile] = \"DW_UT_split_compile\",\n\t[DW_UT_split_type] = \"DW_UT_split_type\",\n\t[DW_UT_lo_user] = \"DW_UT_lo_user\",\n\t[DW_UT_hi_user] = \"DW_UT_hi_user\",\n};\n\nstatic int abbrev_cmp(const void *a, const void *b) {\n\tconst RBinDwarfAbbrevDecl *first = a;\n\tconst RBinDwarfAbbrevDecl *second = b;\n\n\tif (first->offset > second->offset) {\n\t\treturn 1;\n\t} else if (first->offset < second->offset) {\n\t\treturn -1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic inline bool is_printable_attr(ut64 attr_code) {\n\treturn (attr_code >= DW_AT_sibling && attr_code <= DW_AT_loclists_base) ||\n\t\t\tattr_code == DW_AT_MIPS_linkage_name ||\n\t\t\t(attr_code >= DW_AT_GNU_call_site_value && attr_code <= DW_AT_GNU_deleted) ||\n\t\t\t(attr_code >= DW_AT_GNU_dwo_name && attr_code <= DW_AT_GNU_pubtypes);\n}\n\nstatic inline bool is_printable_form(ut64 form_code) {\n\treturn form_code >= DW_FORM_addr && form_code <= DW_FORM_addrx4;\n}\n\nstatic inline bool is_printable_tag(ut64 attr_code) {\n\treturn attr_code <= DW_TAG_LAST;\n}\n\nstatic inline bool is_printable_unit_type(ut64 unit_type) {\n\treturn unit_type > 0 && unit_type <= DW_UT_split_type;\n}\n\n/**\n * @brief Reads 64/32 bit unsigned based on format\n *\n * @param is_64bit Format of the comp unit\n * @param buf Pointer to the buffer to read from, to update after read\n * @param buf_end To check the boundary /for READ macro/\n * @return ut64 Read value\n */\nstatic inline ut64 dwarf_read_offset(bool is_64bit, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tif (is_64bit) {\n\t\tresult = READ64 (*buf);\n\t} else {\n\t\tresult = (ut64)READ32 (*buf);\n\t}\n\treturn result;\n}\n\nstatic inline ut64 dwarf_read_address(size_t size, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tswitch (size) {\n\tcase 2: result = READ16 (*buf); break;\n\tcase 4: result = READ32 (*buf); break;\n\tcase 8: result = READ64 (*buf); break;\n\tdefault:\n\t\tresult = 0;\n\t\t*buf += size;\n\t\teprintf (\"Weird dwarf address size: %zu.\", size);\n\t}\n\treturn result;\n}\n\nstatic int add_sdb_include_dir(Sdb *s, const char *incl, int idx) {\n\tif (!s || !incl) {\n\t\treturn false;\n\t}\n\treturn sdb_array_set (s, \"includedirs\", idx, incl, 0);\n}\n\nstatic void line_header_fini(RBinDwarfLineHeader *hdr) {\n\tif (hdr) {\n\t\tsize_t i;\n\n\t\tfor (i = 0; i < hdr->file_names_count; i ++) {\n\t\t\tfree (hdr->file_names[i].name);\n\t\t}\n\n\t\tfree (hdr->std_opcode_lengths);\n\t\tfree (hdr->file_names);\n\t}\n}\n\n// Parses source file header of DWARF version <= 4\nstatic const ut8 *parse_line_header_source(RBinFile *bf, const ut8 *buf, const ut8 *buf_end,\n\tRBinDwarfLineHeader *hdr, Sdb *sdb, int mode, PrintfCallback print) {\n\tint i = 0;\n\tsize_t count;\n\tconst ut8 *tmp_buf = NULL;\n\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\" The Directory Table:\\n\");\n\t}\n\twhile (buf + 1 < buf_end) {\n\t\tsize_t maxlen = R_MIN ((size_t) (buf_end - buf) - 1, 0xfff);\n\t\tsize_t len = r_str_nlen ((const char *)buf, maxlen);\n\t\tchar *str = r_str_ndup ((const char *)buf, len);\n\t\tif (len < 1 || len >= 0xfff || !str) {\n\t\t\tbuf += 1;\n\t\t\tfree (str);\n\t\t\tbreak;\n\t\t}\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"  %d     %s\\n\", i + 1, str);\n\t\t}\n\t\tadd_sdb_include_dir (sdb, str, i);\n\t\tfree (str);\n\t\ti++;\n\t\tbuf += len + 1;\n\t}\n\n\ttmp_buf = buf;\n\tcount = 0;\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"\\n\");\n\t\tprint (\" The File Name Table:\\n\");\n\t\tprint (\"  Entry Dir     Time      Size       Name\\n\");\n\t}\n\tint entry_index = 1; // used for printing information\n\n\tfor (i = 0; i < 2; i++) {\n\t\twhile (buf + 1 < buf_end) {\n\t\t\tconst char *filename = (const char *)buf;\n\t\t\tsize_t maxlen = R_MIN ((size_t) (buf_end - buf - 1), 0xfff);\n\t\t\tut64 id_idx, mod_time, file_len;\n\t\t\tsize_t len = r_str_nlen (filename, maxlen);\n\n\t\t\tif (!len) {\n\t\t\t\tbuf++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf += len + 1;\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &id_idx, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &mod_time, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &file_len, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tif (i) {\n\t\t\t\tchar *include_dir = NULL, *comp_dir = NULL, *pinclude_dir = NULL;\n\t\t\t\tif (id_idx > 0) {\n\t\t\t\t\tinclude_dir = pinclude_dir = sdb_array_get (sdb, \"includedirs\", id_idx - 1, 0);\n\t\t\t\t\tif (include_dir && include_dir[0] != '/') {\n\t\t\t\t\t\tcomp_dir = sdb_get (bf->sdb_addrinfo, \"DW_AT_comp_dir\", 0);\n\t\t\t\t\t\tif (comp_dir) {\n\t\t\t\t\t\t\tinclude_dir = r_str_newf(\"%s/%s/\", comp_dir, include_dir);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tinclude_dir = pinclude_dir = sdb_get (bf->sdb_addrinfo, \"DW_AT_comp_dir\", 0);\n\t\t\t\t\tif (!include_dir) {\n\t\t\t\t\t\tinclude_dir = \"./\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (hdr->file_names) {\n\t\t\t\t\thdr->file_names[count].name = r_str_newf(\"%s/%s\", r_str_get (include_dir), filename);\n\t\t\t\t\thdr->file_names[count].id_idx = id_idx;\n\t\t\t\t\thdr->file_names[count].mod_time = mod_time;\n\t\t\t\t\thdr->file_names[count].file_len = file_len;\n\t\t\t\t}\n\t\t\t\tif (comp_dir) {\n\t\t\t\t\tR_FREE (include_dir);\n\t\t\t\t\tR_FREE (comp_dir);\n\t\t\t\t}\n\t\t\t\tR_FREE (pinclude_dir);\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (mode == R_MODE_PRINT && i) {\n\t\t\t\tprint (\"  %d     %\" PFMT64d \"       %\" PFMT64d \"         %\" PFMT64d \"          %s\\n\", entry_index++, id_idx, mod_time, file_len, filename);\n\t\t\t}\n\t\t}\n\t\tif (i == 0) {\n\t\t\tif (count > 0) {\n\t\t\t\thdr->file_names = calloc (sizeof (file_entry), count);\n\t\t\t} else {\n\t\t\t\thdr->file_names = NULL;\n\t\t\t}\n\t\t\thdr->file_names_count = count;\n\t\t\tbuf = tmp_buf;\n\t\t\tcount = 0;\n\t\t}\n\t}\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"\\n\");\n\t}\n\nbeach:\n\tsdb_free (sdb);\n\n\treturn buf;\n}\n// TODO DWARF 5 line header parsing, very different from ver. 4\n// Because this function needs ability to parse a lot of FORMS just like debug info\n// I'll complete this function after completing debug_info parsing and merging\n// for the meanwhile I am skipping the space.\nstatic const ut8 *parse_line_header_source_dwarf5(RBinFile *bf, const ut8 *buf, const ut8 *buf_end,\n\tRBinDwarfLineHeader *hdr, Sdb *sdb, int mode) {\n// \tint i = 0;\n// \tsize_t count;\n// \tconst ut8 *tmp_buf = NULL;\n\n// \tut8 dir_entry_count = READ8 (buf);\n// \t// uleb128 pairs\n// \tut8 dir_count = READ8 (buf);\n\n// \t// dirs\n\n// \tut8 file_entry_count = READ8 (buf);\n// \t// uleb128 pairs\n// \tut8 file_count = READ8 (buf);\n// \t// file names\n\n// beach:\n// \tsdb_free (sdb);\n\n\treturn NULL;\n}\n\nstatic const ut8 *parse_line_header (\n\tRBinFile *bf, const ut8 *buf, const ut8 *buf_end,\n\tRBinDwarfLineHeader *hdr, int mode, PrintfCallback print) {\n\n\tr_return_val_if_fail(hdr && bf && buf, NULL);\n\n\thdr->is_64bit = false;\n\thdr->unit_length = READ32 (buf);\n\n\tif (hdr->unit_length == DWARF_INIT_LEN_64) {\n\t\thdr->unit_length = READ64 (buf);\n\t\thdr->is_64bit = true;\n\t}\n\n\thdr->version = READ16 (buf);\n\n\tif (hdr->version == 5) {\n\t\thdr->address_size = READ8 (buf);\n\t\thdr->segment_selector_size = READ8 (buf);\n\t}\n\n\thdr->header_length = dwarf_read_offset(hdr->is_64bit, &buf, buf_end);\n\n\tconst ut8 *tmp_buf = buf; // So I can skip parsing DWARF 5 headers for now\n\n\tif (buf_end - buf < 8) {\n\t\treturn NULL;\n\t}\n\thdr->min_inst_len = READ8 (buf);\n\tif (hdr->version >= 4) {\n\t\thdr->max_ops_per_inst = READ8 (buf);\n\t}\n\thdr->default_is_stmt = READ8 (buf);\n\thdr->line_base = READ (buf, int8_t); // signed\n\thdr->line_range = READ8 (buf);\n\thdr->opcode_base = READ8 (buf);\n\n\thdr->file_names_count = 0;\n\thdr->file_names = NULL;\n\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\" Header information:\\n\");\n\t\tprint (\"  Length:                             %\" PFMT64u \"\\n\", hdr->unit_length);\n\t\tprint (\"  DWARF Version:                      %d\\n\", hdr->version);\n\t\tprint (\"  Header Length:                      %\" PFMT64d \"\\n\", hdr->header_length);\n\t\tprint (\"  Minimum Instruction Length:         %d\\n\", hdr->min_inst_len);\n\t\tprint (\"  Maximum Operations per Instruction: %d\\n\", hdr->max_ops_per_inst);\n\t\tprint (\"  Initial value of 'is_stmt':         %d\\n\", hdr->default_is_stmt);\n\t\tprint (\"  Line Base:                          %d\\n\", hdr->line_base);\n\t\tprint (\"  Line Range:                         %d\\n\", hdr->line_range);\n\t\tprint (\"  Opcode Base:                        %d\\n\\n\", hdr->opcode_base);\n\t}\n\n\tif (hdr->opcode_base > 0) {\n\t\thdr->std_opcode_lengths = calloc (sizeof (ut8), hdr->opcode_base);\n\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\" Opcodes:\\n\");\n\t\t}\n\t\tsize_t i;\n\t\tfor (i = 1; i < hdr->opcode_base; i++) {\n\t\t\tif (buf + 2 > buf_end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thdr->std_opcode_lengths[i] = READ (buf, ut8);\n\t\t\tif (mode == R_MODE_PRINT) {\n\t\t\t\tprint (\"  Opcode %zu has %d arg\\n\", i, hdr->std_opcode_lengths[i]);\n\t\t\t}\n\t\t}\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"\\n\");\n\t\t}\n\t} else {\n\t\thdr->std_opcode_lengths = NULL;\n\t}\n\t// TODO finish parsing of source files out of DWARF 5 header\n\t// for now we skip\n\tif (hdr->version == 5) {\n\t\ttmp_buf += hdr->header_length;\n\t\treturn tmp_buf;\n\t}\n\n\tSdb *sdb = sdb_new (NULL, NULL, 0);\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\n\tif (hdr->version <= 4) {\n\t\tbuf = parse_line_header_source (bf, buf, buf_end, hdr, sdb, mode, print);\n\t} else { // because Version 5 source files are very different\n\t\tbuf = parse_line_header_source_dwarf5 (bf, buf, buf_end, hdr, sdb, mode);\n\t}\n\n\treturn buf;\n}\n\nstatic inline void add_sdb_addrline(Sdb *s, ut64 addr, const char *file, ut64 line, int mode, PrintfCallback print) {\n\tconst char *p;\n\tchar *fileline;\n\tchar offset[64];\n\tchar *offset_ptr;\n\n\tif (!s || !file) {\n\t\treturn;\n\t}\n\tp = r_str_rchr (file, NULL, '/');\n\tif (p) {\n\t\tp++;\n\t} else {\n\t\tp = file;\n\t}\n\t// includedirs and properly check full paths\n\tswitch (mode) {\n\tcase 1:\n\tcase 'r':\n\tcase '*':\n\t\tprint (\"CL %s:%d 0x%08\"PFMT64x\"\\n\", p, (int)line, addr);\n\t\tbreak;\n\t}\n#if 0\n\t/* THIS IS TOO SLOW */\n\tif (r_file_exists (file)) {\n\t\tp = file;\n\t}\n#else\n\tp = file;\n#endif\n\tfileline = r_str_newf (\"%s|%\"PFMT64d, p, line);\n\toffset_ptr = sdb_itoa (addr, offset, 16);\n\tsdb_add (s, offset_ptr, fileline, 0);\n\tsdb_add (s, fileline, offset_ptr, 0);\n\tfree (fileline);\n}\n\nstatic const ut8 *parse_ext_opcode(const RBin *bin, const ut8 *obuf,\n\tsize_t len, const RBinDwarfLineHeader *hdr,\n\tRBinDwarfSMRegisters *regs, int mode) {\n\n\tr_return_val_if_fail (bin && bin->cur && obuf && hdr && regs, NULL);\n\n\tPrintfCallback print = bin->cb_printf;\n\tconst ut8 *buf;\n\tconst ut8 *buf_end;\n\tut8 opcode;\n\tut64 addr;\n\tbuf = obuf;\n\tst64 op_len;\n\tRBinFile *binfile = bin->cur;\n\tRBinObject *o = binfile->o;\n\tut32 addr_size = o && o->info && o->info->bits ? o->info->bits / 8 : 4;\n\tconst char *filename;\n\n\tbuf_end = buf + len;\n\tbuf = r_leb128 (buf, len, &op_len);\n\tif (buf >= buf_end) {\n\t\treturn NULL;\n\t}\n\n\topcode = *buf++;\n\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"  Extended opcode %d: \", opcode);\n\t}\n\n\tswitch (opcode) {\n\tcase DW_LNE_end_sequence:\n\t\tregs->end_sequence = DWARF_TRUE;\n\n\t\tif (binfile && binfile->sdb_addrinfo && hdr->file_names) {\n\t\t\tint fnidx = regs->file - 1;\n\t\t\tif (fnidx >= 0 && fnidx < hdr->file_names_count) {\n\t\t\t\tadd_sdb_addrline(binfile->sdb_addrinfo, regs->address,\n\t\t\t\t\t\thdr->file_names[fnidx].name, regs->line, mode, print);\n\t\t\t}\n\t\t}\n\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"End of Sequence\\n\");\n\t\t}\n\t\tbreak;\n\tcase DW_LNE_set_address:\n\t\tif (addr_size == 8) {\n\t\t\taddr = READ64 (buf);\n\t\t} else {\n\t\t\taddr = READ32 (buf);\n\t\t}\n\t\tregs->address = addr;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set Address to 0x%\"PFMT64x\"\\n\", addr);\n\t\t}\n\t\tbreak;\n\tcase DW_LNE_define_file:\n\t\tfilename = (const char*)buf;\n\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"define_file\\n\");\n\t\t\tprint (\"filename %s\\n\", filename);\n\t\t}\n\n\t\tbuf += (strlen (filename) + 1);\n\t\tut64 dir_idx;\n\t\tut64 ignore;\n\t\tif (buf + 1 < buf_end) {\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &dir_idx, NULL);\n\t\t}\n\t\tif (buf + 1 < buf_end) {\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &ignore, NULL);\n\t\t}\n\t\tif (buf + 1 < buf_end) {\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &ignore, NULL);\n\t\t}\n\t\tbreak;\n\tcase DW_LNE_set_discriminator:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &addr, NULL);\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set Discriminator to %\"PFMT64d\"\\n\", addr);\n\t\t}\n\t\tregs->discriminator = addr;\n\t\tbreak;\n\tdefault:\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Unexpected ext opcode %d\\n\", opcode);\n\t\t}\n\t\tbuf = NULL;\n\t\tbreak;\n\t}\n\n\treturn buf;\n}\n\nstatic const ut8 *parse_spec_opcode(\n\tconst RBin *bin, const ut8 *obuf, size_t len,\n\tconst RBinDwarfLineHeader *hdr,\n\tRBinDwarfSMRegisters *regs,\n\tut8 opcode, int mode) {\n\n\tr_return_val_if_fail (bin && obuf && hdr && regs, NULL);\n\n\tPrintfCallback print = bin->cb_printf;\n\tRBinFile *binfile = bin->cur;\n\tconst ut8 *buf = obuf;\n\tut8 adj_opcode = 0;\n\tut64 advance_adr;\n\n\tadj_opcode = opcode - hdr->opcode_base;\n\tif (!hdr->line_range) {\n\t\t// line line-range information. move away\n\t\treturn NULL;\n\t}\n\tadvance_adr = (adj_opcode / hdr->line_range) * hdr->min_inst_len;\n\tregs->address += advance_adr;\n\tint line_increment =  hdr->line_base + (adj_opcode % hdr->line_range);\n\tregs->line += line_increment;\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"  Special opcode %d: \", adj_opcode);\n\t\tprint (\"advance Address by %\"PFMT64d\" to 0x%\"PFMT64x\" and Line by %d to %\"PFMT64d\"\\n\",\n\t\t\tadvance_adr, regs->address, line_increment, regs->line);\n\t}\n\tif (binfile && binfile->sdb_addrinfo && hdr->file_names) {\n\t\tint idx = regs->file -1;\n\t\tif (idx >= 0 && idx < hdr->file_names_count) {\n\t\t\tadd_sdb_addrline (binfile->sdb_addrinfo, regs->address,\n\t\t\t\t\thdr->file_names[idx].name,\n\t\t\t\t\tregs->line, mode, print);\n\t\t}\n\t}\n\tregs->basic_block = DWARF_FALSE;\n\tregs->prologue_end = DWARF_FALSE;\n\tregs->epilogue_begin = DWARF_FALSE;\n\tregs->discriminator = 0;\n\n\treturn buf;\n}\n\nstatic const ut8 *parse_std_opcode(\n\tconst RBin *bin, const ut8 *obuf, size_t len,\n\tconst RBinDwarfLineHeader *hdr, RBinDwarfSMRegisters *regs,\n\tut8 opcode, int mode) {\n\n\tr_return_val_if_fail (bin && bin->cur && obuf && hdr && regs, NULL);\n\n\tPrintfCallback print = bin->cb_printf;\n\tRBinFile *binfile = bin->cur;\n\tconst ut8* buf = obuf;\n\tconst ut8* buf_end = obuf + len;\n\tut64 addr = 0LL;\n\tst64 sbuf;\n\tut8 adj_opcode;\n\tut64 op_advance;\n\tut16 operand;\n\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"  \"); // formatting\n\t}\n\tswitch (opcode) {\n\tcase DW_LNS_copy:\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Copy\\n\");\n\t\t}\n\t\tif (binfile && binfile->sdb_addrinfo && hdr->file_names) {\n\t\t\tint fnidx = regs->file - 1;\n\t\t\tif (fnidx >= 0 && fnidx < hdr->file_names_count) {\n\t\t\t\tadd_sdb_addrline (binfile->sdb_addrinfo,\n\t\t\t\t\tregs->address,\n\t\t\t\t\thdr->file_names[fnidx].name,\n\t\t\t\t\tregs->line, mode, print);\n\t\t\t}\n\t\t}\n\t\tregs->basic_block = DWARF_FALSE;\n\t\tbreak;\n\tcase DW_LNS_advance_pc:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &addr, NULL);\n\t\tregs->address += addr * hdr->min_inst_len;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Advance PC by %\"PFMT64d\" to 0x%\"PFMT64x\"\\n\",\n\t\t\t\taddr * hdr->min_inst_len, regs->address);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_advance_line:\n\t\tbuf = r_leb128(buf, buf_end - buf, &sbuf);\n\t\tregs->line += sbuf;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Advance line by %\"PFMT64d\", to %\"PFMT64d\"\\n\", sbuf, regs->line);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_file:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &addr, NULL);\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Set file to %\"PFMT64d\"\\n\", addr);\n\t\t}\n\t\tregs->file = addr;\n\t\tbreak;\n\tcase DW_LNS_set_column:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &addr, NULL);\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Set column to %\"PFMT64d\"\\n\", addr);\n\t\t}\n\t\tregs->column = addr;\n\t\tbreak;\n\tcase DW_LNS_negate_stmt:\n\t\tregs->is_stmt = regs->is_stmt ? DWARF_FALSE : DWARF_TRUE;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Set is_stmt to %d\\n\", regs->is_stmt);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_basic_block:\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set_basic_block\\n\");\n\t\t}\n\t\tregs->basic_block = DWARF_TRUE;\n\t\tbreak;\n\tcase DW_LNS_const_add_pc:\n\t\tadj_opcode = 255 - hdr->opcode_base;\n\t\tif (hdr->line_range > 0) { // to dodge division by zero\n\t\t\top_advance = (adj_opcode / hdr->line_range) * hdr->min_inst_len;\n\t\t} else {\n\t\t\top_advance = 0;\n\t\t}\n\t\tregs->address += op_advance;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Advance PC by constant %\"PFMT64d\" to 0x%\"PFMT64x\"\\n\",\n\t\t\t\top_advance, regs->address);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_fixed_advance_pc:\n\t\toperand = READ16 (buf);\n\t\tregs->address += operand;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Fixed advance pc to %\"PFMT64d\"\\n\", regs->address);\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_prologue_end:\n\t\tregs->prologue_end = ~0;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set_prologue_end\\n\");\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_epilogue_begin:\n\t\tregs->epilogue_begin = ~0;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set_epilogue_begin\\n\");\n\t\t}\n\t\tbreak;\n\tcase DW_LNS_set_isa:\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &addr, NULL);\n\t\tregs->isa = addr;\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"set_isa\\n\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"Unexpected std opcode %d\\n\", opcode);\n\t\t}\n\t\tbreak;\n\t}\n\treturn buf;\n}\n\nstatic void set_regs_default(const RBinDwarfLineHeader *hdr, RBinDwarfSMRegisters *regs) {\n\tregs->address = 0;\n\tregs->file = 1;\n\tregs->line = 1;\n\tregs->column = 0;\n\tregs->is_stmt = hdr->default_is_stmt;\n\tregs->basic_block = DWARF_FALSE;\n\tregs->end_sequence = DWARF_FALSE;\n\tregs->prologue_end = DWARF_FALSE;\n\tregs->epilogue_begin = DWARF_FALSE;\n\tregs->isa = 0;\n}\n\n// Passing bin should be unnecessary (after we stop printing inside bin_dwarf)\nstatic size_t parse_opcodes(const RBin *bin, const ut8 *obuf,\n\t\tsize_t len, const RBinDwarfLineHeader *hdr,\n\t\tRBinDwarfSMRegisters *regs, int mode) {\n\tconst ut8 *buf, *buf_end;\n\tut8 opcode, ext_opcode;\n\n\tif (!bin || !obuf || len < 8) {\n\t\treturn 0;\n\t}\n\tbuf = obuf;\n\tbuf_end = obuf + len;\n\n\twhile (buf && buf + 1 < buf_end) {\n\t\topcode = *buf++;\n\t\tlen--;\n\t\tif (!opcode) {\n\t\t\text_opcode = *buf;\n\t\t\tbuf = parse_ext_opcode (bin, buf, len, hdr, regs, mode);\n\t\t\tif (!buf || ext_opcode == DW_LNE_end_sequence) {\n\t\t\t\tset_regs_default (hdr, regs); // end_sequence should reset regs to default\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (opcode >= hdr->opcode_base) {\n\t\t\tbuf = parse_spec_opcode (bin, buf, len, hdr, regs, opcode, mode);\n\t\t} else {\n\t\t\tbuf = parse_std_opcode (bin, buf, len, hdr, regs, opcode, mode);\n\t\t}\n\t\tlen = (size_t)(buf_end - buf);\n\t}\n\tif (mode == R_MODE_PRINT) {\n\t\tbin->cb_printf (\"\\n\"); // formatting of the output\n\t}\n\tif (!buf) {\n\t\treturn 0;\n\t}\n\treturn (size_t) (buf - obuf); // number of bytes we've moved by\n}\n\nstatic bool parse_line_raw(const RBin *a, const ut8 *obuf, ut64 len, int mode) {\n\tr_return_val_if_fail(a && obuf, false);\n\tPrintfCallback print = a->cb_printf;\n\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"Raw dump of debug contents of section .debug_line:\\n\\n\");\n\t}\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + len;\n\tconst ut8 *tmpbuf = NULL;\n\n\tRBinDwarfLineHeader hdr = { 0 };\n\tut64 buf_size;\n\n\t// each iteration we read one header AKA comp. unit\n\twhile (buf <= buf_end) {\n\t\t// How much did we read from the compilation unit\n\t\tsize_t bytes_read = 0;\n\t\t// calculate how much we've read by parsing header\n\t\t// because header unit_length includes itself\n\t\tbuf_size = buf_end - buf;\n\n\t\ttmpbuf = buf;\n\t\tbuf = parse_line_header (a->cur, buf, buf_end, &hdr, mode, print);\n\t\tif (!buf) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\" Line Number Statements:\\n\");\n\t\t}\n\t\tbytes_read = buf - tmpbuf;\n\n\t\tRBinDwarfSMRegisters regs;\n\t\tset_regs_default (&hdr, &regs);\n\n\t\t// If there is more bytes in the buffer than size of the header\n\t\t// It means that there has to be another header/comp.unit\n\t\tif (buf_size > hdr.unit_length) {\n\t\t\tbuf_size = hdr.unit_length + (hdr.is_64bit * 8 + 4); // we dif against bytes_read, but\n\t\t\t\t// unit_length doesn't account unit_length field\n\t\t}\n\t\t// this deals with a case that there is compilation unit with any line information\n\t\tif (buf_size == bytes_read) {\n\t\t\tif (mode == R_MODE_PRINT) {\n\t\t\t\tprint (\" Line table is present, but no lines present\\n\");\n\t\t\t}\n\t\t\tline_header_fini (&hdr);\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf_size > (buf_end - buf) + bytes_read || buf > buf_end) {\n\t\t\tline_header_fini (&hdr);\n\t\t\treturn false;\n\t\t}\n\t\tsize_t tmp_read = 0;\n\t\t// we read the whole compilation unit (that might be composed of more sequences)\n\t\tdo {\n\t\t\t// reads one whole sequence\n\t\t\ttmp_read = parse_opcodes (a, buf, buf_end - buf, &hdr, &regs, mode);\n\t\t\tbytes_read += tmp_read;\n\t\t\tbuf += tmp_read; // Move in the buffer forward\n\t\t} while (bytes_read < buf_size && tmp_read != 0); // if nothing is read -> error, exit\n\n\t\tline_header_fini (&hdr);\n\t\tif (!tmp_read) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n#define READ_BUF(x,y) if (idx+sizeof(y)>=len) { return false;} \\\n\t(x)=*(y*)buf; idx+=sizeof(y);buf+=sizeof(y)\n\n#define READ_BUF64(x) if (idx+sizeof(ut64)>=len) { return false;} \\\n\t(x)=r_read_ble64(buf, big_end); idx+=sizeof(ut64);buf+=sizeof(ut64)\n#define READ_BUF32(x) if (idx+sizeof(ut32)>=len) { return false;} \\\n\t(x)=r_read_ble32(buf, big_end); idx+=sizeof(ut32);buf+=sizeof(ut32)\n#define READ_BUF16(x) if (idx+sizeof(ut16)>=len) { return false;} \\\n\t(x)=r_read_ble16(buf, big_end); idx+=sizeof(ut16);buf+=sizeof(ut16)\n\nstatic int parse_aranges_raw(const ut8 *obuf, int len, int mode, PrintfCallback print) {\n\tut32 length, offset;\n\tut16 version;\n\tut32 debug_info_offset;\n\tut8 address_size, segment_size;\n\tconst ut8 *buf = obuf;\n\tint idx = 0;\n\n\tif (!buf || len< 4) {\n\t\treturn false;\n\t}\n\n\tREAD_BUF32 (length);\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"parse_aranges\\n\");\n\t\tprint (\"length 0x%x\\n\", length);\n\t}\n\n\tif (idx + 12 >= len) {\n\t\treturn false;\n\t}\n\n\tREAD_BUF16 (version);\n\tif (mode == R_MODE_PRINT) {\n\t\tprint(\"Version %d\\n\", version);\n\t}\n\n\tREAD_BUF32 (debug_info_offset);\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"Debug info offset %d\\n\", debug_info_offset);\n\t}\n\n\tREAD_BUF (address_size, ut8);\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"address size %d\\n\", (int)address_size);\n\t}\n\n\tREAD_BUF (segment_size, ut8);\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"segment size %d\\n\", (int)segment_size);\n\t}\n\n\toffset = segment_size + address_size * 2;\n\n\tif (offset) {\n\t\tut64 n = (((ut64) (size_t)buf / offset) + 1) * offset - ((ut64)(size_t)buf);\n\t\tif (idx+n>=len) {\n\t\t\treturn false;\n\t\t}\n\t\tbuf += n;\n\t\tidx += n;\n\t}\n\n\twhile ((buf - obuf) < len) {\n\t\tut64 adr, length;\n\t\tif ((idx+8)>=len) {\n\t\t\tbreak;\n\t\t}\n\t\tREAD_BUF64 (adr);\n\t\tREAD_BUF64 (length);\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"length 0x%\" PFMT64x \" address 0x%\" PFMT64x \"\\n\", length, adr);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int init_debug_info(RBinDwarfDebugInfo *inf) {\n\tif (!inf) {\n\t\treturn -1;\n\t}\n\tinf->comp_units = calloc (sizeof (RBinDwarfCompUnit), DEBUG_INFO_CAPACITY);\n\n\tinf->lookup_table = ht_up_new0 ();\n\n\tif (!inf->comp_units) {\n\t\treturn -1;\n\t}\n\n\tinf->capacity = DEBUG_INFO_CAPACITY;\n\tinf->count = 0;\n\treturn true;\n}\n\nstatic int init_die(RBinDwarfDie *die, ut64 abbr_code, ut64 attr_count) {\n\tif (!die) {\n\t\treturn -1;\n\t}\n\tdie->attr_values = calloc (sizeof (RBinDwarfAttrValue), attr_count);\n\tif (!die->attr_values) {\n\t\treturn -1;\n\t}\n\tdie->abbrev_code = abbr_code;\n\tdie->capacity = attr_count;\n\tdie->count = 0;\n\treturn 0;\n}\n\nstatic int init_comp_unit(RBinDwarfCompUnit *cu) {\n\tif (!cu) {\n\t\treturn -EINVAL;\n\t}\n\tcu->dies = calloc (sizeof (RBinDwarfDie), COMP_UNIT_CAPACITY);\n\tif (!cu->dies) {\n\t\treturn -ENOMEM;\n\t}\n\tcu->capacity = COMP_UNIT_CAPACITY;\n\tcu->count = 0;\n\treturn 0;\n}\n\nstatic int expand_cu(RBinDwarfCompUnit *cu) {\n\tRBinDwarfDie *tmp;\n\n\tif (!cu || cu->capacity == 0 || cu->capacity != cu->count) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RBinDwarfDie *)realloc (cu->dies,\n\t\tcu->capacity * 2 * sizeof (RBinDwarfDie));\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset ((ut8 *)tmp + cu->capacity * sizeof (RBinDwarfDie),\n\t\t0, cu->capacity * sizeof (RBinDwarfDie));\n\tcu->dies = tmp;\n\tcu->capacity *= 2;\n\n\treturn 0;\n}\n\nstatic int init_abbrev_decl(RBinDwarfAbbrevDecl *ad) {\n\tif (!ad) {\n\t\treturn -EINVAL;\n\t}\n\tad->defs = calloc (sizeof (RBinDwarfAttrDef), ABBREV_DECL_CAP);\n\n\tif (!ad->defs) {\n\t\treturn -ENOMEM;\n\t}\n\n\tad->capacity = ABBREV_DECL_CAP;\n\tad->count = 0;\n\n\treturn 0;\n}\n\nstatic int expand_abbrev_decl(RBinDwarfAbbrevDecl *ad) {\n\tRBinDwarfAttrDef *tmp;\n\n\tif (!ad || !ad->capacity || ad->capacity != ad->count) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RBinDwarfAttrDef *)realloc (ad->defs,\n\t\tad->capacity * 2 * sizeof (RBinDwarfAttrDef));\n\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\n\t// Set the area in the buffer past the length to 0\n\tmemset ((ut8 *)tmp + ad->capacity * sizeof (RBinDwarfAttrDef),\n\t\t0, ad->capacity * sizeof (RBinDwarfAttrDef));\n\tad->defs = tmp;\n\tad->capacity *= 2;\n\n\treturn 0;\n}\n\nstatic int init_debug_abbrev(RBinDwarfDebugAbbrev *da) {\n\tif (!da) {\n\t\treturn -EINVAL;\n\t}\n\tda->decls = calloc (sizeof (RBinDwarfAbbrevDecl), DEBUG_ABBREV_CAP);\n\tif (!da->decls) {\n\t\treturn -ENOMEM;\n\t}\n\tda->capacity = DEBUG_ABBREV_CAP;\n\tda->count = 0;\n\n\treturn 0;\n}\n\nstatic int expand_debug_abbrev(RBinDwarfDebugAbbrev *da) {\n\tRBinDwarfAbbrevDecl *tmp;\n\n\tif (!da || da->capacity == 0 || da->capacity != da->count) {\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = (RBinDwarfAbbrevDecl *)realloc (da->decls,\n\t\tda->capacity * 2 * sizeof (RBinDwarfAbbrevDecl));\n\n\tif (!tmp) {\n\t\treturn -ENOMEM;\n\t}\n\tmemset ((ut8 *)tmp + da->capacity * sizeof (RBinDwarfAbbrevDecl),\n\t\t0, da->capacity * sizeof (RBinDwarfAbbrevDecl));\n\n\tda->decls = tmp;\n\tda->capacity *= 2;\n\n\treturn 0;\n}\n\nstatic void print_abbrev_section(RBinDwarfDebugAbbrev *da, PrintfCallback print) {\n\tsize_t i, j;\n\tut64 attr_name, attr_form;\n\n\tif (!da) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < da->count; i++) {\n\t\tint declstag = da->decls[i].tag;\n\t\tprint (\"   %-4\"PFMT64d\" \", da->decls[i].code);\n\t\tif (declstag>=0 && declstag < DW_TAG_LAST) {\n\t\t\tprint (\"  %-25s \", dwarf_tag_name_encodings[declstag]);\n\t\t}\n\t\tprint (\"[%s]\", da->decls[i].has_children ?\n\t\t\t\t\"has children\" : \"no children\");\n\t\tprint (\" (0x%\"PFMT64x\")\\n\", da->decls[i].offset);\n\n\t\tif (da->decls[i].defs) {\n\t\t\tfor (j = 0; j < da->decls[i].count; j++) {\n\t\t\t\tattr_name = da->decls[i].defs[j].attr_name;\n\t\t\t\tattr_form = da->decls[i].defs[j].attr_form;\n\t\t\t\tif (is_printable_attr(attr_name) && is_printable_form(attr_form)) {\n\t\t\t\t\tprint (\"    %-30s %-30s\\n\",\n\t\t\t\t\t\t\tdwarf_attr_encodings[attr_name],\n\t\t\t\t\t\t\tdwarf_attr_form_encodings[attr_form]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nR_API void r_bin_dwarf_free_debug_abbrev(RBinDwarfDebugAbbrev *da) {\n\tsize_t i;\n\tif (!da) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < da->count; i++) {\n\t\tR_FREE (da->decls[i].defs);\n\t}\n\tR_FREE (da->decls);\n\tfree (da);\n}\n\nstatic void free_attr_value(RBinDwarfAttrValue *val) {\n\t// TODO adjust to new forms, now we're leaking\n\tif (!val) {\n\t\treturn;\n\t}\n\tswitch (val->attr_form) {\n\tcase DW_FORM_strp:\n\tcase DW_FORM_string:\n\t\tR_FREE (val->string.content);\n\t\tbreak;\n\tcase DW_FORM_exprloc:\n\tcase DW_FORM_block:\n\tcase DW_FORM_block1:\n\tcase DW_FORM_block2:\n\tcase DW_FORM_block4:\n\t\tR_FREE (val->block.data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t};\n}\n\nstatic void free_die(RBinDwarfDie *die) {\n\tsize_t i;\n\tif (!die) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < die->count; i++) {\n\t\tfree_attr_value (&die->attr_values[i]);\n\t}\n\tR_FREE (die->attr_values);\n}\n\nstatic void free_comp_unit(RBinDwarfCompUnit *cu) {\n\tsize_t i;\n\tif (!cu) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < cu->count; i++) {\n\t\tif (cu->dies) {\n\t\t\tfree_die (&cu->dies[i]);\n\t\t}\n\t}\n\tR_FREE (cu->dies);\n}\n\nR_API void r_bin_dwarf_free_debug_info(RBinDwarfDebugInfo *inf) {\n\tsize_t i;\n\tif (!inf) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < inf->count; i++) {\n\t\tfree_comp_unit (&inf->comp_units[i]);\n\t}\n\tht_up_free (inf->lookup_table);\n\tfree (inf->comp_units);\n\tfree(inf);\n}\n\nstatic void print_attr_value(const RBinDwarfAttrValue *val, PrintfCallback print) {\n\tsize_t i;\n\tr_return_if_fail(val);\n\n\tswitch (val->attr_form) {\n\tcase DW_FORM_block:\n\tcase DW_FORM_block1:\n\tcase DW_FORM_block2:\n\tcase DW_FORM_block4:\n\tcase DW_FORM_exprloc:\n\t\tprint (\"%\"PFMT64u\" byte block:\", val->block.length);\n\t\tfor (i = 0; i < val->block.length; i++) {\n\t\t\tprint (\" 0x%02x\", val->block.data[i]);\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_data1:\n\tcase DW_FORM_data2:\n\tcase DW_FORM_data4:\n\tcase DW_FORM_data8:\n\tcase DW_FORM_data16:\n\t\tprint (\"%\"PFMT64u\"\", val->uconstant);\n\t\tif (val->attr_name == DW_AT_language) {\n\t\t\tprint (\"   (%s)\", dwarf_langs[val->uconstant]);\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_string:\n\t\tif (val->string.content) {\n\t\t\tprint (\"%s\", val->string.content);\n\t\t} else {\n\t\t\tprint (\"No string found\");\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tprint (\"%u\", val->flag);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tprint (\"%\"PFMT64d\"\", val->sconstant);\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\tprint (\"%\"PFMT64u\"\", val->uconstant);\n\t\tbreak;\n\tcase DW_FORM_ref_addr:\n\tcase DW_FORM_ref1:\n\tcase DW_FORM_ref2:\n\tcase DW_FORM_ref4:\n\tcase DW_FORM_ref8:\n\tcase DW_FORM_ref_sig8:\n\tcase DW_FORM_ref_udata:\n\tcase DW_FORM_ref_sup4:\n\tcase DW_FORM_ref_sup8:\n\tcase DW_FORM_sec_offset:\n\t\tprint (\"<0x%\"PFMT64x\">\", val->reference);\n\t\tbreak;\n\tcase DW_FORM_flag_present:\n\t\tprint (\"1\");\n\t\tbreak;\n\tcase DW_FORM_strx:\n\tcase DW_FORM_strx1:\n\tcase DW_FORM_strx2:\n\tcase DW_FORM_strx3:\n\tcase DW_FORM_strx4:\n\tcase DW_FORM_line_ptr:\n\tcase DW_FORM_strp_sup:\n\tcase DW_FORM_strp:\n\t\tprint (\"(indirect string, offset: 0x%\"PFMT64x\"): %s\",\n\t\t\tval->string.offset, val->string.content);\n\t\tbreak;\n\tcase DW_FORM_addr:\n\tcase DW_FORM_addrx:\n\tcase DW_FORM_addrx1:\n\tcase DW_FORM_addrx2:\n\tcase DW_FORM_addrx3:\n\tcase DW_FORM_addrx4:\n\tcase DW_FORM_loclistx:\n\tcase DW_FORM_rnglistx:\n\t\tprint (\"0x%\"PFMT64x\"\", val->address);\n\t\tbreak;\n\tcase DW_FORM_implicit_const:\n\t\tprint (\"0x%\"PFMT64d\"\", val->uconstant);\n\t\tbreak;\n\tdefault:\n\t\tprint (\"Unknown attr value form %\"PFMT64d\"\\n\", val->attr_form);\n\t\tbreak;\n\t};\n}\n\nstatic void print_debug_info(const RBinDwarfDebugInfo *inf, PrintfCallback print) {\n\tsize_t i, j, k;\n\tRBinDwarfDie *dies;\n\tRBinDwarfAttrValue *values;\n\n\tr_return_if_fail(inf);\n\n\tfor (i = 0; i < inf->count; i++) {\n\t\tprint (\"\\n\");\n\t\tprint (\"  Compilation Unit @ offset 0x%\" PFMT64x \":\\n\", inf->comp_units[i].offset);\n\t\tprint (\"   Length:        0x%\" PFMT64x \"\\n\", inf->comp_units[i].hdr.length);\n\t\tprint (\"   Version:       %d\\n\", inf->comp_units[i].hdr.version);\n\t\tprint (\"   Abbrev Offset: 0x%\" PFMT64x \"\\n\", inf->comp_units[i].hdr.abbrev_offset);\n\t\tprint (\"   Pointer Size:  %d\\n\", inf->comp_units[i].hdr.address_size);\n\t\tif (is_printable_unit_type(inf->comp_units[i].hdr.unit_type)) {\n\t\t\tprint (\"   Unit Type:     %s\\n\", dwarf_unit_types[inf->comp_units[i].hdr.unit_type]);\n\t\t}\n\t\tprint (\"\\n\");\n\n\t\tdies = inf->comp_units[i].dies;\n\n\t\tfor (j = 0; j < inf->comp_units[i].count; j++) {\n\t\t\tprint (\"<0x%\"PFMT64x\">: Abbrev Number: %-4\" PFMT64u \" \", dies[j].offset,dies[j].abbrev_code);\n\n\t\t\tif (is_printable_tag (dies[j].tag)) {\n\t\t\t\tprint (\"(%s)\\n\", dwarf_tag_name_encodings[dies[j].tag]);\n\t\t\t} else {\n\t\t\t\tprint (\"(Unknown abbrev tag)\\n\");\n\t\t\t}\n\n\t\t\tif (!dies[j].abbrev_code) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvalues = dies[j].attr_values;\n\n\t\t\tfor (k = 0; k < dies[j].count; k++) {\n\t\t\t\tif (!values[k].attr_name) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (is_printable_attr (values[k].attr_name)) {\n\t\t\t\t\tprint (\"     %-25s : \", dwarf_attr_encodings[values[k].attr_name]);\n\t\t\t\t} else {\n\t\t\t\t\tprint (\"     AT_UNKWN [0x%-3\" PFMT64x \"]\\t : \", values[k].attr_name);\n\t\t\t\t}\n\t\t\t\tprint_attr_value (&values[k], print);\n\t\t\t\tprint (\"\\n\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic const ut8 *fill_block_data(const ut8 *buf, const ut8 *buf_end, RBinDwarfBlock *block) {\n\tblock->data = calloc (sizeof (ut8), block->length);\n\tif (!block->data) {\n\t\treturn NULL;\n\t}\n\t/* Maybe unroll this as an optimization in future? */\n\tif (block->data) {\n\t\tsize_t j = 0;\n\t\tfor (j = 0; j < block->length; j++) {\n\t\t\tblock->data[j] = READ (buf, ut8);\n\t\t}\n\t}\n\treturn buf;\n}\n\n/**\n * This function is quite incomplete and requires lot of work\n * With parsing various new FORM values\n * @brief Parses attribute value based on its definition\n *        and stores it into `value`\n *\n * @param obuf\n * @param obuf_len Buffer max capacity\n * @param def Attribute definition\n * @param value Parsed value storage\n * @param hdr Current unit header\n * @param debug_str Ptr to string section start\n * @param debug_str_len Length of the string section\n * @return const ut8* Updated buffer\n */\nstatic const ut8 *parse_attr_value(const ut8 *obuf, int obuf_len,\n\t\tRBinDwarfAttrDef *def, RBinDwarfAttrValue *value,\n\t\tconst RBinDwarfCompUnitHdr *hdr,\n\t\tconst ut8 *debug_str, size_t debug_str_len) {\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + obuf_len;\n\tsize_t j;\n\n\tr_return_val_if_fail(def && value && hdr && obuf && obuf_len >= 1, NULL);\n\n\tvalue->attr_form = def->attr_form;\n\tvalue->attr_name = def->attr_name;\n\tvalue->block.data = NULL;\n\tvalue->string.content = NULL;\n\tvalue->string.offset = 0;\n\n\t// http://www.dwarfstd.org/doc/DWARF4.pdf#page=161&zoom=100,0,560\n\tswitch (def->attr_form) {\n\tcase DW_FORM_addr:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tswitch (hdr->address_size) {\n\t\tcase 1:\n\t\t\tvalue->address = READ8 (buf);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvalue->address = READ16 (buf);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tvalue->address = READ32 (buf);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalue->address = READ64 (buf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"DWARF: Unexpected pointer size: %u\\n\", (unsigned)hdr->address_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_data1:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_data2:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_data4:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_data8:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_data16: // TODO Fix this, right now I just read the data, but I need to make storage for it\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64 (buf);\n\t\tvalue->uconstant = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = r_leb128 (buf, buf_end - buf, &value->sconstant);\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->uconstant, NULL);\n\t\tbreak;\n\tcase DW_FORM_string:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.content = *buf ? strdup ((const char *)buf) : NULL;\n\t\tbuf += (strlen ((const char *)buf) + 1);\n\t\tbreak;\n\tcase DW_FORM_block1:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ8 (buf);\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block2:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ16 (buf);\n\t\tif (value->block.length > 0) {\n\t\t\tvalue->block.data = calloc (sizeof (ut8), value->block.length);\n\t\t\tif (!value->block.data) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block4:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ32 (buf);\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block: // variable length ULEB128\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = READ (buf, ut8);\n\t\tbreak;\n\t// offset in .debug_str\n\tcase DW_FORM_strp:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset(hdr->is_64bit, &buf, buf_end);\n\t\tif (debug_str && value->string.offset < debug_str_len) {\n\t\t\tvalue->string.content =\n\t\t\t\tstrdup ((const char *)(debug_str + value->string.offset));\n\t\t} else {\n\t\t\tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t}\n\t\tbreak;\n\t// offset in .debug_info\n\tcase DW_FORM_ref_addr:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset(hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t// This type of reference is an offset from the first byte of the compilation\n\t// header for the compilation unit containing the reference\n\tcase DW_FORM_ref1:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref2:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_udata:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\t// uleb128 is enough to fit into ut64?\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->reference, NULL);\n\t\tvalue->reference += hdr->unit_offset;\n\t\tbreak;\n\t// offset in a section other than .debug_info or .debug_str\n\tcase DW_FORM_sec_offset:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset(hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\tcase DW_FORM_exprloc:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\t// this means that the flag is present, nothing is read\n\tcase DW_FORM_flag_present:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = true;\n\t\tbreak;\n\tcase DW_FORM_ref_sig8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// offset into .debug_line_str section, can't parse the section now, so we just skip\n\tcase DW_FORM_strx:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\t// value->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdup ((const char *)(debug_str + value->string.offset));\n\t\t// } else {\n\t\t// \tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t// }\n\t\tbreak;\n\tcase DW_FORM_strx1:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx2:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx3: // TODO Add 3 byte int read\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_strx4:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_implicit_const:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = def->special;\n\t\tbreak;\n\t/*  addrx* forms : The index is relative to the value of the\n\t\tDW_AT_addr_base attribute of the associated compilation unit.\n\t    index into an array of addresses in the .debug_addr section.*/\n\tcase DW_FORM_addrx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tcase DW_FORM_addrx1:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx2:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx3:\n\t\t// I need to add 3byte endianess free read here TODO\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_addrx4:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_line_ptr: // offset in a section .debug_line_str\n\tcase DW_FORM_strp_sup: // offset in a section .debug_line_str\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdupsts\n\t\tbreak;\n\t// offset in the supplementary object file\n\tcase DW_FORM_ref_sup4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_sup8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// An index into the .debug_loc\n\tcase DW_FORM_loclistx:\n\t\tvalue->kind = DW_AT_KIND_LOCLISTPTR;\n\t\tvalue->reference = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t // An index into the .debug_rnglists\n\tcase DW_FORM_rnglistx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Unknown DW_FORM 0x%02\" PFMT64x \"\\n\", def->attr_form);\n\t\tvalue->uconstant = 0;\n\t\treturn NULL;\n\t}\n\treturn buf;\n}\n\n/**\n * @brief\n *\n * @param buf Start of the DIE data\n * @param buf_end\n * @param abbrev Abbreviation of the DIE\n * @param hdr Unit header\n * @param die DIE to store the parsed info into\n * @param debug_str Ptr to string section start\n * @param debug_str_len Length of the string section\n * @param sdb\n * @return const ut8* Updated buffer\n */\nstatic const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RBinDwarfAbbrevDecl *abbrev, RBinDwarfCompUnitHdr *hdr, RBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, Sdb *sdb) {\n\tsize_t i;\n\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\tmemset (&die->attr_values[i], 0, sizeof (die->attr_values[i]));\n\n\t\tbuf = parse_attr_value (buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len);\n\n\t\tRBinDwarfAttrValue *attribute = &die->attr_values[i];\n\n\t\tbool is_string = (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string);\n\t\tbool is_valid_string_form = is_string && attribute->string.content;\n\t\t// TODO  does this have a purpose anymore?\n\t\t// Or atleast it needs to rework becase there will be\n\t\t// more comp units -> more comp dirs and only the last one will be kept\n\t\tif (attribute->attr_name == DW_AT_comp_dir && is_valid_string_form) {\n\t\t\tconst char *name = attribute->string.content;\n\t\t\tsdb_set (sdb, \"DW_AT_comp_dir\", name, 0);\n\t\t}\n\t\tdie->count++;\n\t}\n\treturn buf;\n}\n\n/**\n * @brief Reads throught comp_unit buffer and parses all its DIEntries\n *\n * @param sdb\n * @param buf_start Start of the compilation unit data\n * @param unit Unit to store the newly parsed information\n * @param abbrevs Parsed abbrev section info of *all* abbreviations\n * @param first_abbr_idx index for first abbrev of the current comp unit in abbrev array\n * @param debug_str Ptr to string section start\n * @param debug_str_len Length of the string section\n *\n * @return const ut8* Update buffer\n */\nstatic const ut8 *parse_comp_unit(RBinDwarfDebugInfo *info, Sdb *sdb, const ut8 *buf_start,\n\t\tRBinDwarfCompUnit *unit, const RBinDwarfDebugAbbrev *abbrevs,\n\t\tsize_t first_abbr_idx, const ut8 *debug_str, size_t debug_str_len) {\n\n\tconst ut8 *buf = buf_start;\n\tconst ut8 *buf_end = buf_start + unit->hdr.length - unit->hdr.header_size;\n\n\twhile (buf && buf < buf_end && buf >= buf_start) {\n\t\tif (unit->count && unit->capacity == unit->count) {\n\t\t\texpand_cu (unit);\n\t\t}\n\t\tRBinDwarfDie *die = &unit->dies[unit->count];\n\t\t// add header size to the offset;\n\t\tdie->offset = buf - buf_start + unit->hdr.header_size + unit->offset;\n\t\tdie->offset += unit->hdr.is_64bit ? 12 : 4;\n\n\t\t// DIE starts with ULEB128 with the abbreviation code\n\t\tut64 abbr_code;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &abbr_code, NULL);\n\n\t\tif (abbr_code > abbrevs->count || !buf) { // something invalid\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (buf >= buf_end) {\n\t\t\tunit->count++; // we wanna store this entry too, usually the last one is null_entry\n\t\t\treturn buf; // return the buffer to parse next compilation units\n\t\t}\n\t\t// there can be \"null\" entries that have abbr_code == 0\n\t\tif (!abbr_code) {\n\t\t\tunit->count++;\n\t\t\tcontinue;\n\t\t}\n\t\tut64 abbr_idx = first_abbr_idx + abbr_code;\n\n\t\tif (abbrevs->count < abbr_idx) {\n\t\t\treturn NULL;\n\t\t}\n\t\tRBinDwarfAbbrevDecl *abbrev = &abbrevs->decls[abbr_idx - 1];\n\n\t\tif (init_die (die, abbr_code, abbrev->count)) {\n\t\t\treturn NULL; // error\n\t\t}\n\t\tdie->tag = abbrev->tag;\n\t\tdie->has_children = abbrev->has_children;\n\n\t\tbuf = parse_die (buf, buf_end, abbrev, &unit->hdr, die, debug_str, debug_str_len, sdb);\n\t\tif (!buf) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tunit->count++;\n\t}\n\treturn buf;\n}\n\n/**\n * @brief Reads all information about compilation unit header\n *\n * @param buf Start of the buffer\n * @param buf_end Upper bound of the buffer\n * @param unit Unit to read information into\n * @return ut8* Advanced position in a buffer\n */\nstatic const ut8 *info_comp_unit_read_hdr(const ut8 *buf, const ut8 *buf_end, RBinDwarfCompUnitHdr *hdr) {\n\t// 32-bit vs 64-bit dwarf formats\n\t// http://www.dwarfstd.org/doc/Dwarf3.pdf section 7.4\n\thdr->length = READ32 (buf);\n\tif (hdr->length == (ut32)DWARF_INIT_LEN_64) { // then its 64bit\n\t\thdr->length = READ64 (buf);\n\t\thdr->is_64bit = true;\n\t}\n\tconst ut8 *tmp = buf; // to calculate header size\n\thdr->version = READ16 (buf);\n\tif (hdr->version == 5) {\n\t\thdr->unit_type = READ8 (buf);\n\t\thdr->address_size = READ8 (buf);\n\t\thdr->abbrev_offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\n\t\tif (hdr->unit_type == DW_UT_skeleton || hdr->unit_type == DW_UT_split_compile) {\n\t\t\thdr->dwo_id = READ8 (buf);\n\t\t} else if (hdr->unit_type == DW_UT_type || hdr->unit_type == DW_UT_split_type) {\n\t\t\thdr->type_sig = READ64 (buf);\n\t\t\thdr->type_offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t}\n\t} else {\n\t\thdr->abbrev_offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\thdr->address_size = READ8 (buf);\n\t}\n\thdr->header_size = buf - tmp; // header size excluding length field\n\treturn buf;\n}\nstatic int expand_info(RBinDwarfDebugInfo *info) {\n\tr_return_val_if_fail (info && info->capacity == info->count, -1);\n\n\tRBinDwarfCompUnit *tmp = realloc (info->comp_units,\n\t\tinfo->capacity * 2 * sizeof (RBinDwarfCompUnit));\n\tif (!tmp) {\n\t\treturn -1;\n\t}\n\n\tmemset ((ut8 *)tmp + info->capacity * sizeof (RBinDwarfCompUnit),\n\t\t0, info->capacity * sizeof (RBinDwarfCompUnit));\n\n\tinfo->comp_units = tmp;\n\tinfo->capacity *= 2;\n\n\treturn 0;\n}\n\n/**\n * @brief Parses whole .debug_info section\n *\n * @param sdb Sdb to store line related information into\n * @param da Parsed Abbreviations\n * @param obuf .debug_info section buffer start\n * @param len length of the section buffer\n * @param debug_str start of the .debug_str section\n * @param debug_str_len length of the debug_str section\n * @param mode\n * @return R_API* parse_info_raw Parsed information\n */\nstatic RBinDwarfDebugInfo *parse_info_raw(Sdb *sdb, RBinDwarfDebugAbbrev *da,\n\t\tconst ut8 *obuf, size_t len,\n\t\tconst ut8 *debug_str, size_t debug_str_len) {\n\n\tr_return_val_if_fail (da && sdb && obuf, false);\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + len;\n\n\tRBinDwarfDebugInfo *info = R_NEW0 (RBinDwarfDebugInfo);\n\tif (!info) {\n\t\treturn NULL;\n\t}\n\tif (init_debug_info (info) < 0) {\n\t\tgoto cleanup;\n\t}\n\tint unit_idx = 0;\n\n\twhile (buf < buf_end) {\n\t\tif (info->count >= info->capacity) {\n\t\t\tif (expand_info (info)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tRBinDwarfCompUnit *unit = &info->comp_units[unit_idx];\n\t\tif (init_comp_unit (unit) < 0) {\n\t\t\tunit_idx--;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tinfo->count++;\n\n\t\tunit->offset = buf - obuf;\n\t\t// small redundancy, because it was easiest solution at a time\n\t\tunit->hdr.unit_offset = buf - obuf;\n\n\t\tbuf = info_comp_unit_read_hdr (buf, buf_end, &unit->hdr);\n\n\t\tif (unit->hdr.length > len) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (da->decls->count >= da->capacity) {\n\t\t\teprintf (\"Warning: malformed dwarf have not enough buckets for decls.\\n\");\n\t\t}\n\t\tr_warn_if_fail (da->count <= da->capacity);\n\n\t\t// find abbrev start for current comp unit\n\t\t// we could also do naive, ((char *)da->decls) + abbrev_offset,\n\t\t// but this is more bulletproof to invalid DWARF\n\t\tRBinDwarfAbbrevDecl key = { .offset = unit->hdr.abbrev_offset };\n\t\tRBinDwarfAbbrevDecl *abbrev_start = bsearch (&key, da->decls, da->count, sizeof (key), abbrev_cmp);\n\t\tif (!abbrev_start) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\t// They point to the same array object, so should be def. behaviour\n\t\tsize_t first_abbr_idx = abbrev_start - da->decls;\n\n\t\tbuf = parse_comp_unit (info, sdb, buf, unit, da, first_abbr_idx, debug_str, debug_str_len);\n\n\t\tif (!buf) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tunit_idx++;\n\t}\n\n\treturn info;\n\ncleanup:\n\tr_bin_dwarf_free_debug_info (info);\n\treturn NULL;\n}\n\nstatic RBinDwarfDebugAbbrev *parse_abbrev_raw(const ut8 *obuf, size_t len) {\n\tconst ut8 *buf = obuf, *buf_end = obuf + len;\n\tut64 tmp, attr_code, attr_form, offset;\n\tst64 special;\n\tut8 has_children;\n\tRBinDwarfAbbrevDecl *tmpdecl;\n\n\t// XXX - Set a suitable value here.\n\tif (!obuf || len < 3) {\n\t\treturn NULL;\n\t}\n\tRBinDwarfDebugAbbrev *da = R_NEW0 (RBinDwarfDebugAbbrev);\n\n\tinit_debug_abbrev (da);\n\n\twhile (buf && buf+1 < buf_end) {\n\t\toffset = buf - obuf;\n\t\tbuf = r_uleb128 (buf, (size_t)(buf_end-buf), &tmp, NULL);\n\t\tif (!buf || !tmp || buf >= buf_end) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (da->count == da->capacity) {\n\t\t\texpand_debug_abbrev(da);\n\t\t}\n\t\ttmpdecl = &da->decls[da->count];\n\t\tinit_abbrev_decl (tmpdecl);\n\n\t\ttmpdecl->code = tmp;\n\t\tbuf = r_uleb128 (buf, (size_t)(buf_end-buf), &tmp, NULL);\n\t\ttmpdecl->tag = tmp;\n\n\t\ttmpdecl->offset = offset;\n\t\tif (buf >= buf_end) {\n\t\t\tbreak;\n\t\t}\n\t\thas_children = READ (buf, ut8);\n\t\ttmpdecl->has_children = has_children;\n\t\tdo {\n\t\t\tif (tmpdecl->count == tmpdecl->capacity) {\n\t\t\t\texpand_abbrev_decl (tmpdecl);\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, (size_t)(buf_end - buf), &attr_code, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, (size_t)(buf_end - buf), &attr_form, NULL);\n\t\t\t// http://www.dwarfstd.org/doc/DWARF5.pdf#page=225\n\t\t\tif (attr_form == DW_FORM_implicit_const) {\n\t\t\t\tbuf = r_leb128 (buf, (size_t)(buf_end - buf), &special);\n\t\t\t\ttmpdecl->defs[tmpdecl->count].special = special;\n\t\t\t}\n\t\t\ttmpdecl->defs[tmpdecl->count].attr_name = attr_code;\n\t\t\ttmpdecl->defs[tmpdecl->count].attr_form = attr_form;\n\t\t\ttmpdecl->count++;\n\t\t} while (attr_code && attr_form);\n\n\t\tda->count++;\n\t}\n\treturn da;\n}\n\nRBinSection *getsection(RBin *a, const char *sn) {\n\tRListIter *iter;\n\tRBinSection *section = NULL;\n\tRBinFile *binfile = a ? a->cur: NULL;\n\tRBinObject *o = binfile ? binfile->o : NULL;\n\n\tif ( o && o->sections) {\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tif (strstr (section->name, sn)) {\n\t\t\t\treturn section;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic ut8 *get_section_bytes(RBin *bin, const char *sect_name, size_t *len) {\n\tRBinSection *section = getsection (bin, sect_name);\n\tRBinFile *binfile = bin ? bin->cur: NULL;\n\tif (!section || !binfile) {\n\t\treturn NULL;\n\t}\n\tif (section->size > binfile->size) {\n\t\treturn NULL;\n\t}\n\t*len = section->size;\n\tut8 *buf = calloc (1,*len);\n\tr_buf_read_at (binfile->buf, section->paddr, buf, *len);\n\treturn buf;\n}\n\n/**\n * @brief Parses .debug_info section\n *\n * @param da Parsed abbreviations\n * @param bin\n * @param mode R_MODE_PRINT to print\n * @return RBinDwarfDebugInfo* Parsed information, NULL if error\n */\nR_API RBinDwarfDebugInfo *r_bin_dwarf_parse_info(RBinDwarfDebugAbbrev *da, RBin *bin, int mode) {\n\tRBinDwarfDebugInfo *info = NULL;\n\tRBinSection *debug_str;\n\tRBinSection *section = getsection (bin, \"debug_info\");\n\tRBinFile *binfile = bin ? bin->cur : NULL;\n\n\tut64 debug_str_len = 0;\n\tut8 *debug_str_buf = NULL;\n\n\tif (binfile && section) {\n\t\tdebug_str = getsection (bin, \"debug_str\");\n\t\tif (debug_str) {\n\t\t\tdebug_str_len = debug_str->size;\n\t\t\tdebug_str_buf = calloc (1, debug_str_len + 1);\n\t\t\tif (!debug_str_buf) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tst64 ret = r_buf_read_at (binfile->buf, debug_str->paddr,\n\t\t\t\tdebug_str_buf, debug_str_len);\n\t\t\tif (!ret) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tut64 len = section->size;\n\t\t// what is this checking for?\n\t\tif (len > (UT32_MAX >> 1) || len < 1) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tut8 *buf = calloc (1, len);\n\t\tif (!buf) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (!r_buf_read_at (binfile->buf, section->paddr, buf, len)) {\n\t\t\tfree (buf);\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* set the endianity global [HOTFIX] */\n\t\tbig_end = r_bin_is_big_endian (bin);\n\t\tinfo = parse_info_raw (binfile->sdb_addrinfo, da, buf, len,\n\t\t\tdebug_str_buf, debug_str_len);\n\n\t\tif (mode == R_MODE_PRINT && info) {\n\t\t\tprint_debug_info (info, bin->cb_printf);\n\t\t}\n\t\t// build hashtable after whole parsing because of possible relocations\n\t\tif (info) {\n\t\t\tsize_t i, j;\n\t\t\tfor (i = 0; i < info->count; i++) {\n\t\t\t\tRBinDwarfCompUnit *unit = &info->comp_units[i];\n\t\t\t\tfor (j = 0; j < unit->count; j++) {\n\t\t\t\t\tRBinDwarfDie *die = &unit->dies[j];\n\t\t\t\t\tht_up_insert (info->lookup_table, die->offset, die); // optimization for further processing}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree (debug_str_buf);\n\t\tfree (buf);\n\t\treturn info;\n\t}\ncleanup:\n\tfree (debug_str_buf);\n\treturn NULL;\n}\n\nstatic RBinDwarfRow *row_new(ut64 addr, const char *file, int line, int col) {\n\tRBinDwarfRow *row = R_NEW0 (RBinDwarfRow);\n\tif (!row) {\n\t\treturn NULL;\n\t}\n\trow->file = strdup (file);\n\trow->address = addr;\n\trow->line = line;\n\trow->column = 0;\n\treturn row;\n}\n\nstatic void row_free(void *p) {\n\tRBinDwarfRow *row = (RBinDwarfRow*)p;\n\tfree (row->file);\n\tfree (row);\n}\n\nR_API RList *r_bin_dwarf_parse_line(RBin *bin, int mode) {\n\tut8 *buf;\n\tRList *list = NULL;\n\tint len, ret;\n\tRBinSection *section = getsection (bin, \"debug_line\");\n\tRBinFile *binfile = bin ? bin->cur: NULL;\n\tif (binfile && section) {\n\t\tlen = section->size;\n\t\tif (len < 1) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = calloc (1, len + 1);\n\t\tif (!buf) {\n\t\t\treturn NULL;\n\t\t}\n\t\tret = r_buf_read_at (binfile->buf, section->paddr, buf, len);\n\t\tif (ret != len) {\n\t\t\tfree (buf);\n\t\t\treturn NULL;\n\t\t}\n\t\tlist = r_list_newf (row_free);\n\t\tif (!list) {\n\t\t\tfree (buf);\n\t\t\treturn NULL;\n\t\t}\n\t\t/* set the endianity global [HOTFIX] */\n\t\tbig_end = r_bin_is_big_endian (bin);\n\t\t// Actually parse the section\n\t\tparse_line_raw (bin, buf, len, mode);\n\t\t// k bin/cur/addrinfo/*\n\t\tSdbListIter *iter;\n\t\tSdbKv *kv;\n\t\tSdbList *ls = sdb_foreach_list (binfile->sdb_addrinfo, false);\n\t\t// Use the parsed information from _raw and transform it to more useful format\n\t\tls_foreach (ls, iter, kv) {\n\t\t\tif (!strncmp (sdbkv_key (kv), \"0x\", 2)) {\n\t\t\t\tut64 addr;\n\t\t\t\tRBinDwarfRow *row;\n\t\t\t\tint line;\n\t\t\t\tchar *file = strdup (sdbkv_value (kv));\n\t\t\t\tif (!file) {\n\t\t\t\t\tfree (buf);\n\t\t\t\t\tls_free (ls);\n\t\t\t\t\tr_list_free (list);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tchar *tok = strchr (file, '|');\n\t\t\t\tif (tok) {\n\t\t\t\t\t*tok++ = 0;\n\t\t\t\t\tline = atoi (tok);\n\t\t\t\t\taddr = r_num_math (NULL, sdbkv_key (kv));\n\t\t\t\t\trow = row_new (addr, file, line, 0);\n\t\t\t\t\tr_list_append (list, row);\n\t\t\t\t}\n\t\t\t\tfree (file);\n\t\t\t}\n\t\t}\n\t\tls_free (ls);\n\t\tfree (buf);\n\t}\n\treturn list;\n}\n\nR_API RList *r_bin_dwarf_parse_aranges(RBin *bin, int mode) {\n\tut8 *buf;\n\tint ret;\n\tsize_t len;\n\tRBinSection *section = getsection (bin, \"debug_aranges\");\n\tRBinFile *binfile = bin ? bin->cur: NULL;\n\n\tif (binfile && section) {\n\t\tlen = section->size;\n\t\tif (len < 1 || len > ST32_MAX) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = calloc (1, len);\n\t\tret = r_buf_read_at (binfile->buf, section->paddr, buf, len);\n\t\tif (!ret) {\n\t\t\tfree (buf);\n\t\t\treturn NULL;\n\t\t}\n\t\t/* set the endianity global [HOTFIX] */\n\t\tbig_end = r_bin_is_big_endian (bin);\n\t\tparse_aranges_raw (buf, len, mode, bin->cb_printf);\n\n\t\tfree (buf);\n\t}\n\treturn NULL;\n}\n\nR_API RBinDwarfDebugAbbrev *r_bin_dwarf_parse_abbrev(RBin *bin, int mode) {\n\tsize_t len = 0;\n\tut8 *buf = get_section_bytes (bin, \"debug_abbrev\", &len);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tRBinDwarfDebugAbbrev *abbrevs = parse_abbrev_raw (buf, len);\n\n\tif (mode == R_MODE_PRINT && abbrevs) {\n\t\tprint_abbrev_section (abbrevs, bin->cb_printf);\n\t}\n\tfree (buf);\n\treturn abbrevs;\n}\n\nstatic inline ut64 get_max_offset(size_t addr_size) {\n\tswitch (addr_size) {\n\t\tcase 2:\n\t\treturn UT16_MAX;\n\t\tcase 4:\n\t\treturn UT32_MAX;\n\t\tcase 8:\n\t\treturn UT64_MAX;\n\t}\n\treturn 0;\n}\n\nstatic inline RBinDwarfLocList *create_loc_list(ut64 offset) {\n\tRBinDwarfLocList *list = R_NEW0 (RBinDwarfLocList);\n\tif (list) {\n\t\tlist->list = r_list_new ();\n\t\tlist->offset = offset;\n\t}\n\treturn list;\n}\n\nstatic inline RBinDwarfLocRange *create_loc_range(ut64 start, ut64 end, RBinDwarfBlock *block) {\n\tRBinDwarfLocRange *range = R_NEW0 (RBinDwarfLocRange);\n\tif (range) {\n\t\trange->start = start;\n\t\trange->end = end;\n\t\trange->expression = block;\n\t}\n\treturn range;\n}\n\nstatic void free_loc_table_list(RBinDwarfLocList *loc_list) {\n\tRListIter *iter;\n\tRBinDwarfLocRange *range;\n\tr_list_foreach (loc_list->list, iter, range) {\n\t\tfree (range->expression->data);\n\t\tfree (range->expression);\n\t\tfree (range);\n\t}\n\tr_list_free (loc_list->list);\n\tfree (loc_list);\n}\n\nstatic HtUP *parse_loc_raw(HtUP/*<offset, List *<LocListEntry>*/ *loc_table, const ut8 *buf, size_t len, size_t addr_size) {\n\t/* GNU has their own extensions GNU locviews that we can't parse */\n\tconst ut8 *const buf_start = buf;\n\tconst ut8 *buf_end = buf + len;\n\t/* for recognizing Base address entry */\n\tut64 max_offset = get_max_offset (addr_size);\n\n\tut64 address_base = 0; /* remember base of the loclist */\n\tut64 list_offset = 0;\n\n\tRBinDwarfLocList *loc_list = NULL;\n\tRBinDwarfLocRange *range = NULL;\n\twhile (buf && buf < buf_end) {\n\t\tut64 start_addr = dwarf_read_address (addr_size, &buf, buf_end);\n\t\tut64 end_addr = dwarf_read_address (addr_size, &buf, buf_end);\n\n\t\tif (start_addr == 0 && end_addr == 0) { /* end of list entry: 0, 0 */\n\t\t\tif (loc_list) {\n\t\t\t\tht_up_insert (loc_table, loc_list->offset, loc_list);\n\t\t\t\tlist_offset = buf - buf_start;\n\t\t\t\tloc_list = NULL;\n\t\t\t}\n\t\t\taddress_base = 0;\n\t\t\tcontinue;\n\t\t} else if (start_addr == max_offset && end_addr != max_offset) {\n\t\t\t/* base address, DWARF2 doesn't have this type of entry, these entries shouldn't\n\t\t\t   be in the list, they are just informational entries for further parsing (address_base) */\n\t\t\taddress_base = end_addr;\n\t\t} else { /* location list entry: */\n\t\t\tif (!loc_list) {\n\t\t\t\tloc_list = create_loc_list (list_offset);\n\t\t\t}\n\t\t\t/* TODO in future parse expressions to better structure in dwarf.c and not in dwarf_process.c */\n\t\t\tRBinDwarfBlock *block = R_NEW0 (RBinDwarfBlock);\n\t\t\tblock->length = READ16 (buf);\n\t\t\tbuf = fill_block_data (buf, buf_end, block);\n\t\t\trange = create_loc_range (start_addr + address_base, end_addr + address_base, block);\n\t\t\tr_list_append (loc_list->list, range);\n\t\t\trange = NULL;\n\t\t}\n\t}\n\t/* if for some reason end of list is missing, then loc_list would leak */\n\tif (loc_list) {\n\t\tfree_loc_table_list (loc_list);\n\t}\n\treturn loc_table;\n}\n\n/**\n * @brief Parses out the .debug_loc section into a table that maps each list as\n *        offset of a list -> LocationList\n *\n * @param bin\n * @param addr_size machine address size used in executable (necessary for parsing)\n * @return R_API*\n */\nR_API HtUP/*<offset, RBinDwarfLocList*/ *r_bin_dwarf_parse_loc(RBin *bin, int addr_size) {\n\tr_return_val_if_fail  (bin, NULL);\n\t/* The standarparse_loc_raw_frame, not sure why is that */\n\tsize_t len = 0;\n\tut8 *buf = get_section_bytes (bin, \"debug_loc\", &len);\n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\t/* set the endianity global [HOTFIX] */\n\tbig_end = r_bin_is_big_endian (bin);\n\tHtUP /*<offset, RBinDwarfLocList*/ *loc_table = ht_up_new0 ();\n\tif (!loc_table) {\n\t\tfree (buf);\n\t\treturn NULL;\n\t}\n\tloc_table = parse_loc_raw (loc_table, buf, len, addr_size);\n\tfree (buf);\n\treturn loc_table;\n}\n\nstatic int offset_comp(const void *a, const void *b) {\n\tconst RBinDwarfLocList *f = a;\n\tconst RBinDwarfLocList *s = b;\n\tut64 first = f->offset;\n\tut64 second = s->offset;\n\tif (first < second) {\n\t\treturn -1;\n\t}\n\tif (first > second) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic bool sort_loclists(void *user, const ut64 key, const void *value) {\n\tRBinDwarfLocList *loc_list = (RBinDwarfLocList *)value;\n\tRList *sort_list = user;\n\tr_list_add_sorted (sort_list, loc_list, offset_comp);\n\treturn true;\n}\n\nR_API void r_bin_dwarf_print_loc(HtUP /*<offset, RBinDwarfLocList*/ *loc_table, int addr_size, PrintfCallback print) {\n\tr_return_if_fail (loc_table && print);\n\tprint (\"\\nContents of the .debug_loc section:\\n\");\n\tRList /*<RBinDwarfLocList *>*/ *sort_list = r_list_new ();\n\t/* sort the table contents by offset and print sorted\n\t   a bit ugly, but I wanted to decouple the parsing and printing */\n\tht_up_foreach (loc_table, sort_loclists, sort_list);\n\tRListIter *i;\n\tRBinDwarfLocList *loc_list;\n\tr_list_foreach (sort_list, i, loc_list) {\n\t\tRListIter *j;\n\t\tRBinDwarfLocRange *range;\n\t\tut64 base_offset = loc_list->offset;\n\t\tr_list_foreach (loc_list->list, j, range) {\n\t\t\tprint (\"0x%\" PFMT64x \" 0x%\" PFMT64x \" 0x%\" PFMT64x \"\\n\", base_offset, range->start, range->end);\n\t\t\tbase_offset += addr_size * 2;\n\t\t\tif (range->expression) {\n\t\t\t\tbase_offset += 2 + range->expression->length; /* 2 bytes for expr length */\n\t\t\t}\n\t\t}\n\t\tprint (\"0x%\" PFMT64x \" <End of list>\\n\", base_offset);\n\t}\n\tprint (\"\\n\");\n\tr_list_free (sort_list);\n}\n\nstatic void free_loc_table_entry(HtUPKv *kv) {\n\tif (kv) {\n\t\tfree_loc_table_list (kv->value);\n\t}\n}\n\nR_API void r_bin_dwarf_free_loc(HtUP /*<offset, RBinDwarfLocList*>*/ *loc_table) {\n\tr_return_if_fail (loc_table);\n\tloc_table->opt.freefn = free_loc_table_entry;\n\tht_up_free (loc_table);\n}\n"], "filenames": ["libr/anal/dwarf_process.c", "libr/bin/dwarf.c"], "buggy_code_start_loc": [1007, 386], "buggy_code_end_loc": [1028, 1884], "fixing_code_start_loc": [1007, 386], "fixing_code_end_loc": [1031, 1877], "type": "CWE-787", "message": "A heap buffer overflow in r_sleb128 function in radare2 5.4.2 and 5.4.0.", "other": {"cve": {"id": "CVE-2022-28068", "sourceIdentifier": "cve@mitre.org", "published": "2023-08-22T19:16:22.423", "lastModified": "2023-08-24T22:03:29.030", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A heap buffer overflow in r_sleb128 function in radare2 5.4.2 and 5.4.0."}, {"lang": "es", "value": "Un desbordamiento del b\u00fafer del mont\u00edculo en la funci\u00f3n r_sleb128 en radare2 5.4.2 y 5.4.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:5.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "834B6EB8-099A-469F-ADA3-183E51E43717"}, {"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:5.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "C9DEDA4E-172C-482D-8527-D9AEF8A1D7CC"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/637f4bd1af6752e28e0a9998e954e2e9ce6fa992", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/637f4bd1af6752e28e0a9998e954e2e9ce6fa992"}}