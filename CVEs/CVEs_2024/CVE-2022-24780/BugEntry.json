{"buggy_code": ["<?php\n\n/**\n * Copyright (C) 2013-2020 Combodo SARL\n *\n * This file is part of iTop.\n *\n * iTop is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * iTop is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n */\n\nnamespace Combodo\\iTop\\Portal\\Form;\n\nuse AttachmentPlugIn;\nuse AttributeDateTime;\nuse AttributeSet;\nuse CMDBChangeOpAttachmentAdded;\nuse CMDBChangeOpAttachmentRemoved;\nuse Combodo\\iTop\\Form\\Field\\Field;\nuse Combodo\\iTop\\Form\\Field\\FileUploadField;\nuse Combodo\\iTop\\Form\\Field\\LabelField;\nuse Combodo\\iTop\\Form\\Form;\nuse Combodo\\iTop\\Form\\FormManager;\nuse Combodo\\iTop\\Portal\\Helper\\ApplicationHelper;\nuse DBObject;\nuse DBObjectSearch;\nuse DBObjectSet;\nuse DBSearch;\nuse Dict;\nuse DOMDocument;\nuse DOMXPath;\nuse Exception;\nuse InlineImage;\nuse IssueLog;\nuse MetaModel;\nuse Symfony\\Component\\DependencyInjection\\ContainerInterface;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\Exception\\HttpException;\nuse UserRights;\nuse utils;\n\n/**\n * Description of ObjectFormManager\n *\n * @author Guillaume Lajarige <guillaume.lajarige@combodo.com>\n * @since  2.3.0\n */\nclass ObjectFormManager extends FormManager\n{\n\t/** @var string ENUM_MODE_VIEW */\n\tconst ENUM_MODE_VIEW = 'view';\n\t/** @var string ENUM_MODE_EDIT */\n\tconst ENUM_MODE_EDIT = 'edit';\n\t/** @var string ENUM_MODE_CREATE */\n\tconst ENUM_MODE_CREATE = 'create';\n\t/** @var string ENUM_MODE_APPLY_STIMULUS */\n\tconst ENUM_MODE_APPLY_STIMULUS = 'apply_stimulus';\n\n\t/** @var \\Symfony\\Component\\DependencyInjection\\ContainerInterface $oContainer */\n\tprotected $oContainer;\n\t/** @var \\cmdbAbstractObject $oObject */\n\tprotected $oObject;\n\t/** @var string $sMode */\n\tprotected $sMode;\n\t/** @var string $sActionRulesToken */\n\tprotected $sActionRulesToken;\n\t/** @var array $aFormProperties */\n\tprotected $aFormProperties;\n\t/** @var array $aCallbackUrls */\n\tprotected $aCallbackUrls = array();\n\t/**\n\t * List of hidden fields, used for form update (eg. remove them from the form regarding they dependencies)\n\t * @var array $aHiddenFieldsId\n\t * @since 2.7.5\n\t */\n\tprotected $aHiddenFieldsId = array();\n\n\t/**\n\t * @param string $sJson JSON data that must contain at least :\n\t *       - formobject_class : The class of the object that is being edited/viewed\n\t *       - formmode : view|edit|create\n\t *       - values for parent\n\t * @param bool $bTrustContent if false then won't allow modified TWIG content\n\t *\n\t * @return \\Combodo\\iTop\\Portal\\Form\\ObjectFormManager new instance init from JSON data\n\t *\n\t * @inheritDoc\n\t * @throws \\Exception\n\t * @throws \\SecurityException if twig content is present and $bTrustContent is false\n\t *\n\t * @since 2.7.6 3.0.0 N\u00b04384 new $bTrustContent parameter\n\t */\n\tpublic static function FromJSON($sJson, $bTrustContent = false)\n\t{\n\t\tif (is_array($sJson)) {\n\t\t\t$aJson = $sJson;\n\t\t} else {\n\t\t\t$aJson = json_decode($sJson, true);\n\t\t}\n\n\t\t$oConfig = utils::GetConfig();\n\t\t$bIsContentCheckEnabled = $oConfig->GetModuleSetting(PORTAL_ID, 'enable_formmanager_content_check', true);\n\t\tif ($bIsContentCheckEnabled && (false === $bTrustContent)) {\n\t\t\t/** @noinspection NestedPositiveIfStatementsInspection */\n\t\t\tif (isset($aJson['formproperties']['layout']['type']) && ($aJson['formproperties']['layout']['type'] === 'twig')) {\n\t\t\t\t// There will be an IssueLog above in the hierarchy due to the exception, but we are logging here so that we can output the JSON data !\n\t\t\t\tIssueLog::Error('Portal received a query with forbidden twig content!', \\LogChannels::PORTAL, ['formmanager_data' => $aJson]);\n\t\t\t\tthrow new \\SecurityException('Twig content not allowed in this context!');\n\t\t\t}\n\t\t}\n\n\t\t/** @var \\Combodo\\iTop\\Portal\\Form\\ObjectFormManager $oFormManager */\n\t\t$oFormManager = parent::FromJSON($sJson);\n\n\t\t// Retrieving object to edit\n\t\tif (!isset($aJson['formobject_class'])) {\n\t\t\tthrow new Exception('Object class must be defined in order to generate the form');\n\t\t}\n\t\t$sObjectClass = $aJson['formobject_class'];\n\n\t\tif (!isset($aJson['formobject_id']))\n\t\t{\n\t\t\t$oObject = MetaModel::NewObject($sObjectClass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Note : AllowAllData set to true here instead of checking scope's flag because we are displaying a value that has been set and validated\n\t\t\t$oObject = MetaModel::GetObject($sObjectClass, $aJson['formobject_id'], true, true);\n\t\t}\n\t\t$oFormManager->SetObject($oObject);\n\n\t\t// Retrieving form mode\n\t\tif (!isset($aJson['formmode']))\n\t\t{\n\t\t\tthrow new Exception('Form mode must be defined in order to generate the form');\n\t\t}\n\t\t$oFormManager->SetMode($aJson['formmode']);\n\n\t\t// Retrieving actions rules\n\t\tif (isset($aJson['formactionrulestoken']))\n\t\t{\n\t\t\t$oFormManager->SetActionRulesToken($aJson['formactionrulestoken']);\n\t\t}\n\n\t\t// Retrieving form properties\n\t\tif (isset($aJson['formproperties']))\n\t\t{\n\t\t\t// As empty array are no passed through HTTP, this one is not always present and we have to ensure it is.\n\t\t\tif (!isset($aJson['formproperties']['fields']))\n\t\t\t{\n\t\t\t\t$aJson['formproperties']['fields'] = array();\n\t\t\t}\n\t\t\t$oFormManager->SetFormProperties($aJson['formproperties']);\n\t\t}\n\n\t\t// Retrieving callback urls\n\t\tif (!isset($aJson['formcallbacks'])) {\n\t\t\t// TODO\n\t\t}\n\n\t\treturn $oFormManager;\n\t}\n\n\t/**\n\t * @param string $sPostedFormManagerData received data from the browser\n\t * @param array $aOriginalFormProperties data generated server side\n\t *\n\t * @return bool true if the data are identical\n\t *\n\t * @since 2.7.6 3.0.0 N\u00b04384 check formmanager_data\n\t */\n\tpublic static function CanTrustFormLayoutContent($sPostedFormManagerData, $aOriginalFormProperties)\n\t{\n\t\t$aPostedFormManagerData = json_decode($sPostedFormManagerData, true);\n\t\t$sPostedFormLayoutType = (isset($aPostedFormManagerData['formproperties']['layout']['type'])) ? $aPostedFormManagerData['formproperties']['layout']['type'] : '';\n\n\t\tif ($sPostedFormLayoutType === 'xhtml') {\n\t\t\treturn true;\n\t\t}\n\n\t\t// we need to parse the content so that autoclose tags are returned correctly (`<div />` => `<div></div>`)\n\t\t$oHtmlDocument = new \\DOMDocument();\n\n\t\t$sPostedFormLayoutContent = (isset($aPostedFormManagerData['formproperties']['layout']['content'])) ? $aPostedFormManagerData['formproperties']['layout']['content'] : '';\n\t\t$oHtmlDocument->loadXML('<root>'.$sPostedFormLayoutContent.'</root>');\n\t\t$sPostedFormLayoutRendered = $oHtmlDocument->saveHTML();\n\n\t\t$sOriginalFormLayoutContent = (isset($aOriginalFormProperties['layout']['content'])) ? $aOriginalFormProperties['layout']['content'] : '';\n\t\t$oHtmlDocument->loadXML('<root>'.$sOriginalFormLayoutContent.'</root>');\n\t\t$sOriginalFormLayoutContentRendered = $oHtmlDocument->saveHTML();\n\n\t\treturn ($sPostedFormLayoutRendered === $sOriginalFormLayoutContentRendered);\n\t}\n\n\t/**\n\t *\n\t * @return \\Symfony\\Component\\DependencyInjection\\ContainerInterface\n\t */\n\tpublic function GetContainer()\n\t{\n\t\treturn $this->oContainer;\n\t}\n\n\t/**\n\t *\n\t * @param \\Symfony\\Component\\DependencyInjection\\ContainerInterface $oContainer\n\t *\n\t * @return $this\n\t */\n\tpublic function SetContainer(ContainerInterface $oContainer)\n\t{\n\t\t$this->oContainer = $oContainer;\n\n\t\treturn $this;\n\t}\n\n\t/**\n\t *\n\t * @return \\DBObject\n\t */\n\tpublic function GetObject()\n\t{\n\t\treturn $this->oObject;\n\t}\n\n\t/**\n\t *\n\t * @param \\DBObject $oObject\n\t *\n\t * @return $this\n\t */\n\tpublic function SetObject(DBObject $oObject)\n\t{\n\t\t$this->oObject = $oObject;\n\n\t\treturn $this;\n\t}\n\n\t/**\n\t *\n\t * @return string\n\t */\n\tpublic function GetMode()\n\t{\n\t\treturn $this->sMode;\n\t}\n\n\t/**\n\t *\n\t * @param string $sMode\n\t *\n\t * @return $this\n\t */\n\tpublic function SetMode($sMode)\n\t{\n\t\t$this->sMode = $sMode;\n\n\t\treturn $this;\n\t}\n\n\t/**\n\t *\n\t * @return string\n\t */\n\tpublic function GetActionRulesToken()\n\t{\n\t\treturn $this->sActionRulesToken;\n\t}\n\n\t/**\n\t *\n\t * @param string $sActionRulesToken\n\t *\n\t * @return $this\n\t */\n\tpublic function SetActionRulesToken($sActionRulesToken)\n\t{\n\t\t$this->sActionRulesToken = $sActionRulesToken;\n\n\t\treturn $this;\n\t}\n\n\t/**\n\t *\n\t * @return array\n\t */\n\tpublic function GetFormProperties()\n\t{\n\t\treturn $this->aFormProperties;\n\t}\n\n\t/**\n\t *\n\t * @param array $aFormProperties\n\t *\n\t * @return $this\n\t */\n\tpublic function SetFormProperties($aFormProperties)\n\t{\n\t\t$this->aFormProperties = $aFormProperties;\n\n\t\treturn $this;\n\t}\n\n\t/**\n\t *\n\t * @return array\n\t */\n\tpublic function GetCallbackUrls()\n\t{\n\t\treturn $this->aCallbackUrls;\n\t}\n\n\t/**\n\t *\n\t * @param array $aCallbackUrls\n\t *\n\t * @return $this\n\t */\n\tpublic function SetCallbackUrls($aCallbackUrls)\n\t{\n\t\t$this->aCallbackUrls = $aCallbackUrls;\n\n\t\treturn $this;\n\t}\n\n\t/**\n\t * Returns if the form manager is handling a transition form instead of a state form.\n\t *\n\t * @return bool\n\t */\n\tpublic function IsTransitionForm()\n\t{\n\t\treturn ($this->sMode === static::ENUM_MODE_APPLY_STIMULUS);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic function ToJSON()\n\t{\n\t\t$aJson = parent::ToJSON();\n\t\t$aJson['formobject_class'] = get_class($this->oObject);\n\t\tif ($this->oObject->GetKey() > 0)\n\t\t{\n\t\t\t$aJson['formobject_id'] = $this->oObject->GetKey();\n\t\t}\n\t\t$aJson['formmode'] = $this->sMode;\n\t\t$aJson['formactionrulestoken'] = $this->sActionRulesToken;\n\t\t$aJson['formproperties'] = $this->aFormProperties;\n\n\t\treturn $aJson;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t * @throws \\CoreException\n\t * @throws \\OQLException\n\t * @throws \\Exception\n\t */\n\tpublic function Build()\n\t{\n\t\t$sObjectClass = get_class($this->oObject);\n\n\t\t$aFieldsAtts = array();\n\t\t$aFieldsDMOnlyAttCodes = array();\n\t\t$aFieldsExtraData = array();\n\n\t\tif ($this->oForm !== null)\n\t\t{\n\t\t\t$oForm = $this->oForm;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$aFormId = 'objectform-'.((isset($this->aFormProperties['id'])) ? $this->aFormProperties['id'] : 'default').'-'.uniqid();\n\t\t\t$oForm = new Form($aFormId);\n\t\t\t$oForm->SetTransactionId(utils::GetNewTransactionId());\n\t\t}\n\n\t\t// Building form from its properties\n\t\t// - Consistency checks for stimulus form\n\t\tif (isset($this->aFormProperties['stimulus_code']))\n\t\t{\n\t\t\t$aTransitions = MetaModel::EnumTransitions($sObjectClass, $this->oObject->GetState());\n\t\t\tif (!isset($aTransitions[$this->aFormProperties['stimulus_code']]))\n\t\t\t{\n\t\t\t\t$aStimuli = Metamodel::EnumStimuli($sObjectClass);\n\t\t\t\t$sStimulusLabel = $aStimuli[$this->aFormProperties['stimulus_code']]->GetLabel();\n\n\t\t\t\t$sExceptionMessage = Dict::Format('UI:Error:Invalid_Stimulus_On_Object_In_State', $sStimulusLabel, $this->oObject->GetName(), $this->oObject->GetStateLabel());\n\t\t\t\tthrow new Exception($sExceptionMessage);\n\t\t\t}\n\t\t}\n\t\t// - The fields\n\t\tswitch ($this->aFormProperties['type'])\n\t\t{\n\t\t\tcase 'custom_list':\n\t\t\tcase 'static':\n\t\t\t\tforeach ($this->aFormProperties['fields'] as $sAttCode => $aOptions)\n\t\t\t\t{\n\t\t\t\t\t// When in a transition and no flags are specified for the field, we will retrieve its flags from DM later\n\t\t\t\t\tif ($this->IsTransitionForm() && empty($aOptions))\n\t\t\t\t\t{\n\t\t\t\t\t\t$aFieldsDMOnlyAttCodes[] = $sAttCode;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Otherwise we proceed as usual\n\t\t\t\t\t$iFieldFlags = OPT_ATT_NORMAL;\n\t\t\t\t\t// Checking if field should be slave\n\t\t\t\t\tif (isset($aOptions['slave']) && ($aOptions['slave'] === true))\n\t\t\t\t\t{\n\t\t\t\t\t\t$iFieldFlags = $iFieldFlags | OPT_ATT_SLAVE;\n\t\t\t\t\t}\n\t\t\t\t\t// Checking if field should be must_change\n\t\t\t\t\tif (isset($aOptions['must_change']) && ($aOptions['must_change'] === true))\n\t\t\t\t\t{\n\t\t\t\t\t\t$iFieldFlags = $iFieldFlags | OPT_ATT_MUSTCHANGE;\n\t\t\t\t\t}\n\t\t\t\t\t// Checking if field should be must prompt\n\t\t\t\t\tif (isset($aOptions['must_prompt']) && ($aOptions['must_prompt'] === true))\n\t\t\t\t\t{\n\t\t\t\t\t\t$iFieldFlags = $iFieldFlags | OPT_ATT_MUSTPROMPT;\n\t\t\t\t\t}\n\t\t\t\t\t// Checking if field should be hidden\n\t\t\t\t\tif (isset($aOptions['hidden']) && ($aOptions['hidden'] === true))\n\t\t\t\t\t{\n\t\t\t\t\t\t$iFieldFlags = $iFieldFlags | OPT_ATT_HIDDEN;\n\t\t\t\t\t}\n\t\t\t\t\t// Checking if field should be readonly\n\t\t\t\t\tif (isset($aOptions['read_only']) && ($aOptions['read_only'] === true))\n\t\t\t\t\t{\n\t\t\t\t\t\t$iFieldFlags = $iFieldFlags | OPT_ATT_READONLY;\n\t\t\t\t\t}\n\t\t\t\t\t// Checking if field should be mandatory\n\t\t\t\t\tif (isset($aOptions['mandatory']) && ($aOptions['mandatory'] === true))\n\t\t\t\t\t{\n\t\t\t\t\t\t$iFieldFlags = $iFieldFlags | OPT_ATT_MANDATORY;\n\t\t\t\t\t}\n\t\t\t\t\t// Finally, adding the attribute and its flags\n\t\t\t\t\t$aFieldsAtts[$sAttCode] = $iFieldFlags;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'zlist':\n\t\t\t\tforeach (MetaModel::FlattenZList(MetaModel::GetZListItems($sObjectClass, $this->aFormProperties['fields'])) as $sAttCode)\n\t\t\t\t{\n\t\t\t\t\t$aFieldsAtts[$sAttCode] = OPT_ATT_NORMAL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\t// - The layout\n\t\tif ($this->aFormProperties['layout'] !== null)\n\t\t{\n\t\t\t// Checking if we need to render the template from twig to html in order to parse the fields\n\t\t\tif ($this->aFormProperties['layout']['type'] === 'twig')\n\t\t\t{\n\t\t\t\tif ($this->oContainer !== null)\n\t\t\t\t{\n\t\t\t\t\t/** @var \\Combodo\\iTop\\Portal\\Helper\\ObjectFormHandlerHelper $oObjectFormHandler */\n\t\t\t\t\t$oObjectFormHandler = $this->oContainer->get('object_form_handler');\n\t\t\t\t\t$sRendered = $oObjectFormHandler->RenderFormFromTwig(\n\t\t\t\t\t\t$oForm->GetId(),\n\t\t\t\t\t\t$this->aFormProperties['layout']['content'],\n\t\t\t\t\t\tarray('oRenderer' => $this->oRenderer, 'oObject' => $this->oObject)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$sRendered = 'Form not rendered because of missing container';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$sRendered = $this->aFormProperties['layout']['content'];\n\t\t\t}\n\n\t\t\t// Parsing rendered template to find the fields\n\t\t\t$oHtmlDocument = new DOMDocument();\n\t\t\t// Note: Loading as XML instead of HTML avoid some encoding issues (eg. '\u00e9' was transformed to '&tilde;&copy;')\n\t\t\t$oHtmlDocument->loadXML('<root>'.$sRendered.'</root>');\n\n\t\t\t// Adding fields to the list\n\t\t\t$oXPath = new DOMXPath($oHtmlDocument);\n\t\t\t/** @var \\DOMElement $oFieldNode */\n\t\t\tforeach ($oXPath->query('//div[contains(@class, \"form_field\")][@data-field-id]') as $oFieldNode)\n\t\t\t{\n\t\t\t\t$sFieldId = $oFieldNode->getAttribute('data-field-id');\n\t\t\t\t$sFieldFlags = $oFieldNode->getAttribute('data-field-flags');\n\t\t\t\t$iFieldFlags = OPT_ATT_NORMAL;\n\n\t\t\t\t// When in a transition and no flags are specified for the field, we will retrieve its flags from DM later\n\t\t\t\tif ($this->IsTransitionForm() && $sFieldFlags === '')\n\t\t\t\t{\n\t\t\t\t\t// (Might have already been added from the \"fields\" property)\n\t\t\t\t\tif (!in_array($sFieldId, $aFieldsDMOnlyAttCodes))\n\t\t\t\t\t{\n\t\t\t\t\t\t$aFieldsDMOnlyAttCodes[] = $sFieldId;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise we proceed as usual\n\t\t\t\tforeach (explode(' ', $sFieldFlags) as $sFieldFlag)\n\t\t\t\t{\n\t\t\t\t\tif ($sFieldFlag !== '')\n\t\t\t\t\t{\n\t\t\t\t\t\t$sConst = 'OPT_ATT_'.strtoupper(str_replace('_', '', $sFieldFlag));\n\t\t\t\t\t\tif (defined($sConst))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$iFieldFlags = $iFieldFlags | constant($sConst);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIssueLog::Error(__METHOD__.' at line '.__LINE__.' : Flag \"'.$sFieldFlag.'\" is not valid for field [@data-field-id=\"'.$sFieldId.'\"] in form[@id=\"'.$this->aFormProperties['id'].'\"]');\n\t\t\t\t\t\t\tthrow new Exception('Flag \"'.$sFieldFlag.'\" is not valid for field [@data-field-id=\"'.$sFieldId.'\"] in form[@id=\"'.$this->aFormProperties['id'].'\"]');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Checking if field has form_path, if not, we add it\n\t\t\t\tif (!$oFieldNode->hasAttribute('data-form-path'))\n\t\t\t\t{\n\t\t\t\t\t$oFieldNode->setAttribute('data-form-path', $oForm->GetId());\n\t\t\t\t}\n\t\t\t\t// Checking if field should be displayed opened (For linked set)\n\t\t\t\tif ($oFieldNode->hasAttribute('data-field-opened') && ($oFieldNode->getAttribute('data-field-opened') === 'true'))\n\t\t\t\t{\n\t\t\t\t\t$aFieldsExtraData[$sFieldId]['opened'] = true;\n\t\t\t\t}\n\t\t\t\t// Checking if field allows to ignore scope (For linked set)\n\t\t\t\tif ($oFieldNode->hasAttribute('data-field-ignore-scopes') && ($oFieldNode->getAttribute('data-field-ignore-scopes') === 'true'))\n\t\t\t\t{\n\t\t\t\t\t$aFieldsExtraData[$sFieldId]['ignore_scopes'] = true;\n\t\t\t\t}\n\t\t\t\t// Checking field display mode\n\t\t\t\tif ($oFieldNode->hasAttribute('data-field-display-mode') && $oFieldNode->getAttribute('data-field-display-mode') !== '')\n\t\t\t\t{\n\t\t\t\t\t$aFieldsExtraData[$sFieldId]['display_mode'] = $oFieldNode->getAttribute('data-field-display-mode');\n\t\t\t\t}\n\t\t\t\telseif (isset($this->aFormProperties['properties']['display_mode']))\n\t\t\t\t{\n\t\t\t\t\t$aFieldsExtraData[$sFieldId]['display_mode'] = $this->aFormProperties['properties']['display_mode'];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$aFieldsExtraData[$sFieldId]['display_mode'] = ApplicationHelper::FORM_DEFAULT_DISPLAY_MODE;\n\t\t\t\t}\n\n\t\t\t\t// Finally adding field to the list\n\t\t\t\tif (!array_key_exists($sFieldId, $aFieldsAtts))\n\t\t\t\t{\n\t\t\t\t\t$aFieldsAtts[$sFieldId] = OPT_ATT_NORMAL;\n\t\t\t\t}\n\t\t\t\t$aFieldsAtts[$sFieldId] = $aFieldsAtts[$sFieldId] | $iFieldFlags;\n\t\t\t}\n\n\t\t\t// Adding rendered template to the form renderer as the base layout\n\t\t\t$this->oRenderer->SetBaseLayout($oHtmlDocument->saveHTML());\n\t\t}\n\n\t\t// Merging flags from metamodel with those from the form\n\t\t// Also, retrieving mandatory attributes from metamodel to be able to complete the form with them if necessary\n\t\t//\n\t\t// Note: When in a transition, we don't do this for fields that should be set from DM\n\t\tif ($this->aFormProperties['type'] !== 'static')\n\t\t{\n\t\t\tif ($this->IsTransitionForm())\n\t\t\t{\n\t\t\t\t$aDatamodelAttCodes = $this->oObject->GetTransitionAttributes($this->aFormProperties['stimulus_code']);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$aDatamodelAttCodes = MetaModel::ListAttributeDefs($sObjectClass);\n\t\t\t}\n\n\t\t\tforeach ($aDatamodelAttCodes as $sAttCode => $value)\n\t\t\t{\n\t\t\t\t/** var AttributeDefinition $oAttDef */\n\n\t\t\t\t// Skipping fields that should come from DM only as they will be process later on\n\t\t\t\tif (in_array($sAttCode, $aFieldsDMOnlyAttCodes))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Retrieving object flags\n\t\t\t\tif ($this->IsTransitionForm())\n\t\t\t\t{\n\t\t\t\t\t// Retrieving only mandatory flag from DM when on a transition\n\t\t\t\t\t$iFieldFlags = $value & OPT_ATT_MANDATORY;\n\t\t\t\t\t$oAttDef = MetaModel::GetAttributeDef(get_class($this->oObject), $sAttCode);\n\t\t\t\t}\n\t\t\t\telseif ($this->oObject->IsNew())\n\t\t\t\t{\n\t\t\t\t\t$iFieldFlags = $this->oObject->GetInitialStateAttributeFlags($sAttCode);\n\t\t\t\t\t$oAttDef = $value;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$iFieldFlags = $this->oObject->GetAttributeFlags($sAttCode);\n\t\t\t\t\t$oAttDef = $value;\n\t\t\t\t}\n\n\t\t\t\t// Skipping fields that were not specified to DM only list (garbage collector)\n\t\t\t\tif ($this->IsTransitionForm() && !array_key_exists($sAttCode, $aFieldsAtts))\n\t\t\t\t{\n\t\t\t\t\tif ((($value & OPT_ATT_MANDATORY) === OPT_ATT_MANDATORY && $oAttDef->IsNull($this->oObject->Get($sAttCode)))\n\t\t\t\t\t\t|| (($value & OPT_ATT_MUSTPROMPT) === OPT_ATT_MUSTPROMPT)\n\t\t\t\t\t\t|| (($value & OPT_ATT_MUSTCHANGE) === OPT_ATT_MUSTCHANGE))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!in_array($sAttCode, $aFieldsDMOnlyAttCodes))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$aFieldsDMOnlyAttCodes[] = $sAttCode;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Merging flags with those from the form definition\n\t\t\t\t// - If the field is in fields list\n\t\t\t\tif (array_key_exists($sAttCode, $aFieldsAtts))\n\t\t\t\t{\n\t\t\t\t\t// .. We merge them all\n\t\t\t\t\t$aFieldsAtts[$sAttCode] = $aFieldsAtts[$sAttCode] | $iFieldFlags;\n\t\t\t\t}\n\t\t\t\t// - or it is mandatory and has no value\n\t\t\t\tif ((($iFieldFlags & OPT_ATT_MANDATORY) === OPT_ATT_MANDATORY) && ($this->oObject->Get($sAttCode) === ''))\n\t\t\t\t{\n\t\t\t\t\tif (!array_key_exists($sAttCode, $aFieldsAtts))\n\t\t\t\t\t{\n\t\t\t\t\t\t$aFieldsAtts[$sAttCode] = OPT_ATT_NORMAL;\n\t\t\t\t\t}\n\t\t\t\t\t$aFieldsAtts[$sAttCode] = $aFieldsAtts[$sAttCode] | OPT_ATT_MANDATORY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Adding fields with DM flags only\n\t\t// Note: This should only happen when in a transition\n\t\tforeach ($aFieldsDMOnlyAttCodes as $sAttCode)\n\t\t{\n\t\t\t// Retrieving object flags from DM\n\t\t\tif ($this->IsTransitionForm())\n\t\t\t{\n\t\t\t\t$aTransitionAtts = $this->oObject->GetTransitionAttributes($this->aFormProperties['stimulus_code']);\n\t\t\t\t$iFieldFlags = $aTransitionAtts[$sAttCode];\n\t\t\t}\n\t\t\telseif ($this->oObject->IsNew())\n\t\t\t{\n\t\t\t\t$iFieldFlags = $this->oObject->GetInitialStateAttributeFlags($sAttCode);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$iFieldFlags = $this->oObject->GetAttributeFlags($sAttCode);\n\t\t\t}\n\n\t\t\t// Resetting/Forcing flag to read/write\n\t\t\t$aFieldsAtts[$sAttCode] = OPT_ATT_NORMAL;\n\t\t\t// Checking if field should be must_change\n\t\t\tif (($iFieldFlags & OPT_ATT_MUSTCHANGE) === OPT_ATT_MUSTCHANGE)\n\t\t\t{\n\t\t\t\t$aFieldsAtts[$sAttCode] = $aFieldsAtts[$sAttCode] | OPT_ATT_MUSTCHANGE;\n\t\t\t}\n\t\t\t// Checking if field should be must_prompt\n\t\t\tif (($iFieldFlags & OPT_ATT_MUSTPROMPT) === OPT_ATT_MUSTPROMPT)\n\t\t\t{\n\t\t\t\t$aFieldsAtts[$sAttCode] = $aFieldsAtts[$sAttCode] | OPT_ATT_MUSTPROMPT;\n\t\t\t}\n\t\t\t// Checking if field should be mandatory\n\t\t\tif (($iFieldFlags & OPT_ATT_MANDATORY) === OPT_ATT_MANDATORY)\n\t\t\t{\n\t\t\t\t$aFieldsAtts[$sAttCode] = $aFieldsAtts[$sAttCode] | OPT_ATT_MANDATORY;\n\t\t\t}\n\t\t}\n\n\t\t// Building the form\n\t\tforeach ($aFieldsAtts as $sAttCode => $iFieldFlags)\n\t\t{\n\t\t\t$oAttDef = MetaModel::GetAttributeDef(get_class($this->oObject), $sAttCode);\n\n\t\t\t/** @var Field $oField */\n\t\t\t$oField = null;\n\t\t\tif (is_callable(get_class($oAttDef).'::MakeFormField'))\n\t\t\t{\n\t\t\t\t$oField = $oAttDef->MakeFormField($this->oObject);\n\t\t\t}\n\n\t\t\t// Failsafe for AttributeType that would not have MakeFormField and therefore could not be used in a form\n\t\t\tif ($oField !== null)\n\t\t\t{\n\t\t\t\tif ($this->sMode !== static::ENUM_MODE_VIEW)\n\t\t\t\t{\n\t\t\t\t\t// Field dependencies\n\t\t\t\t\t$aFieldDependencies = $oAttDef->GetPrerequisiteAttributes();\n\t\t\t\t\tif (!empty($aFieldDependencies))\n\t\t\t\t\t{\n\t\t\t\t\t\t$oForm->AddFieldDependencies($oField->GetId(), $aFieldDependencies);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Setting the field flags\n\t\t\t\t\t// - If it's locked because slave, we force it as read only\n\t\t\t\t\tif (($iFieldFlags & OPT_ATT_SLAVE) === OPT_ATT_SLAVE)\n\t\t\t\t\t{\n\t\t\t\t\t\t$oField->SetReadOnly(true);\n\t\t\t\t\t}\n\t\t\t\t\t// - Else if it's must change (transition), we force it as mustchange, not readonly and not hidden\n\t\t\t\t\telseif (($iFieldFlags & OPT_ATT_MUSTCHANGE) === OPT_ATT_MUSTCHANGE && $this->IsTransitionForm())\n\t\t\t\t\t{\n\t\t\t\t\t\t$oField->SetMustChange(true);\n\t\t\t\t\t\t$oField->SetReadOnly(false);\n\t\t\t\t\t\t$oField->SetHidden(false);\n\t\t\t\t\t}\n\t\t\t\t\t// - Else if it's must prompt (transition), we force it as not readonly and not hidden\n\t\t\t\t\telseif (($iFieldFlags & OPT_ATT_MUSTPROMPT) === OPT_ATT_MUSTPROMPT && $this->IsTransitionForm())\n\t\t\t\t\t{\n\t\t\t\t\t\t$oField->SetReadOnly(false);\n\t\t\t\t\t\t$oField->SetHidden(false);\n\t\t\t\t\t}\n\t\t\t\t\t// - Else if it wasn't mandatory or already had a value, and it's hidden, we force it as hidden\n\t\t\t\t\telseif (($iFieldFlags & OPT_ATT_HIDDEN) === OPT_ATT_HIDDEN)\n\t\t\t\t\t{\n\t\t\t\t\t\t$oField->SetHidden(true);\n\t\t\t\t\t}\n\t\t\t\t\telseif (($iFieldFlags & OPT_ATT_READONLY) === OPT_ATT_READONLY)\n\t\t\t\t\t{\n\t\t\t\t\t\t$oField->SetReadOnly(true);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Normal field, use \"flags\" set by AttDef::MakeFormField()\n\t\t\t\t\t\t// Except if we are in a transition be cause $oAttDef doesn't know if the form is for a transition\n\t\t\t\t\t\tif ($this->IsTransitionForm())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$oField->SetReadOnly(false);\n\t\t\t\t\t\t\t$oField->SetHidden(false);\n\t\t\t\t\t\t\t$oField->SetMandatory(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Finally, if it's mandatory ...\n\t\t\t\t\tif (($iFieldFlags & OPT_ATT_MANDATORY) === OPT_ATT_MANDATORY)\n\t\t\t\t\t{\n\t\t\t\t\t\t// ... and when in a transition, we force it as mandatory\n\t\t\t\t\t\tif ($this->IsTransitionForm() && $oAttDef->IsNull($this->oObject->Get($sAttCode)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$oField->SetMandatory(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// .. and has no value, we force it as mandatory\n\t\t\t\t\t\telseif ($oAttDef->IsNull($this->oObject->Get($sAttCode)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$oField->SetMandatory(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Specific operation on field\n\t\t\t\t\t// - Field that require a transaction id\n\t\t\t\t\tif (in_array(get_class($oField),\n\t\t\t\t\t\tarray('Combodo\\\\iTop\\\\Form\\\\Field\\\\TextAreaField', 'Combodo\\\\iTop\\\\Form\\\\Field\\\\CaseLogField')))\n\t\t\t\t\t{\n\t\t\t\t\t\t/** @var \\Combodo\\iTop\\Form\\Field\\TextAreaField|\\Combodo\\iTop\\Form\\Field\\CaseLogField $oField */\n\t\t\t\t\t\t$oField->SetTransactionId($oForm->GetTransactionId());\n\t\t\t\t\t}\n\t\t\t\t\t// - Field that require a search endpoint\n\t\t\t\t\tif (in_array(get_class($oField),\n\t\t\t\t\t\tarray('Combodo\\\\iTop\\\\Form\\\\Field\\\\SelectObjectField', 'Combodo\\\\iTop\\\\Form\\\\Field\\\\LinkedSetField')))\n\t\t\t\t\t{\n\t\t\t\t\t\t/** @var \\Combodo\\iTop\\Form\\Field\\SelectObjectField|\\Combodo\\iTop\\Form\\Field\\LinkedSetField $oField */\n\t\t\t\t\t\tif ($this->oContainer !== null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$sSearchEndpoint = $this->oContainer->get('url_generator')->generate('p_object_search_generic', array(\n\t\t\t\t\t\t\t\t'sTargetAttCode' => $oAttDef->GetCode(),\n\t\t\t\t\t\t\t\t'sHostObjectClass' => get_class($this->oObject),\n\t\t\t\t\t\t\t\t'sHostObjectId' => ($this->oObject->IsNew()) ? null : $this->oObject->GetKey(),\n\t\t\t\t\t\t\t\t'ar_token' => $this->GetActionRulesToken(),\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t$oField->SetSearchEndpoint($sSearchEndpoint);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// - Field that require an information endpoint\n\t\t\t\t\tif (in_array(get_class($oField), array('Combodo\\\\iTop\\\\Form\\\\Field\\\\LinkedSetField')))\n\t\t\t\t\t{\n\t\t\t\t\t\t/** @var \\Combodo\\iTop\\Form\\Field\\LinkedSetField $oField */\n\t\t\t\t\t\tif ($this->oContainer !== null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$oField->SetInformationEndpoint($this->oContainer->get('url_generator')->generate('p_object_get_information_json'));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// - Field that require to apply scope on its DM OQL\n\t\t\t\t\tif (in_array(get_class($oField), array('Combodo\\\\iTop\\\\Form\\\\Field\\\\SelectObjectField')))\n\t\t\t\t\t{\n\t\t\t\t\t\t/** @var \\Combodo\\iTop\\Form\\Field\\SelectObjectField $oField */\n\t\t\t\t\t\tif ($this->oContainer !== null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$oScopeOriginal = ($oField->GetSearch() !== null) ? $oField->GetSearch() : DBSearch::FromOQL($oAttDef->GetValuesDef()->GetFilterExpression());\n\n\t\t\t\t\t\t\t/** @var \\DBSearch $oScopeSearch */\n\t\t\t\t\t\t\t$oScopeSearch = $this->oContainer->get('scope_validator')->GetScopeFilterForProfiles(UserRights::ListProfiles(),\n\t\t\t\t\t\t\t\t$oScopeOriginal->GetClass(), UR_ACTION_READ);\n\t\t\t\t\t\t\tif ($oScopeSearch === null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tIssueLog::Info(__METHOD__.' at line '.__LINE__.' : User #'.UserRights::GetUserId().' has no scope query for '.$oScopeOriginal->GetClass().' class.');\n\t\t\t\t\t\t\t\tthrow new HttpException(Response::HTTP_NOT_FOUND, Dict::S('UI:ObjectDoesNotExist'));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$oScopeOriginal = $oScopeOriginal->Intersect($oScopeSearch);\n\t\t\t\t\t\t\t// Note : This is to skip the silo restriction on the final query\n\t\t\t\t\t\t\tif ($oScopeSearch->IsAllDataAllowed())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$oScopeOriginal->AllowAllData();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$oScopeOriginal->SetInternalParams(array('this' => $this->oObject));\n\t\t\t\t\t\t\t$oField->SetSearch($oScopeOriginal);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// - Field that require to check if the current value is among allowed ones\n\t\t\t\t\tif (in_array(get_class($oField), array('Combodo\\\\iTop\\\\Form\\\\Field\\\\SelectObjectField')))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Note: We can't do this in AttributeExternalKey::MakeFormField() in the Field::SetOnFinalizeCallback() because at this point we have no information about the portal scope and ignore_silos flag, hence it always applies silos.\n\t\t\t\t\t\t// As a workaround we have to manually check if the field's current value is among the scope\n\t\t\t\t\t\t$oField->VerifyCurrentValue();\n\t\t\t\t\t}\n\t\t\t\t\t// - Field that require processing on their subfields\n\t\t\t\t\tif (in_array(get_class($oField), array('Combodo\\\\iTop\\\\Form\\\\Field\\\\SubFormField')))\n\t\t\t\t\t{\n\t\t\t\t\t\t/** @var \\Combodo\\iTop\\Form\\Field\\SubFormField $oField */\n\t\t\t\t\t\t$oSubForm = $oField->GetForm();\n\t\t\t\t\t\tif ($oAttDef->GetEditClass() === 'CustomFields')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Retrieving only user data fields (not the metadata fields of the template)\n\t\t\t\t\t\t\tif ($oSubForm->HasField('user_data'))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/** @var \\Combodo\\iTop\\Form\\Field\\SubFormField $oUserDataField */\n\t\t\t\t\t\t\t\t$oUserDataField = $oSubForm->GetField('user_data');\n\t\t\t\t\t\t\t\t$oUserDataForm = $oUserDataField->GetForm();\n\t\t\t\t\t\t\t\tforeach ($oUserDataForm->GetFields() as $oCustomField)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// - Field that require a search endpoint (OQL based dropdown list fields)\n\t\t\t\t\t\t\t\t\tif (in_array(get_class($oCustomField), array('Combodo\\\\iTop\\\\Form\\\\Field\\\\SelectObjectField')))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t/** @var \\Combodo\\iTop\\Form\\Field\\SelectObjectField $oCustomField */\n\t\t\t\t\t\t\t\t\t\tif ($this->oContainer !== null)\n\t\t\t\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t\t\t\t$sSearchEndpoint = $this->oContainer->get('url_generator')->generate('p_object_search_generic',\n\t\t\t\t\t\t\t\t\t\t\t\tarray(\n\t\t\t\t\t\t\t\t\t\t\t\t\t'sTargetAttCode' => $oAttDef->GetCode(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t'sHostObjectClass' => get_class($this->oObject),\n\t\t\t\t\t\t\t\t\t\t\t\t\t'sHostObjectId' => ($this->oObject->IsNew()) ? null : $this->oObject->GetKey(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t'ar_token' => $this->GetActionRulesToken(),\n\t\t\t\t\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t\t\t\t\t$oCustomField->SetSearchEndpoint($sSearchEndpoint);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// - Field that require to check if the current value is among allowed ones\n\t\t\t\t\t\t\t\t\tif (in_array(get_class($oCustomField), array('Combodo\\\\iTop\\\\Form\\\\Field\\\\SelectObjectField')))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t/** @var \\Combodo\\iTop\\Form\\Field\\SelectObjectField $oCustomField */\n\t\t\t\t\t\t\t\t\t\t$oCustomField->VerifyCurrentValue();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (($iFieldFlags & OPT_ATT_HIDDEN) === OPT_ATT_HIDDEN)\n\t\t\t\t\t{\n\t\t\t\t\t\t$oField->SetHidden(true);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$oField->SetReadOnly(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Specific operation on field\n\t\t\t\t// - LinkedSet\n\t\t\t\tif (in_array(get_class($oField), array('Combodo\\\\iTop\\\\Form\\\\Field\\\\LinkedSetField')))\n\t\t\t\t{\n\t\t\t\t\t/** @var \\Combodo\\iTop\\Form\\Field\\LinkedSetField $oField */\n\t\t\t\t\t/** @var \\AttributeLinkedSetIndirect $oAttDef */\n\t\t\t\t\t//   - Overriding attributes to display\n\t\t\t\t\tif ($this->oContainer !== null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Note : This snippet is inspired from AttributeLinkedSet::MakeFormField()\n\t\t\t\t\t\t$aAttCodesToDisplay = ApplicationHelper::GetLoadedListFromClass($this->oContainer->getParameter('combodo.portal.instance.conf')['lists'],\n\t\t\t\t\t\t\t$oField->GetTargetClass(), 'list');\n\t\t\t\t\t\t// - Adding friendlyname attribute to the list is not already in it\n\t\t\t\t\t\t$sTitleAttCode = 'friendlyname';\n\t\t\t\t\t\tif (($sTitleAttCode !== null) && !in_array($sTitleAttCode, $aAttCodesToDisplay))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$aAttCodesToDisplay = array_merge(array($sTitleAttCode), $aAttCodesToDisplay);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// - Adding attribute labels\n\t\t\t\t\t\t$aAttributesToDisplay = array();\n\t\t\t\t\t\tforeach ($aAttCodesToDisplay as $sAttCodeToDisplay)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$oAttDefToDisplay = MetaModel::GetAttributeDef($oField->GetTargetClass(), $sAttCodeToDisplay);\n\t\t\t\t\t\t\t$aAttributesToDisplay[$sAttCodeToDisplay] = $oAttDefToDisplay->GetLabel();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$oField->SetAttributesToDisplay($aAttributesToDisplay);\n\t\t\t\t\t}\n\t\t\t\t\t//    - Filtering links regarding scopes\n\t\t\t\t\tif ($this->oContainer !== null)\n\t\t\t\t\t{\n\t\t\t\t\t\t$aLimitedAccessItemIDs = array();\n\n\t\t\t\t\t\t/** @var \\ormLinkSet $oFieldOriginalSet */\n\t\t\t\t\t\t$oFieldOriginalSet = $oField->GetCurrentValue();\n\t\t\t\t\t\twhile ($oLink = $oFieldOriginalSet->Fetch())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ($oField->IsIndirect())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$iRemoteKey = $oLink->Get($oAttDef->GetExtKeyToRemote());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$iRemoteKey = $oLink->GetKey();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!$this->oContainer->get('security_helper')->IsActionAllowed(UR_ACTION_READ, $oField->GetTargetClass(), $iRemoteKey))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$aLimitedAccessItemIDs[] = $iRemoteKey;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$oFieldOriginalSet->rewind();\n\t\t\t\t\t\t$oField->SetLimitedAccessItemIDs($aLimitedAccessItemIDs);\n\t\t\t\t\t}\n\t\t\t\t\t//    - Displaying as opened\n\t\t\t\t\tif (array_key_exists($sAttCode, $aFieldsExtraData) && array_key_exists('opened', $aFieldsExtraData[$sAttCode]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$oField->SetDisplayOpened(true);\n\t\t\t\t\t}\n\t\t\t\t\t//    - Displaying out of scopes items\n\t\t\t\t\tif (array_key_exists($sAttCode, $aFieldsExtraData) && array_key_exists('ignore_scopes', $aFieldsExtraData[$sAttCode]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$oField->SetDisplayLimitedAccessItems(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// - BlobField\n\t\t\t\tif (in_array(get_class($oField), array('Combodo\\\\iTop\\\\Form\\\\Field\\\\BlobField', 'Combodo\\\\iTop\\\\Form\\\\Field\\\\ImageField')))\n\t\t\t\t{\n\t\t\t\t\t//   - Overriding attributes to display\n\t\t\t\t\tif ($this->oContainer !== null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Override hardcoded URLs in ormDocument pointing to back office console\n\t\t\t\t\t\t$sDisplayUrl = $this->oContainer->get('url_generator')->generate('p_object_document_display', array('sObjectClass' => get_class($this->oObject), 'sObjectId' => $this->oObject->GetKey(), 'sObjectField' => $sAttCode, 'cache' => 86400));\n\t\t\t\t\t\t$sDownloadUrl = $this->oContainer->get('url_generator')->generate('p_object_document_download', array('sObjectClass' => get_class($this->oObject), 'sObjectId' => $this->oObject->GetKey(), 'sObjectField' => $sAttCode, 'cache' => 86400));\n\t\t\t\t\t\t/** @var \\Combodo\\iTop\\Form\\Field\\BlobField $oField */\n\t\t\t\t\t\t$oField->SetDisplayUrl($sDisplayUrl)\n\t\t\t\t\t\t\t->SetDownloadUrl($sDownloadUrl);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$oField = new LabelField($sAttCode);\n\t\t\t\t$oField->SetReadOnly(true)\n\t\t\t\t\t->SetHidden(false)\n\t\t\t\t\t->SetCurrentValue('Sorry, that AttributeType is not implemented yet.')\n\t\t\t\t\t->SetLabel($oAttDef->GetLabel());\n\t\t\t}\n\n\t\t\t// Setting field display mode\n\t\t\tif (array_key_exists($sAttCode, $aFieldsExtraData) && array_key_exists('display_mode', $aFieldsExtraData[$sAttCode]))\n\t\t\t{\n\t\t\t\t$oField->SetDisplayMode($aFieldsExtraData[$sAttCode]['display_mode']);\n\t\t\t}\n\n\t\t\t// Overload (AttributeDefinition) flags metadata as they have been changed while building the form\n\t\t\t$oField->AddMetadata('attribute-flag-hidden', $oField->GetHidden() ? 'true' : 'false');\n\t\t\t$oField->AddMetadata('attribute-flag-read-only', $oField->GetReadOnly() ? 'true' : 'false');\n\t\t\t$oField->AddMetadata('attribute-flag-mandatory', $oField->GetMandatory() ? 'true' : 'false');\n\t\t\t$oField->AddMetadata('attribute-flag-must-change', $oField->GetMustChange() ? 'true' : 'false');\n\n\t\t\t// Do not add hidden fields as they are of no use, if one is necessary because another depends on it, it will be automatically added.\n\t\t\t// Note: We do this at the end because during the process an hidden field could have become writable if mandatory and empty for example.\n\t\t\tif($oField->GetHidden() === false)\n\t\t\t{\n\t\t\t\t$oForm->AddField($oField);\n\t\t\t} else {\n\t\t\t\t$this->aHiddenFieldsId[]=$oField->GetId();\n\t\t\t}\n\t\t}\n\n\t\t// Checking dependencies to ensure that all needed fields are in the form\n\t\t// (This is kind of a garbage collector for dependencies)\n\t\tforeach ($oForm->GetDependencies() as $sImpactedFieldId => $aDependencies)\n\t\t{\n\t\t\tforeach ($aDependencies as $sDependencyFieldId)\n\t\t\t{\n\t\t\t\tif (!$oForm->HasField($sDependencyFieldId))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\t$oAttDef = MetaModel::GetAttributeDef(get_class($this->oObject), $sDependencyFieldId);\n\t\t\t\t\t\t$oField = $oAttDef->MakeFormField($this->oObject);\n\t\t\t\t\t\t$oField->SetHidden(true);\n\n\t\t\t\t\t\t$oForm->AddField($oField);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception $e)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Avoid blocking a form if a RequestTemplate reference a bad attribute (e.g. :this->id)\n\t\t\t\t\t\tIssueLog::Error('May be a bad OQL (referencing :this->id) in a RequestTemplate causes the following error');\n\t\t\t\t\t\tIssueLog::Error($e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Checking if the instance has attachments\n\t\tif (class_exists('Attachment') && class_exists('AttachmentPlugIn'))\n\t\t{\n\t\t\t// Checking if the object is allowed for attachments\n\t\t\t$bClassAllowed = false;\n\t\t\t$aAllowedClasses = MetaModel::GetModuleSetting('itop-attachments', 'allowed_classes', array('Ticket'));\n\t\t\tforeach ($aAllowedClasses as $sAllowedClass)\n\t\t\t{\n\t\t\t\tif ($this->oObject instanceof $sAllowedClass)\n\t\t\t\t{\n\t\t\t\t\t$bClassAllowed = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Adding attachment field\n\t\t\tif ($bClassAllowed)\n\t\t\t{\n\t\t\t\t// set id to a unique key - avoid collisions with another attribute that could exist with the name 'attachments'\n\t\t\t\t$oField = new FileUploadField('attachments_plugin');\n\t\t\t\t$oField->SetLabel(Dict::S('Portal:Attachments'))\n\t\t\t\t\t->SetUploadEndpoint($this->oContainer->get('url_generator')->generate('p_object_attachment_add'))\n\t\t\t\t\t->SetDownloadEndpoint($this->oContainer->get('url_generator')->generate('p_object_attachment_download',\n\t\t\t\t\t\tarray('sAttachmentId' => '-sAttachmentId-')))\n\t\t\t\t\t->SetTransactionId($oForm->GetTransactionId())\n\t\t\t\t\t->SetAllowDelete($this->oContainer->getParameter('combodo.portal.instance.conf')['properties']['attachments']['allow_delete'])\n\t\t\t\t\t->SetObject($this->oObject);\n\n\t\t\t\t// Checking if we can edit attachments in the current state\n\t\t\t\tif (($this->sMode === static::ENUM_MODE_VIEW)\n\t\t\t\t\t|| AttachmentPlugIn::IsReadonlyState($this->oObject, $this->oObject->GetState(),\n\t\t\t\t\t\tAttachmentPlugIn::ENUM_GUI_PORTALS) === true\n\t\t\t\t\t|| $oForm->GetEditableFieldCount(true) === 0)\n\t\t\t\t{\n\t\t\t\t\t$oField->SetReadOnly(true);\n\t\t\t\t}\n\n\t\t\t\t// Adding attachements field in transition only if it is editable\n\t\t\t\tif (!$this->IsTransitionForm() || ($this->IsTransitionForm() && !$oField->GetReadOnly()))\n\t\t\t\t{\n\t\t\t\t\t$oForm->AddField($oField);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t$oForm->Finalize();\n\t\t$this->oForm = $oForm;\n\t\t$this->oRenderer->SetForm($this->oForm);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t *\n\t * @throws \\CoreException\n\t * @throws \\CoreUnexpectedValue\n\t * @throws \\DeleteException\n\t * @throws \\MySQLException\n\t * @throws \\OQLException\n\t */\n\tpublic function OnCancel($aArgs = null)\n\t{\n\t\t// Ask to each field to clean itself\n\t\t/** @var \\Combodo\\iTop\\Form\\Field\\Field $oField */\n\t\tforeach ($this->oForm->GetFields() as $oField)\n\t\t{\n\t\t\t$oField->OnCancel();\n\t\t}\n\t\t// Then clean inline images from rich text editor such as TextareaField\n\t\t// Note : This could be done by TextareaField::OnCancel(), but we consider that could have been done in this form outside the field.\n\t\t// Also, it would require the field to know the transaction id which it doesn't as of today.\n\t\tInlineImage::OnFormCancel(utils::GetUploadTempId($this->oForm->GetTransactionId()));\n\t\t// Then clean attachments\n\t\t// TODO : This has to be refactored when the function from itop-attachments has been migrated into the core\n\t\t$this->CancelAttachments();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic function CheckTransaction(&$aData)\n\t{\n\t\t$isTransactionValid = \\utils::IsTransactionValid($this->oForm->GetTransactionId(), false); //The transaction token is kept in order to preserve BC with ajax forms (the second call would fail if the token is deleted). (The GC will take care of cleaning the token for us later on)\n\t\tif (!$isTransactionValid) {\n\t\t\tif ($this->oObject->IsNew()) {\n\t\t\t\t$sError = Dict::S('UI:Error:ObjectAlreadyCreated');\n\t\t\t} else {\n\t\t\t\t$sError = Dict::S('UI:Error:ObjectAlreadyUpdated');\n\t\t\t}\n\n\t\t\t$aData['messages']['error'] += [\n\t\t\t\t'_main' => [$sError]\n\t\t\t];\n\t\t\t$aData['valid'] = false;\n\t\t}\n\t}\n\n\t/**\n\t * Validates the form and returns an array with the validation status and the messages.\n\t * If the form is valid, creates/updates the object.\n\t *\n\t * eg :\n\t *  array(\n\t *      'status' => true|false\n\t *      'messages' => array(\n\t *          'errors' => array()\n\t *    )\n\t *\n\t * @inheritDoc\n\t *\n\t * @throws \\ArchivedObjectException\n\t * @throws \\CoreException\n\t * @throws \\CoreUnexpectedValue\n\t * @throws \\MySQLException\n\t * @throws \\MySQLHasGoneAwayException\n\t * @throws \\OQLException\n\t */\n\tpublic function OnSubmit($aArgs = null)\n\t{\n\t\t$aData = parent::OnSubmit($aArgs);\n\n\t\tif (! $aData['valid']) {\n\t\t\treturn $aData;\n\t\t}\n\n\t\t// Update object and form\n\t\t$this->OnUpdate($aArgs);\n\n\t\t// Check if form valid\n\t\tif (! $this->oForm->Validate())\n\t\t{\n\t\t\t// Handle errors\n\t\t\t$aData['valid'] = false;\n\t\t\t$aData['messages']['error'] += $this->oForm->GetErrorMessages();\n\t\t\treturn $aData;\n\t\t}\n\n\t\t$sObjectClass = get_class($this->oObject);\n\n\t\ttry {\n\t\t\t// Forcing allowed writing on the object if necessary. This is used in some particular cases.\n\t\t\t$bAllowWrite = ($sObjectClass === 'Person' && $this->oObject->GetKey() == UserRights::GetContactId());\n\t\t\tif ($bAllowWrite) {\n\t\t\t\t$this->oObject->AllowWrite(true);\n\t\t\t}\n\n\t\t\t// Writing object to DB\n\t\t\t$bIsNew = $this->oObject->IsNew();\n\t\t\t$bWasModified = $this->oObject->IsModified();\n\t\t\t$bActivateTriggers = (!$bIsNew && $bWasModified);\n\t\t\ttry\n\t\t\t{\n\t\t\t\t$this->oObject->DBWrite();\n\t\t\t}\n\t\t\tcatch (Exception $e) {\n\t\t\t\tif ($bIsNew) {\n\t\t\t\t\tthrow new Exception(Dict::S('Portal:Error:ObjectCannotBeCreated'));\n\t\t\t\t}\n\t\t\t\tthrow new Exception(Dict::S('Portal:Error:ObjectCannotBeUpdated'));\n\t\t\t}\n\t\t\t// Finalizing images link to object, otherwise it will be cleaned by the GC\n\t\t\tInlineImage::FinalizeInlineImages($this->oObject);\n\t\t\t// Finalizing attachments link to object\n\t\t\t// TODO : This has to be refactored when the function from itop-attachments has been migrated into the core\n\t\t\tif (isset($aArgs['attachmentIds']))\n\t\t\t{\n\t\t\t\t$this->FinalizeAttachments($aArgs['attachmentIds']);\n\t\t\t}\n\n\t\t\t// Checking if we have to apply a stimulus\n\t\t\tif (isset($aArgs['applyStimulus']))\n\t\t\t{\n\t\t\t\t$this->oObject->ApplyStimulus($aArgs['applyStimulus']['code']);\n\t\t\t}\n\t\t\t// Activating triggers only on update\n\t\t\tif ($bActivateTriggers)\n\t\t\t{\n\t\t\t\t$sTriggersQuery = $this->oContainer->getParameter('combodo.portal.instance.conf')['properties']['triggers_query'];\n\t\t\t\tif ($sTriggersQuery !== null)\n\t\t\t\t{\n\t\t\t\t\t$aParentClasses = MetaModel::EnumParentClasses($sObjectClass, ENUM_PARENT_CLASSES_ALL);\n\t\t\t\t\t$oTriggerSet = new DBObjectSet(DBObjectSearch::FromOQL($sTriggersQuery), array(),\n\t\t\t\t\t\tarray('parent_classes' => $aParentClasses));\n\t\t\t\t\t/** @var \\Trigger $oTrigger */\n\t\t\t\t\twhile ($oTrigger = $oTriggerSet->Fetch())\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$oTrigger->DoActivate($this->oObject->ToArgs('this'));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(Exception $e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tutils::EnrichRaisedException($oTrigger, $e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Resetting caselog fields value, otherwise the value will stay in it after submit.\n\t\t\t$this->oForm->ResetCaseLogFields();\n\n\t\t\tif ($bWasModified)\n\t\t\t{\n\t\t\t\t//=if (isNew) because $bActivateTriggers = (!$this->oObject->IsNew() && $this->oObject->IsModified())\n\t\t\t\tif(!$bActivateTriggers)\n\t\t\t\t{\n\t\t\t\t\t$aData['messages']['success'] += array(\t'_main' => array(Dict::Format('UI:Title:Object_Of_Class_Created', $this->oObject->GetName(),MetaModel::GetName(get_class($this->oObject)))));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$aData['messages']['success'] += array('_main' => array(Dict::Format('UI:Class_Object_Updated', MetaModel::GetName(get_class($this->oObject)), $this->oObject->GetName())));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception $e)\n\t\t{\n\t\t\t$aData['valid'] = false;\n\t\t\t$aData['messages']['error'] += array('_main' => array($e->getMessage()));\n\t\t\tIssueLog::Error(__METHOD__.' at line '.__LINE__.' : '.$e->getMessage());\n\t\t}\n\n\t\treturn $aData;\n\t}\n\n\t/**\n\t * Updates the form and its fields with the current values\n\t *\n\t * Note : Doesn't update the object, see ObjectFormManager::OnSubmit() for that;\n\t *\n\t * @inheritDoc\n\t *\n\t * @throws \\ArchivedObjectException\n\t * @throws \\CoreException\n\t * @throws \\CoreUnexpectedValue\n\t * @throws \\OQLException\n\t * @throws \\Exception\n\t */\n\tpublic function OnUpdate($aArgs = null)\n\t{\n\t\t$aFormProperties = array();\n\n\t\tif (is_array($aArgs))\n\t\t{\n\t\t\t// First we need to update the Object with its new values in order to enable the dependents fields to update\n\t\t\tif (isset($aArgs['currentValues']))\n\t\t\t{\n\t\t\t\t$aCurrentValues = $aArgs['currentValues'];\n\t\t\t\t$sObjectClass = get_class($this->oObject);\n\t\t\t\tforeach ($aCurrentValues as $sAttCode => $value)\n\t\t\t\t{\n\t\t\t\t\tif (MetaModel::IsValidAttCode($sObjectClass, $sAttCode))\n\t\t\t\t\t{\n\t\t\t\t\t\t/** @var \\AttributeDefinition $oAttDef */\n\t\t\t\t\t\t$oAttDef = MetaModel::GetAttributeDef($sObjectClass, $sAttCode);\n\t\t\t\t\t\tif ($oAttDef->IsLinkSet())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/** @var \\AttributeLinkedSet $oAttDef */\n\n\t\t\t\t\t\t\t// Parsing JSON value\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// Note : The value was passed as a string instead of an array because the attribute would not be included in the $aCurrentValues when empty.\n\t\t\t\t\t\t\t// Which was an issue when deleting all objects from linkedset\n\t\t\t\t\t\t\t$value = json_decode($value, true);\n\n\t\t\t\t\t\t\t/** @var \\ormLinkSet $oLinkSet */\n\t\t\t\t\t\t\t$oLinkSet = $this->oObject->Get($sAttCode);\n\t\t\t\t\t\t\t$sLinkedClass = $oAttDef->GetLinkedClass();\n\n\t\t\t\t\t\t\t// Checking links to remove\n\t\t\t\t\t\t\tif (isset($value['remove']))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tforeach ($value['remove'] as $iObjKey => $aObjData)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t$oLinkSet->RemoveItem($iObjKey);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Checking links to add\n\t\t\t\t\t\t\tif (isset($value['add']))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tforeach ($value['add'] as $iObjKey => $aObjdata)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Creating link when linkset is indirect...\n\t\t\t\t\t\t\t\t\tif ($oAttDef->IsIndirect())\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t/** @var \\AttributeLinkedSetIndirect $oAttDef */\n\t\t\t\t\t\t\t\t\t\t$oLink = MetaModel::NewObject($sLinkedClass);\n\t\t\t\t\t\t\t\t\t\t$oLink->Set($oAttDef->GetExtKeyToRemote(), $iObjKey);\n\t\t\t\t\t\t\t\t\t\t$oLink->Set($oAttDef->GetExtKeyToMe(), $this->oObject->GetKey());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// ... or adding remote object when linkset id direct\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t// Note : AllowAllData set to true here instead of checking scope's flag because we are displaying a value that has been set and validated\n\t\t\t\t\t\t\t\t\t\t$oLink = MetaModel::GetObject($sLinkedClass, $iObjKey, false, true);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ($oLink !== null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t$oLinkSet->AddItem($oLink);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Checking links to modify\n\t\t\t\t\t\t\t// TODO: Not implemented yet as we can't change lnk properties in the portal\n\n\t\t\t\t\t\t\t// Setting value in the object\n\t\t\t\t\t\t\t$this->oObject->Set($sAttCode, $oLinkSet);\n\t\t\t\t\t\t} elseif ($oAttDef instanceof AttributeSet) {\n\t\t\t\t\t\t\t/** @var \\ormSet $oTagSet */\n\t\t\t\t\t\t\t$oOrmSet = $this->oObject->Get($sAttCode);\n\t\t\t\t\t\t\tif (is_null($oOrmSet)) {\n\t\t\t\t\t\t\t\t$oOrmSet = new \\ormSet(get_class($this->oObject), $sAttCode, $oAttDef->GetMaxItems());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$oOrmSet->ApplyDelta(json_decode($value, true));\n\t\t\t\t\t\t\t$this->oObject->Set($sAttCode, $oOrmSet);\n\t\t\t\t\t\t} elseif ($oAttDef instanceof AttributeDateTime) // AttributeDate is derived from AttributeDateTime\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ($value != null) {\n\t\t\t\t\t\t\t\t$value = $oAttDef->GetFormat()->Parse($value);\n\t\t\t\t\t\t\t\tif (is_object($value)) {\n\t\t\t\t\t\t\t\t\t$value = $value->format($oAttDef->GetInternalFormat());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$this->oObject->Set($sAttCode, $value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telseif ($oAttDef->IsScalar() && is_array($value))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$this->oObject->Set($sAttCode, current($value));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telseif ($oAttDef->GetEditClass() === 'CustomFields')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// We don't update attribute as ormCustomField comparaison is not working as excepted.\n\t\t\t\t\t\t\t// When several templates available, \"template_id\" is not sent by the portal has it is a read-only select input\n\t\t\t\t\t\t\t// therefore, the TemplateFieldsHandler::CompareValues() doesn't work.\n\t\t\t\t\t\t\t// This use case works in the console as it always send all fields, even hidden and read-only.\n\n\t\t\t\t\t\t\t// Different templates\n\t\t\t\t\t\t\tif (isset($value['template_id'])\n\t\t\t\t\t\t\t\t&& ($value['template_id'] != $value['current_template_id']))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$this->oObject->Set($sAttCode, $value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Same template, different fields\n\t\t\t\t\t\t\telseif (isset($value['template_id'], $value['template_data'])\n\t\t\t\t\t\t\t\t&& ($value['template_id'] == $value['current_template_id'])\n\t\t\t\t\t\t\t\t&& ($value['template_data'] != $value['current_template_data']))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$this->oObject->Set($sAttCode, $value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Update of current values\n\t\t\t\t\t\t\telseif (isset($value['user_data']))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$this->oObject->Set($sAttCode, $value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Else don't update! Otherwise we might loose current value\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$this->oObject->Set($sAttCode, $value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$this->oObject->DoComputeValues();\n\t\t\t}\n\n\t\t\t// Then we retrieve properties of the form to build\n\t\t\tif (isset($aArgs['formProperties']))\n\t\t\t{\n\t\t\t\t$aFormProperties = $aArgs['formProperties'];\n\t\t\t}\n\t\t}\n\t\t// Then we build and update form\n\t\t// - We update form properties only we don't have any yet. This is a fallback for cases when form properties where not among the JSON data\n\t\tif ($this->GetFormProperties() === null)\n\t\t{\n\t\t\t$this->SetFormProperties($aFormProperties);\n\t\t}\n\t\t$this->Build();\n\t}\n\n\t/**\n\t * This is a temporary function until the Attachment refactoring is done. It should be remove once it's done.\n\t * It is inspired from itop-attachments/main.attachments.php / UpdateAttachments()\n\t *\n\t * @param array $aAttachmentIds\n\t *\n\t * @throws \\CoreException\n\t * @throws \\CoreUnexpectedValue\n\t * @throws \\DeleteException\n\t * @throws \\OQLException\n\t */\n\tprotected function FinalizeAttachments($aAttachmentIds)\n\t{\n\t\t$aRemovedAttachmentsIds = (isset($aAttachmentIds['removed_attachments_ids'])) ? $aAttachmentIds['removed_attachments_ids'] : array();\n\t\t// Not used for now. //$aActualAttachmentsIds = (isset($aAttachmentIds['actual_attachments_ids'])) ? $aAttachmentIds['actual_attachments_ids'] : array();\n\t\t$aActions = array();\n\n\t\t// Removing attachments from currents\n\t\tif (!empty($aRemovedAttachmentsIds))\n\t\t{\n\t\t\t$oSearch = DBObjectSearch::FromOQL(\"SELECT Attachment WHERE item_class = :class AND item_id = :item_id\");\n\t\t\t$oSet = new DBObjectSet($oSearch, array(), array('class' => get_class($this->oObject), 'item_id' => $this->oObject->GetKey()));\n\t\t\twhile ($oAttachment = $oSet->Fetch())\n\t\t\t{\n\t\t\t\t// Remove attachments that are no longer attached to the current object\n\t\t\t\tif (in_array($oAttachment->GetKey(), $aRemovedAttachmentsIds))\n\t\t\t\t{\n\t\t\t\t\t$oAttachment->DBDelete();\n\t\t\t\t\t$aActions[] = self::GetAttachmentActionChangeOp($oAttachment, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Processing temporary attachments\n\t\t$sTempId = utils::GetUploadTempId($this->oForm->GetTransactionId());\n\t\t$sOQL = 'SELECT Attachment WHERE temp_id = :temp_id';\n\t\t$oSearch = DBObjectSearch::FromOQL($sOQL);\n\t\t$oSet = new DBObjectSet($oSearch, array(), array('temp_id' => $sTempId));\n\t\twhile ($oAttachment = $oSet->Fetch())\n\t\t{\n\t\t\t// Temp attachment removed\n\t\t\tif (in_array($oAttachment->GetKey(), $aRemovedAttachmentsIds))\n\t\t\t{\n\t\t\t\t$oAttachment->DBDelete();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$oAttachment->SetItem($this->oObject);\n\t\t\t\t$oAttachment->Set('temp_id', '');\n\t\t\t\t$oAttachment->DBUpdate();\n\t\t\t\t$aActions[] = self::GetAttachmentActionChangeOp($oAttachment, true);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Save changes to current object history\n\t\t// inspired from itop-attachments/main.attachments.php / RecordHistory\n\t\tforeach ($aActions as $oChangeOp)\n\t\t{\n\t\t\t$oChangeOp->Set(\"objclass\", get_class($this->oObject));\n\t\t\t$oChangeOp->Set(\"objkey\", $this->oObject->GetKey());\n\t\t\t$oChangeOp->DBInsertNoReload();\n\t\t}\n\t}\n\n\t/**\n\t * This is a temporary function until the Attachment refactoring is done. It should be remove once it's done.\n\t * It is inspired from itop-attachments/main.attachments.php / UpdateAttachments()\n\t *\n\t * @throws \\CoreException\n\t * @throws \\CoreUnexpectedValue\n\t * @throws \\DeleteException\n\t * @throws \\MySQLException\n\t * @throws \\OQLException\n\t */\n\tprotected function CancelAttachments()\n\t{\n\t\t// Processing temporary attachments\n\t\t$sTempId = utils::GetUploadTempId($this->oForm->GetTransactionId());\n\t\t$sOQL = 'SELECT Attachment WHERE temp_id = :temp_id';\n\t\t$oSearch = DBObjectSearch::FromOQL($sOQL);\n\t\t$oSet = new DBObjectSet($oSearch, array(), array('temp_id' => $sTempId));\n\t\twhile ($oAttachment = $oSet->Fetch())\n\t\t{\n\t\t\t$oAttachment->DBDelete();\n\t\t}\n\t}\n\n\t/**\n\t * This is a temporary function until the Attachment refactoring is done. It should be remove once it's done.\n\t * It is inspired from itop-attachments/main.attachments.php / GetActionChangeOp()\n\t *\n\t * @param $oAttachment\n\t * @param bool $bCreate\n\t *\n\t * @return \\CMDBChangeOpAttachmentAdded|\\CMDBChangeOpAttachmentRemoved\n\t * @throws \\CoreException\n\t * @throws \\CoreUnexpectedValue\n\t */\n\tprivate static function GetAttachmentActionChangeOp($oAttachment, $bCreate = true)\n\t{\n\t\t$oBlob = $oAttachment->Get('contents');\n\t\t$sFileName = $oBlob->GetFileName();\n\t\tif ($bCreate)\n\t\t{\n\t\t\t$oChangeOp = new CMDBChangeOpAttachmentAdded();\n\t\t\t$oChangeOp->Set('attachment_id', $oAttachment->GetKey());\n\t\t\t$oChangeOp->Set('filename', $sFileName);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$oChangeOp = new CMDBChangeOpAttachmentRemoved();\n\t\t\t$oChangeOp->Set('filename', $sFileName);\n\t\t}\n\t\treturn $oChangeOp;\n\t}\n\n\t/**\n\t * @return array\n\t * @since 2.7.5\n\t */\n\tpublic function GetHiddenFieldsId()\n\t{\n\t\treturn $this->aHiddenFieldsId;\n\t}\n\n\t/**\n\t * @param array $aHiddenFieldsId\n\t * @since 2.7.5\n\t */\n\tpublic function SetHiddenFieldsId($aHiddenFieldsId)\n\t{\n\t\t$this->aHiddenFieldsId = $aHiddenFieldsId;\n\t}\n}\n"], "fixing_code": ["<?php\n\n/**\n * Copyright (C) 2013-2020 Combodo SARL\n *\n * This file is part of iTop.\n *\n * iTop is free software; you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * iTop is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n */\n\nnamespace Combodo\\iTop\\Portal\\Form;\n\nuse AttachmentPlugIn;\nuse AttributeDateTime;\nuse AttributeSet;\nuse CMDBChangeOpAttachmentAdded;\nuse CMDBChangeOpAttachmentRemoved;\nuse Combodo\\iTop\\Form\\Field\\Field;\nuse Combodo\\iTop\\Form\\Field\\FileUploadField;\nuse Combodo\\iTop\\Form\\Field\\LabelField;\nuse Combodo\\iTop\\Form\\Form;\nuse Combodo\\iTop\\Form\\FormManager;\nuse Combodo\\iTop\\Portal\\Helper\\ApplicationHelper;\nuse DBObject;\nuse DBObjectSearch;\nuse DBObjectSet;\nuse DBSearch;\nuse Dict;\nuse DOMDocument;\nuse DOMXPath;\nuse Exception;\nuse InlineImage;\nuse IssueLog;\nuse MetaModel;\nuse Symfony\\Component\\DependencyInjection\\ContainerInterface;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\Exception\\HttpException;\nuse UserRights;\nuse utils;\n\n/**\n * Description of ObjectFormManager\n *\n * @author Guillaume Lajarige <guillaume.lajarige@combodo.com>\n * @since  2.3.0\n */\nclass ObjectFormManager extends FormManager\n{\n\t/** @var string ENUM_MODE_VIEW */\n\tconst ENUM_MODE_VIEW = 'view';\n\t/** @var string ENUM_MODE_EDIT */\n\tconst ENUM_MODE_EDIT = 'edit';\n\t/** @var string ENUM_MODE_CREATE */\n\tconst ENUM_MODE_CREATE = 'create';\n\t/** @var string ENUM_MODE_APPLY_STIMULUS */\n\tconst ENUM_MODE_APPLY_STIMULUS = 'apply_stimulus';\n\n\t/** @var \\Symfony\\Component\\DependencyInjection\\ContainerInterface $oContainer */\n\tprotected $oContainer;\n\t/** @var \\cmdbAbstractObject $oObject */\n\tprotected $oObject;\n\t/** @var string $sMode */\n\tprotected $sMode;\n\t/** @var string $sActionRulesToken */\n\tprotected $sActionRulesToken;\n\t/** @var array $aFormProperties */\n\tprotected $aFormProperties;\n\t/** @var array $aCallbackUrls */\n\tprotected $aCallbackUrls = array();\n\t/**\n\t * List of hidden fields, used for form update (eg. remove them from the form regarding they dependencies)\n\t *\n\t * @var array $aHiddenFieldsId\n\t * @since 2.7.5\n\t */\n\tprotected $aHiddenFieldsId = array();\n\n\t/**\n\t * @param string|array $formManagerData value of the formmanager_data portal parameter, either JSON or object\n\t *\n\t * @return array formmanager_data as a PHP array\n\t *\n\t * @since 2.7.6 3.0.0 N\u00b04384 method creation : factorize as this is used twice now\n\t */\n\tprotected static function DecodeFormManagerData($formManagerData)\n\t{\n\t\tif (is_array($formManagerData)) {\n\t\t\treturn $formManagerData;\n\t\t}\n\n\t\treturn json_decode($formManagerData, true);\n\t}\n\n\t/**\n\t * @param string $sJson JSON data that must contain at least :\n\t *       - formobject_class : The class of the object that is being edited/viewed\n\t *       - formmode : view|edit|create\n\t *       - values for parent\n\t * @param bool $bTrustContent if false then won't allow modified TWIG content\n\t *\n\t * @return \\Combodo\\iTop\\Portal\\Form\\ObjectFormManager new instance init from JSON data\n\t *\n\t * @inheritDoc\n\t * @throws \\Exception\n\t * @throws \\SecurityException if twig content is present and $bTrustContent is false\n\t *\n\t * @since 2.7.6 3.0.0 N\u00b04384 new $bTrustContent parameter\n\t */\n\tpublic static function FromJSON($sJson, $bTrustContent = false)\n\t{\n\t\t$aJson = static::DecodeFormManagerData($sJson);\n\n\t\t$oConfig = utils::GetConfig();\n\t\t$bIsContentCheckEnabled = $oConfig->GetModuleSetting(PORTAL_ID, 'enable_formmanager_content_check', true);\n\t\tif ($bIsContentCheckEnabled && (false === $bTrustContent)) {\n\t\t\t/** @noinspection NestedPositiveIfStatementsInspection */\n\t\t\tif (isset($aJson['formproperties']['layout']['type']) && ($aJson['formproperties']['layout']['type'] === 'twig')) {\n\t\t\t\t// There will be an IssueLog above in the hierarchy due to the exception, but we are logging here so that we can output the JSON data !\n\t\t\t\tIssueLog::Error('Portal received a query with forbidden twig content!', \\LogChannels::PORTAL, ['formmanager_data' => $aJson]);\n\t\t\t\tthrow new \\SecurityException('Twig content not allowed in this context!');\n\t\t\t}\n\t\t}\n\n\t\t/** @var \\Combodo\\iTop\\Portal\\Form\\ObjectFormManager $oFormManager */\n\t\t$oFormManager = parent::FromJSON($sJson);\n\n\t\t// Retrieving object to edit\n\t\tif (!isset($aJson['formobject_class'])) {\n\t\t\tthrow new Exception('Object class must be defined in order to generate the form');\n\t\t}\n\t\t$sObjectClass = $aJson['formobject_class'];\n\n\t\tif (!isset($aJson['formobject_id']))\n\t\t{\n\t\t\t$oObject = MetaModel::NewObject($sObjectClass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Note : AllowAllData set to true here instead of checking scope's flag because we are displaying a value that has been set and validated\n\t\t\t$oObject = MetaModel::GetObject($sObjectClass, $aJson['formobject_id'], true, true);\n\t\t}\n\t\t$oFormManager->SetObject($oObject);\n\n\t\t// Retrieving form mode\n\t\tif (!isset($aJson['formmode']))\n\t\t{\n\t\t\tthrow new Exception('Form mode must be defined in order to generate the form');\n\t\t}\n\t\t$oFormManager->SetMode($aJson['formmode']);\n\n\t\t// Retrieving actions rules\n\t\tif (isset($aJson['formactionrulestoken']))\n\t\t{\n\t\t\t$oFormManager->SetActionRulesToken($aJson['formactionrulestoken']);\n\t\t}\n\n\t\t// Retrieving form properties\n\t\tif (isset($aJson['formproperties']))\n\t\t{\n\t\t\t// As empty array are no passed through HTTP, this one is not always present and we have to ensure it is.\n\t\t\tif (!isset($aJson['formproperties']['fields']))\n\t\t\t{\n\t\t\t\t$aJson['formproperties']['fields'] = array();\n\t\t\t}\n\t\t\t$oFormManager->SetFormProperties($aJson['formproperties']);\n\t\t}\n\n\t\t// Retrieving callback urls\n\t\tif (!isset($aJson['formcallbacks'])) {\n\t\t\t// TODO\n\t\t}\n\n\t\treturn $oFormManager;\n\t}\n\n\t/**\n\t * @param string $sPostedFormManagerData received data from the browser\n\t * @param array $aOriginalFormProperties data generated server side\n\t *\n\t * @return bool true if the data are identical\n\t *\n\t * @since 2.7.6 3.0.0 N\u00b04384 check formmanager_data\n\t */\n\tpublic static function CanTrustFormLayoutContent($sPostedFormManagerData, $aOriginalFormProperties)\n\t{\n\t\t$aPostedFormManagerData = static::DecodeFormManagerData($sPostedFormManagerData);\n\t\t$sPostedFormLayoutType = (isset($aPostedFormManagerData['formproperties']['layout']['type'])) ? $aPostedFormManagerData['formproperties']['layout']['type'] : '';\n\n\t\tif ($sPostedFormLayoutType === 'xhtml') {\n\t\t\treturn true;\n\t\t}\n\n\t\t// we need to parse the content so that autoclose tags are returned correctly (`<div />` => `<div></div>`)\n\t\t$oHtmlDocument = new \\DOMDocument();\n\n\t\t$sPostedFormLayoutContent = (isset($aPostedFormManagerData['formproperties']['layout']['content'])) ? $aPostedFormManagerData['formproperties']['layout']['content'] : '';\n\t\t$oHtmlDocument->loadXML('<root>'.$sPostedFormLayoutContent.'</root>');\n\t\t$sPostedFormLayoutRendered = $oHtmlDocument->saveHTML();\n\n\t\t$sOriginalFormLayoutContent = (isset($aOriginalFormProperties['layout']['content'])) ? $aOriginalFormProperties['layout']['content'] : '';\n\t\t$oHtmlDocument->loadXML('<root>'.$sOriginalFormLayoutContent.'</root>');\n\t\t$sOriginalFormLayoutContentRendered = $oHtmlDocument->saveHTML();\n\n\t\treturn ($sPostedFormLayoutRendered === $sOriginalFormLayoutContentRendered);\n\t}\n\n\t/**\n\t *\n\t * @return \\Symfony\\Component\\DependencyInjection\\ContainerInterface\n\t */\n\tpublic function GetContainer()\n\t{\n\t\treturn $this->oContainer;\n\t}\n\n\t/**\n\t *\n\t * @param \\Symfony\\Component\\DependencyInjection\\ContainerInterface $oContainer\n\t *\n\t * @return $this\n\t */\n\tpublic function SetContainer(ContainerInterface $oContainer)\n\t{\n\t\t$this->oContainer = $oContainer;\n\n\t\treturn $this;\n\t}\n\n\t/**\n\t *\n\t * @return \\DBObject\n\t */\n\tpublic function GetObject()\n\t{\n\t\treturn $this->oObject;\n\t}\n\n\t/**\n\t *\n\t * @param \\DBObject $oObject\n\t *\n\t * @return $this\n\t */\n\tpublic function SetObject(DBObject $oObject)\n\t{\n\t\t$this->oObject = $oObject;\n\n\t\treturn $this;\n\t}\n\n\t/**\n\t *\n\t * @return string\n\t */\n\tpublic function GetMode()\n\t{\n\t\treturn $this->sMode;\n\t}\n\n\t/**\n\t *\n\t * @param string $sMode\n\t *\n\t * @return $this\n\t */\n\tpublic function SetMode($sMode)\n\t{\n\t\t$this->sMode = $sMode;\n\n\t\treturn $this;\n\t}\n\n\t/**\n\t *\n\t * @return string\n\t */\n\tpublic function GetActionRulesToken()\n\t{\n\t\treturn $this->sActionRulesToken;\n\t}\n\n\t/**\n\t *\n\t * @param string $sActionRulesToken\n\t *\n\t * @return $this\n\t */\n\tpublic function SetActionRulesToken($sActionRulesToken)\n\t{\n\t\t$this->sActionRulesToken = $sActionRulesToken;\n\n\t\treturn $this;\n\t}\n\n\t/**\n\t *\n\t * @return array\n\t */\n\tpublic function GetFormProperties()\n\t{\n\t\treturn $this->aFormProperties;\n\t}\n\n\t/**\n\t *\n\t * @param array $aFormProperties\n\t *\n\t * @return $this\n\t */\n\tpublic function SetFormProperties($aFormProperties)\n\t{\n\t\t$this->aFormProperties = $aFormProperties;\n\n\t\treturn $this;\n\t}\n\n\t/**\n\t *\n\t * @return array\n\t */\n\tpublic function GetCallbackUrls()\n\t{\n\t\treturn $this->aCallbackUrls;\n\t}\n\n\t/**\n\t *\n\t * @param array $aCallbackUrls\n\t *\n\t * @return $this\n\t */\n\tpublic function SetCallbackUrls($aCallbackUrls)\n\t{\n\t\t$this->aCallbackUrls = $aCallbackUrls;\n\n\t\treturn $this;\n\t}\n\n\t/**\n\t * Returns if the form manager is handling a transition form instead of a state form.\n\t *\n\t * @return bool\n\t */\n\tpublic function IsTransitionForm()\n\t{\n\t\treturn ($this->sMode === static::ENUM_MODE_APPLY_STIMULUS);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic function ToJSON()\n\t{\n\t\t$aJson = parent::ToJSON();\n\t\t$aJson['formobject_class'] = get_class($this->oObject);\n\t\tif ($this->oObject->GetKey() > 0)\n\t\t{\n\t\t\t$aJson['formobject_id'] = $this->oObject->GetKey();\n\t\t}\n\t\t$aJson['formmode'] = $this->sMode;\n\t\t$aJson['formactionrulestoken'] = $this->sActionRulesToken;\n\t\t$aJson['formproperties'] = $this->aFormProperties;\n\n\t\treturn $aJson;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t * @throws \\CoreException\n\t * @throws \\OQLException\n\t * @throws \\Exception\n\t */\n\tpublic function Build()\n\t{\n\t\t$sObjectClass = get_class($this->oObject);\n\n\t\t$aFieldsAtts = array();\n\t\t$aFieldsDMOnlyAttCodes = array();\n\t\t$aFieldsExtraData = array();\n\n\t\tif ($this->oForm !== null)\n\t\t{\n\t\t\t$oForm = $this->oForm;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$aFormId = 'objectform-'.((isset($this->aFormProperties['id'])) ? $this->aFormProperties['id'] : 'default').'-'.uniqid();\n\t\t\t$oForm = new Form($aFormId);\n\t\t\t$oForm->SetTransactionId(utils::GetNewTransactionId());\n\t\t}\n\n\t\t// Building form from its properties\n\t\t// - Consistency checks for stimulus form\n\t\tif (isset($this->aFormProperties['stimulus_code']))\n\t\t{\n\t\t\t$aTransitions = MetaModel::EnumTransitions($sObjectClass, $this->oObject->GetState());\n\t\t\tif (!isset($aTransitions[$this->aFormProperties['stimulus_code']]))\n\t\t\t{\n\t\t\t\t$aStimuli = Metamodel::EnumStimuli($sObjectClass);\n\t\t\t\t$sStimulusLabel = $aStimuli[$this->aFormProperties['stimulus_code']]->GetLabel();\n\n\t\t\t\t$sExceptionMessage = Dict::Format('UI:Error:Invalid_Stimulus_On_Object_In_State', $sStimulusLabel, $this->oObject->GetName(), $this->oObject->GetStateLabel());\n\t\t\t\tthrow new Exception($sExceptionMessage);\n\t\t\t}\n\t\t}\n\t\t// - The fields\n\t\tswitch ($this->aFormProperties['type'])\n\t\t{\n\t\t\tcase 'custom_list':\n\t\t\tcase 'static':\n\t\t\t\tforeach ($this->aFormProperties['fields'] as $sAttCode => $aOptions)\n\t\t\t\t{\n\t\t\t\t\t// When in a transition and no flags are specified for the field, we will retrieve its flags from DM later\n\t\t\t\t\tif ($this->IsTransitionForm() && empty($aOptions))\n\t\t\t\t\t{\n\t\t\t\t\t\t$aFieldsDMOnlyAttCodes[] = $sAttCode;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Otherwise we proceed as usual\n\t\t\t\t\t$iFieldFlags = OPT_ATT_NORMAL;\n\t\t\t\t\t// Checking if field should be slave\n\t\t\t\t\tif (isset($aOptions['slave']) && ($aOptions['slave'] === true))\n\t\t\t\t\t{\n\t\t\t\t\t\t$iFieldFlags = $iFieldFlags | OPT_ATT_SLAVE;\n\t\t\t\t\t}\n\t\t\t\t\t// Checking if field should be must_change\n\t\t\t\t\tif (isset($aOptions['must_change']) && ($aOptions['must_change'] === true))\n\t\t\t\t\t{\n\t\t\t\t\t\t$iFieldFlags = $iFieldFlags | OPT_ATT_MUSTCHANGE;\n\t\t\t\t\t}\n\t\t\t\t\t// Checking if field should be must prompt\n\t\t\t\t\tif (isset($aOptions['must_prompt']) && ($aOptions['must_prompt'] === true))\n\t\t\t\t\t{\n\t\t\t\t\t\t$iFieldFlags = $iFieldFlags | OPT_ATT_MUSTPROMPT;\n\t\t\t\t\t}\n\t\t\t\t\t// Checking if field should be hidden\n\t\t\t\t\tif (isset($aOptions['hidden']) && ($aOptions['hidden'] === true))\n\t\t\t\t\t{\n\t\t\t\t\t\t$iFieldFlags = $iFieldFlags | OPT_ATT_HIDDEN;\n\t\t\t\t\t}\n\t\t\t\t\t// Checking if field should be readonly\n\t\t\t\t\tif (isset($aOptions['read_only']) && ($aOptions['read_only'] === true))\n\t\t\t\t\t{\n\t\t\t\t\t\t$iFieldFlags = $iFieldFlags | OPT_ATT_READONLY;\n\t\t\t\t\t}\n\t\t\t\t\t// Checking if field should be mandatory\n\t\t\t\t\tif (isset($aOptions['mandatory']) && ($aOptions['mandatory'] === true))\n\t\t\t\t\t{\n\t\t\t\t\t\t$iFieldFlags = $iFieldFlags | OPT_ATT_MANDATORY;\n\t\t\t\t\t}\n\t\t\t\t\t// Finally, adding the attribute and its flags\n\t\t\t\t\t$aFieldsAtts[$sAttCode] = $iFieldFlags;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'zlist':\n\t\t\t\tforeach (MetaModel::FlattenZList(MetaModel::GetZListItems($sObjectClass, $this->aFormProperties['fields'])) as $sAttCode)\n\t\t\t\t{\n\t\t\t\t\t$aFieldsAtts[$sAttCode] = OPT_ATT_NORMAL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\t// - The layout\n\t\tif ($this->aFormProperties['layout'] !== null)\n\t\t{\n\t\t\t// Checking if we need to render the template from twig to html in order to parse the fields\n\t\t\tif ($this->aFormProperties['layout']['type'] === 'twig')\n\t\t\t{\n\t\t\t\tif ($this->oContainer !== null)\n\t\t\t\t{\n\t\t\t\t\t/** @var \\Combodo\\iTop\\Portal\\Helper\\ObjectFormHandlerHelper $oObjectFormHandler */\n\t\t\t\t\t$oObjectFormHandler = $this->oContainer->get('object_form_handler');\n\t\t\t\t\t$sRendered = $oObjectFormHandler->RenderFormFromTwig(\n\t\t\t\t\t\t$oForm->GetId(),\n\t\t\t\t\t\t$this->aFormProperties['layout']['content'],\n\t\t\t\t\t\tarray('oRenderer' => $this->oRenderer, 'oObject' => $this->oObject)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$sRendered = 'Form not rendered because of missing container';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$sRendered = $this->aFormProperties['layout']['content'];\n\t\t\t}\n\n\t\t\t// Parsing rendered template to find the fields\n\t\t\t$oHtmlDocument = new DOMDocument();\n\t\t\t// Note: Loading as XML instead of HTML avoid some encoding issues (eg. '\u00e9' was transformed to '&tilde;&copy;')\n\t\t\t$oHtmlDocument->loadXML('<root>'.$sRendered.'</root>');\n\n\t\t\t// Adding fields to the list\n\t\t\t$oXPath = new DOMXPath($oHtmlDocument);\n\t\t\t/** @var \\DOMElement $oFieldNode */\n\t\t\tforeach ($oXPath->query('//div[contains(@class, \"form_field\")][@data-field-id]') as $oFieldNode)\n\t\t\t{\n\t\t\t\t$sFieldId = $oFieldNode->getAttribute('data-field-id');\n\t\t\t\t$sFieldFlags = $oFieldNode->getAttribute('data-field-flags');\n\t\t\t\t$iFieldFlags = OPT_ATT_NORMAL;\n\n\t\t\t\t// When in a transition and no flags are specified for the field, we will retrieve its flags from DM later\n\t\t\t\tif ($this->IsTransitionForm() && $sFieldFlags === '')\n\t\t\t\t{\n\t\t\t\t\t// (Might have already been added from the \"fields\" property)\n\t\t\t\t\tif (!in_array($sFieldId, $aFieldsDMOnlyAttCodes))\n\t\t\t\t\t{\n\t\t\t\t\t\t$aFieldsDMOnlyAttCodes[] = $sFieldId;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise we proceed as usual\n\t\t\t\tforeach (explode(' ', $sFieldFlags) as $sFieldFlag)\n\t\t\t\t{\n\t\t\t\t\tif ($sFieldFlag !== '')\n\t\t\t\t\t{\n\t\t\t\t\t\t$sConst = 'OPT_ATT_'.strtoupper(str_replace('_', '', $sFieldFlag));\n\t\t\t\t\t\tif (defined($sConst))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$iFieldFlags = $iFieldFlags | constant($sConst);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIssueLog::Error(__METHOD__.' at line '.__LINE__.' : Flag \"'.$sFieldFlag.'\" is not valid for field [@data-field-id=\"'.$sFieldId.'\"] in form[@id=\"'.$this->aFormProperties['id'].'\"]');\n\t\t\t\t\t\t\tthrow new Exception('Flag \"'.$sFieldFlag.'\" is not valid for field [@data-field-id=\"'.$sFieldId.'\"] in form[@id=\"'.$this->aFormProperties['id'].'\"]');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Checking if field has form_path, if not, we add it\n\t\t\t\tif (!$oFieldNode->hasAttribute('data-form-path'))\n\t\t\t\t{\n\t\t\t\t\t$oFieldNode->setAttribute('data-form-path', $oForm->GetId());\n\t\t\t\t}\n\t\t\t\t// Checking if field should be displayed opened (For linked set)\n\t\t\t\tif ($oFieldNode->hasAttribute('data-field-opened') && ($oFieldNode->getAttribute('data-field-opened') === 'true'))\n\t\t\t\t{\n\t\t\t\t\t$aFieldsExtraData[$sFieldId]['opened'] = true;\n\t\t\t\t}\n\t\t\t\t// Checking if field allows to ignore scope (For linked set)\n\t\t\t\tif ($oFieldNode->hasAttribute('data-field-ignore-scopes') && ($oFieldNode->getAttribute('data-field-ignore-scopes') === 'true'))\n\t\t\t\t{\n\t\t\t\t\t$aFieldsExtraData[$sFieldId]['ignore_scopes'] = true;\n\t\t\t\t}\n\t\t\t\t// Checking field display mode\n\t\t\t\tif ($oFieldNode->hasAttribute('data-field-display-mode') && $oFieldNode->getAttribute('data-field-display-mode') !== '')\n\t\t\t\t{\n\t\t\t\t\t$aFieldsExtraData[$sFieldId]['display_mode'] = $oFieldNode->getAttribute('data-field-display-mode');\n\t\t\t\t}\n\t\t\t\telseif (isset($this->aFormProperties['properties']['display_mode']))\n\t\t\t\t{\n\t\t\t\t\t$aFieldsExtraData[$sFieldId]['display_mode'] = $this->aFormProperties['properties']['display_mode'];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$aFieldsExtraData[$sFieldId]['display_mode'] = ApplicationHelper::FORM_DEFAULT_DISPLAY_MODE;\n\t\t\t\t}\n\n\t\t\t\t// Finally adding field to the list\n\t\t\t\tif (!array_key_exists($sFieldId, $aFieldsAtts))\n\t\t\t\t{\n\t\t\t\t\t$aFieldsAtts[$sFieldId] = OPT_ATT_NORMAL;\n\t\t\t\t}\n\t\t\t\t$aFieldsAtts[$sFieldId] = $aFieldsAtts[$sFieldId] | $iFieldFlags;\n\t\t\t}\n\n\t\t\t// Adding rendered template to the form renderer as the base layout\n\t\t\t$this->oRenderer->SetBaseLayout($oHtmlDocument->saveHTML());\n\t\t}\n\n\t\t// Merging flags from metamodel with those from the form\n\t\t// Also, retrieving mandatory attributes from metamodel to be able to complete the form with them if necessary\n\t\t//\n\t\t// Note: When in a transition, we don't do this for fields that should be set from DM\n\t\tif ($this->aFormProperties['type'] !== 'static')\n\t\t{\n\t\t\tif ($this->IsTransitionForm())\n\t\t\t{\n\t\t\t\t$aDatamodelAttCodes = $this->oObject->GetTransitionAttributes($this->aFormProperties['stimulus_code']);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$aDatamodelAttCodes = MetaModel::ListAttributeDefs($sObjectClass);\n\t\t\t}\n\n\t\t\tforeach ($aDatamodelAttCodes as $sAttCode => $value)\n\t\t\t{\n\t\t\t\t/** var AttributeDefinition $oAttDef */\n\n\t\t\t\t// Skipping fields that should come from DM only as they will be process later on\n\t\t\t\tif (in_array($sAttCode, $aFieldsDMOnlyAttCodes))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Retrieving object flags\n\t\t\t\tif ($this->IsTransitionForm())\n\t\t\t\t{\n\t\t\t\t\t// Retrieving only mandatory flag from DM when on a transition\n\t\t\t\t\t$iFieldFlags = $value & OPT_ATT_MANDATORY;\n\t\t\t\t\t$oAttDef = MetaModel::GetAttributeDef(get_class($this->oObject), $sAttCode);\n\t\t\t\t}\n\t\t\t\telseif ($this->oObject->IsNew())\n\t\t\t\t{\n\t\t\t\t\t$iFieldFlags = $this->oObject->GetInitialStateAttributeFlags($sAttCode);\n\t\t\t\t\t$oAttDef = $value;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$iFieldFlags = $this->oObject->GetAttributeFlags($sAttCode);\n\t\t\t\t\t$oAttDef = $value;\n\t\t\t\t}\n\n\t\t\t\t// Skipping fields that were not specified to DM only list (garbage collector)\n\t\t\t\tif ($this->IsTransitionForm() && !array_key_exists($sAttCode, $aFieldsAtts))\n\t\t\t\t{\n\t\t\t\t\tif ((($value & OPT_ATT_MANDATORY) === OPT_ATT_MANDATORY && $oAttDef->IsNull($this->oObject->Get($sAttCode)))\n\t\t\t\t\t\t|| (($value & OPT_ATT_MUSTPROMPT) === OPT_ATT_MUSTPROMPT)\n\t\t\t\t\t\t|| (($value & OPT_ATT_MUSTCHANGE) === OPT_ATT_MUSTCHANGE))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!in_array($sAttCode, $aFieldsDMOnlyAttCodes))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$aFieldsDMOnlyAttCodes[] = $sAttCode;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Merging flags with those from the form definition\n\t\t\t\t// - If the field is in fields list\n\t\t\t\tif (array_key_exists($sAttCode, $aFieldsAtts))\n\t\t\t\t{\n\t\t\t\t\t// .. We merge them all\n\t\t\t\t\t$aFieldsAtts[$sAttCode] = $aFieldsAtts[$sAttCode] | $iFieldFlags;\n\t\t\t\t}\n\t\t\t\t// - or it is mandatory and has no value\n\t\t\t\tif ((($iFieldFlags & OPT_ATT_MANDATORY) === OPT_ATT_MANDATORY) && ($this->oObject->Get($sAttCode) === ''))\n\t\t\t\t{\n\t\t\t\t\tif (!array_key_exists($sAttCode, $aFieldsAtts))\n\t\t\t\t\t{\n\t\t\t\t\t\t$aFieldsAtts[$sAttCode] = OPT_ATT_NORMAL;\n\t\t\t\t\t}\n\t\t\t\t\t$aFieldsAtts[$sAttCode] = $aFieldsAtts[$sAttCode] | OPT_ATT_MANDATORY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Adding fields with DM flags only\n\t\t// Note: This should only happen when in a transition\n\t\tforeach ($aFieldsDMOnlyAttCodes as $sAttCode)\n\t\t{\n\t\t\t// Retrieving object flags from DM\n\t\t\tif ($this->IsTransitionForm())\n\t\t\t{\n\t\t\t\t$aTransitionAtts = $this->oObject->GetTransitionAttributes($this->aFormProperties['stimulus_code']);\n\t\t\t\t$iFieldFlags = $aTransitionAtts[$sAttCode];\n\t\t\t}\n\t\t\telseif ($this->oObject->IsNew())\n\t\t\t{\n\t\t\t\t$iFieldFlags = $this->oObject->GetInitialStateAttributeFlags($sAttCode);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$iFieldFlags = $this->oObject->GetAttributeFlags($sAttCode);\n\t\t\t}\n\n\t\t\t// Resetting/Forcing flag to read/write\n\t\t\t$aFieldsAtts[$sAttCode] = OPT_ATT_NORMAL;\n\t\t\t// Checking if field should be must_change\n\t\t\tif (($iFieldFlags & OPT_ATT_MUSTCHANGE) === OPT_ATT_MUSTCHANGE)\n\t\t\t{\n\t\t\t\t$aFieldsAtts[$sAttCode] = $aFieldsAtts[$sAttCode] | OPT_ATT_MUSTCHANGE;\n\t\t\t}\n\t\t\t// Checking if field should be must_prompt\n\t\t\tif (($iFieldFlags & OPT_ATT_MUSTPROMPT) === OPT_ATT_MUSTPROMPT)\n\t\t\t{\n\t\t\t\t$aFieldsAtts[$sAttCode] = $aFieldsAtts[$sAttCode] | OPT_ATT_MUSTPROMPT;\n\t\t\t}\n\t\t\t// Checking if field should be mandatory\n\t\t\tif (($iFieldFlags & OPT_ATT_MANDATORY) === OPT_ATT_MANDATORY)\n\t\t\t{\n\t\t\t\t$aFieldsAtts[$sAttCode] = $aFieldsAtts[$sAttCode] | OPT_ATT_MANDATORY;\n\t\t\t}\n\t\t}\n\n\t\t// Building the form\n\t\tforeach ($aFieldsAtts as $sAttCode => $iFieldFlags)\n\t\t{\n\t\t\t$oAttDef = MetaModel::GetAttributeDef(get_class($this->oObject), $sAttCode);\n\n\t\t\t/** @var Field $oField */\n\t\t\t$oField = null;\n\t\t\tif (is_callable(get_class($oAttDef).'::MakeFormField'))\n\t\t\t{\n\t\t\t\t$oField = $oAttDef->MakeFormField($this->oObject);\n\t\t\t}\n\n\t\t\t// Failsafe for AttributeType that would not have MakeFormField and therefore could not be used in a form\n\t\t\tif ($oField !== null)\n\t\t\t{\n\t\t\t\tif ($this->sMode !== static::ENUM_MODE_VIEW)\n\t\t\t\t{\n\t\t\t\t\t// Field dependencies\n\t\t\t\t\t$aFieldDependencies = $oAttDef->GetPrerequisiteAttributes();\n\t\t\t\t\tif (!empty($aFieldDependencies))\n\t\t\t\t\t{\n\t\t\t\t\t\t$oForm->AddFieldDependencies($oField->GetId(), $aFieldDependencies);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Setting the field flags\n\t\t\t\t\t// - If it's locked because slave, we force it as read only\n\t\t\t\t\tif (($iFieldFlags & OPT_ATT_SLAVE) === OPT_ATT_SLAVE)\n\t\t\t\t\t{\n\t\t\t\t\t\t$oField->SetReadOnly(true);\n\t\t\t\t\t}\n\t\t\t\t\t// - Else if it's must change (transition), we force it as mustchange, not readonly and not hidden\n\t\t\t\t\telseif (($iFieldFlags & OPT_ATT_MUSTCHANGE) === OPT_ATT_MUSTCHANGE && $this->IsTransitionForm())\n\t\t\t\t\t{\n\t\t\t\t\t\t$oField->SetMustChange(true);\n\t\t\t\t\t\t$oField->SetReadOnly(false);\n\t\t\t\t\t\t$oField->SetHidden(false);\n\t\t\t\t\t}\n\t\t\t\t\t// - Else if it's must prompt (transition), we force it as not readonly and not hidden\n\t\t\t\t\telseif (($iFieldFlags & OPT_ATT_MUSTPROMPT) === OPT_ATT_MUSTPROMPT && $this->IsTransitionForm())\n\t\t\t\t\t{\n\t\t\t\t\t\t$oField->SetReadOnly(false);\n\t\t\t\t\t\t$oField->SetHidden(false);\n\t\t\t\t\t}\n\t\t\t\t\t// - Else if it wasn't mandatory or already had a value, and it's hidden, we force it as hidden\n\t\t\t\t\telseif (($iFieldFlags & OPT_ATT_HIDDEN) === OPT_ATT_HIDDEN)\n\t\t\t\t\t{\n\t\t\t\t\t\t$oField->SetHidden(true);\n\t\t\t\t\t}\n\t\t\t\t\telseif (($iFieldFlags & OPT_ATT_READONLY) === OPT_ATT_READONLY)\n\t\t\t\t\t{\n\t\t\t\t\t\t$oField->SetReadOnly(true);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Normal field, use \"flags\" set by AttDef::MakeFormField()\n\t\t\t\t\t\t// Except if we are in a transition be cause $oAttDef doesn't know if the form is for a transition\n\t\t\t\t\t\tif ($this->IsTransitionForm())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$oField->SetReadOnly(false);\n\t\t\t\t\t\t\t$oField->SetHidden(false);\n\t\t\t\t\t\t\t$oField->SetMandatory(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Finally, if it's mandatory ...\n\t\t\t\t\tif (($iFieldFlags & OPT_ATT_MANDATORY) === OPT_ATT_MANDATORY)\n\t\t\t\t\t{\n\t\t\t\t\t\t// ... and when in a transition, we force it as mandatory\n\t\t\t\t\t\tif ($this->IsTransitionForm() && $oAttDef->IsNull($this->oObject->Get($sAttCode)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$oField->SetMandatory(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// .. and has no value, we force it as mandatory\n\t\t\t\t\t\telseif ($oAttDef->IsNull($this->oObject->Get($sAttCode)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$oField->SetMandatory(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Specific operation on field\n\t\t\t\t\t// - Field that require a transaction id\n\t\t\t\t\tif (in_array(get_class($oField),\n\t\t\t\t\t\tarray('Combodo\\\\iTop\\\\Form\\\\Field\\\\TextAreaField', 'Combodo\\\\iTop\\\\Form\\\\Field\\\\CaseLogField')))\n\t\t\t\t\t{\n\t\t\t\t\t\t/** @var \\Combodo\\iTop\\Form\\Field\\TextAreaField|\\Combodo\\iTop\\Form\\Field\\CaseLogField $oField */\n\t\t\t\t\t\t$oField->SetTransactionId($oForm->GetTransactionId());\n\t\t\t\t\t}\n\t\t\t\t\t// - Field that require a search endpoint\n\t\t\t\t\tif (in_array(get_class($oField),\n\t\t\t\t\t\tarray('Combodo\\\\iTop\\\\Form\\\\Field\\\\SelectObjectField', 'Combodo\\\\iTop\\\\Form\\\\Field\\\\LinkedSetField')))\n\t\t\t\t\t{\n\t\t\t\t\t\t/** @var \\Combodo\\iTop\\Form\\Field\\SelectObjectField|\\Combodo\\iTop\\Form\\Field\\LinkedSetField $oField */\n\t\t\t\t\t\tif ($this->oContainer !== null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$sSearchEndpoint = $this->oContainer->get('url_generator')->generate('p_object_search_generic', array(\n\t\t\t\t\t\t\t\t'sTargetAttCode' => $oAttDef->GetCode(),\n\t\t\t\t\t\t\t\t'sHostObjectClass' => get_class($this->oObject),\n\t\t\t\t\t\t\t\t'sHostObjectId' => ($this->oObject->IsNew()) ? null : $this->oObject->GetKey(),\n\t\t\t\t\t\t\t\t'ar_token' => $this->GetActionRulesToken(),\n\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t$oField->SetSearchEndpoint($sSearchEndpoint);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// - Field that require an information endpoint\n\t\t\t\t\tif (in_array(get_class($oField), array('Combodo\\\\iTop\\\\Form\\\\Field\\\\LinkedSetField')))\n\t\t\t\t\t{\n\t\t\t\t\t\t/** @var \\Combodo\\iTop\\Form\\Field\\LinkedSetField $oField */\n\t\t\t\t\t\tif ($this->oContainer !== null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$oField->SetInformationEndpoint($this->oContainer->get('url_generator')->generate('p_object_get_information_json'));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// - Field that require to apply scope on its DM OQL\n\t\t\t\t\tif (in_array(get_class($oField), array('Combodo\\\\iTop\\\\Form\\\\Field\\\\SelectObjectField')))\n\t\t\t\t\t{\n\t\t\t\t\t\t/** @var \\Combodo\\iTop\\Form\\Field\\SelectObjectField $oField */\n\t\t\t\t\t\tif ($this->oContainer !== null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$oScopeOriginal = ($oField->GetSearch() !== null) ? $oField->GetSearch() : DBSearch::FromOQL($oAttDef->GetValuesDef()->GetFilterExpression());\n\n\t\t\t\t\t\t\t/** @var \\DBSearch $oScopeSearch */\n\t\t\t\t\t\t\t$oScopeSearch = $this->oContainer->get('scope_validator')->GetScopeFilterForProfiles(UserRights::ListProfiles(),\n\t\t\t\t\t\t\t\t$oScopeOriginal->GetClass(), UR_ACTION_READ);\n\t\t\t\t\t\t\tif ($oScopeSearch === null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tIssueLog::Info(__METHOD__.' at line '.__LINE__.' : User #'.UserRights::GetUserId().' has no scope query for '.$oScopeOriginal->GetClass().' class.');\n\t\t\t\t\t\t\t\tthrow new HttpException(Response::HTTP_NOT_FOUND, Dict::S('UI:ObjectDoesNotExist'));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$oScopeOriginal = $oScopeOriginal->Intersect($oScopeSearch);\n\t\t\t\t\t\t\t// Note : This is to skip the silo restriction on the final query\n\t\t\t\t\t\t\tif ($oScopeSearch->IsAllDataAllowed())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$oScopeOriginal->AllowAllData();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$oScopeOriginal->SetInternalParams(array('this' => $this->oObject));\n\t\t\t\t\t\t\t$oField->SetSearch($oScopeOriginal);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// - Field that require to check if the current value is among allowed ones\n\t\t\t\t\tif (in_array(get_class($oField), array('Combodo\\\\iTop\\\\Form\\\\Field\\\\SelectObjectField')))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Note: We can't do this in AttributeExternalKey::MakeFormField() in the Field::SetOnFinalizeCallback() because at this point we have no information about the portal scope and ignore_silos flag, hence it always applies silos.\n\t\t\t\t\t\t// As a workaround we have to manually check if the field's current value is among the scope\n\t\t\t\t\t\t$oField->VerifyCurrentValue();\n\t\t\t\t\t}\n\t\t\t\t\t// - Field that require processing on their subfields\n\t\t\t\t\tif (in_array(get_class($oField), array('Combodo\\\\iTop\\\\Form\\\\Field\\\\SubFormField')))\n\t\t\t\t\t{\n\t\t\t\t\t\t/** @var \\Combodo\\iTop\\Form\\Field\\SubFormField $oField */\n\t\t\t\t\t\t$oSubForm = $oField->GetForm();\n\t\t\t\t\t\tif ($oAttDef->GetEditClass() === 'CustomFields')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Retrieving only user data fields (not the metadata fields of the template)\n\t\t\t\t\t\t\tif ($oSubForm->HasField('user_data'))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/** @var \\Combodo\\iTop\\Form\\Field\\SubFormField $oUserDataField */\n\t\t\t\t\t\t\t\t$oUserDataField = $oSubForm->GetField('user_data');\n\t\t\t\t\t\t\t\t$oUserDataForm = $oUserDataField->GetForm();\n\t\t\t\t\t\t\t\tforeach ($oUserDataForm->GetFields() as $oCustomField)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// - Field that require a search endpoint (OQL based dropdown list fields)\n\t\t\t\t\t\t\t\t\tif (in_array(get_class($oCustomField), array('Combodo\\\\iTop\\\\Form\\\\Field\\\\SelectObjectField')))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t/** @var \\Combodo\\iTop\\Form\\Field\\SelectObjectField $oCustomField */\n\t\t\t\t\t\t\t\t\t\tif ($this->oContainer !== null)\n\t\t\t\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t\t\t\t$sSearchEndpoint = $this->oContainer->get('url_generator')->generate('p_object_search_generic',\n\t\t\t\t\t\t\t\t\t\t\t\tarray(\n\t\t\t\t\t\t\t\t\t\t\t\t\t'sTargetAttCode' => $oAttDef->GetCode(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t'sHostObjectClass' => get_class($this->oObject),\n\t\t\t\t\t\t\t\t\t\t\t\t\t'sHostObjectId' => ($this->oObject->IsNew()) ? null : $this->oObject->GetKey(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t'ar_token' => $this->GetActionRulesToken(),\n\t\t\t\t\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t\t\t\t\t$oCustomField->SetSearchEndpoint($sSearchEndpoint);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// - Field that require to check if the current value is among allowed ones\n\t\t\t\t\t\t\t\t\tif (in_array(get_class($oCustomField), array('Combodo\\\\iTop\\\\Form\\\\Field\\\\SelectObjectField')))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t/** @var \\Combodo\\iTop\\Form\\Field\\SelectObjectField $oCustomField */\n\t\t\t\t\t\t\t\t\t\t$oCustomField->VerifyCurrentValue();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (($iFieldFlags & OPT_ATT_HIDDEN) === OPT_ATT_HIDDEN)\n\t\t\t\t\t{\n\t\t\t\t\t\t$oField->SetHidden(true);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$oField->SetReadOnly(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Specific operation on field\n\t\t\t\t// - LinkedSet\n\t\t\t\tif (in_array(get_class($oField), array('Combodo\\\\iTop\\\\Form\\\\Field\\\\LinkedSetField')))\n\t\t\t\t{\n\t\t\t\t\t/** @var \\Combodo\\iTop\\Form\\Field\\LinkedSetField $oField */\n\t\t\t\t\t/** @var \\AttributeLinkedSetIndirect $oAttDef */\n\t\t\t\t\t//   - Overriding attributes to display\n\t\t\t\t\tif ($this->oContainer !== null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Note : This snippet is inspired from AttributeLinkedSet::MakeFormField()\n\t\t\t\t\t\t$aAttCodesToDisplay = ApplicationHelper::GetLoadedListFromClass($this->oContainer->getParameter('combodo.portal.instance.conf')['lists'],\n\t\t\t\t\t\t\t$oField->GetTargetClass(), 'list');\n\t\t\t\t\t\t// - Adding friendlyname attribute to the list is not already in it\n\t\t\t\t\t\t$sTitleAttCode = 'friendlyname';\n\t\t\t\t\t\tif (($sTitleAttCode !== null) && !in_array($sTitleAttCode, $aAttCodesToDisplay))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$aAttCodesToDisplay = array_merge(array($sTitleAttCode), $aAttCodesToDisplay);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// - Adding attribute labels\n\t\t\t\t\t\t$aAttributesToDisplay = array();\n\t\t\t\t\t\tforeach ($aAttCodesToDisplay as $sAttCodeToDisplay)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$oAttDefToDisplay = MetaModel::GetAttributeDef($oField->GetTargetClass(), $sAttCodeToDisplay);\n\t\t\t\t\t\t\t$aAttributesToDisplay[$sAttCodeToDisplay] = $oAttDefToDisplay->GetLabel();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$oField->SetAttributesToDisplay($aAttributesToDisplay);\n\t\t\t\t\t}\n\t\t\t\t\t//    - Filtering links regarding scopes\n\t\t\t\t\tif ($this->oContainer !== null)\n\t\t\t\t\t{\n\t\t\t\t\t\t$aLimitedAccessItemIDs = array();\n\n\t\t\t\t\t\t/** @var \\ormLinkSet $oFieldOriginalSet */\n\t\t\t\t\t\t$oFieldOriginalSet = $oField->GetCurrentValue();\n\t\t\t\t\t\twhile ($oLink = $oFieldOriginalSet->Fetch())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ($oField->IsIndirect())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$iRemoteKey = $oLink->Get($oAttDef->GetExtKeyToRemote());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$iRemoteKey = $oLink->GetKey();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!$this->oContainer->get('security_helper')->IsActionAllowed(UR_ACTION_READ, $oField->GetTargetClass(), $iRemoteKey))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$aLimitedAccessItemIDs[] = $iRemoteKey;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$oFieldOriginalSet->rewind();\n\t\t\t\t\t\t$oField->SetLimitedAccessItemIDs($aLimitedAccessItemIDs);\n\t\t\t\t\t}\n\t\t\t\t\t//    - Displaying as opened\n\t\t\t\t\tif (array_key_exists($sAttCode, $aFieldsExtraData) && array_key_exists('opened', $aFieldsExtraData[$sAttCode]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$oField->SetDisplayOpened(true);\n\t\t\t\t\t}\n\t\t\t\t\t//    - Displaying out of scopes items\n\t\t\t\t\tif (array_key_exists($sAttCode, $aFieldsExtraData) && array_key_exists('ignore_scopes', $aFieldsExtraData[$sAttCode]))\n\t\t\t\t\t{\n\t\t\t\t\t\t$oField->SetDisplayLimitedAccessItems(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// - BlobField\n\t\t\t\tif (in_array(get_class($oField), array('Combodo\\\\iTop\\\\Form\\\\Field\\\\BlobField', 'Combodo\\\\iTop\\\\Form\\\\Field\\\\ImageField')))\n\t\t\t\t{\n\t\t\t\t\t//   - Overriding attributes to display\n\t\t\t\t\tif ($this->oContainer !== null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Override hardcoded URLs in ormDocument pointing to back office console\n\t\t\t\t\t\t$sDisplayUrl = $this->oContainer->get('url_generator')->generate('p_object_document_display', array('sObjectClass' => get_class($this->oObject), 'sObjectId' => $this->oObject->GetKey(), 'sObjectField' => $sAttCode, 'cache' => 86400));\n\t\t\t\t\t\t$sDownloadUrl = $this->oContainer->get('url_generator')->generate('p_object_document_download', array('sObjectClass' => get_class($this->oObject), 'sObjectId' => $this->oObject->GetKey(), 'sObjectField' => $sAttCode, 'cache' => 86400));\n\t\t\t\t\t\t/** @var \\Combodo\\iTop\\Form\\Field\\BlobField $oField */\n\t\t\t\t\t\t$oField->SetDisplayUrl($sDisplayUrl)\n\t\t\t\t\t\t\t->SetDownloadUrl($sDownloadUrl);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$oField = new LabelField($sAttCode);\n\t\t\t\t$oField->SetReadOnly(true)\n\t\t\t\t\t->SetHidden(false)\n\t\t\t\t\t->SetCurrentValue('Sorry, that AttributeType is not implemented yet.')\n\t\t\t\t\t->SetLabel($oAttDef->GetLabel());\n\t\t\t}\n\n\t\t\t// Setting field display mode\n\t\t\tif (array_key_exists($sAttCode, $aFieldsExtraData) && array_key_exists('display_mode', $aFieldsExtraData[$sAttCode]))\n\t\t\t{\n\t\t\t\t$oField->SetDisplayMode($aFieldsExtraData[$sAttCode]['display_mode']);\n\t\t\t}\n\n\t\t\t// Overload (AttributeDefinition) flags metadata as they have been changed while building the form\n\t\t\t$oField->AddMetadata('attribute-flag-hidden', $oField->GetHidden() ? 'true' : 'false');\n\t\t\t$oField->AddMetadata('attribute-flag-read-only', $oField->GetReadOnly() ? 'true' : 'false');\n\t\t\t$oField->AddMetadata('attribute-flag-mandatory', $oField->GetMandatory() ? 'true' : 'false');\n\t\t\t$oField->AddMetadata('attribute-flag-must-change', $oField->GetMustChange() ? 'true' : 'false');\n\n\t\t\t// Do not add hidden fields as they are of no use, if one is necessary because another depends on it, it will be automatically added.\n\t\t\t// Note: We do this at the end because during the process an hidden field could have become writable if mandatory and empty for example.\n\t\t\tif($oField->GetHidden() === false)\n\t\t\t{\n\t\t\t\t$oForm->AddField($oField);\n\t\t\t} else {\n\t\t\t\t$this->aHiddenFieldsId[]=$oField->GetId();\n\t\t\t}\n\t\t}\n\n\t\t// Checking dependencies to ensure that all needed fields are in the form\n\t\t// (This is kind of a garbage collector for dependencies)\n\t\tforeach ($oForm->GetDependencies() as $sImpactedFieldId => $aDependencies)\n\t\t{\n\t\t\tforeach ($aDependencies as $sDependencyFieldId)\n\t\t\t{\n\t\t\t\tif (!$oForm->HasField($sDependencyFieldId))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\t$oAttDef = MetaModel::GetAttributeDef(get_class($this->oObject), $sDependencyFieldId);\n\t\t\t\t\t\t$oField = $oAttDef->MakeFormField($this->oObject);\n\t\t\t\t\t\t$oField->SetHidden(true);\n\n\t\t\t\t\t\t$oForm->AddField($oField);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception $e)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Avoid blocking a form if a RequestTemplate reference a bad attribute (e.g. :this->id)\n\t\t\t\t\t\tIssueLog::Error('May be a bad OQL (referencing :this->id) in a RequestTemplate causes the following error');\n\t\t\t\t\t\tIssueLog::Error($e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Checking if the instance has attachments\n\t\tif (class_exists('Attachment') && class_exists('AttachmentPlugIn'))\n\t\t{\n\t\t\t// Checking if the object is allowed for attachments\n\t\t\t$bClassAllowed = false;\n\t\t\t$aAllowedClasses = MetaModel::GetModuleSetting('itop-attachments', 'allowed_classes', array('Ticket'));\n\t\t\tforeach ($aAllowedClasses as $sAllowedClass)\n\t\t\t{\n\t\t\t\tif ($this->oObject instanceof $sAllowedClass)\n\t\t\t\t{\n\t\t\t\t\t$bClassAllowed = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Adding attachment field\n\t\t\tif ($bClassAllowed)\n\t\t\t{\n\t\t\t\t// set id to a unique key - avoid collisions with another attribute that could exist with the name 'attachments'\n\t\t\t\t$oField = new FileUploadField('attachments_plugin');\n\t\t\t\t$oField->SetLabel(Dict::S('Portal:Attachments'))\n\t\t\t\t\t->SetUploadEndpoint($this->oContainer->get('url_generator')->generate('p_object_attachment_add'))\n\t\t\t\t\t->SetDownloadEndpoint($this->oContainer->get('url_generator')->generate('p_object_attachment_download',\n\t\t\t\t\t\tarray('sAttachmentId' => '-sAttachmentId-')))\n\t\t\t\t\t->SetTransactionId($oForm->GetTransactionId())\n\t\t\t\t\t->SetAllowDelete($this->oContainer->getParameter('combodo.portal.instance.conf')['properties']['attachments']['allow_delete'])\n\t\t\t\t\t->SetObject($this->oObject);\n\n\t\t\t\t// Checking if we can edit attachments in the current state\n\t\t\t\tif (($this->sMode === static::ENUM_MODE_VIEW)\n\t\t\t\t\t|| AttachmentPlugIn::IsReadonlyState($this->oObject, $this->oObject->GetState(),\n\t\t\t\t\t\tAttachmentPlugIn::ENUM_GUI_PORTALS) === true\n\t\t\t\t\t|| $oForm->GetEditableFieldCount(true) === 0)\n\t\t\t\t{\n\t\t\t\t\t$oField->SetReadOnly(true);\n\t\t\t\t}\n\n\t\t\t\t// Adding attachements field in transition only if it is editable\n\t\t\t\tif (!$this->IsTransitionForm() || ($this->IsTransitionForm() && !$oField->GetReadOnly()))\n\t\t\t\t{\n\t\t\t\t\t$oForm->AddField($oField);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t$oForm->Finalize();\n\t\t$this->oForm = $oForm;\n\t\t$this->oRenderer->SetForm($this->oForm);\n\t}\n\n\t/**\n\t * @inheritDoc\n\t *\n\t * @throws \\CoreException\n\t * @throws \\CoreUnexpectedValue\n\t * @throws \\DeleteException\n\t * @throws \\MySQLException\n\t * @throws \\OQLException\n\t */\n\tpublic function OnCancel($aArgs = null)\n\t{\n\t\t// Ask to each field to clean itself\n\t\t/** @var \\Combodo\\iTop\\Form\\Field\\Field $oField */\n\t\tforeach ($this->oForm->GetFields() as $oField)\n\t\t{\n\t\t\t$oField->OnCancel();\n\t\t}\n\t\t// Then clean inline images from rich text editor such as TextareaField\n\t\t// Note : This could be done by TextareaField::OnCancel(), but we consider that could have been done in this form outside the field.\n\t\t// Also, it would require the field to know the transaction id which it doesn't as of today.\n\t\tInlineImage::OnFormCancel(utils::GetUploadTempId($this->oForm->GetTransactionId()));\n\t\t// Then clean attachments\n\t\t// TODO : This has to be refactored when the function from itop-attachments has been migrated into the core\n\t\t$this->CancelAttachments();\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tpublic function CheckTransaction(&$aData)\n\t{\n\t\t$isTransactionValid = \\utils::IsTransactionValid($this->oForm->GetTransactionId(), false); //The transaction token is kept in order to preserve BC with ajax forms (the second call would fail if the token is deleted). (The GC will take care of cleaning the token for us later on)\n\t\tif (!$isTransactionValid) {\n\t\t\tif ($this->oObject->IsNew()) {\n\t\t\t\t$sError = Dict::S('UI:Error:ObjectAlreadyCreated');\n\t\t\t} else {\n\t\t\t\t$sError = Dict::S('UI:Error:ObjectAlreadyUpdated');\n\t\t\t}\n\n\t\t\t$aData['messages']['error'] += [\n\t\t\t\t'_main' => [$sError]\n\t\t\t];\n\t\t\t$aData['valid'] = false;\n\t\t}\n\t}\n\n\t/**\n\t * Validates the form and returns an array with the validation status and the messages.\n\t * If the form is valid, creates/updates the object.\n\t *\n\t * eg :\n\t *  array(\n\t *      'status' => true|false\n\t *      'messages' => array(\n\t *          'errors' => array()\n\t *    )\n\t *\n\t * @inheritDoc\n\t *\n\t * @throws \\ArchivedObjectException\n\t * @throws \\CoreException\n\t * @throws \\CoreUnexpectedValue\n\t * @throws \\MySQLException\n\t * @throws \\MySQLHasGoneAwayException\n\t * @throws \\OQLException\n\t */\n\tpublic function OnSubmit($aArgs = null)\n\t{\n\t\t$aData = parent::OnSubmit($aArgs);\n\n\t\tif (! $aData['valid']) {\n\t\t\treturn $aData;\n\t\t}\n\n\t\t// Update object and form\n\t\t$this->OnUpdate($aArgs);\n\n\t\t// Check if form valid\n\t\tif (! $this->oForm->Validate())\n\t\t{\n\t\t\t// Handle errors\n\t\t\t$aData['valid'] = false;\n\t\t\t$aData['messages']['error'] += $this->oForm->GetErrorMessages();\n\t\t\treturn $aData;\n\t\t}\n\n\t\t$sObjectClass = get_class($this->oObject);\n\n\t\ttry {\n\t\t\t// Forcing allowed writing on the object if necessary. This is used in some particular cases.\n\t\t\t$bAllowWrite = ($sObjectClass === 'Person' && $this->oObject->GetKey() == UserRights::GetContactId());\n\t\t\tif ($bAllowWrite) {\n\t\t\t\t$this->oObject->AllowWrite(true);\n\t\t\t}\n\n\t\t\t// Writing object to DB\n\t\t\t$bIsNew = $this->oObject->IsNew();\n\t\t\t$bWasModified = $this->oObject->IsModified();\n\t\t\t$bActivateTriggers = (!$bIsNew && $bWasModified);\n\t\t\ttry\n\t\t\t{\n\t\t\t\t$this->oObject->DBWrite();\n\t\t\t}\n\t\t\tcatch (Exception $e) {\n\t\t\t\tif ($bIsNew) {\n\t\t\t\t\tthrow new Exception(Dict::S('Portal:Error:ObjectCannotBeCreated'));\n\t\t\t\t}\n\t\t\t\tthrow new Exception(Dict::S('Portal:Error:ObjectCannotBeUpdated'));\n\t\t\t}\n\t\t\t// Finalizing images link to object, otherwise it will be cleaned by the GC\n\t\t\tInlineImage::FinalizeInlineImages($this->oObject);\n\t\t\t// Finalizing attachments link to object\n\t\t\t// TODO : This has to be refactored when the function from itop-attachments has been migrated into the core\n\t\t\tif (isset($aArgs['attachmentIds']))\n\t\t\t{\n\t\t\t\t$this->FinalizeAttachments($aArgs['attachmentIds']);\n\t\t\t}\n\n\t\t\t// Checking if we have to apply a stimulus\n\t\t\tif (isset($aArgs['applyStimulus']))\n\t\t\t{\n\t\t\t\t$this->oObject->ApplyStimulus($aArgs['applyStimulus']['code']);\n\t\t\t}\n\t\t\t// Activating triggers only on update\n\t\t\tif ($bActivateTriggers)\n\t\t\t{\n\t\t\t\t$sTriggersQuery = $this->oContainer->getParameter('combodo.portal.instance.conf')['properties']['triggers_query'];\n\t\t\t\tif ($sTriggersQuery !== null)\n\t\t\t\t{\n\t\t\t\t\t$aParentClasses = MetaModel::EnumParentClasses($sObjectClass, ENUM_PARENT_CLASSES_ALL);\n\t\t\t\t\t$oTriggerSet = new DBObjectSet(DBObjectSearch::FromOQL($sTriggersQuery), array(),\n\t\t\t\t\t\tarray('parent_classes' => $aParentClasses));\n\t\t\t\t\t/** @var \\Trigger $oTrigger */\n\t\t\t\t\twhile ($oTrigger = $oTriggerSet->Fetch())\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$oTrigger->DoActivate($this->oObject->ToArgs('this'));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(Exception $e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tutils::EnrichRaisedException($oTrigger, $e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Resetting caselog fields value, otherwise the value will stay in it after submit.\n\t\t\t$this->oForm->ResetCaseLogFields();\n\n\t\t\tif ($bWasModified)\n\t\t\t{\n\t\t\t\t//=if (isNew) because $bActivateTriggers = (!$this->oObject->IsNew() && $this->oObject->IsModified())\n\t\t\t\tif(!$bActivateTriggers)\n\t\t\t\t{\n\t\t\t\t\t$aData['messages']['success'] += array(\t'_main' => array(Dict::Format('UI:Title:Object_Of_Class_Created', $this->oObject->GetName(),MetaModel::GetName(get_class($this->oObject)))));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$aData['messages']['success'] += array('_main' => array(Dict::Format('UI:Class_Object_Updated', MetaModel::GetName(get_class($this->oObject)), $this->oObject->GetName())));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception $e)\n\t\t{\n\t\t\t$aData['valid'] = false;\n\t\t\t$aData['messages']['error'] += array('_main' => array($e->getMessage()));\n\t\t\tIssueLog::Error(__METHOD__.' at line '.__LINE__.' : '.$e->getMessage());\n\t\t}\n\n\t\treturn $aData;\n\t}\n\n\t/**\n\t * Updates the form and its fields with the current values\n\t *\n\t * Note : Doesn't update the object, see ObjectFormManager::OnSubmit() for that;\n\t *\n\t * @inheritDoc\n\t *\n\t * @throws \\ArchivedObjectException\n\t * @throws \\CoreException\n\t * @throws \\CoreUnexpectedValue\n\t * @throws \\OQLException\n\t * @throws \\Exception\n\t */\n\tpublic function OnUpdate($aArgs = null)\n\t{\n\t\t$aFormProperties = array();\n\n\t\tif (is_array($aArgs))\n\t\t{\n\t\t\t// First we need to update the Object with its new values in order to enable the dependents fields to update\n\t\t\tif (isset($aArgs['currentValues']))\n\t\t\t{\n\t\t\t\t$aCurrentValues = $aArgs['currentValues'];\n\t\t\t\t$sObjectClass = get_class($this->oObject);\n\t\t\t\tforeach ($aCurrentValues as $sAttCode => $value)\n\t\t\t\t{\n\t\t\t\t\tif (MetaModel::IsValidAttCode($sObjectClass, $sAttCode))\n\t\t\t\t\t{\n\t\t\t\t\t\t/** @var \\AttributeDefinition $oAttDef */\n\t\t\t\t\t\t$oAttDef = MetaModel::GetAttributeDef($sObjectClass, $sAttCode);\n\t\t\t\t\t\tif ($oAttDef->IsLinkSet())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/** @var \\AttributeLinkedSet $oAttDef */\n\n\t\t\t\t\t\t\t// Parsing JSON value\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// Note : The value was passed as a string instead of an array because the attribute would not be included in the $aCurrentValues when empty.\n\t\t\t\t\t\t\t// Which was an issue when deleting all objects from linkedset\n\t\t\t\t\t\t\t$value = json_decode($value, true);\n\n\t\t\t\t\t\t\t/** @var \\ormLinkSet $oLinkSet */\n\t\t\t\t\t\t\t$oLinkSet = $this->oObject->Get($sAttCode);\n\t\t\t\t\t\t\t$sLinkedClass = $oAttDef->GetLinkedClass();\n\n\t\t\t\t\t\t\t// Checking links to remove\n\t\t\t\t\t\t\tif (isset($value['remove']))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tforeach ($value['remove'] as $iObjKey => $aObjData)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t$oLinkSet->RemoveItem($iObjKey);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Checking links to add\n\t\t\t\t\t\t\tif (isset($value['add']))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tforeach ($value['add'] as $iObjKey => $aObjdata)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Creating link when linkset is indirect...\n\t\t\t\t\t\t\t\t\tif ($oAttDef->IsIndirect())\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t/** @var \\AttributeLinkedSetIndirect $oAttDef */\n\t\t\t\t\t\t\t\t\t\t$oLink = MetaModel::NewObject($sLinkedClass);\n\t\t\t\t\t\t\t\t\t\t$oLink->Set($oAttDef->GetExtKeyToRemote(), $iObjKey);\n\t\t\t\t\t\t\t\t\t\t$oLink->Set($oAttDef->GetExtKeyToMe(), $this->oObject->GetKey());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// ... or adding remote object when linkset id direct\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t// Note : AllowAllData set to true here instead of checking scope's flag because we are displaying a value that has been set and validated\n\t\t\t\t\t\t\t\t\t\t$oLink = MetaModel::GetObject($sLinkedClass, $iObjKey, false, true);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ($oLink !== null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t$oLinkSet->AddItem($oLink);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Checking links to modify\n\t\t\t\t\t\t\t// TODO: Not implemented yet as we can't change lnk properties in the portal\n\n\t\t\t\t\t\t\t// Setting value in the object\n\t\t\t\t\t\t\t$this->oObject->Set($sAttCode, $oLinkSet);\n\t\t\t\t\t\t} elseif ($oAttDef instanceof AttributeSet) {\n\t\t\t\t\t\t\t/** @var \\ormSet $oTagSet */\n\t\t\t\t\t\t\t$oOrmSet = $this->oObject->Get($sAttCode);\n\t\t\t\t\t\t\tif (is_null($oOrmSet)) {\n\t\t\t\t\t\t\t\t$oOrmSet = new \\ormSet(get_class($this->oObject), $sAttCode, $oAttDef->GetMaxItems());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$oOrmSet->ApplyDelta(json_decode($value, true));\n\t\t\t\t\t\t\t$this->oObject->Set($sAttCode, $oOrmSet);\n\t\t\t\t\t\t} elseif ($oAttDef instanceof AttributeDateTime) // AttributeDate is derived from AttributeDateTime\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ($value != null) {\n\t\t\t\t\t\t\t\t$value = $oAttDef->GetFormat()->Parse($value);\n\t\t\t\t\t\t\t\tif (is_object($value)) {\n\t\t\t\t\t\t\t\t\t$value = $value->format($oAttDef->GetInternalFormat());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$this->oObject->Set($sAttCode, $value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telseif ($oAttDef->IsScalar() && is_array($value))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$this->oObject->Set($sAttCode, current($value));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telseif ($oAttDef->GetEditClass() === 'CustomFields')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// We don't update attribute as ormCustomField comparaison is not working as excepted.\n\t\t\t\t\t\t\t// When several templates available, \"template_id\" is not sent by the portal has it is a read-only select input\n\t\t\t\t\t\t\t// therefore, the TemplateFieldsHandler::CompareValues() doesn't work.\n\t\t\t\t\t\t\t// This use case works in the console as it always send all fields, even hidden and read-only.\n\n\t\t\t\t\t\t\t// Different templates\n\t\t\t\t\t\t\tif (isset($value['template_id'])\n\t\t\t\t\t\t\t\t&& ($value['template_id'] != $value['current_template_id']))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$this->oObject->Set($sAttCode, $value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Same template, different fields\n\t\t\t\t\t\t\telseif (isset($value['template_id'], $value['template_data'])\n\t\t\t\t\t\t\t\t&& ($value['template_id'] == $value['current_template_id'])\n\t\t\t\t\t\t\t\t&& ($value['template_data'] != $value['current_template_data']))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$this->oObject->Set($sAttCode, $value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Update of current values\n\t\t\t\t\t\t\telseif (isset($value['user_data']))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$this->oObject->Set($sAttCode, $value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Else don't update! Otherwise we might loose current value\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$this->oObject->Set($sAttCode, $value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$this->oObject->DoComputeValues();\n\t\t\t}\n\n\t\t\t// Then we retrieve properties of the form to build\n\t\t\tif (isset($aArgs['formProperties']))\n\t\t\t{\n\t\t\t\t$aFormProperties = $aArgs['formProperties'];\n\t\t\t}\n\t\t}\n\t\t// Then we build and update form\n\t\t// - We update form properties only we don't have any yet. This is a fallback for cases when form properties where not among the JSON data\n\t\tif ($this->GetFormProperties() === null)\n\t\t{\n\t\t\t$this->SetFormProperties($aFormProperties);\n\t\t}\n\t\t$this->Build();\n\t}\n\n\t/**\n\t * This is a temporary function until the Attachment refactoring is done. It should be remove once it's done.\n\t * It is inspired from itop-attachments/main.attachments.php / UpdateAttachments()\n\t *\n\t * @param array $aAttachmentIds\n\t *\n\t * @throws \\CoreException\n\t * @throws \\CoreUnexpectedValue\n\t * @throws \\DeleteException\n\t * @throws \\OQLException\n\t */\n\tprotected function FinalizeAttachments($aAttachmentIds)\n\t{\n\t\t$aRemovedAttachmentsIds = (isset($aAttachmentIds['removed_attachments_ids'])) ? $aAttachmentIds['removed_attachments_ids'] : array();\n\t\t// Not used for now. //$aActualAttachmentsIds = (isset($aAttachmentIds['actual_attachments_ids'])) ? $aAttachmentIds['actual_attachments_ids'] : array();\n\t\t$aActions = array();\n\n\t\t// Removing attachments from currents\n\t\tif (!empty($aRemovedAttachmentsIds))\n\t\t{\n\t\t\t$oSearch = DBObjectSearch::FromOQL(\"SELECT Attachment WHERE item_class = :class AND item_id = :item_id\");\n\t\t\t$oSet = new DBObjectSet($oSearch, array(), array('class' => get_class($this->oObject), 'item_id' => $this->oObject->GetKey()));\n\t\t\twhile ($oAttachment = $oSet->Fetch())\n\t\t\t{\n\t\t\t\t// Remove attachments that are no longer attached to the current object\n\t\t\t\tif (in_array($oAttachment->GetKey(), $aRemovedAttachmentsIds))\n\t\t\t\t{\n\t\t\t\t\t$oAttachment->DBDelete();\n\t\t\t\t\t$aActions[] = self::GetAttachmentActionChangeOp($oAttachment, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Processing temporary attachments\n\t\t$sTempId = utils::GetUploadTempId($this->oForm->GetTransactionId());\n\t\t$sOQL = 'SELECT Attachment WHERE temp_id = :temp_id';\n\t\t$oSearch = DBObjectSearch::FromOQL($sOQL);\n\t\t$oSet = new DBObjectSet($oSearch, array(), array('temp_id' => $sTempId));\n\t\twhile ($oAttachment = $oSet->Fetch())\n\t\t{\n\t\t\t// Temp attachment removed\n\t\t\tif (in_array($oAttachment->GetKey(), $aRemovedAttachmentsIds))\n\t\t\t{\n\t\t\t\t$oAttachment->DBDelete();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$oAttachment->SetItem($this->oObject);\n\t\t\t\t$oAttachment->Set('temp_id', '');\n\t\t\t\t$oAttachment->DBUpdate();\n\t\t\t\t$aActions[] = self::GetAttachmentActionChangeOp($oAttachment, true);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Save changes to current object history\n\t\t// inspired from itop-attachments/main.attachments.php / RecordHistory\n\t\tforeach ($aActions as $oChangeOp)\n\t\t{\n\t\t\t$oChangeOp->Set(\"objclass\", get_class($this->oObject));\n\t\t\t$oChangeOp->Set(\"objkey\", $this->oObject->GetKey());\n\t\t\t$oChangeOp->DBInsertNoReload();\n\t\t}\n\t}\n\n\t/**\n\t * This is a temporary function until the Attachment refactoring is done. It should be remove once it's done.\n\t * It is inspired from itop-attachments/main.attachments.php / UpdateAttachments()\n\t *\n\t * @throws \\CoreException\n\t * @throws \\CoreUnexpectedValue\n\t * @throws \\DeleteException\n\t * @throws \\MySQLException\n\t * @throws \\OQLException\n\t */\n\tprotected function CancelAttachments()\n\t{\n\t\t// Processing temporary attachments\n\t\t$sTempId = utils::GetUploadTempId($this->oForm->GetTransactionId());\n\t\t$sOQL = 'SELECT Attachment WHERE temp_id = :temp_id';\n\t\t$oSearch = DBObjectSearch::FromOQL($sOQL);\n\t\t$oSet = new DBObjectSet($oSearch, array(), array('temp_id' => $sTempId));\n\t\twhile ($oAttachment = $oSet->Fetch())\n\t\t{\n\t\t\t$oAttachment->DBDelete();\n\t\t}\n\t}\n\n\t/**\n\t * This is a temporary function until the Attachment refactoring is done. It should be remove once it's done.\n\t * It is inspired from itop-attachments/main.attachments.php / GetActionChangeOp()\n\t *\n\t * @param $oAttachment\n\t * @param bool $bCreate\n\t *\n\t * @return \\CMDBChangeOpAttachmentAdded|\\CMDBChangeOpAttachmentRemoved\n\t * @throws \\CoreException\n\t * @throws \\CoreUnexpectedValue\n\t */\n\tprivate static function GetAttachmentActionChangeOp($oAttachment, $bCreate = true)\n\t{\n\t\t$oBlob = $oAttachment->Get('contents');\n\t\t$sFileName = $oBlob->GetFileName();\n\t\tif ($bCreate)\n\t\t{\n\t\t\t$oChangeOp = new CMDBChangeOpAttachmentAdded();\n\t\t\t$oChangeOp->Set('attachment_id', $oAttachment->GetKey());\n\t\t\t$oChangeOp->Set('filename', $sFileName);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$oChangeOp = new CMDBChangeOpAttachmentRemoved();\n\t\t\t$oChangeOp->Set('filename', $sFileName);\n\t\t}\n\t\treturn $oChangeOp;\n\t}\n\n\t/**\n\t * @return array\n\t * @since 2.7.5\n\t */\n\tpublic function GetHiddenFieldsId()\n\t{\n\t\treturn $this->aHiddenFieldsId;\n\t}\n\n\t/**\n\t * @param array $aHiddenFieldsId\n\t * @since 2.7.5\n\t */\n\tpublic function SetHiddenFieldsId($aHiddenFieldsId)\n\t{\n\t\t$this->aHiddenFieldsId = $aHiddenFieldsId;\n\t}\n}\n"], "filenames": ["datamodels/2.x/itop-portal-base/portal/src/Form/ObjectFormManager.php"], "buggy_code_start_loc": [81], "buggy_code_end_loc": [184], "fixing_code_start_loc": [82], "fixing_code_end_loc": [197], "type": "CWE-94", "message": "Combodo iTop is a web based IT Service Management tool. In versions prior to 2.7.6 and 3.0.0, users of the iTop user portal can send TWIG code to the server by forging specific http queries, and execute arbitrary code on the server using http server user privileges. This issue is fixed in versions 2.7.6 and 3.0.0. There are currently no known workarounds.", "other": {"cve": {"id": "CVE-2022-24780", "sourceIdentifier": "security-advisories@github.com", "published": "2022-04-05T19:15:08.100", "lastModified": "2022-10-07T03:33:58.320", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Combodo iTop is a web based IT Service Management tool. In versions prior to 2.7.6 and 3.0.0, users of the iTop user portal can send TWIG code to the server by forging specific http queries, and execute arbitrary code on the server using http server user privileges. This issue is fixed in versions 2.7.6 and 3.0.0. There are currently no known workarounds."}, {"lang": "es", "value": "Combodo iTop es una herramienta de Administraci\u00f3n de Servicios de TI basada en la web. En versiones anteriores a 2.7.6 y 3.0.0, los usuarios del portal de usuarios de iTop pueden enviar c\u00f3digo TWIG al servidor al falsificar consultas http espec\u00edficas, y ejecutar c\u00f3digo arbitrario en el servidor usando privilegios de usuario del servidor http. Este problema ha sido solucionado en versiones 2.7.6 y 3.0.0. Actualmente no son conocidas medidas de mitigaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.6", "matchCriteriaId": "EFDA4E60-0B4B-4E74-BAAD-AA774836EBA9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:3.0.0:alpha:*:*:*:*:*:*", "matchCriteriaId": "608F63C6-0F54-47D8-BFD5-FB5511BDB548"}, {"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:3.0.0:beta:*:*:*:*:*:*", "matchCriteriaId": "DD7E6A6A-9B1D-4BA7-9A58-ACEE1ABC46EB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:3.0.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "E0F94E71-E468-4765-9A44-FCD9121DC414"}, {"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:3.0.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "AF68C176-A8C3-4C88-A344-74CB0E682987"}, {"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:3.0.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "997A26DD-11A4-4D9F-8F6C-845068AE605C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:3.0.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "06061D47-3252-4ED4-9423-600027D39551"}, {"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:3.0.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "A5DFEEA5-6FB7-4583-A13C-B2EE74502B81"}, {"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:3.0.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "D373FD25-9994-4D19-A636-59E9B775D673"}, {"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:3.0.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "A2FE726A-3EF3-497C-8C8E-7F90358AE172"}, {"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:3.0.0:beta8:*:*:*:*:*:*", "matchCriteriaId": "75603E37-CC69-433A-9450-8FCAD26DAA49"}, {"vulnerable": true, "criteria": "cpe:2.3:a:combodo:itop:3.0.0:rc:*:*:*:*:*:*", "matchCriteriaId": "D50B0423-B58B-44DC-A02E-75645DA683B4"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/167236/iTop-Remote-Command-Execution.html", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/Combodo/iTop/commit/93f273a28778e5da8e51096f021d2dc1adbf4ef3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Combodo/iTop/commit/b6fac4b411b8d145fc30fa35c66b51243eafd06b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Combodo/iTop/commit/eb2a615bd28100442c7f6171707bb40884af2305", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Combodo/iTop/security/advisories/GHSA-v97m-wgxq-rh54", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://markus-krell.de/itop-template-injection-inside-customer-portal/", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Combodo/iTop/commit/93f273a28778e5da8e51096f021d2dc1adbf4ef3"}}