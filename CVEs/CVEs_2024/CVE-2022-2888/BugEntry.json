{"buggy_code": ["__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"\n__copyright__ = \"Copyright (C) 2014 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n\nimport hashlib\nimport logging\nimport os\nimport time\nimport uuid\n\nimport wrapt\nfrom flask_login import AnonymousUserMixin, UserMixin\nfrom werkzeug.local import LocalProxy\n\nfrom octoprint.access.groups import Group, GroupChangeListener\nfrom octoprint.access.permissions import OctoPrintPermission, Permissions\nfrom octoprint.settings import settings as s\nfrom octoprint.util import atomic_write, deprecated, generate_api_key\nfrom octoprint.util import get_fully_qualified_classname as fqcn\nfrom octoprint.util import to_bytes, yaml\n\n\nclass UserManager(GroupChangeListener):\n    def __init__(self, group_manager, settings=None):\n        self._group_manager = group_manager\n        self._group_manager.register_listener(self)\n\n        self._logger = logging.getLogger(__name__)\n        self._session_users_by_session = {}\n        self._sessionids_by_userid = {}\n\n        if settings is None:\n            settings = s()\n        self._settings = settings\n\n        self._login_status_listeners = []\n\n    def register_login_status_listener(self, listener):\n        self._login_status_listeners.append(listener)\n\n    def unregister_login_status_listener(self, listener):\n        self._login_status_listeners.remove(listener)\n\n    def anonymous_user_factory(self):\n        return AnonymousUser([self._group_manager.guest_group])\n\n    def api_user_factory(self):\n        return ApiUser([self._group_manager.admin_group, self._group_manager.user_group])\n\n    @property\n    def enabled(self):\n        return True\n\n    def login_user(self, user):\n        self._cleanup_sessions()\n\n        if user is None or user.is_anonymous:\n            return\n\n        if isinstance(user, LocalProxy):\n            # noinspection PyProtectedMember\n            user = user._get_current_object()\n\n        if not isinstance(user, User):\n            return None\n\n        if not isinstance(user, SessionUser):\n            user = SessionUser(user)\n\n        self._session_users_by_session[user.session] = user\n\n        userid = user.get_id()\n        if userid not in self._sessionids_by_userid:\n            self._sessionids_by_userid[userid] = set()\n\n        self._sessionids_by_userid[userid].add(user.session)\n\n        for listener in self._login_status_listeners:\n            try:\n                listener.on_user_logged_in(user)\n            except Exception:\n                self._logger.exception(\n                    f\"Error in on_user_logged_in on {listener!r}\",\n                    extra={\"callback\": fqcn(listener)},\n                )\n\n        self._logger.info(f\"Logged in user: {user.get_id()}\")\n\n        return user\n\n    def logout_user(self, user, stale=False):\n        if user is None or user.is_anonymous:\n            return\n\n        if isinstance(user, LocalProxy):\n            user = user._get_current_object()\n\n        if not isinstance(user, SessionUser):\n            return\n\n        userid = user.get_id()\n        sessionid = user.session\n\n        if userid in self._sessionids_by_userid:\n            try:\n                self._sessionids_by_userid[userid].remove(sessionid)\n            except KeyError:\n                pass\n\n        if sessionid in self._session_users_by_session:\n            try:\n                del self._session_users_by_session[sessionid]\n            except KeyError:\n                pass\n\n        for listener in self._login_status_listeners:\n            try:\n                listener.on_user_logged_out(user, stale=stale)\n            except Exception:\n                self._logger.exception(\n                    f\"Error in on_user_logged_out on {listener!r}\",\n                    extra={\"callback\": fqcn(listener)},\n                )\n\n        self._logger.info(f\"Logged out user: {user.get_id()}\")\n\n    def _cleanup_sessions(self):\n        for session, user in list(self._session_users_by_session.items()):\n            if not isinstance(user, SessionUser):\n                continue\n            if user.created + (24 * 60 * 60) < time.monotonic():\n                self._logger.info(\n                    \"Cleaning up user session {} for user {}\".format(\n                        session, user.get_id()\n                    )\n                )\n                self.logout_user(user, stale=True)\n\n    @staticmethod\n    def create_password_hash(password, salt=None, settings=None):\n        if not salt:\n            if settings is None:\n                settings = s()\n            salt = settings.get([\"accessControl\", \"salt\"])\n            if salt is None:\n                import string\n                from random import choice\n\n                chars = string.ascii_lowercase + string.ascii_uppercase + string.digits\n                salt = \"\".join(choice(chars) for _ in range(32))\n                settings.set([\"accessControl\", \"salt\"], salt)\n                settings.save()\n\n        return hashlib.sha512(\n            to_bytes(password, encoding=\"utf-8\", errors=\"replace\") + to_bytes(salt)\n        ).hexdigest()\n\n    def check_password(self, username, password):\n        user = self.find_user(username)\n        if not user:\n            return False\n\n        hash = UserManager.create_password_hash(password, settings=self._settings)\n        if user.check_password(hash):\n            # new hash matches, correct password\n            return True\n        else:\n            # new hash doesn't match, but maybe the old one does, so check that!\n            oldHash = UserManager.create_password_hash(\n                password, salt=\"mvBUTvwzBzD3yPwvnJ4E4tXNf3CGJvvW\", settings=self._settings\n            )\n            if user.check_password(oldHash):\n                # old hash matches, we migrate the stored password hash to the new one and return True since it's the correct password\n                self.change_user_password(username, password)\n                return True\n            else:\n                # old hash doesn't match either, wrong password\n                return False\n\n    def add_user(self, username, password, active, permissions, groups, overwrite=False):\n        pass\n\n    def change_user_activation(self, username, active):\n        pass\n\n    def change_user_permissions(self, username, permissions):\n        pass\n\n    def add_permissions_to_user(self, username, permissions):\n        pass\n\n    def remove_permissions_from_user(self, username, permissions):\n        pass\n\n    def change_user_groups(self, username, groups):\n        pass\n\n    def add_groups_to_user(self, username, groups):\n        pass\n\n    def remove_groups_from_user(self, username, groups):\n        pass\n\n    def remove_groups_from_users(self, group):\n        pass\n\n    def change_user_password(self, username, password):\n        pass\n\n    def get_user_setting(self, username, key):\n        return None\n\n    def get_all_user_settings(self, username):\n        return {}\n\n    def change_user_setting(self, username, key, value):\n        pass\n\n    def change_user_settings(self, username, new_settings):\n        pass\n\n    def remove_user(self, username):\n        if username in self._sessionids_by_userid:\n            sessions = self._sessionids_by_userid[username]\n            for session in sessions:\n                if session in self._session_users_by_session:\n                    del self._session_users_by_session[session]\n            del self._sessionids_by_userid[username]\n\n    def validate_user_session(self, userid, session):\n        if session in self._session_users_by_session:\n            user = self._session_users_by_session[session]\n            return userid == user.get_id()\n\n        return False\n\n    def find_user(self, userid=None, session=None):\n        if session is not None and session in self._session_users_by_session:\n            user = self._session_users_by_session[session]\n            if userid is None or userid == user.get_id():\n                return user\n\n        return None\n\n    def find_sessions_for(self, matcher):\n        result = []\n        for user in self.get_all_users():\n            if matcher(user):\n                try:\n                    session_ids = self._sessionids_by_userid[user.get_id()]\n                    for session_id in session_ids:\n                        try:\n                            result.append(self._session_users_by_session[session_id])\n                        except KeyError:\n                            # unknown session after all\n                            continue\n                except KeyError:\n                    # no session for user\n                    pass\n        return result\n\n    def get_all_users(self):\n        return []\n\n    def has_been_customized(self):\n        return False\n\n    def on_group_removed(self, group):\n        self._logger.debug(f\"Group {group.key} got removed, removing from all users\")\n        self.remove_groups_from_users([group])\n\n    def on_group_permissions_changed(self, group, added=None, removed=None):\n        users = self.find_sessions_for(lambda u: group in u.groups)\n        for listener in self._login_status_listeners:\n            try:\n                for user in users:\n                    listener.on_user_modified(user)\n            except Exception:\n                self._logger.exception(\n                    f\"Error in on_user_modified on {listener!r}\",\n                    extra={\"callback\": fqcn(listener)},\n                )\n\n    def on_group_subgroups_changed(self, group, added=None, removed=None):\n        users = self.find_sessions_for(lambda u: group in u.groups)\n        for listener in self._login_status_listeners:\n            # noinspection PyBroadException\n            try:\n                for user in users:\n                    listener.on_user_modified(user)\n            except Exception:\n                self._logger.exception(\n                    f\"Error in on_user_modified on {listener!r}\",\n                    extra={\"callback\": fqcn(listener)},\n                )\n\n    def _trigger_on_user_modified(self, user):\n        if isinstance(user, str):\n            # user id\n            users = []\n            try:\n                session_ids = self._sessionids_by_userid[user]\n                for session_id in session_ids:\n                    try:\n                        users.append(self._session_users_by_session[session_id])\n                    except KeyError:\n                        # unknown session id\n                        continue\n            except KeyError:\n                # no session for user\n                return\n        elif isinstance(user, User) and not isinstance(user, SessionUser):\n            users = self.find_sessions_for(lambda u: u.get_id() == user.get_id())\n        elif isinstance(user, User):\n            users = [user]\n        else:\n            return\n\n        for listener in self._login_status_listeners:\n            try:\n                for user in users:\n                    listener.on_user_modified(user)\n            except Exception:\n                self._logger.exception(\n                    f\"Error in on_user_modified on {listener!r}\",\n                    extra={\"callback\": fqcn(listener)},\n                )\n\n    def _trigger_on_user_removed(self, username):\n        for listener in self._login_status_listeners:\n            try:\n                listener.on_user_removed(username)\n            except Exception:\n                self._logger.exception(\n                    f\"Error in on_user_removed on {listener!r}\",\n                    extra={\"callback\": fqcn(listener)},\n                )\n\n    # ~~ Deprecated methods follow\n\n    # TODO: Remove deprecated methods in OctoPrint 1.5.0\n\n    @staticmethod\n    def createPasswordHash(*args, **kwargs):\n        \"\"\"\n        .. deprecated: 1.4.0\n\n           Replaced by :func:`~UserManager.create_password_hash`\n        \"\"\"\n        # we can't use the deprecated decorator here since this method is static\n        import warnings\n\n        warnings.warn(\n            \"createPasswordHash has been renamed to create_password_hash\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return UserManager.create_password_hash(*args, **kwargs)\n\n    @deprecated(\n        \"changeUserRoles has been replaced by change_user_permissions\",\n        includedoc=\"Replaced by :func:`change_user_permissions`\",\n        since=\"1.4.0\",\n    )\n    def changeUserRoles(self, username, roles):\n        user = self.find_user(username)\n        if user is None:\n            raise UnknownUser(username)\n\n        removed_roles = set(user._roles) - set(roles)\n        self.removeRolesFromUser(username, removed_roles, user=user)\n\n        added_roles = set(roles) - set(user._roles)\n        self.addRolesToUser(username, added_roles, user=user)\n\n    @deprecated(\n        \"addRolesToUser has been replaced by add_permissions_to_user\",\n        includedoc=\"Replaced by :func:`add_permissions_to_user`\",\n        since=\"1.4.0\",\n    )\n    def addRolesToUser(self, username, roles, user=None):\n        if user is None:\n            user = self.find_user(username)\n\n        if user is None:\n            raise UnknownUser(username)\n\n        if \"admin\" in roles:\n            self.add_groups_to_user(username, self._group_manager.admin_group)\n\n        if \"user\" in roles:\n            self.remove_groups_from_user(username, self._group_manager.user_group)\n\n    @deprecated(\n        \"removeRolesFromUser has been replaced by remove_permissions_from_user\",\n        includedoc=\"Replaced by :func:`remove_permissions_from_user`\",\n        since=\"1.4.0\",\n    )\n    def removeRolesFromUser(self, username, roles, user=None):\n        if user is None:\n            user = self.find_user(username)\n\n        if user is None:\n            raise UnknownUser(username)\n\n        if \"admin\" in roles:\n            self.remove_groups_from_user(username, self._group_manager.admin_group)\n            self.remove_permissions_from_user(username, Permissions.ADMIN)\n\n        if \"user\" in roles:\n            self.remove_groups_from_user(username, self._group_manager.user_group)\n\n    checkPassword = deprecated(\n        \"checkPassword has been renamed to check_password\",\n        includedoc=\"Replaced by :func:`check_password`\",\n        since=\"1.4.0\",\n    )(check_password)\n    addUser = deprecated(\n        \"addUser has been renamed to add_user\",\n        includedoc=\"Replaced by :func:`add_user`\",\n        since=\"1.4.0\",\n    )(add_user)\n    changeUserActivation = deprecated(\n        \"changeUserActivation has been renamed to change_user_activation\",\n        includedoc=\"Replaced by :func:`change_user_activation`\",\n        since=\"1.4.0\",\n    )(change_user_activation)\n    changeUserPassword = deprecated(\n        \"changeUserPassword has been renamed to change_user_password\",\n        includedoc=\"Replaced by :func:`change_user_password`\",\n        since=\"1.4.0\",\n    )(change_user_password)\n    getUserSetting = deprecated(\n        \"getUserSetting has been renamed to get_user_setting\",\n        includedoc=\"Replaced by :func:`get_user_setting`\",\n        since=\"1.4.0\",\n    )(get_user_setting)\n    getAllUserSettings = deprecated(\n        \"getAllUserSettings has been renamed to get_all_user_settings\",\n        includedoc=\"Replaced by :func:`get_all_user_settings`\",\n        since=\"1.4.0\",\n    )(get_all_user_settings)\n    changeUserSetting = deprecated(\n        \"changeUserSetting has been renamed to change_user_setting\",\n        includedoc=\"Replaced by :func:`change_user_setting`\",\n        since=\"1.4.0\",\n    )(change_user_setting)\n    changeUserSettings = deprecated(\n        \"changeUserSettings has been renamed to change_user_settings\",\n        includedoc=\"Replaced by :func:`change_user_settings`\",\n        since=\"1.4.0\",\n    )(change_user_settings)\n    removeUser = deprecated(\n        \"removeUser has been renamed to remove_user\",\n        includedoc=\"Replaced by :func:`remove_user`\",\n        since=\"1.4.0\",\n    )(remove_user)\n    findUser = deprecated(\n        \"findUser has been renamed to find_user\",\n        includedoc=\"Replaced by :func:`find_user`\",\n        since=\"1.4.0\",\n    )(find_user)\n    getAllUsers = deprecated(\n        \"getAllUsers has been renamed to get_all_users\",\n        includedoc=\"Replaced by :func:`get_all_users`\",\n        since=\"1.4.0\",\n    )(get_all_users)\n    hasBeenCustomized = deprecated(\n        \"hasBeenCustomized has been renamed to has_been_customized\",\n        includedoc=\"Replaced by :func:`has_been_customized`\",\n        since=\"1.4.0\",\n    )(has_been_customized)\n\n\nclass LoginStatusListener:\n    def on_user_logged_in(self, user):\n        pass\n\n    def on_user_logged_out(self, user, stale=False):\n        pass\n\n    def on_user_modified(self, user):\n        pass\n\n    def on_user_removed(self, userid):\n        pass\n\n\n##~~ FilebasedUserManager, takes available users from users.yaml file\n\n\nclass FilebasedUserManager(UserManager):\n    def __init__(self, group_manager, path=None, settings=None):\n        UserManager.__init__(self, group_manager, settings=settings)\n\n        self._logger = logging.getLogger(__name__)\n\n        if path is None:\n            path = self._settings.get([\"accessControl\", \"userfile\"])\n            if path is None:\n                path = os.path.join(s().getBaseFolder(\"base\"), \"users.yaml\")\n\n        self._userfile = path\n\n        self._users = {}\n        self._dirty = False\n\n        self._customized = None\n        self._load()\n\n    def _load(self):\n        if os.path.exists(self._userfile) and os.path.isfile(self._userfile):\n            data = yaml.load_from_file(path=self._userfile)\n\n            if not data or not isinstance(data, dict):\n                self._logger.fatal(\n                    \"{} does not contain a valid map of users. Fix \"\n                    \"the file, or remove it, then restart OctoPrint.\".format(\n                        self._userfile\n                    )\n                )\n                raise CorruptUserStorage()\n\n            for name, attributes in data.items():\n                if not isinstance(attributes, dict):\n                    continue\n\n                permissions = []\n                if \"permissions\" in attributes:\n                    permissions = attributes[\"permissions\"]\n\n                if \"groups\" in attributes:\n                    groups = set(attributes[\"groups\"])\n                else:\n                    groups = {self._group_manager.user_group}\n\n                # migrate from roles to permissions\n                if \"roles\" in attributes and \"permissions\" not in attributes:\n                    self._logger.info(\n                        f\"Migrating user {name} to new granular permission system\"\n                    )\n\n                    groups |= set(self._migrate_roles_to_groups(attributes[\"roles\"]))\n                    self._dirty = True\n\n                apikey = None\n                if \"apikey\" in attributes:\n                    apikey = attributes[\"apikey\"]\n                settings = {}\n                if \"settings\" in attributes:\n                    settings = attributes[\"settings\"]\n\n                self._users[name] = User(\n                    username=name,\n                    passwordHash=attributes[\"password\"],\n                    active=attributes[\"active\"],\n                    permissions=self._to_permissions(*permissions),\n                    groups=self._to_groups(*groups),\n                    apikey=apikey,\n                    settings=settings,\n                )\n                for sessionid in self._sessionids_by_userid.get(name, set()):\n                    if sessionid in self._session_users_by_session:\n                        self._session_users_by_session[sessionid].update_user(\n                            self._users[name]\n                        )\n\n            if self._dirty:\n                self._save()\n\n            self._customized = True\n        else:\n            self._customized = False\n\n    def _save(self, force=False):\n        if not self._dirty and not force:\n            return\n\n        data = {}\n        for name, user in self._users.items():\n            if not user or not isinstance(user, User):\n                continue\n\n            data[name] = {\n                \"password\": user._passwordHash,\n                \"active\": user._active,\n                \"groups\": self._from_groups(*user._groups),\n                \"permissions\": self._from_permissions(*user._permissions),\n                \"apikey\": user._apikey,\n                \"settings\": user._settings,\n                # TODO: deprecated, remove in 1.5.0\n                \"roles\": user._roles,\n            }\n\n        with atomic_write(\n            self._userfile, mode=\"wt\", permissions=0o600, max_permissions=0o666\n        ) as f:\n            yaml.save_to_file(data, file=f, pretty=True)\n            self._dirty = False\n        self._load()\n\n    def _migrate_roles_to_groups(self, roles):\n        # If admin is inside the roles, just return admin group\n        if \"admin\" in roles:\n            return [self._group_manager.admin_group, self._group_manager.user_group]\n        else:\n            return [self._group_manager.user_group]\n\n    def _refresh_groups(self, user):\n        user._groups = self._to_groups(*map(lambda g: g.key, user.groups))\n\n    def add_user(\n        self,\n        username,\n        password,\n        active=False,\n        permissions=None,\n        groups=None,\n        apikey=None,\n        overwrite=False,\n    ):\n        if not permissions:\n            permissions = []\n        permissions = self._to_permissions(*permissions)\n\n        if not groups:\n            groups = self._group_manager.default_groups\n        groups = self._to_groups(*groups)\n\n        if username in self._users and not overwrite:\n            raise UserAlreadyExists(username)\n\n        self._users[username] = User(\n            username,\n            UserManager.create_password_hash(password, settings=self._settings),\n            active,\n            permissions,\n            groups,\n            apikey=apikey,\n        )\n        self._dirty = True\n        self._save()\n\n    def change_user_activation(self, username, active):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        if self._users[username].is_active != active:\n            self._users[username]._active = active\n            self._dirty = True\n            self._save()\n\n            self._trigger_on_user_modified(username)\n\n    def change_user_permissions(self, username, permissions):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        user = self._users[username]\n\n        permissions = self._to_permissions(*permissions)\n\n        removed_permissions = list(set(user._permissions) - set(permissions))\n        added_permissions = list(set(permissions) - set(user._permissions))\n\n        if len(removed_permissions) > 0:\n            user.remove_permissions_from_user(removed_permissions)\n            self._dirty = True\n\n        if len(added_permissions) > 0:\n            user.add_permissions_to_user(added_permissions)\n            self._dirty = True\n\n        if self._dirty:\n            self._save()\n            self._trigger_on_user_modified(username)\n\n    def add_permissions_to_user(self, username, permissions):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        if self._users[username].add_permissions_to_user(\n            self._to_permissions(*permissions)\n        ):\n            self._dirty = True\n            self._save()\n            self._trigger_on_user_modified(username)\n\n    def remove_permissions_from_user(self, username, permissions):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        if self._users[username].remove_permissions_from_user(\n            self._to_permissions(*permissions)\n        ):\n            self._dirty = True\n            self._save()\n            self._trigger_on_user_modified(username)\n\n    def remove_permissions_from_users(self, permissions):\n        modified = []\n        for user in self._users:\n            dirty = user.remove_permissions_from_user(self._to_permissions(*permissions))\n            if dirty:\n                self._dirty = True\n                modified.append(user.get_id())\n\n        if self._dirty:\n            self._save()\n            for username in modified:\n                self._trigger_on_user_modified(username)\n\n    def change_user_groups(self, username, groups):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        user = self._users[username]\n\n        groups = self._to_groups(*groups)\n\n        removed_groups = list(set(user._groups) - set(groups))\n        added_groups = list(set(groups) - set(user._groups))\n\n        if len(removed_groups):\n            self._dirty |= user.remove_groups_from_user(removed_groups)\n        if len(added_groups):\n            self._dirty |= user.add_groups_to_user(added_groups)\n\n        if self._dirty:\n            self._save()\n            self._trigger_on_user_modified(username)\n\n    def add_groups_to_user(self, username, groups, save=True, notify=True):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        if self._users[username].add_groups_to_user(self._to_groups(*groups)):\n            self._dirty = True\n\n            if save:\n                self._save()\n\n            if notify:\n                self._trigger_on_user_modified(username)\n\n    def remove_groups_from_user(self, username, groups, save=True, notify=True):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        if self._users[username].remove_groups_from_user(self._to_groups(*groups)):\n            self._dirty = True\n\n            if save:\n                self._save()\n\n            if notify:\n                self._trigger_on_user_modified(username)\n\n    def remove_groups_from_users(self, groups):\n        modified = []\n        for username, user in self._users.items():\n            dirty = user.remove_groups_from_user(self._to_groups(*groups))\n            if dirty:\n                self._dirty = True\n                modified.append(username)\n\n        if self._dirty:\n            self._save()\n\n            for username in modified:\n                self._trigger_on_user_modified(username)\n\n    def change_user_password(self, username, password):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        passwordHash = UserManager.create_password_hash(password, settings=self._settings)\n        user = self._users[username]\n        if user._passwordHash != passwordHash:\n            user._passwordHash = passwordHash\n            self._dirty = True\n            self._save()\n\n    def change_user_setting(self, username, key, value):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        user = self._users[username]\n        old_value = user.get_setting(key)\n        if not old_value or old_value != value:\n            user.set_setting(key, value)\n            self._dirty = self._dirty or old_value != value\n            self._save()\n\n    def change_user_settings(self, username, new_settings):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        user = self._users[username]\n        for key, value in new_settings.items():\n            old_value = user.get_setting(key)\n            user.set_setting(key, value)\n            self._dirty = self._dirty or old_value != value\n        self._save()\n\n    def get_all_user_settings(self, username):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        user = self._users[username]\n        return user.get_all_settings()\n\n    def get_user_setting(self, username, key):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        user = self._users[username]\n        return user.get_setting(key)\n\n    def generate_api_key(self, username):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        user = self._users[username]\n        user._apikey = generate_api_key()\n        self._dirty = True\n        self._save()\n        return user._apikey\n\n    def delete_api_key(self, username):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        user = self._users[username]\n        user._apikey = None\n        self._dirty = True\n        self._save()\n\n    def remove_user(self, username):\n        UserManager.remove_user(self, username)\n\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        del self._users[username]\n        self._dirty = True\n        self._save()\n\n    def find_user(self, userid=None, apikey=None, session=None):\n        user = UserManager.find_user(self, userid=userid, session=session)\n\n        if user is not None:\n            return user\n\n        if userid is not None:\n            if userid not in self._users:\n                return None\n            return self._users[userid]\n\n        elif apikey is not None:\n            for user in self._users.values():\n                if apikey == user._apikey:\n                    return user\n            return None\n\n        else:\n            return None\n\n    def get_all_users(self):\n        return list(self._users.values())\n\n    def has_been_customized(self):\n        return self._customized\n\n    def on_group_permissions_changed(self, group, added=None, removed=None):\n        # refresh our group references\n        for user in self.get_all_users():\n            if group in user.groups:\n                self._refresh_groups(user)\n\n        # call parent\n        UserManager.on_group_permissions_changed(\n            self, group, added=added, removed=removed\n        )\n\n    def on_group_subgroups_changed(self, group, added=None, removed=None):\n        # refresh our group references\n        for user in self.get_all_users():\n            if group in user.groups:\n                self._refresh_groups(user)\n\n        # call parent\n        UserManager.on_group_subgroups_changed(self, group, added=added, removed=removed)\n\n    # ~~ Helpers\n\n    def _to_groups(self, *groups):\n        return list(\n            set(\n                filter(\n                    lambda x: x is not None,\n                    (self._group_manager._to_group(group) for group in groups),\n                )\n            )\n        )\n\n    def _to_permissions(self, *permissions):\n        return list(\n            set(\n                filter(\n                    lambda x: x is not None,\n                    (Permissions.find(permission) for permission in permissions),\n                )\n            )\n        )\n\n    def _from_groups(self, *groups):\n        return list({group.key for group in groups})\n\n    def _from_permissions(self, *permissions):\n        return list({permission.key for permission in permissions})\n\n    # ~~ Deprecated methods follow\n\n    # TODO: Remove deprecated methods in OctoPrint 1.5.0\n\n    generateApiKey = deprecated(\n        \"generateApiKey has been renamed to generate_api_key\",\n        includedoc=\"Replaced by :func:`generate_api_key`\",\n        since=\"1.4.0\",\n    )(generate_api_key)\n    deleteApiKey = deprecated(\n        \"deleteApiKey has been renamed to delete_api_key\",\n        includedoc=\"Replaced by :func:`delete_api_key`\",\n        since=\"1.4.0\",\n    )(delete_api_key)\n    addUser = deprecated(\n        \"addUser has been renamed to add_user\",\n        includedoc=\"Replaced by :func:`add_user`\",\n        since=\"1.4.0\",\n    )(add_user)\n    changeUserActivation = deprecated(\n        \"changeUserActivation has been renamed to change_user_activation\",\n        includedoc=\"Replaced by :func:`change_user_activation`\",\n        since=\"1.4.0\",\n    )(change_user_activation)\n    changeUserPassword = deprecated(\n        \"changeUserPassword has been renamed to change_user_password\",\n        includedoc=\"Replaced by :func:`change_user_password`\",\n        since=\"1.4.0\",\n    )(change_user_password)\n    getUserSetting = deprecated(\n        \"getUserSetting has been renamed to get_user_setting\",\n        includedoc=\"Replaced by :func:`get_user_setting`\",\n        since=\"1.4.0\",\n    )(get_user_setting)\n    getAllUserSettings = deprecated(\n        \"getAllUserSettings has been renamed to get_all_user_settings\",\n        includedoc=\"Replaced by :func:`get_all_user_settings`\",\n        since=\"1.4.0\",\n    )(get_all_user_settings)\n    changeUserSetting = deprecated(\n        \"changeUserSetting has been renamed to change_user_setting\",\n        includedoc=\"Replaced by :func:`change_user_setting`\",\n        since=\"1.4.0\",\n    )(change_user_setting)\n    changeUserSettings = deprecated(\n        \"changeUserSettings has been renamed to change_user_settings\",\n        includedoc=\"Replaced by :func:`change_user_settings`\",\n        since=\"1.4.0\",\n    )(change_user_settings)\n    removeUser = deprecated(\n        \"removeUser has been renamed to remove_user\",\n        includedoc=\"Replaced by :func:`remove_user`\",\n        since=\"1.4.0\",\n    )(remove_user)\n    findUser = deprecated(\n        \"findUser has been renamed to find_user\",\n        includedoc=\"Replaced by :func:`find_user`\",\n        since=\"1.4.0\",\n    )(find_user)\n    getAllUsers = deprecated(\n        \"getAllUsers has been renamed to get_all_users\",\n        includedoc=\"Replaced by :func:`get_all_users`\",\n        since=\"1.4.0\",\n    )(get_all_users)\n    hasBeenCustomized = deprecated(\n        \"hasBeenCustomized has been renamed to has_been_customized\",\n        includedoc=\"Replaced by :func:`has_been_customized`\",\n        since=\"1.4.0\",\n    )(has_been_customized)\n\n\n##~~ Exceptions\n\n\nclass UserAlreadyExists(Exception):\n    def __init__(self, username):\n        Exception.__init__(self, \"User %s already exists\" % username)\n\n\nclass UnknownUser(Exception):\n    def __init__(self, username):\n        Exception.__init__(self, \"Unknown user: %s\" % username)\n\n\nclass UnknownRole(Exception):\n    def __init__(self, role):\n        Exception.__init__(self, \"Unknown role: %s\" % role)\n\n\nclass CorruptUserStorage(Exception):\n    pass\n\n\n##~~ Refactoring helpers\n\n\nclass MethodReplacedByBooleanProperty:\n    def __init__(self, name, message, getter):\n        self._name = name\n        self._message = message\n        self._getter = getter\n\n    @property\n    def _attr(self):\n        return self._getter()\n\n    def __call__(self):\n        from warnings import warn\n\n        warn(DeprecationWarning(self._message.format(name=self._name)), stacklevel=2)\n        return self._attr\n\n    def __eq__(self, other):\n        return self._attr == other\n\n    def __ne__(self, other):\n        return self._attr != other\n\n    def __bool__(self):\n        # Python 3\n        return self._attr\n\n    def __nonzero__(self):\n        # Python 2\n        return self._attr\n\n    def __hash__(self):\n        return hash(self._attr)\n\n    def __repr__(self):\n        return \"MethodReplacedByProperty({}, {}, {})\".format(\n            self._name, self._message, self._getter\n        )\n\n    def __str__(self):\n        return str(self._attr)\n\n\n# TODO: Remove compatibility layer in OctoPrint 1.5.0\nclass FlaskLoginMethodReplacedByBooleanProperty(MethodReplacedByBooleanProperty):\n    def __init__(self, name, getter):\n        message = (\n            \"{name} is now a property in Flask-Login versions >= 0.3.0, which OctoPrint now uses. \"\n            + \"Use {name} instead of {name}(). This compatibility layer will be removed in OctoPrint 1.5.0.\"\n        )\n        MethodReplacedByBooleanProperty.__init__(self, name, message, getter)\n\n\n# TODO: Remove compatibility layer in OctoPrint 1.5.0\nclass OctoPrintUserMethodReplacedByBooleanProperty(MethodReplacedByBooleanProperty):\n    def __init__(self, name, getter):\n        message = (\n            \"{name} is now a property for consistency reasons with Flask-Login versions >= 0.3.0, which \"\n            + \"OctoPrint now uses. Use {name} instead of {name}(). This compatibility layer will be removed \"\n            + \"in OctoPrint 1.5.0.\"\n        )\n        MethodReplacedByBooleanProperty.__init__(self, name, message, getter)\n\n\n##~~ User object\n\n\nclass User(UserMixin):\n    def __init__(\n        self,\n        username,\n        passwordHash,\n        active,\n        permissions=None,\n        groups=None,\n        apikey=None,\n        settings=None,\n    ):\n        if permissions is None:\n            permissions = []\n        if groups is None:\n            groups = []\n\n        self._username = username\n        self._passwordHash = passwordHash\n        self._active = active\n        self._permissions = permissions\n        self._groups = groups\n        self._apikey = apikey\n\n        if settings is None:\n            settings = {}\n\n        self._settings = settings\n\n    def as_dict(self):\n        from octoprint.access.permissions import OctoPrintPermission\n\n        return {\n            \"name\": self._username,\n            \"active\": bool(self.is_active),\n            \"permissions\": list(map(lambda p: p.key, self._permissions)),\n            \"groups\": list(map(lambda g: g.key, self._groups)),\n            \"needs\": OctoPrintPermission.convert_needs_to_dict(self.needs),\n            \"apikey\": self._apikey,\n            \"settings\": self._settings,\n            # TODO: deprecated, remove in 1.5.0\n            \"admin\": self.has_permission(Permissions.ADMIN),\n            \"user\": not self.is_anonymous,\n            \"roles\": self._roles,\n        }\n\n    def check_password(self, passwordHash):\n        return self._passwordHash == passwordHash\n\n    def get_id(self):\n        return self.get_name()\n\n    def get_name(self):\n        return self._username\n\n    @property\n    def is_anonymous(self):\n        return FlaskLoginMethodReplacedByBooleanProperty(\"is_anonymous\", lambda: False)\n\n    @property\n    def is_authenticated(self):\n        return FlaskLoginMethodReplacedByBooleanProperty(\"is_authenticated\", lambda: True)\n\n    @property\n    def is_active(self):\n        return FlaskLoginMethodReplacedByBooleanProperty(\n            \"is_active\", lambda: self._active\n        )\n\n    def get_all_settings(self):\n        return self._settings\n\n    def get_setting(self, key):\n        if not isinstance(key, (tuple, list)):\n            path = [key]\n        else:\n            path = key\n\n        return self._get_setting(path)\n\n    def set_setting(self, key, value):\n        if not isinstance(key, (tuple, list)):\n            path = [key]\n        else:\n            path = key\n        return self._set_setting(path, value)\n\n    def _get_setting(self, path):\n        s = self._settings\n        for p in path:\n            if isinstance(s, dict) and p in s:\n                s = s[p]\n            else:\n                return None\n        return s\n\n    def _set_setting(self, path, value):\n        s = self._settings\n        for p in path[:-1]:\n            if p not in s:\n                s[p] = {}\n\n            if not isinstance(s[p], dict):\n                s[p] = {}\n\n            s = s[p]\n\n        key = path[-1]\n        s[key] = value\n        return True\n\n    def add_permissions_to_user(self, permissions):\n        # Make sure the permissions variable is of type list\n        if not isinstance(permissions, list):\n            permissions = [permissions]\n\n        assert all(map(lambda p: isinstance(p, OctoPrintPermission), permissions))\n\n        dirty = False\n        for permission in permissions:\n            if permissions not in self._permissions:\n                self._permissions.append(permission)\n                dirty = True\n\n        return dirty\n\n    def remove_permissions_from_user(self, permissions):\n        # Make sure the permissions variable is of type list\n        if not isinstance(permissions, list):\n            permissions = [permissions]\n\n        assert all(map(lambda p: isinstance(p, OctoPrintPermission), permissions))\n\n        dirty = False\n        for permission in permissions:\n            if permission in self._permissions:\n                self._permissions.remove(permission)\n                dirty = True\n\n        return dirty\n\n    def add_groups_to_user(self, groups):\n        # Make sure the groups variable is of type list\n        if not isinstance(groups, list):\n            groups = [groups]\n\n        assert all(map(lambda p: isinstance(p, Group), groups))\n\n        dirty = False\n        for group in groups:\n            if group.is_toggleable() and group not in self._groups:\n                self._groups.append(group)\n                dirty = True\n\n        return dirty\n\n    def remove_groups_from_user(self, groups):\n        # Make sure the groups variable is of type list\n        if not isinstance(groups, list):\n            groups = [groups]\n\n        assert all(map(lambda p: isinstance(p, Group), groups))\n\n        dirty = False\n        for group in groups:\n            if group.is_toggleable() and group in self._groups:\n                self._groups.remove(group)\n                dirty = True\n\n        return dirty\n\n    @property\n    def permissions(self):\n        if self._permissions is None:\n            return []\n\n        if Permissions.ADMIN in self._permissions:\n            return Permissions.all()\n\n        return list(filter(lambda p: p is not None, self._permissions))\n\n    @property\n    def groups(self):\n        return list(self._groups)\n\n    @property\n    def effective_permissions(self):\n        if self._permissions is None:\n            return []\n        return list(\n            filter(lambda p: p is not None and self.has_permission(p), Permissions.all())\n        )\n\n    @property\n    def needs(self):\n        needs = set()\n\n        for permission in self.permissions:\n            if permission is not None:\n                needs = needs.union(permission.needs)\n\n        for group in self.groups:\n            if group is not None:\n                needs = needs.union(group.needs)\n\n        return needs\n\n    def has_permission(self, permission):\n        return self.has_needs(*permission.needs)\n\n    def has_needs(self, *needs):\n        return set(needs).issubset(self.needs)\n\n    def __repr__(self):\n        return (\n            \"User(id=%s,name=%s,active=%r,user=True,admin=%r,permissions=%s,groups=%s)\"\n            % (\n                self.get_id(),\n                self.get_name(),\n                bool(self.is_active),\n                self.has_permission(Permissions.ADMIN),\n                self._permissions,\n                self._groups,\n            )\n        )\n\n    # ~~ Deprecated methods & properties follow\n\n    # TODO: Remove deprecated methods & properties in OctoPrint 1.5.0\n\n    asDict = deprecated(\n        \"asDict has been renamed to as_dict\",\n        includedoc=\"Replaced by :func:`as_dict`\",\n        since=\"1.4.0\",\n    )(as_dict)\n\n    @property\n    @deprecated(\"is_user is deprecated, please use has_permission\", since=\"1.4.0\")\n    def is_user(self):\n        return OctoPrintUserMethodReplacedByBooleanProperty(\n            \"is_user\", lambda: not self.is_anonymous\n        )\n\n    @property\n    @deprecated(\"is_admin is deprecated, please use has_permission\", since=\"1.4.0\")\n    def is_admin(self):\n        return OctoPrintUserMethodReplacedByBooleanProperty(\n            \"is_admin\", lambda: self.has_permission(Permissions.ADMIN)\n        )\n\n    @property\n    @deprecated(\"roles is deprecated, please use has_permission\", since=\"1.4.0\")\n    def roles(self):\n        return self._roles\n\n    @property\n    def _roles(self):\n        \"\"\"Helper for the deprecated self.roles and serializing to yaml\"\"\"\n        if self.has_permission(Permissions.ADMIN):\n            return [\"user\", \"admin\"]\n        elif not self.is_anonymous:\n            return [\"user\"]\n        else:\n            return []\n\n\nclass AnonymousUser(AnonymousUserMixin, User):\n    def __init__(self, groups):\n        User.__init__(self, None, \"\", True, [], groups)\n\n    @property\n    def is_anonymous(self):\n        return FlaskLoginMethodReplacedByBooleanProperty(\"is_anonymous\", lambda: True)\n\n    @property\n    def is_authenticated(self):\n        return FlaskLoginMethodReplacedByBooleanProperty(\n            \"is_authenticated\", lambda: False\n        )\n\n    @property\n    def is_active(self):\n        return FlaskLoginMethodReplacedByBooleanProperty(\n            \"is_active\", lambda: self._active\n        )\n\n    def check_password(self, passwordHash):\n        return True\n\n    def as_dict(self):\n        from octoprint.access.permissions import OctoPrintPermission\n\n        return {\"needs\": OctoPrintPermission.convert_needs_to_dict(self.needs)}\n\n    def __repr__(self):\n        return \"AnonymousUser(groups=%s)\" % self._groups\n\n\nclass SessionUser(wrapt.ObjectProxy):\n    def __init__(self, user):\n        wrapt.ObjectProxy.__init__(self, user)\n\n        self._self_session = \"\".join(\"%02X\" % z for z in bytes(uuid.uuid4().bytes))\n        self._self_created = time.monotonic()\n        self._self_touched = time.monotonic()\n\n    @property\n    def session(self):\n        return self._self_session\n\n    @property\n    def created(self):\n        return self._self_created\n\n    @property\n    def touched(self):\n        return self._self_touched\n\n    def touch(self):\n        self._self_touched = time.monotonic()\n\n    @deprecated(\n        \"SessionUser.get_session() has been deprecated, use SessionUser.session instead\",\n        since=\"1.3.5\",\n    )\n    def get_session(self):\n        return self.session\n\n    def update_user(self, user):\n        self.__wrapped__ = user\n\n    def as_dict(self):\n        result = self.__wrapped__.as_dict()\n        result.update({\"session\": self.session})\n        return result\n\n    def __repr__(self):\n        return \"SessionUser({!r},session={},created={})\".format(\n            self.__wrapped__, self.session, self.created\n        )\n\n\n##~~ User object to use when global api key is used to access the API\n\n\nclass ApiUser(User):\n    def __init__(self, groups):\n        User.__init__(self, \"_api\", \"\", True, [], groups)\n", "__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"\n__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"\n__copyright__ = \"Copyright (C) 2014 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n\nimport atexit\nimport base64\nimport functools\nimport logging\nimport logging.config\nimport mimetypes\nimport os\nimport re\nimport signal\nimport sys\nimport time\nimport uuid  # noqa: F401\nfrom collections import OrderedDict, defaultdict\n\nfrom babel import Locale\nfrom flask import (  # noqa: F401\n    Blueprint,\n    Flask,\n    Request,\n    Response,\n    current_app,\n    g,\n    make_response,\n    request,\n    session,\n)\nfrom flask_assets import Bundle, Environment\nfrom flask_babel import Babel, gettext, ngettext  # noqa: F401\nfrom flask_login import (  # noqa: F401\n    LoginManager,\n    current_user,\n    session_protected,\n    user_logged_out,\n)\nfrom watchdog.observers import Observer\nfrom watchdog.observers.polling import PollingObserver\nfrom werkzeug.exceptions import HTTPException\n\nimport octoprint.filemanager\nimport octoprint.util\nimport octoprint.util.net\nfrom octoprint.server import util\nfrom octoprint.systemcommands import system_command_manager\nfrom octoprint.util.json import JsonEncoding\nfrom octoprint.vendor.flask_principal import (  # noqa: F401\n    AnonymousIdentity,\n    Identity,\n    Permission,\n    Principal,\n    RoleNeed,\n    UserNeed,\n    identity_changed,\n    identity_loaded,\n)\nfrom octoprint.vendor.sockjs.tornado import SockJSRouter\n\ntry:\n    import fcntl\nexcept ImportError:\n    fcntl = None\n\nSUCCESS = {}\nNO_CONTENT = (\"\", 204, {\"Content-Type\": \"text/plain\"})\nNOT_MODIFIED = (\"Not Modified\", 304, {\"Content-Type\": \"text/plain\"})\n\napp = Flask(\"octoprint\")\n\nassets = None\nbabel = None\nlimiter = None\ndebug = False\nsafe_mode = False\n\nprinter = None\nprinterProfileManager = None\nfileManager = None\nslicingManager = None\nanalysisQueue = None\nuserManager = None\npermissionManager = None\ngroupManager = None\neventManager = None\nloginManager = None\npluginManager = None\npluginLifecycleManager = None\npreemptiveCache = None\njsonEncoder = None\njsonDecoder = None\nconnectivityChecker = None\nenvironmentDetector = None\n\nprincipals = Principal(app)\n\nimport octoprint.access.groups as groups  # noqa: E402\nimport octoprint.access.permissions as permissions  # noqa: E402\n\n# we set admin_permission to a GroupPermission with the default admin group\nadmin_permission = octoprint.util.variable_deprecated(\n    \"admin_permission has been deprecated, \" \"please use individual Permissions instead\",\n    since=\"1.4.0\",\n)(groups.GroupPermission(groups.ADMIN_GROUP))\n\n# we set user_permission to a GroupPermission with the default user group\nuser_permission = octoprint.util.variable_deprecated(\n    \"user_permission has been deprecated, \" \"please use individual Permissions instead\",\n    since=\"1.4.0\",\n)(groups.GroupPermission(groups.USER_GROUP))\n\nimport octoprint._version  # noqa: E402\nimport octoprint.access.groups as groups  # noqa: E402\nimport octoprint.access.users as users  # noqa: E402\nimport octoprint.events as events  # noqa: E402\nimport octoprint.filemanager.analysis  # noqa: E402\nimport octoprint.filemanager.storage  # noqa: E402\nimport octoprint.plugin  # noqa: E402\nimport octoprint.slicing  # noqa: E402\nimport octoprint.timelapse  # noqa: E402\n\n# only import further octoprint stuff down here, as it might depend on things defined above to be initialized already\nfrom octoprint import __branch__, __display_version__, __revision__, __version__\nfrom octoprint.printer.profile import PrinterProfileManager\nfrom octoprint.printer.standard import Printer\nfrom octoprint.server.util import (\n    corsRequestHandler,\n    corsResponseHandler,\n    loginFromApiKeyRequestHandler,\n    requireLoginRequestHandler,\n)\nfrom octoprint.server.util.flask import PreemptiveCache\nfrom octoprint.settings import settings\n\nVERSION = __version__\nBRANCH = __branch__\nDISPLAY_VERSION = __display_version__\nREVISION = __revision__\n\nLOCALES = []\nLANGUAGES = set()\n\n\n@identity_loaded.connect_via(app)\ndef on_identity_loaded(sender, identity):\n    user = load_user(identity.id)\n    if user is None:\n        user = userManager.anonymous_user_factory()\n\n    identity.provides.add(UserNeed(user.get_id()))\n    for need in user.needs:\n        identity.provides.add(need)\n\n\ndef _clear_identity(sender):\n    # Remove session keys set by Flask-Principal\n    for key in (\"identity.id\", \"identity.name\", \"identity.auth_type\"):\n        session.pop(key, None)\n\n    # switch to anonymous identity\n    identity_changed.send(sender, identity=AnonymousIdentity())\n\n\n@session_protected.connect_via(app)\ndef on_session_protected(sender):\n    # session was deleted by session protection, that means the user is no more and we need to clear our identity\n    if session.get(\"remember\", None) == \"clear\":\n        _clear_identity(sender)\n\n\n@user_logged_out.connect_via(app)\ndef on_user_logged_out(sender, user=None):\n    # user was logged out, clear identity\n    _clear_identity(sender)\n\n\ndef load_user(id):\n    if id is None:\n        return None\n\n    if id == \"_api\":\n        return userManager.api_user_factory()\n\n    if session and \"usersession.id\" in session:\n        sessionid = session[\"usersession.id\"]\n    else:\n        sessionid = None\n\n    if sessionid:\n        user = userManager.find_user(userid=id, session=sessionid)\n    else:\n        user = userManager.find_user(userid=id)\n\n    if user and user.is_active:\n        return user\n\n    return None\n\n\ndef load_user_from_request(request):\n    user = None\n\n    if settings().getBoolean([\"accessControl\", \"trustBasicAuthentication\"]):\n        # Basic Authentication?\n        user = util.get_user_for_authorization_header(\n            request.headers.get(\"Authorization\")\n        )\n\n    if settings().getBoolean([\"accessControl\", \"trustRemoteUser\"]):\n        # Remote user header?\n        user = util.get_user_for_remote_user_header(request)\n\n    return user\n\n\ndef unauthorized_user():\n    from flask import abort\n\n    abort(403)\n\n\n# ~~ startup code\n\n\nclass Server:\n    def __init__(\n        self,\n        settings=None,\n        plugin_manager=None,\n        connectivity_checker=None,\n        environment_detector=None,\n        event_manager=None,\n        host=None,\n        port=None,\n        v6_only=False,\n        debug=False,\n        safe_mode=False,\n        allow_root=False,\n        octoprint_daemon=None,\n    ):\n        self._settings = settings\n        self._plugin_manager = plugin_manager\n        self._connectivity_checker = connectivity_checker\n        self._environment_detector = environment_detector\n        self._event_manager = event_manager\n        self._host = host\n        self._port = port\n        self._v6_only = v6_only\n        self._debug = debug\n        self._safe_mode = safe_mode\n        self._allow_root = allow_root\n        self._octoprint_daemon = octoprint_daemon\n        self._server = None\n\n        self._logger = None\n\n        self._lifecycle_callbacks = defaultdict(list)\n\n        self._intermediary_server = None\n\n    def run(self):\n        if not self._allow_root:\n            self._check_for_root()\n\n        if self._settings is None:\n            self._settings = settings()\n\n        if not self._settings.getBoolean([\"server\", \"ignoreIncompleteStartup\"]):\n            self._settings.setBoolean([\"server\", \"incompleteStartup\"], True)\n            self._settings.save()\n\n        if self._plugin_manager is None:\n            self._plugin_manager = octoprint.plugin.plugin_manager()\n\n        global app\n        global babel\n\n        global printer\n        global printerProfileManager\n        global fileManager\n        global slicingManager\n        global analysisQueue\n        global userManager\n        global permissionManager\n        global groupManager\n        global eventManager\n        global loginManager\n        global pluginManager\n        global pluginLifecycleManager\n        global preemptiveCache\n        global jsonEncoder\n        global jsonDecoder\n        global connectivityChecker\n        global environmentDetector\n        global debug\n        global safe_mode\n\n        from tornado.ioloop import IOLoop\n        from tornado.web import Application\n\n        debug = self._debug\n        safe_mode = self._safe_mode\n\n        if safe_mode:\n            self._log_safe_mode_start(safe_mode)\n\n        if self._v6_only and not octoprint.util.net.HAS_V6:\n            raise RuntimeError(\n                \"IPv6 only mode configured but system doesn't support IPv6\"\n            )\n\n        if self._host is None:\n            host = self._settings.get([\"server\", \"host\"])\n            if host is None:\n                if octoprint.util.net.HAS_V6:\n                    host = \"::\"\n                else:\n                    host = \"0.0.0.0\"\n\n            self._host = host\n\n        if \":\" in self._host and not octoprint.util.net.HAS_V6:\n            raise RuntimeError(\n                \"IPv6 host address {!r} configured but system doesn't support IPv6\".format(\n                    self._host\n                )\n            )\n\n        if self._port is None:\n            self._port = self._settings.getInt([\"server\", \"port\"])\n            if self._port is None:\n                self._port = 5000\n\n        self._logger = logging.getLogger(__name__)\n        self._setup_heartbeat_logging()\n        pluginManager = self._plugin_manager\n\n        # monkey patch/fix some stuff\n        util.tornado.fix_json_encode()\n        util.tornado.fix_websocket_check_origin()\n        util.tornado.enable_per_message_deflate_extension()\n        util.flask.fix_flask_jsonify()\n\n        self._setup_mimetypes()\n\n        additional_translation_folders = []\n        if not safe_mode:\n            additional_translation_folders += [\n                self._settings.getBaseFolder(\"translations\")\n            ]\n        util.flask.enable_additional_translations(\n            additional_folders=additional_translation_folders\n        )\n\n        # setup app\n        self._setup_app(app)\n\n        # setup i18n\n        self._setup_i18n(app)\n\n        if self._settings.getBoolean([\"serial\", \"log\"]):\n            # enable debug logging to serial.log\n            logging.getLogger(\"SERIAL\").setLevel(logging.DEBUG)\n\n        if self._settings.getBoolean([\"devel\", \"pluginTimings\"]):\n            # enable plugin timings log\n            logging.getLogger(\"PLUGIN_TIMINGS\").setLevel(logging.DEBUG)\n\n        # start the intermediary server\n        self._start_intermediary_server()\n\n        ### IMPORTANT!\n        ###\n        ### Best do not start any subprocesses until the intermediary server shuts down again or they MIGHT inherit the\n        ### open port and prevent us from firing up Tornado later.\n        ###\n        ### The intermediary server's socket should have the CLOSE_EXEC flag (or its equivalent) set where possible, but\n        ### we can only do that if fcntl is available or we are on Windows, so better safe than sorry.\n        ###\n        ### See also issues #2035 and #2090\n\n        systemCommandManager = system_command_manager()\n        printerProfileManager = PrinterProfileManager()\n        eventManager = self._event_manager\n\n        analysis_queue_factories = {\n            \"gcode\": octoprint.filemanager.analysis.GcodeAnalysisQueue\n        }\n        analysis_queue_hooks = pluginManager.get_hooks(\n            \"octoprint.filemanager.analysis.factory\"\n        )\n        for name, hook in analysis_queue_hooks.items():\n            try:\n                additional_factories = hook()\n                analysis_queue_factories.update(**additional_factories)\n            except Exception:\n                self._logger.exception(\n                    f\"Error while processing analysis queues from {name}\",\n                    extra={\"plugin\": name},\n                )\n        analysisQueue = octoprint.filemanager.analysis.AnalysisQueue(\n            analysis_queue_factories\n        )\n\n        slicingManager = octoprint.slicing.SlicingManager(\n            self._settings.getBaseFolder(\"slicingProfiles\"), printerProfileManager\n        )\n\n        storage_managers = {}\n        storage_managers[\n            octoprint.filemanager.FileDestinations.LOCAL\n        ] = octoprint.filemanager.storage.LocalFileStorage(\n            self._settings.getBaseFolder(\"uploads\"),\n            really_universal=self._settings.getBoolean(\n                [\"feature\", \"enforceReallyUniversalFilenames\"]\n            ),\n        )\n\n        fileManager = octoprint.filemanager.FileManager(\n            analysisQueue,\n            slicingManager,\n            printerProfileManager,\n            initial_storage_managers=storage_managers,\n        )\n        pluginLifecycleManager = LifecycleManager(pluginManager)\n        preemptiveCache = PreemptiveCache(\n            os.path.join(\n                self._settings.getBaseFolder(\"data\"), \"preemptive_cache_config.yaml\"\n            )\n        )\n\n        JsonEncoding.add_encoder(users.User, lambda obj: obj.as_dict())\n        JsonEncoding.add_encoder(groups.Group, lambda obj: obj.as_dict())\n        JsonEncoding.add_encoder(\n            permissions.OctoPrintPermission, lambda obj: obj.as_dict()\n        )\n\n        # start regular check if we are connected to the internet\n        def on_connectivity_change(old_value, new_value):\n            eventManager.fire(\n                events.Events.CONNECTIVITY_CHANGED,\n                payload={\"old\": old_value, \"new\": new_value},\n            )\n\n        connectivityChecker = self._connectivity_checker\n        environmentDetector = self._environment_detector\n\n        def on_settings_update(*args, **kwargs):\n            # make sure our connectivity checker runs with the latest settings\n            connectivityEnabled = self._settings.getBoolean(\n                [\"server\", \"onlineCheck\", \"enabled\"]\n            )\n            connectivityInterval = self._settings.getInt(\n                [\"server\", \"onlineCheck\", \"interval\"]\n            )\n            connectivityHost = self._settings.get([\"server\", \"onlineCheck\", \"host\"])\n            connectivityPort = self._settings.getInt([\"server\", \"onlineCheck\", \"port\"])\n            connectivityName = self._settings.get([\"server\", \"onlineCheck\", \"name\"])\n\n            if (\n                connectivityChecker.enabled != connectivityEnabled\n                or connectivityChecker.interval != connectivityInterval\n                or connectivityChecker.host != connectivityHost\n                or connectivityChecker.port != connectivityPort\n                or connectivityChecker.name != connectivityName\n            ):\n                connectivityChecker.enabled = connectivityEnabled\n                connectivityChecker.interval = connectivityInterval\n                connectivityChecker.host = connectivityHost\n                connectivityChecker.port = connectivityPort\n                connectivityChecker.name = connectivityName\n                connectivityChecker.check_immediately()\n\n        eventManager.subscribe(events.Events.SETTINGS_UPDATED, on_settings_update)\n\n        components = {\n            \"plugin_manager\": pluginManager,\n            \"printer_profile_manager\": printerProfileManager,\n            \"event_bus\": eventManager,\n            \"analysis_queue\": analysisQueue,\n            \"slicing_manager\": slicingManager,\n            \"file_manager\": fileManager,\n            \"plugin_lifecycle_manager\": pluginLifecycleManager,\n            \"preemptive_cache\": preemptiveCache,\n            \"json_encoder\": jsonEncoder,\n            \"json_decoder\": jsonDecoder,\n            \"connectivity_checker\": connectivityChecker,\n            \"environment_detector\": self._environment_detector,\n            \"system_commands\": systemCommandManager,\n        }\n\n        # ~~ setup access control\n\n        # get additional permissions from plugins\n        self._setup_plugin_permissions()\n\n        # create group manager instance\n        group_manager_factories = pluginManager.get_hooks(\n            \"octoprint.access.groups.factory\"\n        )\n        for name, factory in group_manager_factories.items():\n            try:\n                groupManager = factory(components, self._settings)\n                if groupManager is not None:\n                    self._logger.debug(\n                        f\"Created group manager instance from factory {name}\"\n                    )\n                    break\n            except Exception:\n                self._logger.exception(\n                    \"Error while creating group manager instance from factory {}\".format(\n                        name\n                    )\n                )\n        else:\n            group_manager_name = self._settings.get([\"accessControl\", \"groupManager\"])\n            try:\n                clazz = octoprint.util.get_class(group_manager_name)\n                groupManager = clazz()\n            except AttributeError:\n                self._logger.exception(\n                    \"Could not instantiate group manager {}, \"\n                    \"falling back to FilebasedGroupManager!\".format(group_manager_name)\n                )\n                groupManager = octoprint.access.groups.FilebasedGroupManager()\n        components.update({\"group_manager\": groupManager})\n\n        # create user manager instance\n        user_manager_factories = pluginManager.get_hooks(\n            \"octoprint.users.factory\"\n        )  # legacy, set first so that new wins\n        user_manager_factories.update(\n            pluginManager.get_hooks(\"octoprint.access.users.factory\")\n        )\n        for name, factory in user_manager_factories.items():\n            try:\n                userManager = factory(components, self._settings)\n                if userManager is not None:\n                    self._logger.debug(\n                        f\"Created user manager instance from factory {name}\"\n                    )\n                    break\n            except Exception:\n                self._logger.exception(\n                    \"Error while creating user manager instance from factory {}\".format(\n                        name\n                    ),\n                    extra={\"plugin\": name},\n                )\n        else:\n            user_manager_name = self._settings.get([\"accessControl\", \"userManager\"])\n            try:\n                clazz = octoprint.util.get_class(user_manager_name)\n                userManager = clazz(groupManager)\n            except octoprint.access.users.CorruptUserStorage:\n                raise\n            except Exception:\n                self._logger.exception(\n                    \"Could not instantiate user manager {}, \"\n                    \"falling back to FilebasedUserManager!\".format(user_manager_name)\n                )\n                userManager = octoprint.access.users.FilebasedUserManager(groupManager)\n        components.update({\"user_manager\": userManager})\n\n        # create printer instance\n        printer_factories = pluginManager.get_hooks(\"octoprint.printer.factory\")\n        for name, factory in printer_factories.items():\n            try:\n                printer = factory(components)\n                if printer is not None:\n                    self._logger.debug(f\"Created printer instance from factory {name}\")\n                    break\n            except Exception:\n                self._logger.exception(\n                    f\"Error while creating printer instance from factory {name}\",\n                    extra={\"plugin\": name},\n                )\n        else:\n            printer = Printer(fileManager, analysisQueue, printerProfileManager)\n        components.update({\"printer\": printer})\n\n        from octoprint import (\n            init_custom_events,\n            init_settings_plugin_config_migration_and_cleanup,\n        )\n        from octoprint import octoprint_plugin_inject_factory as opif\n        from octoprint import settings_plugin_inject_factory as spif\n\n        init_custom_events(pluginManager)\n\n        octoprint_plugin_inject_factory = opif(self._settings, components)\n        settings_plugin_inject_factory = spif(self._settings)\n\n        pluginManager.implementation_inject_factories = [\n            octoprint_plugin_inject_factory,\n            settings_plugin_inject_factory,\n        ]\n        pluginManager.initialize_implementations()\n\n        init_settings_plugin_config_migration_and_cleanup(pluginManager)\n\n        pluginManager.log_all_plugins()\n\n        # log environment data now\n        self._environment_detector.log_detected_environment()\n\n        # initialize file manager and register it for changes in the registered plugins\n        fileManager.initialize()\n        pluginLifecycleManager.add_callback(\n            [\"enabled\", \"disabled\"], lambda name, plugin: fileManager.reload_plugins()\n        )\n\n        # initialize slicing manager and register it for changes in the registered plugins\n        slicingManager.initialize()\n        pluginLifecycleManager.add_callback(\n            [\"enabled\", \"disabled\"], lambda name, plugin: slicingManager.reload_slicers()\n        )\n\n        # setup jinja2\n        self._setup_jinja2()\n\n        # setup assets\n        self._setup_assets()\n\n        # configure timelapse\n        octoprint.timelapse.valid_timelapse(\"test\")\n        octoprint.timelapse.configure_timelapse()\n\n        # setup command triggers\n        events.CommandTrigger(printer)\n        if self._debug:\n            events.DebugEventListener()\n\n        # setup login manager\n        self._setup_login_manager()\n\n        # register API blueprint\n        self._setup_blueprints()\n\n        ## Tornado initialization starts here\n\n        ioloop = IOLoop()\n        ioloop.install()\n\n        enable_cors = settings().getBoolean([\"api\", \"allowCrossOrigin\"])\n\n        self._router = SockJSRouter(\n            self._create_socket_connection,\n            \"/sockjs\",\n            session_kls=util.sockjs.ThreadSafeSession,\n            user_settings={\n                \"websocket_allow_origin\": \"*\" if enable_cors else \"\",\n                \"jsessionid\": False,\n                \"sockjs_url\": \"../../static/js/lib/sockjs.min.js\",\n            },\n        )\n\n        upload_suffixes = {\n            \"name\": self._settings.get([\"server\", \"uploads\", \"nameSuffix\"]),\n            \"path\": self._settings.get([\"server\", \"uploads\", \"pathSuffix\"]),\n        }\n\n        def mime_type_guesser(path):\n            from octoprint.filemanager import get_mime_type\n\n            return get_mime_type(path)\n\n        def download_name_generator(path):\n            metadata = fileManager.get_metadata(\"local\", path)\n            if metadata and \"display\" in metadata:\n                return metadata[\"display\"]\n\n        download_handler_kwargs = {\"as_attachment\": True, \"allow_client_caching\": False}\n\n        additional_mime_types = {\"mime_type_guesser\": mime_type_guesser}\n\n        ##~~ Permission validators\n\n        access_validators_from_plugins = []\n        for plugin, hook in pluginManager.get_hooks(\n            \"octoprint.server.http.access_validator\"\n        ).items():\n            try:\n                access_validators_from_plugins.append(\n                    util.tornado.access_validation_factory(app, hook)\n                )\n            except Exception:\n                self._logger.exception(\n                    \"Error while adding tornado access validator from plugin {}\".format(\n                        plugin\n                    ),\n                    extra={\"plugin\": plugin},\n                )\n\n        timelapse_validators = [\n            util.tornado.access_validation_factory(\n                app,\n                util.flask.permission_validator,\n                permissions.Permissions.TIMELAPSE_LIST,\n            ),\n        ] + access_validators_from_plugins\n        download_validators = [\n            util.tornado.access_validation_factory(\n                app,\n                util.flask.permission_validator,\n                permissions.Permissions.FILES_DOWNLOAD,\n            ),\n        ] + access_validators_from_plugins\n        log_validators = [\n            util.tornado.access_validation_factory(\n                app,\n                util.flask.permission_validator,\n                permissions.Permissions.PLUGIN_LOGGING_MANAGE,\n            ),\n        ] + access_validators_from_plugins\n        camera_validators = [\n            util.tornado.access_validation_factory(\n                app, util.flask.permission_validator, permissions.Permissions.WEBCAM\n            ),\n        ] + access_validators_from_plugins\n        systeminfo_validators = [\n            util.tornado.access_validation_factory(\n                app, util.flask.permission_validator, permissions.Permissions.SYSTEM\n            )\n        ] + access_validators_from_plugins\n\n        timelapse_permission_validator = {\n            \"access_validation\": util.tornado.validation_chain(*timelapse_validators)\n        }\n        download_permission_validator = {\n            \"access_validation\": util.tornado.validation_chain(*download_validators)\n        }\n        log_permission_validator = {\n            \"access_validation\": util.tornado.validation_chain(*log_validators)\n        }\n        camera_permission_validator = {\n            \"access_validation\": util.tornado.validation_chain(*camera_validators)\n        }\n        systeminfo_permission_validator = {\n            \"access_validation\": util.tornado.validation_chain(*systeminfo_validators)\n        }\n\n        no_hidden_files_validator = {\n            \"path_validation\": util.tornado.path_validation_factory(\n                lambda path: not octoprint.util.is_hidden_path(path), status_code=404\n            )\n        }\n\n        only_known_types_validator = {\n            \"path_validation\": util.tornado.path_validation_factory(\n                lambda path: octoprint.filemanager.valid_file_type(\n                    os.path.basename(path)\n                ),\n                status_code=404,\n            )\n        }\n\n        valid_timelapse = lambda path: not octoprint.util.is_hidden_path(path) and (\n            octoprint.timelapse.valid_timelapse(path)\n            or octoprint.timelapse.valid_timelapse_thumbnail(path)\n        )\n        timelapse_path_validator = {\n            \"path_validation\": util.tornado.path_validation_factory(\n                valid_timelapse,\n                status_code=404,\n            )\n        }\n        timelapses_path_validator = {\n            \"path_validation\": util.tornado.path_validation_factory(\n                lambda path: valid_timelapse(path)\n                and os.path.realpath(os.path.abspath(path)).startswith(\n                    settings().getBaseFolder(\"timelapse\")\n                ),\n                status_code=400,\n            )\n        }\n\n        valid_log = lambda path: not octoprint.util.is_hidden_path(\n            path\n        ) and path.endswith(\".log\")\n        log_path_validator = {\n            \"path_validation\": util.tornado.path_validation_factory(\n                valid_log,\n                status_code=404,\n            )\n        }\n        logs_path_validator = {\n            \"path_validation\": util.tornado.path_validation_factory(\n                lambda path: valid_log(path)\n                and os.path.realpath(os.path.abspath(path)).startswith(\n                    settings().getBaseFolder(\"logs\")\n                ),\n                status_code=400,\n            )\n        }\n\n        def joined_dict(*dicts):\n            if not len(dicts):\n                return {}\n\n            joined = {}\n            for d in dicts:\n                joined.update(d)\n            return joined\n\n        util.tornado.RequestlessExceptionLoggingMixin.LOG_REQUEST = debug\n        util.tornado.CorsSupportMixin.ENABLE_CORS = enable_cors\n\n        server_routes = self._router.urls + [\n            # various downloads\n            # .mpg and .mp4 timelapses:\n            (\n                r\"/downloads/timelapse/(.*)\",\n                util.tornado.LargeResponseHandler,\n                joined_dict(\n                    {\"path\": self._settings.getBaseFolder(\"timelapse\")},\n                    timelapse_permission_validator,\n                    download_handler_kwargs,\n                    timelapse_path_validator,\n                ),\n            ),\n            # zipped timelapse bundles\n            (\n                r\"/downloads/timelapses\",\n                util.tornado.DynamicZipBundleHandler,\n                joined_dict(\n                    {\n                        \"as_attachment\": True,\n                        \"attachment_name\": \"octoprint-timelapses.zip\",\n                        \"path_processor\": lambda x: (\n                            x,\n                            os.path.join(self._settings.getBaseFolder(\"timelapse\"), x),\n                        ),\n                    },\n                    timelapse_permission_validator,\n                    timelapses_path_validator,\n                ),\n            ),\n            # uploaded printables\n            (\n                r\"/downloads/files/local/(.*)\",\n                util.tornado.LargeResponseHandler,\n                joined_dict(\n                    {\n                        \"path\": self._settings.getBaseFolder(\"uploads\"),\n                        \"as_attachment\": True,\n                        \"name_generator\": download_name_generator,\n                    },\n                    download_permission_validator,\n                    download_handler_kwargs,\n                    no_hidden_files_validator,\n                    only_known_types_validator,\n                    additional_mime_types,\n                ),\n            ),\n            # log files\n            (\n                r\"/downloads/logs/([^/]*)\",\n                util.tornado.LargeResponseHandler,\n                joined_dict(\n                    {\n                        \"path\": self._settings.getBaseFolder(\"logs\"),\n                        \"mime_type_guesser\": lambda *args, **kwargs: \"text/plain\",\n                        \"stream_body\": True,\n                    },\n                    download_handler_kwargs,\n                    log_permission_validator,\n                    log_path_validator,\n                ),\n            ),\n            # zipped log file bundles\n            (\n                r\"/downloads/logs\",\n                util.tornado.DynamicZipBundleHandler,\n                joined_dict(\n                    {\n                        \"as_attachment\": True,\n                        \"attachment_name\": \"octoprint-logs.zip\",\n                        \"path_processor\": lambda x: (\n                            x,\n                            os.path.join(self._settings.getBaseFolder(\"logs\"), x),\n                        ),\n                    },\n                    log_permission_validator,\n                    logs_path_validator,\n                ),\n            ),\n            # system info bundle\n            (\n                r\"/downloads/systeminfo.zip\",\n                util.tornado.SystemInfoBundleHandler,\n                systeminfo_permission_validator,\n            ),\n            # camera snapshot\n            (\n                r\"/downloads/camera/current\",\n                util.tornado.UrlProxyHandler,\n                joined_dict(\n                    {\n                        \"url\": self._settings.get([\"webcam\", \"snapshot\"]),\n                        \"as_attachment\": True,\n                    },\n                    camera_permission_validator,\n                ),\n            ),\n            # generated webassets\n            (\n                r\"/static/webassets/(.*)\",\n                util.tornado.LargeResponseHandler,\n                {\n                    \"path\": os.path.join(\n                        self._settings.getBaseFolder(\"generated\"), \"webassets\"\n                    ),\n                    \"is_pre_compressed\": True,\n                },\n            ),\n            # online indicators - text file with \"online\" as content and a transparent gif\n            (r\"/online.txt\", util.tornado.StaticDataHandler, {\"data\": \"online\\n\"}),\n            (\n                r\"/online.gif\",\n                util.tornado.StaticDataHandler,\n                {\n                    \"data\": bytes(\n                        base64.b64decode(\n                            \"R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"\n                        )\n                    ),\n                    \"content_type\": \"image/gif\",\n                },\n            ),\n            # deprecated endpoints\n            (\n                r\"/api/logs\",\n                util.tornado.DeprecatedEndpointHandler,\n                {\"url\": \"/plugin/logging/logs\"},\n            ),\n            (\n                r\"/api/logs/(.*)\",\n                util.tornado.DeprecatedEndpointHandler,\n                {\"url\": \"/plugin/logging/logs/{0}\"},\n            ),\n        ]\n\n        # fetch additional routes from plugins\n        for name, hook in pluginManager.get_hooks(\"octoprint.server.http.routes\").items():\n            try:\n                result = hook(list(server_routes))\n            except Exception:\n                self._logger.exception(\n                    f\"There was an error while retrieving additional \"\n                    f\"server routes from plugin hook {name}\",\n                    extra={\"plugin\": name},\n                )\n            else:\n                if isinstance(result, (list, tuple)):\n                    for entry in result:\n                        if not isinstance(entry, tuple) or not len(entry) == 3:\n                            continue\n                        if not isinstance(entry[0], str):\n                            continue\n                        if not isinstance(entry[2], dict):\n                            continue\n\n                        route, handler, kwargs = entry\n                        route = r\"/plugin/{name}/{route}\".format(\n                            name=name,\n                            route=route if not route.startswith(\"/\") else route[1:],\n                        )\n\n                        self._logger.debug(\n                            f\"Adding additional route {route} handled by handler {handler} and with additional arguments {kwargs!r}\"\n                        )\n                        server_routes.append((route, handler, kwargs))\n\n        headers = {\n            \"X-Robots-Tag\": \"noindex, nofollow, noimageindex\",\n            \"X-Content-Type-Options\": \"nosniff\",\n        }\n        if not settings().getBoolean([\"server\", \"allowFraming\"]):\n            headers[\"X-Frame-Options\"] = \"sameorigin\"\n\n        removed_headers = [\"Server\"]\n\n        server_routes.append(\n            (\n                r\".*\",\n                util.tornado.UploadStorageFallbackHandler,\n                {\n                    \"fallback\": util.tornado.WsgiInputContainer(\n                        app.wsgi_app, headers=headers, removed_headers=removed_headers\n                    ),\n                    \"file_prefix\": \"octoprint-file-upload-\",\n                    \"file_suffix\": \".tmp\",\n                    \"suffixes\": upload_suffixes,\n                },\n            )\n        )\n\n        transforms = [\n            util.tornado.GlobalHeaderTransform.for_headers(\n                \"OctoPrintGlobalHeaderTransform\",\n                headers=headers,\n                removed_headers=removed_headers,\n            )\n        ]\n\n        self._tornado_app = Application(handlers=server_routes, transforms=transforms)\n        max_body_sizes = [\n            (\n                \"POST\",\n                r\"/api/files/([^/]*)\",\n                self._settings.getInt([\"server\", \"uploads\", \"maxSize\"]),\n            ),\n            (\"POST\", r\"/api/languages\", 5 * 1024 * 1024),\n        ]\n\n        # allow plugins to extend allowed maximum body sizes\n        for name, hook in pluginManager.get_hooks(\n            \"octoprint.server.http.bodysize\"\n        ).items():\n            try:\n                result = hook(list(max_body_sizes))\n            except Exception:\n                self._logger.exception(\n                    f\"There was an error while retrieving additional \"\n                    f\"upload sizes from plugin hook {name}\",\n                    extra={\"plugin\": name},\n                )\n            else:\n                if isinstance(result, (list, tuple)):\n                    for entry in result:\n                        if not isinstance(entry, tuple) or not len(entry) == 3:\n                            continue\n                        if (\n                            entry[0]\n                            not in util.tornado.UploadStorageFallbackHandler.BODY_METHODS\n                        ):\n                            continue\n                        if not isinstance(entry[2], int):\n                            continue\n\n                        method, route, size = entry\n                        route = r\"/plugin/{name}/{route}\".format(\n                            name=name,\n                            route=route if not route.startswith(\"/\") else route[1:],\n                        )\n\n                        self._logger.debug(\n                            f\"Adding maximum body size of {size}B for {method} requests to {route})\"\n                        )\n                        max_body_sizes.append((method, route, size))\n\n        self._stop_intermediary_server()\n\n        # initialize and bind the server\n        trusted_downstream = self._settings.get(\n            [\"server\", \"reverseProxy\", \"trustedDownstream\"]\n        )\n        if not isinstance(trusted_downstream, list):\n            self._logger.warning(\n                \"server.reverseProxy.trustedDownstream is not a list, skipping\"\n            )\n            trusted_downstream = []\n\n        server_kwargs = {\n            \"max_body_sizes\": max_body_sizes,\n            \"default_max_body_size\": self._settings.getInt([\"server\", \"maxSize\"]),\n            \"xheaders\": True,\n            \"trusted_downstream\": trusted_downstream,\n        }\n        if sys.platform == \"win32\":\n            # set 10min idle timeout under windows to hopefully make #2916 less likely\n            server_kwargs.update({\"idle_connection_timeout\": 600})\n\n        self._server = util.tornado.CustomHTTPServer(self._tornado_app, **server_kwargs)\n\n        listening_address = self._host\n        if self._host == \"::\" and not self._v6_only:\n            # special case - tornado only listens on v4 _and_ v6 if we use None as address\n            listening_address = None\n\n        self._server.listen(self._port, address=listening_address)\n\n        ### From now on it's ok to launch subprocesses again\n\n        eventManager.fire(events.Events.STARTUP)\n\n        # analysis backlog\n        fileManager.process_backlog()\n\n        # auto connect\n        if self._settings.getBoolean([\"serial\", \"autoconnect\"]):\n            self._logger.info(\n                \"Autoconnect on startup is configured, trying to connect to the printer...\"\n            )\n            try:\n                (port, baudrate) = (\n                    self._settings.get([\"serial\", \"port\"]),\n                    self._settings.getInt([\"serial\", \"baudrate\"]),\n                )\n                printer_profile = printerProfileManager.get_default()\n                connectionOptions = printer.__class__.get_connection_options()\n                if port in connectionOptions[\"ports\"] or port == \"AUTO\" or port is None:\n                    self._logger.info(\n                        f\"Trying to connect to configured serial port {port}\"\n                    )\n                    printer.connect(\n                        port=port,\n                        baudrate=baudrate,\n                        profile=printer_profile[\"id\"]\n                        if \"id\" in printer_profile\n                        else \"_default\",\n                    )\n                else:\n                    self._logger.info(\n                        \"Could not find configured serial port {} in the system, cannot automatically connect to a non existing printer. Is it plugged in and booted up yet?\"\n                    )\n            except Exception:\n                self._logger.exception(\n                    \"Something went wrong while attempting to automatically connect to the printer\"\n                )\n\n        # start up watchdogs\n        try:\n            watched = self._settings.getBaseFolder(\"watched\")\n            watchdog_handler = util.watchdog.GcodeWatchdogHandler(fileManager, printer)\n            watchdog_handler.initial_scan(watched)\n\n            if self._settings.getBoolean([\"feature\", \"pollWatched\"]):\n                # use less performant polling observer if explicitly configured\n                observer = PollingObserver()\n            else:\n                # use os default\n                observer = Observer()\n\n            observer.schedule(watchdog_handler, watched, recursive=True)\n            observer.start()\n        except Exception:\n            self._logger.exception(\"Error starting watched folder observer\")\n\n        # run our startup plugins\n        octoprint.plugin.call_plugin(\n            octoprint.plugin.StartupPlugin,\n            \"on_startup\",\n            args=(self._host, self._port),\n            sorting_context=\"StartupPlugin.on_startup\",\n        )\n\n        def call_on_startup(name, plugin):\n            implementation = plugin.get_implementation(octoprint.plugin.StartupPlugin)\n            if implementation is None:\n                return\n            implementation.on_startup(self._host, self._port)\n\n        pluginLifecycleManager.add_callback(\"enabled\", call_on_startup)\n\n        # prepare our after startup function\n        def on_after_startup():\n            if self._host == \"::\":\n                if self._v6_only:\n                    # only v6\n                    self._logger.info(f\"Listening on http://[::]:{self._port}\")\n                else:\n                    # all v4 and v6\n                    self._logger.info(\n                        \"Listening on http://0.0.0.0:{port} and http://[::]:{port}\".format(\n                            port=self._port\n                        )\n                    )\n            else:\n                self._logger.info(\n                    \"Listening on http://{}:{}\".format(\n                        self._host if \":\" not in self._host else \"[\" + self._host + \"]\",\n                        self._port,\n                    )\n                )\n\n            if safe_mode and self._settings.getBoolean([\"server\", \"startOnceInSafeMode\"]):\n                self._logger.info(\n                    \"Server started successfully in safe mode as requested from config, removing flag\"\n                )\n                self._settings.setBoolean([\"server\", \"startOnceInSafeMode\"], False)\n                self._settings.save()\n\n            # now this is somewhat ugly, but the issue is the following: startup plugins might want to do things for\n            # which they need the server to be already alive (e.g. for being able to resolve urls, such as favicons\n            # or service xmls or the like). While they are working though the ioloop would block. Therefore we'll\n            # create a single use thread in which to perform our after-startup-tasks, start that and hand back\n            # control to the ioloop\n            def work():\n                octoprint.plugin.call_plugin(\n                    octoprint.plugin.StartupPlugin,\n                    \"on_after_startup\",\n                    sorting_context=\"StartupPlugin.on_after_startup\",\n                )\n\n                def call_on_after_startup(name, plugin):\n                    implementation = plugin.get_implementation(\n                        octoprint.plugin.StartupPlugin\n                    )\n                    if implementation is None:\n                        return\n                    implementation.on_after_startup()\n\n                pluginLifecycleManager.add_callback(\"enabled\", call_on_after_startup)\n\n                # if there was a rogue plugin we wouldn't even have made it here, so remove startup triggered safe mode\n                # flag again...\n                self._settings.setBoolean([\"server\", \"incompleteStartup\"], False)\n                self._settings.save()\n\n                # make a backup of the current config\n                self._settings.backup(ext=\"backup\")\n\n                # when we are through with that we also run our preemptive cache\n                if settings().getBoolean([\"devel\", \"cache\", \"preemptive\"]):\n                    self._execute_preemptive_flask_caching(preemptiveCache)\n\n            import threading\n\n            threading.Thread(target=work).start()\n\n        ioloop.add_callback(on_after_startup)\n\n        # prepare our shutdown function\n        def on_shutdown():\n            # will be called on clean system exit and shutdown the watchdog observer and call the on_shutdown methods\n            # on all registered ShutdownPlugins\n            self._logger.info(\"Shutting down...\")\n            observer.stop()\n            observer.join()\n            eventManager.fire(events.Events.SHUTDOWN)\n\n            self._logger.info(\"Calling on_shutdown on plugins\")\n            octoprint.plugin.call_plugin(\n                octoprint.plugin.ShutdownPlugin,\n                \"on_shutdown\",\n                sorting_context=\"ShutdownPlugin.on_shutdown\",\n            )\n\n            # wait for shutdown event to be processed, but maximally for 15s\n            event_timeout = 15.0\n            if eventManager.join(timeout=event_timeout):\n                self._logger.warning(\n                    \"Event loop was still busy processing after {}s, shutting down anyhow\".format(\n                        event_timeout\n                    )\n                )\n\n            if self._octoprint_daemon is not None:\n                self._logger.info(\"Cleaning up daemon pidfile\")\n                self._octoprint_daemon.terminated()\n\n            self._logger.info(\"Goodbye!\")\n\n        atexit.register(on_shutdown)\n\n        def sigterm_handler(*args, **kwargs):\n            # will stop tornado on SIGTERM, making the program exit cleanly\n            def shutdown_tornado():\n                self._logger.debug(\"Shutting down tornado's IOLoop...\")\n                ioloop.stop()\n\n            self._logger.debug(\"SIGTERM received...\")\n            ioloop.add_callback_from_signal(shutdown_tornado)\n\n        signal.signal(signal.SIGTERM, sigterm_handler)\n\n        try:\n            # this is the main loop - as long as tornado is running, OctoPrint is running\n            ioloop.start()\n            self._logger.debug(\"Tornado's IOLoop stopped\")\n        except (KeyboardInterrupt, SystemExit):\n            pass\n        except Exception:\n            self._logger.fatal(\n                \"Now that is embarrassing... Something really really went wrong here. Please report this including the stacktrace below in OctoPrint's bugtracker. Thanks!\"\n            )\n            self._logger.exception(\"Stacktrace follows:\")\n\n    def _log_safe_mode_start(self, self_mode):\n        self_mode_file = os.path.join(\n            self._settings.getBaseFolder(\"data\"), \"last_safe_mode\"\n        )\n        try:\n            with open(self_mode_file, \"w+\", encoding=\"utf-8\") as f:\n                f.write(self_mode)\n        except Exception as ex:\n            self._logger.warn(f\"Could not write safe mode file {self_mode_file}: {ex}\")\n\n    def _create_socket_connection(self, session):\n        global printer, fileManager, analysisQueue, userManager, eventManager, connectivityChecker\n        return util.sockjs.PrinterStateConnection(\n            printer,\n            fileManager,\n            analysisQueue,\n            userManager,\n            groupManager,\n            eventManager,\n            pluginManager,\n            connectivityChecker,\n            session,\n        )\n\n    def _check_for_root(self):\n        if \"geteuid\" in dir(os) and os.geteuid() == 0:\n            exit(\"You should not run OctoPrint as root!\")\n\n    def _get_locale(self):\n        global LANGUAGES\n\n        if \"l10n\" in request.values:\n            return Locale.negotiate([request.values[\"l10n\"]], LANGUAGES)\n\n        if \"X-Locale\" in request.headers:\n            return Locale.negotiate([request.headers[\"X-Locale\"]], LANGUAGES)\n\n        if hasattr(g, \"identity\") and g.identity:\n            userid = g.identity.id\n            try:\n                user_language = userManager.get_user_setting(\n                    userid, (\"interface\", \"language\")\n                )\n                if user_language is not None and not user_language == \"_default\":\n                    return Locale.negotiate([user_language], LANGUAGES)\n            except octoprint.access.users.UnknownUser:\n                pass\n\n        default_language = self._settings.get([\"appearance\", \"defaultLanguage\"])\n        if (\n            default_language is not None\n            and not default_language == \"_default\"\n            and default_language in LANGUAGES\n        ):\n            return Locale.negotiate([default_language], LANGUAGES)\n\n        return Locale.parse(request.accept_languages.best_match(LANGUAGES))\n\n    def _setup_heartbeat_logging(self):\n        logger = logging.getLogger(__name__ + \".heartbeat\")\n\n        def log_heartbeat():\n            logger.info(\"Server heartbeat <3\")\n\n        interval = settings().getFloat([\"server\", \"heartbeat\"])\n        logger.info(f\"Starting server heartbeat, {interval}s interval\")\n\n        timer = octoprint.util.RepeatedTimer(interval, log_heartbeat)\n        timer.start()\n\n    def _setup_app(self, app):\n        global limiter\n\n        from octoprint.server.util.flask import (\n            OctoPrintFlaskRequest,\n            OctoPrintFlaskResponse,\n            OctoPrintJsonEncoder,\n            OctoPrintSessionInterface,\n            PrefixAwareJinjaEnvironment,\n            ReverseProxiedEnvironment,\n        )\n\n        # we must set this here because setting app.debug will access app.jinja_env\n        app.jinja_environment = PrefixAwareJinjaEnvironment\n\n        app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n        app.config[\"JSONIFY_PRETTYPRINT_REGULAR\"] = False\n        app.config[\"REMEMBER_COOKIE_HTTPONLY\"] = True\n\n        # we must not set this before TEMPLATES_AUTO_RELOAD is set to True or that won't take\n        app.debug = self._debug\n\n        # setup octoprint's flask json serialization/deserialization\n        app.json_encoder = OctoPrintJsonEncoder\n\n        s = settings()\n\n        secret_key = s.get([\"server\", \"secretKey\"])\n        if not secret_key:\n            import string\n            from random import choice\n\n            chars = string.ascii_lowercase + string.ascii_uppercase + string.digits\n            secret_key = \"\".join(choice(chars) for _ in range(32))\n            s.set([\"server\", \"secretKey\"], secret_key)\n            s.save()\n\n        app.secret_key = secret_key\n\n        reverse_proxied = ReverseProxiedEnvironment(\n            header_prefix=s.get([\"server\", \"reverseProxy\", \"prefixHeader\"]),\n            header_scheme=s.get([\"server\", \"reverseProxy\", \"schemeHeader\"]),\n            header_host=s.get([\"server\", \"reverseProxy\", \"hostHeader\"]),\n            header_server=s.get([\"server\", \"reverseProxy\", \"serverHeader\"]),\n            header_port=s.get([\"server\", \"reverseProxy\", \"portHeader\"]),\n            prefix=s.get([\"server\", \"reverseProxy\", \"prefixFallback\"]),\n            scheme=s.get([\"server\", \"reverseProxy\", \"schemeFallback\"]),\n            host=s.get([\"server\", \"reverseProxy\", \"hostFallback\"]),\n            server=s.get([\"server\", \"reverseProxy\", \"serverFallback\"]),\n            port=s.get([\"server\", \"reverseProxy\", \"portFallback\"]),\n        )\n\n        OctoPrintFlaskRequest.environment_wrapper = reverse_proxied\n        app.request_class = OctoPrintFlaskRequest\n        app.response_class = OctoPrintFlaskResponse\n        app.session_interface = OctoPrintSessionInterface()\n\n        @app.before_request\n        def before_request():\n            g.locale = self._get_locale()\n\n            # used for performance measurement\n            g.start_time = time.monotonic()\n\n            if self._debug and \"perfprofile\" in request.args:\n                try:\n                    from pyinstrument import Profiler\n\n                    g.perfprofiler = Profiler()\n                    g.perfprofiler.start()\n                except ImportError:\n                    # profiler dependency not installed, ignore\n                    pass\n\n        @app.after_request\n        def after_request(response):\n            # send no-cache headers with all POST responses\n            if request.method == \"POST\":\n                response.cache_control.no_cache = True\n\n            response.headers.add(\"X-Clacks-Overhead\", \"GNU Terry Pratchett\")\n\n            if hasattr(g, \"perfprofiler\"):\n                g.perfprofiler.stop()\n                output_html = g.perfprofiler.output_html()\n                return make_response(output_html)\n\n            if hasattr(g, \"start_time\"):\n                end_time = time.monotonic()\n                duration_ms = int((end_time - g.start_time) * 1000)\n                response.headers.add(\"Server-Timing\", f\"app;dur={duration_ms}\")\n\n            return response\n\n        from octoprint.util.jinja import MarkdownFilter\n\n        MarkdownFilter(app)\n\n        from flask_limiter import Limiter\n        from flask_limiter.util import get_remote_address\n\n        app.config[\"RATELIMIT_STRATEGY\"] = \"fixed-window-elastic-expiry\"\n\n        limiter = Limiter(\n            app,\n            key_func=get_remote_address,\n            enabled=s.getBoolean([\"devel\", \"enableRateLimiter\"]),\n        )\n\n    def _setup_i18n(self, app):\n        global babel\n        global LOCALES\n        global LANGUAGES\n\n        babel = Babel(app)\n\n        def get_available_locale_identifiers(locales):\n            result = set()\n\n            # add available translations\n            for locale in locales:\n                result.add(locale.language)\n                if locale.territory:\n                    # if a territory is specified, add that too\n                    result.add(f\"{locale.language}_{locale.territory}\")\n\n            return result\n\n        LOCALES = babel.list_translations()\n        LANGUAGES = get_available_locale_identifiers(LOCALES)\n\n        @babel.localeselector\n        def get_locale():\n            return self._get_locale()\n\n    def _setup_jinja2(self):\n        import re\n\n        app.jinja_env.add_extension(\"jinja2.ext.do\")\n        app.jinja_env.add_extension(\"octoprint.util.jinja.trycatch\")\n\n        def regex_replace(s, find, replace):\n            return re.sub(find, replace, s)\n\n        html_header_regex = re.compile(\n            r\"<h(?P<number>[1-6])>(?P<content>.*?)</h(?P=number)>\"\n        )\n\n        def offset_html_headers(s, offset):\n            def repl(match):\n                number = int(match.group(\"number\"))\n                number += offset\n                if number > 6:\n                    number = 6\n                elif number < 1:\n                    number = 1\n                return \"<h{number}>{content}</h{number}>\".format(\n                    number=number, content=match.group(\"content\")\n                )\n\n            return html_header_regex.sub(repl, s)\n\n        markdown_header_regex = re.compile(\n            r\"^(?P<hashs>#+)\\s+(?P<content>.*)$\", flags=re.MULTILINE\n        )\n\n        def offset_markdown_headers(s, offset):\n            def repl(match):\n                number = len(match.group(\"hashs\"))\n                number += offset\n                if number > 6:\n                    number = 6\n                elif number < 1:\n                    number = 1\n                return \"{hashs} {content}\".format(\n                    hashs=\"#\" * number, content=match.group(\"content\")\n                )\n\n            return markdown_header_regex.sub(repl, s)\n\n        html_link_regex = re.compile(r\"<(?P<tag>a.*?)>(?P<content>.*?)</a>\")\n\n        def externalize_links(text):\n            def repl(match):\n                tag = match.group(\"tag\")\n                if \"href\" not in tag:\n                    return match.group(0)\n\n                if \"target=\" not in tag and \"rel=\" not in tag:\n                    tag += ' target=\"_blank\" rel=\"noreferrer noopener\"'\n\n                content = match.group(\"content\")\n                return f\"<{tag}>{content}</a>\"\n\n            return html_link_regex.sub(repl, text)\n\n        single_quote_regex = re.compile(\"(?<!\\\\\\\\)'\")\n\n        def escape_single_quote(text):\n            return single_quote_regex.sub(\"\\\\'\", text)\n\n        double_quote_regex = re.compile('(?<!\\\\\\\\)\"')\n\n        def escape_double_quote(text):\n            return double_quote_regex.sub('\\\\\"', text)\n\n        app.jinja_env.filters[\"regex_replace\"] = regex_replace\n        app.jinja_env.filters[\"offset_html_headers\"] = offset_html_headers\n        app.jinja_env.filters[\"offset_markdown_headers\"] = offset_markdown_headers\n        app.jinja_env.filters[\"externalize_links\"] = externalize_links\n        app.jinja_env.filters[\"escape_single_quote\"] = app.jinja_env.filters[\n            \"esq\"\n        ] = escape_single_quote\n        app.jinja_env.filters[\"escape_double_quote\"] = app.jinja_env.filters[\n            \"edq\"\n        ] = escape_double_quote\n\n        # configure additional template folders for jinja2\n        import jinja2\n\n        import octoprint.util.jinja\n\n        app.jinja_env.prefix_loader = jinja2.PrefixLoader({})\n\n        loaders = [app.jinja_loader, app.jinja_env.prefix_loader]\n        if octoprint.util.is_running_from_source():\n            root = os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../..\"))\n            allowed = [\"AUTHORS.md\", \"SUPPORTERS.md\", \"THIRDPARTYLICENSES.md\"]\n            files = {\"_data/\" + name: os.path.join(root, name) for name in allowed}\n            loaders.append(octoprint.util.jinja.SelectedFilesWithConversionLoader(files))\n\n        # TODO: Remove this in 2.0.0\n        warning_message = \"Loading plugin template '{template}' from '{filename}' without plugin prefix, this is deprecated and will soon no longer be supported.\"\n        loaders.append(\n            octoprint.util.jinja.WarningLoader(\n                octoprint.util.jinja.PrefixChoiceLoader(app.jinja_env.prefix_loader),\n                warning_message,\n            )\n        )\n\n        app.jinja_loader = jinja2.ChoiceLoader(loaders)\n\n        self._register_template_plugins()\n\n        # make sure plugin lifecycle events relevant for jinja2 are taken care of\n        def template_enabled(name, plugin):\n            if plugin.implementation is None or not isinstance(\n                plugin.implementation, octoprint.plugin.TemplatePlugin\n            ):\n                return\n            self._register_additional_template_plugin(plugin.implementation)\n\n        def template_disabled(name, plugin):\n            if plugin.implementation is None or not isinstance(\n                plugin.implementation, octoprint.plugin.TemplatePlugin\n            ):\n                return\n            self._unregister_additional_template_plugin(plugin.implementation)\n\n        pluginLifecycleManager.add_callback(\"enabled\", template_enabled)\n        pluginLifecycleManager.add_callback(\"disabled\", template_disabled)\n\n    def _execute_preemptive_flask_caching(self, preemptive_cache):\n        import time\n\n        from werkzeug.test import EnvironBuilder\n\n        # we clean up entries from our preemptive cache settings that haven't been\n        # accessed longer than server.preemptiveCache.until days\n        preemptive_cache_timeout = settings().getInt(\n            [\"server\", \"preemptiveCache\", \"until\"]\n        )\n        cutoff_timestamp = time.time() - preemptive_cache_timeout * 24 * 60 * 60\n\n        def filter_current_entries(entry):\n            \"\"\"Returns True for entries younger than the cutoff date\"\"\"\n            return \"_timestamp\" in entry and entry[\"_timestamp\"] > cutoff_timestamp\n\n        def filter_http_entries(entry):\n            \"\"\"Returns True for entries targeting http or https.\"\"\"\n            return (\n                \"base_url\" in entry\n                and entry[\"base_url\"]\n                and (\n                    entry[\"base_url\"].startswith(\"http://\")\n                    or entry[\"base_url\"].startswith(\"https://\")\n                )\n            )\n\n        def filter_entries(entry):\n            \"\"\"Combined filter.\"\"\"\n            filters = (filter_current_entries, filter_http_entries)\n            return all([f(entry) for f in filters])\n\n        # filter out all old and non-http entries\n        cache_data = preemptive_cache.clean_all_data(\n            lambda root, entries: list(filter(filter_entries, entries))\n        )\n        if not cache_data:\n            return\n\n        def execute_caching():\n            logger = logging.getLogger(__name__ + \".preemptive_cache\")\n\n            for route in sorted(cache_data.keys(), key=lambda x: (x.count(\"/\"), x)):\n                entries = reversed(\n                    sorted(cache_data[route], key=lambda x: x.get(\"_count\", 0))\n                )\n                for kwargs in entries:\n                    plugin = kwargs.get(\"plugin\", None)\n                    if plugin:\n                        try:\n                            plugin_info = pluginManager.get_plugin_info(\n                                plugin, require_enabled=True\n                            )\n                            if plugin_info is None:\n                                logger.info(\n                                    \"About to preemptively cache plugin {} but it is not installed or enabled, preemptive caching makes no sense\".format(\n                                        plugin\n                                    )\n                                )\n                                continue\n\n                            implementation = plugin_info.implementation\n                            if implementation is None or not isinstance(\n                                implementation, octoprint.plugin.UiPlugin\n                            ):\n                                logger.info(\n                                    \"About to preemptively cache plugin {} but it is not a UiPlugin, preemptive caching makes no sense\".format(\n                                        plugin\n                                    )\n                                )\n                                continue\n                            if not implementation.get_ui_preemptive_caching_enabled():\n                                logger.info(\n                                    \"About to preemptively cache plugin {} but it has disabled preemptive caching\".format(\n                                        plugin\n                                    )\n                                )\n                                continue\n                        except Exception:\n                            logger.exception(\n                                \"Error while trying to check if plugin {} has preemptive caching enabled, skipping entry\"\n                            )\n                            continue\n\n                    additional_request_data = kwargs.get(\"_additional_request_data\", {})\n                    kwargs = {\n                        k: v\n                        for k, v in kwargs.items()\n                        if not k.startswith(\"_\") and not k == \"plugin\"\n                    }\n                    kwargs.update(additional_request_data)\n\n                    try:\n                        start = time.monotonic()\n                        if plugin:\n                            logger.info(\n                                \"Preemptively caching {} (ui {}) for {!r}\".format(\n                                    route, plugin, kwargs\n                                )\n                            )\n                        else:\n                            logger.info(\n                                \"Preemptively caching {} (ui _default) for {!r}\".format(\n                                    route, kwargs\n                                )\n                            )\n\n                        headers = kwargs.get(\"headers\", {})\n                        headers[\"X-Force-View\"] = plugin if plugin else \"_default\"\n                        headers[\"X-Preemptive-Recording\"] = \"yes\"\n                        kwargs[\"headers\"] = headers\n\n                        builder = EnvironBuilder(**kwargs)\n                        app(builder.get_environ(), lambda *a, **kw: None)\n\n                        logger.info(f\"... done in {time.monotonic() - start:.2f}s\")\n                    except Exception:\n                        logger.exception(\n                            \"Error while trying to preemptively cache {} for {!r}\".format(\n                                route, kwargs\n                            )\n                        )\n\n        # asynchronous caching\n        import threading\n\n        cache_thread = threading.Thread(\n            target=execute_caching, name=\"Preemptive Cache Worker\"\n        )\n        cache_thread.daemon = True\n        cache_thread.start()\n\n    def _register_template_plugins(self):\n        template_plugins = pluginManager.get_implementations(\n            octoprint.plugin.TemplatePlugin\n        )\n        for plugin in template_plugins:\n            try:\n                self._register_additional_template_plugin(plugin)\n            except Exception:\n                self._logger.exception(\n                    \"Error while trying to register templates of plugin {}, ignoring it\".format(\n                        plugin._identifier\n                    )\n                )\n\n    def _register_additional_template_plugin(self, plugin):\n        import octoprint.util.jinja\n\n        folder = plugin.get_template_folder()\n        if (\n            folder is not None\n            and plugin.template_folder_key not in app.jinja_env.prefix_loader.mapping\n        ):\n            loader = octoprint.util.jinja.FilteredFileSystemLoader(\n                [plugin.get_template_folder()],\n                path_filter=lambda x: not octoprint.util.is_hidden_path(x),\n            )\n\n            app.jinja_env.prefix_loader.mapping[plugin.template_folder_key] = loader\n\n    def _unregister_additional_template_plugin(self, plugin):\n        folder = plugin.get_template_folder()\n        if (\n            folder is not None\n            and plugin.template_folder_key in app.jinja_env.prefix_loader.mapping\n        ):\n            del app.jinja_env.prefix_loader.mapping[plugin.template_folder_key]\n\n    def _setup_blueprints(self):\n        # do not remove or the index view won't be found\n        import octoprint.server.views  # noqa: F401\n        from octoprint.server.api import api\n        from octoprint.server.util.flask import make_api_error\n\n        blueprints = [api]\n        api_endpoints = [\"/api\"]\n        registrators = [functools.partial(app.register_blueprint, api, url_prefix=\"/api\")]\n\n        # also register any blueprints defined in BlueprintPlugins\n        (\n            blueprints_from_plugins,\n            api_endpoints_from_plugins,\n            registrators_from_plugins,\n        ) = self._prepare_blueprint_plugins()\n        blueprints += blueprints_from_plugins\n        api_endpoints += api_endpoints_from_plugins\n        registrators += registrators_from_plugins\n\n        # and register a blueprint for serving the static files of asset plugins which are not blueprint plugins themselves\n        (blueprints_from_assets, registrators_from_assets) = self._prepare_asset_plugins()\n        blueprints += blueprints_from_assets\n        registrators += registrators_from_assets\n\n        # make sure all before/after_request hook results are attached as well\n        self._add_plugin_request_handlers_to_blueprints(*blueprints)\n\n        # register everything with the system\n        for registrator in registrators:\n            registrator()\n\n        @app.errorhandler(HTTPException)\n        def _handle_api_error(ex):\n            if any(map(lambda x: request.path.startswith(x), api_endpoints)):\n                return make_api_error(ex.description, ex.code)\n            else:\n                return ex\n\n    def _prepare_blueprint_plugins(self):\n        def register_plugin_blueprint(plugin, blueprint, url_prefix):\n            try:\n                app.register_blueprint(\n                    blueprint, url_prefix=url_prefix, name_prefix=\"plugin\"\n                )\n                self._logger.debug(\n                    f\"Registered API of plugin {plugin} under URL prefix {url_prefix}\"\n                )\n            except Exception:\n                self._logger.exception(\n                    f\"Error while registering blueprint of plugin {plugin}, ignoring it\",\n                    extra={\"plugin\": plugin},\n                )\n\n        blueprints = []\n        api_endpoints = []\n        registrators = []\n\n        blueprint_plugins = octoprint.plugin.plugin_manager().get_implementations(\n            octoprint.plugin.BlueprintPlugin\n        )\n        for plugin in blueprint_plugins:\n            blueprint, prefix = self._prepare_blueprint_plugin(plugin)\n\n            blueprints.append(blueprint)\n            api_endpoints += map(\n                lambda x: prefix + x, plugin.get_blueprint_api_prefixes()\n            )\n            registrators.append(\n                functools.partial(\n                    register_plugin_blueprint, plugin._identifier, blueprint, prefix\n                )\n            )\n\n        return blueprints, api_endpoints, registrators\n\n    def _prepare_asset_plugins(self):\n        def register_asset_blueprint(plugin, blueprint, url_prefix):\n            try:\n                app.register_blueprint(\n                    blueprint, url_prefix=url_prefix, name_prefix=\"plugin\"\n                )\n                self._logger.debug(\n                    f\"Registered assets of plugin {plugin} under URL prefix {url_prefix}\"\n                )\n            except Exception:\n                self._logger.exception(\n                    f\"Error while registering blueprint of plugin {plugin}, ignoring it\",\n                    extra={\"plugin\": plugin},\n                )\n\n        blueprints = []\n        registrators = []\n\n        asset_plugins = octoprint.plugin.plugin_manager().get_implementations(\n            octoprint.plugin.AssetPlugin\n        )\n        for plugin in asset_plugins:\n            if isinstance(plugin, octoprint.plugin.BlueprintPlugin):\n                continue\n            blueprint, prefix = self._prepare_asset_plugin(plugin)\n\n            blueprints.append(blueprint)\n            registrators.append(\n                functools.partial(\n                    register_asset_blueprint, plugin._identifier, blueprint, prefix\n                )\n            )\n\n        return blueprints, registrators\n\n    def _prepare_blueprint_plugin(self, plugin):\n        name = plugin._identifier\n        blueprint = plugin.get_blueprint()\n        if blueprint is None:\n            return\n\n        blueprint.before_request(corsRequestHandler)\n        blueprint.before_request(loginFromApiKeyRequestHandler)\n        blueprint.after_request(corsResponseHandler)\n\n        if plugin.is_blueprint_protected():\n            blueprint.before_request(requireLoginRequestHandler)\n\n        url_prefix = f\"/plugin/{name}\"\n        return blueprint, url_prefix\n\n    def _prepare_asset_plugin(self, plugin):\n        name = plugin._identifier\n\n        url_prefix = f\"/plugin/{name}\"\n        blueprint = Blueprint(name, name, static_folder=plugin.get_asset_folder())\n        return blueprint, url_prefix\n\n    def _add_plugin_request_handlers_to_blueprints(self, *blueprints):\n        before_hooks = octoprint.plugin.plugin_manager().get_hooks(\n            \"octoprint.server.api.before_request\"\n        )\n        after_hooks = octoprint.plugin.plugin_manager().get_hooks(\n            \"octoprint.server.api.after_request\"\n        )\n\n        for name, hook in before_hooks.items():\n            plugin = octoprint.plugin.plugin_manager().get_plugin(name)\n            for blueprint in blueprints:\n                try:\n                    result = hook(plugin=plugin)\n                    if isinstance(result, (list, tuple)):\n                        for h in result:\n                            blueprint.before_request(h)\n                except Exception:\n                    self._logger.exception(\n                        \"Error processing before_request hooks from plugin {}\".format(\n                            plugin\n                        ),\n                        extra={\"plugin\": name},\n                    )\n\n        for name, hook in after_hooks.items():\n            plugin = octoprint.plugin.plugin_manager().get_plugin(name)\n            for blueprint in blueprints:\n                try:\n                    result = hook(plugin=plugin)\n                    if isinstance(result, (list, tuple)):\n                        for h in result:\n                            blueprint.after_request(h)\n                except Exception:\n                    self._logger.exception(\n                        \"Error processing after_request hooks from plugin {}\".format(\n                            plugin\n                        ),\n                        extra={\"plugin\": name},\n                    )\n\n    def _setup_mimetypes(self):\n        # Safety measures for Windows... apparently the mimetypes module takes its translation from the windows\n        # registry, and if for some weird reason that gets borked the reported MIME types can be all over the place.\n        # Since at least in Chrome that can cause hilarious issues with JS files (refusal to run them and thus a\n        # borked UI) we make sure that .js always maps to the correct application/javascript, and also throw in a\n        # .css -> text/css for good measure.\n        #\n        # See #3367\n        mimetypes.add_type(\"application/javascript\", \".js\")\n        mimetypes.add_type(\"text/css\", \".css\")\n\n    def _setup_assets(self):\n        global app\n        global assets\n        global pluginManager\n\n        from octoprint.server.util.webassets import MemoryManifest  # noqa: F401\n\n        util.flask.fix_webassets_filtertool()\n\n        base_folder = self._settings.getBaseFolder(\"generated\")\n\n        # clean the folder\n        if self._settings.getBoolean([\"devel\", \"webassets\", \"clean_on_startup\"]):\n            import errno\n            import shutil\n\n            for entry, recreate in (\n                (\"webassets\", True),\n                # no longer used, but clean up just in case\n                (\".webassets-cache\", False),\n                (\".webassets-manifest.json\", False),\n            ):\n                path = os.path.join(base_folder, entry)\n\n                # delete path if it exists\n                if os.path.exists(path):\n                    try:\n                        self._logger.debug(f\"Deleting {path}...\")\n                        if os.path.isdir(path):\n                            shutil.rmtree(path)\n                        else:\n                            os.remove(path)\n                    except Exception:\n                        self._logger.exception(\n                            f\"Error while trying to delete {path}, \" f\"leaving it alone\"\n                        )\n                        continue\n\n                # re-create path if necessary\n                if recreate:\n                    self._logger.debug(f\"Creating {path}...\")\n                    error_text = (\n                        f\"Error while trying to re-create {path}, that might cause \"\n                        f\"errors with the webassets cache\"\n                    )\n                    try:\n                        os.makedirs(path)\n                    except OSError as e:\n                        if e.errno == errno.EACCES:\n                            # that might be caused by the user still having the folder open somewhere, let's try again after\n                            # waiting a bit\n                            import time\n\n                            for n in range(3):\n                                time.sleep(0.5)\n                                self._logger.debug(\n                                    \"Creating {path}: Retry #{retry} after {time}s\".format(\n                                        path=path, retry=n + 1, time=(n + 1) * 0.5\n                                    )\n                                )\n                                try:\n                                    os.makedirs(path)\n                                    break\n                                except Exception:\n                                    if self._logger.isEnabledFor(logging.DEBUG):\n                                        self._logger.exception(\n                                            f\"Ignored error while creating \"\n                                            f\"directory {path}\"\n                                        )\n                                    pass\n                            else:\n                                # this will only get executed if we never did\n                                # successfully execute makedirs above\n                                self._logger.exception(error_text)\n                                continue\n                        else:\n                            # not an access error, so something we don't understand\n                            # went wrong -> log an error and stop\n                            self._logger.exception(error_text)\n                            continue\n                    except Exception:\n                        # not an OSError, so something we don't understand\n                        # went wrong -> log an error and stop\n                        self._logger.exception(error_text)\n                        continue\n\n                self._logger.info(f\"Reset webasset folder {path}...\")\n\n        AdjustedEnvironment = type(Environment)(\n            Environment.__name__,\n            (Environment,),\n            {\"resolver_class\": util.flask.PluginAssetResolver},\n        )\n\n        class CustomDirectoryEnvironment(AdjustedEnvironment):\n            @property\n            def directory(self):\n                return base_folder\n\n        assets = CustomDirectoryEnvironment(app)\n        assets.debug = not self._settings.getBoolean([\"devel\", \"webassets\", \"bundle\"])\n\n        # we should rarely if ever regenerate the webassets in production and can wait a\n        # few seconds for regeneration in development, if it means we can get rid of\n        # a whole monkey patch and in internal use of pickle with non-tamperproof files\n        assets.cache = False\n        assets.manifest = \"memory\"\n\n        UpdaterType = type(util.flask.SettingsCheckUpdater)(\n            util.flask.SettingsCheckUpdater.__name__,\n            (util.flask.SettingsCheckUpdater,),\n            {\"updater\": assets.updater},\n        )\n        assets.updater = UpdaterType\n\n        preferred_stylesheet = self._settings.get([\"devel\", \"stylesheet\"])\n\n        dynamic_core_assets = util.flask.collect_core_assets()\n        dynamic_plugin_assets = util.flask.collect_plugin_assets(\n            preferred_stylesheet=preferred_stylesheet\n        )\n\n        js_libs = [\n            \"js/lib/babel-polyfill.min.js\",\n            \"js/lib/jquery/jquery.min.js\",\n            \"js/lib/modernizr.custom.js\",\n            \"js/lib/lodash.min.js\",\n            \"js/lib/sprintf.min.js\",\n            \"js/lib/knockout.js\",\n            \"js/lib/knockout.mapping-latest.js\",\n            \"js/lib/babel.js\",\n            \"js/lib/bootstrap/bootstrap.js\",\n            \"js/lib/bootstrap/bootstrap-modalmanager.js\",\n            \"js/lib/bootstrap/bootstrap-modal.js\",\n            \"js/lib/bootstrap/bootstrap-slider.js\",\n            \"js/lib/bootstrap/bootstrap-tabdrop.js\",\n            \"js/lib/jquery/jquery-ui.js\",\n            \"js/lib/jquery/jquery.flot.js\",\n            \"js/lib/jquery/jquery.flot.time.js\",\n            \"js/lib/jquery/jquery.flot.crosshair.js\",\n            \"js/lib/jquery/jquery.flot.resize.js\",\n            \"js/lib/jquery/jquery.iframe-transport.js\",\n            \"js/lib/jquery/jquery.fileupload.js\",\n            \"js/lib/jquery/jquery.slimscroll.min.js\",\n            \"js/lib/jquery/jquery.qrcode.min.js\",\n            \"js/lib/jquery/jquery.bootstrap.wizard.js\",\n            \"js/lib/pnotify/pnotify.core.min.js\",\n            \"js/lib/pnotify/pnotify.buttons.min.js\",\n            \"js/lib/pnotify/pnotify.callbacks.min.js\",\n            \"js/lib/pnotify/pnotify.confirm.min.js\",\n            \"js/lib/pnotify/pnotify.desktop.min.js\",\n            \"js/lib/pnotify/pnotify.history.min.js\",\n            \"js/lib/pnotify/pnotify.mobile.min.js\",\n            \"js/lib/pnotify/pnotify.nonblock.min.js\",\n            \"js/lib/pnotify/pnotify.reference.min.js\",\n            \"js/lib/pnotify/pnotify.tooltip.min.js\",\n            \"js/lib/pnotify/pnotify.maxheight.js\",\n            \"js/lib/moment-with-locales.min.js\",\n            \"js/lib/pusher.color.min.js\",\n            \"js/lib/detectmobilebrowser.js\",\n            \"js/lib/ua-parser.min.js\",\n            \"js/lib/md5.min.js\",\n            \"js/lib/bootstrap-slider-knockout-binding.js\",\n            \"js/lib/loglevel.min.js\",\n            \"js/lib/sockjs.min.js\",\n            \"js/lib/hls.js\",\n            \"js/lib/less.js\",\n        ]\n\n        css_libs = [\n            \"css/bootstrap.min.css\",\n            \"css/bootstrap-modal.css\",\n            \"css/bootstrap-slider.css\",\n            \"css/bootstrap-tabdrop.css\",\n            \"vendor/font-awesome-3.2.1/css/font-awesome.min.css\",\n            \"vendor/font-awesome-5.15.1/css/all.min.css\",\n            \"vendor/font-awesome-5.15.1/css/v4-shims.min.css\",\n            \"css/jquery.fileupload-ui.css\",\n            \"css/pnotify.core.min.css\",\n            \"css/pnotify.buttons.min.css\",\n            \"css/pnotify.history.min.css\",\n        ]\n\n        # a couple of custom filters\n        from webassets.filter import register_filter\n\n        from octoprint.server.util.webassets import (\n            GzipFile,\n            JsDelimiterBundler,\n            JsPluginBundle,\n            LessImportRewrite,\n            RJSMinExtended,\n            SourceMapRemove,\n            SourceMapRewrite,\n        )\n\n        register_filter(LessImportRewrite)\n        register_filter(SourceMapRewrite)\n        register_filter(SourceMapRemove)\n        register_filter(JsDelimiterBundler)\n        register_filter(GzipFile)\n        register_filter(RJSMinExtended)\n\n        def all_assets_for_plugins(collection):\n            \"\"\"Gets all plugin assets for a dict of plugin->assets\"\"\"\n            result = []\n            for assets in collection.values():\n                result += assets\n            return result\n\n        # -- JS --------------------------------------------------------------------------------------------------------\n\n        filters = [\"sourcemap_remove\"]\n        if self._settings.getBoolean([\"devel\", \"webassets\", \"minify\"]):\n            filters += [\"rjsmin_extended\"]\n        filters += [\"js_delimiter_bundler\", \"gzip\"]\n\n        js_filters = filters\n        if self._settings.getBoolean([\"devel\", \"webassets\", \"minify_plugins\"]):\n            js_plugin_filters = js_filters\n        else:\n            js_plugin_filters = [x for x in js_filters if x not in (\"rjsmin_extended\",)]\n\n        def js_bundles_for_plugins(collection, filters=None):\n            \"\"\"Produces JsPluginBundle instances that output IIFE wrapped assets\"\"\"\n            result = OrderedDict()\n            for plugin, assets in collection.items():\n                if len(assets):\n                    result[plugin] = JsPluginBundle(plugin, *assets, filters=filters)\n            return result\n\n        js_core = (\n            dynamic_core_assets[\"js\"]\n            + all_assets_for_plugins(dynamic_plugin_assets[\"bundled\"][\"js\"])\n            + [\"js/app/dataupdater.js\", \"js/app/helpers.js\", \"js/app/main.js\"]\n        )\n        js_plugins = js_bundles_for_plugins(\n            dynamic_plugin_assets[\"external\"][\"js\"], filters=\"js_delimiter_bundler\"\n        )\n\n        clientjs_core = dynamic_core_assets[\"clientjs\"] + all_assets_for_plugins(\n            dynamic_plugin_assets[\"bundled\"][\"clientjs\"]\n        )\n        clientjs_plugins = js_bundles_for_plugins(\n            dynamic_plugin_assets[\"external\"][\"clientjs\"], filters=\"js_delimiter_bundler\"\n        )\n\n        js_libs_bundle = Bundle(\n            *js_libs, output=\"webassets/packed_libs.js\", filters=\",\".join(js_filters)\n        )\n\n        js_core_bundle = Bundle(\n            *js_core, output=\"webassets/packed_core.js\", filters=\",\".join(js_filters)\n        )\n\n        if len(js_plugins) == 0:\n            js_plugins_bundle = Bundle(*[])\n        else:\n            js_plugins_bundle = Bundle(\n                *js_plugins.values(),\n                output=\"webassets/packed_plugins.js\",\n                filters=\",\".join(js_plugin_filters),\n            )\n\n        js_app_bundle = Bundle(\n            js_plugins_bundle,\n            js_core_bundle,\n            output=\"webassets/packed_app.js\",\n            filters=\",\".join(js_plugin_filters),\n        )\n\n        js_client_core_bundle = Bundle(\n            *clientjs_core,\n            output=\"webassets/packed_client_core.js\",\n            filters=\",\".join(js_filters),\n        )\n\n        if len(clientjs_plugins) == 0:\n            js_client_plugins_bundle = Bundle(*[])\n        else:\n            js_client_plugins_bundle = Bundle(\n                *clientjs_plugins.values(),\n                output=\"webassets/packed_client_plugins.js\",\n                filters=\",\".join(js_plugin_filters),\n            )\n\n        js_client_bundle = Bundle(\n            js_client_core_bundle,\n            js_client_plugins_bundle,\n            output=\"webassets/packed_client.js\",\n            filters=\",\".join(js_plugin_filters),\n        )\n\n        # -- CSS -------------------------------------------------------------------------------------------------------\n\n        css_filters = [\"cssrewrite\", \"gzip\"]\n\n        css_core = list(dynamic_core_assets[\"css\"]) + all_assets_for_plugins(\n            dynamic_plugin_assets[\"bundled\"][\"css\"]\n        )\n        css_plugins = list(\n            all_assets_for_plugins(dynamic_plugin_assets[\"external\"][\"css\"])\n        )\n\n        css_libs_bundle = Bundle(\n            *css_libs, output=\"webassets/packed_libs.css\", filters=\",\".join(css_filters)\n        )\n\n        if len(css_core) == 0:\n            css_core_bundle = Bundle(*[])\n        else:\n            css_core_bundle = Bundle(\n                *css_core,\n                output=\"webassets/packed_core.css\",\n                filters=\",\".join(css_filters),\n            )\n\n        if len(css_plugins) == 0:\n            css_plugins_bundle = Bundle(*[])\n        else:\n            css_plugins_bundle = Bundle(\n                *css_plugins,\n                output=\"webassets/packed_plugins.css\",\n                filters=\",\".join(css_filters),\n            )\n\n        css_app_bundle = Bundle(\n            css_core,\n            css_plugins,\n            output=\"webassets/packed_app.css\",\n            filters=\",\".join(css_filters),\n        )\n\n        # -- LESS ------------------------------------------------------------------------------------------------------\n\n        less_filters = [\"cssrewrite\", \"less_importrewrite\", \"gzip\"]\n\n        less_core = list(dynamic_core_assets[\"less\"]) + all_assets_for_plugins(\n            dynamic_plugin_assets[\"bundled\"][\"less\"]\n        )\n        less_plugins = all_assets_for_plugins(dynamic_plugin_assets[\"external\"][\"less\"])\n\n        if len(less_core) == 0:\n            less_core_bundle = Bundle(*[])\n        else:\n            less_core_bundle = Bundle(\n                *less_core,\n                output=\"webassets/packed_core.less\",\n                filters=\",\".join(less_filters),\n            )\n\n        if len(less_plugins) == 0:\n            less_plugins_bundle = Bundle(*[])\n        else:\n            less_plugins_bundle = Bundle(\n                *less_plugins,\n                output=\"webassets/packed_plugins.less\",\n                filters=\",\".join(less_filters),\n            )\n\n        less_app_bundle = Bundle(\n            less_core,\n            less_plugins,\n            output=\"webassets/packed_app.less\",\n            filters=\",\".join(less_filters),\n        )\n\n        # -- asset registration ----------------------------------------------------------------------------------------\n\n        assets.register(\"js_libs\", js_libs_bundle)\n        assets.register(\"js_client_core\", js_client_core_bundle)\n        for plugin, bundle in clientjs_plugins.items():\n            # register our collected clientjs plugin bundles so that they are bound to the environment\n            assets.register(f\"js_client_plugin_{plugin}\", bundle)\n        assets.register(\"js_client_plugins\", js_client_plugins_bundle)\n        assets.register(\"js_client\", js_client_bundle)\n        assets.register(\"js_core\", js_core_bundle)\n        for plugin, bundle in js_plugins.items():\n            # register our collected plugin bundles so that they are bound to the environment\n            assets.register(f\"js_plugin_{plugin}\", bundle)\n        assets.register(\"js_plugins\", js_plugins_bundle)\n        assets.register(\"js_app\", js_app_bundle)\n        assets.register(\"css_libs\", css_libs_bundle)\n        assets.register(\"css_core\", css_core_bundle)\n        assets.register(\"css_plugins\", css_plugins_bundle)\n        assets.register(\"css_app\", css_app_bundle)\n        assets.register(\"less_core\", less_core_bundle)\n        assets.register(\"less_plugins\", less_plugins_bundle)\n        assets.register(\"less_app\", less_app_bundle)\n\n    def _setup_login_manager(self):\n        global loginManager\n\n        loginManager = LoginManager()\n\n        # \"strong\" is incompatible to remember me, see maxcountryman/flask-login#156. It also causes issues with\n        # clients toggling between IPv4 and IPv6 client addresses due to names being resolved one way or the other as\n        # at least observed on a Win10 client targeting \"localhost\", resolved as both \"127.0.0.1\" and \"::1\"\n        loginManager.session_protection = \"basic\"\n\n        loginManager.user_loader(load_user)\n        loginManager.unauthorized_handler(unauthorized_user)\n        loginManager.anonymous_user = userManager.anonymous_user_factory\n        loginManager.request_loader(load_user_from_request)\n\n        loginManager.init_app(app, add_context_processor=False)\n\n    def _start_intermediary_server(self):\n        import socket\n        import threading\n        from http.server import BaseHTTPRequestHandler, HTTPServer\n\n        host = self._host\n        port = self._port\n\n        class IntermediaryServerHandler(BaseHTTPRequestHandler):\n            def __init__(self, rules=None, *args, **kwargs):\n                if rules is None:\n                    rules = []\n                self.rules = rules\n                BaseHTTPRequestHandler.__init__(self, *args, **kwargs)\n\n            def do_GET(self):\n                request_path = self.path\n                if \"?\" in request_path:\n                    request_path = request_path[0 : request_path.find(\"?\")]\n\n                for rule in self.rules:\n                    path, data, content_type = rule\n                    if request_path == path:\n                        self.send_response(200)\n                        if content_type:\n                            self.send_header(\"Content-Type\", content_type)\n                        self.end_headers()\n                        if isinstance(data, str):\n                            data = data.encode(\"utf-8\")\n                        self.wfile.write(data)\n                        break\n                else:\n                    self.send_response(404)\n                    self.wfile.write(b\"Not found\")\n\n        base_path = os.path.realpath(\n            os.path.join(os.path.dirname(__file__), \"..\", \"static\")\n        )\n        rules = [\n            (\n                \"/\",\n                [\n                    \"intermediary.html\",\n                ],\n                \"text/html\",\n            ),\n            (\"/favicon.ico\", [\"img\", \"tentacle-20x20.png\"], \"image/png\"),\n            (\n                \"/intermediary.gif\",\n                bytes(\n                    base64.b64decode(\n                        \"R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"\n                    )\n                ),\n                \"image/gif\",\n            ),\n        ]\n\n        def contents(args):\n            path = os.path.join(base_path, *args)\n            if not os.path.isfile(path):\n                return \"\"\n\n            with open(path, \"rb\") as f:\n                data = f.read()\n            return data\n\n        def process(rule):\n            if len(rule) == 2:\n                path, data = rule\n                content_type = None\n            else:\n                path, data, content_type = rule\n\n            if isinstance(data, (list, tuple)):\n                data = contents(data)\n\n            return path, data, content_type\n\n        rules = list(\n            map(process, filter(lambda rule: len(rule) == 2 or len(rule) == 3, rules))\n        )\n\n        HTTPServerV4 = HTTPServer\n\n        class HTTPServerV6(HTTPServer):\n            address_family = socket.AF_INET6\n\n        class HTTPServerV6SingleStack(HTTPServerV6):\n            def __init__(self, *args, **kwargs):\n                HTTPServerV6.__init__(self, *args, **kwargs)\n\n                # explicitly set V6ONLY flag - seems to be the default, but just to make sure...\n                self.socket.setsockopt(\n                    octoprint.util.net.IPPROTO_IPV6, octoprint.util.net.IPV6_V6ONLY, 1\n                )\n\n        class HTTPServerV6DualStack(HTTPServerV6):\n            def __init__(self, *args, **kwargs):\n                HTTPServerV6.__init__(self, *args, **kwargs)\n\n                # explicitly unset V6ONLY flag\n                self.socket.setsockopt(\n                    octoprint.util.net.IPPROTO_IPV6, octoprint.util.net.IPV6_V6ONLY, 0\n                )\n\n        if \":\" in host:\n            # v6\n            if host == \"::\" and not self._v6_only:\n                ServerClass = HTTPServerV6DualStack\n            else:\n                ServerClass = HTTPServerV6SingleStack\n        else:\n            # v4\n            ServerClass = HTTPServerV4\n\n        if host == \"::\":\n            if self._v6_only:\n                self._logger.debug(f\"Starting intermediary server on http://[::]:{port}\")\n            else:\n                self._logger.debug(\n                    \"Starting intermediary server on http://0.0.0.0:{port} and http://[::]:{port}\".format(\n                        port=port\n                    )\n                )\n        else:\n            self._logger.debug(\n                \"Starting intermediary server on http://{}:{}\".format(\n                    host if \":\" not in host else \"[\" + host + \"]\", port\n                )\n            )\n\n        self._intermediary_server = ServerClass(\n            (host, port),\n            lambda *args, **kwargs: IntermediaryServerHandler(rules, *args, **kwargs),\n            bind_and_activate=False,\n        )\n\n        # if possible, make sure our socket's port descriptor isn't handed over to subprocesses\n        from octoprint.util.platform import set_close_exec\n\n        try:\n            set_close_exec(self._intermediary_server.fileno())\n        except Exception:\n            self._logger.exception(\n                \"Error while attempting to set_close_exec on intermediary server socket\"\n            )\n\n        # then bind the server and have it serve our handler until stopped\n        try:\n            self._intermediary_server.server_bind()\n            self._intermediary_server.server_activate()\n        except Exception as exc:\n            self._intermediary_server.server_close()\n\n            if isinstance(exc, UnicodeDecodeError) and sys.platform == \"win32\":\n                # we end up here if the hostname contains non-ASCII characters due to\n                # https://bugs.python.org/issue26227 - tell the user they need\n                # to either change their hostname or read up other options in\n                # https://github.com/OctoPrint/OctoPrint/issues/3963\n                raise CannotStartServerException(\n                    \"OctoPrint cannot start due to a Python bug \"\n                    \"(https://bugs.python.org/issue26227). Your \"\n                    \"computer's host name contains non-ASCII characters. \"\n                    \"Please either change your computer's host name to \"\n                    \"contain only ASCII characters, or take a look at \"\n                    \"https://github.com/OctoPrint/OctoPrint/issues/3963 for \"\n                    \"other options.\"\n                )\n            else:\n                raise\n\n        def serve():\n            try:\n                self._intermediary_server.serve_forever()\n            except Exception:\n                self._logger.exception(\"Error in intermediary server\")\n\n        thread = threading.Thread(target=serve)\n        thread.daemon = True\n        thread.start()\n\n        self._logger.info(\"Intermediary server started\")\n\n    def _stop_intermediary_server(self):\n        if self._intermediary_server is None:\n            return\n        self._logger.info(\"Shutting down intermediary server...\")\n        self._intermediary_server.shutdown()\n        self._intermediary_server.server_close()\n        self._logger.info(\"Intermediary server shut down\")\n\n    def _setup_plugin_permissions(self):\n        global pluginManager\n\n        from octoprint.access.permissions import PluginOctoPrintPermission\n\n        key_whitelist = re.compile(r\"[A-Za-z0-9_]*\")\n\n        def permission_key(plugin, definition):\n            return \"PLUGIN_{}_{}\".format(plugin.upper(), definition[\"key\"].upper())\n\n        def permission_name(plugin, definition):\n            return \"{}: {}\".format(plugin, definition[\"name\"])\n\n        def permission_role(plugin, role):\n            return f\"plugin_{plugin}_{role}\"\n\n        def process_regular_permission(plugin_info, definition):\n            permissions = []\n            for key in definition.get(\"permissions\", []):\n                permission = octoprint.access.permissions.Permissions.find(key)\n\n                if permission is None:\n                    # if there is still no permission found, postpone this - maybe it is a permission from\n                    # another plugin that hasn't been loaded yet\n                    return False\n\n                permissions.append(permission)\n\n            roles = definition.get(\"roles\", [])\n            description = definition.get(\"description\", \"\")\n            dangerous = definition.get(\"dangerous\", False)\n            default_groups = definition.get(\"default_groups\", [])\n\n            roles_and_permissions = [\n                permission_role(plugin_info.key, role) for role in roles\n            ] + permissions\n\n            key = permission_key(plugin_info.key, definition)\n            permission = PluginOctoPrintPermission(\n                permission_name(plugin_info.name, definition),\n                description,\n                plugin=plugin_info.key,\n                dangerous=dangerous,\n                default_groups=default_groups,\n                *roles_and_permissions,\n            )\n            setattr(\n                octoprint.access.permissions.Permissions,\n                key,\n                PluginOctoPrintPermission(\n                    permission_name(plugin_info.name, definition),\n                    description,\n                    plugin=plugin_info.key,\n                    dangerous=dangerous,\n                    default_groups=default_groups,\n                    *roles_and_permissions,\n                ),\n            )\n\n            self._logger.info(\n                \"Added new permission from plugin {}: {} (needs: {!r})\".format(\n                    plugin_info.key, key, \", \".join(map(repr, permission.needs))\n                )\n            )\n            return True\n\n        postponed = []\n\n        hooks = pluginManager.get_hooks(\"octoprint.access.permissions\")\n        for name, factory in hooks.items():\n            try:\n                if isinstance(factory, (tuple, list)):\n                    additional_permissions = list(factory)\n                elif callable(factory):\n                    additional_permissions = factory()\n                else:\n                    raise ValueError(\"factory must be either a callable, tuple or list\")\n\n                if not isinstance(additional_permissions, (tuple, list)):\n                    raise ValueError(\n                        \"factory result must be either a tuple or a list of permission definition dicts\"\n                    )\n\n                plugin_info = pluginManager.get_plugin_info(name)\n                for p in additional_permissions:\n                    if not isinstance(p, dict):\n                        continue\n\n                    if \"key\" not in p or \"name\" not in p:\n                        continue\n\n                    if not key_whitelist.match(p[\"key\"]):\n                        self._logger.warning(\n                            \"Got permission with invalid key from plugin {}: {}\".format(\n                                name, p[\"key\"]\n                            )\n                        )\n                        continue\n\n                    if not process_regular_permission(plugin_info, p):\n                        postponed.append((plugin_info, p))\n            except Exception:\n                self._logger.exception(\n                    f\"Error while creating permission instance/s from {name}\"\n                )\n\n        # final resolution passes\n        pass_number = 1\n        still_postponed = []\n        while len(postponed):\n            start_length = len(postponed)\n            self._logger.debug(\n                \"Plugin permission resolution pass #{}, \"\n                \"{} unresolved permissions...\".format(pass_number, start_length)\n            )\n\n            for plugin_info, definition in postponed:\n                if not process_regular_permission(plugin_info, definition):\n                    still_postponed.append((plugin_info, definition))\n\n            self._logger.debug(\n                \"... pass #{} done, {} permissions left to resolve\".format(\n                    pass_number, len(still_postponed)\n                )\n            )\n\n            if len(still_postponed) == start_length:\n                # no change, looks like some stuff is unresolvable - let's bail\n                for plugin_info, definition in still_postponed:\n                    self._logger.warning(\n                        \"Unable to resolve permission from {}: {!r}\".format(\n                            plugin_info.key, definition\n                        )\n                    )\n                break\n\n            postponed = still_postponed\n            still_postponed = []\n            pass_number += 1\n\n\nclass LifecycleManager:\n    def __init__(self, plugin_manager):\n        self._plugin_manager = plugin_manager\n\n        self._plugin_lifecycle_callbacks = defaultdict(list)\n        self._logger = logging.getLogger(__name__)\n\n        def wrap_plugin_event(lifecycle_event, new_handler):\n            orig_handler = getattr(self._plugin_manager, \"on_plugin_\" + lifecycle_event)\n\n            def handler(*args, **kwargs):\n                if callable(orig_handler):\n                    orig_handler(*args, **kwargs)\n                if callable(new_handler):\n                    new_handler(*args, **kwargs)\n\n            return handler\n\n        def on_plugin_event_factory(lifecycle_event):\n            def on_plugin_event(name, plugin):\n                self.on_plugin_event(lifecycle_event, name, plugin)\n\n            return on_plugin_event\n\n        for event in (\"loaded\", \"unloaded\", \"enabled\", \"disabled\"):\n            wrap_plugin_event(event, on_plugin_event_factory(event))\n\n    def on_plugin_event(self, event, name, plugin):\n        for lifecycle_callback in self._plugin_lifecycle_callbacks[event]:\n            lifecycle_callback(name, plugin)\n\n    def add_callback(self, events, callback):\n        if isinstance(events, str):\n            events = [events]\n\n        for event in events:\n            self._plugin_lifecycle_callbacks[event].append(callback)\n\n    def remove_callback(self, callback, events=None):\n        if events is None:\n            for event in self._plugin_lifecycle_callbacks:\n                if callback in self._plugin_lifecycle_callbacks[event]:\n                    self._plugin_lifecycle_callbacks[event].remove(callback)\n        else:\n            if isinstance(events, str):\n                events = [events]\n\n            for event in events:\n                if callback in self._plugin_lifecycle_callbacks[event]:\n                    self._plugin_lifecycle_callbacks[event].remove(callback)\n\n\nclass CannotStartServerException(Exception):\n    pass\n", "__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"\n__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"\n__copyright__ = \"Copyright (C) 2014 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n\nimport logging\n\nfrom flask import (\n    Blueprint,\n    Response,\n    abort,\n    current_app,\n    g,\n    jsonify,\n    make_response,\n    request,\n    session,\n)\nfrom flask_login import current_user, login_user, logout_user\nfrom werkzeug.exceptions import HTTPException\n\nimport octoprint.access.users\nimport octoprint.plugin\nimport octoprint.server\nimport octoprint.util.net as util_net\nfrom octoprint.access.permissions import Permissions\nfrom octoprint.events import Events, eventManager\nfrom octoprint.server import NO_CONTENT\nfrom octoprint.server.util import (\n    corsRequestHandler,\n    corsResponseHandler,\n    loginFromApiKeyRequestHandler,\n    loginFromAuthorizationHeaderRequestHandler,\n    noCachingExceptGetResponseHandler,\n)\nfrom octoprint.server.util.flask import (\n    get_json_command_from_request,\n    get_remote_address,\n    limit,\n    no_firstrun_access,\n    passive_login,\n)\nfrom octoprint.settings import settings as s\nfrom octoprint.settings import valid_boolean_trues\nfrom octoprint.vendor.flask_principal import Identity, identity_changed\n\n# ~~ init api blueprint, including sub modules\n\napi = Blueprint(\"api\", __name__)\n\nfrom . import access as api_access  # noqa: F401,E402\nfrom . import connection as api_connection  # noqa: F401,E402\nfrom . import files as api_files  # noqa: F401,E402\nfrom . import job as api_job  # noqa: F401,E402\nfrom . import languages as api_languages  # noqa: F401,E402\nfrom . import printer as api_printer  # noqa: F401,E402\nfrom . import printer_profiles as api_printer_profiles  # noqa: F401,E402\nfrom . import settings as api_settings  # noqa: F401,E402\nfrom . import slicing as api_slicing  # noqa: F401,E402\nfrom . import system as api_system  # noqa: F401,E402\nfrom . import timelapse as api_timelapse  # noqa: F401,E402\nfrom . import users as api_users  # noqa: F401,E402\n\nVERSION = \"0.1\"\n\napi.after_request(noCachingExceptGetResponseHandler)\n\napi.before_request(corsRequestHandler)\napi.before_request(loginFromAuthorizationHeaderRequestHandler)\napi.before_request(loginFromApiKeyRequestHandler)\napi.after_request(corsResponseHandler)\n\n# ~~ data from plugins\n\n\n@api.route(\"/plugin/<string:name>\", methods=[\"GET\"])\ndef pluginData(name):\n    api_plugins = octoprint.plugin.plugin_manager().get_filtered_implementations(\n        lambda p: p._identifier == name, octoprint.plugin.SimpleApiPlugin\n    )\n    if not api_plugins:\n        abort(404)\n\n    if len(api_plugins) > 1:\n        abort(500, description=\"More than one api provider registered, can't proceed\")\n\n    try:\n        api_plugin = api_plugins[0]\n        if api_plugin.is_api_adminonly() and not current_user.is_admin:\n            abort(403)\n\n        response = api_plugin.on_api_get(request)\n\n        if response is not None:\n            message = (\n                \"Rewriting response from {} to use abort(msg, code) - please \"\n                \"consider upgrading the implementation accordingly\".format(name)\n            )\n            if (\n                isinstance(response, Response)\n                and response.mimetype == \"text/html\"\n                and response.status_code >= 300\n            ):\n                # this actually looks like an error response\n                logging.getLogger(__name__).info(message)\n                abort(response.status_code, description=response.data)\n            elif (\n                isinstance(response, tuple)\n                and len(response) == 2\n                and isinstance(response[0], (str, bytes))\n                and response[1] >= 300\n            ):\n                # this actually looks like an error response\n                logging.getLogger(__name__).info(message)\n                abort(response[1], response[0])\n            return response\n        return NO_CONTENT\n    except HTTPException:\n        raise\n    except Exception:\n        logging.getLogger(__name__).exception(\n            f\"Error calling SimpleApiPlugin {name}\", extra={\"plugin\": name}\n        )\n        return abort(500)\n\n\n# ~~ commands for plugins\n\n\n@api.route(\"/plugin/<string:name>\", methods=[\"POST\"])\n@no_firstrun_access\ndef pluginCommand(name):\n    api_plugins = octoprint.plugin.plugin_manager().get_filtered_implementations(\n        lambda p: p._identifier == name, octoprint.plugin.SimpleApiPlugin\n    )\n\n    if not api_plugins:\n        abort(400)\n\n    if len(api_plugins) > 1:\n        abort(500, description=\"More than one api provider registered, can't proceed\")\n\n    api_plugin = api_plugins[0]\n    try:\n        valid_commands = api_plugin.get_api_commands()\n        if valid_commands is None:\n            abort(405)\n\n        if api_plugin.is_api_adminonly() and not Permissions.ADMIN.can():\n            abort(403)\n\n        command, data, response = get_json_command_from_request(request, valid_commands)\n        if response is not None:\n            return response\n\n        response = api_plugin.on_api_command(command, data)\n        if response is not None:\n            return response\n        return NO_CONTENT\n    except HTTPException:\n        raise\n    except Exception:\n        logging.getLogger(__name__).exception(\n            f\"Error while executing SimpleApiPlugin {name}\",\n            extra={\"plugin\": name},\n        )\n        return abort(500)\n\n\n# ~~ first run setup\n\n\n@api.route(\"/setup/wizard\", methods=[\"GET\"])\ndef wizardState():\n    if (\n        not s().getBoolean([\"server\", \"firstRun\"])\n        and octoprint.server.userManager.has_been_customized()\n        and not Permissions.ADMIN.can()\n    ):\n        abort(403)\n\n    seen_wizards = s().get([\"server\", \"seenWizards\"])\n\n    result = {}\n    wizard_plugins = octoprint.server.pluginManager.get_implementations(\n        octoprint.plugin.WizardPlugin\n    )\n    for implementation in wizard_plugins:\n        name = implementation._identifier\n        try:\n            required = implementation.is_wizard_required()\n            details = implementation.get_wizard_details()\n            version = implementation.get_wizard_version()\n            ignored = octoprint.plugin.WizardPlugin.is_wizard_ignored(\n                seen_wizards, implementation\n            )\n        except Exception:\n            logging.getLogger(__name__).exception(\n                \"There was an error fetching wizard \"\n                \"details for {}, ignoring\".format(name),\n                extra={\"plugin\": name},\n            )\n        else:\n            result[name] = {\n                \"required\": required,\n                \"details\": details,\n                \"version\": version,\n                \"ignored\": ignored,\n            }\n\n    return jsonify(result)\n\n\n@api.route(\"/setup/wizard\", methods=[\"POST\"])\ndef wizardFinish():\n    if (\n        not s().getBoolean([\"server\", \"firstRun\"])\n        and octoprint.server.userManager.has_been_customized()\n        and not Permissions.ADMIN.can()\n    ):\n        abort(403)\n\n    data = {}\n    try:\n        data = request.get_json()\n    except Exception:\n        abort(400)\n\n    if data is None:\n        abort(400)\n\n    if \"handled\" not in data:\n        abort(400)\n    handled = data[\"handled\"]\n\n    if s().getBoolean([\"server\", \"firstRun\"]):\n        s().setBoolean([\"server\", \"firstRun\"], False)\n\n    seen_wizards = dict(s().get([\"server\", \"seenWizards\"]))\n\n    wizard_plugins = octoprint.server.pluginManager.get_implementations(\n        octoprint.plugin.WizardPlugin\n    )\n    for implementation in wizard_plugins:\n        name = implementation._identifier\n        try:\n            implementation.on_wizard_finish(name in handled)\n            if name in handled:\n                seen_wizards[name] = implementation.get_wizard_version()\n        except Exception:\n            logging.getLogger(__name__).exception(\n                \"There was an error finishing the \"\n                \"wizard for {}, ignoring\".format(name),\n                extra={\"plugin\": name},\n            )\n\n    s().set([\"server\", \"seenWizards\"], seen_wizards)\n    s().save()\n\n    return NO_CONTENT\n\n\n# ~~ system state\n\n\n@api.route(\"/version\", methods=[\"GET\"])\n@Permissions.STATUS.require(403)\ndef apiVersion():\n    return jsonify(\n        server=octoprint.server.VERSION,\n        api=VERSION,\n        text=f\"OctoPrint {octoprint.server.DISPLAY_VERSION}\",\n    )\n\n\n@api.route(\"/server\", methods=[\"GET\"])\n@Permissions.STATUS.require(403)\ndef serverStatus():\n    return jsonify(version=octoprint.server.VERSION, safemode=octoprint.server.safe_mode)\n\n\n# ~~ Login/user handling\n\n\n@api.route(\"/login\", methods=[\"POST\"])\n@limit(\n    \"3/minute;5/10 minutes;10/hour\",\n    deduct_when=lambda response: response.status_code == 403,\n    error_message=\"You have made too many failed login attempts. Please try again later.\",\n)\ndef login():\n    data = request.get_json()\n    if not data:\n        data = request.values\n\n    if \"user\" in data and \"pass\" in data:\n        username = data[\"user\"]\n        password = data[\"pass\"]\n\n        if \"remember\" in data and data[\"remember\"] in valid_boolean_trues:\n            remember = True\n        else:\n            remember = False\n\n        if \"usersession.id\" in session:\n            _logout(current_user)\n\n        user = octoprint.server.userManager.find_user(username)\n        if user is not None:\n            if octoprint.server.userManager.check_password(username, password):\n                if not user.is_active:\n                    abort(403)\n\n                user = octoprint.server.userManager.login_user(user)\n                session[\"usersession.id\"] = user.session\n                g.user = user\n\n                login_user(user, remember=remember)\n                identity_changed.send(\n                    current_app._get_current_object(), identity=Identity(user.get_id())\n                )\n                session[\"login_mechanism\"] = \"http\"\n\n                remote_addr = get_remote_address(request)\n                logging.getLogger(__name__).info(\n                    \"Actively logging in user {} from {}\".format(\n                        user.get_id(), remote_addr\n                    )\n                )\n\n                response = user.as_dict()\n                response[\"_is_external_client\"] = s().getBoolean(\n                    [\"server\", \"ipCheck\", \"enabled\"]\n                ) and not util_net.is_lan_address(\n                    remote_addr,\n                    additional_private=s().get([\"server\", \"ipCheck\", \"trustedSubnets\"]),\n                )\n                response[\"_login_mechanism\"] = session[\"login_mechanism\"]\n\n                r = make_response(jsonify(response))\n                r.delete_cookie(\"active_logout\")\n\n                eventManager().fire(\n                    Events.USER_LOGGED_IN, payload={\"username\": user.get_id()}\n                )\n\n                return r\n\n        abort(403)\n\n    elif \"passive\" in data:\n        return passive_login()\n\n    abort(400, description=\"Neither user and pass attributes nor passive flag present\")\n\n\n@api.route(\"/logout\", methods=[\"POST\"])\ndef logout():\n    username = None\n    if current_user:\n        username = current_user.get_id()\n\n    # logout from user manager...\n    _logout(current_user)\n\n    # ... and from flask login (and principal)\n    logout_user()\n\n    # ... and send an active logout session cookie\n    r = make_response(jsonify(octoprint.server.userManager.anonymous_user_factory()))\n    r.set_cookie(\"active_logout\", \"true\")\n\n    if username:\n        eventManager().fire(Events.USER_LOGGED_OUT, payload={\"username\": username})\n\n    return r\n\n\ndef _logout(user):\n    if \"usersession.id\" in session:\n        del session[\"usersession.id\"]\n    if \"login_mechanism\" in session:\n        del session[\"login_mechanism\"]\n    octoprint.server.userManager.logout_user(user)\n\n\n@api.route(\"/currentuser\", methods=[\"GET\"])\ndef get_current_user():\n    return jsonify(\n        name=current_user.get_name(),\n        permissions=[permission.key for permission in current_user.effective_permissions],\n        groups=[group.key for group in current_user.groups],\n    )\n\n\n# ~~ Test utils\n\n\n@api.route(\"/util/test\", methods=[\"POST\"])\n@no_firstrun_access\n@Permissions.ADMIN.require(403)\ndef utilTest():\n    valid_commands = {\n        \"path\": [\"path\"],\n        \"url\": [\"url\"],\n        \"server\": [\"host\", \"port\"],\n        \"resolution\": [\"name\"],\n        \"address\": [],\n    }\n\n    command, data, response = get_json_command_from_request(request, valid_commands)\n    if response is not None:\n        return response\n\n    if command == \"path\":\n        return _test_path(data)\n    elif command == \"url\":\n        return _test_url(data)\n    elif command == \"server\":\n        return _test_server(data)\n    elif command == \"resolution\":\n        return _test_resolution(data)\n    elif command == \"address\":\n        return _test_address(data)\n\n\ndef _test_path(data):\n    import os\n\n    from octoprint.util.paths import normalize\n\n    path = normalize(data[\"path\"], real=False)\n    if not path:\n        return jsonify(\n            path=path,\n            exists=False,\n            typeok=False,\n            broken_symlink=False,\n            access=False,\n            result=False,\n        )\n\n    unreal_path = path\n    path = os.path.realpath(path)\n\n    check_type = None\n    check_access = []\n\n    if \"check_type\" in data and data[\"check_type\"] in (\"file\", \"dir\"):\n        check_type = data[\"check_type\"]\n\n    if \"check_access\" in data:\n        request_check_access = data[\"check_access\"]\n        if not isinstance(request_check_access, list):\n            request_check_access = list(request_check_access)\n\n        check_access = [\n            check for check in request_check_access if check in (\"r\", \"w\", \"x\")\n        ]\n\n    allow_create_dir = data.get(\"allow_create_dir\", False) and check_type == \"dir\"\n    check_writable_dir = data.get(\"check_writable_dir\", False) and check_type == \"dir\"\n    if check_writable_dir and \"w\" not in check_access:\n        check_access.append(\"w\")\n\n    # check if path exists\n    exists = os.path.exists(path)\n    if not exists:\n        if os.path.islink(unreal_path):\n            # broken symlink, see #2644\n            logging.getLogger(__name__).error(\n                \"{} is a broken symlink pointing at non existing {}\".format(\n                    unreal_path, path\n                )\n            )\n            return jsonify(\n                path=unreal_path,\n                exists=False,\n                typeok=False,\n                broken_symlink=True,\n                access=False,\n                result=False,\n            )\n\n        elif check_type == \"dir\" and allow_create_dir:\n            try:\n                os.makedirs(path)\n            except Exception:\n                logging.getLogger(__name__).exception(\n                    f\"Error while trying to create {path}\"\n                )\n                return jsonify(\n                    path=path,\n                    exists=False,\n                    typeok=False,\n                    broken_symlink=False,\n                    access=False,\n                    result=False,\n                )\n            else:\n                exists = True\n\n    # check path type\n    type_mapping = {\"file\": os.path.isfile, \"dir\": os.path.isdir}\n    if check_type:\n        typeok = type_mapping[check_type](path)\n    else:\n        typeok = exists\n\n    # check if path allows requested access\n    access_mapping = {\"r\": os.R_OK, \"w\": os.W_OK, \"x\": os.X_OK}\n    if check_access:\n        mode = 0\n        for a in map(lambda x: access_mapping[x], check_access):\n            mode |= a\n        access = os.access(path, mode)\n    else:\n        access = exists\n\n    if check_writable_dir and check_type == \"dir\":\n        try:\n            test_path = os.path.join(path, \".testballoon.txt\")\n            with open(test_path, \"wb\") as f:\n                f.write(b\"Test\")\n            os.remove(test_path)\n        except Exception:\n            logging.getLogger(__name__).exception(\n                f\"Error while testing if {path} is really writable\"\n            )\n            return jsonify(\n                path=path,\n                exists=exists,\n                typeok=typeok,\n                broken_symlink=False,\n                access=False,\n                result=False,\n            )\n\n    return jsonify(\n        path=path,\n        exists=exists,\n        typeok=typeok,\n        broken_symlink=False,\n        access=access,\n        result=exists and typeok and access,\n    )\n\n\ndef _test_url(data):\n    import requests\n\n    from octoprint import util as util\n\n    class StatusCodeRange:\n        def __init__(self, start=None, end=None):\n            self.start = start\n            self.end = end\n\n        def __contains__(self, item):\n            if not isinstance(item, int):\n                return False\n            if self.start and self.end:\n                return self.start <= item < self.end\n            elif self.start:\n                return self.start <= item\n            elif self.end:\n                return item < self.end\n            else:\n                return False\n\n        def as_dict(self):\n            return {\"start\": self.start, \"end\": self.end}\n\n    status_ranges = {\n        \"informational\": StatusCodeRange(start=100, end=200),\n        \"success\": StatusCodeRange(start=200, end=300),\n        \"redirection\": StatusCodeRange(start=300, end=400),\n        \"client_error\": StatusCodeRange(start=400, end=500),\n        \"server_error\": StatusCodeRange(start=500, end=600),\n        \"normal\": StatusCodeRange(end=400),\n        \"error\": StatusCodeRange(start=400, end=600),\n        \"any\": StatusCodeRange(start=100),\n        \"timeout\": StatusCodeRange(start=0, end=1),\n    }\n\n    url = data[\"url\"]\n    method = data.get(\"method\", \"HEAD\")\n    timeout = 3.0\n    valid_ssl = True\n    check_status = [status_ranges[\"normal\"]]\n    content_type_whitelist = None\n    content_type_blacklist = None\n\n    if \"timeout\" in data:\n        try:\n            timeout = float(data[\"timeout\"])\n        except Exception:\n            abort(400, description=\"timeout is invalid\")\n\n    if \"validSsl\" in data:\n        valid_ssl = data[\"validSsl\"] in valid_boolean_trues\n\n    if \"status\" in data:\n        request_status = data[\"status\"]\n        if not isinstance(request_status, list):\n            request_status = [request_status]\n\n        check_status = []\n        for rs in request_status:\n            if isinstance(rs, int):\n                check_status.append([rs])\n            else:\n                if rs in status_ranges:\n                    check_status.append(status_ranges[rs])\n                else:\n                    code = requests.codes[rs]\n                    if code is not None:\n                        check_status.append([code])\n\n    if \"content_type_whitelist\" in data:\n        if not isinstance(data[\"content_type_whitelist\"], (list, tuple)):\n            abort(400, description=\"content_type_whitelist must be a list of mime types\")\n        content_type_whitelist = list(\n            map(util.parse_mime_type, data[\"content_type_whitelist\"])\n        )\n    if \"content_type_blacklist\" in data:\n        if not isinstance(data[\"content_type_whitelist\"], (list, tuple)):\n            abort(400, description=\"content_type_blacklist must be a list of mime types\")\n        content_type_blacklist = list(\n            map(util.parse_mime_type, data[\"content_type_blacklist\"])\n        )\n\n    response_result = None\n    outcome = True\n    status = 0\n    try:\n        with requests.request(\n            method=method, url=url, timeout=timeout, verify=valid_ssl, stream=True\n        ) as response:\n            status = response.status_code\n            outcome = outcome and any(map(lambda x: status in x, check_status))\n            content_type = response.headers.get(\"content-type\")\n\n            response_result = {\n                \"headers\": dict(response.headers),\n                \"content_type\": content_type,\n            }\n\n            if not content_type and data.get(\"content_type_guess\") in valid_boolean_trues:\n                content = response.content\n                content_type = util.guess_mime_type(bytearray(content))\n\n            if not content_type:\n                content_type = \"application/octet-stream\"\n\n            response_result = {\"assumed_content_type\": content_type}\n\n            parsed_content_type = util.parse_mime_type(content_type)\n\n            in_whitelist = content_type_whitelist is None or any(\n                map(\n                    lambda x: util.mime_type_matches(parsed_content_type, x),\n                    content_type_whitelist,\n                )\n            )\n            in_blacklist = content_type_blacklist is not None and any(\n                map(\n                    lambda x: util.mime_type_matches(parsed_content_type, x),\n                    content_type_blacklist,\n                )\n            )\n\n            if not in_whitelist or in_blacklist:\n                # we don't support this content type\n                response.close()\n                outcome = False\n\n            elif \"response\" in data and (\n                data[\"response\"] in valid_boolean_trues\n                or data[\"response\"] in (\"json\", \"bytes\")\n            ):\n                if data[\"response\"] == \"json\":\n                    content = response.json()\n\n                else:\n                    import base64\n\n                    content = base64.standard_b64encode(response.content)\n\n                response_result[\"content\"] = content\n    except Exception:\n        logging.getLogger(__name__).exception(\n            f\"Error while running a test {method} request on {url}\"\n        )\n        outcome = False\n\n    result = {\"url\": url, \"status\": status, \"result\": outcome}\n    if response_result:\n        result[\"response\"] = response_result\n\n    return jsonify(**result)\n\n\ndef _test_server(data):\n    host = data[\"host\"]\n    try:\n        port = int(data[\"port\"])\n    except Exception:\n        abort(400, description=\"Invalid value for port\")\n\n    timeout = 3.05\n    if \"timeout\" in data:\n        try:\n            timeout = float(data[\"timeout\"])\n        except Exception:\n            abort(400, description=\"Invalid value for timeout\")\n\n    protocol = data.get(\"protocol\", \"tcp\")\n    if protocol not in (\"tcp\", \"udp\"):\n        abort(400, description=\"Invalid value for protocol\")\n\n    from octoprint.util import server_reachable\n\n    reachable = server_reachable(host, port, timeout=timeout, proto=protocol)\n\n    result = {\"host\": host, \"port\": port, \"protocol\": protocol, \"result\": reachable}\n\n    return jsonify(**result)\n\n\ndef _test_resolution(data):\n    name = data[\"name\"]\n\n    from octoprint.util.net import resolve_host\n\n    resolvable = len(resolve_host(name)) > 0\n\n    result = {\"name\": name, \"result\": resolvable}\n\n    return jsonify(**result)\n\n\ndef _test_address(data):\n    import netaddr\n\n    from octoprint.util.net import get_lan_ranges, sanitize_address\n\n    remote_addr = data.get(\"address\")\n    if not remote_addr:\n        remote_addr = get_remote_address(request)\n\n    remote_addr = sanitize_address(remote_addr)\n    ip = netaddr.IPAddress(remote_addr)\n\n    lan_subnets = get_lan_ranges()\n\n    detected_subnet = None\n    for subnet in lan_subnets:\n        if ip in subnet:\n            detected_subnet = subnet\n            break\n\n    result = {\n        \"is_lan_address\": detected_subnet is not None,\n        \"address\": remote_addr,\n    }\n\n    if detected_subnet is not None:\n        result[\"subnet\"] = str(detected_subnet)\n\n    return jsonify(**result)\n", "from flask import make_response\n\n__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"\n__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"\n__copyright__ = \"Copyright (C) 2014 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n\nimport functools\nimport logging\nimport os\nimport threading\nimport time\nfrom datetime import datetime\nfrom typing import Union\n\nimport flask\nimport flask.json\nimport flask.sessions\nimport flask.templating\nimport flask_assets\nimport flask_login\nimport netaddr\nimport tornado.web\nimport webassets.updater\nimport webassets.utils\nfrom cachelib import BaseCache\nfrom werkzeug.local import LocalProxy\nfrom werkzeug.utils import cached_property\n\nimport octoprint.access.users\nimport octoprint.plugin\nimport octoprint.server\nimport octoprint.vendor.flask_principal as flask_principal\nfrom octoprint.events import Events, eventManager\nfrom octoprint.settings import settings\nfrom octoprint.util import DefaultOrderedDict, deprecated, yaml\nfrom octoprint.util.json import JsonEncoding\nfrom octoprint.util.net import is_lan_address\nfrom octoprint.util.tz import UTC_TZ, is_timezone_aware\n\n# ~~ monkey patching\n\n\ndef enable_additional_translations(default_locale=\"en\", additional_folders=None):\n    import os\n\n    import flask_babel\n    from babel import Locale, support\n    from flask import _request_ctx_stack\n\n    if additional_folders is None:\n        additional_folders = []\n\n    logger = logging.getLogger(__name__)\n\n    def fixed_list_translations(self):\n        \"\"\"Returns a list of all the locales translations exist for.  The\n        list returned will be filled with actual locale objects and not just\n        strings.\n        \"\"\"\n\n        def list_translations(dirname):\n            if not os.path.isdir(dirname):\n                return []\n            result = []\n            for entry in os.scandir(dirname):\n                locale_dir = os.path.join(entry.path, \"LC_MESSAGES\")\n                if not os.path.isdir(locale_dir):\n                    continue\n                if any(filter(lambda x: x.name.endswith(\".mo\"), os.scandir(locale_dir))):\n                    result.append(Locale.parse(entry.name))\n            return result\n\n        dirs = additional_folders + [os.path.join(self.app.root_path, \"translations\")]\n\n        # translations from plugins\n        plugins = octoprint.plugin.plugin_manager().enabled_plugins\n        for plugin in plugins.values():\n            plugin_translation_dir = os.path.join(plugin.location, \"translations\")\n            if not os.path.isdir(plugin_translation_dir):\n                continue\n            dirs.append(plugin_translation_dir)\n\n        result = [Locale.parse(default_locale)]\n\n        for dir in dirs:\n            result += list_translations(dir)\n        return result\n\n    def fixed_get_translations():\n        \"\"\"Returns the correct gettext translations that should be used for\n        this request.  This will never fail and return a dummy translation\n        object if used outside of the request or if a translation cannot be\n        found.\n        \"\"\"\n        ctx = _request_ctx_stack.top\n        if ctx is None:\n            return None\n        translations = getattr(ctx, \"babel_translations\", None)\n        if translations is None:\n            locale = flask_babel.get_locale()\n            translations = support.Translations()\n\n            if str(locale) != default_locale:\n                # plugin translations\n                plugins = octoprint.plugin.plugin_manager().enabled_plugins\n                for name, plugin in plugins.items():\n                    dirs = list(\n                        map(\n                            lambda x: os.path.join(x, \"_plugins\", name),\n                            additional_folders,\n                        )\n                    ) + [os.path.join(plugin.location, \"translations\")]\n                    for dirname in dirs:\n                        if not os.path.isdir(dirname):\n                            continue\n\n                        try:\n                            plugin_translations = support.Translations.load(\n                                dirname, [locale]\n                            )\n                        except Exception:\n                            logger.exception(\n                                f\"Error while trying to load translations \"\n                                f\"for plugin {name}\"\n                            )\n                        else:\n                            if isinstance(plugin_translations, support.Translations):\n                                translations = translations.merge(plugin_translations)\n                                logger.debug(\n                                    f\"Using translation plugin folder {dirname} from \"\n                                    f\"plugin {name} for locale {locale}\"\n                                )\n                                break\n                    else:\n                        logger.debug(\n                            f\"No translations for locale {locale} \" f\"from plugin {name}\"\n                        )\n\n                # core translations\n                dirs = additional_folders + [\n                    os.path.join(ctx.app.root_path, \"translations\")\n                ]\n                for dirname in dirs:\n                    core_translations = support.Translations.load(dirname, [locale])\n                    if isinstance(core_translations, support.Translations):\n                        logger.debug(\n                            f\"Using translation core folder {dirname} \"\n                            f\"for locale {locale}\"\n                        )\n                        break\n                else:\n                    logger.debug(f\"No translations for locale {locale} in core folders\")\n                translations = translations.merge(core_translations)\n\n            ctx.babel_translations = translations\n        return translations\n\n    flask_babel.Babel.list_translations = fixed_list_translations\n    flask_babel.get_translations = fixed_get_translations\n\n\ndef fix_webassets_filtertool():\n    from webassets.merge import FilterTool, MemoryHunk, log\n\n    error_logger = logging.getLogger(__name__ + \".fix_webassets_filtertool\")\n\n    def fixed_wrap_cache(self, key, func):\n        \"\"\"Return cache value ``key``, or run ``func``.\"\"\"\n        if self.cache:\n            if not self.no_cache_read:\n                log.debug(\"Checking cache for key %s\", key)\n                content = self.cache.get(key)\n                if content not in (False, None):\n                    log.debug(\"Using cached result for %s\", key)\n                    return MemoryHunk(content)\n\n        try:\n            content = func().getvalue()\n            if self.cache:\n                try:\n                    log.debug(\n                        \"Storing result in cache with key %s\",\n                        key,\n                    )\n                    self.cache.set(key, content)\n                except Exception:\n                    error_logger.exception(\n                        \"Got an exception while trying to save file to cache, not caching\"\n                    )\n            return MemoryHunk(content)\n        except Exception:\n            error_logger.exception(\n                \"Got an exception while trying to apply filter, ignoring file\"\n            )\n            return MemoryHunk(\"\")\n\n    FilterTool._wrap_cache = fixed_wrap_cache\n\n\ndef fix_flask_jsonify():\n    def fixed_jsonify(*args, **kwargs):\n        \"\"\"Backported from https://github.com/pallets/flask/blob/7e714bd28b6e96d82b2848b48cf8ff48b517b09b/flask/json/__init__.py#L257\"\"\"\n        from flask.json import current_app, dumps\n\n        indent = None\n        separators = (\",\", \":\")\n\n        if current_app.config[\"JSONIFY_PRETTYPRINT_REGULAR\"] or current_app.debug:\n            indent = 2\n            separators = (\", \", \": \")\n\n        if args and kwargs:\n            raise TypeError(\n                \"jsonify() behavior undefined when passed both args and kwargs\"\n            )\n        elif len(args) == 1:  # single args are passed directly to dumps()\n            data = args[0]\n        else:\n            data = args or kwargs\n\n        return current_app.response_class(\n            dumps(data, indent=indent, separators=separators, allow_nan=False) + \"\\n\",\n            mimetype=\"application/json\",\n        )\n\n    flask.jsonify = fixed_jsonify\n\n\n# ~~ WSGI environment wrapper for reverse proxying\n\n\nclass ReverseProxiedEnvironment:\n    @staticmethod\n    def to_header_candidates(values):\n        if values is None:\n            return []\n        if not isinstance(values, (list, tuple)):\n            values = [values]\n        to_wsgi_format = lambda header: \"HTTP_\" + header.upper().replace(\"-\", \"_\")\n        return list(map(to_wsgi_format, values))\n\n    @staticmethod\n    def valid_ip(address):\n        import netaddr\n\n        try:\n            netaddr.IPAddress(address)\n            return True\n        except Exception:\n            return False\n\n    def __init__(\n        self,\n        header_prefix=None,\n        header_scheme=None,\n        header_host=None,\n        header_server=None,\n        header_port=None,\n        prefix=None,\n        scheme=None,\n        host=None,\n        server=None,\n        port=None,\n    ):\n\n        # sensible defaults\n        if header_prefix is None:\n            header_prefix = [\"x-script-name\"]\n        if header_scheme is None:\n            header_scheme = [\"x-forwarded-proto\", \"x-scheme\"]\n        if header_host is None:\n            header_host = [\"x-forwarded-host\"]\n        if header_server is None:\n            header_server = [\"x-forwarded-server\"]\n        if header_port is None:\n            header_port = [\"x-forwarded-port\"]\n\n        # header candidates\n        self._headers_prefix = self.to_header_candidates(header_prefix)\n        self._headers_scheme = self.to_header_candidates(header_scheme)\n        self._headers_host = self.to_header_candidates(header_host)\n        self._headers_server = self.to_header_candidates(header_server)\n        self._headers_port = self.to_header_candidates(header_port)\n\n        # fallback prefix & scheme & host from config\n        self._fallback_prefix = prefix\n        self._fallback_scheme = scheme\n        self._fallback_host = host\n        self._fallback_server = server\n        self._fallback_port = port\n\n    def __call__(self, environ):\n        def retrieve_header(header_type):\n            candidates = getattr(self, \"_headers_\" + header_type, [])\n            fallback = getattr(self, \"_fallback_\" + header_type, None)\n\n            for candidate in candidates:\n                value = environ.get(candidate, None)\n                if value is not None:\n                    return value\n            else:\n                return fallback\n\n        def host_to_server_and_port(host, scheme):\n            if host is None:\n                return None, None\n\n            default_port = \"443\" if scheme == \"https\" else \"80\"\n            host = host.strip()\n\n            if \":\" in host:\n                # we might have an ipv6 address here, or a port, or both\n\n                if host[0] == \"[\":\n                    # that looks like an ipv6 address with port, e.g. [fec1::1]:80\n                    address_end = host.find(\"]\")\n                    if address_end == -1:\n                        # no ], that looks like a seriously broken address\n                        return None, None\n\n                    # extract server ip, skip enclosing [ and ]\n                    server = host[1:address_end]\n                    tail = host[address_end + 1 :]\n\n                    # now check if there's also a port\n                    if len(tail) and tail[0] == \":\":\n                        # port included as well\n                        port = tail[1:]\n                    else:\n                        # no port, use default one\n                        port = default_port\n\n                elif self.__class__.valid_ip(host):\n                    # ipv6 address without port\n                    server = host\n                    port = default_port\n\n                else:\n                    # ipv4 address with port\n                    server, port = host.rsplit(\":\", 1)\n\n            else:\n                server = host\n                port = default_port\n\n            return server, port\n\n        # determine prefix\n        prefix = retrieve_header(\"prefix\")\n        if prefix is not None:\n            environ[\"SCRIPT_NAME\"] = prefix\n            path_info = environ[\"PATH_INFO\"]\n            if path_info.startswith(prefix):\n                environ[\"PATH_INFO\"] = path_info[len(prefix) :]\n\n        # determine scheme\n        scheme = retrieve_header(\"scheme\")\n        if scheme is not None and \",\" in scheme:\n            # Scheme might be something like \"https,https\" if doubly-reverse-proxied\n            # without stripping original scheme header first, make sure to only use\n            # the first entry in such a case. See #1391.\n            scheme, _ = map(lambda x: x.strip(), scheme.split(\",\", 1))\n        if scheme is not None:\n            environ[\"wsgi.url_scheme\"] = scheme\n\n        # determine host\n        url_scheme = environ[\"wsgi.url_scheme\"]\n        host = retrieve_header(\"host\")\n        if host is not None:\n            # if we have a host, we take server_name and server_port from it\n            server, port = host_to_server_and_port(host, url_scheme)\n            environ[\"HTTP_HOST\"] = host\n            environ[\"SERVER_NAME\"] = server\n            environ[\"SERVER_PORT\"] = port\n\n        elif environ.get(\"HTTP_HOST\", None) is not None:\n            # if we have a Host header, we use that and make sure our server name and port properties match it\n            host = environ[\"HTTP_HOST\"]\n            server, port = host_to_server_and_port(host, url_scheme)\n            environ[\"SERVER_NAME\"] = server\n            environ[\"SERVER_PORT\"] = port\n\n        else:\n            # else we take a look at the server and port headers and if we have\n            # something there we derive the host from it\n\n            # determine server - should usually not be used\n            server = retrieve_header(\"server\")\n            if server is not None:\n                environ[\"SERVER_NAME\"] = server\n\n            # determine port - should usually not be used\n            port = retrieve_header(\"port\")\n            if port is not None:\n                environ[\"SERVER_PORT\"] = port\n\n            # reconstruct host header\n            if (\n                url_scheme == \"http\"\n                and environ[\"SERVER_PORT\"] == \"80\"\n                or url_scheme == \"https\"\n                and environ[\"SERVER_PORT\"] == \"443\"\n            ):\n                # default port for scheme, can be skipped\n                environ[\"HTTP_HOST\"] = environ[\"SERVER_NAME\"]\n            else:\n                server_name_component = environ[\"SERVER_NAME\"]\n                if \":\" in server_name_component and self.__class__.valid_ip(\n                    server_name_component\n                ):\n                    # this is an ipv6 address, we need to wrap that in [ and ] before appending the port\n                    server_name_component = \"[\" + server_name_component + \"]\"\n\n                environ[\"HTTP_HOST\"] = (\n                    server_name_component + \":\" + environ[\"SERVER_PORT\"]\n                )\n\n        # call wrapped app with rewritten environment\n        return environ\n\n\n# ~~ request and response versions\n\n\nclass OctoPrintFlaskRequest(flask.Request):\n    environment_wrapper = staticmethod(lambda x: x)\n\n    def __init__(self, environ, *args, **kwargs):\n        # apply environment wrapper to provided WSGI environment\n        flask.Request.__init__(self, self.environment_wrapper(environ), *args, **kwargs)\n\n    @cached_property\n    def cookies(self):\n        # strip cookie_suffix from all cookies in the request, return result\n        cookies = flask.Request.cookies.__get__(self)\n\n        result = {}\n        desuffixed = {}\n        for key, value in cookies.items():\n            if key.endswith(self.cookie_suffix):\n                desuffixed[key[: -len(self.cookie_suffix)]] = value\n            else:\n                result[key] = value\n\n        result.update(desuffixed)\n        return result\n\n    @cached_property\n    def server_name(self):\n        \"\"\"Short cut to the request's server name header\"\"\"\n        return self.environ.get(\"SERVER_NAME\")\n\n    @cached_property\n    def server_port(self):\n        \"\"\"Short cut to the request's server port header\"\"\"\n        return self.environ.get(\"SERVER_PORT\")\n\n    @cached_property\n    def cookie_suffix(self):\n        \"\"\"\n        Request specific suffix for set and read cookies\n\n        We need this because cookies are not port-specific and we don't want to overwrite our\n        session and other cookies from one OctoPrint instance on our machine with those of another\n        one who happens to listen on the same address albeit a different port or script root.\n        \"\"\"\n        result = \"_P\" + self.server_port\n        if self.script_root:\n            return result + \"_R\" + self.script_root.replace(\"/\", \"|\")\n        return result\n\n\nclass OctoPrintFlaskResponse(flask.Response):\n    def set_cookie(self, key, *args, **kwargs):\n        # restrict cookie path to script root\n        kwargs[\"path\"] = flask.request.script_root + kwargs.get(\"path\", \"/\")\n\n        # set same-site header\n        samesite = settings().get([\"server\", \"cookies\", \"samesite\"])\n        if samesite is not None:\n            samesite = samesite.lower()\n        if samesite == \"none\":\n            # Must be string \"None\"\n            samesite = \"None\"\n        if samesite not in (\"None\", \"strict\", \"lax\"):\n            # If NoneType, the cookie is not set\n            samesite = None\n        kwargs[\"samesite\"] = samesite\n\n        # set secure if necessary\n        kwargs[\"secure\"] = settings().getBoolean([\"server\", \"cookies\", \"secure\"])\n\n        # add request specific cookie suffix to name\n        flask.Response.set_cookie(\n            self, key + flask.request.cookie_suffix, *args, **kwargs\n        )\n\n    def delete_cookie(self, key, path=\"/\", domain=None):\n        flask.Response.delete_cookie(self, key, path=path, domain=domain)\n\n        # we also still might have a cookie left over from before we started prefixing, delete that manually\n        # without any pre processing (no path prefix, no key suffix)\n        flask.Response.set_cookie(\n            self, key, expires=0, max_age=0, path=path, domain=domain\n        )\n\n\nclass OctoPrintSessionInterface(flask.sessions.SecureCookieSessionInterface):\n    def should_set_cookie(self, app, session):\n        return flask.request.endpoint != \"static\"\n\n    def save_session(self, app, session, response):\n        if flask.g.get(\"login_via_apikey\", False):\n            return\n        return super().save_session(app, session, response)\n\n\n# ~~ jinja environment\n\n\nclass PrefixAwareJinjaEnvironment(flask.templating.Environment):\n    def __init__(self, *args, **kwargs):\n        flask.templating.Environment.__init__(self, *args, **kwargs)\n        self.prefix_loader = None\n        self._cached_templates = {}\n\n    def join_path(self, template, parent):\n        if parent and \"/\" in parent:\n            prefix, _ = parent.split(\"/\", 1)\n            if template in self._templates_for_prefix(prefix) and not template.startswith(\n                prefix + \"/\"\n            ):\n                return prefix + \"/\" + template\n\n        return template\n\n    def _templates_for_prefix(self, prefix):\n        if prefix in self._cached_templates:\n            return self._cached_templates[prefix]\n\n        templates = []\n        if prefix in self.prefix_loader.mapping:\n            templates = self.prefix_loader.mapping[prefix].list_templates()\n        self._cached_templates[prefix] = templates\n        return templates\n\n\n# ~~ passive login helper\n\n_cached_local_networks = None\n\n\ndef _local_networks():\n    global _cached_local_networks\n\n    if _cached_local_networks is None:\n        logger = logging.getLogger(__name__)\n        local_networks = netaddr.IPSet([])\n        for entry in settings().get([\"accessControl\", \"localNetworks\"]):\n            try:\n                network = netaddr.IPNetwork(entry)\n            except Exception:\n                logger.warning(\n                    \"Invalid network definition configured in localNetworks: {}\".format(\n                        entry\n                    )\n                )\n                continue\n\n            local_networks.add(network)\n            logger.debug(f\"Added network {network} to localNetworks\")\n\n            if network.version == 4:\n                network_v6 = network.ipv6()\n                local_networks.add(network_v6)\n                logger.debug(\n                    \"Also added v6 representation of v4 network {} = {} to localNetworks\".format(\n                        network, network_v6\n                    )\n                )\n\n        _cached_local_networks = local_networks\n\n    return _cached_local_networks\n\n\ndef passive_login():\n    logger = logging.getLogger(__name__)\n\n    user = flask_login.current_user\n\n    remote_address = get_remote_address(flask.request)\n    ip_check_enabled = settings().getBoolean([\"server\", \"ipCheck\", \"enabled\"])\n    ip_check_trusted = settings().get([\"server\", \"ipCheck\", \"trustedSubnets\"])\n\n    if isinstance(user, LocalProxy):\n        # noinspection PyProtectedMember\n        user = user._get_current_object()\n\n    def login(u):\n        # login known user\n        if not u.is_anonymous:\n            u = octoprint.server.userManager.login_user(u)\n        flask_login.login_user(u)\n        flask_principal.identity_changed.send(\n            flask.current_app._get_current_object(),\n            identity=flask_principal.Identity(u.get_id()),\n        )\n        if hasattr(u, \"session\"):\n            flask.session[\"usersession.id\"] = u.session\n        flask.g.user = u\n\n        eventManager().fire(Events.USER_LOGGED_IN, payload={\"username\": u.get_id()})\n\n        return u\n\n    def determine_user(u):\n        if not u.is_anonymous and u.is_active:\n            # known active user\n            logger.info(f\"Passively logging in user {u.get_id()} from {remote_address}\")\n\n        elif (\n            settings().getBoolean([\"accessControl\", \"autologinLocal\"])\n            and settings().get([\"accessControl\", \"autologinAs\"]) is not None\n            and settings().get([\"accessControl\", \"localNetworks\"]) is not None\n            and \"active_logout\" not in flask.request.cookies\n            and remote_address\n        ):\n            # attempt local autologin\n            autologin_as = settings().get([\"accessControl\", \"autologinAs\"])\n            local_networks = _local_networks()\n            logger.debug(\n                \"Checking if remote address {} is in localNetworks ({!r})\".format(\n                    remote_address, local_networks\n                )\n            )\n\n            try:\n                if netaddr.IPAddress(remote_address) in local_networks:\n                    autologin_user = octoprint.server.userManager.find_user(autologin_as)\n                    if autologin_user is not None and autologin_user.is_active:\n                        logger.info(\n                            \"Passively logging in user {} from {} via autologin\".format(\n                                autologin_as, remote_address\n                            )\n                        )\n                        flask.session[\"login_mechanism\"] = \"autologin\"\n                        return autologin_user\n            except Exception:\n                logger.exception(\n                    \"Could not autologin user {} from {} for networks {}\".format(\n                        autologin_as, remote_address, local_networks\n                    )\n                )\n\n        if not u.is_active:\n            # inactive user, switch to anonymous\n            u = octoprint.server.userManager.anonymous_user_factory()\n\n        return u\n\n    user = login(determine_user(user))\n    response = user.as_dict()\n    response[\"_is_external_client\"] = ip_check_enabled and not is_lan_address(\n        remote_address, additional_private=ip_check_trusted\n    )\n    if flask.session.get(\"login_mechanism\") is not None:\n        response[\"_login_mechanism\"] = flask.session.get(\"login_mechanism\")\n    return flask.jsonify(response)\n\n\n# ~~ rate limiting helper\n\n\ndef limit(*args, **kwargs):\n    if octoprint.server.limiter:\n        return octoprint.server.limiter.limit(*args, **kwargs)\n    else:\n\n        def decorator(f):\n            @functools.wraps(f)\n            def decorated_function(*args, **kwargs):\n                return f(*args, **kwargs)\n\n            return decorated_function\n\n        return decorator\n\n\n# ~~ cache decorator for cacheable views\n\n\nclass LessSimpleCache(BaseCache):\n    \"\"\"\n    Slightly improved version of :class:`SimpleCache`.\n\n    Setting ``default_timeout`` or ``timeout`` to ``-1`` will have no timeout be applied at all.\n    \"\"\"\n\n    def __init__(self, threshold=500, default_timeout=300):\n        BaseCache.__init__(self, default_timeout=default_timeout)\n        self._mutex = threading.RLock()\n        self._cache = {}\n        self._bypassed = set()\n        self.clear = self._cache.clear\n        self._threshold = threshold\n\n    def _prune(self):\n        if self.over_threshold():\n            now = time.time()\n            for idx, (key, (expires, _)) in enumerate(self._cache.items()):\n                if expires is not None and expires <= now or idx % 3 == 0:\n                    with self._mutex:\n                        self._cache.pop(key, None)\n\n    def get(self, key):\n        import pickle\n\n        now = time.time()\n        with self._mutex:\n            expires, value = self._cache.get(key, (0, None))\n        if expires is None or expires > now:\n            return pickle.loads(value)\n\n    def set(self, key, value, timeout=None):\n        import pickle\n\n        with self._mutex:\n            self._prune()\n            self._cache[key] = (\n                self.calculate_timeout(timeout=timeout),\n                pickle.dumps(value, pickle.HIGHEST_PROTOCOL),\n            )\n            if key in self._bypassed:\n                self._bypassed.remove(key)\n\n    def add(self, key, value, timeout=None):\n        with self._mutex:\n            self.set(key, value, timeout=None)\n            self._cache.setdefault(key, self._cache[key])\n\n    def delete(self, key):\n        with self._mutex:\n            self._cache.pop(key, None)\n\n    def calculate_timeout(self, timeout=None):\n        if timeout is None:\n            timeout = self.default_timeout\n        if timeout == -1:\n            return None\n        return time.time() + timeout\n\n    def over_threshold(self):\n        if self._threshold is None:\n            return False\n        with self._mutex:\n            return len(self._cache) > self._threshold\n\n    def __getitem__(self, key):\n        return self.get(key)\n\n    def __setitem__(self, key, value):\n        return self.set(key, value)\n\n    def __delitem__(self, key):\n        return self.delete(key)\n\n    def __contains__(self, key):\n        with self._mutex:\n            return key in self._cache\n\n    def set_bypassed(self, key):\n        with self._mutex:\n            self._bypassed.add(key)\n\n    def is_bypassed(self, key):\n        with self._mutex:\n            return key in self._bypassed\n\n\n_cache = LessSimpleCache()\n\n\ndef cached(\n    timeout=5 * 60,\n    key=lambda: \"view:%s\" % flask.request.path,\n    unless=None,\n    refreshif=None,\n    unless_response=None,\n):\n    def decorator(f):\n        @functools.wraps(f)\n        def decorated_function(*args, **kwargs):\n            logger = logging.getLogger(__name__)\n\n            cache_key = key()\n\n            def f_with_duration(*args, **kwargs):\n                start_time = time.time()\n                try:\n                    return f(*args, **kwargs)\n                finally:\n                    elapsed = time.time() - start_time\n                    logger.debug(\n                        \"Needed {elapsed:.2f}s to render {path} (key: {key})\".format(\n                            elapsed=elapsed, path=flask.request.path, key=cache_key\n                        )\n                    )\n\n            # bypass the cache if \"unless\" condition is true\n            if callable(unless) and unless():\n                logger.debug(\n                    \"Cache for {path} bypassed, calling wrapped function\".format(\n                        path=flask.request.path\n                    )\n                )\n                _cache.set_bypassed(cache_key)\n                return f_with_duration(*args, **kwargs)\n\n            # also bypass the cache if it's disabled completely\n            if not settings().getBoolean([\"devel\", \"cache\", \"enabled\"]):\n                logger.debug(\n                    \"Cache for {path} disabled, calling wrapped function\".format(\n                        path=flask.request.path\n                    )\n                )\n                _cache.set_bypassed(cache_key)\n                return f_with_duration(*args, **kwargs)\n\n            rv = _cache.get(cache_key)\n\n            # only take the value from the cache if we are not required to refresh it from the wrapped function\n            if rv is not None and (not callable(refreshif) or not refreshif(rv)):\n                logger.debug(\n                    \"Serving entry for {path} from cache (key: {key})\".format(\n                        path=flask.request.path, key=cache_key\n                    )\n                )\n                if \"X-From-Cache\" not in rv.headers:\n                    rv.headers[\"X-From-Cache\"] = \"true\"\n                return rv\n\n            # get value from wrapped function\n            logger.debug(\n                \"No cache entry or refreshing cache for {path} (key: {key}), calling wrapped function\".format(\n                    path=flask.request.path, key=cache_key\n                )\n            )\n            rv = f_with_duration(*args, **kwargs)\n\n            # do not store if the \"unless_response\" condition is true\n            if callable(unless_response) and unless_response(rv):\n                logger.debug(\n                    \"Not caching result for {path} (key: {key}), bypassed\".format(\n                        path=flask.request.path, key=cache_key\n                    )\n                )\n                _cache.set_bypassed(cache_key)\n                return rv\n\n            # store it in the cache\n            _cache.set(cache_key, rv, timeout=timeout)\n\n            return rv\n\n        return decorated_function\n\n    return decorator\n\n\ndef is_in_cache(key=lambda: \"view:%s\" % flask.request.path):\n    if callable(key):\n        key = key()\n    return key in _cache\n\n\ndef is_cache_bypassed(key=lambda: \"view:%s\" % flask.request.path):\n    if callable(key):\n        key = key()\n    return _cache.is_bypassed(key)\n\n\ndef cache_check_headers():\n    return \"no-cache\" in flask.request.cache_control or \"no-cache\" in flask.request.pragma\n\n\ndef cache_check_response_headers(response):\n    if not isinstance(response, flask.Response):\n        return False\n\n    headers = response.headers\n\n    if \"Cache-Control\" in headers and (\n        \"no-cache\" in headers[\"Cache-Control\"] or \"no-store\" in headers[\"Cache-Control\"]\n    ):\n        return True\n\n    if \"Pragma\" in headers and \"no-cache\" in headers[\"Pragma\"]:\n        return True\n\n    if \"Expires\" in headers and headers[\"Expires\"] in (\"0\", \"-1\"):\n        return True\n\n    return False\n\n\ndef cache_check_status_code(response, valid):\n    if not isinstance(response, flask.Response):\n        return False\n\n    if callable(valid):\n        return not valid(response.status_code)\n    else:\n        return response.status_code not in valid\n\n\nclass PreemptiveCache:\n    def __init__(self, cachefile):\n        self.cachefile = cachefile\n        self.environment = None\n\n        self._logger = logging.getLogger(__name__ + \".\" + self.__class__.__name__)\n\n        self._lock = threading.RLock()\n\n    def record(self, data, unless=None, root=None):\n        if callable(unless) and unless():\n            return\n\n        entry_data = data\n        if callable(entry_data):\n            entry_data = entry_data()\n\n        if entry_data is not None:\n            if root is None:\n                from flask import request\n\n                root = request.path\n            self.add_data(root, entry_data)\n\n    def has_record(self, data, root=None):\n        if callable(data):\n            data = data()\n\n        if data is None:\n            return False\n\n        if root is None:\n            from flask import request\n\n            root = request.path\n\n        all_data = self.get_data(root)\n        for existing in all_data:\n            if self._compare_data(data, existing):\n                return True\n\n        return False\n\n    def clean_all_data(self, cleanup_function):\n        assert callable(cleanup_function)\n\n        with self._lock:\n            all_data = self.get_all_data()\n            for root, entries in list(all_data.items()):\n                old_count = len(entries)\n                entries = cleanup_function(root, entries)\n                if not entries:\n                    del all_data[root]\n                    self._logger.debug(f\"Removed root {root} from preemptive cache\")\n                elif len(entries) < old_count:\n                    all_data[root] = entries\n                    self._logger.debug(\n                        \"Removed {} entries from preemptive cache for root {}\".format(\n                            old_count - len(entries), root\n                        )\n                    )\n            self.set_all_data(all_data)\n\n        return all_data\n\n    def get_all_data(self):\n        cache_data = None\n        with self._lock:\n            try:\n                cache_data = yaml.load_from_file(path=self.cachefile)\n            except OSError as e:\n                import errno\n\n                if e.errno != errno.ENOENT:\n                    raise\n            except Exception:\n                self._logger.exception(f\"Error while reading {self.cachefile}\")\n\n        if cache_data is None:\n            cache_data = {}\n\n        if not self._validate_data(cache_data):\n            self._logger.warning(\"Preemptive cache data was invalid, ignoring it\")\n            cache_data = {}\n\n        return cache_data\n\n    def get_data(self, root):\n        cache_data = self.get_all_data()\n        return cache_data.get(root, list())\n\n    def set_all_data(self, data):\n        from octoprint.util import atomic_write\n\n        with self._lock:\n            try:\n                with atomic_write(self.cachefile, \"wt\", max_permissions=0o666) as handle:\n                    yaml.save_to_file(data, file=handle, pretty=True)\n            except Exception:\n                self._logger.exception(f\"Error while writing {self.cachefile}\")\n\n    def set_data(self, root, data):\n        with self._lock:\n            all_data = self.get_all_data()\n            all_data[root] = data\n            self.set_all_data(all_data)\n\n    def add_data(self, root, data):\n        def split_matched_and_unmatched(entry, entries):\n            matched = []\n            unmatched = []\n\n            for e in entries:\n                if self._compare_data(e, entry):\n                    matched.append(e)\n                else:\n                    unmatched.append(e)\n\n            return matched, unmatched\n\n        with self._lock:\n            cache_data = self.get_all_data()\n\n            if root not in cache_data:\n                cache_data[root] = []\n\n            existing, other = split_matched_and_unmatched(data, cache_data[root])\n\n            def get_newest(entries):\n                result = None\n                for entry in entries:\n                    if \"_timestamp\" in entry and (\n                        result is None\n                        or (\n                            \"_timestamp\" in result\n                            and result[\"_timestamp\"] < entry[\"_timestamp\"]\n                        )\n                    ):\n                        result = entry\n                return result\n\n            to_persist = get_newest(existing)\n            if not to_persist:\n                import copy\n\n                to_persist = copy.deepcopy(data)\n                to_persist[\"_timestamp\"] = time.time()\n                to_persist[\"_count\"] = 1\n                self._logger.info(f\"Adding entry for {root} and {to_persist!r}\")\n            else:\n                to_persist[\"_timestamp\"] = time.time()\n                to_persist[\"_count\"] = to_persist.get(\"_count\", 0) + 1\n                self._logger.debug(\n                    f\"Updating timestamp and counter for {root} and {data!r}\"\n                )\n\n            self.set_data(root, [to_persist] + other)\n\n    def _compare_data(self, a, b):\n        from octoprint.util import dict_filter\n\n        def strip_ignored(d):\n            return dict_filter(d, lambda k, v: not k.startswith(\"_\"))\n\n        return set(strip_ignored(a).items()) == set(strip_ignored(b).items())\n\n    def _validate_data(self, data):\n        if not isinstance(data, dict):\n            return False\n\n        for entries in data.values():\n            if not isinstance(entries, list):\n                return False\n\n            for entry in entries:\n                if not self._validate_entry(entry):\n                    return False\n\n        return True\n\n    def _validate_entry(self, entry):\n        return isinstance(entry, dict) and \"_timestamp\" in entry and \"_count\" in entry\n\n\ndef preemptively_cached(cache, data, unless=None):\n    def decorator(f):\n        @functools.wraps(f)\n        def decorated_function(*args, **kwargs):\n            try:\n                cache.record(data, unless=unless)\n            except Exception:\n                logging.getLogger(__name__).exception(\n                    f\"Error while recording preemptive cache entry: {data!r}\"\n                )\n            return f(*args, **kwargs)\n\n        return decorated_function\n\n    return decorator\n\n\ndef etagged(etag):\n    def decorator(f):\n        @functools.wraps(f)\n        def decorated_function(*args, **kwargs):\n            rv = f(*args, **kwargs)\n            if isinstance(rv, flask.Response):\n                try:\n                    result = etag\n                    if callable(result):\n                        result = result(rv)\n                    if result:\n                        rv.set_etag(result)\n                except Exception:\n                    logging.getLogger(__name__).exception(\n                        \"Error while calculating the etag value for response {!r}\".format(\n                            rv\n                        )\n                    )\n            return rv\n\n        return decorated_function\n\n    return decorator\n\n\ndef lastmodified(date):\n    def decorator(f):\n        @functools.wraps(f)\n        def decorated_function(*args, **kwargs):\n            rv = f(*args, **kwargs)\n            if \"Last-Modified\" not in rv.headers:\n                try:\n                    result = date\n                    if callable(result):\n                        result = result(rv)\n\n                    if not isinstance(result, str):\n                        from werkzeug.http import http_date\n\n                        result = http_date(result)\n\n                    if result:\n                        rv.headers[\"Last-Modified\"] = result\n                except Exception:\n                    logging.getLogger(__name__).exception(\n                        \"Error while calculating the lastmodified value for response {!r}\".format(\n                            rv\n                        )\n                    )\n            return rv\n\n        return decorated_function\n\n    return decorator\n\n\ndef conditional(condition, met):\n    def decorator(f):\n        @functools.wraps(f)\n        def decorated_function(*args, **kwargs):\n            try:\n                if callable(condition) and condition():\n                    # condition has been met, return met-response\n                    rv = met\n                    if callable(met):\n                        rv = met()\n                    return rv\n            except Exception:\n                logging.getLogger(__name__).exception(\n                    \"Error while evaluating conditional {!r} or met {!r}\".format(\n                        condition, met\n                    )\n                )\n\n            # condition hasn't been met, call decorated function\n            return f(*args, **kwargs)\n\n        return decorated_function\n\n    return decorator\n\n\ndef with_client_revalidation(f):\n    @functools.wraps(f)\n    def decorated_function(*args, **kwargs):\n        r = f(*args, **kwargs)\n\n        if isinstance(r, flask.Response):\n            r = add_revalidation_response_headers(r)\n\n        return r\n\n    return decorated_function\n\n\ndef with_revalidation_checking(\n    etag_factory=None, lastmodified_factory=None, condition=None, unless=None\n):\n    if etag_factory is None:\n\n        def etag_factory(lm=None):\n            return None\n\n    if lastmodified_factory is None:\n\n        def lastmodified_factory():\n            return None\n\n    if condition is None:\n\n        def condition(lm=None, etag=None):\n            if lm is None:\n                lm = lastmodified_factory()\n\n            if etag is None:\n                etag = etag_factory(lm=lm)\n\n            if flask.request.if_none_match and flask.request.if_modified_since:\n                # use both\n                return check_lastmodified(lm) and check_etag(etag)\n            elif flask.request.if_none_match:\n                # use only ETag\n                return check_etag(etag)\n            elif flask.request.if_modified_since:\n                # use only Last-Modified\n                return check_lastmodified(lm)\n            else:\n                # assume stale cache\n                return False\n\n    if unless is None:\n\n        def unless():\n            return False\n\n    def decorator(f):\n        @functools.wraps(f)\n        def decorated_function(*args, **kwargs):\n            from octoprint.server import NOT_MODIFIED\n\n            lm = lastmodified_factory()\n            etag = etag_factory(lm)\n\n            if condition(lm, etag) and not unless():\n                return NOT_MODIFIED\n\n            # generate response\n            response = f(*args, **kwargs)\n\n            # set etag header if not already set\n            if etag and response.get_etag()[0] is None:\n                response.set_etag(etag)\n\n            # set last modified header if not already set\n            if lm and response.headers.get(\"Last-Modified\", None) is None:\n                if not isinstance(lm, str):\n                    from werkzeug.http import http_date\n\n                    lm = http_date(lm)\n                response.headers[\"Last-Modified\"] = lm\n\n            response = add_no_max_age_response_headers(response)\n            return response\n\n        return decorated_function\n\n    return decorator\n\n\ndef check_etag(etag):\n    if etag is None:\n        return False\n\n    return (\n        flask.request.method in (\"GET\", \"HEAD\")\n        and flask.request.if_none_match is not None\n        and etag in flask.request.if_none_match\n    )\n\n\ndef check_lastmodified(lastmodified: Union[int, float, datetime]) -> bool:\n    \"\"\"Compares the provided lastmodified value with the value of the If-Modified-Since header.\n\n    If ``lastmodified`` is an int or float, it's assumed to be a Unix timestamp and converted\n    to a timezone aware datetime instance in UTC.\n\n    If ``lastmodified`` is a datetime instance, it needs to be timezone aware or the\n    result will always be ``False``.\n\n    Args:\n        lastmodified (Union[int, float, datetime]): The last modified value to compare against\n\n    Raises:\n        ValueError: If anything but an int, float or datetime instance is passed\n\n    Returns:\n        bool: true if the values indicate that the document is still up to date\n    \"\"\"\n\n    if lastmodified is None:\n        return False\n\n    if isinstance(lastmodified, (int, float)):\n        # max(86400, lastmodified) is workaround for https://bugs.python.org/issue29097,\n        # present in CPython 3.6.x up to 3.7.1.\n        #\n        # I think it's fair to say that we'll never encounter lastmodified values older than\n        # 1970-01-02 so this is a safe workaround.\n        #\n        # Timestamps are defined as seconds since epoch aka 1970/01/01 00:00:00Z, so we\n        # use UTC as timezone here.\n        lastmodified = datetime.fromtimestamp(\n            max(86400, lastmodified), tz=UTC_TZ\n        ).replace(microsecond=0)\n\n    if not isinstance(lastmodified, datetime):\n        raise ValueError(\n            \"lastmodified must be a datetime or float or int instance but, got {} instead\".format(\n                lastmodified.__class__\n            )\n        )\n\n    if not is_timezone_aware(lastmodified):\n        # datetime object is not timezone aware, we can't check lastmodified with that\n        logger = logging.getLogger(__name__)\n        logger.warning(\n            \"lastmodified is not timezone aware, cannot check against If-Modified-Since. In the future this will become an error!\",\n            stack_info=logger.isEnabledFor(logging.DEBUG),\n        )\n        return False\n\n    return (\n        flask.request.method in (\"GET\", \"HEAD\")\n        and flask.request.if_modified_since is not None\n        and lastmodified <= flask.request.if_modified_since\n    )\n\n\ndef add_revalidation_response_headers(response):\n    import werkzeug.http\n\n    cache_control = werkzeug.http.parse_dict_header(\n        response.headers.get(\"Cache-Control\", \"\")\n    )\n    if \"no-cache\" not in cache_control:\n        cache_control[\"no-cache\"] = None\n    if \"must-revalidate\" not in cache_control:\n        cache_control[\"must-revalidate\"] = None\n    response.headers[\"Cache-Control\"] = werkzeug.http.dump_header(cache_control)\n\n    return response\n\n\ndef add_non_caching_response_headers(response):\n    import werkzeug.http\n\n    cache_control = werkzeug.http.parse_dict_header(\n        response.headers.get(\"Cache-Control\", \"\")\n    )\n    if \"no-store\" not in cache_control:\n        cache_control[\"no-store\"] = None\n    if \"no-cache\" not in cache_control:\n        cache_control[\"no-cache\"] = None\n    if \"must-revalidate\" not in cache_control:\n        cache_control[\"must-revalidate\"] = None\n    if \"post-check\" not in cache_control or cache_control[\"post-check\"] != \"0\":\n        cache_control[\"post-check\"] = \"0\"\n    if \"pre-check\" not in cache_control or cache_control[\"pre-check\"] != \"0\":\n        cache_control[\"pre-check\"] = \"0\"\n    if \"max-age\" not in cache_control or cache_control[\"max-age\"] != \"0\":\n        cache_control[\"max-age\"] = \"0\"\n    response.headers[\"Cache-Control\"] = werkzeug.http.dump_header(cache_control)\n\n    response.headers[\"Pragma\"] = \"no-cache\"\n    response.headers[\"Expires\"] = \"-1\"\n    return response\n\n\ndef add_no_max_age_response_headers(response):\n    import werkzeug.http\n\n    cache_control = werkzeug.http.parse_dict_header(\n        response.headers.get(\"Cache-Control\", \"\")\n    )\n    if \"max-age\" not in cache_control or cache_control[\"max-age\"] != \"0\":\n        cache_control[\"max-age\"] = \"0\"\n    response.headers[\"Cache-Control\"] = werkzeug.http.dump_header(cache_control)\n\n    return response\n\n\n# ~~ access validators for use with tornado\n\n\ndef permission_validator(request, permission):\n    \"\"\"\n    Validates that the given request is made by an authorized user, identified either by API key or existing Flask\n    session.\n\n    Must be executed in an existing Flask request context!\n\n    :param request: The Flask request object\n    :param request: The required permission\n    \"\"\"\n\n    user = get_flask_user_from_request(request)\n    if not user.has_permission(permission):\n        raise tornado.web.HTTPError(403)\n\n\n@deprecated(\n    \"admin_validator is deprecated, please use new permission_validator\", since=\"\"\n)\ndef admin_validator(request):\n    from octoprint.access.permissions import Permissions\n\n    return permission_validator(request, Permissions.ADMIN)\n\n\n@deprecated(\"user_validator is deprecated, please use new permission_validator\", since=\"\")\ndef user_validator(request):\n    return True\n\n\ndef get_flask_user_from_request(request):\n    \"\"\"\n    Retrieves the current flask user from the request context. Uses API key if available, otherwise the current\n    user session if available.\n\n    :param request: flask request from which to retrieve the current user\n    :return: the user (might be an anonymous user)\n    \"\"\"\n    import flask_login\n\n    import octoprint.server.util\n\n    user = None\n\n    apikey = octoprint.server.util.get_api_key(request)\n    if apikey is not None:\n        # user from api key?\n        user = octoprint.server.util.get_user_for_apikey(apikey)\n\n    if user is None:\n        # user still None -> current session user\n        user = flask_login.current_user\n\n    if user is None:\n        # user still None -> anonymous\n        from octoprint.server import userManager\n\n        user = userManager.anonymous_user_factory()\n\n    return user\n\n\ndef redirect_to_tornado(request, target, code=302):\n    \"\"\"\n    Redirects from flask to tornado, flask request context must exist.\n\n    :param request:\n    :param target:\n    :param code:\n    :return:\n    \"\"\"\n\n    import flask\n\n    requestUrl = request.url\n    appBaseUrl = requestUrl[: requestUrl.find(flask.url_for(\"index\") + \"api\")]\n\n    redirectUrl = appBaseUrl + target\n    if \"?\" in requestUrl:\n        fragment = requestUrl[requestUrl.rfind(\"?\") :]\n        redirectUrl += fragment\n    return flask.redirect(redirectUrl, code=code)\n\n\ndef restricted_access(func):\n    \"\"\"\n    This combines :py:func:`no_firstrun_access` and ``login_required``.\n    \"\"\"\n\n    @functools.wraps(func)\n    def decorated_view(*args, **kwargs):\n        return no_firstrun_access(flask_login.login_required(func))(*args, **kwargs)\n\n    return decorated_view\n\n\ndef no_firstrun_access(func):\n    \"\"\"\n    If you decorate a view with this, it will ensure that first setup has been\n    done for OctoPrint's Access Control.\n\n    If OctoPrint's Access Control has not been setup yet (indicated by the userManager\n    not reporting that its user database has been customized from default), the decorator\n    will cause a HTTP 403 status code to be returned by the decorated resource.\n    \"\"\"\n\n    @functools.wraps(func)\n    def decorated_view(*args, **kwargs):\n        # if OctoPrint hasn't been set up yet, abort\n        if settings().getBoolean([\"server\", \"firstRun\"]) and (\n            octoprint.server.userManager is None\n            or not octoprint.server.userManager.has_been_customized()\n        ):\n            flask.abort(403)\n        return func(*args, **kwargs)\n\n    return decorated_view\n\n\ndef firstrun_only_access(func):\n    \"\"\"\n    If you decorate a view with this, it will ensure that first setup has _not_ been\n    done for OctoPrint's Access Control. Otherwise it\n    will cause a HTTP 403 status code to be returned by the decorated resource.\n    \"\"\"\n\n    @functools.wraps(func)\n    def decorated_view(*args, **kwargs):\n        # if OctoPrint has been set up yet, abort\n        if settings().getBoolean([\"server\", \"firstRun\"]) and (\n            octoprint.server.userManager is None\n            or not octoprint.server.userManager.has_been_customized()\n        ):\n            return func(*args, **kwargs)\n        else:\n            flask.abort(403)\n\n    return decorated_view\n\n\ndef get_remote_address(request):\n    forwardedFor = request.headers.get(\"X-Forwarded-For\", None)\n    if forwardedFor is not None:\n        return forwardedFor.split(\",\")[0]\n    return request.remote_addr\n\n\ndef get_json_command_from_request(request, valid_commands):\n    content_type = request.headers.get(\"Content-Type\", None)\n    if content_type is None or \"application/json\" not in content_type:\n        flask.abort(400, description=\"Expected content-type JSON\")\n\n    data = request.get_json()\n    if data is None:\n        flask.abort(\n            400, description=\"Malformed JSON body or wrong content-type in request\"\n        )\n    if \"command\" not in data or data[\"command\"] not in valid_commands:\n        flask.abort(400, description=\"command is invalid\")\n\n    command = data[\"command\"]\n    if any(map(lambda x: x not in data, valid_commands[command])):\n        flask.abort(400, description=\"Mandatory parameters missing\")\n\n    return command, data, None\n\n\ndef make_text_response(message, status):\n    \"\"\"\n    Helper to generate basic text responses.\n\n    Response will have the provided message as body, the provided status code, and\n    a content type of \"text/plain\".\n\n    Args:\n        message: The message in the response body\n        status: The HTTP status code\n\n    Returns:\n\n    \"\"\"\n    return make_response(message, status, {\"Content-Type\": \"text/plain\"})\n\n\ndef make_api_error(message, status):\n    \"\"\"\n    Helper to generate API error responses in JSON format.\n\n    Turns something like ``make_api_error(\"Not Found\", 404)`` into a JSON response\n    with body ``{\"error\": \"Not Found\"}``.\n\n    Args:\n        message: The error message to put into the response\n        status: The HTTP status code\n\n    Returns: a flask response to return to the client\n    \"\"\"\n    return make_response(flask.jsonify(error=message), status)\n\n\n##~~ Flask-Assets resolver with plugin asset support\n\n\nclass PluginAssetResolver(flask_assets.FlaskResolver):\n    def split_prefix(self, ctx, item):\n        app = ctx.environment._app\n        if item.startswith(\"plugin/\"):\n            try:\n                prefix, plugin, name = item.split(\"/\", 2)\n                blueprint = prefix + \".\" + plugin\n\n                directory = flask_assets.get_static_folder(app.blueprints[blueprint])\n                item = name\n                endpoint = blueprint + \".static\"\n                return directory, item, endpoint\n            except (ValueError, KeyError):\n                pass\n\n        return flask_assets.FlaskResolver.split_prefix(self, ctx, item)\n\n    def resolve_output_to_path(self, ctx, target, bundle):\n        import os\n\n        return os.path.normpath(os.path.join(ctx.environment.directory, target))\n\n\n##~~ Webassets updater that takes changes in the configuration into account\n\n\nclass SettingsCheckUpdater(webassets.updater.BaseUpdater):\n\n    updater = \"always\"\n\n    def __init__(self):\n        self._delegate = webassets.updater.get_updater(self.__class__.updater)\n\n    def needs_rebuild(self, bundle, ctx):\n        return self._delegate.needs_rebuild(bundle, ctx) or self.changed_settings(ctx)\n\n    def changed_settings(self, ctx):\n        if not ctx.cache:\n            return False\n\n        cache_key = (\"octo\", \"settings\")\n        current_hash = settings().effective_hash\n        cached_hash = ctx.cache.get(cache_key)\n        # This may seem counter-intuitive, but if no cache entry is found\n        # then we actually return \"no update needed\". This is because\n        # otherwise if no cache / a dummy cache is used, then we would be\n        # rebuilding every single time.\n        if cached_hash is not None:\n            return cached_hash != current_hash\n        return False\n\n    def build_done(self, bundle, ctx):\n        self._delegate.build_done(bundle, ctx)\n        if not ctx.cache:\n            return\n\n        cache_key = (\"octo\", \"settings\")\n        ctx.cache.set(cache_key, settings().effective_hash)\n\n\n##~~ core assets collector\ndef collect_core_assets(preferred_stylesheet=\"css\"):\n    assets = {\"js\": [], \"clientjs\": [], \"css\": [], \"less\": []}\n    assets[\"js\"] = [\n        \"js/app/bindings/allowbindings.js\",\n        \"js/app/bindings/contextmenu.js\",\n        \"js/app/bindings/invisible.js\",\n        \"js/app/bindings/popover.js\",\n        \"js/app/bindings/qrcode.js\",\n        \"js/app/bindings/slimscrolledforeach.js\",\n        \"js/app/bindings/toggle.js\",\n        \"js/app/bindings/togglecontent.js\",\n        \"js/app/bindings/valuewithinit.js\",\n        \"js/app/viewmodels/access.js\",\n        \"js/app/viewmodels/appearance.js\",\n        \"js/app/viewmodels/connection.js\",\n        \"js/app/viewmodels/control.js\",\n        \"js/app/viewmodels/files.js\",\n        \"js/app/viewmodels/loginstate.js\",\n        \"js/app/viewmodels/loginui.js\",\n        \"js/app/viewmodels/navigation.js\",\n        \"js/app/viewmodels/printerstate.js\",\n        \"js/app/viewmodels/printerprofiles.js\",\n        \"js/app/viewmodels/settings.js\",\n        \"js/app/viewmodels/slicing.js\",\n        \"js/app/viewmodels/system.js\",\n        \"js/app/viewmodels/temperature.js\",\n        \"js/app/viewmodels/terminal.js\",\n        \"js/app/viewmodels/timelapse.js\",\n        \"js/app/viewmodels/uistate.js\",\n        \"js/app/viewmodels/users.js\",\n        \"js/app/viewmodels/usersettings.js\",\n        \"js/app/viewmodels/wizard.js\",\n        \"js/app/viewmodels/about.js\",\n    ]\n\n    assets[\"clientjs\"] = [\n        \"js/app/client/base.js\",\n        \"js/app/client/socket.js\",\n        \"js/app/client/access.js\",\n        \"js/app/client/browser.js\",\n        \"js/app/client/connection.js\",\n        \"js/app/client/control.js\",\n        \"js/app/client/files.js\",\n        \"js/app/client/job.js\",\n        \"js/app/client/languages.js\",\n        \"js/app/client/printer.js\",\n        \"js/app/client/printerprofiles.js\",\n        \"js/app/client/settings.js\",\n        \"js/app/client/slicing.js\",\n        \"js/app/client/system.js\",\n        \"js/app/client/timelapse.js\",\n        \"js/app/client/users.js\",\n        \"js/app/client/util.js\",\n        \"js/app/client/wizard.js\",\n    ]\n\n    if preferred_stylesheet == \"less\":\n        assets[\"less\"].append(\"less/octoprint.less\")\n    elif preferred_stylesheet == \"css\":\n        assets[\"css\"].append(\"css/octoprint.css\")\n\n    return assets\n\n\n##~~ plugin assets collector\n\n\ndef collect_plugin_assets(preferred_stylesheet=\"css\"):\n    logger = logging.getLogger(__name__ + \".collect_plugin_assets\")\n\n    supported_stylesheets = (\"css\", \"less\")\n    assets = {\n        \"bundled\": {\n            \"js\": DefaultOrderedDict(list),\n            \"clientjs\": DefaultOrderedDict(list),\n            \"css\": DefaultOrderedDict(list),\n            \"less\": DefaultOrderedDict(list),\n        },\n        \"external\": {\n            \"js\": DefaultOrderedDict(list),\n            \"clientjs\": DefaultOrderedDict(list),\n            \"css\": DefaultOrderedDict(list),\n            \"less\": DefaultOrderedDict(list),\n        },\n    }\n\n    asset_plugins = octoprint.plugin.plugin_manager().get_implementations(\n        octoprint.plugin.AssetPlugin\n    )\n    for implementation in asset_plugins:\n        name = implementation._identifier\n        is_bundled = implementation._plugin_info.bundled\n\n        asset_key = \"bundled\" if is_bundled else \"external\"\n\n        try:\n            all_assets = implementation.get_assets()\n            basefolder = implementation.get_asset_folder()\n        except Exception:\n            logger.exception(\n                \"Got an error while trying to collect assets from {}, ignoring assets from the plugin\".format(\n                    name\n                ),\n                extra={\"plugin\": name},\n            )\n            continue\n\n        def asset_exists(category, asset):\n            exists = os.path.exists(os.path.join(basefolder, asset))\n            if not exists:\n                logger.warning(\n                    \"Plugin {} is referring to non existing {} asset {}\".format(\n                        name, category, asset\n                    )\n                )\n            return exists\n\n        if \"js\" in all_assets:\n            for asset in all_assets[\"js\"]:\n                if not asset_exists(\"js\", asset):\n                    continue\n                assets[asset_key][\"js\"][name].append(f\"plugin/{name}/{asset}\")\n\n        if \"clientjs\" in all_assets:\n            for asset in all_assets[\"clientjs\"]:\n                if not asset_exists(\"clientjs\", asset):\n                    continue\n                assets[asset_key][\"clientjs\"][name].append(f\"plugin/{name}/{asset}\")\n\n        if preferred_stylesheet in all_assets:\n            for asset in all_assets[preferred_stylesheet]:\n                if not asset_exists(preferred_stylesheet, asset):\n                    continue\n                assets[asset_key][preferred_stylesheet][name].append(\n                    f\"plugin/{name}/{asset}\"\n                )\n        else:\n            for stylesheet in supported_stylesheets:\n                if stylesheet not in all_assets:\n                    continue\n\n                for asset in all_assets[stylesheet]:\n                    if not asset_exists(stylesheet, asset):\n                        continue\n                    assets[asset_key][stylesheet][name].append(f\"plugin/{name}/{asset}\")\n                break\n\n    return assets\n\n\n##~~ JSON encoding\n\n\nclass OctoPrintJsonEncoder(flask.json.JSONEncoder):\n    def default(self, obj):\n        try:\n            return JsonEncoding.encode(obj)\n        except TypeError:\n            return flask.json.JSONEncoder.default(self, obj)\n", "__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"\n__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"\n__copyright__ = \"Copyright (C) 2014 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n\nimport logging\nimport re\nimport threading\nimport time\n\nimport wrapt\n\nimport octoprint.access.users\nimport octoprint.events\nimport octoprint.plugin\nimport octoprint.printer\nimport octoprint.server\nimport octoprint.timelapse\nimport octoprint.vendor.sockjs.tornado\nimport octoprint.vendor.sockjs.tornado.proto\nimport octoprint.vendor.sockjs.tornado.session\nimport octoprint.vendor.sockjs.tornado.util\nfrom octoprint.access.groups import GroupChangeListener\nfrom octoprint.access.permissions import Permissions\nfrom octoprint.access.users import LoginStatusListener\nfrom octoprint.events import Events\nfrom octoprint.settings import settings\nfrom octoprint.util.json import dumps as json_dumps\nfrom octoprint.util.version import get_python_version_string\n\n\nclass ThreadSafeSession(octoprint.vendor.sockjs.tornado.session.Session):\n    def __init__(self, conn, server, session_id, expiry=None):\n        octoprint.vendor.sockjs.tornado.session.Session.__init__(\n            self, conn, server, session_id, expiry=expiry\n        )\n\n    def set_handler(self, handler, start_heartbeat=True):\n        if getattr(handler, \"__orig_send_pack\", None) is None:\n            orig_send_pack = handler.send_pack\n            mutex = threading.RLock()\n\n            def send_pack(*args, **kwargs):\n                with mutex:\n                    return orig_send_pack(*args, **kwargs)\n\n            handler.send_pack = send_pack\n            handler.__orig_send_pack = orig_send_pack\n\n        return octoprint.vendor.sockjs.tornado.session.Session.set_handler(\n            self, handler, start_heartbeat=start_heartbeat\n        )\n\n    def remove_handler(self, handler):\n        result = octoprint.vendor.sockjs.tornado.session.Session.remove_handler(\n            self, handler\n        )\n\n        if getattr(handler, \"__orig_send_pack\", None) is not None:\n            handler.send_pack = handler.__orig_send_pack\n            delattr(handler, \"__orig_send_pack\")\n\n        return result\n\n\nclass JsonEncodingSessionWrapper(wrapt.ObjectProxy):\n    def send_message(self, msg, stats=True, binary=False):\n        self.send_jsonified(\n            json_dumps(octoprint.vendor.sockjs.tornado.util.bytes_to_str(msg)),\n            stats,\n        )\n\n\nclass PrinterStateConnection(\n    octoprint.vendor.sockjs.tornado.SockJSConnection,\n    octoprint.printer.PrinterCallback,\n    LoginStatusListener,\n    GroupChangeListener,\n):\n\n    _event_permissions = {\n        Events.USER_LOGGED_IN: [Permissions.ADMIN],\n        Events.USER_LOGGED_OUT: [Permissions.ADMIN],\n        \"*\": [],\n    }\n\n    _event_payload_processors = {\n        Events.CLIENT_OPENED: [\n            lambda user, payload: payload\n            if user.has_permission(Permissions.ADMIN)\n            else {}\n        ],\n        Events.CLIENT_AUTHED: [\n            lambda user, payload: payload\n            if user.has_permission(Permissions.ADMIN)\n            else {}\n        ],\n        \"*\": [],\n    }\n\n    # TODO: Permissions should be overridable from plugins, this special case stuff here is a hack\n    _emit_permissions = {\n        \"connected\": [],\n        \"reauthRequired\": [],\n        \"plugin\": lambda payload: []\n        if payload.get(\"plugin\") in (\"backup\", \"softwareupdate\")\n        and settings().getBoolean([\"server\", \"firstRun\"])\n        else [Permissions.STATUS],\n        \"*\": [Permissions.STATUS],\n    }\n\n    _unauthed_backlog_max = 100\n\n    def __init__(\n        self,\n        printer,\n        fileManager,\n        analysisQueue,\n        userManager,\n        groupManager,\n        eventManager,\n        pluginManager,\n        connectivityChecker,\n        session,\n    ):\n        if isinstance(session, octoprint.vendor.sockjs.tornado.session.Session):\n            session = JsonEncodingSessionWrapper(session)\n\n        octoprint.vendor.sockjs.tornado.SockJSConnection.__init__(self, session)\n\n        self._logger = logging.getLogger(__name__)\n\n        self._temperatureBacklog = []\n        self._temperatureBacklogMutex = threading.Lock()\n        self._logBacklog = []\n        self._logBacklogMutex = threading.Lock()\n        self._messageBacklog = []\n        self._messageBacklogMutex = threading.Lock()\n\n        self._unauthed_backlog = []\n        self._unauthed_backlog_mutex = threading.RLock()\n\n        self._printer = printer\n        self._fileManager = fileManager\n        self._analysisQueue = analysisQueue\n        self._userManager = userManager\n        self._groupManager = groupManager\n        self._eventManager = eventManager\n        self._pluginManager = pluginManager\n        self._connectivityChecker = connectivityChecker\n\n        self._remoteAddress = None\n        self._user = self._userManager.anonymous_user_factory()\n\n        self._throttle_factor = 1\n        self._last_current = 0\n        self._base_rate_limit = 0.5\n\n        self._held_back_current = None\n        self._held_back_mutex = threading.RLock()\n\n        self._register_hooks = self._pluginManager.get_hooks(\n            \"octoprint.server.sockjs.register\"\n        )\n        self._authed_hooks = self._pluginManager.get_hooks(\n            \"octoprint.server.sockjs.authed\"\n        )\n        self._emit_hooks = self._pluginManager.get_hooks(\"octoprint.server.sockjs.emit\")\n\n        self._registered = False\n        self._authed = False\n        self._initial_data_sent = False\n\n        self._subscriptions_active = False\n        self._subscriptions = {\"state\": False, \"plugins\": [], \"events\": []}\n\n    @staticmethod\n    def _get_remote_address(info):\n        forwarded_for = info.headers.get(\"X-Forwarded-For\")\n        if forwarded_for is not None:\n            return forwarded_for.split(\",\")[0]\n        return info.ip\n\n    def __str__(self):\n        if self._remoteAddress:\n            return f\"{self!r} connected to {self._remoteAddress}\"\n        else:\n            return f\"Unconnected {self!r}\"\n\n    def on_open(self, info):\n        self._pluginManager.register_message_receiver(self.on_plugin_message)\n        self._remoteAddress = self._get_remote_address(info)\n        self._logger.info(\"New connection from client: %s\" % self._remoteAddress)\n\n        self._userManager.register_login_status_listener(self)\n        self._groupManager.register_listener(self)\n\n        plugin_signature = lambda impl: \"{}:{}\".format(\n            impl._identifier, impl._plugin_version\n        )\n        template_plugins = list(\n            map(\n                plugin_signature,\n                self._pluginManager.get_implementations(octoprint.plugin.TemplatePlugin),\n            )\n        )\n        asset_plugins = list(\n            map(\n                plugin_signature,\n                self._pluginManager.get_implementations(octoprint.plugin.AssetPlugin),\n            )\n        )\n        ui_plugins = sorted(set(template_plugins + asset_plugins))\n\n        import hashlib\n\n        plugin_hash = hashlib.md5()\n        plugin_hash.update(\",\".join(ui_plugins).encode(\"utf-8\"))\n\n        config_hash = settings().config_hash\n\n        # connected => update the API key, might be necessary if the client was left open while the server restarted\n        self._emit(\n            \"connected\",\n            {\n                \"version\": octoprint.server.VERSION,\n                \"display_version\": octoprint.server.DISPLAY_VERSION,\n                \"branch\": octoprint.server.BRANCH,\n                \"python_version\": get_python_version_string(),\n                \"plugin_hash\": plugin_hash.hexdigest(),\n                \"config_hash\": config_hash,\n                \"debug\": octoprint.server.debug,\n                \"safe_mode\": octoprint.server.safe_mode,\n                \"online\": self._connectivityChecker.online,\n                \"permissions\": [permission.as_dict() for permission in Permissions.all()],\n            },\n        )\n\n        self._eventManager.fire(\n            Events.CLIENT_OPENED, {\"remoteAddress\": self._remoteAddress}\n        )\n        self._register()\n\n    def on_close(self):\n        self._user = self._userManager.anonymous_user_factory()\n        self._groupManager.unregister_listener(self)\n        self._userManager.unregister_login_status_listener(self)\n\n        self._unregister()\n        self._eventManager.fire(\n            Events.CLIENT_CLOSED, {\"remoteAddress\": self._remoteAddress}\n        )\n\n        self._logger.info(\"Client connection closed: %s\" % self._remoteAddress)\n\n        self._on_logout()\n        self._remoteAddress = None\n        self._pluginManager.unregister_message_receiver(self.on_plugin_message)\n\n    def on_message(self, message):\n        try:\n            import json\n\n            message = json.loads(message)\n        except Exception:\n            self._logger.warning(\n                \"Invalid JSON received from client {}, ignoring: {!r}\".format(\n                    self._remoteAddress, message\n                )\n            )\n            return\n\n        if \"auth\" in message:\n            try:\n                parts = message[\"auth\"].split(\":\")\n                if not len(parts) == 2:\n                    raise ValueError()\n            except ValueError:\n                self._logger.warning(\n                    \"Got invalid auth message from client {}, ignoring: {!r}\".format(\n                        self._remoteAddress, message[\"auth\"]\n                    )\n                )\n            else:\n                user_id, user_session = parts\n\n                if self._userManager.validate_user_session(user_id, user_session):\n                    user = self._userManager.find_user(\n                        userid=user_id, session=user_session\n                    )\n                    self._on_login(user)\n                else:\n                    self._logger.warning(\n                        f\"Unknown user/session combo: {user_id}:{user_session}\"\n                    )\n                    self._on_logout()\n\n            self._register()\n\n        elif \"throttle\" in message:\n            try:\n                throttle = int(message[\"throttle\"])\n                if throttle < 1:\n                    raise ValueError()\n            except ValueError:\n                self._logger.warning(\n                    \"Got invalid throttle factor from client {}, ignoring: {!r}\".format(\n                        self._remoteAddress, message[\"throttle\"]\n                    )\n                )\n            else:\n                self._throttle_factor = throttle\n                self._logger.debug(\n                    \"Set throttle factor for client {} to {}\".format(\n                        self._remoteAddress, self._throttle_factor\n                    )\n                )\n\n        elif \"subscribe\" in message:\n            if not self._subscriptions_active:\n                self._subscriptions_active = True\n                self._logger.debug(\"Client makes use of subscriptions\")\n\n            def list_or_boolean(value):\n                if isinstance(value, list):\n                    return value\n                elif isinstance(value, bool):\n                    return [] if not value else None\n                else:\n                    raise ValueError(\"value must be a list or boolean\")\n\n            def regex_or_boolean(value):\n                if isinstance(value, str):\n                    try:\n                        return re.compile(value)\n                    except Exception:\n                        raise ValueError(\"value must be a valid regex\")\n                elif isinstance(value, bool):\n                    return value\n                else:\n                    raise ValueError(\"value must be a string or boolean\")\n\n            try:\n                subscribe = message[\"subscribe\"]\n\n                state = subscribe.get(\"state\", False)\n                if isinstance(state, bool):\n                    if state:\n                        state = {\"logs\": True, \"messages\": False}\n                elif isinstance(state, dict):\n                    logs = regex_or_boolean(state.get(\"logs\", False))\n                    messages = regex_or_boolean(state.get(\"messages\", False))\n                    state = {\n                        \"logs\": logs,\n                        \"messages\": messages,\n                    }\n\n                plugins = list_or_boolean(subscribe.get(\"plugins\", []))\n                events = list_or_boolean(subscribe.get(\"events\", []))\n\n            except ValueError as e:\n                self._logger.warning(\n                    \"Got invalid subscription message from client {}, ignoring: {!r} ({}) \".format(\n                        self._remoteAddress, message[\"subscribe\"], str(e)\n                    )\n                )\n            else:\n                old_state = self._subscriptions[\"state\"]\n                self._subscriptions[\"state\"] = state\n                self._subscriptions[\"plugins\"] = plugins\n                self._subscriptions[\"events\"] = events\n\n                if state and not old_state:\n                    # trigger initial data\n                    self._printer.send_initial_callback(self)\n                elif old_state and not state:\n                    self._initial_data_sent = False\n\n    def on_printer_send_current_data(self, data):\n        if not self._user.has_permission(Permissions.STATUS):\n            return\n\n        if self._subscriptions_active and not self._subscriptions[\"state\"]:\n            return\n\n        if not self._initial_data_sent:\n            self._logger.debug(\"Initial data not yet send, dropping current message\")\n            return\n\n        # make sure we rate limit the updates according to our throttle factor\n        with self._held_back_mutex:\n            if self._held_back_current is not None:\n                self._held_back_current.cancel()\n                self._held_back_current = None\n\n            now = time.time()\n            delta = (\n                self._last_current + self._base_rate_limit * self._throttle_factor - now\n            )\n            if delta > 0:\n                self._held_back_current = threading.Timer(\n                    delta, lambda: self.on_printer_send_current_data(data)\n                )\n                self._held_back_current.start()\n                return\n\n        self._last_current = now\n\n        # add current temperature, log and message backlogs to sent data\n        with self._temperatureBacklogMutex:\n            temperatures = self._temperatureBacklog\n            self._temperatureBacklog = []\n\n        with self._logBacklogMutex:\n            logs = self._filter_logs(self._logBacklog)\n            self._logBacklog = []\n\n        with self._messageBacklogMutex:\n            messages = self._filter_messages(self._messageBacklog)\n            self._messageBacklog = []\n\n        busy_files = [\n            {\"origin\": v[0], \"path\": v[1]} for v in self._fileManager.get_busy_files()\n        ]\n        if (\n            \"job\" in data\n            and data[\"job\"] is not None\n            and \"file\" in data[\"job\"]\n            and \"path\" in data[\"job\"][\"file\"]\n            and \"origin\" in data[\"job\"][\"file\"]\n            and data[\"job\"][\"file\"][\"path\"] is not None\n            and data[\"job\"][\"file\"][\"origin\"] is not None\n            and (self._printer.is_printing() or self._printer.is_paused())\n        ):\n            busy_files.append(\n                {\n                    \"origin\": data[\"job\"][\"file\"][\"origin\"],\n                    \"path\": data[\"job\"][\"file\"][\"path\"],\n                }\n            )\n\n        data.update(\n            {\n                \"serverTime\": time.time(),\n                \"temps\": temperatures,\n                \"logs\": self._filter_logs(logs),\n                \"messages\": messages,\n                \"busyFiles\": busy_files,\n                \"markings\": list(self._printer.get_markings()),\n            }\n        )\n        self._emit(\"current\", payload=data)\n\n    def on_printer_send_initial_data(self, data):\n        self._initial_data_sent = True\n        if self._subscriptions_active and not self._subscriptions[\"state\"]:\n            self._logger.debug(\"Not subscribed to state, dropping history\")\n            return\n\n        data_to_send = dict(data)\n        data_to_send[\"logs\"] = self._filter_logs(data_to_send.get(\"logs\", []))\n        data_to_send[\"messages\"] = self._filter_messages(data_to_send.get(\"messages\", []))\n        data_to_send[\"serverTime\"] = time.time()\n        self._emit(\"history\", payload=data_to_send)\n\n    def _filter_state_subscription(self, sub, values):\n        if not self._subscriptions_active or self._subscriptions[\"state\"][sub] is True:\n            return values\n\n        if self._subscriptions[\"state\"][sub] is False:\n            return []\n\n        return [line for line in values if self._subscriptions[\"state\"][sub].search(line)]\n\n    def _filter_logs(self, logs):\n        return self._filter_state_subscription(\"logs\", logs)\n\n    def _filter_messages(self, messages):\n        return self._filter_state_subscription(\"messages\", messages)\n\n    def sendEvent(self, type, payload=None):\n        permissions = self._event_permissions.get(type, self._event_permissions[\"*\"])\n        permissions = [x(self._user) if callable(x) else x for x in permissions]\n        if not self._user or not all(\n            map(lambda p: self._user.has_permission(p), permissions)\n        ):\n            return\n\n        processors = self._event_payload_processors.get(\n            type, self._event_payload_processors[\"*\"]\n        )\n        for processor in processors:\n            payload = processor(self._user, payload)\n\n        self._emit(\"event\", payload={\"type\": type, \"payload\": payload})\n\n    def sendTimelapseConfig(self, timelapseConfig):\n        self._emit(\"timelapse\", payload=timelapseConfig)\n\n    def sendSlicingProgress(\n        self, slicer, source_location, source_path, dest_location, dest_path, progress\n    ):\n        self._emit(\n            \"slicingProgress\",\n            payload={\n                \"slicer\": slicer,\n                \"source_location\": source_location,\n                \"source_path\": source_path,\n                \"dest_location\": dest_location,\n                \"dest_path\": dest_path,\n                \"progress\": progress,\n            },\n        )\n\n    def sendRenderProgress(self, progress):\n        self._emit(\"renderProgress\", {\"progress\": progress})\n\n    def on_plugin_message(self, plugin, data, permissions=None):\n        if (\n            self._subscriptions_active\n            and self._subscriptions[\"plugins\"] is not None\n            and plugin not in self._subscriptions[\"plugins\"]\n        ):\n            return\n\n        self._emit(\n            \"plugin\", payload={\"plugin\": plugin, \"data\": data}, permissions=permissions\n        )\n\n    def on_printer_add_log(self, data):\n        with self._logBacklogMutex:\n            self._logBacklog.append(data)\n\n    def on_printer_add_message(self, data):\n        with self._messageBacklogMutex:\n            self._messageBacklog.append(data)\n\n    def on_printer_add_temperature(self, data):\n        with self._temperatureBacklogMutex:\n            self._temperatureBacklog.append(data)\n\n    def on_user_logged_out(self, user, stale=False):\n        if (\n            user.get_id() == self._user.get_id()\n            and hasattr(user, \"session\")\n            and hasattr(self._user, \"session\")\n            and user.session == self._user.session\n        ):\n            self._logger.info(f\"User {user.get_id()} logged out, logging out on socket\")\n            self._on_logout()\n\n            if stale:\n                self._sendReauthRequired(\"stale\")\n            else:\n                self._sendReauthRequired(\"logout\")\n\n    def on_user_modified(self, user):\n        if user.get_id() == self._user.get_id():\n            self._sendReauthRequired(\"modified\")\n\n    def on_user_removed(self, userid):\n        if self._user.get_id() == userid:\n            self._logger.info(f\"User {userid} deleted, logging out on socket\")\n            self._on_logout()\n            self._sendReauthRequired(\"removed\")\n\n    def on_group_permissions_changed(self, group, added=None, removed=None):\n        if self._user.is_anonymous and group == self._groupManager.guest_group:\n            self._sendReauthRequired(\"modified\")\n\n    def on_group_subgroups_changed(self, group, added=None, removed=None):\n        if self._user.is_anonymous and group == self._groupManager.guest_group:\n            self._sendReauthRequired(\"modified\")\n\n    def _onEvent(self, event, payload):\n        if (\n            self._subscriptions_active\n            and self._subscriptions[\"events\"] is not None\n            and event not in self._subscriptions[\"events\"]\n        ):\n            return\n\n        self.sendEvent(event, payload)\n\n    def _register(self):\n        \"\"\"Register this socket with the system if STATUS permission is available.\"\"\"\n\n        proceed = True\n        for name, hook in self._register_hooks.items():\n            try:\n                proceed = proceed and hook(self, self._user)\n            except Exception:\n                self._logger.exception(\n                    f\"Error processing register hook handler for plugin {name}\",\n                    extra={\"plugin\": name},\n                )\n\n        if not proceed:\n            return\n\n        if self._registered:\n            return\n\n        if not self._user.has_permission(Permissions.STATUS):\n            return\n\n        # printer\n        self._printer.register_callback(self)\n        self._printer.send_initial_callback(self)\n\n        # files\n        self._fileManager.register_slicingprogress_callback(self)\n\n        # events\n        for event in octoprint.events.all_events():\n            self._eventManager.subscribe(event, self._onEvent)\n\n        # timelapse\n        octoprint.timelapse.register_callback(self)\n        octoprint.timelapse.notify_callback(self, timelapse=octoprint.timelapse.current)\n        if octoprint.timelapse.current_render_job is not None:\n            # This is a horrible hack for now to allow displaying a notification that a render job is still\n            # active in the backend on a fresh connect of a client. This needs to be substituted with a proper\n            # job management for timelapse rendering, analysis stuff etc that also gets cancelled when prints\n            # start and so on.\n            #\n            # For now this is the easiest way though to at least inform the user that a timelapse is still ongoing.\n            #\n            # TODO remove when central job management becomes available and takes care of this for us\n            self.sendEvent(\n                Events.MOVIE_RENDERING, payload=octoprint.timelapse.current_render_job\n            )\n        self._registered = True\n\n    def _unregister(self):\n        \"\"\"Unregister this socket from the system\"\"\"\n\n        self._printer.unregister_callback(self)\n        self._fileManager.unregister_slicingprogress_callback(self)\n        octoprint.timelapse.unregister_callback(self)\n        for event in octoprint.events.all_events():\n            self._eventManager.unsubscribe(event, self._onEvent)\n\n    def _reregister(self):\n        \"\"\"Unregister and register again\"\"\"\n        self._unregister()\n        self._register()\n\n    def _sendReauthRequired(self, reason):\n        self._emit(\"reauthRequired\", payload={\"reason\": reason})\n\n    def _emit(self, type, payload=None, permissions=None):\n        proceed = True\n        for name, hook in self._emit_hooks.items():\n            try:\n                proceed = proceed and hook(self, self._user, type, payload)\n            except Exception:\n                self._logger.exception(\n                    f\"Error processing emit hook handler from plugin {name}\",\n                    extra={\"plugin\": name},\n                )\n\n        if not proceed:\n            return\n\n        if permissions is None:\n            permissions = self._emit_permissions.get(type, self._emit_permissions[\"*\"])\n            permissions = (\n                permissions(payload)\n                if callable(permissions)\n                else [x for x in permissions]\n            )\n\n        if not self._user or not all(\n            map(lambda p: self._user.has_permission(p), permissions)\n        ):\n            if not self._authed:\n                with self._unauthed_backlog_mutex:\n                    if len(self._unauthed_backlog) < self._unauthed_backlog_max:\n                        self._unauthed_backlog.append((type, payload))\n                        self._logger.debug(\n                            \"Socket message held back until permissions cleared, added to backlog: {}\".format(\n                                type\n                            )\n                        )\n                    else:\n                        self._logger.debug(\n                            \"Socket message held back, but backlog full. Throwing message away: {}\".format(\n                                type\n                            )\n                        )\n            return\n\n        self._do_emit(type, payload)\n\n    def _do_emit(self, type, payload):\n        try:\n            self.send({type: payload})\n        except Exception as e:\n            if self._logger.isEnabledFor(logging.DEBUG):\n                self._logger.exception(\n                    f\"Could not send message to client {self._remoteAddress}\"\n                )\n            else:\n                self._logger.warning(\n                    \"Could not send message to client {}: {}\".format(\n                        self._remoteAddress, e\n                    )\n                )\n\n    def _on_login(self, user):\n        self._user = user\n        self._logger.info(\n            \"User {} logged in on the socket from client {}\".format(\n                user.get_name(), self._remoteAddress\n            )\n        )\n        self._authed = True\n\n        for name, hook in self._authed_hooks.items():\n            try:\n                hook(self, self._user)\n            except Exception:\n                self._logger.exception(\n                    f\"Error processing authed hook handler for plugin {name}\",\n                    extra={\"plugin\": name},\n                )\n\n        # if we have a backlog from being unauthed, process that now\n        with self._unauthed_backlog_mutex:\n            backlog = self._unauthed_backlog\n            self._unauthed_backlog = []\n\n        if len(backlog):\n            self._logger.debug(\n                \"Sending {} messages on the socket that were held back\".format(\n                    len(backlog)\n                )\n            )\n            for message, payload in backlog:\n                self._do_emit(message, payload)\n\n        # trigger ClientAuthed event\n        octoprint.events.eventManager().fire(\n            octoprint.events.Events.CLIENT_AUTHED,\n            payload={\"username\": user.get_name(), \"remoteAddress\": self._remoteAddress},\n        )\n\n    def _on_logout(self):\n        self._user = self._userManager.anonymous_user_factory()\n        self._authed = False\n\n        for name, hook in self._authed_hooks.items():\n            try:\n                hook(self, self._user)\n            except Exception:\n                self._logger.exception(\n                    f\"Error processing authed hook handler for plugin {name}\",\n                    extra={\"plugin\": name},\n                )\n", "$(function () {\n    function UserSettingsViewModel(parameters) {\n        var self = this;\n\n        self.loginState = parameters[0];\n        self.access = parameters[1];\n\n        self.users = self.access.users;\n\n        self.userSettingsDialog = undefined;\n\n        var auto_locale = {\n            language: \"_default\",\n            display: gettext(\"Site default\"),\n            english: undefined\n        };\n        self.locales = ko.observableArray(\n            [auto_locale].concat(\n                _.sortBy(_.values(AVAILABLE_LOCALES), function (n) {\n                    return n.display;\n                })\n            )\n        );\n        self.locale_languages = _.keys(AVAILABLE_LOCALES);\n\n        self.access_password = ko.observable(undefined);\n        self.access_repeatedPassword = ko.observable(undefined);\n        self.access_currentPassword = ko.observable(undefined);\n        self.access_currentPasswordMismatch = ko.observable(false);\n        self.access_apikey = ko.observable(undefined);\n        self.interface_language = ko.observable(undefined);\n\n        self.currentUser = ko.observable(undefined);\n        self.currentUser.subscribe(function (newUser) {\n            self.access_password(undefined);\n            self.access_repeatedPassword(undefined);\n            self.access_currentPassword(undefined);\n            self.access_currentPasswordMismatch(false);\n            self.access_apikey(undefined);\n            self.interface_language(\"_default\");\n\n            if (newUser !== undefined) {\n                self.access_apikey(newUser.apikey);\n                if (\n                    newUser.settings.hasOwnProperty(\"interface\") &&\n                    newUser.settings.interface.hasOwnProperty(\"language\")\n                ) {\n                    self.interface_language(newUser.settings.interface.language);\n                }\n            }\n        });\n        self.access_currentPassword.subscribe(function () {\n            self.access_currentPasswordMismatch(false);\n        });\n\n        self.passwordMismatch = ko.pureComputed(function () {\n            return self.access_password() !== self.access_repeatedPassword();\n        });\n\n        self.show = function (user) {\n            if (!CONFIG_ACCESS_CONTROL) return;\n\n            if (user === undefined) {\n                user = self.loginState.currentUser();\n            }\n\n            var process = function (user) {\n                self.currentUser(user);\n                self.userSettingsDialog.modal(\"show\");\n            };\n\n            // make sure we have the current user data, see #2534\n            OctoPrint.access.users\n                .get(user.name)\n                .done(function (data) {\n                    process(data);\n                })\n                .fail(function () {\n                    log.warn(\n                        \"Could not fetch current user data, proceeding with client side data copy\"\n                    );\n                    process(user);\n                });\n        };\n\n        self.save = function () {\n            if (!CONFIG_ACCESS_CONTROL) return;\n\n            self.userSettingsDialog.trigger(\"beforeSave\");\n\n            function process() {\n                var settings = {\n                    interface: {\n                        language: self.interface_language()\n                    }\n                };\n                self.updateSettings(self.currentUser().name, settings).done(function () {\n                    // close dialog\n                    self.currentUser(undefined);\n                    self.userSettingsDialog.modal(\"hide\");\n                    self.loginState.reloadUser();\n                });\n            }\n\n            if (self.access_password() && !self.passwordMismatch()) {\n                self.users\n                    .updatePassword(\n                        self.currentUser().name,\n                        self.access_password(),\n                        self.access_currentPassword()\n                    )\n                    .done(function () {\n                        process();\n                    })\n                    .fail(function (xhr) {\n                        if (xhr.status === 403) {\n                            self.access_currentPasswordMismatch(true);\n                        }\n                    });\n            } else {\n                process();\n            }\n        };\n\n        self.copyApikey = function () {\n            copyToClipboard(self.access_apikey());\n        };\n\n        self.generateApikey = function () {\n            if (!CONFIG_ACCESS_CONTROL) return;\n\n            var generate = function () {\n                self.users\n                    .generateApikey(self.currentUser().name)\n                    .done(function (response) {\n                        self.access_apikey(response.apikey);\n                    });\n            };\n\n            if (self.access_apikey()) {\n                showConfirmationDialog(\n                    gettext(\n                        \"This will generate a new API Key. The old API Key will cease to function immediately.\"\n                    ),\n                    generate\n                );\n            } else {\n                generate();\n            }\n        };\n\n        self.deleteApikey = function () {\n            if (!CONFIG_ACCESS_CONTROL) return;\n            if (!self.access_apikey()) return;\n\n            showConfirmationDialog(\n                gettext(\n                    \"This will delete the API Key. It will cease to to function immediately.\"\n                ),\n                function () {\n                    self.users.deleteApikey(self.currentUser().name).done(function () {\n                        self.access_apikey(undefined);\n                    });\n                }\n            );\n        };\n\n        self.updateSettings = function (username, settings) {\n            return OctoPrint.access.users.saveSettings(username, settings);\n        };\n\n        self.saveEnabled = function () {\n            return !self.passwordMismatch();\n        };\n\n        self.onStartup = function () {\n            self.userSettingsDialog = $(\"#usersettings_dialog\");\n        };\n\n        self.onAllBound = function (allViewModels) {\n            self.userSettingsDialog.on(\"show\", function () {\n                callViewModels(allViewModels, \"onUserSettingsShown\");\n            });\n            self.userSettingsDialog.on(\"hidden\", function () {\n                callViewModels(allViewModels, \"onUserSettingsHidden\");\n            });\n            self.userSettingsDialog.on(\"beforeSave\", function () {\n                callViewModels(allViewModels, \"onUserSettingsBeforeSave\");\n            });\n        };\n    }\n\n    OCTOPRINT_VIEWMODELS.push({\n        construct: UserSettingsViewModel,\n        dependencies: [\"loginStateViewModel\", \"accessViewModel\"],\n        elements: [\"#usersettings_dialog\"]\n    });\n});\n", "<form class=\"form-horizontal\" onsubmit=\"return false;\">\n    <fieldset>\n        <legend>{{ _('Password') }}</legend>\n        <p>\n            {{ _('If you do not wish to change your password, just leave the following fields empty.') }}\n        </p>\n        <div class=\"control-group\" data-bind=\"css: {error: access_currentPasswordMismatch()}\">\n            <label class=\"control-label\" for=\"userSettings-access_currentPassword\">{{ _('Current Password') }}</label>\n            <div class=\"controls\">\n                <input type=\"password\" class=\"input-block-level\" id=\"userSettings-access_currentPassword\" data-bind=\"value: access_currentPassword, valueUpdate: 'afterkeydown'\" required>\n                <span class=\"help-inline\" data-bind=\"visible: access_currentPasswordMismatch()\">{{ _('Passwords do not match') }}</span>\n            </div>\n        </div>\n        <div class=\"control-group\">\n            <label class=\"control-label\" for=\"userSettings-access_password\">{{ _('New Password') }}</label>\n            <div class=\"controls\">\n                <input type=\"password\" class=\"input-block-level\" id=\"userSettings-access_password\" data-bind=\"value: access_password\" required>\n            </div>\n        </div>\n        <div class=\"control-group\" data-bind=\"css: {error: passwordMismatch()}\">\n            <label class=\"control-label\" for=\"userSettings-access_repeatedPassword\">{{ _('Repeat Password') }}</label>\n            <div class=\"controls\">\n                <input type=\"password\" class=\"input-block-level\" id=\"userSettings-access_repeatedPassword\" data-bind=\"value: access_repeatedPassword, valueUpdate: 'afterkeydown'\" required>\n                <span class=\"help-inline\" data-bind=\"visible: passwordMismatch()\">{{ _('Passwords do not match') }}</span>\n            </div>\n        </div>\n    </fieldset>\n    <fieldset>\n        <legend>{{ _('API Key') }}</legend>\n        <div class=\"control-group\">\n            <label class=\"control-label\" for=\"userSettings-access_apikey\">{{ _('Current API Key') }}</label>\n            <div class=\"controls\">\n                <div class=\"input-append input-block-level\">\n                    <input type=\"text\" readonly=\"readonly\" id=\"userSettings-access_apikey\" data-bind=\"value: access_apikey, attr: {placeholder: '{{ _('N/A')|esq }}'}\">\n                    <a class=\"btn add-on\" title=\"Copy API Key to clipboard\" data-bind=\"click: copyApikey, css: {'disabled': !access_apikey()}\"><i class=\"fas fa-copy\"></i></a>\n                    <a class=\"btn add-on\" title=\"Generate new API Key\" data-bind=\"click: generateApikey\"><i class=\"fas fa-sync\"></i></a>\n                    <a class=\"btn btn-danger add-on\" title=\"Delete API Key\" data-bind=\"click: deleteApikey, css: {'disabled': !access_apikey()}\"><i class=\"far fa-trash-alt\"></i></a>\n                </div>\n                <span class=\"help-block\">{{ _('Please note that changes to the API key are applied immediately, without having to \"Confirm\" first.') }}</span>\n            </div>\n        </div>\n        <div class=\"control-group\" data-bind=\"visible: access_apikey\">\n            <label class=\"control-label\">{{ _('QR Code') }}</label>\n            <div class=\"controls\">\n                <div data-bind=\"qrcode: {text: access_apikey, size: 150}\"></div>\n            </div>\n        </div>\n    </fieldset>\n</form>\n", "\"\"\"\nUnit tests for ``octoprint.server.util.flask``.\n\"\"\"\n\n__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"\n__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"\n__copyright__ = \"Copyright (C) 2016 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n\n\nimport unittest\nfrom unittest import mock\n\nfrom ddt import data, ddt, unpack\n\nfrom octoprint.server.util.flask import (\n    OctoPrintFlaskRequest,\n    OctoPrintFlaskResponse,\n    ReverseProxiedEnvironment,\n)\n\nstandard_environ = {\n    \"HTTP_HOST\": \"localhost:5000\",\n    \"SERVER_NAME\": \"localhost\",\n    \"SERVER_PORT\": \"5000\",\n    \"SCRIPT_NAME\": \"\",\n    \"PATH_INFO\": \"/\",\n    \"wsgi.url_scheme\": \"http\",\n}\n\n\n@ddt\nclass ReverseProxiedEnvironmentTest(unittest.TestCase):\n    @data(\n        # defaults\n        ({}, {}),\n        # prefix set, path info not prefixed\n        (\n            {\"HTTP_X_SCRIPT_NAME\": \"/octoprint\", \"PATH_INFO\": \"/static/online.gif\"},\n            {\"SCRIPT_NAME\": \"/octoprint\"},\n        ),\n        # prefix set, path info prefixed\n        (\n            {\n                \"HTTP_X_SCRIPT_NAME\": \"/octoprint\",\n                \"PATH_INFO\": \"/octoprint/static/online.gif\",\n            },\n            {\"SCRIPT_NAME\": \"/octoprint\", \"PATH_INFO\": \"/static/online.gif\"},\n        ),\n        # host set\n        (\n            {\"HTTP_X_FORWARDED_HOST\": \"example.com\"},\n            {\n                \"HTTP_HOST\": \"example.com\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"80\",\n            },\n        ),\n        # host set with port\n        (\n            {\"HTTP_X_FORWARDED_HOST\": \"example.com:1234\"},\n            {\n                \"HTTP_HOST\": \"example.com:1234\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"1234\",\n            },\n        ),\n        # host and scheme set\n        (\n            {\"HTTP_X_FORWARDED_HOST\": \"example.com\", \"HTTP_X_FORWARDED_PROTO\": \"https\"},\n            {\n                \"HTTP_HOST\": \"example.com\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"443\",\n                \"wsgi.url_scheme\": \"https\",\n            },\n        ),\n        # host and scheme 2 set\n        (\n            {\"HTTP_X_FORWARDED_HOST\": \"example.com\", \"HTTP_X_SCHEME\": \"https\"},\n            {\n                \"HTTP_HOST\": \"example.com\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"443\",\n                \"wsgi.url_scheme\": \"https\",\n            },\n        ),\n        # host, server and port headers set -> only host wins\n        (\n            {\n                \"HTTP_X_FORWARDED_HOST\": \"example.com\",\n                \"HTTP_X_FORWARDED_SERVER\": \"example2.com\",\n                \"HTTP_X_FORWARDED_PORT\": \"444\",\n                \"HTTP_X_FORWARDED_PROTO\": \"https\",\n            },\n            {\n                \"HTTP_HOST\": \"example.com\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"443\",\n                \"wsgi.url_scheme\": \"https\",\n            },\n        ),\n        # host set, server and port differ -> updated, standard port\n        (\n            {\n                \"HTTP_HOST\": \"example.com\",\n                \"wsgi.url_scheme\": \"https\",\n                \"SERVER_NAME\": \"localhost\",\n                \"SERVER_PORT\": \"80\",\n            },\n            {\n                \"HTTP_HOST\": \"example.com\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"443\",\n            },\n        ),\n        # host set, server and port differ -> updated, non standard port\n        (\n            {\n                \"HTTP_HOST\": \"example.com:444\",\n                \"wsgi.url_scheme\": \"https\",\n                \"SERVER_NAME\": \"localhost\",\n                \"SERVER_PORT\": \"80\",\n            },\n            {\n                \"HTTP_HOST\": \"example.com:444\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"444\",\n            },\n        ),\n        # multiple scheme entries -> only use first one\n        (\n            {\n                \"HTTP_X_FORWARDED_PROTO\": \"https,http\",\n            },\n            {\"wsgi.url_scheme\": \"https\"},\n        ),\n        # host = none (should never happen but you never know) -> server & port used for reconstruction\n        (\n            {\n                \"HTTP_HOST\": None,\n                \"HTTP_X_FORWARDED_SERVER\": \"example.com\",\n                \"HTTP_X_FORWARDED_PORT\": \"80\",\n            },\n            {\n                \"HTTP_HOST\": \"example.com\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"80\",\n            },\n        ),\n        # host = none, default port -> server & port used for reconstruction (ipv4)\n        (\n            {\"HTTP_HOST\": None, \"SERVER_NAME\": \"127.0.0.1\", \"SERVER_PORT\": \"80\"},\n            {\"HTTP_HOST\": \"127.0.0.1\", \"SERVER_NAME\": \"127.0.0.1\", \"SERVER_PORT\": \"80\"},\n        ),\n        # host = none, non standard port -> server & port used for reconstruction (ipv4)\n        (\n            {\"HTTP_HOST\": None, \"SERVER_NAME\": \"127.0.0.1\", \"SERVER_PORT\": \"444\"},\n            {\n                \"HTTP_HOST\": \"127.0.0.1:444\",\n                \"SERVER_NAME\": \"127.0.0.1\",\n                \"SERVER_PORT\": \"444\",\n            },\n        ),\n        # host = none, default port -> server & port used for reconstruction (ipv6)\n        (\n            {\"HTTP_HOST\": None, \"SERVER_NAME\": \"fec1::1\", \"SERVER_PORT\": \"80\"},\n            {\"HTTP_HOST\": \"fec1::1\", \"SERVER_NAME\": \"fec1::1\", \"SERVER_PORT\": \"80\"},\n        ),\n        # host = none, non standard port -> server & port used for reconstruction (ipv6)\n        (\n            {\"HTTP_HOST\": None, \"SERVER_NAME\": \"fec1::1\", \"SERVER_PORT\": \"444\"},\n            {\n                \"HTTP_HOST\": \"[fec1::1]:444\",\n                \"SERVER_NAME\": \"fec1::1\",\n                \"SERVER_PORT\": \"444\",\n            },\n        ),\n        # host set, server and port not, default port -> server & port derived from host (ipv4)\n        (\n            {\"HTTP_HOST\": \"127.0.0.1\", \"SERVER_NAME\": None, \"SERVER_PORT\": None},\n            {\"HTTP_HOST\": \"127.0.0.1\", \"SERVER_NAME\": \"127.0.0.1\", \"SERVER_PORT\": \"80\"},\n        ),\n        # host set, server and port not, non standard port -> server & port derived from host (ipv4)\n        (\n            {\"HTTP_HOST\": \"127.0.0.1:444\", \"SERVER_NAME\": None, \"SERVER_PORT\": None},\n            {\n                \"HTTP_HOST\": \"127.0.0.1:444\",\n                \"SERVER_NAME\": \"127.0.0.1\",\n                \"SERVER_PORT\": \"444\",\n            },\n        ),\n        # host set, server and port not, default port -> server & port derived from host (ipv6)\n        (\n            {\"HTTP_HOST\": \"fec1::1\", \"SERVER_NAME\": None, \"SERVER_PORT\": None},\n            {\"HTTP_HOST\": \"fec1::1\", \"SERVER_NAME\": \"fec1::1\", \"SERVER_PORT\": \"80\"},\n        ),\n        # host set, server and port not, non standard port -> server & port derived from host (ipv6)\n        (\n            {\"HTTP_HOST\": \"[fec1::1]:444\", \"SERVER_NAME\": None, \"SERVER_PORT\": None},\n            {\n                \"HTTP_HOST\": \"[fec1::1]:444\",\n                \"SERVER_NAME\": \"fec1::1\",\n                \"SERVER_PORT\": \"444\",\n            },\n        ),\n    )\n    @unpack\n    def test_stock(self, environ, expected):\n        reverse_proxied = ReverseProxiedEnvironment()\n\n        merged_environ = dict(standard_environ)\n        merged_environ.update(environ)\n\n        actual = reverse_proxied(merged_environ)\n\n        merged_expected = dict(standard_environ)\n        merged_expected.update(environ)\n        merged_expected.update(expected)\n\n        self.assertDictEqual(merged_expected, actual)\n\n    @data(\n        # server and port headers set -> host derived with port\n        (\n            {\n                \"SERVER_NAME\": \"example2.com\",\n                \"SERVER_PORT\": \"444\",\n                \"HTTP_X_FORWARDED_PROTO\": \"https\",\n            },\n            {\n                \"HTTP_HOST\": \"example2.com:444\",\n                \"SERVER_NAME\": \"example2.com\",\n                \"SERVER_PORT\": \"444\",\n                \"wsgi.url_scheme\": \"https\",\n            },\n        ),\n        # server and port headers set, standard port -> host derived, no port\n        (\n            {\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"80\",\n            },\n            {\n                \"HTTP_HOST\": \"example.com\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"80\",\n            },\n        ),\n        # server and port forwarded headers set -> host derived with port\n        (\n            {\n                \"HTTP_X_FORWARDED_SERVER\": \"example2.com\",\n                \"HTTP_X_FORWARDED_PORT\": \"444\",\n                \"HTTP_X_FORWARDED_PROTO\": \"https\",\n            },\n            {\n                \"HTTP_HOST\": \"example2.com:444\",\n                \"SERVER_NAME\": \"example2.com\",\n                \"SERVER_PORT\": \"444\",\n                \"wsgi.url_scheme\": \"https\",\n            },\n        ),\n        # server and port forwarded headers set, standard port -> host derived, no port\n        (\n            {\n                \"HTTP_X_FORWARDED_SERVER\": \"example.com\",\n                \"HTTP_X_FORWARDED_PORT\": \"80\",\n            },\n            {\n                \"HTTP_HOST\": \"example.com\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"80\",\n            },\n        ),\n    )\n    @unpack\n    def test_nohost(self, environ, expected):\n        reverse_proxied = ReverseProxiedEnvironment()\n\n        merged_environ = dict(standard_environ)\n        merged_environ.update(environ)\n        del merged_environ[\"HTTP_HOST\"]\n\n        actual = reverse_proxied(merged_environ)\n\n        merged_expected = dict(standard_environ)\n        merged_expected.update(environ)\n        merged_expected.update(expected)\n\n        self.assertDictEqual(merged_expected, actual)\n\n    @data(\n        # prefix overridden\n        (\n            {\"prefix\": \"fallback_prefix\"},\n            {},\n            {\n                \"SCRIPT_NAME\": \"fallback_prefix\",\n            },\n        ),\n        # scheme overridden\n        ({\"scheme\": \"https\"}, {}, {\"wsgi.url_scheme\": \"https\"}),\n        # host overridden, default port\n        (\n            {\"host\": \"example.com\"},\n            {},\n            {\n                \"HTTP_HOST\": \"example.com\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"80\",\n            },\n        ),\n        # host overridden, included port\n        (\n            {\"host\": \"example.com:81\"},\n            {},\n            {\n                \"HTTP_HOST\": \"example.com:81\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"81\",\n            },\n        ),\n        # prefix not really overridden, forwarded headers take precedence\n        ({\"prefix\": \"/octoprint\"}, {\"HTTP_X_SCRIPT_NAME\": \"\"}, {}),\n        # scheme not really overridden, forwarded headers take precedence\n        ({\"scheme\": \"https\"}, {\"HTTP_X_FORWARDED_PROTO\": \"http\"}, {}),\n        # scheme 2 not really overridden, forwarded headers take precedence\n        ({\"scheme\": \"https\"}, {\"HTTP_X_SCHEME\": \"http\"}, {}),\n        # host not really overridden, forwarded headers take precedence\n        ({\"host\": \"example.com:444\"}, {\"HTTP_X_FORWARDED_HOST\": \"localhost:5000\"}, {}),\n        # server not really overridden, forwarded headers take precedence\n        ({\"server\": \"example.com\"}, {\"HTTP_X_FORWARDED_SERVER\": \"localhost\"}, {}),\n        # port not really overridden, forwarded headers take precedence\n        ({\"port\": \"444\"}, {\"HTTP_X_FORWARDED_PORT\": \"5000\"}, {}),\n        # server and port not really overridden, Host header wins\n        ({\"server\": \"example.com\", \"port\": \"80\"}, {}, {}),\n    )\n    @unpack\n    def test_fallbacks(self, fallbacks, environ, expected):\n        reverse_proxied = ReverseProxiedEnvironment(**fallbacks)\n\n        merged_environ = dict(standard_environ)\n        merged_environ.update(environ)\n\n        actual = reverse_proxied(merged_environ)\n\n        merged_expected = dict(standard_environ)\n        merged_expected.update(environ)\n        merged_expected.update(expected)\n\n        self.assertDictEqual(merged_expected, actual)\n\n    @data(\n        # server overridden\n        (\n            {\"server\": \"example.com\"},\n            {},\n            {\n                \"HTTP_HOST\": \"example.com:5000\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"5000\",\n            },\n        ),\n        # port overridden, standard port\n        ({\"port\": \"80\"}, {}, {\"HTTP_HOST\": \"localhost\", \"SERVER_PORT\": \"80\"}),\n        # port overridden, non standard port\n        ({\"port\": \"81\"}, {}, {\"HTTP_HOST\": \"localhost:81\", \"SERVER_PORT\": \"81\"}),\n        # server and port overridden, default port\n        (\n            {\"server\": \"example.com\", \"port\": \"80\"},\n            {},\n            {\n                \"HTTP_HOST\": \"example.com\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"80\",\n            },\n        ),\n        # server and port overridden, non default port\n        (\n            {\"server\": \"example.com\", \"port\": \"81\"},\n            {},\n            {\n                \"HTTP_HOST\": \"example.com:81\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"81\",\n            },\n        ),\n    )\n    @unpack\n    def test_fallbacks_nohost(self, fallbacks, environ, expected):\n        reverse_proxied = ReverseProxiedEnvironment(**fallbacks)\n\n        merged_environ = dict(standard_environ)\n        merged_environ.update(environ)\n        del merged_environ[\"HTTP_HOST\"]\n\n        actual = reverse_proxied(merged_environ)\n\n        merged_expected = dict(standard_environ)\n        merged_expected.update(environ)\n        merged_expected.update(expected)\n\n        self.assertDictEqual(merged_expected, actual)\n\n    def test_header_config_ok(self):\n        result = ReverseProxiedEnvironment.to_header_candidates(\n            [\"prefix-header1\", \"prefix-header2\"]\n        )\n        self.assertSetEqual(set(result), {\"HTTP_PREFIX_HEADER1\", \"HTTP_PREFIX_HEADER2\"})\n\n    def test_header_config_string(self):\n        result = ReverseProxiedEnvironment.to_header_candidates(\"prefix-header\")\n        self.assertSetEqual(set(result), {\"HTTP_PREFIX_HEADER\"})\n\n    def test_header_config_none(self):\n        result = ReverseProxiedEnvironment.to_header_candidates(None)\n        self.assertEqual(result, [])\n\n\n##~~\n\n\nclass OctoPrintFlaskRequestTest(unittest.TestCase):\n    def setUp(self):\n        self.orig_environment_wrapper = OctoPrintFlaskRequest.environment_wrapper\n\n    def tearDown(self):\n        OctoPrintFlaskRequest.environment_wrapper = staticmethod(\n            self.orig_environment_wrapper\n        )\n\n    def test_environment_wrapper(self):\n        def environment_wrapper(environ):\n            environ.update({\"TEST\": \"yes\"})\n            return environ\n\n        OctoPrintFlaskRequest.environment_wrapper = staticmethod(environment_wrapper)\n        request = OctoPrintFlaskRequest(standard_environ)\n\n        self.assertTrue(\"TEST\" in request.environ)\n\n    def test_server_name(self):\n        request = OctoPrintFlaskRequest(standard_environ)\n        self.assertEqual(\"localhost\", request.server_name)\n\n    def test_server_port(self):\n        request = OctoPrintFlaskRequest(standard_environ)\n        self.assertEqual(\"5000\", request.server_port)\n\n    def test_cookie_suffix(self):\n        request = OctoPrintFlaskRequest(standard_environ)\n        self.assertEqual(\"_P5000\", request.cookie_suffix)\n\n    def test_cookie_suffix_with_root(self):\n        script_root_environ = dict(standard_environ)\n        script_root_environ[\"SCRIPT_NAME\"] = \"/path/to/octoprint\"\n\n        request = OctoPrintFlaskRequest(script_root_environ)\n        self.assertEqual(\"_P5000_R|path|to|octoprint\", request.cookie_suffix)\n\n    def test_cookies(self):\n        environ = dict(standard_environ)\n        environ[\"HTTP_COOKIE\"] = (\n            \"postfixed_P5000=postfixed_value; \"\n            \"postfixed_wrong_P5001=postfixed_wrong_value; \"\n            \"unpostfixed=unpostfixed_value; \"\n            \"both_P5000=both_postfixed_value; \"\n            \"both=both_unpostfixed_value;\"\n        )\n\n        request = OctoPrintFlaskRequest(environ)\n\n        cookies = request.cookies\n        self.assertDictEqual(\n            {\n                \"postfixed\": \"postfixed_value\",\n                \"postfixed_wrong_P5001\": \"postfixed_wrong_value\",\n                \"unpostfixed\": \"unpostfixed_value\",\n                \"both\": \"both_postfixed_value\",\n            },\n            cookies,\n        )\n\n\n##~~\n\n\n@ddt\nclass OctoPrintFlaskResponseTest(unittest.TestCase):\n    def setUp(self):\n        # mock settings\n        self.settings_patcher = mock.patch(\"octoprint.settings.settings\")\n        self.settings_getter = self.settings_patcher.start()\n\n        self.settings = mock.MagicMock()\n        self.settings_getter.return_value = self.settings\n\n    def tearDown(self):\n        self.settings_patcher.stop()\n\n    @data(\n        [None, None, False, None, None],\n        [None, None, False, \"none\", \"None\"],\n        [None, None, False, \"lax\", \"lax\"],\n        [None, None, False, \"StRiCt\", \"strict\"],\n        [None, None, False, \"INVALID\", None],\n        [None, None, True, None, None],\n        [\"/subfolder/\", None, False, None, None],\n        [None, \"/some/other/script/root\", False, None, None],\n        [\"/subfolder/\", \"/some/other/script/root\", False, None, None],\n    )\n    @unpack\n    def test_cookie_set_and_delete(\n        self, path, scriptroot, secure, samesite, expected_samesite\n    ):\n        environ = dict(standard_environ)\n\n        expected_suffix = \"_P5000\"\n        if scriptroot is not None:\n            environ.update({\"SCRIPT_NAME\": scriptroot})\n            expected_suffix += \"_R\" + scriptroot.replace(\"/\", \"|\")\n\n        request = OctoPrintFlaskRequest(environ)\n\n        if path:\n            expected_path_set = expected_path_delete = path\n        else:\n            expected_path_set = expected_path_delete = \"/\"\n        if scriptroot:\n            expected_path_set = scriptroot + expected_path_set\n\n        if path is not None:\n            kwargs = {\"path\": path}\n        else:\n            kwargs = {}\n\n        with mock.patch(\"flask.request\", new=request):\n            with mock.patch(\"octoprint.server.util.flask.settings\") as settings_mock:\n                settings = mock.MagicMock()\n                settings.getBoolean.return_value = secure\n                settings.get.return_value = samesite\n                settings_mock.return_value = settings\n\n                response = OctoPrintFlaskResponse()\n\n                # test set_cookie\n                with mock.patch(\"flask.Response.set_cookie\") as set_cookie_mock:\n                    response.set_cookie(\"some_key\", \"some_value\", **kwargs)\n\n                    # set_cookie should have key and path values adjusted\n                    set_cookie_mock.assert_called_once_with(\n                        response,\n                        \"some_key\" + expected_suffix,\n                        \"some_value\",\n                        path=expected_path_set,\n                        secure=secure,\n                        samesite=expected_samesite,\n                    )\n\n                # test delete_cookie\n                with mock.patch(\"flask.Response.set_cookie\") as set_cookie_mock:\n                    with mock.patch(\"flask.Response.delete_cookie\") as delete_cookie_mock:\n                        response.delete_cookie(\"some_key\", **kwargs)\n\n                        # delete_cookie internally calls set_cookie - so our delete_cookie call still uses the non modified\n                        # key and path values, set_cookie will translate those (as tested above)\n                        delete_cookie_mock.assert_called_once_with(\n                            response, \"some_key\", path=expected_path_delete, domain=None\n                        )\n\n                        # we also test if an additional set_cookie call for the non modified versions happens, as\n                        # implemented to ensure any old cookies from before introduction of the suffixes and path handling\n                        # are deleted as well\n                        set_cookie_mock.assert_called_once_with(\n                            response,\n                            \"some_key\",\n                            expires=0,\n                            max_age=0,\n                            path=expected_path_delete,\n                            domain=None,\n                        )\n"], "fixing_code": ["__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"\n__copyright__ = \"Copyright (C) 2014 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n\nimport hashlib\nimport logging\nimport os\nimport time\nimport uuid\n\nimport wrapt\nfrom flask_login import AnonymousUserMixin, UserMixin\nfrom werkzeug.local import LocalProxy\n\nfrom octoprint.access.groups import Group, GroupChangeListener\nfrom octoprint.access.permissions import OctoPrintPermission, Permissions\nfrom octoprint.settings import settings as s\nfrom octoprint.util import atomic_write, deprecated, generate_api_key\nfrom octoprint.util import get_fully_qualified_classname as fqcn\nfrom octoprint.util import to_bytes, yaml\n\n\nclass UserManager(GroupChangeListener):\n    def __init__(self, group_manager, settings=None):\n        self._group_manager = group_manager\n        self._group_manager.register_listener(self)\n\n        self._logger = logging.getLogger(__name__)\n        self._session_users_by_session = {}\n        self._sessionids_by_userid = {}\n\n        if settings is None:\n            settings = s()\n        self._settings = settings\n\n        self._login_status_listeners = []\n\n    def register_login_status_listener(self, listener):\n        self._login_status_listeners.append(listener)\n\n    def unregister_login_status_listener(self, listener):\n        self._login_status_listeners.remove(listener)\n\n    def anonymous_user_factory(self):\n        return AnonymousUser([self._group_manager.guest_group])\n\n    def api_user_factory(self):\n        return ApiUser([self._group_manager.admin_group, self._group_manager.user_group])\n\n    @property\n    def enabled(self):\n        return True\n\n    def login_user(self, user):\n        self._cleanup_sessions()\n\n        if user is None or user.is_anonymous:\n            return\n\n        if isinstance(user, LocalProxy):\n            # noinspection PyProtectedMember\n            user = user._get_current_object()\n\n        if not isinstance(user, User):\n            return None\n\n        if not isinstance(user, SessionUser):\n            user = SessionUser(user)\n\n        self._session_users_by_session[user.session] = user\n\n        userid = user.get_id()\n        if userid not in self._sessionids_by_userid:\n            self._sessionids_by_userid[userid] = set()\n\n        self._sessionids_by_userid[userid].add(user.session)\n\n        for listener in self._login_status_listeners:\n            try:\n                listener.on_user_logged_in(user)\n            except Exception:\n                self._logger.exception(\n                    f\"Error in on_user_logged_in on {listener!r}\",\n                    extra={\"callback\": fqcn(listener)},\n                )\n\n        self._logger.info(f\"Logged in user: {user.get_id()}\")\n\n        return user\n\n    def logout_user(self, user, stale=False):\n        if user is None or user.is_anonymous:\n            return\n\n        if isinstance(user, LocalProxy):\n            user = user._get_current_object()\n\n        if not isinstance(user, SessionUser):\n            return\n\n        userid = user.get_id()\n        sessionid = user.session\n\n        if userid in self._sessionids_by_userid:\n            try:\n                self._sessionids_by_userid[userid].remove(sessionid)\n            except KeyError:\n                pass\n\n        if sessionid in self._session_users_by_session:\n            try:\n                del self._session_users_by_session[sessionid]\n            except KeyError:\n                pass\n\n        for listener in self._login_status_listeners:\n            try:\n                listener.on_user_logged_out(user, stale=stale)\n            except Exception:\n                self._logger.exception(\n                    f\"Error in on_user_logged_out on {listener!r}\",\n                    extra={\"callback\": fqcn(listener)},\n                )\n\n        self._logger.info(f\"Logged out user: {user.get_id()}\")\n\n    def _cleanup_sessions(self):\n        for session, user in list(self._session_users_by_session.items()):\n            if not isinstance(user, SessionUser):\n                continue\n            if user.touched + (15 * 60) < time.monotonic():\n                self._logger.info(\n                    f\"Cleaning up user session {session} for user {user.get_id()}\"\n                )\n                self.logout_user(user, stale=True)\n\n    @staticmethod\n    def create_password_hash(password, salt=None, settings=None):\n        if not salt:\n            if settings is None:\n                settings = s()\n            salt = settings.get([\"accessControl\", \"salt\"])\n            if salt is None:\n                import string\n                from random import choice\n\n                chars = string.ascii_lowercase + string.ascii_uppercase + string.digits\n                salt = \"\".join(choice(chars) for _ in range(32))\n                settings.set([\"accessControl\", \"salt\"], salt)\n                settings.save()\n\n        return hashlib.sha512(\n            to_bytes(password, encoding=\"utf-8\", errors=\"replace\") + to_bytes(salt)\n        ).hexdigest()\n\n    def check_password(self, username, password):\n        user = self.find_user(username)\n        if not user:\n            return False\n\n        hash = UserManager.create_password_hash(password, settings=self._settings)\n        if user.check_password(hash):\n            # new hash matches, correct password\n            return True\n        else:\n            # new hash doesn't match, but maybe the old one does, so check that!\n            oldHash = UserManager.create_password_hash(\n                password, salt=\"mvBUTvwzBzD3yPwvnJ4E4tXNf3CGJvvW\", settings=self._settings\n            )\n            if user.check_password(oldHash):\n                # old hash matches, we migrate the stored password hash to the new one and return True since it's the correct password\n                self.change_user_password(username, password)\n                return True\n            else:\n                # old hash doesn't match either, wrong password\n                return False\n\n    def signature_key_for_user(self, username, salt=None):\n        return self.create_password_hash(username, salt=salt)\n\n    def add_user(self, username, password, active, permissions, groups, overwrite=False):\n        pass\n\n    def change_user_activation(self, username, active):\n        pass\n\n    def change_user_permissions(self, username, permissions):\n        pass\n\n    def add_permissions_to_user(self, username, permissions):\n        pass\n\n    def remove_permissions_from_user(self, username, permissions):\n        pass\n\n    def change_user_groups(self, username, groups):\n        pass\n\n    def add_groups_to_user(self, username, groups):\n        pass\n\n    def remove_groups_from_user(self, username, groups):\n        pass\n\n    def remove_groups_from_users(self, group):\n        pass\n\n    def change_user_password(self, username, password):\n        pass\n\n    def get_user_setting(self, username, key):\n        return None\n\n    def get_all_user_settings(self, username):\n        return {}\n\n    def change_user_setting(self, username, key, value):\n        pass\n\n    def change_user_settings(self, username, new_settings):\n        pass\n\n    def remove_user(self, username):\n        if username in self._sessionids_by_userid:\n            sessions = self._sessionids_by_userid[username]\n            for session in sessions:\n                if session in self._session_users_by_session:\n                    del self._session_users_by_session[session]\n            del self._sessionids_by_userid[username]\n\n    def validate_user_session(self, userid, session):\n        self._cleanup_sessions()\n\n        if session in self._session_users_by_session:\n            user = self._session_users_by_session[session]\n            return userid == user.get_id()\n\n        return False\n\n    def find_user(self, userid=None, session=None, fresh=False):\n        self._cleanup_sessions()\n\n        if session is not None and session in self._session_users_by_session:\n            user = self._session_users_by_session[session]\n            if userid is None or userid == user.get_id():\n                user.touch()\n                return user\n\n        return None\n\n    def find_sessions_for(self, matcher):\n        self._cleanup_sessions()\n\n        result = []\n        for user in self.get_all_users():\n            if matcher(user):\n                try:\n                    session_ids = self._sessionids_by_userid[user.get_id()]\n                    for session_id in session_ids:\n                        try:\n                            session_user = self._session_users_by_session[session_id]\n                            session_user.touch()\n                            result.append(session_user)\n                        except KeyError:\n                            # unknown session after all\n                            continue\n                except KeyError:\n                    # no session for user\n                    pass\n        return result\n\n    def get_all_users(self):\n        return []\n\n    def has_been_customized(self):\n        return False\n\n    def on_group_removed(self, group):\n        self._logger.debug(f\"Group {group.key} got removed, removing from all users\")\n        self.remove_groups_from_users([group])\n\n    def on_group_permissions_changed(self, group, added=None, removed=None):\n        users = self.find_sessions_for(lambda u: group in u.groups)\n        for listener in self._login_status_listeners:\n            try:\n                for user in users:\n                    listener.on_user_modified(user)\n            except Exception:\n                self._logger.exception(\n                    f\"Error in on_user_modified on {listener!r}\",\n                    extra={\"callback\": fqcn(listener)},\n                )\n\n    def on_group_subgroups_changed(self, group, added=None, removed=None):\n        users = self.find_sessions_for(lambda u: group in u.groups)\n        for listener in self._login_status_listeners:\n            # noinspection PyBroadException\n            try:\n                for user in users:\n                    listener.on_user_modified(user)\n            except Exception:\n                self._logger.exception(\n                    f\"Error in on_user_modified on {listener!r}\",\n                    extra={\"callback\": fqcn(listener)},\n                )\n\n    def _trigger_on_user_modified(self, user):\n        if isinstance(user, str):\n            # user id\n            users = []\n            try:\n                session_ids = self._sessionids_by_userid[user]\n                for session_id in session_ids:\n                    try:\n                        users.append(self._session_users_by_session[session_id])\n                    except KeyError:\n                        # unknown session id\n                        continue\n            except KeyError:\n                # no session for user\n                return\n        elif isinstance(user, User) and not isinstance(user, SessionUser):\n            users = self.find_sessions_for(lambda u: u.get_id() == user.get_id())\n        elif isinstance(user, User):\n            users = [user]\n        else:\n            return\n\n        for listener in self._login_status_listeners:\n            try:\n                for user in users:\n                    listener.on_user_modified(user)\n            except Exception:\n                self._logger.exception(\n                    f\"Error in on_user_modified on {listener!r}\",\n                    extra={\"callback\": fqcn(listener)},\n                )\n\n    def _trigger_on_user_removed(self, username):\n        for listener in self._login_status_listeners:\n            try:\n                listener.on_user_removed(username)\n            except Exception:\n                self._logger.exception(\n                    f\"Error in on_user_removed on {listener!r}\",\n                    extra={\"callback\": fqcn(listener)},\n                )\n\n    # ~~ Deprecated methods follow\n\n    # TODO: Remove deprecated methods in OctoPrint 1.5.0\n\n    @staticmethod\n    def createPasswordHash(*args, **kwargs):\n        \"\"\"\n        .. deprecated: 1.4.0\n\n           Replaced by :func:`~UserManager.create_password_hash`\n        \"\"\"\n        # we can't use the deprecated decorator here since this method is static\n        import warnings\n\n        warnings.warn(\n            \"createPasswordHash has been renamed to create_password_hash\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return UserManager.create_password_hash(*args, **kwargs)\n\n    @deprecated(\n        \"changeUserRoles has been replaced by change_user_permissions\",\n        includedoc=\"Replaced by :func:`change_user_permissions`\",\n        since=\"1.4.0\",\n    )\n    def changeUserRoles(self, username, roles):\n        user = self.find_user(username)\n        if user is None:\n            raise UnknownUser(username)\n\n        removed_roles = set(user._roles) - set(roles)\n        self.removeRolesFromUser(username, removed_roles, user=user)\n\n        added_roles = set(roles) - set(user._roles)\n        self.addRolesToUser(username, added_roles, user=user)\n\n    @deprecated(\n        \"addRolesToUser has been replaced by add_permissions_to_user\",\n        includedoc=\"Replaced by :func:`add_permissions_to_user`\",\n        since=\"1.4.0\",\n    )\n    def addRolesToUser(self, username, roles, user=None):\n        if user is None:\n            user = self.find_user(username)\n\n        if user is None:\n            raise UnknownUser(username)\n\n        if \"admin\" in roles:\n            self.add_groups_to_user(username, self._group_manager.admin_group)\n\n        if \"user\" in roles:\n            self.remove_groups_from_user(username, self._group_manager.user_group)\n\n    @deprecated(\n        \"removeRolesFromUser has been replaced by remove_permissions_from_user\",\n        includedoc=\"Replaced by :func:`remove_permissions_from_user`\",\n        since=\"1.4.0\",\n    )\n    def removeRolesFromUser(self, username, roles, user=None):\n        if user is None:\n            user = self.find_user(username)\n\n        if user is None:\n            raise UnknownUser(username)\n\n        if \"admin\" in roles:\n            self.remove_groups_from_user(username, self._group_manager.admin_group)\n            self.remove_permissions_from_user(username, Permissions.ADMIN)\n\n        if \"user\" in roles:\n            self.remove_groups_from_user(username, self._group_manager.user_group)\n\n    checkPassword = deprecated(\n        \"checkPassword has been renamed to check_password\",\n        includedoc=\"Replaced by :func:`check_password`\",\n        since=\"1.4.0\",\n    )(check_password)\n    addUser = deprecated(\n        \"addUser has been renamed to add_user\",\n        includedoc=\"Replaced by :func:`add_user`\",\n        since=\"1.4.0\",\n    )(add_user)\n    changeUserActivation = deprecated(\n        \"changeUserActivation has been renamed to change_user_activation\",\n        includedoc=\"Replaced by :func:`change_user_activation`\",\n        since=\"1.4.0\",\n    )(change_user_activation)\n    changeUserPassword = deprecated(\n        \"changeUserPassword has been renamed to change_user_password\",\n        includedoc=\"Replaced by :func:`change_user_password`\",\n        since=\"1.4.0\",\n    )(change_user_password)\n    getUserSetting = deprecated(\n        \"getUserSetting has been renamed to get_user_setting\",\n        includedoc=\"Replaced by :func:`get_user_setting`\",\n        since=\"1.4.0\",\n    )(get_user_setting)\n    getAllUserSettings = deprecated(\n        \"getAllUserSettings has been renamed to get_all_user_settings\",\n        includedoc=\"Replaced by :func:`get_all_user_settings`\",\n        since=\"1.4.0\",\n    )(get_all_user_settings)\n    changeUserSetting = deprecated(\n        \"changeUserSetting has been renamed to change_user_setting\",\n        includedoc=\"Replaced by :func:`change_user_setting`\",\n        since=\"1.4.0\",\n    )(change_user_setting)\n    changeUserSettings = deprecated(\n        \"changeUserSettings has been renamed to change_user_settings\",\n        includedoc=\"Replaced by :func:`change_user_settings`\",\n        since=\"1.4.0\",\n    )(change_user_settings)\n    removeUser = deprecated(\n        \"removeUser has been renamed to remove_user\",\n        includedoc=\"Replaced by :func:`remove_user`\",\n        since=\"1.4.0\",\n    )(remove_user)\n    findUser = deprecated(\n        \"findUser has been renamed to find_user\",\n        includedoc=\"Replaced by :func:`find_user`\",\n        since=\"1.4.0\",\n    )(find_user)\n    getAllUsers = deprecated(\n        \"getAllUsers has been renamed to get_all_users\",\n        includedoc=\"Replaced by :func:`get_all_users`\",\n        since=\"1.4.0\",\n    )(get_all_users)\n    hasBeenCustomized = deprecated(\n        \"hasBeenCustomized has been renamed to has_been_customized\",\n        includedoc=\"Replaced by :func:`has_been_customized`\",\n        since=\"1.4.0\",\n    )(has_been_customized)\n\n\nclass LoginStatusListener:\n    def on_user_logged_in(self, user):\n        pass\n\n    def on_user_logged_out(self, user, stale=False):\n        pass\n\n    def on_user_modified(self, user):\n        pass\n\n    def on_user_removed(self, userid):\n        pass\n\n\n##~~ FilebasedUserManager, takes available users from users.yaml file\n\n\nclass FilebasedUserManager(UserManager):\n    def __init__(self, group_manager, path=None, settings=None):\n        UserManager.__init__(self, group_manager, settings=settings)\n\n        self._logger = logging.getLogger(__name__)\n\n        if path is None:\n            path = self._settings.get([\"accessControl\", \"userfile\"])\n            if path is None:\n                path = os.path.join(s().getBaseFolder(\"base\"), \"users.yaml\")\n\n        self._userfile = path\n\n        self._users = {}\n        self._dirty = False\n\n        self._customized = None\n        self._load()\n\n    def _load(self):\n        if os.path.exists(self._userfile) and os.path.isfile(self._userfile):\n            data = yaml.load_from_file(path=self._userfile)\n\n            if not data or not isinstance(data, dict):\n                self._logger.fatal(\n                    \"{} does not contain a valid map of users. Fix \"\n                    \"the file, or remove it, then restart OctoPrint.\".format(\n                        self._userfile\n                    )\n                )\n                raise CorruptUserStorage()\n\n            for name, attributes in data.items():\n                if not isinstance(attributes, dict):\n                    continue\n\n                permissions = []\n                if \"permissions\" in attributes:\n                    permissions = attributes[\"permissions\"]\n\n                if \"groups\" in attributes:\n                    groups = set(attributes[\"groups\"])\n                else:\n                    groups = {self._group_manager.user_group}\n\n                # migrate from roles to permissions\n                if \"roles\" in attributes and \"permissions\" not in attributes:\n                    self._logger.info(\n                        f\"Migrating user {name} to new granular permission system\"\n                    )\n\n                    groups |= set(self._migrate_roles_to_groups(attributes[\"roles\"]))\n                    self._dirty = True\n\n                apikey = None\n                if \"apikey\" in attributes:\n                    apikey = attributes[\"apikey\"]\n                settings = {}\n                if \"settings\" in attributes:\n                    settings = attributes[\"settings\"]\n\n                self._users[name] = User(\n                    username=name,\n                    passwordHash=attributes[\"password\"],\n                    active=attributes[\"active\"],\n                    permissions=self._to_permissions(*permissions),\n                    groups=self._to_groups(*groups),\n                    apikey=apikey,\n                    settings=settings,\n                )\n                for sessionid in self._sessionids_by_userid.get(name, set()):\n                    if sessionid in self._session_users_by_session:\n                        self._session_users_by_session[sessionid].update_user(\n                            self._users[name]\n                        )\n\n            if self._dirty:\n                self._save()\n\n            self._customized = True\n        else:\n            self._customized = False\n\n    def _save(self, force=False):\n        if not self._dirty and not force:\n            return\n\n        data = {}\n        for name, user in self._users.items():\n            if not user or not isinstance(user, User):\n                continue\n\n            data[name] = {\n                \"password\": user._passwordHash,\n                \"active\": user._active,\n                \"groups\": self._from_groups(*user._groups),\n                \"permissions\": self._from_permissions(*user._permissions),\n                \"apikey\": user._apikey,\n                \"settings\": user._settings,\n                # TODO: deprecated, remove in 1.5.0\n                \"roles\": user._roles,\n            }\n\n        with atomic_write(\n            self._userfile, mode=\"wt\", permissions=0o600, max_permissions=0o666\n        ) as f:\n            yaml.save_to_file(data, file=f, pretty=True)\n            self._dirty = False\n        self._load()\n\n    def _migrate_roles_to_groups(self, roles):\n        # If admin is inside the roles, just return admin group\n        if \"admin\" in roles:\n            return [self._group_manager.admin_group, self._group_manager.user_group]\n        else:\n            return [self._group_manager.user_group]\n\n    def _refresh_groups(self, user):\n        user._groups = self._to_groups(*map(lambda g: g.key, user.groups))\n\n    def add_user(\n        self,\n        username,\n        password,\n        active=False,\n        permissions=None,\n        groups=None,\n        apikey=None,\n        overwrite=False,\n    ):\n        if not permissions:\n            permissions = []\n        permissions = self._to_permissions(*permissions)\n\n        if not groups:\n            groups = self._group_manager.default_groups\n        groups = self._to_groups(*groups)\n\n        if username in self._users and not overwrite:\n            raise UserAlreadyExists(username)\n\n        self._users[username] = User(\n            username,\n            UserManager.create_password_hash(password, settings=self._settings),\n            active,\n            permissions,\n            groups,\n            apikey=apikey,\n        )\n        self._dirty = True\n        self._save()\n\n    def change_user_activation(self, username, active):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        if self._users[username].is_active != active:\n            self._users[username]._active = active\n            self._dirty = True\n            self._save()\n\n            self._trigger_on_user_modified(username)\n\n    def change_user_permissions(self, username, permissions):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        user = self._users[username]\n\n        permissions = self._to_permissions(*permissions)\n\n        removed_permissions = list(set(user._permissions) - set(permissions))\n        added_permissions = list(set(permissions) - set(user._permissions))\n\n        if len(removed_permissions) > 0:\n            user.remove_permissions_from_user(removed_permissions)\n            self._dirty = True\n\n        if len(added_permissions) > 0:\n            user.add_permissions_to_user(added_permissions)\n            self._dirty = True\n\n        if self._dirty:\n            self._save()\n            self._trigger_on_user_modified(username)\n\n    def add_permissions_to_user(self, username, permissions):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        if self._users[username].add_permissions_to_user(\n            self._to_permissions(*permissions)\n        ):\n            self._dirty = True\n            self._save()\n            self._trigger_on_user_modified(username)\n\n    def remove_permissions_from_user(self, username, permissions):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        if self._users[username].remove_permissions_from_user(\n            self._to_permissions(*permissions)\n        ):\n            self._dirty = True\n            self._save()\n            self._trigger_on_user_modified(username)\n\n    def remove_permissions_from_users(self, permissions):\n        modified = []\n        for user in self._users:\n            dirty = user.remove_permissions_from_user(self._to_permissions(*permissions))\n            if dirty:\n                self._dirty = True\n                modified.append(user.get_id())\n\n        if self._dirty:\n            self._save()\n            for username in modified:\n                self._trigger_on_user_modified(username)\n\n    def change_user_groups(self, username, groups):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        user = self._users[username]\n\n        groups = self._to_groups(*groups)\n\n        removed_groups = list(set(user._groups) - set(groups))\n        added_groups = list(set(groups) - set(user._groups))\n\n        if len(removed_groups):\n            self._dirty |= user.remove_groups_from_user(removed_groups)\n        if len(added_groups):\n            self._dirty |= user.add_groups_to_user(added_groups)\n\n        if self._dirty:\n            self._save()\n            self._trigger_on_user_modified(username)\n\n    def add_groups_to_user(self, username, groups, save=True, notify=True):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        if self._users[username].add_groups_to_user(self._to_groups(*groups)):\n            self._dirty = True\n\n            if save:\n                self._save()\n\n            if notify:\n                self._trigger_on_user_modified(username)\n\n    def remove_groups_from_user(self, username, groups, save=True, notify=True):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        if self._users[username].remove_groups_from_user(self._to_groups(*groups)):\n            self._dirty = True\n\n            if save:\n                self._save()\n\n            if notify:\n                self._trigger_on_user_modified(username)\n\n    def remove_groups_from_users(self, groups):\n        modified = []\n        for username, user in self._users.items():\n            dirty = user.remove_groups_from_user(self._to_groups(*groups))\n            if dirty:\n                self._dirty = True\n                modified.append(username)\n\n        if self._dirty:\n            self._save()\n\n            for username in modified:\n                self._trigger_on_user_modified(username)\n\n    def change_user_password(self, username, password):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        passwordHash = UserManager.create_password_hash(password, settings=self._settings)\n        user = self._users[username]\n        if user._passwordHash != passwordHash:\n            user._passwordHash = passwordHash\n            self._dirty = True\n            self._save()\n\n            self._trigger_on_user_modified(user)\n\n    def signature_key_for_user(self, username, salt=None):\n        if username not in self._users:\n            raise UnknownUser(username)\n        user = self._users[username]\n        return UserManager.create_password_hash(username + user._passwordHash, salt=salt)\n\n    def change_user_setting(self, username, key, value):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        user = self._users[username]\n        old_value = user.get_setting(key)\n        if not old_value or old_value != value:\n            user.set_setting(key, value)\n            self._dirty = self._dirty or old_value != value\n            self._save()\n\n    def change_user_settings(self, username, new_settings):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        user = self._users[username]\n        for key, value in new_settings.items():\n            old_value = user.get_setting(key)\n            user.set_setting(key, value)\n            self._dirty = self._dirty or old_value != value\n        self._save()\n\n    def get_all_user_settings(self, username):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        user = self._users[username]\n        return user.get_all_settings()\n\n    def get_user_setting(self, username, key):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        user = self._users[username]\n        return user.get_setting(key)\n\n    def generate_api_key(self, username):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        user = self._users[username]\n        user._apikey = generate_api_key()\n        self._dirty = True\n        self._save()\n        return user._apikey\n\n    def delete_api_key(self, username):\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        user = self._users[username]\n        user._apikey = None\n        self._dirty = True\n        self._save()\n\n    def remove_user(self, username):\n        UserManager.remove_user(self, username)\n\n        if username not in self._users:\n            raise UnknownUser(username)\n\n        del self._users[username]\n        self._dirty = True\n        self._save()\n\n    def find_user(self, userid=None, apikey=None, session=None, fresh=False):\n        user = UserManager.find_user(self, userid=userid, session=session)\n\n        if user is not None or (session and fresh):\n            return user\n\n        if userid is not None:\n            if userid not in self._users:\n                return None\n            return self._users[userid]\n\n        elif apikey is not None:\n            for user in self._users.values():\n                if apikey == user._apikey:\n                    return user\n            return None\n\n        else:\n            return None\n\n    def get_all_users(self):\n        return list(self._users.values())\n\n    def has_been_customized(self):\n        return self._customized\n\n    def on_group_permissions_changed(self, group, added=None, removed=None):\n        # refresh our group references\n        for user in self.get_all_users():\n            if group in user.groups:\n                self._refresh_groups(user)\n\n        # call parent\n        UserManager.on_group_permissions_changed(\n            self, group, added=added, removed=removed\n        )\n\n    def on_group_subgroups_changed(self, group, added=None, removed=None):\n        # refresh our group references\n        for user in self.get_all_users():\n            if group in user.groups:\n                self._refresh_groups(user)\n\n        # call parent\n        UserManager.on_group_subgroups_changed(self, group, added=added, removed=removed)\n\n    # ~~ Helpers\n\n    def _to_groups(self, *groups):\n        return list(\n            set(\n                filter(\n                    lambda x: x is not None,\n                    (self._group_manager._to_group(group) for group in groups),\n                )\n            )\n        )\n\n    def _to_permissions(self, *permissions):\n        return list(\n            set(\n                filter(\n                    lambda x: x is not None,\n                    (Permissions.find(permission) for permission in permissions),\n                )\n            )\n        )\n\n    def _from_groups(self, *groups):\n        return list({group.key for group in groups})\n\n    def _from_permissions(self, *permissions):\n        return list({permission.key for permission in permissions})\n\n    # ~~ Deprecated methods follow\n\n    # TODO: Remove deprecated methods in OctoPrint 1.5.0\n\n    generateApiKey = deprecated(\n        \"generateApiKey has been renamed to generate_api_key\",\n        includedoc=\"Replaced by :func:`generate_api_key`\",\n        since=\"1.4.0\",\n    )(generate_api_key)\n    deleteApiKey = deprecated(\n        \"deleteApiKey has been renamed to delete_api_key\",\n        includedoc=\"Replaced by :func:`delete_api_key`\",\n        since=\"1.4.0\",\n    )(delete_api_key)\n    addUser = deprecated(\n        \"addUser has been renamed to add_user\",\n        includedoc=\"Replaced by :func:`add_user`\",\n        since=\"1.4.0\",\n    )(add_user)\n    changeUserActivation = deprecated(\n        \"changeUserActivation has been renamed to change_user_activation\",\n        includedoc=\"Replaced by :func:`change_user_activation`\",\n        since=\"1.4.0\",\n    )(change_user_activation)\n    changeUserPassword = deprecated(\n        \"changeUserPassword has been renamed to change_user_password\",\n        includedoc=\"Replaced by :func:`change_user_password`\",\n        since=\"1.4.0\",\n    )(change_user_password)\n    getUserSetting = deprecated(\n        \"getUserSetting has been renamed to get_user_setting\",\n        includedoc=\"Replaced by :func:`get_user_setting`\",\n        since=\"1.4.0\",\n    )(get_user_setting)\n    getAllUserSettings = deprecated(\n        \"getAllUserSettings has been renamed to get_all_user_settings\",\n        includedoc=\"Replaced by :func:`get_all_user_settings`\",\n        since=\"1.4.0\",\n    )(get_all_user_settings)\n    changeUserSetting = deprecated(\n        \"changeUserSetting has been renamed to change_user_setting\",\n        includedoc=\"Replaced by :func:`change_user_setting`\",\n        since=\"1.4.0\",\n    )(change_user_setting)\n    changeUserSettings = deprecated(\n        \"changeUserSettings has been renamed to change_user_settings\",\n        includedoc=\"Replaced by :func:`change_user_settings`\",\n        since=\"1.4.0\",\n    )(change_user_settings)\n    removeUser = deprecated(\n        \"removeUser has been renamed to remove_user\",\n        includedoc=\"Replaced by :func:`remove_user`\",\n        since=\"1.4.0\",\n    )(remove_user)\n    findUser = deprecated(\n        \"findUser has been renamed to find_user\",\n        includedoc=\"Replaced by :func:`find_user`\",\n        since=\"1.4.0\",\n    )(find_user)\n    getAllUsers = deprecated(\n        \"getAllUsers has been renamed to get_all_users\",\n        includedoc=\"Replaced by :func:`get_all_users`\",\n        since=\"1.4.0\",\n    )(get_all_users)\n    hasBeenCustomized = deprecated(\n        \"hasBeenCustomized has been renamed to has_been_customized\",\n        includedoc=\"Replaced by :func:`has_been_customized`\",\n        since=\"1.4.0\",\n    )(has_been_customized)\n\n\n##~~ Exceptions\n\n\nclass UserAlreadyExists(Exception):\n    def __init__(self, username):\n        Exception.__init__(self, \"User %s already exists\" % username)\n\n\nclass UnknownUser(Exception):\n    def __init__(self, username):\n        Exception.__init__(self, \"Unknown user: %s\" % username)\n\n\nclass UnknownRole(Exception):\n    def __init__(self, role):\n        Exception.__init__(self, \"Unknown role: %s\" % role)\n\n\nclass CorruptUserStorage(Exception):\n    pass\n\n\n##~~ Refactoring helpers\n\n\nclass MethodReplacedByBooleanProperty:\n    def __init__(self, name, message, getter):\n        self._name = name\n        self._message = message\n        self._getter = getter\n\n    @property\n    def _attr(self):\n        return self._getter()\n\n    def __call__(self):\n        from warnings import warn\n\n        warn(DeprecationWarning(self._message.format(name=self._name)), stacklevel=2)\n        return self._attr\n\n    def __eq__(self, other):\n        return self._attr == other\n\n    def __ne__(self, other):\n        return self._attr != other\n\n    def __bool__(self):\n        # Python 3\n        return self._attr\n\n    def __nonzero__(self):\n        # Python 2\n        return self._attr\n\n    def __hash__(self):\n        return hash(self._attr)\n\n    def __repr__(self):\n        return \"MethodReplacedByProperty({}, {}, {})\".format(\n            self._name, self._message, self._getter\n        )\n\n    def __str__(self):\n        return str(self._attr)\n\n\n# TODO: Remove compatibility layer in OctoPrint 1.5.0\nclass FlaskLoginMethodReplacedByBooleanProperty(MethodReplacedByBooleanProperty):\n    def __init__(self, name, getter):\n        message = (\n            \"{name} is now a property in Flask-Login versions >= 0.3.0, which OctoPrint now uses. \"\n            + \"Use {name} instead of {name}(). This compatibility layer will be removed in OctoPrint 1.5.0.\"\n        )\n        MethodReplacedByBooleanProperty.__init__(self, name, message, getter)\n\n\n# TODO: Remove compatibility layer in OctoPrint 1.5.0\nclass OctoPrintUserMethodReplacedByBooleanProperty(MethodReplacedByBooleanProperty):\n    def __init__(self, name, getter):\n        message = (\n            \"{name} is now a property for consistency reasons with Flask-Login versions >= 0.3.0, which \"\n            + \"OctoPrint now uses. Use {name} instead of {name}(). This compatibility layer will be removed \"\n            + \"in OctoPrint 1.5.0.\"\n        )\n        MethodReplacedByBooleanProperty.__init__(self, name, message, getter)\n\n\n##~~ User object\n\n\nclass User(UserMixin):\n    def __init__(\n        self,\n        username,\n        passwordHash,\n        active,\n        permissions=None,\n        groups=None,\n        apikey=None,\n        settings=None,\n    ):\n        if permissions is None:\n            permissions = []\n        if groups is None:\n            groups = []\n\n        self._username = username\n        self._passwordHash = passwordHash\n        self._active = active\n        self._permissions = permissions\n        self._groups = groups\n        self._apikey = apikey\n\n        if settings is None:\n            settings = {}\n\n        self._settings = settings\n\n    def as_dict(self):\n        from octoprint.access.permissions import OctoPrintPermission\n\n        return {\n            \"name\": self._username,\n            \"active\": bool(self.is_active),\n            \"permissions\": list(map(lambda p: p.key, self._permissions)),\n            \"groups\": list(map(lambda g: g.key, self._groups)),\n            \"needs\": OctoPrintPermission.convert_needs_to_dict(self.needs),\n            \"apikey\": self._apikey,\n            \"settings\": self._settings,\n            # TODO: deprecated, remove in 1.5.0\n            \"admin\": self.has_permission(Permissions.ADMIN),\n            \"user\": not self.is_anonymous,\n            \"roles\": self._roles,\n        }\n\n    def check_password(self, passwordHash):\n        return self._passwordHash == passwordHash\n\n    def get_id(self):\n        return self.get_name()\n\n    def get_name(self):\n        return self._username\n\n    @property\n    def is_anonymous(self):\n        return FlaskLoginMethodReplacedByBooleanProperty(\"is_anonymous\", lambda: False)\n\n    @property\n    def is_authenticated(self):\n        return FlaskLoginMethodReplacedByBooleanProperty(\"is_authenticated\", lambda: True)\n\n    @property\n    def is_active(self):\n        return FlaskLoginMethodReplacedByBooleanProperty(\n            \"is_active\", lambda: self._active\n        )\n\n    def get_all_settings(self):\n        return self._settings\n\n    def get_setting(self, key):\n        if not isinstance(key, (tuple, list)):\n            path = [key]\n        else:\n            path = key\n\n        return self._get_setting(path)\n\n    def set_setting(self, key, value):\n        if not isinstance(key, (tuple, list)):\n            path = [key]\n        else:\n            path = key\n        return self._set_setting(path, value)\n\n    def _get_setting(self, path):\n        s = self._settings\n        for p in path:\n            if isinstance(s, dict) and p in s:\n                s = s[p]\n            else:\n                return None\n        return s\n\n    def _set_setting(self, path, value):\n        s = self._settings\n        for p in path[:-1]:\n            if p not in s:\n                s[p] = {}\n\n            if not isinstance(s[p], dict):\n                s[p] = {}\n\n            s = s[p]\n\n        key = path[-1]\n        s[key] = value\n        return True\n\n    def add_permissions_to_user(self, permissions):\n        # Make sure the permissions variable is of type list\n        if not isinstance(permissions, list):\n            permissions = [permissions]\n\n        assert all(map(lambda p: isinstance(p, OctoPrintPermission), permissions))\n\n        dirty = False\n        for permission in permissions:\n            if permissions not in self._permissions:\n                self._permissions.append(permission)\n                dirty = True\n\n        return dirty\n\n    def remove_permissions_from_user(self, permissions):\n        # Make sure the permissions variable is of type list\n        if not isinstance(permissions, list):\n            permissions = [permissions]\n\n        assert all(map(lambda p: isinstance(p, OctoPrintPermission), permissions))\n\n        dirty = False\n        for permission in permissions:\n            if permission in self._permissions:\n                self._permissions.remove(permission)\n                dirty = True\n\n        return dirty\n\n    def add_groups_to_user(self, groups):\n        # Make sure the groups variable is of type list\n        if not isinstance(groups, list):\n            groups = [groups]\n\n        assert all(map(lambda p: isinstance(p, Group), groups))\n\n        dirty = False\n        for group in groups:\n            if group.is_toggleable() and group not in self._groups:\n                self._groups.append(group)\n                dirty = True\n\n        return dirty\n\n    def remove_groups_from_user(self, groups):\n        # Make sure the groups variable is of type list\n        if not isinstance(groups, list):\n            groups = [groups]\n\n        assert all(map(lambda p: isinstance(p, Group), groups))\n\n        dirty = False\n        for group in groups:\n            if group.is_toggleable() and group in self._groups:\n                self._groups.remove(group)\n                dirty = True\n\n        return dirty\n\n    @property\n    def permissions(self):\n        if self._permissions is None:\n            return []\n\n        if Permissions.ADMIN in self._permissions:\n            return Permissions.all()\n\n        return list(filter(lambda p: p is not None, self._permissions))\n\n    @property\n    def groups(self):\n        return list(self._groups)\n\n    @property\n    def effective_permissions(self):\n        if self._permissions is None:\n            return []\n        return list(\n            filter(lambda p: p is not None and self.has_permission(p), Permissions.all())\n        )\n\n    @property\n    def needs(self):\n        needs = set()\n\n        for permission in self.permissions:\n            if permission is not None:\n                needs = needs.union(permission.needs)\n\n        for group in self.groups:\n            if group is not None:\n                needs = needs.union(group.needs)\n\n        return needs\n\n    def has_permission(self, permission):\n        return self.has_needs(*permission.needs)\n\n    def has_needs(self, *needs):\n        return set(needs).issubset(self.needs)\n\n    def __repr__(self):\n        return (\n            \"User(id=%s,name=%s,active=%r,user=True,admin=%r,permissions=%s,groups=%s)\"\n            % (\n                self.get_id(),\n                self.get_name(),\n                bool(self.is_active),\n                self.has_permission(Permissions.ADMIN),\n                self._permissions,\n                self._groups,\n            )\n        )\n\n    # ~~ Deprecated methods & properties follow\n\n    # TODO: Remove deprecated methods & properties in OctoPrint 1.5.0\n\n    asDict = deprecated(\n        \"asDict has been renamed to as_dict\",\n        includedoc=\"Replaced by :func:`as_dict`\",\n        since=\"1.4.0\",\n    )(as_dict)\n\n    @property\n    @deprecated(\"is_user is deprecated, please use has_permission\", since=\"1.4.0\")\n    def is_user(self):\n        return OctoPrintUserMethodReplacedByBooleanProperty(\n            \"is_user\", lambda: not self.is_anonymous\n        )\n\n    @property\n    @deprecated(\"is_admin is deprecated, please use has_permission\", since=\"1.4.0\")\n    def is_admin(self):\n        return OctoPrintUserMethodReplacedByBooleanProperty(\n            \"is_admin\", lambda: self.has_permission(Permissions.ADMIN)\n        )\n\n    @property\n    @deprecated(\"roles is deprecated, please use has_permission\", since=\"1.4.0\")\n    def roles(self):\n        return self._roles\n\n    @property\n    def _roles(self):\n        \"\"\"Helper for the deprecated self.roles and serializing to yaml\"\"\"\n        if self.has_permission(Permissions.ADMIN):\n            return [\"user\", \"admin\"]\n        elif not self.is_anonymous:\n            return [\"user\"]\n        else:\n            return []\n\n\nclass AnonymousUser(AnonymousUserMixin, User):\n    def __init__(self, groups):\n        User.__init__(self, None, \"\", True, [], groups)\n\n    @property\n    def is_anonymous(self):\n        return FlaskLoginMethodReplacedByBooleanProperty(\"is_anonymous\", lambda: True)\n\n    @property\n    def is_authenticated(self):\n        return FlaskLoginMethodReplacedByBooleanProperty(\n            \"is_authenticated\", lambda: False\n        )\n\n    @property\n    def is_active(self):\n        return FlaskLoginMethodReplacedByBooleanProperty(\n            \"is_active\", lambda: self._active\n        )\n\n    def check_password(self, passwordHash):\n        return True\n\n    def as_dict(self):\n        from octoprint.access.permissions import OctoPrintPermission\n\n        return {\"needs\": OctoPrintPermission.convert_needs_to_dict(self.needs)}\n\n    def __repr__(self):\n        return \"AnonymousUser(groups=%s)\" % self._groups\n\n\nclass SessionUser(wrapt.ObjectProxy):\n    def __init__(self, user):\n        wrapt.ObjectProxy.__init__(self, user)\n\n        self._self_session = \"\".join(\"%02X\" % z for z in bytes(uuid.uuid4().bytes))\n        self._self_created = self._self_touched = time.monotonic()\n\n    @property\n    def session(self):\n        return self._self_session\n\n    @property\n    def created(self):\n        return self._self_created\n\n    @property\n    def touched(self):\n        return self._self_touched\n\n    def touch(self):\n        self._self_touched = time.monotonic()\n\n    @deprecated(\n        \"SessionUser.get_session() has been deprecated, use SessionUser.session instead\",\n        since=\"1.3.5\",\n    )\n    def get_session(self):\n        return self.session\n\n    def update_user(self, user):\n        self.__wrapped__ = user\n\n    def as_dict(self):\n        result = self.__wrapped__.as_dict()\n        result.update({\"session\": self.session})\n        return result\n\n    def __repr__(self):\n        return \"SessionUser({!r},session={},created={})\".format(\n            self.__wrapped__, self.session, self.created\n        )\n\n\n##~~ User object to use when global api key is used to access the API\n\n\nclass ApiUser(User):\n    def __init__(self, groups):\n        User.__init__(self, \"_api\", \"\", True, [], groups)\n", "__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"\n__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"\n__copyright__ = \"Copyright (C) 2014 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n\nimport atexit\nimport base64\nimport functools\nimport logging\nimport logging.config\nimport mimetypes\nimport os\nimport re\nimport signal\nimport sys\nimport time\nimport uuid  # noqa: F401\nfrom collections import OrderedDict, defaultdict\n\nfrom babel import Locale\nfrom flask import (  # noqa: F401\n    Blueprint,\n    Flask,\n    Request,\n    Response,\n    current_app,\n    g,\n    make_response,\n    request,\n    session,\n)\nfrom flask_assets import Bundle, Environment\nfrom flask_babel import Babel, gettext, ngettext  # noqa: F401\nfrom flask_login import (  # noqa: F401\n    LoginManager,\n    current_user,\n    session_protected,\n    user_logged_out,\n)\nfrom watchdog.observers import Observer\nfrom watchdog.observers.polling import PollingObserver\nfrom werkzeug.exceptions import HTTPException\n\nimport octoprint.filemanager\nimport octoprint.util\nimport octoprint.util.net\nfrom octoprint.server import util\nfrom octoprint.systemcommands import system_command_manager\nfrom octoprint.util.json import JsonEncoding\nfrom octoprint.vendor.flask_principal import (  # noqa: F401\n    AnonymousIdentity,\n    Identity,\n    Permission,\n    Principal,\n    RoleNeed,\n    UserNeed,\n    identity_changed,\n    identity_loaded,\n)\nfrom octoprint.vendor.sockjs.tornado import SockJSRouter\n\ntry:\n    import fcntl\nexcept ImportError:\n    fcntl = None\n\nSUCCESS = {}\nNO_CONTENT = (\"\", 204, {\"Content-Type\": \"text/plain\"})\nNOT_MODIFIED = (\"Not Modified\", 304, {\"Content-Type\": \"text/plain\"})\n\napp = Flask(\"octoprint\")\n\nassets = None\nbabel = None\nlimiter = None\ndebug = False\nsafe_mode = False\n\nprinter = None\nprinterProfileManager = None\nfileManager = None\nslicingManager = None\nanalysisQueue = None\nuserManager = None\npermissionManager = None\ngroupManager = None\neventManager = None\nloginManager = None\npluginManager = None\npluginLifecycleManager = None\npreemptiveCache = None\njsonEncoder = None\njsonDecoder = None\nconnectivityChecker = None\nenvironmentDetector = None\n\nprincipals = Principal(app)\n\nimport octoprint.access.groups as groups  # noqa: E402\nimport octoprint.access.permissions as permissions  # noqa: E402\n\n# we set admin_permission to a GroupPermission with the default admin group\nadmin_permission = octoprint.util.variable_deprecated(\n    \"admin_permission has been deprecated, \" \"please use individual Permissions instead\",\n    since=\"1.4.0\",\n)(groups.GroupPermission(groups.ADMIN_GROUP))\n\n# we set user_permission to a GroupPermission with the default user group\nuser_permission = octoprint.util.variable_deprecated(\n    \"user_permission has been deprecated, \" \"please use individual Permissions instead\",\n    since=\"1.4.0\",\n)(groups.GroupPermission(groups.USER_GROUP))\n\nimport octoprint._version  # noqa: E402\nimport octoprint.access.groups as groups  # noqa: E402\nimport octoprint.access.users as users  # noqa: E402\nimport octoprint.events as events  # noqa: E402\nimport octoprint.filemanager.analysis  # noqa: E402\nimport octoprint.filemanager.storage  # noqa: E402\nimport octoprint.plugin  # noqa: E402\nimport octoprint.slicing  # noqa: E402\nimport octoprint.timelapse  # noqa: E402\n\n# only import further octoprint stuff down here, as it might depend on things defined above to be initialized already\nfrom octoprint import __branch__, __display_version__, __revision__, __version__\nfrom octoprint.printer.profile import PrinterProfileManager\nfrom octoprint.printer.standard import Printer\nfrom octoprint.server.util import (\n    corsRequestHandler,\n    corsResponseHandler,\n    loginFromApiKeyRequestHandler,\n    requireLoginRequestHandler,\n)\nfrom octoprint.server.util.flask import PreemptiveCache, validate_session_signature\nfrom octoprint.settings import settings\n\nVERSION = __version__\nBRANCH = __branch__\nDISPLAY_VERSION = __display_version__\nREVISION = __revision__\n\nLOCALES = []\nLANGUAGES = set()\n\n\n@identity_loaded.connect_via(app)\ndef on_identity_loaded(sender, identity):\n    user = load_user(identity.id)\n    if user is None:\n        user = userManager.anonymous_user_factory()\n\n    identity.provides.add(UserNeed(user.get_id()))\n    for need in user.needs:\n        identity.provides.add(need)\n\n\ndef _clear_identity(sender):\n    # Remove session keys set by Flask-Principal\n    for key in (\"identity.id\", \"identity.name\", \"identity.auth_type\"):\n        session.pop(key, None)\n\n    # switch to anonymous identity\n    identity_changed.send(sender, identity=AnonymousIdentity())\n\n\n@session_protected.connect_via(app)\ndef on_session_protected(sender):\n    # session was deleted by session protection, that means the user is no more and we need to clear our identity\n    if session.get(\"remember\", None) == \"clear\":\n        _clear_identity(sender)\n\n\n@user_logged_out.connect_via(app)\ndef on_user_logged_out(sender, user=None):\n    # user was logged out, clear identity\n    _clear_identity(sender)\n\n\ndef load_user(id):\n    if id is None:\n        return None\n\n    if id == \"_api\":\n        return userManager.api_user_factory()\n\n    if session and \"usersession.id\" in session:\n        sessionid = session[\"usersession.id\"]\n    else:\n        sessionid = None\n\n    if session and \"usersession.signature\" in session:\n        sessionsig = session[\"usersession.signature\"]\n    else:\n        sessionsig = \"\"\n\n    if sessionid:\n        # session[\"_fresh\"] is False if the session comes from a remember me cookie,\n        # True if it came from a use of the login dialog\n        user = userManager.find_user(\n            userid=id, session=sessionid, fresh=session.get(\"_fresh\", False)\n        )\n    else:\n        user = userManager.find_user(userid=id)\n\n    if (\n        user\n        and user.is_active\n        and (not sessionid or validate_session_signature(sessionsig, id, sessionid))\n    ):\n        return user\n\n    return None\n\n\ndef load_user_from_request(request):\n    user = None\n\n    if settings().getBoolean([\"accessControl\", \"trustBasicAuthentication\"]):\n        # Basic Authentication?\n        user = util.get_user_for_authorization_header(\n            request.headers.get(\"Authorization\")\n        )\n\n    if settings().getBoolean([\"accessControl\", \"trustRemoteUser\"]):\n        # Remote user header?\n        user = util.get_user_for_remote_user_header(request)\n\n    return user\n\n\ndef unauthorized_user():\n    from flask import abort\n\n    abort(403)\n\n\n# ~~ startup code\n\n\nclass Server:\n    def __init__(\n        self,\n        settings=None,\n        plugin_manager=None,\n        connectivity_checker=None,\n        environment_detector=None,\n        event_manager=None,\n        host=None,\n        port=None,\n        v6_only=False,\n        debug=False,\n        safe_mode=False,\n        allow_root=False,\n        octoprint_daemon=None,\n    ):\n        self._settings = settings\n        self._plugin_manager = plugin_manager\n        self._connectivity_checker = connectivity_checker\n        self._environment_detector = environment_detector\n        self._event_manager = event_manager\n        self._host = host\n        self._port = port\n        self._v6_only = v6_only\n        self._debug = debug\n        self._safe_mode = safe_mode\n        self._allow_root = allow_root\n        self._octoprint_daemon = octoprint_daemon\n        self._server = None\n\n        self._logger = None\n\n        self._lifecycle_callbacks = defaultdict(list)\n\n        self._intermediary_server = None\n\n    def run(self):\n        if not self._allow_root:\n            self._check_for_root()\n\n        if self._settings is None:\n            self._settings = settings()\n\n        if not self._settings.getBoolean([\"server\", \"ignoreIncompleteStartup\"]):\n            self._settings.setBoolean([\"server\", \"incompleteStartup\"], True)\n            self._settings.save()\n\n        if self._plugin_manager is None:\n            self._plugin_manager = octoprint.plugin.plugin_manager()\n\n        global app\n        global babel\n\n        global printer\n        global printerProfileManager\n        global fileManager\n        global slicingManager\n        global analysisQueue\n        global userManager\n        global permissionManager\n        global groupManager\n        global eventManager\n        global loginManager\n        global pluginManager\n        global pluginLifecycleManager\n        global preemptiveCache\n        global jsonEncoder\n        global jsonDecoder\n        global connectivityChecker\n        global environmentDetector\n        global debug\n        global safe_mode\n\n        from tornado.ioloop import IOLoop\n        from tornado.web import Application\n\n        debug = self._debug\n        safe_mode = self._safe_mode\n\n        if safe_mode:\n            self._log_safe_mode_start(safe_mode)\n\n        if self._v6_only and not octoprint.util.net.HAS_V6:\n            raise RuntimeError(\n                \"IPv6 only mode configured but system doesn't support IPv6\"\n            )\n\n        if self._host is None:\n            host = self._settings.get([\"server\", \"host\"])\n            if host is None:\n                if octoprint.util.net.HAS_V6:\n                    host = \"::\"\n                else:\n                    host = \"0.0.0.0\"\n\n            self._host = host\n\n        if \":\" in self._host and not octoprint.util.net.HAS_V6:\n            raise RuntimeError(\n                \"IPv6 host address {!r} configured but system doesn't support IPv6\".format(\n                    self._host\n                )\n            )\n\n        if self._port is None:\n            self._port = self._settings.getInt([\"server\", \"port\"])\n            if self._port is None:\n                self._port = 5000\n\n        self._logger = logging.getLogger(__name__)\n        self._setup_heartbeat_logging()\n        pluginManager = self._plugin_manager\n\n        # monkey patch/fix some stuff\n        util.tornado.fix_json_encode()\n        util.tornado.fix_websocket_check_origin()\n        util.tornado.enable_per_message_deflate_extension()\n        util.flask.fix_flask_jsonify()\n\n        self._setup_mimetypes()\n\n        additional_translation_folders = []\n        if not safe_mode:\n            additional_translation_folders += [\n                self._settings.getBaseFolder(\"translations\")\n            ]\n        util.flask.enable_additional_translations(\n            additional_folders=additional_translation_folders\n        )\n\n        # setup app\n        self._setup_app(app)\n\n        # setup i18n\n        self._setup_i18n(app)\n\n        if self._settings.getBoolean([\"serial\", \"log\"]):\n            # enable debug logging to serial.log\n            logging.getLogger(\"SERIAL\").setLevel(logging.DEBUG)\n\n        if self._settings.getBoolean([\"devel\", \"pluginTimings\"]):\n            # enable plugin timings log\n            logging.getLogger(\"PLUGIN_TIMINGS\").setLevel(logging.DEBUG)\n\n        # start the intermediary server\n        self._start_intermediary_server()\n\n        ### IMPORTANT!\n        ###\n        ### Best do not start any subprocesses until the intermediary server shuts down again or they MIGHT inherit the\n        ### open port and prevent us from firing up Tornado later.\n        ###\n        ### The intermediary server's socket should have the CLOSE_EXEC flag (or its equivalent) set where possible, but\n        ### we can only do that if fcntl is available or we are on Windows, so better safe than sorry.\n        ###\n        ### See also issues #2035 and #2090\n\n        systemCommandManager = system_command_manager()\n        printerProfileManager = PrinterProfileManager()\n        eventManager = self._event_manager\n\n        analysis_queue_factories = {\n            \"gcode\": octoprint.filemanager.analysis.GcodeAnalysisQueue\n        }\n        analysis_queue_hooks = pluginManager.get_hooks(\n            \"octoprint.filemanager.analysis.factory\"\n        )\n        for name, hook in analysis_queue_hooks.items():\n            try:\n                additional_factories = hook()\n                analysis_queue_factories.update(**additional_factories)\n            except Exception:\n                self._logger.exception(\n                    f\"Error while processing analysis queues from {name}\",\n                    extra={\"plugin\": name},\n                )\n        analysisQueue = octoprint.filemanager.analysis.AnalysisQueue(\n            analysis_queue_factories\n        )\n\n        slicingManager = octoprint.slicing.SlicingManager(\n            self._settings.getBaseFolder(\"slicingProfiles\"), printerProfileManager\n        )\n\n        storage_managers = {}\n        storage_managers[\n            octoprint.filemanager.FileDestinations.LOCAL\n        ] = octoprint.filemanager.storage.LocalFileStorage(\n            self._settings.getBaseFolder(\"uploads\"),\n            really_universal=self._settings.getBoolean(\n                [\"feature\", \"enforceReallyUniversalFilenames\"]\n            ),\n        )\n\n        fileManager = octoprint.filemanager.FileManager(\n            analysisQueue,\n            slicingManager,\n            printerProfileManager,\n            initial_storage_managers=storage_managers,\n        )\n        pluginLifecycleManager = LifecycleManager(pluginManager)\n        preemptiveCache = PreemptiveCache(\n            os.path.join(\n                self._settings.getBaseFolder(\"data\"), \"preemptive_cache_config.yaml\"\n            )\n        )\n\n        JsonEncoding.add_encoder(users.User, lambda obj: obj.as_dict())\n        JsonEncoding.add_encoder(groups.Group, lambda obj: obj.as_dict())\n        JsonEncoding.add_encoder(\n            permissions.OctoPrintPermission, lambda obj: obj.as_dict()\n        )\n\n        # start regular check if we are connected to the internet\n        def on_connectivity_change(old_value, new_value):\n            eventManager.fire(\n                events.Events.CONNECTIVITY_CHANGED,\n                payload={\"old\": old_value, \"new\": new_value},\n            )\n\n        connectivityChecker = self._connectivity_checker\n        environmentDetector = self._environment_detector\n\n        def on_settings_update(*args, **kwargs):\n            # make sure our connectivity checker runs with the latest settings\n            connectivityEnabled = self._settings.getBoolean(\n                [\"server\", \"onlineCheck\", \"enabled\"]\n            )\n            connectivityInterval = self._settings.getInt(\n                [\"server\", \"onlineCheck\", \"interval\"]\n            )\n            connectivityHost = self._settings.get([\"server\", \"onlineCheck\", \"host\"])\n            connectivityPort = self._settings.getInt([\"server\", \"onlineCheck\", \"port\"])\n            connectivityName = self._settings.get([\"server\", \"onlineCheck\", \"name\"])\n\n            if (\n                connectivityChecker.enabled != connectivityEnabled\n                or connectivityChecker.interval != connectivityInterval\n                or connectivityChecker.host != connectivityHost\n                or connectivityChecker.port != connectivityPort\n                or connectivityChecker.name != connectivityName\n            ):\n                connectivityChecker.enabled = connectivityEnabled\n                connectivityChecker.interval = connectivityInterval\n                connectivityChecker.host = connectivityHost\n                connectivityChecker.port = connectivityPort\n                connectivityChecker.name = connectivityName\n                connectivityChecker.check_immediately()\n\n        eventManager.subscribe(events.Events.SETTINGS_UPDATED, on_settings_update)\n\n        components = {\n            \"plugin_manager\": pluginManager,\n            \"printer_profile_manager\": printerProfileManager,\n            \"event_bus\": eventManager,\n            \"analysis_queue\": analysisQueue,\n            \"slicing_manager\": slicingManager,\n            \"file_manager\": fileManager,\n            \"plugin_lifecycle_manager\": pluginLifecycleManager,\n            \"preemptive_cache\": preemptiveCache,\n            \"json_encoder\": jsonEncoder,\n            \"json_decoder\": jsonDecoder,\n            \"connectivity_checker\": connectivityChecker,\n            \"environment_detector\": self._environment_detector,\n            \"system_commands\": systemCommandManager,\n        }\n\n        # ~~ setup access control\n\n        # get additional permissions from plugins\n        self._setup_plugin_permissions()\n\n        # create group manager instance\n        group_manager_factories = pluginManager.get_hooks(\n            \"octoprint.access.groups.factory\"\n        )\n        for name, factory in group_manager_factories.items():\n            try:\n                groupManager = factory(components, self._settings)\n                if groupManager is not None:\n                    self._logger.debug(\n                        f\"Created group manager instance from factory {name}\"\n                    )\n                    break\n            except Exception:\n                self._logger.exception(\n                    \"Error while creating group manager instance from factory {}\".format(\n                        name\n                    )\n                )\n        else:\n            group_manager_name = self._settings.get([\"accessControl\", \"groupManager\"])\n            try:\n                clazz = octoprint.util.get_class(group_manager_name)\n                groupManager = clazz()\n            except AttributeError:\n                self._logger.exception(\n                    \"Could not instantiate group manager {}, \"\n                    \"falling back to FilebasedGroupManager!\".format(group_manager_name)\n                )\n                groupManager = octoprint.access.groups.FilebasedGroupManager()\n        components.update({\"group_manager\": groupManager})\n\n        # create user manager instance\n        user_manager_factories = pluginManager.get_hooks(\n            \"octoprint.users.factory\"\n        )  # legacy, set first so that new wins\n        user_manager_factories.update(\n            pluginManager.get_hooks(\"octoprint.access.users.factory\")\n        )\n        for name, factory in user_manager_factories.items():\n            try:\n                userManager = factory(components, self._settings)\n                if userManager is not None:\n                    self._logger.debug(\n                        f\"Created user manager instance from factory {name}\"\n                    )\n                    break\n            except Exception:\n                self._logger.exception(\n                    \"Error while creating user manager instance from factory {}\".format(\n                        name\n                    ),\n                    extra={\"plugin\": name},\n                )\n        else:\n            user_manager_name = self._settings.get([\"accessControl\", \"userManager\"])\n            try:\n                clazz = octoprint.util.get_class(user_manager_name)\n                userManager = clazz(groupManager)\n            except octoprint.access.users.CorruptUserStorage:\n                raise\n            except Exception:\n                self._logger.exception(\n                    \"Could not instantiate user manager {}, \"\n                    \"falling back to FilebasedUserManager!\".format(user_manager_name)\n                )\n                userManager = octoprint.access.users.FilebasedUserManager(groupManager)\n        components.update({\"user_manager\": userManager})\n\n        # create printer instance\n        printer_factories = pluginManager.get_hooks(\"octoprint.printer.factory\")\n        for name, factory in printer_factories.items():\n            try:\n                printer = factory(components)\n                if printer is not None:\n                    self._logger.debug(f\"Created printer instance from factory {name}\")\n                    break\n            except Exception:\n                self._logger.exception(\n                    f\"Error while creating printer instance from factory {name}\",\n                    extra={\"plugin\": name},\n                )\n        else:\n            printer = Printer(fileManager, analysisQueue, printerProfileManager)\n        components.update({\"printer\": printer})\n\n        from octoprint import (\n            init_custom_events,\n            init_settings_plugin_config_migration_and_cleanup,\n        )\n        from octoprint import octoprint_plugin_inject_factory as opif\n        from octoprint import settings_plugin_inject_factory as spif\n\n        init_custom_events(pluginManager)\n\n        octoprint_plugin_inject_factory = opif(self._settings, components)\n        settings_plugin_inject_factory = spif(self._settings)\n\n        pluginManager.implementation_inject_factories = [\n            octoprint_plugin_inject_factory,\n            settings_plugin_inject_factory,\n        ]\n        pluginManager.initialize_implementations()\n\n        init_settings_plugin_config_migration_and_cleanup(pluginManager)\n\n        pluginManager.log_all_plugins()\n\n        # log environment data now\n        self._environment_detector.log_detected_environment()\n\n        # initialize file manager and register it for changes in the registered plugins\n        fileManager.initialize()\n        pluginLifecycleManager.add_callback(\n            [\"enabled\", \"disabled\"], lambda name, plugin: fileManager.reload_plugins()\n        )\n\n        # initialize slicing manager and register it for changes in the registered plugins\n        slicingManager.initialize()\n        pluginLifecycleManager.add_callback(\n            [\"enabled\", \"disabled\"], lambda name, plugin: slicingManager.reload_slicers()\n        )\n\n        # setup jinja2\n        self._setup_jinja2()\n\n        # setup assets\n        self._setup_assets()\n\n        # configure timelapse\n        octoprint.timelapse.valid_timelapse(\"test\")\n        octoprint.timelapse.configure_timelapse()\n\n        # setup command triggers\n        events.CommandTrigger(printer)\n        if self._debug:\n            events.DebugEventListener()\n\n        # setup login manager\n        self._setup_login_manager()\n\n        # register API blueprint\n        self._setup_blueprints()\n\n        ## Tornado initialization starts here\n\n        ioloop = IOLoop()\n        ioloop.install()\n\n        enable_cors = settings().getBoolean([\"api\", \"allowCrossOrigin\"])\n\n        self._router = SockJSRouter(\n            self._create_socket_connection,\n            \"/sockjs\",\n            session_kls=util.sockjs.ThreadSafeSession,\n            user_settings={\n                \"websocket_allow_origin\": \"*\" if enable_cors else \"\",\n                \"jsessionid\": False,\n                \"sockjs_url\": \"../../static/js/lib/sockjs.min.js\",\n            },\n        )\n\n        upload_suffixes = {\n            \"name\": self._settings.get([\"server\", \"uploads\", \"nameSuffix\"]),\n            \"path\": self._settings.get([\"server\", \"uploads\", \"pathSuffix\"]),\n        }\n\n        def mime_type_guesser(path):\n            from octoprint.filemanager import get_mime_type\n\n            return get_mime_type(path)\n\n        def download_name_generator(path):\n            metadata = fileManager.get_metadata(\"local\", path)\n            if metadata and \"display\" in metadata:\n                return metadata[\"display\"]\n\n        download_handler_kwargs = {\"as_attachment\": True, \"allow_client_caching\": False}\n\n        additional_mime_types = {\"mime_type_guesser\": mime_type_guesser}\n\n        ##~~ Permission validators\n\n        access_validators_from_plugins = []\n        for plugin, hook in pluginManager.get_hooks(\n            \"octoprint.server.http.access_validator\"\n        ).items():\n            try:\n                access_validators_from_plugins.append(\n                    util.tornado.access_validation_factory(app, hook)\n                )\n            except Exception:\n                self._logger.exception(\n                    \"Error while adding tornado access validator from plugin {}\".format(\n                        plugin\n                    ),\n                    extra={\"plugin\": plugin},\n                )\n\n        timelapse_validators = [\n            util.tornado.access_validation_factory(\n                app,\n                util.flask.permission_validator,\n                permissions.Permissions.TIMELAPSE_LIST,\n            ),\n        ] + access_validators_from_plugins\n        download_validators = [\n            util.tornado.access_validation_factory(\n                app,\n                util.flask.permission_validator,\n                permissions.Permissions.FILES_DOWNLOAD,\n            ),\n        ] + access_validators_from_plugins\n        log_validators = [\n            util.tornado.access_validation_factory(\n                app,\n                util.flask.permission_validator,\n                permissions.Permissions.PLUGIN_LOGGING_MANAGE,\n            ),\n        ] + access_validators_from_plugins\n        camera_validators = [\n            util.tornado.access_validation_factory(\n                app, util.flask.permission_validator, permissions.Permissions.WEBCAM\n            ),\n        ] + access_validators_from_plugins\n        systeminfo_validators = [\n            util.tornado.access_validation_factory(\n                app, util.flask.permission_validator, permissions.Permissions.SYSTEM\n            )\n        ] + access_validators_from_plugins\n\n        timelapse_permission_validator = {\n            \"access_validation\": util.tornado.validation_chain(*timelapse_validators)\n        }\n        download_permission_validator = {\n            \"access_validation\": util.tornado.validation_chain(*download_validators)\n        }\n        log_permission_validator = {\n            \"access_validation\": util.tornado.validation_chain(*log_validators)\n        }\n        camera_permission_validator = {\n            \"access_validation\": util.tornado.validation_chain(*camera_validators)\n        }\n        systeminfo_permission_validator = {\n            \"access_validation\": util.tornado.validation_chain(*systeminfo_validators)\n        }\n\n        no_hidden_files_validator = {\n            \"path_validation\": util.tornado.path_validation_factory(\n                lambda path: not octoprint.util.is_hidden_path(path), status_code=404\n            )\n        }\n\n        only_known_types_validator = {\n            \"path_validation\": util.tornado.path_validation_factory(\n                lambda path: octoprint.filemanager.valid_file_type(\n                    os.path.basename(path)\n                ),\n                status_code=404,\n            )\n        }\n\n        valid_timelapse = lambda path: not octoprint.util.is_hidden_path(path) and (\n            octoprint.timelapse.valid_timelapse(path)\n            or octoprint.timelapse.valid_timelapse_thumbnail(path)\n        )\n        timelapse_path_validator = {\n            \"path_validation\": util.tornado.path_validation_factory(\n                valid_timelapse,\n                status_code=404,\n            )\n        }\n        timelapses_path_validator = {\n            \"path_validation\": util.tornado.path_validation_factory(\n                lambda path: valid_timelapse(path)\n                and os.path.realpath(os.path.abspath(path)).startswith(\n                    settings().getBaseFolder(\"timelapse\")\n                ),\n                status_code=400,\n            )\n        }\n\n        valid_log = lambda path: not octoprint.util.is_hidden_path(\n            path\n        ) and path.endswith(\".log\")\n        log_path_validator = {\n            \"path_validation\": util.tornado.path_validation_factory(\n                valid_log,\n                status_code=404,\n            )\n        }\n        logs_path_validator = {\n            \"path_validation\": util.tornado.path_validation_factory(\n                lambda path: valid_log(path)\n                and os.path.realpath(os.path.abspath(path)).startswith(\n                    settings().getBaseFolder(\"logs\")\n                ),\n                status_code=400,\n            )\n        }\n\n        def joined_dict(*dicts):\n            if not len(dicts):\n                return {}\n\n            joined = {}\n            for d in dicts:\n                joined.update(d)\n            return joined\n\n        util.tornado.RequestlessExceptionLoggingMixin.LOG_REQUEST = debug\n        util.tornado.CorsSupportMixin.ENABLE_CORS = enable_cors\n\n        server_routes = self._router.urls + [\n            # various downloads\n            # .mpg and .mp4 timelapses:\n            (\n                r\"/downloads/timelapse/(.*)\",\n                util.tornado.LargeResponseHandler,\n                joined_dict(\n                    {\"path\": self._settings.getBaseFolder(\"timelapse\")},\n                    timelapse_permission_validator,\n                    download_handler_kwargs,\n                    timelapse_path_validator,\n                ),\n            ),\n            # zipped timelapse bundles\n            (\n                r\"/downloads/timelapses\",\n                util.tornado.DynamicZipBundleHandler,\n                joined_dict(\n                    {\n                        \"as_attachment\": True,\n                        \"attachment_name\": \"octoprint-timelapses.zip\",\n                        \"path_processor\": lambda x: (\n                            x,\n                            os.path.join(self._settings.getBaseFolder(\"timelapse\"), x),\n                        ),\n                    },\n                    timelapse_permission_validator,\n                    timelapses_path_validator,\n                ),\n            ),\n            # uploaded printables\n            (\n                r\"/downloads/files/local/(.*)\",\n                util.tornado.LargeResponseHandler,\n                joined_dict(\n                    {\n                        \"path\": self._settings.getBaseFolder(\"uploads\"),\n                        \"as_attachment\": True,\n                        \"name_generator\": download_name_generator,\n                    },\n                    download_permission_validator,\n                    download_handler_kwargs,\n                    no_hidden_files_validator,\n                    only_known_types_validator,\n                    additional_mime_types,\n                ),\n            ),\n            # log files\n            (\n                r\"/downloads/logs/([^/]*)\",\n                util.tornado.LargeResponseHandler,\n                joined_dict(\n                    {\n                        \"path\": self._settings.getBaseFolder(\"logs\"),\n                        \"mime_type_guesser\": lambda *args, **kwargs: \"text/plain\",\n                        \"stream_body\": True,\n                    },\n                    download_handler_kwargs,\n                    log_permission_validator,\n                    log_path_validator,\n                ),\n            ),\n            # zipped log file bundles\n            (\n                r\"/downloads/logs\",\n                util.tornado.DynamicZipBundleHandler,\n                joined_dict(\n                    {\n                        \"as_attachment\": True,\n                        \"attachment_name\": \"octoprint-logs.zip\",\n                        \"path_processor\": lambda x: (\n                            x,\n                            os.path.join(self._settings.getBaseFolder(\"logs\"), x),\n                        ),\n                    },\n                    log_permission_validator,\n                    logs_path_validator,\n                ),\n            ),\n            # system info bundle\n            (\n                r\"/downloads/systeminfo.zip\",\n                util.tornado.SystemInfoBundleHandler,\n                systeminfo_permission_validator,\n            ),\n            # camera snapshot\n            (\n                r\"/downloads/camera/current\",\n                util.tornado.UrlProxyHandler,\n                joined_dict(\n                    {\n                        \"url\": self._settings.get([\"webcam\", \"snapshot\"]),\n                        \"as_attachment\": True,\n                    },\n                    camera_permission_validator,\n                ),\n            ),\n            # generated webassets\n            (\n                r\"/static/webassets/(.*)\",\n                util.tornado.LargeResponseHandler,\n                {\n                    \"path\": os.path.join(\n                        self._settings.getBaseFolder(\"generated\"), \"webassets\"\n                    ),\n                    \"is_pre_compressed\": True,\n                },\n            ),\n            # online indicators - text file with \"online\" as content and a transparent gif\n            (r\"/online.txt\", util.tornado.StaticDataHandler, {\"data\": \"online\\n\"}),\n            (\n                r\"/online.gif\",\n                util.tornado.StaticDataHandler,\n                {\n                    \"data\": bytes(\n                        base64.b64decode(\n                            \"R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"\n                        )\n                    ),\n                    \"content_type\": \"image/gif\",\n                },\n            ),\n            # deprecated endpoints\n            (\n                r\"/api/logs\",\n                util.tornado.DeprecatedEndpointHandler,\n                {\"url\": \"/plugin/logging/logs\"},\n            ),\n            (\n                r\"/api/logs/(.*)\",\n                util.tornado.DeprecatedEndpointHandler,\n                {\"url\": \"/plugin/logging/logs/{0}\"},\n            ),\n        ]\n\n        # fetch additional routes from plugins\n        for name, hook in pluginManager.get_hooks(\"octoprint.server.http.routes\").items():\n            try:\n                result = hook(list(server_routes))\n            except Exception:\n                self._logger.exception(\n                    f\"There was an error while retrieving additional \"\n                    f\"server routes from plugin hook {name}\",\n                    extra={\"plugin\": name},\n                )\n            else:\n                if isinstance(result, (list, tuple)):\n                    for entry in result:\n                        if not isinstance(entry, tuple) or not len(entry) == 3:\n                            continue\n                        if not isinstance(entry[0], str):\n                            continue\n                        if not isinstance(entry[2], dict):\n                            continue\n\n                        route, handler, kwargs = entry\n                        route = r\"/plugin/{name}/{route}\".format(\n                            name=name,\n                            route=route if not route.startswith(\"/\") else route[1:],\n                        )\n\n                        self._logger.debug(\n                            f\"Adding additional route {route} handled by handler {handler} and with additional arguments {kwargs!r}\"\n                        )\n                        server_routes.append((route, handler, kwargs))\n\n        headers = {\n            \"X-Robots-Tag\": \"noindex, nofollow, noimageindex\",\n            \"X-Content-Type-Options\": \"nosniff\",\n        }\n        if not settings().getBoolean([\"server\", \"allowFraming\"]):\n            headers[\"X-Frame-Options\"] = \"sameorigin\"\n\n        removed_headers = [\"Server\"]\n\n        server_routes.append(\n            (\n                r\".*\",\n                util.tornado.UploadStorageFallbackHandler,\n                {\n                    \"fallback\": util.tornado.WsgiInputContainer(\n                        app.wsgi_app, headers=headers, removed_headers=removed_headers\n                    ),\n                    \"file_prefix\": \"octoprint-file-upload-\",\n                    \"file_suffix\": \".tmp\",\n                    \"suffixes\": upload_suffixes,\n                },\n            )\n        )\n\n        transforms = [\n            util.tornado.GlobalHeaderTransform.for_headers(\n                \"OctoPrintGlobalHeaderTransform\",\n                headers=headers,\n                removed_headers=removed_headers,\n            )\n        ]\n\n        self._tornado_app = Application(handlers=server_routes, transforms=transforms)\n        max_body_sizes = [\n            (\n                \"POST\",\n                r\"/api/files/([^/]*)\",\n                self._settings.getInt([\"server\", \"uploads\", \"maxSize\"]),\n            ),\n            (\"POST\", r\"/api/languages\", 5 * 1024 * 1024),\n        ]\n\n        # allow plugins to extend allowed maximum body sizes\n        for name, hook in pluginManager.get_hooks(\n            \"octoprint.server.http.bodysize\"\n        ).items():\n            try:\n                result = hook(list(max_body_sizes))\n            except Exception:\n                self._logger.exception(\n                    f\"There was an error while retrieving additional \"\n                    f\"upload sizes from plugin hook {name}\",\n                    extra={\"plugin\": name},\n                )\n            else:\n                if isinstance(result, (list, tuple)):\n                    for entry in result:\n                        if not isinstance(entry, tuple) or not len(entry) == 3:\n                            continue\n                        if (\n                            entry[0]\n                            not in util.tornado.UploadStorageFallbackHandler.BODY_METHODS\n                        ):\n                            continue\n                        if not isinstance(entry[2], int):\n                            continue\n\n                        method, route, size = entry\n                        route = r\"/plugin/{name}/{route}\".format(\n                            name=name,\n                            route=route if not route.startswith(\"/\") else route[1:],\n                        )\n\n                        self._logger.debug(\n                            f\"Adding maximum body size of {size}B for {method} requests to {route})\"\n                        )\n                        max_body_sizes.append((method, route, size))\n\n        self._stop_intermediary_server()\n\n        # initialize and bind the server\n        trusted_downstream = self._settings.get(\n            [\"server\", \"reverseProxy\", \"trustedDownstream\"]\n        )\n        if not isinstance(trusted_downstream, list):\n            self._logger.warning(\n                \"server.reverseProxy.trustedDownstream is not a list, skipping\"\n            )\n            trusted_downstream = []\n\n        server_kwargs = {\n            \"max_body_sizes\": max_body_sizes,\n            \"default_max_body_size\": self._settings.getInt([\"server\", \"maxSize\"]),\n            \"xheaders\": True,\n            \"trusted_downstream\": trusted_downstream,\n        }\n        if sys.platform == \"win32\":\n            # set 10min idle timeout under windows to hopefully make #2916 less likely\n            server_kwargs.update({\"idle_connection_timeout\": 600})\n\n        self._server = util.tornado.CustomHTTPServer(self._tornado_app, **server_kwargs)\n\n        listening_address = self._host\n        if self._host == \"::\" and not self._v6_only:\n            # special case - tornado only listens on v4 _and_ v6 if we use None as address\n            listening_address = None\n\n        self._server.listen(self._port, address=listening_address)\n\n        ### From now on it's ok to launch subprocesses again\n\n        eventManager.fire(events.Events.STARTUP)\n\n        # analysis backlog\n        fileManager.process_backlog()\n\n        # auto connect\n        if self._settings.getBoolean([\"serial\", \"autoconnect\"]):\n            self._logger.info(\n                \"Autoconnect on startup is configured, trying to connect to the printer...\"\n            )\n            try:\n                (port, baudrate) = (\n                    self._settings.get([\"serial\", \"port\"]),\n                    self._settings.getInt([\"serial\", \"baudrate\"]),\n                )\n                printer_profile = printerProfileManager.get_default()\n                connectionOptions = printer.__class__.get_connection_options()\n                if port in connectionOptions[\"ports\"] or port == \"AUTO\" or port is None:\n                    self._logger.info(\n                        f\"Trying to connect to configured serial port {port}\"\n                    )\n                    printer.connect(\n                        port=port,\n                        baudrate=baudrate,\n                        profile=printer_profile[\"id\"]\n                        if \"id\" in printer_profile\n                        else \"_default\",\n                    )\n                else:\n                    self._logger.info(\n                        \"Could not find configured serial port {} in the system, cannot automatically connect to a non existing printer. Is it plugged in and booted up yet?\"\n                    )\n            except Exception:\n                self._logger.exception(\n                    \"Something went wrong while attempting to automatically connect to the printer\"\n                )\n\n        # start up watchdogs\n        try:\n            watched = self._settings.getBaseFolder(\"watched\")\n            watchdog_handler = util.watchdog.GcodeWatchdogHandler(fileManager, printer)\n            watchdog_handler.initial_scan(watched)\n\n            if self._settings.getBoolean([\"feature\", \"pollWatched\"]):\n                # use less performant polling observer if explicitly configured\n                observer = PollingObserver()\n            else:\n                # use os default\n                observer = Observer()\n\n            observer.schedule(watchdog_handler, watched, recursive=True)\n            observer.start()\n        except Exception:\n            self._logger.exception(\"Error starting watched folder observer\")\n\n        # run our startup plugins\n        octoprint.plugin.call_plugin(\n            octoprint.plugin.StartupPlugin,\n            \"on_startup\",\n            args=(self._host, self._port),\n            sorting_context=\"StartupPlugin.on_startup\",\n        )\n\n        def call_on_startup(name, plugin):\n            implementation = plugin.get_implementation(octoprint.plugin.StartupPlugin)\n            if implementation is None:\n                return\n            implementation.on_startup(self._host, self._port)\n\n        pluginLifecycleManager.add_callback(\"enabled\", call_on_startup)\n\n        # prepare our after startup function\n        def on_after_startup():\n            if self._host == \"::\":\n                if self._v6_only:\n                    # only v6\n                    self._logger.info(f\"Listening on http://[::]:{self._port}\")\n                else:\n                    # all v4 and v6\n                    self._logger.info(\n                        \"Listening on http://0.0.0.0:{port} and http://[::]:{port}\".format(\n                            port=self._port\n                        )\n                    )\n            else:\n                self._logger.info(\n                    \"Listening on http://{}:{}\".format(\n                        self._host if \":\" not in self._host else \"[\" + self._host + \"]\",\n                        self._port,\n                    )\n                )\n\n            if safe_mode and self._settings.getBoolean([\"server\", \"startOnceInSafeMode\"]):\n                self._logger.info(\n                    \"Server started successfully in safe mode as requested from config, removing flag\"\n                )\n                self._settings.setBoolean([\"server\", \"startOnceInSafeMode\"], False)\n                self._settings.save()\n\n            # now this is somewhat ugly, but the issue is the following: startup plugins might want to do things for\n            # which they need the server to be already alive (e.g. for being able to resolve urls, such as favicons\n            # or service xmls or the like). While they are working though the ioloop would block. Therefore we'll\n            # create a single use thread in which to perform our after-startup-tasks, start that and hand back\n            # control to the ioloop\n            def work():\n                octoprint.plugin.call_plugin(\n                    octoprint.plugin.StartupPlugin,\n                    \"on_after_startup\",\n                    sorting_context=\"StartupPlugin.on_after_startup\",\n                )\n\n                def call_on_after_startup(name, plugin):\n                    implementation = plugin.get_implementation(\n                        octoprint.plugin.StartupPlugin\n                    )\n                    if implementation is None:\n                        return\n                    implementation.on_after_startup()\n\n                pluginLifecycleManager.add_callback(\"enabled\", call_on_after_startup)\n\n                # if there was a rogue plugin we wouldn't even have made it here, so remove startup triggered safe mode\n                # flag again...\n                self._settings.setBoolean([\"server\", \"incompleteStartup\"], False)\n                self._settings.save()\n\n                # make a backup of the current config\n                self._settings.backup(ext=\"backup\")\n\n                # when we are through with that we also run our preemptive cache\n                if settings().getBoolean([\"devel\", \"cache\", \"preemptive\"]):\n                    self._execute_preemptive_flask_caching(preemptiveCache)\n\n            import threading\n\n            threading.Thread(target=work).start()\n\n        ioloop.add_callback(on_after_startup)\n\n        # prepare our shutdown function\n        def on_shutdown():\n            # will be called on clean system exit and shutdown the watchdog observer and call the on_shutdown methods\n            # on all registered ShutdownPlugins\n            self._logger.info(\"Shutting down...\")\n            observer.stop()\n            observer.join()\n            eventManager.fire(events.Events.SHUTDOWN)\n\n            self._logger.info(\"Calling on_shutdown on plugins\")\n            octoprint.plugin.call_plugin(\n                octoprint.plugin.ShutdownPlugin,\n                \"on_shutdown\",\n                sorting_context=\"ShutdownPlugin.on_shutdown\",\n            )\n\n            # wait for shutdown event to be processed, but maximally for 15s\n            event_timeout = 15.0\n            if eventManager.join(timeout=event_timeout):\n                self._logger.warning(\n                    \"Event loop was still busy processing after {}s, shutting down anyhow\".format(\n                        event_timeout\n                    )\n                )\n\n            if self._octoprint_daemon is not None:\n                self._logger.info(\"Cleaning up daemon pidfile\")\n                self._octoprint_daemon.terminated()\n\n            self._logger.info(\"Goodbye!\")\n\n        atexit.register(on_shutdown)\n\n        def sigterm_handler(*args, **kwargs):\n            # will stop tornado on SIGTERM, making the program exit cleanly\n            def shutdown_tornado():\n                self._logger.debug(\"Shutting down tornado's IOLoop...\")\n                ioloop.stop()\n\n            self._logger.debug(\"SIGTERM received...\")\n            ioloop.add_callback_from_signal(shutdown_tornado)\n\n        signal.signal(signal.SIGTERM, sigterm_handler)\n\n        try:\n            # this is the main loop - as long as tornado is running, OctoPrint is running\n            ioloop.start()\n            self._logger.debug(\"Tornado's IOLoop stopped\")\n        except (KeyboardInterrupt, SystemExit):\n            pass\n        except Exception:\n            self._logger.fatal(\n                \"Now that is embarrassing... Something really really went wrong here. Please report this including the stacktrace below in OctoPrint's bugtracker. Thanks!\"\n            )\n            self._logger.exception(\"Stacktrace follows:\")\n\n    def _log_safe_mode_start(self, self_mode):\n        self_mode_file = os.path.join(\n            self._settings.getBaseFolder(\"data\"), \"last_safe_mode\"\n        )\n        try:\n            with open(self_mode_file, \"w+\", encoding=\"utf-8\") as f:\n                f.write(self_mode)\n        except Exception as ex:\n            self._logger.warn(f\"Could not write safe mode file {self_mode_file}: {ex}\")\n\n    def _create_socket_connection(self, session):\n        global printer, fileManager, analysisQueue, userManager, eventManager, connectivityChecker\n        return util.sockjs.PrinterStateConnection(\n            printer,\n            fileManager,\n            analysisQueue,\n            userManager,\n            groupManager,\n            eventManager,\n            pluginManager,\n            connectivityChecker,\n            session,\n        )\n\n    def _check_for_root(self):\n        if \"geteuid\" in dir(os) and os.geteuid() == 0:\n            exit(\"You should not run OctoPrint as root!\")\n\n    def _get_locale(self):\n        global LANGUAGES\n\n        if \"l10n\" in request.values:\n            return Locale.negotiate([request.values[\"l10n\"]], LANGUAGES)\n\n        if \"X-Locale\" in request.headers:\n            return Locale.negotiate([request.headers[\"X-Locale\"]], LANGUAGES)\n\n        if hasattr(g, \"identity\") and g.identity:\n            userid = g.identity.id\n            try:\n                user_language = userManager.get_user_setting(\n                    userid, (\"interface\", \"language\")\n                )\n                if user_language is not None and not user_language == \"_default\":\n                    return Locale.negotiate([user_language], LANGUAGES)\n            except octoprint.access.users.UnknownUser:\n                pass\n\n        default_language = self._settings.get([\"appearance\", \"defaultLanguage\"])\n        if (\n            default_language is not None\n            and not default_language == \"_default\"\n            and default_language in LANGUAGES\n        ):\n            return Locale.negotiate([default_language], LANGUAGES)\n\n        return Locale.parse(request.accept_languages.best_match(LANGUAGES))\n\n    def _setup_heartbeat_logging(self):\n        logger = logging.getLogger(__name__ + \".heartbeat\")\n\n        def log_heartbeat():\n            logger.info(\"Server heartbeat <3\")\n\n        interval = settings().getFloat([\"server\", \"heartbeat\"])\n        logger.info(f\"Starting server heartbeat, {interval}s interval\")\n\n        timer = octoprint.util.RepeatedTimer(interval, log_heartbeat)\n        timer.start()\n\n    def _setup_app(self, app):\n        global limiter\n\n        from octoprint.server.util.flask import (\n            OctoPrintFlaskRequest,\n            OctoPrintFlaskResponse,\n            OctoPrintJsonEncoder,\n            OctoPrintSessionInterface,\n            PrefixAwareJinjaEnvironment,\n            ReverseProxiedEnvironment,\n        )\n\n        # we must set this here because setting app.debug will access app.jinja_env\n        app.jinja_environment = PrefixAwareJinjaEnvironment\n\n        app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n        app.config[\"JSONIFY_PRETTYPRINT_REGULAR\"] = False\n        app.config[\"REMEMBER_COOKIE_DURATION\"] = 90 * 24 * 60 * 60  # 90 days\n        app.config[\"REMEMBER_COOKIE_HTTPONLY\"] = True\n        # REMEMBER_COOKIE_SECURE will be taken care of by our custom cookie handling\n\n        # we must not set this before TEMPLATES_AUTO_RELOAD is set to True or that won't take\n        app.debug = self._debug\n\n        # setup octoprint's flask json serialization/deserialization\n        app.json_encoder = OctoPrintJsonEncoder\n\n        s = settings()\n\n        secret_key = s.get([\"server\", \"secretKey\"])\n        if not secret_key:\n            import string\n            from random import choice\n\n            chars = string.ascii_lowercase + string.ascii_uppercase + string.digits\n            secret_key = \"\".join(choice(chars) for _ in range(32))\n            s.set([\"server\", \"secretKey\"], secret_key)\n            s.save()\n\n        app.secret_key = secret_key\n\n        reverse_proxied = ReverseProxiedEnvironment(\n            header_prefix=s.get([\"server\", \"reverseProxy\", \"prefixHeader\"]),\n            header_scheme=s.get([\"server\", \"reverseProxy\", \"schemeHeader\"]),\n            header_host=s.get([\"server\", \"reverseProxy\", \"hostHeader\"]),\n            header_server=s.get([\"server\", \"reverseProxy\", \"serverHeader\"]),\n            header_port=s.get([\"server\", \"reverseProxy\", \"portHeader\"]),\n            prefix=s.get([\"server\", \"reverseProxy\", \"prefixFallback\"]),\n            scheme=s.get([\"server\", \"reverseProxy\", \"schemeFallback\"]),\n            host=s.get([\"server\", \"reverseProxy\", \"hostFallback\"]),\n            server=s.get([\"server\", \"reverseProxy\", \"serverFallback\"]),\n            port=s.get([\"server\", \"reverseProxy\", \"portFallback\"]),\n        )\n\n        OctoPrintFlaskRequest.environment_wrapper = reverse_proxied\n        app.request_class = OctoPrintFlaskRequest\n        app.response_class = OctoPrintFlaskResponse\n        app.session_interface = OctoPrintSessionInterface()\n\n        @app.before_request\n        def before_request():\n            g.locale = self._get_locale()\n\n            # used for performance measurement\n            g.start_time = time.monotonic()\n\n            if self._debug and \"perfprofile\" in request.args:\n                try:\n                    from pyinstrument import Profiler\n\n                    g.perfprofiler = Profiler()\n                    g.perfprofiler.start()\n                except ImportError:\n                    # profiler dependency not installed, ignore\n                    pass\n\n        @app.after_request\n        def after_request(response):\n            # send no-cache headers with all POST responses\n            if request.method == \"POST\":\n                response.cache_control.no_cache = True\n\n            response.headers.add(\"X-Clacks-Overhead\", \"GNU Terry Pratchett\")\n\n            if hasattr(g, \"perfprofiler\"):\n                g.perfprofiler.stop()\n                output_html = g.perfprofiler.output_html()\n                return make_response(output_html)\n\n            if hasattr(g, \"start_time\"):\n                end_time = time.monotonic()\n                duration_ms = int((end_time - g.start_time) * 1000)\n                response.headers.add(\"Server-Timing\", f\"app;dur={duration_ms}\")\n\n            return response\n\n        from octoprint.util.jinja import MarkdownFilter\n\n        MarkdownFilter(app)\n\n        from flask_limiter import Limiter\n        from flask_limiter.util import get_remote_address\n\n        app.config[\"RATELIMIT_STRATEGY\"] = \"fixed-window-elastic-expiry\"\n\n        limiter = Limiter(\n            app,\n            key_func=get_remote_address,\n            enabled=s.getBoolean([\"devel\", \"enableRateLimiter\"]),\n        )\n\n    def _setup_i18n(self, app):\n        global babel\n        global LOCALES\n        global LANGUAGES\n\n        babel = Babel(app)\n\n        def get_available_locale_identifiers(locales):\n            result = set()\n\n            # add available translations\n            for locale in locales:\n                result.add(locale.language)\n                if locale.territory:\n                    # if a territory is specified, add that too\n                    result.add(f\"{locale.language}_{locale.territory}\")\n\n            return result\n\n        LOCALES = babel.list_translations()\n        LANGUAGES = get_available_locale_identifiers(LOCALES)\n\n        @babel.localeselector\n        def get_locale():\n            return self._get_locale()\n\n    def _setup_jinja2(self):\n        import re\n\n        app.jinja_env.add_extension(\"jinja2.ext.do\")\n        app.jinja_env.add_extension(\"octoprint.util.jinja.trycatch\")\n\n        def regex_replace(s, find, replace):\n            return re.sub(find, replace, s)\n\n        html_header_regex = re.compile(\n            r\"<h(?P<number>[1-6])>(?P<content>.*?)</h(?P=number)>\"\n        )\n\n        def offset_html_headers(s, offset):\n            def repl(match):\n                number = int(match.group(\"number\"))\n                number += offset\n                if number > 6:\n                    number = 6\n                elif number < 1:\n                    number = 1\n                return \"<h{number}>{content}</h{number}>\".format(\n                    number=number, content=match.group(\"content\")\n                )\n\n            return html_header_regex.sub(repl, s)\n\n        markdown_header_regex = re.compile(\n            r\"^(?P<hashs>#+)\\s+(?P<content>.*)$\", flags=re.MULTILINE\n        )\n\n        def offset_markdown_headers(s, offset):\n            def repl(match):\n                number = len(match.group(\"hashs\"))\n                number += offset\n                if number > 6:\n                    number = 6\n                elif number < 1:\n                    number = 1\n                return \"{hashs} {content}\".format(\n                    hashs=\"#\" * number, content=match.group(\"content\")\n                )\n\n            return markdown_header_regex.sub(repl, s)\n\n        html_link_regex = re.compile(r\"<(?P<tag>a.*?)>(?P<content>.*?)</a>\")\n\n        def externalize_links(text):\n            def repl(match):\n                tag = match.group(\"tag\")\n                if \"href\" not in tag:\n                    return match.group(0)\n\n                if \"target=\" not in tag and \"rel=\" not in tag:\n                    tag += ' target=\"_blank\" rel=\"noreferrer noopener\"'\n\n                content = match.group(\"content\")\n                return f\"<{tag}>{content}</a>\"\n\n            return html_link_regex.sub(repl, text)\n\n        single_quote_regex = re.compile(\"(?<!\\\\\\\\)'\")\n\n        def escape_single_quote(text):\n            return single_quote_regex.sub(\"\\\\'\", text)\n\n        double_quote_regex = re.compile('(?<!\\\\\\\\)\"')\n\n        def escape_double_quote(text):\n            return double_quote_regex.sub('\\\\\"', text)\n\n        app.jinja_env.filters[\"regex_replace\"] = regex_replace\n        app.jinja_env.filters[\"offset_html_headers\"] = offset_html_headers\n        app.jinja_env.filters[\"offset_markdown_headers\"] = offset_markdown_headers\n        app.jinja_env.filters[\"externalize_links\"] = externalize_links\n        app.jinja_env.filters[\"escape_single_quote\"] = app.jinja_env.filters[\n            \"esq\"\n        ] = escape_single_quote\n        app.jinja_env.filters[\"escape_double_quote\"] = app.jinja_env.filters[\n            \"edq\"\n        ] = escape_double_quote\n\n        # configure additional template folders for jinja2\n        import jinja2\n\n        import octoprint.util.jinja\n\n        app.jinja_env.prefix_loader = jinja2.PrefixLoader({})\n\n        loaders = [app.jinja_loader, app.jinja_env.prefix_loader]\n        if octoprint.util.is_running_from_source():\n            root = os.path.abspath(os.path.join(os.path.dirname(__file__), \"../../..\"))\n            allowed = [\"AUTHORS.md\", \"SUPPORTERS.md\", \"THIRDPARTYLICENSES.md\"]\n            files = {\"_data/\" + name: os.path.join(root, name) for name in allowed}\n            loaders.append(octoprint.util.jinja.SelectedFilesWithConversionLoader(files))\n\n        # TODO: Remove this in 2.0.0\n        warning_message = \"Loading plugin template '{template}' from '{filename}' without plugin prefix, this is deprecated and will soon no longer be supported.\"\n        loaders.append(\n            octoprint.util.jinja.WarningLoader(\n                octoprint.util.jinja.PrefixChoiceLoader(app.jinja_env.prefix_loader),\n                warning_message,\n            )\n        )\n\n        app.jinja_loader = jinja2.ChoiceLoader(loaders)\n\n        self._register_template_plugins()\n\n        # make sure plugin lifecycle events relevant for jinja2 are taken care of\n        def template_enabled(name, plugin):\n            if plugin.implementation is None or not isinstance(\n                plugin.implementation, octoprint.plugin.TemplatePlugin\n            ):\n                return\n            self._register_additional_template_plugin(plugin.implementation)\n\n        def template_disabled(name, plugin):\n            if plugin.implementation is None or not isinstance(\n                plugin.implementation, octoprint.plugin.TemplatePlugin\n            ):\n                return\n            self._unregister_additional_template_plugin(plugin.implementation)\n\n        pluginLifecycleManager.add_callback(\"enabled\", template_enabled)\n        pluginLifecycleManager.add_callback(\"disabled\", template_disabled)\n\n    def _execute_preemptive_flask_caching(self, preemptive_cache):\n        import time\n\n        from werkzeug.test import EnvironBuilder\n\n        # we clean up entries from our preemptive cache settings that haven't been\n        # accessed longer than server.preemptiveCache.until days\n        preemptive_cache_timeout = settings().getInt(\n            [\"server\", \"preemptiveCache\", \"until\"]\n        )\n        cutoff_timestamp = time.time() - preemptive_cache_timeout * 24 * 60 * 60\n\n        def filter_current_entries(entry):\n            \"\"\"Returns True for entries younger than the cutoff date\"\"\"\n            return \"_timestamp\" in entry and entry[\"_timestamp\"] > cutoff_timestamp\n\n        def filter_http_entries(entry):\n            \"\"\"Returns True for entries targeting http or https.\"\"\"\n            return (\n                \"base_url\" in entry\n                and entry[\"base_url\"]\n                and (\n                    entry[\"base_url\"].startswith(\"http://\")\n                    or entry[\"base_url\"].startswith(\"https://\")\n                )\n            )\n\n        def filter_entries(entry):\n            \"\"\"Combined filter.\"\"\"\n            filters = (filter_current_entries, filter_http_entries)\n            return all([f(entry) for f in filters])\n\n        # filter out all old and non-http entries\n        cache_data = preemptive_cache.clean_all_data(\n            lambda root, entries: list(filter(filter_entries, entries))\n        )\n        if not cache_data:\n            return\n\n        def execute_caching():\n            logger = logging.getLogger(__name__ + \".preemptive_cache\")\n\n            for route in sorted(cache_data.keys(), key=lambda x: (x.count(\"/\"), x)):\n                entries = reversed(\n                    sorted(cache_data[route], key=lambda x: x.get(\"_count\", 0))\n                )\n                for kwargs in entries:\n                    plugin = kwargs.get(\"plugin\", None)\n                    if plugin:\n                        try:\n                            plugin_info = pluginManager.get_plugin_info(\n                                plugin, require_enabled=True\n                            )\n                            if plugin_info is None:\n                                logger.info(\n                                    \"About to preemptively cache plugin {} but it is not installed or enabled, preemptive caching makes no sense\".format(\n                                        plugin\n                                    )\n                                )\n                                continue\n\n                            implementation = plugin_info.implementation\n                            if implementation is None or not isinstance(\n                                implementation, octoprint.plugin.UiPlugin\n                            ):\n                                logger.info(\n                                    \"About to preemptively cache plugin {} but it is not a UiPlugin, preemptive caching makes no sense\".format(\n                                        plugin\n                                    )\n                                )\n                                continue\n                            if not implementation.get_ui_preemptive_caching_enabled():\n                                logger.info(\n                                    \"About to preemptively cache plugin {} but it has disabled preemptive caching\".format(\n                                        plugin\n                                    )\n                                )\n                                continue\n                        except Exception:\n                            logger.exception(\n                                \"Error while trying to check if plugin {} has preemptive caching enabled, skipping entry\"\n                            )\n                            continue\n\n                    additional_request_data = kwargs.get(\"_additional_request_data\", {})\n                    kwargs = {\n                        k: v\n                        for k, v in kwargs.items()\n                        if not k.startswith(\"_\") and not k == \"plugin\"\n                    }\n                    kwargs.update(additional_request_data)\n\n                    try:\n                        start = time.monotonic()\n                        if plugin:\n                            logger.info(\n                                \"Preemptively caching {} (ui {}) for {!r}\".format(\n                                    route, plugin, kwargs\n                                )\n                            )\n                        else:\n                            logger.info(\n                                \"Preemptively caching {} (ui _default) for {!r}\".format(\n                                    route, kwargs\n                                )\n                            )\n\n                        headers = kwargs.get(\"headers\", {})\n                        headers[\"X-Force-View\"] = plugin if plugin else \"_default\"\n                        headers[\"X-Preemptive-Recording\"] = \"yes\"\n                        kwargs[\"headers\"] = headers\n\n                        builder = EnvironBuilder(**kwargs)\n                        app(builder.get_environ(), lambda *a, **kw: None)\n\n                        logger.info(f\"... done in {time.monotonic() - start:.2f}s\")\n                    except Exception:\n                        logger.exception(\n                            \"Error while trying to preemptively cache {} for {!r}\".format(\n                                route, kwargs\n                            )\n                        )\n\n        # asynchronous caching\n        import threading\n\n        cache_thread = threading.Thread(\n            target=execute_caching, name=\"Preemptive Cache Worker\"\n        )\n        cache_thread.daemon = True\n        cache_thread.start()\n\n    def _register_template_plugins(self):\n        template_plugins = pluginManager.get_implementations(\n            octoprint.plugin.TemplatePlugin\n        )\n        for plugin in template_plugins:\n            try:\n                self._register_additional_template_plugin(plugin)\n            except Exception:\n                self._logger.exception(\n                    \"Error while trying to register templates of plugin {}, ignoring it\".format(\n                        plugin._identifier\n                    )\n                )\n\n    def _register_additional_template_plugin(self, plugin):\n        import octoprint.util.jinja\n\n        folder = plugin.get_template_folder()\n        if (\n            folder is not None\n            and plugin.template_folder_key not in app.jinja_env.prefix_loader.mapping\n        ):\n            loader = octoprint.util.jinja.FilteredFileSystemLoader(\n                [plugin.get_template_folder()],\n                path_filter=lambda x: not octoprint.util.is_hidden_path(x),\n            )\n\n            app.jinja_env.prefix_loader.mapping[plugin.template_folder_key] = loader\n\n    def _unregister_additional_template_plugin(self, plugin):\n        folder = plugin.get_template_folder()\n        if (\n            folder is not None\n            and plugin.template_folder_key in app.jinja_env.prefix_loader.mapping\n        ):\n            del app.jinja_env.prefix_loader.mapping[plugin.template_folder_key]\n\n    def _setup_blueprints(self):\n        # do not remove or the index view won't be found\n        import octoprint.server.views  # noqa: F401\n        from octoprint.server.api import api\n        from octoprint.server.util.flask import make_api_error\n\n        blueprints = [api]\n        api_endpoints = [\"/api\"]\n        registrators = [functools.partial(app.register_blueprint, api, url_prefix=\"/api\")]\n\n        # also register any blueprints defined in BlueprintPlugins\n        (\n            blueprints_from_plugins,\n            api_endpoints_from_plugins,\n            registrators_from_plugins,\n        ) = self._prepare_blueprint_plugins()\n        blueprints += blueprints_from_plugins\n        api_endpoints += api_endpoints_from_plugins\n        registrators += registrators_from_plugins\n\n        # and register a blueprint for serving the static files of asset plugins which are not blueprint plugins themselves\n        (blueprints_from_assets, registrators_from_assets) = self._prepare_asset_plugins()\n        blueprints += blueprints_from_assets\n        registrators += registrators_from_assets\n\n        # make sure all before/after_request hook results are attached as well\n        self._add_plugin_request_handlers_to_blueprints(*blueprints)\n\n        # register everything with the system\n        for registrator in registrators:\n            registrator()\n\n        @app.errorhandler(HTTPException)\n        def _handle_api_error(ex):\n            if any(map(lambda x: request.path.startswith(x), api_endpoints)):\n                return make_api_error(ex.description, ex.code)\n            else:\n                return ex\n\n    def _prepare_blueprint_plugins(self):\n        def register_plugin_blueprint(plugin, blueprint, url_prefix):\n            try:\n                app.register_blueprint(\n                    blueprint, url_prefix=url_prefix, name_prefix=\"plugin\"\n                )\n                self._logger.debug(\n                    f\"Registered API of plugin {plugin} under URL prefix {url_prefix}\"\n                )\n            except Exception:\n                self._logger.exception(\n                    f\"Error while registering blueprint of plugin {plugin}, ignoring it\",\n                    extra={\"plugin\": plugin},\n                )\n\n        blueprints = []\n        api_endpoints = []\n        registrators = []\n\n        blueprint_plugins = octoprint.plugin.plugin_manager().get_implementations(\n            octoprint.plugin.BlueprintPlugin\n        )\n        for plugin in blueprint_plugins:\n            blueprint, prefix = self._prepare_blueprint_plugin(plugin)\n\n            blueprints.append(blueprint)\n            api_endpoints += map(\n                lambda x: prefix + x, plugin.get_blueprint_api_prefixes()\n            )\n            registrators.append(\n                functools.partial(\n                    register_plugin_blueprint, plugin._identifier, blueprint, prefix\n                )\n            )\n\n        return blueprints, api_endpoints, registrators\n\n    def _prepare_asset_plugins(self):\n        def register_asset_blueprint(plugin, blueprint, url_prefix):\n            try:\n                app.register_blueprint(\n                    blueprint, url_prefix=url_prefix, name_prefix=\"plugin\"\n                )\n                self._logger.debug(\n                    f\"Registered assets of plugin {plugin} under URL prefix {url_prefix}\"\n                )\n            except Exception:\n                self._logger.exception(\n                    f\"Error while registering blueprint of plugin {plugin}, ignoring it\",\n                    extra={\"plugin\": plugin},\n                )\n\n        blueprints = []\n        registrators = []\n\n        asset_plugins = octoprint.plugin.plugin_manager().get_implementations(\n            octoprint.plugin.AssetPlugin\n        )\n        for plugin in asset_plugins:\n            if isinstance(plugin, octoprint.plugin.BlueprintPlugin):\n                continue\n            blueprint, prefix = self._prepare_asset_plugin(plugin)\n\n            blueprints.append(blueprint)\n            registrators.append(\n                functools.partial(\n                    register_asset_blueprint, plugin._identifier, blueprint, prefix\n                )\n            )\n\n        return blueprints, registrators\n\n    def _prepare_blueprint_plugin(self, plugin):\n        name = plugin._identifier\n        blueprint = plugin.get_blueprint()\n        if blueprint is None:\n            return\n\n        blueprint.before_request(corsRequestHandler)\n        blueprint.before_request(loginFromApiKeyRequestHandler)\n        blueprint.after_request(corsResponseHandler)\n\n        if plugin.is_blueprint_protected():\n            blueprint.before_request(requireLoginRequestHandler)\n\n        url_prefix = f\"/plugin/{name}\"\n        return blueprint, url_prefix\n\n    def _prepare_asset_plugin(self, plugin):\n        name = plugin._identifier\n\n        url_prefix = f\"/plugin/{name}\"\n        blueprint = Blueprint(name, name, static_folder=plugin.get_asset_folder())\n        return blueprint, url_prefix\n\n    def _add_plugin_request_handlers_to_blueprints(self, *blueprints):\n        before_hooks = octoprint.plugin.plugin_manager().get_hooks(\n            \"octoprint.server.api.before_request\"\n        )\n        after_hooks = octoprint.plugin.plugin_manager().get_hooks(\n            \"octoprint.server.api.after_request\"\n        )\n\n        for name, hook in before_hooks.items():\n            plugin = octoprint.plugin.plugin_manager().get_plugin(name)\n            for blueprint in blueprints:\n                try:\n                    result = hook(plugin=plugin)\n                    if isinstance(result, (list, tuple)):\n                        for h in result:\n                            blueprint.before_request(h)\n                except Exception:\n                    self._logger.exception(\n                        \"Error processing before_request hooks from plugin {}\".format(\n                            plugin\n                        ),\n                        extra={\"plugin\": name},\n                    )\n\n        for name, hook in after_hooks.items():\n            plugin = octoprint.plugin.plugin_manager().get_plugin(name)\n            for blueprint in blueprints:\n                try:\n                    result = hook(plugin=plugin)\n                    if isinstance(result, (list, tuple)):\n                        for h in result:\n                            blueprint.after_request(h)\n                except Exception:\n                    self._logger.exception(\n                        \"Error processing after_request hooks from plugin {}\".format(\n                            plugin\n                        ),\n                        extra={\"plugin\": name},\n                    )\n\n    def _setup_mimetypes(self):\n        # Safety measures for Windows... apparently the mimetypes module takes its translation from the windows\n        # registry, and if for some weird reason that gets borked the reported MIME types can be all over the place.\n        # Since at least in Chrome that can cause hilarious issues with JS files (refusal to run them and thus a\n        # borked UI) we make sure that .js always maps to the correct application/javascript, and also throw in a\n        # .css -> text/css for good measure.\n        #\n        # See #3367\n        mimetypes.add_type(\"application/javascript\", \".js\")\n        mimetypes.add_type(\"text/css\", \".css\")\n\n    def _setup_assets(self):\n        global app\n        global assets\n        global pluginManager\n\n        from octoprint.server.util.webassets import MemoryManifest  # noqa: F401\n\n        util.flask.fix_webassets_filtertool()\n\n        base_folder = self._settings.getBaseFolder(\"generated\")\n\n        # clean the folder\n        if self._settings.getBoolean([\"devel\", \"webassets\", \"clean_on_startup\"]):\n            import errno\n            import shutil\n\n            for entry, recreate in (\n                (\"webassets\", True),\n                # no longer used, but clean up just in case\n                (\".webassets-cache\", False),\n                (\".webassets-manifest.json\", False),\n            ):\n                path = os.path.join(base_folder, entry)\n\n                # delete path if it exists\n                if os.path.exists(path):\n                    try:\n                        self._logger.debug(f\"Deleting {path}...\")\n                        if os.path.isdir(path):\n                            shutil.rmtree(path)\n                        else:\n                            os.remove(path)\n                    except Exception:\n                        self._logger.exception(\n                            f\"Error while trying to delete {path}, \" f\"leaving it alone\"\n                        )\n                        continue\n\n                # re-create path if necessary\n                if recreate:\n                    self._logger.debug(f\"Creating {path}...\")\n                    error_text = (\n                        f\"Error while trying to re-create {path}, that might cause \"\n                        f\"errors with the webassets cache\"\n                    )\n                    try:\n                        os.makedirs(path)\n                    except OSError as e:\n                        if e.errno == errno.EACCES:\n                            # that might be caused by the user still having the folder open somewhere, let's try again after\n                            # waiting a bit\n                            import time\n\n                            for n in range(3):\n                                time.sleep(0.5)\n                                self._logger.debug(\n                                    \"Creating {path}: Retry #{retry} after {time}s\".format(\n                                        path=path, retry=n + 1, time=(n + 1) * 0.5\n                                    )\n                                )\n                                try:\n                                    os.makedirs(path)\n                                    break\n                                except Exception:\n                                    if self._logger.isEnabledFor(logging.DEBUG):\n                                        self._logger.exception(\n                                            f\"Ignored error while creating \"\n                                            f\"directory {path}\"\n                                        )\n                                    pass\n                            else:\n                                # this will only get executed if we never did\n                                # successfully execute makedirs above\n                                self._logger.exception(error_text)\n                                continue\n                        else:\n                            # not an access error, so something we don't understand\n                            # went wrong -> log an error and stop\n                            self._logger.exception(error_text)\n                            continue\n                    except Exception:\n                        # not an OSError, so something we don't understand\n                        # went wrong -> log an error and stop\n                        self._logger.exception(error_text)\n                        continue\n\n                self._logger.info(f\"Reset webasset folder {path}...\")\n\n        AdjustedEnvironment = type(Environment)(\n            Environment.__name__,\n            (Environment,),\n            {\"resolver_class\": util.flask.PluginAssetResolver},\n        )\n\n        class CustomDirectoryEnvironment(AdjustedEnvironment):\n            @property\n            def directory(self):\n                return base_folder\n\n        assets = CustomDirectoryEnvironment(app)\n        assets.debug = not self._settings.getBoolean([\"devel\", \"webassets\", \"bundle\"])\n\n        # we should rarely if ever regenerate the webassets in production and can wait a\n        # few seconds for regeneration in development, if it means we can get rid of\n        # a whole monkey patch and in internal use of pickle with non-tamperproof files\n        assets.cache = False\n        assets.manifest = \"memory\"\n\n        UpdaterType = type(util.flask.SettingsCheckUpdater)(\n            util.flask.SettingsCheckUpdater.__name__,\n            (util.flask.SettingsCheckUpdater,),\n            {\"updater\": assets.updater},\n        )\n        assets.updater = UpdaterType\n\n        preferred_stylesheet = self._settings.get([\"devel\", \"stylesheet\"])\n\n        dynamic_core_assets = util.flask.collect_core_assets()\n        dynamic_plugin_assets = util.flask.collect_plugin_assets(\n            preferred_stylesheet=preferred_stylesheet\n        )\n\n        js_libs = [\n            \"js/lib/babel-polyfill.min.js\",\n            \"js/lib/jquery/jquery.min.js\",\n            \"js/lib/modernizr.custom.js\",\n            \"js/lib/lodash.min.js\",\n            \"js/lib/sprintf.min.js\",\n            \"js/lib/knockout.js\",\n            \"js/lib/knockout.mapping-latest.js\",\n            \"js/lib/babel.js\",\n            \"js/lib/bootstrap/bootstrap.js\",\n            \"js/lib/bootstrap/bootstrap-modalmanager.js\",\n            \"js/lib/bootstrap/bootstrap-modal.js\",\n            \"js/lib/bootstrap/bootstrap-slider.js\",\n            \"js/lib/bootstrap/bootstrap-tabdrop.js\",\n            \"js/lib/jquery/jquery-ui.js\",\n            \"js/lib/jquery/jquery.flot.js\",\n            \"js/lib/jquery/jquery.flot.time.js\",\n            \"js/lib/jquery/jquery.flot.crosshair.js\",\n            \"js/lib/jquery/jquery.flot.resize.js\",\n            \"js/lib/jquery/jquery.iframe-transport.js\",\n            \"js/lib/jquery/jquery.fileupload.js\",\n            \"js/lib/jquery/jquery.slimscroll.min.js\",\n            \"js/lib/jquery/jquery.qrcode.min.js\",\n            \"js/lib/jquery/jquery.bootstrap.wizard.js\",\n            \"js/lib/pnotify/pnotify.core.min.js\",\n            \"js/lib/pnotify/pnotify.buttons.min.js\",\n            \"js/lib/pnotify/pnotify.callbacks.min.js\",\n            \"js/lib/pnotify/pnotify.confirm.min.js\",\n            \"js/lib/pnotify/pnotify.desktop.min.js\",\n            \"js/lib/pnotify/pnotify.history.min.js\",\n            \"js/lib/pnotify/pnotify.mobile.min.js\",\n            \"js/lib/pnotify/pnotify.nonblock.min.js\",\n            \"js/lib/pnotify/pnotify.reference.min.js\",\n            \"js/lib/pnotify/pnotify.tooltip.min.js\",\n            \"js/lib/pnotify/pnotify.maxheight.js\",\n            \"js/lib/moment-with-locales.min.js\",\n            \"js/lib/pusher.color.min.js\",\n            \"js/lib/detectmobilebrowser.js\",\n            \"js/lib/ua-parser.min.js\",\n            \"js/lib/md5.min.js\",\n            \"js/lib/bootstrap-slider-knockout-binding.js\",\n            \"js/lib/loglevel.min.js\",\n            \"js/lib/sockjs.min.js\",\n            \"js/lib/hls.js\",\n            \"js/lib/less.js\",\n        ]\n\n        css_libs = [\n            \"css/bootstrap.min.css\",\n            \"css/bootstrap-modal.css\",\n            \"css/bootstrap-slider.css\",\n            \"css/bootstrap-tabdrop.css\",\n            \"vendor/font-awesome-3.2.1/css/font-awesome.min.css\",\n            \"vendor/font-awesome-5.15.1/css/all.min.css\",\n            \"vendor/font-awesome-5.15.1/css/v4-shims.min.css\",\n            \"css/jquery.fileupload-ui.css\",\n            \"css/pnotify.core.min.css\",\n            \"css/pnotify.buttons.min.css\",\n            \"css/pnotify.history.min.css\",\n        ]\n\n        # a couple of custom filters\n        from webassets.filter import register_filter\n\n        from octoprint.server.util.webassets import (\n            GzipFile,\n            JsDelimiterBundler,\n            JsPluginBundle,\n            LessImportRewrite,\n            RJSMinExtended,\n            SourceMapRemove,\n            SourceMapRewrite,\n        )\n\n        register_filter(LessImportRewrite)\n        register_filter(SourceMapRewrite)\n        register_filter(SourceMapRemove)\n        register_filter(JsDelimiterBundler)\n        register_filter(GzipFile)\n        register_filter(RJSMinExtended)\n\n        def all_assets_for_plugins(collection):\n            \"\"\"Gets all plugin assets for a dict of plugin->assets\"\"\"\n            result = []\n            for assets in collection.values():\n                result += assets\n            return result\n\n        # -- JS --------------------------------------------------------------------------------------------------------\n\n        filters = [\"sourcemap_remove\"]\n        if self._settings.getBoolean([\"devel\", \"webassets\", \"minify\"]):\n            filters += [\"rjsmin_extended\"]\n        filters += [\"js_delimiter_bundler\", \"gzip\"]\n\n        js_filters = filters\n        if self._settings.getBoolean([\"devel\", \"webassets\", \"minify_plugins\"]):\n            js_plugin_filters = js_filters\n        else:\n            js_plugin_filters = [x for x in js_filters if x not in (\"rjsmin_extended\",)]\n\n        def js_bundles_for_plugins(collection, filters=None):\n            \"\"\"Produces JsPluginBundle instances that output IIFE wrapped assets\"\"\"\n            result = OrderedDict()\n            for plugin, assets in collection.items():\n                if len(assets):\n                    result[plugin] = JsPluginBundle(plugin, *assets, filters=filters)\n            return result\n\n        js_core = (\n            dynamic_core_assets[\"js\"]\n            + all_assets_for_plugins(dynamic_plugin_assets[\"bundled\"][\"js\"])\n            + [\"js/app/dataupdater.js\", \"js/app/helpers.js\", \"js/app/main.js\"]\n        )\n        js_plugins = js_bundles_for_plugins(\n            dynamic_plugin_assets[\"external\"][\"js\"], filters=\"js_delimiter_bundler\"\n        )\n\n        clientjs_core = dynamic_core_assets[\"clientjs\"] + all_assets_for_plugins(\n            dynamic_plugin_assets[\"bundled\"][\"clientjs\"]\n        )\n        clientjs_plugins = js_bundles_for_plugins(\n            dynamic_plugin_assets[\"external\"][\"clientjs\"], filters=\"js_delimiter_bundler\"\n        )\n\n        js_libs_bundle = Bundle(\n            *js_libs, output=\"webassets/packed_libs.js\", filters=\",\".join(js_filters)\n        )\n\n        js_core_bundle = Bundle(\n            *js_core, output=\"webassets/packed_core.js\", filters=\",\".join(js_filters)\n        )\n\n        if len(js_plugins) == 0:\n            js_plugins_bundle = Bundle(*[])\n        else:\n            js_plugins_bundle = Bundle(\n                *js_plugins.values(),\n                output=\"webassets/packed_plugins.js\",\n                filters=\",\".join(js_plugin_filters),\n            )\n\n        js_app_bundle = Bundle(\n            js_plugins_bundle,\n            js_core_bundle,\n            output=\"webassets/packed_app.js\",\n            filters=\",\".join(js_plugin_filters),\n        )\n\n        js_client_core_bundle = Bundle(\n            *clientjs_core,\n            output=\"webassets/packed_client_core.js\",\n            filters=\",\".join(js_filters),\n        )\n\n        if len(clientjs_plugins) == 0:\n            js_client_plugins_bundle = Bundle(*[])\n        else:\n            js_client_plugins_bundle = Bundle(\n                *clientjs_plugins.values(),\n                output=\"webassets/packed_client_plugins.js\",\n                filters=\",\".join(js_plugin_filters),\n            )\n\n        js_client_bundle = Bundle(\n            js_client_core_bundle,\n            js_client_plugins_bundle,\n            output=\"webassets/packed_client.js\",\n            filters=\",\".join(js_plugin_filters),\n        )\n\n        # -- CSS -------------------------------------------------------------------------------------------------------\n\n        css_filters = [\"cssrewrite\", \"gzip\"]\n\n        css_core = list(dynamic_core_assets[\"css\"]) + all_assets_for_plugins(\n            dynamic_plugin_assets[\"bundled\"][\"css\"]\n        )\n        css_plugins = list(\n            all_assets_for_plugins(dynamic_plugin_assets[\"external\"][\"css\"])\n        )\n\n        css_libs_bundle = Bundle(\n            *css_libs, output=\"webassets/packed_libs.css\", filters=\",\".join(css_filters)\n        )\n\n        if len(css_core) == 0:\n            css_core_bundle = Bundle(*[])\n        else:\n            css_core_bundle = Bundle(\n                *css_core,\n                output=\"webassets/packed_core.css\",\n                filters=\",\".join(css_filters),\n            )\n\n        if len(css_plugins) == 0:\n            css_plugins_bundle = Bundle(*[])\n        else:\n            css_plugins_bundle = Bundle(\n                *css_plugins,\n                output=\"webassets/packed_plugins.css\",\n                filters=\",\".join(css_filters),\n            )\n\n        css_app_bundle = Bundle(\n            css_core,\n            css_plugins,\n            output=\"webassets/packed_app.css\",\n            filters=\",\".join(css_filters),\n        )\n\n        # -- LESS ------------------------------------------------------------------------------------------------------\n\n        less_filters = [\"cssrewrite\", \"less_importrewrite\", \"gzip\"]\n\n        less_core = list(dynamic_core_assets[\"less\"]) + all_assets_for_plugins(\n            dynamic_plugin_assets[\"bundled\"][\"less\"]\n        )\n        less_plugins = all_assets_for_plugins(dynamic_plugin_assets[\"external\"][\"less\"])\n\n        if len(less_core) == 0:\n            less_core_bundle = Bundle(*[])\n        else:\n            less_core_bundle = Bundle(\n                *less_core,\n                output=\"webassets/packed_core.less\",\n                filters=\",\".join(less_filters),\n            )\n\n        if len(less_plugins) == 0:\n            less_plugins_bundle = Bundle(*[])\n        else:\n            less_plugins_bundle = Bundle(\n                *less_plugins,\n                output=\"webassets/packed_plugins.less\",\n                filters=\",\".join(less_filters),\n            )\n\n        less_app_bundle = Bundle(\n            less_core,\n            less_plugins,\n            output=\"webassets/packed_app.less\",\n            filters=\",\".join(less_filters),\n        )\n\n        # -- asset registration ----------------------------------------------------------------------------------------\n\n        assets.register(\"js_libs\", js_libs_bundle)\n        assets.register(\"js_client_core\", js_client_core_bundle)\n        for plugin, bundle in clientjs_plugins.items():\n            # register our collected clientjs plugin bundles so that they are bound to the environment\n            assets.register(f\"js_client_plugin_{plugin}\", bundle)\n        assets.register(\"js_client_plugins\", js_client_plugins_bundle)\n        assets.register(\"js_client\", js_client_bundle)\n        assets.register(\"js_core\", js_core_bundle)\n        for plugin, bundle in js_plugins.items():\n            # register our collected plugin bundles so that they are bound to the environment\n            assets.register(f\"js_plugin_{plugin}\", bundle)\n        assets.register(\"js_plugins\", js_plugins_bundle)\n        assets.register(\"js_app\", js_app_bundle)\n        assets.register(\"css_libs\", css_libs_bundle)\n        assets.register(\"css_core\", css_core_bundle)\n        assets.register(\"css_plugins\", css_plugins_bundle)\n        assets.register(\"css_app\", css_app_bundle)\n        assets.register(\"less_core\", less_core_bundle)\n        assets.register(\"less_plugins\", less_plugins_bundle)\n        assets.register(\"less_app\", less_app_bundle)\n\n    def _setup_login_manager(self):\n        global loginManager\n\n        loginManager = LoginManager()\n\n        # \"strong\" is incompatible to remember me, see maxcountryman/flask-login#156. It also causes issues with\n        # clients toggling between IPv4 and IPv6 client addresses due to names being resolved one way or the other as\n        # at least observed on a Win10 client targeting \"localhost\", resolved as both \"127.0.0.1\" and \"::1\"\n        loginManager.session_protection = \"basic\"\n\n        loginManager.user_loader(load_user)\n        loginManager.unauthorized_handler(unauthorized_user)\n        loginManager.anonymous_user = userManager.anonymous_user_factory\n        loginManager.request_loader(load_user_from_request)\n\n        loginManager.init_app(app, add_context_processor=False)\n\n    def _start_intermediary_server(self):\n        import socket\n        import threading\n        from http.server import BaseHTTPRequestHandler, HTTPServer\n\n        host = self._host\n        port = self._port\n\n        class IntermediaryServerHandler(BaseHTTPRequestHandler):\n            def __init__(self, rules=None, *args, **kwargs):\n                if rules is None:\n                    rules = []\n                self.rules = rules\n                BaseHTTPRequestHandler.__init__(self, *args, **kwargs)\n\n            def do_GET(self):\n                request_path = self.path\n                if \"?\" in request_path:\n                    request_path = request_path[0 : request_path.find(\"?\")]\n\n                for rule in self.rules:\n                    path, data, content_type = rule\n                    if request_path == path:\n                        self.send_response(200)\n                        if content_type:\n                            self.send_header(\"Content-Type\", content_type)\n                        self.end_headers()\n                        if isinstance(data, str):\n                            data = data.encode(\"utf-8\")\n                        self.wfile.write(data)\n                        break\n                else:\n                    self.send_response(404)\n                    self.wfile.write(b\"Not found\")\n\n        base_path = os.path.realpath(\n            os.path.join(os.path.dirname(__file__), \"..\", \"static\")\n        )\n        rules = [\n            (\n                \"/\",\n                [\n                    \"intermediary.html\",\n                ],\n                \"text/html\",\n            ),\n            (\"/favicon.ico\", [\"img\", \"tentacle-20x20.png\"], \"image/png\"),\n            (\n                \"/intermediary.gif\",\n                bytes(\n                    base64.b64decode(\n                        \"R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"\n                    )\n                ),\n                \"image/gif\",\n            ),\n        ]\n\n        def contents(args):\n            path = os.path.join(base_path, *args)\n            if not os.path.isfile(path):\n                return \"\"\n\n            with open(path, \"rb\") as f:\n                data = f.read()\n            return data\n\n        def process(rule):\n            if len(rule) == 2:\n                path, data = rule\n                content_type = None\n            else:\n                path, data, content_type = rule\n\n            if isinstance(data, (list, tuple)):\n                data = contents(data)\n\n            return path, data, content_type\n\n        rules = list(\n            map(process, filter(lambda rule: len(rule) == 2 or len(rule) == 3, rules))\n        )\n\n        HTTPServerV4 = HTTPServer\n\n        class HTTPServerV6(HTTPServer):\n            address_family = socket.AF_INET6\n\n        class HTTPServerV6SingleStack(HTTPServerV6):\n            def __init__(self, *args, **kwargs):\n                HTTPServerV6.__init__(self, *args, **kwargs)\n\n                # explicitly set V6ONLY flag - seems to be the default, but just to make sure...\n                self.socket.setsockopt(\n                    octoprint.util.net.IPPROTO_IPV6, octoprint.util.net.IPV6_V6ONLY, 1\n                )\n\n        class HTTPServerV6DualStack(HTTPServerV6):\n            def __init__(self, *args, **kwargs):\n                HTTPServerV6.__init__(self, *args, **kwargs)\n\n                # explicitly unset V6ONLY flag\n                self.socket.setsockopt(\n                    octoprint.util.net.IPPROTO_IPV6, octoprint.util.net.IPV6_V6ONLY, 0\n                )\n\n        if \":\" in host:\n            # v6\n            if host == \"::\" and not self._v6_only:\n                ServerClass = HTTPServerV6DualStack\n            else:\n                ServerClass = HTTPServerV6SingleStack\n        else:\n            # v4\n            ServerClass = HTTPServerV4\n\n        if host == \"::\":\n            if self._v6_only:\n                self._logger.debug(f\"Starting intermediary server on http://[::]:{port}\")\n            else:\n                self._logger.debug(\n                    \"Starting intermediary server on http://0.0.0.0:{port} and http://[::]:{port}\".format(\n                        port=port\n                    )\n                )\n        else:\n            self._logger.debug(\n                \"Starting intermediary server on http://{}:{}\".format(\n                    host if \":\" not in host else \"[\" + host + \"]\", port\n                )\n            )\n\n        self._intermediary_server = ServerClass(\n            (host, port),\n            lambda *args, **kwargs: IntermediaryServerHandler(rules, *args, **kwargs),\n            bind_and_activate=False,\n        )\n\n        # if possible, make sure our socket's port descriptor isn't handed over to subprocesses\n        from octoprint.util.platform import set_close_exec\n\n        try:\n            set_close_exec(self._intermediary_server.fileno())\n        except Exception:\n            self._logger.exception(\n                \"Error while attempting to set_close_exec on intermediary server socket\"\n            )\n\n        # then bind the server and have it serve our handler until stopped\n        try:\n            self._intermediary_server.server_bind()\n            self._intermediary_server.server_activate()\n        except Exception as exc:\n            self._intermediary_server.server_close()\n\n            if isinstance(exc, UnicodeDecodeError) and sys.platform == \"win32\":\n                # we end up here if the hostname contains non-ASCII characters due to\n                # https://bugs.python.org/issue26227 - tell the user they need\n                # to either change their hostname or read up other options in\n                # https://github.com/OctoPrint/OctoPrint/issues/3963\n                raise CannotStartServerException(\n                    \"OctoPrint cannot start due to a Python bug \"\n                    \"(https://bugs.python.org/issue26227). Your \"\n                    \"computer's host name contains non-ASCII characters. \"\n                    \"Please either change your computer's host name to \"\n                    \"contain only ASCII characters, or take a look at \"\n                    \"https://github.com/OctoPrint/OctoPrint/issues/3963 for \"\n                    \"other options.\"\n                )\n            else:\n                raise\n\n        def serve():\n            try:\n                self._intermediary_server.serve_forever()\n            except Exception:\n                self._logger.exception(\"Error in intermediary server\")\n\n        thread = threading.Thread(target=serve)\n        thread.daemon = True\n        thread.start()\n\n        self._logger.info(\"Intermediary server started\")\n\n    def _stop_intermediary_server(self):\n        if self._intermediary_server is None:\n            return\n        self._logger.info(\"Shutting down intermediary server...\")\n        self._intermediary_server.shutdown()\n        self._intermediary_server.server_close()\n        self._logger.info(\"Intermediary server shut down\")\n\n    def _setup_plugin_permissions(self):\n        global pluginManager\n\n        from octoprint.access.permissions import PluginOctoPrintPermission\n\n        key_whitelist = re.compile(r\"[A-Za-z0-9_]*\")\n\n        def permission_key(plugin, definition):\n            return \"PLUGIN_{}_{}\".format(plugin.upper(), definition[\"key\"].upper())\n\n        def permission_name(plugin, definition):\n            return \"{}: {}\".format(plugin, definition[\"name\"])\n\n        def permission_role(plugin, role):\n            return f\"plugin_{plugin}_{role}\"\n\n        def process_regular_permission(plugin_info, definition):\n            permissions = []\n            for key in definition.get(\"permissions\", []):\n                permission = octoprint.access.permissions.Permissions.find(key)\n\n                if permission is None:\n                    # if there is still no permission found, postpone this - maybe it is a permission from\n                    # another plugin that hasn't been loaded yet\n                    return False\n\n                permissions.append(permission)\n\n            roles = definition.get(\"roles\", [])\n            description = definition.get(\"description\", \"\")\n            dangerous = definition.get(\"dangerous\", False)\n            default_groups = definition.get(\"default_groups\", [])\n\n            roles_and_permissions = [\n                permission_role(plugin_info.key, role) for role in roles\n            ] + permissions\n\n            key = permission_key(plugin_info.key, definition)\n            permission = PluginOctoPrintPermission(\n                permission_name(plugin_info.name, definition),\n                description,\n                plugin=plugin_info.key,\n                dangerous=dangerous,\n                default_groups=default_groups,\n                *roles_and_permissions,\n            )\n            setattr(\n                octoprint.access.permissions.Permissions,\n                key,\n                PluginOctoPrintPermission(\n                    permission_name(plugin_info.name, definition),\n                    description,\n                    plugin=plugin_info.key,\n                    dangerous=dangerous,\n                    default_groups=default_groups,\n                    *roles_and_permissions,\n                ),\n            )\n\n            self._logger.info(\n                \"Added new permission from plugin {}: {} (needs: {!r})\".format(\n                    plugin_info.key, key, \", \".join(map(repr, permission.needs))\n                )\n            )\n            return True\n\n        postponed = []\n\n        hooks = pluginManager.get_hooks(\"octoprint.access.permissions\")\n        for name, factory in hooks.items():\n            try:\n                if isinstance(factory, (tuple, list)):\n                    additional_permissions = list(factory)\n                elif callable(factory):\n                    additional_permissions = factory()\n                else:\n                    raise ValueError(\"factory must be either a callable, tuple or list\")\n\n                if not isinstance(additional_permissions, (tuple, list)):\n                    raise ValueError(\n                        \"factory result must be either a tuple or a list of permission definition dicts\"\n                    )\n\n                plugin_info = pluginManager.get_plugin_info(name)\n                for p in additional_permissions:\n                    if not isinstance(p, dict):\n                        continue\n\n                    if \"key\" not in p or \"name\" not in p:\n                        continue\n\n                    if not key_whitelist.match(p[\"key\"]):\n                        self._logger.warning(\n                            \"Got permission with invalid key from plugin {}: {}\".format(\n                                name, p[\"key\"]\n                            )\n                        )\n                        continue\n\n                    if not process_regular_permission(plugin_info, p):\n                        postponed.append((plugin_info, p))\n            except Exception:\n                self._logger.exception(\n                    f\"Error while creating permission instance/s from {name}\"\n                )\n\n        # final resolution passes\n        pass_number = 1\n        still_postponed = []\n        while len(postponed):\n            start_length = len(postponed)\n            self._logger.debug(\n                \"Plugin permission resolution pass #{}, \"\n                \"{} unresolved permissions...\".format(pass_number, start_length)\n            )\n\n            for plugin_info, definition in postponed:\n                if not process_regular_permission(plugin_info, definition):\n                    still_postponed.append((plugin_info, definition))\n\n            self._logger.debug(\n                \"... pass #{} done, {} permissions left to resolve\".format(\n                    pass_number, len(still_postponed)\n                )\n            )\n\n            if len(still_postponed) == start_length:\n                # no change, looks like some stuff is unresolvable - let's bail\n                for plugin_info, definition in still_postponed:\n                    self._logger.warning(\n                        \"Unable to resolve permission from {}: {!r}\".format(\n                            plugin_info.key, definition\n                        )\n                    )\n                break\n\n            postponed = still_postponed\n            still_postponed = []\n            pass_number += 1\n\n\nclass LifecycleManager:\n    def __init__(self, plugin_manager):\n        self._plugin_manager = plugin_manager\n\n        self._plugin_lifecycle_callbacks = defaultdict(list)\n        self._logger = logging.getLogger(__name__)\n\n        def wrap_plugin_event(lifecycle_event, new_handler):\n            orig_handler = getattr(self._plugin_manager, \"on_plugin_\" + lifecycle_event)\n\n            def handler(*args, **kwargs):\n                if callable(orig_handler):\n                    orig_handler(*args, **kwargs)\n                if callable(new_handler):\n                    new_handler(*args, **kwargs)\n\n            return handler\n\n        def on_plugin_event_factory(lifecycle_event):\n            def on_plugin_event(name, plugin):\n                self.on_plugin_event(lifecycle_event, name, plugin)\n\n            return on_plugin_event\n\n        for event in (\"loaded\", \"unloaded\", \"enabled\", \"disabled\"):\n            wrap_plugin_event(event, on_plugin_event_factory(event))\n\n    def on_plugin_event(self, event, name, plugin):\n        for lifecycle_callback in self._plugin_lifecycle_callbacks[event]:\n            lifecycle_callback(name, plugin)\n\n    def add_callback(self, events, callback):\n        if isinstance(events, str):\n            events = [events]\n\n        for event in events:\n            self._plugin_lifecycle_callbacks[event].append(callback)\n\n    def remove_callback(self, callback, events=None):\n        if events is None:\n            for event in self._plugin_lifecycle_callbacks:\n                if callback in self._plugin_lifecycle_callbacks[event]:\n                    self._plugin_lifecycle_callbacks[event].remove(callback)\n        else:\n            if isinstance(events, str):\n                events = [events]\n\n            for event in events:\n                if callback in self._plugin_lifecycle_callbacks[event]:\n                    self._plugin_lifecycle_callbacks[event].remove(callback)\n\n\nclass CannotStartServerException(Exception):\n    pass\n", "__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"\n__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"\n__copyright__ = \"Copyright (C) 2014 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n\nimport logging\n\nfrom flask import (\n    Blueprint,\n    Response,\n    abort,\n    current_app,\n    g,\n    jsonify,\n    make_response,\n    request,\n    session,\n)\nfrom flask_login import current_user, login_user, logout_user\nfrom werkzeug.exceptions import HTTPException\n\nimport octoprint.access.users\nimport octoprint.plugin\nimport octoprint.server\nimport octoprint.util.net as util_net\nfrom octoprint.access.permissions import Permissions\nfrom octoprint.events import Events, eventManager\nfrom octoprint.server import NO_CONTENT\nfrom octoprint.server.util import (\n    corsRequestHandler,\n    corsResponseHandler,\n    loginFromApiKeyRequestHandler,\n    loginFromAuthorizationHeaderRequestHandler,\n    noCachingExceptGetResponseHandler,\n)\nfrom octoprint.server.util.flask import (\n    get_json_command_from_request,\n    get_remote_address,\n    limit,\n    no_firstrun_access,\n    passive_login,\n    session_signature,\n)\nfrom octoprint.settings import settings as s\nfrom octoprint.settings import valid_boolean_trues\nfrom octoprint.vendor.flask_principal import Identity, identity_changed\n\n# ~~ init api blueprint, including sub modules\n\napi = Blueprint(\"api\", __name__)\n\nfrom . import access as api_access  # noqa: F401,E402\nfrom . import connection as api_connection  # noqa: F401,E402\nfrom . import files as api_files  # noqa: F401,E402\nfrom . import job as api_job  # noqa: F401,E402\nfrom . import languages as api_languages  # noqa: F401,E402\nfrom . import printer as api_printer  # noqa: F401,E402\nfrom . import printer_profiles as api_printer_profiles  # noqa: F401,E402\nfrom . import settings as api_settings  # noqa: F401,E402\nfrom . import slicing as api_slicing  # noqa: F401,E402\nfrom . import system as api_system  # noqa: F401,E402\nfrom . import timelapse as api_timelapse  # noqa: F401,E402\nfrom . import users as api_users  # noqa: F401,E402\n\nVERSION = \"0.1\"\n\napi.after_request(noCachingExceptGetResponseHandler)\n\napi.before_request(corsRequestHandler)\napi.before_request(loginFromAuthorizationHeaderRequestHandler)\napi.before_request(loginFromApiKeyRequestHandler)\napi.after_request(corsResponseHandler)\n\n# ~~ data from plugins\n\n\n@api.route(\"/plugin/<string:name>\", methods=[\"GET\"])\ndef pluginData(name):\n    api_plugins = octoprint.plugin.plugin_manager().get_filtered_implementations(\n        lambda p: p._identifier == name, octoprint.plugin.SimpleApiPlugin\n    )\n    if not api_plugins:\n        abort(404)\n\n    if len(api_plugins) > 1:\n        abort(500, description=\"More than one api provider registered, can't proceed\")\n\n    try:\n        api_plugin = api_plugins[0]\n        if api_plugin.is_api_adminonly() and not current_user.is_admin:\n            abort(403)\n\n        response = api_plugin.on_api_get(request)\n\n        if response is not None:\n            message = (\n                \"Rewriting response from {} to use abort(msg, code) - please \"\n                \"consider upgrading the implementation accordingly\".format(name)\n            )\n            if (\n                isinstance(response, Response)\n                and response.mimetype == \"text/html\"\n                and response.status_code >= 300\n            ):\n                # this actually looks like an error response\n                logging.getLogger(__name__).info(message)\n                abort(response.status_code, description=response.data)\n            elif (\n                isinstance(response, tuple)\n                and len(response) == 2\n                and isinstance(response[0], (str, bytes))\n                and response[1] >= 300\n            ):\n                # this actually looks like an error response\n                logging.getLogger(__name__).info(message)\n                abort(response[1], response[0])\n            return response\n        return NO_CONTENT\n    except HTTPException:\n        raise\n    except Exception:\n        logging.getLogger(__name__).exception(\n            f\"Error calling SimpleApiPlugin {name}\", extra={\"plugin\": name}\n        )\n        return abort(500)\n\n\n# ~~ commands for plugins\n\n\n@api.route(\"/plugin/<string:name>\", methods=[\"POST\"])\n@no_firstrun_access\ndef pluginCommand(name):\n    api_plugins = octoprint.plugin.plugin_manager().get_filtered_implementations(\n        lambda p: p._identifier == name, octoprint.plugin.SimpleApiPlugin\n    )\n\n    if not api_plugins:\n        abort(400)\n\n    if len(api_plugins) > 1:\n        abort(500, description=\"More than one api provider registered, can't proceed\")\n\n    api_plugin = api_plugins[0]\n    try:\n        valid_commands = api_plugin.get_api_commands()\n        if valid_commands is None:\n            abort(405)\n\n        if api_plugin.is_api_adminonly() and not Permissions.ADMIN.can():\n            abort(403)\n\n        command, data, response = get_json_command_from_request(request, valid_commands)\n        if response is not None:\n            return response\n\n        response = api_plugin.on_api_command(command, data)\n        if response is not None:\n            return response\n        return NO_CONTENT\n    except HTTPException:\n        raise\n    except Exception:\n        logging.getLogger(__name__).exception(\n            f\"Error while executing SimpleApiPlugin {name}\",\n            extra={\"plugin\": name},\n        )\n        return abort(500)\n\n\n# ~~ first run setup\n\n\n@api.route(\"/setup/wizard\", methods=[\"GET\"])\ndef wizardState():\n    if (\n        not s().getBoolean([\"server\", \"firstRun\"])\n        and octoprint.server.userManager.has_been_customized()\n        and not Permissions.ADMIN.can()\n    ):\n        abort(403)\n\n    seen_wizards = s().get([\"server\", \"seenWizards\"])\n\n    result = {}\n    wizard_plugins = octoprint.server.pluginManager.get_implementations(\n        octoprint.plugin.WizardPlugin\n    )\n    for implementation in wizard_plugins:\n        name = implementation._identifier\n        try:\n            required = implementation.is_wizard_required()\n            details = implementation.get_wizard_details()\n            version = implementation.get_wizard_version()\n            ignored = octoprint.plugin.WizardPlugin.is_wizard_ignored(\n                seen_wizards, implementation\n            )\n        except Exception:\n            logging.getLogger(__name__).exception(\n                \"There was an error fetching wizard \"\n                \"details for {}, ignoring\".format(name),\n                extra={\"plugin\": name},\n            )\n        else:\n            result[name] = {\n                \"required\": required,\n                \"details\": details,\n                \"version\": version,\n                \"ignored\": ignored,\n            }\n\n    return jsonify(result)\n\n\n@api.route(\"/setup/wizard\", methods=[\"POST\"])\ndef wizardFinish():\n    if (\n        not s().getBoolean([\"server\", \"firstRun\"])\n        and octoprint.server.userManager.has_been_customized()\n        and not Permissions.ADMIN.can()\n    ):\n        abort(403)\n\n    data = {}\n    try:\n        data = request.get_json()\n    except Exception:\n        abort(400)\n\n    if data is None:\n        abort(400)\n\n    if \"handled\" not in data:\n        abort(400)\n    handled = data[\"handled\"]\n\n    if s().getBoolean([\"server\", \"firstRun\"]):\n        s().setBoolean([\"server\", \"firstRun\"], False)\n\n    seen_wizards = dict(s().get([\"server\", \"seenWizards\"]))\n\n    wizard_plugins = octoprint.server.pluginManager.get_implementations(\n        octoprint.plugin.WizardPlugin\n    )\n    for implementation in wizard_plugins:\n        name = implementation._identifier\n        try:\n            implementation.on_wizard_finish(name in handled)\n            if name in handled:\n                seen_wizards[name] = implementation.get_wizard_version()\n        except Exception:\n            logging.getLogger(__name__).exception(\n                \"There was an error finishing the \"\n                \"wizard for {}, ignoring\".format(name),\n                extra={\"plugin\": name},\n            )\n\n    s().set([\"server\", \"seenWizards\"], seen_wizards)\n    s().save()\n\n    return NO_CONTENT\n\n\n# ~~ system state\n\n\n@api.route(\"/version\", methods=[\"GET\"])\n@Permissions.STATUS.require(403)\ndef apiVersion():\n    return jsonify(\n        server=octoprint.server.VERSION,\n        api=VERSION,\n        text=f\"OctoPrint {octoprint.server.DISPLAY_VERSION}\",\n    )\n\n\n@api.route(\"/server\", methods=[\"GET\"])\n@Permissions.STATUS.require(403)\ndef serverStatus():\n    return jsonify(version=octoprint.server.VERSION, safemode=octoprint.server.safe_mode)\n\n\n# ~~ Login/user handling\n\n\n@api.route(\"/login\", methods=[\"POST\"])\n@limit(\n    \"3/minute;5/10 minutes;10/hour\",\n    deduct_when=lambda response: response.status_code == 403,\n    error_message=\"You have made too many failed login attempts. Please try again later.\",\n)\ndef login():\n    data = request.get_json()\n    if not data:\n        data = request.values\n\n    if \"user\" in data and \"pass\" in data:\n        username = data[\"user\"]\n        password = data[\"pass\"]\n\n        if \"remember\" in data and data[\"remember\"] in valid_boolean_trues:\n            remember = True\n        else:\n            remember = False\n\n        if \"usersession.id\" in session:\n            _logout(current_user)\n\n        user = octoprint.server.userManager.find_user(username)\n        if user is not None:\n            if octoprint.server.userManager.check_password(username, password):\n                if not user.is_active:\n                    abort(403)\n\n                user = octoprint.server.userManager.login_user(user)\n                session[\"usersession.id\"] = user.session\n                session[\"usersession.signature\"] = session_signature(\n                    username, user.session\n                )\n                g.user = user\n\n                login_user(user, remember=remember)\n                identity_changed.send(\n                    current_app._get_current_object(), identity=Identity(user.get_id())\n                )\n                session[\"login_mechanism\"] = \"http\"\n\n                remote_addr = get_remote_address(request)\n                logging.getLogger(__name__).info(\n                    \"Actively logging in user {} from {}\".format(\n                        user.get_id(), remote_addr\n                    )\n                )\n\n                response = user.as_dict()\n                response[\"_is_external_client\"] = s().getBoolean(\n                    [\"server\", \"ipCheck\", \"enabled\"]\n                ) and not util_net.is_lan_address(\n                    remote_addr,\n                    additional_private=s().get([\"server\", \"ipCheck\", \"trustedSubnets\"]),\n                )\n                response[\"_login_mechanism\"] = session[\"login_mechanism\"]\n\n                r = make_response(jsonify(response))\n                r.delete_cookie(\"active_logout\")\n\n                eventManager().fire(\n                    Events.USER_LOGGED_IN, payload={\"username\": user.get_id()}\n                )\n\n                return r\n\n        abort(403)\n\n    elif \"passive\" in data:\n        return passive_login()\n\n    abort(400, description=\"Neither user and pass attributes nor passive flag present\")\n\n\n@api.route(\"/logout\", methods=[\"POST\"])\ndef logout():\n    username = None\n    if current_user:\n        username = current_user.get_id()\n\n    # logout from user manager...\n    _logout(current_user)\n\n    # ... and from flask login (and principal)\n    logout_user()\n\n    # ... and send an active logout session cookie\n    r = make_response(jsonify(octoprint.server.userManager.anonymous_user_factory()))\n    r.set_cookie(\"active_logout\", \"true\")\n\n    if username:\n        eventManager().fire(Events.USER_LOGGED_OUT, payload={\"username\": username})\n\n    return r\n\n\ndef _logout(user):\n    if \"usersession.id\" in session:\n        del session[\"usersession.id\"]\n    if \"login_mechanism\" in session:\n        del session[\"login_mechanism\"]\n    octoprint.server.userManager.logout_user(user)\n\n\n@api.route(\"/currentuser\", methods=[\"GET\"])\ndef get_current_user():\n    return jsonify(\n        name=current_user.get_name(),\n        permissions=[permission.key for permission in current_user.effective_permissions],\n        groups=[group.key for group in current_user.groups],\n    )\n\n\n# ~~ Test utils\n\n\n@api.route(\"/util/test\", methods=[\"POST\"])\n@no_firstrun_access\n@Permissions.ADMIN.require(403)\ndef utilTest():\n    valid_commands = {\n        \"path\": [\"path\"],\n        \"url\": [\"url\"],\n        \"server\": [\"host\", \"port\"],\n        \"resolution\": [\"name\"],\n        \"address\": [],\n    }\n\n    command, data, response = get_json_command_from_request(request, valid_commands)\n    if response is not None:\n        return response\n\n    if command == \"path\":\n        return _test_path(data)\n    elif command == \"url\":\n        return _test_url(data)\n    elif command == \"server\":\n        return _test_server(data)\n    elif command == \"resolution\":\n        return _test_resolution(data)\n    elif command == \"address\":\n        return _test_address(data)\n\n\ndef _test_path(data):\n    import os\n\n    from octoprint.util.paths import normalize\n\n    path = normalize(data[\"path\"], real=False)\n    if not path:\n        return jsonify(\n            path=path,\n            exists=False,\n            typeok=False,\n            broken_symlink=False,\n            access=False,\n            result=False,\n        )\n\n    unreal_path = path\n    path = os.path.realpath(path)\n\n    check_type = None\n    check_access = []\n\n    if \"check_type\" in data and data[\"check_type\"] in (\"file\", \"dir\"):\n        check_type = data[\"check_type\"]\n\n    if \"check_access\" in data:\n        request_check_access = data[\"check_access\"]\n        if not isinstance(request_check_access, list):\n            request_check_access = list(request_check_access)\n\n        check_access = [\n            check for check in request_check_access if check in (\"r\", \"w\", \"x\")\n        ]\n\n    allow_create_dir = data.get(\"allow_create_dir\", False) and check_type == \"dir\"\n    check_writable_dir = data.get(\"check_writable_dir\", False) and check_type == \"dir\"\n    if check_writable_dir and \"w\" not in check_access:\n        check_access.append(\"w\")\n\n    # check if path exists\n    exists = os.path.exists(path)\n    if not exists:\n        if os.path.islink(unreal_path):\n            # broken symlink, see #2644\n            logging.getLogger(__name__).error(\n                \"{} is a broken symlink pointing at non existing {}\".format(\n                    unreal_path, path\n                )\n            )\n            return jsonify(\n                path=unreal_path,\n                exists=False,\n                typeok=False,\n                broken_symlink=True,\n                access=False,\n                result=False,\n            )\n\n        elif check_type == \"dir\" and allow_create_dir:\n            try:\n                os.makedirs(path)\n            except Exception:\n                logging.getLogger(__name__).exception(\n                    f\"Error while trying to create {path}\"\n                )\n                return jsonify(\n                    path=path,\n                    exists=False,\n                    typeok=False,\n                    broken_symlink=False,\n                    access=False,\n                    result=False,\n                )\n            else:\n                exists = True\n\n    # check path type\n    type_mapping = {\"file\": os.path.isfile, \"dir\": os.path.isdir}\n    if check_type:\n        typeok = type_mapping[check_type](path)\n    else:\n        typeok = exists\n\n    # check if path allows requested access\n    access_mapping = {\"r\": os.R_OK, \"w\": os.W_OK, \"x\": os.X_OK}\n    if check_access:\n        mode = 0\n        for a in map(lambda x: access_mapping[x], check_access):\n            mode |= a\n        access = os.access(path, mode)\n    else:\n        access = exists\n\n    if check_writable_dir and check_type == \"dir\":\n        try:\n            test_path = os.path.join(path, \".testballoon.txt\")\n            with open(test_path, \"wb\") as f:\n                f.write(b\"Test\")\n            os.remove(test_path)\n        except Exception:\n            logging.getLogger(__name__).exception(\n                f\"Error while testing if {path} is really writable\"\n            )\n            return jsonify(\n                path=path,\n                exists=exists,\n                typeok=typeok,\n                broken_symlink=False,\n                access=False,\n                result=False,\n            )\n\n    return jsonify(\n        path=path,\n        exists=exists,\n        typeok=typeok,\n        broken_symlink=False,\n        access=access,\n        result=exists and typeok and access,\n    )\n\n\ndef _test_url(data):\n    import requests\n\n    from octoprint import util as util\n\n    class StatusCodeRange:\n        def __init__(self, start=None, end=None):\n            self.start = start\n            self.end = end\n\n        def __contains__(self, item):\n            if not isinstance(item, int):\n                return False\n            if self.start and self.end:\n                return self.start <= item < self.end\n            elif self.start:\n                return self.start <= item\n            elif self.end:\n                return item < self.end\n            else:\n                return False\n\n        def as_dict(self):\n            return {\"start\": self.start, \"end\": self.end}\n\n    status_ranges = {\n        \"informational\": StatusCodeRange(start=100, end=200),\n        \"success\": StatusCodeRange(start=200, end=300),\n        \"redirection\": StatusCodeRange(start=300, end=400),\n        \"client_error\": StatusCodeRange(start=400, end=500),\n        \"server_error\": StatusCodeRange(start=500, end=600),\n        \"normal\": StatusCodeRange(end=400),\n        \"error\": StatusCodeRange(start=400, end=600),\n        \"any\": StatusCodeRange(start=100),\n        \"timeout\": StatusCodeRange(start=0, end=1),\n    }\n\n    url = data[\"url\"]\n    method = data.get(\"method\", \"HEAD\")\n    timeout = 3.0\n    valid_ssl = True\n    check_status = [status_ranges[\"normal\"]]\n    content_type_whitelist = None\n    content_type_blacklist = None\n\n    if \"timeout\" in data:\n        try:\n            timeout = float(data[\"timeout\"])\n        except Exception:\n            abort(400, description=\"timeout is invalid\")\n\n    if \"validSsl\" in data:\n        valid_ssl = data[\"validSsl\"] in valid_boolean_trues\n\n    if \"status\" in data:\n        request_status = data[\"status\"]\n        if not isinstance(request_status, list):\n            request_status = [request_status]\n\n        check_status = []\n        for rs in request_status:\n            if isinstance(rs, int):\n                check_status.append([rs])\n            else:\n                if rs in status_ranges:\n                    check_status.append(status_ranges[rs])\n                else:\n                    code = requests.codes[rs]\n                    if code is not None:\n                        check_status.append([code])\n\n    if \"content_type_whitelist\" in data:\n        if not isinstance(data[\"content_type_whitelist\"], (list, tuple)):\n            abort(400, description=\"content_type_whitelist must be a list of mime types\")\n        content_type_whitelist = list(\n            map(util.parse_mime_type, data[\"content_type_whitelist\"])\n        )\n    if \"content_type_blacklist\" in data:\n        if not isinstance(data[\"content_type_whitelist\"], (list, tuple)):\n            abort(400, description=\"content_type_blacklist must be a list of mime types\")\n        content_type_blacklist = list(\n            map(util.parse_mime_type, data[\"content_type_blacklist\"])\n        )\n\n    response_result = None\n    outcome = True\n    status = 0\n    try:\n        with requests.request(\n            method=method, url=url, timeout=timeout, verify=valid_ssl, stream=True\n        ) as response:\n            status = response.status_code\n            outcome = outcome and any(map(lambda x: status in x, check_status))\n            content_type = response.headers.get(\"content-type\")\n\n            response_result = {\n                \"headers\": dict(response.headers),\n                \"content_type\": content_type,\n            }\n\n            if not content_type and data.get(\"content_type_guess\") in valid_boolean_trues:\n                content = response.content\n                content_type = util.guess_mime_type(bytearray(content))\n\n            if not content_type:\n                content_type = \"application/octet-stream\"\n\n            response_result = {\"assumed_content_type\": content_type}\n\n            parsed_content_type = util.parse_mime_type(content_type)\n\n            in_whitelist = content_type_whitelist is None or any(\n                map(\n                    lambda x: util.mime_type_matches(parsed_content_type, x),\n                    content_type_whitelist,\n                )\n            )\n            in_blacklist = content_type_blacklist is not None and any(\n                map(\n                    lambda x: util.mime_type_matches(parsed_content_type, x),\n                    content_type_blacklist,\n                )\n            )\n\n            if not in_whitelist or in_blacklist:\n                # we don't support this content type\n                response.close()\n                outcome = False\n\n            elif \"response\" in data and (\n                data[\"response\"] in valid_boolean_trues\n                or data[\"response\"] in (\"json\", \"bytes\")\n            ):\n                if data[\"response\"] == \"json\":\n                    content = response.json()\n\n                else:\n                    import base64\n\n                    content = base64.standard_b64encode(response.content)\n\n                response_result[\"content\"] = content\n    except Exception:\n        logging.getLogger(__name__).exception(\n            f\"Error while running a test {method} request on {url}\"\n        )\n        outcome = False\n\n    result = {\"url\": url, \"status\": status, \"result\": outcome}\n    if response_result:\n        result[\"response\"] = response_result\n\n    return jsonify(**result)\n\n\ndef _test_server(data):\n    host = data[\"host\"]\n    try:\n        port = int(data[\"port\"])\n    except Exception:\n        abort(400, description=\"Invalid value for port\")\n\n    timeout = 3.05\n    if \"timeout\" in data:\n        try:\n            timeout = float(data[\"timeout\"])\n        except Exception:\n            abort(400, description=\"Invalid value for timeout\")\n\n    protocol = data.get(\"protocol\", \"tcp\")\n    if protocol not in (\"tcp\", \"udp\"):\n        abort(400, description=\"Invalid value for protocol\")\n\n    from octoprint.util import server_reachable\n\n    reachable = server_reachable(host, port, timeout=timeout, proto=protocol)\n\n    result = {\"host\": host, \"port\": port, \"protocol\": protocol, \"result\": reachable}\n\n    return jsonify(**result)\n\n\ndef _test_resolution(data):\n    name = data[\"name\"]\n\n    from octoprint.util.net import resolve_host\n\n    resolvable = len(resolve_host(name)) > 0\n\n    result = {\"name\": name, \"result\": resolvable}\n\n    return jsonify(**result)\n\n\ndef _test_address(data):\n    import netaddr\n\n    from octoprint.util.net import get_lan_ranges, sanitize_address\n\n    remote_addr = data.get(\"address\")\n    if not remote_addr:\n        remote_addr = get_remote_address(request)\n\n    remote_addr = sanitize_address(remote_addr)\n    ip = netaddr.IPAddress(remote_addr)\n\n    lan_subnets = get_lan_ranges()\n\n    detected_subnet = None\n    for subnet in lan_subnets:\n        if ip in subnet:\n            detected_subnet = subnet\n            break\n\n    result = {\n        \"is_lan_address\": detected_subnet is not None,\n        \"address\": remote_addr,\n    }\n\n    if detected_subnet is not None:\n        result[\"subnet\"] = str(detected_subnet)\n\n    return jsonify(**result)\n", "from flask import make_response\n\n__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"\n__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"\n__copyright__ = \"Copyright (C) 2014 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n\nimport functools\nimport hashlib\nimport hmac\nimport logging\nimport os\nimport threading\nimport time\nfrom datetime import datetime, timedelta\nfrom typing import Union\n\nimport flask\nimport flask.json\nimport flask.sessions\nimport flask.templating\nimport flask_assets\nimport flask_login\nimport netaddr\nimport tornado.web\nimport webassets.updater\nimport webassets.utils\nfrom cachelib import BaseCache\nfrom flask import current_app\nfrom flask_login import COOKIE_NAME as REMEMBER_COOKIE_NAME\nfrom flask_login.utils import decode_cookie, encode_cookie\nfrom werkzeug.local import LocalProxy\nfrom werkzeug.utils import cached_property\n\nimport octoprint.access.users\nimport octoprint.plugin\nimport octoprint.server\nimport octoprint.vendor.flask_principal as flask_principal\nfrom octoprint.events import Events, eventManager\nfrom octoprint.settings import settings\nfrom octoprint.util import DefaultOrderedDict, deprecated, yaml\nfrom octoprint.util.json import JsonEncoding\nfrom octoprint.util.net import is_lan_address\nfrom octoprint.util.tz import UTC_TZ, is_timezone_aware\n\n# ~~ monkey patching\n\n\ndef enable_additional_translations(default_locale=\"en\", additional_folders=None):\n    import os\n\n    import flask_babel\n    from babel import Locale, support\n    from flask import _request_ctx_stack\n\n    if additional_folders is None:\n        additional_folders = []\n\n    logger = logging.getLogger(__name__)\n\n    def fixed_list_translations(self):\n        \"\"\"Returns a list of all the locales translations exist for.  The\n        list returned will be filled with actual locale objects and not just\n        strings.\n        \"\"\"\n\n        def list_translations(dirname):\n            if not os.path.isdir(dirname):\n                return []\n            result = []\n            for entry in os.scandir(dirname):\n                locale_dir = os.path.join(entry.path, \"LC_MESSAGES\")\n                if not os.path.isdir(locale_dir):\n                    continue\n                if any(filter(lambda x: x.name.endswith(\".mo\"), os.scandir(locale_dir))):\n                    result.append(Locale.parse(entry.name))\n            return result\n\n        dirs = additional_folders + [os.path.join(self.app.root_path, \"translations\")]\n\n        # translations from plugins\n        plugins = octoprint.plugin.plugin_manager().enabled_plugins\n        for plugin in plugins.values():\n            plugin_translation_dir = os.path.join(plugin.location, \"translations\")\n            if not os.path.isdir(plugin_translation_dir):\n                continue\n            dirs.append(plugin_translation_dir)\n\n        result = [Locale.parse(default_locale)]\n\n        for dir in dirs:\n            result += list_translations(dir)\n        return result\n\n    def fixed_get_translations():\n        \"\"\"Returns the correct gettext translations that should be used for\n        this request.  This will never fail and return a dummy translation\n        object if used outside of the request or if a translation cannot be\n        found.\n        \"\"\"\n        ctx = _request_ctx_stack.top\n        if ctx is None:\n            return None\n        translations = getattr(ctx, \"babel_translations\", None)\n        if translations is None:\n            locale = flask_babel.get_locale()\n            translations = support.Translations()\n\n            if str(locale) != default_locale:\n                # plugin translations\n                plugins = octoprint.plugin.plugin_manager().enabled_plugins\n                for name, plugin in plugins.items():\n                    dirs = list(\n                        map(\n                            lambda x: os.path.join(x, \"_plugins\", name),\n                            additional_folders,\n                        )\n                    ) + [os.path.join(plugin.location, \"translations\")]\n                    for dirname in dirs:\n                        if not os.path.isdir(dirname):\n                            continue\n\n                        try:\n                            plugin_translations = support.Translations.load(\n                                dirname, [locale]\n                            )\n                        except Exception:\n                            logger.exception(\n                                f\"Error while trying to load translations \"\n                                f\"for plugin {name}\"\n                            )\n                        else:\n                            if isinstance(plugin_translations, support.Translations):\n                                translations = translations.merge(plugin_translations)\n                                logger.debug(\n                                    f\"Using translation plugin folder {dirname} from \"\n                                    f\"plugin {name} for locale {locale}\"\n                                )\n                                break\n                    else:\n                        logger.debug(\n                            f\"No translations for locale {locale} \" f\"from plugin {name}\"\n                        )\n\n                # core translations\n                dirs = additional_folders + [\n                    os.path.join(ctx.app.root_path, \"translations\")\n                ]\n                for dirname in dirs:\n                    core_translations = support.Translations.load(dirname, [locale])\n                    if isinstance(core_translations, support.Translations):\n                        logger.debug(\n                            f\"Using translation core folder {dirname} \"\n                            f\"for locale {locale}\"\n                        )\n                        break\n                else:\n                    logger.debug(f\"No translations for locale {locale} in core folders\")\n                translations = translations.merge(core_translations)\n\n            ctx.babel_translations = translations\n        return translations\n\n    flask_babel.Babel.list_translations = fixed_list_translations\n    flask_babel.get_translations = fixed_get_translations\n\n\ndef fix_webassets_filtertool():\n    from webassets.merge import FilterTool, MemoryHunk, log\n\n    error_logger = logging.getLogger(__name__ + \".fix_webassets_filtertool\")\n\n    def fixed_wrap_cache(self, key, func):\n        \"\"\"Return cache value ``key``, or run ``func``.\"\"\"\n        if self.cache:\n            if not self.no_cache_read:\n                log.debug(\"Checking cache for key %s\", key)\n                content = self.cache.get(key)\n                if content not in (False, None):\n                    log.debug(\"Using cached result for %s\", key)\n                    return MemoryHunk(content)\n\n        try:\n            content = func().getvalue()\n            if self.cache:\n                try:\n                    log.debug(\n                        \"Storing result in cache with key %s\",\n                        key,\n                    )\n                    self.cache.set(key, content)\n                except Exception:\n                    error_logger.exception(\n                        \"Got an exception while trying to save file to cache, not caching\"\n                    )\n            return MemoryHunk(content)\n        except Exception:\n            error_logger.exception(\n                \"Got an exception while trying to apply filter, ignoring file\"\n            )\n            return MemoryHunk(\"\")\n\n    FilterTool._wrap_cache = fixed_wrap_cache\n\n\ndef fix_flask_jsonify():\n    def fixed_jsonify(*args, **kwargs):\n        \"\"\"Backported from https://github.com/pallets/flask/blob/7e714bd28b6e96d82b2848b48cf8ff48b517b09b/flask/json/__init__.py#L257\"\"\"\n        from flask.json import current_app, dumps\n\n        indent = None\n        separators = (\",\", \":\")\n\n        if current_app.config[\"JSONIFY_PRETTYPRINT_REGULAR\"] or current_app.debug:\n            indent = 2\n            separators = (\", \", \": \")\n\n        if args and kwargs:\n            raise TypeError(\n                \"jsonify() behavior undefined when passed both args and kwargs\"\n            )\n        elif len(args) == 1:  # single args are passed directly to dumps()\n            data = args[0]\n        else:\n            data = args or kwargs\n\n        return current_app.response_class(\n            dumps(data, indent=indent, separators=separators, allow_nan=False) + \"\\n\",\n            mimetype=\"application/json\",\n        )\n\n    flask.jsonify = fixed_jsonify\n\n\n# ~~ WSGI environment wrapper for reverse proxying\n\n\nclass ReverseProxiedEnvironment:\n    @staticmethod\n    def to_header_candidates(values):\n        if values is None:\n            return []\n        if not isinstance(values, (list, tuple)):\n            values = [values]\n        to_wsgi_format = lambda header: \"HTTP_\" + header.upper().replace(\"-\", \"_\")\n        return list(map(to_wsgi_format, values))\n\n    @staticmethod\n    def valid_ip(address):\n        import netaddr\n\n        try:\n            netaddr.IPAddress(address)\n            return True\n        except Exception:\n            return False\n\n    def __init__(\n        self,\n        header_prefix=None,\n        header_scheme=None,\n        header_host=None,\n        header_server=None,\n        header_port=None,\n        prefix=None,\n        scheme=None,\n        host=None,\n        server=None,\n        port=None,\n    ):\n\n        # sensible defaults\n        if header_prefix is None:\n            header_prefix = [\"x-script-name\"]\n        if header_scheme is None:\n            header_scheme = [\"x-forwarded-proto\", \"x-scheme\"]\n        if header_host is None:\n            header_host = [\"x-forwarded-host\"]\n        if header_server is None:\n            header_server = [\"x-forwarded-server\"]\n        if header_port is None:\n            header_port = [\"x-forwarded-port\"]\n\n        # header candidates\n        self._headers_prefix = self.to_header_candidates(header_prefix)\n        self._headers_scheme = self.to_header_candidates(header_scheme)\n        self._headers_host = self.to_header_candidates(header_host)\n        self._headers_server = self.to_header_candidates(header_server)\n        self._headers_port = self.to_header_candidates(header_port)\n\n        # fallback prefix & scheme & host from config\n        self._fallback_prefix = prefix\n        self._fallback_scheme = scheme\n        self._fallback_host = host\n        self._fallback_server = server\n        self._fallback_port = port\n\n    def __call__(self, environ):\n        def retrieve_header(header_type):\n            candidates = getattr(self, \"_headers_\" + header_type, [])\n            fallback = getattr(self, \"_fallback_\" + header_type, None)\n\n            for candidate in candidates:\n                value = environ.get(candidate, None)\n                if value is not None:\n                    return value\n            else:\n                return fallback\n\n        def host_to_server_and_port(host, scheme):\n            if host is None:\n                return None, None\n\n            default_port = \"443\" if scheme == \"https\" else \"80\"\n            host = host.strip()\n\n            if \":\" in host:\n                # we might have an ipv6 address here, or a port, or both\n\n                if host[0] == \"[\":\n                    # that looks like an ipv6 address with port, e.g. [fec1::1]:80\n                    address_end = host.find(\"]\")\n                    if address_end == -1:\n                        # no ], that looks like a seriously broken address\n                        return None, None\n\n                    # extract server ip, skip enclosing [ and ]\n                    server = host[1:address_end]\n                    tail = host[address_end + 1 :]\n\n                    # now check if there's also a port\n                    if len(tail) and tail[0] == \":\":\n                        # port included as well\n                        port = tail[1:]\n                    else:\n                        # no port, use default one\n                        port = default_port\n\n                elif self.__class__.valid_ip(host):\n                    # ipv6 address without port\n                    server = host\n                    port = default_port\n\n                else:\n                    # ipv4 address with port\n                    server, port = host.rsplit(\":\", 1)\n\n            else:\n                server = host\n                port = default_port\n\n            return server, port\n\n        # determine prefix\n        prefix = retrieve_header(\"prefix\")\n        if prefix is not None:\n            environ[\"SCRIPT_NAME\"] = prefix\n            path_info = environ[\"PATH_INFO\"]\n            if path_info.startswith(prefix):\n                environ[\"PATH_INFO\"] = path_info[len(prefix) :]\n\n        # determine scheme\n        scheme = retrieve_header(\"scheme\")\n        if scheme is not None and \",\" in scheme:\n            # Scheme might be something like \"https,https\" if doubly-reverse-proxied\n            # without stripping original scheme header first, make sure to only use\n            # the first entry in such a case. See #1391.\n            scheme, _ = map(lambda x: x.strip(), scheme.split(\",\", 1))\n        if scheme is not None:\n            environ[\"wsgi.url_scheme\"] = scheme\n\n        # determine host\n        url_scheme = environ[\"wsgi.url_scheme\"]\n        host = retrieve_header(\"host\")\n        if host is not None:\n            # if we have a host, we take server_name and server_port from it\n            server, port = host_to_server_and_port(host, url_scheme)\n            environ[\"HTTP_HOST\"] = host\n            environ[\"SERVER_NAME\"] = server\n            environ[\"SERVER_PORT\"] = port\n\n        elif environ.get(\"HTTP_HOST\", None) is not None:\n            # if we have a Host header, we use that and make sure our server name and port properties match it\n            host = environ[\"HTTP_HOST\"]\n            server, port = host_to_server_and_port(host, url_scheme)\n            environ[\"SERVER_NAME\"] = server\n            environ[\"SERVER_PORT\"] = port\n\n        else:\n            # else we take a look at the server and port headers and if we have\n            # something there we derive the host from it\n\n            # determine server - should usually not be used\n            server = retrieve_header(\"server\")\n            if server is not None:\n                environ[\"SERVER_NAME\"] = server\n\n            # determine port - should usually not be used\n            port = retrieve_header(\"port\")\n            if port is not None:\n                environ[\"SERVER_PORT\"] = port\n\n            # reconstruct host header\n            if (\n                url_scheme == \"http\"\n                and environ[\"SERVER_PORT\"] == \"80\"\n                or url_scheme == \"https\"\n                and environ[\"SERVER_PORT\"] == \"443\"\n            ):\n                # default port for scheme, can be skipped\n                environ[\"HTTP_HOST\"] = environ[\"SERVER_NAME\"]\n            else:\n                server_name_component = environ[\"SERVER_NAME\"]\n                if \":\" in server_name_component and self.__class__.valid_ip(\n                    server_name_component\n                ):\n                    # this is an ipv6 address, we need to wrap that in [ and ] before appending the port\n                    server_name_component = \"[\" + server_name_component + \"]\"\n\n                environ[\"HTTP_HOST\"] = (\n                    server_name_component + \":\" + environ[\"SERVER_PORT\"]\n                )\n\n        # call wrapped app with rewritten environment\n        return environ\n\n\n# ~~ request and response versions\n\n\ndef encode_remember_me_cookie(value):\n    from octoprint.server import userManager\n\n    name = value.split(\"|\")[0]\n    try:\n        remember_key = userManager.signature_key_for_user(\n            name, salt=current_app.config[\"SECRET_KEY\"]\n        )\n        timestamp = datetime.utcnow().timestamp()\n        return encode_cookie(f\"{name}|{timestamp}\", key=remember_key)\n    except Exception:\n        pass\n\n    return \"\"\n\n\ndef decode_remember_me_cookie(value):\n    from octoprint.server import userManager\n\n    parts = value.split(\"|\")\n    if len(parts) == 3:\n        name, created, _ = parts\n\n        try:\n            # valid signature?\n            signature_key = userManager.signature_key_for_user(\n                name, salt=current_app.config[\"SECRET_KEY\"]\n            )\n            cookie = decode_cookie(value, key=signature_key)\n            if cookie:\n                # still valid?\n                if (\n                    datetime.fromtimestamp(float(created))\n                    + timedelta(seconds=current_app.config[\"REMEMBER_COOKIE_DURATION\"])\n                    > datetime.utcnow()\n                ):\n                    return encode_cookie(name)\n        except Exception:\n            pass\n\n    raise ValueError(\"Invalid remember me cookie\")\n\n\nclass OctoPrintFlaskRequest(flask.Request):\n    environment_wrapper = staticmethod(lambda x: x)\n\n    def __init__(self, environ, *args, **kwargs):\n        # apply environment wrapper to provided WSGI environment\n        flask.Request.__init__(self, self.environment_wrapper(environ), *args, **kwargs)\n\n    @cached_property\n    def cookies(self):\n        # strip cookie_suffix from all cookies in the request, return result\n        cookies = flask.Request.cookies.__get__(self)\n\n        result = {}\n        desuffixed = {}\n        for key, value in cookies.items():\n\n            def process_value(k, v):\n                if k == current_app.config.get(\n                    \"REMEMBER_COOKIE_NAME\", REMEMBER_COOKIE_NAME\n                ):\n                    return decode_remember_me_cookie(v)\n                return v\n\n            try:\n                if key.endswith(self.cookie_suffix):\n                    key = key[: -len(self.cookie_suffix)]\n                    desuffixed[key] = process_value(key, value)\n                else:\n                    result[key] = process_value(key, value)\n            except ValueError:\n                # ignore broken cookies\n                pass\n\n        result.update(desuffixed)\n        return result\n\n    @cached_property\n    def server_name(self):\n        \"\"\"Short cut to the request's server name header\"\"\"\n        return self.environ.get(\"SERVER_NAME\")\n\n    @cached_property\n    def server_port(self):\n        \"\"\"Short cut to the request's server port header\"\"\"\n        return self.environ.get(\"SERVER_PORT\")\n\n    @cached_property\n    def cookie_suffix(self):\n        \"\"\"\n        Request specific suffix for set and read cookies\n\n        We need this because cookies are not port-specific and we don't want to overwrite our\n        session and other cookies from one OctoPrint instance on our machine with those of another\n        one who happens to listen on the same address albeit a different port or script root.\n        \"\"\"\n        result = \"_P\" + self.server_port\n        if self.script_root:\n            return result + \"_R\" + self.script_root.replace(\"/\", \"|\")\n        return result\n\n\nclass OctoPrintFlaskResponse(flask.Response):\n    def set_cookie(self, key, value=\"\", *args, **kwargs):\n        # restrict cookie path to script root\n        kwargs[\"path\"] = flask.request.script_root + kwargs.get(\"path\", \"/\")\n\n        # set same-site header\n        samesite = settings().get([\"server\", \"cookies\", \"samesite\"])\n        if samesite is not None:\n            samesite = samesite.lower()\n        if samesite == \"none\":\n            # Must be string \"None\"\n            samesite = \"None\"\n        if samesite not in (\"None\", \"strict\", \"lax\"):\n            # If NoneType, the cookie is not set\n            samesite = None\n        kwargs[\"samesite\"] = samesite\n\n        # set secure if necessary\n        kwargs[\"secure\"] = settings().getBoolean([\"server\", \"cookies\", \"secure\"])\n\n        # tie account properties to remember me cookie (e.g. current password hash)\n        if key == current_app.config.get(\"REMEMBER_COOKIE_NAME\", REMEMBER_COOKIE_NAME):\n            value = encode_remember_me_cookie(value)\n\n        # add request specific cookie suffix to name\n        flask.Response.set_cookie(\n            self, key + flask.request.cookie_suffix, value=value, *args, **kwargs\n        )\n\n    def delete_cookie(self, key, path=\"/\", domain=None):\n        flask.Response.delete_cookie(self, key, path=path, domain=domain)\n\n        # we also still might have a cookie left over from before we started prefixing, delete that manually\n        # without any pre processing (no path prefix, no key suffix)\n        flask.Response.set_cookie(\n            self, key, expires=0, max_age=0, path=path, domain=domain\n        )\n\n\nclass OctoPrintSessionInterface(flask.sessions.SecureCookieSessionInterface):\n    def should_set_cookie(self, app, session):\n        return flask.request.endpoint != \"static\"\n\n    def save_session(self, app, session, response):\n        if flask.g.get(\"login_via_apikey\", False):\n            return\n        return super().save_session(app, session, response)\n\n\n# ~~ jinja environment\n\n\nclass PrefixAwareJinjaEnvironment(flask.templating.Environment):\n    def __init__(self, *args, **kwargs):\n        flask.templating.Environment.__init__(self, *args, **kwargs)\n        self.prefix_loader = None\n        self._cached_templates = {}\n\n    def join_path(self, template, parent):\n        if parent and \"/\" in parent:\n            prefix, _ = parent.split(\"/\", 1)\n            if template in self._templates_for_prefix(prefix) and not template.startswith(\n                prefix + \"/\"\n            ):\n                return prefix + \"/\" + template\n\n        return template\n\n    def _templates_for_prefix(self, prefix):\n        if prefix in self._cached_templates:\n            return self._cached_templates[prefix]\n\n        templates = []\n        if prefix in self.prefix_loader.mapping:\n            templates = self.prefix_loader.mapping[prefix].list_templates()\n        self._cached_templates[prefix] = templates\n        return templates\n\n\n# ~~ passive login helper\n\n_cached_local_networks = None\n\n\ndef _local_networks():\n    global _cached_local_networks\n\n    if _cached_local_networks is None:\n        logger = logging.getLogger(__name__)\n        local_networks = netaddr.IPSet([])\n        for entry in settings().get([\"accessControl\", \"localNetworks\"]):\n            try:\n                network = netaddr.IPNetwork(entry)\n            except Exception:\n                logger.warning(\n                    \"Invalid network definition configured in localNetworks: {}\".format(\n                        entry\n                    )\n                )\n                continue\n\n            local_networks.add(network)\n            logger.debug(f\"Added network {network} to localNetworks\")\n\n            if network.version == 4:\n                network_v6 = network.ipv6()\n                local_networks.add(network_v6)\n                logger.debug(\n                    \"Also added v6 representation of v4 network {} = {} to localNetworks\".format(\n                        network, network_v6\n                    )\n                )\n\n        _cached_local_networks = local_networks\n\n    return _cached_local_networks\n\n\ndef passive_login():\n    logger = logging.getLogger(__name__)\n\n    user = flask_login.current_user\n\n    remote_address = get_remote_address(flask.request)\n    ip_check_enabled = settings().getBoolean([\"server\", \"ipCheck\", \"enabled\"])\n    ip_check_trusted = settings().get([\"server\", \"ipCheck\", \"trustedSubnets\"])\n\n    if isinstance(user, LocalProxy):\n        # noinspection PyProtectedMember\n        user = user._get_current_object()\n\n    def login(u):\n        # login known user\n        if not u.is_anonymous:\n            u = octoprint.server.userManager.login_user(u)\n        flask_login.login_user(u)\n        flask_principal.identity_changed.send(\n            flask.current_app._get_current_object(),\n            identity=flask_principal.Identity(u.get_id()),\n        )\n        if hasattr(u, \"session\"):\n            flask.session[\"usersession.id\"] = u.session\n            flask.session[\"usersession.signature\"] = session_signature(\n                u.get_id(), u.session\n            )\n        flask.g.user = u\n\n        eventManager().fire(Events.USER_LOGGED_IN, payload={\"username\": u.get_id()})\n\n        return u\n\n    def determine_user(u):\n        if not u.is_anonymous and u.is_active:\n            # known active user\n            logger.info(f\"Passively logging in user {u.get_id()} from {remote_address}\")\n\n        elif (\n            settings().getBoolean([\"accessControl\", \"autologinLocal\"])\n            and settings().get([\"accessControl\", \"autologinAs\"]) is not None\n            and settings().get([\"accessControl\", \"localNetworks\"]) is not None\n            and \"active_logout\" not in flask.request.cookies\n            and remote_address\n        ):\n            # attempt local autologin\n            autologin_as = settings().get([\"accessControl\", \"autologinAs\"])\n            local_networks = _local_networks()\n            logger.debug(\n                \"Checking if remote address {} is in localNetworks ({!r})\".format(\n                    remote_address, local_networks\n                )\n            )\n\n            try:\n                if netaddr.IPAddress(remote_address) in local_networks:\n                    autologin_user = octoprint.server.userManager.find_user(autologin_as)\n                    if autologin_user is not None and autologin_user.is_active:\n                        logger.info(\n                            \"Passively logging in user {} from {} via autologin\".format(\n                                autologin_as, remote_address\n                            )\n                        )\n                        flask.session[\"login_mechanism\"] = \"autologin\"\n                        return autologin_user\n            except Exception:\n                logger.exception(\n                    \"Could not autologin user {} from {} for networks {}\".format(\n                        autologin_as, remote_address, local_networks\n                    )\n                )\n\n        if not u.is_active:\n            # inactive user, switch to anonymous\n            u = octoprint.server.userManager.anonymous_user_factory()\n\n        return u\n\n    user = login(determine_user(user))\n    response = user.as_dict()\n    response[\"_is_external_client\"] = ip_check_enabled and not is_lan_address(\n        remote_address, additional_private=ip_check_trusted\n    )\n    if flask.session.get(\"login_mechanism\") is not None:\n        response[\"_login_mechanism\"] = flask.session.get(\"login_mechanism\")\n    return flask.jsonify(response)\n\n\n# ~~ rate limiting helper\n\n\ndef limit(*args, **kwargs):\n    if octoprint.server.limiter:\n        return octoprint.server.limiter.limit(*args, **kwargs)\n    else:\n\n        def decorator(f):\n            @functools.wraps(f)\n            def decorated_function(*args, **kwargs):\n                return f(*args, **kwargs)\n\n            return decorated_function\n\n        return decorator\n\n\n# ~~ cache decorator for cacheable views\n\n\nclass LessSimpleCache(BaseCache):\n    \"\"\"\n    Slightly improved version of :class:`SimpleCache`.\n\n    Setting ``default_timeout`` or ``timeout`` to ``-1`` will have no timeout be applied at all.\n    \"\"\"\n\n    def __init__(self, threshold=500, default_timeout=300):\n        BaseCache.__init__(self, default_timeout=default_timeout)\n        self._mutex = threading.RLock()\n        self._cache = {}\n        self._bypassed = set()\n        self.clear = self._cache.clear\n        self._threshold = threshold\n\n    def _prune(self):\n        if self.over_threshold():\n            now = time.time()\n            for idx, (key, (expires, _)) in enumerate(self._cache.items()):\n                if expires is not None and expires <= now or idx % 3 == 0:\n                    with self._mutex:\n                        self._cache.pop(key, None)\n\n    def get(self, key):\n        import pickle\n\n        now = time.time()\n        with self._mutex:\n            expires, value = self._cache.get(key, (0, None))\n        if expires is None or expires > now:\n            return pickle.loads(value)\n\n    def set(self, key, value, timeout=None):\n        import pickle\n\n        with self._mutex:\n            self._prune()\n            self._cache[key] = (\n                self.calculate_timeout(timeout=timeout),\n                pickle.dumps(value, pickle.HIGHEST_PROTOCOL),\n            )\n            if key in self._bypassed:\n                self._bypassed.remove(key)\n\n    def add(self, key, value, timeout=None):\n        with self._mutex:\n            self.set(key, value, timeout=None)\n            self._cache.setdefault(key, self._cache[key])\n\n    def delete(self, key):\n        with self._mutex:\n            self._cache.pop(key, None)\n\n    def calculate_timeout(self, timeout=None):\n        if timeout is None:\n            timeout = self.default_timeout\n        if timeout == -1:\n            return None\n        return time.time() + timeout\n\n    def over_threshold(self):\n        if self._threshold is None:\n            return False\n        with self._mutex:\n            return len(self._cache) > self._threshold\n\n    def __getitem__(self, key):\n        return self.get(key)\n\n    def __setitem__(self, key, value):\n        return self.set(key, value)\n\n    def __delitem__(self, key):\n        return self.delete(key)\n\n    def __contains__(self, key):\n        with self._mutex:\n            return key in self._cache\n\n    def set_bypassed(self, key):\n        with self._mutex:\n            self._bypassed.add(key)\n\n    def is_bypassed(self, key):\n        with self._mutex:\n            return key in self._bypassed\n\n\n_cache = LessSimpleCache()\n\n\ndef cached(\n    timeout=5 * 60,\n    key=lambda: \"view:%s\" % flask.request.path,\n    unless=None,\n    refreshif=None,\n    unless_response=None,\n):\n    def decorator(f):\n        @functools.wraps(f)\n        def decorated_function(*args, **kwargs):\n            logger = logging.getLogger(__name__)\n\n            cache_key = key()\n\n            def f_with_duration(*args, **kwargs):\n                start_time = time.time()\n                try:\n                    return f(*args, **kwargs)\n                finally:\n                    elapsed = time.time() - start_time\n                    logger.debug(\n                        \"Needed {elapsed:.2f}s to render {path} (key: {key})\".format(\n                            elapsed=elapsed, path=flask.request.path, key=cache_key\n                        )\n                    )\n\n            # bypass the cache if \"unless\" condition is true\n            if callable(unless) and unless():\n                logger.debug(\n                    \"Cache for {path} bypassed, calling wrapped function\".format(\n                        path=flask.request.path\n                    )\n                )\n                _cache.set_bypassed(cache_key)\n                return f_with_duration(*args, **kwargs)\n\n            # also bypass the cache if it's disabled completely\n            if not settings().getBoolean([\"devel\", \"cache\", \"enabled\"]):\n                logger.debug(\n                    \"Cache for {path} disabled, calling wrapped function\".format(\n                        path=flask.request.path\n                    )\n                )\n                _cache.set_bypassed(cache_key)\n                return f_with_duration(*args, **kwargs)\n\n            rv = _cache.get(cache_key)\n\n            # only take the value from the cache if we are not required to refresh it from the wrapped function\n            if rv is not None and (not callable(refreshif) or not refreshif(rv)):\n                logger.debug(\n                    \"Serving entry for {path} from cache (key: {key})\".format(\n                        path=flask.request.path, key=cache_key\n                    )\n                )\n                if \"X-From-Cache\" not in rv.headers:\n                    rv.headers[\"X-From-Cache\"] = \"true\"\n                return rv\n\n            # get value from wrapped function\n            logger.debug(\n                \"No cache entry or refreshing cache for {path} (key: {key}), calling wrapped function\".format(\n                    path=flask.request.path, key=cache_key\n                )\n            )\n            rv = f_with_duration(*args, **kwargs)\n\n            # do not store if the \"unless_response\" condition is true\n            if callable(unless_response) and unless_response(rv):\n                logger.debug(\n                    \"Not caching result for {path} (key: {key}), bypassed\".format(\n                        path=flask.request.path, key=cache_key\n                    )\n                )\n                _cache.set_bypassed(cache_key)\n                return rv\n\n            # store it in the cache\n            _cache.set(cache_key, rv, timeout=timeout)\n\n            return rv\n\n        return decorated_function\n\n    return decorator\n\n\ndef is_in_cache(key=lambda: \"view:%s\" % flask.request.path):\n    if callable(key):\n        key = key()\n    return key in _cache\n\n\ndef is_cache_bypassed(key=lambda: \"view:%s\" % flask.request.path):\n    if callable(key):\n        key = key()\n    return _cache.is_bypassed(key)\n\n\ndef cache_check_headers():\n    return \"no-cache\" in flask.request.cache_control or \"no-cache\" in flask.request.pragma\n\n\ndef cache_check_response_headers(response):\n    if not isinstance(response, flask.Response):\n        return False\n\n    headers = response.headers\n\n    if \"Cache-Control\" in headers and (\n        \"no-cache\" in headers[\"Cache-Control\"] or \"no-store\" in headers[\"Cache-Control\"]\n    ):\n        return True\n\n    if \"Pragma\" in headers and \"no-cache\" in headers[\"Pragma\"]:\n        return True\n\n    if \"Expires\" in headers and headers[\"Expires\"] in (\"0\", \"-1\"):\n        return True\n\n    return False\n\n\ndef cache_check_status_code(response, valid):\n    if not isinstance(response, flask.Response):\n        return False\n\n    if callable(valid):\n        return not valid(response.status_code)\n    else:\n        return response.status_code not in valid\n\n\nclass PreemptiveCache:\n    def __init__(self, cachefile):\n        self.cachefile = cachefile\n        self.environment = None\n\n        self._logger = logging.getLogger(__name__ + \".\" + self.__class__.__name__)\n\n        self._lock = threading.RLock()\n\n    def record(self, data, unless=None, root=None):\n        if callable(unless) and unless():\n            return\n\n        entry_data = data\n        if callable(entry_data):\n            entry_data = entry_data()\n\n        if entry_data is not None:\n            if root is None:\n                from flask import request\n\n                root = request.path\n            self.add_data(root, entry_data)\n\n    def has_record(self, data, root=None):\n        if callable(data):\n            data = data()\n\n        if data is None:\n            return False\n\n        if root is None:\n            from flask import request\n\n            root = request.path\n\n        all_data = self.get_data(root)\n        for existing in all_data:\n            if self._compare_data(data, existing):\n                return True\n\n        return False\n\n    def clean_all_data(self, cleanup_function):\n        assert callable(cleanup_function)\n\n        with self._lock:\n            all_data = self.get_all_data()\n            for root, entries in list(all_data.items()):\n                old_count = len(entries)\n                entries = cleanup_function(root, entries)\n                if not entries:\n                    del all_data[root]\n                    self._logger.debug(f\"Removed root {root} from preemptive cache\")\n                elif len(entries) < old_count:\n                    all_data[root] = entries\n                    self._logger.debug(\n                        \"Removed {} entries from preemptive cache for root {}\".format(\n                            old_count - len(entries), root\n                        )\n                    )\n            self.set_all_data(all_data)\n\n        return all_data\n\n    def get_all_data(self):\n        cache_data = None\n        with self._lock:\n            try:\n                cache_data = yaml.load_from_file(path=self.cachefile)\n            except OSError as e:\n                import errno\n\n                if e.errno != errno.ENOENT:\n                    raise\n            except Exception:\n                self._logger.exception(f\"Error while reading {self.cachefile}\")\n\n        if cache_data is None:\n            cache_data = {}\n\n        if not self._validate_data(cache_data):\n            self._logger.warning(\"Preemptive cache data was invalid, ignoring it\")\n            cache_data = {}\n\n        return cache_data\n\n    def get_data(self, root):\n        cache_data = self.get_all_data()\n        return cache_data.get(root, list())\n\n    def set_all_data(self, data):\n        from octoprint.util import atomic_write\n\n        with self._lock:\n            try:\n                with atomic_write(self.cachefile, \"wt\", max_permissions=0o666) as handle:\n                    yaml.save_to_file(data, file=handle, pretty=True)\n            except Exception:\n                self._logger.exception(f\"Error while writing {self.cachefile}\")\n\n    def set_data(self, root, data):\n        with self._lock:\n            all_data = self.get_all_data()\n            all_data[root] = data\n            self.set_all_data(all_data)\n\n    def add_data(self, root, data):\n        def split_matched_and_unmatched(entry, entries):\n            matched = []\n            unmatched = []\n\n            for e in entries:\n                if self._compare_data(e, entry):\n                    matched.append(e)\n                else:\n                    unmatched.append(e)\n\n            return matched, unmatched\n\n        with self._lock:\n            cache_data = self.get_all_data()\n\n            if root not in cache_data:\n                cache_data[root] = []\n\n            existing, other = split_matched_and_unmatched(data, cache_data[root])\n\n            def get_newest(entries):\n                result = None\n                for entry in entries:\n                    if \"_timestamp\" in entry and (\n                        result is None\n                        or (\n                            \"_timestamp\" in result\n                            and result[\"_timestamp\"] < entry[\"_timestamp\"]\n                        )\n                    ):\n                        result = entry\n                return result\n\n            to_persist = get_newest(existing)\n            if not to_persist:\n                import copy\n\n                to_persist = copy.deepcopy(data)\n                to_persist[\"_timestamp\"] = time.time()\n                to_persist[\"_count\"] = 1\n                self._logger.info(f\"Adding entry for {root} and {to_persist!r}\")\n            else:\n                to_persist[\"_timestamp\"] = time.time()\n                to_persist[\"_count\"] = to_persist.get(\"_count\", 0) + 1\n                self._logger.debug(\n                    f\"Updating timestamp and counter for {root} and {data!r}\"\n                )\n\n            self.set_data(root, [to_persist] + other)\n\n    def _compare_data(self, a, b):\n        from octoprint.util import dict_filter\n\n        def strip_ignored(d):\n            return dict_filter(d, lambda k, v: not k.startswith(\"_\"))\n\n        return set(strip_ignored(a).items()) == set(strip_ignored(b).items())\n\n    def _validate_data(self, data):\n        if not isinstance(data, dict):\n            return False\n\n        for entries in data.values():\n            if not isinstance(entries, list):\n                return False\n\n            for entry in entries:\n                if not self._validate_entry(entry):\n                    return False\n\n        return True\n\n    def _validate_entry(self, entry):\n        return isinstance(entry, dict) and \"_timestamp\" in entry and \"_count\" in entry\n\n\ndef preemptively_cached(cache, data, unless=None):\n    def decorator(f):\n        @functools.wraps(f)\n        def decorated_function(*args, **kwargs):\n            try:\n                cache.record(data, unless=unless)\n            except Exception:\n                logging.getLogger(__name__).exception(\n                    f\"Error while recording preemptive cache entry: {data!r}\"\n                )\n            return f(*args, **kwargs)\n\n        return decorated_function\n\n    return decorator\n\n\ndef etagged(etag):\n    def decorator(f):\n        @functools.wraps(f)\n        def decorated_function(*args, **kwargs):\n            rv = f(*args, **kwargs)\n            if isinstance(rv, flask.Response):\n                try:\n                    result = etag\n                    if callable(result):\n                        result = result(rv)\n                    if result:\n                        rv.set_etag(result)\n                except Exception:\n                    logging.getLogger(__name__).exception(\n                        \"Error while calculating the etag value for response {!r}\".format(\n                            rv\n                        )\n                    )\n            return rv\n\n        return decorated_function\n\n    return decorator\n\n\ndef lastmodified(date):\n    def decorator(f):\n        @functools.wraps(f)\n        def decorated_function(*args, **kwargs):\n            rv = f(*args, **kwargs)\n            if \"Last-Modified\" not in rv.headers:\n                try:\n                    result = date\n                    if callable(result):\n                        result = result(rv)\n\n                    if not isinstance(result, str):\n                        from werkzeug.http import http_date\n\n                        result = http_date(result)\n\n                    if result:\n                        rv.headers[\"Last-Modified\"] = result\n                except Exception:\n                    logging.getLogger(__name__).exception(\n                        \"Error while calculating the lastmodified value for response {!r}\".format(\n                            rv\n                        )\n                    )\n            return rv\n\n        return decorated_function\n\n    return decorator\n\n\ndef conditional(condition, met):\n    def decorator(f):\n        @functools.wraps(f)\n        def decorated_function(*args, **kwargs):\n            try:\n                if callable(condition) and condition():\n                    # condition has been met, return met-response\n                    rv = met\n                    if callable(met):\n                        rv = met()\n                    return rv\n            except Exception:\n                logging.getLogger(__name__).exception(\n                    \"Error while evaluating conditional {!r} or met {!r}\".format(\n                        condition, met\n                    )\n                )\n\n            # condition hasn't been met, call decorated function\n            return f(*args, **kwargs)\n\n        return decorated_function\n\n    return decorator\n\n\ndef with_client_revalidation(f):\n    @functools.wraps(f)\n    def decorated_function(*args, **kwargs):\n        r = f(*args, **kwargs)\n\n        if isinstance(r, flask.Response):\n            r = add_revalidation_response_headers(r)\n\n        return r\n\n    return decorated_function\n\n\ndef with_revalidation_checking(\n    etag_factory=None, lastmodified_factory=None, condition=None, unless=None\n):\n    if etag_factory is None:\n\n        def etag_factory(lm=None):\n            return None\n\n    if lastmodified_factory is None:\n\n        def lastmodified_factory():\n            return None\n\n    if condition is None:\n\n        def condition(lm=None, etag=None):\n            if lm is None:\n                lm = lastmodified_factory()\n\n            if etag is None:\n                etag = etag_factory(lm=lm)\n\n            if flask.request.if_none_match and flask.request.if_modified_since:\n                # use both\n                return check_lastmodified(lm) and check_etag(etag)\n            elif flask.request.if_none_match:\n                # use only ETag\n                return check_etag(etag)\n            elif flask.request.if_modified_since:\n                # use only Last-Modified\n                return check_lastmodified(lm)\n            else:\n                # assume stale cache\n                return False\n\n    if unless is None:\n\n        def unless():\n            return False\n\n    def decorator(f):\n        @functools.wraps(f)\n        def decorated_function(*args, **kwargs):\n            from octoprint.server import NOT_MODIFIED\n\n            lm = lastmodified_factory()\n            etag = etag_factory(lm)\n\n            if condition(lm, etag) and not unless():\n                return NOT_MODIFIED\n\n            # generate response\n            response = f(*args, **kwargs)\n\n            # set etag header if not already set\n            if etag and response.get_etag()[0] is None:\n                response.set_etag(etag)\n\n            # set last modified header if not already set\n            if lm and response.headers.get(\"Last-Modified\", None) is None:\n                if not isinstance(lm, str):\n                    from werkzeug.http import http_date\n\n                    lm = http_date(lm)\n                response.headers[\"Last-Modified\"] = lm\n\n            response = add_no_max_age_response_headers(response)\n            return response\n\n        return decorated_function\n\n    return decorator\n\n\ndef check_etag(etag):\n    if etag is None:\n        return False\n\n    return (\n        flask.request.method in (\"GET\", \"HEAD\")\n        and flask.request.if_none_match is not None\n        and etag in flask.request.if_none_match\n    )\n\n\ndef check_lastmodified(lastmodified: Union[int, float, datetime]) -> bool:\n    \"\"\"Compares the provided lastmodified value with the value of the If-Modified-Since header.\n\n    If ``lastmodified`` is an int or float, it's assumed to be a Unix timestamp and converted\n    to a timezone aware datetime instance in UTC.\n\n    If ``lastmodified`` is a datetime instance, it needs to be timezone aware or the\n    result will always be ``False``.\n\n    Args:\n        lastmodified (Union[int, float, datetime]): The last modified value to compare against\n\n    Raises:\n        ValueError: If anything but an int, float or datetime instance is passed\n\n    Returns:\n        bool: true if the values indicate that the document is still up to date\n    \"\"\"\n\n    if lastmodified is None:\n        return False\n\n    if isinstance(lastmodified, (int, float)):\n        # max(86400, lastmodified) is workaround for https://bugs.python.org/issue29097,\n        # present in CPython 3.6.x up to 3.7.1.\n        #\n        # I think it's fair to say that we'll never encounter lastmodified values older than\n        # 1970-01-02 so this is a safe workaround.\n        #\n        # Timestamps are defined as seconds since epoch aka 1970/01/01 00:00:00Z, so we\n        # use UTC as timezone here.\n        lastmodified = datetime.fromtimestamp(\n            max(86400, lastmodified), tz=UTC_TZ\n        ).replace(microsecond=0)\n\n    if not isinstance(lastmodified, datetime):\n        raise ValueError(\n            \"lastmodified must be a datetime or float or int instance but, got {} instead\".format(\n                lastmodified.__class__\n            )\n        )\n\n    if not is_timezone_aware(lastmodified):\n        # datetime object is not timezone aware, we can't check lastmodified with that\n        logger = logging.getLogger(__name__)\n        logger.warning(\n            \"lastmodified is not timezone aware, cannot check against If-Modified-Since. In the future this will become an error!\",\n            stack_info=logger.isEnabledFor(logging.DEBUG),\n        )\n        return False\n\n    return (\n        flask.request.method in (\"GET\", \"HEAD\")\n        and flask.request.if_modified_since is not None\n        and lastmodified <= flask.request.if_modified_since\n    )\n\n\ndef add_revalidation_response_headers(response):\n    import werkzeug.http\n\n    cache_control = werkzeug.http.parse_dict_header(\n        response.headers.get(\"Cache-Control\", \"\")\n    )\n    if \"no-cache\" not in cache_control:\n        cache_control[\"no-cache\"] = None\n    if \"must-revalidate\" not in cache_control:\n        cache_control[\"must-revalidate\"] = None\n    response.headers[\"Cache-Control\"] = werkzeug.http.dump_header(cache_control)\n\n    return response\n\n\ndef add_non_caching_response_headers(response):\n    import werkzeug.http\n\n    cache_control = werkzeug.http.parse_dict_header(\n        response.headers.get(\"Cache-Control\", \"\")\n    )\n    if \"no-store\" not in cache_control:\n        cache_control[\"no-store\"] = None\n    if \"no-cache\" not in cache_control:\n        cache_control[\"no-cache\"] = None\n    if \"must-revalidate\" not in cache_control:\n        cache_control[\"must-revalidate\"] = None\n    if \"post-check\" not in cache_control or cache_control[\"post-check\"] != \"0\":\n        cache_control[\"post-check\"] = \"0\"\n    if \"pre-check\" not in cache_control or cache_control[\"pre-check\"] != \"0\":\n        cache_control[\"pre-check\"] = \"0\"\n    if \"max-age\" not in cache_control or cache_control[\"max-age\"] != \"0\":\n        cache_control[\"max-age\"] = \"0\"\n    response.headers[\"Cache-Control\"] = werkzeug.http.dump_header(cache_control)\n\n    response.headers[\"Pragma\"] = \"no-cache\"\n    response.headers[\"Expires\"] = \"-1\"\n    return response\n\n\ndef add_no_max_age_response_headers(response):\n    import werkzeug.http\n\n    cache_control = werkzeug.http.parse_dict_header(\n        response.headers.get(\"Cache-Control\", \"\")\n    )\n    if \"max-age\" not in cache_control or cache_control[\"max-age\"] != \"0\":\n        cache_control[\"max-age\"] = \"0\"\n    response.headers[\"Cache-Control\"] = werkzeug.http.dump_header(cache_control)\n\n    return response\n\n\n# ~~ access validators for use with tornado\n\n\ndef permission_validator(request, permission):\n    \"\"\"\n    Validates that the given request is made by an authorized user, identified either by API key or existing Flask\n    session.\n\n    Must be executed in an existing Flask request context!\n\n    :param request: The Flask request object\n    :param request: The required permission\n    \"\"\"\n\n    user = get_flask_user_from_request(request)\n    if not user.has_permission(permission):\n        raise tornado.web.HTTPError(403)\n\n\n@deprecated(\n    \"admin_validator is deprecated, please use new permission_validator\", since=\"\"\n)\ndef admin_validator(request):\n    from octoprint.access.permissions import Permissions\n\n    return permission_validator(request, Permissions.ADMIN)\n\n\n@deprecated(\"user_validator is deprecated, please use new permission_validator\", since=\"\")\ndef user_validator(request):\n    return True\n\n\ndef get_flask_user_from_request(request):\n    \"\"\"\n    Retrieves the current flask user from the request context. Uses API key if available, otherwise the current\n    user session if available.\n\n    :param request: flask request from which to retrieve the current user\n    :return: the user (might be an anonymous user)\n    \"\"\"\n    import flask_login\n\n    import octoprint.server.util\n\n    user = None\n\n    apikey = octoprint.server.util.get_api_key(request)\n    if apikey is not None:\n        # user from api key?\n        user = octoprint.server.util.get_user_for_apikey(apikey)\n\n    if user is None:\n        # user still None -> current session user\n        user = flask_login.current_user\n\n    if user is None:\n        # user still None -> anonymous\n        from octoprint.server import userManager\n\n        user = userManager.anonymous_user_factory()\n\n    return user\n\n\ndef redirect_to_tornado(request, target, code=302):\n    \"\"\"\n    Redirects from flask to tornado, flask request context must exist.\n\n    :param request:\n    :param target:\n    :param code:\n    :return:\n    \"\"\"\n\n    import flask\n\n    requestUrl = request.url\n    appBaseUrl = requestUrl[: requestUrl.find(flask.url_for(\"index\") + \"api\")]\n\n    redirectUrl = appBaseUrl + target\n    if \"?\" in requestUrl:\n        fragment = requestUrl[requestUrl.rfind(\"?\") :]\n        redirectUrl += fragment\n    return flask.redirect(redirectUrl, code=code)\n\n\ndef restricted_access(func):\n    \"\"\"\n    This combines :py:func:`no_firstrun_access` and ``login_required``.\n    \"\"\"\n\n    @functools.wraps(func)\n    def decorated_view(*args, **kwargs):\n        return no_firstrun_access(flask_login.login_required(func))(*args, **kwargs)\n\n    return decorated_view\n\n\ndef no_firstrun_access(func):\n    \"\"\"\n    If you decorate a view with this, it will ensure that first setup has been\n    done for OctoPrint's Access Control.\n\n    If OctoPrint's Access Control has not been setup yet (indicated by the userManager\n    not reporting that its user database has been customized from default), the decorator\n    will cause a HTTP 403 status code to be returned by the decorated resource.\n    \"\"\"\n\n    @functools.wraps(func)\n    def decorated_view(*args, **kwargs):\n        # if OctoPrint hasn't been set up yet, abort\n        if settings().getBoolean([\"server\", \"firstRun\"]) and (\n            octoprint.server.userManager is None\n            or not octoprint.server.userManager.has_been_customized()\n        ):\n            flask.abort(403)\n        return func(*args, **kwargs)\n\n    return decorated_view\n\n\ndef firstrun_only_access(func):\n    \"\"\"\n    If you decorate a view with this, it will ensure that first setup has _not_ been\n    done for OctoPrint's Access Control. Otherwise it\n    will cause a HTTP 403 status code to be returned by the decorated resource.\n    \"\"\"\n\n    @functools.wraps(func)\n    def decorated_view(*args, **kwargs):\n        # if OctoPrint has been set up yet, abort\n        if settings().getBoolean([\"server\", \"firstRun\"]) and (\n            octoprint.server.userManager is None\n            or not octoprint.server.userManager.has_been_customized()\n        ):\n            return func(*args, **kwargs)\n        else:\n            flask.abort(403)\n\n    return decorated_view\n\n\ndef get_remote_address(request):\n    forwardedFor = request.headers.get(\"X-Forwarded-For\", None)\n    if forwardedFor is not None:\n        return forwardedFor.split(\",\")[0]\n    return request.remote_addr\n\n\ndef get_json_command_from_request(request, valid_commands):\n    content_type = request.headers.get(\"Content-Type\", None)\n    if content_type is None or \"application/json\" not in content_type:\n        flask.abort(400, description=\"Expected content-type JSON\")\n\n    data = request.get_json()\n    if data is None:\n        flask.abort(\n            400, description=\"Malformed JSON body or wrong content-type in request\"\n        )\n    if \"command\" not in data or data[\"command\"] not in valid_commands:\n        flask.abort(400, description=\"command is invalid\")\n\n    command = data[\"command\"]\n    if any(map(lambda x: x not in data, valid_commands[command])):\n        flask.abort(400, description=\"Mandatory parameters missing\")\n\n    return command, data, None\n\n\ndef make_text_response(message, status):\n    \"\"\"\n    Helper to generate basic text responses.\n\n    Response will have the provided message as body, the provided status code, and\n    a content type of \"text/plain\".\n\n    Args:\n        message: The message in the response body\n        status: The HTTP status code\n\n    Returns:\n\n    \"\"\"\n    return make_response(message, status, {\"Content-Type\": \"text/plain\"})\n\n\ndef make_api_error(message, status):\n    \"\"\"\n    Helper to generate API error responses in JSON format.\n\n    Turns something like ``make_api_error(\"Not Found\", 404)`` into a JSON response\n    with body ``{\"error\": \"Not Found\"}``.\n\n    Args:\n        message: The error message to put into the response\n        status: The HTTP status code\n\n    Returns: a flask response to return to the client\n    \"\"\"\n    return make_response(flask.jsonify(error=message), status)\n\n\n##~~ Flask-Assets resolver with plugin asset support\n\n\nclass PluginAssetResolver(flask_assets.FlaskResolver):\n    def split_prefix(self, ctx, item):\n        app = ctx.environment._app\n        if item.startswith(\"plugin/\"):\n            try:\n                prefix, plugin, name = item.split(\"/\", 2)\n                blueprint = prefix + \".\" + plugin\n\n                directory = flask_assets.get_static_folder(app.blueprints[blueprint])\n                item = name\n                endpoint = blueprint + \".static\"\n                return directory, item, endpoint\n            except (ValueError, KeyError):\n                pass\n\n        return flask_assets.FlaskResolver.split_prefix(self, ctx, item)\n\n    def resolve_output_to_path(self, ctx, target, bundle):\n        import os\n\n        return os.path.normpath(os.path.join(ctx.environment.directory, target))\n\n\n##~~ Webassets updater that takes changes in the configuration into account\n\n\nclass SettingsCheckUpdater(webassets.updater.BaseUpdater):\n\n    updater = \"always\"\n\n    def __init__(self):\n        self._delegate = webassets.updater.get_updater(self.__class__.updater)\n\n    def needs_rebuild(self, bundle, ctx):\n        return self._delegate.needs_rebuild(bundle, ctx) or self.changed_settings(ctx)\n\n    def changed_settings(self, ctx):\n        if not ctx.cache:\n            return False\n\n        cache_key = (\"octo\", \"settings\")\n        current_hash = settings().effective_hash\n        cached_hash = ctx.cache.get(cache_key)\n        # This may seem counter-intuitive, but if no cache entry is found\n        # then we actually return \"no update needed\". This is because\n        # otherwise if no cache / a dummy cache is used, then we would be\n        # rebuilding every single time.\n        if cached_hash is not None:\n            return cached_hash != current_hash\n        return False\n\n    def build_done(self, bundle, ctx):\n        self._delegate.build_done(bundle, ctx)\n        if not ctx.cache:\n            return\n\n        cache_key = (\"octo\", \"settings\")\n        ctx.cache.set(cache_key, settings().effective_hash)\n\n\n##~~ core assets collector\ndef collect_core_assets(preferred_stylesheet=\"css\"):\n    assets = {\"js\": [], \"clientjs\": [], \"css\": [], \"less\": []}\n    assets[\"js\"] = [\n        \"js/app/bindings/allowbindings.js\",\n        \"js/app/bindings/contextmenu.js\",\n        \"js/app/bindings/invisible.js\",\n        \"js/app/bindings/popover.js\",\n        \"js/app/bindings/qrcode.js\",\n        \"js/app/bindings/slimscrolledforeach.js\",\n        \"js/app/bindings/toggle.js\",\n        \"js/app/bindings/togglecontent.js\",\n        \"js/app/bindings/valuewithinit.js\",\n        \"js/app/viewmodels/access.js\",\n        \"js/app/viewmodels/appearance.js\",\n        \"js/app/viewmodels/connection.js\",\n        \"js/app/viewmodels/control.js\",\n        \"js/app/viewmodels/files.js\",\n        \"js/app/viewmodels/loginstate.js\",\n        \"js/app/viewmodels/loginui.js\",\n        \"js/app/viewmodels/navigation.js\",\n        \"js/app/viewmodels/printerstate.js\",\n        \"js/app/viewmodels/printerprofiles.js\",\n        \"js/app/viewmodels/settings.js\",\n        \"js/app/viewmodels/slicing.js\",\n        \"js/app/viewmodels/system.js\",\n        \"js/app/viewmodels/temperature.js\",\n        \"js/app/viewmodels/terminal.js\",\n        \"js/app/viewmodels/timelapse.js\",\n        \"js/app/viewmodels/uistate.js\",\n        \"js/app/viewmodels/users.js\",\n        \"js/app/viewmodels/usersettings.js\",\n        \"js/app/viewmodels/wizard.js\",\n        \"js/app/viewmodels/about.js\",\n    ]\n\n    assets[\"clientjs\"] = [\n        \"js/app/client/base.js\",\n        \"js/app/client/socket.js\",\n        \"js/app/client/access.js\",\n        \"js/app/client/browser.js\",\n        \"js/app/client/connection.js\",\n        \"js/app/client/control.js\",\n        \"js/app/client/files.js\",\n        \"js/app/client/job.js\",\n        \"js/app/client/languages.js\",\n        \"js/app/client/printer.js\",\n        \"js/app/client/printerprofiles.js\",\n        \"js/app/client/settings.js\",\n        \"js/app/client/slicing.js\",\n        \"js/app/client/system.js\",\n        \"js/app/client/timelapse.js\",\n        \"js/app/client/users.js\",\n        \"js/app/client/util.js\",\n        \"js/app/client/wizard.js\",\n    ]\n\n    if preferred_stylesheet == \"less\":\n        assets[\"less\"].append(\"less/octoprint.less\")\n    elif preferred_stylesheet == \"css\":\n        assets[\"css\"].append(\"css/octoprint.css\")\n\n    return assets\n\n\n##~~ plugin assets collector\n\n\ndef collect_plugin_assets(preferred_stylesheet=\"css\"):\n    logger = logging.getLogger(__name__ + \".collect_plugin_assets\")\n\n    supported_stylesheets = (\"css\", \"less\")\n    assets = {\n        \"bundled\": {\n            \"js\": DefaultOrderedDict(list),\n            \"clientjs\": DefaultOrderedDict(list),\n            \"css\": DefaultOrderedDict(list),\n            \"less\": DefaultOrderedDict(list),\n        },\n        \"external\": {\n            \"js\": DefaultOrderedDict(list),\n            \"clientjs\": DefaultOrderedDict(list),\n            \"css\": DefaultOrderedDict(list),\n            \"less\": DefaultOrderedDict(list),\n        },\n    }\n\n    asset_plugins = octoprint.plugin.plugin_manager().get_implementations(\n        octoprint.plugin.AssetPlugin\n    )\n    for implementation in asset_plugins:\n        name = implementation._identifier\n        is_bundled = implementation._plugin_info.bundled\n\n        asset_key = \"bundled\" if is_bundled else \"external\"\n\n        try:\n            all_assets = implementation.get_assets()\n            basefolder = implementation.get_asset_folder()\n        except Exception:\n            logger.exception(\n                \"Got an error while trying to collect assets from {}, ignoring assets from the plugin\".format(\n                    name\n                ),\n                extra={\"plugin\": name},\n            )\n            continue\n\n        def asset_exists(category, asset):\n            exists = os.path.exists(os.path.join(basefolder, asset))\n            if not exists:\n                logger.warning(\n                    \"Plugin {} is referring to non existing {} asset {}\".format(\n                        name, category, asset\n                    )\n                )\n            return exists\n\n        if \"js\" in all_assets:\n            for asset in all_assets[\"js\"]:\n                if not asset_exists(\"js\", asset):\n                    continue\n                assets[asset_key][\"js\"][name].append(f\"plugin/{name}/{asset}\")\n\n        if \"clientjs\" in all_assets:\n            for asset in all_assets[\"clientjs\"]:\n                if not asset_exists(\"clientjs\", asset):\n                    continue\n                assets[asset_key][\"clientjs\"][name].append(f\"plugin/{name}/{asset}\")\n\n        if preferred_stylesheet in all_assets:\n            for asset in all_assets[preferred_stylesheet]:\n                if not asset_exists(preferred_stylesheet, asset):\n                    continue\n                assets[asset_key][preferred_stylesheet][name].append(\n                    f\"plugin/{name}/{asset}\"\n                )\n        else:\n            for stylesheet in supported_stylesheets:\n                if stylesheet not in all_assets:\n                    continue\n\n                for asset in all_assets[stylesheet]:\n                    if not asset_exists(stylesheet, asset):\n                        continue\n                    assets[asset_key][stylesheet][name].append(f\"plugin/{name}/{asset}\")\n                break\n\n    return assets\n\n\n##~~ JSON encoding\n\n\nclass OctoPrintJsonEncoder(flask.json.JSONEncoder):\n    def default(self, obj):\n        try:\n            return JsonEncoding.encode(obj)\n        except TypeError:\n            return flask.json.JSONEncoder.default(self, obj)\n\n\n##~~ Session signing\n\n\ndef session_signature(user, session):\n    from octoprint.server import userManager\n\n    key = userManager.signature_key_for_user(user, salt=current_app.config[\"SECRET_KEY\"])\n    return hmac.new(\n        key.encode(\"utf-8\"), session.encode(\"utf-8\"), hashlib.sha512\n    ).hexdigest()\n\n\ndef validate_session_signature(sig, user, session):\n    return hmac.compare_digest(sig, session_signature(user, session))\n", "__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"\n__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"\n__copyright__ = \"Copyright (C) 2014 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n\nimport logging\nimport re\nimport threading\nimport time\n\nimport wrapt\n\nimport octoprint.access.users\nimport octoprint.events\nimport octoprint.plugin\nimport octoprint.printer\nimport octoprint.server\nimport octoprint.timelapse\nimport octoprint.vendor.sockjs.tornado\nimport octoprint.vendor.sockjs.tornado.proto\nimport octoprint.vendor.sockjs.tornado.session\nimport octoprint.vendor.sockjs.tornado.util\nfrom octoprint.access.groups import GroupChangeListener\nfrom octoprint.access.permissions import Permissions\nfrom octoprint.access.users import LoginStatusListener, SessionUser\nfrom octoprint.events import Events\nfrom octoprint.settings import settings\nfrom octoprint.util import RepeatedTimer\nfrom octoprint.util.json import dumps as json_dumps\nfrom octoprint.util.version import get_python_version_string\n\n\nclass ThreadSafeSession(octoprint.vendor.sockjs.tornado.session.Session):\n    def __init__(self, conn, server, session_id, expiry=None):\n        octoprint.vendor.sockjs.tornado.session.Session.__init__(\n            self, conn, server, session_id, expiry=expiry\n        )\n\n    def set_handler(self, handler, start_heartbeat=True):\n        if getattr(handler, \"__orig_send_pack\", None) is None:\n            orig_send_pack = handler.send_pack\n            mutex = threading.RLock()\n\n            def send_pack(*args, **kwargs):\n                with mutex:\n                    return orig_send_pack(*args, **kwargs)\n\n            handler.send_pack = send_pack\n            handler.__orig_send_pack = orig_send_pack\n\n        return octoprint.vendor.sockjs.tornado.session.Session.set_handler(\n            self, handler, start_heartbeat=start_heartbeat\n        )\n\n    def remove_handler(self, handler):\n        result = octoprint.vendor.sockjs.tornado.session.Session.remove_handler(\n            self, handler\n        )\n\n        if getattr(handler, \"__orig_send_pack\", None) is not None:\n            handler.send_pack = handler.__orig_send_pack\n            delattr(handler, \"__orig_send_pack\")\n\n        return result\n\n\nclass JsonEncodingSessionWrapper(wrapt.ObjectProxy):\n    def send_message(self, msg, stats=True, binary=False):\n        self.send_jsonified(\n            json_dumps(octoprint.vendor.sockjs.tornado.util.bytes_to_str(msg)),\n            stats,\n        )\n\n\nclass PrinterStateConnection(\n    octoprint.vendor.sockjs.tornado.SockJSConnection,\n    octoprint.printer.PrinterCallback,\n    LoginStatusListener,\n    GroupChangeListener,\n):\n\n    _event_permissions = {\n        Events.USER_LOGGED_IN: [Permissions.ADMIN],\n        Events.USER_LOGGED_OUT: [Permissions.ADMIN],\n        \"*\": [],\n    }\n\n    _event_payload_processors = {\n        Events.CLIENT_OPENED: [\n            lambda user, payload: payload\n            if user.has_permission(Permissions.ADMIN)\n            else {}\n        ],\n        Events.CLIENT_AUTHED: [\n            lambda user, payload: payload\n            if user.has_permission(Permissions.ADMIN)\n            else {}\n        ],\n        \"*\": [],\n    }\n\n    # TODO: Permissions should be overridable from plugins, this special case stuff here is a hack\n    _emit_permissions = {\n        \"connected\": [],\n        \"reauthRequired\": [],\n        \"plugin\": lambda payload: []\n        if payload.get(\"plugin\") in (\"backup\", \"softwareupdate\")\n        and settings().getBoolean([\"server\", \"firstRun\"])\n        else [Permissions.STATUS],\n        \"*\": [Permissions.STATUS],\n    }\n\n    _unauthed_backlog_max = 100\n\n    def __init__(\n        self,\n        printer,\n        fileManager,\n        analysisQueue,\n        userManager,\n        groupManager,\n        eventManager,\n        pluginManager,\n        connectivityChecker,\n        session,\n    ):\n        if isinstance(session, octoprint.vendor.sockjs.tornado.session.Session):\n            session = JsonEncodingSessionWrapper(session)\n\n        octoprint.vendor.sockjs.tornado.SockJSConnection.__init__(self, session)\n\n        self._logger = logging.getLogger(__name__)\n\n        self._temperatureBacklog = []\n        self._temperatureBacklogMutex = threading.Lock()\n        self._logBacklog = []\n        self._logBacklogMutex = threading.Lock()\n        self._messageBacklog = []\n        self._messageBacklogMutex = threading.Lock()\n\n        self._unauthed_backlog = []\n        self._unauthed_backlog_mutex = threading.RLock()\n\n        self._printer = printer\n        self._fileManager = fileManager\n        self._analysisQueue = analysisQueue\n        self._userManager = userManager\n        self._groupManager = groupManager\n        self._eventManager = eventManager\n        self._pluginManager = pluginManager\n        self._connectivityChecker = connectivityChecker\n\n        self._remoteAddress = None\n        self._user = self._userManager.anonymous_user_factory()\n\n        self._throttle_factor = 1\n        self._last_current = 0\n        self._base_rate_limit = 0.5\n\n        self._held_back_current = None\n        self._held_back_mutex = threading.RLock()\n\n        self._register_hooks = self._pluginManager.get_hooks(\n            \"octoprint.server.sockjs.register\"\n        )\n        self._authed_hooks = self._pluginManager.get_hooks(\n            \"octoprint.server.sockjs.authed\"\n        )\n        self._emit_hooks = self._pluginManager.get_hooks(\"octoprint.server.sockjs.emit\")\n\n        self._registered = False\n        self._authed = False\n        self._initial_data_sent = False\n\n        self._subscriptions_active = False\n        self._subscriptions = {\"state\": False, \"plugins\": [], \"events\": []}\n\n        self._keep_alive = RepeatedTimer(\n            60, self._keep_alive_callback, condition=lambda: self._authed\n        )\n\n    @staticmethod\n    def _get_remote_address(info):\n        forwarded_for = info.headers.get(\"X-Forwarded-For\")\n        if forwarded_for is not None:\n            return forwarded_for.split(\",\")[0]\n        return info.ip\n\n    def _keep_alive_callback(self):\n        if not self._authed:\n            return\n        if not isinstance(self._user, SessionUser):\n            return\n        self._user.touch()\n\n    def __str__(self):\n        if self._remoteAddress:\n            return f\"{self!r} connected to {self._remoteAddress}\"\n        else:\n            return f\"Unconnected {self!r}\"\n\n    def on_open(self, info):\n        self._pluginManager.register_message_receiver(self.on_plugin_message)\n        self._remoteAddress = self._get_remote_address(info)\n        self._logger.info(\"New connection from client: %s\" % self._remoteAddress)\n\n        self._userManager.register_login_status_listener(self)\n        self._groupManager.register_listener(self)\n\n        plugin_signature = lambda impl: \"{}:{}\".format(\n            impl._identifier, impl._plugin_version\n        )\n        template_plugins = list(\n            map(\n                plugin_signature,\n                self._pluginManager.get_implementations(octoprint.plugin.TemplatePlugin),\n            )\n        )\n        asset_plugins = list(\n            map(\n                plugin_signature,\n                self._pluginManager.get_implementations(octoprint.plugin.AssetPlugin),\n            )\n        )\n        ui_plugins = sorted(set(template_plugins + asset_plugins))\n\n        import hashlib\n\n        plugin_hash = hashlib.md5()\n        plugin_hash.update(\",\".join(ui_plugins).encode(\"utf-8\"))\n\n        config_hash = settings().config_hash\n\n        # connected => update the API key, might be necessary if the client was left open while the server restarted\n        self._emit(\n            \"connected\",\n            {\n                \"version\": octoprint.server.VERSION,\n                \"display_version\": octoprint.server.DISPLAY_VERSION,\n                \"branch\": octoprint.server.BRANCH,\n                \"python_version\": get_python_version_string(),\n                \"plugin_hash\": plugin_hash.hexdigest(),\n                \"config_hash\": config_hash,\n                \"debug\": octoprint.server.debug,\n                \"safe_mode\": octoprint.server.safe_mode,\n                \"online\": self._connectivityChecker.online,\n                \"permissions\": [permission.as_dict() for permission in Permissions.all()],\n            },\n        )\n\n        self._eventManager.fire(\n            Events.CLIENT_OPENED, {\"remoteAddress\": self._remoteAddress}\n        )\n        self._register()\n\n    def on_close(self):\n        self._user = self._userManager.anonymous_user_factory()\n        self._groupManager.unregister_listener(self)\n        self._userManager.unregister_login_status_listener(self)\n\n        self._unregister()\n        self._eventManager.fire(\n            Events.CLIENT_CLOSED, {\"remoteAddress\": self._remoteAddress}\n        )\n\n        self._logger.info(\"Client connection closed: %s\" % self._remoteAddress)\n\n        self._on_logout()\n        self._remoteAddress = None\n        self._pluginManager.unregister_message_receiver(self.on_plugin_message)\n\n    def on_message(self, message):\n        try:\n            import json\n\n            message = json.loads(message)\n        except Exception:\n            self._logger.warning(\n                \"Invalid JSON received from client {}, ignoring: {!r}\".format(\n                    self._remoteAddress, message\n                )\n            )\n            return\n\n        if \"auth\" in message:\n            try:\n                parts = message[\"auth\"].split(\":\")\n                if not len(parts) == 2:\n                    raise ValueError()\n            except ValueError:\n                self._logger.warning(\n                    \"Got invalid auth message from client {}, ignoring: {!r}\".format(\n                        self._remoteAddress, message[\"auth\"]\n                    )\n                )\n            else:\n                user_id, user_session = parts\n\n                if self._userManager.validate_user_session(user_id, user_session):\n                    user = self._userManager.find_user(\n                        userid=user_id, session=user_session\n                    )\n                    self._on_login(user)\n                else:\n                    self._logger.warning(\n                        f\"Unknown user/session combo: {user_id}:{user_session}\"\n                    )\n                    self._on_logout()\n\n            self._register()\n\n        elif \"throttle\" in message:\n            try:\n                throttle = int(message[\"throttle\"])\n                if throttle < 1:\n                    raise ValueError()\n            except ValueError:\n                self._logger.warning(\n                    \"Got invalid throttle factor from client {}, ignoring: {!r}\".format(\n                        self._remoteAddress, message[\"throttle\"]\n                    )\n                )\n            else:\n                self._throttle_factor = throttle\n                self._logger.debug(\n                    \"Set throttle factor for client {} to {}\".format(\n                        self._remoteAddress, self._throttle_factor\n                    )\n                )\n\n        elif \"subscribe\" in message:\n            if not self._subscriptions_active:\n                self._subscriptions_active = True\n                self._logger.debug(\"Client makes use of subscriptions\")\n\n            def list_or_boolean(value):\n                if isinstance(value, list):\n                    return value\n                elif isinstance(value, bool):\n                    return [] if not value else None\n                else:\n                    raise ValueError(\"value must be a list or boolean\")\n\n            def regex_or_boolean(value):\n                if isinstance(value, str):\n                    try:\n                        return re.compile(value)\n                    except Exception:\n                        raise ValueError(\"value must be a valid regex\")\n                elif isinstance(value, bool):\n                    return value\n                else:\n                    raise ValueError(\"value must be a string or boolean\")\n\n            try:\n                subscribe = message[\"subscribe\"]\n\n                state = subscribe.get(\"state\", False)\n                if isinstance(state, bool):\n                    if state:\n                        state = {\"logs\": True, \"messages\": False}\n                elif isinstance(state, dict):\n                    logs = regex_or_boolean(state.get(\"logs\", False))\n                    messages = regex_or_boolean(state.get(\"messages\", False))\n                    state = {\n                        \"logs\": logs,\n                        \"messages\": messages,\n                    }\n\n                plugins = list_or_boolean(subscribe.get(\"plugins\", []))\n                events = list_or_boolean(subscribe.get(\"events\", []))\n\n            except ValueError as e:\n                self._logger.warning(\n                    \"Got invalid subscription message from client {}, ignoring: {!r} ({}) \".format(\n                        self._remoteAddress, message[\"subscribe\"], str(e)\n                    )\n                )\n            else:\n                old_state = self._subscriptions[\"state\"]\n                self._subscriptions[\"state\"] = state\n                self._subscriptions[\"plugins\"] = plugins\n                self._subscriptions[\"events\"] = events\n\n                if state and not old_state:\n                    # trigger initial data\n                    self._printer.send_initial_callback(self)\n                elif old_state and not state:\n                    self._initial_data_sent = False\n\n    def on_printer_send_current_data(self, data):\n        if not self._user.has_permission(Permissions.STATUS):\n            return\n\n        if self._subscriptions_active and not self._subscriptions[\"state\"]:\n            return\n\n        if not self._initial_data_sent:\n            self._logger.debug(\"Initial data not yet send, dropping current message\")\n            return\n\n        # make sure we rate limit the updates according to our throttle factor\n        with self._held_back_mutex:\n            if self._held_back_current is not None:\n                self._held_back_current.cancel()\n                self._held_back_current = None\n\n            now = time.time()\n            delta = (\n                self._last_current + self._base_rate_limit * self._throttle_factor - now\n            )\n            if delta > 0:\n                self._held_back_current = threading.Timer(\n                    delta, lambda: self.on_printer_send_current_data(data)\n                )\n                self._held_back_current.start()\n                return\n\n        self._last_current = now\n\n        # add current temperature, log and message backlogs to sent data\n        with self._temperatureBacklogMutex:\n            temperatures = self._temperatureBacklog\n            self._temperatureBacklog = []\n\n        with self._logBacklogMutex:\n            logs = self._filter_logs(self._logBacklog)\n            self._logBacklog = []\n\n        with self._messageBacklogMutex:\n            messages = self._filter_messages(self._messageBacklog)\n            self._messageBacklog = []\n\n        busy_files = [\n            {\"origin\": v[0], \"path\": v[1]} for v in self._fileManager.get_busy_files()\n        ]\n        if (\n            \"job\" in data\n            and data[\"job\"] is not None\n            and \"file\" in data[\"job\"]\n            and \"path\" in data[\"job\"][\"file\"]\n            and \"origin\" in data[\"job\"][\"file\"]\n            and data[\"job\"][\"file\"][\"path\"] is not None\n            and data[\"job\"][\"file\"][\"origin\"] is not None\n            and (self._printer.is_printing() or self._printer.is_paused())\n        ):\n            busy_files.append(\n                {\n                    \"origin\": data[\"job\"][\"file\"][\"origin\"],\n                    \"path\": data[\"job\"][\"file\"][\"path\"],\n                }\n            )\n\n        data.update(\n            {\n                \"serverTime\": time.time(),\n                \"temps\": temperatures,\n                \"logs\": self._filter_logs(logs),\n                \"messages\": messages,\n                \"busyFiles\": busy_files,\n                \"markings\": list(self._printer.get_markings()),\n            }\n        )\n        self._emit(\"current\", payload=data)\n\n    def on_printer_send_initial_data(self, data):\n        self._initial_data_sent = True\n        if self._subscriptions_active and not self._subscriptions[\"state\"]:\n            self._logger.debug(\"Not subscribed to state, dropping history\")\n            return\n\n        data_to_send = dict(data)\n        data_to_send[\"logs\"] = self._filter_logs(data_to_send.get(\"logs\", []))\n        data_to_send[\"messages\"] = self._filter_messages(data_to_send.get(\"messages\", []))\n        data_to_send[\"serverTime\"] = time.time()\n        self._emit(\"history\", payload=data_to_send)\n\n    def _filter_state_subscription(self, sub, values):\n        if not self._subscriptions_active or self._subscriptions[\"state\"][sub] is True:\n            return values\n\n        if self._subscriptions[\"state\"][sub] is False:\n            return []\n\n        return [line for line in values if self._subscriptions[\"state\"][sub].search(line)]\n\n    def _filter_logs(self, logs):\n        return self._filter_state_subscription(\"logs\", logs)\n\n    def _filter_messages(self, messages):\n        return self._filter_state_subscription(\"messages\", messages)\n\n    def sendEvent(self, type, payload=None):\n        permissions = self._event_permissions.get(type, self._event_permissions[\"*\"])\n        permissions = [x(self._user) if callable(x) else x for x in permissions]\n        if not self._user or not all(\n            map(lambda p: self._user.has_permission(p), permissions)\n        ):\n            return\n\n        processors = self._event_payload_processors.get(\n            type, self._event_payload_processors[\"*\"]\n        )\n        for processor in processors:\n            payload = processor(self._user, payload)\n\n        self._emit(\"event\", payload={\"type\": type, \"payload\": payload})\n\n    def sendTimelapseConfig(self, timelapseConfig):\n        self._emit(\"timelapse\", payload=timelapseConfig)\n\n    def sendSlicingProgress(\n        self, slicer, source_location, source_path, dest_location, dest_path, progress\n    ):\n        self._emit(\n            \"slicingProgress\",\n            payload={\n                \"slicer\": slicer,\n                \"source_location\": source_location,\n                \"source_path\": source_path,\n                \"dest_location\": dest_location,\n                \"dest_path\": dest_path,\n                \"progress\": progress,\n            },\n        )\n\n    def sendRenderProgress(self, progress):\n        self._emit(\"renderProgress\", {\"progress\": progress})\n\n    def on_plugin_message(self, plugin, data, permissions=None):\n        if (\n            self._subscriptions_active\n            and self._subscriptions[\"plugins\"] is not None\n            and plugin not in self._subscriptions[\"plugins\"]\n        ):\n            return\n\n        self._emit(\n            \"plugin\", payload={\"plugin\": plugin, \"data\": data}, permissions=permissions\n        )\n\n    def on_printer_add_log(self, data):\n        with self._logBacklogMutex:\n            self._logBacklog.append(data)\n\n    def on_printer_add_message(self, data):\n        with self._messageBacklogMutex:\n            self._messageBacklog.append(data)\n\n    def on_printer_add_temperature(self, data):\n        with self._temperatureBacklogMutex:\n            self._temperatureBacklog.append(data)\n\n    def on_user_logged_out(self, user, stale=False):\n        if (\n            user.get_id() == self._user.get_id()\n            and hasattr(user, \"session\")\n            and hasattr(self._user, \"session\")\n            and user.session == self._user.session\n        ):\n            self._logger.info(f\"User {user.get_id()} logged out, logging out on socket\")\n            self._on_logout()\n\n            if stale:\n                self._sendReauthRequired(\"stale\")\n            else:\n                self._sendReauthRequired(\"logout\")\n\n    def on_user_modified(self, user):\n        if user.get_id() == self._user.get_id():\n            self._sendReauthRequired(\"modified\")\n\n    def on_user_removed(self, userid):\n        if self._user.get_id() == userid:\n            self._logger.info(f\"User {userid} deleted, logging out on socket\")\n            self._on_logout()\n            self._sendReauthRequired(\"removed\")\n\n    def on_group_permissions_changed(self, group, added=None, removed=None):\n        if self._user.is_anonymous and group == self._groupManager.guest_group:\n            self._sendReauthRequired(\"modified\")\n\n    def on_group_subgroups_changed(self, group, added=None, removed=None):\n        if self._user.is_anonymous and group == self._groupManager.guest_group:\n            self._sendReauthRequired(\"modified\")\n\n    def _onEvent(self, event, payload):\n        if (\n            self._subscriptions_active\n            and self._subscriptions[\"events\"] is not None\n            and event not in self._subscriptions[\"events\"]\n        ):\n            return\n\n        self.sendEvent(event, payload)\n\n    def _register(self):\n        \"\"\"Register this socket with the system if STATUS permission is available.\"\"\"\n\n        proceed = True\n        for name, hook in self._register_hooks.items():\n            try:\n                proceed = proceed and hook(self, self._user)\n            except Exception:\n                self._logger.exception(\n                    f\"Error processing register hook handler for plugin {name}\",\n                    extra={\"plugin\": name},\n                )\n\n        if not proceed:\n            return\n\n        if self._registered:\n            return\n\n        if not self._user.has_permission(Permissions.STATUS):\n            return\n\n        # printer\n        self._printer.register_callback(self)\n        self._printer.send_initial_callback(self)\n\n        # files\n        self._fileManager.register_slicingprogress_callback(self)\n\n        # events\n        for event in octoprint.events.all_events():\n            self._eventManager.subscribe(event, self._onEvent)\n\n        # timelapse\n        octoprint.timelapse.register_callback(self)\n        octoprint.timelapse.notify_callback(self, timelapse=octoprint.timelapse.current)\n        if octoprint.timelapse.current_render_job is not None:\n            # This is a horrible hack for now to allow displaying a notification that a render job is still\n            # active in the backend on a fresh connect of a client. This needs to be substituted with a proper\n            # job management for timelapse rendering, analysis stuff etc that also gets cancelled when prints\n            # start and so on.\n            #\n            # For now this is the easiest way though to at least inform the user that a timelapse is still ongoing.\n            #\n            # TODO remove when central job management becomes available and takes care of this for us\n            self.sendEvent(\n                Events.MOVIE_RENDERING, payload=octoprint.timelapse.current_render_job\n            )\n        self._registered = True\n\n    def _unregister(self):\n        \"\"\"Unregister this socket from the system\"\"\"\n\n        self._printer.unregister_callback(self)\n        self._fileManager.unregister_slicingprogress_callback(self)\n        octoprint.timelapse.unregister_callback(self)\n        for event in octoprint.events.all_events():\n            self._eventManager.unsubscribe(event, self._onEvent)\n\n    def _reregister(self):\n        \"\"\"Unregister and register again\"\"\"\n        self._unregister()\n        self._register()\n\n    def _sendReauthRequired(self, reason):\n        self._emit(\"reauthRequired\", payload={\"reason\": reason})\n\n    def _emit(self, type, payload=None, permissions=None):\n        proceed = True\n        for name, hook in self._emit_hooks.items():\n            try:\n                proceed = proceed and hook(self, self._user, type, payload)\n            except Exception:\n                self._logger.exception(\n                    f\"Error processing emit hook handler from plugin {name}\",\n                    extra={\"plugin\": name},\n                )\n\n        if not proceed:\n            return\n\n        if permissions is None:\n            permissions = self._emit_permissions.get(type, self._emit_permissions[\"*\"])\n            permissions = (\n                permissions(payload)\n                if callable(permissions)\n                else [x for x in permissions]\n            )\n\n        if not self._user or not all(\n            map(lambda p: self._user.has_permission(p), permissions)\n        ):\n            if not self._authed:\n                with self._unauthed_backlog_mutex:\n                    if len(self._unauthed_backlog) < self._unauthed_backlog_max:\n                        self._unauthed_backlog.append((type, payload))\n                        self._logger.debug(\n                            \"Socket message held back until permissions cleared, added to backlog: {}\".format(\n                                type\n                            )\n                        )\n                    else:\n                        self._logger.debug(\n                            \"Socket message held back, but backlog full. Throwing message away: {}\".format(\n                                type\n                            )\n                        )\n            return\n\n        self._do_emit(type, payload)\n\n    def _do_emit(self, type, payload):\n        try:\n            self.send({type: payload})\n        except Exception as e:\n            if self._logger.isEnabledFor(logging.DEBUG):\n                self._logger.exception(\n                    f\"Could not send message to client {self._remoteAddress}\"\n                )\n            else:\n                self._logger.warning(\n                    \"Could not send message to client {}: {}\".format(\n                        self._remoteAddress, e\n                    )\n                )\n\n    def _on_login(self, user):\n        self._user = user\n        self._logger.info(\n            \"User {} logged in on the socket from client {}\".format(\n                user.get_name(), self._remoteAddress\n            )\n        )\n        self._authed = True\n\n        self._keep_alive.start()\n\n        for name, hook in self._authed_hooks.items():\n            try:\n                hook(self, self._user)\n            except Exception:\n                self._logger.exception(\n                    f\"Error processing authed hook handler for plugin {name}\",\n                    extra={\"plugin\": name},\n                )\n\n        # if we have a backlog from being unauthed, process that now\n        with self._unauthed_backlog_mutex:\n            backlog = self._unauthed_backlog\n            self._unauthed_backlog = []\n\n        if len(backlog):\n            self._logger.debug(\n                \"Sending {} messages on the socket that were held back\".format(\n                    len(backlog)\n                )\n            )\n            for message, payload in backlog:\n                self._do_emit(message, payload)\n\n        # trigger ClientAuthed event\n        octoprint.events.eventManager().fire(\n            octoprint.events.Events.CLIENT_AUTHED,\n            payload={\"username\": user.get_name(), \"remoteAddress\": self._remoteAddress},\n        )\n\n    def _on_logout(self):\n        self._user = self._userManager.anonymous_user_factory()\n        self._authed = False\n\n        for name, hook in self._authed_hooks.items():\n            try:\n                hook(self, self._user)\n            except Exception:\n                self._logger.exception(\n                    f\"Error processing authed hook handler for plugin {name}\",\n                    extra={\"plugin\": name},\n                )\n", "$(function () {\n    function UserSettingsViewModel(parameters) {\n        var self = this;\n\n        self.loginState = parameters[0];\n        self.access = parameters[1];\n\n        self.users = self.access.users;\n\n        self.userSettingsDialog = undefined;\n\n        var auto_locale = {\n            language: \"_default\",\n            display: gettext(\"Site default\"),\n            english: undefined\n        };\n        self.locales = ko.observableArray(\n            [auto_locale].concat(\n                _.sortBy(_.values(AVAILABLE_LOCALES), function (n) {\n                    return n.display;\n                })\n            )\n        );\n        self.locale_languages = _.keys(AVAILABLE_LOCALES);\n\n        self.access_password = ko.observable(undefined);\n        self.access_repeatedPassword = ko.observable(undefined);\n        self.access_currentPassword = ko.observable(undefined);\n        self.access_currentPasswordMismatch = ko.observable(false);\n        self.access_apikey = ko.observable(undefined);\n        self.interface_language = ko.observable(undefined);\n\n        self.currentUser = ko.observable(undefined);\n        self.currentUser.subscribe(function (newUser) {\n            self.access_password(undefined);\n            self.access_repeatedPassword(undefined);\n            self.access_currentPassword(undefined);\n            self.access_currentPasswordMismatch(false);\n            self.access_apikey(undefined);\n            self.interface_language(\"_default\");\n\n            if (newUser !== undefined) {\n                self.access_apikey(newUser.apikey);\n                if (\n                    newUser.settings.hasOwnProperty(\"interface\") &&\n                    newUser.settings.interface.hasOwnProperty(\"language\")\n                ) {\n                    self.interface_language(newUser.settings.interface.language);\n                }\n            }\n        });\n        self.access_currentPassword.subscribe(function () {\n            self.access_currentPasswordMismatch(false);\n        });\n\n        self.passwordMismatch = ko.pureComputed(function () {\n            return self.access_password() !== self.access_repeatedPassword();\n        });\n\n        self.show = function (user) {\n            if (!CONFIG_ACCESS_CONTROL) return;\n\n            if (user === undefined) {\n                user = self.loginState.currentUser();\n            }\n\n            var process = function (user) {\n                self.currentUser(user);\n                self.userSettingsDialog.modal(\"show\");\n            };\n\n            // make sure we have the current user data, see #2534\n            OctoPrint.access.users\n                .get(user.name)\n                .done(function (data) {\n                    process(data);\n                })\n                .fail(function () {\n                    log.warn(\n                        \"Could not fetch current user data, proceeding with client side data copy\"\n                    );\n                    process(user);\n                });\n        };\n\n        self.save = function () {\n            if (!CONFIG_ACCESS_CONTROL) return;\n\n            self.userSettingsDialog.trigger(\"beforeSave\");\n\n            function saveSettings() {\n                var settings = {\n                    interface: {\n                        language: self.interface_language()\n                    }\n                };\n                self.updateSettings(self.currentUser().name, settings).done(function () {\n                    // close dialog\n                    self.currentUser(undefined);\n                    self.userSettingsDialog.modal(\"hide\");\n                    self.loginState.reloadUser();\n                });\n            }\n\n            if (self.access_password() && !self.passwordMismatch()) {\n                self.users\n                    .updatePassword(\n                        self.currentUser().name,\n                        self.access_password(),\n                        self.access_currentPassword()\n                    )\n                    .done(function () {\n                        saveSettings();\n                    })\n                    .fail(function (xhr) {\n                        if (xhr.status === 403) {\n                            self.access_currentPasswordMismatch(true);\n                        }\n                    });\n            } else {\n                saveSettings();\n            }\n        };\n\n        self.copyApikey = function () {\n            copyToClipboard(self.access_apikey());\n        };\n\n        self.generateApikey = function () {\n            if (!CONFIG_ACCESS_CONTROL) return;\n\n            var generate = function () {\n                self.users\n                    .generateApikey(self.currentUser().name)\n                    .done(function (response) {\n                        self.access_apikey(response.apikey);\n                    });\n            };\n\n            if (self.access_apikey()) {\n                showConfirmationDialog(\n                    gettext(\n                        \"This will generate a new API Key. The old API Key will cease to function immediately.\"\n                    ),\n                    generate\n                );\n            } else {\n                generate();\n            }\n        };\n\n        self.deleteApikey = function () {\n            if (!CONFIG_ACCESS_CONTROL) return;\n            if (!self.access_apikey()) return;\n\n            showConfirmationDialog(\n                gettext(\n                    \"This will delete the API Key. It will cease to to function immediately.\"\n                ),\n                function () {\n                    self.users.deleteApikey(self.currentUser().name).done(function () {\n                        self.access_apikey(undefined);\n                    });\n                }\n            );\n        };\n\n        self.updateSettings = function (username, settings) {\n            return OctoPrint.access.users.saveSettings(username, settings);\n        };\n\n        self.saveEnabled = function () {\n            return !self.passwordMismatch();\n        };\n\n        self.onStartup = function () {\n            self.userSettingsDialog = $(\"#usersettings_dialog\");\n        };\n\n        self.onAllBound = function (allViewModels) {\n            self.userSettingsDialog.on(\"show\", function () {\n                callViewModels(allViewModels, \"onUserSettingsShown\");\n            });\n            self.userSettingsDialog.on(\"hidden\", function () {\n                callViewModels(allViewModels, \"onUserSettingsHidden\");\n            });\n            self.userSettingsDialog.on(\"beforeSave\", function () {\n                callViewModels(allViewModels, \"onUserSettingsBeforeSave\");\n            });\n        };\n    }\n\n    OCTOPRINT_VIEWMODELS.push({\n        construct: UserSettingsViewModel,\n        dependencies: [\"loginStateViewModel\", \"accessViewModel\"],\n        elements: [\"#usersettings_dialog\"]\n    });\n});\n", "<form class=\"form-horizontal\" onsubmit=\"return false;\">\n    <fieldset>\n        <legend>{{ _('Password') }}</legend>\n        <p>\n            {{ _('If you do not wish to change your password, just leave the following fields empty.') }}\n        </p>\n        <div class=\"control-group\" data-bind=\"css: {error: access_currentPasswordMismatch()}\">\n            <label class=\"control-label\" for=\"userSettings-access_currentPassword\">{{ _('Current Password') }}</label>\n            <div class=\"controls\">\n                <input type=\"password\" class=\"input-block-level\" id=\"userSettings-access_currentPassword\" data-bind=\"value: access_currentPassword, valueUpdate: 'afterkeydown'\" required>\n                <span class=\"help-inline\" data-bind=\"visible: access_currentPasswordMismatch()\">{{ _('Passwords do not match') }}</span>\n            </div>\n        </div>\n        <div class=\"control-group\">\n            <label class=\"control-label\" for=\"userSettings-access_password\">{{ _('New Password') }}</label>\n            <div class=\"controls\">\n                <input type=\"password\" class=\"input-block-level\" id=\"userSettings-access_password\" data-bind=\"value: access_password\" required>\n            </div>\n        </div>\n        <div class=\"control-group\" data-bind=\"css: {error: passwordMismatch()}\">\n            <label class=\"control-label\" for=\"userSettings-access_repeatedPassword\">{{ _('Repeat Password') }}</label>\n            <div class=\"controls\">\n                <input type=\"password\" class=\"input-block-level\" id=\"userSettings-access_repeatedPassword\" data-bind=\"value: access_repeatedPassword, valueUpdate: 'afterkeydown'\" required>\n                <span class=\"help-inline\" data-bind=\"visible: passwordMismatch()\">{{ _('Passwords do not match') }}</span>\n            </div>\n        </div>\n        <p>{% trans %}\n            Please note that you will be <strong>logged out immediately</strong> after changing your password and asked to login again.\n        {% endtrans %}</p>\n    </fieldset>\n    <fieldset>\n        <legend>{{ _('API Key') }}</legend>\n        <div class=\"control-group\">\n            <label class=\"control-label\" for=\"userSettings-access_apikey\">{{ _('Current API Key') }}</label>\n            <div class=\"controls\">\n                <div class=\"input-append input-block-level\">\n                    <input type=\"text\" readonly=\"readonly\" id=\"userSettings-access_apikey\" data-bind=\"value: access_apikey, attr: {placeholder: '{{ _('N/A')|esq }}'}\">\n                    <a class=\"btn add-on\" title=\"Copy API Key to clipboard\" data-bind=\"click: copyApikey, css: {'disabled': !access_apikey()}\"><i class=\"fas fa-copy\"></i></a>\n                    <a class=\"btn add-on\" title=\"Generate new API Key\" data-bind=\"click: generateApikey\"><i class=\"fas fa-sync\"></i></a>\n                    <a class=\"btn btn-danger add-on\" title=\"Delete API Key\" data-bind=\"click: deleteApikey, css: {'disabled': !access_apikey()}\"><i class=\"far fa-trash-alt\"></i></a>\n                </div>\n                <span class=\"help-block\">{{ _('Please note that changes to the API key are applied immediately, without having to \"Confirm\" first.') }}</span>\n            </div>\n        </div>\n        <div class=\"control-group\" data-bind=\"visible: access_apikey\">\n            <label class=\"control-label\">{{ _('QR Code') }}</label>\n            <div class=\"controls\">\n                <div data-bind=\"qrcode: {text: access_apikey, size: 150}\"></div>\n            </div>\n        </div>\n    </fieldset>\n</form>\n", "\"\"\"\nUnit tests for ``octoprint.server.util.flask``.\n\"\"\"\n\n__author__ = \"Gina H\u00e4u\u00dfge <osd@foosel.net>\"\n__license__ = \"GNU Affero General Public License http://www.gnu.org/licenses/agpl.html\"\n__copyright__ = \"Copyright (C) 2016 The OctoPrint Project - Released under terms of the AGPLv3 License\"\n\n\nimport unittest\nfrom unittest import mock\n\nimport flask\nfrom ddt import data, ddt, unpack\n\nfrom octoprint.server.util.flask import (\n    OctoPrintFlaskRequest,\n    OctoPrintFlaskResponse,\n    ReverseProxiedEnvironment,\n)\n\nstandard_environ = {\n    \"HTTP_HOST\": \"localhost:5000\",\n    \"SERVER_NAME\": \"localhost\",\n    \"SERVER_PORT\": \"5000\",\n    \"SCRIPT_NAME\": \"\",\n    \"PATH_INFO\": \"/\",\n    \"wsgi.url_scheme\": \"http\",\n}\n\n\n@ddt\nclass ReverseProxiedEnvironmentTest(unittest.TestCase):\n    @data(\n        # defaults\n        ({}, {}),\n        # prefix set, path info not prefixed\n        (\n            {\"HTTP_X_SCRIPT_NAME\": \"/octoprint\", \"PATH_INFO\": \"/static/online.gif\"},\n            {\"SCRIPT_NAME\": \"/octoprint\"},\n        ),\n        # prefix set, path info prefixed\n        (\n            {\n                \"HTTP_X_SCRIPT_NAME\": \"/octoprint\",\n                \"PATH_INFO\": \"/octoprint/static/online.gif\",\n            },\n            {\"SCRIPT_NAME\": \"/octoprint\", \"PATH_INFO\": \"/static/online.gif\"},\n        ),\n        # host set\n        (\n            {\"HTTP_X_FORWARDED_HOST\": \"example.com\"},\n            {\n                \"HTTP_HOST\": \"example.com\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"80\",\n            },\n        ),\n        # host set with port\n        (\n            {\"HTTP_X_FORWARDED_HOST\": \"example.com:1234\"},\n            {\n                \"HTTP_HOST\": \"example.com:1234\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"1234\",\n            },\n        ),\n        # host and scheme set\n        (\n            {\"HTTP_X_FORWARDED_HOST\": \"example.com\", \"HTTP_X_FORWARDED_PROTO\": \"https\"},\n            {\n                \"HTTP_HOST\": \"example.com\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"443\",\n                \"wsgi.url_scheme\": \"https\",\n            },\n        ),\n        # host and scheme 2 set\n        (\n            {\"HTTP_X_FORWARDED_HOST\": \"example.com\", \"HTTP_X_SCHEME\": \"https\"},\n            {\n                \"HTTP_HOST\": \"example.com\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"443\",\n                \"wsgi.url_scheme\": \"https\",\n            },\n        ),\n        # host, server and port headers set -> only host wins\n        (\n            {\n                \"HTTP_X_FORWARDED_HOST\": \"example.com\",\n                \"HTTP_X_FORWARDED_SERVER\": \"example2.com\",\n                \"HTTP_X_FORWARDED_PORT\": \"444\",\n                \"HTTP_X_FORWARDED_PROTO\": \"https\",\n            },\n            {\n                \"HTTP_HOST\": \"example.com\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"443\",\n                \"wsgi.url_scheme\": \"https\",\n            },\n        ),\n        # host set, server and port differ -> updated, standard port\n        (\n            {\n                \"HTTP_HOST\": \"example.com\",\n                \"wsgi.url_scheme\": \"https\",\n                \"SERVER_NAME\": \"localhost\",\n                \"SERVER_PORT\": \"80\",\n            },\n            {\n                \"HTTP_HOST\": \"example.com\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"443\",\n            },\n        ),\n        # host set, server and port differ -> updated, non standard port\n        (\n            {\n                \"HTTP_HOST\": \"example.com:444\",\n                \"wsgi.url_scheme\": \"https\",\n                \"SERVER_NAME\": \"localhost\",\n                \"SERVER_PORT\": \"80\",\n            },\n            {\n                \"HTTP_HOST\": \"example.com:444\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"444\",\n            },\n        ),\n        # multiple scheme entries -> only use first one\n        (\n            {\n                \"HTTP_X_FORWARDED_PROTO\": \"https,http\",\n            },\n            {\"wsgi.url_scheme\": \"https\"},\n        ),\n        # host = none (should never happen but you never know) -> server & port used for reconstruction\n        (\n            {\n                \"HTTP_HOST\": None,\n                \"HTTP_X_FORWARDED_SERVER\": \"example.com\",\n                \"HTTP_X_FORWARDED_PORT\": \"80\",\n            },\n            {\n                \"HTTP_HOST\": \"example.com\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"80\",\n            },\n        ),\n        # host = none, default port -> server & port used for reconstruction (ipv4)\n        (\n            {\"HTTP_HOST\": None, \"SERVER_NAME\": \"127.0.0.1\", \"SERVER_PORT\": \"80\"},\n            {\"HTTP_HOST\": \"127.0.0.1\", \"SERVER_NAME\": \"127.0.0.1\", \"SERVER_PORT\": \"80\"},\n        ),\n        # host = none, non standard port -> server & port used for reconstruction (ipv4)\n        (\n            {\"HTTP_HOST\": None, \"SERVER_NAME\": \"127.0.0.1\", \"SERVER_PORT\": \"444\"},\n            {\n                \"HTTP_HOST\": \"127.0.0.1:444\",\n                \"SERVER_NAME\": \"127.0.0.1\",\n                \"SERVER_PORT\": \"444\",\n            },\n        ),\n        # host = none, default port -> server & port used for reconstruction (ipv6)\n        (\n            {\"HTTP_HOST\": None, \"SERVER_NAME\": \"fec1::1\", \"SERVER_PORT\": \"80\"},\n            {\"HTTP_HOST\": \"fec1::1\", \"SERVER_NAME\": \"fec1::1\", \"SERVER_PORT\": \"80\"},\n        ),\n        # host = none, non standard port -> server & port used for reconstruction (ipv6)\n        (\n            {\"HTTP_HOST\": None, \"SERVER_NAME\": \"fec1::1\", \"SERVER_PORT\": \"444\"},\n            {\n                \"HTTP_HOST\": \"[fec1::1]:444\",\n                \"SERVER_NAME\": \"fec1::1\",\n                \"SERVER_PORT\": \"444\",\n            },\n        ),\n        # host set, server and port not, default port -> server & port derived from host (ipv4)\n        (\n            {\"HTTP_HOST\": \"127.0.0.1\", \"SERVER_NAME\": None, \"SERVER_PORT\": None},\n            {\"HTTP_HOST\": \"127.0.0.1\", \"SERVER_NAME\": \"127.0.0.1\", \"SERVER_PORT\": \"80\"},\n        ),\n        # host set, server and port not, non standard port -> server & port derived from host (ipv4)\n        (\n            {\"HTTP_HOST\": \"127.0.0.1:444\", \"SERVER_NAME\": None, \"SERVER_PORT\": None},\n            {\n                \"HTTP_HOST\": \"127.0.0.1:444\",\n                \"SERVER_NAME\": \"127.0.0.1\",\n                \"SERVER_PORT\": \"444\",\n            },\n        ),\n        # host set, server and port not, default port -> server & port derived from host (ipv6)\n        (\n            {\"HTTP_HOST\": \"fec1::1\", \"SERVER_NAME\": None, \"SERVER_PORT\": None},\n            {\"HTTP_HOST\": \"fec1::1\", \"SERVER_NAME\": \"fec1::1\", \"SERVER_PORT\": \"80\"},\n        ),\n        # host set, server and port not, non standard port -> server & port derived from host (ipv6)\n        (\n            {\"HTTP_HOST\": \"[fec1::1]:444\", \"SERVER_NAME\": None, \"SERVER_PORT\": None},\n            {\n                \"HTTP_HOST\": \"[fec1::1]:444\",\n                \"SERVER_NAME\": \"fec1::1\",\n                \"SERVER_PORT\": \"444\",\n            },\n        ),\n    )\n    @unpack\n    def test_stock(self, environ, expected):\n        reverse_proxied = ReverseProxiedEnvironment()\n\n        merged_environ = dict(standard_environ)\n        merged_environ.update(environ)\n\n        actual = reverse_proxied(merged_environ)\n\n        merged_expected = dict(standard_environ)\n        merged_expected.update(environ)\n        merged_expected.update(expected)\n\n        self.assertDictEqual(merged_expected, actual)\n\n    @data(\n        # server and port headers set -> host derived with port\n        (\n            {\n                \"SERVER_NAME\": \"example2.com\",\n                \"SERVER_PORT\": \"444\",\n                \"HTTP_X_FORWARDED_PROTO\": \"https\",\n            },\n            {\n                \"HTTP_HOST\": \"example2.com:444\",\n                \"SERVER_NAME\": \"example2.com\",\n                \"SERVER_PORT\": \"444\",\n                \"wsgi.url_scheme\": \"https\",\n            },\n        ),\n        # server and port headers set, standard port -> host derived, no port\n        (\n            {\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"80\",\n            },\n            {\n                \"HTTP_HOST\": \"example.com\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"80\",\n            },\n        ),\n        # server and port forwarded headers set -> host derived with port\n        (\n            {\n                \"HTTP_X_FORWARDED_SERVER\": \"example2.com\",\n                \"HTTP_X_FORWARDED_PORT\": \"444\",\n                \"HTTP_X_FORWARDED_PROTO\": \"https\",\n            },\n            {\n                \"HTTP_HOST\": \"example2.com:444\",\n                \"SERVER_NAME\": \"example2.com\",\n                \"SERVER_PORT\": \"444\",\n                \"wsgi.url_scheme\": \"https\",\n            },\n        ),\n        # server and port forwarded headers set, standard port -> host derived, no port\n        (\n            {\n                \"HTTP_X_FORWARDED_SERVER\": \"example.com\",\n                \"HTTP_X_FORWARDED_PORT\": \"80\",\n            },\n            {\n                \"HTTP_HOST\": \"example.com\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"80\",\n            },\n        ),\n    )\n    @unpack\n    def test_nohost(self, environ, expected):\n        reverse_proxied = ReverseProxiedEnvironment()\n\n        merged_environ = dict(standard_environ)\n        merged_environ.update(environ)\n        del merged_environ[\"HTTP_HOST\"]\n\n        actual = reverse_proxied(merged_environ)\n\n        merged_expected = dict(standard_environ)\n        merged_expected.update(environ)\n        merged_expected.update(expected)\n\n        self.assertDictEqual(merged_expected, actual)\n\n    @data(\n        # prefix overridden\n        (\n            {\"prefix\": \"fallback_prefix\"},\n            {},\n            {\n                \"SCRIPT_NAME\": \"fallback_prefix\",\n            },\n        ),\n        # scheme overridden\n        ({\"scheme\": \"https\"}, {}, {\"wsgi.url_scheme\": \"https\"}),\n        # host overridden, default port\n        (\n            {\"host\": \"example.com\"},\n            {},\n            {\n                \"HTTP_HOST\": \"example.com\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"80\",\n            },\n        ),\n        # host overridden, included port\n        (\n            {\"host\": \"example.com:81\"},\n            {},\n            {\n                \"HTTP_HOST\": \"example.com:81\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"81\",\n            },\n        ),\n        # prefix not really overridden, forwarded headers take precedence\n        ({\"prefix\": \"/octoprint\"}, {\"HTTP_X_SCRIPT_NAME\": \"\"}, {}),\n        # scheme not really overridden, forwarded headers take precedence\n        ({\"scheme\": \"https\"}, {\"HTTP_X_FORWARDED_PROTO\": \"http\"}, {}),\n        # scheme 2 not really overridden, forwarded headers take precedence\n        ({\"scheme\": \"https\"}, {\"HTTP_X_SCHEME\": \"http\"}, {}),\n        # host not really overridden, forwarded headers take precedence\n        ({\"host\": \"example.com:444\"}, {\"HTTP_X_FORWARDED_HOST\": \"localhost:5000\"}, {}),\n        # server not really overridden, forwarded headers take precedence\n        ({\"server\": \"example.com\"}, {\"HTTP_X_FORWARDED_SERVER\": \"localhost\"}, {}),\n        # port not really overridden, forwarded headers take precedence\n        ({\"port\": \"444\"}, {\"HTTP_X_FORWARDED_PORT\": \"5000\"}, {}),\n        # server and port not really overridden, Host header wins\n        ({\"server\": \"example.com\", \"port\": \"80\"}, {}, {}),\n    )\n    @unpack\n    def test_fallbacks(self, fallbacks, environ, expected):\n        reverse_proxied = ReverseProxiedEnvironment(**fallbacks)\n\n        merged_environ = dict(standard_environ)\n        merged_environ.update(environ)\n\n        actual = reverse_proxied(merged_environ)\n\n        merged_expected = dict(standard_environ)\n        merged_expected.update(environ)\n        merged_expected.update(expected)\n\n        self.assertDictEqual(merged_expected, actual)\n\n    @data(\n        # server overridden\n        (\n            {\"server\": \"example.com\"},\n            {},\n            {\n                \"HTTP_HOST\": \"example.com:5000\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"5000\",\n            },\n        ),\n        # port overridden, standard port\n        ({\"port\": \"80\"}, {}, {\"HTTP_HOST\": \"localhost\", \"SERVER_PORT\": \"80\"}),\n        # port overridden, non standard port\n        ({\"port\": \"81\"}, {}, {\"HTTP_HOST\": \"localhost:81\", \"SERVER_PORT\": \"81\"}),\n        # server and port overridden, default port\n        (\n            {\"server\": \"example.com\", \"port\": \"80\"},\n            {},\n            {\n                \"HTTP_HOST\": \"example.com\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"80\",\n            },\n        ),\n        # server and port overridden, non default port\n        (\n            {\"server\": \"example.com\", \"port\": \"81\"},\n            {},\n            {\n                \"HTTP_HOST\": \"example.com:81\",\n                \"SERVER_NAME\": \"example.com\",\n                \"SERVER_PORT\": \"81\",\n            },\n        ),\n    )\n    @unpack\n    def test_fallbacks_nohost(self, fallbacks, environ, expected):\n        reverse_proxied = ReverseProxiedEnvironment(**fallbacks)\n\n        merged_environ = dict(standard_environ)\n        merged_environ.update(environ)\n        del merged_environ[\"HTTP_HOST\"]\n\n        actual = reverse_proxied(merged_environ)\n\n        merged_expected = dict(standard_environ)\n        merged_expected.update(environ)\n        merged_expected.update(expected)\n\n        self.assertDictEqual(merged_expected, actual)\n\n    def test_header_config_ok(self):\n        result = ReverseProxiedEnvironment.to_header_candidates(\n            [\"prefix-header1\", \"prefix-header2\"]\n        )\n        self.assertSetEqual(set(result), {\"HTTP_PREFIX_HEADER1\", \"HTTP_PREFIX_HEADER2\"})\n\n    def test_header_config_string(self):\n        result = ReverseProxiedEnvironment.to_header_candidates(\"prefix-header\")\n        self.assertSetEqual(set(result), {\"HTTP_PREFIX_HEADER\"})\n\n    def test_header_config_none(self):\n        result = ReverseProxiedEnvironment.to_header_candidates(None)\n        self.assertEqual(result, [])\n\n\n##~~\n\n\nclass OctoPrintFlaskRequestTest(unittest.TestCase):\n    def setUp(self):\n        self.orig_environment_wrapper = OctoPrintFlaskRequest.environment_wrapper\n\n        self.app = flask.Flask(\"testapp\")\n        self.app.config[\"SECRET_KEY\"] = \"secret\"\n\n    def tearDown(self):\n        OctoPrintFlaskRequest.environment_wrapper = staticmethod(\n            self.orig_environment_wrapper\n        )\n\n    def test_environment_wrapper(self):\n        def environment_wrapper(environ):\n            environ.update({\"TEST\": \"yes\"})\n            return environ\n\n        OctoPrintFlaskRequest.environment_wrapper = staticmethod(environment_wrapper)\n        request = OctoPrintFlaskRequest(standard_environ)\n\n        self.assertTrue(\"TEST\" in request.environ)\n\n    def test_server_name(self):\n        request = OctoPrintFlaskRequest(standard_environ)\n        self.assertEqual(\"localhost\", request.server_name)\n\n    def test_server_port(self):\n        request = OctoPrintFlaskRequest(standard_environ)\n        self.assertEqual(\"5000\", request.server_port)\n\n    def test_cookie_suffix(self):\n        request = OctoPrintFlaskRequest(standard_environ)\n        self.assertEqual(\"_P5000\", request.cookie_suffix)\n\n    def test_cookie_suffix_with_root(self):\n        script_root_environ = dict(standard_environ)\n        script_root_environ[\"SCRIPT_NAME\"] = \"/path/to/octoprint\"\n\n        request = OctoPrintFlaskRequest(script_root_environ)\n        self.assertEqual(\"_P5000_R|path|to|octoprint\", request.cookie_suffix)\n\n    def test_cookies(self):\n        environ = dict(standard_environ)\n        environ[\"HTTP_COOKIE\"] = (\n            \"postfixed_P5000=postfixed_value; \"\n            \"postfixed_wrong_P5001=postfixed_wrong_value; \"\n            \"unpostfixed=unpostfixed_value; \"\n            \"both_P5000=both_postfixed_value; \"\n            \"both=both_unpostfixed_value;\"\n        )\n\n        request = OctoPrintFlaskRequest(environ)\n\n        with self.app.app_context():\n            cookies = request.cookies\n        self.assertDictEqual(\n            {\n                \"postfixed\": \"postfixed_value\",\n                \"postfixed_wrong_P5001\": \"postfixed_wrong_value\",\n                \"unpostfixed\": \"unpostfixed_value\",\n                \"both\": \"both_postfixed_value\",\n            },\n            cookies,\n        )\n\n\n##~~\n\n\n@ddt\nclass OctoPrintFlaskResponseTest(unittest.TestCase):\n    def setUp(self):\n        # mock settings\n        self.settings_patcher = mock.patch(\"octoprint.settings.settings\")\n        self.settings_getter = self.settings_patcher.start()\n\n        self.settings = mock.MagicMock()\n        self.settings_getter.return_value = self.settings\n\n        self.app = flask.Flask(\"testapp\")\n        self.app.config[\"SECRET_KEY\"] = \"secret\"\n\n    def tearDown(self):\n        self.settings_patcher.stop()\n\n    @data(\n        [None, None, False, None, None],\n        [None, None, False, \"none\", \"None\"],\n        [None, None, False, \"lax\", \"lax\"],\n        [None, None, False, \"StRiCt\", \"strict\"],\n        [None, None, False, \"INVALID\", None],\n        [None, None, True, None, None],\n        [\"/subfolder/\", None, False, None, None],\n        [None, \"/some/other/script/root\", False, None, None],\n        [\"/subfolder/\", \"/some/other/script/root\", False, None, None],\n    )\n    @unpack\n    def test_cookie_set_and_delete(\n        self, path, scriptroot, secure, samesite, expected_samesite\n    ):\n        environ = dict(standard_environ)\n\n        expected_suffix = \"_P5000\"\n        if scriptroot is not None:\n            environ.update({\"SCRIPT_NAME\": scriptroot})\n            expected_suffix += \"_R\" + scriptroot.replace(\"/\", \"|\")\n\n        request = OctoPrintFlaskRequest(environ)\n\n        if path:\n            expected_path_set = expected_path_delete = path\n        else:\n            expected_path_set = expected_path_delete = \"/\"\n        if scriptroot:\n            expected_path_set = scriptroot + expected_path_set\n\n        if path is not None:\n            kwargs = {\"path\": path}\n        else:\n            kwargs = {}\n\n        with mock.patch(\"flask.request\", new=request):\n            with mock.patch(\"octoprint.server.util.flask.settings\") as settings_mock:\n                settings = mock.MagicMock()\n                settings.getBoolean.return_value = secure\n                settings.get.return_value = samesite\n                settings_mock.return_value = settings\n\n                response = OctoPrintFlaskResponse()\n\n                # test set_cookie\n                with mock.patch(\"flask.Response.set_cookie\") as set_cookie_mock:\n                    with self.app.app_context():\n                        response.set_cookie(\"some_key\", \"some_value\", **kwargs)\n\n                    # set_cookie should have key and path values adjusted\n                    set_cookie_mock.assert_called_once_with(\n                        response,\n                        \"some_key\" + expected_suffix,\n                        value=\"some_value\",\n                        path=expected_path_set,\n                        secure=secure,\n                        samesite=expected_samesite,\n                    )\n\n                # test delete_cookie\n                with mock.patch(\"flask.Response.set_cookie\") as set_cookie_mock:\n                    with mock.patch(\"flask.Response.delete_cookie\") as delete_cookie_mock:\n                        with self.app.app_context():\n                            response.delete_cookie(\"some_key\", **kwargs)\n\n                        # delete_cookie internally calls set_cookie - so our delete_cookie call still uses the non modified\n                        # key and path values, set_cookie will translate those (as tested above)\n                        delete_cookie_mock.assert_called_once_with(\n                            response, \"some_key\", path=expected_path_delete, domain=None\n                        )\n\n                        # we also test if an additional set_cookie call for the non modified versions happens, as\n                        # implemented to ensure any old cookies from before introduction of the suffixes and path handling\n                        # are deleted as well\n                        set_cookie_mock.assert_called_once_with(\n                            response,\n                            \"some_key\",\n                            expires=0,\n                            max_age=0,\n                            path=expected_path_delete,\n                            domain=None,\n                        )\n"], "filenames": ["src/octoprint/access/users.py", "src/octoprint/server/__init__.py", "src/octoprint/server/api/__init__.py", "src/octoprint/server/util/flask.py", "src/octoprint/server/util/sockjs.py", "src/octoprint/static/js/app/viewmodels/usersettings.js", "src/octoprint/templates/dialogs/usersettings/access.jinja2", "tests/server/util/test_flask.py"], "buggy_code_start_loc": [130, 133, 40, 7, 24, 91, 26, 12], "buggy_code_end_loc": [1388, 1369, 314, 1834, 718, 122, 26, 564], "fixing_code_start_loc": [130, 133, 41, 8, 24, 91, 27, 13], "fixing_code_end_loc": [1405, 1385, 319, 1919, 733, 122, 30, 574], "type": "CWE-613", "message": "If an attacker comes into the possession of a victim's OctoPrint session cookie through whatever means, the attacker can use this cookie to authenticate as long as the victim's account exists.", "other": {"cve": {"id": "CVE-2022-2888", "sourceIdentifier": "security@huntr.dev", "published": "2022-09-21T12:15:09.923", "lastModified": "2022-09-22T15:40:24.917", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "If an attacker comes into the possession of a victim's OctoPrint session cookie through whatever means, the attacker can use this cookie to authenticate as long as the victim's account exists."}, {"lang": "es", "value": "Si un atacante entra en posesi\u00f3n de la cookie de sesi\u00f3n de OctoPrint de una v\u00edctima mediante cualquier medio, el atacante puede usar esta cookie para autenticarse mientras la cuenta de la v\u00edctima exista"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 2.5}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 2.5}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-613"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:octoprint:octoprint:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.8.3", "matchCriteriaId": "900F81F7-9FC4-44CE-ABD6-1E82DC120B4B"}]}]}], "references": [{"url": "https://github.com/octoprint/octoprint/commit/40e6217ac1a85cc5ed592873ae49db01d3005da4", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/d27d232b-2578-4b32-b3b4-74aabdadf629", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/octoprint/octoprint/commit/40e6217ac1a85cc5ed592873ae49db01d3005da4"}}