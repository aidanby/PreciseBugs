{"buggy_code": ["Changelog\n=========\n\n1.13 (unreleased)\n-----------------\n\n- Nothing changed yet.\n\n\n1.12 (2020-10-07)\n-----------------\n\n- Added prefiltering on widgets\n  [daggelpop, sgeulette]\n- Add Transifex.net service integration to manage the translation process.\n  [macagua]\n- Add Spanish translation\n  [macagua]\n\n\n1.11 (2019-09-20)\n-----------------\n\n- Limit catalog results (with sort_limit) because solr sends None for higher limit results.\n  [sgeulette]\n- Use contact_source metadata in widget result\n  [sgeulette]\n\n1.10 (2017-10-05)\n-----------------\n\n- Set Content-type 'text/plain' headers to autocomplete request. This prevent \"<!DOCTYPE html\" tag.\n  [bsuttor]\n\n\n1.9 (2017-05-30)\n----------------\n\n- Fix optimization issue when vocabulary is restricted by a relation.\n  [thomasdesvenain]\n\n- Prevent fatal error on autocomplete if by chance a held position related to a position or an organisation has been removed\n  but the relation always exist. An error is logged.\n  [thomasdesvenain]\n\n1.8 (2016-10-21)\n----------------\n\n- ContactChoice can now be used as master field when\n  plone.formwidget.masterselect >= 1.6 is installed.\n  [vincentfretin]\n\n\n1.7 (2016-07-07)\n----------------\n\n- Set matchSubset: false to fix autocomplete behavior with accents and not\n  doing a new ajax request.\n  [vincentfretin]\n\n- Ensure that the required property for ContactList field works correctly\n  [mpeeters]\n\n\n1.6 (2016-03-31)\n----------------\n\n- Fix an exception with plone.formwidget.contenttree >= 1.0.11 that introduced\n  support for providing defaults to contenttrees.\n  [pcdummy]\n\n\n1.5 (2016-03-04)\n----------------\n\n- Add a querySelectSearchInput class to the input field.\n  [vincentfretin]\n\n- Add display template for single selection field\n  [sgeulette]\n\n- Fix buildout\n  [sgeulette]\n\n1.4 (2015-06-02)\n----------------\n\n- Remove prefill_person when clicking on Create Contact link (this behavior is\n  too difficult to understand for end users).\n  [cedricmessiant]\n\n- Use a more generic selector for title so that it also works with behaviors.\n  [cedricmessiant]\n\n- Use prelabel variable in template (so that you can override it in custom\n  settings, see collective.contact.core).\n  [cedricmessiant]\n\n- Increase results to 50 items.\n  [vincentfretin]\n\n- jQuery 1.9 compatibility.\n  [vincentfretin]\n\n- Fix ContactSource search if no review_state parameter\n  [ebrehault]\n\n\n1.2.2 (2014-09-25)\n------------------\n\n- Add review_state parameter on ContactList and ContactChoice widgets.\n  [cedricmessiant]\n\n1.2.1 (2014-09-10)\n------------------\n\n- UI : improve prefill of add new contact overlay form.\n  [thomasdesvenain]\n\n\n1.2 (2014-06-02)\n----------------\n\n- We can give as source param a 'relations' value to filter on contents\n  related to an other content.\n  [thomasdesvenain]\n\n\n1.1 (2014-03-11)\n----------------\n\n- Don't include closeOnClick: true in javascript, so it defaults to\n  global configuration.\n  [vincentfretin]\n\n- UI improvements :\n  - Add contact link is displayed after user has filled a search.\n  - We have and explicit help message next to contact link.\n  - Contact creation form title is pre-filled with user search.\n  - The search input has a placeholder.\n  [thomasdesvenain]\n\n- Execute prepOverlay only if it hasn't been done yet, this avoid to have a\n  pbo undefined error when you have recursive overlays.\n  [vincentfretin]\n\n- The jqueryui autocomplete plugin conflicts with the jquery autocomplete\n  plugin used by plone.formwidget.autocomplete, disable the jqueryui one.\n  [cedricmessiant]\n\n- Do not break dexterity content type when we don't have a REQUEST\n  (in async context).\n  [thomasdesvenain]\n\n- We can add contact and contact list fields TTW on dexterity content types.\n  [thomasdesvenain]\n\n\n1.0 (2013-09-18)\n----------------\n\n- Check do_post_sort attribute on source to be able to disable the sorting.\n\n- Declare dependencies on z3c.relationfield and plone.formwidget.contenttree.\n\n- Remove ploneform-render-widget view for content provider, this is now\n  in plone.app.z3cform since 0.7.3.\n\n\n1.0rc1 (2013-03-27)\n-------------------\n\n- Added hidden and rtf mode templates.\n  [vincentfretin]\n\n- Don't open tooltip in tooltip.\n  [vincentfretin]\n\n\n0.12 (2013-03-12)\n-----------------\n\n- Decode title, returning unicode, to standardize term attributes\n  [sgeulette]\n\n\n0.11 (2013-03-11)\n-----------------\n\n- Fixed UnicodeDecodeError in @@autocomplete-search\n  [vincentfretin]\n\n- Internationalized two messages.\n  [vincentfretin]\n\n- Don't show tooltip if the mouse left the link.\n  [vincentfretin]\n\n- Don't call tokenToUrl if value is --NOVALUE--.\n  [vincentfretin]\n\n\n0.10 (2013-03-07)\n-----------------\n\n- Nothing changed yet.\n\n\n0.9 (2013-03-07)\n----------------\n\n- Initial release.\n  [vincentfretin]\n", "import json\n\nfrom z3c.form.interfaces import IFieldWidget\nimport z3c.form.interfaces\nfrom z3c.form.widget import FieldWidget\nfrom zope.component import getUtility\nfrom zope.component.interfaces import ComponentLookupError\nfrom zope.i18n import translate\nfrom zope.interface import implementer, implements, Interface\nfrom zope.browserpage.viewpagetemplatefile import ViewPageTemplateFile\nfrom zope.schema.interfaces import IContextSourceBinder\nfrom zope.schema.interfaces import IVocabulary\nfrom zope.schema.interfaces import IVocabularyFactory\nfrom five import grok\n\nfrom Products.CMFPlone.utils import base_hasattr, safe_unicode\nfrom plone.app.layout.viewlets.interfaces import IBelowContent\nfrom plone.app.layout.viewlets.interfaces import IHtmlHeadLinks\nfrom plone.formwidget.autocomplete.widget import (\n    AutocompleteMultiSelectionWidget,\n    AutocompleteSelectionWidget)\nfrom plone.formwidget.autocomplete.widget import AutocompleteSearch as BaseAutocompleteSearch\n\ntry:\n    from plone.formwidget.masterselect.widget import MasterSelect as BaseMasterSelect\n    from plone.formwidget.masterselect.interfaces import IMasterSelectWidget\n    class MasterSelect(BaseMasterSelect):\n        grok.implements(IMasterSelectWidget)\n        def getSlaves(self):\n            for slave in self.field.slave_fields:\n                yield slave.copy()\nexcept ImportError:\n    class MasterSelect(object):\n        pass\n\nfrom collective.contact.widget import _\nfrom collective.contact.widget.interfaces import (\n    IContactAutocompleteWidget,\n    IContactAutocompleteSelectionWidget,\n    IContactAutocompleteMultiSelectionWidget,\n    IContactContent,\n    IContactWidgetSettings,\n)\n\n\nclass PatchLoadInsideOverlay(grok.Viewlet):\n    grok.context(Interface)\n    grok.viewletmanager(IHtmlHeadLinks)\n    wait_msg = _(u\"please wait\")\n    tooltip_template = ViewPageTemplateFile('js/widget.js.pt')\n\n    def render(self):\n        return self.tooltip_template() % {\n            'wait_msg': translate(self.wait_msg, context=self.request)}\n\n\nclass TermViewlet(grok.Viewlet):\n    grok.name('term-contact')\n    grok.context(IContactContent)\n    grok.viewletmanager(IBelowContent)\n\n    @property\n    def token(self):\n        return '/'.join(self.context.getPhysicalPath())\n\n    @property\n    def title(self):\n        if base_hasattr(self.context, 'get_full_title'):\n            title = self.context.get_full_title()\n        else:\n            title = self.context.Title()\n        title = title and safe_unicode(title) or u\"\"\n        return title\n\n    @property\n    def portal_type(self):\n        return self.context.portal_type\n\n    @property\n    def url(self):\n        return self.context.absolute_url()\n\n    def render(self):\n        return u\"\"\"<input type=\"hidden\" name=\"objpath\" value=\"%s\" />\"\"\" % (\n            '|'.join([self.token, self.title, self.portal_type, self.url]))\n\n\nclass ContactBaseWidget(object):\n    implements(IContactAutocompleteWidget)\n    noValueLabel = _(u'(nothing)')\n    autoFill = False\n    maxResults = 50\n    close_on_click = True\n    display_template = ViewPageTemplateFile('templates/contact_display.pt')\n    input_template = ViewPageTemplateFile('templates/contact_input.pt')\n    hidden_template = ViewPageTemplateFile('templates/contact_hidden.pt')\n    rtf_template = ViewPageTemplateFile('templates/contact_rtf.pt')\n\n    # JavaScript template\n    js_template = \"\"\"\\\n    (function($) {\n        $().ready(function() {\n            $('#%(id)s-input-fields').data('klass','%(klass)s').data('title','%(title)s').data('input_type','%(input_type)s').data('multiple', %(multiple)s);\n            $('#%(id)s-buttons-search').remove();\n            $('#%(id)s-widgets-query').autocomplete('%(url)s', {\n                autoFill: %(autoFill)s,\n                minChars: %(minChars)d,\n                max: %(maxResults)d,\n                mustMatch: %(mustMatch)s,\n                matchContains: %(matchContains)s,\n                matchSubset: false,\n                formatItem: %(formatItem)s,\n                formatResult: %(formatResult)s,\n                parse: %(parseFunction)s,\n                extraParams: {'prefilter': function() {return $('#formfield-%(id)s .prefilter-select').val() || '';}}\n            }).result(%(js_callback)s);\n            %(js_extra)s\n        });\n    })(jQuery);\n    \"\"\"\n\n    js_callback_template = \"\"\"\nfunction (event, data, formatted) {\n    (function($) {\n        var input_box = $(event.target);\n        formwidget_autocomplete_new_value(input_box,data[0],data[1]);\n        // trigger change event on newly added input element\n        var input = input_box.parents('.querySelectSearch').parent('div').siblings('.autocompleteInputWidget').find('input').last();\n        var url = data[3];\n        ccw.add_contact_preview(input, url);\n        input.trigger('change');\n    }(jQuery));\n}\n\"\"\"\n    overlay_template = ViewPageTemplateFile('js/overlay.js.pt')\n    placeholder = _(u\"Fill your search here...\")\n\n    @property\n    def bound_source(self):\n        try:\n            return super(ContactBaseWidget, self).bound_source\n        except ComponentLookupError:\n            return []\n\n    def tokenToUrl(self, token):\n        if token == \"--NOVALUE--\":\n            return \"\"\n        return self.bound_source.tokenToUrl(token)\n\n    def render(self):\n        settings = getUtility(IContactWidgetSettings)\n        attributes = settings.add_contact_infos(self)\n        for key, value in attributes.items():\n            setattr(self, key, value)\n        if self.mode == z3c.form.interfaces.DISPLAY_MODE:\n            return self.display_template(self)\n        elif self.mode == z3c.form.interfaces.HIDDEN_MODE:\n            return self.hidden_template(self)\n        elif self.mode == \"rtf\":\n            return self.rtf_template(self)\n        else:\n            return self.input_template(self)\n\n    def js_extra(self):\n        content = \"\"\n        include_default = False\n        for action in self.actions:\n            formselector = action.get('formselector', None)\n            if formselector is None:\n                include_default = True\n            else:\n                closeselector = action.get(\n                    'closeselector', '[name=\"form.buttons.cancel\"]')\n                content += self.overlay_template(**dict(\n                    klass=action['klass'],\n                    formselector=formselector,\n                    closeselector=closeselector,\n                    closeOnClick=self.close_on_click and 'true' or 'false'))\n\n        if include_default:\n            content += self.overlay_template(**dict(\n                klass='addnew',\n                formselector='#form',\n                closeselector='[name=\"form.buttons.cancel\"]',\n                closeOnClick=self.close_on_click and 'true' or 'false'))\n\n        return content\n\n    def prefilter_terms(self):\n        if isinstance(self.field.prefilter_vocabulary, basestring):\n            vocabulary = getUtility(IVocabularyFactory, name=self.field.prefilter_vocabulary)\n            return vocabulary(self.context)\n        elif IVocabulary.providedBy(self.field.prefilter_vocabulary):\n            return self.field.prefilter_vocabulary\n        elif IContextSourceBinder.providedBy(self.field.prefilter_vocabulary):\n            source = self.field.prefilter_vocabulary\n            return source(self.context)\n        else:\n            return []\n\n    def prefilter_default_value(self):\n        if callable(self.field.prefilter_default_value):\n            return self.field.prefilter_default_value(self.context)\n        else:\n            return None\n\n\nclass ContactAutocompleteSelectionWidget(ContactBaseWidget, AutocompleteSelectionWidget, MasterSelect):\n    implements(IContactAutocompleteSelectionWidget)\n    display_template = ViewPageTemplateFile('templates/contact_display_single.pt')\n\n\nclass ContactAutocompleteMultiSelectionWidget(ContactBaseWidget, AutocompleteMultiSelectionWidget):\n    implements(IContactAutocompleteMultiSelectionWidget)\n\n\n@implementer(IFieldWidget)\ndef ContactAutocompleteFieldWidget(field, request):\n    widget = ContactAutocompleteSelectionWidget(request)\n    return FieldWidget(field, widget)\n\n\n@implementer(IFieldWidget)\ndef ContactAutocompleteMultiFieldWidget(field, request):\n    widget = ContactAutocompleteMultiSelectionWidget(request)\n    return FieldWidget(field, widget)\n\n\nclass AutocompleteSearch(BaseAutocompleteSearch):\n    def __call__(self):\n        # We want to check that the user was indeed allowed to access the\n        # form for this widget. We can only this now, since security isn't\n        # applied yet during traversal.\n        self.validate_access()\n\n        query = self.request.get('q', None)\n        path = self.request.get('path', None)\n        if not query:\n            if path is None:\n                return ''\n            else:\n                query = ''\n\n        relations = self.request.get('relations', None)\n        # Update the widget before accessing the source.\n        # The source was only bound without security applied\n        # during traversal before.\n        self.context.update()\n        source = self.context.bound_source\n        if path is not None:\n            query = \"path:%s %s\" % (source.tokenToPath(path), query)\n\n        if query or relations:\n            prefilter = {}\n            try:\n                prefilter_param = json.loads(self.request.get('prefilter'))\n                if type(prefilter_param) == dict and len(prefilter_param) > 0:\n                    prefilter = prefilter_param\n            except ValueError:\n                pass\n\n            terms = source.search(query, relations=relations, prefilter=prefilter)\n\n        else:\n            terms = ()\n\n        if getattr(source, 'do_post_sort', True):\n            terms = sorted(set(terms), key=lambda t: t.title)\n\n        response = self.request.response\n        response.setHeader('Content-type', 'text/plain')\n\n        return u'\\n'.join([u\"|\".join((t.token, t.title or t.token, t.portal_type, t.url, t.extra))\n                          for t in terms])\n"], "fixing_code": ["Changelog\n=========\n\n1.13 (unreleased)\n-----------------\n\n- Escaped contact title special characters in `term-contact` viewlet to avoid\n  script insertion (xss). This viewlet stores an hidden field used in a\n  dynamically js generation.\n  [sgeulette]\n\n1.12 (2020-10-07)\n-----------------\n\n- Added prefiltering on widgets\n  [daggelpop, sgeulette]\n- Add Transifex.net service integration to manage the translation process.\n  [macagua]\n- Add Spanish translation\n  [macagua]\n\n\n1.11 (2019-09-20)\n-----------------\n\n- Limit catalog results (with sort_limit) because solr sends None for higher limit results.\n  [sgeulette]\n- Use contact_source metadata in widget result\n  [sgeulette]\n\n1.10 (2017-10-05)\n-----------------\n\n- Set Content-type 'text/plain' headers to autocomplete request. This prevent \"<!DOCTYPE html\" tag.\n  [bsuttor]\n\n\n1.9 (2017-05-30)\n----------------\n\n- Fix optimization issue when vocabulary is restricted by a relation.\n  [thomasdesvenain]\n\n- Prevent fatal error on autocomplete if by chance a held position related to a position or an organisation has been removed\n  but the relation always exist. An error is logged.\n  [thomasdesvenain]\n\n1.8 (2016-10-21)\n----------------\n\n- ContactChoice can now be used as master field when\n  plone.formwidget.masterselect >= 1.6 is installed.\n  [vincentfretin]\n\n\n1.7 (2016-07-07)\n----------------\n\n- Set matchSubset: false to fix autocomplete behavior with accents and not\n  doing a new ajax request.\n  [vincentfretin]\n\n- Ensure that the required property for ContactList field works correctly\n  [mpeeters]\n\n\n1.6 (2016-03-31)\n----------------\n\n- Fix an exception with plone.formwidget.contenttree >= 1.0.11 that introduced\n  support for providing defaults to contenttrees.\n  [pcdummy]\n\n\n1.5 (2016-03-04)\n----------------\n\n- Add a querySelectSearchInput class to the input field.\n  [vincentfretin]\n\n- Add display template for single selection field\n  [sgeulette]\n\n- Fix buildout\n  [sgeulette]\n\n1.4 (2015-06-02)\n----------------\n\n- Remove prefill_person when clicking on Create Contact link (this behavior is\n  too difficult to understand for end users).\n  [cedricmessiant]\n\n- Use a more generic selector for title so that it also works with behaviors.\n  [cedricmessiant]\n\n- Use prelabel variable in template (so that you can override it in custom\n  settings, see collective.contact.core).\n  [cedricmessiant]\n\n- Increase results to 50 items.\n  [vincentfretin]\n\n- jQuery 1.9 compatibility.\n  [vincentfretin]\n\n- Fix ContactSource search if no review_state parameter\n  [ebrehault]\n\n\n1.2.2 (2014-09-25)\n------------------\n\n- Add review_state parameter on ContactList and ContactChoice widgets.\n  [cedricmessiant]\n\n1.2.1 (2014-09-10)\n------------------\n\n- UI : improve prefill of add new contact overlay form.\n  [thomasdesvenain]\n\n\n1.2 (2014-06-02)\n----------------\n\n- We can give as source param a 'relations' value to filter on contents\n  related to an other content.\n  [thomasdesvenain]\n\n\n1.1 (2014-03-11)\n----------------\n\n- Don't include closeOnClick: true in javascript, so it defaults to\n  global configuration.\n  [vincentfretin]\n\n- UI improvements :\n  - Add contact link is displayed after user has filled a search.\n  - We have and explicit help message next to contact link.\n  - Contact creation form title is pre-filled with user search.\n  - The search input has a placeholder.\n  [thomasdesvenain]\n\n- Execute prepOverlay only if it hasn't been done yet, this avoid to have a\n  pbo undefined error when you have recursive overlays.\n  [vincentfretin]\n\n- The jqueryui autocomplete plugin conflicts with the jquery autocomplete\n  plugin used by plone.formwidget.autocomplete, disable the jqueryui one.\n  [cedricmessiant]\n\n- Do not break dexterity content type when we don't have a REQUEST\n  (in async context).\n  [thomasdesvenain]\n\n- We can add contact and contact list fields TTW on dexterity content types.\n  [thomasdesvenain]\n\n\n1.0 (2013-09-18)\n----------------\n\n- Check do_post_sort attribute on source to be able to disable the sorting.\n\n- Declare dependencies on z3c.relationfield and plone.formwidget.contenttree.\n\n- Remove ploneform-render-widget view for content provider, this is now\n  in plone.app.z3cform since 0.7.3.\n\n\n1.0rc1 (2013-03-27)\n-------------------\n\n- Added hidden and rtf mode templates.\n  [vincentfretin]\n\n- Don't open tooltip in tooltip.\n  [vincentfretin]\n\n\n0.12 (2013-03-12)\n-----------------\n\n- Decode title, returning unicode, to standardize term attributes\n  [sgeulette]\n\n\n0.11 (2013-03-11)\n-----------------\n\n- Fixed UnicodeDecodeError in @@autocomplete-search\n  [vincentfretin]\n\n- Internationalized two messages.\n  [vincentfretin]\n\n- Don't show tooltip if the mouse left the link.\n  [vincentfretin]\n\n- Don't call tokenToUrl if value is --NOVALUE--.\n  [vincentfretin]\n\n\n0.10 (2013-03-07)\n-----------------\n\n- Nothing changed yet.\n\n\n0.9 (2013-03-07)\n----------------\n\n- Initial release.\n  [vincentfretin]\n", "from cgi import escape\nfrom collective.contact.widget import _\nfrom collective.contact.widget.interfaces import IContactAutocompleteMultiSelectionWidget\nfrom collective.contact.widget.interfaces import IContactAutocompleteSelectionWidget\nfrom collective.contact.widget.interfaces import IContactAutocompleteWidget\nfrom collective.contact.widget.interfaces import IContactContent\nfrom collective.contact.widget.interfaces import IContactWidgetSettings\nfrom five import grok\nfrom plone.app.layout.viewlets.interfaces import IBelowContent\nfrom plone.app.layout.viewlets.interfaces import IHtmlHeadLinks\nfrom plone.formwidget.autocomplete.widget import AutocompleteMultiSelectionWidget\nfrom plone.formwidget.autocomplete.widget import AutocompleteSearch as BaseAutocompleteSearch\nfrom plone.formwidget.autocomplete.widget import AutocompleteSelectionWidget\nfrom Products.CMFPlone.utils import base_hasattr\nfrom Products.CMFPlone.utils import safe_unicode\nfrom z3c.form.interfaces import IFieldWidget\nfrom z3c.form.widget import FieldWidget\nfrom zope.browserpage.viewpagetemplatefile import ViewPageTemplateFile\nfrom zope.component import getUtility\nfrom zope.component.interfaces import ComponentLookupError\nfrom zope.i18n import translate\nfrom zope.interface import implementer\nfrom zope.interface import implements\nfrom zope.interface import Interface\nfrom zope.schema.interfaces import IContextSourceBinder\nfrom zope.schema.interfaces import IVocabulary\nfrom zope.schema.interfaces import IVocabularyFactory\n\nimport json\nimport z3c.form.interfaces\n\n\ntry:\n    from plone.formwidget.masterselect.interfaces import IMasterSelectWidget\n    from plone.formwidget.masterselect.widget import MasterSelect as BaseMasterSelect\n    class MasterSelect(BaseMasterSelect):\n        grok.implements(IMasterSelectWidget)\n        def getSlaves(self):\n            for slave in self.field.slave_fields:\n                yield slave.copy()\nexcept ImportError:\n    class MasterSelect(object):\n        pass\n\n\nclass PatchLoadInsideOverlay(grok.Viewlet):\n    grok.context(Interface)\n    grok.viewletmanager(IHtmlHeadLinks)\n    wait_msg = _(u\"please wait\")\n    tooltip_template = ViewPageTemplateFile('js/widget.js.pt')\n\n    def render(self):\n        return self.tooltip_template() % {\n            'wait_msg': translate(self.wait_msg, context=self.request)}\n\n\nclass TermViewlet(grok.Viewlet):\n    grok.name('term-contact')\n    grok.context(IContactContent)\n    grok.viewletmanager(IBelowContent)\n\n    @property\n    def token(self):\n        return '/'.join(self.context.getPhysicalPath())\n\n    @property\n    def title(self):\n        if base_hasattr(self.context, 'get_full_title'):\n            title = self.context.get_full_title()\n        else:\n            title = self.context.Title()\n        title = title and safe_unicode(title) or u\"\"\n        return escape(title, quote=True)\n\n    @property\n    def portal_type(self):\n        return self.context.portal_type\n\n    @property\n    def url(self):\n        return self.context.absolute_url()\n\n    def render(self):\n        return u\"\"\"<input type=\"hidden\" name=\"objpath\" value=\"%s\" />\"\"\" % (\n            '|'.join([self.token, self.title, self.portal_type, self.url]))\n\n\nclass ContactBaseWidget(object):\n    implements(IContactAutocompleteWidget)\n    noValueLabel = _(u'(nothing)')\n    autoFill = False\n    maxResults = 50\n    close_on_click = True\n    display_template = ViewPageTemplateFile('templates/contact_display.pt')\n    input_template = ViewPageTemplateFile('templates/contact_input.pt')\n    hidden_template = ViewPageTemplateFile('templates/contact_hidden.pt')\n    rtf_template = ViewPageTemplateFile('templates/contact_rtf.pt')\n\n    # JavaScript template\n    js_template = \"\"\"\\\n    (function($) {\n        $().ready(function() {\n            $('#%(id)s-input-fields').data('klass','%(klass)s').data('title','%(title)s').data('input_type','%(input_type)s').data('multiple', %(multiple)s);\n            $('#%(id)s-buttons-search').remove();\n            $('#%(id)s-widgets-query').autocomplete('%(url)s', {\n                autoFill: %(autoFill)s,\n                minChars: %(minChars)d,\n                max: %(maxResults)d,\n                mustMatch: %(mustMatch)s,\n                matchContains: %(matchContains)s,\n                matchSubset: false,\n                formatItem: %(formatItem)s,\n                formatResult: %(formatResult)s,\n                parse: %(parseFunction)s,\n                extraParams: {'prefilter': function() {return $('#formfield-%(id)s .prefilter-select').val() || '';}}\n            }).result(%(js_callback)s);\n            %(js_extra)s\n        });\n    })(jQuery);\n    \"\"\"\n\n    js_callback_template = \"\"\"\nfunction (event, data, formatted) {\n    (function($) {\n        var input_box = $(event.target);\n        formwidget_autocomplete_new_value(input_box,data[0],data[1]);\n        // trigger change event on newly added input element\n        var input = input_box.parents('.querySelectSearch').parent('div').siblings('.autocompleteInputWidget').find('input').last();\n        var url = data[3];\n        ccw.add_contact_preview(input, url);\n        input.trigger('change');\n    }(jQuery));\n}\n\"\"\"\n    overlay_template = ViewPageTemplateFile('js/overlay.js.pt')\n    placeholder = _(u\"Fill your search here...\")\n\n    @property\n    def bound_source(self):\n        try:\n            return super(ContactBaseWidget, self).bound_source\n        except ComponentLookupError:\n            return []\n\n    def tokenToUrl(self, token):\n        if token == \"--NOVALUE--\":\n            return \"\"\n        return self.bound_source.tokenToUrl(token)\n\n    def render(self):\n        settings = getUtility(IContactWidgetSettings)\n        attributes = settings.add_contact_infos(self)\n        for key, value in attributes.items():\n            setattr(self, key, value)\n        if self.mode == z3c.form.interfaces.DISPLAY_MODE:\n            return self.display_template(self)\n        elif self.mode == z3c.form.interfaces.HIDDEN_MODE:\n            return self.hidden_template(self)\n        elif self.mode == \"rtf\":\n            return self.rtf_template(self)\n        else:\n            return self.input_template(self)\n\n    def js_extra(self):\n        content = \"\"\n        include_default = False\n        for action in self.actions:\n            formselector = action.get('formselector', None)\n            if formselector is None:\n                include_default = True\n            else:\n                closeselector = action.get(\n                    'closeselector', '[name=\"form.buttons.cancel\"]')\n                content += self.overlay_template(**dict(\n                    klass=action['klass'],\n                    formselector=formselector,\n                    closeselector=closeselector,\n                    closeOnClick=self.close_on_click and 'true' or 'false'))\n\n        if include_default:\n            content += self.overlay_template(**dict(\n                klass='addnew',\n                formselector='#form',\n                closeselector='[name=\"form.buttons.cancel\"]',\n                closeOnClick=self.close_on_click and 'true' or 'false'))\n\n        return content\n\n    def prefilter_terms(self):\n        if isinstance(self.field.prefilter_vocabulary, basestring):\n            vocabulary = getUtility(IVocabularyFactory, name=self.field.prefilter_vocabulary)\n            return vocabulary(self.context)\n        elif IVocabulary.providedBy(self.field.prefilter_vocabulary):\n            return self.field.prefilter_vocabulary\n        elif IContextSourceBinder.providedBy(self.field.prefilter_vocabulary):\n            source = self.field.prefilter_vocabulary\n            return source(self.context)\n        else:\n            return []\n\n    def prefilter_default_value(self):\n        if callable(self.field.prefilter_default_value):\n            return self.field.prefilter_default_value(self.context)\n        else:\n            return None\n\n\nclass ContactAutocompleteSelectionWidget(ContactBaseWidget, AutocompleteSelectionWidget, MasterSelect):\n    implements(IContactAutocompleteSelectionWidget)\n    display_template = ViewPageTemplateFile('templates/contact_display_single.pt')\n\n\nclass ContactAutocompleteMultiSelectionWidget(ContactBaseWidget, AutocompleteMultiSelectionWidget):\n    implements(IContactAutocompleteMultiSelectionWidget)\n\n\n@implementer(IFieldWidget)\ndef ContactAutocompleteFieldWidget(field, request):\n    widget = ContactAutocompleteSelectionWidget(request)\n    return FieldWidget(field, widget)\n\n\n@implementer(IFieldWidget)\ndef ContactAutocompleteMultiFieldWidget(field, request):\n    widget = ContactAutocompleteMultiSelectionWidget(request)\n    return FieldWidget(field, widget)\n\n\nclass AutocompleteSearch(BaseAutocompleteSearch):\n    def __call__(self):\n        # We want to check that the user was indeed allowed to access the\n        # form for this widget. We can only this now, since security isn't\n        # applied yet during traversal.\n        self.validate_access()\n\n        query = self.request.get('q', None)\n        path = self.request.get('path', None)\n        if not query:\n            if path is None:\n                return ''\n            else:\n                query = ''\n\n        relations = self.request.get('relations', None)\n        # Update the widget before accessing the source.\n        # The source was only bound without security applied\n        # during traversal before.\n        self.context.update()\n        source = self.context.bound_source\n        if path is not None:\n            query = \"path:%s %s\" % (source.tokenToPath(path), query)\n\n        if query or relations:\n            prefilter = {}\n            try:\n                prefilter_param = json.loads(self.request.get('prefilter'))\n                if type(prefilter_param) == dict and len(prefilter_param) > 0:\n                    prefilter = prefilter_param\n            except ValueError:\n                pass\n\n            terms = source.search(query, relations=relations, prefilter=prefilter)\n\n        else:\n            terms = ()\n\n        if getattr(source, 'do_post_sort', True):\n            terms = sorted(set(terms), key=lambda t: t.title)\n\n        response = self.request.response\n        response.setHeader('Content-type', 'text/plain')\n\n        return u'\\n'.join([u\"|\".join((t.token, t.title or t.token, t.portal_type, t.url, t.extra))\n                          for t in terms])\n"], "filenames": ["CHANGES.rst", "src/collective/contact/widget/widgets.py"], "buggy_code_start_loc": [7, 1], "buggy_code_end_loc": [9, 74], "fixing_code_start_loc": [7, 1], "fixing_code_end_loc": [11, 74], "type": "CWE-79", "message": "A vulnerability classified as problematic was found in collective.contact.widget up to 1.12. This vulnerability affects the function title of the file src/collective/contact/widget/widgets.py. The manipulation leads to cross site scripting. The attack can be initiated remotely. The name of the patch is 5da36305ca7ed433782be8901c47387406fcda12. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-216496.", "other": {"cve": {"id": "CVE-2022-4638", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-21T22:15:08.570", "lastModified": "2022-12-28T21:27:57.017", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability classified as problematic was found in collective.contact.widget up to 1.12. This vulnerability affects the function title of the file src/collective/contact/widget/widgets.py. The manipulation leads to cross site scripting. The attack can be initiated remotely. The name of the patch is 5da36305ca7ed433782be8901c47387406fcda12. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-216496."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-707"}, {"lang": "en", "value": "CWE-74"}, {"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:collective.contact.widget_project:collective.contact.widget:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.12", "matchCriteriaId": "CE474E9B-FD4F-4AC8-A4B3-BDAF85499E35"}]}]}], "references": [{"url": "https://github.com/collective/collective.contact.widget/commit/5da36305ca7ed433782be8901c47387406fcda12", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216496", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/collective/collective.contact.widget/commit/5da36305ca7ed433782be8901c47387406fcda12"}}