{"buggy_code": ["/*\n * The copyright in this software is being made available under the 2-clauses \n * BSD License, included below. This software may be subject to other third \n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux \n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#include \"opj_apps_config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"openjpeg.h\"\n#include \"convert.h\"\n\n/*\n * Get logarithm of an integer and round downwards.\n *\n * log2(a)\n */\nstatic int int_floorlog2(int a) {\n    int l;\n    for (l = 0; a > 1; l++) {\n        a >>= 1;\n    }\n    return l;\n}\n\n/* Component precision scaling */\nvoid clip_component(opj_image_comp_t* component, OPJ_UINT32 precision)\n{\n\tOPJ_SIZE_T i;\n\tOPJ_SIZE_T len;\n\tOPJ_UINT32 umax = (OPJ_UINT32)((OPJ_INT32)-1);\n\t\n\tlen = (OPJ_SIZE_T)component->w * (OPJ_SIZE_T)component->h;\n\tif (precision < 32) {\n\t\tumax = (1U << precision) - 1U;\n\t}\n\t\n\tif (component->sgnd) {\n\t\tOPJ_INT32* l_data = component->data;\n\t\tOPJ_INT32 max = (OPJ_INT32)(umax / 2U);\n\t\tOPJ_INT32 min = -max - 1;\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tif (l_data[i] > max) {\n\t\t\t\tl_data[i] = max;\n\t\t\t} else if (l_data[i] < min) {\n\t\t\t\tl_data[i] = min;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tOPJ_UINT32* l_data = (OPJ_UINT32*)component->data;\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tif (l_data[i] > umax) {\n\t\t\t\tl_data[i] = umax;\n\t\t\t}\n\t\t}\n\t}\n\tcomponent->prec = precision;\n}\n\n/* Component precision scaling */\nstatic void scale_component_up(opj_image_comp_t* component, OPJ_UINT32 precision)\n{\n\tOPJ_SIZE_T i, len;\n\t\n\tlen = (OPJ_SIZE_T)component->w * (OPJ_SIZE_T)component->h;\n\tif (component->sgnd) {\n\t\tOPJ_INT64  newMax = (OPJ_INT64)(1U << (precision - 1));\n\t\tOPJ_INT64  oldMax = (OPJ_INT64)(1U << (component->prec - 1));\n\t\tOPJ_INT32* l_data = component->data;\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tl_data[i] = (OPJ_INT32)(((OPJ_INT64)l_data[i] * newMax) / oldMax);\n\t\t}\n\t} else {\n\t\tOPJ_UINT64  newMax = (OPJ_UINT64)((1U << precision) - 1U);\n\t\tOPJ_UINT64  oldMax = (OPJ_UINT64)((1U << component->prec) - 1U);\n\t\tOPJ_UINT32* l_data = (OPJ_UINT32*)component->data;\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tl_data[i] = (OPJ_UINT32)(((OPJ_UINT64)l_data[i] * newMax) / oldMax);\n\t\t}\n\t}\n\tcomponent->prec = precision;\n\tcomponent->bpp = precision;\n}\nvoid scale_component(opj_image_comp_t* component, OPJ_UINT32 precision)\n{\n\tint shift;\n\tOPJ_SIZE_T i, len;\n\t\n\tif (component->prec == precision) {\n\t\treturn;\n\t}\n\tif (component->prec < precision) {\n\t\tscale_component_up(component, precision);\n\t\treturn;\n\t}\n\tshift = (int)(component->prec - precision);\n\tlen = (OPJ_SIZE_T)component->w * (OPJ_SIZE_T)component->h;\n\tif (component->sgnd) {\n\t\tOPJ_INT32* l_data = component->data;\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tl_data[i] >>= shift;\n\t\t}\n\t} else {\n\t\tOPJ_UINT32* l_data = (OPJ_UINT32*)component->data;\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tl_data[i] >>= shift;\n\t\t}\n\t}\n\tcomponent->bpp = precision;\n\tcomponent->prec = precision;\n}\n\n\n/* planar / interleaved conversions */\n/* used by PNG/TIFF */\nstatic void convert_32s_C1P1(const OPJ_INT32* pSrc, OPJ_INT32* const* pDst, OPJ_SIZE_T length)\n{\n\tmemcpy(pDst[0], pSrc, length * sizeof(OPJ_INT32));\n}\nstatic void convert_32s_C2P2(const OPJ_INT32* pSrc, OPJ_INT32* const* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tOPJ_INT32* pDst0 = pDst[0];\n\tOPJ_INT32* pDst1 = pDst[1];\n\t\n\tfor (i = 0; i < length; i++) {\n\t\tpDst0[i] = pSrc[2*i+0];\n\t\tpDst1[i] = pSrc[2*i+1];\n\t}\n}\nstatic void convert_32s_C3P3(const OPJ_INT32* pSrc, OPJ_INT32* const* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tOPJ_INT32* pDst0 = pDst[0];\n\tOPJ_INT32* pDst1 = pDst[1];\n\tOPJ_INT32* pDst2 = pDst[2];\n\t\n\tfor (i = 0; i < length; i++) {\n\t\tpDst0[i] = pSrc[3*i+0];\n\t\tpDst1[i] = pSrc[3*i+1];\n\t\tpDst2[i] = pSrc[3*i+2];\n\t}\n}\nstatic void convert_32s_C4P4(const OPJ_INT32* pSrc, OPJ_INT32* const* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tOPJ_INT32* pDst0 = pDst[0];\n\tOPJ_INT32* pDst1 = pDst[1];\n\tOPJ_INT32* pDst2 = pDst[2];\n\tOPJ_INT32* pDst3 = pDst[3];\n\t\n\tfor (i = 0; i < length; i++) {\n\t\tpDst0[i] = pSrc[4*i+0];\n\t\tpDst1[i] = pSrc[4*i+1];\n\t\tpDst2[i] = pSrc[4*i+2];\n\t\tpDst3[i] = pSrc[4*i+3];\n\t}\n}\nconst convert_32s_CXPX convert_32s_CXPX_LUT[5] = {\n\tNULL,\n\tconvert_32s_C1P1,\n\tconvert_32s_C2P2,\n\tconvert_32s_C3P3,\n\tconvert_32s_C4P4\n};\n\nstatic void convert_32s_P1C1(OPJ_INT32 const* const* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length, OPJ_INT32 adjust)\n{\n\tOPJ_SIZE_T i;\n\tconst OPJ_INT32* pSrc0 = pSrc[0];\n\t\n\tfor (i = 0; i < length; i++) {\n\t\tpDst[i] = pSrc0[i] + adjust;\n\t}\n}\nstatic void convert_32s_P2C2(OPJ_INT32 const* const* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length, OPJ_INT32 adjust)\n{\n\tOPJ_SIZE_T i;\n\tconst OPJ_INT32* pSrc0 = pSrc[0];\n\tconst OPJ_INT32* pSrc1 = pSrc[1];\n\t\n\tfor (i = 0; i < length; i++) {\n\t\tpDst[2*i+0] = pSrc0[i] + adjust;\n\t\tpDst[2*i+1] = pSrc1[i] + adjust;\n\t}\n}\nstatic void convert_32s_P3C3(OPJ_INT32 const* const* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length, OPJ_INT32 adjust)\n{\n\tOPJ_SIZE_T i;\n\tconst OPJ_INT32* pSrc0 = pSrc[0];\n\tconst OPJ_INT32* pSrc1 = pSrc[1];\n\tconst OPJ_INT32* pSrc2 = pSrc[2];\n\t\n\tfor (i = 0; i < length; i++) {\n\t\tpDst[3*i+0] = pSrc0[i] + adjust;\n\t\tpDst[3*i+1] = pSrc1[i] + adjust;\n\t\tpDst[3*i+2] = pSrc2[i] + adjust;\n\t}\n}\nstatic void convert_32s_P4C4(OPJ_INT32 const* const* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length, OPJ_INT32 adjust)\n{\n\tOPJ_SIZE_T i;\n\tconst OPJ_INT32* pSrc0 = pSrc[0];\n\tconst OPJ_INT32* pSrc1 = pSrc[1];\n\tconst OPJ_INT32* pSrc2 = pSrc[2];\n\tconst OPJ_INT32* pSrc3 = pSrc[3];\n\t\n\tfor (i = 0; i < length; i++) {\n\t\tpDst[4*i+0] = pSrc0[i] + adjust;\n\t\tpDst[4*i+1] = pSrc1[i] + adjust;\n\t\tpDst[4*i+2] = pSrc2[i] + adjust;\n\t\tpDst[4*i+3] = pSrc3[i] + adjust;\n\t}\n}\nconst convert_32s_PXCX convert_32s_PXCX_LUT[5] = {\n\tNULL,\n\tconvert_32s_P1C1,\n\tconvert_32s_P2C2,\n\tconvert_32s_P3C3,\n\tconvert_32s_P4C4\n};\n\n/* bit depth conversions */\n/* used by PNG/TIFF up to 8bpp */\nstatic void convert_1u32s_C1R(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 val = *pSrc++;\n\t\tpDst[i+0] = (OPJ_INT32)( val >> 7);\n\t\tpDst[i+1] = (OPJ_INT32)((val >> 6) & 0x1U);\n\t\tpDst[i+2] = (OPJ_INT32)((val >> 5) & 0x1U);\n\t\tpDst[i+3] = (OPJ_INT32)((val >> 4) & 0x1U);\n\t\tpDst[i+4] = (OPJ_INT32)((val >> 3) & 0x1U);\n\t\tpDst[i+5] = (OPJ_INT32)((val >> 2) & 0x1U);\n\t\tpDst[i+6] = (OPJ_INT32)((val >> 1) & 0x1U);\n\t\tpDst[i+7] = (OPJ_INT32)(val & 0x1U);\n\t}\n\tif (length & 7U) {\n\t\tOPJ_UINT32 val = *pSrc++;\n\t\tlength = length & 7U;\n\t\tpDst[i+0] = (OPJ_INT32)(val >> 7);\n\t\t\n\t\tif (length > 1U) {\n\t\t\tpDst[i+1] = (OPJ_INT32)((val >> 6) & 0x1U);\n\t\t\tif (length > 2U) {\n\t\t\t\tpDst[i+2] = (OPJ_INT32)((val >> 5) & 0x1U);\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tpDst[i+3] = (OPJ_INT32)((val >> 4) & 0x1U);\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tpDst[i+4] = (OPJ_INT32)((val >> 3) & 0x1U);\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tpDst[i+5] = (OPJ_INT32)((val >> 2) & 0x1U);\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tpDst[i+6] = (OPJ_INT32)((val >> 1) & 0x1U);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void convert_2u32s_C1R(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i+=4U) {\n\t\tOPJ_UINT32 val = *pSrc++;\n\t\tpDst[i+0] = (OPJ_INT32)( val >> 6);\n\t\tpDst[i+1] = (OPJ_INT32)((val >> 4) & 0x3U);\n\t\tpDst[i+2] = (OPJ_INT32)((val >> 2) & 0x3U);\n\t\tpDst[i+3] = (OPJ_INT32)(val & 0x3U);\n\t}\n\tif (length & 3U) {\n\t\tOPJ_UINT32 val = *pSrc++;\n\t\tlength = length & 3U;\n\t\tpDst[i+0] =  (OPJ_INT32)(val >> 6);\n\t\t\n\t\tif (length > 1U) {\n\t\t\tpDst[i+1] = (OPJ_INT32)((val >> 4) & 0x3U);\n\t\t\tif (length > 2U) {\n\t\t\t\tpDst[i+2] = (OPJ_INT32)((val >> 2) & 0x3U);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void convert_4u32s_C1R(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)1U); i+=2U) {\n\t\tOPJ_UINT32 val = *pSrc++;\n\t\tpDst[i+0] = (OPJ_INT32)(val >> 4);\n\t\tpDst[i+1] = (OPJ_INT32)(val & 0xFU);\n\t}\n\tif (length & 1U) {\n\t\tOPJ_UINT8 val = *pSrc++;\n\t\tpDst[i+0] = (OPJ_INT32)(val >> 4);\n\t}\n}\nstatic void convert_6u32s_C1R(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i+=4U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\tpDst[i+0] = (OPJ_INT32)(val0 >> 2);\n\t\tpDst[i+1] = (OPJ_INT32)(((val0 & 0x3U) << 4) | (val1 >> 4));\n\t\tpDst[i+2] = (OPJ_INT32)(((val1 & 0xFU) << 2) | (val2 >> 6));\n\t\tpDst[i+3] = (OPJ_INT32)(val2 & 0x3FU);\n\t\t\n\t}\n\tif (length & 3U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tlength = length & 3U;\n\t\tpDst[i+0] = (OPJ_INT32)(val0 >> 2);\n\t\t\n\t\tif (length > 1U) {\n\t\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\t\tpDst[i+1] = (OPJ_INT32)(((val0 & 0x3U) << 4) | (val1 >> 4));\n\t\t\tif (length > 2U) {\n\t\t\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\t\t\tpDst[i+2] = (OPJ_INT32)(((val1 & 0xFU) << 2) | (val2 >> 6));\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void convert_8u32s_C1R(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < length; i++) {\n\t\tpDst[i] = pSrc[i];\n\t}\n}\nconst convert_XXx32s_C1R convert_XXu32s_C1R_LUT[9] = {\n\tNULL,\n\tconvert_1u32s_C1R,\n\tconvert_2u32s_C1R,\n\tNULL,\n\tconvert_4u32s_C1R,\n\tNULL,\n\tconvert_6u32s_C1R,\n\tNULL,\n\tconvert_8u32s_C1R\n};\n\n\nstatic void convert_32s1u_C1R(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\tOPJ_UINT32 src4 = (OPJ_UINT32)pSrc[i+4];\n\t\tOPJ_UINT32 src5 = (OPJ_UINT32)pSrc[i+5];\n\t\tOPJ_UINT32 src6 = (OPJ_UINT32)pSrc[i+6];\n\t\tOPJ_UINT32 src7 = (OPJ_UINT32)pSrc[i+7];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 7) | (src1 << 6) | (src2 << 5) | (src3 << 4) | (src4 << 3) | (src5 << 2) | (src6 << 1) | src7);\n\t}\n\t\n\tif (length & 7U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = 0U;\n\t\tOPJ_UINT32 src2 = 0U;\n\t\tOPJ_UINT32 src3 = 0U;\n\t\tOPJ_UINT32 src4 = 0U;\n\t\tOPJ_UINT32 src5 = 0U;\n\t\tOPJ_UINT32 src6 = 0U;\n\t\tlength = length & 7U;\n\t\t\n\t\tif (length > 1U) {\n\t\t\tsrc1 = (OPJ_UINT32)pSrc[i+1];\n\t\t\tif (length > 2U) {\n\t\t\t\tsrc2 = (OPJ_UINT32)pSrc[i+2];\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tsrc3 = (OPJ_UINT32)pSrc[i+3];\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tsrc4 = (OPJ_UINT32)pSrc[i+4];\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tsrc5 = (OPJ_UINT32)pSrc[i+5];\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tsrc6 = (OPJ_UINT32)pSrc[i+6];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 7) | (src1 << 6) | (src2 << 5) | (src3 << 4) | (src4 << 3) | (src5 << 2) | (src6 << 1));\n\t}\n}\n\nstatic void convert_32s2u_C1R(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i+=4U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 6) | (src1 << 4) | (src2 << 2) | src3);\n\t}\n\t\n\tif (length & 3U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = 0U;\n\t\tOPJ_UINT32 src2 = 0U;\n\t\tlength = length & 3U;\n\t\t\n\t\tif (length > 1U) {\n\t\t\tsrc1 = (OPJ_UINT32)pSrc[i+1];\n\t\t\tif (length > 2U) {\n\t\t\t\tsrc2 = (OPJ_UINT32)pSrc[i+2];\n\t\t\t}\n\t\t}\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 6) | (src1 << 4) | (src2 << 2));\n\t}\n}\n\nstatic void convert_32s4u_C1R(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)1U); i+=2U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 4) | src1);\n\t}\n\t\n\tif (length & 1U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 4));\n\t}\n}\n\nstatic void convert_32s6u_C1R(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i+=4U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 2) | (src1 >> 4));\n\t\t*pDst++ = (OPJ_BYTE)(((src1 & 0xFU) << 4) | (src2 >> 2));\n\t\t*pDst++ = (OPJ_BYTE)(((src2 & 0x3U) << 6) | src3);\n\t}\n\t\n\tif (length & 3U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = 0U;\n\t\tOPJ_UINT32 src2 = 0U;\n\t\tlength = length & 3U;\n\t\t\n\t\tif (length > 1U) {\n\t\t\tsrc1 = (OPJ_UINT32)pSrc[i+1];\n\t\t\tif (length > 2U) {\n\t\t\t\tsrc2 = (OPJ_UINT32)pSrc[i+2];\n\t\t\t}\n\t\t}\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 2) | (src1 >> 4));\n\t\tif (length > 1U) {\n\t\t\t*pDst++ = (OPJ_BYTE)(((src1 & 0xFU) << 4) | (src2 >> 2));\n\t\t\tif (length > 2U) {\n\t\t\t\t*pDst++ = (OPJ_BYTE)(((src2 & 0x3U) << 6));\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void convert_32s8u_C1R(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < length; ++i) {\n\t\tpDst[i] = (OPJ_BYTE)pSrc[i];\n\t}\n}\nconst convert_32sXXx_C1R convert_32sXXu_C1R_LUT[9] = {\n\tNULL,\n\tconvert_32s1u_C1R,\n\tconvert_32s2u_C1R,\n\tNULL,\n\tconvert_32s4u_C1R,\n\tNULL,\n\tconvert_32s6u_C1R,\n\tNULL,\n\tconvert_32s8u_C1R\n};\n\n/* -->> -->> -->> -->>\n\n  TGA IMAGE FORMAT\n\n <<-- <<-- <<-- <<-- */\n\n#ifdef INFORMATION_ONLY\n/* TGA header definition. */\nstruct tga_header\n{                           \n    unsigned char   id_length;              /* Image id field length    */\n    unsigned char   colour_map_type;        /* Colour map type          */\n    unsigned char   image_type;             /* Image type               */\n    /*\n    ** Colour map specification\n    */\n    unsigned short  colour_map_index;       /* First entry index        */\n    unsigned short  colour_map_length;      /* Colour map length        */\n    unsigned char   colour_map_entry_size;  /* Colour map entry size    */\n    /*\n    ** Image specification\n    */\n    unsigned short  x_origin;               /* x origin of image        */\n    unsigned short  y_origin;               /* u origin of image        */\n    unsigned short  image_width;            /* Image width              */\n    unsigned short  image_height;           /* Image height             */\n    unsigned char   pixel_depth;            /* Pixel depth              */\n    unsigned char   image_desc;             /* Image descriptor         */\n};\n#endif /* INFORMATION_ONLY */\n\nstatic unsigned short get_ushort(const unsigned char *data) {\n    unsigned short val = *(const unsigned short *)data;\n#ifdef OPJ_BIG_ENDIAN\n    val = ((val & 0xffU) << 8) | (val >> 8);\n#endif\n    return val;\n}\n\n#define TGA_HEADER_SIZE 18\n\nstatic int tga_readheader(FILE *fp, unsigned int *bits_per_pixel, \n                          unsigned int *width, unsigned int *height, int *flip_image)\n{\n    int palette_size;\n    unsigned char tga[TGA_HEADER_SIZE];\n    unsigned char id_len, /*cmap_type,*/ image_type;\n    unsigned char pixel_depth, image_desc;\n    unsigned short /*cmap_index,*/ cmap_len, cmap_entry_size;\n    unsigned short /*x_origin, y_origin,*/ image_w, image_h;\n\n    if (!bits_per_pixel || !width || !height || !flip_image)\n        return 0;\n\n    if ( fread(tga, TGA_HEADER_SIZE, 1, fp) != 1 )\n    {\n        fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0 ;\n    }\n    id_len = tga[0];\n    /*cmap_type = tga[1];*/\n    image_type = tga[2];\n    /*cmap_index = get_ushort(&tga[3]);*/\n    cmap_len = get_ushort(&tga[5]);\n    cmap_entry_size = tga[7];\n\n\n#if 0\n    x_origin = get_ushort(&tga[8]);\n    y_origin = get_ushort(&tga[10]);\n#endif\n    image_w = get_ushort(&tga[12]);\n    image_h = get_ushort(&tga[14]);\n    pixel_depth = tga[16];\n    image_desc  = tga[17];\n\n    *bits_per_pixel = (unsigned int)pixel_depth;\n    *width  = (unsigned int)image_w;\n    *height = (unsigned int)image_h;\n\n    /* Ignore tga identifier, if present ... */\n    if (id_len)\n    {\n        unsigned char *id = (unsigned char *) malloc(id_len);\n\t\tif(id == 0){\n\t\t\tfprintf(stderr, \"tga_readheader: memory out\\n\");\n\t\t\treturn 0;\n\t\t}\n        if ( !fread(id, id_len, 1, fp) )\n        {\n            fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n            free(id);\n            return 0 ;\n        }\n        free(id);\n    }\n\n    /* Test for compressed formats ... not yet supported ...\n    // Note :-  9 - RLE encoded palettized.\n    //\t  \t   10 - RLE encoded RGB. */\n    if (image_type > 8)\n    {\n        fprintf(stderr, \"Sorry, compressed tga files are not currently supported.\\n\");\n        return 0 ;\n    }\n\n    *flip_image = !(image_desc & 32);\n\n    /* Palettized formats are not yet supported, skip over the palette, if present ... */\n    palette_size = cmap_len * (cmap_entry_size/8);\n\n    if (palette_size>0)\n    {\n        fprintf(stderr, \"File contains a palette - not yet supported.\");\n        fseek(fp, palette_size, SEEK_CUR);\n    }\n    return 1;\n}\n\n#ifdef OPJ_BIG_ENDIAN\n\nstatic INLINE OPJ_UINT16 swap16(OPJ_UINT16 x)\n{\n    return (OPJ_UINT16)(((x & 0x00ffU) <<  8) | ((x & 0xff00U) >>  8));\n}\n\n#endif\n\nstatic int tga_writeheader(FILE *fp, int bits_per_pixel, int width, int height, \n                           OPJ_BOOL flip_image)\n{\n    OPJ_UINT16 image_w, image_h, us0;\n    unsigned char uc0, image_type;\n    unsigned char pixel_depth, image_desc;\n\n    if (!bits_per_pixel || !width || !height)\n        return 0;\n\n    pixel_depth = 0;\n\n    if ( bits_per_pixel < 256 )\n        pixel_depth = (unsigned char)bits_per_pixel;\n    else{\n        fprintf(stderr,\"ERROR: Wrong bits per pixel inside tga_header\");\n        return 0;\n    }\n    uc0 = 0;\n\n    if(fwrite(&uc0, 1, 1, fp) != 1) goto fails; /* id_length */\n    if(fwrite(&uc0, 1, 1, fp) != 1) goto fails; /* colour_map_type */\n\n    image_type = 2; /* Uncompressed. */\n    if(fwrite(&image_type, 1, 1, fp) != 1) goto fails;\n\n    us0 = 0;\n    if(fwrite(&us0, 2, 1, fp) != 1) goto fails; /* colour_map_index */\n    if(fwrite(&us0, 2, 1, fp) != 1) goto fails; /* colour_map_length */\n    if(fwrite(&uc0, 1, 1, fp) != 1) goto fails; /* colour_map_entry_size */\n\n    if(fwrite(&us0, 2, 1, fp) != 1) goto fails; /* x_origin */\n    if(fwrite(&us0, 2, 1, fp) != 1) goto fails; /* y_origin */\n\n    image_w = (unsigned short)width;\n    image_h = (unsigned short) height;\n\n#ifndef OPJ_BIG_ENDIAN\n    if(fwrite(&image_w, 2, 1, fp) != 1) goto fails;\n    if(fwrite(&image_h, 2, 1, fp) != 1) goto fails;\n#else\n    image_w = swap16(image_w);\n    image_h = swap16(image_h);\n    if(fwrite(&image_w, 2, 1, fp) != 1) goto fails;\n    if(fwrite(&image_h, 2, 1, fp) != 1) goto fails;\n#endif\n\n    if(fwrite(&pixel_depth, 1, 1, fp) != 1) goto fails;\n\n    image_desc = 8; /* 8 bits per component. */\n\n    if (flip_image)\n        image_desc |= 32;\n    if(fwrite(&image_desc, 1, 1, fp) != 1) goto fails;\n\n    return 1;\n\nfails:\n    fputs(\"\\nwrite_tgaheader: write ERROR\\n\", stderr);\n    return 0;\n}\n\nopj_image_t* tgatoimage(const char *filename, opj_cparameters_t *parameters) {\n    FILE *f;\n    opj_image_t *image;\n    unsigned int image_width, image_height, pixel_bit_depth;\n    unsigned int x, y;\n    int flip_image=0;\n    opj_image_cmptparm_t cmptparm[4];\t/* maximum 4 components */\n    int numcomps;\n    OPJ_COLOR_SPACE color_space;\n    OPJ_BOOL mono ;\n    OPJ_BOOL save_alpha;\n    int subsampling_dx, subsampling_dy;\n    int i;\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        fprintf(stderr, \"Failed to open %s for reading !!\\n\", filename);\n        return 0;\n    }\n\n    if (!tga_readheader(f, &pixel_bit_depth, &image_width, &image_height, &flip_image)) {\n        fclose(f);\n        return NULL;\n    }\n\n    /* We currently only support 24 & 32 bit tga's ... */\n    if (!((pixel_bit_depth == 24) || (pixel_bit_depth == 32))) {\n        fclose(f);\n        return NULL;\n    }\n\n    /* initialize image components */\n    memset(&cmptparm[0], 0, 4 * sizeof(opj_image_cmptparm_t));\n\n    mono = (pixel_bit_depth == 8) || (pixel_bit_depth == 16);  /* Mono with & without alpha. */\n    save_alpha = (pixel_bit_depth == 16) || (pixel_bit_depth == 32); /* Mono with alpha, or RGB with alpha */\n\n    if (mono) {\n        color_space = OPJ_CLRSPC_GRAY;\n        numcomps = save_alpha ? 2 : 1;\n    }\n    else {\n        numcomps = save_alpha ? 4 : 3;\n        color_space = OPJ_CLRSPC_SRGB;\n    }\n\n    subsampling_dx = parameters->subsampling_dx;\n    subsampling_dy = parameters->subsampling_dy;\n\n    for (i = 0; i < numcomps; i++) {\n        cmptparm[i].prec = 8;\n        cmptparm[i].bpp = 8;\n        cmptparm[i].sgnd = 0;\n        cmptparm[i].dx = (OPJ_UINT32)subsampling_dx;\n        cmptparm[i].dy = (OPJ_UINT32)subsampling_dy;\n        cmptparm[i].w = image_width;\n        cmptparm[i].h = image_height;\n    }\n\n    /* create the image */\n    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);\n\n    if (!image) {\n        fclose(f);\n        return NULL;\n    }\n\n\n    /* set image offset and reference grid */\n    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n    image->x1 =\t!image->x0 ? (OPJ_UINT32)(image_width - 1)  * (OPJ_UINT32)subsampling_dx + 1 : image->x0 + (OPJ_UINT32)(image_width - 1)  * (OPJ_UINT32)subsampling_dx + 1;\n    image->y1 =\t!image->y0 ? (OPJ_UINT32)(image_height - 1) * (OPJ_UINT32)subsampling_dy + 1 : image->y0 + (OPJ_UINT32)(image_height - 1) * (OPJ_UINT32)subsampling_dy + 1;\n\n    /* set image data */\n    for (y=0; y < image_height; y++)\n    {\n        int index;\n\n        if (flip_image)\n            index = (int)((image_height-y-1)*image_width);\n        else\n            index = (int)(y*image_width);\n\n        if (numcomps==3)\n        {\n            for (x=0;x<image_width;x++)\n            {\n                unsigned char r,g,b;\n\n                if( !fread(&b, 1, 1, f) )\n                {\n                    fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if ( !fread(&g, 1, 1, f) )\n                {\n                    fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if ( !fread(&r, 1, 1, f) )\n                {\n                    fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n\n                image->comps[0].data[index]=r;\n                image->comps[1].data[index]=g;\n                image->comps[2].data[index]=b;\n                index++;\n            }\n        }\n        else if (numcomps==4)\n        {\n            for (x=0;x<image_width;x++)\n            {\n                unsigned char r,g,b,a;\n                if ( !fread(&b, 1, 1, f) )\n                {\n                    fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if ( !fread(&g, 1, 1, f) )\n                {\n                    fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if ( !fread(&r, 1, 1, f) )\n                {\n                    fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if ( !fread(&a, 1, 1, f) )\n                {\n                    fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n\n                image->comps[0].data[index]=r;\n                image->comps[1].data[index]=g;\n                image->comps[2].data[index]=b;\n                image->comps[3].data[index]=a;\n                index++;\n            }\n        }\n        else {\n            fprintf(stderr, \"Currently unsupported bit depth : %s\\n\", filename);\n        }\n    }\n    fclose(f);\n    return image;\n}\n\nint imagetotga(opj_image_t * image, const char *outfile) {\n    int width, height, bpp, x, y;\n    OPJ_BOOL write_alpha;\n    unsigned int i;\n    int adjustR, adjustG, adjustB, fails;\n    unsigned int alpha_channel;\n    float r,g,b,a;\n    unsigned char value;\n    float scale;\n    FILE *fdest;\n    size_t res;\n    fails = 1;\n\n    fdest = fopen(outfile, \"wb\");\n    if (!fdest) {\n        fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n        return 1;\n    }\n\n    for (i = 0; i < image->numcomps-1; i++)\t{\n        if ((image->comps[0].dx != image->comps[i+1].dx)\n                ||(image->comps[0].dy != image->comps[i+1].dy)\n                ||(image->comps[0].prec != image->comps[i+1].prec))\t{\n            fclose(fdest);\n            fprintf(stderr, \"Unable to create a tga file with such J2K image charateristics.\");\n            return 1;\n        }\n    }\n\n    width  = (int)image->comps[0].w;\n    height = (int)image->comps[0].h;\n\n    /* Mono with alpha, or RGB with alpha. */\n    write_alpha = (image->numcomps==2) || (image->numcomps==4);\n\n    /* Write TGA header  */\n    bpp = write_alpha ? 32 : 24;\n\n    if (!tga_writeheader(fdest, bpp, width , height, OPJ_TRUE))\n\t\tgoto fin;\n\n    alpha_channel = image->numcomps-1;\n\n    scale = 255.0f / (float)((1<<image->comps[0].prec)-1);\n\n    adjustR = (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n    adjustG = (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);\n    adjustB = (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);\n\n\tfor (y=0; y < height; y++) \n   {\n\tunsigned int index= (unsigned int)(y*width);\n\n\tfor (x=0; x < width; x++, index++)\t\n  {\n\tr = (float)(image->comps[0].data[index] + adjustR);\n\n\tif (image->numcomps > 2) \n {\n\tg = (float)(image->comps[1].data[index] + adjustG);\n\tb = (float)(image->comps[2].data[index] + adjustB);\n }\n\telse  \n {/* Greyscale ... */\n\tg = r;\n\tb = r;\n }\n\n/* TGA format writes BGR ... */\n\tif(b > 255.) b = 255.; else if(b < 0.) b = 0.;\n\tvalue = (unsigned char)(b*scale);\n\tres = fwrite(&value,1,1,fdest);\n\n\tif( res < 1 ) \n {\n \tfprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n\tgoto fin;\n }\n\tif(g > 255.) g = 255.; else if(g < 0.) g = 0.;\n\tvalue = (unsigned char)(g*scale);\n\tres = fwrite(&value,1,1,fdest);\n\n\tif( res < 1 ) \n {\n\tfprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n\tgoto fin;\n }\n\tif(r > 255.) r = 255.; else if(r < 0.) r = 0.;\n\tvalue = (unsigned char)(r*scale);\n\tres = fwrite(&value,1,1,fdest);\n\n\tif( res < 1 ) \n {\n\tfprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n\tgoto fin;\n }\n\n\tif (write_alpha) \n {\n\ta = (float)(image->comps[alpha_channel].data[index]);\n\tif(a > 255.) a = 255.; else if(a < 0.) a = 0.;\n\tvalue = (unsigned char)(a*scale);\n\tres = fwrite(&value,1,1,fdest);\n\n\t\tif( res < 1 ) \n\t   {\n\t\tfprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n\t\tgoto fin;\n\t   }\n }\n  }\n   }\n\tfails = 0;\nfin:\n\tfclose(fdest);\n\n\treturn fails;\n}\n\n/* -->> -->> -->> -->>\n\nPGX IMAGE FORMAT\n\n<<-- <<-- <<-- <<-- */\n\n\nstatic unsigned char readuchar(FILE * f)\n{\n    unsigned char c1;\n    if ( !fread(&c1, 1, 1, f) )\n    {\n        fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    return c1;\n}\n\nstatic unsigned short readushort(FILE * f, int bigendian)\n{\n    unsigned char c1, c2;\n    if ( !fread(&c1, 1, 1, f) )\n    {\n        fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if ( !fread(&c2, 1, 1, f) )\n    {\n        fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (bigendian)\n        return (unsigned short)((c1 << 8) + c2);\n    else\n        return (unsigned short)((c2 << 8) + c1);\n}\n\nstatic unsigned int readuint(FILE * f, int bigendian)\n{\n    unsigned char c1, c2, c3, c4;\n    if ( !fread(&c1, 1, 1, f) )\n    {\n        fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if ( !fread(&c2, 1, 1, f) )\n    {\n        fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if ( !fread(&c3, 1, 1, f) )\n    {\n        fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if ( !fread(&c4, 1, 1, f) )\n    {\n        fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (bigendian)\n        return (unsigned int)(c1 << 24) + (unsigned int)(c2 << 16) + (unsigned int)(c3 << 8) + c4;\n    else\n        return (unsigned int)(c4 << 24) + (unsigned int)(c3 << 16) + (unsigned int)(c2 << 8) + c1;\n}\n\nopj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters) {\n    FILE *f = NULL;\n    int w, h, prec;\n    int i, numcomps, max;\n    OPJ_COLOR_SPACE color_space;\n    opj_image_cmptparm_t cmptparm;\t/* maximum of 1 component  */\n    opj_image_t * image = NULL;\n    int adjustS, ushift, dshift, force8;\n\n    char endian1,endian2,sign;\n    char signtmp[32];\n\n    char temp[32];\n    int bigendian;\n    opj_image_comp_t *comp = NULL;\n\n    numcomps = 1;\n    color_space = OPJ_CLRSPC_GRAY;\n\n    memset(&cmptparm, 0, sizeof(opj_image_cmptparm_t));\n\n    max = 0;\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        fprintf(stderr, \"Failed to open %s for reading !\\n\", filename);\n        return NULL;\n    }\n\n    fseek(f, 0, SEEK_SET);\n    if( fscanf(f, \"PG%[ \\t]%c%c%[ \\t+-]%d%[ \\t]%d%[ \\t]%d\",temp,&endian1,&endian2,signtmp,&prec,temp,&w,temp,&h) != 9){\n        fclose(f);\n        fprintf(stderr, \"ERROR: Failed to read the right number of element from the fscanf() function!\\n\");\n        return NULL;\n    }\n\n    i=0;\n    sign='+';\n    while (signtmp[i]!='\\0') {\n        if (signtmp[i]=='-') sign='-';\n        i++;\n    }\n\n    fgetc(f);\n    if (endian1=='M' && endian2=='L') {\n        bigendian = 1;\n    } else if (endian2=='M' && endian1=='L') {\n        bigendian = 0;\n    } else {\n        fclose(f);\n        fprintf(stderr, \"Bad pgx header, please check input file\\n\");\n        return NULL;\n    }\n\n    /* initialize image component */\n\n    cmptparm.x0 = (OPJ_UINT32)parameters->image_offset_x0;\n    cmptparm.y0 = (OPJ_UINT32)parameters->image_offset_y0;\n    cmptparm.w = !cmptparm.x0 ? (OPJ_UINT32)((w - 1) * parameters->subsampling_dx + 1) : cmptparm.x0 + (OPJ_UINT32)(w - 1) * (OPJ_UINT32)parameters->subsampling_dx + 1;\n    cmptparm.h = !cmptparm.y0 ? (OPJ_UINT32)((h - 1) * parameters->subsampling_dy + 1) : cmptparm.y0 + (OPJ_UINT32)(h - 1) * (OPJ_UINT32)parameters->subsampling_dy + 1;\n\n    if (sign == '-') {\n        cmptparm.sgnd = 1;\n    } else {\n        cmptparm.sgnd = 0;\n    }\n    if(prec < 8)\n    {\n        force8 = 1;\n        ushift = 8 - prec; dshift = prec - ushift;\n        if(cmptparm.sgnd) adjustS = (1<<(prec - 1)); else adjustS = 0;\n        cmptparm.sgnd = 0;\n        prec = 8;\n    }\n    else ushift = dshift = force8 = adjustS = 0;\n\n    cmptparm.prec = (OPJ_UINT32)prec;\n    cmptparm.bpp = (OPJ_UINT32)prec;\n    cmptparm.dx = (OPJ_UINT32)parameters->subsampling_dx;\n    cmptparm.dy = (OPJ_UINT32)parameters->subsampling_dy;\n\n    /* create the image */\n    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm, color_space);\n    if(!image) {\n        fclose(f);\n        return NULL;\n    }\n    /* set image offset and reference grid */\n    image->x0 = cmptparm.x0;\n    image->y0 = cmptparm.x0;\n    image->x1 = cmptparm.w;\n    image->y1 = cmptparm.h;\n\n    /* set image data */\n\n    comp = &image->comps[0];\n\n    for (i = 0; i < w * h; i++) {\n        int v;\n        if(force8)\n        {\n            v = readuchar(f) + adjustS;\n            v = (v<<ushift) + (v>>dshift);\n            comp->data[i] = (unsigned char)v;\n\n            if(v > max) max = v;\n\n            continue;\n        }\n        if (comp->prec == 8) {\n            if (!comp->sgnd) {\n                v = readuchar(f);\n            } else {\n                v = (char) readuchar(f);\n            }\n        } else if (comp->prec <= 16) {\n            if (!comp->sgnd) {\n                v = readushort(f, bigendian);\n            } else {\n                v = (short) readushort(f, bigendian);\n            }\n        } else {\n            if (!comp->sgnd) {\n                v = (int)readuint(f, bigendian);\n            } else {\n                v = (int) readuint(f, bigendian);\n            }\n        }\n        if (v > max)\n            max = v;\n        comp->data[i] = v;\n    }\n    fclose(f);\n    comp->bpp = (OPJ_UINT32)int_floorlog2(max) + 1;\n\n    return image;\n}\n\n#define CLAMP(x,a,b) x < a ? a : (x > b ? b : x)\n\nstatic INLINE int clamp( const int value, const int prec, const int sgnd )\n{\n  if( sgnd )\n    {\n    if (prec <= 8)       return CLAMP(value,-128,127);\n    else if (prec <= 16) return CLAMP(value,-32768,32767);\n    else                 return CLAMP(value,-2147483647-1,2147483647);\n    }\n  else\n    {\n    if (prec <= 8)       return CLAMP(value,0,255);\n    else if (prec <= 16) return CLAMP(value,0,65535);\n    else                 return value; /*CLAMP(value,0,4294967295);*/\n    }\n}\n\nint imagetopgx(opj_image_t * image, const char *outfile) \n{\n  int w, h;\n  int i, j, fails = 1;\n  unsigned int compno;\n  FILE *fdest = NULL;\n\n  for (compno = 0; compno < image->numcomps; compno++) \n\t{\n    opj_image_comp_t *comp = &image->comps[compno];\n    char bname[256]; /* buffer for name */\n    char *name = bname; /* pointer */\n    int nbytes = 0;\n    size_t res;\n    const size_t olen = strlen(outfile);\n    const size_t dotpos = olen - 4;\n    const size_t total = dotpos + 1 + 1 + 4; /* '-' + '[1-3]' + '.pgx' */\n\n    if( outfile[dotpos] != '.' ) \n\t\t{\n      /* `pgx` was recognized but there is no dot at expected position */\n      fprintf(stderr, \"ERROR -> Impossible happen.\" );\n      goto fin;\n\t\t}\n    if( total > 256 ) \n\t\t{\n      name = (char*)malloc(total+1);\n\t\t\tif (name == NULL) {\n\t\t\t\tfprintf(stderr, \"imagetopgx: memory out\\n\");\n\t\t\t\tgoto fin;\n\t\t\t}\n\t\t}\n    strncpy(name, outfile, dotpos);\n    sprintf(name+dotpos, \"_%u.pgx\", compno);\n    fdest = fopen(name, \"wb\");\n    /* don't need name anymore */\n\t\t\t\n    if (!fdest) \n\t\t{\n\t\t\t\t\n      fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", name);\n\t\t\tif( total > 256 ) free(name);\n      goto fin;\n\t\t}\n\n    w = (int)image->comps[compno].w;\n    h = (int)image->comps[compno].h;\n\n    fprintf(fdest, \"PG ML %c %d %d %d\\n\", comp->sgnd ? '-' : '+', comp->prec,\n      w, h);\n\n    if (comp->prec <= 8) \n      nbytes = 1;\n    else if (comp->prec <= 16)\n      nbytes = 2;\n    else\n      nbytes = 4;\n\n    for (i = 0; i < w * h; i++) \n\t\t{\n      /* FIXME: clamp func is being called within a loop */\n      const int val = clamp(image->comps[compno].data[i],\n        (int)comp->prec, (int)comp->sgnd);\n\n      for (j = nbytes - 1; j >= 0; j--) \n\t\t\t{\n        int v = (int)(val >> (j * 8));\n        unsigned char byte = (unsigned char)v;\n        res = fwrite(&byte, 1, 1, fdest);\n\n        if( res < 1 ) \n\t\t\t\t{\n          fprintf(stderr, \"failed to write 1 byte for %s\\n\", name);\n\t\t\t\t\tif( total > 256 ) free(name);\n          goto fin;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( total > 256 ) free(name);\n    fclose(fdest); fdest = NULL;\n\t}\n  fails = 0;\nfin:\n  if(fdest) fclose(fdest);\n\n  return fails;\n}\n\n/* -->> -->> -->> -->>\n\nPNM IMAGE FORMAT\n\n<<-- <<-- <<-- <<-- */\n\nstruct pnm_header\n{\n    int width, height, maxval, depth, format;\n    char rgb, rgba, gray, graya, bw;\n    char ok;\n};\n\nstatic char *skip_white(char *s)\n{\n    if (s != NULL)\n    {\n        while(*s)\n        {\n            if(*s == '\\n' || *s == '\\r') return NULL;\n            if(isspace(*s)) { ++s; continue; }\n            return s;\n        }\n    }\n    return NULL;\n}\n\nstatic char *skip_int(char *start, int *out_n)\n{\n    char *s;\n    char c;\n\n    *out_n = 0;\n\n    s = skip_white(start);\n    if(s == NULL) return NULL;\n    start = s;\n\n    while(*s)\n    {\n        if( !isdigit(*s)) break;\n        ++s;\n    }\n    c = *s; *s = 0; *out_n = atoi(start); *s = c;\n    return s;\n}\n\nstatic char *skip_idf(char *start, char out_idf[256])\n{\n    char *s;\n    char c;\n\n    s = skip_white(start);\n    if(s == NULL) return NULL;\n    start = s;\n\n    while(*s)\n    {\n        if(isalpha(*s) || *s == '_') { ++s; continue; }\n        break;\n    }\n    c = *s; *s = 0; strncpy(out_idf, start, 255); *s = c;\n    return s;\n}\n\nstatic void read_pnm_header(FILE *reader, struct pnm_header *ph)\n{\n    int format, end, ttype;\n    char idf[256], type[256];\n    char line[256];\n\n    if (fgets(line, 250, reader) == NULL)\n    {\n        fprintf(stderr,\"\\nWARNING: fgets return a NULL value\");\n        return;\n    }\n\n    if(line[0] != 'P')\n    {\n        fprintf(stderr,\"read_pnm_header:PNM:magic P missing\\n\"); return;\n    }\n    format = atoi(line + 1);\n    if(format < 1 || format > 7)\n    {\n        fprintf(stderr,\"read_pnm_header:magic format %d invalid\\n\", format);\n        return;\n    }\n    ph->format = format;\n    ttype = end = 0;\n\n    while(fgets(line, 250, reader))\n    {\n        char *s;\n        int allow_null = 0;\n\n        if(*line == '#') continue;\n\n        s = line;\n\n        if(format == 7)\n        {\n            s = skip_idf(s, idf);\n\n            if(s == NULL || *s == 0) return;\n\n            if(strcmp(idf, \"ENDHDR\") == 0)\n            {\n                end = 1; break;\n            }\n            if(strcmp(idf, \"WIDTH\") == 0)\n            {\n                s = skip_int(s, &ph->width);\n                if(s == NULL || *s == 0) return;\n\n                continue;\n            }\n            if(strcmp(idf, \"HEIGHT\") == 0)\n            {\n                s = skip_int(s, &ph->height);\n                if(s == NULL || *s == 0) return;\n\n                continue;\n            }\n            if(strcmp(idf, \"DEPTH\") == 0)\n            {\n                s = skip_int(s, &ph->depth);\n                if(s == NULL || *s == 0) return;\n\n                continue;\n            }\n            if(strcmp(idf, \"MAXVAL\") == 0)\n            {\n                s = skip_int(s, &ph->maxval);\n                if(s == NULL || *s == 0) return;\n\n                continue;\n            }\n            if(strcmp(idf, \"TUPLTYPE\") == 0)\n            {\n                s = skip_idf(s, type);\n                if(s == NULL || *s == 0) return;\n\n                if(strcmp(type, \"BLACKANDWHITE\") == 0)\n                {\n                    ph->bw = 1; ttype = 1; continue;\n                }\n                if(strcmp(type, \"GRAYSCALE\") == 0)\n                {\n                    ph->gray = 1; ttype = 1; continue;\n                }\n                if(strcmp(type, \"GRAYSCALE_ALPHA\") == 0)\n                {\n                    ph->graya = 1; ttype = 1; continue;\n                }\n                if(strcmp(type, \"RGB\") == 0)\n                {\n                    ph->rgb = 1; ttype = 1; continue;\n                }\n                if(strcmp(type, \"RGB_ALPHA\") == 0)\n                {\n                    ph->rgba = 1; ttype = 1; continue;\n                }\n                fprintf(stderr,\"read_pnm_header:unknown P7 TUPLTYPE %s\\n\",type);\n                return;\n            }\n            fprintf(stderr,\"read_pnm_header:unknown P7 idf %s\\n\",idf);\n            return;\n        } /* if(format == 7) */\n\n        /* Here format is in range [1,6] */\n        if (ph->width == 0) {\n            s = skip_int(s, &ph->width);\n            if ((s == NULL) || (*s == 0) || (ph->width < 1)) return;\n            allow_null = 1;\n        }\n        if (ph->height == 0) {\n            s = skip_int(s, &ph->height);\n            if ((s == NULL) && allow_null) continue;\n            if ((s == NULL) || (*s == 0) || (ph->height < 1)) return;\n            if(format == 1 || format == 4) {\n                break;\n            }\n            allow_null = 1;\n        }\n        /* here, format is in P2, P3, P5, P6 */\n        s = skip_int(s, &ph->maxval);\n        if ((s == NULL) && allow_null) continue;\n        if ((s == NULL) || (*s == 0)) return;\n        break;\n    }/* while(fgets( ) */\n    if(format == 2 || format == 3 || format > 4)\n    {\n        if(ph->maxval < 1 || ph->maxval > 65535) return;\n    }\n    if(ph->width < 1 || ph->height < 1) return;\n\n    if(format == 7)\n    {\n        if(!end)\n        {\n            fprintf(stderr,\"read_pnm_header:P7 without ENDHDR\\n\"); return;\n        }\n        if(ph->depth < 1 || ph->depth > 4) return;\n\n        if (ttype)\n            ph->ok = 1;\n    }\n    else\n    {\n        ph->ok = 1;\n        if(format == 1 || format == 4)\n        {\n            ph->maxval = 255;\n        }\n    }\n}\n\nstatic int has_prec(int val)\n{\n    if(val < 2) return 1;\n    if(val < 4) return 2;\n    if(val < 8) return 3;\n    if(val < 16) return 4;\n    if(val < 32) return 5;\n    if(val < 64) return 6;\n    if(val < 128) return 7;\n    if(val < 256) return 8;\n    if(val < 512) return 9;\n    if(val < 1024) return 10;\n    if(val < 2048) return 11;\n    if(val < 4096) return 12;\n    if(val < 8192) return 13;\n    if(val < 16384) return 14;\n    if(val < 32768) return 15;\n    return 16;\n}\n\nopj_image_t* pnmtoimage(const char *filename, opj_cparameters_t *parameters) {\n    int subsampling_dx = parameters->subsampling_dx;\n    int subsampling_dy = parameters->subsampling_dy;\n\n    FILE *fp = NULL;\n    int i, compno, numcomps, w, h, prec, format;\n    OPJ_COLOR_SPACE color_space;\n    opj_image_cmptparm_t cmptparm[4]; /* RGBA: max. 4 components */\n    opj_image_t * image = NULL;\n    struct pnm_header header_info;\n\n    if((fp = fopen(filename, \"rb\")) == NULL)\n    {\n        fprintf(stderr, \"pnmtoimage:Failed to open %s for reading!\\n\",filename);\n        return NULL;\n    }\n    memset(&header_info, 0, sizeof(struct pnm_header));\n\n    read_pnm_header(fp, &header_info);\n\n    if(!header_info.ok) { fclose(fp); return NULL; }\n\n    format = header_info.format;\n\n    switch(format)\n    {\n    case 1: /* ascii bitmap */\n    case 4: /* raw bitmap */\n        numcomps = 1;\n        break;\n\n    case 2: /* ascii greymap */\n    case 5: /* raw greymap */\n        numcomps = 1;\n        break;\n\n    case 3: /* ascii pixmap */\n    case 6: /* raw pixmap */\n        numcomps = 3;\n        break;\n\n    case 7: /* arbitrary map */\n        numcomps = header_info.depth;\n        break;\n\n    default: fclose(fp); return NULL;\n    }\n    if(numcomps < 3)\n        color_space = OPJ_CLRSPC_GRAY;/* GRAY, GRAYA */\n    else\n        color_space = OPJ_CLRSPC_SRGB;/* RGB, RGBA */\n\n    prec = has_prec(header_info.maxval);\n\n    if(prec < 8) prec = 8;\n\n    w = header_info.width;\n    h = header_info.height;\n    subsampling_dx = parameters->subsampling_dx;\n    subsampling_dy = parameters->subsampling_dy;\n\n    memset(&cmptparm[0], 0, (size_t)numcomps * sizeof(opj_image_cmptparm_t));\n\n    for(i = 0; i < numcomps; i++)\n    {\n        cmptparm[i].prec = (OPJ_UINT32)prec;\n        cmptparm[i].bpp = (OPJ_UINT32)prec;\n        cmptparm[i].sgnd = 0;\n        cmptparm[i].dx = (OPJ_UINT32)subsampling_dx;\n        cmptparm[i].dy = (OPJ_UINT32)subsampling_dy;\n        cmptparm[i].w = (OPJ_UINT32)w;\n        cmptparm[i].h = (OPJ_UINT32)h;\n    }\n    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);\n\n    if(!image) { fclose(fp); return NULL; }\n\n    /* set image offset and reference grid */\n    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n    image->x1 = (OPJ_UINT32)(parameters->image_offset_x0 + (w - 1) * subsampling_dx + 1);\n    image->y1 = (OPJ_UINT32)(parameters->image_offset_y0 + (h - 1) * subsampling_dy + 1);\n\n    if((format == 2) || (format == 3)) /* ascii pixmap */\n    {\n        unsigned int index;\n\n        for (i = 0; i < w * h; i++)\n        {\n            for(compno = 0; compno < numcomps; compno++)\n            {\n                index = 0;\n                if (fscanf(fp, \"%u\", &index) != 1)\n                    fprintf(stderr, \"\\nWARNING: fscanf return a number of element different from the expected.\\n\");\n\n                image->comps[compno].data[i] = (OPJ_INT32)(index * 255)/header_info.maxval;\n            }\n        }\n    }\n    else\n        if((format == 5)\n                || (format == 6)\n                ||((format == 7)\n                   && (   header_info.gray || header_info.graya\n                          || header_info.rgb || header_info.rgba)))/* binary pixmap */\n        {\n            unsigned char c0, c1, one;\n\n            one = (prec < 9);\n\n            for (i = 0; i < w * h; i++)\n            {\n                for(compno = 0; compno < numcomps; compno++)\n                {\n                if ( !fread(&c0, 1, 1, fp) )\n                  {\n                  fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n                  opj_image_destroy(image);\n                  fclose(fp);\n                  return NULL;\n                  }\n                    if(one)\n                    {\n                        image->comps[compno].data[i] = c0;\n                    }\n                    else\n                    {\n                        if ( !fread(&c1, 1, 1, fp) )\n                            fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n                        /* netpbm: */\n                        image->comps[compno].data[i] = ((c0<<8) | c1);\n                    }\n                }\n            }\n        }\n        else\n            if(format == 1) /* ascii bitmap */\n            {\n                for (i = 0; i < w * h; i++)\n                {\n                    unsigned int index;\n\n                    if ( fscanf(fp, \"%u\", &index) != 1)\n                        fprintf(stderr, \"\\nWARNING: fscanf return a number of element different from the expected.\\n\");\n\n                    image->comps[0].data[i] = (index?0:255);\n                }\n            }\n            else\n                if(format == 4)\n                {\n                    int x, y, bit;\n                    unsigned char uc;\n\n                    i = 0;\n                    for(y = 0; y < h; ++y)\n                    {\n                        bit = -1; uc = 0;\n\n                        for(x = 0; x < w; ++x)\n                        {\n                            if(bit == -1)\n                            {\n                                bit = 7;\n                                uc = (unsigned char)getc(fp);\n                            }\n                            image->comps[0].data[i] = (((uc>>bit) & 1)?0:255);\n                            --bit; ++i;\n                        }\n                    }\n                }\n                else\n                    if((format == 7 && header_info.bw)) /*MONO*/\n                    {\n                        unsigned char uc;\n\n                        for(i = 0; i < w * h; ++i)\n                        {\n                            if ( !fread(&uc, 1, 1, fp) )\n                                fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n                            image->comps[0].data[i] = (uc & 1)?0:255;\n                        }\n                    }\n    fclose(fp);\n\n    return image;\n}/* pnmtoimage() */\n\nint imagetopnm(opj_image_t * image, const char *outfile, int force_split)\n{\n    int *red, *green, *blue, *alpha;\n    int wr, hr, max;\n    int i;\n    unsigned int compno, ncomp;\n    int adjustR, adjustG, adjustB, adjustA;\n    int fails, two, want_gray, has_alpha, triple;\n    int prec, v;\n    FILE *fdest = NULL;\n    const char *tmp = outfile;\n    char *destname;\n\n    alpha = NULL;\n\n    if((prec = (int)image->comps[0].prec) > 16)\n    {\n        fprintf(stderr,\"%s:%d:imagetopnm\\n\\tprecision %d is larger than 16\"\n                \"\\n\\t: refused.\\n\",__FILE__,__LINE__,prec);\n        return 1;\n    }\n    two = has_alpha = 0; fails = 1;\n    ncomp = image->numcomps;\n\n    while (*tmp) ++tmp; tmp -= 2;\n    want_gray = (*tmp == 'g' || *tmp == 'G');\n    ncomp = image->numcomps;\n\n    if(want_gray) ncomp = 1;\n\n    if ((force_split == 0) &&\n\t\t\t\t(ncomp == 2 /* GRAYA */\n            || (ncomp > 2 /* RGB, RGBA */\n                && image->comps[0].dx == image->comps[1].dx\n                && image->comps[1].dx == image->comps[2].dx\n                && image->comps[0].dy == image->comps[1].dy\n                && image->comps[1].dy == image->comps[2].dy\n                && image->comps[0].prec == image->comps[1].prec\n                && image->comps[1].prec == image->comps[2].prec\n                )))\n\t\t{\n        fdest = fopen(outfile, \"wb\");\n\n        if (!fdest)\n        {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n            return fails;\n        }\n        two = (prec > 8);\n        triple = (ncomp > 2);\n        wr = (int)image->comps[0].w; hr = (int)image->comps[0].h;\n        max = (1<<prec) - 1; has_alpha = (ncomp == 4 || ncomp == 2);\n\n        red = image->comps[0].data;\n\n        if(triple)\n        {\n            green = image->comps[1].data;\n            blue = image->comps[2].data;\n        }\n        else green = blue = NULL;\n\n        if(has_alpha)\n        {\n            const char *tt = (triple?\"RGB_ALPHA\":\"GRAYSCALE_ALPHA\");\n\n            fprintf(fdest, \"P7\\n# OpenJPEG-%s\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %u\\n\"\n                    \"MAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\", opj_version(),\n                    wr, hr, ncomp, max, tt);\n            alpha = image->comps[ncomp - 1].data;\n            adjustA = (image->comps[ncomp - 1].sgnd ?\n                        1 << (image->comps[ncomp - 1].prec - 1) : 0);\n        }\n        else\n        {\n            fprintf(fdest, \"P6\\n# OpenJPEG-%s\\n%d %d\\n%d\\n\",\n                    opj_version(), wr, hr, max);\n            adjustA = 0;\n        }\n        adjustR = (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n\n        if(triple)\n        {\n            adjustG = (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);\n            adjustB = (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);\n        }\n        else adjustG = adjustB = 0;\n\n        for(i = 0; i < wr * hr; ++i)\n        {\n            if(two)\n            {\n                v = *red + adjustR; ++red;\n                if(v > 65535) v = 65535; else if(v < 0) v = 0;\n\n                /* netpbm: */\n                fprintf(fdest, \"%c%c\",(unsigned char)(v>>8), (unsigned char)v);\n\n                if(triple)\n                {\n                    v = *green + adjustG; ++green;\n                    if(v > 65535) v = 65535; else if(v < 0) v = 0;\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\",(unsigned char)(v>>8), (unsigned char)v);\n\n                    v =  *blue + adjustB; ++blue;\n                    if(v > 65535) v = 65535; else if(v < 0) v = 0;\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\",(unsigned char)(v>>8), (unsigned char)v);\n\n                }/* if(triple) */\n\n                if(has_alpha)\n                {\n                    v = *alpha + adjustA; ++alpha;\n                    if(v > 65535) v = 65535; else if(v < 0) v = 0;\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\",(unsigned char)(v>>8), (unsigned char)v);\n                }\n                continue;\n\n            }\t/* if(two) */\n\n            /* prec <= 8: */\n            v = *red++;\n            if(v > 255) v = 255; else if(v < 0) v = 0;\n\n            fprintf(fdest, \"%c\", (unsigned char)v);\n            if(triple)\n            {\n                v = *green++;\n                if(v > 255) v = 255; else if(v < 0) v = 0;\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n                v = *blue++;\n                if(v > 255) v = 255; else if(v < 0) v = 0;\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n\t\t\t\t\t\t}\n            if(has_alpha)\n            {\n                v = *alpha++;\n                if(v > 255) v = 255; else if(v < 0) v = 0;\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n            }\n        }\t/* for(i */\n\n        fclose(fdest); return 0;\n    }\n\n    /* YUV or MONO: */\n\n    if (image->numcomps > ncomp)\n    {\n        fprintf(stderr,\"WARNING -> [PGM file] Only the first component\\n\");\n        fprintf(stderr,\"           is written to the file\\n\");\n    }\n    destname = (char*)malloc(strlen(outfile) + 8);\n    if(destname == NULL){\n        fprintf(stderr, \"imagetopnm: memory out\\n\");\n        return 1;\n    }\n    for (compno = 0; compno < ncomp; compno++)\n    {\n        if (ncomp > 1)\n        {\n            /*sprintf(destname, \"%d.%s\", compno, outfile);*/\n            const size_t olen = strlen(outfile);\n            const size_t dotpos = olen - 4;\n\n            strncpy(destname, outfile, dotpos);\n            sprintf(destname+dotpos, \"_%u.pgm\", compno);\n        }\n        else\n            sprintf(destname, \"%s\", outfile);\n\n        fdest = fopen(destname, \"wb\");\n        if (!fdest)\n        {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", destname);\n            free(destname);\n            return 1;\n        }\n        wr = (int)image->comps[compno].w; hr = (int)image->comps[compno].h;\n        prec = (int)image->comps[compno].prec;\n        max = (1<<prec) - 1;\n\n        fprintf(fdest, \"P5\\n#OpenJPEG-%s\\n%d %d\\n%d\\n\",\n                opj_version(), wr, hr, max);\n\n        red = image->comps[compno].data;\n        adjustR =\n                (image->comps[compno].sgnd ? 1 << (image->comps[compno].prec - 1) : 0);\n\n        if(prec > 8)\n        {\n            for (i = 0; i < wr * hr; i++)\n            {\n                v = *red + adjustR; ++red;\n                if(v > 65535) v = 65535; else if(v < 0) v = 0;\n\n                /* netpbm: */\n                fprintf(fdest, \"%c%c\",(unsigned char)(v>>8), (unsigned char)v);\n\n                if(has_alpha)\n                {\n                    v = *alpha++;\n                    if(v > 65535) v = 65535; else if(v < 0) v = 0;\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\",(unsigned char)(v>>8), (unsigned char)v);\n                }\n            }/* for(i */\n        }\n        else /* prec <= 8 */\n        {\n            for(i = 0; i < wr * hr; ++i)\n            {\n                v = *red + adjustR; ++red;\n                if(v > 255) v = 255; else if(v < 0) v = 0;\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n            }\n        }\n        fclose(fdest);\n    } /* for (compno */\n    free(destname);\n\n    return 0;\n}/* imagetopnm() */\n\n/* -->> -->> -->> -->>\n\n    RAW IMAGE FORMAT\n\n <<-- <<-- <<-- <<-- */\nstatic opj_image_t* rawtoimage_common(const char *filename, opj_cparameters_t *parameters, raw_cparameters_t *raw_cp, OPJ_BOOL big_endian) {\n    int subsampling_dx = parameters->subsampling_dx;\n    int subsampling_dy = parameters->subsampling_dy;\n\n    FILE *f = NULL;\n    int i, compno, numcomps, w, h;\n    OPJ_COLOR_SPACE color_space;\n    opj_image_cmptparm_t *cmptparm;\n    opj_image_t * image = NULL;\n    unsigned short ch;\n\n    if((! (raw_cp->rawWidth & raw_cp->rawHeight & raw_cp->rawComp & raw_cp->rawBitDepth)) == 0)\n    {\n        fprintf(stderr,\"\\nError: invalid raw image parameters\\n\");\n        fprintf(stderr,\"Please use the Format option -F:\\n\");\n        fprintf(stderr,\"-F <width>,<height>,<ncomp>,<bitdepth>,{s,u}@<dx1>x<dy1>:...:<dxn>x<dyn>\\n\");\n        fprintf(stderr,\"If subsampling is omitted, 1x1 is assumed for all components\\n\");\n        fprintf(stderr,\"Example: -i image.raw -o image.j2k -F 512,512,3,8,u@1x1:2x2:2x2\\n\");\n        fprintf(stderr,\"         for raw 512x512 image with 4:2:0 subsampling\\n\");\n        fprintf(stderr,\"Aborting.\\n\");\n        return NULL;\n    }\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        fprintf(stderr, \"Failed to open %s for reading !!\\n\", filename);\n        fprintf(stderr,\"Aborting\\n\");\n        return NULL;\n    }\n    numcomps = raw_cp->rawComp;\n\n    /* FIXME ADE at this point, tcp_mct has not been properly set in calling function */\n    if (numcomps == 1) {\n        color_space = OPJ_CLRSPC_GRAY;\n    } else if ((numcomps >= 3) && (parameters->tcp_mct == 0)) {\n        color_space = OPJ_CLRSPC_SYCC;\n    } else if ((numcomps >= 3) && (parameters->tcp_mct != 2)) {\n        color_space = OPJ_CLRSPC_SRGB;\n    } else {\n        color_space = OPJ_CLRSPC_UNKNOWN;\n    }\n    w = raw_cp->rawWidth;\n    h = raw_cp->rawHeight;\n    cmptparm = (opj_image_cmptparm_t*) calloc((OPJ_UINT32)numcomps,sizeof(opj_image_cmptparm_t));\n    if (!cmptparm) {\n        fprintf(stderr, \"Failed to allocate image components parameters !!\\n\");\n        fprintf(stderr,\"Aborting\\n\");\n        fclose(f);\n        return NULL;\n    }\n    /* initialize image components */\n    for(i = 0; i < numcomps; i++) {\n        cmptparm[i].prec = (OPJ_UINT32)raw_cp->rawBitDepth;\n        cmptparm[i].bpp = (OPJ_UINT32)raw_cp->rawBitDepth;\n        cmptparm[i].sgnd = (OPJ_UINT32)raw_cp->rawSigned;\n        cmptparm[i].dx = (OPJ_UINT32)(subsampling_dx * raw_cp->rawComps[i].dx);\n        cmptparm[i].dy = (OPJ_UINT32)(subsampling_dy * raw_cp->rawComps[i].dy);\n        cmptparm[i].w = (OPJ_UINT32)w;\n        cmptparm[i].h = (OPJ_UINT32)h;\n    }\n    /* create the image */\n    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);\n    free(cmptparm);\n    if(!image) {\n        fclose(f);\n        return NULL;\n    }\n    /* set image offset and reference grid */\n    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n    image->x1 = (OPJ_UINT32)parameters->image_offset_x0 + (OPJ_UINT32)(w - 1) *\t(OPJ_UINT32)subsampling_dx + 1;\n    image->y1 = (OPJ_UINT32)parameters->image_offset_y0 + (OPJ_UINT32)(h - 1) * (OPJ_UINT32)subsampling_dy + 1;\n\n    if(raw_cp->rawBitDepth <= 8)\n    {\n        unsigned char value = 0;\n        for(compno = 0; compno < numcomps; compno++) {\n            int nloop = (w*h)/(raw_cp->rawComps[compno].dx*raw_cp->rawComps[compno].dy);\n            for (i = 0; i < nloop; i++) {\n                if (!fread(&value, 1, 1, f)) {\n                    fprintf(stderr,\"Error reading raw file. End of file probably reached.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                image->comps[compno].data[i] = raw_cp->rawSigned?(char)value:value;\n            }\n        }\n    }\n    else if(raw_cp->rawBitDepth <= 16)\n    {\n        unsigned short value;\n        for(compno = 0; compno < numcomps; compno++) {\n            int nloop = (w*h)/(raw_cp->rawComps[compno].dx*raw_cp->rawComps[compno].dy);\n            for (i = 0; i < nloop; i++) {\n                unsigned char temp1;\n                unsigned char temp2;\n                if (!fread(&temp1, 1, 1, f)) {\n                    fprintf(stderr,\"Error reading raw file. End of file probably reached.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if (!fread(&temp2, 1, 1, f)) {\n                    fprintf(stderr,\"Error reading raw file. End of file probably reached.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if( big_endian )\n                {\n                    value = (unsigned short)((temp1 << 8) + temp2);\n                }\n                else\n                {\n                    value = (unsigned short)((temp2 << 8) + temp1);\n                }\n                image->comps[compno].data[i] = raw_cp->rawSigned?(short)value:value;\n            }\n        }\n    }\n    else {\n        fprintf(stderr,\"OpenJPEG cannot encode raw components with bit depth higher than 16 bits.\\n\");\n        opj_image_destroy(image);\n        fclose(f);\n        return NULL;\n    }\n\n    if (fread(&ch, 1, 1, f)) {\n        fprintf(stderr,\"Warning. End of raw file not reached... processing anyway\\n\");\n    }\n    fclose(f);\n\n    return image;\n}\n\nopj_image_t* rawltoimage(const char *filename, opj_cparameters_t *parameters, raw_cparameters_t *raw_cp) {\n    return rawtoimage_common(filename, parameters, raw_cp, OPJ_FALSE);\n}\n\nopj_image_t* rawtoimage(const char *filename, opj_cparameters_t *parameters, raw_cparameters_t *raw_cp) {\n    return rawtoimage_common(filename, parameters, raw_cp, OPJ_TRUE);\n}\n\nstatic int imagetoraw_common(opj_image_t * image, const char *outfile, OPJ_BOOL big_endian)\n{\n    FILE *rawFile = NULL;\n    size_t res;\n    unsigned int compno;\n    int w, h, fails;\n    int line, row, curr, mask;\n    int *ptr;\n    unsigned char uc;\n    (void)big_endian;\n\n    if((image->numcomps * image->x1 * image->y1) == 0)\n    {\n        fprintf(stderr,\"\\nError: invalid raw image parameters\\n\");\n        return 1;\n    }\n\n    rawFile = fopen(outfile, \"wb\");\n    if (!rawFile) {\n        fprintf(stderr, \"Failed to open %s for writing !!\\n\", outfile);\n        return 1;\n    }\n\n    fails = 1;\n    fprintf(stdout,\"Raw image characteristics: %d components\\n\", image->numcomps);\n\n    for(compno = 0; compno < image->numcomps; compno++)\n    {\n        fprintf(stdout,\"Component %u characteristics: %dx%dx%d %s\\n\", compno, image->comps[compno].w,\n                image->comps[compno].h, image->comps[compno].prec, image->comps[compno].sgnd==1 ? \"signed\": \"unsigned\");\n\n        w = (int)image->comps[compno].w;\n        h = (int)image->comps[compno].h;\n\n        if(image->comps[compno].prec <= 8)\n        {\n            if(image->comps[compno].sgnd == 1)\n            {\n                mask = (1 << image->comps[compno].prec) - 1;\n                ptr = image->comps[compno].data;\n                for (line = 0; line < h; line++) {\n                    for(row = 0; row < w; row++)\t{\n                        curr = *ptr;\n                        if(curr > 127) curr = 127; else if(curr < -128) curr = -128;\n                        uc = (unsigned char) (curr & mask);\n                        res = fwrite(&uc, 1, 1, rawFile);\n                        if( res < 1 ) {\n                            fprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n                            goto fin;\n                        }\n                        ptr++;\n                    }\n                }\n            }\n            else if(image->comps[compno].sgnd == 0)\n            {\n                mask = (1 << image->comps[compno].prec) - 1;\n                ptr = image->comps[compno].data;\n                for (line = 0; line < h; line++) {\n                    for(row = 0; row < w; row++)\t{\n                        curr = *ptr;\n                        if(curr > 255) curr = 255; else if(curr < 0) curr = 0;\n                        uc = (unsigned char) (curr & mask);\n                        res = fwrite(&uc, 1, 1, rawFile);\n                        if( res < 1 ) {\n                            fprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n                            goto fin;\n                        }\n                        ptr++;\n                    }\n                }\n            }\n        }\n        else if(image->comps[compno].prec <= 16)\n        {\n            if(image->comps[compno].sgnd == 1)\n            {\n                union { signed short val; signed char vals[2]; } uc16;\n                mask = (1 << image->comps[compno].prec) - 1;\n                ptr = image->comps[compno].data;\n                for (line = 0; line < h; line++) {\n                    for(row = 0; row < w; row++)\t{\n                        curr = *ptr;\n                        if(curr > 32767 ) curr = 32767; else if( curr < -32768) curr = -32768;\n                        uc16.val = (signed short)(curr & mask);\n                        res = fwrite(uc16.vals, 1, 2, rawFile);\n                        if( res < 2 ) {\n                            fprintf(stderr, \"failed to write 2 byte for %s\\n\", outfile);\n                            goto fin;\n                        }\n                        ptr++;\n                    }\n                }\n            }\n            else if(image->comps[compno].sgnd == 0)\n            {\n                union { unsigned short val; unsigned char vals[2]; } uc16;\n                mask = (1 << image->comps[compno].prec) - 1;\n                ptr = image->comps[compno].data;\n                for (line = 0; line < h; line++) {\n                    for(row = 0; row < w; row++)\t{\n                        curr = *ptr;\n                        if(curr > 65535 ) curr = 65535; else if( curr < 0) curr = 0;\n                        uc16.val = (unsigned short)(curr & mask);\n                        res = fwrite(uc16.vals, 1, 2, rawFile);\n                        if( res < 2 ) {\n                            fprintf(stderr, \"failed to write 2 byte for %s\\n\", outfile);\n                            goto fin;\n                        }\n                        ptr++;\n                    }\n                }\n            }\n        }\n        else if (image->comps[compno].prec <= 32)\n        {\n            fprintf(stderr,\"More than 16 bits per component no handled yet\\n\");\n            goto fin;\n        }\n        else\n        {\n            fprintf(stderr,\"Error: invalid precision: %d\\n\", image->comps[compno].prec);\n            goto fin;\n        }\n    }\n  fails = 0;\nfin:\n    fclose(rawFile);\n    return fails;\n}\n\nint imagetoraw(opj_image_t * image, const char *outfile)\n{\n    return imagetoraw_common(image, outfile, OPJ_TRUE);\n}\n\nint imagetorawl(opj_image_t * image, const char *outfile)\n{\n    return imagetoraw_common(image, outfile, OPJ_FALSE);\n}\n\n", "/*\n * The copyright in this software is being made available under the 2-clauses \n * BSD License, included below. This software may be subject to other third \n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux \n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#include \"opj_apps_config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"openjpeg.h\"\n#include \"convert.h\"\n\ntypedef struct {\n\tOPJ_UINT16 bfType;      /* 'BM' for Bitmap (19776) */\n\tOPJ_UINT32 bfSize;      /* Size of the file        */\n\tOPJ_UINT16 bfReserved1; /* Reserved : 0            */\n\tOPJ_UINT16 bfReserved2; /* Reserved : 0            */\n\tOPJ_UINT32 bfOffBits;   /* Offset                  */\n} OPJ_BITMAPFILEHEADER;\n\ntypedef struct {\n\tOPJ_UINT32 biSize;             /* Size of the structure in bytes */\n\tOPJ_UINT32 biWidth;            /* Width of the image in pixels */\n\tOPJ_UINT32 biHeight;           /* Heigth of the image in pixels */\n\tOPJ_UINT16 biPlanes;           /* 1 */\n\tOPJ_UINT16 biBitCount;         /* Number of color bits by pixels */\n\tOPJ_UINT32 biCompression;      /* Type of encoding 0: none 1: RLE8 2: RLE4 */\n\tOPJ_UINT32 biSizeImage;        /* Size of the image in bytes */\n\tOPJ_UINT32 biXpelsPerMeter;    /* Horizontal (X) resolution in pixels/meter */\n\tOPJ_UINT32 biYpelsPerMeter;    /* Vertical (Y) resolution in pixels/meter */\n\tOPJ_UINT32 biClrUsed;          /* Number of color used in the image (0: ALL) */\n\tOPJ_UINT32 biClrImportant;     /* Number of important color (0: ALL) */\n\tOPJ_UINT32 biRedMask;          /* Red channel bit mask */\n\tOPJ_UINT32 biGreenMask;        /* Green channel bit mask */\n\tOPJ_UINT32 biBlueMask;         /* Blue channel bit mask */\n\tOPJ_UINT32 biAlphaMask;        /* Alpha channel bit mask */\n\tOPJ_UINT32 biColorSpaceType;   /* Color space type */\n\tOPJ_UINT8  biColorSpaceEP[36]; /* Color space end points */\n\tOPJ_UINT32 biRedGamma;         /* Red channel gamma */\n\tOPJ_UINT32 biGreenGamma;       /* Green channel gamma */\n\tOPJ_UINT32 biBlueGamma;        /* Blue channel gamma */\n\tOPJ_UINT32 biIntent;           /* Intent */\n\tOPJ_UINT32 biIccProfileData;   /* ICC profile data */\n\tOPJ_UINT32 biIccProfileSize;   /* ICC profile size */\n\tOPJ_UINT32 biReserved;         /* Reserved */\n} OPJ_BITMAPINFOHEADER;\n\nstatic void opj_applyLUT8u_8u32s_C1R(\n\tOPJ_UINT8 const* pSrc, OPJ_INT32 srcStride,\n\tOPJ_INT32* pDst, OPJ_INT32 dstStride,\n\tOPJ_UINT8 const* pLUT,\n\tOPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 y;\n\t\n\tfor (y = height; y != 0U; --y) {\n\t\tOPJ_UINT32 x;\n\t\t\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tpDst[x] = (OPJ_INT32)pLUT[pSrc[x]];\n\t\t}\n\t\tpSrc += srcStride;\n\t\tpDst += dstStride;\n\t}\n}\n\nstatic void opj_applyLUT8u_8u32s_C1P3R(\n\tOPJ_UINT8 const* pSrc, OPJ_INT32 srcStride,\n\tOPJ_INT32* const* pDst, OPJ_INT32 const* pDstStride,\n\tOPJ_UINT8 const* const* pLUT,\n\tOPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 y;\n\tOPJ_INT32* pR = pDst[0];\n\tOPJ_INT32* pG = pDst[1];\n\tOPJ_INT32* pB = pDst[2];\n\tOPJ_UINT8 const* pLUT_R = pLUT[0];\n\tOPJ_UINT8 const* pLUT_G = pLUT[1];\n\tOPJ_UINT8 const* pLUT_B = pLUT[2];\n\t\n\tfor (y = height; y != 0U; --y) {\n\t\tOPJ_UINT32 x;\n\t\t\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tOPJ_UINT8 idx = pSrc[x];\n\t\t\tpR[x] = (OPJ_INT32)pLUT_R[idx];\n\t\t\tpG[x] = (OPJ_INT32)pLUT_G[idx];\n\t\t\tpB[x] = (OPJ_INT32)pLUT_B[idx];\n\t\t}\n\t\tpSrc += srcStride;\n\t\tpR += pDstStride[0];\n\t\tpG += pDstStride[1];\n\t\tpB += pDstStride[2];\n\t}\n}\n\nstatic void bmp24toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image)\n{\n\tint index;\n\tOPJ_UINT32 width, height;\n\tOPJ_UINT32 x, y;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\tindex = 0;\n\tpSrc = pData + (height - 1U) * stride;\n\tfor(y = 0; y < height; y++)\n\t{\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\timage->comps[0].data[index] = (OPJ_INT32)pSrc[3*x+2];\t/* R */\n\t\t\timage->comps[1].data[index] = (OPJ_INT32)pSrc[3*x+1];\t/* G */\n\t\t\timage->comps[2].data[index] = (OPJ_INT32)pSrc[3*x+0];\t/* B */\n\t\t\tindex++;\n\t\t}\n\t\tpSrc -= stride;\n\t}\n}\n\nstatic void bmp_mask_get_shift_and_prec(OPJ_UINT32 mask, OPJ_UINT32* shift, OPJ_UINT32* prec)\n{\n\tOPJ_UINT32 l_shift, l_prec;\n\t\n\tl_shift = l_prec = 0U;\n\t\n\tif (mask != 0U) {\n\t\twhile ((mask & 1U) == 0U) {\n\t\t\tmask >>= 1;\n\t\t\tl_shift++;\n\t\t}\n\t\twhile (mask & 1U) {\n\t\t\tmask >>= 1;\n\t\t\tl_prec++;\n\t\t}\n\t}\n\t*shift = l_shift; *prec = l_prec;\n}\n\nstatic void bmpmask32toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image, OPJ_UINT32 redMask, OPJ_UINT32 greenMask, OPJ_UINT32 blueMask, OPJ_UINT32 alphaMask)\n{\n\tint index;\n\tOPJ_UINT32 width, height;\n\tOPJ_UINT32 x, y;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\tOPJ_BOOL hasAlpha;\n\tOPJ_UINT32 redShift,   redPrec;\n\tOPJ_UINT32 greenShift, greenPrec;\n\tOPJ_UINT32 blueShift,  bluePrec;\n\tOPJ_UINT32 alphaShift, alphaPrec;\n\t\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\thasAlpha = image->numcomps > 3U;\n\t\n\tbmp_mask_get_shift_and_prec(redMask,   &redShift,   &redPrec);\n\tbmp_mask_get_shift_and_prec(greenMask, &greenShift, &greenPrec);\n\tbmp_mask_get_shift_and_prec(blueMask,  &blueShift,  &bluePrec);\n\tbmp_mask_get_shift_and_prec(alphaMask, &alphaShift, &alphaPrec);\n\t\n\timage->comps[0].bpp = redPrec;\n\timage->comps[0].prec = redPrec;\n\timage->comps[1].bpp = greenPrec;\n\timage->comps[1].prec = greenPrec;\n\timage->comps[2].bpp = bluePrec;\n\timage->comps[2].prec = bluePrec;\n\tif (hasAlpha) {\n\t\timage->comps[3].bpp = alphaPrec;\n\t\timage->comps[3].prec = alphaPrec;\n\t}\n\t\n\tindex = 0;\n\tpSrc = pData + (height - 1U) * stride;\n\tfor(y = 0; y < height; y++)\n\t{\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tOPJ_UINT32 value = 0U;\n\t\t\t\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+0]) <<  0;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+1]) <<  8;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+2]) << 16;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+3]) << 24;\n\t\t\t\n\t\t\timage->comps[0].data[index] = (OPJ_INT32)((value & redMask)   >> redShift);   /* R */\n\t\t\timage->comps[1].data[index] = (OPJ_INT32)((value & greenMask) >> greenShift); /* G */\n\t\t\timage->comps[2].data[index] = (OPJ_INT32)((value & blueMask)  >> blueShift);  /* B */\n\t\t\tif (hasAlpha) {\n\t\t\t\timage->comps[3].data[index] = (OPJ_INT32)((value & alphaMask)  >> alphaShift);  /* A */\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tpSrc -= stride;\n\t}\n}\n\nstatic void bmpmask16toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image, OPJ_UINT32 redMask, OPJ_UINT32 greenMask, OPJ_UINT32 blueMask, OPJ_UINT32 alphaMask)\n{\n\tint index;\n\tOPJ_UINT32 width, height;\n\tOPJ_UINT32 x, y;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\tOPJ_BOOL hasAlpha;\n\tOPJ_UINT32 redShift,   redPrec;\n\tOPJ_UINT32 greenShift, greenPrec;\n\tOPJ_UINT32 blueShift,  bluePrec;\n\tOPJ_UINT32 alphaShift, alphaPrec;\n\t\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\thasAlpha = image->numcomps > 3U;\n\t\n\tbmp_mask_get_shift_and_prec(redMask,   &redShift,   &redPrec);\n\tbmp_mask_get_shift_and_prec(greenMask, &greenShift, &greenPrec);\n\tbmp_mask_get_shift_and_prec(blueMask,  &blueShift,  &bluePrec);\n\tbmp_mask_get_shift_and_prec(alphaMask, &alphaShift, &alphaPrec);\n\t\n\timage->comps[0].bpp = redPrec;\n\timage->comps[0].prec = redPrec;\n\timage->comps[1].bpp = greenPrec;\n\timage->comps[1].prec = greenPrec;\n\timage->comps[2].bpp = bluePrec;\n\timage->comps[2].prec = bluePrec;\n\tif (hasAlpha) {\n\t\timage->comps[3].bpp = alphaPrec;\n\t\timage->comps[3].prec = alphaPrec;\n\t}\n\t\n\tindex = 0;\n\tpSrc = pData + (height - 1U) * stride;\n\tfor(y = 0; y < height; y++)\n\t{\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tOPJ_UINT32 value = 0U;\n\t\t\t\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[2*x+0]) <<  0;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[2*x+1]) <<  8;\n\t\t\t\n\t\t\timage->comps[0].data[index] = (OPJ_INT32)((value & redMask)   >> redShift);   /* R */\n\t\t\timage->comps[1].data[index] = (OPJ_INT32)((value & greenMask) >> greenShift); /* G */\n\t\t\timage->comps[2].data[index] = (OPJ_INT32)((value & blueMask)  >> blueShift);  /* B */\n\t\t\tif (hasAlpha) {\n\t\t\t\timage->comps[3].data[index] = (OPJ_INT32)((value & alphaMask)  >> alphaShift);  /* A */\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tpSrc -= stride;\n\t}\n}\n\nstatic opj_image_t* bmp8toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image, OPJ_UINT8 const* const* pLUT)\n{\n\tOPJ_UINT32 width, height;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\t\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\tpSrc = pData + (height - 1U) * stride;\n\tif (image->numcomps == 1U) {\n\t\topj_applyLUT8u_8u32s_C1R(pSrc, -(OPJ_INT32)stride, image->comps[0].data, (OPJ_INT32)width, pLUT[0], width, height);\n\t}\n\telse {\n\t\tOPJ_INT32* pDst[3];\n\t\tOPJ_INT32  pDstStride[3];\n\t\t\n\t\tpDst[0] = image->comps[0].data; pDst[1] = image->comps[1].data; pDst[2] = image->comps[2].data;\n\t\tpDstStride[0] = (OPJ_INT32)width; pDstStride[1] = (OPJ_INT32)width; pDstStride[2] = (OPJ_INT32)width;\n\t\topj_applyLUT8u_8u32s_C1P3R(pSrc, -(OPJ_INT32)stride, pDst, pDstStride, pLUT, width, height);\n\t}\n\treturn image;\n}\n\nstatic OPJ_BOOL bmp_read_file_header(FILE* IN, OPJ_BITMAPFILEHEADER* header)\n{\n\theader->bfType  = (OPJ_UINT16)getc(IN);\n\theader->bfType |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\tif (header->bfType != 19778) {\n\t\tfprintf(stderr,\"Error, not a BMP file!\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\t\n\t/* FILE HEADER */\n\t/* ------------- */\n\theader->bfSize  = (OPJ_UINT32)getc(IN);\n\theader->bfSize |= (OPJ_UINT32)getc(IN) << 8;\n\theader->bfSize |= (OPJ_UINT32)getc(IN) << 16;\n\theader->bfSize |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\theader->bfReserved1  = (OPJ_UINT16)getc(IN);\n\theader->bfReserved1 |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\theader->bfReserved2  = (OPJ_UINT16)getc(IN);\n\theader->bfReserved2 |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\theader->bfOffBits  = (OPJ_UINT32)getc(IN);\n\theader->bfOffBits |= (OPJ_UINT32)getc(IN) << 8;\n\theader->bfOffBits |= (OPJ_UINT32)getc(IN) << 16;\n\theader->bfOffBits |= (OPJ_UINT32)getc(IN) << 24;\n\treturn OPJ_TRUE;\n}\nstatic OPJ_BOOL bmp_read_info_header(FILE* IN, OPJ_BITMAPINFOHEADER* header)\n{\n\tmemset(header, 0, sizeof(*header));\n\t/* INFO HEADER */\n\t/* ------------- */\n\theader->biSize  = (OPJ_UINT32)getc(IN);\n\theader->biSize |= (OPJ_UINT32)getc(IN) << 8;\n\theader->biSize |= (OPJ_UINT32)getc(IN) << 16;\n\theader->biSize |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\tswitch (header->biSize) {\n\t\tcase 12U:  /* BITMAPCOREHEADER */\n\t\tcase 40U:  /* BITMAPINFOHEADER */\n\t\tcase 52U:  /* BITMAPV2INFOHEADER */\n\t\tcase 56U:  /* BITMAPV3INFOHEADER */\n\t\tcase 108U: /* BITMAPV4HEADER */\n\t\tcase 124U: /* BITMAPV5HEADER */\n\t\t\tbreak;\n  default:\n\t\t\tfprintf(stderr,\"Error, unknown BMP header size %d\\n\", header->biSize);\n\t\t\treturn OPJ_FALSE;\n\t}\n\t\n\theader->biWidth  = (OPJ_UINT32)getc(IN);\n\theader->biWidth |= (OPJ_UINT32)getc(IN) << 8;\n\theader->biWidth |= (OPJ_UINT32)getc(IN) << 16;\n\theader->biWidth |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\theader->biHeight  = (OPJ_UINT32)getc(IN);\n\theader->biHeight |= (OPJ_UINT32)getc(IN) << 8;\n\theader->biHeight |= (OPJ_UINT32)getc(IN) << 16;\n\theader->biHeight |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\theader->biPlanes  = (OPJ_UINT16)getc(IN);\n\theader->biPlanes |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\theader->biBitCount  = (OPJ_UINT16)getc(IN);\n\theader->biBitCount |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\tif(header->biSize >= 40U) {\n\t\theader->biCompression  = (OPJ_UINT32)getc(IN);\n\t\theader->biCompression |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biCompression |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biCompression |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biSizeImage  = (OPJ_UINT32)getc(IN);\n\t\theader->biSizeImage |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biSizeImage |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biSizeImage |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biXpelsPerMeter  = (OPJ_UINT32)getc(IN);\n\t\theader->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biYpelsPerMeter  = (OPJ_UINT32)getc(IN);\n\t\theader->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biClrUsed  = (OPJ_UINT32)getc(IN);\n\t\theader->biClrUsed |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biClrUsed |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biClrUsed |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biClrImportant  = (OPJ_UINT32)getc(IN);\n\t\theader->biClrImportant |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biClrImportant |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biClrImportant |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\t\n\tif(header->biSize >= 56U) {\n\t\theader->biRedMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biRedMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biRedMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biRedMask |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biGreenMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biGreenMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biGreenMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biGreenMask |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biBlueMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biBlueMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biBlueMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biBlueMask |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biAlphaMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biAlphaMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biAlphaMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biAlphaMask |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\t\n\tif(header->biSize >= 108U) {\n\t\theader->biColorSpaceType  = (OPJ_UINT32)getc(IN);\n\t\theader->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\tif (fread(&(header->biColorSpaceEP), 1U, sizeof(header->biColorSpaceEP), IN) != sizeof(header->biColorSpaceEP)) {\n\t\t\tfprintf(stderr,\"Error, can't  read BMP header\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t\n\t\theader->biRedGamma  = (OPJ_UINT32)getc(IN);\n\t\theader->biRedGamma |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biRedGamma |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biRedGamma |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biGreenGamma  = (OPJ_UINT32)getc(IN);\n\t\theader->biGreenGamma |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biGreenGamma |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biGreenGamma |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biBlueGamma  = (OPJ_UINT32)getc(IN);\n\t\theader->biBlueGamma |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biBlueGamma |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biBlueGamma |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\t\n\tif(header->biSize >= 124U) {\n\t\theader->biIntent  = (OPJ_UINT32)getc(IN);\n\t\theader->biIntent |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biIntent |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biIntent |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biIccProfileData  = (OPJ_UINT32)getc(IN);\n\t\theader->biIccProfileData |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biIccProfileData |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biIccProfileData |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biIccProfileSize  = (OPJ_UINT32)getc(IN);\n\t\theader->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biReserved  = (OPJ_UINT32)getc(IN);\n\t\theader->biReserved |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biReserved |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biReserved |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_raw_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_ARG_NOT_USED(width);\n\t\n\tif ( fread(pData, sizeof(OPJ_UINT8), stride * height, IN) != (stride * height) )\n\t{\n\t\tfprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 x, y;\n\tOPJ_UINT8 *pix;\n\tconst OPJ_UINT8 *beyond;\n\t\n\tbeyond = pData + stride * height;\n\tpix = pData;\n\t\n\tx = y = 0U;\n\twhile (y < height)\n\t{\n\t\tint c = getc(IN);\n\t\t\n\t\tif (c) {\n\t\t\tint j;\n\t\t\tOPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n\t\t\t\n\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n\t\t\t\t*pix = c1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tc = getc(IN);\n\t\t\tif (c == 0x00) { /* EOL */\n\t\t\t\tx = 0;\n\t\t\t\t++y;\n\t\t\t\tpix = pData + y * stride + x;\n\t\t\t}\n\t\t\telse if (c == 0x01) { /* EOP */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (c == 0x02) { /* MOVE by dxdy */\n\t\t\t\tc = getc(IN);\n\t\t\t\tx += (OPJ_UINT32)c;\n\t\t\t\tc = getc(IN);\n\t\t\t\ty += (OPJ_UINT32)c;\n\t\t\t\tpix = pData + y * stride + x;\n\t\t\t}\n\t\t\telse /* 03 .. 255 */\n\t\t\t{\n\t\t\t\tint j;\n\t\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++)\n\t\t\t\t{\n\t\t\t\t\tOPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n\t\t\t\t\t*pix = c1;\n\t\t\t\t}\n\t\t\t\tif ((OPJ_UINT32)c & 1U) { /* skip padding byte */\n\t\t\t\t\tgetc(IN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}/* while() */\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 x, y;\n\tOPJ_UINT8 *pix;\n\tconst OPJ_UINT8 *beyond;\n\t\n\tbeyond = pData + stride * height;\n\tpix = pData;\n\tx = y = 0U;\n\twhile(y < height)\n\t{\n\t\tint c = getc(IN);\n\t\tif(c == EOF) break;\n\t\t\n\t\tif(c) {/* encoded mode */\n\t\t\tint j;\n\t\t\tOPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n\t\t\n\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n\t\t\t\t*pix = (OPJ_UINT8)((j&1) ? (c1 & 0x0fU) : ((c1>>4)&0x0fU));\n\t\t\t}\n\t\t}\n\t\telse { /* absolute mode */\n\t\t\tc = getc(IN);\n\t\t\tif(c == EOF) break;\n\t\t\n\t\t\tif(c == 0x00) { /* EOL */\n\t\t\t\tx = 0;  y++;  pix = pData + y * stride;\n\t\t\t}\n\t\t\telse if(c == 0x01) { /* EOP */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(c == 0x02) { /* MOVE by dxdy */\n\t\t\t\tc = getc(IN);  x += (OPJ_UINT32)c;\n\t\t\t\tc = getc(IN);  y += (OPJ_UINT32)c;\n\t\t\t\tpix = pData + y * stride + x;\n\t\t\t}\n\t\t\telse { /* 03 .. 255 : absolute mode */\n\t\t\t\tint j;\n\t\t\t\tOPJ_UINT8 c1 = 0U;\n\t\t\t\t\n\t\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n\t\t\t\t\tif((j&1) == 0) {\n\t\t\t\t\t\t\tc1 = (OPJ_UINT8)getc(IN);\n\t\t\t\t\t}\n\t\t\t\t\t*pix =  (OPJ_UINT8)((j&1) ? (c1 & 0x0fU) : ((c1>>4)&0x0fU));\n\t\t\t\t}\n\t\t\t\tif(((c&3) == 1) || ((c&3) == 2)) { /* skip padding byte */\n\t\t\t\t\t\tgetc(IN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}  /* while(y < height) */\n\treturn OPJ_TRUE;\n}\n\nopj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters)\n{\n\topj_image_cmptparm_t cmptparm[4];\t/* maximum of 4 components */\n\tOPJ_UINT8 lut_R[256], lut_G[256], lut_B[256];\n\tOPJ_UINT8 const* pLUT[3];\n\topj_image_t * image = NULL;\n\tFILE *IN;\n\tOPJ_BITMAPFILEHEADER File_h;\n\tOPJ_BITMAPINFOHEADER Info_h;\n\tOPJ_UINT32 i, palette_len, numcmpts = 1U;\n\tOPJ_BOOL l_result = OPJ_FALSE;\n\tOPJ_UINT8* pData = NULL;\n\tOPJ_UINT32 stride;\n\t\n\tpLUT[0] = lut_R; pLUT[1] = lut_G; pLUT[2] = lut_B;\n\t\n\tIN = fopen(filename, \"rb\");\n\tif (!IN)\n\t{\n\t\tfprintf(stderr, \"Failed to open %s for reading !!\\n\", filename);\n\t\treturn NULL;\n\t}\n\n\tif (!bmp_read_file_header(IN, &File_h)) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\tif (!bmp_read_info_header(IN, &Info_h)) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\t\n\t/* Load palette */\n\tif (Info_h.biBitCount <= 8U)\n\t{\n\t\tmemset(&lut_R[0], 0, sizeof(lut_R));\n\t\tmemset(&lut_G[0], 0, sizeof(lut_G));\n\t\tmemset(&lut_B[0], 0, sizeof(lut_B));\n\t\t\n\t\tpalette_len = Info_h.biClrUsed;\n\t\tif((palette_len == 0U) && (Info_h.biBitCount <= 8U)) {\n\t\t\tpalette_len = (1U << Info_h.biBitCount);\n\t\t}\n\t\tif (palette_len > 256U) {\n\t\t\tpalette_len = 256U;\n\t\t}\n\t\tif (palette_len > 0U) {\n\t\t\tOPJ_UINT8 has_color = 0U;\n\t\t\tfor (i = 0U; i < palette_len; i++) {\n\t\t\t\tlut_B[i] = (OPJ_UINT8)getc(IN);\n\t\t\t\tlut_G[i] = (OPJ_UINT8)getc(IN);\n\t\t\t\tlut_R[i] = (OPJ_UINT8)getc(IN);\n\t\t\t\t(void)getc(IN); /* padding */\n\t\t\t\thas_color |= (lut_B[i] ^ lut_G[i]) | (lut_G[i] ^ lut_R[i]);\n\t\t\t}\n\t\t\tif(has_color) {\n\t\t\t\tnumcmpts = 3U;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tnumcmpts = 3U;\n\t\tif ((Info_h.biCompression == 3) && (Info_h.biAlphaMask != 0U)) {\n\t\t\tnumcmpts++;\n\t\t}\n\t}\n\t\n\tif (Info_h.biWidth == 0 || Info_h.biHeight == 0) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\t\n\tif (Info_h.biBitCount > (((OPJ_UINT32)-1) - 31) / Info_h.biWidth) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\tstride = ((Info_h.biWidth * Info_h.biBitCount + 31U) / 32U) * 4U; /* rows are aligned on 32bits */\n\tif (Info_h.biBitCount == 4 && Info_h.biCompression == 2) { /* RLE 4 gets decoded as 8 bits data for now... */\n\t\tif (8 > (((OPJ_UINT32)-1) - 31) / Info_h.biWidth) {\n\t\t\tfclose(IN);\n\t\t\treturn NULL;\n\t\t}\n\t\tstride = ((Info_h.biWidth * 8U + 31U) / 32U) * 4U;\n\t}\n\t\n\tif (stride > ((OPJ_UINT32)-1) / sizeof(OPJ_UINT8) / Info_h.biHeight) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\tpData = (OPJ_UINT8 *) calloc(1, stride * Info_h.biHeight * sizeof(OPJ_UINT8));\n\tif (pData == NULL) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\t/* Place the cursor at the beginning of the image information */\n\tfseek(IN, 0, SEEK_SET);\n\tfseek(IN, (long)File_h.bfOffBits, SEEK_SET);\n\t\n\tswitch (Info_h.biCompression) {\n\t\tcase 0:\n\t\tcase 3:\n\t\t\t/* read raw data */\n\t\t\tl_result = bmp_read_raw_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t/* read rle8 data */\n\t\t\tl_result = bmp_read_rle8_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/* read rle4 data */\n\t\t\tl_result = bmp_read_rle4_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);\n\t\t\tbreak;\n  default:\n\t\t\tfprintf(stderr, \"Unsupported BMP compression\\n\");\n\t\t\tl_result = OPJ_FALSE;\n\t\t\tbreak;\n\t}\n\tif (!l_result) {\n\t\tfree(pData);\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\t\n\t/* create the image */\n\tmemset(&cmptparm[0], 0, sizeof(cmptparm));\n\tfor(i = 0; i < 4U; i++)\n\t{\n\t\tcmptparm[i].prec = 8;\n\t\tcmptparm[i].bpp  = 8;\n\t\tcmptparm[i].sgnd = 0;\n\t\tcmptparm[i].dx   = (OPJ_UINT32)parameters->subsampling_dx;\n\t\tcmptparm[i].dy   = (OPJ_UINT32)parameters->subsampling_dy;\n\t\tcmptparm[i].w    = Info_h.biWidth;\n\t\tcmptparm[i].h    = Info_h.biHeight;\n\t}\n\n\timage = opj_image_create(numcmpts, &cmptparm[0], (numcmpts == 1U) ? OPJ_CLRSPC_GRAY : OPJ_CLRSPC_SRGB);\n\tif(!image) {\n\t\tfclose(IN);\n\t\tfree(pData);\n\t\treturn NULL;\n\t}\n\tif (numcmpts == 4U) {\n\t\timage->comps[3].alpha = 1;\n\t}\n\t\n\t/* set image offset and reference grid */\n\timage->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n\timage->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n\timage->x1 =\timage->x0 + (Info_h.biWidth  - 1U) * (OPJ_UINT32)parameters->subsampling_dx + 1U;\n\timage->y1 = image->y0 + (Info_h.biHeight - 1U) * (OPJ_UINT32)parameters->subsampling_dy + 1U;\n\t\n\t/* Read the data */\n\tif (Info_h.biBitCount == 24 && Info_h.biCompression == 0) { /*RGB */\n\t\tbmp24toimage(pData, stride, image);\n\t}\n\telse if (Info_h.biBitCount == 8 && Info_h.biCompression == 0) { /* RGB 8bpp Indexed */\n\t\tbmp8toimage(pData, stride, image, pLUT);\n\t}\n\telse if (Info_h.biBitCount == 8 && Info_h.biCompression == 1) { /*RLE8*/\n\t\tbmp8toimage(pData, stride, image, pLUT);\n\t}\n\telse if (Info_h.biBitCount == 4 && Info_h.biCompression == 2) { /*RLE4*/\n\t\tbmp8toimage(pData, stride, image, pLUT); /* RLE 4 gets decoded as 8 bits data for now */\n\t}\n\telse if (Info_h.biBitCount == 32 && Info_h.biCompression == 0) { /* RGBX */\n\t\tbmpmask32toimage(pData, stride, image, 0x00FF0000U, 0x0000FF00U, 0x000000FFU, 0x00000000U);\n\t}\n\telse if (Info_h.biBitCount == 32 && Info_h.biCompression == 3) { /* bitmask */\n\t\tbmpmask32toimage(pData, stride, image, Info_h.biRedMask, Info_h.biGreenMask, Info_h.biBlueMask, Info_h.biAlphaMask);\n\t}\n\telse if (Info_h.biBitCount == 16 && Info_h.biCompression == 0) { /* RGBX */\n\t\tbmpmask16toimage(pData, stride, image, 0x7C00U, 0x03E0U, 0x001FU, 0x0000U);\n\t}\n\telse if (Info_h.biBitCount == 16 && Info_h.biCompression == 3) { /* bitmask */\n\t\tif ((Info_h.biRedMask == 0U) && (Info_h.biGreenMask == 0U) && (Info_h.biBlueMask == 0U)) {\n\t\t\tInfo_h.biRedMask   = 0xF800U;\n\t\t\tInfo_h.biGreenMask = 0x07E0U;\n\t\t\tInfo_h.biBlueMask  = 0x001FU;\n\t\t}\n\t\tbmpmask16toimage(pData, stride, image, Info_h.biRedMask, Info_h.biGreenMask, Info_h.biBlueMask, Info_h.biAlphaMask);\n\t}\n\telse {\n\t\topj_image_destroy(image);\n\t\timage = NULL;\n\t\tfprintf(stderr, \"Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\\n\", Info_h.biBitCount);\n\t}\n\tfree(pData);\n\tfclose(IN);\n\treturn image;\n}\n\nint imagetobmp(opj_image_t * image, const char *outfile) {\n    int w, h;\n    int i, pad;\n    FILE *fdest = NULL;\n    int adjustR, adjustG, adjustB;\n\n    if (image->comps[0].prec < 8) {\n        fprintf(stderr, \"Unsupported number of components: %d\\n\", image->comps[0].prec);\n        return 1;\n    }\n    if (image->numcomps >= 3 && image->comps[0].dx == image->comps[1].dx\n            && image->comps[1].dx == image->comps[2].dx\n            && image->comps[0].dy == image->comps[1].dy\n            && image->comps[1].dy == image->comps[2].dy\n            && image->comps[0].prec == image->comps[1].prec\n            && image->comps[1].prec == image->comps[2].prec) {\n\n        /* -->> -->> -->> -->>\n        24 bits color\n        <<-- <<-- <<-- <<-- */\n\n        fdest = fopen(outfile, \"wb\");\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n            return 1;\n        }\n\n        w = (int)image->comps[0].w;\n        h = (int)image->comps[0].h;\n\n        fprintf(fdest, \"BM\");\n\n        /* FILE HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\",\n                (OPJ_UINT8) (h * w * 3 + 3 * h * (w % 2) + 54) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2) + 54)\t>> 8) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2) + 54)\t>> 16) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2) + 54)\t>> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (54) & 0xff, ((54) >> 8) & 0xff,((54) >> 16) & 0xff, ((54) >> 24) & 0xff);\n\n        /* INFO HEADER   */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (40) & 0xff, ((40) >> 8) & 0xff,\t((40) >> 16) & 0xff, ((40) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((w) & 0xff),\n                (OPJ_UINT8) ((w) >> 8) & 0xff,\n                (OPJ_UINT8) ((w) >> 16) & 0xff,\n                (OPJ_UINT8) ((w) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((h) & 0xff),\n                (OPJ_UINT8) ((h) >> 8) & 0xff,\n                (OPJ_UINT8) ((h) >> 16) & 0xff,\n                (OPJ_UINT8) ((h) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c\", (1) & 0xff, ((1) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c\", (24) & 0xff, ((24) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) (3 * h * w + 3 * h * (w % 2)) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2)) >> 8) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2)) >> 16) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff, ((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\t((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n\n        if (image->comps[0].prec > 8) {\n            adjustR = (int)image->comps[0].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\\n\", image->comps[0].prec);\n        }\n        else\n            adjustR = 0;\n        if (image->comps[1].prec > 8) {\n            adjustG = (int)image->comps[1].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 1 from %d bits to 8 bits\\n\", image->comps[1].prec);\n        }\n        else\n            adjustG = 0;\n        if (image->comps[2].prec > 8) {\n            adjustB = (int)image->comps[2].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 2 from %d bits to 8 bits\\n\", image->comps[2].prec);\n        }\n        else\n            adjustB = 0;\n\n        for (i = 0; i < w * h; i++) {\n            OPJ_UINT8 rc, gc, bc;\n            int r, g, b;\n\n            r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n            r = ((r >> adjustR)+((r >> (adjustR-1))%2));\n            if(r > 255) r = 255; else if(r < 0) r = 0;\n            rc = (OPJ_UINT8)r;\n\n            g = image->comps[1].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            g += (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);\n            g = ((g >> adjustG)+((g >> (adjustG-1))%2));\n            if(g > 255) g = 255; else if(g < 0) g = 0;\n            gc = (OPJ_UINT8)g;\n\n            b = image->comps[2].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            b += (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);\n            b = ((b >> adjustB)+((b >> (adjustB-1))%2));\n            if(b > 255) b = 255; else if(b < 0) b = 0;\n            bc = (OPJ_UINT8)b;\n\n            fprintf(fdest, \"%c%c%c\", bc, gc, rc);\n\n            if ((i + 1) % w == 0) {\n                for (pad = ((3 * w) % 4) ? (4 - (3 * w) % 4) : 0; pad > 0; pad--)\t/* ADD */\n                    fprintf(fdest, \"%c\", 0);\n            }\n        }\n        fclose(fdest);\n    } else {\t\t\t/* Gray-scale */\n\n        /* -->> -->> -->> -->>\n        8 bits non code (Gray scale)\n        <<-- <<-- <<-- <<-- */\n\n        fdest = fopen(outfile, \"wb\");\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n            return 1;\n        }\n        w = (int)image->comps[0].w;\n        h = (int)image->comps[0].h;\n\n        fprintf(fdest, \"BM\");\n\n        /* FILE HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) (h * w + 54 + 1024 + h * (w % 2)) & 0xff,\n                (OPJ_UINT8) ((h * w + 54 + 1024 + h * (w % 2)) >> 8) & 0xff,\n                (OPJ_UINT8) ((h * w + 54 + 1024 + h * (w % 2)) >> 16) & 0xff,\n                (OPJ_UINT8) ((h * w + 54 + 1024 + w * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (54 + 1024) & 0xff, ((54 + 1024) >> 8) & 0xff,\n                ((54 + 1024) >> 16) & 0xff,\n                ((54 + 1024) >> 24) & 0xff);\n\n        /* INFO HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (40) & 0xff, ((40) >> 8) & 0xff,\t((40) >> 16) & 0xff, ((40) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((w) & 0xff),\n                (OPJ_UINT8) ((w) >> 8) & 0xff,\n                (OPJ_UINT8) ((w) >> 16) & 0xff,\n                (OPJ_UINT8) ((w) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((h) & 0xff),\n                (OPJ_UINT8) ((h) >> 8) & 0xff,\n                (OPJ_UINT8) ((h) >> 16) & 0xff,\n                (OPJ_UINT8) ((h) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c\", (1) & 0xff, ((1) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c\", (8) & 0xff, ((8) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) (h * w + h * (w % 2)) & 0xff,\n                (OPJ_UINT8) ((h * w + h * (w % 2)) >> 8) &\t0xff,\n                (OPJ_UINT8) ((h * w + h * (w % 2)) >> 16) &\t0xff,\n                (OPJ_UINT8) ((h * w + h * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\t((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\t((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (256) & 0xff, ((256) >> 8) & 0xff, ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (256) & 0xff, ((256) >> 8) & 0xff, ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);\n\n        if (image->comps[0].prec > 8) {\n            adjustR = (int)image->comps[0].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\\n\", image->comps[0].prec);\n        }else\n            adjustR = 0;\n\n        for (i = 0; i < 256; i++) {\n            fprintf(fdest, \"%c%c%c%c\", i, i, i, 0);\n        }\n\n        for (i = 0; i < w * h; i++) {\n            int r;\n\n            r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n            r = ((r >> adjustR)+((r >> (adjustR-1))%2));\n            if(r > 255) r = 255; else if(r < 0) r = 0;\n\n            fprintf(fdest, \"%c\", (OPJ_UINT8)r);\n\n            if ((i + 1) % w == 0) {\n                for (pad = (w % 4) ? (4 - w % 4) : 0; pad > 0; pad--)\t/* ADD */\n                    fprintf(fdest, \"%c\", 0);\n            }\n        }\n        fclose(fdest);\n    }\n\n    return 0;\n}\n", "/*\n * The copyright in this software is being made available under the 2-clauses \n * BSD License, included below. This software may be subject to other third \n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux \n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR \n * Copyright (c) 2012, CS Systemes d'Information, France\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#include \"opj_apps_config.h\"\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n\n#ifdef _WIN32\n#include \"windirent.h\"\n#else\n#include <dirent.h>\n#endif /* _WIN32 */\n\n#ifdef _WIN32\n#include <windows.h>\n#define strcasecmp _stricmp\n#define strncasecmp _strnicmp\n#else\n#include <strings.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/times.h>\n#endif /* _WIN32 */\n\n#include \"openjpeg.h\"\n#include \"opj_getopt.h\"\n#include \"convert.h\"\n#include \"index.h\"\n\n#ifdef OPJ_HAVE_LIBLCMS2\n#include <lcms2.h>\n#endif\n#ifdef OPJ_HAVE_LIBLCMS1\n#include <lcms.h>\n#endif\n#include \"color.h\"\n\n#include \"format_defs.h\"\n#include \"opj_string.h\"\n\ntypedef struct dircnt{\n\t/** Buffer for holding images read from Directory*/\n\tchar *filename_buf;\n\t/** Pointer to the buffer*/\n\tchar **filename;\n}dircnt_t;\n\n\ntypedef struct img_folder{\n\t/** The directory path of the folder containing input images*/\n\tchar *imgdirpath;\n\t/** Output format*/\n\tconst char *out_format;\n\t/** Enable option*/\n\tchar set_imgdir;\n\t/** Enable Cod Format for output*/\n\tchar set_out_format;\n\n}img_fol_t;\n\ntypedef enum opj_prec_mode\n{\n\tOPJ_PREC_MODE_CLIP,\n\tOPJ_PREC_MODE_SCALE\n} opj_precision_mode;\n\ntypedef struct opj_prec\n{\n\tOPJ_UINT32         prec;\n\topj_precision_mode mode;\n}opj_precision;\n\ntypedef struct opj_decompress_params\n{\n\t/** core library parameters */\n\topj_dparameters_t core;\n\t\n\t/** input file name */\n\tchar infile[OPJ_PATH_LEN];\n\t/** output file name */\n\tchar outfile[OPJ_PATH_LEN];\n\t/** input file format 0: J2K, 1: JP2, 2: JPT */\n\tint decod_format;\n\t/** output file format 0: PGX, 1: PxM, 2: BMP */\n\tint cod_format;\n\t/** index file name */\n\tchar indexfilename[OPJ_PATH_LEN];\n\t\n\t/** Decoding area left boundary */\n\tOPJ_UINT32 DA_x0;\n\t/** Decoding area right boundary */\n\tOPJ_UINT32 DA_x1;\n\t/** Decoding area up boundary */\n\tOPJ_UINT32 DA_y0;\n\t/** Decoding area bottom boundary */\n\tOPJ_UINT32 DA_y1;\n\t/** Verbose mode */\n\tOPJ_BOOL m_verbose;\n\t\n\t/** tile number ot the decoded tile*/\n\tOPJ_UINT32 tile_index;\n\t/** Nb of tile to decode */\n\tOPJ_UINT32 nb_tile_to_decode;\n\t\n\topj_precision* precision;\n\tOPJ_UINT32     nb_precision;\n\t\n\t/* force output colorspace to RGB */\n\tint force_rgb;\n\t/* upsample components according to their dx/dy values */\n\tint upsample;\n\t/* split output components to different files */\n\tint split_pnm;\n    /** number of threads */\n    int num_threads;\n}opj_decompress_parameters;\n\n/* -------------------------------------------------------------------------- */\n/* Declarations                                                               */\nint get_num_images(char *imgdirpath);\nint load_images(dircnt_t *dirptr, char *imgdirpath);\nint get_file_format(const char *filename);\nchar get_next_file(int imageno,dircnt_t *dirptr,img_fol_t *img_fol, opj_decompress_parameters *parameters);\nstatic int infile_format(const char *fname);\n\nint parse_cmdline_decoder(int argc, char **argv, opj_decompress_parameters *parameters,img_fol_t *img_fol);\nint parse_DA_values( char* inArg, unsigned int *DA_x0, unsigned int *DA_y0, unsigned int *DA_x1, unsigned int *DA_y1);\n\nstatic opj_image_t* convert_gray_to_rgb(opj_image_t* original);\n\n/* -------------------------------------------------------------------------- */\nstatic void decode_help_display(void) {\n\tfprintf(stdout,\"\\nThis is the opj_decompress utility from the OpenJPEG project.\\n\"\n\t               \"It decompresses JPEG 2000 codestreams to various image formats.\\n\"\n\t               \"It has been compiled against openjp2 library v%s.\\n\\n\",opj_version());\n\n\tfprintf(stdout,\"Parameters:\\n\"\n\t               \"-----------\\n\"\n\t               \"\\n\"\n\t               \"  -ImgDir <directory> \\n\"\n\t               \"\tImage file Directory path \\n\"\n\t               \"  -OutFor <PBM|PGM|PPM|PNM|PAM|PGX|PNG|BMP|TIF|RAW|RAWL|TGA>\\n\"\n\t               \"    REQUIRED only if -ImgDir is used\\n\"\n\t               \"\tOutput format for decompressed images.\\n\");\n\tfprintf(stdout,\"  -i <compressed file>\\n\"\n\t               \"    REQUIRED only if an Input image directory is not specified\\n\"\n\t               \"    Currently accepts J2K-files, JP2-files and JPT-files. The file type\\n\"\n\t               \"    is identified based on its suffix.\\n\");\n\tfprintf(stdout,\"  -o <decompressed file>\\n\"\n\t               \"    REQUIRED\\n\"\n\t               \"    Currently accepts formats specified above (see OutFor option)\\n\"\n\t               \"    Binary data is written to the file (not ascii). If a PGX\\n\"\n\t               \"    filename is given, there will be as many output files as there are\\n\"\n\t               \"    components: an indice starting from 0 will then be appended to the\\n\"\n\t               \"    output filename, just before the \\\"pgx\\\" extension. If a PGM filename\\n\"\n\t               \"    is given and there are more than one component, only the first component\\n\"\n\t               \"    will be written to the file.\\n\");\n\tfprintf(stdout,\"  -r <reduce factor>\\n\"\n\t               \"    Set the number of highest resolution levels to be discarded. The\\n\"\n\t               \"    image resolution is effectively divided by 2 to the power of the\\n\"\n\t               \"    number of discarded levels. The reduce factor is limited by the\\n\"\n\t               \"    smallest total number of decomposition levels among tiles.\\n\"\n\t               \"  -l <number of quality layers to decode>\\n\"\n\t               \"    Set the maximum number of quality layers to decode. If there are\\n\"\n\t               \"    less quality layers than the specified number, all the quality layers\\n\"\n\t               \"    are decoded.\\n\");\n\tfprintf(stdout,\"  -x  \\n\"\n\t               \"    Create an index file *.Idx (-x index_name.Idx) \\n\"\n\t               \"  -d <x0,y0,x1,y1>\\n\"\n\t               \"    OPTIONAL\\n\"\n\t               \"    Decoding area\\n\"\n\t               \"    By default all the image is decoded.\\n\"\n\t               \"  -t <tile_number>\\n\"\n\t               \"    OPTIONAL\\n\"\n\t               \"    Set the tile number of the decoded tile. Follow the JPEG2000 convention from left-up to bottom-up\\n\"\n\t               \"    By default all tiles are decoded.\\n\");\n\tfprintf(stdout,\"  -p <comp 0 precision>[C|S][,<comp 1 precision>[C|S][,...]]\\n\"\n\t               \"    OPTIONAL\\n\"\n\t               \"    Force the precision (bit depth) of components.\\n\");\n\tfprintf(stdout,\"    There shall be at least 1 value. Theres no limit on the number of values (comma separated, last values ignored if too much values).\\n\"\n\t               \"    If there are less values than components, the last value is used for remaining components.\\n\"\n\t               \"    If 'C' is specified (default), values are clipped.\\n\"\n\t               \"    If 'S' is specified, values are scaled.\\n\"\n\t               \"    A 0 value can be specified (meaning original bit depth).\\n\");\n\tfprintf(stdout,\"  -force-rgb\\n\"\n\t               \"    Force output image colorspace to RGB\\n\"\n\t               \"  -upsample\\n\"\n\t               \"    Downsampled components will be upsampled to image size\\n\"\n\t               \"  -split-pnm\\n\"\n\t               \"    Split output components to different files when writing to PNM\\n\");\n\tif( opj_has_thread_support() ) {\n\t  fprintf(stdout,\"  -threads <num_threads>\\n\"\n\t\t\t\t\t\"    Number of threads to use for decoding.\\n\");\n\t}\n/* UniPG>> */\n#ifdef USE_JPWL\n\tfprintf(stdout,\"  -W <options>\\n\"\n\t               \"    Activates the JPWL correction capability, if the codestream complies.\\n\"\n\t               \"    Options can be a comma separated list of <param=val> tokens:\\n\"\n\t               \"    c, c=numcomps\\n\"\n\t               \"       numcomps is the number of expected components in the codestream\\n\"\n\t               \"       (search of first EPB rely upon this, default is %d)\\n\", JPWL_EXPECTED_COMPONENTS);\n#endif /* USE_JPWL */\n/* <<UniPG */\n\tfprintf(stdout,\"\\n\");\n}\n\n/* -------------------------------------------------------------------------- */\n\nstatic OPJ_BOOL parse_precision(const char* option, opj_decompress_parameters* parameters)\n{\n\tconst char* l_remaining = option;\n\tOPJ_BOOL l_result = OPJ_TRUE;\n\t\n\t/* reset */\n\tif (parameters->precision) {\n\t\tfree(parameters->precision);\n\t\tparameters->precision = NULL;\n\t}\n\tparameters->nb_precision = 0U;\n\t\n\tfor(;;)\n\t{\n\t\tint prec;\n\t\tchar mode;\n\t\tchar comma;\n\t\tint count;\n\t\t\n\t\tcount = sscanf(l_remaining, \"%d%c%c\", &prec, &mode, &comma);\n\t\tif (count == 1) {\n\t\t\tmode = 'C';\n\t\t\tcount++;\n\t\t}\n\t\tif ((count == 2) || (mode==',')) {\n\t\t\tif (mode==',') {\n\t\t\t\tmode = 'C';\n\t\t\t}\n\t\t\tcomma=',';\n\t\t\tcount = 3;\n\t\t}\n\t\tif (count == 3) {\n\t\t\tif ((prec < 1) || (prec > 32)) {\n\t\t\t\tfprintf(stderr,\"Invalid precision %d in precision option %s\\n\", prec, option);\n\t\t\t\tl_result = OPJ_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((mode != 'C') && (mode != 'S')) {\n\t\t\t\tfprintf(stderr,\"Invalid precision mode %c in precision option %s\\n\", mode, option);\n\t\t\t\tl_result = OPJ_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (comma != ',') {\n\t\t\t\tfprintf(stderr,\"Invalid character %c in precision option %s\\n\", comma, option);\n\t\t\t\tl_result = OPJ_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (parameters->precision == NULL) {\n\t\t\t\t/* first one */\n\t\t\t\tparameters->precision = (opj_precision *)malloc(sizeof(opj_precision));\n\t\t\t\tif (parameters->precision == NULL) {\n\t\t\t\t\tfprintf(stderr,\"Could not allocate memory for precision option\\n\");\n\t\t\t\t\tl_result = OPJ_FALSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tOPJ_UINT32 l_new_size = parameters->nb_precision + 1U;\n\t\t\t\topj_precision* l_new;\n\t\t\t\t\n\t\t\t\tif (l_new_size == 0U) {\n\t\t\t\t\tfprintf(stderr,\"Could not allocate memory for precision option\\n\");\n\t\t\t\t\tl_result = OPJ_FALSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tl_new = (opj_precision *)realloc(parameters->precision, l_new_size * sizeof(opj_precision));\n\t\t\t\tif (l_new == NULL) {\n\t\t\t\t\tfprintf(stderr,\"Could not allocate memory for precision option\\n\");\n\t\t\t\t\tl_result = OPJ_FALSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tparameters->precision = l_new;\n\t\t\t}\n\t\t\t\n\t\t\tparameters->precision[parameters->nb_precision].prec = (OPJ_UINT32)prec;\n\t\t\tswitch (mode) {\n\t\t\t\tcase 'C':\n\t\t\t\t\tparameters->precision[parameters->nb_precision].mode = OPJ_PREC_MODE_CLIP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tparameters->precision[parameters->nb_precision].mode = OPJ_PREC_MODE_SCALE;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tparameters->nb_precision++;\n\t\t\t\n\t\t\tl_remaining = strchr(l_remaining, ',');\n\t\t\tif (l_remaining == NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tl_remaining += 1;\n\t\t} else {\n\t\t\tfprintf(stderr,\"Could not parse precision option %s\\n\", option);\n\t\t\tl_result = OPJ_FALSE;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn l_result;\n}\n\n/* -------------------------------------------------------------------------- */\n\nint get_num_images(char *imgdirpath){\n\tDIR *dir;\n\tstruct dirent* content;\t\n\tint num_images = 0;\n\n\t/*Reading the input images from given input directory*/\n\n\tdir= opendir(imgdirpath);\n\tif(!dir){\n\t\tfprintf(stderr,\"Could not open Folder %s\\n\",imgdirpath);\n\t\treturn 0;\n\t}\n\t\n\twhile((content=readdir(dir))!=NULL){\n\t\tif(strcmp(\".\",content->d_name)==0 || strcmp(\"..\",content->d_name)==0 )\n\t\t\tcontinue;\n\t\tnum_images++;\n\t}\n\tclosedir(dir);\n\treturn num_images;\n}\n\n/* -------------------------------------------------------------------------- */\nint load_images(dircnt_t *dirptr, char *imgdirpath){\n\tDIR *dir;\n\tstruct dirent* content;\t\n\tint i = 0;\n\n\t/*Reading the input images from given input directory*/\n\n\tdir= opendir(imgdirpath);\n\tif(!dir){\n\t\tfprintf(stderr,\"Could not open Folder %s\\n\",imgdirpath);\n\t\treturn 1;\n\t}else\t{\n\t\tfprintf(stderr,\"Folder opened successfully\\n\");\n\t}\n\t\n\twhile((content=readdir(dir))!=NULL){\n\t\tif(strcmp(\".\",content->d_name)==0 || strcmp(\"..\",content->d_name)==0 )\n\t\t\tcontinue;\n\n\t\tstrcpy(dirptr->filename[i],content->d_name);\n\t\ti++;\n\t}\n\tclosedir(dir);\n\treturn 0;\t\n}\n\n/* -------------------------------------------------------------------------- */\nint get_file_format(const char *filename) {\n\tunsigned int i;\n\tstatic const char *extension[] = {\"pgx\", \"pnm\", \"pgm\", \"ppm\", \"bmp\",\"tif\", \"raw\", \"rawl\", \"tga\", \"png\", \"j2k\", \"jp2\", \"jpt\", \"j2c\", \"jpc\" };\n\tstatic const int format[] = { PGX_DFMT, PXM_DFMT, PXM_DFMT, PXM_DFMT, BMP_DFMT, TIF_DFMT, RAW_DFMT, RAWL_DFMT, TGA_DFMT, PNG_DFMT, J2K_CFMT, JP2_CFMT, JPT_CFMT, J2K_CFMT, J2K_CFMT };\n\tconst char * ext = strrchr(filename, '.');\n\tif (ext == NULL)\n\t\treturn -1;\n\text++;\n\tif(*ext) {\n\t\tfor(i = 0; i < sizeof(format)/sizeof(*format); i++) {\n\t\t\tif(strcasecmp(ext, extension[i]) == 0) {\n\t\t\t\treturn format[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n#ifdef _WIN32\nconst char* path_separator = \"\\\\\";\n#else\nconst char* path_separator = \"/\";\n#endif\n\n/* -------------------------------------------------------------------------- */\nchar get_next_file(int imageno,dircnt_t *dirptr,img_fol_t *img_fol, opj_decompress_parameters *parameters){\n\tchar image_filename[OPJ_PATH_LEN], infilename[OPJ_PATH_LEN],outfilename[OPJ_PATH_LEN],temp_ofname[OPJ_PATH_LEN];\n\tchar *temp_p, temp1[OPJ_PATH_LEN]=\"\";\n\n\tstrcpy(image_filename,dirptr->filename[imageno]);\n\tfprintf(stderr,\"File Number %d \\\"%s\\\"\\n\",imageno,image_filename);\n\tsprintf(infilename, \"%s%s%s\", img_fol->imgdirpath, path_separator, image_filename);\n\tparameters->decod_format = infile_format(infilename);\n\tif (parameters->decod_format == -1)\n\t\treturn 1;\n\tif (opj_strcpy_s(parameters->infile, sizeof(parameters->infile), infilename) != 0) {\n\t\treturn 1;\n\t}\n\n\t/*Set output file*/\n\tstrcpy(temp_ofname,strtok(image_filename,\".\"));\n\twhile((temp_p = strtok(NULL,\".\")) != NULL){\n\t\tstrcat(temp_ofname,temp1);\n\t\tsprintf(temp1,\".%s\",temp_p);\n\t}\n\tif(img_fol->set_out_format==1){\n\t\tsprintf(outfilename,\"%s/%s.%s\",img_fol->imgdirpath,temp_ofname,img_fol->out_format);\n\t\tif (opj_strcpy_s(parameters->outfile, sizeof(parameters->outfile), outfilename) != 0) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* -------------------------------------------------------------------------- */\n#define JP2_RFC3745_MAGIC \"\\x00\\x00\\x00\\x0c\\x6a\\x50\\x20\\x20\\x0d\\x0a\\x87\\x0a\"\n#define JP2_MAGIC \"\\x0d\\x0a\\x87\\x0a\"\n/* position 45: \"\\xff\\x52\" */\n#define J2K_CODESTREAM_MAGIC \"\\xff\\x4f\\xff\\x51\"\n\nstatic int infile_format(const char *fname)\n{\n\tFILE *reader;\n\tconst char *s, *magic_s;\n\tint ext_format, magic_format;\n\tunsigned char buf[12];\n\tOPJ_SIZE_T l_nb_read;\n\n\treader = fopen(fname, \"rb\");\n\n\tif (reader == NULL)\n\t\treturn -2;\n\n\tmemset(buf, 0, 12);\n\tl_nb_read = fread(buf, 1, 12, reader);\n\tfclose(reader);\n\tif (l_nb_read != 12)\n\t\treturn -1;\n\n\n\n\text_format = get_file_format(fname);\n\n\tif (ext_format == JPT_CFMT)\n\t\treturn JPT_CFMT;\n\n\tif (memcmp(buf, JP2_RFC3745_MAGIC, 12) == 0 || memcmp(buf, JP2_MAGIC, 4) == 0) {\n\t\tmagic_format = JP2_CFMT;\n\t\tmagic_s = \".jp2\";\n\t}\n\telse if (memcmp(buf, J2K_CODESTREAM_MAGIC, 4) == 0) {\n\t\tmagic_format = J2K_CFMT;\n\t\tmagic_s = \".j2k or .jpc or .j2c\";\n\t}\n\telse\n\t\treturn -1;\n\n\tif (magic_format == ext_format)\n\t\treturn ext_format;\n\n\ts = fname + strlen(fname) - 4;\n\n\tfputs(\"\\n===========================================\\n\", stderr);\n\tfprintf(stderr, \"The extension of this file is incorrect.\\n\"\n\t\t\t\t\t\"FOUND %s. SHOULD BE %s\\n\", s, magic_s);\n\tfputs(\"===========================================\\n\", stderr);\n\n\treturn magic_format;\n}\n\n/* -------------------------------------------------------------------------- */\n/**\n * Parse the command line\n */\n/* -------------------------------------------------------------------------- */\nint parse_cmdline_decoder(int argc, char **argv, opj_decompress_parameters *parameters,img_fol_t *img_fol) {\n\t/* parse the command line */\n\tint totlen, c;\n\topj_option_t long_option[]={\n\t\t{\"ImgDir\",    REQ_ARG, NULL,'y'},\n\t\t{\"OutFor\",    REQ_ARG, NULL,'O'},\n\t\t{\"force-rgb\", NO_ARG,  NULL, 1},\n\t\t{\"upsample\",  NO_ARG,  NULL, 1},\n\t\t{\"split-pnm\", NO_ARG,  NULL, 1},\n\t\t{\"threads\",   REQ_ARG, NULL, 'T'}\n\t};\n\n\tconst char optlist[] = \"i:o:r:l:x:d:t:p:\"\n\n/* UniPG>> */\n#ifdef USE_JPWL\n\t\t\t\t\t\"W:\"\n#endif /* USE_JPWL */\n/* <<UniPG */\n            \"h\"\t\t;\n\n\tlong_option[2].flag = &(parameters->force_rgb);\n\tlong_option[3].flag = &(parameters->upsample);\n\tlong_option[4].flag = &(parameters->split_pnm);\n\ttotlen=sizeof(long_option);\n\topj_reset_options_reading();\n\timg_fol->set_out_format = 0;\n\tdo {\n\t\tc = opj_getopt_long(argc, argv,optlist,long_option,totlen);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\t\tcase 0: /* long opt with flag */\n\t\t\t\tbreak;\n\t\t\tcase 'i':\t\t\t/* input file */\n\t\t\t{\n\t\t\t\tchar *infile = opj_optarg;\n\t\t\t\tparameters->decod_format = infile_format(infile);\n\t\t\t\tswitch(parameters->decod_format) {\n\t\t\t\t\tcase J2K_CFMT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase JP2_CFMT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase JPT_CFMT:\n\t\t\t\t\t\tbreak;\n                                        case -2:\n\t\t\t\t\t\tfprintf(stderr, \n\t\t\t\t\t\t\t\"!! infile cannot be read: %s !!\\n\\n\", \n\t\t\t\t\t\t\tinfile);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfprintf(stderr, \n                            \"[ERROR] Unknown input file format: %s \\n\"\n                            \"        Known file formats are *.j2k, *.jp2, *.jpc or *.jpt\\n\",\n\t\t\t\t\t\t\tinfile);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tif (opj_strcpy_s(parameters->infile, sizeof(parameters->infile), infile) != 0) {\n\t\t\t\t\tfprintf(stderr, \"[ERROR] Path is too long\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\t\n\t\t\t\t/* ----------------------------------------------------- */\n\n\t\t\tcase 'o':\t\t\t/* output file */\n\t\t\t{\n\t\t\t\tchar *outfile = opj_optarg;\n\t\t\t\tparameters->cod_format = get_file_format(outfile);\n\t\t\t\tswitch(parameters->cod_format) {\n\t\t\t\t\tcase PGX_DFMT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PXM_DFMT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase BMP_DFMT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TIF_DFMT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase RAW_DFMT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase RAWL_DFMT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TGA_DFMT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PNG_DFMT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfprintf(stderr, \"Unknown output format image %s [only *.png, *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!!\\n\", outfile);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tif (opj_strcpy_s(parameters->outfile, sizeof(parameters->outfile), outfile) != 0) {\n\t\t\t\t\tfprintf(stderr, \"[ERROR] Path is too long\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\t\t\t/* ----------------------------------------------------- */\n\n\t\t\tcase 'O':\t\t\t/* output format */\n\t\t\t{\n\t\t\t\tchar outformat[50];\n\t\t\t\tchar *of = opj_optarg;\n\t\t\t\tsprintf(outformat,\".%s\",of);\n\t\t\t\timg_fol->set_out_format = 1;\n\t\t\t\tparameters->cod_format = get_file_format(outformat);\n\t\t\t\tswitch(parameters->cod_format) {\n\t\t\t\t\tcase PGX_DFMT:\n\t\t\t\t\t\timg_fol->out_format = \"pgx\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PXM_DFMT:\n\t\t\t\t\t\timg_fol->out_format = \"ppm\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase BMP_DFMT:\n\t\t\t\t\t\timg_fol->out_format = \"bmp\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TIF_DFMT:\n\t\t\t\t\t\timg_fol->out_format = \"tif\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase RAW_DFMT:\n\t\t\t\t\t\timg_fol->out_format = \"raw\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase RAWL_DFMT:\n\t\t\t\t\t\timg_fol->out_format = \"rawl\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TGA_DFMT:\n\t\t\t\t\t\timg_fol->out_format = \"raw\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PNG_DFMT:\n\t\t\t\t\t\timg_fol->out_format = \"png\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfprintf(stderr, \"Unknown output format image %s [only *.png, *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!!\\n\", outformat);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t\t/* ----------------------------------------------------- */\n\n\n\t\t\tcase 'r':\t\t/* reduce option */\n\t\t\t{\n\t\t\t\tsscanf(opj_optarg, \"%u\", &(parameters->core.cp_reduce));\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\t\t\t/* ----------------------------------------------------- */\n      \n\n\t\t\tcase 'l':\t\t/* layering option */\n\t\t\t{\n\t\t\t\tsscanf(opj_optarg, \"%u\", &(parameters->core.cp_layer));\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\t\t\t/* ----------------------------------------------------- */\n\n\t\t\tcase 'h': \t\t\t/* display an help description */\n\t\t\t\tdecode_help_display();\n\t\t\t\treturn 1;\t\t\t\t\n\n            /* ----------------------------------------------------- */\n\n\t\t\tcase 'y':\t\t\t/* Image Directory path */\n                {\n\t\t\t\t\timg_fol->imgdirpath = (char*)malloc(strlen(opj_optarg) + 1);\n\t\t\t\t\tif(img_fol->imgdirpath == NULL){\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\tstrcpy(img_fol->imgdirpath,opj_optarg);\n\t\t\t\t\timg_fol->set_imgdir=1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\t/* ----------------------------------------------------- */\n\n\t\t\tcase 'd':     \t\t/* Input decode ROI */\n\t\t\t{\n\t\t\t\tsize_t size_optarg = (size_t)strlen(opj_optarg) + 1U;\n\t\t\t\tchar *ROI_values = (char*) malloc(size_optarg);\n\t\t\t\tif (ROI_values == NULL) {\n\t\t\t\t\tfprintf(stderr, \"[ERROR] Couldn't allocate memory\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tROI_values[0] = '\\0';\n\t\t\t\tmemcpy(ROI_values, opj_optarg, size_optarg);\n\t\t\t\t/*printf(\"ROI_values = %s [%d / %d]\\n\", ROI_values, strlen(ROI_values), size_optarg ); */\n\t\t\t\tparse_DA_values( ROI_values, &parameters->DA_x0, &parameters->DA_y0, &parameters->DA_x1, &parameters->DA_y1);\n\n\t\t\t\tfree(ROI_values);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* ----------------------------------------------------- */\n\n\t\t\tcase 't':     \t\t/* Input tile index */\n\t\t\t{\n\t\t\t\tsscanf(opj_optarg, \"%u\", &parameters->tile_index);\n\t\t\t\tparameters->nb_tile_to_decode = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t\t/* ----------------------------------------------------- */\t\t\t\t\t\t\t\t\n\n\t\t\tcase 'x':\t\t\t/* Creation of index file */\n\t\t\t\t{\n\t\t\t\t\tif (opj_strcpy_s(parameters->indexfilename, sizeof(parameters->indexfilename), opj_optarg) != 0) {\n\t\t\t\t\t\tfprintf(stderr, \"[ERROR] Path is too long\\n\");\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\t/* ----------------------------------------------------- */\n\t\t\tcase 'p': /* Force precision */\n\t\t\t\t{\n\t\t\t\t\tif (!parse_precision(opj_optarg, parameters))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t/* ----------------------------------------------------- */\n\t\t\t\t\n\t\t\t\t/* UniPG>> */\n#ifdef USE_JPWL\n\t\t\t\n\t\t\tcase 'W': \t\t\t/* activate JPWL correction */\n\t\t\t{\n\t\t\t\tchar *token = NULL;\n\n\t\t\t\ttoken = strtok(opj_optarg, \",\");\n\t\t\t\twhile(token != NULL) {\n\n\t\t\t\t\t/* search expected number of components */\n\t\t\t\t\tif (*token == 'c') {\n\n\t\t\t\t\t\tstatic int compno;\n\n\t\t\t\t\t\tcompno = JPWL_EXPECTED_COMPONENTS; /* predefined no. of components */\n\n\t\t\t\t\t\tif(sscanf(token, \"c=%d\", &compno) == 1) {\n\t\t\t\t\t\t\t/* Specified */\n\t\t\t\t\t\t\tif ((compno < 1) || (compno > 256)) {\n\t\t\t\t\t\t\t\tfprintf(stderr, \"ERROR -> invalid number of components c = %d\\n\", compno);\n\t\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tparameters->jpwl_exp_comps = compno;\n\n\t\t\t\t\t\t} else if (!strcmp(token, \"c\")) {\n\t\t\t\t\t\t\t/* default */\n\t\t\t\t\t\t\tparameters->jpwl_exp_comps = compno; /* auto for default size */\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfprintf(stderr, \"ERROR -> invalid components specified = %s\\n\", token);\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t/* search maximum number of tiles */\n\t\t\t\t\tif (*token == 't') {\n\n\t\t\t\t\t\tstatic int tileno;\n\n\t\t\t\t\t\ttileno = JPWL_MAXIMUM_TILES; /* maximum no. of tiles */\n\n\t\t\t\t\t\tif(sscanf(token, \"t=%d\", &tileno) == 1) {\n\t\t\t\t\t\t\t/* Specified */\n\t\t\t\t\t\t\tif ((tileno < 1) || (tileno > JPWL_MAXIMUM_TILES)) {\n\t\t\t\t\t\t\t\tfprintf(stderr, \"ERROR -> invalid number of tiles t = %d\\n\", tileno);\n\t\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tparameters->jpwl_max_tiles = tileno;\n\n\t\t\t\t\t\t} else if (!strcmp(token, \"t\")) {\n\t\t\t\t\t\t\t/* default */\n\t\t\t\t\t\t\tparameters->jpwl_max_tiles = tileno; /* auto for default size */\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfprintf(stderr, \"ERROR -> invalid tiles specified = %s\\n\", token);\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t/* next token or bust */\n\t\t\t\t\ttoken = strtok(NULL, \",\");\n\t\t\t\t};\n\t\t\t\tparameters->jpwl_correct = OPJ_TRUE;\n\t\t\t\tfprintf(stdout, \"JPWL correction capability activated\\n\");\n\t\t\t\tfprintf(stdout, \"- expecting %d components\\n\", parameters->jpwl_exp_comps);\n\t\t\t}\n\t\t\tbreak;\t\n#endif /* USE_JPWL */\n/* <<UniPG */            \n\t\t\t\t\n\t\t\t\t/* ----------------------------------------------------- */\n\t\t\tcase 'T':  /* Number of threads */\n\t\t\t\t{\n\t\t\t\t\tif( strcmp(opj_optarg, \"ALL_CPUS\") == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tparameters->num_threads = opj_get_num_cpus();\n\t\t\t\t\t\tif( parameters->num_threads == 1 )\n\t\t\t\t\t\t\tparameters->num_threads = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t  sscanf(opj_optarg, \"%d\", &parameters->num_threads);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\t/* ----------------------------------------------------- */\n\t\t\t\n        default:\n            fprintf(stderr, \"[WARNING] An invalid option has been ignored.\\n\");\n            break;\n\t\t}\n\t}while(c != -1);\n\n\t/* check for possible errors */\n\tif(img_fol->set_imgdir==1){\n\t\tif(!(parameters->infile[0]==0)){\n            fprintf(stderr, \"[ERROR] options -ImgDir and -i cannot be used together.\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif(img_fol->set_out_format == 0){\n            fprintf(stderr, \"[ERROR] When -ImgDir is used, -OutFor <FORMAT> must be used.\\n\");\n            fprintf(stderr, \"Only one format allowed.\\n\"\n                            \"Valid format are PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA.\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif(!((parameters->outfile[0] == 0))){\n            fprintf(stderr, \"[ERROR] options -ImgDir and -o cannot be used together.\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}else{\n\t\tif((parameters->infile[0] == 0) || (parameters->outfile[0] == 0)) {\n            fprintf(stderr, \"[ERROR] Required parameters are missing\\n\"\n                            \"Example: %s -i image.j2k -o image.pgm\\n\",argv[0]);\n            fprintf(stderr, \"   Help: %s -h\\n\",argv[0]);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* -------------------------------------------------------------------------- */\n/**\n * Parse decoding area input values\n * separator = \",\"\n */\n/* -------------------------------------------------------------------------- */\nint parse_DA_values( char* inArg, unsigned int *DA_x0, unsigned int *DA_y0, unsigned int *DA_x1, unsigned int *DA_y1)\n{\n\tint it = 0;\n\tint values[4];\n\tchar delims[] = \",\";\n\tchar *result = NULL;\n\tresult = strtok( inArg, delims );\n\n\twhile( (result != NULL) && (it < 4 ) ) {\n\t\tvalues[it] = atoi(result);\n\t\tresult = strtok( NULL, delims );\n\t\tit++;\n\t}\n\n\tif (it != 4) {\n\t\treturn EXIT_FAILURE;\n\t}\n\telse{\n\t\t*DA_x0 = (OPJ_UINT32)values[0]; *DA_y0 = (OPJ_UINT32)values[1];\n\t\t*DA_x1 = (OPJ_UINT32)values[2]; *DA_y1 = (OPJ_UINT32)values[3];\n\t\treturn EXIT_SUCCESS;\n\t}\n}\n\nOPJ_FLOAT64 opj_clock(void) {\n#ifdef _WIN32\n\t/* _WIN32: use QueryPerformance (very accurate) */\n    LARGE_INTEGER freq , t ;\n    /* freq is the clock speed of the CPU */\n    QueryPerformanceFrequency(&freq) ;\n\t/* cout << \"freq = \" << ((double) freq.QuadPart) << endl; */\n    /* t is the high resolution performance counter (see MSDN) */\n    QueryPerformanceCounter ( & t ) ;\n\treturn freq.QuadPart ? (t.QuadPart / (OPJ_FLOAT64)freq.QuadPart) : 0;\n#elif defined(__linux)\n\tstruct timespec ts;\n\tclock_gettime(CLOCK_REALTIME, &ts);\n\treturn( (OPJ_FLOAT64)ts.tv_sec + (OPJ_FLOAT64)ts.tv_nsec * 1e-9 );\n#else\n\t/* Unix : use resource usage */\n\t/* FIXME: this counts the total CPU time, instead of the user perceived time */\n\tstruct rusage t;\n\tOPJ_FLOAT64 procTime;\n\t/* (1) Get the rusage data structure at this moment (man getrusage) */\n\tgetrusage(0,&t);\n\t/* (2) What is the elapsed time ? - CPU time = User time + System time */\n\t/* (2a) Get the seconds */\n\tprocTime = (OPJ_FLOAT64)(t.ru_utime.tv_sec + t.ru_stime.tv_sec);\n\t/* (2b) More precisely! Get the microseconds part ! */\n\treturn ( procTime + (OPJ_FLOAT64)(t.ru_utime.tv_usec + t.ru_stime.tv_usec) * 1e-6 ) ;\n#endif\n}\n\n/* -------------------------------------------------------------------------- */\n\n/**\nsample error callback expecting a FILE* client object\n*/\nstatic void error_callback(const char *msg, void *client_data) {\n\t(void)client_data;\n\tfprintf(stdout, \"[ERROR] %s\", msg);\n}\n/**\nsample warning callback expecting a FILE* client object\n*/\nstatic void warning_callback(const char *msg, void *client_data) {\n\t(void)client_data;\n\tfprintf(stdout, \"[WARNING] %s\", msg);\n}\n/**\nsample debug callback expecting no client object\n*/\nstatic void info_callback(const char *msg, void *client_data) {\n\t(void)client_data;\n\tfprintf(stdout, \"[INFO] %s\", msg);\n}\n\nstatic void set_default_parameters(opj_decompress_parameters* parameters)\n{\n\tif (parameters) {\n\t\tmemset(parameters, 0, sizeof(opj_decompress_parameters));\n\t\t\n\t\t/* default decoding parameters (command line specific) */\n\t\tparameters->decod_format = -1;\n\t\tparameters->cod_format = -1;\n\t\t\n\t\t/* default decoding parameters (core) */\n\t\topj_set_default_decoder_parameters(&(parameters->core));\n\t}\n}\n\nstatic void destroy_parameters(opj_decompress_parameters* parameters)\n{\n\tif (parameters) {\n\t\tif (parameters->precision) {\n\t\t\tfree(parameters->precision);\n\t\t\tparameters->precision = NULL;\n\t\t}\n\t}\n}\n\n/* -------------------------------------------------------------------------- */\n\nstatic opj_image_t* convert_gray_to_rgb(opj_image_t* original)\n{\n\tOPJ_UINT32 compno;\n\topj_image_t* l_new_image = NULL;\n\topj_image_cmptparm_t* l_new_components = NULL;\n\t\n\tl_new_components = (opj_image_cmptparm_t*)malloc((original->numcomps + 2U) * sizeof(opj_image_cmptparm_t));\n\tif (l_new_components == NULL) {\n\t\tfprintf(stderr, \"ERROR -> opj_decompress: failed to allocate memory for RGB image!\\n\");\n\t\topj_image_destroy(original);\n\t\treturn NULL;\n\t}\n\t\n\tl_new_components[0].bpp  = l_new_components[1].bpp  = l_new_components[2].bpp  = original->comps[0].bpp;\n\tl_new_components[0].dx   = l_new_components[1].dx   = l_new_components[2].dx   = original->comps[0].dx;\n\tl_new_components[0].dy   = l_new_components[1].dy   = l_new_components[2].dy   = original->comps[0].dy;\n\tl_new_components[0].h    = l_new_components[1].h    = l_new_components[2].h    = original->comps[0].h;\n\tl_new_components[0].w    = l_new_components[1].w    = l_new_components[2].w    = original->comps[0].w;\n\tl_new_components[0].prec = l_new_components[1].prec = l_new_components[2].prec = original->comps[0].prec;\n\tl_new_components[0].sgnd = l_new_components[1].sgnd = l_new_components[2].sgnd = original->comps[0].sgnd;\n\tl_new_components[0].x0   = l_new_components[1].x0   = l_new_components[2].x0   = original->comps[0].x0;\n\tl_new_components[0].y0   = l_new_components[1].y0   = l_new_components[2].y0   = original->comps[0].y0;\n\t\n\tfor(compno = 1U; compno < original->numcomps; ++compno) {\n\t\tl_new_components[compno+2U].bpp  = original->comps[compno].bpp;\n\t\tl_new_components[compno+2U].dx   = original->comps[compno].dx;\n\t\tl_new_components[compno+2U].dy   = original->comps[compno].dy;\n\t\tl_new_components[compno+2U].h    = original->comps[compno].h;\n\t\tl_new_components[compno+2U].w    = original->comps[compno].w;\n\t\tl_new_components[compno+2U].prec = original->comps[compno].prec;\n\t\tl_new_components[compno+2U].sgnd = original->comps[compno].sgnd;\n\t\tl_new_components[compno+2U].x0   = original->comps[compno].x0;\n\t\tl_new_components[compno+2U].y0   = original->comps[compno].y0;\n\t}\n\t\n\tl_new_image = opj_image_create(original->numcomps + 2U, l_new_components, OPJ_CLRSPC_SRGB);\n\tfree(l_new_components);\n\tif (l_new_image == NULL) {\n\t\tfprintf(stderr, \"ERROR -> opj_decompress: failed to allocate memory for RGB image!\\n\");\n\t\topj_image_destroy(original);\n\t\treturn NULL;\n\t}\n\t\n\tl_new_image->x0 = original->x0;\n\tl_new_image->x1 = original->x1;\n\tl_new_image->y0 = original->y0;\n\tl_new_image->y1 = original->y1;\n\t\n\tl_new_image->comps[0].factor        = l_new_image->comps[1].factor        = l_new_image->comps[2].factor        = original->comps[0].factor;\n\tl_new_image->comps[0].alpha         = l_new_image->comps[1].alpha         = l_new_image->comps[2].alpha         = original->comps[0].alpha;\n\tl_new_image->comps[0].resno_decoded = l_new_image->comps[1].resno_decoded = l_new_image->comps[2].resno_decoded = original->comps[0].resno_decoded;\n\t\n\tmemcpy(l_new_image->comps[0].data, original->comps[0].data, original->comps[0].w * original->comps[0].h * sizeof(OPJ_INT32));\n\tmemcpy(l_new_image->comps[1].data, original->comps[0].data, original->comps[0].w * original->comps[0].h * sizeof(OPJ_INT32));\n\tmemcpy(l_new_image->comps[2].data, original->comps[0].data, original->comps[0].w * original->comps[0].h * sizeof(OPJ_INT32));\n\t\n\tfor(compno = 1U; compno < original->numcomps; ++compno) {\n\t\tl_new_image->comps[compno+2U].factor        = original->comps[compno].factor;\n\t\tl_new_image->comps[compno+2U].alpha         = original->comps[compno].alpha;\n\t\tl_new_image->comps[compno+2U].resno_decoded = original->comps[compno].resno_decoded;\n\t\tmemcpy(l_new_image->comps[compno+2U].data, original->comps[compno].data, original->comps[compno].w * original->comps[compno].h * sizeof(OPJ_INT32));\n\t}\n\topj_image_destroy(original);\n\treturn l_new_image;\n}\n\n/* -------------------------------------------------------------------------- */\n\nstatic opj_image_t* upsample_image_components(opj_image_t* original)\n{\n\topj_image_t* l_new_image = NULL;\n\topj_image_cmptparm_t* l_new_components = NULL;\n\tOPJ_BOOL l_upsample_need = OPJ_FALSE;\n\tOPJ_UINT32 compno;\n\n\tfor (compno = 0U; compno < original->numcomps; ++compno) {\n\t\tif (original->comps[compno].factor > 0U) {\n\t\t\tfprintf(stderr, \"ERROR -> opj_decompress: -upsample not supported with reduction\\n\");\n\t\t\topj_image_destroy(original);\n\t\t\treturn NULL;\n\t\t}\n\t\tif ((original->comps[compno].dx > 1U) || (original->comps[compno].dy > 1U)) {\n\t\t\tl_upsample_need = OPJ_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!l_upsample_need) {\n\t\treturn original;\n\t}\n\t/* Upsample is needed */\n\tl_new_components = (opj_image_cmptparm_t*)malloc(original->numcomps * sizeof(opj_image_cmptparm_t));\n\tif (l_new_components == NULL) {\n\t\tfprintf(stderr, \"ERROR -> opj_decompress: failed to allocate memory for upsampled components!\\n\");\n\t\topj_image_destroy(original);\n\t\treturn NULL;\n\t}\n\t\n\tfor (compno = 0U; compno < original->numcomps; ++compno) {\n\t\topj_image_cmptparm_t* l_new_cmp = &(l_new_components[compno]);\n\t\topj_image_comp_t*     l_org_cmp = &(original->comps[compno]);\n\t\t\n\t\tl_new_cmp->bpp  = l_org_cmp->bpp;\n\t\tl_new_cmp->prec = l_org_cmp->prec;\n\t\tl_new_cmp->sgnd = l_org_cmp->sgnd;\n\t\tl_new_cmp->x0   = original->x0;\n\t\tl_new_cmp->y0   = original->y0;\n\t\tl_new_cmp->dx   = 1;\n\t\tl_new_cmp->dy   = 1;\n\t\tl_new_cmp->w    = l_org_cmp->w; /* should be original->x1 - original->x0 for dx==1 */\n\t\tl_new_cmp->h    = l_org_cmp->h; /* should be original->y1 - original->y0 for dy==0 */\n\t\t\n\t\tif (l_org_cmp->dx > 1U) {\n\t\t\tl_new_cmp->w = original->x1 - original->x0;\n\t\t}\n\t\t\n\t\tif (l_org_cmp->dy > 1U) {\n\t\t\tl_new_cmp->h = original->y1 - original->y0;\n\t\t}\n\t}\n\t\n\tl_new_image = opj_image_create(original->numcomps, l_new_components, original->color_space);\n\tfree(l_new_components);\n\tif (l_new_image == NULL) {\n\t\tfprintf(stderr, \"ERROR -> opj_decompress: failed to allocate memory for upsampled components!\\n\");\n\t\topj_image_destroy(original);\n\t\treturn NULL;\n\t}\n\t\n\tl_new_image->x0 = original->x0;\n\tl_new_image->x1 = original->x1;\n\tl_new_image->y0 = original->y0;\n\tl_new_image->y1 = original->y1;\n\t\n\tfor (compno = 0U; compno < original->numcomps; ++compno) {\n\t\topj_image_comp_t* l_new_cmp = &(l_new_image->comps[compno]);\n\t\topj_image_comp_t* l_org_cmp = &(original->comps[compno]);\n\t\t\n\t\tl_new_cmp->factor        = l_org_cmp->factor;\n\t\tl_new_cmp->alpha         = l_org_cmp->alpha;\n\t\tl_new_cmp->resno_decoded = l_org_cmp->resno_decoded;\n\t\t\n\t\tif ((l_org_cmp->dx > 1U) || (l_org_cmp->dy > 1U)) {\n\t\t\tconst OPJ_INT32* l_src = l_org_cmp->data;\n\t\t\tOPJ_INT32*       l_dst = l_new_cmp->data;\n\t\t\tOPJ_UINT32 y;\n\t\t\tOPJ_UINT32 xoff, yoff;\n\t\t\t\n\t\t\t/* need to take into account dx & dy */\n\t\t\txoff = l_org_cmp->dx * l_org_cmp->x0 -  original->x0;\n\t\t\tyoff = l_org_cmp->dy * l_org_cmp->y0 -  original->y0;\n\t\t\tif ((xoff >= l_org_cmp->dx) || (yoff >= l_org_cmp->dy)) {\n\t\t\t\tfprintf(stderr, \"ERROR -> opj_decompress: Invalid image/component parameters found when upsampling\\n\");\n\t\t\t\topj_image_destroy(original);\n\t\t\t\topj_image_destroy(l_new_image);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t\n\t\t\tfor (y = 0U; y < yoff; ++y) {\n\t\t\t\tmemset(l_dst, 0U, l_new_cmp->w * sizeof(OPJ_INT32));\n\t\t\t\tl_dst += l_new_cmp->w;\n\t\t\t}\n\t\t\t\n\t\t\tif(l_new_cmp->h > (l_org_cmp->dy - 1U)) { /* check subtraction overflow for really small images */\n\t\t\t\tfor (; y < l_new_cmp->h - (l_org_cmp->dy - 1U); y += l_org_cmp->dy) {\n\t\t\t\t\tOPJ_UINT32 x, dy;\n\t\t\t\t\tOPJ_UINT32 xorg;\n\t\t\t\t\t\n\t\t\t\t\txorg = 0U;\n\t\t\t\t\tfor (x = 0U; x < xoff; ++x) {\n\t\t\t\t\t\tl_dst[x] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (l_new_cmp->w > (l_org_cmp->dx - 1U)) { /* check subtraction overflow for really small images */\n\t\t\t\t\t\tfor (; x < l_new_cmp->w - (l_org_cmp->dx - 1U); x += l_org_cmp->dx, ++xorg) {\n\t\t\t\t\t\t\tOPJ_UINT32 dx;\n\t\t\t\t\t\t\tfor (dx = 0U; dx < l_org_cmp->dx; ++dx) {\n\t\t\t\t\t\t\t\tl_dst[x + dx] = l_src[xorg];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (; x < l_new_cmp->w; ++x) {\n\t\t\t\t\t\tl_dst[x] = l_src[xorg];\n\t\t\t\t\t}\n\t\t\t\t\tl_dst += l_new_cmp->w;\n\t\t\t\t\t\t\n\t\t\t\t\tfor (dy = 1U; dy < l_org_cmp->dy; ++dy) {\n\t\t\t\t\t\tmemcpy(l_dst, l_dst - l_new_cmp->w, l_new_cmp->w * sizeof(OPJ_INT32));\n\t\t\t\t\t\tl_dst += l_new_cmp->w;\n\t\t\t\t\t}\n\t\t\t\t\tl_src += l_org_cmp->w;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (y < l_new_cmp->h) {\n\t\t\t\tOPJ_UINT32 x;\n\t\t\t\tOPJ_UINT32 xorg;\n\t\t\t\t\n\t\t\t\txorg = 0U;\n\t\t\t\tfor (x = 0U; x < xoff; ++x) {\n\t\t\t\t\tl_dst[x] = 0;\n\t\t\t\t}\n\t\t\t\tif (l_new_cmp->w > (l_org_cmp->dx - 1U)) { /* check subtraction overflow for really small images */\n\t\t\t\t\tfor (; x < l_new_cmp->w - (l_org_cmp->dx - 1U); x += l_org_cmp->dx, ++xorg) {\n\t\t\t\t\t\tOPJ_UINT32 dx;\n\t\t\t\t\t\tfor (dx = 0U; dx < l_org_cmp->dx; ++dx) {\n\t\t\t\t\t\t\tl_dst[x + dx] = l_src[xorg];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (; x < l_new_cmp->w; ++x) {\n\t\t\t\t\tl_dst[x] = l_src[xorg];\n\t\t\t\t}\n\t\t\t\tl_dst += l_new_cmp->w;\n\t\t\t\t++y;\n\t\t\t\tfor (; y < l_new_cmp->h; ++y) {\n\t\t\t\t\tmemcpy(l_dst, l_dst - l_new_cmp->w, l_new_cmp->w * sizeof(OPJ_INT32));\n\t\t\t\t\tl_dst += l_new_cmp->w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmemcpy(l_new_cmp->data, l_org_cmp->data, l_org_cmp->w * l_org_cmp->h * sizeof(OPJ_INT32));\n\t\t}\n\t}\n\topj_image_destroy(original);\n\treturn l_new_image;\n}\n\n/* -------------------------------------------------------------------------- */\n/**\n * OPJ_DECOMPRESS MAIN\n */\n/* -------------------------------------------------------------------------- */\nint main(int argc, char **argv)\n{\n\topj_decompress_parameters parameters;\t\t\t/* decompression parameters */\n\topj_image_t* image = NULL;\n\topj_stream_t *l_stream = NULL;\t\t\t\t/* Stream */\n\topj_codec_t* l_codec = NULL;\t\t\t\t/* Handle to a decompressor */\n\topj_codestream_index_t* cstr_index = NULL;\n\n\tOPJ_INT32 num_images, imageno;\n\timg_fol_t img_fol;\n\tdircnt_t *dirptr = NULL;\n  int failed = 0;\n  OPJ_FLOAT64 t, tCumulative = 0;\n  OPJ_UINT32 numDecompressedImages = 0;\n\n\t/* set decoding parameters to default values */\n\tset_default_parameters(&parameters);\n\n\t/* Initialize img_fol */\n\tmemset(&img_fol,0,sizeof(img_fol_t));\n\n\t/* parse input and get user encoding parameters */\n\tif(parse_cmdline_decoder(argc, argv, &parameters,&img_fol) == 1) {\n\t\tfailed = 1; goto fin;\n\t}\n\n\t/* Initialize reading of directory */\n\tif(img_fol.set_imgdir==1){\t\n\t\tint it_image;\n\t\tnum_images=get_num_images(img_fol.imgdirpath);\n\n\t\tdirptr=(dircnt_t*)malloc(sizeof(dircnt_t));\n\t\tif(!dirptr){\n\t\t\tdestroy_parameters(&parameters);\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t\tdirptr->filename_buf = (char*)malloc((size_t)num_images*OPJ_PATH_LEN*sizeof(char));\t/* Stores at max 10 image file names*/\n\t\tif(!dirptr->filename_buf){\n\t\t\tfailed = 1; goto fin;\n\t\t}\n\t\t\t\t\n\t\tdirptr->filename = (char**) malloc((size_t)num_images*sizeof(char*));\n\n\t\tif(!dirptr->filename){\n\t\t\tfailed = 1; goto fin;\n\t\t}\n\t\tfor(it_image=0;it_image<num_images;it_image++){\n\t\t\tdirptr->filename[it_image] = dirptr->filename_buf + it_image*OPJ_PATH_LEN;\n\t\t}\n\t\t\n\t\tif(load_images(dirptr,img_fol.imgdirpath)==1){\n\t\t\tfailed = 1; goto fin;\n\t\t}\n\t\tif (num_images==0){\n\t\t\tfprintf(stdout,\"Folder is empty\\n\");\n\t\t\tfailed = 1; goto fin;\n\t\t}\n\t}else{\n\t\tnum_images=1;\n\t}\n\n\t/*Decoding image one by one*/\n\tfor(imageno = 0; imageno < num_images ; imageno++)\t{\n\n\t\tfprintf(stderr,\"\\n\");\n\n\t\tif(img_fol.set_imgdir==1){\n\t\t\tif (get_next_file(imageno, dirptr,&img_fol, &parameters)) {\n\t\t\t\tfprintf(stderr,\"skipping file...\\n\");\n\t\t\t\tdestroy_parameters(&parameters);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* read the input file and put it in memory */\n\t\t/* ---------------------------------------- */\n\n\t\tl_stream = opj_stream_create_default_file_stream(parameters.infile,1);\n\t\tif (!l_stream){\n\t\t\tfprintf(stderr, \"ERROR -> failed to create the stream from the file %s\\n\", parameters.infile);\n\t\t\tfailed = 1; goto fin;\n\t\t}\n\n\t\t/* decode the JPEG2000 stream */\n\t\t/* ---------------------- */\n\n\t\tswitch(parameters.decod_format) {\n\t\t\tcase J2K_CFMT:\t/* JPEG-2000 codestream */\n\t\t\t{\n\t\t\t\t/* Get a decoder handle */\n\t\t\t\tl_codec = opj_create_decompress(OPJ_CODEC_J2K);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase JP2_CFMT:\t/* JPEG 2000 compressed image data */\n\t\t\t{\n\t\t\t\t/* Get a decoder handle */\n\t\t\t\tl_codec = opj_create_decompress(OPJ_CODEC_JP2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase JPT_CFMT:\t/* JPEG 2000, JPIP */\n\t\t\t{\n\t\t\t\t/* Get a decoder handle */\n\t\t\t\tl_codec = opj_create_decompress(OPJ_CODEC_JPT);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"skipping file..\\n\");\n\t\t\t\tdestroy_parameters(&parameters);\n\t\t\t\topj_stream_destroy(l_stream);\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* catch events using our callbacks and give a local context */\t\t\n\t\topj_set_info_handler(l_codec, info_callback,00);\n\t\topj_set_warning_handler(l_codec, warning_callback,00);\n\t\topj_set_error_handler(l_codec, error_callback,00);\n\n\t\tt = opj_clock();\n\n\t\t/* Setup the decoder decoding parameters using user parameters */\n\t\tif ( !opj_setup_decoder(l_codec, &(parameters.core)) ){\n\t\t\tfprintf(stderr, \"ERROR -> opj_decompress: failed to setup the decoder\\n\");\n\t\t\topj_stream_destroy(l_stream);\n\t\t\topj_destroy_codec(l_codec);\n\t\t\tfailed = 1; goto fin;\n\t\t}\n\t\t\n\t\tif( parameters.num_threads >= 1 && !opj_codec_set_threads(l_codec, parameters.num_threads) ) {\n\t\t\tfprintf(stderr, \"ERROR -> opj_decompress: failed to set number of threads\\n\");\n\t\t\topj_stream_destroy(l_stream);\n\t\t\topj_destroy_codec(l_codec);\n\t\t\tfailed = 1; goto fin;\n\t\t}\n\n\t\t/* Read the main header of the codestream and if necessary the JP2 boxes*/\n\t\tif(! opj_read_header(l_stream, l_codec, &image)){\n\t\t\tfprintf(stderr, \"ERROR -> opj_decompress: failed to read the header\\n\");\n\t\t\topj_stream_destroy(l_stream);\n\t\t\topj_destroy_codec(l_codec);\n\t\t\topj_image_destroy(image);\n\t\t\tfailed = 1; goto fin;\n\t\t}\n\n\t\tif (!parameters.nb_tile_to_decode) {\n\t\t\t/* Optional if you want decode the entire image */\n\t\t\tif (!opj_set_decode_area(l_codec, image, (OPJ_INT32)parameters.DA_x0,\n\t\t\t\t\t(OPJ_INT32)parameters.DA_y0, (OPJ_INT32)parameters.DA_x1, (OPJ_INT32)parameters.DA_y1)){\n\t\t\t\tfprintf(stderr,\t\"ERROR -> opj_decompress: failed to set the decoded area\\n\");\n\t\t\t\topj_stream_destroy(l_stream);\n\t\t\t\topj_destroy_codec(l_codec);\n\t\t\t\topj_image_destroy(image);\n\t\t\t\tfailed = 1; goto fin;\n\t\t\t}\n\n\t\t\t/* Get the decoded image */\n\t\t\tif (!(opj_decode(l_codec, l_stream, image) && opj_end_decompress(l_codec,\tl_stream))) {\n\t\t\t\tfprintf(stderr,\"ERROR -> opj_decompress: failed to decode image!\\n\");\n\t\t\t\topj_destroy_codec(l_codec);\n\t\t\t\topj_stream_destroy(l_stream);\n\t\t\t\topj_image_destroy(image);\n\t\t\t\tfailed = 1; goto fin;\n\t\t\t}\n\t\t}\n\t\telse {\n\n\t\t\t/* It is just here to illustrate how to use the resolution after set parameters */\n\t\t\t/*if (!opj_set_decoded_resolution_factor(l_codec, 5)) {\n\t\t\t\tfprintf(stderr, \"ERROR -> opj_decompress: failed to set the resolution factor tile!\\n\");\n\t\t\t\topj_destroy_codec(l_codec);\n\t\t\t\topj_stream_destroy(l_stream);\n\t\t\t\topj_image_destroy(image);\n\t\t\t\tfailed = 1; goto fin;\n\t\t\t}*/\n\n\t\t\tif (!opj_get_decoded_tile(l_codec, l_stream, image, parameters.tile_index)) {\n\t\t\t\tfprintf(stderr, \"ERROR -> opj_decompress: failed to decode tile!\\n\");\n\t\t\t\topj_destroy_codec(l_codec);\n\t\t\t\topj_stream_destroy(l_stream);\n\t\t\t\topj_image_destroy(image);\n\t\t\t\tfailed = 1; goto fin;\n\t\t\t}\n\t\t\tfprintf(stdout, \"tile %d is decoded!\\n\\n\", parameters.tile_index);\n\t\t}\n\n\t\ttCumulative += opj_clock() - t;\n\t\tnumDecompressedImages++;\n\n\t\t/* Close the byte stream */\n\t\topj_stream_destroy(l_stream);\n\n\t\tif( image->color_space != OPJ_CLRSPC_SYCC \n\t\t\t&& image->numcomps == 3 && image->comps[0].dx == image->comps[0].dy\n\t\t\t&& image->comps[1].dx != 1 )\n\t\t\timage->color_space = OPJ_CLRSPC_SYCC;\n\t\telse if (image->numcomps <= 2)\n\t\t\timage->color_space = OPJ_CLRSPC_GRAY;\n\n\t\tif(image->color_space == OPJ_CLRSPC_SYCC){\n\t\t\tcolor_sycc_to_rgb(image);\n\t\t}\n\t\telse if((image->color_space == OPJ_CLRSPC_CMYK) && (parameters.cod_format != TIF_DFMT)){\n\t\t\tcolor_cmyk_to_rgb(image);\n\t\t}\n\t\telse if(image->color_space == OPJ_CLRSPC_EYCC){\n\t\t\tcolor_esycc_to_rgb(image);\n\t\t}\n\t\t\n\t\tif(image->icc_profile_buf) {\n#if defined(OPJ_HAVE_LIBLCMS1) || defined(OPJ_HAVE_LIBLCMS2)\n\t\t\tif(image->icc_profile_len)\n\t\t\t color_apply_icc_profile(image);\n\t\t\telse\n\t\t\t color_cielab_to_rgb(image);\n#endif\n\t\t\tfree(image->icc_profile_buf);\n\t\t\timage->icc_profile_buf = NULL; image->icc_profile_len = 0;\n\t\t}\n\t\t\n\t\t/* Force output precision */\n\t\t/* ---------------------- */\n\t\tif (parameters.precision != NULL)\n\t\t{\n\t\t\tOPJ_UINT32 compno;\n\t\t\tfor (compno = 0; compno < image->numcomps; ++compno)\n\t\t\t{\n\t\t\t\tOPJ_UINT32 precno = compno;\n\t\t\t\tOPJ_UINT32 prec;\n\t\t\t\t\n\t\t\t\tif (precno >= parameters.nb_precision) {\n\t\t\t\t\tprecno = parameters.nb_precision - 1U;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tprec = parameters.precision[precno].prec;\n\t\t\t\tif (prec == 0) {\n\t\t\t\t\tprec = image->comps[compno].prec;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tswitch (parameters.precision[precno].mode) {\n\t\t\t\t\tcase OPJ_PREC_MODE_CLIP:\n\t\t\t\t\t\tclip_component(&(image->comps[compno]), prec);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OPJ_PREC_MODE_SCALE:\n\t\t\t\t\t\tscale_component(&(image->comps[compno]), prec);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* Upsample components */\n\t\t/* ------------------- */\n\t\tif (parameters.upsample)\n\t\t{\n\t\t\timage = upsample_image_components(image);\n\t\t\tif (image == NULL) {\n\t\t\t\tfprintf(stderr, \"ERROR -> opj_decompress: failed to upsample image components!\\n\");\n\t\t\t\topj_destroy_codec(l_codec);\n\t\t\t\tfailed = 1; goto fin;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* Force RGB output */\n\t\t/* ---------------- */\n\t\tif (parameters.force_rgb)\n\t\t{\n\t\t\tswitch (image->color_space) {\n\t\t\t\tcase OPJ_CLRSPC_SRGB:\n\t\t\t\t\tbreak;\n\t\t\t\tcase OPJ_CLRSPC_GRAY:\n\t\t\t\t\timage = convert_gray_to_rgb(image);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfprintf(stderr, \"ERROR -> opj_decompress: don't know how to convert image to RGB colorspace!\\n\");\n\t\t\t\t\topj_image_destroy(image);\n\t\t\t\t\timage = NULL;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (image == NULL) {\n\t\t\t\tfprintf(stderr, \"ERROR -> opj_decompress: failed to convert to RGB image!\\n\");\n\t\t\t\topj_destroy_codec(l_codec);\n\t\t\t\tfailed = 1; goto fin;\n\t\t\t}\n\t\t}\n\n\t\t/* create output image */\n\t\t/* ------------------- */\n\t\tswitch (parameters.cod_format) {\n\t\tcase PXM_DFMT:\t\t\t/* PNM PGM PPM */\n\t\t\tif (imagetopnm(image, parameters.outfile, parameters.split_pnm)) {\n                fprintf(stderr,\"[ERROR] Outfile %s not generated\\n\",parameters.outfile);\n        failed = 1;\n\t\t\t}\n\t\t\telse {\n                fprintf(stdout,\"[INFO] Generated Outfile %s\\n\",parameters.outfile);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PGX_DFMT:\t\t\t/* PGX */\n\t\t\tif(imagetopgx(image, parameters.outfile)){\n                fprintf(stderr,\"[ERROR] Outfile %s not generated\\n\",parameters.outfile);\n        failed = 1;\n\t\t\t}\n\t\t\telse {\n                fprintf(stdout,\"[INFO] Generated Outfile %s\\n\",parameters.outfile);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase BMP_DFMT:\t\t\t/* BMP */\n\t\t\tif(imagetobmp(image, parameters.outfile)){\n                fprintf(stderr,\"[ERROR] Outfile %s not generated\\n\",parameters.outfile);\n        failed = 1;\n\t\t\t}\n\t\t\telse {\n                fprintf(stdout,\"[INFO] Generated Outfile %s\\n\",parameters.outfile);\n\t\t\t}\n\t\t\tbreak;\n#ifdef OPJ_HAVE_LIBTIFF\n\t\tcase TIF_DFMT:\t\t\t/* TIFF */\n\t\t\tif(imagetotif(image, parameters.outfile)){\n                fprintf(stderr,\"[ERROR] Outfile %s not generated\\n\",parameters.outfile);\n        failed = 1;\n\t\t\t}\n\t\t\telse {\n                fprintf(stdout,\"[INFO] Generated Outfile %s\\n\",parameters.outfile);\n\t\t\t}\n\t\t\tbreak;\n#endif /* OPJ_HAVE_LIBTIFF */\n\t\tcase RAW_DFMT:\t\t\t/* RAW */\n\t\t\tif(imagetoraw(image, parameters.outfile)){\n                fprintf(stderr,\"[ERROR] Error generating raw file. Outfile %s not generated\\n\",parameters.outfile);\n        failed = 1;\n\t\t\t}\n\t\t\telse {\n                fprintf(stdout,\"[INFO] Generated Outfile %s\\n\",parameters.outfile);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase RAWL_DFMT:\t\t\t/* RAWL */\n\t\t\tif(imagetorawl(image, parameters.outfile)){\n                fprintf(stderr,\"[ERROR] Error generating rawl file. Outfile %s not generated\\n\",parameters.outfile);\n        failed = 1;\n\t\t\t}\n\t\t\telse {\n                fprintf(stdout,\"[INFO] Generated Outfile %s\\n\",parameters.outfile);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TGA_DFMT:\t\t\t/* TGA */\n\t\t\tif(imagetotga(image, parameters.outfile)){\n                fprintf(stderr,\"[ERROR] Error generating tga file. Outfile %s not generated\\n\",parameters.outfile);\n        failed = 1;\n\t\t\t}\n\t\t\telse {\n                fprintf(stdout,\"[INFO] Generated Outfile %s\\n\",parameters.outfile);\n\t\t\t}\n\t\t\tbreak;\n#ifdef OPJ_HAVE_LIBPNG\n\t\tcase PNG_DFMT:\t\t\t/* PNG */\n\t\t\tif(imagetopng(image, parameters.outfile)){\n                fprintf(stderr,\"[ERROR] Error generating png file. Outfile %s not generated\\n\",parameters.outfile);\n        failed = 1;\n\t\t\t}\n\t\t\telse {\n                fprintf(stdout,\"[INFO] Generated Outfile %s\\n\",parameters.outfile);\n\t\t\t}\n\t\t\tbreak;\n#endif /* OPJ_HAVE_LIBPNG */\n/* Can happen if output file is TIFF or PNG\n * and OPJ_HAVE_LIBTIF or OPJ_HAVE_LIBPNG is undefined\n*/\n\t\t\tdefault:\n                fprintf(stderr,\"[ERROR] Outfile %s not generated\\n\",parameters.outfile);\n        failed = 1;\n\t\t}\n\n\t\t/* free remaining structures */\n\t\tif (l_codec) {\n\t\t\topj_destroy_codec(l_codec);\n\t\t}\n\n\n\t\t/* free image data structure */\n\t\topj_image_destroy(image);\n\n\t\t/* destroy the codestream index */\n\t\topj_destroy_cstr_index(&cstr_index);\n\n\t\tif(failed) (void)remove(parameters.outfile); /* ignore return value */\n\t}\nfin:\n\tdestroy_parameters(&parameters);\n\tif(failed && img_fol.imgdirpath) free(img_fol.imgdirpath);\n\tif(dirptr){\n\t\tif(dirptr->filename) free(dirptr->filename);\n\t\tif(dirptr->filename_buf) free(dirptr->filename_buf);\n\t\tfree(dirptr);\n\t}\n\tif (numDecompressedImages) {\n\t\tfprintf(stdout, \"decode time: %d ms\\n\", (int)( (tCumulative * 1000.0) / (OPJ_FLOAT64)numDecompressedImages));\n\t}\n\treturn failed ? EXIT_FAILURE : EXIT_SUCCESS;\n}\n/*end main()*/\n", "/*\n * The copyright in this software is being made available under the 2-clauses \n * BSD License, included below. This software may be subject to other third \n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux \n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * Copyright (c) 2010-2011, Kaori Hagihara\n * Copyright (c) 2011-2012, Centre National d'Etudes Spatiales (CNES), France \n * Copyright (c) 2012, CS Systemes d'Information, France\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"opj_includes.h\"\n\n/** @defgroup J2K J2K - JPEG-2000 codestream reader/writer */\n/*@{*/\n\n/** @name Local static functions */\n/*@{*/\n\n/**\n * Sets up the procedures to do on reading header. Developpers wanting to extend the library can add their own reading procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_header_reading (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager);\n\n/**\n * The read header procedure.\n */\nstatic OPJ_BOOL opj_j2k_read_header_procedure(  opj_j2k_t *p_j2k,\n                                                opj_stream_private_t *p_stream,\n                                                opj_event_mgr_t * p_manager);\n\n/**\n * The default encoding validation procedure without any extension.\n *\n * @param       p_j2k                   the jpeg2000 codec to validate.\n * @param       p_stream                the input stream to validate.\n * @param       p_manager               the user event manager.\n *\n * @return true if the parameters are correct.\n */\nstatic OPJ_BOOL opj_j2k_encoding_validation (   opj_j2k_t * p_j2k,\n                                                opj_stream_private_t *p_stream,\n                                                opj_event_mgr_t * p_manager );\n\n/**\n * The default decoding validation procedure without any extension.\n *\n * @param       p_j2k                   the jpeg2000 codec to validate.\n * @param       p_stream                                the input stream to validate.\n * @param       p_manager               the user event manager.\n *\n * @return true if the parameters are correct.\n */\nstatic OPJ_BOOL opj_j2k_decoding_validation (   opj_j2k_t * p_j2k,\n                                                opj_stream_private_t *p_stream,\n                                                opj_event_mgr_t * p_manager );\n\n/**\n * Sets up the validation ,i.e. adds the procedures to lauch to make sure the codec parameters\n * are valid. Developpers wanting to extend the library can add their own validation procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_encoding_validation (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager);\n\n/**\n * Sets up the validation ,i.e. adds the procedures to lauch to make sure the codec parameters\n * are valid. Developpers wanting to extend the library can add their own validation procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_decoding_validation (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager);\n\n/**\n * Sets up the validation ,i.e. adds the procedures to lauch to make sure the codec parameters\n * are valid. Developpers wanting to extend the library can add their own validation procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_end_compress (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager);\n\n/**\n * The mct encoding validation procedure.\n *\n * @param       p_j2k                   the jpeg2000 codec to validate.\n * @param       p_stream                                the input stream to validate.\n * @param       p_manager               the user event manager.\n *\n * @return true if the parameters are correct.\n */\nstatic OPJ_BOOL opj_j2k_mct_validation (opj_j2k_t * p_j2k,\n                                        opj_stream_private_t *p_stream,\n                                        opj_event_mgr_t * p_manager );\n\n/**\n * Builds the tcd decoder to use to decode tile.\n */\nstatic OPJ_BOOL opj_j2k_build_decoder ( opj_j2k_t * p_j2k,\n                                        opj_stream_private_t *p_stream,\n                                        opj_event_mgr_t * p_manager );\n/**\n * Builds the tcd encoder to use to encode tile.\n */\nstatic OPJ_BOOL opj_j2k_build_encoder ( opj_j2k_t * p_j2k,\n                                        opj_stream_private_t *p_stream,\n                                        opj_event_mgr_t * p_manager );\n\n/**\n * Creates a tile-coder decoder.\n *\n * @param       p_stream                        the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager                   the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_create_tcd(     opj_j2k_t *p_j2k,\n                                                                    opj_stream_private_t *p_stream,\n                                                                    opj_event_mgr_t * p_manager );\n\n/**\n * Excutes the given procedures on the given codec.\n *\n * @param       p_procedure_list        the list of procedures to execute\n * @param       p_j2k                           the jpeg2000 codec to execute the procedures on.\n * @param       p_stream                        the stream to execute the procedures on.\n * @param       p_manager                       the user manager.\n *\n * @return      true                            if all the procedures were successfully executed.\n */\nstatic OPJ_BOOL opj_j2k_exec (  opj_j2k_t * p_j2k,\n                            opj_procedure_list_t * p_procedure_list,\n                            opj_stream_private_t *p_stream,\n                            opj_event_mgr_t * p_manager);\n\n/**\n * Updates the rates of the tcp.\n *\n * @param       p_stream                                the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_update_rates(   opj_j2k_t *p_j2k,\n                                                                            opj_stream_private_t *p_stream,\n                                                                            opj_event_mgr_t * p_manager );\n\n/**\n * Copies the decoding tile parameters onto all the tile parameters.\n * Creates also the tile decoder.\n */\nstatic OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd (       opj_j2k_t * p_j2k,\n                                                            opj_stream_private_t *p_stream,\n                                                            opj_event_mgr_t * p_manager );\n\n/**\n * Destroys the memory associated with the decoding of headers.\n */\nstatic OPJ_BOOL opj_j2k_destroy_header_memory ( opj_j2k_t * p_j2k,\n                                                opj_stream_private_t *p_stream,\n                                                opj_event_mgr_t * p_manager );\n\n/**\n * Reads the lookup table containing all the marker, status and action, and returns the handler associated\n * with the marker value.\n * @param       p_id            Marker value to look up\n *\n * @return      the handler associated with the id.\n*/\nstatic const struct opj_dec_memory_marker_handler * opj_j2k_get_marker_handler (OPJ_UINT32 p_id);\n\n/**\n * Destroys a tile coding parameter structure.\n *\n * @param       p_tcp           the tile coding parameter to destroy.\n */\nstatic void opj_j2k_tcp_destroy (opj_tcp_t *p_tcp);\n\n/**\n * Destroys the data inside a tile coding parameter structure.\n *\n * @param       p_tcp           the tile coding parameter which contain data to destroy.\n */\nstatic void opj_j2k_tcp_data_destroy (opj_tcp_t *p_tcp);\n\n/**\n * Destroys a coding parameter structure.\n *\n * @param       p_cp            the coding parameter to destroy.\n */\nstatic void opj_j2k_cp_destroy (opj_cp_t *p_cp);\n\n/**\n * Compare 2 a SPCod/ SPCoc elements, i.e. the coding style of a given component of a tile.\n *\n * @param       p_j2k            J2K codec.\n * @param       p_tile_no        Tile number\n * @param       p_first_comp_no  The 1st component number to compare.\n * @param       p_second_comp_no The 1st component number to compare.\n *\n * @return OPJ_TRUE if SPCdod are equals.\n */\nstatic OPJ_BOOL opj_j2k_compare_SPCod_SPCoc(opj_j2k_t *p_j2k, OPJ_UINT32 p_tile_no, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no);\n\n/**\n * Writes a SPCod or SPCoc element, i.e. the coding style of a given component of a tile.\n *\n * @param       p_j2k           J2K codec.\n * @param       p_tile_no       FIXME DOC\n * @param       p_comp_no       the component number to output.\n * @param       p_data          FIXME DOC\n * @param       p_header_size   FIXME DOC\n * @param       p_manager       the user event manager.\n *\n * @return FIXME DOC\n*/\nstatic OPJ_BOOL opj_j2k_write_SPCod_SPCoc(      opj_j2k_t *p_j2k,\n                                                                                    OPJ_UINT32 p_tile_no,\n                                                                                    OPJ_UINT32 p_comp_no,\n                                                                                    OPJ_BYTE * p_data,\n                                                                                    OPJ_UINT32 * p_header_size,\n                                                                                    opj_event_mgr_t * p_manager );\n\n/**\n * Gets the size taken by writing a SPCod or SPCoc for the given tile and component.\n *\n * @param       p_j2k                   the J2K codec.\n * @param       p_tile_no               the tile index.\n * @param       p_comp_no               the component being outputted.\n *\n * @return      the number of bytes taken by the SPCod element.\n */\nstatic OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size (opj_j2k_t *p_j2k,\n                                                                                            OPJ_UINT32 p_tile_no,\n                                                                                            OPJ_UINT32 p_comp_no );\n\n/**\n * Reads a SPCod or SPCoc element, i.e. the coding style of a given component of a tile.\n * @param       p_j2k           the jpeg2000 codec.\n * @param       compno          FIXME DOC\n * @param       p_header_data   the data contained in the COM box.\n * @param       p_header_size   the size of the data contained in the COM marker.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_SPCod_SPCoc(   opj_j2k_t *p_j2k,\n                                            OPJ_UINT32 compno,\n                                            OPJ_BYTE * p_header_data,\n                                            OPJ_UINT32 * p_header_size,\n                                            opj_event_mgr_t * p_manager );\n\n/**\n * Gets the size taken by writing SQcd or SQcc element, i.e. the quantization values of a band in the QCD or QCC.\n *\n * @param       p_tile_no               the tile index.\n * @param       p_comp_no               the component being outputted.\n * @param       p_j2k                   the J2K codec.\n *\n * @return      the number of bytes taken by the SPCod element.\n */\nstatic OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size (  opj_j2k_t *p_j2k,\n                                                                                    OPJ_UINT32 p_tile_no,\n                                                                                    OPJ_UINT32 p_comp_no );\n\n/**\n * Compares 2 SQcd or SQcc element, i.e. the quantization values of a band in the QCD or QCC.\n *\n * @param       p_j2k                   J2K codec.\n * @param       p_tile_no               the tile to output.\n * @param       p_first_comp_no         the first component number to compare.\n * @param       p_second_comp_no        the second component number to compare.\n *\n * @return OPJ_TRUE if equals.\n */\nstatic OPJ_BOOL opj_j2k_compare_SQcd_SQcc(opj_j2k_t *p_j2k, OPJ_UINT32 p_tile_no, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no);\n\n\n/**\n * Writes a SQcd or SQcc element, i.e. the quantization values of a band in the QCD or QCC.\n *\n * @param       p_tile_no               the tile to output.\n * @param       p_comp_no               the component number to output.\n * @param       p_data                  the data buffer.\n * @param       p_header_size   pointer to the size of the data buffer, it is changed by the function.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n *\n*/\nstatic OPJ_BOOL opj_j2k_write_SQcd_SQcc(opj_j2k_t *p_j2k,\n                                                                            OPJ_UINT32 p_tile_no,\n                                                                            OPJ_UINT32 p_comp_no,\n                                                                            OPJ_BYTE * p_data,\n                                                                            OPJ_UINT32 * p_header_size,\n                                                                            opj_event_mgr_t * p_manager);\n\n/**\n * Updates the Tile Length Marker.\n */\nstatic void opj_j2k_update_tlm ( opj_j2k_t * p_j2k, OPJ_UINT32 p_tile_part_size);\n\n/**\n * Reads a SQcd or SQcc element, i.e. the quantization values of a band in the QCD or QCC.\n *\n * @param       p_j2k           J2K codec.\n * @param       compno          the component number to output.\n * @param       p_header_data   the data buffer.\n * @param       p_header_size   pointer to the size of the data buffer, it is changed by the function.\n * @param       p_manager       the user event manager.\n *\n*/\nstatic OPJ_BOOL opj_j2k_read_SQcd_SQcc( opj_j2k_t *p_j2k,\n                                        OPJ_UINT32 compno,\n                                        OPJ_BYTE * p_header_data,\n                                        OPJ_UINT32 * p_header_size,\n                                        opj_event_mgr_t * p_manager );\n\n/**\n * Copies the tile component parameters of all the component from the first tile component.\n *\n * @param               p_j2k           the J2k codec.\n */\nstatic void opj_j2k_copy_tile_component_parameters( opj_j2k_t *p_j2k );\n\n/**\n * Copies the tile quantization parameters of all the component from the first tile component.\n *\n * @param               p_j2k           the J2k codec.\n */\nstatic void opj_j2k_copy_tile_quantization_parameters( opj_j2k_t *p_j2k );\n\n/**\n * Reads the tiles.\n */\nstatic OPJ_BOOL opj_j2k_decode_tiles (  opj_j2k_t *p_j2k,\n                                        opj_stream_private_t *p_stream,\n                                        opj_event_mgr_t * p_manager);\n\nstatic OPJ_BOOL opj_j2k_pre_write_tile ( opj_j2k_t * p_j2k,\n                                                                             OPJ_UINT32 p_tile_index,\n                                                                             opj_stream_private_t *p_stream,\n                                                                             opj_event_mgr_t * p_manager );\n\nstatic OPJ_BOOL opj_j2k_update_image_data (opj_tcd_t * p_tcd, OPJ_BYTE * p_data, opj_image_t* p_output_image);\n\nstatic void opj_get_tile_dimensions(opj_image_t * l_image,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\topj_tcd_tilecomp_t * l_tilec,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\topj_image_comp_t * l_img_comp,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tOPJ_UINT32* l_size_comp,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tOPJ_UINT32* l_width,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tOPJ_UINT32* l_height,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tOPJ_UINT32* l_offset_x,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tOPJ_UINT32* l_offset_y,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tOPJ_UINT32* l_image_width,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tOPJ_UINT32* l_stride,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tOPJ_UINT32* l_tile_offset);\n\nstatic void opj_j2k_get_tile_data (opj_tcd_t * p_tcd, OPJ_BYTE * p_data);\n\nstatic OPJ_BOOL opj_j2k_post_write_tile (opj_j2k_t * p_j2k,\n                                                                             opj_stream_private_t *p_stream,\n                                                                             opj_event_mgr_t * p_manager );\n\n/**\n * Sets up the procedures to do on writing header.\n * Developers wanting to extend the library can add their own writing procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_header_writing (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager);\n\nstatic OPJ_BOOL opj_j2k_write_first_tile_part(  opj_j2k_t *p_j2k,\n                                                                                            OPJ_BYTE * p_data,\n                                                                                            OPJ_UINT32 * p_data_written,\n                                                                                            OPJ_UINT32 p_total_data_size,\n                                                                                            opj_stream_private_t *p_stream,\n                                                                                            struct opj_event_mgr * p_manager );\n\nstatic OPJ_BOOL opj_j2k_write_all_tile_parts(   opj_j2k_t *p_j2k,\n                                                                                            OPJ_BYTE * p_data,\n                                                                                            OPJ_UINT32 * p_data_written,\n                                                                                            OPJ_UINT32 p_total_data_size,\n                                                                                            opj_stream_private_t *p_stream,\n                                                                                            struct opj_event_mgr * p_manager );\n\n/**\n * Gets the offset of the header.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_get_end_header( opj_j2k_t *p_j2k,\n                                        opj_stream_private_t *p_stream,\n                                        opj_event_mgr_t * p_manager );\n\nstatic OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k);\n\n/*\n * -----------------------------------------------------------------------\n * -----------------------------------------------------------------------\n * -----------------------------------------------------------------------\n */\n\n/**\n * Writes the SOC marker (Start Of Codestream)\n *\n * @param       p_stream                        the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_soc(      opj_j2k_t *p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                            opj_event_mgr_t * p_manager );\n\n/**\n * Reads a SOC marker (Start of Codestream)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_stream        XXX needs data\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_soc(   opj_j2k_t *p_j2k,\n                                    opj_stream_private_t *p_stream,\n                                    opj_event_mgr_t * p_manager );\n\n/**\n * Writes the SIZ marker (image and tile size)\n *\n * @param       p_j2k           J2K codec.\n * @param       p_stream        the stream to write data to.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_siz(      opj_j2k_t *p_j2k,\n                                                                opj_stream_private_t *p_stream,\n                                                                opj_event_mgr_t * p_manager );\n\n/**\n * Reads a SIZ marker (image and tile size)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_header_data   the data contained in the SIZ box.\n * @param       p_header_size   the size of the data contained in the SIZ marker.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Writes the COM marker (comment)\n *\n * @param       p_stream                        the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_com(      opj_j2k_t *p_j2k,\n                                                                        opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n\n/**\n * Reads a COM marker (comments)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_header_data   the data contained in the COM box.\n * @param       p_header_size   the size of the data contained in the COM marker.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_com (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager );\n/**\n * Writes the COD marker (Coding style default)\n *\n * @param       p_stream                        the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_cod(      opj_j2k_t *p_j2k,\n                                                                        opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n\n/**\n * Reads a COD marker (Coding Styke defaults)\n * @param       p_header_data   the data contained in the COD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the COD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_cod (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager);\n\n/**\n * Compares 2 COC markers (Coding style component)\n *\n * @param       p_j2k            J2K codec.\n * @param       p_first_comp_no  the index of the first component to compare.\n * @param       p_second_comp_no the index of the second component to compare.\n *\n * @return      OPJ_TRUE if equals\n */\nstatic OPJ_BOOL opj_j2k_compare_coc(opj_j2k_t *p_j2k, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no);\n\n/**\n * Writes the COC marker (Coding style component)\n *\n * @param       p_j2k       J2K codec.\n * @param       p_comp_no   the index of the component to output.\n * @param       p_stream    the stream to write data to.\n * @param       p_manager   the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_coc(  opj_j2k_t *p_j2k,\n                                                                OPJ_UINT32 p_comp_no,\n                                                                opj_stream_private_t *p_stream,\n                                                                opj_event_mgr_t * p_manager );\n\n/**\n * Writes the COC marker (Coding style component)\n *\n * @param       p_j2k                   J2K codec.\n * @param       p_comp_no               the index of the component to output.\n * @param       p_data          FIXME DOC\n * @param       p_data_written  FIXME DOC\n * @param       p_manager               the user event manager.\n*/\nstatic void opj_j2k_write_coc_in_memory(opj_j2k_t *p_j2k,\n                                                                            OPJ_UINT32 p_comp_no,\n                                                                            OPJ_BYTE * p_data,\n                                                                            OPJ_UINT32 * p_data_written,\n                                                                            opj_event_mgr_t * p_manager );\n\n/**\n * Gets the maximum size taken by a coc.\n *\n * @param       p_j2k   the jpeg2000 codec to use.\n */\nstatic OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k);\n\n/**\n * Reads a COC marker (Coding Style Component)\n * @param       p_header_data   the data contained in the COC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the COC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_coc (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager );\n\n/**\n * Writes the QCD marker (quantization default)\n *\n * @param       p_j2k                   J2K codec.\n * @param       p_stream                the stream to write data to.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_qcd(      opj_j2k_t *p_j2k,\n                                                                        opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n\n/**\n * Reads a QCD marker (Quantization defaults)\n * @param       p_header_data   the data contained in the QCD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the QCD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_qcd (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager );\n\n/**\n * Compare QCC markers (quantization component)\n *\n * @param       p_j2k                 J2K codec.\n * @param       p_first_comp_no       the index of the first component to compare.\n * @param       p_second_comp_no      the index of the second component to compare.\n *\n * @return OPJ_TRUE if equals.\n */\nstatic OPJ_BOOL opj_j2k_compare_qcc(opj_j2k_t *p_j2k, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no);\n\n/**\n * Writes the QCC marker (quantization component)\n *\n * @param       p_comp_no       the index of the component to output.\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_qcc(      opj_j2k_t *p_j2k,\n                                                                        OPJ_UINT32 p_comp_no,\n                                                                        opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n\n/**\n * Writes the QCC marker (quantization component)\n *\n * @param       p_j2k           J2K codec.\n * @param       p_comp_no       the index of the component to output.\n * @param       p_data          FIXME DOC\n * @param       p_data_written  the stream to write data to.\n * @param       p_manager       the user event manager.\n*/\nstatic void opj_j2k_write_qcc_in_memory(opj_j2k_t *p_j2k,\n                                                                            OPJ_UINT32 p_comp_no,\n                                                                            OPJ_BYTE * p_data,\n                                                                            OPJ_UINT32 * p_data_written,\n                                                                            opj_event_mgr_t * p_manager );\n\n/**\n * Gets the maximum size taken by a qcc.\n */\nstatic OPJ_UINT32 opj_j2k_get_max_qcc_size (opj_j2k_t *p_j2k);\n\n/**\n * Reads a QCC marker (Quantization component)\n * @param       p_header_data   the data contained in the QCC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the QCC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_qcc(   opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager);\n/**\n * Writes the POC marker (Progression Order Change)\n *\n * @param       p_stream                                the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_poc(      opj_j2k_t *p_j2k,\n                                                                        opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n/**\n * Writes the POC marker (Progression Order Change)\n *\n * @param       p_j2k          J2K codec.\n * @param       p_data         FIXME DOC\n * @param       p_data_written the stream to write data to.\n * @param       p_manager      the user event manager.\n */\nstatic void opj_j2k_write_poc_in_memory(opj_j2k_t *p_j2k,\n                                                                            OPJ_BYTE * p_data,\n                                                                            OPJ_UINT32 * p_data_written,\n                                                                            opj_event_mgr_t * p_manager );\n/**\n * Gets the maximum size taken by the writing of a POC.\n */\nstatic OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k);\n\n/**\n * Reads a POC marker (Progression Order Change)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_poc (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager );\n\n/**\n * Gets the maximum size taken by the toc headers of all the tile parts of any given tile.\n */\nstatic OPJ_UINT32 opj_j2k_get_max_toc_size (opj_j2k_t *p_j2k);\n\n/**\n * Gets the maximum size taken by the headers of the SOT.\n *\n * @param       p_j2k   the jpeg2000 codec to use.\n */\nstatic OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k);\n\n/**\n * Reads a CRG marker (Component registration)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_crg (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager );\n/**\n * Reads a TLM marker (Tile Length Marker)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_tlm (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager);\n\n/**\n * Writes the updated tlm.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_updated_tlm(      opj_j2k_t *p_j2k,\n                                            opj_stream_private_t *p_stream,\n                                            opj_event_mgr_t * p_manager );\n\n/**\n * Reads a PLM marker (Packet length, main header marker)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_plm (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager);\n/**\n * Reads a PLT marker (Packet length, tile-part header)\n *\n * @param       p_header_data   the data contained in the PLT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the PLT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_plt (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager );\n\n/**\n * Reads a PPM marker (Packed headers, main header)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n */\n\nstatic OPJ_BOOL opj_j2k_read_ppm (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t opj_j2k_t *p_j2k,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_BYTE * p_header_data,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_UINT32 p_header_size,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t opj_event_mgr_t * p_manager );\n\n/**\n * Merges all PPM markers read (Packed headers, main header)\n *\n * @param       p_cp      main coding parameters.\n * @param       p_manager the user event manager.\n */\nstatic OPJ_BOOL opj_j2k_merge_ppm ( opj_cp_t *p_cp, opj_event_mgr_t * p_manager );\n\n/**\n * Reads a PPT marker (Packed packet headers, tile-part header)\n *\n * @param       p_header_data   the data contained in the PPT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the PPT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_ppt (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager );\n\n/**\n * Merges all PPT markers read (Packed headers, tile-part header)\n *\n * @param       p_tcp   the tile.\n * @param       p_manager               the user event manager.\n */\nstatic OPJ_BOOL opj_j2k_merge_ppt (  opj_tcp_t *p_tcp,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   opj_event_mgr_t * p_manager );\n\n\n/**\n * Writes the TLM marker (Tile Length Marker)\n *\n * @param       p_stream                                the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_tlm(      opj_j2k_t *p_j2k,\n                                                                        opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n\n/**\n * Writes the SOT marker (Start of tile-part)\n *\n * @param       p_j2k            J2K codec.\n * @param       p_data           FIXME DOC\n * @param       p_data_written   FIXME DOC\n * @param       p_stream         the stream to write data to.\n * @param       p_manager        the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_sot(      opj_j2k_t *p_j2k,\n                                                                        OPJ_BYTE * p_data,\n                                                                        OPJ_UINT32 * p_data_written,\n                                                                        const opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n\n/**\n * Reads values from a SOT marker (Start of tile-part)\n *\n * the j2k decoder state is not affected. No side effects, no checks except for p_header_size.\n *\n * @param       p_header_data   the data contained in the SOT marker.\n * @param       p_header_size   the size of the data contained in the SOT marker.\n * @param       p_tile_no       Isot.\n * @param       p_tot_len       Psot.\n * @param       p_current_part  TPsot.\n * @param       p_num_parts     TNsot.\n * @param       p_manager       the user event manager.\n */\nstatic OPJ_BOOL opj_j2k_get_sot_values(OPJ_BYTE *  p_header_data,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_UINT32  p_header_size,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_UINT32* p_tile_no,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_UINT32* p_tot_len,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_UINT32* p_current_part,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_UINT32* p_num_parts,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t opj_event_mgr_t * p_manager );\n/**\n * Reads a SOT marker (Start of tile-part)\n *\n * @param       p_header_data   the data contained in the SOT marker.\n * @param       p_j2k           the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the PPT marker.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_sot (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager );\n/**\n * Writes the SOD marker (Start of data)\n *\n * @param       p_j2k               J2K codec.\n * @param       p_tile_coder        FIXME DOC\n * @param       p_data              FIXME DOC\n * @param       p_data_written      FIXME DOC\n * @param       p_total_data_size   FIXME DOC\n * @param       p_stream            the stream to write data to.\n * @param       p_manager           the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_sod(      opj_j2k_t *p_j2k,\n                                                                        opj_tcd_t * p_tile_coder,\n                                                                        OPJ_BYTE * p_data,\n                                                                        OPJ_UINT32 * p_data_written,\n                                                                        OPJ_UINT32 p_total_data_size,\n                                                                        const opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n\n/**\n * Reads a SOD marker (Start Of Data)\n *\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_stream                FIXME DOC\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_sod(   opj_j2k_t *p_j2k,\n                                    opj_stream_private_t *p_stream,\n                                    opj_event_mgr_t * p_manager );\n\nstatic void opj_j2k_update_tlm (opj_j2k_t * p_j2k, OPJ_UINT32 p_tile_part_size )\n{\n        opj_write_bytes(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,p_j2k->m_current_tile_number,1);            /* PSOT */\n        ++p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current;\n\n        opj_write_bytes(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,p_tile_part_size,4);                                        /* PSOT */\n        p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current += 4;\n}\n\n/**\n * Writes the RGN marker (Region Of Interest)\n *\n * @param       p_tile_no               the tile to output\n * @param       p_comp_no               the component to output\n * @param       nb_comps                the number of components\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_rgn(  opj_j2k_t *p_j2k,\n                                    OPJ_UINT32 p_tile_no,\n                                    OPJ_UINT32 p_comp_no,\n                                    OPJ_UINT32 nb_comps,\n                                    opj_stream_private_t *p_stream,\n                                    opj_event_mgr_t * p_manager );\n\n/**\n * Reads a RGN marker (Region Of Interest)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_rgn (opj_j2k_t *p_j2k,\n                                  OPJ_BYTE * p_header_data,\n                                  OPJ_UINT32 p_header_size,\n                                  opj_event_mgr_t * p_manager );\n\n/**\n * Writes the EOC marker (End of Codestream)\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_eoc(      opj_j2k_t *p_j2k,\n                                    opj_stream_private_t *p_stream,\n                                    opj_event_mgr_t * p_manager );\n\n#if 0\n/**\n * Reads a EOC marker (End Of Codestream)\n *\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_stream                FIXME DOC\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_eoc (      opj_j2k_t *p_j2k,\n                                                                opj_stream_private_t *p_stream,\n                                                                opj_event_mgr_t * p_manager );\n#endif\n\n/**\n * Writes the CBD-MCT-MCC-MCO markers (Multi components transform)\n *\n * @param       p_stream                        the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_mct_data_group(   opj_j2k_t *p_j2k,\n                                                opj_stream_private_t *p_stream,\n                                                opj_event_mgr_t * p_manager );\n\n/**\n * Inits the Info\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_init_info(      opj_j2k_t *p_j2k,\n                                    opj_stream_private_t *p_stream,\n                                    opj_event_mgr_t * p_manager );\n\n/**\nAdd main header marker information\n@param cstr_index    Codestream information structure\n@param type         marker type\n@param pos          byte offset of marker segment\n@param len          length of marker segment\n */\nstatic OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index, OPJ_UINT32 type, OPJ_OFF_T pos, OPJ_UINT32 len) ;\n/**\nAdd tile header marker information\n@param tileno       tile index number\n@param cstr_index   Codestream information structure\n@param type         marker type\n@param pos          byte offset of marker segment\n@param len          length of marker segment\n */\nstatic OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno, opj_codestream_index_t *cstr_index, OPJ_UINT32 type, OPJ_OFF_T pos, OPJ_UINT32 len);\n\n/**\n * Reads an unknown marker\n *\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_stream                the stream object to read from.\n * @param       output_marker           FIXME DOC\n * @param       p_manager               the user event manager.\n *\n * @return      true                    if the marker could be deduced.\n*/\nstatic OPJ_BOOL opj_j2k_read_unk( opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  OPJ_UINT32 *output_marker,\n                                  opj_event_mgr_t * p_manager );\n\n/**\n * Writes the MCT marker (Multiple Component Transform)\n *\n * @param       p_j2k           J2K codec.\n * @param       p_mct_record    FIXME DOC\n * @param       p_stream        the stream to write data to.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_mct_record(       opj_j2k_t *p_j2k,\n                                                                                    opj_mct_data_t * p_mct_record,\n                                            opj_stream_private_t *p_stream,\n                                            opj_event_mgr_t * p_manager );\n\n/**\n * Reads a MCT marker (Multiple Component Transform)\n *\n * @param       p_header_data   the data contained in the MCT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the MCT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_mct (      opj_j2k_t *p_j2k,\n                                                                    OPJ_BYTE * p_header_data,\n                                                                    OPJ_UINT32 p_header_size,\n                                                                    opj_event_mgr_t * p_manager );\n\n/**\n * Writes the MCC marker (Multiple Component Collection)\n *\n * @param       p_j2k                   J2K codec.\n * @param       p_mcc_record            FIXME DOC\n * @param       p_stream                the stream to write data to.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_mcc_record(   opj_j2k_t *p_j2k,\n                                            opj_simple_mcc_decorrelation_data_t * p_mcc_record,\n                                            opj_stream_private_t *p_stream,\n                                            opj_event_mgr_t * p_manager );\n\n/**\n * Reads a MCC marker (Multiple Component Collection)\n *\n * @param       p_header_data   the data contained in the MCC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the MCC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_mcc (      opj_j2k_t *p_j2k,\n                                                                    OPJ_BYTE * p_header_data,\n                                                                    OPJ_UINT32 p_header_size,\n                                                                    opj_event_mgr_t * p_manager );\n\n/**\n * Writes the MCO marker (Multiple component transformation ordering)\n *\n * @param       p_stream                                the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_mco(      opj_j2k_t *p_j2k,\n                                    opj_stream_private_t *p_stream,\n                                    opj_event_mgr_t * p_manager );\n\n/**\n * Reads a MCO marker (Multiple Component Transform Ordering)\n *\n * @param       p_header_data   the data contained in the MCO box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the MCO marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_mco (      opj_j2k_t *p_j2k,\n                                                                    OPJ_BYTE * p_header_data,\n                                                                    OPJ_UINT32 p_header_size,\n                                                                    opj_event_mgr_t * p_manager );\n\nstatic OPJ_BOOL opj_j2k_add_mct(opj_tcp_t * p_tcp, opj_image_t * p_image, OPJ_UINT32 p_index);\n\nstatic void  opj_j2k_read_int16_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_float32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_float64_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\n\nstatic void  opj_j2k_read_int16_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_int32_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_float32_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_float64_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\n\nstatic void  opj_j2k_write_float_to_int16 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_write_float_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_write_float_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_write_float_to_float64 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\n\n/**\n * Ends the encoding, i.e. frees memory.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_end_encoding(   opj_j2k_t *p_j2k,\n                                                                            opj_stream_private_t *p_stream,\n                                                                            opj_event_mgr_t * p_manager );\n\n/**\n * Writes the CBD marker (Component bit depth definition)\n *\n * @param       p_stream                                the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_cbd(      opj_j2k_t *p_j2k,\n                                                                    opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n\n/**\n * Reads a CBD marker (Component bit depth definition)\n * @param       p_header_data   the data contained in the CBD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the CBD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_cbd (      opj_j2k_t *p_j2k,\n                                                                OPJ_BYTE * p_header_data,\n                                                                OPJ_UINT32 p_header_size,\n                                                                opj_event_mgr_t * p_manager);\n\n\n/**\n * Writes COC marker for each component.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_all_coc( opj_j2k_t *p_j2k,\n                                                                        opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n\n/**\n * Writes QCC marker for each component.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_all_qcc( opj_j2k_t *p_j2k,\n                                                                        opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n\n/**\n * Writes regions of interests.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_regions(  opj_j2k_t *p_j2k,\n                                                                        opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n\n/**\n * Writes EPC ????\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_epc(      opj_j2k_t *p_j2k,\n                                                                    opj_stream_private_t *p_stream,\n                                                                    opj_event_mgr_t * p_manager );\n\n/**\n * Checks the progression order changes values. Tells of the poc given as input are valid.\n * A nice message is outputted at errors.\n *\n * @param       p_pocs                  the progression order changes.\n * @param       p_nb_pocs               the number of progression order changes.\n * @param       p_nb_resolutions        the number of resolutions.\n * @param       numcomps                the number of components\n * @param       numlayers               the number of layers.\n * @param       p_manager               the user event manager.\n *\n * @return      true if the pocs are valid.\n */\nstatic OPJ_BOOL opj_j2k_check_poc_val(  const opj_poc_t *p_pocs,\n                                                                            OPJ_UINT32 p_nb_pocs,\n                                                                            OPJ_UINT32 p_nb_resolutions,\n                                                                            OPJ_UINT32 numcomps,\n                                                                            OPJ_UINT32 numlayers,\n                                                                            opj_event_mgr_t * p_manager);\n\n/**\n * Gets the number of tile parts used for the given change of progression (if any) and the given tile.\n *\n * @param               cp                      the coding parameters.\n * @param               pino            the offset of the given poc (i.e. its position in the coding parameter).\n * @param               tileno          the given tile.\n *\n * @return              the number of tile parts.\n */\nstatic OPJ_UINT32 opj_j2k_get_num_tp( opj_cp_t *cp, OPJ_UINT32 pino, OPJ_UINT32 tileno);\n\n/**\n * Calculates the total number of tile parts needed by the encoder to\n * encode such an image. If not enough memory is available, then the function return false.\n *\n * @param       p_nb_tiles      pointer that will hold the number of tile parts.\n * @param       cp                      the coding parameters for the image.\n * @param       image           the image to encode.\n * @param       p_j2k                   the p_j2k encoder.\n * @param       p_manager       the user event manager.\n *\n * @return true if the function was successful, false else.\n */\nstatic OPJ_BOOL opj_j2k_calculate_tp(   opj_j2k_t *p_j2k,\n                                                                            opj_cp_t *cp,\n                                                                            OPJ_UINT32 * p_nb_tiles,\n                                                                            opj_image_t *image,\n                                                                            opj_event_mgr_t * p_manager);\n\nstatic void opj_j2k_dump_MH_info(opj_j2k_t* p_j2k, FILE* out_stream);\n\nstatic void opj_j2k_dump_MH_index(opj_j2k_t* p_j2k, FILE* out_stream);\n\nstatic opj_codestream_index_t* opj_j2k_create_cstr_index(void);\n\nstatic OPJ_FLOAT32 opj_j2k_get_tp_stride (opj_tcp_t * p_tcp);\n\nstatic OPJ_FLOAT32 opj_j2k_get_default_stride (opj_tcp_t * p_tcp);\n\nstatic int opj_j2k_initialise_4K_poc(opj_poc_t *POC, int numres);\n\nstatic void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters, opj_image_t *image, opj_event_mgr_t *p_manager);\n\nstatic OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image, OPJ_UINT16 rsiz, opj_event_mgr_t *p_manager);\n\n/**\n * Checks for invalid number of tile-parts in SOT marker (TPsot==TNsot). See issue 254.\n *\n * @param       p_stream            the stream to read data from.\n * @param       tile_no             tile number we're looking for.\n * @param       p_correction_needed output value. if true, non conformant codestream needs TNsot correction.\n * @param       p_manager       the user event manager.\n *\n * @return true if the function was successful, false else.\n */\nstatic OPJ_BOOL opj_j2k_need_nb_tile_parts_correction(opj_stream_private_t *p_stream, OPJ_UINT32 tile_no, OPJ_BOOL* p_correction_needed, opj_event_mgr_t * p_manager );\n\n/*@}*/\n\n/*@}*/\n\n/* ----------------------------------------------------------------------- */\ntypedef struct j2k_prog_order{\n        OPJ_PROG_ORDER enum_prog;\n        char str_prog[5];\n}j2k_prog_order_t;\n\nstatic j2k_prog_order_t j2k_prog_order_list[] = {\n        {OPJ_CPRL, \"CPRL\"},\n        {OPJ_LRCP, \"LRCP\"},\n        {OPJ_PCRL, \"PCRL\"},\n        {OPJ_RLCP, \"RLCP\"},\n        {OPJ_RPCL, \"RPCL\"},\n        {(OPJ_PROG_ORDER)-1, \"\"}\n};\n\n/**\n * FIXME DOC\n */\nstatic const OPJ_UINT32 MCT_ELEMENT_SIZE [] =\n{\n        2,\n        4,\n        4,\n        8\n};\n\ntypedef void (* opj_j2k_mct_function) (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\n\nstatic const opj_j2k_mct_function j2k_mct_read_functions_to_float [] =\n{\n        opj_j2k_read_int16_to_float,\n        opj_j2k_read_int32_to_float,\n        opj_j2k_read_float32_to_float,\n        opj_j2k_read_float64_to_float\n};\n\nstatic const opj_j2k_mct_function j2k_mct_read_functions_to_int32 [] =\n{\n        opj_j2k_read_int16_to_int32,\n        opj_j2k_read_int32_to_int32,\n        opj_j2k_read_float32_to_int32,\n        opj_j2k_read_float64_to_int32\n};\n\nstatic const opj_j2k_mct_function j2k_mct_write_functions_from_float [] =\n{\n        opj_j2k_write_float_to_int16,\n        opj_j2k_write_float_to_int32,\n        opj_j2k_write_float_to_float,\n        opj_j2k_write_float_to_float64\n};\n\ntypedef struct opj_dec_memory_marker_handler\n{\n        /** marker value */\n        OPJ_UINT32 id;\n        /** value of the state when the marker can appear */\n        OPJ_UINT32 states;\n        /** action linked to the marker */\n        OPJ_BOOL (*handler) (   opj_j2k_t *p_j2k,\n                            OPJ_BYTE * p_header_data,\n                            OPJ_UINT32 p_header_size,\n                            opj_event_mgr_t * p_manager );\n}\nopj_dec_memory_marker_handler_t;\n\nstatic const opj_dec_memory_marker_handler_t j2k_memory_marker_handler_tab [] =\n{\n  {J2K_MS_SOT, J2K_STATE_MH | J2K_STATE_TPHSOT, opj_j2k_read_sot},\n  {J2K_MS_COD, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_cod},\n  {J2K_MS_COC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_coc},\n  {J2K_MS_RGN, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_rgn},\n  {J2K_MS_QCD, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_qcd},\n  {J2K_MS_QCC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_qcc},\n  {J2K_MS_POC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_poc},\n  {J2K_MS_SIZ, J2K_STATE_MHSIZ, opj_j2k_read_siz},\n  {J2K_MS_TLM, J2K_STATE_MH, opj_j2k_read_tlm},\n  {J2K_MS_PLM, J2K_STATE_MH, opj_j2k_read_plm},\n  {J2K_MS_PLT, J2K_STATE_TPH, opj_j2k_read_plt},\n  {J2K_MS_PPM, J2K_STATE_MH, opj_j2k_read_ppm},\n  {J2K_MS_PPT, J2K_STATE_TPH, opj_j2k_read_ppt},\n  {J2K_MS_SOP, 0, 0},\n  {J2K_MS_CRG, J2K_STATE_MH, opj_j2k_read_crg},\n  {J2K_MS_COM, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_com},\n  {J2K_MS_MCT, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_mct},\n  {J2K_MS_CBD, J2K_STATE_MH , opj_j2k_read_cbd},\n  {J2K_MS_MCC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_mcc},\n  {J2K_MS_MCO, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_mco},\n#ifdef USE_JPWL\n#ifdef TODO_MS /* remove these functions which are not commpatible with the v2 API */\n  {J2K_MS_EPC, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_epc},\n  {J2K_MS_EPB, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_epb},\n  {J2K_MS_ESD, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_esd},\n  {J2K_MS_RED, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_red},\n#endif\n#endif /* USE_JPWL */\n#ifdef USE_JPSEC\n  {J2K_MS_SEC, J2K_DEC_STATE_MH, j2k_read_sec},\n  {J2K_MS_INSEC, 0, j2k_read_insec}\n#endif /* USE_JPSEC */\n  {J2K_MS_UNK, J2K_STATE_MH | J2K_STATE_TPH, 0}/*opj_j2k_read_unk is directly used*/\n};\n\nstatic void  opj_j2k_read_int16_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                opj_read_bytes(l_src_data,&l_temp,2);\n\n                l_src_data+=sizeof(OPJ_INT16);\n\n                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;\n        }\n}\n\nstatic void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                opj_read_bytes(l_src_data,&l_temp,4);\n\n                l_src_data+=sizeof(OPJ_INT32);\n\n                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;\n        }\n}\n\nstatic void  opj_j2k_read_float32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;\n        OPJ_UINT32 i;\n        OPJ_FLOAT32 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                opj_read_float(l_src_data,&l_temp);\n\n                l_src_data+=sizeof(OPJ_FLOAT32);\n\n                *(l_dest_data++) = l_temp;\n        }\n}\n\nstatic void  opj_j2k_read_float64_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;\n        OPJ_UINT32 i;\n        OPJ_FLOAT64 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                opj_read_double(l_src_data,&l_temp);\n\n                l_src_data+=sizeof(OPJ_FLOAT64);\n\n                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;\n        }\n}\n\nstatic void  opj_j2k_read_int16_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n        OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                opj_read_bytes(l_src_data,&l_temp,2);\n\n                l_src_data+=sizeof(OPJ_INT16);\n\n                *(l_dest_data++) = (OPJ_INT32) l_temp;\n        }\n}\n\nstatic void  opj_j2k_read_int32_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n        OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                opj_read_bytes(l_src_data,&l_temp,4);\n\n                l_src_data+=sizeof(OPJ_INT32);\n\n                *(l_dest_data++) = (OPJ_INT32) l_temp;\n        }\n}\n\nstatic void  opj_j2k_read_float32_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n        OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;\n        OPJ_UINT32 i;\n        OPJ_FLOAT32 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                opj_read_float(l_src_data,&l_temp);\n\n                l_src_data+=sizeof(OPJ_FLOAT32);\n\n                *(l_dest_data++) = (OPJ_INT32) l_temp;\n        }\n}\n\nstatic void  opj_j2k_read_float64_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n        OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;\n        OPJ_UINT32 i;\n        OPJ_FLOAT64 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                opj_read_double(l_src_data,&l_temp);\n\n                l_src_data+=sizeof(OPJ_FLOAT64);\n\n                *(l_dest_data++) = (OPJ_INT32) l_temp;\n        }\n}\n\nstatic void  opj_j2k_write_float_to_int16 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;\n        OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                l_temp = (OPJ_UINT32) *(l_src_data++);\n\n                opj_write_bytes(l_dest_data,l_temp,sizeof(OPJ_INT16));\n\n                l_dest_data+=sizeof(OPJ_INT16);\n        }\n}\n\nstatic void opj_j2k_write_float_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;\n        OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                l_temp = (OPJ_UINT32) *(l_src_data++);\n\n                opj_write_bytes(l_dest_data,l_temp,sizeof(OPJ_INT32));\n\n                l_dest_data+=sizeof(OPJ_INT32);\n        }\n}\n\nstatic void  opj_j2k_write_float_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;\n        OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;\n        OPJ_UINT32 i;\n        OPJ_FLOAT32 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                l_temp = (OPJ_FLOAT32) *(l_src_data++);\n\n                opj_write_float(l_dest_data,l_temp);\n\n                l_dest_data+=sizeof(OPJ_FLOAT32);\n        }\n}\n\nstatic void  opj_j2k_write_float_to_float64 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;\n        OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;\n        OPJ_UINT32 i;\n        OPJ_FLOAT64 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                l_temp = (OPJ_FLOAT64) *(l_src_data++);\n\n                opj_write_double(l_dest_data,l_temp);\n\n                l_dest_data+=sizeof(OPJ_FLOAT64);\n        }\n}\n\nchar *opj_j2k_convert_progression_order(OPJ_PROG_ORDER prg_order){\n        j2k_prog_order_t *po;\n        for(po = j2k_prog_order_list; po->enum_prog != -1; po++ ){\n                if(po->enum_prog == prg_order){\n                        return po->str_prog;\n                }\n        }\n        return po->str_prog;\n}\n\nstatic OPJ_BOOL opj_j2k_check_poc_val( const opj_poc_t *p_pocs,\n                                                        OPJ_UINT32 p_nb_pocs,\n                                                        OPJ_UINT32 p_nb_resolutions,\n                                                        OPJ_UINT32 p_num_comps,\n                                                        OPJ_UINT32 p_num_layers,\n                                                        opj_event_mgr_t * p_manager)\n{\n        OPJ_UINT32* packet_array;\n        OPJ_UINT32 index , resno, compno, layno;\n        OPJ_UINT32 i;\n        OPJ_UINT32 step_c = 1;\n        OPJ_UINT32 step_r = p_num_comps * step_c;\n        OPJ_UINT32 step_l = p_nb_resolutions * step_r;\n        OPJ_BOOL loss = OPJ_FALSE;\n        OPJ_UINT32 layno0 = 0;\n\n        packet_array = (OPJ_UINT32*) opj_calloc(step_l * p_num_layers, sizeof(OPJ_UINT32));\n        if (packet_array == 00) {\n                opj_event_msg(p_manager , EVT_ERROR, \"Not enough memory for checking the poc values.\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (p_nb_pocs == 0) {\n        opj_free(packet_array);\n                return OPJ_TRUE;\n        }\n\n        index = step_r * p_pocs->resno0;\n        /* take each resolution for each poc */\n        for (resno = p_pocs->resno0 ; resno < p_pocs->resno1 ; ++resno)\n        {\n                OPJ_UINT32 res_index = index + p_pocs->compno0 * step_c;\n\n                /* take each comp of each resolution for each poc */\n                for (compno = p_pocs->compno0 ; compno < p_pocs->compno1 ; ++compno) {\n                        OPJ_UINT32 comp_index = res_index + layno0 * step_l;\n\n                        /* and finally take each layer of each res of ... */\n                        for (layno = layno0; layno < p_pocs->layno1 ; ++layno) {\n                                /*index = step_r * resno + step_c * compno + step_l * layno;*/\n                                packet_array[comp_index] = 1;\n                                comp_index += step_l;\n                        }\n\n                        res_index += step_c;\n                }\n\n                index += step_r;\n        }\n        ++p_pocs;\n\n        /* iterate through all the pocs */\n        for (i = 1; i < p_nb_pocs ; ++i) {\n                OPJ_UINT32 l_last_layno1 = (p_pocs-1)->layno1 ;\n\n                layno0 = (p_pocs->layno1 > l_last_layno1)? l_last_layno1 : 0;\n                index = step_r * p_pocs->resno0;\n\n                /* take each resolution for each poc */\n                for (resno = p_pocs->resno0 ; resno < p_pocs->resno1 ; ++resno) {\n                        OPJ_UINT32 res_index = index + p_pocs->compno0 * step_c;\n\n                        /* take each comp of each resolution for each poc */\n                        for (compno = p_pocs->compno0 ; compno < p_pocs->compno1 ; ++compno) {\n                                OPJ_UINT32 comp_index = res_index + layno0 * step_l;\n\n                                /* and finally take each layer of each res of ... */\n                                for (layno = layno0; layno < p_pocs->layno1 ; ++layno) {\n                                        /*index = step_r * resno + step_c * compno + step_l * layno;*/\n                                        packet_array[comp_index] = 1;\n                                        comp_index += step_l;\n                                }\n\n                                res_index += step_c;\n                        }\n\n                        index += step_r;\n                }\n\n                ++p_pocs;\n        }\n\n        index = 0;\n        for (layno = 0; layno < p_num_layers ; ++layno) {\n                for (resno = 0; resno < p_nb_resolutions; ++resno) {\n                        for (compno = 0; compno < p_num_comps; ++compno) {\n                                loss |= (packet_array[index]!=1);\n                                /*index = step_r * resno + step_c * compno + step_l * layno;*/\n                                index += step_c;\n                        }\n                }\n        }\n\n        if (loss) {\n                opj_event_msg(p_manager , EVT_ERROR, \"Missing packets possible loss of data\\n\");\n        }\n\n        opj_free(packet_array);\n\n        return !loss;\n}\n\n/* ----------------------------------------------------------------------- */\n\nstatic OPJ_UINT32 opj_j2k_get_num_tp(opj_cp_t *cp, OPJ_UINT32 pino, OPJ_UINT32 tileno)\n{\n        const OPJ_CHAR *prog = 00;\n        OPJ_INT32 i;\n        OPJ_UINT32 tpnum = 1;\n        opj_tcp_t *tcp = 00;\n        opj_poc_t * l_current_poc = 00;\n\n        /*  preconditions */\n        assert(tileno < (cp->tw * cp->th));\n        assert(pino < (cp->tcps[tileno].numpocs + 1));\n\n        /* get the given tile coding parameter */\n        tcp = &cp->tcps[tileno];\n        assert(tcp != 00);\n\n        l_current_poc = &(tcp->pocs[pino]);\n        assert(l_current_poc != 0);\n\n        /* get the progression order as a character string */\n        prog = opj_j2k_convert_progression_order(tcp->prg);\n        assert(strlen(prog) > 0);\n\n        if (cp->m_specific_param.m_enc.m_tp_on == 1) {\n                for (i=0;i<4;++i) {\n                        switch (prog[i])\n                        {\n                                /* component wise */\n                                case 'C':\n                                        tpnum *= l_current_poc->compE;\n                                        break;\n                                /* resolution wise */\n                                case 'R':\n                                        tpnum *= l_current_poc->resE;\n                                        break;\n                                /* precinct wise */\n                                case 'P':\n                                        tpnum *= l_current_poc->prcE;\n                                        break;\n                                /* layer wise */\n                                case 'L':\n                                        tpnum *= l_current_poc->layE;\n                                        break;\n                        }\n                        /* whould we split here ? */\n                        if ( cp->m_specific_param.m_enc.m_tp_flag == prog[i] ) {\n                                cp->m_specific_param.m_enc.m_tp_pos=i;\n                                break;\n                        }\n                }\n        }\n        else {\n                tpnum=1;\n        }\n\n        return tpnum;\n}\n\nstatic OPJ_BOOL opj_j2k_calculate_tp(  opj_j2k_t *p_j2k,\n                                                        opj_cp_t *cp,\n                                                        OPJ_UINT32 * p_nb_tiles,\n                                                        opj_image_t *image,\n                                                        opj_event_mgr_t * p_manager\n                                )\n{\n        OPJ_UINT32 pino,tileno;\n        OPJ_UINT32 l_nb_tiles;\n        opj_tcp_t *tcp;\n\n        /* preconditions */\n        assert(p_nb_tiles != 00);\n        assert(cp != 00);\n        assert(image != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_nb_tiles = cp->tw * cp->th;\n        * p_nb_tiles = 0;\n        tcp = cp->tcps;\n\n        /* INDEX >> */\n        /* TODO mergeV2: check this part which use cstr_info */\n        /*if (p_j2k->cstr_info) {\n                opj_tile_info_t * l_info_tile_ptr = p_j2k->cstr_info->tile;\n\n                for (tileno = 0; tileno < l_nb_tiles; ++tileno) {\n                        OPJ_UINT32 cur_totnum_tp = 0;\n\n                        opj_pi_update_encoding_parameters(image,cp,tileno);\n\n                        for (pino = 0; pino <= tcp->numpocs; ++pino)\n                        {\n                                OPJ_UINT32 tp_num = opj_j2k_get_num_tp(cp,pino,tileno);\n\n                                *p_nb_tiles = *p_nb_tiles + tp_num;\n\n                                cur_totnum_tp += tp_num;\n                        }\n\n                        tcp->m_nb_tile_parts = cur_totnum_tp;\n\n                        l_info_tile_ptr->tp = (opj_tp_info_t *) opj_malloc(cur_totnum_tp * sizeof(opj_tp_info_t));\n                        if (l_info_tile_ptr->tp == 00) {\n                                return OPJ_FALSE;\n                        }\n\n                        memset(l_info_tile_ptr->tp,0,cur_totnum_tp * sizeof(opj_tp_info_t));\n\n                        l_info_tile_ptr->num_tps = cur_totnum_tp;\n\n                        ++l_info_tile_ptr;\n                        ++tcp;\n                }\n        }\n        else */{\n                for (tileno = 0; tileno < l_nb_tiles; ++tileno) {\n                        OPJ_UINT32 cur_totnum_tp = 0;\n\n                        opj_pi_update_encoding_parameters(image,cp,tileno);\n\n                        for (pino = 0; pino <= tcp->numpocs; ++pino) {\n                                OPJ_UINT32 tp_num = opj_j2k_get_num_tp(cp,pino,tileno);\n\n                                *p_nb_tiles = *p_nb_tiles + tp_num;\n\n                                cur_totnum_tp += tp_num;\n                        }\n                        tcp->m_nb_tile_parts = cur_totnum_tp;\n\n                        ++tcp;\n                }\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_soc(     opj_j2k_t *p_j2k,\n                                                opj_stream_private_t *p_stream,\n                                                    opj_event_mgr_t * p_manager )\n{\n        /* 2 bytes will be written */\n        OPJ_BYTE * l_start_stream = 00;\n\n        /* preconditions */\n        assert(p_stream != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_start_stream = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        /* write SOC identifier */\n        opj_write_bytes(l_start_stream,J2K_MS_SOC,2);\n\n        if (opj_stream_write_data(p_stream,l_start_stream,2,p_manager) != 2) {\n                return OPJ_FALSE;\n        }\n\n/* UniPG>> */\n#ifdef USE_JPWL\n        /* update markers struct */\n/*\n        OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_SOC, p_stream_tell(p_stream) - 2, 2);\n*/\n  assert( 0 && \"TODO\" );\n#endif /* USE_JPWL */\n/* <<UniPG */\n\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a SOC marker (Start of Codestream)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_stream        FIXME DOC\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_soc(   opj_j2k_t *p_j2k,\n                                    opj_stream_private_t *p_stream,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_BYTE l_data [2];\n        OPJ_UINT32 l_marker;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        if (opj_stream_read_data(p_stream,l_data,2,p_manager) != 2) {\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(l_data,&l_marker,2);\n        if (l_marker != J2K_MS_SOC) {\n                return OPJ_FALSE;\n        }\n\n        /* Next marker should be a SIZ marker in the main header */\n        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_MHSIZ;\n\n        /* FIXME move it in a index structure included in p_j2k*/\n        p_j2k->cstr_index->main_head_start = opj_stream_tell(p_stream) - 2;\n\n        opj_event_msg(p_manager, EVT_INFO, \"Start to read j2k main header (%d).\\n\", p_j2k->cstr_index->main_head_start);\n\n        /* Add the marker to the codestream index*/\n        if (OPJ_FALSE == opj_j2k_add_mhmarker(p_j2k->cstr_index, J2K_MS_SOC, p_j2k->cstr_index->main_head_start, 2)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add mh marker\\n\");\n                return OPJ_FALSE;\n        }\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_siz(     opj_j2k_t *p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager )\n{\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_size_len;\n        OPJ_BYTE * l_current_ptr;\n        opj_image_t * l_image = 00;\n        opj_cp_t *cp = 00;\n        opj_image_comp_t * l_img_comp = 00;\n\n        /* preconditions */\n        assert(p_stream != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_image = p_j2k->m_private_image;\n        cp = &(p_j2k->m_cp);\n        l_size_len = 40 + 3 * l_image->numcomps;\n        l_img_comp = l_image->comps;\n\n        if (l_size_len > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_size_len);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory for the SIZ marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_size_len;\n        }\n\n        l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        /* write SOC identifier */\n        opj_write_bytes(l_current_ptr,J2K_MS_SIZ,2);    /* SIZ */\n        l_current_ptr+=2;\n\n        opj_write_bytes(l_current_ptr,l_size_len-2,2); /* L_SIZ */\n        l_current_ptr+=2;\n\n        opj_write_bytes(l_current_ptr, cp->rsiz, 2);    /* Rsiz (capabilities) */\n        l_current_ptr+=2;\n\n        opj_write_bytes(l_current_ptr, l_image->x1, 4); /* Xsiz */\n        l_current_ptr+=4;\n\n        opj_write_bytes(l_current_ptr, l_image->y1, 4); /* Ysiz */\n        l_current_ptr+=4;\n\n        opj_write_bytes(l_current_ptr, l_image->x0, 4); /* X0siz */\n        l_current_ptr+=4;\n\n        opj_write_bytes(l_current_ptr, l_image->y0, 4); /* Y0siz */\n        l_current_ptr+=4;\n\n        opj_write_bytes(l_current_ptr, cp->tdx, 4);             /* XTsiz */\n        l_current_ptr+=4;\n\n        opj_write_bytes(l_current_ptr, cp->tdy, 4);             /* YTsiz */\n        l_current_ptr+=4;\n\n        opj_write_bytes(l_current_ptr, cp->tx0, 4);             /* XT0siz */\n        l_current_ptr+=4;\n\n        opj_write_bytes(l_current_ptr, cp->ty0, 4);             /* YT0siz */\n        l_current_ptr+=4;\n\n        opj_write_bytes(l_current_ptr, l_image->numcomps, 2);   /* Csiz */\n        l_current_ptr+=2;\n\n        for (i = 0; i < l_image->numcomps; ++i) {\n                /* TODO here with MCT ? */\n                opj_write_bytes(l_current_ptr, l_img_comp->prec - 1 + (l_img_comp->sgnd << 7), 1);      /* Ssiz_i */\n                ++l_current_ptr;\n\n                opj_write_bytes(l_current_ptr, l_img_comp->dx, 1);      /* XRsiz_i */\n                ++l_current_ptr;\n\n                opj_write_bytes(l_current_ptr, l_img_comp->dy, 1);      /* YRsiz_i */\n                ++l_current_ptr;\n\n                ++l_img_comp;\n        }\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_size_len,p_manager) != l_size_len) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a SIZ marker (image and tile size)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_header_data   the data contained in the SIZ box.\n * @param       p_header_size   the size of the data contained in the SIZ marker.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                 )\n{\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_nb_comp;\n        OPJ_UINT32 l_nb_comp_remain;\n        OPJ_UINT32 l_remaining_size;\n        OPJ_UINT32 l_nb_tiles;\n        OPJ_UINT32 l_tmp, l_tx1, l_ty1;\n        opj_image_t *l_image = 00;\n        opj_cp_t *l_cp = 00;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcp_t * l_current_tile_param = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_header_data != 00);\n\n        l_image = p_j2k->m_private_image;\n        l_cp = &(p_j2k->m_cp);\n\n        /* minimum size == 39 - 3 (= minimum component parameter) */\n        if (p_header_size < 36) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker size\\n\");\n                return OPJ_FALSE;\n        }\n\n        l_remaining_size = p_header_size - 36;\n        l_nb_comp = l_remaining_size / 3;\n        l_nb_comp_remain = l_remaining_size % 3;\n        if (l_nb_comp_remain != 0){\n                opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker size\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(p_header_data,&l_tmp ,2);                                                /* Rsiz (capabilities) */\n        p_header_data+=2;\n        l_cp->rsiz = (OPJ_UINT16) l_tmp;\n        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->x1, 4);   /* Xsiz */\n        p_header_data+=4;\n        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->y1, 4);   /* Ysiz */\n        p_header_data+=4;\n        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->x0, 4);   /* X0siz */\n        p_header_data+=4;\n        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->y0, 4);   /* Y0siz */\n        p_header_data+=4;\n        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->tdx, 4);             /* XTsiz */\n        p_header_data+=4;\n        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->tdy, 4);             /* YTsiz */\n        p_header_data+=4;\n        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->tx0, 4);             /* XT0siz */\n        p_header_data+=4;\n        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->ty0, 4);             /* YT0siz */\n        p_header_data+=4;\n        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_tmp, 2);                 /* Csiz */\n        p_header_data+=2;\n        if (l_tmp < 16385)\n                l_image->numcomps = (OPJ_UINT16) l_tmp;\n        else {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker: number of component is illegal -> %d\\n\", l_tmp);\n                return OPJ_FALSE;\n        }\n\n        if (l_image->numcomps != l_nb_comp) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker: number of component is not compatible with the remaining number of parameters ( %d vs %d)\\n\", l_image->numcomps, l_nb_comp);\n                return OPJ_FALSE;\n        }\n\n        /* testcase 4035.pdf.SIGSEGV.d8b.3375 */\n        /* testcase issue427-null-image-size.jp2 */\n        if ((l_image->x0 >= l_image->x1) || (l_image->y0 >= l_image->y1)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker: negative or zero image size (%\" PRId64 \" x %\" PRId64 \")\\n\", (OPJ_INT64)l_image->x1 - l_image->x0, (OPJ_INT64)l_image->y1 - l_image->y0);\n                return OPJ_FALSE;\n        }\n        /* testcase 2539.pdf.SIGFPE.706.1712 (also 3622.pdf.SIGFPE.706.2916 and 4008.pdf.SIGFPE.706.3345 and maybe more) */\n        if ((l_cp->tdx == 0U) || (l_cp->tdy == 0U)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker: invalid tile size (tdx: %d, tdy: %d)\\n\", l_cp->tdx, l_cp->tdy);\n                return OPJ_FALSE;\n        }\n\n        /* testcase 1610.pdf.SIGSEGV.59c.681 */\n        if ((0xFFFFFFFFU / l_image->x1) < l_image->y1) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Prevent buffer overflow (x1: %d, y1: %d)\\n\", l_image->x1, l_image->y1);\n                return OPJ_FALSE;\n        }\n\n        /* testcase issue427-illegal-tile-offset.jp2 */\n        l_tx1 = opj_uint_adds(l_cp->tx0, l_cp->tdx); /* manage overflow */\n        l_ty1 = opj_uint_adds(l_cp->ty0, l_cp->tdy); /* manage overflow */\n        if ((l_cp->tx0 > l_image->x0) || (l_cp->ty0 > l_image->y0) || (l_tx1 <= l_image->x0) || (l_ty1 <= l_image->y0) ) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker: illegal tile offset\\n\");\n                return OPJ_FALSE;\n        }\n\n#ifdef USE_JPWL\n        if (l_cp->correct) {\n                /* if JPWL is on, we check whether TX errors have damaged\n                  too much the SIZ parameters */\n                if (!(l_image->x1 * l_image->y1)) {\n                        opj_event_msg(p_manager, EVT_ERROR,\n                                \"JPWL: bad image size (%d x %d)\\n\",\n                                l_image->x1, l_image->y1);\n                        if (!JPWL_ASSUME) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                return OPJ_FALSE;\n                        }\n                }\n\n        /* FIXME check previously in the function so why keep this piece of code ? Need by the norm ?\n                if (l_image->numcomps != ((len - 38) / 3)) {\n                        opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,\n                                \"JPWL: Csiz is %d => space in SIZ only for %d comps.!!!\\n\",\n                                l_image->numcomps, ((len - 38) / 3));\n                        if (!JPWL_ASSUME) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                return OPJ_FALSE;\n                        }\n        */              /* we try to correct */\n        /*              opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust this\\n\");\n                        if (l_image->numcomps < ((len - 38) / 3)) {\n                                len = 38 + 3 * l_image->numcomps;\n                                opj_event_msg(p_manager, EVT_WARNING, \"- setting Lsiz to %d => HYPOTHESIS!!!\\n\",\n                                        len);\n                        } else {\n                                l_image->numcomps = ((len - 38) / 3);\n                                opj_event_msg(p_manager, EVT_WARNING, \"- setting Csiz to %d => HYPOTHESIS!!!\\n\",\n                                        l_image->numcomps);\n                        }\n                }\n        */\n\n                /* update components number in the jpwl_exp_comps filed */\n                l_cp->exp_comps = l_image->numcomps;\n        }\n#endif /* USE_JPWL */\n\n        /* Allocate the resulting image components */\n        l_image->comps = (opj_image_comp_t*) opj_calloc(l_image->numcomps, sizeof(opj_image_comp_t));\n        if (l_image->comps == 00){\n                l_image->numcomps = 0;\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to take in charge SIZ marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        l_img_comp = l_image->comps;\n\n        /* Read the component information */\n        for (i = 0; i < l_image->numcomps; ++i){\n                OPJ_UINT32 tmp;\n                opj_read_bytes(p_header_data,&tmp,1);   /* Ssiz_i */\n                ++p_header_data;\n                l_img_comp->prec = (tmp & 0x7f) + 1;\n                l_img_comp->sgnd = tmp >> 7;\n                opj_read_bytes(p_header_data,&tmp,1);   /* XRsiz_i */\n                ++p_header_data;\n                l_img_comp->dx = (OPJ_UINT32)tmp; /* should be between 1 and 255 */\n                opj_read_bytes(p_header_data,&tmp,1);   /* YRsiz_i */\n                ++p_header_data;\n                l_img_comp->dy = (OPJ_UINT32)tmp; /* should be between 1 and 255 */\n                if( l_img_comp->dx < 1 || l_img_comp->dx > 255 ||\n                    l_img_comp->dy < 1 || l_img_comp->dy > 255 ) {\n                    opj_event_msg(p_manager, EVT_ERROR,\n                                  \"Invalid values for comp = %d : dx=%u dy=%u (should be between 1 and 255 according to the JPEG2000 norm)\\n\",\n                                  i, l_img_comp->dx, l_img_comp->dy);\n                    return OPJ_FALSE;\n                }\n                if( l_img_comp->prec > 38) { /* TODO openjpeg won't handle more than ? */\n                    opj_event_msg(p_manager, EVT_ERROR,\n                                  \"Invalid values for comp = %d : prec=%u (should be between 1 and 38 according to the JPEG2000 norm)\\n\",\n                                  i, l_img_comp->prec);\n                    return OPJ_FALSE;\n                }\n\n#ifdef USE_JPWL\n                if (l_cp->correct) {\n                /* if JPWL is on, we check whether TX errors have damaged\n                        too much the SIZ parameters, again */\n                        if (!(l_image->comps[i].dx * l_image->comps[i].dy)) {\n                                opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,\n                                        \"JPWL: bad XRsiz_%d/YRsiz_%d (%d x %d)\\n\",\n                                        i, i, l_image->comps[i].dx, l_image->comps[i].dy);\n                                if (!JPWL_ASSUME) {\n                                        opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                        return OPJ_FALSE;\n                                }\n                                /* we try to correct */\n                                opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust them\\n\");\n                                if (!l_image->comps[i].dx) {\n                                        l_image->comps[i].dx = 1;\n                                        opj_event_msg(p_manager, EVT_WARNING, \"- setting XRsiz_%d to %d => HYPOTHESIS!!!\\n\",\n                                                i, l_image->comps[i].dx);\n                                }\n                                if (!l_image->comps[i].dy) {\n                                        l_image->comps[i].dy = 1;\n                                        opj_event_msg(p_manager, EVT_WARNING, \"- setting YRsiz_%d to %d => HYPOTHESIS!!!\\n\",\n                                                i, l_image->comps[i].dy);\n                                }\n                        }\n                }\n#endif /* USE_JPWL */\n                l_img_comp->resno_decoded = 0;                                                          /* number of resolution decoded */\n                l_img_comp->factor = l_cp->m_specific_param.m_dec.m_reduce; /* reducing factor per component */\n                ++l_img_comp;\n        }\n\n        /* Compute the number of tiles */\n        l_cp->tw = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(l_image->x1 - l_cp->tx0), (OPJ_INT32)l_cp->tdx);\n        l_cp->th = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(l_image->y1 - l_cp->ty0), (OPJ_INT32)l_cp->tdy);\n\n        /* Check that the number of tiles is valid */\n        if (l_cp->tw == 0 || l_cp->th == 0 || l_cp->tw > 65535 / l_cp->th) {\n            opj_event_msg(  p_manager, EVT_ERROR, \n                            \"Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\\n\",\n                            l_cp->tw, l_cp->th);\n            return OPJ_FALSE;\n        }\n        l_nb_tiles = l_cp->tw * l_cp->th;\n\n        /* Define the tiles which will be decoded */\n        if (p_j2k->m_specific_param.m_decoder.m_discard_tiles) {\n                p_j2k->m_specific_param.m_decoder.m_start_tile_x = (p_j2k->m_specific_param.m_decoder.m_start_tile_x - l_cp->tx0) / l_cp->tdx;\n                p_j2k->m_specific_param.m_decoder.m_start_tile_y = (p_j2k->m_specific_param.m_decoder.m_start_tile_y - l_cp->ty0) / l_cp->tdy;\n                p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(p_j2k->m_specific_param.m_decoder.m_end_tile_x - l_cp->tx0), (OPJ_INT32)l_cp->tdx);\n                p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(p_j2k->m_specific_param.m_decoder.m_end_tile_y - l_cp->ty0), (OPJ_INT32)l_cp->tdy);\n        }\n        else {\n                p_j2k->m_specific_param.m_decoder.m_start_tile_x = 0;\n                p_j2k->m_specific_param.m_decoder.m_start_tile_y = 0;\n                p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;\n                p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;\n        }\n\n#ifdef USE_JPWL\n        if (l_cp->correct) {\n                /* if JPWL is on, we check whether TX errors have damaged\n                  too much the SIZ parameters */\n                if ((l_cp->tw < 1) || (l_cp->th < 1) || (l_cp->tw > l_cp->max_tiles) || (l_cp->th > l_cp->max_tiles)) {\n                        opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,\n                                \"JPWL: bad number of tiles (%d x %d)\\n\",\n                                l_cp->tw, l_cp->th);\n                        if (!JPWL_ASSUME) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                return OPJ_FALSE;\n                        }\n                        /* we try to correct */\n                        opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust them\\n\");\n                        if (l_cp->tw < 1) {\n                                l_cp->tw= 1;\n                                opj_event_msg(p_manager, EVT_WARNING, \"- setting %d tiles in x => HYPOTHESIS!!!\\n\",\n                                                l_cp->tw);\n                        }\n                        if (l_cp->tw > l_cp->max_tiles) {\n                                l_cp->tw= 1;\n                                opj_event_msg(p_manager, EVT_WARNING, \"- too large x, increase expectance of %d\\n\"\n                                        \"- setting %d tiles in x => HYPOTHESIS!!!\\n\",\n                                        l_cp->max_tiles, l_cp->tw);\n                        }\n                        if (l_cp->th < 1) {\n                                l_cp->th= 1;\n                                opj_event_msg(p_manager, EVT_WARNING, \"- setting %d tiles in y => HYPOTHESIS!!!\\n\",\n                                                l_cp->th);\n                        }\n                        if (l_cp->th > l_cp->max_tiles) {\n                                l_cp->th= 1;\n                                opj_event_msg(p_manager, EVT_WARNING, \"- too large y, increase expectance of %d to continue\\n\",\n                                        \"- setting %d tiles in y => HYPOTHESIS!!!\\n\",\n                                        l_cp->max_tiles, l_cp->th);\n                        }\n                }\n        }\n#endif /* USE_JPWL */\n\n        /* memory allocations */\n        l_cp->tcps = (opj_tcp_t*) opj_calloc(l_nb_tiles, sizeof(opj_tcp_t));\n        if (l_cp->tcps == 00) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to take in charge SIZ marker\\n\");\n                return OPJ_FALSE;\n        }\n\n#ifdef USE_JPWL\n        if (l_cp->correct) {\n                if (!l_cp->tcps) {\n                        opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,\n                                \"JPWL: could not alloc tcps field of cp\\n\");\n                        if (!JPWL_ASSUME) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                return OPJ_FALSE;\n                        }\n                }\n        }\n#endif /* USE_JPWL */\n\n        p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps =\n                        (opj_tccp_t*) opj_calloc(l_image->numcomps, sizeof(opj_tccp_t));\n        if(p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps  == 00) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to take in charge SIZ marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mct_records =\n                        (opj_mct_data_t*)opj_calloc(OPJ_J2K_MCT_DEFAULT_NB_RECORDS ,sizeof(opj_mct_data_t));\n\n        if (! p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mct_records) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to take in charge SIZ marker\\n\");\n                return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_decoder.m_default_tcp->m_nb_max_mct_records = OPJ_J2K_MCT_DEFAULT_NB_RECORDS;\n\n        p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mcc_records =\n                        (opj_simple_mcc_decorrelation_data_t*)\n                        opj_calloc(OPJ_J2K_MCC_DEFAULT_NB_RECORDS, sizeof(opj_simple_mcc_decorrelation_data_t));\n\n        if (! p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mcc_records) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to take in charge SIZ marker\\n\");\n                return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_decoder.m_default_tcp->m_nb_max_mcc_records = OPJ_J2K_MCC_DEFAULT_NB_RECORDS;\n\n        /* set up default dc level shift */\n        for (i=0;i<l_image->numcomps;++i) {\n                if (! l_image->comps[i].sgnd) {\n                        p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps[i].m_dc_level_shift = 1 << (l_image->comps[i].prec - 1);\n                }\n        }\n\n        l_current_tile_param = l_cp->tcps;\n        for     (i = 0; i < l_nb_tiles; ++i) {\n                l_current_tile_param->tccps = (opj_tccp_t*) opj_calloc(l_image->numcomps, sizeof(opj_tccp_t));\n                if (l_current_tile_param->tccps == 00) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to take in charge SIZ marker\\n\");\n                        return OPJ_FALSE;\n                }\n\n                ++l_current_tile_param;\n        }\n\n        p_j2k->m_specific_param.m_decoder.m_state =  J2K_STATE_MH; /* FIXME J2K_DEC_STATE_MH; */\n        opj_image_comp_header_update(l_image,l_cp);\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_com(     opj_j2k_t *p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager\n                            )\n{\n        OPJ_UINT32 l_comment_size;\n        OPJ_UINT32 l_total_com_size;\n        const OPJ_CHAR *l_comment;\n        OPJ_BYTE * l_current_ptr = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n\n        l_comment = p_j2k->m_cp.comment;\n        l_comment_size = (OPJ_UINT32)strlen(l_comment);\n        l_total_com_size = l_comment_size + 6;\n\n        if (l_total_com_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_total_com_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write the COM marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_total_com_size;\n        }\n\n        l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        opj_write_bytes(l_current_ptr,J2K_MS_COM , 2);  /* COM */\n        l_current_ptr+=2;\n\n        opj_write_bytes(l_current_ptr,l_total_com_size - 2 , 2);        /* L_COM */\n        l_current_ptr+=2;\n\n        opj_write_bytes(l_current_ptr,1 , 2);   /* General use (IS 8859-15:1999 (Latin) values) */\n        l_current_ptr+=2;\n\n        memcpy( l_current_ptr,l_comment,l_comment_size);\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_total_com_size,p_manager) != l_total_com_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a COM marker (comments)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_header_data   the data contained in the COM box.\n * @param       p_header_size   the size of the data contained in the COM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_com (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_header_data != 00);\n  (void)p_header_size;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_cod(     opj_j2k_t *p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager )\n{\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        OPJ_UINT32 l_code_size,l_remaining_size;\n        OPJ_BYTE * l_current_data = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];\n        l_code_size = 9 + opj_j2k_get_SPCod_SPCoc_size(p_j2k,p_j2k->m_current_tile_number,0);\n        l_remaining_size = l_code_size;\n\n        if (l_code_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_code_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write COD marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_code_size;\n        }\n\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        opj_write_bytes(l_current_data,J2K_MS_COD,2);             /* COD */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_code_size-2,2);          /* L_COD */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_tcp->csty,1);            /* Scod */\n        ++l_current_data;\n\n        opj_write_bytes(l_current_data,(OPJ_UINT32)l_tcp->prg,1); /* SGcod (A) */\n        ++l_current_data;\n\n        opj_write_bytes(l_current_data,l_tcp->numlayers,2);       /* SGcod (B) */\n        l_current_data+=2;\n\n        opj_write_bytes(l_current_data,l_tcp->mct,1);             /* SGcod (C) */\n        ++l_current_data;\n\n        l_remaining_size -= 9;\n\n        if (! opj_j2k_write_SPCod_SPCoc(p_j2k,p_j2k->m_current_tile_number,0,l_current_data,&l_remaining_size,p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error writing COD marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (l_remaining_size != 0) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error writing COD marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_code_size,p_manager) != l_code_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a COD marker (Coding Styke defaults)\n * @param       p_header_data   the data contained in the COD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the COD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_cod (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        /* loop */\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_tmp;\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_image_t *l_image = 00;\n\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_image = p_j2k->m_private_image;\n        l_cp = &(p_j2k->m_cp);\n\n        /* If we are in the first tile-part header of the current tile */\n        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?\n                                &l_cp->tcps[p_j2k->m_current_tile_number] :\n                                p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\t\n        /* Only one COD per tile */\n        if (l_tcp->cod) {\n                opj_event_msg(p_manager, EVT_ERROR, \"COD marker already read. No more than one COD marker per tile.\\n\");\n                return OPJ_FALSE;\n        }\n        l_tcp->cod = 1;\n\t\n        /* Make sure room is sufficient */\n        if (p_header_size < 5) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading COD marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(p_header_data,&l_tcp->csty,1);           /* Scod */\n        ++p_header_data;\n        /* Make sure we know how to decode this */\n        if ((l_tcp->csty & ~(OPJ_UINT32)(J2K_CP_CSTY_PRT | J2K_CP_CSTY_SOP | J2K_CP_CSTY_EPH)) != 0U) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Unknown Scod value in COD marker\\n\");\n                return OPJ_FALSE;\n        }\n        opj_read_bytes(p_header_data,&l_tmp,1);                         /* SGcod (A) */\n        ++p_header_data;\n        l_tcp->prg = (OPJ_PROG_ORDER) l_tmp;\n        /* Make sure progression order is valid */\n        if (l_tcp->prg > OPJ_CPRL ) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Unknown progression order in COD marker\\n\");\n                l_tcp->prg = OPJ_PROG_UNKNOWN;\n        }\n        opj_read_bytes(p_header_data,&l_tcp->numlayers,2);      /* SGcod (B) */\n        p_header_data+=2;\n\t\n        if ((l_tcp->numlayers < 1U) || (l_tcp->numlayers > 65535U)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Invalid number of layers in COD marker : %d not in range [1-65535]\\n\", l_tcp->numlayers);\n                return OPJ_FALSE;\n        }\n\n        /* If user didn't set a number layer to decode take the max specify in the codestream. */\n        if      (l_cp->m_specific_param.m_dec.m_layer) {\n                l_tcp->num_layers_to_decode = l_cp->m_specific_param.m_dec.m_layer;\n        }\n        else {\n                l_tcp->num_layers_to_decode = l_tcp->numlayers;\n        }\n\n        opj_read_bytes(p_header_data,&l_tcp->mct,1);            /* SGcod (C) */\n        ++p_header_data;\n\n        p_header_size -= 5;\n        for     (i = 0; i < l_image->numcomps; ++i) {\n                l_tcp->tccps[i].csty = l_tcp->csty & J2K_CCP_CSTY_PRT;\n        }\n\n        if (! opj_j2k_read_SPCod_SPCoc(p_j2k,0,p_header_data,&p_header_size,p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading COD marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (p_header_size != 0) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading COD marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        /* Apply the coding style to other components of the current tile or the m_default_tcp*/\n        opj_j2k_copy_tile_component_parameters(p_j2k);\n\n        /* Index */\n#ifdef WIP_REMOVE_MSD\n        if (p_j2k->cstr_info) {\n                /*opj_codestream_info_t *l_cstr_info = p_j2k->cstr_info;*/\n                p_j2k->cstr_info->prog = l_tcp->prg;\n                p_j2k->cstr_info->numlayers = l_tcp->numlayers;\n                p_j2k->cstr_info->numdecompos = (OPJ_INT32*) opj_malloc(l_image->numcomps * sizeof(OPJ_UINT32));\n\t\t\t\tif(!p_j2k->cstr_info->numdecompos){\n\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t}\n                for     (i = 0; i < l_image->numcomps; ++i) {\n                        p_j2k->cstr_info->numdecompos[i] = l_tcp->tccps[i].numresolutions - 1;\n                }\n        }\n#endif\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_coc( opj_j2k_t *p_j2k,\n                                                OPJ_UINT32 p_comp_no,\n                                                opj_stream_private_t *p_stream,\n                                                opj_event_mgr_t * p_manager )\n{\n        OPJ_UINT32 l_coc_size,l_remaining_size;\n        OPJ_UINT32 l_comp_room;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_comp_room = (p_j2k->m_private_image->numcomps <= 256) ? 1 : 2;\n\n        l_coc_size = 5 + l_comp_room + opj_j2k_get_SPCod_SPCoc_size(p_j2k,p_j2k->m_current_tile_number,p_comp_no);\n\n        if (l_coc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n                OPJ_BYTE *new_header_tile_data;\n                /*p_j2k->m_specific_param.m_encoder.m_header_tile_data\n                        = (OPJ_BYTE*)opj_realloc(\n                                p_j2k->m_specific_param.m_encoder.m_header_tile_data,\n                                l_coc_size);*/\n\n                new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_coc_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write COC marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_coc_size;\n        }\n\n        opj_j2k_write_coc_in_memory(p_j2k,p_comp_no,p_j2k->m_specific_param.m_encoder.m_header_tile_data,&l_remaining_size,p_manager);\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_coc_size,p_manager) != l_coc_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_compare_coc(opj_j2k_t *p_j2k, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no)\n{\n\topj_cp_t *l_cp = NULL;\n\topj_tcp_t *l_tcp = NULL;\n\t\n\t/* preconditions */\n\tassert(p_j2k != 00);\n\t\n\tl_cp = &(p_j2k->m_cp);\n\tl_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];\n\t\n\tif (l_tcp->tccps[p_first_comp_no].csty != l_tcp->tccps[p_second_comp_no].csty) {\n\t\treturn OPJ_FALSE;\n\t}\n\t\n\t\n\treturn opj_j2k_compare_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number, p_first_comp_no, p_second_comp_no);\n}\n\nstatic void opj_j2k_write_coc_in_memory(   opj_j2k_t *p_j2k,\n                                                OPJ_UINT32 p_comp_no,\n                                                OPJ_BYTE * p_data,\n                                                OPJ_UINT32 * p_data_written,\n                                                opj_event_mgr_t * p_manager\n                                    )\n{\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        OPJ_UINT32 l_coc_size,l_remaining_size;\n        OPJ_BYTE * l_current_data = 00;\n        opj_image_t *l_image = 00;\n        OPJ_UINT32 l_comp_room;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];\n        l_image = p_j2k->m_private_image;\n        l_comp_room = (l_image->numcomps <= 256) ? 1 : 2;\n\n        l_coc_size = 5 + l_comp_room + opj_j2k_get_SPCod_SPCoc_size(p_j2k,p_j2k->m_current_tile_number,p_comp_no);\n        l_remaining_size = l_coc_size;\n\n        l_current_data = p_data;\n\n        opj_write_bytes(l_current_data,J2K_MS_COC,2);                           /* COC */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_coc_size-2,2);                         /* L_COC */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,p_comp_no, l_comp_room);         /* Ccoc */\n        l_current_data+=l_comp_room;\n\n        opj_write_bytes(l_current_data, l_tcp->tccps[p_comp_no].csty, 1);               /* Scoc */\n        ++l_current_data;\n\n        l_remaining_size -= (5 + l_comp_room);\n        opj_j2k_write_SPCod_SPCoc(p_j2k,p_j2k->m_current_tile_number,0,l_current_data,&l_remaining_size,p_manager);\n        * p_data_written = l_coc_size;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k)\n{\n        OPJ_UINT32 i,j;\n        OPJ_UINT32 l_nb_comp;\n        OPJ_UINT32 l_nb_tiles;\n        OPJ_UINT32 l_max = 0;\n\n        /* preconditions */\n\n        l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th ;\n        l_nb_comp = p_j2k->m_private_image->numcomps;\n\n        for (i=0;i<l_nb_tiles;++i) {\n                for (j=0;j<l_nb_comp;++j) {\n                        l_max = opj_uint_max(l_max,opj_j2k_get_SPCod_SPCoc_size(p_j2k,i,j));\n                }\n        }\n\n        return 6 + l_max;\n}\n\n/**\n * Reads a COC marker (Coding Style Component)\n * @param       p_header_data   the data contained in the COC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the COC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_coc (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        opj_cp_t *l_cp = NULL;\n        opj_tcp_t *l_tcp = NULL;\n        opj_image_t *l_image = NULL;\n        OPJ_UINT32 l_comp_room;\n        OPJ_UINT32 l_comp_no;\n\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ) ? /*FIXME J2K_DEC_STATE_TPH*/\n                                &l_cp->tcps[p_j2k->m_current_tile_number] :\n                                p_j2k->m_specific_param.m_decoder.m_default_tcp;\n        l_image = p_j2k->m_private_image;\n\n        l_comp_room = l_image->numcomps <= 256 ? 1 : 2;\n\n        /* make sure room is sufficient*/\n        if (p_header_size < l_comp_room + 1) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading COC marker\\n\");\n                return OPJ_FALSE;\n        }\n        p_header_size -= l_comp_room + 1;\n\n        opj_read_bytes(p_header_data,&l_comp_no,l_comp_room);                   /* Ccoc */\n        p_header_data += l_comp_room;\n        if (l_comp_no >= l_image->numcomps) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading COC marker (bad number of components)\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(p_header_data,&l_tcp->tccps[l_comp_no].csty,1);                  /* Scoc */\n        ++p_header_data ;\n\n        if (! opj_j2k_read_SPCod_SPCoc(p_j2k,l_comp_no,p_header_data,&p_header_size,p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading COC marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (p_header_size != 0) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading COC marker\\n\");\n                return OPJ_FALSE;\n        }\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_qcd(     opj_j2k_t *p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager\n                            )\n{\n        OPJ_UINT32 l_qcd_size,l_remaining_size;\n        OPJ_BYTE * l_current_data = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_qcd_size = 4 + opj_j2k_get_SQcd_SQcc_size(p_j2k,p_j2k->m_current_tile_number,0);\n        l_remaining_size = l_qcd_size;\n\n        if (l_qcd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_qcd_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write QCD marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_qcd_size;\n        }\n\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        opj_write_bytes(l_current_data,J2K_MS_QCD,2);           /* QCD */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_qcd_size-2,2);         /* L_QCD */\n        l_current_data += 2;\n\n        l_remaining_size -= 4;\n\n        if (! opj_j2k_write_SQcd_SQcc(p_j2k,p_j2k->m_current_tile_number,0,l_current_data,&l_remaining_size,p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error writing QCD marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (l_remaining_size != 0) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error writing QCD marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_qcd_size,p_manager) != l_qcd_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a QCD marker (Quantization defaults)\n * @param       p_header_data   the data contained in the QCD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the QCD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_qcd (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        if (! opj_j2k_read_SQcd_SQcc(p_j2k,0,p_header_data,&p_header_size,p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCD marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (p_header_size != 0) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCD marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        /* Apply the quantization parameters to other components of the current tile or the m_default_tcp */\n        opj_j2k_copy_tile_quantization_parameters(p_j2k);\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_qcc(     opj_j2k_t *p_j2k,\n                                                OPJ_UINT32 p_comp_no,\n                                                opj_stream_private_t *p_stream,\n                                                opj_event_mgr_t * p_manager\n                            )\n{\n        OPJ_UINT32 l_qcc_size,l_remaining_size;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_qcc_size = 5 + opj_j2k_get_SQcd_SQcc_size(p_j2k,p_j2k->m_current_tile_number,p_comp_no);\n        l_qcc_size += p_j2k->m_private_image->numcomps <= 256 ? 0:1;\n        l_remaining_size = l_qcc_size;\n\n        if (l_qcc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_qcc_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write QCC marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_qcc_size;\n        }\n\n        opj_j2k_write_qcc_in_memory(p_j2k,p_comp_no,p_j2k->m_specific_param.m_encoder.m_header_tile_data,&l_remaining_size,p_manager);\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_qcc_size,p_manager) != l_qcc_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_compare_qcc(opj_j2k_t *p_j2k, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no)\n{\n\treturn opj_j2k_compare_SQcd_SQcc(p_j2k,p_j2k->m_current_tile_number,p_first_comp_no, p_second_comp_no);\n}\n\nstatic void opj_j2k_write_qcc_in_memory(   opj_j2k_t *p_j2k,\n                                                                OPJ_UINT32 p_comp_no,\n                                                                OPJ_BYTE * p_data,\n                                                                OPJ_UINT32 * p_data_written,\n                                                                opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_UINT32 l_qcc_size,l_remaining_size;\n        OPJ_BYTE * l_current_data = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_qcc_size = 6 + opj_j2k_get_SQcd_SQcc_size(p_j2k,p_j2k->m_current_tile_number,p_comp_no);\n        l_remaining_size = l_qcc_size;\n\n        l_current_data = p_data;\n\n        opj_write_bytes(l_current_data,J2K_MS_QCC,2);           /* QCC */\n        l_current_data += 2;\n\n        if (p_j2k->m_private_image->numcomps <= 256) {\n                --l_qcc_size;\n\n                opj_write_bytes(l_current_data,l_qcc_size-2,2);         /* L_QCC */\n                l_current_data += 2;\n\n                opj_write_bytes(l_current_data, p_comp_no, 1);  /* Cqcc */\n                ++l_current_data;\n\n                /* in the case only one byte is sufficient the last byte allocated is useless -> still do -6 for available */\n                l_remaining_size -= 6;\n        }\n        else {\n                opj_write_bytes(l_current_data,l_qcc_size-2,2);         /* L_QCC */\n                l_current_data += 2;\n\n                opj_write_bytes(l_current_data, p_comp_no, 2);  /* Cqcc */\n                l_current_data+=2;\n\n                l_remaining_size -= 6;\n        }\n\n        opj_j2k_write_SQcd_SQcc(p_j2k,p_j2k->m_current_tile_number,p_comp_no,l_current_data,&l_remaining_size,p_manager);\n\n        *p_data_written = l_qcc_size;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_max_qcc_size (opj_j2k_t *p_j2k)\n{\n        return opj_j2k_get_max_coc_size(p_j2k);\n}\n\n/**\n * Reads a QCC marker (Quantization component)\n * @param       p_header_data   the data contained in the QCC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the QCC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_qcc(   opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_UINT32 l_num_comp,l_comp_no;\n\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_num_comp = p_j2k->m_private_image->numcomps;\n\n        if (l_num_comp <= 256) {\n                if (p_header_size < 1) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCC marker\\n\");\n                        return OPJ_FALSE;\n                }\n                opj_read_bytes(p_header_data,&l_comp_no,1);\n                ++p_header_data;\n                --p_header_size;\n        }\n        else {\n                if (p_header_size < 2) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCC marker\\n\");\n                        return OPJ_FALSE;\n                }\n                opj_read_bytes(p_header_data,&l_comp_no,2);\n                p_header_data+=2;\n                p_header_size-=2;\n        }\n\n#ifdef USE_JPWL\n        if (p_j2k->m_cp.correct) {\n\n                static OPJ_UINT32 backup_compno = 0;\n\n                /* compno is negative or larger than the number of components!!! */\n                if (/*(l_comp_no < 0) ||*/ (l_comp_no >= l_num_comp)) {\n                        opj_event_msg(p_manager, EVT_ERROR,\n                                \"JPWL: bad component number in QCC (%d out of a maximum of %d)\\n\",\n                                l_comp_no, l_num_comp);\n                        if (!JPWL_ASSUME) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                return OPJ_FALSE;\n                        }\n                        /* we try to correct */\n                        l_comp_no = backup_compno % l_num_comp;\n                        opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust this\\n\"\n                                \"- setting component number to %d\\n\",\n                                l_comp_no);\n                }\n\n                /* keep your private count of tiles */\n                backup_compno++;\n        };\n#endif /* USE_JPWL */\n\n        if (l_comp_no >= p_j2k->m_private_image->numcomps) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Invalid component number: %d, regarding the number of components %d\\n\",\n                              l_comp_no, p_j2k->m_private_image->numcomps);\n                return OPJ_FALSE;\n        }\n\n        if (! opj_j2k_read_SQcd_SQcc(p_j2k,l_comp_no,p_header_data,&p_header_size,p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCC marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (p_header_size != 0) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCC marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_poc(     opj_j2k_t *p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager\n                            )\n{\n        OPJ_UINT32 l_nb_comp;\n        OPJ_UINT32 l_nb_poc;\n        OPJ_UINT32 l_poc_size;\n        OPJ_UINT32 l_written_size = 0;\n        opj_tcp_t *l_tcp = 00;\n        OPJ_UINT32 l_poc_room;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_tcp = &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number];\n        l_nb_comp = p_j2k->m_private_image->numcomps;\n        l_nb_poc = 1 + l_tcp->numpocs;\n\n        if (l_nb_comp <= 256) {\n                l_poc_room = 1;\n        }\n        else {\n                l_poc_room = 2;\n        }\n        l_poc_size = 4 + (5 + 2 * l_poc_room) * l_nb_poc;\n\n        if (l_poc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_poc_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write POC marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_poc_size;\n        }\n\n        opj_j2k_write_poc_in_memory(p_j2k,p_j2k->m_specific_param.m_encoder.m_header_tile_data,&l_written_size,p_manager);\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_poc_size,p_manager) != l_poc_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic void opj_j2k_write_poc_in_memory(   opj_j2k_t *p_j2k,\n                                                                OPJ_BYTE * p_data,\n                                                                OPJ_UINT32 * p_data_written,\n                                                                opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_UINT32 i;\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_nb_comp;\n        OPJ_UINT32 l_nb_poc;\n        OPJ_UINT32 l_poc_size;\n        opj_image_t *l_image = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_tccp_t *l_tccp = 00;\n        opj_poc_t *l_current_poc = 00;\n        OPJ_UINT32 l_poc_room;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_tcp = &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number];\n        l_tccp = &l_tcp->tccps[0];\n        l_image = p_j2k->m_private_image;\n        l_nb_comp = l_image->numcomps;\n        l_nb_poc = 1 + l_tcp->numpocs;\n\n        if (l_nb_comp <= 256) {\n                l_poc_room = 1;\n        }\n        else {\n                l_poc_room = 2;\n        }\n\n        l_poc_size = 4 + (5 + 2 * l_poc_room) * l_nb_poc;\n\n        l_current_data = p_data;\n\n        opj_write_bytes(l_current_data,J2K_MS_POC,2);                                   /* POC  */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_poc_size-2,2);                                 /* Lpoc */\n        l_current_data += 2;\n\n        l_current_poc =  l_tcp->pocs;\n        for (i = 0; i < l_nb_poc; ++i) {\n                opj_write_bytes(l_current_data,l_current_poc->resno0,1);                                /* RSpoc_i */\n                ++l_current_data;\n\n                opj_write_bytes(l_current_data,l_current_poc->compno0,l_poc_room);              /* CSpoc_i */\n                l_current_data+=l_poc_room;\n\n                opj_write_bytes(l_current_data,l_current_poc->layno1,2);                                /* LYEpoc_i */\n                l_current_data+=2;\n\n                opj_write_bytes(l_current_data,l_current_poc->resno1,1);                                /* REpoc_i */\n                ++l_current_data;\n\n                opj_write_bytes(l_current_data,l_current_poc->compno1,l_poc_room);              /* CEpoc_i */\n                l_current_data+=l_poc_room;\n\n                opj_write_bytes(l_current_data, (OPJ_UINT32)l_current_poc->prg,1);    /* Ppoc_i */\n                ++l_current_data;\n\n                /* change the value of the max layer according to the actual number of layers in the file, components and resolutions*/\n                l_current_poc->layno1 = (OPJ_UINT32)opj_int_min((OPJ_INT32)l_current_poc->layno1, (OPJ_INT32)l_tcp->numlayers);\n                l_current_poc->resno1 = (OPJ_UINT32)opj_int_min((OPJ_INT32)l_current_poc->resno1, (OPJ_INT32)l_tccp->numresolutions);\n                l_current_poc->compno1 = (OPJ_UINT32)opj_int_min((OPJ_INT32)l_current_poc->compno1, (OPJ_INT32)l_nb_comp);\n\n                ++l_current_poc;\n        }\n\n        *p_data_written = l_poc_size;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k)\n{\n        opj_tcp_t * l_tcp = 00;\n        OPJ_UINT32 l_nb_tiles = 0;\n        OPJ_UINT32 l_max_poc = 0;\n        OPJ_UINT32 i;\n\n        l_tcp = p_j2k->m_cp.tcps;\n        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n\n        for (i=0;i<l_nb_tiles;++i) {\n                l_max_poc = opj_uint_max(l_max_poc,l_tcp->numpocs);\n                ++l_tcp;\n        }\n\n        ++l_max_poc;\n\n        return 4 + 9 * l_max_poc;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_max_toc_size (opj_j2k_t *p_j2k)\n{\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_nb_tiles;\n        OPJ_UINT32 l_max = 0;\n        opj_tcp_t * l_tcp = 00;\n\n        l_tcp = p_j2k->m_cp.tcps;\n        l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th ;\n\n        for (i=0;i<l_nb_tiles;++i) {\n                l_max = opj_uint_max(l_max,l_tcp->m_nb_tile_parts);\n\n                ++l_tcp;\n        }\n\n        return 12 * l_max;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k)\n{\n        OPJ_UINT32 l_nb_bytes = 0;\n        OPJ_UINT32 l_nb_comps;\n        OPJ_UINT32 l_coc_bytes,l_qcc_bytes;\n\n        l_nb_comps = p_j2k->m_private_image->numcomps - 1;\n        l_nb_bytes += opj_j2k_get_max_toc_size(p_j2k);\n\n        if (!(OPJ_IS_CINEMA(p_j2k->m_cp.rsiz))) {\n                l_coc_bytes = opj_j2k_get_max_coc_size(p_j2k);\n                l_nb_bytes += l_nb_comps * l_coc_bytes;\n\n                l_qcc_bytes = opj_j2k_get_max_qcc_size(p_j2k);\n                l_nb_bytes += l_nb_comps * l_qcc_bytes;\n        }\n\n        l_nb_bytes += opj_j2k_get_max_poc_size(p_j2k);\n\n        /*** DEVELOPER CORNER, Add room for your headers ***/\n\n        return l_nb_bytes;\n}\n\n/**\n * Reads a POC marker (Progression Order Change)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_poc (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_UINT32 i, l_nb_comp, l_tmp;\n        opj_image_t * l_image = 00;\n        OPJ_UINT32 l_old_poc_nb, l_current_poc_nb, l_current_poc_remaining;\n        OPJ_UINT32 l_chunk_size, l_comp_room;\n\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_poc_t *l_current_poc = 00;\n\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_image = p_j2k->m_private_image;\n        l_nb_comp = l_image->numcomps;\n        if (l_nb_comp <= 256) {\n                l_comp_room = 1;\n        }\n        else {\n                l_comp_room = 2;\n        }\n        l_chunk_size = 5 + 2 * l_comp_room;\n        l_current_poc_nb = p_header_size / l_chunk_size;\n        l_current_poc_remaining = p_header_size % l_chunk_size;\n\n        if ((l_current_poc_nb <= 0) || (l_current_poc_remaining != 0)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading POC marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?\n                                &l_cp->tcps[p_j2k->m_current_tile_number] :\n                                p_j2k->m_specific_param.m_decoder.m_default_tcp;\n        l_old_poc_nb = l_tcp->POC ? l_tcp->numpocs + 1 : 0;\n        l_current_poc_nb += l_old_poc_nb;\n\n        if(l_current_poc_nb >= 32)\n          {\n          opj_event_msg(p_manager, EVT_ERROR, \"Too many POCs %d\\n\", l_current_poc_nb);\n          return OPJ_FALSE;\n          }\n        assert(l_current_poc_nb < 32);\n\n        /* now poc is in use.*/\n        l_tcp->POC = 1;\n\n        l_current_poc = &l_tcp->pocs[l_old_poc_nb];\n        for     (i = l_old_poc_nb; i < l_current_poc_nb; ++i) {\n                opj_read_bytes(p_header_data,&(l_current_poc->resno0),1);                               /* RSpoc_i */\n                ++p_header_data;\n                opj_read_bytes(p_header_data,&(l_current_poc->compno0),l_comp_room);    /* CSpoc_i */\n                p_header_data+=l_comp_room;\n                opj_read_bytes(p_header_data,&(l_current_poc->layno1),2);                               /* LYEpoc_i */\n                /* make sure layer end is in acceptable bounds */\n                l_current_poc->layno1 = opj_uint_min(l_current_poc->layno1, l_tcp->numlayers);\n                p_header_data+=2;\n                opj_read_bytes(p_header_data,&(l_current_poc->resno1),1);                               /* REpoc_i */\n                ++p_header_data;\n                opj_read_bytes(p_header_data,&(l_current_poc->compno1),l_comp_room);    /* CEpoc_i */\n                p_header_data+=l_comp_room;\n                opj_read_bytes(p_header_data,&l_tmp,1);                                                                 /* Ppoc_i */\n                ++p_header_data;\n                l_current_poc->prg = (OPJ_PROG_ORDER) l_tmp;\n                /* make sure comp is in acceptable bounds */\n                l_current_poc->compno1 = opj_uint_min(l_current_poc->compno1, l_nb_comp);\n                ++l_current_poc;\n        }\n\n        l_tcp->numpocs = l_current_poc_nb - 1;\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a CRG marker (Component registration)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_crg (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_UINT32 l_nb_comp;\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_nb_comp = p_j2k->m_private_image->numcomps;\n\n        if (p_header_size != l_nb_comp *4) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading CRG marker\\n\");\n                return OPJ_FALSE;\n        }\n        /* Do not care of this at the moment since only local variables are set here */\n        /*\n        for\n                (i = 0; i < l_nb_comp; ++i)\n        {\n                opj_read_bytes(p_header_data,&l_Xcrg_i,2);                              // Xcrg_i\n                p_header_data+=2;\n                opj_read_bytes(p_header_data,&l_Ycrg_i,2);                              // Xcrg_i\n                p_header_data+=2;\n        }\n        */\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a TLM marker (Tile Length Marker)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_tlm (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_UINT32 l_Ztlm, l_Stlm, l_ST, l_SP, l_tot_num_tp_remaining, l_quotient, l_Ptlm_size;\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        if (p_header_size < 2) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading TLM marker\\n\");\n                return OPJ_FALSE;\n        }\n        p_header_size -= 2;\n\n        opj_read_bytes(p_header_data,&l_Ztlm,1);                                /* Ztlm */\n        ++p_header_data;\n        opj_read_bytes(p_header_data,&l_Stlm,1);                                /* Stlm */\n        ++p_header_data;\n\n        l_ST = ((l_Stlm >> 4) & 0x3);\n        l_SP = (l_Stlm >> 6) & 0x1;\n\n        l_Ptlm_size = (l_SP + 1) * 2;\n        l_quotient = l_Ptlm_size + l_ST;\n\n        l_tot_num_tp_remaining = p_header_size % l_quotient;\n\n        if (l_tot_num_tp_remaining != 0) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading TLM marker\\n\");\n                return OPJ_FALSE;\n        }\n        /* FIXME Do not care of this at the moment since only local variables are set here */\n        /*\n        for\n                (i = 0; i < l_tot_num_tp; ++i)\n        {\n                opj_read_bytes(p_header_data,&l_Ttlm_i,l_ST);                           // Ttlm_i\n                p_header_data += l_ST;\n                opj_read_bytes(p_header_data,&l_Ptlm_i,l_Ptlm_size);            // Ptlm_i\n                p_header_data += l_Ptlm_size;\n        }*/\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a PLM marker (Packet length, main header marker)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_plm (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        if (p_header_size < 1) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading PLM marker\\n\");\n                return OPJ_FALSE;\n        }\n        /* Do not care of this at the moment since only local variables are set here */\n        /*\n        opj_read_bytes(p_header_data,&l_Zplm,1);                                        // Zplm\n        ++p_header_data;\n        --p_header_size;\n\n        while\n                (p_header_size > 0)\n        {\n                opj_read_bytes(p_header_data,&l_Nplm,1);                                // Nplm\n                ++p_header_data;\n                p_header_size -= (1+l_Nplm);\n                if\n                        (p_header_size < 0)\n                {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error reading PLM marker\\n\");\n                        return false;\n                }\n                for\n                        (i = 0; i < l_Nplm; ++i)\n                {\n                        opj_read_bytes(p_header_data,&l_tmp,1);                         // Iplm_ij\n                        ++p_header_data;\n                        // take only the last seven bytes\n                        l_packet_len |= (l_tmp & 0x7f);\n                        if\n                                (l_tmp & 0x80)\n                        {\n                                l_packet_len <<= 7;\n                        }\n                        else\n                        {\n                // store packet length and proceed to next packet\n                                l_packet_len = 0;\n                        }\n                }\n                if\n                        (l_packet_len != 0)\n                {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error reading PLM marker\\n\");\n                        return false;\n                }\n        }\n        */\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a PLT marker (Packet length, tile-part header)\n *\n * @param       p_header_data   the data contained in the PLT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the PLT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_plt (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_UINT32 l_Zplt, l_tmp, l_packet_len = 0, i;\n\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        if (p_header_size < 1) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading PLT marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(p_header_data,&l_Zplt,1);                /* Zplt */\n        ++p_header_data;\n        --p_header_size;\n\n        for (i = 0; i < p_header_size; ++i) {\n                opj_read_bytes(p_header_data,&l_tmp,1);         /* Iplt_ij */\n                ++p_header_data;\n                /* take only the last seven bytes */\n                l_packet_len |= (l_tmp & 0x7f);\n                if (l_tmp & 0x80) {\n                        l_packet_len <<= 7;\n                }\n                else {\n            /* store packet length and proceed to next packet */\n                        l_packet_len = 0;\n                }\n        }\n\n        if (l_packet_len != 0) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading PLT marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a PPM marker (Packed packet headers, main header)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n */\n\nstatic OPJ_BOOL opj_j2k_read_ppm (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\topj_j2k_t *p_j2k,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tOPJ_BYTE * p_header_data,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tOPJ_UINT32 p_header_size,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\topj_event_mgr_t * p_manager )\n{\n\topj_cp_t *l_cp = 00;\n\tOPJ_UINT32 l_Z_ppm;\n\t\n\t/* preconditions */\n\tassert(p_header_data != 00);\n\tassert(p_j2k != 00);\n\tassert(p_manager != 00);\n\t\n\t/* We need to have the Z_ppm element + 1 byte of Nppm/Ippm at minimum */\n\tif (p_header_size < 2) {\n\t\topj_event_msg(p_manager, EVT_ERROR, \"Error reading PPM marker\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\t\n\tl_cp = &(p_j2k->m_cp);\n\tl_cp->ppm = 1;\n\t\n\topj_read_bytes(p_header_data,&l_Z_ppm,1);               /* Z_ppm */\n\t++p_header_data;\n\t--p_header_size;\n\t\n\t/* check allocation needed */\n\tif (l_cp->ppm_markers == NULL) { /* first PPM marker */\n\t\tOPJ_UINT32 l_newCount = l_Z_ppm + 1U; /* can't overflow, l_Z_ppm is UINT8 */\n\t\tassert(l_cp->ppm_markers_count == 0U);\n\t\t\n\t\tl_cp->ppm_markers = (opj_ppx *) opj_calloc(l_newCount, sizeof(opj_ppx));\n\t\tif (l_cp->ppm_markers == NULL) {\n\t\t\topj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPM marker\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_cp->ppm_markers_count = l_newCount;\n\t} else if (l_cp->ppm_markers_count <= l_Z_ppm) {\n\t\tOPJ_UINT32 l_newCount = l_Z_ppm + 1U; /* can't overflow, l_Z_ppm is UINT8 */\n\t\topj_ppx *new_ppm_markers;\n\t\tnew_ppm_markers = (opj_ppx *) opj_realloc(l_cp->ppm_markers, l_newCount * sizeof(opj_ppx));\n\t\tif (new_ppm_markers == NULL) {\n\t\t\t/* clean up to be done on l_cp destruction */\n\t\t\topj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPM marker\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_cp->ppm_markers = new_ppm_markers;\n\t\tmemset(l_cp->ppm_markers + l_cp->ppm_markers_count, 0, (l_newCount - l_cp->ppm_markers_count) * sizeof(opj_ppx));\n\t\tl_cp->ppm_markers_count = l_newCount;\n\t}\n\t\n\tif (l_cp->ppm_markers[l_Z_ppm].m_data != NULL) {\n\t\t/* clean up to be done on l_cp destruction */\n\t\topj_event_msg(p_manager, EVT_ERROR, \"Zppm %u already read\\n\", l_Z_ppm);\n\t\treturn OPJ_FALSE;\n\t}\n\t\n\tl_cp->ppm_markers[l_Z_ppm].m_data = (OPJ_BYTE *) opj_malloc(p_header_size);\n\tif (l_cp->ppm_markers[l_Z_ppm].m_data == NULL) {\n\t\t/* clean up to be done on l_cp destruction */\n\t\topj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPM marker\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\tl_cp->ppm_markers[l_Z_ppm].m_data_size = p_header_size;\n\tmemcpy(l_cp->ppm_markers[l_Z_ppm].m_data, p_header_data, p_header_size);\n\n\treturn OPJ_TRUE;\n}\n\n/**\n * Merges all PPM markers read (Packed headers, main header)\n *\n * @param       p_cp      main coding parameters.\n * @param       p_manager the user event manager.\n */\nstatic OPJ_BOOL opj_j2k_merge_ppm ( opj_cp_t *p_cp, opj_event_mgr_t * p_manager )\n{\n\tOPJ_UINT32 i, l_ppm_data_size, l_N_ppm_remaining;\n\t\n\t/* preconditions */\n\tassert(p_cp != 00);\n\tassert(p_manager != 00);\n\tassert(p_cp->ppm_buffer == NULL);\n\t\n\tif (p_cp->ppm == 0U) {\n\t\treturn OPJ_TRUE;\n\t}\n\t\n\tl_ppm_data_size = 0U;\n\tl_N_ppm_remaining = 0U;\n\tfor (i = 0U; i < p_cp->ppm_markers_count; ++i) {\n\t\tif (p_cp->ppm_markers[i].m_data != NULL) { /* standard doesn't seem to require contiguous Zppm */\n\t\t\tOPJ_UINT32 l_N_ppm;\n\t\t\tOPJ_UINT32 l_data_size = p_cp->ppm_markers[i].m_data_size;\n\t\t\tconst OPJ_BYTE* l_data = p_cp->ppm_markers[i].m_data;\n\t\t\t\n\t\t\tif (l_N_ppm_remaining >= l_data_size) {\n\t\t\t\tl_N_ppm_remaining -= l_data_size;\n\t\t\t\tl_data_size = 0U;\n\t\t\t} else {\n\t\t\t\tl_data += l_N_ppm_remaining;\n\t\t\t\tl_data_size -= l_N_ppm_remaining;\n\t\t\t\tl_N_ppm_remaining = 0U;\n\t\t\t}\n\t\t\t\n\t\t\tif (l_data_size > 0U) {\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\t/* read Nppm */\n\t\t\t\t\tif (l_data_size < 4U) {\n\t\t\t\t\t\t/* clean up to be done on l_cp destruction */\n\t\t\t\t\t\topj_event_msg(p_manager, EVT_ERROR, \"Not enough bytes to read Nppm\\n\");\n\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\topj_read_bytes(l_data, &l_N_ppm, 4);\n\t\t\t\t\tl_data+=4;\n\t\t\t\t\tl_data_size-=4;\n\t\t\t\t\tl_ppm_data_size += l_N_ppm; /* can't overflow, max 256 markers of max 65536 bytes, that is when PPM markers are not corrupted which is checked elsewhere */\n\t\t\t\t\t\n\t\t\t\t\tif (l_data_size >= l_N_ppm) {\n\t\t\t\t\t\tl_data_size -= l_N_ppm;\n\t\t\t\t\t\tl_data += l_N_ppm;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tl_N_ppm_remaining = l_N_ppm - l_data_size;\n\t\t\t\t\t\tl_data_size = 0U;\n\t\t\t\t\t}\n\t\t\t\t} while (l_data_size > 0U);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (l_N_ppm_remaining != 0U) {\n\t\t/* clean up to be done on l_cp destruction */\n\t\topj_event_msg(p_manager, EVT_ERROR, \"Corrupted PPM markers\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\t\n\tp_cp->ppm_buffer = (OPJ_BYTE *) opj_malloc(l_ppm_data_size);\n\tif (p_cp->ppm_buffer == 00) {\n\t\topj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPM marker\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\tp_cp->ppm_len = l_ppm_data_size;\n\tl_ppm_data_size = 0U;\n\tl_N_ppm_remaining = 0U;\n\tfor (i = 0U; i < p_cp->ppm_markers_count; ++i) {\n\t\tif (p_cp->ppm_markers[i].m_data != NULL) { /* standard doesn't seem to require contiguous Zppm */\n\t\t\tOPJ_UINT32 l_N_ppm;\n\t\t\tOPJ_UINT32 l_data_size = p_cp->ppm_markers[i].m_data_size;\n\t\t\tconst OPJ_BYTE* l_data = p_cp->ppm_markers[i].m_data;\n\t\t\t\n\t\t\tif (l_N_ppm_remaining >= l_data_size) {\n\t\t\t\tmemcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data, l_data_size);\n\t\t\t\tl_ppm_data_size += l_data_size;\n\t\t\t\tl_N_ppm_remaining -= l_data_size;\n\t\t\t\tl_data_size = 0U;\n\t\t\t} else {\n\t\t\t\tmemcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data, l_N_ppm_remaining);\n\t\t\t\tl_ppm_data_size += l_N_ppm_remaining;\n\t\t\t\tl_data += l_N_ppm_remaining;\n\t\t\t\tl_data_size -= l_N_ppm_remaining;\n\t\t\t\tl_N_ppm_remaining = 0U;\n\t\t\t}\n\n\t\t\tif (l_data_size > 0U) {\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\t/* read Nppm */\n\t\t\t\t\tif (l_data_size < 4U) {\n\t\t\t\t\t\t/* clean up to be done on l_cp destruction */\n\t\t\t\t\t\topj_event_msg(p_manager, EVT_ERROR, \"Not enough bytes to read Nppm\\n\");\n\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\topj_read_bytes(l_data, &l_N_ppm, 4);\n\t\t\t\t\tl_data+=4;\n\t\t\t\t\tl_data_size-=4;\n\t\t\t\t\t\n\t\t\t\t\tif (l_data_size >= l_N_ppm) {\n\t\t\t\t\t\tmemcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data, l_N_ppm);\n\t\t\t\t\t\tl_ppm_data_size += l_N_ppm;\n\t\t\t\t\t\tl_data_size -= l_N_ppm;\n\t\t\t\t\t\tl_data += l_N_ppm;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmemcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data, l_data_size);\n\t\t\t\t\t\tl_ppm_data_size += l_data_size;\n\t\t\t\t\t\tl_N_ppm_remaining = l_N_ppm - l_data_size;\n\t\t\t\t\t\tl_data_size = 0U;\n\t\t\t\t\t}\n\t\t\t\t} while (l_data_size > 0U);\n\t\t\t}\n\t\t\topj_free(p_cp->ppm_markers[i].m_data);\n\t\t\tp_cp->ppm_markers[i].m_data = NULL;\n\t\t\tp_cp->ppm_markers[i].m_data_size = 0U;\n\t\t}\n\t}\n\t\n\tp_cp->ppm_data = p_cp->ppm_buffer;\n\tp_cp->ppm_data_size = p_cp->ppm_len;\n\t\n\tp_cp->ppm_markers_count = 0U;\n\topj_free(p_cp->ppm_markers);\n\tp_cp->ppm_markers = NULL;\n\t\n\treturn OPJ_TRUE;\n}\n\n/**\n * Reads a PPT marker (Packed packet headers, tile-part header)\n *\n * @param       p_header_data   the data contained in the PPT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the PPT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_ppt (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n\topj_cp_t *l_cp = 00;\n\topj_tcp_t *l_tcp = 00;\n\tOPJ_UINT32 l_Z_ppt;\n\n\t/* preconditions */\n\tassert(p_header_data != 00);\n\tassert(p_j2k != 00);\n\tassert(p_manager != 00);\n\n\t/* We need to have the Z_ppt element + 1 byte of Ippt at minimum */\n\tif (p_header_size < 2) {\n\t\topj_event_msg(p_manager, EVT_ERROR, \"Error reading PPT marker\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\n\tl_cp = &(p_j2k->m_cp);\n\tif (l_cp->ppm){\n\t\topj_event_msg(p_manager, EVT_ERROR, \"Error reading PPT marker: packet header have been previously found in the main header (PPM marker).\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\n\tl_tcp = &(l_cp->tcps[p_j2k->m_current_tile_number]);\n\tl_tcp->ppt = 1;\n\n\topj_read_bytes(p_header_data,&l_Z_ppt,1);               /* Z_ppt */\n\t++p_header_data;\n\t--p_header_size;\n\t\n\t/* check allocation needed */\n\tif (l_tcp->ppt_markers == NULL) { /* first PPT marker */\n\t\tOPJ_UINT32 l_newCount = l_Z_ppt + 1U; /* can't overflow, l_Z_ppt is UINT8 */\n\t\tassert(l_tcp->ppt_markers_count == 0U);\n\t\t\n\t\tl_tcp->ppt_markers = (opj_ppx *) opj_calloc(l_newCount, sizeof(opj_ppx));\n\t\tif (l_tcp->ppt_markers == NULL) {\n\t\t\topj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPT marker\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_tcp->ppt_markers_count = l_newCount;\n\t} else if (l_tcp->ppt_markers_count <= l_Z_ppt) {\n\t\tOPJ_UINT32 l_newCount = l_Z_ppt + 1U; /* can't overflow, l_Z_ppt is UINT8 */\n\t\topj_ppx *new_ppt_markers;\n\t\tnew_ppt_markers = (opj_ppx *) opj_realloc(l_tcp->ppt_markers, l_newCount * sizeof(opj_ppx));\n\t\tif (new_ppt_markers == NULL) {\n\t\t\t/* clean up to be done on l_tcp destruction */\n\t\t\topj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPT marker\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_tcp->ppt_markers = new_ppt_markers;\n\t\tmemset(l_tcp->ppt_markers + l_tcp->ppt_markers_count, 0, (l_newCount - l_tcp->ppt_markers_count) * sizeof(opj_ppx));\n\t\tl_tcp->ppt_markers_count = l_newCount;\n\t}\n\t\n\tif (l_tcp->ppt_markers[l_Z_ppt].m_data != NULL) {\n\t\t/* clean up to be done on l_tcp destruction */\n\t\topj_event_msg(p_manager, EVT_ERROR, \"Zppt %u already read\\n\", l_Z_ppt);\n\t\treturn OPJ_FALSE;\n\t}\n\t\n\tl_tcp->ppt_markers[l_Z_ppt].m_data = (OPJ_BYTE *) opj_malloc(p_header_size);\n\tif (l_tcp->ppt_markers[l_Z_ppt].m_data == NULL) {\n\t\t/* clean up to be done on l_tcp destruction */\n\t\topj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPT marker\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\tl_tcp->ppt_markers[l_Z_ppt].m_data_size = p_header_size;\n\tmemcpy(l_tcp->ppt_markers[l_Z_ppt].m_data, p_header_data, p_header_size);\n\treturn OPJ_TRUE;\n}\n\n/**\n * Merges all PPT markers read (Packed packet headers, tile-part header)\n *\n * @param       p_tcp   the tile.\n * @param       p_manager               the user event manager.\n */\nstatic OPJ_BOOL opj_j2k_merge_ppt(opj_tcp_t *p_tcp, opj_event_mgr_t * p_manager)\n{\n\tOPJ_UINT32 i, l_ppt_data_size;\n\t/* preconditions */\n\tassert(p_tcp != 00);\n\tassert(p_manager != 00);\n\tassert(p_tcp->ppt_buffer == NULL);\n\t\n\tif (p_tcp->ppt == 0U) {\n\t\treturn OPJ_TRUE;\n\t}\n\t\n\tl_ppt_data_size = 0U;\n\tfor (i = 0U; i < p_tcp->ppt_markers_count; ++i) {\n\t\tl_ppt_data_size += p_tcp->ppt_markers[i].m_data_size; /* can't overflow, max 256 markers of max 65536 bytes */\n\t}\n\t\n\tp_tcp->ppt_buffer = (OPJ_BYTE *) opj_malloc(l_ppt_data_size);\n\tif (p_tcp->ppt_buffer == 00) {\n\t\topj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPT marker\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\tp_tcp->ppt_len = l_ppt_data_size;\n\tl_ppt_data_size = 0U;\n\tfor (i = 0U; i < p_tcp->ppt_markers_count; ++i) {\n\t\tif (p_tcp->ppt_markers[i].m_data != NULL) { /* standard doesn't seem to require contiguous Zppt */\n\t\t\tmemcpy(p_tcp->ppt_buffer + l_ppt_data_size, p_tcp->ppt_markers[i].m_data, p_tcp->ppt_markers[i].m_data_size);\n\t\t\tl_ppt_data_size += p_tcp->ppt_markers[i].m_data_size; /* can't overflow, max 256 markers of max 65536 bytes */\n\t\t\t\n\t\t\topj_free(p_tcp->ppt_markers[i].m_data);\n\t\t\tp_tcp->ppt_markers[i].m_data = NULL;\n\t\t\tp_tcp->ppt_markers[i].m_data_size = 0U;\n\t\t}\n\t}\n\t\n\tp_tcp->ppt_markers_count = 0U;\n\topj_free(p_tcp->ppt_markers);\n\tp_tcp->ppt_markers = NULL;\n\t\n\tp_tcp->ppt_data = p_tcp->ppt_buffer;\n\tp_tcp->ppt_data_size = p_tcp->ppt_len;\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_tlm(     opj_j2k_t *p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager\n                            )\n{\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_tlm_size;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_tlm_size = 6 + (5*p_j2k->m_specific_param.m_encoder.m_total_tile_parts);\n\n        if (l_tlm_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_tlm_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write TLM marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_tlm_size;\n        }\n\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        /* change the way data is written to avoid seeking if possible */\n        /* TODO */\n        p_j2k->m_specific_param.m_encoder.m_tlm_start = opj_stream_tell(p_stream);\n\n        opj_write_bytes(l_current_data,J2K_MS_TLM,2);                                   /* TLM */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_tlm_size-2,2);                                 /* Lpoc */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,0,1);                                                    /* Ztlm=0*/\n        ++l_current_data;\n\n        opj_write_bytes(l_current_data,0x50,1);                                                 /* Stlm ST=1(8bits-255 tiles max),SP=1(Ptlm=32bits) */\n        ++l_current_data;\n\n        /* do nothing on the 5 * l_j2k->m_specific_param.m_encoder.m_total_tile_parts remaining data */\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_tlm_size,p_manager) != l_tlm_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_sot(     opj_j2k_t *p_j2k,\n                                                        OPJ_BYTE * p_data,\n                                                        OPJ_UINT32 * p_data_written,\n                                                        const opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager\n                            )\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        opj_write_bytes(p_data,J2K_MS_SOT,2);                                   /* SOT */\n        p_data += 2;\n\n        opj_write_bytes(p_data,10,2);                                                   /* Lsot */\n        p_data += 2;\n\n        opj_write_bytes(p_data, p_j2k->m_current_tile_number,2);                        /* Isot */\n        p_data += 2;\n\n        /* Psot  */\n        p_data += 4;\n\n        opj_write_bytes(p_data, p_j2k->m_specific_param.m_encoder.m_current_tile_part_number,1);                        /* TPsot */\n        ++p_data;\n\n        opj_write_bytes(p_data, p_j2k->m_cp.tcps[p_j2k->m_current_tile_number].m_nb_tile_parts,1);                      /* TNsot */\n        ++p_data;\n\n        /* UniPG>> */\n#ifdef USE_JPWL\n        /* update markers struct */\n/*\n        OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_SOT, p_j2k->sot_start, len + 2);\n*/\n  assert( 0 && \"TODO\" );\n#endif /* USE_JPWL */\n\n        * p_data_written = 12;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_get_sot_values(OPJ_BYTE *  p_header_data,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_UINT32  p_header_size,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_UINT32* p_tile_no,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_UINT32* p_tot_len,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_UINT32* p_current_part,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_UINT32* p_num_parts,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t opj_event_mgr_t * p_manager )\n{\n\t/* preconditions */\n\tassert(p_header_data != 00);\n\tassert(p_manager != 00);\n\t\n\t/* Size of this marker is fixed = 12 (we have already read marker and its size)*/\n\tif (p_header_size != 8) {\n\t\topj_event_msg(p_manager, EVT_ERROR, \"Error reading SOT marker\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\t\n\topj_read_bytes(p_header_data,p_tile_no,2);      /* Isot */\n\tp_header_data+=2;\n\topj_read_bytes(p_header_data,p_tot_len,4);      /* Psot */\n\tp_header_data+=4;\n\topj_read_bytes(p_header_data,p_current_part,1); /* TPsot */\n\t++p_header_data;\n\topj_read_bytes(p_header_data,p_num_parts ,1);   /* TNsot */\n\t++p_header_data;\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_sot ( opj_j2k_t *p_j2k,\n                            OPJ_BYTE * p_header_data,\n                            OPJ_UINT32 p_header_size,\n                            opj_event_mgr_t * p_manager )\n{\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        OPJ_UINT32 l_tot_len, l_num_parts = 0;\n        OPJ_UINT32 l_current_part;\n        OPJ_UINT32 l_tile_x,l_tile_y;\n\n        /* preconditions */\n\t\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\t\n        if (! opj_j2k_get_sot_values(p_header_data, p_header_size, &(p_j2k->m_current_tile_number), &l_tot_len, &l_current_part, &l_num_parts, p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading SOT marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        l_cp = &(p_j2k->m_cp);\n\n        /* testcase 2.pdf.SIGFPE.706.1112 */\n        if (p_j2k->m_current_tile_number >= l_cp->tw * l_cp->th) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Invalid tile number %d\\n\", p_j2k->m_current_tile_number);\n                return OPJ_FALSE;\n        }\n\n        l_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];\n        l_tile_x = p_j2k->m_current_tile_number % l_cp->tw;\n        l_tile_y = p_j2k->m_current_tile_number / l_cp->tw;\n\n#ifdef USE_JPWL\n        if (l_cp->correct) {\n\n                OPJ_UINT32 tileno = p_j2k->m_current_tile_number;\n                static OPJ_UINT32 backup_tileno = 0;\n\n                /* tileno is negative or larger than the number of tiles!!! */\n                if (tileno > (l_cp->tw * l_cp->th)) {\n                        opj_event_msg(p_manager, EVT_ERROR,\n                                        \"JPWL: bad tile number (%d out of a maximum of %d)\\n\",\n                                        tileno, (l_cp->tw * l_cp->th));\n                        if (!JPWL_ASSUME) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                return OPJ_FALSE;\n                        }\n                        /* we try to correct */\n                        tileno = backup_tileno;\n                        opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust this\\n\"\n                                        \"- setting tile number to %d\\n\",\n                                        tileno);\n                }\n\n                /* keep your private count of tiles */\n                backup_tileno++;\n        };\n#endif /* USE_JPWL */\n\n        /* look for the tile in the list of already processed tile (in parts). */\n        /* Optimization possible here with a more complex data structure and with the removing of tiles */\n        /* since the time taken by this function can only grow at the time */\n\n        /* PSot should be equal to zero or >=14 or <= 2^32-1 */\n        if ((l_tot_len !=0 ) && (l_tot_len < 14) )\n        {\n            if (l_tot_len == 12 ) /* MSD: Special case for the PHR data which are read by kakadu*/\n            {\n                opj_event_msg(p_manager, EVT_WARNING, \"Empty SOT marker detected: Psot=%d.\\n\", l_tot_len);\n            }\n            else\n            {\n                opj_event_msg(p_manager, EVT_ERROR, \"Psot value is not correct regards to the JPEG2000 norm: %d.\\n\", l_tot_len);\n                return OPJ_FALSE;\n            }\n        }\n\n#ifdef USE_JPWL\n        if (l_cp->correct) {\n\n                /* totlen is negative or larger than the bytes left!!! */\n                if (/*(l_tot_len < 0) ||*/ (l_tot_len > p_header_size ) ) { /* FIXME it seems correct; for info in V1 -> (p_stream_numbytesleft(p_stream) + 8))) { */\n                        opj_event_msg(p_manager, EVT_ERROR,\n                                        \"JPWL: bad tile byte size (%d bytes against %d bytes left)\\n\",\n                                        l_tot_len, p_header_size ); /* FIXME it seems correct; for info in V1 -> p_stream_numbytesleft(p_stream) + 8); */\n                        if (!JPWL_ASSUME) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                return OPJ_FALSE;\n                        }\n                        /* we try to correct */\n                        l_tot_len = 0;\n                        opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust this\\n\"\n                                        \"- setting Psot to %d => assuming it is the last tile\\n\",\n                                        l_tot_len);\n                }\n                };\n#endif /* USE_JPWL */\n\n                /* Ref A.4.2: Psot could be equal zero if it is the last tile-part of the codestream.*/\n                if (!l_tot_len) {\n                        opj_event_msg(p_manager, EVT_INFO, \"Psot value of the current tile-part is equal to zero, \"\n                                        \"we assuming it is the last tile-part of the codestream.\\n\");\n                        p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;\n                }\n\n                if (l_num_parts != 0) { /* Number of tile-part header is provided by this tile-part header */\n                        l_num_parts += p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction;\n                        /* Useful to manage the case of textGBR.jp2 file because two values of TNSot are allowed: the correct numbers of\n                         * tile-parts for that tile and zero (A.4.2 of 15444-1 : 2002). */\n                        if (l_tcp->m_nb_tile_parts) {\n                                if (l_current_part >= l_tcp->m_nb_tile_parts){\n                                        opj_event_msg(p_manager, EVT_ERROR, \"In SOT marker, TPSot (%d) is not valid regards to the current \"\n                                                        \"number of tile-part (%d), giving up\\n\", l_current_part, l_tcp->m_nb_tile_parts );\n                                        p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;\n                                        return OPJ_FALSE;\n                                }\n                        }\n                        if( l_current_part >= l_num_parts ) {\n                          /* testcase 451.pdf.SIGSEGV.ce9.3723 */\n                          opj_event_msg(p_manager, EVT_ERROR, \"In SOT marker, TPSot (%d) is not valid regards to the current \"\n                            \"number of tile-part (header) (%d), giving up\\n\", l_current_part, l_num_parts );\n                          p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;\n                          return OPJ_FALSE;\n                        }\n                        l_tcp->m_nb_tile_parts = l_num_parts;\n                }\n\n                /* If know the number of tile part header we will check if we didn't read the last*/\n                if (l_tcp->m_nb_tile_parts) {\n                        if (l_tcp->m_nb_tile_parts == (l_current_part+1)) {\n                                p_j2k->m_specific_param.m_decoder.m_can_decode = 1; /* Process the last tile-part header*/\n                        }\n                }\n\n                if (!p_j2k->m_specific_param.m_decoder.m_last_tile_part){\n                        /* Keep the size of data to skip after this marker */\n                        p_j2k->m_specific_param.m_decoder.m_sot_length = l_tot_len - 12; /* SOT_marker_size = 12 */\n                }\n                else {\n                        /* FIXME: need to be computed from the number of bytes remaining in the codestream */\n                        p_j2k->m_specific_param.m_decoder.m_sot_length = 0;\n                }\n\n                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPH;\n\n                /* Check if the current tile is outside the area we want decode or not corresponding to the tile index*/\n                if (p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec == -1) {\n                        p_j2k->m_specific_param.m_decoder.m_skip_data =\n                                (l_tile_x < p_j2k->m_specific_param.m_decoder.m_start_tile_x)\n                                ||      (l_tile_x >= p_j2k->m_specific_param.m_decoder.m_end_tile_x)\n                                ||  (l_tile_y < p_j2k->m_specific_param.m_decoder.m_start_tile_y)\n                                ||      (l_tile_y >= p_j2k->m_specific_param.m_decoder.m_end_tile_y);\n                }\n                else {\n                        assert( p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec >= 0 );\n                        p_j2k->m_specific_param.m_decoder.m_skip_data =\n                                (p_j2k->m_current_tile_number != (OPJ_UINT32)p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec);\n                }\n\n                /* Index */\n                if (p_j2k->cstr_index)\n                {\n                        assert(p_j2k->cstr_index->tile_index != 00);\n                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tileno = p_j2k->m_current_tile_number;\n                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_tpsno = l_current_part;\n\n                        if (l_num_parts != 0){\n                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].nb_tps = l_num_parts;\n                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = l_num_parts;\n\n                                if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index) {\n                                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index =\n                                                (opj_tp_index_t*)opj_calloc(l_num_parts, sizeof(opj_tp_index_t));\n                                        if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index) {\n                                                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read SOT marker. Tile index allocation failed\\n\");\n                                                return OPJ_FALSE;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n                                }\n                                else {\n                                        opj_tp_index_t *new_tp_index = (opj_tp_index_t *) opj_realloc(\n                                                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index, l_num_parts* sizeof(opj_tp_index_t));\n                                        if (! new_tp_index) {\n                                                opj_free(p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index);\n                                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index = NULL;\n                                                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read SOT marker. Tile index allocation failed\\n\");\n                                                return OPJ_FALSE;\n                                        }\n                                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index = new_tp_index;\n                                }\n                        }\n                        else{\n                                /*if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index)*/ {\n\n                                        if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index) {\n                                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = 10;\n                                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index =\n                                                        (opj_tp_index_t*)opj_calloc( p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps,\n                                                                        sizeof(opj_tp_index_t));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index) {\n                                                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = 0;\n                                                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read SOT marker. Tile index allocation failed\\n\");\n                                                        return OPJ_FALSE;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t        }\n                                        }\n\n                                        if ( l_current_part >= p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps ){\n                                                opj_tp_index_t *new_tp_index;\n                                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = l_current_part + 1;\n                                                new_tp_index = (opj_tp_index_t *) opj_realloc(\n                                                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index,\n                                                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps * sizeof(opj_tp_index_t));\n                                                if (! new_tp_index) {\n                                                        opj_free(p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index);\n                                                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index = NULL;\n                                                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = 0;\n                                                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read SOT marker. Tile index allocation failed\\n\");\n                                                        return OPJ_FALSE;\n                                                }\n                                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index = new_tp_index;\n                                        }\n                                }\n\n                        }\n\n                }\n\n                /* FIXME move this onto a separate method to call before reading any SOT, remove part about main_end header, use a index struct inside p_j2k */\n                /* if (p_j2k->cstr_info) {\n                   if (l_tcp->first) {\n                   if (tileno == 0) {\n                   p_j2k->cstr_info->main_head_end = p_stream_tell(p_stream) - 13;\n                   }\n\n                   p_j2k->cstr_info->tile[tileno].tileno = tileno;\n                   p_j2k->cstr_info->tile[tileno].start_pos = p_stream_tell(p_stream) - 12;\n                   p_j2k->cstr_info->tile[tileno].end_pos = p_j2k->cstr_info->tile[tileno].start_pos + totlen - 1;\n                   p_j2k->cstr_info->tile[tileno].num_tps = numparts;\n\n                   if (numparts) {\n                   p_j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_malloc(numparts * sizeof(opj_tp_info_t));\n                   }\n                   else {\n                   p_j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_malloc(10 * sizeof(opj_tp_info_t)); // Fixme (10)\n                   }\n                   }\n                   else {\n                   p_j2k->cstr_info->tile[tileno].end_pos += totlen;\n                   }\n\n                   p_j2k->cstr_info->tile[tileno].tp[partno].tp_start_pos = p_stream_tell(p_stream) - 12;\n                   p_j2k->cstr_info->tile[tileno].tp[partno].tp_end_pos =\n                   p_j2k->cstr_info->tile[tileno].tp[partno].tp_start_pos + totlen - 1;\n                   }*/\n                return OPJ_TRUE;\n        }\n\nstatic OPJ_BOOL opj_j2k_write_sod(     opj_j2k_t *p_j2k,\n                                                        opj_tcd_t * p_tile_coder,\n                                                        OPJ_BYTE * p_data,\n                                                        OPJ_UINT32 * p_data_written,\n                                                        OPJ_UINT32 p_total_data_size,\n                                                        const opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager\n                            )\n{\n        opj_codestream_info_t *l_cstr_info = 00;\n        OPJ_UINT32 l_remaining_data;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        opj_write_bytes(p_data,J2K_MS_SOD,2);                                   /* SOD */\n        p_data += 2;\n\n        /* make room for the EOF marker */\n        l_remaining_data =  p_total_data_size - 4;\n\n        /* update tile coder */\n        p_tile_coder->tp_num = p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number ;\n        p_tile_coder->cur_tp_num = p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;\n\n         /* INDEX >> */\n        /* TODO mergeV2: check this part which use cstr_info */\n        /*l_cstr_info = p_j2k->cstr_info;\n        if (l_cstr_info) {\n                if (!p_j2k->m_specific_param.m_encoder.m_current_tile_part_number ) {\n                        //TODO cstr_info->tile[p_j2k->m_current_tile_number].end_header = p_stream_tell(p_stream) + p_j2k->pos_correction - 1;\n                        l_cstr_info->tile[p_j2k->m_current_tile_number].tileno = p_j2k->m_current_tile_number;\n                }\n                else {*/\n                        /*\n                        TODO\n                        if\n                                (cstr_info->tile[p_j2k->m_current_tile_number].packet[cstr_info->packno - 1].end_pos < p_stream_tell(p_stream))\n                        {\n                                cstr_info->tile[p_j2k->m_current_tile_number].packet[cstr_info->packno].start_pos = p_stream_tell(p_stream);\n                        }*/\n                /*}*/\n                /* UniPG>> */\n#ifdef USE_JPWL\n                /* update markers struct */\n                /*OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_SOD, p_j2k->sod_start, 2);\n*/\n  assert( 0 && \"TODO\" );\n#endif /* USE_JPWL */\n                /* <<UniPG */\n        /*}*/\n        /* << INDEX */\n\n        if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0) {\n                p_tile_coder->tcd_image->tiles->packno = 0;\n                if (l_cstr_info) {\n                        l_cstr_info->packno = 0;\n                }\n        }\n\n        *p_data_written = 0;\n\n        if (! opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number, p_data, p_data_written, l_remaining_data , l_cstr_info)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Cannot encode tile\\n\");\n                return OPJ_FALSE;\n        }\n\n        *p_data_written += 2;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_sod (opj_j2k_t *p_j2k,\n                           opj_stream_private_t *p_stream,\n                                                   opj_event_mgr_t * p_manager\n                           )\n{\n        OPJ_SIZE_T l_current_read_size;\n        opj_codestream_index_t * l_cstr_index = 00;\n        OPJ_BYTE ** l_current_data = 00;\n        opj_tcp_t * l_tcp = 00;\n        OPJ_UINT32 * l_tile_len = 00;\n        OPJ_BOOL l_sot_length_pb_detected = OPJ_FALSE;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_tcp = &(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);\n\n        if (p_j2k->m_specific_param.m_decoder.m_last_tile_part) {\n                /* opj_stream_get_number_byte_left returns OPJ_OFF_T\n                // but we are in the last tile part,\n                // so its result will fit on OPJ_UINT32 unless we find\n                // a file with a single tile part of more than 4 GB...*/\n                p_j2k->m_specific_param.m_decoder.m_sot_length = (OPJ_UINT32)(opj_stream_get_number_byte_left(p_stream) - 2);\n        }\n        else {\n            /* Check to avoid pass the limit of OPJ_UINT32 */\n            if (p_j2k->m_specific_param.m_decoder.m_sot_length >= 2 )\n                p_j2k->m_specific_param.m_decoder.m_sot_length -= 2;\n            else {\n                /* MSD: case commented to support empty SOT marker (PHR data) */\n            }\n        }\n\n        l_current_data = &(l_tcp->m_data);\n        l_tile_len = &l_tcp->m_data_size;\n\n        /* Patch to support new PHR data */\n        if (p_j2k->m_specific_param.m_decoder.m_sot_length) {\n            /* If we are here, we'll try to read the data after allocation */\n            /* Check enough bytes left in stream before allocation */\n            if ((OPJ_OFF_T)p_j2k->m_specific_param.m_decoder.m_sot_length > opj_stream_get_number_byte_left(p_stream)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Tile part length size inconsistent with stream length\\n\");\n                return OPJ_FALSE;\n            }\n            if (! *l_current_data) {\n                /* LH: oddly enough, in this path, l_tile_len!=0.\n                 * TODO: If this was consistent, we could simplify the code to only use realloc(), as realloc(0,...) default to malloc(0,...).\n                 */\n                *l_current_data = (OPJ_BYTE*) opj_malloc(p_j2k->m_specific_param.m_decoder.m_sot_length);\n            }\n            else {\n                OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(*l_current_data, *l_tile_len + p_j2k->m_specific_param.m_decoder.m_sot_length);\n                if (! l_new_current_data) {\n                        opj_free(*l_current_data);\n                        /*nothing more is done as l_current_data will be set to null, and just\n                          afterward we enter in the error path\n                          and the actual tile_len is updated (committed) at the end of the\n                          function. */\n                }\n                *l_current_data = l_new_current_data;\n            }\n            \n            if (*l_current_data == 00) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to decode tile\\n\");\n                return OPJ_FALSE;\n            }\n        }\n        else {\n            l_sot_length_pb_detected = OPJ_TRUE;\n        }\n\n        /* Index */\n        l_cstr_index = p_j2k->cstr_index;\n        if (l_cstr_index) {\n                OPJ_OFF_T l_current_pos = opj_stream_tell(p_stream) - 2;\n\n                OPJ_UINT32 l_current_tile_part = l_cstr_index->tile_index[p_j2k->m_current_tile_number].current_tpsno;\n                l_cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index[l_current_tile_part].end_header =\n                                l_current_pos;\n                l_cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index[l_current_tile_part].end_pos =\n                                l_current_pos + p_j2k->m_specific_param.m_decoder.m_sot_length + 2;\n\n                if (OPJ_FALSE == opj_j2k_add_tlmarker(p_j2k->m_current_tile_number,\n                                        l_cstr_index,\n                                        J2K_MS_SOD,\n                                        l_current_pos,\n                                        p_j2k->m_specific_param.m_decoder.m_sot_length + 2)) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add tl marker\\n\");\n                        return OPJ_FALSE;\n                }\n\n                /*l_cstr_index->packno = 0;*/\n        }\n\n        /* Patch to support new PHR data */\n        if (!l_sot_length_pb_detected) {\n            l_current_read_size = opj_stream_read_data(\n                        p_stream,\n                        *l_current_data + *l_tile_len,\n                        p_j2k->m_specific_param.m_decoder.m_sot_length,\n                        p_manager);\n        }\n        else\n        {\n            l_current_read_size = 0;\n        }\n\n        if (l_current_read_size != p_j2k->m_specific_param.m_decoder.m_sot_length) {\n                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;\n        }\n        else {\n                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;\n        }\n\n        *l_tile_len += (OPJ_UINT32)l_current_read_size;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k,\n                            OPJ_UINT32 p_tile_no,\n                            OPJ_UINT32 p_comp_no,\n                            OPJ_UINT32 nb_comps,\n                            opj_stream_private_t *p_stream,\n                            opj_event_mgr_t * p_manager\n                            )\n{\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_rgn_size;\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_tccp_t *l_tccp = 00;\n        OPJ_UINT32 l_comp_room;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = &l_cp->tcps[p_tile_no];\n        l_tccp = &l_tcp->tccps[p_comp_no];\n\n        if (nb_comps <= 256) {\n                l_comp_room = 1;\n        }\n        else {\n                l_comp_room = 2;\n        }\n\n        l_rgn_size = 6 + l_comp_room;\n\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        opj_write_bytes(l_current_data,J2K_MS_RGN,2);                                   /* RGN  */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_rgn_size-2,2);                                 /* Lrgn */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,p_comp_no,l_comp_room);                          /* Crgn */\n        l_current_data+=l_comp_room;\n\n        opj_write_bytes(l_current_data, 0,1);                                           /* Srgn */\n        ++l_current_data;\n\n        opj_write_bytes(l_current_data, (OPJ_UINT32)l_tccp->roishift,1);                            /* SPrgn */\n        ++l_current_data;\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_rgn_size,p_manager) != l_rgn_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_eoc(     opj_j2k_t *p_j2k,\n                            opj_stream_private_t *p_stream,\n                            opj_event_mgr_t * p_manager\n                            )\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        opj_write_bytes(p_j2k->m_specific_param.m_encoder.m_header_tile_data,J2K_MS_EOC,2);                                     /* EOC */\n\n/* UniPG>> */\n#ifdef USE_JPWL\n        /* update markers struct */\n        /*\n        OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_EOC, p_stream_tell(p_stream) - 2, 2);\n*/\n#endif /* USE_JPWL */\n\n        if ( opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,2,p_manager) != 2) {\n                return OPJ_FALSE;\n        }\n\n        if ( ! opj_stream_flush(p_stream,p_manager) ) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a RGN marker (Region Of Interest)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_rgn (opj_j2k_t *p_j2k,\n                                  OPJ_BYTE * p_header_data,\n                                  OPJ_UINT32 p_header_size,\n                                  opj_event_mgr_t * p_manager\n                                  )\n{\n        OPJ_UINT32 l_nb_comp;\n        opj_image_t * l_image = 00;\n\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        OPJ_UINT32 l_comp_room, l_comp_no, l_roi_sty;\n\n        /* preconditions*/\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_image = p_j2k->m_private_image;\n        l_nb_comp = l_image->numcomps;\n\n        if (l_nb_comp <= 256) {\n                l_comp_room = 1; }\n        else {\n                l_comp_room = 2; }\n\n        if (p_header_size != 2 + l_comp_room) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading RGN marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?\n                                &l_cp->tcps[p_j2k->m_current_tile_number] :\n                                p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n        opj_read_bytes(p_header_data,&l_comp_no,l_comp_room);           /* Crgn */\n        p_header_data+=l_comp_room;\n        opj_read_bytes(p_header_data,&l_roi_sty,1);                                     /* Srgn */\n        ++p_header_data;\n\n#ifdef USE_JPWL\n        if (l_cp->correct) {\n                /* totlen is negative or larger than the bytes left!!! */\n                if (l_comp_room >= l_nb_comp) {\n                        opj_event_msg(p_manager, EVT_ERROR,\n                                \"JPWL: bad component number in RGN (%d when there are only %d)\\n\",\n                                l_comp_room, l_nb_comp);\n                        if (!JPWL_ASSUME) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                return OPJ_FALSE;\n                        }\n                }\n        };\n#endif /* USE_JPWL */\n\n        /* testcase 3635.pdf.asan.77.2930 */\n        if (l_comp_no >= l_nb_comp) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                        \"bad component number in RGN (%d when there are only %d)\\n\",\n                        l_comp_no, l_nb_comp);\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(p_header_data,(OPJ_UINT32 *) (&(l_tcp->tccps[l_comp_no].roishift)),1);   /* SPrgn */\n        ++p_header_data;\n\n        return OPJ_TRUE;\n\n}\n\nstatic OPJ_FLOAT32 opj_j2k_get_tp_stride (opj_tcp_t * p_tcp)\n{\n        return (OPJ_FLOAT32) ((p_tcp->m_nb_tile_parts - 1) * 14);\n}\n\nstatic OPJ_FLOAT32 opj_j2k_get_default_stride (opj_tcp_t * p_tcp)\n{\n    (void)p_tcp;\n    return 0;\n}\n\nstatic OPJ_BOOL opj_j2k_update_rates(  opj_j2k_t *p_j2k,\n                                                            opj_stream_private_t *p_stream,\n                                                            opj_event_mgr_t * p_manager )\n{\n        opj_cp_t * l_cp = 00;\n        opj_image_t * l_image = 00;\n        opj_tcp_t * l_tcp = 00;\n        opj_image_comp_t * l_img_comp = 00;\n\n        OPJ_UINT32 i,j,k;\n        OPJ_INT32 l_x0,l_y0,l_x1,l_y1;\n        OPJ_FLOAT32 * l_rates = 0;\n        OPJ_FLOAT32 l_sot_remove;\n        OPJ_UINT32 l_bits_empty, l_size_pixel;\n        OPJ_UINT32 l_tile_size = 0;\n        OPJ_UINT32 l_last_res;\n        OPJ_FLOAT32 (* l_tp_stride_func)(opj_tcp_t *) = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_image = p_j2k->m_private_image;\n        l_tcp = l_cp->tcps;\n\n        l_bits_empty = 8 * l_image->comps->dx * l_image->comps->dy;\n        l_size_pixel = l_image->numcomps * l_image->comps->prec;\n        l_sot_remove = (OPJ_FLOAT32) opj_stream_tell(p_stream) / (OPJ_FLOAT32)(l_cp->th * l_cp->tw);\n\n        if (l_cp->m_specific_param.m_enc.m_tp_on) {\n                l_tp_stride_func = opj_j2k_get_tp_stride;\n        }\n        else {\n                l_tp_stride_func = opj_j2k_get_default_stride;\n        }\n\n        for (i=0;i<l_cp->th;++i) {\n                for (j=0;j<l_cp->tw;++j) {\n                        OPJ_FLOAT32 l_offset = (OPJ_FLOAT32)(*l_tp_stride_func)(l_tcp) / (OPJ_FLOAT32)l_tcp->numlayers;\n\n                        /* 4 borders of the tile rescale on the image if necessary */\n                        l_x0 = opj_int_max((OPJ_INT32)(l_cp->tx0 + j * l_cp->tdx), (OPJ_INT32)l_image->x0);\n                        l_y0 = opj_int_max((OPJ_INT32)(l_cp->ty0 + i * l_cp->tdy), (OPJ_INT32)l_image->y0);\n                        l_x1 = opj_int_min((OPJ_INT32)(l_cp->tx0 + (j + 1) * l_cp->tdx), (OPJ_INT32)l_image->x1);\n                        l_y1 = opj_int_min((OPJ_INT32)(l_cp->ty0 + (i + 1) * l_cp->tdy), (OPJ_INT32)l_image->y1);\n\n                        l_rates = l_tcp->rates;\n\n                        /* Modification of the RATE >> */\n                        if (*l_rates > 0.0f) {\n                                *l_rates =              (( (OPJ_FLOAT32) (l_size_pixel * (OPJ_UINT32)(l_x1 - l_x0) * (OPJ_UINT32)(l_y1 - l_y0)))\n                                                                /\n                                                                ((*l_rates) * (OPJ_FLOAT32)l_bits_empty)\n                                                                )\n                                                                -\n                                                                l_offset;\n                        }\n\n                        ++l_rates;\n\n                        for (k = 1; k < l_tcp->numlayers; ++k) {\n                                if (*l_rates > 0.0f) {\n                                        *l_rates =              (( (OPJ_FLOAT32) (l_size_pixel * (OPJ_UINT32)(l_x1 - l_x0) * (OPJ_UINT32)(l_y1 - l_y0)))\n                                                                        /\n                                                                                ((*l_rates) * (OPJ_FLOAT32)l_bits_empty)\n                                                                        )\n                                                                        -\n                                                                        l_offset;\n                                }\n\n                                ++l_rates;\n                        }\n\n                        ++l_tcp;\n\n                }\n        }\n\n        l_tcp = l_cp->tcps;\n\n        for (i=0;i<l_cp->th;++i) {\n                for     (j=0;j<l_cp->tw;++j) {\n                        l_rates = l_tcp->rates;\n\n                        if (*l_rates > 0.0f) {\n                                *l_rates -= l_sot_remove;\n\n                                if (*l_rates < 30.0f) {\n                                        *l_rates = 30.0f;\n                                }\n                        }\n\n                        ++l_rates;\n\n                        l_last_res = l_tcp->numlayers - 1;\n\n                        for (k = 1; k < l_last_res; ++k) {\n\n                                if (*l_rates > 0.0f) {\n                                        *l_rates -= l_sot_remove;\n\n                                        if (*l_rates < *(l_rates - 1) + 10.0f) {\n                                                *l_rates  = (*(l_rates - 1)) + 20.0f;\n                                        }\n                                }\n\n                                ++l_rates;\n                        }\n\n                        if (*l_rates > 0.0f) {\n                                *l_rates -= (l_sot_remove + 2.f);\n\n                                if (*l_rates < *(l_rates - 1) + 10.0f) {\n                                        *l_rates  = (*(l_rates - 1)) + 20.0f;\n                                }\n                        }\n\n                        ++l_tcp;\n                }\n        }\n\n        l_img_comp = l_image->comps;\n        l_tile_size = 0;\n\n        for (i=0;i<l_image->numcomps;++i) {\n                l_tile_size += (        opj_uint_ceildiv(l_cp->tdx,l_img_comp->dx)\n                                                        *\n                                                        opj_uint_ceildiv(l_cp->tdy,l_img_comp->dy)\n                                                        *\n                                                        l_img_comp->prec\n                                                );\n\n                ++l_img_comp;\n        }\n\n        l_tile_size = (OPJ_UINT32) (l_tile_size * 0.1625); /* 1.3/8 = 0.1625 */\n\n        l_tile_size += opj_j2k_get_specific_header_sizes(p_j2k);\n\n        p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = l_tile_size;\n        p_j2k->m_specific_param.m_encoder.m_encoded_tile_data =\n                        (OPJ_BYTE *) opj_malloc(p_j2k->m_specific_param.m_encoder.m_encoded_tile_size);\n        if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data == 00) {\n                return OPJ_FALSE;\n        }\n\n        if (OPJ_IS_CINEMA(l_cp->rsiz)) {\n                p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer =\n                                (OPJ_BYTE *) opj_malloc(5*p_j2k->m_specific_param.m_encoder.m_total_tile_parts);\n                if (! p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {\n                        return OPJ_FALSE;\n                }\n\n                p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current =\n                                p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer;\n        }\n\n        return OPJ_TRUE;\n}\n\n#if 0\nstatic OPJ_BOOL opj_j2k_read_eoc (     opj_j2k_t *p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager )\n{\n        OPJ_UINT32 i;\n        opj_tcd_t * l_tcd = 00;\n        OPJ_UINT32 l_nb_tiles;\n        opj_tcp_t * l_tcp = 00;\n        OPJ_BOOL l_success;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n        l_tcp = p_j2k->m_cp.tcps;\n\n        l_tcd = opj_tcd_create(OPJ_TRUE);\n        if (l_tcd == 00) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Cannot decode tile, memory error\\n\");\n                return OPJ_FALSE;\n        }\n\n        for (i = 0; i < l_nb_tiles; ++i) {\n                if (l_tcp->m_data) {\n                        if (! opj_tcd_init_decode_tile(l_tcd, i)) {\n                                opj_tcd_destroy(l_tcd);\n                                opj_event_msg(p_manager, EVT_ERROR, \"Cannot decode tile, memory error\\n\");\n                                return OPJ_FALSE;\n                        }\n\n                        l_success = opj_tcd_decode_tile(l_tcd, l_tcp->m_data, l_tcp->m_data_size, i, p_j2k->cstr_index);\n                        /* cleanup */\n\n                        if (! l_success) {\n                                p_j2k->m_specific_param.m_decoder.m_state |= J2K_STATE_ERR;\n                                break;\n                        }\n                }\n\n                opj_j2k_tcp_destroy(l_tcp);\n                ++l_tcp;\n        }\n\n        opj_tcd_destroy(l_tcd);\n        return OPJ_TRUE;\n}\n#endif\n\nstatic OPJ_BOOL opj_j2k_get_end_header(opj_j2k_t *p_j2k,\n                                                        struct opj_stream_private *p_stream,\n                                                        struct opj_event_mgr * p_manager )\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        p_j2k->cstr_index->main_head_end = opj_stream_tell(p_stream);\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_mct_data_group(  opj_j2k_t *p_j2k,\n                                                                        struct opj_stream_private *p_stream,\n                                                                        struct opj_event_mgr * p_manager )\n{\n        OPJ_UINT32 i;\n        opj_simple_mcc_decorrelation_data_t * l_mcc_record;\n        opj_mct_data_t * l_mct_record;\n        opj_tcp_t * l_tcp;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n\n        if (! opj_j2k_write_cbd(p_j2k,p_stream,p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        l_tcp = &(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);\n        l_mct_record = l_tcp->m_mct_records;\n\n        for (i=0;i<l_tcp->m_nb_mct_records;++i) {\n\n                if (! opj_j2k_write_mct_record(p_j2k,l_mct_record,p_stream,p_manager)) {\n                        return OPJ_FALSE;\n                }\n\n                ++l_mct_record;\n        }\n\n        l_mcc_record = l_tcp->m_mcc_records;\n\n        for     (i=0;i<l_tcp->m_nb_mcc_records;++i) {\n\n                if (! opj_j2k_write_mcc_record(p_j2k,l_mcc_record,p_stream,p_manager)) {\n                        return OPJ_FALSE;\n                }\n\n                ++l_mcc_record;\n        }\n\n        if (! opj_j2k_write_mco(p_j2k,p_stream,p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_all_coc(\n\topj_j2k_t *p_j2k,\n\tstruct opj_stream_private *p_stream,\n\tstruct opj_event_mgr * p_manager )\n{\n\tOPJ_UINT32 compno;\n\t\n\t/* preconditions */\n\tassert(p_j2k != 00);\n\tassert(p_manager != 00);\n\tassert(p_stream != 00);\n\t\n\tfor (compno = 1; compno < p_j2k->m_private_image->numcomps; ++compno)\n\t{\n\t\t/* cod is first component of first tile */\n\t\tif (! opj_j2k_compare_coc(p_j2k, 0, compno)) {\n\t\t\tif (! opj_j2k_write_coc(p_j2k,compno,p_stream, p_manager)) {\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_all_qcc(\n\topj_j2k_t *p_j2k,\n\tstruct opj_stream_private *p_stream,\n\tstruct opj_event_mgr * p_manager )\n{\n\tOPJ_UINT32 compno;\n\t\n\t/* preconditions */\n\tassert(p_j2k != 00);\n\tassert(p_manager != 00);\n\tassert(p_stream != 00);\n\t\n\tfor (compno = 1; compno < p_j2k->m_private_image->numcomps; ++compno)\n\t{\n\t\t/* qcd is first component of first tile */\n\t\tif (! opj_j2k_compare_qcc(p_j2k, 0, compno)) {\n\t\t\tif (! opj_j2k_write_qcc(p_j2k,compno,p_stream, p_manager)) {\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_regions( opj_j2k_t *p_j2k,\n                                                        struct opj_stream_private *p_stream,\n                                                        struct opj_event_mgr * p_manager )\n{\n        OPJ_UINT32 compno;\n        const opj_tccp_t *l_tccp = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_tccp = p_j2k->m_cp.tcps->tccps;\n\n        for (compno = 0; compno < p_j2k->m_private_image->numcomps; ++compno)  {\n                if (l_tccp->roishift) {\n\n                        if (! opj_j2k_write_rgn(p_j2k,0,compno,p_j2k->m_private_image->numcomps,p_stream,p_manager)) {\n                                return OPJ_FALSE;\n                        }\n                }\n\n                ++l_tccp;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_epc(     opj_j2k_t *p_j2k,\n                                                struct opj_stream_private *p_stream,\n                                                struct opj_event_mgr * p_manager )\n{\n        opj_codestream_index_t * l_cstr_index = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_cstr_index = p_j2k->cstr_index;\n        if (l_cstr_index) {\n                l_cstr_index->codestream_size = (OPJ_UINT64)opj_stream_tell(p_stream);\n                /* UniPG>> */\n                /* The following adjustment is done to adjust the codestream size */\n                /* if SOD is not at 0 in the buffer. Useful in case of JP2, where */\n                /* the first bunch of bytes is not in the codestream              */\n                l_cstr_index->codestream_size -= (OPJ_UINT64)l_cstr_index->main_head_start;\n                /* <<UniPG */\n        }\n\n#ifdef USE_JPWL\n        /* preparation of JPWL marker segments */\n#if 0\n        if(cp->epc_on) {\n\n                /* encode according to JPWL */\n                jpwl_encode(p_j2k, p_stream, image);\n\n        }\n#endif\n  assert( 0 && \"TODO\" );\n#endif /* USE_JPWL */\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_unk (     opj_j2k_t *p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                        OPJ_UINT32 *output_marker,\n                                                        opj_event_mgr_t * p_manager\n                                                        )\n{\n        OPJ_UINT32 l_unknown_marker;\n        const opj_dec_memory_marker_handler_t * l_marker_handler;\n        OPJ_UINT32 l_size_unk = 2;\n\n        /* preconditions*/\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        opj_event_msg(p_manager, EVT_WARNING, \"Unknown marker\\n\");\n\n\t\tfor (;;) {\n                /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer*/\n                if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                        return OPJ_FALSE;\n                }\n\n                /* read 2 bytes as the new marker ID*/\n                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_unknown_marker,2);\n\n                if (!(l_unknown_marker < 0xff00)) {\n\n                        /* Get the marker handler from the marker ID*/\n                        l_marker_handler = opj_j2k_get_marker_handler(l_unknown_marker);\n\n                        if (!(p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Marker is not compliant with its position\\n\");\n                                return OPJ_FALSE;\n                        }\n                        else {\n                                if (l_marker_handler->id != J2K_MS_UNK) {\n                                        /* Add the marker to the codestream index*/\n                                        if (l_marker_handler->id != J2K_MS_SOT)\n                                        {\n                                                OPJ_BOOL res = opj_j2k_add_mhmarker(p_j2k->cstr_index, J2K_MS_UNK,\n                                                                (OPJ_UINT32) opj_stream_tell(p_stream) - l_size_unk,\n                                                                l_size_unk);\n                                                if (res == OPJ_FALSE) {\n                                                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add mh marker\\n\");\n                                                        return OPJ_FALSE;\n                                                }\n                                        }\n                                        break; /* next marker is known and well located */\n                                }\n                                else\n                                        l_size_unk += 2;\n                        }\n                }\n        }\n\n        *output_marker = l_marker_handler->id ;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_mct_record(      opj_j2k_t *p_j2k,\n                                                                opj_mct_data_t * p_mct_record,\n                                                                struct opj_stream_private *p_stream,\n                                                                struct opj_event_mgr * p_manager )\n{\n        OPJ_UINT32 l_mct_size;\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_tmp;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_mct_size = 10 + p_mct_record->m_data_size;\n\n        if (l_mct_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mct_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write MCT marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mct_size;\n        }\n\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        opj_write_bytes(l_current_data,J2K_MS_MCT,2);                                   /* MCT */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_mct_size-2,2);                                 /* Lmct */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,0,2);                                                    /* Zmct */\n        l_current_data += 2;\n\n        /* only one marker atm */\n        l_tmp = (p_mct_record->m_index & 0xff) | (p_mct_record->m_array_type << 8) | (p_mct_record->m_element_type << 10);\n\n        opj_write_bytes(l_current_data,l_tmp,2);\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,0,2);                                                    /* Ymct */\n        l_current_data+=2;\n\n        memcpy(l_current_data,p_mct_record->m_data,p_mct_record->m_data_size);\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_mct_size,p_manager) != l_mct_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a MCT marker (Multiple Component Transform)\n *\n * @param       p_header_data   the data contained in the MCT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the MCT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_mct (      opj_j2k_t *p_j2k,\n                                                                    OPJ_BYTE * p_header_data,\n                                                                    OPJ_UINT32 p_header_size,\n                                                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_UINT32 i;\n        opj_tcp_t *l_tcp = 00;\n        OPJ_UINT32 l_tmp;\n        OPJ_UINT32 l_indix;\n        opj_mct_data_t * l_mct_data;\n\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n\n        l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?\n                        &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number] :\n                        p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n        if (p_header_size < 2) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCT marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        /* first marker */\n        opj_read_bytes(p_header_data,&l_tmp,2);                         /* Zmct */\n        p_header_data += 2;\n        if (l_tmp != 0) {\n                opj_event_msg(p_manager, EVT_WARNING, \"Cannot take in charge mct data within multiple MCT records\\n\");\n                return OPJ_TRUE;\n        }\n\n        if(p_header_size <= 6) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCT marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        /* Imct -> no need for other values, take the first, type is double with decorrelation x0000 1101 0000 0000*/\n        opj_read_bytes(p_header_data,&l_tmp,2);                         /* Imct */\n        p_header_data += 2;\n\n        l_indix = l_tmp & 0xff;\n        l_mct_data = l_tcp->m_mct_records;\n\n        for (i=0;i<l_tcp->m_nb_mct_records;++i) {\n                if (l_mct_data->m_index == l_indix) {\n                        break;\n                }\n                ++l_mct_data;\n        }\n\n        /* NOT FOUND */\n        if (i == l_tcp->m_nb_mct_records) {\n                if (l_tcp->m_nb_mct_records == l_tcp->m_nb_max_mct_records) {\n                        opj_mct_data_t *new_mct_records;\n                        l_tcp->m_nb_max_mct_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;\n\n                        new_mct_records = (opj_mct_data_t *) opj_realloc(l_tcp->m_mct_records, l_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t));\n                        if (! new_mct_records) {\n                                opj_free(l_tcp->m_mct_records);\n                                l_tcp->m_mct_records = NULL;\n                                l_tcp->m_nb_max_mct_records = 0;\n                                l_tcp->m_nb_mct_records = 0;\n                                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read MCT marker\\n\");\n                                return OPJ_FALSE;\n                        }\n                        l_tcp->m_mct_records = new_mct_records;\n                        l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;\n                        memset(l_mct_data ,0,(l_tcp->m_nb_max_mct_records - l_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t));\n                }\n\n                l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;\n                ++l_tcp->m_nb_mct_records;\n        }\n\n        if (l_mct_data->m_data) {\n                opj_free(l_mct_data->m_data);\n                l_mct_data->m_data = 00;\n        }\n\n        l_mct_data->m_index = l_indix;\n        l_mct_data->m_array_type = (J2K_MCT_ARRAY_TYPE)((l_tmp  >> 8) & 3);\n        l_mct_data->m_element_type = (J2K_MCT_ELEMENT_TYPE)((l_tmp  >> 10) & 3);\n\n        opj_read_bytes(p_header_data,&l_tmp,2);                         /* Ymct */\n        p_header_data+=2;\n        if (l_tmp != 0) {\n                opj_event_msg(p_manager, EVT_WARNING, \"Cannot take in charge multiple MCT markers\\n\");\n                return OPJ_TRUE;\n        }\n\n        p_header_size -= 6;\n\n        l_mct_data->m_data = (OPJ_BYTE*)opj_malloc(p_header_size);\n        if (! l_mct_data->m_data) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCT marker\\n\");\n                return OPJ_FALSE;\n        }\n        memcpy(l_mct_data->m_data,p_header_data,p_header_size);\n\n        l_mct_data->m_data_size = p_header_size;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_mcc_record(      opj_j2k_t *p_j2k,\n                                                                struct opj_simple_mcc_decorrelation_data * p_mcc_record,\n                                                                struct opj_stream_private *p_stream,\n                                                                struct opj_event_mgr * p_manager )\n{\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_mcc_size;\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_nb_bytes_for_comp;\n        OPJ_UINT32 l_mask;\n        OPJ_UINT32 l_tmcc;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        if (p_mcc_record->m_nb_comps > 255 ) {\n        l_nb_bytes_for_comp = 2;\n                l_mask = 0x8000;\n        }\n        else {\n                l_nb_bytes_for_comp = 1;\n                l_mask = 0;\n        }\n\n        l_mcc_size = p_mcc_record->m_nb_comps * 2 * l_nb_bytes_for_comp + 19;\n        if (l_mcc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size)\n        {\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mcc_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write MCC marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mcc_size;\n        }\n\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        opj_write_bytes(l_current_data,J2K_MS_MCC,2);                                   /* MCC */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_mcc_size-2,2);                                 /* Lmcc */\n        l_current_data += 2;\n\n        /* first marker */\n        opj_write_bytes(l_current_data,0,2);                                    /* Zmcc */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,p_mcc_record->m_index,1);                                        /* Imcc -> no need for other values, take the first */\n        ++l_current_data;\n\n        /* only one marker atm */\n        opj_write_bytes(l_current_data,0,2);                                    /* Ymcc */\n        l_current_data+=2;\n\n        opj_write_bytes(l_current_data,1,2);                                    /* Qmcc -> number of collections -> 1 */\n        l_current_data+=2;\n\n        opj_write_bytes(l_current_data,0x1,1);                                  /* Xmcci type of component transformation -> array based decorrelation */\n        ++l_current_data;\n\n        opj_write_bytes(l_current_data,p_mcc_record->m_nb_comps | l_mask,2);    /* Nmcci number of input components involved and size for each component offset = 8 bits */\n        l_current_data+=2;\n\n        for (i=0;i<p_mcc_record->m_nb_comps;++i) {\n                opj_write_bytes(l_current_data,i,l_nb_bytes_for_comp);                          /* Cmccij Component offset*/\n                l_current_data+=l_nb_bytes_for_comp;\n        }\n\n        opj_write_bytes(l_current_data,p_mcc_record->m_nb_comps|l_mask,2);      /* Mmcci number of output components involved and size for each component offset = 8 bits */\n        l_current_data+=2;\n\n        for (i=0;i<p_mcc_record->m_nb_comps;++i)\n        {\n                opj_write_bytes(l_current_data,i,l_nb_bytes_for_comp);                          /* Wmccij Component offset*/\n                l_current_data+=l_nb_bytes_for_comp;\n        }\n\n        l_tmcc = ((!p_mcc_record->m_is_irreversible) & 1U) << 16;\n\n        if (p_mcc_record->m_decorrelation_array) {\n                l_tmcc |= p_mcc_record->m_decorrelation_array->m_index;\n        }\n\n        if (p_mcc_record->m_offset_array) {\n                l_tmcc |= ((p_mcc_record->m_offset_array->m_index)<<8);\n        }\n\n        opj_write_bytes(l_current_data,l_tmcc,3);       /* Tmcci : use MCT defined as number 1 and irreversible array based. */\n        l_current_data+=3;\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_mcc_size,p_manager) != l_mcc_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_mcc (     opj_j2k_t *p_j2k,\n                                                OPJ_BYTE * p_header_data,\n                                                OPJ_UINT32 p_header_size,\n                                                opj_event_mgr_t * p_manager )\n{\n        OPJ_UINT32 i,j;\n        OPJ_UINT32 l_tmp;\n        OPJ_UINT32 l_indix;\n        opj_tcp_t * l_tcp;\n        opj_simple_mcc_decorrelation_data_t * l_mcc_record;\n        opj_mct_data_t * l_mct_data;\n        OPJ_UINT32 l_nb_collections;\n        OPJ_UINT32 l_nb_comps;\n        OPJ_UINT32 l_nb_bytes_by_comp;\n        OPJ_BOOL l_new_mcc = OPJ_FALSE;\n\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?\n                        &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number] :\n                        p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n        if (p_header_size < 2) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        /* first marker */\n        opj_read_bytes(p_header_data,&l_tmp,2);                         /* Zmcc */\n        p_header_data += 2;\n        if (l_tmp != 0) {\n                opj_event_msg(p_manager, EVT_WARNING, \"Cannot take in charge multiple data spanning\\n\");\n                return OPJ_TRUE;\n        }\n\n        if (p_header_size < 7) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(p_header_data,&l_indix,1); /* Imcc -> no need for other values, take the first */\n        ++p_header_data;\n\n        l_mcc_record = l_tcp->m_mcc_records;\n\n        for(i=0;i<l_tcp->m_nb_mcc_records;++i) {\n                if (l_mcc_record->m_index == l_indix) {\n                        break;\n                }\n                ++l_mcc_record;\n        }\n\n        /** NOT FOUND */\n        if (i == l_tcp->m_nb_mcc_records) {\n                if (l_tcp->m_nb_mcc_records == l_tcp->m_nb_max_mcc_records) {\n                        opj_simple_mcc_decorrelation_data_t *new_mcc_records;\n                        l_tcp->m_nb_max_mcc_records += OPJ_J2K_MCC_DEFAULT_NB_RECORDS;\n\n                        new_mcc_records = (opj_simple_mcc_decorrelation_data_t *) opj_realloc(\n                                        l_tcp->m_mcc_records, l_tcp->m_nb_max_mcc_records * sizeof(opj_simple_mcc_decorrelation_data_t));\n                        if (! new_mcc_records) {\n                                opj_free(l_tcp->m_mcc_records);\n                                l_tcp->m_mcc_records = NULL;\n                                l_tcp->m_nb_max_mcc_records = 0;\n                                l_tcp->m_nb_mcc_records = 0;\n                                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read MCC marker\\n\");\n                                return OPJ_FALSE;\n                        }\n                        l_tcp->m_mcc_records = new_mcc_records;\n                        l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;\n                        memset(l_mcc_record,0,(l_tcp->m_nb_max_mcc_records-l_tcp->m_nb_mcc_records) * sizeof(opj_simple_mcc_decorrelation_data_t));\n                }\n                l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;\n                l_new_mcc = OPJ_TRUE;\n        }\n        l_mcc_record->m_index = l_indix;\n\n        /* only one marker atm */\n        opj_read_bytes(p_header_data,&l_tmp,2);                         /* Ymcc */\n        p_header_data+=2;\n        if (l_tmp != 0) {\n                opj_event_msg(p_manager, EVT_WARNING, \"Cannot take in charge multiple data spanning\\n\");\n                return OPJ_TRUE;\n        }\n\n        opj_read_bytes(p_header_data,&l_nb_collections,2);                              /* Qmcc -> number of collections -> 1 */\n        p_header_data+=2;\n\n        if (l_nb_collections > 1) {\n                opj_event_msg(p_manager, EVT_WARNING, \"Cannot take in charge multiple collections\\n\");\n                return OPJ_TRUE;\n        }\n\n        p_header_size -= 7;\n\n        for (i=0;i<l_nb_collections;++i) {\n                if (p_header_size < 3) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n                        return OPJ_FALSE;\n                }\n\n                opj_read_bytes(p_header_data,&l_tmp,1); /* Xmcci type of component transformation -> array based decorrelation */\n                ++p_header_data;\n\n                if (l_tmp != 1) {\n                        opj_event_msg(p_manager, EVT_WARNING, \"Cannot take in charge collections other than array decorrelation\\n\");\n                        return OPJ_TRUE;\n                }\n\n                opj_read_bytes(p_header_data,&l_nb_comps,2);\n\n                p_header_data+=2;\n                p_header_size-=3;\n\n                l_nb_bytes_by_comp = 1 + (l_nb_comps>>15);\n                l_mcc_record->m_nb_comps = l_nb_comps & 0x7fff;\n\n                if (p_header_size < (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2)) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n                        return OPJ_FALSE;\n                }\n\n                p_header_size -= (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2);\n\n                for (j=0;j<l_mcc_record->m_nb_comps;++j) {\n                        opj_read_bytes(p_header_data,&l_tmp,l_nb_bytes_by_comp);        /* Cmccij Component offset*/\n                        p_header_data+=l_nb_bytes_by_comp;\n\n                        if (l_tmp != j) {\n                                opj_event_msg(p_manager, EVT_WARNING, \"Cannot take in charge collections with indix shuffle\\n\");\n                                return OPJ_TRUE;\n                        }\n                }\n\n                opj_read_bytes(p_header_data,&l_nb_comps,2);\n                p_header_data+=2;\n\n                l_nb_bytes_by_comp = 1 + (l_nb_comps>>15);\n                l_nb_comps &= 0x7fff;\n\n                if (l_nb_comps != l_mcc_record->m_nb_comps) {\n                        opj_event_msg(p_manager, EVT_WARNING, \"Cannot take in charge collections without same number of indixes\\n\");\n                        return OPJ_TRUE;\n                }\n\n                if (p_header_size < (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3)) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n                        return OPJ_FALSE;\n                }\n\n                p_header_size -= (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3);\n\n                for (j=0;j<l_mcc_record->m_nb_comps;++j) {\n                        opj_read_bytes(p_header_data,&l_tmp,l_nb_bytes_by_comp);        /* Wmccij Component offset*/\n                        p_header_data+=l_nb_bytes_by_comp;\n\n                        if (l_tmp != j) {\n                                opj_event_msg(p_manager, EVT_WARNING, \"Cannot take in charge collections with indix shuffle\\n\");\n                                return OPJ_TRUE;\n                        }\n                }\n\n                opj_read_bytes(p_header_data,&l_tmp,3); /* Wmccij Component offset*/\n                p_header_data += 3;\n\n                l_mcc_record->m_is_irreversible = ! ((l_tmp>>16) & 1);\n                l_mcc_record->m_decorrelation_array = 00;\n                l_mcc_record->m_offset_array = 00;\n\n                l_indix = l_tmp & 0xff;\n                if (l_indix != 0) {\n                        l_mct_data = l_tcp->m_mct_records;\n                        for (j=0;j<l_tcp->m_nb_mct_records;++j) {\n                                if (l_mct_data->m_index == l_indix) {\n                                        l_mcc_record->m_decorrelation_array = l_mct_data;\n                                        break;\n                                }\n                                ++l_mct_data;\n                        }\n\n                        if (l_mcc_record->m_decorrelation_array == 00) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n                                return OPJ_FALSE;\n                        }\n                }\n\n                l_indix = (l_tmp >> 8) & 0xff;\n                if (l_indix != 0) {\n                        l_mct_data = l_tcp->m_mct_records;\n                        for (j=0;j<l_tcp->m_nb_mct_records;++j) {\n                                if (l_mct_data->m_index == l_indix) {\n                                        l_mcc_record->m_offset_array = l_mct_data;\n                                        break;\n                                }\n                                ++l_mct_data;\n                        }\n\n                        if (l_mcc_record->m_offset_array == 00) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n                                return OPJ_FALSE;\n                        }\n                }\n        }\n\n        if (p_header_size != 0) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (l_new_mcc) {\n                ++l_tcp->m_nb_mcc_records;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_mco(     opj_j2k_t *p_j2k,\n                                                struct opj_stream_private *p_stream,\n                                                struct opj_event_mgr * p_manager\n                                  )\n{\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_mco_size;\n        opj_tcp_t * l_tcp = 00;\n        opj_simple_mcc_decorrelation_data_t * l_mcc_record;\n        OPJ_UINT32 i;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_tcp =&(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);\n\t\n        l_mco_size = 5 + l_tcp->m_nb_mcc_records;\n        if (l_mco_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mco_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write MCO marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mco_size;\n        }\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n\n        opj_write_bytes(l_current_data,J2K_MS_MCO,2);                   /* MCO */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_mco_size-2,2);                 /* Lmco */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_tcp->m_nb_mcc_records,1);      /* Nmco : only one transform stage*/\n        ++l_current_data;\n\n        l_mcc_record = l_tcp->m_mcc_records;\n        for (i=0;i<l_tcp->m_nb_mcc_records;++i) {\n                opj_write_bytes(l_current_data,l_mcc_record->m_index,1);/* Imco -> use the mcc indicated by 1*/\n                ++l_current_data;\n                ++l_mcc_record;\n        }\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_mco_size,p_manager) != l_mco_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a MCO marker (Multiple Component Transform Ordering)\n *\n * @param       p_header_data   the data contained in the MCO box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the MCO marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_mco (      opj_j2k_t *p_j2k,\n                                                                    OPJ_BYTE * p_header_data,\n                                                                    OPJ_UINT32 p_header_size,\n                                                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_UINT32 l_tmp, i;\n        OPJ_UINT32 l_nb_stages;\n        opj_tcp_t * l_tcp;\n        opj_tccp_t * l_tccp;\n        opj_image_t * l_image;\n\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_image = p_j2k->m_private_image;\n        l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?\n                        &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number] :\n                        p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n        if (p_header_size < 1) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCO marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(p_header_data,&l_nb_stages,1);                           /* Nmco : only one transform stage*/\n        ++p_header_data;\n\n        if (l_nb_stages > 1) {\n                opj_event_msg(p_manager, EVT_WARNING, \"Cannot take in charge multiple transformation stages.\\n\");\n                return OPJ_TRUE;\n        }\n\n        if (p_header_size != l_nb_stages + 1) {\n                opj_event_msg(p_manager, EVT_WARNING, \"Error reading MCO marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        l_tccp = l_tcp->tccps;\n\n        for (i=0;i<l_image->numcomps;++i) {\n                l_tccp->m_dc_level_shift = 0;\n                ++l_tccp;\n        }\n\n        if (l_tcp->m_mct_decoding_matrix) {\n                opj_free(l_tcp->m_mct_decoding_matrix);\n                l_tcp->m_mct_decoding_matrix = 00;\n        }\n\n        for (i=0;i<l_nb_stages;++i) {\n                opj_read_bytes(p_header_data,&l_tmp,1);\n                ++p_header_data;\n\n                if (! opj_j2k_add_mct(l_tcp,p_j2k->m_private_image,l_tmp)) {\n                        return OPJ_FALSE;\n                }\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_add_mct(opj_tcp_t * p_tcp, opj_image_t * p_image, OPJ_UINT32 p_index)\n{\n        OPJ_UINT32 i;\n        opj_simple_mcc_decorrelation_data_t * l_mcc_record;\n        opj_mct_data_t * l_deco_array, * l_offset_array;\n        OPJ_UINT32 l_data_size,l_mct_size, l_offset_size;\n        OPJ_UINT32 l_nb_elem;\n        OPJ_UINT32 * l_offset_data, * l_current_offset_data;\n        opj_tccp_t * l_tccp;\n\n        /* preconditions */\n        assert(p_tcp != 00);\n\n        l_mcc_record = p_tcp->m_mcc_records;\n\n        for (i=0;i<p_tcp->m_nb_mcc_records;++i) {\n                if (l_mcc_record->m_index == p_index) {\n                        break;\n                }\n        }\n\n        if (i==p_tcp->m_nb_mcc_records) {\n                /** element discarded **/\n                return OPJ_TRUE;\n        }\n\n        if (l_mcc_record->m_nb_comps != p_image->numcomps) {\n                /** do not support number of comps != image */\n                return OPJ_TRUE;\n        }\n\n        l_deco_array = l_mcc_record->m_decorrelation_array;\n\n        if (l_deco_array) {\n                l_data_size = MCT_ELEMENT_SIZE[l_deco_array->m_element_type] * p_image->numcomps * p_image->numcomps;\n                if (l_deco_array->m_data_size != l_data_size) {\n                        return OPJ_FALSE;\n                }\n\n                l_nb_elem = p_image->numcomps * p_image->numcomps;\n                l_mct_size = l_nb_elem * (OPJ_UINT32)sizeof(OPJ_FLOAT32);\n                p_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32*)opj_malloc(l_mct_size);\n\n                if (! p_tcp->m_mct_decoding_matrix ) {\n                        return OPJ_FALSE;\n                }\n\n                j2k_mct_read_functions_to_float[l_deco_array->m_element_type](l_deco_array->m_data,p_tcp->m_mct_decoding_matrix,l_nb_elem);\n        }\n\n        l_offset_array = l_mcc_record->m_offset_array;\n\n        if (l_offset_array) {\n                l_data_size = MCT_ELEMENT_SIZE[l_offset_array->m_element_type] * p_image->numcomps;\n                if (l_offset_array->m_data_size != l_data_size) {\n                        return OPJ_FALSE;\n                }\n\n                l_nb_elem = p_image->numcomps;\n                l_offset_size = l_nb_elem * (OPJ_UINT32)sizeof(OPJ_UINT32);\n                l_offset_data = (OPJ_UINT32*)opj_malloc(l_offset_size);\n\n                if (! l_offset_data ) {\n                        return OPJ_FALSE;\n                }\n\n                j2k_mct_read_functions_to_int32[l_offset_array->m_element_type](l_offset_array->m_data,l_offset_data,l_nb_elem);\n\n                l_tccp = p_tcp->tccps;\n                l_current_offset_data = l_offset_data;\n\n                for (i=0;i<p_image->numcomps;++i) {\n                        l_tccp->m_dc_level_shift = (OPJ_INT32)*(l_current_offset_data++);\n                        ++l_tccp;\n                }\n\n                opj_free(l_offset_data);\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_cbd( opj_j2k_t *p_j2k,\n                                                struct opj_stream_private *p_stream,\n                                                struct opj_event_mgr * p_manager )\n{\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_cbd_size;\n        OPJ_BYTE * l_current_data = 00;\n        opj_image_t *l_image = 00;\n        opj_image_comp_t * l_comp = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_image = p_j2k->m_private_image;\n        l_cbd_size = 6 + p_j2k->m_private_image->numcomps;\n\n        if (l_cbd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_cbd_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write CBD marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_cbd_size;\n        }\n\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        opj_write_bytes(l_current_data,J2K_MS_CBD,2);                   /* CBD */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_cbd_size-2,2);                 /* L_CBD */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_image->numcomps, 2);           /* Ncbd */\n        l_current_data+=2;\n\n        l_comp = l_image->comps;\n\n        for (i=0;i<l_image->numcomps;++i) {\n                opj_write_bytes(l_current_data, (l_comp->sgnd << 7) | (l_comp->prec - 1), 1);           /* Component bit depth */\n                ++l_current_data;\n\n                ++l_comp;\n        }\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_cbd_size,p_manager) != l_cbd_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a CBD marker (Component bit depth definition)\n * @param       p_header_data   the data contained in the CBD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the CBD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_cbd (      opj_j2k_t *p_j2k,\n                                                                OPJ_BYTE * p_header_data,\n                                                                OPJ_UINT32 p_header_size,\n                                                                opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_UINT32 l_nb_comp,l_num_comp;\n        OPJ_UINT32 l_comp_def;\n        OPJ_UINT32 i;\n        opj_image_comp_t * l_comp = 00;\n\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_num_comp = p_j2k->m_private_image->numcomps;\n\n        if (p_header_size != (p_j2k->m_private_image->numcomps + 2)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Crror reading CBD marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(p_header_data,&l_nb_comp,2);                             /* Ncbd */\n        p_header_data+=2;\n\n        if (l_nb_comp != l_num_comp) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Crror reading CBD marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        l_comp = p_j2k->m_private_image->comps;\n        for (i=0;i<l_num_comp;++i) {\n                opj_read_bytes(p_header_data,&l_comp_def,1);                    /* Component bit depth */\n                ++p_header_data;\n        l_comp->sgnd = (l_comp_def>>7) & 1;\n                l_comp->prec = (l_comp_def&0x7f) + 1;\n                ++l_comp;\n        }\n\n        return OPJ_TRUE;\n}\n\n/* ----------------------------------------------------------------------- */\n/* J2K / JPT decoder interface                                             */\n/* ----------------------------------------------------------------------- */\n\nvoid opj_j2k_setup_decoder(opj_j2k_t *j2k, opj_dparameters_t *parameters)\n{\n        if(j2k && parameters) {\n                j2k->m_cp.m_specific_param.m_dec.m_layer = parameters->cp_layer;\n                j2k->m_cp.m_specific_param.m_dec.m_reduce = parameters->cp_reduce;\n\n#ifdef USE_JPWL\n                j2k->m_cp.correct = parameters->jpwl_correct;\n                j2k->m_cp.exp_comps = parameters->jpwl_exp_comps;\n                j2k->m_cp.max_tiles = parameters->jpwl_max_tiles;\n#endif /* USE_JPWL */\n        }\n}\n\nOPJ_BOOL opj_j2k_set_threads(opj_j2k_t *j2k, OPJ_UINT32 num_threads)\n{\n        if( opj_has_thread_support() )\n        {\n            opj_thread_pool_destroy(j2k->m_tp);\n            j2k->m_tp = NULL;\n            if (num_threads <= (OPJ_UINT32)INT_MAX ) {\n                j2k->m_tp = opj_thread_pool_create((int)num_threads);\n            }\n            if( j2k->m_tp == NULL )\n            {\n                j2k->m_tp = opj_thread_pool_create(0);\n                return OPJ_FALSE;\n            }\n            return OPJ_TRUE;\n        }\n        return OPJ_FALSE;\n}\n\nstatic int opj_j2k_get_default_thread_count()\n{\n    const char* num_threads = getenv(\"OPJ_NUM_THREADS\");\n    if( num_threads == NULL || !opj_has_thread_support() )\n        return 0;\n    if( strcmp(num_threads, \"ALL_CPUS\") == 0 )\n        return opj_get_num_cpus();\n    return atoi(num_threads);\n}\n\n/* ----------------------------------------------------------------------- */\n/* J2K encoder interface                                                       */\n/* ----------------------------------------------------------------------- */\n\nopj_j2k_t* opj_j2k_create_compress(void)\n{\n        opj_j2k_t *l_j2k = (opj_j2k_t*) opj_calloc(1,sizeof(opj_j2k_t));\n        if (!l_j2k) {\n                return NULL;\n        }\n\n\n        l_j2k->m_is_decoder = 0;\n        l_j2k->m_cp.m_is_decoder = 0;\n\n        l_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *) opj_malloc(OPJ_J2K_DEFAULT_HEADER_SIZE);\n        if (! l_j2k->m_specific_param.m_encoder.m_header_tile_data) {\n                opj_j2k_destroy(l_j2k);\n                return NULL;\n        }\n\n        l_j2k->m_specific_param.m_encoder.m_header_tile_data_size = OPJ_J2K_DEFAULT_HEADER_SIZE;\n\n        /* validation list creation*/\n        l_j2k->m_validation_list = opj_procedure_list_create();\n        if (! l_j2k->m_validation_list) {\n                opj_j2k_destroy(l_j2k);\n                return NULL;\n        }\n\n        /* execution list creation*/\n        l_j2k->m_procedure_list = opj_procedure_list_create();\n        if (! l_j2k->m_procedure_list) {\n                opj_j2k_destroy(l_j2k);\n                return NULL;\n        }\n\n        l_j2k->m_tp = opj_thread_pool_create(opj_j2k_get_default_thread_count());\n        if( !l_j2k->m_tp )\n        {\n            l_j2k->m_tp = opj_thread_pool_create(0);\n        }\n        if( !l_j2k->m_tp )\n        {\n            opj_j2k_destroy(l_j2k);\n            return NULL;\n        }\n\n        return l_j2k;\n}\n\nstatic int opj_j2k_initialise_4K_poc(opj_poc_t *POC, int numres){\n    POC[0].tile  = 1;\n    POC[0].resno0  = 0;\n    POC[0].compno0 = 0;\n    POC[0].layno1  = 1;\n    POC[0].resno1  = (OPJ_UINT32)(numres-1);\n    POC[0].compno1 = 3;\n    POC[0].prg1 = OPJ_CPRL;\n    POC[1].tile  = 1;\n    POC[1].resno0  = (OPJ_UINT32)(numres-1);\n    POC[1].compno0 = 0;\n    POC[1].layno1  = 1;\n    POC[1].resno1  = (OPJ_UINT32)numres;\n    POC[1].compno1 = 3;\n    POC[1].prg1 = OPJ_CPRL;\n    return 2;\n}\n\nstatic void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters, opj_image_t *image, opj_event_mgr_t *p_manager)\n{\n    /* Configure cinema parameters */\n    int i;\n\n    /* No tiling */\n    parameters->tile_size_on = OPJ_FALSE;\n    parameters->cp_tdx=1;\n    parameters->cp_tdy=1;\n\n    /* One tile part for each component */\n    parameters->tp_flag = 'C';\n    parameters->tp_on = 1;\n\n    /* Tile and Image shall be at (0,0) */\n    parameters->cp_tx0 = 0;\n    parameters->cp_ty0 = 0;\n    parameters->image_offset_x0 = 0;\n    parameters->image_offset_y0 = 0;\n\n    /* Codeblock size= 32*32 */\n    parameters->cblockw_init = 32;\n    parameters->cblockh_init = 32;\n\n    /* Codeblock style: no mode switch enabled */\n    parameters->mode = 0;\n\n    /* No ROI */\n    parameters->roi_compno = -1;\n\n    /* No subsampling */\n    parameters->subsampling_dx = 1;\n    parameters->subsampling_dy = 1;\n\n    /* 9-7 transform */\n    parameters->irreversible = 1;\n\n    /* Number of layers */\n    if (parameters->tcp_numlayers > 1){\n        opj_event_msg(p_manager, EVT_WARNING,\n                \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                \"1 single quality layer\"\n                \"-> Number of layers forced to 1 (rather than %d)\\n\"\n                \"-> Rate of the last layer (%3.1f) will be used\",\n                parameters->tcp_numlayers, parameters->tcp_rates[parameters->tcp_numlayers-1]);\n        parameters->tcp_rates[0] = parameters->tcp_rates[parameters->tcp_numlayers-1];\n        parameters->tcp_numlayers = 1;\n    }\n\n    /* Resolution levels */\n    switch (parameters->rsiz){\n    case OPJ_PROFILE_CINEMA_2K:\n        if(parameters->numresolution > 6){\n            opj_event_msg(p_manager, EVT_WARNING,\n                    \"JPEG 2000 Profile-3 (2k dc profile) requires:\\n\"\n                    \"Number of decomposition levels <= 5\\n\"\n                    \"-> Number of decomposition levels forced to 5 (rather than %d)\\n\",\n                    parameters->numresolution+1);\n            parameters->numresolution = 6;\n        }\n        break;\n    case OPJ_PROFILE_CINEMA_4K:\n        if(parameters->numresolution < 2){\n            opj_event_msg(p_manager, EVT_WARNING,\n                    \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                    \"Number of decomposition levels >= 1 && <= 6\\n\"\n                    \"-> Number of decomposition levels forced to 1 (rather than %d)\\n\",\n                    parameters->numresolution+1);\n            parameters->numresolution = 1;\n        }else if(parameters->numresolution > 7){\n            opj_event_msg(p_manager, EVT_WARNING,\n                    \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                    \"Number of decomposition levels >= 1 && <= 6\\n\"\n                    \"-> Number of decomposition levels forced to 6 (rather than %d)\\n\",\n                    parameters->numresolution+1);\n            parameters->numresolution = 7;\n        }\n        break;\n    default :\n        break;\n    }\n\n    /* Precincts */\n    parameters->csty |= 0x01;\n    parameters->res_spec = parameters->numresolution-1;\n    for (i = 0; i<parameters->res_spec; i++) {\n        parameters->prcw_init[i] = 256;\n        parameters->prch_init[i] = 256;\n    }\n\n    /* The progression order shall be CPRL */\n    parameters->prog_order = OPJ_CPRL;\n\n    /* Progression order changes for 4K, disallowed for 2K */\n    if (parameters->rsiz == OPJ_PROFILE_CINEMA_4K) {\n        parameters->numpocs = (OPJ_UINT32)opj_j2k_initialise_4K_poc(parameters->POC,parameters->numresolution);\n    } else {\n        parameters->numpocs = 0;\n    }\n\n    /* Limited bit-rate */\n    parameters->cp_disto_alloc = 1;\n    if (parameters->max_cs_size <= 0) {\n        /* No rate has been introduced, 24 fps is assumed */\n        parameters->max_cs_size = OPJ_CINEMA_24_CS;\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1302083 compressed bytes @ 24fps\\n\"\n                      \"As no rate has been given, this limit will be used.\\n\");\n    } else if (parameters->max_cs_size > OPJ_CINEMA_24_CS) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1302083 compressed bytes @ 24fps\\n\"\n                      \"-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\\n\");\n        parameters->max_cs_size = OPJ_CINEMA_24_CS;\n    }\n\n    if (parameters->max_comp_size <= 0) {\n        /* No rate has been introduced, 24 fps is assumed */\n        parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1041666 compressed bytes @ 24fps\\n\"\n                      \"As no rate has been given, this limit will be used.\\n\");\n    } else if (parameters->max_comp_size > OPJ_CINEMA_24_COMP) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1041666 compressed bytes @ 24fps\\n\"\n                      \"-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\\n\");\n        parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n    }\n\n    parameters->tcp_rates[0] = (OPJ_FLOAT32) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec)/\n            (OPJ_FLOAT32)(((OPJ_UINT32)parameters->max_cs_size) * 8 * image->comps[0].dx * image->comps[0].dy);\n\n}\n\nstatic OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image, OPJ_UINT16 rsiz, opj_event_mgr_t *p_manager)\n{\n    OPJ_UINT32 i;\n\n    /* Number of components */\n    if (image->numcomps != 3){\n        opj_event_msg(p_manager, EVT_WARNING,\n                \"JPEG 2000 Profile-3 (2k dc profile) requires:\\n\"\n                \"3 components\"\n                \"-> Number of components of input image (%d) is not compliant\\n\"\n                \"-> Non-profile-3 codestream will be generated\\n\",\n                image->numcomps);\n        return OPJ_FALSE;\n    }\n\n    /* Bitdepth */\n    for (i = 0; i < image->numcomps; i++) {\n        if ((image->comps[i].bpp != 12) | (image->comps[i].sgnd)){\n            char signed_str[] = \"signed\";\n            char unsigned_str[] = \"unsigned\";\n            char *tmp_str = image->comps[i].sgnd?signed_str:unsigned_str;\n            opj_event_msg(p_manager, EVT_WARNING,\n                    \"JPEG 2000 Profile-3 (2k dc profile) requires:\\n\"\n                    \"Precision of each component shall be 12 bits unsigned\"\n                    \"-> At least component %d of input image (%d bits, %s) is not compliant\\n\"\n                    \"-> Non-profile-3 codestream will be generated\\n\",\n                    i,image->comps[i].bpp, tmp_str);\n            return OPJ_FALSE;\n        }\n    }\n\n    /* Image size */\n    switch (rsiz){\n    case OPJ_PROFILE_CINEMA_2K:\n        if (((image->comps[0].w > 2048) | (image->comps[0].h > 1080))){\n            opj_event_msg(p_manager, EVT_WARNING,\n                    \"JPEG 2000 Profile-3 (2k dc profile) requires:\\n\"\n                    \"width <= 2048 and height <= 1080\\n\"\n                    \"-> Input image size %d x %d is not compliant\\n\"\n                    \"-> Non-profile-3 codestream will be generated\\n\",\n                    image->comps[0].w,image->comps[0].h);\n            return OPJ_FALSE;\n        }\n        break;\n    case OPJ_PROFILE_CINEMA_4K:\n        if (((image->comps[0].w > 4096) | (image->comps[0].h > 2160))){\n            opj_event_msg(p_manager, EVT_WARNING,\n                    \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                    \"width <= 4096 and height <= 2160\\n\"\n                    \"-> Image size %d x %d is not compliant\\n\"\n                    \"-> Non-profile-4 codestream will be generated\\n\",\n                    image->comps[0].w,image->comps[0].h);\n            return OPJ_FALSE;\n        }\n        break;\n    default :\n        break;\n    }\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_setup_encoder(     opj_j2k_t *p_j2k,\n                                                    opj_cparameters_t *parameters,\n                                                    opj_image_t *image,\n                                                    opj_event_mgr_t * p_manager)\n{\n        OPJ_UINT32 i, j, tileno, numpocs_tile;\n        opj_cp_t *cp = 00;\n\n        if(!p_j2k || !parameters || ! image) {\n                return OPJ_FALSE;\n        }\n\n        if ((parameters->numresolution <= 0) || (parameters->numresolution > OPJ_J2K_MAXRLVLS)) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Invalid number of resolutions : %d not in range [1,%d]\\n\", parameters->numresolution, OPJ_J2K_MAXRLVLS);\n            return OPJ_FALSE;\n        }\n\n        /* keep a link to cp so that we can destroy it later in j2k_destroy_compress */\n        cp = &(p_j2k->m_cp);\n\n        /* set default values for cp */\n        cp->tw = 1;\n        cp->th = 1;\n\n        /* FIXME ADE: to be removed once deprecated cp_cinema and cp_rsiz have been removed */\n        if (parameters->rsiz == OPJ_PROFILE_NONE) { /* consider deprecated fields only if RSIZ has not been set */\n            OPJ_BOOL deprecated_used = OPJ_FALSE;\n            switch (parameters->cp_cinema){\n            case OPJ_CINEMA2K_24:\n                parameters->rsiz = OPJ_PROFILE_CINEMA_2K;\n                parameters->max_cs_size = OPJ_CINEMA_24_CS;\n                parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n                deprecated_used = OPJ_TRUE;\n                break;\n            case OPJ_CINEMA2K_48:\n                parameters->rsiz = OPJ_PROFILE_CINEMA_2K;\n                parameters->max_cs_size = OPJ_CINEMA_48_CS;\n                parameters->max_comp_size = OPJ_CINEMA_48_COMP;\n                deprecated_used = OPJ_TRUE;\n                break;\n            case OPJ_CINEMA4K_24:\n                parameters->rsiz = OPJ_PROFILE_CINEMA_4K;\n                parameters->max_cs_size = OPJ_CINEMA_24_CS;\n                parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n                deprecated_used = OPJ_TRUE;\n                break;\n            case OPJ_OFF:\n            default:\n                break;\n            }\n            switch (parameters->cp_rsiz){\n            case OPJ_CINEMA2K:\n                parameters->rsiz = OPJ_PROFILE_CINEMA_2K;\n                deprecated_used = OPJ_TRUE;\n                break;\n            case OPJ_CINEMA4K:\n                parameters->rsiz = OPJ_PROFILE_CINEMA_4K;\n                deprecated_used = OPJ_TRUE;\n                break;\n            case OPJ_MCT:\n                parameters->rsiz = OPJ_PROFILE_PART2 | OPJ_EXTENSION_MCT;\n                deprecated_used = OPJ_TRUE;\n            case OPJ_STD_RSIZ:\n            default:\n                break;\n            }\n            if (deprecated_used) {\n                opj_event_msg(p_manager, EVT_WARNING,\n                        \"Deprecated fields cp_cinema or cp_rsiz are used\\n\"\n                        \"Please consider using only the rsiz field\\n\"\n                        \"See openjpeg.h documentation for more details\\n\");\n            }\n        }\n\n        /* see if max_codestream_size does limit input rate */\n        if (parameters->max_cs_size <= 0) {\n            if (parameters->tcp_rates[parameters->tcp_numlayers-1] > 0) {\n                OPJ_FLOAT32 temp_size;\n                temp_size =(OPJ_FLOAT32)(image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec)/\n                        (parameters->tcp_rates[parameters->tcp_numlayers-1] * 8 * (OPJ_FLOAT32)image->comps[0].dx * (OPJ_FLOAT32)image->comps[0].dy);\n                parameters->max_cs_size = (int) floor(temp_size);\n            } else {\n                parameters->max_cs_size = 0;\n            }\n        } else {\n            OPJ_FLOAT32 temp_rate;\n            OPJ_BOOL cap = OPJ_FALSE;\n            temp_rate = (OPJ_FLOAT32) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec)/\n                    (OPJ_FLOAT32)(((OPJ_UINT32)parameters->max_cs_size) * 8 * image->comps[0].dx * image->comps[0].dy);\n            for (i = 0; i < (OPJ_UINT32) parameters->tcp_numlayers; i++) {\n                if (parameters->tcp_rates[i] < temp_rate) {\n                    parameters->tcp_rates[i] = temp_rate;\n                    cap = OPJ_TRUE;\n                }\n            }\n            if (cap) {\n                opj_event_msg(p_manager, EVT_WARNING,\n                        \"The desired maximum codestream size has limited\\n\"\n                        \"at least one of the desired quality layers\\n\");\n            }\n        }\n\n        /* Manage profiles and applications and set RSIZ */\n        /* set cinema parameters if required */\n        if (OPJ_IS_CINEMA(parameters->rsiz)){\n            if ((parameters->rsiz == OPJ_PROFILE_CINEMA_S2K)\n                    || (parameters->rsiz == OPJ_PROFILE_CINEMA_S4K)){\n                opj_event_msg(p_manager, EVT_WARNING,\n                        \"JPEG 2000 Scalable Digital Cinema profiles not yet supported\\n\");\n                parameters->rsiz = OPJ_PROFILE_NONE;\n            } else {\n                opj_j2k_set_cinema_parameters(parameters,image,p_manager);\n                if (!opj_j2k_is_cinema_compliant(image,parameters->rsiz,p_manager)) {\n                    parameters->rsiz = OPJ_PROFILE_NONE;\n                }\n            }\n        } else if (OPJ_IS_STORAGE(parameters->rsiz)) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                    \"JPEG 2000 Long Term Storage profile not yet supported\\n\");\n            parameters->rsiz = OPJ_PROFILE_NONE;\n        } else if (OPJ_IS_BROADCAST(parameters->rsiz)) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                    \"JPEG 2000 Broadcast profiles not yet supported\\n\");\n            parameters->rsiz = OPJ_PROFILE_NONE;\n        } else if (OPJ_IS_IMF(parameters->rsiz)) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                    \"JPEG 2000 IMF profiles not yet supported\\n\");\n            parameters->rsiz = OPJ_PROFILE_NONE;\n        } else if (OPJ_IS_PART2(parameters->rsiz)) {\n            if (parameters->rsiz == ((OPJ_PROFILE_PART2) | (OPJ_EXTENSION_NONE))) {\n                opj_event_msg(p_manager, EVT_WARNING,\n                              \"JPEG 2000 Part-2 profile defined\\n\"\n                              \"but no Part-2 extension enabled.\\n\"\n                              \"Profile set to NONE.\\n\");\n                parameters->rsiz = OPJ_PROFILE_NONE;\n            } else if (parameters->rsiz != ((OPJ_PROFILE_PART2) | (OPJ_EXTENSION_MCT))) {\n                opj_event_msg(p_manager, EVT_WARNING,\n                              \"Unsupported Part-2 extension enabled\\n\"\n                              \"Profile set to NONE.\\n\");\n                parameters->rsiz = OPJ_PROFILE_NONE;\n            }\n        }\n\n        /*\n        copy user encoding parameters\n        */\n        cp->m_specific_param.m_enc.m_max_comp_size = (OPJ_UINT32)parameters->max_comp_size;\n        cp->rsiz = parameters->rsiz;\n        cp->m_specific_param.m_enc.m_disto_alloc = (OPJ_UINT32)parameters->cp_disto_alloc & 1u;\n        cp->m_specific_param.m_enc.m_fixed_alloc = (OPJ_UINT32)parameters->cp_fixed_alloc & 1u;\n        cp->m_specific_param.m_enc.m_fixed_quality = (OPJ_UINT32)parameters->cp_fixed_quality & 1u;\n\n        /* mod fixed_quality */\n        if (parameters->cp_fixed_alloc && parameters->cp_matrice) {\n                size_t array_size = (size_t)parameters->tcp_numlayers * (size_t)parameters->numresolution * 3 * sizeof(OPJ_INT32);\n                cp->m_specific_param.m_enc.m_matrice = (OPJ_INT32 *) opj_malloc(array_size);\n\t\t\t\t\t\t\t\tif (!cp->m_specific_param.m_enc.m_matrice) {\n\t\t\t\t\t\t\t\t        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to allocate copy of user encoding parameters matrix \\n\");\n\t\t\t\t\t\t\t\t        return OPJ_FALSE;\n\t\t\t\t\t\t\t\t}\n                memcpy(cp->m_specific_param.m_enc.m_matrice, parameters->cp_matrice, array_size);\n        }\n\n        /* tiles */\n        cp->tdx = (OPJ_UINT32)parameters->cp_tdx;\n        cp->tdy = (OPJ_UINT32)parameters->cp_tdy;\n\n        /* tile offset */\n        cp->tx0 = (OPJ_UINT32)parameters->cp_tx0;\n        cp->ty0 = (OPJ_UINT32)parameters->cp_ty0;\n\n        /* comment string */\n        if(parameters->cp_comment) {\n                cp->comment = (char*)opj_malloc(strlen(parameters->cp_comment) + 1U);\n\t\t\t\t\t\t\t\tif(!cp->comment) {\n\t\t\t\t\t\t\t\t        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to allocate copy of comment string\\n\");\n\t\t\t\t\t\t\t\t        return OPJ_FALSE;\n\t\t\t\t\t\t\t\t}\n                strcpy(cp->comment, parameters->cp_comment);\n        } else {\n                /* Create default comment for codestream */\n                const char comment[] = \"Created by OpenJPEG version \";\n                const size_t clen = strlen(comment);\n                const char *version = opj_version();\n\n                /* UniPG>> */\n#ifdef USE_JPWL\n                cp->comment = (char*)opj_malloc(clen+strlen(version)+11);\n\t\t\t\t\t\t\t\tif(!cp->comment) {\n\t\t\t\t\t\t\t\t        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to allocate comment string\\n\");\n\t\t\t\t\t\t\t\t        return OPJ_FALSE;\n\t\t\t\t\t\t\t\t}\n                sprintf(cp->comment,\"%s%s with JPWL\", comment, version);\n#else\n                cp->comment = (char*)opj_malloc(clen+strlen(version)+1);\n\t\t\t\t\t\t\t\tif(!cp->comment) {\n\t\t\t\t\t\t\t\t        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to allocate comment string\\n\");\n\t\t\t\t\t\t\t\t        return OPJ_FALSE;\n\t\t\t\t\t\t\t\t}\n                sprintf(cp->comment,\"%s%s\", comment, version);\n#endif\n                /* <<UniPG */\n\t\t\t\t}\n\n        /*\n        calculate other encoding parameters\n        */\n\n        if (parameters->tile_size_on) {\n                cp->tw = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(image->x1 - cp->tx0), (OPJ_INT32)cp->tdx);\n                cp->th = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(image->y1 - cp->ty0), (OPJ_INT32)cp->tdy);\n        } else {\n                cp->tdx = image->x1 - cp->tx0;\n                cp->tdy = image->y1 - cp->ty0;\n        }\n\n        if (parameters->tp_on) {\n                cp->m_specific_param.m_enc.m_tp_flag = (OPJ_BYTE)parameters->tp_flag;\n                cp->m_specific_param.m_enc.m_tp_on = 1;\n        }\n\n#ifdef USE_JPWL\n        /*\n        calculate JPWL encoding parameters\n        */\n\n        if (parameters->jpwl_epc_on) {\n                OPJ_INT32 i;\n\n                /* set JPWL on */\n                cp->epc_on = OPJ_TRUE;\n                cp->info_on = OPJ_FALSE; /* no informative technique */\n\n                /* set EPB on */\n                if ((parameters->jpwl_hprot_MH > 0) || (parameters->jpwl_hprot_TPH[0] > 0)) {\n                        cp->epb_on = OPJ_TRUE;\n\n                        cp->hprot_MH = parameters->jpwl_hprot_MH;\n                        for (i = 0; i < JPWL_MAX_NO_TILESPECS; i++) {\n                                cp->hprot_TPH_tileno[i] = parameters->jpwl_hprot_TPH_tileno[i];\n                                cp->hprot_TPH[i] = parameters->jpwl_hprot_TPH[i];\n                        }\n                        /* if tile specs are not specified, copy MH specs */\n                        if (cp->hprot_TPH[0] == -1) {\n                                cp->hprot_TPH_tileno[0] = 0;\n                                cp->hprot_TPH[0] = parameters->jpwl_hprot_MH;\n                        }\n                        for (i = 0; i < JPWL_MAX_NO_PACKSPECS; i++) {\n                                cp->pprot_tileno[i] = parameters->jpwl_pprot_tileno[i];\n                                cp->pprot_packno[i] = parameters->jpwl_pprot_packno[i];\n                                cp->pprot[i] = parameters->jpwl_pprot[i];\n                        }\n                }\n\n                /* set ESD writing */\n                if ((parameters->jpwl_sens_size == 1) || (parameters->jpwl_sens_size == 2)) {\n                        cp->esd_on = OPJ_TRUE;\n\n                        cp->sens_size = parameters->jpwl_sens_size;\n                        cp->sens_addr = parameters->jpwl_sens_addr;\n                        cp->sens_range = parameters->jpwl_sens_range;\n\n                        cp->sens_MH = parameters->jpwl_sens_MH;\n                        for (i = 0; i < JPWL_MAX_NO_TILESPECS; i++) {\n                                cp->sens_TPH_tileno[i] = parameters->jpwl_sens_TPH_tileno[i];\n                                cp->sens_TPH[i] = parameters->jpwl_sens_TPH[i];\n                        }\n                }\n\n                /* always set RED writing to false: we are at the encoder */\n                cp->red_on = OPJ_FALSE;\n\n        } else {\n                cp->epc_on = OPJ_FALSE;\n        }\n#endif /* USE_JPWL */\n\n        /* initialize the mutiple tiles */\n        /* ---------------------------- */\n        cp->tcps = (opj_tcp_t*) opj_calloc(cp->tw * cp->th, sizeof(opj_tcp_t));\n        if (!cp->tcps) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to allocate tile coding parameters\\n\");\n                return OPJ_FALSE;\n        }\n        if (parameters->numpocs) {\n                /* initialisation of POC */\n                opj_j2k_check_poc_val(parameters->POC,parameters->numpocs, (OPJ_UINT32)parameters->numresolution, image->numcomps, (OPJ_UINT32)parameters->tcp_numlayers, p_manager);\n                /* TODO MSD use the return value*/\n        }\n\n        for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {\n                opj_tcp_t *tcp = &cp->tcps[tileno];\n                tcp->numlayers = (OPJ_UINT32)parameters->tcp_numlayers;\n\n                for (j = 0; j < tcp->numlayers; j++) {\n                        if(OPJ_IS_CINEMA(cp->rsiz)){\n                                if (cp->m_specific_param.m_enc.m_fixed_quality) {\n                                        tcp->distoratio[j] = parameters->tcp_distoratio[j];\n                                }\n                                tcp->rates[j] = parameters->tcp_rates[j];\n                        }else{\n                                if (cp->m_specific_param.m_enc.m_fixed_quality) {       /* add fixed_quality */\n                                        tcp->distoratio[j] = parameters->tcp_distoratio[j];\n                                } else {\n                                        tcp->rates[j] = parameters->tcp_rates[j];\n                                }\n                        }\n                }\n\n                tcp->csty = (OPJ_UINT32)parameters->csty;\n                tcp->prg = parameters->prog_order;\n                tcp->mct = (OPJ_UINT32)parameters->tcp_mct;\n\n                numpocs_tile = 0;\n                tcp->POC = 0;\n\n                if (parameters->numpocs) {\n                        /* initialisation of POC */\n                        tcp->POC = 1;\n                        for (i = 0; i < parameters->numpocs; i++) {\n                                if (tileno + 1 == parameters->POC[i].tile )  {\n                                        opj_poc_t *tcp_poc = &tcp->pocs[numpocs_tile];\n\n                                        tcp_poc->resno0         = parameters->POC[numpocs_tile].resno0;\n                                        tcp_poc->compno0        = parameters->POC[numpocs_tile].compno0;\n                                        tcp_poc->layno1         = parameters->POC[numpocs_tile].layno1;\n                                        tcp_poc->resno1         = parameters->POC[numpocs_tile].resno1;\n                                        tcp_poc->compno1        = parameters->POC[numpocs_tile].compno1;\n                                        tcp_poc->prg1           = parameters->POC[numpocs_tile].prg1;\n                                        tcp_poc->tile           = parameters->POC[numpocs_tile].tile;\n\n                                        numpocs_tile++;\n                                }\n                        }\n\n                        tcp->numpocs = numpocs_tile -1 ;\n                }else{\n                        tcp->numpocs = 0;\n                }\n\n                tcp->tccps = (opj_tccp_t*) opj_calloc(image->numcomps, sizeof(opj_tccp_t));\n                if (!tcp->tccps) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to allocate tile component coding parameters\\n\");\n                        return OPJ_FALSE;\n                }\n                if (parameters->mct_data) {\n                      \n                    OPJ_UINT32 lMctSize = image->numcomps * image->numcomps * (OPJ_UINT32)sizeof(OPJ_FLOAT32);\n                    OPJ_FLOAT32 * lTmpBuf = (OPJ_FLOAT32*)opj_malloc(lMctSize);\n                    OPJ_INT32 * l_dc_shift = (OPJ_INT32 *) ((OPJ_BYTE *) parameters->mct_data + lMctSize);\n\n\t\t\t\t\t\t\t\t\t\tif (!lTmpBuf) {\n                            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to allocate temp buffer\\n\");\n                            return OPJ_FALSE;\n                    }\n\n                    tcp->mct = 2;\n                    tcp->m_mct_coding_matrix = (OPJ_FLOAT32*)opj_malloc(lMctSize);\n\t\t\t\t\t\t\t\t\t\tif (! tcp->m_mct_coding_matrix) {\n                            opj_free(lTmpBuf);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlTmpBuf = NULL;\n                            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to allocate encoder MCT coding matrix \\n\");\n                            return OPJ_FALSE;\n                    }\n                    memcpy(tcp->m_mct_coding_matrix,parameters->mct_data,lMctSize);\n                    memcpy(lTmpBuf,parameters->mct_data,lMctSize);\n\n                    tcp->m_mct_decoding_matrix = (OPJ_FLOAT32*)opj_malloc(lMctSize);\n\t\t\t\t\t\t\t\t\t\tif (! tcp->m_mct_decoding_matrix) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\topj_free(lTmpBuf);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlTmpBuf = NULL;\n                            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to allocate encoder MCT decoding matrix \\n\");\n                            return OPJ_FALSE;\n                    }\n                    if(opj_matrix_inversion_f(lTmpBuf,(tcp->m_mct_decoding_matrix),image->numcomps) == OPJ_FALSE) {\n                            opj_free(lTmpBuf);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlTmpBuf = NULL;\n                            opj_event_msg(p_manager, EVT_ERROR, \"Failed to inverse encoder MCT decoding matrix \\n\");\n                            return OPJ_FALSE;\n\t\t\t\t\t\t\t\t\t\t}\n\n                    tcp->mct_norms = (OPJ_FLOAT64*)\n                                    opj_malloc(image->numcomps * sizeof(OPJ_FLOAT64));\n\t\t\t\t\t\t\t\t\t\tif (! tcp->mct_norms) {\n                            opj_free(lTmpBuf);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlTmpBuf = NULL;\n                            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to allocate encoder MCT norms \\n\");\n                            return OPJ_FALSE;\n                    }\n                    opj_calculate_norms(tcp->mct_norms,image->numcomps,tcp->m_mct_decoding_matrix);\n                    opj_free(lTmpBuf);\n\n                    for (i = 0; i < image->numcomps; i++) {\n                            opj_tccp_t *tccp = &tcp->tccps[i];\n                            tccp->m_dc_level_shift = l_dc_shift[i];\n                    }\n\n                    if (opj_j2k_setup_mct_encoding(tcp,image) == OPJ_FALSE) {\n                        /* free will be handled by opj_j2k_destroy */\n\t\t\t\t\t\t\t\t\t\t\t\topj_event_msg(p_manager, EVT_ERROR, \"Failed to setup j2k mct encoding\\n\");\n                        return OPJ_FALSE;\n                    }\n                }\n                else {\n                    if(tcp->mct==1 && image->numcomps >= 3) { /* RGB->YCC MCT is enabled */\n                        if ((image->comps[0].dx != image->comps[1].dx) ||\n                                (image->comps[0].dx != image->comps[2].dx) ||\n                                (image->comps[0].dy != image->comps[1].dy) ||\n                                (image->comps[0].dy != image->comps[2].dy)) {\n                            opj_event_msg(p_manager, EVT_WARNING, \"Cannot perform MCT on components with different sizes. Disabling MCT.\\n\");\n                            tcp->mct = 0;\n                        }\n                    }\n                        for (i = 0; i < image->numcomps; i++) {\n                                opj_tccp_t *tccp = &tcp->tccps[i];\n                                opj_image_comp_t * l_comp = &(image->comps[i]);\n\n                                if (! l_comp->sgnd) {\n                                        tccp->m_dc_level_shift = 1 << (l_comp->prec - 1);\n                                }\n                        }\n                }\n\n                for (i = 0; i < image->numcomps; i++) {\n                        opj_tccp_t *tccp = &tcp->tccps[i];\n\n                        tccp->csty = parameters->csty & 0x01;   /* 0 => one precinct || 1 => custom precinct  */\n                        tccp->numresolutions = (OPJ_UINT32)parameters->numresolution;\n                        tccp->cblkw = (OPJ_UINT32)opj_int_floorlog2(parameters->cblockw_init);\n                        tccp->cblkh = (OPJ_UINT32)opj_int_floorlog2(parameters->cblockh_init);\n                        tccp->cblksty = (OPJ_UINT32)parameters->mode;\n                        tccp->qmfbid = parameters->irreversible ? 0 : 1;\n                        tccp->qntsty = parameters->irreversible ? J2K_CCP_QNTSTY_SEQNT : J2K_CCP_QNTSTY_NOQNT;\n                        tccp->numgbits = 2;\n\n                        if ((OPJ_INT32)i == parameters->roi_compno) {\n                                tccp->roishift = parameters->roi_shift;\n                        } else {\n                                tccp->roishift = 0;\n                        }\n\n                                if (parameters->csty & J2K_CCP_CSTY_PRT) {\n                                        OPJ_INT32 p = 0, it_res;\n                                        assert( tccp->numresolutions > 0 );\n                                        for (it_res = (OPJ_INT32)tccp->numresolutions - 1; it_res >= 0; it_res--) {\n                                                if (p < parameters->res_spec) {\n\n                                                        if (parameters->prcw_init[p] < 1) {\n                                                                tccp->prcw[it_res] = 1;\n                                                        } else {\n                                                                tccp->prcw[it_res] = (OPJ_UINT32)opj_int_floorlog2(parameters->prcw_init[p]);\n                                                        }\n\n                                                        if (parameters->prch_init[p] < 1) {\n                                                                tccp->prch[it_res] = 1;\n                                                        }else {\n                                                                tccp->prch[it_res] = (OPJ_UINT32)opj_int_floorlog2(parameters->prch_init[p]);\n                                                        }\n\n                                                } else {\n                                                        OPJ_INT32 res_spec = parameters->res_spec;\n                                                        OPJ_INT32 size_prcw = 0;\n                                                        OPJ_INT32 size_prch = 0;\n\n                                                        assert(res_spec>0); /* issue 189 */\n                                                        size_prcw = parameters->prcw_init[res_spec - 1] >> (p - (res_spec - 1));\n                                                        size_prch = parameters->prch_init[res_spec - 1] >> (p - (res_spec - 1));\n\n\n                                                        if (size_prcw < 1) {\n                                                                tccp->prcw[it_res] = 1;\n                                                        } else {\n                                                                tccp->prcw[it_res] = (OPJ_UINT32)opj_int_floorlog2(size_prcw);\n                                                        }\n\n                                                        if (size_prch < 1) {\n                                                                tccp->prch[it_res] = 1;\n                                                        } else {\n                                                                tccp->prch[it_res] = (OPJ_UINT32)opj_int_floorlog2(size_prch);\n                                                        }\n                                                }\n                                                p++;\n                                                /*printf(\"\\nsize precinct for level %d : %d,%d\\n\", it_res,tccp->prcw[it_res], tccp->prch[it_res]); */\n                                        }       /*end for*/\n                                } else {\n                                        for (j = 0; j < tccp->numresolutions; j++) {\n                                                tccp->prcw[j] = 15;\n                                                tccp->prch[j] = 15;\n                                        }\n                                }\n\n                        opj_dwt_calc_explicit_stepsizes(tccp, image->comps[i].prec);\n                }\n        }\n\n        if (parameters->mct_data) {\n                opj_free(parameters->mct_data);\n                parameters->mct_data = 00;\n        }\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index, OPJ_UINT32 type, OPJ_OFF_T pos, OPJ_UINT32 len)\n{\n        assert(cstr_index != 00);\n\n        /* expand the list? */\n        if ((cstr_index->marknum + 1) > cstr_index->maxmarknum) {\n                opj_marker_info_t *new_marker;\n                cstr_index->maxmarknum = (OPJ_UINT32)(100 + (OPJ_FLOAT32) cstr_index->maxmarknum);\n                new_marker = (opj_marker_info_t *) opj_realloc(cstr_index->marker, cstr_index->maxmarknum *sizeof(opj_marker_info_t));\n                if (! new_marker) {\n                        opj_free(cstr_index->marker);\n                        cstr_index->marker = NULL;\n                        cstr_index->maxmarknum = 0;\n                        cstr_index->marknum = 0;\n                        /* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add mh marker\\n\"); */\n                        return OPJ_FALSE;\n                }\n                cstr_index->marker = new_marker;\n        }\n\n        /* add the marker */\n        cstr_index->marker[cstr_index->marknum].type = (OPJ_UINT16)type;\n        cstr_index->marker[cstr_index->marknum].pos = (OPJ_INT32)pos;\n        cstr_index->marker[cstr_index->marknum].len = (OPJ_INT32)len;\n        cstr_index->marknum++;\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno, opj_codestream_index_t *cstr_index, OPJ_UINT32 type, OPJ_OFF_T pos, OPJ_UINT32 len)\n{\n        assert(cstr_index != 00);\n        assert(cstr_index->tile_index != 00);\n\n        /* expand the list? */\n        if ((cstr_index->tile_index[tileno].marknum + 1) > cstr_index->tile_index[tileno].maxmarknum) {\n                opj_marker_info_t *new_marker;\n                cstr_index->tile_index[tileno].maxmarknum = (OPJ_UINT32)(100 + (OPJ_FLOAT32) cstr_index->tile_index[tileno].maxmarknum);\n                new_marker = (opj_marker_info_t *) opj_realloc(\n                                cstr_index->tile_index[tileno].marker,\n                                cstr_index->tile_index[tileno].maxmarknum *sizeof(opj_marker_info_t));\n                if (! new_marker) {\n                        opj_free(cstr_index->tile_index[tileno].marker);\n                        cstr_index->tile_index[tileno].marker = NULL;\n                        cstr_index->tile_index[tileno].maxmarknum = 0;\n                        cstr_index->tile_index[tileno].marknum = 0;\n                        /* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add tl marker\\n\"); */\n                        return OPJ_FALSE;\n                }\n                cstr_index->tile_index[tileno].marker = new_marker;\n        }\n\n        /* add the marker */\n        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].type = (OPJ_UINT16)type;\n        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].pos = (OPJ_INT32)pos;\n        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].len = (OPJ_INT32)len;\n        cstr_index->tile_index[tileno].marknum++;\n\n        if (type == J2K_MS_SOT) {\n                OPJ_UINT32 l_current_tile_part = cstr_index->tile_index[tileno].current_tpsno;\n\n                if (cstr_index->tile_index[tileno].tp_index)\n                        cstr_index->tile_index[tileno].tp_index[l_current_tile_part].start_pos = pos;\n\n        }\n        return OPJ_TRUE;\n}\n\n/*\n * -----------------------------------------------------------------------\n * -----------------------------------------------------------------------\n * -----------------------------------------------------------------------\n */\n\nOPJ_BOOL opj_j2k_end_decompress(opj_j2k_t *p_j2k,\n                                opj_stream_private_t *p_stream,\n                                opj_event_mgr_t * p_manager\n                                )\n{\n    (void)p_j2k;\n    (void)p_stream;\n    (void)p_manager;\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_read_header(   opj_stream_private_t *p_stream,\n                                                            opj_j2k_t* p_j2k,\n                                                            opj_image_t** p_image,\n                                                            opj_event_mgr_t* p_manager )\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n\n        /* create an empty image header */\n        p_j2k->m_private_image = opj_image_create0();\n        if (! p_j2k->m_private_image) {\n                return OPJ_FALSE;\n        }\n\n        /* customization of the validation */\n        if (! opj_j2k_setup_decoding_validation(p_j2k, p_manager)) {\n                opj_image_destroy(p_j2k->m_private_image);\n                p_j2k->m_private_image = NULL;\n                return OPJ_FALSE;\n        }\n\n        /* validation of the parameters codec */\n        if (! opj_j2k_exec(p_j2k, p_j2k->m_validation_list, p_stream,p_manager)) {\n                opj_image_destroy(p_j2k->m_private_image);\n                p_j2k->m_private_image = NULL;\n                return OPJ_FALSE;\n        }\n\n        /* customization of the encoding */\n        if (! opj_j2k_setup_header_reading(p_j2k, p_manager)) {\n                opj_image_destroy(p_j2k->m_private_image);\n                p_j2k->m_private_image = NULL;\n                return OPJ_FALSE;\n        }\n\n        /* read header */\n        if (! opj_j2k_exec (p_j2k,p_j2k->m_procedure_list,p_stream,p_manager)) {\n                opj_image_destroy(p_j2k->m_private_image);\n                p_j2k->m_private_image = NULL;\n                return OPJ_FALSE;\n        }\n\n        *p_image = opj_image_create0();\n        if (! (*p_image)) {\n                return OPJ_FALSE;\n        }\n\n        /* Copy codestream image information to the output image */\n        opj_copy_image_header(p_j2k->m_private_image, *p_image);\n\n    /*Allocate and initialize some elements of codestrem index*/\n        if (!opj_j2k_allocate_tile_element_cstr_index(p_j2k)){\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_setup_header_reading (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager)\n{\n        /* preconditions*/\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_read_header_procedure, p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        /* DEVELOPER CORNER, add your custom procedures */\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_copy_default_tcp_and_create_tcd, p_manager))  {\n                return OPJ_FALSE;\n        }\n\t\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_setup_decoding_validation (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager)\n{\n        /* preconditions*/\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list,(opj_procedure)opj_j2k_build_decoder, p_manager)) {\n                return OPJ_FALSE;\n        }\n        if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list,(opj_procedure)opj_j2k_decoding_validation, p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        /* DEVELOPER CORNER, add your custom validation procedure */\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_mct_validation (       opj_j2k_t * p_j2k,\n                                                                opj_stream_private_t *p_stream,\n                                                                opj_event_mgr_t * p_manager )\n{\n        OPJ_BOOL l_is_valid = OPJ_TRUE;\n        OPJ_UINT32 i,j;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n\n        if ((p_j2k->m_cp.rsiz & 0x8200) == 0x8200) {\n                OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n                opj_tcp_t * l_tcp = p_j2k->m_cp.tcps;\n\n                for (i=0;i<l_nb_tiles;++i) {\n                        if (l_tcp->mct == 2) {\n                                opj_tccp_t * l_tccp = l_tcp->tccps;\n                                l_is_valid &= (l_tcp->m_mct_coding_matrix != 00);\n\n                                for (j=0;j<p_j2k->m_private_image->numcomps;++j) {\n                                        l_is_valid &= ! (l_tccp->qmfbid & 1);\n                                        ++l_tccp;\n                                }\n                        }\n                        ++l_tcp;\n                }\n        }\n\n        return l_is_valid;\n}\n\nOPJ_BOOL opj_j2k_setup_mct_encoding(opj_tcp_t * p_tcp, opj_image_t * p_image)\n{\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_indix = 1;\n        opj_mct_data_t * l_mct_deco_data = 00,* l_mct_offset_data = 00;\n        opj_simple_mcc_decorrelation_data_t * l_mcc_data;\n        OPJ_UINT32 l_mct_size,l_nb_elem;\n        OPJ_FLOAT32 * l_data, * l_current_data;\n        opj_tccp_t * l_tccp;\n\n        /* preconditions */\n        assert(p_tcp != 00);\n\n        if (p_tcp->mct != 2) {\n                return OPJ_TRUE;\n        }\n\n        if (p_tcp->m_mct_decoding_matrix) {\n                if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {\n                        opj_mct_data_t *new_mct_records;\n                        p_tcp->m_nb_max_mct_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;\n\n                        new_mct_records = (opj_mct_data_t *) opj_realloc(p_tcp->m_mct_records, p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t));\n                        if (! new_mct_records) {\n                                opj_free(p_tcp->m_mct_records);\n                                p_tcp->m_mct_records = NULL;\n                                p_tcp->m_nb_max_mct_records = 0;\n                                p_tcp->m_nb_mct_records = 0;\n                                /* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to setup mct encoding\\n\"); */\n                                return OPJ_FALSE;\n                        }\n                        p_tcp->m_mct_records = new_mct_records;\n                        l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;\n\n                        memset(l_mct_deco_data ,0,(p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t));\n                }\n                l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;\n\n                if (l_mct_deco_data->m_data) {\n                        opj_free(l_mct_deco_data->m_data);\n                        l_mct_deco_data->m_data = 00;\n                }\n\n                l_mct_deco_data->m_index = l_indix++;\n                l_mct_deco_data->m_array_type = MCT_TYPE_DECORRELATION;\n                l_mct_deco_data->m_element_type = MCT_TYPE_FLOAT;\n                l_nb_elem = p_image->numcomps * p_image->numcomps;\n                l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_deco_data->m_element_type];\n                l_mct_deco_data->m_data = (OPJ_BYTE*)opj_malloc(l_mct_size );\n\n                if (! l_mct_deco_data->m_data) {\n                        return OPJ_FALSE;\n                }\n\n                j2k_mct_write_functions_from_float[l_mct_deco_data->m_element_type](p_tcp->m_mct_decoding_matrix,l_mct_deco_data->m_data,l_nb_elem);\n\n                l_mct_deco_data->m_data_size = l_mct_size;\n                ++p_tcp->m_nb_mct_records;\n        }\n\n        if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {\n                opj_mct_data_t *new_mct_records;\n                p_tcp->m_nb_max_mct_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;\n                new_mct_records = (opj_mct_data_t *) opj_realloc(p_tcp->m_mct_records, p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t));\n                if (! new_mct_records) {\n                        opj_free(p_tcp->m_mct_records);\n                        p_tcp->m_mct_records = NULL;\n                        p_tcp->m_nb_max_mct_records = 0;\n                        p_tcp->m_nb_mct_records = 0;\n                        /* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to setup mct encoding\\n\"); */\n                        return OPJ_FALSE;\n                }\n                p_tcp->m_mct_records = new_mct_records;\n                l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;\n\n                memset(l_mct_offset_data ,0,(p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t));\n\n                if (l_mct_deco_data) {\n                        l_mct_deco_data = l_mct_offset_data - 1;\n                }\n        }\n\n        l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;\n\n        if (l_mct_offset_data->m_data) {\n                opj_free(l_mct_offset_data->m_data);\n                l_mct_offset_data->m_data = 00;\n        }\n\n        l_mct_offset_data->m_index = l_indix++;\n        l_mct_offset_data->m_array_type = MCT_TYPE_OFFSET;\n        l_mct_offset_data->m_element_type = MCT_TYPE_FLOAT;\n        l_nb_elem = p_image->numcomps;\n        l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_offset_data->m_element_type];\n        l_mct_offset_data->m_data = (OPJ_BYTE*)opj_malloc(l_mct_size );\n\n        if (! l_mct_offset_data->m_data) {\n                return OPJ_FALSE;\n        }\n\n        l_data = (OPJ_FLOAT32*)opj_malloc(l_nb_elem * sizeof(OPJ_FLOAT32));\n        if (! l_data) {\n                opj_free(l_mct_offset_data->m_data);\n                l_mct_offset_data->m_data = 00;\n                return OPJ_FALSE;\n        }\n\n        l_tccp = p_tcp->tccps;\n        l_current_data = l_data;\n\n        for (i=0;i<l_nb_elem;++i) {\n                *(l_current_data++) = (OPJ_FLOAT32) (l_tccp->m_dc_level_shift);\n                ++l_tccp;\n        }\n\n        j2k_mct_write_functions_from_float[l_mct_offset_data->m_element_type](l_data,l_mct_offset_data->m_data,l_nb_elem);\n\n        opj_free(l_data);\n\n        l_mct_offset_data->m_data_size = l_mct_size;\n\n        ++p_tcp->m_nb_mct_records;\n\n        if (p_tcp->m_nb_mcc_records == p_tcp->m_nb_max_mcc_records) {\n                opj_simple_mcc_decorrelation_data_t *new_mcc_records;\n                p_tcp->m_nb_max_mcc_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;\n                new_mcc_records = (opj_simple_mcc_decorrelation_data_t *) opj_realloc(\n                                p_tcp->m_mcc_records, p_tcp->m_nb_max_mcc_records * sizeof(opj_simple_mcc_decorrelation_data_t));\n                if (! new_mcc_records) {\n                        opj_free(p_tcp->m_mcc_records);\n                        p_tcp->m_mcc_records = NULL;\n                        p_tcp->m_nb_max_mcc_records = 0;\n                        p_tcp->m_nb_mcc_records = 0;\n                        /* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to setup mct encoding\\n\"); */\n                        return OPJ_FALSE;\n                }\n                p_tcp->m_mcc_records = new_mcc_records;\n                l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;\n                memset(l_mcc_data ,0,(p_tcp->m_nb_max_mcc_records - p_tcp->m_nb_mcc_records) * sizeof(opj_simple_mcc_decorrelation_data_t));\n\n        }\n\n        l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;\n        l_mcc_data->m_decorrelation_array = l_mct_deco_data;\n        l_mcc_data->m_is_irreversible = 1;\n        l_mcc_data->m_nb_comps = p_image->numcomps;\n        l_mcc_data->m_index = l_indix++;\n        l_mcc_data->m_offset_array = l_mct_offset_data;\n        ++p_tcp->m_nb_mcc_records;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_build_decoder (opj_j2k_t * p_j2k,\n                                                            opj_stream_private_t *p_stream,\n                                                            opj_event_mgr_t * p_manager )\n{\n        /* add here initialization of cp\n           copy paste of setup_decoder */\n  (void)p_j2k;\n  (void)p_stream;\n  (void)p_manager;\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_build_encoder (opj_j2k_t * p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager )\n{\n        /* add here initialization of cp\n           copy paste of setup_encoder */\n  (void)p_j2k;\n  (void)p_stream;\n  (void)p_manager;\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_encoding_validation (  opj_j2k_t * p_j2k,\n                                                                            opj_stream_private_t *p_stream,\n                                                                            opj_event_mgr_t * p_manager )\n{\n        OPJ_BOOL l_is_valid = OPJ_TRUE;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n\n        /* STATE checking */\n        /* make sure the state is at 0 */\n        l_is_valid &= (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NONE);\n\n        /* POINTER validation */\n        /* make sure a p_j2k codec is present */\n        l_is_valid &= (p_j2k->m_procedure_list != 00);\n        /* make sure a validation list is present */\n        l_is_valid &= (p_j2k->m_validation_list != 00);\n\n        /* ISO 15444-1:2004 states between 1 & 33 (0 -> 32) */\n        /* 33 (32) would always fail the check below (if a cast to 64bits was done) */\n        /* FIXME Shall we change OPJ_J2K_MAXRLVLS to 32 ? */\n        if ((p_j2k->m_cp.tcps->tccps->numresolutions <= 0) || (p_j2k->m_cp.tcps->tccps->numresolutions > 32)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Number of resolutions is too high in comparison to the size of tiles\\n\");\n                return OPJ_FALSE;\n        }\n\n        if ((p_j2k->m_cp.tdx) < (OPJ_UINT32) (1 << (p_j2k->m_cp.tcps->tccps->numresolutions - 1U))) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Number of resolutions is too high in comparison to the size of tiles\\n\");\n                return OPJ_FALSE;\n        }\n\n        if ((p_j2k->m_cp.tdy) < (OPJ_UINT32) (1 << (p_j2k->m_cp.tcps->tccps->numresolutions - 1U))) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Number of resolutions is too high in comparison to the size of tiles\\n\");\n                return OPJ_FALSE;\n        }\n\n        /* PARAMETER VALIDATION */\n        return l_is_valid;\n}\n\nstatic OPJ_BOOL opj_j2k_decoding_validation (  opj_j2k_t *p_j2k,\n                                        opj_stream_private_t *p_stream,\n                                        opj_event_mgr_t * p_manager\n                                        )\n{\n        OPJ_BOOL l_is_valid = OPJ_TRUE;\n\n        /* preconditions*/\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n\n        /* STATE checking */\n        /* make sure the state is at 0 */\n#ifdef TODO_MSD\n        l_is_valid &= (p_j2k->m_specific_param.m_decoder.m_state == J2K_DEC_STATE_NONE);\n#endif\n        l_is_valid &= (p_j2k->m_specific_param.m_decoder.m_state == 0x0000);\n\n        /* POINTER validation */\n        /* make sure a p_j2k codec is present */\n        /* make sure a procedure list is present */\n        l_is_valid &= (p_j2k->m_procedure_list != 00);\n        /* make sure a validation list is present */\n        l_is_valid &= (p_j2k->m_validation_list != 00);\n\n        /* PARAMETER VALIDATION */\n        return l_is_valid;\n}\n\nstatic OPJ_BOOL opj_j2k_read_header_procedure( opj_j2k_t *p_j2k,\n                                                                            opj_stream_private_t *p_stream,\n                                                                            opj_event_mgr_t * p_manager)\n{\n        OPJ_UINT32 l_current_marker;\n        OPJ_UINT32 l_marker_size;\n        const opj_dec_memory_marker_handler_t * l_marker_handler = 00;\n        OPJ_BOOL l_has_siz = 0;\n        OPJ_BOOL l_has_cod = 0;\n        OPJ_BOOL l_has_qcd = 0;\n\n        /* preconditions */\n        assert(p_stream != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        /*  We enter in the main header */\n        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_MHSOC;\n\n        /* Try to read the SOC marker, the codestream must begin with SOC marker */\n        if (! opj_j2k_read_soc(p_j2k,p_stream,p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Expected a SOC marker \\n\");\n                return OPJ_FALSE;\n        }\n\n        /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */\n        if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                return OPJ_FALSE;\n        }\n\n        /* Read 2 bytes as the new marker ID */\n        opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_current_marker,2);\n\n        /* Try to read until the SOT is detected */\n        while (l_current_marker != J2K_MS_SOT) {\n\n                /* Check if the current marker ID is valid */\n                if (l_current_marker < 0xff00) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"A marker ID was expected (0xff--) instead of %.8x\\n\", l_current_marker);\n                        return OPJ_FALSE;\n                }\n\n                /* Get the marker handler from the marker ID */\n                l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);\n\n                /* Manage case where marker is unknown */\n                if (l_marker_handler->id == J2K_MS_UNK) {\n                        if (! opj_j2k_read_unk(p_j2k, p_stream, &l_current_marker, p_manager)){\n                                opj_event_msg(p_manager, EVT_ERROR, \"Unknow marker have been detected and generated error.\\n\");\n                                return OPJ_FALSE;\n                        }\n\n                        if (l_current_marker == J2K_MS_SOT)\n                                break; /* SOT marker is detected main header is completely read */\n                        else    /* Get the marker handler from the marker ID */\n                                l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);\n                }\n\n                if (l_marker_handler->id == J2K_MS_SIZ) {\n                    /* Mark required SIZ marker as found */\n                    l_has_siz = 1;\n                }\n                if (l_marker_handler->id == J2K_MS_COD) {\n                    /* Mark required COD marker as found */\n                    l_has_cod = 1;\n                }\n                if (l_marker_handler->id == J2K_MS_QCD) {\n                    /* Mark required QCD marker as found */\n                    l_has_qcd = 1;\n                }\n\n                /* Check if the marker is known and if it is the right place to find it */\n                if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states) ) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Marker is not compliant with its position\\n\");\n                        return OPJ_FALSE;\n                }\n\n                /* Try to read 2 bytes (the marker size) from stream and copy them into the buffer */\n                if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                        return OPJ_FALSE;\n                }\n\n                /* read 2 bytes as the marker size */\n                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_marker_size,2);\n                l_marker_size -= 2; /* Subtract the size of the marker ID already read */\n\n                /* Check if the marker size is compatible with the header data size */\n                if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {\n                        OPJ_BYTE *new_header_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size);\n                        if (! new_header_data) {\n                                opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);\n                                p_j2k->m_specific_param.m_decoder.m_header_data = NULL;\n                                p_j2k->m_specific_param.m_decoder.m_header_data_size = 0;\n                                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read header\\n\");\n                                return OPJ_FALSE;\n                        }\n                        p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;\n                        p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;\n                }\n\n                /* Try to read the rest of the marker segment from stream and copy them into the buffer */\n                if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,l_marker_size,p_manager) != l_marker_size) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                        return OPJ_FALSE;\n                }\n\n                /* Read the marker segment with the correct marker handler */\n                if (! (*(l_marker_handler->handler))(p_j2k,p_j2k->m_specific_param.m_decoder.m_header_data,l_marker_size,p_manager)) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Marker handler function failed to read the marker segment\\n\");\n                        return OPJ_FALSE;\n                }\n\n                /* Add the marker to the codestream index*/\n                if (OPJ_FALSE == opj_j2k_add_mhmarker(\n                                        p_j2k->cstr_index,\n                                        l_marker_handler->id,\n                                        (OPJ_UINT32) opj_stream_tell(p_stream) - l_marker_size - 4,\n                                        l_marker_size + 4 )) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add mh marker\\n\");\n                        return OPJ_FALSE;\n                }\n\n                /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */\n                if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                        return OPJ_FALSE;\n                }\n\n                /* read 2 bytes as the new marker ID */\n                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_current_marker,2);\n        }\n\n        if (l_has_siz == 0) {\n            opj_event_msg(p_manager, EVT_ERROR, \"required SIZ marker not found in main header\\n\");\n            return OPJ_FALSE;\n        }\n        if (l_has_cod == 0) {\n            opj_event_msg(p_manager, EVT_ERROR, \"required COD marker not found in main header\\n\");\n            return OPJ_FALSE;\n        }\n        if (l_has_qcd == 0) {\n            opj_event_msg(p_manager, EVT_ERROR, \"required QCD marker not found in main header\\n\");\n            return OPJ_FALSE;\n        }\n\t\n        if (! opj_j2k_merge_ppm(&(p_j2k->m_cp), p_manager)) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Failed to merge PPM data\\n\");\n            return OPJ_FALSE;\n        }\n\n        opj_event_msg(p_manager, EVT_INFO, \"Main header has been correctly decoded.\\n\");\n\n        /* Position of the last element if the main header */\n        p_j2k->cstr_index->main_head_end = (OPJ_UINT32) opj_stream_tell(p_stream) - 2;\n\n        /* Next step: read a tile-part header */\n        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_exec ( opj_j2k_t * p_j2k,\n                                        opj_procedure_list_t * p_procedure_list,\n                                        opj_stream_private_t *p_stream,\n                                        opj_event_mgr_t * p_manager )\n{\n        OPJ_BOOL (** l_procedure) (opj_j2k_t * ,opj_stream_private_t *,opj_event_mgr_t *) = 00;\n        OPJ_BOOL l_result = OPJ_TRUE;\n        OPJ_UINT32 l_nb_proc, i;\n\n        /* preconditions*/\n        assert(p_procedure_list != 00);\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n\n        l_nb_proc = opj_procedure_list_get_nb_procedures(p_procedure_list);\n        l_procedure = (OPJ_BOOL (**) (opj_j2k_t * ,opj_stream_private_t *,opj_event_mgr_t *)) opj_procedure_list_get_first_procedure(p_procedure_list);\n\n        for     (i=0;i<l_nb_proc;++i) {\n                l_result = l_result && ((*l_procedure) (p_j2k,p_stream,p_manager));\n                ++l_procedure;\n        }\n\n        /* and clear the procedure list at the end.*/\n        opj_procedure_list_clear(p_procedure_list);\n        return l_result;\n}\n\n/* FIXME DOC*/\nstatic OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd (       opj_j2k_t * p_j2k,\n                                                            opj_stream_private_t *p_stream,\n                                                            opj_event_mgr_t * p_manager\n                                                            )\n{\n        opj_tcp_t * l_tcp = 00;\n        opj_tcp_t * l_default_tcp = 00;\n        OPJ_UINT32 l_nb_tiles;\n        OPJ_UINT32 i,j;\n        opj_tccp_t *l_current_tccp = 00;\n        OPJ_UINT32 l_tccp_size;\n        OPJ_UINT32 l_mct_size;\n        opj_image_t * l_image;\n        OPJ_UINT32 l_mcc_records_size,l_mct_records_size;\n        opj_mct_data_t * l_src_mct_rec, *l_dest_mct_rec;\n        opj_simple_mcc_decorrelation_data_t * l_src_mcc_rec, *l_dest_mcc_rec;\n        OPJ_UINT32 l_offset;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n\n        l_image = p_j2k->m_private_image;\n        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n        l_tcp = p_j2k->m_cp.tcps;\n        l_tccp_size = l_image->numcomps * (OPJ_UINT32)sizeof(opj_tccp_t);\n        l_default_tcp = p_j2k->m_specific_param.m_decoder.m_default_tcp;\n        l_mct_size = l_image->numcomps * l_image->numcomps * (OPJ_UINT32)sizeof(OPJ_FLOAT32);\n\n        /* For each tile */\n        for (i=0; i<l_nb_tiles; ++i) {\n                /* keep the tile-compo coding parameters pointer of the current tile coding parameters*/\n                l_current_tccp = l_tcp->tccps;\n                /*Copy default coding parameters into the current tile coding parameters*/\n                memcpy(l_tcp, l_default_tcp, sizeof(opj_tcp_t));\n                /* Initialize some values of the current tile coding parameters*/\n                l_tcp->cod = 0;\n                l_tcp->ppt = 0;\n                l_tcp->ppt_data = 00;\n                /* Remove memory not owned by this tile in case of early error return. */\n                l_tcp->m_mct_decoding_matrix = 00;\n                l_tcp->m_nb_max_mct_records = 0;\n                l_tcp->m_mct_records = 00;\n                l_tcp->m_nb_max_mcc_records = 0;\n                l_tcp->m_mcc_records = 00;\n                /* Reconnect the tile-compo coding parameters pointer to the current tile coding parameters*/\n                l_tcp->tccps = l_current_tccp;\n\n                /* Get the mct_decoding_matrix of the dflt_tile_cp and copy them into the current tile cp*/\n                if (l_default_tcp->m_mct_decoding_matrix) {\n                        l_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32*)opj_malloc(l_mct_size);\n                        if (! l_tcp->m_mct_decoding_matrix ) {\n                                return OPJ_FALSE;\n                        }\n                        memcpy(l_tcp->m_mct_decoding_matrix,l_default_tcp->m_mct_decoding_matrix,l_mct_size);\n                }\n\n                /* Get the mct_record of the dflt_tile_cp and copy them into the current tile cp*/\n                l_mct_records_size = l_default_tcp->m_nb_max_mct_records * (OPJ_UINT32)sizeof(opj_mct_data_t);\n                l_tcp->m_mct_records = (opj_mct_data_t*)opj_malloc(l_mct_records_size);\n                if (! l_tcp->m_mct_records) {\n                        return OPJ_FALSE;\n                }\n                memcpy(l_tcp->m_mct_records, l_default_tcp->m_mct_records,l_mct_records_size);\n\n                /* Copy the mct record data from dflt_tile_cp to the current tile*/\n                l_src_mct_rec = l_default_tcp->m_mct_records;\n                l_dest_mct_rec = l_tcp->m_mct_records;\n\n                for (j=0;j<l_default_tcp->m_nb_mct_records;++j) {\n\n                        if (l_src_mct_rec->m_data) {\n\n                                l_dest_mct_rec->m_data = (OPJ_BYTE*) opj_malloc(l_src_mct_rec->m_data_size);\n                                if(! l_dest_mct_rec->m_data) {\n                                        return OPJ_FALSE;\n                                }\n                                memcpy(l_dest_mct_rec->m_data,l_src_mct_rec->m_data,l_src_mct_rec->m_data_size);\n                        }\n\n                        ++l_src_mct_rec;\n                        ++l_dest_mct_rec;\n                        /* Update with each pass to free exactly what has been allocated on early return. */\n                        l_tcp->m_nb_max_mct_records += 1;\n                }\n\n                /* Get the mcc_record of the dflt_tile_cp and copy them into the current tile cp*/\n                l_mcc_records_size = l_default_tcp->m_nb_max_mcc_records * (OPJ_UINT32)sizeof(opj_simple_mcc_decorrelation_data_t);\n                l_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t*) opj_malloc(l_mcc_records_size);\n                if (! l_tcp->m_mcc_records) {\n                        return OPJ_FALSE;\n                }\n                memcpy(l_tcp->m_mcc_records,l_default_tcp->m_mcc_records,l_mcc_records_size);\n                l_tcp->m_nb_max_mcc_records = l_default_tcp->m_nb_max_mcc_records;\n\n                /* Copy the mcc record data from dflt_tile_cp to the current tile*/\n                l_src_mcc_rec = l_default_tcp->m_mcc_records;\n                l_dest_mcc_rec = l_tcp->m_mcc_records;\n\n                for (j=0;j<l_default_tcp->m_nb_max_mcc_records;++j) {\n\n                        if (l_src_mcc_rec->m_decorrelation_array) {\n                                l_offset = (OPJ_UINT32)(l_src_mcc_rec->m_decorrelation_array - l_default_tcp->m_mct_records);\n                                l_dest_mcc_rec->m_decorrelation_array = l_tcp->m_mct_records + l_offset;\n                        }\n\n                        if (l_src_mcc_rec->m_offset_array) {\n                                l_offset = (OPJ_UINT32)(l_src_mcc_rec->m_offset_array - l_default_tcp->m_mct_records);\n                                l_dest_mcc_rec->m_offset_array = l_tcp->m_mct_records + l_offset;\n                        }\n\n                        ++l_src_mcc_rec;\n                        ++l_dest_mcc_rec;\n                }\n\n                /* Copy all the dflt_tile_compo_cp to the current tile cp */\n                memcpy(l_current_tccp,l_default_tcp->tccps,l_tccp_size);\n\n                /* Move to next tile cp*/\n                ++l_tcp;\n        }\n\n        /* Create the current tile decoder*/\n        p_j2k->m_tcd = (opj_tcd_t*)opj_tcd_create(OPJ_TRUE); /* FIXME why a cast ? */\n        if (! p_j2k->m_tcd ) {\n                return OPJ_FALSE;\n        }\n\n        if ( !opj_tcd_init(p_j2k->m_tcd, l_image, &(p_j2k->m_cp), p_j2k->m_tp) ) {\n                opj_tcd_destroy(p_j2k->m_tcd);\n                p_j2k->m_tcd = 00;\n                opj_event_msg(p_manager, EVT_ERROR, \"Cannot decode tile, memory error\\n\");\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic const opj_dec_memory_marker_handler_t * opj_j2k_get_marker_handler (OPJ_UINT32 p_id)\n{\n        const opj_dec_memory_marker_handler_t *e;\n        for (e = j2k_memory_marker_handler_tab; e->id != 0; ++e) {\n                if (e->id == p_id) {\n                        break; /* we find a handler corresponding to the marker ID*/\n                }\n        }\n        return e;\n}\n\nvoid opj_j2k_destroy (opj_j2k_t *p_j2k)\n{\n        if (p_j2k == 00) {\n                return;\n        }\n\n        if (p_j2k->m_is_decoder) {\n\n                if (p_j2k->m_specific_param.m_decoder.m_default_tcp != 00) {\n                        opj_j2k_tcp_destroy(p_j2k->m_specific_param.m_decoder.m_default_tcp);\n                        opj_free(p_j2k->m_specific_param.m_decoder.m_default_tcp);\n                        p_j2k->m_specific_param.m_decoder.m_default_tcp = 00;\n                }\n\n                if (p_j2k->m_specific_param.m_decoder.m_header_data != 00) {\n                        opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);\n                        p_j2k->m_specific_param.m_decoder.m_header_data = 00;\n                        p_j2k->m_specific_param.m_decoder.m_header_data_size = 0;\n                }\n        }\n        else {\n\n                if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = 00;\n                }\n\n                if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);\n                        p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = 00;\n                        p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = 00;\n                }\n\n                if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = 00;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                }\n        }\n\n        opj_tcd_destroy(p_j2k->m_tcd);\n\n        opj_j2k_cp_destroy(&(p_j2k->m_cp));\n        memset(&(p_j2k->m_cp),0,sizeof(opj_cp_t));\n\n        opj_procedure_list_destroy(p_j2k->m_procedure_list);\n        p_j2k->m_procedure_list = 00;\n\n        opj_procedure_list_destroy(p_j2k->m_validation_list);\n        p_j2k->m_procedure_list = 00;\n\n        j2k_destroy_cstr_index(p_j2k->cstr_index);\n        p_j2k->cstr_index = NULL;\n\n        opj_image_destroy(p_j2k->m_private_image);\n        p_j2k->m_private_image = NULL;\n\n        opj_image_destroy(p_j2k->m_output_image);\n        p_j2k->m_output_image = NULL;\n\n        opj_thread_pool_destroy(p_j2k->m_tp);\n        p_j2k->m_tp = NULL;\n\n        opj_free(p_j2k);\n}\n\nvoid j2k_destroy_cstr_index (opj_codestream_index_t *p_cstr_ind)\n{\n        if (p_cstr_ind) {\n\n                if (p_cstr_ind->marker) {\n                        opj_free(p_cstr_ind->marker);\n                        p_cstr_ind->marker = NULL;\n                }\n\n                if (p_cstr_ind->tile_index) {\n                        OPJ_UINT32 it_tile = 0;\n\n                        for (it_tile=0; it_tile < p_cstr_ind->nb_of_tiles; it_tile++) {\n\n                                if(p_cstr_ind->tile_index[it_tile].packet_index) {\n                                        opj_free(p_cstr_ind->tile_index[it_tile].packet_index);\n                                        p_cstr_ind->tile_index[it_tile].packet_index = NULL;\n                                }\n\n                                if(p_cstr_ind->tile_index[it_tile].tp_index){\n                                        opj_free(p_cstr_ind->tile_index[it_tile].tp_index);\n                                        p_cstr_ind->tile_index[it_tile].tp_index = NULL;\n                                }\n\n                                if(p_cstr_ind->tile_index[it_tile].marker){\n                                        opj_free(p_cstr_ind->tile_index[it_tile].marker);\n                                        p_cstr_ind->tile_index[it_tile].marker = NULL;\n\n                                }\n                        }\n\n                        opj_free( p_cstr_ind->tile_index);\n                        p_cstr_ind->tile_index = NULL;\n                }\n\n                opj_free(p_cstr_ind);\n        }\n}\n\nstatic void opj_j2k_tcp_destroy (opj_tcp_t *p_tcp)\n{\n\tif (p_tcp == 00) {\n\t\treturn;\n\t}\n\t\n\tif (p_tcp->ppt_markers != 00) {\n\t\tOPJ_UINT32 i;\n\t\tfor (i = 0U; i < p_tcp->ppt_markers_count; ++i) {\n\t\t\tif (p_tcp->ppt_markers[i].m_data != NULL) {\n\t\t\t\topj_free(p_tcp->ppt_markers[i].m_data);\n\t\t\t}\n\t\t}\n\t\tp_tcp->ppt_markers_count = 0U;\n\t\topj_free(p_tcp->ppt_markers);\n\t\tp_tcp->ppt_markers = NULL;\n\t}\n\t\n\tif (p_tcp->ppt_buffer != 00) {\n\t\topj_free(p_tcp->ppt_buffer);\n\t\tp_tcp->ppt_buffer = 00;\n\t}\n\t\n\tif (p_tcp->tccps != 00) {\n\t\topj_free(p_tcp->tccps);\n\t\tp_tcp->tccps = 00;\n\t}\n\t\n\tif (p_tcp->m_mct_coding_matrix != 00) {\n\t\topj_free(p_tcp->m_mct_coding_matrix);\n\t\tp_tcp->m_mct_coding_matrix = 00;\n\t}\n\t\n\tif (p_tcp->m_mct_decoding_matrix != 00) {\n\t\topj_free(p_tcp->m_mct_decoding_matrix);\n\t\tp_tcp->m_mct_decoding_matrix = 00;\n\t}\n\t\n\tif (p_tcp->m_mcc_records) {\n\t\topj_free(p_tcp->m_mcc_records);\n\t\tp_tcp->m_mcc_records = 00;\n\t\tp_tcp->m_nb_max_mcc_records = 0;\n\t\tp_tcp->m_nb_mcc_records = 0;\n\t}\n\t\n\tif (p_tcp->m_mct_records) {\n\t\topj_mct_data_t * l_mct_data = p_tcp->m_mct_records;\n\t\tOPJ_UINT32 i;\n\t\t\n\t\tfor (i=0;i<p_tcp->m_nb_mct_records;++i) {\n\t\t\tif (l_mct_data->m_data) {\n\t\t\t\topj_free(l_mct_data->m_data);\n\t\t\t\tl_mct_data->m_data = 00;\n\t\t\t}\n\t\t\t\n\t\t\t++l_mct_data;\n\t\t}\n\t\t\n\t\topj_free(p_tcp->m_mct_records);\n\t\tp_tcp->m_mct_records = 00;\n\t}\n\n\tif (p_tcp->mct_norms != 00) {\n\t\topj_free(p_tcp->mct_norms);\n\t\tp_tcp->mct_norms = 00;\n\t}\n\n\topj_j2k_tcp_data_destroy(p_tcp);\n\n}\n\nstatic void opj_j2k_tcp_data_destroy (opj_tcp_t *p_tcp)\n{\n        if (p_tcp->m_data) {\n                opj_free(p_tcp->m_data);\n                p_tcp->m_data = NULL;\n                p_tcp->m_data_size = 0;\n        }\n}\n\nstatic void opj_j2k_cp_destroy (opj_cp_t *p_cp)\n{\n\tOPJ_UINT32 l_nb_tiles;\n\topj_tcp_t * l_current_tile = 00;\n\n\tif (p_cp == 00)\n\t{\n\t\treturn;\n\t}\n\tif (p_cp->tcps != 00)\n\t{\n\t\tOPJ_UINT32 i;\n\t\tl_current_tile = p_cp->tcps;\n\t\tl_nb_tiles = p_cp->th * p_cp->tw;\n\t\t\n\t\tfor (i = 0U; i < l_nb_tiles; ++i)\n\t\t{\n\t\t\topj_j2k_tcp_destroy(l_current_tile);\n\t\t\t++l_current_tile;\n\t\t}\n\t\topj_free(p_cp->tcps);\n\t\tp_cp->tcps = 00;\n\t}\n\tif (p_cp->ppm_markers != 00) {\n\t\tOPJ_UINT32 i;\n\t\tfor (i = 0U; i < p_cp->ppm_markers_count; ++i) {\n\t\t\tif (p_cp->ppm_markers[i].m_data != NULL) {\n\t\t\t\topj_free(p_cp->ppm_markers[i].m_data);\n\t\t\t}\n\t\t}\n\t\tp_cp->ppm_markers_count = 0U;\n\t\topj_free(p_cp->ppm_markers);\n\t\tp_cp->ppm_markers = NULL;\n\t}\n\topj_free(p_cp->ppm_buffer);\n\tp_cp->ppm_buffer = 00;\n\tp_cp->ppm_data = NULL; /* ppm_data belongs to the allocated buffer pointed by ppm_buffer */\n\topj_free(p_cp->comment);\n\tp_cp->comment = 00;\n\tif (! p_cp->m_is_decoder)\n\t{\n\t\topj_free(p_cp->m_specific_param.m_enc.m_matrice);\n\t\tp_cp->m_specific_param.m_enc.m_matrice = 00;\n\t}\n}\n\nstatic OPJ_BOOL opj_j2k_need_nb_tile_parts_correction(opj_stream_private_t *p_stream, OPJ_UINT32 tile_no, OPJ_BOOL* p_correction_needed, opj_event_mgr_t * p_manager )\n{\n\tOPJ_BYTE   l_header_data[10];\n\tOPJ_OFF_T  l_stream_pos_backup;\n\tOPJ_UINT32 l_current_marker;\n\tOPJ_UINT32 l_marker_size;\n\tOPJ_UINT32 l_tile_no, l_tot_len, l_current_part, l_num_parts;\n\t\n\t/* initialize to no correction needed */\n\t*p_correction_needed = OPJ_FALSE;\n\t\n\tif (!opj_stream_has_seek(p_stream)) {\n\t\t/* We can't do much in this case, seek is needed */\n\t\treturn OPJ_TRUE;\n\t}\n\t\n\tl_stream_pos_backup = opj_stream_tell(p_stream);\n\tif (l_stream_pos_backup == -1) {\n\t\t/* let's do nothing */\n\t\treturn OPJ_TRUE;\n\t}\n\t\n\tfor (;;) {\n\t\t/* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */\n\t\tif (opj_stream_read_data(p_stream,l_header_data, 2, p_manager) != 2) {\n\t\t\t/* assume all is OK */\n\t\t\tif (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t\treturn OPJ_TRUE;\n\t\t}\n\t\t\n\t\t/* Read 2 bytes from buffer as the new marker ID */\n\t\topj_read_bytes(l_header_data, &l_current_marker, 2);\n\t\t\n\t\tif (l_current_marker != J2K_MS_SOT) {\n\t\t\t/* assume all is OK */\n\t\t\tif (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t\treturn OPJ_TRUE;\n\t\t}\n\t\t\n\t\t/* Try to read 2 bytes (the marker size) from stream and copy them into the buffer */\n\t\tif (opj_stream_read_data(p_stream, l_header_data, 2, p_manager) != 2) {\n\t\t\topj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t\n\t\t/* Read 2 bytes from the buffer as the marker size */\n\t\topj_read_bytes(l_header_data, &l_marker_size, 2);\n\t\t\n\t\t/* Check marker size for SOT Marker */\n\t\tif (l_marker_size != 10) {\n\t\t\topj_event_msg(p_manager, EVT_ERROR, \"Inconsistent marker size\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_marker_size -= 2;\n\t\t\n\t\tif (opj_stream_read_data(p_stream, l_header_data, l_marker_size, p_manager) != l_marker_size) {\n\t\t\topj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t\n\t\tif (! opj_j2k_get_sot_values(l_header_data, l_marker_size, &l_tile_no, &l_tot_len, &l_current_part, &l_num_parts, p_manager)) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t\n\t\tif (l_tile_no == tile_no) {\n\t\t\t/* we found what we were looking for */\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif ((l_tot_len == 0U) || (l_tot_len < 14U)) {\n\t\t\t/* last SOT until EOC or invalid Psot value */\n\t\t\t/* assume all is OK */\n\t\t\tif (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t\treturn OPJ_TRUE;\n\t\t}\n\t\tl_tot_len -= 12U;\n\t\t/* look for next SOT marker */\n\t\tif (opj_stream_skip(p_stream, (OPJ_OFF_T)(l_tot_len), p_manager) != (OPJ_OFF_T)(l_tot_len)) {\n\t\t\t/* assume all is OK */\n\t\t\tif (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t\treturn OPJ_TRUE;\n\t\t}\n\t}\n\t\n\t/* check for correction */\n\tif (l_current_part == l_num_parts) {\n\t\t*p_correction_needed = OPJ_TRUE;\n\t}\n\t\n\tif (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {\n\t\treturn OPJ_FALSE;\n\t}\n\treturn OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_read_tile_header(      opj_j2k_t * p_j2k,\n                                                                    OPJ_UINT32 * p_tile_index,\n                                                                    OPJ_UINT32 * p_data_size,\n                                                                    OPJ_INT32 * p_tile_x0, OPJ_INT32 * p_tile_y0,\n                                                                    OPJ_INT32 * p_tile_x1, OPJ_INT32 * p_tile_y1,\n                                                                    OPJ_UINT32 * p_nb_comps,\n                                                                    OPJ_BOOL * p_go_on,\n                                                                    opj_stream_private_t *p_stream,\n                                                                    opj_event_mgr_t * p_manager )\n{\n        OPJ_UINT32 l_current_marker = J2K_MS_SOT;\n        OPJ_UINT32 l_marker_size;\n        const opj_dec_memory_marker_handler_t * l_marker_handler = 00;\n        opj_tcp_t * l_tcp = NULL;\n\n        /* preconditions */\n        assert(p_stream != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        /* Reach the End Of Codestream ?*/\n        if (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_EOC){\n                l_current_marker = J2K_MS_EOC;\n        }\n        /* We need to encounter a SOT marker (a new tile-part header) */\n        else if (p_j2k->m_specific_param.m_decoder.m_state != J2K_STATE_TPHSOT){\n                return OPJ_FALSE;\n        }\n\n        /* Read into the codestream until reach the EOC or ! can_decode ??? FIXME */\n        while ( (!p_j2k->m_specific_param.m_decoder.m_can_decode) && (l_current_marker != J2K_MS_EOC) ) {\n\n                /* Try to read until the Start Of Data is detected */\n                while (l_current_marker != J2K_MS_SOD) {\n                    \n                    if(opj_stream_get_number_byte_left(p_stream) == 0)\n                    {\n                        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;\n                        break;\n                    }\n\n                        /* Try to read 2 bytes (the marker size) from stream and copy them into the buffer */\n                        if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                                return OPJ_FALSE;\n                        }\n\n                        /* Read 2 bytes from the buffer as the marker size */\n                        opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_marker_size,2);\n\n                        /* Check marker size (does not include marker ID but includes marker size) */\n                        if (l_marker_size < 2) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Inconsistent marker size\\n\");\n                                return OPJ_FALSE;\n                        }\n\n                        /* cf. https://code.google.com/p/openjpeg/issues/detail?id=226 */\n                        if (l_current_marker == 0x8080 && opj_stream_get_number_byte_left(p_stream) == 0) {\n                                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;\n                                break;\n                        }\n\n                        /* Why this condition? FIXME */\n                        if (p_j2k->m_specific_param.m_decoder.m_state & J2K_STATE_TPH){\n                                p_j2k->m_specific_param.m_decoder.m_sot_length -= (l_marker_size + 2);\n                        }\n                        l_marker_size -= 2; /* Subtract the size of the marker ID already read */\n\n                        /* Get the marker handler from the marker ID */\n                        l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);\n\n                        /* Check if the marker is known and if it is the right place to find it */\n                        if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states) ) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Marker is not compliant with its position\\n\");\n                                return OPJ_FALSE;\n                        }\n/* FIXME manage case of unknown marker as in the main header ? */\n\n                        /* Check if the marker size is compatible with the header data size */\n                        if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {\n                                OPJ_BYTE *new_header_data = NULL;\n                                /* If we are here, this means we consider this marker as known & we will read it */\n                                /* Check enough bytes left in stream before allocation */\n                                if ((OPJ_OFF_T)l_marker_size >  opj_stream_get_number_byte_left(p_stream)) {\n                                        opj_event_msg(p_manager, EVT_ERROR, \"Marker size inconsistent with stream length\\n\");\n                                        return OPJ_FALSE;\n                                }\n                                new_header_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size);\n                                if (! new_header_data) {\n                                        opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);\n                                        p_j2k->m_specific_param.m_decoder.m_header_data = NULL;\n                                        p_j2k->m_specific_param.m_decoder.m_header_data_size = 0;\n                                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read header\\n\");\n                                        return OPJ_FALSE;\n                                }\n                                p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;\n                                p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;\n                        }\n\n                        /* Try to read the rest of the marker segment from stream and copy them into the buffer */\n                        if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,l_marker_size,p_manager) != l_marker_size) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                                return OPJ_FALSE;\n                        }\n\n                        if (!l_marker_handler->handler) {\n                                /* See issue #175 */\n                                opj_event_msg(p_manager, EVT_ERROR, \"Not sure how that happened.\\n\");\n                                return OPJ_FALSE;\n                        }\n                        /* Read the marker segment with the correct marker handler */\n                        if (! (*(l_marker_handler->handler))(p_j2k,p_j2k->m_specific_param.m_decoder.m_header_data,l_marker_size,p_manager)) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Fail to read the current marker segment (%#x)\\n\", l_current_marker);\n                                return OPJ_FALSE;\n                        }\n\n                        /* Add the marker to the codestream index*/\n                        if (OPJ_FALSE == opj_j2k_add_tlmarker(p_j2k->m_current_tile_number,\n                                                p_j2k->cstr_index,\n                                                l_marker_handler->id,\n                                                (OPJ_UINT32) opj_stream_tell(p_stream) - l_marker_size - 4,\n                                                l_marker_size + 4 )) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add tl marker\\n\");\n                                return OPJ_FALSE;\n                        }\n\n                        /* Keep the position of the last SOT marker read */\n                        if ( l_marker_handler->id == J2K_MS_SOT ) {\n                                OPJ_UINT32 sot_pos = (OPJ_UINT32) opj_stream_tell(p_stream) - l_marker_size - 4 ;\n                                if (sot_pos > p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos)\n                                {\n                                        p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = sot_pos;\n                                }\n                        }\n\n                        if (p_j2k->m_specific_param.m_decoder.m_skip_data) {\n                                /* Skip the rest of the tile part header*/\n                                if (opj_stream_skip(p_stream,p_j2k->m_specific_param.m_decoder.m_sot_length,p_manager) != p_j2k->m_specific_param.m_decoder.m_sot_length) {\n                                        opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                                        return OPJ_FALSE;\n                                }\n                                l_current_marker = J2K_MS_SOD; /* Normally we reached a SOD */\n                        }\n                        else {\n                                /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer*/\n                                if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {\n                                        opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                                        return OPJ_FALSE;\n                                }\n                                /* Read 2 bytes from the buffer as the new marker ID */\n                                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_current_marker,2);\n                        }\n                }\n                if(opj_stream_get_number_byte_left(p_stream) == 0\n                    && p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NEOC)\n                    break;\n\n                /* If we didn't skip data before, we need to read the SOD marker*/\n                if (! p_j2k->m_specific_param.m_decoder.m_skip_data) {\n                        /* Try to read the SOD marker and skip data ? FIXME */\n                        if (! opj_j2k_read_sod(p_j2k, p_stream, p_manager)) {\n                                return OPJ_FALSE;\n                        }\n                        if (p_j2k->m_specific_param.m_decoder.m_can_decode && !p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked) {\n                                /* Issue 254 */\n                                OPJ_BOOL l_correction_needed;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n                                p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked = 1;\n                                if(!opj_j2k_need_nb_tile_parts_correction(p_stream, p_j2k->m_current_tile_number, &l_correction_needed, p_manager)) {\n                                        opj_event_msg(p_manager, EVT_ERROR, \"opj_j2k_apply_nb_tile_parts_correction error\\n\");\n                                        return OPJ_FALSE;\n                                }\n                                if (l_correction_needed) {\n                                        OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;\n                                        OPJ_UINT32 l_tile_no;\n\n                                        p_j2k->m_specific_param.m_decoder.m_can_decode = 0;\n                                        p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction = 1;\n                                        /* correct tiles */\n                                        for (l_tile_no = 0U; l_tile_no < l_nb_tiles; ++l_tile_no) {\n                                                if (p_j2k->m_cp.tcps[l_tile_no].m_nb_tile_parts != 0U) {\n                                                        p_j2k->m_cp.tcps[l_tile_no].m_nb_tile_parts+=1;\n                                                }\n                                        }\n                                        opj_event_msg(p_manager, EVT_WARNING, \"Non conformant codestream TPsot==TNsot.\\n\");\n                                }\n                        }\n                        if (! p_j2k->m_specific_param.m_decoder.m_can_decode){\n                                /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */\n                                if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {\n                                        opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                                        return OPJ_FALSE;\n                                }\n\n                                /* Read 2 bytes from buffer as the new marker ID */\n                                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_current_marker,2);\n                        }\n                }\n                else {\n                        /* Indicate we will try to read a new tile-part header*/\n                        p_j2k->m_specific_param.m_decoder.m_skip_data = 0;\n                        p_j2k->m_specific_param.m_decoder.m_can_decode = 0;\n                        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;\n\n                        /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */\n                        if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                                return OPJ_FALSE;\n                        }\n\n                        /* Read 2 bytes from buffer as the new marker ID */\n                        opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_current_marker,2);\n                }\n        }\n\n        /* Current marker is the EOC marker ?*/\n        if (l_current_marker == J2K_MS_EOC) {\n                if (p_j2k->m_specific_param.m_decoder.m_state != J2K_STATE_EOC ){\n                        p_j2k->m_current_tile_number = 0;\n                        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_EOC;\n                }\n        }\n\n        /* FIXME DOC ???*/\n        if ( ! p_j2k->m_specific_param.m_decoder.m_can_decode) {\n                OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n                l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;\n\n                while( (p_j2k->m_current_tile_number < l_nb_tiles) && (l_tcp->m_data == 00) ) {\n                        ++p_j2k->m_current_tile_number;\n                        ++l_tcp;\n                }\n\n                if (p_j2k->m_current_tile_number == l_nb_tiles) {\n                        *p_go_on = OPJ_FALSE;\n                        return OPJ_TRUE;\n                }\n        }\n\n        if (! opj_j2k_merge_ppt(p_j2k->m_cp.tcps + p_j2k->m_current_tile_number, p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Failed to merge PPT data\\n\");\n                return OPJ_FALSE;\n        }\n        /*FIXME ???*/\n        if (! opj_tcd_init_decode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number, p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Cannot decode tile, memory error\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_event_msg(p_manager, EVT_INFO, \"Header of tile %d / %d has been read.\\n\",\n                        p_j2k->m_current_tile_number+1, (p_j2k->m_cp.th * p_j2k->m_cp.tw));\n\n        *p_tile_index = p_j2k->m_current_tile_number;\n        *p_go_on = OPJ_TRUE;\n        *p_data_size = opj_tcd_get_decoded_tile_size(p_j2k->m_tcd);\n        *p_tile_x0 = p_j2k->m_tcd->tcd_image->tiles->x0;\n        *p_tile_y0 = p_j2k->m_tcd->tcd_image->tiles->y0;\n        *p_tile_x1 = p_j2k->m_tcd->tcd_image->tiles->x1;\n        *p_tile_y1 = p_j2k->m_tcd->tcd_image->tiles->y1;\n        *p_nb_comps = p_j2k->m_tcd->tcd_image->tiles->numcomps;\n\n         p_j2k->m_specific_param.m_decoder.m_state |= 0x0080;/* FIXME J2K_DEC_STATE_DATA;*/\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_decode_tile (  opj_j2k_t * p_j2k,\n                                                        OPJ_UINT32 p_tile_index,\n                                                        OPJ_BYTE * p_data,\n                                                        OPJ_UINT32 p_data_size,\n                                                        opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager )\n{\n        OPJ_UINT32 l_current_marker;\n        OPJ_BYTE l_data [2];\n        opj_tcp_t * l_tcp;\n\n        /* preconditions */\n        assert(p_stream != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        if ( !(p_j2k->m_specific_param.m_decoder.m_state & 0x0080/*FIXME J2K_DEC_STATE_DATA*/)\n                || (p_tile_index != p_j2k->m_current_tile_number) ) {\n                return OPJ_FALSE;\n        }\n\n        l_tcp = &(p_j2k->m_cp.tcps[p_tile_index]);\n        if (! l_tcp->m_data) {\n                opj_j2k_tcp_destroy(l_tcp);\n                return OPJ_FALSE;\n        }\n\n        if (! opj_tcd_decode_tile(      p_j2k->m_tcd,\n                                                                l_tcp->m_data,\n                                                                l_tcp->m_data_size,\n                                                                p_tile_index,\n                                                                p_j2k->cstr_index, p_manager) ) {\n                opj_j2k_tcp_destroy(l_tcp);\n                p_j2k->m_specific_param.m_decoder.m_state |= 0x8000;/*FIXME J2K_DEC_STATE_ERR;*/\n                opj_event_msg(p_manager, EVT_ERROR, \"Failed to decode.\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (! opj_tcd_update_tile_data(p_j2k->m_tcd,p_data,p_data_size)) {\n                return OPJ_FALSE;\n        }\n\n        /* To avoid to destroy the tcp which can be useful when we try to decode a tile decoded before (cf j2k_random_tile_access)\n         * we destroy just the data which will be re-read in read_tile_header*/\n        /*opj_j2k_tcp_destroy(l_tcp);\n        p_j2k->m_tcd->tcp = 0;*/\n        opj_j2k_tcp_data_destroy(l_tcp);\n\n        p_j2k->m_specific_param.m_decoder.m_can_decode = 0;\n        p_j2k->m_specific_param.m_decoder.m_state &= (~ (0x0080u));/* FIXME J2K_DEC_STATE_DATA);*/\n\n        if(opj_stream_get_number_byte_left(p_stream) == 0 \n            && p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NEOC){\n            return OPJ_TRUE;\n        }\n\n        if (p_j2k->m_specific_param.m_decoder.m_state != 0x0100){ /*FIXME J2K_DEC_STATE_EOC)*/\n                if (opj_stream_read_data(p_stream,l_data,2,p_manager) != 2) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                        return OPJ_FALSE;\n                }\n\n                opj_read_bytes(l_data,&l_current_marker,2);\n\n                if (l_current_marker == J2K_MS_EOC) {\n                        p_j2k->m_current_tile_number = 0;\n                        p_j2k->m_specific_param.m_decoder.m_state =  0x0100;/*FIXME J2K_DEC_STATE_EOC;*/\n                }\n                else if (l_current_marker != J2K_MS_SOT)\n                {       \n                        if(opj_stream_get_number_byte_left(p_stream) == 0) {\n                            p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;\n                            opj_event_msg(p_manager, EVT_WARNING, \"Stream does not end with EOC\\n\");\n                            return OPJ_TRUE;\n                        }\n                        opj_event_msg(p_manager, EVT_ERROR, \"Stream too short, expected SOT\\n\");\n                        return OPJ_FALSE;\n                }\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_update_image_data (opj_tcd_t * p_tcd, OPJ_BYTE * p_data, opj_image_t* p_output_image)\n{\n        OPJ_UINT32 i,j,k = 0;\n        OPJ_UINT32 l_width_src,l_height_src;\n        OPJ_UINT32 l_width_dest,l_height_dest;\n        OPJ_INT32 l_offset_x0_src, l_offset_y0_src, l_offset_x1_src, l_offset_y1_src;\n        OPJ_SIZE_T l_start_offset_src, l_line_offset_src, l_end_offset_src ;\n        OPJ_UINT32 l_start_x_dest , l_start_y_dest;\n        OPJ_UINT32 l_x0_dest, l_y0_dest, l_x1_dest, l_y1_dest;\n        OPJ_SIZE_T l_start_offset_dest, l_line_offset_dest;\n\n        opj_image_comp_t * l_img_comp_src = 00;\n        opj_image_comp_t * l_img_comp_dest = 00;\n\n        opj_tcd_tilecomp_t * l_tilec = 00;\n        opj_image_t * l_image_src = 00;\n        OPJ_UINT32 l_size_comp, l_remaining;\n        OPJ_INT32 * l_dest_ptr;\n        opj_tcd_resolution_t* l_res= 00;\n\n        l_tilec = p_tcd->tcd_image->tiles->comps;\n        l_image_src = p_tcd->image;\n        l_img_comp_src = l_image_src->comps;\n\n        l_img_comp_dest = p_output_image->comps;\n\n        for (i=0; i<l_image_src->numcomps; i++) {\n\n                /* Allocate output component buffer if necessary */\n                if (!l_img_comp_dest->data) {\n                        OPJ_SIZE_T l_width = l_img_comp_dest->w;\n                        OPJ_SIZE_T l_height = l_img_comp_dest->h;\n\n                        if ((l_height == 0U) || (l_width > (SIZE_MAX / l_height))) {\n                                /* would overflow */\n                                return OPJ_FALSE;\n                        }\n                        l_img_comp_dest->data = (OPJ_INT32*) opj_calloc(l_width * l_height, sizeof(OPJ_INT32));\n                        if (! l_img_comp_dest->data) {\n                                return OPJ_FALSE;\n                        }\n                }\n\n                /* Copy info from decoded comp image to output image */\n                l_img_comp_dest->resno_decoded = l_img_comp_src->resno_decoded;\n\n                /*-----*/\n                /* Compute the precision of the output buffer */\n                l_size_comp = l_img_comp_src->prec >> 3; /*(/ 8)*/\n                l_remaining = l_img_comp_src->prec & 7;  /* (%8) */\n                l_res = l_tilec->resolutions + l_img_comp_src->resno_decoded;\n\n                if (l_remaining) {\n                        ++l_size_comp;\n                }\n\n                if (l_size_comp == 3) {\n                        l_size_comp = 4;\n                }\n                /*-----*/\n\n                /* Current tile component size*/\n                /*if (i == 0) {\n                fprintf(stdout, \"SRC: l_res_x0=%d, l_res_x1=%d, l_res_y0=%d, l_res_y1=%d\\n\",\n                                l_res->x0, l_res->x1, l_res->y0, l_res->y1);\n                }*/\n\n                l_width_src = (OPJ_UINT32)(l_res->x1 - l_res->x0);\n                l_height_src = (OPJ_UINT32)(l_res->y1 - l_res->y0);\n\n                /* Border of the current output component*/\n                l_x0_dest = opj_uint_ceildivpow2(l_img_comp_dest->x0, l_img_comp_dest->factor);\n                l_y0_dest = opj_uint_ceildivpow2(l_img_comp_dest->y0, l_img_comp_dest->factor);\n                l_x1_dest = l_x0_dest + l_img_comp_dest->w; /* can't overflow given that image->x1 is uint32 */\n                l_y1_dest = l_y0_dest + l_img_comp_dest->h;\n\n                /*if (i == 0) {\n                fprintf(stdout, \"DEST: l_x0_dest=%d, l_x1_dest=%d, l_y0_dest=%d, l_y1_dest=%d (%d)\\n\",\n                                l_x0_dest, l_x1_dest, l_y0_dest, l_y1_dest, l_img_comp_dest->factor );\n                }*/\n\n                /*-----*/\n                /* Compute the area (l_offset_x0_src, l_offset_y0_src, l_offset_x1_src, l_offset_y1_src)\n                 * of the input buffer (decoded tile component) which will be move\n                 * in the output buffer. Compute the area of the output buffer (l_start_x_dest,\n                 * l_start_y_dest, l_width_dest, l_height_dest)  which will be modified\n                 * by this input area.\n                 * */\n                assert( l_res->x0 >= 0);\n                assert( l_res->x1 >= 0);\n                if ( l_x0_dest < (OPJ_UINT32)l_res->x0 ) {\n                        l_start_x_dest = (OPJ_UINT32)l_res->x0 - l_x0_dest;\n                        l_offset_x0_src = 0;\n\n                        if ( l_x1_dest >= (OPJ_UINT32)l_res->x1 ) {\n                                l_width_dest = l_width_src;\n                                l_offset_x1_src = 0;\n                        }\n                        else {\n                                l_width_dest = l_x1_dest - (OPJ_UINT32)l_res->x0 ;\n                                l_offset_x1_src = (OPJ_INT32)(l_width_src - l_width_dest);\n                        }\n                }\n                else {\n                        l_start_x_dest = 0U;\n                        l_offset_x0_src = (OPJ_INT32)l_x0_dest - l_res->x0;\n\n                        if ( l_x1_dest >= (OPJ_UINT32)l_res->x1 ) {\n                                l_width_dest = l_width_src - (OPJ_UINT32)l_offset_x0_src;\n                                l_offset_x1_src = 0;\n                        }\n                        else {\n                                l_width_dest = l_img_comp_dest->w ;\n                                l_offset_x1_src = l_res->x1 - (OPJ_INT32)l_x1_dest;\n                        }\n                }\n\n                if ( l_y0_dest < (OPJ_UINT32)l_res->y0 ) {\n                        l_start_y_dest = (OPJ_UINT32)l_res->y0 - l_y0_dest;\n                        l_offset_y0_src = 0;\n\n                        if ( l_y1_dest >= (OPJ_UINT32)l_res->y1 ) {\n                                l_height_dest = l_height_src;\n                                l_offset_y1_src = 0;\n                        }\n                        else {\n                                l_height_dest = l_y1_dest - (OPJ_UINT32)l_res->y0 ;\n                                l_offset_y1_src =  (OPJ_INT32)(l_height_src - l_height_dest);\n                        }\n                }\n                else {\n                        l_start_y_dest = 0U;\n                        l_offset_y0_src = (OPJ_INT32)l_y0_dest - l_res->y0;\n\n                        if ( l_y1_dest >= (OPJ_UINT32)l_res->y1 ) {\n                                l_height_dest = l_height_src - (OPJ_UINT32)l_offset_y0_src;\n                                l_offset_y1_src = 0;\n                        }\n                        else {\n                                l_height_dest = l_img_comp_dest->h ;\n                                l_offset_y1_src = l_res->y1 - (OPJ_INT32)l_y1_dest;\n                        }\n                }\n\n                if( (l_offset_x0_src < 0 ) || (l_offset_y0_src < 0 ) || (l_offset_x1_src < 0 ) || (l_offset_y1_src < 0 ) ){\n                        return OPJ_FALSE;\n                }\n                /* testcase 2977.pdf.asan.67.2198 */\n                if ((OPJ_INT32)l_width_dest < 0 || (OPJ_INT32)l_height_dest < 0) {\n                        return OPJ_FALSE;\n                }\n                /*-----*/\n\n                /* Compute the input buffer offset */\n                l_start_offset_src = (OPJ_SIZE_T)l_offset_x0_src + (OPJ_SIZE_T)l_offset_y0_src * (OPJ_SIZE_T)l_width_src;\n                l_line_offset_src  = (OPJ_SIZE_T)l_offset_x1_src + (OPJ_SIZE_T)l_offset_x0_src;\n                l_end_offset_src   = (OPJ_SIZE_T)l_offset_y1_src * (OPJ_SIZE_T)l_width_src - (OPJ_SIZE_T)l_offset_x0_src;\n\n                /* Compute the output buffer offset */\n                l_start_offset_dest = (OPJ_SIZE_T)l_start_x_dest + (OPJ_SIZE_T)l_start_y_dest * (OPJ_SIZE_T)l_img_comp_dest->w;\n                l_line_offset_dest  = (OPJ_SIZE_T)l_img_comp_dest->w - (OPJ_SIZE_T)l_width_dest;\n\n                /* Move the output buffer to the first place where we will write*/\n                l_dest_ptr = l_img_comp_dest->data + l_start_offset_dest;\n\n                /*if (i == 0) {\n                        fprintf(stdout, \"COMPO[%d]:\\n\",i);\n                        fprintf(stdout, \"SRC: l_start_x_src=%d, l_start_y_src=%d, l_width_src=%d, l_height_src=%d\\n\"\n                                        \"\\t tile offset:%d, %d, %d, %d\\n\"\n                                        \"\\t buffer offset: %d; %d, %d\\n\",\n                                        l_res->x0, l_res->y0, l_width_src, l_height_src,\n                                        l_offset_x0_src, l_offset_y0_src, l_offset_x1_src, l_offset_y1_src,\n                                        l_start_offset_src, l_line_offset_src, l_end_offset_src);\n\n                        fprintf(stdout, \"DEST: l_start_x_dest=%d, l_start_y_dest=%d, l_width_dest=%d, l_height_dest=%d\\n\"\n                                        \"\\t start offset: %d, line offset= %d\\n\",\n                                        l_start_x_dest, l_start_y_dest, l_width_dest, l_height_dest, l_start_offset_dest, l_line_offset_dest);\n                }*/\n\n                switch (l_size_comp) {\n                        case 1:\n                                {\n                                        OPJ_CHAR * l_src_ptr = (OPJ_CHAR*) p_data;\n                                        l_src_ptr += l_start_offset_src; /* Move to the first place where we will read*/\n\n                                        if (l_img_comp_src->sgnd) {\n                                                for (j = 0 ; j < l_height_dest ; ++j) {\n                                                        for ( k = 0 ; k < l_width_dest ; ++k) {\n                                                                *(l_dest_ptr++) = (OPJ_INT32) (*(l_src_ptr++)); /* Copy only the data needed for the output image */\n                                                        }\n\n                                                        l_dest_ptr+= l_line_offset_dest; /* Move to the next place where we will write */\n                                                        l_src_ptr += l_line_offset_src ; /* Move to the next place where we will read */\n                                                }\n                                        }\n                                        else {\n                                                for ( j = 0 ; j < l_height_dest ; ++j ) {\n                                                        for ( k = 0 ; k < l_width_dest ; ++k) {\n                                                                *(l_dest_ptr++) = (OPJ_INT32) ((*(l_src_ptr++))&0xff);\n                                                        }\n\n                                                        l_dest_ptr+= l_line_offset_dest;\n                                                        l_src_ptr += l_line_offset_src;\n                                                }\n                                        }\n\n                                        l_src_ptr += l_end_offset_src; /* Move to the end of this component-part of the input buffer */\n                                        p_data = (OPJ_BYTE*) l_src_ptr; /* Keep the current position for the next component-part */\n                                }\n                                break;\n                        case 2:\n                                {\n                                        OPJ_INT16 * l_src_ptr = (OPJ_INT16 *) p_data;\n                                        l_src_ptr += l_start_offset_src;\n\n                                        if (l_img_comp_src->sgnd) {\n                                                for (j=0;j<l_height_dest;++j) {\n                                                        for (k=0;k<l_width_dest;++k) {\n                                                                *(l_dest_ptr++) = *(l_src_ptr++);\n                                                        }\n\n                                                        l_dest_ptr+= l_line_offset_dest;\n                                                        l_src_ptr += l_line_offset_src ;\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_height_dest;++j) {\n                                                        for (k=0;k<l_width_dest;++k) {\n                                                                *(l_dest_ptr++) = (*(l_src_ptr++))&0xffff;\n                                                        }\n\n                                                        l_dest_ptr+= l_line_offset_dest;\n                                                        l_src_ptr += l_line_offset_src ;\n                                                }\n                                        }\n\n                                        l_src_ptr += l_end_offset_src;\n                                        p_data = (OPJ_BYTE*) l_src_ptr;\n                                }\n                                break;\n                        case 4:\n                                {\n                                        OPJ_INT32 * l_src_ptr = (OPJ_INT32 *) p_data;\n                                        l_src_ptr += l_start_offset_src;\n\n                                        for (j=0;j<l_height_dest;++j) {\n                                                for (k=0;k<l_width_dest;++k) {\n                                                        *(l_dest_ptr++) = (*(l_src_ptr++));\n                                                }\n\n                                                l_dest_ptr+= l_line_offset_dest;\n                                                l_src_ptr += l_line_offset_src ;\n                                        }\n\n                                        l_src_ptr += l_end_offset_src;\n                                        p_data = (OPJ_BYTE*) l_src_ptr;\n                                }\n                                break;\n                }\n\n                ++l_img_comp_dest;\n                ++l_img_comp_src;\n                ++l_tilec;\n        }\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_set_decode_area(       opj_j2k_t *p_j2k,\n                                                                    opj_image_t* p_image,\n                                                                    OPJ_INT32 p_start_x, OPJ_INT32 p_start_y,\n                                                                    OPJ_INT32 p_end_x, OPJ_INT32 p_end_y,\n                                                                    opj_event_mgr_t * p_manager )\n{\n        opj_cp_t * l_cp = &(p_j2k->m_cp);\n        opj_image_t * l_image = p_j2k->m_private_image;\n\n        OPJ_UINT32 it_comp;\n        OPJ_INT32 l_comp_x1, l_comp_y1;\n        opj_image_comp_t* l_img_comp = NULL;\n\n        /* Check if we are read the main header */\n        if (p_j2k->m_specific_param.m_decoder.m_state != J2K_STATE_TPHSOT) { /* FIXME J2K_DEC_STATE_TPHSOT)*/\n                opj_event_msg(p_manager, EVT_ERROR, \"Need to decode the main header before begin to decode the remaining codestream\");\n                return OPJ_FALSE;\n        }\n\n        if ( !p_start_x && !p_start_y && !p_end_x && !p_end_y){\n                opj_event_msg(p_manager, EVT_INFO, \"No decoded area parameters, set the decoded area to the whole image\\n\");\n\n                p_j2k->m_specific_param.m_decoder.m_start_tile_x = 0;\n                p_j2k->m_specific_param.m_decoder.m_start_tile_y = 0;\n                p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;\n                p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;\n\n                return OPJ_TRUE;\n        }\n\n        /* ----- */\n        /* Check if the positions provided by the user are correct */\n\n        /* Left */\n        assert(p_start_x >= 0 );\n        assert(p_start_y >= 0 );\n\n        if ((OPJ_UINT32)p_start_x > l_image->x1 ) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                        \"Left position of the decoded area (region_x0=%d) is outside the image area (Xsiz=%d).\\n\",\n                        p_start_x, l_image->x1);\n                return OPJ_FALSE;\n        }\n        else if ((OPJ_UINT32)p_start_x < l_image->x0){\n                opj_event_msg(p_manager, EVT_WARNING,\n                                \"Left position of the decoded area (region_x0=%d) is outside the image area (XOsiz=%d).\\n\",\n                                p_start_x, l_image->x0);\n                p_j2k->m_specific_param.m_decoder.m_start_tile_x = 0;\n                p_image->x0 = l_image->x0;\n        }\n        else {\n                p_j2k->m_specific_param.m_decoder.m_start_tile_x = ((OPJ_UINT32)p_start_x - l_cp->tx0) / l_cp->tdx;\n                p_image->x0 = (OPJ_UINT32)p_start_x;\n        }\n\n        /* Up */\n        if ((OPJ_UINT32)p_start_y > l_image->y1){\n                opj_event_msg(p_manager, EVT_ERROR,\n                                \"Up position of the decoded area (region_y0=%d) is outside the image area (Ysiz=%d).\\n\",\n                                p_start_y, l_image->y1);\n                return OPJ_FALSE;\n        }\n        else if ((OPJ_UINT32)p_start_y < l_image->y0){\n                opj_event_msg(p_manager, EVT_WARNING,\n                                \"Up position of the decoded area (region_y0=%d) is outside the image area (YOsiz=%d).\\n\",\n                                p_start_y, l_image->y0);\n                p_j2k->m_specific_param.m_decoder.m_start_tile_y = 0;\n                p_image->y0 = l_image->y0;\n        }\n        else {\n                p_j2k->m_specific_param.m_decoder.m_start_tile_y = ((OPJ_UINT32)p_start_y - l_cp->ty0) / l_cp->tdy;\n                p_image->y0 = (OPJ_UINT32)p_start_y;\n        }\n\n        /* Right */\n        assert((OPJ_UINT32)p_end_x > 0);\n        assert((OPJ_UINT32)p_end_y > 0);\n        if ((OPJ_UINT32)p_end_x < l_image->x0) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                        \"Right position of the decoded area (region_x1=%d) is outside the image area (XOsiz=%d).\\n\",\n                        p_end_x, l_image->x0);\n                return OPJ_FALSE;\n        }\n        else if ((OPJ_UINT32)p_end_x > l_image->x1) {\n                opj_event_msg(p_manager, EVT_WARNING,\n                        \"Right position of the decoded area (region_x1=%d) is outside the image area (Xsiz=%d).\\n\",\n                        p_end_x, l_image->x1);\n                p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;\n                p_image->x1 = l_image->x1;\n        }\n        else {\n                p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32)opj_int_ceildiv(p_end_x - (OPJ_INT32)l_cp->tx0, (OPJ_INT32)l_cp->tdx);\n                p_image->x1 = (OPJ_UINT32)p_end_x;\n        }\n\n        /* Bottom */\n        if ((OPJ_UINT32)p_end_y < l_image->y0) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                        \"Bottom position of the decoded area (region_y1=%d) is outside the image area (YOsiz=%d).\\n\",\n                        p_end_y, l_image->y0);\n                return OPJ_FALSE;\n        }\n        if ((OPJ_UINT32)p_end_y > l_image->y1){\n                opj_event_msg(p_manager, EVT_WARNING,\n                        \"Bottom position of the decoded area (region_y1=%d) is outside the image area (Ysiz=%d).\\n\",\n                        p_end_y, l_image->y1);\n                p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;\n                p_image->y1 = l_image->y1;\n        }\n        else{\n                p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32)opj_int_ceildiv(p_end_y - (OPJ_INT32)l_cp->ty0, (OPJ_INT32)l_cp->tdy);\n                p_image->y1 = (OPJ_UINT32)p_end_y;\n        }\n        /* ----- */\n\n        p_j2k->m_specific_param.m_decoder.m_discard_tiles = 1;\n\n        l_img_comp = p_image->comps;\n        for (it_comp=0; it_comp < p_image->numcomps; ++it_comp)\n        {\n                OPJ_INT32 l_h,l_w;\n\n                l_img_comp->x0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->x0, (OPJ_INT32)l_img_comp->dx);\n                l_img_comp->y0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->y0, (OPJ_INT32)l_img_comp->dy);\n                l_comp_x1 = opj_int_ceildiv((OPJ_INT32)p_image->x1, (OPJ_INT32)l_img_comp->dx);\n                l_comp_y1 = opj_int_ceildiv((OPJ_INT32)p_image->y1, (OPJ_INT32)l_img_comp->dy);\n\n                l_w = opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32)l_img_comp->factor)\n                                - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->x0, (OPJ_INT32)l_img_comp->factor);\n                if (l_w < 0){\n                        opj_event_msg(p_manager, EVT_ERROR,\n                                \"Size x of the decoded component image is incorrect (comp[%d].w=%d).\\n\",\n                                it_comp, l_w);\n                        return OPJ_FALSE;\n                }\n                l_img_comp->w = (OPJ_UINT32)l_w;\n\n                l_h = opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32)l_img_comp->factor)\n                                - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->y0, (OPJ_INT32)l_img_comp->factor);\n                if (l_h < 0){\n                        opj_event_msg(p_manager, EVT_ERROR,\n                                \"Size y of the decoded component image is incorrect (comp[%d].h=%d).\\n\",\n                                it_comp, l_h);\n                        return OPJ_FALSE;\n                }\n                l_img_comp->h = (OPJ_UINT32)l_h;\n\n                l_img_comp++;\n        }\n\n        opj_event_msg( p_manager, EVT_INFO,\"Setting decoding area to %d,%d,%d,%d\\n\",\n                        p_image->x0, p_image->y0, p_image->x1, p_image->y1);\n\n        return OPJ_TRUE;\n}\n\nopj_j2k_t* opj_j2k_create_decompress(void)\n{\n        opj_j2k_t *l_j2k = (opj_j2k_t*) opj_calloc(1,sizeof(opj_j2k_t));\n        if (!l_j2k) {\n                return 00;\n        }\n\n        l_j2k->m_is_decoder = 1;\n        l_j2k->m_cp.m_is_decoder = 1;\n\n#ifdef OPJ_DISABLE_TPSOT_FIX\n        l_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked = 1;\n#endif\n\n        l_j2k->m_specific_param.m_decoder.m_default_tcp = (opj_tcp_t*) opj_calloc(1,sizeof(opj_tcp_t));\n        if (!l_j2k->m_specific_param.m_decoder.m_default_tcp) {\n                opj_j2k_destroy(l_j2k);\n                return 00;\n        }\n\n        l_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *) opj_calloc(1,OPJ_J2K_DEFAULT_HEADER_SIZE);\n        if (! l_j2k->m_specific_param.m_decoder.m_header_data) {\n                opj_j2k_destroy(l_j2k);\n                return 00;\n        }\n\n        l_j2k->m_specific_param.m_decoder.m_header_data_size = OPJ_J2K_DEFAULT_HEADER_SIZE;\n\n        l_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = -1 ;\n\n        l_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = 0 ;\n\n        /* codestream index creation */\n        l_j2k->cstr_index = opj_j2k_create_cstr_index();\n        if (!l_j2k->cstr_index){\n                opj_j2k_destroy(l_j2k);\n                return 00;\n        }\n\n        /* validation list creation */\n        l_j2k->m_validation_list = opj_procedure_list_create();\n        if (! l_j2k->m_validation_list) {\n                opj_j2k_destroy(l_j2k);\n                return 00;\n        }\n\n        /* execution list creation */\n        l_j2k->m_procedure_list = opj_procedure_list_create();\n        if (! l_j2k->m_procedure_list) {\n                opj_j2k_destroy(l_j2k);\n                return 00;\n        }\n\n        l_j2k->m_tp = opj_thread_pool_create(opj_j2k_get_default_thread_count());\n        if( !l_j2k->m_tp )\n        {\n            l_j2k->m_tp = opj_thread_pool_create(0);\n        }\n        if( !l_j2k->m_tp )\n        {\n            opj_j2k_destroy(l_j2k);\n            return NULL;\n        }\n\n        return l_j2k;\n}\n\nstatic opj_codestream_index_t* opj_j2k_create_cstr_index(void)\n{\n        opj_codestream_index_t* cstr_index = (opj_codestream_index_t*)\n                        opj_calloc(1,sizeof(opj_codestream_index_t));\n        if (!cstr_index)\n                return NULL;\n\n        cstr_index->maxmarknum = 100;\n        cstr_index->marknum = 0;\n        cstr_index->marker = (opj_marker_info_t*)\n                        opj_calloc(cstr_index->maxmarknum, sizeof(opj_marker_info_t));\n        if (!cstr_index-> marker) {\n                opj_free(cstr_index);\n                return NULL;\n        }\n\n        cstr_index->tile_index = NULL;\n\n        return cstr_index;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size (       opj_j2k_t *p_j2k,\n                                                                                OPJ_UINT32 p_tile_no,\n                                                                                OPJ_UINT32 p_comp_no )\n{\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_tccp_t *l_tccp = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = &l_cp->tcps[p_tile_no];\n        l_tccp = &l_tcp->tccps[p_comp_no];\n\n        /* preconditions again */\n        assert(p_tile_no < (l_cp->tw * l_cp->th));\n        assert(p_comp_no < p_j2k->m_private_image->numcomps);\n\n        if (l_tccp->csty & J2K_CCP_CSTY_PRT) {\n                return 5 + l_tccp->numresolutions;\n        }\n        else {\n                return 5;\n        }\n}\n\nstatic OPJ_BOOL opj_j2k_compare_SPCod_SPCoc(opj_j2k_t *p_j2k, OPJ_UINT32 p_tile_no, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no)\n{\n\tOPJ_UINT32 i;\n\topj_cp_t *l_cp = NULL;\n\topj_tcp_t *l_tcp = NULL;\n\topj_tccp_t *l_tccp0 = NULL;\n\topj_tccp_t *l_tccp1 = NULL;\n\t\n\t/* preconditions */\n\tassert(p_j2k != 00);\n\t\n\tl_cp = &(p_j2k->m_cp);\n\tl_tcp = &l_cp->tcps[p_tile_no];\n\tl_tccp0 = &l_tcp->tccps[p_first_comp_no];\n\tl_tccp1 = &l_tcp->tccps[p_second_comp_no];\n\t\n\tif (l_tccp0->numresolutions != l_tccp1->numresolutions) {\n\t\treturn OPJ_FALSE;\n\t}\n\tif (l_tccp0->cblkw != l_tccp1->cblkw) {\n\t\treturn OPJ_FALSE;\n\t}\n\tif (l_tccp0->cblkh != l_tccp1->cblkh) {\n\t\treturn OPJ_FALSE;\n\t}\n\tif (l_tccp0->cblksty != l_tccp1->cblksty) {\n\t\treturn OPJ_FALSE;\n\t}\n\tif (l_tccp0->qmfbid != l_tccp1->qmfbid) {\n\t\treturn OPJ_FALSE;\n\t}\n\tif ((l_tccp0->csty & J2K_CCP_CSTY_PRT) != (l_tccp1->csty & J2K_CCP_CSTY_PRT)) {\n\t\treturn OPJ_FALSE;\n\t}\n\t\n\tfor (i = 0U; i < l_tccp0->numresolutions; ++i) {\n\t\tif (l_tccp0->prcw[i] != l_tccp1->prcw[i]) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tif (l_tccp0->prch[i] != l_tccp1->prch[i]) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t}\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_SPCod_SPCoc(     opj_j2k_t *p_j2k,\n                                                                    OPJ_UINT32 p_tile_no,\n                                                                    OPJ_UINT32 p_comp_no,\n                                                                    OPJ_BYTE * p_data,\n                                                                    OPJ_UINT32 * p_header_size,\n                                                                    struct opj_event_mgr * p_manager )\n{\n        OPJ_UINT32 i;\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_tccp_t *l_tccp = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_header_size != 00);\n        assert(p_manager != 00);\n        assert(p_data != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = &l_cp->tcps[p_tile_no];\n        l_tccp = &l_tcp->tccps[p_comp_no];\n\n        /* preconditions again */\n        assert(p_tile_no < (l_cp->tw * l_cp->th));\n        assert(p_comp_no <(p_j2k->m_private_image->numcomps));\n\n        if (*p_header_size < 5) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error writing SPCod SPCoc element\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_write_bytes(p_data,l_tccp->numresolutions - 1, 1);  /* SPcoc (D) */\n        ++p_data;\n\n        opj_write_bytes(p_data,l_tccp->cblkw - 2, 1);                   /* SPcoc (E) */\n        ++p_data;\n\n        opj_write_bytes(p_data,l_tccp->cblkh - 2, 1);                   /* SPcoc (F) */\n        ++p_data;\n\n        opj_write_bytes(p_data,l_tccp->cblksty, 1);                             /* SPcoc (G) */\n        ++p_data;\n\n        opj_write_bytes(p_data,l_tccp->qmfbid, 1);                              /* SPcoc (H) */\n        ++p_data;\n\n        *p_header_size = *p_header_size - 5;\n\n        if (l_tccp->csty & J2K_CCP_CSTY_PRT) {\n\n                if (*p_header_size < l_tccp->numresolutions) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error writing SPCod SPCoc element\\n\");\n                        return OPJ_FALSE;\n                }\n\n                for (i = 0; i < l_tccp->numresolutions; ++i) {\n                        opj_write_bytes(p_data,l_tccp->prcw[i] + (l_tccp->prch[i] << 4), 1);    /* SPcoc (I_i) */\n                        ++p_data;\n                }\n\n                *p_header_size = *p_header_size - l_tccp->numresolutions;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_SPCod_SPCoc(  opj_j2k_t *p_j2k,\n                                                                OPJ_UINT32 compno,\n                                                                OPJ_BYTE * p_header_data,\n                                                                OPJ_UINT32 * p_header_size,\n                                                                opj_event_mgr_t * p_manager)\n{\n        OPJ_UINT32 i, l_tmp;\n        opj_cp_t *l_cp = NULL;\n        opj_tcp_t *l_tcp = NULL;\n        opj_tccp_t *l_tccp = NULL;\n        OPJ_BYTE * l_current_ptr = NULL;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_header_data != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?\n                                &l_cp->tcps[p_j2k->m_current_tile_number] :\n                                p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n        /* precondition again */\n        assert(compno < p_j2k->m_private_image->numcomps);\n\n        l_tccp = &l_tcp->tccps[compno];\n        l_current_ptr = p_header_data;\n\n        /* make sure room is sufficient */\n        if (*p_header_size < 5) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading SPCod SPCoc element\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(l_current_ptr, &l_tccp->numresolutions ,1);              /* SPcox (D) */\n        ++l_tccp->numresolutions;                                                                               /* tccp->numresolutions = read() + 1 */\n        if (l_tccp->numresolutions > OPJ_J2K_MAXRLVLS) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Invalid value for numresolutions : %d, max value is set in openjpeg.h at %d\\n\",\n                              l_tccp->numresolutions, OPJ_J2K_MAXRLVLS);\n                return OPJ_FALSE;\n        }\n        ++l_current_ptr;\n\n        /* If user wants to remove more resolutions than the codestream contains, return error */\n        if (l_cp->m_specific_param.m_dec.m_reduce >= l_tccp->numresolutions) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error decoding component %d.\\nThe number of resolutions to remove is higher than the number \"\n                                        \"of resolutions of this component\\nModify the cp_reduce parameter.\\n\\n\", compno);\n                p_j2k->m_specific_param.m_decoder.m_state |= 0x8000;/* FIXME J2K_DEC_STATE_ERR;*/\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(l_current_ptr,&l_tccp->cblkw ,1);                /* SPcoc (E) */\n        ++l_current_ptr;\n        l_tccp->cblkw += 2;\n\n        opj_read_bytes(l_current_ptr,&l_tccp->cblkh ,1);                /* SPcoc (F) */\n        ++l_current_ptr;\n        l_tccp->cblkh += 2;\n\n        if ((l_tccp->cblkw > 10) || (l_tccp->cblkh > 10) || ((l_tccp->cblkw + l_tccp->cblkh) > 12)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading SPCod SPCoc element, Invalid cblkw/cblkh combination\\n\");\n                return OPJ_FALSE;\n        }\n\t\n\n        opj_read_bytes(l_current_ptr,&l_tccp->cblksty ,1);              /* SPcoc (G) */\n        ++l_current_ptr;\n        if (l_tccp->cblksty & 0xC0U) { /* 2 msb are reserved, assume we can't read */\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading SPCod SPCoc element, Invalid code-block style found\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(l_current_ptr,&l_tccp->qmfbid ,1);               /* SPcoc (H) */\n        ++l_current_ptr;\n\n        *p_header_size = *p_header_size - 5;\n\n        /* use custom precinct size ? */\n        if (l_tccp->csty & J2K_CCP_CSTY_PRT) {\n                if (*p_header_size < l_tccp->numresolutions) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error reading SPCod SPCoc element\\n\");\n                        return OPJ_FALSE;\n                }\n\n                for     (i = 0; i < l_tccp->numresolutions; ++i) {\n                        opj_read_bytes(l_current_ptr,&l_tmp ,1);                /* SPcoc (I_i) */\n                        ++l_current_ptr;\n                        /* Precinct exponent 0 is only allowed for lowest resolution level (Table A.21) */\n                        if ((i != 0) && (((l_tmp & 0xf) == 0) || ((l_tmp >> 4) == 0))) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Invalid precinct size\\n\");\n                                return OPJ_FALSE;\n                        }\n                        l_tccp->prcw[i] = l_tmp & 0xf;\n                        l_tccp->prch[i] = l_tmp >> 4;\n                }\n\n                *p_header_size = *p_header_size - l_tccp->numresolutions;\n        }\n        else {\n                /* set default size for the precinct width and height */\n                for     (i = 0; i < l_tccp->numresolutions; ++i) {\n                        l_tccp->prcw[i] = 15;\n                        l_tccp->prch[i] = 15;\n                }\n        }\n\n#ifdef WIP_REMOVE_MSD\n        /* INDEX >> */\n        if (p_j2k->cstr_info && compno == 0) {\n                OPJ_UINT32 l_data_size = l_tccp->numresolutions * sizeof(OPJ_UINT32);\n\n                p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].cblkh = l_tccp->cblkh;\n                p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].cblkw = l_tccp->cblkw;\n                p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].numresolutions = l_tccp->numresolutions;\n                p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].cblksty = l_tccp->cblksty;\n                p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].qmfbid = l_tccp->qmfbid;\n\n                memcpy(p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].pdx,l_tccp->prcw, l_data_size);\n                memcpy(p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].pdy,l_tccp->prch, l_data_size);\n        }\n        /* << INDEX */\n#endif\n\n        return OPJ_TRUE;\n}\n\nstatic void opj_j2k_copy_tile_component_parameters( opj_j2k_t *p_j2k )\n{\n        /* loop */\n        OPJ_UINT32 i;\n        opj_cp_t *l_cp = NULL;\n        opj_tcp_t *l_tcp = NULL;\n        opj_tccp_t *l_ref_tccp = NULL, *l_copied_tccp = NULL;\n        OPJ_UINT32 l_prc_size;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ? /* FIXME J2K_DEC_STATE_TPH*/\n                                &l_cp->tcps[p_j2k->m_current_tile_number] :\n                                p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n        l_ref_tccp = &l_tcp->tccps[0];\n        l_copied_tccp = l_ref_tccp + 1;\n        l_prc_size = l_ref_tccp->numresolutions * (OPJ_UINT32)sizeof(OPJ_UINT32);\n\n        for     (i=1; i<p_j2k->m_private_image->numcomps; ++i) {\n                l_copied_tccp->numresolutions = l_ref_tccp->numresolutions;\n                l_copied_tccp->cblkw = l_ref_tccp->cblkw;\n                l_copied_tccp->cblkh = l_ref_tccp->cblkh;\n                l_copied_tccp->cblksty = l_ref_tccp->cblksty;\n                l_copied_tccp->qmfbid = l_ref_tccp->qmfbid;\n                memcpy(l_copied_tccp->prcw,l_ref_tccp->prcw,l_prc_size);\n                memcpy(l_copied_tccp->prch,l_ref_tccp->prch,l_prc_size);\n                ++l_copied_tccp;\n        }\n}\n\nstatic OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size ( opj_j2k_t *p_j2k,\n                                                                        OPJ_UINT32 p_tile_no,\n                                                                        OPJ_UINT32 p_comp_no )\n{\n        OPJ_UINT32 l_num_bands;\n\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_tccp_t *l_tccp = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = &l_cp->tcps[p_tile_no];\n        l_tccp = &l_tcp->tccps[p_comp_no];\n\n        /* preconditions again */\n        assert(p_tile_no < l_cp->tw * l_cp->th);\n        assert(p_comp_no < p_j2k->m_private_image->numcomps);\n\n        l_num_bands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 : (l_tccp->numresolutions * 3 - 2);\n\n        if (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT)  {\n                return 1 + l_num_bands;\n        }\n        else {\n                return 1 + 2*l_num_bands;\n        }\n}\n\nstatic OPJ_BOOL opj_j2k_compare_SQcd_SQcc(opj_j2k_t *p_j2k, OPJ_UINT32 p_tile_no, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no)\n{\n\topj_cp_t *l_cp = NULL;\n\topj_tcp_t *l_tcp = NULL;\n\topj_tccp_t *l_tccp0 = NULL;\n\topj_tccp_t *l_tccp1 = NULL;\n\tOPJ_UINT32 l_band_no, l_num_bands;\n\t\n\t/* preconditions */\n\tassert(p_j2k != 00);\n\t\n\tl_cp = &(p_j2k->m_cp);\n\tl_tcp = &l_cp->tcps[p_tile_no];\n\tl_tccp0 = &l_tcp->tccps[p_first_comp_no];\n\tl_tccp1 = &l_tcp->tccps[p_second_comp_no];\n\t\n\tif (l_tccp0->qntsty != l_tccp1->qntsty ) {\n\t\treturn OPJ_FALSE;\n\t}\n\tif (l_tccp0->numgbits != l_tccp1->numgbits ) {\n\t\treturn OPJ_FALSE;\n\t}\n\tif (l_tccp0->qntsty == J2K_CCP_QNTSTY_SIQNT) {\n\t\tl_num_bands = 1U;\n\t} else {\n\t\tl_num_bands = l_tccp0->numresolutions * 3U - 2U;\n\t\tif (l_num_bands != (l_tccp1->numresolutions * 3U - 2U)) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t}\n\t\n\tfor (l_band_no = 0; l_band_no < l_num_bands; ++l_band_no) {\n\t\tif (l_tccp0->stepsizes[l_band_no].expn != l_tccp1->stepsizes[l_band_no].expn ) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t}\n\tif (l_tccp0->qntsty != J2K_CCP_QNTSTY_NOQNT)\n\t{\n\t\tfor (l_band_no = 0; l_band_no < l_num_bands; ++l_band_no) {\n\t\t\tif (l_tccp0->stepsizes[l_band_no].mant != l_tccp1->stepsizes[l_band_no].mant ) {\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\treturn OPJ_TRUE;\n}\n\n\nstatic OPJ_BOOL opj_j2k_write_SQcd_SQcc(       opj_j2k_t *p_j2k,\n                                                                OPJ_UINT32 p_tile_no,\n                                                                OPJ_UINT32 p_comp_no,\n                                                                OPJ_BYTE * p_data,\n                                                                OPJ_UINT32 * p_header_size,\n                                                                struct opj_event_mgr * p_manager )\n{\n        OPJ_UINT32 l_header_size;\n        OPJ_UINT32 l_band_no, l_num_bands;\n        OPJ_UINT32 l_expn,l_mant;\n\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_tccp_t *l_tccp = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_header_size != 00);\n        assert(p_manager != 00);\n        assert(p_data != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = &l_cp->tcps[p_tile_no];\n        l_tccp = &l_tcp->tccps[p_comp_no];\n\n        /* preconditions again */\n        assert(p_tile_no < l_cp->tw * l_cp->th);\n        assert(p_comp_no <p_j2k->m_private_image->numcomps);\n\n        l_num_bands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 : (l_tccp->numresolutions * 3 - 2);\n\n        if (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT)  {\n                l_header_size = 1 + l_num_bands;\n\n                if (*p_header_size < l_header_size) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error writing SQcd SQcc element\\n\");\n                        return OPJ_FALSE;\n                }\n\n                opj_write_bytes(p_data,l_tccp->qntsty + (l_tccp->numgbits << 5), 1);    /* Sqcx */\n                ++p_data;\n\n                for (l_band_no = 0; l_band_no < l_num_bands; ++l_band_no) {\n                        l_expn = (OPJ_UINT32)l_tccp->stepsizes[l_band_no].expn;\n                        opj_write_bytes(p_data, l_expn << 3, 1);        /* SPqcx_i */\n                        ++p_data;\n                }\n        }\n        else {\n                l_header_size = 1 + 2*l_num_bands;\n\n                if (*p_header_size < l_header_size) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error writing SQcd SQcc element\\n\");\n                        return OPJ_FALSE;\n                }\n\n                opj_write_bytes(p_data,l_tccp->qntsty + (l_tccp->numgbits << 5), 1);    /* Sqcx */\n                ++p_data;\n\n                for (l_band_no = 0; l_band_no < l_num_bands; ++l_band_no) {\n                        l_expn = (OPJ_UINT32)l_tccp->stepsizes[l_band_no].expn;\n                        l_mant = (OPJ_UINT32)l_tccp->stepsizes[l_band_no].mant;\n\n                        opj_write_bytes(p_data, (l_expn << 11) + l_mant, 2);    /* SPqcx_i */\n                        p_data += 2;\n                }\n        }\n\n        *p_header_size = *p_header_size - l_header_size;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k,\n                                                            OPJ_UINT32 p_comp_no,\n                                                            OPJ_BYTE* p_header_data,\n                                                            OPJ_UINT32 * p_header_size,\n                                                            opj_event_mgr_t * p_manager\n                                                            )\n{\n        /* loop*/\n        OPJ_UINT32 l_band_no;\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_tccp_t *l_tccp = 00;\n        OPJ_BYTE * l_current_ptr = 00;\n        OPJ_UINT32 l_tmp, l_num_band;\n\n        /* preconditions*/\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_header_data != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        /* come from tile part header or main header ?*/\n        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ? /*FIXME J2K_DEC_STATE_TPH*/\n                                &l_cp->tcps[p_j2k->m_current_tile_number] :\n                                p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n        /* precondition again*/\n        assert(p_comp_no <  p_j2k->m_private_image->numcomps);\n\n        l_tccp = &l_tcp->tccps[p_comp_no];\n        l_current_ptr = p_header_data;\n\n        if (*p_header_size < 1) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading SQcd or SQcc element\\n\");\n                return OPJ_FALSE;\n        }\n        *p_header_size -= 1;\n\n        opj_read_bytes(l_current_ptr, &l_tmp ,1);                       /* Sqcx */\n        ++l_current_ptr;\n\n        l_tccp->qntsty = l_tmp & 0x1f;\n        l_tccp->numgbits = l_tmp >> 5;\n        if (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) {\n        l_num_band = 1;\n        }\n        else {\n                l_num_band = (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) ?\n                        (*p_header_size) :\n                        (*p_header_size) / 2;\n\n                if( l_num_band > OPJ_J2K_MAXBANDS ) {\n                        opj_event_msg(p_manager, EVT_WARNING, \"While reading CCP_QNTSTY element inside QCD or QCC marker segment, \"\n                                \"number of subbands (%d) is greater to OPJ_J2K_MAXBANDS (%d). So we limit the number of elements stored to \"\n                                \"OPJ_J2K_MAXBANDS (%d) and skip the rest. \\n\", l_num_band, OPJ_J2K_MAXBANDS, OPJ_J2K_MAXBANDS);\n                        /*return OPJ_FALSE;*/\n                }\n        }\n\n#ifdef USE_JPWL\n        if (l_cp->correct) {\n\n                /* if JPWL is on, we check whether there are too many subbands */\n                if (/*(l_num_band < 0) ||*/ (l_num_band >= OPJ_J2K_MAXBANDS)) {\n                        opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,\n                                \"JPWL: bad number of subbands in Sqcx (%d)\\n\",\n                                l_num_band);\n                        if (!JPWL_ASSUME) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                return OPJ_FALSE;\n                        }\n                        /* we try to correct */\n                        l_num_band = 1;\n                        opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust them\\n\"\n                                \"- setting number of bands to %d => HYPOTHESIS!!!\\n\",\n                                l_num_band);\n                };\n\n        };\n#endif /* USE_JPWL */\n\n        if (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) {\n                for     (l_band_no = 0; l_band_no < l_num_band; l_band_no++) {\n                        opj_read_bytes(l_current_ptr, &l_tmp ,1);                       /* SPqcx_i */\n                        ++l_current_ptr;\n                        if (l_band_no < OPJ_J2K_MAXBANDS){\n                                l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32)(l_tmp >> 3);\n                                l_tccp->stepsizes[l_band_no].mant = 0;\n                        }\n                }\n                *p_header_size = *p_header_size - l_num_band;\n        }\n        else {\n                for     (l_band_no = 0; l_band_no < l_num_band; l_band_no++) {\n                        opj_read_bytes(l_current_ptr, &l_tmp ,2);                       /* SPqcx_i */\n                        l_current_ptr+=2;\n                        if (l_band_no < OPJ_J2K_MAXBANDS){\n                                l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32)(l_tmp >> 11);\n                                l_tccp->stepsizes[l_band_no].mant = l_tmp & 0x7ff;\n                        }\n                }\n                *p_header_size = *p_header_size - 2*l_num_band;\n        }\n\n        /* Add Antonin : if scalar_derived -> compute other stepsizes */\n        if (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) {\n                for (l_band_no = 1; l_band_no < OPJ_J2K_MAXBANDS; l_band_no++) {\n                        l_tccp->stepsizes[l_band_no].expn =\n                                ((OPJ_INT32)(l_tccp->stepsizes[0].expn) - (OPJ_INT32)((l_band_no - 1) / 3) > 0) ?\n                                        (OPJ_INT32)(l_tccp->stepsizes[0].expn) - (OPJ_INT32)((l_band_no - 1) / 3) : 0;\n                        l_tccp->stepsizes[l_band_no].mant = l_tccp->stepsizes[0].mant;\n                }\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic void opj_j2k_copy_tile_quantization_parameters( opj_j2k_t *p_j2k )\n{\n        OPJ_UINT32 i;\n        opj_cp_t *l_cp = NULL;\n        opj_tcp_t *l_tcp = NULL;\n        opj_tccp_t *l_ref_tccp = NULL;\n        opj_tccp_t *l_copied_tccp = NULL;\n        OPJ_UINT32 l_size;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?\n                        &l_cp->tcps[p_j2k->m_current_tile_number] :\n                        p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n        l_ref_tccp = &l_tcp->tccps[0];\n        l_copied_tccp = l_ref_tccp + 1;\n        l_size = OPJ_J2K_MAXBANDS * sizeof(opj_stepsize_t);\n\n        for     (i=1;i<p_j2k->m_private_image->numcomps;++i) {\n                l_copied_tccp->qntsty = l_ref_tccp->qntsty;\n                l_copied_tccp->numgbits = l_ref_tccp->numgbits;\n                memcpy(l_copied_tccp->stepsizes,l_ref_tccp->stepsizes,l_size);\n                ++l_copied_tccp;\n        }\n}\n\nstatic void opj_j2k_dump_tile_info( opj_tcp_t * l_default_tile,OPJ_INT32 numcomps,FILE* out_stream)\n{\n        if (l_default_tile)\n        {\n                OPJ_INT32 compno;\n\n                fprintf(out_stream, \"\\t default tile {\\n\");\n                fprintf(out_stream, \"\\t\\t csty=%#x\\n\", l_default_tile->csty);\n                fprintf(out_stream, \"\\t\\t prg=%#x\\n\", l_default_tile->prg);\n                fprintf(out_stream, \"\\t\\t numlayers=%d\\n\", l_default_tile->numlayers);\n                fprintf(out_stream, \"\\t\\t mct=%x\\n\", l_default_tile->mct);\n\n                for (compno = 0; compno < numcomps; compno++) {\n                        opj_tccp_t *l_tccp = &(l_default_tile->tccps[compno]);\n                        OPJ_UINT32 resno;\n      OPJ_INT32 bandno, numbands;\n\n                        /* coding style*/\n                        fprintf(out_stream, \"\\t\\t comp %d {\\n\", compno);\n                        fprintf(out_stream, \"\\t\\t\\t csty=%#x\\n\", l_tccp->csty);\n                        fprintf(out_stream, \"\\t\\t\\t numresolutions=%d\\n\", l_tccp->numresolutions);\n                        fprintf(out_stream, \"\\t\\t\\t cblkw=2^%d\\n\", l_tccp->cblkw);\n                        fprintf(out_stream, \"\\t\\t\\t cblkh=2^%d\\n\", l_tccp->cblkh);\n                        fprintf(out_stream, \"\\t\\t\\t cblksty=%#x\\n\", l_tccp->cblksty);\n                        fprintf(out_stream, \"\\t\\t\\t qmfbid=%d\\n\", l_tccp->qmfbid);\n\n                        fprintf(out_stream, \"\\t\\t\\t preccintsize (w,h)=\");\n                        for (resno = 0; resno < l_tccp->numresolutions; resno++) {\n                                fprintf(out_stream, \"(%d,%d) \", l_tccp->prcw[resno], l_tccp->prch[resno]);\n                        }\n                        fprintf(out_stream, \"\\n\");\n\n                        /* quantization style*/\n                        fprintf(out_stream, \"\\t\\t\\t qntsty=%d\\n\", l_tccp->qntsty);\n                        fprintf(out_stream, \"\\t\\t\\t numgbits=%d\\n\", l_tccp->numgbits);\n                        fprintf(out_stream, \"\\t\\t\\t stepsizes (m,e)=\");\n                        numbands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 : (OPJ_INT32)l_tccp->numresolutions * 3 - 2;\n                        for (bandno = 0; bandno < numbands; bandno++) {\n                                fprintf(out_stream, \"(%d,%d) \", l_tccp->stepsizes[bandno].mant,\n                                        l_tccp->stepsizes[bandno].expn);\n                        }\n                        fprintf(out_stream, \"\\n\");\n\n                        /* RGN value*/\n                        fprintf(out_stream, \"\\t\\t\\t roishift=%d\\n\", l_tccp->roishift);\n\n                        fprintf(out_stream, \"\\t\\t }\\n\");\n                } /*end of component of default tile*/\n                fprintf(out_stream, \"\\t }\\n\"); /*end of default tile*/\n            }\n}\n\nvoid j2k_dump (opj_j2k_t* p_j2k, OPJ_INT32 flag, FILE* out_stream)\n{\n        /* Check if the flag is compatible with j2k file*/\n        if ( (flag & OPJ_JP2_INFO) || (flag & OPJ_JP2_IND)){\n                fprintf(out_stream, \"Wrong flag\\n\");\n                return;\n        }\n\n        /* Dump the image_header */\n        if (flag & OPJ_IMG_INFO){\n                if (p_j2k->m_private_image)\n                        j2k_dump_image_header(p_j2k->m_private_image, 0, out_stream);\n        }\n\n        /* Dump the codestream info from main header */\n        if (flag & OPJ_J2K_MH_INFO){\n                if (p_j2k->m_private_image)\n                        opj_j2k_dump_MH_info(p_j2k, out_stream);\n        }\n        /* Dump all tile/codestream info */\n        if (flag & OPJ_J2K_TCH_INFO){\n          OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n          OPJ_UINT32 i;\n          opj_tcp_t * l_tcp = p_j2k->m_cp.tcps;\n          if (p_j2k->m_private_image) {\n            for (i=0;i<l_nb_tiles;++i) {\n              opj_j2k_dump_tile_info( l_tcp,(OPJ_INT32)p_j2k->m_private_image->numcomps, out_stream);\n              ++l_tcp;\n            }\n          }\n        }\n\n        /* Dump the codestream info of the current tile */\n        if (flag & OPJ_J2K_TH_INFO){\n\n        }\n\n        /* Dump the codestream index from main header */\n        if (flag & OPJ_J2K_MH_IND){\n                opj_j2k_dump_MH_index(p_j2k, out_stream);\n        }\n\n        /* Dump the codestream index of the current tile */\n        if (flag & OPJ_J2K_TH_IND){\n\n        }\n\n}\n\nstatic void opj_j2k_dump_MH_index(opj_j2k_t* p_j2k, FILE* out_stream)\n{\n        opj_codestream_index_t* cstr_index = p_j2k->cstr_index;\n        OPJ_UINT32 it_marker, it_tile, it_tile_part;\n\n        fprintf(out_stream, \"Codestream index from main header: {\\n\");\n\n        fprintf(out_stream, \"\\t Main header start position=%\" PRIi64 \"\\n\"\n                                    \"\\t Main header end position=%\" PRIi64 \"\\n\",\n                        cstr_index->main_head_start, cstr_index->main_head_end);\n\n        fprintf(out_stream, \"\\t Marker list: {\\n\");\n\n        if (cstr_index->marker){\n                for (it_marker=0; it_marker < cstr_index->marknum ; it_marker++){\n                        fprintf(out_stream, \"\\t\\t type=%#x, pos=%\" PRIi64 \", len=%d\\n\",\n                                        cstr_index->marker[it_marker].type,\n                                        cstr_index->marker[it_marker].pos,\n                                        cstr_index->marker[it_marker].len );\n                }\n        }\n\n        fprintf(out_stream, \"\\t }\\n\");\n\n        if (cstr_index->tile_index){\n\n        /* Simple test to avoid to write empty information*/\n        OPJ_UINT32 l_acc_nb_of_tile_part = 0;\n        for (it_tile=0; it_tile < cstr_index->nb_of_tiles ; it_tile++){\n                        l_acc_nb_of_tile_part += cstr_index->tile_index[it_tile].nb_tps;\n        }\n\n        if (l_acc_nb_of_tile_part)\n        {\n            fprintf(out_stream, \"\\t Tile index: {\\n\");\n\n                    for (it_tile=0; it_tile < cstr_index->nb_of_tiles ; it_tile++){\n                            OPJ_UINT32 nb_of_tile_part = cstr_index->tile_index[it_tile].nb_tps;\n\n                            fprintf(out_stream, \"\\t\\t nb of tile-part in tile [%d]=%d\\n\", it_tile, nb_of_tile_part);\n\n                            if (cstr_index->tile_index[it_tile].tp_index){\n                                    for (it_tile_part =0; it_tile_part < nb_of_tile_part; it_tile_part++){\n                                            fprintf(out_stream, \"\\t\\t\\t tile-part[%d]: star_pos=%\" PRIi64 \", end_header=%\" PRIi64 \", end_pos=%\" PRIi64 \".\\n\",\n                                                            it_tile_part,\n                                                            cstr_index->tile_index[it_tile].tp_index[it_tile_part].start_pos,\n                                                            cstr_index->tile_index[it_tile].tp_index[it_tile_part].end_header,\n                                                            cstr_index->tile_index[it_tile].tp_index[it_tile_part].end_pos);\n                                    }\n                            }\n\n                            if (cstr_index->tile_index[it_tile].marker){\n                                    for (it_marker=0; it_marker < cstr_index->tile_index[it_tile].marknum ; it_marker++){\n                                            fprintf(out_stream, \"\\t\\t type=%#x, pos=%\" PRIi64 \", len=%d\\n\",\n                                                            cstr_index->tile_index[it_tile].marker[it_marker].type,\n                                                            cstr_index->tile_index[it_tile].marker[it_marker].pos,\n                                                            cstr_index->tile_index[it_tile].marker[it_marker].len );\n                                    }\n                            }\n                    }\n                    fprintf(out_stream,\"\\t }\\n\");\n        }\n        }\n\n        fprintf(out_stream,\"}\\n\");\n\n}\n\n\nstatic void opj_j2k_dump_MH_info(opj_j2k_t* p_j2k, FILE* out_stream)\n{\n\n        fprintf(out_stream, \"Codestream info from main header: {\\n\");\n\n        fprintf(out_stream, \"\\t tx0=%d, ty0=%d\\n\", p_j2k->m_cp.tx0, p_j2k->m_cp.ty0);\n        fprintf(out_stream, \"\\t tdx=%d, tdy=%d\\n\", p_j2k->m_cp.tdx, p_j2k->m_cp.tdy);\n        fprintf(out_stream, \"\\t tw=%d, th=%d\\n\", p_j2k->m_cp.tw, p_j2k->m_cp.th);\n        opj_j2k_dump_tile_info(p_j2k->m_specific_param.m_decoder.m_default_tcp,(OPJ_INT32)p_j2k->m_private_image->numcomps, out_stream);\n        fprintf(out_stream, \"}\\n\");\n}\n\nvoid j2k_dump_image_header(opj_image_t* img_header, OPJ_BOOL dev_dump_flag, FILE* out_stream)\n{\n        char tab[2];\n\n        if (dev_dump_flag){\n                fprintf(stdout, \"[DEV] Dump an image_header struct {\\n\");\n                tab[0] = '\\0';\n        }\n        else {\n                fprintf(out_stream, \"Image info {\\n\");\n                tab[0] = '\\t';tab[1] = '\\0';\n        }\n\n        fprintf(out_stream, \"%s x0=%d, y0=%d\\n\", tab, img_header->x0, img_header->y0);\n        fprintf(out_stream,     \"%s x1=%d, y1=%d\\n\", tab, img_header->x1, img_header->y1);\n        fprintf(out_stream, \"%s numcomps=%d\\n\", tab, img_header->numcomps);\n\n        if (img_header->comps){\n                OPJ_UINT32 compno;\n                for (compno = 0; compno < img_header->numcomps; compno++) {\n                        fprintf(out_stream, \"%s\\t component %d {\\n\", tab, compno);\n                        j2k_dump_image_comp_header(&(img_header->comps[compno]), dev_dump_flag, out_stream);\n                        fprintf(out_stream,\"%s}\\n\",tab);\n                }\n        }\n\n        fprintf(out_stream, \"}\\n\");\n}\n\nvoid j2k_dump_image_comp_header(opj_image_comp_t* comp_header, OPJ_BOOL dev_dump_flag, FILE* out_stream)\n{\n        char tab[3];\n\n        if (dev_dump_flag){\n                fprintf(stdout, \"[DEV] Dump an image_comp_header struct {\\n\");\n                tab[0] = '\\0';\n        }       else {\n                tab[0] = '\\t';tab[1] = '\\t';tab[2] = '\\0';\n        }\n\n        fprintf(out_stream, \"%s dx=%d, dy=%d\\n\", tab, comp_header->dx, comp_header->dy);\n        fprintf(out_stream, \"%s prec=%d\\n\", tab, comp_header->prec);\n        fprintf(out_stream, \"%s sgnd=%d\\n\", tab, comp_header->sgnd);\n\n        if (dev_dump_flag)\n                fprintf(out_stream, \"}\\n\");\n}\n\nopj_codestream_info_v2_t* j2k_get_cstr_info(opj_j2k_t* p_j2k)\n{\n        OPJ_UINT32 compno;\n        OPJ_UINT32 numcomps = p_j2k->m_private_image->numcomps;\n        opj_tcp_t *l_default_tile;\n        opj_codestream_info_v2_t* cstr_info = (opj_codestream_info_v2_t*) opj_calloc(1,sizeof(opj_codestream_info_v2_t));\n\t\tif (!cstr_info)\n\t\t\treturn NULL;\n\n        cstr_info->nbcomps = p_j2k->m_private_image->numcomps;\n\n        cstr_info->tx0 = p_j2k->m_cp.tx0;\n        cstr_info->ty0 = p_j2k->m_cp.ty0;\n        cstr_info->tdx = p_j2k->m_cp.tdx;\n        cstr_info->tdy = p_j2k->m_cp.tdy;\n        cstr_info->tw = p_j2k->m_cp.tw;\n        cstr_info->th = p_j2k->m_cp.th;\n\n        cstr_info->tile_info = NULL; /* Not fill from the main header*/\n\n        l_default_tile = p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n        cstr_info->m_default_tile_info.csty = l_default_tile->csty;\n        cstr_info->m_default_tile_info.prg = l_default_tile->prg;\n        cstr_info->m_default_tile_info.numlayers = l_default_tile->numlayers;\n        cstr_info->m_default_tile_info.mct = l_default_tile->mct;\n\n        cstr_info->m_default_tile_info.tccp_info = (opj_tccp_info_t*) opj_calloc(cstr_info->nbcomps, sizeof(opj_tccp_info_t));\n\t\tif (!cstr_info->m_default_tile_info.tccp_info)\n\t\t{\n\t\t\topj_destroy_cstr_info(&cstr_info);\n\t\t\treturn NULL;\n\t\t}\n\n        for (compno = 0; compno < numcomps; compno++) {\n                opj_tccp_t *l_tccp = &(l_default_tile->tccps[compno]);\n                opj_tccp_info_t *l_tccp_info = &(cstr_info->m_default_tile_info.tccp_info[compno]);\n                OPJ_INT32 bandno, numbands;\n\n                /* coding style*/\n                l_tccp_info->csty = l_tccp->csty;\n                l_tccp_info->numresolutions = l_tccp->numresolutions;\n                l_tccp_info->cblkw = l_tccp->cblkw;\n                l_tccp_info->cblkh = l_tccp->cblkh;\n                l_tccp_info->cblksty = l_tccp->cblksty;\n                l_tccp_info->qmfbid = l_tccp->qmfbid;\n                if (l_tccp->numresolutions < OPJ_J2K_MAXRLVLS)\n                {\n                        memcpy(l_tccp_info->prch, l_tccp->prch, l_tccp->numresolutions);\n                        memcpy(l_tccp_info->prcw, l_tccp->prcw, l_tccp->numresolutions);\n                }\n\n                /* quantization style*/\n                l_tccp_info->qntsty = l_tccp->qntsty;\n                l_tccp_info->numgbits = l_tccp->numgbits;\n\n                numbands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 : (OPJ_INT32)l_tccp->numresolutions * 3 - 2;\n                if (numbands < OPJ_J2K_MAXBANDS) {\n                        for (bandno = 0; bandno < numbands; bandno++) {\n                                l_tccp_info->stepsizes_mant[bandno] = (OPJ_UINT32)l_tccp->stepsizes[bandno].mant;\n                                l_tccp_info->stepsizes_expn[bandno] = (OPJ_UINT32)l_tccp->stepsizes[bandno].expn;\n                        }\n                }\n\n                /* RGN value*/\n                l_tccp_info->roishift = l_tccp->roishift;\n        }\n\n        return cstr_info;\n}\n\nopj_codestream_index_t* j2k_get_cstr_index(opj_j2k_t* p_j2k)\n{\n        opj_codestream_index_t* l_cstr_index = (opj_codestream_index_t*)\n                        opj_calloc(1,sizeof(opj_codestream_index_t));\n        if (!l_cstr_index)\n                return NULL;\n\n        l_cstr_index->main_head_start = p_j2k->cstr_index->main_head_start;\n        l_cstr_index->main_head_end = p_j2k->cstr_index->main_head_end;\n        l_cstr_index->codestream_size = p_j2k->cstr_index->codestream_size;\n\n        l_cstr_index->marknum = p_j2k->cstr_index->marknum;\n        l_cstr_index->marker = (opj_marker_info_t*)opj_malloc(l_cstr_index->marknum*sizeof(opj_marker_info_t));\n        if (!l_cstr_index->marker){\n                opj_free( l_cstr_index);\n                return NULL;\n        }\n\n        if (p_j2k->cstr_index->marker)\n                memcpy(l_cstr_index->marker, p_j2k->cstr_index->marker, l_cstr_index->marknum * sizeof(opj_marker_info_t) );\n        else{\n                opj_free(l_cstr_index->marker);\n                l_cstr_index->marker = NULL;\n        }\n\n        l_cstr_index->nb_of_tiles = p_j2k->cstr_index->nb_of_tiles;\n        l_cstr_index->tile_index = (opj_tile_index_t*)opj_calloc(l_cstr_index->nb_of_tiles, sizeof(opj_tile_index_t) );\n        if (!l_cstr_index->tile_index){\n                opj_free( l_cstr_index->marker);\n                opj_free( l_cstr_index);\n                return NULL;\n        }\n\n        if (!p_j2k->cstr_index->tile_index){\n                opj_free(l_cstr_index->tile_index);\n                l_cstr_index->tile_index = NULL;\n        }\n        else {\n                OPJ_UINT32 it_tile = 0;\n                for (it_tile = 0; it_tile < l_cstr_index->nb_of_tiles; it_tile++ ){\n\n                        /* Tile Marker*/\n                        l_cstr_index->tile_index[it_tile].marknum = p_j2k->cstr_index->tile_index[it_tile].marknum;\n\n                        l_cstr_index->tile_index[it_tile].marker =\n                                (opj_marker_info_t*)opj_malloc(l_cstr_index->tile_index[it_tile].marknum*sizeof(opj_marker_info_t));\n\n                        if (!l_cstr_index->tile_index[it_tile].marker) {\n                                OPJ_UINT32 it_tile_free;\n\n                                for (it_tile_free=0; it_tile_free < it_tile; it_tile_free++){\n                                        opj_free(l_cstr_index->tile_index[it_tile_free].marker);\n                                }\n\n                                opj_free( l_cstr_index->tile_index);\n                                opj_free( l_cstr_index->marker);\n                                opj_free( l_cstr_index);\n                                return NULL;\n                        }\n\n                        if (p_j2k->cstr_index->tile_index[it_tile].marker)\n                                memcpy( l_cstr_index->tile_index[it_tile].marker,\n                                                p_j2k->cstr_index->tile_index[it_tile].marker,\n                                                l_cstr_index->tile_index[it_tile].marknum * sizeof(opj_marker_info_t) );\n                        else{\n                                opj_free(l_cstr_index->tile_index[it_tile].marker);\n                                l_cstr_index->tile_index[it_tile].marker = NULL;\n                        }\n\n                        /* Tile part index*/\n                        l_cstr_index->tile_index[it_tile].nb_tps = p_j2k->cstr_index->tile_index[it_tile].nb_tps;\n\n                        l_cstr_index->tile_index[it_tile].tp_index =\n                                (opj_tp_index_t*)opj_malloc(l_cstr_index->tile_index[it_tile].nb_tps*sizeof(opj_tp_index_t));\n\n                        if(!l_cstr_index->tile_index[it_tile].tp_index){\n                                OPJ_UINT32 it_tile_free;\n\n                                for (it_tile_free=0; it_tile_free < it_tile; it_tile_free++){\n                                        opj_free(l_cstr_index->tile_index[it_tile_free].marker);\n                                        opj_free(l_cstr_index->tile_index[it_tile_free].tp_index);\n                                }\n\n                                opj_free( l_cstr_index->tile_index);\n                                opj_free( l_cstr_index->marker);\n                                opj_free( l_cstr_index);\n                                return NULL;\n                        }\n\n                        if (p_j2k->cstr_index->tile_index[it_tile].tp_index){\n                                memcpy( l_cstr_index->tile_index[it_tile].tp_index,\n                                                p_j2k->cstr_index->tile_index[it_tile].tp_index,\n                                                l_cstr_index->tile_index[it_tile].nb_tps * sizeof(opj_tp_index_t) );\n                        }\n                        else{\n                                opj_free(l_cstr_index->tile_index[it_tile].tp_index);\n                                l_cstr_index->tile_index[it_tile].tp_index = NULL;\n                        }\n\n                        /* Packet index (NOT USED)*/\n                        l_cstr_index->tile_index[it_tile].nb_packet = 0;\n                        l_cstr_index->tile_index[it_tile].packet_index = NULL;\n\n                }\n        }\n\n        return l_cstr_index;\n}\n\nstatic OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k)\n{\n        OPJ_UINT32 it_tile=0;\n\n        p_j2k->cstr_index->nb_of_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;\n        p_j2k->cstr_index->tile_index = (opj_tile_index_t*)opj_calloc(p_j2k->cstr_index->nb_of_tiles, sizeof(opj_tile_index_t));\n        if (!p_j2k->cstr_index->tile_index)\n                return OPJ_FALSE;\n\n        for (it_tile=0; it_tile < p_j2k->cstr_index->nb_of_tiles; it_tile++){\n                p_j2k->cstr_index->tile_index[it_tile].maxmarknum = 100;\n                p_j2k->cstr_index->tile_index[it_tile].marknum = 0;\n                p_j2k->cstr_index->tile_index[it_tile].marker = (opj_marker_info_t*)\n                                opj_calloc(p_j2k->cstr_index->tile_index[it_tile].maxmarknum, sizeof(opj_marker_info_t));\n                if (!p_j2k->cstr_index->tile_index[it_tile].marker)\n                        return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_decode_tiles ( opj_j2k_t *p_j2k,\n                                                            opj_stream_private_t *p_stream,\n                                                            opj_event_mgr_t * p_manager)\n{\n        OPJ_BOOL l_go_on = OPJ_TRUE;\n        OPJ_UINT32 l_current_tile_no;\n        OPJ_UINT32 l_data_size,l_max_data_size;\n        OPJ_INT32 l_tile_x0,l_tile_y0,l_tile_x1,l_tile_y1;\n        OPJ_UINT32 l_nb_comps;\n        OPJ_BYTE * l_current_data;\n        OPJ_UINT32 nr_tiles = 0;\n\n        l_current_data = (OPJ_BYTE*)opj_malloc(1000);\n        if (! l_current_data) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to decode tiles\\n\");\n                return OPJ_FALSE;\n        }\n        l_max_data_size = 1000;\n\n\t\tfor (;;) {\n                if (! opj_j2k_read_tile_header( p_j2k,\n                                        &l_current_tile_no,\n                                        &l_data_size,\n                                        &l_tile_x0, &l_tile_y0,\n                                        &l_tile_x1, &l_tile_y1,\n                                        &l_nb_comps,\n                                        &l_go_on,\n                                        p_stream,\n                                        p_manager)) {\n                        opj_free(l_current_data);\n                        return OPJ_FALSE;\n                }\n\n                if (! l_go_on) {\n                        break;\n                }\n\n                if (l_data_size > l_max_data_size) {\n                        OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(l_current_data, l_data_size);\n                        if (! l_new_current_data) {\n                                opj_free(l_current_data);\n                                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to decode tile %d/%d\\n\", l_current_tile_no +1, p_j2k->m_cp.th * p_j2k->m_cp.tw);\n                                return OPJ_FALSE;\n                        }\n                        l_current_data = l_new_current_data;\n                        l_max_data_size = l_data_size;\n                }\n\n                if (! opj_j2k_decode_tile(p_j2k,l_current_tile_no,l_current_data,l_data_size,p_stream,p_manager)) {\n                        opj_free(l_current_data);\n                        opj_event_msg(p_manager, EVT_ERROR, \"Failed to decode tile %d/%d\\n\", l_current_tile_no +1, p_j2k->m_cp.th * p_j2k->m_cp.tw);\n                        return OPJ_FALSE;\n                }\n                opj_event_msg(p_manager, EVT_INFO, \"Tile %d/%d has been decoded.\\n\", l_current_tile_no +1, p_j2k->m_cp.th * p_j2k->m_cp.tw);\n\n                if (! opj_j2k_update_image_data(p_j2k->m_tcd,l_current_data, p_j2k->m_output_image)) {\n                        opj_free(l_current_data);\n                        return OPJ_FALSE;\n                }\n                opj_event_msg(p_manager, EVT_INFO, \"Image data has been updated with tile %d.\\n\\n\", l_current_tile_no + 1);\n                \n                if(opj_stream_get_number_byte_left(p_stream) == 0  \n                    && p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NEOC)\n                    break;\n                if(++nr_tiles ==  p_j2k->m_cp.th * p_j2k->m_cp.tw) \n                    break;\n        }\n\n        opj_free(l_current_data);\n\n        return OPJ_TRUE;\n}\n\n/**\n * Sets up the procedures to do on decoding data. Developpers wanting to extend the library can add their own reading procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_decoding (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager)\n{\n        /* preconditions*/\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_decode_tiles, p_manager)) {\n                return OPJ_FALSE;\n        }\n        /* DEVELOPER CORNER, add your custom procedures */\n\n        return OPJ_TRUE;\n}\n\n/*\n * Read and decode one tile.\n */\nstatic OPJ_BOOL opj_j2k_decode_one_tile (       opj_j2k_t *p_j2k,\n                                                                            opj_stream_private_t *p_stream,\n                                                                            opj_event_mgr_t * p_manager)\n{\n        OPJ_BOOL l_go_on = OPJ_TRUE;\n        OPJ_UINT32 l_current_tile_no;\n        OPJ_UINT32 l_tile_no_to_dec;\n        OPJ_UINT32 l_data_size,l_max_data_size;\n        OPJ_INT32 l_tile_x0,l_tile_y0,l_tile_x1,l_tile_y1;\n        OPJ_UINT32 l_nb_comps;\n        OPJ_BYTE * l_current_data;\n\n        l_current_data = (OPJ_BYTE*)opj_malloc(1000);\n        if (! l_current_data) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to decode one tile\\n\");\n                return OPJ_FALSE;\n        }\n        l_max_data_size = 1000;\n\n        /*Allocate and initialize some elements of codestrem index if not already done*/\n        if( !p_j2k->cstr_index->tile_index)\n        {\n                if (!opj_j2k_allocate_tile_element_cstr_index(p_j2k)){\n                        opj_free(l_current_data);\n                        return OPJ_FALSE;\n                }\n        }\n        /* Move into the codestream to the first SOT used to decode the desired tile */\n        l_tile_no_to_dec = (OPJ_UINT32)p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec;\n        if (p_j2k->cstr_index->tile_index)\n                if(p_j2k->cstr_index->tile_index->tp_index)\n                {\n                        if ( ! p_j2k->cstr_index->tile_index[l_tile_no_to_dec].nb_tps) {\n                                /* the index for this tile has not been built,\n                                 *  so move to the last SOT read */\n                                if ( !(opj_stream_read_seek(p_stream, p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos+2, p_manager)) ){\n                                        opj_event_msg(p_manager, EVT_ERROR, \"Problem with seek function\\n\");\n                                        opj_free(l_current_data);\n                                        return OPJ_FALSE;\n                                }\n                        }\n                        else{\n                                if ( !(opj_stream_read_seek(p_stream, p_j2k->cstr_index->tile_index[l_tile_no_to_dec].tp_index[0].start_pos+2, p_manager)) ) {\n                                        opj_event_msg(p_manager, EVT_ERROR, \"Problem with seek function\\n\");\n                                        opj_free(l_current_data);\n                                        return OPJ_FALSE;\n                                }\n                        }\n                        /* Special case if we have previously read the EOC marker (if the previous tile getted is the last ) */\n                        if(p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_EOC)\n                                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;\n                }\n\n\t\tfor (;;) {\n                if (! opj_j2k_read_tile_header( p_j2k,\n                                        &l_current_tile_no,\n                                        &l_data_size,\n                                        &l_tile_x0, &l_tile_y0,\n                                        &l_tile_x1, &l_tile_y1,\n                                        &l_nb_comps,\n                                        &l_go_on,\n                                        p_stream,\n                                        p_manager)) {\n                        opj_free(l_current_data);\n                        return OPJ_FALSE;\n                }\n\n                if (! l_go_on) {\n                        break;\n                }\n\n                if (l_data_size > l_max_data_size) {\n                        OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(l_current_data, l_data_size);\n                        if (! l_new_current_data) {\n                                opj_free(l_current_data);\n                                l_current_data = NULL;\n                                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to decode tile %d/%d\\n\", l_current_tile_no+1, p_j2k->m_cp.th * p_j2k->m_cp.tw);\n                                return OPJ_FALSE;\n                        }\n                        l_current_data = l_new_current_data;\n                        l_max_data_size = l_data_size;\n                }\n\n                if (! opj_j2k_decode_tile(p_j2k,l_current_tile_no,l_current_data,l_data_size,p_stream,p_manager)) {\n                        opj_free(l_current_data);\n                        return OPJ_FALSE;\n                }\n                opj_event_msg(p_manager, EVT_INFO, \"Tile %d/%d has been decoded.\\n\", l_current_tile_no+1, p_j2k->m_cp.th * p_j2k->m_cp.tw);\n\n                if (! opj_j2k_update_image_data(p_j2k->m_tcd,l_current_data, p_j2k->m_output_image)) {\n                        opj_free(l_current_data);\n                        return OPJ_FALSE;\n                }\n                opj_event_msg(p_manager, EVT_INFO, \"Image data has been updated with tile %d.\\n\\n\", l_current_tile_no+1);\n\n                if(l_current_tile_no == l_tile_no_to_dec)\n                {\n                        /* move into the codestream to the first SOT (FIXME or not move?)*/\n                        if (!(opj_stream_read_seek(p_stream, p_j2k->cstr_index->main_head_end + 2, p_manager) ) ) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Problem with seek function\\n\");\n                                opj_free(l_current_data);\n                                return OPJ_FALSE;\n                        }\n                        break;\n                }\n                else {\n                        opj_event_msg(p_manager, EVT_WARNING, \"Tile read, decoded and updated is not the desired one (%d vs %d).\\n\", l_current_tile_no+1, l_tile_no_to_dec+1);\n                }\n\n        }\n\n        opj_free(l_current_data);\n\n        return OPJ_TRUE;\n}\n\n/**\n * Sets up the procedures to do on decoding one tile. Developpers wanting to extend the library can add their own reading procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_decoding_tile (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager)\n{\n        /* preconditions*/\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_decode_one_tile, p_manager)) {\n                return OPJ_FALSE;\n        }\n        /* DEVELOPER CORNER, add your custom procedures */\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_decode(opj_j2k_t * p_j2k,\n                                                opj_stream_private_t * p_stream,\n                                                opj_image_t * p_image,\n                                                opj_event_mgr_t * p_manager)\n{\n        OPJ_UINT32 compno;\n\n        if (!p_image)\n                return OPJ_FALSE;\n\t\n        p_j2k->m_output_image = opj_image_create0();\n        if (! (p_j2k->m_output_image)) {\n                return OPJ_FALSE;\n        }\n        opj_copy_image_header(p_image, p_j2k->m_output_image);\n\n        /* customization of the decoding */\n        opj_j2k_setup_decoding(p_j2k, p_manager);\n\n        /* Decode the codestream */\n        if (! opj_j2k_exec (p_j2k,p_j2k->m_procedure_list,p_stream,p_manager)) {\n                opj_image_destroy(p_j2k->m_private_image);\n                p_j2k->m_private_image = NULL;\n                return OPJ_FALSE;\n        }\n\n        /* Move data and copy one information from codec to output image*/\n        for (compno = 0; compno < p_image->numcomps; compno++) {\n                p_image->comps[compno].resno_decoded = p_j2k->m_output_image->comps[compno].resno_decoded;\n                p_image->comps[compno].data = p_j2k->m_output_image->comps[compno].data;\n#if 0\n                char fn[256];\n                sprintf( fn, \"/tmp/%d.raw\", compno );\n                FILE *debug = fopen( fn, \"wb\" );\n                fwrite( p_image->comps[compno].data, sizeof(OPJ_INT32), p_image->comps[compno].w * p_image->comps[compno].h, debug );\n                fclose( debug );\n#endif\n                p_j2k->m_output_image->comps[compno].data = NULL;\n        }\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_get_tile(      opj_j2k_t *p_j2k,\n                                                    opj_stream_private_t *p_stream,\n                                                    opj_image_t* p_image,\n                                                    opj_event_mgr_t * p_manager,\n                                                    OPJ_UINT32 tile_index )\n{\n        OPJ_UINT32 compno;\n        OPJ_UINT32 l_tile_x, l_tile_y;\n        opj_image_comp_t* l_img_comp;\n\n        if (!p_image) {\n                opj_event_msg(p_manager, EVT_ERROR, \"We need an image previously created.\\n\");\n                return OPJ_FALSE;\n        }\n\n        if ( /*(tile_index < 0) &&*/ (tile_index >= p_j2k->m_cp.tw * p_j2k->m_cp.th) ){\n                opj_event_msg(p_manager, EVT_ERROR, \"Tile index provided by the user is incorrect %d (max = %d) \\n\", tile_index, (p_j2k->m_cp.tw * p_j2k->m_cp.th) - 1);\n                return OPJ_FALSE;\n        }\n\n        /* Compute the dimension of the desired tile*/\n        l_tile_x = tile_index % p_j2k->m_cp.tw;\n        l_tile_y = tile_index / p_j2k->m_cp.tw;\n\n        p_image->x0 = l_tile_x * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;\n        if (p_image->x0 < p_j2k->m_private_image->x0)\n                p_image->x0 = p_j2k->m_private_image->x0;\n        p_image->x1 = (l_tile_x + 1) * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;\n        if (p_image->x1 > p_j2k->m_private_image->x1)\n                p_image->x1 = p_j2k->m_private_image->x1;\n\n        p_image->y0 = l_tile_y * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;\n        if (p_image->y0 < p_j2k->m_private_image->y0)\n                p_image->y0 = p_j2k->m_private_image->y0;\n        p_image->y1 = (l_tile_y + 1) * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;\n        if (p_image->y1 > p_j2k->m_private_image->y1)\n                p_image->y1 = p_j2k->m_private_image->y1;\n\n        l_img_comp = p_image->comps;\n        for (compno=0; compno < p_image->numcomps; ++compno)\n        {\n                OPJ_INT32 l_comp_x1, l_comp_y1;\n\n                l_img_comp->factor = p_j2k->m_private_image->comps[compno].factor;\n\n                l_img_comp->x0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->x0, (OPJ_INT32)l_img_comp->dx);\n                l_img_comp->y0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->y0, (OPJ_INT32)l_img_comp->dy);\n                l_comp_x1 = opj_int_ceildiv((OPJ_INT32)p_image->x1, (OPJ_INT32)l_img_comp->dx);\n                l_comp_y1 = opj_int_ceildiv((OPJ_INT32)p_image->y1, (OPJ_INT32)l_img_comp->dy);\n\n                l_img_comp->w = (OPJ_UINT32)(opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32)l_img_comp->factor) - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->x0, (OPJ_INT32)l_img_comp->factor));\n                l_img_comp->h = (OPJ_UINT32)(opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32)l_img_comp->factor) - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->y0, (OPJ_INT32)l_img_comp->factor));\n\n                l_img_comp++;\n        }\n\n        /* Destroy the previous output image*/\n        if (p_j2k->m_output_image)\n                opj_image_destroy(p_j2k->m_output_image);\n\n        /* Create the ouput image from the information previously computed*/\n        p_j2k->m_output_image = opj_image_create0();\n        if (! (p_j2k->m_output_image)) {\n                return OPJ_FALSE;\n        }\n        opj_copy_image_header(p_image, p_j2k->m_output_image);\n\n        p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = (OPJ_INT32)tile_index;\n\n        /* customization of the decoding */\n        opj_j2k_setup_decoding_tile(p_j2k, p_manager);\n\n        /* Decode the codestream */\n        if (! opj_j2k_exec (p_j2k,p_j2k->m_procedure_list,p_stream,p_manager)) {\n                opj_image_destroy(p_j2k->m_private_image);\n                p_j2k->m_private_image = NULL;\n                return OPJ_FALSE;\n        }\n\n        /* Move data and copy one information from codec to output image*/\n        for (compno = 0; compno < p_image->numcomps; compno++) {\n                p_image->comps[compno].resno_decoded = p_j2k->m_output_image->comps[compno].resno_decoded;\n\n                if (p_image->comps[compno].data)\n                        opj_free(p_image->comps[compno].data);\n\n                p_image->comps[compno].data = p_j2k->m_output_image->comps[compno].data;\n\n                p_j2k->m_output_image->comps[compno].data = NULL;\n        }\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_set_decoded_resolution_factor(opj_j2k_t *p_j2k,\n                                               OPJ_UINT32 res_factor,\n                                               opj_event_mgr_t * p_manager)\n{\n        OPJ_UINT32 it_comp;\n\n        p_j2k->m_cp.m_specific_param.m_dec.m_reduce = res_factor;\n\n        if (p_j2k->m_private_image) {\n                if (p_j2k->m_private_image->comps) {\n                        if (p_j2k->m_specific_param.m_decoder.m_default_tcp) {\n                                if (p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps) {\n                                        for (it_comp = 0 ; it_comp < p_j2k->m_private_image->numcomps; it_comp++) {\n                                                OPJ_UINT32 max_res = p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps[it_comp].numresolutions;\n                                                if ( res_factor >= max_res){\n                                                        opj_event_msg(p_manager, EVT_ERROR, \"Resolution factor is greater than the maximum resolution in the component.\\n\");\n                                                        return OPJ_FALSE;\n                                                }\n                                                p_j2k->m_private_image->comps[it_comp].factor = res_factor;\n                                        }\n                                        return OPJ_TRUE;\n                                }\n                        }\n                }\n        }\n\n        return OPJ_FALSE;\n}\n\nOPJ_BOOL opj_j2k_encode(opj_j2k_t * p_j2k,\n                        opj_stream_private_t *p_stream,\n                        opj_event_mgr_t * p_manager )\n{\n        OPJ_UINT32 i, j;\n        OPJ_UINT32 l_nb_tiles;\n        OPJ_UINT32 l_max_tile_size = 0, l_current_tile_size;\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_BOOL l_reuse_data = OPJ_FALSE;\n        opj_tcd_t* p_tcd = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n\t\n        p_tcd = p_j2k->m_tcd;\n\n        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n        if (l_nb_tiles == 1) {\n                l_reuse_data = OPJ_TRUE;\n#ifdef __SSE__\n                for (j=0;j<p_j2k->m_tcd->image->numcomps;++j) {\n                        opj_image_comp_t * l_img_comp = p_tcd->image->comps + j;\n                        if (((size_t)l_img_comp->data & 0xFU) != 0U) { /* tile data shall be aligned on 16 bytes */\n\t\t\t\t\t\t\t\t\t\t\t\t        l_reuse_data = OPJ_FALSE;\n                        }\n                }\n#endif\n        }\n        for (i=0;i<l_nb_tiles;++i) {\n                if (! opj_j2k_pre_write_tile(p_j2k,i,p_stream,p_manager)) {\n                        if (l_current_data) {\n                                opj_free(l_current_data);\n                        }\n                        return OPJ_FALSE;\n                }\n\n                /* if we only have one tile, then simply set tile component data equal to image component data */\n                /* otherwise, allocate the data */\n                for (j=0;j<p_j2k->m_tcd->image->numcomps;++j) {\n                        opj_tcd_tilecomp_t* l_tilec = p_tcd->tcd_image->tiles->comps + j;\n                        if (l_reuse_data) {\n\t\t\t\t\t\t\t\t\t\t\t\t        opj_image_comp_t * l_img_comp = p_tcd->image->comps + j;\n\t\t\t\t\t\t\t\t\t\t\t\t        l_tilec->data  =  l_img_comp->data;\n\t\t\t\t\t\t\t\t\t\t\t\t        l_tilec->ownsData = OPJ_FALSE;\n                        } else {\n\t\t\t\t\t\t\t\t\t\t\t\t        if(! opj_alloc_tile_component_data(l_tilec)) {\n\t\t\t\t\t\t\t\t\t\t\t\t                opj_event_msg(p_manager, EVT_ERROR, \"Error allocating tile component data.\" );\n\t\t\t\t\t\t\t\t\t\t\t\t                if (l_current_data) {\n\t\t\t\t\t\t\t\t\t\t\t\t                        opj_free(l_current_data);\n\t\t\t\t\t\t\t\t\t\t\t\t                }\n\t\t\t\t\t\t\t\t\t\t\t\t                return OPJ_FALSE;\n\t\t\t\t\t\t\t\t\t\t\t\t        }\n                        }\n                }\n                l_current_tile_size = opj_tcd_get_encoded_tile_size(p_j2k->m_tcd);\n                if (!l_reuse_data) {\n                        if (l_current_tile_size > l_max_tile_size) {\n\t\t\t\t\t\t\t\t\t\t\t\t        OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(l_current_data, l_current_tile_size);\n\t\t\t\t\t\t\t\t\t\t\t\t        if (! l_new_current_data) {\n\t\t\t\t\t\t\t\t\t\t\t\t                if (l_current_data) {\n\t\t\t\t\t\t\t\t\t\t\t\t                        opj_free(l_current_data);\n\t\t\t\t\t\t\t\t\t\t\t\t                }\n\t\t\t\t\t\t\t\t\t\t\t\t                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to encode all tiles\\n\");\n\t\t\t\t\t\t\t\t\t\t\t\t                return OPJ_FALSE;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_data = l_new_current_data;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_max_tile_size = l_current_tile_size;\n                        }\n\n                        /* copy image data (32 bit) to l_current_data as contiguous, all-component, zero offset buffer */\n                        /* 32 bit components @ 8 bit precision get converted to 8 bit */\n                        /* 32 bit components @ 16 bit precision get converted to 16 bit */\n                        opj_j2k_get_tile_data(p_j2k->m_tcd,l_current_data);\n\n                        /* now copy this data into the tile component */\n                        if (! opj_tcd_copy_tile_data(p_j2k->m_tcd,l_current_data,l_current_tile_size)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\topj_event_msg(p_manager, EVT_ERROR, \"Size mismatch between tile data and sent data.\" );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\topj_free(l_current_data);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn OPJ_FALSE;\n                        }\n                }\n\n                if (! opj_j2k_post_write_tile (p_j2k,p_stream,p_manager)) {\n                        if (l_current_data) {\n                                opj_free(l_current_data);\n                        }\n                        return OPJ_FALSE;\n                }\n        }\n\n        if (l_current_data) {\n                opj_free(l_current_data);\n        }\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_end_compress(  opj_j2k_t *p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager)\n{\n        /* customization of the encoding */\n        if (! opj_j2k_setup_end_compress(p_j2k, p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        if (! opj_j2k_exec (p_j2k, p_j2k->m_procedure_list, p_stream, p_manager))\n        {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_start_compress(opj_j2k_t *p_j2k,\n                                                            opj_stream_private_t *p_stream,\n                                                            opj_image_t * p_image,\n                                                            opj_event_mgr_t * p_manager)\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n\n        p_j2k->m_private_image = opj_image_create0();\n        if (! p_j2k->m_private_image) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Failed to allocate image header.\" );\n                return OPJ_FALSE;\n        }\n        opj_copy_image_header(p_image, p_j2k->m_private_image);\n\n        /* TODO_MSD: Find a better way */\n        if (p_image->comps) {\n                OPJ_UINT32 it_comp;\n                for (it_comp = 0 ; it_comp < p_image->numcomps; it_comp++) {\n                        if (p_image->comps[it_comp].data) {\n                                p_j2k->m_private_image->comps[it_comp].data =p_image->comps[it_comp].data;\n                                p_image->comps[it_comp].data = NULL;\n\n                        }\n                }\n        }\n\n        /* customization of the validation */\n        if (! opj_j2k_setup_encoding_validation (p_j2k, p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        /* validation of the parameters codec */\n        if (! opj_j2k_exec(p_j2k,p_j2k->m_validation_list,p_stream,p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        /* customization of the encoding */\n        if (! opj_j2k_setup_header_writing(p_j2k, p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        /* write header */\n        if (! opj_j2k_exec (p_j2k,p_j2k->m_procedure_list,p_stream,p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_pre_write_tile (       opj_j2k_t * p_j2k,\n                                                                OPJ_UINT32 p_tile_index,\n                                                                opj_stream_private_t *p_stream,\n                                                                opj_event_mgr_t * p_manager )\n{\n  (void)p_stream;\n        if (p_tile_index != p_j2k->m_current_tile_number) {\n                opj_event_msg(p_manager, EVT_ERROR, \"The given tile index does not match.\" );\n                return OPJ_FALSE;\n        }\n\n        opj_event_msg(p_manager, EVT_INFO, \"tile number %d / %d\\n\", p_j2k->m_current_tile_number + 1, p_j2k->m_cp.tw * p_j2k->m_cp.th);\n\n        p_j2k->m_specific_param.m_encoder.m_current_tile_part_number = 0;\n        p_j2k->m_tcd->cur_totnum_tp = p_j2k->m_cp.tcps[p_tile_index].m_nb_tile_parts;\n        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = 0;\n\n        /* initialisation before tile encoding  */\n        if (! opj_tcd_init_encode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number, p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic void opj_get_tile_dimensions(opj_image_t * l_image,\n                             opj_tcd_tilecomp_t * l_tilec,\n                             opj_image_comp_t * l_img_comp,\n                             OPJ_UINT32* l_size_comp,\n                             OPJ_UINT32* l_width,\n                             OPJ_UINT32* l_height,\n                             OPJ_UINT32* l_offset_x,\n                             OPJ_UINT32* l_offset_y,\n                             OPJ_UINT32* l_image_width,\n                             OPJ_UINT32* l_stride,\n                             OPJ_UINT32* l_tile_offset) {\n\tOPJ_UINT32 l_remaining;\n\t*l_size_comp = l_img_comp->prec >> 3; /* (/8) */\n\tl_remaining = l_img_comp->prec & 7;  /* (%8) */\n\tif (l_remaining) {\n\t\t*l_size_comp += 1;\n\t}\n\n\tif (*l_size_comp == 3) {\n\t\t*l_size_comp = 4;\n\t}\n\n\t*l_width  = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0);\n\t*l_height = (OPJ_UINT32)(l_tilec->y1 - l_tilec->y0);\n\t*l_offset_x = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)l_image->x0, (OPJ_INT32)l_img_comp->dx);\n\t*l_offset_y = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)l_image->y0, (OPJ_INT32)l_img_comp->dy);\n\t*l_image_width = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)l_image->x1 - (OPJ_INT32)l_image->x0, (OPJ_INT32)l_img_comp->dx);\n\t*l_stride = *l_image_width - *l_width;\n\t*l_tile_offset = ((OPJ_UINT32)l_tilec->x0 - *l_offset_x) + ((OPJ_UINT32)l_tilec->y0 - *l_offset_y) * *l_image_width;\n}\n\nstatic void opj_j2k_get_tile_data (opj_tcd_t * p_tcd, OPJ_BYTE * p_data)\n{\n        OPJ_UINT32 i,j,k = 0;\n\n        for (i=0;i<p_tcd->image->numcomps;++i) {\n                opj_image_t * l_image =  p_tcd->image;\n                OPJ_INT32 * l_src_ptr;\n                opj_tcd_tilecomp_t * l_tilec = p_tcd->tcd_image->tiles->comps + i;\n                opj_image_comp_t * l_img_comp = l_image->comps + i;\n                OPJ_UINT32 l_size_comp,l_width,l_height,l_offset_x,l_offset_y, l_image_width,l_stride,l_tile_offset;\n\n                opj_get_tile_dimensions(l_image,\n                                        l_tilec,\n                                        l_img_comp,\n                                        &l_size_comp,\n                                        &l_width,\n                                        &l_height,\n                                        &l_offset_x,\n                                        &l_offset_y,\n                                        &l_image_width,\n                                        &l_stride,\n                                        &l_tile_offset);\n\n                l_src_ptr = l_img_comp->data + l_tile_offset;\n\n                switch (l_size_comp) {\n                        case 1:\n                                {\n                                        OPJ_CHAR * l_dest_ptr = (OPJ_CHAR*) p_data;\n                                        if (l_img_comp->sgnd) {\n                                                for     (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr) = (OPJ_CHAR) (*l_src_ptr);\n                                                                ++l_dest_ptr;\n                                                                ++l_src_ptr;\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr) = (OPJ_CHAR)((*l_src_ptr)&0xff);\n                                                                ++l_dest_ptr;\n                                                                ++l_src_ptr;\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n\n                                        p_data = (OPJ_BYTE*) l_dest_ptr;\n                                }\n                                break;\n                        case 2:\n                                {\n                                        OPJ_INT16 * l_dest_ptr = (OPJ_INT16 *) p_data;\n                                        if (l_img_comp->sgnd) {\n                                                for (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_INT16) (*(l_src_ptr++));\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_INT16)((*(l_src_ptr++)) & 0xffff);\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n\n                                        p_data = (OPJ_BYTE*) l_dest_ptr;\n                                }\n                                break;\n                        case 4:\n                                {\n                                        OPJ_INT32 * l_dest_ptr = (OPJ_INT32 *) p_data;\n                                        for (j=0;j<l_height;++j) {\n                                                for (k=0;k<l_width;++k) {\n                                                        *(l_dest_ptr++) = *(l_src_ptr++);\n                                                }\n                                                l_src_ptr += l_stride;\n                                        }\n\n                                        p_data = (OPJ_BYTE*) l_dest_ptr;\n                                }\n                                break;\n                }\n        }\n}\n\nstatic OPJ_BOOL opj_j2k_post_write_tile (      opj_j2k_t * p_j2k,\n                                                                opj_stream_private_t *p_stream,\n                                                                opj_event_mgr_t * p_manager )\n{\n        OPJ_UINT32 l_nb_bytes_written;\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_tile_size = 0;\n        OPJ_UINT32 l_available_data;\n\n        /* preconditions */\n        assert(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);\n\n        l_tile_size = p_j2k->m_specific_param.m_encoder.m_encoded_tile_size;\n        l_available_data = l_tile_size;\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_encoded_tile_data;\n\n        l_nb_bytes_written = 0;\n        if (! opj_j2k_write_first_tile_part(p_j2k,l_current_data,&l_nb_bytes_written,l_available_data,p_stream,p_manager)) {\n                return OPJ_FALSE;\n        }\n        l_current_data += l_nb_bytes_written;\n        l_available_data -= l_nb_bytes_written;\n\n        l_nb_bytes_written = 0;\n        if (! opj_j2k_write_all_tile_parts(p_j2k,l_current_data,&l_nb_bytes_written,l_available_data,p_stream,p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        l_available_data -= l_nb_bytes_written;\n        l_nb_bytes_written = l_tile_size - l_available_data;\n\n        if ( opj_stream_write_data(     p_stream,\n                                                                p_j2k->m_specific_param.m_encoder.m_encoded_tile_data,\n                                                                l_nb_bytes_written,p_manager) != l_nb_bytes_written) {\n                return OPJ_FALSE;\n        }\n\n        ++p_j2k->m_current_tile_number;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_setup_end_compress (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager)\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        /* DEVELOPER CORNER, insert your custom procedures */\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_eoc, p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        if (OPJ_IS_CINEMA(p_j2k->m_cp.rsiz)) {\n                if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_updated_tlm, p_manager)) {\n                        return OPJ_FALSE;\n                }\n        }\n\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_epc, p_manager)) {\n                return OPJ_FALSE;\n        }\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_end_encoding, p_manager)) {\n                return OPJ_FALSE;\n        }\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_destroy_header_memory, p_manager)) {\n                return OPJ_FALSE;\n        }\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_setup_encoding_validation (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager)\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure)opj_j2k_build_encoder, p_manager)) {\n                return OPJ_FALSE;\n        }\n        if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure)opj_j2k_encoding_validation, p_manager)) {\n                return OPJ_FALSE;\n\t\t\t\t}\n\n        /* DEVELOPER CORNER, add your custom validation procedure */\n        if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure)opj_j2k_mct_validation, p_manager)) {\n                return OPJ_FALSE;\n        }\n\t\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_setup_header_writing (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager)\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_init_info, p_manager)) {\n                return OPJ_FALSE;\n        }\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_soc, p_manager)) {\n                return OPJ_FALSE;\n        }\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_siz, p_manager)) {\n                return OPJ_FALSE;\n        }\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_cod, p_manager)) {\n                return OPJ_FALSE;\n        }\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_qcd, p_manager)) {\n                return OPJ_FALSE;\n        }\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_all_coc, p_manager)) {\n                return OPJ_FALSE;\n        }\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_all_qcc, p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        if (OPJ_IS_CINEMA(p_j2k->m_cp.rsiz)) {\n                if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_tlm, p_manager)) {\n                        return OPJ_FALSE;\n                }\n\n                if (p_j2k->m_cp.rsiz == OPJ_PROFILE_CINEMA_4K) {\n                        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_poc, p_manager)) {\n                                return OPJ_FALSE;\n                        }\n                }\n        }\n\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_regions, p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        if (p_j2k->m_cp.comment != 00)  {\n                if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_com, p_manager)) {\n                        return OPJ_FALSE;\n                }\n        }\n\n        /* DEVELOPER CORNER, insert your custom procedures */\n        if (p_j2k->m_cp.rsiz & OPJ_EXTENSION_MCT) {\n                if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_mct_data_group, p_manager)) {\n                        return OPJ_FALSE;\n                }\n        }\n        /* End of Developer Corner */\n\n        if (p_j2k->cstr_index) {\n                if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_get_end_header, p_manager)) {\n                        return OPJ_FALSE;\n                }\n        }\n\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_create_tcd, p_manager)) {\n                return OPJ_FALSE;\n        }\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_update_rates, p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_first_tile_part (opj_j2k_t *p_j2k,\n                                                                        OPJ_BYTE * p_data,\n                                                                        OPJ_UINT32 * p_data_written,\n                                                                        OPJ_UINT32 p_total_data_size,\n                                                                        opj_stream_private_t *p_stream,\n                                                                        struct opj_event_mgr * p_manager )\n{\n        OPJ_UINT32 l_nb_bytes_written = 0;\n        OPJ_UINT32 l_current_nb_bytes_written;\n        OPJ_BYTE * l_begin_data = 00;\n\n        opj_tcd_t * l_tcd = 00;\n        opj_cp_t * l_cp = 00;\n\n        l_tcd = p_j2k->m_tcd;\n        l_cp = &(p_j2k->m_cp);\n\n        l_tcd->cur_pino = 0;\n\n        /*Get number of tile parts*/\n        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = 0;\n\n        /* INDEX >> */\n        /* << INDEX */\n\n        l_current_nb_bytes_written = 0;\n        l_begin_data = p_data;\n        if (! opj_j2k_write_sot(p_j2k,p_data,&l_current_nb_bytes_written,p_stream,p_manager))\n        {\n                return OPJ_FALSE;\n        }\n\n        l_nb_bytes_written += l_current_nb_bytes_written;\n        p_data += l_current_nb_bytes_written;\n        p_total_data_size -= l_current_nb_bytes_written;\n\n        if (!OPJ_IS_CINEMA(l_cp->rsiz)) {\n#if 0\n                for (compno = 1; compno < p_j2k->m_private_image->numcomps; compno++) {\n                        l_current_nb_bytes_written = 0;\n                        opj_j2k_write_coc_in_memory(p_j2k,compno,p_data,&l_current_nb_bytes_written,p_manager);\n                        l_nb_bytes_written += l_current_nb_bytes_written;\n                        p_data += l_current_nb_bytes_written;\n                        p_total_data_size -= l_current_nb_bytes_written;\n\n                        l_current_nb_bytes_written = 0;\n                        opj_j2k_write_qcc_in_memory(p_j2k,compno,p_data,&l_current_nb_bytes_written,p_manager);\n                        l_nb_bytes_written += l_current_nb_bytes_written;\n                        p_data += l_current_nb_bytes_written;\n                        p_total_data_size -= l_current_nb_bytes_written;\n                }\n#endif\n                if (l_cp->tcps[p_j2k->m_current_tile_number].numpocs) {\n                        l_current_nb_bytes_written = 0;\n                        opj_j2k_write_poc_in_memory(p_j2k,p_data,&l_current_nb_bytes_written,p_manager);\n                        l_nb_bytes_written += l_current_nb_bytes_written;\n                        p_data += l_current_nb_bytes_written;\n                        p_total_data_size -= l_current_nb_bytes_written;\n                }\n        }\n\n        l_current_nb_bytes_written = 0;\n        if (! opj_j2k_write_sod(p_j2k,l_tcd,p_data,&l_current_nb_bytes_written,p_total_data_size,p_stream,p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        l_nb_bytes_written += l_current_nb_bytes_written;\n        * p_data_written = l_nb_bytes_written;\n\n        /* Writing Psot in SOT marker */\n        opj_write_bytes(l_begin_data + 6,l_nb_bytes_written,4);                                 /* PSOT */\n\n        if (OPJ_IS_CINEMA(l_cp->rsiz)){\n                opj_j2k_update_tlm(p_j2k,l_nb_bytes_written);\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_all_tile_parts(  opj_j2k_t *p_j2k,\n                                                                        OPJ_BYTE * p_data,\n                                                                        OPJ_UINT32 * p_data_written,\n                                                                        OPJ_UINT32 p_total_data_size,\n                                                                        opj_stream_private_t *p_stream,\n                                                                        struct opj_event_mgr * p_manager\n                                                                )\n{\n        OPJ_UINT32 tilepartno=0;\n        OPJ_UINT32 l_nb_bytes_written = 0;\n        OPJ_UINT32 l_current_nb_bytes_written;\n        OPJ_UINT32 l_part_tile_size;\n        OPJ_UINT32 tot_num_tp;\n        OPJ_UINT32 pino;\n\n        OPJ_BYTE * l_begin_data;\n        opj_tcp_t *l_tcp = 00;\n        opj_tcd_t * l_tcd = 00;\n        opj_cp_t * l_cp = 00;\n\n        l_tcd = p_j2k->m_tcd;\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;\n\n        /*Get number of tile parts*/\n        tot_num_tp = opj_j2k_get_num_tp(l_cp,0,p_j2k->m_current_tile_number);\n\n        /* start writing remaining tile parts */\n        ++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;\n        for (tilepartno = 1; tilepartno < tot_num_tp ; ++tilepartno) {\n                p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;\n                l_current_nb_bytes_written = 0;\n                l_part_tile_size = 0;\n                l_begin_data = p_data;\n\n                if (! opj_j2k_write_sot(p_j2k,p_data,&l_current_nb_bytes_written,p_stream,p_manager)) {\n                        return OPJ_FALSE;\n                }\n\n                l_nb_bytes_written += l_current_nb_bytes_written;\n                p_data += l_current_nb_bytes_written;\n                p_total_data_size -= l_current_nb_bytes_written;\n                l_part_tile_size += l_current_nb_bytes_written;\n\n                l_current_nb_bytes_written = 0;\n                if (! opj_j2k_write_sod(p_j2k,l_tcd,p_data,&l_current_nb_bytes_written,p_total_data_size,p_stream,p_manager)) {\n                        return OPJ_FALSE;\n                }\n\n                p_data += l_current_nb_bytes_written;\n                l_nb_bytes_written += l_current_nb_bytes_written;\n                p_total_data_size -= l_current_nb_bytes_written;\n                l_part_tile_size += l_current_nb_bytes_written;\n\n                /* Writing Psot in SOT marker */\n                opj_write_bytes(l_begin_data + 6,l_part_tile_size,4);                                   /* PSOT */\n\n                if (OPJ_IS_CINEMA(l_cp->rsiz)) {\n                        opj_j2k_update_tlm(p_j2k,l_part_tile_size);\n                }\n\n                ++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;\n        }\n\n        for (pino = 1; pino <= l_tcp->numpocs; ++pino) {\n                l_tcd->cur_pino = pino;\n\n                /*Get number of tile parts*/\n                tot_num_tp = opj_j2k_get_num_tp(l_cp,pino,p_j2k->m_current_tile_number);\n                for (tilepartno = 0; tilepartno < tot_num_tp ; ++tilepartno) {\n                        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;\n                        l_current_nb_bytes_written = 0;\n                        l_part_tile_size = 0;\n                        l_begin_data = p_data;\n\n                        if (! opj_j2k_write_sot(p_j2k,p_data,&l_current_nb_bytes_written,p_stream,p_manager)) {\n                                return OPJ_FALSE;\n                        }\n\n                        l_nb_bytes_written += l_current_nb_bytes_written;\n                        p_data += l_current_nb_bytes_written;\n                        p_total_data_size -= l_current_nb_bytes_written;\n                        l_part_tile_size += l_current_nb_bytes_written;\n\n                        l_current_nb_bytes_written = 0;\n\n                        if (! opj_j2k_write_sod(p_j2k,l_tcd,p_data,&l_current_nb_bytes_written,p_total_data_size,p_stream,p_manager)) {\n                                return OPJ_FALSE;\n                        }\n\n                        l_nb_bytes_written += l_current_nb_bytes_written;\n                        p_data += l_current_nb_bytes_written;\n                        p_total_data_size -= l_current_nb_bytes_written;\n                        l_part_tile_size += l_current_nb_bytes_written;\n\n                        /* Writing Psot in SOT marker */\n                        opj_write_bytes(l_begin_data + 6,l_part_tile_size,4);                                   /* PSOT */\n\n                        if (OPJ_IS_CINEMA(l_cp->rsiz)) {\n                                opj_j2k_update_tlm(p_j2k,l_part_tile_size);\n                        }\n\n                        ++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;\n                }\n        }\n\n        *p_data_written = l_nb_bytes_written;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_updated_tlm( opj_j2k_t *p_j2k,\n                                                                    struct opj_stream_private *p_stream,\n                                                                    struct opj_event_mgr * p_manager )\n{\n        OPJ_UINT32 l_tlm_size;\n        OPJ_OFF_T l_tlm_position, l_current_position;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_tlm_size = 5 * p_j2k->m_specific_param.m_encoder.m_total_tile_parts;\n        l_tlm_position = 6 + p_j2k->m_specific_param.m_encoder.m_tlm_start;\n        l_current_position = opj_stream_tell(p_stream);\n\n        if (! opj_stream_seek(p_stream,l_tlm_position,p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer,l_tlm_size,p_manager) != l_tlm_size) {\n                return OPJ_FALSE;\n        }\n\n        if (! opj_stream_seek(p_stream,l_current_position,p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_end_encoding(  opj_j2k_t *p_j2k,\n                                                        struct opj_stream_private *p_stream,\n                                                        struct opj_event_mgr * p_manager )\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        opj_tcd_destroy(p_j2k->m_tcd);\n        p_j2k->m_tcd = 00;\n\n        if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {\n                opj_free(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);\n                p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = 0;\n                p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = 0;\n        }\n\n        if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {\n                opj_free(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);\n                p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = 0;\n        }\n\n        p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = 0;\n\n        return OPJ_TRUE;\n}\n\n/**\n * Destroys the memory associated with the decoding of headers.\n */\nstatic OPJ_BOOL opj_j2k_destroy_header_memory ( opj_j2k_t * p_j2k,\n                                                opj_stream_private_t *p_stream,\n                                                opj_event_mgr_t * p_manager\n                                                )\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n\n        if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {\n                opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = 0;\n        }\n\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_init_info(     opj_j2k_t *p_j2k,\n                                                struct opj_stream_private *p_stream,\n                                                struct opj_event_mgr * p_manager )\n{\n        opj_codestream_info_t * l_cstr_info = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n  (void)l_cstr_info;\n\n        /* TODO mergeV2: check this part which use cstr_info */\n        /*l_cstr_info = p_j2k->cstr_info;\n\n        if (l_cstr_info)  {\n                OPJ_UINT32 compno;\n                l_cstr_info->tile = (opj_tile_info_t *) opj_malloc(p_j2k->m_cp.tw * p_j2k->m_cp.th * sizeof(opj_tile_info_t));\n\n                l_cstr_info->image_w = p_j2k->m_image->x1 - p_j2k->m_image->x0;\n                l_cstr_info->image_h = p_j2k->m_image->y1 - p_j2k->m_image->y0;\n\n                l_cstr_info->prog = (&p_j2k->m_cp.tcps[0])->prg;\n\n                l_cstr_info->tw = p_j2k->m_cp.tw;\n                l_cstr_info->th = p_j2k->m_cp.th;\n\n                l_cstr_info->tile_x = p_j2k->m_cp.tdx;*/        /* new version parser */\n                /*l_cstr_info->tile_y = p_j2k->m_cp.tdy;*/      /* new version parser */\n                /*l_cstr_info->tile_Ox = p_j2k->m_cp.tx0;*/     /* new version parser */\n                /*l_cstr_info->tile_Oy = p_j2k->m_cp.ty0;*/     /* new version parser */\n\n                /*l_cstr_info->numcomps = p_j2k->m_image->numcomps;\n\n                l_cstr_info->numlayers = (&p_j2k->m_cp.tcps[0])->numlayers;\n\n                l_cstr_info->numdecompos = (OPJ_INT32*) opj_malloc(p_j2k->m_image->numcomps * sizeof(OPJ_INT32));\n\n                for (compno=0; compno < p_j2k->m_image->numcomps; compno++) {\n                        l_cstr_info->numdecompos[compno] = (&p_j2k->m_cp.tcps[0])->tccps->numresolutions - 1;\n                }\n\n                l_cstr_info->D_max = 0.0;       */      /* ADD Marcela */\n\n                /*l_cstr_info->main_head_start = opj_stream_tell(p_stream);*/ /* position of SOC */\n\n                /*l_cstr_info->maxmarknum = 100;\n                l_cstr_info->marker = (opj_marker_info_t *) opj_malloc(l_cstr_info->maxmarknum * sizeof(opj_marker_info_t));\n                l_cstr_info->marknum = 0;\n        }*/\n\n        return opj_j2k_calculate_tp(p_j2k,&(p_j2k->m_cp),&p_j2k->m_specific_param.m_encoder.m_total_tile_parts,p_j2k->m_private_image,p_manager);\n}\n\n/**\n * Creates a tile-coder decoder.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_create_tcd(     opj_j2k_t *p_j2k,\n                                                                    opj_stream_private_t *p_stream,\n                                                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        p_j2k->m_tcd = opj_tcd_create(OPJ_FALSE);\n\n        if (! p_j2k->m_tcd) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to create Tile Coder\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (!opj_tcd_init(p_j2k->m_tcd,p_j2k->m_private_image,&p_j2k->m_cp, p_j2k->m_tp)) {\n                opj_tcd_destroy(p_j2k->m_tcd);\n                p_j2k->m_tcd = 00;\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_write_tile (opj_j2k_t * p_j2k,\n                                                 OPJ_UINT32 p_tile_index,\n                                                 OPJ_BYTE * p_data,\n                                                 OPJ_UINT32 p_data_size,\n                                                 opj_stream_private_t *p_stream,\n                                                 opj_event_mgr_t * p_manager )\n{\n        if (! opj_j2k_pre_write_tile(p_j2k,p_tile_index,p_stream,p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error while opj_j2k_pre_write_tile with tile index = %d\\n\", p_tile_index);\n                return OPJ_FALSE;\n        }\n        else {\n                OPJ_UINT32 j;\n                /* Allocate data */\n                for (j=0;j<p_j2k->m_tcd->image->numcomps;++j) {\n                        opj_tcd_tilecomp_t* l_tilec = p_j2k->m_tcd->tcd_image->tiles->comps + j;\n\n                        if(! opj_alloc_tile_component_data(l_tilec)) {\n\t\t\t\t\t\t\t\t\t\t\t\t        opj_event_msg(p_manager, EVT_ERROR, \"Error allocating tile component data.\" );\n                                return OPJ_FALSE;\n                        }\n                }\n\n                /* now copy data into the tile component */\n                if (! opj_tcd_copy_tile_data(p_j2k->m_tcd,p_data,p_data_size)) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Size mismatch between tile data and sent data.\" );\n                        return OPJ_FALSE;\n                }\n                if (! opj_j2k_post_write_tile(p_j2k,p_stream,p_manager)) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error while opj_j2k_post_write_tile with tile index = %d\\n\", p_tile_index);\n                        return OPJ_FALSE;\n                }\n        }\n\n        return OPJ_TRUE;\n}\n"], "fixing_code": ["/*\n * The copyright in this software is being made available under the 2-clauses \n * BSD License, included below. This software may be subject to other third \n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux \n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#include \"opj_apps_config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"openjpeg.h\"\n#include \"convert.h\"\n\n/*\n * Get logarithm of an integer and round downwards.\n *\n * log2(a)\n */\nstatic int int_floorlog2(int a) {\n    int l;\n    for (l = 0; a > 1; l++) {\n        a >>= 1;\n    }\n    return l;\n}\n\n/* Component precision scaling */\nvoid clip_component(opj_image_comp_t* component, OPJ_UINT32 precision)\n{\n\tOPJ_SIZE_T i;\n\tOPJ_SIZE_T len;\n\tOPJ_UINT32 umax = (OPJ_UINT32)((OPJ_INT32)-1);\n\t\n\tlen = (OPJ_SIZE_T)component->w * (OPJ_SIZE_T)component->h;\n\tif (precision < 32) {\n\t\tumax = (1U << precision) - 1U;\n\t}\n\t\n\tif (component->sgnd) {\n\t\tOPJ_INT32* l_data = component->data;\n\t\tOPJ_INT32 max = (OPJ_INT32)(umax / 2U);\n\t\tOPJ_INT32 min = -max - 1;\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tif (l_data[i] > max) {\n\t\t\t\tl_data[i] = max;\n\t\t\t} else if (l_data[i] < min) {\n\t\t\t\tl_data[i] = min;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tOPJ_UINT32* l_data = (OPJ_UINT32*)component->data;\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tif (l_data[i] > umax) {\n\t\t\t\tl_data[i] = umax;\n\t\t\t}\n\t\t}\n\t}\n\tcomponent->prec = precision;\n}\n\n/* Component precision scaling */\nstatic void scale_component_up(opj_image_comp_t* component, OPJ_UINT32 precision)\n{\n\tOPJ_SIZE_T i, len;\n\t\n\tlen = (OPJ_SIZE_T)component->w * (OPJ_SIZE_T)component->h;\n\tif (component->sgnd) {\n\t\tOPJ_INT64  newMax = (OPJ_INT64)(1U << (precision - 1));\n\t\tOPJ_INT64  oldMax = (OPJ_INT64)(1U << (component->prec - 1));\n\t\tOPJ_INT32* l_data = component->data;\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tl_data[i] = (OPJ_INT32)(((OPJ_INT64)l_data[i] * newMax) / oldMax);\n\t\t}\n\t} else {\n\t\tOPJ_UINT64  newMax = (OPJ_UINT64)((1U << precision) - 1U);\n\t\tOPJ_UINT64  oldMax = (OPJ_UINT64)((1U << component->prec) - 1U);\n\t\tOPJ_UINT32* l_data = (OPJ_UINT32*)component->data;\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tl_data[i] = (OPJ_UINT32)(((OPJ_UINT64)l_data[i] * newMax) / oldMax);\n\t\t}\n\t}\n\tcomponent->prec = precision;\n\tcomponent->bpp = precision;\n}\nvoid scale_component(opj_image_comp_t* component, OPJ_UINT32 precision)\n{\n\tint shift;\n\tOPJ_SIZE_T i, len;\n\t\n\tif (component->prec == precision) {\n\t\treturn;\n\t}\n\tif (component->prec < precision) {\n\t\tscale_component_up(component, precision);\n\t\treturn;\n\t}\n\tshift = (int)(component->prec - precision);\n\tlen = (OPJ_SIZE_T)component->w * (OPJ_SIZE_T)component->h;\n\tif (component->sgnd) {\n\t\tOPJ_INT32* l_data = component->data;\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tl_data[i] >>= shift;\n\t\t}\n\t} else {\n\t\tOPJ_UINT32* l_data = (OPJ_UINT32*)component->data;\n\t\tfor (i = 0; i < len; ++i) {\n\t\t\tl_data[i] >>= shift;\n\t\t}\n\t}\n\tcomponent->bpp = precision;\n\tcomponent->prec = precision;\n}\n\n\n/* planar / interleaved conversions */\n/* used by PNG/TIFF */\nstatic void convert_32s_C1P1(const OPJ_INT32* pSrc, OPJ_INT32* const* pDst, OPJ_SIZE_T length)\n{\n\tmemcpy(pDst[0], pSrc, length * sizeof(OPJ_INT32));\n}\nstatic void convert_32s_C2P2(const OPJ_INT32* pSrc, OPJ_INT32* const* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tOPJ_INT32* pDst0 = pDst[0];\n\tOPJ_INT32* pDst1 = pDst[1];\n\t\n\tfor (i = 0; i < length; i++) {\n\t\tpDst0[i] = pSrc[2*i+0];\n\t\tpDst1[i] = pSrc[2*i+1];\n\t}\n}\nstatic void convert_32s_C3P3(const OPJ_INT32* pSrc, OPJ_INT32* const* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tOPJ_INT32* pDst0 = pDst[0];\n\tOPJ_INT32* pDst1 = pDst[1];\n\tOPJ_INT32* pDst2 = pDst[2];\n\t\n\tfor (i = 0; i < length; i++) {\n\t\tpDst0[i] = pSrc[3*i+0];\n\t\tpDst1[i] = pSrc[3*i+1];\n\t\tpDst2[i] = pSrc[3*i+2];\n\t}\n}\nstatic void convert_32s_C4P4(const OPJ_INT32* pSrc, OPJ_INT32* const* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tOPJ_INT32* pDst0 = pDst[0];\n\tOPJ_INT32* pDst1 = pDst[1];\n\tOPJ_INT32* pDst2 = pDst[2];\n\tOPJ_INT32* pDst3 = pDst[3];\n\t\n\tfor (i = 0; i < length; i++) {\n\t\tpDst0[i] = pSrc[4*i+0];\n\t\tpDst1[i] = pSrc[4*i+1];\n\t\tpDst2[i] = pSrc[4*i+2];\n\t\tpDst3[i] = pSrc[4*i+3];\n\t}\n}\nconst convert_32s_CXPX convert_32s_CXPX_LUT[5] = {\n\tNULL,\n\tconvert_32s_C1P1,\n\tconvert_32s_C2P2,\n\tconvert_32s_C3P3,\n\tconvert_32s_C4P4\n};\n\nstatic void convert_32s_P1C1(OPJ_INT32 const* const* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length, OPJ_INT32 adjust)\n{\n\tOPJ_SIZE_T i;\n\tconst OPJ_INT32* pSrc0 = pSrc[0];\n\t\n\tfor (i = 0; i < length; i++) {\n\t\tpDst[i] = pSrc0[i] + adjust;\n\t}\n}\nstatic void convert_32s_P2C2(OPJ_INT32 const* const* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length, OPJ_INT32 adjust)\n{\n\tOPJ_SIZE_T i;\n\tconst OPJ_INT32* pSrc0 = pSrc[0];\n\tconst OPJ_INT32* pSrc1 = pSrc[1];\n\t\n\tfor (i = 0; i < length; i++) {\n\t\tpDst[2*i+0] = pSrc0[i] + adjust;\n\t\tpDst[2*i+1] = pSrc1[i] + adjust;\n\t}\n}\nstatic void convert_32s_P3C3(OPJ_INT32 const* const* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length, OPJ_INT32 adjust)\n{\n\tOPJ_SIZE_T i;\n\tconst OPJ_INT32* pSrc0 = pSrc[0];\n\tconst OPJ_INT32* pSrc1 = pSrc[1];\n\tconst OPJ_INT32* pSrc2 = pSrc[2];\n\t\n\tfor (i = 0; i < length; i++) {\n\t\tpDst[3*i+0] = pSrc0[i] + adjust;\n\t\tpDst[3*i+1] = pSrc1[i] + adjust;\n\t\tpDst[3*i+2] = pSrc2[i] + adjust;\n\t}\n}\nstatic void convert_32s_P4C4(OPJ_INT32 const* const* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length, OPJ_INT32 adjust)\n{\n\tOPJ_SIZE_T i;\n\tconst OPJ_INT32* pSrc0 = pSrc[0];\n\tconst OPJ_INT32* pSrc1 = pSrc[1];\n\tconst OPJ_INT32* pSrc2 = pSrc[2];\n\tconst OPJ_INT32* pSrc3 = pSrc[3];\n\t\n\tfor (i = 0; i < length; i++) {\n\t\tpDst[4*i+0] = pSrc0[i] + adjust;\n\t\tpDst[4*i+1] = pSrc1[i] + adjust;\n\t\tpDst[4*i+2] = pSrc2[i] + adjust;\n\t\tpDst[4*i+3] = pSrc3[i] + adjust;\n\t}\n}\nconst convert_32s_PXCX convert_32s_PXCX_LUT[5] = {\n\tNULL,\n\tconvert_32s_P1C1,\n\tconvert_32s_P2C2,\n\tconvert_32s_P3C3,\n\tconvert_32s_P4C4\n};\n\n/* bit depth conversions */\n/* used by PNG/TIFF up to 8bpp */\nstatic void convert_1u32s_C1R(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 val = *pSrc++;\n\t\tpDst[i+0] = (OPJ_INT32)( val >> 7);\n\t\tpDst[i+1] = (OPJ_INT32)((val >> 6) & 0x1U);\n\t\tpDst[i+2] = (OPJ_INT32)((val >> 5) & 0x1U);\n\t\tpDst[i+3] = (OPJ_INT32)((val >> 4) & 0x1U);\n\t\tpDst[i+4] = (OPJ_INT32)((val >> 3) & 0x1U);\n\t\tpDst[i+5] = (OPJ_INT32)((val >> 2) & 0x1U);\n\t\tpDst[i+6] = (OPJ_INT32)((val >> 1) & 0x1U);\n\t\tpDst[i+7] = (OPJ_INT32)(val & 0x1U);\n\t}\n\tif (length & 7U) {\n\t\tOPJ_UINT32 val = *pSrc++;\n\t\tlength = length & 7U;\n\t\tpDst[i+0] = (OPJ_INT32)(val >> 7);\n\t\t\n\t\tif (length > 1U) {\n\t\t\tpDst[i+1] = (OPJ_INT32)((val >> 6) & 0x1U);\n\t\t\tif (length > 2U) {\n\t\t\t\tpDst[i+2] = (OPJ_INT32)((val >> 5) & 0x1U);\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tpDst[i+3] = (OPJ_INT32)((val >> 4) & 0x1U);\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tpDst[i+4] = (OPJ_INT32)((val >> 3) & 0x1U);\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tpDst[i+5] = (OPJ_INT32)((val >> 2) & 0x1U);\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tpDst[i+6] = (OPJ_INT32)((val >> 1) & 0x1U);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void convert_2u32s_C1R(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i+=4U) {\n\t\tOPJ_UINT32 val = *pSrc++;\n\t\tpDst[i+0] = (OPJ_INT32)( val >> 6);\n\t\tpDst[i+1] = (OPJ_INT32)((val >> 4) & 0x3U);\n\t\tpDst[i+2] = (OPJ_INT32)((val >> 2) & 0x3U);\n\t\tpDst[i+3] = (OPJ_INT32)(val & 0x3U);\n\t}\n\tif (length & 3U) {\n\t\tOPJ_UINT32 val = *pSrc++;\n\t\tlength = length & 3U;\n\t\tpDst[i+0] =  (OPJ_INT32)(val >> 6);\n\t\t\n\t\tif (length > 1U) {\n\t\t\tpDst[i+1] = (OPJ_INT32)((val >> 4) & 0x3U);\n\t\t\tif (length > 2U) {\n\t\t\t\tpDst[i+2] = (OPJ_INT32)((val >> 2) & 0x3U);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void convert_4u32s_C1R(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)1U); i+=2U) {\n\t\tOPJ_UINT32 val = *pSrc++;\n\t\tpDst[i+0] = (OPJ_INT32)(val >> 4);\n\t\tpDst[i+1] = (OPJ_INT32)(val & 0xFU);\n\t}\n\tif (length & 1U) {\n\t\tOPJ_UINT8 val = *pSrc++;\n\t\tpDst[i+0] = (OPJ_INT32)(val >> 4);\n\t}\n}\nstatic void convert_6u32s_C1R(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i+=4U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\tpDst[i+0] = (OPJ_INT32)(val0 >> 2);\n\t\tpDst[i+1] = (OPJ_INT32)(((val0 & 0x3U) << 4) | (val1 >> 4));\n\t\tpDst[i+2] = (OPJ_INT32)(((val1 & 0xFU) << 2) | (val2 >> 6));\n\t\tpDst[i+3] = (OPJ_INT32)(val2 & 0x3FU);\n\t\t\n\t}\n\tif (length & 3U) {\n\t\tOPJ_UINT32 val0 = *pSrc++;\n\t\tlength = length & 3U;\n\t\tpDst[i+0] = (OPJ_INT32)(val0 >> 2);\n\t\t\n\t\tif (length > 1U) {\n\t\t\tOPJ_UINT32 val1 = *pSrc++;\n\t\t\tpDst[i+1] = (OPJ_INT32)(((val0 & 0x3U) << 4) | (val1 >> 4));\n\t\t\tif (length > 2U) {\n\t\t\t\tOPJ_UINT32 val2 = *pSrc++;\n\t\t\t\tpDst[i+2] = (OPJ_INT32)(((val1 & 0xFU) << 2) | (val2 >> 6));\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void convert_8u32s_C1R(const OPJ_BYTE* pSrc, OPJ_INT32* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < length; i++) {\n\t\tpDst[i] = pSrc[i];\n\t}\n}\nconst convert_XXx32s_C1R convert_XXu32s_C1R_LUT[9] = {\n\tNULL,\n\tconvert_1u32s_C1R,\n\tconvert_2u32s_C1R,\n\tNULL,\n\tconvert_4u32s_C1R,\n\tNULL,\n\tconvert_6u32s_C1R,\n\tNULL,\n\tconvert_8u32s_C1R\n};\n\n\nstatic void convert_32s1u_C1R(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)7U); i+=8U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\tOPJ_UINT32 src4 = (OPJ_UINT32)pSrc[i+4];\n\t\tOPJ_UINT32 src5 = (OPJ_UINT32)pSrc[i+5];\n\t\tOPJ_UINT32 src6 = (OPJ_UINT32)pSrc[i+6];\n\t\tOPJ_UINT32 src7 = (OPJ_UINT32)pSrc[i+7];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 7) | (src1 << 6) | (src2 << 5) | (src3 << 4) | (src4 << 3) | (src5 << 2) | (src6 << 1) | src7);\n\t}\n\t\n\tif (length & 7U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = 0U;\n\t\tOPJ_UINT32 src2 = 0U;\n\t\tOPJ_UINT32 src3 = 0U;\n\t\tOPJ_UINT32 src4 = 0U;\n\t\tOPJ_UINT32 src5 = 0U;\n\t\tOPJ_UINT32 src6 = 0U;\n\t\tlength = length & 7U;\n\t\t\n\t\tif (length > 1U) {\n\t\t\tsrc1 = (OPJ_UINT32)pSrc[i+1];\n\t\t\tif (length > 2U) {\n\t\t\t\tsrc2 = (OPJ_UINT32)pSrc[i+2];\n\t\t\t\tif (length > 3U) {\n\t\t\t\t\tsrc3 = (OPJ_UINT32)pSrc[i+3];\n\t\t\t\t\tif (length > 4U) {\n\t\t\t\t\t\tsrc4 = (OPJ_UINT32)pSrc[i+4];\n\t\t\t\t\t\tif (length > 5U) {\n\t\t\t\t\t\t\tsrc5 = (OPJ_UINT32)pSrc[i+5];\n\t\t\t\t\t\t\tif (length > 6U) {\n\t\t\t\t\t\t\t\tsrc6 = (OPJ_UINT32)pSrc[i+6];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 7) | (src1 << 6) | (src2 << 5) | (src3 << 4) | (src4 << 3) | (src5 << 2) | (src6 << 1));\n\t}\n}\n\nstatic void convert_32s2u_C1R(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i+=4U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 6) | (src1 << 4) | (src2 << 2) | src3);\n\t}\n\t\n\tif (length & 3U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = 0U;\n\t\tOPJ_UINT32 src2 = 0U;\n\t\tlength = length & 3U;\n\t\t\n\t\tif (length > 1U) {\n\t\t\tsrc1 = (OPJ_UINT32)pSrc[i+1];\n\t\t\tif (length > 2U) {\n\t\t\t\tsrc2 = (OPJ_UINT32)pSrc[i+2];\n\t\t\t}\n\t\t}\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 6) | (src1 << 4) | (src2 << 2));\n\t}\n}\n\nstatic void convert_32s4u_C1R(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)1U); i+=2U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 4) | src1);\n\t}\n\t\n\tif (length & 1U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 4));\n\t}\n}\n\nstatic void convert_32s6u_C1R(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < (length & ~(OPJ_SIZE_T)3U); i+=4U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = (OPJ_UINT32)pSrc[i+1];\n\t\tOPJ_UINT32 src2 = (OPJ_UINT32)pSrc[i+2];\n\t\tOPJ_UINT32 src3 = (OPJ_UINT32)pSrc[i+3];\n\t\t\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 2) | (src1 >> 4));\n\t\t*pDst++ = (OPJ_BYTE)(((src1 & 0xFU) << 4) | (src2 >> 2));\n\t\t*pDst++ = (OPJ_BYTE)(((src2 & 0x3U) << 6) | src3);\n\t}\n\t\n\tif (length & 3U) {\n\t\tOPJ_UINT32 src0 = (OPJ_UINT32)pSrc[i+0];\n\t\tOPJ_UINT32 src1 = 0U;\n\t\tOPJ_UINT32 src2 = 0U;\n\t\tlength = length & 3U;\n\t\t\n\t\tif (length > 1U) {\n\t\t\tsrc1 = (OPJ_UINT32)pSrc[i+1];\n\t\t\tif (length > 2U) {\n\t\t\t\tsrc2 = (OPJ_UINT32)pSrc[i+2];\n\t\t\t}\n\t\t}\n\t\t*pDst++ = (OPJ_BYTE)((src0 << 2) | (src1 >> 4));\n\t\tif (length > 1U) {\n\t\t\t*pDst++ = (OPJ_BYTE)(((src1 & 0xFU) << 4) | (src2 >> 2));\n\t\t\tif (length > 2U) {\n\t\t\t\t*pDst++ = (OPJ_BYTE)(((src2 & 0x3U) << 6));\n\t\t\t}\n\t\t}\n\t}\n}\nstatic void convert_32s8u_C1R(const OPJ_INT32* pSrc, OPJ_BYTE* pDst, OPJ_SIZE_T length)\n{\n\tOPJ_SIZE_T i;\n\tfor (i = 0; i < length; ++i) {\n\t\tpDst[i] = (OPJ_BYTE)pSrc[i];\n\t}\n}\nconst convert_32sXXx_C1R convert_32sXXu_C1R_LUT[9] = {\n\tNULL,\n\tconvert_32s1u_C1R,\n\tconvert_32s2u_C1R,\n\tNULL,\n\tconvert_32s4u_C1R,\n\tNULL,\n\tconvert_32s6u_C1R,\n\tNULL,\n\tconvert_32s8u_C1R\n};\n\n/* -->> -->> -->> -->>\n\n  TGA IMAGE FORMAT\n\n <<-- <<-- <<-- <<-- */\n\n#ifdef INFORMATION_ONLY\n/* TGA header definition. */\nstruct tga_header\n{                           \n    unsigned char   id_length;              /* Image id field length    */\n    unsigned char   colour_map_type;        /* Colour map type          */\n    unsigned char   image_type;             /* Image type               */\n    /*\n    ** Colour map specification\n    */\n    unsigned short  colour_map_index;       /* First entry index        */\n    unsigned short  colour_map_length;      /* Colour map length        */\n    unsigned char   colour_map_entry_size;  /* Colour map entry size    */\n    /*\n    ** Image specification\n    */\n    unsigned short  x_origin;               /* x origin of image        */\n    unsigned short  y_origin;               /* u origin of image        */\n    unsigned short  image_width;            /* Image width              */\n    unsigned short  image_height;           /* Image height             */\n    unsigned char   pixel_depth;            /* Pixel depth              */\n    unsigned char   image_desc;             /* Image descriptor         */\n};\n#endif /* INFORMATION_ONLY */\n\nstatic unsigned short get_ushort(const unsigned char *data) {\n    unsigned short val = *(const unsigned short *)data;\n#ifdef OPJ_BIG_ENDIAN\n    val = ((val & 0xffU) << 8) | (val >> 8);\n#endif\n    return val;\n}\n\n#define TGA_HEADER_SIZE 18\n\nstatic int tga_readheader(FILE *fp, unsigned int *bits_per_pixel, \n                          unsigned int *width, unsigned int *height, int *flip_image)\n{\n    int palette_size;\n    unsigned char tga[TGA_HEADER_SIZE];\n    unsigned char id_len, /*cmap_type,*/ image_type;\n    unsigned char pixel_depth, image_desc;\n    unsigned short /*cmap_index,*/ cmap_len, cmap_entry_size;\n    unsigned short /*x_origin, y_origin,*/ image_w, image_h;\n\n    if (!bits_per_pixel || !width || !height || !flip_image)\n        return 0;\n\n    if ( fread(tga, TGA_HEADER_SIZE, 1, fp) != 1 )\n    {\n        fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0 ;\n    }\n    id_len = tga[0];\n    /*cmap_type = tga[1];*/\n    image_type = tga[2];\n    /*cmap_index = get_ushort(&tga[3]);*/\n    cmap_len = get_ushort(&tga[5]);\n    cmap_entry_size = tga[7];\n\n\n#if 0\n    x_origin = get_ushort(&tga[8]);\n    y_origin = get_ushort(&tga[10]);\n#endif\n    image_w = get_ushort(&tga[12]);\n    image_h = get_ushort(&tga[14]);\n    pixel_depth = tga[16];\n    image_desc  = tga[17];\n\n    *bits_per_pixel = (unsigned int)pixel_depth;\n    *width  = (unsigned int)image_w;\n    *height = (unsigned int)image_h;\n\n    /* Ignore tga identifier, if present ... */\n    if (id_len)\n    {\n        unsigned char *id = (unsigned char *) malloc(id_len);\n\t\tif(id == 0){\n\t\t\tfprintf(stderr, \"tga_readheader: memory out\\n\");\n\t\t\treturn 0;\n\t\t}\n        if ( !fread(id, id_len, 1, fp) )\n        {\n            fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n            free(id);\n            return 0 ;\n        }\n        free(id);\n    }\n\n    /* Test for compressed formats ... not yet supported ...\n    // Note :-  9 - RLE encoded palettized.\n    //\t  \t   10 - RLE encoded RGB. */\n    if (image_type > 8)\n    {\n        fprintf(stderr, \"Sorry, compressed tga files are not currently supported.\\n\");\n        return 0 ;\n    }\n\n    *flip_image = !(image_desc & 32);\n\n    /* Palettized formats are not yet supported, skip over the palette, if present ... */\n    palette_size = cmap_len * (cmap_entry_size/8);\n\n    if (palette_size>0)\n    {\n        fprintf(stderr, \"File contains a palette - not yet supported.\");\n        fseek(fp, palette_size, SEEK_CUR);\n    }\n    return 1;\n}\n\n#ifdef OPJ_BIG_ENDIAN\n\nstatic INLINE OPJ_UINT16 swap16(OPJ_UINT16 x)\n{\n    return (OPJ_UINT16)(((x & 0x00ffU) <<  8) | ((x & 0xff00U) >>  8));\n}\n\n#endif\n\nstatic int tga_writeheader(FILE *fp, int bits_per_pixel, int width, int height, \n                           OPJ_BOOL flip_image)\n{\n    OPJ_UINT16 image_w, image_h, us0;\n    unsigned char uc0, image_type;\n    unsigned char pixel_depth, image_desc;\n\n    if (!bits_per_pixel || !width || !height)\n        return 0;\n\n    pixel_depth = 0;\n\n    if ( bits_per_pixel < 256 )\n        pixel_depth = (unsigned char)bits_per_pixel;\n    else{\n        fprintf(stderr,\"ERROR: Wrong bits per pixel inside tga_header\");\n        return 0;\n    }\n    uc0 = 0;\n\n    if(fwrite(&uc0, 1, 1, fp) != 1) goto fails; /* id_length */\n    if(fwrite(&uc0, 1, 1, fp) != 1) goto fails; /* colour_map_type */\n\n    image_type = 2; /* Uncompressed. */\n    if(fwrite(&image_type, 1, 1, fp) != 1) goto fails;\n\n    us0 = 0;\n    if(fwrite(&us0, 2, 1, fp) != 1) goto fails; /* colour_map_index */\n    if(fwrite(&us0, 2, 1, fp) != 1) goto fails; /* colour_map_length */\n    if(fwrite(&uc0, 1, 1, fp) != 1) goto fails; /* colour_map_entry_size */\n\n    if(fwrite(&us0, 2, 1, fp) != 1) goto fails; /* x_origin */\n    if(fwrite(&us0, 2, 1, fp) != 1) goto fails; /* y_origin */\n\n    image_w = (unsigned short)width;\n    image_h = (unsigned short) height;\n\n#ifndef OPJ_BIG_ENDIAN\n    if(fwrite(&image_w, 2, 1, fp) != 1) goto fails;\n    if(fwrite(&image_h, 2, 1, fp) != 1) goto fails;\n#else\n    image_w = swap16(image_w);\n    image_h = swap16(image_h);\n    if(fwrite(&image_w, 2, 1, fp) != 1) goto fails;\n    if(fwrite(&image_h, 2, 1, fp) != 1) goto fails;\n#endif\n\n    if(fwrite(&pixel_depth, 1, 1, fp) != 1) goto fails;\n\n    image_desc = 8; /* 8 bits per component. */\n\n    if (flip_image)\n        image_desc |= 32;\n    if(fwrite(&image_desc, 1, 1, fp) != 1) goto fails;\n\n    return 1;\n\nfails:\n    fputs(\"\\nwrite_tgaheader: write ERROR\\n\", stderr);\n    return 0;\n}\n\nopj_image_t* tgatoimage(const char *filename, opj_cparameters_t *parameters) {\n    FILE *f;\n    opj_image_t *image;\n    unsigned int image_width, image_height, pixel_bit_depth;\n    unsigned int x, y;\n    int flip_image=0;\n    opj_image_cmptparm_t cmptparm[4];\t/* maximum 4 components */\n    int numcomps;\n    OPJ_COLOR_SPACE color_space;\n    OPJ_BOOL mono ;\n    OPJ_BOOL save_alpha;\n    int subsampling_dx, subsampling_dy;\n    int i;\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        fprintf(stderr, \"Failed to open %s for reading !!\\n\", filename);\n        return 0;\n    }\n\n    if (!tga_readheader(f, &pixel_bit_depth, &image_width, &image_height, &flip_image)) {\n        fclose(f);\n        return NULL;\n    }\n\n    /* We currently only support 24 & 32 bit tga's ... */\n    if (!((pixel_bit_depth == 24) || (pixel_bit_depth == 32))) {\n        fclose(f);\n        return NULL;\n    }\n\n    /* initialize image components */\n    memset(&cmptparm[0], 0, 4 * sizeof(opj_image_cmptparm_t));\n\n    mono = (pixel_bit_depth == 8) || (pixel_bit_depth == 16);  /* Mono with & without alpha. */\n    save_alpha = (pixel_bit_depth == 16) || (pixel_bit_depth == 32); /* Mono with alpha, or RGB with alpha */\n\n    if (mono) {\n        color_space = OPJ_CLRSPC_GRAY;\n        numcomps = save_alpha ? 2 : 1;\n    }\n    else {\n        numcomps = save_alpha ? 4 : 3;\n        color_space = OPJ_CLRSPC_SRGB;\n    }\n\n    subsampling_dx = parameters->subsampling_dx;\n    subsampling_dy = parameters->subsampling_dy;\n\n    for (i = 0; i < numcomps; i++) {\n        cmptparm[i].prec = 8;\n        cmptparm[i].bpp = 8;\n        cmptparm[i].sgnd = 0;\n        cmptparm[i].dx = (OPJ_UINT32)subsampling_dx;\n        cmptparm[i].dy = (OPJ_UINT32)subsampling_dy;\n        cmptparm[i].w = image_width;\n        cmptparm[i].h = image_height;\n    }\n\n    /* create the image */\n    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);\n\n    if (!image) {\n        fclose(f);\n        return NULL;\n    }\n\n\n    /* set image offset and reference grid */\n    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n    image->x1 =\t!image->x0 ? (OPJ_UINT32)(image_width - 1)  * (OPJ_UINT32)subsampling_dx + 1 : image->x0 + (OPJ_UINT32)(image_width - 1)  * (OPJ_UINT32)subsampling_dx + 1;\n    image->y1 =\t!image->y0 ? (OPJ_UINT32)(image_height - 1) * (OPJ_UINT32)subsampling_dy + 1 : image->y0 + (OPJ_UINT32)(image_height - 1) * (OPJ_UINT32)subsampling_dy + 1;\n\n    /* set image data */\n    for (y=0; y < image_height; y++)\n    {\n        int index;\n\n        if (flip_image)\n            index = (int)((image_height-y-1)*image_width);\n        else\n            index = (int)(y*image_width);\n\n        if (numcomps==3)\n        {\n            for (x=0;x<image_width;x++)\n            {\n                unsigned char r,g,b;\n\n                if( !fread(&b, 1, 1, f) )\n                {\n                    fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if ( !fread(&g, 1, 1, f) )\n                {\n                    fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if ( !fread(&r, 1, 1, f) )\n                {\n                    fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n\n                image->comps[0].data[index]=r;\n                image->comps[1].data[index]=g;\n                image->comps[2].data[index]=b;\n                index++;\n            }\n        }\n        else if (numcomps==4)\n        {\n            for (x=0;x<image_width;x++)\n            {\n                unsigned char r,g,b,a;\n                if ( !fread(&b, 1, 1, f) )\n                {\n                    fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if ( !fread(&g, 1, 1, f) )\n                {\n                    fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if ( !fread(&r, 1, 1, f) )\n                {\n                    fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if ( !fread(&a, 1, 1, f) )\n                {\n                    fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n\n                image->comps[0].data[index]=r;\n                image->comps[1].data[index]=g;\n                image->comps[2].data[index]=b;\n                image->comps[3].data[index]=a;\n                index++;\n            }\n        }\n        else {\n            fprintf(stderr, \"Currently unsupported bit depth : %s\\n\", filename);\n        }\n    }\n    fclose(f);\n    return image;\n}\n\nint imagetotga(opj_image_t * image, const char *outfile) {\n    int width, height, bpp, x, y;\n    OPJ_BOOL write_alpha;\n    unsigned int i;\n    int adjustR, adjustG, adjustB, fails;\n    unsigned int alpha_channel;\n    float r,g,b,a;\n    unsigned char value;\n    float scale;\n    FILE *fdest;\n    size_t res;\n    fails = 1;\n\n    fdest = fopen(outfile, \"wb\");\n    if (!fdest) {\n        fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n        return 1;\n    }\n\n    for (i = 0; i < image->numcomps-1; i++)\t{\n        if ((image->comps[0].dx != image->comps[i+1].dx)\n                ||(image->comps[0].dy != image->comps[i+1].dy)\n                ||(image->comps[0].prec != image->comps[i+1].prec)\n\t\t\t\t||(image->comps[0].sgnd != image->comps[i+1].sgnd))\t{\n            fclose(fdest);\n            fprintf(stderr, \"Unable to create a tga file with such J2K image charateristics.\");\n            return 1;\n        }\n    }\n\n    width  = (int)image->comps[0].w;\n    height = (int)image->comps[0].h;\n\n    /* Mono with alpha, or RGB with alpha. */\n    write_alpha = (image->numcomps==2) || (image->numcomps==4);\n\n    /* Write TGA header  */\n    bpp = write_alpha ? 32 : 24;\n\n    if (!tga_writeheader(fdest, bpp, width , height, OPJ_TRUE))\n\t\tgoto fin;\n\n    alpha_channel = image->numcomps-1;\n\n    scale = 255.0f / (float)((1<<image->comps[0].prec)-1);\n\n    adjustR = (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n    adjustG = (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);\n    adjustB = (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);\n\n\tfor (y=0; y < height; y++) \n   {\n\tunsigned int index= (unsigned int)(y*width);\n\n\tfor (x=0; x < width; x++, index++)\t\n  {\n\tr = (float)(image->comps[0].data[index] + adjustR);\n\n\tif (image->numcomps > 2) \n {\n\tg = (float)(image->comps[1].data[index] + adjustG);\n\tb = (float)(image->comps[2].data[index] + adjustB);\n }\n\telse  \n {/* Greyscale ... */\n\tg = r;\n\tb = r;\n }\n\n/* TGA format writes BGR ... */\n\tif(b > 255.) b = 255.; else if(b < 0.) b = 0.;\n\tvalue = (unsigned char)(b*scale);\n\tres = fwrite(&value,1,1,fdest);\n\n\tif( res < 1 ) \n {\n \tfprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n\tgoto fin;\n }\n\tif(g > 255.) g = 255.; else if(g < 0.) g = 0.;\n\tvalue = (unsigned char)(g*scale);\n\tres = fwrite(&value,1,1,fdest);\n\n\tif( res < 1 ) \n {\n\tfprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n\tgoto fin;\n }\n\tif(r > 255.) r = 255.; else if(r < 0.) r = 0.;\n\tvalue = (unsigned char)(r*scale);\n\tres = fwrite(&value,1,1,fdest);\n\n\tif( res < 1 ) \n {\n\tfprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n\tgoto fin;\n }\n\n\tif (write_alpha) \n {\n\ta = (float)(image->comps[alpha_channel].data[index]);\n\tif(a > 255.) a = 255.; else if(a < 0.) a = 0.;\n\tvalue = (unsigned char)(a*scale);\n\tres = fwrite(&value,1,1,fdest);\n\n\t\tif( res < 1 ) \n\t   {\n\t\tfprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n\t\tgoto fin;\n\t   }\n }\n  }\n   }\n\tfails = 0;\nfin:\n\tfclose(fdest);\n\n\treturn fails;\n}\n\n/* -->> -->> -->> -->>\n\nPGX IMAGE FORMAT\n\n<<-- <<-- <<-- <<-- */\n\n\nstatic unsigned char readuchar(FILE * f)\n{\n    unsigned char c1;\n    if ( !fread(&c1, 1, 1, f) )\n    {\n        fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    return c1;\n}\n\nstatic unsigned short readushort(FILE * f, int bigendian)\n{\n    unsigned char c1, c2;\n    if ( !fread(&c1, 1, 1, f) )\n    {\n        fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if ( !fread(&c2, 1, 1, f) )\n    {\n        fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (bigendian)\n        return (unsigned short)((c1 << 8) + c2);\n    else\n        return (unsigned short)((c2 << 8) + c1);\n}\n\nstatic unsigned int readuint(FILE * f, int bigendian)\n{\n    unsigned char c1, c2, c3, c4;\n    if ( !fread(&c1, 1, 1, f) )\n    {\n        fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if ( !fread(&c2, 1, 1, f) )\n    {\n        fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if ( !fread(&c3, 1, 1, f) )\n    {\n        fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if ( !fread(&c4, 1, 1, f) )\n    {\n        fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (bigendian)\n        return (unsigned int)(c1 << 24) + (unsigned int)(c2 << 16) + (unsigned int)(c3 << 8) + c4;\n    else\n        return (unsigned int)(c4 << 24) + (unsigned int)(c3 << 16) + (unsigned int)(c2 << 8) + c1;\n}\n\nopj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters) {\n    FILE *f = NULL;\n    int w, h, prec;\n    int i, numcomps, max;\n    OPJ_COLOR_SPACE color_space;\n    opj_image_cmptparm_t cmptparm;\t/* maximum of 1 component  */\n    opj_image_t * image = NULL;\n    int adjustS, ushift, dshift, force8;\n\n    char endian1,endian2,sign;\n    char signtmp[32];\n\n    char temp[32];\n    int bigendian;\n    opj_image_comp_t *comp = NULL;\n\n    numcomps = 1;\n    color_space = OPJ_CLRSPC_GRAY;\n\n    memset(&cmptparm, 0, sizeof(opj_image_cmptparm_t));\n\n    max = 0;\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        fprintf(stderr, \"Failed to open %s for reading !\\n\", filename);\n        return NULL;\n    }\n\n    fseek(f, 0, SEEK_SET);\n    if( fscanf(f, \"PG%[ \\t]%c%c%[ \\t+-]%d%[ \\t]%d%[ \\t]%d\",temp,&endian1,&endian2,signtmp,&prec,temp,&w,temp,&h) != 9){\n        fclose(f);\n        fprintf(stderr, \"ERROR: Failed to read the right number of element from the fscanf() function!\\n\");\n        return NULL;\n    }\n\n    i=0;\n    sign='+';\n    while (signtmp[i]!='\\0') {\n        if (signtmp[i]=='-') sign='-';\n        i++;\n    }\n\n    fgetc(f);\n    if (endian1=='M' && endian2=='L') {\n        bigendian = 1;\n    } else if (endian2=='M' && endian1=='L') {\n        bigendian = 0;\n    } else {\n        fclose(f);\n        fprintf(stderr, \"Bad pgx header, please check input file\\n\");\n        return NULL;\n    }\n\n    /* initialize image component */\n\n    cmptparm.x0 = (OPJ_UINT32)parameters->image_offset_x0;\n    cmptparm.y0 = (OPJ_UINT32)parameters->image_offset_y0;\n    cmptparm.w = !cmptparm.x0 ? (OPJ_UINT32)((w - 1) * parameters->subsampling_dx + 1) : cmptparm.x0 + (OPJ_UINT32)(w - 1) * (OPJ_UINT32)parameters->subsampling_dx + 1;\n    cmptparm.h = !cmptparm.y0 ? (OPJ_UINT32)((h - 1) * parameters->subsampling_dy + 1) : cmptparm.y0 + (OPJ_UINT32)(h - 1) * (OPJ_UINT32)parameters->subsampling_dy + 1;\n\n    if (sign == '-') {\n        cmptparm.sgnd = 1;\n    } else {\n        cmptparm.sgnd = 0;\n    }\n    if(prec < 8)\n    {\n        force8 = 1;\n        ushift = 8 - prec; dshift = prec - ushift;\n        if(cmptparm.sgnd) adjustS = (1<<(prec - 1)); else adjustS = 0;\n        cmptparm.sgnd = 0;\n        prec = 8;\n    }\n    else ushift = dshift = force8 = adjustS = 0;\n\n    cmptparm.prec = (OPJ_UINT32)prec;\n    cmptparm.bpp = (OPJ_UINT32)prec;\n    cmptparm.dx = (OPJ_UINT32)parameters->subsampling_dx;\n    cmptparm.dy = (OPJ_UINT32)parameters->subsampling_dy;\n\n    /* create the image */\n    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm, color_space);\n    if(!image) {\n        fclose(f);\n        return NULL;\n    }\n    /* set image offset and reference grid */\n    image->x0 = cmptparm.x0;\n    image->y0 = cmptparm.x0;\n    image->x1 = cmptparm.w;\n    image->y1 = cmptparm.h;\n\n    /* set image data */\n\n    comp = &image->comps[0];\n\n    for (i = 0; i < w * h; i++) {\n        int v;\n        if(force8)\n        {\n            v = readuchar(f) + adjustS;\n            v = (v<<ushift) + (v>>dshift);\n            comp->data[i] = (unsigned char)v;\n\n            if(v > max) max = v;\n\n            continue;\n        }\n        if (comp->prec == 8) {\n            if (!comp->sgnd) {\n                v = readuchar(f);\n            } else {\n                v = (char) readuchar(f);\n            }\n        } else if (comp->prec <= 16) {\n            if (!comp->sgnd) {\n                v = readushort(f, bigendian);\n            } else {\n                v = (short) readushort(f, bigendian);\n            }\n        } else {\n            if (!comp->sgnd) {\n                v = (int)readuint(f, bigendian);\n            } else {\n                v = (int) readuint(f, bigendian);\n            }\n        }\n        if (v > max)\n            max = v;\n        comp->data[i] = v;\n    }\n    fclose(f);\n    comp->bpp = (OPJ_UINT32)int_floorlog2(max) + 1;\n\n    return image;\n}\n\n#define CLAMP(x,a,b) x < a ? a : (x > b ? b : x)\n\nstatic INLINE int clamp( const int value, const int prec, const int sgnd )\n{\n  if( sgnd )\n    {\n    if (prec <= 8)       return CLAMP(value,-128,127);\n    else if (prec <= 16) return CLAMP(value,-32768,32767);\n    else                 return CLAMP(value,-2147483647-1,2147483647);\n    }\n  else\n    {\n    if (prec <= 8)       return CLAMP(value,0,255);\n    else if (prec <= 16) return CLAMP(value,0,65535);\n    else                 return value; /*CLAMP(value,0,4294967295);*/\n    }\n}\n\nint imagetopgx(opj_image_t * image, const char *outfile) \n{\n  int w, h;\n  int i, j, fails = 1;\n  unsigned int compno;\n  FILE *fdest = NULL;\n\n  for (compno = 0; compno < image->numcomps; compno++) \n\t{\n    opj_image_comp_t *comp = &image->comps[compno];\n    char bname[256]; /* buffer for name */\n    char *name = bname; /* pointer */\n    int nbytes = 0;\n    size_t res;\n    const size_t olen = strlen(outfile);\n    const size_t dotpos = olen - 4;\n    const size_t total = dotpos + 1 + 1 + 4; /* '-' + '[1-3]' + '.pgx' */\n\n    if( outfile[dotpos] != '.' ) \n\t\t{\n      /* `pgx` was recognized but there is no dot at expected position */\n      fprintf(stderr, \"ERROR -> Impossible happen.\" );\n      goto fin;\n\t\t}\n    if( total > 256 ) \n\t\t{\n      name = (char*)malloc(total+1);\n\t\t\tif (name == NULL) {\n\t\t\t\tfprintf(stderr, \"imagetopgx: memory out\\n\");\n\t\t\t\tgoto fin;\n\t\t\t}\n\t\t}\n    strncpy(name, outfile, dotpos);\n    sprintf(name+dotpos, \"_%u.pgx\", compno);\n    fdest = fopen(name, \"wb\");\n    /* don't need name anymore */\n\t\t\t\n    if (!fdest) \n\t\t{\n\t\t\t\t\n      fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", name);\n\t\t\tif( total > 256 ) free(name);\n      goto fin;\n\t\t}\n\n    w = (int)image->comps[compno].w;\n    h = (int)image->comps[compno].h;\n\n    fprintf(fdest, \"PG ML %c %d %d %d\\n\", comp->sgnd ? '-' : '+', comp->prec,\n      w, h);\n\n    if (comp->prec <= 8) \n      nbytes = 1;\n    else if (comp->prec <= 16)\n      nbytes = 2;\n    else\n      nbytes = 4;\n\n    for (i = 0; i < w * h; i++) \n\t\t{\n      /* FIXME: clamp func is being called within a loop */\n      const int val = clamp(image->comps[compno].data[i],\n        (int)comp->prec, (int)comp->sgnd);\n\n      for (j = nbytes - 1; j >= 0; j--) \n\t\t\t{\n        int v = (int)(val >> (j * 8));\n        unsigned char byte = (unsigned char)v;\n        res = fwrite(&byte, 1, 1, fdest);\n\n        if( res < 1 ) \n\t\t\t\t{\n          fprintf(stderr, \"failed to write 1 byte for %s\\n\", name);\n\t\t\t\t\tif( total > 256 ) free(name);\n          goto fin;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( total > 256 ) free(name);\n    fclose(fdest); fdest = NULL;\n\t}\n  fails = 0;\nfin:\n  if(fdest) fclose(fdest);\n\n  return fails;\n}\n\n/* -->> -->> -->> -->>\n\nPNM IMAGE FORMAT\n\n<<-- <<-- <<-- <<-- */\n\nstruct pnm_header\n{\n    int width, height, maxval, depth, format;\n    char rgb, rgba, gray, graya, bw;\n    char ok;\n};\n\nstatic char *skip_white(char *s)\n{\n    if (s != NULL)\n    {\n        while(*s)\n        {\n            if(*s == '\\n' || *s == '\\r') return NULL;\n            if(isspace(*s)) { ++s; continue; }\n            return s;\n        }\n    }\n    return NULL;\n}\n\nstatic char *skip_int(char *start, int *out_n)\n{\n    char *s;\n    char c;\n\n    *out_n = 0;\n\n    s = skip_white(start);\n    if(s == NULL) return NULL;\n    start = s;\n\n    while(*s)\n    {\n        if( !isdigit(*s)) break;\n        ++s;\n    }\n    c = *s; *s = 0; *out_n = atoi(start); *s = c;\n    return s;\n}\n\nstatic char *skip_idf(char *start, char out_idf[256])\n{\n    char *s;\n    char c;\n\n    s = skip_white(start);\n    if(s == NULL) return NULL;\n    start = s;\n\n    while(*s)\n    {\n        if(isalpha(*s) || *s == '_') { ++s; continue; }\n        break;\n    }\n    c = *s; *s = 0; strncpy(out_idf, start, 255); *s = c;\n    return s;\n}\n\nstatic void read_pnm_header(FILE *reader, struct pnm_header *ph)\n{\n    int format, end, ttype;\n    char idf[256], type[256];\n    char line[256];\n\n    if (fgets(line, 250, reader) == NULL)\n    {\n        fprintf(stderr,\"\\nWARNING: fgets return a NULL value\");\n        return;\n    }\n\n    if(line[0] != 'P')\n    {\n        fprintf(stderr,\"read_pnm_header:PNM:magic P missing\\n\"); return;\n    }\n    format = atoi(line + 1);\n    if(format < 1 || format > 7)\n    {\n        fprintf(stderr,\"read_pnm_header:magic format %d invalid\\n\", format);\n        return;\n    }\n    ph->format = format;\n    ttype = end = 0;\n\n    while(fgets(line, 250, reader))\n    {\n        char *s;\n        int allow_null = 0;\n\n        if(*line == '#') continue;\n\n        s = line;\n\n        if(format == 7)\n        {\n            s = skip_idf(s, idf);\n\n            if(s == NULL || *s == 0) return;\n\n            if(strcmp(idf, \"ENDHDR\") == 0)\n            {\n                end = 1; break;\n            }\n            if(strcmp(idf, \"WIDTH\") == 0)\n            {\n                s = skip_int(s, &ph->width);\n                if(s == NULL || *s == 0) return;\n\n                continue;\n            }\n            if(strcmp(idf, \"HEIGHT\") == 0)\n            {\n                s = skip_int(s, &ph->height);\n                if(s == NULL || *s == 0) return;\n\n                continue;\n            }\n            if(strcmp(idf, \"DEPTH\") == 0)\n            {\n                s = skip_int(s, &ph->depth);\n                if(s == NULL || *s == 0) return;\n\n                continue;\n            }\n            if(strcmp(idf, \"MAXVAL\") == 0)\n            {\n                s = skip_int(s, &ph->maxval);\n                if(s == NULL || *s == 0) return;\n\n                continue;\n            }\n            if(strcmp(idf, \"TUPLTYPE\") == 0)\n            {\n                s = skip_idf(s, type);\n                if(s == NULL || *s == 0) return;\n\n                if(strcmp(type, \"BLACKANDWHITE\") == 0)\n                {\n                    ph->bw = 1; ttype = 1; continue;\n                }\n                if(strcmp(type, \"GRAYSCALE\") == 0)\n                {\n                    ph->gray = 1; ttype = 1; continue;\n                }\n                if(strcmp(type, \"GRAYSCALE_ALPHA\") == 0)\n                {\n                    ph->graya = 1; ttype = 1; continue;\n                }\n                if(strcmp(type, \"RGB\") == 0)\n                {\n                    ph->rgb = 1; ttype = 1; continue;\n                }\n                if(strcmp(type, \"RGB_ALPHA\") == 0)\n                {\n                    ph->rgba = 1; ttype = 1; continue;\n                }\n                fprintf(stderr,\"read_pnm_header:unknown P7 TUPLTYPE %s\\n\",type);\n                return;\n            }\n            fprintf(stderr,\"read_pnm_header:unknown P7 idf %s\\n\",idf);\n            return;\n        } /* if(format == 7) */\n\n        /* Here format is in range [1,6] */\n        if (ph->width == 0) {\n            s = skip_int(s, &ph->width);\n            if ((s == NULL) || (*s == 0) || (ph->width < 1)) return;\n            allow_null = 1;\n        }\n        if (ph->height == 0) {\n            s = skip_int(s, &ph->height);\n            if ((s == NULL) && allow_null) continue;\n            if ((s == NULL) || (*s == 0) || (ph->height < 1)) return;\n            if(format == 1 || format == 4) {\n                break;\n            }\n            allow_null = 1;\n        }\n        /* here, format is in P2, P3, P5, P6 */\n        s = skip_int(s, &ph->maxval);\n        if ((s == NULL) && allow_null) continue;\n        if ((s == NULL) || (*s == 0)) return;\n        break;\n    }/* while(fgets( ) */\n    if(format == 2 || format == 3 || format > 4)\n    {\n        if(ph->maxval < 1 || ph->maxval > 65535) return;\n    }\n    if(ph->width < 1 || ph->height < 1) return;\n\n    if(format == 7)\n    {\n        if(!end)\n        {\n            fprintf(stderr,\"read_pnm_header:P7 without ENDHDR\\n\"); return;\n        }\n        if(ph->depth < 1 || ph->depth > 4) return;\n\n        if (ttype)\n            ph->ok = 1;\n    }\n    else\n    {\n        ph->ok = 1;\n        if(format == 1 || format == 4)\n        {\n            ph->maxval = 255;\n        }\n    }\n}\n\nstatic int has_prec(int val)\n{\n    if(val < 2) return 1;\n    if(val < 4) return 2;\n    if(val < 8) return 3;\n    if(val < 16) return 4;\n    if(val < 32) return 5;\n    if(val < 64) return 6;\n    if(val < 128) return 7;\n    if(val < 256) return 8;\n    if(val < 512) return 9;\n    if(val < 1024) return 10;\n    if(val < 2048) return 11;\n    if(val < 4096) return 12;\n    if(val < 8192) return 13;\n    if(val < 16384) return 14;\n    if(val < 32768) return 15;\n    return 16;\n}\n\nopj_image_t* pnmtoimage(const char *filename, opj_cparameters_t *parameters) {\n    int subsampling_dx = parameters->subsampling_dx;\n    int subsampling_dy = parameters->subsampling_dy;\n\n    FILE *fp = NULL;\n    int i, compno, numcomps, w, h, prec, format;\n    OPJ_COLOR_SPACE color_space;\n    opj_image_cmptparm_t cmptparm[4]; /* RGBA: max. 4 components */\n    opj_image_t * image = NULL;\n    struct pnm_header header_info;\n\n    if((fp = fopen(filename, \"rb\")) == NULL)\n    {\n        fprintf(stderr, \"pnmtoimage:Failed to open %s for reading!\\n\",filename);\n        return NULL;\n    }\n    memset(&header_info, 0, sizeof(struct pnm_header));\n\n    read_pnm_header(fp, &header_info);\n\n    if(!header_info.ok) { fclose(fp); return NULL; }\n\n    format = header_info.format;\n\n    switch(format)\n    {\n    case 1: /* ascii bitmap */\n    case 4: /* raw bitmap */\n        numcomps = 1;\n        break;\n\n    case 2: /* ascii greymap */\n    case 5: /* raw greymap */\n        numcomps = 1;\n        break;\n\n    case 3: /* ascii pixmap */\n    case 6: /* raw pixmap */\n        numcomps = 3;\n        break;\n\n    case 7: /* arbitrary map */\n        numcomps = header_info.depth;\n        break;\n\n    default: fclose(fp); return NULL;\n    }\n    if(numcomps < 3)\n        color_space = OPJ_CLRSPC_GRAY;/* GRAY, GRAYA */\n    else\n        color_space = OPJ_CLRSPC_SRGB;/* RGB, RGBA */\n\n    prec = has_prec(header_info.maxval);\n\n    if(prec < 8) prec = 8;\n\n    w = header_info.width;\n    h = header_info.height;\n    subsampling_dx = parameters->subsampling_dx;\n    subsampling_dy = parameters->subsampling_dy;\n\n    memset(&cmptparm[0], 0, (size_t)numcomps * sizeof(opj_image_cmptparm_t));\n\n    for(i = 0; i < numcomps; i++)\n    {\n        cmptparm[i].prec = (OPJ_UINT32)prec;\n        cmptparm[i].bpp = (OPJ_UINT32)prec;\n        cmptparm[i].sgnd = 0;\n        cmptparm[i].dx = (OPJ_UINT32)subsampling_dx;\n        cmptparm[i].dy = (OPJ_UINT32)subsampling_dy;\n        cmptparm[i].w = (OPJ_UINT32)w;\n        cmptparm[i].h = (OPJ_UINT32)h;\n    }\n    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);\n\n    if(!image) { fclose(fp); return NULL; }\n\n    /* set image offset and reference grid */\n    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n    image->x1 = (OPJ_UINT32)(parameters->image_offset_x0 + (w - 1) * subsampling_dx + 1);\n    image->y1 = (OPJ_UINT32)(parameters->image_offset_y0 + (h - 1) * subsampling_dy + 1);\n\n    if((format == 2) || (format == 3)) /* ascii pixmap */\n    {\n        unsigned int index;\n\n        for (i = 0; i < w * h; i++)\n        {\n            for(compno = 0; compno < numcomps; compno++)\n            {\n                index = 0;\n                if (fscanf(fp, \"%u\", &index) != 1)\n                    fprintf(stderr, \"\\nWARNING: fscanf return a number of element different from the expected.\\n\");\n\n                image->comps[compno].data[i] = (OPJ_INT32)(index * 255)/header_info.maxval;\n            }\n        }\n    }\n    else\n        if((format == 5)\n                || (format == 6)\n                ||((format == 7)\n                   && (   header_info.gray || header_info.graya\n                          || header_info.rgb || header_info.rgba)))/* binary pixmap */\n        {\n            unsigned char c0, c1, one;\n\n            one = (prec < 9);\n\n            for (i = 0; i < w * h; i++)\n            {\n                for(compno = 0; compno < numcomps; compno++)\n                {\n                if ( !fread(&c0, 1, 1, fp) )\n                  {\n                  fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n                  opj_image_destroy(image);\n                  fclose(fp);\n                  return NULL;\n                  }\n                    if(one)\n                    {\n                        image->comps[compno].data[i] = c0;\n                    }\n                    else\n                    {\n                        if ( !fread(&c1, 1, 1, fp) )\n                            fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n                        /* netpbm: */\n                        image->comps[compno].data[i] = ((c0<<8) | c1);\n                    }\n                }\n            }\n        }\n        else\n            if(format == 1) /* ascii bitmap */\n            {\n                for (i = 0; i < w * h; i++)\n                {\n                    unsigned int index;\n\n                    if ( fscanf(fp, \"%u\", &index) != 1)\n                        fprintf(stderr, \"\\nWARNING: fscanf return a number of element different from the expected.\\n\");\n\n                    image->comps[0].data[i] = (index?0:255);\n                }\n            }\n            else\n                if(format == 4)\n                {\n                    int x, y, bit;\n                    unsigned char uc;\n\n                    i = 0;\n                    for(y = 0; y < h; ++y)\n                    {\n                        bit = -1; uc = 0;\n\n                        for(x = 0; x < w; ++x)\n                        {\n                            if(bit == -1)\n                            {\n                                bit = 7;\n                                uc = (unsigned char)getc(fp);\n                            }\n                            image->comps[0].data[i] = (((uc>>bit) & 1)?0:255);\n                            --bit; ++i;\n                        }\n                    }\n                }\n                else\n                    if((format == 7 && header_info.bw)) /*MONO*/\n                    {\n                        unsigned char uc;\n\n                        for(i = 0; i < w * h; ++i)\n                        {\n                            if ( !fread(&uc, 1, 1, fp) )\n                                fprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n                            image->comps[0].data[i] = (uc & 1)?0:255;\n                        }\n                    }\n    fclose(fp);\n\n    return image;\n}/* pnmtoimage() */\n\nint imagetopnm(opj_image_t * image, const char *outfile, int force_split)\n{\n    int *red, *green, *blue, *alpha;\n    int wr, hr, max;\n    int i;\n    unsigned int compno, ncomp, ui;\n    int adjustR, adjustG, adjustB, adjustA;\n    int fails, two, want_gray, has_alpha, triple;\n    int prec, v;\n    FILE *fdest = NULL;\n    const char *tmp = outfile;\n    char *destname;\n\n    alpha = NULL;\n\n    if((prec = (int)image->comps[0].prec) > 16)\n    {\n        fprintf(stderr,\"%s:%d:imagetopnm\\n\\tprecision %d is larger than 16\"\n                \"\\n\\t: refused.\\n\",__FILE__,__LINE__,prec);\n        return 1;\n    }\n    two = has_alpha = 0; fails = 1;\n    ncomp = image->numcomps;\n\n    while (*tmp) ++tmp; tmp -= 2;\n    want_gray = (*tmp == 'g' || *tmp == 'G');\n    ncomp = image->numcomps;\n\n    if(want_gray) ncomp = 1;\n\n    for (ui = 1; ui < ncomp; ++ui) {\n        if (image->comps[0].dx != image->comps[ui].dx) {\n            break;\n        }\n        if (image->comps[0].dy != image->comps[ui].dy) {\n            break;\n        }\n        if (image->comps[0].prec != image->comps[ui].prec) {\n            break;\n        }\n        if (image->comps[0].sgnd != image->comps[ui].sgnd) {\n            break;\n        }\n    }\n    if (ui != ncomp) {\n        fprintf(stderr,\"imagetopnm: All components\\n    shall have \"\n         \"the same subsampling, same bit depth, same sign.\\n\"\n         \"    Aborting\\n\");\n        return 1;\n    }\n\n    if ((force_split == 0) &&\n\t\t\t\t(ncomp == 2 /* GRAYA */\n            || (ncomp > 2 /* RGB, RGBA */\n                && image->comps[0].dx == image->comps[1].dx\n                && image->comps[1].dx == image->comps[2].dx\n                && image->comps[0].dy == image->comps[1].dy\n                && image->comps[1].dy == image->comps[2].dy\n                && image->comps[0].prec == image->comps[1].prec\n                && image->comps[1].prec == image->comps[2].prec\n                )))\n\t\t{\n        fdest = fopen(outfile, \"wb\");\n\n        if (!fdest)\n        {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n            return fails;\n        }\n        two = (prec > 8);\n        triple = (ncomp > 2);\n        wr = (int)image->comps[0].w; hr = (int)image->comps[0].h;\n        max = (1<<prec) - 1; has_alpha = (ncomp == 4 || ncomp == 2);\n\n        red = image->comps[0].data;\n\n        if(triple)\n        {\n            green = image->comps[1].data;\n            blue = image->comps[2].data;\n        }\n        else green = blue = NULL;\n\n        if(has_alpha)\n        {\n            const char *tt = (triple?\"RGB_ALPHA\":\"GRAYSCALE_ALPHA\");\n\n            fprintf(fdest, \"P7\\n# OpenJPEG-%s\\nWIDTH %d\\nHEIGHT %d\\nDEPTH %u\\n\"\n                    \"MAXVAL %d\\nTUPLTYPE %s\\nENDHDR\\n\", opj_version(),\n                    wr, hr, ncomp, max, tt);\n            alpha = image->comps[ncomp - 1].data;\n            adjustA = (image->comps[ncomp - 1].sgnd ?\n                        1 << (image->comps[ncomp - 1].prec - 1) : 0);\n        }\n        else\n        {\n            fprintf(fdest, \"P6\\n# OpenJPEG-%s\\n%d %d\\n%d\\n\",\n                    opj_version(), wr, hr, max);\n            adjustA = 0;\n        }\n        adjustR = (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n\n        if(triple)\n        {\n            adjustG = (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);\n            adjustB = (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);\n        }\n        else adjustG = adjustB = 0;\n\n        for(i = 0; i < wr * hr; ++i)\n        {\n            if(two)\n            {\n                v = *red + adjustR; ++red;\n                if(v > 65535) v = 65535; else if(v < 0) v = 0;\n\n                /* netpbm: */\n                fprintf(fdest, \"%c%c\",(unsigned char)(v>>8), (unsigned char)v);\n\n                if(triple)\n                {\n                    v = *green + adjustG; ++green;\n                    if(v > 65535) v = 65535; else if(v < 0) v = 0;\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\",(unsigned char)(v>>8), (unsigned char)v);\n\n                    v =  *blue + adjustB; ++blue;\n                    if(v > 65535) v = 65535; else if(v < 0) v = 0;\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\",(unsigned char)(v>>8), (unsigned char)v);\n\n                }/* if(triple) */\n\n                if(has_alpha)\n                {\n                    v = *alpha + adjustA; ++alpha;\n                    if(v > 65535) v = 65535; else if(v < 0) v = 0;\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\",(unsigned char)(v>>8), (unsigned char)v);\n                }\n                continue;\n\n            }\t/* if(two) */\n\n            /* prec <= 8: */\n            v = *red++;\n            if(v > 255) v = 255; else if(v < 0) v = 0;\n\n            fprintf(fdest, \"%c\", (unsigned char)v);\n            if(triple)\n            {\n                v = *green++;\n                if(v > 255) v = 255; else if(v < 0) v = 0;\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n                v = *blue++;\n                if(v > 255) v = 255; else if(v < 0) v = 0;\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n\t\t\t\t\t\t}\n            if(has_alpha)\n            {\n                v = *alpha++;\n                if(v > 255) v = 255; else if(v < 0) v = 0;\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n            }\n        }\t/* for(i */\n\n        fclose(fdest); return 0;\n    }\n\n    /* YUV or MONO: */\n\n    if (image->numcomps > ncomp)\n    {\n        fprintf(stderr,\"WARNING -> [PGM file] Only the first component\\n\");\n        fprintf(stderr,\"           is written to the file\\n\");\n    }\n    destname = (char*)malloc(strlen(outfile) + 8);\n    if(destname == NULL){\n        fprintf(stderr, \"imagetopnm: memory out\\n\");\n        return 1;\n    }\n    for (compno = 0; compno < ncomp; compno++)\n    {\n        if (ncomp > 1)\n        {\n            /*sprintf(destname, \"%d.%s\", compno, outfile);*/\n            const size_t olen = strlen(outfile);\n            const size_t dotpos = olen - 4;\n\n            strncpy(destname, outfile, dotpos);\n            sprintf(destname+dotpos, \"_%u.pgm\", compno);\n        }\n        else\n            sprintf(destname, \"%s\", outfile);\n\n        fdest = fopen(destname, \"wb\");\n        if (!fdest)\n        {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", destname);\n            free(destname);\n            return 1;\n        }\n        wr = (int)image->comps[compno].w; hr = (int)image->comps[compno].h;\n        prec = (int)image->comps[compno].prec;\n        max = (1<<prec) - 1;\n\n        fprintf(fdest, \"P5\\n#OpenJPEG-%s\\n%d %d\\n%d\\n\",\n                opj_version(), wr, hr, max);\n\n        red = image->comps[compno].data;\n        adjustR =\n                (image->comps[compno].sgnd ? 1 << (image->comps[compno].prec - 1) : 0);\n\n        if(prec > 8)\n        {\n            for (i = 0; i < wr * hr; i++)\n            {\n                v = *red + adjustR; ++red;\n                if(v > 65535) v = 65535; else if(v < 0) v = 0;\n\n                /* netpbm: */\n                fprintf(fdest, \"%c%c\",(unsigned char)(v>>8), (unsigned char)v);\n\n                if(has_alpha)\n                {\n                    v = *alpha++;\n                    if(v > 65535) v = 65535; else if(v < 0) v = 0;\n\n                    /* netpbm: */\n                    fprintf(fdest, \"%c%c\",(unsigned char)(v>>8), (unsigned char)v);\n                }\n            }/* for(i */\n        }\n        else /* prec <= 8 */\n        {\n            for(i = 0; i < wr * hr; ++i)\n            {\n                v = *red + adjustR; ++red;\n                if(v > 255) v = 255; else if(v < 0) v = 0;\n\n                fprintf(fdest, \"%c\", (unsigned char)v);\n            }\n        }\n        fclose(fdest);\n    } /* for (compno */\n    free(destname);\n\n    return 0;\n}/* imagetopnm() */\n\n/* -->> -->> -->> -->>\n\n    RAW IMAGE FORMAT\n\n <<-- <<-- <<-- <<-- */\nstatic opj_image_t* rawtoimage_common(const char *filename, opj_cparameters_t *parameters, raw_cparameters_t *raw_cp, OPJ_BOOL big_endian) {\n    int subsampling_dx = parameters->subsampling_dx;\n    int subsampling_dy = parameters->subsampling_dy;\n\n    FILE *f = NULL;\n    int i, compno, numcomps, w, h;\n    OPJ_COLOR_SPACE color_space;\n    opj_image_cmptparm_t *cmptparm;\n    opj_image_t * image = NULL;\n    unsigned short ch;\n\n    if((! (raw_cp->rawWidth & raw_cp->rawHeight & raw_cp->rawComp & raw_cp->rawBitDepth)) == 0)\n    {\n        fprintf(stderr,\"\\nError: invalid raw image parameters\\n\");\n        fprintf(stderr,\"Please use the Format option -F:\\n\");\n        fprintf(stderr,\"-F <width>,<height>,<ncomp>,<bitdepth>,{s,u}@<dx1>x<dy1>:...:<dxn>x<dyn>\\n\");\n        fprintf(stderr,\"If subsampling is omitted, 1x1 is assumed for all components\\n\");\n        fprintf(stderr,\"Example: -i image.raw -o image.j2k -F 512,512,3,8,u@1x1:2x2:2x2\\n\");\n        fprintf(stderr,\"         for raw 512x512 image with 4:2:0 subsampling\\n\");\n        fprintf(stderr,\"Aborting.\\n\");\n        return NULL;\n    }\n\n    f = fopen(filename, \"rb\");\n    if (!f) {\n        fprintf(stderr, \"Failed to open %s for reading !!\\n\", filename);\n        fprintf(stderr,\"Aborting\\n\");\n        return NULL;\n    }\n    numcomps = raw_cp->rawComp;\n\n    /* FIXME ADE at this point, tcp_mct has not been properly set in calling function */\n    if (numcomps == 1) {\n        color_space = OPJ_CLRSPC_GRAY;\n    } else if ((numcomps >= 3) && (parameters->tcp_mct == 0)) {\n        color_space = OPJ_CLRSPC_SYCC;\n    } else if ((numcomps >= 3) && (parameters->tcp_mct != 2)) {\n        color_space = OPJ_CLRSPC_SRGB;\n    } else {\n        color_space = OPJ_CLRSPC_UNKNOWN;\n    }\n    w = raw_cp->rawWidth;\n    h = raw_cp->rawHeight;\n    cmptparm = (opj_image_cmptparm_t*) calloc((OPJ_UINT32)numcomps,sizeof(opj_image_cmptparm_t));\n    if (!cmptparm) {\n        fprintf(stderr, \"Failed to allocate image components parameters !!\\n\");\n        fprintf(stderr,\"Aborting\\n\");\n        fclose(f);\n        return NULL;\n    }\n    /* initialize image components */\n    for(i = 0; i < numcomps; i++) {\n        cmptparm[i].prec = (OPJ_UINT32)raw_cp->rawBitDepth;\n        cmptparm[i].bpp = (OPJ_UINT32)raw_cp->rawBitDepth;\n        cmptparm[i].sgnd = (OPJ_UINT32)raw_cp->rawSigned;\n        cmptparm[i].dx = (OPJ_UINT32)(subsampling_dx * raw_cp->rawComps[i].dx);\n        cmptparm[i].dy = (OPJ_UINT32)(subsampling_dy * raw_cp->rawComps[i].dy);\n        cmptparm[i].w = (OPJ_UINT32)w;\n        cmptparm[i].h = (OPJ_UINT32)h;\n    }\n    /* create the image */\n    image = opj_image_create((OPJ_UINT32)numcomps, &cmptparm[0], color_space);\n    free(cmptparm);\n    if(!image) {\n        fclose(f);\n        return NULL;\n    }\n    /* set image offset and reference grid */\n    image->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n    image->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n    image->x1 = (OPJ_UINT32)parameters->image_offset_x0 + (OPJ_UINT32)(w - 1) *\t(OPJ_UINT32)subsampling_dx + 1;\n    image->y1 = (OPJ_UINT32)parameters->image_offset_y0 + (OPJ_UINT32)(h - 1) * (OPJ_UINT32)subsampling_dy + 1;\n\n    if(raw_cp->rawBitDepth <= 8)\n    {\n        unsigned char value = 0;\n        for(compno = 0; compno < numcomps; compno++) {\n            int nloop = (w*h)/(raw_cp->rawComps[compno].dx*raw_cp->rawComps[compno].dy);\n            for (i = 0; i < nloop; i++) {\n                if (!fread(&value, 1, 1, f)) {\n                    fprintf(stderr,\"Error reading raw file. End of file probably reached.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                image->comps[compno].data[i] = raw_cp->rawSigned?(char)value:value;\n            }\n        }\n    }\n    else if(raw_cp->rawBitDepth <= 16)\n    {\n        unsigned short value;\n        for(compno = 0; compno < numcomps; compno++) {\n            int nloop = (w*h)/(raw_cp->rawComps[compno].dx*raw_cp->rawComps[compno].dy);\n            for (i = 0; i < nloop; i++) {\n                unsigned char temp1;\n                unsigned char temp2;\n                if (!fread(&temp1, 1, 1, f)) {\n                    fprintf(stderr,\"Error reading raw file. End of file probably reached.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if (!fread(&temp2, 1, 1, f)) {\n                    fprintf(stderr,\"Error reading raw file. End of file probably reached.\\n\");\n                    opj_image_destroy(image);\n                    fclose(f);\n                    return NULL;\n                }\n                if( big_endian )\n                {\n                    value = (unsigned short)((temp1 << 8) + temp2);\n                }\n                else\n                {\n                    value = (unsigned short)((temp2 << 8) + temp1);\n                }\n                image->comps[compno].data[i] = raw_cp->rawSigned?(short)value:value;\n            }\n        }\n    }\n    else {\n        fprintf(stderr,\"OpenJPEG cannot encode raw components with bit depth higher than 16 bits.\\n\");\n        opj_image_destroy(image);\n        fclose(f);\n        return NULL;\n    }\n\n    if (fread(&ch, 1, 1, f)) {\n        fprintf(stderr,\"Warning. End of raw file not reached... processing anyway\\n\");\n    }\n    fclose(f);\n\n    return image;\n}\n\nopj_image_t* rawltoimage(const char *filename, opj_cparameters_t *parameters, raw_cparameters_t *raw_cp) {\n    return rawtoimage_common(filename, parameters, raw_cp, OPJ_FALSE);\n}\n\nopj_image_t* rawtoimage(const char *filename, opj_cparameters_t *parameters, raw_cparameters_t *raw_cp) {\n    return rawtoimage_common(filename, parameters, raw_cp, OPJ_TRUE);\n}\n\nstatic int imagetoraw_common(opj_image_t * image, const char *outfile, OPJ_BOOL big_endian)\n{\n    FILE *rawFile = NULL;\n    size_t res;\n    unsigned int compno, numcomps;\n    int w, h, fails;\n    int line, row, curr, mask;\n    int *ptr;\n    unsigned char uc;\n    (void)big_endian;\n\n    if((image->numcomps * image->x1 * image->y1) == 0)\n    {\n        fprintf(stderr,\"\\nError: invalid raw image parameters\\n\");\n        return 1;\n    }\n\n    numcomps = image->numcomps;\n\n    if (numcomps > 4) {\n        numcomps = 4;\n    }\n    for (compno = 1; compno < numcomps; ++compno) {\n        if (image->comps[0].dx != image->comps[compno].dx) {\n            break;\n        }\n        if (image->comps[0].dy != image->comps[compno].dy) {\n            break;\n        }\n        if (image->comps[0].prec != image->comps[compno].prec) {\n            break;\n        }\n        if (image->comps[0].sgnd != image->comps[compno].sgnd) {\n            break;\n        }\n    }\n    if (compno != numcomps) {\n        fprintf(stderr,\"imagetoraw_common: All components shall have the same subsampling, same bit depth, same sign.\\n\");\n        fprintf(stderr,\"\\tAborting\\n\");\n        return 1;\n    }\n\n    rawFile = fopen(outfile, \"wb\");\n    if (!rawFile) {\n        fprintf(stderr, \"Failed to open %s for writing !!\\n\", outfile);\n        return 1;\n    }\n\n    fails = 1;\n    fprintf(stdout,\"Raw image characteristics: %d components\\n\", numcomps);\n\n    for(compno = 0; compno < numcomps; compno++)\n    {\n        fprintf(stdout,\"Component %u characteristics: %dx%dx%d %s\\n\", compno, image->comps[compno].w,\n                image->comps[compno].h, image->comps[compno].prec, image->comps[compno].sgnd==1 ? \"signed\": \"unsigned\");\n\n        w = (int)image->comps[compno].w;\n        h = (int)image->comps[compno].h;\n\n        if(image->comps[compno].prec <= 8)\n        {\n            if(image->comps[compno].sgnd == 1)\n            {\n                mask = (1 << image->comps[compno].prec) - 1;\n                ptr = image->comps[compno].data;\n                for (line = 0; line < h; line++) {\n                    for(row = 0; row < w; row++)\t{\n                        curr = *ptr;\n                        if(curr > 127) curr = 127; else if(curr < -128) curr = -128;\n                        uc = (unsigned char) (curr & mask);\n                        res = fwrite(&uc, 1, 1, rawFile);\n                        if( res < 1 ) {\n                            fprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n                            goto fin;\n                        }\n                        ptr++;\n                    }\n                }\n            }\n            else if(image->comps[compno].sgnd == 0)\n            {\n                mask = (1 << image->comps[compno].prec) - 1;\n                ptr = image->comps[compno].data;\n                for (line = 0; line < h; line++) {\n                    for(row = 0; row < w; row++)\t{\n                        curr = *ptr;\n                        if(curr > 255) curr = 255; else if(curr < 0) curr = 0;\n                        uc = (unsigned char) (curr & mask);\n                        res = fwrite(&uc, 1, 1, rawFile);\n                        if( res < 1 ) {\n                            fprintf(stderr, \"failed to write 1 byte for %s\\n\", outfile);\n                            goto fin;\n                        }\n                        ptr++;\n                    }\n                }\n            }\n        }\n        else if(image->comps[compno].prec <= 16)\n        {\n            if(image->comps[compno].sgnd == 1)\n            {\n                union { signed short val; signed char vals[2]; } uc16;\n                mask = (1 << image->comps[compno].prec) - 1;\n                ptr = image->comps[compno].data;\n                for (line = 0; line < h; line++) {\n                    for(row = 0; row < w; row++)\t{\n                        curr = *ptr;\n                        if(curr > 32767 ) curr = 32767; else if( curr < -32768) curr = -32768;\n                        uc16.val = (signed short)(curr & mask);\n                        res = fwrite(uc16.vals, 1, 2, rawFile);\n                        if( res < 2 ) {\n                            fprintf(stderr, \"failed to write 2 byte for %s\\n\", outfile);\n                            goto fin;\n                        }\n                        ptr++;\n                    }\n                }\n            }\n            else if(image->comps[compno].sgnd == 0)\n            {\n                union { unsigned short val; unsigned char vals[2]; } uc16;\n                mask = (1 << image->comps[compno].prec) - 1;\n                ptr = image->comps[compno].data;\n                for (line = 0; line < h; line++) {\n                    for(row = 0; row < w; row++)\t{\n                        curr = *ptr;\n                        if(curr > 65535 ) curr = 65535; else if( curr < 0) curr = 0;\n                        uc16.val = (unsigned short)(curr & mask);\n                        res = fwrite(uc16.vals, 1, 2, rawFile);\n                        if( res < 2 ) {\n                            fprintf(stderr, \"failed to write 2 byte for %s\\n\", outfile);\n                            goto fin;\n                        }\n                        ptr++;\n                    }\n                }\n            }\n        }\n        else if (image->comps[compno].prec <= 32)\n        {\n            fprintf(stderr,\"More than 16 bits per component not handled yet\\n\");\n            goto fin;\n        }\n        else\n        {\n            fprintf(stderr,\"Error: invalid precision: %d\\n\", image->comps[compno].prec);\n            goto fin;\n        }\n    }\n  fails = 0;\nfin:\n    fclose(rawFile);\n    return fails;\n}\n\nint imagetoraw(opj_image_t * image, const char *outfile)\n{\n    return imagetoraw_common(image, outfile, OPJ_TRUE);\n}\n\nint imagetorawl(opj_image_t * image, const char *outfile)\n{\n    return imagetoraw_common(image, outfile, OPJ_FALSE);\n}\n\n", "/*\n * The copyright in this software is being made available under the 2-clauses \n * BSD License, included below. This software may be subject to other third \n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux \n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#include \"opj_apps_config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"openjpeg.h\"\n#include \"convert.h\"\n\ntypedef struct {\n\tOPJ_UINT16 bfType;      /* 'BM' for Bitmap (19776) */\n\tOPJ_UINT32 bfSize;      /* Size of the file        */\n\tOPJ_UINT16 bfReserved1; /* Reserved : 0            */\n\tOPJ_UINT16 bfReserved2; /* Reserved : 0            */\n\tOPJ_UINT32 bfOffBits;   /* Offset                  */\n} OPJ_BITMAPFILEHEADER;\n\ntypedef struct {\n\tOPJ_UINT32 biSize;             /* Size of the structure in bytes */\n\tOPJ_UINT32 biWidth;            /* Width of the image in pixels */\n\tOPJ_UINT32 biHeight;           /* Heigth of the image in pixels */\n\tOPJ_UINT16 biPlanes;           /* 1 */\n\tOPJ_UINT16 biBitCount;         /* Number of color bits by pixels */\n\tOPJ_UINT32 biCompression;      /* Type of encoding 0: none 1: RLE8 2: RLE4 */\n\tOPJ_UINT32 biSizeImage;        /* Size of the image in bytes */\n\tOPJ_UINT32 biXpelsPerMeter;    /* Horizontal (X) resolution in pixels/meter */\n\tOPJ_UINT32 biYpelsPerMeter;    /* Vertical (Y) resolution in pixels/meter */\n\tOPJ_UINT32 biClrUsed;          /* Number of color used in the image (0: ALL) */\n\tOPJ_UINT32 biClrImportant;     /* Number of important color (0: ALL) */\n\tOPJ_UINT32 biRedMask;          /* Red channel bit mask */\n\tOPJ_UINT32 biGreenMask;        /* Green channel bit mask */\n\tOPJ_UINT32 biBlueMask;         /* Blue channel bit mask */\n\tOPJ_UINT32 biAlphaMask;        /* Alpha channel bit mask */\n\tOPJ_UINT32 biColorSpaceType;   /* Color space type */\n\tOPJ_UINT8  biColorSpaceEP[36]; /* Color space end points */\n\tOPJ_UINT32 biRedGamma;         /* Red channel gamma */\n\tOPJ_UINT32 biGreenGamma;       /* Green channel gamma */\n\tOPJ_UINT32 biBlueGamma;        /* Blue channel gamma */\n\tOPJ_UINT32 biIntent;           /* Intent */\n\tOPJ_UINT32 biIccProfileData;   /* ICC profile data */\n\tOPJ_UINT32 biIccProfileSize;   /* ICC profile size */\n\tOPJ_UINT32 biReserved;         /* Reserved */\n} OPJ_BITMAPINFOHEADER;\n\nstatic void opj_applyLUT8u_8u32s_C1R(\n\tOPJ_UINT8 const* pSrc, OPJ_INT32 srcStride,\n\tOPJ_INT32* pDst, OPJ_INT32 dstStride,\n\tOPJ_UINT8 const* pLUT,\n\tOPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 y;\n\t\n\tfor (y = height; y != 0U; --y) {\n\t\tOPJ_UINT32 x;\n\t\t\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tpDst[x] = (OPJ_INT32)pLUT[pSrc[x]];\n\t\t}\n\t\tpSrc += srcStride;\n\t\tpDst += dstStride;\n\t}\n}\n\nstatic void opj_applyLUT8u_8u32s_C1P3R(\n\tOPJ_UINT8 const* pSrc, OPJ_INT32 srcStride,\n\tOPJ_INT32* const* pDst, OPJ_INT32 const* pDstStride,\n\tOPJ_UINT8 const* const* pLUT,\n\tOPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 y;\n\tOPJ_INT32* pR = pDst[0];\n\tOPJ_INT32* pG = pDst[1];\n\tOPJ_INT32* pB = pDst[2];\n\tOPJ_UINT8 const* pLUT_R = pLUT[0];\n\tOPJ_UINT8 const* pLUT_G = pLUT[1];\n\tOPJ_UINT8 const* pLUT_B = pLUT[2];\n\t\n\tfor (y = height; y != 0U; --y) {\n\t\tOPJ_UINT32 x;\n\t\t\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tOPJ_UINT8 idx = pSrc[x];\n\t\t\tpR[x] = (OPJ_INT32)pLUT_R[idx];\n\t\t\tpG[x] = (OPJ_INT32)pLUT_G[idx];\n\t\t\tpB[x] = (OPJ_INT32)pLUT_B[idx];\n\t\t}\n\t\tpSrc += srcStride;\n\t\tpR += pDstStride[0];\n\t\tpG += pDstStride[1];\n\t\tpB += pDstStride[2];\n\t}\n}\n\nstatic void bmp24toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image)\n{\n\tint index;\n\tOPJ_UINT32 width, height;\n\tOPJ_UINT32 x, y;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\tindex = 0;\n\tpSrc = pData + (height - 1U) * stride;\n\tfor(y = 0; y < height; y++)\n\t{\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\timage->comps[0].data[index] = (OPJ_INT32)pSrc[3*x+2];\t/* R */\n\t\t\timage->comps[1].data[index] = (OPJ_INT32)pSrc[3*x+1];\t/* G */\n\t\t\timage->comps[2].data[index] = (OPJ_INT32)pSrc[3*x+0];\t/* B */\n\t\t\tindex++;\n\t\t}\n\t\tpSrc -= stride;\n\t}\n}\n\nstatic void bmp_mask_get_shift_and_prec(OPJ_UINT32 mask, OPJ_UINT32* shift, OPJ_UINT32* prec)\n{\n\tOPJ_UINT32 l_shift, l_prec;\n\t\n\tl_shift = l_prec = 0U;\n\t\n\tif (mask != 0U) {\n\t\twhile ((mask & 1U) == 0U) {\n\t\t\tmask >>= 1;\n\t\t\tl_shift++;\n\t\t}\n\t\twhile (mask & 1U) {\n\t\t\tmask >>= 1;\n\t\t\tl_prec++;\n\t\t}\n\t}\n\t*shift = l_shift; *prec = l_prec;\n}\n\nstatic void bmpmask32toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image, OPJ_UINT32 redMask, OPJ_UINT32 greenMask, OPJ_UINT32 blueMask, OPJ_UINT32 alphaMask)\n{\n\tint index;\n\tOPJ_UINT32 width, height;\n\tOPJ_UINT32 x, y;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\tOPJ_BOOL hasAlpha;\n\tOPJ_UINT32 redShift,   redPrec;\n\tOPJ_UINT32 greenShift, greenPrec;\n\tOPJ_UINT32 blueShift,  bluePrec;\n\tOPJ_UINT32 alphaShift, alphaPrec;\n\t\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\thasAlpha = image->numcomps > 3U;\n\t\n\tbmp_mask_get_shift_and_prec(redMask,   &redShift,   &redPrec);\n\tbmp_mask_get_shift_and_prec(greenMask, &greenShift, &greenPrec);\n\tbmp_mask_get_shift_and_prec(blueMask,  &blueShift,  &bluePrec);\n\tbmp_mask_get_shift_and_prec(alphaMask, &alphaShift, &alphaPrec);\n\t\n\timage->comps[0].bpp = redPrec;\n\timage->comps[0].prec = redPrec;\n\timage->comps[1].bpp = greenPrec;\n\timage->comps[1].prec = greenPrec;\n\timage->comps[2].bpp = bluePrec;\n\timage->comps[2].prec = bluePrec;\n\tif (hasAlpha) {\n\t\timage->comps[3].bpp = alphaPrec;\n\t\timage->comps[3].prec = alphaPrec;\n\t}\n\t\n\tindex = 0;\n\tpSrc = pData + (height - 1U) * stride;\n\tfor(y = 0; y < height; y++)\n\t{\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tOPJ_UINT32 value = 0U;\n\t\t\t\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+0]) <<  0;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+1]) <<  8;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+2]) << 16;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[4*x+3]) << 24;\n\t\t\t\n\t\t\timage->comps[0].data[index] = (OPJ_INT32)((value & redMask)   >> redShift);   /* R */\n\t\t\timage->comps[1].data[index] = (OPJ_INT32)((value & greenMask) >> greenShift); /* G */\n\t\t\timage->comps[2].data[index] = (OPJ_INT32)((value & blueMask)  >> blueShift);  /* B */\n\t\t\tif (hasAlpha) {\n\t\t\t\timage->comps[3].data[index] = (OPJ_INT32)((value & alphaMask)  >> alphaShift);  /* A */\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tpSrc -= stride;\n\t}\n}\n\nstatic void bmpmask16toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image, OPJ_UINT32 redMask, OPJ_UINT32 greenMask, OPJ_UINT32 blueMask, OPJ_UINT32 alphaMask)\n{\n\tint index;\n\tOPJ_UINT32 width, height;\n\tOPJ_UINT32 x, y;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\tOPJ_BOOL hasAlpha;\n\tOPJ_UINT32 redShift,   redPrec;\n\tOPJ_UINT32 greenShift, greenPrec;\n\tOPJ_UINT32 blueShift,  bluePrec;\n\tOPJ_UINT32 alphaShift, alphaPrec;\n\t\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\thasAlpha = image->numcomps > 3U;\n\t\n\tbmp_mask_get_shift_and_prec(redMask,   &redShift,   &redPrec);\n\tbmp_mask_get_shift_and_prec(greenMask, &greenShift, &greenPrec);\n\tbmp_mask_get_shift_and_prec(blueMask,  &blueShift,  &bluePrec);\n\tbmp_mask_get_shift_and_prec(alphaMask, &alphaShift, &alphaPrec);\n\t\n\timage->comps[0].bpp = redPrec;\n\timage->comps[0].prec = redPrec;\n\timage->comps[1].bpp = greenPrec;\n\timage->comps[1].prec = greenPrec;\n\timage->comps[2].bpp = bluePrec;\n\timage->comps[2].prec = bluePrec;\n\tif (hasAlpha) {\n\t\timage->comps[3].bpp = alphaPrec;\n\t\timage->comps[3].prec = alphaPrec;\n\t}\n\t\n\tindex = 0;\n\tpSrc = pData + (height - 1U) * stride;\n\tfor(y = 0; y < height; y++)\n\t{\n\t\tfor(x = 0; x < width; x++)\n\t\t{\n\t\t\tOPJ_UINT32 value = 0U;\n\t\t\t\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[2*x+0]) <<  0;\n\t\t\tvalue |= ((OPJ_UINT32)pSrc[2*x+1]) <<  8;\n\t\t\t\n\t\t\timage->comps[0].data[index] = (OPJ_INT32)((value & redMask)   >> redShift);   /* R */\n\t\t\timage->comps[1].data[index] = (OPJ_INT32)((value & greenMask) >> greenShift); /* G */\n\t\t\timage->comps[2].data[index] = (OPJ_INT32)((value & blueMask)  >> blueShift);  /* B */\n\t\t\tif (hasAlpha) {\n\t\t\t\timage->comps[3].data[index] = (OPJ_INT32)((value & alphaMask)  >> alphaShift);  /* A */\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tpSrc -= stride;\n\t}\n}\n\nstatic opj_image_t* bmp8toimage(const OPJ_UINT8* pData, OPJ_UINT32 stride, opj_image_t* image, OPJ_UINT8 const* const* pLUT)\n{\n\tOPJ_UINT32 width, height;\n\tconst OPJ_UINT8 *pSrc = NULL;\n\t\n\twidth  = image->comps[0].w;\n\theight = image->comps[0].h;\n\t\n\tpSrc = pData + (height - 1U) * stride;\n\tif (image->numcomps == 1U) {\n\t\topj_applyLUT8u_8u32s_C1R(pSrc, -(OPJ_INT32)stride, image->comps[0].data, (OPJ_INT32)width, pLUT[0], width, height);\n\t}\n\telse {\n\t\tOPJ_INT32* pDst[3];\n\t\tOPJ_INT32  pDstStride[3];\n\t\t\n\t\tpDst[0] = image->comps[0].data; pDst[1] = image->comps[1].data; pDst[2] = image->comps[2].data;\n\t\tpDstStride[0] = (OPJ_INT32)width; pDstStride[1] = (OPJ_INT32)width; pDstStride[2] = (OPJ_INT32)width;\n\t\topj_applyLUT8u_8u32s_C1P3R(pSrc, -(OPJ_INT32)stride, pDst, pDstStride, pLUT, width, height);\n\t}\n\treturn image;\n}\n\nstatic OPJ_BOOL bmp_read_file_header(FILE* IN, OPJ_BITMAPFILEHEADER* header)\n{\n\theader->bfType  = (OPJ_UINT16)getc(IN);\n\theader->bfType |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\tif (header->bfType != 19778) {\n\t\tfprintf(stderr,\"Error, not a BMP file!\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\t\n\t/* FILE HEADER */\n\t/* ------------- */\n\theader->bfSize  = (OPJ_UINT32)getc(IN);\n\theader->bfSize |= (OPJ_UINT32)getc(IN) << 8;\n\theader->bfSize |= (OPJ_UINT32)getc(IN) << 16;\n\theader->bfSize |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\theader->bfReserved1  = (OPJ_UINT16)getc(IN);\n\theader->bfReserved1 |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\theader->bfReserved2  = (OPJ_UINT16)getc(IN);\n\theader->bfReserved2 |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\theader->bfOffBits  = (OPJ_UINT32)getc(IN);\n\theader->bfOffBits |= (OPJ_UINT32)getc(IN) << 8;\n\theader->bfOffBits |= (OPJ_UINT32)getc(IN) << 16;\n\theader->bfOffBits |= (OPJ_UINT32)getc(IN) << 24;\n\treturn OPJ_TRUE;\n}\nstatic OPJ_BOOL bmp_read_info_header(FILE* IN, OPJ_BITMAPINFOHEADER* header)\n{\n\tmemset(header, 0, sizeof(*header));\n\t/* INFO HEADER */\n\t/* ------------- */\n\theader->biSize  = (OPJ_UINT32)getc(IN);\n\theader->biSize |= (OPJ_UINT32)getc(IN) << 8;\n\theader->biSize |= (OPJ_UINT32)getc(IN) << 16;\n\theader->biSize |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\tswitch (header->biSize) {\n\t\tcase 12U:  /* BITMAPCOREHEADER */\n\t\tcase 40U:  /* BITMAPINFOHEADER */\n\t\tcase 52U:  /* BITMAPV2INFOHEADER */\n\t\tcase 56U:  /* BITMAPV3INFOHEADER */\n\t\tcase 108U: /* BITMAPV4HEADER */\n\t\tcase 124U: /* BITMAPV5HEADER */\n\t\t\tbreak;\n  default:\n\t\t\tfprintf(stderr,\"Error, unknown BMP header size %d\\n\", header->biSize);\n\t\t\treturn OPJ_FALSE;\n\t}\n\t\n\theader->biWidth  = (OPJ_UINT32)getc(IN);\n\theader->biWidth |= (OPJ_UINT32)getc(IN) << 8;\n\theader->biWidth |= (OPJ_UINT32)getc(IN) << 16;\n\theader->biWidth |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\theader->biHeight  = (OPJ_UINT32)getc(IN);\n\theader->biHeight |= (OPJ_UINT32)getc(IN) << 8;\n\theader->biHeight |= (OPJ_UINT32)getc(IN) << 16;\n\theader->biHeight |= (OPJ_UINT32)getc(IN) << 24;\n\t\n\theader->biPlanes  = (OPJ_UINT16)getc(IN);\n\theader->biPlanes |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\theader->biBitCount  = (OPJ_UINT16)getc(IN);\n\theader->biBitCount |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);\n\t\n\tif(header->biSize >= 40U) {\n\t\theader->biCompression  = (OPJ_UINT32)getc(IN);\n\t\theader->biCompression |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biCompression |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biCompression |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biSizeImage  = (OPJ_UINT32)getc(IN);\n\t\theader->biSizeImage |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biSizeImage |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biSizeImage |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biXpelsPerMeter  = (OPJ_UINT32)getc(IN);\n\t\theader->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biYpelsPerMeter  = (OPJ_UINT32)getc(IN);\n\t\theader->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biClrUsed  = (OPJ_UINT32)getc(IN);\n\t\theader->biClrUsed |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biClrUsed |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biClrUsed |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biClrImportant  = (OPJ_UINT32)getc(IN);\n\t\theader->biClrImportant |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biClrImportant |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biClrImportant |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\t\n\tif(header->biSize >= 56U) {\n\t\theader->biRedMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biRedMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biRedMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biRedMask |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biGreenMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biGreenMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biGreenMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biGreenMask |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biBlueMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biBlueMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biBlueMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biBlueMask |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biAlphaMask  = (OPJ_UINT32)getc(IN);\n\t\theader->biAlphaMask |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biAlphaMask |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biAlphaMask |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\t\n\tif(header->biSize >= 108U) {\n\t\theader->biColorSpaceType  = (OPJ_UINT32)getc(IN);\n\t\theader->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\tif (fread(&(header->biColorSpaceEP), 1U, sizeof(header->biColorSpaceEP), IN) != sizeof(header->biColorSpaceEP)) {\n\t\t\tfprintf(stderr,\"Error, can't  read BMP header\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t\n\t\theader->biRedGamma  = (OPJ_UINT32)getc(IN);\n\t\theader->biRedGamma |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biRedGamma |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biRedGamma |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biGreenGamma  = (OPJ_UINT32)getc(IN);\n\t\theader->biGreenGamma |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biGreenGamma |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biGreenGamma |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biBlueGamma  = (OPJ_UINT32)getc(IN);\n\t\theader->biBlueGamma |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biBlueGamma |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biBlueGamma |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\t\n\tif(header->biSize >= 124U) {\n\t\theader->biIntent  = (OPJ_UINT32)getc(IN);\n\t\theader->biIntent |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biIntent |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biIntent |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biIccProfileData  = (OPJ_UINT32)getc(IN);\n\t\theader->biIccProfileData |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biIccProfileData |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biIccProfileData |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biIccProfileSize  = (OPJ_UINT32)getc(IN);\n\t\theader->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 24;\n\t\t\n\t\theader->biReserved  = (OPJ_UINT32)getc(IN);\n\t\theader->biReserved |= (OPJ_UINT32)getc(IN) << 8;\n\t\theader->biReserved |= (OPJ_UINT32)getc(IN) << 16;\n\t\theader->biReserved |= (OPJ_UINT32)getc(IN) << 24;\n\t}\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_raw_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_ARG_NOT_USED(width);\n\t\n\tif ( fread(pData, sizeof(OPJ_UINT8), stride * height, IN) != (stride * height) )\n\t{\n\t\tfprintf(stderr, \"\\nError: fread return a number of element different from the expected.\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 x, y;\n\tOPJ_UINT8 *pix;\n\tconst OPJ_UINT8 *beyond;\n\t\n\tbeyond = pData + stride * height;\n\tpix = pData;\n\t\n\tx = y = 0U;\n\twhile (y < height)\n\t{\n\t\tint c = getc(IN);\n\t\t\n\t\tif (c) {\n\t\t\tint j;\n\t\t\tOPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n\t\t\t\n\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n\t\t\t\t*pix = c1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tc = getc(IN);\n\t\t\tif (c == 0x00) { /* EOL */\n\t\t\t\tx = 0;\n\t\t\t\t++y;\n\t\t\t\tpix = pData + y * stride + x;\n\t\t\t}\n\t\t\telse if (c == 0x01) { /* EOP */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (c == 0x02) { /* MOVE by dxdy */\n\t\t\t\tc = getc(IN);\n\t\t\t\tx += (OPJ_UINT32)c;\n\t\t\t\tc = getc(IN);\n\t\t\t\ty += (OPJ_UINT32)c;\n\t\t\t\tpix = pData + y * stride + x;\n\t\t\t}\n\t\t\telse /* 03 .. 255 */\n\t\t\t{\n\t\t\t\tint j;\n\t\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++)\n\t\t\t\t{\n\t\t\t\t\tOPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n\t\t\t\t\t*pix = c1;\n\t\t\t\t}\n\t\t\t\tif ((OPJ_UINT32)c & 1U) { /* skip padding byte */\n\t\t\t\t\tgetc(IN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}/* while() */\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n\tOPJ_UINT32 x, y;\n\tOPJ_UINT8 *pix;\n\tconst OPJ_UINT8 *beyond;\n\t\n\tbeyond = pData + stride * height;\n\tpix = pData;\n\tx = y = 0U;\n\twhile(y < height)\n\t{\n\t\tint c = getc(IN);\n\t\tif(c == EOF) break;\n\t\t\n\t\tif(c) {/* encoded mode */\n\t\t\tint j;\n\t\t\tOPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n\t\t\n\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n\t\t\t\t*pix = (OPJ_UINT8)((j&1) ? (c1 & 0x0fU) : ((c1>>4)&0x0fU));\n\t\t\t}\n\t\t}\n\t\telse { /* absolute mode */\n\t\t\tc = getc(IN);\n\t\t\tif(c == EOF) break;\n\t\t\n\t\t\tif(c == 0x00) { /* EOL */\n\t\t\t\tx = 0;  y++;  pix = pData + y * stride;\n\t\t\t}\n\t\t\telse if(c == 0x01) { /* EOP */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(c == 0x02) { /* MOVE by dxdy */\n\t\t\t\tc = getc(IN);  x += (OPJ_UINT32)c;\n\t\t\t\tc = getc(IN);  y += (OPJ_UINT32)c;\n\t\t\t\tpix = pData + y * stride + x;\n\t\t\t}\n\t\t\telse { /* 03 .. 255 : absolute mode */\n\t\t\t\tint j;\n\t\t\t\tOPJ_UINT8 c1 = 0U;\n\t\t\t\t\n\t\t\t\tfor (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n\t\t\t\t\tif((j&1) == 0) {\n\t\t\t\t\t\t\tc1 = (OPJ_UINT8)getc(IN);\n\t\t\t\t\t}\n\t\t\t\t\t*pix =  (OPJ_UINT8)((j&1) ? (c1 & 0x0fU) : ((c1>>4)&0x0fU));\n\t\t\t\t}\n\t\t\t\tif(((c&3) == 1) || ((c&3) == 2)) { /* skip padding byte */\n\t\t\t\t\t\tgetc(IN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}  /* while(y < height) */\n\treturn OPJ_TRUE;\n}\n\nopj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters)\n{\n\topj_image_cmptparm_t cmptparm[4];\t/* maximum of 4 components */\n\tOPJ_UINT8 lut_R[256], lut_G[256], lut_B[256];\n\tOPJ_UINT8 const* pLUT[3];\n\topj_image_t * image = NULL;\n\tFILE *IN;\n\tOPJ_BITMAPFILEHEADER File_h;\n\tOPJ_BITMAPINFOHEADER Info_h;\n\tOPJ_UINT32 i, palette_len, numcmpts = 1U;\n\tOPJ_BOOL l_result = OPJ_FALSE;\n\tOPJ_UINT8* pData = NULL;\n\tOPJ_UINT32 stride;\n\t\n\tpLUT[0] = lut_R; pLUT[1] = lut_G; pLUT[2] = lut_B;\n\t\n\tIN = fopen(filename, \"rb\");\n\tif (!IN)\n\t{\n\t\tfprintf(stderr, \"Failed to open %s for reading !!\\n\", filename);\n\t\treturn NULL;\n\t}\n\n\tif (!bmp_read_file_header(IN, &File_h)) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\tif (!bmp_read_info_header(IN, &Info_h)) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\t\n\t/* Load palette */\n\tif (Info_h.biBitCount <= 8U)\n\t{\n\t\tmemset(&lut_R[0], 0, sizeof(lut_R));\n\t\tmemset(&lut_G[0], 0, sizeof(lut_G));\n\t\tmemset(&lut_B[0], 0, sizeof(lut_B));\n\t\t\n\t\tpalette_len = Info_h.biClrUsed;\n\t\tif((palette_len == 0U) && (Info_h.biBitCount <= 8U)) {\n\t\t\tpalette_len = (1U << Info_h.biBitCount);\n\t\t}\n\t\tif (palette_len > 256U) {\n\t\t\tpalette_len = 256U;\n\t\t}\n\t\tif (palette_len > 0U) {\n\t\t\tOPJ_UINT8 has_color = 0U;\n\t\t\tfor (i = 0U; i < palette_len; i++) {\n\t\t\t\tlut_B[i] = (OPJ_UINT8)getc(IN);\n\t\t\t\tlut_G[i] = (OPJ_UINT8)getc(IN);\n\t\t\t\tlut_R[i] = (OPJ_UINT8)getc(IN);\n\t\t\t\t(void)getc(IN); /* padding */\n\t\t\t\thas_color |= (lut_B[i] ^ lut_G[i]) | (lut_G[i] ^ lut_R[i]);\n\t\t\t}\n\t\t\tif(has_color) {\n\t\t\t\tnumcmpts = 3U;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tnumcmpts = 3U;\n\t\tif ((Info_h.biCompression == 3) && (Info_h.biAlphaMask != 0U)) {\n\t\t\tnumcmpts++;\n\t\t}\n\t}\n\t\n\tif (Info_h.biWidth == 0 || Info_h.biHeight == 0) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\t\n\tif (Info_h.biBitCount > (((OPJ_UINT32)-1) - 31) / Info_h.biWidth) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\tstride = ((Info_h.biWidth * Info_h.biBitCount + 31U) / 32U) * 4U; /* rows are aligned on 32bits */\n\tif (Info_h.biBitCount == 4 && Info_h.biCompression == 2) { /* RLE 4 gets decoded as 8 bits data for now... */\n\t\tif (8 > (((OPJ_UINT32)-1) - 31) / Info_h.biWidth) {\n\t\t\tfclose(IN);\n\t\t\treturn NULL;\n\t\t}\n\t\tstride = ((Info_h.biWidth * 8U + 31U) / 32U) * 4U;\n\t}\n\t\n\tif (stride > ((OPJ_UINT32)-1) / sizeof(OPJ_UINT8) / Info_h.biHeight) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\tpData = (OPJ_UINT8 *) calloc(1, stride * Info_h.biHeight * sizeof(OPJ_UINT8));\n\tif (pData == NULL) {\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\t/* Place the cursor at the beginning of the image information */\n\tfseek(IN, 0, SEEK_SET);\n\tfseek(IN, (long)File_h.bfOffBits, SEEK_SET);\n\t\n\tswitch (Info_h.biCompression) {\n\t\tcase 0:\n\t\tcase 3:\n\t\t\t/* read raw data */\n\t\t\tl_result = bmp_read_raw_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t/* read rle8 data */\n\t\t\tl_result = bmp_read_rle8_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/* read rle4 data */\n\t\t\tl_result = bmp_read_rle4_data(IN, pData, stride, Info_h.biWidth, Info_h.biHeight);\n\t\t\tbreak;\n  default:\n\t\t\tfprintf(stderr, \"Unsupported BMP compression\\n\");\n\t\t\tl_result = OPJ_FALSE;\n\t\t\tbreak;\n\t}\n\tif (!l_result) {\n\t\tfree(pData);\n\t\tfclose(IN);\n\t\treturn NULL;\n\t}\n\t\n\t/* create the image */\n\tmemset(&cmptparm[0], 0, sizeof(cmptparm));\n\tfor(i = 0; i < 4U; i++)\n\t{\n\t\tcmptparm[i].prec = 8;\n\t\tcmptparm[i].bpp  = 8;\n\t\tcmptparm[i].sgnd = 0;\n\t\tcmptparm[i].dx   = (OPJ_UINT32)parameters->subsampling_dx;\n\t\tcmptparm[i].dy   = (OPJ_UINT32)parameters->subsampling_dy;\n\t\tcmptparm[i].w    = Info_h.biWidth;\n\t\tcmptparm[i].h    = Info_h.biHeight;\n\t}\n\n\timage = opj_image_create(numcmpts, &cmptparm[0], (numcmpts == 1U) ? OPJ_CLRSPC_GRAY : OPJ_CLRSPC_SRGB);\n\tif(!image) {\n\t\tfclose(IN);\n\t\tfree(pData);\n\t\treturn NULL;\n\t}\n\tif (numcmpts == 4U) {\n\t\timage->comps[3].alpha = 1;\n\t}\n\t\n\t/* set image offset and reference grid */\n\timage->x0 = (OPJ_UINT32)parameters->image_offset_x0;\n\timage->y0 = (OPJ_UINT32)parameters->image_offset_y0;\n\timage->x1 =\timage->x0 + (Info_h.biWidth  - 1U) * (OPJ_UINT32)parameters->subsampling_dx + 1U;\n\timage->y1 = image->y0 + (Info_h.biHeight - 1U) * (OPJ_UINT32)parameters->subsampling_dy + 1U;\n\t\n\t/* Read the data */\n\tif (Info_h.biBitCount == 24 && Info_h.biCompression == 0) { /*RGB */\n\t\tbmp24toimage(pData, stride, image);\n\t}\n\telse if (Info_h.biBitCount == 8 && Info_h.biCompression == 0) { /* RGB 8bpp Indexed */\n\t\tbmp8toimage(pData, stride, image, pLUT);\n\t}\n\telse if (Info_h.biBitCount == 8 && Info_h.biCompression == 1) { /*RLE8*/\n\t\tbmp8toimage(pData, stride, image, pLUT);\n\t}\n\telse if (Info_h.biBitCount == 4 && Info_h.biCompression == 2) { /*RLE4*/\n\t\tbmp8toimage(pData, stride, image, pLUT); /* RLE 4 gets decoded as 8 bits data for now */\n\t}\n\telse if (Info_h.biBitCount == 32 && Info_h.biCompression == 0) { /* RGBX */\n\t\tbmpmask32toimage(pData, stride, image, 0x00FF0000U, 0x0000FF00U, 0x000000FFU, 0x00000000U);\n\t}\n\telse if (Info_h.biBitCount == 32 && Info_h.biCompression == 3) { /* bitmask */\n\t\tbmpmask32toimage(pData, stride, image, Info_h.biRedMask, Info_h.biGreenMask, Info_h.biBlueMask, Info_h.biAlphaMask);\n\t}\n\telse if (Info_h.biBitCount == 16 && Info_h.biCompression == 0) { /* RGBX */\n\t\tbmpmask16toimage(pData, stride, image, 0x7C00U, 0x03E0U, 0x001FU, 0x0000U);\n\t}\n\telse if (Info_h.biBitCount == 16 && Info_h.biCompression == 3) { /* bitmask */\n\t\tif ((Info_h.biRedMask == 0U) && (Info_h.biGreenMask == 0U) && (Info_h.biBlueMask == 0U)) {\n\t\t\tInfo_h.biRedMask   = 0xF800U;\n\t\t\tInfo_h.biGreenMask = 0x07E0U;\n\t\t\tInfo_h.biBlueMask  = 0x001FU;\n\t\t}\n\t\tbmpmask16toimage(pData, stride, image, Info_h.biRedMask, Info_h.biGreenMask, Info_h.biBlueMask, Info_h.biAlphaMask);\n\t}\n\telse {\n\t\topj_image_destroy(image);\n\t\timage = NULL;\n\t\tfprintf(stderr, \"Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\\n\", Info_h.biBitCount);\n\t}\n\tfree(pData);\n\tfclose(IN);\n\treturn image;\n}\n\nint imagetobmp(opj_image_t * image, const char *outfile) {\n    int w, h;\n    int i, pad;\n    FILE *fdest = NULL;\n    int adjustR, adjustG, adjustB;\n\n   {\n    unsigned int ui, ncomp = image->numcomps;\n\n    if (ncomp > 4) { /* RGBA in bmpmask32toimage */\n        ncomp = 4;\n    }\n    for (ui = 1; ui < ncomp; ++ui) {\n        if (image->comps[0].dx != image->comps[ui].dx) {\n            break;\n        }\n        if (image->comps[0].dy != image->comps[ui].dy) {\n            break;\n        }\n        if (image->comps[0].prec != image->comps[ui].prec) {\n            break;\n        }\n        if (image->comps[0].sgnd != image->comps[ui].sgnd) {\n            break;\n        }\n    }\n    if (ui != ncomp) {\n        fprintf(stderr,\"imagetobmp: All components shall have the same subsampling, same bit depth, same sign.\\n\");\n        fprintf(stderr,\"\\tAborting\\n\");\n        return 1;\n    }\n\n   }\n    if (image->comps[0].prec < 8) {\n        fprintf(stderr, \"imagetobmp: Unsupported precision: %d\\n\", image->comps[0].prec);\n        return 1;\n    }\n    if (image->numcomps >= 3 && image->comps[0].dx == image->comps[1].dx\n            && image->comps[1].dx == image->comps[2].dx\n            && image->comps[0].dy == image->comps[1].dy\n            && image->comps[1].dy == image->comps[2].dy\n            && image->comps[0].prec == image->comps[1].prec\n            && image->comps[1].prec == image->comps[2].prec) {\n\n        /* -->> -->> -->> -->>\n        24 bits color\n        <<-- <<-- <<-- <<-- */\n\n        fdest = fopen(outfile, \"wb\");\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n            return 1;\n        }\n\n        w = (int)image->comps[0].w;\n        h = (int)image->comps[0].h;\n\n        fprintf(fdest, \"BM\");\n\n        /* FILE HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\",\n                (OPJ_UINT8) (h * w * 3 + 3 * h * (w % 2) + 54) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2) + 54)\t>> 8) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2) + 54)\t>> 16) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2) + 54)\t>> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (54) & 0xff, ((54) >> 8) & 0xff,((54) >> 16) & 0xff, ((54) >> 24) & 0xff);\n\n        /* INFO HEADER   */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (40) & 0xff, ((40) >> 8) & 0xff,\t((40) >> 16) & 0xff, ((40) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((w) & 0xff),\n                (OPJ_UINT8) ((w) >> 8) & 0xff,\n                (OPJ_UINT8) ((w) >> 16) & 0xff,\n                (OPJ_UINT8) ((w) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((h) & 0xff),\n                (OPJ_UINT8) ((h) >> 8) & 0xff,\n                (OPJ_UINT8) ((h) >> 16) & 0xff,\n                (OPJ_UINT8) ((h) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c\", (1) & 0xff, ((1) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c\", (24) & 0xff, ((24) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) (3 * h * w + 3 * h * (w % 2)) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2)) >> 8) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2)) >> 16) & 0xff,\n                (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff, ((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\t((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n\n        if (image->comps[0].prec > 8) {\n            adjustR = (int)image->comps[0].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\\n\", image->comps[0].prec);\n        }\n        else\n            adjustR = 0;\n        if (image->comps[1].prec > 8) {\n            adjustG = (int)image->comps[1].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 1 from %d bits to 8 bits\\n\", image->comps[1].prec);\n        }\n        else\n            adjustG = 0;\n        if (image->comps[2].prec > 8) {\n            adjustB = (int)image->comps[2].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 2 from %d bits to 8 bits\\n\", image->comps[2].prec);\n        }\n        else\n            adjustB = 0;\n\n        for (i = 0; i < w * h; i++) {\n            OPJ_UINT8 rc, gc, bc;\n            int r, g, b;\n\n            r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n            r = ((r >> adjustR)+((r >> (adjustR-1))%2));\n            if(r > 255) r = 255; else if(r < 0) r = 0;\n            rc = (OPJ_UINT8)r;\n\n            g = image->comps[1].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            g += (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);\n            g = ((g >> adjustG)+((g >> (adjustG-1))%2));\n            if(g > 255) g = 255; else if(g < 0) g = 0;\n            gc = (OPJ_UINT8)g;\n\n            b = image->comps[2].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            b += (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);\n            b = ((b >> adjustB)+((b >> (adjustB-1))%2));\n            if(b > 255) b = 255; else if(b < 0) b = 0;\n            bc = (OPJ_UINT8)b;\n\n            fprintf(fdest, \"%c%c%c\", bc, gc, rc);\n\n            if ((i + 1) % w == 0) {\n                for (pad = ((3 * w) % 4) ? (4 - (3 * w) % 4) : 0; pad > 0; pad--)\t/* ADD */\n                    fprintf(fdest, \"%c\", 0);\n            }\n        }\n        fclose(fdest);\n    } else {\t\t\t/* Gray-scale */\n\n        /* -->> -->> -->> -->>\n        8 bits non code (Gray scale)\n        <<-- <<-- <<-- <<-- */\n\n        fdest = fopen(outfile, \"wb\");\n        if (!fdest) {\n            fprintf(stderr, \"ERROR -> failed to open %s for writing\\n\", outfile);\n            return 1;\n        }\n        w = (int)image->comps[0].w;\n        h = (int)image->comps[0].h;\n\n        fprintf(fdest, \"BM\");\n\n        /* FILE HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) (h * w + 54 + 1024 + h * (w % 2)) & 0xff,\n                (OPJ_UINT8) ((h * w + 54 + 1024 + h * (w % 2)) >> 8) & 0xff,\n                (OPJ_UINT8) ((h * w + 54 + 1024 + h * (w % 2)) >> 16) & 0xff,\n                (OPJ_UINT8) ((h * w + 54 + 1024 + w * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (54 + 1024) & 0xff, ((54 + 1024) >> 8) & 0xff,\n                ((54 + 1024) >> 16) & 0xff,\n                ((54 + 1024) >> 24) & 0xff);\n\n        /* INFO HEADER */\n        /* ------------- */\n        fprintf(fdest, \"%c%c%c%c\", (40) & 0xff, ((40) >> 8) & 0xff,\t((40) >> 16) & 0xff, ((40) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((w) & 0xff),\n                (OPJ_UINT8) ((w) >> 8) & 0xff,\n                (OPJ_UINT8) ((w) >> 16) & 0xff,\n                (OPJ_UINT8) ((w) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) ((h) & 0xff),\n                (OPJ_UINT8) ((h) >> 8) & 0xff,\n                (OPJ_UINT8) ((h) >> 16) & 0xff,\n                (OPJ_UINT8) ((h) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c\", (1) & 0xff, ((1) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c\", (8) & 0xff, ((8) >> 8) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (OPJ_UINT8) (h * w + h * (w % 2)) & 0xff,\n                (OPJ_UINT8) ((h * w + h * (w % 2)) >> 8) &\t0xff,\n                (OPJ_UINT8) ((h * w + h * (w % 2)) >> 16) &\t0xff,\n                (OPJ_UINT8) ((h * w + h * (w % 2)) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\t((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (7834) & 0xff, ((7834) >> 8) & 0xff,\t((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (256) & 0xff, ((256) >> 8) & 0xff, ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);\n        fprintf(fdest, \"%c%c%c%c\", (256) & 0xff, ((256) >> 8) & 0xff, ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);\n\n        if (image->comps[0].prec > 8) {\n            adjustR = (int)image->comps[0].prec - 8;\n            printf(\"BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\\n\", image->comps[0].prec);\n        }else\n            adjustR = 0;\n\n        for (i = 0; i < 256; i++) {\n            fprintf(fdest, \"%c%c%c%c\", i, i, i, 0);\n        }\n\n        for (i = 0; i < w * h; i++) {\n            int r;\n\n            r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];\n            r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);\n            r = ((r >> adjustR)+((r >> (adjustR-1))%2));\n            if(r > 255) r = 255; else if(r < 0) r = 0;\n\n            fprintf(fdest, \"%c\", (OPJ_UINT8)r);\n\n            if ((i + 1) % w == 0) {\n                for (pad = (w % 4) ? (4 - w % 4) : 0; pad > 0; pad--)\t/* ADD */\n                    fprintf(fdest, \"%c\", 0);\n            }\n        }\n        fclose(fdest);\n    }\n\n    return 0;\n}\n", "/*\n * The copyright in this software is being made available under the 2-clauses \n * BSD License, included below. This software may be subject to other third \n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux \n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR \n * Copyright (c) 2012, CS Systemes d'Information, France\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#include \"opj_apps_config.h\"\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n\n#ifdef _WIN32\n#include \"windirent.h\"\n#else\n#include <dirent.h>\n#endif /* _WIN32 */\n\n#ifdef _WIN32\n#include <windows.h>\n#define strcasecmp _stricmp\n#define strncasecmp _strnicmp\n#else\n#include <strings.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/times.h>\n#endif /* _WIN32 */\n\n#include \"openjpeg.h\"\n#include \"opj_getopt.h\"\n#include \"convert.h\"\n#include \"index.h\"\n\n#ifdef OPJ_HAVE_LIBLCMS2\n#include <lcms2.h>\n#endif\n#ifdef OPJ_HAVE_LIBLCMS1\n#include <lcms.h>\n#endif\n#include \"color.h\"\n\n#include \"format_defs.h\"\n#include \"opj_string.h\"\n\ntypedef struct dircnt{\n\t/** Buffer for holding images read from Directory*/\n\tchar *filename_buf;\n\t/** Pointer to the buffer*/\n\tchar **filename;\n}dircnt_t;\n\n\ntypedef struct img_folder{\n\t/** The directory path of the folder containing input images*/\n\tchar *imgdirpath;\n\t/** Output format*/\n\tconst char *out_format;\n\t/** Enable option*/\n\tchar set_imgdir;\n\t/** Enable Cod Format for output*/\n\tchar set_out_format;\n\n}img_fol_t;\n\ntypedef enum opj_prec_mode\n{\n\tOPJ_PREC_MODE_CLIP,\n\tOPJ_PREC_MODE_SCALE\n} opj_precision_mode;\n\ntypedef struct opj_prec\n{\n\tOPJ_UINT32         prec;\n\topj_precision_mode mode;\n}opj_precision;\n\ntypedef struct opj_decompress_params\n{\n\t/** core library parameters */\n\topj_dparameters_t core;\n\t\n\t/** input file name */\n\tchar infile[OPJ_PATH_LEN];\n\t/** output file name */\n\tchar outfile[OPJ_PATH_LEN];\n\t/** input file format 0: J2K, 1: JP2, 2: JPT */\n\tint decod_format;\n\t/** output file format 0: PGX, 1: PxM, 2: BMP */\n\tint cod_format;\n\t/** index file name */\n\tchar indexfilename[OPJ_PATH_LEN];\n\t\n\t/** Decoding area left boundary */\n\tOPJ_UINT32 DA_x0;\n\t/** Decoding area right boundary */\n\tOPJ_UINT32 DA_x1;\n\t/** Decoding area up boundary */\n\tOPJ_UINT32 DA_y0;\n\t/** Decoding area bottom boundary */\n\tOPJ_UINT32 DA_y1;\n\t/** Verbose mode */\n\tOPJ_BOOL m_verbose;\n\t\n\t/** tile number ot the decoded tile*/\n\tOPJ_UINT32 tile_index;\n\t/** Nb of tile to decode */\n\tOPJ_UINT32 nb_tile_to_decode;\n\t\n\topj_precision* precision;\n\tOPJ_UINT32     nb_precision;\n\t\n\t/* force output colorspace to RGB */\n\tint force_rgb;\n\t/* upsample components according to their dx/dy values */\n\tint upsample;\n\t/* split output components to different files */\n\tint split_pnm;\n    /** number of threads */\n    int num_threads;\n}opj_decompress_parameters;\n\n/* -------------------------------------------------------------------------- */\n/* Declarations                                                               */\nint get_num_images(char *imgdirpath);\nint load_images(dircnt_t *dirptr, char *imgdirpath);\nint get_file_format(const char *filename);\nchar get_next_file(int imageno,dircnt_t *dirptr,img_fol_t *img_fol, opj_decompress_parameters *parameters);\nstatic int infile_format(const char *fname);\n\nint parse_cmdline_decoder(int argc, char **argv, opj_decompress_parameters *parameters,img_fol_t *img_fol);\nint parse_DA_values( char* inArg, unsigned int *DA_x0, unsigned int *DA_y0, unsigned int *DA_x1, unsigned int *DA_y1);\n\nstatic opj_image_t* convert_gray_to_rgb(opj_image_t* original);\n\n/* -------------------------------------------------------------------------- */\nstatic void decode_help_display(void) {\n\tfprintf(stdout,\"\\nThis is the opj_decompress utility from the OpenJPEG project.\\n\"\n\t               \"It decompresses JPEG 2000 codestreams to various image formats.\\n\"\n\t               \"It has been compiled against openjp2 library v%s.\\n\\n\",opj_version());\n\n\tfprintf(stdout,\"Parameters:\\n\"\n\t               \"-----------\\n\"\n\t               \"\\n\"\n\t               \"  -ImgDir <directory> \\n\"\n\t               \"\tImage file Directory path \\n\"\n\t               \"  -OutFor <PBM|PGM|PPM|PNM|PAM|PGX|PNG|BMP|TIF|RAW|RAWL|TGA>\\n\"\n\t               \"    REQUIRED only if -ImgDir is used\\n\"\n\t               \"\tOutput format for decompressed images.\\n\");\n\tfprintf(stdout,\"  -i <compressed file>\\n\"\n\t               \"    REQUIRED only if an Input image directory is not specified\\n\"\n\t               \"    Currently accepts J2K-files, JP2-files and JPT-files. The file type\\n\"\n\t               \"    is identified based on its suffix.\\n\");\n\tfprintf(stdout,\"  -o <decompressed file>\\n\"\n\t               \"    REQUIRED\\n\"\n\t               \"    Currently accepts formats specified above (see OutFor option)\\n\"\n\t               \"    Binary data is written to the file (not ascii). If a PGX\\n\"\n\t               \"    filename is given, there will be as many output files as there are\\n\"\n\t               \"    components: an indice starting from 0 will then be appended to the\\n\"\n\t               \"    output filename, just before the \\\"pgx\\\" extension. If a PGM filename\\n\"\n\t               \"    is given and there are more than one component, only the first component\\n\"\n\t               \"    will be written to the file.\\n\");\n\tfprintf(stdout,\"  -r <reduce factor>\\n\"\n\t               \"    Set the number of highest resolution levels to be discarded. The\\n\"\n\t               \"    image resolution is effectively divided by 2 to the power of the\\n\"\n\t               \"    number of discarded levels. The reduce factor is limited by the\\n\"\n\t               \"    smallest total number of decomposition levels among tiles.\\n\"\n\t               \"  -l <number of quality layers to decode>\\n\"\n\t               \"    Set the maximum number of quality layers to decode. If there are\\n\"\n\t               \"    less quality layers than the specified number, all the quality layers\\n\"\n\t               \"    are decoded.\\n\");\n\tfprintf(stdout,\"  -x  \\n\"\n\t               \"    Create an index file *.Idx (-x index_name.Idx) \\n\"\n\t               \"  -d <x0,y0,x1,y1>\\n\"\n\t               \"    OPTIONAL\\n\"\n\t               \"    Decoding area\\n\"\n\t               \"    By default all the image is decoded.\\n\"\n\t               \"  -t <tile_number>\\n\"\n\t               \"    OPTIONAL\\n\"\n\t               \"    Set the tile number of the decoded tile. Follow the JPEG2000 convention from left-up to bottom-up\\n\"\n\t               \"    By default all tiles are decoded.\\n\");\n\tfprintf(stdout,\"  -p <comp 0 precision>[C|S][,<comp 1 precision>[C|S][,...]]\\n\"\n\t               \"    OPTIONAL\\n\"\n\t               \"    Force the precision (bit depth) of components.\\n\");\n\tfprintf(stdout,\"    There shall be at least 1 value. Theres no limit on the number of values (comma separated, last values ignored if too much values).\\n\"\n\t               \"    If there are less values than components, the last value is used for remaining components.\\n\"\n\t               \"    If 'C' is specified (default), values are clipped.\\n\"\n\t               \"    If 'S' is specified, values are scaled.\\n\"\n\t               \"    A 0 value can be specified (meaning original bit depth).\\n\");\n\tfprintf(stdout,\"  -force-rgb\\n\"\n\t               \"    Force output image colorspace to RGB\\n\"\n\t               \"  -upsample\\n\"\n\t               \"    Downsampled components will be upsampled to image size\\n\"\n\t               \"  -split-pnm\\n\"\n\t               \"    Split output components to different files when writing to PNM\\n\");\n\tif( opj_has_thread_support() ) {\n\t  fprintf(stdout,\"  -threads <num_threads>\\n\"\n\t\t\t\t\t\"    Number of threads to use for decoding.\\n\");\n\t}\n/* UniPG>> */\n#ifdef USE_JPWL\n\tfprintf(stdout,\"  -W <options>\\n\"\n\t               \"    Activates the JPWL correction capability, if the codestream complies.\\n\"\n\t               \"    Options can be a comma separated list of <param=val> tokens:\\n\"\n\t               \"    c, c=numcomps\\n\"\n\t               \"       numcomps is the number of expected components in the codestream\\n\"\n\t               \"       (search of first EPB rely upon this, default is %d)\\n\", JPWL_EXPECTED_COMPONENTS);\n#endif /* USE_JPWL */\n/* <<UniPG */\n\tfprintf(stdout,\"\\n\");\n}\n\n/* -------------------------------------------------------------------------- */\n\nstatic OPJ_BOOL parse_precision(const char* option, opj_decompress_parameters* parameters)\n{\n\tconst char* l_remaining = option;\n\tOPJ_BOOL l_result = OPJ_TRUE;\n\t\n\t/* reset */\n\tif (parameters->precision) {\n\t\tfree(parameters->precision);\n\t\tparameters->precision = NULL;\n\t}\n\tparameters->nb_precision = 0U;\n\t\n\tfor(;;)\n\t{\n\t\tint prec;\n\t\tchar mode;\n\t\tchar comma;\n\t\tint count;\n\t\t\n\t\tcount = sscanf(l_remaining, \"%d%c%c\", &prec, &mode, &comma);\n\t\tif (count == 1) {\n\t\t\tmode = 'C';\n\t\t\tcount++;\n\t\t}\n\t\tif ((count == 2) || (mode==',')) {\n\t\t\tif (mode==',') {\n\t\t\t\tmode = 'C';\n\t\t\t}\n\t\t\tcomma=',';\n\t\t\tcount = 3;\n\t\t}\n\t\tif (count == 3) {\n\t\t\tif ((prec < 1) || (prec > 32)) {\n\t\t\t\tfprintf(stderr,\"Invalid precision %d in precision option %s\\n\", prec, option);\n\t\t\t\tl_result = OPJ_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((mode != 'C') && (mode != 'S')) {\n\t\t\t\tfprintf(stderr,\"Invalid precision mode %c in precision option %s\\n\", mode, option);\n\t\t\t\tl_result = OPJ_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (comma != ',') {\n\t\t\t\tfprintf(stderr,\"Invalid character %c in precision option %s\\n\", comma, option);\n\t\t\t\tl_result = OPJ_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (parameters->precision == NULL) {\n\t\t\t\t/* first one */\n\t\t\t\tparameters->precision = (opj_precision *)malloc(sizeof(opj_precision));\n\t\t\t\tif (parameters->precision == NULL) {\n\t\t\t\t\tfprintf(stderr,\"Could not allocate memory for precision option\\n\");\n\t\t\t\t\tl_result = OPJ_FALSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tOPJ_UINT32 l_new_size = parameters->nb_precision + 1U;\n\t\t\t\topj_precision* l_new;\n\t\t\t\t\n\t\t\t\tif (l_new_size == 0U) {\n\t\t\t\t\tfprintf(stderr,\"Could not allocate memory for precision option\\n\");\n\t\t\t\t\tl_result = OPJ_FALSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tl_new = (opj_precision *)realloc(parameters->precision, l_new_size * sizeof(opj_precision));\n\t\t\t\tif (l_new == NULL) {\n\t\t\t\t\tfprintf(stderr,\"Could not allocate memory for precision option\\n\");\n\t\t\t\t\tl_result = OPJ_FALSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tparameters->precision = l_new;\n\t\t\t}\n\t\t\t\n\t\t\tparameters->precision[parameters->nb_precision].prec = (OPJ_UINT32)prec;\n\t\t\tswitch (mode) {\n\t\t\t\tcase 'C':\n\t\t\t\t\tparameters->precision[parameters->nb_precision].mode = OPJ_PREC_MODE_CLIP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tparameters->precision[parameters->nb_precision].mode = OPJ_PREC_MODE_SCALE;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tparameters->nb_precision++;\n\t\t\t\n\t\t\tl_remaining = strchr(l_remaining, ',');\n\t\t\tif (l_remaining == NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tl_remaining += 1;\n\t\t} else {\n\t\t\tfprintf(stderr,\"Could not parse precision option %s\\n\", option);\n\t\t\tl_result = OPJ_FALSE;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn l_result;\n}\n\n/* -------------------------------------------------------------------------- */\n\nint get_num_images(char *imgdirpath){\n\tDIR *dir;\n\tstruct dirent* content;\t\n\tint num_images = 0;\n\n\t/*Reading the input images from given input directory*/\n\n\tdir= opendir(imgdirpath);\n\tif(!dir){\n\t\tfprintf(stderr,\"Could not open Folder %s\\n\",imgdirpath);\n\t\treturn 0;\n\t}\n\t\n\twhile((content=readdir(dir))!=NULL){\n\t\tif(strcmp(\".\",content->d_name)==0 || strcmp(\"..\",content->d_name)==0 )\n\t\t\tcontinue;\n\t\tnum_images++;\n\t}\n\tclosedir(dir);\n\treturn num_images;\n}\n\n/* -------------------------------------------------------------------------- */\nint load_images(dircnt_t *dirptr, char *imgdirpath){\n\tDIR *dir;\n\tstruct dirent* content;\t\n\tint i = 0;\n\n\t/*Reading the input images from given input directory*/\n\n\tdir= opendir(imgdirpath);\n\tif(!dir){\n\t\tfprintf(stderr,\"Could not open Folder %s\\n\",imgdirpath);\n\t\treturn 1;\n\t}else\t{\n\t\tfprintf(stderr,\"Folder opened successfully\\n\");\n\t}\n\t\n\twhile((content=readdir(dir))!=NULL){\n\t\tif(strcmp(\".\",content->d_name)==0 || strcmp(\"..\",content->d_name)==0 )\n\t\t\tcontinue;\n\n\t\tstrcpy(dirptr->filename[i],content->d_name);\n\t\ti++;\n\t}\n\tclosedir(dir);\n\treturn 0;\t\n}\n\n/* -------------------------------------------------------------------------- */\nint get_file_format(const char *filename) {\n\tunsigned int i;\n\tstatic const char *extension[] = {\"pgx\", \"pnm\", \"pgm\", \"ppm\", \"bmp\",\"tif\", \"raw\", \"rawl\", \"tga\", \"png\", \"j2k\", \"jp2\", \"jpt\", \"j2c\", \"jpc\" };\n\tstatic const int format[] = { PGX_DFMT, PXM_DFMT, PXM_DFMT, PXM_DFMT, BMP_DFMT, TIF_DFMT, RAW_DFMT, RAWL_DFMT, TGA_DFMT, PNG_DFMT, J2K_CFMT, JP2_CFMT, JPT_CFMT, J2K_CFMT, J2K_CFMT };\n\tconst char * ext = strrchr(filename, '.');\n\tif (ext == NULL)\n\t\treturn -1;\n\text++;\n\tif(*ext) {\n\t\tfor(i = 0; i < sizeof(format)/sizeof(*format); i++) {\n\t\t\tif(strcasecmp(ext, extension[i]) == 0) {\n\t\t\t\treturn format[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n#ifdef _WIN32\nconst char* path_separator = \"\\\\\";\n#else\nconst char* path_separator = \"/\";\n#endif\n\n/* -------------------------------------------------------------------------- */\nchar get_next_file(int imageno,dircnt_t *dirptr,img_fol_t *img_fol, opj_decompress_parameters *parameters){\n\tchar image_filename[OPJ_PATH_LEN], infilename[OPJ_PATH_LEN],outfilename[OPJ_PATH_LEN],temp_ofname[OPJ_PATH_LEN];\n\tchar *temp_p, temp1[OPJ_PATH_LEN]=\"\";\n\n\tstrcpy(image_filename,dirptr->filename[imageno]);\n\tfprintf(stderr,\"File Number %d \\\"%s\\\"\\n\",imageno,image_filename);\n\tsprintf(infilename, \"%s%s%s\", img_fol->imgdirpath, path_separator, image_filename);\n\tparameters->decod_format = infile_format(infilename);\n\tif (parameters->decod_format == -1)\n\t\treturn 1;\n\tif (opj_strcpy_s(parameters->infile, sizeof(parameters->infile), infilename) != 0) {\n\t\treturn 1;\n\t}\n\n\t/*Set output file*/\n\tstrcpy(temp_ofname,strtok(image_filename,\".\"));\n\twhile((temp_p = strtok(NULL,\".\")) != NULL){\n\t\tstrcat(temp_ofname,temp1);\n\t\tsprintf(temp1,\".%s\",temp_p);\n\t}\n\tif(img_fol->set_out_format==1){\n\t\tsprintf(outfilename,\"%s/%s.%s\",img_fol->imgdirpath,temp_ofname,img_fol->out_format);\n\t\tif (opj_strcpy_s(parameters->outfile, sizeof(parameters->outfile), outfilename) != 0) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* -------------------------------------------------------------------------- */\n#define JP2_RFC3745_MAGIC \"\\x00\\x00\\x00\\x0c\\x6a\\x50\\x20\\x20\\x0d\\x0a\\x87\\x0a\"\n#define JP2_MAGIC \"\\x0d\\x0a\\x87\\x0a\"\n/* position 45: \"\\xff\\x52\" */\n#define J2K_CODESTREAM_MAGIC \"\\xff\\x4f\\xff\\x51\"\n\nstatic int infile_format(const char *fname)\n{\n\tFILE *reader;\n\tconst char *s, *magic_s;\n\tint ext_format, magic_format;\n\tunsigned char buf[12];\n\tOPJ_SIZE_T l_nb_read;\n\n\treader = fopen(fname, \"rb\");\n\n\tif (reader == NULL)\n\t\treturn -2;\n\n\tmemset(buf, 0, 12);\n\tl_nb_read = fread(buf, 1, 12, reader);\n\tfclose(reader);\n\tif (l_nb_read != 12)\n\t\treturn -1;\n\n\n\n\text_format = get_file_format(fname);\n\n\tif (ext_format == JPT_CFMT)\n\t\treturn JPT_CFMT;\n\n\tif (memcmp(buf, JP2_RFC3745_MAGIC, 12) == 0 || memcmp(buf, JP2_MAGIC, 4) == 0) {\n\t\tmagic_format = JP2_CFMT;\n\t\tmagic_s = \".jp2\";\n\t}\n\telse if (memcmp(buf, J2K_CODESTREAM_MAGIC, 4) == 0) {\n\t\tmagic_format = J2K_CFMT;\n\t\tmagic_s = \".j2k or .jpc or .j2c\";\n\t}\n\telse\n\t\treturn -1;\n\n\tif (magic_format == ext_format)\n\t\treturn ext_format;\n\n\ts = fname + strlen(fname) - 4;\n\n\tfputs(\"\\n===========================================\\n\", stderr);\n\tfprintf(stderr, \"The extension of this file is incorrect.\\n\"\n\t\t\t\t\t\"FOUND %s. SHOULD BE %s\\n\", s, magic_s);\n\tfputs(\"===========================================\\n\", stderr);\n\n\treturn magic_format;\n}\n\n/* -------------------------------------------------------------------------- */\n/**\n * Parse the command line\n */\n/* -------------------------------------------------------------------------- */\nint parse_cmdline_decoder(int argc, char **argv, opj_decompress_parameters *parameters,img_fol_t *img_fol) {\n\t/* parse the command line */\n\tint totlen, c;\n\topj_option_t long_option[]={\n\t\t{\"ImgDir\",    REQ_ARG, NULL,'y'},\n\t\t{\"OutFor\",    REQ_ARG, NULL,'O'},\n\t\t{\"force-rgb\", NO_ARG,  NULL, 1},\n\t\t{\"upsample\",  NO_ARG,  NULL, 1},\n\t\t{\"split-pnm\", NO_ARG,  NULL, 1},\n\t\t{\"threads\",   REQ_ARG, NULL, 'T'}\n\t};\n\n\tconst char optlist[] = \"i:o:r:l:x:d:t:p:\"\n\n/* UniPG>> */\n#ifdef USE_JPWL\n\t\t\t\t\t\"W:\"\n#endif /* USE_JPWL */\n/* <<UniPG */\n            \"h\"\t\t;\n\n\tlong_option[2].flag = &(parameters->force_rgb);\n\tlong_option[3].flag = &(parameters->upsample);\n\tlong_option[4].flag = &(parameters->split_pnm);\n\ttotlen=sizeof(long_option);\n\topj_reset_options_reading();\n\timg_fol->set_out_format = 0;\n\tdo {\n\t\tc = opj_getopt_long(argc, argv,optlist,long_option,totlen);\n\t\tif (c == -1)\n\t\t\tbreak;\n\t\tswitch (c) {\n\t\t\tcase 0: /* long opt with flag */\n\t\t\t\tbreak;\n\t\t\tcase 'i':\t\t\t/* input file */\n\t\t\t{\n\t\t\t\tchar *infile = opj_optarg;\n\t\t\t\tparameters->decod_format = infile_format(infile);\n\t\t\t\tswitch(parameters->decod_format) {\n\t\t\t\t\tcase J2K_CFMT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase JP2_CFMT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase JPT_CFMT:\n\t\t\t\t\t\tbreak;\n                                        case -2:\n\t\t\t\t\t\tfprintf(stderr, \n\t\t\t\t\t\t\t\"!! infile cannot be read: %s !!\\n\\n\", \n\t\t\t\t\t\t\tinfile);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfprintf(stderr, \n                            \"[ERROR] Unknown input file format: %s \\n\"\n                            \"        Known file formats are *.j2k, *.jp2, *.jpc or *.jpt\\n\",\n\t\t\t\t\t\t\tinfile);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tif (opj_strcpy_s(parameters->infile, sizeof(parameters->infile), infile) != 0) {\n\t\t\t\t\tfprintf(stderr, \"[ERROR] Path is too long\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\t\n\t\t\t\t/* ----------------------------------------------------- */\n\n\t\t\tcase 'o':\t\t\t/* output file */\n\t\t\t{\n\t\t\t\tchar *outfile = opj_optarg;\n\t\t\t\tparameters->cod_format = get_file_format(outfile);\n\t\t\t\tswitch(parameters->cod_format) {\n\t\t\t\t\tcase PGX_DFMT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PXM_DFMT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase BMP_DFMT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TIF_DFMT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase RAW_DFMT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase RAWL_DFMT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TGA_DFMT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PNG_DFMT:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfprintf(stderr, \"Unknown output format image %s [only *.png, *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!!\\n\", outfile);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tif (opj_strcpy_s(parameters->outfile, sizeof(parameters->outfile), outfile) != 0) {\n\t\t\t\t\tfprintf(stderr, \"[ERROR] Path is too long\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\t\t\t/* ----------------------------------------------------- */\n\n\t\t\tcase 'O':\t\t\t/* output format */\n\t\t\t{\n\t\t\t\tchar outformat[50];\n\t\t\t\tchar *of = opj_optarg;\n\t\t\t\tsprintf(outformat,\".%s\",of);\n\t\t\t\timg_fol->set_out_format = 1;\n\t\t\t\tparameters->cod_format = get_file_format(outformat);\n\t\t\t\tswitch(parameters->cod_format) {\n\t\t\t\t\tcase PGX_DFMT:\n\t\t\t\t\t\timg_fol->out_format = \"pgx\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PXM_DFMT:\n\t\t\t\t\t\timg_fol->out_format = \"ppm\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase BMP_DFMT:\n\t\t\t\t\t\timg_fol->out_format = \"bmp\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TIF_DFMT:\n\t\t\t\t\t\timg_fol->out_format = \"tif\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase RAW_DFMT:\n\t\t\t\t\t\timg_fol->out_format = \"raw\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase RAWL_DFMT:\n\t\t\t\t\t\timg_fol->out_format = \"rawl\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TGA_DFMT:\n\t\t\t\t\t\timg_fol->out_format = \"raw\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PNG_DFMT:\n\t\t\t\t\t\timg_fol->out_format = \"png\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfprintf(stderr, \"Unknown output format image %s [only *.png, *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!!\\n\", outformat);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t\t/* ----------------------------------------------------- */\n\n\n\t\t\tcase 'r':\t\t/* reduce option */\n\t\t\t{\n\t\t\t\tsscanf(opj_optarg, \"%u\", &(parameters->core.cp_reduce));\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\t\t\t/* ----------------------------------------------------- */\n      \n\n\t\t\tcase 'l':\t\t/* layering option */\n\t\t\t{\n\t\t\t\tsscanf(opj_optarg, \"%u\", &(parameters->core.cp_layer));\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\t\t\t/* ----------------------------------------------------- */\n\n\t\t\tcase 'h': \t\t\t/* display an help description */\n\t\t\t\tdecode_help_display();\n\t\t\t\treturn 1;\t\t\t\t\n\n            /* ----------------------------------------------------- */\n\n\t\t\tcase 'y':\t\t\t/* Image Directory path */\n                {\n\t\t\t\t\timg_fol->imgdirpath = (char*)malloc(strlen(opj_optarg) + 1);\n\t\t\t\t\tif(img_fol->imgdirpath == NULL){\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\tstrcpy(img_fol->imgdirpath,opj_optarg);\n\t\t\t\t\timg_fol->set_imgdir=1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\t/* ----------------------------------------------------- */\n\n\t\t\tcase 'd':     \t\t/* Input decode ROI */\n\t\t\t{\n\t\t\t\tsize_t size_optarg = (size_t)strlen(opj_optarg) + 1U;\n\t\t\t\tchar *ROI_values = (char*) malloc(size_optarg);\n\t\t\t\tif (ROI_values == NULL) {\n\t\t\t\t\tfprintf(stderr, \"[ERROR] Couldn't allocate memory\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tROI_values[0] = '\\0';\n\t\t\t\tmemcpy(ROI_values, opj_optarg, size_optarg);\n\t\t\t\t/*printf(\"ROI_values = %s [%d / %d]\\n\", ROI_values, strlen(ROI_values), size_optarg ); */\n\t\t\t\tparse_DA_values( ROI_values, &parameters->DA_x0, &parameters->DA_y0, &parameters->DA_x1, &parameters->DA_y1);\n\n\t\t\t\tfree(ROI_values);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* ----------------------------------------------------- */\n\n\t\t\tcase 't':     \t\t/* Input tile index */\n\t\t\t{\n\t\t\t\tsscanf(opj_optarg, \"%u\", &parameters->tile_index);\n\t\t\t\tparameters->nb_tile_to_decode = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t\t/* ----------------------------------------------------- */\t\t\t\t\t\t\t\t\n\n\t\t\tcase 'x':\t\t\t/* Creation of index file */\n\t\t\t\t{\n\t\t\t\t\tif (opj_strcpy_s(parameters->indexfilename, sizeof(parameters->indexfilename), opj_optarg) != 0) {\n\t\t\t\t\t\tfprintf(stderr, \"[ERROR] Path is too long\\n\");\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\t/* ----------------------------------------------------- */\n\t\t\tcase 'p': /* Force precision */\n\t\t\t\t{\n\t\t\t\t\tif (!parse_precision(opj_optarg, parameters))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\t/* ----------------------------------------------------- */\n\t\t\t\t\n\t\t\t\t/* UniPG>> */\n#ifdef USE_JPWL\n\t\t\t\n\t\t\tcase 'W': \t\t\t/* activate JPWL correction */\n\t\t\t{\n\t\t\t\tchar *token = NULL;\n\n\t\t\t\ttoken = strtok(opj_optarg, \",\");\n\t\t\t\twhile(token != NULL) {\n\n\t\t\t\t\t/* search expected number of components */\n\t\t\t\t\tif (*token == 'c') {\n\n\t\t\t\t\t\tstatic int compno;\n\n\t\t\t\t\t\tcompno = JPWL_EXPECTED_COMPONENTS; /* predefined no. of components */\n\n\t\t\t\t\t\tif(sscanf(token, \"c=%d\", &compno) == 1) {\n\t\t\t\t\t\t\t/* Specified */\n\t\t\t\t\t\t\tif ((compno < 1) || (compno > 256)) {\n\t\t\t\t\t\t\t\tfprintf(stderr, \"ERROR -> invalid number of components c = %d\\n\", compno);\n\t\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tparameters->jpwl_exp_comps = compno;\n\n\t\t\t\t\t\t} else if (!strcmp(token, \"c\")) {\n\t\t\t\t\t\t\t/* default */\n\t\t\t\t\t\t\tparameters->jpwl_exp_comps = compno; /* auto for default size */\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfprintf(stderr, \"ERROR -> invalid components specified = %s\\n\", token);\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t/* search maximum number of tiles */\n\t\t\t\t\tif (*token == 't') {\n\n\t\t\t\t\t\tstatic int tileno;\n\n\t\t\t\t\t\ttileno = JPWL_MAXIMUM_TILES; /* maximum no. of tiles */\n\n\t\t\t\t\t\tif(sscanf(token, \"t=%d\", &tileno) == 1) {\n\t\t\t\t\t\t\t/* Specified */\n\t\t\t\t\t\t\tif ((tileno < 1) || (tileno > JPWL_MAXIMUM_TILES)) {\n\t\t\t\t\t\t\t\tfprintf(stderr, \"ERROR -> invalid number of tiles t = %d\\n\", tileno);\n\t\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tparameters->jpwl_max_tiles = tileno;\n\n\t\t\t\t\t\t} else if (!strcmp(token, \"t\")) {\n\t\t\t\t\t\t\t/* default */\n\t\t\t\t\t\t\tparameters->jpwl_max_tiles = tileno; /* auto for default size */\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfprintf(stderr, \"ERROR -> invalid tiles specified = %s\\n\", token);\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t/* next token or bust */\n\t\t\t\t\ttoken = strtok(NULL, \",\");\n\t\t\t\t};\n\t\t\t\tparameters->jpwl_correct = OPJ_TRUE;\n\t\t\t\tfprintf(stdout, \"JPWL correction capability activated\\n\");\n\t\t\t\tfprintf(stdout, \"- expecting %d components\\n\", parameters->jpwl_exp_comps);\n\t\t\t}\n\t\t\tbreak;\t\n#endif /* USE_JPWL */\n/* <<UniPG */            \n\t\t\t\t\n\t\t\t\t/* ----------------------------------------------------- */\n\t\t\tcase 'T':  /* Number of threads */\n\t\t\t\t{\n\t\t\t\t\tif( strcmp(opj_optarg, \"ALL_CPUS\") == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tparameters->num_threads = opj_get_num_cpus();\n\t\t\t\t\t\tif( parameters->num_threads == 1 )\n\t\t\t\t\t\t\tparameters->num_threads = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t  sscanf(opj_optarg, \"%d\", &parameters->num_threads);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\t/* ----------------------------------------------------- */\n\t\t\t\n        default:\n            fprintf(stderr, \"[WARNING] An invalid option has been ignored.\\n\");\n            break;\n\t\t}\n\t}while(c != -1);\n\n\t/* check for possible errors */\n\tif(img_fol->set_imgdir==1){\n\t\tif(!(parameters->infile[0]==0)){\n            fprintf(stderr, \"[ERROR] options -ImgDir and -i cannot be used together.\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif(img_fol->set_out_format == 0){\n            fprintf(stderr, \"[ERROR] When -ImgDir is used, -OutFor <FORMAT> must be used.\\n\");\n            fprintf(stderr, \"Only one format allowed.\\n\"\n                            \"Valid format are PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA.\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif(!((parameters->outfile[0] == 0))){\n            fprintf(stderr, \"[ERROR] options -ImgDir and -o cannot be used together.\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}else{\n\t\tif((parameters->infile[0] == 0) || (parameters->outfile[0] == 0)) {\n            fprintf(stderr, \"[ERROR] Required parameters are missing\\n\"\n                            \"Example: %s -i image.j2k -o image.pgm\\n\",argv[0]);\n            fprintf(stderr, \"   Help: %s -h\\n\",argv[0]);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/* -------------------------------------------------------------------------- */\n/**\n * Parse decoding area input values\n * separator = \",\"\n */\n/* -------------------------------------------------------------------------- */\nint parse_DA_values( char* inArg, unsigned int *DA_x0, unsigned int *DA_y0, unsigned int *DA_x1, unsigned int *DA_y1)\n{\n\tint it = 0;\n\tint values[4];\n\tchar delims[] = \",\";\n\tchar *result = NULL;\n\tresult = strtok( inArg, delims );\n\n\twhile( (result != NULL) && (it < 4 ) ) {\n\t\tvalues[it] = atoi(result);\n\t\tresult = strtok( NULL, delims );\n\t\tit++;\n\t}\n\n\tif (it != 4) {\n\t\treturn EXIT_FAILURE;\n\t}\n\telse{\n\t\t*DA_x0 = (OPJ_UINT32)values[0]; *DA_y0 = (OPJ_UINT32)values[1];\n\t\t*DA_x1 = (OPJ_UINT32)values[2]; *DA_y1 = (OPJ_UINT32)values[3];\n\t\treturn EXIT_SUCCESS;\n\t}\n}\n\nOPJ_FLOAT64 opj_clock(void) {\n#ifdef _WIN32\n\t/* _WIN32: use QueryPerformance (very accurate) */\n    LARGE_INTEGER freq , t ;\n    /* freq is the clock speed of the CPU */\n    QueryPerformanceFrequency(&freq) ;\n\t/* cout << \"freq = \" << ((double) freq.QuadPart) << endl; */\n    /* t is the high resolution performance counter (see MSDN) */\n    QueryPerformanceCounter ( & t ) ;\n\treturn freq.QuadPart ? (t.QuadPart / (OPJ_FLOAT64)freq.QuadPart) : 0;\n#elif defined(__linux)\n\tstruct timespec ts;\n\tclock_gettime(CLOCK_REALTIME, &ts);\n\treturn( (OPJ_FLOAT64)ts.tv_sec + (OPJ_FLOAT64)ts.tv_nsec * 1e-9 );\n#else\n\t/* Unix : use resource usage */\n\t/* FIXME: this counts the total CPU time, instead of the user perceived time */\n\tstruct rusage t;\n\tOPJ_FLOAT64 procTime;\n\t/* (1) Get the rusage data structure at this moment (man getrusage) */\n\tgetrusage(0,&t);\n\t/* (2) What is the elapsed time ? - CPU time = User time + System time */\n\t/* (2a) Get the seconds */\n\tprocTime = (OPJ_FLOAT64)(t.ru_utime.tv_sec + t.ru_stime.tv_sec);\n\t/* (2b) More precisely! Get the microseconds part ! */\n\treturn ( procTime + (OPJ_FLOAT64)(t.ru_utime.tv_usec + t.ru_stime.tv_usec) * 1e-6 ) ;\n#endif\n}\n\n/* -------------------------------------------------------------------------- */\n\n/**\nsample error callback expecting a FILE* client object\n*/\nstatic void error_callback(const char *msg, void *client_data) {\n\t(void)client_data;\n\tfprintf(stdout, \"[ERROR] %s\", msg);\n}\n/**\nsample warning callback expecting a FILE* client object\n*/\nstatic void warning_callback(const char *msg, void *client_data) {\n\t(void)client_data;\n\tfprintf(stdout, \"[WARNING] %s\", msg);\n}\n/**\nsample debug callback expecting no client object\n*/\nstatic void info_callback(const char *msg, void *client_data) {\n\t(void)client_data;\n\tfprintf(stdout, \"[INFO] %s\", msg);\n}\n\nstatic void set_default_parameters(opj_decompress_parameters* parameters)\n{\n\tif (parameters) {\n\t\tmemset(parameters, 0, sizeof(opj_decompress_parameters));\n\t\t\n\t\t/* default decoding parameters (command line specific) */\n\t\tparameters->decod_format = -1;\n\t\tparameters->cod_format = -1;\n\t\t\n\t\t/* default decoding parameters (core) */\n\t\topj_set_default_decoder_parameters(&(parameters->core));\n\t}\n}\n\nstatic void destroy_parameters(opj_decompress_parameters* parameters)\n{\n\tif (parameters) {\n\t\tif (parameters->precision) {\n\t\t\tfree(parameters->precision);\n\t\t\tparameters->precision = NULL;\n\t\t}\n\t}\n}\n\n/* -------------------------------------------------------------------------- */\n\nstatic opj_image_t* convert_gray_to_rgb(opj_image_t* original)\n{\n\tOPJ_UINT32 compno;\n\topj_image_t* l_new_image = NULL;\n\topj_image_cmptparm_t* l_new_components = NULL;\n\t\n\tl_new_components = (opj_image_cmptparm_t*)malloc((original->numcomps + 2U) * sizeof(opj_image_cmptparm_t));\n\tif (l_new_components == NULL) {\n\t\tfprintf(stderr, \"ERROR -> opj_decompress: failed to allocate memory for RGB image!\\n\");\n\t\topj_image_destroy(original);\n\t\treturn NULL;\n\t}\n\t\n\tl_new_components[0].bpp  = l_new_components[1].bpp  = l_new_components[2].bpp  = original->comps[0].bpp;\n\tl_new_components[0].dx   = l_new_components[1].dx   = l_new_components[2].dx   = original->comps[0].dx;\n\tl_new_components[0].dy   = l_new_components[1].dy   = l_new_components[2].dy   = original->comps[0].dy;\n\tl_new_components[0].h    = l_new_components[1].h    = l_new_components[2].h    = original->comps[0].h;\n\tl_new_components[0].w    = l_new_components[1].w    = l_new_components[2].w    = original->comps[0].w;\n\tl_new_components[0].prec = l_new_components[1].prec = l_new_components[2].prec = original->comps[0].prec;\n\tl_new_components[0].sgnd = l_new_components[1].sgnd = l_new_components[2].sgnd = original->comps[0].sgnd;\n\tl_new_components[0].x0   = l_new_components[1].x0   = l_new_components[2].x0   = original->comps[0].x0;\n\tl_new_components[0].y0   = l_new_components[1].y0   = l_new_components[2].y0   = original->comps[0].y0;\n\t\n\tfor(compno = 1U; compno < original->numcomps; ++compno) {\n\t\tl_new_components[compno+2U].bpp  = original->comps[compno].bpp;\n\t\tl_new_components[compno+2U].dx   = original->comps[compno].dx;\n\t\tl_new_components[compno+2U].dy   = original->comps[compno].dy;\n\t\tl_new_components[compno+2U].h    = original->comps[compno].h;\n\t\tl_new_components[compno+2U].w    = original->comps[compno].w;\n\t\tl_new_components[compno+2U].prec = original->comps[compno].prec;\n\t\tl_new_components[compno+2U].sgnd = original->comps[compno].sgnd;\n\t\tl_new_components[compno+2U].x0   = original->comps[compno].x0;\n\t\tl_new_components[compno+2U].y0   = original->comps[compno].y0;\n\t}\n\t\n\tl_new_image = opj_image_create(original->numcomps + 2U, l_new_components, OPJ_CLRSPC_SRGB);\n\tfree(l_new_components);\n\tif (l_new_image == NULL) {\n\t\tfprintf(stderr, \"ERROR -> opj_decompress: failed to allocate memory for RGB image!\\n\");\n\t\topj_image_destroy(original);\n\t\treturn NULL;\n\t}\n\t\n\tl_new_image->x0 = original->x0;\n\tl_new_image->x1 = original->x1;\n\tl_new_image->y0 = original->y0;\n\tl_new_image->y1 = original->y1;\n\t\n\tl_new_image->comps[0].factor        = l_new_image->comps[1].factor        = l_new_image->comps[2].factor        = original->comps[0].factor;\n\tl_new_image->comps[0].alpha         = l_new_image->comps[1].alpha         = l_new_image->comps[2].alpha         = original->comps[0].alpha;\n\tl_new_image->comps[0].resno_decoded = l_new_image->comps[1].resno_decoded = l_new_image->comps[2].resno_decoded = original->comps[0].resno_decoded;\n\t\n\tmemcpy(l_new_image->comps[0].data, original->comps[0].data, original->comps[0].w * original->comps[0].h * sizeof(OPJ_INT32));\n\tmemcpy(l_new_image->comps[1].data, original->comps[0].data, original->comps[0].w * original->comps[0].h * sizeof(OPJ_INT32));\n\tmemcpy(l_new_image->comps[2].data, original->comps[0].data, original->comps[0].w * original->comps[0].h * sizeof(OPJ_INT32));\n\t\n\tfor(compno = 1U; compno < original->numcomps; ++compno) {\n\t\tl_new_image->comps[compno+2U].factor        = original->comps[compno].factor;\n\t\tl_new_image->comps[compno+2U].alpha         = original->comps[compno].alpha;\n\t\tl_new_image->comps[compno+2U].resno_decoded = original->comps[compno].resno_decoded;\n\t\tmemcpy(l_new_image->comps[compno+2U].data, original->comps[compno].data, original->comps[compno].w * original->comps[compno].h * sizeof(OPJ_INT32));\n\t}\n\topj_image_destroy(original);\n\treturn l_new_image;\n}\n\n/* -------------------------------------------------------------------------- */\n\nstatic opj_image_t* upsample_image_components(opj_image_t* original)\n{\n\topj_image_t* l_new_image = NULL;\n\topj_image_cmptparm_t* l_new_components = NULL;\n\tOPJ_BOOL l_upsample_need = OPJ_FALSE;\n\tOPJ_UINT32 compno;\n\n\tfor (compno = 0U; compno < original->numcomps; ++compno) {\n\t\tif (original->comps[compno].factor > 0U) {\n\t\t\tfprintf(stderr, \"ERROR -> opj_decompress: -upsample not supported with reduction\\n\");\n\t\t\topj_image_destroy(original);\n\t\t\treturn NULL;\n\t\t}\n\t\tif ((original->comps[compno].dx > 1U) || (original->comps[compno].dy > 1U)) {\n\t\t\tl_upsample_need = OPJ_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!l_upsample_need) {\n\t\treturn original;\n\t}\n\t/* Upsample is needed */\n\tl_new_components = (opj_image_cmptparm_t*)malloc(original->numcomps * sizeof(opj_image_cmptparm_t));\n\tif (l_new_components == NULL) {\n\t\tfprintf(stderr, \"ERROR -> opj_decompress: failed to allocate memory for upsampled components!\\n\");\n\t\topj_image_destroy(original);\n\t\treturn NULL;\n\t}\n\t\n\tfor (compno = 0U; compno < original->numcomps; ++compno) {\n\t\topj_image_cmptparm_t* l_new_cmp = &(l_new_components[compno]);\n\t\topj_image_comp_t*     l_org_cmp = &(original->comps[compno]);\n\t\t\n\t\tl_new_cmp->bpp  = l_org_cmp->bpp;\n\t\tl_new_cmp->prec = l_org_cmp->prec;\n\t\tl_new_cmp->sgnd = l_org_cmp->sgnd;\n\t\tl_new_cmp->x0   = original->x0;\n\t\tl_new_cmp->y0   = original->y0;\n\t\tl_new_cmp->dx   = 1;\n\t\tl_new_cmp->dy   = 1;\n\t\tl_new_cmp->w    = l_org_cmp->w; /* should be original->x1 - original->x0 for dx==1 */\n\t\tl_new_cmp->h    = l_org_cmp->h; /* should be original->y1 - original->y0 for dy==0 */\n\t\t\n\t\tif (l_org_cmp->dx > 1U) {\n\t\t\tl_new_cmp->w = original->x1 - original->x0;\n\t\t}\n\t\t\n\t\tif (l_org_cmp->dy > 1U) {\n\t\t\tl_new_cmp->h = original->y1 - original->y0;\n\t\t}\n\t}\n\t\n\tl_new_image = opj_image_create(original->numcomps, l_new_components, original->color_space);\n\tfree(l_new_components);\n\tif (l_new_image == NULL) {\n\t\tfprintf(stderr, \"ERROR -> opj_decompress: failed to allocate memory for upsampled components!\\n\");\n\t\topj_image_destroy(original);\n\t\treturn NULL;\n\t}\n\t\n\tl_new_image->x0 = original->x0;\n\tl_new_image->x1 = original->x1;\n\tl_new_image->y0 = original->y0;\n\tl_new_image->y1 = original->y1;\n\t\n\tfor (compno = 0U; compno < original->numcomps; ++compno) {\n\t\topj_image_comp_t* l_new_cmp = &(l_new_image->comps[compno]);\n\t\topj_image_comp_t* l_org_cmp = &(original->comps[compno]);\n\t\t\n\t\tl_new_cmp->factor        = l_org_cmp->factor;\n\t\tl_new_cmp->alpha         = l_org_cmp->alpha;\n\t\tl_new_cmp->resno_decoded = l_org_cmp->resno_decoded;\n\t\t\n\t\tif ((l_org_cmp->dx > 1U) || (l_org_cmp->dy > 1U)) {\n\t\t\tconst OPJ_INT32* l_src = l_org_cmp->data;\n\t\t\tOPJ_INT32*       l_dst = l_new_cmp->data;\n\t\t\tOPJ_UINT32 y;\n\t\t\tOPJ_UINT32 xoff, yoff;\n\t\t\t\n\t\t\t/* need to take into account dx & dy */\n\t\t\txoff = l_org_cmp->dx * l_org_cmp->x0 -  original->x0;\n\t\t\tyoff = l_org_cmp->dy * l_org_cmp->y0 -  original->y0;\n\t\t\tif ((xoff >= l_org_cmp->dx) || (yoff >= l_org_cmp->dy)) {\n\t\t\t\tfprintf(stderr, \"ERROR -> opj_decompress: Invalid image/component parameters found when upsampling\\n\");\n\t\t\t\topj_image_destroy(original);\n\t\t\t\topj_image_destroy(l_new_image);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t\n\t\t\tfor (y = 0U; y < yoff; ++y) {\n\t\t\t\tmemset(l_dst, 0U, l_new_cmp->w * sizeof(OPJ_INT32));\n\t\t\t\tl_dst += l_new_cmp->w;\n\t\t\t}\n\t\t\t\n\t\t\tif(l_new_cmp->h > (l_org_cmp->dy - 1U)) { /* check subtraction overflow for really small images */\n\t\t\t\tfor (; y < l_new_cmp->h - (l_org_cmp->dy - 1U); y += l_org_cmp->dy) {\n\t\t\t\t\tOPJ_UINT32 x, dy;\n\t\t\t\t\tOPJ_UINT32 xorg;\n\t\t\t\t\t\n\t\t\t\t\txorg = 0U;\n\t\t\t\t\tfor (x = 0U; x < xoff; ++x) {\n\t\t\t\t\t\tl_dst[x] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (l_new_cmp->w > (l_org_cmp->dx - 1U)) { /* check subtraction overflow for really small images */\n\t\t\t\t\t\tfor (; x < l_new_cmp->w - (l_org_cmp->dx - 1U); x += l_org_cmp->dx, ++xorg) {\n\t\t\t\t\t\t\tOPJ_UINT32 dx;\n\t\t\t\t\t\t\tfor (dx = 0U; dx < l_org_cmp->dx; ++dx) {\n\t\t\t\t\t\t\t\tl_dst[x + dx] = l_src[xorg];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (; x < l_new_cmp->w; ++x) {\n\t\t\t\t\t\tl_dst[x] = l_src[xorg];\n\t\t\t\t\t}\n\t\t\t\t\tl_dst += l_new_cmp->w;\n\t\t\t\t\t\t\n\t\t\t\t\tfor (dy = 1U; dy < l_org_cmp->dy; ++dy) {\n\t\t\t\t\t\tmemcpy(l_dst, l_dst - l_new_cmp->w, l_new_cmp->w * sizeof(OPJ_INT32));\n\t\t\t\t\t\tl_dst += l_new_cmp->w;\n\t\t\t\t\t}\n\t\t\t\t\tl_src += l_org_cmp->w;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (y < l_new_cmp->h) {\n\t\t\t\tOPJ_UINT32 x;\n\t\t\t\tOPJ_UINT32 xorg;\n\t\t\t\t\n\t\t\t\txorg = 0U;\n\t\t\t\tfor (x = 0U; x < xoff; ++x) {\n\t\t\t\t\tl_dst[x] = 0;\n\t\t\t\t}\n\t\t\t\tif (l_new_cmp->w > (l_org_cmp->dx - 1U)) { /* check subtraction overflow for really small images */\n\t\t\t\t\tfor (; x < l_new_cmp->w - (l_org_cmp->dx - 1U); x += l_org_cmp->dx, ++xorg) {\n\t\t\t\t\t\tOPJ_UINT32 dx;\n\t\t\t\t\t\tfor (dx = 0U; dx < l_org_cmp->dx; ++dx) {\n\t\t\t\t\t\t\tl_dst[x + dx] = l_src[xorg];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (; x < l_new_cmp->w; ++x) {\n\t\t\t\t\tl_dst[x] = l_src[xorg];\n\t\t\t\t}\n\t\t\t\tl_dst += l_new_cmp->w;\n\t\t\t\t++y;\n\t\t\t\tfor (; y < l_new_cmp->h; ++y) {\n\t\t\t\t\tmemcpy(l_dst, l_dst - l_new_cmp->w, l_new_cmp->w * sizeof(OPJ_INT32));\n\t\t\t\t\tl_dst += l_new_cmp->w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmemcpy(l_new_cmp->data, l_org_cmp->data, l_org_cmp->w * l_org_cmp->h * sizeof(OPJ_INT32));\n\t\t}\n\t}\n\topj_image_destroy(original);\n\treturn l_new_image;\n}\n\n/* -------------------------------------------------------------------------- */\n/**\n * OPJ_DECOMPRESS MAIN\n */\n/* -------------------------------------------------------------------------- */\nint main(int argc, char **argv)\n{\n\topj_decompress_parameters parameters;\t\t\t/* decompression parameters */\n\topj_image_t* image = NULL;\n\topj_stream_t *l_stream = NULL;\t\t\t\t/* Stream */\n\topj_codec_t* l_codec = NULL;\t\t\t\t/* Handle to a decompressor */\n\topj_codestream_index_t* cstr_index = NULL;\n\n\tOPJ_INT32 num_images, imageno;\n\timg_fol_t img_fol;\n\tdircnt_t *dirptr = NULL;\n  int failed = 0;\n  OPJ_FLOAT64 t, tCumulative = 0;\n  OPJ_UINT32 numDecompressedImages = 0;\n\n\t/* set decoding parameters to default values */\n\tset_default_parameters(&parameters);\n\n\t/* Initialize img_fol */\n\tmemset(&img_fol,0,sizeof(img_fol_t));\n\n\t/* parse input and get user encoding parameters */\n\tif(parse_cmdline_decoder(argc, argv, &parameters,&img_fol) == 1) {\n\t\tfailed = 1; goto fin;\n\t}\n\n\t/* Initialize reading of directory */\n\tif(img_fol.set_imgdir==1){\t\n\t\tint it_image;\n\t\tnum_images=get_num_images(img_fol.imgdirpath);\n\n\t\tdirptr=(dircnt_t*)malloc(sizeof(dircnt_t));\n\t\tif(!dirptr){\n\t\t\tdestroy_parameters(&parameters);\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t\tdirptr->filename_buf = (char*)malloc((size_t)num_images*OPJ_PATH_LEN*sizeof(char));\t/* Stores at max 10 image file names*/\n\t\tif(!dirptr->filename_buf){\n\t\t\tfailed = 1; goto fin;\n\t\t}\n\t\t\t\t\n\t\tdirptr->filename = (char**) malloc((size_t)num_images*sizeof(char*));\n\n\t\tif(!dirptr->filename){\n\t\t\tfailed = 1; goto fin;\n\t\t}\n\t\tfor(it_image=0;it_image<num_images;it_image++){\n\t\t\tdirptr->filename[it_image] = dirptr->filename_buf + it_image*OPJ_PATH_LEN;\n\t\t}\n\t\t\n\t\tif(load_images(dirptr,img_fol.imgdirpath)==1){\n\t\t\tfailed = 1; goto fin;\n\t\t}\n\t\tif (num_images==0){\n\t\t\tfprintf(stdout,\"Folder is empty\\n\");\n\t\t\tfailed = 1; goto fin;\n\t\t}\n\t}else{\n\t\tnum_images=1;\n\t}\n\n\t/*Decoding image one by one*/\n\tfor(imageno = 0; imageno < num_images ; imageno++)\t{\n\n\t\tfprintf(stderr,\"\\n\");\n\n\t\tif(img_fol.set_imgdir==1){\n\t\t\tif (get_next_file(imageno, dirptr,&img_fol, &parameters)) {\n\t\t\t\tfprintf(stderr,\"skipping file...\\n\");\n\t\t\t\tdestroy_parameters(&parameters);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/* read the input file and put it in memory */\n\t\t/* ---------------------------------------- */\n\n\t\tl_stream = opj_stream_create_default_file_stream(parameters.infile,1);\n\t\tif (!l_stream){\n\t\t\tfprintf(stderr, \"ERROR -> failed to create the stream from the file %s\\n\", parameters.infile);\n\t\t\tfailed = 1; goto fin;\n\t\t}\n\n\t\t/* decode the JPEG2000 stream */\n\t\t/* ---------------------- */\n\n\t\tswitch(parameters.decod_format) {\n\t\t\tcase J2K_CFMT:\t/* JPEG-2000 codestream */\n\t\t\t{\n\t\t\t\t/* Get a decoder handle */\n\t\t\t\tl_codec = opj_create_decompress(OPJ_CODEC_J2K);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase JP2_CFMT:\t/* JPEG 2000 compressed image data */\n\t\t\t{\n\t\t\t\t/* Get a decoder handle */\n\t\t\t\tl_codec = opj_create_decompress(OPJ_CODEC_JP2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase JPT_CFMT:\t/* JPEG 2000, JPIP */\n\t\t\t{\n\t\t\t\t/* Get a decoder handle */\n\t\t\t\tl_codec = opj_create_decompress(OPJ_CODEC_JPT);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"skipping file..\\n\");\n\t\t\t\tdestroy_parameters(&parameters);\n\t\t\t\topj_stream_destroy(l_stream);\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* catch events using our callbacks and give a local context */\t\t\n\t\topj_set_info_handler(l_codec, info_callback,00);\n\t\topj_set_warning_handler(l_codec, warning_callback,00);\n\t\topj_set_error_handler(l_codec, error_callback,00);\n\n\t\tt = opj_clock();\n\n\t\t/* Setup the decoder decoding parameters using user parameters */\n\t\tif ( !opj_setup_decoder(l_codec, &(parameters.core)) ){\n\t\t\tfprintf(stderr, \"ERROR -> opj_decompress: failed to setup the decoder\\n\");\n\t\t\topj_stream_destroy(l_stream);\n\t\t\topj_destroy_codec(l_codec);\n\t\t\tfailed = 1; goto fin;\n\t\t}\n\t\t\n\t\tif( parameters.num_threads >= 1 && !opj_codec_set_threads(l_codec, parameters.num_threads) ) {\n\t\t\tfprintf(stderr, \"ERROR -> opj_decompress: failed to set number of threads\\n\");\n\t\t\topj_stream_destroy(l_stream);\n\t\t\topj_destroy_codec(l_codec);\n\t\t\tfailed = 1; goto fin;\n\t\t}\n\n\t\t/* Read the main header of the codestream and if necessary the JP2 boxes*/\n\t\tif(! opj_read_header(l_stream, l_codec, &image)){\n\t\t\tfprintf(stderr, \"ERROR -> opj_decompress: failed to read the header\\n\");\n\t\t\topj_stream_destroy(l_stream);\n\t\t\topj_destroy_codec(l_codec);\n\t\t\topj_image_destroy(image);\n\t\t\tfailed = 1; goto fin;\n\t\t}\n\n\t\tif (!parameters.nb_tile_to_decode) {\n\t\t\t/* Optional if you want decode the entire image */\n\t\t\tif (!opj_set_decode_area(l_codec, image, (OPJ_INT32)parameters.DA_x0,\n\t\t\t\t\t(OPJ_INT32)parameters.DA_y0, (OPJ_INT32)parameters.DA_x1, (OPJ_INT32)parameters.DA_y1)){\n\t\t\t\tfprintf(stderr,\t\"ERROR -> opj_decompress: failed to set the decoded area\\n\");\n\t\t\t\topj_stream_destroy(l_stream);\n\t\t\t\topj_destroy_codec(l_codec);\n\t\t\t\topj_image_destroy(image);\n\t\t\t\tfailed = 1; goto fin;\n\t\t\t}\n\n\t\t\t/* Get the decoded image */\n\t\t\tif (!(opj_decode(l_codec, l_stream, image) && opj_end_decompress(l_codec,\tl_stream))) {\n\t\t\t\tfprintf(stderr,\"ERROR -> opj_decompress: failed to decode image!\\n\");\n\t\t\t\topj_destroy_codec(l_codec);\n\t\t\t\topj_stream_destroy(l_stream);\n\t\t\t\topj_image_destroy(image);\n\t\t\t\tfailed = 1; goto fin;\n\t\t\t}\n\t\t}\n\t\telse {\n\n\t\t\t/* It is just here to illustrate how to use the resolution after set parameters */\n\t\t\t/*if (!opj_set_decoded_resolution_factor(l_codec, 5)) {\n\t\t\t\tfprintf(stderr, \"ERROR -> opj_decompress: failed to set the resolution factor tile!\\n\");\n\t\t\t\topj_destroy_codec(l_codec);\n\t\t\t\topj_stream_destroy(l_stream);\n\t\t\t\topj_image_destroy(image);\n\t\t\t\tfailed = 1; goto fin;\n\t\t\t}*/\n\n\t\t\tif (!opj_get_decoded_tile(l_codec, l_stream, image, parameters.tile_index)) {\n\t\t\t\tfprintf(stderr, \"ERROR -> opj_decompress: failed to decode tile!\\n\");\n\t\t\t\topj_destroy_codec(l_codec);\n\t\t\t\topj_stream_destroy(l_stream);\n\t\t\t\topj_image_destroy(image);\n\t\t\t\tfailed = 1; goto fin;\n\t\t\t}\n\t\t\tfprintf(stdout, \"tile %d is decoded!\\n\\n\", parameters.tile_index);\n\t\t}\n\n\t\ttCumulative += opj_clock() - t;\n\t\tnumDecompressedImages++;\n\n\t\t/* Close the byte stream */\n\t\topj_stream_destroy(l_stream);\n\n\t\tif( image->color_space != OPJ_CLRSPC_SYCC \n\t\t\t&& image->numcomps == 3 && image->comps[0].dx == image->comps[0].dy\n\t\t\t&& image->comps[1].dx != 1 )\n\t\t\timage->color_space = OPJ_CLRSPC_SYCC;\n\t\telse if (image->numcomps <= 2)\n\t\t\timage->color_space = OPJ_CLRSPC_GRAY;\n\n\t\tif(image->color_space == OPJ_CLRSPC_SYCC){\n\t\t\tcolor_sycc_to_rgb(image);\n\t\t}\n\t\telse if((image->color_space == OPJ_CLRSPC_CMYK) && (parameters.cod_format != TIF_DFMT)){\n\t\t\tcolor_cmyk_to_rgb(image);\n\t\t}\n\t\telse if(image->color_space == OPJ_CLRSPC_EYCC){\n\t\t\tcolor_esycc_to_rgb(image);\n\t\t}\n\t\t\n\t\tif(image->icc_profile_buf) {\n#if defined(OPJ_HAVE_LIBLCMS1) || defined(OPJ_HAVE_LIBLCMS2)\n\t\t\tif(image->icc_profile_len)\n\t\t\t color_apply_icc_profile(image);\n\t\t\telse\n\t\t\t color_cielab_to_rgb(image);\n#endif\n\t\t\tfree(image->icc_profile_buf);\n\t\t\timage->icc_profile_buf = NULL; image->icc_profile_len = 0;\n\t\t}\n\t\t\n\t\t/* Force output precision */\n\t\t/* ---------------------- */\n\t\tif (parameters.precision != NULL)\n\t\t{\n\t\t\tOPJ_UINT32 compno;\n\t\t\tfor (compno = 0; compno < image->numcomps; ++compno)\n\t\t\t{\n\t\t\t\tOPJ_UINT32 precno = compno;\n\t\t\t\tOPJ_UINT32 prec;\n\t\t\t\t\n\t\t\t\tif (precno >= parameters.nb_precision) {\n\t\t\t\t\tprecno = parameters.nb_precision - 1U;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tprec = parameters.precision[precno].prec;\n\t\t\t\tif (prec == 0) {\n\t\t\t\t\tprec = image->comps[compno].prec;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tswitch (parameters.precision[precno].mode) {\n\t\t\t\t\tcase OPJ_PREC_MODE_CLIP:\n\t\t\t\t\t\tclip_component(&(image->comps[compno]), prec);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase OPJ_PREC_MODE_SCALE:\n\t\t\t\t\t\tscale_component(&(image->comps[compno]), prec);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* Upsample components */\n\t\t/* ------------------- */\n\t\tif (parameters.upsample)\n\t\t{\n\t\t\timage = upsample_image_components(image);\n\t\t\tif (image == NULL) {\n\t\t\t\tfprintf(stderr, \"ERROR -> opj_decompress: failed to upsample image components!\\n\");\n\t\t\t\topj_destroy_codec(l_codec);\n\t\t\t\tfailed = 1; goto fin;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/* Force RGB output */\n\t\t/* ---------------- */\n\t\tif (parameters.force_rgb)\n\t\t{\n\t\t\tswitch (image->color_space) {\n\t\t\t\tcase OPJ_CLRSPC_SRGB:\n\t\t\t\t\tbreak;\n\t\t\t\tcase OPJ_CLRSPC_GRAY:\n\t\t\t\t\timage = convert_gray_to_rgb(image);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfprintf(stderr, \"ERROR -> opj_decompress: don't know how to convert image to RGB colorspace!\\n\");\n\t\t\t\t\topj_image_destroy(image);\n\t\t\t\t\timage = NULL;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (image == NULL) {\n\t\t\t\tfprintf(stderr, \"ERROR -> opj_decompress: failed to convert to RGB image!\\n\");\n\t\t\t\topj_destroy_codec(l_codec);\n\t\t\t\tfailed = 1; goto fin;\n\t\t\t}\n\t\t}\n\n\t\t/* create output image */\n\t\t/* ------------------- */\n\t\tswitch (parameters.cod_format) {\n\t\tcase PXM_DFMT:\t\t\t/* PNM PGM PPM */\n\t\t\tif (imagetopnm(image, parameters.outfile, parameters.split_pnm)) {\n                fprintf(stderr,\"[ERROR] Outfile %s not generated\\n\",parameters.outfile);\n        failed = 1;\n\t\t\t}\n\t\t\telse {\n                fprintf(stdout,\"[INFO] Generated Outfile %s\\n\",parameters.outfile);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PGX_DFMT:\t\t\t/* PGX */\n\t\t\tif(imagetopgx(image, parameters.outfile)){\n                fprintf(stderr,\"[ERROR] Outfile %s not generated\\n\",parameters.outfile);\n        failed = 1;\n\t\t\t}\n\t\t\telse {\n                fprintf(stdout,\"[INFO] Generated Outfile %s\\n\",parameters.outfile);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase BMP_DFMT:\t\t\t/* BMP */\n\t\t\tif(imagetobmp(image, parameters.outfile)){\n                fprintf(stderr,\"[ERROR] Outfile %s not generated\\n\",parameters.outfile);\n        failed = 1;\n\t\t\t}\n\t\t\telse {\n                fprintf(stdout,\"[INFO] Generated Outfile %s\\n\",parameters.outfile);\n\t\t\t}\n\t\t\tbreak;\n#ifdef OPJ_HAVE_LIBTIFF\n\t\tcase TIF_DFMT:\t\t\t/* TIFF */\n\t\t\tif(imagetotif(image, parameters.outfile)){\n                fprintf(stderr,\"[ERROR] Outfile %s not generated\\n\",parameters.outfile);\n        failed = 1;\n\t\t\t}\n\t\t\telse {\n                fprintf(stdout,\"[INFO] Generated Outfile %s\\n\",parameters.outfile);\n\t\t\t}\n\t\t\tbreak;\n#endif /* OPJ_HAVE_LIBTIFF */\n\t\tcase RAW_DFMT:\t\t\t/* RAW */\n\t\t\tif(imagetoraw(image, parameters.outfile)){\n                fprintf(stderr,\"[ERROR] Error generating raw file. Outfile %s not generated\\n\",parameters.outfile);\n        failed = 1;\n\t\t\t}\n\t\t\telse {\n                fprintf(stdout,\"[INFO] Generated Outfile %s\\n\",parameters.outfile);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase RAWL_DFMT:\t\t\t/* RAWL */\n\t\t\tif(imagetorawl(image, parameters.outfile)){\n                fprintf(stderr,\"[ERROR] Error generating rawl file. Outfile %s not generated\\n\",parameters.outfile);\n        failed = 1;\n\t\t\t}\n\t\t\telse {\n                fprintf(stdout,\"[INFO] Generated Outfile %s\\n\",parameters.outfile);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TGA_DFMT:\t\t\t/* TGA */\n\t\t\tif(imagetotga(image, parameters.outfile)){\n                fprintf(stderr,\"[ERROR] Error generating tga file. Outfile %s not generated\\n\",parameters.outfile);\n        failed = 1;\n\t\t\t}\n\t\t\telse {\n                fprintf(stdout,\"[INFO] Generated Outfile %s\\n\",parameters.outfile);\n\t\t\t}\n\t\t\tbreak;\n#ifdef OPJ_HAVE_LIBPNG\n\t\tcase PNG_DFMT:\t\t\t/* PNG */\n\t\t\tif(imagetopng(image, parameters.outfile)){\n                fprintf(stderr,\"[ERROR] Error generating png file. Outfile %s not generated\\n\",parameters.outfile);\n        failed = 1;\n\t\t\t}\n\t\t\telse {\n                fprintf(stdout,\"[INFO] Generated Outfile %s\\n\",parameters.outfile);\n\t\t\t}\n\t\t\tbreak;\n#endif /* OPJ_HAVE_LIBPNG */\n/* Can happen if output file is TIFF or PNG\n * and OPJ_HAVE_LIBTIF or OPJ_HAVE_LIBPNG is undefined\n*/\n\t\t\tdefault:\n                fprintf(stderr,\"[ERROR] Outfile %s not generated\\n\",parameters.outfile);\n        failed = 1;\n\t\t}\n\n\t\t/* free remaining structures */\n\t\tif (l_codec) {\n\t\t\topj_destroy_codec(l_codec);\n\t\t}\n\n\n\t\t/* free image data structure */\n\t\topj_image_destroy(image);\n\n\t\t/* destroy the codestream index */\n\t\topj_destroy_cstr_index(&cstr_index);\n\n\t\tif(failed) (void)remove(parameters.outfile); /* ignore return value */\n\t}\nfin:\n\tdestroy_parameters(&parameters);\n\tif(failed && img_fol.imgdirpath) free(img_fol.imgdirpath);\n\tif(dirptr){\n\t\tif(dirptr->filename) free(dirptr->filename);\n\t\tif(dirptr->filename_buf) free(dirptr->filename_buf);\n\t\tfree(dirptr);\n\t}\n\tif (numDecompressedImages && !failed) {\n\t\tfprintf(stdout, \"decode time: %d ms\\n\", (int)( (tCumulative * 1000.0) / (OPJ_FLOAT64)numDecompressedImages));\n\t}\n\treturn failed ? EXIT_FAILURE : EXIT_SUCCESS;\n}\n/*end main()*/\n", "/*\n * The copyright in this software is being made available under the 2-clauses \n * BSD License, included below. This software may be subject to other third \n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux \n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>\n * Copyright (c) 2006-2007, Parvatha Elangovan\n * Copyright (c) 2010-2011, Kaori Hagihara\n * Copyright (c) 2011-2012, Centre National d'Etudes Spatiales (CNES), France \n * Copyright (c) 2012, CS Systemes d'Information, France\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"opj_includes.h\"\n\n/** @defgroup J2K J2K - JPEG-2000 codestream reader/writer */\n/*@{*/\n\n/** @name Local static functions */\n/*@{*/\n\n/**\n * Sets up the procedures to do on reading header. Developpers wanting to extend the library can add their own reading procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_header_reading (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager);\n\n/**\n * The read header procedure.\n */\nstatic OPJ_BOOL opj_j2k_read_header_procedure(  opj_j2k_t *p_j2k,\n                                                opj_stream_private_t *p_stream,\n                                                opj_event_mgr_t * p_manager);\n\n/**\n * The default encoding validation procedure without any extension.\n *\n * @param       p_j2k                   the jpeg2000 codec to validate.\n * @param       p_stream                the input stream to validate.\n * @param       p_manager               the user event manager.\n *\n * @return true if the parameters are correct.\n */\nstatic OPJ_BOOL opj_j2k_encoding_validation (   opj_j2k_t * p_j2k,\n                                                opj_stream_private_t *p_stream,\n                                                opj_event_mgr_t * p_manager );\n\n/**\n * The default decoding validation procedure without any extension.\n *\n * @param       p_j2k                   the jpeg2000 codec to validate.\n * @param       p_stream                                the input stream to validate.\n * @param       p_manager               the user event manager.\n *\n * @return true if the parameters are correct.\n */\nstatic OPJ_BOOL opj_j2k_decoding_validation (   opj_j2k_t * p_j2k,\n                                                opj_stream_private_t *p_stream,\n                                                opj_event_mgr_t * p_manager );\n\n/**\n * Sets up the validation ,i.e. adds the procedures to lauch to make sure the codec parameters\n * are valid. Developpers wanting to extend the library can add their own validation procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_encoding_validation (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager);\n\n/**\n * Sets up the validation ,i.e. adds the procedures to lauch to make sure the codec parameters\n * are valid. Developpers wanting to extend the library can add their own validation procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_decoding_validation (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager);\n\n/**\n * Sets up the validation ,i.e. adds the procedures to lauch to make sure the codec parameters\n * are valid. Developpers wanting to extend the library can add their own validation procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_end_compress (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager);\n\n/**\n * The mct encoding validation procedure.\n *\n * @param       p_j2k                   the jpeg2000 codec to validate.\n * @param       p_stream                                the input stream to validate.\n * @param       p_manager               the user event manager.\n *\n * @return true if the parameters are correct.\n */\nstatic OPJ_BOOL opj_j2k_mct_validation (opj_j2k_t * p_j2k,\n                                        opj_stream_private_t *p_stream,\n                                        opj_event_mgr_t * p_manager );\n\n/**\n * Builds the tcd decoder to use to decode tile.\n */\nstatic OPJ_BOOL opj_j2k_build_decoder ( opj_j2k_t * p_j2k,\n                                        opj_stream_private_t *p_stream,\n                                        opj_event_mgr_t * p_manager );\n/**\n * Builds the tcd encoder to use to encode tile.\n */\nstatic OPJ_BOOL opj_j2k_build_encoder ( opj_j2k_t * p_j2k,\n                                        opj_stream_private_t *p_stream,\n                                        opj_event_mgr_t * p_manager );\n\n/**\n * Creates a tile-coder decoder.\n *\n * @param       p_stream                        the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager                   the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_create_tcd(     opj_j2k_t *p_j2k,\n                                                                    opj_stream_private_t *p_stream,\n                                                                    opj_event_mgr_t * p_manager );\n\n/**\n * Excutes the given procedures on the given codec.\n *\n * @param       p_procedure_list        the list of procedures to execute\n * @param       p_j2k                           the jpeg2000 codec to execute the procedures on.\n * @param       p_stream                        the stream to execute the procedures on.\n * @param       p_manager                       the user manager.\n *\n * @return      true                            if all the procedures were successfully executed.\n */\nstatic OPJ_BOOL opj_j2k_exec (  opj_j2k_t * p_j2k,\n                            opj_procedure_list_t * p_procedure_list,\n                            opj_stream_private_t *p_stream,\n                            opj_event_mgr_t * p_manager);\n\n/**\n * Updates the rates of the tcp.\n *\n * @param       p_stream                                the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_update_rates(   opj_j2k_t *p_j2k,\n                                                                            opj_stream_private_t *p_stream,\n                                                                            opj_event_mgr_t * p_manager );\n\n/**\n * Copies the decoding tile parameters onto all the tile parameters.\n * Creates also the tile decoder.\n */\nstatic OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd (       opj_j2k_t * p_j2k,\n                                                            opj_stream_private_t *p_stream,\n                                                            opj_event_mgr_t * p_manager );\n\n/**\n * Destroys the memory associated with the decoding of headers.\n */\nstatic OPJ_BOOL opj_j2k_destroy_header_memory ( opj_j2k_t * p_j2k,\n                                                opj_stream_private_t *p_stream,\n                                                opj_event_mgr_t * p_manager );\n\n/**\n * Reads the lookup table containing all the marker, status and action, and returns the handler associated\n * with the marker value.\n * @param       p_id            Marker value to look up\n *\n * @return      the handler associated with the id.\n*/\nstatic const struct opj_dec_memory_marker_handler * opj_j2k_get_marker_handler (OPJ_UINT32 p_id);\n\n/**\n * Destroys a tile coding parameter structure.\n *\n * @param       p_tcp           the tile coding parameter to destroy.\n */\nstatic void opj_j2k_tcp_destroy (opj_tcp_t *p_tcp);\n\n/**\n * Destroys the data inside a tile coding parameter structure.\n *\n * @param       p_tcp           the tile coding parameter which contain data to destroy.\n */\nstatic void opj_j2k_tcp_data_destroy (opj_tcp_t *p_tcp);\n\n/**\n * Destroys a coding parameter structure.\n *\n * @param       p_cp            the coding parameter to destroy.\n */\nstatic void opj_j2k_cp_destroy (opj_cp_t *p_cp);\n\n/**\n * Compare 2 a SPCod/ SPCoc elements, i.e. the coding style of a given component of a tile.\n *\n * @param       p_j2k            J2K codec.\n * @param       p_tile_no        Tile number\n * @param       p_first_comp_no  The 1st component number to compare.\n * @param       p_second_comp_no The 1st component number to compare.\n *\n * @return OPJ_TRUE if SPCdod are equals.\n */\nstatic OPJ_BOOL opj_j2k_compare_SPCod_SPCoc(opj_j2k_t *p_j2k, OPJ_UINT32 p_tile_no, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no);\n\n/**\n * Writes a SPCod or SPCoc element, i.e. the coding style of a given component of a tile.\n *\n * @param       p_j2k           J2K codec.\n * @param       p_tile_no       FIXME DOC\n * @param       p_comp_no       the component number to output.\n * @param       p_data          FIXME DOC\n * @param       p_header_size   FIXME DOC\n * @param       p_manager       the user event manager.\n *\n * @return FIXME DOC\n*/\nstatic OPJ_BOOL opj_j2k_write_SPCod_SPCoc(      opj_j2k_t *p_j2k,\n                                                                                    OPJ_UINT32 p_tile_no,\n                                                                                    OPJ_UINT32 p_comp_no,\n                                                                                    OPJ_BYTE * p_data,\n                                                                                    OPJ_UINT32 * p_header_size,\n                                                                                    opj_event_mgr_t * p_manager );\n\n/**\n * Gets the size taken by writing a SPCod or SPCoc for the given tile and component.\n *\n * @param       p_j2k                   the J2K codec.\n * @param       p_tile_no               the tile index.\n * @param       p_comp_no               the component being outputted.\n *\n * @return      the number of bytes taken by the SPCod element.\n */\nstatic OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size (opj_j2k_t *p_j2k,\n                                                                                            OPJ_UINT32 p_tile_no,\n                                                                                            OPJ_UINT32 p_comp_no );\n\n/**\n * Reads a SPCod or SPCoc element, i.e. the coding style of a given component of a tile.\n * @param       p_j2k           the jpeg2000 codec.\n * @param       compno          FIXME DOC\n * @param       p_header_data   the data contained in the COM box.\n * @param       p_header_size   the size of the data contained in the COM marker.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_SPCod_SPCoc(   opj_j2k_t *p_j2k,\n                                            OPJ_UINT32 compno,\n                                            OPJ_BYTE * p_header_data,\n                                            OPJ_UINT32 * p_header_size,\n                                            opj_event_mgr_t * p_manager );\n\n/**\n * Gets the size taken by writing SQcd or SQcc element, i.e. the quantization values of a band in the QCD or QCC.\n *\n * @param       p_tile_no               the tile index.\n * @param       p_comp_no               the component being outputted.\n * @param       p_j2k                   the J2K codec.\n *\n * @return      the number of bytes taken by the SPCod element.\n */\nstatic OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size (  opj_j2k_t *p_j2k,\n                                                                                    OPJ_UINT32 p_tile_no,\n                                                                                    OPJ_UINT32 p_comp_no );\n\n/**\n * Compares 2 SQcd or SQcc element, i.e. the quantization values of a band in the QCD or QCC.\n *\n * @param       p_j2k                   J2K codec.\n * @param       p_tile_no               the tile to output.\n * @param       p_first_comp_no         the first component number to compare.\n * @param       p_second_comp_no        the second component number to compare.\n *\n * @return OPJ_TRUE if equals.\n */\nstatic OPJ_BOOL opj_j2k_compare_SQcd_SQcc(opj_j2k_t *p_j2k, OPJ_UINT32 p_tile_no, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no);\n\n\n/**\n * Writes a SQcd or SQcc element, i.e. the quantization values of a band in the QCD or QCC.\n *\n * @param       p_tile_no               the tile to output.\n * @param       p_comp_no               the component number to output.\n * @param       p_data                  the data buffer.\n * @param       p_header_size   pointer to the size of the data buffer, it is changed by the function.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n *\n*/\nstatic OPJ_BOOL opj_j2k_write_SQcd_SQcc(opj_j2k_t *p_j2k,\n                                                                            OPJ_UINT32 p_tile_no,\n                                                                            OPJ_UINT32 p_comp_no,\n                                                                            OPJ_BYTE * p_data,\n                                                                            OPJ_UINT32 * p_header_size,\n                                                                            opj_event_mgr_t * p_manager);\n\n/**\n * Updates the Tile Length Marker.\n */\nstatic void opj_j2k_update_tlm ( opj_j2k_t * p_j2k, OPJ_UINT32 p_tile_part_size);\n\n/**\n * Reads a SQcd or SQcc element, i.e. the quantization values of a band in the QCD or QCC.\n *\n * @param       p_j2k           J2K codec.\n * @param       compno          the component number to output.\n * @param       p_header_data   the data buffer.\n * @param       p_header_size   pointer to the size of the data buffer, it is changed by the function.\n * @param       p_manager       the user event manager.\n *\n*/\nstatic OPJ_BOOL opj_j2k_read_SQcd_SQcc( opj_j2k_t *p_j2k,\n                                        OPJ_UINT32 compno,\n                                        OPJ_BYTE * p_header_data,\n                                        OPJ_UINT32 * p_header_size,\n                                        opj_event_mgr_t * p_manager );\n\n/**\n * Copies the tile component parameters of all the component from the first tile component.\n *\n * @param               p_j2k           the J2k codec.\n */\nstatic void opj_j2k_copy_tile_component_parameters( opj_j2k_t *p_j2k );\n\n/**\n * Copies the tile quantization parameters of all the component from the first tile component.\n *\n * @param               p_j2k           the J2k codec.\n */\nstatic void opj_j2k_copy_tile_quantization_parameters( opj_j2k_t *p_j2k );\n\n/**\n * Reads the tiles.\n */\nstatic OPJ_BOOL opj_j2k_decode_tiles (  opj_j2k_t *p_j2k,\n                                        opj_stream_private_t *p_stream,\n                                        opj_event_mgr_t * p_manager);\n\nstatic OPJ_BOOL opj_j2k_pre_write_tile ( opj_j2k_t * p_j2k,\n                                                                             OPJ_UINT32 p_tile_index,\n                                                                             opj_stream_private_t *p_stream,\n                                                                             opj_event_mgr_t * p_manager );\n\nstatic OPJ_BOOL opj_j2k_update_image_data (opj_tcd_t * p_tcd, OPJ_BYTE * p_data, opj_image_t* p_output_image);\n\nstatic void opj_get_tile_dimensions(opj_image_t * l_image,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\topj_tcd_tilecomp_t * l_tilec,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\topj_image_comp_t * l_img_comp,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tOPJ_UINT32* l_size_comp,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tOPJ_UINT32* l_width,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tOPJ_UINT32* l_height,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tOPJ_UINT32* l_offset_x,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tOPJ_UINT32* l_offset_y,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tOPJ_UINT32* l_image_width,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tOPJ_UINT32* l_stride,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tOPJ_UINT32* l_tile_offset);\n\nstatic void opj_j2k_get_tile_data (opj_tcd_t * p_tcd, OPJ_BYTE * p_data);\n\nstatic OPJ_BOOL opj_j2k_post_write_tile (opj_j2k_t * p_j2k,\n                                                                             opj_stream_private_t *p_stream,\n                                                                             opj_event_mgr_t * p_manager );\n\n/**\n * Sets up the procedures to do on writing header.\n * Developers wanting to extend the library can add their own writing procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_header_writing (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager);\n\nstatic OPJ_BOOL opj_j2k_write_first_tile_part(  opj_j2k_t *p_j2k,\n                                                                                            OPJ_BYTE * p_data,\n                                                                                            OPJ_UINT32 * p_data_written,\n                                                                                            OPJ_UINT32 p_total_data_size,\n                                                                                            opj_stream_private_t *p_stream,\n                                                                                            struct opj_event_mgr * p_manager );\n\nstatic OPJ_BOOL opj_j2k_write_all_tile_parts(   opj_j2k_t *p_j2k,\n                                                                                            OPJ_BYTE * p_data,\n                                                                                            OPJ_UINT32 * p_data_written,\n                                                                                            OPJ_UINT32 p_total_data_size,\n                                                                                            opj_stream_private_t *p_stream,\n                                                                                            struct opj_event_mgr * p_manager );\n\n/**\n * Gets the offset of the header.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_get_end_header( opj_j2k_t *p_j2k,\n                                        opj_stream_private_t *p_stream,\n                                        opj_event_mgr_t * p_manager );\n\nstatic OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k);\n\n/*\n * -----------------------------------------------------------------------\n * -----------------------------------------------------------------------\n * -----------------------------------------------------------------------\n */\n\n/**\n * Writes the SOC marker (Start Of Codestream)\n *\n * @param       p_stream                        the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_soc(      opj_j2k_t *p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                            opj_event_mgr_t * p_manager );\n\n/**\n * Reads a SOC marker (Start of Codestream)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_stream        XXX needs data\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_soc(   opj_j2k_t *p_j2k,\n                                    opj_stream_private_t *p_stream,\n                                    opj_event_mgr_t * p_manager );\n\n/**\n * Writes the SIZ marker (image and tile size)\n *\n * @param       p_j2k           J2K codec.\n * @param       p_stream        the stream to write data to.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_siz(      opj_j2k_t *p_j2k,\n                                                                opj_stream_private_t *p_stream,\n                                                                opj_event_mgr_t * p_manager );\n\n/**\n * Reads a SIZ marker (image and tile size)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_header_data   the data contained in the SIZ box.\n * @param       p_header_size   the size of the data contained in the SIZ marker.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager);\n\n/**\n * Writes the COM marker (comment)\n *\n * @param       p_stream                        the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_com(      opj_j2k_t *p_j2k,\n                                                                        opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n\n/**\n * Reads a COM marker (comments)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_header_data   the data contained in the COM box.\n * @param       p_header_size   the size of the data contained in the COM marker.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_com (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager );\n/**\n * Writes the COD marker (Coding style default)\n *\n * @param       p_stream                        the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_cod(      opj_j2k_t *p_j2k,\n                                                                        opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n\n/**\n * Reads a COD marker (Coding Styke defaults)\n * @param       p_header_data   the data contained in the COD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the COD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_cod (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager);\n\n/**\n * Compares 2 COC markers (Coding style component)\n *\n * @param       p_j2k            J2K codec.\n * @param       p_first_comp_no  the index of the first component to compare.\n * @param       p_second_comp_no the index of the second component to compare.\n *\n * @return      OPJ_TRUE if equals\n */\nstatic OPJ_BOOL opj_j2k_compare_coc(opj_j2k_t *p_j2k, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no);\n\n/**\n * Writes the COC marker (Coding style component)\n *\n * @param       p_j2k       J2K codec.\n * @param       p_comp_no   the index of the component to output.\n * @param       p_stream    the stream to write data to.\n * @param       p_manager   the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_coc(  opj_j2k_t *p_j2k,\n                                                                OPJ_UINT32 p_comp_no,\n                                                                opj_stream_private_t *p_stream,\n                                                                opj_event_mgr_t * p_manager );\n\n/**\n * Writes the COC marker (Coding style component)\n *\n * @param       p_j2k                   J2K codec.\n * @param       p_comp_no               the index of the component to output.\n * @param       p_data          FIXME DOC\n * @param       p_data_written  FIXME DOC\n * @param       p_manager               the user event manager.\n*/\nstatic void opj_j2k_write_coc_in_memory(opj_j2k_t *p_j2k,\n                                                                            OPJ_UINT32 p_comp_no,\n                                                                            OPJ_BYTE * p_data,\n                                                                            OPJ_UINT32 * p_data_written,\n                                                                            opj_event_mgr_t * p_manager );\n\n/**\n * Gets the maximum size taken by a coc.\n *\n * @param       p_j2k   the jpeg2000 codec to use.\n */\nstatic OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k);\n\n/**\n * Reads a COC marker (Coding Style Component)\n * @param       p_header_data   the data contained in the COC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the COC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_coc (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager );\n\n/**\n * Writes the QCD marker (quantization default)\n *\n * @param       p_j2k                   J2K codec.\n * @param       p_stream                the stream to write data to.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_qcd(      opj_j2k_t *p_j2k,\n                                                                        opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n\n/**\n * Reads a QCD marker (Quantization defaults)\n * @param       p_header_data   the data contained in the QCD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the QCD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_qcd (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager );\n\n/**\n * Compare QCC markers (quantization component)\n *\n * @param       p_j2k                 J2K codec.\n * @param       p_first_comp_no       the index of the first component to compare.\n * @param       p_second_comp_no      the index of the second component to compare.\n *\n * @return OPJ_TRUE if equals.\n */\nstatic OPJ_BOOL opj_j2k_compare_qcc(opj_j2k_t *p_j2k, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no);\n\n/**\n * Writes the QCC marker (quantization component)\n *\n * @param       p_comp_no       the index of the component to output.\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_qcc(      opj_j2k_t *p_j2k,\n                                                                        OPJ_UINT32 p_comp_no,\n                                                                        opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n\n/**\n * Writes the QCC marker (quantization component)\n *\n * @param       p_j2k           J2K codec.\n * @param       p_comp_no       the index of the component to output.\n * @param       p_data          FIXME DOC\n * @param       p_data_written  the stream to write data to.\n * @param       p_manager       the user event manager.\n*/\nstatic void opj_j2k_write_qcc_in_memory(opj_j2k_t *p_j2k,\n                                                                            OPJ_UINT32 p_comp_no,\n                                                                            OPJ_BYTE * p_data,\n                                                                            OPJ_UINT32 * p_data_written,\n                                                                            opj_event_mgr_t * p_manager );\n\n/**\n * Gets the maximum size taken by a qcc.\n */\nstatic OPJ_UINT32 opj_j2k_get_max_qcc_size (opj_j2k_t *p_j2k);\n\n/**\n * Reads a QCC marker (Quantization component)\n * @param       p_header_data   the data contained in the QCC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the QCC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_qcc(   opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager);\n/**\n * Writes the POC marker (Progression Order Change)\n *\n * @param       p_stream                                the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_poc(      opj_j2k_t *p_j2k,\n                                                                        opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n/**\n * Writes the POC marker (Progression Order Change)\n *\n * @param       p_j2k          J2K codec.\n * @param       p_data         FIXME DOC\n * @param       p_data_written the stream to write data to.\n * @param       p_manager      the user event manager.\n */\nstatic void opj_j2k_write_poc_in_memory(opj_j2k_t *p_j2k,\n                                                                            OPJ_BYTE * p_data,\n                                                                            OPJ_UINT32 * p_data_written,\n                                                                            opj_event_mgr_t * p_manager );\n/**\n * Gets the maximum size taken by the writing of a POC.\n */\nstatic OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k);\n\n/**\n * Reads a POC marker (Progression Order Change)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_poc (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager );\n\n/**\n * Gets the maximum size taken by the toc headers of all the tile parts of any given tile.\n */\nstatic OPJ_UINT32 opj_j2k_get_max_toc_size (opj_j2k_t *p_j2k);\n\n/**\n * Gets the maximum size taken by the headers of the SOT.\n *\n * @param       p_j2k   the jpeg2000 codec to use.\n */\nstatic OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k);\n\n/**\n * Reads a CRG marker (Component registration)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_crg (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager );\n/**\n * Reads a TLM marker (Tile Length Marker)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_tlm (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager);\n\n/**\n * Writes the updated tlm.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_updated_tlm(      opj_j2k_t *p_j2k,\n                                            opj_stream_private_t *p_stream,\n                                            opj_event_mgr_t * p_manager );\n\n/**\n * Reads a PLM marker (Packet length, main header marker)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_plm (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager);\n/**\n * Reads a PLT marker (Packet length, tile-part header)\n *\n * @param       p_header_data   the data contained in the PLT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the PLT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_plt (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager );\n\n/**\n * Reads a PPM marker (Packed headers, main header)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n */\n\nstatic OPJ_BOOL opj_j2k_read_ppm (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t opj_j2k_t *p_j2k,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_BYTE * p_header_data,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_UINT32 p_header_size,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t opj_event_mgr_t * p_manager );\n\n/**\n * Merges all PPM markers read (Packed headers, main header)\n *\n * @param       p_cp      main coding parameters.\n * @param       p_manager the user event manager.\n */\nstatic OPJ_BOOL opj_j2k_merge_ppm ( opj_cp_t *p_cp, opj_event_mgr_t * p_manager );\n\n/**\n * Reads a PPT marker (Packed packet headers, tile-part header)\n *\n * @param       p_header_data   the data contained in the PPT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the PPT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_ppt (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager );\n\n/**\n * Merges all PPT markers read (Packed headers, tile-part header)\n *\n * @param       p_tcp   the tile.\n * @param       p_manager               the user event manager.\n */\nstatic OPJ_BOOL opj_j2k_merge_ppt (  opj_tcp_t *p_tcp,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   opj_event_mgr_t * p_manager );\n\n\n/**\n * Writes the TLM marker (Tile Length Marker)\n *\n * @param       p_stream                                the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_tlm(      opj_j2k_t *p_j2k,\n                                                                        opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n\n/**\n * Writes the SOT marker (Start of tile-part)\n *\n * @param       p_j2k            J2K codec.\n * @param       p_data           FIXME DOC\n * @param       p_data_written   FIXME DOC\n * @param       p_stream         the stream to write data to.\n * @param       p_manager        the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_sot(      opj_j2k_t *p_j2k,\n                                                                        OPJ_BYTE * p_data,\n                                                                        OPJ_UINT32 * p_data_written,\n                                                                        const opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n\n/**\n * Reads values from a SOT marker (Start of tile-part)\n *\n * the j2k decoder state is not affected. No side effects, no checks except for p_header_size.\n *\n * @param       p_header_data   the data contained in the SOT marker.\n * @param       p_header_size   the size of the data contained in the SOT marker.\n * @param       p_tile_no       Isot.\n * @param       p_tot_len       Psot.\n * @param       p_current_part  TPsot.\n * @param       p_num_parts     TNsot.\n * @param       p_manager       the user event manager.\n */\nstatic OPJ_BOOL opj_j2k_get_sot_values(OPJ_BYTE *  p_header_data,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_UINT32  p_header_size,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_UINT32* p_tile_no,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_UINT32* p_tot_len,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_UINT32* p_current_part,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_UINT32* p_num_parts,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t opj_event_mgr_t * p_manager );\n/**\n * Reads a SOT marker (Start of tile-part)\n *\n * @param       p_header_data   the data contained in the SOT marker.\n * @param       p_j2k           the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the PPT marker.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_sot (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager );\n/**\n * Writes the SOD marker (Start of data)\n *\n * @param       p_j2k               J2K codec.\n * @param       p_tile_coder        FIXME DOC\n * @param       p_data              FIXME DOC\n * @param       p_data_written      FIXME DOC\n * @param       p_total_data_size   FIXME DOC\n * @param       p_stream            the stream to write data to.\n * @param       p_manager           the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_sod(      opj_j2k_t *p_j2k,\n                                                                        opj_tcd_t * p_tile_coder,\n                                                                        OPJ_BYTE * p_data,\n                                                                        OPJ_UINT32 * p_data_written,\n                                                                        OPJ_UINT32 p_total_data_size,\n                                                                        const opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n\n/**\n * Reads a SOD marker (Start Of Data)\n *\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_stream                FIXME DOC\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_sod(   opj_j2k_t *p_j2k,\n                                    opj_stream_private_t *p_stream,\n                                    opj_event_mgr_t * p_manager );\n\nstatic void opj_j2k_update_tlm (opj_j2k_t * p_j2k, OPJ_UINT32 p_tile_part_size )\n{\n        opj_write_bytes(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,p_j2k->m_current_tile_number,1);            /* PSOT */\n        ++p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current;\n\n        opj_write_bytes(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,p_tile_part_size,4);                                        /* PSOT */\n        p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current += 4;\n}\n\n/**\n * Writes the RGN marker (Region Of Interest)\n *\n * @param       p_tile_no               the tile to output\n * @param       p_comp_no               the component to output\n * @param       nb_comps                the number of components\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_rgn(  opj_j2k_t *p_j2k,\n                                    OPJ_UINT32 p_tile_no,\n                                    OPJ_UINT32 p_comp_no,\n                                    OPJ_UINT32 nb_comps,\n                                    opj_stream_private_t *p_stream,\n                                    opj_event_mgr_t * p_manager );\n\n/**\n * Reads a RGN marker (Region Of Interest)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_rgn (opj_j2k_t *p_j2k,\n                                  OPJ_BYTE * p_header_data,\n                                  OPJ_UINT32 p_header_size,\n                                  opj_event_mgr_t * p_manager );\n\n/**\n * Writes the EOC marker (End of Codestream)\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_eoc(      opj_j2k_t *p_j2k,\n                                    opj_stream_private_t *p_stream,\n                                    opj_event_mgr_t * p_manager );\n\n#if 0\n/**\n * Reads a EOC marker (End Of Codestream)\n *\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_stream                FIXME DOC\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_eoc (      opj_j2k_t *p_j2k,\n                                                                opj_stream_private_t *p_stream,\n                                                                opj_event_mgr_t * p_manager );\n#endif\n\n/**\n * Writes the CBD-MCT-MCC-MCO markers (Multi components transform)\n *\n * @param       p_stream                        the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_mct_data_group(   opj_j2k_t *p_j2k,\n                                                opj_stream_private_t *p_stream,\n                                                opj_event_mgr_t * p_manager );\n\n/**\n * Inits the Info\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_init_info(      opj_j2k_t *p_j2k,\n                                    opj_stream_private_t *p_stream,\n                                    opj_event_mgr_t * p_manager );\n\n/**\nAdd main header marker information\n@param cstr_index    Codestream information structure\n@param type         marker type\n@param pos          byte offset of marker segment\n@param len          length of marker segment\n */\nstatic OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index, OPJ_UINT32 type, OPJ_OFF_T pos, OPJ_UINT32 len) ;\n/**\nAdd tile header marker information\n@param tileno       tile index number\n@param cstr_index   Codestream information structure\n@param type         marker type\n@param pos          byte offset of marker segment\n@param len          length of marker segment\n */\nstatic OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno, opj_codestream_index_t *cstr_index, OPJ_UINT32 type, OPJ_OFF_T pos, OPJ_UINT32 len);\n\n/**\n * Reads an unknown marker\n *\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_stream                the stream object to read from.\n * @param       output_marker           FIXME DOC\n * @param       p_manager               the user event manager.\n *\n * @return      true                    if the marker could be deduced.\n*/\nstatic OPJ_BOOL opj_j2k_read_unk( opj_j2k_t *p_j2k,\n                                  opj_stream_private_t *p_stream,\n                                  OPJ_UINT32 *output_marker,\n                                  opj_event_mgr_t * p_manager );\n\n/**\n * Writes the MCT marker (Multiple Component Transform)\n *\n * @param       p_j2k           J2K codec.\n * @param       p_mct_record    FIXME DOC\n * @param       p_stream        the stream to write data to.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_mct_record(       opj_j2k_t *p_j2k,\n                                                                                    opj_mct_data_t * p_mct_record,\n                                            opj_stream_private_t *p_stream,\n                                            opj_event_mgr_t * p_manager );\n\n/**\n * Reads a MCT marker (Multiple Component Transform)\n *\n * @param       p_header_data   the data contained in the MCT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the MCT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_mct (      opj_j2k_t *p_j2k,\n                                                                    OPJ_BYTE * p_header_data,\n                                                                    OPJ_UINT32 p_header_size,\n                                                                    opj_event_mgr_t * p_manager );\n\n/**\n * Writes the MCC marker (Multiple Component Collection)\n *\n * @param       p_j2k                   J2K codec.\n * @param       p_mcc_record            FIXME DOC\n * @param       p_stream                the stream to write data to.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_mcc_record(   opj_j2k_t *p_j2k,\n                                            opj_simple_mcc_decorrelation_data_t * p_mcc_record,\n                                            opj_stream_private_t *p_stream,\n                                            opj_event_mgr_t * p_manager );\n\n/**\n * Reads a MCC marker (Multiple Component Collection)\n *\n * @param       p_header_data   the data contained in the MCC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the MCC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_mcc (      opj_j2k_t *p_j2k,\n                                                                    OPJ_BYTE * p_header_data,\n                                                                    OPJ_UINT32 p_header_size,\n                                                                    opj_event_mgr_t * p_manager );\n\n/**\n * Writes the MCO marker (Multiple component transformation ordering)\n *\n * @param       p_stream                                the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_mco(      opj_j2k_t *p_j2k,\n                                    opj_stream_private_t *p_stream,\n                                    opj_event_mgr_t * p_manager );\n\n/**\n * Reads a MCO marker (Multiple Component Transform Ordering)\n *\n * @param       p_header_data   the data contained in the MCO box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the MCO marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_mco (      opj_j2k_t *p_j2k,\n                                                                    OPJ_BYTE * p_header_data,\n                                                                    OPJ_UINT32 p_header_size,\n                                                                    opj_event_mgr_t * p_manager );\n\nstatic OPJ_BOOL opj_j2k_add_mct(opj_tcp_t * p_tcp, opj_image_t * p_image, OPJ_UINT32 p_index);\n\nstatic void  opj_j2k_read_int16_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_float32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_float64_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\n\nstatic void  opj_j2k_read_int16_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_int32_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_float32_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_read_float64_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\n\nstatic void  opj_j2k_write_float_to_int16 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_write_float_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_write_float_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\nstatic void  opj_j2k_write_float_to_float64 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\n\n/**\n * Ends the encoding, i.e. frees memory.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_end_encoding(   opj_j2k_t *p_j2k,\n                                                                            opj_stream_private_t *p_stream,\n                                                                            opj_event_mgr_t * p_manager );\n\n/**\n * Writes the CBD marker (Component bit depth definition)\n *\n * @param       p_stream                                the stream to write data to.\n * @param       p_j2k                           J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_cbd(      opj_j2k_t *p_j2k,\n                                                                    opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n\n/**\n * Reads a CBD marker (Component bit depth definition)\n * @param       p_header_data   the data contained in the CBD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the CBD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_cbd (      opj_j2k_t *p_j2k,\n                                                                OPJ_BYTE * p_header_data,\n                                                                OPJ_UINT32 p_header_size,\n                                                                opj_event_mgr_t * p_manager);\n\n\n/**\n * Writes COC marker for each component.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_all_coc( opj_j2k_t *p_j2k,\n                                                                        opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n\n/**\n * Writes QCC marker for each component.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_all_qcc( opj_j2k_t *p_j2k,\n                                                                        opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n\n/**\n * Writes regions of interests.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_regions(  opj_j2k_t *p_j2k,\n                                                                        opj_stream_private_t *p_stream,\n                                                                        opj_event_mgr_t * p_manager );\n\n/**\n * Writes EPC ????\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_write_epc(      opj_j2k_t *p_j2k,\n                                                                    opj_stream_private_t *p_stream,\n                                                                    opj_event_mgr_t * p_manager );\n\n/**\n * Checks the progression order changes values. Tells of the poc given as input are valid.\n * A nice message is outputted at errors.\n *\n * @param       p_pocs                  the progression order changes.\n * @param       p_nb_pocs               the number of progression order changes.\n * @param       p_nb_resolutions        the number of resolutions.\n * @param       numcomps                the number of components\n * @param       numlayers               the number of layers.\n * @param       p_manager               the user event manager.\n *\n * @return      true if the pocs are valid.\n */\nstatic OPJ_BOOL opj_j2k_check_poc_val(  const opj_poc_t *p_pocs,\n                                                                            OPJ_UINT32 p_nb_pocs,\n                                                                            OPJ_UINT32 p_nb_resolutions,\n                                                                            OPJ_UINT32 numcomps,\n                                                                            OPJ_UINT32 numlayers,\n                                                                            opj_event_mgr_t * p_manager);\n\n/**\n * Gets the number of tile parts used for the given change of progression (if any) and the given tile.\n *\n * @param               cp                      the coding parameters.\n * @param               pino            the offset of the given poc (i.e. its position in the coding parameter).\n * @param               tileno          the given tile.\n *\n * @return              the number of tile parts.\n */\nstatic OPJ_UINT32 opj_j2k_get_num_tp( opj_cp_t *cp, OPJ_UINT32 pino, OPJ_UINT32 tileno);\n\n/**\n * Calculates the total number of tile parts needed by the encoder to\n * encode such an image. If not enough memory is available, then the function return false.\n *\n * @param       p_nb_tiles      pointer that will hold the number of tile parts.\n * @param       cp                      the coding parameters for the image.\n * @param       image           the image to encode.\n * @param       p_j2k                   the p_j2k encoder.\n * @param       p_manager       the user event manager.\n *\n * @return true if the function was successful, false else.\n */\nstatic OPJ_BOOL opj_j2k_calculate_tp(   opj_j2k_t *p_j2k,\n                                                                            opj_cp_t *cp,\n                                                                            OPJ_UINT32 * p_nb_tiles,\n                                                                            opj_image_t *image,\n                                                                            opj_event_mgr_t * p_manager);\n\nstatic void opj_j2k_dump_MH_info(opj_j2k_t* p_j2k, FILE* out_stream);\n\nstatic void opj_j2k_dump_MH_index(opj_j2k_t* p_j2k, FILE* out_stream);\n\nstatic opj_codestream_index_t* opj_j2k_create_cstr_index(void);\n\nstatic OPJ_FLOAT32 opj_j2k_get_tp_stride (opj_tcp_t * p_tcp);\n\nstatic OPJ_FLOAT32 opj_j2k_get_default_stride (opj_tcp_t * p_tcp);\n\nstatic int opj_j2k_initialise_4K_poc(opj_poc_t *POC, int numres);\n\nstatic void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters, opj_image_t *image, opj_event_mgr_t *p_manager);\n\nstatic OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image, OPJ_UINT16 rsiz, opj_event_mgr_t *p_manager);\n\n/**\n * Checks for invalid number of tile-parts in SOT marker (TPsot==TNsot). See issue 254.\n *\n * @param       p_stream            the stream to read data from.\n * @param       tile_no             tile number we're looking for.\n * @param       p_correction_needed output value. if true, non conformant codestream needs TNsot correction.\n * @param       p_manager       the user event manager.\n *\n * @return true if the function was successful, false else.\n */\nstatic OPJ_BOOL opj_j2k_need_nb_tile_parts_correction(opj_stream_private_t *p_stream, OPJ_UINT32 tile_no, OPJ_BOOL* p_correction_needed, opj_event_mgr_t * p_manager );\n\n/*@}*/\n\n/*@}*/\n\n/* ----------------------------------------------------------------------- */\ntypedef struct j2k_prog_order{\n        OPJ_PROG_ORDER enum_prog;\n        char str_prog[5];\n}j2k_prog_order_t;\n\nstatic j2k_prog_order_t j2k_prog_order_list[] = {\n        {OPJ_CPRL, \"CPRL\"},\n        {OPJ_LRCP, \"LRCP\"},\n        {OPJ_PCRL, \"PCRL\"},\n        {OPJ_RLCP, \"RLCP\"},\n        {OPJ_RPCL, \"RPCL\"},\n        {(OPJ_PROG_ORDER)-1, \"\"}\n};\n\n/**\n * FIXME DOC\n */\nstatic const OPJ_UINT32 MCT_ELEMENT_SIZE [] =\n{\n        2,\n        4,\n        4,\n        8\n};\n\ntypedef void (* opj_j2k_mct_function) (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);\n\nstatic const opj_j2k_mct_function j2k_mct_read_functions_to_float [] =\n{\n        opj_j2k_read_int16_to_float,\n        opj_j2k_read_int32_to_float,\n        opj_j2k_read_float32_to_float,\n        opj_j2k_read_float64_to_float\n};\n\nstatic const opj_j2k_mct_function j2k_mct_read_functions_to_int32 [] =\n{\n        opj_j2k_read_int16_to_int32,\n        opj_j2k_read_int32_to_int32,\n        opj_j2k_read_float32_to_int32,\n        opj_j2k_read_float64_to_int32\n};\n\nstatic const opj_j2k_mct_function j2k_mct_write_functions_from_float [] =\n{\n        opj_j2k_write_float_to_int16,\n        opj_j2k_write_float_to_int32,\n        opj_j2k_write_float_to_float,\n        opj_j2k_write_float_to_float64\n};\n\ntypedef struct opj_dec_memory_marker_handler\n{\n        /** marker value */\n        OPJ_UINT32 id;\n        /** value of the state when the marker can appear */\n        OPJ_UINT32 states;\n        /** action linked to the marker */\n        OPJ_BOOL (*handler) (   opj_j2k_t *p_j2k,\n                            OPJ_BYTE * p_header_data,\n                            OPJ_UINT32 p_header_size,\n                            opj_event_mgr_t * p_manager );\n}\nopj_dec_memory_marker_handler_t;\n\nstatic const opj_dec_memory_marker_handler_t j2k_memory_marker_handler_tab [] =\n{\n  {J2K_MS_SOT, J2K_STATE_MH | J2K_STATE_TPHSOT, opj_j2k_read_sot},\n  {J2K_MS_COD, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_cod},\n  {J2K_MS_COC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_coc},\n  {J2K_MS_RGN, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_rgn},\n  {J2K_MS_QCD, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_qcd},\n  {J2K_MS_QCC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_qcc},\n  {J2K_MS_POC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_poc},\n  {J2K_MS_SIZ, J2K_STATE_MHSIZ, opj_j2k_read_siz},\n  {J2K_MS_TLM, J2K_STATE_MH, opj_j2k_read_tlm},\n  {J2K_MS_PLM, J2K_STATE_MH, opj_j2k_read_plm},\n  {J2K_MS_PLT, J2K_STATE_TPH, opj_j2k_read_plt},\n  {J2K_MS_PPM, J2K_STATE_MH, opj_j2k_read_ppm},\n  {J2K_MS_PPT, J2K_STATE_TPH, opj_j2k_read_ppt},\n  {J2K_MS_SOP, 0, 0},\n  {J2K_MS_CRG, J2K_STATE_MH, opj_j2k_read_crg},\n  {J2K_MS_COM, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_com},\n  {J2K_MS_MCT, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_mct},\n  {J2K_MS_CBD, J2K_STATE_MH , opj_j2k_read_cbd},\n  {J2K_MS_MCC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_mcc},\n  {J2K_MS_MCO, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_mco},\n#ifdef USE_JPWL\n#ifdef TODO_MS /* remove these functions which are not commpatible with the v2 API */\n  {J2K_MS_EPC, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_epc},\n  {J2K_MS_EPB, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_epb},\n  {J2K_MS_ESD, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_esd},\n  {J2K_MS_RED, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_red},\n#endif\n#endif /* USE_JPWL */\n#ifdef USE_JPSEC\n  {J2K_MS_SEC, J2K_DEC_STATE_MH, j2k_read_sec},\n  {J2K_MS_INSEC, 0, j2k_read_insec}\n#endif /* USE_JPSEC */\n  {J2K_MS_UNK, J2K_STATE_MH | J2K_STATE_TPH, 0}/*opj_j2k_read_unk is directly used*/\n};\n\nstatic void  opj_j2k_read_int16_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                opj_read_bytes(l_src_data,&l_temp,2);\n\n                l_src_data+=sizeof(OPJ_INT16);\n\n                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;\n        }\n}\n\nstatic void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                opj_read_bytes(l_src_data,&l_temp,4);\n\n                l_src_data+=sizeof(OPJ_INT32);\n\n                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;\n        }\n}\n\nstatic void  opj_j2k_read_float32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;\n        OPJ_UINT32 i;\n        OPJ_FLOAT32 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                opj_read_float(l_src_data,&l_temp);\n\n                l_src_data+=sizeof(OPJ_FLOAT32);\n\n                *(l_dest_data++) = l_temp;\n        }\n}\n\nstatic void  opj_j2k_read_float64_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;\n        OPJ_UINT32 i;\n        OPJ_FLOAT64 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                opj_read_double(l_src_data,&l_temp);\n\n                l_src_data+=sizeof(OPJ_FLOAT64);\n\n                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;\n        }\n}\n\nstatic void  opj_j2k_read_int16_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n        OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                opj_read_bytes(l_src_data,&l_temp,2);\n\n                l_src_data+=sizeof(OPJ_INT16);\n\n                *(l_dest_data++) = (OPJ_INT32) l_temp;\n        }\n}\n\nstatic void  opj_j2k_read_int32_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n        OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                opj_read_bytes(l_src_data,&l_temp,4);\n\n                l_src_data+=sizeof(OPJ_INT32);\n\n                *(l_dest_data++) = (OPJ_INT32) l_temp;\n        }\n}\n\nstatic void  opj_j2k_read_float32_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n        OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;\n        OPJ_UINT32 i;\n        OPJ_FLOAT32 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                opj_read_float(l_src_data,&l_temp);\n\n                l_src_data+=sizeof(OPJ_FLOAT32);\n\n                *(l_dest_data++) = (OPJ_INT32) l_temp;\n        }\n}\n\nstatic void  opj_j2k_read_float64_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n        OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;\n        OPJ_UINT32 i;\n        OPJ_FLOAT64 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                opj_read_double(l_src_data,&l_temp);\n\n                l_src_data+=sizeof(OPJ_FLOAT64);\n\n                *(l_dest_data++) = (OPJ_INT32) l_temp;\n        }\n}\n\nstatic void  opj_j2k_write_float_to_int16 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;\n        OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                l_temp = (OPJ_UINT32) *(l_src_data++);\n\n                opj_write_bytes(l_dest_data,l_temp,sizeof(OPJ_INT16));\n\n                l_dest_data+=sizeof(OPJ_INT16);\n        }\n}\n\nstatic void opj_j2k_write_float_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;\n        OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                l_temp = (OPJ_UINT32) *(l_src_data++);\n\n                opj_write_bytes(l_dest_data,l_temp,sizeof(OPJ_INT32));\n\n                l_dest_data+=sizeof(OPJ_INT32);\n        }\n}\n\nstatic void  opj_j2k_write_float_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;\n        OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;\n        OPJ_UINT32 i;\n        OPJ_FLOAT32 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                l_temp = (OPJ_FLOAT32) *(l_src_data++);\n\n                opj_write_float(l_dest_data,l_temp);\n\n                l_dest_data+=sizeof(OPJ_FLOAT32);\n        }\n}\n\nstatic void  opj_j2k_write_float_to_float64 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;\n        OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;\n        OPJ_UINT32 i;\n        OPJ_FLOAT64 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                l_temp = (OPJ_FLOAT64) *(l_src_data++);\n\n                opj_write_double(l_dest_data,l_temp);\n\n                l_dest_data+=sizeof(OPJ_FLOAT64);\n        }\n}\n\nchar *opj_j2k_convert_progression_order(OPJ_PROG_ORDER prg_order){\n        j2k_prog_order_t *po;\n        for(po = j2k_prog_order_list; po->enum_prog != -1; po++ ){\n                if(po->enum_prog == prg_order){\n                        return po->str_prog;\n                }\n        }\n        return po->str_prog;\n}\n\nstatic OPJ_BOOL opj_j2k_check_poc_val( const opj_poc_t *p_pocs,\n                                                        OPJ_UINT32 p_nb_pocs,\n                                                        OPJ_UINT32 p_nb_resolutions,\n                                                        OPJ_UINT32 p_num_comps,\n                                                        OPJ_UINT32 p_num_layers,\n                                                        opj_event_mgr_t * p_manager)\n{\n        OPJ_UINT32* packet_array;\n        OPJ_UINT32 index , resno, compno, layno;\n        OPJ_UINT32 i;\n        OPJ_UINT32 step_c = 1;\n        OPJ_UINT32 step_r = p_num_comps * step_c;\n        OPJ_UINT32 step_l = p_nb_resolutions * step_r;\n        OPJ_BOOL loss = OPJ_FALSE;\n        OPJ_UINT32 layno0 = 0;\n\n        packet_array = (OPJ_UINT32*) opj_calloc(step_l * p_num_layers, sizeof(OPJ_UINT32));\n        if (packet_array == 00) {\n                opj_event_msg(p_manager , EVT_ERROR, \"Not enough memory for checking the poc values.\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (p_nb_pocs == 0) {\n        opj_free(packet_array);\n                return OPJ_TRUE;\n        }\n\n        index = step_r * p_pocs->resno0;\n        /* take each resolution for each poc */\n        for (resno = p_pocs->resno0 ; resno < p_pocs->resno1 ; ++resno)\n        {\n                OPJ_UINT32 res_index = index + p_pocs->compno0 * step_c;\n\n                /* take each comp of each resolution for each poc */\n                for (compno = p_pocs->compno0 ; compno < p_pocs->compno1 ; ++compno) {\n                        OPJ_UINT32 comp_index = res_index + layno0 * step_l;\n\n                        /* and finally take each layer of each res of ... */\n                        for (layno = layno0; layno < p_pocs->layno1 ; ++layno) {\n                                /*index = step_r * resno + step_c * compno + step_l * layno;*/\n                                packet_array[comp_index] = 1;\n                                comp_index += step_l;\n                        }\n\n                        res_index += step_c;\n                }\n\n                index += step_r;\n        }\n        ++p_pocs;\n\n        /* iterate through all the pocs */\n        for (i = 1; i < p_nb_pocs ; ++i) {\n                OPJ_UINT32 l_last_layno1 = (p_pocs-1)->layno1 ;\n\n                layno0 = (p_pocs->layno1 > l_last_layno1)? l_last_layno1 : 0;\n                index = step_r * p_pocs->resno0;\n\n                /* take each resolution for each poc */\n                for (resno = p_pocs->resno0 ; resno < p_pocs->resno1 ; ++resno) {\n                        OPJ_UINT32 res_index = index + p_pocs->compno0 * step_c;\n\n                        /* take each comp of each resolution for each poc */\n                        for (compno = p_pocs->compno0 ; compno < p_pocs->compno1 ; ++compno) {\n                                OPJ_UINT32 comp_index = res_index + layno0 * step_l;\n\n                                /* and finally take each layer of each res of ... */\n                                for (layno = layno0; layno < p_pocs->layno1 ; ++layno) {\n                                        /*index = step_r * resno + step_c * compno + step_l * layno;*/\n                                        packet_array[comp_index] = 1;\n                                        comp_index += step_l;\n                                }\n\n                                res_index += step_c;\n                        }\n\n                        index += step_r;\n                }\n\n                ++p_pocs;\n        }\n\n        index = 0;\n        for (layno = 0; layno < p_num_layers ; ++layno) {\n                for (resno = 0; resno < p_nb_resolutions; ++resno) {\n                        for (compno = 0; compno < p_num_comps; ++compno) {\n                                loss |= (packet_array[index]!=1);\n                                /*index = step_r * resno + step_c * compno + step_l * layno;*/\n                                index += step_c;\n                        }\n                }\n        }\n\n        if (loss) {\n                opj_event_msg(p_manager , EVT_ERROR, \"Missing packets possible loss of data\\n\");\n        }\n\n        opj_free(packet_array);\n\n        return !loss;\n}\n\n/* ----------------------------------------------------------------------- */\n\nstatic OPJ_UINT32 opj_j2k_get_num_tp(opj_cp_t *cp, OPJ_UINT32 pino, OPJ_UINT32 tileno)\n{\n        const OPJ_CHAR *prog = 00;\n        OPJ_INT32 i;\n        OPJ_UINT32 tpnum = 1;\n        opj_tcp_t *tcp = 00;\n        opj_poc_t * l_current_poc = 00;\n\n        /*  preconditions */\n        assert(tileno < (cp->tw * cp->th));\n        assert(pino < (cp->tcps[tileno].numpocs + 1));\n\n        /* get the given tile coding parameter */\n        tcp = &cp->tcps[tileno];\n        assert(tcp != 00);\n\n        l_current_poc = &(tcp->pocs[pino]);\n        assert(l_current_poc != 0);\n\n        /* get the progression order as a character string */\n        prog = opj_j2k_convert_progression_order(tcp->prg);\n        assert(strlen(prog) > 0);\n\n        if (cp->m_specific_param.m_enc.m_tp_on == 1) {\n                for (i=0;i<4;++i) {\n                        switch (prog[i])\n                        {\n                                /* component wise */\n                                case 'C':\n                                        tpnum *= l_current_poc->compE;\n                                        break;\n                                /* resolution wise */\n                                case 'R':\n                                        tpnum *= l_current_poc->resE;\n                                        break;\n                                /* precinct wise */\n                                case 'P':\n                                        tpnum *= l_current_poc->prcE;\n                                        break;\n                                /* layer wise */\n                                case 'L':\n                                        tpnum *= l_current_poc->layE;\n                                        break;\n                        }\n                        /* whould we split here ? */\n                        if ( cp->m_specific_param.m_enc.m_tp_flag == prog[i] ) {\n                                cp->m_specific_param.m_enc.m_tp_pos=i;\n                                break;\n                        }\n                }\n        }\n        else {\n                tpnum=1;\n        }\n\n        return tpnum;\n}\n\nstatic OPJ_BOOL opj_j2k_calculate_tp(  opj_j2k_t *p_j2k,\n                                                        opj_cp_t *cp,\n                                                        OPJ_UINT32 * p_nb_tiles,\n                                                        opj_image_t *image,\n                                                        opj_event_mgr_t * p_manager\n                                )\n{\n        OPJ_UINT32 pino,tileno;\n        OPJ_UINT32 l_nb_tiles;\n        opj_tcp_t *tcp;\n\n        /* preconditions */\n        assert(p_nb_tiles != 00);\n        assert(cp != 00);\n        assert(image != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_nb_tiles = cp->tw * cp->th;\n        * p_nb_tiles = 0;\n        tcp = cp->tcps;\n\n        /* INDEX >> */\n        /* TODO mergeV2: check this part which use cstr_info */\n        /*if (p_j2k->cstr_info) {\n                opj_tile_info_t * l_info_tile_ptr = p_j2k->cstr_info->tile;\n\n                for (tileno = 0; tileno < l_nb_tiles; ++tileno) {\n                        OPJ_UINT32 cur_totnum_tp = 0;\n\n                        opj_pi_update_encoding_parameters(image,cp,tileno);\n\n                        for (pino = 0; pino <= tcp->numpocs; ++pino)\n                        {\n                                OPJ_UINT32 tp_num = opj_j2k_get_num_tp(cp,pino,tileno);\n\n                                *p_nb_tiles = *p_nb_tiles + tp_num;\n\n                                cur_totnum_tp += tp_num;\n                        }\n\n                        tcp->m_nb_tile_parts = cur_totnum_tp;\n\n                        l_info_tile_ptr->tp = (opj_tp_info_t *) opj_malloc(cur_totnum_tp * sizeof(opj_tp_info_t));\n                        if (l_info_tile_ptr->tp == 00) {\n                                return OPJ_FALSE;\n                        }\n\n                        memset(l_info_tile_ptr->tp,0,cur_totnum_tp * sizeof(opj_tp_info_t));\n\n                        l_info_tile_ptr->num_tps = cur_totnum_tp;\n\n                        ++l_info_tile_ptr;\n                        ++tcp;\n                }\n        }\n        else */{\n                for (tileno = 0; tileno < l_nb_tiles; ++tileno) {\n                        OPJ_UINT32 cur_totnum_tp = 0;\n\n                        opj_pi_update_encoding_parameters(image,cp,tileno);\n\n                        for (pino = 0; pino <= tcp->numpocs; ++pino) {\n                                OPJ_UINT32 tp_num = opj_j2k_get_num_tp(cp,pino,tileno);\n\n                                *p_nb_tiles = *p_nb_tiles + tp_num;\n\n                                cur_totnum_tp += tp_num;\n                        }\n                        tcp->m_nb_tile_parts = cur_totnum_tp;\n\n                        ++tcp;\n                }\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_soc(     opj_j2k_t *p_j2k,\n                                                opj_stream_private_t *p_stream,\n                                                    opj_event_mgr_t * p_manager )\n{\n        /* 2 bytes will be written */\n        OPJ_BYTE * l_start_stream = 00;\n\n        /* preconditions */\n        assert(p_stream != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_start_stream = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        /* write SOC identifier */\n        opj_write_bytes(l_start_stream,J2K_MS_SOC,2);\n\n        if (opj_stream_write_data(p_stream,l_start_stream,2,p_manager) != 2) {\n                return OPJ_FALSE;\n        }\n\n/* UniPG>> */\n#ifdef USE_JPWL\n        /* update markers struct */\n/*\n        OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_SOC, p_stream_tell(p_stream) - 2, 2);\n*/\n  assert( 0 && \"TODO\" );\n#endif /* USE_JPWL */\n/* <<UniPG */\n\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a SOC marker (Start of Codestream)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_stream        FIXME DOC\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_soc(   opj_j2k_t *p_j2k,\n                                    opj_stream_private_t *p_stream,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_BYTE l_data [2];\n        OPJ_UINT32 l_marker;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        if (opj_stream_read_data(p_stream,l_data,2,p_manager) != 2) {\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(l_data,&l_marker,2);\n        if (l_marker != J2K_MS_SOC) {\n                return OPJ_FALSE;\n        }\n\n        /* Next marker should be a SIZ marker in the main header */\n        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_MHSIZ;\n\n        /* FIXME move it in a index structure included in p_j2k*/\n        p_j2k->cstr_index->main_head_start = opj_stream_tell(p_stream) - 2;\n\n        opj_event_msg(p_manager, EVT_INFO, \"Start to read j2k main header (%d).\\n\", p_j2k->cstr_index->main_head_start);\n\n        /* Add the marker to the codestream index*/\n        if (OPJ_FALSE == opj_j2k_add_mhmarker(p_j2k->cstr_index, J2K_MS_SOC, p_j2k->cstr_index->main_head_start, 2)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add mh marker\\n\");\n                return OPJ_FALSE;\n        }\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_siz(     opj_j2k_t *p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager )\n{\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_size_len;\n        OPJ_BYTE * l_current_ptr;\n        opj_image_t * l_image = 00;\n        opj_cp_t *cp = 00;\n        opj_image_comp_t * l_img_comp = 00;\n\n        /* preconditions */\n        assert(p_stream != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_image = p_j2k->m_private_image;\n        cp = &(p_j2k->m_cp);\n        l_size_len = 40 + 3 * l_image->numcomps;\n        l_img_comp = l_image->comps;\n\n        if (l_size_len > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_size_len);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory for the SIZ marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_size_len;\n        }\n\n        l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        /* write SOC identifier */\n        opj_write_bytes(l_current_ptr,J2K_MS_SIZ,2);    /* SIZ */\n        l_current_ptr+=2;\n\n        opj_write_bytes(l_current_ptr,l_size_len-2,2); /* L_SIZ */\n        l_current_ptr+=2;\n\n        opj_write_bytes(l_current_ptr, cp->rsiz, 2);    /* Rsiz (capabilities) */\n        l_current_ptr+=2;\n\n        opj_write_bytes(l_current_ptr, l_image->x1, 4); /* Xsiz */\n        l_current_ptr+=4;\n\n        opj_write_bytes(l_current_ptr, l_image->y1, 4); /* Ysiz */\n        l_current_ptr+=4;\n\n        opj_write_bytes(l_current_ptr, l_image->x0, 4); /* X0siz */\n        l_current_ptr+=4;\n\n        opj_write_bytes(l_current_ptr, l_image->y0, 4); /* Y0siz */\n        l_current_ptr+=4;\n\n        opj_write_bytes(l_current_ptr, cp->tdx, 4);             /* XTsiz */\n        l_current_ptr+=4;\n\n        opj_write_bytes(l_current_ptr, cp->tdy, 4);             /* YTsiz */\n        l_current_ptr+=4;\n\n        opj_write_bytes(l_current_ptr, cp->tx0, 4);             /* XT0siz */\n        l_current_ptr+=4;\n\n        opj_write_bytes(l_current_ptr, cp->ty0, 4);             /* YT0siz */\n        l_current_ptr+=4;\n\n        opj_write_bytes(l_current_ptr, l_image->numcomps, 2);   /* Csiz */\n        l_current_ptr+=2;\n\n        for (i = 0; i < l_image->numcomps; ++i) {\n                /* TODO here with MCT ? */\n                opj_write_bytes(l_current_ptr, l_img_comp->prec - 1 + (l_img_comp->sgnd << 7), 1);      /* Ssiz_i */\n                ++l_current_ptr;\n\n                opj_write_bytes(l_current_ptr, l_img_comp->dx, 1);      /* XRsiz_i */\n                ++l_current_ptr;\n\n                opj_write_bytes(l_current_ptr, l_img_comp->dy, 1);      /* YRsiz_i */\n                ++l_current_ptr;\n\n                ++l_img_comp;\n        }\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_size_len,p_manager) != l_size_len) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a SIZ marker (image and tile size)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_header_data   the data contained in the SIZ box.\n * @param       p_header_size   the size of the data contained in the SIZ marker.\n * @param       p_manager       the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k,\n                                 OPJ_BYTE * p_header_data,\n                                 OPJ_UINT32 p_header_size,\n                                 opj_event_mgr_t * p_manager\n                                 )\n{\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_nb_comp;\n        OPJ_UINT32 l_nb_comp_remain;\n        OPJ_UINT32 l_remaining_size;\n        OPJ_UINT32 l_nb_tiles;\n        OPJ_UINT32 l_tmp, l_tx1, l_ty1;\n        opj_image_t *l_image = 00;\n        opj_cp_t *l_cp = 00;\n        opj_image_comp_t * l_img_comp = 00;\n        opj_tcp_t * l_current_tile_param = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_header_data != 00);\n\n        l_image = p_j2k->m_private_image;\n        l_cp = &(p_j2k->m_cp);\n\n        /* minimum size == 39 - 3 (= minimum component parameter) */\n        if (p_header_size < 36) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker size\\n\");\n                return OPJ_FALSE;\n        }\n\n        l_remaining_size = p_header_size - 36;\n        l_nb_comp = l_remaining_size / 3;\n        l_nb_comp_remain = l_remaining_size % 3;\n        if (l_nb_comp_remain != 0){\n                opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker size\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(p_header_data,&l_tmp ,2);                                                /* Rsiz (capabilities) */\n        p_header_data+=2;\n        l_cp->rsiz = (OPJ_UINT16) l_tmp;\n        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->x1, 4);   /* Xsiz */\n        p_header_data+=4;\n        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->y1, 4);   /* Ysiz */\n        p_header_data+=4;\n        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->x0, 4);   /* X0siz */\n        p_header_data+=4;\n        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->y0, 4);   /* Y0siz */\n        p_header_data+=4;\n        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->tdx, 4);             /* XTsiz */\n        p_header_data+=4;\n        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->tdy, 4);             /* YTsiz */\n        p_header_data+=4;\n        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->tx0, 4);             /* XT0siz */\n        p_header_data+=4;\n        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->ty0, 4);             /* YT0siz */\n        p_header_data+=4;\n        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_tmp, 2);                 /* Csiz */\n        p_header_data+=2;\n        if (l_tmp < 16385)\n                l_image->numcomps = (OPJ_UINT16) l_tmp;\n        else {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker: number of component is illegal -> %d\\n\", l_tmp);\n                return OPJ_FALSE;\n        }\n\n        if (l_image->numcomps != l_nb_comp) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker: number of component is not compatible with the remaining number of parameters ( %d vs %d)\\n\", l_image->numcomps, l_nb_comp);\n                return OPJ_FALSE;\n        }\n\n        /* testcase 4035.pdf.SIGSEGV.d8b.3375 */\n        /* testcase issue427-null-image-size.jp2 */\n        if ((l_image->x0 >= l_image->x1) || (l_image->y0 >= l_image->y1)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker: negative or zero image size (%\" PRId64 \" x %\" PRId64 \")\\n\", (OPJ_INT64)l_image->x1 - l_image->x0, (OPJ_INT64)l_image->y1 - l_image->y0);\n                return OPJ_FALSE;\n        }\n        /* testcase 2539.pdf.SIGFPE.706.1712 (also 3622.pdf.SIGFPE.706.2916 and 4008.pdf.SIGFPE.706.3345 and maybe more) */\n        if ((l_cp->tdx == 0U) || (l_cp->tdy == 0U)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker: invalid tile size (tdx: %d, tdy: %d)\\n\", l_cp->tdx, l_cp->tdy);\n                return OPJ_FALSE;\n        }\n\n        /* testcase 1610.pdf.SIGSEGV.59c.681 */\n        if ((0xFFFFFFFFU / l_image->x1) < l_image->y1) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Prevent buffer overflow (x1: %d, y1: %d)\\n\", l_image->x1, l_image->y1);\n                return OPJ_FALSE;\n        }\n\n        /* testcase issue427-illegal-tile-offset.jp2 */\n        l_tx1 = opj_uint_adds(l_cp->tx0, l_cp->tdx); /* manage overflow */\n        l_ty1 = opj_uint_adds(l_cp->ty0, l_cp->tdy); /* manage overflow */\n        if ((l_cp->tx0 > l_image->x0) || (l_cp->ty0 > l_image->y0) || (l_tx1 <= l_image->x0) || (l_ty1 <= l_image->y0) ) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error with SIZ marker: illegal tile offset\\n\");\n                return OPJ_FALSE;\n        }\n\n#ifdef USE_JPWL\n        if (l_cp->correct) {\n                /* if JPWL is on, we check whether TX errors have damaged\n                  too much the SIZ parameters */\n                if (!(l_image->x1 * l_image->y1)) {\n                        opj_event_msg(p_manager, EVT_ERROR,\n                                \"JPWL: bad image size (%d x %d)\\n\",\n                                l_image->x1, l_image->y1);\n                        if (!JPWL_ASSUME) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                return OPJ_FALSE;\n                        }\n                }\n\n        /* FIXME check previously in the function so why keep this piece of code ? Need by the norm ?\n                if (l_image->numcomps != ((len - 38) / 3)) {\n                        opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,\n                                \"JPWL: Csiz is %d => space in SIZ only for %d comps.!!!\\n\",\n                                l_image->numcomps, ((len - 38) / 3));\n                        if (!JPWL_ASSUME) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                return OPJ_FALSE;\n                        }\n        */              /* we try to correct */\n        /*              opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust this\\n\");\n                        if (l_image->numcomps < ((len - 38) / 3)) {\n                                len = 38 + 3 * l_image->numcomps;\n                                opj_event_msg(p_manager, EVT_WARNING, \"- setting Lsiz to %d => HYPOTHESIS!!!\\n\",\n                                        len);\n                        } else {\n                                l_image->numcomps = ((len - 38) / 3);\n                                opj_event_msg(p_manager, EVT_WARNING, \"- setting Csiz to %d => HYPOTHESIS!!!\\n\",\n                                        l_image->numcomps);\n                        }\n                }\n        */\n\n                /* update components number in the jpwl_exp_comps filed */\n                l_cp->exp_comps = l_image->numcomps;\n        }\n#endif /* USE_JPWL */\n\n        /* Allocate the resulting image components */\n        l_image->comps = (opj_image_comp_t*) opj_calloc(l_image->numcomps, sizeof(opj_image_comp_t));\n        if (l_image->comps == 00){\n                l_image->numcomps = 0;\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to take in charge SIZ marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        l_img_comp = l_image->comps;\n\n        /* Read the component information */\n        for (i = 0; i < l_image->numcomps; ++i){\n                OPJ_UINT32 tmp;\n                opj_read_bytes(p_header_data,&tmp,1);   /* Ssiz_i */\n                ++p_header_data;\n                l_img_comp->prec = (tmp & 0x7f) + 1;\n                l_img_comp->sgnd = tmp >> 7;\n                opj_read_bytes(p_header_data,&tmp,1);   /* XRsiz_i */\n                ++p_header_data;\n                l_img_comp->dx = (OPJ_UINT32)tmp; /* should be between 1 and 255 */\n                opj_read_bytes(p_header_data,&tmp,1);   /* YRsiz_i */\n                ++p_header_data;\n                l_img_comp->dy = (OPJ_UINT32)tmp; /* should be between 1 and 255 */\n                if( l_img_comp->dx < 1 || l_img_comp->dx > 255 ||\n                    l_img_comp->dy < 1 || l_img_comp->dy > 255 ) {\n                    opj_event_msg(p_manager, EVT_ERROR,\n                                  \"Invalid values for comp = %d : dx=%u dy=%u (should be between 1 and 255 according to the JPEG2000 norm)\\n\",\n                                  i, l_img_comp->dx, l_img_comp->dy);\n                    return OPJ_FALSE;\n                }\n                if( l_img_comp->prec < 1 || l_img_comp->prec > 38) { /* TODO openjpeg won't handle more than ? */\n                    opj_event_msg(p_manager, EVT_ERROR,\n                                  \"Invalid values for comp = %d : prec=%u (should be between 1 and 38 according to the JPEG2000 norm)\\n\",\n                                  i, l_img_comp->prec);\n                    return OPJ_FALSE;\n                }\n\n#ifdef USE_JPWL\n                if (l_cp->correct) {\n                /* if JPWL is on, we check whether TX errors have damaged\n                        too much the SIZ parameters, again */\n                        if (!(l_image->comps[i].dx * l_image->comps[i].dy)) {\n                                opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,\n                                        \"JPWL: bad XRsiz_%d/YRsiz_%d (%d x %d)\\n\",\n                                        i, i, l_image->comps[i].dx, l_image->comps[i].dy);\n                                if (!JPWL_ASSUME) {\n                                        opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                        return OPJ_FALSE;\n                                }\n                                /* we try to correct */\n                                opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust them\\n\");\n                                if (!l_image->comps[i].dx) {\n                                        l_image->comps[i].dx = 1;\n                                        opj_event_msg(p_manager, EVT_WARNING, \"- setting XRsiz_%d to %d => HYPOTHESIS!!!\\n\",\n                                                i, l_image->comps[i].dx);\n                                }\n                                if (!l_image->comps[i].dy) {\n                                        l_image->comps[i].dy = 1;\n                                        opj_event_msg(p_manager, EVT_WARNING, \"- setting YRsiz_%d to %d => HYPOTHESIS!!!\\n\",\n                                                i, l_image->comps[i].dy);\n                                }\n                        }\n                }\n#endif /* USE_JPWL */\n                l_img_comp->resno_decoded = 0;                                                          /* number of resolution decoded */\n                l_img_comp->factor = l_cp->m_specific_param.m_dec.m_reduce; /* reducing factor per component */\n                ++l_img_comp;\n        }\n\n        /* Compute the number of tiles */\n        l_cp->tw = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(l_image->x1 - l_cp->tx0), (OPJ_INT32)l_cp->tdx);\n        l_cp->th = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(l_image->y1 - l_cp->ty0), (OPJ_INT32)l_cp->tdy);\n\n        /* Check that the number of tiles is valid */\n        if (l_cp->tw == 0 || l_cp->th == 0 || l_cp->tw > 65535 / l_cp->th) {\n            opj_event_msg(  p_manager, EVT_ERROR, \n                            \"Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\\n\",\n                            l_cp->tw, l_cp->th);\n            return OPJ_FALSE;\n        }\n        l_nb_tiles = l_cp->tw * l_cp->th;\n\n        /* Define the tiles which will be decoded */\n        if (p_j2k->m_specific_param.m_decoder.m_discard_tiles) {\n                p_j2k->m_specific_param.m_decoder.m_start_tile_x = (p_j2k->m_specific_param.m_decoder.m_start_tile_x - l_cp->tx0) / l_cp->tdx;\n                p_j2k->m_specific_param.m_decoder.m_start_tile_y = (p_j2k->m_specific_param.m_decoder.m_start_tile_y - l_cp->ty0) / l_cp->tdy;\n                p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(p_j2k->m_specific_param.m_decoder.m_end_tile_x - l_cp->tx0), (OPJ_INT32)l_cp->tdx);\n                p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(p_j2k->m_specific_param.m_decoder.m_end_tile_y - l_cp->ty0), (OPJ_INT32)l_cp->tdy);\n        }\n        else {\n                p_j2k->m_specific_param.m_decoder.m_start_tile_x = 0;\n                p_j2k->m_specific_param.m_decoder.m_start_tile_y = 0;\n                p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;\n                p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;\n        }\n\n#ifdef USE_JPWL\n        if (l_cp->correct) {\n                /* if JPWL is on, we check whether TX errors have damaged\n                  too much the SIZ parameters */\n                if ((l_cp->tw < 1) || (l_cp->th < 1) || (l_cp->tw > l_cp->max_tiles) || (l_cp->th > l_cp->max_tiles)) {\n                        opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,\n                                \"JPWL: bad number of tiles (%d x %d)\\n\",\n                                l_cp->tw, l_cp->th);\n                        if (!JPWL_ASSUME) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                return OPJ_FALSE;\n                        }\n                        /* we try to correct */\n                        opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust them\\n\");\n                        if (l_cp->tw < 1) {\n                                l_cp->tw= 1;\n                                opj_event_msg(p_manager, EVT_WARNING, \"- setting %d tiles in x => HYPOTHESIS!!!\\n\",\n                                                l_cp->tw);\n                        }\n                        if (l_cp->tw > l_cp->max_tiles) {\n                                l_cp->tw= 1;\n                                opj_event_msg(p_manager, EVT_WARNING, \"- too large x, increase expectance of %d\\n\"\n                                        \"- setting %d tiles in x => HYPOTHESIS!!!\\n\",\n                                        l_cp->max_tiles, l_cp->tw);\n                        }\n                        if (l_cp->th < 1) {\n                                l_cp->th= 1;\n                                opj_event_msg(p_manager, EVT_WARNING, \"- setting %d tiles in y => HYPOTHESIS!!!\\n\",\n                                                l_cp->th);\n                        }\n                        if (l_cp->th > l_cp->max_tiles) {\n                                l_cp->th= 1;\n                                opj_event_msg(p_manager, EVT_WARNING, \"- too large y, increase expectance of %d to continue\\n\",\n                                        \"- setting %d tiles in y => HYPOTHESIS!!!\\n\",\n                                        l_cp->max_tiles, l_cp->th);\n                        }\n                }\n        }\n#endif /* USE_JPWL */\n\n        /* memory allocations */\n        l_cp->tcps = (opj_tcp_t*) opj_calloc(l_nb_tiles, sizeof(opj_tcp_t));\n        if (l_cp->tcps == 00) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to take in charge SIZ marker\\n\");\n                return OPJ_FALSE;\n        }\n\n#ifdef USE_JPWL\n        if (l_cp->correct) {\n                if (!l_cp->tcps) {\n                        opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,\n                                \"JPWL: could not alloc tcps field of cp\\n\");\n                        if (!JPWL_ASSUME) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                return OPJ_FALSE;\n                        }\n                }\n        }\n#endif /* USE_JPWL */\n\n        p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps =\n                        (opj_tccp_t*) opj_calloc(l_image->numcomps, sizeof(opj_tccp_t));\n        if(p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps  == 00) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to take in charge SIZ marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mct_records =\n                        (opj_mct_data_t*)opj_calloc(OPJ_J2K_MCT_DEFAULT_NB_RECORDS ,sizeof(opj_mct_data_t));\n\n        if (! p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mct_records) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to take in charge SIZ marker\\n\");\n                return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_decoder.m_default_tcp->m_nb_max_mct_records = OPJ_J2K_MCT_DEFAULT_NB_RECORDS;\n\n        p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mcc_records =\n                        (opj_simple_mcc_decorrelation_data_t*)\n                        opj_calloc(OPJ_J2K_MCC_DEFAULT_NB_RECORDS, sizeof(opj_simple_mcc_decorrelation_data_t));\n\n        if (! p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mcc_records) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to take in charge SIZ marker\\n\");\n                return OPJ_FALSE;\n        }\n        p_j2k->m_specific_param.m_decoder.m_default_tcp->m_nb_max_mcc_records = OPJ_J2K_MCC_DEFAULT_NB_RECORDS;\n\n        /* set up default dc level shift */\n        for (i=0;i<l_image->numcomps;++i) {\n                if (! l_image->comps[i].sgnd) {\n                        p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps[i].m_dc_level_shift = 1 << (l_image->comps[i].prec - 1);\n                }\n        }\n\n        l_current_tile_param = l_cp->tcps;\n        for     (i = 0; i < l_nb_tiles; ++i) {\n                l_current_tile_param->tccps = (opj_tccp_t*) opj_calloc(l_image->numcomps, sizeof(opj_tccp_t));\n                if (l_current_tile_param->tccps == 00) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to take in charge SIZ marker\\n\");\n                        return OPJ_FALSE;\n                }\n\n                ++l_current_tile_param;\n        }\n\n        p_j2k->m_specific_param.m_decoder.m_state =  J2K_STATE_MH; /* FIXME J2K_DEC_STATE_MH; */\n        opj_image_comp_header_update(l_image,l_cp);\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_com(     opj_j2k_t *p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager\n                            )\n{\n        OPJ_UINT32 l_comment_size;\n        OPJ_UINT32 l_total_com_size;\n        const OPJ_CHAR *l_comment;\n        OPJ_BYTE * l_current_ptr = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n\n        l_comment = p_j2k->m_cp.comment;\n        l_comment_size = (OPJ_UINT32)strlen(l_comment);\n        l_total_com_size = l_comment_size + 6;\n\n        if (l_total_com_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_total_com_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write the COM marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_total_com_size;\n        }\n\n        l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        opj_write_bytes(l_current_ptr,J2K_MS_COM , 2);  /* COM */\n        l_current_ptr+=2;\n\n        opj_write_bytes(l_current_ptr,l_total_com_size - 2 , 2);        /* L_COM */\n        l_current_ptr+=2;\n\n        opj_write_bytes(l_current_ptr,1 , 2);   /* General use (IS 8859-15:1999 (Latin) values) */\n        l_current_ptr+=2;\n\n        memcpy( l_current_ptr,l_comment,l_comment_size);\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_total_com_size,p_manager) != l_total_com_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a COM marker (comments)\n * @param       p_j2k           the jpeg2000 file codec.\n * @param       p_header_data   the data contained in the COM box.\n * @param       p_header_size   the size of the data contained in the COM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_com (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_header_data != 00);\n  (void)p_header_size;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_cod(     opj_j2k_t *p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager )\n{\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        OPJ_UINT32 l_code_size,l_remaining_size;\n        OPJ_BYTE * l_current_data = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];\n        l_code_size = 9 + opj_j2k_get_SPCod_SPCoc_size(p_j2k,p_j2k->m_current_tile_number,0);\n        l_remaining_size = l_code_size;\n\n        if (l_code_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_code_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write COD marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_code_size;\n        }\n\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        opj_write_bytes(l_current_data,J2K_MS_COD,2);             /* COD */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_code_size-2,2);          /* L_COD */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_tcp->csty,1);            /* Scod */\n        ++l_current_data;\n\n        opj_write_bytes(l_current_data,(OPJ_UINT32)l_tcp->prg,1); /* SGcod (A) */\n        ++l_current_data;\n\n        opj_write_bytes(l_current_data,l_tcp->numlayers,2);       /* SGcod (B) */\n        l_current_data+=2;\n\n        opj_write_bytes(l_current_data,l_tcp->mct,1);             /* SGcod (C) */\n        ++l_current_data;\n\n        l_remaining_size -= 9;\n\n        if (! opj_j2k_write_SPCod_SPCoc(p_j2k,p_j2k->m_current_tile_number,0,l_current_data,&l_remaining_size,p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error writing COD marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (l_remaining_size != 0) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error writing COD marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_code_size,p_manager) != l_code_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a COD marker (Coding Styke defaults)\n * @param       p_header_data   the data contained in the COD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the COD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_cod (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        /* loop */\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_tmp;\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_image_t *l_image = 00;\n\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_image = p_j2k->m_private_image;\n        l_cp = &(p_j2k->m_cp);\n\n        /* If we are in the first tile-part header of the current tile */\n        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?\n                                &l_cp->tcps[p_j2k->m_current_tile_number] :\n                                p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\t\n        /* Only one COD per tile */\n        if (l_tcp->cod) {\n                opj_event_msg(p_manager, EVT_ERROR, \"COD marker already read. No more than one COD marker per tile.\\n\");\n                return OPJ_FALSE;\n        }\n        l_tcp->cod = 1;\n\t\n        /* Make sure room is sufficient */\n        if (p_header_size < 5) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading COD marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(p_header_data,&l_tcp->csty,1);           /* Scod */\n        ++p_header_data;\n        /* Make sure we know how to decode this */\n        if ((l_tcp->csty & ~(OPJ_UINT32)(J2K_CP_CSTY_PRT | J2K_CP_CSTY_SOP | J2K_CP_CSTY_EPH)) != 0U) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Unknown Scod value in COD marker\\n\");\n                return OPJ_FALSE;\n        }\n        opj_read_bytes(p_header_data,&l_tmp,1);                         /* SGcod (A) */\n        ++p_header_data;\n        l_tcp->prg = (OPJ_PROG_ORDER) l_tmp;\n        /* Make sure progression order is valid */\n        if (l_tcp->prg > OPJ_CPRL ) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Unknown progression order in COD marker\\n\");\n                l_tcp->prg = OPJ_PROG_UNKNOWN;\n        }\n        opj_read_bytes(p_header_data,&l_tcp->numlayers,2);      /* SGcod (B) */\n        p_header_data+=2;\n\t\n        if ((l_tcp->numlayers < 1U) || (l_tcp->numlayers > 65535U)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Invalid number of layers in COD marker : %d not in range [1-65535]\\n\", l_tcp->numlayers);\n                return OPJ_FALSE;\n        }\n\n        /* If user didn't set a number layer to decode take the max specify in the codestream. */\n        if      (l_cp->m_specific_param.m_dec.m_layer) {\n                l_tcp->num_layers_to_decode = l_cp->m_specific_param.m_dec.m_layer;\n        }\n        else {\n                l_tcp->num_layers_to_decode = l_tcp->numlayers;\n        }\n\n        opj_read_bytes(p_header_data,&l_tcp->mct,1);            /* SGcod (C) */\n        ++p_header_data;\n\n        p_header_size -= 5;\n        for     (i = 0; i < l_image->numcomps; ++i) {\n                l_tcp->tccps[i].csty = l_tcp->csty & J2K_CCP_CSTY_PRT;\n        }\n\n        if (! opj_j2k_read_SPCod_SPCoc(p_j2k,0,p_header_data,&p_header_size,p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading COD marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (p_header_size != 0) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading COD marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        /* Apply the coding style to other components of the current tile or the m_default_tcp*/\n        opj_j2k_copy_tile_component_parameters(p_j2k);\n\n        /* Index */\n#ifdef WIP_REMOVE_MSD\n        if (p_j2k->cstr_info) {\n                /*opj_codestream_info_t *l_cstr_info = p_j2k->cstr_info;*/\n                p_j2k->cstr_info->prog = l_tcp->prg;\n                p_j2k->cstr_info->numlayers = l_tcp->numlayers;\n                p_j2k->cstr_info->numdecompos = (OPJ_INT32*) opj_malloc(l_image->numcomps * sizeof(OPJ_UINT32));\n\t\t\t\tif(!p_j2k->cstr_info->numdecompos){\n\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t}\n                for     (i = 0; i < l_image->numcomps; ++i) {\n                        p_j2k->cstr_info->numdecompos[i] = l_tcp->tccps[i].numresolutions - 1;\n                }\n        }\n#endif\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_coc( opj_j2k_t *p_j2k,\n                                                OPJ_UINT32 p_comp_no,\n                                                opj_stream_private_t *p_stream,\n                                                opj_event_mgr_t * p_manager )\n{\n        OPJ_UINT32 l_coc_size,l_remaining_size;\n        OPJ_UINT32 l_comp_room;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_comp_room = (p_j2k->m_private_image->numcomps <= 256) ? 1 : 2;\n\n        l_coc_size = 5 + l_comp_room + opj_j2k_get_SPCod_SPCoc_size(p_j2k,p_j2k->m_current_tile_number,p_comp_no);\n\n        if (l_coc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n                OPJ_BYTE *new_header_tile_data;\n                /*p_j2k->m_specific_param.m_encoder.m_header_tile_data\n                        = (OPJ_BYTE*)opj_realloc(\n                                p_j2k->m_specific_param.m_encoder.m_header_tile_data,\n                                l_coc_size);*/\n\n                new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_coc_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write COC marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_coc_size;\n        }\n\n        opj_j2k_write_coc_in_memory(p_j2k,p_comp_no,p_j2k->m_specific_param.m_encoder.m_header_tile_data,&l_remaining_size,p_manager);\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_coc_size,p_manager) != l_coc_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_compare_coc(opj_j2k_t *p_j2k, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no)\n{\n\topj_cp_t *l_cp = NULL;\n\topj_tcp_t *l_tcp = NULL;\n\t\n\t/* preconditions */\n\tassert(p_j2k != 00);\n\t\n\tl_cp = &(p_j2k->m_cp);\n\tl_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];\n\t\n\tif (l_tcp->tccps[p_first_comp_no].csty != l_tcp->tccps[p_second_comp_no].csty) {\n\t\treturn OPJ_FALSE;\n\t}\n\t\n\t\n\treturn opj_j2k_compare_SPCod_SPCoc(p_j2k, p_j2k->m_current_tile_number, p_first_comp_no, p_second_comp_no);\n}\n\nstatic void opj_j2k_write_coc_in_memory(   opj_j2k_t *p_j2k,\n                                                OPJ_UINT32 p_comp_no,\n                                                OPJ_BYTE * p_data,\n                                                OPJ_UINT32 * p_data_written,\n                                                opj_event_mgr_t * p_manager\n                                    )\n{\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        OPJ_UINT32 l_coc_size,l_remaining_size;\n        OPJ_BYTE * l_current_data = 00;\n        opj_image_t *l_image = 00;\n        OPJ_UINT32 l_comp_room;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];\n        l_image = p_j2k->m_private_image;\n        l_comp_room = (l_image->numcomps <= 256) ? 1 : 2;\n\n        l_coc_size = 5 + l_comp_room + opj_j2k_get_SPCod_SPCoc_size(p_j2k,p_j2k->m_current_tile_number,p_comp_no);\n        l_remaining_size = l_coc_size;\n\n        l_current_data = p_data;\n\n        opj_write_bytes(l_current_data,J2K_MS_COC,2);                           /* COC */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_coc_size-2,2);                         /* L_COC */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,p_comp_no, l_comp_room);         /* Ccoc */\n        l_current_data+=l_comp_room;\n\n        opj_write_bytes(l_current_data, l_tcp->tccps[p_comp_no].csty, 1);               /* Scoc */\n        ++l_current_data;\n\n        l_remaining_size -= (5 + l_comp_room);\n        opj_j2k_write_SPCod_SPCoc(p_j2k,p_j2k->m_current_tile_number,0,l_current_data,&l_remaining_size,p_manager);\n        * p_data_written = l_coc_size;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k)\n{\n        OPJ_UINT32 i,j;\n        OPJ_UINT32 l_nb_comp;\n        OPJ_UINT32 l_nb_tiles;\n        OPJ_UINT32 l_max = 0;\n\n        /* preconditions */\n\n        l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th ;\n        l_nb_comp = p_j2k->m_private_image->numcomps;\n\n        for (i=0;i<l_nb_tiles;++i) {\n                for (j=0;j<l_nb_comp;++j) {\n                        l_max = opj_uint_max(l_max,opj_j2k_get_SPCod_SPCoc_size(p_j2k,i,j));\n                }\n        }\n\n        return 6 + l_max;\n}\n\n/**\n * Reads a COC marker (Coding Style Component)\n * @param       p_header_data   the data contained in the COC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the COC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_coc (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        opj_cp_t *l_cp = NULL;\n        opj_tcp_t *l_tcp = NULL;\n        opj_image_t *l_image = NULL;\n        OPJ_UINT32 l_comp_room;\n        OPJ_UINT32 l_comp_no;\n\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ) ? /*FIXME J2K_DEC_STATE_TPH*/\n                                &l_cp->tcps[p_j2k->m_current_tile_number] :\n                                p_j2k->m_specific_param.m_decoder.m_default_tcp;\n        l_image = p_j2k->m_private_image;\n\n        l_comp_room = l_image->numcomps <= 256 ? 1 : 2;\n\n        /* make sure room is sufficient*/\n        if (p_header_size < l_comp_room + 1) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading COC marker\\n\");\n                return OPJ_FALSE;\n        }\n        p_header_size -= l_comp_room + 1;\n\n        opj_read_bytes(p_header_data,&l_comp_no,l_comp_room);                   /* Ccoc */\n        p_header_data += l_comp_room;\n        if (l_comp_no >= l_image->numcomps) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading COC marker (bad number of components)\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(p_header_data,&l_tcp->tccps[l_comp_no].csty,1);                  /* Scoc */\n        ++p_header_data ;\n\n        if (! opj_j2k_read_SPCod_SPCoc(p_j2k,l_comp_no,p_header_data,&p_header_size,p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading COC marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (p_header_size != 0) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading COC marker\\n\");\n                return OPJ_FALSE;\n        }\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_qcd(     opj_j2k_t *p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager\n                            )\n{\n        OPJ_UINT32 l_qcd_size,l_remaining_size;\n        OPJ_BYTE * l_current_data = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_qcd_size = 4 + opj_j2k_get_SQcd_SQcc_size(p_j2k,p_j2k->m_current_tile_number,0);\n        l_remaining_size = l_qcd_size;\n\n        if (l_qcd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_qcd_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write QCD marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_qcd_size;\n        }\n\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        opj_write_bytes(l_current_data,J2K_MS_QCD,2);           /* QCD */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_qcd_size-2,2);         /* L_QCD */\n        l_current_data += 2;\n\n        l_remaining_size -= 4;\n\n        if (! opj_j2k_write_SQcd_SQcc(p_j2k,p_j2k->m_current_tile_number,0,l_current_data,&l_remaining_size,p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error writing QCD marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (l_remaining_size != 0) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error writing QCD marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_qcd_size,p_manager) != l_qcd_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a QCD marker (Quantization defaults)\n * @param       p_header_data   the data contained in the QCD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the QCD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_qcd (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        if (! opj_j2k_read_SQcd_SQcc(p_j2k,0,p_header_data,&p_header_size,p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCD marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (p_header_size != 0) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCD marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        /* Apply the quantization parameters to other components of the current tile or the m_default_tcp */\n        opj_j2k_copy_tile_quantization_parameters(p_j2k);\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_qcc(     opj_j2k_t *p_j2k,\n                                                OPJ_UINT32 p_comp_no,\n                                                opj_stream_private_t *p_stream,\n                                                opj_event_mgr_t * p_manager\n                            )\n{\n        OPJ_UINT32 l_qcc_size,l_remaining_size;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_qcc_size = 5 + opj_j2k_get_SQcd_SQcc_size(p_j2k,p_j2k->m_current_tile_number,p_comp_no);\n        l_qcc_size += p_j2k->m_private_image->numcomps <= 256 ? 0:1;\n        l_remaining_size = l_qcc_size;\n\n        if (l_qcc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_qcc_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write QCC marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_qcc_size;\n        }\n\n        opj_j2k_write_qcc_in_memory(p_j2k,p_comp_no,p_j2k->m_specific_param.m_encoder.m_header_tile_data,&l_remaining_size,p_manager);\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_qcc_size,p_manager) != l_qcc_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_compare_qcc(opj_j2k_t *p_j2k, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no)\n{\n\treturn opj_j2k_compare_SQcd_SQcc(p_j2k,p_j2k->m_current_tile_number,p_first_comp_no, p_second_comp_no);\n}\n\nstatic void opj_j2k_write_qcc_in_memory(   opj_j2k_t *p_j2k,\n                                                                OPJ_UINT32 p_comp_no,\n                                                                OPJ_BYTE * p_data,\n                                                                OPJ_UINT32 * p_data_written,\n                                                                opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_UINT32 l_qcc_size,l_remaining_size;\n        OPJ_BYTE * l_current_data = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_qcc_size = 6 + opj_j2k_get_SQcd_SQcc_size(p_j2k,p_j2k->m_current_tile_number,p_comp_no);\n        l_remaining_size = l_qcc_size;\n\n        l_current_data = p_data;\n\n        opj_write_bytes(l_current_data,J2K_MS_QCC,2);           /* QCC */\n        l_current_data += 2;\n\n        if (p_j2k->m_private_image->numcomps <= 256) {\n                --l_qcc_size;\n\n                opj_write_bytes(l_current_data,l_qcc_size-2,2);         /* L_QCC */\n                l_current_data += 2;\n\n                opj_write_bytes(l_current_data, p_comp_no, 1);  /* Cqcc */\n                ++l_current_data;\n\n                /* in the case only one byte is sufficient the last byte allocated is useless -> still do -6 for available */\n                l_remaining_size -= 6;\n        }\n        else {\n                opj_write_bytes(l_current_data,l_qcc_size-2,2);         /* L_QCC */\n                l_current_data += 2;\n\n                opj_write_bytes(l_current_data, p_comp_no, 2);  /* Cqcc */\n                l_current_data+=2;\n\n                l_remaining_size -= 6;\n        }\n\n        opj_j2k_write_SQcd_SQcc(p_j2k,p_j2k->m_current_tile_number,p_comp_no,l_current_data,&l_remaining_size,p_manager);\n\n        *p_data_written = l_qcc_size;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_max_qcc_size (opj_j2k_t *p_j2k)\n{\n        return opj_j2k_get_max_coc_size(p_j2k);\n}\n\n/**\n * Reads a QCC marker (Quantization component)\n * @param       p_header_data   the data contained in the QCC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the QCC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_qcc(   opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_UINT32 l_num_comp,l_comp_no;\n\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_num_comp = p_j2k->m_private_image->numcomps;\n\n        if (l_num_comp <= 256) {\n                if (p_header_size < 1) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCC marker\\n\");\n                        return OPJ_FALSE;\n                }\n                opj_read_bytes(p_header_data,&l_comp_no,1);\n                ++p_header_data;\n                --p_header_size;\n        }\n        else {\n                if (p_header_size < 2) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCC marker\\n\");\n                        return OPJ_FALSE;\n                }\n                opj_read_bytes(p_header_data,&l_comp_no,2);\n                p_header_data+=2;\n                p_header_size-=2;\n        }\n\n#ifdef USE_JPWL\n        if (p_j2k->m_cp.correct) {\n\n                static OPJ_UINT32 backup_compno = 0;\n\n                /* compno is negative or larger than the number of components!!! */\n                if (/*(l_comp_no < 0) ||*/ (l_comp_no >= l_num_comp)) {\n                        opj_event_msg(p_manager, EVT_ERROR,\n                                \"JPWL: bad component number in QCC (%d out of a maximum of %d)\\n\",\n                                l_comp_no, l_num_comp);\n                        if (!JPWL_ASSUME) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                return OPJ_FALSE;\n                        }\n                        /* we try to correct */\n                        l_comp_no = backup_compno % l_num_comp;\n                        opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust this\\n\"\n                                \"- setting component number to %d\\n\",\n                                l_comp_no);\n                }\n\n                /* keep your private count of tiles */\n                backup_compno++;\n        };\n#endif /* USE_JPWL */\n\n        if (l_comp_no >= p_j2k->m_private_image->numcomps) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Invalid component number: %d, regarding the number of components %d\\n\",\n                              l_comp_no, p_j2k->m_private_image->numcomps);\n                return OPJ_FALSE;\n        }\n\n        if (! opj_j2k_read_SQcd_SQcc(p_j2k,l_comp_no,p_header_data,&p_header_size,p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCC marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (p_header_size != 0) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading QCC marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_poc(     opj_j2k_t *p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager\n                            )\n{\n        OPJ_UINT32 l_nb_comp;\n        OPJ_UINT32 l_nb_poc;\n        OPJ_UINT32 l_poc_size;\n        OPJ_UINT32 l_written_size = 0;\n        opj_tcp_t *l_tcp = 00;\n        OPJ_UINT32 l_poc_room;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_tcp = &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number];\n        l_nb_comp = p_j2k->m_private_image->numcomps;\n        l_nb_poc = 1 + l_tcp->numpocs;\n\n        if (l_nb_comp <= 256) {\n                l_poc_room = 1;\n        }\n        else {\n                l_poc_room = 2;\n        }\n        l_poc_size = 4 + (5 + 2 * l_poc_room) * l_nb_poc;\n\n        if (l_poc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_poc_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write POC marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_poc_size;\n        }\n\n        opj_j2k_write_poc_in_memory(p_j2k,p_j2k->m_specific_param.m_encoder.m_header_tile_data,&l_written_size,p_manager);\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_poc_size,p_manager) != l_poc_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic void opj_j2k_write_poc_in_memory(   opj_j2k_t *p_j2k,\n                                                                OPJ_BYTE * p_data,\n                                                                OPJ_UINT32 * p_data_written,\n                                                                opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_UINT32 i;\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_nb_comp;\n        OPJ_UINT32 l_nb_poc;\n        OPJ_UINT32 l_poc_size;\n        opj_image_t *l_image = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_tccp_t *l_tccp = 00;\n        opj_poc_t *l_current_poc = 00;\n        OPJ_UINT32 l_poc_room;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_tcp = &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number];\n        l_tccp = &l_tcp->tccps[0];\n        l_image = p_j2k->m_private_image;\n        l_nb_comp = l_image->numcomps;\n        l_nb_poc = 1 + l_tcp->numpocs;\n\n        if (l_nb_comp <= 256) {\n                l_poc_room = 1;\n        }\n        else {\n                l_poc_room = 2;\n        }\n\n        l_poc_size = 4 + (5 + 2 * l_poc_room) * l_nb_poc;\n\n        l_current_data = p_data;\n\n        opj_write_bytes(l_current_data,J2K_MS_POC,2);                                   /* POC  */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_poc_size-2,2);                                 /* Lpoc */\n        l_current_data += 2;\n\n        l_current_poc =  l_tcp->pocs;\n        for (i = 0; i < l_nb_poc; ++i) {\n                opj_write_bytes(l_current_data,l_current_poc->resno0,1);                                /* RSpoc_i */\n                ++l_current_data;\n\n                opj_write_bytes(l_current_data,l_current_poc->compno0,l_poc_room);              /* CSpoc_i */\n                l_current_data+=l_poc_room;\n\n                opj_write_bytes(l_current_data,l_current_poc->layno1,2);                                /* LYEpoc_i */\n                l_current_data+=2;\n\n                opj_write_bytes(l_current_data,l_current_poc->resno1,1);                                /* REpoc_i */\n                ++l_current_data;\n\n                opj_write_bytes(l_current_data,l_current_poc->compno1,l_poc_room);              /* CEpoc_i */\n                l_current_data+=l_poc_room;\n\n                opj_write_bytes(l_current_data, (OPJ_UINT32)l_current_poc->prg,1);    /* Ppoc_i */\n                ++l_current_data;\n\n                /* change the value of the max layer according to the actual number of layers in the file, components and resolutions*/\n                l_current_poc->layno1 = (OPJ_UINT32)opj_int_min((OPJ_INT32)l_current_poc->layno1, (OPJ_INT32)l_tcp->numlayers);\n                l_current_poc->resno1 = (OPJ_UINT32)opj_int_min((OPJ_INT32)l_current_poc->resno1, (OPJ_INT32)l_tccp->numresolutions);\n                l_current_poc->compno1 = (OPJ_UINT32)opj_int_min((OPJ_INT32)l_current_poc->compno1, (OPJ_INT32)l_nb_comp);\n\n                ++l_current_poc;\n        }\n\n        *p_data_written = l_poc_size;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k)\n{\n        opj_tcp_t * l_tcp = 00;\n        OPJ_UINT32 l_nb_tiles = 0;\n        OPJ_UINT32 l_max_poc = 0;\n        OPJ_UINT32 i;\n\n        l_tcp = p_j2k->m_cp.tcps;\n        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n\n        for (i=0;i<l_nb_tiles;++i) {\n                l_max_poc = opj_uint_max(l_max_poc,l_tcp->numpocs);\n                ++l_tcp;\n        }\n\n        ++l_max_poc;\n\n        return 4 + 9 * l_max_poc;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_max_toc_size (opj_j2k_t *p_j2k)\n{\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_nb_tiles;\n        OPJ_UINT32 l_max = 0;\n        opj_tcp_t * l_tcp = 00;\n\n        l_tcp = p_j2k->m_cp.tcps;\n        l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th ;\n\n        for (i=0;i<l_nb_tiles;++i) {\n                l_max = opj_uint_max(l_max,l_tcp->m_nb_tile_parts);\n\n                ++l_tcp;\n        }\n\n        return 12 * l_max;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k)\n{\n        OPJ_UINT32 l_nb_bytes = 0;\n        OPJ_UINT32 l_nb_comps;\n        OPJ_UINT32 l_coc_bytes,l_qcc_bytes;\n\n        l_nb_comps = p_j2k->m_private_image->numcomps - 1;\n        l_nb_bytes += opj_j2k_get_max_toc_size(p_j2k);\n\n        if (!(OPJ_IS_CINEMA(p_j2k->m_cp.rsiz))) {\n                l_coc_bytes = opj_j2k_get_max_coc_size(p_j2k);\n                l_nb_bytes += l_nb_comps * l_coc_bytes;\n\n                l_qcc_bytes = opj_j2k_get_max_qcc_size(p_j2k);\n                l_nb_bytes += l_nb_comps * l_qcc_bytes;\n        }\n\n        l_nb_bytes += opj_j2k_get_max_poc_size(p_j2k);\n\n        /*** DEVELOPER CORNER, Add room for your headers ***/\n\n        return l_nb_bytes;\n}\n\n/**\n * Reads a POC marker (Progression Order Change)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_poc (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_UINT32 i, l_nb_comp, l_tmp;\n        opj_image_t * l_image = 00;\n        OPJ_UINT32 l_old_poc_nb, l_current_poc_nb, l_current_poc_remaining;\n        OPJ_UINT32 l_chunk_size, l_comp_room;\n\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_poc_t *l_current_poc = 00;\n\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_image = p_j2k->m_private_image;\n        l_nb_comp = l_image->numcomps;\n        if (l_nb_comp <= 256) {\n                l_comp_room = 1;\n        }\n        else {\n                l_comp_room = 2;\n        }\n        l_chunk_size = 5 + 2 * l_comp_room;\n        l_current_poc_nb = p_header_size / l_chunk_size;\n        l_current_poc_remaining = p_header_size % l_chunk_size;\n\n        if ((l_current_poc_nb <= 0) || (l_current_poc_remaining != 0)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading POC marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?\n                                &l_cp->tcps[p_j2k->m_current_tile_number] :\n                                p_j2k->m_specific_param.m_decoder.m_default_tcp;\n        l_old_poc_nb = l_tcp->POC ? l_tcp->numpocs + 1 : 0;\n        l_current_poc_nb += l_old_poc_nb;\n\n        if(l_current_poc_nb >= 32)\n          {\n          opj_event_msg(p_manager, EVT_ERROR, \"Too many POCs %d\\n\", l_current_poc_nb);\n          return OPJ_FALSE;\n          }\n        assert(l_current_poc_nb < 32);\n\n        /* now poc is in use.*/\n        l_tcp->POC = 1;\n\n        l_current_poc = &l_tcp->pocs[l_old_poc_nb];\n        for     (i = l_old_poc_nb; i < l_current_poc_nb; ++i) {\n                opj_read_bytes(p_header_data,&(l_current_poc->resno0),1);                               /* RSpoc_i */\n                ++p_header_data;\n                opj_read_bytes(p_header_data,&(l_current_poc->compno0),l_comp_room);    /* CSpoc_i */\n                p_header_data+=l_comp_room;\n                opj_read_bytes(p_header_data,&(l_current_poc->layno1),2);                               /* LYEpoc_i */\n                /* make sure layer end is in acceptable bounds */\n                l_current_poc->layno1 = opj_uint_min(l_current_poc->layno1, l_tcp->numlayers);\n                p_header_data+=2;\n                opj_read_bytes(p_header_data,&(l_current_poc->resno1),1);                               /* REpoc_i */\n                ++p_header_data;\n                opj_read_bytes(p_header_data,&(l_current_poc->compno1),l_comp_room);    /* CEpoc_i */\n                p_header_data+=l_comp_room;\n                opj_read_bytes(p_header_data,&l_tmp,1);                                                                 /* Ppoc_i */\n                ++p_header_data;\n                l_current_poc->prg = (OPJ_PROG_ORDER) l_tmp;\n                /* make sure comp is in acceptable bounds */\n                l_current_poc->compno1 = opj_uint_min(l_current_poc->compno1, l_nb_comp);\n                ++l_current_poc;\n        }\n\n        l_tcp->numpocs = l_current_poc_nb - 1;\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a CRG marker (Component registration)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_crg (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_UINT32 l_nb_comp;\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_nb_comp = p_j2k->m_private_image->numcomps;\n\n        if (p_header_size != l_nb_comp *4) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading CRG marker\\n\");\n                return OPJ_FALSE;\n        }\n        /* Do not care of this at the moment since only local variables are set here */\n        /*\n        for\n                (i = 0; i < l_nb_comp; ++i)\n        {\n                opj_read_bytes(p_header_data,&l_Xcrg_i,2);                              // Xcrg_i\n                p_header_data+=2;\n                opj_read_bytes(p_header_data,&l_Ycrg_i,2);                              // Xcrg_i\n                p_header_data+=2;\n        }\n        */\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a TLM marker (Tile Length Marker)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_tlm (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_UINT32 l_Ztlm, l_Stlm, l_ST, l_SP, l_tot_num_tp_remaining, l_quotient, l_Ptlm_size;\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        if (p_header_size < 2) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading TLM marker\\n\");\n                return OPJ_FALSE;\n        }\n        p_header_size -= 2;\n\n        opj_read_bytes(p_header_data,&l_Ztlm,1);                                /* Ztlm */\n        ++p_header_data;\n        opj_read_bytes(p_header_data,&l_Stlm,1);                                /* Stlm */\n        ++p_header_data;\n\n        l_ST = ((l_Stlm >> 4) & 0x3);\n        l_SP = (l_Stlm >> 6) & 0x1;\n\n        l_Ptlm_size = (l_SP + 1) * 2;\n        l_quotient = l_Ptlm_size + l_ST;\n\n        l_tot_num_tp_remaining = p_header_size % l_quotient;\n\n        if (l_tot_num_tp_remaining != 0) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading TLM marker\\n\");\n                return OPJ_FALSE;\n        }\n        /* FIXME Do not care of this at the moment since only local variables are set here */\n        /*\n        for\n                (i = 0; i < l_tot_num_tp; ++i)\n        {\n                opj_read_bytes(p_header_data,&l_Ttlm_i,l_ST);                           // Ttlm_i\n                p_header_data += l_ST;\n                opj_read_bytes(p_header_data,&l_Ptlm_i,l_Ptlm_size);            // Ptlm_i\n                p_header_data += l_Ptlm_size;\n        }*/\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a PLM marker (Packet length, main header marker)\n *\n * @param       p_header_data   the data contained in the TLM box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the TLM marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_plm (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        if (p_header_size < 1) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading PLM marker\\n\");\n                return OPJ_FALSE;\n        }\n        /* Do not care of this at the moment since only local variables are set here */\n        /*\n        opj_read_bytes(p_header_data,&l_Zplm,1);                                        // Zplm\n        ++p_header_data;\n        --p_header_size;\n\n        while\n                (p_header_size > 0)\n        {\n                opj_read_bytes(p_header_data,&l_Nplm,1);                                // Nplm\n                ++p_header_data;\n                p_header_size -= (1+l_Nplm);\n                if\n                        (p_header_size < 0)\n                {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error reading PLM marker\\n\");\n                        return false;\n                }\n                for\n                        (i = 0; i < l_Nplm; ++i)\n                {\n                        opj_read_bytes(p_header_data,&l_tmp,1);                         // Iplm_ij\n                        ++p_header_data;\n                        // take only the last seven bytes\n                        l_packet_len |= (l_tmp & 0x7f);\n                        if\n                                (l_tmp & 0x80)\n                        {\n                                l_packet_len <<= 7;\n                        }\n                        else\n                        {\n                // store packet length and proceed to next packet\n                                l_packet_len = 0;\n                        }\n                }\n                if\n                        (l_packet_len != 0)\n                {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error reading PLM marker\\n\");\n                        return false;\n                }\n        }\n        */\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a PLT marker (Packet length, tile-part header)\n *\n * @param       p_header_data   the data contained in the PLT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the PLT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_plt (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_UINT32 l_Zplt, l_tmp, l_packet_len = 0, i;\n\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        if (p_header_size < 1) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading PLT marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(p_header_data,&l_Zplt,1);                /* Zplt */\n        ++p_header_data;\n        --p_header_size;\n\n        for (i = 0; i < p_header_size; ++i) {\n                opj_read_bytes(p_header_data,&l_tmp,1);         /* Iplt_ij */\n                ++p_header_data;\n                /* take only the last seven bytes */\n                l_packet_len |= (l_tmp & 0x7f);\n                if (l_tmp & 0x80) {\n                        l_packet_len <<= 7;\n                }\n                else {\n            /* store packet length and proceed to next packet */\n                        l_packet_len = 0;\n                }\n        }\n\n        if (l_packet_len != 0) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading PLT marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a PPM marker (Packed packet headers, main header)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n */\n\nstatic OPJ_BOOL opj_j2k_read_ppm (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\topj_j2k_t *p_j2k,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tOPJ_BYTE * p_header_data,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tOPJ_UINT32 p_header_size,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\topj_event_mgr_t * p_manager )\n{\n\topj_cp_t *l_cp = 00;\n\tOPJ_UINT32 l_Z_ppm;\n\t\n\t/* preconditions */\n\tassert(p_header_data != 00);\n\tassert(p_j2k != 00);\n\tassert(p_manager != 00);\n\t\n\t/* We need to have the Z_ppm element + 1 byte of Nppm/Ippm at minimum */\n\tif (p_header_size < 2) {\n\t\topj_event_msg(p_manager, EVT_ERROR, \"Error reading PPM marker\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\t\n\tl_cp = &(p_j2k->m_cp);\n\tl_cp->ppm = 1;\n\t\n\topj_read_bytes(p_header_data,&l_Z_ppm,1);               /* Z_ppm */\n\t++p_header_data;\n\t--p_header_size;\n\t\n\t/* check allocation needed */\n\tif (l_cp->ppm_markers == NULL) { /* first PPM marker */\n\t\tOPJ_UINT32 l_newCount = l_Z_ppm + 1U; /* can't overflow, l_Z_ppm is UINT8 */\n\t\tassert(l_cp->ppm_markers_count == 0U);\n\t\t\n\t\tl_cp->ppm_markers = (opj_ppx *) opj_calloc(l_newCount, sizeof(opj_ppx));\n\t\tif (l_cp->ppm_markers == NULL) {\n\t\t\topj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPM marker\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_cp->ppm_markers_count = l_newCount;\n\t} else if (l_cp->ppm_markers_count <= l_Z_ppm) {\n\t\tOPJ_UINT32 l_newCount = l_Z_ppm + 1U; /* can't overflow, l_Z_ppm is UINT8 */\n\t\topj_ppx *new_ppm_markers;\n\t\tnew_ppm_markers = (opj_ppx *) opj_realloc(l_cp->ppm_markers, l_newCount * sizeof(opj_ppx));\n\t\tif (new_ppm_markers == NULL) {\n\t\t\t/* clean up to be done on l_cp destruction */\n\t\t\topj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPM marker\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_cp->ppm_markers = new_ppm_markers;\n\t\tmemset(l_cp->ppm_markers + l_cp->ppm_markers_count, 0, (l_newCount - l_cp->ppm_markers_count) * sizeof(opj_ppx));\n\t\tl_cp->ppm_markers_count = l_newCount;\n\t}\n\t\n\tif (l_cp->ppm_markers[l_Z_ppm].m_data != NULL) {\n\t\t/* clean up to be done on l_cp destruction */\n\t\topj_event_msg(p_manager, EVT_ERROR, \"Zppm %u already read\\n\", l_Z_ppm);\n\t\treturn OPJ_FALSE;\n\t}\n\t\n\tl_cp->ppm_markers[l_Z_ppm].m_data = (OPJ_BYTE *) opj_malloc(p_header_size);\n\tif (l_cp->ppm_markers[l_Z_ppm].m_data == NULL) {\n\t\t/* clean up to be done on l_cp destruction */\n\t\topj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPM marker\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\tl_cp->ppm_markers[l_Z_ppm].m_data_size = p_header_size;\n\tmemcpy(l_cp->ppm_markers[l_Z_ppm].m_data, p_header_data, p_header_size);\n\n\treturn OPJ_TRUE;\n}\n\n/**\n * Merges all PPM markers read (Packed headers, main header)\n *\n * @param       p_cp      main coding parameters.\n * @param       p_manager the user event manager.\n */\nstatic OPJ_BOOL opj_j2k_merge_ppm ( opj_cp_t *p_cp, opj_event_mgr_t * p_manager )\n{\n\tOPJ_UINT32 i, l_ppm_data_size, l_N_ppm_remaining;\n\t\n\t/* preconditions */\n\tassert(p_cp != 00);\n\tassert(p_manager != 00);\n\tassert(p_cp->ppm_buffer == NULL);\n\t\n\tif (p_cp->ppm == 0U) {\n\t\treturn OPJ_TRUE;\n\t}\n\t\n\tl_ppm_data_size = 0U;\n\tl_N_ppm_remaining = 0U;\n\tfor (i = 0U; i < p_cp->ppm_markers_count; ++i) {\n\t\tif (p_cp->ppm_markers[i].m_data != NULL) { /* standard doesn't seem to require contiguous Zppm */\n\t\t\tOPJ_UINT32 l_N_ppm;\n\t\t\tOPJ_UINT32 l_data_size = p_cp->ppm_markers[i].m_data_size;\n\t\t\tconst OPJ_BYTE* l_data = p_cp->ppm_markers[i].m_data;\n\t\t\t\n\t\t\tif (l_N_ppm_remaining >= l_data_size) {\n\t\t\t\tl_N_ppm_remaining -= l_data_size;\n\t\t\t\tl_data_size = 0U;\n\t\t\t} else {\n\t\t\t\tl_data += l_N_ppm_remaining;\n\t\t\t\tl_data_size -= l_N_ppm_remaining;\n\t\t\t\tl_N_ppm_remaining = 0U;\n\t\t\t}\n\t\t\t\n\t\t\tif (l_data_size > 0U) {\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\t/* read Nppm */\n\t\t\t\t\tif (l_data_size < 4U) {\n\t\t\t\t\t\t/* clean up to be done on l_cp destruction */\n\t\t\t\t\t\topj_event_msg(p_manager, EVT_ERROR, \"Not enough bytes to read Nppm\\n\");\n\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\topj_read_bytes(l_data, &l_N_ppm, 4);\n\t\t\t\t\tl_data+=4;\n\t\t\t\t\tl_data_size-=4;\n\t\t\t\t\tl_ppm_data_size += l_N_ppm; /* can't overflow, max 256 markers of max 65536 bytes, that is when PPM markers are not corrupted which is checked elsewhere */\n\t\t\t\t\t\n\t\t\t\t\tif (l_data_size >= l_N_ppm) {\n\t\t\t\t\t\tl_data_size -= l_N_ppm;\n\t\t\t\t\t\tl_data += l_N_ppm;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tl_N_ppm_remaining = l_N_ppm - l_data_size;\n\t\t\t\t\t\tl_data_size = 0U;\n\t\t\t\t\t}\n\t\t\t\t} while (l_data_size > 0U);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (l_N_ppm_remaining != 0U) {\n\t\t/* clean up to be done on l_cp destruction */\n\t\topj_event_msg(p_manager, EVT_ERROR, \"Corrupted PPM markers\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\t\n\tp_cp->ppm_buffer = (OPJ_BYTE *) opj_malloc(l_ppm_data_size);\n\tif (p_cp->ppm_buffer == 00) {\n\t\topj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPM marker\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\tp_cp->ppm_len = l_ppm_data_size;\n\tl_ppm_data_size = 0U;\n\tl_N_ppm_remaining = 0U;\n\tfor (i = 0U; i < p_cp->ppm_markers_count; ++i) {\n\t\tif (p_cp->ppm_markers[i].m_data != NULL) { /* standard doesn't seem to require contiguous Zppm */\n\t\t\tOPJ_UINT32 l_N_ppm;\n\t\t\tOPJ_UINT32 l_data_size = p_cp->ppm_markers[i].m_data_size;\n\t\t\tconst OPJ_BYTE* l_data = p_cp->ppm_markers[i].m_data;\n\t\t\t\n\t\t\tif (l_N_ppm_remaining >= l_data_size) {\n\t\t\t\tmemcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data, l_data_size);\n\t\t\t\tl_ppm_data_size += l_data_size;\n\t\t\t\tl_N_ppm_remaining -= l_data_size;\n\t\t\t\tl_data_size = 0U;\n\t\t\t} else {\n\t\t\t\tmemcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data, l_N_ppm_remaining);\n\t\t\t\tl_ppm_data_size += l_N_ppm_remaining;\n\t\t\t\tl_data += l_N_ppm_remaining;\n\t\t\t\tl_data_size -= l_N_ppm_remaining;\n\t\t\t\tl_N_ppm_remaining = 0U;\n\t\t\t}\n\n\t\t\tif (l_data_size > 0U) {\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\t/* read Nppm */\n\t\t\t\t\tif (l_data_size < 4U) {\n\t\t\t\t\t\t/* clean up to be done on l_cp destruction */\n\t\t\t\t\t\topj_event_msg(p_manager, EVT_ERROR, \"Not enough bytes to read Nppm\\n\");\n\t\t\t\t\t\treturn OPJ_FALSE;\n\t\t\t\t\t}\n\t\t\t\t\topj_read_bytes(l_data, &l_N_ppm, 4);\n\t\t\t\t\tl_data+=4;\n\t\t\t\t\tl_data_size-=4;\n\t\t\t\t\t\n\t\t\t\t\tif (l_data_size >= l_N_ppm) {\n\t\t\t\t\t\tmemcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data, l_N_ppm);\n\t\t\t\t\t\tl_ppm_data_size += l_N_ppm;\n\t\t\t\t\t\tl_data_size -= l_N_ppm;\n\t\t\t\t\t\tl_data += l_N_ppm;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmemcpy(p_cp->ppm_buffer + l_ppm_data_size, l_data, l_data_size);\n\t\t\t\t\t\tl_ppm_data_size += l_data_size;\n\t\t\t\t\t\tl_N_ppm_remaining = l_N_ppm - l_data_size;\n\t\t\t\t\t\tl_data_size = 0U;\n\t\t\t\t\t}\n\t\t\t\t} while (l_data_size > 0U);\n\t\t\t}\n\t\t\topj_free(p_cp->ppm_markers[i].m_data);\n\t\t\tp_cp->ppm_markers[i].m_data = NULL;\n\t\t\tp_cp->ppm_markers[i].m_data_size = 0U;\n\t\t}\n\t}\n\t\n\tp_cp->ppm_data = p_cp->ppm_buffer;\n\tp_cp->ppm_data_size = p_cp->ppm_len;\n\t\n\tp_cp->ppm_markers_count = 0U;\n\topj_free(p_cp->ppm_markers);\n\tp_cp->ppm_markers = NULL;\n\t\n\treturn OPJ_TRUE;\n}\n\n/**\n * Reads a PPT marker (Packed packet headers, tile-part header)\n *\n * @param       p_header_data   the data contained in the PPT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the PPT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_ppt (  opj_j2k_t *p_j2k,\n                                    OPJ_BYTE * p_header_data,\n                                    OPJ_UINT32 p_header_size,\n                                    opj_event_mgr_t * p_manager\n                                    )\n{\n\topj_cp_t *l_cp = 00;\n\topj_tcp_t *l_tcp = 00;\n\tOPJ_UINT32 l_Z_ppt;\n\n\t/* preconditions */\n\tassert(p_header_data != 00);\n\tassert(p_j2k != 00);\n\tassert(p_manager != 00);\n\n\t/* We need to have the Z_ppt element + 1 byte of Ippt at minimum */\n\tif (p_header_size < 2) {\n\t\topj_event_msg(p_manager, EVT_ERROR, \"Error reading PPT marker\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\n\tl_cp = &(p_j2k->m_cp);\n\tif (l_cp->ppm){\n\t\topj_event_msg(p_manager, EVT_ERROR, \"Error reading PPT marker: packet header have been previously found in the main header (PPM marker).\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\n\tl_tcp = &(l_cp->tcps[p_j2k->m_current_tile_number]);\n\tl_tcp->ppt = 1;\n\n\topj_read_bytes(p_header_data,&l_Z_ppt,1);               /* Z_ppt */\n\t++p_header_data;\n\t--p_header_size;\n\t\n\t/* check allocation needed */\n\tif (l_tcp->ppt_markers == NULL) { /* first PPT marker */\n\t\tOPJ_UINT32 l_newCount = l_Z_ppt + 1U; /* can't overflow, l_Z_ppt is UINT8 */\n\t\tassert(l_tcp->ppt_markers_count == 0U);\n\t\t\n\t\tl_tcp->ppt_markers = (opj_ppx *) opj_calloc(l_newCount, sizeof(opj_ppx));\n\t\tif (l_tcp->ppt_markers == NULL) {\n\t\t\topj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPT marker\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_tcp->ppt_markers_count = l_newCount;\n\t} else if (l_tcp->ppt_markers_count <= l_Z_ppt) {\n\t\tOPJ_UINT32 l_newCount = l_Z_ppt + 1U; /* can't overflow, l_Z_ppt is UINT8 */\n\t\topj_ppx *new_ppt_markers;\n\t\tnew_ppt_markers = (opj_ppx *) opj_realloc(l_tcp->ppt_markers, l_newCount * sizeof(opj_ppx));\n\t\tif (new_ppt_markers == NULL) {\n\t\t\t/* clean up to be done on l_tcp destruction */\n\t\t\topj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPT marker\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_tcp->ppt_markers = new_ppt_markers;\n\t\tmemset(l_tcp->ppt_markers + l_tcp->ppt_markers_count, 0, (l_newCount - l_tcp->ppt_markers_count) * sizeof(opj_ppx));\n\t\tl_tcp->ppt_markers_count = l_newCount;\n\t}\n\t\n\tif (l_tcp->ppt_markers[l_Z_ppt].m_data != NULL) {\n\t\t/* clean up to be done on l_tcp destruction */\n\t\topj_event_msg(p_manager, EVT_ERROR, \"Zppt %u already read\\n\", l_Z_ppt);\n\t\treturn OPJ_FALSE;\n\t}\n\t\n\tl_tcp->ppt_markers[l_Z_ppt].m_data = (OPJ_BYTE *) opj_malloc(p_header_size);\n\tif (l_tcp->ppt_markers[l_Z_ppt].m_data == NULL) {\n\t\t/* clean up to be done on l_tcp destruction */\n\t\topj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPT marker\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\tl_tcp->ppt_markers[l_Z_ppt].m_data_size = p_header_size;\n\tmemcpy(l_tcp->ppt_markers[l_Z_ppt].m_data, p_header_data, p_header_size);\n\treturn OPJ_TRUE;\n}\n\n/**\n * Merges all PPT markers read (Packed packet headers, tile-part header)\n *\n * @param       p_tcp   the tile.\n * @param       p_manager               the user event manager.\n */\nstatic OPJ_BOOL opj_j2k_merge_ppt(opj_tcp_t *p_tcp, opj_event_mgr_t * p_manager)\n{\n\tOPJ_UINT32 i, l_ppt_data_size;\n\t/* preconditions */\n\tassert(p_tcp != 00);\n\tassert(p_manager != 00);\n\tassert(p_tcp->ppt_buffer == NULL);\n\t\n\tif (p_tcp->ppt == 0U) {\n\t\treturn OPJ_TRUE;\n\t}\n\t\n\tl_ppt_data_size = 0U;\n\tfor (i = 0U; i < p_tcp->ppt_markers_count; ++i) {\n\t\tl_ppt_data_size += p_tcp->ppt_markers[i].m_data_size; /* can't overflow, max 256 markers of max 65536 bytes */\n\t}\n\t\n\tp_tcp->ppt_buffer = (OPJ_BYTE *) opj_malloc(l_ppt_data_size);\n\tif (p_tcp->ppt_buffer == 00) {\n\t\topj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read PPT marker\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\tp_tcp->ppt_len = l_ppt_data_size;\n\tl_ppt_data_size = 0U;\n\tfor (i = 0U; i < p_tcp->ppt_markers_count; ++i) {\n\t\tif (p_tcp->ppt_markers[i].m_data != NULL) { /* standard doesn't seem to require contiguous Zppt */\n\t\t\tmemcpy(p_tcp->ppt_buffer + l_ppt_data_size, p_tcp->ppt_markers[i].m_data, p_tcp->ppt_markers[i].m_data_size);\n\t\t\tl_ppt_data_size += p_tcp->ppt_markers[i].m_data_size; /* can't overflow, max 256 markers of max 65536 bytes */\n\t\t\t\n\t\t\topj_free(p_tcp->ppt_markers[i].m_data);\n\t\t\tp_tcp->ppt_markers[i].m_data = NULL;\n\t\t\tp_tcp->ppt_markers[i].m_data_size = 0U;\n\t\t}\n\t}\n\t\n\tp_tcp->ppt_markers_count = 0U;\n\topj_free(p_tcp->ppt_markers);\n\tp_tcp->ppt_markers = NULL;\n\t\n\tp_tcp->ppt_data = p_tcp->ppt_buffer;\n\tp_tcp->ppt_data_size = p_tcp->ppt_len;\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_tlm(     opj_j2k_t *p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager\n                            )\n{\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_tlm_size;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_tlm_size = 6 + (5*p_j2k->m_specific_param.m_encoder.m_total_tile_parts);\n\n        if (l_tlm_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_tlm_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write TLM marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_tlm_size;\n        }\n\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        /* change the way data is written to avoid seeking if possible */\n        /* TODO */\n        p_j2k->m_specific_param.m_encoder.m_tlm_start = opj_stream_tell(p_stream);\n\n        opj_write_bytes(l_current_data,J2K_MS_TLM,2);                                   /* TLM */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_tlm_size-2,2);                                 /* Lpoc */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,0,1);                                                    /* Ztlm=0*/\n        ++l_current_data;\n\n        opj_write_bytes(l_current_data,0x50,1);                                                 /* Stlm ST=1(8bits-255 tiles max),SP=1(Ptlm=32bits) */\n        ++l_current_data;\n\n        /* do nothing on the 5 * l_j2k->m_specific_param.m_encoder.m_total_tile_parts remaining data */\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_tlm_size,p_manager) != l_tlm_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_sot(     opj_j2k_t *p_j2k,\n                                                        OPJ_BYTE * p_data,\n                                                        OPJ_UINT32 * p_data_written,\n                                                        const opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager\n                            )\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        opj_write_bytes(p_data,J2K_MS_SOT,2);                                   /* SOT */\n        p_data += 2;\n\n        opj_write_bytes(p_data,10,2);                                                   /* Lsot */\n        p_data += 2;\n\n        opj_write_bytes(p_data, p_j2k->m_current_tile_number,2);                        /* Isot */\n        p_data += 2;\n\n        /* Psot  */\n        p_data += 4;\n\n        opj_write_bytes(p_data, p_j2k->m_specific_param.m_encoder.m_current_tile_part_number,1);                        /* TPsot */\n        ++p_data;\n\n        opj_write_bytes(p_data, p_j2k->m_cp.tcps[p_j2k->m_current_tile_number].m_nb_tile_parts,1);                      /* TNsot */\n        ++p_data;\n\n        /* UniPG>> */\n#ifdef USE_JPWL\n        /* update markers struct */\n/*\n        OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_SOT, p_j2k->sot_start, len + 2);\n*/\n  assert( 0 && \"TODO\" );\n#endif /* USE_JPWL */\n\n        * p_data_written = 12;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_get_sot_values(OPJ_BYTE *  p_header_data,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_UINT32  p_header_size,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_UINT32* p_tile_no,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_UINT32* p_tot_len,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_UINT32* p_current_part,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t OPJ_UINT32* p_num_parts,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t opj_event_mgr_t * p_manager )\n{\n\t/* preconditions */\n\tassert(p_header_data != 00);\n\tassert(p_manager != 00);\n\t\n\t/* Size of this marker is fixed = 12 (we have already read marker and its size)*/\n\tif (p_header_size != 8) {\n\t\topj_event_msg(p_manager, EVT_ERROR, \"Error reading SOT marker\\n\");\n\t\treturn OPJ_FALSE;\n\t}\n\t\n\topj_read_bytes(p_header_data,p_tile_no,2);      /* Isot */\n\tp_header_data+=2;\n\topj_read_bytes(p_header_data,p_tot_len,4);      /* Psot */\n\tp_header_data+=4;\n\topj_read_bytes(p_header_data,p_current_part,1); /* TPsot */\n\t++p_header_data;\n\topj_read_bytes(p_header_data,p_num_parts ,1);   /* TNsot */\n\t++p_header_data;\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_sot ( opj_j2k_t *p_j2k,\n                            OPJ_BYTE * p_header_data,\n                            OPJ_UINT32 p_header_size,\n                            opj_event_mgr_t * p_manager )\n{\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        OPJ_UINT32 l_tot_len, l_num_parts = 0;\n        OPJ_UINT32 l_current_part;\n        OPJ_UINT32 l_tile_x,l_tile_y;\n\n        /* preconditions */\n\t\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\t\n        if (! opj_j2k_get_sot_values(p_header_data, p_header_size, &(p_j2k->m_current_tile_number), &l_tot_len, &l_current_part, &l_num_parts, p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading SOT marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        l_cp = &(p_j2k->m_cp);\n\n        /* testcase 2.pdf.SIGFPE.706.1112 */\n        if (p_j2k->m_current_tile_number >= l_cp->tw * l_cp->th) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Invalid tile number %d\\n\", p_j2k->m_current_tile_number);\n                return OPJ_FALSE;\n        }\n\n        l_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];\n        l_tile_x = p_j2k->m_current_tile_number % l_cp->tw;\n        l_tile_y = p_j2k->m_current_tile_number / l_cp->tw;\n\n#ifdef USE_JPWL\n        if (l_cp->correct) {\n\n                OPJ_UINT32 tileno = p_j2k->m_current_tile_number;\n                static OPJ_UINT32 backup_tileno = 0;\n\n                /* tileno is negative or larger than the number of tiles!!! */\n                if (tileno > (l_cp->tw * l_cp->th)) {\n                        opj_event_msg(p_manager, EVT_ERROR,\n                                        \"JPWL: bad tile number (%d out of a maximum of %d)\\n\",\n                                        tileno, (l_cp->tw * l_cp->th));\n                        if (!JPWL_ASSUME) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                return OPJ_FALSE;\n                        }\n                        /* we try to correct */\n                        tileno = backup_tileno;\n                        opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust this\\n\"\n                                        \"- setting tile number to %d\\n\",\n                                        tileno);\n                }\n\n                /* keep your private count of tiles */\n                backup_tileno++;\n        };\n#endif /* USE_JPWL */\n\n        /* look for the tile in the list of already processed tile (in parts). */\n        /* Optimization possible here with a more complex data structure and with the removing of tiles */\n        /* since the time taken by this function can only grow at the time */\n\n        /* PSot should be equal to zero or >=14 or <= 2^32-1 */\n        if ((l_tot_len !=0 ) && (l_tot_len < 14) )\n        {\n            if (l_tot_len == 12 ) /* MSD: Special case for the PHR data which are read by kakadu*/\n            {\n                opj_event_msg(p_manager, EVT_WARNING, \"Empty SOT marker detected: Psot=%d.\\n\", l_tot_len);\n            }\n            else\n            {\n                opj_event_msg(p_manager, EVT_ERROR, \"Psot value is not correct regards to the JPEG2000 norm: %d.\\n\", l_tot_len);\n                return OPJ_FALSE;\n            }\n        }\n\n#ifdef USE_JPWL\n        if (l_cp->correct) {\n\n                /* totlen is negative or larger than the bytes left!!! */\n                if (/*(l_tot_len < 0) ||*/ (l_tot_len > p_header_size ) ) { /* FIXME it seems correct; for info in V1 -> (p_stream_numbytesleft(p_stream) + 8))) { */\n                        opj_event_msg(p_manager, EVT_ERROR,\n                                        \"JPWL: bad tile byte size (%d bytes against %d bytes left)\\n\",\n                                        l_tot_len, p_header_size ); /* FIXME it seems correct; for info in V1 -> p_stream_numbytesleft(p_stream) + 8); */\n                        if (!JPWL_ASSUME) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                return OPJ_FALSE;\n                        }\n                        /* we try to correct */\n                        l_tot_len = 0;\n                        opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust this\\n\"\n                                        \"- setting Psot to %d => assuming it is the last tile\\n\",\n                                        l_tot_len);\n                }\n                };\n#endif /* USE_JPWL */\n\n                /* Ref A.4.2: Psot could be equal zero if it is the last tile-part of the codestream.*/\n                if (!l_tot_len) {\n                        opj_event_msg(p_manager, EVT_INFO, \"Psot value of the current tile-part is equal to zero, \"\n                                        \"we assuming it is the last tile-part of the codestream.\\n\");\n                        p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;\n                }\n\n                if (l_num_parts != 0) { /* Number of tile-part header is provided by this tile-part header */\n                        l_num_parts += p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction;\n                        /* Useful to manage the case of textGBR.jp2 file because two values of TNSot are allowed: the correct numbers of\n                         * tile-parts for that tile and zero (A.4.2 of 15444-1 : 2002). */\n                        if (l_tcp->m_nb_tile_parts) {\n                                if (l_current_part >= l_tcp->m_nb_tile_parts){\n                                        opj_event_msg(p_manager, EVT_ERROR, \"In SOT marker, TPSot (%d) is not valid regards to the current \"\n                                                        \"number of tile-part (%d), giving up\\n\", l_current_part, l_tcp->m_nb_tile_parts );\n                                        p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;\n                                        return OPJ_FALSE;\n                                }\n                        }\n                        if( l_current_part >= l_num_parts ) {\n                          /* testcase 451.pdf.SIGSEGV.ce9.3723 */\n                          opj_event_msg(p_manager, EVT_ERROR, \"In SOT marker, TPSot (%d) is not valid regards to the current \"\n                            \"number of tile-part (header) (%d), giving up\\n\", l_current_part, l_num_parts );\n                          p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;\n                          return OPJ_FALSE;\n                        }\n                        l_tcp->m_nb_tile_parts = l_num_parts;\n                }\n\n                /* If know the number of tile part header we will check if we didn't read the last*/\n                if (l_tcp->m_nb_tile_parts) {\n                        if (l_tcp->m_nb_tile_parts == (l_current_part+1)) {\n                                p_j2k->m_specific_param.m_decoder.m_can_decode = 1; /* Process the last tile-part header*/\n                        }\n                }\n\n                if (!p_j2k->m_specific_param.m_decoder.m_last_tile_part){\n                        /* Keep the size of data to skip after this marker */\n                        p_j2k->m_specific_param.m_decoder.m_sot_length = l_tot_len - 12; /* SOT_marker_size = 12 */\n                }\n                else {\n                        /* FIXME: need to be computed from the number of bytes remaining in the codestream */\n                        p_j2k->m_specific_param.m_decoder.m_sot_length = 0;\n                }\n\n                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPH;\n\n                /* Check if the current tile is outside the area we want decode or not corresponding to the tile index*/\n                if (p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec == -1) {\n                        p_j2k->m_specific_param.m_decoder.m_skip_data =\n                                (l_tile_x < p_j2k->m_specific_param.m_decoder.m_start_tile_x)\n                                ||      (l_tile_x >= p_j2k->m_specific_param.m_decoder.m_end_tile_x)\n                                ||  (l_tile_y < p_j2k->m_specific_param.m_decoder.m_start_tile_y)\n                                ||      (l_tile_y >= p_j2k->m_specific_param.m_decoder.m_end_tile_y);\n                }\n                else {\n                        assert( p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec >= 0 );\n                        p_j2k->m_specific_param.m_decoder.m_skip_data =\n                                (p_j2k->m_current_tile_number != (OPJ_UINT32)p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec);\n                }\n\n                /* Index */\n                if (p_j2k->cstr_index)\n                {\n                        assert(p_j2k->cstr_index->tile_index != 00);\n                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tileno = p_j2k->m_current_tile_number;\n                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_tpsno = l_current_part;\n\n                        if (l_num_parts != 0){\n                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].nb_tps = l_num_parts;\n                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = l_num_parts;\n\n                                if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index) {\n                                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index =\n                                                (opj_tp_index_t*)opj_calloc(l_num_parts, sizeof(opj_tp_index_t));\n                                        if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index) {\n                                                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read SOT marker. Tile index allocation failed\\n\");\n                                                return OPJ_FALSE;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n                                }\n                                else {\n                                        opj_tp_index_t *new_tp_index = (opj_tp_index_t *) opj_realloc(\n                                                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index, l_num_parts* sizeof(opj_tp_index_t));\n                                        if (! new_tp_index) {\n                                                opj_free(p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index);\n                                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index = NULL;\n                                                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read SOT marker. Tile index allocation failed\\n\");\n                                                return OPJ_FALSE;\n                                        }\n                                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index = new_tp_index;\n                                }\n                        }\n                        else{\n                                /*if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index)*/ {\n\n                                        if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index) {\n                                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = 10;\n                                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index =\n                                                        (opj_tp_index_t*)opj_calloc( p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps,\n                                                                        sizeof(opj_tp_index_t));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index) {\n                                                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = 0;\n                                                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read SOT marker. Tile index allocation failed\\n\");\n                                                        return OPJ_FALSE;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t        }\n                                        }\n\n                                        if ( l_current_part >= p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps ){\n                                                opj_tp_index_t *new_tp_index;\n                                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = l_current_part + 1;\n                                                new_tp_index = (opj_tp_index_t *) opj_realloc(\n                                                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index,\n                                                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps * sizeof(opj_tp_index_t));\n                                                if (! new_tp_index) {\n                                                        opj_free(p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index);\n                                                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index = NULL;\n                                                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = 0;\n                                                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read SOT marker. Tile index allocation failed\\n\");\n                                                        return OPJ_FALSE;\n                                                }\n                                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index = new_tp_index;\n                                        }\n                                }\n\n                        }\n\n                }\n\n                /* FIXME move this onto a separate method to call before reading any SOT, remove part about main_end header, use a index struct inside p_j2k */\n                /* if (p_j2k->cstr_info) {\n                   if (l_tcp->first) {\n                   if (tileno == 0) {\n                   p_j2k->cstr_info->main_head_end = p_stream_tell(p_stream) - 13;\n                   }\n\n                   p_j2k->cstr_info->tile[tileno].tileno = tileno;\n                   p_j2k->cstr_info->tile[tileno].start_pos = p_stream_tell(p_stream) - 12;\n                   p_j2k->cstr_info->tile[tileno].end_pos = p_j2k->cstr_info->tile[tileno].start_pos + totlen - 1;\n                   p_j2k->cstr_info->tile[tileno].num_tps = numparts;\n\n                   if (numparts) {\n                   p_j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_malloc(numparts * sizeof(opj_tp_info_t));\n                   }\n                   else {\n                   p_j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_malloc(10 * sizeof(opj_tp_info_t)); // Fixme (10)\n                   }\n                   }\n                   else {\n                   p_j2k->cstr_info->tile[tileno].end_pos += totlen;\n                   }\n\n                   p_j2k->cstr_info->tile[tileno].tp[partno].tp_start_pos = p_stream_tell(p_stream) - 12;\n                   p_j2k->cstr_info->tile[tileno].tp[partno].tp_end_pos =\n                   p_j2k->cstr_info->tile[tileno].tp[partno].tp_start_pos + totlen - 1;\n                   }*/\n                return OPJ_TRUE;\n        }\n\nstatic OPJ_BOOL opj_j2k_write_sod(     opj_j2k_t *p_j2k,\n                                                        opj_tcd_t * p_tile_coder,\n                                                        OPJ_BYTE * p_data,\n                                                        OPJ_UINT32 * p_data_written,\n                                                        OPJ_UINT32 p_total_data_size,\n                                                        const opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager\n                            )\n{\n        opj_codestream_info_t *l_cstr_info = 00;\n        OPJ_UINT32 l_remaining_data;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        opj_write_bytes(p_data,J2K_MS_SOD,2);                                   /* SOD */\n        p_data += 2;\n\n        /* make room for the EOF marker */\n        l_remaining_data =  p_total_data_size - 4;\n\n        /* update tile coder */\n        p_tile_coder->tp_num = p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number ;\n        p_tile_coder->cur_tp_num = p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;\n\n         /* INDEX >> */\n        /* TODO mergeV2: check this part which use cstr_info */\n        /*l_cstr_info = p_j2k->cstr_info;\n        if (l_cstr_info) {\n                if (!p_j2k->m_specific_param.m_encoder.m_current_tile_part_number ) {\n                        //TODO cstr_info->tile[p_j2k->m_current_tile_number].end_header = p_stream_tell(p_stream) + p_j2k->pos_correction - 1;\n                        l_cstr_info->tile[p_j2k->m_current_tile_number].tileno = p_j2k->m_current_tile_number;\n                }\n                else {*/\n                        /*\n                        TODO\n                        if\n                                (cstr_info->tile[p_j2k->m_current_tile_number].packet[cstr_info->packno - 1].end_pos < p_stream_tell(p_stream))\n                        {\n                                cstr_info->tile[p_j2k->m_current_tile_number].packet[cstr_info->packno].start_pos = p_stream_tell(p_stream);\n                        }*/\n                /*}*/\n                /* UniPG>> */\n#ifdef USE_JPWL\n                /* update markers struct */\n                /*OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_SOD, p_j2k->sod_start, 2);\n*/\n  assert( 0 && \"TODO\" );\n#endif /* USE_JPWL */\n                /* <<UniPG */\n        /*}*/\n        /* << INDEX */\n\n        if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0) {\n                p_tile_coder->tcd_image->tiles->packno = 0;\n                if (l_cstr_info) {\n                        l_cstr_info->packno = 0;\n                }\n        }\n\n        *p_data_written = 0;\n\n        if (! opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number, p_data, p_data_written, l_remaining_data , l_cstr_info)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Cannot encode tile\\n\");\n                return OPJ_FALSE;\n        }\n\n        *p_data_written += 2;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_sod (opj_j2k_t *p_j2k,\n                           opj_stream_private_t *p_stream,\n                                                   opj_event_mgr_t * p_manager\n                           )\n{\n        OPJ_SIZE_T l_current_read_size;\n        opj_codestream_index_t * l_cstr_index = 00;\n        OPJ_BYTE ** l_current_data = 00;\n        opj_tcp_t * l_tcp = 00;\n        OPJ_UINT32 * l_tile_len = 00;\n        OPJ_BOOL l_sot_length_pb_detected = OPJ_FALSE;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_tcp = &(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);\n\n        if (p_j2k->m_specific_param.m_decoder.m_last_tile_part) {\n                /* opj_stream_get_number_byte_left returns OPJ_OFF_T\n                // but we are in the last tile part,\n                // so its result will fit on OPJ_UINT32 unless we find\n                // a file with a single tile part of more than 4 GB...*/\n                p_j2k->m_specific_param.m_decoder.m_sot_length = (OPJ_UINT32)(opj_stream_get_number_byte_left(p_stream) - 2);\n        }\n        else {\n            /* Check to avoid pass the limit of OPJ_UINT32 */\n            if (p_j2k->m_specific_param.m_decoder.m_sot_length >= 2 )\n                p_j2k->m_specific_param.m_decoder.m_sot_length -= 2;\n            else {\n                /* MSD: case commented to support empty SOT marker (PHR data) */\n            }\n        }\n\n        l_current_data = &(l_tcp->m_data);\n        l_tile_len = &l_tcp->m_data_size;\n\n        /* Patch to support new PHR data */\n        if (p_j2k->m_specific_param.m_decoder.m_sot_length) {\n            /* If we are here, we'll try to read the data after allocation */\n            /* Check enough bytes left in stream before allocation */\n            if ((OPJ_OFF_T)p_j2k->m_specific_param.m_decoder.m_sot_length > opj_stream_get_number_byte_left(p_stream)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Tile part length size inconsistent with stream length\\n\");\n                return OPJ_FALSE;\n            }\n            if (! *l_current_data) {\n                /* LH: oddly enough, in this path, l_tile_len!=0.\n                 * TODO: If this was consistent, we could simplify the code to only use realloc(), as realloc(0,...) default to malloc(0,...).\n                 */\n                *l_current_data = (OPJ_BYTE*) opj_malloc(p_j2k->m_specific_param.m_decoder.m_sot_length);\n            }\n            else {\n                OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(*l_current_data, *l_tile_len + p_j2k->m_specific_param.m_decoder.m_sot_length);\n                if (! l_new_current_data) {\n                        opj_free(*l_current_data);\n                        /*nothing more is done as l_current_data will be set to null, and just\n                          afterward we enter in the error path\n                          and the actual tile_len is updated (committed) at the end of the\n                          function. */\n                }\n                *l_current_data = l_new_current_data;\n            }\n            \n            if (*l_current_data == 00) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to decode tile\\n\");\n                return OPJ_FALSE;\n            }\n        }\n        else {\n            l_sot_length_pb_detected = OPJ_TRUE;\n        }\n\n        /* Index */\n        l_cstr_index = p_j2k->cstr_index;\n        if (l_cstr_index) {\n                OPJ_OFF_T l_current_pos = opj_stream_tell(p_stream) - 2;\n\n                OPJ_UINT32 l_current_tile_part = l_cstr_index->tile_index[p_j2k->m_current_tile_number].current_tpsno;\n                l_cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index[l_current_tile_part].end_header =\n                                l_current_pos;\n                l_cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index[l_current_tile_part].end_pos =\n                                l_current_pos + p_j2k->m_specific_param.m_decoder.m_sot_length + 2;\n\n                if (OPJ_FALSE == opj_j2k_add_tlmarker(p_j2k->m_current_tile_number,\n                                        l_cstr_index,\n                                        J2K_MS_SOD,\n                                        l_current_pos,\n                                        p_j2k->m_specific_param.m_decoder.m_sot_length + 2)) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add tl marker\\n\");\n                        return OPJ_FALSE;\n                }\n\n                /*l_cstr_index->packno = 0;*/\n        }\n\n        /* Patch to support new PHR data */\n        if (!l_sot_length_pb_detected) {\n            l_current_read_size = opj_stream_read_data(\n                        p_stream,\n                        *l_current_data + *l_tile_len,\n                        p_j2k->m_specific_param.m_decoder.m_sot_length,\n                        p_manager);\n        }\n        else\n        {\n            l_current_read_size = 0;\n        }\n\n        if (l_current_read_size != p_j2k->m_specific_param.m_decoder.m_sot_length) {\n                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;\n        }\n        else {\n                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;\n        }\n\n        *l_tile_len += (OPJ_UINT32)l_current_read_size;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k,\n                            OPJ_UINT32 p_tile_no,\n                            OPJ_UINT32 p_comp_no,\n                            OPJ_UINT32 nb_comps,\n                            opj_stream_private_t *p_stream,\n                            opj_event_mgr_t * p_manager\n                            )\n{\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_rgn_size;\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_tccp_t *l_tccp = 00;\n        OPJ_UINT32 l_comp_room;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = &l_cp->tcps[p_tile_no];\n        l_tccp = &l_tcp->tccps[p_comp_no];\n\n        if (nb_comps <= 256) {\n                l_comp_room = 1;\n        }\n        else {\n                l_comp_room = 2;\n        }\n\n        l_rgn_size = 6 + l_comp_room;\n\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        opj_write_bytes(l_current_data,J2K_MS_RGN,2);                                   /* RGN  */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_rgn_size-2,2);                                 /* Lrgn */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,p_comp_no,l_comp_room);                          /* Crgn */\n        l_current_data+=l_comp_room;\n\n        opj_write_bytes(l_current_data, 0,1);                                           /* Srgn */\n        ++l_current_data;\n\n        opj_write_bytes(l_current_data, (OPJ_UINT32)l_tccp->roishift,1);                            /* SPrgn */\n        ++l_current_data;\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_rgn_size,p_manager) != l_rgn_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_eoc(     opj_j2k_t *p_j2k,\n                            opj_stream_private_t *p_stream,\n                            opj_event_mgr_t * p_manager\n                            )\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        opj_write_bytes(p_j2k->m_specific_param.m_encoder.m_header_tile_data,J2K_MS_EOC,2);                                     /* EOC */\n\n/* UniPG>> */\n#ifdef USE_JPWL\n        /* update markers struct */\n        /*\n        OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_EOC, p_stream_tell(p_stream) - 2, 2);\n*/\n#endif /* USE_JPWL */\n\n        if ( opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,2,p_manager) != 2) {\n                return OPJ_FALSE;\n        }\n\n        if ( ! opj_stream_flush(p_stream,p_manager) ) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a RGN marker (Region Of Interest)\n *\n * @param       p_header_data   the data contained in the POC box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the POC marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_rgn (opj_j2k_t *p_j2k,\n                                  OPJ_BYTE * p_header_data,\n                                  OPJ_UINT32 p_header_size,\n                                  opj_event_mgr_t * p_manager\n                                  )\n{\n        OPJ_UINT32 l_nb_comp;\n        opj_image_t * l_image = 00;\n\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        OPJ_UINT32 l_comp_room, l_comp_no, l_roi_sty;\n\n        /* preconditions*/\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_image = p_j2k->m_private_image;\n        l_nb_comp = l_image->numcomps;\n\n        if (l_nb_comp <= 256) {\n                l_comp_room = 1; }\n        else {\n                l_comp_room = 2; }\n\n        if (p_header_size != 2 + l_comp_room) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading RGN marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?\n                                &l_cp->tcps[p_j2k->m_current_tile_number] :\n                                p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n        opj_read_bytes(p_header_data,&l_comp_no,l_comp_room);           /* Crgn */\n        p_header_data+=l_comp_room;\n        opj_read_bytes(p_header_data,&l_roi_sty,1);                                     /* Srgn */\n        ++p_header_data;\n\n#ifdef USE_JPWL\n        if (l_cp->correct) {\n                /* totlen is negative or larger than the bytes left!!! */\n                if (l_comp_room >= l_nb_comp) {\n                        opj_event_msg(p_manager, EVT_ERROR,\n                                \"JPWL: bad component number in RGN (%d when there are only %d)\\n\",\n                                l_comp_room, l_nb_comp);\n                        if (!JPWL_ASSUME) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                return OPJ_FALSE;\n                        }\n                }\n        };\n#endif /* USE_JPWL */\n\n        /* testcase 3635.pdf.asan.77.2930 */\n        if (l_comp_no >= l_nb_comp) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                        \"bad component number in RGN (%d when there are only %d)\\n\",\n                        l_comp_no, l_nb_comp);\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(p_header_data,(OPJ_UINT32 *) (&(l_tcp->tccps[l_comp_no].roishift)),1);   /* SPrgn */\n        ++p_header_data;\n\n        return OPJ_TRUE;\n\n}\n\nstatic OPJ_FLOAT32 opj_j2k_get_tp_stride (opj_tcp_t * p_tcp)\n{\n        return (OPJ_FLOAT32) ((p_tcp->m_nb_tile_parts - 1) * 14);\n}\n\nstatic OPJ_FLOAT32 opj_j2k_get_default_stride (opj_tcp_t * p_tcp)\n{\n    (void)p_tcp;\n    return 0;\n}\n\nstatic OPJ_BOOL opj_j2k_update_rates(  opj_j2k_t *p_j2k,\n                                                            opj_stream_private_t *p_stream,\n                                                            opj_event_mgr_t * p_manager )\n{\n        opj_cp_t * l_cp = 00;\n        opj_image_t * l_image = 00;\n        opj_tcp_t * l_tcp = 00;\n        opj_image_comp_t * l_img_comp = 00;\n\n        OPJ_UINT32 i,j,k;\n        OPJ_INT32 l_x0,l_y0,l_x1,l_y1;\n        OPJ_FLOAT32 * l_rates = 0;\n        OPJ_FLOAT32 l_sot_remove;\n        OPJ_UINT32 l_bits_empty, l_size_pixel;\n        OPJ_UINT32 l_tile_size = 0;\n        OPJ_UINT32 l_last_res;\n        OPJ_FLOAT32 (* l_tp_stride_func)(opj_tcp_t *) = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_image = p_j2k->m_private_image;\n        l_tcp = l_cp->tcps;\n\n        l_bits_empty = 8 * l_image->comps->dx * l_image->comps->dy;\n        l_size_pixel = l_image->numcomps * l_image->comps->prec;\n        l_sot_remove = (OPJ_FLOAT32) opj_stream_tell(p_stream) / (OPJ_FLOAT32)(l_cp->th * l_cp->tw);\n\n        if (l_cp->m_specific_param.m_enc.m_tp_on) {\n                l_tp_stride_func = opj_j2k_get_tp_stride;\n        }\n        else {\n                l_tp_stride_func = opj_j2k_get_default_stride;\n        }\n\n        for (i=0;i<l_cp->th;++i) {\n                for (j=0;j<l_cp->tw;++j) {\n                        OPJ_FLOAT32 l_offset = (OPJ_FLOAT32)(*l_tp_stride_func)(l_tcp) / (OPJ_FLOAT32)l_tcp->numlayers;\n\n                        /* 4 borders of the tile rescale on the image if necessary */\n                        l_x0 = opj_int_max((OPJ_INT32)(l_cp->tx0 + j * l_cp->tdx), (OPJ_INT32)l_image->x0);\n                        l_y0 = opj_int_max((OPJ_INT32)(l_cp->ty0 + i * l_cp->tdy), (OPJ_INT32)l_image->y0);\n                        l_x1 = opj_int_min((OPJ_INT32)(l_cp->tx0 + (j + 1) * l_cp->tdx), (OPJ_INT32)l_image->x1);\n                        l_y1 = opj_int_min((OPJ_INT32)(l_cp->ty0 + (i + 1) * l_cp->tdy), (OPJ_INT32)l_image->y1);\n\n                        l_rates = l_tcp->rates;\n\n                        /* Modification of the RATE >> */\n                        if (*l_rates > 0.0f) {\n                                *l_rates =              (( (OPJ_FLOAT32) (l_size_pixel * (OPJ_UINT32)(l_x1 - l_x0) * (OPJ_UINT32)(l_y1 - l_y0)))\n                                                                /\n                                                                ((*l_rates) * (OPJ_FLOAT32)l_bits_empty)\n                                                                )\n                                                                -\n                                                                l_offset;\n                        }\n\n                        ++l_rates;\n\n                        for (k = 1; k < l_tcp->numlayers; ++k) {\n                                if (*l_rates > 0.0f) {\n                                        *l_rates =              (( (OPJ_FLOAT32) (l_size_pixel * (OPJ_UINT32)(l_x1 - l_x0) * (OPJ_UINT32)(l_y1 - l_y0)))\n                                                                        /\n                                                                                ((*l_rates) * (OPJ_FLOAT32)l_bits_empty)\n                                                                        )\n                                                                        -\n                                                                        l_offset;\n                                }\n\n                                ++l_rates;\n                        }\n\n                        ++l_tcp;\n\n                }\n        }\n\n        l_tcp = l_cp->tcps;\n\n        for (i=0;i<l_cp->th;++i) {\n                for     (j=0;j<l_cp->tw;++j) {\n                        l_rates = l_tcp->rates;\n\n                        if (*l_rates > 0.0f) {\n                                *l_rates -= l_sot_remove;\n\n                                if (*l_rates < 30.0f) {\n                                        *l_rates = 30.0f;\n                                }\n                        }\n\n                        ++l_rates;\n\n                        l_last_res = l_tcp->numlayers - 1;\n\n                        for (k = 1; k < l_last_res; ++k) {\n\n                                if (*l_rates > 0.0f) {\n                                        *l_rates -= l_sot_remove;\n\n                                        if (*l_rates < *(l_rates - 1) + 10.0f) {\n                                                *l_rates  = (*(l_rates - 1)) + 20.0f;\n                                        }\n                                }\n\n                                ++l_rates;\n                        }\n\n                        if (*l_rates > 0.0f) {\n                                *l_rates -= (l_sot_remove + 2.f);\n\n                                if (*l_rates < *(l_rates - 1) + 10.0f) {\n                                        *l_rates  = (*(l_rates - 1)) + 20.0f;\n                                }\n                        }\n\n                        ++l_tcp;\n                }\n        }\n\n        l_img_comp = l_image->comps;\n        l_tile_size = 0;\n\n        for (i=0;i<l_image->numcomps;++i) {\n                l_tile_size += (        opj_uint_ceildiv(l_cp->tdx,l_img_comp->dx)\n                                                        *\n                                                        opj_uint_ceildiv(l_cp->tdy,l_img_comp->dy)\n                                                        *\n                                                        l_img_comp->prec\n                                                );\n\n                ++l_img_comp;\n        }\n\n        l_tile_size = (OPJ_UINT32) (l_tile_size * 0.1625); /* 1.3/8 = 0.1625 */\n\n        l_tile_size += opj_j2k_get_specific_header_sizes(p_j2k);\n\n        p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = l_tile_size;\n        p_j2k->m_specific_param.m_encoder.m_encoded_tile_data =\n                        (OPJ_BYTE *) opj_malloc(p_j2k->m_specific_param.m_encoder.m_encoded_tile_size);\n        if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data == 00) {\n                return OPJ_FALSE;\n        }\n\n        if (OPJ_IS_CINEMA(l_cp->rsiz)) {\n                p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer =\n                                (OPJ_BYTE *) opj_malloc(5*p_j2k->m_specific_param.m_encoder.m_total_tile_parts);\n                if (! p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {\n                        return OPJ_FALSE;\n                }\n\n                p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current =\n                                p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer;\n        }\n\n        return OPJ_TRUE;\n}\n\n#if 0\nstatic OPJ_BOOL opj_j2k_read_eoc (     opj_j2k_t *p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager )\n{\n        OPJ_UINT32 i;\n        opj_tcd_t * l_tcd = 00;\n        OPJ_UINT32 l_nb_tiles;\n        opj_tcp_t * l_tcp = 00;\n        OPJ_BOOL l_success;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n        l_tcp = p_j2k->m_cp.tcps;\n\n        l_tcd = opj_tcd_create(OPJ_TRUE);\n        if (l_tcd == 00) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Cannot decode tile, memory error\\n\");\n                return OPJ_FALSE;\n        }\n\n        for (i = 0; i < l_nb_tiles; ++i) {\n                if (l_tcp->m_data) {\n                        if (! opj_tcd_init_decode_tile(l_tcd, i)) {\n                                opj_tcd_destroy(l_tcd);\n                                opj_event_msg(p_manager, EVT_ERROR, \"Cannot decode tile, memory error\\n\");\n                                return OPJ_FALSE;\n                        }\n\n                        l_success = opj_tcd_decode_tile(l_tcd, l_tcp->m_data, l_tcp->m_data_size, i, p_j2k->cstr_index);\n                        /* cleanup */\n\n                        if (! l_success) {\n                                p_j2k->m_specific_param.m_decoder.m_state |= J2K_STATE_ERR;\n                                break;\n                        }\n                }\n\n                opj_j2k_tcp_destroy(l_tcp);\n                ++l_tcp;\n        }\n\n        opj_tcd_destroy(l_tcd);\n        return OPJ_TRUE;\n}\n#endif\n\nstatic OPJ_BOOL opj_j2k_get_end_header(opj_j2k_t *p_j2k,\n                                                        struct opj_stream_private *p_stream,\n                                                        struct opj_event_mgr * p_manager )\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        p_j2k->cstr_index->main_head_end = opj_stream_tell(p_stream);\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_mct_data_group(  opj_j2k_t *p_j2k,\n                                                                        struct opj_stream_private *p_stream,\n                                                                        struct opj_event_mgr * p_manager )\n{\n        OPJ_UINT32 i;\n        opj_simple_mcc_decorrelation_data_t * l_mcc_record;\n        opj_mct_data_t * l_mct_record;\n        opj_tcp_t * l_tcp;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n\n        if (! opj_j2k_write_cbd(p_j2k,p_stream,p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        l_tcp = &(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);\n        l_mct_record = l_tcp->m_mct_records;\n\n        for (i=0;i<l_tcp->m_nb_mct_records;++i) {\n\n                if (! opj_j2k_write_mct_record(p_j2k,l_mct_record,p_stream,p_manager)) {\n                        return OPJ_FALSE;\n                }\n\n                ++l_mct_record;\n        }\n\n        l_mcc_record = l_tcp->m_mcc_records;\n\n        for     (i=0;i<l_tcp->m_nb_mcc_records;++i) {\n\n                if (! opj_j2k_write_mcc_record(p_j2k,l_mcc_record,p_stream,p_manager)) {\n                        return OPJ_FALSE;\n                }\n\n                ++l_mcc_record;\n        }\n\n        if (! opj_j2k_write_mco(p_j2k,p_stream,p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_all_coc(\n\topj_j2k_t *p_j2k,\n\tstruct opj_stream_private *p_stream,\n\tstruct opj_event_mgr * p_manager )\n{\n\tOPJ_UINT32 compno;\n\t\n\t/* preconditions */\n\tassert(p_j2k != 00);\n\tassert(p_manager != 00);\n\tassert(p_stream != 00);\n\t\n\tfor (compno = 1; compno < p_j2k->m_private_image->numcomps; ++compno)\n\t{\n\t\t/* cod is first component of first tile */\n\t\tif (! opj_j2k_compare_coc(p_j2k, 0, compno)) {\n\t\t\tif (! opj_j2k_write_coc(p_j2k,compno,p_stream, p_manager)) {\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_all_qcc(\n\topj_j2k_t *p_j2k,\n\tstruct opj_stream_private *p_stream,\n\tstruct opj_event_mgr * p_manager )\n{\n\tOPJ_UINT32 compno;\n\t\n\t/* preconditions */\n\tassert(p_j2k != 00);\n\tassert(p_manager != 00);\n\tassert(p_stream != 00);\n\t\n\tfor (compno = 1; compno < p_j2k->m_private_image->numcomps; ++compno)\n\t{\n\t\t/* qcd is first component of first tile */\n\t\tif (! opj_j2k_compare_qcc(p_j2k, 0, compno)) {\n\t\t\tif (! opj_j2k_write_qcc(p_j2k,compno,p_stream, p_manager)) {\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_regions( opj_j2k_t *p_j2k,\n                                                        struct opj_stream_private *p_stream,\n                                                        struct opj_event_mgr * p_manager )\n{\n        OPJ_UINT32 compno;\n        const opj_tccp_t *l_tccp = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_tccp = p_j2k->m_cp.tcps->tccps;\n\n        for (compno = 0; compno < p_j2k->m_private_image->numcomps; ++compno)  {\n                if (l_tccp->roishift) {\n\n                        if (! opj_j2k_write_rgn(p_j2k,0,compno,p_j2k->m_private_image->numcomps,p_stream,p_manager)) {\n                                return OPJ_FALSE;\n                        }\n                }\n\n                ++l_tccp;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_epc(     opj_j2k_t *p_j2k,\n                                                struct opj_stream_private *p_stream,\n                                                struct opj_event_mgr * p_manager )\n{\n        opj_codestream_index_t * l_cstr_index = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_cstr_index = p_j2k->cstr_index;\n        if (l_cstr_index) {\n                l_cstr_index->codestream_size = (OPJ_UINT64)opj_stream_tell(p_stream);\n                /* UniPG>> */\n                /* The following adjustment is done to adjust the codestream size */\n                /* if SOD is not at 0 in the buffer. Useful in case of JP2, where */\n                /* the first bunch of bytes is not in the codestream              */\n                l_cstr_index->codestream_size -= (OPJ_UINT64)l_cstr_index->main_head_start;\n                /* <<UniPG */\n        }\n\n#ifdef USE_JPWL\n        /* preparation of JPWL marker segments */\n#if 0\n        if(cp->epc_on) {\n\n                /* encode according to JPWL */\n                jpwl_encode(p_j2k, p_stream, image);\n\n        }\n#endif\n  assert( 0 && \"TODO\" );\n#endif /* USE_JPWL */\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_unk (     opj_j2k_t *p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                        OPJ_UINT32 *output_marker,\n                                                        opj_event_mgr_t * p_manager\n                                                        )\n{\n        OPJ_UINT32 l_unknown_marker;\n        const opj_dec_memory_marker_handler_t * l_marker_handler;\n        OPJ_UINT32 l_size_unk = 2;\n\n        /* preconditions*/\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        opj_event_msg(p_manager, EVT_WARNING, \"Unknown marker\\n\");\n\n\t\tfor (;;) {\n                /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer*/\n                if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                        return OPJ_FALSE;\n                }\n\n                /* read 2 bytes as the new marker ID*/\n                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_unknown_marker,2);\n\n                if (!(l_unknown_marker < 0xff00)) {\n\n                        /* Get the marker handler from the marker ID*/\n                        l_marker_handler = opj_j2k_get_marker_handler(l_unknown_marker);\n\n                        if (!(p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Marker is not compliant with its position\\n\");\n                                return OPJ_FALSE;\n                        }\n                        else {\n                                if (l_marker_handler->id != J2K_MS_UNK) {\n                                        /* Add the marker to the codestream index*/\n                                        if (l_marker_handler->id != J2K_MS_SOT)\n                                        {\n                                                OPJ_BOOL res = opj_j2k_add_mhmarker(p_j2k->cstr_index, J2K_MS_UNK,\n                                                                (OPJ_UINT32) opj_stream_tell(p_stream) - l_size_unk,\n                                                                l_size_unk);\n                                                if (res == OPJ_FALSE) {\n                                                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add mh marker\\n\");\n                                                        return OPJ_FALSE;\n                                                }\n                                        }\n                                        break; /* next marker is known and well located */\n                                }\n                                else\n                                        l_size_unk += 2;\n                        }\n                }\n        }\n\n        *output_marker = l_marker_handler->id ;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_mct_record(      opj_j2k_t *p_j2k,\n                                                                opj_mct_data_t * p_mct_record,\n                                                                struct opj_stream_private *p_stream,\n                                                                struct opj_event_mgr * p_manager )\n{\n        OPJ_UINT32 l_mct_size;\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_tmp;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_mct_size = 10 + p_mct_record->m_data_size;\n\n        if (l_mct_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mct_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write MCT marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mct_size;\n        }\n\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        opj_write_bytes(l_current_data,J2K_MS_MCT,2);                                   /* MCT */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_mct_size-2,2);                                 /* Lmct */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,0,2);                                                    /* Zmct */\n        l_current_data += 2;\n\n        /* only one marker atm */\n        l_tmp = (p_mct_record->m_index & 0xff) | (p_mct_record->m_array_type << 8) | (p_mct_record->m_element_type << 10);\n\n        opj_write_bytes(l_current_data,l_tmp,2);\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,0,2);                                                    /* Ymct */\n        l_current_data+=2;\n\n        memcpy(l_current_data,p_mct_record->m_data,p_mct_record->m_data_size);\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_mct_size,p_manager) != l_mct_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a MCT marker (Multiple Component Transform)\n *\n * @param       p_header_data   the data contained in the MCT box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the MCT marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_mct (      opj_j2k_t *p_j2k,\n                                                                    OPJ_BYTE * p_header_data,\n                                                                    OPJ_UINT32 p_header_size,\n                                                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_UINT32 i;\n        opj_tcp_t *l_tcp = 00;\n        OPJ_UINT32 l_tmp;\n        OPJ_UINT32 l_indix;\n        opj_mct_data_t * l_mct_data;\n\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n\n        l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?\n                        &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number] :\n                        p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n        if (p_header_size < 2) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCT marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        /* first marker */\n        opj_read_bytes(p_header_data,&l_tmp,2);                         /* Zmct */\n        p_header_data += 2;\n        if (l_tmp != 0) {\n                opj_event_msg(p_manager, EVT_WARNING, \"Cannot take in charge mct data within multiple MCT records\\n\");\n                return OPJ_TRUE;\n        }\n\n        if(p_header_size <= 6) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCT marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        /* Imct -> no need for other values, take the first, type is double with decorrelation x0000 1101 0000 0000*/\n        opj_read_bytes(p_header_data,&l_tmp,2);                         /* Imct */\n        p_header_data += 2;\n\n        l_indix = l_tmp & 0xff;\n        l_mct_data = l_tcp->m_mct_records;\n\n        for (i=0;i<l_tcp->m_nb_mct_records;++i) {\n                if (l_mct_data->m_index == l_indix) {\n                        break;\n                }\n                ++l_mct_data;\n        }\n\n        /* NOT FOUND */\n        if (i == l_tcp->m_nb_mct_records) {\n                if (l_tcp->m_nb_mct_records == l_tcp->m_nb_max_mct_records) {\n                        opj_mct_data_t *new_mct_records;\n                        l_tcp->m_nb_max_mct_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;\n\n                        new_mct_records = (opj_mct_data_t *) opj_realloc(l_tcp->m_mct_records, l_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t));\n                        if (! new_mct_records) {\n                                opj_free(l_tcp->m_mct_records);\n                                l_tcp->m_mct_records = NULL;\n                                l_tcp->m_nb_max_mct_records = 0;\n                                l_tcp->m_nb_mct_records = 0;\n                                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read MCT marker\\n\");\n                                return OPJ_FALSE;\n                        }\n                        l_tcp->m_mct_records = new_mct_records;\n                        l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;\n                        memset(l_mct_data ,0,(l_tcp->m_nb_max_mct_records - l_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t));\n                }\n\n                l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;\n                ++l_tcp->m_nb_mct_records;\n        }\n\n        if (l_mct_data->m_data) {\n                opj_free(l_mct_data->m_data);\n                l_mct_data->m_data = 00;\n        }\n\n        l_mct_data->m_index = l_indix;\n        l_mct_data->m_array_type = (J2K_MCT_ARRAY_TYPE)((l_tmp  >> 8) & 3);\n        l_mct_data->m_element_type = (J2K_MCT_ELEMENT_TYPE)((l_tmp  >> 10) & 3);\n\n        opj_read_bytes(p_header_data,&l_tmp,2);                         /* Ymct */\n        p_header_data+=2;\n        if (l_tmp != 0) {\n                opj_event_msg(p_manager, EVT_WARNING, \"Cannot take in charge multiple MCT markers\\n\");\n                return OPJ_TRUE;\n        }\n\n        p_header_size -= 6;\n\n        l_mct_data->m_data = (OPJ_BYTE*)opj_malloc(p_header_size);\n        if (! l_mct_data->m_data) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCT marker\\n\");\n                return OPJ_FALSE;\n        }\n        memcpy(l_mct_data->m_data,p_header_data,p_header_size);\n\n        l_mct_data->m_data_size = p_header_size;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_mcc_record(      opj_j2k_t *p_j2k,\n                                                                struct opj_simple_mcc_decorrelation_data * p_mcc_record,\n                                                                struct opj_stream_private *p_stream,\n                                                                struct opj_event_mgr * p_manager )\n{\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_mcc_size;\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_nb_bytes_for_comp;\n        OPJ_UINT32 l_mask;\n        OPJ_UINT32 l_tmcc;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        if (p_mcc_record->m_nb_comps > 255 ) {\n        l_nb_bytes_for_comp = 2;\n                l_mask = 0x8000;\n        }\n        else {\n                l_nb_bytes_for_comp = 1;\n                l_mask = 0;\n        }\n\n        l_mcc_size = p_mcc_record->m_nb_comps * 2 * l_nb_bytes_for_comp + 19;\n        if (l_mcc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size)\n        {\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mcc_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write MCC marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mcc_size;\n        }\n\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        opj_write_bytes(l_current_data,J2K_MS_MCC,2);                                   /* MCC */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_mcc_size-2,2);                                 /* Lmcc */\n        l_current_data += 2;\n\n        /* first marker */\n        opj_write_bytes(l_current_data,0,2);                                    /* Zmcc */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,p_mcc_record->m_index,1);                                        /* Imcc -> no need for other values, take the first */\n        ++l_current_data;\n\n        /* only one marker atm */\n        opj_write_bytes(l_current_data,0,2);                                    /* Ymcc */\n        l_current_data+=2;\n\n        opj_write_bytes(l_current_data,1,2);                                    /* Qmcc -> number of collections -> 1 */\n        l_current_data+=2;\n\n        opj_write_bytes(l_current_data,0x1,1);                                  /* Xmcci type of component transformation -> array based decorrelation */\n        ++l_current_data;\n\n        opj_write_bytes(l_current_data,p_mcc_record->m_nb_comps | l_mask,2);    /* Nmcci number of input components involved and size for each component offset = 8 bits */\n        l_current_data+=2;\n\n        for (i=0;i<p_mcc_record->m_nb_comps;++i) {\n                opj_write_bytes(l_current_data,i,l_nb_bytes_for_comp);                          /* Cmccij Component offset*/\n                l_current_data+=l_nb_bytes_for_comp;\n        }\n\n        opj_write_bytes(l_current_data,p_mcc_record->m_nb_comps|l_mask,2);      /* Mmcci number of output components involved and size for each component offset = 8 bits */\n        l_current_data+=2;\n\n        for (i=0;i<p_mcc_record->m_nb_comps;++i)\n        {\n                opj_write_bytes(l_current_data,i,l_nb_bytes_for_comp);                          /* Wmccij Component offset*/\n                l_current_data+=l_nb_bytes_for_comp;\n        }\n\n        l_tmcc = ((!p_mcc_record->m_is_irreversible) & 1U) << 16;\n\n        if (p_mcc_record->m_decorrelation_array) {\n                l_tmcc |= p_mcc_record->m_decorrelation_array->m_index;\n        }\n\n        if (p_mcc_record->m_offset_array) {\n                l_tmcc |= ((p_mcc_record->m_offset_array->m_index)<<8);\n        }\n\n        opj_write_bytes(l_current_data,l_tmcc,3);       /* Tmcci : use MCT defined as number 1 and irreversible array based. */\n        l_current_data+=3;\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_mcc_size,p_manager) != l_mcc_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_mcc (     opj_j2k_t *p_j2k,\n                                                OPJ_BYTE * p_header_data,\n                                                OPJ_UINT32 p_header_size,\n                                                opj_event_mgr_t * p_manager )\n{\n        OPJ_UINT32 i,j;\n        OPJ_UINT32 l_tmp;\n        OPJ_UINT32 l_indix;\n        opj_tcp_t * l_tcp;\n        opj_simple_mcc_decorrelation_data_t * l_mcc_record;\n        opj_mct_data_t * l_mct_data;\n        OPJ_UINT32 l_nb_collections;\n        OPJ_UINT32 l_nb_comps;\n        OPJ_UINT32 l_nb_bytes_by_comp;\n        OPJ_BOOL l_new_mcc = OPJ_FALSE;\n\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?\n                        &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number] :\n                        p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n        if (p_header_size < 2) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        /* first marker */\n        opj_read_bytes(p_header_data,&l_tmp,2);                         /* Zmcc */\n        p_header_data += 2;\n        if (l_tmp != 0) {\n                opj_event_msg(p_manager, EVT_WARNING, \"Cannot take in charge multiple data spanning\\n\");\n                return OPJ_TRUE;\n        }\n\n        if (p_header_size < 7) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(p_header_data,&l_indix,1); /* Imcc -> no need for other values, take the first */\n        ++p_header_data;\n\n        l_mcc_record = l_tcp->m_mcc_records;\n\n        for(i=0;i<l_tcp->m_nb_mcc_records;++i) {\n                if (l_mcc_record->m_index == l_indix) {\n                        break;\n                }\n                ++l_mcc_record;\n        }\n\n        /** NOT FOUND */\n        if (i == l_tcp->m_nb_mcc_records) {\n                if (l_tcp->m_nb_mcc_records == l_tcp->m_nb_max_mcc_records) {\n                        opj_simple_mcc_decorrelation_data_t *new_mcc_records;\n                        l_tcp->m_nb_max_mcc_records += OPJ_J2K_MCC_DEFAULT_NB_RECORDS;\n\n                        new_mcc_records = (opj_simple_mcc_decorrelation_data_t *) opj_realloc(\n                                        l_tcp->m_mcc_records, l_tcp->m_nb_max_mcc_records * sizeof(opj_simple_mcc_decorrelation_data_t));\n                        if (! new_mcc_records) {\n                                opj_free(l_tcp->m_mcc_records);\n                                l_tcp->m_mcc_records = NULL;\n                                l_tcp->m_nb_max_mcc_records = 0;\n                                l_tcp->m_nb_mcc_records = 0;\n                                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read MCC marker\\n\");\n                                return OPJ_FALSE;\n                        }\n                        l_tcp->m_mcc_records = new_mcc_records;\n                        l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;\n                        memset(l_mcc_record,0,(l_tcp->m_nb_max_mcc_records-l_tcp->m_nb_mcc_records) * sizeof(opj_simple_mcc_decorrelation_data_t));\n                }\n                l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;\n                l_new_mcc = OPJ_TRUE;\n        }\n        l_mcc_record->m_index = l_indix;\n\n        /* only one marker atm */\n        opj_read_bytes(p_header_data,&l_tmp,2);                         /* Ymcc */\n        p_header_data+=2;\n        if (l_tmp != 0) {\n                opj_event_msg(p_manager, EVT_WARNING, \"Cannot take in charge multiple data spanning\\n\");\n                return OPJ_TRUE;\n        }\n\n        opj_read_bytes(p_header_data,&l_nb_collections,2);                              /* Qmcc -> number of collections -> 1 */\n        p_header_data+=2;\n\n        if (l_nb_collections > 1) {\n                opj_event_msg(p_manager, EVT_WARNING, \"Cannot take in charge multiple collections\\n\");\n                return OPJ_TRUE;\n        }\n\n        p_header_size -= 7;\n\n        for (i=0;i<l_nb_collections;++i) {\n                if (p_header_size < 3) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n                        return OPJ_FALSE;\n                }\n\n                opj_read_bytes(p_header_data,&l_tmp,1); /* Xmcci type of component transformation -> array based decorrelation */\n                ++p_header_data;\n\n                if (l_tmp != 1) {\n                        opj_event_msg(p_manager, EVT_WARNING, \"Cannot take in charge collections other than array decorrelation\\n\");\n                        return OPJ_TRUE;\n                }\n\n                opj_read_bytes(p_header_data,&l_nb_comps,2);\n\n                p_header_data+=2;\n                p_header_size-=3;\n\n                l_nb_bytes_by_comp = 1 + (l_nb_comps>>15);\n                l_mcc_record->m_nb_comps = l_nb_comps & 0x7fff;\n\n                if (p_header_size < (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2)) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n                        return OPJ_FALSE;\n                }\n\n                p_header_size -= (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2);\n\n                for (j=0;j<l_mcc_record->m_nb_comps;++j) {\n                        opj_read_bytes(p_header_data,&l_tmp,l_nb_bytes_by_comp);        /* Cmccij Component offset*/\n                        p_header_data+=l_nb_bytes_by_comp;\n\n                        if (l_tmp != j) {\n                                opj_event_msg(p_manager, EVT_WARNING, \"Cannot take in charge collections with indix shuffle\\n\");\n                                return OPJ_TRUE;\n                        }\n                }\n\n                opj_read_bytes(p_header_data,&l_nb_comps,2);\n                p_header_data+=2;\n\n                l_nb_bytes_by_comp = 1 + (l_nb_comps>>15);\n                l_nb_comps &= 0x7fff;\n\n                if (l_nb_comps != l_mcc_record->m_nb_comps) {\n                        opj_event_msg(p_manager, EVT_WARNING, \"Cannot take in charge collections without same number of indixes\\n\");\n                        return OPJ_TRUE;\n                }\n\n                if (p_header_size < (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3)) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n                        return OPJ_FALSE;\n                }\n\n                p_header_size -= (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3);\n\n                for (j=0;j<l_mcc_record->m_nb_comps;++j) {\n                        opj_read_bytes(p_header_data,&l_tmp,l_nb_bytes_by_comp);        /* Wmccij Component offset*/\n                        p_header_data+=l_nb_bytes_by_comp;\n\n                        if (l_tmp != j) {\n                                opj_event_msg(p_manager, EVT_WARNING, \"Cannot take in charge collections with indix shuffle\\n\");\n                                return OPJ_TRUE;\n                        }\n                }\n\n                opj_read_bytes(p_header_data,&l_tmp,3); /* Wmccij Component offset*/\n                p_header_data += 3;\n\n                l_mcc_record->m_is_irreversible = ! ((l_tmp>>16) & 1);\n                l_mcc_record->m_decorrelation_array = 00;\n                l_mcc_record->m_offset_array = 00;\n\n                l_indix = l_tmp & 0xff;\n                if (l_indix != 0) {\n                        l_mct_data = l_tcp->m_mct_records;\n                        for (j=0;j<l_tcp->m_nb_mct_records;++j) {\n                                if (l_mct_data->m_index == l_indix) {\n                                        l_mcc_record->m_decorrelation_array = l_mct_data;\n                                        break;\n                                }\n                                ++l_mct_data;\n                        }\n\n                        if (l_mcc_record->m_decorrelation_array == 00) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n                                return OPJ_FALSE;\n                        }\n                }\n\n                l_indix = (l_tmp >> 8) & 0xff;\n                if (l_indix != 0) {\n                        l_mct_data = l_tcp->m_mct_records;\n                        for (j=0;j<l_tcp->m_nb_mct_records;++j) {\n                                if (l_mct_data->m_index == l_indix) {\n                                        l_mcc_record->m_offset_array = l_mct_data;\n                                        break;\n                                }\n                                ++l_mct_data;\n                        }\n\n                        if (l_mcc_record->m_offset_array == 00) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n                                return OPJ_FALSE;\n                        }\n                }\n        }\n\n        if (p_header_size != 0) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCC marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (l_new_mcc) {\n                ++l_tcp->m_nb_mcc_records;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_mco(     opj_j2k_t *p_j2k,\n                                                struct opj_stream_private *p_stream,\n                                                struct opj_event_mgr * p_manager\n                                  )\n{\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_mco_size;\n        opj_tcp_t * l_tcp = 00;\n        opj_simple_mcc_decorrelation_data_t * l_mcc_record;\n        OPJ_UINT32 i;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_tcp =&(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);\n\t\n        l_mco_size = 5 + l_tcp->m_nb_mcc_records;\n        if (l_mco_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mco_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write MCO marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mco_size;\n        }\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n\n        opj_write_bytes(l_current_data,J2K_MS_MCO,2);                   /* MCO */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_mco_size-2,2);                 /* Lmco */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_tcp->m_nb_mcc_records,1);      /* Nmco : only one transform stage*/\n        ++l_current_data;\n\n        l_mcc_record = l_tcp->m_mcc_records;\n        for (i=0;i<l_tcp->m_nb_mcc_records;++i) {\n                opj_write_bytes(l_current_data,l_mcc_record->m_index,1);/* Imco -> use the mcc indicated by 1*/\n                ++l_current_data;\n                ++l_mcc_record;\n        }\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_mco_size,p_manager) != l_mco_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a MCO marker (Multiple Component Transform Ordering)\n *\n * @param       p_header_data   the data contained in the MCO box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the MCO marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_mco (      opj_j2k_t *p_j2k,\n                                                                    OPJ_BYTE * p_header_data,\n                                                                    OPJ_UINT32 p_header_size,\n                                                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_UINT32 l_tmp, i;\n        OPJ_UINT32 l_nb_stages;\n        opj_tcp_t * l_tcp;\n        opj_tccp_t * l_tccp;\n        opj_image_t * l_image;\n\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_image = p_j2k->m_private_image;\n        l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?\n                        &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number] :\n                        p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n        if (p_header_size < 1) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading MCO marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(p_header_data,&l_nb_stages,1);                           /* Nmco : only one transform stage*/\n        ++p_header_data;\n\n        if (l_nb_stages > 1) {\n                opj_event_msg(p_manager, EVT_WARNING, \"Cannot take in charge multiple transformation stages.\\n\");\n                return OPJ_TRUE;\n        }\n\n        if (p_header_size != l_nb_stages + 1) {\n                opj_event_msg(p_manager, EVT_WARNING, \"Error reading MCO marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        l_tccp = l_tcp->tccps;\n\n        for (i=0;i<l_image->numcomps;++i) {\n                l_tccp->m_dc_level_shift = 0;\n                ++l_tccp;\n        }\n\n        if (l_tcp->m_mct_decoding_matrix) {\n                opj_free(l_tcp->m_mct_decoding_matrix);\n                l_tcp->m_mct_decoding_matrix = 00;\n        }\n\n        for (i=0;i<l_nb_stages;++i) {\n                opj_read_bytes(p_header_data,&l_tmp,1);\n                ++p_header_data;\n\n                if (! opj_j2k_add_mct(l_tcp,p_j2k->m_private_image,l_tmp)) {\n                        return OPJ_FALSE;\n                }\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_add_mct(opj_tcp_t * p_tcp, opj_image_t * p_image, OPJ_UINT32 p_index)\n{\n        OPJ_UINT32 i;\n        opj_simple_mcc_decorrelation_data_t * l_mcc_record;\n        opj_mct_data_t * l_deco_array, * l_offset_array;\n        OPJ_UINT32 l_data_size,l_mct_size, l_offset_size;\n        OPJ_UINT32 l_nb_elem;\n        OPJ_UINT32 * l_offset_data, * l_current_offset_data;\n        opj_tccp_t * l_tccp;\n\n        /* preconditions */\n        assert(p_tcp != 00);\n\n        l_mcc_record = p_tcp->m_mcc_records;\n\n        for (i=0;i<p_tcp->m_nb_mcc_records;++i) {\n                if (l_mcc_record->m_index == p_index) {\n                        break;\n                }\n        }\n\n        if (i==p_tcp->m_nb_mcc_records) {\n                /** element discarded **/\n                return OPJ_TRUE;\n        }\n\n        if (l_mcc_record->m_nb_comps != p_image->numcomps) {\n                /** do not support number of comps != image */\n                return OPJ_TRUE;\n        }\n\n        l_deco_array = l_mcc_record->m_decorrelation_array;\n\n        if (l_deco_array) {\n                l_data_size = MCT_ELEMENT_SIZE[l_deco_array->m_element_type] * p_image->numcomps * p_image->numcomps;\n                if (l_deco_array->m_data_size != l_data_size) {\n                        return OPJ_FALSE;\n                }\n\n                l_nb_elem = p_image->numcomps * p_image->numcomps;\n                l_mct_size = l_nb_elem * (OPJ_UINT32)sizeof(OPJ_FLOAT32);\n                p_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32*)opj_malloc(l_mct_size);\n\n                if (! p_tcp->m_mct_decoding_matrix ) {\n                        return OPJ_FALSE;\n                }\n\n                j2k_mct_read_functions_to_float[l_deco_array->m_element_type](l_deco_array->m_data,p_tcp->m_mct_decoding_matrix,l_nb_elem);\n        }\n\n        l_offset_array = l_mcc_record->m_offset_array;\n\n        if (l_offset_array) {\n                l_data_size = MCT_ELEMENT_SIZE[l_offset_array->m_element_type] * p_image->numcomps;\n                if (l_offset_array->m_data_size != l_data_size) {\n                        return OPJ_FALSE;\n                }\n\n                l_nb_elem = p_image->numcomps;\n                l_offset_size = l_nb_elem * (OPJ_UINT32)sizeof(OPJ_UINT32);\n                l_offset_data = (OPJ_UINT32*)opj_malloc(l_offset_size);\n\n                if (! l_offset_data ) {\n                        return OPJ_FALSE;\n                }\n\n                j2k_mct_read_functions_to_int32[l_offset_array->m_element_type](l_offset_array->m_data,l_offset_data,l_nb_elem);\n\n                l_tccp = p_tcp->tccps;\n                l_current_offset_data = l_offset_data;\n\n                for (i=0;i<p_image->numcomps;++i) {\n                        l_tccp->m_dc_level_shift = (OPJ_INT32)*(l_current_offset_data++);\n                        ++l_tccp;\n                }\n\n                opj_free(l_offset_data);\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_cbd( opj_j2k_t *p_j2k,\n                                                struct opj_stream_private *p_stream,\n                                                struct opj_event_mgr * p_manager )\n{\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_cbd_size;\n        OPJ_BYTE * l_current_data = 00;\n        opj_image_t *l_image = 00;\n        opj_image_comp_t * l_comp = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_image = p_j2k->m_private_image;\n        l_cbd_size = 6 + p_j2k->m_private_image->numcomps;\n\n        if (l_cbd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_cbd_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to write CBD marker\\n\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_cbd_size;\n        }\n\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        opj_write_bytes(l_current_data,J2K_MS_CBD,2);                   /* CBD */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_cbd_size-2,2);                 /* L_CBD */\n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_image->numcomps, 2);           /* Ncbd */\n        l_current_data+=2;\n\n        l_comp = l_image->comps;\n\n        for (i=0;i<l_image->numcomps;++i) {\n                opj_write_bytes(l_current_data, (l_comp->sgnd << 7) | (l_comp->prec - 1), 1);           /* Component bit depth */\n                ++l_current_data;\n\n                ++l_comp;\n        }\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_cbd_size,p_manager) != l_cbd_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\n/**\n * Reads a CBD marker (Component bit depth definition)\n * @param       p_header_data   the data contained in the CBD box.\n * @param       p_j2k                   the jpeg2000 codec.\n * @param       p_header_size   the size of the data contained in the CBD marker.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_read_cbd (      opj_j2k_t *p_j2k,\n                                                                OPJ_BYTE * p_header_data,\n                                                                OPJ_UINT32 p_header_size,\n                                                                opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_UINT32 l_nb_comp,l_num_comp;\n        OPJ_UINT32 l_comp_def;\n        OPJ_UINT32 i;\n        opj_image_comp_t * l_comp = 00;\n\n        /* preconditions */\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        l_num_comp = p_j2k->m_private_image->numcomps;\n\n        if (p_header_size != (p_j2k->m_private_image->numcomps + 2)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Crror reading CBD marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(p_header_data,&l_nb_comp,2);                             /* Ncbd */\n        p_header_data+=2;\n\n        if (l_nb_comp != l_num_comp) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Crror reading CBD marker\\n\");\n                return OPJ_FALSE;\n        }\n\n        l_comp = p_j2k->m_private_image->comps;\n        for (i=0;i<l_num_comp;++i) {\n                opj_read_bytes(p_header_data,&l_comp_def,1);                    /* Component bit depth */\n                ++p_header_data;\n        l_comp->sgnd = (l_comp_def>>7) & 1;\n                l_comp->prec = (l_comp_def&0x7f) + 1;\n                ++l_comp;\n        }\n\n        return OPJ_TRUE;\n}\n\n/* ----------------------------------------------------------------------- */\n/* J2K / JPT decoder interface                                             */\n/* ----------------------------------------------------------------------- */\n\nvoid opj_j2k_setup_decoder(opj_j2k_t *j2k, opj_dparameters_t *parameters)\n{\n        if(j2k && parameters) {\n                j2k->m_cp.m_specific_param.m_dec.m_layer = parameters->cp_layer;\n                j2k->m_cp.m_specific_param.m_dec.m_reduce = parameters->cp_reduce;\n\n#ifdef USE_JPWL\n                j2k->m_cp.correct = parameters->jpwl_correct;\n                j2k->m_cp.exp_comps = parameters->jpwl_exp_comps;\n                j2k->m_cp.max_tiles = parameters->jpwl_max_tiles;\n#endif /* USE_JPWL */\n        }\n}\n\nOPJ_BOOL opj_j2k_set_threads(opj_j2k_t *j2k, OPJ_UINT32 num_threads)\n{\n        if( opj_has_thread_support() )\n        {\n            opj_thread_pool_destroy(j2k->m_tp);\n            j2k->m_tp = NULL;\n            if (num_threads <= (OPJ_UINT32)INT_MAX ) {\n                j2k->m_tp = opj_thread_pool_create((int)num_threads);\n            }\n            if( j2k->m_tp == NULL )\n            {\n                j2k->m_tp = opj_thread_pool_create(0);\n                return OPJ_FALSE;\n            }\n            return OPJ_TRUE;\n        }\n        return OPJ_FALSE;\n}\n\nstatic int opj_j2k_get_default_thread_count()\n{\n    const char* num_threads = getenv(\"OPJ_NUM_THREADS\");\n    if( num_threads == NULL || !opj_has_thread_support() )\n        return 0;\n    if( strcmp(num_threads, \"ALL_CPUS\") == 0 )\n        return opj_get_num_cpus();\n    return atoi(num_threads);\n}\n\n/* ----------------------------------------------------------------------- */\n/* J2K encoder interface                                                       */\n/* ----------------------------------------------------------------------- */\n\nopj_j2k_t* opj_j2k_create_compress(void)\n{\n        opj_j2k_t *l_j2k = (opj_j2k_t*) opj_calloc(1,sizeof(opj_j2k_t));\n        if (!l_j2k) {\n                return NULL;\n        }\n\n\n        l_j2k->m_is_decoder = 0;\n        l_j2k->m_cp.m_is_decoder = 0;\n\n        l_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *) opj_malloc(OPJ_J2K_DEFAULT_HEADER_SIZE);\n        if (! l_j2k->m_specific_param.m_encoder.m_header_tile_data) {\n                opj_j2k_destroy(l_j2k);\n                return NULL;\n        }\n\n        l_j2k->m_specific_param.m_encoder.m_header_tile_data_size = OPJ_J2K_DEFAULT_HEADER_SIZE;\n\n        /* validation list creation*/\n        l_j2k->m_validation_list = opj_procedure_list_create();\n        if (! l_j2k->m_validation_list) {\n                opj_j2k_destroy(l_j2k);\n                return NULL;\n        }\n\n        /* execution list creation*/\n        l_j2k->m_procedure_list = opj_procedure_list_create();\n        if (! l_j2k->m_procedure_list) {\n                opj_j2k_destroy(l_j2k);\n                return NULL;\n        }\n\n        l_j2k->m_tp = opj_thread_pool_create(opj_j2k_get_default_thread_count());\n        if( !l_j2k->m_tp )\n        {\n            l_j2k->m_tp = opj_thread_pool_create(0);\n        }\n        if( !l_j2k->m_tp )\n        {\n            opj_j2k_destroy(l_j2k);\n            return NULL;\n        }\n\n        return l_j2k;\n}\n\nstatic int opj_j2k_initialise_4K_poc(opj_poc_t *POC, int numres){\n    POC[0].tile  = 1;\n    POC[0].resno0  = 0;\n    POC[0].compno0 = 0;\n    POC[0].layno1  = 1;\n    POC[0].resno1  = (OPJ_UINT32)(numres-1);\n    POC[0].compno1 = 3;\n    POC[0].prg1 = OPJ_CPRL;\n    POC[1].tile  = 1;\n    POC[1].resno0  = (OPJ_UINT32)(numres-1);\n    POC[1].compno0 = 0;\n    POC[1].layno1  = 1;\n    POC[1].resno1  = (OPJ_UINT32)numres;\n    POC[1].compno1 = 3;\n    POC[1].prg1 = OPJ_CPRL;\n    return 2;\n}\n\nstatic void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters, opj_image_t *image, opj_event_mgr_t *p_manager)\n{\n    /* Configure cinema parameters */\n    int i;\n\n    /* No tiling */\n    parameters->tile_size_on = OPJ_FALSE;\n    parameters->cp_tdx=1;\n    parameters->cp_tdy=1;\n\n    /* One tile part for each component */\n    parameters->tp_flag = 'C';\n    parameters->tp_on = 1;\n\n    /* Tile and Image shall be at (0,0) */\n    parameters->cp_tx0 = 0;\n    parameters->cp_ty0 = 0;\n    parameters->image_offset_x0 = 0;\n    parameters->image_offset_y0 = 0;\n\n    /* Codeblock size= 32*32 */\n    parameters->cblockw_init = 32;\n    parameters->cblockh_init = 32;\n\n    /* Codeblock style: no mode switch enabled */\n    parameters->mode = 0;\n\n    /* No ROI */\n    parameters->roi_compno = -1;\n\n    /* No subsampling */\n    parameters->subsampling_dx = 1;\n    parameters->subsampling_dy = 1;\n\n    /* 9-7 transform */\n    parameters->irreversible = 1;\n\n    /* Number of layers */\n    if (parameters->tcp_numlayers > 1){\n        opj_event_msg(p_manager, EVT_WARNING,\n                \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                \"1 single quality layer\"\n                \"-> Number of layers forced to 1 (rather than %d)\\n\"\n                \"-> Rate of the last layer (%3.1f) will be used\",\n                parameters->tcp_numlayers, parameters->tcp_rates[parameters->tcp_numlayers-1]);\n        parameters->tcp_rates[0] = parameters->tcp_rates[parameters->tcp_numlayers-1];\n        parameters->tcp_numlayers = 1;\n    }\n\n    /* Resolution levels */\n    switch (parameters->rsiz){\n    case OPJ_PROFILE_CINEMA_2K:\n        if(parameters->numresolution > 6){\n            opj_event_msg(p_manager, EVT_WARNING,\n                    \"JPEG 2000 Profile-3 (2k dc profile) requires:\\n\"\n                    \"Number of decomposition levels <= 5\\n\"\n                    \"-> Number of decomposition levels forced to 5 (rather than %d)\\n\",\n                    parameters->numresolution+1);\n            parameters->numresolution = 6;\n        }\n        break;\n    case OPJ_PROFILE_CINEMA_4K:\n        if(parameters->numresolution < 2){\n            opj_event_msg(p_manager, EVT_WARNING,\n                    \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                    \"Number of decomposition levels >= 1 && <= 6\\n\"\n                    \"-> Number of decomposition levels forced to 1 (rather than %d)\\n\",\n                    parameters->numresolution+1);\n            parameters->numresolution = 1;\n        }else if(parameters->numresolution > 7){\n            opj_event_msg(p_manager, EVT_WARNING,\n                    \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                    \"Number of decomposition levels >= 1 && <= 6\\n\"\n                    \"-> Number of decomposition levels forced to 6 (rather than %d)\\n\",\n                    parameters->numresolution+1);\n            parameters->numresolution = 7;\n        }\n        break;\n    default :\n        break;\n    }\n\n    /* Precincts */\n    parameters->csty |= 0x01;\n    parameters->res_spec = parameters->numresolution-1;\n    for (i = 0; i<parameters->res_spec; i++) {\n        parameters->prcw_init[i] = 256;\n        parameters->prch_init[i] = 256;\n    }\n\n    /* The progression order shall be CPRL */\n    parameters->prog_order = OPJ_CPRL;\n\n    /* Progression order changes for 4K, disallowed for 2K */\n    if (parameters->rsiz == OPJ_PROFILE_CINEMA_4K) {\n        parameters->numpocs = (OPJ_UINT32)opj_j2k_initialise_4K_poc(parameters->POC,parameters->numresolution);\n    } else {\n        parameters->numpocs = 0;\n    }\n\n    /* Limited bit-rate */\n    parameters->cp_disto_alloc = 1;\n    if (parameters->max_cs_size <= 0) {\n        /* No rate has been introduced, 24 fps is assumed */\n        parameters->max_cs_size = OPJ_CINEMA_24_CS;\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1302083 compressed bytes @ 24fps\\n\"\n                      \"As no rate has been given, this limit will be used.\\n\");\n    } else if (parameters->max_cs_size > OPJ_CINEMA_24_CS) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1302083 compressed bytes @ 24fps\\n\"\n                      \"-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\\n\");\n        parameters->max_cs_size = OPJ_CINEMA_24_CS;\n    }\n\n    if (parameters->max_comp_size <= 0) {\n        /* No rate has been introduced, 24 fps is assumed */\n        parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1041666 compressed bytes @ 24fps\\n\"\n                      \"As no rate has been given, this limit will be used.\\n\");\n    } else if (parameters->max_comp_size > OPJ_CINEMA_24_COMP) {\n        opj_event_msg(p_manager, EVT_WARNING,\n                      \"JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\\n\"\n                      \"Maximum 1041666 compressed bytes @ 24fps\\n\"\n                      \"-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\\n\");\n        parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n    }\n\n    parameters->tcp_rates[0] = (OPJ_FLOAT32) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec)/\n            (OPJ_FLOAT32)(((OPJ_UINT32)parameters->max_cs_size) * 8 * image->comps[0].dx * image->comps[0].dy);\n\n}\n\nstatic OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image, OPJ_UINT16 rsiz, opj_event_mgr_t *p_manager)\n{\n    OPJ_UINT32 i;\n\n    /* Number of components */\n    if (image->numcomps != 3){\n        opj_event_msg(p_manager, EVT_WARNING,\n                \"JPEG 2000 Profile-3 (2k dc profile) requires:\\n\"\n                \"3 components\"\n                \"-> Number of components of input image (%d) is not compliant\\n\"\n                \"-> Non-profile-3 codestream will be generated\\n\",\n                image->numcomps);\n        return OPJ_FALSE;\n    }\n\n    /* Bitdepth */\n    for (i = 0; i < image->numcomps; i++) {\n        if ((image->comps[i].bpp != 12) | (image->comps[i].sgnd)){\n            char signed_str[] = \"signed\";\n            char unsigned_str[] = \"unsigned\";\n            char *tmp_str = image->comps[i].sgnd?signed_str:unsigned_str;\n            opj_event_msg(p_manager, EVT_WARNING,\n                    \"JPEG 2000 Profile-3 (2k dc profile) requires:\\n\"\n                    \"Precision of each component shall be 12 bits unsigned\"\n                    \"-> At least component %d of input image (%d bits, %s) is not compliant\\n\"\n                    \"-> Non-profile-3 codestream will be generated\\n\",\n                    i,image->comps[i].bpp, tmp_str);\n            return OPJ_FALSE;\n        }\n    }\n\n    /* Image size */\n    switch (rsiz){\n    case OPJ_PROFILE_CINEMA_2K:\n        if (((image->comps[0].w > 2048) | (image->comps[0].h > 1080))){\n            opj_event_msg(p_manager, EVT_WARNING,\n                    \"JPEG 2000 Profile-3 (2k dc profile) requires:\\n\"\n                    \"width <= 2048 and height <= 1080\\n\"\n                    \"-> Input image size %d x %d is not compliant\\n\"\n                    \"-> Non-profile-3 codestream will be generated\\n\",\n                    image->comps[0].w,image->comps[0].h);\n            return OPJ_FALSE;\n        }\n        break;\n    case OPJ_PROFILE_CINEMA_4K:\n        if (((image->comps[0].w > 4096) | (image->comps[0].h > 2160))){\n            opj_event_msg(p_manager, EVT_WARNING,\n                    \"JPEG 2000 Profile-4 (4k dc profile) requires:\\n\"\n                    \"width <= 4096 and height <= 2160\\n\"\n                    \"-> Image size %d x %d is not compliant\\n\"\n                    \"-> Non-profile-4 codestream will be generated\\n\",\n                    image->comps[0].w,image->comps[0].h);\n            return OPJ_FALSE;\n        }\n        break;\n    default :\n        break;\n    }\n\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_setup_encoder(     opj_j2k_t *p_j2k,\n                                                    opj_cparameters_t *parameters,\n                                                    opj_image_t *image,\n                                                    opj_event_mgr_t * p_manager)\n{\n        OPJ_UINT32 i, j, tileno, numpocs_tile;\n        opj_cp_t *cp = 00;\n\n        if(!p_j2k || !parameters || ! image) {\n                return OPJ_FALSE;\n        }\n\n        if ((parameters->numresolution <= 0) || (parameters->numresolution > OPJ_J2K_MAXRLVLS)) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Invalid number of resolutions : %d not in range [1,%d]\\n\", parameters->numresolution, OPJ_J2K_MAXRLVLS);\n            return OPJ_FALSE;\n        }\n\n        /* keep a link to cp so that we can destroy it later in j2k_destroy_compress */\n        cp = &(p_j2k->m_cp);\n\n        /* set default values for cp */\n        cp->tw = 1;\n        cp->th = 1;\n\n        /* FIXME ADE: to be removed once deprecated cp_cinema and cp_rsiz have been removed */\n        if (parameters->rsiz == OPJ_PROFILE_NONE) { /* consider deprecated fields only if RSIZ has not been set */\n            OPJ_BOOL deprecated_used = OPJ_FALSE;\n            switch (parameters->cp_cinema){\n            case OPJ_CINEMA2K_24:\n                parameters->rsiz = OPJ_PROFILE_CINEMA_2K;\n                parameters->max_cs_size = OPJ_CINEMA_24_CS;\n                parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n                deprecated_used = OPJ_TRUE;\n                break;\n            case OPJ_CINEMA2K_48:\n                parameters->rsiz = OPJ_PROFILE_CINEMA_2K;\n                parameters->max_cs_size = OPJ_CINEMA_48_CS;\n                parameters->max_comp_size = OPJ_CINEMA_48_COMP;\n                deprecated_used = OPJ_TRUE;\n                break;\n            case OPJ_CINEMA4K_24:\n                parameters->rsiz = OPJ_PROFILE_CINEMA_4K;\n                parameters->max_cs_size = OPJ_CINEMA_24_CS;\n                parameters->max_comp_size = OPJ_CINEMA_24_COMP;\n                deprecated_used = OPJ_TRUE;\n                break;\n            case OPJ_OFF:\n            default:\n                break;\n            }\n            switch (parameters->cp_rsiz){\n            case OPJ_CINEMA2K:\n                parameters->rsiz = OPJ_PROFILE_CINEMA_2K;\n                deprecated_used = OPJ_TRUE;\n                break;\n            case OPJ_CINEMA4K:\n                parameters->rsiz = OPJ_PROFILE_CINEMA_4K;\n                deprecated_used = OPJ_TRUE;\n                break;\n            case OPJ_MCT:\n                parameters->rsiz = OPJ_PROFILE_PART2 | OPJ_EXTENSION_MCT;\n                deprecated_used = OPJ_TRUE;\n            case OPJ_STD_RSIZ:\n            default:\n                break;\n            }\n            if (deprecated_used) {\n                opj_event_msg(p_manager, EVT_WARNING,\n                        \"Deprecated fields cp_cinema or cp_rsiz are used\\n\"\n                        \"Please consider using only the rsiz field\\n\"\n                        \"See openjpeg.h documentation for more details\\n\");\n            }\n        }\n\n        /* see if max_codestream_size does limit input rate */\n        if (parameters->max_cs_size <= 0) {\n            if (parameters->tcp_rates[parameters->tcp_numlayers-1] > 0) {\n                OPJ_FLOAT32 temp_size;\n                temp_size =(OPJ_FLOAT32)(image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec)/\n                        (parameters->tcp_rates[parameters->tcp_numlayers-1] * 8 * (OPJ_FLOAT32)image->comps[0].dx * (OPJ_FLOAT32)image->comps[0].dy);\n                parameters->max_cs_size = (int) floor(temp_size);\n            } else {\n                parameters->max_cs_size = 0;\n            }\n        } else {\n            OPJ_FLOAT32 temp_rate;\n            OPJ_BOOL cap = OPJ_FALSE;\n            temp_rate = (OPJ_FLOAT32) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec)/\n                    (OPJ_FLOAT32)(((OPJ_UINT32)parameters->max_cs_size) * 8 * image->comps[0].dx * image->comps[0].dy);\n            for (i = 0; i < (OPJ_UINT32) parameters->tcp_numlayers; i++) {\n                if (parameters->tcp_rates[i] < temp_rate) {\n                    parameters->tcp_rates[i] = temp_rate;\n                    cap = OPJ_TRUE;\n                }\n            }\n            if (cap) {\n                opj_event_msg(p_manager, EVT_WARNING,\n                        \"The desired maximum codestream size has limited\\n\"\n                        \"at least one of the desired quality layers\\n\");\n            }\n        }\n\n        /* Manage profiles and applications and set RSIZ */\n        /* set cinema parameters if required */\n        if (OPJ_IS_CINEMA(parameters->rsiz)){\n            if ((parameters->rsiz == OPJ_PROFILE_CINEMA_S2K)\n                    || (parameters->rsiz == OPJ_PROFILE_CINEMA_S4K)){\n                opj_event_msg(p_manager, EVT_WARNING,\n                        \"JPEG 2000 Scalable Digital Cinema profiles not yet supported\\n\");\n                parameters->rsiz = OPJ_PROFILE_NONE;\n            } else {\n                opj_j2k_set_cinema_parameters(parameters,image,p_manager);\n                if (!opj_j2k_is_cinema_compliant(image,parameters->rsiz,p_manager)) {\n                    parameters->rsiz = OPJ_PROFILE_NONE;\n                }\n            }\n        } else if (OPJ_IS_STORAGE(parameters->rsiz)) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                    \"JPEG 2000 Long Term Storage profile not yet supported\\n\");\n            parameters->rsiz = OPJ_PROFILE_NONE;\n        } else if (OPJ_IS_BROADCAST(parameters->rsiz)) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                    \"JPEG 2000 Broadcast profiles not yet supported\\n\");\n            parameters->rsiz = OPJ_PROFILE_NONE;\n        } else if (OPJ_IS_IMF(parameters->rsiz)) {\n            opj_event_msg(p_manager, EVT_WARNING,\n                    \"JPEG 2000 IMF profiles not yet supported\\n\");\n            parameters->rsiz = OPJ_PROFILE_NONE;\n        } else if (OPJ_IS_PART2(parameters->rsiz)) {\n            if (parameters->rsiz == ((OPJ_PROFILE_PART2) | (OPJ_EXTENSION_NONE))) {\n                opj_event_msg(p_manager, EVT_WARNING,\n                              \"JPEG 2000 Part-2 profile defined\\n\"\n                              \"but no Part-2 extension enabled.\\n\"\n                              \"Profile set to NONE.\\n\");\n                parameters->rsiz = OPJ_PROFILE_NONE;\n            } else if (parameters->rsiz != ((OPJ_PROFILE_PART2) | (OPJ_EXTENSION_MCT))) {\n                opj_event_msg(p_manager, EVT_WARNING,\n                              \"Unsupported Part-2 extension enabled\\n\"\n                              \"Profile set to NONE.\\n\");\n                parameters->rsiz = OPJ_PROFILE_NONE;\n            }\n        }\n\n        /*\n        copy user encoding parameters\n        */\n        cp->m_specific_param.m_enc.m_max_comp_size = (OPJ_UINT32)parameters->max_comp_size;\n        cp->rsiz = parameters->rsiz;\n        cp->m_specific_param.m_enc.m_disto_alloc = (OPJ_UINT32)parameters->cp_disto_alloc & 1u;\n        cp->m_specific_param.m_enc.m_fixed_alloc = (OPJ_UINT32)parameters->cp_fixed_alloc & 1u;\n        cp->m_specific_param.m_enc.m_fixed_quality = (OPJ_UINT32)parameters->cp_fixed_quality & 1u;\n\n        /* mod fixed_quality */\n        if (parameters->cp_fixed_alloc && parameters->cp_matrice) {\n                size_t array_size = (size_t)parameters->tcp_numlayers * (size_t)parameters->numresolution * 3 * sizeof(OPJ_INT32);\n                cp->m_specific_param.m_enc.m_matrice = (OPJ_INT32 *) opj_malloc(array_size);\n\t\t\t\t\t\t\t\tif (!cp->m_specific_param.m_enc.m_matrice) {\n\t\t\t\t\t\t\t\t        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to allocate copy of user encoding parameters matrix \\n\");\n\t\t\t\t\t\t\t\t        return OPJ_FALSE;\n\t\t\t\t\t\t\t\t}\n                memcpy(cp->m_specific_param.m_enc.m_matrice, parameters->cp_matrice, array_size);\n        }\n\n        /* tiles */\n        cp->tdx = (OPJ_UINT32)parameters->cp_tdx;\n        cp->tdy = (OPJ_UINT32)parameters->cp_tdy;\n\n        /* tile offset */\n        cp->tx0 = (OPJ_UINT32)parameters->cp_tx0;\n        cp->ty0 = (OPJ_UINT32)parameters->cp_ty0;\n\n        /* comment string */\n        if(parameters->cp_comment) {\n                cp->comment = (char*)opj_malloc(strlen(parameters->cp_comment) + 1U);\n\t\t\t\t\t\t\t\tif(!cp->comment) {\n\t\t\t\t\t\t\t\t        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to allocate copy of comment string\\n\");\n\t\t\t\t\t\t\t\t        return OPJ_FALSE;\n\t\t\t\t\t\t\t\t}\n                strcpy(cp->comment, parameters->cp_comment);\n        } else {\n                /* Create default comment for codestream */\n                const char comment[] = \"Created by OpenJPEG version \";\n                const size_t clen = strlen(comment);\n                const char *version = opj_version();\n\n                /* UniPG>> */\n#ifdef USE_JPWL\n                cp->comment = (char*)opj_malloc(clen+strlen(version)+11);\n\t\t\t\t\t\t\t\tif(!cp->comment) {\n\t\t\t\t\t\t\t\t        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to allocate comment string\\n\");\n\t\t\t\t\t\t\t\t        return OPJ_FALSE;\n\t\t\t\t\t\t\t\t}\n                sprintf(cp->comment,\"%s%s with JPWL\", comment, version);\n#else\n                cp->comment = (char*)opj_malloc(clen+strlen(version)+1);\n\t\t\t\t\t\t\t\tif(!cp->comment) {\n\t\t\t\t\t\t\t\t        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to allocate comment string\\n\");\n\t\t\t\t\t\t\t\t        return OPJ_FALSE;\n\t\t\t\t\t\t\t\t}\n                sprintf(cp->comment,\"%s%s\", comment, version);\n#endif\n                /* <<UniPG */\n\t\t\t\t}\n\n        /*\n        calculate other encoding parameters\n        */\n\n        if (parameters->tile_size_on) {\n                cp->tw = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(image->x1 - cp->tx0), (OPJ_INT32)cp->tdx);\n                cp->th = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(image->y1 - cp->ty0), (OPJ_INT32)cp->tdy);\n        } else {\n                cp->tdx = image->x1 - cp->tx0;\n                cp->tdy = image->y1 - cp->ty0;\n        }\n\n        if (parameters->tp_on) {\n                cp->m_specific_param.m_enc.m_tp_flag = (OPJ_BYTE)parameters->tp_flag;\n                cp->m_specific_param.m_enc.m_tp_on = 1;\n        }\n\n#ifdef USE_JPWL\n        /*\n        calculate JPWL encoding parameters\n        */\n\n        if (parameters->jpwl_epc_on) {\n                OPJ_INT32 i;\n\n                /* set JPWL on */\n                cp->epc_on = OPJ_TRUE;\n                cp->info_on = OPJ_FALSE; /* no informative technique */\n\n                /* set EPB on */\n                if ((parameters->jpwl_hprot_MH > 0) || (parameters->jpwl_hprot_TPH[0] > 0)) {\n                        cp->epb_on = OPJ_TRUE;\n\n                        cp->hprot_MH = parameters->jpwl_hprot_MH;\n                        for (i = 0; i < JPWL_MAX_NO_TILESPECS; i++) {\n                                cp->hprot_TPH_tileno[i] = parameters->jpwl_hprot_TPH_tileno[i];\n                                cp->hprot_TPH[i] = parameters->jpwl_hprot_TPH[i];\n                        }\n                        /* if tile specs are not specified, copy MH specs */\n                        if (cp->hprot_TPH[0] == -1) {\n                                cp->hprot_TPH_tileno[0] = 0;\n                                cp->hprot_TPH[0] = parameters->jpwl_hprot_MH;\n                        }\n                        for (i = 0; i < JPWL_MAX_NO_PACKSPECS; i++) {\n                                cp->pprot_tileno[i] = parameters->jpwl_pprot_tileno[i];\n                                cp->pprot_packno[i] = parameters->jpwl_pprot_packno[i];\n                                cp->pprot[i] = parameters->jpwl_pprot[i];\n                        }\n                }\n\n                /* set ESD writing */\n                if ((parameters->jpwl_sens_size == 1) || (parameters->jpwl_sens_size == 2)) {\n                        cp->esd_on = OPJ_TRUE;\n\n                        cp->sens_size = parameters->jpwl_sens_size;\n                        cp->sens_addr = parameters->jpwl_sens_addr;\n                        cp->sens_range = parameters->jpwl_sens_range;\n\n                        cp->sens_MH = parameters->jpwl_sens_MH;\n                        for (i = 0; i < JPWL_MAX_NO_TILESPECS; i++) {\n                                cp->sens_TPH_tileno[i] = parameters->jpwl_sens_TPH_tileno[i];\n                                cp->sens_TPH[i] = parameters->jpwl_sens_TPH[i];\n                        }\n                }\n\n                /* always set RED writing to false: we are at the encoder */\n                cp->red_on = OPJ_FALSE;\n\n        } else {\n                cp->epc_on = OPJ_FALSE;\n        }\n#endif /* USE_JPWL */\n\n        /* initialize the mutiple tiles */\n        /* ---------------------------- */\n        cp->tcps = (opj_tcp_t*) opj_calloc(cp->tw * cp->th, sizeof(opj_tcp_t));\n        if (!cp->tcps) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to allocate tile coding parameters\\n\");\n                return OPJ_FALSE;\n        }\n        if (parameters->numpocs) {\n                /* initialisation of POC */\n                opj_j2k_check_poc_val(parameters->POC,parameters->numpocs, (OPJ_UINT32)parameters->numresolution, image->numcomps, (OPJ_UINT32)parameters->tcp_numlayers, p_manager);\n                /* TODO MSD use the return value*/\n        }\n\n        for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {\n                opj_tcp_t *tcp = &cp->tcps[tileno];\n                tcp->numlayers = (OPJ_UINT32)parameters->tcp_numlayers;\n\n                for (j = 0; j < tcp->numlayers; j++) {\n                        if(OPJ_IS_CINEMA(cp->rsiz)){\n                                if (cp->m_specific_param.m_enc.m_fixed_quality) {\n                                        tcp->distoratio[j] = parameters->tcp_distoratio[j];\n                                }\n                                tcp->rates[j] = parameters->tcp_rates[j];\n                        }else{\n                                if (cp->m_specific_param.m_enc.m_fixed_quality) {       /* add fixed_quality */\n                                        tcp->distoratio[j] = parameters->tcp_distoratio[j];\n                                } else {\n                                        tcp->rates[j] = parameters->tcp_rates[j];\n                                }\n                        }\n                }\n\n                tcp->csty = (OPJ_UINT32)parameters->csty;\n                tcp->prg = parameters->prog_order;\n                tcp->mct = (OPJ_UINT32)parameters->tcp_mct;\n\n                numpocs_tile = 0;\n                tcp->POC = 0;\n\n                if (parameters->numpocs) {\n                        /* initialisation of POC */\n                        tcp->POC = 1;\n                        for (i = 0; i < parameters->numpocs; i++) {\n                                if (tileno + 1 == parameters->POC[i].tile )  {\n                                        opj_poc_t *tcp_poc = &tcp->pocs[numpocs_tile];\n\n                                        tcp_poc->resno0         = parameters->POC[numpocs_tile].resno0;\n                                        tcp_poc->compno0        = parameters->POC[numpocs_tile].compno0;\n                                        tcp_poc->layno1         = parameters->POC[numpocs_tile].layno1;\n                                        tcp_poc->resno1         = parameters->POC[numpocs_tile].resno1;\n                                        tcp_poc->compno1        = parameters->POC[numpocs_tile].compno1;\n                                        tcp_poc->prg1           = parameters->POC[numpocs_tile].prg1;\n                                        tcp_poc->tile           = parameters->POC[numpocs_tile].tile;\n\n                                        numpocs_tile++;\n                                }\n                        }\n\n                        tcp->numpocs = numpocs_tile -1 ;\n                }else{\n                        tcp->numpocs = 0;\n                }\n\n                tcp->tccps = (opj_tccp_t*) opj_calloc(image->numcomps, sizeof(opj_tccp_t));\n                if (!tcp->tccps) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to allocate tile component coding parameters\\n\");\n                        return OPJ_FALSE;\n                }\n                if (parameters->mct_data) {\n                      \n                    OPJ_UINT32 lMctSize = image->numcomps * image->numcomps * (OPJ_UINT32)sizeof(OPJ_FLOAT32);\n                    OPJ_FLOAT32 * lTmpBuf = (OPJ_FLOAT32*)opj_malloc(lMctSize);\n                    OPJ_INT32 * l_dc_shift = (OPJ_INT32 *) ((OPJ_BYTE *) parameters->mct_data + lMctSize);\n\n\t\t\t\t\t\t\t\t\t\tif (!lTmpBuf) {\n                            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to allocate temp buffer\\n\");\n                            return OPJ_FALSE;\n                    }\n\n                    tcp->mct = 2;\n                    tcp->m_mct_coding_matrix = (OPJ_FLOAT32*)opj_malloc(lMctSize);\n\t\t\t\t\t\t\t\t\t\tif (! tcp->m_mct_coding_matrix) {\n                            opj_free(lTmpBuf);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlTmpBuf = NULL;\n                            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to allocate encoder MCT coding matrix \\n\");\n                            return OPJ_FALSE;\n                    }\n                    memcpy(tcp->m_mct_coding_matrix,parameters->mct_data,lMctSize);\n                    memcpy(lTmpBuf,parameters->mct_data,lMctSize);\n\n                    tcp->m_mct_decoding_matrix = (OPJ_FLOAT32*)opj_malloc(lMctSize);\n\t\t\t\t\t\t\t\t\t\tif (! tcp->m_mct_decoding_matrix) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\topj_free(lTmpBuf);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlTmpBuf = NULL;\n                            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to allocate encoder MCT decoding matrix \\n\");\n                            return OPJ_FALSE;\n                    }\n                    if(opj_matrix_inversion_f(lTmpBuf,(tcp->m_mct_decoding_matrix),image->numcomps) == OPJ_FALSE) {\n                            opj_free(lTmpBuf);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlTmpBuf = NULL;\n                            opj_event_msg(p_manager, EVT_ERROR, \"Failed to inverse encoder MCT decoding matrix \\n\");\n                            return OPJ_FALSE;\n\t\t\t\t\t\t\t\t\t\t}\n\n                    tcp->mct_norms = (OPJ_FLOAT64*)\n                                    opj_malloc(image->numcomps * sizeof(OPJ_FLOAT64));\n\t\t\t\t\t\t\t\t\t\tif (! tcp->mct_norms) {\n                            opj_free(lTmpBuf);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlTmpBuf = NULL;\n                            opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to allocate encoder MCT norms \\n\");\n                            return OPJ_FALSE;\n                    }\n                    opj_calculate_norms(tcp->mct_norms,image->numcomps,tcp->m_mct_decoding_matrix);\n                    opj_free(lTmpBuf);\n\n                    for (i = 0; i < image->numcomps; i++) {\n                            opj_tccp_t *tccp = &tcp->tccps[i];\n                            tccp->m_dc_level_shift = l_dc_shift[i];\n                    }\n\n                    if (opj_j2k_setup_mct_encoding(tcp,image) == OPJ_FALSE) {\n                        /* free will be handled by opj_j2k_destroy */\n\t\t\t\t\t\t\t\t\t\t\t\topj_event_msg(p_manager, EVT_ERROR, \"Failed to setup j2k mct encoding\\n\");\n                        return OPJ_FALSE;\n                    }\n                }\n                else {\n                    if(tcp->mct==1 && image->numcomps >= 3) { /* RGB->YCC MCT is enabled */\n                        if ((image->comps[0].dx != image->comps[1].dx) ||\n                                (image->comps[0].dx != image->comps[2].dx) ||\n                                (image->comps[0].dy != image->comps[1].dy) ||\n                                (image->comps[0].dy != image->comps[2].dy)) {\n                            opj_event_msg(p_manager, EVT_WARNING, \"Cannot perform MCT on components with different sizes. Disabling MCT.\\n\");\n                            tcp->mct = 0;\n                        }\n                    }\n                        for (i = 0; i < image->numcomps; i++) {\n                                opj_tccp_t *tccp = &tcp->tccps[i];\n                                opj_image_comp_t * l_comp = &(image->comps[i]);\n\n                                if (! l_comp->sgnd) {\n                                        tccp->m_dc_level_shift = 1 << (l_comp->prec - 1);\n                                }\n                        }\n                }\n\n                for (i = 0; i < image->numcomps; i++) {\n                        opj_tccp_t *tccp = &tcp->tccps[i];\n\n                        tccp->csty = parameters->csty & 0x01;   /* 0 => one precinct || 1 => custom precinct  */\n                        tccp->numresolutions = (OPJ_UINT32)parameters->numresolution;\n                        tccp->cblkw = (OPJ_UINT32)opj_int_floorlog2(parameters->cblockw_init);\n                        tccp->cblkh = (OPJ_UINT32)opj_int_floorlog2(parameters->cblockh_init);\n                        tccp->cblksty = (OPJ_UINT32)parameters->mode;\n                        tccp->qmfbid = parameters->irreversible ? 0 : 1;\n                        tccp->qntsty = parameters->irreversible ? J2K_CCP_QNTSTY_SEQNT : J2K_CCP_QNTSTY_NOQNT;\n                        tccp->numgbits = 2;\n\n                        if ((OPJ_INT32)i == parameters->roi_compno) {\n                                tccp->roishift = parameters->roi_shift;\n                        } else {\n                                tccp->roishift = 0;\n                        }\n\n                                if (parameters->csty & J2K_CCP_CSTY_PRT) {\n                                        OPJ_INT32 p = 0, it_res;\n                                        assert( tccp->numresolutions > 0 );\n                                        for (it_res = (OPJ_INT32)tccp->numresolutions - 1; it_res >= 0; it_res--) {\n                                                if (p < parameters->res_spec) {\n\n                                                        if (parameters->prcw_init[p] < 1) {\n                                                                tccp->prcw[it_res] = 1;\n                                                        } else {\n                                                                tccp->prcw[it_res] = (OPJ_UINT32)opj_int_floorlog2(parameters->prcw_init[p]);\n                                                        }\n\n                                                        if (parameters->prch_init[p] < 1) {\n                                                                tccp->prch[it_res] = 1;\n                                                        }else {\n                                                                tccp->prch[it_res] = (OPJ_UINT32)opj_int_floorlog2(parameters->prch_init[p]);\n                                                        }\n\n                                                } else {\n                                                        OPJ_INT32 res_spec = parameters->res_spec;\n                                                        OPJ_INT32 size_prcw = 0;\n                                                        OPJ_INT32 size_prch = 0;\n\n                                                        assert(res_spec>0); /* issue 189 */\n                                                        size_prcw = parameters->prcw_init[res_spec - 1] >> (p - (res_spec - 1));\n                                                        size_prch = parameters->prch_init[res_spec - 1] >> (p - (res_spec - 1));\n\n\n                                                        if (size_prcw < 1) {\n                                                                tccp->prcw[it_res] = 1;\n                                                        } else {\n                                                                tccp->prcw[it_res] = (OPJ_UINT32)opj_int_floorlog2(size_prcw);\n                                                        }\n\n                                                        if (size_prch < 1) {\n                                                                tccp->prch[it_res] = 1;\n                                                        } else {\n                                                                tccp->prch[it_res] = (OPJ_UINT32)opj_int_floorlog2(size_prch);\n                                                        }\n                                                }\n                                                p++;\n                                                /*printf(\"\\nsize precinct for level %d : %d,%d\\n\", it_res,tccp->prcw[it_res], tccp->prch[it_res]); */\n                                        }       /*end for*/\n                                } else {\n                                        for (j = 0; j < tccp->numresolutions; j++) {\n                                                tccp->prcw[j] = 15;\n                                                tccp->prch[j] = 15;\n                                        }\n                                }\n\n                        opj_dwt_calc_explicit_stepsizes(tccp, image->comps[i].prec);\n                }\n        }\n\n        if (parameters->mct_data) {\n                opj_free(parameters->mct_data);\n                parameters->mct_data = 00;\n        }\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index, OPJ_UINT32 type, OPJ_OFF_T pos, OPJ_UINT32 len)\n{\n        assert(cstr_index != 00);\n\n        /* expand the list? */\n        if ((cstr_index->marknum + 1) > cstr_index->maxmarknum) {\n                opj_marker_info_t *new_marker;\n                cstr_index->maxmarknum = (OPJ_UINT32)(100 + (OPJ_FLOAT32) cstr_index->maxmarknum);\n                new_marker = (opj_marker_info_t *) opj_realloc(cstr_index->marker, cstr_index->maxmarknum *sizeof(opj_marker_info_t));\n                if (! new_marker) {\n                        opj_free(cstr_index->marker);\n                        cstr_index->marker = NULL;\n                        cstr_index->maxmarknum = 0;\n                        cstr_index->marknum = 0;\n                        /* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add mh marker\\n\"); */\n                        return OPJ_FALSE;\n                }\n                cstr_index->marker = new_marker;\n        }\n\n        /* add the marker */\n        cstr_index->marker[cstr_index->marknum].type = (OPJ_UINT16)type;\n        cstr_index->marker[cstr_index->marknum].pos = (OPJ_INT32)pos;\n        cstr_index->marker[cstr_index->marknum].len = (OPJ_INT32)len;\n        cstr_index->marknum++;\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno, opj_codestream_index_t *cstr_index, OPJ_UINT32 type, OPJ_OFF_T pos, OPJ_UINT32 len)\n{\n        assert(cstr_index != 00);\n        assert(cstr_index->tile_index != 00);\n\n        /* expand the list? */\n        if ((cstr_index->tile_index[tileno].marknum + 1) > cstr_index->tile_index[tileno].maxmarknum) {\n                opj_marker_info_t *new_marker;\n                cstr_index->tile_index[tileno].maxmarknum = (OPJ_UINT32)(100 + (OPJ_FLOAT32) cstr_index->tile_index[tileno].maxmarknum);\n                new_marker = (opj_marker_info_t *) opj_realloc(\n                                cstr_index->tile_index[tileno].marker,\n                                cstr_index->tile_index[tileno].maxmarknum *sizeof(opj_marker_info_t));\n                if (! new_marker) {\n                        opj_free(cstr_index->tile_index[tileno].marker);\n                        cstr_index->tile_index[tileno].marker = NULL;\n                        cstr_index->tile_index[tileno].maxmarknum = 0;\n                        cstr_index->tile_index[tileno].marknum = 0;\n                        /* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add tl marker\\n\"); */\n                        return OPJ_FALSE;\n                }\n                cstr_index->tile_index[tileno].marker = new_marker;\n        }\n\n        /* add the marker */\n        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].type = (OPJ_UINT16)type;\n        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].pos = (OPJ_INT32)pos;\n        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].len = (OPJ_INT32)len;\n        cstr_index->tile_index[tileno].marknum++;\n\n        if (type == J2K_MS_SOT) {\n                OPJ_UINT32 l_current_tile_part = cstr_index->tile_index[tileno].current_tpsno;\n\n                if (cstr_index->tile_index[tileno].tp_index)\n                        cstr_index->tile_index[tileno].tp_index[l_current_tile_part].start_pos = pos;\n\n        }\n        return OPJ_TRUE;\n}\n\n/*\n * -----------------------------------------------------------------------\n * -----------------------------------------------------------------------\n * -----------------------------------------------------------------------\n */\n\nOPJ_BOOL opj_j2k_end_decompress(opj_j2k_t *p_j2k,\n                                opj_stream_private_t *p_stream,\n                                opj_event_mgr_t * p_manager\n                                )\n{\n    (void)p_j2k;\n    (void)p_stream;\n    (void)p_manager;\n    return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_read_header(   opj_stream_private_t *p_stream,\n                                                            opj_j2k_t* p_j2k,\n                                                            opj_image_t** p_image,\n                                                            opj_event_mgr_t* p_manager )\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n\n        /* create an empty image header */\n        p_j2k->m_private_image = opj_image_create0();\n        if (! p_j2k->m_private_image) {\n                return OPJ_FALSE;\n        }\n\n        /* customization of the validation */\n        if (! opj_j2k_setup_decoding_validation(p_j2k, p_manager)) {\n                opj_image_destroy(p_j2k->m_private_image);\n                p_j2k->m_private_image = NULL;\n                return OPJ_FALSE;\n        }\n\n        /* validation of the parameters codec */\n        if (! opj_j2k_exec(p_j2k, p_j2k->m_validation_list, p_stream,p_manager)) {\n                opj_image_destroy(p_j2k->m_private_image);\n                p_j2k->m_private_image = NULL;\n                return OPJ_FALSE;\n        }\n\n        /* customization of the encoding */\n        if (! opj_j2k_setup_header_reading(p_j2k, p_manager)) {\n                opj_image_destroy(p_j2k->m_private_image);\n                p_j2k->m_private_image = NULL;\n                return OPJ_FALSE;\n        }\n\n        /* read header */\n        if (! opj_j2k_exec (p_j2k,p_j2k->m_procedure_list,p_stream,p_manager)) {\n                opj_image_destroy(p_j2k->m_private_image);\n                p_j2k->m_private_image = NULL;\n                return OPJ_FALSE;\n        }\n\n        *p_image = opj_image_create0();\n        if (! (*p_image)) {\n                return OPJ_FALSE;\n        }\n\n        /* Copy codestream image information to the output image */\n        opj_copy_image_header(p_j2k->m_private_image, *p_image);\n\n    /*Allocate and initialize some elements of codestrem index*/\n        if (!opj_j2k_allocate_tile_element_cstr_index(p_j2k)){\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_setup_header_reading (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager)\n{\n        /* preconditions*/\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_read_header_procedure, p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        /* DEVELOPER CORNER, add your custom procedures */\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_copy_default_tcp_and_create_tcd, p_manager))  {\n                return OPJ_FALSE;\n        }\n\t\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_setup_decoding_validation (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager)\n{\n        /* preconditions*/\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list,(opj_procedure)opj_j2k_build_decoder, p_manager)) {\n                return OPJ_FALSE;\n        }\n        if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list,(opj_procedure)opj_j2k_decoding_validation, p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        /* DEVELOPER CORNER, add your custom validation procedure */\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_mct_validation (       opj_j2k_t * p_j2k,\n                                                                opj_stream_private_t *p_stream,\n                                                                opj_event_mgr_t * p_manager )\n{\n        OPJ_BOOL l_is_valid = OPJ_TRUE;\n        OPJ_UINT32 i,j;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n\n        if ((p_j2k->m_cp.rsiz & 0x8200) == 0x8200) {\n                OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n                opj_tcp_t * l_tcp = p_j2k->m_cp.tcps;\n\n                for (i=0;i<l_nb_tiles;++i) {\n                        if (l_tcp->mct == 2) {\n                                opj_tccp_t * l_tccp = l_tcp->tccps;\n                                l_is_valid &= (l_tcp->m_mct_coding_matrix != 00);\n\n                                for (j=0;j<p_j2k->m_private_image->numcomps;++j) {\n                                        l_is_valid &= ! (l_tccp->qmfbid & 1);\n                                        ++l_tccp;\n                                }\n                        }\n                        ++l_tcp;\n                }\n        }\n\n        return l_is_valid;\n}\n\nOPJ_BOOL opj_j2k_setup_mct_encoding(opj_tcp_t * p_tcp, opj_image_t * p_image)\n{\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_indix = 1;\n        opj_mct_data_t * l_mct_deco_data = 00,* l_mct_offset_data = 00;\n        opj_simple_mcc_decorrelation_data_t * l_mcc_data;\n        OPJ_UINT32 l_mct_size,l_nb_elem;\n        OPJ_FLOAT32 * l_data, * l_current_data;\n        opj_tccp_t * l_tccp;\n\n        /* preconditions */\n        assert(p_tcp != 00);\n\n        if (p_tcp->mct != 2) {\n                return OPJ_TRUE;\n        }\n\n        if (p_tcp->m_mct_decoding_matrix) {\n                if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {\n                        opj_mct_data_t *new_mct_records;\n                        p_tcp->m_nb_max_mct_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;\n\n                        new_mct_records = (opj_mct_data_t *) opj_realloc(p_tcp->m_mct_records, p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t));\n                        if (! new_mct_records) {\n                                opj_free(p_tcp->m_mct_records);\n                                p_tcp->m_mct_records = NULL;\n                                p_tcp->m_nb_max_mct_records = 0;\n                                p_tcp->m_nb_mct_records = 0;\n                                /* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to setup mct encoding\\n\"); */\n                                return OPJ_FALSE;\n                        }\n                        p_tcp->m_mct_records = new_mct_records;\n                        l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;\n\n                        memset(l_mct_deco_data ,0,(p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t));\n                }\n                l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;\n\n                if (l_mct_deco_data->m_data) {\n                        opj_free(l_mct_deco_data->m_data);\n                        l_mct_deco_data->m_data = 00;\n                }\n\n                l_mct_deco_data->m_index = l_indix++;\n                l_mct_deco_data->m_array_type = MCT_TYPE_DECORRELATION;\n                l_mct_deco_data->m_element_type = MCT_TYPE_FLOAT;\n                l_nb_elem = p_image->numcomps * p_image->numcomps;\n                l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_deco_data->m_element_type];\n                l_mct_deco_data->m_data = (OPJ_BYTE*)opj_malloc(l_mct_size );\n\n                if (! l_mct_deco_data->m_data) {\n                        return OPJ_FALSE;\n                }\n\n                j2k_mct_write_functions_from_float[l_mct_deco_data->m_element_type](p_tcp->m_mct_decoding_matrix,l_mct_deco_data->m_data,l_nb_elem);\n\n                l_mct_deco_data->m_data_size = l_mct_size;\n                ++p_tcp->m_nb_mct_records;\n        }\n\n        if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {\n                opj_mct_data_t *new_mct_records;\n                p_tcp->m_nb_max_mct_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;\n                new_mct_records = (opj_mct_data_t *) opj_realloc(p_tcp->m_mct_records, p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t));\n                if (! new_mct_records) {\n                        opj_free(p_tcp->m_mct_records);\n                        p_tcp->m_mct_records = NULL;\n                        p_tcp->m_nb_max_mct_records = 0;\n                        p_tcp->m_nb_mct_records = 0;\n                        /* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to setup mct encoding\\n\"); */\n                        return OPJ_FALSE;\n                }\n                p_tcp->m_mct_records = new_mct_records;\n                l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;\n\n                memset(l_mct_offset_data ,0,(p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t));\n\n                if (l_mct_deco_data) {\n                        l_mct_deco_data = l_mct_offset_data - 1;\n                }\n        }\n\n        l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;\n\n        if (l_mct_offset_data->m_data) {\n                opj_free(l_mct_offset_data->m_data);\n                l_mct_offset_data->m_data = 00;\n        }\n\n        l_mct_offset_data->m_index = l_indix++;\n        l_mct_offset_data->m_array_type = MCT_TYPE_OFFSET;\n        l_mct_offset_data->m_element_type = MCT_TYPE_FLOAT;\n        l_nb_elem = p_image->numcomps;\n        l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_offset_data->m_element_type];\n        l_mct_offset_data->m_data = (OPJ_BYTE*)opj_malloc(l_mct_size );\n\n        if (! l_mct_offset_data->m_data) {\n                return OPJ_FALSE;\n        }\n\n        l_data = (OPJ_FLOAT32*)opj_malloc(l_nb_elem * sizeof(OPJ_FLOAT32));\n        if (! l_data) {\n                opj_free(l_mct_offset_data->m_data);\n                l_mct_offset_data->m_data = 00;\n                return OPJ_FALSE;\n        }\n\n        l_tccp = p_tcp->tccps;\n        l_current_data = l_data;\n\n        for (i=0;i<l_nb_elem;++i) {\n                *(l_current_data++) = (OPJ_FLOAT32) (l_tccp->m_dc_level_shift);\n                ++l_tccp;\n        }\n\n        j2k_mct_write_functions_from_float[l_mct_offset_data->m_element_type](l_data,l_mct_offset_data->m_data,l_nb_elem);\n\n        opj_free(l_data);\n\n        l_mct_offset_data->m_data_size = l_mct_size;\n\n        ++p_tcp->m_nb_mct_records;\n\n        if (p_tcp->m_nb_mcc_records == p_tcp->m_nb_max_mcc_records) {\n                opj_simple_mcc_decorrelation_data_t *new_mcc_records;\n                p_tcp->m_nb_max_mcc_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;\n                new_mcc_records = (opj_simple_mcc_decorrelation_data_t *) opj_realloc(\n                                p_tcp->m_mcc_records, p_tcp->m_nb_max_mcc_records * sizeof(opj_simple_mcc_decorrelation_data_t));\n                if (! new_mcc_records) {\n                        opj_free(p_tcp->m_mcc_records);\n                        p_tcp->m_mcc_records = NULL;\n                        p_tcp->m_nb_max_mcc_records = 0;\n                        p_tcp->m_nb_mcc_records = 0;\n                        /* opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to setup mct encoding\\n\"); */\n                        return OPJ_FALSE;\n                }\n                p_tcp->m_mcc_records = new_mcc_records;\n                l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;\n                memset(l_mcc_data ,0,(p_tcp->m_nb_max_mcc_records - p_tcp->m_nb_mcc_records) * sizeof(opj_simple_mcc_decorrelation_data_t));\n\n        }\n\n        l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;\n        l_mcc_data->m_decorrelation_array = l_mct_deco_data;\n        l_mcc_data->m_is_irreversible = 1;\n        l_mcc_data->m_nb_comps = p_image->numcomps;\n        l_mcc_data->m_index = l_indix++;\n        l_mcc_data->m_offset_array = l_mct_offset_data;\n        ++p_tcp->m_nb_mcc_records;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_build_decoder (opj_j2k_t * p_j2k,\n                                                            opj_stream_private_t *p_stream,\n                                                            opj_event_mgr_t * p_manager )\n{\n        /* add here initialization of cp\n           copy paste of setup_decoder */\n  (void)p_j2k;\n  (void)p_stream;\n  (void)p_manager;\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_build_encoder (opj_j2k_t * p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager )\n{\n        /* add here initialization of cp\n           copy paste of setup_encoder */\n  (void)p_j2k;\n  (void)p_stream;\n  (void)p_manager;\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_encoding_validation (  opj_j2k_t * p_j2k,\n                                                                            opj_stream_private_t *p_stream,\n                                                                            opj_event_mgr_t * p_manager )\n{\n        OPJ_BOOL l_is_valid = OPJ_TRUE;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n\n        /* STATE checking */\n        /* make sure the state is at 0 */\n        l_is_valid &= (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NONE);\n\n        /* POINTER validation */\n        /* make sure a p_j2k codec is present */\n        l_is_valid &= (p_j2k->m_procedure_list != 00);\n        /* make sure a validation list is present */\n        l_is_valid &= (p_j2k->m_validation_list != 00);\n\n        /* ISO 15444-1:2004 states between 1 & 33 (0 -> 32) */\n        /* 33 (32) would always fail the check below (if a cast to 64bits was done) */\n        /* FIXME Shall we change OPJ_J2K_MAXRLVLS to 32 ? */\n        if ((p_j2k->m_cp.tcps->tccps->numresolutions <= 0) || (p_j2k->m_cp.tcps->tccps->numresolutions > 32)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Number of resolutions is too high in comparison to the size of tiles\\n\");\n                return OPJ_FALSE;\n        }\n\n        if ((p_j2k->m_cp.tdx) < (OPJ_UINT32) (1 << (p_j2k->m_cp.tcps->tccps->numresolutions - 1U))) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Number of resolutions is too high in comparison to the size of tiles\\n\");\n                return OPJ_FALSE;\n        }\n\n        if ((p_j2k->m_cp.tdy) < (OPJ_UINT32) (1 << (p_j2k->m_cp.tcps->tccps->numresolutions - 1U))) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Number of resolutions is too high in comparison to the size of tiles\\n\");\n                return OPJ_FALSE;\n        }\n\n        /* PARAMETER VALIDATION */\n        return l_is_valid;\n}\n\nstatic OPJ_BOOL opj_j2k_decoding_validation (  opj_j2k_t *p_j2k,\n                                        opj_stream_private_t *p_stream,\n                                        opj_event_mgr_t * p_manager\n                                        )\n{\n        OPJ_BOOL l_is_valid = OPJ_TRUE;\n\n        /* preconditions*/\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n\n        /* STATE checking */\n        /* make sure the state is at 0 */\n#ifdef TODO_MSD\n        l_is_valid &= (p_j2k->m_specific_param.m_decoder.m_state == J2K_DEC_STATE_NONE);\n#endif\n        l_is_valid &= (p_j2k->m_specific_param.m_decoder.m_state == 0x0000);\n\n        /* POINTER validation */\n        /* make sure a p_j2k codec is present */\n        /* make sure a procedure list is present */\n        l_is_valid &= (p_j2k->m_procedure_list != 00);\n        /* make sure a validation list is present */\n        l_is_valid &= (p_j2k->m_validation_list != 00);\n\n        /* PARAMETER VALIDATION */\n        return l_is_valid;\n}\n\nstatic OPJ_BOOL opj_j2k_read_header_procedure( opj_j2k_t *p_j2k,\n                                                                            opj_stream_private_t *p_stream,\n                                                                            opj_event_mgr_t * p_manager)\n{\n        OPJ_UINT32 l_current_marker;\n        OPJ_UINT32 l_marker_size;\n        const opj_dec_memory_marker_handler_t * l_marker_handler = 00;\n        OPJ_BOOL l_has_siz = 0;\n        OPJ_BOOL l_has_cod = 0;\n        OPJ_BOOL l_has_qcd = 0;\n\n        /* preconditions */\n        assert(p_stream != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        /*  We enter in the main header */\n        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_MHSOC;\n\n        /* Try to read the SOC marker, the codestream must begin with SOC marker */\n        if (! opj_j2k_read_soc(p_j2k,p_stream,p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Expected a SOC marker \\n\");\n                return OPJ_FALSE;\n        }\n\n        /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */\n        if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                return OPJ_FALSE;\n        }\n\n        /* Read 2 bytes as the new marker ID */\n        opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_current_marker,2);\n\n        /* Try to read until the SOT is detected */\n        while (l_current_marker != J2K_MS_SOT) {\n\n                /* Check if the current marker ID is valid */\n                if (l_current_marker < 0xff00) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"A marker ID was expected (0xff--) instead of %.8x\\n\", l_current_marker);\n                        return OPJ_FALSE;\n                }\n\n                /* Get the marker handler from the marker ID */\n                l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);\n\n                /* Manage case where marker is unknown */\n                if (l_marker_handler->id == J2K_MS_UNK) {\n                        if (! opj_j2k_read_unk(p_j2k, p_stream, &l_current_marker, p_manager)){\n                                opj_event_msg(p_manager, EVT_ERROR, \"Unknow marker have been detected and generated error.\\n\");\n                                return OPJ_FALSE;\n                        }\n\n                        if (l_current_marker == J2K_MS_SOT)\n                                break; /* SOT marker is detected main header is completely read */\n                        else    /* Get the marker handler from the marker ID */\n                                l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);\n                }\n\n                if (l_marker_handler->id == J2K_MS_SIZ) {\n                    /* Mark required SIZ marker as found */\n                    l_has_siz = 1;\n                }\n                if (l_marker_handler->id == J2K_MS_COD) {\n                    /* Mark required COD marker as found */\n                    l_has_cod = 1;\n                }\n                if (l_marker_handler->id == J2K_MS_QCD) {\n                    /* Mark required QCD marker as found */\n                    l_has_qcd = 1;\n                }\n\n                /* Check if the marker is known and if it is the right place to find it */\n                if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states) ) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Marker is not compliant with its position\\n\");\n                        return OPJ_FALSE;\n                }\n\n                /* Try to read 2 bytes (the marker size) from stream and copy them into the buffer */\n                if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                        return OPJ_FALSE;\n                }\n\n                /* read 2 bytes as the marker size */\n                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_marker_size,2);\n                l_marker_size -= 2; /* Subtract the size of the marker ID already read */\n\n                /* Check if the marker size is compatible with the header data size */\n                if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {\n                        OPJ_BYTE *new_header_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size);\n                        if (! new_header_data) {\n                                opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);\n                                p_j2k->m_specific_param.m_decoder.m_header_data = NULL;\n                                p_j2k->m_specific_param.m_decoder.m_header_data_size = 0;\n                                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read header\\n\");\n                                return OPJ_FALSE;\n                        }\n                        p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;\n                        p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;\n                }\n\n                /* Try to read the rest of the marker segment from stream and copy them into the buffer */\n                if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,l_marker_size,p_manager) != l_marker_size) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                        return OPJ_FALSE;\n                }\n\n                /* Read the marker segment with the correct marker handler */\n                if (! (*(l_marker_handler->handler))(p_j2k,p_j2k->m_specific_param.m_decoder.m_header_data,l_marker_size,p_manager)) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Marker handler function failed to read the marker segment\\n\");\n                        return OPJ_FALSE;\n                }\n\n                /* Add the marker to the codestream index*/\n                if (OPJ_FALSE == opj_j2k_add_mhmarker(\n                                        p_j2k->cstr_index,\n                                        l_marker_handler->id,\n                                        (OPJ_UINT32) opj_stream_tell(p_stream) - l_marker_size - 4,\n                                        l_marker_size + 4 )) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add mh marker\\n\");\n                        return OPJ_FALSE;\n                }\n\n                /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */\n                if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                        return OPJ_FALSE;\n                }\n\n                /* read 2 bytes as the new marker ID */\n                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_current_marker,2);\n        }\n\n        if (l_has_siz == 0) {\n            opj_event_msg(p_manager, EVT_ERROR, \"required SIZ marker not found in main header\\n\");\n            return OPJ_FALSE;\n        }\n        if (l_has_cod == 0) {\n            opj_event_msg(p_manager, EVT_ERROR, \"required COD marker not found in main header\\n\");\n            return OPJ_FALSE;\n        }\n        if (l_has_qcd == 0) {\n            opj_event_msg(p_manager, EVT_ERROR, \"required QCD marker not found in main header\\n\");\n            return OPJ_FALSE;\n        }\n\t\n        if (! opj_j2k_merge_ppm(&(p_j2k->m_cp), p_manager)) {\n            opj_event_msg(p_manager, EVT_ERROR, \"Failed to merge PPM data\\n\");\n            return OPJ_FALSE;\n        }\n\n        opj_event_msg(p_manager, EVT_INFO, \"Main header has been correctly decoded.\\n\");\n\n        /* Position of the last element if the main header */\n        p_j2k->cstr_index->main_head_end = (OPJ_UINT32) opj_stream_tell(p_stream) - 2;\n\n        /* Next step: read a tile-part header */\n        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_exec ( opj_j2k_t * p_j2k,\n                                        opj_procedure_list_t * p_procedure_list,\n                                        opj_stream_private_t *p_stream,\n                                        opj_event_mgr_t * p_manager )\n{\n        OPJ_BOOL (** l_procedure) (opj_j2k_t * ,opj_stream_private_t *,opj_event_mgr_t *) = 00;\n        OPJ_BOOL l_result = OPJ_TRUE;\n        OPJ_UINT32 l_nb_proc, i;\n\n        /* preconditions*/\n        assert(p_procedure_list != 00);\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n\n        l_nb_proc = opj_procedure_list_get_nb_procedures(p_procedure_list);\n        l_procedure = (OPJ_BOOL (**) (opj_j2k_t * ,opj_stream_private_t *,opj_event_mgr_t *)) opj_procedure_list_get_first_procedure(p_procedure_list);\n\n        for     (i=0;i<l_nb_proc;++i) {\n                l_result = l_result && ((*l_procedure) (p_j2k,p_stream,p_manager));\n                ++l_procedure;\n        }\n\n        /* and clear the procedure list at the end.*/\n        opj_procedure_list_clear(p_procedure_list);\n        return l_result;\n}\n\n/* FIXME DOC*/\nstatic OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd (       opj_j2k_t * p_j2k,\n                                                            opj_stream_private_t *p_stream,\n                                                            opj_event_mgr_t * p_manager\n                                                            )\n{\n        opj_tcp_t * l_tcp = 00;\n        opj_tcp_t * l_default_tcp = 00;\n        OPJ_UINT32 l_nb_tiles;\n        OPJ_UINT32 i,j;\n        opj_tccp_t *l_current_tccp = 00;\n        OPJ_UINT32 l_tccp_size;\n        OPJ_UINT32 l_mct_size;\n        opj_image_t * l_image;\n        OPJ_UINT32 l_mcc_records_size,l_mct_records_size;\n        opj_mct_data_t * l_src_mct_rec, *l_dest_mct_rec;\n        opj_simple_mcc_decorrelation_data_t * l_src_mcc_rec, *l_dest_mcc_rec;\n        OPJ_UINT32 l_offset;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n\n        l_image = p_j2k->m_private_image;\n        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n        l_tcp = p_j2k->m_cp.tcps;\n        l_tccp_size = l_image->numcomps * (OPJ_UINT32)sizeof(opj_tccp_t);\n        l_default_tcp = p_j2k->m_specific_param.m_decoder.m_default_tcp;\n        l_mct_size = l_image->numcomps * l_image->numcomps * (OPJ_UINT32)sizeof(OPJ_FLOAT32);\n\n        /* For each tile */\n        for (i=0; i<l_nb_tiles; ++i) {\n                /* keep the tile-compo coding parameters pointer of the current tile coding parameters*/\n                l_current_tccp = l_tcp->tccps;\n                /*Copy default coding parameters into the current tile coding parameters*/\n                memcpy(l_tcp, l_default_tcp, sizeof(opj_tcp_t));\n                /* Initialize some values of the current tile coding parameters*/\n                l_tcp->cod = 0;\n                l_tcp->ppt = 0;\n                l_tcp->ppt_data = 00;\n                /* Remove memory not owned by this tile in case of early error return. */\n                l_tcp->m_mct_decoding_matrix = 00;\n                l_tcp->m_nb_max_mct_records = 0;\n                l_tcp->m_mct_records = 00;\n                l_tcp->m_nb_max_mcc_records = 0;\n                l_tcp->m_mcc_records = 00;\n                /* Reconnect the tile-compo coding parameters pointer to the current tile coding parameters*/\n                l_tcp->tccps = l_current_tccp;\n\n                /* Get the mct_decoding_matrix of the dflt_tile_cp and copy them into the current tile cp*/\n                if (l_default_tcp->m_mct_decoding_matrix) {\n                        l_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32*)opj_malloc(l_mct_size);\n                        if (! l_tcp->m_mct_decoding_matrix ) {\n                                return OPJ_FALSE;\n                        }\n                        memcpy(l_tcp->m_mct_decoding_matrix,l_default_tcp->m_mct_decoding_matrix,l_mct_size);\n                }\n\n                /* Get the mct_record of the dflt_tile_cp and copy them into the current tile cp*/\n                l_mct_records_size = l_default_tcp->m_nb_max_mct_records * (OPJ_UINT32)sizeof(opj_mct_data_t);\n                l_tcp->m_mct_records = (opj_mct_data_t*)opj_malloc(l_mct_records_size);\n                if (! l_tcp->m_mct_records) {\n                        return OPJ_FALSE;\n                }\n                memcpy(l_tcp->m_mct_records, l_default_tcp->m_mct_records,l_mct_records_size);\n\n                /* Copy the mct record data from dflt_tile_cp to the current tile*/\n                l_src_mct_rec = l_default_tcp->m_mct_records;\n                l_dest_mct_rec = l_tcp->m_mct_records;\n\n                for (j=0;j<l_default_tcp->m_nb_mct_records;++j) {\n\n                        if (l_src_mct_rec->m_data) {\n\n                                l_dest_mct_rec->m_data = (OPJ_BYTE*) opj_malloc(l_src_mct_rec->m_data_size);\n                                if(! l_dest_mct_rec->m_data) {\n                                        return OPJ_FALSE;\n                                }\n                                memcpy(l_dest_mct_rec->m_data,l_src_mct_rec->m_data,l_src_mct_rec->m_data_size);\n                        }\n\n                        ++l_src_mct_rec;\n                        ++l_dest_mct_rec;\n                        /* Update with each pass to free exactly what has been allocated on early return. */\n                        l_tcp->m_nb_max_mct_records += 1;\n                }\n\n                /* Get the mcc_record of the dflt_tile_cp and copy them into the current tile cp*/\n                l_mcc_records_size = l_default_tcp->m_nb_max_mcc_records * (OPJ_UINT32)sizeof(opj_simple_mcc_decorrelation_data_t);\n                l_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t*) opj_malloc(l_mcc_records_size);\n                if (! l_tcp->m_mcc_records) {\n                        return OPJ_FALSE;\n                }\n                memcpy(l_tcp->m_mcc_records,l_default_tcp->m_mcc_records,l_mcc_records_size);\n                l_tcp->m_nb_max_mcc_records = l_default_tcp->m_nb_max_mcc_records;\n\n                /* Copy the mcc record data from dflt_tile_cp to the current tile*/\n                l_src_mcc_rec = l_default_tcp->m_mcc_records;\n                l_dest_mcc_rec = l_tcp->m_mcc_records;\n\n                for (j=0;j<l_default_tcp->m_nb_max_mcc_records;++j) {\n\n                        if (l_src_mcc_rec->m_decorrelation_array) {\n                                l_offset = (OPJ_UINT32)(l_src_mcc_rec->m_decorrelation_array - l_default_tcp->m_mct_records);\n                                l_dest_mcc_rec->m_decorrelation_array = l_tcp->m_mct_records + l_offset;\n                        }\n\n                        if (l_src_mcc_rec->m_offset_array) {\n                                l_offset = (OPJ_UINT32)(l_src_mcc_rec->m_offset_array - l_default_tcp->m_mct_records);\n                                l_dest_mcc_rec->m_offset_array = l_tcp->m_mct_records + l_offset;\n                        }\n\n                        ++l_src_mcc_rec;\n                        ++l_dest_mcc_rec;\n                }\n\n                /* Copy all the dflt_tile_compo_cp to the current tile cp */\n                memcpy(l_current_tccp,l_default_tcp->tccps,l_tccp_size);\n\n                /* Move to next tile cp*/\n                ++l_tcp;\n        }\n\n        /* Create the current tile decoder*/\n        p_j2k->m_tcd = (opj_tcd_t*)opj_tcd_create(OPJ_TRUE); /* FIXME why a cast ? */\n        if (! p_j2k->m_tcd ) {\n                return OPJ_FALSE;\n        }\n\n        if ( !opj_tcd_init(p_j2k->m_tcd, l_image, &(p_j2k->m_cp), p_j2k->m_tp) ) {\n                opj_tcd_destroy(p_j2k->m_tcd);\n                p_j2k->m_tcd = 00;\n                opj_event_msg(p_manager, EVT_ERROR, \"Cannot decode tile, memory error\\n\");\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic const opj_dec_memory_marker_handler_t * opj_j2k_get_marker_handler (OPJ_UINT32 p_id)\n{\n        const opj_dec_memory_marker_handler_t *e;\n        for (e = j2k_memory_marker_handler_tab; e->id != 0; ++e) {\n                if (e->id == p_id) {\n                        break; /* we find a handler corresponding to the marker ID*/\n                }\n        }\n        return e;\n}\n\nvoid opj_j2k_destroy (opj_j2k_t *p_j2k)\n{\n        if (p_j2k == 00) {\n                return;\n        }\n\n        if (p_j2k->m_is_decoder) {\n\n                if (p_j2k->m_specific_param.m_decoder.m_default_tcp != 00) {\n                        opj_j2k_tcp_destroy(p_j2k->m_specific_param.m_decoder.m_default_tcp);\n                        opj_free(p_j2k->m_specific_param.m_decoder.m_default_tcp);\n                        p_j2k->m_specific_param.m_decoder.m_default_tcp = 00;\n                }\n\n                if (p_j2k->m_specific_param.m_decoder.m_header_data != 00) {\n                        opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);\n                        p_j2k->m_specific_param.m_decoder.m_header_data = 00;\n                        p_j2k->m_specific_param.m_decoder.m_header_data_size = 0;\n                }\n        }\n        else {\n\n                if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = 00;\n                }\n\n                if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);\n                        p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = 00;\n                        p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = 00;\n                }\n\n                if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = 00;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                }\n        }\n\n        opj_tcd_destroy(p_j2k->m_tcd);\n\n        opj_j2k_cp_destroy(&(p_j2k->m_cp));\n        memset(&(p_j2k->m_cp),0,sizeof(opj_cp_t));\n\n        opj_procedure_list_destroy(p_j2k->m_procedure_list);\n        p_j2k->m_procedure_list = 00;\n\n        opj_procedure_list_destroy(p_j2k->m_validation_list);\n        p_j2k->m_procedure_list = 00;\n\n        j2k_destroy_cstr_index(p_j2k->cstr_index);\n        p_j2k->cstr_index = NULL;\n\n        opj_image_destroy(p_j2k->m_private_image);\n        p_j2k->m_private_image = NULL;\n\n        opj_image_destroy(p_j2k->m_output_image);\n        p_j2k->m_output_image = NULL;\n\n        opj_thread_pool_destroy(p_j2k->m_tp);\n        p_j2k->m_tp = NULL;\n\n        opj_free(p_j2k);\n}\n\nvoid j2k_destroy_cstr_index (opj_codestream_index_t *p_cstr_ind)\n{\n        if (p_cstr_ind) {\n\n                if (p_cstr_ind->marker) {\n                        opj_free(p_cstr_ind->marker);\n                        p_cstr_ind->marker = NULL;\n                }\n\n                if (p_cstr_ind->tile_index) {\n                        OPJ_UINT32 it_tile = 0;\n\n                        for (it_tile=0; it_tile < p_cstr_ind->nb_of_tiles; it_tile++) {\n\n                                if(p_cstr_ind->tile_index[it_tile].packet_index) {\n                                        opj_free(p_cstr_ind->tile_index[it_tile].packet_index);\n                                        p_cstr_ind->tile_index[it_tile].packet_index = NULL;\n                                }\n\n                                if(p_cstr_ind->tile_index[it_tile].tp_index){\n                                        opj_free(p_cstr_ind->tile_index[it_tile].tp_index);\n                                        p_cstr_ind->tile_index[it_tile].tp_index = NULL;\n                                }\n\n                                if(p_cstr_ind->tile_index[it_tile].marker){\n                                        opj_free(p_cstr_ind->tile_index[it_tile].marker);\n                                        p_cstr_ind->tile_index[it_tile].marker = NULL;\n\n                                }\n                        }\n\n                        opj_free( p_cstr_ind->tile_index);\n                        p_cstr_ind->tile_index = NULL;\n                }\n\n                opj_free(p_cstr_ind);\n        }\n}\n\nstatic void opj_j2k_tcp_destroy (opj_tcp_t *p_tcp)\n{\n\tif (p_tcp == 00) {\n\t\treturn;\n\t}\n\t\n\tif (p_tcp->ppt_markers != 00) {\n\t\tOPJ_UINT32 i;\n\t\tfor (i = 0U; i < p_tcp->ppt_markers_count; ++i) {\n\t\t\tif (p_tcp->ppt_markers[i].m_data != NULL) {\n\t\t\t\topj_free(p_tcp->ppt_markers[i].m_data);\n\t\t\t}\n\t\t}\n\t\tp_tcp->ppt_markers_count = 0U;\n\t\topj_free(p_tcp->ppt_markers);\n\t\tp_tcp->ppt_markers = NULL;\n\t}\n\t\n\tif (p_tcp->ppt_buffer != 00) {\n\t\topj_free(p_tcp->ppt_buffer);\n\t\tp_tcp->ppt_buffer = 00;\n\t}\n\t\n\tif (p_tcp->tccps != 00) {\n\t\topj_free(p_tcp->tccps);\n\t\tp_tcp->tccps = 00;\n\t}\n\t\n\tif (p_tcp->m_mct_coding_matrix != 00) {\n\t\topj_free(p_tcp->m_mct_coding_matrix);\n\t\tp_tcp->m_mct_coding_matrix = 00;\n\t}\n\t\n\tif (p_tcp->m_mct_decoding_matrix != 00) {\n\t\topj_free(p_tcp->m_mct_decoding_matrix);\n\t\tp_tcp->m_mct_decoding_matrix = 00;\n\t}\n\t\n\tif (p_tcp->m_mcc_records) {\n\t\topj_free(p_tcp->m_mcc_records);\n\t\tp_tcp->m_mcc_records = 00;\n\t\tp_tcp->m_nb_max_mcc_records = 0;\n\t\tp_tcp->m_nb_mcc_records = 0;\n\t}\n\t\n\tif (p_tcp->m_mct_records) {\n\t\topj_mct_data_t * l_mct_data = p_tcp->m_mct_records;\n\t\tOPJ_UINT32 i;\n\t\t\n\t\tfor (i=0;i<p_tcp->m_nb_mct_records;++i) {\n\t\t\tif (l_mct_data->m_data) {\n\t\t\t\topj_free(l_mct_data->m_data);\n\t\t\t\tl_mct_data->m_data = 00;\n\t\t\t}\n\t\t\t\n\t\t\t++l_mct_data;\n\t\t}\n\t\t\n\t\topj_free(p_tcp->m_mct_records);\n\t\tp_tcp->m_mct_records = 00;\n\t}\n\n\tif (p_tcp->mct_norms != 00) {\n\t\topj_free(p_tcp->mct_norms);\n\t\tp_tcp->mct_norms = 00;\n\t}\n\n\topj_j2k_tcp_data_destroy(p_tcp);\n\n}\n\nstatic void opj_j2k_tcp_data_destroy (opj_tcp_t *p_tcp)\n{\n        if (p_tcp->m_data) {\n                opj_free(p_tcp->m_data);\n                p_tcp->m_data = NULL;\n                p_tcp->m_data_size = 0;\n        }\n}\n\nstatic void opj_j2k_cp_destroy (opj_cp_t *p_cp)\n{\n\tOPJ_UINT32 l_nb_tiles;\n\topj_tcp_t * l_current_tile = 00;\n\n\tif (p_cp == 00)\n\t{\n\t\treturn;\n\t}\n\tif (p_cp->tcps != 00)\n\t{\n\t\tOPJ_UINT32 i;\n\t\tl_current_tile = p_cp->tcps;\n\t\tl_nb_tiles = p_cp->th * p_cp->tw;\n\t\t\n\t\tfor (i = 0U; i < l_nb_tiles; ++i)\n\t\t{\n\t\t\topj_j2k_tcp_destroy(l_current_tile);\n\t\t\t++l_current_tile;\n\t\t}\n\t\topj_free(p_cp->tcps);\n\t\tp_cp->tcps = 00;\n\t}\n\tif (p_cp->ppm_markers != 00) {\n\t\tOPJ_UINT32 i;\n\t\tfor (i = 0U; i < p_cp->ppm_markers_count; ++i) {\n\t\t\tif (p_cp->ppm_markers[i].m_data != NULL) {\n\t\t\t\topj_free(p_cp->ppm_markers[i].m_data);\n\t\t\t}\n\t\t}\n\t\tp_cp->ppm_markers_count = 0U;\n\t\topj_free(p_cp->ppm_markers);\n\t\tp_cp->ppm_markers = NULL;\n\t}\n\topj_free(p_cp->ppm_buffer);\n\tp_cp->ppm_buffer = 00;\n\tp_cp->ppm_data = NULL; /* ppm_data belongs to the allocated buffer pointed by ppm_buffer */\n\topj_free(p_cp->comment);\n\tp_cp->comment = 00;\n\tif (! p_cp->m_is_decoder)\n\t{\n\t\topj_free(p_cp->m_specific_param.m_enc.m_matrice);\n\t\tp_cp->m_specific_param.m_enc.m_matrice = 00;\n\t}\n}\n\nstatic OPJ_BOOL opj_j2k_need_nb_tile_parts_correction(opj_stream_private_t *p_stream, OPJ_UINT32 tile_no, OPJ_BOOL* p_correction_needed, opj_event_mgr_t * p_manager )\n{\n\tOPJ_BYTE   l_header_data[10];\n\tOPJ_OFF_T  l_stream_pos_backup;\n\tOPJ_UINT32 l_current_marker;\n\tOPJ_UINT32 l_marker_size;\n\tOPJ_UINT32 l_tile_no, l_tot_len, l_current_part, l_num_parts;\n\t\n\t/* initialize to no correction needed */\n\t*p_correction_needed = OPJ_FALSE;\n\t\n\tif (!opj_stream_has_seek(p_stream)) {\n\t\t/* We can't do much in this case, seek is needed */\n\t\treturn OPJ_TRUE;\n\t}\n\t\n\tl_stream_pos_backup = opj_stream_tell(p_stream);\n\tif (l_stream_pos_backup == -1) {\n\t\t/* let's do nothing */\n\t\treturn OPJ_TRUE;\n\t}\n\t\n\tfor (;;) {\n\t\t/* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */\n\t\tif (opj_stream_read_data(p_stream,l_header_data, 2, p_manager) != 2) {\n\t\t\t/* assume all is OK */\n\t\t\tif (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t\treturn OPJ_TRUE;\n\t\t}\n\t\t\n\t\t/* Read 2 bytes from buffer as the new marker ID */\n\t\topj_read_bytes(l_header_data, &l_current_marker, 2);\n\t\t\n\t\tif (l_current_marker != J2K_MS_SOT) {\n\t\t\t/* assume all is OK */\n\t\t\tif (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t\treturn OPJ_TRUE;\n\t\t}\n\t\t\n\t\t/* Try to read 2 bytes (the marker size) from stream and copy them into the buffer */\n\t\tif (opj_stream_read_data(p_stream, l_header_data, 2, p_manager) != 2) {\n\t\t\topj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t\n\t\t/* Read 2 bytes from the buffer as the marker size */\n\t\topj_read_bytes(l_header_data, &l_marker_size, 2);\n\t\t\n\t\t/* Check marker size for SOT Marker */\n\t\tif (l_marker_size != 10) {\n\t\t\topj_event_msg(p_manager, EVT_ERROR, \"Inconsistent marker size\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tl_marker_size -= 2;\n\t\t\n\t\tif (opj_stream_read_data(p_stream, l_header_data, l_marker_size, p_manager) != l_marker_size) {\n\t\t\topj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t\n\t\tif (! opj_j2k_get_sot_values(l_header_data, l_marker_size, &l_tile_no, &l_tot_len, &l_current_part, &l_num_parts, p_manager)) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\t\n\t\tif (l_tile_no == tile_no) {\n\t\t\t/* we found what we were looking for */\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif ((l_tot_len == 0U) || (l_tot_len < 14U)) {\n\t\t\t/* last SOT until EOC or invalid Psot value */\n\t\t\t/* assume all is OK */\n\t\t\tif (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t\treturn OPJ_TRUE;\n\t\t}\n\t\tl_tot_len -= 12U;\n\t\t/* look for next SOT marker */\n\t\tif (opj_stream_skip(p_stream, (OPJ_OFF_T)(l_tot_len), p_manager) != (OPJ_OFF_T)(l_tot_len)) {\n\t\t\t/* assume all is OK */\n\t\t\tif (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t\treturn OPJ_TRUE;\n\t\t}\n\t}\n\t\n\t/* check for correction */\n\tif (l_current_part == l_num_parts) {\n\t\t*p_correction_needed = OPJ_TRUE;\n\t}\n\t\n\tif (! opj_stream_seek(p_stream, l_stream_pos_backup, p_manager)) {\n\t\treturn OPJ_FALSE;\n\t}\n\treturn OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_read_tile_header(      opj_j2k_t * p_j2k,\n                                                                    OPJ_UINT32 * p_tile_index,\n                                                                    OPJ_UINT32 * p_data_size,\n                                                                    OPJ_INT32 * p_tile_x0, OPJ_INT32 * p_tile_y0,\n                                                                    OPJ_INT32 * p_tile_x1, OPJ_INT32 * p_tile_y1,\n                                                                    OPJ_UINT32 * p_nb_comps,\n                                                                    OPJ_BOOL * p_go_on,\n                                                                    opj_stream_private_t *p_stream,\n                                                                    opj_event_mgr_t * p_manager )\n{\n        OPJ_UINT32 l_current_marker = J2K_MS_SOT;\n        OPJ_UINT32 l_marker_size;\n        const opj_dec_memory_marker_handler_t * l_marker_handler = 00;\n        opj_tcp_t * l_tcp = NULL;\n\n        /* preconditions */\n        assert(p_stream != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        /* Reach the End Of Codestream ?*/\n        if (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_EOC){\n                l_current_marker = J2K_MS_EOC;\n        }\n        /* We need to encounter a SOT marker (a new tile-part header) */\n        else if (p_j2k->m_specific_param.m_decoder.m_state != J2K_STATE_TPHSOT){\n                return OPJ_FALSE;\n        }\n\n        /* Read into the codestream until reach the EOC or ! can_decode ??? FIXME */\n        while ( (!p_j2k->m_specific_param.m_decoder.m_can_decode) && (l_current_marker != J2K_MS_EOC) ) {\n\n                /* Try to read until the Start Of Data is detected */\n                while (l_current_marker != J2K_MS_SOD) {\n                    \n                    if(opj_stream_get_number_byte_left(p_stream) == 0)\n                    {\n                        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;\n                        break;\n                    }\n\n                        /* Try to read 2 bytes (the marker size) from stream and copy them into the buffer */\n                        if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                                return OPJ_FALSE;\n                        }\n\n                        /* Read 2 bytes from the buffer as the marker size */\n                        opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_marker_size,2);\n\n                        /* Check marker size (does not include marker ID but includes marker size) */\n                        if (l_marker_size < 2) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Inconsistent marker size\\n\");\n                                return OPJ_FALSE;\n                        }\n\n                        /* cf. https://code.google.com/p/openjpeg/issues/detail?id=226 */\n                        if (l_current_marker == 0x8080 && opj_stream_get_number_byte_left(p_stream) == 0) {\n                                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;\n                                break;\n                        }\n\n                        /* Why this condition? FIXME */\n                        if (p_j2k->m_specific_param.m_decoder.m_state & J2K_STATE_TPH){\n                                p_j2k->m_specific_param.m_decoder.m_sot_length -= (l_marker_size + 2);\n                        }\n                        l_marker_size -= 2; /* Subtract the size of the marker ID already read */\n\n                        /* Get the marker handler from the marker ID */\n                        l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);\n\n                        /* Check if the marker is known and if it is the right place to find it */\n                        if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states) ) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Marker is not compliant with its position\\n\");\n                                return OPJ_FALSE;\n                        }\n/* FIXME manage case of unknown marker as in the main header ? */\n\n                        /* Check if the marker size is compatible with the header data size */\n                        if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {\n                                OPJ_BYTE *new_header_data = NULL;\n                                /* If we are here, this means we consider this marker as known & we will read it */\n                                /* Check enough bytes left in stream before allocation */\n                                if ((OPJ_OFF_T)l_marker_size >  opj_stream_get_number_byte_left(p_stream)) {\n                                        opj_event_msg(p_manager, EVT_ERROR, \"Marker size inconsistent with stream length\\n\");\n                                        return OPJ_FALSE;\n                                }\n                                new_header_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size);\n                                if (! new_header_data) {\n                                        opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);\n                                        p_j2k->m_specific_param.m_decoder.m_header_data = NULL;\n                                        p_j2k->m_specific_param.m_decoder.m_header_data_size = 0;\n                                        opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to read header\\n\");\n                                        return OPJ_FALSE;\n                                }\n                                p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;\n                                p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;\n                        }\n\n                        /* Try to read the rest of the marker segment from stream and copy them into the buffer */\n                        if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,l_marker_size,p_manager) != l_marker_size) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                                return OPJ_FALSE;\n                        }\n\n                        if (!l_marker_handler->handler) {\n                                /* See issue #175 */\n                                opj_event_msg(p_manager, EVT_ERROR, \"Not sure how that happened.\\n\");\n                                return OPJ_FALSE;\n                        }\n                        /* Read the marker segment with the correct marker handler */\n                        if (! (*(l_marker_handler->handler))(p_j2k,p_j2k->m_specific_param.m_decoder.m_header_data,l_marker_size,p_manager)) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Fail to read the current marker segment (%#x)\\n\", l_current_marker);\n                                return OPJ_FALSE;\n                        }\n\n                        /* Add the marker to the codestream index*/\n                        if (OPJ_FALSE == opj_j2k_add_tlmarker(p_j2k->m_current_tile_number,\n                                                p_j2k->cstr_index,\n                                                l_marker_handler->id,\n                                                (OPJ_UINT32) opj_stream_tell(p_stream) - l_marker_size - 4,\n                                                l_marker_size + 4 )) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to add tl marker\\n\");\n                                return OPJ_FALSE;\n                        }\n\n                        /* Keep the position of the last SOT marker read */\n                        if ( l_marker_handler->id == J2K_MS_SOT ) {\n                                OPJ_UINT32 sot_pos = (OPJ_UINT32) opj_stream_tell(p_stream) - l_marker_size - 4 ;\n                                if (sot_pos > p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos)\n                                {\n                                        p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = sot_pos;\n                                }\n                        }\n\n                        if (p_j2k->m_specific_param.m_decoder.m_skip_data) {\n                                /* Skip the rest of the tile part header*/\n                                if (opj_stream_skip(p_stream,p_j2k->m_specific_param.m_decoder.m_sot_length,p_manager) != p_j2k->m_specific_param.m_decoder.m_sot_length) {\n                                        opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                                        return OPJ_FALSE;\n                                }\n                                l_current_marker = J2K_MS_SOD; /* Normally we reached a SOD */\n                        }\n                        else {\n                                /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer*/\n                                if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {\n                                        opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                                        return OPJ_FALSE;\n                                }\n                                /* Read 2 bytes from the buffer as the new marker ID */\n                                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_current_marker,2);\n                        }\n                }\n                if(opj_stream_get_number_byte_left(p_stream) == 0\n                    && p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NEOC)\n                    break;\n\n                /* If we didn't skip data before, we need to read the SOD marker*/\n                if (! p_j2k->m_specific_param.m_decoder.m_skip_data) {\n                        /* Try to read the SOD marker and skip data ? FIXME */\n                        if (! opj_j2k_read_sod(p_j2k, p_stream, p_manager)) {\n                                return OPJ_FALSE;\n                        }\n                        if (p_j2k->m_specific_param.m_decoder.m_can_decode && !p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked) {\n                                /* Issue 254 */\n                                OPJ_BOOL l_correction_needed;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n                                p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked = 1;\n                                if(!opj_j2k_need_nb_tile_parts_correction(p_stream, p_j2k->m_current_tile_number, &l_correction_needed, p_manager)) {\n                                        opj_event_msg(p_manager, EVT_ERROR, \"opj_j2k_apply_nb_tile_parts_correction error\\n\");\n                                        return OPJ_FALSE;\n                                }\n                                if (l_correction_needed) {\n                                        OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;\n                                        OPJ_UINT32 l_tile_no;\n\n                                        p_j2k->m_specific_param.m_decoder.m_can_decode = 0;\n                                        p_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction = 1;\n                                        /* correct tiles */\n                                        for (l_tile_no = 0U; l_tile_no < l_nb_tiles; ++l_tile_no) {\n                                                if (p_j2k->m_cp.tcps[l_tile_no].m_nb_tile_parts != 0U) {\n                                                        p_j2k->m_cp.tcps[l_tile_no].m_nb_tile_parts+=1;\n                                                }\n                                        }\n                                        opj_event_msg(p_manager, EVT_WARNING, \"Non conformant codestream TPsot==TNsot.\\n\");\n                                }\n                        }\n                        if (! p_j2k->m_specific_param.m_decoder.m_can_decode){\n                                /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */\n                                if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {\n                                        opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                                        return OPJ_FALSE;\n                                }\n\n                                /* Read 2 bytes from buffer as the new marker ID */\n                                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_current_marker,2);\n                        }\n                }\n                else {\n                        /* Indicate we will try to read a new tile-part header*/\n                        p_j2k->m_specific_param.m_decoder.m_skip_data = 0;\n                        p_j2k->m_specific_param.m_decoder.m_can_decode = 0;\n                        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;\n\n                        /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */\n                        if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                                return OPJ_FALSE;\n                        }\n\n                        /* Read 2 bytes from buffer as the new marker ID */\n                        opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_current_marker,2);\n                }\n        }\n\n        /* Current marker is the EOC marker ?*/\n        if (l_current_marker == J2K_MS_EOC) {\n                if (p_j2k->m_specific_param.m_decoder.m_state != J2K_STATE_EOC ){\n                        p_j2k->m_current_tile_number = 0;\n                        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_EOC;\n                }\n        }\n\n        /* FIXME DOC ???*/\n        if ( ! p_j2k->m_specific_param.m_decoder.m_can_decode) {\n                OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n                l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;\n\n                while( (p_j2k->m_current_tile_number < l_nb_tiles) && (l_tcp->m_data == 00) ) {\n                        ++p_j2k->m_current_tile_number;\n                        ++l_tcp;\n                }\n\n                if (p_j2k->m_current_tile_number == l_nb_tiles) {\n                        *p_go_on = OPJ_FALSE;\n                        return OPJ_TRUE;\n                }\n        }\n\n        if (! opj_j2k_merge_ppt(p_j2k->m_cp.tcps + p_j2k->m_current_tile_number, p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Failed to merge PPT data\\n\");\n                return OPJ_FALSE;\n        }\n        /*FIXME ???*/\n        if (! opj_tcd_init_decode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number, p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Cannot decode tile, memory error\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_event_msg(p_manager, EVT_INFO, \"Header of tile %d / %d has been read.\\n\",\n                        p_j2k->m_current_tile_number+1, (p_j2k->m_cp.th * p_j2k->m_cp.tw));\n\n        *p_tile_index = p_j2k->m_current_tile_number;\n        *p_go_on = OPJ_TRUE;\n        *p_data_size = opj_tcd_get_decoded_tile_size(p_j2k->m_tcd);\n        *p_tile_x0 = p_j2k->m_tcd->tcd_image->tiles->x0;\n        *p_tile_y0 = p_j2k->m_tcd->tcd_image->tiles->y0;\n        *p_tile_x1 = p_j2k->m_tcd->tcd_image->tiles->x1;\n        *p_tile_y1 = p_j2k->m_tcd->tcd_image->tiles->y1;\n        *p_nb_comps = p_j2k->m_tcd->tcd_image->tiles->numcomps;\n\n         p_j2k->m_specific_param.m_decoder.m_state |= 0x0080;/* FIXME J2K_DEC_STATE_DATA;*/\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_decode_tile (  opj_j2k_t * p_j2k,\n                                                        OPJ_UINT32 p_tile_index,\n                                                        OPJ_BYTE * p_data,\n                                                        OPJ_UINT32 p_data_size,\n                                                        opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager )\n{\n        OPJ_UINT32 l_current_marker;\n        OPJ_BYTE l_data [2];\n        opj_tcp_t * l_tcp;\n\n        /* preconditions */\n        assert(p_stream != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        if ( !(p_j2k->m_specific_param.m_decoder.m_state & 0x0080/*FIXME J2K_DEC_STATE_DATA*/)\n                || (p_tile_index != p_j2k->m_current_tile_number) ) {\n                return OPJ_FALSE;\n        }\n\n        l_tcp = &(p_j2k->m_cp.tcps[p_tile_index]);\n        if (! l_tcp->m_data) {\n                opj_j2k_tcp_destroy(l_tcp);\n                return OPJ_FALSE;\n        }\n\n        if (! opj_tcd_decode_tile(      p_j2k->m_tcd,\n                                                                l_tcp->m_data,\n                                                                l_tcp->m_data_size,\n                                                                p_tile_index,\n                                                                p_j2k->cstr_index, p_manager) ) {\n                opj_j2k_tcp_destroy(l_tcp);\n                p_j2k->m_specific_param.m_decoder.m_state |= 0x8000;/*FIXME J2K_DEC_STATE_ERR;*/\n                opj_event_msg(p_manager, EVT_ERROR, \"Failed to decode.\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (! opj_tcd_update_tile_data(p_j2k->m_tcd,p_data,p_data_size)) {\n                return OPJ_FALSE;\n        }\n\n        /* To avoid to destroy the tcp which can be useful when we try to decode a tile decoded before (cf j2k_random_tile_access)\n         * we destroy just the data which will be re-read in read_tile_header*/\n        /*opj_j2k_tcp_destroy(l_tcp);\n        p_j2k->m_tcd->tcp = 0;*/\n        opj_j2k_tcp_data_destroy(l_tcp);\n\n        p_j2k->m_specific_param.m_decoder.m_can_decode = 0;\n        p_j2k->m_specific_param.m_decoder.m_state &= (~ (0x0080u));/* FIXME J2K_DEC_STATE_DATA);*/\n\n        if(opj_stream_get_number_byte_left(p_stream) == 0 \n            && p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NEOC){\n            return OPJ_TRUE;\n        }\n\n        if (p_j2k->m_specific_param.m_decoder.m_state != 0x0100){ /*FIXME J2K_DEC_STATE_EOC)*/\n                if (opj_stream_read_data(p_stream,l_data,2,p_manager) != 2) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Stream too short\\n\");\n                        return OPJ_FALSE;\n                }\n\n                opj_read_bytes(l_data,&l_current_marker,2);\n\n                if (l_current_marker == J2K_MS_EOC) {\n                        p_j2k->m_current_tile_number = 0;\n                        p_j2k->m_specific_param.m_decoder.m_state =  0x0100;/*FIXME J2K_DEC_STATE_EOC;*/\n                }\n                else if (l_current_marker != J2K_MS_SOT)\n                {       \n                        if(opj_stream_get_number_byte_left(p_stream) == 0) {\n                            p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;\n                            opj_event_msg(p_manager, EVT_WARNING, \"Stream does not end with EOC\\n\");\n                            return OPJ_TRUE;\n                        }\n                        opj_event_msg(p_manager, EVT_ERROR, \"Stream too short, expected SOT\\n\");\n                        return OPJ_FALSE;\n                }\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_update_image_data (opj_tcd_t * p_tcd, OPJ_BYTE * p_data, opj_image_t* p_output_image)\n{\n        OPJ_UINT32 i,j,k = 0;\n        OPJ_UINT32 l_width_src,l_height_src;\n        OPJ_UINT32 l_width_dest,l_height_dest;\n        OPJ_INT32 l_offset_x0_src, l_offset_y0_src, l_offset_x1_src, l_offset_y1_src;\n        OPJ_SIZE_T l_start_offset_src, l_line_offset_src, l_end_offset_src ;\n        OPJ_UINT32 l_start_x_dest , l_start_y_dest;\n        OPJ_UINT32 l_x0_dest, l_y0_dest, l_x1_dest, l_y1_dest;\n        OPJ_SIZE_T l_start_offset_dest, l_line_offset_dest;\n\n        opj_image_comp_t * l_img_comp_src = 00;\n        opj_image_comp_t * l_img_comp_dest = 00;\n\n        opj_tcd_tilecomp_t * l_tilec = 00;\n        opj_image_t * l_image_src = 00;\n        OPJ_UINT32 l_size_comp, l_remaining;\n        OPJ_INT32 * l_dest_ptr;\n        opj_tcd_resolution_t* l_res= 00;\n\n        l_tilec = p_tcd->tcd_image->tiles->comps;\n        l_image_src = p_tcd->image;\n        l_img_comp_src = l_image_src->comps;\n\n        l_img_comp_dest = p_output_image->comps;\n\n        for (i=0; i<l_image_src->numcomps; i++) {\n\n                /* Allocate output component buffer if necessary */\n                if (!l_img_comp_dest->data) {\n                        OPJ_SIZE_T l_width = l_img_comp_dest->w;\n                        OPJ_SIZE_T l_height = l_img_comp_dest->h;\n\n                        if ((l_height == 0U) || (l_width > (SIZE_MAX / l_height))) {\n                                /* would overflow */\n                                return OPJ_FALSE;\n                        }\n                        l_img_comp_dest->data = (OPJ_INT32*) opj_calloc(l_width * l_height, sizeof(OPJ_INT32));\n                        if (! l_img_comp_dest->data) {\n                                return OPJ_FALSE;\n                        }\n                }\n\n                /* Copy info from decoded comp image to output image */\n                l_img_comp_dest->resno_decoded = l_img_comp_src->resno_decoded;\n\n                /*-----*/\n                /* Compute the precision of the output buffer */\n                l_size_comp = l_img_comp_src->prec >> 3; /*(/ 8)*/\n                l_remaining = l_img_comp_src->prec & 7;  /* (%8) */\n                l_res = l_tilec->resolutions + l_img_comp_src->resno_decoded;\n\n                if (l_remaining) {\n                        ++l_size_comp;\n                }\n\n                if (l_size_comp == 3) {\n                        l_size_comp = 4;\n                }\n                /*-----*/\n\n                /* Current tile component size*/\n                /*if (i == 0) {\n                fprintf(stdout, \"SRC: l_res_x0=%d, l_res_x1=%d, l_res_y0=%d, l_res_y1=%d\\n\",\n                                l_res->x0, l_res->x1, l_res->y0, l_res->y1);\n                }*/\n\n                l_width_src = (OPJ_UINT32)(l_res->x1 - l_res->x0);\n                l_height_src = (OPJ_UINT32)(l_res->y1 - l_res->y0);\n\n                /* Border of the current output component*/\n                l_x0_dest = opj_uint_ceildivpow2(l_img_comp_dest->x0, l_img_comp_dest->factor);\n                l_y0_dest = opj_uint_ceildivpow2(l_img_comp_dest->y0, l_img_comp_dest->factor);\n                l_x1_dest = l_x0_dest + l_img_comp_dest->w; /* can't overflow given that image->x1 is uint32 */\n                l_y1_dest = l_y0_dest + l_img_comp_dest->h;\n\n                /*if (i == 0) {\n                fprintf(stdout, \"DEST: l_x0_dest=%d, l_x1_dest=%d, l_y0_dest=%d, l_y1_dest=%d (%d)\\n\",\n                                l_x0_dest, l_x1_dest, l_y0_dest, l_y1_dest, l_img_comp_dest->factor );\n                }*/\n\n                /*-----*/\n                /* Compute the area (l_offset_x0_src, l_offset_y0_src, l_offset_x1_src, l_offset_y1_src)\n                 * of the input buffer (decoded tile component) which will be move\n                 * in the output buffer. Compute the area of the output buffer (l_start_x_dest,\n                 * l_start_y_dest, l_width_dest, l_height_dest)  which will be modified\n                 * by this input area.\n                 * */\n                assert( l_res->x0 >= 0);\n                assert( l_res->x1 >= 0);\n                if ( l_x0_dest < (OPJ_UINT32)l_res->x0 ) {\n                        l_start_x_dest = (OPJ_UINT32)l_res->x0 - l_x0_dest;\n                        l_offset_x0_src = 0;\n\n                        if ( l_x1_dest >= (OPJ_UINT32)l_res->x1 ) {\n                                l_width_dest = l_width_src;\n                                l_offset_x1_src = 0;\n                        }\n                        else {\n                                l_width_dest = l_x1_dest - (OPJ_UINT32)l_res->x0 ;\n                                l_offset_x1_src = (OPJ_INT32)(l_width_src - l_width_dest);\n                        }\n                }\n                else {\n                        l_start_x_dest = 0U;\n                        l_offset_x0_src = (OPJ_INT32)l_x0_dest - l_res->x0;\n\n                        if ( l_x1_dest >= (OPJ_UINT32)l_res->x1 ) {\n                                l_width_dest = l_width_src - (OPJ_UINT32)l_offset_x0_src;\n                                l_offset_x1_src = 0;\n                        }\n                        else {\n                                l_width_dest = l_img_comp_dest->w ;\n                                l_offset_x1_src = l_res->x1 - (OPJ_INT32)l_x1_dest;\n                        }\n                }\n\n                if ( l_y0_dest < (OPJ_UINT32)l_res->y0 ) {\n                        l_start_y_dest = (OPJ_UINT32)l_res->y0 - l_y0_dest;\n                        l_offset_y0_src = 0;\n\n                        if ( l_y1_dest >= (OPJ_UINT32)l_res->y1 ) {\n                                l_height_dest = l_height_src;\n                                l_offset_y1_src = 0;\n                        }\n                        else {\n                                l_height_dest = l_y1_dest - (OPJ_UINT32)l_res->y0 ;\n                                l_offset_y1_src =  (OPJ_INT32)(l_height_src - l_height_dest);\n                        }\n                }\n                else {\n                        l_start_y_dest = 0U;\n                        l_offset_y0_src = (OPJ_INT32)l_y0_dest - l_res->y0;\n\n                        if ( l_y1_dest >= (OPJ_UINT32)l_res->y1 ) {\n                                l_height_dest = l_height_src - (OPJ_UINT32)l_offset_y0_src;\n                                l_offset_y1_src = 0;\n                        }\n                        else {\n                                l_height_dest = l_img_comp_dest->h ;\n                                l_offset_y1_src = l_res->y1 - (OPJ_INT32)l_y1_dest;\n                        }\n                }\n\n                if( (l_offset_x0_src < 0 ) || (l_offset_y0_src < 0 ) || (l_offset_x1_src < 0 ) || (l_offset_y1_src < 0 ) ){\n                        return OPJ_FALSE;\n                }\n                /* testcase 2977.pdf.asan.67.2198 */\n                if ((OPJ_INT32)l_width_dest < 0 || (OPJ_INT32)l_height_dest < 0) {\n                        return OPJ_FALSE;\n                }\n                /*-----*/\n\n                /* Compute the input buffer offset */\n                l_start_offset_src = (OPJ_SIZE_T)l_offset_x0_src + (OPJ_SIZE_T)l_offset_y0_src * (OPJ_SIZE_T)l_width_src;\n                l_line_offset_src  = (OPJ_SIZE_T)l_offset_x1_src + (OPJ_SIZE_T)l_offset_x0_src;\n                l_end_offset_src   = (OPJ_SIZE_T)l_offset_y1_src * (OPJ_SIZE_T)l_width_src - (OPJ_SIZE_T)l_offset_x0_src;\n\n                /* Compute the output buffer offset */\n                l_start_offset_dest = (OPJ_SIZE_T)l_start_x_dest + (OPJ_SIZE_T)l_start_y_dest * (OPJ_SIZE_T)l_img_comp_dest->w;\n                l_line_offset_dest  = (OPJ_SIZE_T)l_img_comp_dest->w - (OPJ_SIZE_T)l_width_dest;\n\n                /* Move the output buffer to the first place where we will write*/\n                l_dest_ptr = l_img_comp_dest->data + l_start_offset_dest;\n\n                /*if (i == 0) {\n                        fprintf(stdout, \"COMPO[%d]:\\n\",i);\n                        fprintf(stdout, \"SRC: l_start_x_src=%d, l_start_y_src=%d, l_width_src=%d, l_height_src=%d\\n\"\n                                        \"\\t tile offset:%d, %d, %d, %d\\n\"\n                                        \"\\t buffer offset: %d; %d, %d\\n\",\n                                        l_res->x0, l_res->y0, l_width_src, l_height_src,\n                                        l_offset_x0_src, l_offset_y0_src, l_offset_x1_src, l_offset_y1_src,\n                                        l_start_offset_src, l_line_offset_src, l_end_offset_src);\n\n                        fprintf(stdout, \"DEST: l_start_x_dest=%d, l_start_y_dest=%d, l_width_dest=%d, l_height_dest=%d\\n\"\n                                        \"\\t start offset: %d, line offset= %d\\n\",\n                                        l_start_x_dest, l_start_y_dest, l_width_dest, l_height_dest, l_start_offset_dest, l_line_offset_dest);\n                }*/\n\n                switch (l_size_comp) {\n                        case 1:\n                                {\n                                        OPJ_CHAR * l_src_ptr = (OPJ_CHAR*) p_data;\n                                        l_src_ptr += l_start_offset_src; /* Move to the first place where we will read*/\n\n                                        if (l_img_comp_src->sgnd) {\n                                                for (j = 0 ; j < l_height_dest ; ++j) {\n                                                        for ( k = 0 ; k < l_width_dest ; ++k) {\n                                                                *(l_dest_ptr++) = (OPJ_INT32) (*(l_src_ptr++)); /* Copy only the data needed for the output image */\n                                                        }\n\n                                                        l_dest_ptr+= l_line_offset_dest; /* Move to the next place where we will write */\n                                                        l_src_ptr += l_line_offset_src ; /* Move to the next place where we will read */\n                                                }\n                                        }\n                                        else {\n                                                for ( j = 0 ; j < l_height_dest ; ++j ) {\n                                                        for ( k = 0 ; k < l_width_dest ; ++k) {\n                                                                *(l_dest_ptr++) = (OPJ_INT32) ((*(l_src_ptr++))&0xff);\n                                                        }\n\n                                                        l_dest_ptr+= l_line_offset_dest;\n                                                        l_src_ptr += l_line_offset_src;\n                                                }\n                                        }\n\n                                        l_src_ptr += l_end_offset_src; /* Move to the end of this component-part of the input buffer */\n                                        p_data = (OPJ_BYTE*) l_src_ptr; /* Keep the current position for the next component-part */\n                                }\n                                break;\n                        case 2:\n                                {\n                                        OPJ_INT16 * l_src_ptr = (OPJ_INT16 *) p_data;\n                                        l_src_ptr += l_start_offset_src;\n\n                                        if (l_img_comp_src->sgnd) {\n                                                for (j=0;j<l_height_dest;++j) {\n                                                        for (k=0;k<l_width_dest;++k) {\n                                                                *(l_dest_ptr++) = *(l_src_ptr++);\n                                                        }\n\n                                                        l_dest_ptr+= l_line_offset_dest;\n                                                        l_src_ptr += l_line_offset_src ;\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_height_dest;++j) {\n                                                        for (k=0;k<l_width_dest;++k) {\n                                                                *(l_dest_ptr++) = (*(l_src_ptr++))&0xffff;\n                                                        }\n\n                                                        l_dest_ptr+= l_line_offset_dest;\n                                                        l_src_ptr += l_line_offset_src ;\n                                                }\n                                        }\n\n                                        l_src_ptr += l_end_offset_src;\n                                        p_data = (OPJ_BYTE*) l_src_ptr;\n                                }\n                                break;\n                        case 4:\n                                {\n                                        OPJ_INT32 * l_src_ptr = (OPJ_INT32 *) p_data;\n                                        l_src_ptr += l_start_offset_src;\n\n                                        for (j=0;j<l_height_dest;++j) {\n                                                for (k=0;k<l_width_dest;++k) {\n                                                        *(l_dest_ptr++) = (*(l_src_ptr++));\n                                                }\n\n                                                l_dest_ptr+= l_line_offset_dest;\n                                                l_src_ptr += l_line_offset_src ;\n                                        }\n\n                                        l_src_ptr += l_end_offset_src;\n                                        p_data = (OPJ_BYTE*) l_src_ptr;\n                                }\n                                break;\n                }\n\n                ++l_img_comp_dest;\n                ++l_img_comp_src;\n                ++l_tilec;\n        }\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_set_decode_area(       opj_j2k_t *p_j2k,\n                                                                    opj_image_t* p_image,\n                                                                    OPJ_INT32 p_start_x, OPJ_INT32 p_start_y,\n                                                                    OPJ_INT32 p_end_x, OPJ_INT32 p_end_y,\n                                                                    opj_event_mgr_t * p_manager )\n{\n        opj_cp_t * l_cp = &(p_j2k->m_cp);\n        opj_image_t * l_image = p_j2k->m_private_image;\n\n        OPJ_UINT32 it_comp;\n        OPJ_INT32 l_comp_x1, l_comp_y1;\n        opj_image_comp_t* l_img_comp = NULL;\n\n        /* Check if we are read the main header */\n        if (p_j2k->m_specific_param.m_decoder.m_state != J2K_STATE_TPHSOT) { /* FIXME J2K_DEC_STATE_TPHSOT)*/\n                opj_event_msg(p_manager, EVT_ERROR, \"Need to decode the main header before begin to decode the remaining codestream\");\n                return OPJ_FALSE;\n        }\n\n        if ( !p_start_x && !p_start_y && !p_end_x && !p_end_y){\n                opj_event_msg(p_manager, EVT_INFO, \"No decoded area parameters, set the decoded area to the whole image\\n\");\n\n                p_j2k->m_specific_param.m_decoder.m_start_tile_x = 0;\n                p_j2k->m_specific_param.m_decoder.m_start_tile_y = 0;\n                p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;\n                p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;\n\n                return OPJ_TRUE;\n        }\n\n        /* ----- */\n        /* Check if the positions provided by the user are correct */\n\n        /* Left */\n        assert(p_start_x >= 0 );\n        assert(p_start_y >= 0 );\n\n        if ((OPJ_UINT32)p_start_x > l_image->x1 ) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                        \"Left position of the decoded area (region_x0=%d) is outside the image area (Xsiz=%d).\\n\",\n                        p_start_x, l_image->x1);\n                return OPJ_FALSE;\n        }\n        else if ((OPJ_UINT32)p_start_x < l_image->x0){\n                opj_event_msg(p_manager, EVT_WARNING,\n                                \"Left position of the decoded area (region_x0=%d) is outside the image area (XOsiz=%d).\\n\",\n                                p_start_x, l_image->x0);\n                p_j2k->m_specific_param.m_decoder.m_start_tile_x = 0;\n                p_image->x0 = l_image->x0;\n        }\n        else {\n                p_j2k->m_specific_param.m_decoder.m_start_tile_x = ((OPJ_UINT32)p_start_x - l_cp->tx0) / l_cp->tdx;\n                p_image->x0 = (OPJ_UINT32)p_start_x;\n        }\n\n        /* Up */\n        if ((OPJ_UINT32)p_start_y > l_image->y1){\n                opj_event_msg(p_manager, EVT_ERROR,\n                                \"Up position of the decoded area (region_y0=%d) is outside the image area (Ysiz=%d).\\n\",\n                                p_start_y, l_image->y1);\n                return OPJ_FALSE;\n        }\n        else if ((OPJ_UINT32)p_start_y < l_image->y0){\n                opj_event_msg(p_manager, EVT_WARNING,\n                                \"Up position of the decoded area (region_y0=%d) is outside the image area (YOsiz=%d).\\n\",\n                                p_start_y, l_image->y0);\n                p_j2k->m_specific_param.m_decoder.m_start_tile_y = 0;\n                p_image->y0 = l_image->y0;\n        }\n        else {\n                p_j2k->m_specific_param.m_decoder.m_start_tile_y = ((OPJ_UINT32)p_start_y - l_cp->ty0) / l_cp->tdy;\n                p_image->y0 = (OPJ_UINT32)p_start_y;\n        }\n\n        /* Right */\n        assert((OPJ_UINT32)p_end_x > 0);\n        assert((OPJ_UINT32)p_end_y > 0);\n        if ((OPJ_UINT32)p_end_x < l_image->x0) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                        \"Right position of the decoded area (region_x1=%d) is outside the image area (XOsiz=%d).\\n\",\n                        p_end_x, l_image->x0);\n                return OPJ_FALSE;\n        }\n        else if ((OPJ_UINT32)p_end_x > l_image->x1) {\n                opj_event_msg(p_manager, EVT_WARNING,\n                        \"Right position of the decoded area (region_x1=%d) is outside the image area (Xsiz=%d).\\n\",\n                        p_end_x, l_image->x1);\n                p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;\n                p_image->x1 = l_image->x1;\n        }\n        else {\n                p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32)opj_int_ceildiv(p_end_x - (OPJ_INT32)l_cp->tx0, (OPJ_INT32)l_cp->tdx);\n                p_image->x1 = (OPJ_UINT32)p_end_x;\n        }\n\n        /* Bottom */\n        if ((OPJ_UINT32)p_end_y < l_image->y0) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                        \"Bottom position of the decoded area (region_y1=%d) is outside the image area (YOsiz=%d).\\n\",\n                        p_end_y, l_image->y0);\n                return OPJ_FALSE;\n        }\n        if ((OPJ_UINT32)p_end_y > l_image->y1){\n                opj_event_msg(p_manager, EVT_WARNING,\n                        \"Bottom position of the decoded area (region_y1=%d) is outside the image area (Ysiz=%d).\\n\",\n                        p_end_y, l_image->y1);\n                p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;\n                p_image->y1 = l_image->y1;\n        }\n        else{\n                p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32)opj_int_ceildiv(p_end_y - (OPJ_INT32)l_cp->ty0, (OPJ_INT32)l_cp->tdy);\n                p_image->y1 = (OPJ_UINT32)p_end_y;\n        }\n        /* ----- */\n\n        p_j2k->m_specific_param.m_decoder.m_discard_tiles = 1;\n\n        l_img_comp = p_image->comps;\n        for (it_comp=0; it_comp < p_image->numcomps; ++it_comp)\n        {\n                OPJ_INT32 l_h,l_w;\n\n                l_img_comp->x0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->x0, (OPJ_INT32)l_img_comp->dx);\n                l_img_comp->y0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->y0, (OPJ_INT32)l_img_comp->dy);\n                l_comp_x1 = opj_int_ceildiv((OPJ_INT32)p_image->x1, (OPJ_INT32)l_img_comp->dx);\n                l_comp_y1 = opj_int_ceildiv((OPJ_INT32)p_image->y1, (OPJ_INT32)l_img_comp->dy);\n\n                l_w = opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32)l_img_comp->factor)\n                                - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->x0, (OPJ_INT32)l_img_comp->factor);\n                if (l_w < 0){\n                        opj_event_msg(p_manager, EVT_ERROR,\n                                \"Size x of the decoded component image is incorrect (comp[%d].w=%d).\\n\",\n                                it_comp, l_w);\n                        return OPJ_FALSE;\n                }\n                l_img_comp->w = (OPJ_UINT32)l_w;\n\n                l_h = opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32)l_img_comp->factor)\n                                - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->y0, (OPJ_INT32)l_img_comp->factor);\n                if (l_h < 0){\n                        opj_event_msg(p_manager, EVT_ERROR,\n                                \"Size y of the decoded component image is incorrect (comp[%d].h=%d).\\n\",\n                                it_comp, l_h);\n                        return OPJ_FALSE;\n                }\n                l_img_comp->h = (OPJ_UINT32)l_h;\n\n                l_img_comp++;\n        }\n\n        opj_event_msg( p_manager, EVT_INFO,\"Setting decoding area to %d,%d,%d,%d\\n\",\n                        p_image->x0, p_image->y0, p_image->x1, p_image->y1);\n\n        return OPJ_TRUE;\n}\n\nopj_j2k_t* opj_j2k_create_decompress(void)\n{\n        opj_j2k_t *l_j2k = (opj_j2k_t*) opj_calloc(1,sizeof(opj_j2k_t));\n        if (!l_j2k) {\n                return 00;\n        }\n\n        l_j2k->m_is_decoder = 1;\n        l_j2k->m_cp.m_is_decoder = 1;\n\n#ifdef OPJ_DISABLE_TPSOT_FIX\n        l_j2k->m_specific_param.m_decoder.m_nb_tile_parts_correction_checked = 1;\n#endif\n\n        l_j2k->m_specific_param.m_decoder.m_default_tcp = (opj_tcp_t*) opj_calloc(1,sizeof(opj_tcp_t));\n        if (!l_j2k->m_specific_param.m_decoder.m_default_tcp) {\n                opj_j2k_destroy(l_j2k);\n                return 00;\n        }\n\n        l_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *) opj_calloc(1,OPJ_J2K_DEFAULT_HEADER_SIZE);\n        if (! l_j2k->m_specific_param.m_decoder.m_header_data) {\n                opj_j2k_destroy(l_j2k);\n                return 00;\n        }\n\n        l_j2k->m_specific_param.m_decoder.m_header_data_size = OPJ_J2K_DEFAULT_HEADER_SIZE;\n\n        l_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = -1 ;\n\n        l_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = 0 ;\n\n        /* codestream index creation */\n        l_j2k->cstr_index = opj_j2k_create_cstr_index();\n        if (!l_j2k->cstr_index){\n                opj_j2k_destroy(l_j2k);\n                return 00;\n        }\n\n        /* validation list creation */\n        l_j2k->m_validation_list = opj_procedure_list_create();\n        if (! l_j2k->m_validation_list) {\n                opj_j2k_destroy(l_j2k);\n                return 00;\n        }\n\n        /* execution list creation */\n        l_j2k->m_procedure_list = opj_procedure_list_create();\n        if (! l_j2k->m_procedure_list) {\n                opj_j2k_destroy(l_j2k);\n                return 00;\n        }\n\n        l_j2k->m_tp = opj_thread_pool_create(opj_j2k_get_default_thread_count());\n        if( !l_j2k->m_tp )\n        {\n            l_j2k->m_tp = opj_thread_pool_create(0);\n        }\n        if( !l_j2k->m_tp )\n        {\n            opj_j2k_destroy(l_j2k);\n            return NULL;\n        }\n\n        return l_j2k;\n}\n\nstatic opj_codestream_index_t* opj_j2k_create_cstr_index(void)\n{\n        opj_codestream_index_t* cstr_index = (opj_codestream_index_t*)\n                        opj_calloc(1,sizeof(opj_codestream_index_t));\n        if (!cstr_index)\n                return NULL;\n\n        cstr_index->maxmarknum = 100;\n        cstr_index->marknum = 0;\n        cstr_index->marker = (opj_marker_info_t*)\n                        opj_calloc(cstr_index->maxmarknum, sizeof(opj_marker_info_t));\n        if (!cstr_index-> marker) {\n                opj_free(cstr_index);\n                return NULL;\n        }\n\n        cstr_index->tile_index = NULL;\n\n        return cstr_index;\n}\n\nstatic OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size (       opj_j2k_t *p_j2k,\n                                                                                OPJ_UINT32 p_tile_no,\n                                                                                OPJ_UINT32 p_comp_no )\n{\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_tccp_t *l_tccp = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = &l_cp->tcps[p_tile_no];\n        l_tccp = &l_tcp->tccps[p_comp_no];\n\n        /* preconditions again */\n        assert(p_tile_no < (l_cp->tw * l_cp->th));\n        assert(p_comp_no < p_j2k->m_private_image->numcomps);\n\n        if (l_tccp->csty & J2K_CCP_CSTY_PRT) {\n                return 5 + l_tccp->numresolutions;\n        }\n        else {\n                return 5;\n        }\n}\n\nstatic OPJ_BOOL opj_j2k_compare_SPCod_SPCoc(opj_j2k_t *p_j2k, OPJ_UINT32 p_tile_no, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no)\n{\n\tOPJ_UINT32 i;\n\topj_cp_t *l_cp = NULL;\n\topj_tcp_t *l_tcp = NULL;\n\topj_tccp_t *l_tccp0 = NULL;\n\topj_tccp_t *l_tccp1 = NULL;\n\t\n\t/* preconditions */\n\tassert(p_j2k != 00);\n\t\n\tl_cp = &(p_j2k->m_cp);\n\tl_tcp = &l_cp->tcps[p_tile_no];\n\tl_tccp0 = &l_tcp->tccps[p_first_comp_no];\n\tl_tccp1 = &l_tcp->tccps[p_second_comp_no];\n\t\n\tif (l_tccp0->numresolutions != l_tccp1->numresolutions) {\n\t\treturn OPJ_FALSE;\n\t}\n\tif (l_tccp0->cblkw != l_tccp1->cblkw) {\n\t\treturn OPJ_FALSE;\n\t}\n\tif (l_tccp0->cblkh != l_tccp1->cblkh) {\n\t\treturn OPJ_FALSE;\n\t}\n\tif (l_tccp0->cblksty != l_tccp1->cblksty) {\n\t\treturn OPJ_FALSE;\n\t}\n\tif (l_tccp0->qmfbid != l_tccp1->qmfbid) {\n\t\treturn OPJ_FALSE;\n\t}\n\tif ((l_tccp0->csty & J2K_CCP_CSTY_PRT) != (l_tccp1->csty & J2K_CCP_CSTY_PRT)) {\n\t\treturn OPJ_FALSE;\n\t}\n\t\n\tfor (i = 0U; i < l_tccp0->numresolutions; ++i) {\n\t\tif (l_tccp0->prcw[i] != l_tccp1->prcw[i]) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t\tif (l_tccp0->prch[i] != l_tccp1->prch[i]) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t}\n\treturn OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_SPCod_SPCoc(     opj_j2k_t *p_j2k,\n                                                                    OPJ_UINT32 p_tile_no,\n                                                                    OPJ_UINT32 p_comp_no,\n                                                                    OPJ_BYTE * p_data,\n                                                                    OPJ_UINT32 * p_header_size,\n                                                                    struct opj_event_mgr * p_manager )\n{\n        OPJ_UINT32 i;\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_tccp_t *l_tccp = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_header_size != 00);\n        assert(p_manager != 00);\n        assert(p_data != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = &l_cp->tcps[p_tile_no];\n        l_tccp = &l_tcp->tccps[p_comp_no];\n\n        /* preconditions again */\n        assert(p_tile_no < (l_cp->tw * l_cp->th));\n        assert(p_comp_no <(p_j2k->m_private_image->numcomps));\n\n        if (*p_header_size < 5) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error writing SPCod SPCoc element\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_write_bytes(p_data,l_tccp->numresolutions - 1, 1);  /* SPcoc (D) */\n        ++p_data;\n\n        opj_write_bytes(p_data,l_tccp->cblkw - 2, 1);                   /* SPcoc (E) */\n        ++p_data;\n\n        opj_write_bytes(p_data,l_tccp->cblkh - 2, 1);                   /* SPcoc (F) */\n        ++p_data;\n\n        opj_write_bytes(p_data,l_tccp->cblksty, 1);                             /* SPcoc (G) */\n        ++p_data;\n\n        opj_write_bytes(p_data,l_tccp->qmfbid, 1);                              /* SPcoc (H) */\n        ++p_data;\n\n        *p_header_size = *p_header_size - 5;\n\n        if (l_tccp->csty & J2K_CCP_CSTY_PRT) {\n\n                if (*p_header_size < l_tccp->numresolutions) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error writing SPCod SPCoc element\\n\");\n                        return OPJ_FALSE;\n                }\n\n                for (i = 0; i < l_tccp->numresolutions; ++i) {\n                        opj_write_bytes(p_data,l_tccp->prcw[i] + (l_tccp->prch[i] << 4), 1);    /* SPcoc (I_i) */\n                        ++p_data;\n                }\n\n                *p_header_size = *p_header_size - l_tccp->numresolutions;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_SPCod_SPCoc(  opj_j2k_t *p_j2k,\n                                                                OPJ_UINT32 compno,\n                                                                OPJ_BYTE * p_header_data,\n                                                                OPJ_UINT32 * p_header_size,\n                                                                opj_event_mgr_t * p_manager)\n{\n        OPJ_UINT32 i, l_tmp;\n        opj_cp_t *l_cp = NULL;\n        opj_tcp_t *l_tcp = NULL;\n        opj_tccp_t *l_tccp = NULL;\n        OPJ_BYTE * l_current_ptr = NULL;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_header_data != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?\n                                &l_cp->tcps[p_j2k->m_current_tile_number] :\n                                p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n        /* precondition again */\n        assert(compno < p_j2k->m_private_image->numcomps);\n\n        l_tccp = &l_tcp->tccps[compno];\n        l_current_ptr = p_header_data;\n\n        /* make sure room is sufficient */\n        if (*p_header_size < 5) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading SPCod SPCoc element\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(l_current_ptr, &l_tccp->numresolutions ,1);              /* SPcox (D) */\n        ++l_tccp->numresolutions;                                                                               /* tccp->numresolutions = read() + 1 */\n        if (l_tccp->numresolutions > OPJ_J2K_MAXRLVLS) {\n                opj_event_msg(p_manager, EVT_ERROR,\n                              \"Invalid value for numresolutions : %d, max value is set in openjpeg.h at %d\\n\",\n                              l_tccp->numresolutions, OPJ_J2K_MAXRLVLS);\n                return OPJ_FALSE;\n        }\n        ++l_current_ptr;\n\n        /* If user wants to remove more resolutions than the codestream contains, return error */\n        if (l_cp->m_specific_param.m_dec.m_reduce >= l_tccp->numresolutions) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error decoding component %d.\\nThe number of resolutions to remove is higher than the number \"\n                                        \"of resolutions of this component\\nModify the cp_reduce parameter.\\n\\n\", compno);\n                p_j2k->m_specific_param.m_decoder.m_state |= 0x8000;/* FIXME J2K_DEC_STATE_ERR;*/\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(l_current_ptr,&l_tccp->cblkw ,1);                /* SPcoc (E) */\n        ++l_current_ptr;\n        l_tccp->cblkw += 2;\n\n        opj_read_bytes(l_current_ptr,&l_tccp->cblkh ,1);                /* SPcoc (F) */\n        ++l_current_ptr;\n        l_tccp->cblkh += 2;\n\n        if ((l_tccp->cblkw > 10) || (l_tccp->cblkh > 10) || ((l_tccp->cblkw + l_tccp->cblkh) > 12)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading SPCod SPCoc element, Invalid cblkw/cblkh combination\\n\");\n                return OPJ_FALSE;\n        }\n\t\n\n        opj_read_bytes(l_current_ptr,&l_tccp->cblksty ,1);              /* SPcoc (G) */\n        ++l_current_ptr;\n        if (l_tccp->cblksty & 0xC0U) { /* 2 msb are reserved, assume we can't read */\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading SPCod SPCoc element, Invalid code-block style found\\n\");\n                return OPJ_FALSE;\n        }\n\n        opj_read_bytes(l_current_ptr,&l_tccp->qmfbid ,1);               /* SPcoc (H) */\n        ++l_current_ptr;\n\n        *p_header_size = *p_header_size - 5;\n\n        /* use custom precinct size ? */\n        if (l_tccp->csty & J2K_CCP_CSTY_PRT) {\n                if (*p_header_size < l_tccp->numresolutions) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error reading SPCod SPCoc element\\n\");\n                        return OPJ_FALSE;\n                }\n\n                for     (i = 0; i < l_tccp->numresolutions; ++i) {\n                        opj_read_bytes(l_current_ptr,&l_tmp ,1);                /* SPcoc (I_i) */\n                        ++l_current_ptr;\n                        /* Precinct exponent 0 is only allowed for lowest resolution level (Table A.21) */\n                        if ((i != 0) && (((l_tmp & 0xf) == 0) || ((l_tmp >> 4) == 0))) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Invalid precinct size\\n\");\n                                return OPJ_FALSE;\n                        }\n                        l_tccp->prcw[i] = l_tmp & 0xf;\n                        l_tccp->prch[i] = l_tmp >> 4;\n                }\n\n                *p_header_size = *p_header_size - l_tccp->numresolutions;\n        }\n        else {\n                /* set default size for the precinct width and height */\n                for     (i = 0; i < l_tccp->numresolutions; ++i) {\n                        l_tccp->prcw[i] = 15;\n                        l_tccp->prch[i] = 15;\n                }\n        }\n\n#ifdef WIP_REMOVE_MSD\n        /* INDEX >> */\n        if (p_j2k->cstr_info && compno == 0) {\n                OPJ_UINT32 l_data_size = l_tccp->numresolutions * sizeof(OPJ_UINT32);\n\n                p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].cblkh = l_tccp->cblkh;\n                p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].cblkw = l_tccp->cblkw;\n                p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].numresolutions = l_tccp->numresolutions;\n                p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].cblksty = l_tccp->cblksty;\n                p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].qmfbid = l_tccp->qmfbid;\n\n                memcpy(p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].pdx,l_tccp->prcw, l_data_size);\n                memcpy(p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].pdy,l_tccp->prch, l_data_size);\n        }\n        /* << INDEX */\n#endif\n\n        return OPJ_TRUE;\n}\n\nstatic void opj_j2k_copy_tile_component_parameters( opj_j2k_t *p_j2k )\n{\n        /* loop */\n        OPJ_UINT32 i;\n        opj_cp_t *l_cp = NULL;\n        opj_tcp_t *l_tcp = NULL;\n        opj_tccp_t *l_ref_tccp = NULL, *l_copied_tccp = NULL;\n        OPJ_UINT32 l_prc_size;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ? /* FIXME J2K_DEC_STATE_TPH*/\n                                &l_cp->tcps[p_j2k->m_current_tile_number] :\n                                p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n        l_ref_tccp = &l_tcp->tccps[0];\n        l_copied_tccp = l_ref_tccp + 1;\n        l_prc_size = l_ref_tccp->numresolutions * (OPJ_UINT32)sizeof(OPJ_UINT32);\n\n        for     (i=1; i<p_j2k->m_private_image->numcomps; ++i) {\n                l_copied_tccp->numresolutions = l_ref_tccp->numresolutions;\n                l_copied_tccp->cblkw = l_ref_tccp->cblkw;\n                l_copied_tccp->cblkh = l_ref_tccp->cblkh;\n                l_copied_tccp->cblksty = l_ref_tccp->cblksty;\n                l_copied_tccp->qmfbid = l_ref_tccp->qmfbid;\n                memcpy(l_copied_tccp->prcw,l_ref_tccp->prcw,l_prc_size);\n                memcpy(l_copied_tccp->prch,l_ref_tccp->prch,l_prc_size);\n                ++l_copied_tccp;\n        }\n}\n\nstatic OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size ( opj_j2k_t *p_j2k,\n                                                                        OPJ_UINT32 p_tile_no,\n                                                                        OPJ_UINT32 p_comp_no )\n{\n        OPJ_UINT32 l_num_bands;\n\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_tccp_t *l_tccp = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = &l_cp->tcps[p_tile_no];\n        l_tccp = &l_tcp->tccps[p_comp_no];\n\n        /* preconditions again */\n        assert(p_tile_no < l_cp->tw * l_cp->th);\n        assert(p_comp_no < p_j2k->m_private_image->numcomps);\n\n        l_num_bands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 : (l_tccp->numresolutions * 3 - 2);\n\n        if (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT)  {\n                return 1 + l_num_bands;\n        }\n        else {\n                return 1 + 2*l_num_bands;\n        }\n}\n\nstatic OPJ_BOOL opj_j2k_compare_SQcd_SQcc(opj_j2k_t *p_j2k, OPJ_UINT32 p_tile_no, OPJ_UINT32 p_first_comp_no, OPJ_UINT32 p_second_comp_no)\n{\n\topj_cp_t *l_cp = NULL;\n\topj_tcp_t *l_tcp = NULL;\n\topj_tccp_t *l_tccp0 = NULL;\n\topj_tccp_t *l_tccp1 = NULL;\n\tOPJ_UINT32 l_band_no, l_num_bands;\n\t\n\t/* preconditions */\n\tassert(p_j2k != 00);\n\t\n\tl_cp = &(p_j2k->m_cp);\n\tl_tcp = &l_cp->tcps[p_tile_no];\n\tl_tccp0 = &l_tcp->tccps[p_first_comp_no];\n\tl_tccp1 = &l_tcp->tccps[p_second_comp_no];\n\t\n\tif (l_tccp0->qntsty != l_tccp1->qntsty ) {\n\t\treturn OPJ_FALSE;\n\t}\n\tif (l_tccp0->numgbits != l_tccp1->numgbits ) {\n\t\treturn OPJ_FALSE;\n\t}\n\tif (l_tccp0->qntsty == J2K_CCP_QNTSTY_SIQNT) {\n\t\tl_num_bands = 1U;\n\t} else {\n\t\tl_num_bands = l_tccp0->numresolutions * 3U - 2U;\n\t\tif (l_num_bands != (l_tccp1->numresolutions * 3U - 2U)) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t}\n\t\n\tfor (l_band_no = 0; l_band_no < l_num_bands; ++l_band_no) {\n\t\tif (l_tccp0->stepsizes[l_band_no].expn != l_tccp1->stepsizes[l_band_no].expn ) {\n\t\t\treturn OPJ_FALSE;\n\t\t}\n\t}\n\tif (l_tccp0->qntsty != J2K_CCP_QNTSTY_NOQNT)\n\t{\n\t\tfor (l_band_no = 0; l_band_no < l_num_bands; ++l_band_no) {\n\t\t\tif (l_tccp0->stepsizes[l_band_no].mant != l_tccp1->stepsizes[l_band_no].mant ) {\n\t\t\t\treturn OPJ_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\treturn OPJ_TRUE;\n}\n\n\nstatic OPJ_BOOL opj_j2k_write_SQcd_SQcc(       opj_j2k_t *p_j2k,\n                                                                OPJ_UINT32 p_tile_no,\n                                                                OPJ_UINT32 p_comp_no,\n                                                                OPJ_BYTE * p_data,\n                                                                OPJ_UINT32 * p_header_size,\n                                                                struct opj_event_mgr * p_manager )\n{\n        OPJ_UINT32 l_header_size;\n        OPJ_UINT32 l_band_no, l_num_bands;\n        OPJ_UINT32 l_expn,l_mant;\n\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_tccp_t *l_tccp = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_header_size != 00);\n        assert(p_manager != 00);\n        assert(p_data != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = &l_cp->tcps[p_tile_no];\n        l_tccp = &l_tcp->tccps[p_comp_no];\n\n        /* preconditions again */\n        assert(p_tile_no < l_cp->tw * l_cp->th);\n        assert(p_comp_no <p_j2k->m_private_image->numcomps);\n\n        l_num_bands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 : (l_tccp->numresolutions * 3 - 2);\n\n        if (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT)  {\n                l_header_size = 1 + l_num_bands;\n\n                if (*p_header_size < l_header_size) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error writing SQcd SQcc element\\n\");\n                        return OPJ_FALSE;\n                }\n\n                opj_write_bytes(p_data,l_tccp->qntsty + (l_tccp->numgbits << 5), 1);    /* Sqcx */\n                ++p_data;\n\n                for (l_band_no = 0; l_band_no < l_num_bands; ++l_band_no) {\n                        l_expn = (OPJ_UINT32)l_tccp->stepsizes[l_band_no].expn;\n                        opj_write_bytes(p_data, l_expn << 3, 1);        /* SPqcx_i */\n                        ++p_data;\n                }\n        }\n        else {\n                l_header_size = 1 + 2*l_num_bands;\n\n                if (*p_header_size < l_header_size) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error writing SQcd SQcc element\\n\");\n                        return OPJ_FALSE;\n                }\n\n                opj_write_bytes(p_data,l_tccp->qntsty + (l_tccp->numgbits << 5), 1);    /* Sqcx */\n                ++p_data;\n\n                for (l_band_no = 0; l_band_no < l_num_bands; ++l_band_no) {\n                        l_expn = (OPJ_UINT32)l_tccp->stepsizes[l_band_no].expn;\n                        l_mant = (OPJ_UINT32)l_tccp->stepsizes[l_band_no].mant;\n\n                        opj_write_bytes(p_data, (l_expn << 11) + l_mant, 2);    /* SPqcx_i */\n                        p_data += 2;\n                }\n        }\n\n        *p_header_size = *p_header_size - l_header_size;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k,\n                                                            OPJ_UINT32 p_comp_no,\n                                                            OPJ_BYTE* p_header_data,\n                                                            OPJ_UINT32 * p_header_size,\n                                                            opj_event_mgr_t * p_manager\n                                                            )\n{\n        /* loop*/\n        OPJ_UINT32 l_band_no;\n        opj_cp_t *l_cp = 00;\n        opj_tcp_t *l_tcp = 00;\n        opj_tccp_t *l_tccp = 00;\n        OPJ_BYTE * l_current_ptr = 00;\n        OPJ_UINT32 l_tmp, l_num_band;\n\n        /* preconditions*/\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_header_data != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        /* come from tile part header or main header ?*/\n        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ? /*FIXME J2K_DEC_STATE_TPH*/\n                                &l_cp->tcps[p_j2k->m_current_tile_number] :\n                                p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n        /* precondition again*/\n        assert(p_comp_no <  p_j2k->m_private_image->numcomps);\n\n        l_tccp = &l_tcp->tccps[p_comp_no];\n        l_current_ptr = p_header_data;\n\n        if (*p_header_size < 1) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error reading SQcd or SQcc element\\n\");\n                return OPJ_FALSE;\n        }\n        *p_header_size -= 1;\n\n        opj_read_bytes(l_current_ptr, &l_tmp ,1);                       /* Sqcx */\n        ++l_current_ptr;\n\n        l_tccp->qntsty = l_tmp & 0x1f;\n        l_tccp->numgbits = l_tmp >> 5;\n        if (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) {\n        l_num_band = 1;\n        }\n        else {\n                l_num_band = (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) ?\n                        (*p_header_size) :\n                        (*p_header_size) / 2;\n\n                if( l_num_band > OPJ_J2K_MAXBANDS ) {\n                        opj_event_msg(p_manager, EVT_WARNING, \"While reading CCP_QNTSTY element inside QCD or QCC marker segment, \"\n                                \"number of subbands (%d) is greater to OPJ_J2K_MAXBANDS (%d). So we limit the number of elements stored to \"\n                                \"OPJ_J2K_MAXBANDS (%d) and skip the rest. \\n\", l_num_band, OPJ_J2K_MAXBANDS, OPJ_J2K_MAXBANDS);\n                        /*return OPJ_FALSE;*/\n                }\n        }\n\n#ifdef USE_JPWL\n        if (l_cp->correct) {\n\n                /* if JPWL is on, we check whether there are too many subbands */\n                if (/*(l_num_band < 0) ||*/ (l_num_band >= OPJ_J2K_MAXBANDS)) {\n                        opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,\n                                \"JPWL: bad number of subbands in Sqcx (%d)\\n\",\n                                l_num_band);\n                        if (!JPWL_ASSUME) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"JPWL: giving up\\n\");\n                                return OPJ_FALSE;\n                        }\n                        /* we try to correct */\n                        l_num_band = 1;\n                        opj_event_msg(p_manager, EVT_WARNING, \"- trying to adjust them\\n\"\n                                \"- setting number of bands to %d => HYPOTHESIS!!!\\n\",\n                                l_num_band);\n                };\n\n        };\n#endif /* USE_JPWL */\n\n        if (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) {\n                for     (l_band_no = 0; l_band_no < l_num_band; l_band_no++) {\n                        opj_read_bytes(l_current_ptr, &l_tmp ,1);                       /* SPqcx_i */\n                        ++l_current_ptr;\n                        if (l_band_no < OPJ_J2K_MAXBANDS){\n                                l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32)(l_tmp >> 3);\n                                l_tccp->stepsizes[l_band_no].mant = 0;\n                        }\n                }\n                *p_header_size = *p_header_size - l_num_band;\n        }\n        else {\n                for     (l_band_no = 0; l_band_no < l_num_band; l_band_no++) {\n                        opj_read_bytes(l_current_ptr, &l_tmp ,2);                       /* SPqcx_i */\n                        l_current_ptr+=2;\n                        if (l_band_no < OPJ_J2K_MAXBANDS){\n                                l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32)(l_tmp >> 11);\n                                l_tccp->stepsizes[l_band_no].mant = l_tmp & 0x7ff;\n                        }\n                }\n                *p_header_size = *p_header_size - 2*l_num_band;\n        }\n\n        /* Add Antonin : if scalar_derived -> compute other stepsizes */\n        if (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) {\n                for (l_band_no = 1; l_band_no < OPJ_J2K_MAXBANDS; l_band_no++) {\n                        l_tccp->stepsizes[l_band_no].expn =\n                                ((OPJ_INT32)(l_tccp->stepsizes[0].expn) - (OPJ_INT32)((l_band_no - 1) / 3) > 0) ?\n                                        (OPJ_INT32)(l_tccp->stepsizes[0].expn) - (OPJ_INT32)((l_band_no - 1) / 3) : 0;\n                        l_tccp->stepsizes[l_band_no].mant = l_tccp->stepsizes[0].mant;\n                }\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic void opj_j2k_copy_tile_quantization_parameters( opj_j2k_t *p_j2k )\n{\n        OPJ_UINT32 i;\n        opj_cp_t *l_cp = NULL;\n        opj_tcp_t *l_tcp = NULL;\n        opj_tccp_t *l_ref_tccp = NULL;\n        opj_tccp_t *l_copied_tccp = NULL;\n        OPJ_UINT32 l_size;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?\n                        &l_cp->tcps[p_j2k->m_current_tile_number] :\n                        p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n        l_ref_tccp = &l_tcp->tccps[0];\n        l_copied_tccp = l_ref_tccp + 1;\n        l_size = OPJ_J2K_MAXBANDS * sizeof(opj_stepsize_t);\n\n        for     (i=1;i<p_j2k->m_private_image->numcomps;++i) {\n                l_copied_tccp->qntsty = l_ref_tccp->qntsty;\n                l_copied_tccp->numgbits = l_ref_tccp->numgbits;\n                memcpy(l_copied_tccp->stepsizes,l_ref_tccp->stepsizes,l_size);\n                ++l_copied_tccp;\n        }\n}\n\nstatic void opj_j2k_dump_tile_info( opj_tcp_t * l_default_tile,OPJ_INT32 numcomps,FILE* out_stream)\n{\n        if (l_default_tile)\n        {\n                OPJ_INT32 compno;\n\n                fprintf(out_stream, \"\\t default tile {\\n\");\n                fprintf(out_stream, \"\\t\\t csty=%#x\\n\", l_default_tile->csty);\n                fprintf(out_stream, \"\\t\\t prg=%#x\\n\", l_default_tile->prg);\n                fprintf(out_stream, \"\\t\\t numlayers=%d\\n\", l_default_tile->numlayers);\n                fprintf(out_stream, \"\\t\\t mct=%x\\n\", l_default_tile->mct);\n\n                for (compno = 0; compno < numcomps; compno++) {\n                        opj_tccp_t *l_tccp = &(l_default_tile->tccps[compno]);\n                        OPJ_UINT32 resno;\n      OPJ_INT32 bandno, numbands;\n\n                        /* coding style*/\n                        fprintf(out_stream, \"\\t\\t comp %d {\\n\", compno);\n                        fprintf(out_stream, \"\\t\\t\\t csty=%#x\\n\", l_tccp->csty);\n                        fprintf(out_stream, \"\\t\\t\\t numresolutions=%d\\n\", l_tccp->numresolutions);\n                        fprintf(out_stream, \"\\t\\t\\t cblkw=2^%d\\n\", l_tccp->cblkw);\n                        fprintf(out_stream, \"\\t\\t\\t cblkh=2^%d\\n\", l_tccp->cblkh);\n                        fprintf(out_stream, \"\\t\\t\\t cblksty=%#x\\n\", l_tccp->cblksty);\n                        fprintf(out_stream, \"\\t\\t\\t qmfbid=%d\\n\", l_tccp->qmfbid);\n\n                        fprintf(out_stream, \"\\t\\t\\t preccintsize (w,h)=\");\n                        for (resno = 0; resno < l_tccp->numresolutions; resno++) {\n                                fprintf(out_stream, \"(%d,%d) \", l_tccp->prcw[resno], l_tccp->prch[resno]);\n                        }\n                        fprintf(out_stream, \"\\n\");\n\n                        /* quantization style*/\n                        fprintf(out_stream, \"\\t\\t\\t qntsty=%d\\n\", l_tccp->qntsty);\n                        fprintf(out_stream, \"\\t\\t\\t numgbits=%d\\n\", l_tccp->numgbits);\n                        fprintf(out_stream, \"\\t\\t\\t stepsizes (m,e)=\");\n                        numbands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 : (OPJ_INT32)l_tccp->numresolutions * 3 - 2;\n                        for (bandno = 0; bandno < numbands; bandno++) {\n                                fprintf(out_stream, \"(%d,%d) \", l_tccp->stepsizes[bandno].mant,\n                                        l_tccp->stepsizes[bandno].expn);\n                        }\n                        fprintf(out_stream, \"\\n\");\n\n                        /* RGN value*/\n                        fprintf(out_stream, \"\\t\\t\\t roishift=%d\\n\", l_tccp->roishift);\n\n                        fprintf(out_stream, \"\\t\\t }\\n\");\n                } /*end of component of default tile*/\n                fprintf(out_stream, \"\\t }\\n\"); /*end of default tile*/\n            }\n}\n\nvoid j2k_dump (opj_j2k_t* p_j2k, OPJ_INT32 flag, FILE* out_stream)\n{\n        /* Check if the flag is compatible with j2k file*/\n        if ( (flag & OPJ_JP2_INFO) || (flag & OPJ_JP2_IND)){\n                fprintf(out_stream, \"Wrong flag\\n\");\n                return;\n        }\n\n        /* Dump the image_header */\n        if (flag & OPJ_IMG_INFO){\n                if (p_j2k->m_private_image)\n                        j2k_dump_image_header(p_j2k->m_private_image, 0, out_stream);\n        }\n\n        /* Dump the codestream info from main header */\n        if (flag & OPJ_J2K_MH_INFO){\n                if (p_j2k->m_private_image)\n                        opj_j2k_dump_MH_info(p_j2k, out_stream);\n        }\n        /* Dump all tile/codestream info */\n        if (flag & OPJ_J2K_TCH_INFO){\n          OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n          OPJ_UINT32 i;\n          opj_tcp_t * l_tcp = p_j2k->m_cp.tcps;\n          if (p_j2k->m_private_image) {\n            for (i=0;i<l_nb_tiles;++i) {\n              opj_j2k_dump_tile_info( l_tcp,(OPJ_INT32)p_j2k->m_private_image->numcomps, out_stream);\n              ++l_tcp;\n            }\n          }\n        }\n\n        /* Dump the codestream info of the current tile */\n        if (flag & OPJ_J2K_TH_INFO){\n\n        }\n\n        /* Dump the codestream index from main header */\n        if (flag & OPJ_J2K_MH_IND){\n                opj_j2k_dump_MH_index(p_j2k, out_stream);\n        }\n\n        /* Dump the codestream index of the current tile */\n        if (flag & OPJ_J2K_TH_IND){\n\n        }\n\n}\n\nstatic void opj_j2k_dump_MH_index(opj_j2k_t* p_j2k, FILE* out_stream)\n{\n        opj_codestream_index_t* cstr_index = p_j2k->cstr_index;\n        OPJ_UINT32 it_marker, it_tile, it_tile_part;\n\n        fprintf(out_stream, \"Codestream index from main header: {\\n\");\n\n        fprintf(out_stream, \"\\t Main header start position=%\" PRIi64 \"\\n\"\n                                    \"\\t Main header end position=%\" PRIi64 \"\\n\",\n                        cstr_index->main_head_start, cstr_index->main_head_end);\n\n        fprintf(out_stream, \"\\t Marker list: {\\n\");\n\n        if (cstr_index->marker){\n                for (it_marker=0; it_marker < cstr_index->marknum ; it_marker++){\n                        fprintf(out_stream, \"\\t\\t type=%#x, pos=%\" PRIi64 \", len=%d\\n\",\n                                        cstr_index->marker[it_marker].type,\n                                        cstr_index->marker[it_marker].pos,\n                                        cstr_index->marker[it_marker].len );\n                }\n        }\n\n        fprintf(out_stream, \"\\t }\\n\");\n\n        if (cstr_index->tile_index){\n\n        /* Simple test to avoid to write empty information*/\n        OPJ_UINT32 l_acc_nb_of_tile_part = 0;\n        for (it_tile=0; it_tile < cstr_index->nb_of_tiles ; it_tile++){\n                        l_acc_nb_of_tile_part += cstr_index->tile_index[it_tile].nb_tps;\n        }\n\n        if (l_acc_nb_of_tile_part)\n        {\n            fprintf(out_stream, \"\\t Tile index: {\\n\");\n\n                    for (it_tile=0; it_tile < cstr_index->nb_of_tiles ; it_tile++){\n                            OPJ_UINT32 nb_of_tile_part = cstr_index->tile_index[it_tile].nb_tps;\n\n                            fprintf(out_stream, \"\\t\\t nb of tile-part in tile [%d]=%d\\n\", it_tile, nb_of_tile_part);\n\n                            if (cstr_index->tile_index[it_tile].tp_index){\n                                    for (it_tile_part =0; it_tile_part < nb_of_tile_part; it_tile_part++){\n                                            fprintf(out_stream, \"\\t\\t\\t tile-part[%d]: star_pos=%\" PRIi64 \", end_header=%\" PRIi64 \", end_pos=%\" PRIi64 \".\\n\",\n                                                            it_tile_part,\n                                                            cstr_index->tile_index[it_tile].tp_index[it_tile_part].start_pos,\n                                                            cstr_index->tile_index[it_tile].tp_index[it_tile_part].end_header,\n                                                            cstr_index->tile_index[it_tile].tp_index[it_tile_part].end_pos);\n                                    }\n                            }\n\n                            if (cstr_index->tile_index[it_tile].marker){\n                                    for (it_marker=0; it_marker < cstr_index->tile_index[it_tile].marknum ; it_marker++){\n                                            fprintf(out_stream, \"\\t\\t type=%#x, pos=%\" PRIi64 \", len=%d\\n\",\n                                                            cstr_index->tile_index[it_tile].marker[it_marker].type,\n                                                            cstr_index->tile_index[it_tile].marker[it_marker].pos,\n                                                            cstr_index->tile_index[it_tile].marker[it_marker].len );\n                                    }\n                            }\n                    }\n                    fprintf(out_stream,\"\\t }\\n\");\n        }\n        }\n\n        fprintf(out_stream,\"}\\n\");\n\n}\n\n\nstatic void opj_j2k_dump_MH_info(opj_j2k_t* p_j2k, FILE* out_stream)\n{\n\n        fprintf(out_stream, \"Codestream info from main header: {\\n\");\n\n        fprintf(out_stream, \"\\t tx0=%d, ty0=%d\\n\", p_j2k->m_cp.tx0, p_j2k->m_cp.ty0);\n        fprintf(out_stream, \"\\t tdx=%d, tdy=%d\\n\", p_j2k->m_cp.tdx, p_j2k->m_cp.tdy);\n        fprintf(out_stream, \"\\t tw=%d, th=%d\\n\", p_j2k->m_cp.tw, p_j2k->m_cp.th);\n        opj_j2k_dump_tile_info(p_j2k->m_specific_param.m_decoder.m_default_tcp,(OPJ_INT32)p_j2k->m_private_image->numcomps, out_stream);\n        fprintf(out_stream, \"}\\n\");\n}\n\nvoid j2k_dump_image_header(opj_image_t* img_header, OPJ_BOOL dev_dump_flag, FILE* out_stream)\n{\n        char tab[2];\n\n        if (dev_dump_flag){\n                fprintf(stdout, \"[DEV] Dump an image_header struct {\\n\");\n                tab[0] = '\\0';\n        }\n        else {\n                fprintf(out_stream, \"Image info {\\n\");\n                tab[0] = '\\t';tab[1] = '\\0';\n        }\n\n        fprintf(out_stream, \"%s x0=%d, y0=%d\\n\", tab, img_header->x0, img_header->y0);\n        fprintf(out_stream,     \"%s x1=%d, y1=%d\\n\", tab, img_header->x1, img_header->y1);\n        fprintf(out_stream, \"%s numcomps=%d\\n\", tab, img_header->numcomps);\n\n        if (img_header->comps){\n                OPJ_UINT32 compno;\n                for (compno = 0; compno < img_header->numcomps; compno++) {\n                        fprintf(out_stream, \"%s\\t component %d {\\n\", tab, compno);\n                        j2k_dump_image_comp_header(&(img_header->comps[compno]), dev_dump_flag, out_stream);\n                        fprintf(out_stream,\"%s}\\n\",tab);\n                }\n        }\n\n        fprintf(out_stream, \"}\\n\");\n}\n\nvoid j2k_dump_image_comp_header(opj_image_comp_t* comp_header, OPJ_BOOL dev_dump_flag, FILE* out_stream)\n{\n        char tab[3];\n\n        if (dev_dump_flag){\n                fprintf(stdout, \"[DEV] Dump an image_comp_header struct {\\n\");\n                tab[0] = '\\0';\n        }       else {\n                tab[0] = '\\t';tab[1] = '\\t';tab[2] = '\\0';\n        }\n\n        fprintf(out_stream, \"%s dx=%d, dy=%d\\n\", tab, comp_header->dx, comp_header->dy);\n        fprintf(out_stream, \"%s prec=%d\\n\", tab, comp_header->prec);\n        fprintf(out_stream, \"%s sgnd=%d\\n\", tab, comp_header->sgnd);\n\n        if (dev_dump_flag)\n                fprintf(out_stream, \"}\\n\");\n}\n\nopj_codestream_info_v2_t* j2k_get_cstr_info(opj_j2k_t* p_j2k)\n{\n        OPJ_UINT32 compno;\n        OPJ_UINT32 numcomps = p_j2k->m_private_image->numcomps;\n        opj_tcp_t *l_default_tile;\n        opj_codestream_info_v2_t* cstr_info = (opj_codestream_info_v2_t*) opj_calloc(1,sizeof(opj_codestream_info_v2_t));\n\t\tif (!cstr_info)\n\t\t\treturn NULL;\n\n        cstr_info->nbcomps = p_j2k->m_private_image->numcomps;\n\n        cstr_info->tx0 = p_j2k->m_cp.tx0;\n        cstr_info->ty0 = p_j2k->m_cp.ty0;\n        cstr_info->tdx = p_j2k->m_cp.tdx;\n        cstr_info->tdy = p_j2k->m_cp.tdy;\n        cstr_info->tw = p_j2k->m_cp.tw;\n        cstr_info->th = p_j2k->m_cp.th;\n\n        cstr_info->tile_info = NULL; /* Not fill from the main header*/\n\n        l_default_tile = p_j2k->m_specific_param.m_decoder.m_default_tcp;\n\n        cstr_info->m_default_tile_info.csty = l_default_tile->csty;\n        cstr_info->m_default_tile_info.prg = l_default_tile->prg;\n        cstr_info->m_default_tile_info.numlayers = l_default_tile->numlayers;\n        cstr_info->m_default_tile_info.mct = l_default_tile->mct;\n\n        cstr_info->m_default_tile_info.tccp_info = (opj_tccp_info_t*) opj_calloc(cstr_info->nbcomps, sizeof(opj_tccp_info_t));\n\t\tif (!cstr_info->m_default_tile_info.tccp_info)\n\t\t{\n\t\t\topj_destroy_cstr_info(&cstr_info);\n\t\t\treturn NULL;\n\t\t}\n\n        for (compno = 0; compno < numcomps; compno++) {\n                opj_tccp_t *l_tccp = &(l_default_tile->tccps[compno]);\n                opj_tccp_info_t *l_tccp_info = &(cstr_info->m_default_tile_info.tccp_info[compno]);\n                OPJ_INT32 bandno, numbands;\n\n                /* coding style*/\n                l_tccp_info->csty = l_tccp->csty;\n                l_tccp_info->numresolutions = l_tccp->numresolutions;\n                l_tccp_info->cblkw = l_tccp->cblkw;\n                l_tccp_info->cblkh = l_tccp->cblkh;\n                l_tccp_info->cblksty = l_tccp->cblksty;\n                l_tccp_info->qmfbid = l_tccp->qmfbid;\n                if (l_tccp->numresolutions < OPJ_J2K_MAXRLVLS)\n                {\n                        memcpy(l_tccp_info->prch, l_tccp->prch, l_tccp->numresolutions);\n                        memcpy(l_tccp_info->prcw, l_tccp->prcw, l_tccp->numresolutions);\n                }\n\n                /* quantization style*/\n                l_tccp_info->qntsty = l_tccp->qntsty;\n                l_tccp_info->numgbits = l_tccp->numgbits;\n\n                numbands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 : (OPJ_INT32)l_tccp->numresolutions * 3 - 2;\n                if (numbands < OPJ_J2K_MAXBANDS) {\n                        for (bandno = 0; bandno < numbands; bandno++) {\n                                l_tccp_info->stepsizes_mant[bandno] = (OPJ_UINT32)l_tccp->stepsizes[bandno].mant;\n                                l_tccp_info->stepsizes_expn[bandno] = (OPJ_UINT32)l_tccp->stepsizes[bandno].expn;\n                        }\n                }\n\n                /* RGN value*/\n                l_tccp_info->roishift = l_tccp->roishift;\n        }\n\n        return cstr_info;\n}\n\nopj_codestream_index_t* j2k_get_cstr_index(opj_j2k_t* p_j2k)\n{\n        opj_codestream_index_t* l_cstr_index = (opj_codestream_index_t*)\n                        opj_calloc(1,sizeof(opj_codestream_index_t));\n        if (!l_cstr_index)\n                return NULL;\n\n        l_cstr_index->main_head_start = p_j2k->cstr_index->main_head_start;\n        l_cstr_index->main_head_end = p_j2k->cstr_index->main_head_end;\n        l_cstr_index->codestream_size = p_j2k->cstr_index->codestream_size;\n\n        l_cstr_index->marknum = p_j2k->cstr_index->marknum;\n        l_cstr_index->marker = (opj_marker_info_t*)opj_malloc(l_cstr_index->marknum*sizeof(opj_marker_info_t));\n        if (!l_cstr_index->marker){\n                opj_free( l_cstr_index);\n                return NULL;\n        }\n\n        if (p_j2k->cstr_index->marker)\n                memcpy(l_cstr_index->marker, p_j2k->cstr_index->marker, l_cstr_index->marknum * sizeof(opj_marker_info_t) );\n        else{\n                opj_free(l_cstr_index->marker);\n                l_cstr_index->marker = NULL;\n        }\n\n        l_cstr_index->nb_of_tiles = p_j2k->cstr_index->nb_of_tiles;\n        l_cstr_index->tile_index = (opj_tile_index_t*)opj_calloc(l_cstr_index->nb_of_tiles, sizeof(opj_tile_index_t) );\n        if (!l_cstr_index->tile_index){\n                opj_free( l_cstr_index->marker);\n                opj_free( l_cstr_index);\n                return NULL;\n        }\n\n        if (!p_j2k->cstr_index->tile_index){\n                opj_free(l_cstr_index->tile_index);\n                l_cstr_index->tile_index = NULL;\n        }\n        else {\n                OPJ_UINT32 it_tile = 0;\n                for (it_tile = 0; it_tile < l_cstr_index->nb_of_tiles; it_tile++ ){\n\n                        /* Tile Marker*/\n                        l_cstr_index->tile_index[it_tile].marknum = p_j2k->cstr_index->tile_index[it_tile].marknum;\n\n                        l_cstr_index->tile_index[it_tile].marker =\n                                (opj_marker_info_t*)opj_malloc(l_cstr_index->tile_index[it_tile].marknum*sizeof(opj_marker_info_t));\n\n                        if (!l_cstr_index->tile_index[it_tile].marker) {\n                                OPJ_UINT32 it_tile_free;\n\n                                for (it_tile_free=0; it_tile_free < it_tile; it_tile_free++){\n                                        opj_free(l_cstr_index->tile_index[it_tile_free].marker);\n                                }\n\n                                opj_free( l_cstr_index->tile_index);\n                                opj_free( l_cstr_index->marker);\n                                opj_free( l_cstr_index);\n                                return NULL;\n                        }\n\n                        if (p_j2k->cstr_index->tile_index[it_tile].marker)\n                                memcpy( l_cstr_index->tile_index[it_tile].marker,\n                                                p_j2k->cstr_index->tile_index[it_tile].marker,\n                                                l_cstr_index->tile_index[it_tile].marknum * sizeof(opj_marker_info_t) );\n                        else{\n                                opj_free(l_cstr_index->tile_index[it_tile].marker);\n                                l_cstr_index->tile_index[it_tile].marker = NULL;\n                        }\n\n                        /* Tile part index*/\n                        l_cstr_index->tile_index[it_tile].nb_tps = p_j2k->cstr_index->tile_index[it_tile].nb_tps;\n\n                        l_cstr_index->tile_index[it_tile].tp_index =\n                                (opj_tp_index_t*)opj_malloc(l_cstr_index->tile_index[it_tile].nb_tps*sizeof(opj_tp_index_t));\n\n                        if(!l_cstr_index->tile_index[it_tile].tp_index){\n                                OPJ_UINT32 it_tile_free;\n\n                                for (it_tile_free=0; it_tile_free < it_tile; it_tile_free++){\n                                        opj_free(l_cstr_index->tile_index[it_tile_free].marker);\n                                        opj_free(l_cstr_index->tile_index[it_tile_free].tp_index);\n                                }\n\n                                opj_free( l_cstr_index->tile_index);\n                                opj_free( l_cstr_index->marker);\n                                opj_free( l_cstr_index);\n                                return NULL;\n                        }\n\n                        if (p_j2k->cstr_index->tile_index[it_tile].tp_index){\n                                memcpy( l_cstr_index->tile_index[it_tile].tp_index,\n                                                p_j2k->cstr_index->tile_index[it_tile].tp_index,\n                                                l_cstr_index->tile_index[it_tile].nb_tps * sizeof(opj_tp_index_t) );\n                        }\n                        else{\n                                opj_free(l_cstr_index->tile_index[it_tile].tp_index);\n                                l_cstr_index->tile_index[it_tile].tp_index = NULL;\n                        }\n\n                        /* Packet index (NOT USED)*/\n                        l_cstr_index->tile_index[it_tile].nb_packet = 0;\n                        l_cstr_index->tile_index[it_tile].packet_index = NULL;\n\n                }\n        }\n\n        return l_cstr_index;\n}\n\nstatic OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k)\n{\n        OPJ_UINT32 it_tile=0;\n\n        p_j2k->cstr_index->nb_of_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;\n        p_j2k->cstr_index->tile_index = (opj_tile_index_t*)opj_calloc(p_j2k->cstr_index->nb_of_tiles, sizeof(opj_tile_index_t));\n        if (!p_j2k->cstr_index->tile_index)\n                return OPJ_FALSE;\n\n        for (it_tile=0; it_tile < p_j2k->cstr_index->nb_of_tiles; it_tile++){\n                p_j2k->cstr_index->tile_index[it_tile].maxmarknum = 100;\n                p_j2k->cstr_index->tile_index[it_tile].marknum = 0;\n                p_j2k->cstr_index->tile_index[it_tile].marker = (opj_marker_info_t*)\n                                opj_calloc(p_j2k->cstr_index->tile_index[it_tile].maxmarknum, sizeof(opj_marker_info_t));\n                if (!p_j2k->cstr_index->tile_index[it_tile].marker)\n                        return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_decode_tiles ( opj_j2k_t *p_j2k,\n                                                            opj_stream_private_t *p_stream,\n                                                            opj_event_mgr_t * p_manager)\n{\n        OPJ_BOOL l_go_on = OPJ_TRUE;\n        OPJ_UINT32 l_current_tile_no;\n        OPJ_UINT32 l_data_size,l_max_data_size;\n        OPJ_INT32 l_tile_x0,l_tile_y0,l_tile_x1,l_tile_y1;\n        OPJ_UINT32 l_nb_comps;\n        OPJ_BYTE * l_current_data;\n        OPJ_UINT32 nr_tiles = 0;\n\n        l_current_data = (OPJ_BYTE*)opj_malloc(1000);\n        if (! l_current_data) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to decode tiles\\n\");\n                return OPJ_FALSE;\n        }\n        l_max_data_size = 1000;\n\n\t\tfor (;;) {\n                if (! opj_j2k_read_tile_header( p_j2k,\n                                        &l_current_tile_no,\n                                        &l_data_size,\n                                        &l_tile_x0, &l_tile_y0,\n                                        &l_tile_x1, &l_tile_y1,\n                                        &l_nb_comps,\n                                        &l_go_on,\n                                        p_stream,\n                                        p_manager)) {\n                        opj_free(l_current_data);\n                        return OPJ_FALSE;\n                }\n\n                if (! l_go_on) {\n                        break;\n                }\n\n                if (l_data_size > l_max_data_size) {\n                        OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(l_current_data, l_data_size);\n                        if (! l_new_current_data) {\n                                opj_free(l_current_data);\n                                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to decode tile %d/%d\\n\", l_current_tile_no +1, p_j2k->m_cp.th * p_j2k->m_cp.tw);\n                                return OPJ_FALSE;\n                        }\n                        l_current_data = l_new_current_data;\n                        l_max_data_size = l_data_size;\n                }\n\n                if (! opj_j2k_decode_tile(p_j2k,l_current_tile_no,l_current_data,l_data_size,p_stream,p_manager)) {\n                        opj_free(l_current_data);\n                        opj_event_msg(p_manager, EVT_ERROR, \"Failed to decode tile %d/%d\\n\", l_current_tile_no +1, p_j2k->m_cp.th * p_j2k->m_cp.tw);\n                        return OPJ_FALSE;\n                }\n                opj_event_msg(p_manager, EVT_INFO, \"Tile %d/%d has been decoded.\\n\", l_current_tile_no +1, p_j2k->m_cp.th * p_j2k->m_cp.tw);\n\n                if (! opj_j2k_update_image_data(p_j2k->m_tcd,l_current_data, p_j2k->m_output_image)) {\n                        opj_free(l_current_data);\n                        return OPJ_FALSE;\n                }\n                opj_event_msg(p_manager, EVT_INFO, \"Image data has been updated with tile %d.\\n\\n\", l_current_tile_no + 1);\n                \n                if(opj_stream_get_number_byte_left(p_stream) == 0  \n                    && p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NEOC)\n                    break;\n                if(++nr_tiles ==  p_j2k->m_cp.th * p_j2k->m_cp.tw) \n                    break;\n        }\n\n        opj_free(l_current_data);\n\n        return OPJ_TRUE;\n}\n\n/**\n * Sets up the procedures to do on decoding data. Developpers wanting to extend the library can add their own reading procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_decoding (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager)\n{\n        /* preconditions*/\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_decode_tiles, p_manager)) {\n                return OPJ_FALSE;\n        }\n        /* DEVELOPER CORNER, add your custom procedures */\n\n        return OPJ_TRUE;\n}\n\n/*\n * Read and decode one tile.\n */\nstatic OPJ_BOOL opj_j2k_decode_one_tile (       opj_j2k_t *p_j2k,\n                                                                            opj_stream_private_t *p_stream,\n                                                                            opj_event_mgr_t * p_manager)\n{\n        OPJ_BOOL l_go_on = OPJ_TRUE;\n        OPJ_UINT32 l_current_tile_no;\n        OPJ_UINT32 l_tile_no_to_dec;\n        OPJ_UINT32 l_data_size,l_max_data_size;\n        OPJ_INT32 l_tile_x0,l_tile_y0,l_tile_x1,l_tile_y1;\n        OPJ_UINT32 l_nb_comps;\n        OPJ_BYTE * l_current_data;\n\n        l_current_data = (OPJ_BYTE*)opj_malloc(1000);\n        if (! l_current_data) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to decode one tile\\n\");\n                return OPJ_FALSE;\n        }\n        l_max_data_size = 1000;\n\n        /*Allocate and initialize some elements of codestrem index if not already done*/\n        if( !p_j2k->cstr_index->tile_index)\n        {\n                if (!opj_j2k_allocate_tile_element_cstr_index(p_j2k)){\n                        opj_free(l_current_data);\n                        return OPJ_FALSE;\n                }\n        }\n        /* Move into the codestream to the first SOT used to decode the desired tile */\n        l_tile_no_to_dec = (OPJ_UINT32)p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec;\n        if (p_j2k->cstr_index->tile_index)\n                if(p_j2k->cstr_index->tile_index->tp_index)\n                {\n                        if ( ! p_j2k->cstr_index->tile_index[l_tile_no_to_dec].nb_tps) {\n                                /* the index for this tile has not been built,\n                                 *  so move to the last SOT read */\n                                if ( !(opj_stream_read_seek(p_stream, p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos+2, p_manager)) ){\n                                        opj_event_msg(p_manager, EVT_ERROR, \"Problem with seek function\\n\");\n                                        opj_free(l_current_data);\n                                        return OPJ_FALSE;\n                                }\n                        }\n                        else{\n                                if ( !(opj_stream_read_seek(p_stream, p_j2k->cstr_index->tile_index[l_tile_no_to_dec].tp_index[0].start_pos+2, p_manager)) ) {\n                                        opj_event_msg(p_manager, EVT_ERROR, \"Problem with seek function\\n\");\n                                        opj_free(l_current_data);\n                                        return OPJ_FALSE;\n                                }\n                        }\n                        /* Special case if we have previously read the EOC marker (if the previous tile getted is the last ) */\n                        if(p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_EOC)\n                                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;\n                }\n\n\t\tfor (;;) {\n                if (! opj_j2k_read_tile_header( p_j2k,\n                                        &l_current_tile_no,\n                                        &l_data_size,\n                                        &l_tile_x0, &l_tile_y0,\n                                        &l_tile_x1, &l_tile_y1,\n                                        &l_nb_comps,\n                                        &l_go_on,\n                                        p_stream,\n                                        p_manager)) {\n                        opj_free(l_current_data);\n                        return OPJ_FALSE;\n                }\n\n                if (! l_go_on) {\n                        break;\n                }\n\n                if (l_data_size > l_max_data_size) {\n                        OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(l_current_data, l_data_size);\n                        if (! l_new_current_data) {\n                                opj_free(l_current_data);\n                                l_current_data = NULL;\n                                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to decode tile %d/%d\\n\", l_current_tile_no+1, p_j2k->m_cp.th * p_j2k->m_cp.tw);\n                                return OPJ_FALSE;\n                        }\n                        l_current_data = l_new_current_data;\n                        l_max_data_size = l_data_size;\n                }\n\n                if (! opj_j2k_decode_tile(p_j2k,l_current_tile_no,l_current_data,l_data_size,p_stream,p_manager)) {\n                        opj_free(l_current_data);\n                        return OPJ_FALSE;\n                }\n                opj_event_msg(p_manager, EVT_INFO, \"Tile %d/%d has been decoded.\\n\", l_current_tile_no+1, p_j2k->m_cp.th * p_j2k->m_cp.tw);\n\n                if (! opj_j2k_update_image_data(p_j2k->m_tcd,l_current_data, p_j2k->m_output_image)) {\n                        opj_free(l_current_data);\n                        return OPJ_FALSE;\n                }\n                opj_event_msg(p_manager, EVT_INFO, \"Image data has been updated with tile %d.\\n\\n\", l_current_tile_no+1);\n\n                if(l_current_tile_no == l_tile_no_to_dec)\n                {\n                        /* move into the codestream to the first SOT (FIXME or not move?)*/\n                        if (!(opj_stream_read_seek(p_stream, p_j2k->cstr_index->main_head_end + 2, p_manager) ) ) {\n                                opj_event_msg(p_manager, EVT_ERROR, \"Problem with seek function\\n\");\n                                opj_free(l_current_data);\n                                return OPJ_FALSE;\n                        }\n                        break;\n                }\n                else {\n                        opj_event_msg(p_manager, EVT_WARNING, \"Tile read, decoded and updated is not the desired one (%d vs %d).\\n\", l_current_tile_no+1, l_tile_no_to_dec+1);\n                }\n\n        }\n\n        opj_free(l_current_data);\n\n        return OPJ_TRUE;\n}\n\n/**\n * Sets up the procedures to do on decoding one tile. Developpers wanting to extend the library can add their own reading procedures.\n */\nstatic OPJ_BOOL opj_j2k_setup_decoding_tile (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager)\n{\n        /* preconditions*/\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_decode_one_tile, p_manager)) {\n                return OPJ_FALSE;\n        }\n        /* DEVELOPER CORNER, add your custom procedures */\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_decode(opj_j2k_t * p_j2k,\n                                                opj_stream_private_t * p_stream,\n                                                opj_image_t * p_image,\n                                                opj_event_mgr_t * p_manager)\n{\n        OPJ_UINT32 compno;\n\n        if (!p_image)\n                return OPJ_FALSE;\n\t\n        p_j2k->m_output_image = opj_image_create0();\n        if (! (p_j2k->m_output_image)) {\n                return OPJ_FALSE;\n        }\n        opj_copy_image_header(p_image, p_j2k->m_output_image);\n\n        /* customization of the decoding */\n        opj_j2k_setup_decoding(p_j2k, p_manager);\n\n        /* Decode the codestream */\n        if (! opj_j2k_exec (p_j2k,p_j2k->m_procedure_list,p_stream,p_manager)) {\n                opj_image_destroy(p_j2k->m_private_image);\n                p_j2k->m_private_image = NULL;\n                return OPJ_FALSE;\n        }\n\n        /* Move data and copy one information from codec to output image*/\n        for (compno = 0; compno < p_image->numcomps; compno++) {\n                p_image->comps[compno].resno_decoded = p_j2k->m_output_image->comps[compno].resno_decoded;\n\t\tp_image->comps[compno].data = p_j2k->m_output_image->comps[compno].data;\n\n\t\tif(p_image->comps[compno].data == NULL) return OPJ_FALSE;\n\n                p_j2k->m_output_image->comps[compno].data = NULL;\n#if 0\n                char fn[256];\n                sprintf( fn, \"/tmp/%d.raw\", compno );\n                FILE *debug = fopen( fn, \"wb\" );\n                fwrite( p_image->comps[compno].data, sizeof(OPJ_INT32), p_image->comps[compno].w * p_image->comps[compno].h, debug );\n                fclose( debug );\n#endif\n        }\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_get_tile(      opj_j2k_t *p_j2k,\n                                                    opj_stream_private_t *p_stream,\n                                                    opj_image_t* p_image,\n                                                    opj_event_mgr_t * p_manager,\n                                                    OPJ_UINT32 tile_index )\n{\n        OPJ_UINT32 compno;\n        OPJ_UINT32 l_tile_x, l_tile_y;\n        opj_image_comp_t* l_img_comp;\n\n        if (!p_image) {\n                opj_event_msg(p_manager, EVT_ERROR, \"We need an image previously created.\\n\");\n                return OPJ_FALSE;\n        }\n\n        if ( /*(tile_index < 0) &&*/ (tile_index >= p_j2k->m_cp.tw * p_j2k->m_cp.th) ){\n                opj_event_msg(p_manager, EVT_ERROR, \"Tile index provided by the user is incorrect %d (max = %d) \\n\", tile_index, (p_j2k->m_cp.tw * p_j2k->m_cp.th) - 1);\n                return OPJ_FALSE;\n        }\n\n        /* Compute the dimension of the desired tile*/\n        l_tile_x = tile_index % p_j2k->m_cp.tw;\n        l_tile_y = tile_index / p_j2k->m_cp.tw;\n\n        p_image->x0 = l_tile_x * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;\n        if (p_image->x0 < p_j2k->m_private_image->x0)\n                p_image->x0 = p_j2k->m_private_image->x0;\n        p_image->x1 = (l_tile_x + 1) * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;\n        if (p_image->x1 > p_j2k->m_private_image->x1)\n                p_image->x1 = p_j2k->m_private_image->x1;\n\n        p_image->y0 = l_tile_y * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;\n        if (p_image->y0 < p_j2k->m_private_image->y0)\n                p_image->y0 = p_j2k->m_private_image->y0;\n        p_image->y1 = (l_tile_y + 1) * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;\n        if (p_image->y1 > p_j2k->m_private_image->y1)\n                p_image->y1 = p_j2k->m_private_image->y1;\n\n        l_img_comp = p_image->comps;\n        for (compno=0; compno < p_image->numcomps; ++compno)\n        {\n                OPJ_INT32 l_comp_x1, l_comp_y1;\n\n                l_img_comp->factor = p_j2k->m_private_image->comps[compno].factor;\n\n                l_img_comp->x0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->x0, (OPJ_INT32)l_img_comp->dx);\n                l_img_comp->y0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->y0, (OPJ_INT32)l_img_comp->dy);\n                l_comp_x1 = opj_int_ceildiv((OPJ_INT32)p_image->x1, (OPJ_INT32)l_img_comp->dx);\n                l_comp_y1 = opj_int_ceildiv((OPJ_INT32)p_image->y1, (OPJ_INT32)l_img_comp->dy);\n\n                l_img_comp->w = (OPJ_UINT32)(opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32)l_img_comp->factor) - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->x0, (OPJ_INT32)l_img_comp->factor));\n                l_img_comp->h = (OPJ_UINT32)(opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32)l_img_comp->factor) - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->y0, (OPJ_INT32)l_img_comp->factor));\n\n                l_img_comp++;\n        }\n\n        /* Destroy the previous output image*/\n        if (p_j2k->m_output_image)\n                opj_image_destroy(p_j2k->m_output_image);\n\n        /* Create the ouput image from the information previously computed*/\n        p_j2k->m_output_image = opj_image_create0();\n        if (! (p_j2k->m_output_image)) {\n                return OPJ_FALSE;\n        }\n        opj_copy_image_header(p_image, p_j2k->m_output_image);\n\n        p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = (OPJ_INT32)tile_index;\n\n        /* customization of the decoding */\n        opj_j2k_setup_decoding_tile(p_j2k, p_manager);\n\n        /* Decode the codestream */\n        if (! opj_j2k_exec (p_j2k,p_j2k->m_procedure_list,p_stream,p_manager)) {\n                opj_image_destroy(p_j2k->m_private_image);\n                p_j2k->m_private_image = NULL;\n                return OPJ_FALSE;\n        }\n\n        /* Move data and copy one information from codec to output image*/\n        for (compno = 0; compno < p_image->numcomps; compno++) {\n                p_image->comps[compno].resno_decoded = p_j2k->m_output_image->comps[compno].resno_decoded;\n\n                if (p_image->comps[compno].data)\n                        opj_free(p_image->comps[compno].data);\n\n                p_image->comps[compno].data = p_j2k->m_output_image->comps[compno].data;\n\n\t\t\t\tif (p_image->comps[compno].data == NULL) return OPJ_FALSE;\n\n                p_j2k->m_output_image->comps[compno].data = NULL;\n        }\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_set_decoded_resolution_factor(opj_j2k_t *p_j2k,\n                                               OPJ_UINT32 res_factor,\n                                               opj_event_mgr_t * p_manager)\n{\n        OPJ_UINT32 it_comp;\n\n        p_j2k->m_cp.m_specific_param.m_dec.m_reduce = res_factor;\n\n        if (p_j2k->m_private_image) {\n                if (p_j2k->m_private_image->comps) {\n                        if (p_j2k->m_specific_param.m_decoder.m_default_tcp) {\n                                if (p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps) {\n                                        for (it_comp = 0 ; it_comp < p_j2k->m_private_image->numcomps; it_comp++) {\n                                                OPJ_UINT32 max_res = p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps[it_comp].numresolutions;\n                                                if ( res_factor >= max_res){\n                                                        opj_event_msg(p_manager, EVT_ERROR, \"Resolution factor is greater than the maximum resolution in the component.\\n\");\n                                                        return OPJ_FALSE;\n                                                }\n                                                p_j2k->m_private_image->comps[it_comp].factor = res_factor;\n                                        }\n                                        return OPJ_TRUE;\n                                }\n                        }\n                }\n        }\n\n        return OPJ_FALSE;\n}\n\nOPJ_BOOL opj_j2k_encode(opj_j2k_t * p_j2k,\n                        opj_stream_private_t *p_stream,\n                        opj_event_mgr_t * p_manager )\n{\n        OPJ_UINT32 i, j;\n        OPJ_UINT32 l_nb_tiles;\n        OPJ_UINT32 l_max_tile_size = 0, l_current_tile_size;\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_BOOL l_reuse_data = OPJ_FALSE;\n        opj_tcd_t* p_tcd = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n\t\n        p_tcd = p_j2k->m_tcd;\n\n        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n        if (l_nb_tiles == 1) {\n                l_reuse_data = OPJ_TRUE;\n#ifdef __SSE__\n                for (j=0;j<p_j2k->m_tcd->image->numcomps;++j) {\n                        opj_image_comp_t * l_img_comp = p_tcd->image->comps + j;\n                        if (((size_t)l_img_comp->data & 0xFU) != 0U) { /* tile data shall be aligned on 16 bytes */\n\t\t\t\t\t\t\t\t\t\t\t\t        l_reuse_data = OPJ_FALSE;\n                        }\n                }\n#endif\n        }\n        for (i=0;i<l_nb_tiles;++i) {\n                if (! opj_j2k_pre_write_tile(p_j2k,i,p_stream,p_manager)) {\n                        if (l_current_data) {\n                                opj_free(l_current_data);\n                        }\n                        return OPJ_FALSE;\n                }\n\n                /* if we only have one tile, then simply set tile component data equal to image component data */\n                /* otherwise, allocate the data */\n                for (j=0;j<p_j2k->m_tcd->image->numcomps;++j) {\n                        opj_tcd_tilecomp_t* l_tilec = p_tcd->tcd_image->tiles->comps + j;\n                        if (l_reuse_data) {\n\t\t\t\t\t\t\t\t\t\t\t\t        opj_image_comp_t * l_img_comp = p_tcd->image->comps + j;\n\t\t\t\t\t\t\t\t\t\t\t\t        l_tilec->data  =  l_img_comp->data;\n\t\t\t\t\t\t\t\t\t\t\t\t        l_tilec->ownsData = OPJ_FALSE;\n                        } else {\n\t\t\t\t\t\t\t\t\t\t\t\t        if(! opj_alloc_tile_component_data(l_tilec)) {\n\t\t\t\t\t\t\t\t\t\t\t\t                opj_event_msg(p_manager, EVT_ERROR, \"Error allocating tile component data.\" );\n\t\t\t\t\t\t\t\t\t\t\t\t                if (l_current_data) {\n\t\t\t\t\t\t\t\t\t\t\t\t                        opj_free(l_current_data);\n\t\t\t\t\t\t\t\t\t\t\t\t                }\n\t\t\t\t\t\t\t\t\t\t\t\t                return OPJ_FALSE;\n\t\t\t\t\t\t\t\t\t\t\t\t        }\n                        }\n                }\n                l_current_tile_size = opj_tcd_get_encoded_tile_size(p_j2k->m_tcd);\n                if (!l_reuse_data) {\n                        if (l_current_tile_size > l_max_tile_size) {\n\t\t\t\t\t\t\t\t\t\t\t\t        OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(l_current_data, l_current_tile_size);\n\t\t\t\t\t\t\t\t\t\t\t\t        if (! l_new_current_data) {\n\t\t\t\t\t\t\t\t\t\t\t\t                if (l_current_data) {\n\t\t\t\t\t\t\t\t\t\t\t\t                        opj_free(l_current_data);\n\t\t\t\t\t\t\t\t\t\t\t\t                }\n\t\t\t\t\t\t\t\t\t\t\t\t                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to encode all tiles\\n\");\n\t\t\t\t\t\t\t\t\t\t\t\t                return OPJ_FALSE;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_current_data = l_new_current_data;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tl_max_tile_size = l_current_tile_size;\n                        }\n\n                        /* copy image data (32 bit) to l_current_data as contiguous, all-component, zero offset buffer */\n                        /* 32 bit components @ 8 bit precision get converted to 8 bit */\n                        /* 32 bit components @ 16 bit precision get converted to 16 bit */\n                        opj_j2k_get_tile_data(p_j2k->m_tcd,l_current_data);\n\n                        /* now copy this data into the tile component */\n                        if (! opj_tcd_copy_tile_data(p_j2k->m_tcd,l_current_data,l_current_tile_size)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\topj_event_msg(p_manager, EVT_ERROR, \"Size mismatch between tile data and sent data.\" );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\topj_free(l_current_data);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn OPJ_FALSE;\n                        }\n                }\n\n                if (! opj_j2k_post_write_tile (p_j2k,p_stream,p_manager)) {\n                        if (l_current_data) {\n                                opj_free(l_current_data);\n                        }\n                        return OPJ_FALSE;\n                }\n        }\n\n        if (l_current_data) {\n                opj_free(l_current_data);\n        }\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_end_compress(  opj_j2k_t *p_j2k,\n                                                        opj_stream_private_t *p_stream,\n                                                        opj_event_mgr_t * p_manager)\n{\n        /* customization of the encoding */\n        if (! opj_j2k_setup_end_compress(p_j2k, p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        if (! opj_j2k_exec (p_j2k, p_j2k->m_procedure_list, p_stream, p_manager))\n        {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_start_compress(opj_j2k_t *p_j2k,\n                                                            opj_stream_private_t *p_stream,\n                                                            opj_image_t * p_image,\n                                                            opj_event_mgr_t * p_manager)\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n\n        p_j2k->m_private_image = opj_image_create0();\n        if (! p_j2k->m_private_image) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Failed to allocate image header.\" );\n                return OPJ_FALSE;\n        }\n        opj_copy_image_header(p_image, p_j2k->m_private_image);\n\n        /* TODO_MSD: Find a better way */\n        if (p_image->comps) {\n                OPJ_UINT32 it_comp;\n                for (it_comp = 0 ; it_comp < p_image->numcomps; it_comp++) {\n                        if (p_image->comps[it_comp].data) {\n                                p_j2k->m_private_image->comps[it_comp].data =p_image->comps[it_comp].data;\n                                p_image->comps[it_comp].data = NULL;\n\n                        }\n                }\n        }\n\n        /* customization of the validation */\n        if (! opj_j2k_setup_encoding_validation (p_j2k, p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        /* validation of the parameters codec */\n        if (! opj_j2k_exec(p_j2k,p_j2k->m_validation_list,p_stream,p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        /* customization of the encoding */\n        if (! opj_j2k_setup_header_writing(p_j2k, p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        /* write header */\n        if (! opj_j2k_exec (p_j2k,p_j2k->m_procedure_list,p_stream,p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_pre_write_tile (       opj_j2k_t * p_j2k,\n                                                                OPJ_UINT32 p_tile_index,\n                                                                opj_stream_private_t *p_stream,\n                                                                opj_event_mgr_t * p_manager )\n{\n  (void)p_stream;\n        if (p_tile_index != p_j2k->m_current_tile_number) {\n                opj_event_msg(p_manager, EVT_ERROR, \"The given tile index does not match.\" );\n                return OPJ_FALSE;\n        }\n\n        opj_event_msg(p_manager, EVT_INFO, \"tile number %d / %d\\n\", p_j2k->m_current_tile_number + 1, p_j2k->m_cp.tw * p_j2k->m_cp.th);\n\n        p_j2k->m_specific_param.m_encoder.m_current_tile_part_number = 0;\n        p_j2k->m_tcd->cur_totnum_tp = p_j2k->m_cp.tcps[p_tile_index].m_nb_tile_parts;\n        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = 0;\n\n        /* initialisation before tile encoding  */\n        if (! opj_tcd_init_encode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number, p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic void opj_get_tile_dimensions(opj_image_t * l_image,\n                             opj_tcd_tilecomp_t * l_tilec,\n                             opj_image_comp_t * l_img_comp,\n                             OPJ_UINT32* l_size_comp,\n                             OPJ_UINT32* l_width,\n                             OPJ_UINT32* l_height,\n                             OPJ_UINT32* l_offset_x,\n                             OPJ_UINT32* l_offset_y,\n                             OPJ_UINT32* l_image_width,\n                             OPJ_UINT32* l_stride,\n                             OPJ_UINT32* l_tile_offset) {\n\tOPJ_UINT32 l_remaining;\n\t*l_size_comp = l_img_comp->prec >> 3; /* (/8) */\n\tl_remaining = l_img_comp->prec & 7;  /* (%8) */\n\tif (l_remaining) {\n\t\t*l_size_comp += 1;\n\t}\n\n\tif (*l_size_comp == 3) {\n\t\t*l_size_comp = 4;\n\t}\n\n\t*l_width  = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0);\n\t*l_height = (OPJ_UINT32)(l_tilec->y1 - l_tilec->y0);\n\t*l_offset_x = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)l_image->x0, (OPJ_INT32)l_img_comp->dx);\n\t*l_offset_y = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)l_image->y0, (OPJ_INT32)l_img_comp->dy);\n\t*l_image_width = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)l_image->x1 - (OPJ_INT32)l_image->x0, (OPJ_INT32)l_img_comp->dx);\n\t*l_stride = *l_image_width - *l_width;\n\t*l_tile_offset = ((OPJ_UINT32)l_tilec->x0 - *l_offset_x) + ((OPJ_UINT32)l_tilec->y0 - *l_offset_y) * *l_image_width;\n}\n\nstatic void opj_j2k_get_tile_data (opj_tcd_t * p_tcd, OPJ_BYTE * p_data)\n{\n        OPJ_UINT32 i,j,k = 0;\n\n        for (i=0;i<p_tcd->image->numcomps;++i) {\n                opj_image_t * l_image =  p_tcd->image;\n                OPJ_INT32 * l_src_ptr;\n                opj_tcd_tilecomp_t * l_tilec = p_tcd->tcd_image->tiles->comps + i;\n                opj_image_comp_t * l_img_comp = l_image->comps + i;\n                OPJ_UINT32 l_size_comp,l_width,l_height,l_offset_x,l_offset_y, l_image_width,l_stride,l_tile_offset;\n\n                opj_get_tile_dimensions(l_image,\n                                        l_tilec,\n                                        l_img_comp,\n                                        &l_size_comp,\n                                        &l_width,\n                                        &l_height,\n                                        &l_offset_x,\n                                        &l_offset_y,\n                                        &l_image_width,\n                                        &l_stride,\n                                        &l_tile_offset);\n\n                l_src_ptr = l_img_comp->data + l_tile_offset;\n\n                switch (l_size_comp) {\n                        case 1:\n                                {\n                                        OPJ_CHAR * l_dest_ptr = (OPJ_CHAR*) p_data;\n                                        if (l_img_comp->sgnd) {\n                                                for     (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr) = (OPJ_CHAR) (*l_src_ptr);\n                                                                ++l_dest_ptr;\n                                                                ++l_src_ptr;\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr) = (OPJ_CHAR)((*l_src_ptr)&0xff);\n                                                                ++l_dest_ptr;\n                                                                ++l_src_ptr;\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n\n                                        p_data = (OPJ_BYTE*) l_dest_ptr;\n                                }\n                                break;\n                        case 2:\n                                {\n                                        OPJ_INT16 * l_dest_ptr = (OPJ_INT16 *) p_data;\n                                        if (l_img_comp->sgnd) {\n                                                for (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_INT16) (*(l_src_ptr++));\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n                                        else {\n                                                for (j=0;j<l_height;++j) {\n                                                        for (k=0;k<l_width;++k) {\n                                                                *(l_dest_ptr++) = (OPJ_INT16)((*(l_src_ptr++)) & 0xffff);\n                                                        }\n                                                        l_src_ptr += l_stride;\n                                                }\n                                        }\n\n                                        p_data = (OPJ_BYTE*) l_dest_ptr;\n                                }\n                                break;\n                        case 4:\n                                {\n                                        OPJ_INT32 * l_dest_ptr = (OPJ_INT32 *) p_data;\n                                        for (j=0;j<l_height;++j) {\n                                                for (k=0;k<l_width;++k) {\n                                                        *(l_dest_ptr++) = *(l_src_ptr++);\n                                                }\n                                                l_src_ptr += l_stride;\n                                        }\n\n                                        p_data = (OPJ_BYTE*) l_dest_ptr;\n                                }\n                                break;\n                }\n        }\n}\n\nstatic OPJ_BOOL opj_j2k_post_write_tile (      opj_j2k_t * p_j2k,\n                                                                opj_stream_private_t *p_stream,\n                                                                opj_event_mgr_t * p_manager )\n{\n        OPJ_UINT32 l_nb_bytes_written;\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_tile_size = 0;\n        OPJ_UINT32 l_available_data;\n\n        /* preconditions */\n        assert(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);\n\n        l_tile_size = p_j2k->m_specific_param.m_encoder.m_encoded_tile_size;\n        l_available_data = l_tile_size;\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_encoded_tile_data;\n\n        l_nb_bytes_written = 0;\n        if (! opj_j2k_write_first_tile_part(p_j2k,l_current_data,&l_nb_bytes_written,l_available_data,p_stream,p_manager)) {\n                return OPJ_FALSE;\n        }\n        l_current_data += l_nb_bytes_written;\n        l_available_data -= l_nb_bytes_written;\n\n        l_nb_bytes_written = 0;\n        if (! opj_j2k_write_all_tile_parts(p_j2k,l_current_data,&l_nb_bytes_written,l_available_data,p_stream,p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        l_available_data -= l_nb_bytes_written;\n        l_nb_bytes_written = l_tile_size - l_available_data;\n\n        if ( opj_stream_write_data(     p_stream,\n                                                                p_j2k->m_specific_param.m_encoder.m_encoded_tile_data,\n                                                                l_nb_bytes_written,p_manager) != l_nb_bytes_written) {\n                return OPJ_FALSE;\n        }\n\n        ++p_j2k->m_current_tile_number;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_setup_end_compress (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager)\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        /* DEVELOPER CORNER, insert your custom procedures */\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_eoc, p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        if (OPJ_IS_CINEMA(p_j2k->m_cp.rsiz)) {\n                if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_updated_tlm, p_manager)) {\n                        return OPJ_FALSE;\n                }\n        }\n\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_epc, p_manager)) {\n                return OPJ_FALSE;\n        }\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_end_encoding, p_manager)) {\n                return OPJ_FALSE;\n        }\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_destroy_header_memory, p_manager)) {\n                return OPJ_FALSE;\n        }\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_setup_encoding_validation (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager)\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure)opj_j2k_build_encoder, p_manager)) {\n                return OPJ_FALSE;\n        }\n        if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure)opj_j2k_encoding_validation, p_manager)) {\n                return OPJ_FALSE;\n\t\t\t\t}\n\n        /* DEVELOPER CORNER, add your custom validation procedure */\n        if (! opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure)opj_j2k_mct_validation, p_manager)) {\n                return OPJ_FALSE;\n        }\n\t\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_setup_header_writing (opj_j2k_t *p_j2k, opj_event_mgr_t * p_manager)\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_init_info, p_manager)) {\n                return OPJ_FALSE;\n        }\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_soc, p_manager)) {\n                return OPJ_FALSE;\n        }\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_siz, p_manager)) {\n                return OPJ_FALSE;\n        }\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_cod, p_manager)) {\n                return OPJ_FALSE;\n        }\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_qcd, p_manager)) {\n                return OPJ_FALSE;\n        }\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_all_coc, p_manager)) {\n                return OPJ_FALSE;\n        }\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_all_qcc, p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        if (OPJ_IS_CINEMA(p_j2k->m_cp.rsiz)) {\n                if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_tlm, p_manager)) {\n                        return OPJ_FALSE;\n                }\n\n                if (p_j2k->m_cp.rsiz == OPJ_PROFILE_CINEMA_4K) {\n                        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_poc, p_manager)) {\n                                return OPJ_FALSE;\n                        }\n                }\n        }\n\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_regions, p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        if (p_j2k->m_cp.comment != 00)  {\n                if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_com, p_manager)) {\n                        return OPJ_FALSE;\n                }\n        }\n\n        /* DEVELOPER CORNER, insert your custom procedures */\n        if (p_j2k->m_cp.rsiz & OPJ_EXTENSION_MCT) {\n                if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_mct_data_group, p_manager)) {\n                        return OPJ_FALSE;\n                }\n        }\n        /* End of Developer Corner */\n\n        if (p_j2k->cstr_index) {\n                if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_get_end_header, p_manager)) {\n                        return OPJ_FALSE;\n                }\n        }\n\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_create_tcd, p_manager)) {\n                return OPJ_FALSE;\n        }\n        if (! opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_update_rates, p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_first_tile_part (opj_j2k_t *p_j2k,\n                                                                        OPJ_BYTE * p_data,\n                                                                        OPJ_UINT32 * p_data_written,\n                                                                        OPJ_UINT32 p_total_data_size,\n                                                                        opj_stream_private_t *p_stream,\n                                                                        struct opj_event_mgr * p_manager )\n{\n        OPJ_UINT32 l_nb_bytes_written = 0;\n        OPJ_UINT32 l_current_nb_bytes_written;\n        OPJ_BYTE * l_begin_data = 00;\n\n        opj_tcd_t * l_tcd = 00;\n        opj_cp_t * l_cp = 00;\n\n        l_tcd = p_j2k->m_tcd;\n        l_cp = &(p_j2k->m_cp);\n\n        l_tcd->cur_pino = 0;\n\n        /*Get number of tile parts*/\n        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = 0;\n\n        /* INDEX >> */\n        /* << INDEX */\n\n        l_current_nb_bytes_written = 0;\n        l_begin_data = p_data;\n        if (! opj_j2k_write_sot(p_j2k,p_data,&l_current_nb_bytes_written,p_stream,p_manager))\n        {\n                return OPJ_FALSE;\n        }\n\n        l_nb_bytes_written += l_current_nb_bytes_written;\n        p_data += l_current_nb_bytes_written;\n        p_total_data_size -= l_current_nb_bytes_written;\n\n        if (!OPJ_IS_CINEMA(l_cp->rsiz)) {\n#if 0\n                for (compno = 1; compno < p_j2k->m_private_image->numcomps; compno++) {\n                        l_current_nb_bytes_written = 0;\n                        opj_j2k_write_coc_in_memory(p_j2k,compno,p_data,&l_current_nb_bytes_written,p_manager);\n                        l_nb_bytes_written += l_current_nb_bytes_written;\n                        p_data += l_current_nb_bytes_written;\n                        p_total_data_size -= l_current_nb_bytes_written;\n\n                        l_current_nb_bytes_written = 0;\n                        opj_j2k_write_qcc_in_memory(p_j2k,compno,p_data,&l_current_nb_bytes_written,p_manager);\n                        l_nb_bytes_written += l_current_nb_bytes_written;\n                        p_data += l_current_nb_bytes_written;\n                        p_total_data_size -= l_current_nb_bytes_written;\n                }\n#endif\n                if (l_cp->tcps[p_j2k->m_current_tile_number].numpocs) {\n                        l_current_nb_bytes_written = 0;\n                        opj_j2k_write_poc_in_memory(p_j2k,p_data,&l_current_nb_bytes_written,p_manager);\n                        l_nb_bytes_written += l_current_nb_bytes_written;\n                        p_data += l_current_nb_bytes_written;\n                        p_total_data_size -= l_current_nb_bytes_written;\n                }\n        }\n\n        l_current_nb_bytes_written = 0;\n        if (! opj_j2k_write_sod(p_j2k,l_tcd,p_data,&l_current_nb_bytes_written,p_total_data_size,p_stream,p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        l_nb_bytes_written += l_current_nb_bytes_written;\n        * p_data_written = l_nb_bytes_written;\n\n        /* Writing Psot in SOT marker */\n        opj_write_bytes(l_begin_data + 6,l_nb_bytes_written,4);                                 /* PSOT */\n\n        if (OPJ_IS_CINEMA(l_cp->rsiz)){\n                opj_j2k_update_tlm(p_j2k,l_nb_bytes_written);\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_all_tile_parts(  opj_j2k_t *p_j2k,\n                                                                        OPJ_BYTE * p_data,\n                                                                        OPJ_UINT32 * p_data_written,\n                                                                        OPJ_UINT32 p_total_data_size,\n                                                                        opj_stream_private_t *p_stream,\n                                                                        struct opj_event_mgr * p_manager\n                                                                )\n{\n        OPJ_UINT32 tilepartno=0;\n        OPJ_UINT32 l_nb_bytes_written = 0;\n        OPJ_UINT32 l_current_nb_bytes_written;\n        OPJ_UINT32 l_part_tile_size;\n        OPJ_UINT32 tot_num_tp;\n        OPJ_UINT32 pino;\n\n        OPJ_BYTE * l_begin_data;\n        opj_tcp_t *l_tcp = 00;\n        opj_tcd_t * l_tcd = 00;\n        opj_cp_t * l_cp = 00;\n\n        l_tcd = p_j2k->m_tcd;\n        l_cp = &(p_j2k->m_cp);\n        l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;\n\n        /*Get number of tile parts*/\n        tot_num_tp = opj_j2k_get_num_tp(l_cp,0,p_j2k->m_current_tile_number);\n\n        /* start writing remaining tile parts */\n        ++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;\n        for (tilepartno = 1; tilepartno < tot_num_tp ; ++tilepartno) {\n                p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;\n                l_current_nb_bytes_written = 0;\n                l_part_tile_size = 0;\n                l_begin_data = p_data;\n\n                if (! opj_j2k_write_sot(p_j2k,p_data,&l_current_nb_bytes_written,p_stream,p_manager)) {\n                        return OPJ_FALSE;\n                }\n\n                l_nb_bytes_written += l_current_nb_bytes_written;\n                p_data += l_current_nb_bytes_written;\n                p_total_data_size -= l_current_nb_bytes_written;\n                l_part_tile_size += l_current_nb_bytes_written;\n\n                l_current_nb_bytes_written = 0;\n                if (! opj_j2k_write_sod(p_j2k,l_tcd,p_data,&l_current_nb_bytes_written,p_total_data_size,p_stream,p_manager)) {\n                        return OPJ_FALSE;\n                }\n\n                p_data += l_current_nb_bytes_written;\n                l_nb_bytes_written += l_current_nb_bytes_written;\n                p_total_data_size -= l_current_nb_bytes_written;\n                l_part_tile_size += l_current_nb_bytes_written;\n\n                /* Writing Psot in SOT marker */\n                opj_write_bytes(l_begin_data + 6,l_part_tile_size,4);                                   /* PSOT */\n\n                if (OPJ_IS_CINEMA(l_cp->rsiz)) {\n                        opj_j2k_update_tlm(p_j2k,l_part_tile_size);\n                }\n\n                ++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;\n        }\n\n        for (pino = 1; pino <= l_tcp->numpocs; ++pino) {\n                l_tcd->cur_pino = pino;\n\n                /*Get number of tile parts*/\n                tot_num_tp = opj_j2k_get_num_tp(l_cp,pino,p_j2k->m_current_tile_number);\n                for (tilepartno = 0; tilepartno < tot_num_tp ; ++tilepartno) {\n                        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;\n                        l_current_nb_bytes_written = 0;\n                        l_part_tile_size = 0;\n                        l_begin_data = p_data;\n\n                        if (! opj_j2k_write_sot(p_j2k,p_data,&l_current_nb_bytes_written,p_stream,p_manager)) {\n                                return OPJ_FALSE;\n                        }\n\n                        l_nb_bytes_written += l_current_nb_bytes_written;\n                        p_data += l_current_nb_bytes_written;\n                        p_total_data_size -= l_current_nb_bytes_written;\n                        l_part_tile_size += l_current_nb_bytes_written;\n\n                        l_current_nb_bytes_written = 0;\n\n                        if (! opj_j2k_write_sod(p_j2k,l_tcd,p_data,&l_current_nb_bytes_written,p_total_data_size,p_stream,p_manager)) {\n                                return OPJ_FALSE;\n                        }\n\n                        l_nb_bytes_written += l_current_nb_bytes_written;\n                        p_data += l_current_nb_bytes_written;\n                        p_total_data_size -= l_current_nb_bytes_written;\n                        l_part_tile_size += l_current_nb_bytes_written;\n\n                        /* Writing Psot in SOT marker */\n                        opj_write_bytes(l_begin_data + 6,l_part_tile_size,4);                                   /* PSOT */\n\n                        if (OPJ_IS_CINEMA(l_cp->rsiz)) {\n                                opj_j2k_update_tlm(p_j2k,l_part_tile_size);\n                        }\n\n                        ++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;\n                }\n        }\n\n        *p_data_written = l_nb_bytes_written;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_write_updated_tlm( opj_j2k_t *p_j2k,\n                                                                    struct opj_stream_private *p_stream,\n                                                                    struct opj_event_mgr * p_manager )\n{\n        OPJ_UINT32 l_tlm_size;\n        OPJ_OFF_T l_tlm_position, l_current_position;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_tlm_size = 5 * p_j2k->m_specific_param.m_encoder.m_total_tile_parts;\n        l_tlm_position = 6 + p_j2k->m_specific_param.m_encoder.m_tlm_start;\n        l_current_position = opj_stream_tell(p_stream);\n\n        if (! opj_stream_seek(p_stream,l_tlm_position,p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer,l_tlm_size,p_manager) != l_tlm_size) {\n                return OPJ_FALSE;\n        }\n\n        if (! opj_stream_seek(p_stream,l_current_position,p_manager)) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_end_encoding(  opj_j2k_t *p_j2k,\n                                                        struct opj_stream_private *p_stream,\n                                                        struct opj_event_mgr * p_manager )\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        opj_tcd_destroy(p_j2k->m_tcd);\n        p_j2k->m_tcd = 00;\n\n        if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {\n                opj_free(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);\n                p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = 0;\n                p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = 0;\n        }\n\n        if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {\n                opj_free(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);\n                p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = 0;\n        }\n\n        p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = 0;\n\n        return OPJ_TRUE;\n}\n\n/**\n * Destroys the memory associated with the decoding of headers.\n */\nstatic OPJ_BOOL opj_j2k_destroy_header_memory ( opj_j2k_t * p_j2k,\n                                                opj_stream_private_t *p_stream,\n                                                opj_event_mgr_t * p_manager\n                                                )\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n\n        if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {\n                opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = 0;\n        }\n\n        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n\n        return OPJ_TRUE;\n}\n\nstatic OPJ_BOOL opj_j2k_init_info(     opj_j2k_t *p_j2k,\n                                                struct opj_stream_private *p_stream,\n                                                struct opj_event_mgr * p_manager )\n{\n        opj_codestream_info_t * l_cstr_info = 00;\n\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n  (void)l_cstr_info;\n\n        /* TODO mergeV2: check this part which use cstr_info */\n        /*l_cstr_info = p_j2k->cstr_info;\n\n        if (l_cstr_info)  {\n                OPJ_UINT32 compno;\n                l_cstr_info->tile = (opj_tile_info_t *) opj_malloc(p_j2k->m_cp.tw * p_j2k->m_cp.th * sizeof(opj_tile_info_t));\n\n                l_cstr_info->image_w = p_j2k->m_image->x1 - p_j2k->m_image->x0;\n                l_cstr_info->image_h = p_j2k->m_image->y1 - p_j2k->m_image->y0;\n\n                l_cstr_info->prog = (&p_j2k->m_cp.tcps[0])->prg;\n\n                l_cstr_info->tw = p_j2k->m_cp.tw;\n                l_cstr_info->th = p_j2k->m_cp.th;\n\n                l_cstr_info->tile_x = p_j2k->m_cp.tdx;*/        /* new version parser */\n                /*l_cstr_info->tile_y = p_j2k->m_cp.tdy;*/      /* new version parser */\n                /*l_cstr_info->tile_Ox = p_j2k->m_cp.tx0;*/     /* new version parser */\n                /*l_cstr_info->tile_Oy = p_j2k->m_cp.ty0;*/     /* new version parser */\n\n                /*l_cstr_info->numcomps = p_j2k->m_image->numcomps;\n\n                l_cstr_info->numlayers = (&p_j2k->m_cp.tcps[0])->numlayers;\n\n                l_cstr_info->numdecompos = (OPJ_INT32*) opj_malloc(p_j2k->m_image->numcomps * sizeof(OPJ_INT32));\n\n                for (compno=0; compno < p_j2k->m_image->numcomps; compno++) {\n                        l_cstr_info->numdecompos[compno] = (&p_j2k->m_cp.tcps[0])->tccps->numresolutions - 1;\n                }\n\n                l_cstr_info->D_max = 0.0;       */      /* ADD Marcela */\n\n                /*l_cstr_info->main_head_start = opj_stream_tell(p_stream);*/ /* position of SOC */\n\n                /*l_cstr_info->maxmarknum = 100;\n                l_cstr_info->marker = (opj_marker_info_t *) opj_malloc(l_cstr_info->maxmarknum * sizeof(opj_marker_info_t));\n                l_cstr_info->marknum = 0;\n        }*/\n\n        return opj_j2k_calculate_tp(p_j2k,&(p_j2k->m_cp),&p_j2k->m_specific_param.m_encoder.m_total_tile_parts,p_j2k->m_private_image,p_manager);\n}\n\n/**\n * Creates a tile-coder decoder.\n *\n * @param       p_stream                the stream to write data to.\n * @param       p_j2k                   J2K codec.\n * @param       p_manager               the user event manager.\n*/\nstatic OPJ_BOOL opj_j2k_create_tcd(     opj_j2k_t *p_j2k,\n                                                                    opj_stream_private_t *p_stream,\n                                                                    opj_event_mgr_t * p_manager\n                                    )\n{\n        /* preconditions */\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        p_j2k->m_tcd = opj_tcd_create(OPJ_FALSE);\n\n        if (! p_j2k->m_tcd) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Not enough memory to create Tile Coder\\n\");\n                return OPJ_FALSE;\n        }\n\n        if (!opj_tcd_init(p_j2k->m_tcd,p_j2k->m_private_image,&p_j2k->m_cp, p_j2k->m_tp)) {\n                opj_tcd_destroy(p_j2k->m_tcd);\n                p_j2k->m_tcd = 00;\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}\n\nOPJ_BOOL opj_j2k_write_tile (opj_j2k_t * p_j2k,\n                                                 OPJ_UINT32 p_tile_index,\n                                                 OPJ_BYTE * p_data,\n                                                 OPJ_UINT32 p_data_size,\n                                                 opj_stream_private_t *p_stream,\n                                                 opj_event_mgr_t * p_manager )\n{\n        if (! opj_j2k_pre_write_tile(p_j2k,p_tile_index,p_stream,p_manager)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Error while opj_j2k_pre_write_tile with tile index = %d\\n\", p_tile_index);\n                return OPJ_FALSE;\n        }\n        else {\n                OPJ_UINT32 j;\n                /* Allocate data */\n                for (j=0;j<p_j2k->m_tcd->image->numcomps;++j) {\n                        opj_tcd_tilecomp_t* l_tilec = p_j2k->m_tcd->tcd_image->tiles->comps + j;\n\n                        if(! opj_alloc_tile_component_data(l_tilec)) {\n\t\t\t\t\t\t\t\t\t\t\t\t        opj_event_msg(p_manager, EVT_ERROR, \"Error allocating tile component data.\" );\n                                return OPJ_FALSE;\n                        }\n                }\n\n                /* now copy data into the tile component */\n                if (! opj_tcd_copy_tile_data(p_j2k->m_tcd,p_data,p_data_size)) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Size mismatch between tile data and sent data.\" );\n                        return OPJ_FALSE;\n                }\n                if (! opj_j2k_post_write_tile(p_j2k,p_stream,p_manager)) {\n                        opj_event_msg(p_manager, EVT_ERROR, \"Error while opj_j2k_post_write_tile with tile index = %d\\n\", p_tile_index);\n                        return OPJ_FALSE;\n                }\n        }\n\n        return OPJ_TRUE;\n}\n"], "filenames": ["src/bin/jp2/convert.c", "src/bin/jp2/convertbmp.c", "src/bin/jp2/opj_decompress.c", "src/lib/openjp2/j2k.c"], "buggy_code_start_loc": [909, 808, 1610, 2161], "buggy_code_end_loc": [2242, 811, 1611, 10132], "fixing_code_start_loc": [909, 809, 1610, 2161], "fixing_code_end_loc": [2289, 838, 1611, 10138], "type": "CWE-476", "message": "A NULL pointer dereference flaw was found in the way openjpeg 2.1.2 decoded certain input images. Due to a logic error in the code responsible for decoding the input image, an application using openjpeg to process image data could crash when processing a crafted image.", "other": {"cve": {"id": "CVE-2016-9572", "sourceIdentifier": "secalert@redhat.com", "published": "2018-08-01T16:29:00.383", "lastModified": "2023-02-12T23:27:16.647", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A NULL pointer dereference flaw was found in the way openjpeg 2.1.2 decoded certain input images. Due to a logic error in the code responsible for decoding the input image, an application using openjpeg to process image data could crash when processing a crafted image."}, {"lang": "es", "value": "Se ha detectado un error de desreferencia de puntero NULL en la forma en la que openjpeg 2.1.2 descifraba ciertas im\u00e1genes de entrada. Debido a un error de l\u00f3gica en el c\u00f3digo responsable de descifrar la imagen de entrada, una aplicaci\u00f3n que emplee openjpeg para procesar datos de im\u00e1genes podr\u00eda cerrarse inesperadamente al procesar una imagen manipulada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:uclouvain:openjpeg:2.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "1CFB3AF6-73C9-4567-9FA4-DE81159128D7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/109233", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2016-9572", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/szukw000/openjpeg/commit/7b28bd2b723df6be09fe7791eba33147c1c47d0d", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/uclouvain/openjpeg/issues/863", "source": "secalert@redhat.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201710-26", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2017/dsa-3768", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpujul2019-5072835.html", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/szukw000/openjpeg/commit/7b28bd2b723df6be09fe7791eba33147c1c47d0d"}}