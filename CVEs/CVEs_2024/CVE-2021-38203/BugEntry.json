{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n\n#include \"misc.h\"\n#include \"ctree.h\"\n#include \"block-group.h\"\n#include \"space-info.h\"\n#include \"disk-io.h\"\n#include \"free-space-cache.h\"\n#include \"free-space-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"ref-verify.h\"\n#include \"sysfs.h\"\n#include \"tree-log.h\"\n#include \"delalloc-space.h\"\n#include \"discard.h\"\n#include \"raid56.h\"\n#include \"zoned.h\"\n\n/*\n * Return target flags in extended format or 0 if restripe for this chunk_type\n * is not in progress\n *\n * Should be called with balance_lock held\n */\nstatic u64 get_restripe_target(struct btrfs_fs_info *fs_info, u64 flags)\n{\n\tstruct btrfs_balance_control *bctl = fs_info->balance_ctl;\n\tu64 target = 0;\n\n\tif (!bctl)\n\t\treturn 0;\n\n\tif (flags & BTRFS_BLOCK_GROUP_DATA &&\n\t    bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT) {\n\t\ttarget = BTRFS_BLOCK_GROUP_DATA | bctl->data.target;\n\t} else if (flags & BTRFS_BLOCK_GROUP_SYSTEM &&\n\t\t   bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) {\n\t\ttarget = BTRFS_BLOCK_GROUP_SYSTEM | bctl->sys.target;\n\t} else if (flags & BTRFS_BLOCK_GROUP_METADATA &&\n\t\t   bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT) {\n\t\ttarget = BTRFS_BLOCK_GROUP_METADATA | bctl->meta.target;\n\t}\n\n\treturn target;\n}\n\n/*\n * @flags: available profiles in extended format (see ctree.h)\n *\n * Return reduced profile in chunk format.  If profile changing is in progress\n * (either running or paused) picks the target profile (if it's already\n * available), otherwise falls back to plain reducing.\n */\nstatic u64 btrfs_reduce_alloc_profile(struct btrfs_fs_info *fs_info, u64 flags)\n{\n\tu64 num_devices = fs_info->fs_devices->rw_devices;\n\tu64 target;\n\tu64 raid_type;\n\tu64 allowed = 0;\n\n\t/*\n\t * See if restripe for this chunk_type is in progress, if so try to\n\t * reduce to the target profile\n\t */\n\tspin_lock(&fs_info->balance_lock);\n\ttarget = get_restripe_target(fs_info, flags);\n\tif (target) {\n\t\tspin_unlock(&fs_info->balance_lock);\n\t\treturn extended_to_chunk(target);\n\t}\n\tspin_unlock(&fs_info->balance_lock);\n\n\t/* First, mask out the RAID levels which aren't possible */\n\tfor (raid_type = 0; raid_type < BTRFS_NR_RAID_TYPES; raid_type++) {\n\t\tif (num_devices >= btrfs_raid_array[raid_type].devs_min)\n\t\t\tallowed |= btrfs_raid_array[raid_type].bg_flag;\n\t}\n\tallowed &= flags;\n\n\tif (allowed & BTRFS_BLOCK_GROUP_RAID6)\n\t\tallowed = BTRFS_BLOCK_GROUP_RAID6;\n\telse if (allowed & BTRFS_BLOCK_GROUP_RAID5)\n\t\tallowed = BTRFS_BLOCK_GROUP_RAID5;\n\telse if (allowed & BTRFS_BLOCK_GROUP_RAID10)\n\t\tallowed = BTRFS_BLOCK_GROUP_RAID10;\n\telse if (allowed & BTRFS_BLOCK_GROUP_RAID1)\n\t\tallowed = BTRFS_BLOCK_GROUP_RAID1;\n\telse if (allowed & BTRFS_BLOCK_GROUP_RAID0)\n\t\tallowed = BTRFS_BLOCK_GROUP_RAID0;\n\n\tflags &= ~BTRFS_BLOCK_GROUP_PROFILE_MASK;\n\n\treturn extended_to_chunk(flags | allowed);\n}\n\nu64 btrfs_get_alloc_profile(struct btrfs_fs_info *fs_info, u64 orig_flags)\n{\n\tunsigned seq;\n\tu64 flags;\n\n\tdo {\n\t\tflags = orig_flags;\n\t\tseq = read_seqbegin(&fs_info->profiles_lock);\n\n\t\tif (flags & BTRFS_BLOCK_GROUP_DATA)\n\t\t\tflags |= fs_info->avail_data_alloc_bits;\n\t\telse if (flags & BTRFS_BLOCK_GROUP_SYSTEM)\n\t\t\tflags |= fs_info->avail_system_alloc_bits;\n\t\telse if (flags & BTRFS_BLOCK_GROUP_METADATA)\n\t\t\tflags |= fs_info->avail_metadata_alloc_bits;\n\t} while (read_seqretry(&fs_info->profiles_lock, seq));\n\n\treturn btrfs_reduce_alloc_profile(fs_info, flags);\n}\n\nvoid btrfs_get_block_group(struct btrfs_block_group *cache)\n{\n\trefcount_inc(&cache->refs);\n}\n\nvoid btrfs_put_block_group(struct btrfs_block_group *cache)\n{\n\tif (refcount_dec_and_test(&cache->refs)) {\n\t\tWARN_ON(cache->pinned > 0);\n\t\tWARN_ON(cache->reserved > 0);\n\n\t\t/*\n\t\t * A block_group shouldn't be on the discard_list anymore.\n\t\t * Remove the block_group from the discard_list to prevent us\n\t\t * from causing a panic due to NULL pointer dereference.\n\t\t */\n\t\tif (WARN_ON(!list_empty(&cache->discard_list)))\n\t\t\tbtrfs_discard_cancel_work(&cache->fs_info->discard_ctl,\n\t\t\t\t\t\t  cache);\n\n\t\t/*\n\t\t * If not empty, someone is still holding mutex of\n\t\t * full_stripe_lock, which can only be released by caller.\n\t\t * And it will definitely cause use-after-free when caller\n\t\t * tries to release full stripe lock.\n\t\t *\n\t\t * No better way to resolve, but only to warn.\n\t\t */\n\t\tWARN_ON(!RB_EMPTY_ROOT(&cache->full_stripe_locks_root.root));\n\t\tkfree(cache->free_space_ctl);\n\t\tkfree(cache);\n\t}\n}\n\n/*\n * This adds the block group to the fs_info rb tree for the block group cache\n */\nstatic int btrfs_add_block_group_cache(struct btrfs_fs_info *info,\n\t\t\t\t       struct btrfs_block_group *block_group)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_block_group *cache;\n\n\tASSERT(block_group->length != 0);\n\n\tspin_lock(&info->block_group_cache_lock);\n\tp = &info->block_group_cache_tree.rb_node;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tcache = rb_entry(parent, struct btrfs_block_group, cache_node);\n\t\tif (block_group->start < cache->start) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (block_group->start > cache->start) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tspin_unlock(&info->block_group_cache_lock);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&block_group->cache_node, parent, p);\n\trb_insert_color(&block_group->cache_node,\n\t\t\t&info->block_group_cache_tree);\n\n\tif (info->first_logical_byte > block_group->start)\n\t\tinfo->first_logical_byte = block_group->start;\n\n\tspin_unlock(&info->block_group_cache_lock);\n\n\treturn 0;\n}\n\n/*\n * This will return the block group at or after bytenr if contains is 0, else\n * it will return the block group that contains the bytenr\n */\nstatic struct btrfs_block_group *block_group_cache_tree_search(\n\t\tstruct btrfs_fs_info *info, u64 bytenr, int contains)\n{\n\tstruct btrfs_block_group *cache, *ret = NULL;\n\tstruct rb_node *n;\n\tu64 end, start;\n\n\tspin_lock(&info->block_group_cache_lock);\n\tn = info->block_group_cache_tree.rb_node;\n\n\twhile (n) {\n\t\tcache = rb_entry(n, struct btrfs_block_group, cache_node);\n\t\tend = cache->start + cache->length - 1;\n\t\tstart = cache->start;\n\n\t\tif (bytenr < start) {\n\t\t\tif (!contains && (!ret || start < ret->start))\n\t\t\t\tret = cache;\n\t\t\tn = n->rb_left;\n\t\t} else if (bytenr > start) {\n\t\t\tif (contains && bytenr <= end) {\n\t\t\t\tret = cache;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tret = cache;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret) {\n\t\tbtrfs_get_block_group(ret);\n\t\tif (bytenr == 0 && info->first_logical_byte > ret->start)\n\t\t\tinfo->first_logical_byte = ret->start;\n\t}\n\tspin_unlock(&info->block_group_cache_lock);\n\n\treturn ret;\n}\n\n/*\n * Return the block group that starts at or after bytenr\n */\nstruct btrfs_block_group *btrfs_lookup_first_block_group(\n\t\tstruct btrfs_fs_info *info, u64 bytenr)\n{\n\treturn block_group_cache_tree_search(info, bytenr, 0);\n}\n\n/*\n * Return the block group that contains the given bytenr\n */\nstruct btrfs_block_group *btrfs_lookup_block_group(\n\t\tstruct btrfs_fs_info *info, u64 bytenr)\n{\n\treturn block_group_cache_tree_search(info, bytenr, 1);\n}\n\nstruct btrfs_block_group *btrfs_next_block_group(\n\t\tstruct btrfs_block_group *cache)\n{\n\tstruct btrfs_fs_info *fs_info = cache->fs_info;\n\tstruct rb_node *node;\n\n\tspin_lock(&fs_info->block_group_cache_lock);\n\n\t/* If our block group was removed, we need a full search. */\n\tif (RB_EMPTY_NODE(&cache->cache_node)) {\n\t\tconst u64 next_bytenr = cache->start + cache->length;\n\n\t\tspin_unlock(&fs_info->block_group_cache_lock);\n\t\tbtrfs_put_block_group(cache);\n\t\tcache = btrfs_lookup_first_block_group(fs_info, next_bytenr); return cache;\n\t}\n\tnode = rb_next(&cache->cache_node);\n\tbtrfs_put_block_group(cache);\n\tif (node) {\n\t\tcache = rb_entry(node, struct btrfs_block_group, cache_node);\n\t\tbtrfs_get_block_group(cache);\n\t} else\n\t\tcache = NULL;\n\tspin_unlock(&fs_info->block_group_cache_lock);\n\treturn cache;\n}\n\nbool btrfs_inc_nocow_writers(struct btrfs_fs_info *fs_info, u64 bytenr)\n{\n\tstruct btrfs_block_group *bg;\n\tbool ret = true;\n\n\tbg = btrfs_lookup_block_group(fs_info, bytenr);\n\tif (!bg)\n\t\treturn false;\n\n\tspin_lock(&bg->lock);\n\tif (bg->ro)\n\t\tret = false;\n\telse\n\t\tatomic_inc(&bg->nocow_writers);\n\tspin_unlock(&bg->lock);\n\n\t/* No put on block group, done by btrfs_dec_nocow_writers */\n\tif (!ret)\n\t\tbtrfs_put_block_group(bg);\n\n\treturn ret;\n}\n\nvoid btrfs_dec_nocow_writers(struct btrfs_fs_info *fs_info, u64 bytenr)\n{\n\tstruct btrfs_block_group *bg;\n\n\tbg = btrfs_lookup_block_group(fs_info, bytenr);\n\tASSERT(bg);\n\tif (atomic_dec_and_test(&bg->nocow_writers))\n\t\twake_up_var(&bg->nocow_writers);\n\t/*\n\t * Once for our lookup and once for the lookup done by a previous call\n\t * to btrfs_inc_nocow_writers()\n\t */\n\tbtrfs_put_block_group(bg);\n\tbtrfs_put_block_group(bg);\n}\n\nvoid btrfs_wait_nocow_writers(struct btrfs_block_group *bg)\n{\n\twait_var_event(&bg->nocow_writers, !atomic_read(&bg->nocow_writers));\n}\n\nvoid btrfs_dec_block_group_reservations(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tconst u64 start)\n{\n\tstruct btrfs_block_group *bg;\n\n\tbg = btrfs_lookup_block_group(fs_info, start);\n\tASSERT(bg);\n\tif (atomic_dec_and_test(&bg->reservations))\n\t\twake_up_var(&bg->reservations);\n\tbtrfs_put_block_group(bg);\n}\n\nvoid btrfs_wait_block_group_reservations(struct btrfs_block_group *bg)\n{\n\tstruct btrfs_space_info *space_info = bg->space_info;\n\n\tASSERT(bg->ro);\n\n\tif (!(bg->flags & BTRFS_BLOCK_GROUP_DATA))\n\t\treturn;\n\n\t/*\n\t * Our block group is read only but before we set it to read only,\n\t * some task might have had allocated an extent from it already, but it\n\t * has not yet created a respective ordered extent (and added it to a\n\t * root's list of ordered extents).\n\t * Therefore wait for any task currently allocating extents, since the\n\t * block group's reservations counter is incremented while a read lock\n\t * on the groups' semaphore is held and decremented after releasing\n\t * the read access on that semaphore and creating the ordered extent.\n\t */\n\tdown_write(&space_info->groups_sem);\n\tup_write(&space_info->groups_sem);\n\n\twait_var_event(&bg->reservations, !atomic_read(&bg->reservations));\n}\n\nstruct btrfs_caching_control *btrfs_get_caching_control(\n\t\tstruct btrfs_block_group *cache)\n{\n\tstruct btrfs_caching_control *ctl;\n\n\tspin_lock(&cache->lock);\n\tif (!cache->caching_ctl) {\n\t\tspin_unlock(&cache->lock);\n\t\treturn NULL;\n\t}\n\n\tctl = cache->caching_ctl;\n\trefcount_inc(&ctl->count);\n\tspin_unlock(&cache->lock);\n\treturn ctl;\n}\n\nvoid btrfs_put_caching_control(struct btrfs_caching_control *ctl)\n{\n\tif (refcount_dec_and_test(&ctl->count))\n\t\tkfree(ctl);\n}\n\n/*\n * When we wait for progress in the block group caching, its because our\n * allocation attempt failed at least once.  So, we must sleep and let some\n * progress happen before we try again.\n *\n * This function will sleep at least once waiting for new free space to show\n * up, and then it will check the block group free space numbers for our min\n * num_bytes.  Another option is to have it go ahead and look in the rbtree for\n * a free extent of a given size, but this is a good start.\n *\n * Callers of this must check if cache->cached == BTRFS_CACHE_ERROR before using\n * any of the information in this block group.\n */\nvoid btrfs_wait_block_group_cache_progress(struct btrfs_block_group *cache,\n\t\t\t\t\t   u64 num_bytes)\n{\n\tstruct btrfs_caching_control *caching_ctl;\n\n\tcaching_ctl = btrfs_get_caching_control(cache);\n\tif (!caching_ctl)\n\t\treturn;\n\n\twait_event(caching_ctl->wait, btrfs_block_group_done(cache) ||\n\t\t   (cache->free_space_ctl->free_space >= num_bytes));\n\n\tbtrfs_put_caching_control(caching_ctl);\n}\n\nint btrfs_wait_block_group_cache_done(struct btrfs_block_group *cache)\n{\n\tstruct btrfs_caching_control *caching_ctl;\n\tint ret = 0;\n\n\tcaching_ctl = btrfs_get_caching_control(cache);\n\tif (!caching_ctl)\n\t\treturn (cache->cached == BTRFS_CACHE_ERROR) ? -EIO : 0;\n\n\twait_event(caching_ctl->wait, btrfs_block_group_done(cache));\n\tif (cache->cached == BTRFS_CACHE_ERROR)\n\t\tret = -EIO;\n\tbtrfs_put_caching_control(caching_ctl);\n\treturn ret;\n}\n\nstatic bool space_cache_v1_done(struct btrfs_block_group *cache)\n{\n\tbool ret;\n\n\tspin_lock(&cache->lock);\n\tret = cache->cached != BTRFS_CACHE_FAST;\n\tspin_unlock(&cache->lock);\n\n\treturn ret;\n}\n\nvoid btrfs_wait_space_cache_v1_finished(struct btrfs_block_group *cache,\n\t\t\t\tstruct btrfs_caching_control *caching_ctl)\n{\n\twait_event(caching_ctl->wait, space_cache_v1_done(cache));\n}\n\n#ifdef CONFIG_BTRFS_DEBUG\nstatic void fragment_free_space(struct btrfs_block_group *block_group)\n{\n\tstruct btrfs_fs_info *fs_info = block_group->fs_info;\n\tu64 start = block_group->start;\n\tu64 len = block_group->length;\n\tu64 chunk = block_group->flags & BTRFS_BLOCK_GROUP_METADATA ?\n\t\tfs_info->nodesize : fs_info->sectorsize;\n\tu64 step = chunk << 1;\n\n\twhile (len > chunk) {\n\t\tbtrfs_remove_free_space(block_group, start, chunk);\n\t\tstart += step;\n\t\tif (len < step)\n\t\t\tlen = 0;\n\t\telse\n\t\t\tlen -= step;\n\t}\n}\n#endif\n\n/*\n * This is only called by btrfs_cache_block_group, since we could have freed\n * extents we need to check the pinned_extents for any extents that can't be\n * used yet since their free space will be released as soon as the transaction\n * commits.\n */\nu64 add_new_free_space(struct btrfs_block_group *block_group, u64 start, u64 end)\n{\n\tstruct btrfs_fs_info *info = block_group->fs_info;\n\tu64 extent_start, extent_end, size, total_added = 0;\n\tint ret;\n\n\twhile (start < end) {\n\t\tret = find_first_extent_bit(&info->excluded_extents, start,\n\t\t\t\t\t    &extent_start, &extent_end,\n\t\t\t\t\t    EXTENT_DIRTY | EXTENT_UPTODATE,\n\t\t\t\t\t    NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (extent_start <= start) {\n\t\t\tstart = extent_end + 1;\n\t\t} else if (extent_start > start && extent_start < end) {\n\t\t\tsize = extent_start - start;\n\t\t\ttotal_added += size;\n\t\t\tret = btrfs_add_free_space_async_trimmed(block_group,\n\t\t\t\t\t\t\t\t start, size);\n\t\t\tBUG_ON(ret); /* -ENOMEM or logic error */\n\t\t\tstart = extent_end + 1;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start < end) {\n\t\tsize = end - start;\n\t\ttotal_added += size;\n\t\tret = btrfs_add_free_space_async_trimmed(block_group, start,\n\t\t\t\t\t\t\t size);\n\t\tBUG_ON(ret); /* -ENOMEM or logic error */\n\t}\n\n\treturn total_added;\n}\n\nstatic int load_extent_tree_free(struct btrfs_caching_control *caching_ctl)\n{\n\tstruct btrfs_block_group *block_group = caching_ctl->block_group;\n\tstruct btrfs_fs_info *fs_info = block_group->fs_info;\n\tstruct btrfs_root *extent_root = fs_info->extent_root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tu64 total_found = 0;\n\tu64 last = 0;\n\tu32 nritems;\n\tint ret;\n\tbool wakeup = true;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tlast = max_t(u64, block_group->start, BTRFS_SUPER_INFO_OFFSET);\n\n#ifdef CONFIG_BTRFS_DEBUG\n\t/*\n\t * If we're fragmenting we don't want to make anybody think we can\n\t * allocate from this block group until we've had a chance to fragment\n\t * the free space.\n\t */\n\tif (btrfs_should_fragment_free_space(block_group))\n\t\twakeup = false;\n#endif\n\t/*\n\t * We don't want to deadlock with somebody trying to allocate a new\n\t * extent for the extent root while also trying to search the extent\n\t * root to add free space.  So we skip locking and search the commit\n\t * root, since its read-only\n\t */\n\tpath->skip_locking = 1;\n\tpath->search_commit_root = 1;\n\tpath->reada = READA_FORWARD;\n\n\tkey.objectid = last;\n\tkey.offset = 0;\n\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\nnext:\n\tret = btrfs_search_slot(NULL, extent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tnritems = btrfs_header_nritems(leaf);\n\n\twhile (1) {\n\t\tif (btrfs_fs_closing(fs_info) > 1) {\n\t\t\tlast = (u64)-1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (path->slots[0] < nritems) {\n\t\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\t} else {\n\t\t\tret = btrfs_find_next_key(extent_root, path, &key, 0, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (need_resched() ||\n\t\t\t    rwsem_is_contended(&fs_info->commit_root_sem)) {\n\t\t\t\tif (wakeup)\n\t\t\t\t\tcaching_ctl->progress = last;\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tup_read(&fs_info->commit_root_sem);\n\t\t\t\tmutex_unlock(&caching_ctl->mutex);\n\t\t\t\tcond_resched();\n\t\t\t\tmutex_lock(&caching_ctl->mutex);\n\t\t\t\tdown_read(&fs_info->commit_root_sem);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tret = btrfs_next_leaf(extent_root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t\tnritems = btrfs_header_nritems(leaf);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (key.objectid < last) {\n\t\t\tkey.objectid = last;\n\t\t\tkey.offset = 0;\n\t\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\n\t\t\tif (wakeup)\n\t\t\t\tcaching_ctl->progress = last;\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (key.objectid < block_group->start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (key.objectid >= block_group->start + block_group->length)\n\t\t\tbreak;\n\n\t\tif (key.type == BTRFS_EXTENT_ITEM_KEY ||\n\t\t    key.type == BTRFS_METADATA_ITEM_KEY) {\n\t\t\ttotal_found += add_new_free_space(block_group, last,\n\t\t\t\t\t\t\t  key.objectid);\n\t\t\tif (key.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\t\tlast = key.objectid +\n\t\t\t\t\tfs_info->nodesize;\n\t\t\telse\n\t\t\t\tlast = key.objectid + key.offset;\n\n\t\t\tif (total_found > CACHING_CTL_WAKE_UP) {\n\t\t\t\ttotal_found = 0;\n\t\t\t\tif (wakeup)\n\t\t\t\t\twake_up(&caching_ctl->wait);\n\t\t\t}\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\n\n\ttotal_found += add_new_free_space(block_group, last,\n\t\t\t\tblock_group->start + block_group->length);\n\tcaching_ctl->progress = (u64)-1;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic noinline void caching_thread(struct btrfs_work *work)\n{\n\tstruct btrfs_block_group *block_group;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_caching_control *caching_ctl;\n\tint ret;\n\n\tcaching_ctl = container_of(work, struct btrfs_caching_control, work);\n\tblock_group = caching_ctl->block_group;\n\tfs_info = block_group->fs_info;\n\n\tmutex_lock(&caching_ctl->mutex);\n\tdown_read(&fs_info->commit_root_sem);\n\n\tif (btrfs_test_opt(fs_info, SPACE_CACHE)) {\n\t\tret = load_free_space_cache(block_group);\n\t\tif (ret == 1) {\n\t\t\tret = 0;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/*\n\t\t * We failed to load the space cache, set ourselves to\n\t\t * CACHE_STARTED and carry on.\n\t\t */\n\t\tspin_lock(&block_group->lock);\n\t\tblock_group->cached = BTRFS_CACHE_STARTED;\n\t\tspin_unlock(&block_group->lock);\n\t\twake_up(&caching_ctl->wait);\n\t}\n\n\t/*\n\t * If we are in the transaction that populated the free space tree we\n\t * can't actually cache from the free space tree as our commit root and\n\t * real root are the same, so we could change the contents of the blocks\n\t * while caching.  Instead do the slow caching in this case, and after\n\t * the transaction has committed we will be safe.\n\t */\n\tif (btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE) &&\n\t    !(test_bit(BTRFS_FS_FREE_SPACE_TREE_UNTRUSTED, &fs_info->flags)))\n\t\tret = load_free_space_tree(caching_ctl);\n\telse\n\t\tret = load_extent_tree_free(caching_ctl);\ndone:\n\tspin_lock(&block_group->lock);\n\tblock_group->caching_ctl = NULL;\n\tblock_group->cached = ret ? BTRFS_CACHE_ERROR : BTRFS_CACHE_FINISHED;\n\tspin_unlock(&block_group->lock);\n\n#ifdef CONFIG_BTRFS_DEBUG\n\tif (btrfs_should_fragment_free_space(block_group)) {\n\t\tu64 bytes_used;\n\n\t\tspin_lock(&block_group->space_info->lock);\n\t\tspin_lock(&block_group->lock);\n\t\tbytes_used = block_group->length - block_group->used;\n\t\tblock_group->space_info->bytes_used += bytes_used >> 1;\n\t\tspin_unlock(&block_group->lock);\n\t\tspin_unlock(&block_group->space_info->lock);\n\t\tfragment_free_space(block_group);\n\t}\n#endif\n\n\tcaching_ctl->progress = (u64)-1;\n\n\tup_read(&fs_info->commit_root_sem);\n\tbtrfs_free_excluded_extents(block_group);\n\tmutex_unlock(&caching_ctl->mutex);\n\n\twake_up(&caching_ctl->wait);\n\n\tbtrfs_put_caching_control(caching_ctl);\n\tbtrfs_put_block_group(block_group);\n}\n\nint btrfs_cache_block_group(struct btrfs_block_group *cache, int load_cache_only)\n{\n\tDEFINE_WAIT(wait);\n\tstruct btrfs_fs_info *fs_info = cache->fs_info;\n\tstruct btrfs_caching_control *caching_ctl = NULL;\n\tint ret = 0;\n\n\t/* Allocator for zoned filesystems does not use the cache at all */\n\tif (btrfs_is_zoned(fs_info))\n\t\treturn 0;\n\n\tcaching_ctl = kzalloc(sizeof(*caching_ctl), GFP_NOFS);\n\tif (!caching_ctl)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&caching_ctl->list);\n\tmutex_init(&caching_ctl->mutex);\n\tinit_waitqueue_head(&caching_ctl->wait);\n\tcaching_ctl->block_group = cache;\n\tcaching_ctl->progress = cache->start;\n\trefcount_set(&caching_ctl->count, 2);\n\tbtrfs_init_work(&caching_ctl->work, caching_thread, NULL, NULL);\n\n\tspin_lock(&cache->lock);\n\tif (cache->cached != BTRFS_CACHE_NO) {\n\t\tkfree(caching_ctl);\n\n\t\tcaching_ctl = cache->caching_ctl;\n\t\tif (caching_ctl)\n\t\t\trefcount_inc(&caching_ctl->count);\n\t\tspin_unlock(&cache->lock);\n\t\tgoto out;\n\t}\n\tWARN_ON(cache->caching_ctl);\n\tcache->caching_ctl = caching_ctl;\n\tif (btrfs_test_opt(fs_info, SPACE_CACHE))\n\t\tcache->cached = BTRFS_CACHE_FAST;\n\telse\n\t\tcache->cached = BTRFS_CACHE_STARTED;\n\tcache->has_caching_ctl = 1;\n\tspin_unlock(&cache->lock);\n\n\tspin_lock(&fs_info->block_group_cache_lock);\n\trefcount_inc(&caching_ctl->count);\n\tlist_add_tail(&caching_ctl->list, &fs_info->caching_block_groups);\n\tspin_unlock(&fs_info->block_group_cache_lock);\n\n\tbtrfs_get_block_group(cache);\n\n\tbtrfs_queue_work(fs_info->caching_workers, &caching_ctl->work);\nout:\n\tif (load_cache_only && caching_ctl)\n\t\tbtrfs_wait_space_cache_v1_finished(cache, caching_ctl);\n\tif (caching_ctl)\n\t\tbtrfs_put_caching_control(caching_ctl);\n\n\treturn ret;\n}\n\nstatic void clear_avail_alloc_bits(struct btrfs_fs_info *fs_info, u64 flags)\n{\n\tu64 extra_flags = chunk_to_extended(flags) &\n\t\t\t\tBTRFS_EXTENDED_PROFILE_MASK;\n\n\twrite_seqlock(&fs_info->profiles_lock);\n\tif (flags & BTRFS_BLOCK_GROUP_DATA)\n\t\tfs_info->avail_data_alloc_bits &= ~extra_flags;\n\tif (flags & BTRFS_BLOCK_GROUP_METADATA)\n\t\tfs_info->avail_metadata_alloc_bits &= ~extra_flags;\n\tif (flags & BTRFS_BLOCK_GROUP_SYSTEM)\n\t\tfs_info->avail_system_alloc_bits &= ~extra_flags;\n\twrite_sequnlock(&fs_info->profiles_lock);\n}\n\n/*\n * Clear incompat bits for the following feature(s):\n *\n * - RAID56 - in case there's neither RAID5 nor RAID6 profile block group\n *            in the whole filesystem\n *\n * - RAID1C34 - same as above for RAID1C3 and RAID1C4 block groups\n */\nstatic void clear_incompat_bg_bits(struct btrfs_fs_info *fs_info, u64 flags)\n{\n\tbool found_raid56 = false;\n\tbool found_raid1c34 = false;\n\n\tif ((flags & BTRFS_BLOCK_GROUP_RAID56_MASK) ||\n\t    (flags & BTRFS_BLOCK_GROUP_RAID1C3) ||\n\t    (flags & BTRFS_BLOCK_GROUP_RAID1C4)) {\n\t\tstruct list_head *head = &fs_info->space_info;\n\t\tstruct btrfs_space_info *sinfo;\n\n\t\tlist_for_each_entry_rcu(sinfo, head, list) {\n\t\t\tdown_read(&sinfo->groups_sem);\n\t\t\tif (!list_empty(&sinfo->block_groups[BTRFS_RAID_RAID5]))\n\t\t\t\tfound_raid56 = true;\n\t\t\tif (!list_empty(&sinfo->block_groups[BTRFS_RAID_RAID6]))\n\t\t\t\tfound_raid56 = true;\n\t\t\tif (!list_empty(&sinfo->block_groups[BTRFS_RAID_RAID1C3]))\n\t\t\t\tfound_raid1c34 = true;\n\t\t\tif (!list_empty(&sinfo->block_groups[BTRFS_RAID_RAID1C4]))\n\t\t\t\tfound_raid1c34 = true;\n\t\t\tup_read(&sinfo->groups_sem);\n\t\t}\n\t\tif (!found_raid56)\n\t\t\tbtrfs_clear_fs_incompat(fs_info, RAID56);\n\t\tif (!found_raid1c34)\n\t\t\tbtrfs_clear_fs_incompat(fs_info, RAID1C34);\n\t}\n}\n\nstatic int remove_block_group_item(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct btrfs_block_group *block_group)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tint ret;\n\n\troot = fs_info->extent_root;\n\tkey.objectid = block_group->start;\n\tkey.type = BTRFS_BLOCK_GROUP_ITEM_KEY;\n\tkey.offset = block_group->length;\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret > 0)\n\t\tret = -ENOENT;\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = btrfs_del_item(trans, root, path);\n\treturn ret;\n}\n\nint btrfs_remove_block_group(struct btrfs_trans_handle *trans,\n\t\t\t     u64 group_start, struct extent_map *em)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_group *block_group;\n\tstruct btrfs_free_cluster *cluster;\n\tstruct inode *inode;\n\tstruct kobject *kobj = NULL;\n\tint ret;\n\tint index;\n\tint factor;\n\tstruct btrfs_caching_control *caching_ctl = NULL;\n\tbool remove_em;\n\tbool remove_rsv = false;\n\n\tblock_group = btrfs_lookup_block_group(fs_info, group_start);\n\tBUG_ON(!block_group);\n\tBUG_ON(!block_group->ro);\n\n\ttrace_btrfs_remove_block_group(block_group);\n\t/*\n\t * Free the reserved super bytes from this block group before\n\t * remove it.\n\t */\n\tbtrfs_free_excluded_extents(block_group);\n\tbtrfs_free_ref_tree_range(fs_info, block_group->start,\n\t\t\t\t  block_group->length);\n\n\tindex = btrfs_bg_flags_to_raid_index(block_group->flags);\n\tfactor = btrfs_bg_type_to_factor(block_group->flags);\n\n\t/* make sure this block group isn't part of an allocation cluster */\n\tcluster = &fs_info->data_alloc_cluster;\n\tspin_lock(&cluster->refill_lock);\n\tbtrfs_return_cluster_to_free_space(block_group, cluster);\n\tspin_unlock(&cluster->refill_lock);\n\n\t/*\n\t * make sure this block group isn't part of a metadata\n\t * allocation cluster\n\t */\n\tcluster = &fs_info->meta_alloc_cluster;\n\tspin_lock(&cluster->refill_lock);\n\tbtrfs_return_cluster_to_free_space(block_group, cluster);\n\tspin_unlock(&cluster->refill_lock);\n\n\tbtrfs_clear_treelog_bg(block_group);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * get the inode first so any iput calls done for the io_list\n\t * aren't the final iput (no unlinks allowed now)\n\t */\n\tinode = lookup_free_space_inode(block_group, path);\n\n\tmutex_lock(&trans->transaction->cache_write_mutex);\n\t/*\n\t * Make sure our free space cache IO is done before removing the\n\t * free space inode\n\t */\n\tspin_lock(&trans->transaction->dirty_bgs_lock);\n\tif (!list_empty(&block_group->io_list)) {\n\t\tlist_del_init(&block_group->io_list);\n\n\t\tWARN_ON(!IS_ERR(inode) && inode != block_group->io_ctl.inode);\n\n\t\tspin_unlock(&trans->transaction->dirty_bgs_lock);\n\t\tbtrfs_wait_cache_io(trans, block_group, path);\n\t\tbtrfs_put_block_group(block_group);\n\t\tspin_lock(&trans->transaction->dirty_bgs_lock);\n\t}\n\n\tif (!list_empty(&block_group->dirty_list)) {\n\t\tlist_del_init(&block_group->dirty_list);\n\t\tremove_rsv = true;\n\t\tbtrfs_put_block_group(block_group);\n\t}\n\tspin_unlock(&trans->transaction->dirty_bgs_lock);\n\tmutex_unlock(&trans->transaction->cache_write_mutex);\n\n\tret = btrfs_remove_free_space_inode(trans, inode, block_group);\n\tif (ret)\n\t\tgoto out;\n\n\tspin_lock(&fs_info->block_group_cache_lock);\n\trb_erase(&block_group->cache_node,\n\t\t &fs_info->block_group_cache_tree);\n\tRB_CLEAR_NODE(&block_group->cache_node);\n\n\t/* Once for the block groups rbtree */\n\tbtrfs_put_block_group(block_group);\n\n\tif (fs_info->first_logical_byte == block_group->start)\n\t\tfs_info->first_logical_byte = (u64)-1;\n\tspin_unlock(&fs_info->block_group_cache_lock);\n\n\tdown_write(&block_group->space_info->groups_sem);\n\t/*\n\t * we must use list_del_init so people can check to see if they\n\t * are still on the list after taking the semaphore\n\t */\n\tlist_del_init(&block_group->list);\n\tif (list_empty(&block_group->space_info->block_groups[index])) {\n\t\tkobj = block_group->space_info->block_group_kobjs[index];\n\t\tblock_group->space_info->block_group_kobjs[index] = NULL;\n\t\tclear_avail_alloc_bits(fs_info, block_group->flags);\n\t}\n\tup_write(&block_group->space_info->groups_sem);\n\tclear_incompat_bg_bits(fs_info, block_group->flags);\n\tif (kobj) {\n\t\tkobject_del(kobj);\n\t\tkobject_put(kobj);\n\t}\n\n\tif (block_group->has_caching_ctl)\n\t\tcaching_ctl = btrfs_get_caching_control(block_group);\n\tif (block_group->cached == BTRFS_CACHE_STARTED)\n\t\tbtrfs_wait_block_group_cache_done(block_group);\n\tif (block_group->has_caching_ctl) {\n\t\tspin_lock(&fs_info->block_group_cache_lock);\n\t\tif (!caching_ctl) {\n\t\t\tstruct btrfs_caching_control *ctl;\n\n\t\t\tlist_for_each_entry(ctl,\n\t\t\t\t    &fs_info->caching_block_groups, list)\n\t\t\t\tif (ctl->block_group == block_group) {\n\t\t\t\t\tcaching_ctl = ctl;\n\t\t\t\t\trefcount_inc(&caching_ctl->count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tif (caching_ctl)\n\t\t\tlist_del_init(&caching_ctl->list);\n\t\tspin_unlock(&fs_info->block_group_cache_lock);\n\t\tif (caching_ctl) {\n\t\t\t/* Once for the caching bgs list and once for us. */\n\t\t\tbtrfs_put_caching_control(caching_ctl);\n\t\t\tbtrfs_put_caching_control(caching_ctl);\n\t\t}\n\t}\n\n\tspin_lock(&trans->transaction->dirty_bgs_lock);\n\tWARN_ON(!list_empty(&block_group->dirty_list));\n\tWARN_ON(!list_empty(&block_group->io_list));\n\tspin_unlock(&trans->transaction->dirty_bgs_lock);\n\n\tbtrfs_remove_free_space_cache(block_group);\n\n\tspin_lock(&block_group->space_info->lock);\n\tlist_del_init(&block_group->ro_list);\n\n\tif (btrfs_test_opt(fs_info, ENOSPC_DEBUG)) {\n\t\tWARN_ON(block_group->space_info->total_bytes\n\t\t\t< block_group->length);\n\t\tWARN_ON(block_group->space_info->bytes_readonly\n\t\t\t< block_group->length - block_group->zone_unusable);\n\t\tWARN_ON(block_group->space_info->bytes_zone_unusable\n\t\t\t< block_group->zone_unusable);\n\t\tWARN_ON(block_group->space_info->disk_total\n\t\t\t< block_group->length * factor);\n\t}\n\tblock_group->space_info->total_bytes -= block_group->length;\n\tblock_group->space_info->bytes_readonly -=\n\t\t(block_group->length - block_group->zone_unusable);\n\tblock_group->space_info->bytes_zone_unusable -=\n\t\tblock_group->zone_unusable;\n\tblock_group->space_info->disk_total -= block_group->length * factor;\n\n\tspin_unlock(&block_group->space_info->lock);\n\n\t/*\n\t * Remove the free space for the block group from the free space tree\n\t * and the block group's item from the extent tree before marking the\n\t * block group as removed. This is to prevent races with tasks that\n\t * freeze and unfreeze a block group, this task and another task\n\t * allocating a new block group - the unfreeze task ends up removing\n\t * the block group's extent map before the task calling this function\n\t * deletes the block group item from the extent tree, allowing for\n\t * another task to attempt to create another block group with the same\n\t * item key (and failing with -EEXIST and a transaction abort).\n\t */\n\tret = remove_block_group_free_space(trans, block_group);\n\tif (ret)\n\t\tgoto out;\n\n\tret = remove_block_group_item(trans, path, block_group);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tspin_lock(&block_group->lock);\n\tblock_group->removed = 1;\n\t/*\n\t * At this point trimming or scrub can't start on this block group,\n\t * because we removed the block group from the rbtree\n\t * fs_info->block_group_cache_tree so no one can't find it anymore and\n\t * even if someone already got this block group before we removed it\n\t * from the rbtree, they have already incremented block_group->frozen -\n\t * if they didn't, for the trimming case they won't find any free space\n\t * entries because we already removed them all when we called\n\t * btrfs_remove_free_space_cache().\n\t *\n\t * And we must not remove the extent map from the fs_info->mapping_tree\n\t * to prevent the same logical address range and physical device space\n\t * ranges from being reused for a new block group. This is needed to\n\t * avoid races with trimming and scrub.\n\t *\n\t * An fs trim operation (btrfs_trim_fs() / btrfs_ioctl_fitrim()) is\n\t * completely transactionless, so while it is trimming a range the\n\t * currently running transaction might finish and a new one start,\n\t * allowing for new block groups to be created that can reuse the same\n\t * physical device locations unless we take this special care.\n\t *\n\t * There may also be an implicit trim operation if the file system\n\t * is mounted with -odiscard. The same protections must remain\n\t * in place until the extents have been discarded completely when\n\t * the transaction commit has completed.\n\t */\n\tremove_em = (atomic_read(&block_group->frozen) == 0);\n\tspin_unlock(&block_group->lock);\n\n\tif (remove_em) {\n\t\tstruct extent_map_tree *em_tree;\n\n\t\tem_tree = &fs_info->mapping_tree;\n\t\twrite_lock(&em_tree->lock);\n\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\t\t/* once for the tree */\n\t\tfree_extent_map(em);\n\t}\n\nout:\n\t/* Once for the lookup reference */\n\tbtrfs_put_block_group(block_group);\n\tif (remove_rsv)\n\t\tbtrfs_delayed_refs_rsv_release(fs_info, 1);\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstruct btrfs_trans_handle *btrfs_start_trans_remove_block_group(\n\t\tstruct btrfs_fs_info *fs_info, const u64 chunk_offset)\n{\n\tstruct extent_map_tree *em_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tunsigned int num_items;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, chunk_offset, 1);\n\tread_unlock(&em_tree->lock);\n\tASSERT(em && em->start == chunk_offset);\n\n\t/*\n\t * We need to reserve 3 + N units from the metadata space info in order\n\t * to remove a block group (done at btrfs_remove_chunk() and at\n\t * btrfs_remove_block_group()), which are used for:\n\t *\n\t * 1 unit for adding the free space inode's orphan (located in the tree\n\t * of tree roots).\n\t * 1 unit for deleting the block group item (located in the extent\n\t * tree).\n\t * 1 unit for deleting the free space item (located in tree of tree\n\t * roots).\n\t * N units for deleting N device extent items corresponding to each\n\t * stripe (located in the device tree).\n\t *\n\t * In order to remove a block group we also need to reserve units in the\n\t * system space info in order to update the chunk tree (update one or\n\t * more device items and remove one chunk item), but this is done at\n\t * btrfs_remove_chunk() through a call to check_system_chunk().\n\t */\n\tmap = em->map_lookup;\n\tnum_items = 3 + map->num_stripes;\n\tfree_extent_map(em);\n\n\treturn btrfs_start_transaction_fallback_global_rsv(fs_info->extent_root,\n\t\t\t\t\t\t\t   num_items);\n}\n\n/*\n * Mark block group @cache read-only, so later write won't happen to block\n * group @cache.\n *\n * If @force is not set, this function will only mark the block group readonly\n * if we have enough free space (1M) in other metadata/system block groups.\n * If @force is not set, this function will mark the block group readonly\n * without checking free space.\n *\n * NOTE: This function doesn't care if other block groups can contain all the\n * data in this block group. That check should be done by relocation routine,\n * not this function.\n */\nstatic int inc_block_group_ro(struct btrfs_block_group *cache, int force)\n{\n\tstruct btrfs_space_info *sinfo = cache->space_info;\n\tu64 num_bytes;\n\tint ret = -ENOSPC;\n\n\tspin_lock(&sinfo->lock);\n\tspin_lock(&cache->lock);\n\n\tif (cache->swap_extents) {\n\t\tret = -ETXTBSY;\n\t\tgoto out;\n\t}\n\n\tif (cache->ro) {\n\t\tcache->ro++;\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tnum_bytes = cache->length - cache->reserved - cache->pinned -\n\t\t    cache->bytes_super - cache->zone_unusable - cache->used;\n\n\t/*\n\t * Data never overcommits, even in mixed mode, so do just the straight\n\t * check of left over space in how much we have allocated.\n\t */\n\tif (force) {\n\t\tret = 0;\n\t} else if (sinfo->flags & BTRFS_BLOCK_GROUP_DATA) {\n\t\tu64 sinfo_used = btrfs_space_info_used(sinfo, true);\n\n\t\t/*\n\t\t * Here we make sure if we mark this bg RO, we still have enough\n\t\t * free space as buffer.\n\t\t */\n\t\tif (sinfo_used + num_bytes <= sinfo->total_bytes)\n\t\t\tret = 0;\n\t} else {\n\t\t/*\n\t\t * We overcommit metadata, so we need to do the\n\t\t * btrfs_can_overcommit check here, and we need to pass in\n\t\t * BTRFS_RESERVE_NO_FLUSH to give ourselves the most amount of\n\t\t * leeway to allow us to mark this block group as read only.\n\t\t */\n\t\tif (btrfs_can_overcommit(cache->fs_info, sinfo, num_bytes,\n\t\t\t\t\t BTRFS_RESERVE_NO_FLUSH))\n\t\t\tret = 0;\n\t}\n\n\tif (!ret) {\n\t\tsinfo->bytes_readonly += num_bytes;\n\t\tif (btrfs_is_zoned(cache->fs_info)) {\n\t\t\t/* Migrate zone_unusable bytes to readonly */\n\t\t\tsinfo->bytes_readonly += cache->zone_unusable;\n\t\t\tsinfo->bytes_zone_unusable -= cache->zone_unusable;\n\t\t\tcache->zone_unusable = 0;\n\t\t}\n\t\tcache->ro++;\n\t\tlist_add_tail(&cache->ro_list, &sinfo->ro_bgs);\n\t}\nout:\n\tspin_unlock(&cache->lock);\n\tspin_unlock(&sinfo->lock);\n\tif (ret == -ENOSPC && btrfs_test_opt(cache->fs_info, ENOSPC_DEBUG)) {\n\t\tbtrfs_info(cache->fs_info,\n\t\t\t\"unable to make block group %llu ro\", cache->start);\n\t\tbtrfs_dump_space_info(cache->fs_info, cache->space_info, 0, 0);\n\t}\n\treturn ret;\n}\n\nstatic bool clean_pinned_extents(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_block_group *bg)\n{\n\tstruct btrfs_fs_info *fs_info = bg->fs_info;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tconst u64 start = bg->start;\n\tconst u64 end = start + bg->length - 1;\n\tint ret;\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (trans->transaction->list.prev != &fs_info->trans_list) {\n\t\tprev_trans = list_last_entry(&trans->transaction->list,\n\t\t\t\t\t     struct btrfs_transaction, list);\n\t\trefcount_inc(&prev_trans->use_count);\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n\n\t/*\n\t * Hold the unused_bg_unpin_mutex lock to avoid racing with\n\t * btrfs_finish_extent_commit(). If we are at transaction N, another\n\t * task might be running finish_extent_commit() for the previous\n\t * transaction N - 1, and have seen a range belonging to the block\n\t * group in pinned_extents before we were able to clear the whole block\n\t * group range from pinned_extents. This means that task can lookup for\n\t * the block group after we unpinned it from pinned_extents and removed\n\t * it, leading to a BUG_ON() at unpin_extent_range().\n\t */\n\tmutex_lock(&fs_info->unused_bg_unpin_mutex);\n\tif (prev_trans) {\n\t\tret = clear_extent_bits(&prev_trans->pinned_extents, start, end,\n\t\t\t\t\tEXTENT_DIRTY);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = clear_extent_bits(&trans->transaction->pinned_extents, start, end,\n\t\t\t\tEXTENT_DIRTY);\nout:\n\tmutex_unlock(&fs_info->unused_bg_unpin_mutex);\n\tif (prev_trans)\n\t\tbtrfs_put_transaction(prev_trans);\n\n\treturn ret == 0;\n}\n\n/*\n * Process the unused_bgs list and remove any that don't have any allocated\n * space inside of them.\n */\nvoid btrfs_delete_unused_bgs(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_block_group *block_group;\n\tstruct btrfs_space_info *space_info;\n\tstruct btrfs_trans_handle *trans;\n\tconst bool async_trim_enabled = btrfs_test_opt(fs_info, DISCARD_ASYNC);\n\tint ret = 0;\n\n\tif (!test_bit(BTRFS_FS_OPEN, &fs_info->flags))\n\t\treturn;\n\n\t/*\n\t * Long running balances can keep us blocked here for eternity, so\n\t * simply skip deletion if we're unable to get the mutex.\n\t */\n\tif (!mutex_trylock(&fs_info->reclaim_bgs_lock))\n\t\treturn;\n\n\tspin_lock(&fs_info->unused_bgs_lock);\n\twhile (!list_empty(&fs_info->unused_bgs)) {\n\t\tint trimming;\n\n\t\tblock_group = list_first_entry(&fs_info->unused_bgs,\n\t\t\t\t\t       struct btrfs_block_group,\n\t\t\t\t\t       bg_list);\n\t\tlist_del_init(&block_group->bg_list);\n\n\t\tspace_info = block_group->space_info;\n\n\t\tif (ret || btrfs_mixed_space_info(space_info)) {\n\t\t\tbtrfs_put_block_group(block_group);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&fs_info->unused_bgs_lock);\n\n\t\tbtrfs_discard_cancel_work(&fs_info->discard_ctl, block_group);\n\n\t\t/* Don't want to race with allocators so take the groups_sem */\n\t\tdown_write(&space_info->groups_sem);\n\n\t\t/*\n\t\t * Async discard moves the final block group discard to be prior\n\t\t * to the unused_bgs code path.  Therefore, if it's not fully\n\t\t * trimmed, punt it back to the async discard lists.\n\t\t */\n\t\tif (btrfs_test_opt(fs_info, DISCARD_ASYNC) &&\n\t\t    !btrfs_is_free_space_trimmed(block_group)) {\n\t\t\ttrace_btrfs_skip_unused_block_group(block_group);\n\t\t\tup_write(&space_info->groups_sem);\n\t\t\t/* Requeue if we failed because of async discard */\n\t\t\tbtrfs_discard_queue_work(&fs_info->discard_ctl,\n\t\t\t\t\t\t block_group);\n\t\t\tgoto next;\n\t\t}\n\n\t\tspin_lock(&block_group->lock);\n\t\tif (block_group->reserved || block_group->pinned ||\n\t\t    block_group->used || block_group->ro ||\n\t\t    list_is_singular(&block_group->list)) {\n\t\t\t/*\n\t\t\t * We want to bail if we made new allocations or have\n\t\t\t * outstanding allocations in this block group.  We do\n\t\t\t * the ro check in case balance is currently acting on\n\t\t\t * this block group.\n\t\t\t */\n\t\t\ttrace_btrfs_skip_unused_block_group(block_group);\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tup_write(&space_info->groups_sem);\n\t\t\tgoto next;\n\t\t}\n\t\tspin_unlock(&block_group->lock);\n\n\t\t/* We don't want to force the issue, only flip if it's ok. */\n\t\tret = inc_block_group_ro(block_group, 0);\n\t\tup_write(&space_info->groups_sem);\n\t\tif (ret < 0) {\n\t\t\tret = 0;\n\t\t\tgoto next;\n\t\t}\n\n\t\t/*\n\t\t * Want to do this before we do anything else so we can recover\n\t\t * properly if we fail to join the transaction.\n\t\t */\n\t\ttrans = btrfs_start_trans_remove_block_group(fs_info,\n\t\t\t\t\t\t     block_group->start);\n\t\tif (IS_ERR(trans)) {\n\t\t\tbtrfs_dec_block_group_ro(block_group);\n\t\t\tret = PTR_ERR(trans);\n\t\t\tgoto next;\n\t\t}\n\n\t\t/*\n\t\t * We could have pending pinned extents for this block group,\n\t\t * just delete them, we don't care about them anymore.\n\t\t */\n\t\tif (!clean_pinned_extents(trans, block_group)) {\n\t\t\tbtrfs_dec_block_group_ro(block_group);\n\t\t\tgoto end_trans;\n\t\t}\n\n\t\t/*\n\t\t * At this point, the block_group is read only and should fail\n\t\t * new allocations.  However, btrfs_finish_extent_commit() can\n\t\t * cause this block_group to be placed back on the discard\n\t\t * lists because now the block_group isn't fully discarded.\n\t\t * Bail here and try again later after discarding everything.\n\t\t */\n\t\tspin_lock(&fs_info->discard_ctl.lock);\n\t\tif (!list_empty(&block_group->discard_list)) {\n\t\t\tspin_unlock(&fs_info->discard_ctl.lock);\n\t\t\tbtrfs_dec_block_group_ro(block_group);\n\t\t\tbtrfs_discard_queue_work(&fs_info->discard_ctl,\n\t\t\t\t\t\t block_group);\n\t\t\tgoto end_trans;\n\t\t}\n\t\tspin_unlock(&fs_info->discard_ctl.lock);\n\n\t\t/* Reset pinned so btrfs_put_block_group doesn't complain */\n\t\tspin_lock(&space_info->lock);\n\t\tspin_lock(&block_group->lock);\n\n\t\tbtrfs_space_info_update_bytes_pinned(fs_info, space_info,\n\t\t\t\t\t\t     -block_group->pinned);\n\t\tspace_info->bytes_readonly += block_group->pinned;\n\t\tblock_group->pinned = 0;\n\n\t\tspin_unlock(&block_group->lock);\n\t\tspin_unlock(&space_info->lock);\n\n\t\t/*\n\t\t * The normal path here is an unused block group is passed here,\n\t\t * then trimming is handled in the transaction commit path.\n\t\t * Async discard interposes before this to do the trimming\n\t\t * before coming down the unused block group path as trimming\n\t\t * will no longer be done later in the transaction commit path.\n\t\t */\n\t\tif (!async_trim_enabled && btrfs_test_opt(fs_info, DISCARD_ASYNC))\n\t\t\tgoto flip_async;\n\n\t\t/*\n\t\t * DISCARD can flip during remount. On zoned filesystems, we\n\t\t * need to reset sequential-required zones.\n\t\t */\n\t\ttrimming = btrfs_test_opt(fs_info, DISCARD_SYNC) ||\n\t\t\t\tbtrfs_is_zoned(fs_info);\n\n\t\t/* Implicit trim during transaction commit. */\n\t\tif (trimming)\n\t\t\tbtrfs_freeze_block_group(block_group);\n\n\t\t/*\n\t\t * Btrfs_remove_chunk will abort the transaction if things go\n\t\t * horribly wrong.\n\t\t */\n\t\tret = btrfs_remove_chunk(trans, block_group->start);\n\n\t\tif (ret) {\n\t\t\tif (trimming)\n\t\t\t\tbtrfs_unfreeze_block_group(block_group);\n\t\t\tgoto end_trans;\n\t\t}\n\n\t\t/*\n\t\t * If we're not mounted with -odiscard, we can just forget\n\t\t * about this block group. Otherwise we'll need to wait\n\t\t * until transaction commit to do the actual discard.\n\t\t */\n\t\tif (trimming) {\n\t\t\tspin_lock(&fs_info->unused_bgs_lock);\n\t\t\t/*\n\t\t\t * A concurrent scrub might have added us to the list\n\t\t\t * fs_info->unused_bgs, so use a list_move operation\n\t\t\t * to add the block group to the deleted_bgs list.\n\t\t\t */\n\t\t\tlist_move(&block_group->bg_list,\n\t\t\t\t  &trans->transaction->deleted_bgs);\n\t\t\tspin_unlock(&fs_info->unused_bgs_lock);\n\t\t\tbtrfs_get_block_group(block_group);\n\t\t}\nend_trans:\n\t\tbtrfs_end_transaction(trans);\nnext:\n\t\tbtrfs_put_block_group(block_group);\n\t\tspin_lock(&fs_info->unused_bgs_lock);\n\t}\n\tspin_unlock(&fs_info->unused_bgs_lock);\n\tmutex_unlock(&fs_info->reclaim_bgs_lock);\n\treturn;\n\nflip_async:\n\tbtrfs_end_transaction(trans);\n\tmutex_unlock(&fs_info->reclaim_bgs_lock);\n\tbtrfs_put_block_group(block_group);\n\tbtrfs_discard_punt_unused_bgs_list(fs_info);\n}\n\nvoid btrfs_mark_bg_unused(struct btrfs_block_group *bg)\n{\n\tstruct btrfs_fs_info *fs_info = bg->fs_info;\n\n\tspin_lock(&fs_info->unused_bgs_lock);\n\tif (list_empty(&bg->bg_list)) {\n\t\tbtrfs_get_block_group(bg);\n\t\ttrace_btrfs_add_unused_block_group(bg);\n\t\tlist_add_tail(&bg->bg_list, &fs_info->unused_bgs);\n\t}\n\tspin_unlock(&fs_info->unused_bgs_lock);\n}\n\nvoid btrfs_reclaim_bgs_work(struct work_struct *work)\n{\n\tstruct btrfs_fs_info *fs_info =\n\t\tcontainer_of(work, struct btrfs_fs_info, reclaim_bgs_work);\n\tstruct btrfs_block_group *bg;\n\tstruct btrfs_space_info *space_info;\n\tLIST_HEAD(again_list);\n\n\tif (!test_bit(BTRFS_FS_OPEN, &fs_info->flags))\n\t\treturn;\n\n\tif (!btrfs_exclop_start(fs_info, BTRFS_EXCLOP_BALANCE))\n\t\treturn;\n\n\tmutex_lock(&fs_info->reclaim_bgs_lock);\n\tspin_lock(&fs_info->unused_bgs_lock);\n\twhile (!list_empty(&fs_info->reclaim_bgs)) {\n\t\tu64 zone_unusable;\n\t\tint ret = 0;\n\n\t\tbg = list_first_entry(&fs_info->reclaim_bgs,\n\t\t\t\t      struct btrfs_block_group,\n\t\t\t\t      bg_list);\n\t\tlist_del_init(&bg->bg_list);\n\n\t\tspace_info = bg->space_info;\n\t\tspin_unlock(&fs_info->unused_bgs_lock);\n\n\t\t/* Don't race with allocators so take the groups_sem */\n\t\tdown_write(&space_info->groups_sem);\n\n\t\tspin_lock(&bg->lock);\n\t\tif (bg->reserved || bg->pinned || bg->ro) {\n\t\t\t/*\n\t\t\t * We want to bail if we made new allocations or have\n\t\t\t * outstanding allocations in this block group.  We do\n\t\t\t * the ro check in case balance is currently acting on\n\t\t\t * this block group.\n\t\t\t */\n\t\t\tspin_unlock(&bg->lock);\n\t\t\tup_write(&space_info->groups_sem);\n\t\t\tgoto next;\n\t\t}\n\t\tspin_unlock(&bg->lock);\n\n\t\t/* Get out fast, in case we're unmounting the filesystem */\n\t\tif (btrfs_fs_closing(fs_info)) {\n\t\t\tup_write(&space_info->groups_sem);\n\t\t\tgoto next;\n\t\t}\n\n\t\t/*\n\t\t * Cache the zone_unusable value before turning the block group\n\t\t * to read only. As soon as the blog group is read only it's\n\t\t * zone_unusable value gets moved to the block group's read-only\n\t\t * bytes and isn't available for calculations anymore.\n\t\t */\n\t\tzone_unusable = bg->zone_unusable;\n\t\tret = inc_block_group_ro(bg, 0);\n\t\tup_write(&space_info->groups_sem);\n\t\tif (ret < 0)\n\t\t\tgoto next;\n\n\t\tbtrfs_info(fs_info,\n\t\t\t\"reclaiming chunk %llu with %llu%% used %llu%% unusable\",\n\t\t\t\tbg->start, div_u64(bg->used * 100, bg->length),\n\t\t\t\tdiv64_u64(zone_unusable * 100, bg->length));\n\t\ttrace_btrfs_reclaim_block_group(bg);\n\t\tret = btrfs_relocate_chunk(fs_info, bg->start);\n\t\tif (ret)\n\t\t\tbtrfs_err(fs_info, \"error relocating chunk %llu\",\n\t\t\t\t  bg->start);\n\nnext:\n\t\tspin_lock(&fs_info->unused_bgs_lock);\n\t\tif (ret == -EAGAIN && list_empty(&bg->bg_list))\n\t\t\tlist_add_tail(&bg->bg_list, &again_list);\n\t\telse\n\t\t\tbtrfs_put_block_group(bg);\n\t}\n\tlist_splice_tail(&again_list, &fs_info->reclaim_bgs);\n\tspin_unlock(&fs_info->unused_bgs_lock);\n\tmutex_unlock(&fs_info->reclaim_bgs_lock);\n\tbtrfs_exclop_finish(fs_info);\n}\n\nvoid btrfs_reclaim_bgs(struct btrfs_fs_info *fs_info)\n{\n\tspin_lock(&fs_info->unused_bgs_lock);\n\tif (!list_empty(&fs_info->reclaim_bgs))\n\t\tqueue_work(system_unbound_wq, &fs_info->reclaim_bgs_work);\n\tspin_unlock(&fs_info->unused_bgs_lock);\n}\n\nvoid btrfs_mark_bg_to_reclaim(struct btrfs_block_group *bg)\n{\n\tstruct btrfs_fs_info *fs_info = bg->fs_info;\n\n\tspin_lock(&fs_info->unused_bgs_lock);\n\tif (list_empty(&bg->bg_list)) {\n\t\tbtrfs_get_block_group(bg);\n\t\ttrace_btrfs_add_reclaim_block_group(bg);\n\t\tlist_add_tail(&bg->bg_list, &fs_info->reclaim_bgs);\n\t}\n\tspin_unlock(&fs_info->unused_bgs_lock);\n}\n\nstatic int read_bg_from_eb(struct btrfs_fs_info *fs_info, struct btrfs_key *key,\n\t\t\t   struct btrfs_path *path)\n{\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tstruct btrfs_block_group_item bg;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tu64 flags;\n\tint ret = 0;\n\n\tslot = path->slots[0];\n\tleaf = path->nodes[0];\n\n\tem_tree = &fs_info->mapping_tree;\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, key->objectid, key->offset);\n\tread_unlock(&em_tree->lock);\n\tif (!em) {\n\t\tbtrfs_err(fs_info,\n\t\t\t  \"logical %llu len %llu found bg but no related chunk\",\n\t\t\t  key->objectid, key->offset);\n\t\treturn -ENOENT;\n\t}\n\n\tif (em->start != key->objectid || em->len != key->offset) {\n\t\tbtrfs_err(fs_info,\n\t\t\t\"block group %llu len %llu mismatch with chunk %llu len %llu\",\n\t\t\tkey->objectid, key->offset, em->start, em->len);\n\t\tret = -EUCLEAN;\n\t\tgoto out_free_em;\n\t}\n\n\tread_extent_buffer(leaf, &bg, btrfs_item_ptr_offset(leaf, slot),\n\t\t\t   sizeof(bg));\n\tflags = btrfs_stack_block_group_flags(&bg) &\n\t\tBTRFS_BLOCK_GROUP_TYPE_MASK;\n\n\tif (flags != (em->map_lookup->type & BTRFS_BLOCK_GROUP_TYPE_MASK)) {\n\t\tbtrfs_err(fs_info,\n\"block group %llu len %llu type flags 0x%llx mismatch with chunk type flags 0x%llx\",\n\t\t\t  key->objectid, key->offset, flags,\n\t\t\t  (BTRFS_BLOCK_GROUP_TYPE_MASK & em->map_lookup->type));\n\t\tret = -EUCLEAN;\n\t}\n\nout_free_em:\n\tfree_extent_map(em);\n\treturn ret;\n}\n\nstatic int find_first_block_group(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct btrfs_key *key)\n{\n\tstruct btrfs_root *root = fs_info->extent_root;\n\tint ret;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\n\tret = btrfs_search_slot(NULL, root, key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twhile (1) {\n\t\tslot = path->slots[0];\n\t\tleaf = path->nodes[0];\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\tif (found_key.objectid >= key->objectid &&\n\t\t    found_key.type == BTRFS_BLOCK_GROUP_ITEM_KEY) {\n\t\t\tret = read_bg_from_eb(fs_info, &found_key, path);\n\t\t\tbreak;\n\t\t}\n\n\t\tpath->slots[0]++;\n\t}\nout:\n\treturn ret;\n}\n\nstatic void set_avail_alloc_bits(struct btrfs_fs_info *fs_info, u64 flags)\n{\n\tu64 extra_flags = chunk_to_extended(flags) &\n\t\t\t\tBTRFS_EXTENDED_PROFILE_MASK;\n\n\twrite_seqlock(&fs_info->profiles_lock);\n\tif (flags & BTRFS_BLOCK_GROUP_DATA)\n\t\tfs_info->avail_data_alloc_bits |= extra_flags;\n\tif (flags & BTRFS_BLOCK_GROUP_METADATA)\n\t\tfs_info->avail_metadata_alloc_bits |= extra_flags;\n\tif (flags & BTRFS_BLOCK_GROUP_SYSTEM)\n\t\tfs_info->avail_system_alloc_bits |= extra_flags;\n\twrite_sequnlock(&fs_info->profiles_lock);\n}\n\n/**\n * Map a physical disk address to a list of logical addresses\n *\n * @fs_info:       the filesystem\n * @chunk_start:   logical address of block group\n * @bdev:\t   physical device to resolve, can be NULL to indicate any device\n * @physical:\t   physical address to map to logical addresses\n * @logical:\t   return array of logical addresses which map to @physical\n * @naddrs:\t   length of @logical\n * @stripe_len:    size of IO stripe for the given block group\n *\n * Maps a particular @physical disk address to a list of @logical addresses.\n * Used primarily to exclude those portions of a block group that contain super\n * block copies.\n */\nint btrfs_rmap_block(struct btrfs_fs_info *fs_info, u64 chunk_start,\n\t\t     struct block_device *bdev, u64 physical, u64 **logical,\n\t\t     int *naddrs, int *stripe_len)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tu64 *buf;\n\tu64 bytenr;\n\tu64 data_stripe_length;\n\tu64 io_stripe_size;\n\tint i, nr = 0;\n\tint ret = 0;\n\n\tem = btrfs_get_chunk_map(fs_info, chunk_start, 1);\n\tif (IS_ERR(em))\n\t\treturn -EIO;\n\n\tmap = em->map_lookup;\n\tdata_stripe_length = em->orig_block_len;\n\tio_stripe_size = map->stripe_len;\n\tchunk_start = em->start;\n\n\t/* For RAID5/6 adjust to a full IO stripe length */\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK)\n\t\tio_stripe_size = map->stripe_len * nr_data_stripes(map);\n\n\tbuf = kcalloc(map->num_stripes, sizeof(u64), GFP_NOFS);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tbool already_inserted = false;\n\t\tu64 stripe_nr;\n\t\tu64 offset;\n\t\tint j;\n\n\t\tif (!in_range(physical, map->stripes[i].physical,\n\t\t\t      data_stripe_length))\n\t\t\tcontinue;\n\n\t\tif (bdev && map->stripes[i].dev->bdev != bdev)\n\t\t\tcontinue;\n\n\t\tstripe_nr = physical - map->stripes[i].physical;\n\t\tstripe_nr = div64_u64_rem(stripe_nr, map->stripe_len, &offset);\n\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID10) {\n\t\t\tstripe_nr = stripe_nr * map->num_stripes + i;\n\t\t\tstripe_nr = div_u64(stripe_nr, map->sub_stripes);\n\t\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID0) {\n\t\t\tstripe_nr = stripe_nr * map->num_stripes + i;\n\t\t}\n\t\t/*\n\t\t * The remaining case would be for RAID56, multiply by\n\t\t * nr_data_stripes().  Alternatively, just use rmap_len below\n\t\t * instead of map->stripe_len\n\t\t */\n\n\t\tbytenr = chunk_start + stripe_nr * io_stripe_size + offset;\n\n\t\t/* Ensure we don't add duplicate addresses */\n\t\tfor (j = 0; j < nr; j++) {\n\t\t\tif (buf[j] == bytenr) {\n\t\t\t\talready_inserted = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!already_inserted)\n\t\t\tbuf[nr++] = bytenr;\n\t}\n\n\t*logical = buf;\n\t*naddrs = nr;\n\t*stripe_len = io_stripe_size;\nout:\n\tfree_extent_map(em);\n\treturn ret;\n}\n\nstatic int exclude_super_stripes(struct btrfs_block_group *cache)\n{\n\tstruct btrfs_fs_info *fs_info = cache->fs_info;\n\tconst bool zoned = btrfs_is_zoned(fs_info);\n\tu64 bytenr;\n\tu64 *logical;\n\tint stripe_len;\n\tint i, nr, ret;\n\n\tif (cache->start < BTRFS_SUPER_INFO_OFFSET) {\n\t\tstripe_len = BTRFS_SUPER_INFO_OFFSET - cache->start;\n\t\tcache->bytes_super += stripe_len;\n\t\tret = btrfs_add_excluded_extent(fs_info, cache->start,\n\t\t\t\t\t\tstripe_len);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < BTRFS_SUPER_MIRROR_MAX; i++) {\n\t\tbytenr = btrfs_sb_offset(i);\n\t\tret = btrfs_rmap_block(fs_info, cache->start, NULL,\n\t\t\t\t       bytenr, &logical, &nr, &stripe_len);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* Shouldn't have super stripes in sequential zones */\n\t\tif (zoned && nr) {\n\t\t\tbtrfs_err(fs_info,\n\t\t\t\"zoned: block group %llu must not contain super block\",\n\t\t\t\t  cache->start);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\twhile (nr--) {\n\t\t\tu64 len = min_t(u64, stripe_len,\n\t\t\t\tcache->start + cache->length - logical[nr]);\n\n\t\t\tcache->bytes_super += len;\n\t\t\tret = btrfs_add_excluded_extent(fs_info, logical[nr],\n\t\t\t\t\t\t\tlen);\n\t\t\tif (ret) {\n\t\t\t\tkfree(logical);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tkfree(logical);\n\t}\n\treturn 0;\n}\n\nstatic void link_block_group(struct btrfs_block_group *cache)\n{\n\tstruct btrfs_space_info *space_info = cache->space_info;\n\tint index = btrfs_bg_flags_to_raid_index(cache->flags);\n\n\tdown_write(&space_info->groups_sem);\n\tlist_add_tail(&cache->list, &space_info->block_groups[index]);\n\tup_write(&space_info->groups_sem);\n}\n\nstatic struct btrfs_block_group *btrfs_create_block_group_cache(\n\t\tstruct btrfs_fs_info *fs_info, u64 start)\n{\n\tstruct btrfs_block_group *cache;\n\n\tcache = kzalloc(sizeof(*cache), GFP_NOFS);\n\tif (!cache)\n\t\treturn NULL;\n\n\tcache->free_space_ctl = kzalloc(sizeof(*cache->free_space_ctl),\n\t\t\t\t\tGFP_NOFS);\n\tif (!cache->free_space_ctl) {\n\t\tkfree(cache);\n\t\treturn NULL;\n\t}\n\n\tcache->start = start;\n\n\tcache->fs_info = fs_info;\n\tcache->full_stripe_len = btrfs_full_stripe_len(fs_info, start);\n\n\tcache->discard_index = BTRFS_DISCARD_INDEX_UNUSED;\n\n\trefcount_set(&cache->refs, 1);\n\tspin_lock_init(&cache->lock);\n\tinit_rwsem(&cache->data_rwsem);\n\tINIT_LIST_HEAD(&cache->list);\n\tINIT_LIST_HEAD(&cache->cluster_list);\n\tINIT_LIST_HEAD(&cache->bg_list);\n\tINIT_LIST_HEAD(&cache->ro_list);\n\tINIT_LIST_HEAD(&cache->discard_list);\n\tINIT_LIST_HEAD(&cache->dirty_list);\n\tINIT_LIST_HEAD(&cache->io_list);\n\tbtrfs_init_free_space_ctl(cache, cache->free_space_ctl);\n\tatomic_set(&cache->frozen, 0);\n\tmutex_init(&cache->free_space_lock);\n\tbtrfs_init_full_stripe_locks_tree(&cache->full_stripe_locks_root);\n\n\treturn cache;\n}\n\n/*\n * Iterate all chunks and verify that each of them has the corresponding block\n * group\n */\nstatic int check_chunk_block_group_mappings(struct btrfs_fs_info *fs_info)\n{\n\tstruct extent_map_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct btrfs_block_group *bg;\n\tu64 start = 0;\n\tint ret = 0;\n\n\twhile (1) {\n\t\tread_lock(&map_tree->lock);\n\t\t/*\n\t\t * lookup_extent_mapping will return the first extent map\n\t\t * intersecting the range, so setting @len to 1 is enough to\n\t\t * get the first chunk.\n\t\t */\n\t\tem = lookup_extent_mapping(map_tree, start, 1);\n\t\tread_unlock(&map_tree->lock);\n\t\tif (!em)\n\t\t\tbreak;\n\n\t\tbg = btrfs_lookup_block_group(fs_info, em->start);\n\t\tif (!bg) {\n\t\t\tbtrfs_err(fs_info,\n\t\"chunk start=%llu len=%llu doesn't have corresponding block group\",\n\t\t\t\t     em->start, em->len);\n\t\t\tret = -EUCLEAN;\n\t\t\tfree_extent_map(em);\n\t\t\tbreak;\n\t\t}\n\t\tif (bg->start != em->start || bg->length != em->len ||\n\t\t    (bg->flags & BTRFS_BLOCK_GROUP_TYPE_MASK) !=\n\t\t    (em->map_lookup->type & BTRFS_BLOCK_GROUP_TYPE_MASK)) {\n\t\t\tbtrfs_err(fs_info,\n\"chunk start=%llu len=%llu flags=0x%llx doesn't match block group start=%llu len=%llu flags=0x%llx\",\n\t\t\t\tem->start, em->len,\n\t\t\t\tem->map_lookup->type & BTRFS_BLOCK_GROUP_TYPE_MASK,\n\t\t\t\tbg->start, bg->length,\n\t\t\t\tbg->flags & BTRFS_BLOCK_GROUP_TYPE_MASK);\n\t\t\tret = -EUCLEAN;\n\t\t\tfree_extent_map(em);\n\t\t\tbtrfs_put_block_group(bg);\n\t\t\tbreak;\n\t\t}\n\t\tstart = em->start + em->len;\n\t\tfree_extent_map(em);\n\t\tbtrfs_put_block_group(bg);\n\t}\n\treturn ret;\n}\n\nstatic int read_one_block_group(struct btrfs_fs_info *info,\n\t\t\t\tstruct btrfs_block_group_item *bgi,\n\t\t\t\tconst struct btrfs_key *key,\n\t\t\t\tint need_clear)\n{\n\tstruct btrfs_block_group *cache;\n\tstruct btrfs_space_info *space_info;\n\tconst bool mixed = btrfs_fs_incompat(info, MIXED_GROUPS);\n\tint ret;\n\n\tASSERT(key->type == BTRFS_BLOCK_GROUP_ITEM_KEY);\n\n\tcache = btrfs_create_block_group_cache(info, key->objectid);\n\tif (!cache)\n\t\treturn -ENOMEM;\n\n\tcache->length = key->offset;\n\tcache->used = btrfs_stack_block_group_used(bgi);\n\tcache->flags = btrfs_stack_block_group_flags(bgi);\n\n\tset_free_space_tree_thresholds(cache);\n\n\tif (need_clear) {\n\t\t/*\n\t\t * When we mount with old space cache, we need to\n\t\t * set BTRFS_DC_CLEAR and set dirty flag.\n\t\t *\n\t\t * a) Setting 'BTRFS_DC_CLEAR' makes sure that we\n\t\t *    truncate the old free space cache inode and\n\t\t *    setup a new one.\n\t\t * b) Setting 'dirty flag' makes sure that we flush\n\t\t *    the new space cache info onto disk.\n\t\t */\n\t\tif (btrfs_test_opt(info, SPACE_CACHE))\n\t\t\tcache->disk_cache_state = BTRFS_DC_CLEAR;\n\t}\n\tif (!mixed && ((cache->flags & BTRFS_BLOCK_GROUP_METADATA) &&\n\t    (cache->flags & BTRFS_BLOCK_GROUP_DATA))) {\n\t\t\tbtrfs_err(info,\n\"bg %llu is a mixed block group but filesystem hasn't enabled mixed block groups\",\n\t\t\t\t  cache->start);\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t}\n\n\tret = btrfs_load_block_group_zone_info(cache, false);\n\tif (ret) {\n\t\tbtrfs_err(info, \"zoned: failed to load zone info of bg %llu\",\n\t\t\t  cache->start);\n\t\tgoto error;\n\t}\n\n\t/*\n\t * We need to exclude the super stripes now so that the space info has\n\t * super bytes accounted for, otherwise we'll think we have more space\n\t * than we actually do.\n\t */\n\tret = exclude_super_stripes(cache);\n\tif (ret) {\n\t\t/* We may have excluded something, so call this just in case. */\n\t\tbtrfs_free_excluded_extents(cache);\n\t\tgoto error;\n\t}\n\n\t/*\n\t * For zoned filesystem, space after the allocation offset is the only\n\t * free space for a block group. So, we don't need any caching work.\n\t * btrfs_calc_zone_unusable() will set the amount of free space and\n\t * zone_unusable space.\n\t *\n\t * For regular filesystem, check for two cases, either we are full, and\n\t * therefore don't need to bother with the caching work since we won't\n\t * find any space, or we are empty, and we can just add all the space\n\t * in and be done with it.  This saves us _a_lot_ of time, particularly\n\t * in the full case.\n\t */\n\tif (btrfs_is_zoned(info)) {\n\t\tbtrfs_calc_zone_unusable(cache);\n\t} else if (cache->length == cache->used) {\n\t\tcache->last_byte_to_unpin = (u64)-1;\n\t\tcache->cached = BTRFS_CACHE_FINISHED;\n\t\tbtrfs_free_excluded_extents(cache);\n\t} else if (cache->used == 0) {\n\t\tcache->last_byte_to_unpin = (u64)-1;\n\t\tcache->cached = BTRFS_CACHE_FINISHED;\n\t\tadd_new_free_space(cache, cache->start,\n\t\t\t\t   cache->start + cache->length);\n\t\tbtrfs_free_excluded_extents(cache);\n\t}\n\n\tret = btrfs_add_block_group_cache(info, cache);\n\tif (ret) {\n\t\tbtrfs_remove_free_space_cache(cache);\n\t\tgoto error;\n\t}\n\ttrace_btrfs_add_block_group(info, cache, 0);\n\tbtrfs_update_space_info(info, cache->flags, cache->length,\n\t\t\t\tcache->used, cache->bytes_super,\n\t\t\t\tcache->zone_unusable, &space_info);\n\n\tcache->space_info = space_info;\n\n\tlink_block_group(cache);\n\n\tset_avail_alloc_bits(info, cache->flags);\n\tif (btrfs_chunk_readonly(info, cache->start)) {\n\t\tinc_block_group_ro(cache, 1);\n\t} else if (cache->used == 0) {\n\t\tASSERT(list_empty(&cache->bg_list));\n\t\tif (btrfs_test_opt(info, DISCARD_ASYNC))\n\t\t\tbtrfs_discard_queue_work(&info->discard_ctl, cache);\n\t\telse\n\t\t\tbtrfs_mark_bg_unused(cache);\n\t}\n\treturn 0;\nerror:\n\tbtrfs_put_block_group(cache);\n\treturn ret;\n}\n\nstatic int fill_dummy_bgs(struct btrfs_fs_info *fs_info)\n{\n\tstruct extent_map_tree *em_tree = &fs_info->mapping_tree;\n\tstruct btrfs_space_info *space_info;\n\tstruct rb_node *node;\n\tint ret = 0;\n\n\tfor (node = rb_first_cached(&em_tree->map); node; node = rb_next(node)) {\n\t\tstruct extent_map *em;\n\t\tstruct map_lookup *map;\n\t\tstruct btrfs_block_group *bg;\n\n\t\tem = rb_entry(node, struct extent_map, rb_node);\n\t\tmap = em->map_lookup;\n\t\tbg = btrfs_create_block_group_cache(fs_info, em->start);\n\t\tif (!bg) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Fill dummy cache as FULL */\n\t\tbg->length = em->len;\n\t\tbg->flags = map->type;\n\t\tbg->last_byte_to_unpin = (u64)-1;\n\t\tbg->cached = BTRFS_CACHE_FINISHED;\n\t\tbg->used = em->len;\n\t\tbg->flags = map->type;\n\t\tret = btrfs_add_block_group_cache(fs_info, bg);\n\t\tif (ret) {\n\t\t\tbtrfs_remove_free_space_cache(bg);\n\t\t\tbtrfs_put_block_group(bg);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_update_space_info(fs_info, bg->flags, em->len, em->len,\n\t\t\t\t\t0, 0, &space_info);\n\t\tbg->space_info = space_info;\n\t\tlink_block_group(bg);\n\n\t\tset_avail_alloc_bits(fs_info, bg->flags);\n\t}\n\tif (!ret)\n\t\tbtrfs_init_global_block_rsv(fs_info);\n\treturn ret;\n}\n\nint btrfs_read_block_groups(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\tstruct btrfs_block_group *cache;\n\tstruct btrfs_space_info *space_info;\n\tstruct btrfs_key key;\n\tint need_clear = 0;\n\tu64 cache_gen;\n\n\tif (!info->extent_root)\n\t\treturn fill_dummy_bgs(info);\n\n\tkey.objectid = 0;\n\tkey.offset = 0;\n\tkey.type = BTRFS_BLOCK_GROUP_ITEM_KEY;\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tcache_gen = btrfs_super_cache_generation(info->super_copy);\n\tif (btrfs_test_opt(info, SPACE_CACHE) &&\n\t    btrfs_super_generation(info->super_copy) != cache_gen)\n\t\tneed_clear = 1;\n\tif (btrfs_test_opt(info, CLEAR_CACHE))\n\t\tneed_clear = 1;\n\n\twhile (1) {\n\t\tstruct btrfs_block_group_item bgi;\n\t\tstruct extent_buffer *leaf;\n\t\tint slot;\n\n\t\tret = find_first_block_group(info, path, &key);\n\t\tif (ret > 0)\n\t\t\tbreak;\n\t\tif (ret != 0)\n\t\t\tgoto error;\n\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tread_extent_buffer(leaf, &bgi, btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t   sizeof(bgi));\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tbtrfs_release_path(path);\n\t\tret = read_one_block_group(info, &bgi, &key, need_clear);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tkey.objectid += key.offset;\n\t\tkey.offset = 0;\n\t}\n\tbtrfs_release_path(path);\n\n\tlist_for_each_entry(space_info, &info->space_info, list) {\n\t\tint i;\n\n\t\tfor (i = 0; i < BTRFS_NR_RAID_TYPES; i++) {\n\t\t\tif (list_empty(&space_info->block_groups[i]))\n\t\t\t\tcontinue;\n\t\t\tcache = list_first_entry(&space_info->block_groups[i],\n\t\t\t\t\t\t struct btrfs_block_group,\n\t\t\t\t\t\t list);\n\t\t\tbtrfs_sysfs_add_block_group_type(cache);\n\t\t}\n\n\t\tif (!(btrfs_get_alloc_profile(info, space_info->flags) &\n\t\t      (BTRFS_BLOCK_GROUP_RAID10 |\n\t\t       BTRFS_BLOCK_GROUP_RAID1_MASK |\n\t\t       BTRFS_BLOCK_GROUP_RAID56_MASK |\n\t\t       BTRFS_BLOCK_GROUP_DUP)))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Avoid allocating from un-mirrored block group if there are\n\t\t * mirrored block groups.\n\t\t */\n\t\tlist_for_each_entry(cache,\n\t\t\t\t&space_info->block_groups[BTRFS_RAID_RAID0],\n\t\t\t\tlist)\n\t\t\tinc_block_group_ro(cache, 1);\n\t\tlist_for_each_entry(cache,\n\t\t\t\t&space_info->block_groups[BTRFS_RAID_SINGLE],\n\t\t\t\tlist)\n\t\t\tinc_block_group_ro(cache, 1);\n\t}\n\n\tbtrfs_init_global_block_rsv(info);\n\tret = check_chunk_block_group_mappings(info);\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int insert_block_group_item(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_block_group *block_group)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_block_group_item bgi;\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\n\tspin_lock(&block_group->lock);\n\tbtrfs_set_stack_block_group_used(&bgi, block_group->used);\n\tbtrfs_set_stack_block_group_chunk_objectid(&bgi,\n\t\t\t\tBTRFS_FIRST_CHUNK_TREE_OBJECTID);\n\tbtrfs_set_stack_block_group_flags(&bgi, block_group->flags);\n\tkey.objectid = block_group->start;\n\tkey.type = BTRFS_BLOCK_GROUP_ITEM_KEY;\n\tkey.offset = block_group->length;\n\tspin_unlock(&block_group->lock);\n\n\troot = fs_info->extent_root;\n\treturn btrfs_insert_item(trans, root, &key, &bgi, sizeof(bgi));\n}\n\nvoid btrfs_create_pending_block_groups(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_block_group *block_group;\n\tint ret = 0;\n\n\tif (!trans->can_flush_pending_bgs)\n\t\treturn;\n\n\twhile (!list_empty(&trans->new_bgs)) {\n\t\tint index;\n\n\t\tblock_group = list_first_entry(&trans->new_bgs,\n\t\t\t\t\t       struct btrfs_block_group,\n\t\t\t\t\t       bg_list);\n\t\tif (ret)\n\t\t\tgoto next;\n\n\t\tindex = btrfs_bg_flags_to_raid_index(block_group->flags);\n\n\t\tret = insert_block_group_item(trans, block_group);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\tret = btrfs_finish_chunk_alloc(trans, block_group->start,\n\t\t\t\t\tblock_group->length);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\tadd_block_group_free_space(trans, block_group);\n\n\t\t/*\n\t\t * If we restriped during balance, we may have added a new raid\n\t\t * type, so now add the sysfs entries when it is safe to do so.\n\t\t * We don't have to worry about locking here as it's handled in\n\t\t * btrfs_sysfs_add_block_group_type.\n\t\t */\n\t\tif (block_group->space_info->block_group_kobjs[index] == NULL)\n\t\t\tbtrfs_sysfs_add_block_group_type(block_group);\n\n\t\t/* Already aborted the transaction if it failed. */\nnext:\n\t\tbtrfs_delayed_refs_rsv_release(fs_info, 1);\n\t\tlist_del_init(&block_group->bg_list);\n\t}\n\tbtrfs_trans_release_chunk_metadata(trans);\n}\n\nint btrfs_make_block_group(struct btrfs_trans_handle *trans, u64 bytes_used,\n\t\t\t   u64 type, u64 chunk_offset, u64 size)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_block_group *cache;\n\tint ret;\n\n\tbtrfs_set_log_full_commit(trans);\n\n\tcache = btrfs_create_block_group_cache(fs_info, chunk_offset);\n\tif (!cache)\n\t\treturn -ENOMEM;\n\n\tcache->length = size;\n\tset_free_space_tree_thresholds(cache);\n\tcache->used = bytes_used;\n\tcache->flags = type;\n\tcache->last_byte_to_unpin = (u64)-1;\n\tcache->cached = BTRFS_CACHE_FINISHED;\n\tif (btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE))\n\t\tcache->needs_free_space = 1;\n\n\tret = btrfs_load_block_group_zone_info(cache, true);\n\tif (ret) {\n\t\tbtrfs_put_block_group(cache);\n\t\treturn ret;\n\t}\n\n\tret = exclude_super_stripes(cache);\n\tif (ret) {\n\t\t/* We may have excluded something, so call this just in case */\n\t\tbtrfs_free_excluded_extents(cache);\n\t\tbtrfs_put_block_group(cache);\n\t\treturn ret;\n\t}\n\n\tadd_new_free_space(cache, chunk_offset, chunk_offset + size);\n\n\tbtrfs_free_excluded_extents(cache);\n\n#ifdef CONFIG_BTRFS_DEBUG\n\tif (btrfs_should_fragment_free_space(cache)) {\n\t\tu64 new_bytes_used = size - bytes_used;\n\n\t\tbytes_used += new_bytes_used >> 1;\n\t\tfragment_free_space(cache);\n\t}\n#endif\n\t/*\n\t * Ensure the corresponding space_info object is created and\n\t * assigned to our block group. We want our bg to be added to the rbtree\n\t * with its ->space_info set.\n\t */\n\tcache->space_info = btrfs_find_space_info(fs_info, cache->flags);\n\tASSERT(cache->space_info);\n\n\tret = btrfs_add_block_group_cache(fs_info, cache);\n\tif (ret) {\n\t\tbtrfs_remove_free_space_cache(cache);\n\t\tbtrfs_put_block_group(cache);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Now that our block group has its ->space_info set and is inserted in\n\t * the rbtree, update the space info's counters.\n\t */\n\ttrace_btrfs_add_block_group(fs_info, cache, 1);\n\tbtrfs_update_space_info(fs_info, cache->flags, size, bytes_used,\n\t\t\t\tcache->bytes_super, 0, &cache->space_info);\n\tbtrfs_update_global_block_rsv(fs_info);\n\n\tlink_block_group(cache);\n\n\tlist_add_tail(&cache->bg_list, &trans->new_bgs);\n\ttrans->delayed_ref_updates++;\n\tbtrfs_update_delayed_refs_rsv(trans);\n\n\tset_avail_alloc_bits(fs_info, type);\n\treturn 0;\n}\n\n/*\n * Mark one block group RO, can be called several times for the same block\n * group.\n *\n * @cache:\t\tthe destination block group\n * @do_chunk_alloc:\twhether need to do chunk pre-allocation, this is to\n * \t\t\tensure we still have some free space after marking this\n * \t\t\tblock group RO.\n */\nint btrfs_inc_block_group_ro(struct btrfs_block_group *cache,\n\t\t\t     bool do_chunk_alloc)\n{\n\tstruct btrfs_fs_info *fs_info = cache->fs_info;\n\tstruct btrfs_trans_handle *trans;\n\tu64 alloc_flags;\n\tint ret;\n\tbool dirty_bg_running;\n\n\tdo {\n\t\ttrans = btrfs_join_transaction(fs_info->extent_root);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\n\t\tdirty_bg_running = false;\n\n\t\t/*\n\t\t * We're not allowed to set block groups readonly after the dirty\n\t\t * block group cache has started writing.  If it already started,\n\t\t * back off and let this transaction commit.\n\t\t */\n\t\tmutex_lock(&fs_info->ro_block_group_mutex);\n\t\tif (test_bit(BTRFS_TRANS_DIRTY_BG_RUN, &trans->transaction->flags)) {\n\t\t\tu64 transid = trans->transid;\n\n\t\t\tmutex_unlock(&fs_info->ro_block_group_mutex);\n\t\t\tbtrfs_end_transaction(trans);\n\n\t\t\tret = btrfs_wait_for_commit(fs_info, transid);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tdirty_bg_running = true;\n\t\t}\n\t} while (dirty_bg_running);\n\n\tif (do_chunk_alloc) {\n\t\t/*\n\t\t * If we are changing raid levels, try to allocate a\n\t\t * corresponding block group with the new raid level.\n\t\t */\n\t\talloc_flags = btrfs_get_alloc_profile(fs_info, cache->flags);\n\t\tif (alloc_flags != cache->flags) {\n\t\t\tret = btrfs_chunk_alloc(trans, alloc_flags,\n\t\t\t\t\t\tCHUNK_ALLOC_FORCE);\n\t\t\t/*\n\t\t\t * ENOSPC is allowed here, we may have enough space\n\t\t\t * already allocated at the new raid level to carry on\n\t\t\t */\n\t\t\tif (ret == -ENOSPC)\n\t\t\t\tret = 0;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = inc_block_group_ro(cache, 0);\n\tif (!do_chunk_alloc || ret == -ETXTBSY)\n\t\tgoto unlock_out;\n\tif (!ret)\n\t\tgoto out;\n\talloc_flags = btrfs_get_alloc_profile(fs_info, cache->space_info->flags);\n\tret = btrfs_chunk_alloc(trans, alloc_flags, CHUNK_ALLOC_FORCE);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = inc_block_group_ro(cache, 0);\n\tif (ret == -ETXTBSY)\n\t\tgoto unlock_out;\nout:\n\tif (cache->flags & BTRFS_BLOCK_GROUP_SYSTEM) {\n\t\talloc_flags = btrfs_get_alloc_profile(fs_info, cache->flags);\n\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\tcheck_system_chunk(trans, alloc_flags);\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t}\nunlock_out:\n\tmutex_unlock(&fs_info->ro_block_group_mutex);\n\n\tbtrfs_end_transaction(trans);\n\treturn ret;\n}\n\nvoid btrfs_dec_block_group_ro(struct btrfs_block_group *cache)\n{\n\tstruct btrfs_space_info *sinfo = cache->space_info;\n\tu64 num_bytes;\n\n\tBUG_ON(!cache->ro);\n\n\tspin_lock(&sinfo->lock);\n\tspin_lock(&cache->lock);\n\tif (!--cache->ro) {\n\t\tif (btrfs_is_zoned(cache->fs_info)) {\n\t\t\t/* Migrate zone_unusable bytes back */\n\t\t\tcache->zone_unusable = cache->alloc_offset - cache->used;\n\t\t\tsinfo->bytes_zone_unusable += cache->zone_unusable;\n\t\t\tsinfo->bytes_readonly -= cache->zone_unusable;\n\t\t}\n\t\tnum_bytes = cache->length - cache->reserved -\n\t\t\t    cache->pinned - cache->bytes_super -\n\t\t\t    cache->zone_unusable - cache->used;\n\t\tsinfo->bytes_readonly -= num_bytes;\n\t\tlist_del_init(&cache->ro_list);\n\t}\n\tspin_unlock(&cache->lock);\n\tspin_unlock(&sinfo->lock);\n}\n\nstatic int update_block_group_item(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct btrfs_block_group *cache)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tint ret;\n\tstruct btrfs_root *root = fs_info->extent_root;\n\tunsigned long bi;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_block_group_item bgi;\n\tstruct btrfs_key key;\n\n\tkey.objectid = cache->start;\n\tkey.type = BTRFS_BLOCK_GROUP_ITEM_KEY;\n\tkey.offset = cache->length;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tleaf = path->nodes[0];\n\tbi = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\tbtrfs_set_stack_block_group_used(&bgi, cache->used);\n\tbtrfs_set_stack_block_group_chunk_objectid(&bgi,\n\t\t\tBTRFS_FIRST_CHUNK_TREE_OBJECTID);\n\tbtrfs_set_stack_block_group_flags(&bgi, cache->flags);\n\twrite_extent_buffer(leaf, &bgi, bi, sizeof(bgi));\n\tbtrfs_mark_buffer_dirty(leaf);\nfail:\n\tbtrfs_release_path(path);\n\treturn ret;\n\n}\n\nstatic int cache_save_setup(struct btrfs_block_group *block_group,\n\t\t\t    struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_path *path)\n{\n\tstruct btrfs_fs_info *fs_info = block_group->fs_info;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct inode *inode = NULL;\n\tstruct extent_changeset *data_reserved = NULL;\n\tu64 alloc_hint = 0;\n\tint dcs = BTRFS_DC_ERROR;\n\tu64 cache_size = 0;\n\tint retries = 0;\n\tint ret = 0;\n\n\tif (!btrfs_test_opt(fs_info, SPACE_CACHE))\n\t\treturn 0;\n\n\t/*\n\t * If this block group is smaller than 100 megs don't bother caching the\n\t * block group.\n\t */\n\tif (block_group->length < (100 * SZ_1M)) {\n\t\tspin_lock(&block_group->lock);\n\t\tblock_group->disk_cache_state = BTRFS_DC_WRITTEN;\n\t\tspin_unlock(&block_group->lock);\n\t\treturn 0;\n\t}\n\n\tif (TRANS_ABORTED(trans))\n\t\treturn 0;\nagain:\n\tinode = lookup_free_space_inode(block_group, path);\n\tif (IS_ERR(inode) && PTR_ERR(inode) != -ENOENT) {\n\t\tret = PTR_ERR(inode);\n\t\tbtrfs_release_path(path);\n\t\tgoto out;\n\t}\n\n\tif (IS_ERR(inode)) {\n\t\tBUG_ON(retries);\n\t\tretries++;\n\n\t\tif (block_group->ro)\n\t\t\tgoto out_free;\n\n\t\tret = create_free_space_inode(trans, block_group, path);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t\tgoto again;\n\t}\n\n\t/*\n\t * We want to set the generation to 0, that way if anything goes wrong\n\t * from here on out we know not to trust this cache when we load up next\n\t * time.\n\t */\n\tBTRFS_I(inode)->generation = 0;\n\tret = btrfs_update_inode(trans, root, BTRFS_I(inode));\n\tif (ret) {\n\t\t/*\n\t\t * So theoretically we could recover from this, simply set the\n\t\t * super cache generation to 0 so we know to invalidate the\n\t\t * cache, but then we'd have to keep track of the block groups\n\t\t * that fail this way so we know we _have_ to reset this cache\n\t\t * before the next commit or risk reading stale cache.  So to\n\t\t * limit our exposure to horrible edge cases lets just abort the\n\t\t * transaction, this only happens in really bad situations\n\t\t * anyway.\n\t\t */\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out_put;\n\t}\n\tWARN_ON(ret);\n\n\t/* We've already setup this transaction, go ahead and exit */\n\tif (block_group->cache_generation == trans->transid &&\n\t    i_size_read(inode)) {\n\t\tdcs = BTRFS_DC_SETUP;\n\t\tgoto out_put;\n\t}\n\n\tif (i_size_read(inode) > 0) {\n\t\tret = btrfs_check_trunc_cache_free_space(fs_info,\n\t\t\t\t\t&fs_info->global_block_rsv);\n\t\tif (ret)\n\t\t\tgoto out_put;\n\n\t\tret = btrfs_truncate_free_space_cache(trans, NULL, inode);\n\t\tif (ret)\n\t\t\tgoto out_put;\n\t}\n\n\tspin_lock(&block_group->lock);\n\tif (block_group->cached != BTRFS_CACHE_FINISHED ||\n\t    !btrfs_test_opt(fs_info, SPACE_CACHE)) {\n\t\t/*\n\t\t * don't bother trying to write stuff out _if_\n\t\t * a) we're not cached,\n\t\t * b) we're with nospace_cache mount option,\n\t\t * c) we're with v2 space_cache (FREE_SPACE_TREE).\n\t\t */\n\t\tdcs = BTRFS_DC_WRITTEN;\n\t\tspin_unlock(&block_group->lock);\n\t\tgoto out_put;\n\t}\n\tspin_unlock(&block_group->lock);\n\n\t/*\n\t * We hit an ENOSPC when setting up the cache in this transaction, just\n\t * skip doing the setup, we've already cleared the cache so we're safe.\n\t */\n\tif (test_bit(BTRFS_TRANS_CACHE_ENOSPC, &trans->transaction->flags)) {\n\t\tret = -ENOSPC;\n\t\tgoto out_put;\n\t}\n\n\t/*\n\t * Try to preallocate enough space based on how big the block group is.\n\t * Keep in mind this has to include any pinned space which could end up\n\t * taking up quite a bit since it's not folded into the other space\n\t * cache.\n\t */\n\tcache_size = div_u64(block_group->length, SZ_256M);\n\tif (!cache_size)\n\t\tcache_size = 1;\n\n\tcache_size *= 16;\n\tcache_size *= fs_info->sectorsize;\n\n\tret = btrfs_check_data_free_space(BTRFS_I(inode), &data_reserved, 0,\n\t\t\t\t\t  cache_size);\n\tif (ret)\n\t\tgoto out_put;\n\n\tret = btrfs_prealloc_file_range_trans(inode, trans, 0, 0, cache_size,\n\t\t\t\t\t      cache_size, cache_size,\n\t\t\t\t\t      &alloc_hint);\n\t/*\n\t * Our cache requires contiguous chunks so that we don't modify a bunch\n\t * of metadata or split extents when writing the cache out, which means\n\t * we can enospc if we are heavily fragmented in addition to just normal\n\t * out of space conditions.  So if we hit this just skip setting up any\n\t * other block groups for this transaction, maybe we'll unpin enough\n\t * space the next time around.\n\t */\n\tif (!ret)\n\t\tdcs = BTRFS_DC_SETUP;\n\telse if (ret == -ENOSPC)\n\t\tset_bit(BTRFS_TRANS_CACHE_ENOSPC, &trans->transaction->flags);\n\nout_put:\n\tiput(inode);\nout_free:\n\tbtrfs_release_path(path);\nout:\n\tspin_lock(&block_group->lock);\n\tif (!ret && dcs == BTRFS_DC_SETUP)\n\t\tblock_group->cache_generation = trans->transid;\n\tblock_group->disk_cache_state = dcs;\n\tspin_unlock(&block_group->lock);\n\n\textent_changeset_free(data_reserved);\n\treturn ret;\n}\n\nint btrfs_setup_space_cache(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_block_group *cache, *tmp;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_path *path;\n\n\tif (list_empty(&cur_trans->dirty_bgs) ||\n\t    !btrfs_test_opt(fs_info, SPACE_CACHE))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t/* Could add new block groups, use _safe just in case */\n\tlist_for_each_entry_safe(cache, tmp, &cur_trans->dirty_bgs,\n\t\t\t\t dirty_list) {\n\t\tif (cache->disk_cache_state == BTRFS_DC_CLEAR)\n\t\t\tcache_save_setup(cache, trans, path);\n\t}\n\n\tbtrfs_free_path(path);\n\treturn 0;\n}\n\n/*\n * Transaction commit does final block group cache writeback during a critical\n * section where nothing is allowed to change the FS.  This is required in\n * order for the cache to actually match the block group, but can introduce a\n * lot of latency into the commit.\n *\n * So, btrfs_start_dirty_block_groups is here to kick off block group cache IO.\n * There's a chance we'll have to redo some of it if the block group changes\n * again during the commit, but it greatly reduces the commit latency by\n * getting rid of the easy block groups while we're still allowing others to\n * join the commit.\n */\nint btrfs_start_dirty_block_groups(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_block_group *cache;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tint ret = 0;\n\tint should_put;\n\tstruct btrfs_path *path = NULL;\n\tLIST_HEAD(dirty);\n\tstruct list_head *io = &cur_trans->io_bgs;\n\tint num_started = 0;\n\tint loops = 0;\n\n\tspin_lock(&cur_trans->dirty_bgs_lock);\n\tif (list_empty(&cur_trans->dirty_bgs)) {\n\t\tspin_unlock(&cur_trans->dirty_bgs_lock);\n\t\treturn 0;\n\t}\n\tlist_splice_init(&cur_trans->dirty_bgs, &dirty);\n\tspin_unlock(&cur_trans->dirty_bgs_lock);\n\nagain:\n\t/* Make sure all the block groups on our dirty list actually exist */\n\tbtrfs_create_pending_block_groups(trans);\n\n\tif (!path) {\n\t\tpath = btrfs_alloc_path();\n\t\tif (!path) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * cache_write_mutex is here only to save us from balance or automatic\n\t * removal of empty block groups deleting this block group while we are\n\t * writing out the cache\n\t */\n\tmutex_lock(&trans->transaction->cache_write_mutex);\n\twhile (!list_empty(&dirty)) {\n\t\tbool drop_reserve = true;\n\n\t\tcache = list_first_entry(&dirty, struct btrfs_block_group,\n\t\t\t\t\t dirty_list);\n\t\t/*\n\t\t * This can happen if something re-dirties a block group that\n\t\t * is already under IO.  Just wait for it to finish and then do\n\t\t * it all again\n\t\t */\n\t\tif (!list_empty(&cache->io_list)) {\n\t\t\tlist_del_init(&cache->io_list);\n\t\t\tbtrfs_wait_cache_io(trans, cache, path);\n\t\t\tbtrfs_put_block_group(cache);\n\t\t}\n\n\n\t\t/*\n\t\t * btrfs_wait_cache_io uses the cache->dirty_list to decide if\n\t\t * it should update the cache_state.  Don't delete until after\n\t\t * we wait.\n\t\t *\n\t\t * Since we're not running in the commit critical section\n\t\t * we need the dirty_bgs_lock to protect from update_block_group\n\t\t */\n\t\tspin_lock(&cur_trans->dirty_bgs_lock);\n\t\tlist_del_init(&cache->dirty_list);\n\t\tspin_unlock(&cur_trans->dirty_bgs_lock);\n\n\t\tshould_put = 1;\n\n\t\tcache_save_setup(cache, trans, path);\n\n\t\tif (cache->disk_cache_state == BTRFS_DC_SETUP) {\n\t\t\tcache->io_ctl.inode = NULL;\n\t\t\tret = btrfs_write_out_cache(trans, cache, path);\n\t\t\tif (ret == 0 && cache->io_ctl.inode) {\n\t\t\t\tnum_started++;\n\t\t\t\tshould_put = 0;\n\n\t\t\t\t/*\n\t\t\t\t * The cache_write_mutex is protecting the\n\t\t\t\t * io_list, also refer to the definition of\n\t\t\t\t * btrfs_transaction::io_bgs for more details\n\t\t\t\t */\n\t\t\t\tlist_add_tail(&cache->io_list, io);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * If we failed to write the cache, the\n\t\t\t\t * generation will be bad and life goes on\n\t\t\t\t */\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t}\n\t\tif (!ret) {\n\t\t\tret = update_block_group_item(trans, path, cache);\n\t\t\t/*\n\t\t\t * Our block group might still be attached to the list\n\t\t\t * of new block groups in the transaction handle of some\n\t\t\t * other task (struct btrfs_trans_handle->new_bgs). This\n\t\t\t * means its block group item isn't yet in the extent\n\t\t\t * tree. If this happens ignore the error, as we will\n\t\t\t * try again later in the critical section of the\n\t\t\t * transaction commit.\n\t\t\t */\n\t\t\tif (ret == -ENOENT) {\n\t\t\t\tret = 0;\n\t\t\t\tspin_lock(&cur_trans->dirty_bgs_lock);\n\t\t\t\tif (list_empty(&cache->dirty_list)) {\n\t\t\t\t\tlist_add_tail(&cache->dirty_list,\n\t\t\t\t\t\t      &cur_trans->dirty_bgs);\n\t\t\t\t\tbtrfs_get_block_group(cache);\n\t\t\t\t\tdrop_reserve = false;\n\t\t\t\t}\n\t\t\t\tspin_unlock(&cur_trans->dirty_bgs_lock);\n\t\t\t} else if (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\t}\n\t\t}\n\n\t\t/* If it's not on the io list, we need to put the block group */\n\t\tif (should_put)\n\t\t\tbtrfs_put_block_group(cache);\n\t\tif (drop_reserve)\n\t\t\tbtrfs_delayed_refs_rsv_release(fs_info, 1);\n\t\t/*\n\t\t * Avoid blocking other tasks for too long. It might even save\n\t\t * us from writing caches for block groups that are going to be\n\t\t * removed.\n\t\t */\n\t\tmutex_unlock(&trans->transaction->cache_write_mutex);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmutex_lock(&trans->transaction->cache_write_mutex);\n\t}\n\tmutex_unlock(&trans->transaction->cache_write_mutex);\n\n\t/*\n\t * Go through delayed refs for all the stuff we've just kicked off\n\t * and then loop back (just once)\n\t */\n\tif (!ret)\n\t\tret = btrfs_run_delayed_refs(trans, 0);\n\tif (!ret && loops == 0) {\n\t\tloops++;\n\t\tspin_lock(&cur_trans->dirty_bgs_lock);\n\t\tlist_splice_init(&cur_trans->dirty_bgs, &dirty);\n\t\t/*\n\t\t * dirty_bgs_lock protects us from concurrent block group\n\t\t * deletes too (not just cache_write_mutex).\n\t\t */\n\t\tif (!list_empty(&dirty)) {\n\t\t\tspin_unlock(&cur_trans->dirty_bgs_lock);\n\t\t\tgoto again;\n\t\t}\n\t\tspin_unlock(&cur_trans->dirty_bgs_lock);\n\t}\nout:\n\tif (ret < 0) {\n\t\tspin_lock(&cur_trans->dirty_bgs_lock);\n\t\tlist_splice_init(&dirty, &cur_trans->dirty_bgs);\n\t\tspin_unlock(&cur_trans->dirty_bgs_lock);\n\t\tbtrfs_cleanup_dirty_bgs(cur_trans, fs_info);\n\t}\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nint btrfs_write_dirty_block_groups(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_block_group *cache;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tint ret = 0;\n\tint should_put;\n\tstruct btrfs_path *path;\n\tstruct list_head *io = &cur_trans->io_bgs;\n\tint num_started = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Even though we are in the critical section of the transaction commit,\n\t * we can still have concurrent tasks adding elements to this\n\t * transaction's list of dirty block groups. These tasks correspond to\n\t * endio free space workers started when writeback finishes for a\n\t * space cache, which run inode.c:btrfs_finish_ordered_io(), and can\n\t * allocate new block groups as a result of COWing nodes of the root\n\t * tree when updating the free space inode. The writeback for the space\n\t * caches is triggered by an earlier call to\n\t * btrfs_start_dirty_block_groups() and iterations of the following\n\t * loop.\n\t * Also we want to do the cache_save_setup first and then run the\n\t * delayed refs to make sure we have the best chance at doing this all\n\t * in one shot.\n\t */\n\tspin_lock(&cur_trans->dirty_bgs_lock);\n\twhile (!list_empty(&cur_trans->dirty_bgs)) {\n\t\tcache = list_first_entry(&cur_trans->dirty_bgs,\n\t\t\t\t\t struct btrfs_block_group,\n\t\t\t\t\t dirty_list);\n\n\t\t/*\n\t\t * This can happen if cache_save_setup re-dirties a block group\n\t\t * that is already under IO.  Just wait for it to finish and\n\t\t * then do it all again\n\t\t */\n\t\tif (!list_empty(&cache->io_list)) {\n\t\t\tspin_unlock(&cur_trans->dirty_bgs_lock);\n\t\t\tlist_del_init(&cache->io_list);\n\t\t\tbtrfs_wait_cache_io(trans, cache, path);\n\t\t\tbtrfs_put_block_group(cache);\n\t\t\tspin_lock(&cur_trans->dirty_bgs_lock);\n\t\t}\n\n\t\t/*\n\t\t * Don't remove from the dirty list until after we've waited on\n\t\t * any pending IO\n\t\t */\n\t\tlist_del_init(&cache->dirty_list);\n\t\tspin_unlock(&cur_trans->dirty_bgs_lock);\n\t\tshould_put = 1;\n\n\t\tcache_save_setup(cache, trans, path);\n\n\t\tif (!ret)\n\t\t\tret = btrfs_run_delayed_refs(trans,\n\t\t\t\t\t\t     (unsigned long) -1);\n\n\t\tif (!ret && cache->disk_cache_state == BTRFS_DC_SETUP) {\n\t\t\tcache->io_ctl.inode = NULL;\n\t\t\tret = btrfs_write_out_cache(trans, cache, path);\n\t\t\tif (ret == 0 && cache->io_ctl.inode) {\n\t\t\t\tnum_started++;\n\t\t\t\tshould_put = 0;\n\t\t\t\tlist_add_tail(&cache->io_list, io);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * If we failed to write the cache, the\n\t\t\t\t * generation will be bad and life goes on\n\t\t\t\t */\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t}\n\t\tif (!ret) {\n\t\t\tret = update_block_group_item(trans, path, cache);\n\t\t\t/*\n\t\t\t * One of the free space endio workers might have\n\t\t\t * created a new block group while updating a free space\n\t\t\t * cache's inode (at inode.c:btrfs_finish_ordered_io())\n\t\t\t * and hasn't released its transaction handle yet, in\n\t\t\t * which case the new block group is still attached to\n\t\t\t * its transaction handle and its creation has not\n\t\t\t * finished yet (no block group item in the extent tree\n\t\t\t * yet, etc). If this is the case, wait for all free\n\t\t\t * space endio workers to finish and retry. This is a\n\t\t\t * very rare case so no need for a more efficient and\n\t\t\t * complex approach.\n\t\t\t */\n\t\t\tif (ret == -ENOENT) {\n\t\t\t\twait_event(cur_trans->writer_wait,\n\t\t\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\t\t\t\tret = update_block_group_item(trans, path, cache);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t}\n\n\t\t/* If its not on the io list, we need to put the block group */\n\t\tif (should_put)\n\t\t\tbtrfs_put_block_group(cache);\n\t\tbtrfs_delayed_refs_rsv_release(fs_info, 1);\n\t\tspin_lock(&cur_trans->dirty_bgs_lock);\n\t}\n\tspin_unlock(&cur_trans->dirty_bgs_lock);\n\n\t/*\n\t * Refer to the definition of io_bgs member for details why it's safe\n\t * to use it without any locking\n\t */\n\twhile (!list_empty(io)) {\n\t\tcache = list_first_entry(io, struct btrfs_block_group,\n\t\t\t\t\t io_list);\n\t\tlist_del_init(&cache->io_list);\n\t\tbtrfs_wait_cache_io(trans, cache, path);\n\t\tbtrfs_put_block_group(cache);\n\t}\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nint btrfs_update_block_group(struct btrfs_trans_handle *trans,\n\t\t\t     u64 bytenr, u64 num_bytes, int alloc)\n{\n\tstruct btrfs_fs_info *info = trans->fs_info;\n\tstruct btrfs_block_group *cache = NULL;\n\tu64 total = num_bytes;\n\tu64 old_val;\n\tu64 byte_in_group;\n\tint factor;\n\tint ret = 0;\n\n\t/* Block accounting for super block */\n\tspin_lock(&info->delalloc_root_lock);\n\told_val = btrfs_super_bytes_used(info->super_copy);\n\tif (alloc)\n\t\told_val += num_bytes;\n\telse\n\t\told_val -= num_bytes;\n\tbtrfs_set_super_bytes_used(info->super_copy, old_val);\n\tspin_unlock(&info->delalloc_root_lock);\n\n\twhile (total) {\n\t\tcache = btrfs_lookup_block_group(info, bytenr);\n\t\tif (!cache) {\n\t\t\tret = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\t\tfactor = btrfs_bg_type_to_factor(cache->flags);\n\n\t\t/*\n\t\t * If this block group has free space cache written out, we\n\t\t * need to make sure to load it if we are removing space.  This\n\t\t * is because we need the unpinning stage to actually add the\n\t\t * space back to the block group, otherwise we will leak space.\n\t\t */\n\t\tif (!alloc && !btrfs_block_group_done(cache))\n\t\t\tbtrfs_cache_block_group(cache, 1);\n\n\t\tbyte_in_group = bytenr - cache->start;\n\t\tWARN_ON(byte_in_group > cache->length);\n\n\t\tspin_lock(&cache->space_info->lock);\n\t\tspin_lock(&cache->lock);\n\n\t\tif (btrfs_test_opt(info, SPACE_CACHE) &&\n\t\t    cache->disk_cache_state < BTRFS_DC_CLEAR)\n\t\t\tcache->disk_cache_state = BTRFS_DC_CLEAR;\n\n\t\told_val = cache->used;\n\t\tnum_bytes = min(total, cache->length - byte_in_group);\n\t\tif (alloc) {\n\t\t\told_val += num_bytes;\n\t\t\tcache->used = old_val;\n\t\t\tcache->reserved -= num_bytes;\n\t\t\tcache->space_info->bytes_reserved -= num_bytes;\n\t\t\tcache->space_info->bytes_used += num_bytes;\n\t\t\tcache->space_info->disk_used += num_bytes * factor;\n\t\t\tspin_unlock(&cache->lock);\n\t\t\tspin_unlock(&cache->space_info->lock);\n\t\t} else {\n\t\t\told_val -= num_bytes;\n\t\t\tcache->used = old_val;\n\t\t\tcache->pinned += num_bytes;\n\t\t\tbtrfs_space_info_update_bytes_pinned(info,\n\t\t\t\t\tcache->space_info, num_bytes);\n\t\t\tcache->space_info->bytes_used -= num_bytes;\n\t\t\tcache->space_info->disk_used -= num_bytes * factor;\n\t\t\tspin_unlock(&cache->lock);\n\t\t\tspin_unlock(&cache->space_info->lock);\n\n\t\t\tset_extent_dirty(&trans->transaction->pinned_extents,\n\t\t\t\t\t bytenr, bytenr + num_bytes - 1,\n\t\t\t\t\t GFP_NOFS | __GFP_NOFAIL);\n\t\t}\n\n\t\tspin_lock(&trans->transaction->dirty_bgs_lock);\n\t\tif (list_empty(&cache->dirty_list)) {\n\t\t\tlist_add_tail(&cache->dirty_list,\n\t\t\t\t      &trans->transaction->dirty_bgs);\n\t\t\ttrans->delayed_ref_updates++;\n\t\t\tbtrfs_get_block_group(cache);\n\t\t}\n\t\tspin_unlock(&trans->transaction->dirty_bgs_lock);\n\n\t\t/*\n\t\t * No longer have used bytes in this block group, queue it for\n\t\t * deletion. We do this after adding the block group to the\n\t\t * dirty list to avoid races between cleaner kthread and space\n\t\t * cache writeout.\n\t\t */\n\t\tif (!alloc && old_val == 0) {\n\t\t\tif (!btrfs_test_opt(info, DISCARD_ASYNC))\n\t\t\t\tbtrfs_mark_bg_unused(cache);\n\t\t}\n\n\t\tbtrfs_put_block_group(cache);\n\t\ttotal -= num_bytes;\n\t\tbytenr += num_bytes;\n\t}\n\n\t/* Modified block groups are accounted for in the delayed_refs_rsv. */\n\tbtrfs_update_delayed_refs_rsv(trans);\n\treturn ret;\n}\n\n/**\n * btrfs_add_reserved_bytes - update the block_group and space info counters\n * @cache:\tThe cache we are manipulating\n * @ram_bytes:  The number of bytes of file content, and will be same to\n *              @num_bytes except for the compress path.\n * @num_bytes:\tThe number of bytes in question\n * @delalloc:   The blocks are allocated for the delalloc write\n *\n * This is called by the allocator when it reserves space. If this is a\n * reservation and the block group has become read only we cannot make the\n * reservation and return -EAGAIN, otherwise this function always succeeds.\n */\nint btrfs_add_reserved_bytes(struct btrfs_block_group *cache,\n\t\t\t     u64 ram_bytes, u64 num_bytes, int delalloc)\n{\n\tstruct btrfs_space_info *space_info = cache->space_info;\n\tint ret = 0;\n\n\tspin_lock(&space_info->lock);\n\tspin_lock(&cache->lock);\n\tif (cache->ro) {\n\t\tret = -EAGAIN;\n\t} else {\n\t\tcache->reserved += num_bytes;\n\t\tspace_info->bytes_reserved += num_bytes;\n\t\ttrace_btrfs_space_reservation(cache->fs_info, \"space_info\",\n\t\t\t\t\t      space_info->flags, num_bytes, 1);\n\t\tbtrfs_space_info_update_bytes_may_use(cache->fs_info,\n\t\t\t\t\t\t      space_info, -ram_bytes);\n\t\tif (delalloc)\n\t\t\tcache->delalloc_bytes += num_bytes;\n\n\t\t/*\n\t\t * Compression can use less space than we reserved, so wake\n\t\t * tickets if that happens\n\t\t */\n\t\tif (num_bytes < ram_bytes)\n\t\t\tbtrfs_try_granting_tickets(cache->fs_info, space_info);\n\t}\n\tspin_unlock(&cache->lock);\n\tspin_unlock(&space_info->lock);\n\treturn ret;\n}\n\n/**\n * btrfs_free_reserved_bytes - update the block_group and space info counters\n * @cache:      The cache we are manipulating\n * @num_bytes:  The number of bytes in question\n * @delalloc:   The blocks are allocated for the delalloc write\n *\n * This is called by somebody who is freeing space that was never actually used\n * on disk.  For example if you reserve some space for a new leaf in transaction\n * A and before transaction A commits you free that leaf, you call this with\n * reserve set to 0 in order to clear the reservation.\n */\nvoid btrfs_free_reserved_bytes(struct btrfs_block_group *cache,\n\t\t\t       u64 num_bytes, int delalloc)\n{\n\tstruct btrfs_space_info *space_info = cache->space_info;\n\n\tspin_lock(&space_info->lock);\n\tspin_lock(&cache->lock);\n\tif (cache->ro)\n\t\tspace_info->bytes_readonly += num_bytes;\n\tcache->reserved -= num_bytes;\n\tspace_info->bytes_reserved -= num_bytes;\n\tspace_info->max_extent_size = 0;\n\n\tif (delalloc)\n\t\tcache->delalloc_bytes -= num_bytes;\n\tspin_unlock(&cache->lock);\n\n\tbtrfs_try_granting_tickets(cache->fs_info, space_info);\n\tspin_unlock(&space_info->lock);\n}\n\nstatic void force_metadata_allocation(struct btrfs_fs_info *info)\n{\n\tstruct list_head *head = &info->space_info;\n\tstruct btrfs_space_info *found;\n\n\tlist_for_each_entry(found, head, list) {\n\t\tif (found->flags & BTRFS_BLOCK_GROUP_METADATA)\n\t\t\tfound->force_alloc = CHUNK_ALLOC_FORCE;\n\t}\n}\n\nstatic int should_alloc_chunk(struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_space_info *sinfo, int force)\n{\n\tu64 bytes_used = btrfs_space_info_used(sinfo, false);\n\tu64 thresh;\n\n\tif (force == CHUNK_ALLOC_FORCE)\n\t\treturn 1;\n\n\t/*\n\t * in limited mode, we want to have some free space up to\n\t * about 1% of the FS size.\n\t */\n\tif (force == CHUNK_ALLOC_LIMITED) {\n\t\tthresh = btrfs_super_total_bytes(fs_info->super_copy);\n\t\tthresh = max_t(u64, SZ_64M, div_factor_fine(thresh, 1));\n\n\t\tif (sinfo->total_bytes - bytes_used < thresh)\n\t\t\treturn 1;\n\t}\n\n\tif (bytes_used + SZ_2M < div_factor(sinfo->total_bytes, 8))\n\t\treturn 0;\n\treturn 1;\n}\n\nint btrfs_force_chunk_alloc(struct btrfs_trans_handle *trans, u64 type)\n{\n\tu64 alloc_flags = btrfs_get_alloc_profile(trans->fs_info, type);\n\n\treturn btrfs_chunk_alloc(trans, alloc_flags, CHUNK_ALLOC_FORCE);\n}\n\n/*\n * If force is CHUNK_ALLOC_FORCE:\n *    - return 1 if it successfully allocates a chunk,\n *    - return errors including -ENOSPC otherwise.\n * If force is NOT CHUNK_ALLOC_FORCE:\n *    - return 0 if it doesn't need to allocate a new chunk,\n *    - return 1 if it successfully allocates a chunk,\n *    - return errors including -ENOSPC otherwise.\n */\nint btrfs_chunk_alloc(struct btrfs_trans_handle *trans, u64 flags,\n\t\t      enum btrfs_chunk_alloc_enum force)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_space_info *space_info;\n\tbool wait_for_alloc = false;\n\tbool should_alloc = false;\n\tint ret = 0;\n\n\t/* Don't re-enter if we're already allocating a chunk */\n\tif (trans->allocating_chunk)\n\t\treturn -ENOSPC;\n\n\tspace_info = btrfs_find_space_info(fs_info, flags);\n\tASSERT(space_info);\n\n\tdo {\n\t\tspin_lock(&space_info->lock);\n\t\tif (force < space_info->force_alloc)\n\t\t\tforce = space_info->force_alloc;\n\t\tshould_alloc = should_alloc_chunk(fs_info, space_info, force);\n\t\tif (space_info->full) {\n\t\t\t/* No more free physical space */\n\t\t\tif (should_alloc)\n\t\t\t\tret = -ENOSPC;\n\t\t\telse\n\t\t\t\tret = 0;\n\t\t\tspin_unlock(&space_info->lock);\n\t\t\treturn ret;\n\t\t} else if (!should_alloc) {\n\t\t\tspin_unlock(&space_info->lock);\n\t\t\treturn 0;\n\t\t} else if (space_info->chunk_alloc) {\n\t\t\t/*\n\t\t\t * Someone is already allocating, so we need to block\n\t\t\t * until this someone is finished and then loop to\n\t\t\t * recheck if we should continue with our allocation\n\t\t\t * attempt.\n\t\t\t */\n\t\t\twait_for_alloc = true;\n\t\t\tspin_unlock(&space_info->lock);\n\t\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t\t} else {\n\t\t\t/* Proceed with allocation */\n\t\t\tspace_info->chunk_alloc = 1;\n\t\t\twait_for_alloc = false;\n\t\t\tspin_unlock(&space_info->lock);\n\t\t}\n\n\t\tcond_resched();\n\t} while (wait_for_alloc);\n\n\tmutex_lock(&fs_info->chunk_mutex);\n\ttrans->allocating_chunk = true;\n\n\t/*\n\t * If we have mixed data/metadata chunks we want to make sure we keep\n\t * allocating mixed chunks instead of individual chunks.\n\t */\n\tif (btrfs_mixed_space_info(space_info))\n\t\tflags |= (BTRFS_BLOCK_GROUP_DATA | BTRFS_BLOCK_GROUP_METADATA);\n\n\t/*\n\t * if we're doing a data chunk, go ahead and make sure that\n\t * we keep a reasonable number of metadata chunks allocated in the\n\t * FS as well.\n\t */\n\tif (flags & BTRFS_BLOCK_GROUP_DATA && fs_info->metadata_ratio) {\n\t\tfs_info->data_chunk_allocations++;\n\t\tif (!(fs_info->data_chunk_allocations %\n\t\t      fs_info->metadata_ratio))\n\t\t\tforce_metadata_allocation(fs_info);\n\t}\n\n\t/*\n\t * Check if we have enough space in SYSTEM chunk because we may need\n\t * to update devices.\n\t */\n\tcheck_system_chunk(trans, flags);\n\n\tret = btrfs_alloc_chunk(trans, flags);\n\ttrans->allocating_chunk = false;\n\n\tspin_lock(&space_info->lock);\n\tif (ret < 0) {\n\t\tif (ret == -ENOSPC)\n\t\t\tspace_info->full = 1;\n\t\telse\n\t\t\tgoto out;\n\t} else {\n\t\tret = 1;\n\t\tspace_info->max_extent_size = 0;\n\t}\n\n\tspace_info->force_alloc = CHUNK_ALLOC_NO_FORCE;\nout:\n\tspace_info->chunk_alloc = 0;\n\tspin_unlock(&space_info->lock);\n\tmutex_unlock(&fs_info->chunk_mutex);\n\t/*\n\t * When we allocate a new chunk we reserve space in the chunk block\n\t * reserve to make sure we can COW nodes/leafs in the chunk tree or\n\t * add new nodes/leafs to it if we end up needing to do it when\n\t * inserting the chunk item and updating device items as part of the\n\t * second phase of chunk allocation, performed by\n\t * btrfs_finish_chunk_alloc(). So make sure we don't accumulate a\n\t * large number of new block groups to create in our transaction\n\t * handle's new_bgs list to avoid exhausting the chunk block reserve\n\t * in extreme cases - like having a single transaction create many new\n\t * block groups when starting to write out the free space caches of all\n\t * the block groups that were made dirty during the lifetime of the\n\t * transaction.\n\t */\n\tif (trans->chunk_bytes_reserved >= (u64)SZ_2M)\n\t\tbtrfs_create_pending_block_groups(trans);\n\n\treturn ret;\n}\n\nstatic u64 get_profile_num_devs(struct btrfs_fs_info *fs_info, u64 type)\n{\n\tu64 num_dev;\n\n\tnum_dev = btrfs_raid_array[btrfs_bg_flags_to_raid_index(type)].devs_max;\n\tif (!num_dev)\n\t\tnum_dev = fs_info->fs_devices->rw_devices;\n\n\treturn num_dev;\n}\n\n/*\n * Reserve space in the system space for allocating or removing a chunk\n */\nvoid check_system_chunk(struct btrfs_trans_handle *trans, u64 type)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_space_info *info;\n\tu64 left;\n\tu64 thresh;\n\tint ret = 0;\n\tu64 num_devs;\n\n\t/*\n\t * Needed because we can end up allocating a system chunk and for an\n\t * atomic and race free space reservation in the chunk block reserve.\n\t */\n\tlockdep_assert_held(&fs_info->chunk_mutex);\n\n\tinfo = btrfs_find_space_info(fs_info, BTRFS_BLOCK_GROUP_SYSTEM);\nagain:\n\tspin_lock(&info->lock);\n\tleft = info->total_bytes - btrfs_space_info_used(info, true);\n\tspin_unlock(&info->lock);\n\n\tnum_devs = get_profile_num_devs(fs_info, type);\n\n\t/* num_devs device items to update and 1 chunk item to add or remove */\n\tthresh = btrfs_calc_metadata_size(fs_info, num_devs) +\n\t\tbtrfs_calc_insert_metadata_size(fs_info, 1);\n\n\tif (left < thresh && btrfs_test_opt(fs_info, ENOSPC_DEBUG)) {\n\t\tbtrfs_info(fs_info, \"left=%llu, need=%llu, flags=%llu\",\n\t\t\t   left, thresh, type);\n\t\tbtrfs_dump_space_info(fs_info, info, 0, 0);\n\t}\n\n\tif (left < thresh) {\n\t\tu64 flags = btrfs_system_alloc_profile(fs_info);\n\t\tu64 reserved = atomic64_read(&cur_trans->chunk_bytes_reserved);\n\n\t\t/*\n\t\t * If there's not available space for the chunk tree (system\n\t\t * space) and there are other tasks that reserved space for\n\t\t * creating a new system block group, wait for them to complete\n\t\t * the creation of their system block group and release excess\n\t\t * reserved space. We do this because:\n\t\t *\n\t\t * *) We can end up allocating more system chunks than necessary\n\t\t *    when there are multiple tasks that are concurrently\n\t\t *    allocating block groups, which can lead to exhaustion of\n\t\t *    the system array in the superblock;\n\t\t *\n\t\t * *) If we allocate extra and unnecessary system block groups,\n\t\t *    despite being empty for a long time, and possibly forever,\n\t\t *    they end not being added to the list of unused block groups\n\t\t *    because that typically happens only when deallocating the\n\t\t *    last extent from a block group - which never happens since\n\t\t *    we never allocate from them in the first place. The few\n\t\t *    exceptions are when mounting a filesystem or running scrub,\n\t\t *    which add unused block groups to the list of unused block\n\t\t *    groups, to be deleted by the cleaner kthread.\n\t\t *    And even when they are added to the list of unused block\n\t\t *    groups, it can take a long time until they get deleted,\n\t\t *    since the cleaner kthread might be sleeping or busy with\n\t\t *    other work (deleting subvolumes, running delayed iputs,\n\t\t *    defrag scheduling, etc);\n\t\t *\n\t\t * This is rare in practice, but can happen when too many tasks\n\t\t * are allocating blocks groups in parallel (via fallocate())\n\t\t * and before the one that reserved space for a new system block\n\t\t * group finishes the block group creation and releases the space\n\t\t * reserved in excess (at btrfs_create_pending_block_groups()),\n\t\t * other tasks end up here and see free system space temporarily\n\t\t * not enough for updating the chunk tree.\n\t\t *\n\t\t * We unlock the chunk mutex before waiting for such tasks and\n\t\t * lock it again after the wait, otherwise we would deadlock.\n\t\t * It is safe to do so because allocating a system chunk is the\n\t\t * first thing done while allocating a new block group.\n\t\t */\n\t\tif (reserved > trans->chunk_bytes_reserved) {\n\t\t\tconst u64 min_needed = reserved - thresh;\n\n\t\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t\t\twait_event(cur_trans->chunk_reserve_wait,\n\t\t\t   atomic64_read(&cur_trans->chunk_bytes_reserved) <=\n\t\t\t   min_needed);\n\t\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * Ignore failure to create system chunk. We might end up not\n\t\t * needing it, as we might not need to COW all nodes/leafs from\n\t\t * the paths we visit in the chunk tree (they were already COWed\n\t\t * or created in the current transaction for example).\n\t\t */\n\t\tret = btrfs_alloc_chunk(trans, flags);\n\t}\n\n\tif (!ret) {\n\t\tret = btrfs_block_rsv_add(fs_info->chunk_root,\n\t\t\t\t\t  &fs_info->chunk_block_rsv,\n\t\t\t\t\t  thresh, BTRFS_RESERVE_NO_FLUSH);\n\t\tif (!ret) {\n\t\t\tatomic64_add(thresh, &cur_trans->chunk_bytes_reserved);\n\t\t\ttrans->chunk_bytes_reserved += thresh;\n\t\t}\n\t}\n}\n\nvoid btrfs_put_block_group_cache(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group *block_group;\n\tu64 last = 0;\n\n\twhile (1) {\n\t\tstruct inode *inode;\n\n\t\tblock_group = btrfs_lookup_first_block_group(info, last);\n\t\twhile (block_group) {\n\t\t\tbtrfs_wait_block_group_cache_done(block_group);\n\t\t\tspin_lock(&block_group->lock);\n\t\t\tif (block_group->iref)\n\t\t\t\tbreak;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tblock_group = btrfs_next_block_group(block_group);\n\t\t}\n\t\tif (!block_group) {\n\t\t\tif (last == 0)\n\t\t\t\tbreak;\n\t\t\tlast = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode = block_group->inode;\n\t\tblock_group->iref = 0;\n\t\tblock_group->inode = NULL;\n\t\tspin_unlock(&block_group->lock);\n\t\tASSERT(block_group->io_ctl.inode == NULL);\n\t\tiput(inode);\n\t\tlast = block_group->start + block_group->length;\n\t\tbtrfs_put_block_group(block_group);\n\t}\n}\n\n/*\n * Must be called only after stopping all workers, since we could have block\n * group caching kthreads running, and therefore they could race with us if we\n * freed the block groups before stopping them.\n */\nint btrfs_free_block_groups(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group *block_group;\n\tstruct btrfs_space_info *space_info;\n\tstruct btrfs_caching_control *caching_ctl;\n\tstruct rb_node *n;\n\n\tspin_lock(&info->block_group_cache_lock);\n\twhile (!list_empty(&info->caching_block_groups)) {\n\t\tcaching_ctl = list_entry(info->caching_block_groups.next,\n\t\t\t\t\t struct btrfs_caching_control, list);\n\t\tlist_del(&caching_ctl->list);\n\t\tbtrfs_put_caching_control(caching_ctl);\n\t}\n\tspin_unlock(&info->block_group_cache_lock);\n\n\tspin_lock(&info->unused_bgs_lock);\n\twhile (!list_empty(&info->unused_bgs)) {\n\t\tblock_group = list_first_entry(&info->unused_bgs,\n\t\t\t\t\t       struct btrfs_block_group,\n\t\t\t\t\t       bg_list);\n\t\tlist_del_init(&block_group->bg_list);\n\t\tbtrfs_put_block_group(block_group);\n\t}\n\tspin_unlock(&info->unused_bgs_lock);\n\n\tspin_lock(&info->unused_bgs_lock);\n\twhile (!list_empty(&info->reclaim_bgs)) {\n\t\tblock_group = list_first_entry(&info->reclaim_bgs,\n\t\t\t\t\t       struct btrfs_block_group,\n\t\t\t\t\t       bg_list);\n\t\tlist_del_init(&block_group->bg_list);\n\t\tbtrfs_put_block_group(block_group);\n\t}\n\tspin_unlock(&info->unused_bgs_lock);\n\n\tspin_lock(&info->block_group_cache_lock);\n\twhile ((n = rb_last(&info->block_group_cache_tree)) != NULL) {\n\t\tblock_group = rb_entry(n, struct btrfs_block_group,\n\t\t\t\t       cache_node);\n\t\trb_erase(&block_group->cache_node,\n\t\t\t &info->block_group_cache_tree);\n\t\tRB_CLEAR_NODE(&block_group->cache_node);\n\t\tspin_unlock(&info->block_group_cache_lock);\n\n\t\tdown_write(&block_group->space_info->groups_sem);\n\t\tlist_del(&block_group->list);\n\t\tup_write(&block_group->space_info->groups_sem);\n\n\t\t/*\n\t\t * We haven't cached this block group, which means we could\n\t\t * possibly have excluded extents on this block group.\n\t\t */\n\t\tif (block_group->cached == BTRFS_CACHE_NO ||\n\t\t    block_group->cached == BTRFS_CACHE_ERROR)\n\t\t\tbtrfs_free_excluded_extents(block_group);\n\n\t\tbtrfs_remove_free_space_cache(block_group);\n\t\tASSERT(block_group->cached != BTRFS_CACHE_STARTED);\n\t\tASSERT(list_empty(&block_group->dirty_list));\n\t\tASSERT(list_empty(&block_group->io_list));\n\t\tASSERT(list_empty(&block_group->bg_list));\n\t\tASSERT(refcount_read(&block_group->refs) == 1);\n\t\tASSERT(block_group->swap_extents == 0);\n\t\tbtrfs_put_block_group(block_group);\n\n\t\tspin_lock(&info->block_group_cache_lock);\n\t}\n\tspin_unlock(&info->block_group_cache_lock);\n\n\tbtrfs_release_global_block_rsv(info);\n\n\twhile (!list_empty(&info->space_info)) {\n\t\tspace_info = list_entry(info->space_info.next,\n\t\t\t\t\tstruct btrfs_space_info,\n\t\t\t\t\tlist);\n\n\t\t/*\n\t\t * Do not hide this behind enospc_debug, this is actually\n\t\t * important and indicates a real bug if this happens.\n\t\t */\n\t\tif (WARN_ON(space_info->bytes_pinned > 0 ||\n\t\t\t    space_info->bytes_reserved > 0 ||\n\t\t\t    space_info->bytes_may_use > 0))\n\t\t\tbtrfs_dump_space_info(info, space_info, 0, 0);\n\t\tWARN_ON(space_info->reclaim_size > 0);\n\t\tlist_del(&space_info->list);\n\t\tbtrfs_sysfs_remove_space_info(space_info);\n\t}\n\treturn 0;\n}\n\nvoid btrfs_freeze_block_group(struct btrfs_block_group *cache)\n{\n\tatomic_inc(&cache->frozen);\n}\n\nvoid btrfs_unfreeze_block_group(struct btrfs_block_group *block_group)\n{\n\tstruct btrfs_fs_info *fs_info = block_group->fs_info;\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tbool cleanup;\n\n\tspin_lock(&block_group->lock);\n\tcleanup = (atomic_dec_and_test(&block_group->frozen) &&\n\t\t   block_group->removed);\n\tspin_unlock(&block_group->lock);\n\n\tif (cleanup) {\n\t\tem_tree = &fs_info->mapping_tree;\n\t\twrite_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, block_group->start,\n\t\t\t\t\t   1);\n\t\tBUG_ON(!em); /* logic error, can't happen */\n\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\n\t\t/* once for us and once for the tree */\n\t\tfree_extent_map(em);\n\t\tfree_extent_map(em);\n\n\t\t/*\n\t\t * We may have left one free space entry and other possible\n\t\t * tasks trimming this block group have left 1 entry each one.\n\t\t * Free them if any.\n\t\t */\n\t\t__btrfs_remove_free_space_cache(block_group->free_space_ctl);\n\t}\n}\n\nbool btrfs_inc_block_group_swap_extents(struct btrfs_block_group *bg)\n{\n\tbool ret = true;\n\n\tspin_lock(&bg->lock);\n\tif (bg->ro)\n\t\tret = false;\n\telse\n\t\tbg->swap_extents++;\n\tspin_unlock(&bg->lock);\n\n\treturn ret;\n}\n\nvoid btrfs_dec_block_group_swap_extents(struct btrfs_block_group *bg, int amount)\n{\n\tspin_lock(&bg->lock);\n\tASSERT(!bg->ro);\n\tASSERT(bg->swap_extents >= amount);\n\tbg->swap_extents -= amount;\n\tspin_unlock(&bg->lock);\n}\n", "// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (C) 2007 Oracle.  All rights reserved.\n */\n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/blkdev.h>\n#include <linux/uuid.h>\n#include \"misc.h\"\n#include \"ctree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"volumes.h\"\n#include \"dev-replace.h\"\n#include \"qgroup.h\"\n#include \"block-group.h\"\n#include \"space-info.h\"\n#include \"zoned.h\"\n\n#define BTRFS_ROOT_TRANS_TAG 0\n\n/*\n * Transaction states and transitions\n *\n * No running transaction (fs tree blocks are not modified)\n * |\n * | To next stage:\n * |  Call start_transaction() variants. Except btrfs_join_transaction_nostart().\n * V\n * Transaction N [[TRANS_STATE_RUNNING]]\n * |\n * | New trans handles can be attached to transaction N by calling all\n * | start_transaction() variants.\n * |\n * | To next stage:\n * |  Call btrfs_commit_transaction() on any trans handle attached to\n * |  transaction N\n * V\n * Transaction N [[TRANS_STATE_COMMIT_START]]\n * |\n * | Will wait for previous running transaction to completely finish if there\n * | is one\n * |\n * | Then one of the following happes:\n * | - Wait for all other trans handle holders to release.\n * |   The btrfs_commit_transaction() caller will do the commit work.\n * | - Wait for current transaction to be committed by others.\n * |   Other btrfs_commit_transaction() caller will do the commit work.\n * |\n * | At this stage, only btrfs_join_transaction*() variants can attach\n * | to this running transaction.\n * | All other variants will wait for current one to finish and attach to\n * | transaction N+1.\n * |\n * | To next stage:\n * |  Caller is chosen to commit transaction N, and all other trans handle\n * |  haven been released.\n * V\n * Transaction N [[TRANS_STATE_COMMIT_DOING]]\n * |\n * | The heavy lifting transaction work is started.\n * | From running delayed refs (modifying extent tree) to creating pending\n * | snapshots, running qgroups.\n * | In short, modify supporting trees to reflect modifications of subvolume\n * | trees.\n * |\n * | At this stage, all start_transaction() calls will wait for this\n * | transaction to finish and attach to transaction N+1.\n * |\n * | To next stage:\n * |  Until all supporting trees are updated.\n * V\n * Transaction N [[TRANS_STATE_UNBLOCKED]]\n * |\t\t\t\t\t\t    Transaction N+1\n * | All needed trees are modified, thus we only    [[TRANS_STATE_RUNNING]]\n * | need to write them back to disk and update\t    |\n * | super blocks.\t\t\t\t    |\n * |\t\t\t\t\t\t    |\n * | At this stage, new transaction is allowed to   |\n * | start.\t\t\t\t\t    |\n * | All new start_transaction() calls will be\t    |\n * | attached to transid N+1.\t\t\t    |\n * |\t\t\t\t\t\t    |\n * | To next stage:\t\t\t\t    |\n * |  Until all tree blocks are super blocks are    |\n * |  written to block devices\t\t\t    |\n * V\t\t\t\t\t\t    |\n * Transaction N [[TRANS_STATE_COMPLETED]]\t    V\n *   All tree blocks and super blocks are written.  Transaction N+1\n *   This transaction is finished and all its\t    [[TRANS_STATE_COMMIT_START]]\n *   data structures will be cleaned up.\t    | Life goes on\n */\nstatic const unsigned int btrfs_blocked_trans_types[TRANS_STATE_MAX] = {\n\t[TRANS_STATE_RUNNING]\t\t= 0U,\n\t[TRANS_STATE_COMMIT_START]\t= (__TRANS_START | __TRANS_ATTACH),\n\t[TRANS_STATE_COMMIT_DOING]\t= (__TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN |\n\t\t\t\t\t   __TRANS_JOIN_NOSTART),\n\t[TRANS_STATE_UNBLOCKED]\t\t= (__TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN |\n\t\t\t\t\t   __TRANS_JOIN_NOLOCK |\n\t\t\t\t\t   __TRANS_JOIN_NOSTART),\n\t[TRANS_STATE_SUPER_COMMITTED]\t= (__TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN |\n\t\t\t\t\t   __TRANS_JOIN_NOLOCK |\n\t\t\t\t\t   __TRANS_JOIN_NOSTART),\n\t[TRANS_STATE_COMPLETED]\t\t= (__TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN |\n\t\t\t\t\t   __TRANS_JOIN_NOLOCK |\n\t\t\t\t\t   __TRANS_JOIN_NOSTART),\n};\n\nvoid btrfs_put_transaction(struct btrfs_transaction *transaction)\n{\n\tWARN_ON(refcount_read(&transaction->use_count) == 0);\n\tif (refcount_dec_and_test(&transaction->use_count)) {\n\t\tBUG_ON(!list_empty(&transaction->list));\n\t\tWARN_ON(!RB_EMPTY_ROOT(\n\t\t\t\t&transaction->delayed_refs.href_root.rb_root));\n\t\tWARN_ON(!RB_EMPTY_ROOT(\n\t\t\t\t&transaction->delayed_refs.dirty_extent_root));\n\t\tif (transaction->delayed_refs.pending_csums)\n\t\t\tbtrfs_err(transaction->fs_info,\n\t\t\t\t  \"pending csums is %llu\",\n\t\t\t\t  transaction->delayed_refs.pending_csums);\n\t\t/*\n\t\t * If any block groups are found in ->deleted_bgs then it's\n\t\t * because the transaction was aborted and a commit did not\n\t\t * happen (things failed before writing the new superblock\n\t\t * and calling btrfs_finish_extent_commit()), so we can not\n\t\t * discard the physical locations of the block groups.\n\t\t */\n\t\twhile (!list_empty(&transaction->deleted_bgs)) {\n\t\t\tstruct btrfs_block_group *cache;\n\n\t\t\tcache = list_first_entry(&transaction->deleted_bgs,\n\t\t\t\t\t\t struct btrfs_block_group,\n\t\t\t\t\t\t bg_list);\n\t\t\tlist_del_init(&cache->bg_list);\n\t\t\tbtrfs_unfreeze_block_group(cache);\n\t\t\tbtrfs_put_block_group(cache);\n\t\t}\n\t\tWARN_ON(!list_empty(&transaction->dev_update_list));\n\t\tkfree(transaction);\n\t}\n}\n\nstatic noinline void switch_commit_roots(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_root *root, *tmp;\n\tstruct btrfs_caching_control *caching_ctl, *next;\n\n\tdown_write(&fs_info->commit_root_sem);\n\tlist_for_each_entry_safe(root, tmp, &cur_trans->switch_commits,\n\t\t\t\t dirty_list) {\n\t\tlist_del_init(&root->dirty_list);\n\t\tfree_extent_buffer(root->commit_root);\n\t\troot->commit_root = btrfs_root_node(root);\n\t\textent_io_tree_release(&root->dirty_log_pages);\n\t\tbtrfs_qgroup_clean_swapped_blocks(root);\n\t}\n\n\t/* We can free old roots now. */\n\tspin_lock(&cur_trans->dropped_roots_lock);\n\twhile (!list_empty(&cur_trans->dropped_roots)) {\n\t\troot = list_first_entry(&cur_trans->dropped_roots,\n\t\t\t\t\tstruct btrfs_root, root_list);\n\t\tlist_del_init(&root->root_list);\n\t\tspin_unlock(&cur_trans->dropped_roots_lock);\n\t\tbtrfs_free_log(trans, root);\n\t\tbtrfs_drop_and_free_fs_root(fs_info, root);\n\t\tspin_lock(&cur_trans->dropped_roots_lock);\n\t}\n\tspin_unlock(&cur_trans->dropped_roots_lock);\n\n\t/*\n\t * We have to update the last_byte_to_unpin under the commit_root_sem,\n\t * at the same time we swap out the commit roots.\n\t *\n\t * This is because we must have a real view of the last spot the caching\n\t * kthreads were while caching.  Consider the following views of the\n\t * extent tree for a block group\n\t *\n\t * commit root\n\t * +----+----+----+----+----+----+----+\n\t * |\\\\\\\\|    |\\\\\\\\|\\\\\\\\|    |\\\\\\\\|\\\\\\\\|\n\t * +----+----+----+----+----+----+----+\n\t * 0    1    2    3    4    5    6    7\n\t *\n\t * new commit root\n\t * +----+----+----+----+----+----+----+\n\t * |    |    |    |\\\\\\\\|    |    |\\\\\\\\|\n\t * +----+----+----+----+----+----+----+\n\t * 0    1    2    3    4    5    6    7\n\t *\n\t * If the cache_ctl->progress was at 3, then we are only allowed to\n\t * unpin [0,1) and [2,3], because the caching thread has already\n\t * processed those extents.  We are not allowed to unpin [5,6), because\n\t * the caching thread will re-start it's search from 3, and thus find\n\t * the hole from [4,6) to add to the free space cache.\n\t */\n\tspin_lock(&fs_info->block_group_cache_lock);\n\tlist_for_each_entry_safe(caching_ctl, next,\n\t\t\t\t &fs_info->caching_block_groups, list) {\n\t\tstruct btrfs_block_group *cache = caching_ctl->block_group;\n\n\t\tif (btrfs_block_group_done(cache)) {\n\t\t\tcache->last_byte_to_unpin = (u64)-1;\n\t\t\tlist_del_init(&caching_ctl->list);\n\t\t\tbtrfs_put_caching_control(caching_ctl);\n\t\t} else {\n\t\t\tcache->last_byte_to_unpin = caching_ctl->progress;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->block_group_cache_lock);\n\tup_write(&fs_info->commit_root_sem);\n}\n\nstatic inline void extwriter_counter_inc(struct btrfs_transaction *trans,\n\t\t\t\t\t unsigned int type)\n{\n\tif (type & TRANS_EXTWRITERS)\n\t\tatomic_inc(&trans->num_extwriters);\n}\n\nstatic inline void extwriter_counter_dec(struct btrfs_transaction *trans,\n\t\t\t\t\t unsigned int type)\n{\n\tif (type & TRANS_EXTWRITERS)\n\t\tatomic_dec(&trans->num_extwriters);\n}\n\nstatic inline void extwriter_counter_init(struct btrfs_transaction *trans,\n\t\t\t\t\t  unsigned int type)\n{\n\tatomic_set(&trans->num_extwriters, ((type & TRANS_EXTWRITERS) ? 1 : 0));\n}\n\nstatic inline int extwriter_counter_read(struct btrfs_transaction *trans)\n{\n\treturn atomic_read(&trans->num_extwriters);\n}\n\n/*\n * To be called after all the new block groups attached to the transaction\n * handle have been created (btrfs_create_pending_block_groups()).\n */\nvoid btrfs_trans_release_chunk_metadata(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\n\tif (!trans->chunk_bytes_reserved)\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&trans->new_bgs));\n\n\tbtrfs_block_rsv_release(fs_info, &fs_info->chunk_block_rsv,\n\t\t\t\ttrans->chunk_bytes_reserved, NULL);\n\tatomic64_sub(trans->chunk_bytes_reserved, &cur_trans->chunk_bytes_reserved);\n\tcond_wake_up(&cur_trans->chunk_reserve_wait);\n\ttrans->chunk_bytes_reserved = 0;\n}\n\n/*\n * either allocate a new transaction or hop into the existing one\n */\nstatic noinline int join_transaction(struct btrfs_fs_info *fs_info,\n\t\t\t\t     unsigned int type)\n{\n\tstruct btrfs_transaction *cur_trans;\n\n\tspin_lock(&fs_info->trans_lock);\nloop:\n\t/* The file system has been taken offline. No new transactions. */\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\treturn -EROFS;\n\t}\n\n\tcur_trans = fs_info->running_transaction;\n\tif (cur_trans) {\n\t\tif (TRANS_ABORTED(cur_trans)) {\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\treturn cur_trans->aborted;\n\t\t}\n\t\tif (btrfs_blocked_trans_types[cur_trans->state] & type) {\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\trefcount_inc(&cur_trans->use_count);\n\t\tatomic_inc(&cur_trans->num_writers);\n\t\textwriter_counter_inc(cur_trans, type);\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n\n\t/*\n\t * If we are ATTACH, we just want to catch the current transaction,\n\t * and commit it. If there is no transaction, just return ENOENT.\n\t */\n\tif (type == TRANS_ATTACH)\n\t\treturn -ENOENT;\n\n\t/*\n\t * JOIN_NOLOCK only happens during the transaction commit, so\n\t * it is impossible that ->running_transaction is NULL\n\t */\n\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\n\tcur_trans = kmalloc(sizeof(*cur_trans), GFP_NOFS);\n\tif (!cur_trans)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (fs_info->running_transaction) {\n\t\t/*\n\t\t * someone started a transaction after we unlocked.  Make sure\n\t\t * to redo the checks above\n\t\t */\n\t\tkfree(cur_trans);\n\t\tgoto loop;\n\t} else if (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\tkfree(cur_trans);\n\t\treturn -EROFS;\n\t}\n\n\tcur_trans->fs_info = fs_info;\n\tatomic_set(&cur_trans->pending_ordered, 0);\n\tinit_waitqueue_head(&cur_trans->pending_wait);\n\tatomic_set(&cur_trans->num_writers, 1);\n\textwriter_counter_init(cur_trans, type);\n\tinit_waitqueue_head(&cur_trans->writer_wait);\n\tinit_waitqueue_head(&cur_trans->commit_wait);\n\tcur_trans->state = TRANS_STATE_RUNNING;\n\t/*\n\t * One for this trans handle, one so it will live on until we\n\t * commit the transaction.\n\t */\n\trefcount_set(&cur_trans->use_count, 2);\n\tcur_trans->flags = 0;\n\tcur_trans->start_time = ktime_get_seconds();\n\n\tmemset(&cur_trans->delayed_refs, 0, sizeof(cur_trans->delayed_refs));\n\n\tcur_trans->delayed_refs.href_root = RB_ROOT_CACHED;\n\tcur_trans->delayed_refs.dirty_extent_root = RB_ROOT;\n\tatomic_set(&cur_trans->delayed_refs.num_entries, 0);\n\n\t/*\n\t * although the tree mod log is per file system and not per transaction,\n\t * the log must never go across transaction boundaries.\n\t */\n\tsmp_mb();\n\tif (!list_empty(&fs_info->tree_mod_seq_list))\n\t\tWARN(1, KERN_ERR \"BTRFS: tree_mod_seq_list not empty when creating a fresh transaction\\n\");\n\tif (!RB_EMPTY_ROOT(&fs_info->tree_mod_log))\n\t\tWARN(1, KERN_ERR \"BTRFS: tree_mod_log rb tree not empty when creating a fresh transaction\\n\");\n\tatomic64_set(&fs_info->tree_mod_seq, 0);\n\n\tspin_lock_init(&cur_trans->delayed_refs.lock);\n\n\tINIT_LIST_HEAD(&cur_trans->pending_snapshots);\n\tINIT_LIST_HEAD(&cur_trans->dev_update_list);\n\tINIT_LIST_HEAD(&cur_trans->switch_commits);\n\tINIT_LIST_HEAD(&cur_trans->dirty_bgs);\n\tINIT_LIST_HEAD(&cur_trans->io_bgs);\n\tINIT_LIST_HEAD(&cur_trans->dropped_roots);\n\tmutex_init(&cur_trans->cache_write_mutex);\n\tspin_lock_init(&cur_trans->dirty_bgs_lock);\n\tINIT_LIST_HEAD(&cur_trans->deleted_bgs);\n\tspin_lock_init(&cur_trans->dropped_roots_lock);\n\tINIT_LIST_HEAD(&cur_trans->releasing_ebs);\n\tspin_lock_init(&cur_trans->releasing_ebs_lock);\n\tatomic64_set(&cur_trans->chunk_bytes_reserved, 0);\n\tinit_waitqueue_head(&cur_trans->chunk_reserve_wait);\n\tlist_add_tail(&cur_trans->list, &fs_info->trans_list);\n\textent_io_tree_init(fs_info, &cur_trans->dirty_pages,\n\t\t\tIO_TREE_TRANS_DIRTY_PAGES, fs_info->btree_inode);\n\textent_io_tree_init(fs_info, &cur_trans->pinned_extents,\n\t\t\tIO_TREE_FS_PINNED_EXTENTS, NULL);\n\tfs_info->generation++;\n\tcur_trans->transid = fs_info->generation;\n\tfs_info->running_transaction = cur_trans;\n\tcur_trans->aborted = 0;\n\tspin_unlock(&fs_info->trans_lock);\n\n\treturn 0;\n}\n\n/*\n * This does all the record keeping required to make sure that a shareable root\n * is properly recorded in a given transaction.  This is required to make sure\n * the old root from before we joined the transaction is deleted when the\n * transaction commits.\n */\nstatic int record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       int force)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret = 0;\n\n\tif ((test_bit(BTRFS_ROOT_SHAREABLE, &root->state) &&\n\t    root->last_trans < trans->transid) || force) {\n\t\tWARN_ON(root == fs_info->extent_root);\n\t\tWARN_ON(!force && root->commit_root != root->node);\n\n\t\t/*\n\t\t * see below for IN_TRANS_SETUP usage rules\n\t\t * we have the reloc mutex held now, so there\n\t\t * is only one writer in this function\n\t\t */\n\t\tset_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state);\n\n\t\t/* make sure readers find IN_TRANS_SETUP before\n\t\t * they find our root->last_trans update\n\t\t */\n\t\tsmp_wmb();\n\n\t\tspin_lock(&fs_info->fs_roots_radix_lock);\n\t\tif (root->last_trans == trans->transid && !force) {\n\t\t\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tradix_tree_tag_set(&fs_info->fs_roots_radix,\n\t\t\t\t   (unsigned long)root->root_key.objectid,\n\t\t\t\t   BTRFS_ROOT_TRANS_TAG);\n\t\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\t\troot->last_trans = trans->transid;\n\n\t\t/* this is pretty tricky.  We don't want to\n\t\t * take the relocation lock in btrfs_record_root_in_trans\n\t\t * unless we're really doing the first setup for this root in\n\t\t * this transaction.\n\t\t *\n\t\t * Normally we'd use root->last_trans as a flag to decide\n\t\t * if we want to take the expensive mutex.\n\t\t *\n\t\t * But, we have to set root->last_trans before we\n\t\t * init the relocation root, otherwise, we trip over warnings\n\t\t * in ctree.c.  The solution used here is to flag ourselves\n\t\t * with root IN_TRANS_SETUP.  When this is 1, we're still\n\t\t * fixing up the reloc trees and everyone must wait.\n\t\t *\n\t\t * When this is zero, they can trust root->last_trans and fly\n\t\t * through btrfs_record_root_in_trans without having to take the\n\t\t * lock.  smp_wmb() makes sure that all the writes above are\n\t\t * done before we pop in the zero below\n\t\t */\n\t\tret = btrfs_init_reloc_root(trans, root);\n\t\tsmp_mb__before_atomic();\n\t\tclear_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state);\n\t}\n\treturn ret;\n}\n\n\nvoid btrfs_add_dropped_root(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\n\t/* Add ourselves to the transaction dropped list */\n\tspin_lock(&cur_trans->dropped_roots_lock);\n\tlist_add_tail(&root->root_list, &cur_trans->dropped_roots);\n\tspin_unlock(&cur_trans->dropped_roots_lock);\n\n\t/* Make sure we don't try to update the root at commit time */\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\tradix_tree_tag_clear(&fs_info->fs_roots_radix,\n\t\t\t     (unsigned long)root->root_key.objectid,\n\t\t\t     BTRFS_ROOT_TRANS_TAG);\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n}\n\nint btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\n\tif (!test_bit(BTRFS_ROOT_SHAREABLE, &root->state))\n\t\treturn 0;\n\n\t/*\n\t * see record_root_in_trans for comments about IN_TRANS_SETUP usage\n\t * and barriers\n\t */\n\tsmp_rmb();\n\tif (root->last_trans == trans->transid &&\n\t    !test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\n\t\treturn 0;\n\n\tmutex_lock(&fs_info->reloc_mutex);\n\tret = record_root_in_trans(trans, root, 0);\n\tmutex_unlock(&fs_info->reloc_mutex);\n\n\treturn ret;\n}\n\nstatic inline int is_transaction_blocked(struct btrfs_transaction *trans)\n{\n\treturn (trans->state >= TRANS_STATE_COMMIT_START &&\n\t\ttrans->state < TRANS_STATE_UNBLOCKED &&\n\t\t!TRANS_ABORTED(trans));\n}\n\n/* wait for commit against the current transaction to become unblocked\n * when this is done, it is safe to start a new transaction, but the current\n * transaction might not be fully on disk.\n */\nstatic void wait_current_trans(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_transaction *cur_trans;\n\n\tspin_lock(&fs_info->trans_lock);\n\tcur_trans = fs_info->running_transaction;\n\tif (cur_trans && is_transaction_blocked(cur_trans)) {\n\t\trefcount_inc(&cur_trans->use_count);\n\t\tspin_unlock(&fs_info->trans_lock);\n\n\t\twait_event(fs_info->transaction_wait,\n\t\t\t   cur_trans->state >= TRANS_STATE_UNBLOCKED ||\n\t\t\t   TRANS_ABORTED(cur_trans));\n\t\tbtrfs_put_transaction(cur_trans);\n\t} else {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t}\n}\n\nstatic int may_wait_transaction(struct btrfs_fs_info *fs_info, int type)\n{\n\tif (test_bit(BTRFS_FS_LOG_RECOVERING, &fs_info->flags))\n\t\treturn 0;\n\n\tif (type == TRANS_START)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic inline bool need_reserve_reloc_root(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (!fs_info->reloc_ctl ||\n\t    !test_bit(BTRFS_ROOT_SHAREABLE, &root->state) ||\n\t    root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID ||\n\t    root->reloc_root)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic struct btrfs_trans_handle *\nstart_transaction(struct btrfs_root *root, unsigned int num_items,\n\t\t  unsigned int type, enum btrfs_reserve_flush_enum flush,\n\t\t  bool enforce_qgroups)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_block_rsv *delayed_refs_rsv = &fs_info->delayed_refs_rsv;\n\tstruct btrfs_trans_handle *h;\n\tstruct btrfs_transaction *cur_trans;\n\tu64 num_bytes = 0;\n\tu64 qgroup_reserved = 0;\n\tbool reloc_reserved = false;\n\tbool do_chunk_alloc = false;\n\tint ret;\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (current->journal_info) {\n\t\tWARN_ON(type & TRANS_EXTWRITERS);\n\t\th = current->journal_info;\n\t\trefcount_inc(&h->use_count);\n\t\tWARN_ON(refcount_read(&h->use_count) > 2);\n\t\th->orig_rsv = h->block_rsv;\n\t\th->block_rsv = NULL;\n\t\tgoto got_it;\n\t}\n\n\t/*\n\t * Do the reservation before we join the transaction so we can do all\n\t * the appropriate flushing if need be.\n\t */\n\tif (num_items && root != fs_info->chunk_root) {\n\t\tstruct btrfs_block_rsv *rsv = &fs_info->trans_block_rsv;\n\t\tu64 delayed_refs_bytes = 0;\n\n\t\tqgroup_reserved = num_items * fs_info->nodesize;\n\t\tret = btrfs_qgroup_reserve_meta_pertrans(root, qgroup_reserved,\n\t\t\t\tenforce_qgroups);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\n\t\t/*\n\t\t * We want to reserve all the bytes we may need all at once, so\n\t\t * we only do 1 enospc flushing cycle per transaction start.  We\n\t\t * accomplish this by simply assuming we'll do 2 x num_items\n\t\t * worth of delayed refs updates in this trans handle, and\n\t\t * refill that amount for whatever is missing in the reserve.\n\t\t */\n\t\tnum_bytes = btrfs_calc_insert_metadata_size(fs_info, num_items);\n\t\tif (flush == BTRFS_RESERVE_FLUSH_ALL &&\n\t\t    delayed_refs_rsv->full == 0) {\n\t\t\tdelayed_refs_bytes = num_bytes;\n\t\t\tnum_bytes <<= 1;\n\t\t}\n\n\t\t/*\n\t\t * Do the reservation for the relocation root creation\n\t\t */\n\t\tif (need_reserve_reloc_root(root)) {\n\t\t\tnum_bytes += fs_info->nodesize;\n\t\t\treloc_reserved = true;\n\t\t}\n\n\t\tret = btrfs_block_rsv_add(root, rsv, num_bytes, flush);\n\t\tif (ret)\n\t\t\tgoto reserve_fail;\n\t\tif (delayed_refs_bytes) {\n\t\t\tbtrfs_migrate_to_delayed_refs_rsv(fs_info, rsv,\n\t\t\t\t\t\t\t  delayed_refs_bytes);\n\t\t\tnum_bytes -= delayed_refs_bytes;\n\t\t}\n\n\t\tif (rsv->space_info->force_alloc)\n\t\t\tdo_chunk_alloc = true;\n\t} else if (num_items == 0 && flush == BTRFS_RESERVE_FLUSH_ALL &&\n\t\t   !delayed_refs_rsv->full) {\n\t\t/*\n\t\t * Some people call with btrfs_start_transaction(root, 0)\n\t\t * because they can be throttled, but have some other mechanism\n\t\t * for reserving space.  We still want these guys to refill the\n\t\t * delayed block_rsv so just add 1 items worth of reservation\n\t\t * here.\n\t\t */\n\t\tret = btrfs_delayed_refs_rsv_refill(fs_info, flush);\n\t\tif (ret)\n\t\t\tgoto reserve_fail;\n\t}\nagain:\n\th = kmem_cache_zalloc(btrfs_trans_handle_cachep, GFP_NOFS);\n\tif (!h) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t/*\n\t * If we are JOIN_NOLOCK we're already committing a transaction and\n\t * waiting on this guy, so we don't need to do the sb_start_intwrite\n\t * because we're already holding a ref.  We need this because we could\n\t * have raced in and did an fsync() on a file which can kick a commit\n\t * and then we deadlock with somebody doing a freeze.\n\t *\n\t * If we are ATTACH, it means we just want to catch the current\n\t * transaction and commit it, so we needn't do sb_start_intwrite(). \n\t */\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_start_intwrite(fs_info->sb);\n\n\tif (may_wait_transaction(fs_info, type))\n\t\twait_current_trans(fs_info);\n\n\tdo {\n\t\tret = join_transaction(fs_info, type);\n\t\tif (ret == -EBUSY) {\n\t\t\twait_current_trans(fs_info);\n\t\t\tif (unlikely(type == TRANS_ATTACH ||\n\t\t\t\t     type == TRANS_JOIN_NOSTART))\n\t\t\t\tret = -ENOENT;\n\t\t}\n\t} while (ret == -EBUSY);\n\n\tif (ret < 0)\n\t\tgoto join_fail;\n\n\tcur_trans = fs_info->running_transaction;\n\n\th->transid = cur_trans->transid;\n\th->transaction = cur_trans;\n\th->root = root;\n\trefcount_set(&h->use_count, 1);\n\th->fs_info = root->fs_info;\n\n\th->type = type;\n\th->can_flush_pending_bgs = true;\n\tINIT_LIST_HEAD(&h->new_bgs);\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START &&\n\t    may_wait_transaction(fs_info, type)) {\n\t\tcurrent->journal_info = h;\n\t\tbtrfs_commit_transaction(h);\n\t\tgoto again;\n\t}\n\n\tif (num_bytes) {\n\t\ttrace_btrfs_space_reservation(fs_info, \"transaction\",\n\t\t\t\t\t      h->transid, num_bytes, 1);\n\t\th->block_rsv = &fs_info->trans_block_rsv;\n\t\th->bytes_reserved = num_bytes;\n\t\th->reloc_reserved = reloc_reserved;\n\t}\n\ngot_it:\n\tif (!current->journal_info)\n\t\tcurrent->journal_info = h;\n\n\t/*\n\t * If the space_info is marked ALLOC_FORCE then we'll get upgraded to\n\t * ALLOC_FORCE the first run through, and then we won't allocate for\n\t * anybody else who races in later.  We don't care about the return\n\t * value here.\n\t */\n\tif (do_chunk_alloc && num_bytes) {\n\t\tu64 flags = h->block_rsv->space_info->flags;\n\n\t\tbtrfs_chunk_alloc(h, btrfs_get_alloc_profile(fs_info, flags),\n\t\t\t\t  CHUNK_ALLOC_NO_FORCE);\n\t}\n\n\t/*\n\t * btrfs_record_root_in_trans() needs to alloc new extents, and may\n\t * call btrfs_join_transaction() while we're also starting a\n\t * transaction.\n\t *\n\t * Thus it need to be called after current->journal_info initialized,\n\t * or we can deadlock.\n\t */\n\tret = btrfs_record_root_in_trans(h, root);\n\tif (ret) {\n\t\t/*\n\t\t * The transaction handle is fully initialized and linked with\n\t\t * other structures so it needs to be ended in case of errors,\n\t\t * not just freed.\n\t\t */\n\t\tbtrfs_end_transaction(h);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn h;\n\njoin_fail:\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(fs_info->sb);\n\tkmem_cache_free(btrfs_trans_handle_cachep, h);\nalloc_fail:\n\tif (num_bytes)\n\t\tbtrfs_block_rsv_release(fs_info, &fs_info->trans_block_rsv,\n\t\t\t\t\tnum_bytes, NULL);\nreserve_fail:\n\tbtrfs_qgroup_free_meta_pertrans(root, qgroup_reserved);\n\treturn ERR_PTR(ret);\n}\n\nstruct btrfs_trans_handle *btrfs_start_transaction(struct btrfs_root *root,\n\t\t\t\t\t\t   unsigned int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_ALL, true);\n}\n\nstruct btrfs_trans_handle *btrfs_start_transaction_fallback_global_rsv(\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tunsigned int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_ALL_STEAL, false);\n}\n\nstruct btrfs_trans_handle *btrfs_join_transaction(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN, BTRFS_RESERVE_NO_FLUSH,\n\t\t\t\t true);\n}\n\nstruct btrfs_trans_handle *btrfs_join_transaction_spacecache(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK,\n\t\t\t\t BTRFS_RESERVE_NO_FLUSH, true);\n}\n\n/*\n * Similar to regular join but it never starts a transaction when none is\n * running or after waiting for the current one to finish.\n */\nstruct btrfs_trans_handle *btrfs_join_transaction_nostart(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOSTART,\n\t\t\t\t BTRFS_RESERVE_NO_FLUSH, true);\n}\n\n/*\n * btrfs_attach_transaction() - catch the running transaction\n *\n * It is used when we want to commit the current the transaction, but\n * don't want to start a new one.\n *\n * Note: If this function return -ENOENT, it just means there is no\n * running transaction. But it is possible that the inactive transaction\n * is still in the memory, not fully on disk. If you hope there is no\n * inactive transaction in the fs when -ENOENT is returned, you should\n * invoke\n *     btrfs_attach_transaction_barrier()\n */\nstruct btrfs_trans_handle *btrfs_attach_transaction(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_ATTACH,\n\t\t\t\t BTRFS_RESERVE_NO_FLUSH, true);\n}\n\n/*\n * btrfs_attach_transaction_barrier() - catch the running transaction\n *\n * It is similar to the above function, the difference is this one\n * will wait for all the inactive transactions until they fully\n * complete.\n */\nstruct btrfs_trans_handle *\nbtrfs_attach_transaction_barrier(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = start_transaction(root, 0, TRANS_ATTACH,\n\t\t\t\t  BTRFS_RESERVE_NO_FLUSH, true);\n\tif (trans == ERR_PTR(-ENOENT))\n\t\tbtrfs_wait_for_commit(root->fs_info, 0);\n\n\treturn trans;\n}\n\n/* Wait for a transaction commit to reach at least the given state. */\nstatic noinline void wait_for_commit(struct btrfs_transaction *commit,\n\t\t\t\t     const enum btrfs_trans_state min_state)\n{\n\twait_event(commit->commit_wait, commit->state >= min_state);\n}\n\nint btrfs_wait_for_commit(struct btrfs_fs_info *fs_info, u64 transid)\n{\n\tstruct btrfs_transaction *cur_trans = NULL, *t;\n\tint ret = 0;\n\n\tif (transid) {\n\t\tif (transid <= fs_info->last_trans_committed)\n\t\t\tgoto out;\n\n\t\t/* find specified transaction */\n\t\tspin_lock(&fs_info->trans_lock);\n\t\tlist_for_each_entry(t, &fs_info->trans_list, list) {\n\t\t\tif (t->transid == transid) {\n\t\t\t\tcur_trans = t;\n\t\t\t\trefcount_inc(&cur_trans->use_count);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t->transid > transid) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&fs_info->trans_lock);\n\n\t\t/*\n\t\t * The specified transaction doesn't exist, or we\n\t\t * raced with btrfs_commit_transaction\n\t\t */\n\t\tif (!cur_trans) {\n\t\t\tif (transid > fs_info->last_trans_committed)\n\t\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* find newest transaction that is committing | committed */\n\t\tspin_lock(&fs_info->trans_lock);\n\t\tlist_for_each_entry_reverse(t, &fs_info->trans_list,\n\t\t\t\t\t    list) {\n\t\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\t\tif (t->state == TRANS_STATE_COMPLETED)\n\t\t\t\t\tbreak;\n\t\t\t\tcur_trans = t;\n\t\t\t\trefcount_inc(&cur_trans->use_count);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\tif (!cur_trans)\n\t\t\tgoto out;  /* nothing committing|committed */\n\t}\n\n\twait_for_commit(cur_trans, TRANS_STATE_COMPLETED);\n\tbtrfs_put_transaction(cur_trans);\nout:\n\treturn ret;\n}\n\nvoid btrfs_throttle(struct btrfs_fs_info *fs_info)\n{\n\twait_current_trans(fs_info);\n}\n\nstatic bool should_end_transaction(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\n\tif (btrfs_check_space_for_delayed_refs(fs_info))\n\t\treturn true;\n\n\treturn !!btrfs_block_rsv_check(&fs_info->global_block_rsv, 5);\n}\n\nbool btrfs_should_end_transaction(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START ||\n\t    test_bit(BTRFS_DELAYED_REFS_FLUSHING, &cur_trans->delayed_refs.flags))\n\t\treturn true;\n\n\treturn should_end_transaction(trans);\n}\n\nstatic void btrfs_trans_release_metadata(struct btrfs_trans_handle *trans)\n\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\n\tif (!trans->block_rsv) {\n\t\tASSERT(!trans->bytes_reserved);\n\t\treturn;\n\t}\n\n\tif (!trans->bytes_reserved)\n\t\treturn;\n\n\tASSERT(trans->block_rsv == &fs_info->trans_block_rsv);\n\ttrace_btrfs_space_reservation(fs_info, \"transaction\",\n\t\t\t\t      trans->transid, trans->bytes_reserved, 0);\n\tbtrfs_block_rsv_release(fs_info, trans->block_rsv,\n\t\t\t\ttrans->bytes_reserved, NULL);\n\ttrans->bytes_reserved = 0;\n}\n\nstatic int __btrfs_end_transaction(struct btrfs_trans_handle *trans,\n\t\t\t\t   int throttle)\n{\n\tstruct btrfs_fs_info *info = trans->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tint err = 0;\n\n\tif (refcount_read(&trans->use_count) > 1) {\n\t\trefcount_dec(&trans->use_count);\n\t\ttrans->block_rsv = trans->orig_rsv;\n\t\treturn 0;\n\t}\n\n\tbtrfs_trans_release_metadata(trans);\n\ttrans->block_rsv = NULL;\n\n\tbtrfs_create_pending_block_groups(trans);\n\n\tbtrfs_trans_release_chunk_metadata(trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(info->sb);\n\n\tWARN_ON(cur_trans != info->running_transaction);\n\tWARN_ON(atomic_read(&cur_trans->num_writers) < 1);\n\tatomic_dec(&cur_trans->num_writers);\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tcond_wake_up(&cur_trans->writer_wait);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tif (throttle)\n\t\tbtrfs_run_delayed_iputs(info);\n\n\tif (TRANS_ABORTED(trans) ||\n\t    test_bit(BTRFS_FS_STATE_ERROR, &info->fs_state)) {\n\t\twake_up_process(info->transaction_kthread);\n\t\tif (TRANS_ABORTED(trans))\n\t\t\terr = trans->aborted;\n\t\telse\n\t\t\terr = -EROFS;\n\t}\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\treturn err;\n}\n\nint btrfs_end_transaction(struct btrfs_trans_handle *trans)\n{\n\treturn __btrfs_end_transaction(trans, 0);\n}\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans)\n{\n\treturn __btrfs_end_transaction(trans, 1);\n}\n\n/*\n * when btree blocks are allocated, they have some corresponding bits set for\n * them in one of two extent_io trees.  This is used to make sure all of\n * those extents are sent to disk but does not wait on them\n */\nint btrfs_write_marked_extents(struct btrfs_fs_info *fs_info,\n\t\t\t       struct extent_io_tree *dirty_pages, int mark)\n{\n\tint err = 0;\n\tint werr = 0;\n\tstruct address_space *mapping = fs_info->btree_inode->i_mapping;\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = 0;\n\tu64 end;\n\n\tatomic_inc(&BTRFS_I(fs_info->btree_inode)->sync_writers);\n\twhile (!find_first_extent_bit(dirty_pages, start, &start, &end,\n\t\t\t\t      mark, &cached_state)) {\n\t\tbool wait_writeback = false;\n\n\t\terr = convert_extent_bit(dirty_pages, start, end,\n\t\t\t\t\t EXTENT_NEED_WAIT,\n\t\t\t\t\t mark, &cached_state);\n\t\t/*\n\t\t * convert_extent_bit can return -ENOMEM, which is most of the\n\t\t * time a temporary error. So when it happens, ignore the error\n\t\t * and wait for writeback of this range to finish - because we\n\t\t * failed to set the bit EXTENT_NEED_WAIT for the range, a call\n\t\t * to __btrfs_wait_marked_extents() would not know that\n\t\t * writeback for this range started and therefore wouldn't\n\t\t * wait for it to finish - we don't want to commit a\n\t\t * superblock that points to btree nodes/leafs for which\n\t\t * writeback hasn't finished yet (and without errors).\n\t\t * We cleanup any entries left in the io tree when committing\n\t\t * the transaction (through extent_io_tree_release()).\n\t\t */\n\t\tif (err == -ENOMEM) {\n\t\t\terr = 0;\n\t\t\twait_writeback = true;\n\t\t}\n\t\tif (!err)\n\t\t\terr = filemap_fdatawrite_range(mapping, start, end);\n\t\tif (err)\n\t\t\twerr = err;\n\t\telse if (wait_writeback)\n\t\t\twerr = filemap_fdatawait_range(mapping, start, end);\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tcond_resched();\n\t\tstart = end + 1;\n\t}\n\tatomic_dec(&BTRFS_I(fs_info->btree_inode)->sync_writers);\n\treturn werr;\n}\n\n/*\n * when btree blocks are allocated, they have some corresponding bits set for\n * them in one of two extent_io trees.  This is used to make sure all of\n * those extents are on disk for transaction or log commit.  We wait\n * on all the pages and clear them from the dirty pages state tree\n */\nstatic int __btrfs_wait_marked_extents(struct btrfs_fs_info *fs_info,\n\t\t\t\t       struct extent_io_tree *dirty_pages)\n{\n\tint err = 0;\n\tint werr = 0;\n\tstruct address_space *mapping = fs_info->btree_inode->i_mapping;\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = 0;\n\tu64 end;\n\n\twhile (!find_first_extent_bit(dirty_pages, start, &start, &end,\n\t\t\t\t      EXTENT_NEED_WAIT, &cached_state)) {\n\t\t/*\n\t\t * Ignore -ENOMEM errors returned by clear_extent_bit().\n\t\t * When committing the transaction, we'll remove any entries\n\t\t * left in the io tree. For a log commit, we don't remove them\n\t\t * after committing the log because the tree can be accessed\n\t\t * concurrently - we do it only at transaction commit time when\n\t\t * it's safe to do it (through extent_io_tree_release()).\n\t\t */\n\t\terr = clear_extent_bit(dirty_pages, start, end,\n\t\t\t\t       EXTENT_NEED_WAIT, 0, 0, &cached_state);\n\t\tif (err == -ENOMEM)\n\t\t\terr = 0;\n\t\tif (!err)\n\t\t\terr = filemap_fdatawait_range(mapping, start, end);\n\t\tif (err)\n\t\t\twerr = err;\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tcond_resched();\n\t\tstart = end + 1;\n\t}\n\tif (err)\n\t\twerr = err;\n\treturn werr;\n}\n\nstatic int btrfs_wait_extents(struct btrfs_fs_info *fs_info,\n\t\t       struct extent_io_tree *dirty_pages)\n{\n\tbool errors = false;\n\tint err;\n\n\terr = __btrfs_wait_marked_extents(fs_info, dirty_pages);\n\tif (test_and_clear_bit(BTRFS_FS_BTREE_ERR, &fs_info->flags))\n\t\terrors = true;\n\n\tif (errors && !err)\n\t\terr = -EIO;\n\treturn err;\n}\n\nint btrfs_wait_tree_log_extents(struct btrfs_root *log_root, int mark)\n{\n\tstruct btrfs_fs_info *fs_info = log_root->fs_info;\n\tstruct extent_io_tree *dirty_pages = &log_root->dirty_log_pages;\n\tbool errors = false;\n\tint err;\n\n\tASSERT(log_root->root_key.objectid == BTRFS_TREE_LOG_OBJECTID);\n\n\terr = __btrfs_wait_marked_extents(fs_info, dirty_pages);\n\tif ((mark & EXTENT_DIRTY) &&\n\t    test_and_clear_bit(BTRFS_FS_LOG1_ERR, &fs_info->flags))\n\t\terrors = true;\n\n\tif ((mark & EXTENT_NEW) &&\n\t    test_and_clear_bit(BTRFS_FS_LOG2_ERR, &fs_info->flags))\n\t\terrors = true;\n\n\tif (errors && !err)\n\t\terr = -EIO;\n\treturn err;\n}\n\n/*\n * When btree blocks are allocated the corresponding extents are marked dirty.\n * This function ensures such extents are persisted on disk for transaction or\n * log commit.\n *\n * @trans: transaction whose dirty pages we'd like to write\n */\nstatic int btrfs_write_and_wait_transaction(struct btrfs_trans_handle *trans)\n{\n\tint ret;\n\tint ret2;\n\tstruct extent_io_tree *dirty_pages = &trans->transaction->dirty_pages;\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\tret = btrfs_write_marked_extents(fs_info, dirty_pages, EXTENT_DIRTY);\n\tblk_finish_plug(&plug);\n\tret2 = btrfs_wait_extents(fs_info, dirty_pages);\n\n\textent_io_tree_release(&trans->transaction->dirty_pages);\n\n\tif (ret)\n\t\treturn ret;\n\telse if (ret2)\n\t\treturn ret2;\n\telse\n\t\treturn 0;\n}\n\n/*\n * this is used to update the root pointer in the tree of tree roots.\n *\n * But, in the case of the extent allocation tree, updating the root\n * pointer may allocate blocks which may change the root of the extent\n * allocation tree.\n *\n * So, this loops and repeats and makes sure the cowonly root didn't\n * change while the root pointer was being updated in the metadata.\n */\nstatic int update_cowonly_root(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tint ret;\n\tu64 old_root_bytenr;\n\tu64 old_root_used;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\n\told_root_used = btrfs_root_used(&root->root_item);\n\n\twhile (1) {\n\t\told_root_bytenr = btrfs_root_bytenr(&root->root_item);\n\t\tif (old_root_bytenr == root->node->start &&\n\t\t    old_root_used == btrfs_root_used(&root->root_item))\n\t\t\tbreak;\n\n\t\tbtrfs_set_root_node(&root->root_item, root->node);\n\t\tret = btrfs_update_root(trans, tree_root,\n\t\t\t\t\t&root->root_key,\n\t\t\t\t\t&root->root_item);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\told_root_used = btrfs_root_used(&root->root_item);\n\t}\n\n\treturn 0;\n}\n\n/*\n * update all the cowonly tree roots on disk\n *\n * The error handling in this function may not be obvious. Any of the\n * failures will cause the file system to go offline. We still need\n * to clean up the delayed refs.\n */\nstatic noinline int commit_cowonly_roots(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct list_head *dirty_bgs = &trans->transaction->dirty_bgs;\n\tstruct list_head *io_bgs = &trans->transaction->io_bgs;\n\tstruct list_head *next;\n\tstruct extent_buffer *eb;\n\tint ret;\n\n\teb = btrfs_lock_root_node(fs_info->tree_root);\n\tret = btrfs_cow_block(trans, fs_info->tree_root, eb, NULL,\n\t\t\t      0, &eb, BTRFS_NESTING_COW);\n\tbtrfs_tree_unlock(eb);\n\tfree_extent_buffer(eb);\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_run_dev_stats(trans);\n\tif (ret)\n\t\treturn ret;\n\tret = btrfs_run_dev_replace(trans);\n\tif (ret)\n\t\treturn ret;\n\tret = btrfs_run_qgroups(trans);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_setup_space_cache(trans);\n\tif (ret)\n\t\treturn ret;\n\nagain:\n\twhile (!list_empty(&fs_info->dirty_cowonly_roots)) {\n\t\tstruct btrfs_root *root;\n\t\tnext = fs_info->dirty_cowonly_roots.next;\n\t\tlist_del_init(next);\n\t\troot = list_entry(next, struct btrfs_root, dirty_list);\n\t\tclear_bit(BTRFS_ROOT_DIRTY, &root->state);\n\n\t\tif (root != fs_info->extent_root)\n\t\t\tlist_add_tail(&root->dirty_list,\n\t\t\t\t      &trans->transaction->switch_commits);\n\t\tret = update_cowonly_root(trans, root);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Now flush any delayed refs generated by updating all of the roots */\n\tret = btrfs_run_delayed_refs(trans, (unsigned long)-1);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (!list_empty(dirty_bgs) || !list_empty(io_bgs)) {\n\t\tret = btrfs_write_dirty_block_groups(trans);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * We're writing the dirty block groups, which could generate\n\t\t * delayed refs, which could generate more dirty block groups,\n\t\t * so we want to keep this flushing in this loop to make sure\n\t\t * everything gets run.\n\t\t */\n\t\tret = btrfs_run_delayed_refs(trans, (unsigned long)-1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!list_empty(&fs_info->dirty_cowonly_roots))\n\t\tgoto again;\n\n\tlist_add_tail(&fs_info->extent_root->dirty_list,\n\t\t      &trans->transaction->switch_commits);\n\n\t/* Update dev-replace pointer once everything is committed */\n\tfs_info->dev_replace.committed_cursor_left =\n\t\tfs_info->dev_replace.cursor_left_last_write_of_item;\n\n\treturn 0;\n}\n\n/*\n * dead roots are old snapshots that need to be deleted.  This allocates\n * a dirty root struct and adds it into the list of dead roots that need to\n * be deleted\n */\nvoid btrfs_add_dead_root(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (list_empty(&root->root_list)) {\n\t\tbtrfs_grab_root(root);\n\t\tlist_add_tail(&root->root_list, &fs_info->dead_roots);\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n}\n\n/*\n * update all the cowonly tree roots on disk\n */\nstatic noinline int commit_fs_roots(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_root *gang[8];\n\tint i;\n\tint ret;\n\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\twhile (1) {\n\t\tret = radix_tree_gang_lookup_tag(&fs_info->fs_roots_radix,\n\t\t\t\t\t\t (void **)gang, 0,\n\t\t\t\t\t\t ARRAY_SIZE(gang),\n\t\t\t\t\t\t BTRFS_ROOT_TRANS_TAG);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tstruct btrfs_root *root = gang[i];\n\t\t\tint ret2;\n\n\t\t\tradix_tree_tag_clear(&fs_info->fs_roots_radix,\n\t\t\t\t\t(unsigned long)root->root_key.objectid,\n\t\t\t\t\tBTRFS_ROOT_TRANS_TAG);\n\t\t\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\n\t\t\tbtrfs_free_log(trans, root);\n\t\t\tret2 = btrfs_update_reloc_root(trans, root);\n\t\t\tif (ret2)\n\t\t\t\treturn ret2;\n\n\t\t\t/* see comments in should_cow_block() */\n\t\t\tclear_bit(BTRFS_ROOT_FORCE_COW, &root->state);\n\t\t\tsmp_mb__after_atomic();\n\n\t\t\tif (root->commit_root != root->node) {\n\t\t\t\tlist_add_tail(&root->dirty_list,\n\t\t\t\t\t&trans->transaction->switch_commits);\n\t\t\t\tbtrfs_set_root_node(&root->root_item,\n\t\t\t\t\t\t    root->node);\n\t\t\t}\n\n\t\t\tret2 = btrfs_update_root(trans, fs_info->tree_root,\n\t\t\t\t\t\t&root->root_key,\n\t\t\t\t\t\t&root->root_item);\n\t\t\tif (ret2)\n\t\t\t\treturn ret2;\n\t\t\tspin_lock(&fs_info->fs_roots_radix_lock);\n\t\t\tbtrfs_qgroup_free_meta_all_pertrans(root);\n\t\t}\n\t}\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\treturn 0;\n}\n\n/*\n * defrag a given btree.\n * Every leaf in the btree is read and defragged.\n */\nint btrfs_defrag_root(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *info = root->fs_info;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\tif (test_and_set_bit(BTRFS_ROOT_DEFRAG_RUNNING, &root->state))\n\t\treturn 0;\n\n\twhile (1) {\n\t\ttrans = btrfs_start_transaction(root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = btrfs_defrag_leaves(trans, root);\n\n\t\tbtrfs_end_transaction(trans);\n\t\tbtrfs_btree_balance_dirty(info);\n\t\tcond_resched();\n\n\t\tif (btrfs_fs_closing(info) || ret != -EAGAIN)\n\t\t\tbreak;\n\n\t\tif (btrfs_defrag_cancelled(info)) {\n\t\t\tbtrfs_debug(info, \"defrag_root cancelled\");\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tclear_bit(BTRFS_ROOT_DEFRAG_RUNNING, &root->state);\n\treturn ret;\n}\n\n/*\n * Do all special snapshot related qgroup dirty hack.\n *\n * Will do all needed qgroup inherit and dirty hack like switch commit\n * roots inside one transaction and write all btree into disk, to make\n * qgroup works.\n */\nstatic int qgroup_account_snapshot(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *src,\n\t\t\t\t   struct btrfs_root *parent,\n\t\t\t\t   struct btrfs_qgroup_inherit *inherit,\n\t\t\t\t   u64 dst_objectid)\n{\n\tstruct btrfs_fs_info *fs_info = src->fs_info;\n\tint ret;\n\n\t/*\n\t * Save some performance in the case that qgroups are not\n\t * enabled. If this check races with the ioctl, rescan will\n\t * kick in anyway.\n\t */\n\tif (!test_bit(BTRFS_FS_QUOTA_ENABLED, &fs_info->flags))\n\t\treturn 0;\n\n\t/*\n\t * Ensure dirty @src will be committed.  Or, after coming\n\t * commit_fs_roots() and switch_commit_roots(), any dirty but not\n\t * recorded root will never be updated again, causing an outdated root\n\t * item.\n\t */\n\tret = record_root_in_trans(trans, src, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * btrfs_qgroup_inherit relies on a consistent view of the usage for the\n\t * src root, so we must run the delayed refs here.\n\t *\n\t * However this isn't particularly fool proof, because there's no\n\t * synchronization keeping us from changing the tree after this point\n\t * before we do the qgroup_inherit, or even from making changes while\n\t * we're doing the qgroup_inherit.  But that's a problem for the future,\n\t * for now flush the delayed refs to narrow the race window where the\n\t * qgroup counters could end up wrong.\n\t */\n\tret = btrfs_run_delayed_refs(trans, (unsigned long)-1);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * We are going to commit transaction, see btrfs_commit_transaction()\n\t * comment for reason locking tree_log_mutex\n\t */\n\tmutex_lock(&fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans);\n\tif (ret)\n\t\tgoto out;\n\tret = btrfs_qgroup_account_extents(trans);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* Now qgroup are all updated, we can inherit it to new qgroups */\n\tret = btrfs_qgroup_inherit(trans, src->root_key.objectid, dst_objectid,\n\t\t\t\t   inherit);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * Now we do a simplified commit transaction, which will:\n\t * 1) commit all subvolume and extent tree\n\t *    To ensure all subvolume and extent tree have a valid\n\t *    commit_root to accounting later insert_dir_item()\n\t * 2) write all btree blocks onto disk\n\t *    This is to make sure later btree modification will be cowed\n\t *    Or commit_root can be populated and cause wrong qgroup numbers\n\t * In this simplified commit, we don't really care about other trees\n\t * like chunk and root tree, as they won't affect qgroup.\n\t * And we don't write super to avoid half committed status.\n\t */\n\tret = commit_cowonly_roots(trans);\n\tif (ret)\n\t\tgoto out;\n\tswitch_commit_roots(trans);\n\tret = btrfs_write_and_wait_transaction(trans);\n\tif (ret)\n\t\tbtrfs_handle_fs_error(fs_info, ret,\n\t\t\t\"Error while writing out transaction for qgroup\");\n\nout:\n\tmutex_unlock(&fs_info->tree_log_mutex);\n\n\t/*\n\t * Force parent root to be updated, as we recorded it before so its\n\t * last_trans == cur_transid.\n\t * Or it won't be committed again onto disk after later\n\t * insert_dir_item()\n\t */\n\tif (!ret)\n\t\tret = record_root_in_trans(trans, parent, 1);\n\treturn ret;\n}\n\n/*\n * new snapshots need to be created at a very specific time in the\n * transaction commit.  This does the actual creation.\n *\n * Note:\n * If the error which may affect the commitment of the current transaction\n * happens, we should return the error number. If the error which just affect\n * the creation of the pending snapshots, just return 0.\n */\nstatic noinline int create_pending_snapshot(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_pending_snapshot *pending)\n{\n\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_key key;\n\tstruct btrfs_root_item *new_root_item;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *root = pending->root;\n\tstruct btrfs_root *parent_root;\n\tstruct btrfs_block_rsv *rsv;\n\tstruct inode *parent_inode;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *dir_item;\n\tstruct dentry *dentry;\n\tstruct extent_buffer *tmp;\n\tstruct extent_buffer *old;\n\tstruct timespec64 cur_time;\n\tint ret = 0;\n\tu64 to_reserve = 0;\n\tu64 index = 0;\n\tu64 objectid;\n\tu64 root_flags;\n\n\tASSERT(pending->path);\n\tpath = pending->path;\n\n\tASSERT(pending->root_item);\n\tnew_root_item = pending->root_item;\n\n\tpending->error = btrfs_get_free_objectid(tree_root, &objectid);\n\tif (pending->error)\n\t\tgoto no_free_objectid;\n\n\t/*\n\t * Make qgroup to skip current new snapshot's qgroupid, as it is\n\t * accounted by later btrfs_qgroup_inherit().\n\t */\n\tbtrfs_set_skip_qgroup(trans, objectid);\n\n\tbtrfs_reloc_pre_snapshot(pending, &to_reserve);\n\n\tif (to_reserve > 0) {\n\t\tpending->error = btrfs_block_rsv_add(root,\n\t\t\t\t\t\t     &pending->block_rsv,\n\t\t\t\t\t\t     to_reserve,\n\t\t\t\t\t\t     BTRFS_RESERVE_NO_FLUSH);\n\t\tif (pending->error)\n\t\t\tgoto clear_skip_qgroup;\n\t}\n\n\tkey.objectid = objectid;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\n\trsv = trans->block_rsv;\n\ttrans->block_rsv = &pending->block_rsv;\n\ttrans->bytes_reserved = trans->block_rsv->reserved;\n\ttrace_btrfs_space_reservation(fs_info, \"transaction\",\n\t\t\t\t      trans->transid,\n\t\t\t\t      trans->bytes_reserved, 1);\n\tdentry = pending->dentry;\n\tparent_inode = pending->dir;\n\tparent_root = BTRFS_I(parent_inode)->root;\n\tret = record_root_in_trans(trans, parent_root, 0);\n\tif (ret)\n\t\tgoto fail;\n\tcur_time = current_time(parent_inode);\n\n\t/*\n\t * insert the directory item\n\t */\n\tret = btrfs_set_inode_index(BTRFS_I(parent_inode), &index);\n\tBUG_ON(ret); /* -ENOMEM */\n\n\t/* check if there is a file/dir which has the same name. */\n\tdir_item = btrfs_lookup_dir_item(NULL, parent_root, path,\n\t\t\t\t\t btrfs_ino(BTRFS_I(parent_inode)),\n\t\t\t\t\t dentry->d_name.name,\n\t\t\t\t\t dentry->d_name.len, 0);\n\tif (dir_item != NULL && !IS_ERR(dir_item)) {\n\t\tpending->error = -EEXIST;\n\t\tgoto dir_item_existed;\n\t} else if (IS_ERR(dir_item)) {\n\t\tret = PTR_ERR(dir_item);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\tbtrfs_release_path(path);\n\n\t/*\n\t * pull in the delayed directory update\n\t * and the delayed inode item\n\t * otherwise we corrupt the FS during\n\t * snapshot\n\t */\n\tret = btrfs_run_delayed_items(trans);\n\tif (ret) {\t/* Transaction aborted */\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\n\tret = record_root_in_trans(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\tbtrfs_set_root_last_snapshot(&root->root_item, trans->transid);\n\tmemcpy(new_root_item, &root->root_item, sizeof(*new_root_item));\n\tbtrfs_check_and_init_root_item(new_root_item);\n\n\troot_flags = btrfs_root_flags(new_root_item);\n\tif (pending->readonly)\n\t\troot_flags |= BTRFS_ROOT_SUBVOL_RDONLY;\n\telse\n\t\troot_flags &= ~BTRFS_ROOT_SUBVOL_RDONLY;\n\tbtrfs_set_root_flags(new_root_item, root_flags);\n\n\tbtrfs_set_root_generation_v2(new_root_item,\n\t\t\ttrans->transid);\n\tgenerate_random_guid(new_root_item->uuid);\n\tmemcpy(new_root_item->parent_uuid, root->root_item.uuid,\n\t\t\tBTRFS_UUID_SIZE);\n\tif (!(root_flags & BTRFS_ROOT_SUBVOL_RDONLY)) {\n\t\tmemset(new_root_item->received_uuid, 0,\n\t\t       sizeof(new_root_item->received_uuid));\n\t\tmemset(&new_root_item->stime, 0, sizeof(new_root_item->stime));\n\t\tmemset(&new_root_item->rtime, 0, sizeof(new_root_item->rtime));\n\t\tbtrfs_set_root_stransid(new_root_item, 0);\n\t\tbtrfs_set_root_rtransid(new_root_item, 0);\n\t}\n\tbtrfs_set_stack_timespec_sec(&new_root_item->otime, cur_time.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&new_root_item->otime, cur_time.tv_nsec);\n\tbtrfs_set_root_otransid(new_root_item, trans->transid);\n\n\told = btrfs_lock_root_node(root);\n\tret = btrfs_cow_block(trans, root, old, NULL, 0, &old,\n\t\t\t      BTRFS_NESTING_COW);\n\tif (ret) {\n\t\tbtrfs_tree_unlock(old);\n\t\tfree_extent_buffer(old);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_copy_root(trans, root, old, &tmp, objectid);\n\t/* clean up in any case */\n\tbtrfs_tree_unlock(old);\n\tfree_extent_buffer(old);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\t/* see comments in should_cow_block() */\n\tset_bit(BTRFS_ROOT_FORCE_COW, &root->state);\n\tsmp_wmb();\n\n\tbtrfs_set_root_node(new_root_item, tmp);\n\t/* record when the snapshot was created in key.offset */\n\tkey.offset = trans->transid;\n\tret = btrfs_insert_root(trans, tree_root, &key, new_root_item);\n\tbtrfs_tree_unlock(tmp);\n\tfree_extent_buffer(tmp);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * insert root back/forward references\n\t */\n\tret = btrfs_add_root_ref(trans, objectid,\n\t\t\t\t parent_root->root_key.objectid,\n\t\t\t\t btrfs_ino(BTRFS_I(parent_inode)), index,\n\t\t\t\t dentry->d_name.name, dentry->d_name.len);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\n\tkey.offset = (u64)-1;\n\tpending->snap = btrfs_get_new_fs_root(fs_info, objectid, pending->anon_dev);\n\tif (IS_ERR(pending->snap)) {\n\t\tret = PTR_ERR(pending->snap);\n\t\tpending->snap = NULL;\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_reloc_post_snapshot(trans, pending);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * Do special qgroup accounting for snapshot, as we do some qgroup\n\t * snapshot hack to do fast snapshot.\n\t * To co-operate with that hack, we do hack again.\n\t * Or snapshot will be greatly slowed down by a subtree qgroup rescan\n\t */\n\tret = qgroup_account_snapshot(trans, root, parent_root,\n\t\t\t\t      pending->inherit, objectid);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = btrfs_insert_dir_item(trans, dentry->d_name.name,\n\t\t\t\t    dentry->d_name.len, BTRFS_I(parent_inode),\n\t\t\t\t    &key, BTRFS_FT_DIR, index);\n\t/* We have check then name at the beginning, so it is impossible. */\n\tBUG_ON(ret == -EEXIST || ret == -EOVERFLOW);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_i_size_write(BTRFS_I(parent_inode), parent_inode->i_size +\n\t\t\t\t\t dentry->d_name.len * 2);\n\tparent_inode->i_mtime = parent_inode->i_ctime =\n\t\tcurrent_time(parent_inode);\n\tret = btrfs_update_inode_fallback(trans, parent_root, BTRFS_I(parent_inode));\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\tret = btrfs_uuid_tree_add(trans, new_root_item->uuid,\n\t\t\t\t  BTRFS_UUID_KEY_SUBVOL,\n\t\t\t\t  objectid);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\tif (!btrfs_is_empty_uuid(new_root_item->received_uuid)) {\n\t\tret = btrfs_uuid_tree_add(trans, new_root_item->received_uuid,\n\t\t\t\t\t  BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t  objectid);\n\t\tif (ret && ret != -EEXIST) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\nfail:\n\tpending->error = ret;\ndir_item_existed:\n\ttrans->block_rsv = rsv;\n\ttrans->bytes_reserved = 0;\nclear_skip_qgroup:\n\tbtrfs_clear_skip_qgroup(trans);\nno_free_objectid:\n\tkfree(new_root_item);\n\tpending->root_item = NULL;\n\tbtrfs_free_path(path);\n\tpending->path = NULL;\n\n\treturn ret;\n}\n\n/*\n * create all the snapshots we've scheduled for creation\n */\nstatic noinline int create_pending_snapshots(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_pending_snapshot *pending, *next;\n\tstruct list_head *head = &trans->transaction->pending_snapshots;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(pending, next, head, list) {\n\t\tlist_del(&pending->list);\n\t\tret = create_pending_snapshot(trans, pending);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic void update_super_roots(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_super_block *super;\n\n\tsuper = fs_info->super_copy;\n\n\troot_item = &fs_info->chunk_root->root_item;\n\tsuper->chunk_root = root_item->bytenr;\n\tsuper->chunk_root_generation = root_item->generation;\n\tsuper->chunk_root_level = root_item->level;\n\n\troot_item = &fs_info->tree_root->root_item;\n\tsuper->root = root_item->bytenr;\n\tsuper->generation = root_item->generation;\n\tsuper->root_level = root_item->level;\n\tif (btrfs_test_opt(fs_info, SPACE_CACHE))\n\t\tsuper->cache_generation = root_item->generation;\n\telse if (test_bit(BTRFS_FS_CLEANUP_SPACE_CACHE_V1, &fs_info->flags))\n\t\tsuper->cache_generation = 0;\n\tif (test_bit(BTRFS_FS_UPDATE_UUID_TREE_GEN, &fs_info->flags))\n\t\tsuper->uuid_tree_generation = root_item->generation;\n}\n\nint btrfs_transaction_in_commit(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_transaction *trans;\n\tint ret = 0;\n\n\tspin_lock(&info->trans_lock);\n\ttrans = info->running_transaction;\n\tif (trans)\n\t\tret = (trans->state >= TRANS_STATE_COMMIT_START);\n\tspin_unlock(&info->trans_lock);\n\treturn ret;\n}\n\nint btrfs_transaction_blocked(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_transaction *trans;\n\tint ret = 0;\n\n\tspin_lock(&info->trans_lock);\n\ttrans = info->running_transaction;\n\tif (trans)\n\t\tret = is_transaction_blocked(trans);\n\tspin_unlock(&info->trans_lock);\n\treturn ret;\n}\n\n/*\n * commit transactions asynchronously. once btrfs_commit_transaction_async\n * returns, any subsequent transaction will not be allowed to join.\n */\nstruct btrfs_async_commit {\n\tstruct btrfs_trans_handle *newtrans;\n\tstruct work_struct work;\n};\n\nstatic void do_async_commit(struct work_struct *work)\n{\n\tstruct btrfs_async_commit *ac =\n\t\tcontainer_of(work, struct btrfs_async_commit, work);\n\n\t/*\n\t * We've got freeze protection passed with the transaction.\n\t * Tell lockdep about it.\n\t */\n\tif (ac->newtrans->type & __TRANS_FREEZABLE)\n\t\t__sb_writers_acquired(ac->newtrans->fs_info->sb, SB_FREEZE_FS);\n\n\tcurrent->journal_info = ac->newtrans;\n\n\tbtrfs_commit_transaction(ac->newtrans);\n\tkfree(ac);\n}\n\nint btrfs_commit_transaction_async(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_async_commit *ac;\n\tstruct btrfs_transaction *cur_trans;\n\n\tac = kmalloc(sizeof(*ac), GFP_NOFS);\n\tif (!ac)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&ac->work, do_async_commit);\n\tac->newtrans = btrfs_join_transaction(trans->root);\n\tif (IS_ERR(ac->newtrans)) {\n\t\tint err = PTR_ERR(ac->newtrans);\n\t\tkfree(ac);\n\t\treturn err;\n\t}\n\n\t/* take transaction reference */\n\tcur_trans = trans->transaction;\n\trefcount_inc(&cur_trans->use_count);\n\n\tbtrfs_end_transaction(trans);\n\n\t/*\n\t * Tell lockdep we've released the freeze rwsem, since the\n\t * async commit thread will be the one to unlock it.\n\t */\n\tif (ac->newtrans->type & __TRANS_FREEZABLE)\n\t\t__sb_writers_release(fs_info->sb, SB_FREEZE_FS);\n\n\tschedule_work(&ac->work);\n\t/*\n\t * Wait for the current transaction commit to start and block\n\t * subsequent transaction joins\n\t */\n\twait_event(fs_info->transaction_blocked_wait,\n\t\t   cur_trans->state >= TRANS_STATE_COMMIT_START ||\n\t\t   TRANS_ABORTED(cur_trans));\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tbtrfs_put_transaction(cur_trans);\n\treturn 0;\n}\n\n\nstatic void cleanup_transaction(struct btrfs_trans_handle *trans, int err)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\n\tWARN_ON(refcount_read(&trans->use_count) > 1);\n\n\tbtrfs_abort_transaction(trans, err);\n\n\tspin_lock(&fs_info->trans_lock);\n\n\t/*\n\t * If the transaction is removed from the list, it means this\n\t * transaction has been committed successfully, so it is impossible\n\t * to call the cleanup function.\n\t */\n\tBUG_ON(list_empty(&cur_trans->list));\n\n\tif (cur_trans == fs_info->running_transaction) {\n\t\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\twait_event(cur_trans->writer_wait,\n\t\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t\tspin_lock(&fs_info->trans_lock);\n\t}\n\n\t/*\n\t * Now that we know no one else is still using the transaction we can\n\t * remove the transaction from the list of transactions. This avoids\n\t * the transaction kthread from cleaning up the transaction while some\n\t * other task is still using it, which could result in a use-after-free\n\t * on things like log trees, as it forces the transaction kthread to\n\t * wait for this transaction to be cleaned up by us.\n\t */\n\tlist_del_init(&cur_trans->list);\n\n\tspin_unlock(&fs_info->trans_lock);\n\n\tbtrfs_cleanup_one_transaction(trans->transaction, fs_info);\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (cur_trans == fs_info->running_transaction)\n\t\tfs_info->running_transaction = NULL;\n\tspin_unlock(&fs_info->trans_lock);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(fs_info->sb);\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\ttrace_btrfs_transaction_commit(trans->root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tbtrfs_scrub_cancel(fs_info);\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n}\n\n/*\n * Release reserved delayed ref space of all pending block groups of the\n * transaction and remove them from the list\n */\nstatic void btrfs_cleanup_pending_block_groups(struct btrfs_trans_handle *trans)\n{\n       struct btrfs_fs_info *fs_info = trans->fs_info;\n       struct btrfs_block_group *block_group, *tmp;\n\n       list_for_each_entry_safe(block_group, tmp, &trans->new_bgs, bg_list) {\n               btrfs_delayed_refs_rsv_release(fs_info, 1);\n               list_del_init(&block_group->bg_list);\n       }\n}\n\nstatic inline int btrfs_start_delalloc_flush(struct btrfs_fs_info *fs_info)\n{\n\t/*\n\t * We use writeback_inodes_sb here because if we used\n\t * btrfs_start_delalloc_roots we would deadlock with fs freeze.\n\t * Currently are holding the fs freeze lock, if we do an async flush\n\t * we'll do btrfs_join_transaction() and deadlock because we need to\n\t * wait for the fs freeze lock.  Using the direct flushing we benefit\n\t * from already being in a transaction and our join_transaction doesn't\n\t * have to re-take the fs freeze lock.\n\t */\n\tif (btrfs_test_opt(fs_info, FLUSHONCOMMIT))\n\t\twriteback_inodes_sb(fs_info->sb, WB_REASON_SYNC);\n\treturn 0;\n}\n\nstatic inline void btrfs_wait_delalloc_flush(struct btrfs_fs_info *fs_info)\n{\n\tif (btrfs_test_opt(fs_info, FLUSHONCOMMIT))\n\t\tbtrfs_wait_ordered_roots(fs_info, U64_MAX, 0, (u64)-1);\n}\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tint ret;\n\n\tASSERT(refcount_read(&trans->use_count) == 1);\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (TRANS_ABORTED(cur_trans)) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans);\n\ttrans->block_rsv = NULL;\n\n\t/*\n\t * We only want one transaction commit doing the flushing so we do not\n\t * waste a bunch of time on lock contention on the extent root node.\n\t */\n\tif (!test_and_set_bit(BTRFS_DELAYED_REFS_FLUSHING,\n\t\t\t      &cur_trans->delayed_refs.flags)) {\n\t\t/*\n\t\t * Make a pass through all the delayed refs we have so far.\n\t\t * Any running threads may add more while we are here.\n\t\t */\n\t\tret = btrfs_run_delayed_refs(trans, 0);\n\t\tif (ret) {\n\t\t\tbtrfs_end_transaction(trans);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tbtrfs_create_pending_block_groups(trans);\n\n\tif (!test_bit(BTRFS_TRANS_DIRTY_BG_RUN, &cur_trans->flags)) {\n\t\tint run_it = 0;\n\n\t\t/* this mutex is also taken before trying to set\n\t\t * block groups readonly.  We need to make sure\n\t\t * that nobody has set a block group readonly\n\t\t * after a extents from that block group have been\n\t\t * allocated for cache files.  btrfs_set_block_group_ro\n\t\t * will wait for the transaction to commit if it\n\t\t * finds BTRFS_TRANS_DIRTY_BG_RUN set.\n\t\t *\n\t\t * The BTRFS_TRANS_DIRTY_BG_RUN flag is also used to make sure\n\t\t * only one process starts all the block group IO.  It wouldn't\n\t\t * hurt to have more than one go through, but there's no\n\t\t * real advantage to it either.\n\t\t */\n\t\tmutex_lock(&fs_info->ro_block_group_mutex);\n\t\tif (!test_and_set_bit(BTRFS_TRANS_DIRTY_BG_RUN,\n\t\t\t\t      &cur_trans->flags))\n\t\t\trun_it = 1;\n\t\tmutex_unlock(&fs_info->ro_block_group_mutex);\n\n\t\tif (run_it) {\n\t\t\tret = btrfs_start_dirty_block_groups(trans);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_end_transaction(trans);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tenum btrfs_trans_state want_state = TRANS_STATE_COMPLETED;\n\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\trefcount_inc(&cur_trans->use_count);\n\n\t\tif (trans->in_fsync)\n\t\t\twant_state = TRANS_STATE_SUPER_COMMITTED;\n\t\tret = btrfs_end_transaction(trans);\n\t\twait_for_commit(cur_trans, want_state);\n\n\t\tif (TRANS_ABORTED(cur_trans))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &fs_info->trans_list) {\n\t\tenum btrfs_trans_state want_state = TRANS_STATE_COMPLETED;\n\n\t\tif (trans->in_fsync)\n\t\t\twant_state = TRANS_STATE_SUPER_COMMITTED;\n\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state < want_state) {\n\t\t\trefcount_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\n\t\t\twait_for_commit(prev_trans, want_state);\n\n\t\t\tret = READ_ONCE(prev_trans->aborted);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup_transaction;\n\t\t} else {\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\t/*\n\t\t * The previous transaction was aborted and was already removed\n\t\t * from the list of transactions at fs_info->trans_list. So we\n\t\t * abort to prevent writing a new superblock that reflects a\n\t\t * corrupt state (pointing to trees with unwritten nodes/leafs).\n\t\t */\n\t\tif (test_bit(BTRFS_FS_STATE_TRANS_ABORTED, &fs_info->fs_state)) {\n\t\t\tret = -EROFS;\n\t\t\tgoto cleanup_transaction;\n\t\t}\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(fs_info);\n\n\t/*\n\t * Wait for all ordered extents started by a fast fsync that joined this\n\t * transaction. Otherwise if this transaction commits before the ordered\n\t * extents complete we lose logged data after a power failure.\n\t */\n\twait_event(cur_trans->pending_wait,\n\t\t   atomic_read(&cur_trans->pending_ordered) == 0);\n\n\tbtrfs_scrub_pause(fs_info);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\tif (TRANS_ABORTED(cur_trans)) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans);\n\tif (ret)\n\t\tgoto unlock_reloc;\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans);\n\tif (ret)\n\t\tgoto unlock_reloc;\n\n\tret = btrfs_run_delayed_refs(trans, (unsigned long)-1);\n\tif (ret)\n\t\tgoto unlock_reloc;\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(fs_info);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans);\n\tif (ret)\n\t\tgoto unlock_tree_log;\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, fs_info);\n\n\t/*\n\t * Since fs roots are all committed, we can get a quite accurate\n\t * new_roots. So let's do quota accounting.\n\t */\n\tret = btrfs_qgroup_account_extents(trans);\n\tif (ret < 0)\n\t\tgoto unlock_tree_log;\n\n\tret = commit_cowonly_roots(trans);\n\tif (ret)\n\t\tgoto unlock_tree_log;\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (TRANS_ABORTED(cur_trans)) {\n\t\tret = cur_trans->aborted;\n\t\tgoto unlock_tree_log;\n\t}\n\n\tcur_trans = fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&fs_info->tree_root->root_item,\n\t\t\t    fs_info->tree_root->node);\n\tlist_add_tail(&fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&fs_info->chunk_root->root_item,\n\t\t\t    fs_info->chunk_root->node);\n\tlist_add_tail(&fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(trans);\n\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tASSERT(list_empty(&cur_trans->io_bgs));\n\tupdate_super_roots(fs_info);\n\n\tbtrfs_set_super_log_root(fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(fs_info->super_copy, 0);\n\tmemcpy(fs_info->super_for_commit, fs_info->super_copy,\n\t       sizeof(*fs_info->super_copy));\n\n\tbtrfs_commit_device_sizes(cur_trans);\n\n\tclear_bit(BTRFS_FS_LOG1_ERR, &fs_info->flags);\n\tclear_bit(BTRFS_FS_LOG2_ERR, &fs_info->flags);\n\n\tbtrfs_trans_release_chunk_metadata(trans);\n\n\tspin_lock(&fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\tfs_info->running_transaction = NULL;\n\tspin_unlock(&fs_info->trans_lock);\n\tmutex_unlock(&fs_info->reloc_mutex);\n\n\twake_up(&fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans);\n\tif (ret) {\n\t\tbtrfs_handle_fs_error(fs_info, ret,\n\t\t\t\t      \"Error while writing out transaction\");\n\t\t/*\n\t\t * reloc_mutex has been unlocked, tree_log_mutex is still held\n\t\t * but we can't jump to unlock_tree_log causing double unlock\n\t\t */\n\t\tmutex_unlock(&fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * At this point, we should have written all the tree blocks allocated\n\t * in this transaction. So it's now safe to free the redirtyied extent\n\t * buffers.\n\t */\n\tbtrfs_free_redirty_list(cur_trans);\n\n\tret = write_all_supers(fs_info, 0);\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&fs_info->tree_log_mutex);\n\tif (ret)\n\t\tgoto scrub_continue;\n\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_SUPER_COMMITTED;\n\twake_up(&cur_trans->commit_wait);\n\n\tbtrfs_finish_extent_commit(trans);\n\n\tif (test_bit(BTRFS_TRANS_HAVE_FREE_BGS, &cur_trans->flags))\n\t\tbtrfs_clear_space_info_full(fs_info);\n\n\tfs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(trans->root);\n\n\tbtrfs_scrub_continue(fs_info);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\treturn ret;\n\nunlock_tree_log:\n\tmutex_unlock(&fs_info->tree_log_mutex);\nunlock_reloc:\n\tmutex_unlock(&fs_info->reloc_mutex);\nscrub_continue:\n\tbtrfs_scrub_continue(fs_info);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans);\n\tbtrfs_cleanup_pending_block_groups(trans);\n\tbtrfs_trans_release_chunk_metadata(trans);\n\ttrans->block_rsv = NULL;\n\tbtrfs_warn(fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, ret);\n\n\treturn ret;\n}\n\n/*\n * return < 0 if error\n * 0 if there are no more dead_roots at the time of call\n * 1 there are more to be processed, call me again\n *\n * The return value indicates there are certainly more snapshots to delete, but\n * if there comes a new one during processing, it may return 0. We don't mind,\n * because btrfs_commit_super will poke cleaner thread and it will process it a\n * few seconds later.\n */\nint btrfs_clean_one_deleted_snapshot(struct btrfs_root *root)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (list_empty(&fs_info->dead_roots)) {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\treturn 0;\n\t}\n\troot = list_first_entry(&fs_info->dead_roots,\n\t\t\tstruct btrfs_root, root_list);\n\tlist_del_init(&root->root_list);\n\tspin_unlock(&fs_info->trans_lock);\n\n\tbtrfs_debug(fs_info, \"cleaner removing %llu\", root->root_key.objectid);\n\n\tbtrfs_kill_all_delayed_nodes(root);\n\n\tif (btrfs_header_backref_rev(root->node) <\n\t\t\tBTRFS_MIXED_BACKREF_REV)\n\t\tret = btrfs_drop_snapshot(root, 0, 0);\n\telse\n\t\tret = btrfs_drop_snapshot(root, 1, 0);\n\n\tbtrfs_put_root(root);\n\treturn (ret < 0) ? 0 : 1;\n}\n\nvoid btrfs_apply_pending_changes(struct btrfs_fs_info *fs_info)\n{\n\tunsigned long prev;\n\tunsigned long bit;\n\n\tprev = xchg(&fs_info->pending_changes, 0);\n\tif (!prev)\n\t\treturn;\n\n\tbit = 1 << BTRFS_PENDING_COMMIT;\n\tif (prev & bit)\n\t\tbtrfs_debug(fs_info, \"pending commit done\");\n\tprev &= ~bit;\n\n\tif (prev)\n\t\tbtrfs_warn(fs_info,\n\t\t\t\"unknown pending changes left 0x%lx, ignoring\", prev);\n}\n", "/* SPDX-License-Identifier: GPL-2.0 */\n/*\n * Copyright (C) 2007 Oracle.  All rights reserved.\n */\n\n#ifndef BTRFS_TRANSACTION_H\n#define BTRFS_TRANSACTION_H\n\n#include <linux/refcount.h>\n#include \"btrfs_inode.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n\nenum btrfs_trans_state {\n\tTRANS_STATE_RUNNING,\n\tTRANS_STATE_COMMIT_START,\n\tTRANS_STATE_COMMIT_DOING,\n\tTRANS_STATE_UNBLOCKED,\n\tTRANS_STATE_SUPER_COMMITTED,\n\tTRANS_STATE_COMPLETED,\n\tTRANS_STATE_MAX,\n};\n\n#define BTRFS_TRANS_HAVE_FREE_BGS\t0\n#define BTRFS_TRANS_DIRTY_BG_RUN\t1\n#define BTRFS_TRANS_CACHE_ENOSPC\t2\n\nstruct btrfs_transaction {\n\tu64 transid;\n\t/*\n\t * total external writers(USERSPACE/START/ATTACH) in this\n\t * transaction, it must be zero before the transaction is\n\t * being committed\n\t */\n\tatomic_t num_extwriters;\n\t/*\n\t * total writers in this transaction, it must be zero before the\n\t * transaction can end\n\t */\n\tatomic_t num_writers;\n\trefcount_t use_count;\n\n\tunsigned long flags;\n\n\t/* Be protected by fs_info->trans_lock when we want to change it. */\n\tenum btrfs_trans_state state;\n\tint aborted;\n\tstruct list_head list;\n\tstruct extent_io_tree dirty_pages;\n\ttime64_t start_time;\n\twait_queue_head_t writer_wait;\n\twait_queue_head_t commit_wait;\n\tstruct list_head pending_snapshots;\n\tstruct list_head dev_update_list;\n\tstruct list_head switch_commits;\n\tstruct list_head dirty_bgs;\n\n\t/*\n\t * There is no explicit lock which protects io_bgs, rather its\n\t * consistency is implied by the fact that all the sites which modify\n\t * it do so under some form of transaction critical section, namely:\n\t *\n\t * - btrfs_start_dirty_block_groups - This function can only ever be\n\t *   run by one of the transaction committers. Refer to\n\t *   BTRFS_TRANS_DIRTY_BG_RUN usage in btrfs_commit_transaction\n\t *\n\t * - btrfs_write_dirty_blockgroups - this is called by\n\t *   commit_cowonly_roots from transaction critical section\n\t *   (TRANS_STATE_COMMIT_DOING)\n\t *\n\t * - btrfs_cleanup_dirty_bgs - called on transaction abort\n\t */\n\tstruct list_head io_bgs;\n\tstruct list_head dropped_roots;\n\tstruct extent_io_tree pinned_extents;\n\n\t/*\n\t * we need to make sure block group deletion doesn't race with\n\t * free space cache writeout.  This mutex keeps them from stomping\n\t * on each other\n\t */\n\tstruct mutex cache_write_mutex;\n\tspinlock_t dirty_bgs_lock;\n\t/* Protected by spin lock fs_info->unused_bgs_lock. */\n\tstruct list_head deleted_bgs;\n\tspinlock_t dropped_roots_lock;\n\tstruct btrfs_delayed_ref_root delayed_refs;\n\tstruct btrfs_fs_info *fs_info;\n\n\t/*\n\t * Number of ordered extents the transaction must wait for before\n\t * committing. These are ordered extents started by a fast fsync.\n\t */\n\tatomic_t pending_ordered;\n\twait_queue_head_t pending_wait;\n\n\tspinlock_t releasing_ebs_lock;\n\tstruct list_head releasing_ebs;\n\n\t/*\n\t * The number of bytes currently reserved, by all transaction handles\n\t * attached to this transaction, for metadata extents of the chunk tree.\n\t */\n\tatomic64_t chunk_bytes_reserved;\n\twait_queue_head_t chunk_reserve_wait;\n};\n\n#define __TRANS_FREEZABLE\t(1U << 0)\n\n#define __TRANS_START\t\t(1U << 9)\n#define __TRANS_ATTACH\t\t(1U << 10)\n#define __TRANS_JOIN\t\t(1U << 11)\n#define __TRANS_JOIN_NOLOCK\t(1U << 12)\n#define __TRANS_DUMMY\t\t(1U << 13)\n#define __TRANS_JOIN_NOSTART\t(1U << 14)\n\n#define TRANS_START\t\t(__TRANS_START | __TRANS_FREEZABLE)\n#define TRANS_ATTACH\t\t(__TRANS_ATTACH)\n#define TRANS_JOIN\t\t(__TRANS_JOIN | __TRANS_FREEZABLE)\n#define TRANS_JOIN_NOLOCK\t(__TRANS_JOIN_NOLOCK)\n#define TRANS_JOIN_NOSTART\t(__TRANS_JOIN_NOSTART)\n\n#define TRANS_EXTWRITERS\t(__TRANS_START | __TRANS_ATTACH)\n\nstruct btrfs_trans_handle {\n\tu64 transid;\n\tu64 bytes_reserved;\n\tu64 chunk_bytes_reserved;\n\tunsigned long delayed_ref_updates;\n\tstruct btrfs_transaction *transaction;\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct btrfs_block_rsv *orig_rsv;\n\trefcount_t use_count;\n\tunsigned int type;\n\t/*\n\t * Error code of transaction abort, set outside of locks and must use\n\t * the READ_ONCE/WRITE_ONCE access\n\t */\n\tshort aborted;\n\tbool adding_csums;\n\tbool allocating_chunk;\n\tbool can_flush_pending_bgs;\n\tbool reloc_reserved;\n\tbool in_fsync;\n\tstruct btrfs_root *root;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct list_head new_bgs;\n};\n\n/*\n * The abort status can be changed between calls and is not protected by locks.\n * This accepts btrfs_transaction and btrfs_trans_handle as types. Once it's\n * set to a non-zero value it does not change, so the macro should be in checks\n * but is not necessary for further reads of the value.\n */\n#define TRANS_ABORTED(trans)\t\t(unlikely(READ_ONCE((trans)->aborted)))\n\nstruct btrfs_pending_snapshot {\n\tstruct dentry *dentry;\n\tstruct inode *dir;\n\tstruct btrfs_root *root;\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_root *snap;\n\tstruct btrfs_qgroup_inherit *inherit;\n\tstruct btrfs_path *path;\n\t/* block reservation for the operation */\n\tstruct btrfs_block_rsv block_rsv;\n\t/* extra metadata reservation for relocation */\n\tint error;\n\t/* Preallocated anonymous block device number */\n\tdev_t anon_dev;\n\tbool readonly;\n\tstruct list_head list;\n};\n\nstatic inline void btrfs_set_inode_last_trans(struct btrfs_trans_handle *trans,\n\t\t\t\t\t      struct btrfs_inode *inode)\n{\n\tspin_lock(&inode->lock);\n\tinode->last_trans = trans->transaction->transid;\n\tinode->last_sub_trans = inode->root->log_transid;\n\tinode->last_log_commit = inode->last_sub_trans - 1;\n\tspin_unlock(&inode->lock);\n}\n\n/*\n * Make qgroup codes to skip given qgroupid, means the old/new_roots for\n * qgroup won't contain the qgroupid in it.\n */\nstatic inline void btrfs_set_skip_qgroup(struct btrfs_trans_handle *trans,\n\t\t\t\t\t u64 qgroupid)\n{\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tWARN_ON(delayed_refs->qgroup_to_skip);\n\tdelayed_refs->qgroup_to_skip = qgroupid;\n}\n\nstatic inline void btrfs_clear_skip_qgroup(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tWARN_ON(!delayed_refs->qgroup_to_skip);\n\tdelayed_refs->qgroup_to_skip = 0;\n}\n\nint btrfs_end_transaction(struct btrfs_trans_handle *trans);\nstruct btrfs_trans_handle *btrfs_start_transaction(struct btrfs_root *root,\n\t\t\t\t\t\t   unsigned int num_items);\nstruct btrfs_trans_handle *btrfs_start_transaction_fallback_global_rsv(\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tunsigned int num_items);\nstruct btrfs_trans_handle *btrfs_join_transaction(struct btrfs_root *root);\nstruct btrfs_trans_handle *btrfs_join_transaction_spacecache(struct btrfs_root *root);\nstruct btrfs_trans_handle *btrfs_join_transaction_nostart(struct btrfs_root *root);\nstruct btrfs_trans_handle *btrfs_attach_transaction(struct btrfs_root *root);\nstruct btrfs_trans_handle *btrfs_attach_transaction_barrier(\n\t\t\t\t\tstruct btrfs_root *root);\nint btrfs_wait_for_commit(struct btrfs_fs_info *fs_info, u64 transid);\n\nvoid btrfs_add_dead_root(struct btrfs_root *root);\nint btrfs_defrag_root(struct btrfs_root *root);\nint btrfs_clean_one_deleted_snapshot(struct btrfs_root *root);\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans);\nint btrfs_commit_transaction_async(struct btrfs_trans_handle *trans);\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans);\nbool btrfs_should_end_transaction(struct btrfs_trans_handle *trans);\nvoid btrfs_throttle(struct btrfs_fs_info *fs_info);\nint btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root);\nint btrfs_write_marked_extents(struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct extent_io_tree *dirty_pages, int mark);\nint btrfs_wait_tree_log_extents(struct btrfs_root *root, int mark);\nint btrfs_transaction_blocked(struct btrfs_fs_info *info);\nint btrfs_transaction_in_commit(struct btrfs_fs_info *info);\nvoid btrfs_put_transaction(struct btrfs_transaction *transaction);\nvoid btrfs_apply_pending_changes(struct btrfs_fs_info *fs_info);\nvoid btrfs_add_dropped_root(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root);\nvoid btrfs_trans_release_chunk_metadata(struct btrfs_trans_handle *trans);\n\n#endif\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n\n#include \"misc.h\"\n#include \"ctree.h\"\n#include \"block-group.h\"\n#include \"space-info.h\"\n#include \"disk-io.h\"\n#include \"free-space-cache.h\"\n#include \"free-space-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"ref-verify.h\"\n#include \"sysfs.h\"\n#include \"tree-log.h\"\n#include \"delalloc-space.h\"\n#include \"discard.h\"\n#include \"raid56.h\"\n#include \"zoned.h\"\n\n/*\n * Return target flags in extended format or 0 if restripe for this chunk_type\n * is not in progress\n *\n * Should be called with balance_lock held\n */\nstatic u64 get_restripe_target(struct btrfs_fs_info *fs_info, u64 flags)\n{\n\tstruct btrfs_balance_control *bctl = fs_info->balance_ctl;\n\tu64 target = 0;\n\n\tif (!bctl)\n\t\treturn 0;\n\n\tif (flags & BTRFS_BLOCK_GROUP_DATA &&\n\t    bctl->data.flags & BTRFS_BALANCE_ARGS_CONVERT) {\n\t\ttarget = BTRFS_BLOCK_GROUP_DATA | bctl->data.target;\n\t} else if (flags & BTRFS_BLOCK_GROUP_SYSTEM &&\n\t\t   bctl->sys.flags & BTRFS_BALANCE_ARGS_CONVERT) {\n\t\ttarget = BTRFS_BLOCK_GROUP_SYSTEM | bctl->sys.target;\n\t} else if (flags & BTRFS_BLOCK_GROUP_METADATA &&\n\t\t   bctl->meta.flags & BTRFS_BALANCE_ARGS_CONVERT) {\n\t\ttarget = BTRFS_BLOCK_GROUP_METADATA | bctl->meta.target;\n\t}\n\n\treturn target;\n}\n\n/*\n * @flags: available profiles in extended format (see ctree.h)\n *\n * Return reduced profile in chunk format.  If profile changing is in progress\n * (either running or paused) picks the target profile (if it's already\n * available), otherwise falls back to plain reducing.\n */\nstatic u64 btrfs_reduce_alloc_profile(struct btrfs_fs_info *fs_info, u64 flags)\n{\n\tu64 num_devices = fs_info->fs_devices->rw_devices;\n\tu64 target;\n\tu64 raid_type;\n\tu64 allowed = 0;\n\n\t/*\n\t * See if restripe for this chunk_type is in progress, if so try to\n\t * reduce to the target profile\n\t */\n\tspin_lock(&fs_info->balance_lock);\n\ttarget = get_restripe_target(fs_info, flags);\n\tif (target) {\n\t\tspin_unlock(&fs_info->balance_lock);\n\t\treturn extended_to_chunk(target);\n\t}\n\tspin_unlock(&fs_info->balance_lock);\n\n\t/* First, mask out the RAID levels which aren't possible */\n\tfor (raid_type = 0; raid_type < BTRFS_NR_RAID_TYPES; raid_type++) {\n\t\tif (num_devices >= btrfs_raid_array[raid_type].devs_min)\n\t\t\tallowed |= btrfs_raid_array[raid_type].bg_flag;\n\t}\n\tallowed &= flags;\n\n\tif (allowed & BTRFS_BLOCK_GROUP_RAID6)\n\t\tallowed = BTRFS_BLOCK_GROUP_RAID6;\n\telse if (allowed & BTRFS_BLOCK_GROUP_RAID5)\n\t\tallowed = BTRFS_BLOCK_GROUP_RAID5;\n\telse if (allowed & BTRFS_BLOCK_GROUP_RAID10)\n\t\tallowed = BTRFS_BLOCK_GROUP_RAID10;\n\telse if (allowed & BTRFS_BLOCK_GROUP_RAID1)\n\t\tallowed = BTRFS_BLOCK_GROUP_RAID1;\n\telse if (allowed & BTRFS_BLOCK_GROUP_RAID0)\n\t\tallowed = BTRFS_BLOCK_GROUP_RAID0;\n\n\tflags &= ~BTRFS_BLOCK_GROUP_PROFILE_MASK;\n\n\treturn extended_to_chunk(flags | allowed);\n}\n\nu64 btrfs_get_alloc_profile(struct btrfs_fs_info *fs_info, u64 orig_flags)\n{\n\tunsigned seq;\n\tu64 flags;\n\n\tdo {\n\t\tflags = orig_flags;\n\t\tseq = read_seqbegin(&fs_info->profiles_lock);\n\n\t\tif (flags & BTRFS_BLOCK_GROUP_DATA)\n\t\t\tflags |= fs_info->avail_data_alloc_bits;\n\t\telse if (flags & BTRFS_BLOCK_GROUP_SYSTEM)\n\t\t\tflags |= fs_info->avail_system_alloc_bits;\n\t\telse if (flags & BTRFS_BLOCK_GROUP_METADATA)\n\t\t\tflags |= fs_info->avail_metadata_alloc_bits;\n\t} while (read_seqretry(&fs_info->profiles_lock, seq));\n\n\treturn btrfs_reduce_alloc_profile(fs_info, flags);\n}\n\nvoid btrfs_get_block_group(struct btrfs_block_group *cache)\n{\n\trefcount_inc(&cache->refs);\n}\n\nvoid btrfs_put_block_group(struct btrfs_block_group *cache)\n{\n\tif (refcount_dec_and_test(&cache->refs)) {\n\t\tWARN_ON(cache->pinned > 0);\n\t\tWARN_ON(cache->reserved > 0);\n\n\t\t/*\n\t\t * A block_group shouldn't be on the discard_list anymore.\n\t\t * Remove the block_group from the discard_list to prevent us\n\t\t * from causing a panic due to NULL pointer dereference.\n\t\t */\n\t\tif (WARN_ON(!list_empty(&cache->discard_list)))\n\t\t\tbtrfs_discard_cancel_work(&cache->fs_info->discard_ctl,\n\t\t\t\t\t\t  cache);\n\n\t\t/*\n\t\t * If not empty, someone is still holding mutex of\n\t\t * full_stripe_lock, which can only be released by caller.\n\t\t * And it will definitely cause use-after-free when caller\n\t\t * tries to release full stripe lock.\n\t\t *\n\t\t * No better way to resolve, but only to warn.\n\t\t */\n\t\tWARN_ON(!RB_EMPTY_ROOT(&cache->full_stripe_locks_root.root));\n\t\tkfree(cache->free_space_ctl);\n\t\tkfree(cache);\n\t}\n}\n\n/*\n * This adds the block group to the fs_info rb tree for the block group cache\n */\nstatic int btrfs_add_block_group_cache(struct btrfs_fs_info *info,\n\t\t\t\t       struct btrfs_block_group *block_group)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_block_group *cache;\n\n\tASSERT(block_group->length != 0);\n\n\tspin_lock(&info->block_group_cache_lock);\n\tp = &info->block_group_cache_tree.rb_node;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tcache = rb_entry(parent, struct btrfs_block_group, cache_node);\n\t\tif (block_group->start < cache->start) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (block_group->start > cache->start) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tspin_unlock(&info->block_group_cache_lock);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&block_group->cache_node, parent, p);\n\trb_insert_color(&block_group->cache_node,\n\t\t\t&info->block_group_cache_tree);\n\n\tif (info->first_logical_byte > block_group->start)\n\t\tinfo->first_logical_byte = block_group->start;\n\n\tspin_unlock(&info->block_group_cache_lock);\n\n\treturn 0;\n}\n\n/*\n * This will return the block group at or after bytenr if contains is 0, else\n * it will return the block group that contains the bytenr\n */\nstatic struct btrfs_block_group *block_group_cache_tree_search(\n\t\tstruct btrfs_fs_info *info, u64 bytenr, int contains)\n{\n\tstruct btrfs_block_group *cache, *ret = NULL;\n\tstruct rb_node *n;\n\tu64 end, start;\n\n\tspin_lock(&info->block_group_cache_lock);\n\tn = info->block_group_cache_tree.rb_node;\n\n\twhile (n) {\n\t\tcache = rb_entry(n, struct btrfs_block_group, cache_node);\n\t\tend = cache->start + cache->length - 1;\n\t\tstart = cache->start;\n\n\t\tif (bytenr < start) {\n\t\t\tif (!contains && (!ret || start < ret->start))\n\t\t\t\tret = cache;\n\t\t\tn = n->rb_left;\n\t\t} else if (bytenr > start) {\n\t\t\tif (contains && bytenr <= end) {\n\t\t\t\tret = cache;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tret = cache;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret) {\n\t\tbtrfs_get_block_group(ret);\n\t\tif (bytenr == 0 && info->first_logical_byte > ret->start)\n\t\t\tinfo->first_logical_byte = ret->start;\n\t}\n\tspin_unlock(&info->block_group_cache_lock);\n\n\treturn ret;\n}\n\n/*\n * Return the block group that starts at or after bytenr\n */\nstruct btrfs_block_group *btrfs_lookup_first_block_group(\n\t\tstruct btrfs_fs_info *info, u64 bytenr)\n{\n\treturn block_group_cache_tree_search(info, bytenr, 0);\n}\n\n/*\n * Return the block group that contains the given bytenr\n */\nstruct btrfs_block_group *btrfs_lookup_block_group(\n\t\tstruct btrfs_fs_info *info, u64 bytenr)\n{\n\treturn block_group_cache_tree_search(info, bytenr, 1);\n}\n\nstruct btrfs_block_group *btrfs_next_block_group(\n\t\tstruct btrfs_block_group *cache)\n{\n\tstruct btrfs_fs_info *fs_info = cache->fs_info;\n\tstruct rb_node *node;\n\n\tspin_lock(&fs_info->block_group_cache_lock);\n\n\t/* If our block group was removed, we need a full search. */\n\tif (RB_EMPTY_NODE(&cache->cache_node)) {\n\t\tconst u64 next_bytenr = cache->start + cache->length;\n\n\t\tspin_unlock(&fs_info->block_group_cache_lock);\n\t\tbtrfs_put_block_group(cache);\n\t\tcache = btrfs_lookup_first_block_group(fs_info, next_bytenr); return cache;\n\t}\n\tnode = rb_next(&cache->cache_node);\n\tbtrfs_put_block_group(cache);\n\tif (node) {\n\t\tcache = rb_entry(node, struct btrfs_block_group, cache_node);\n\t\tbtrfs_get_block_group(cache);\n\t} else\n\t\tcache = NULL;\n\tspin_unlock(&fs_info->block_group_cache_lock);\n\treturn cache;\n}\n\nbool btrfs_inc_nocow_writers(struct btrfs_fs_info *fs_info, u64 bytenr)\n{\n\tstruct btrfs_block_group *bg;\n\tbool ret = true;\n\n\tbg = btrfs_lookup_block_group(fs_info, bytenr);\n\tif (!bg)\n\t\treturn false;\n\n\tspin_lock(&bg->lock);\n\tif (bg->ro)\n\t\tret = false;\n\telse\n\t\tatomic_inc(&bg->nocow_writers);\n\tspin_unlock(&bg->lock);\n\n\t/* No put on block group, done by btrfs_dec_nocow_writers */\n\tif (!ret)\n\t\tbtrfs_put_block_group(bg);\n\n\treturn ret;\n}\n\nvoid btrfs_dec_nocow_writers(struct btrfs_fs_info *fs_info, u64 bytenr)\n{\n\tstruct btrfs_block_group *bg;\n\n\tbg = btrfs_lookup_block_group(fs_info, bytenr);\n\tASSERT(bg);\n\tif (atomic_dec_and_test(&bg->nocow_writers))\n\t\twake_up_var(&bg->nocow_writers);\n\t/*\n\t * Once for our lookup and once for the lookup done by a previous call\n\t * to btrfs_inc_nocow_writers()\n\t */\n\tbtrfs_put_block_group(bg);\n\tbtrfs_put_block_group(bg);\n}\n\nvoid btrfs_wait_nocow_writers(struct btrfs_block_group *bg)\n{\n\twait_var_event(&bg->nocow_writers, !atomic_read(&bg->nocow_writers));\n}\n\nvoid btrfs_dec_block_group_reservations(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tconst u64 start)\n{\n\tstruct btrfs_block_group *bg;\n\n\tbg = btrfs_lookup_block_group(fs_info, start);\n\tASSERT(bg);\n\tif (atomic_dec_and_test(&bg->reservations))\n\t\twake_up_var(&bg->reservations);\n\tbtrfs_put_block_group(bg);\n}\n\nvoid btrfs_wait_block_group_reservations(struct btrfs_block_group *bg)\n{\n\tstruct btrfs_space_info *space_info = bg->space_info;\n\n\tASSERT(bg->ro);\n\n\tif (!(bg->flags & BTRFS_BLOCK_GROUP_DATA))\n\t\treturn;\n\n\t/*\n\t * Our block group is read only but before we set it to read only,\n\t * some task might have had allocated an extent from it already, but it\n\t * has not yet created a respective ordered extent (and added it to a\n\t * root's list of ordered extents).\n\t * Therefore wait for any task currently allocating extents, since the\n\t * block group's reservations counter is incremented while a read lock\n\t * on the groups' semaphore is held and decremented after releasing\n\t * the read access on that semaphore and creating the ordered extent.\n\t */\n\tdown_write(&space_info->groups_sem);\n\tup_write(&space_info->groups_sem);\n\n\twait_var_event(&bg->reservations, !atomic_read(&bg->reservations));\n}\n\nstruct btrfs_caching_control *btrfs_get_caching_control(\n\t\tstruct btrfs_block_group *cache)\n{\n\tstruct btrfs_caching_control *ctl;\n\n\tspin_lock(&cache->lock);\n\tif (!cache->caching_ctl) {\n\t\tspin_unlock(&cache->lock);\n\t\treturn NULL;\n\t}\n\n\tctl = cache->caching_ctl;\n\trefcount_inc(&ctl->count);\n\tspin_unlock(&cache->lock);\n\treturn ctl;\n}\n\nvoid btrfs_put_caching_control(struct btrfs_caching_control *ctl)\n{\n\tif (refcount_dec_and_test(&ctl->count))\n\t\tkfree(ctl);\n}\n\n/*\n * When we wait for progress in the block group caching, its because our\n * allocation attempt failed at least once.  So, we must sleep and let some\n * progress happen before we try again.\n *\n * This function will sleep at least once waiting for new free space to show\n * up, and then it will check the block group free space numbers for our min\n * num_bytes.  Another option is to have it go ahead and look in the rbtree for\n * a free extent of a given size, but this is a good start.\n *\n * Callers of this must check if cache->cached == BTRFS_CACHE_ERROR before using\n * any of the information in this block group.\n */\nvoid btrfs_wait_block_group_cache_progress(struct btrfs_block_group *cache,\n\t\t\t\t\t   u64 num_bytes)\n{\n\tstruct btrfs_caching_control *caching_ctl;\n\n\tcaching_ctl = btrfs_get_caching_control(cache);\n\tif (!caching_ctl)\n\t\treturn;\n\n\twait_event(caching_ctl->wait, btrfs_block_group_done(cache) ||\n\t\t   (cache->free_space_ctl->free_space >= num_bytes));\n\n\tbtrfs_put_caching_control(caching_ctl);\n}\n\nint btrfs_wait_block_group_cache_done(struct btrfs_block_group *cache)\n{\n\tstruct btrfs_caching_control *caching_ctl;\n\tint ret = 0;\n\n\tcaching_ctl = btrfs_get_caching_control(cache);\n\tif (!caching_ctl)\n\t\treturn (cache->cached == BTRFS_CACHE_ERROR) ? -EIO : 0;\n\n\twait_event(caching_ctl->wait, btrfs_block_group_done(cache));\n\tif (cache->cached == BTRFS_CACHE_ERROR)\n\t\tret = -EIO;\n\tbtrfs_put_caching_control(caching_ctl);\n\treturn ret;\n}\n\nstatic bool space_cache_v1_done(struct btrfs_block_group *cache)\n{\n\tbool ret;\n\n\tspin_lock(&cache->lock);\n\tret = cache->cached != BTRFS_CACHE_FAST;\n\tspin_unlock(&cache->lock);\n\n\treturn ret;\n}\n\nvoid btrfs_wait_space_cache_v1_finished(struct btrfs_block_group *cache,\n\t\t\t\tstruct btrfs_caching_control *caching_ctl)\n{\n\twait_event(caching_ctl->wait, space_cache_v1_done(cache));\n}\n\n#ifdef CONFIG_BTRFS_DEBUG\nstatic void fragment_free_space(struct btrfs_block_group *block_group)\n{\n\tstruct btrfs_fs_info *fs_info = block_group->fs_info;\n\tu64 start = block_group->start;\n\tu64 len = block_group->length;\n\tu64 chunk = block_group->flags & BTRFS_BLOCK_GROUP_METADATA ?\n\t\tfs_info->nodesize : fs_info->sectorsize;\n\tu64 step = chunk << 1;\n\n\twhile (len > chunk) {\n\t\tbtrfs_remove_free_space(block_group, start, chunk);\n\t\tstart += step;\n\t\tif (len < step)\n\t\t\tlen = 0;\n\t\telse\n\t\t\tlen -= step;\n\t}\n}\n#endif\n\n/*\n * This is only called by btrfs_cache_block_group, since we could have freed\n * extents we need to check the pinned_extents for any extents that can't be\n * used yet since their free space will be released as soon as the transaction\n * commits.\n */\nu64 add_new_free_space(struct btrfs_block_group *block_group, u64 start, u64 end)\n{\n\tstruct btrfs_fs_info *info = block_group->fs_info;\n\tu64 extent_start, extent_end, size, total_added = 0;\n\tint ret;\n\n\twhile (start < end) {\n\t\tret = find_first_extent_bit(&info->excluded_extents, start,\n\t\t\t\t\t    &extent_start, &extent_end,\n\t\t\t\t\t    EXTENT_DIRTY | EXTENT_UPTODATE,\n\t\t\t\t\t    NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (extent_start <= start) {\n\t\t\tstart = extent_end + 1;\n\t\t} else if (extent_start > start && extent_start < end) {\n\t\t\tsize = extent_start - start;\n\t\t\ttotal_added += size;\n\t\t\tret = btrfs_add_free_space_async_trimmed(block_group,\n\t\t\t\t\t\t\t\t start, size);\n\t\t\tBUG_ON(ret); /* -ENOMEM or logic error */\n\t\t\tstart = extent_end + 1;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start < end) {\n\t\tsize = end - start;\n\t\ttotal_added += size;\n\t\tret = btrfs_add_free_space_async_trimmed(block_group, start,\n\t\t\t\t\t\t\t size);\n\t\tBUG_ON(ret); /* -ENOMEM or logic error */\n\t}\n\n\treturn total_added;\n}\n\nstatic int load_extent_tree_free(struct btrfs_caching_control *caching_ctl)\n{\n\tstruct btrfs_block_group *block_group = caching_ctl->block_group;\n\tstruct btrfs_fs_info *fs_info = block_group->fs_info;\n\tstruct btrfs_root *extent_root = fs_info->extent_root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tu64 total_found = 0;\n\tu64 last = 0;\n\tu32 nritems;\n\tint ret;\n\tbool wakeup = true;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tlast = max_t(u64, block_group->start, BTRFS_SUPER_INFO_OFFSET);\n\n#ifdef CONFIG_BTRFS_DEBUG\n\t/*\n\t * If we're fragmenting we don't want to make anybody think we can\n\t * allocate from this block group until we've had a chance to fragment\n\t * the free space.\n\t */\n\tif (btrfs_should_fragment_free_space(block_group))\n\t\twakeup = false;\n#endif\n\t/*\n\t * We don't want to deadlock with somebody trying to allocate a new\n\t * extent for the extent root while also trying to search the extent\n\t * root to add free space.  So we skip locking and search the commit\n\t * root, since its read-only\n\t */\n\tpath->skip_locking = 1;\n\tpath->search_commit_root = 1;\n\tpath->reada = READA_FORWARD;\n\n\tkey.objectid = last;\n\tkey.offset = 0;\n\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\nnext:\n\tret = btrfs_search_slot(NULL, extent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tnritems = btrfs_header_nritems(leaf);\n\n\twhile (1) {\n\t\tif (btrfs_fs_closing(fs_info) > 1) {\n\t\t\tlast = (u64)-1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (path->slots[0] < nritems) {\n\t\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\t} else {\n\t\t\tret = btrfs_find_next_key(extent_root, path, &key, 0, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (need_resched() ||\n\t\t\t    rwsem_is_contended(&fs_info->commit_root_sem)) {\n\t\t\t\tif (wakeup)\n\t\t\t\t\tcaching_ctl->progress = last;\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tup_read(&fs_info->commit_root_sem);\n\t\t\t\tmutex_unlock(&caching_ctl->mutex);\n\t\t\t\tcond_resched();\n\t\t\t\tmutex_lock(&caching_ctl->mutex);\n\t\t\t\tdown_read(&fs_info->commit_root_sem);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tret = btrfs_next_leaf(extent_root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t\tnritems = btrfs_header_nritems(leaf);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (key.objectid < last) {\n\t\t\tkey.objectid = last;\n\t\t\tkey.offset = 0;\n\t\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\n\t\t\tif (wakeup)\n\t\t\t\tcaching_ctl->progress = last;\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (key.objectid < block_group->start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (key.objectid >= block_group->start + block_group->length)\n\t\t\tbreak;\n\n\t\tif (key.type == BTRFS_EXTENT_ITEM_KEY ||\n\t\t    key.type == BTRFS_METADATA_ITEM_KEY) {\n\t\t\ttotal_found += add_new_free_space(block_group, last,\n\t\t\t\t\t\t\t  key.objectid);\n\t\t\tif (key.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\t\tlast = key.objectid +\n\t\t\t\t\tfs_info->nodesize;\n\t\t\telse\n\t\t\t\tlast = key.objectid + key.offset;\n\n\t\t\tif (total_found > CACHING_CTL_WAKE_UP) {\n\t\t\t\ttotal_found = 0;\n\t\t\t\tif (wakeup)\n\t\t\t\t\twake_up(&caching_ctl->wait);\n\t\t\t}\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\n\n\ttotal_found += add_new_free_space(block_group, last,\n\t\t\t\tblock_group->start + block_group->length);\n\tcaching_ctl->progress = (u64)-1;\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic noinline void caching_thread(struct btrfs_work *work)\n{\n\tstruct btrfs_block_group *block_group;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct btrfs_caching_control *caching_ctl;\n\tint ret;\n\n\tcaching_ctl = container_of(work, struct btrfs_caching_control, work);\n\tblock_group = caching_ctl->block_group;\n\tfs_info = block_group->fs_info;\n\n\tmutex_lock(&caching_ctl->mutex);\n\tdown_read(&fs_info->commit_root_sem);\n\n\tif (btrfs_test_opt(fs_info, SPACE_CACHE)) {\n\t\tret = load_free_space_cache(block_group);\n\t\tif (ret == 1) {\n\t\t\tret = 0;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/*\n\t\t * We failed to load the space cache, set ourselves to\n\t\t * CACHE_STARTED and carry on.\n\t\t */\n\t\tspin_lock(&block_group->lock);\n\t\tblock_group->cached = BTRFS_CACHE_STARTED;\n\t\tspin_unlock(&block_group->lock);\n\t\twake_up(&caching_ctl->wait);\n\t}\n\n\t/*\n\t * If we are in the transaction that populated the free space tree we\n\t * can't actually cache from the free space tree as our commit root and\n\t * real root are the same, so we could change the contents of the blocks\n\t * while caching.  Instead do the slow caching in this case, and after\n\t * the transaction has committed we will be safe.\n\t */\n\tif (btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE) &&\n\t    !(test_bit(BTRFS_FS_FREE_SPACE_TREE_UNTRUSTED, &fs_info->flags)))\n\t\tret = load_free_space_tree(caching_ctl);\n\telse\n\t\tret = load_extent_tree_free(caching_ctl);\ndone:\n\tspin_lock(&block_group->lock);\n\tblock_group->caching_ctl = NULL;\n\tblock_group->cached = ret ? BTRFS_CACHE_ERROR : BTRFS_CACHE_FINISHED;\n\tspin_unlock(&block_group->lock);\n\n#ifdef CONFIG_BTRFS_DEBUG\n\tif (btrfs_should_fragment_free_space(block_group)) {\n\t\tu64 bytes_used;\n\n\t\tspin_lock(&block_group->space_info->lock);\n\t\tspin_lock(&block_group->lock);\n\t\tbytes_used = block_group->length - block_group->used;\n\t\tblock_group->space_info->bytes_used += bytes_used >> 1;\n\t\tspin_unlock(&block_group->lock);\n\t\tspin_unlock(&block_group->space_info->lock);\n\t\tfragment_free_space(block_group);\n\t}\n#endif\n\n\tcaching_ctl->progress = (u64)-1;\n\n\tup_read(&fs_info->commit_root_sem);\n\tbtrfs_free_excluded_extents(block_group);\n\tmutex_unlock(&caching_ctl->mutex);\n\n\twake_up(&caching_ctl->wait);\n\n\tbtrfs_put_caching_control(caching_ctl);\n\tbtrfs_put_block_group(block_group);\n}\n\nint btrfs_cache_block_group(struct btrfs_block_group *cache, int load_cache_only)\n{\n\tDEFINE_WAIT(wait);\n\tstruct btrfs_fs_info *fs_info = cache->fs_info;\n\tstruct btrfs_caching_control *caching_ctl = NULL;\n\tint ret = 0;\n\n\t/* Allocator for zoned filesystems does not use the cache at all */\n\tif (btrfs_is_zoned(fs_info))\n\t\treturn 0;\n\n\tcaching_ctl = kzalloc(sizeof(*caching_ctl), GFP_NOFS);\n\tif (!caching_ctl)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&caching_ctl->list);\n\tmutex_init(&caching_ctl->mutex);\n\tinit_waitqueue_head(&caching_ctl->wait);\n\tcaching_ctl->block_group = cache;\n\tcaching_ctl->progress = cache->start;\n\trefcount_set(&caching_ctl->count, 2);\n\tbtrfs_init_work(&caching_ctl->work, caching_thread, NULL, NULL);\n\n\tspin_lock(&cache->lock);\n\tif (cache->cached != BTRFS_CACHE_NO) {\n\t\tkfree(caching_ctl);\n\n\t\tcaching_ctl = cache->caching_ctl;\n\t\tif (caching_ctl)\n\t\t\trefcount_inc(&caching_ctl->count);\n\t\tspin_unlock(&cache->lock);\n\t\tgoto out;\n\t}\n\tWARN_ON(cache->caching_ctl);\n\tcache->caching_ctl = caching_ctl;\n\tif (btrfs_test_opt(fs_info, SPACE_CACHE))\n\t\tcache->cached = BTRFS_CACHE_FAST;\n\telse\n\t\tcache->cached = BTRFS_CACHE_STARTED;\n\tcache->has_caching_ctl = 1;\n\tspin_unlock(&cache->lock);\n\n\tspin_lock(&fs_info->block_group_cache_lock);\n\trefcount_inc(&caching_ctl->count);\n\tlist_add_tail(&caching_ctl->list, &fs_info->caching_block_groups);\n\tspin_unlock(&fs_info->block_group_cache_lock);\n\n\tbtrfs_get_block_group(cache);\n\n\tbtrfs_queue_work(fs_info->caching_workers, &caching_ctl->work);\nout:\n\tif (load_cache_only && caching_ctl)\n\t\tbtrfs_wait_space_cache_v1_finished(cache, caching_ctl);\n\tif (caching_ctl)\n\t\tbtrfs_put_caching_control(caching_ctl);\n\n\treturn ret;\n}\n\nstatic void clear_avail_alloc_bits(struct btrfs_fs_info *fs_info, u64 flags)\n{\n\tu64 extra_flags = chunk_to_extended(flags) &\n\t\t\t\tBTRFS_EXTENDED_PROFILE_MASK;\n\n\twrite_seqlock(&fs_info->profiles_lock);\n\tif (flags & BTRFS_BLOCK_GROUP_DATA)\n\t\tfs_info->avail_data_alloc_bits &= ~extra_flags;\n\tif (flags & BTRFS_BLOCK_GROUP_METADATA)\n\t\tfs_info->avail_metadata_alloc_bits &= ~extra_flags;\n\tif (flags & BTRFS_BLOCK_GROUP_SYSTEM)\n\t\tfs_info->avail_system_alloc_bits &= ~extra_flags;\n\twrite_sequnlock(&fs_info->profiles_lock);\n}\n\n/*\n * Clear incompat bits for the following feature(s):\n *\n * - RAID56 - in case there's neither RAID5 nor RAID6 profile block group\n *            in the whole filesystem\n *\n * - RAID1C34 - same as above for RAID1C3 and RAID1C4 block groups\n */\nstatic void clear_incompat_bg_bits(struct btrfs_fs_info *fs_info, u64 flags)\n{\n\tbool found_raid56 = false;\n\tbool found_raid1c34 = false;\n\n\tif ((flags & BTRFS_BLOCK_GROUP_RAID56_MASK) ||\n\t    (flags & BTRFS_BLOCK_GROUP_RAID1C3) ||\n\t    (flags & BTRFS_BLOCK_GROUP_RAID1C4)) {\n\t\tstruct list_head *head = &fs_info->space_info;\n\t\tstruct btrfs_space_info *sinfo;\n\n\t\tlist_for_each_entry_rcu(sinfo, head, list) {\n\t\t\tdown_read(&sinfo->groups_sem);\n\t\t\tif (!list_empty(&sinfo->block_groups[BTRFS_RAID_RAID5]))\n\t\t\t\tfound_raid56 = true;\n\t\t\tif (!list_empty(&sinfo->block_groups[BTRFS_RAID_RAID6]))\n\t\t\t\tfound_raid56 = true;\n\t\t\tif (!list_empty(&sinfo->block_groups[BTRFS_RAID_RAID1C3]))\n\t\t\t\tfound_raid1c34 = true;\n\t\t\tif (!list_empty(&sinfo->block_groups[BTRFS_RAID_RAID1C4]))\n\t\t\t\tfound_raid1c34 = true;\n\t\t\tup_read(&sinfo->groups_sem);\n\t\t}\n\t\tif (!found_raid56)\n\t\t\tbtrfs_clear_fs_incompat(fs_info, RAID56);\n\t\tif (!found_raid1c34)\n\t\t\tbtrfs_clear_fs_incompat(fs_info, RAID1C34);\n\t}\n}\n\nstatic int remove_block_group_item(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct btrfs_block_group *block_group)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tint ret;\n\n\troot = fs_info->extent_root;\n\tkey.objectid = block_group->start;\n\tkey.type = BTRFS_BLOCK_GROUP_ITEM_KEY;\n\tkey.offset = block_group->length;\n\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret > 0)\n\t\tret = -ENOENT;\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = btrfs_del_item(trans, root, path);\n\treturn ret;\n}\n\nint btrfs_remove_block_group(struct btrfs_trans_handle *trans,\n\t\t\t     u64 group_start, struct extent_map *em)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_path *path;\n\tstruct btrfs_block_group *block_group;\n\tstruct btrfs_free_cluster *cluster;\n\tstruct inode *inode;\n\tstruct kobject *kobj = NULL;\n\tint ret;\n\tint index;\n\tint factor;\n\tstruct btrfs_caching_control *caching_ctl = NULL;\n\tbool remove_em;\n\tbool remove_rsv = false;\n\n\tblock_group = btrfs_lookup_block_group(fs_info, group_start);\n\tBUG_ON(!block_group);\n\tBUG_ON(!block_group->ro);\n\n\ttrace_btrfs_remove_block_group(block_group);\n\t/*\n\t * Free the reserved super bytes from this block group before\n\t * remove it.\n\t */\n\tbtrfs_free_excluded_extents(block_group);\n\tbtrfs_free_ref_tree_range(fs_info, block_group->start,\n\t\t\t\t  block_group->length);\n\n\tindex = btrfs_bg_flags_to_raid_index(block_group->flags);\n\tfactor = btrfs_bg_type_to_factor(block_group->flags);\n\n\t/* make sure this block group isn't part of an allocation cluster */\n\tcluster = &fs_info->data_alloc_cluster;\n\tspin_lock(&cluster->refill_lock);\n\tbtrfs_return_cluster_to_free_space(block_group, cluster);\n\tspin_unlock(&cluster->refill_lock);\n\n\t/*\n\t * make sure this block group isn't part of a metadata\n\t * allocation cluster\n\t */\n\tcluster = &fs_info->meta_alloc_cluster;\n\tspin_lock(&cluster->refill_lock);\n\tbtrfs_return_cluster_to_free_space(block_group, cluster);\n\tspin_unlock(&cluster->refill_lock);\n\n\tbtrfs_clear_treelog_bg(block_group);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * get the inode first so any iput calls done for the io_list\n\t * aren't the final iput (no unlinks allowed now)\n\t */\n\tinode = lookup_free_space_inode(block_group, path);\n\n\tmutex_lock(&trans->transaction->cache_write_mutex);\n\t/*\n\t * Make sure our free space cache IO is done before removing the\n\t * free space inode\n\t */\n\tspin_lock(&trans->transaction->dirty_bgs_lock);\n\tif (!list_empty(&block_group->io_list)) {\n\t\tlist_del_init(&block_group->io_list);\n\n\t\tWARN_ON(!IS_ERR(inode) && inode != block_group->io_ctl.inode);\n\n\t\tspin_unlock(&trans->transaction->dirty_bgs_lock);\n\t\tbtrfs_wait_cache_io(trans, block_group, path);\n\t\tbtrfs_put_block_group(block_group);\n\t\tspin_lock(&trans->transaction->dirty_bgs_lock);\n\t}\n\n\tif (!list_empty(&block_group->dirty_list)) {\n\t\tlist_del_init(&block_group->dirty_list);\n\t\tremove_rsv = true;\n\t\tbtrfs_put_block_group(block_group);\n\t}\n\tspin_unlock(&trans->transaction->dirty_bgs_lock);\n\tmutex_unlock(&trans->transaction->cache_write_mutex);\n\n\tret = btrfs_remove_free_space_inode(trans, inode, block_group);\n\tif (ret)\n\t\tgoto out;\n\n\tspin_lock(&fs_info->block_group_cache_lock);\n\trb_erase(&block_group->cache_node,\n\t\t &fs_info->block_group_cache_tree);\n\tRB_CLEAR_NODE(&block_group->cache_node);\n\n\t/* Once for the block groups rbtree */\n\tbtrfs_put_block_group(block_group);\n\n\tif (fs_info->first_logical_byte == block_group->start)\n\t\tfs_info->first_logical_byte = (u64)-1;\n\tspin_unlock(&fs_info->block_group_cache_lock);\n\n\tdown_write(&block_group->space_info->groups_sem);\n\t/*\n\t * we must use list_del_init so people can check to see if they\n\t * are still on the list after taking the semaphore\n\t */\n\tlist_del_init(&block_group->list);\n\tif (list_empty(&block_group->space_info->block_groups[index])) {\n\t\tkobj = block_group->space_info->block_group_kobjs[index];\n\t\tblock_group->space_info->block_group_kobjs[index] = NULL;\n\t\tclear_avail_alloc_bits(fs_info, block_group->flags);\n\t}\n\tup_write(&block_group->space_info->groups_sem);\n\tclear_incompat_bg_bits(fs_info, block_group->flags);\n\tif (kobj) {\n\t\tkobject_del(kobj);\n\t\tkobject_put(kobj);\n\t}\n\n\tif (block_group->has_caching_ctl)\n\t\tcaching_ctl = btrfs_get_caching_control(block_group);\n\tif (block_group->cached == BTRFS_CACHE_STARTED)\n\t\tbtrfs_wait_block_group_cache_done(block_group);\n\tif (block_group->has_caching_ctl) {\n\t\tspin_lock(&fs_info->block_group_cache_lock);\n\t\tif (!caching_ctl) {\n\t\t\tstruct btrfs_caching_control *ctl;\n\n\t\t\tlist_for_each_entry(ctl,\n\t\t\t\t    &fs_info->caching_block_groups, list)\n\t\t\t\tif (ctl->block_group == block_group) {\n\t\t\t\t\tcaching_ctl = ctl;\n\t\t\t\t\trefcount_inc(&caching_ctl->count);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tif (caching_ctl)\n\t\t\tlist_del_init(&caching_ctl->list);\n\t\tspin_unlock(&fs_info->block_group_cache_lock);\n\t\tif (caching_ctl) {\n\t\t\t/* Once for the caching bgs list and once for us. */\n\t\t\tbtrfs_put_caching_control(caching_ctl);\n\t\t\tbtrfs_put_caching_control(caching_ctl);\n\t\t}\n\t}\n\n\tspin_lock(&trans->transaction->dirty_bgs_lock);\n\tWARN_ON(!list_empty(&block_group->dirty_list));\n\tWARN_ON(!list_empty(&block_group->io_list));\n\tspin_unlock(&trans->transaction->dirty_bgs_lock);\n\n\tbtrfs_remove_free_space_cache(block_group);\n\n\tspin_lock(&block_group->space_info->lock);\n\tlist_del_init(&block_group->ro_list);\n\n\tif (btrfs_test_opt(fs_info, ENOSPC_DEBUG)) {\n\t\tWARN_ON(block_group->space_info->total_bytes\n\t\t\t< block_group->length);\n\t\tWARN_ON(block_group->space_info->bytes_readonly\n\t\t\t< block_group->length - block_group->zone_unusable);\n\t\tWARN_ON(block_group->space_info->bytes_zone_unusable\n\t\t\t< block_group->zone_unusable);\n\t\tWARN_ON(block_group->space_info->disk_total\n\t\t\t< block_group->length * factor);\n\t}\n\tblock_group->space_info->total_bytes -= block_group->length;\n\tblock_group->space_info->bytes_readonly -=\n\t\t(block_group->length - block_group->zone_unusable);\n\tblock_group->space_info->bytes_zone_unusable -=\n\t\tblock_group->zone_unusable;\n\tblock_group->space_info->disk_total -= block_group->length * factor;\n\n\tspin_unlock(&block_group->space_info->lock);\n\n\t/*\n\t * Remove the free space for the block group from the free space tree\n\t * and the block group's item from the extent tree before marking the\n\t * block group as removed. This is to prevent races with tasks that\n\t * freeze and unfreeze a block group, this task and another task\n\t * allocating a new block group - the unfreeze task ends up removing\n\t * the block group's extent map before the task calling this function\n\t * deletes the block group item from the extent tree, allowing for\n\t * another task to attempt to create another block group with the same\n\t * item key (and failing with -EEXIST and a transaction abort).\n\t */\n\tret = remove_block_group_free_space(trans, block_group);\n\tif (ret)\n\t\tgoto out;\n\n\tret = remove_block_group_item(trans, path, block_group);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tspin_lock(&block_group->lock);\n\tblock_group->removed = 1;\n\t/*\n\t * At this point trimming or scrub can't start on this block group,\n\t * because we removed the block group from the rbtree\n\t * fs_info->block_group_cache_tree so no one can't find it anymore and\n\t * even if someone already got this block group before we removed it\n\t * from the rbtree, they have already incremented block_group->frozen -\n\t * if they didn't, for the trimming case they won't find any free space\n\t * entries because we already removed them all when we called\n\t * btrfs_remove_free_space_cache().\n\t *\n\t * And we must not remove the extent map from the fs_info->mapping_tree\n\t * to prevent the same logical address range and physical device space\n\t * ranges from being reused for a new block group. This is needed to\n\t * avoid races with trimming and scrub.\n\t *\n\t * An fs trim operation (btrfs_trim_fs() / btrfs_ioctl_fitrim()) is\n\t * completely transactionless, so while it is trimming a range the\n\t * currently running transaction might finish and a new one start,\n\t * allowing for new block groups to be created that can reuse the same\n\t * physical device locations unless we take this special care.\n\t *\n\t * There may also be an implicit trim operation if the file system\n\t * is mounted with -odiscard. The same protections must remain\n\t * in place until the extents have been discarded completely when\n\t * the transaction commit has completed.\n\t */\n\tremove_em = (atomic_read(&block_group->frozen) == 0);\n\tspin_unlock(&block_group->lock);\n\n\tif (remove_em) {\n\t\tstruct extent_map_tree *em_tree;\n\n\t\tem_tree = &fs_info->mapping_tree;\n\t\twrite_lock(&em_tree->lock);\n\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\t\t/* once for the tree */\n\t\tfree_extent_map(em);\n\t}\n\nout:\n\t/* Once for the lookup reference */\n\tbtrfs_put_block_group(block_group);\n\tif (remove_rsv)\n\t\tbtrfs_delayed_refs_rsv_release(fs_info, 1);\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstruct btrfs_trans_handle *btrfs_start_trans_remove_block_group(\n\t\tstruct btrfs_fs_info *fs_info, const u64 chunk_offset)\n{\n\tstruct extent_map_tree *em_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tunsigned int num_items;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, chunk_offset, 1);\n\tread_unlock(&em_tree->lock);\n\tASSERT(em && em->start == chunk_offset);\n\n\t/*\n\t * We need to reserve 3 + N units from the metadata space info in order\n\t * to remove a block group (done at btrfs_remove_chunk() and at\n\t * btrfs_remove_block_group()), which are used for:\n\t *\n\t * 1 unit for adding the free space inode's orphan (located in the tree\n\t * of tree roots).\n\t * 1 unit for deleting the block group item (located in the extent\n\t * tree).\n\t * 1 unit for deleting the free space item (located in tree of tree\n\t * roots).\n\t * N units for deleting N device extent items corresponding to each\n\t * stripe (located in the device tree).\n\t *\n\t * In order to remove a block group we also need to reserve units in the\n\t * system space info in order to update the chunk tree (update one or\n\t * more device items and remove one chunk item), but this is done at\n\t * btrfs_remove_chunk() through a call to check_system_chunk().\n\t */\n\tmap = em->map_lookup;\n\tnum_items = 3 + map->num_stripes;\n\tfree_extent_map(em);\n\n\treturn btrfs_start_transaction_fallback_global_rsv(fs_info->extent_root,\n\t\t\t\t\t\t\t   num_items);\n}\n\n/*\n * Mark block group @cache read-only, so later write won't happen to block\n * group @cache.\n *\n * If @force is not set, this function will only mark the block group readonly\n * if we have enough free space (1M) in other metadata/system block groups.\n * If @force is not set, this function will mark the block group readonly\n * without checking free space.\n *\n * NOTE: This function doesn't care if other block groups can contain all the\n * data in this block group. That check should be done by relocation routine,\n * not this function.\n */\nstatic int inc_block_group_ro(struct btrfs_block_group *cache, int force)\n{\n\tstruct btrfs_space_info *sinfo = cache->space_info;\n\tu64 num_bytes;\n\tint ret = -ENOSPC;\n\n\tspin_lock(&sinfo->lock);\n\tspin_lock(&cache->lock);\n\n\tif (cache->swap_extents) {\n\t\tret = -ETXTBSY;\n\t\tgoto out;\n\t}\n\n\tif (cache->ro) {\n\t\tcache->ro++;\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tnum_bytes = cache->length - cache->reserved - cache->pinned -\n\t\t    cache->bytes_super - cache->zone_unusable - cache->used;\n\n\t/*\n\t * Data never overcommits, even in mixed mode, so do just the straight\n\t * check of left over space in how much we have allocated.\n\t */\n\tif (force) {\n\t\tret = 0;\n\t} else if (sinfo->flags & BTRFS_BLOCK_GROUP_DATA) {\n\t\tu64 sinfo_used = btrfs_space_info_used(sinfo, true);\n\n\t\t/*\n\t\t * Here we make sure if we mark this bg RO, we still have enough\n\t\t * free space as buffer.\n\t\t */\n\t\tif (sinfo_used + num_bytes <= sinfo->total_bytes)\n\t\t\tret = 0;\n\t} else {\n\t\t/*\n\t\t * We overcommit metadata, so we need to do the\n\t\t * btrfs_can_overcommit check here, and we need to pass in\n\t\t * BTRFS_RESERVE_NO_FLUSH to give ourselves the most amount of\n\t\t * leeway to allow us to mark this block group as read only.\n\t\t */\n\t\tif (btrfs_can_overcommit(cache->fs_info, sinfo, num_bytes,\n\t\t\t\t\t BTRFS_RESERVE_NO_FLUSH))\n\t\t\tret = 0;\n\t}\n\n\tif (!ret) {\n\t\tsinfo->bytes_readonly += num_bytes;\n\t\tif (btrfs_is_zoned(cache->fs_info)) {\n\t\t\t/* Migrate zone_unusable bytes to readonly */\n\t\t\tsinfo->bytes_readonly += cache->zone_unusable;\n\t\t\tsinfo->bytes_zone_unusable -= cache->zone_unusable;\n\t\t\tcache->zone_unusable = 0;\n\t\t}\n\t\tcache->ro++;\n\t\tlist_add_tail(&cache->ro_list, &sinfo->ro_bgs);\n\t}\nout:\n\tspin_unlock(&cache->lock);\n\tspin_unlock(&sinfo->lock);\n\tif (ret == -ENOSPC && btrfs_test_opt(cache->fs_info, ENOSPC_DEBUG)) {\n\t\tbtrfs_info(cache->fs_info,\n\t\t\t\"unable to make block group %llu ro\", cache->start);\n\t\tbtrfs_dump_space_info(cache->fs_info, cache->space_info, 0, 0);\n\t}\n\treturn ret;\n}\n\nstatic bool clean_pinned_extents(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_block_group *bg)\n{\n\tstruct btrfs_fs_info *fs_info = bg->fs_info;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tconst u64 start = bg->start;\n\tconst u64 end = start + bg->length - 1;\n\tint ret;\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (trans->transaction->list.prev != &fs_info->trans_list) {\n\t\tprev_trans = list_last_entry(&trans->transaction->list,\n\t\t\t\t\t     struct btrfs_transaction, list);\n\t\trefcount_inc(&prev_trans->use_count);\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n\n\t/*\n\t * Hold the unused_bg_unpin_mutex lock to avoid racing with\n\t * btrfs_finish_extent_commit(). If we are at transaction N, another\n\t * task might be running finish_extent_commit() for the previous\n\t * transaction N - 1, and have seen a range belonging to the block\n\t * group in pinned_extents before we were able to clear the whole block\n\t * group range from pinned_extents. This means that task can lookup for\n\t * the block group after we unpinned it from pinned_extents and removed\n\t * it, leading to a BUG_ON() at unpin_extent_range().\n\t */\n\tmutex_lock(&fs_info->unused_bg_unpin_mutex);\n\tif (prev_trans) {\n\t\tret = clear_extent_bits(&prev_trans->pinned_extents, start, end,\n\t\t\t\t\tEXTENT_DIRTY);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = clear_extent_bits(&trans->transaction->pinned_extents, start, end,\n\t\t\t\tEXTENT_DIRTY);\nout:\n\tmutex_unlock(&fs_info->unused_bg_unpin_mutex);\n\tif (prev_trans)\n\t\tbtrfs_put_transaction(prev_trans);\n\n\treturn ret == 0;\n}\n\n/*\n * Process the unused_bgs list and remove any that don't have any allocated\n * space inside of them.\n */\nvoid btrfs_delete_unused_bgs(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_block_group *block_group;\n\tstruct btrfs_space_info *space_info;\n\tstruct btrfs_trans_handle *trans;\n\tconst bool async_trim_enabled = btrfs_test_opt(fs_info, DISCARD_ASYNC);\n\tint ret = 0;\n\n\tif (!test_bit(BTRFS_FS_OPEN, &fs_info->flags))\n\t\treturn;\n\n\t/*\n\t * Long running balances can keep us blocked here for eternity, so\n\t * simply skip deletion if we're unable to get the mutex.\n\t */\n\tif (!mutex_trylock(&fs_info->reclaim_bgs_lock))\n\t\treturn;\n\n\tspin_lock(&fs_info->unused_bgs_lock);\n\twhile (!list_empty(&fs_info->unused_bgs)) {\n\t\tint trimming;\n\n\t\tblock_group = list_first_entry(&fs_info->unused_bgs,\n\t\t\t\t\t       struct btrfs_block_group,\n\t\t\t\t\t       bg_list);\n\t\tlist_del_init(&block_group->bg_list);\n\n\t\tspace_info = block_group->space_info;\n\n\t\tif (ret || btrfs_mixed_space_info(space_info)) {\n\t\t\tbtrfs_put_block_group(block_group);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&fs_info->unused_bgs_lock);\n\n\t\tbtrfs_discard_cancel_work(&fs_info->discard_ctl, block_group);\n\n\t\t/* Don't want to race with allocators so take the groups_sem */\n\t\tdown_write(&space_info->groups_sem);\n\n\t\t/*\n\t\t * Async discard moves the final block group discard to be prior\n\t\t * to the unused_bgs code path.  Therefore, if it's not fully\n\t\t * trimmed, punt it back to the async discard lists.\n\t\t */\n\t\tif (btrfs_test_opt(fs_info, DISCARD_ASYNC) &&\n\t\t    !btrfs_is_free_space_trimmed(block_group)) {\n\t\t\ttrace_btrfs_skip_unused_block_group(block_group);\n\t\t\tup_write(&space_info->groups_sem);\n\t\t\t/* Requeue if we failed because of async discard */\n\t\t\tbtrfs_discard_queue_work(&fs_info->discard_ctl,\n\t\t\t\t\t\t block_group);\n\t\t\tgoto next;\n\t\t}\n\n\t\tspin_lock(&block_group->lock);\n\t\tif (block_group->reserved || block_group->pinned ||\n\t\t    block_group->used || block_group->ro ||\n\t\t    list_is_singular(&block_group->list)) {\n\t\t\t/*\n\t\t\t * We want to bail if we made new allocations or have\n\t\t\t * outstanding allocations in this block group.  We do\n\t\t\t * the ro check in case balance is currently acting on\n\t\t\t * this block group.\n\t\t\t */\n\t\t\ttrace_btrfs_skip_unused_block_group(block_group);\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tup_write(&space_info->groups_sem);\n\t\t\tgoto next;\n\t\t}\n\t\tspin_unlock(&block_group->lock);\n\n\t\t/* We don't want to force the issue, only flip if it's ok. */\n\t\tret = inc_block_group_ro(block_group, 0);\n\t\tup_write(&space_info->groups_sem);\n\t\tif (ret < 0) {\n\t\t\tret = 0;\n\t\t\tgoto next;\n\t\t}\n\n\t\t/*\n\t\t * Want to do this before we do anything else so we can recover\n\t\t * properly if we fail to join the transaction.\n\t\t */\n\t\ttrans = btrfs_start_trans_remove_block_group(fs_info,\n\t\t\t\t\t\t     block_group->start);\n\t\tif (IS_ERR(trans)) {\n\t\t\tbtrfs_dec_block_group_ro(block_group);\n\t\t\tret = PTR_ERR(trans);\n\t\t\tgoto next;\n\t\t}\n\n\t\t/*\n\t\t * We could have pending pinned extents for this block group,\n\t\t * just delete them, we don't care about them anymore.\n\t\t */\n\t\tif (!clean_pinned_extents(trans, block_group)) {\n\t\t\tbtrfs_dec_block_group_ro(block_group);\n\t\t\tgoto end_trans;\n\t\t}\n\n\t\t/*\n\t\t * At this point, the block_group is read only and should fail\n\t\t * new allocations.  However, btrfs_finish_extent_commit() can\n\t\t * cause this block_group to be placed back on the discard\n\t\t * lists because now the block_group isn't fully discarded.\n\t\t * Bail here and try again later after discarding everything.\n\t\t */\n\t\tspin_lock(&fs_info->discard_ctl.lock);\n\t\tif (!list_empty(&block_group->discard_list)) {\n\t\t\tspin_unlock(&fs_info->discard_ctl.lock);\n\t\t\tbtrfs_dec_block_group_ro(block_group);\n\t\t\tbtrfs_discard_queue_work(&fs_info->discard_ctl,\n\t\t\t\t\t\t block_group);\n\t\t\tgoto end_trans;\n\t\t}\n\t\tspin_unlock(&fs_info->discard_ctl.lock);\n\n\t\t/* Reset pinned so btrfs_put_block_group doesn't complain */\n\t\tspin_lock(&space_info->lock);\n\t\tspin_lock(&block_group->lock);\n\n\t\tbtrfs_space_info_update_bytes_pinned(fs_info, space_info,\n\t\t\t\t\t\t     -block_group->pinned);\n\t\tspace_info->bytes_readonly += block_group->pinned;\n\t\tblock_group->pinned = 0;\n\n\t\tspin_unlock(&block_group->lock);\n\t\tspin_unlock(&space_info->lock);\n\n\t\t/*\n\t\t * The normal path here is an unused block group is passed here,\n\t\t * then trimming is handled in the transaction commit path.\n\t\t * Async discard interposes before this to do the trimming\n\t\t * before coming down the unused block group path as trimming\n\t\t * will no longer be done later in the transaction commit path.\n\t\t */\n\t\tif (!async_trim_enabled && btrfs_test_opt(fs_info, DISCARD_ASYNC))\n\t\t\tgoto flip_async;\n\n\t\t/*\n\t\t * DISCARD can flip during remount. On zoned filesystems, we\n\t\t * need to reset sequential-required zones.\n\t\t */\n\t\ttrimming = btrfs_test_opt(fs_info, DISCARD_SYNC) ||\n\t\t\t\tbtrfs_is_zoned(fs_info);\n\n\t\t/* Implicit trim during transaction commit. */\n\t\tif (trimming)\n\t\t\tbtrfs_freeze_block_group(block_group);\n\n\t\t/*\n\t\t * Btrfs_remove_chunk will abort the transaction if things go\n\t\t * horribly wrong.\n\t\t */\n\t\tret = btrfs_remove_chunk(trans, block_group->start);\n\n\t\tif (ret) {\n\t\t\tif (trimming)\n\t\t\t\tbtrfs_unfreeze_block_group(block_group);\n\t\t\tgoto end_trans;\n\t\t}\n\n\t\t/*\n\t\t * If we're not mounted with -odiscard, we can just forget\n\t\t * about this block group. Otherwise we'll need to wait\n\t\t * until transaction commit to do the actual discard.\n\t\t */\n\t\tif (trimming) {\n\t\t\tspin_lock(&fs_info->unused_bgs_lock);\n\t\t\t/*\n\t\t\t * A concurrent scrub might have added us to the list\n\t\t\t * fs_info->unused_bgs, so use a list_move operation\n\t\t\t * to add the block group to the deleted_bgs list.\n\t\t\t */\n\t\t\tlist_move(&block_group->bg_list,\n\t\t\t\t  &trans->transaction->deleted_bgs);\n\t\t\tspin_unlock(&fs_info->unused_bgs_lock);\n\t\t\tbtrfs_get_block_group(block_group);\n\t\t}\nend_trans:\n\t\tbtrfs_end_transaction(trans);\nnext:\n\t\tbtrfs_put_block_group(block_group);\n\t\tspin_lock(&fs_info->unused_bgs_lock);\n\t}\n\tspin_unlock(&fs_info->unused_bgs_lock);\n\tmutex_unlock(&fs_info->reclaim_bgs_lock);\n\treturn;\n\nflip_async:\n\tbtrfs_end_transaction(trans);\n\tmutex_unlock(&fs_info->reclaim_bgs_lock);\n\tbtrfs_put_block_group(block_group);\n\tbtrfs_discard_punt_unused_bgs_list(fs_info);\n}\n\nvoid btrfs_mark_bg_unused(struct btrfs_block_group *bg)\n{\n\tstruct btrfs_fs_info *fs_info = bg->fs_info;\n\n\tspin_lock(&fs_info->unused_bgs_lock);\n\tif (list_empty(&bg->bg_list)) {\n\t\tbtrfs_get_block_group(bg);\n\t\ttrace_btrfs_add_unused_block_group(bg);\n\t\tlist_add_tail(&bg->bg_list, &fs_info->unused_bgs);\n\t}\n\tspin_unlock(&fs_info->unused_bgs_lock);\n}\n\nvoid btrfs_reclaim_bgs_work(struct work_struct *work)\n{\n\tstruct btrfs_fs_info *fs_info =\n\t\tcontainer_of(work, struct btrfs_fs_info, reclaim_bgs_work);\n\tstruct btrfs_block_group *bg;\n\tstruct btrfs_space_info *space_info;\n\tLIST_HEAD(again_list);\n\n\tif (!test_bit(BTRFS_FS_OPEN, &fs_info->flags))\n\t\treturn;\n\n\tif (!btrfs_exclop_start(fs_info, BTRFS_EXCLOP_BALANCE))\n\t\treturn;\n\n\tmutex_lock(&fs_info->reclaim_bgs_lock);\n\tspin_lock(&fs_info->unused_bgs_lock);\n\twhile (!list_empty(&fs_info->reclaim_bgs)) {\n\t\tu64 zone_unusable;\n\t\tint ret = 0;\n\n\t\tbg = list_first_entry(&fs_info->reclaim_bgs,\n\t\t\t\t      struct btrfs_block_group,\n\t\t\t\t      bg_list);\n\t\tlist_del_init(&bg->bg_list);\n\n\t\tspace_info = bg->space_info;\n\t\tspin_unlock(&fs_info->unused_bgs_lock);\n\n\t\t/* Don't race with allocators so take the groups_sem */\n\t\tdown_write(&space_info->groups_sem);\n\n\t\tspin_lock(&bg->lock);\n\t\tif (bg->reserved || bg->pinned || bg->ro) {\n\t\t\t/*\n\t\t\t * We want to bail if we made new allocations or have\n\t\t\t * outstanding allocations in this block group.  We do\n\t\t\t * the ro check in case balance is currently acting on\n\t\t\t * this block group.\n\t\t\t */\n\t\t\tspin_unlock(&bg->lock);\n\t\t\tup_write(&space_info->groups_sem);\n\t\t\tgoto next;\n\t\t}\n\t\tspin_unlock(&bg->lock);\n\n\t\t/* Get out fast, in case we're unmounting the filesystem */\n\t\tif (btrfs_fs_closing(fs_info)) {\n\t\t\tup_write(&space_info->groups_sem);\n\t\t\tgoto next;\n\t\t}\n\n\t\t/*\n\t\t * Cache the zone_unusable value before turning the block group\n\t\t * to read only. As soon as the blog group is read only it's\n\t\t * zone_unusable value gets moved to the block group's read-only\n\t\t * bytes and isn't available for calculations anymore.\n\t\t */\n\t\tzone_unusable = bg->zone_unusable;\n\t\tret = inc_block_group_ro(bg, 0);\n\t\tup_write(&space_info->groups_sem);\n\t\tif (ret < 0)\n\t\t\tgoto next;\n\n\t\tbtrfs_info(fs_info,\n\t\t\t\"reclaiming chunk %llu with %llu%% used %llu%% unusable\",\n\t\t\t\tbg->start, div_u64(bg->used * 100, bg->length),\n\t\t\t\tdiv64_u64(zone_unusable * 100, bg->length));\n\t\ttrace_btrfs_reclaim_block_group(bg);\n\t\tret = btrfs_relocate_chunk(fs_info, bg->start);\n\t\tif (ret)\n\t\t\tbtrfs_err(fs_info, \"error relocating chunk %llu\",\n\t\t\t\t  bg->start);\n\nnext:\n\t\tspin_lock(&fs_info->unused_bgs_lock);\n\t\tif (ret == -EAGAIN && list_empty(&bg->bg_list))\n\t\t\tlist_add_tail(&bg->bg_list, &again_list);\n\t\telse\n\t\t\tbtrfs_put_block_group(bg);\n\t}\n\tlist_splice_tail(&again_list, &fs_info->reclaim_bgs);\n\tspin_unlock(&fs_info->unused_bgs_lock);\n\tmutex_unlock(&fs_info->reclaim_bgs_lock);\n\tbtrfs_exclop_finish(fs_info);\n}\n\nvoid btrfs_reclaim_bgs(struct btrfs_fs_info *fs_info)\n{\n\tspin_lock(&fs_info->unused_bgs_lock);\n\tif (!list_empty(&fs_info->reclaim_bgs))\n\t\tqueue_work(system_unbound_wq, &fs_info->reclaim_bgs_work);\n\tspin_unlock(&fs_info->unused_bgs_lock);\n}\n\nvoid btrfs_mark_bg_to_reclaim(struct btrfs_block_group *bg)\n{\n\tstruct btrfs_fs_info *fs_info = bg->fs_info;\n\n\tspin_lock(&fs_info->unused_bgs_lock);\n\tif (list_empty(&bg->bg_list)) {\n\t\tbtrfs_get_block_group(bg);\n\t\ttrace_btrfs_add_reclaim_block_group(bg);\n\t\tlist_add_tail(&bg->bg_list, &fs_info->reclaim_bgs);\n\t}\n\tspin_unlock(&fs_info->unused_bgs_lock);\n}\n\nstatic int read_bg_from_eb(struct btrfs_fs_info *fs_info, struct btrfs_key *key,\n\t\t\t   struct btrfs_path *path)\n{\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tstruct btrfs_block_group_item bg;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tu64 flags;\n\tint ret = 0;\n\n\tslot = path->slots[0];\n\tleaf = path->nodes[0];\n\n\tem_tree = &fs_info->mapping_tree;\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, key->objectid, key->offset);\n\tread_unlock(&em_tree->lock);\n\tif (!em) {\n\t\tbtrfs_err(fs_info,\n\t\t\t  \"logical %llu len %llu found bg but no related chunk\",\n\t\t\t  key->objectid, key->offset);\n\t\treturn -ENOENT;\n\t}\n\n\tif (em->start != key->objectid || em->len != key->offset) {\n\t\tbtrfs_err(fs_info,\n\t\t\t\"block group %llu len %llu mismatch with chunk %llu len %llu\",\n\t\t\tkey->objectid, key->offset, em->start, em->len);\n\t\tret = -EUCLEAN;\n\t\tgoto out_free_em;\n\t}\n\n\tread_extent_buffer(leaf, &bg, btrfs_item_ptr_offset(leaf, slot),\n\t\t\t   sizeof(bg));\n\tflags = btrfs_stack_block_group_flags(&bg) &\n\t\tBTRFS_BLOCK_GROUP_TYPE_MASK;\n\n\tif (flags != (em->map_lookup->type & BTRFS_BLOCK_GROUP_TYPE_MASK)) {\n\t\tbtrfs_err(fs_info,\n\"block group %llu len %llu type flags 0x%llx mismatch with chunk type flags 0x%llx\",\n\t\t\t  key->objectid, key->offset, flags,\n\t\t\t  (BTRFS_BLOCK_GROUP_TYPE_MASK & em->map_lookup->type));\n\t\tret = -EUCLEAN;\n\t}\n\nout_free_em:\n\tfree_extent_map(em);\n\treturn ret;\n}\n\nstatic int find_first_block_group(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct btrfs_key *key)\n{\n\tstruct btrfs_root *root = fs_info->extent_root;\n\tint ret;\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\n\tret = btrfs_search_slot(NULL, root, key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twhile (1) {\n\t\tslot = path->slots[0];\n\t\tleaf = path->nodes[0];\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\tif (found_key.objectid >= key->objectid &&\n\t\t    found_key.type == BTRFS_BLOCK_GROUP_ITEM_KEY) {\n\t\t\tret = read_bg_from_eb(fs_info, &found_key, path);\n\t\t\tbreak;\n\t\t}\n\n\t\tpath->slots[0]++;\n\t}\nout:\n\treturn ret;\n}\n\nstatic void set_avail_alloc_bits(struct btrfs_fs_info *fs_info, u64 flags)\n{\n\tu64 extra_flags = chunk_to_extended(flags) &\n\t\t\t\tBTRFS_EXTENDED_PROFILE_MASK;\n\n\twrite_seqlock(&fs_info->profiles_lock);\n\tif (flags & BTRFS_BLOCK_GROUP_DATA)\n\t\tfs_info->avail_data_alloc_bits |= extra_flags;\n\tif (flags & BTRFS_BLOCK_GROUP_METADATA)\n\t\tfs_info->avail_metadata_alloc_bits |= extra_flags;\n\tif (flags & BTRFS_BLOCK_GROUP_SYSTEM)\n\t\tfs_info->avail_system_alloc_bits |= extra_flags;\n\twrite_sequnlock(&fs_info->profiles_lock);\n}\n\n/**\n * Map a physical disk address to a list of logical addresses\n *\n * @fs_info:       the filesystem\n * @chunk_start:   logical address of block group\n * @bdev:\t   physical device to resolve, can be NULL to indicate any device\n * @physical:\t   physical address to map to logical addresses\n * @logical:\t   return array of logical addresses which map to @physical\n * @naddrs:\t   length of @logical\n * @stripe_len:    size of IO stripe for the given block group\n *\n * Maps a particular @physical disk address to a list of @logical addresses.\n * Used primarily to exclude those portions of a block group that contain super\n * block copies.\n */\nint btrfs_rmap_block(struct btrfs_fs_info *fs_info, u64 chunk_start,\n\t\t     struct block_device *bdev, u64 physical, u64 **logical,\n\t\t     int *naddrs, int *stripe_len)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tu64 *buf;\n\tu64 bytenr;\n\tu64 data_stripe_length;\n\tu64 io_stripe_size;\n\tint i, nr = 0;\n\tint ret = 0;\n\n\tem = btrfs_get_chunk_map(fs_info, chunk_start, 1);\n\tif (IS_ERR(em))\n\t\treturn -EIO;\n\n\tmap = em->map_lookup;\n\tdata_stripe_length = em->orig_block_len;\n\tio_stripe_size = map->stripe_len;\n\tchunk_start = em->start;\n\n\t/* For RAID5/6 adjust to a full IO stripe length */\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK)\n\t\tio_stripe_size = map->stripe_len * nr_data_stripes(map);\n\n\tbuf = kcalloc(map->num_stripes, sizeof(u64), GFP_NOFS);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < map->num_stripes; i++) {\n\t\tbool already_inserted = false;\n\t\tu64 stripe_nr;\n\t\tu64 offset;\n\t\tint j;\n\n\t\tif (!in_range(physical, map->stripes[i].physical,\n\t\t\t      data_stripe_length))\n\t\t\tcontinue;\n\n\t\tif (bdev && map->stripes[i].dev->bdev != bdev)\n\t\t\tcontinue;\n\n\t\tstripe_nr = physical - map->stripes[i].physical;\n\t\tstripe_nr = div64_u64_rem(stripe_nr, map->stripe_len, &offset);\n\n\t\tif (map->type & BTRFS_BLOCK_GROUP_RAID10) {\n\t\t\tstripe_nr = stripe_nr * map->num_stripes + i;\n\t\t\tstripe_nr = div_u64(stripe_nr, map->sub_stripes);\n\t\t} else if (map->type & BTRFS_BLOCK_GROUP_RAID0) {\n\t\t\tstripe_nr = stripe_nr * map->num_stripes + i;\n\t\t}\n\t\t/*\n\t\t * The remaining case would be for RAID56, multiply by\n\t\t * nr_data_stripes().  Alternatively, just use rmap_len below\n\t\t * instead of map->stripe_len\n\t\t */\n\n\t\tbytenr = chunk_start + stripe_nr * io_stripe_size + offset;\n\n\t\t/* Ensure we don't add duplicate addresses */\n\t\tfor (j = 0; j < nr; j++) {\n\t\t\tif (buf[j] == bytenr) {\n\t\t\t\talready_inserted = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!already_inserted)\n\t\t\tbuf[nr++] = bytenr;\n\t}\n\n\t*logical = buf;\n\t*naddrs = nr;\n\t*stripe_len = io_stripe_size;\nout:\n\tfree_extent_map(em);\n\treturn ret;\n}\n\nstatic int exclude_super_stripes(struct btrfs_block_group *cache)\n{\n\tstruct btrfs_fs_info *fs_info = cache->fs_info;\n\tconst bool zoned = btrfs_is_zoned(fs_info);\n\tu64 bytenr;\n\tu64 *logical;\n\tint stripe_len;\n\tint i, nr, ret;\n\n\tif (cache->start < BTRFS_SUPER_INFO_OFFSET) {\n\t\tstripe_len = BTRFS_SUPER_INFO_OFFSET - cache->start;\n\t\tcache->bytes_super += stripe_len;\n\t\tret = btrfs_add_excluded_extent(fs_info, cache->start,\n\t\t\t\t\t\tstripe_len);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < BTRFS_SUPER_MIRROR_MAX; i++) {\n\t\tbytenr = btrfs_sb_offset(i);\n\t\tret = btrfs_rmap_block(fs_info, cache->start, NULL,\n\t\t\t\t       bytenr, &logical, &nr, &stripe_len);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/* Shouldn't have super stripes in sequential zones */\n\t\tif (zoned && nr) {\n\t\t\tbtrfs_err(fs_info,\n\t\t\t\"zoned: block group %llu must not contain super block\",\n\t\t\t\t  cache->start);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\twhile (nr--) {\n\t\t\tu64 len = min_t(u64, stripe_len,\n\t\t\t\tcache->start + cache->length - logical[nr]);\n\n\t\t\tcache->bytes_super += len;\n\t\t\tret = btrfs_add_excluded_extent(fs_info, logical[nr],\n\t\t\t\t\t\t\tlen);\n\t\t\tif (ret) {\n\t\t\t\tkfree(logical);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tkfree(logical);\n\t}\n\treturn 0;\n}\n\nstatic void link_block_group(struct btrfs_block_group *cache)\n{\n\tstruct btrfs_space_info *space_info = cache->space_info;\n\tint index = btrfs_bg_flags_to_raid_index(cache->flags);\n\n\tdown_write(&space_info->groups_sem);\n\tlist_add_tail(&cache->list, &space_info->block_groups[index]);\n\tup_write(&space_info->groups_sem);\n}\n\nstatic struct btrfs_block_group *btrfs_create_block_group_cache(\n\t\tstruct btrfs_fs_info *fs_info, u64 start)\n{\n\tstruct btrfs_block_group *cache;\n\n\tcache = kzalloc(sizeof(*cache), GFP_NOFS);\n\tif (!cache)\n\t\treturn NULL;\n\n\tcache->free_space_ctl = kzalloc(sizeof(*cache->free_space_ctl),\n\t\t\t\t\tGFP_NOFS);\n\tif (!cache->free_space_ctl) {\n\t\tkfree(cache);\n\t\treturn NULL;\n\t}\n\n\tcache->start = start;\n\n\tcache->fs_info = fs_info;\n\tcache->full_stripe_len = btrfs_full_stripe_len(fs_info, start);\n\n\tcache->discard_index = BTRFS_DISCARD_INDEX_UNUSED;\n\n\trefcount_set(&cache->refs, 1);\n\tspin_lock_init(&cache->lock);\n\tinit_rwsem(&cache->data_rwsem);\n\tINIT_LIST_HEAD(&cache->list);\n\tINIT_LIST_HEAD(&cache->cluster_list);\n\tINIT_LIST_HEAD(&cache->bg_list);\n\tINIT_LIST_HEAD(&cache->ro_list);\n\tINIT_LIST_HEAD(&cache->discard_list);\n\tINIT_LIST_HEAD(&cache->dirty_list);\n\tINIT_LIST_HEAD(&cache->io_list);\n\tbtrfs_init_free_space_ctl(cache, cache->free_space_ctl);\n\tatomic_set(&cache->frozen, 0);\n\tmutex_init(&cache->free_space_lock);\n\tbtrfs_init_full_stripe_locks_tree(&cache->full_stripe_locks_root);\n\n\treturn cache;\n}\n\n/*\n * Iterate all chunks and verify that each of them has the corresponding block\n * group\n */\nstatic int check_chunk_block_group_mappings(struct btrfs_fs_info *fs_info)\n{\n\tstruct extent_map_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct btrfs_block_group *bg;\n\tu64 start = 0;\n\tint ret = 0;\n\n\twhile (1) {\n\t\tread_lock(&map_tree->lock);\n\t\t/*\n\t\t * lookup_extent_mapping will return the first extent map\n\t\t * intersecting the range, so setting @len to 1 is enough to\n\t\t * get the first chunk.\n\t\t */\n\t\tem = lookup_extent_mapping(map_tree, start, 1);\n\t\tread_unlock(&map_tree->lock);\n\t\tif (!em)\n\t\t\tbreak;\n\n\t\tbg = btrfs_lookup_block_group(fs_info, em->start);\n\t\tif (!bg) {\n\t\t\tbtrfs_err(fs_info,\n\t\"chunk start=%llu len=%llu doesn't have corresponding block group\",\n\t\t\t\t     em->start, em->len);\n\t\t\tret = -EUCLEAN;\n\t\t\tfree_extent_map(em);\n\t\t\tbreak;\n\t\t}\n\t\tif (bg->start != em->start || bg->length != em->len ||\n\t\t    (bg->flags & BTRFS_BLOCK_GROUP_TYPE_MASK) !=\n\t\t    (em->map_lookup->type & BTRFS_BLOCK_GROUP_TYPE_MASK)) {\n\t\t\tbtrfs_err(fs_info,\n\"chunk start=%llu len=%llu flags=0x%llx doesn't match block group start=%llu len=%llu flags=0x%llx\",\n\t\t\t\tem->start, em->len,\n\t\t\t\tem->map_lookup->type & BTRFS_BLOCK_GROUP_TYPE_MASK,\n\t\t\t\tbg->start, bg->length,\n\t\t\t\tbg->flags & BTRFS_BLOCK_GROUP_TYPE_MASK);\n\t\t\tret = -EUCLEAN;\n\t\t\tfree_extent_map(em);\n\t\t\tbtrfs_put_block_group(bg);\n\t\t\tbreak;\n\t\t}\n\t\tstart = em->start + em->len;\n\t\tfree_extent_map(em);\n\t\tbtrfs_put_block_group(bg);\n\t}\n\treturn ret;\n}\n\nstatic int read_one_block_group(struct btrfs_fs_info *info,\n\t\t\t\tstruct btrfs_block_group_item *bgi,\n\t\t\t\tconst struct btrfs_key *key,\n\t\t\t\tint need_clear)\n{\n\tstruct btrfs_block_group *cache;\n\tstruct btrfs_space_info *space_info;\n\tconst bool mixed = btrfs_fs_incompat(info, MIXED_GROUPS);\n\tint ret;\n\n\tASSERT(key->type == BTRFS_BLOCK_GROUP_ITEM_KEY);\n\n\tcache = btrfs_create_block_group_cache(info, key->objectid);\n\tif (!cache)\n\t\treturn -ENOMEM;\n\n\tcache->length = key->offset;\n\tcache->used = btrfs_stack_block_group_used(bgi);\n\tcache->flags = btrfs_stack_block_group_flags(bgi);\n\n\tset_free_space_tree_thresholds(cache);\n\n\tif (need_clear) {\n\t\t/*\n\t\t * When we mount with old space cache, we need to\n\t\t * set BTRFS_DC_CLEAR and set dirty flag.\n\t\t *\n\t\t * a) Setting 'BTRFS_DC_CLEAR' makes sure that we\n\t\t *    truncate the old free space cache inode and\n\t\t *    setup a new one.\n\t\t * b) Setting 'dirty flag' makes sure that we flush\n\t\t *    the new space cache info onto disk.\n\t\t */\n\t\tif (btrfs_test_opt(info, SPACE_CACHE))\n\t\t\tcache->disk_cache_state = BTRFS_DC_CLEAR;\n\t}\n\tif (!mixed && ((cache->flags & BTRFS_BLOCK_GROUP_METADATA) &&\n\t    (cache->flags & BTRFS_BLOCK_GROUP_DATA))) {\n\t\t\tbtrfs_err(info,\n\"bg %llu is a mixed block group but filesystem hasn't enabled mixed block groups\",\n\t\t\t\t  cache->start);\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t}\n\n\tret = btrfs_load_block_group_zone_info(cache, false);\n\tif (ret) {\n\t\tbtrfs_err(info, \"zoned: failed to load zone info of bg %llu\",\n\t\t\t  cache->start);\n\t\tgoto error;\n\t}\n\n\t/*\n\t * We need to exclude the super stripes now so that the space info has\n\t * super bytes accounted for, otherwise we'll think we have more space\n\t * than we actually do.\n\t */\n\tret = exclude_super_stripes(cache);\n\tif (ret) {\n\t\t/* We may have excluded something, so call this just in case. */\n\t\tbtrfs_free_excluded_extents(cache);\n\t\tgoto error;\n\t}\n\n\t/*\n\t * For zoned filesystem, space after the allocation offset is the only\n\t * free space for a block group. So, we don't need any caching work.\n\t * btrfs_calc_zone_unusable() will set the amount of free space and\n\t * zone_unusable space.\n\t *\n\t * For regular filesystem, check for two cases, either we are full, and\n\t * therefore don't need to bother with the caching work since we won't\n\t * find any space, or we are empty, and we can just add all the space\n\t * in and be done with it.  This saves us _a_lot_ of time, particularly\n\t * in the full case.\n\t */\n\tif (btrfs_is_zoned(info)) {\n\t\tbtrfs_calc_zone_unusable(cache);\n\t} else if (cache->length == cache->used) {\n\t\tcache->last_byte_to_unpin = (u64)-1;\n\t\tcache->cached = BTRFS_CACHE_FINISHED;\n\t\tbtrfs_free_excluded_extents(cache);\n\t} else if (cache->used == 0) {\n\t\tcache->last_byte_to_unpin = (u64)-1;\n\t\tcache->cached = BTRFS_CACHE_FINISHED;\n\t\tadd_new_free_space(cache, cache->start,\n\t\t\t\t   cache->start + cache->length);\n\t\tbtrfs_free_excluded_extents(cache);\n\t}\n\n\tret = btrfs_add_block_group_cache(info, cache);\n\tif (ret) {\n\t\tbtrfs_remove_free_space_cache(cache);\n\t\tgoto error;\n\t}\n\ttrace_btrfs_add_block_group(info, cache, 0);\n\tbtrfs_update_space_info(info, cache->flags, cache->length,\n\t\t\t\tcache->used, cache->bytes_super,\n\t\t\t\tcache->zone_unusable, &space_info);\n\n\tcache->space_info = space_info;\n\n\tlink_block_group(cache);\n\n\tset_avail_alloc_bits(info, cache->flags);\n\tif (btrfs_chunk_readonly(info, cache->start)) {\n\t\tinc_block_group_ro(cache, 1);\n\t} else if (cache->used == 0) {\n\t\tASSERT(list_empty(&cache->bg_list));\n\t\tif (btrfs_test_opt(info, DISCARD_ASYNC))\n\t\t\tbtrfs_discard_queue_work(&info->discard_ctl, cache);\n\t\telse\n\t\t\tbtrfs_mark_bg_unused(cache);\n\t}\n\treturn 0;\nerror:\n\tbtrfs_put_block_group(cache);\n\treturn ret;\n}\n\nstatic int fill_dummy_bgs(struct btrfs_fs_info *fs_info)\n{\n\tstruct extent_map_tree *em_tree = &fs_info->mapping_tree;\n\tstruct btrfs_space_info *space_info;\n\tstruct rb_node *node;\n\tint ret = 0;\n\n\tfor (node = rb_first_cached(&em_tree->map); node; node = rb_next(node)) {\n\t\tstruct extent_map *em;\n\t\tstruct map_lookup *map;\n\t\tstruct btrfs_block_group *bg;\n\n\t\tem = rb_entry(node, struct extent_map, rb_node);\n\t\tmap = em->map_lookup;\n\t\tbg = btrfs_create_block_group_cache(fs_info, em->start);\n\t\tif (!bg) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Fill dummy cache as FULL */\n\t\tbg->length = em->len;\n\t\tbg->flags = map->type;\n\t\tbg->last_byte_to_unpin = (u64)-1;\n\t\tbg->cached = BTRFS_CACHE_FINISHED;\n\t\tbg->used = em->len;\n\t\tbg->flags = map->type;\n\t\tret = btrfs_add_block_group_cache(fs_info, bg);\n\t\tif (ret) {\n\t\t\tbtrfs_remove_free_space_cache(bg);\n\t\t\tbtrfs_put_block_group(bg);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_update_space_info(fs_info, bg->flags, em->len, em->len,\n\t\t\t\t\t0, 0, &space_info);\n\t\tbg->space_info = space_info;\n\t\tlink_block_group(bg);\n\n\t\tset_avail_alloc_bits(fs_info, bg->flags);\n\t}\n\tif (!ret)\n\t\tbtrfs_init_global_block_rsv(fs_info);\n\treturn ret;\n}\n\nint btrfs_read_block_groups(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\tstruct btrfs_block_group *cache;\n\tstruct btrfs_space_info *space_info;\n\tstruct btrfs_key key;\n\tint need_clear = 0;\n\tu64 cache_gen;\n\n\tif (!info->extent_root)\n\t\treturn fill_dummy_bgs(info);\n\n\tkey.objectid = 0;\n\tkey.offset = 0;\n\tkey.type = BTRFS_BLOCK_GROUP_ITEM_KEY;\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tcache_gen = btrfs_super_cache_generation(info->super_copy);\n\tif (btrfs_test_opt(info, SPACE_CACHE) &&\n\t    btrfs_super_generation(info->super_copy) != cache_gen)\n\t\tneed_clear = 1;\n\tif (btrfs_test_opt(info, CLEAR_CACHE))\n\t\tneed_clear = 1;\n\n\twhile (1) {\n\t\tstruct btrfs_block_group_item bgi;\n\t\tstruct extent_buffer *leaf;\n\t\tint slot;\n\n\t\tret = find_first_block_group(info, path, &key);\n\t\tif (ret > 0)\n\t\t\tbreak;\n\t\tif (ret != 0)\n\t\t\tgoto error;\n\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tread_extent_buffer(leaf, &bgi, btrfs_item_ptr_offset(leaf, slot),\n\t\t\t\t   sizeof(bgi));\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tbtrfs_release_path(path);\n\t\tret = read_one_block_group(info, &bgi, &key, need_clear);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tkey.objectid += key.offset;\n\t\tkey.offset = 0;\n\t}\n\tbtrfs_release_path(path);\n\n\tlist_for_each_entry(space_info, &info->space_info, list) {\n\t\tint i;\n\n\t\tfor (i = 0; i < BTRFS_NR_RAID_TYPES; i++) {\n\t\t\tif (list_empty(&space_info->block_groups[i]))\n\t\t\t\tcontinue;\n\t\t\tcache = list_first_entry(&space_info->block_groups[i],\n\t\t\t\t\t\t struct btrfs_block_group,\n\t\t\t\t\t\t list);\n\t\t\tbtrfs_sysfs_add_block_group_type(cache);\n\t\t}\n\n\t\tif (!(btrfs_get_alloc_profile(info, space_info->flags) &\n\t\t      (BTRFS_BLOCK_GROUP_RAID10 |\n\t\t       BTRFS_BLOCK_GROUP_RAID1_MASK |\n\t\t       BTRFS_BLOCK_GROUP_RAID56_MASK |\n\t\t       BTRFS_BLOCK_GROUP_DUP)))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Avoid allocating from un-mirrored block group if there are\n\t\t * mirrored block groups.\n\t\t */\n\t\tlist_for_each_entry(cache,\n\t\t\t\t&space_info->block_groups[BTRFS_RAID_RAID0],\n\t\t\t\tlist)\n\t\t\tinc_block_group_ro(cache, 1);\n\t\tlist_for_each_entry(cache,\n\t\t\t\t&space_info->block_groups[BTRFS_RAID_SINGLE],\n\t\t\t\tlist)\n\t\t\tinc_block_group_ro(cache, 1);\n\t}\n\n\tbtrfs_init_global_block_rsv(info);\n\tret = check_chunk_block_group_mappings(info);\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nstatic int insert_block_group_item(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_block_group *block_group)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_block_group_item bgi;\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\n\tspin_lock(&block_group->lock);\n\tbtrfs_set_stack_block_group_used(&bgi, block_group->used);\n\tbtrfs_set_stack_block_group_chunk_objectid(&bgi,\n\t\t\t\tBTRFS_FIRST_CHUNK_TREE_OBJECTID);\n\tbtrfs_set_stack_block_group_flags(&bgi, block_group->flags);\n\tkey.objectid = block_group->start;\n\tkey.type = BTRFS_BLOCK_GROUP_ITEM_KEY;\n\tkey.offset = block_group->length;\n\tspin_unlock(&block_group->lock);\n\n\troot = fs_info->extent_root;\n\treturn btrfs_insert_item(trans, root, &key, &bgi, sizeof(bgi));\n}\n\nvoid btrfs_create_pending_block_groups(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_block_group *block_group;\n\tint ret = 0;\n\n\tif (!trans->can_flush_pending_bgs)\n\t\treturn;\n\n\twhile (!list_empty(&trans->new_bgs)) {\n\t\tint index;\n\n\t\tblock_group = list_first_entry(&trans->new_bgs,\n\t\t\t\t\t       struct btrfs_block_group,\n\t\t\t\t\t       bg_list);\n\t\tif (ret)\n\t\t\tgoto next;\n\n\t\tindex = btrfs_bg_flags_to_raid_index(block_group->flags);\n\n\t\tret = insert_block_group_item(trans, block_group);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\tret = btrfs_finish_chunk_alloc(trans, block_group->start,\n\t\t\t\t\tblock_group->length);\n\t\tif (ret)\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\tadd_block_group_free_space(trans, block_group);\n\n\t\t/*\n\t\t * If we restriped during balance, we may have added a new raid\n\t\t * type, so now add the sysfs entries when it is safe to do so.\n\t\t * We don't have to worry about locking here as it's handled in\n\t\t * btrfs_sysfs_add_block_group_type.\n\t\t */\n\t\tif (block_group->space_info->block_group_kobjs[index] == NULL)\n\t\t\tbtrfs_sysfs_add_block_group_type(block_group);\n\n\t\t/* Already aborted the transaction if it failed. */\nnext:\n\t\tbtrfs_delayed_refs_rsv_release(fs_info, 1);\n\t\tlist_del_init(&block_group->bg_list);\n\t}\n\tbtrfs_trans_release_chunk_metadata(trans);\n}\n\nint btrfs_make_block_group(struct btrfs_trans_handle *trans, u64 bytes_used,\n\t\t\t   u64 type, u64 chunk_offset, u64 size)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_block_group *cache;\n\tint ret;\n\n\tbtrfs_set_log_full_commit(trans);\n\n\tcache = btrfs_create_block_group_cache(fs_info, chunk_offset);\n\tif (!cache)\n\t\treturn -ENOMEM;\n\n\tcache->length = size;\n\tset_free_space_tree_thresholds(cache);\n\tcache->used = bytes_used;\n\tcache->flags = type;\n\tcache->last_byte_to_unpin = (u64)-1;\n\tcache->cached = BTRFS_CACHE_FINISHED;\n\tif (btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE))\n\t\tcache->needs_free_space = 1;\n\n\tret = btrfs_load_block_group_zone_info(cache, true);\n\tif (ret) {\n\t\tbtrfs_put_block_group(cache);\n\t\treturn ret;\n\t}\n\n\tret = exclude_super_stripes(cache);\n\tif (ret) {\n\t\t/* We may have excluded something, so call this just in case */\n\t\tbtrfs_free_excluded_extents(cache);\n\t\tbtrfs_put_block_group(cache);\n\t\treturn ret;\n\t}\n\n\tadd_new_free_space(cache, chunk_offset, chunk_offset + size);\n\n\tbtrfs_free_excluded_extents(cache);\n\n#ifdef CONFIG_BTRFS_DEBUG\n\tif (btrfs_should_fragment_free_space(cache)) {\n\t\tu64 new_bytes_used = size - bytes_used;\n\n\t\tbytes_used += new_bytes_used >> 1;\n\t\tfragment_free_space(cache);\n\t}\n#endif\n\t/*\n\t * Ensure the corresponding space_info object is created and\n\t * assigned to our block group. We want our bg to be added to the rbtree\n\t * with its ->space_info set.\n\t */\n\tcache->space_info = btrfs_find_space_info(fs_info, cache->flags);\n\tASSERT(cache->space_info);\n\n\tret = btrfs_add_block_group_cache(fs_info, cache);\n\tif (ret) {\n\t\tbtrfs_remove_free_space_cache(cache);\n\t\tbtrfs_put_block_group(cache);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Now that our block group has its ->space_info set and is inserted in\n\t * the rbtree, update the space info's counters.\n\t */\n\ttrace_btrfs_add_block_group(fs_info, cache, 1);\n\tbtrfs_update_space_info(fs_info, cache->flags, size, bytes_used,\n\t\t\t\tcache->bytes_super, 0, &cache->space_info);\n\tbtrfs_update_global_block_rsv(fs_info);\n\n\tlink_block_group(cache);\n\n\tlist_add_tail(&cache->bg_list, &trans->new_bgs);\n\ttrans->delayed_ref_updates++;\n\tbtrfs_update_delayed_refs_rsv(trans);\n\n\tset_avail_alloc_bits(fs_info, type);\n\treturn 0;\n}\n\n/*\n * Mark one block group RO, can be called several times for the same block\n * group.\n *\n * @cache:\t\tthe destination block group\n * @do_chunk_alloc:\twhether need to do chunk pre-allocation, this is to\n * \t\t\tensure we still have some free space after marking this\n * \t\t\tblock group RO.\n */\nint btrfs_inc_block_group_ro(struct btrfs_block_group *cache,\n\t\t\t     bool do_chunk_alloc)\n{\n\tstruct btrfs_fs_info *fs_info = cache->fs_info;\n\tstruct btrfs_trans_handle *trans;\n\tu64 alloc_flags;\n\tint ret;\n\tbool dirty_bg_running;\n\n\tdo {\n\t\ttrans = btrfs_join_transaction(fs_info->extent_root);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\n\t\tdirty_bg_running = false;\n\n\t\t/*\n\t\t * We're not allowed to set block groups readonly after the dirty\n\t\t * block group cache has started writing.  If it already started,\n\t\t * back off and let this transaction commit.\n\t\t */\n\t\tmutex_lock(&fs_info->ro_block_group_mutex);\n\t\tif (test_bit(BTRFS_TRANS_DIRTY_BG_RUN, &trans->transaction->flags)) {\n\t\t\tu64 transid = trans->transid;\n\n\t\t\tmutex_unlock(&fs_info->ro_block_group_mutex);\n\t\t\tbtrfs_end_transaction(trans);\n\n\t\t\tret = btrfs_wait_for_commit(fs_info, transid);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tdirty_bg_running = true;\n\t\t}\n\t} while (dirty_bg_running);\n\n\tif (do_chunk_alloc) {\n\t\t/*\n\t\t * If we are changing raid levels, try to allocate a\n\t\t * corresponding block group with the new raid level.\n\t\t */\n\t\talloc_flags = btrfs_get_alloc_profile(fs_info, cache->flags);\n\t\tif (alloc_flags != cache->flags) {\n\t\t\tret = btrfs_chunk_alloc(trans, alloc_flags,\n\t\t\t\t\t\tCHUNK_ALLOC_FORCE);\n\t\t\t/*\n\t\t\t * ENOSPC is allowed here, we may have enough space\n\t\t\t * already allocated at the new raid level to carry on\n\t\t\t */\n\t\t\tif (ret == -ENOSPC)\n\t\t\t\tret = 0;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = inc_block_group_ro(cache, 0);\n\tif (!do_chunk_alloc || ret == -ETXTBSY)\n\t\tgoto unlock_out;\n\tif (!ret)\n\t\tgoto out;\n\talloc_flags = btrfs_get_alloc_profile(fs_info, cache->space_info->flags);\n\tret = btrfs_chunk_alloc(trans, alloc_flags, CHUNK_ALLOC_FORCE);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = inc_block_group_ro(cache, 0);\n\tif (ret == -ETXTBSY)\n\t\tgoto unlock_out;\nout:\n\tif (cache->flags & BTRFS_BLOCK_GROUP_SYSTEM) {\n\t\talloc_flags = btrfs_get_alloc_profile(fs_info, cache->flags);\n\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\tcheck_system_chunk(trans, alloc_flags);\n\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t}\nunlock_out:\n\tmutex_unlock(&fs_info->ro_block_group_mutex);\n\n\tbtrfs_end_transaction(trans);\n\treturn ret;\n}\n\nvoid btrfs_dec_block_group_ro(struct btrfs_block_group *cache)\n{\n\tstruct btrfs_space_info *sinfo = cache->space_info;\n\tu64 num_bytes;\n\n\tBUG_ON(!cache->ro);\n\n\tspin_lock(&sinfo->lock);\n\tspin_lock(&cache->lock);\n\tif (!--cache->ro) {\n\t\tif (btrfs_is_zoned(cache->fs_info)) {\n\t\t\t/* Migrate zone_unusable bytes back */\n\t\t\tcache->zone_unusable = cache->alloc_offset - cache->used;\n\t\t\tsinfo->bytes_zone_unusable += cache->zone_unusable;\n\t\t\tsinfo->bytes_readonly -= cache->zone_unusable;\n\t\t}\n\t\tnum_bytes = cache->length - cache->reserved -\n\t\t\t    cache->pinned - cache->bytes_super -\n\t\t\t    cache->zone_unusable - cache->used;\n\t\tsinfo->bytes_readonly -= num_bytes;\n\t\tlist_del_init(&cache->ro_list);\n\t}\n\tspin_unlock(&cache->lock);\n\tspin_unlock(&sinfo->lock);\n}\n\nstatic int update_block_group_item(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_path *path,\n\t\t\t\t   struct btrfs_block_group *cache)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tint ret;\n\tstruct btrfs_root *root = fs_info->extent_root;\n\tunsigned long bi;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_block_group_item bgi;\n\tstruct btrfs_key key;\n\n\tkey.objectid = cache->start;\n\tkey.type = BTRFS_BLOCK_GROUP_ITEM_KEY;\n\tkey.offset = cache->length;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tleaf = path->nodes[0];\n\tbi = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\tbtrfs_set_stack_block_group_used(&bgi, cache->used);\n\tbtrfs_set_stack_block_group_chunk_objectid(&bgi,\n\t\t\tBTRFS_FIRST_CHUNK_TREE_OBJECTID);\n\tbtrfs_set_stack_block_group_flags(&bgi, cache->flags);\n\twrite_extent_buffer(leaf, &bgi, bi, sizeof(bgi));\n\tbtrfs_mark_buffer_dirty(leaf);\nfail:\n\tbtrfs_release_path(path);\n\treturn ret;\n\n}\n\nstatic int cache_save_setup(struct btrfs_block_group *block_group,\n\t\t\t    struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_path *path)\n{\n\tstruct btrfs_fs_info *fs_info = block_group->fs_info;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct inode *inode = NULL;\n\tstruct extent_changeset *data_reserved = NULL;\n\tu64 alloc_hint = 0;\n\tint dcs = BTRFS_DC_ERROR;\n\tu64 cache_size = 0;\n\tint retries = 0;\n\tint ret = 0;\n\n\tif (!btrfs_test_opt(fs_info, SPACE_CACHE))\n\t\treturn 0;\n\n\t/*\n\t * If this block group is smaller than 100 megs don't bother caching the\n\t * block group.\n\t */\n\tif (block_group->length < (100 * SZ_1M)) {\n\t\tspin_lock(&block_group->lock);\n\t\tblock_group->disk_cache_state = BTRFS_DC_WRITTEN;\n\t\tspin_unlock(&block_group->lock);\n\t\treturn 0;\n\t}\n\n\tif (TRANS_ABORTED(trans))\n\t\treturn 0;\nagain:\n\tinode = lookup_free_space_inode(block_group, path);\n\tif (IS_ERR(inode) && PTR_ERR(inode) != -ENOENT) {\n\t\tret = PTR_ERR(inode);\n\t\tbtrfs_release_path(path);\n\t\tgoto out;\n\t}\n\n\tif (IS_ERR(inode)) {\n\t\tBUG_ON(retries);\n\t\tretries++;\n\n\t\tif (block_group->ro)\n\t\t\tgoto out_free;\n\n\t\tret = create_free_space_inode(trans, block_group, path);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t\tgoto again;\n\t}\n\n\t/*\n\t * We want to set the generation to 0, that way if anything goes wrong\n\t * from here on out we know not to trust this cache when we load up next\n\t * time.\n\t */\n\tBTRFS_I(inode)->generation = 0;\n\tret = btrfs_update_inode(trans, root, BTRFS_I(inode));\n\tif (ret) {\n\t\t/*\n\t\t * So theoretically we could recover from this, simply set the\n\t\t * super cache generation to 0 so we know to invalidate the\n\t\t * cache, but then we'd have to keep track of the block groups\n\t\t * that fail this way so we know we _have_ to reset this cache\n\t\t * before the next commit or risk reading stale cache.  So to\n\t\t * limit our exposure to horrible edge cases lets just abort the\n\t\t * transaction, this only happens in really bad situations\n\t\t * anyway.\n\t\t */\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto out_put;\n\t}\n\tWARN_ON(ret);\n\n\t/* We've already setup this transaction, go ahead and exit */\n\tif (block_group->cache_generation == trans->transid &&\n\t    i_size_read(inode)) {\n\t\tdcs = BTRFS_DC_SETUP;\n\t\tgoto out_put;\n\t}\n\n\tif (i_size_read(inode) > 0) {\n\t\tret = btrfs_check_trunc_cache_free_space(fs_info,\n\t\t\t\t\t&fs_info->global_block_rsv);\n\t\tif (ret)\n\t\t\tgoto out_put;\n\n\t\tret = btrfs_truncate_free_space_cache(trans, NULL, inode);\n\t\tif (ret)\n\t\t\tgoto out_put;\n\t}\n\n\tspin_lock(&block_group->lock);\n\tif (block_group->cached != BTRFS_CACHE_FINISHED ||\n\t    !btrfs_test_opt(fs_info, SPACE_CACHE)) {\n\t\t/*\n\t\t * don't bother trying to write stuff out _if_\n\t\t * a) we're not cached,\n\t\t * b) we're with nospace_cache mount option,\n\t\t * c) we're with v2 space_cache (FREE_SPACE_TREE).\n\t\t */\n\t\tdcs = BTRFS_DC_WRITTEN;\n\t\tspin_unlock(&block_group->lock);\n\t\tgoto out_put;\n\t}\n\tspin_unlock(&block_group->lock);\n\n\t/*\n\t * We hit an ENOSPC when setting up the cache in this transaction, just\n\t * skip doing the setup, we've already cleared the cache so we're safe.\n\t */\n\tif (test_bit(BTRFS_TRANS_CACHE_ENOSPC, &trans->transaction->flags)) {\n\t\tret = -ENOSPC;\n\t\tgoto out_put;\n\t}\n\n\t/*\n\t * Try to preallocate enough space based on how big the block group is.\n\t * Keep in mind this has to include any pinned space which could end up\n\t * taking up quite a bit since it's not folded into the other space\n\t * cache.\n\t */\n\tcache_size = div_u64(block_group->length, SZ_256M);\n\tif (!cache_size)\n\t\tcache_size = 1;\n\n\tcache_size *= 16;\n\tcache_size *= fs_info->sectorsize;\n\n\tret = btrfs_check_data_free_space(BTRFS_I(inode), &data_reserved, 0,\n\t\t\t\t\t  cache_size);\n\tif (ret)\n\t\tgoto out_put;\n\n\tret = btrfs_prealloc_file_range_trans(inode, trans, 0, 0, cache_size,\n\t\t\t\t\t      cache_size, cache_size,\n\t\t\t\t\t      &alloc_hint);\n\t/*\n\t * Our cache requires contiguous chunks so that we don't modify a bunch\n\t * of metadata or split extents when writing the cache out, which means\n\t * we can enospc if we are heavily fragmented in addition to just normal\n\t * out of space conditions.  So if we hit this just skip setting up any\n\t * other block groups for this transaction, maybe we'll unpin enough\n\t * space the next time around.\n\t */\n\tif (!ret)\n\t\tdcs = BTRFS_DC_SETUP;\n\telse if (ret == -ENOSPC)\n\t\tset_bit(BTRFS_TRANS_CACHE_ENOSPC, &trans->transaction->flags);\n\nout_put:\n\tiput(inode);\nout_free:\n\tbtrfs_release_path(path);\nout:\n\tspin_lock(&block_group->lock);\n\tif (!ret && dcs == BTRFS_DC_SETUP)\n\t\tblock_group->cache_generation = trans->transid;\n\tblock_group->disk_cache_state = dcs;\n\tspin_unlock(&block_group->lock);\n\n\textent_changeset_free(data_reserved);\n\treturn ret;\n}\n\nint btrfs_setup_space_cache(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_block_group *cache, *tmp;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_path *path;\n\n\tif (list_empty(&cur_trans->dirty_bgs) ||\n\t    !btrfs_test_opt(fs_info, SPACE_CACHE))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t/* Could add new block groups, use _safe just in case */\n\tlist_for_each_entry_safe(cache, tmp, &cur_trans->dirty_bgs,\n\t\t\t\t dirty_list) {\n\t\tif (cache->disk_cache_state == BTRFS_DC_CLEAR)\n\t\t\tcache_save_setup(cache, trans, path);\n\t}\n\n\tbtrfs_free_path(path);\n\treturn 0;\n}\n\n/*\n * Transaction commit does final block group cache writeback during a critical\n * section where nothing is allowed to change the FS.  This is required in\n * order for the cache to actually match the block group, but can introduce a\n * lot of latency into the commit.\n *\n * So, btrfs_start_dirty_block_groups is here to kick off block group cache IO.\n * There's a chance we'll have to redo some of it if the block group changes\n * again during the commit, but it greatly reduces the commit latency by\n * getting rid of the easy block groups while we're still allowing others to\n * join the commit.\n */\nint btrfs_start_dirty_block_groups(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_block_group *cache;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tint ret = 0;\n\tint should_put;\n\tstruct btrfs_path *path = NULL;\n\tLIST_HEAD(dirty);\n\tstruct list_head *io = &cur_trans->io_bgs;\n\tint num_started = 0;\n\tint loops = 0;\n\n\tspin_lock(&cur_trans->dirty_bgs_lock);\n\tif (list_empty(&cur_trans->dirty_bgs)) {\n\t\tspin_unlock(&cur_trans->dirty_bgs_lock);\n\t\treturn 0;\n\t}\n\tlist_splice_init(&cur_trans->dirty_bgs, &dirty);\n\tspin_unlock(&cur_trans->dirty_bgs_lock);\n\nagain:\n\t/* Make sure all the block groups on our dirty list actually exist */\n\tbtrfs_create_pending_block_groups(trans);\n\n\tif (!path) {\n\t\tpath = btrfs_alloc_path();\n\t\tif (!path) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * cache_write_mutex is here only to save us from balance or automatic\n\t * removal of empty block groups deleting this block group while we are\n\t * writing out the cache\n\t */\n\tmutex_lock(&trans->transaction->cache_write_mutex);\n\twhile (!list_empty(&dirty)) {\n\t\tbool drop_reserve = true;\n\n\t\tcache = list_first_entry(&dirty, struct btrfs_block_group,\n\t\t\t\t\t dirty_list);\n\t\t/*\n\t\t * This can happen if something re-dirties a block group that\n\t\t * is already under IO.  Just wait for it to finish and then do\n\t\t * it all again\n\t\t */\n\t\tif (!list_empty(&cache->io_list)) {\n\t\t\tlist_del_init(&cache->io_list);\n\t\t\tbtrfs_wait_cache_io(trans, cache, path);\n\t\t\tbtrfs_put_block_group(cache);\n\t\t}\n\n\n\t\t/*\n\t\t * btrfs_wait_cache_io uses the cache->dirty_list to decide if\n\t\t * it should update the cache_state.  Don't delete until after\n\t\t * we wait.\n\t\t *\n\t\t * Since we're not running in the commit critical section\n\t\t * we need the dirty_bgs_lock to protect from update_block_group\n\t\t */\n\t\tspin_lock(&cur_trans->dirty_bgs_lock);\n\t\tlist_del_init(&cache->dirty_list);\n\t\tspin_unlock(&cur_trans->dirty_bgs_lock);\n\n\t\tshould_put = 1;\n\n\t\tcache_save_setup(cache, trans, path);\n\n\t\tif (cache->disk_cache_state == BTRFS_DC_SETUP) {\n\t\t\tcache->io_ctl.inode = NULL;\n\t\t\tret = btrfs_write_out_cache(trans, cache, path);\n\t\t\tif (ret == 0 && cache->io_ctl.inode) {\n\t\t\t\tnum_started++;\n\t\t\t\tshould_put = 0;\n\n\t\t\t\t/*\n\t\t\t\t * The cache_write_mutex is protecting the\n\t\t\t\t * io_list, also refer to the definition of\n\t\t\t\t * btrfs_transaction::io_bgs for more details\n\t\t\t\t */\n\t\t\t\tlist_add_tail(&cache->io_list, io);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * If we failed to write the cache, the\n\t\t\t\t * generation will be bad and life goes on\n\t\t\t\t */\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t}\n\t\tif (!ret) {\n\t\t\tret = update_block_group_item(trans, path, cache);\n\t\t\t/*\n\t\t\t * Our block group might still be attached to the list\n\t\t\t * of new block groups in the transaction handle of some\n\t\t\t * other task (struct btrfs_trans_handle->new_bgs). This\n\t\t\t * means its block group item isn't yet in the extent\n\t\t\t * tree. If this happens ignore the error, as we will\n\t\t\t * try again later in the critical section of the\n\t\t\t * transaction commit.\n\t\t\t */\n\t\t\tif (ret == -ENOENT) {\n\t\t\t\tret = 0;\n\t\t\t\tspin_lock(&cur_trans->dirty_bgs_lock);\n\t\t\t\tif (list_empty(&cache->dirty_list)) {\n\t\t\t\t\tlist_add_tail(&cache->dirty_list,\n\t\t\t\t\t\t      &cur_trans->dirty_bgs);\n\t\t\t\t\tbtrfs_get_block_group(cache);\n\t\t\t\t\tdrop_reserve = false;\n\t\t\t\t}\n\t\t\t\tspin_unlock(&cur_trans->dirty_bgs_lock);\n\t\t\t} else if (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\t}\n\t\t}\n\n\t\t/* If it's not on the io list, we need to put the block group */\n\t\tif (should_put)\n\t\t\tbtrfs_put_block_group(cache);\n\t\tif (drop_reserve)\n\t\t\tbtrfs_delayed_refs_rsv_release(fs_info, 1);\n\t\t/*\n\t\t * Avoid blocking other tasks for too long. It might even save\n\t\t * us from writing caches for block groups that are going to be\n\t\t * removed.\n\t\t */\n\t\tmutex_unlock(&trans->transaction->cache_write_mutex);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tmutex_lock(&trans->transaction->cache_write_mutex);\n\t}\n\tmutex_unlock(&trans->transaction->cache_write_mutex);\n\n\t/*\n\t * Go through delayed refs for all the stuff we've just kicked off\n\t * and then loop back (just once)\n\t */\n\tif (!ret)\n\t\tret = btrfs_run_delayed_refs(trans, 0);\n\tif (!ret && loops == 0) {\n\t\tloops++;\n\t\tspin_lock(&cur_trans->dirty_bgs_lock);\n\t\tlist_splice_init(&cur_trans->dirty_bgs, &dirty);\n\t\t/*\n\t\t * dirty_bgs_lock protects us from concurrent block group\n\t\t * deletes too (not just cache_write_mutex).\n\t\t */\n\t\tif (!list_empty(&dirty)) {\n\t\t\tspin_unlock(&cur_trans->dirty_bgs_lock);\n\t\t\tgoto again;\n\t\t}\n\t\tspin_unlock(&cur_trans->dirty_bgs_lock);\n\t}\nout:\n\tif (ret < 0) {\n\t\tspin_lock(&cur_trans->dirty_bgs_lock);\n\t\tlist_splice_init(&dirty, &cur_trans->dirty_bgs);\n\t\tspin_unlock(&cur_trans->dirty_bgs_lock);\n\t\tbtrfs_cleanup_dirty_bgs(cur_trans, fs_info);\n\t}\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nint btrfs_write_dirty_block_groups(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_block_group *cache;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tint ret = 0;\n\tint should_put;\n\tstruct btrfs_path *path;\n\tstruct list_head *io = &cur_trans->io_bgs;\n\tint num_started = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Even though we are in the critical section of the transaction commit,\n\t * we can still have concurrent tasks adding elements to this\n\t * transaction's list of dirty block groups. These tasks correspond to\n\t * endio free space workers started when writeback finishes for a\n\t * space cache, which run inode.c:btrfs_finish_ordered_io(), and can\n\t * allocate new block groups as a result of COWing nodes of the root\n\t * tree when updating the free space inode. The writeback for the space\n\t * caches is triggered by an earlier call to\n\t * btrfs_start_dirty_block_groups() and iterations of the following\n\t * loop.\n\t * Also we want to do the cache_save_setup first and then run the\n\t * delayed refs to make sure we have the best chance at doing this all\n\t * in one shot.\n\t */\n\tspin_lock(&cur_trans->dirty_bgs_lock);\n\twhile (!list_empty(&cur_trans->dirty_bgs)) {\n\t\tcache = list_first_entry(&cur_trans->dirty_bgs,\n\t\t\t\t\t struct btrfs_block_group,\n\t\t\t\t\t dirty_list);\n\n\t\t/*\n\t\t * This can happen if cache_save_setup re-dirties a block group\n\t\t * that is already under IO.  Just wait for it to finish and\n\t\t * then do it all again\n\t\t */\n\t\tif (!list_empty(&cache->io_list)) {\n\t\t\tspin_unlock(&cur_trans->dirty_bgs_lock);\n\t\t\tlist_del_init(&cache->io_list);\n\t\t\tbtrfs_wait_cache_io(trans, cache, path);\n\t\t\tbtrfs_put_block_group(cache);\n\t\t\tspin_lock(&cur_trans->dirty_bgs_lock);\n\t\t}\n\n\t\t/*\n\t\t * Don't remove from the dirty list until after we've waited on\n\t\t * any pending IO\n\t\t */\n\t\tlist_del_init(&cache->dirty_list);\n\t\tspin_unlock(&cur_trans->dirty_bgs_lock);\n\t\tshould_put = 1;\n\n\t\tcache_save_setup(cache, trans, path);\n\n\t\tif (!ret)\n\t\t\tret = btrfs_run_delayed_refs(trans,\n\t\t\t\t\t\t     (unsigned long) -1);\n\n\t\tif (!ret && cache->disk_cache_state == BTRFS_DC_SETUP) {\n\t\t\tcache->io_ctl.inode = NULL;\n\t\t\tret = btrfs_write_out_cache(trans, cache, path);\n\t\t\tif (ret == 0 && cache->io_ctl.inode) {\n\t\t\t\tnum_started++;\n\t\t\t\tshould_put = 0;\n\t\t\t\tlist_add_tail(&cache->io_list, io);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * If we failed to write the cache, the\n\t\t\t\t * generation will be bad and life goes on\n\t\t\t\t */\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t}\n\t\tif (!ret) {\n\t\t\tret = update_block_group_item(trans, path, cache);\n\t\t\t/*\n\t\t\t * One of the free space endio workers might have\n\t\t\t * created a new block group while updating a free space\n\t\t\t * cache's inode (at inode.c:btrfs_finish_ordered_io())\n\t\t\t * and hasn't released its transaction handle yet, in\n\t\t\t * which case the new block group is still attached to\n\t\t\t * its transaction handle and its creation has not\n\t\t\t * finished yet (no block group item in the extent tree\n\t\t\t * yet, etc). If this is the case, wait for all free\n\t\t\t * space endio workers to finish and retry. This is a\n\t\t\t * very rare case so no need for a more efficient and\n\t\t\t * complex approach.\n\t\t\t */\n\t\t\tif (ret == -ENOENT) {\n\t\t\t\twait_event(cur_trans->writer_wait,\n\t\t\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\t\t\t\tret = update_block_group_item(trans, path, cache);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t}\n\n\t\t/* If its not on the io list, we need to put the block group */\n\t\tif (should_put)\n\t\t\tbtrfs_put_block_group(cache);\n\t\tbtrfs_delayed_refs_rsv_release(fs_info, 1);\n\t\tspin_lock(&cur_trans->dirty_bgs_lock);\n\t}\n\tspin_unlock(&cur_trans->dirty_bgs_lock);\n\n\t/*\n\t * Refer to the definition of io_bgs member for details why it's safe\n\t * to use it without any locking\n\t */\n\twhile (!list_empty(io)) {\n\t\tcache = list_first_entry(io, struct btrfs_block_group,\n\t\t\t\t\t io_list);\n\t\tlist_del_init(&cache->io_list);\n\t\tbtrfs_wait_cache_io(trans, cache, path);\n\t\tbtrfs_put_block_group(cache);\n\t}\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n\nint btrfs_update_block_group(struct btrfs_trans_handle *trans,\n\t\t\t     u64 bytenr, u64 num_bytes, int alloc)\n{\n\tstruct btrfs_fs_info *info = trans->fs_info;\n\tstruct btrfs_block_group *cache = NULL;\n\tu64 total = num_bytes;\n\tu64 old_val;\n\tu64 byte_in_group;\n\tint factor;\n\tint ret = 0;\n\n\t/* Block accounting for super block */\n\tspin_lock(&info->delalloc_root_lock);\n\told_val = btrfs_super_bytes_used(info->super_copy);\n\tif (alloc)\n\t\told_val += num_bytes;\n\telse\n\t\told_val -= num_bytes;\n\tbtrfs_set_super_bytes_used(info->super_copy, old_val);\n\tspin_unlock(&info->delalloc_root_lock);\n\n\twhile (total) {\n\t\tcache = btrfs_lookup_block_group(info, bytenr);\n\t\tif (!cache) {\n\t\t\tret = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\t\tfactor = btrfs_bg_type_to_factor(cache->flags);\n\n\t\t/*\n\t\t * If this block group has free space cache written out, we\n\t\t * need to make sure to load it if we are removing space.  This\n\t\t * is because we need the unpinning stage to actually add the\n\t\t * space back to the block group, otherwise we will leak space.\n\t\t */\n\t\tif (!alloc && !btrfs_block_group_done(cache))\n\t\t\tbtrfs_cache_block_group(cache, 1);\n\n\t\tbyte_in_group = bytenr - cache->start;\n\t\tWARN_ON(byte_in_group > cache->length);\n\n\t\tspin_lock(&cache->space_info->lock);\n\t\tspin_lock(&cache->lock);\n\n\t\tif (btrfs_test_opt(info, SPACE_CACHE) &&\n\t\t    cache->disk_cache_state < BTRFS_DC_CLEAR)\n\t\t\tcache->disk_cache_state = BTRFS_DC_CLEAR;\n\n\t\told_val = cache->used;\n\t\tnum_bytes = min(total, cache->length - byte_in_group);\n\t\tif (alloc) {\n\t\t\told_val += num_bytes;\n\t\t\tcache->used = old_val;\n\t\t\tcache->reserved -= num_bytes;\n\t\t\tcache->space_info->bytes_reserved -= num_bytes;\n\t\t\tcache->space_info->bytes_used += num_bytes;\n\t\t\tcache->space_info->disk_used += num_bytes * factor;\n\t\t\tspin_unlock(&cache->lock);\n\t\t\tspin_unlock(&cache->space_info->lock);\n\t\t} else {\n\t\t\told_val -= num_bytes;\n\t\t\tcache->used = old_val;\n\t\t\tcache->pinned += num_bytes;\n\t\t\tbtrfs_space_info_update_bytes_pinned(info,\n\t\t\t\t\tcache->space_info, num_bytes);\n\t\t\tcache->space_info->bytes_used -= num_bytes;\n\t\t\tcache->space_info->disk_used -= num_bytes * factor;\n\t\t\tspin_unlock(&cache->lock);\n\t\t\tspin_unlock(&cache->space_info->lock);\n\n\t\t\tset_extent_dirty(&trans->transaction->pinned_extents,\n\t\t\t\t\t bytenr, bytenr + num_bytes - 1,\n\t\t\t\t\t GFP_NOFS | __GFP_NOFAIL);\n\t\t}\n\n\t\tspin_lock(&trans->transaction->dirty_bgs_lock);\n\t\tif (list_empty(&cache->dirty_list)) {\n\t\t\tlist_add_tail(&cache->dirty_list,\n\t\t\t\t      &trans->transaction->dirty_bgs);\n\t\t\ttrans->delayed_ref_updates++;\n\t\t\tbtrfs_get_block_group(cache);\n\t\t}\n\t\tspin_unlock(&trans->transaction->dirty_bgs_lock);\n\n\t\t/*\n\t\t * No longer have used bytes in this block group, queue it for\n\t\t * deletion. We do this after adding the block group to the\n\t\t * dirty list to avoid races between cleaner kthread and space\n\t\t * cache writeout.\n\t\t */\n\t\tif (!alloc && old_val == 0) {\n\t\t\tif (!btrfs_test_opt(info, DISCARD_ASYNC))\n\t\t\t\tbtrfs_mark_bg_unused(cache);\n\t\t}\n\n\t\tbtrfs_put_block_group(cache);\n\t\ttotal -= num_bytes;\n\t\tbytenr += num_bytes;\n\t}\n\n\t/* Modified block groups are accounted for in the delayed_refs_rsv. */\n\tbtrfs_update_delayed_refs_rsv(trans);\n\treturn ret;\n}\n\n/**\n * btrfs_add_reserved_bytes - update the block_group and space info counters\n * @cache:\tThe cache we are manipulating\n * @ram_bytes:  The number of bytes of file content, and will be same to\n *              @num_bytes except for the compress path.\n * @num_bytes:\tThe number of bytes in question\n * @delalloc:   The blocks are allocated for the delalloc write\n *\n * This is called by the allocator when it reserves space. If this is a\n * reservation and the block group has become read only we cannot make the\n * reservation and return -EAGAIN, otherwise this function always succeeds.\n */\nint btrfs_add_reserved_bytes(struct btrfs_block_group *cache,\n\t\t\t     u64 ram_bytes, u64 num_bytes, int delalloc)\n{\n\tstruct btrfs_space_info *space_info = cache->space_info;\n\tint ret = 0;\n\n\tspin_lock(&space_info->lock);\n\tspin_lock(&cache->lock);\n\tif (cache->ro) {\n\t\tret = -EAGAIN;\n\t} else {\n\t\tcache->reserved += num_bytes;\n\t\tspace_info->bytes_reserved += num_bytes;\n\t\ttrace_btrfs_space_reservation(cache->fs_info, \"space_info\",\n\t\t\t\t\t      space_info->flags, num_bytes, 1);\n\t\tbtrfs_space_info_update_bytes_may_use(cache->fs_info,\n\t\t\t\t\t\t      space_info, -ram_bytes);\n\t\tif (delalloc)\n\t\t\tcache->delalloc_bytes += num_bytes;\n\n\t\t/*\n\t\t * Compression can use less space than we reserved, so wake\n\t\t * tickets if that happens\n\t\t */\n\t\tif (num_bytes < ram_bytes)\n\t\t\tbtrfs_try_granting_tickets(cache->fs_info, space_info);\n\t}\n\tspin_unlock(&cache->lock);\n\tspin_unlock(&space_info->lock);\n\treturn ret;\n}\n\n/**\n * btrfs_free_reserved_bytes - update the block_group and space info counters\n * @cache:      The cache we are manipulating\n * @num_bytes:  The number of bytes in question\n * @delalloc:   The blocks are allocated for the delalloc write\n *\n * This is called by somebody who is freeing space that was never actually used\n * on disk.  For example if you reserve some space for a new leaf in transaction\n * A and before transaction A commits you free that leaf, you call this with\n * reserve set to 0 in order to clear the reservation.\n */\nvoid btrfs_free_reserved_bytes(struct btrfs_block_group *cache,\n\t\t\t       u64 num_bytes, int delalloc)\n{\n\tstruct btrfs_space_info *space_info = cache->space_info;\n\n\tspin_lock(&space_info->lock);\n\tspin_lock(&cache->lock);\n\tif (cache->ro)\n\t\tspace_info->bytes_readonly += num_bytes;\n\tcache->reserved -= num_bytes;\n\tspace_info->bytes_reserved -= num_bytes;\n\tspace_info->max_extent_size = 0;\n\n\tif (delalloc)\n\t\tcache->delalloc_bytes -= num_bytes;\n\tspin_unlock(&cache->lock);\n\n\tbtrfs_try_granting_tickets(cache->fs_info, space_info);\n\tspin_unlock(&space_info->lock);\n}\n\nstatic void force_metadata_allocation(struct btrfs_fs_info *info)\n{\n\tstruct list_head *head = &info->space_info;\n\tstruct btrfs_space_info *found;\n\n\tlist_for_each_entry(found, head, list) {\n\t\tif (found->flags & BTRFS_BLOCK_GROUP_METADATA)\n\t\t\tfound->force_alloc = CHUNK_ALLOC_FORCE;\n\t}\n}\n\nstatic int should_alloc_chunk(struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_space_info *sinfo, int force)\n{\n\tu64 bytes_used = btrfs_space_info_used(sinfo, false);\n\tu64 thresh;\n\n\tif (force == CHUNK_ALLOC_FORCE)\n\t\treturn 1;\n\n\t/*\n\t * in limited mode, we want to have some free space up to\n\t * about 1% of the FS size.\n\t */\n\tif (force == CHUNK_ALLOC_LIMITED) {\n\t\tthresh = btrfs_super_total_bytes(fs_info->super_copy);\n\t\tthresh = max_t(u64, SZ_64M, div_factor_fine(thresh, 1));\n\n\t\tif (sinfo->total_bytes - bytes_used < thresh)\n\t\t\treturn 1;\n\t}\n\n\tif (bytes_used + SZ_2M < div_factor(sinfo->total_bytes, 8))\n\t\treturn 0;\n\treturn 1;\n}\n\nint btrfs_force_chunk_alloc(struct btrfs_trans_handle *trans, u64 type)\n{\n\tu64 alloc_flags = btrfs_get_alloc_profile(trans->fs_info, type);\n\n\treturn btrfs_chunk_alloc(trans, alloc_flags, CHUNK_ALLOC_FORCE);\n}\n\n/*\n * If force is CHUNK_ALLOC_FORCE:\n *    - return 1 if it successfully allocates a chunk,\n *    - return errors including -ENOSPC otherwise.\n * If force is NOT CHUNK_ALLOC_FORCE:\n *    - return 0 if it doesn't need to allocate a new chunk,\n *    - return 1 if it successfully allocates a chunk,\n *    - return errors including -ENOSPC otherwise.\n */\nint btrfs_chunk_alloc(struct btrfs_trans_handle *trans, u64 flags,\n\t\t      enum btrfs_chunk_alloc_enum force)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_space_info *space_info;\n\tbool wait_for_alloc = false;\n\tbool should_alloc = false;\n\tint ret = 0;\n\n\t/* Don't re-enter if we're already allocating a chunk */\n\tif (trans->allocating_chunk)\n\t\treturn -ENOSPC;\n\n\tspace_info = btrfs_find_space_info(fs_info, flags);\n\tASSERT(space_info);\n\n\tdo {\n\t\tspin_lock(&space_info->lock);\n\t\tif (force < space_info->force_alloc)\n\t\t\tforce = space_info->force_alloc;\n\t\tshould_alloc = should_alloc_chunk(fs_info, space_info, force);\n\t\tif (space_info->full) {\n\t\t\t/* No more free physical space */\n\t\t\tif (should_alloc)\n\t\t\t\tret = -ENOSPC;\n\t\t\telse\n\t\t\t\tret = 0;\n\t\t\tspin_unlock(&space_info->lock);\n\t\t\treturn ret;\n\t\t} else if (!should_alloc) {\n\t\t\tspin_unlock(&space_info->lock);\n\t\t\treturn 0;\n\t\t} else if (space_info->chunk_alloc) {\n\t\t\t/*\n\t\t\t * Someone is already allocating, so we need to block\n\t\t\t * until this someone is finished and then loop to\n\t\t\t * recheck if we should continue with our allocation\n\t\t\t * attempt.\n\t\t\t */\n\t\t\twait_for_alloc = true;\n\t\t\tspin_unlock(&space_info->lock);\n\t\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t\t} else {\n\t\t\t/* Proceed with allocation */\n\t\t\tspace_info->chunk_alloc = 1;\n\t\t\twait_for_alloc = false;\n\t\t\tspin_unlock(&space_info->lock);\n\t\t}\n\n\t\tcond_resched();\n\t} while (wait_for_alloc);\n\n\tmutex_lock(&fs_info->chunk_mutex);\n\ttrans->allocating_chunk = true;\n\n\t/*\n\t * If we have mixed data/metadata chunks we want to make sure we keep\n\t * allocating mixed chunks instead of individual chunks.\n\t */\n\tif (btrfs_mixed_space_info(space_info))\n\t\tflags |= (BTRFS_BLOCK_GROUP_DATA | BTRFS_BLOCK_GROUP_METADATA);\n\n\t/*\n\t * if we're doing a data chunk, go ahead and make sure that\n\t * we keep a reasonable number of metadata chunks allocated in the\n\t * FS as well.\n\t */\n\tif (flags & BTRFS_BLOCK_GROUP_DATA && fs_info->metadata_ratio) {\n\t\tfs_info->data_chunk_allocations++;\n\t\tif (!(fs_info->data_chunk_allocations %\n\t\t      fs_info->metadata_ratio))\n\t\t\tforce_metadata_allocation(fs_info);\n\t}\n\n\t/*\n\t * Check if we have enough space in SYSTEM chunk because we may need\n\t * to update devices.\n\t */\n\tcheck_system_chunk(trans, flags);\n\n\tret = btrfs_alloc_chunk(trans, flags);\n\ttrans->allocating_chunk = false;\n\n\tspin_lock(&space_info->lock);\n\tif (ret < 0) {\n\t\tif (ret == -ENOSPC)\n\t\t\tspace_info->full = 1;\n\t\telse\n\t\t\tgoto out;\n\t} else {\n\t\tret = 1;\n\t\tspace_info->max_extent_size = 0;\n\t}\n\n\tspace_info->force_alloc = CHUNK_ALLOC_NO_FORCE;\nout:\n\tspace_info->chunk_alloc = 0;\n\tspin_unlock(&space_info->lock);\n\tmutex_unlock(&fs_info->chunk_mutex);\n\t/*\n\t * When we allocate a new chunk we reserve space in the chunk block\n\t * reserve to make sure we can COW nodes/leafs in the chunk tree or\n\t * add new nodes/leafs to it if we end up needing to do it when\n\t * inserting the chunk item and updating device items as part of the\n\t * second phase of chunk allocation, performed by\n\t * btrfs_finish_chunk_alloc(). So make sure we don't accumulate a\n\t * large number of new block groups to create in our transaction\n\t * handle's new_bgs list to avoid exhausting the chunk block reserve\n\t * in extreme cases - like having a single transaction create many new\n\t * block groups when starting to write out the free space caches of all\n\t * the block groups that were made dirty during the lifetime of the\n\t * transaction.\n\t */\n\tif (trans->chunk_bytes_reserved >= (u64)SZ_2M)\n\t\tbtrfs_create_pending_block_groups(trans);\n\n\treturn ret;\n}\n\nstatic u64 get_profile_num_devs(struct btrfs_fs_info *fs_info, u64 type)\n{\n\tu64 num_dev;\n\n\tnum_dev = btrfs_raid_array[btrfs_bg_flags_to_raid_index(type)].devs_max;\n\tif (!num_dev)\n\t\tnum_dev = fs_info->fs_devices->rw_devices;\n\n\treturn num_dev;\n}\n\n/*\n * Reserve space in the system space for allocating or removing a chunk\n */\nvoid check_system_chunk(struct btrfs_trans_handle *trans, u64 type)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_space_info *info;\n\tu64 left;\n\tu64 thresh;\n\tint ret = 0;\n\tu64 num_devs;\n\n\t/*\n\t * Needed because we can end up allocating a system chunk and for an\n\t * atomic and race free space reservation in the chunk block reserve.\n\t */\n\tlockdep_assert_held(&fs_info->chunk_mutex);\n\n\tinfo = btrfs_find_space_info(fs_info, BTRFS_BLOCK_GROUP_SYSTEM);\n\tspin_lock(&info->lock);\n\tleft = info->total_bytes - btrfs_space_info_used(info, true);\n\tspin_unlock(&info->lock);\n\n\tnum_devs = get_profile_num_devs(fs_info, type);\n\n\t/* num_devs device items to update and 1 chunk item to add or remove */\n\tthresh = btrfs_calc_metadata_size(fs_info, num_devs) +\n\t\tbtrfs_calc_insert_metadata_size(fs_info, 1);\n\n\tif (left < thresh && btrfs_test_opt(fs_info, ENOSPC_DEBUG)) {\n\t\tbtrfs_info(fs_info, \"left=%llu, need=%llu, flags=%llu\",\n\t\t\t   left, thresh, type);\n\t\tbtrfs_dump_space_info(fs_info, info, 0, 0);\n\t}\n\n\tif (left < thresh) {\n\t\tu64 flags = btrfs_system_alloc_profile(fs_info);\n\n\t\t/*\n\t\t * Ignore failure to create system chunk. We might end up not\n\t\t * needing it, as we might not need to COW all nodes/leafs from\n\t\t * the paths we visit in the chunk tree (they were already COWed\n\t\t * or created in the current transaction for example).\n\t\t */\n\t\tret = btrfs_alloc_chunk(trans, flags);\n\t}\n\n\tif (!ret) {\n\t\tret = btrfs_block_rsv_add(fs_info->chunk_root,\n\t\t\t\t\t  &fs_info->chunk_block_rsv,\n\t\t\t\t\t  thresh, BTRFS_RESERVE_NO_FLUSH);\n\t\tif (!ret)\n\t\t\ttrans->chunk_bytes_reserved += thresh;\n\t}\n}\n\nvoid btrfs_put_block_group_cache(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group *block_group;\n\tu64 last = 0;\n\n\twhile (1) {\n\t\tstruct inode *inode;\n\n\t\tblock_group = btrfs_lookup_first_block_group(info, last);\n\t\twhile (block_group) {\n\t\t\tbtrfs_wait_block_group_cache_done(block_group);\n\t\t\tspin_lock(&block_group->lock);\n\t\t\tif (block_group->iref)\n\t\t\t\tbreak;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tblock_group = btrfs_next_block_group(block_group);\n\t\t}\n\t\tif (!block_group) {\n\t\t\tif (last == 0)\n\t\t\t\tbreak;\n\t\t\tlast = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode = block_group->inode;\n\t\tblock_group->iref = 0;\n\t\tblock_group->inode = NULL;\n\t\tspin_unlock(&block_group->lock);\n\t\tASSERT(block_group->io_ctl.inode == NULL);\n\t\tiput(inode);\n\t\tlast = block_group->start + block_group->length;\n\t\tbtrfs_put_block_group(block_group);\n\t}\n}\n\n/*\n * Must be called only after stopping all workers, since we could have block\n * group caching kthreads running, and therefore they could race with us if we\n * freed the block groups before stopping them.\n */\nint btrfs_free_block_groups(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group *block_group;\n\tstruct btrfs_space_info *space_info;\n\tstruct btrfs_caching_control *caching_ctl;\n\tstruct rb_node *n;\n\n\tspin_lock(&info->block_group_cache_lock);\n\twhile (!list_empty(&info->caching_block_groups)) {\n\t\tcaching_ctl = list_entry(info->caching_block_groups.next,\n\t\t\t\t\t struct btrfs_caching_control, list);\n\t\tlist_del(&caching_ctl->list);\n\t\tbtrfs_put_caching_control(caching_ctl);\n\t}\n\tspin_unlock(&info->block_group_cache_lock);\n\n\tspin_lock(&info->unused_bgs_lock);\n\twhile (!list_empty(&info->unused_bgs)) {\n\t\tblock_group = list_first_entry(&info->unused_bgs,\n\t\t\t\t\t       struct btrfs_block_group,\n\t\t\t\t\t       bg_list);\n\t\tlist_del_init(&block_group->bg_list);\n\t\tbtrfs_put_block_group(block_group);\n\t}\n\tspin_unlock(&info->unused_bgs_lock);\n\n\tspin_lock(&info->unused_bgs_lock);\n\twhile (!list_empty(&info->reclaim_bgs)) {\n\t\tblock_group = list_first_entry(&info->reclaim_bgs,\n\t\t\t\t\t       struct btrfs_block_group,\n\t\t\t\t\t       bg_list);\n\t\tlist_del_init(&block_group->bg_list);\n\t\tbtrfs_put_block_group(block_group);\n\t}\n\tspin_unlock(&info->unused_bgs_lock);\n\n\tspin_lock(&info->block_group_cache_lock);\n\twhile ((n = rb_last(&info->block_group_cache_tree)) != NULL) {\n\t\tblock_group = rb_entry(n, struct btrfs_block_group,\n\t\t\t\t       cache_node);\n\t\trb_erase(&block_group->cache_node,\n\t\t\t &info->block_group_cache_tree);\n\t\tRB_CLEAR_NODE(&block_group->cache_node);\n\t\tspin_unlock(&info->block_group_cache_lock);\n\n\t\tdown_write(&block_group->space_info->groups_sem);\n\t\tlist_del(&block_group->list);\n\t\tup_write(&block_group->space_info->groups_sem);\n\n\t\t/*\n\t\t * We haven't cached this block group, which means we could\n\t\t * possibly have excluded extents on this block group.\n\t\t */\n\t\tif (block_group->cached == BTRFS_CACHE_NO ||\n\t\t    block_group->cached == BTRFS_CACHE_ERROR)\n\t\t\tbtrfs_free_excluded_extents(block_group);\n\n\t\tbtrfs_remove_free_space_cache(block_group);\n\t\tASSERT(block_group->cached != BTRFS_CACHE_STARTED);\n\t\tASSERT(list_empty(&block_group->dirty_list));\n\t\tASSERT(list_empty(&block_group->io_list));\n\t\tASSERT(list_empty(&block_group->bg_list));\n\t\tASSERT(refcount_read(&block_group->refs) == 1);\n\t\tASSERT(block_group->swap_extents == 0);\n\t\tbtrfs_put_block_group(block_group);\n\n\t\tspin_lock(&info->block_group_cache_lock);\n\t}\n\tspin_unlock(&info->block_group_cache_lock);\n\n\tbtrfs_release_global_block_rsv(info);\n\n\twhile (!list_empty(&info->space_info)) {\n\t\tspace_info = list_entry(info->space_info.next,\n\t\t\t\t\tstruct btrfs_space_info,\n\t\t\t\t\tlist);\n\n\t\t/*\n\t\t * Do not hide this behind enospc_debug, this is actually\n\t\t * important and indicates a real bug if this happens.\n\t\t */\n\t\tif (WARN_ON(space_info->bytes_pinned > 0 ||\n\t\t\t    space_info->bytes_reserved > 0 ||\n\t\t\t    space_info->bytes_may_use > 0))\n\t\t\tbtrfs_dump_space_info(info, space_info, 0, 0);\n\t\tWARN_ON(space_info->reclaim_size > 0);\n\t\tlist_del(&space_info->list);\n\t\tbtrfs_sysfs_remove_space_info(space_info);\n\t}\n\treturn 0;\n}\n\nvoid btrfs_freeze_block_group(struct btrfs_block_group *cache)\n{\n\tatomic_inc(&cache->frozen);\n}\n\nvoid btrfs_unfreeze_block_group(struct btrfs_block_group *block_group)\n{\n\tstruct btrfs_fs_info *fs_info = block_group->fs_info;\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_map *em;\n\tbool cleanup;\n\n\tspin_lock(&block_group->lock);\n\tcleanup = (atomic_dec_and_test(&block_group->frozen) &&\n\t\t   block_group->removed);\n\tspin_unlock(&block_group->lock);\n\n\tif (cleanup) {\n\t\tem_tree = &fs_info->mapping_tree;\n\t\twrite_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, block_group->start,\n\t\t\t\t\t   1);\n\t\tBUG_ON(!em); /* logic error, can't happen */\n\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\n\t\t/* once for us and once for the tree */\n\t\tfree_extent_map(em);\n\t\tfree_extent_map(em);\n\n\t\t/*\n\t\t * We may have left one free space entry and other possible\n\t\t * tasks trimming this block group have left 1 entry each one.\n\t\t * Free them if any.\n\t\t */\n\t\t__btrfs_remove_free_space_cache(block_group->free_space_ctl);\n\t}\n}\n\nbool btrfs_inc_block_group_swap_extents(struct btrfs_block_group *bg)\n{\n\tbool ret = true;\n\n\tspin_lock(&bg->lock);\n\tif (bg->ro)\n\t\tret = false;\n\telse\n\t\tbg->swap_extents++;\n\tspin_unlock(&bg->lock);\n\n\treturn ret;\n}\n\nvoid btrfs_dec_block_group_swap_extents(struct btrfs_block_group *bg, int amount)\n{\n\tspin_lock(&bg->lock);\n\tASSERT(!bg->ro);\n\tASSERT(bg->swap_extents >= amount);\n\tbg->swap_extents -= amount;\n\tspin_unlock(&bg->lock);\n}\n", "// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (C) 2007 Oracle.  All rights reserved.\n */\n\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/blkdev.h>\n#include <linux/uuid.h>\n#include \"misc.h\"\n#include \"ctree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"volumes.h\"\n#include \"dev-replace.h\"\n#include \"qgroup.h\"\n#include \"block-group.h\"\n#include \"space-info.h\"\n#include \"zoned.h\"\n\n#define BTRFS_ROOT_TRANS_TAG 0\n\n/*\n * Transaction states and transitions\n *\n * No running transaction (fs tree blocks are not modified)\n * |\n * | To next stage:\n * |  Call start_transaction() variants. Except btrfs_join_transaction_nostart().\n * V\n * Transaction N [[TRANS_STATE_RUNNING]]\n * |\n * | New trans handles can be attached to transaction N by calling all\n * | start_transaction() variants.\n * |\n * | To next stage:\n * |  Call btrfs_commit_transaction() on any trans handle attached to\n * |  transaction N\n * V\n * Transaction N [[TRANS_STATE_COMMIT_START]]\n * |\n * | Will wait for previous running transaction to completely finish if there\n * | is one\n * |\n * | Then one of the following happes:\n * | - Wait for all other trans handle holders to release.\n * |   The btrfs_commit_transaction() caller will do the commit work.\n * | - Wait for current transaction to be committed by others.\n * |   Other btrfs_commit_transaction() caller will do the commit work.\n * |\n * | At this stage, only btrfs_join_transaction*() variants can attach\n * | to this running transaction.\n * | All other variants will wait for current one to finish and attach to\n * | transaction N+1.\n * |\n * | To next stage:\n * |  Caller is chosen to commit transaction N, and all other trans handle\n * |  haven been released.\n * V\n * Transaction N [[TRANS_STATE_COMMIT_DOING]]\n * |\n * | The heavy lifting transaction work is started.\n * | From running delayed refs (modifying extent tree) to creating pending\n * | snapshots, running qgroups.\n * | In short, modify supporting trees to reflect modifications of subvolume\n * | trees.\n * |\n * | At this stage, all start_transaction() calls will wait for this\n * | transaction to finish and attach to transaction N+1.\n * |\n * | To next stage:\n * |  Until all supporting trees are updated.\n * V\n * Transaction N [[TRANS_STATE_UNBLOCKED]]\n * |\t\t\t\t\t\t    Transaction N+1\n * | All needed trees are modified, thus we only    [[TRANS_STATE_RUNNING]]\n * | need to write them back to disk and update\t    |\n * | super blocks.\t\t\t\t    |\n * |\t\t\t\t\t\t    |\n * | At this stage, new transaction is allowed to   |\n * | start.\t\t\t\t\t    |\n * | All new start_transaction() calls will be\t    |\n * | attached to transid N+1.\t\t\t    |\n * |\t\t\t\t\t\t    |\n * | To next stage:\t\t\t\t    |\n * |  Until all tree blocks are super blocks are    |\n * |  written to block devices\t\t\t    |\n * V\t\t\t\t\t\t    |\n * Transaction N [[TRANS_STATE_COMPLETED]]\t    V\n *   All tree blocks and super blocks are written.  Transaction N+1\n *   This transaction is finished and all its\t    [[TRANS_STATE_COMMIT_START]]\n *   data structures will be cleaned up.\t    | Life goes on\n */\nstatic const unsigned int btrfs_blocked_trans_types[TRANS_STATE_MAX] = {\n\t[TRANS_STATE_RUNNING]\t\t= 0U,\n\t[TRANS_STATE_COMMIT_START]\t= (__TRANS_START | __TRANS_ATTACH),\n\t[TRANS_STATE_COMMIT_DOING]\t= (__TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN |\n\t\t\t\t\t   __TRANS_JOIN_NOSTART),\n\t[TRANS_STATE_UNBLOCKED]\t\t= (__TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN |\n\t\t\t\t\t   __TRANS_JOIN_NOLOCK |\n\t\t\t\t\t   __TRANS_JOIN_NOSTART),\n\t[TRANS_STATE_SUPER_COMMITTED]\t= (__TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN |\n\t\t\t\t\t   __TRANS_JOIN_NOLOCK |\n\t\t\t\t\t   __TRANS_JOIN_NOSTART),\n\t[TRANS_STATE_COMPLETED]\t\t= (__TRANS_START |\n\t\t\t\t\t   __TRANS_ATTACH |\n\t\t\t\t\t   __TRANS_JOIN |\n\t\t\t\t\t   __TRANS_JOIN_NOLOCK |\n\t\t\t\t\t   __TRANS_JOIN_NOSTART),\n};\n\nvoid btrfs_put_transaction(struct btrfs_transaction *transaction)\n{\n\tWARN_ON(refcount_read(&transaction->use_count) == 0);\n\tif (refcount_dec_and_test(&transaction->use_count)) {\n\t\tBUG_ON(!list_empty(&transaction->list));\n\t\tWARN_ON(!RB_EMPTY_ROOT(\n\t\t\t\t&transaction->delayed_refs.href_root.rb_root));\n\t\tWARN_ON(!RB_EMPTY_ROOT(\n\t\t\t\t&transaction->delayed_refs.dirty_extent_root));\n\t\tif (transaction->delayed_refs.pending_csums)\n\t\t\tbtrfs_err(transaction->fs_info,\n\t\t\t\t  \"pending csums is %llu\",\n\t\t\t\t  transaction->delayed_refs.pending_csums);\n\t\t/*\n\t\t * If any block groups are found in ->deleted_bgs then it's\n\t\t * because the transaction was aborted and a commit did not\n\t\t * happen (things failed before writing the new superblock\n\t\t * and calling btrfs_finish_extent_commit()), so we can not\n\t\t * discard the physical locations of the block groups.\n\t\t */\n\t\twhile (!list_empty(&transaction->deleted_bgs)) {\n\t\t\tstruct btrfs_block_group *cache;\n\n\t\t\tcache = list_first_entry(&transaction->deleted_bgs,\n\t\t\t\t\t\t struct btrfs_block_group,\n\t\t\t\t\t\t bg_list);\n\t\t\tlist_del_init(&cache->bg_list);\n\t\t\tbtrfs_unfreeze_block_group(cache);\n\t\t\tbtrfs_put_block_group(cache);\n\t\t}\n\t\tWARN_ON(!list_empty(&transaction->dev_update_list));\n\t\tkfree(transaction);\n\t}\n}\n\nstatic noinline void switch_commit_roots(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_root *root, *tmp;\n\tstruct btrfs_caching_control *caching_ctl, *next;\n\n\tdown_write(&fs_info->commit_root_sem);\n\tlist_for_each_entry_safe(root, tmp, &cur_trans->switch_commits,\n\t\t\t\t dirty_list) {\n\t\tlist_del_init(&root->dirty_list);\n\t\tfree_extent_buffer(root->commit_root);\n\t\troot->commit_root = btrfs_root_node(root);\n\t\textent_io_tree_release(&root->dirty_log_pages);\n\t\tbtrfs_qgroup_clean_swapped_blocks(root);\n\t}\n\n\t/* We can free old roots now. */\n\tspin_lock(&cur_trans->dropped_roots_lock);\n\twhile (!list_empty(&cur_trans->dropped_roots)) {\n\t\troot = list_first_entry(&cur_trans->dropped_roots,\n\t\t\t\t\tstruct btrfs_root, root_list);\n\t\tlist_del_init(&root->root_list);\n\t\tspin_unlock(&cur_trans->dropped_roots_lock);\n\t\tbtrfs_free_log(trans, root);\n\t\tbtrfs_drop_and_free_fs_root(fs_info, root);\n\t\tspin_lock(&cur_trans->dropped_roots_lock);\n\t}\n\tspin_unlock(&cur_trans->dropped_roots_lock);\n\n\t/*\n\t * We have to update the last_byte_to_unpin under the commit_root_sem,\n\t * at the same time we swap out the commit roots.\n\t *\n\t * This is because we must have a real view of the last spot the caching\n\t * kthreads were while caching.  Consider the following views of the\n\t * extent tree for a block group\n\t *\n\t * commit root\n\t * +----+----+----+----+----+----+----+\n\t * |\\\\\\\\|    |\\\\\\\\|\\\\\\\\|    |\\\\\\\\|\\\\\\\\|\n\t * +----+----+----+----+----+----+----+\n\t * 0    1    2    3    4    5    6    7\n\t *\n\t * new commit root\n\t * +----+----+----+----+----+----+----+\n\t * |    |    |    |\\\\\\\\|    |    |\\\\\\\\|\n\t * +----+----+----+----+----+----+----+\n\t * 0    1    2    3    4    5    6    7\n\t *\n\t * If the cache_ctl->progress was at 3, then we are only allowed to\n\t * unpin [0,1) and [2,3], because the caching thread has already\n\t * processed those extents.  We are not allowed to unpin [5,6), because\n\t * the caching thread will re-start it's search from 3, and thus find\n\t * the hole from [4,6) to add to the free space cache.\n\t */\n\tspin_lock(&fs_info->block_group_cache_lock);\n\tlist_for_each_entry_safe(caching_ctl, next,\n\t\t\t\t &fs_info->caching_block_groups, list) {\n\t\tstruct btrfs_block_group *cache = caching_ctl->block_group;\n\n\t\tif (btrfs_block_group_done(cache)) {\n\t\t\tcache->last_byte_to_unpin = (u64)-1;\n\t\t\tlist_del_init(&caching_ctl->list);\n\t\t\tbtrfs_put_caching_control(caching_ctl);\n\t\t} else {\n\t\t\tcache->last_byte_to_unpin = caching_ctl->progress;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->block_group_cache_lock);\n\tup_write(&fs_info->commit_root_sem);\n}\n\nstatic inline void extwriter_counter_inc(struct btrfs_transaction *trans,\n\t\t\t\t\t unsigned int type)\n{\n\tif (type & TRANS_EXTWRITERS)\n\t\tatomic_inc(&trans->num_extwriters);\n}\n\nstatic inline void extwriter_counter_dec(struct btrfs_transaction *trans,\n\t\t\t\t\t unsigned int type)\n{\n\tif (type & TRANS_EXTWRITERS)\n\t\tatomic_dec(&trans->num_extwriters);\n}\n\nstatic inline void extwriter_counter_init(struct btrfs_transaction *trans,\n\t\t\t\t\t  unsigned int type)\n{\n\tatomic_set(&trans->num_extwriters, ((type & TRANS_EXTWRITERS) ? 1 : 0));\n}\n\nstatic inline int extwriter_counter_read(struct btrfs_transaction *trans)\n{\n\treturn atomic_read(&trans->num_extwriters);\n}\n\n/*\n * To be called after all the new block groups attached to the transaction\n * handle have been created (btrfs_create_pending_block_groups()).\n */\nvoid btrfs_trans_release_chunk_metadata(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\n\tif (!trans->chunk_bytes_reserved)\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&trans->new_bgs));\n\n\tbtrfs_block_rsv_release(fs_info, &fs_info->chunk_block_rsv,\n\t\t\t\ttrans->chunk_bytes_reserved, NULL);\n\ttrans->chunk_bytes_reserved = 0;\n}\n\n/*\n * either allocate a new transaction or hop into the existing one\n */\nstatic noinline int join_transaction(struct btrfs_fs_info *fs_info,\n\t\t\t\t     unsigned int type)\n{\n\tstruct btrfs_transaction *cur_trans;\n\n\tspin_lock(&fs_info->trans_lock);\nloop:\n\t/* The file system has been taken offline. No new transactions. */\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\treturn -EROFS;\n\t}\n\n\tcur_trans = fs_info->running_transaction;\n\tif (cur_trans) {\n\t\tif (TRANS_ABORTED(cur_trans)) {\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\treturn cur_trans->aborted;\n\t\t}\n\t\tif (btrfs_blocked_trans_types[cur_trans->state] & type) {\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\trefcount_inc(&cur_trans->use_count);\n\t\tatomic_inc(&cur_trans->num_writers);\n\t\textwriter_counter_inc(cur_trans, type);\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n\n\t/*\n\t * If we are ATTACH, we just want to catch the current transaction,\n\t * and commit it. If there is no transaction, just return ENOENT.\n\t */\n\tif (type == TRANS_ATTACH)\n\t\treturn -ENOENT;\n\n\t/*\n\t * JOIN_NOLOCK only happens during the transaction commit, so\n\t * it is impossible that ->running_transaction is NULL\n\t */\n\tBUG_ON(type == TRANS_JOIN_NOLOCK);\n\n\tcur_trans = kmalloc(sizeof(*cur_trans), GFP_NOFS);\n\tif (!cur_trans)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (fs_info->running_transaction) {\n\t\t/*\n\t\t * someone started a transaction after we unlocked.  Make sure\n\t\t * to redo the checks above\n\t\t */\n\t\tkfree(cur_trans);\n\t\tgoto loop;\n\t} else if (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\tkfree(cur_trans);\n\t\treturn -EROFS;\n\t}\n\n\tcur_trans->fs_info = fs_info;\n\tatomic_set(&cur_trans->pending_ordered, 0);\n\tinit_waitqueue_head(&cur_trans->pending_wait);\n\tatomic_set(&cur_trans->num_writers, 1);\n\textwriter_counter_init(cur_trans, type);\n\tinit_waitqueue_head(&cur_trans->writer_wait);\n\tinit_waitqueue_head(&cur_trans->commit_wait);\n\tcur_trans->state = TRANS_STATE_RUNNING;\n\t/*\n\t * One for this trans handle, one so it will live on until we\n\t * commit the transaction.\n\t */\n\trefcount_set(&cur_trans->use_count, 2);\n\tcur_trans->flags = 0;\n\tcur_trans->start_time = ktime_get_seconds();\n\n\tmemset(&cur_trans->delayed_refs, 0, sizeof(cur_trans->delayed_refs));\n\n\tcur_trans->delayed_refs.href_root = RB_ROOT_CACHED;\n\tcur_trans->delayed_refs.dirty_extent_root = RB_ROOT;\n\tatomic_set(&cur_trans->delayed_refs.num_entries, 0);\n\n\t/*\n\t * although the tree mod log is per file system and not per transaction,\n\t * the log must never go across transaction boundaries.\n\t */\n\tsmp_mb();\n\tif (!list_empty(&fs_info->tree_mod_seq_list))\n\t\tWARN(1, KERN_ERR \"BTRFS: tree_mod_seq_list not empty when creating a fresh transaction\\n\");\n\tif (!RB_EMPTY_ROOT(&fs_info->tree_mod_log))\n\t\tWARN(1, KERN_ERR \"BTRFS: tree_mod_log rb tree not empty when creating a fresh transaction\\n\");\n\tatomic64_set(&fs_info->tree_mod_seq, 0);\n\n\tspin_lock_init(&cur_trans->delayed_refs.lock);\n\n\tINIT_LIST_HEAD(&cur_trans->pending_snapshots);\n\tINIT_LIST_HEAD(&cur_trans->dev_update_list);\n\tINIT_LIST_HEAD(&cur_trans->switch_commits);\n\tINIT_LIST_HEAD(&cur_trans->dirty_bgs);\n\tINIT_LIST_HEAD(&cur_trans->io_bgs);\n\tINIT_LIST_HEAD(&cur_trans->dropped_roots);\n\tmutex_init(&cur_trans->cache_write_mutex);\n\tspin_lock_init(&cur_trans->dirty_bgs_lock);\n\tINIT_LIST_HEAD(&cur_trans->deleted_bgs);\n\tspin_lock_init(&cur_trans->dropped_roots_lock);\n\tINIT_LIST_HEAD(&cur_trans->releasing_ebs);\n\tspin_lock_init(&cur_trans->releasing_ebs_lock);\n\tlist_add_tail(&cur_trans->list, &fs_info->trans_list);\n\textent_io_tree_init(fs_info, &cur_trans->dirty_pages,\n\t\t\tIO_TREE_TRANS_DIRTY_PAGES, fs_info->btree_inode);\n\textent_io_tree_init(fs_info, &cur_trans->pinned_extents,\n\t\t\tIO_TREE_FS_PINNED_EXTENTS, NULL);\n\tfs_info->generation++;\n\tcur_trans->transid = fs_info->generation;\n\tfs_info->running_transaction = cur_trans;\n\tcur_trans->aborted = 0;\n\tspin_unlock(&fs_info->trans_lock);\n\n\treturn 0;\n}\n\n/*\n * This does all the record keeping required to make sure that a shareable root\n * is properly recorded in a given transaction.  This is required to make sure\n * the old root from before we joined the transaction is deleted when the\n * transaction commits.\n */\nstatic int record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       int force)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret = 0;\n\n\tif ((test_bit(BTRFS_ROOT_SHAREABLE, &root->state) &&\n\t    root->last_trans < trans->transid) || force) {\n\t\tWARN_ON(root == fs_info->extent_root);\n\t\tWARN_ON(!force && root->commit_root != root->node);\n\n\t\t/*\n\t\t * see below for IN_TRANS_SETUP usage rules\n\t\t * we have the reloc mutex held now, so there\n\t\t * is only one writer in this function\n\t\t */\n\t\tset_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state);\n\n\t\t/* make sure readers find IN_TRANS_SETUP before\n\t\t * they find our root->last_trans update\n\t\t */\n\t\tsmp_wmb();\n\n\t\tspin_lock(&fs_info->fs_roots_radix_lock);\n\t\tif (root->last_trans == trans->transid && !force) {\n\t\t\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tradix_tree_tag_set(&fs_info->fs_roots_radix,\n\t\t\t\t   (unsigned long)root->root_key.objectid,\n\t\t\t\t   BTRFS_ROOT_TRANS_TAG);\n\t\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\t\troot->last_trans = trans->transid;\n\n\t\t/* this is pretty tricky.  We don't want to\n\t\t * take the relocation lock in btrfs_record_root_in_trans\n\t\t * unless we're really doing the first setup for this root in\n\t\t * this transaction.\n\t\t *\n\t\t * Normally we'd use root->last_trans as a flag to decide\n\t\t * if we want to take the expensive mutex.\n\t\t *\n\t\t * But, we have to set root->last_trans before we\n\t\t * init the relocation root, otherwise, we trip over warnings\n\t\t * in ctree.c.  The solution used here is to flag ourselves\n\t\t * with root IN_TRANS_SETUP.  When this is 1, we're still\n\t\t * fixing up the reloc trees and everyone must wait.\n\t\t *\n\t\t * When this is zero, they can trust root->last_trans and fly\n\t\t * through btrfs_record_root_in_trans without having to take the\n\t\t * lock.  smp_wmb() makes sure that all the writes above are\n\t\t * done before we pop in the zero below\n\t\t */\n\t\tret = btrfs_init_reloc_root(trans, root);\n\t\tsmp_mb__before_atomic();\n\t\tclear_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state);\n\t}\n\treturn ret;\n}\n\n\nvoid btrfs_add_dropped_root(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\n\t/* Add ourselves to the transaction dropped list */\n\tspin_lock(&cur_trans->dropped_roots_lock);\n\tlist_add_tail(&root->root_list, &cur_trans->dropped_roots);\n\tspin_unlock(&cur_trans->dropped_roots_lock);\n\n\t/* Make sure we don't try to update the root at commit time */\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\tradix_tree_tag_clear(&fs_info->fs_roots_radix,\n\t\t\t     (unsigned long)root->root_key.objectid,\n\t\t\t     BTRFS_ROOT_TRANS_TAG);\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n}\n\nint btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\n\tif (!test_bit(BTRFS_ROOT_SHAREABLE, &root->state))\n\t\treturn 0;\n\n\t/*\n\t * see record_root_in_trans for comments about IN_TRANS_SETUP usage\n\t * and barriers\n\t */\n\tsmp_rmb();\n\tif (root->last_trans == trans->transid &&\n\t    !test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\n\t\treturn 0;\n\n\tmutex_lock(&fs_info->reloc_mutex);\n\tret = record_root_in_trans(trans, root, 0);\n\tmutex_unlock(&fs_info->reloc_mutex);\n\n\treturn ret;\n}\n\nstatic inline int is_transaction_blocked(struct btrfs_transaction *trans)\n{\n\treturn (trans->state >= TRANS_STATE_COMMIT_START &&\n\t\ttrans->state < TRANS_STATE_UNBLOCKED &&\n\t\t!TRANS_ABORTED(trans));\n}\n\n/* wait for commit against the current transaction to become unblocked\n * when this is done, it is safe to start a new transaction, but the current\n * transaction might not be fully on disk.\n */\nstatic void wait_current_trans(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_transaction *cur_trans;\n\n\tspin_lock(&fs_info->trans_lock);\n\tcur_trans = fs_info->running_transaction;\n\tif (cur_trans && is_transaction_blocked(cur_trans)) {\n\t\trefcount_inc(&cur_trans->use_count);\n\t\tspin_unlock(&fs_info->trans_lock);\n\n\t\twait_event(fs_info->transaction_wait,\n\t\t\t   cur_trans->state >= TRANS_STATE_UNBLOCKED ||\n\t\t\t   TRANS_ABORTED(cur_trans));\n\t\tbtrfs_put_transaction(cur_trans);\n\t} else {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t}\n}\n\nstatic int may_wait_transaction(struct btrfs_fs_info *fs_info, int type)\n{\n\tif (test_bit(BTRFS_FS_LOG_RECOVERING, &fs_info->flags))\n\t\treturn 0;\n\n\tif (type == TRANS_START)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic inline bool need_reserve_reloc_root(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (!fs_info->reloc_ctl ||\n\t    !test_bit(BTRFS_ROOT_SHAREABLE, &root->state) ||\n\t    root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID ||\n\t    root->reloc_root)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic struct btrfs_trans_handle *\nstart_transaction(struct btrfs_root *root, unsigned int num_items,\n\t\t  unsigned int type, enum btrfs_reserve_flush_enum flush,\n\t\t  bool enforce_qgroups)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_block_rsv *delayed_refs_rsv = &fs_info->delayed_refs_rsv;\n\tstruct btrfs_trans_handle *h;\n\tstruct btrfs_transaction *cur_trans;\n\tu64 num_bytes = 0;\n\tu64 qgroup_reserved = 0;\n\tbool reloc_reserved = false;\n\tbool do_chunk_alloc = false;\n\tint ret;\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\n\t\treturn ERR_PTR(-EROFS);\n\n\tif (current->journal_info) {\n\t\tWARN_ON(type & TRANS_EXTWRITERS);\n\t\th = current->journal_info;\n\t\trefcount_inc(&h->use_count);\n\t\tWARN_ON(refcount_read(&h->use_count) > 2);\n\t\th->orig_rsv = h->block_rsv;\n\t\th->block_rsv = NULL;\n\t\tgoto got_it;\n\t}\n\n\t/*\n\t * Do the reservation before we join the transaction so we can do all\n\t * the appropriate flushing if need be.\n\t */\n\tif (num_items && root != fs_info->chunk_root) {\n\t\tstruct btrfs_block_rsv *rsv = &fs_info->trans_block_rsv;\n\t\tu64 delayed_refs_bytes = 0;\n\n\t\tqgroup_reserved = num_items * fs_info->nodesize;\n\t\tret = btrfs_qgroup_reserve_meta_pertrans(root, qgroup_reserved,\n\t\t\t\tenforce_qgroups);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\n\t\t/*\n\t\t * We want to reserve all the bytes we may need all at once, so\n\t\t * we only do 1 enospc flushing cycle per transaction start.  We\n\t\t * accomplish this by simply assuming we'll do 2 x num_items\n\t\t * worth of delayed refs updates in this trans handle, and\n\t\t * refill that amount for whatever is missing in the reserve.\n\t\t */\n\t\tnum_bytes = btrfs_calc_insert_metadata_size(fs_info, num_items);\n\t\tif (flush == BTRFS_RESERVE_FLUSH_ALL &&\n\t\t    delayed_refs_rsv->full == 0) {\n\t\t\tdelayed_refs_bytes = num_bytes;\n\t\t\tnum_bytes <<= 1;\n\t\t}\n\n\t\t/*\n\t\t * Do the reservation for the relocation root creation\n\t\t */\n\t\tif (need_reserve_reloc_root(root)) {\n\t\t\tnum_bytes += fs_info->nodesize;\n\t\t\treloc_reserved = true;\n\t\t}\n\n\t\tret = btrfs_block_rsv_add(root, rsv, num_bytes, flush);\n\t\tif (ret)\n\t\t\tgoto reserve_fail;\n\t\tif (delayed_refs_bytes) {\n\t\t\tbtrfs_migrate_to_delayed_refs_rsv(fs_info, rsv,\n\t\t\t\t\t\t\t  delayed_refs_bytes);\n\t\t\tnum_bytes -= delayed_refs_bytes;\n\t\t}\n\n\t\tif (rsv->space_info->force_alloc)\n\t\t\tdo_chunk_alloc = true;\n\t} else if (num_items == 0 && flush == BTRFS_RESERVE_FLUSH_ALL &&\n\t\t   !delayed_refs_rsv->full) {\n\t\t/*\n\t\t * Some people call with btrfs_start_transaction(root, 0)\n\t\t * because they can be throttled, but have some other mechanism\n\t\t * for reserving space.  We still want these guys to refill the\n\t\t * delayed block_rsv so just add 1 items worth of reservation\n\t\t * here.\n\t\t */\n\t\tret = btrfs_delayed_refs_rsv_refill(fs_info, flush);\n\t\tif (ret)\n\t\t\tgoto reserve_fail;\n\t}\nagain:\n\th = kmem_cache_zalloc(btrfs_trans_handle_cachep, GFP_NOFS);\n\tif (!h) {\n\t\tret = -ENOMEM;\n\t\tgoto alloc_fail;\n\t}\n\n\t/*\n\t * If we are JOIN_NOLOCK we're already committing a transaction and\n\t * waiting on this guy, so we don't need to do the sb_start_intwrite\n\t * because we're already holding a ref.  We need this because we could\n\t * have raced in and did an fsync() on a file which can kick a commit\n\t * and then we deadlock with somebody doing a freeze.\n\t *\n\t * If we are ATTACH, it means we just want to catch the current\n\t * transaction and commit it, so we needn't do sb_start_intwrite(). \n\t */\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_start_intwrite(fs_info->sb);\n\n\tif (may_wait_transaction(fs_info, type))\n\t\twait_current_trans(fs_info);\n\n\tdo {\n\t\tret = join_transaction(fs_info, type);\n\t\tif (ret == -EBUSY) {\n\t\t\twait_current_trans(fs_info);\n\t\t\tif (unlikely(type == TRANS_ATTACH ||\n\t\t\t\t     type == TRANS_JOIN_NOSTART))\n\t\t\t\tret = -ENOENT;\n\t\t}\n\t} while (ret == -EBUSY);\n\n\tif (ret < 0)\n\t\tgoto join_fail;\n\n\tcur_trans = fs_info->running_transaction;\n\n\th->transid = cur_trans->transid;\n\th->transaction = cur_trans;\n\th->root = root;\n\trefcount_set(&h->use_count, 1);\n\th->fs_info = root->fs_info;\n\n\th->type = type;\n\th->can_flush_pending_bgs = true;\n\tINIT_LIST_HEAD(&h->new_bgs);\n\n\tsmp_mb();\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START &&\n\t    may_wait_transaction(fs_info, type)) {\n\t\tcurrent->journal_info = h;\n\t\tbtrfs_commit_transaction(h);\n\t\tgoto again;\n\t}\n\n\tif (num_bytes) {\n\t\ttrace_btrfs_space_reservation(fs_info, \"transaction\",\n\t\t\t\t\t      h->transid, num_bytes, 1);\n\t\th->block_rsv = &fs_info->trans_block_rsv;\n\t\th->bytes_reserved = num_bytes;\n\t\th->reloc_reserved = reloc_reserved;\n\t}\n\ngot_it:\n\tif (!current->journal_info)\n\t\tcurrent->journal_info = h;\n\n\t/*\n\t * If the space_info is marked ALLOC_FORCE then we'll get upgraded to\n\t * ALLOC_FORCE the first run through, and then we won't allocate for\n\t * anybody else who races in later.  We don't care about the return\n\t * value here.\n\t */\n\tif (do_chunk_alloc && num_bytes) {\n\t\tu64 flags = h->block_rsv->space_info->flags;\n\n\t\tbtrfs_chunk_alloc(h, btrfs_get_alloc_profile(fs_info, flags),\n\t\t\t\t  CHUNK_ALLOC_NO_FORCE);\n\t}\n\n\t/*\n\t * btrfs_record_root_in_trans() needs to alloc new extents, and may\n\t * call btrfs_join_transaction() while we're also starting a\n\t * transaction.\n\t *\n\t * Thus it need to be called after current->journal_info initialized,\n\t * or we can deadlock.\n\t */\n\tret = btrfs_record_root_in_trans(h, root);\n\tif (ret) {\n\t\t/*\n\t\t * The transaction handle is fully initialized and linked with\n\t\t * other structures so it needs to be ended in case of errors,\n\t\t * not just freed.\n\t\t */\n\t\tbtrfs_end_transaction(h);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn h;\n\njoin_fail:\n\tif (type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(fs_info->sb);\n\tkmem_cache_free(btrfs_trans_handle_cachep, h);\nalloc_fail:\n\tif (num_bytes)\n\t\tbtrfs_block_rsv_release(fs_info, &fs_info->trans_block_rsv,\n\t\t\t\t\tnum_bytes, NULL);\nreserve_fail:\n\tbtrfs_qgroup_free_meta_pertrans(root, qgroup_reserved);\n\treturn ERR_PTR(ret);\n}\n\nstruct btrfs_trans_handle *btrfs_start_transaction(struct btrfs_root *root,\n\t\t\t\t\t\t   unsigned int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_ALL, true);\n}\n\nstruct btrfs_trans_handle *btrfs_start_transaction_fallback_global_rsv(\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tunsigned int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_ALL_STEAL, false);\n}\n\nstruct btrfs_trans_handle *btrfs_join_transaction(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN, BTRFS_RESERVE_NO_FLUSH,\n\t\t\t\t true);\n}\n\nstruct btrfs_trans_handle *btrfs_join_transaction_spacecache(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK,\n\t\t\t\t BTRFS_RESERVE_NO_FLUSH, true);\n}\n\n/*\n * Similar to regular join but it never starts a transaction when none is\n * running or after waiting for the current one to finish.\n */\nstruct btrfs_trans_handle *btrfs_join_transaction_nostart(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOSTART,\n\t\t\t\t BTRFS_RESERVE_NO_FLUSH, true);\n}\n\n/*\n * btrfs_attach_transaction() - catch the running transaction\n *\n * It is used when we want to commit the current the transaction, but\n * don't want to start a new one.\n *\n * Note: If this function return -ENOENT, it just means there is no\n * running transaction. But it is possible that the inactive transaction\n * is still in the memory, not fully on disk. If you hope there is no\n * inactive transaction in the fs when -ENOENT is returned, you should\n * invoke\n *     btrfs_attach_transaction_barrier()\n */\nstruct btrfs_trans_handle *btrfs_attach_transaction(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_ATTACH,\n\t\t\t\t BTRFS_RESERVE_NO_FLUSH, true);\n}\n\n/*\n * btrfs_attach_transaction_barrier() - catch the running transaction\n *\n * It is similar to the above function, the difference is this one\n * will wait for all the inactive transactions until they fully\n * complete.\n */\nstruct btrfs_trans_handle *\nbtrfs_attach_transaction_barrier(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = start_transaction(root, 0, TRANS_ATTACH,\n\t\t\t\t  BTRFS_RESERVE_NO_FLUSH, true);\n\tif (trans == ERR_PTR(-ENOENT))\n\t\tbtrfs_wait_for_commit(root->fs_info, 0);\n\n\treturn trans;\n}\n\n/* Wait for a transaction commit to reach at least the given state. */\nstatic noinline void wait_for_commit(struct btrfs_transaction *commit,\n\t\t\t\t     const enum btrfs_trans_state min_state)\n{\n\twait_event(commit->commit_wait, commit->state >= min_state);\n}\n\nint btrfs_wait_for_commit(struct btrfs_fs_info *fs_info, u64 transid)\n{\n\tstruct btrfs_transaction *cur_trans = NULL, *t;\n\tint ret = 0;\n\n\tif (transid) {\n\t\tif (transid <= fs_info->last_trans_committed)\n\t\t\tgoto out;\n\n\t\t/* find specified transaction */\n\t\tspin_lock(&fs_info->trans_lock);\n\t\tlist_for_each_entry(t, &fs_info->trans_list, list) {\n\t\t\tif (t->transid == transid) {\n\t\t\t\tcur_trans = t;\n\t\t\t\trefcount_inc(&cur_trans->use_count);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t->transid > transid) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&fs_info->trans_lock);\n\n\t\t/*\n\t\t * The specified transaction doesn't exist, or we\n\t\t * raced with btrfs_commit_transaction\n\t\t */\n\t\tif (!cur_trans) {\n\t\t\tif (transid > fs_info->last_trans_committed)\n\t\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* find newest transaction that is committing | committed */\n\t\tspin_lock(&fs_info->trans_lock);\n\t\tlist_for_each_entry_reverse(t, &fs_info->trans_list,\n\t\t\t\t\t    list) {\n\t\t\tif (t->state >= TRANS_STATE_COMMIT_START) {\n\t\t\t\tif (t->state == TRANS_STATE_COMPLETED)\n\t\t\t\t\tbreak;\n\t\t\t\tcur_trans = t;\n\t\t\t\trefcount_inc(&cur_trans->use_count);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\tif (!cur_trans)\n\t\t\tgoto out;  /* nothing committing|committed */\n\t}\n\n\twait_for_commit(cur_trans, TRANS_STATE_COMPLETED);\n\tbtrfs_put_transaction(cur_trans);\nout:\n\treturn ret;\n}\n\nvoid btrfs_throttle(struct btrfs_fs_info *fs_info)\n{\n\twait_current_trans(fs_info);\n}\n\nstatic bool should_end_transaction(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\n\tif (btrfs_check_space_for_delayed_refs(fs_info))\n\t\treturn true;\n\n\treturn !!btrfs_block_rsv_check(&fs_info->global_block_rsv, 5);\n}\n\nbool btrfs_should_end_transaction(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START ||\n\t    test_bit(BTRFS_DELAYED_REFS_FLUSHING, &cur_trans->delayed_refs.flags))\n\t\treturn true;\n\n\treturn should_end_transaction(trans);\n}\n\nstatic void btrfs_trans_release_metadata(struct btrfs_trans_handle *trans)\n\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\n\tif (!trans->block_rsv) {\n\t\tASSERT(!trans->bytes_reserved);\n\t\treturn;\n\t}\n\n\tif (!trans->bytes_reserved)\n\t\treturn;\n\n\tASSERT(trans->block_rsv == &fs_info->trans_block_rsv);\n\ttrace_btrfs_space_reservation(fs_info, \"transaction\",\n\t\t\t\t      trans->transid, trans->bytes_reserved, 0);\n\tbtrfs_block_rsv_release(fs_info, trans->block_rsv,\n\t\t\t\ttrans->bytes_reserved, NULL);\n\ttrans->bytes_reserved = 0;\n}\n\nstatic int __btrfs_end_transaction(struct btrfs_trans_handle *trans,\n\t\t\t\t   int throttle)\n{\n\tstruct btrfs_fs_info *info = trans->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tint err = 0;\n\n\tif (refcount_read(&trans->use_count) > 1) {\n\t\trefcount_dec(&trans->use_count);\n\t\ttrans->block_rsv = trans->orig_rsv;\n\t\treturn 0;\n\t}\n\n\tbtrfs_trans_release_metadata(trans);\n\ttrans->block_rsv = NULL;\n\n\tbtrfs_create_pending_block_groups(trans);\n\n\tbtrfs_trans_release_chunk_metadata(trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(info->sb);\n\n\tWARN_ON(cur_trans != info->running_transaction);\n\tWARN_ON(atomic_read(&cur_trans->num_writers) < 1);\n\tatomic_dec(&cur_trans->num_writers);\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tcond_wake_up(&cur_trans->writer_wait);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tif (throttle)\n\t\tbtrfs_run_delayed_iputs(info);\n\n\tif (TRANS_ABORTED(trans) ||\n\t    test_bit(BTRFS_FS_STATE_ERROR, &info->fs_state)) {\n\t\twake_up_process(info->transaction_kthread);\n\t\tif (TRANS_ABORTED(trans))\n\t\t\terr = trans->aborted;\n\t\telse\n\t\t\terr = -EROFS;\n\t}\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\treturn err;\n}\n\nint btrfs_end_transaction(struct btrfs_trans_handle *trans)\n{\n\treturn __btrfs_end_transaction(trans, 0);\n}\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans)\n{\n\treturn __btrfs_end_transaction(trans, 1);\n}\n\n/*\n * when btree blocks are allocated, they have some corresponding bits set for\n * them in one of two extent_io trees.  This is used to make sure all of\n * those extents are sent to disk but does not wait on them\n */\nint btrfs_write_marked_extents(struct btrfs_fs_info *fs_info,\n\t\t\t       struct extent_io_tree *dirty_pages, int mark)\n{\n\tint err = 0;\n\tint werr = 0;\n\tstruct address_space *mapping = fs_info->btree_inode->i_mapping;\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = 0;\n\tu64 end;\n\n\tatomic_inc(&BTRFS_I(fs_info->btree_inode)->sync_writers);\n\twhile (!find_first_extent_bit(dirty_pages, start, &start, &end,\n\t\t\t\t      mark, &cached_state)) {\n\t\tbool wait_writeback = false;\n\n\t\terr = convert_extent_bit(dirty_pages, start, end,\n\t\t\t\t\t EXTENT_NEED_WAIT,\n\t\t\t\t\t mark, &cached_state);\n\t\t/*\n\t\t * convert_extent_bit can return -ENOMEM, which is most of the\n\t\t * time a temporary error. So when it happens, ignore the error\n\t\t * and wait for writeback of this range to finish - because we\n\t\t * failed to set the bit EXTENT_NEED_WAIT for the range, a call\n\t\t * to __btrfs_wait_marked_extents() would not know that\n\t\t * writeback for this range started and therefore wouldn't\n\t\t * wait for it to finish - we don't want to commit a\n\t\t * superblock that points to btree nodes/leafs for which\n\t\t * writeback hasn't finished yet (and without errors).\n\t\t * We cleanup any entries left in the io tree when committing\n\t\t * the transaction (through extent_io_tree_release()).\n\t\t */\n\t\tif (err == -ENOMEM) {\n\t\t\terr = 0;\n\t\t\twait_writeback = true;\n\t\t}\n\t\tif (!err)\n\t\t\terr = filemap_fdatawrite_range(mapping, start, end);\n\t\tif (err)\n\t\t\twerr = err;\n\t\telse if (wait_writeback)\n\t\t\twerr = filemap_fdatawait_range(mapping, start, end);\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tcond_resched();\n\t\tstart = end + 1;\n\t}\n\tatomic_dec(&BTRFS_I(fs_info->btree_inode)->sync_writers);\n\treturn werr;\n}\n\n/*\n * when btree blocks are allocated, they have some corresponding bits set for\n * them in one of two extent_io trees.  This is used to make sure all of\n * those extents are on disk for transaction or log commit.  We wait\n * on all the pages and clear them from the dirty pages state tree\n */\nstatic int __btrfs_wait_marked_extents(struct btrfs_fs_info *fs_info,\n\t\t\t\t       struct extent_io_tree *dirty_pages)\n{\n\tint err = 0;\n\tint werr = 0;\n\tstruct address_space *mapping = fs_info->btree_inode->i_mapping;\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = 0;\n\tu64 end;\n\n\twhile (!find_first_extent_bit(dirty_pages, start, &start, &end,\n\t\t\t\t      EXTENT_NEED_WAIT, &cached_state)) {\n\t\t/*\n\t\t * Ignore -ENOMEM errors returned by clear_extent_bit().\n\t\t * When committing the transaction, we'll remove any entries\n\t\t * left in the io tree. For a log commit, we don't remove them\n\t\t * after committing the log because the tree can be accessed\n\t\t * concurrently - we do it only at transaction commit time when\n\t\t * it's safe to do it (through extent_io_tree_release()).\n\t\t */\n\t\terr = clear_extent_bit(dirty_pages, start, end,\n\t\t\t\t       EXTENT_NEED_WAIT, 0, 0, &cached_state);\n\t\tif (err == -ENOMEM)\n\t\t\terr = 0;\n\t\tif (!err)\n\t\t\terr = filemap_fdatawait_range(mapping, start, end);\n\t\tif (err)\n\t\t\twerr = err;\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tcond_resched();\n\t\tstart = end + 1;\n\t}\n\tif (err)\n\t\twerr = err;\n\treturn werr;\n}\n\nstatic int btrfs_wait_extents(struct btrfs_fs_info *fs_info,\n\t\t       struct extent_io_tree *dirty_pages)\n{\n\tbool errors = false;\n\tint err;\n\n\terr = __btrfs_wait_marked_extents(fs_info, dirty_pages);\n\tif (test_and_clear_bit(BTRFS_FS_BTREE_ERR, &fs_info->flags))\n\t\terrors = true;\n\n\tif (errors && !err)\n\t\terr = -EIO;\n\treturn err;\n}\n\nint btrfs_wait_tree_log_extents(struct btrfs_root *log_root, int mark)\n{\n\tstruct btrfs_fs_info *fs_info = log_root->fs_info;\n\tstruct extent_io_tree *dirty_pages = &log_root->dirty_log_pages;\n\tbool errors = false;\n\tint err;\n\n\tASSERT(log_root->root_key.objectid == BTRFS_TREE_LOG_OBJECTID);\n\n\terr = __btrfs_wait_marked_extents(fs_info, dirty_pages);\n\tif ((mark & EXTENT_DIRTY) &&\n\t    test_and_clear_bit(BTRFS_FS_LOG1_ERR, &fs_info->flags))\n\t\terrors = true;\n\n\tif ((mark & EXTENT_NEW) &&\n\t    test_and_clear_bit(BTRFS_FS_LOG2_ERR, &fs_info->flags))\n\t\terrors = true;\n\n\tif (errors && !err)\n\t\terr = -EIO;\n\treturn err;\n}\n\n/*\n * When btree blocks are allocated the corresponding extents are marked dirty.\n * This function ensures such extents are persisted on disk for transaction or\n * log commit.\n *\n * @trans: transaction whose dirty pages we'd like to write\n */\nstatic int btrfs_write_and_wait_transaction(struct btrfs_trans_handle *trans)\n{\n\tint ret;\n\tint ret2;\n\tstruct extent_io_tree *dirty_pages = &trans->transaction->dirty_pages;\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\tret = btrfs_write_marked_extents(fs_info, dirty_pages, EXTENT_DIRTY);\n\tblk_finish_plug(&plug);\n\tret2 = btrfs_wait_extents(fs_info, dirty_pages);\n\n\textent_io_tree_release(&trans->transaction->dirty_pages);\n\n\tif (ret)\n\t\treturn ret;\n\telse if (ret2)\n\t\treturn ret2;\n\telse\n\t\treturn 0;\n}\n\n/*\n * this is used to update the root pointer in the tree of tree roots.\n *\n * But, in the case of the extent allocation tree, updating the root\n * pointer may allocate blocks which may change the root of the extent\n * allocation tree.\n *\n * So, this loops and repeats and makes sure the cowonly root didn't\n * change while the root pointer was being updated in the metadata.\n */\nstatic int update_cowonly_root(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tint ret;\n\tu64 old_root_bytenr;\n\tu64 old_root_used;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\n\told_root_used = btrfs_root_used(&root->root_item);\n\n\twhile (1) {\n\t\told_root_bytenr = btrfs_root_bytenr(&root->root_item);\n\t\tif (old_root_bytenr == root->node->start &&\n\t\t    old_root_used == btrfs_root_used(&root->root_item))\n\t\t\tbreak;\n\n\t\tbtrfs_set_root_node(&root->root_item, root->node);\n\t\tret = btrfs_update_root(trans, tree_root,\n\t\t\t\t\t&root->root_key,\n\t\t\t\t\t&root->root_item);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\told_root_used = btrfs_root_used(&root->root_item);\n\t}\n\n\treturn 0;\n}\n\n/*\n * update all the cowonly tree roots on disk\n *\n * The error handling in this function may not be obvious. Any of the\n * failures will cause the file system to go offline. We still need\n * to clean up the delayed refs.\n */\nstatic noinline int commit_cowonly_roots(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct list_head *dirty_bgs = &trans->transaction->dirty_bgs;\n\tstruct list_head *io_bgs = &trans->transaction->io_bgs;\n\tstruct list_head *next;\n\tstruct extent_buffer *eb;\n\tint ret;\n\n\teb = btrfs_lock_root_node(fs_info->tree_root);\n\tret = btrfs_cow_block(trans, fs_info->tree_root, eb, NULL,\n\t\t\t      0, &eb, BTRFS_NESTING_COW);\n\tbtrfs_tree_unlock(eb);\n\tfree_extent_buffer(eb);\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_run_dev_stats(trans);\n\tif (ret)\n\t\treturn ret;\n\tret = btrfs_run_dev_replace(trans);\n\tif (ret)\n\t\treturn ret;\n\tret = btrfs_run_qgroups(trans);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_setup_space_cache(trans);\n\tif (ret)\n\t\treturn ret;\n\nagain:\n\twhile (!list_empty(&fs_info->dirty_cowonly_roots)) {\n\t\tstruct btrfs_root *root;\n\t\tnext = fs_info->dirty_cowonly_roots.next;\n\t\tlist_del_init(next);\n\t\troot = list_entry(next, struct btrfs_root, dirty_list);\n\t\tclear_bit(BTRFS_ROOT_DIRTY, &root->state);\n\n\t\tif (root != fs_info->extent_root)\n\t\t\tlist_add_tail(&root->dirty_list,\n\t\t\t\t      &trans->transaction->switch_commits);\n\t\tret = update_cowonly_root(trans, root);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Now flush any delayed refs generated by updating all of the roots */\n\tret = btrfs_run_delayed_refs(trans, (unsigned long)-1);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (!list_empty(dirty_bgs) || !list_empty(io_bgs)) {\n\t\tret = btrfs_write_dirty_block_groups(trans);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * We're writing the dirty block groups, which could generate\n\t\t * delayed refs, which could generate more dirty block groups,\n\t\t * so we want to keep this flushing in this loop to make sure\n\t\t * everything gets run.\n\t\t */\n\t\tret = btrfs_run_delayed_refs(trans, (unsigned long)-1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!list_empty(&fs_info->dirty_cowonly_roots))\n\t\tgoto again;\n\n\tlist_add_tail(&fs_info->extent_root->dirty_list,\n\t\t      &trans->transaction->switch_commits);\n\n\t/* Update dev-replace pointer once everything is committed */\n\tfs_info->dev_replace.committed_cursor_left =\n\t\tfs_info->dev_replace.cursor_left_last_write_of_item;\n\n\treturn 0;\n}\n\n/*\n * dead roots are old snapshots that need to be deleted.  This allocates\n * a dirty root struct and adds it into the list of dead roots that need to\n * be deleted\n */\nvoid btrfs_add_dead_root(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (list_empty(&root->root_list)) {\n\t\tbtrfs_grab_root(root);\n\t\tlist_add_tail(&root->root_list, &fs_info->dead_roots);\n\t}\n\tspin_unlock(&fs_info->trans_lock);\n}\n\n/*\n * update all the cowonly tree roots on disk\n */\nstatic noinline int commit_fs_roots(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_root *gang[8];\n\tint i;\n\tint ret;\n\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\twhile (1) {\n\t\tret = radix_tree_gang_lookup_tag(&fs_info->fs_roots_radix,\n\t\t\t\t\t\t (void **)gang, 0,\n\t\t\t\t\t\t ARRAY_SIZE(gang),\n\t\t\t\t\t\t BTRFS_ROOT_TRANS_TAG);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tstruct btrfs_root *root = gang[i];\n\t\t\tint ret2;\n\n\t\t\tradix_tree_tag_clear(&fs_info->fs_roots_radix,\n\t\t\t\t\t(unsigned long)root->root_key.objectid,\n\t\t\t\t\tBTRFS_ROOT_TRANS_TAG);\n\t\t\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\n\t\t\tbtrfs_free_log(trans, root);\n\t\t\tret2 = btrfs_update_reloc_root(trans, root);\n\t\t\tif (ret2)\n\t\t\t\treturn ret2;\n\n\t\t\t/* see comments in should_cow_block() */\n\t\t\tclear_bit(BTRFS_ROOT_FORCE_COW, &root->state);\n\t\t\tsmp_mb__after_atomic();\n\n\t\t\tif (root->commit_root != root->node) {\n\t\t\t\tlist_add_tail(&root->dirty_list,\n\t\t\t\t\t&trans->transaction->switch_commits);\n\t\t\t\tbtrfs_set_root_node(&root->root_item,\n\t\t\t\t\t\t    root->node);\n\t\t\t}\n\n\t\t\tret2 = btrfs_update_root(trans, fs_info->tree_root,\n\t\t\t\t\t\t&root->root_key,\n\t\t\t\t\t\t&root->root_item);\n\t\t\tif (ret2)\n\t\t\t\treturn ret2;\n\t\t\tspin_lock(&fs_info->fs_roots_radix_lock);\n\t\t\tbtrfs_qgroup_free_meta_all_pertrans(root);\n\t\t}\n\t}\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\treturn 0;\n}\n\n/*\n * defrag a given btree.\n * Every leaf in the btree is read and defragged.\n */\nint btrfs_defrag_root(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *info = root->fs_info;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\tif (test_and_set_bit(BTRFS_ROOT_DEFRAG_RUNNING, &root->state))\n\t\treturn 0;\n\n\twhile (1) {\n\t\ttrans = btrfs_start_transaction(root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\tret = PTR_ERR(trans);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = btrfs_defrag_leaves(trans, root);\n\n\t\tbtrfs_end_transaction(trans);\n\t\tbtrfs_btree_balance_dirty(info);\n\t\tcond_resched();\n\n\t\tif (btrfs_fs_closing(info) || ret != -EAGAIN)\n\t\t\tbreak;\n\n\t\tif (btrfs_defrag_cancelled(info)) {\n\t\t\tbtrfs_debug(info, \"defrag_root cancelled\");\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\tclear_bit(BTRFS_ROOT_DEFRAG_RUNNING, &root->state);\n\treturn ret;\n}\n\n/*\n * Do all special snapshot related qgroup dirty hack.\n *\n * Will do all needed qgroup inherit and dirty hack like switch commit\n * roots inside one transaction and write all btree into disk, to make\n * qgroup works.\n */\nstatic int qgroup_account_snapshot(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *src,\n\t\t\t\t   struct btrfs_root *parent,\n\t\t\t\t   struct btrfs_qgroup_inherit *inherit,\n\t\t\t\t   u64 dst_objectid)\n{\n\tstruct btrfs_fs_info *fs_info = src->fs_info;\n\tint ret;\n\n\t/*\n\t * Save some performance in the case that qgroups are not\n\t * enabled. If this check races with the ioctl, rescan will\n\t * kick in anyway.\n\t */\n\tif (!test_bit(BTRFS_FS_QUOTA_ENABLED, &fs_info->flags))\n\t\treturn 0;\n\n\t/*\n\t * Ensure dirty @src will be committed.  Or, after coming\n\t * commit_fs_roots() and switch_commit_roots(), any dirty but not\n\t * recorded root will never be updated again, causing an outdated root\n\t * item.\n\t */\n\tret = record_root_in_trans(trans, src, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * btrfs_qgroup_inherit relies on a consistent view of the usage for the\n\t * src root, so we must run the delayed refs here.\n\t *\n\t * However this isn't particularly fool proof, because there's no\n\t * synchronization keeping us from changing the tree after this point\n\t * before we do the qgroup_inherit, or even from making changes while\n\t * we're doing the qgroup_inherit.  But that's a problem for the future,\n\t * for now flush the delayed refs to narrow the race window where the\n\t * qgroup counters could end up wrong.\n\t */\n\tret = btrfs_run_delayed_refs(trans, (unsigned long)-1);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * We are going to commit transaction, see btrfs_commit_transaction()\n\t * comment for reason locking tree_log_mutex\n\t */\n\tmutex_lock(&fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans);\n\tif (ret)\n\t\tgoto out;\n\tret = btrfs_qgroup_account_extents(trans);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* Now qgroup are all updated, we can inherit it to new qgroups */\n\tret = btrfs_qgroup_inherit(trans, src->root_key.objectid, dst_objectid,\n\t\t\t\t   inherit);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * Now we do a simplified commit transaction, which will:\n\t * 1) commit all subvolume and extent tree\n\t *    To ensure all subvolume and extent tree have a valid\n\t *    commit_root to accounting later insert_dir_item()\n\t * 2) write all btree blocks onto disk\n\t *    This is to make sure later btree modification will be cowed\n\t *    Or commit_root can be populated and cause wrong qgroup numbers\n\t * In this simplified commit, we don't really care about other trees\n\t * like chunk and root tree, as they won't affect qgroup.\n\t * And we don't write super to avoid half committed status.\n\t */\n\tret = commit_cowonly_roots(trans);\n\tif (ret)\n\t\tgoto out;\n\tswitch_commit_roots(trans);\n\tret = btrfs_write_and_wait_transaction(trans);\n\tif (ret)\n\t\tbtrfs_handle_fs_error(fs_info, ret,\n\t\t\t\"Error while writing out transaction for qgroup\");\n\nout:\n\tmutex_unlock(&fs_info->tree_log_mutex);\n\n\t/*\n\t * Force parent root to be updated, as we recorded it before so its\n\t * last_trans == cur_transid.\n\t * Or it won't be committed again onto disk after later\n\t * insert_dir_item()\n\t */\n\tif (!ret)\n\t\tret = record_root_in_trans(trans, parent, 1);\n\treturn ret;\n}\n\n/*\n * new snapshots need to be created at a very specific time in the\n * transaction commit.  This does the actual creation.\n *\n * Note:\n * If the error which may affect the commitment of the current transaction\n * happens, we should return the error number. If the error which just affect\n * the creation of the pending snapshots, just return 0.\n */\nstatic noinline int create_pending_snapshot(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_pending_snapshot *pending)\n{\n\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_key key;\n\tstruct btrfs_root_item *new_root_item;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *root = pending->root;\n\tstruct btrfs_root *parent_root;\n\tstruct btrfs_block_rsv *rsv;\n\tstruct inode *parent_inode;\n\tstruct btrfs_path *path;\n\tstruct btrfs_dir_item *dir_item;\n\tstruct dentry *dentry;\n\tstruct extent_buffer *tmp;\n\tstruct extent_buffer *old;\n\tstruct timespec64 cur_time;\n\tint ret = 0;\n\tu64 to_reserve = 0;\n\tu64 index = 0;\n\tu64 objectid;\n\tu64 root_flags;\n\n\tASSERT(pending->path);\n\tpath = pending->path;\n\n\tASSERT(pending->root_item);\n\tnew_root_item = pending->root_item;\n\n\tpending->error = btrfs_get_free_objectid(tree_root, &objectid);\n\tif (pending->error)\n\t\tgoto no_free_objectid;\n\n\t/*\n\t * Make qgroup to skip current new snapshot's qgroupid, as it is\n\t * accounted by later btrfs_qgroup_inherit().\n\t */\n\tbtrfs_set_skip_qgroup(trans, objectid);\n\n\tbtrfs_reloc_pre_snapshot(pending, &to_reserve);\n\n\tif (to_reserve > 0) {\n\t\tpending->error = btrfs_block_rsv_add(root,\n\t\t\t\t\t\t     &pending->block_rsv,\n\t\t\t\t\t\t     to_reserve,\n\t\t\t\t\t\t     BTRFS_RESERVE_NO_FLUSH);\n\t\tif (pending->error)\n\t\t\tgoto clear_skip_qgroup;\n\t}\n\n\tkey.objectid = objectid;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\n\trsv = trans->block_rsv;\n\ttrans->block_rsv = &pending->block_rsv;\n\ttrans->bytes_reserved = trans->block_rsv->reserved;\n\ttrace_btrfs_space_reservation(fs_info, \"transaction\",\n\t\t\t\t      trans->transid,\n\t\t\t\t      trans->bytes_reserved, 1);\n\tdentry = pending->dentry;\n\tparent_inode = pending->dir;\n\tparent_root = BTRFS_I(parent_inode)->root;\n\tret = record_root_in_trans(trans, parent_root, 0);\n\tif (ret)\n\t\tgoto fail;\n\tcur_time = current_time(parent_inode);\n\n\t/*\n\t * insert the directory item\n\t */\n\tret = btrfs_set_inode_index(BTRFS_I(parent_inode), &index);\n\tBUG_ON(ret); /* -ENOMEM */\n\n\t/* check if there is a file/dir which has the same name. */\n\tdir_item = btrfs_lookup_dir_item(NULL, parent_root, path,\n\t\t\t\t\t btrfs_ino(BTRFS_I(parent_inode)),\n\t\t\t\t\t dentry->d_name.name,\n\t\t\t\t\t dentry->d_name.len, 0);\n\tif (dir_item != NULL && !IS_ERR(dir_item)) {\n\t\tpending->error = -EEXIST;\n\t\tgoto dir_item_existed;\n\t} else if (IS_ERR(dir_item)) {\n\t\tret = PTR_ERR(dir_item);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\tbtrfs_release_path(path);\n\n\t/*\n\t * pull in the delayed directory update\n\t * and the delayed inode item\n\t * otherwise we corrupt the FS during\n\t * snapshot\n\t */\n\tret = btrfs_run_delayed_items(trans);\n\tif (ret) {\t/* Transaction aborted */\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\n\tret = record_root_in_trans(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\tbtrfs_set_root_last_snapshot(&root->root_item, trans->transid);\n\tmemcpy(new_root_item, &root->root_item, sizeof(*new_root_item));\n\tbtrfs_check_and_init_root_item(new_root_item);\n\n\troot_flags = btrfs_root_flags(new_root_item);\n\tif (pending->readonly)\n\t\troot_flags |= BTRFS_ROOT_SUBVOL_RDONLY;\n\telse\n\t\troot_flags &= ~BTRFS_ROOT_SUBVOL_RDONLY;\n\tbtrfs_set_root_flags(new_root_item, root_flags);\n\n\tbtrfs_set_root_generation_v2(new_root_item,\n\t\t\ttrans->transid);\n\tgenerate_random_guid(new_root_item->uuid);\n\tmemcpy(new_root_item->parent_uuid, root->root_item.uuid,\n\t\t\tBTRFS_UUID_SIZE);\n\tif (!(root_flags & BTRFS_ROOT_SUBVOL_RDONLY)) {\n\t\tmemset(new_root_item->received_uuid, 0,\n\t\t       sizeof(new_root_item->received_uuid));\n\t\tmemset(&new_root_item->stime, 0, sizeof(new_root_item->stime));\n\t\tmemset(&new_root_item->rtime, 0, sizeof(new_root_item->rtime));\n\t\tbtrfs_set_root_stransid(new_root_item, 0);\n\t\tbtrfs_set_root_rtransid(new_root_item, 0);\n\t}\n\tbtrfs_set_stack_timespec_sec(&new_root_item->otime, cur_time.tv_sec);\n\tbtrfs_set_stack_timespec_nsec(&new_root_item->otime, cur_time.tv_nsec);\n\tbtrfs_set_root_otransid(new_root_item, trans->transid);\n\n\told = btrfs_lock_root_node(root);\n\tret = btrfs_cow_block(trans, root, old, NULL, 0, &old,\n\t\t\t      BTRFS_NESTING_COW);\n\tif (ret) {\n\t\tbtrfs_tree_unlock(old);\n\t\tfree_extent_buffer(old);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_copy_root(trans, root, old, &tmp, objectid);\n\t/* clean up in any case */\n\tbtrfs_tree_unlock(old);\n\tfree_extent_buffer(old);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\t/* see comments in should_cow_block() */\n\tset_bit(BTRFS_ROOT_FORCE_COW, &root->state);\n\tsmp_wmb();\n\n\tbtrfs_set_root_node(new_root_item, tmp);\n\t/* record when the snapshot was created in key.offset */\n\tkey.offset = trans->transid;\n\tret = btrfs_insert_root(trans, tree_root, &key, new_root_item);\n\tbtrfs_tree_unlock(tmp);\n\tfree_extent_buffer(tmp);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * insert root back/forward references\n\t */\n\tret = btrfs_add_root_ref(trans, objectid,\n\t\t\t\t parent_root->root_key.objectid,\n\t\t\t\t btrfs_ino(BTRFS_I(parent_inode)), index,\n\t\t\t\t dentry->d_name.name, dentry->d_name.len);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\n\tkey.offset = (u64)-1;\n\tpending->snap = btrfs_get_new_fs_root(fs_info, objectid, pending->anon_dev);\n\tif (IS_ERR(pending->snap)) {\n\t\tret = PTR_ERR(pending->snap);\n\t\tpending->snap = NULL;\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_reloc_post_snapshot(trans, pending);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * Do special qgroup accounting for snapshot, as we do some qgroup\n\t * snapshot hack to do fast snapshot.\n\t * To co-operate with that hack, we do hack again.\n\t * Or snapshot will be greatly slowed down by a subtree qgroup rescan\n\t */\n\tret = qgroup_account_snapshot(trans, root, parent_root,\n\t\t\t\t      pending->inherit, objectid);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = btrfs_insert_dir_item(trans, dentry->d_name.name,\n\t\t\t\t    dentry->d_name.len, BTRFS_I(parent_inode),\n\t\t\t\t    &key, BTRFS_FT_DIR, index);\n\t/* We have check then name at the beginning, so it is impossible. */\n\tBUG_ON(ret == -EEXIST || ret == -EOVERFLOW);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\n\tbtrfs_i_size_write(BTRFS_I(parent_inode), parent_inode->i_size +\n\t\t\t\t\t dentry->d_name.len * 2);\n\tparent_inode->i_mtime = parent_inode->i_ctime =\n\t\tcurrent_time(parent_inode);\n\tret = btrfs_update_inode_fallback(trans, parent_root, BTRFS_I(parent_inode));\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\tret = btrfs_uuid_tree_add(trans, new_root_item->uuid,\n\t\t\t\t  BTRFS_UUID_KEY_SUBVOL,\n\t\t\t\t  objectid);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tgoto fail;\n\t}\n\tif (!btrfs_is_empty_uuid(new_root_item->received_uuid)) {\n\t\tret = btrfs_uuid_tree_add(trans, new_root_item->received_uuid,\n\t\t\t\t\t  BTRFS_UUID_KEY_RECEIVED_SUBVOL,\n\t\t\t\t\t  objectid);\n\t\tif (ret && ret != -EEXIST) {\n\t\t\tbtrfs_abort_transaction(trans, ret);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\nfail:\n\tpending->error = ret;\ndir_item_existed:\n\ttrans->block_rsv = rsv;\n\ttrans->bytes_reserved = 0;\nclear_skip_qgroup:\n\tbtrfs_clear_skip_qgroup(trans);\nno_free_objectid:\n\tkfree(new_root_item);\n\tpending->root_item = NULL;\n\tbtrfs_free_path(path);\n\tpending->path = NULL;\n\n\treturn ret;\n}\n\n/*\n * create all the snapshots we've scheduled for creation\n */\nstatic noinline int create_pending_snapshots(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_pending_snapshot *pending, *next;\n\tstruct list_head *head = &trans->transaction->pending_snapshots;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(pending, next, head, list) {\n\t\tlist_del(&pending->list);\n\t\tret = create_pending_snapshot(trans, pending);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic void update_super_roots(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_super_block *super;\n\n\tsuper = fs_info->super_copy;\n\n\troot_item = &fs_info->chunk_root->root_item;\n\tsuper->chunk_root = root_item->bytenr;\n\tsuper->chunk_root_generation = root_item->generation;\n\tsuper->chunk_root_level = root_item->level;\n\n\troot_item = &fs_info->tree_root->root_item;\n\tsuper->root = root_item->bytenr;\n\tsuper->generation = root_item->generation;\n\tsuper->root_level = root_item->level;\n\tif (btrfs_test_opt(fs_info, SPACE_CACHE))\n\t\tsuper->cache_generation = root_item->generation;\n\telse if (test_bit(BTRFS_FS_CLEANUP_SPACE_CACHE_V1, &fs_info->flags))\n\t\tsuper->cache_generation = 0;\n\tif (test_bit(BTRFS_FS_UPDATE_UUID_TREE_GEN, &fs_info->flags))\n\t\tsuper->uuid_tree_generation = root_item->generation;\n}\n\nint btrfs_transaction_in_commit(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_transaction *trans;\n\tint ret = 0;\n\n\tspin_lock(&info->trans_lock);\n\ttrans = info->running_transaction;\n\tif (trans)\n\t\tret = (trans->state >= TRANS_STATE_COMMIT_START);\n\tspin_unlock(&info->trans_lock);\n\treturn ret;\n}\n\nint btrfs_transaction_blocked(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_transaction *trans;\n\tint ret = 0;\n\n\tspin_lock(&info->trans_lock);\n\ttrans = info->running_transaction;\n\tif (trans)\n\t\tret = is_transaction_blocked(trans);\n\tspin_unlock(&info->trans_lock);\n\treturn ret;\n}\n\n/*\n * commit transactions asynchronously. once btrfs_commit_transaction_async\n * returns, any subsequent transaction will not be allowed to join.\n */\nstruct btrfs_async_commit {\n\tstruct btrfs_trans_handle *newtrans;\n\tstruct work_struct work;\n};\n\nstatic void do_async_commit(struct work_struct *work)\n{\n\tstruct btrfs_async_commit *ac =\n\t\tcontainer_of(work, struct btrfs_async_commit, work);\n\n\t/*\n\t * We've got freeze protection passed with the transaction.\n\t * Tell lockdep about it.\n\t */\n\tif (ac->newtrans->type & __TRANS_FREEZABLE)\n\t\t__sb_writers_acquired(ac->newtrans->fs_info->sb, SB_FREEZE_FS);\n\n\tcurrent->journal_info = ac->newtrans;\n\n\tbtrfs_commit_transaction(ac->newtrans);\n\tkfree(ac);\n}\n\nint btrfs_commit_transaction_async(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_async_commit *ac;\n\tstruct btrfs_transaction *cur_trans;\n\n\tac = kmalloc(sizeof(*ac), GFP_NOFS);\n\tif (!ac)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&ac->work, do_async_commit);\n\tac->newtrans = btrfs_join_transaction(trans->root);\n\tif (IS_ERR(ac->newtrans)) {\n\t\tint err = PTR_ERR(ac->newtrans);\n\t\tkfree(ac);\n\t\treturn err;\n\t}\n\n\t/* take transaction reference */\n\tcur_trans = trans->transaction;\n\trefcount_inc(&cur_trans->use_count);\n\n\tbtrfs_end_transaction(trans);\n\n\t/*\n\t * Tell lockdep we've released the freeze rwsem, since the\n\t * async commit thread will be the one to unlock it.\n\t */\n\tif (ac->newtrans->type & __TRANS_FREEZABLE)\n\t\t__sb_writers_release(fs_info->sb, SB_FREEZE_FS);\n\n\tschedule_work(&ac->work);\n\t/*\n\t * Wait for the current transaction commit to start and block\n\t * subsequent transaction joins\n\t */\n\twait_event(fs_info->transaction_blocked_wait,\n\t\t   cur_trans->state >= TRANS_STATE_COMMIT_START ||\n\t\t   TRANS_ABORTED(cur_trans));\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tbtrfs_put_transaction(cur_trans);\n\treturn 0;\n}\n\n\nstatic void cleanup_transaction(struct btrfs_trans_handle *trans, int err)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\n\tWARN_ON(refcount_read(&trans->use_count) > 1);\n\n\tbtrfs_abort_transaction(trans, err);\n\n\tspin_lock(&fs_info->trans_lock);\n\n\t/*\n\t * If the transaction is removed from the list, it means this\n\t * transaction has been committed successfully, so it is impossible\n\t * to call the cleanup function.\n\t */\n\tBUG_ON(list_empty(&cur_trans->list));\n\n\tif (cur_trans == fs_info->running_transaction) {\n\t\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\twait_event(cur_trans->writer_wait,\n\t\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t\tspin_lock(&fs_info->trans_lock);\n\t}\n\n\t/*\n\t * Now that we know no one else is still using the transaction we can\n\t * remove the transaction from the list of transactions. This avoids\n\t * the transaction kthread from cleaning up the transaction while some\n\t * other task is still using it, which could result in a use-after-free\n\t * on things like log trees, as it forces the transaction kthread to\n\t * wait for this transaction to be cleaned up by us.\n\t */\n\tlist_del_init(&cur_trans->list);\n\n\tspin_unlock(&fs_info->trans_lock);\n\n\tbtrfs_cleanup_one_transaction(trans->transaction, fs_info);\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (cur_trans == fs_info->running_transaction)\n\t\tfs_info->running_transaction = NULL;\n\tspin_unlock(&fs_info->trans_lock);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(fs_info->sb);\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\ttrace_btrfs_transaction_commit(trans->root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tbtrfs_scrub_cancel(fs_info);\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n}\n\n/*\n * Release reserved delayed ref space of all pending block groups of the\n * transaction and remove them from the list\n */\nstatic void btrfs_cleanup_pending_block_groups(struct btrfs_trans_handle *trans)\n{\n       struct btrfs_fs_info *fs_info = trans->fs_info;\n       struct btrfs_block_group *block_group, *tmp;\n\n       list_for_each_entry_safe(block_group, tmp, &trans->new_bgs, bg_list) {\n               btrfs_delayed_refs_rsv_release(fs_info, 1);\n               list_del_init(&block_group->bg_list);\n       }\n}\n\nstatic inline int btrfs_start_delalloc_flush(struct btrfs_fs_info *fs_info)\n{\n\t/*\n\t * We use writeback_inodes_sb here because if we used\n\t * btrfs_start_delalloc_roots we would deadlock with fs freeze.\n\t * Currently are holding the fs freeze lock, if we do an async flush\n\t * we'll do btrfs_join_transaction() and deadlock because we need to\n\t * wait for the fs freeze lock.  Using the direct flushing we benefit\n\t * from already being in a transaction and our join_transaction doesn't\n\t * have to re-take the fs freeze lock.\n\t */\n\tif (btrfs_test_opt(fs_info, FLUSHONCOMMIT))\n\t\twriteback_inodes_sb(fs_info->sb, WB_REASON_SYNC);\n\treturn 0;\n}\n\nstatic inline void btrfs_wait_delalloc_flush(struct btrfs_fs_info *fs_info)\n{\n\tif (btrfs_test_opt(fs_info, FLUSHONCOMMIT))\n\t\tbtrfs_wait_ordered_roots(fs_info, U64_MAX, 0, (u64)-1);\n}\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tint ret;\n\n\tASSERT(refcount_read(&trans->use_count) == 1);\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (TRANS_ABORTED(cur_trans)) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans);\n\ttrans->block_rsv = NULL;\n\n\t/*\n\t * We only want one transaction commit doing the flushing so we do not\n\t * waste a bunch of time on lock contention on the extent root node.\n\t */\n\tif (!test_and_set_bit(BTRFS_DELAYED_REFS_FLUSHING,\n\t\t\t      &cur_trans->delayed_refs.flags)) {\n\t\t/*\n\t\t * Make a pass through all the delayed refs we have so far.\n\t\t * Any running threads may add more while we are here.\n\t\t */\n\t\tret = btrfs_run_delayed_refs(trans, 0);\n\t\tif (ret) {\n\t\t\tbtrfs_end_transaction(trans);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tbtrfs_create_pending_block_groups(trans);\n\n\tif (!test_bit(BTRFS_TRANS_DIRTY_BG_RUN, &cur_trans->flags)) {\n\t\tint run_it = 0;\n\n\t\t/* this mutex is also taken before trying to set\n\t\t * block groups readonly.  We need to make sure\n\t\t * that nobody has set a block group readonly\n\t\t * after a extents from that block group have been\n\t\t * allocated for cache files.  btrfs_set_block_group_ro\n\t\t * will wait for the transaction to commit if it\n\t\t * finds BTRFS_TRANS_DIRTY_BG_RUN set.\n\t\t *\n\t\t * The BTRFS_TRANS_DIRTY_BG_RUN flag is also used to make sure\n\t\t * only one process starts all the block group IO.  It wouldn't\n\t\t * hurt to have more than one go through, but there's no\n\t\t * real advantage to it either.\n\t\t */\n\t\tmutex_lock(&fs_info->ro_block_group_mutex);\n\t\tif (!test_and_set_bit(BTRFS_TRANS_DIRTY_BG_RUN,\n\t\t\t\t      &cur_trans->flags))\n\t\t\trun_it = 1;\n\t\tmutex_unlock(&fs_info->ro_block_group_mutex);\n\n\t\tif (run_it) {\n\t\t\tret = btrfs_start_dirty_block_groups(trans);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_end_transaction(trans);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tenum btrfs_trans_state want_state = TRANS_STATE_COMPLETED;\n\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\trefcount_inc(&cur_trans->use_count);\n\n\t\tif (trans->in_fsync)\n\t\t\twant_state = TRANS_STATE_SUPER_COMMITTED;\n\t\tret = btrfs_end_transaction(trans);\n\t\twait_for_commit(cur_trans, want_state);\n\n\t\tif (TRANS_ABORTED(cur_trans))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &fs_info->trans_list) {\n\t\tenum btrfs_trans_state want_state = TRANS_STATE_COMPLETED;\n\n\t\tif (trans->in_fsync)\n\t\t\twant_state = TRANS_STATE_SUPER_COMMITTED;\n\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state < want_state) {\n\t\t\trefcount_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\n\t\t\twait_for_commit(prev_trans, want_state);\n\n\t\t\tret = READ_ONCE(prev_trans->aborted);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup_transaction;\n\t\t} else {\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\t/*\n\t\t * The previous transaction was aborted and was already removed\n\t\t * from the list of transactions at fs_info->trans_list. So we\n\t\t * abort to prevent writing a new superblock that reflects a\n\t\t * corrupt state (pointing to trees with unwritten nodes/leafs).\n\t\t */\n\t\tif (test_bit(BTRFS_FS_STATE_TRANS_ABORTED, &fs_info->fs_state)) {\n\t\t\tret = -EROFS;\n\t\t\tgoto cleanup_transaction;\n\t\t}\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(fs_info);\n\n\t/*\n\t * Wait for all ordered extents started by a fast fsync that joined this\n\t * transaction. Otherwise if this transaction commits before the ordered\n\t * extents complete we lose logged data after a power failure.\n\t */\n\twait_event(cur_trans->pending_wait,\n\t\t   atomic_read(&cur_trans->pending_ordered) == 0);\n\n\tbtrfs_scrub_pause(fs_info);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\tif (TRANS_ABORTED(cur_trans)) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans);\n\tif (ret)\n\t\tgoto unlock_reloc;\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans);\n\tif (ret)\n\t\tgoto unlock_reloc;\n\n\tret = btrfs_run_delayed_refs(trans, (unsigned long)-1);\n\tif (ret)\n\t\tgoto unlock_reloc;\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(fs_info);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans);\n\tif (ret)\n\t\tgoto unlock_tree_log;\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, fs_info);\n\n\t/*\n\t * Since fs roots are all committed, we can get a quite accurate\n\t * new_roots. So let's do quota accounting.\n\t */\n\tret = btrfs_qgroup_account_extents(trans);\n\tif (ret < 0)\n\t\tgoto unlock_tree_log;\n\n\tret = commit_cowonly_roots(trans);\n\tif (ret)\n\t\tgoto unlock_tree_log;\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (TRANS_ABORTED(cur_trans)) {\n\t\tret = cur_trans->aborted;\n\t\tgoto unlock_tree_log;\n\t}\n\n\tcur_trans = fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&fs_info->tree_root->root_item,\n\t\t\t    fs_info->tree_root->node);\n\tlist_add_tail(&fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&fs_info->chunk_root->root_item,\n\t\t\t    fs_info->chunk_root->node);\n\tlist_add_tail(&fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(trans);\n\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tASSERT(list_empty(&cur_trans->io_bgs));\n\tupdate_super_roots(fs_info);\n\n\tbtrfs_set_super_log_root(fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(fs_info->super_copy, 0);\n\tmemcpy(fs_info->super_for_commit, fs_info->super_copy,\n\t       sizeof(*fs_info->super_copy));\n\n\tbtrfs_commit_device_sizes(cur_trans);\n\n\tclear_bit(BTRFS_FS_LOG1_ERR, &fs_info->flags);\n\tclear_bit(BTRFS_FS_LOG2_ERR, &fs_info->flags);\n\n\tbtrfs_trans_release_chunk_metadata(trans);\n\n\tspin_lock(&fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\tfs_info->running_transaction = NULL;\n\tspin_unlock(&fs_info->trans_lock);\n\tmutex_unlock(&fs_info->reloc_mutex);\n\n\twake_up(&fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans);\n\tif (ret) {\n\t\tbtrfs_handle_fs_error(fs_info, ret,\n\t\t\t\t      \"Error while writing out transaction\");\n\t\t/*\n\t\t * reloc_mutex has been unlocked, tree_log_mutex is still held\n\t\t * but we can't jump to unlock_tree_log causing double unlock\n\t\t */\n\t\tmutex_unlock(&fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * At this point, we should have written all the tree blocks allocated\n\t * in this transaction. So it's now safe to free the redirtyied extent\n\t * buffers.\n\t */\n\tbtrfs_free_redirty_list(cur_trans);\n\n\tret = write_all_supers(fs_info, 0);\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&fs_info->tree_log_mutex);\n\tif (ret)\n\t\tgoto scrub_continue;\n\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_SUPER_COMMITTED;\n\twake_up(&cur_trans->commit_wait);\n\n\tbtrfs_finish_extent_commit(trans);\n\n\tif (test_bit(BTRFS_TRANS_HAVE_FREE_BGS, &cur_trans->flags))\n\t\tbtrfs_clear_space_info_full(fs_info);\n\n\tfs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(trans->root);\n\n\tbtrfs_scrub_continue(fs_info);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\treturn ret;\n\nunlock_tree_log:\n\tmutex_unlock(&fs_info->tree_log_mutex);\nunlock_reloc:\n\tmutex_unlock(&fs_info->reloc_mutex);\nscrub_continue:\n\tbtrfs_scrub_continue(fs_info);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans);\n\tbtrfs_cleanup_pending_block_groups(trans);\n\tbtrfs_trans_release_chunk_metadata(trans);\n\ttrans->block_rsv = NULL;\n\tbtrfs_warn(fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, ret);\n\n\treturn ret;\n}\n\n/*\n * return < 0 if error\n * 0 if there are no more dead_roots at the time of call\n * 1 there are more to be processed, call me again\n *\n * The return value indicates there are certainly more snapshots to delete, but\n * if there comes a new one during processing, it may return 0. We don't mind,\n * because btrfs_commit_super will poke cleaner thread and it will process it a\n * few seconds later.\n */\nint btrfs_clean_one_deleted_snapshot(struct btrfs_root *root)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tspin_lock(&fs_info->trans_lock);\n\tif (list_empty(&fs_info->dead_roots)) {\n\t\tspin_unlock(&fs_info->trans_lock);\n\t\treturn 0;\n\t}\n\troot = list_first_entry(&fs_info->dead_roots,\n\t\t\tstruct btrfs_root, root_list);\n\tlist_del_init(&root->root_list);\n\tspin_unlock(&fs_info->trans_lock);\n\n\tbtrfs_debug(fs_info, \"cleaner removing %llu\", root->root_key.objectid);\n\n\tbtrfs_kill_all_delayed_nodes(root);\n\n\tif (btrfs_header_backref_rev(root->node) <\n\t\t\tBTRFS_MIXED_BACKREF_REV)\n\t\tret = btrfs_drop_snapshot(root, 0, 0);\n\telse\n\t\tret = btrfs_drop_snapshot(root, 1, 0);\n\n\tbtrfs_put_root(root);\n\treturn (ret < 0) ? 0 : 1;\n}\n\nvoid btrfs_apply_pending_changes(struct btrfs_fs_info *fs_info)\n{\n\tunsigned long prev;\n\tunsigned long bit;\n\n\tprev = xchg(&fs_info->pending_changes, 0);\n\tif (!prev)\n\t\treturn;\n\n\tbit = 1 << BTRFS_PENDING_COMMIT;\n\tif (prev & bit)\n\t\tbtrfs_debug(fs_info, \"pending commit done\");\n\tprev &= ~bit;\n\n\tif (prev)\n\t\tbtrfs_warn(fs_info,\n\t\t\t\"unknown pending changes left 0x%lx, ignoring\", prev);\n}\n", "/* SPDX-License-Identifier: GPL-2.0 */\n/*\n * Copyright (C) 2007 Oracle.  All rights reserved.\n */\n\n#ifndef BTRFS_TRANSACTION_H\n#define BTRFS_TRANSACTION_H\n\n#include <linux/refcount.h>\n#include \"btrfs_inode.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n\nenum btrfs_trans_state {\n\tTRANS_STATE_RUNNING,\n\tTRANS_STATE_COMMIT_START,\n\tTRANS_STATE_COMMIT_DOING,\n\tTRANS_STATE_UNBLOCKED,\n\tTRANS_STATE_SUPER_COMMITTED,\n\tTRANS_STATE_COMPLETED,\n\tTRANS_STATE_MAX,\n};\n\n#define BTRFS_TRANS_HAVE_FREE_BGS\t0\n#define BTRFS_TRANS_DIRTY_BG_RUN\t1\n#define BTRFS_TRANS_CACHE_ENOSPC\t2\n\nstruct btrfs_transaction {\n\tu64 transid;\n\t/*\n\t * total external writers(USERSPACE/START/ATTACH) in this\n\t * transaction, it must be zero before the transaction is\n\t * being committed\n\t */\n\tatomic_t num_extwriters;\n\t/*\n\t * total writers in this transaction, it must be zero before the\n\t * transaction can end\n\t */\n\tatomic_t num_writers;\n\trefcount_t use_count;\n\n\tunsigned long flags;\n\n\t/* Be protected by fs_info->trans_lock when we want to change it. */\n\tenum btrfs_trans_state state;\n\tint aborted;\n\tstruct list_head list;\n\tstruct extent_io_tree dirty_pages;\n\ttime64_t start_time;\n\twait_queue_head_t writer_wait;\n\twait_queue_head_t commit_wait;\n\tstruct list_head pending_snapshots;\n\tstruct list_head dev_update_list;\n\tstruct list_head switch_commits;\n\tstruct list_head dirty_bgs;\n\n\t/*\n\t * There is no explicit lock which protects io_bgs, rather its\n\t * consistency is implied by the fact that all the sites which modify\n\t * it do so under some form of transaction critical section, namely:\n\t *\n\t * - btrfs_start_dirty_block_groups - This function can only ever be\n\t *   run by one of the transaction committers. Refer to\n\t *   BTRFS_TRANS_DIRTY_BG_RUN usage in btrfs_commit_transaction\n\t *\n\t * - btrfs_write_dirty_blockgroups - this is called by\n\t *   commit_cowonly_roots from transaction critical section\n\t *   (TRANS_STATE_COMMIT_DOING)\n\t *\n\t * - btrfs_cleanup_dirty_bgs - called on transaction abort\n\t */\n\tstruct list_head io_bgs;\n\tstruct list_head dropped_roots;\n\tstruct extent_io_tree pinned_extents;\n\n\t/*\n\t * we need to make sure block group deletion doesn't race with\n\t * free space cache writeout.  This mutex keeps them from stomping\n\t * on each other\n\t */\n\tstruct mutex cache_write_mutex;\n\tspinlock_t dirty_bgs_lock;\n\t/* Protected by spin lock fs_info->unused_bgs_lock. */\n\tstruct list_head deleted_bgs;\n\tspinlock_t dropped_roots_lock;\n\tstruct btrfs_delayed_ref_root delayed_refs;\n\tstruct btrfs_fs_info *fs_info;\n\n\t/*\n\t * Number of ordered extents the transaction must wait for before\n\t * committing. These are ordered extents started by a fast fsync.\n\t */\n\tatomic_t pending_ordered;\n\twait_queue_head_t pending_wait;\n\n\tspinlock_t releasing_ebs_lock;\n\tstruct list_head releasing_ebs;\n};\n\n#define __TRANS_FREEZABLE\t(1U << 0)\n\n#define __TRANS_START\t\t(1U << 9)\n#define __TRANS_ATTACH\t\t(1U << 10)\n#define __TRANS_JOIN\t\t(1U << 11)\n#define __TRANS_JOIN_NOLOCK\t(1U << 12)\n#define __TRANS_DUMMY\t\t(1U << 13)\n#define __TRANS_JOIN_NOSTART\t(1U << 14)\n\n#define TRANS_START\t\t(__TRANS_START | __TRANS_FREEZABLE)\n#define TRANS_ATTACH\t\t(__TRANS_ATTACH)\n#define TRANS_JOIN\t\t(__TRANS_JOIN | __TRANS_FREEZABLE)\n#define TRANS_JOIN_NOLOCK\t(__TRANS_JOIN_NOLOCK)\n#define TRANS_JOIN_NOSTART\t(__TRANS_JOIN_NOSTART)\n\n#define TRANS_EXTWRITERS\t(__TRANS_START | __TRANS_ATTACH)\n\nstruct btrfs_trans_handle {\n\tu64 transid;\n\tu64 bytes_reserved;\n\tu64 chunk_bytes_reserved;\n\tunsigned long delayed_ref_updates;\n\tstruct btrfs_transaction *transaction;\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct btrfs_block_rsv *orig_rsv;\n\trefcount_t use_count;\n\tunsigned int type;\n\t/*\n\t * Error code of transaction abort, set outside of locks and must use\n\t * the READ_ONCE/WRITE_ONCE access\n\t */\n\tshort aborted;\n\tbool adding_csums;\n\tbool allocating_chunk;\n\tbool can_flush_pending_bgs;\n\tbool reloc_reserved;\n\tbool in_fsync;\n\tstruct btrfs_root *root;\n\tstruct btrfs_fs_info *fs_info;\n\tstruct list_head new_bgs;\n};\n\n/*\n * The abort status can be changed between calls and is not protected by locks.\n * This accepts btrfs_transaction and btrfs_trans_handle as types. Once it's\n * set to a non-zero value it does not change, so the macro should be in checks\n * but is not necessary for further reads of the value.\n */\n#define TRANS_ABORTED(trans)\t\t(unlikely(READ_ONCE((trans)->aborted)))\n\nstruct btrfs_pending_snapshot {\n\tstruct dentry *dentry;\n\tstruct inode *dir;\n\tstruct btrfs_root *root;\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_root *snap;\n\tstruct btrfs_qgroup_inherit *inherit;\n\tstruct btrfs_path *path;\n\t/* block reservation for the operation */\n\tstruct btrfs_block_rsv block_rsv;\n\t/* extra metadata reservation for relocation */\n\tint error;\n\t/* Preallocated anonymous block device number */\n\tdev_t anon_dev;\n\tbool readonly;\n\tstruct list_head list;\n};\n\nstatic inline void btrfs_set_inode_last_trans(struct btrfs_trans_handle *trans,\n\t\t\t\t\t      struct btrfs_inode *inode)\n{\n\tspin_lock(&inode->lock);\n\tinode->last_trans = trans->transaction->transid;\n\tinode->last_sub_trans = inode->root->log_transid;\n\tinode->last_log_commit = inode->last_sub_trans - 1;\n\tspin_unlock(&inode->lock);\n}\n\n/*\n * Make qgroup codes to skip given qgroupid, means the old/new_roots for\n * qgroup won't contain the qgroupid in it.\n */\nstatic inline void btrfs_set_skip_qgroup(struct btrfs_trans_handle *trans,\n\t\t\t\t\t u64 qgroupid)\n{\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tWARN_ON(delayed_refs->qgroup_to_skip);\n\tdelayed_refs->qgroup_to_skip = qgroupid;\n}\n\nstatic inline void btrfs_clear_skip_qgroup(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tWARN_ON(!delayed_refs->qgroup_to_skip);\n\tdelayed_refs->qgroup_to_skip = 0;\n}\n\nint btrfs_end_transaction(struct btrfs_trans_handle *trans);\nstruct btrfs_trans_handle *btrfs_start_transaction(struct btrfs_root *root,\n\t\t\t\t\t\t   unsigned int num_items);\nstruct btrfs_trans_handle *btrfs_start_transaction_fallback_global_rsv(\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tunsigned int num_items);\nstruct btrfs_trans_handle *btrfs_join_transaction(struct btrfs_root *root);\nstruct btrfs_trans_handle *btrfs_join_transaction_spacecache(struct btrfs_root *root);\nstruct btrfs_trans_handle *btrfs_join_transaction_nostart(struct btrfs_root *root);\nstruct btrfs_trans_handle *btrfs_attach_transaction(struct btrfs_root *root);\nstruct btrfs_trans_handle *btrfs_attach_transaction_barrier(\n\t\t\t\t\tstruct btrfs_root *root);\nint btrfs_wait_for_commit(struct btrfs_fs_info *fs_info, u64 transid);\n\nvoid btrfs_add_dead_root(struct btrfs_root *root);\nint btrfs_defrag_root(struct btrfs_root *root);\nint btrfs_clean_one_deleted_snapshot(struct btrfs_root *root);\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans);\nint btrfs_commit_transaction_async(struct btrfs_trans_handle *trans);\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans);\nbool btrfs_should_end_transaction(struct btrfs_trans_handle *trans);\nvoid btrfs_throttle(struct btrfs_fs_info *fs_info);\nint btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root);\nint btrfs_write_marked_extents(struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct extent_io_tree *dirty_pages, int mark);\nint btrfs_wait_tree_log_extents(struct btrfs_root *root, int mark);\nint btrfs_transaction_blocked(struct btrfs_fs_info *info);\nint btrfs_transaction_in_commit(struct btrfs_fs_info *info);\nvoid btrfs_put_transaction(struct btrfs_transaction *transaction);\nvoid btrfs_apply_pending_changes(struct btrfs_fs_info *fs_info);\nvoid btrfs_add_dropped_root(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root);\nvoid btrfs_trans_release_chunk_metadata(struct btrfs_trans_handle *trans);\n\n#endif\n"], "filenames": ["fs/btrfs/block-group.c", "fs/btrfs/transaction.c", "fs/btrfs/transaction.h"], "buggy_code_start_loc": [3380, 263, 99], "buggy_code_end_loc": [3484, 391, 106], "fixing_code_start_loc": [3379, 262, 98], "fixing_code_end_loc": [3427, 385, 98], "type": "CWE-667", "message": "btrfs in the Linux kernel before 5.13.4 allows attackers to cause a denial of service (deadlock) via processes that trigger allocation of new system chunks during times when there is a shortage of free space in the system space_info.", "other": {"cve": {"id": "CVE-2021-38203", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-08T20:15:07.217", "lastModified": "2022-05-03T16:04:40.443", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "btrfs in the Linux kernel before 5.13.4 allows attackers to cause a denial of service (deadlock) via processes that trigger allocation of new system chunks during times when there is a shortage of free space in the system space_info."}, {"lang": "es", "value": "btrfs en el kernel de Linux versiones anteriores a 5.13.4, permite a atacantes causar una denegaci\u00f3n de servicio (bloqueo) por medio de procesos que desencadenan la asignaci\u00f3n de nuevos trozos del sistema durante los momentos en que hay una escasez de espacio libre en el space_info del sistema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-667"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.13.4", "matchCriteriaId": "4C85356F-2C6C-4FB9-B0CA-949711182223"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:hci_bootstrap_os:-:*:*:*:*:*:*:*", "matchCriteriaId": "1C767AA1-88B7-48F0-9F31-A89D16DCD52C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_compute_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "AD7447BC-F315-4298-A822-549942FC118B"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "A3C19813-E823-456A-B1CE-EC0684CE1953"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire:-:*:*:*:*:*:*:*", "matchCriteriaId": "A6E9EF0C-AFA8-4F7B-9FDC-1E0F7C26E737"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:element_software:-:*:*:*:*:*:*:*", "matchCriteriaId": "85DF4B3F-4BBC-42B7-B729-096934523D63"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_storage_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "02DEB4FB-A21D-4CB1-B522-EEE5093E8521"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.13.4", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/1cb3db1cf383a3c7dbda1aa0ce748b0958759947", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210902-0010/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/1cb3db1cf383a3c7dbda1aa0ce748b0958759947"}}