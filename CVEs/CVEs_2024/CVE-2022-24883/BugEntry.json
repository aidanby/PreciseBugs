{"buggy_code": ["/**\n * WinPR: Windows Portable Runtime\n * NTLM Security Package (Compute)\n *\n * Copyright 2011-2014 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <winpr/config.h>\n\n#include <winpr/assert.h>\n\n#include \"ntlm.h\"\n#include \"../sspi.h\"\n\n#include <winpr/crt.h>\n#include <winpr/sam.h>\n#include <winpr/ntlm.h>\n#include <winpr/print.h>\n#include <winpr/crypto.h>\n#include <winpr/sysinfo.h>\n\n#include \"ntlm_compute.h\"\n\n#include \"../../log.h\"\n#define TAG WINPR_TAG(\"sspi.NTLM\")\n\nstatic char NTLM_CLIENT_SIGN_MAGIC[] = \"session key to client-to-server signing key magic constant\";\nstatic char NTLM_SERVER_SIGN_MAGIC[] = \"session key to server-to-client signing key magic constant\";\nstatic char NTLM_CLIENT_SEAL_MAGIC[] = \"session key to client-to-server sealing key magic constant\";\nstatic char NTLM_SERVER_SEAL_MAGIC[] = \"session key to server-to-client sealing key magic constant\";\n\nstatic const BYTE NTLM_NULL_BUFFER[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t                                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\n/**\n * Populate VERSION structure.\n * VERSION @msdn{cc236654}\n * @param s\n */\n\nBOOL ntlm_get_version_info(NTLM_VERSION_INFO* versionInfo)\n{\n\tOSVERSIONINFOA osVersionInfo = { 0 };\n\n\tWINPR_ASSERT(versionInfo);\n\n\tosVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);\n\tif (!GetVersionExA(&osVersionInfo))\n\t\treturn FALSE;\n\tversionInfo->ProductMajorVersion = (UINT8)osVersionInfo.dwMajorVersion;\n\tversionInfo->ProductMinorVersion = (UINT8)osVersionInfo.dwMinorVersion;\n\tversionInfo->ProductBuild = (UINT16)osVersionInfo.dwBuildNumber;\n\tZeroMemory(versionInfo->Reserved, sizeof(versionInfo->Reserved));\n\tversionInfo->NTLMRevisionCurrent = NTLMSSP_REVISION_W2K3;\n\treturn TRUE;\n}\n\n/**\n * Read VERSION structure.\n * VERSION @msdn{cc236654}\n * @param s\n */\n\nBOOL ntlm_read_version_info(wStream* s, NTLM_VERSION_INFO* versionInfo)\n{\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(versionInfo);\n\n\tif (!Stream_CheckAndLogRequiredLength(TAG, s, 8))\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, versionInfo->ProductMajorVersion); /* ProductMajorVersion (1 byte) */\n\tStream_Read_UINT8(s, versionInfo->ProductMinorVersion); /* ProductMinorVersion (1 byte) */\n\tStream_Read_UINT16(s, versionInfo->ProductBuild);       /* ProductBuild (2 bytes) */\n\tStream_Read(s, versionInfo->Reserved, sizeof(versionInfo->Reserved)); /* Reserved (3 bytes) */\n\tStream_Read_UINT8(s, versionInfo->NTLMRevisionCurrent); /* NTLMRevisionCurrent (1 byte) */\n\treturn TRUE;\n}\n\n/**\n * Write VERSION structure.\n * VERSION @msdn{cc236654}\n * @param s\n */\n\nBOOL ntlm_write_version_info(wStream* s, const NTLM_VERSION_INFO* versionInfo)\n{\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(versionInfo);\n\n\tif (Stream_GetRemainingCapacity(s) < 5 + sizeof(versionInfo->Reserved))\n\t{\n\t\tWLog_ERR(TAG, \"NTLM_VERSION_INFO short header %\" PRIuz \", expected %\" PRIuz,\n\t\t         Stream_GetRemainingCapacity(s), 5 + sizeof(versionInfo->Reserved));\n\t\treturn FALSE;\n\t}\n\n\tStream_Write_UINT8(s, versionInfo->ProductMajorVersion); /* ProductMajorVersion (1 byte) */\n\tStream_Write_UINT8(s, versionInfo->ProductMinorVersion); /* ProductMinorVersion (1 byte) */\n\tStream_Write_UINT16(s, versionInfo->ProductBuild);       /* ProductBuild (2 bytes) */\n\tStream_Write(s, versionInfo->Reserved, sizeof(versionInfo->Reserved)); /* Reserved (3 bytes) */\n\tStream_Write_UINT8(s, versionInfo->NTLMRevisionCurrent); /* NTLMRevisionCurrent (1 byte) */\n\treturn TRUE;\n}\n\n/**\n * Print VERSION structure.\n * VERSION @msdn{cc236654}\n * @param s\n */\n#ifdef WITH_DEBUG_NTLM\nvoid ntlm_print_version_info(const NTLM_VERSION_INFO* versionInfo)\n{\n\tWINPR_ASSERT(versionInfo);\n\n\tWLog_VRB(TAG, \"VERSION ={\");\n\tWLog_VRB(TAG, \"\\tProductMajorVersion: %\" PRIu8 \"\", versionInfo->ProductMajorVersion);\n\tWLog_VRB(TAG, \"\\tProductMinorVersion: %\" PRIu8 \"\", versionInfo->ProductMinorVersion);\n\tWLog_VRB(TAG, \"\\tProductBuild: %\" PRIu16 \"\", versionInfo->ProductBuild);\n\tWLog_VRB(TAG, \"\\tReserved: 0x%02\" PRIX8 \"%02\" PRIX8 \"%02\" PRIX8 \"\", versionInfo->Reserved[0],\n\t         versionInfo->Reserved[1], versionInfo->Reserved[2]);\n\tWLog_VRB(TAG, \"\\tNTLMRevisionCurrent: 0x%02\" PRIX8 \"\", versionInfo->NTLMRevisionCurrent);\n}\n#endif\n\nstatic BOOL ntlm_read_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge)\n{\n\tsize_t size;\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(challenge);\n\n\tif (!Stream_CheckAndLogRequiredLength(TAG, s, 28))\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, challenge->RespType);\n\tStream_Read_UINT8(s, challenge->HiRespType);\n\tStream_Read_UINT16(s, challenge->Reserved1);\n\tStream_Read_UINT32(s, challenge->Reserved2);\n\tStream_Read(s, challenge->Timestamp, 8);\n\tStream_Read(s, challenge->ClientChallenge, 8);\n\tStream_Read_UINT32(s, challenge->Reserved3);\n\tsize = Stream_Length(s) - Stream_GetPosition(s);\n\n\tif (size > UINT32_MAX)\n\t{\n\t\tWLog_ERR(TAG, \"NTLMv2_CLIENT_CHALLENGE::cbAvPairs too large, got %\" PRIuz \"bytes\", size);\n\t\treturn FALSE;\n\t}\n\n\tchallenge->cbAvPairs = (UINT32)size;\n\tchallenge->AvPairs = (NTLM_AV_PAIR*)malloc(challenge->cbAvPairs);\n\n\tif (!challenge->AvPairs)\n\t{\n\t\tWLog_ERR(TAG, \"NTLMv2_CLIENT_CHALLENGE::AvPairs failed to allocate %\" PRIu32 \"bytes\",\n\t\t         challenge->cbAvPairs);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read(s, challenge->AvPairs, size);\n\treturn TRUE;\n}\n\nstatic BOOL ntlm_write_ntlm_v2_client_challenge(wStream* s,\n                                                const NTLMv2_CLIENT_CHALLENGE* challenge)\n{\n\tULONG length;\n\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(challenge);\n\n\tif (Stream_GetRemainingCapacity(s) < 28)\n\t{\n\t\tWLog_ERR(TAG, \"NTLMv2_CLIENT_CHALLENGE expected 28bytes, have %\" PRIuz \"bytes\",\n\t\t         Stream_GetRemainingCapacity(s));\n\t\treturn FALSE;\n\t}\n\tStream_Write_UINT8(s, challenge->RespType);\n\tStream_Write_UINT8(s, challenge->HiRespType);\n\tStream_Write_UINT16(s, challenge->Reserved1);\n\tStream_Write_UINT32(s, challenge->Reserved2);\n\tStream_Write(s, challenge->Timestamp, 8);\n\tStream_Write(s, challenge->ClientChallenge, 8);\n\tStream_Write_UINT32(s, challenge->Reserved3);\n\tlength = ntlm_av_pair_list_length(challenge->AvPairs, challenge->cbAvPairs);\n\n\tif (!Stream_CheckAndLogRequiredLength(TAG, s, length))\n\t\treturn FALSE;\n\n\tStream_Write(s, challenge->AvPairs, length);\n\treturn TRUE;\n}\n\nBOOL ntlm_read_ntlm_v2_response(wStream* s, NTLMv2_RESPONSE* response)\n{\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(response);\n\n\tif (!Stream_CheckAndLogRequiredLength(TAG, s, 16))\n\t\treturn FALSE;\n\n\tStream_Read(s, response->Response, 16);\n\treturn ntlm_read_ntlm_v2_client_challenge(s, &(response->Challenge));\n}\n\nBOOL ntlm_write_ntlm_v2_response(wStream* s, const NTLMv2_RESPONSE* response)\n{\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(response);\n\n\tif (Stream_GetRemainingCapacity(s) < 16)\n\t{\n\t\tWLog_ERR(TAG, \"NTLMv2_RESPONSE expected 16bytes, have %\" PRIuz \"bytes\",\n\t\t         Stream_GetRemainingCapacity(s));\n\t\treturn FALSE;\n\t}\n\tStream_Write(s, response->Response, 16);\n\treturn ntlm_write_ntlm_v2_client_challenge(s, &(response->Challenge));\n}\n\n/**\n * Get current time, in tenths of microseconds since midnight of January 1, 1601.\n * @param[out] timestamp 64-bit little-endian timestamp\n */\n\nvoid ntlm_current_time(BYTE* timestamp)\n{\n\tFILETIME filetime = { 0 };\n\tULARGE_INTEGER time64 = { 0 };\n\n\tWINPR_ASSERT(timestamp);\n\n\tGetSystemTimeAsFileTime(&filetime);\n\ttime64.u.LowPart = filetime.dwLowDateTime;\n\ttime64.u.HighPart = filetime.dwHighDateTime;\n\tCopyMemory(timestamp, &(time64.QuadPart), 8);\n}\n\n/**\n * Generate timestamp for AUTHENTICATE_MESSAGE.\n * @param NTLM context\n */\n\nvoid ntlm_generate_timestamp(NTLM_CONTEXT* context)\n{\n\tWINPR_ASSERT(context);\n\n\tif (memcmp(context->ChallengeTimestamp, NTLM_NULL_BUFFER, 8) != 0)\n\t\tCopyMemory(context->Timestamp, context->ChallengeTimestamp, 8);\n\telse\n\t\tntlm_current_time(context->Timestamp);\n}\n\nstatic int ntlm_fetch_ntlm_v2_hash(NTLM_CONTEXT* context, BYTE* hash)\n{\n\tWINPR_SAM* sam;\n\tWINPR_SAM_ENTRY* entry;\n\tSSPI_CREDENTIALS* credentials;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(hash);\n\n\tcredentials = context->credentials;\n\tsam = SamOpen(context->SamFile, TRUE);\n\n\tif (!sam)\n\t\treturn -1;\n\n\tentry = SamLookupUserW(\n\t    sam, (LPWSTR)credentials->identity.User, credentials->identity.UserLength * 2,\n\t    (LPWSTR)credentials->identity.Domain, credentials->identity.DomainLength * 2);\n\n\tif (entry)\n\t{\n#ifdef WITH_DEBUG_NTLM\n\t\tWLog_VRB(TAG, \"NTLM Hash:\");\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, entry->NtHash, 16);\n#endif\n\t\tNTOWFv2FromHashW(entry->NtHash, (LPWSTR)credentials->identity.User,\n\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,\n\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);\n\t\tSamFreeEntry(sam, entry);\n\t\tSamClose(sam);\n\t\treturn 1;\n\t}\n\n\tentry = SamLookupUserW(sam, (LPWSTR)credentials->identity.User,\n\t                       credentials->identity.UserLength * 2, NULL, 0);\n\n\tif (entry)\n\t{\n#ifdef WITH_DEBUG_NTLM\n\t\tWLog_VRB(TAG, \"NTLM Hash:\");\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, entry->NtHash, 16);\n#endif\n\t\tNTOWFv2FromHashW(entry->NtHash, (LPWSTR)credentials->identity.User,\n\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,\n\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);\n\t\tSamFreeEntry(sam, entry);\n\t\tSamClose(sam);\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\tSamClose(sam);\n\t\tWLog_ERR(TAG, \"Error: Could not find user in SAM database\");\n\t\treturn 0;\n\t}\n}\n\nstatic int ntlm_convert_password_hash(NTLM_CONTEXT* context, BYTE* hash)\n{\n\tint status;\n\tint i;\n\tchar* PasswordHash = NULL;\n\tINT64 PasswordHashLength = 0;\n\tSSPI_CREDENTIALS* credentials;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(hash);\n\n\tcredentials = context->credentials;\n\t/* Password contains a password hash of length (PasswordLength -\n\t * SSPI_CREDENTIALS_HASH_LENGTH_OFFSET) */\n\tPasswordHashLength = credentials->identity.PasswordLength - SSPI_CREDENTIALS_HASH_LENGTH_OFFSET;\n\tWINPR_ASSERT(PasswordHashLength >= 0);\n\tWINPR_ASSERT(PasswordHashLength <= INT_MAX);\n\tstatus = ConvertFromUnicode(CP_UTF8, 0, (LPCWSTR)credentials->identity.Password,\n\t                            (int)PasswordHashLength, &PasswordHash, 0, NULL, NULL);\n\n\tif (status <= 0)\n\t\treturn -1;\n\n\tCharUpperBuffA(PasswordHash, (DWORD)PasswordHashLength);\n\n\tfor (i = 0; i < 32; i += 2)\n\t{\n\t\tBYTE hn =\n\t\t    (BYTE)(PasswordHash[i] > '9' ? PasswordHash[i] - 'A' + 10 : PasswordHash[i] - '0');\n\t\tBYTE ln = (BYTE)(PasswordHash[i + 1] > '9' ? PasswordHash[i + 1] - 'A' + 10\n\t\t                                           : PasswordHash[i + 1] - '0');\n\t\thash[i / 2] = (BYTE)((hn << 4) | ln);\n\t}\n\n\tfree(PasswordHash);\n\treturn 1;\n}\n\nstatic BOOL ntlm_compute_ntlm_v2_hash(NTLM_CONTEXT* context, BYTE* hash)\n{\n\tSSPI_CREDENTIALS* credentials;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(hash);\n\n\tcredentials = context->credentials;\n#ifdef WITH_DEBUG_NTLM\n\n\tif (credentials)\n\t{\n\t\tWLog_VRB(TAG, \"Password (length = %\" PRIu32 \")\", credentials->identity.PasswordLength * 2);\n\t\twinpr_HexDump(TAG, WLOG_TRACE, (BYTE*)credentials->identity.Password,\n\t\t              credentials->identity.PasswordLength * 2);\n\t\tWLog_VRB(TAG, \"Username (length = %\" PRIu32 \")\", credentials->identity.UserLength * 2);\n\t\twinpr_HexDump(TAG, WLOG_TRACE, (BYTE*)credentials->identity.User,\n\t\t              credentials->identity.UserLength * 2);\n\t\tWLog_VRB(TAG, \"Domain (length = %\" PRIu32 \")\", credentials->identity.DomainLength * 2);\n\t\twinpr_HexDump(TAG, WLOG_TRACE, (BYTE*)credentials->identity.Domain,\n\t\t              credentials->identity.DomainLength * 2);\n\t}\n\telse\n\t\tWLog_VRB(TAG, \"Strange, NTLM_CONTEXT is missing valid credentials...\");\n\n\tWLog_VRB(TAG, \"Workstation (length = %\" PRIu16 \")\", context->Workstation.Length);\n\twinpr_HexDump(TAG, WLOG_TRACE, (BYTE*)context->Workstation.Buffer, context->Workstation.Length);\n\tWLog_VRB(TAG, \"NTOWFv2, NTLMv2 Hash\");\n\twinpr_HexDump(TAG, WLOG_TRACE, context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH);\n#endif\n\n\tif (memcmp(context->NtlmV2Hash, NTLM_NULL_BUFFER, 16) != 0)\n\t\treturn TRUE;\n\n\tif (!credentials)\n\t\treturn FALSE;\n\telse if (memcmp(context->NtlmHash, NTLM_NULL_BUFFER, 16) != 0)\n\t{\n\t\tNTOWFv2FromHashW(context->NtlmHash, (LPWSTR)credentials->identity.User,\n\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,\n\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);\n\t}\n\telse if (credentials->identity.PasswordLength > SSPI_CREDENTIALS_HASH_LENGTH_OFFSET)\n\t{\n\t\t/* Special case for WinPR: password hash */\n\t\tif (ntlm_convert_password_hash(context, context->NtlmHash) < 0)\n\t\t\treturn FALSE;\n\n\t\tNTOWFv2FromHashW(context->NtlmHash, (LPWSTR)credentials->identity.User,\n\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,\n\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);\n\t}\n\telse if (credentials->identity.Password)\n\t{\n\t\tNTOWFv2W((LPWSTR)credentials->identity.Password, credentials->identity.PasswordLength * 2,\n\t\t         (LPWSTR)credentials->identity.User, credentials->identity.UserLength * 2,\n\t\t         (LPWSTR)credentials->identity.Domain, credentials->identity.DomainLength * 2,\n\t\t         (BYTE*)hash);\n\t}\n\telse if (context->HashCallback)\n\t{\n\t\tint ret;\n\t\tSecBuffer proofValue, micValue;\n\n\t\tif (ntlm_computeProofValue(context, &proofValue) != SEC_E_OK)\n\t\t\treturn FALSE;\n\n\t\tif (ntlm_computeMicValue(context, &micValue) != SEC_E_OK)\n\t\t{\n\t\t\tsspi_SecBufferFree(&proofValue);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tret = context->HashCallback(context->HashCallbackArg, &credentials->identity, &proofValue,\n\t\t                            context->EncryptedRandomSessionKey,\n\t\t                            context->AUTHENTICATE_MESSAGE.MessageIntegrityCheck, &micValue,\n\t\t                            hash);\n\t\tsspi_SecBufferFree(&proofValue);\n\t\tsspi_SecBufferFree(&micValue);\n\t\treturn ret ? TRUE : FALSE;\n\t}\n\telse if (context->UseSamFileDatabase)\n\t{\n\t\treturn ntlm_fetch_ntlm_v2_hash(context, hash);\n\t}\n\n\treturn TRUE;\n}\n\nBOOL ntlm_compute_lm_v2_response(NTLM_CONTEXT* context)\n{\n\tBYTE* response;\n\tBYTE value[WINPR_MD5_DIGEST_LENGTH] = { 0 };\n\n\tWINPR_ASSERT(context);\n\n\tif (context->LmCompatibilityLevel < 2)\n\t{\n\t\tif (!sspi_SecBufferAlloc(&context->LmChallengeResponse, 24))\n\t\t\treturn FALSE;\n\n\t\tZeroMemory(context->LmChallengeResponse.pvBuffer, 24);\n\t\treturn TRUE;\n\t}\n\n\t/* Compute the NTLMv2 hash */\n\n\tif (!ntlm_compute_ntlm_v2_hash(context, context->NtlmV2Hash))\n\t\treturn FALSE;\n\n\t/* Concatenate the server and client challenges */\n\tCopyMemory(value, context->ServerChallenge, 8);\n\tCopyMemory(&value[8], context->ClientChallenge, 8);\n\n\tif (!sspi_SecBufferAlloc(&context->LmChallengeResponse, 24))\n\t\treturn FALSE;\n\n\tresponse = (BYTE*)context->LmChallengeResponse.pvBuffer;\n\t/* Compute the HMAC-MD5 hash of the resulting value using the NTLMv2 hash as the key */\n\twinpr_HMAC(WINPR_MD_MD5, (void*)context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH, (BYTE*)value,\n\t           WINPR_MD5_DIGEST_LENGTH, (BYTE*)response, WINPR_MD5_DIGEST_LENGTH);\n\t/* Concatenate the resulting HMAC-MD5 hash and the client challenge, giving us the LMv2 response\n\t * (24 bytes) */\n\tCopyMemory(&response[16], context->ClientChallenge, 8);\n\treturn TRUE;\n}\n\n/**\n * Compute NTLMv2 Response.\n * NTLMv2_RESPONSE @msdn{cc236653}\n * NTLMv2 Authentication @msdn{cc236700}\n * @param NTLM context\n */\n\nBOOL ntlm_compute_ntlm_v2_response(NTLM_CONTEXT* context)\n{\n\tBYTE* blob;\n\tSecBuffer ntlm_v2_temp = { 0 };\n\tSecBuffer ntlm_v2_temp_chal = { 0 };\n\tPSecBuffer TargetInfo;\n\n\tWINPR_ASSERT(context);\n\n\tTargetInfo = &context->ChallengeTargetInfo;\n\tBOOL ret = FALSE;\n\n\tif (!sspi_SecBufferAlloc(&ntlm_v2_temp, TargetInfo->cbBuffer + 28))\n\t\tgoto exit;\n\n\tZeroMemory(ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);\n\tblob = (BYTE*)ntlm_v2_temp.pvBuffer;\n\n\t/* Compute the NTLMv2 hash */\n\tif (!ntlm_compute_ntlm_v2_hash(context, (BYTE*)context->NtlmV2Hash))\n\t\tgoto exit;\n\n\t/* Construct temp */\n\tblob[0] = 1; /* RespType (1 byte) */\n\tblob[1] = 1; /* HighRespType (1 byte) */\n\t/* Reserved1 (2 bytes) */\n\t/* Reserved2 (4 bytes) */\n\tCopyMemory(&blob[8], context->Timestamp, 8);        /* Timestamp (8 bytes) */\n\tCopyMemory(&blob[16], context->ClientChallenge, 8); /* ClientChallenge (8 bytes) */\n\t/* Reserved3 (4 bytes) */\n\tCopyMemory(&blob[28], TargetInfo->pvBuffer, TargetInfo->cbBuffer);\n#ifdef WITH_DEBUG_NTLM\n\tWLog_VRB(TAG, \"NTLMv2 Response Temp Blob\");\n\twinpr_HexDump(TAG, WLOG_TRACE, ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);\n#endif\n\n\t/* Concatenate server challenge with temp */\n\n\tif (!sspi_SecBufferAlloc(&ntlm_v2_temp_chal, ntlm_v2_temp.cbBuffer + 8))\n\t\tgoto exit;\n\n\tblob = (BYTE*)ntlm_v2_temp_chal.pvBuffer;\n\tCopyMemory(blob, context->ServerChallenge, 8);\n\tCopyMemory(&blob[8], ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);\n\twinpr_HMAC(WINPR_MD_MD5, (BYTE*)context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH,\n\t           (BYTE*)ntlm_v2_temp_chal.pvBuffer, ntlm_v2_temp_chal.cbBuffer,\n\t           context->NtProofString, WINPR_MD5_DIGEST_LENGTH);\n\n\t/* NtChallengeResponse, Concatenate NTProofStr with temp */\n\n\tif (!sspi_SecBufferAlloc(&context->NtChallengeResponse, ntlm_v2_temp.cbBuffer + 16))\n\t\tgoto exit;\n\n\tblob = (BYTE*)context->NtChallengeResponse.pvBuffer;\n\tCopyMemory(blob, context->NtProofString, WINPR_MD5_DIGEST_LENGTH);\n\tCopyMemory(&blob[16], ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);\n\t/* Compute SessionBaseKey, the HMAC-MD5 hash of NTProofStr using the NTLMv2 hash as the key */\n\twinpr_HMAC(WINPR_MD_MD5, (BYTE*)context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH,\n\t           context->NtProofString, WINPR_MD5_DIGEST_LENGTH, context->SessionBaseKey,\n\t           WINPR_MD5_DIGEST_LENGTH);\n\tret = TRUE;\nexit:\n\tsspi_SecBufferFree(&ntlm_v2_temp);\n\tsspi_SecBufferFree(&ntlm_v2_temp_chal);\n\treturn ret;\n}\n\n/**\n * Encrypt the given plain text using RC4 and the given key.\n * @param key RC4 key\n * @param length text length\n * @param plaintext plain text\n * @param ciphertext cipher text\n */\n\nvoid ntlm_rc4k(BYTE* key, size_t length, BYTE* plaintext, BYTE* ciphertext)\n{\n\tWINPR_RC4_CTX* rc4 = winpr_RC4_New(key, 16);\n\n\tif (rc4)\n\t{\n\t\twinpr_RC4_Update(rc4, length, plaintext, ciphertext);\n\t\twinpr_RC4_Free(rc4);\n\t}\n}\n\n/**\n * Generate client challenge (8-byte nonce).\n * @param NTLM context\n */\n\nvoid ntlm_generate_client_challenge(NTLM_CONTEXT* context)\n{\n\tWINPR_ASSERT(context);\n\n\t/* ClientChallenge is used in computation of LMv2 and NTLMv2 responses */\n\tif (memcmp(context->ClientChallenge, NTLM_NULL_BUFFER, sizeof(context->ClientChallenge)) == 0)\n\t\twinpr_RAND(context->ClientChallenge, sizeof(context->ClientChallenge));\n}\n\n/**\n * Generate server challenge (8-byte nonce).\n * @param NTLM context\n */\n\nvoid ntlm_generate_server_challenge(NTLM_CONTEXT* context)\n{\n\tWINPR_ASSERT(context);\n\n\tif (memcmp(context->ServerChallenge, NTLM_NULL_BUFFER, sizeof(context->ServerChallenge)) == 0)\n\t\twinpr_RAND(context->ServerChallenge, sizeof(context->ServerChallenge));\n}\n\n/**\n * Generate KeyExchangeKey (the 128-bit SessionBaseKey).\n * @msdn{cc236710}\n * @param NTLM context\n */\n\nvoid ntlm_generate_key_exchange_key(NTLM_CONTEXT* context)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(sizeof(context->KeyExchangeKey) == sizeof(context->SessionBaseKey));\n\n\t/* In NTLMv2, KeyExchangeKey is the 128-bit SessionBaseKey */\n\tCopyMemory(context->KeyExchangeKey, context->SessionBaseKey, sizeof(context->KeyExchangeKey));\n}\n\n/**\n * Generate RandomSessionKey (16-byte nonce).\n * @param NTLM context\n */\n\nvoid ntlm_generate_random_session_key(NTLM_CONTEXT* context)\n{\n\tWINPR_ASSERT(context);\n\twinpr_RAND(context->RandomSessionKey, sizeof(context->RandomSessionKey));\n}\n\n/**\n * Generate ExportedSessionKey (the RandomSessionKey, exported)\n * @param NTLM context\n */\n\nvoid ntlm_generate_exported_session_key(NTLM_CONTEXT* context)\n{\n\tWINPR_ASSERT(context);\n\n\tCopyMemory(context->ExportedSessionKey, context->RandomSessionKey,\n\t           sizeof(context->ExportedSessionKey));\n}\n\n/**\n * Encrypt RandomSessionKey (RC4-encrypted RandomSessionKey, using KeyExchangeKey as the key).\n * @param NTLM context\n */\n\nvoid ntlm_encrypt_random_session_key(NTLM_CONTEXT* context)\n{\n\t/* In NTLMv2, EncryptedRandomSessionKey is the ExportedSessionKey RC4-encrypted with the\n\t * KeyExchangeKey */\n\tWINPR_ASSERT(context);\n\tntlm_rc4k(context->KeyExchangeKey, 16, context->RandomSessionKey,\n\t          context->EncryptedRandomSessionKey);\n}\n\n/**\n * Decrypt RandomSessionKey (RC4-encrypted RandomSessionKey, using KeyExchangeKey as the key).\n * @param NTLM context\n */\n\nvoid ntlm_decrypt_random_session_key(NTLM_CONTEXT* context)\n{\n\tWINPR_ASSERT(context);\n\n\t/* In NTLMv2, EncryptedRandomSessionKey is the ExportedSessionKey RC4-encrypted with the\n\t * KeyExchangeKey */\n\n\t/**\n\t * \tif (NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)\n\t * \t\tSet RandomSessionKey to RC4K(KeyExchangeKey,\n\t * AUTHENTICATE_MESSAGE.EncryptedRandomSessionKey) else Set RandomSessionKey to KeyExchangeKey\n\t */\n\tif (context->NegotiateKeyExchange)\n\t{\n\t\tWINPR_ASSERT(sizeof(context->EncryptedRandomSessionKey) ==\n\t\t             sizeof(context->RandomSessionKey));\n\t\tntlm_rc4k(context->KeyExchangeKey, sizeof(context->EncryptedRandomSessionKey),\n\t\t          context->EncryptedRandomSessionKey, context->RandomSessionKey);\n\t}\n\telse\n\t{\n\t\tWINPR_ASSERT(sizeof(context->RandomSessionKey) == sizeof(context->KeyExchangeKey));\n\t\tCopyMemory(context->RandomSessionKey, context->KeyExchangeKey,\n\t\t           sizeof(context->RandomSessionKey));\n\t}\n}\n\n/**\n * Generate signing key.\n * @msdn{cc236711}\n * @param exported_session_key ExportedSessionKey\n * @param sign_magic Sign magic string\n * @param signing_key Destination signing key\n */\n\nstatic BOOL ntlm_generate_signing_key(BYTE* exported_session_key, const SecBuffer* sign_magic,\n                                      BYTE* signing_key)\n{\n\tBOOL rc = FALSE;\n\tsize_t length;\n\tBYTE* value = NULL;\n\n\tWINPR_ASSERT(exported_session_key);\n\tWINPR_ASSERT(sign_magic);\n\tWINPR_ASSERT(signing_key);\n\n\tlength = WINPR_MD5_DIGEST_LENGTH + sign_magic->cbBuffer;\n\tvalue = (BYTE*)malloc(length);\n\n\tif (!value)\n\t\tgoto out;\n\n\t/* Concatenate ExportedSessionKey with sign magic */\n\tCopyMemory(value, exported_session_key, WINPR_MD5_DIGEST_LENGTH);\n\tCopyMemory(&value[WINPR_MD5_DIGEST_LENGTH], sign_magic->pvBuffer, sign_magic->cbBuffer);\n\n\trc = winpr_Digest(WINPR_MD_MD5, value, length, signing_key, WINPR_MD5_DIGEST_LENGTH);\n\nout:\n\tfree(value);\n\treturn rc;\n}\n\n/**\n * Generate client signing key (ClientSigningKey).\n * @msdn{cc236711}\n * @param NTLM context\n */\n\nBOOL ntlm_generate_client_signing_key(NTLM_CONTEXT* context)\n{\n\tconst SecBuffer signMagic = { sizeof(NTLM_CLIENT_SIGN_MAGIC), 0, NTLM_CLIENT_SIGN_MAGIC };\n\n\tWINPR_ASSERT(context);\n\treturn ntlm_generate_signing_key(context->ExportedSessionKey, &signMagic,\n\t                                 context->ClientSigningKey);\n}\n\n/**\n * Generate server signing key (ServerSigningKey).\n * @msdn{cc236711}\n * @param NTLM context\n */\n\nBOOL ntlm_generate_server_signing_key(NTLM_CONTEXT* context)\n{\n\tconst SecBuffer signMagic = { sizeof(NTLM_SERVER_SIGN_MAGIC), 0, NTLM_SERVER_SIGN_MAGIC };\n\n\tWINPR_ASSERT(context);\n\treturn ntlm_generate_signing_key(context->ExportedSessionKey, &signMagic,\n\t                                 context->ServerSigningKey);\n}\n\n/**\n * Generate client sealing key (ClientSealingKey).\n * @msdn{cc236712}\n * @param NTLM context\n */\n\nBOOL ntlm_generate_client_sealing_key(NTLM_CONTEXT* context)\n{\n\tconst SecBuffer sealMagic = { sizeof(NTLM_CLIENT_SEAL_MAGIC), 0, NTLM_CLIENT_SEAL_MAGIC };\n\n\tWINPR_ASSERT(context);\n\treturn ntlm_generate_signing_key(context->ExportedSessionKey, &sealMagic,\n\t                                 context->ClientSealingKey);\n}\n\n/**\n * Generate server sealing key (ServerSealingKey).\n * @msdn{cc236712}\n * @param NTLM context\n */\n\nBOOL ntlm_generate_server_sealing_key(NTLM_CONTEXT* context)\n{\n\tconst SecBuffer sealMagic = { sizeof(NTLM_SERVER_SEAL_MAGIC), 0, NTLM_SERVER_SEAL_MAGIC };\n\n\tWINPR_ASSERT(context);\n\treturn ntlm_generate_signing_key(context->ExportedSessionKey, &sealMagic,\n\t                                 context->ServerSealingKey);\n}\n\n/**\n * Initialize RC4 stream cipher states for sealing.\n * @param NTLM context\n */\n\nvoid ntlm_init_rc4_seal_states(NTLM_CONTEXT* context)\n{\n\tWINPR_ASSERT(context);\n\tif (context->server)\n\t{\n\t\tcontext->SendSigningKey = context->ServerSigningKey;\n\t\tcontext->RecvSigningKey = context->ClientSigningKey;\n\t\tcontext->SendSealingKey = context->ClientSealingKey;\n\t\tcontext->RecvSealingKey = context->ServerSealingKey;\n\t\tcontext->SendRc4Seal =\n\t\t    winpr_RC4_New(context->ServerSealingKey, sizeof(context->ServerSealingKey));\n\t\tcontext->RecvRc4Seal =\n\t\t    winpr_RC4_New(context->ClientSealingKey, sizeof(context->ClientSealingKey));\n\t}\n\telse\n\t{\n\t\tcontext->SendSigningKey = context->ClientSigningKey;\n\t\tcontext->RecvSigningKey = context->ServerSigningKey;\n\t\tcontext->SendSealingKey = context->ServerSealingKey;\n\t\tcontext->RecvSealingKey = context->ClientSealingKey;\n\t\tcontext->SendRc4Seal =\n\t\t    winpr_RC4_New(context->ClientSealingKey, sizeof(context->ClientSealingKey));\n\t\tcontext->RecvRc4Seal =\n\t\t    winpr_RC4_New(context->ServerSealingKey, sizeof(context->ServerSealingKey));\n\t}\n}\n\nBOOL ntlm_compute_message_integrity_check(NTLM_CONTEXT* context, BYTE* mic, UINT32 size)\n{\n\tBOOL rc = FALSE;\n\t/*\n\t * Compute the HMAC-MD5 hash of ConcatenationOf(NEGOTIATE_MESSAGE,\n\t * CHALLENGE_MESSAGE, AUTHENTICATE_MESSAGE) using the ExportedSessionKey\n\t */\n\tWINPR_HMAC_CTX* hmac = winpr_HMAC_New();\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(mic);\n\tWINPR_ASSERT(size >= WINPR_MD5_DIGEST_LENGTH);\n\n\tmemset(mic, 0, size);\n\tif (!hmac)\n\t\treturn FALSE;\n\n\tif (winpr_HMAC_Init(hmac, WINPR_MD_MD5, context->ExportedSessionKey, WINPR_MD5_DIGEST_LENGTH))\n\t{\n\t\twinpr_HMAC_Update(hmac, (BYTE*)context->NegotiateMessage.pvBuffer,\n\t\t                  context->NegotiateMessage.cbBuffer);\n\t\twinpr_HMAC_Update(hmac, (BYTE*)context->ChallengeMessage.pvBuffer,\n\t\t                  context->ChallengeMessage.cbBuffer);\n\n\t\tif (context->MessageIntegrityCheckOffset > 0)\n\t\t{\n\t\t\tconst BYTE* auth = (BYTE*)context->AuthenticateMessage.pvBuffer;\n\t\t\tconst BYTE data[WINPR_MD5_DIGEST_LENGTH] = { 0 };\n\t\t\tconst size_t rest = context->MessageIntegrityCheckOffset + sizeof(data);\n\n\t\t\tWINPR_ASSERT(rest <= context->AuthenticateMessage.cbBuffer);\n\t\t\twinpr_HMAC_Update(hmac, &auth[0], context->MessageIntegrityCheckOffset);\n\t\t\twinpr_HMAC_Update(hmac, data, sizeof(data));\n\t\t\twinpr_HMAC_Update(hmac, &auth[rest], context->AuthenticateMessage.cbBuffer - rest);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twinpr_HMAC_Update(hmac, (BYTE*)context->AuthenticateMessage.pvBuffer,\n\t\t\t                  context->AuthenticateMessage.cbBuffer);\n\t\t}\n\t\twinpr_HMAC_Final(hmac, mic, WINPR_MD5_DIGEST_LENGTH);\n\t\trc = TRUE;\n\t}\n\n\twinpr_HMAC_Free(hmac);\n\treturn rc;\n}\n"], "fixing_code": ["/**\n * WinPR: Windows Portable Runtime\n * NTLM Security Package (Compute)\n *\n * Copyright 2011-2014 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <winpr/config.h>\n\n#include <winpr/assert.h>\n\n#include \"ntlm.h\"\n#include \"../sspi.h\"\n\n#include <winpr/crt.h>\n#include <winpr/sam.h>\n#include <winpr/ntlm.h>\n#include <winpr/print.h>\n#include <winpr/crypto.h>\n#include <winpr/sysinfo.h>\n\n#include \"ntlm_compute.h\"\n\n#include \"../../log.h\"\n#define TAG WINPR_TAG(\"sspi.NTLM\")\n\nstatic char NTLM_CLIENT_SIGN_MAGIC[] = \"session key to client-to-server signing key magic constant\";\nstatic char NTLM_SERVER_SIGN_MAGIC[] = \"session key to server-to-client signing key magic constant\";\nstatic char NTLM_CLIENT_SEAL_MAGIC[] = \"session key to client-to-server sealing key magic constant\";\nstatic char NTLM_SERVER_SEAL_MAGIC[] = \"session key to server-to-client sealing key magic constant\";\n\nstatic const BYTE NTLM_NULL_BUFFER[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t                                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\n/**\n * Populate VERSION structure.\n * VERSION @msdn{cc236654}\n * @param s\n */\n\nBOOL ntlm_get_version_info(NTLM_VERSION_INFO* versionInfo)\n{\n\tOSVERSIONINFOA osVersionInfo = { 0 };\n\n\tWINPR_ASSERT(versionInfo);\n\n\tosVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);\n\tif (!GetVersionExA(&osVersionInfo))\n\t\treturn FALSE;\n\tversionInfo->ProductMajorVersion = (UINT8)osVersionInfo.dwMajorVersion;\n\tversionInfo->ProductMinorVersion = (UINT8)osVersionInfo.dwMinorVersion;\n\tversionInfo->ProductBuild = (UINT16)osVersionInfo.dwBuildNumber;\n\tZeroMemory(versionInfo->Reserved, sizeof(versionInfo->Reserved));\n\tversionInfo->NTLMRevisionCurrent = NTLMSSP_REVISION_W2K3;\n\treturn TRUE;\n}\n\n/**\n * Read VERSION structure.\n * VERSION @msdn{cc236654}\n * @param s\n */\n\nBOOL ntlm_read_version_info(wStream* s, NTLM_VERSION_INFO* versionInfo)\n{\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(versionInfo);\n\n\tif (!Stream_CheckAndLogRequiredLength(TAG, s, 8))\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, versionInfo->ProductMajorVersion); /* ProductMajorVersion (1 byte) */\n\tStream_Read_UINT8(s, versionInfo->ProductMinorVersion); /* ProductMinorVersion (1 byte) */\n\tStream_Read_UINT16(s, versionInfo->ProductBuild);       /* ProductBuild (2 bytes) */\n\tStream_Read(s, versionInfo->Reserved, sizeof(versionInfo->Reserved)); /* Reserved (3 bytes) */\n\tStream_Read_UINT8(s, versionInfo->NTLMRevisionCurrent); /* NTLMRevisionCurrent (1 byte) */\n\treturn TRUE;\n}\n\n/**\n * Write VERSION structure.\n * VERSION @msdn{cc236654}\n * @param s\n */\n\nBOOL ntlm_write_version_info(wStream* s, const NTLM_VERSION_INFO* versionInfo)\n{\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(versionInfo);\n\n\tif (Stream_GetRemainingCapacity(s) < 5 + sizeof(versionInfo->Reserved))\n\t{\n\t\tWLog_ERR(TAG, \"NTLM_VERSION_INFO short header %\" PRIuz \", expected %\" PRIuz,\n\t\t         Stream_GetRemainingCapacity(s), 5 + sizeof(versionInfo->Reserved));\n\t\treturn FALSE;\n\t}\n\n\tStream_Write_UINT8(s, versionInfo->ProductMajorVersion); /* ProductMajorVersion (1 byte) */\n\tStream_Write_UINT8(s, versionInfo->ProductMinorVersion); /* ProductMinorVersion (1 byte) */\n\tStream_Write_UINT16(s, versionInfo->ProductBuild);       /* ProductBuild (2 bytes) */\n\tStream_Write(s, versionInfo->Reserved, sizeof(versionInfo->Reserved)); /* Reserved (3 bytes) */\n\tStream_Write_UINT8(s, versionInfo->NTLMRevisionCurrent); /* NTLMRevisionCurrent (1 byte) */\n\treturn TRUE;\n}\n\n/**\n * Print VERSION structure.\n * VERSION @msdn{cc236654}\n * @param s\n */\n#ifdef WITH_DEBUG_NTLM\nvoid ntlm_print_version_info(const NTLM_VERSION_INFO* versionInfo)\n{\n\tWINPR_ASSERT(versionInfo);\n\n\tWLog_VRB(TAG, \"VERSION ={\");\n\tWLog_VRB(TAG, \"\\tProductMajorVersion: %\" PRIu8 \"\", versionInfo->ProductMajorVersion);\n\tWLog_VRB(TAG, \"\\tProductMinorVersion: %\" PRIu8 \"\", versionInfo->ProductMinorVersion);\n\tWLog_VRB(TAG, \"\\tProductBuild: %\" PRIu16 \"\", versionInfo->ProductBuild);\n\tWLog_VRB(TAG, \"\\tReserved: 0x%02\" PRIX8 \"%02\" PRIX8 \"%02\" PRIX8 \"\", versionInfo->Reserved[0],\n\t         versionInfo->Reserved[1], versionInfo->Reserved[2]);\n\tWLog_VRB(TAG, \"\\tNTLMRevisionCurrent: 0x%02\" PRIX8 \"\", versionInfo->NTLMRevisionCurrent);\n}\n#endif\n\nstatic BOOL ntlm_read_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge)\n{\n\tsize_t size;\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(challenge);\n\n\tif (!Stream_CheckAndLogRequiredLength(TAG, s, 28))\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, challenge->RespType);\n\tStream_Read_UINT8(s, challenge->HiRespType);\n\tStream_Read_UINT16(s, challenge->Reserved1);\n\tStream_Read_UINT32(s, challenge->Reserved2);\n\tStream_Read(s, challenge->Timestamp, 8);\n\tStream_Read(s, challenge->ClientChallenge, 8);\n\tStream_Read_UINT32(s, challenge->Reserved3);\n\tsize = Stream_Length(s) - Stream_GetPosition(s);\n\n\tif (size > UINT32_MAX)\n\t{\n\t\tWLog_ERR(TAG, \"NTLMv2_CLIENT_CHALLENGE::cbAvPairs too large, got %\" PRIuz \"bytes\", size);\n\t\treturn FALSE;\n\t}\n\n\tchallenge->cbAvPairs = (UINT32)size;\n\tchallenge->AvPairs = (NTLM_AV_PAIR*)malloc(challenge->cbAvPairs);\n\n\tif (!challenge->AvPairs)\n\t{\n\t\tWLog_ERR(TAG, \"NTLMv2_CLIENT_CHALLENGE::AvPairs failed to allocate %\" PRIu32 \"bytes\",\n\t\t         challenge->cbAvPairs);\n\t\treturn FALSE;\n\t}\n\n\tStream_Read(s, challenge->AvPairs, size);\n\treturn TRUE;\n}\n\nstatic BOOL ntlm_write_ntlm_v2_client_challenge(wStream* s,\n                                                const NTLMv2_CLIENT_CHALLENGE* challenge)\n{\n\tULONG length;\n\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(challenge);\n\n\tif (Stream_GetRemainingCapacity(s) < 28)\n\t{\n\t\tWLog_ERR(TAG, \"NTLMv2_CLIENT_CHALLENGE expected 28bytes, have %\" PRIuz \"bytes\",\n\t\t         Stream_GetRemainingCapacity(s));\n\t\treturn FALSE;\n\t}\n\tStream_Write_UINT8(s, challenge->RespType);\n\tStream_Write_UINT8(s, challenge->HiRespType);\n\tStream_Write_UINT16(s, challenge->Reserved1);\n\tStream_Write_UINT32(s, challenge->Reserved2);\n\tStream_Write(s, challenge->Timestamp, 8);\n\tStream_Write(s, challenge->ClientChallenge, 8);\n\tStream_Write_UINT32(s, challenge->Reserved3);\n\tlength = ntlm_av_pair_list_length(challenge->AvPairs, challenge->cbAvPairs);\n\n\tif (!Stream_CheckAndLogRequiredLength(TAG, s, length))\n\t\treturn FALSE;\n\n\tStream_Write(s, challenge->AvPairs, length);\n\treturn TRUE;\n}\n\nBOOL ntlm_read_ntlm_v2_response(wStream* s, NTLMv2_RESPONSE* response)\n{\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(response);\n\n\tif (!Stream_CheckAndLogRequiredLength(TAG, s, 16))\n\t\treturn FALSE;\n\n\tStream_Read(s, response->Response, 16);\n\treturn ntlm_read_ntlm_v2_client_challenge(s, &(response->Challenge));\n}\n\nBOOL ntlm_write_ntlm_v2_response(wStream* s, const NTLMv2_RESPONSE* response)\n{\n\tWINPR_ASSERT(s);\n\tWINPR_ASSERT(response);\n\n\tif (Stream_GetRemainingCapacity(s) < 16)\n\t{\n\t\tWLog_ERR(TAG, \"NTLMv2_RESPONSE expected 16bytes, have %\" PRIuz \"bytes\",\n\t\t         Stream_GetRemainingCapacity(s));\n\t\treturn FALSE;\n\t}\n\tStream_Write(s, response->Response, 16);\n\treturn ntlm_write_ntlm_v2_client_challenge(s, &(response->Challenge));\n}\n\n/**\n * Get current time, in tenths of microseconds since midnight of January 1, 1601.\n * @param[out] timestamp 64-bit little-endian timestamp\n */\n\nvoid ntlm_current_time(BYTE* timestamp)\n{\n\tFILETIME filetime = { 0 };\n\tULARGE_INTEGER time64 = { 0 };\n\n\tWINPR_ASSERT(timestamp);\n\n\tGetSystemTimeAsFileTime(&filetime);\n\ttime64.u.LowPart = filetime.dwLowDateTime;\n\ttime64.u.HighPart = filetime.dwHighDateTime;\n\tCopyMemory(timestamp, &(time64.QuadPart), 8);\n}\n\n/**\n * Generate timestamp for AUTHENTICATE_MESSAGE.\n * @param NTLM context\n */\n\nvoid ntlm_generate_timestamp(NTLM_CONTEXT* context)\n{\n\tWINPR_ASSERT(context);\n\n\tif (memcmp(context->ChallengeTimestamp, NTLM_NULL_BUFFER, 8) != 0)\n\t\tCopyMemory(context->Timestamp, context->ChallengeTimestamp, 8);\n\telse\n\t\tntlm_current_time(context->Timestamp);\n}\n\nstatic BOOL ntlm_fetch_ntlm_v2_hash(NTLM_CONTEXT* context, BYTE* hash)\n{\n\tBOOL rc = FALSE;\n\tWINPR_SAM* sam = NULL;\n\tWINPR_SAM_ENTRY* entry = NULL;\n\tSSPI_CREDENTIALS* credentials;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(hash);\n\n\tcredentials = context->credentials;\n\tsam = SamOpen(context->SamFile, TRUE);\n\n\tif (!sam)\n\t\tgoto fail;\n\n\tentry = SamLookupUserW(\n\t    sam, (LPWSTR)credentials->identity.User, credentials->identity.UserLength * sizeof(WCHAR),\n\t    (LPWSTR)credentials->identity.Domain, credentials->identity.DomainLength * sizeof(WCHAR));\n\n\tif (!entry)\n\t{\n\t\tentry = SamLookupUserW(sam, (LPWSTR)credentials->identity.User,\n\t\t                       credentials->identity.UserLength * sizeof(WCHAR), NULL, 0);\n\t}\n\n\tif (!entry)\n\t\tgoto fail;\n\n#ifdef WITH_DEBUG_NTLM\n\t\tWLog_VRB(TAG, \"NTLM Hash:\");\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, entry->NtHash, 16);\n#endif\n\t    NTOWFv2FromHashW(entry->NtHash, (LPWSTR)credentials->identity.User,\n\t                     credentials->identity.UserLength * sizeof(WCHAR),\n\t                     (LPWSTR)credentials->identity.Domain,\n\t                     credentials->identity.DomainLength * sizeof(WCHAR), (BYTE*)hash);\n\n\t    rc = TRUE;\n\nfail:\n\tSamFreeEntry(sam, entry);\n\tSamClose(sam);\n\tif (!rc)\n\t\tWLog_ERR(TAG, \"Error: Could not find user in SAM database\");\n\n\treturn rc;\n}\n\nstatic int ntlm_convert_password_hash(NTLM_CONTEXT* context, BYTE* hash)\n{\n\tint status;\n\tint i;\n\tchar* PasswordHash = NULL;\n\tINT64 PasswordHashLength = 0;\n\tSSPI_CREDENTIALS* credentials;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(hash);\n\n\tcredentials = context->credentials;\n\t/* Password contains a password hash of length (PasswordLength -\n\t * SSPI_CREDENTIALS_HASH_LENGTH_OFFSET) */\n\tPasswordHashLength = credentials->identity.PasswordLength - SSPI_CREDENTIALS_HASH_LENGTH_OFFSET;\n\tWINPR_ASSERT(PasswordHashLength >= 0);\n\tWINPR_ASSERT(PasswordHashLength <= INT_MAX);\n\tstatus = ConvertFromUnicode(CP_UTF8, 0, (LPCWSTR)credentials->identity.Password,\n\t                            (int)PasswordHashLength, &PasswordHash, 0, NULL, NULL);\n\n\tif (status <= 0)\n\t\treturn -1;\n\n\tCharUpperBuffA(PasswordHash, (DWORD)PasswordHashLength);\n\n\tfor (i = 0; i < 32; i += 2)\n\t{\n\t\tBYTE hn =\n\t\t    (BYTE)(PasswordHash[i] > '9' ? PasswordHash[i] - 'A' + 10 : PasswordHash[i] - '0');\n\t\tBYTE ln = (BYTE)(PasswordHash[i + 1] > '9' ? PasswordHash[i + 1] - 'A' + 10\n\t\t                                           : PasswordHash[i + 1] - '0');\n\t\thash[i / 2] = (BYTE)((hn << 4) | ln);\n\t}\n\n\tfree(PasswordHash);\n\treturn 1;\n}\n\nstatic BOOL ntlm_compute_ntlm_v2_hash(NTLM_CONTEXT* context, BYTE* hash)\n{\n\tSSPI_CREDENTIALS* credentials;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(hash);\n\n\tcredentials = context->credentials;\n#ifdef WITH_DEBUG_NTLM\n\n\tif (credentials)\n\t{\n\t\tWLog_VRB(TAG, \"Password (length = %\" PRIu32 \")\", credentials->identity.PasswordLength * 2);\n\t\twinpr_HexDump(TAG, WLOG_TRACE, (BYTE*)credentials->identity.Password,\n\t\t              credentials->identity.PasswordLength * 2);\n\t\tWLog_VRB(TAG, \"Username (length = %\" PRIu32 \")\", credentials->identity.UserLength * 2);\n\t\twinpr_HexDump(TAG, WLOG_TRACE, (BYTE*)credentials->identity.User,\n\t\t              credentials->identity.UserLength * 2);\n\t\tWLog_VRB(TAG, \"Domain (length = %\" PRIu32 \")\", credentials->identity.DomainLength * 2);\n\t\twinpr_HexDump(TAG, WLOG_TRACE, (BYTE*)credentials->identity.Domain,\n\t\t              credentials->identity.DomainLength * 2);\n\t}\n\telse\n\t\tWLog_VRB(TAG, \"Strange, NTLM_CONTEXT is missing valid credentials...\");\n\n\tWLog_VRB(TAG, \"Workstation (length = %\" PRIu16 \")\", context->Workstation.Length);\n\twinpr_HexDump(TAG, WLOG_TRACE, (BYTE*)context->Workstation.Buffer, context->Workstation.Length);\n\tWLog_VRB(TAG, \"NTOWFv2, NTLMv2 Hash\");\n\twinpr_HexDump(TAG, WLOG_TRACE, context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH);\n#endif\n\n\tif (memcmp(context->NtlmV2Hash, NTLM_NULL_BUFFER, 16) != 0)\n\t\treturn TRUE;\n\n\tif (!credentials)\n\t\treturn FALSE;\n\telse if (memcmp(context->NtlmHash, NTLM_NULL_BUFFER, 16) != 0)\n\t{\n\t\tNTOWFv2FromHashW(context->NtlmHash, (LPWSTR)credentials->identity.User,\n\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,\n\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);\n\t}\n\telse if (credentials->identity.PasswordLength > SSPI_CREDENTIALS_HASH_LENGTH_OFFSET)\n\t{\n\t\t/* Special case for WinPR: password hash */\n\t\tif (ntlm_convert_password_hash(context, context->NtlmHash) < 0)\n\t\t\treturn FALSE;\n\n\t\tNTOWFv2FromHashW(context->NtlmHash, (LPWSTR)credentials->identity.User,\n\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,\n\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);\n\t}\n\telse if (credentials->identity.Password)\n\t{\n\t\tNTOWFv2W((LPWSTR)credentials->identity.Password, credentials->identity.PasswordLength * 2,\n\t\t         (LPWSTR)credentials->identity.User, credentials->identity.UserLength * 2,\n\t\t         (LPWSTR)credentials->identity.Domain, credentials->identity.DomainLength * 2,\n\t\t         (BYTE*)hash);\n\t}\n\telse if (context->HashCallback)\n\t{\n\t\tint ret;\n\t\tSecBuffer proofValue, micValue;\n\n\t\tif (ntlm_computeProofValue(context, &proofValue) != SEC_E_OK)\n\t\t\treturn FALSE;\n\n\t\tif (ntlm_computeMicValue(context, &micValue) != SEC_E_OK)\n\t\t{\n\t\t\tsspi_SecBufferFree(&proofValue);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tret = context->HashCallback(context->HashCallbackArg, &credentials->identity, &proofValue,\n\t\t                            context->EncryptedRandomSessionKey,\n\t\t                            context->AUTHENTICATE_MESSAGE.MessageIntegrityCheck, &micValue,\n\t\t                            hash);\n\t\tsspi_SecBufferFree(&proofValue);\n\t\tsspi_SecBufferFree(&micValue);\n\t\treturn ret ? TRUE : FALSE;\n\t}\n\telse if (context->UseSamFileDatabase)\n\t{\n\t\treturn ntlm_fetch_ntlm_v2_hash(context, hash);\n\t}\n\n\treturn TRUE;\n}\n\nBOOL ntlm_compute_lm_v2_response(NTLM_CONTEXT* context)\n{\n\tBYTE* response;\n\tBYTE value[WINPR_MD5_DIGEST_LENGTH] = { 0 };\n\n\tWINPR_ASSERT(context);\n\n\tif (context->LmCompatibilityLevel < 2)\n\t{\n\t\tif (!sspi_SecBufferAlloc(&context->LmChallengeResponse, 24))\n\t\t\treturn FALSE;\n\n\t\tZeroMemory(context->LmChallengeResponse.pvBuffer, 24);\n\t\treturn TRUE;\n\t}\n\n\t/* Compute the NTLMv2 hash */\n\n\tif (!ntlm_compute_ntlm_v2_hash(context, context->NtlmV2Hash))\n\t\treturn FALSE;\n\n\t/* Concatenate the server and client challenges */\n\tCopyMemory(value, context->ServerChallenge, 8);\n\tCopyMemory(&value[8], context->ClientChallenge, 8);\n\n\tif (!sspi_SecBufferAlloc(&context->LmChallengeResponse, 24))\n\t\treturn FALSE;\n\n\tresponse = (BYTE*)context->LmChallengeResponse.pvBuffer;\n\t/* Compute the HMAC-MD5 hash of the resulting value using the NTLMv2 hash as the key */\n\twinpr_HMAC(WINPR_MD_MD5, (void*)context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH, (BYTE*)value,\n\t           WINPR_MD5_DIGEST_LENGTH, (BYTE*)response, WINPR_MD5_DIGEST_LENGTH);\n\t/* Concatenate the resulting HMAC-MD5 hash and the client challenge, giving us the LMv2 response\n\t * (24 bytes) */\n\tCopyMemory(&response[16], context->ClientChallenge, 8);\n\treturn TRUE;\n}\n\n/**\n * Compute NTLMv2 Response.\n * NTLMv2_RESPONSE @msdn{cc236653}\n * NTLMv2 Authentication @msdn{cc236700}\n * @param NTLM context\n */\n\nBOOL ntlm_compute_ntlm_v2_response(NTLM_CONTEXT* context)\n{\n\tBYTE* blob;\n\tSecBuffer ntlm_v2_temp = { 0 };\n\tSecBuffer ntlm_v2_temp_chal = { 0 };\n\tPSecBuffer TargetInfo;\n\n\tWINPR_ASSERT(context);\n\n\tTargetInfo = &context->ChallengeTargetInfo;\n\tBOOL ret = FALSE;\n\n\tif (!sspi_SecBufferAlloc(&ntlm_v2_temp, TargetInfo->cbBuffer + 28))\n\t\tgoto exit;\n\n\tZeroMemory(ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);\n\tblob = (BYTE*)ntlm_v2_temp.pvBuffer;\n\n\t/* Compute the NTLMv2 hash */\n\tif (!ntlm_compute_ntlm_v2_hash(context, (BYTE*)context->NtlmV2Hash))\n\t\tgoto exit;\n\n\t/* Construct temp */\n\tblob[0] = 1; /* RespType (1 byte) */\n\tblob[1] = 1; /* HighRespType (1 byte) */\n\t/* Reserved1 (2 bytes) */\n\t/* Reserved2 (4 bytes) */\n\tCopyMemory(&blob[8], context->Timestamp, 8);        /* Timestamp (8 bytes) */\n\tCopyMemory(&blob[16], context->ClientChallenge, 8); /* ClientChallenge (8 bytes) */\n\t/* Reserved3 (4 bytes) */\n\tCopyMemory(&blob[28], TargetInfo->pvBuffer, TargetInfo->cbBuffer);\n#ifdef WITH_DEBUG_NTLM\n\tWLog_VRB(TAG, \"NTLMv2 Response Temp Blob\");\n\twinpr_HexDump(TAG, WLOG_TRACE, ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);\n#endif\n\n\t/* Concatenate server challenge with temp */\n\n\tif (!sspi_SecBufferAlloc(&ntlm_v2_temp_chal, ntlm_v2_temp.cbBuffer + 8))\n\t\tgoto exit;\n\n\tblob = (BYTE*)ntlm_v2_temp_chal.pvBuffer;\n\tCopyMemory(blob, context->ServerChallenge, 8);\n\tCopyMemory(&blob[8], ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);\n\twinpr_HMAC(WINPR_MD_MD5, (BYTE*)context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH,\n\t           (BYTE*)ntlm_v2_temp_chal.pvBuffer, ntlm_v2_temp_chal.cbBuffer,\n\t           context->NtProofString, WINPR_MD5_DIGEST_LENGTH);\n\n\t/* NtChallengeResponse, Concatenate NTProofStr with temp */\n\n\tif (!sspi_SecBufferAlloc(&context->NtChallengeResponse, ntlm_v2_temp.cbBuffer + 16))\n\t\tgoto exit;\n\n\tblob = (BYTE*)context->NtChallengeResponse.pvBuffer;\n\tCopyMemory(blob, context->NtProofString, WINPR_MD5_DIGEST_LENGTH);\n\tCopyMemory(&blob[16], ntlm_v2_temp.pvBuffer, ntlm_v2_temp.cbBuffer);\n\t/* Compute SessionBaseKey, the HMAC-MD5 hash of NTProofStr using the NTLMv2 hash as the key */\n\twinpr_HMAC(WINPR_MD_MD5, (BYTE*)context->NtlmV2Hash, WINPR_MD5_DIGEST_LENGTH,\n\t           context->NtProofString, WINPR_MD5_DIGEST_LENGTH, context->SessionBaseKey,\n\t           WINPR_MD5_DIGEST_LENGTH);\n\tret = TRUE;\nexit:\n\tsspi_SecBufferFree(&ntlm_v2_temp);\n\tsspi_SecBufferFree(&ntlm_v2_temp_chal);\n\treturn ret;\n}\n\n/**\n * Encrypt the given plain text using RC4 and the given key.\n * @param key RC4 key\n * @param length text length\n * @param plaintext plain text\n * @param ciphertext cipher text\n */\n\nvoid ntlm_rc4k(BYTE* key, size_t length, BYTE* plaintext, BYTE* ciphertext)\n{\n\tWINPR_RC4_CTX* rc4 = winpr_RC4_New(key, 16);\n\n\tif (rc4)\n\t{\n\t\twinpr_RC4_Update(rc4, length, plaintext, ciphertext);\n\t\twinpr_RC4_Free(rc4);\n\t}\n}\n\n/**\n * Generate client challenge (8-byte nonce).\n * @param NTLM context\n */\n\nvoid ntlm_generate_client_challenge(NTLM_CONTEXT* context)\n{\n\tWINPR_ASSERT(context);\n\n\t/* ClientChallenge is used in computation of LMv2 and NTLMv2 responses */\n\tif (memcmp(context->ClientChallenge, NTLM_NULL_BUFFER, sizeof(context->ClientChallenge)) == 0)\n\t\twinpr_RAND(context->ClientChallenge, sizeof(context->ClientChallenge));\n}\n\n/**\n * Generate server challenge (8-byte nonce).\n * @param NTLM context\n */\n\nvoid ntlm_generate_server_challenge(NTLM_CONTEXT* context)\n{\n\tWINPR_ASSERT(context);\n\n\tif (memcmp(context->ServerChallenge, NTLM_NULL_BUFFER, sizeof(context->ServerChallenge)) == 0)\n\t\twinpr_RAND(context->ServerChallenge, sizeof(context->ServerChallenge));\n}\n\n/**\n * Generate KeyExchangeKey (the 128-bit SessionBaseKey).\n * @msdn{cc236710}\n * @param NTLM context\n */\n\nvoid ntlm_generate_key_exchange_key(NTLM_CONTEXT* context)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(sizeof(context->KeyExchangeKey) == sizeof(context->SessionBaseKey));\n\n\t/* In NTLMv2, KeyExchangeKey is the 128-bit SessionBaseKey */\n\tCopyMemory(context->KeyExchangeKey, context->SessionBaseKey, sizeof(context->KeyExchangeKey));\n}\n\n/**\n * Generate RandomSessionKey (16-byte nonce).\n * @param NTLM context\n */\n\nvoid ntlm_generate_random_session_key(NTLM_CONTEXT* context)\n{\n\tWINPR_ASSERT(context);\n\twinpr_RAND(context->RandomSessionKey, sizeof(context->RandomSessionKey));\n}\n\n/**\n * Generate ExportedSessionKey (the RandomSessionKey, exported)\n * @param NTLM context\n */\n\nvoid ntlm_generate_exported_session_key(NTLM_CONTEXT* context)\n{\n\tWINPR_ASSERT(context);\n\n\tCopyMemory(context->ExportedSessionKey, context->RandomSessionKey,\n\t           sizeof(context->ExportedSessionKey));\n}\n\n/**\n * Encrypt RandomSessionKey (RC4-encrypted RandomSessionKey, using KeyExchangeKey as the key).\n * @param NTLM context\n */\n\nvoid ntlm_encrypt_random_session_key(NTLM_CONTEXT* context)\n{\n\t/* In NTLMv2, EncryptedRandomSessionKey is the ExportedSessionKey RC4-encrypted with the\n\t * KeyExchangeKey */\n\tWINPR_ASSERT(context);\n\tntlm_rc4k(context->KeyExchangeKey, 16, context->RandomSessionKey,\n\t          context->EncryptedRandomSessionKey);\n}\n\n/**\n * Decrypt RandomSessionKey (RC4-encrypted RandomSessionKey, using KeyExchangeKey as the key).\n * @param NTLM context\n */\n\nvoid ntlm_decrypt_random_session_key(NTLM_CONTEXT* context)\n{\n\tWINPR_ASSERT(context);\n\n\t/* In NTLMv2, EncryptedRandomSessionKey is the ExportedSessionKey RC4-encrypted with the\n\t * KeyExchangeKey */\n\n\t/**\n\t * \tif (NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)\n\t * \t\tSet RandomSessionKey to RC4K(KeyExchangeKey,\n\t * AUTHENTICATE_MESSAGE.EncryptedRandomSessionKey) else Set RandomSessionKey to KeyExchangeKey\n\t */\n\tif (context->NegotiateKeyExchange)\n\t{\n\t\tWINPR_ASSERT(sizeof(context->EncryptedRandomSessionKey) ==\n\t\t             sizeof(context->RandomSessionKey));\n\t\tntlm_rc4k(context->KeyExchangeKey, sizeof(context->EncryptedRandomSessionKey),\n\t\t          context->EncryptedRandomSessionKey, context->RandomSessionKey);\n\t}\n\telse\n\t{\n\t\tWINPR_ASSERT(sizeof(context->RandomSessionKey) == sizeof(context->KeyExchangeKey));\n\t\tCopyMemory(context->RandomSessionKey, context->KeyExchangeKey,\n\t\t           sizeof(context->RandomSessionKey));\n\t}\n}\n\n/**\n * Generate signing key.\n * @msdn{cc236711}\n * @param exported_session_key ExportedSessionKey\n * @param sign_magic Sign magic string\n * @param signing_key Destination signing key\n */\n\nstatic BOOL ntlm_generate_signing_key(BYTE* exported_session_key, const SecBuffer* sign_magic,\n                                      BYTE* signing_key)\n{\n\tBOOL rc = FALSE;\n\tsize_t length;\n\tBYTE* value = NULL;\n\n\tWINPR_ASSERT(exported_session_key);\n\tWINPR_ASSERT(sign_magic);\n\tWINPR_ASSERT(signing_key);\n\n\tlength = WINPR_MD5_DIGEST_LENGTH + sign_magic->cbBuffer;\n\tvalue = (BYTE*)malloc(length);\n\n\tif (!value)\n\t\tgoto out;\n\n\t/* Concatenate ExportedSessionKey with sign magic */\n\tCopyMemory(value, exported_session_key, WINPR_MD5_DIGEST_LENGTH);\n\tCopyMemory(&value[WINPR_MD5_DIGEST_LENGTH], sign_magic->pvBuffer, sign_magic->cbBuffer);\n\n\trc = winpr_Digest(WINPR_MD_MD5, value, length, signing_key, WINPR_MD5_DIGEST_LENGTH);\n\nout:\n\tfree(value);\n\treturn rc;\n}\n\n/**\n * Generate client signing key (ClientSigningKey).\n * @msdn{cc236711}\n * @param NTLM context\n */\n\nBOOL ntlm_generate_client_signing_key(NTLM_CONTEXT* context)\n{\n\tconst SecBuffer signMagic = { sizeof(NTLM_CLIENT_SIGN_MAGIC), 0, NTLM_CLIENT_SIGN_MAGIC };\n\n\tWINPR_ASSERT(context);\n\treturn ntlm_generate_signing_key(context->ExportedSessionKey, &signMagic,\n\t                                 context->ClientSigningKey);\n}\n\n/**\n * Generate server signing key (ServerSigningKey).\n * @msdn{cc236711}\n * @param NTLM context\n */\n\nBOOL ntlm_generate_server_signing_key(NTLM_CONTEXT* context)\n{\n\tconst SecBuffer signMagic = { sizeof(NTLM_SERVER_SIGN_MAGIC), 0, NTLM_SERVER_SIGN_MAGIC };\n\n\tWINPR_ASSERT(context);\n\treturn ntlm_generate_signing_key(context->ExportedSessionKey, &signMagic,\n\t                                 context->ServerSigningKey);\n}\n\n/**\n * Generate client sealing key (ClientSealingKey).\n * @msdn{cc236712}\n * @param NTLM context\n */\n\nBOOL ntlm_generate_client_sealing_key(NTLM_CONTEXT* context)\n{\n\tconst SecBuffer sealMagic = { sizeof(NTLM_CLIENT_SEAL_MAGIC), 0, NTLM_CLIENT_SEAL_MAGIC };\n\n\tWINPR_ASSERT(context);\n\treturn ntlm_generate_signing_key(context->ExportedSessionKey, &sealMagic,\n\t                                 context->ClientSealingKey);\n}\n\n/**\n * Generate server sealing key (ServerSealingKey).\n * @msdn{cc236712}\n * @param NTLM context\n */\n\nBOOL ntlm_generate_server_sealing_key(NTLM_CONTEXT* context)\n{\n\tconst SecBuffer sealMagic = { sizeof(NTLM_SERVER_SEAL_MAGIC), 0, NTLM_SERVER_SEAL_MAGIC };\n\n\tWINPR_ASSERT(context);\n\treturn ntlm_generate_signing_key(context->ExportedSessionKey, &sealMagic,\n\t                                 context->ServerSealingKey);\n}\n\n/**\n * Initialize RC4 stream cipher states for sealing.\n * @param NTLM context\n */\n\nvoid ntlm_init_rc4_seal_states(NTLM_CONTEXT* context)\n{\n\tWINPR_ASSERT(context);\n\tif (context->server)\n\t{\n\t\tcontext->SendSigningKey = context->ServerSigningKey;\n\t\tcontext->RecvSigningKey = context->ClientSigningKey;\n\t\tcontext->SendSealingKey = context->ClientSealingKey;\n\t\tcontext->RecvSealingKey = context->ServerSealingKey;\n\t\tcontext->SendRc4Seal =\n\t\t    winpr_RC4_New(context->ServerSealingKey, sizeof(context->ServerSealingKey));\n\t\tcontext->RecvRc4Seal =\n\t\t    winpr_RC4_New(context->ClientSealingKey, sizeof(context->ClientSealingKey));\n\t}\n\telse\n\t{\n\t\tcontext->SendSigningKey = context->ClientSigningKey;\n\t\tcontext->RecvSigningKey = context->ServerSigningKey;\n\t\tcontext->SendSealingKey = context->ServerSealingKey;\n\t\tcontext->RecvSealingKey = context->ClientSealingKey;\n\t\tcontext->SendRc4Seal =\n\t\t    winpr_RC4_New(context->ClientSealingKey, sizeof(context->ClientSealingKey));\n\t\tcontext->RecvRc4Seal =\n\t\t    winpr_RC4_New(context->ServerSealingKey, sizeof(context->ServerSealingKey));\n\t}\n}\n\nBOOL ntlm_compute_message_integrity_check(NTLM_CONTEXT* context, BYTE* mic, UINT32 size)\n{\n\tBOOL rc = FALSE;\n\t/*\n\t * Compute the HMAC-MD5 hash of ConcatenationOf(NEGOTIATE_MESSAGE,\n\t * CHALLENGE_MESSAGE, AUTHENTICATE_MESSAGE) using the ExportedSessionKey\n\t */\n\tWINPR_HMAC_CTX* hmac = winpr_HMAC_New();\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(mic);\n\tWINPR_ASSERT(size >= WINPR_MD5_DIGEST_LENGTH);\n\n\tmemset(mic, 0, size);\n\tif (!hmac)\n\t\treturn FALSE;\n\n\tif (winpr_HMAC_Init(hmac, WINPR_MD_MD5, context->ExportedSessionKey, WINPR_MD5_DIGEST_LENGTH))\n\t{\n\t\twinpr_HMAC_Update(hmac, (BYTE*)context->NegotiateMessage.pvBuffer,\n\t\t                  context->NegotiateMessage.cbBuffer);\n\t\twinpr_HMAC_Update(hmac, (BYTE*)context->ChallengeMessage.pvBuffer,\n\t\t                  context->ChallengeMessage.cbBuffer);\n\n\t\tif (context->MessageIntegrityCheckOffset > 0)\n\t\t{\n\t\t\tconst BYTE* auth = (BYTE*)context->AuthenticateMessage.pvBuffer;\n\t\t\tconst BYTE data[WINPR_MD5_DIGEST_LENGTH] = { 0 };\n\t\t\tconst size_t rest = context->MessageIntegrityCheckOffset + sizeof(data);\n\n\t\t\tWINPR_ASSERT(rest <= context->AuthenticateMessage.cbBuffer);\n\t\t\twinpr_HMAC_Update(hmac, &auth[0], context->MessageIntegrityCheckOffset);\n\t\t\twinpr_HMAC_Update(hmac, data, sizeof(data));\n\t\t\twinpr_HMAC_Update(hmac, &auth[rest], context->AuthenticateMessage.cbBuffer - rest);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twinpr_HMAC_Update(hmac, (BYTE*)context->AuthenticateMessage.pvBuffer,\n\t\t\t                  context->AuthenticateMessage.cbBuffer);\n\t\t}\n\t\twinpr_HMAC_Final(hmac, mic, WINPR_MD5_DIGEST_LENGTH);\n\t\trc = TRUE;\n\t}\n\n\twinpr_HMAC_Free(hmac);\n\treturn rc;\n}\n"], "filenames": ["winpr/libwinpr/sspi/NTLM/ntlm_compute.c"], "buggy_code_start_loc": [266], "buggy_code_end_loc": [321], "fixing_code_start_loc": [266], "fixing_code_end_loc": [313], "type": "CWE-287", "message": "FreeRDP is a free implementation of the Remote Desktop Protocol (RDP). Prior to version 2.7.0, server side authentication against a `SAM` file might be successful for invalid credentials if the server has configured an invalid `SAM` file path. FreeRDP based clients are not affected. RDP server implementations using FreeRDP to authenticate against a `SAM` file are affected. Version 2.7.0 contains a fix for this issue. As a workaround, use custom authentication via `HashCallback` and/or ensure the `SAM` database path configured is valid and the application has file handles left.", "other": {"cve": {"id": "CVE-2022-24883", "sourceIdentifier": "security-advisories@github.com", "published": "2022-04-26T16:15:47.883", "lastModified": "2022-11-16T19:56:24.430", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "FreeRDP is a free implementation of the Remote Desktop Protocol (RDP). Prior to version 2.7.0, server side authentication against a `SAM` file might be successful for invalid credentials if the server has configured an invalid `SAM` file path. FreeRDP based clients are not affected. RDP server implementations using FreeRDP to authenticate against a `SAM` file are affected. Version 2.7.0 contains a fix for this issue. As a workaround, use custom authentication via `HashCallback` and/or ensure the `SAM` database path configured is valid and the application has file handles left."}, {"lang": "es", "value": "FreeRDP es una implementaci\u00f3n libre del protocolo de escritorio remoto (RDP). En versiones anteriores a 2.7.0, la autenticaci\u00f3n del lado del servidor contra un archivo \"SAM\" podr\u00eda tener \u00e9xito para credenciales inv\u00e1lidas si el servidor ha configurado una ruta de archivo \"SAM\" inv\u00e1lida. Los clientes basados en FreeRDP no est\u00e1n afectados. Las implementaciones de servidores RDP que usan FreeRDP para autenticar contra un archivo \"SAM\" est\u00e1n afectadas. La versi\u00f3n 2.7.0 contiene una correcci\u00f3n para este problema. Como mitigaci\u00f3n, use la autenticaci\u00f3n personalizada por medio de \"HashCallback\" y/o aseg\u00farese de que la ruta de la base de datos \"SAM\" configurada es v\u00e1lida y que la aplicaci\u00f3n dispone de los manejadores del archivo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.0", "matchCriteriaId": "68BB9FD2-F03F-4B57-A9CD-FEDC52626DC5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/FreeRDP/FreeRDP/commit/4661492e5a617199457c8074bad22f766a116cdc", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/commit/6f473b273a4b6f0cb6aca32b95e22fd0de88e144", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/releases/tag/2.7.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-qxm3-v2r6-vmwf", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/AELSWWBAM2YONRPGLWVDY6UNTLJERJYL/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DOYKBQOHSRM7JQYUIYUWFOXI2JZ2J5RD/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PZWR6KSIKXO4B2TXBB3WH6YTNYHN46OY/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-24", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/4661492e5a617199457c8074bad22f766a116cdc"}}