{"buggy_code": ["/* eslint eqeqeq: 0 */\n/* eslint no-use-before-define: 0 */\n/**\n * Baobab Helpers\n * ===============\n *\n * Miscellaneous helper functions.\n */\nimport {Monkey, MonkeyDefinition} from './monkey';\nimport type from './type';\n\nconst hasOwnProp = {}.hasOwnProperty;\n\n/**\n * Function returning the index of the first element of a list matching the\n * given predicate.\n *\n * @param  {array}     a  - The target array.\n * @param  {function}  fn - The predicate function.\n * @return {mixed}        - The index of the first matching item or -1.\n */\nfunction index(a, fn) {\n  let i, l;\n  for (i = 0, l = a.length; i < l; i++) {\n    if (fn(a[i]))\n      return i;\n  }\n  return -1;\n}\n\n/**\n * Efficient slice function used to clone arrays or parts of them.\n *\n * @param  {array} array - The array to slice.\n * @return {array}       - The sliced array.\n */\nfunction slice(array) {\n  const newArray = new Array(array.length);\n\n  let i,\n      l;\n\n  for (i = 0, l = array.length; i < l; i++)\n    newArray[i] = array[i];\n\n  return newArray;\n}\n\n/**\n * Archive abstraction\n *\n * @constructor\n * @param {integer} size - Maximum number of records to store.\n */\nexport class Archive {\n  constructor(size) {\n    this.size = size;\n    this.records = [];\n  }\n\n  /**\n   * Method retrieving the records.\n   *\n   * @return {array} - The records.\n   */\n  get() {\n    return this.records;\n  }\n\n  /**\n   * Method adding a record to the archive\n   *\n   * @param {object}  record - The record to store.\n   * @return {Archive}       - The archive itself for chaining purposes.\n   */\n  add(record) {\n    this.records.unshift(record);\n\n    // If the number of records is exceeded, we truncate the records\n    if (this.records.length > this.size)\n      this.records.length = this.size;\n\n    return this;\n  }\n\n  /**\n   * Method clearing the records.\n   *\n   * @return {Archive} - The archive itself for chaining purposes.\n   */\n  clear() {\n    this.records = [];\n    return this;\n  }\n\n  /**\n   * Method to go back in time.\n   *\n   * @param {integer} steps - Number of steps we should go back by.\n   * @return {number}       - The last record.\n   */\n  back(steps) {\n    const record = this.records[steps - 1];\n\n    if (record)\n      this.records = this.records.slice(steps);\n    return record;\n  }\n}\n\n/**\n * Function creating a real array from what should be an array but is not.\n * I'm looking at you nasty `arguments`...\n *\n * @param  {mixed} culprit - The culprit to convert.\n * @return {array}         - The real array.\n */\nexport function arrayFrom(culprit) {\n  return slice(culprit);\n}\n\n/**\n * Function decorating one function with another that will be called before the\n * decorated one.\n *\n * @param  {function} decorator - The decorating function.\n * @param  {function} fn        - The function to decorate.\n * @return {function}           - The decorated function.\n */\nexport function before(decorator, fn) {\n  return function() {\n    decorator.apply(null, arguments);\n    fn.apply(null, arguments);\n  };\n}\n\n/**\n * Function cloning the given regular expression. Supports `y` and `u` flags\n * already.\n *\n * @param  {RegExp} re - The target regular expression.\n * @return {RegExp}    - The cloned regular expression.\n */\nfunction cloneRegexp(re) {\n  const pattern = re.source;\n\n  let flags = '';\n\n  if (re.global) flags += 'g';\n  if (re.multiline) flags += 'm';\n  if (re.ignoreCase) flags += 'i';\n  if (re.sticky) flags += 'y';\n  if (re.unicode) flags += 'u';\n\n  return new RegExp(pattern, flags);\n}\n\n/**\n * Function cloning the given variable.\n *\n * @todo: implement a faster way to clone an array.\n *\n * @param  {boolean} deep - Should we deep clone the variable.\n * @param  {mixed}   item - The variable to clone\n * @return {mixed}        - The cloned variable.\n */\nfunction cloner(deep, item) {\n  if (!item ||\n      typeof item !== 'object' ||\n      item instanceof Error ||\n      item instanceof MonkeyDefinition ||\n      item instanceof Monkey ||\n      ('ArrayBuffer' in global && item instanceof ArrayBuffer))\n    return item;\n\n  // Array\n  if (type.array(item)) {\n    if (deep) {\n      const a = new Array(item.length);\n\n      for (let i = 0, l = item.length; i < l; i++)\n        a[i] = cloner(true, item[i]);\n      return a;\n    }\n\n    return slice(item);\n  }\n\n  // Date\n  if (item instanceof Date)\n    return new Date(item.getTime());\n\n  // RegExp\n  if (item instanceof RegExp)\n    return cloneRegexp(item);\n\n  // Object\n  if (type.object(item)) {\n    const o = {};\n\n    // NOTE: could be possible to erase computed properties through `null`.\n    const props = Object.getOwnPropertyNames(item);\n    for (let i = 0, l = props.length; i < l; i++) {\n      const name = props[i];\n      const k = Object.getOwnPropertyDescriptor(item, name);\n      if (k.enumerable === true) {\n        if (k.get && k.get.isLazyGetter) {\n          Object.defineProperty(o, name, {\n            get: k.get,\n            enumerable: true,\n            configurable: true\n          });\n        }\n        else {\n          o[name] = deep ? cloner(true, item[name]) : item[name];\n        }\n      }\n      else if (k.enumerable === false) {\n        Object.defineProperty(o, name, {\n          value: deep ? cloner(true, k.value) : k.value,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        });\n      }\n    }\n    return o;\n  }\n\n  return item;\n}\n\n/**\n * Exporting shallow and deep cloning functions.\n */\nconst shallowClone = cloner.bind(null, false),\n      deepClone = cloner.bind(null, true);\n\nexport {shallowClone, deepClone};\n\n/**\n * Coerce the given variable into a full-fledged path.\n *\n * @param  {mixed} target - The variable to coerce.\n * @return {array}        - The array path.\n */\nexport function coercePath(target) {\n  if (target || target === 0 || target === '')\n    return target;\n  return [];\n}\n\n/**\n * Function comparing an object's properties to a given descriptive\n * object.\n *\n * @param  {object} object      - The object to compare.\n * @param  {object} description - The description's mapping.\n * @return {boolean}            - Whether the object matches the description.\n */\nfunction compare(object, description) {\n  let ok = true,\n      k;\n\n  // If we reached here via a recursive call, object may be undefined because\n  // not all items in a collection will have the same deep nesting structure.\n  if (!object)\n    return false;\n\n  for (k in description) {\n    if (type.object(description[k])) {\n      ok = ok && compare(object[k], description[k]);\n    }\n    else if (type.array(description[k])) {\n      ok = ok && !!~description[k].indexOf(object[k]);\n    }\n    else {\n      if (object[k] !== description[k])\n        return false;\n    }\n  }\n\n  return ok;\n}\n\n/**\n * Function freezing the given variable if possible.\n *\n * @param  {boolean} deep - Should we recursively freeze the given objects?\n * @param  {object}  o    - The variable to freeze.\n * @return {object}    - The merged object.\n */\nfunction freezer(deep, o) {\n  if (typeof o !== 'object' ||\n      o === null ||\n      o instanceof Monkey)\n    return;\n\n  Object.freeze(o);\n\n  if (!deep)\n    return;\n\n  if (Array.isArray(o)) {\n\n    // Iterating through the elements\n    let i,\n        l;\n\n    for (i = 0, l = o.length; i < l; i++)\n      deepFreeze(o[i]);\n  }\n  else {\n    let p,\n        k;\n\n    for (k in o) {\n      if (type.lazyGetter(o, k))\n        continue;\n\n      p = o[k];\n\n      if (!p ||\n          !hasOwnProp.call(o, k) ||\n          typeof p !== 'object' ||\n          Object.isFrozen(p))\n        continue;\n\n      deepFreeze(p);\n    }\n  }\n}\n\nconst freeze = freezer.bind(null, false),\n      deepFreeze = freezer.bind(null, true);\n\nexport {freeze, deepFreeze};\n\n/**\n * Function retrieving nested data within the given object and according to\n * the given path.\n *\n * @todo: work if dynamic path hit objects also.\n * @todo: memoized perfgetters.\n *\n * @param  {object}  object - The object we need to get data from.\n * @param  {array}   path   - The path to follow.\n * @return {object}  result            - The result.\n * @return {mixed}   result.data       - The data at path, or `undefined`.\n * @return {array}   result.solvedPath - The solved path or `null`.\n * @return {boolean} result.exists     - Does the path exists in the tree?\n */\nconst NOT_FOUND_OBJECT = {data: undefined, solvedPath: null, exists: false};\n\nexport function getIn(object, path) {\n  if (!path)\n    return NOT_FOUND_OBJECT;\n\n  const solvedPath = [];\n\n  let exists = true,\n      c = object,\n      idx,\n      i,\n      l;\n\n  for (i = 0, l = path.length; i < l; i++) {\n    if (!c)\n      return {\n        data: undefined,\n        solvedPath: solvedPath.concat(path.slice(i)),\n        exists: false\n      };\n\n    if (typeof path[i] === 'function') {\n      if (!type.array(c))\n        return NOT_FOUND_OBJECT;\n\n      idx = index(c, path[i]);\n      if (!~idx)\n        return NOT_FOUND_OBJECT;\n\n      solvedPath.push(idx);\n      c = c[idx];\n    }\n    else if (typeof path[i] === 'object') {\n      if (!type.array(c))\n        return NOT_FOUND_OBJECT;\n\n      idx = index(c, e => compare(e, path[i]));\n      if (!~idx)\n        return NOT_FOUND_OBJECT;\n\n      solvedPath.push(idx);\n      c = c[idx];\n    }\n    else {\n      solvedPath.push(path[i]);\n      exists = typeof c === 'object' && path[i] in c;\n      c = c[path[i]];\n    }\n  }\n\n  return {data: c, solvedPath, exists};\n}\n\n/**\n * Little helper returning a JavaScript error carrying some data with it.\n *\n * @param  {string} message - The error message.\n * @param  {object} [data]  - Optional data to assign to the error.\n * @return {Error}          - The created error.\n */\nexport function makeError(message, data) {\n  const err = new Error(message);\n\n  for (const k in data)\n    err[k] = data[k];\n\n  return err;\n}\n\n/**\n * Function taking n objects to merge them together.\n * Note 1): the latter object will take precedence over the first one.\n * Note 2): the first object will be mutated to allow for perf scenarios.\n * Note 3): this function will consider monkeys as leaves.\n *\n * @param  {boolean}   deep    - Whether the merge should be deep or not.\n * @param  {...object} objects - Objects to merge.\n * @return {object}            - The merged object.\n */\nfunction merger(deep, ...objects) {\n  const o = objects[0];\n\n  let t,\n      i,\n      l,\n      k;\n\n  for (i = 1, l = objects.length; i < l; i++) {\n    t = objects[i];\n\n    for (k in t) {\n      if (deep &&\n          type.object(t[k]) &&\n          !(t[k] instanceof Monkey)) {\n        o[k] = merger(true, o[k] || {}, t[k]);\n      }\n      else {\n        o[k] = t[k];\n      }\n    }\n  }\n\n  return o;\n}\n\n/**\n * Exporting both `shallowMerge` and `deepMerge` functions.\n */\nconst shallowMerge = merger.bind(null, false),\n      deepMerge = merger.bind(null, true);\n\nexport {shallowMerge, deepMerge};\n\n/**\n * Function returning a string hash from a non-dynamic path expressed as an\n * array.\n *\n * @param  {array}  path - The path to hash.\n * @return {string} string - The resultant hash.\n */\nexport function hashPath(path) {\n  return '\u03bb' + path.map(step => {\n    if (type.function(step) || type.object(step))\n      return `#${uniqid()}#`;\n\n    return step;\n  }).join('\u03bb');\n}\n\n/**\n * Solving a potentially relative path.\n *\n * @param  {array} base - The base path from which to solve the path.\n * @param  {array} to   - The subpath to reach.\n * @param  {array}      - The solved absolute path.\n */\nexport function solveRelativePath(base, to) {\n  let solvedPath = [];\n\n  // Coercing to array\n  to = [].concat(to);\n\n  for (let i = 0, l = to.length; i < l; i++) {\n    const step = to[i];\n\n    if (step === '.') {\n      if (!i)\n        solvedPath = base.slice(0);\n    }\n    else if (step === '..') {\n      solvedPath = (!i ? base : solvedPath).slice(0, -1);\n    }\n    else {\n      solvedPath.push(step);\n    }\n  }\n\n  return solvedPath;\n}\n\n/**\n * Function determining whether some paths in the tree were affected by some\n * updates that occurred at the given paths. This helper is mainly used at\n * cursor level to determine whether the cursor is concerned by the updates\n * fired at tree level.\n *\n * NOTES: 1) If performance become an issue, the following threefold loop\n *           can be simplified to a complex twofold one.\n *        2) A regex version could also work but I am not confident it would\n *           be faster.\n *        3) Another solution would be to keep a register of cursors like with\n *           the monkeys and update along this tree.\n *\n * @param  {array} affectedPaths - The paths that were updated.\n * @param  {array} comparedPaths - The paths that we are actually interested in.\n * @return {boolean}             - Is the update relevant to the compared\n *                                 paths?\n */\nexport function solveUpdate(affectedPaths, comparedPaths) {\n  let i, j, k, l, m, n, p, c, s;\n\n  // Looping through possible paths\n  for (i = 0, l = affectedPaths.length; i < l; i++) {\n    p = affectedPaths[i];\n\n    if (!p.length)\n      return true;\n\n    // Looping through logged paths\n    for (j = 0, m = comparedPaths.length; j < m; j++) {\n      c = comparedPaths[j];\n\n      if (!c || !c.length)\n        return true;\n\n      // Looping through steps\n      for (k = 0, n = c.length; k < n; k++) {\n        s = c[k];\n\n        // If path is not relevant, we break\n        // NOTE: the '!=' instead of '!==' is required here!\n        if (s != p[k])\n          break;\n\n        // If we reached last item and we are relevant\n        if (k + 1 === n || k + 1 === p.length)\n          return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Non-mutative version of the splice array method.\n *\n * @param  {array}    array        - The array to splice.\n * @param  {integer}  startIndex   - The start index.\n * @param  {integer}  nb           - Number of elements to remove.\n * @param  {...mixed} elements     - Elements to append after splicing.\n * @return {array}                 - The spliced array.\n */\nexport function splice(array, startIndex, nb, ...elements) {\n  if (nb === undefined && arguments.length === 2)\n    nb = array.length - startIndex;\n  else if (nb === null || nb === undefined)\n    nb = 0;\n  else if (isNaN(+nb))\n    throw new Error(`argument nb ${nb} can not be parsed into a number!`);\n  nb = Math.max(0, nb);\n\n  // Solving startIndex\n  if (type.function(startIndex))\n    startIndex = index(array, startIndex);\n  if (type.object(startIndex))\n    startIndex = index(array, e => compare(e, startIndex));\n\n  // Positive index\n  if (startIndex >= 0)\n    return array\n      .slice(0, startIndex)\n      .concat(elements)\n      .concat(array.slice(startIndex + nb));\n\n  // Negative index\n  return array\n    .slice(0, array.length + startIndex)\n    .concat(elements)\n    .concat(array.slice(array.length + startIndex + nb));\n}\n\n/**\n * Function returning a unique incremental id each time it is called.\n *\n * @return {integer} - The latest unique id.\n */\nconst uniqid = (function() {\n  let i = 0;\n\n  return function() {\n    return i++;\n  };\n})();\n\nexport {uniqid};\n", "/**\n * Baobab Helpers Unit Tests\n * ==========================\n */\nimport {strict as assert} from 'assert';\nimport {\n  deepMerge,\n  getIn,\n  shallowMerge,\n  splice,\n  solveRelativePath\n// @ts-ignore\n} from '../../src/helpers';\n\ndescribe('Helpers', function() {\n\n  /**\n   * Nested getter\n   */\n  describe('GetIn', function() {\n    it('should return both data at path and solved path.', function() {\n      const data = {a: {b: {c: 'hey'}}};\n\n      assert.deepEqual(\n        getIn(data, ['a', 'b', 'c']),\n        {data: 'hey', solvedPath: ['a', 'b', 'c'], exists: true}\n      );\n    });\n\n    it('should also work with dynamic paths.', function() {\n      const data = {a: {b: [null, {id: 34}]}};\n\n      assert.deepEqual(\n        getIn(data, ['a', 'b', {id: 34}]),\n        {data: {id: 34}, solvedPath: ['a', 'b', 1], exists: true}\n      );\n    });\n\n    it('should return a not-found object when the data cannot be accessed.', function() {\n      const data = {a: null};\n\n      assert.deepEqual(\n        getIn(data, ['a', 'b', 'c']),\n        {data: undefined, solvedPath: ['a', 'b', 'c'], exists: false}\n      );\n\n      const otherData = {a: [{id: 45}]};\n\n      assert.deepEqual(\n        getIn(otherData, ['a', (e: any) => e.id === 46]),\n        {data: undefined, solvedPath: null, exists: false}\n      );\n    });\n  });\n\n  /**\n   * Merge\n   */\n  describe('Merge', function() {\n    it('should be possible to shallow merge objects.', function() {\n      const data = {a: 1, c: 3},\n            nestedData = {a: 1, b: {c: 2}};\n\n      assert.deepEqual(shallowMerge({}, data, {b: 2}), {a: 1, b: 2, c: 3});\n      assert.deepEqual(shallowMerge({}, nestedData, {b: {d: 3}}), {a: 1, b: {d: 3}});\n    });\n\n    it('the merge functions should be mutative.', function() {\n      const data = {a: 1, c: 3};\n\n      shallowMerge(data, {b: 2});\n\n      assert.deepEqual(data, {a: 1, b: 2, c: 3});\n    });\n\n    it('should be possible to deep merge objects.', function() {\n      const data = {inner: {a: 1, c: 3}};\n\n      assert.deepEqual(deepMerge({}, data, {inner: {b: 2}}), {inner: {a: 1, b: 2, c: 3}});\n    });\n\n    it('deep merge should avoid computed node keys.', function() {\n      const data = {a: 1, b: {c: 2, $facet: {d: 3}}};\n\n      assert.deepEqual(\n        deepMerge({}, data, {a: 5, b: {$facet: 'test'}}),\n        {a: 5, b: {c: 2, $facet: 'test'}}\n      );\n    });\n\n    it('should consider arrays are values.', function() {\n      assert.deepEqual(\n        deepMerge({}, {one: {two: [1, 2]}, three: 3}, {one: {two: [3, 4]}}),\n        {one: {two: [3, 4]}, three: 3}\n      );\n    });\n  });\n\n  /**\n   * Non-mutative splice\n   */\n  describe('Splice', function() {\n\n    it('should work in a non-mutative fashion.', function() {\n      const array = ['yellow', 'blue', 'purple'];\n\n      assert.deepEqual(\n        splice(array, 0, 0),\n        array\n      );\n\n      assert.deepEqual(\n        splice(array, 0, 1),\n        ['blue', 'purple']\n      );\n\n      assert.deepEqual(\n        splice(array, 1, 1),\n        ['yellow', 'purple']\n      );\n\n      assert.deepEqual(\n        splice(array, 2, 1),\n        ['yellow', 'blue']\n      );\n\n      assert.deepEqual(\n        splice(array, 2, 0),\n        array\n      );\n\n      assert.deepEqual(\n        splice(array, 1, 2),\n        ['yellow']\n      );\n\n      assert.deepEqual(\n        splice(array, 2, 1, 'orange', 'gold'),\n        ['yellow', 'blue', 'orange', 'gold']\n      );\n\n      assert.deepEqual(\n        splice(array, 5, 3),\n        array\n      );\n\n      assert.deepEqual(\n        splice(array, 5, 3, 'orange', 'gold'),\n        ['yellow', 'blue', 'purple', 'orange', 'gold']\n      );\n\n      assert.deepEqual(\n        splice(array, 1, 0, 'gold'),\n        ['yellow', 'gold', 'blue', 'purple']\n      );\n\n      assert.deepEqual(\n        splice(array, 1, 1, 'gold'),\n        ['yellow', 'gold', 'purple']\n      );\n    });\n\n    it('should treat a negative nb argument as 0.', function() {\n      const array = ['yellow', 'blue', 'purple'];\n\n      assert.deepEqual(\n        splice(array, 0, -1, 'gold'),\n        ['gold', 'yellow', 'blue', 'purple']\n      );\n    });\n\n    it('should properly handle negative indexes.', function() {\n      const array = [1, 2, 3, 4];\n\n      assert.deepEqual(\n        splice(array, -1, 1),\n        [1, 2, 3]\n      );\n\n      assert.deepEqual(\n        splice(array, -1, 0),\n        [1, 2, 3, 4]\n      );\n\n      assert.deepEqual(\n        splice(array, -2, 2),\n        [1, 2]\n      );\n\n      assert.deepEqual(\n        splice(array, -1, 1, 5),\n        [1, 2, 3, 5]\n      );\n\n      assert.deepEqual(\n        splice(array, -2, 1, 5),\n        [1, 2, 5, 4]\n      );\n\n      assert.deepEqual(\n        splice(array, -2, 1),\n        [1, 2, 4]\n      );\n\n      assert.deepEqual(\n        splice(['yellow', 'purple'], -1, 1),\n        ['yellow']\n      );\n    });\n\n    it('should handle predicates & descriptors as start index.', function() {\n      const collection = [\n        {name: 'John'},\n        {name: 'Jack'}\n      ];\n\n      assert.deepEqual(\n        splice(collection, (e: any) => e.name === 'Jack', 1, {name: 'Paul'}),\n        [{name: 'John'}, {name: 'Paul'}]\n      );\n\n      assert.deepEqual(\n        splice(collection, {name: 'Jack'}, 1, {name: 'Paul'}),\n        [{name: 'John'}, {name: 'Paul'}]\n      );\n    });\n\n    describe('Issue #472 - tree/cursor.splice does not conform with the specification as of ES6 (ECMAScript 2015)', function () {\n      it('should be possible to splice an array when omitting the nb (deleteCount) argument', function () {\n        const array = [0, 1, 2, 3, 4];\n\n        assert.deepEqual(splice(array, 2), [0, 1]);\n\n        assert.deepEqual(splice(array, -2), [0, 1, 2]);\n      });\n\n      it('should ignore the nb (deleteCount) argument when passing null, undefined, empty string, or false', function () {\n        const array = [0, 1, 2, 3, 4];\n\n        assert.deepEqual(splice(array, 2, null), [0, 1, 2, 3, 4], 'null for nb');\n        assert.deepEqual(splice(array, 2, null, 5), [0, 1, 5, 2, 3, 4], 'null for nb with new item');\n\n        assert.deepEqual(splice(array, 2, undefined), [0, 1, 2, 3, 4], 'undefined for nb');\n        assert.deepEqual(splice(array, 2, undefined, 5), [0, 1, 5, 2, 3, 4], 'undefined for nb with new item');\n\n        assert.deepEqual(splice(array, 2, ''), [0, 1, 2, 3, 4], '\"\" for nb');\n        assert.deepEqual(splice(array, 2, '', 5), [0, 1, 5, 2, 3, 4], '\"\" for nb with new item');\n\n        assert.deepEqual(splice(array, 2, false), [0, 1, 2, 3, 4], 'false for nb');\n        assert.deepEqual(splice(array, 2, false, 5), [0, 1, 5, 2, 3, 4], 'false for nb with new item');\n      });\n\n      it('should allow for nb (deleteCount) argument to be true, a coereced string, a decimal, or Infinity', function () {\n        const array = [0, 1, 2, 3, 4];\n\n        assert.deepEqual(splice(array, 2, true), [0, 1, 3, 4], 'true for nb');\n\n        assert.deepEqual(splice(array, 2, '1'), [0, 1, 3, 4], '\"1\" for nb');\n\n        assert.deepEqual(splice(array, 2, 1.2), [0, 1, 3, 4], '1.2 for nb');\n\n        assert.deepEqual(splice(array, 2, Infinity), [0, 1], 'Infinity for nb');\n      });\n\n      it('should throw an error when supplying an argument for nb (deleteCount) which is not parseable as number', function () {\n        const array = [0, 1, 2, 3, 4];\n\n        assert.throws(function() {\n          splice(array, 2, 'a');\n        }, Error);\n\n        assert.throws(function() {\n            splice(array, 2, {});\n        }, Error);\n      });\n    });\n  });\n\n  /**\n   * Solving relative paths\n   */\n  describe('Relative paths solving', function() {\n    it('should work for every cases.', function() {\n      const cases = [\n        [['one', 'two'], ['one', 'two']],\n        [['.', 'one', 'two'], ['base', 'sub', 'one', 'two']],\n        [['.', 'one', '.', 'two'], ['base', 'sub', 'one', 'two']],\n        [['one', 'two', '.'], ['one', 'two']],\n        [['..', 'one'], ['base', 'one']],\n        [['..', 'one', '..'], ['base']],\n        [['..', '..', '..', '..'], []],\n        [['..', '..', '..', 'base', '..', 'base'], ['base']]\n      ];\n\n      cases.forEach(([path, expected], i) => assert.deepEqual(solveRelativePath(['base', 'sub'], path), expected, 'N\u00b0 ' + i));\n    });\n  });\n});\n"], "fixing_code": ["/* eslint eqeqeq: 0 */\n/* eslint no-use-before-define: 0 */\n/**\n * Baobab Helpers\n * ===============\n *\n * Miscellaneous helper functions.\n */\nimport {Monkey, MonkeyDefinition} from './monkey';\nimport type from './type';\n\nconst hasOwnProp = {}.hasOwnProperty;\n\n/**\n * Function returning the index of the first element of a list matching the\n * given predicate.\n *\n * @param  {array}     a  - The target array.\n * @param  {function}  fn - The predicate function.\n * @return {mixed}        - The index of the first matching item or -1.\n */\nfunction index(a, fn) {\n  let i, l;\n  for (i = 0, l = a.length; i < l; i++) {\n    if (fn(a[i]))\n      return i;\n  }\n  return -1;\n}\n\n/**\n * Efficient slice function used to clone arrays or parts of them.\n *\n * @param  {array} array - The array to slice.\n * @return {array}       - The sliced array.\n */\nfunction slice(array) {\n  const newArray = new Array(array.length);\n\n  let i,\n      l;\n\n  for (i = 0, l = array.length; i < l; i++)\n    newArray[i] = array[i];\n\n  return newArray;\n}\n\n/**\n * Archive abstraction\n *\n * @constructor\n * @param {integer} size - Maximum number of records to store.\n */\nexport class Archive {\n  constructor(size) {\n    this.size = size;\n    this.records = [];\n  }\n\n  /**\n   * Method retrieving the records.\n   *\n   * @return {array} - The records.\n   */\n  get() {\n    return this.records;\n  }\n\n  /**\n   * Method adding a record to the archive\n   *\n   * @param {object}  record - The record to store.\n   * @return {Archive}       - The archive itself for chaining purposes.\n   */\n  add(record) {\n    this.records.unshift(record);\n\n    // If the number of records is exceeded, we truncate the records\n    if (this.records.length > this.size)\n      this.records.length = this.size;\n\n    return this;\n  }\n\n  /**\n   * Method clearing the records.\n   *\n   * @return {Archive} - The archive itself for chaining purposes.\n   */\n  clear() {\n    this.records = [];\n    return this;\n  }\n\n  /**\n   * Method to go back in time.\n   *\n   * @param {integer} steps - Number of steps we should go back by.\n   * @return {number}       - The last record.\n   */\n  back(steps) {\n    const record = this.records[steps - 1];\n\n    if (record)\n      this.records = this.records.slice(steps);\n    return record;\n  }\n}\n\n/**\n * Function creating a real array from what should be an array but is not.\n * I'm looking at you nasty `arguments`...\n *\n * @param  {mixed} culprit - The culprit to convert.\n * @return {array}         - The real array.\n */\nexport function arrayFrom(culprit) {\n  return slice(culprit);\n}\n\n/**\n * Function decorating one function with another that will be called before the\n * decorated one.\n *\n * @param  {function} decorator - The decorating function.\n * @param  {function} fn        - The function to decorate.\n * @return {function}           - The decorated function.\n */\nexport function before(decorator, fn) {\n  return function() {\n    decorator.apply(null, arguments);\n    fn.apply(null, arguments);\n  };\n}\n\n/**\n * Function cloning the given regular expression. Supports `y` and `u` flags\n * already.\n *\n * @param  {RegExp} re - The target regular expression.\n * @return {RegExp}    - The cloned regular expression.\n */\nfunction cloneRegexp(re) {\n  const pattern = re.source;\n\n  let flags = '';\n\n  if (re.global) flags += 'g';\n  if (re.multiline) flags += 'm';\n  if (re.ignoreCase) flags += 'i';\n  if (re.sticky) flags += 'y';\n  if (re.unicode) flags += 'u';\n\n  return new RegExp(pattern, flags);\n}\n\n/**\n * Function cloning the given variable.\n *\n * @todo: implement a faster way to clone an array.\n *\n * @param  {boolean} deep - Should we deep clone the variable.\n * @param  {mixed}   item - The variable to clone\n * @return {mixed}        - The cloned variable.\n */\nfunction cloner(deep, item) {\n  if (!item ||\n      typeof item !== 'object' ||\n      item instanceof Error ||\n      item instanceof MonkeyDefinition ||\n      item instanceof Monkey ||\n      ('ArrayBuffer' in global && item instanceof ArrayBuffer))\n    return item;\n\n  // Array\n  if (type.array(item)) {\n    if (deep) {\n      const a = new Array(item.length);\n\n      for (let i = 0, l = item.length; i < l; i++)\n        a[i] = cloner(true, item[i]);\n      return a;\n    }\n\n    return slice(item);\n  }\n\n  // Date\n  if (item instanceof Date)\n    return new Date(item.getTime());\n\n  // RegExp\n  if (item instanceof RegExp)\n    return cloneRegexp(item);\n\n  // Object\n  if (type.object(item)) {\n    const o = {};\n\n    // NOTE: could be possible to erase computed properties through `null`.\n    const props = Object.getOwnPropertyNames(item);\n    for (let i = 0, l = props.length; i < l; i++) {\n      const name = props[i];\n      const k = Object.getOwnPropertyDescriptor(item, name);\n      if (k.enumerable === true) {\n        if (k.get && k.get.isLazyGetter) {\n          Object.defineProperty(o, name, {\n            get: k.get,\n            enumerable: true,\n            configurable: true\n          });\n        }\n        else {\n          o[name] = deep ? cloner(true, item[name]) : item[name];\n        }\n      }\n      else if (k.enumerable === false) {\n        Object.defineProperty(o, name, {\n          value: deep ? cloner(true, k.value) : k.value,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        });\n      }\n    }\n    return o;\n  }\n\n  return item;\n}\n\n/**\n * Exporting shallow and deep cloning functions.\n */\nconst shallowClone = cloner.bind(null, false),\n      deepClone = cloner.bind(null, true);\n\nexport {shallowClone, deepClone};\n\n/**\n * Coerce the given variable into a full-fledged path.\n *\n * @param  {mixed} target - The variable to coerce.\n * @return {array}        - The array path.\n */\nexport function coercePath(target) {\n  if (target || target === 0 || target === '')\n    return target;\n  return [];\n}\n\n/**\n * Function comparing an object's properties to a given descriptive\n * object.\n *\n * @param  {object} object      - The object to compare.\n * @param  {object} description - The description's mapping.\n * @return {boolean}            - Whether the object matches the description.\n */\nfunction compare(object, description) {\n  let ok = true,\n      k;\n\n  // If we reached here via a recursive call, object may be undefined because\n  // not all items in a collection will have the same deep nesting structure.\n  if (!object)\n    return false;\n\n  for (k in description) {\n    if (type.object(description[k])) {\n      ok = ok && compare(object[k], description[k]);\n    }\n    else if (type.array(description[k])) {\n      ok = ok && !!~description[k].indexOf(object[k]);\n    }\n    else {\n      if (object[k] !== description[k])\n        return false;\n    }\n  }\n\n  return ok;\n}\n\n/**\n * Function freezing the given variable if possible.\n *\n * @param  {boolean} deep - Should we recursively freeze the given objects?\n * @param  {object}  o    - The variable to freeze.\n * @return {object}    - The merged object.\n */\nfunction freezer(deep, o) {\n  if (typeof o !== 'object' ||\n      o === null ||\n      o instanceof Monkey)\n    return;\n\n  Object.freeze(o);\n\n  if (!deep)\n    return;\n\n  if (Array.isArray(o)) {\n\n    // Iterating through the elements\n    let i,\n        l;\n\n    for (i = 0, l = o.length; i < l; i++)\n      deepFreeze(o[i]);\n  }\n  else {\n    let p,\n        k;\n\n    for (k in o) {\n      if (type.lazyGetter(o, k))\n        continue;\n\n      p = o[k];\n\n      if (!p ||\n          !hasOwnProp.call(o, k) ||\n          typeof p !== 'object' ||\n          Object.isFrozen(p))\n        continue;\n\n      deepFreeze(p);\n    }\n  }\n}\n\nconst freeze = freezer.bind(null, false),\n      deepFreeze = freezer.bind(null, true);\n\nexport {freeze, deepFreeze};\n\n/**\n * Function retrieving nested data within the given object and according to\n * the given path.\n *\n * @todo: work if dynamic path hit objects also.\n * @todo: memoized perfgetters.\n *\n * @param  {object}  object - The object we need to get data from.\n * @param  {array}   path   - The path to follow.\n * @return {object}  result            - The result.\n * @return {mixed}   result.data       - The data at path, or `undefined`.\n * @return {array}   result.solvedPath - The solved path or `null`.\n * @return {boolean} result.exists     - Does the path exists in the tree?\n */\nconst NOT_FOUND_OBJECT = {data: undefined, solvedPath: null, exists: false};\n\nexport function getIn(object, path) {\n  if (!path)\n    return NOT_FOUND_OBJECT;\n\n  const solvedPath = [];\n\n  let exists = true,\n      c = object,\n      idx,\n      i,\n      l;\n\n  for (i = 0, l = path.length; i < l; i++) {\n    if (!c)\n      return {\n        data: undefined,\n        solvedPath: solvedPath.concat(path.slice(i)),\n        exists: false\n      };\n\n    if (typeof path[i] === 'function') {\n      if (!type.array(c))\n        return NOT_FOUND_OBJECT;\n\n      idx = index(c, path[i]);\n      if (!~idx)\n        return NOT_FOUND_OBJECT;\n\n      solvedPath.push(idx);\n      c = c[idx];\n    }\n    else if (typeof path[i] === 'object') {\n      if (!type.array(c))\n        return NOT_FOUND_OBJECT;\n\n      idx = index(c, e => compare(e, path[i]));\n      if (!~idx)\n        return NOT_FOUND_OBJECT;\n\n      solvedPath.push(idx);\n      c = c[idx];\n    }\n    else {\n      solvedPath.push(path[i]);\n      exists = typeof c === 'object' && path[i] in c;\n      c = c[path[i]];\n    }\n  }\n\n  return {data: c, solvedPath, exists};\n}\n\n/**\n * Little helper returning a JavaScript error carrying some data with it.\n *\n * @param  {string} message - The error message.\n * @param  {object} [data]  - Optional data to assign to the error.\n * @return {Error}          - The created error.\n */\nexport function makeError(message, data) {\n  const err = new Error(message);\n\n  for (const k in data)\n    err[k] = data[k];\n\n  return err;\n}\n\n/**\n * Function taking n objects to merge them together.\n * Note 1): the latter object will take precedence over the first one.\n * Note 2): the first object will be mutated to allow for perf scenarios.\n * Note 3): this function will consider monkeys as leaves.\n *\n * @param  {boolean}   deep    - Whether the merge should be deep or not.\n * @param  {...object} objects - Objects to merge.\n * @return {object}            - The merged object.\n */\nfunction merger(deep, ...objects) {\n  const o = objects[0];\n\n  let t,\n      i,\n      l,\n      k;\n\n  for (i = 1, l = objects.length; i < l; i++) {\n    t = objects[i];\n\n    for (k in t) {\n      if (deep &&\n          type.object(t[k]) &&\n          !(t[k] instanceof Monkey) &&\n          !(k === '__proto__' || k === 'constructor' || k === 'prototype')) {\n        o[k] = merger(true, o[k] || {}, t[k]);\n      }\n      else {\n        o[k] = t[k];\n      }\n    }\n  }\n\n  return o;\n}\n\n/**\n * Exporting both `shallowMerge` and `deepMerge` functions.\n */\nconst shallowMerge = merger.bind(null, false),\n      deepMerge = merger.bind(null, true);\n\nexport {shallowMerge, deepMerge};\n\n/**\n * Function returning a string hash from a non-dynamic path expressed as an\n * array.\n *\n * @param  {array}  path - The path to hash.\n * @return {string} string - The resultant hash.\n */\nexport function hashPath(path) {\n  return '\u03bb' + path.map(step => {\n    if (type.function(step) || type.object(step))\n      return `#${uniqid()}#`;\n\n    return step;\n  }).join('\u03bb');\n}\n\n/**\n * Solving a potentially relative path.\n *\n * @param  {array} base - The base path from which to solve the path.\n * @param  {array} to   - The subpath to reach.\n * @param  {array}      - The solved absolute path.\n */\nexport function solveRelativePath(base, to) {\n  let solvedPath = [];\n\n  // Coercing to array\n  to = [].concat(to);\n\n  for (let i = 0, l = to.length; i < l; i++) {\n    const step = to[i];\n\n    if (step === '.') {\n      if (!i)\n        solvedPath = base.slice(0);\n    }\n    else if (step === '..') {\n      solvedPath = (!i ? base : solvedPath).slice(0, -1);\n    }\n    else {\n      solvedPath.push(step);\n    }\n  }\n\n  return solvedPath;\n}\n\n/**\n * Function determining whether some paths in the tree were affected by some\n * updates that occurred at the given paths. This helper is mainly used at\n * cursor level to determine whether the cursor is concerned by the updates\n * fired at tree level.\n *\n * NOTES: 1) If performance become an issue, the following threefold loop\n *           can be simplified to a complex twofold one.\n *        2) A regex version could also work but I am not confident it would\n *           be faster.\n *        3) Another solution would be to keep a register of cursors like with\n *           the monkeys and update along this tree.\n *\n * @param  {array} affectedPaths - The paths that were updated.\n * @param  {array} comparedPaths - The paths that we are actually interested in.\n * @return {boolean}             - Is the update relevant to the compared\n *                                 paths?\n */\nexport function solveUpdate(affectedPaths, comparedPaths) {\n  let i, j, k, l, m, n, p, c, s;\n\n  // Looping through possible paths\n  for (i = 0, l = affectedPaths.length; i < l; i++) {\n    p = affectedPaths[i];\n\n    if (!p.length)\n      return true;\n\n    // Looping through logged paths\n    for (j = 0, m = comparedPaths.length; j < m; j++) {\n      c = comparedPaths[j];\n\n      if (!c || !c.length)\n        return true;\n\n      // Looping through steps\n      for (k = 0, n = c.length; k < n; k++) {\n        s = c[k];\n\n        // If path is not relevant, we break\n        // NOTE: the '!=' instead of '!==' is required here!\n        if (s != p[k])\n          break;\n\n        // If we reached last item and we are relevant\n        if (k + 1 === n || k + 1 === p.length)\n          return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Non-mutative version of the splice array method.\n *\n * @param  {array}    array        - The array to splice.\n * @param  {integer}  startIndex   - The start index.\n * @param  {integer}  nb           - Number of elements to remove.\n * @param  {...mixed} elements     - Elements to append after splicing.\n * @return {array}                 - The spliced array.\n */\nexport function splice(array, startIndex, nb, ...elements) {\n  if (nb === undefined && arguments.length === 2)\n    nb = array.length - startIndex;\n  else if (nb === null || nb === undefined)\n    nb = 0;\n  else if (isNaN(+nb))\n    throw new Error(`argument nb ${nb} can not be parsed into a number!`);\n  nb = Math.max(0, nb);\n\n  // Solving startIndex\n  if (type.function(startIndex))\n    startIndex = index(array, startIndex);\n  if (type.object(startIndex))\n    startIndex = index(array, e => compare(e, startIndex));\n\n  // Positive index\n  if (startIndex >= 0)\n    return array\n      .slice(0, startIndex)\n      .concat(elements)\n      .concat(array.slice(startIndex + nb));\n\n  // Negative index\n  return array\n    .slice(0, array.length + startIndex)\n    .concat(elements)\n    .concat(array.slice(array.length + startIndex + nb));\n}\n\n/**\n * Function returning a unique incremental id each time it is called.\n *\n * @return {integer} - The latest unique id.\n */\nconst uniqid = (function() {\n  let i = 0;\n\n  return function() {\n    return i++;\n  };\n})();\n\nexport {uniqid};\n", "/**\n * Baobab Helpers Unit Tests\n * ==========================\n */\nimport {strict as assert} from 'assert';\nimport {\n  deepMerge,\n  getIn,\n  shallowMerge,\n  splice,\n  solveRelativePath\n// @ts-ignore\n} from '../../src/helpers';\n\ndescribe('Helpers', function() {\n\n  /**\n   * Nested getter\n   */\n  describe('GetIn', function() {\n    it('should return both data at path and solved path.', function() {\n      const data = {a: {b: {c: 'hey'}}};\n\n      assert.deepEqual(\n        getIn(data, ['a', 'b', 'c']),\n        {data: 'hey', solvedPath: ['a', 'b', 'c'], exists: true}\n      );\n    });\n\n    it('should also work with dynamic paths.', function() {\n      const data = {a: {b: [null, {id: 34}]}};\n\n      assert.deepEqual(\n        getIn(data, ['a', 'b', {id: 34}]),\n        {data: {id: 34}, solvedPath: ['a', 'b', 1], exists: true}\n      );\n    });\n\n    it('should return a not-found object when the data cannot be accessed.', function() {\n      const data = {a: null};\n\n      assert.deepEqual(\n        getIn(data, ['a', 'b', 'c']),\n        {data: undefined, solvedPath: ['a', 'b', 'c'], exists: false}\n      );\n\n      const otherData = {a: [{id: 45}]};\n\n      assert.deepEqual(\n        getIn(otherData, ['a', (e: any) => e.id === 46]),\n        {data: undefined, solvedPath: null, exists: false}\n      );\n    });\n  });\n\n  /**\n   * Merge\n   */\n  describe('Merge', function() {\n    it('should be possible to shallow merge objects.', function() {\n      const data = {a: 1, c: 3},\n            nestedData = {a: 1, b: {c: 2}};\n\n      assert.deepEqual(shallowMerge({}, data, {b: 2}), {a: 1, b: 2, c: 3});\n      assert.deepEqual(shallowMerge({}, nestedData, {b: {d: 3}}), {a: 1, b: {d: 3}});\n    });\n\n    it('the merge functions should be mutative.', function() {\n      const data = {a: 1, c: 3};\n\n      shallowMerge(data, {b: 2});\n\n      assert.deepEqual(data, {a: 1, b: 2, c: 3});\n    });\n\n    it('should be possible to deep merge objects.', function() {\n      const data = {inner: {a: 1, c: 3}};\n\n      assert.deepEqual(deepMerge({}, data, {inner: {b: 2}}), {inner: {a: 1, b: 2, c: 3}});\n    });\n\n    it('deep merge should avoid computed node keys.', function() {\n      const data = {a: 1, b: {c: 2, $facet: {d: 3}}};\n\n      assert.deepEqual(\n        deepMerge({}, data, {a: 5, b: {$facet: 'test'}}),\n        {a: 5, b: {c: 2, $facet: 'test'}}\n      );\n    });\n\n    it('should consider arrays are values.', function() {\n      assert.deepEqual(\n        deepMerge({}, {one: {two: [1, 2]}, three: 3}, {one: {two: [3, 4]}}),\n        {one: {two: [3, 4]}, three: 3}\n      );\n    });\n\n    it('merge should not pollute object prototype.', function() {\n      const data = JSON.parse('{\"__proto__\": {\"polluted\": true}}');\n\n      deepMerge({}, data);\n\n      assert.equal(Object.keys(Object.prototype).includes('polluted'), false);\n    });\n  });\n\n  /**\n   * Non-mutative splice\n   */\n  describe('Splice', function() {\n\n    it('should work in a non-mutative fashion.', function() {\n      const array = ['yellow', 'blue', 'purple'];\n\n      assert.deepEqual(\n        splice(array, 0, 0),\n        array\n      );\n\n      assert.deepEqual(\n        splice(array, 0, 1),\n        ['blue', 'purple']\n      );\n\n      assert.deepEqual(\n        splice(array, 1, 1),\n        ['yellow', 'purple']\n      );\n\n      assert.deepEqual(\n        splice(array, 2, 1),\n        ['yellow', 'blue']\n      );\n\n      assert.deepEqual(\n        splice(array, 2, 0),\n        array\n      );\n\n      assert.deepEqual(\n        splice(array, 1, 2),\n        ['yellow']\n      );\n\n      assert.deepEqual(\n        splice(array, 2, 1, 'orange', 'gold'),\n        ['yellow', 'blue', 'orange', 'gold']\n      );\n\n      assert.deepEqual(\n        splice(array, 5, 3),\n        array\n      );\n\n      assert.deepEqual(\n        splice(array, 5, 3, 'orange', 'gold'),\n        ['yellow', 'blue', 'purple', 'orange', 'gold']\n      );\n\n      assert.deepEqual(\n        splice(array, 1, 0, 'gold'),\n        ['yellow', 'gold', 'blue', 'purple']\n      );\n\n      assert.deepEqual(\n        splice(array, 1, 1, 'gold'),\n        ['yellow', 'gold', 'purple']\n      );\n    });\n\n    it('should treat a negative nb argument as 0.', function() {\n      const array = ['yellow', 'blue', 'purple'];\n\n      assert.deepEqual(\n        splice(array, 0, -1, 'gold'),\n        ['gold', 'yellow', 'blue', 'purple']\n      );\n    });\n\n    it('should properly handle negative indexes.', function() {\n      const array = [1, 2, 3, 4];\n\n      assert.deepEqual(\n        splice(array, -1, 1),\n        [1, 2, 3]\n      );\n\n      assert.deepEqual(\n        splice(array, -1, 0),\n        [1, 2, 3, 4]\n      );\n\n      assert.deepEqual(\n        splice(array, -2, 2),\n        [1, 2]\n      );\n\n      assert.deepEqual(\n        splice(array, -1, 1, 5),\n        [1, 2, 3, 5]\n      );\n\n      assert.deepEqual(\n        splice(array, -2, 1, 5),\n        [1, 2, 5, 4]\n      );\n\n      assert.deepEqual(\n        splice(array, -2, 1),\n        [1, 2, 4]\n      );\n\n      assert.deepEqual(\n        splice(['yellow', 'purple'], -1, 1),\n        ['yellow']\n      );\n    });\n\n    it('should handle predicates & descriptors as start index.', function() {\n      const collection = [\n        {name: 'John'},\n        {name: 'Jack'}\n      ];\n\n      assert.deepEqual(\n        splice(collection, (e: any) => e.name === 'Jack', 1, {name: 'Paul'}),\n        [{name: 'John'}, {name: 'Paul'}]\n      );\n\n      assert.deepEqual(\n        splice(collection, {name: 'Jack'}, 1, {name: 'Paul'}),\n        [{name: 'John'}, {name: 'Paul'}]\n      );\n    });\n\n    describe('Issue #472 - tree/cursor.splice does not conform with the specification as of ES6 (ECMAScript 2015)', function () {\n      it('should be possible to splice an array when omitting the nb (deleteCount) argument', function () {\n        const array = [0, 1, 2, 3, 4];\n\n        assert.deepEqual(splice(array, 2), [0, 1]);\n\n        assert.deepEqual(splice(array, -2), [0, 1, 2]);\n      });\n\n      it('should ignore the nb (deleteCount) argument when passing null, undefined, empty string, or false', function () {\n        const array = [0, 1, 2, 3, 4];\n\n        assert.deepEqual(splice(array, 2, null), [0, 1, 2, 3, 4], 'null for nb');\n        assert.deepEqual(splice(array, 2, null, 5), [0, 1, 5, 2, 3, 4], 'null for nb with new item');\n\n        assert.deepEqual(splice(array, 2, undefined), [0, 1, 2, 3, 4], 'undefined for nb');\n        assert.deepEqual(splice(array, 2, undefined, 5), [0, 1, 5, 2, 3, 4], 'undefined for nb with new item');\n\n        assert.deepEqual(splice(array, 2, ''), [0, 1, 2, 3, 4], '\"\" for nb');\n        assert.deepEqual(splice(array, 2, '', 5), [0, 1, 5, 2, 3, 4], '\"\" for nb with new item');\n\n        assert.deepEqual(splice(array, 2, false), [0, 1, 2, 3, 4], 'false for nb');\n        assert.deepEqual(splice(array, 2, false, 5), [0, 1, 5, 2, 3, 4], 'false for nb with new item');\n      });\n\n      it('should allow for nb (deleteCount) argument to be true, a coereced string, a decimal, or Infinity', function () {\n        const array = [0, 1, 2, 3, 4];\n\n        assert.deepEqual(splice(array, 2, true), [0, 1, 3, 4], 'true for nb');\n\n        assert.deepEqual(splice(array, 2, '1'), [0, 1, 3, 4], '\"1\" for nb');\n\n        assert.deepEqual(splice(array, 2, 1.2), [0, 1, 3, 4], '1.2 for nb');\n\n        assert.deepEqual(splice(array, 2, Infinity), [0, 1], 'Infinity for nb');\n      });\n\n      it('should throw an error when supplying an argument for nb (deleteCount) which is not parseable as number', function () {\n        const array = [0, 1, 2, 3, 4];\n\n        assert.throws(function() {\n          splice(array, 2, 'a');\n        }, Error);\n\n        assert.throws(function() {\n            splice(array, 2, {});\n        }, Error);\n      });\n    });\n  });\n\n  /**\n   * Solving relative paths\n   */\n  describe('Relative paths solving', function() {\n    it('should work for every cases.', function() {\n      const cases = [\n        [['one', 'two'], ['one', 'two']],\n        [['.', 'one', 'two'], ['base', 'sub', 'one', 'two']],\n        [['.', 'one', '.', 'two'], ['base', 'sub', 'one', 'two']],\n        [['one', 'two', '.'], ['one', 'two']],\n        [['..', 'one'], ['base', 'one']],\n        [['..', 'one', '..'], ['base']],\n        [['..', '..', '..', '..'], []],\n        [['..', '..', '..', 'base', '..', 'base'], ['base']]\n      ];\n\n      cases.forEach(([path, expected], i) => assert.deepEqual(solveRelativePath(['base', 'sub'], path), expected, 'N\u00b0 ' + i));\n    });\n  });\n});\n"], "filenames": ["src/helpers.js", "test/suites/helpers.ts"], "buggy_code_start_loc": [447, 95], "buggy_code_end_loc": [448, 95], "fixing_code_start_loc": [447, 96], "fixing_code_end_loc": [449, 104], "type": "CWE-1321", "message": "A vulnerability was found in Yomguithereal Baobab up to 2.6.0. It has been declared as critical. Affected by this vulnerability is an unknown functionality. The manipulation leads to improperly controlled modification of object prototype attributes ('prototype pollution'). The attack can be launched remotely. Upgrading to version 2.6.1 is able to address this issue. The name of the patch is c56639532a923d9a1600fb863ec7551b188b5d19. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-217627.", "other": {"cve": {"id": "CVE-2021-4307", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-07T20:15:09.623", "lastModified": "2023-01-12T20:34:50.617", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in Yomguithereal Baobab up to 2.6.0. It has been declared as critical. Affected by this vulnerability is an unknown functionality. The manipulation leads to improperly controlled modification of object prototype attributes ('prototype pollution'). The attack can be launched remotely. Upgrading to version 2.6.1 is able to address this issue. The name of the patch is c56639532a923d9a1600fb863ec7551b188b5d19. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-217627."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:baobab_project:baobab:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.6.1", "matchCriteriaId": "590751DC-51A5-4A1B-86E0-BCD329C22D7A"}]}]}], "references": [{"url": "https://github.com/Yomguithereal/baobab/commit/c56639532a923d9a1600fb863ec7551b188b5d19", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Yomguithereal/baobab/pull/511", "source": "cna@vuldb.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/Yomguithereal/baobab/releases/tag/2.6.1", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217627", "source": "cna@vuldb.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://vuldb.com/?id.217627", "source": "cna@vuldb.com", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/Yomguithereal/baobab/commit/c56639532a923d9a1600fb863ec7551b188b5d19"}}