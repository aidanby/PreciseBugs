{"buggy_code": ["/*\n * L2TPv3 IP encapsulation support\n *\n * Copyright (c) 2008,2009,2010 Katalix Systems Ltd\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License\n *\tas published by the Free Software Foundation; either version\n *\t2 of the License, or (at your option) any later version.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/icmp.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/random.h>\n#include <linux/socket.h>\n#include <linux/l2tp.h>\n#include <linux/in.h>\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/udp.h>\n#include <net/inet_common.h>\n#include <net/inet_hashtables.h>\n#include <net/tcp_states.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n\n#include \"l2tp_core.h\"\n\nstruct l2tp_ip_sock {\n\t/* inet_sock has to be the first member of l2tp_ip_sock */\n\tstruct inet_sock\tinet;\n\n\tu32\t\t\tconn_id;\n\tu32\t\t\tpeer_conn_id;\n};\n\nstatic DEFINE_RWLOCK(l2tp_ip_lock);\nstatic struct hlist_head l2tp_ip_table;\nstatic struct hlist_head l2tp_ip_bind_table;\n\nstatic inline struct l2tp_ip_sock *l2tp_ip_sk(const struct sock *sk)\n{\n\treturn (struct l2tp_ip_sock *)sk;\n}\n\nstatic struct sock *__l2tp_ip_bind_lookup(struct net *net, __be32 laddr, int dif, u32 tunnel_id)\n{\n\tstruct sock *sk;\n\n\tsk_for_each_bound(sk, &l2tp_ip_bind_table) {\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\t\tstruct l2tp_ip_sock *l2tp = l2tp_ip_sk(sk);\n\n\t\tif (l2tp == NULL)\n\t\t\tcontinue;\n\n\t\tif ((l2tp->conn_id == tunnel_id) &&\n\t\t    net_eq(sock_net(sk), net) &&\n\t\t    !(inet->inet_rcv_saddr && inet->inet_rcv_saddr != laddr) &&\n\t\t    !(sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif))\n\t\t\tgoto found;\n\t}\n\n\tsk = NULL;\nfound:\n\treturn sk;\n}\n\nstatic inline struct sock *l2tp_ip_bind_lookup(struct net *net, __be32 laddr, int dif, u32 tunnel_id)\n{\n\tstruct sock *sk = __l2tp_ip_bind_lookup(net, laddr, dif, tunnel_id);\n\tif (sk)\n\t\tsock_hold(sk);\n\n\treturn sk;\n}\n\n/* When processing receive frames, there are two cases to\n * consider. Data frames consist of a non-zero session-id and an\n * optional cookie. Control frames consist of a regular L2TP header\n * preceded by 32-bits of zeros.\n *\n * L2TPv3 Session Header Over IP\n *\n *  0                   1                   2                   3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |                           Session ID                          |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |               Cookie (optional, maximum 64 bits)...\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *                                                                 |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * L2TPv3 Control Message Header Over IP\n *\n *  0                   1                   2                   3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |                      (32 bits of zeros)                       |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |T|L|x|x|S|x|x|x|x|x|x|x|  Ver  |             Length            |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |                     Control Connection ID                     |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |               Ns              |               Nr              |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * All control frames are passed to userspace.\n */\nstatic int l2tp_ip_recv(struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk;\n\tu32 session_id;\n\tu32 tunnel_id;\n\tunsigned char *ptr, *optr;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel = NULL;\n\tint length;\n\n\tif (!pskb_may_pull(skb, 4))\n\t\tgoto discard;\n\n\t/* Point to L2TP header */\n\toptr = ptr = skb->data;\n\tsession_id = ntohl(*((__be32 *) ptr));\n\tptr += 4;\n\n\t/* RFC3931: L2TP/IP packets have the first 4 bytes containing\n\t * the session_id. If it is 0, the packet is a L2TP control\n\t * frame and the session_id value can be discarded.\n\t */\n\tif (session_id == 0) {\n\t\t__skb_pull(skb, 4);\n\t\tgoto pass_up;\n\t}\n\n\t/* Ok, this is a data packet. Lookup the session. */\n\tsession = l2tp_session_find(net, NULL, session_id);\n\tif (session == NULL)\n\t\tgoto discard;\n\n\ttunnel = session->tunnel;\n\tif (tunnel == NULL)\n\t\tgoto discard;\n\n\t/* Trace packet contents, if enabled */\n\tif (tunnel->debug & L2TP_MSG_DATA) {\n\t\tlength = min(32u, skb->len);\n\t\tif (!pskb_may_pull(skb, length))\n\t\t\tgoto discard;\n\n\t\t/* Point to L2TP header */\n\t\toptr = ptr = skb->data;\n\t\tptr += 4;\n\t\tpr_debug(\"%s: ip recv\\n\", tunnel->name);\n\t\tprint_hex_dump_bytes(\"\", DUMP_PREFIX_OFFSET, ptr, length);\n\t}\n\n\tl2tp_recv_common(session, skb, ptr, optr, 0, skb->len, tunnel->recv_payload_hook);\n\n\treturn 0;\n\npass_up:\n\t/* Get the tunnel_id from the L2TP header */\n\tif (!pskb_may_pull(skb, 12))\n\t\tgoto discard;\n\n\tif ((skb->data[0] & 0xc0) != 0xc0)\n\t\tgoto discard;\n\n\ttunnel_id = ntohl(*(__be32 *) &skb->data[4]);\n\ttunnel = l2tp_tunnel_find(net, tunnel_id);\n\tif (tunnel != NULL)\n\t\tsk = tunnel->sock;\n\telse {\n\t\tstruct iphdr *iph = (struct iphdr *) skb_network_header(skb);\n\n\t\tread_lock_bh(&l2tp_ip_lock);\n\t\tsk = __l2tp_ip_bind_lookup(net, iph->daddr, 0, tunnel_id);\n\t\tread_unlock_bh(&l2tp_ip_lock);\n\t}\n\n\tif (sk == NULL)\n\t\tgoto discard;\n\n\tsock_hold(sk);\n\n\tif (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_put;\n\n\tnf_reset(skb);\n\n\treturn sk_receive_skb(sk, skb, 1);\n\ndiscard_put:\n\tsock_put(sk);\n\ndiscard:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int l2tp_ip_open(struct sock *sk)\n{\n\t/* Prevent autobind. We don't have ports. */\n\tinet_sk(sk)->inet_num = IPPROTO_L2TP;\n\n\twrite_lock_bh(&l2tp_ip_lock);\n\tsk_add_node(sk, &l2tp_ip_table);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\n\treturn 0;\n}\n\nstatic void l2tp_ip_close(struct sock *sk, long timeout)\n{\n\twrite_lock_bh(&l2tp_ip_lock);\n\thlist_del_init(&sk->sk_bind_node);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\tsk_common_release(sk);\n}\n\nstatic void l2tp_ip_destroy_sock(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\tstruct l2tp_tunnel *tunnel = l2tp_sock_to_tunnel(sk);\n\n\twhile ((skb = __skb_dequeue_tail(&sk->sk_write_queue)) != NULL)\n\t\tkfree_skb(skb);\n\n\tif (tunnel) {\n\t\tl2tp_tunnel_closeall(tunnel);\n\t\tsock_put(sk);\n\t}\n\n\tsk_refcnt_debug_dec(sk);\n}\n\nstatic int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;\n\tstruct net *net = sock_net(sk);\n\tint ret;\n\tint chk_addr_ret;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n\tif (addr_len < sizeof(struct sockaddr_l2tpip))\n\t\treturn -EINVAL;\n\tif (addr->l2tp_family != AF_INET)\n\t\treturn -EINVAL;\n\n\tret = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip_lock);\n\tif (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,\n\t\t\t\t  sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\n\tread_unlock_bh(&l2tp_ip_lock);\n\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))\n\t\tgoto out;\n\n\tchk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);\n\tret = -EADDRNOTAVAIL;\n\tif (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&\n\t    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)\n\t\tgoto out;\n\n\tif (addr->l2tp_addr.s_addr)\n\t\tinet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;\n\tif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\n\t\tinet->inet_saddr = 0;  /* Use device */\n\tsk_dst_reset(sk);\n\n\tl2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip_lock);\n\tsk_add_bind_node(sk, &l2tp_ip_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\tret = 0;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\nout:\n\trelease_sock(sk);\n\n\treturn ret;\n\nout_in_use:\n\tread_unlock_bh(&l2tp_ip_lock);\n\n\treturn ret;\n}\n\nstatic int l2tp_ip_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sockaddr_l2tpip *lsa = (struct sockaddr_l2tpip *) uaddr;\n\tint rc;\n\n\tif (sock_flag(sk, SOCK_ZAPPED)) /* Must bind first - autobinding does not work */\n\t\treturn -EINVAL;\n\n\tif (addr_len < sizeof(*lsa))\n\t\treturn -EINVAL;\n\n\tif (ipv4_is_multicast(lsa->l2tp_addr.s_addr))\n\t\treturn -EINVAL;\n\n\trc = ip4_datagram_connect(sk, uaddr, addr_len);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tlock_sock(sk);\n\n\tl2tp_ip_sk(sk)->peer_conn_id = lsa->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip_lock);\n\thlist_del_init(&sk->sk_bind_node);\n\tsk_add_bind_node(sk, &l2tp_ip_bind_table);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\n\trelease_sock(sk);\n\treturn rc;\n}\n\nstatic int l2tp_ip_disconnect(struct sock *sk, int flags)\n{\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\treturn 0;\n\n\treturn __udp_disconnect(sk, flags);\n}\n\nstatic int l2tp_ip_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t   int *uaddr_len, int peer)\n{\n\tstruct sock *sk\t\t= sock->sk;\n\tstruct inet_sock *inet\t= inet_sk(sk);\n\tstruct l2tp_ip_sock *lsk = l2tp_ip_sk(sk);\n\tstruct sockaddr_l2tpip *lsa = (struct sockaddr_l2tpip *)uaddr;\n\n\tmemset(lsa, 0, sizeof(*lsa));\n\tlsa->l2tp_family = AF_INET;\n\tif (peer) {\n\t\tif (!inet->inet_dport)\n\t\t\treturn -ENOTCONN;\n\t\tlsa->l2tp_conn_id = lsk->peer_conn_id;\n\t\tlsa->l2tp_addr.s_addr = inet->inet_daddr;\n\t} else {\n\t\t__be32 addr = inet->inet_rcv_saddr;\n\t\tif (!addr)\n\t\t\taddr = inet->inet_saddr;\n\t\tlsa->l2tp_conn_id = lsk->conn_id;\n\t\tlsa->l2tp_addr.s_addr = addr;\n\t}\n\t*uaddr_len = sizeof(*lsa);\n\treturn 0;\n}\n\nstatic int l2tp_ip_backlog_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\n\t/* Charge it to the socket, dropping if the queue is full. */\n\trc = sock_queue_rcv_skb(sk, skb);\n\tif (rc < 0)\n\t\tgoto drop;\n\n\treturn 0;\n\ndrop:\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_INDISCARDS);\n\tkfree_skb(skb);\n\treturn -1;\n}\n\n/* Userspace will call sendmsg() on the tunnel socket to send L2TP\n * control frames.\n */\nstatic int l2tp_ip_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *skb;\n\tint rc;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 *fl4;\n\tint connected = 0;\n\t__be32 daddr;\n\n\tlock_sock(sk);\n\n\trc = -ENOTCONN;\n\tif (sock_flag(sk, SOCK_DEAD))\n\t\tgoto out;\n\n\t/* Get and verify the address. */\n\tif (msg->msg_name) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_l2tpip *, lip, msg->msg_name);\n\t\trc = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(*lip))\n\t\t\tgoto out;\n\n\t\tif (lip->l2tp_family != AF_INET) {\n\t\t\trc = -EAFNOSUPPORT;\n\t\t\tif (lip->l2tp_family != AF_UNSPEC)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tdaddr = lip->l2tp_addr.s_addr;\n\t} else {\n\t\trc = -EDESTADDRREQ;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\n\t\tdaddr = inet->inet_daddr;\n\t\tconnected = 1;\n\t}\n\n\t/* Allocate a socket buffer */\n\trc = -ENOMEM;\n\tskb = sock_wmalloc(sk, 2 + NET_SKB_PAD + sizeof(struct iphdr) +\n\t\t\t   4 + len, 0, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto error;\n\n\t/* Reserve space for headers, putting IP header on 4-byte boundary. */\n\tskb_reserve(skb, 2 + NET_SKB_PAD);\n\tskb_reset_network_header(skb);\n\tskb_reserve(skb, sizeof(struct iphdr));\n\tskb_reset_transport_header(skb);\n\n\t/* Insert 0 session_id */\n\t*((__be32 *) skb_put(skb, 4)) = 0;\n\n\t/* Copy user data into skb */\n\trc = memcpy_from_msg(skb_put(skb, len), msg, len);\n\tif (rc < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\tfl4 = &inet->cork.fl.u.ip4;\n\tif (connected)\n\t\trt = (struct rtable *) __sk_dst_check(sk, 0);\n\n\trcu_read_lock();\n\tif (rt == NULL) {\n\t\tconst struct ip_options_rcu *inet_opt;\n\n\t\tinet_opt = rcu_dereference(inet->inet_opt);\n\n\t\t/* Use correct destination address if we have options. */\n\t\tif (inet_opt && inet_opt->opt.srr)\n\t\t\tdaddr = inet_opt->opt.faddr;\n\n\t\t/* If this fails, retransmit mechanism of transport layer will\n\t\t * keep trying until route appears or the connection times\n\t\t * itself out.\n\t\t */\n\t\trt = ip_route_output_ports(sock_net(sk), fl4, sk,\n\t\t\t\t\t   daddr, inet->inet_saddr,\n\t\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto no_route;\n\t\tif (connected) {\n\t\t\tsk_setup_caps(sk, &rt->dst);\n\t\t} else {\n\t\t\tskb_dst_set(skb, &rt->dst);\n\t\t\tgoto xmit;\n\t\t}\n\t}\n\n\t/* We dont need to clone dst here, it is guaranteed to not disappear.\n\t *  __dev_xmit_skb() might force a refcount if needed.\n\t */\n\tskb_dst_set_noref(skb, &rt->dst);\n\nxmit:\n\t/* Queue the packet to IP for output */\n\trc = ip_queue_xmit(sk, skb, &inet->cork.fl);\n\trcu_read_unlock();\n\nerror:\n\tif (rc >= 0)\n\t\trc = len;\n\nout:\n\trelease_sock(sk);\n\treturn rc;\n\nno_route:\n\trcu_read_unlock();\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\tkfree_skb(skb);\n\trc = -EHOSTUNREACH;\n\tgoto out;\n}\n\nstatic int l2tp_ip_recvmsg(struct sock *sk, struct msghdr *msg,\n\t\t\t   size_t len, int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tDECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tsin->sin_port = 0;\n\t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\t}\n\tif (inet->cmsg_flags)\n\t\tip_cmsg_recv(msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err ? err : copied;\n}\n\nstatic struct proto l2tp_ip_prot = {\n\t.name\t\t   = \"L2TP/IP\",\n\t.owner\t\t   = THIS_MODULE,\n\t.init\t\t   = l2tp_ip_open,\n\t.close\t\t   = l2tp_ip_close,\n\t.bind\t\t   = l2tp_ip_bind,\n\t.connect\t   = l2tp_ip_connect,\n\t.disconnect\t   = l2tp_ip_disconnect,\n\t.ioctl\t\t   = udp_ioctl,\n\t.destroy\t   = l2tp_ip_destroy_sock,\n\t.setsockopt\t   = ip_setsockopt,\n\t.getsockopt\t   = ip_getsockopt,\n\t.sendmsg\t   = l2tp_ip_sendmsg,\n\t.recvmsg\t   = l2tp_ip_recvmsg,\n\t.backlog_rcv\t   = l2tp_ip_backlog_recv,\n\t.hash\t\t   = inet_hash,\n\t.unhash\t\t   = inet_unhash,\n\t.obj_size\t   = sizeof(struct l2tp_ip_sock),\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ip_setsockopt,\n\t.compat_getsockopt = compat_ip_getsockopt,\n#endif\n};\n\nstatic const struct proto_ops l2tp_ip_ops = {\n\t.family\t\t   = PF_INET,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet_release,\n\t.bind\t\t   = inet_bind,\n\t.connect\t   = inet_dgram_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = sock_no_accept,\n\t.getname\t   = l2tp_ip_getname,\n\t.poll\t\t   = datagram_poll,\n\t.ioctl\t\t   = inet_ioctl,\n\t.listen\t\t   = sock_no_listen,\n\t.shutdown\t   = inet_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet_sendmsg,\n\t.recvmsg\t   = sock_common_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n\t.sendpage\t   = sock_no_sendpage,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_sock_common_setsockopt,\n\t.compat_getsockopt = compat_sock_common_getsockopt,\n#endif\n};\n\nstatic struct inet_protosw l2tp_ip_protosw = {\n\t.type\t\t= SOCK_DGRAM,\n\t.protocol\t= IPPROTO_L2TP,\n\t.prot\t\t= &l2tp_ip_prot,\n\t.ops\t\t= &l2tp_ip_ops,\n};\n\nstatic struct net_protocol l2tp_ip_protocol __read_mostly = {\n\t.handler\t= l2tp_ip_recv,\n\t.netns_ok\t= 1,\n};\n\nstatic int __init l2tp_ip_init(void)\n{\n\tint err;\n\n\tpr_info(\"L2TP IP encapsulation support (L2TPv3)\\n\");\n\n\terr = proto_register(&l2tp_ip_prot, 1);\n\tif (err != 0)\n\t\tgoto out;\n\n\terr = inet_add_protocol(&l2tp_ip_protocol, IPPROTO_L2TP);\n\tif (err)\n\t\tgoto out1;\n\n\tinet_register_protosw(&l2tp_ip_protosw);\n\treturn 0;\n\nout1:\n\tproto_unregister(&l2tp_ip_prot);\nout:\n\treturn err;\n}\n\nstatic void __exit l2tp_ip_exit(void)\n{\n\tinet_unregister_protosw(&l2tp_ip_protosw);\n\tinet_del_protocol(&l2tp_ip_protocol, IPPROTO_L2TP);\n\tproto_unregister(&l2tp_ip_prot);\n}\n\nmodule_init(l2tp_ip_init);\nmodule_exit(l2tp_ip_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"James Chapman <jchapman@katalix.com>\");\nMODULE_DESCRIPTION(\"L2TP over IP\");\nMODULE_VERSION(\"1.0\");\n\n/* Use the value of SOCK_DGRAM (2) directory, because __stringify doesn't like\n * enums\n */\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET, 2, IPPROTO_L2TP);\nMODULE_ALIAS_NET_PF_PROTO(PF_INET, IPPROTO_L2TP);\n", "/*\n * L2TPv3 IP encapsulation support for IPv6\n *\n * Copyright (c) 2012 Katalix Systems Ltd\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License\n *\tas published by the Free Software Foundation; either version\n *\t2 of the License, or (at your option) any later version.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/icmp.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/random.h>\n#include <linux/socket.h>\n#include <linux/l2tp.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/udp.h>\n#include <net/inet_common.h>\n#include <net/inet_hashtables.h>\n#include <net/inet6_hashtables.h>\n#include <net/tcp_states.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n\n#include <net/transp_v6.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n\n#include \"l2tp_core.h\"\n\nstruct l2tp_ip6_sock {\n\t/* inet_sock has to be the first member of l2tp_ip6_sock */\n\tstruct inet_sock\tinet;\n\n\tu32\t\t\tconn_id;\n\tu32\t\t\tpeer_conn_id;\n\n\t/* ipv6_pinfo has to be the last member of l2tp_ip6_sock, see\n\t   inet6_sk_generic */\n\tstruct ipv6_pinfo\tinet6;\n};\n\nstatic DEFINE_RWLOCK(l2tp_ip6_lock);\nstatic struct hlist_head l2tp_ip6_table;\nstatic struct hlist_head l2tp_ip6_bind_table;\n\nstatic inline struct l2tp_ip6_sock *l2tp_ip6_sk(const struct sock *sk)\n{\n\treturn (struct l2tp_ip6_sock *)sk;\n}\n\nstatic struct sock *__l2tp_ip6_bind_lookup(struct net *net,\n\t\t\t\t\t   struct in6_addr *laddr,\n\t\t\t\t\t   int dif, u32 tunnel_id)\n{\n\tstruct sock *sk;\n\n\tsk_for_each_bound(sk, &l2tp_ip6_bind_table) {\n\t\tconst struct in6_addr *addr = inet6_rcv_saddr(sk);\n\t\tstruct l2tp_ip6_sock *l2tp = l2tp_ip6_sk(sk);\n\n\t\tif (l2tp == NULL)\n\t\t\tcontinue;\n\n\t\tif ((l2tp->conn_id == tunnel_id) &&\n\t\t    net_eq(sock_net(sk), net) &&\n\t\t    !(addr && ipv6_addr_equal(addr, laddr)) &&\n\t\t    !(sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif))\n\t\t\tgoto found;\n\t}\n\n\tsk = NULL;\nfound:\n\treturn sk;\n}\n\nstatic inline struct sock *l2tp_ip6_bind_lookup(struct net *net,\n\t\t\t\t\t\tstruct in6_addr *laddr,\n\t\t\t\t\t\tint dif, u32 tunnel_id)\n{\n\tstruct sock *sk = __l2tp_ip6_bind_lookup(net, laddr, dif, tunnel_id);\n\tif (sk)\n\t\tsock_hold(sk);\n\n\treturn sk;\n}\n\n/* When processing receive frames, there are two cases to\n * consider. Data frames consist of a non-zero session-id and an\n * optional cookie. Control frames consist of a regular L2TP header\n * preceded by 32-bits of zeros.\n *\n * L2TPv3 Session Header Over IP\n *\n *  0                   1                   2                   3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |                           Session ID                          |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |               Cookie (optional, maximum 64 bits)...\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *                                                                 |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * L2TPv3 Control Message Header Over IP\n *\n *  0                   1                   2                   3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |                      (32 bits of zeros)                       |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |T|L|x|x|S|x|x|x|x|x|x|x|  Ver  |             Length            |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |                     Control Connection ID                     |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |               Ns              |               Nr              |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * All control frames are passed to userspace.\n */\nstatic int l2tp_ip6_recv(struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk;\n\tu32 session_id;\n\tu32 tunnel_id;\n\tunsigned char *ptr, *optr;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel = NULL;\n\tint length;\n\n\tif (!pskb_may_pull(skb, 4))\n\t\tgoto discard;\n\n\t/* Point to L2TP header */\n\toptr = ptr = skb->data;\n\tsession_id = ntohl(*((__be32 *) ptr));\n\tptr += 4;\n\n\t/* RFC3931: L2TP/IP packets have the first 4 bytes containing\n\t * the session_id. If it is 0, the packet is a L2TP control\n\t * frame and the session_id value can be discarded.\n\t */\n\tif (session_id == 0) {\n\t\t__skb_pull(skb, 4);\n\t\tgoto pass_up;\n\t}\n\n\t/* Ok, this is a data packet. Lookup the session. */\n\tsession = l2tp_session_find(net, NULL, session_id);\n\tif (session == NULL)\n\t\tgoto discard;\n\n\ttunnel = session->tunnel;\n\tif (tunnel == NULL)\n\t\tgoto discard;\n\n\t/* Trace packet contents, if enabled */\n\tif (tunnel->debug & L2TP_MSG_DATA) {\n\t\tlength = min(32u, skb->len);\n\t\tif (!pskb_may_pull(skb, length))\n\t\t\tgoto discard;\n\n\t\t/* Point to L2TP header */\n\t\toptr = ptr = skb->data;\n\t\tptr += 4;\n\t\tpr_debug(\"%s: ip recv\\n\", tunnel->name);\n\t\tprint_hex_dump_bytes(\"\", DUMP_PREFIX_OFFSET, ptr, length);\n\t}\n\n\tl2tp_recv_common(session, skb, ptr, optr, 0, skb->len,\n\t\t\t tunnel->recv_payload_hook);\n\treturn 0;\n\npass_up:\n\t/* Get the tunnel_id from the L2TP header */\n\tif (!pskb_may_pull(skb, 12))\n\t\tgoto discard;\n\n\tif ((skb->data[0] & 0xc0) != 0xc0)\n\t\tgoto discard;\n\n\ttunnel_id = ntohl(*(__be32 *) &skb->data[4]);\n\ttunnel = l2tp_tunnel_find(net, tunnel_id);\n\tif (tunnel != NULL)\n\t\tsk = tunnel->sock;\n\telse {\n\t\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\n\t\tread_lock_bh(&l2tp_ip6_lock);\n\t\tsk = __l2tp_ip6_bind_lookup(net, &iph->daddr,\n\t\t\t\t\t    0, tunnel_id);\n\t\tread_unlock_bh(&l2tp_ip6_lock);\n\t}\n\n\tif (sk == NULL)\n\t\tgoto discard;\n\n\tsock_hold(sk);\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_put;\n\n\tnf_reset(skb);\n\n\treturn sk_receive_skb(sk, skb, 1);\n\ndiscard_put:\n\tsock_put(sk);\n\ndiscard:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int l2tp_ip6_open(struct sock *sk)\n{\n\t/* Prevent autobind. We don't have ports. */\n\tinet_sk(sk)->inet_num = IPPROTO_L2TP;\n\n\twrite_lock_bh(&l2tp_ip6_lock);\n\tsk_add_node(sk, &l2tp_ip6_table);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\treturn 0;\n}\n\nstatic void l2tp_ip6_close(struct sock *sk, long timeout)\n{\n\twrite_lock_bh(&l2tp_ip6_lock);\n\thlist_del_init(&sk->sk_bind_node);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\tsk_common_release(sk);\n}\n\nstatic void l2tp_ip6_destroy_sock(struct sock *sk)\n{\n\tstruct l2tp_tunnel *tunnel = l2tp_sock_to_tunnel(sk);\n\n\tlock_sock(sk);\n\tip6_flush_pending_frames(sk);\n\trelease_sock(sk);\n\n\tif (tunnel) {\n\t\tl2tp_tunnel_closeall(tunnel);\n\t\tsock_put(sk);\n\t}\n\n\tinet6_destroy_sock(sk);\n}\n\nstatic int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;\n\tstruct net *net = sock_net(sk);\n\t__be32 v4addr = 0;\n\tint addr_type;\n\tint err;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n\tif (addr->l2tp_family != AF_INET6)\n\t\treturn -EINVAL;\n\tif (addr_len < sizeof(*addr))\n\t\treturn -EINVAL;\n\n\taddr_type = ipv6_addr_type(&addr->l2tp_addr);\n\n\t/* l2tp_ip6 sockets are IPv6 only */\n\tif (addr_type == IPV6_ADDR_MAPPED)\n\t\treturn -EADDRNOTAVAIL;\n\n\t/* L2TP is point-point, not multicast */\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -EADDRNOTAVAIL;\n\n\terr = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip6_lock);\n\tif (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr,\n\t\t\t\t   sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\tread_unlock_bh(&l2tp_ip6_lock);\n\n\tlock_sock(sk);\n\n\terr = -EINVAL;\n\tif (sk->sk_state != TCP_CLOSE)\n\t\tgoto out_unlock;\n\n\t/* Check if the address belongs to the host. */\n\trcu_read_lock();\n\tif (addr_type != IPV6_ADDR_ANY) {\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (addr_type & IPV6_ADDR_LINKLOCAL) {\n\t\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t\t    addr->l2tp_scope_id) {\n\t\t\t\t/* Override any existing binding, if another\n\t\t\t\t * one is supplied by user.\n\t\t\t\t */\n\t\t\t\tsk->sk_bound_dev_if = addr->l2tp_scope_id;\n\t\t\t}\n\n\t\t\t/* Binding to link-local address requires an\n\t\t\t   interface */\n\t\t\tif (!sk->sk_bound_dev_if)\n\t\t\t\tgoto out_unlock_rcu;\n\n\t\t\terr = -ENODEV;\n\t\t\tdev = dev_get_by_index_rcu(sock_net(sk),\n\t\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\t\tif (!dev)\n\t\t\t\tgoto out_unlock_rcu;\n\t\t}\n\n\t\t/* ipv4 addr of the socket is invalid.  Only the\n\t\t * unspecified and mapped address have a v4 equivalent.\n\t\t */\n\t\tv4addr = LOOPBACK4_IPV6;\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))\n\t\t\tgoto out_unlock_rcu;\n\t}\n\trcu_read_unlock();\n\n\tinet->inet_rcv_saddr = inet->inet_saddr = v4addr;\n\tsk->sk_v6_rcv_saddr = addr->l2tp_addr;\n\tnp->saddr = addr->l2tp_addr;\n\n\tl2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip6_lock);\n\tsk_add_bind_node(sk, &l2tp_ip6_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trelease_sock(sk);\n\treturn 0;\n\nout_unlock_rcu:\n\trcu_read_unlock();\nout_unlock:\n\trelease_sock(sk);\n\treturn err;\n\nout_in_use:\n\tread_unlock_bh(&l2tp_ip6_lock);\n\treturn err;\n}\n\nstatic int l2tp_ip6_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t    int addr_len)\n{\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *) uaddr;\n\tstruct sockaddr_in6\t*usin = (struct sockaddr_in6 *) uaddr;\n\tstruct in6_addr\t*daddr;\n\tint\taddr_type;\n\tint rc;\n\n\tif (sock_flag(sk, SOCK_ZAPPED)) /* Must bind first - autobinding does not work */\n\t\treturn -EINVAL;\n\n\tif (addr_len < sizeof(*lsa))\n\t\treturn -EINVAL;\n\n\tif (usin->sin6_family != AF_INET6)\n\t\treturn -EINVAL;\n\n\taddr_type = ipv6_addr_type(&usin->sin6_addr);\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -EINVAL;\n\n\tif (addr_type & IPV6_ADDR_MAPPED) {\n\t\tdaddr = &usin->sin6_addr;\n\t\tif (ipv4_is_multicast(daddr->s6_addr32[3]))\n\t\t\treturn -EINVAL;\n\t}\n\n\trc = ip6_datagram_connect(sk, uaddr, addr_len);\n\n\tlock_sock(sk);\n\n\tl2tp_ip6_sk(sk)->peer_conn_id = lsa->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip6_lock);\n\thlist_del_init(&sk->sk_bind_node);\n\tsk_add_bind_node(sk, &l2tp_ip6_bind_table);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\trelease_sock(sk);\n\n\treturn rc;\n}\n\nstatic int l2tp_ip6_disconnect(struct sock *sk, int flags)\n{\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\treturn 0;\n\n\treturn __udp_disconnect(sk, flags);\n}\n\nstatic int l2tp_ip6_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t    int *uaddr_len, int peer)\n{\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct l2tp_ip6_sock *lsk = l2tp_ip6_sk(sk);\n\n\tlsa->l2tp_family = AF_INET6;\n\tlsa->l2tp_flowinfo = 0;\n\tlsa->l2tp_scope_id = 0;\n\tlsa->l2tp_unused = 0;\n\tif (peer) {\n\t\tif (!lsk->peer_conn_id)\n\t\t\treturn -ENOTCONN;\n\t\tlsa->l2tp_conn_id = lsk->peer_conn_id;\n\t\tlsa->l2tp_addr = sk->sk_v6_daddr;\n\t\tif (np->sndflow)\n\t\t\tlsa->l2tp_flowinfo = np->flow_label;\n\t} else {\n\t\tif (ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\t\tlsa->l2tp_addr = np->saddr;\n\t\telse\n\t\t\tlsa->l2tp_addr = sk->sk_v6_rcv_saddr;\n\n\t\tlsa->l2tp_conn_id = lsk->conn_id;\n\t}\n\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tlsa->l2tp_scope_id = sk->sk_bound_dev_if;\n\t*uaddr_len = sizeof(*lsa);\n\treturn 0;\n}\n\nstatic int l2tp_ip6_backlog_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\n\t/* Charge it to the socket, dropping if the queue is full. */\n\trc = sock_queue_rcv_skb(sk, skb);\n\tif (rc < 0)\n\t\tgoto drop;\n\n\treturn 0;\n\ndrop:\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_INDISCARDS);\n\tkfree_skb(skb);\n\treturn -1;\n}\n\nstatic int l2tp_ip6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\t__be32 *transhdr = NULL;\n\tint err = 0;\n\n\tskb = skb_peek(&sk->sk_write_queue);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\ttranshdr = (__be32 *)skb_transport_header(skb);\n\t*transhdr = 0;\n\n\terr = ip6_push_pending_frames(sk);\n\nout:\n\treturn err;\n}\n\n/* Userspace will call sendmsg() on the tunnel socket to send L2TP\n * control frames.\n */\nstatic int l2tp_ip6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct ipv6_txoptions opt_space;\n\tDECLARE_SOCKADDR(struct sockaddr_l2tpip6 *, lsa, msg->msg_name);\n\tstruct in6_addr *daddr, *final_p, final;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt_to_free = NULL;\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct dst_entry *dst = NULL;\n\tstruct flowi6 fl6;\n\tstruct sockcm_cookie sockc_unused = {0};\n\tstruct ipcm6_cookie ipc6;\n\tint addr_len = msg->msg_namelen;\n\tint transhdrlen = 4; /* zero session-id */\n\tint ulen = len + transhdrlen;\n\tint err;\n\n\t/* Rough check on arithmetic overflow,\n\t   better check is made in ip6_append_data().\n\t */\n\tif (len > INT_MAX)\n\t\treturn -EMSGSIZE;\n\n\t/* Mirror BSD error message compatibility */\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tfl6.flowi6_mark = sk->sk_mark;\n\n\tipc6.hlimit = -1;\n\tipc6.tclass = -1;\n\tipc6.dontfrag = -1;\n\n\tif (lsa) {\n\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\treturn -EINVAL;\n\n\t\tif (lsa->l2tp_family && lsa->l2tp_family != AF_INET6)\n\t\t\treturn -EAFNOSUPPORT;\n\n\t\tdaddr = &lsa->l2tp_addr;\n\t\tif (np->sndflow) {\n\t\t\tfl6.flowlabel = lsa->l2tp_flowinfo & IPV6_FLOWINFO_MASK;\n\t\t\tif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\t\tif (flowlabel == NULL)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise it will be difficult to maintain\n\t\t * sk->sk_dst_cache.\n\t\t */\n\t\tif (sk->sk_state == TCP_ESTABLISHED &&\n\t\t    ipv6_addr_equal(daddr, &sk->sk_v6_daddr))\n\t\t\tdaddr = &sk->sk_v6_daddr;\n\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    lsa->l2tp_scope_id &&\n\t\t    ipv6_addr_type(daddr) & IPV6_ADDR_LINKLOCAL)\n\t\t\tfl6.flowi6_oif = lsa->l2tp_scope_id;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tdaddr = &sk->sk_v6_daddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t}\n\n\tif (fl6.flowi6_oif == 0)\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\n\tif (msg->msg_controllen) {\n\t\topt = &opt_space;\n\t\tmemset(opt, 0, sizeof(struct ipv6_txoptions));\n\t\topt->tot_len = sizeof(struct ipv6_txoptions);\n\t\tipc6.opt = opt;\n\n\t\terr = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, &ipc6,\n\t\t\t\t\t    &sockc_unused);\n\t\tif (err < 0) {\n\t\t\tfl6_sock_release(flowlabel);\n\t\t\treturn err;\n\t\t}\n\t\tif ((fl6.flowlabel & IPV6_FLOWLABEL_MASK) && !flowlabel) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (flowlabel == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t}\n\n\tif (!opt) {\n\t\topt = txopt_get(np);\n\t\topt_to_free = opt;\n\t}\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\tipc6.opt = opt;\n\n\tfl6.flowi6_proto = sk->sk_protocol;\n\tif (!ipv6_addr_any(daddr))\n\t\tfl6.daddr = *daddr;\n\telse\n\t\tfl6.daddr.s6_addr[15] = 0x1; /* :: means loopback (BSD'ism) */\n\tif (ipv6_addr_any(&fl6.saddr) && !ipv6_addr_any(&np->saddr))\n\t\tfl6.saddr = np->saddr;\n\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\telse if (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->ucast_oif;\n\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\tif (ipc6.tclass < 0)\n\t\tipc6.tclass = np->tclass;\n\n\tfl6.flowlabel = ip6_make_flowinfo(ipc6.tclass, fl6.flowlabel);\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto out;\n\t}\n\n\tif (ipc6.hlimit < 0)\n\t\tipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);\n\n\tif (ipc6.dontfrag < 0)\n\t\tipc6.dontfrag = np->dontfrag;\n\n\tif (msg->msg_flags & MSG_CONFIRM)\n\t\tgoto do_confirm;\n\nback_from_confirm:\n\tlock_sock(sk);\n\terr = ip6_append_data(sk, ip_generic_getfrag, msg,\n\t\t\t      ulen, transhdrlen, &ipc6,\n\t\t\t      &fl6, (struct rt6_info *)dst,\n\t\t\t      msg->msg_flags, &sockc_unused);\n\tif (err)\n\t\tip6_flush_pending_frames(sk);\n\telse if (!(msg->msg_flags & MSG_MORE))\n\t\terr = l2tp_ip6_push_pending_frames(sk);\n\trelease_sock(sk);\ndone:\n\tdst_release(dst);\nout:\n\tfl6_sock_release(flowlabel);\n\ttxopt_put(opt_to_free);\n\n\treturn err < 0 ? err : len;\n\ndo_confirm:\n\tdst_confirm(dst);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto done;\n}\n\nstatic int l2tp_ip6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t\t    int noblock, int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_l2tpip6 *, lsa, msg->msg_name);\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (addr_len)\n\t\t*addr_len = sizeof(*lsa);\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len, addr_len);\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (lsa) {\n\t\tlsa->l2tp_family = AF_INET6;\n\t\tlsa->l2tp_unused = 0;\n\t\tlsa->l2tp_addr = ipv6_hdr(skb)->saddr;\n\t\tlsa->l2tp_flowinfo = 0;\n\t\tlsa->l2tp_scope_id = 0;\n\t\tlsa->l2tp_conn_id = 0;\n\t\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\tlsa->l2tp_scope_id = inet6_iif(skb);\n\t}\n\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_ctl(sk, msg, skb);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err ? err : copied;\n}\n\nstatic struct proto l2tp_ip6_prot = {\n\t.name\t\t   = \"L2TP/IPv6\",\n\t.owner\t\t   = THIS_MODULE,\n\t.init\t\t   = l2tp_ip6_open,\n\t.close\t\t   = l2tp_ip6_close,\n\t.bind\t\t   = l2tp_ip6_bind,\n\t.connect\t   = l2tp_ip6_connect,\n\t.disconnect\t   = l2tp_ip6_disconnect,\n\t.ioctl\t\t   = udp_ioctl,\n\t.destroy\t   = l2tp_ip6_destroy_sock,\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.sendmsg\t   = l2tp_ip6_sendmsg,\n\t.recvmsg\t   = l2tp_ip6_recvmsg,\n\t.backlog_rcv\t   = l2tp_ip6_backlog_recv,\n\t.hash\t\t   = inet6_hash,\n\t.unhash\t\t   = inet_unhash,\n\t.obj_size\t   = sizeof(struct l2tp_ip6_sock),\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n};\n\nstatic const struct proto_ops l2tp_ip6_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = inet6_bind,\n\t.connect\t   = inet_dgram_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = sock_no_accept,\n\t.getname\t   = l2tp_ip6_getname,\n\t.poll\t\t   = datagram_poll,\n\t.ioctl\t\t   = inet6_ioctl,\n\t.listen\t\t   = sock_no_listen,\n\t.shutdown\t   = inet_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet_sendmsg,\n\t.recvmsg\t   = sock_common_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n\t.sendpage\t   = sock_no_sendpage,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_sock_common_setsockopt,\n\t.compat_getsockopt = compat_sock_common_getsockopt,\n#endif\n};\n\nstatic struct inet_protosw l2tp_ip6_protosw = {\n\t.type\t\t= SOCK_DGRAM,\n\t.protocol\t= IPPROTO_L2TP,\n\t.prot\t\t= &l2tp_ip6_prot,\n\t.ops\t\t= &l2tp_ip6_ops,\n};\n\nstatic struct inet6_protocol l2tp_ip6_protocol __read_mostly = {\n\t.handler\t= l2tp_ip6_recv,\n};\n\nstatic int __init l2tp_ip6_init(void)\n{\n\tint err;\n\n\tpr_info(\"L2TP IP encapsulation support for IPv6 (L2TPv3)\\n\");\n\n\terr = proto_register(&l2tp_ip6_prot, 1);\n\tif (err != 0)\n\t\tgoto out;\n\n\terr = inet6_add_protocol(&l2tp_ip6_protocol, IPPROTO_L2TP);\n\tif (err)\n\t\tgoto out1;\n\n\tinet6_register_protosw(&l2tp_ip6_protosw);\n\treturn 0;\n\nout1:\n\tproto_unregister(&l2tp_ip6_prot);\nout:\n\treturn err;\n}\n\nstatic void __exit l2tp_ip6_exit(void)\n{\n\tinet6_unregister_protosw(&l2tp_ip6_protosw);\n\tinet6_del_protocol(&l2tp_ip6_protocol, IPPROTO_L2TP);\n\tproto_unregister(&l2tp_ip6_prot);\n}\n\nmodule_init(l2tp_ip6_init);\nmodule_exit(l2tp_ip6_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Chris Elston <celston@katalix.com>\");\nMODULE_DESCRIPTION(\"L2TP IP encapsulation for IPv6\");\nMODULE_VERSION(\"1.0\");\n\n/* Use the value of SOCK_DGRAM (2) directory, because __stringify doesn't like\n * enums\n */\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET6, 2, IPPROTO_L2TP);\nMODULE_ALIAS_NET_PF_PROTO(PF_INET6, IPPROTO_L2TP);\n"], "fixing_code": ["/*\n * L2TPv3 IP encapsulation support\n *\n * Copyright (c) 2008,2009,2010 Katalix Systems Ltd\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License\n *\tas published by the Free Software Foundation; either version\n *\t2 of the License, or (at your option) any later version.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/icmp.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/random.h>\n#include <linux/socket.h>\n#include <linux/l2tp.h>\n#include <linux/in.h>\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/udp.h>\n#include <net/inet_common.h>\n#include <net/inet_hashtables.h>\n#include <net/tcp_states.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n\n#include \"l2tp_core.h\"\n\nstruct l2tp_ip_sock {\n\t/* inet_sock has to be the first member of l2tp_ip_sock */\n\tstruct inet_sock\tinet;\n\n\tu32\t\t\tconn_id;\n\tu32\t\t\tpeer_conn_id;\n};\n\nstatic DEFINE_RWLOCK(l2tp_ip_lock);\nstatic struct hlist_head l2tp_ip_table;\nstatic struct hlist_head l2tp_ip_bind_table;\n\nstatic inline struct l2tp_ip_sock *l2tp_ip_sk(const struct sock *sk)\n{\n\treturn (struct l2tp_ip_sock *)sk;\n}\n\nstatic struct sock *__l2tp_ip_bind_lookup(struct net *net, __be32 laddr, int dif, u32 tunnel_id)\n{\n\tstruct sock *sk;\n\n\tsk_for_each_bound(sk, &l2tp_ip_bind_table) {\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\t\tstruct l2tp_ip_sock *l2tp = l2tp_ip_sk(sk);\n\n\t\tif (l2tp == NULL)\n\t\t\tcontinue;\n\n\t\tif ((l2tp->conn_id == tunnel_id) &&\n\t\t    net_eq(sock_net(sk), net) &&\n\t\t    !(inet->inet_rcv_saddr && inet->inet_rcv_saddr != laddr) &&\n\t\t    !(sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif))\n\t\t\tgoto found;\n\t}\n\n\tsk = NULL;\nfound:\n\treturn sk;\n}\n\nstatic inline struct sock *l2tp_ip_bind_lookup(struct net *net, __be32 laddr, int dif, u32 tunnel_id)\n{\n\tstruct sock *sk = __l2tp_ip_bind_lookup(net, laddr, dif, tunnel_id);\n\tif (sk)\n\t\tsock_hold(sk);\n\n\treturn sk;\n}\n\n/* When processing receive frames, there are two cases to\n * consider. Data frames consist of a non-zero session-id and an\n * optional cookie. Control frames consist of a regular L2TP header\n * preceded by 32-bits of zeros.\n *\n * L2TPv3 Session Header Over IP\n *\n *  0                   1                   2                   3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |                           Session ID                          |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |               Cookie (optional, maximum 64 bits)...\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *                                                                 |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * L2TPv3 Control Message Header Over IP\n *\n *  0                   1                   2                   3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |                      (32 bits of zeros)                       |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |T|L|x|x|S|x|x|x|x|x|x|x|  Ver  |             Length            |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |                     Control Connection ID                     |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |               Ns              |               Nr              |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * All control frames are passed to userspace.\n */\nstatic int l2tp_ip_recv(struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk;\n\tu32 session_id;\n\tu32 tunnel_id;\n\tunsigned char *ptr, *optr;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel = NULL;\n\tint length;\n\n\tif (!pskb_may_pull(skb, 4))\n\t\tgoto discard;\n\n\t/* Point to L2TP header */\n\toptr = ptr = skb->data;\n\tsession_id = ntohl(*((__be32 *) ptr));\n\tptr += 4;\n\n\t/* RFC3931: L2TP/IP packets have the first 4 bytes containing\n\t * the session_id. If it is 0, the packet is a L2TP control\n\t * frame and the session_id value can be discarded.\n\t */\n\tif (session_id == 0) {\n\t\t__skb_pull(skb, 4);\n\t\tgoto pass_up;\n\t}\n\n\t/* Ok, this is a data packet. Lookup the session. */\n\tsession = l2tp_session_find(net, NULL, session_id);\n\tif (session == NULL)\n\t\tgoto discard;\n\n\ttunnel = session->tunnel;\n\tif (tunnel == NULL)\n\t\tgoto discard;\n\n\t/* Trace packet contents, if enabled */\n\tif (tunnel->debug & L2TP_MSG_DATA) {\n\t\tlength = min(32u, skb->len);\n\t\tif (!pskb_may_pull(skb, length))\n\t\t\tgoto discard;\n\n\t\t/* Point to L2TP header */\n\t\toptr = ptr = skb->data;\n\t\tptr += 4;\n\t\tpr_debug(\"%s: ip recv\\n\", tunnel->name);\n\t\tprint_hex_dump_bytes(\"\", DUMP_PREFIX_OFFSET, ptr, length);\n\t}\n\n\tl2tp_recv_common(session, skb, ptr, optr, 0, skb->len, tunnel->recv_payload_hook);\n\n\treturn 0;\n\npass_up:\n\t/* Get the tunnel_id from the L2TP header */\n\tif (!pskb_may_pull(skb, 12))\n\t\tgoto discard;\n\n\tif ((skb->data[0] & 0xc0) != 0xc0)\n\t\tgoto discard;\n\n\ttunnel_id = ntohl(*(__be32 *) &skb->data[4]);\n\ttunnel = l2tp_tunnel_find(net, tunnel_id);\n\tif (tunnel != NULL)\n\t\tsk = tunnel->sock;\n\telse {\n\t\tstruct iphdr *iph = (struct iphdr *) skb_network_header(skb);\n\n\t\tread_lock_bh(&l2tp_ip_lock);\n\t\tsk = __l2tp_ip_bind_lookup(net, iph->daddr, 0, tunnel_id);\n\t\tread_unlock_bh(&l2tp_ip_lock);\n\t}\n\n\tif (sk == NULL)\n\t\tgoto discard;\n\n\tsock_hold(sk);\n\n\tif (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_put;\n\n\tnf_reset(skb);\n\n\treturn sk_receive_skb(sk, skb, 1);\n\ndiscard_put:\n\tsock_put(sk);\n\ndiscard:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int l2tp_ip_open(struct sock *sk)\n{\n\t/* Prevent autobind. We don't have ports. */\n\tinet_sk(sk)->inet_num = IPPROTO_L2TP;\n\n\twrite_lock_bh(&l2tp_ip_lock);\n\tsk_add_node(sk, &l2tp_ip_table);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\n\treturn 0;\n}\n\nstatic void l2tp_ip_close(struct sock *sk, long timeout)\n{\n\twrite_lock_bh(&l2tp_ip_lock);\n\thlist_del_init(&sk->sk_bind_node);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\tsk_common_release(sk);\n}\n\nstatic void l2tp_ip_destroy_sock(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\tstruct l2tp_tunnel *tunnel = l2tp_sock_to_tunnel(sk);\n\n\twhile ((skb = __skb_dequeue_tail(&sk->sk_write_queue)) != NULL)\n\t\tkfree_skb(skb);\n\n\tif (tunnel) {\n\t\tl2tp_tunnel_closeall(tunnel);\n\t\tsock_put(sk);\n\t}\n\n\tsk_refcnt_debug_dec(sk);\n}\n\nstatic int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;\n\tstruct net *net = sock_net(sk);\n\tint ret;\n\tint chk_addr_ret;\n\n\tif (addr_len < sizeof(struct sockaddr_l2tpip))\n\t\treturn -EINVAL;\n\tif (addr->l2tp_family != AF_INET)\n\t\treturn -EINVAL;\n\n\tret = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip_lock);\n\tif (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,\n\t\t\t\t  sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\n\tread_unlock_bh(&l2tp_ip_lock);\n\n\tlock_sock(sk);\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\n\tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))\n\t\tgoto out;\n\n\tchk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);\n\tret = -EADDRNOTAVAIL;\n\tif (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&\n\t    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)\n\t\tgoto out;\n\n\tif (addr->l2tp_addr.s_addr)\n\t\tinet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;\n\tif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\n\t\tinet->inet_saddr = 0;  /* Use device */\n\tsk_dst_reset(sk);\n\n\tl2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip_lock);\n\tsk_add_bind_node(sk, &l2tp_ip_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\tret = 0;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\nout:\n\trelease_sock(sk);\n\n\treturn ret;\n\nout_in_use:\n\tread_unlock_bh(&l2tp_ip_lock);\n\n\treturn ret;\n}\n\nstatic int l2tp_ip_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sockaddr_l2tpip *lsa = (struct sockaddr_l2tpip *) uaddr;\n\tint rc;\n\n\tif (sock_flag(sk, SOCK_ZAPPED)) /* Must bind first - autobinding does not work */\n\t\treturn -EINVAL;\n\n\tif (addr_len < sizeof(*lsa))\n\t\treturn -EINVAL;\n\n\tif (ipv4_is_multicast(lsa->l2tp_addr.s_addr))\n\t\treturn -EINVAL;\n\n\trc = ip4_datagram_connect(sk, uaddr, addr_len);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tlock_sock(sk);\n\n\tl2tp_ip_sk(sk)->peer_conn_id = lsa->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip_lock);\n\thlist_del_init(&sk->sk_bind_node);\n\tsk_add_bind_node(sk, &l2tp_ip_bind_table);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\n\trelease_sock(sk);\n\treturn rc;\n}\n\nstatic int l2tp_ip_disconnect(struct sock *sk, int flags)\n{\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\treturn 0;\n\n\treturn __udp_disconnect(sk, flags);\n}\n\nstatic int l2tp_ip_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t   int *uaddr_len, int peer)\n{\n\tstruct sock *sk\t\t= sock->sk;\n\tstruct inet_sock *inet\t= inet_sk(sk);\n\tstruct l2tp_ip_sock *lsk = l2tp_ip_sk(sk);\n\tstruct sockaddr_l2tpip *lsa = (struct sockaddr_l2tpip *)uaddr;\n\n\tmemset(lsa, 0, sizeof(*lsa));\n\tlsa->l2tp_family = AF_INET;\n\tif (peer) {\n\t\tif (!inet->inet_dport)\n\t\t\treturn -ENOTCONN;\n\t\tlsa->l2tp_conn_id = lsk->peer_conn_id;\n\t\tlsa->l2tp_addr.s_addr = inet->inet_daddr;\n\t} else {\n\t\t__be32 addr = inet->inet_rcv_saddr;\n\t\tif (!addr)\n\t\t\taddr = inet->inet_saddr;\n\t\tlsa->l2tp_conn_id = lsk->conn_id;\n\t\tlsa->l2tp_addr.s_addr = addr;\n\t}\n\t*uaddr_len = sizeof(*lsa);\n\treturn 0;\n}\n\nstatic int l2tp_ip_backlog_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\n\t/* Charge it to the socket, dropping if the queue is full. */\n\trc = sock_queue_rcv_skb(sk, skb);\n\tif (rc < 0)\n\t\tgoto drop;\n\n\treturn 0;\n\ndrop:\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_INDISCARDS);\n\tkfree_skb(skb);\n\treturn -1;\n}\n\n/* Userspace will call sendmsg() on the tunnel socket to send L2TP\n * control frames.\n */\nstatic int l2tp_ip_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *skb;\n\tint rc;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 *fl4;\n\tint connected = 0;\n\t__be32 daddr;\n\n\tlock_sock(sk);\n\n\trc = -ENOTCONN;\n\tif (sock_flag(sk, SOCK_DEAD))\n\t\tgoto out;\n\n\t/* Get and verify the address. */\n\tif (msg->msg_name) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_l2tpip *, lip, msg->msg_name);\n\t\trc = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(*lip))\n\t\t\tgoto out;\n\n\t\tif (lip->l2tp_family != AF_INET) {\n\t\t\trc = -EAFNOSUPPORT;\n\t\t\tif (lip->l2tp_family != AF_UNSPEC)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tdaddr = lip->l2tp_addr.s_addr;\n\t} else {\n\t\trc = -EDESTADDRREQ;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\n\t\tdaddr = inet->inet_daddr;\n\t\tconnected = 1;\n\t}\n\n\t/* Allocate a socket buffer */\n\trc = -ENOMEM;\n\tskb = sock_wmalloc(sk, 2 + NET_SKB_PAD + sizeof(struct iphdr) +\n\t\t\t   4 + len, 0, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto error;\n\n\t/* Reserve space for headers, putting IP header on 4-byte boundary. */\n\tskb_reserve(skb, 2 + NET_SKB_PAD);\n\tskb_reset_network_header(skb);\n\tskb_reserve(skb, sizeof(struct iphdr));\n\tskb_reset_transport_header(skb);\n\n\t/* Insert 0 session_id */\n\t*((__be32 *) skb_put(skb, 4)) = 0;\n\n\t/* Copy user data into skb */\n\trc = memcpy_from_msg(skb_put(skb, len), msg, len);\n\tif (rc < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\tfl4 = &inet->cork.fl.u.ip4;\n\tif (connected)\n\t\trt = (struct rtable *) __sk_dst_check(sk, 0);\n\n\trcu_read_lock();\n\tif (rt == NULL) {\n\t\tconst struct ip_options_rcu *inet_opt;\n\n\t\tinet_opt = rcu_dereference(inet->inet_opt);\n\n\t\t/* Use correct destination address if we have options. */\n\t\tif (inet_opt && inet_opt->opt.srr)\n\t\t\tdaddr = inet_opt->opt.faddr;\n\n\t\t/* If this fails, retransmit mechanism of transport layer will\n\t\t * keep trying until route appears or the connection times\n\t\t * itself out.\n\t\t */\n\t\trt = ip_route_output_ports(sock_net(sk), fl4, sk,\n\t\t\t\t\t   daddr, inet->inet_saddr,\n\t\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto no_route;\n\t\tif (connected) {\n\t\t\tsk_setup_caps(sk, &rt->dst);\n\t\t} else {\n\t\t\tskb_dst_set(skb, &rt->dst);\n\t\t\tgoto xmit;\n\t\t}\n\t}\n\n\t/* We dont need to clone dst here, it is guaranteed to not disappear.\n\t *  __dev_xmit_skb() might force a refcount if needed.\n\t */\n\tskb_dst_set_noref(skb, &rt->dst);\n\nxmit:\n\t/* Queue the packet to IP for output */\n\trc = ip_queue_xmit(sk, skb, &inet->cork.fl);\n\trcu_read_unlock();\n\nerror:\n\tif (rc >= 0)\n\t\trc = len;\n\nout:\n\trelease_sock(sk);\n\treturn rc;\n\nno_route:\n\trcu_read_unlock();\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\tkfree_skb(skb);\n\trc = -EHOSTUNREACH;\n\tgoto out;\n}\n\nstatic int l2tp_ip_recvmsg(struct sock *sk, struct msghdr *msg,\n\t\t\t   size_t len, int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tDECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tsin->sin_port = 0;\n\t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\t}\n\tif (inet->cmsg_flags)\n\t\tip_cmsg_recv(msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err ? err : copied;\n}\n\nstatic struct proto l2tp_ip_prot = {\n\t.name\t\t   = \"L2TP/IP\",\n\t.owner\t\t   = THIS_MODULE,\n\t.init\t\t   = l2tp_ip_open,\n\t.close\t\t   = l2tp_ip_close,\n\t.bind\t\t   = l2tp_ip_bind,\n\t.connect\t   = l2tp_ip_connect,\n\t.disconnect\t   = l2tp_ip_disconnect,\n\t.ioctl\t\t   = udp_ioctl,\n\t.destroy\t   = l2tp_ip_destroy_sock,\n\t.setsockopt\t   = ip_setsockopt,\n\t.getsockopt\t   = ip_getsockopt,\n\t.sendmsg\t   = l2tp_ip_sendmsg,\n\t.recvmsg\t   = l2tp_ip_recvmsg,\n\t.backlog_rcv\t   = l2tp_ip_backlog_recv,\n\t.hash\t\t   = inet_hash,\n\t.unhash\t\t   = inet_unhash,\n\t.obj_size\t   = sizeof(struct l2tp_ip_sock),\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ip_setsockopt,\n\t.compat_getsockopt = compat_ip_getsockopt,\n#endif\n};\n\nstatic const struct proto_ops l2tp_ip_ops = {\n\t.family\t\t   = PF_INET,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet_release,\n\t.bind\t\t   = inet_bind,\n\t.connect\t   = inet_dgram_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = sock_no_accept,\n\t.getname\t   = l2tp_ip_getname,\n\t.poll\t\t   = datagram_poll,\n\t.ioctl\t\t   = inet_ioctl,\n\t.listen\t\t   = sock_no_listen,\n\t.shutdown\t   = inet_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet_sendmsg,\n\t.recvmsg\t   = sock_common_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n\t.sendpage\t   = sock_no_sendpage,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_sock_common_setsockopt,\n\t.compat_getsockopt = compat_sock_common_getsockopt,\n#endif\n};\n\nstatic struct inet_protosw l2tp_ip_protosw = {\n\t.type\t\t= SOCK_DGRAM,\n\t.protocol\t= IPPROTO_L2TP,\n\t.prot\t\t= &l2tp_ip_prot,\n\t.ops\t\t= &l2tp_ip_ops,\n};\n\nstatic struct net_protocol l2tp_ip_protocol __read_mostly = {\n\t.handler\t= l2tp_ip_recv,\n\t.netns_ok\t= 1,\n};\n\nstatic int __init l2tp_ip_init(void)\n{\n\tint err;\n\n\tpr_info(\"L2TP IP encapsulation support (L2TPv3)\\n\");\n\n\terr = proto_register(&l2tp_ip_prot, 1);\n\tif (err != 0)\n\t\tgoto out;\n\n\terr = inet_add_protocol(&l2tp_ip_protocol, IPPROTO_L2TP);\n\tif (err)\n\t\tgoto out1;\n\n\tinet_register_protosw(&l2tp_ip_protosw);\n\treturn 0;\n\nout1:\n\tproto_unregister(&l2tp_ip_prot);\nout:\n\treturn err;\n}\n\nstatic void __exit l2tp_ip_exit(void)\n{\n\tinet_unregister_protosw(&l2tp_ip_protosw);\n\tinet_del_protocol(&l2tp_ip_protocol, IPPROTO_L2TP);\n\tproto_unregister(&l2tp_ip_prot);\n}\n\nmodule_init(l2tp_ip_init);\nmodule_exit(l2tp_ip_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"James Chapman <jchapman@katalix.com>\");\nMODULE_DESCRIPTION(\"L2TP over IP\");\nMODULE_VERSION(\"1.0\");\n\n/* Use the value of SOCK_DGRAM (2) directory, because __stringify doesn't like\n * enums\n */\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET, 2, IPPROTO_L2TP);\nMODULE_ALIAS_NET_PF_PROTO(PF_INET, IPPROTO_L2TP);\n", "/*\n * L2TPv3 IP encapsulation support for IPv6\n *\n * Copyright (c) 2012 Katalix Systems Ltd\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License\n *\tas published by the Free Software Foundation; either version\n *\t2 of the License, or (at your option) any later version.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/icmp.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/random.h>\n#include <linux/socket.h>\n#include <linux/l2tp.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/udp.h>\n#include <net/inet_common.h>\n#include <net/inet_hashtables.h>\n#include <net/inet6_hashtables.h>\n#include <net/tcp_states.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n\n#include <net/transp_v6.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n\n#include \"l2tp_core.h\"\n\nstruct l2tp_ip6_sock {\n\t/* inet_sock has to be the first member of l2tp_ip6_sock */\n\tstruct inet_sock\tinet;\n\n\tu32\t\t\tconn_id;\n\tu32\t\t\tpeer_conn_id;\n\n\t/* ipv6_pinfo has to be the last member of l2tp_ip6_sock, see\n\t   inet6_sk_generic */\n\tstruct ipv6_pinfo\tinet6;\n};\n\nstatic DEFINE_RWLOCK(l2tp_ip6_lock);\nstatic struct hlist_head l2tp_ip6_table;\nstatic struct hlist_head l2tp_ip6_bind_table;\n\nstatic inline struct l2tp_ip6_sock *l2tp_ip6_sk(const struct sock *sk)\n{\n\treturn (struct l2tp_ip6_sock *)sk;\n}\n\nstatic struct sock *__l2tp_ip6_bind_lookup(struct net *net,\n\t\t\t\t\t   struct in6_addr *laddr,\n\t\t\t\t\t   int dif, u32 tunnel_id)\n{\n\tstruct sock *sk;\n\n\tsk_for_each_bound(sk, &l2tp_ip6_bind_table) {\n\t\tconst struct in6_addr *addr = inet6_rcv_saddr(sk);\n\t\tstruct l2tp_ip6_sock *l2tp = l2tp_ip6_sk(sk);\n\n\t\tif (l2tp == NULL)\n\t\t\tcontinue;\n\n\t\tif ((l2tp->conn_id == tunnel_id) &&\n\t\t    net_eq(sock_net(sk), net) &&\n\t\t    !(addr && ipv6_addr_equal(addr, laddr)) &&\n\t\t    !(sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif))\n\t\t\tgoto found;\n\t}\n\n\tsk = NULL;\nfound:\n\treturn sk;\n}\n\nstatic inline struct sock *l2tp_ip6_bind_lookup(struct net *net,\n\t\t\t\t\t\tstruct in6_addr *laddr,\n\t\t\t\t\t\tint dif, u32 tunnel_id)\n{\n\tstruct sock *sk = __l2tp_ip6_bind_lookup(net, laddr, dif, tunnel_id);\n\tif (sk)\n\t\tsock_hold(sk);\n\n\treturn sk;\n}\n\n/* When processing receive frames, there are two cases to\n * consider. Data frames consist of a non-zero session-id and an\n * optional cookie. Control frames consist of a regular L2TP header\n * preceded by 32-bits of zeros.\n *\n * L2TPv3 Session Header Over IP\n *\n *  0                   1                   2                   3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |                           Session ID                          |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |               Cookie (optional, maximum 64 bits)...\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *                                                                 |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * L2TPv3 Control Message Header Over IP\n *\n *  0                   1                   2                   3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |                      (32 bits of zeros)                       |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |T|L|x|x|S|x|x|x|x|x|x|x|  Ver  |             Length            |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |                     Control Connection ID                     |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |               Ns              |               Nr              |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * All control frames are passed to userspace.\n */\nstatic int l2tp_ip6_recv(struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk;\n\tu32 session_id;\n\tu32 tunnel_id;\n\tunsigned char *ptr, *optr;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel = NULL;\n\tint length;\n\n\tif (!pskb_may_pull(skb, 4))\n\t\tgoto discard;\n\n\t/* Point to L2TP header */\n\toptr = ptr = skb->data;\n\tsession_id = ntohl(*((__be32 *) ptr));\n\tptr += 4;\n\n\t/* RFC3931: L2TP/IP packets have the first 4 bytes containing\n\t * the session_id. If it is 0, the packet is a L2TP control\n\t * frame and the session_id value can be discarded.\n\t */\n\tif (session_id == 0) {\n\t\t__skb_pull(skb, 4);\n\t\tgoto pass_up;\n\t}\n\n\t/* Ok, this is a data packet. Lookup the session. */\n\tsession = l2tp_session_find(net, NULL, session_id);\n\tif (session == NULL)\n\t\tgoto discard;\n\n\ttunnel = session->tunnel;\n\tif (tunnel == NULL)\n\t\tgoto discard;\n\n\t/* Trace packet contents, if enabled */\n\tif (tunnel->debug & L2TP_MSG_DATA) {\n\t\tlength = min(32u, skb->len);\n\t\tif (!pskb_may_pull(skb, length))\n\t\t\tgoto discard;\n\n\t\t/* Point to L2TP header */\n\t\toptr = ptr = skb->data;\n\t\tptr += 4;\n\t\tpr_debug(\"%s: ip recv\\n\", tunnel->name);\n\t\tprint_hex_dump_bytes(\"\", DUMP_PREFIX_OFFSET, ptr, length);\n\t}\n\n\tl2tp_recv_common(session, skb, ptr, optr, 0, skb->len,\n\t\t\t tunnel->recv_payload_hook);\n\treturn 0;\n\npass_up:\n\t/* Get the tunnel_id from the L2TP header */\n\tif (!pskb_may_pull(skb, 12))\n\t\tgoto discard;\n\n\tif ((skb->data[0] & 0xc0) != 0xc0)\n\t\tgoto discard;\n\n\ttunnel_id = ntohl(*(__be32 *) &skb->data[4]);\n\ttunnel = l2tp_tunnel_find(net, tunnel_id);\n\tif (tunnel != NULL)\n\t\tsk = tunnel->sock;\n\telse {\n\t\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\n\t\tread_lock_bh(&l2tp_ip6_lock);\n\t\tsk = __l2tp_ip6_bind_lookup(net, &iph->daddr,\n\t\t\t\t\t    0, tunnel_id);\n\t\tread_unlock_bh(&l2tp_ip6_lock);\n\t}\n\n\tif (sk == NULL)\n\t\tgoto discard;\n\n\tsock_hold(sk);\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_put;\n\n\tnf_reset(skb);\n\n\treturn sk_receive_skb(sk, skb, 1);\n\ndiscard_put:\n\tsock_put(sk);\n\ndiscard:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int l2tp_ip6_open(struct sock *sk)\n{\n\t/* Prevent autobind. We don't have ports. */\n\tinet_sk(sk)->inet_num = IPPROTO_L2TP;\n\n\twrite_lock_bh(&l2tp_ip6_lock);\n\tsk_add_node(sk, &l2tp_ip6_table);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\treturn 0;\n}\n\nstatic void l2tp_ip6_close(struct sock *sk, long timeout)\n{\n\twrite_lock_bh(&l2tp_ip6_lock);\n\thlist_del_init(&sk->sk_bind_node);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\tsk_common_release(sk);\n}\n\nstatic void l2tp_ip6_destroy_sock(struct sock *sk)\n{\n\tstruct l2tp_tunnel *tunnel = l2tp_sock_to_tunnel(sk);\n\n\tlock_sock(sk);\n\tip6_flush_pending_frames(sk);\n\trelease_sock(sk);\n\n\tif (tunnel) {\n\t\tl2tp_tunnel_closeall(tunnel);\n\t\tsock_put(sk);\n\t}\n\n\tinet6_destroy_sock(sk);\n}\n\nstatic int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;\n\tstruct net *net = sock_net(sk);\n\t__be32 v4addr = 0;\n\tint addr_type;\n\tint err;\n\n\tif (addr->l2tp_family != AF_INET6)\n\t\treturn -EINVAL;\n\tif (addr_len < sizeof(*addr))\n\t\treturn -EINVAL;\n\n\taddr_type = ipv6_addr_type(&addr->l2tp_addr);\n\n\t/* l2tp_ip6 sockets are IPv6 only */\n\tif (addr_type == IPV6_ADDR_MAPPED)\n\t\treturn -EADDRNOTAVAIL;\n\n\t/* L2TP is point-point, not multicast */\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -EADDRNOTAVAIL;\n\n\terr = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip6_lock);\n\tif (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr,\n\t\t\t\t   sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\tread_unlock_bh(&l2tp_ip6_lock);\n\n\tlock_sock(sk);\n\n\terr = -EINVAL;\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out_unlock;\n\n\tif (sk->sk_state != TCP_CLOSE)\n\t\tgoto out_unlock;\n\n\t/* Check if the address belongs to the host. */\n\trcu_read_lock();\n\tif (addr_type != IPV6_ADDR_ANY) {\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (addr_type & IPV6_ADDR_LINKLOCAL) {\n\t\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t\t    addr->l2tp_scope_id) {\n\t\t\t\t/* Override any existing binding, if another\n\t\t\t\t * one is supplied by user.\n\t\t\t\t */\n\t\t\t\tsk->sk_bound_dev_if = addr->l2tp_scope_id;\n\t\t\t}\n\n\t\t\t/* Binding to link-local address requires an\n\t\t\t   interface */\n\t\t\tif (!sk->sk_bound_dev_if)\n\t\t\t\tgoto out_unlock_rcu;\n\n\t\t\terr = -ENODEV;\n\t\t\tdev = dev_get_by_index_rcu(sock_net(sk),\n\t\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\t\tif (!dev)\n\t\t\t\tgoto out_unlock_rcu;\n\t\t}\n\n\t\t/* ipv4 addr of the socket is invalid.  Only the\n\t\t * unspecified and mapped address have a v4 equivalent.\n\t\t */\n\t\tv4addr = LOOPBACK4_IPV6;\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))\n\t\t\tgoto out_unlock_rcu;\n\t}\n\trcu_read_unlock();\n\n\tinet->inet_rcv_saddr = inet->inet_saddr = v4addr;\n\tsk->sk_v6_rcv_saddr = addr->l2tp_addr;\n\tnp->saddr = addr->l2tp_addr;\n\n\tl2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip6_lock);\n\tsk_add_bind_node(sk, &l2tp_ip6_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trelease_sock(sk);\n\treturn 0;\n\nout_unlock_rcu:\n\trcu_read_unlock();\nout_unlock:\n\trelease_sock(sk);\n\treturn err;\n\nout_in_use:\n\tread_unlock_bh(&l2tp_ip6_lock);\n\treturn err;\n}\n\nstatic int l2tp_ip6_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t    int addr_len)\n{\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *) uaddr;\n\tstruct sockaddr_in6\t*usin = (struct sockaddr_in6 *) uaddr;\n\tstruct in6_addr\t*daddr;\n\tint\taddr_type;\n\tint rc;\n\n\tif (sock_flag(sk, SOCK_ZAPPED)) /* Must bind first - autobinding does not work */\n\t\treturn -EINVAL;\n\n\tif (addr_len < sizeof(*lsa))\n\t\treturn -EINVAL;\n\n\tif (usin->sin6_family != AF_INET6)\n\t\treturn -EINVAL;\n\n\taddr_type = ipv6_addr_type(&usin->sin6_addr);\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -EINVAL;\n\n\tif (addr_type & IPV6_ADDR_MAPPED) {\n\t\tdaddr = &usin->sin6_addr;\n\t\tif (ipv4_is_multicast(daddr->s6_addr32[3]))\n\t\t\treturn -EINVAL;\n\t}\n\n\trc = ip6_datagram_connect(sk, uaddr, addr_len);\n\n\tlock_sock(sk);\n\n\tl2tp_ip6_sk(sk)->peer_conn_id = lsa->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip6_lock);\n\thlist_del_init(&sk->sk_bind_node);\n\tsk_add_bind_node(sk, &l2tp_ip6_bind_table);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\trelease_sock(sk);\n\n\treturn rc;\n}\n\nstatic int l2tp_ip6_disconnect(struct sock *sk, int flags)\n{\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\treturn 0;\n\n\treturn __udp_disconnect(sk, flags);\n}\n\nstatic int l2tp_ip6_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t    int *uaddr_len, int peer)\n{\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct l2tp_ip6_sock *lsk = l2tp_ip6_sk(sk);\n\n\tlsa->l2tp_family = AF_INET6;\n\tlsa->l2tp_flowinfo = 0;\n\tlsa->l2tp_scope_id = 0;\n\tlsa->l2tp_unused = 0;\n\tif (peer) {\n\t\tif (!lsk->peer_conn_id)\n\t\t\treturn -ENOTCONN;\n\t\tlsa->l2tp_conn_id = lsk->peer_conn_id;\n\t\tlsa->l2tp_addr = sk->sk_v6_daddr;\n\t\tif (np->sndflow)\n\t\t\tlsa->l2tp_flowinfo = np->flow_label;\n\t} else {\n\t\tif (ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\t\tlsa->l2tp_addr = np->saddr;\n\t\telse\n\t\t\tlsa->l2tp_addr = sk->sk_v6_rcv_saddr;\n\n\t\tlsa->l2tp_conn_id = lsk->conn_id;\n\t}\n\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tlsa->l2tp_scope_id = sk->sk_bound_dev_if;\n\t*uaddr_len = sizeof(*lsa);\n\treturn 0;\n}\n\nstatic int l2tp_ip6_backlog_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\n\t/* Charge it to the socket, dropping if the queue is full. */\n\trc = sock_queue_rcv_skb(sk, skb);\n\tif (rc < 0)\n\t\tgoto drop;\n\n\treturn 0;\n\ndrop:\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_INDISCARDS);\n\tkfree_skb(skb);\n\treturn -1;\n}\n\nstatic int l2tp_ip6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\t__be32 *transhdr = NULL;\n\tint err = 0;\n\n\tskb = skb_peek(&sk->sk_write_queue);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\ttranshdr = (__be32 *)skb_transport_header(skb);\n\t*transhdr = 0;\n\n\terr = ip6_push_pending_frames(sk);\n\nout:\n\treturn err;\n}\n\n/* Userspace will call sendmsg() on the tunnel socket to send L2TP\n * control frames.\n */\nstatic int l2tp_ip6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct ipv6_txoptions opt_space;\n\tDECLARE_SOCKADDR(struct sockaddr_l2tpip6 *, lsa, msg->msg_name);\n\tstruct in6_addr *daddr, *final_p, final;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt_to_free = NULL;\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct dst_entry *dst = NULL;\n\tstruct flowi6 fl6;\n\tstruct sockcm_cookie sockc_unused = {0};\n\tstruct ipcm6_cookie ipc6;\n\tint addr_len = msg->msg_namelen;\n\tint transhdrlen = 4; /* zero session-id */\n\tint ulen = len + transhdrlen;\n\tint err;\n\n\t/* Rough check on arithmetic overflow,\n\t   better check is made in ip6_append_data().\n\t */\n\tif (len > INT_MAX)\n\t\treturn -EMSGSIZE;\n\n\t/* Mirror BSD error message compatibility */\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tfl6.flowi6_mark = sk->sk_mark;\n\n\tipc6.hlimit = -1;\n\tipc6.tclass = -1;\n\tipc6.dontfrag = -1;\n\n\tif (lsa) {\n\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\treturn -EINVAL;\n\n\t\tif (lsa->l2tp_family && lsa->l2tp_family != AF_INET6)\n\t\t\treturn -EAFNOSUPPORT;\n\n\t\tdaddr = &lsa->l2tp_addr;\n\t\tif (np->sndflow) {\n\t\t\tfl6.flowlabel = lsa->l2tp_flowinfo & IPV6_FLOWINFO_MASK;\n\t\t\tif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\t\tif (flowlabel == NULL)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise it will be difficult to maintain\n\t\t * sk->sk_dst_cache.\n\t\t */\n\t\tif (sk->sk_state == TCP_ESTABLISHED &&\n\t\t    ipv6_addr_equal(daddr, &sk->sk_v6_daddr))\n\t\t\tdaddr = &sk->sk_v6_daddr;\n\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    lsa->l2tp_scope_id &&\n\t\t    ipv6_addr_type(daddr) & IPV6_ADDR_LINKLOCAL)\n\t\t\tfl6.flowi6_oif = lsa->l2tp_scope_id;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tdaddr = &sk->sk_v6_daddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t}\n\n\tif (fl6.flowi6_oif == 0)\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\n\tif (msg->msg_controllen) {\n\t\topt = &opt_space;\n\t\tmemset(opt, 0, sizeof(struct ipv6_txoptions));\n\t\topt->tot_len = sizeof(struct ipv6_txoptions);\n\t\tipc6.opt = opt;\n\n\t\terr = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, &ipc6,\n\t\t\t\t\t    &sockc_unused);\n\t\tif (err < 0) {\n\t\t\tfl6_sock_release(flowlabel);\n\t\t\treturn err;\n\t\t}\n\t\tif ((fl6.flowlabel & IPV6_FLOWLABEL_MASK) && !flowlabel) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (flowlabel == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t}\n\n\tif (!opt) {\n\t\topt = txopt_get(np);\n\t\topt_to_free = opt;\n\t}\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\tipc6.opt = opt;\n\n\tfl6.flowi6_proto = sk->sk_protocol;\n\tif (!ipv6_addr_any(daddr))\n\t\tfl6.daddr = *daddr;\n\telse\n\t\tfl6.daddr.s6_addr[15] = 0x1; /* :: means loopback (BSD'ism) */\n\tif (ipv6_addr_any(&fl6.saddr) && !ipv6_addr_any(&np->saddr))\n\t\tfl6.saddr = np->saddr;\n\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\telse if (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->ucast_oif;\n\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\tif (ipc6.tclass < 0)\n\t\tipc6.tclass = np->tclass;\n\n\tfl6.flowlabel = ip6_make_flowinfo(ipc6.tclass, fl6.flowlabel);\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto out;\n\t}\n\n\tif (ipc6.hlimit < 0)\n\t\tipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);\n\n\tif (ipc6.dontfrag < 0)\n\t\tipc6.dontfrag = np->dontfrag;\n\n\tif (msg->msg_flags & MSG_CONFIRM)\n\t\tgoto do_confirm;\n\nback_from_confirm:\n\tlock_sock(sk);\n\terr = ip6_append_data(sk, ip_generic_getfrag, msg,\n\t\t\t      ulen, transhdrlen, &ipc6,\n\t\t\t      &fl6, (struct rt6_info *)dst,\n\t\t\t      msg->msg_flags, &sockc_unused);\n\tif (err)\n\t\tip6_flush_pending_frames(sk);\n\telse if (!(msg->msg_flags & MSG_MORE))\n\t\terr = l2tp_ip6_push_pending_frames(sk);\n\trelease_sock(sk);\ndone:\n\tdst_release(dst);\nout:\n\tfl6_sock_release(flowlabel);\n\ttxopt_put(opt_to_free);\n\n\treturn err < 0 ? err : len;\n\ndo_confirm:\n\tdst_confirm(dst);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto done;\n}\n\nstatic int l2tp_ip6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t\t    int noblock, int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_l2tpip6 *, lsa, msg->msg_name);\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (addr_len)\n\t\t*addr_len = sizeof(*lsa);\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len, addr_len);\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (lsa) {\n\t\tlsa->l2tp_family = AF_INET6;\n\t\tlsa->l2tp_unused = 0;\n\t\tlsa->l2tp_addr = ipv6_hdr(skb)->saddr;\n\t\tlsa->l2tp_flowinfo = 0;\n\t\tlsa->l2tp_scope_id = 0;\n\t\tlsa->l2tp_conn_id = 0;\n\t\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\tlsa->l2tp_scope_id = inet6_iif(skb);\n\t}\n\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_ctl(sk, msg, skb);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err ? err : copied;\n}\n\nstatic struct proto l2tp_ip6_prot = {\n\t.name\t\t   = \"L2TP/IPv6\",\n\t.owner\t\t   = THIS_MODULE,\n\t.init\t\t   = l2tp_ip6_open,\n\t.close\t\t   = l2tp_ip6_close,\n\t.bind\t\t   = l2tp_ip6_bind,\n\t.connect\t   = l2tp_ip6_connect,\n\t.disconnect\t   = l2tp_ip6_disconnect,\n\t.ioctl\t\t   = udp_ioctl,\n\t.destroy\t   = l2tp_ip6_destroy_sock,\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.sendmsg\t   = l2tp_ip6_sendmsg,\n\t.recvmsg\t   = l2tp_ip6_recvmsg,\n\t.backlog_rcv\t   = l2tp_ip6_backlog_recv,\n\t.hash\t\t   = inet6_hash,\n\t.unhash\t\t   = inet_unhash,\n\t.obj_size\t   = sizeof(struct l2tp_ip6_sock),\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n};\n\nstatic const struct proto_ops l2tp_ip6_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = inet6_bind,\n\t.connect\t   = inet_dgram_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = sock_no_accept,\n\t.getname\t   = l2tp_ip6_getname,\n\t.poll\t\t   = datagram_poll,\n\t.ioctl\t\t   = inet6_ioctl,\n\t.listen\t\t   = sock_no_listen,\n\t.shutdown\t   = inet_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet_sendmsg,\n\t.recvmsg\t   = sock_common_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n\t.sendpage\t   = sock_no_sendpage,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_sock_common_setsockopt,\n\t.compat_getsockopt = compat_sock_common_getsockopt,\n#endif\n};\n\nstatic struct inet_protosw l2tp_ip6_protosw = {\n\t.type\t\t= SOCK_DGRAM,\n\t.protocol\t= IPPROTO_L2TP,\n\t.prot\t\t= &l2tp_ip6_prot,\n\t.ops\t\t= &l2tp_ip6_ops,\n};\n\nstatic struct inet6_protocol l2tp_ip6_protocol __read_mostly = {\n\t.handler\t= l2tp_ip6_recv,\n};\n\nstatic int __init l2tp_ip6_init(void)\n{\n\tint err;\n\n\tpr_info(\"L2TP IP encapsulation support for IPv6 (L2TPv3)\\n\");\n\n\terr = proto_register(&l2tp_ip6_prot, 1);\n\tif (err != 0)\n\t\tgoto out;\n\n\terr = inet6_add_protocol(&l2tp_ip6_protocol, IPPROTO_L2TP);\n\tif (err)\n\t\tgoto out1;\n\n\tinet6_register_protosw(&l2tp_ip6_protosw);\n\treturn 0;\n\nout1:\n\tproto_unregister(&l2tp_ip6_prot);\nout:\n\treturn err;\n}\n\nstatic void __exit l2tp_ip6_exit(void)\n{\n\tinet6_unregister_protosw(&l2tp_ip6_protosw);\n\tinet6_del_protocol(&l2tp_ip6_protocol, IPPROTO_L2TP);\n\tproto_unregister(&l2tp_ip6_prot);\n}\n\nmodule_init(l2tp_ip6_init);\nmodule_exit(l2tp_ip6_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Chris Elston <celston@katalix.com>\");\nMODULE_DESCRIPTION(\"L2TP IP encapsulation for IPv6\");\nMODULE_VERSION(\"1.0\");\n\n/* Use the value of SOCK_DGRAM (2) directory, because __stringify doesn't like\n * enums\n */\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET6, 2, IPPROTO_L2TP);\nMODULE_ALIAS_NET_PF_PROTO(PF_INET6, IPPROTO_L2TP);\n"], "filenames": ["net/l2tp/l2tp_ip.c", "net/l2tp/l2tp_ip6.c"], "buggy_code_start_loc": [254, 272], "buggy_code_end_loc": [269, 298], "fixing_code_start_loc": [253, 271], "fixing_code_end_loc": [271, 300], "type": "CWE-264", "message": "Race condition in the L2TPv3 IP Encapsulation feature in the Linux kernel before 4.8.14 allows local users to gain privileges or cause a denial of service (use-after-free) by making multiple bind system calls without properly ascertaining whether a socket has the SOCK_ZAPPED status, related to net/l2tp/l2tp_ip.c and net/l2tp/l2tp_ip6.c.", "other": {"cve": {"id": "CVE-2016-10200", "sourceIdentifier": "security@android.com", "published": "2017-03-07T21:59:00.153", "lastModified": "2023-06-07T12:44:53.337", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Race condition in the L2TPv3 IP Encapsulation feature in the Linux kernel before 4.8.14 allows local users to gain privileges or cause a denial of service (use-after-free) by making multiple bind system calls without properly ascertaining whether a socket has the SOCK_ZAPPED status, related to net/l2tp/l2tp_ip.c and net/l2tp/l2tp_ip6.c."}, {"lang": "es", "value": "Condici\u00f3n de carrera en la caracter\u00edstica L2TPv3 IP Encapsulation en el kernel de Linux en versiones anteriores a 4.8.14 permite a usuarios locales obtener privilegios o provocar una denegaci\u00f3n de servicio (uso despu\u00e9s de liberaci\u00f3n) realizando m\u00faltiples llamadas al sistema enlazadas sin comprobar adecuadamente si un socket tiene el estatus SOCK_ZAPPED, relacionado con net/l2tp/l2tp_ip.c and net/l2tp/l2tp_ip6.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}, {"lang": "en", "value": "CWE-362"}, {"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.34", "versionEndExcluding": "3.2", "matchCriteriaId": "14FD3DA1-7FAC-4B6B-A0BB-54475E9C1380"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.2.20", "versionEndExcluding": "3.2.88", "matchCriteriaId": "3B82F618-7B1B-49EA-B1C0-8D4317DD2F72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.4.2", "versionEndExcluding": "3.12.69", "matchCriteriaId": "736649AC-0E90-4495-B20F-FAB4D4051E48"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.13", "versionEndExcluding": "3.16.40", "matchCriteriaId": "1331ABAB-8C2B-4379-BA77-B655A5B9A83F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "3.18.52", "matchCriteriaId": "8104AAC1-9700-4372-8E11-37B09309A76F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.19", "versionEndExcluding": "4.4.38", "matchCriteriaId": "5931D73A-2E25-417B-84CC-D257F64C28C7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.8.14", "matchCriteriaId": "2454EAB6-FC42-4FA4-BE76-CBAA81D4ADC4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:google:android:*:*:*:*:*:*:*:*", "versionEndIncluding": "7.1.1", "matchCriteriaId": "0F11609D-D1B4-4DD6-8CC7-A224344E1E67"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=32c231164b762dddefa13af5a0101032c70b50ef", "source": "security@android.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://source.android.com/security/bulletin/2017-03-01.html", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.8.14", "source": "security@android.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/101783", "source": "security@android.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1037965", "source": "security@android.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1037968", "source": "security@android.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1842", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2077", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2437", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2444", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/32c231164b762dddefa13af5a0101032c70b50ef", "source": "security@android.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/32c231164b762dddefa13af5a0101032c70b50ef"}}