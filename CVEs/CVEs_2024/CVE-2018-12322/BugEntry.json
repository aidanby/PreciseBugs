{"buggy_code": ["/* radare - LGPL - Copyright 2015 - condret, riq */\n\n/* 6502 info taken from http://unusedino.de/ec64/technical/aay/c64/bchrt651.htm\n *\n * Mnemonics logic based on:\n *\thttp://homepage.ntlworld.com/cyborgsystems/CS_Main/6502/6502.htm\n * and:\n *\thttp://vice-emu.sourceforge.net/\n */\n\n#include <string.h>\n#include <r_types.h>\n#include <r_lib.h>\n#include <r_asm.h>\n#include <r_anal.h>\n#include \"../../asm/arch/snes/snes_op_table.h\"\n\nenum {\n\t_6502_FLAGS_C = (1 << 0),\n\t_6502_FLAGS_B = (1 << 1),\n\t_6502_FLAGS_Z = (1 << 2),\n\t_6502_FLAGS_N = (1 << 3),\n\n\t_6502_FLAGS_NZ = (_6502_FLAGS_Z | _6502_FLAGS_N),\n\t_6502_FLAGS_CNZ = (_6502_FLAGS_C | _6502_FLAGS_Z | _6502_FLAGS_N),\n\t_6502_FLAGS_BNZ = (_6502_FLAGS_B | _6502_FLAGS_Z | _6502_FLAGS_N),\n};\n\nstatic void _6502_anal_update_flags(RAnalOp *op, int flags) {\n\t/* FIXME: $b9 instead of $b8 to prevent the bug triggered by: A = 0 - 0xff - 1 */\n\tif (flags & _6502_FLAGS_B) r_strbuf_append (&op->esil, \",$b9,C,=\");\n\tif (flags & _6502_FLAGS_C) r_strbuf_append (&op->esil, \",$c7,C,=\");\n\tif (flags & _6502_FLAGS_Z) r_strbuf_append (&op->esil, \",$z,Z,=\");\n\tif (flags & _6502_FLAGS_N) r_strbuf_append (&op->esil, \",$s,N,=\");\n}\n\n/* ORA, AND, EOR, ADC, STA, LDA, CMP and SBC share this pattern */\nstatic void _6502_anal_esil_get_addr_pattern1(RAnalOp *op, const ut8* data, char* addrbuf, int addrsize) {\n\t// turn off bits 5, 6 and 7\n\tswitch(data[0] & 0x1f) { // 0x1f = b00111111\n\tcase 0x09: // op #$ff\n\t\top->cycles = 2;\n\t\tsnprintf (addrbuf, addrsize,\"0x%02x\", data[1]);\n\t\tbreak;\n\tcase 0x05: // op $ff\n\t\top->cycles = 3;\n\t\tsnprintf (addrbuf, addrsize,\"0x%02x\", data[1]);\n\t\tbreak;\n\tcase 0x15: // op $ff,x\n\t\top->cycles = 4;\n\t\tsnprintf (addrbuf, addrsize,\"x,0x%02x,+\", data[1]);\n\t\tbreak;\n\tcase 0x0d: // op $ffff\n\t\top->cycles = 4;\n\t\tsnprintf (addrbuf, addrsize,\"0x%04x\", data[1] | data[2] << 8);\n\t\tbreak;\n\tcase 0x1d: // op $ffff,x\n\t\t// FIXME: Add 1 if page boundary is crossed.\n\t\top->cycles = 4;\n\t\tsnprintf (addrbuf, addrsize,\"x,0x%04x,+\", data[1] | data[2] << 8);\n\t\tbreak;\n\tcase 0x19: // op $ffff,y\n\t\t// FIXME: Add 1 if page boundary is crossed.\n\t\top->cycles = 4;\n\t\tsnprintf (addrbuf, addrsize,\"y,0x%04x,+\", data[1] | data[2] << 8);\n\t\tbreak;\n\tcase 0x01: // op ($ff,x)\n\t\top->cycles = 6;\n\t\tsnprintf (addrbuf, addrsize,\"x,0x%02x,+,[2]\", data[1]);\n\t\tbreak;\n\tcase 0x11: // op ($ff),y\n\t\t// FIXME: Add 1 if page boundary is crossed.\n\t\top->cycles = 5;\n\t\tsnprintf (addrbuf, addrsize,\"y,0x%02x,[2],+\", data[1]);\n\t\tbreak;\n\t}\n}\n\n/* ASL, ROL, LSR, ROR, STX, LDX, DEC and INC share this pattern */\nstatic void _6502_anal_esil_get_addr_pattern2(RAnalOp *op, const ut8* data, char* addrbuf, int addrsize, char reg) {\n\t// turn off bits 5, 6 and 7\n\tswitch(data[0] & 0x1f) { // 0x1f = b00111111\n\tcase 0x02: // op #$ff\n\t\top->cycles = 2;\n\t\tsnprintf (addrbuf, addrsize, \"0x%02x\", data[1]);\n\t\tbreak;\n\tcase 0x0a: //op a\n\t\top->cycles = 2;\n\t\tsnprintf (addrbuf, addrsize, \"a\");\n\t\tbreak;\n\tcase 0x06: // op $ff\n\t\top->cycles = 5;\n\t\tsnprintf (addrbuf, addrsize, \"0x%02x\", data[1]);\n\t\tbreak;\n\tcase 0x16: // op $ff,x\n\t\top->cycles = 6;\n\t\tsnprintf (addrbuf, addrsize, \"%c,0x%02x,+\", reg, data[1]);\n\t\tbreak;\n\tcase 0x0e: // op $ffff\n\t\top->cycles = 6;\n\t\tsnprintf (addrbuf, addrsize, \"0x%04x\", data[1] | data[2] << 8);\n\t\tbreak;\n\tcase 0x1e: // op $ffff,x\n\t\top->cycles = 7;\n\t\tsnprintf (addrbuf, addrsize, \"%c,0x%04x,+\", reg, data[1] | data[2] << 8);\n\t\tbreak;\n\t}\n}\n\n/* BIT, JMP, JMP(), STY, LDY, CPY, and CPX share this pattern */\nstatic void _6502_anal_esil_get_addr_pattern3(RAnalOp *op, const ut8* data, char* addrbuf, int addrsize, char reg) {\n\t// turn off bits 5, 6 and 7\n\tswitch (data[0] & 0x1f) { // 0x1f = b00111111\n\tcase 0x00: // op #$ff\n\t\top->cycles = 2;\n\t\tsnprintf (addrbuf, addrsize, \"0x%02x\", data[1]);\n\t\tbreak;\n\tcase 0x08: //op a\n\t\top->cycles = 2;\n\t\tsnprintf (addrbuf, addrsize, \"a\");\n\t\tbreak;\n\tcase 0x04: // op $ff\n\t\top->cycles = 5;\n\t\tsnprintf (addrbuf, addrsize, \"0x%02x\", data[1]);\n\t\tbreak;\n\tcase 0x14: // op $ff,x\n\t\top->cycles = 6;\n\t\tsnprintf (addrbuf, addrsize, \"%c,0x%02x,+\", reg, data[1]);\n\t\tbreak;\n\tcase 0x0c: // op $ffff\n\t\top->cycles = 6;\n\t\tsnprintf (addrbuf, addrsize, \"0x%04x\", data[1] | data[2] << 8);\n\t\tbreak;\n\tcase 0x1c: // op $ffff,x\n\t\top->cycles = 7;\n\t\tsnprintf (addrbuf, addrsize, \"%c,0x%04x,+\", reg, data[1] | data[2] << 8);\n\t\tbreak;\n\t}\n}\n\nstatic void _6502_anal_esil_ccall(RAnalOp *op, ut8 data0)\n{\n\tchar *flag;\n\tswitch(data0) {\n\tcase 0x10: // bpl $ffff\n\t\tflag = \"N,!\";\n\t\tbreak;\n\tcase 0x30: // bmi $ffff\n\t\tflag = \"N\";\n\t\tbreak;\n\tcase 0x50: // bvc $ffff\n\t\tflag = \"V,!\";\n\t\tbreak;\n\tcase 0x70: // bvs $ffff\n\t\tflag = \"V\";\n\t\tbreak;\n\tcase 0x90: // bcc $ffff\n\t\tflag = \"C,!\";\n\t\tbreak;\n\tcase 0xb0: // bcs $ffff\n\t\tflag = \"C\";\n\t\tbreak;\n\tcase 0xd0: // bne $ffff\n\t\tflag = \"Z,!\";\n\t\tbreak;\n\tcase 0xf0: // beq $ffff\n\t\tflag = \"Z\";\n\t\tbreak;\n\tdefault:\n\t\t// FIXME: should not happen\n\t\tflag = \"unk\";\n\t\tbreak;\n\t}\n\tr_strbuf_setf (&op->esil, \"%s,?{,0x%04x,pc,=,}\", flag, (op->jump & 0xffff));\n}\n\n// inc register\nstatic void _6502_anal_esil_inc_reg(RAnalOp *op, ut8 data0, char* sign)\n{\n\tchar* reg = NULL;\n\n\tswitch(data0) {\n\tcase 0xe8: // inx\n\tcase 0xca: // dex\n\t\treg = \"x\";\n\t\tbreak;\n\tcase 0xc8: // iny\n\tcase 0x88: // dey\n\t\treg = \"y\";\n\t\tbreak;\n\t}\n\tr_strbuf_setf (&op->esil, \"%s,%s%s=\", reg, sign, sign);\n\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n}\n\nstatic void _6502_anal_esil_mov(RAnalOp *op, ut8 data0) {\n\tconst char* src=\"unk\";\n\tconst char* dst=\"unk\";\n\tswitch(data0) {\n\tcase 0xaa: // tax\n\t\tsrc=\"a\";\n\t\tdst=\"x\";\n\t\tbreak;\n\tcase 0x8a: // txa\n\t\tsrc=\"x\";\n\t\tdst=\"a\";\n\t\tbreak;\n\tcase 0xa8: // tay\n\t\tsrc=\"a\";\n\t\tdst=\"y\";\n\t\tbreak;\n\tcase 0x98: // tya\n\t\tsrc=\"y\";\n\t\tdst=\"a\";\n\t\tbreak;\n\tcase 0x9a: // txs\n\t\tsrc=\"x\";\n\t\tdst=\"sp\";\n\t\tbreak;\n\tcase 0xba: // tsx\n\t\tsrc=\"sp\";\n\t\tdst=\"x\";\n\t\tbreak;\n\tdefault:\n\t\t// FIXME: should not happen\n\t\tbreak;\n\t}\n\tr_strbuf_setf (&op->esil, \"%s,%s,=\",src,dst);\n\n\t// don't update NZ on txs\n\tif (data0 != 0x9a) _6502_anal_update_flags (op, _6502_FLAGS_NZ);\n}\n\nstatic void _6502_anal_esil_push(RAnalOp *op, ut8 data0) {\n\t// case 0x08: // php\n\t// case 0x48: // pha\n\tchar *reg = (data0==0x08) ? \"flags\" : \"a\";\n\t// stack is on page one: sp + 0x100\n\tr_strbuf_setf (&op->esil, \"%s,sp,0x100,+,=[1],sp,--=\", reg);\n}\n\nstatic void _6502_anal_esil_pop(RAnalOp *op, ut8 data0) {\n\t// case 0x28: // plp\n\t// case 0x68: // pla\n\tchar *reg = (data0==0x28) ? \"flags\" : \"a\";\n\t// stack is on page one: sp + 0x100\n\tr_strbuf_setf (&op->esil, \"sp,++=,sp,0x100,+,[1],%s,=\", reg);\n\n\tif (data0==0x68) _6502_anal_update_flags (op, _6502_FLAGS_NZ);\n}\n\nstatic void _6502_anal_esil_flags(RAnalOp *op, ut8 data0) {\n\tint enabled=0;\n\tchar flag ='u';\n\tswitch(data0) {\n\tcase 0x78: // sei\n\t\tenabled = 1;\n\t\tflag = 'I';\n\t\tbreak;\n\tcase 0x58: // cli\n\t\tenabled = 0;\n\t\tflag = 'I';\n\t\tbreak;\n\tcase 0x38: // sec\n\t\tenabled = 1;\n\t\tflag = 'C';\n\t\tbreak;\n\tcase 0x18: // clc\n\t\tenabled = 0;\n\t\tflag = 'C';\n\t\tbreak;\n\tcase 0xf8: // sed\n\t\tenabled = 1;\n\t\tflag = 'D';\n\t\tbreak;\n\tcase 0xd8: // cld\n\t\tenabled = 0;\n\t\tflag = 'D';\n\t\tbreak;\n\tcase 0xb8: // clv\n\t\tenabled = 0;\n\t\tflag = 'V';\n\t\tbreak;\n\t\tbreak;\n\t}\n\tr_strbuf_setf (&op->esil, \"%d,%c,=\", enabled, flag);\n}\n\nstatic int _6502_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tchar addrbuf[64];\n\tconst int buffsize = sizeof (addrbuf) - 1;\n\n\tmemset (op, '\\0', sizeof (RAnalOp));\n\top->size = snes_op_get_size (1, 1, &snes_op[data[0]]);\t//snes-arch is similiar to nes/6502\n\top->addr = addr;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->id = data[0];\n\tr_strbuf_init (&op->esil);\n\tswitch (data[0]) {\n\tcase 0x02:\n\tcase 0x03:\n\tcase 0x04:\n\tcase 0x07:\n\tcase 0x0b:\n\tcase 0x0c:\n\tcase 0x0f:\n\tcase 0x12:\n\tcase 0x13:\n\tcase 0x14:\n\tcase 0x17:\n\tcase 0x1a:\n\tcase 0x1b:\n\tcase 0x1c:\n\tcase 0x1f:\n\tcase 0x22:\n\tcase 0x23:\n\tcase 0x27:\n\tcase 0x2b:\n\tcase 0x2f:\n\tcase 0x32:\n\tcase 0x33:\n\tcase 0x34:\n\tcase 0x37:\n\tcase 0x3a:\n\tcase 0x3b:\n\tcase 0x3c:\n\tcase 0x3f:\n\tcase 0x42:\n\tcase 0x43:\n\tcase 0x44:\n\tcase 0x47:\n\tcase 0x4b:\n\tcase 0x4f:\n\tcase 0x52:\n\tcase 0x53:\n\tcase 0x54:\n\tcase 0x57:\n\tcase 0x5a:\n\tcase 0x5b:\n\tcase 0x5c:\n\tcase 0x5f:\n\tcase 0x62:\n\tcase 0x63:\n\tcase 0x64:\n\tcase 0x67:\n\tcase 0x6b:\n\tcase 0x6f:\n\tcase 0x72:\n\tcase 0x73:\n\tcase 0x74:\n\tcase 0x77:\n\tcase 0x7a:\n\tcase 0x7b:\n\tcase 0x7c:\n\tcase 0x7f:\n\tcase 0x80:\n\tcase 0x82:\n\tcase 0x83:\n\tcase 0x87:\n\tcase 0x89:\n\tcase 0x8b:\n\tcase 0x8f:\n\tcase 0x92:\n\tcase 0x93:\n\tcase 0x97:\n\tcase 0x9b:\n\tcase 0x9c:\n\tcase 0x9e:\n\tcase 0x9f:\n\tcase 0xa3:\n\tcase 0xa7:\n\tcase 0xab:\n\tcase 0xaf:\n\tcase 0xb2:\n\tcase 0xb3:\n\tcase 0xb7:\n\tcase 0xbb:\n\tcase 0xbf:\n\tcase 0xc2:\n\tcase 0xc3:\n\tcase 0xc7:\n\tcase 0xcb:\n\tcase 0xcf:\n\tcase 0xd2:\n\tcase 0xd3:\n\tcase 0xd4:\n\tcase 0xd7:\n\tcase 0xda:\n\tcase 0xdb:\n\tcase 0xdc:\n\tcase 0xdf:\n\tcase 0xe2:\n\tcase 0xe3:\n\tcase 0xe7:\n\tcase 0xeb:\n\tcase 0xef:\n\tcase 0xf2:\n\tcase 0xf3:\n\tcase 0xf4:\n\tcase 0xf7:\n\tcase 0xfa:\n\tcase 0xfb:\n\tcase 0xfc:\n\tcase 0xff:\n\t\t// undocumented or not-implemented opcodes for 6502.\n\t\t// some of them might be implemented in 65816\n\t\top->size = 1;\n\t\top->type = R_ANAL_OP_TYPE_ILL;\n\t\tbreak;\n\n\t// BRK\n\tcase 0x00: // brk\n\t\top->cycles = 7;\n\t\top->type = R_ANAL_OP_TYPE_SWI;\n\t\t// override 65816 code which seems to be wrong: size is 1, but pc = pc + 2\n\t\top->size = 1;\n\t\t// PC + 2 to Stack, P to Stack  B=1 D=0 I=1. \"B\" is not a flag. Only its bit is pushed on the stack\n\t\t// PC was already incremented by one at this point. Needs to incremented once more\n\t\t// New PC is Interrupt Vector: $fffe. (FIXME: Confirm this is valid for all 6502)\n\t\tr_strbuf_set (&op->esil, \",1,I,=,0,D,=,flags,0x10,|,0x100,sp,+,=[1],pc,1,+,0xfe,sp,+,=[2],3,sp,-=,0xfffe,[2],pc,=\");\n\t\tbreak;\n\n\t// FLAGS\n\tcase 0x78: // sei\n\tcase 0x58: // cli\n\tcase 0x38: // sec\n\tcase 0x18: // clc\n\tcase 0xf8: // sed\n\tcase 0xd8: // cld\n\tcase 0xb8: // clv\n\t\top->cycles = 2;\n\t\t// FIXME: what opcode for this?\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\t_6502_anal_esil_flags (op, data[0]);\n\t\tbreak;\n\t// BIT\n\tcase 0x24: // bit $ff\n\tcase 0x2c: // bit $ffff\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 0);\n\t\tr_strbuf_setf (&op->esil, \"a,%s,[1],&,0x80,&,!,!,N,=,a,%s,[1],&,0x40,&,!,!,V,=,a,%s,[1],&,0xff,&,!,Z,=\",addrbuf, addrbuf, addrbuf);\n\t\tbreak;\n\t// ADC\n\tcase 0x69: // adc #$ff\n\tcase 0x65: // adc $ff\n\tcase 0x75: // adc $ff,x\n\tcase 0x6d: // adc $ffff\n\tcase 0x7d: // adc $ffff,x\n\tcase 0x79: // adc $ffff,y\n\tcase 0x61: // adc ($ff,x)\n\tcase 0x71: // adc ($ff,y)\n\t\t// FIXME: update V\n\t\t// FIXME: support BCD mode\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tif (data[0] == 0x69) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\t// fix Z\n\t\tr_strbuf_append (&op->esil, \",a,a,=,$z,Z,=\");\n\t\tbreak;\n\t// SBC\n\tcase 0xe9: // sbc #$ff\n\tcase 0xe5: // sbc $ff\n\tcase 0xf5: // sbc $ff,x\n\tcase 0xed: // sbc $ffff\n\tcase 0xfd: // sbc $ffff,x\n\tcase 0xf9: // sbc $ffff,y\n\tcase 0xe1: // sbc ($ff,x)\n\tcase 0xf1: // sbc ($ff,y)\n\t\t// FIXME: update V\n\t\t// FIXME: support BCD mode\n\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tif (data[0] == 0xe9) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"C,!,%s,+,a,-=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"C,!,%s,[1],+,a,-=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_BNZ);\n\t\t// fix Z and revert C\n\t\tr_strbuf_append (&op->esil, \",a,a,=,$z,Z,=,C,!=\");\n\t\tbreak;\n\t// ORA\n\tcase 0x09: // ora #$ff\n\tcase 0x05: // ora $ff\n\tcase 0x15: // ora $ff,x\n\tcase 0x0d: // ora $ffff\n\tcase 0x1d: // ora $ffff,x\n\tcase 0x19: // ora $ffff,y\n\tcase 0x01: // ora ($ff,x)\n\tcase 0x11: // ora ($ff),y\n\t\top->type = R_ANAL_OP_TYPE_OR;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tif (data[0] == 0x09) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,a,|=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],a,|=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// AND\n\tcase 0x29: // and #$ff\n\tcase 0x25: // and $ff\n\tcase 0x35: // and $ff,x\n\tcase 0x2d: // and $ffff\n\tcase 0x3d: // and $ffff,x\n\tcase 0x39: // and $ffff,y\n\tcase 0x21: // and ($ff,x)\n\tcase 0x31: // and ($ff),y\n\t\top->type = R_ANAL_OP_TYPE_AND;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tif (data[0] == 0x29) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,a,&=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],a,&=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// EOR\n\tcase 0x49: // eor #$ff\n\tcase 0x45: // eor $ff\n\tcase 0x55: // eor $ff,x\n\tcase 0x4d: // eor $ffff\n\tcase 0x5d: // eor $ffff,x\n\tcase 0x59: // eor $ffff,y\n\tcase 0x41: // eor ($ff,x)\n\tcase 0x51: // eor ($ff),y\n\t\top->type = R_ANAL_OP_TYPE_XOR;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tif (data[0] == 0x49) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,a,^=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],a,^=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// ASL\n\tcase 0x0a: // asl a\n\tcase 0x06: // asl $ff\n\tcase 0x16: // asl $ff,x\n\tcase 0x0e: // asl $ffff\n\tcase 0x1e: // asl $ffff,x\n\t\top->type = R_ANAL_OP_TYPE_SHL;\n\t\tif (data[0] == 0x0a) {\n\t\t\tr_strbuf_set (&op->esil, \"1,a,<<=,$c7,C,=,a,a,=\");\n\t\t} else  {\n\t\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\n\t\t\tr_strbuf_setf (&op->esil, \"1,%s,[1],<<,%s,=[1],$c7,C,=\", addrbuf, addrbuf);\n\t\t}\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// LSR\n\tcase 0x4a: // lsr a\n\tcase 0x46: // lsr $ff\n\tcase 0x56: // lsr $ff,x\n\tcase 0x4e: // lsr $ffff\n\tcase 0x5e: // lsr $ffff,x\n\t\top->type = R_ANAL_OP_TYPE_SHR;\n\t\tif (data[0] == 0x4a) {\n\t\t\tr_strbuf_set (&op->esil, \"1,a,&,C,=,1,a,>>=\");\n\t\t} else {\n\t\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\n\t\t\tr_strbuf_setf (&op->esil, \"1,%s,[1],&,C,=,1,%s,[1],>>,%s,=[1]\", addrbuf, addrbuf, addrbuf);\n\t\t}\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// ROL\n\tcase 0x2a: // rol a\n\tcase 0x26: // rol $ff\n\tcase 0x36: // rol $ff,x\n\tcase 0x2e: // rol $ffff\n\tcase 0x3e: // rol $ffff,x\n\t\top->type = R_ANAL_OP_TYPE_ROL;\n\t\tif (data[0] == 0x2a) {\n\t\t\tr_strbuf_set (&op->esil, \"1,a,<<,C,|,a,=,$c7,C,=,a,a,=\");\n\t\t} else {\n\t\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\n\t\t\tr_strbuf_setf (&op->esil, \"1,%s,[1],<<,C,|,%s,=[1],$c7,C,=\", addrbuf, addrbuf);\n\t\t}\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// ROR\n\tcase 0x6a: // ror a\n\tcase 0x66: // ror $ff\n\tcase 0x76: // ror $ff,x\n\tcase 0x6e: // ror $ffff\n\tcase 0x7e: // ror $ffff,x\n\t\t// uses N as temporary to hold C value. but in fact,\n\t\t// it is not temporary since in all ROR ops, N will have the value of C\n\t\top->type = R_ANAL_OP_TYPE_ROR;\n\t\tif (data[0] == 0x6a) {\n\t\t\tr_strbuf_set (&op->esil, \"C,N,=,1,a,&,C,=,1,a,>>,7,N,<<,|,a,=\");\n\t\t} else {\n\t\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\n\t\t\tr_strbuf_setf (&op->esil, \"C,N,=,1,%s,[1],&,C,=,1,%s,[1],>>,7,N,<<,|,%s,=[1]\", addrbuf, addrbuf, addrbuf);\n\t\t}\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// INC\n\tcase 0xe6: // inc $ff\n\tcase 0xf6: // inc $ff,x\n\tcase 0xee: // inc $ffff\n\tcase 0xfe: // inc $ffff,x\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\n\t\tr_strbuf_setf (&op->esil, \"%s,++=[1]\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// DEC\n\tcase 0xc6: // dec $ff\n\tcase 0xd6: // dec $ff,x\n\tcase 0xce: // dec $ffff\n\tcase 0xde: // dec $ffff,x\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\n\t\tr_strbuf_setf (&op->esil, \"%s,--=[1]\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// INX, INY\n\tcase 0xe8: // inx\n\tcase 0xc8: // iny\n\t\top->cycles = 2;\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t_6502_anal_esil_inc_reg (op, data[0], \"+\");\n\t\tbreak;\n\t// DEX, DEY\n\tcase 0xca: // dex\n\tcase 0x88: // dey\n\t\top->cycles = 2;\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t_6502_anal_esil_inc_reg (op, data[0], \"-\");\n\t\tbreak;\n\t// CMP\n\tcase 0xc9: // cmp #$ff\n\tcase 0xc5: // cmp $ff\n\tcase 0xd5: // cmp $ff,x\n\tcase 0xcd: // cmp $ffff\n\tcase 0xdd: // cmp $ffff,x\n\tcase 0xd9: // cmp $ffff,y\n\tcase 0xc1: // cmp ($ff,x)\n\tcase 0xd1: // cmp ($ff),y\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tif (data[0] == 0xc9) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,a,==\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],a,==\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_BNZ);\n\t\t// invert C, since C=1 when A-M >= 0\n\t\tr_strbuf_append (&op->esil, \",C,!,C,=\");\n\t\tbreak;\n\t// CPX\n\tcase 0xe0: // cpx #$ff\n\tcase 0xe4: // cpx $ff\n\tcase 0xec: // cpx $ffff\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\t_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 0);\n\t\tif (data[0] == 0xe0) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,x,==\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],x,==\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_BNZ);\n\t\t// invert C, since C=1 when A-M >= 0\n\t\tr_strbuf_append (&op->esil, \",C,!,C,=\");\n\t\tbreak;\n\t// CPY\n\tcase 0xc0: // cpy #$ff\n\tcase 0xc4: // cpy $ff\n\tcase 0xcc: // cpy $ffff\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\t_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 0);\n\t\tif (data[0] == 0xc0) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,y,==\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],y,==\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_BNZ);\n\t\t// invert C, since C=1 when A-M >= 0\n\t\tr_strbuf_append (&op->esil, \",C,!,C,=\");\n\t\tbreak;\n\t// BRANCHES\n\tcase 0x10: // bpl $ffff\n\tcase 0x30: // bmi $ffff\n\tcase 0x50: // bvc $ffff\n\tcase 0x70: // bvs $ffff\n\tcase 0x90: // bcc $ffff\n\tcase 0xb0: // bcs $ffff\n\tcase 0xd0: // bne $ffff\n\tcase 0xf0: // beq $ffff\n\t\t// FIXME: Add 1 if branch occurs to same page.\n\t\t// FIXME: Add 2 if branch occurs to different page\n\t\top->cycles = 2;\n\t\top->failcycles = 3;\n\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\tif (data[1] <= 127)\n\t\t\top->jump = addr + data[1] + op->size;\n\t\telse\top->jump = addr - (256 - data[1]) + op->size;\n\t\top->fail = addr + op->size;\n\t\t// FIXME: add a type of conditional\n\t\t// op->cond = R_ANAL_COND_LE;\n\t\t_6502_anal_esil_ccall (op, data[0]);\n\t\tbreak;\n\t// JSR\n\tcase 0x20: // jsr $ffff\n\t\top->cycles = 6;\n\t\top->type = R_ANAL_OP_TYPE_CALL;\n\t\top->jump = data[1] | data[2] << 8;\n\t\top->stackop = R_ANAL_STACK_INC;\n\t\top->stackptr = 2;\n\t\t// JSR pushes the address-1 of the next operation on to the stack before transferring program\n\t\t// control to the following address\n\t\t// stack is on page one and sp is an 8-bit reg: operations must be done like: sp + 0x100\n\t\tr_strbuf_setf (&op->esil, \"1,pc,-,0xff,sp,+,=[2],0x%04x,pc,=,2,sp,-=\", op->jump);\n\t\tbreak;\n\t// JMP\n\tcase 0x4c: // jmp $ffff\n\t\top->cycles = 3;\n\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\top->jump = data[1] | data[2] << 8;\n\t\tr_strbuf_setf (&op->esil, \"0x%04x,pc,=\", op->jump);\n\t\tbreak;\n\tcase 0x6c: // jmp ($ffff)\n\t\top->cycles = 5;\n\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\t// FIXME: how to read memory?\n\t\t// op->jump = data[1] | data[2] << 8;\n\t\tr_strbuf_setf (&op->esil, \"0x%04x,[2],pc,=\", data[1] | data[2] << 8);\n\t\tbreak;\n\t// RTS\n\tcase 0x60: // rts\n\t\top->eob = true;\n\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\top->cycles = 6;\n\t\top->stackop = R_ANAL_STACK_INC;\n\t\top->stackptr = -2;\n\t\t// Operation:  PC from Stack, PC + 1 -> PC\n\t\t// stack is on page one and sp is an 8-bit reg: operations must be done like: sp + 0x100\n\t\tr_strbuf_set (&op->esil, \"0x101,sp,+,[2],pc,=,pc,++=,2,sp,+=\");\n\t\tbreak;\n\t// RTI\n\tcase 0x40: // rti\n\t\top->eob = true;\n\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\top->cycles = 6;\n\t\top->stackop = R_ANAL_STACK_INC;\n\t\top->stackptr = -3;\n\t\t// Operation: P from Stack, PC from Stack\n\t\t// stack is on page one and sp is an 8-bit reg: operations must be done like: sp + 0x100\n\t\tr_strbuf_set (&op->esil, \"0x101,sp,+,[1],flags,=,0x102,sp,+,[2],pc,=,3,sp,+=\");\n\t\tbreak;\n\t// NOP\n\tcase 0xea: // nop\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\top->cycles = 2;\n\t\tbreak;\n\t// LDA\n\tcase 0xa9: // lda #$ff\n\tcase 0xa5: // lda $ff\n\tcase 0xb5: // lda $ff,x\n\tcase 0xad: // lda $ffff\n\tcase 0xbd: // lda $ffff,x\n\tcase 0xb9: // lda $ffff,y\n\tcase 0xa1: // lda ($ff,x)\n\tcase 0xb1: // lda ($ff),y\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tif (data[0] == 0xa9) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,a,=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],a,=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// LDX\n\tcase 0xa2: // ldx #$ff\n\tcase 0xa6: // ldx $ff\n\tcase 0xb6: // ldx $ff,y\n\tcase 0xae: // ldx $ffff\n\tcase 0xbe: // ldx $ffff,y\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'y');\n\t\tif (data[0] == 0xa2) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,x,=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],x,=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// LDY\n\tcase 0xa0: // ldy #$ff\n\tcase 0xa4: // ldy $ff\n\tcase 0xb4: // ldy $ff,x\n\tcase 0xac: // ldy $ffff\n\tcase 0xbc: // ldy $ffff,x\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\t_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 'x');\n\t\tif (data[0] == 0xa0) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,y,=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],y,=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// STA\n\tcase 0x85: // sta $ff\n\tcase 0x95: // sta $ff,x\n\tcase 0x8d: // sta $ffff\n\tcase 0x9d: // sta $ffff,x\n\tcase 0x99: // sta $ffff,y\n\tcase 0x81: // sta ($ff,x)\n\tcase 0x91: // sta ($ff),y\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tr_strbuf_setf (&op->esil, \"a,%s,=[1]\", addrbuf);\n\t\tbreak;\n\t// STX\n\tcase 0x86: // stx $ff\n\tcase 0x96: // stx $ff,y\n\tcase 0x8e: // stx $ffff\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'y');\n\t\tr_strbuf_setf (&op->esil, \"x,%s,=[1]\", addrbuf);\n\t\tbreak;\n\t// STY\n\tcase 0x84: // sty $ff\n\tcase 0x94: // sty $ff,x\n\tcase 0x8c: // sty $ffff\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 'x');\n\t\tr_strbuf_setf (&op->esil, \"y,%s,=[1]\", addrbuf);\n\t\tbreak;\n\t// PHP/PHA\n\tcase 0x08: // php\n\tcase 0x48: // pha\n\t\top->type = R_ANAL_OP_TYPE_PUSH;\n\t\top->cycles = 3;\n\t\top->stackop = R_ANAL_STACK_INC;\n\t\top->stackptr = 1;\n\t\t_6502_anal_esil_push (op, data[0]);\n\t\tbreak;\n\t// PLP,PLA\n\tcase 0x28: // plp\n\tcase 0x68: // plp\n\t\top->type = R_ANAL_OP_TYPE_POP;\n\t\top->cycles = 4;\n\t\top->stackop = R_ANAL_STACK_INC;\n\t\top->stackptr = -1;\n\t\t_6502_anal_esil_pop (op, data[0]);\n\t\tbreak;\n\t// TAX,TYA,...\n\tcase 0xaa: // tax\n\tcase 0x8a: // txa\n\tcase 0xa8: // tay\n\tcase 0x98: // tya\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->cycles = 2;\n\t\t_6502_anal_esil_mov (op, data[0]);\n\t\tbreak;\n\tcase 0x9a: // txs\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->cycles = 2;\n\t\top->stackop = R_ANAL_STACK_SET;\n\t\t// FIXME: should I get register X a place it here?\n\t\t// op->stackptr = get_register_x();\n\t\t_6502_anal_esil_mov (op, data[0]);\n\t\tbreak;\n\tcase 0xba: // tsx\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->cycles = 2;\n\t\top->stackop = R_ANAL_STACK_GET;\n\t\t_6502_anal_esil_mov (op, data[0]);\n\t\tbreak;\n\t}\n\treturn op->size;\n}\n\nstatic int set_reg_profile(RAnal *anal) {\n\tchar *p =\n\t\t\"=PC\tpc\\n\"\n\t\t\"=SP\tsp\\n\"\n\t\t\"gpr\ta\t.8\t0\t0\\n\"\n\t\t\"gpr\tx\t.8\t1\t0\\n\"\n\t\t\"gpr\ty\t.8\t2\t0\\n\"\n\n\t\t\"gpr\tflags\t.8\t3\t0\\n\"\n\t\t\"gpr\tC\t.1\t.24\t0\\n\"\n\t\t\"gpr\tZ\t.1\t.25\t0\\n\"\n\t\t\"gpr\tI\t.1\t.26\t0\\n\"\n\t\t\"gpr\tD\t.1\t.27\t0\\n\"\n\t\t// bit 4 (.28) is NOT a real flag.\n\t\t// \"gpr\tB\t.1\t.28\t0\\n\"\n\t\t// bit 5 (.29) is not used\n\t\t\"gpr\tV\t.1\t.30\t0\\n\"\n\t\t\"gpr\tN\t.1\t.31\t0\\n\"\n\t\t\"gpr\tsp\t.8\t4\t0\\n\"\n\t\t\"gpr\tpc\t.16\t5\t0\\n\";\n\treturn r_reg_set_profile_string (anal->reg, p);\n}\n\nstatic int esil_6502_init (RAnalEsil *esil) {\n\tif (esil->anal && esil->anal->reg) {\t\t//initial values\n\t\tr_reg_set_value (esil->anal->reg, r_reg_get (esil->anal->reg, \"pc\", -1), 0x0000);\n\t\tr_reg_set_value (esil->anal->reg, r_reg_get (esil->anal->reg, \"sp\", -1), 0xff);\n\t\tr_reg_set_value (esil->anal->reg, r_reg_get (esil->anal->reg, \"a\", -1), 0x00);\n\t\tr_reg_set_value (esil->anal->reg, r_reg_get (esil->anal->reg, \"x\", -1), 0x00);\n\t\tr_reg_set_value (esil->anal->reg, r_reg_get (esil->anal->reg, \"y\", -1), 0x00);\n\t\tr_reg_set_value (esil->anal->reg, r_reg_get (esil->anal->reg, \"flags\", -1), 0x00);\n\t}\n\treturn true;\n}\n\nstatic int esil_6502_fini (RAnalEsil *esil) {\n\treturn true;\n}\n\nRAnalPlugin r_anal_plugin_6502 = {\n\t.name = \"6502\",\n\t.desc = \"6502/NES analysis plugin\",\n\t.license = \"LGPL3\",\n\t.arch = \"6502\",\n\t.bits = 8,\n\t.op = &_6502_op,\n\t.set_reg_profile = &set_reg_profile,\n\t.esil = true,\n\t.esil_init = esil_6502_init,\n\t.esil_fini = esil_6502_fini,\n};\n\n#ifndef CORELIB\nRLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_ANAL,\n\t.data = &r_anal_plugin_6502,\n\t.version = R2_VERSION\n};\n#endif\n"], "fixing_code": ["/* radare - LGPL - Copyright 2015 - condret, riq */\n\n/* 6502 info taken from http://unusedino.de/ec64/technical/aay/c64/bchrt651.htm\n *\n * Mnemonics logic based on:\n *\thttp://homepage.ntlworld.com/cyborgsystems/CS_Main/6502/6502.htm\n * and:\n *\thttp://vice-emu.sourceforge.net/\n */\n\n#include <string.h>\n#include <r_types.h>\n#include <r_lib.h>\n#include <r_asm.h>\n#include <r_anal.h>\n#include \"../../asm/arch/snes/snes_op_table.h\"\n\nenum {\n\t_6502_FLAGS_C = (1 << 0),\n\t_6502_FLAGS_B = (1 << 1),\n\t_6502_FLAGS_Z = (1 << 2),\n\t_6502_FLAGS_N = (1 << 3),\n\n\t_6502_FLAGS_NZ = (_6502_FLAGS_Z | _6502_FLAGS_N),\n\t_6502_FLAGS_CNZ = (_6502_FLAGS_C | _6502_FLAGS_Z | _6502_FLAGS_N),\n\t_6502_FLAGS_BNZ = (_6502_FLAGS_B | _6502_FLAGS_Z | _6502_FLAGS_N),\n};\n\nstatic void _6502_anal_update_flags(RAnalOp *op, int flags) {\n\t/* FIXME: $b9 instead of $b8 to prevent the bug triggered by: A = 0 - 0xff - 1 */\n\tif (flags & _6502_FLAGS_B) r_strbuf_append (&op->esil, \",$b9,C,=\");\n\tif (flags & _6502_FLAGS_C) r_strbuf_append (&op->esil, \",$c7,C,=\");\n\tif (flags & _6502_FLAGS_Z) r_strbuf_append (&op->esil, \",$z,Z,=\");\n\tif (flags & _6502_FLAGS_N) r_strbuf_append (&op->esil, \",$s,N,=\");\n}\n\n/* ORA, AND, EOR, ADC, STA, LDA, CMP and SBC share this pattern */\nstatic void _6502_anal_esil_get_addr_pattern1(RAnalOp *op, const ut8* data, char* addrbuf, int addrsize) {\n\t// turn off bits 5, 6 and 7\n\tswitch(data[0] & 0x1f) { // 0x1f = b00111111\n\tcase 0x09: // op #$ff\n\t\top->cycles = 2;\n\t\tsnprintf (addrbuf, addrsize,\"0x%02x\", data[1]);\n\t\tbreak;\n\tcase 0x05: // op $ff\n\t\top->cycles = 3;\n\t\tsnprintf (addrbuf, addrsize,\"0x%02x\", data[1]);\n\t\tbreak;\n\tcase 0x15: // op $ff,x\n\t\top->cycles = 4;\n\t\tsnprintf (addrbuf, addrsize,\"x,0x%02x,+\", data[1]);\n\t\tbreak;\n\tcase 0x0d: // op $ffff\n\t\top->cycles = 4;\n\t\tsnprintf (addrbuf, addrsize,\"0x%04x\", data[1] | data[2] << 8);\n\t\tbreak;\n\tcase 0x1d: // op $ffff,x\n\t\t// FIXME: Add 1 if page boundary is crossed.\n\t\top->cycles = 4;\n\t\tsnprintf (addrbuf, addrsize,\"x,0x%04x,+\", data[1] | data[2] << 8);\n\t\tbreak;\n\tcase 0x19: // op $ffff,y\n\t\t// FIXME: Add 1 if page boundary is crossed.\n\t\top->cycles = 4;\n\t\tsnprintf (addrbuf, addrsize,\"y,0x%04x,+\", data[1] | data[2] << 8);\n\t\tbreak;\n\tcase 0x01: // op ($ff,x)\n\t\top->cycles = 6;\n\t\tsnprintf (addrbuf, addrsize,\"x,0x%02x,+,[2]\", data[1]);\n\t\tbreak;\n\tcase 0x11: // op ($ff),y\n\t\t// FIXME: Add 1 if page boundary is crossed.\n\t\top->cycles = 5;\n\t\tsnprintf (addrbuf, addrsize,\"y,0x%02x,[2],+\", data[1]);\n\t\tbreak;\n\t}\n}\n\n/* ASL, ROL, LSR, ROR, STX, LDX, DEC and INC share this pattern */\nstatic void _6502_anal_esil_get_addr_pattern2(RAnalOp *op, const ut8* data, char* addrbuf, int addrsize, char reg) {\n\t// turn off bits 5, 6 and 7\n\tswitch(data[0] & 0x1f) { // 0x1f = b00111111\n\tcase 0x02: // op #$ff\n\t\top->cycles = 2;\n\t\tsnprintf (addrbuf, addrsize, \"0x%02x\", data[1]);\n\t\tbreak;\n\tcase 0x0a: //op a\n\t\top->cycles = 2;\n\t\tsnprintf (addrbuf, addrsize, \"a\");\n\t\tbreak;\n\tcase 0x06: // op $ff\n\t\top->cycles = 5;\n\t\tsnprintf (addrbuf, addrsize, \"0x%02x\", data[1]);\n\t\tbreak;\n\tcase 0x16: // op $ff,x\n\t\top->cycles = 6;\n\t\tsnprintf (addrbuf, addrsize, \"%c,0x%02x,+\", reg, data[1]);\n\t\tbreak;\n\tcase 0x0e: // op $ffff\n\t\top->cycles = 6;\n\t\tsnprintf (addrbuf, addrsize, \"0x%04x\", data[1] | data[2] << 8);\n\t\tbreak;\n\tcase 0x1e: // op $ffff,x\n\t\top->cycles = 7;\n\t\tsnprintf (addrbuf, addrsize, \"%c,0x%04x,+\", reg, data[1] | data[2] << 8);\n\t\tbreak;\n\t}\n}\n\n/* BIT, JMP, JMP(), STY, LDY, CPY, and CPX share this pattern */\nstatic void _6502_anal_esil_get_addr_pattern3(RAnalOp *op, const ut8* data, char* addrbuf, int addrsize, char reg) {\n\t// turn off bits 5, 6 and 7\n\tswitch (data[0] & 0x1f) { // 0x1f = b00111111\n\tcase 0x00: // op #$ff\n\t\top->cycles = 2;\n\t\tsnprintf (addrbuf, addrsize, \"0x%02x\", data[1]);\n\t\tbreak;\n\tcase 0x08: //op a\n\t\top->cycles = 2;\n\t\tsnprintf (addrbuf, addrsize, \"a\");\n\t\tbreak;\n\tcase 0x04: // op $ff\n\t\top->cycles = 5;\n\t\tsnprintf (addrbuf, addrsize, \"0x%02x\", data[1]);\n\t\tbreak;\n\tcase 0x14: // op $ff,x\n\t\top->cycles = 6;\n\t\tsnprintf (addrbuf, addrsize, \"%c,0x%02x,+\", reg, data[1]);\n\t\tbreak;\n\tcase 0x0c: // op $ffff\n\t\top->cycles = 6;\n\t\tsnprintf (addrbuf, addrsize, \"0x%04x\", data[1] | data[2] << 8);\n\t\tbreak;\n\tcase 0x1c: // op $ffff,x\n\t\top->cycles = 7;\n\t\tsnprintf (addrbuf, addrsize, \"%c,0x%04x,+\", reg, data[1] | data[2] << 8);\n\t\tbreak;\n\t}\n}\n\nstatic void _6502_anal_esil_ccall(RAnalOp *op, ut8 data0)\n{\n\tchar *flag;\n\tswitch(data0) {\n\tcase 0x10: // bpl $ffff\n\t\tflag = \"N,!\";\n\t\tbreak;\n\tcase 0x30: // bmi $ffff\n\t\tflag = \"N\";\n\t\tbreak;\n\tcase 0x50: // bvc $ffff\n\t\tflag = \"V,!\";\n\t\tbreak;\n\tcase 0x70: // bvs $ffff\n\t\tflag = \"V\";\n\t\tbreak;\n\tcase 0x90: // bcc $ffff\n\t\tflag = \"C,!\";\n\t\tbreak;\n\tcase 0xb0: // bcs $ffff\n\t\tflag = \"C\";\n\t\tbreak;\n\tcase 0xd0: // bne $ffff\n\t\tflag = \"Z,!\";\n\t\tbreak;\n\tcase 0xf0: // beq $ffff\n\t\tflag = \"Z\";\n\t\tbreak;\n\tdefault:\n\t\t// FIXME: should not happen\n\t\tflag = \"unk\";\n\t\tbreak;\n\t}\n\tr_strbuf_setf (&op->esil, \"%s,?{,0x%04x,pc,=,}\", flag, (op->jump & 0xffff));\n}\n\n// inc register\nstatic void _6502_anal_esil_inc_reg(RAnalOp *op, ut8 data0, char* sign)\n{\n\tchar* reg = NULL;\n\n\tswitch(data0) {\n\tcase 0xe8: // inx\n\tcase 0xca: // dex\n\t\treg = \"x\";\n\t\tbreak;\n\tcase 0xc8: // iny\n\tcase 0x88: // dey\n\t\treg = \"y\";\n\t\tbreak;\n\t}\n\tr_strbuf_setf (&op->esil, \"%s,%s%s=\", reg, sign, sign);\n\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n}\n\nstatic void _6502_anal_esil_mov(RAnalOp *op, ut8 data0) {\n\tconst char* src=\"unk\";\n\tconst char* dst=\"unk\";\n\tswitch(data0) {\n\tcase 0xaa: // tax\n\t\tsrc=\"a\";\n\t\tdst=\"x\";\n\t\tbreak;\n\tcase 0x8a: // txa\n\t\tsrc=\"x\";\n\t\tdst=\"a\";\n\t\tbreak;\n\tcase 0xa8: // tay\n\t\tsrc=\"a\";\n\t\tdst=\"y\";\n\t\tbreak;\n\tcase 0x98: // tya\n\t\tsrc=\"y\";\n\t\tdst=\"a\";\n\t\tbreak;\n\tcase 0x9a: // txs\n\t\tsrc=\"x\";\n\t\tdst=\"sp\";\n\t\tbreak;\n\tcase 0xba: // tsx\n\t\tsrc=\"sp\";\n\t\tdst=\"x\";\n\t\tbreak;\n\tdefault:\n\t\t// FIXME: should not happen\n\t\tbreak;\n\t}\n\tr_strbuf_setf (&op->esil, \"%s,%s,=\",src,dst);\n\n\t// don't update NZ on txs\n\tif (data0 != 0x9a) _6502_anal_update_flags (op, _6502_FLAGS_NZ);\n}\n\nstatic void _6502_anal_esil_push(RAnalOp *op, ut8 data0) {\n\t// case 0x08: // php\n\t// case 0x48: // pha\n\tchar *reg = (data0==0x08) ? \"flags\" : \"a\";\n\t// stack is on page one: sp + 0x100\n\tr_strbuf_setf (&op->esil, \"%s,sp,0x100,+,=[1],sp,--=\", reg);\n}\n\nstatic void _6502_anal_esil_pop(RAnalOp *op, ut8 data0) {\n\t// case 0x28: // plp\n\t// case 0x68: // pla\n\tchar *reg = (data0==0x28) ? \"flags\" : \"a\";\n\t// stack is on page one: sp + 0x100\n\tr_strbuf_setf (&op->esil, \"sp,++=,sp,0x100,+,[1],%s,=\", reg);\n\n\tif (data0==0x68) _6502_anal_update_flags (op, _6502_FLAGS_NZ);\n}\n\nstatic void _6502_anal_esil_flags(RAnalOp *op, ut8 data0) {\n\tint enabled=0;\n\tchar flag ='u';\n\tswitch(data0) {\n\tcase 0x78: // sei\n\t\tenabled = 1;\n\t\tflag = 'I';\n\t\tbreak;\n\tcase 0x58: // cli\n\t\tenabled = 0;\n\t\tflag = 'I';\n\t\tbreak;\n\tcase 0x38: // sec\n\t\tenabled = 1;\n\t\tflag = 'C';\n\t\tbreak;\n\tcase 0x18: // clc\n\t\tenabled = 0;\n\t\tflag = 'C';\n\t\tbreak;\n\tcase 0xf8: // sed\n\t\tenabled = 1;\n\t\tflag = 'D';\n\t\tbreak;\n\tcase 0xd8: // cld\n\t\tenabled = 0;\n\t\tflag = 'D';\n\t\tbreak;\n\tcase 0xb8: // clv\n\t\tenabled = 0;\n\t\tflag = 'V';\n\t\tbreak;\n\t\tbreak;\n\t}\n\tr_strbuf_setf (&op->esil, \"%d,%c,=\", enabled, flag);\n}\n\nstatic int _6502_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tchar addrbuf[64];\n\tconst int buffsize = sizeof (addrbuf) - 1;\n\n\tmemset (op, '\\0', sizeof (RAnalOp));\n\top->size = snes_op_get_size (1, 1, &snes_op[data[0]]);\t//snes-arch is similiar to nes/6502\n\top->addr = addr;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->id = data[0];\n\tr_strbuf_init (&op->esil);\n\tswitch (data[0]) {\n\tcase 0x02:\n\tcase 0x03:\n\tcase 0x04:\n\tcase 0x07:\n\tcase 0x0b:\n\tcase 0x0c:\n\tcase 0x0f:\n\tcase 0x12:\n\tcase 0x13:\n\tcase 0x14:\n\tcase 0x17:\n\tcase 0x1a:\n\tcase 0x1b:\n\tcase 0x1c:\n\tcase 0x1f:\n\tcase 0x22:\n\tcase 0x23:\n\tcase 0x27:\n\tcase 0x2b:\n\tcase 0x2f:\n\tcase 0x32:\n\tcase 0x33:\n\tcase 0x34:\n\tcase 0x37:\n\tcase 0x3a:\n\tcase 0x3b:\n\tcase 0x3c:\n\tcase 0x3f:\n\tcase 0x42:\n\tcase 0x43:\n\tcase 0x44:\n\tcase 0x47:\n\tcase 0x4b:\n\tcase 0x4f:\n\tcase 0x52:\n\tcase 0x53:\n\tcase 0x54:\n\tcase 0x57:\n\tcase 0x5a:\n\tcase 0x5b:\n\tcase 0x5c:\n\tcase 0x5f:\n\tcase 0x62:\n\tcase 0x63:\n\tcase 0x64:\n\tcase 0x67:\n\tcase 0x6b:\n\tcase 0x6f:\n\tcase 0x72:\n\tcase 0x73:\n\tcase 0x74:\n\tcase 0x77:\n\tcase 0x7a:\n\tcase 0x7b:\n\tcase 0x7c:\n\tcase 0x7f:\n\tcase 0x80:\n\tcase 0x82:\n\tcase 0x83:\n\tcase 0x87:\n\tcase 0x89:\n\tcase 0x8b:\n\tcase 0x8f:\n\tcase 0x92:\n\tcase 0x93:\n\tcase 0x97:\n\tcase 0x9b:\n\tcase 0x9c:\n\tcase 0x9e:\n\tcase 0x9f:\n\tcase 0xa3:\n\tcase 0xa7:\n\tcase 0xab:\n\tcase 0xaf:\n\tcase 0xb2:\n\tcase 0xb3:\n\tcase 0xb7:\n\tcase 0xbb:\n\tcase 0xbf:\n\tcase 0xc2:\n\tcase 0xc3:\n\tcase 0xc7:\n\tcase 0xcb:\n\tcase 0xcf:\n\tcase 0xd2:\n\tcase 0xd3:\n\tcase 0xd4:\n\tcase 0xd7:\n\tcase 0xda:\n\tcase 0xdb:\n\tcase 0xdc:\n\tcase 0xdf:\n\tcase 0xe2:\n\tcase 0xe3:\n\tcase 0xe7:\n\tcase 0xeb:\n\tcase 0xef:\n\tcase 0xf2:\n\tcase 0xf3:\n\tcase 0xf4:\n\tcase 0xf7:\n\tcase 0xfa:\n\tcase 0xfb:\n\tcase 0xfc:\n\tcase 0xff:\n\t\t// undocumented or not-implemented opcodes for 6502.\n\t\t// some of them might be implemented in 65816\n\t\top->size = 1;\n\t\top->type = R_ANAL_OP_TYPE_ILL;\n\t\tbreak;\n\n\t// BRK\n\tcase 0x00: // brk\n\t\top->cycles = 7;\n\t\top->type = R_ANAL_OP_TYPE_SWI;\n\t\t// override 65816 code which seems to be wrong: size is 1, but pc = pc + 2\n\t\top->size = 1;\n\t\t// PC + 2 to Stack, P to Stack  B=1 D=0 I=1. \"B\" is not a flag. Only its bit is pushed on the stack\n\t\t// PC was already incremented by one at this point. Needs to incremented once more\n\t\t// New PC is Interrupt Vector: $fffe. (FIXME: Confirm this is valid for all 6502)\n\t\tr_strbuf_set (&op->esil, \",1,I,=,0,D,=,flags,0x10,|,0x100,sp,+,=[1],pc,1,+,0xfe,sp,+,=[2],3,sp,-=,0xfffe,[2],pc,=\");\n\t\tbreak;\n\n\t// FLAGS\n\tcase 0x78: // sei\n\tcase 0x58: // cli\n\tcase 0x38: // sec\n\tcase 0x18: // clc\n\tcase 0xf8: // sed\n\tcase 0xd8: // cld\n\tcase 0xb8: // clv\n\t\top->cycles = 2;\n\t\t// FIXME: what opcode for this?\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\t_6502_anal_esil_flags (op, data[0]);\n\t\tbreak;\n\t// BIT\n\tcase 0x24: // bit $ff\n\tcase 0x2c: // bit $ffff\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\t_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 0);\n\t\tr_strbuf_setf (&op->esil, \"a,%s,[1],&,0x80,&,!,!,N,=,a,%s,[1],&,0x40,&,!,!,V,=,a,%s,[1],&,0xff,&,!,Z,=\",addrbuf, addrbuf, addrbuf);\n\t\tbreak;\n\t// ADC\n\tcase 0x69: // adc #$ff\n\tcase 0x65: // adc $ff\n\tcase 0x75: // adc $ff,x\n\tcase 0x6d: // adc $ffff\n\tcase 0x7d: // adc $ffff,x\n\tcase 0x79: // adc $ffff,y\n\tcase 0x61: // adc ($ff,x)\n\tcase 0x71: // adc ($ff,y)\n\t\t// FIXME: update V\n\t\t// FIXME: support BCD mode\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tif (data[0] == 0x69) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],a,+=,C,NUM,$c7,C,=,a,+=,$c7,C,|=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\t// fix Z\n\t\tr_strbuf_append (&op->esil, \",a,a,=,$z,Z,=\");\n\t\tbreak;\n\t// SBC\n\tcase 0xe9: // sbc #$ff\n\tcase 0xe5: // sbc $ff\n\tcase 0xf5: // sbc $ff,x\n\tcase 0xed: // sbc $ffff\n\tcase 0xfd: // sbc $ffff,x\n\tcase 0xf9: // sbc $ffff,y\n\tcase 0xe1: // sbc ($ff,x)\n\tcase 0xf1: // sbc ($ff,y)\n\t\t// FIXME: update V\n\t\t// FIXME: support BCD mode\n\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tif (data[0] == 0xe9) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"C,!,%s,+,a,-=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"C,!,%s,[1],+,a,-=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_BNZ);\n\t\t// fix Z and revert C\n\t\tr_strbuf_append (&op->esil, \",a,a,=,$z,Z,=,C,!=\");\n\t\tbreak;\n\t// ORA\n\tcase 0x09: // ora #$ff\n\tcase 0x05: // ora $ff\n\tcase 0x15: // ora $ff,x\n\tcase 0x0d: // ora $ffff\n\tcase 0x1d: // ora $ffff,x\n\tcase 0x19: // ora $ffff,y\n\tcase 0x01: // ora ($ff,x)\n\tcase 0x11: // ora ($ff),y\n\t\top->type = R_ANAL_OP_TYPE_OR;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tif (data[0] == 0x09) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,a,|=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],a,|=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// AND\n\tcase 0x29: // and #$ff\n\tcase 0x25: // and $ff\n\tcase 0x35: // and $ff,x\n\tcase 0x2d: // and $ffff\n\tcase 0x3d: // and $ffff,x\n\tcase 0x39: // and $ffff,y\n\tcase 0x21: // and ($ff,x)\n\tcase 0x31: // and ($ff),y\n\t\top->type = R_ANAL_OP_TYPE_AND;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tif (data[0] == 0x29) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,a,&=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],a,&=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// EOR\n\tcase 0x49: // eor #$ff\n\tcase 0x45: // eor $ff\n\tcase 0x55: // eor $ff,x\n\tcase 0x4d: // eor $ffff\n\tcase 0x5d: // eor $ffff,x\n\tcase 0x59: // eor $ffff,y\n\tcase 0x41: // eor ($ff,x)\n\tcase 0x51: // eor ($ff),y\n\t\top->type = R_ANAL_OP_TYPE_XOR;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tif (data[0] == 0x49) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,a,^=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],a,^=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// ASL\n\tcase 0x0a: // asl a\n\tcase 0x06: // asl $ff\n\tcase 0x16: // asl $ff,x\n\tcase 0x0e: // asl $ffff\n\tcase 0x1e: // asl $ffff,x\n\t\top->type = R_ANAL_OP_TYPE_SHL;\n\t\tif (data[0] == 0x0a) {\n\t\t\tr_strbuf_set (&op->esil, \"1,a,<<=,$c7,C,=,a,a,=\");\n\t\t} else  {\n\t\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\n\t\t\tr_strbuf_setf (&op->esil, \"1,%s,[1],<<,%s,=[1],$c7,C,=\", addrbuf, addrbuf);\n\t\t}\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// LSR\n\tcase 0x4a: // lsr a\n\tcase 0x46: // lsr $ff\n\tcase 0x56: // lsr $ff,x\n\tcase 0x4e: // lsr $ffff\n\tcase 0x5e: // lsr $ffff,x\n\t\top->type = R_ANAL_OP_TYPE_SHR;\n\t\tif (data[0] == 0x4a) {\n\t\t\tr_strbuf_set (&op->esil, \"1,a,&,C,=,1,a,>>=\");\n\t\t} else {\n\t\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\n\t\t\tr_strbuf_setf (&op->esil, \"1,%s,[1],&,C,=,1,%s,[1],>>,%s,=[1]\", addrbuf, addrbuf, addrbuf);\n\t\t}\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// ROL\n\tcase 0x2a: // rol a\n\tcase 0x26: // rol $ff\n\tcase 0x36: // rol $ff,x\n\tcase 0x2e: // rol $ffff\n\tcase 0x3e: // rol $ffff,x\n\t\top->type = R_ANAL_OP_TYPE_ROL;\n\t\tif (data[0] == 0x2a) {\n\t\t\tr_strbuf_set (&op->esil, \"1,a,<<,C,|,a,=,$c7,C,=,a,a,=\");\n\t\t} else {\n\t\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\n\t\t\tr_strbuf_setf (&op->esil, \"1,%s,[1],<<,C,|,%s,=[1],$c7,C,=\", addrbuf, addrbuf);\n\t\t}\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// ROR\n\tcase 0x6a: // ror a\n\tcase 0x66: // ror $ff\n\tcase 0x76: // ror $ff,x\n\tcase 0x6e: // ror $ffff\n\tcase 0x7e: // ror $ffff,x\n\t\t// uses N as temporary to hold C value. but in fact,\n\t\t// it is not temporary since in all ROR ops, N will have the value of C\n\t\top->type = R_ANAL_OP_TYPE_ROR;\n\t\tif (data[0] == 0x6a) {\n\t\t\tr_strbuf_set (&op->esil, \"C,N,=,1,a,&,C,=,1,a,>>,7,N,<<,|,a,=\");\n\t\t} else {\n\t\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\n\t\t\tr_strbuf_setf (&op->esil, \"C,N,=,1,%s,[1],&,C,=,1,%s,[1],>>,7,N,<<,|,%s,=[1]\", addrbuf, addrbuf, addrbuf);\n\t\t}\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// INC\n\tcase 0xe6: // inc $ff\n\tcase 0xf6: // inc $ff,x\n\tcase 0xee: // inc $ffff\n\tcase 0xfe: // inc $ffff,x\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\n\t\tr_strbuf_setf (&op->esil, \"%s,++=[1]\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// DEC\n\tcase 0xc6: // dec $ff\n\tcase 0xd6: // dec $ff,x\n\tcase 0xce: // dec $ffff\n\tcase 0xde: // dec $ffff,x\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'x');\n\t\tr_strbuf_setf (&op->esil, \"%s,--=[1]\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// INX, INY\n\tcase 0xe8: // inx\n\tcase 0xc8: // iny\n\t\top->cycles = 2;\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t_6502_anal_esil_inc_reg (op, data[0], \"+\");\n\t\tbreak;\n\t// DEX, DEY\n\tcase 0xca: // dex\n\tcase 0x88: // dey\n\t\top->cycles = 2;\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t_6502_anal_esil_inc_reg (op, data[0], \"-\");\n\t\tbreak;\n\t// CMP\n\tcase 0xc9: // cmp #$ff\n\tcase 0xc5: // cmp $ff\n\tcase 0xd5: // cmp $ff,x\n\tcase 0xcd: // cmp $ffff\n\tcase 0xdd: // cmp $ffff,x\n\tcase 0xd9: // cmp $ffff,y\n\tcase 0xc1: // cmp ($ff,x)\n\tcase 0xd1: // cmp ($ff),y\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tif (data[0] == 0xc9) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,a,==\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],a,==\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_BNZ);\n\t\t// invert C, since C=1 when A-M >= 0\n\t\tr_strbuf_append (&op->esil, \",C,!,C,=\");\n\t\tbreak;\n\t// CPX\n\tcase 0xe0: // cpx #$ff\n\tcase 0xe4: // cpx $ff\n\tcase 0xec: // cpx $ffff\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\t_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 0);\n\t\tif (data[0] == 0xe0) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,x,==\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],x,==\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_BNZ);\n\t\t// invert C, since C=1 when A-M >= 0\n\t\tr_strbuf_append (&op->esil, \",C,!,C,=\");\n\t\tbreak;\n\t// CPY\n\tcase 0xc0: // cpy #$ff\n\tcase 0xc4: // cpy $ff\n\tcase 0xcc: // cpy $ffff\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\t_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 0);\n\t\tif (data[0] == 0xc0) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,y,==\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],y,==\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_BNZ);\n\t\t// invert C, since C=1 when A-M >= 0\n\t\tr_strbuf_append (&op->esil, \",C,!,C,=\");\n\t\tbreak;\n\t// BRANCHES\n\tcase 0x10: // bpl $ffff\n\tcase 0x30: // bmi $ffff\n\tcase 0x50: // bvc $ffff\n\tcase 0x70: // bvs $ffff\n\tcase 0x90: // bcc $ffff\n\tcase 0xb0: // bcs $ffff\n\tcase 0xd0: // bne $ffff\n\tcase 0xf0: // beq $ffff\n\t\t// FIXME: Add 1 if branch occurs to same page.\n\t\t// FIXME: Add 2 if branch occurs to different page\n\t\top->cycles = 2;\n\t\top->failcycles = 3;\n\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\tif (len > 1) {\n\t\t\tif (data[1] <= 127) {\n\t\t\t\top->jump = addr + data[1] + op->size;\n\t\t\t} else {\n\t\t\t\top->jump = addr - (256 - data[1]) + op->size;\n\t\t\t}\n\t\t} else {\n\t\t\top->jump = addr;\n\t\t}\n\t\top->fail = addr + op->size;\n\t\t// FIXME: add a type of conditional\n\t\t// op->cond = R_ANAL_COND_LE;\n\t\t_6502_anal_esil_ccall (op, data[0]);\n\t\tbreak;\n\t// JSR\n\tcase 0x20: // jsr $ffff\n\t\top->cycles = 6;\n\t\top->type = R_ANAL_OP_TYPE_CALL;\n\t\top->jump = data[1] | data[2] << 8;\n\t\top->stackop = R_ANAL_STACK_INC;\n\t\top->stackptr = 2;\n\t\t// JSR pushes the address-1 of the next operation on to the stack before transferring program\n\t\t// control to the following address\n\t\t// stack is on page one and sp is an 8-bit reg: operations must be done like: sp + 0x100\n\t\tr_strbuf_setf (&op->esil, \"1,pc,-,0xff,sp,+,=[2],0x%04x,pc,=,2,sp,-=\", op->jump);\n\t\tbreak;\n\t// JMP\n\tcase 0x4c: // jmp $ffff\n\t\top->cycles = 3;\n\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\top->jump = data[1] | data[2] << 8;\n\t\tr_strbuf_setf (&op->esil, \"0x%04x,pc,=\", op->jump);\n\t\tbreak;\n\tcase 0x6c: // jmp ($ffff)\n\t\top->cycles = 5;\n\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\t// FIXME: how to read memory?\n\t\t// op->jump = data[1] | data[2] << 8;\n\t\tr_strbuf_setf (&op->esil, \"0x%04x,[2],pc,=\", data[1] | data[2] << 8);\n\t\tbreak;\n\t// RTS\n\tcase 0x60: // rts\n\t\top->eob = true;\n\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\top->cycles = 6;\n\t\top->stackop = R_ANAL_STACK_INC;\n\t\top->stackptr = -2;\n\t\t// Operation:  PC from Stack, PC + 1 -> PC\n\t\t// stack is on page one and sp is an 8-bit reg: operations must be done like: sp + 0x100\n\t\tr_strbuf_set (&op->esil, \"0x101,sp,+,[2],pc,=,pc,++=,2,sp,+=\");\n\t\tbreak;\n\t// RTI\n\tcase 0x40: // rti\n\t\top->eob = true;\n\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\top->cycles = 6;\n\t\top->stackop = R_ANAL_STACK_INC;\n\t\top->stackptr = -3;\n\t\t// Operation: P from Stack, PC from Stack\n\t\t// stack is on page one and sp is an 8-bit reg: operations must be done like: sp + 0x100\n\t\tr_strbuf_set (&op->esil, \"0x101,sp,+,[1],flags,=,0x102,sp,+,[2],pc,=,3,sp,+=\");\n\t\tbreak;\n\t// NOP\n\tcase 0xea: // nop\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\top->cycles = 2;\n\t\tbreak;\n\t// LDA\n\tcase 0xa9: // lda #$ff\n\tcase 0xa5: // lda $ff\n\tcase 0xb5: // lda $ff,x\n\tcase 0xad: // lda $ffff\n\tcase 0xbd: // lda $ffff,x\n\tcase 0xb9: // lda $ffff,y\n\tcase 0xa1: // lda ($ff,x)\n\tcase 0xb1: // lda ($ff),y\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tif (data[0] == 0xa9) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,a,=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],a,=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// LDX\n\tcase 0xa2: // ldx #$ff\n\tcase 0xa6: // ldx $ff\n\tcase 0xb6: // ldx $ff,y\n\tcase 0xae: // ldx $ffff\n\tcase 0xbe: // ldx $ffff,y\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'y');\n\t\tif (data[0] == 0xa2) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,x,=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],x,=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// LDY\n\tcase 0xa0: // ldy #$ff\n\tcase 0xa4: // ldy $ff\n\tcase 0xb4: // ldy $ff,x\n\tcase 0xac: // ldy $ffff\n\tcase 0xbc: // ldy $ffff,x\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\t_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 'x');\n\t\tif (data[0] == 0xa0) // immediate mode\n\t\t\tr_strbuf_setf (&op->esil, \"%s,y,=\", addrbuf);\n\t\telse\tr_strbuf_setf (&op->esil, \"%s,[1],y,=\", addrbuf);\n\t\t_6502_anal_update_flags (op, _6502_FLAGS_NZ);\n\t\tbreak;\n\t// STA\n\tcase 0x85: // sta $ff\n\tcase 0x95: // sta $ff,x\n\tcase 0x8d: // sta $ffff\n\tcase 0x9d: // sta $ffff,x\n\tcase 0x99: // sta $ffff,y\n\tcase 0x81: // sta ($ff,x)\n\tcase 0x91: // sta ($ff),y\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t_6502_anal_esil_get_addr_pattern1 (op, data, addrbuf, buffsize);\n\t\tr_strbuf_setf (&op->esil, \"a,%s,=[1]\", addrbuf);\n\t\tbreak;\n\t// STX\n\tcase 0x86: // stx $ff\n\tcase 0x96: // stx $ff,y\n\tcase 0x8e: // stx $ffff\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t_6502_anal_esil_get_addr_pattern2 (op, data, addrbuf, buffsize, 'y');\n\t\tr_strbuf_setf (&op->esil, \"x,%s,=[1]\", addrbuf);\n\t\tbreak;\n\t// STY\n\tcase 0x84: // sty $ff\n\tcase 0x94: // sty $ff,x\n\tcase 0x8c: // sty $ffff\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\t_6502_anal_esil_get_addr_pattern3 (op, data, addrbuf, buffsize, 'x');\n\t\tr_strbuf_setf (&op->esil, \"y,%s,=[1]\", addrbuf);\n\t\tbreak;\n\t// PHP/PHA\n\tcase 0x08: // php\n\tcase 0x48: // pha\n\t\top->type = R_ANAL_OP_TYPE_PUSH;\n\t\top->cycles = 3;\n\t\top->stackop = R_ANAL_STACK_INC;\n\t\top->stackptr = 1;\n\t\t_6502_anal_esil_push (op, data[0]);\n\t\tbreak;\n\t// PLP,PLA\n\tcase 0x28: // plp\n\tcase 0x68: // plp\n\t\top->type = R_ANAL_OP_TYPE_POP;\n\t\top->cycles = 4;\n\t\top->stackop = R_ANAL_STACK_INC;\n\t\top->stackptr = -1;\n\t\t_6502_anal_esil_pop (op, data[0]);\n\t\tbreak;\n\t// TAX,TYA,...\n\tcase 0xaa: // tax\n\tcase 0x8a: // txa\n\tcase 0xa8: // tay\n\tcase 0x98: // tya\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->cycles = 2;\n\t\t_6502_anal_esil_mov (op, data[0]);\n\t\tbreak;\n\tcase 0x9a: // txs\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->cycles = 2;\n\t\top->stackop = R_ANAL_STACK_SET;\n\t\t// FIXME: should I get register X a place it here?\n\t\t// op->stackptr = get_register_x();\n\t\t_6502_anal_esil_mov (op, data[0]);\n\t\tbreak;\n\tcase 0xba: // tsx\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->cycles = 2;\n\t\top->stackop = R_ANAL_STACK_GET;\n\t\t_6502_anal_esil_mov (op, data[0]);\n\t\tbreak;\n\t}\n\treturn op->size;\n}\n\nstatic int set_reg_profile(RAnal *anal) {\n\tchar *p =\n\t\t\"=PC\tpc\\n\"\n\t\t\"=SP\tsp\\n\"\n\t\t\"gpr\ta\t.8\t0\t0\\n\"\n\t\t\"gpr\tx\t.8\t1\t0\\n\"\n\t\t\"gpr\ty\t.8\t2\t0\\n\"\n\n\t\t\"gpr\tflags\t.8\t3\t0\\n\"\n\t\t\"gpr\tC\t.1\t.24\t0\\n\"\n\t\t\"gpr\tZ\t.1\t.25\t0\\n\"\n\t\t\"gpr\tI\t.1\t.26\t0\\n\"\n\t\t\"gpr\tD\t.1\t.27\t0\\n\"\n\t\t// bit 4 (.28) is NOT a real flag.\n\t\t// \"gpr\tB\t.1\t.28\t0\\n\"\n\t\t// bit 5 (.29) is not used\n\t\t\"gpr\tV\t.1\t.30\t0\\n\"\n\t\t\"gpr\tN\t.1\t.31\t0\\n\"\n\t\t\"gpr\tsp\t.8\t4\t0\\n\"\n\t\t\"gpr\tpc\t.16\t5\t0\\n\";\n\treturn r_reg_set_profile_string (anal->reg, p);\n}\n\nstatic int esil_6502_init (RAnalEsil *esil) {\n\tif (esil->anal && esil->anal->reg) {\t\t//initial values\n\t\tr_reg_set_value (esil->anal->reg, r_reg_get (esil->anal->reg, \"pc\", -1), 0x0000);\n\t\tr_reg_set_value (esil->anal->reg, r_reg_get (esil->anal->reg, \"sp\", -1), 0xff);\n\t\tr_reg_set_value (esil->anal->reg, r_reg_get (esil->anal->reg, \"a\", -1), 0x00);\n\t\tr_reg_set_value (esil->anal->reg, r_reg_get (esil->anal->reg, \"x\", -1), 0x00);\n\t\tr_reg_set_value (esil->anal->reg, r_reg_get (esil->anal->reg, \"y\", -1), 0x00);\n\t\tr_reg_set_value (esil->anal->reg, r_reg_get (esil->anal->reg, \"flags\", -1), 0x00);\n\t}\n\treturn true;\n}\n\nstatic int esil_6502_fini (RAnalEsil *esil) {\n\treturn true;\n}\n\nRAnalPlugin r_anal_plugin_6502 = {\n\t.name = \"6502\",\n\t.desc = \"6502/NES analysis plugin\",\n\t.license = \"LGPL3\",\n\t.arch = \"6502\",\n\t.bits = 8,\n\t.op = &_6502_op,\n\t.set_reg_profile = &set_reg_profile,\n\t.esil = true,\n\t.esil_init = esil_6502_init,\n\t.esil_fini = esil_6502_fini,\n};\n\n#ifndef CORELIB\nRLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_ANAL,\n\t.data = &r_anal_plugin_6502,\n\t.version = R2_VERSION\n};\n#endif\n"], "filenames": ["libr/anal/p/anal_6502.c"], "buggy_code_start_loc": [685], "buggy_code_end_loc": [688], "fixing_code_start_loc": [685], "fixing_code_end_loc": [694], "type": "CWE-125", "message": "There is a heap out of bounds read in radare2 2.6.0 in _6502_op() in libr/anal/p/anal_6502.c via a crafted iNES ROM binary file.", "other": {"cve": {"id": "CVE-2018-12322", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-13T16:29:01.627", "lastModified": "2018-08-02T15:05:51.970", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "There is a heap out of bounds read in radare2 2.6.0 in _6502_op() in libr/anal/p/anal_6502.c via a crafted iNES ROM binary file."}, {"lang": "es", "value": "Hay una lectura fuera de l\u00edmites de la memoria din\u00e1mica (heap) en radare2 2.6.0 en _6502_op() en libr/anal/p/anal_6502.c mediante un archivo binario iNES ROM manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:2.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "ECF03BDC-4698-4552-A58C-67FD78902BED"}]}]}], "references": [{"url": "https://github.com/radare/radare2/commit/bbb4af56003c1afdad67af0c4339267ca38b1017", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/radare/radare2/issues/10294", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/bbb4af56003c1afdad67af0c4339267ca38b1017"}}