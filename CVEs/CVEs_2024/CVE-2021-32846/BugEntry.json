{"buggy_code": ["/*-\n * Copyright (c) 2016 Docker, Inc.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer\n *    in this position and unchanged.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n/*\n * virtio vsock emulation based on v4 specification\n *    http://markmail.org/message/porhou5zv3wqjz6h\n * Tested against the Linux implementation at\n *    git@github.com:stefanha/linux.git#vsock @ 563d2a770dfa\n * Backported to v4.1.19:\n *    git cherry-pick -x 11aa9c2 f6a835b 4ef7ea9 8566b86 \\\n *                       ea3803c a9f9df1 1bb5b77 0c734eb \\\n *                       139bbcd 563d2a7\n */\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/uio.h>\n#include <sys/un.h>\n#include <sys/time.h>\n#include <sys/queue.h>\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <strings.h>\n#include <unistd.h>\n#include <errno.h>\n\n#include <xhyve/pci_emul.h>\n#include <xhyve/virtio.h>\n#include <xhyve/xhyve.h>\n\n#define VTSOCK_RINGSZ 256\n\n#define VTSOCK_QUEUE_RX\t\t0\n#define VTSOCK_QUEUE_TX\t\t1\n#define VTSOCK_QUEUE_EVT\t2\n#define VTSOCK_QUEUES\t\t3\n\n#define VTSOCK_MAXSEGS\t\t32\n\n#define VTSOCK_MAXSOCKS\t1024\n#define VTSOCK_MAXFWDS\t4\n\n/* Number of seconds to wait after sending an OP_SHUTDOWN flags == ALL before\n * we RST the connection ourselves.\n */\n#define SHUTDOWN_RST_DELAY\t30\n\n/*\n * Host capabilities\n */\n#define VTSOCK_S_HOSTCAPS 0\n#if 0\n\t(VIRTIO_RING_F_INDIRECT_DESC) /* indirect descriptors */\n#endif\n\n/*\n * Config space \"registers\"\n */\nstruct vtsock_config {\n\tuint64_t guest_cid;\n} __packed;\n\n/*\n * Fixed-size block header\n */\n\nstruct virtio_sock_hdr {\n\tuint64_t src_cid;\n\tuint64_t dst_cid;\n\tuint32_t src_port;\n\tuint32_t dst_port;\n\tuint32_t len;\n#define VIRTIO_VSOCK_TYPE_STREAM 1\n\tuint16_t type;\n#define VIRTIO_VSOCK_OP_INVALID 0\n\t/* Connect operations */\n#define VIRTIO_VSOCK_OP_REQUEST 1\n#define VIRTIO_VSOCK_OP_RESPONSE 2\n#define VIRTIO_VSOCK_OP_RST 3\n#define VIRTIO_VSOCK_OP_SHUTDOWN 4\n\t/* To send payload */\n#define VIRTIO_VSOCK_OP_RW 5\n\t/* Tell the peer our credit info */\n#define VIRTIO_VSOCK_OP_CREDIT_UPDATE 6\n\t/* Request the peer to send the credit info to us */\n#define VIRTIO_VSOCK_OP_CREDIT_REQUEST 7\n\tuint16_t op;\n\tuint32_t flags;\n#define VIRTIO_VSOCK_FLAG_SHUTDOWN_RX (1U<<0) /* Peer will not receive any more data */\n#define VIRTIO_VSOCK_FLAG_SHUTDOWN_TX (1U<<1) /* Peer will not transmit any more data */\n#define VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL (VIRTIO_VSOCK_FLAG_SHUTDOWN_RX|VIRTIO_VSOCK_FLAG_SHUTDOWN_TX)\n\tuint32_t buf_alloc;\n\tuint32_t fwd_cnt;\n} __packed;\n\n/*\n * Debug printf\n */\nstatic int pci_vtsock_debug = 0;\n#define DPRINTF(params) do { if (pci_vtsock_debug) { printf params; fflush(stdout); } } while(0)\n/* Protocol logging */\n#define PPRINTF(params) do { if (0) { printf params;  fflush(stdout); } } while(0)\n\n/* XXX need to use rx and tx more consistently */\n\nstruct vsock_addr {\n\tuint64_t cid;\n\tuint32_t port;\n};\n#define PRIcid \"%08\"PRIx64\n#define PRIport \"%08\"PRIx32\n\n#define SCNcid \"%08\"SCNx64\n#define SCNport \"%08\"SCNx32\n#define SCNaddr SCNcid \".\" SCNport\n\n#ifdef PRI_ADDR_PREFIX\n#define PRIaddr PRI_ADDR_PREFIX PRIcid \".\" PRIport\n#else\n#define PRIaddr PRIcid \".\" PRIport\n#endif\n\n#ifndef CONNECT_SOCKET_NAME\n#define CONNECT_SOCKET_NAME \"connect\"\n#endif\n\n#define FMTADDR(a) a.cid, a.port\n\n#define WRITE_BUF_LENGTH (128*1024)\n\nstruct pci_vtsock_sock {\n\tpthread_mutex_t mtx;\n\n\t/* Either on softc->free_list or softc->inuse_list */\n\tLIST_ENTRY(pci_vtsock_sock) list;\n\n\t/* For tx and rx thread local use respectively */\n\tLIST_ENTRY(pci_vtsock_sock) tx_queue;\n\tLIST_ENTRY(pci_vtsock_sock) rx_queue;\n\n\t/*\n\t * To allocate a sock:\n\t *\n\t *   Take list_rwlock for writing\n\t *\n\t *     Grab a sock from head of free_list\n\t *\n\t *     If a FREE sock is found take its lock before removing it\n\t *     from the list and setting its state to CONNECTING.\n\t *\n\t *     Add the sock to inuse_list.\n\t *\n\t *   Drop list_rwlock\n\t *\n\t * To free a sock:\n\t *\n\t *   Set state to CLOSING_TX and kick the tx thread[*].\n\t *\n\t * Then the following will happen:\n\t *\n\t * ,-TX thread:\n\t * |\n\t * | The TX loop will take list_rwlock for reading (as part of\n\t * | its normal start of loop processing) and:\n\t * |\n\t * |   Take the socket's lock and discover state == CLOSING_TX\n\t * |\n\t * |   Set state == CLOSING_RX\n\t * |\n\t * |   Note that an RX kick is needed\n\t * |\n         * | Release list_rwlock\n\t * |\n\t * `-Kick the rx thread if required\n\t *\n\t * ,-RX thread:\n\t * |\n\t * | The RX loop will take list_rwlock for reading (as part of\n\t * | its normal start of loop processing) and:\n\t * |\n\t * |   Take the socket's lock and discover state == CLOSING_RX\n\t * |\n\t * |   Put the socket on a local \"to be closed\" queue\n\t * |\n         * | Release list_rwlock\n\t * |\n\t * | If there a sockets to be closed, take list_rwlock for\n\t * | writing, and for each socket:\n\t * |\n\t * |   close the fd, set state == FREE\n\t * |\n\t * |   remove socket from inuse_list, add to free_list\n\t * |\n\t * |   drop the socket's lock\n\t * |\n\t * `-Drop list_rwlock\n\t *\n\t * [*] Callers in the TX loop (only) may when closing a socket\n\t * choose to skip the initial CLOSING_TX state (which exists\n\t * only to ensure that the fd is not current in the tx select,\n\t * which it cannot be if the TX thread is doing the close) and\n\t * go straight to CLOSING_RX kicking the rx thread instead. If\n\t * the close is initiated by the RX thread (or anywhere else)\n\t * then it must go through the full\n\t * CLOSING_TX->CLOSING_RX->FREE path.\n\t */\n\tenum {\n\t\tSOCK_FREE, /* Initial state */\n\t\tSOCK_CONNECTING,\n\t\tSOCK_CONNECTED,\n\t\tSOCK_CLOSING_TX,\n\t\tSOCK_CLOSING_RX,\n\t} state;\n\t/* fd is:\n\t *   >= 0\tWhen state == CONNECTED,\n\t *     -1\tOtherwise\n\t */\n\tint fd;\n\tuint16_t port_generation;\n\t/* valid when SOCK_CONNECTED only */\n\tuint32_t local_shutdown, peer_shutdown;\n\ttime_t rst_deadline; /* When local_shutdown==ALL, expect RST before */\n\n\tstruct vsock_addr local_addr;\n\tstruct vsock_addr peer_addr;\n\n\tuint32_t buf_alloc;\n\tuint32_t fwd_cnt;\n\n\tbool credit_update_required;\n\tuint32_t rx_cnt; /* Amount we have sent to the peer */\n\tuint32_t peer_buf_alloc; /* From the peer */\n\tuint32_t peer_fwd_cnt; /* From the peer */\n\n\t/* Write buffer. We do not update fwd_cnt until we drain the _whole_ buffer */\n\tuint8_t write_buf[WRITE_BUF_LENGTH];\n\tunsigned int write_buf_head, write_buf_tail;\n};\n\nstruct pci_vtsock_forward {\n\tint listen_fd;\n\tuint32_t port;\n};\n\n/*\n * Per-device softc\n */\n/*\n * Lock order (outer most first): XXX more thought needed.\n *\n *   vssc_mtx is taken by the core and is often held during callbacks\n *   (e.g. it is held during a vq_notify or pci cfg access). It\n *   protects virtio resources.\n *\n *   list_rwlock, protects free and inuse lists (rdlock for traversal)\n *\n *   sock->mtx protects the contents of the sock struct, including the\n *   state.\n *\n *   reply_mtx protects reply_{ring,prod,cons}\n */\nLIST_HEAD(sock_list_head, pci_vtsock_sock);\nstruct pci_vtsock_softc {\n\tstruct virtio_softc vssc_vs;\n\tpthread_mutex_t vssc_mtx;\n\tchar *path;\n\tstruct vqueue_info vssc_vqs[VTSOCK_QUEUES];\n\tstruct vtsock_config vssc_cfg;\n\n\t/* list_mtx protects free_list and inuse_list heads */\n\tpthread_rwlock_t list_rwlock;\n\tstruct sock_list_head free_list, inuse_list;\n\tstruct pci_vtsock_sock socks[VTSOCK_MAXSOCKS];\n\n\tstruct pci_vtsock_forward fwds[VTSOCK_MAXFWDS];\n\tint nr_fwds;\n\n\tpthread_t tx_thread;\n\tint tx_kick_fd, tx_wake_fd; /* Write to kick, select on wake */\n\tbool rx_kick_pending;\n\tint connect_fd; /* */\n\n\tpthread_t rx_thread;\n\tint rx_kick_fd, rx_wake_fd; /* Write to kick, select on wake */\n\n\tpthread_mutex_t reply_mtx;\n#define VTSOCK_REPLYRINGSZ (2*VTSOCK_RINGSZ)\n\tstruct virtio_sock_hdr reply_ring[VTSOCK_REPLYRINGSZ];\n\tint reply_prod, reply_cons;\n\t/*\n\t * If reply_prod == reply_cons then the ring is empty,\n\t * otherwise there is data in it.\n\t *\n\t * If the ring is not empty then there MUST always be a 1 slot\n\t * buffer between the producer and the consumer pointers\n\t * (i.e. the ring size is effectively one less than expected).\n\t *\n\t * If this invariant is violated and we consume the final free\n\t * slot then reply_prod would have caught up to reply_cons and\n\t * the ring would be considered empty rather than\n\t * full. Therefore we consider the ring full when:\n\t *\n\t *    (reply_prod + 1) % VTSOCK_REPLYRINGSZ == reply_cons.\n\t */\n#define REPLY_RING_EMPTY(sc) (sc->reply_cons == sc->reply_prod)\n//#define REPLY_RING_FULL(sc) ((sc->reply_prod + 1) % VTSOCK_REPLYRINGSZ == sc->reply_cons)\n};\n\n\n/* Protocol stuff */\n\n/* Reserved CIDs */\n#define VMADDR_CID_ANY (uint64_t) -1U\n//#define VMADDR_CID_HYPERVISOR 0\n//#define VMADDR_CID_RESERVED 1\n#define VMADDR_CID_HOST 2\n\n#define VMADDR_CID_MAX UINT32_MAX /* Athough CID's are 64-bit in the protocol, we only support 32-bits */\n\nstatic void pci_vtsock_reset(void *);\nstatic void pci_vtsock_notify_tx(void *, struct vqueue_info *);\nstatic void pci_vtsock_notify_rx(void *, struct vqueue_info *);\nstatic int pci_vtsock_cfgread(void *, int, int, uint32_t *);\nstatic int pci_vtsock_cfgwrite(void *, int, int, uint32_t);\nstatic void *pci_vtsock_rx_thread(void *vssc);\n\nstatic bool sock_is_buffering(struct pci_vtsock_sock *sock);\n\nstatic struct virtio_consts vtsock_vi_consts = {\n\t\"vtsock\", /* our name */\n\tVTSOCK_QUEUES,\n\tsizeof(struct vtsock_config), /* config reg size */\n\tpci_vtsock_reset, /* reset */\n\tNULL, /* no device-wide qnotify */\n\tpci_vtsock_cfgread, /* read PCI config */\n\tpci_vtsock_cfgwrite, /* write PCI config */\n\tNULL, /* apply negotiated features */\n\tVTSOCK_S_HOSTCAPS, /* our capabilities */\n};\n\nstatic void pci_vtsock_reset(void *vsc)\n{\n\tstruct pci_vtsock_softc *sc = vsc;\n\n\tDPRINTF((\"vtsock: device reset requested !\\n\"));\n\tvi_reset_dev(&sc->vssc_vs);\n\t/* XXX TODO: close/reset all socks */\n}\n\nstatic const char * const opnames[] = {\n\t[VIRTIO_VSOCK_OP_INVALID] = \"INVALID\",\n\t[VIRTIO_VSOCK_OP_REQUEST] = \"REQUEST\",\n\t[VIRTIO_VSOCK_OP_RESPONSE] = \"RESPONSE\",\n\t[VIRTIO_VSOCK_OP_RST] = \"RST\",\n\t[VIRTIO_VSOCK_OP_SHUTDOWN] = \"SHUTDOWN\",\n\t[VIRTIO_VSOCK_OP_RW] = \"RW\",\n\t[VIRTIO_VSOCK_OP_CREDIT_UPDATE] = \"CREDIT_UPDATE\",\n\t[VIRTIO_VSOCK_OP_CREDIT_REQUEST] = \"CREDIT_REQUEST\"\n};\n\nstatic int max_fd(int a, int b)\n{\n\tif (a > b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\n/*\n * Returns >= 0 number of fds on success or -1 to indicate caller\n * should retry. On any failure which cannot be retried logs and exits.\n */\nstatic int xselect(const char *ctx,\n\t\t   int nfds, fd_set *readfds, fd_set *writefds,\n\t\t   fd_set *errorfds, struct timeval *timeout)\n{\n\tint rc = select(nfds, readfds, writefds, errorfds, timeout);\n\tif (rc >= 0) return rc;\n\n\t/*\n\t * http://pubs.opengroup.org/onlinepubs/009695399/functions/select.html\n\t * lists EINTR, EBADF and EINVAL. EINTR is recoverable and should be\n\t * retried.\n\t */\n\tif (errno == EINTR) return -1;\n\t/*\n\t * OSX select(2) man page lists EAGAIN in addition to the above.\n\t * EAGAIN should be retried.\n\t*/\n\tif (errno == EAGAIN) return -1;\n\n\tfprintf(stderr, \"%s: select() failed %d: %s\\n\",\n\t\tctx, errno, strerror(errno));\n\tabort();\n}\n\nstatic size_t iovec_clip(struct iovec **iov, int *iov_len, size_t bytes)\n{\n\tsize_t ret = 0;\n\tint i;\n\tfor (i = 0; i < *iov_len && ret < bytes; i++) {\n\t\tif ((bytes-ret) < (*iov)[i].iov_len)\n\t\t\t(*iov)[i].iov_len = bytes - ret;\n\t\tret += (*iov)[i].iov_len;\n\t}\n\t*iov_len = i;\n\treturn ret;\n}\n\n/* Pulls @bytes from @iov into @buf. @buf can be NULL, in which case this just discards @bytes */\nstatic size_t iovec_pull(struct iovec **iov, int *iov_len, void *buf, size_t bytes)\n{\n\tsize_t res = 0;\n\n\t//DPRINTF((\"iovec_pull %zd bytes into %p. iov=%p, iov_len=%d\\n\",\n\t//\t bytes, (void *)buf, (void *)*iov, *iov_len));\n\n\twhile (res < bytes && *iov_len) {\n\t\tsize_t c = (bytes - res) < (*iov)[0].iov_len ? (bytes - res) : (*iov)[0].iov_len;\n\n\t\t//DPRINTF((\"Copy %zd/%zd bytes from base=%p to buf=%p\\n\",\n\t\t//\t c, (*iov)[0].iov_len, (void*)(*iov)[0].iov_base, (void*)buf));\n\n\t\tif (buf) memcpy(buf, (*iov)[0].iov_base, c);\n\n\t\t(*iov)[0].iov_len -= c;\n\t\t(*iov)[0].iov_base = (char *)(*iov)[0].iov_base + c;\n\n\t\t//DPRINTF((\"iov %p is now %zd bytes at %p\\n\", (void *)*iov,\n\t\t//\t (*iov)[0].iov_len, (void *)(*iov)[0].iov_base));\n\n\t\tif ((*iov)[0].iov_len == 0) {\n\t\t\t(*iov)++;\n\t\t\t(*iov_len)--;\n\t\t\t//DPRINTF((\"iov elem consumed, now iov=%p, iov_len=%d\\n\", (void *)*iov, *iov_len));\n\t\t}\n\n\t\tif (buf) buf = (char *)buf + c;\n\t\t//DPRINTF((\"buf now %p\\n\", (void *)buf));\n\n\t\tres += c;\n\t}\n\t//DPRINTF((\"iovec_pull pulled %zd/%zd bytes\\n\", res, bytes));\n\n\treturn res;\n}\n\nstatic size_t iovec_push(struct iovec **iov, int *iov_len, void *buf, size_t bytes)\n{\n\tsize_t res = 0;\n\n\t//DPRINTF((\"iovec_push %zd bytes from %p. iov=%p, iov_len=%d\\n\",\n\t//\t bytes, (void *)buf, (void *)*iov, *iov_len));\n\n\twhile (res < bytes && *iov_len) {\n\t\tsize_t c = (bytes - res) < (*iov)[0].iov_len ? (bytes - res) : (*iov)[0].iov_len;\n\n\t\t//DPRINTF((\"Copy %zd/%zd bytes from buf=%p to base=%p\\n\",\n\t\t//\t c, (*iov)[0].iov_len, (void *)buf, (void *)(*iov)[0].iov_base));\n\n\t\tmemcpy((*iov)[0].iov_base, buf, c);\n\n\t\t(*iov)[0].iov_len -= c;\n\t\t(*iov)[0].iov_base = (char *)(*iov)[0].iov_base + c;\n\n\t\t//DPRINTF((\"iov %p is now %zd bytes at %p\\n\", (void *)*iov,\n\t\t//\t (*iov)[0].iov_len, (void *)(*iov)[0].iov_base));\n\n\t\tif ((*iov)[0].iov_len == 0) {\n\t\t\t(*iov)++;\n\t\t\t(*iov_len)--;\n\t\t\t//DPRINTF((\"iov elem consumed, now iov=%p, iov_len=%d\\n\", (void *)*iov, *iov_len));\n\t\t}\n\n\t\tbuf = (char *)buf + c;\n\t\t//DPRINTF((\"buf now %p\\n\", (void *)buf));\n\n\t\tres += c;\n\t}\n\n\treturn res;\n}\n\nstatic void dprint_iovec(struct iovec *iov, int iovec_len, const char *ctx)\n{\n\tint i;\n\tif (!pci_vtsock_debug) return;\n\tDPRINTF((\"%s: IOV:%p ELEMS:%d\\n\", ctx, (void *)iov, iovec_len));\n\tfor (i = 0; i < iovec_len; i++)\n\t\tDPRINTF((\"%s:  %d = %zu @ %p\\n\",\n\t\t\t ctx, i, iov[i].iov_len, (void *)iov[i].iov_base));\n}\n\nstatic void dprint_chain(struct iovec *iov, int iovec_len, const char *ctx)\n{\n\tint i;\n\tif (!pci_vtsock_debug) return;\n\tDPRINTF((\"%s: CHAIN:%p ELEMS:%d\\n\", ctx, (void *)iov, iovec_len));\n\tfor (i = 0; i < iovec_len; i++)\n\t\tDPRINTF((\"%s:  %d = %zu @ %p\\n\",\n\t\t\t ctx, i, iov[i].iov_len, (void *)iov[i].iov_base));\n}\n\n\nstatic void dprint_header(struct virtio_sock_hdr *hdr, bool tx, const char *ctx)\n{\n\tif (!pci_vtsock_debug) return;\n\tassert(hdr->op < nitems(opnames));\n\n\tDPRINTF((\"%s: %sSRC:\"PRIaddr\" DST:\"PRIaddr\"\\n\",\n\t\t ctx, tx ? \"<=\" : \"=>\",\n\t\t hdr->src_cid, hdr->src_port, hdr->dst_cid, hdr->dst_port));\n\tDPRINTF((\"%s:   LEN:%08\"PRIx32\" TYPE:%04\"PRIx16\" OP:%\"PRId16\"=%s\\n\",\n\t\t ctx, hdr->len, hdr->type, hdr->op,\n\t\t opnames[hdr->op] ? opnames[hdr->op] : \"<unknown>\"));\n\tDPRINTF((\"%s:  FLAGS:%08\"PRIx32\" BUF_ALLOC:%08\"PRIx32\" FWD_CNT:%08\"PRIx32\"\\n\",\n\t\t ctx, hdr->flags, hdr->buf_alloc, hdr->fwd_cnt));\n}\n\nstatic void put_sock(struct pci_vtsock_sock *s)\n{\n\tint err = pthread_mutex_unlock(&s->mtx);\n\tassert(err == 0);\n}\n\nstatic struct pci_vtsock_sock *get_sock(struct pci_vtsock_sock *s)\n{\n\tint err = pthread_mutex_lock(&s->mtx);\n\tassert(err == 0);\n\treturn s;\n}\n\n/* Returns a locked sock */\nstatic struct pci_vtsock_sock *lookup_sock(struct pci_vtsock_softc *sc,\n\t\t\t\t\t   uint16_t type,\n\t\t\t\t\t   struct vsock_addr local_addr,\n\t\t\t\t\t   struct vsock_addr peer_addr)\n{\n\tstruct pci_vtsock_sock *s;\n\n\tassert(type == VIRTIO_VSOCK_TYPE_STREAM);\n\n\tpthread_rwlock_rdlock(&sc->list_rwlock);\n\tLIST_FOREACH(s, &sc->inuse_list, list) {\n\t\tget_sock(s);\n\n\t\tif ((s->state == SOCK_CONNECTED || s->state == SOCK_CONNECTING) &&\n\t\t    s->peer_addr.cid == peer_addr.cid &&\n\t\t    s->peer_addr.port == peer_addr.port &&\n\t\t    s->local_addr.cid == local_addr.cid &&\n\t\t    s->local_addr.port == local_addr.port) {\n\t\t\tgoto found;\n\t\t}\n\n\t\tput_sock(s);\n\t}\n\n\ts = NULL;\n\nfound:\n\tpthread_rwlock_unlock(&sc->list_rwlock);\n\treturn s;\n}\n\n\n/* Returns NULL on failure or a locked socket on success */\nstatic struct pci_vtsock_sock *alloc_sock(struct pci_vtsock_softc *sc)\n{\n\tstruct pci_vtsock_sock *s;\n\n\tpthread_rwlock_wrlock(&sc->list_rwlock);\n\ts = LIST_FIRST(&sc->free_list);\n\tif (s) {\n\t\tget_sock(s);\n\t\tLIST_REMOVE(s, list);\n\t\tLIST_INSERT_HEAD(&sc->inuse_list, s, list);\n\t\ts->state = SOCK_CONNECTING;\n\t}\n\tpthread_rwlock_unlock(&sc->list_rwlock);\n\n\tif (!s) return NULL;\n\n\ts->buf_alloc = WRITE_BUF_LENGTH;\n\ts->fwd_cnt = 0;\n\n\ts->peer_buf_alloc = 0;\n\ts->peer_fwd_cnt = 0;\n\ts->rx_cnt = 0;\n\ts->credit_update_required = false;\n\n\ts->local_shutdown = 0;\n\ts->peer_shutdown = 0;\n\n\ts->write_buf_head = s->write_buf_tail = 0;\n\n\treturn s;\n}\n\n/* Caller must hold sc->list_rwlock AND s->lock. This function will\n * free s and release s->lock but not sc->list_rwlock\n */\nstatic void free_sock(struct pci_vtsock_softc *sc, struct pci_vtsock_sock *s)\n{\n\tLIST_REMOVE(s, list);\n\ts->state = SOCK_FREE;\n\n\tLIST_INSERT_HEAD(&sc->free_list, s, list);\n\n\tput_sock(s);\n}\n\nstatic int set_socket_options(struct pci_vtsock_sock *s)\n{\n\tint rc, buf_alloc = (int)s->buf_alloc;\n\tsocklen_t opt_len;\n\n\trc = setsockopt(s->fd, SOL_SOCKET, SO_SNDBUF,\n\t\t\t&buf_alloc, sizeof(buf_alloc));\n\tif ( rc < 0 ) {\n\t\tDPRINTF((\"Failed to set SO_SNDBUF on fd %d: %s\\n\",\n\t\t\t s->fd, strerror(errno)));\n\t\treturn rc;\n\t}\n\n\trc = setsockopt(s->fd, SOL_SOCKET, SO_RCVBUF,\n\t\t\t&buf_alloc, sizeof(buf_alloc));\n\tif ( rc < 0 ) {\n\t\tDPRINTF((\"Failed to set SO_RCVBUF on fd %d: %s\\n\",\n\t\t\t s->fd, strerror(errno)));\n\t\treturn rc;\n\t}\n\n\topt_len = sizeof(buf_alloc);\n\trc = getsockopt(s->fd, SOL_SOCKET, SO_SNDBUF,\n\t\t\t&buf_alloc, &opt_len);\n\tif ( rc < 0 ) {\n\t\tDPRINTF((\"Failed to get SO_SNDBUF on fd %d: %s\\n\",\n\t\t\t s->fd, strerror(errno)));\n\t\treturn rc;\n\t}\n\t/* If we didn't get what we asked for then expose this to the other end */\n\tif (buf_alloc < (int)s->buf_alloc) {\n\t\tPPRINTF((\"fd %d SO_SNDBUF is 0x%x not 0x%x as requested, clamping\\n\",\n\t\t\t s->fd, buf_alloc, s->buf_alloc));\n\t\ts->buf_alloc = (uint32_t)buf_alloc;\n\t}\n\n\treturn 0;\n}\n\n\n/* On success the socket returned will be locked, the caller is\n * responsible for calling put_sock() on it.\n */\nstatic struct pci_vtsock_sock *connect_sock(struct pci_vtsock_softc *sc,\n\t\t\t\t\t    struct vsock_addr local_addr,\n\t\t\t\t\t    struct vsock_addr peer_addr,\n\t\t\t\t\t    uint32_t peer_buf_alloc,\n\t\t\t\t\t    uint32_t peer_fwd_cnt)\n{\n\tstruct pci_vtsock_sock *s;\n\tstruct sockaddr_un un;\n\tint rc, fd = -1;\n\n\ts = alloc_sock(sc);\n\tif (s == NULL) {\n\t\tDPRINTF((\"TX: No available socks\\n\"));\n\t\tgoto err;\n\t}\n\n\tDPRINTF((\"TX: Assigned sock %ld at %p\\n\",\n\t\t s - &sc->socks[0], (void *)s));\n\n\tbzero(&un, sizeof(un));\n\n\tun.sun_len = 0; /* Unused? */\n\tun.sun_family = AF_UNIX;\n\trc = snprintf(un.sun_path, sizeof(un.sun_path),\n\t\t     \"%s/\"PRIaddr, sc->path, FMTADDR(local_addr));\n\tif (rc < 0) {\n\t\tDPRINTF((\"TX: Failed to format socket path\\n\"));\n\t\tgoto err;\n\t}\n\n\tfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\tDPRINTF((\"TX: socket failed for %s: %s\\n\",\n\t\t\t un.sun_path, strerror(errno)));\n\t\tgoto err;\n\t}\n\n\tif (fd >= FD_SETSIZE) {\n\t\tDPRINTF((\"TX: socket fd %d > FD_SETSIZE %d\\n\", fd, FD_SETSIZE));\n\t\tgoto err;\n\t}\n\n\trc = connect(fd, (struct sockaddr *)&un, sizeof(un));\n\tif (rc < 0) {\n\t\tDPRINTF((\"TX: connect failed for %s: %s\\n\",\n\t\t\t un.sun_path, strerror(errno)));\n\t\tgoto err;\n\t}\n\n\trc = fcntl(fd, F_SETFL, O_NONBLOCK);\n\tif (rc < 0) {\n\t\tDPRINTF((\"TX: O_NONBLOCK failed for %s: %s\\n\",\n\t\t\t un.sun_path, strerror(errno)));\n\t\tgoto err;\n\t}\n\n\tDPRINTF((\"TX: Socket path %s opened on fd %d\\n\", un.sun_path, fd));\n\n\ts->fd = fd;\n\ts->peer_addr = peer_addr;\n\ts->local_addr = local_addr;\n\n\ts->peer_buf_alloc = peer_buf_alloc;\n\ts->peer_fwd_cnt = peer_fwd_cnt;\n\n\trc = set_socket_options(s);\n\tif (rc < 0) goto err;\n\n\tPPRINTF((\"TX: SOCK connected (%d) \"PRIaddr\" <=> \"PRIaddr\"\\n\",\n\t\t s->fd, FMTADDR(s->local_addr), FMTADDR(s->peer_addr)));\n\ts->state = SOCK_CONNECTED;\n\n\treturn s;\n\nerr:\n\tif (fd >= 0) close(fd);\n\tif (s) {\n\t\tpthread_rwlock_wrlock(&sc->list_rwlock);\n\t\tfree_sock(sc, s);\n\t\tpthread_rwlock_unlock(&sc->list_rwlock);\n\t}\n\treturn NULL;\n}\n\nstatic void kick_rx(struct pci_vtsock_softc *sc, const char *why)\n{\n\tchar dummy;\n\tssize_t nr;\n\tsc->rx_kick_pending = false;\n\tnr = write(sc->rx_kick_fd, &dummy, 1);\n\tassert(nr == 1);\n\tDPRINTF((\"RX: kicked rx thread: %s\\n\", why));\n}\n\nstatic void kick_tx(struct pci_vtsock_softc *sc, const char *why)\n{\n\tchar dummy;\n\tssize_t nr;\n\tnr = write(sc->tx_kick_fd, &dummy, 1);\n\tassert(nr == 1);\n\tDPRINTF((\"TX: kicked tx thread: %s\\n\", why));\n}\n\n/* Reflect peer_shutdown into local fd */\nstatic void shutdown_peer_local_fd(struct pci_vtsock_sock *s, uint32_t mode,\n\t\t\t\t       const char *ctx)\n{\n\tint rc;\n\tint how;\n\tconst char *how_str;\n\tuint32_t new = mode | s->peer_shutdown;\n\tuint32_t set = s->peer_shutdown ^ new;\n\tuint32_t new_local = s->local_shutdown;\n\n\tassert((mode & ~VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL) == 0);\n\tassert(mode != 0);\n\n\tDPRINTF((\"%s: PEER CUR %\"PRIx32\", MODE %\"PRIx32\", NEW %\"PRIx32\", SET %\"PRIx32\"\\n\",\n\t\t ctx, s->peer_shutdown, mode, new, set));\n\n\tswitch (set) {\n\tcase 0:\n\t\treturn;\n\tcase VIRTIO_VSOCK_FLAG_SHUTDOWN_TX:\n\t\tif (sock_is_buffering(s))\n\t\t{\n\t\t\tPPRINTF((\"%s: fd: %d SHUT_WR while buffering, deferring local shutdown\\n\", ctx, s->fd));\n\t\t\thow = 0;\n\t\t\thow_str = \"none\";\n\t\t} else  {\n\t\t\thow = SHUT_WR;\n\t\t\thow_str = \"SHUT_WR\";\n\t\t\tnew_local |= VIRTIO_VSOCK_FLAG_SHUTDOWN_RX;\n\t\t}\n\t\tbreak;\n\tcase VIRTIO_VSOCK_FLAG_SHUTDOWN_RX:\n\t\thow = SHUT_RD;\n\t\thow_str = \"SHUT_RD\";\n\t\tnew_local = s->local_shutdown | VIRTIO_VSOCK_FLAG_SHUTDOWN_TX;\n\t\tbreak;\n\tcase VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL:\n\t\tif (sock_is_buffering(s)) {\n\t\t\tPPRINTF((\"%s: fd: %d SHUT_RDWR while buffering, deferring local SHUT_WR\\n\", ctx, s->fd));\n\t\t\thow = SHUT_RD;\n\t\t\thow_str = \"SHUT_RD\";\n\t\t\tnew_local |= VIRTIO_VSOCK_FLAG_SHUTDOWN_TX;\n\t\t} else {\n\t\t\thow = SHUT_RDWR;\n\t\t\thow_str = \"SHUT_RDWR\";\n\t\t\tnew_local |= VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\n\tif (how) {\n\t\trc = shutdown(s->fd, how);\n\t\tDPRINTF((\"%s: shutdown_peer: shutdown(%d, %s)\\n\", ctx, s->fd, how_str));\n\t\tif (rc < 0 && errno != ENOTCONN) {\n\t\t\tDPRINTF((\"%s: shutdown(%d, %s) for peer shutdown failed: %s\\n\",\n\t\t\t\t ctx, s->fd, how_str, strerror(errno)));\n\t\t\tabort();\n\t\t}\n\t}\n\n\ts->local_shutdown = new_local;\n\ts->peer_shutdown = new;\n}\n\n/* The caller must have sent something (probably OP_RST, but perhaps\n * OP_SHUTDOWN) to the peer already.\n */\nstatic void close_sock(struct pci_vtsock_softc *sc,  struct pci_vtsock_sock *s,\n\t\t       const char *ctx)\n{\n\tif (!s) return;\n\tDPRINTF((\"%s: Closing sock %p\\n\", ctx, (void *)s));\n\n\tshutdown_peer_local_fd(s, VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL, ctx);\n\n\ts->state = SOCK_CLOSING_TX;\n\tkick_tx(sc, \"sock closed\");\n}\n\n/*\n * Caller should send OP_SHUTDOWN with flags == s->local_shutdown after calling this.\n */\nstatic void shutdown_local_sock(const char *ctx,\n\t\t\t\tstruct pci_vtsock_sock *s,\n\t\t\t\tuint32_t mode)\n{\n\tuint32_t new, set;\n\n\tassert((mode & ~VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL) == 0);\n\n\tif (s->state != SOCK_CONNECTED) return;\n\n\tassert(s->local_shutdown != VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL);\n\n\tDPRINTF((\"%s: fd %d: LOCAL SHUTDOWN 0x%\"PRIx32\" (0x%\"PRIx32\")\\n\",\n\t\t ctx, s->fd, mode, s->peer_shutdown));\n\n\tnew = mode | s->local_shutdown;\n\tset = s->local_shutdown ^ new;\n\ts->local_shutdown = new;\n\n\tDPRINTF((\"%s: setting 0x%\"PRIx32\" mode is now 0x%\"PRIx32\" (peer 0x%\"PRIx32\")\\n\",\n\t\t ctx, set, s->local_shutdown, s->peer_shutdown));\n\n\tif (s->local_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_RX && s->write_buf_tail > 0) {\n\t\tPPRINTF((\"%s: discarding %d bytes from buffer\\n\", ctx,\n\t\t\t s->write_buf_tail - s->write_buf_head));\n\t\ts->write_buf_tail = s->write_buf_head = 0;\n\t}\n\n\tif (s->local_shutdown == VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL)\n\t\ts->rst_deadline = time(NULL) + SHUTDOWN_RST_DELAY;\n}\n\nstatic void set_credit_update_required(struct pci_vtsock_softc *sc,\n\t\t\t\t       struct pci_vtsock_sock *sock)\n{\n\tif (sock->credit_update_required) return;\n\tsock->credit_update_required = true;\n\tsc->rx_kick_pending = true;\n}\n\nstatic void send_response_common(struct pci_vtsock_softc *sc,\n\t\t\t\t struct vsock_addr local_addr,\n\t\t\t\t struct vsock_addr peer_addr,\n\t\t\t\t uint16_t op, uint16_t type, uint32_t flags,\n\t\t\t\t uint32_t buf_alloc, uint32_t fwd_cnt)\n{\n\tstruct virtio_sock_hdr *hdr;\n\tint slot;\n\n\tassert(op != VIRTIO_VSOCK_OP_RW);\n\tassert(flags == 0 || op == VIRTIO_VSOCK_OP_SHUTDOWN);\n\n\tpthread_mutex_lock(&sc->reply_mtx);\n\n\tslot = sc->reply_prod++;\n\tif (sc->reply_prod == VTSOCK_REPLYRINGSZ)\n\t\tsc->reply_prod = 0;\n\tDPRINTF((\"TX: QUEUING REPLY IN SLOT %x (prod %x, cons %x)\\n\",\n\t\t slot, sc->reply_prod, sc->reply_cons));\n\t/*\n\t * We have just incremented reply_prod above but we hold the\n\t * lock so the consumer cannot have caught us up. Hence for\n\t * the ring to appear empty it must actually have just overflowed.\n\t */\n\tassert(!REPLY_RING_EMPTY(sc));\n\n\thdr = &sc->reply_ring[slot];\n\n\thdr->src_cid = local_addr.cid;\n\thdr->src_port = local_addr.port;\n\n\thdr->dst_cid = peer_addr.cid;\n\thdr->dst_port = peer_addr.port;\n\n\thdr->len = 0;\n\thdr->type = type;\n\thdr->op = op;\n\thdr->flags = flags;\n\n\thdr->buf_alloc = buf_alloc;\n\thdr->fwd_cnt = fwd_cnt;\n\n\tdprint_header(hdr, 0, \"TX\");\n\n\tpthread_mutex_unlock(&sc->reply_mtx);\n\n\tsc->rx_kick_pending = true;\n}\n\nstatic void send_response_sock(struct pci_vtsock_softc *sc,\n\t\t\t\t uint16_t op, uint32_t flags,\n\t\t\t\t const struct pci_vtsock_sock *sock)\n{\n\tsend_response_common(sc, sock->local_addr, sock->peer_addr,\n\t\t\t     op, VIRTIO_VSOCK_TYPE_STREAM, flags,\n\t\t\t     sock->buf_alloc, sock->fwd_cnt);\n}\n\nstatic void send_response_nosock(struct pci_vtsock_softc *sc, uint16_t op,\n\t\t\t\t uint16_t type,\n\t\t\t\t struct vsock_addr local_addr,\n\t\t\t\t struct vsock_addr peer_addr)\n{\n\tsend_response_common(sc, local_addr, peer_addr,\n\t\t\t     op, type, 0, 0, 0);\n}\n\nstatic bool sock_is_buffering(struct pci_vtsock_sock *sock)\n{\n\treturn sock->write_buf_tail > 0;\n}\n\nstatic int buffer_write(struct pci_vtsock_sock *sock,\n\t\t\tuint32_t len, struct iovec *iov, int iov_len)\n{\n\tsize_t nr;\n\tif (len > WRITE_BUF_LENGTH - sock->write_buf_tail) {\n\t\tDPRINTF((\"TX: fd %d unable to buffer write of 0x%\"PRIx32\" bytes,\"\n\t\t\t \" buffer use 0x%x/0x%x, 0x%x remaining\\n\",\n\t\t\t sock->fd, len, sock->write_buf_tail,\n\t\t\t WRITE_BUF_LENGTH,\n\t\t\t WRITE_BUF_LENGTH - sock->write_buf_tail));\n\t\treturn -1;\n\t}\n\n\tnr = iovec_pull(&iov, &iov_len,\n\t\t\t&sock->write_buf[sock->write_buf_tail], len);\n\tassert(nr == len);\n\tassert(iov_len == 0);\n\n\tsock->write_buf_tail += nr;\n\tDPRINTF((\"TX: fd %d buffered 0x%\"PRIx32\" bytes (0x%x/0x%x)\\n\",\n\t\t sock->fd, len, sock->write_buf_tail, WRITE_BUF_LENGTH));\n\n\treturn 0;\n}\n\nstatic void buffer_drain(struct pci_vtsock_softc *sc,\n\t\t\t struct pci_vtsock_sock *sock)\n{\n\tssize_t nr;\n\n\tDPRINTF((\"TX: buffer drain on fd %d 0x%x-0x%x/0x%x\\n\",\n\t\t sock->fd, sock->write_buf_head, sock->write_buf_tail,\n\t\t WRITE_BUF_LENGTH));\n\n\tassert(sock_is_buffering(sock));\n\tassert(sock->write_buf_head < sock->write_buf_tail);\n\n\tnr = write(sock->fd, &sock->write_buf[sock->write_buf_head],\n\t\t   sock->write_buf_tail - sock->write_buf_head);\n\tif (nr == -1) {\n\t\tif (errno == EPIPE) {\n\t\t\t/* Assume EOF and shutdown */\n\t\t\tshutdown_local_sock(\"TX\", sock, VIRTIO_VSOCK_FLAG_SHUTDOWN_RX);\n\t\t\tsend_response_sock(sc, VIRTIO_VSOCK_OP_SHUTDOWN,\n\t\t\t\t\t   sock->local_shutdown, sock);\n\t\t\treturn;\n\t\t} else if (errno == EAGAIN) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tPPRINTF((\"TX: write fd=%d failed with %d %s\\n\", sock->fd,\n\t\t\t\t errno, strerror(errno)));\n\t\t\tsend_response_sock(sc, VIRTIO_VSOCK_OP_RST, 0, sock);\n\t\t\tclose_sock(sc, sock, \"TX\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tDPRINTF((\"TX: drained %zd/%\"PRId32\" bytes\\n\", nr,\n\t\t sock->write_buf_tail - sock->write_buf_head));\n\tsock->write_buf_head += nr;\n\tif (sock->write_buf_head < sock->write_buf_tail)\n\t\treturn;\n\n\t/* Buffer completely drained, reset and update peer.  NB: We\n\t * only update fwd_cnt once the buffer is empty rather than as\n\t * we go, in the hopes that we then won't need to buffer so\n\t * much as we go on.\n\t */\n\tDPRINTF((\"TX: fd %d buffer drained of 0x%x bytes\\n\",\n\t\t sock->fd, sock->write_buf_head));\n\tsock->fwd_cnt += sock->write_buf_head;\n\tsock->write_buf_head = sock->write_buf_tail = 0;\n\n\t/* shutdown_peer_local_fd will have deferred this if we were buffering */\n\tif ((sock->peer_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_TX) &&\n\t    !(sock->local_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_RX)) {\n\t\tint rc = shutdown(sock->fd, SHUT_WR);\n\t\tPPRINTF((\"TX: buffer_drained, performing pending shutdown(%d, SHUT_WR)\\n\", sock->fd));\n\t\tif (rc < 0 && errno != ENOTCONN) {\n\t\t\tDPRINTF((\"TX: shutdown(%d, SHUT_WR) after buffer drain failed: %s\\n\",\n\t\t\t\t sock->fd, strerror(errno)));\n\t\t\tabort();\n\t\t}\n\t\tsock->local_shutdown |= VIRTIO_VSOCK_FLAG_SHUTDOWN_RX;\n\t}\n\n\tset_credit_update_required(sc, sock);\n}\n\n/* -> 1 == success, update peer credit\n * -> 0 == success, don't update peer credit\n */\nstatic int handle_write(struct pci_vtsock_softc *sc,\n\t\t\tstruct pci_vtsock_sock *sock,\n\t\t\tuint32_t len, struct iovec *iov, int iov_len)\n{\n\tssize_t num;\n\n\tif (sock_is_buffering(sock)) {\n\t\treturn buffer_write(sock, len, iov, iov_len);\n\t}\n\n\tnum = writev(sock->fd, iov, iov_len);\n\tif (num == -1) {\n\t\tif (errno == EPIPE) {\n\t\t\t/* Assume EOF and shutdown */\n\t\t\tPPRINTF((\"TX: writev fd=%d failed with EPIPE => SHUTDOWN_RX\\n\", sock->fd));\n\t\t\tshutdown_local_sock(\"TX\", sock, VIRTIO_VSOCK_FLAG_SHUTDOWN_RX);\n\t\t\tsend_response_sock(sc, VIRTIO_VSOCK_OP_SHUTDOWN,\n\t\t\t\t\t   sock->local_shutdown, sock);\n\t\t\treturn 0;\n\t\t} else if (errno == EAGAIN) {\n\t\t\tnum = 0;\n\t\t} else {\n\t\t\tPPRINTF((\"TX: writev fd=%d failed with %d %s\\n\", sock->fd,\n\t\t\t\t errno, strerror(errno)));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tDPRINTF((\"TX: wrote %zd/%\"PRId32\" bytes\\n\", num, len));\n\tsock->fwd_cnt += num;\n\tif (num == len) {\n\t\treturn 1;\n\t} else { /* Buffer the rest */\n\t\tsize_t pulled = iovec_pull(&iov, &iov_len, NULL, (size_t)num);\n\t\tassert(pulled == (size_t)num);\n\t\treturn buffer_write(sock, len - (uint32_t)num, iov, iov_len);\n\t}\n}\n\nstatic void pci_vtsock_proc_tx(struct pci_vtsock_softc *sc,\n\t\t\t       struct vqueue_info *vq)\n{\n\tstruct pci_vtsock_sock *sock;\n\tstruct iovec iov_array[VTSOCK_MAXSEGS], *iov = iov_array;\n\tuint16_t idx, flags[VTSOCK_MAXSEGS];\n\tstruct virtio_sock_hdr hdr;\n\tint iovec_len;\n\tsize_t pulled;\n\n\tiovec_len = vq_getchain(vq, &idx, iov, VTSOCK_MAXSEGS, flags);\n\tassert(iovec_len <= VTSOCK_MAXSEGS);\n\n\tDPRINTF((\"TX: chain with %d buffers at idx %\"PRIx16\"\\n\",\n\t\t iovec_len, idx));\n\tdprint_chain(iov, iovec_len, \"TX\");\n\t//assert(iov[0].iov_len >= sizeof(*hdr));\n\t//hdr = iov[0].iov_base;\n\n\tpulled = iovec_pull(&iov, &iovec_len, &hdr, sizeof(hdr));\n\tassert(pulled == sizeof(hdr));\n\n\tdprint_header(&hdr, 1, \"TX\");\n\n\tdprint_iovec(iov, iovec_len, \"TX\");\n\n\tif (hdr.src_cid != sc->vssc_cfg.guest_cid ||\n\t    hdr.dst_cid != VMADDR_CID_HOST ||\n\t    hdr.type != VIRTIO_VSOCK_TYPE_STREAM) {\n\t\tDPRINTF((\"TX: Bad src/dst address/type\\n\"));\n\t\tsend_response_nosock(sc, VIRTIO_VSOCK_OP_RST,\n\t\t\t\t     hdr.type,\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = hdr.dst_cid,\n\t\t\t\t\t     .port =hdr.dst_port\n\t\t\t\t     },\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = hdr.src_cid,\n\t\t\t\t\t     .port =hdr.src_port\n\t\t\t\t     });\n\t\tvq_relchain(vq, idx, 0);\n\t\treturn;\n\t}\n\n\tsock = lookup_sock(sc, VIRTIO_VSOCK_TYPE_STREAM,\n\t\t\t   (struct vsock_addr) {\n\t\t\t\t   .cid = hdr.dst_cid,\n\t\t\t\t\t   .port =hdr.dst_port\n\t\t\t   },\n\t\t\t   (struct vsock_addr) {\n\t\t\t\t   .cid = hdr.src_cid,\n\t\t\t\t\t   .port =hdr.src_port\n\t\t\t   });\n\n\tif (sock) {\n\t\tsock->peer_buf_alloc = hdr.buf_alloc;\n\t\tsock->peer_fwd_cnt = hdr.fwd_cnt;\n\t}\n\n\tswitch (hdr.op) {\n\tcase VIRTIO_VSOCK_OP_INVALID:\n\t\tPPRINTF((\"TX: => INVALID\\n\"));\n\t\tgoto do_rst;\n\n\tcase VIRTIO_VSOCK_OP_REQUEST:\n\t\t/* Attempt to (re)connect existing sock? Naughty! */\n\t\t/* Or is it -- what are the semantics? */\n\t\tif (sock) {\n\t\t\tPPRINTF((\"TX: Attempt to reconnect sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\n\t\tif (hdr.dst_cid == sc->vssc_cfg.guest_cid) {\n\t\t\tPPRINTF((\"TX: Attempt to connect back to guest\\n!\"));\n\t\t\tgoto do_rst;\n\t\t}\n\n\t\tsock = connect_sock(sc,\n\t\t\t\t    (struct vsock_addr){\n\t\t\t\t\t    .cid = hdr.dst_cid, .port = hdr.dst_port\n\t\t\t\t    },\n\t\t\t\t    (struct vsock_addr){\n\t\t\t\t\t    .cid = hdr.src_cid, .port = hdr.src_port\n\t\t\t\t    }, hdr.buf_alloc, hdr.fwd_cnt);\n\t\tif (!sock) {\n\t\t\tPPRINTF((\"TX: Failed to open sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\n\t\tsend_response_sock(sc, VIRTIO_VSOCK_OP_RESPONSE, 0, sock);\n\t\tvq_relchain(vq, idx, 0);\n\t\t/* No rx kick required, send_response_sock did one */\n\t\tbreak;\n\n\tcase VIRTIO_VSOCK_OP_RESPONSE:\n\t\tif (!sock) {\n\t\t\tPPRINTF((\"TX: RESPONSE to non-existent sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->state != SOCK_CONNECTING) {\n\t\t\tPPRINTF((\"TX: RESPONSE to non-connecting sock (state %d)\\n\",\n\t\t\t\t sock->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tPPRINTF((\"TX: SOCK connected (%d) \"PRIaddr\" <=> \"PRIaddr\"\\n\",\n\t\t\t sock->fd, FMTADDR(sock->local_addr), FMTADDR(sock->peer_addr)));\n\t\tsock->state = SOCK_CONNECTED;\n\t\tvq_relchain(vq, idx, 0);\n\t\tkick_rx(sc, \"new outgoing sock\");\n\t\tbreak;\n\n\tcase VIRTIO_VSOCK_OP_RST:\n\t\t/* No response */\n\t\tif (!sock)\n\t\t\tPPRINTF((\"TX: RST to non-existent sock\\n\"));\n\t\tclose_sock(sc, sock, \"TX\");\n\t\tvq_relchain(vq, idx, 0);\n\t\tbreak;\n\n\tcase VIRTIO_VSOCK_OP_SHUTDOWN:\n\t\tif (!sock) {\n\t\t\tDPRINTF((\"TX: SHUTDOWN to non-existent sock \"PRIcid\".\"PRIport\"\\n\",\n\t\t\t\t hdr.dst_cid, hdr.dst_port));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->state != SOCK_CONNECTED) {\n\t\t\tPPRINTF((\"TX: SHUTDOWN to non-connected sock (state %d)\\n\",\n\t\t\t\t sock->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (hdr.flags & ~VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL) {\n\t\t\tPPRINTF((\"TX: SHUTDOWN with reserved flags %\"PRIx32\"\\n\",\n\t\t\t\t hdr.flags));\n\t\t\tgoto do_rst; /* ??? */\n\t\t}\n\t\tif (!(hdr.flags & VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL)) {\n\t\t\tPPRINTF((\"TX: SHUTDOWN with no flags %\"PRIx32\"\\n\",\n\t\t\t\t hdr.flags));\n\t\t\tgoto do_rst; /* ??? */\n\t\t}\n\n\t\tshutdown_peer_local_fd(sock, hdr.flags, \"TX\");\n\n\t\t/* If the peer is now SHUTDOWN_ALL then we should send\n\t\t * a RST to the peer to finalise the shutdown.\n\t\t */\n\t\tif (sock->peer_shutdown == VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL)\n\t\t\tgoto do_rst;\n\n\t\tvq_relchain(vq, idx, 0);\n\t\tbreak;\n\n\tcase VIRTIO_VSOCK_OP_RW:\n\t{\n\t\tint rc;\n\n\t\tif (!sock) {\n\t\t\tPPRINTF((\"TX: RW with no sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->state != SOCK_CONNECTED) {\n\t\t\tPPRINTF((\"TX: RW to non-connected sock (state %d)\\n\",\n\t\t\t\t sock->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->peer_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_TX) {\n\t\t\tPPRINTF((\"TX: RW to socket with peer_shutdown.TX\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->local_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_RX) {\n\t\t\tPPRINTF((\"TX: RW to socket with local_shutdown.RX\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\trc = handle_write(sc, sock, hdr.len, iov, iovec_len);\n\t\tif (rc < 0) goto do_rst;\n\t\tvq_relchain(vq, idx, 0);\n\t\tif (rc == 1)\n\t\t\tset_credit_update_required(sc, sock);\n\t\tbreak;\n\t}\n\n\tcase VIRTIO_VSOCK_OP_CREDIT_UPDATE:\n\t\tif (!sock) {\n\t\t\tPPRINTF((\"TX: CREDIT_UPDATE to non-existent sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->state != SOCK_CONNECTED) {\n\t\t\tPPRINTF((\"TX: CREDIT_UPDATE to non-connected sock (state %d)\\n\",\n\t\t\t\t sock->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\t/* No response needed, we updated above */\n\t\tvq_relchain(vq, idx, 0);\n\t\t/* But kick rx thread to attempt to send more */\n\t\tsc->rx_kick_pending = true;\n\t\tbreak;\n\n\tcase VIRTIO_VSOCK_OP_CREDIT_REQUEST:\n\t\tif (!sock) {\n\t\t\tPPRINTF((\"TX: CREDIT_REQUEST to non-existent sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->state != SOCK_CONNECTED) {\n\t\t\tPPRINTF((\"TX: CREDIT_REQUEST to non-connected sock (state %d)\\n\",\n\t\t\t\t sock->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tvq_relchain(vq, idx, 0);\n\t\tset_credit_update_required(sc, sock);\n\t\tbreak;\n\t}\n\n\tif (sock)\n\t\tput_sock(sock);\n\n\treturn;\n\ndo_rst:\n\tif (sock)\n\t\tsend_response_sock(sc, VIRTIO_VSOCK_OP_RST, 0, sock);\n\telse\n\t\tsend_response_nosock(sc, VIRTIO_VSOCK_OP_RST, hdr.type,\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = hdr.dst_cid,\n\t\t\t\t\t     .port =hdr.dst_port\n\t\t\t\t     },\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = hdr.src_cid,\n\t\t\t\t\t     .port =hdr.src_port\n\t\t\t\t     });\n\tvq_relchain(vq, idx, 0);\n\tclose_sock(sc, sock, \"TX\");\n\tif (sock) put_sock(sock);\n\treturn;\n}\n\nstatic void handle_connect_fd(struct pci_vtsock_softc *sc, int accept_fd, uint64_t cid, uint32_t port)\n{\n\tint fd, rc;\n\tchar buf[8 + 1 + 8 + 1 + 1]; /* %08x.%08x\\n\\0 */\n\tssize_t bytes;\n\tstruct pci_vtsock_sock *sock = NULL;\n\n\tfd = accept(accept_fd, NULL, NULL);\n\tif (fd < 0) {\n\t\tfprintf(stderr,\n\t\t\t\"TX: Unable to accept incoming connection: %d (%s)\\n\",\n\t\t\terrno, strerror(errno));\n\t\treturn;\n\t}\n\n\tif (fd >= FD_SETSIZE) {\n\t\tfprintf(stderr, \"TX: Unable to accept incoming connection: fd %d > FD_SETSIZE %d\\n\",\n\t\t\tfd, FD_SETSIZE);\n\t\tclose(fd);\n\t\tgoto err;\n\t}\n\n\tDPRINTF((\"TX: Connect attempt on connect fd => %d\\n\", fd));\n\n\tif (cid == VMADDR_CID_ANY) {\n\t\tdo {\n\t\t\tbytes = read(fd, buf, sizeof(buf)-1);\n\t\t} while (bytes == -1 && errno == EAGAIN);\n\n\t\tif (bytes != sizeof(buf) - 1) {\n\t\t\tDPRINTF((\"TX: Short read on connect %zd/%zd\\n\", bytes, sizeof(buf)-1));\n\t\t\tif (bytes == -1) DPRINTF((\"TX: errno: %s\\n\", strerror(errno)));\n\t\t\tgoto err;\n\t\t}\n\t\tbuf[sizeof(buf)-1] = '\\0';\n\n\t\tif (buf[sizeof(buf)-2] != '\\n') {\n\t\t\tDPRINTF((\"TX: No newline on connect %s\\n\", buf));\n\t\t\tgoto err;\n\t\t}\n\n\t\tDPRINTF((\"TX: Connect to %s\", buf));\n\n\t\trc = sscanf(buf, SCNaddr\"\\n\", &cid, &port);\n\t\tif (rc != 2) {\n\t\t\tDPRINTF((\"TX: Failed to parse connect attempt\\n\"));\n\t\t\tgoto err;\n\t\t}\n\t\tDPRINTF((\"TX: Connection requested to \"PRIaddr\"\\n\", cid, port));\n\t} else {\n\t\tDPRINTF((\"TX: Forwarding connection to \"PRIaddr\"\\n\", cid, port));\n\t}\n\n\tif (cid >= VMADDR_CID_MAX) {\n\t\tDPRINTF((\"TX: Attempt to connect to CID over 32-bit\\n\"));\n\t\tgoto err;\n\t}\n\tif (cid != sc->vssc_cfg.guest_cid) {\n\t\tDPRINTF((\"TX: Attempt to connect to non-guest CID\\n\"));\n\t\tgoto err;\n\t}\n\n\tsock = alloc_sock(sc);\n\n\tif (sock == NULL) {\n\t\tDPRINTF((\"TX: No available sockets for connect\\n\"));\n\t\tgoto err;\n\t}\n\n\tDPRINTF((\"TX: Assigned sock %ld at %p for connect\\n\",\n\t\t sock - &sc->socks[0], (void *)sock));\n\n\tsock->fd = fd;\n\tsock->peer_addr.cid = cid;\n\tsock->peer_addr.port = port;\n\tsock->local_addr.cid = VMADDR_CID_HOST;\n\t/* Start at 2^16 to be larger than a TCP port, add a\n\t * generation counter to reduce port reuse.\n\t * XXX Allocate properly.\n         */\n\tsock->local_addr.port = ((uint32_t)(sock - &sc->socks[0] + 1) << 16)\n\t\t+ (++sock->port_generation);\n\n\trc = set_socket_options(sock);\n\tif (rc < 0) goto err;\n\n\tput_sock(sock);\n\n\tPPRINTF((\"TX: SOCK connecting (%d) \"PRIaddr\" <=> \"PRIaddr\"\\n\",\n\t\t sock->fd, FMTADDR(sock->local_addr), FMTADDR(sock->peer_addr)));\n\tsend_response_sock(sc, VIRTIO_VSOCK_OP_REQUEST, 0, sock);\n\n\treturn;\nerr:\n\tif (sock) {\n\t\tpthread_rwlock_wrlock(&sc->list_rwlock);\n\t\tfree_sock(sc, sock);\n\t\tpthread_rwlock_unlock(&sc->list_rwlock);\n\t}\n\tclose(fd);\n}\n\nstatic void *pci_vtsock_tx_thread(void *vsc)\n{\n\tstruct pci_vtsock_softc *sc = vsc;\n\tstruct vqueue_info *vq = &sc->vssc_vqs[VTSOCK_QUEUE_TX];\n\tfd_set rfd, wfd;\n\tLIST_HEAD(tx_queue, pci_vtsock_sock) queue;\n\n\tpthread_setname_np(\"vsock:tx\");\n\n\tassert(sc);\n\tassert(sc->tx_wake_fd != -1);\n\tassert(sc->connect_fd != -1);\n\n\twhile(1) {\n\t\tbool kick_rx_closing = false;\n\t\tint i, nrfd, maxfd, nr;\n\t\tint buffering = 0;\n\t\tstruct pci_vtsock_sock *s;\n\t\tstruct timeval *select_timeout = NULL, select_timeout_5s;\n\n\t\tLIST_INIT(&queue);\n\n\t\tFD_ZERO(&rfd);\n\t\tFD_ZERO(&wfd);\n\n\t\tFD_SET(sc->tx_wake_fd, &rfd);\n\t\tmaxfd = sc->tx_wake_fd;\n\n\t\tFD_SET(sc->connect_fd, &rfd);\n\t\tmaxfd = max_fd(sc->connect_fd, maxfd);\n\t\tnrfd = 2;\n\n\t\tfor (i = 0; i < sc->nr_fwds; i++) {\n\t\t\tstruct pci_vtsock_forward *fwd = &sc->fwds[i];\n\t\t\tassert(fwd->listen_fd != -1);\n\t\t\tFD_SET(fwd->listen_fd, &rfd);\n\t\t\tmaxfd = max_fd(fwd->listen_fd, maxfd);\n\t\t\tnrfd++;\n\t\t}\n\n\t\tpthread_rwlock_rdlock(&sc->list_rwlock);\n\t\tLIST_FOREACH(s, &sc->inuse_list, list) {\n\t\t\tget_sock(s);\n\n\t\t\tswitch (s->state) {\n\t\t\tcase SOCK_CLOSING_TX: /* Closing comes through here */\n\t\t\t\tif (sock_is_buffering(s))\n\t\t\t\t\tbreak;\n\n\t\t\t        /* Close down */\n\t\t\t\tassert(s->local_shutdown == VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL ||\n\t\t\t\t       s->peer_shutdown == VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL);\n\n\t\t\t\tDPRINTF((\"TX: Closing sock %p fd %d local %\"PRIx32\" peer %\"PRIx32\"\\n\",\n\t\t\t\t\t (void *)s, s->fd,\n\t\t\t\t\t s->local_shutdown,\n\t\t\t\t\t s->peer_shutdown));\n\t\t\t\tPPRINTF((\"TX: SOCK closed (%d) \"PRIaddr\" <=> \"PRIaddr\"\\n\",\n\t\t\t\t\t s->fd,\n\t\t\t\t\t FMTADDR(s->local_addr), FMTADDR(s->peer_addr)));\n\n\t\t\t\ts->state = SOCK_CLOSING_RX;\n\n\t\t\t\tkick_rx_closing = true;\n\n\t\t\t\tput_sock(s);\n\t\t\t\tcontinue;\n\t\t\tcase SOCK_CONNECTED:\n\t\t\t\tbreak;\n\t\t\tcase SOCK_FREE:\n\t\t\tcase SOCK_CONNECTING:\n\t\t\tcase SOCK_CLOSING_RX:\n\t\t\t\tput_sock(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tassert(s->fd >= 0);\n\n\t\t\tif (s->local_shutdown == VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL) {\n\t\t\t\ttime_t now = time(NULL);\n\n\t\t\t\t/* Has deadline for peer to return a RST expired? */\n\t\t\t\tif (now > s->rst_deadline) {\n\t\t\t\t\tsend_response_sock(sc, VIRTIO_VSOCK_OP_RST, 0, s);\n\t\t\t\t\tclose_sock(sc, s, \"TX\");\n\t\t\t\t\tput_sock(s);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (select_timeout == NULL) {\n\t\t\t\t\tselect_timeout_5s.tv_sec = 5;\n\t\t\t\t\tselect_timeout_5s.tv_usec = 0;\n\t\t\t\t\tselect_timeout = &select_timeout_5s;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (s->local_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_RX) {\n\t\t\t\tput_sock(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (sock_is_buffering(s)) {\n\t\t\t\tFD_SET(s->fd, &wfd);\n\t\t\t\tmaxfd = max_fd(s->fd, maxfd);\n\t\t\t\tbuffering++;\n\t\t\t\tnrfd++;\n\t\t\t\tLIST_INSERT_HEAD(&queue, s, tx_queue);\n\t\t\t}\n\t\t\tput_sock(s);\n\t\t}\n\t\tpthread_rwlock_unlock(&sc->list_rwlock);\n\t\tassert(maxfd < FD_SETSIZE);\n\n\t\tif (kick_rx_closing)\n\t\t\tkick_rx(sc, \"tx closing\");\n\n\t\tDPRINTF((\"TX: *** selecting on %d fds (buffering: %d)\\n\",\n\t\t\t nrfd, buffering));\n\t\tnr = xselect(\"TX\", maxfd + 1, &rfd, &wfd, NULL, select_timeout);\n\t\tif (nr < 0) continue;\n\t\tDPRINTF((\"TX:\\nTX: *** %d/%d fds are readable/writeable\\n\", nr, nrfd));\n\n\t\tif (FD_ISSET(sc->tx_wake_fd, &rfd)) {\n\t\t\t/* Eat the notification(s) */\n\t\t\tchar dummy[128];\n\t\t\tssize_t rd_dummy = read(sc->tx_wake_fd, &dummy, sizeof(dummy));\n\t\t\tassert(rd_dummy >= 1);\n\t\t\t/* Restart select now that we have some descriptors */\n\t\t\tDPRINTF((\"TX: thread got %zd kicks (have descs: %s)\\n\",\n\t\t\t\t rd_dummy,\n\t\t\t\t vq_has_descs(vq) ? \"yes\" : \"no\"));\n\t\t}\n\n\t\tif (FD_ISSET(sc->connect_fd, &rfd)) {\n\t\t\tDPRINTF((\"TX: Handling connect fd\\n\"));\n\t\t\thandle_connect_fd(sc, sc->connect_fd, VMADDR_CID_ANY, 0);\n\t\t}\n\n\t\tfor (i = 0; i < sc->nr_fwds; i++) {\n\t\t\tstruct pci_vtsock_forward *fwd = &sc->fwds[i];\n\t\t\tif (FD_ISSET(fwd->listen_fd, &rfd)) {\n\t\t\t\tDPRINTF((\"Attempt to connect to forwarded guest port %\"PRId32\"\\n\", fwd->port));\n\t\t\t\thandle_connect_fd(sc, fwd->listen_fd, sc->vssc_cfg.guest_cid, fwd->port);\n\t\t\t}\n\t\t}\n\n\t\tif (buffering) {\n\t\t\tLIST_FOREACH(s, &queue, tx_queue) {\n\t\t\t\tget_sock(s);\n\t\t\t\tif (s->state != SOCK_CONNECTED && s->state != SOCK_CLOSING_TX) {\n\t\t\t\t\tput_sock(s);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (FD_ISSET(s->fd, &wfd)) {\n\t\t\t\t\tbuffer_drain(sc, s);\n\t\t\t\t}\n\t\t\t\tput_sock(s);\n\t\t\t}\n\t\t}\n\n\t\twhile (vq_has_descs(vq))\n\t\t\tpci_vtsock_proc_tx(sc, vq);\n\n\t\tif (vq_ring_ready(vq))\n\t\t\tvq_endchains(vq, 1);\n\n\t\tif (sc->rx_kick_pending) {\n\t\t\tkick_rx(sc, \"end of tx loop\");\n\t\t}\n\t\tDPRINTF((\"TX: All work complete\\n\"));\n\t}\n}\n\nstatic void pci_vtsock_notify_tx(void *vsc, struct vqueue_info *vq)\n{\n\tstruct pci_vtsock_softc *sc = vsc;\n\n\tassert(vq == &sc->vssc_vqs[VTSOCK_QUEUE_TX]);\n\tkick_tx(sc, \"notify\");\n}\n\n/*\n * Returns:\n *  -1 == no descriptors available, nothing sent, s->credit_update_required untouched\n *   0 == nothing done (sock has shutdown, peer has no buffers, nothing on Unix socket)\n *  >0 == number of bytes read\n *\n * If return is >= 0 then will have sent something to the other end\n * (an OP_CREDIT_UPDATE if no other traffic was generated) and thus\n * s->credit_update_required will be false on exit if return is >= 0.\n */\nstatic ssize_t pci_vtsock_proc_rx(struct pci_vtsock_softc *sc,\n\t\t\t\t  struct vqueue_info *vq,\n\t\t\t\t  struct pci_vtsock_sock *s)\n{\n\tstruct virtio_sock_hdr *hdr;\n\tstruct iovec iov_array[VTSOCK_MAXSEGS], *iov = iov_array;\n\tuint16_t flags[VTSOCK_MAXSEGS];\n\tuint16_t idx;\n\tuint32_t peer_free;\n\tint iovec_len;\n\tsize_t pushed;\n\tssize_t len;\n\n\tassert(s->fd >= 0);\n\n\tif (!vq_has_descs(vq)) {\n\t\tDPRINTF((\"RX: no queues!\\n\"));\n\t\treturn -1;\n\t}\n\n\tiovec_len = vq_getchain(vq, &idx, iov, VTSOCK_MAXSEGS, flags);\n\tDPRINTF((\"RX: virtio-vsock: got %d elem rx chain\\n\", iovec_len));\n\tdprint_chain(iov, iovec_len, \"RX\");\n\n\tassert(iovec_len >= 1);\n\t/* XXX needed so we can update len after the read */\n\tassert(iov[0].iov_len >= sizeof(*hdr));\n\n\thdr = iov[0].iov_base;\n\thdr->src_cid = s->local_addr.cid;\n\thdr->src_port = s->local_addr.port;\n\thdr->dst_cid = s->peer_addr.cid;\n\thdr->dst_port = s->peer_addr.port;\n\thdr->len = 0; /* XXX */\n\thdr->type = VIRTIO_VSOCK_TYPE_STREAM;\n\thdr->op = VIRTIO_VSOCK_OP_RW;\n\thdr->flags = 0;\n\thdr->buf_alloc = s->buf_alloc;\n\thdr->fwd_cnt = s->fwd_cnt;\n\n\tpeer_free = s->peer_buf_alloc - (s->rx_cnt - s->peer_fwd_cnt);\n\tDPRINTF((\"RX:\\tpeer free = %\"PRIx32\"\\n\", peer_free));\n\tif (!peer_free) goto credit_update; /* No space */\n\n\tpushed = iovec_push(&iov, &iovec_len, hdr, sizeof(*hdr));\n\tassert(pushed == sizeof(*hdr));\n\n\tiovec_clip(&iov, &iovec_len, peer_free);\n\n\tlen = readv(s->fd, iov, iovec_len);\n\tif (len == -1) {\n\t\tif (errno == EAGAIN) { /* Nothing to read/would block */\n\t\t\tDPRINTF((\"RX: readv fd=%d EAGAIN\\n\", s->fd));\n\t\t\tgoto credit_update;\n\t\t}\n\t\tPPRINTF((\"RX: readv fd=%d failed with %d %s\\n\",\n\t\t\t s->fd, errno, strerror(errno)));\n\t\thdr->op = VIRTIO_VSOCK_OP_RST;\n\t\thdr->flags = 0;\n\t\thdr->len = 0;\n\t\tdprint_header(hdr, 0, \"RX\");\n\t\ts->credit_update_required = false;\n\t\tvq_relchain(vq, idx, sizeof(*hdr));\n\t\tclose_sock(sc, s, \"RX\");\n\t\treturn 0;\n\t}\n\tDPRINTF((\"RX: readv put %zd bytes into iov\\n\", len));\n\tif (len == 0) { /* Not actually anything to read -- EOF */\n\t\tPPRINTF((\"RX: readv fd=%d EOF => SHUTDOWN_TX\\n\", s->fd));\n\t\tshutdown_local_sock(\"RX\", s, VIRTIO_VSOCK_FLAG_SHUTDOWN_TX);\n\t\thdr->op = VIRTIO_VSOCK_OP_SHUTDOWN;\n\t\thdr->flags = s->local_shutdown;\n\t\thdr->len = 0;\n\t\tdprint_header(hdr, 0, \"RX\");\n\t\ts->credit_update_required = false;\n\t\tvq_relchain(vq, idx, sizeof(*hdr));\n\t\treturn 0;\n\t}\n\thdr->len = (uint32_t)len;\n\n\ts->rx_cnt += len;\n\n\tdprint_header(hdr, 0, \"RX\");\n\ts->credit_update_required = false;\n\tvq_relchain(vq, idx, sizeof(*hdr) + (uint32_t)len);\n\n\treturn len;\n\ncredit_update:\n\tif (s->credit_update_required) {\n\t\thdr->op = VIRTIO_VSOCK_OP_CREDIT_UPDATE;\n\t\thdr->flags = 0;\n\t\thdr->len = 0;\n\t\tdprint_header(hdr, 0, \"RX\");\n\t\ts->credit_update_required = false;\n\t\tvq_relchain(vq, idx, sizeof(*hdr));\n\t} else {\n\t\tvq_retchain(vq);\n\t}\n\treturn 0;\n}\n\n/* True if there is more to do */\nstatic bool rx_do_one_reply(struct pci_vtsock_softc *sc,\n\t\t\t    struct vqueue_info *vq)\n{\n\tstruct virtio_sock_hdr *hdr;\n\tstruct iovec iov_array[VTSOCK_MAXSEGS], *iov = iov_array;\n\tint iovec_len;\n\tuint16_t idx;\n\tsize_t pushed;\n\tint slot;\n\tbool more_to_do = false;\n\n\tif (REPLY_RING_EMPTY(sc))\n\t\tgoto done;\n\n\tslot = sc->reply_cons++;\n\tif (sc->reply_cons == VTSOCK_REPLYRINGSZ)\n\t\tsc->reply_cons = 0;\n\n\thdr = &sc->reply_ring[slot];\n\n\tiovec_len = vq_getchain(vq, &idx, iov, VTSOCK_MAXSEGS, NULL);\n\tDPRINTF((\"RX: reply: got %d elem rx chain for slot %x (prod %x, cons %x)\\n\",\n\t\t iovec_len, slot, sc->reply_prod, sc->reply_cons));\n\n\tassert(iovec_len >= 1);\n\n\tpushed = iovec_push(&iov, &iovec_len, hdr, sizeof(*hdr));\n\tassert(pushed == sizeof(*hdr));\n\n\tvq_relchain(vq, idx, sizeof(*hdr));\n\n\tmore_to_do = !REPLY_RING_EMPTY(sc);\n\ndone:\n\treturn more_to_do;\n}\n\n/* true on success, false if no descriptors */\nstatic bool send_credit_update(struct vqueue_info *vq,\n\t\t\t       struct pci_vtsock_sock *s)\n{\n\tstruct virtio_sock_hdr *hdr;\n\tstruct iovec iov_array[VTSOCK_MAXSEGS], *iov = iov_array;\n\tuint16_t idx;\n\tint iovec_len;\n\n\tassert(s->fd >= 0);\n\n\tif (!vq_has_descs(vq)) {\n\t\tDPRINTF((\"RX: no queues for credit update!\\n\"));\n\t\treturn false;\n\t}\n\n\tiovec_len = vq_getchain(vq, &idx, iov, VTSOCK_MAXSEGS, NULL);\n\tDPRINTF((\"RX: virtio-vsock: got %d elem rx chain for credit update\\n\", iovec_len));\n\tdprint_chain(iov, iovec_len, \"RX\");\n\n\tassert(iovec_len >= 1);\n\tassert(iov[0].iov_len >= sizeof(*hdr));\n\n\thdr = iov[0].iov_base;\n\thdr->src_cid = s->local_addr.cid;\n\thdr->src_port = s->local_addr.port;\n\thdr->dst_cid = s->peer_addr.cid;\n\thdr->dst_port = s->peer_addr.port;\n\thdr->len = 0;\n\thdr->type = VIRTIO_VSOCK_TYPE_STREAM;\n\thdr->op = VIRTIO_VSOCK_OP_CREDIT_UPDATE;\n\thdr->flags = 0;\n\thdr->buf_alloc = s->buf_alloc;\n\thdr->fwd_cnt = s->fwd_cnt;\n\n\tdprint_header(hdr, 0, \"RX\");\n\n\tvq_relchain(vq, idx, sizeof(*hdr));\n\n\treturn true;\n}\n\nstatic void *pci_vtsock_rx_thread(void *vsc)\n{\n\tstruct pci_vtsock_softc *sc = vsc;\n\tstruct vqueue_info *vq = &sc->vssc_vqs[VTSOCK_QUEUE_RX];\n\tfd_set rfd;\n\tbool poll_socks = true;\n\tstruct pci_vtsock_sock *s, *ts;\n\tLIST_HEAD(rx_queue, pci_vtsock_sock) queue;\n\tLIST_HEAD(rx_closing_queue, pci_vtsock_sock) closing_queue;\n\n\tassert(sc);\n\tassert(sc->rx_wake_fd != -1);\n\n\tpthread_setname_np(\"vsock:rx\");\n\nrx_done:\n\n\twhile (1) {\n\t\tint nrfd, maxfd, nr;\n\t\tbool did_some_work = true;\n\t\tbool pending_credit_updates = false;\n\t\tstruct timeval zero_timeout = {\n\t\t\t.tv_sec = 0,\n\t\t\t.tv_usec = 0,\n\t\t};\n\n\t\tFD_ZERO(&rfd);\n\n\t\tLIST_INIT(&queue);\n\t\tLIST_INIT(&closing_queue);\n\n\t\tFD_SET(sc->rx_wake_fd, &rfd);\n\t\tmaxfd = sc->rx_wake_fd;\n\t\tnrfd = 1;\n\n\t\tpthread_rwlock_rdlock(&sc->list_rwlock);\n\t\tLIST_FOREACH(s, &sc->inuse_list, list) {\n\t\t\tbool polling = true;\n\t\t\tuint32_t peer_free;\n\n\t\t\tget_sock(s);\n\n\t\t\tif (s->state == SOCK_CLOSING_RX) { /* Closing comes through here */\n\t\t\t\tassert(s->local_shutdown == VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL ||\n\t\t\t\t       s->peer_shutdown == VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL);\n\n\t\t\t\tDPRINTF((\"RX: Closing sock %p fd %d local %\"PRIx32\" peer %\"PRIx32\"\\n\",\n\t\t\t\t\t (void *)s, s->fd,\n\t\t\t\t\t s->local_shutdown,\n\t\t\t\t\t s->peer_shutdown));\n\t\t\t\tPPRINTF((\"RX: SOCK closed (%d) \"PRIaddr\" <=> \"PRIaddr\"\\n\",\n\t\t\t\t\t s->fd,\n\t\t\t\t\t FMTADDR(s->local_addr), FMTADDR(s->peer_addr)));\n\n\t\t\t\tclose(s->fd);\n\t\t\t\ts->fd = -1;\n\n\t\t\t\t/* Cannot move to free list with only\n\t\t\t\t * rdlock on list_rwlock, queue on a\n\t\t\t\t * local list */\n\t\t\t\tLIST_INSERT_HEAD(&closing_queue, s, rx_queue);\n\n\t\t\t\tput_sock(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (s->state != SOCK_CONNECTED || !poll_socks) {\n\t\t\t\tput_sock(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (s->local_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_TX)\n\t\t\t\tpolling = false;\n\n\t\t\tif (s->peer_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_RX)\n\t\t\t\tpolling = false;\n\n\t\t\tif (s->credit_update_required)\n\t\t\t\tpending_credit_updates = true;\n\n\t\t\tassert(s->fd >= 0);\n\t\t\tpeer_free = s->peer_buf_alloc - (s->rx_cnt - s->peer_fwd_cnt);\n\t\t\tDPRINTF((\"RX: sock %p (%d): peer free = %\"PRId32\"\\n\",\n\t\t\t\t (void*)s, s->fd, peer_free));\n\t\t\tif (peer_free == 0)\n\t\t\t\tpolling = false;\n\n\t\t\tif (polling) {\n\t\t\t\tFD_SET(s->fd, &rfd);\n\t\t\t\tmaxfd = max_fd(s->fd, maxfd);\n\t\t\t\tnrfd++;\n\t\t\t}\n\n\t\t\tif (polling || s->credit_update_required)\n\t\t\t\tLIST_INSERT_HEAD(&queue, s, rx_queue);\n\n\t\t\tput_sock(s);\n\t\t}\n\t\tpthread_rwlock_unlock(&sc->list_rwlock);\n\n\t\tif (!LIST_EMPTY(&closing_queue)) {\n\t\t\tpthread_rwlock_wrlock(&sc->list_rwlock);\n\n\t\t\tLIST_FOREACH(s, &closing_queue, rx_queue) {\n\t\t\t\tget_sock(s);\n\t\t\t\tfree_sock(sc, s);\n\t\t\t}\n\n\t\t\tpthread_rwlock_unlock(&sc->list_rwlock);\n\t\t}\n\n\t\t/* Unlocked during select */\n\t\tassert(maxfd < FD_SETSIZE);\n\n\t\tDPRINTF((\"RX: *** thread selecting on %d fds (socks: %s)\\n\",\n\t\t\t nrfd, poll_socks ? \"yes\" : \"no\"));\n\n\t\t/*\n\t\t * If we have pending_credit_updates then pass zero\n\t\t * timeout to poll the fds but don't block so we will\n\t\t * immediately handle whatever work we can, including\n\t\t * the pending credit updates.\n\t\t */\n\t\tnr = xselect(\"RX\", maxfd + 1, &rfd, NULL, NULL,\n\t\t\t    pending_credit_updates ? &zero_timeout : NULL);\n\t\tif (nr < 0) continue;\n\t\tDPRINTF((\"RX:\\nRX: *** %d/%d fds are readable (descs: %s)\\n\",\n\t\t\t nr, nrfd, vq_has_descs(vq) ? \"yes\" : \"no\"));\n\n\t\tif (FD_ISSET(sc->rx_wake_fd, &rfd)) {\n\t\t\t/* Eat the notification(s) */\n\t\t\tchar dummy[128];\n\t\t\tssize_t rd_dummy = read(sc->rx_wake_fd, &dummy, 128);\n\t\t\tassert(rd_dummy >= 1);\n\t\t\t/* Restart select now that we have some\n\t\t\t * descriptors. It's possible that synchronous\n\t\t\t * responses sent from the tx thread have\n\t\t\t * eaten them all though, so check.\n\t\t\t */\n\t\t\tDPRINTF((\"RX: thread got %zd kicks (have descs: %s)\\n\",\n\t\t\t\t rd_dummy, vq_has_descs(vq) ? \"yes\" : \"no\"));\n\n// XXX need to check sockets in order to process the reply ring, so\n// cannot make this tempting looking optimisation.\n//\n//\t\t\tif (nr == 1) {\n//\t\t\t\t /* Must have been the kicker fd, in\n//\t\t\t\t  * which case there is no point\n//\t\t\t\t  * checking the socks.\n//\t\t\t\t  */\n//\t\t\t\tDPRINTF((\"RX: Kicked w/ no other fds -- restarting select()\\n\"));\n//\t\t\t\tgoto rx_done;\n//\t\t\t}\n\n\t\t\t/* We might have some descriptors, so it might be worth polling the socks again */\n\t\t\tpoll_socks = true;\n\t\t}\n\n\t\tif (!vq_has_descs(vq)) {\n\t\t\tDPRINTF((\"RX: No descs -- restarting select()\\n\"));\n\t\t\tpoll_socks = false; /* Don't poll socks next time */\n\t\t\tgoto rx_done;\n\t\t}\n\n\t\twhile (did_some_work) {\n\t\t\tint nr_data_rx = 0;\n\t\t\tbool more_replies_pending = true; /* Assume there is */\n\t\t\tdid_some_work = false;\n\n\t\t\tDPRINTF((\"RX: Handling pending replies first\\n\"));\n\t\t\tpthread_mutex_lock(&sc->reply_mtx);\n\t\t\twhile (vq_has_descs(vq)) {\n\t\t\t\tmore_replies_pending = rx_do_one_reply(sc, vq);\n\t\t\t\tif (!more_replies_pending) break;\n\t\t\t\tdid_some_work = true;\n\t\t\t}\n\t\t\tpthread_mutex_unlock(&sc->reply_mtx);\n\n\t\t\tif (more_replies_pending) {\n\t\t\t\tDPRINTF((\"RX: No more descriptors for pending replies\\n\"));\n\t\t\t\tpoll_socks = false; /* Still replies to send, so don't handle socks yet */\n\t\t\t\tvq_endchains(vq, 1);\n\t\t\t\tgoto rx_done;\n\t\t\t}\n\n\t\t\tDPRINTF((\"RX: Checking all socks\\n\"));\n\n\t\t\tLIST_FOREACH_SAFE(s, &queue, rx_queue, ts) {\n\t\t\t\t/*\n\t\t\t\t * Check for new replies in the reply\n\t\t\t\t * ring frequently in order to avoid\n\t\t\t\t * possible deadlock due to filling\n\t\t\t\t * both vrings with data leaving no\n\t\t\t\t * space for replies. See \"Virtqueue\n\t\t\t\t * Flow Control\" in the spec.\n\t\t\t\t */\n\t\t\t\tif (nr_data_rx++ >= 8) {\n\t\t\t\t\tbool replies_pending;\n\t\t\t\t\tpthread_mutex_lock(&sc->reply_mtx);\n\t\t\t\t\treplies_pending = !REPLY_RING_EMPTY(sc);\n\t\t\t\t\tpthread_mutex_unlock(&sc->reply_mtx);\n\t\t\t\t\tif (replies_pending) break;\n\t\t\t\t}\n\n\t\t\t\tget_sock(s);\n\n\t\t\t\tif (s->state != SOCK_CONNECTED) {\n\t\t\t\t\tLIST_REMOVE(s, rx_queue);\n\t\t\t\t\tput_sock(s);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassert(s->fd >= 0);\n\n\t\t\t\tif (FD_ISSET(s->fd, &rfd)) {\n\t\t\t\t\tssize_t bytes;\n\t\t\t\t\tDPRINTF((\"RX: event on sock %p fd %d\\n\",\n\t\t\t\t\t\t (void *)s, s->fd));\n\t\t\t\t\tbytes = pci_vtsock_proc_rx(sc, vq, s);\n\t\t\t\t\tif (bytes == -1) {\n\t\t\t\t\t\t/* Consumed all descriptors, stop */\n\t\t\t\t\t\tDPRINTF((\"RX: No more descriptors\\n\"));\n\t\t\t\t\t\tvq_endchains(vq, 1);\n\t\t\t\t\t\tput_sock(s);\n\t\t\t\t\t\tgoto rx_done;\n\t\t\t\t\t} else if (bytes == 0) {\n\t\t\t\t\t\tLIST_REMOVE(s, rx_queue);\n\t\t\t\t\t\tFD_CLR(s->fd, &rfd);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdid_some_work = true;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * If proc_rx returned >= 0\n\t\t\t\t\t * then it is guaranteed to\n\t\t\t\t\t * have sent something and\n\t\t\t\t\t * thus a credit update is no\n\t\t\t\t\t * longer required. We have\n\t\t\t\t\t * handled the < 0 case above.\n\t\t\t\t\t */\n\t\t\t\t\tassert(s->credit_update_required == false);\n\t\t\t\t} else if (s->credit_update_required) {\n\t\t\t\t\tif (send_credit_update(vq, s)) {\n\t\t\t\t\t\ts->credit_update_required = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Consumed all descriptors, stop */\n\t\t\t\t\t\tDPRINTF((\"RX: No more descriptors\\n\"));\n\t\t\t\t\t\tvq_endchains(vq, 1);\n\t\t\t\t\t\tput_sock(s);\n\t\t\t\t\t\tgoto rx_done;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* Was nothing to do */\n\t\t\t\t\tLIST_REMOVE(s, rx_queue);\n\t\t\t\t}\n\n\t\t\t\tput_sock(s);\n\t\t\t}\n\t\t}\n\n\t\tDPRINTF((\"RX: All work complete\\n\"));\n\t\tvq_endchains(vq, 0);\n\t}\n}\n\n\nstatic void pci_vtsock_notify_rx(void *vsc, struct vqueue_info *vq)\n{\n\tstruct pci_vtsock_softc *sc = vsc;\n\n\tassert(vq == &sc->vssc_vqs[VTSOCK_QUEUE_RX]);\n\tassert(sc->rx_wake_fd >= 0);\n\n\tkick_rx(sc, \"notify\");\n}\n\nstatic void pci_vtsock_notify_evt(void *vsc, struct vqueue_info *vq)\n{\n\tstruct pci_vtsock_softc *sc = vsc;\n\n\tDPRINTF((\"vtsock: evt notify sc=%p vq=%zd(%p)\\n\",\n\t\t (void *)sc, vq - &sc->vssc_vqs[VTSOCK_QUEUE_RX], (void *)vq));\n}\n\nstatic int listen_un(struct sockaddr_un *un)\n{\n\tint fd, rc;\n\n\trc = unlink(un->sun_path);\n\tif (rc < 0 && errno != ENOENT) {\n\t\tperror(\"Failed to unlink unix socket path\");\n\t\treturn -1;\n\t}\n\n\tfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\tperror(\"Failed to open unix socket\");\n\t\treturn -1;\n\t}\n\n\trc = bind(fd, (struct sockaddr *)un, sizeof(*un));\n\tif (rc < 0) {\n\t\tperror(\"Failed to bind() unix socket\");\n\t\treturn -1;\n\t}\n\n\trc = listen(fd, SOMAXCONN);\n\tif (rc < 0) {\n\t\tperror(\"Failed to listen() unix socket\");\n\t\treturn -1;\n\t}\n\n\t/* XXX Any chown/chmod needed? */\n\n\trc = fcntl(fd, F_SETFL, O_NONBLOCK);\n\tif (rc < 0) {\n\t\tperror(\"O_NONBLOCK failed for unix socket\\n\");\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n\nstatic int open_connect_socket(struct pci_vtsock_softc *sc)\n{\n\tstruct sockaddr_un un;\n\tint fd, rc;\n\n\tassert(sc->connect_fd == -1);\n\n\tbzero(&un, sizeof(un));\n\n\tun.sun_len = 0; /* Unused? */\n\tun.sun_family = AF_UNIX;\n\trc = snprintf(un.sun_path, sizeof(un.sun_path),\n\t\t     \"%s/\"CONNECT_SOCKET_NAME, sc->path);\n\tif (rc < 0) {\n\t\tperror(\"Failed to format connect socket path\");\n\t\treturn 1;\n\t}\n\tDPRINTF((\"Connect socket is %s\\n\", un.sun_path));\n\n\tfd = listen_un(&un);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"failed to open connect socket\\n\");\n\t\treturn 1;\n\t}\n\n\tsc->connect_fd = fd;\n\tassert(sc->connect_fd < FD_SETSIZE);\n\n\tDPRINTF((\"Connect socket %s is fd %d\\n\", un.sun_path, fd));\n\n\treturn 0;\n}\n\nstatic int open_one_forward_socket(struct pci_vtsock_softc *sc, uint32_t port)\n{\n\tstruct sockaddr_un un, sl;\n\tstruct pci_vtsock_forward *fwd;\n\tint fd, rc;\n\n\tif (sc->nr_fwds == VTSOCK_MAXFWDS)  {\n\t\tfprintf(stderr, \"Too many forwards\\n\");\n\t\treturn 1;\n\t}\n\n\tfwd = &sc->fwds[sc->nr_fwds++];\n\tassert(fwd->listen_fd == -1);\n\n\tbzero(&un, sizeof(un));\n\n\tun.sun_len = 0; /* Unused? */\n\tun.sun_family = AF_UNIX;\n\trc = snprintf(un.sun_path, sizeof(un.sun_path),\n\t\t     \"%s/\"PRIaddr, sc->path, sc->vssc_cfg.guest_cid, port);\n\tif (rc < 0) {\n\t\tperror(\"Failed to format forward socket path\");\n\t\treturn 1;\n\t}\n\trc = snprintf(sl.sun_path, sizeof(sl.sun_path),\n\t\t     \"%s/guest.\"PRIport, sc->path, port);\n\tif (rc < 0) {\n\t\tperror(\"Failed to format forward socket symlink path\");\n\t\treturn 1;\n\t}\n\n\trc = unlink(sl.sun_path);\n\tif (rc < 0 && errno != ENOENT) {\n\t\tperror(\"Failed to unlink forward socket symlink path\");\n\t\treturn 1;\n\t}\n\n\tfd = listen_un(&un);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed to open forward socket\\n\");\n\t\treturn 1;\n\t}\n\n\trc = symlink(&un.sun_path[strlen(sc->path) + 1], sl.sun_path);\n\tif (rc < 0) {\n\t\tperror(\"Failed to create forward socket symlink\\n\");\n\t\tclose(fd);\n\t\treturn 1;\n\t}\n\n\tfwd->listen_fd = fd;\n\tassert(fwd->listen_fd < FD_SETSIZE);\n\n\tfwd->port = port;\n\n\tDPRINTF((\"forwarding port %\"PRId32\" to the guest\\n\", port));\n\n\treturn 0;\n}\n\nstatic int open_forward_sockets(struct pci_vtsock_softc *sc,\n\t\t\t\tchar *guest_forwards)\n{\n\tchar *s = guest_forwards, *e;\n\tint rc;\n\n\tif (!guest_forwards) return 0;\n\n\twhile (*s != '\\0') {\n\t\tunsigned long ul;\n\n\t\trc = 1;\n\t\terrno = 0;\n\t\tul = strtoul(s, &e, 0);\n\n\t\tif (errno) {\n\t\t\tfprintf(stderr, \"failed to parse forward \\\"%s\\\": %s\\n\",\n\t\t\t\ts, strerror(errno));\n\t\t\tgoto err;\n\t\t}\n\t\tif (ul >= UINT32_MAX) {\n\t\t\tfprintf(stderr, \"invalid guest port forward %ld\\n\", ul);\n\t\t\tgoto err;\n\t\t}\n\n\t\trc = open_one_forward_socket(sc, (uint32_t)ul);\n\t\tif (rc) goto err;\n\n\t\ts = e;\n\t\tif (*s == ';') s++;\n\t}\n\n\trc = 0;\nerr:\n\tfree(guest_forwards);\n\treturn rc;\n\n}\n\nstatic int pci_vtsock_cfgread(void *, int, int, uint32_t *);\nstatic int pci_vtsock_cfgwrite(void *, int, int, uint32_t);\n\nstatic char *\ncopy_up_to_comma(const char *from)\n{\n\tchar *comma = strchr(from, ',');\n\tchar *tmp = NULL;\n\tif (comma == NULL) {\n\t\ttmp = strdup(from); /* rest of string */\n\t} else {\n\t\tsize_t length = (size_t)(comma - from);\n\t\ttmp = strndup(from, length);\n\t}\n\treturn tmp;\n}\n\nstatic int\npci_vtsock_init(struct pci_devinst *pi, char *opts)\n{\n\tuint64_t guest_cid = VMADDR_CID_ANY;\n\tconst char *path = NULL;\n\tchar *guest_forwards = NULL;\n\tstruct pci_vtsock_softc *sc;\n\tstruct sockaddr_un un;\n\tint i, pipefds[2];\n\n\tif (opts == NULL) {\n\t\tprintf(\"virtio-sock: configuration required\\n\");\n\t\treturn (1);\n\t}\n\n\twhile (1) {\n\t\tchar *next;\n\t\tif (! opts)\n\t\t\tbreak;\n\t\tnext = strchr(opts, ',');\n\t\tif (next)\n\t\t\tnext[0] = '\\0';\n\t\tif (strncmp(opts, \"guest_cid=\", 10) == 0) {\n\t\t\tint tmp = atoi(&opts[10]);\n\t\t\tif (tmp <= 0) {\n\t\t\t\tfprintf(stderr, \"bad guest cid: %s\\r\\n\", opts);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tguest_cid = (uint32_t)tmp;\n\t\t} else if (strncmp(opts, \"path=\", 5) == 0) {\n\t\t\tpath = copy_up_to_comma(opts + 5);\n\t\t} else if (strncmp(opts, \"guest_forwards=\", 15) == 0) {\n\t\t\tguest_forwards = copy_up_to_comma(opts + 15);\n\t\t} else {\n\t\t\tfprintf(stderr, \"invalid option: %s\\r\\n\", opts);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (! next)\n\t\t\tbreak;\n\t\topts = &next[1];\n\t}\n\tif (guest_cid == VMADDR_CID_ANY || path == NULL) {\n\t\tfprintf(stderr, \"guest_cid and path options are both required.\\n\");\n\t\treturn 1;\n\t}\n\n\tif (guest_cid <= VMADDR_CID_HOST || guest_cid >= VMADDR_CID_MAX) {\n\t\tfprintf(stderr, \"invalid guest_cid \"PRIcid\"\\n\", guest_cid);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * We need to be able to construct socket paths of the form\n\t * \"%08x.%08x\" cid,port.\n\t */\n\tif (strlen(path) + sizeof(\"/00000000.00000000\") > sizeof(un.sun_path)) {\n\t\tprintf(\"virtio-sock: path too long\\n\");\n\t\treturn (1);\n\t}\n\n\t/* XXX confirm path exists and is a directory */\n\n\tfprintf(stderr, \"vsock init %d:%d = %s, guest_cid = \"PRIcid\"\\n\\r\",\n\t\tpi->pi_slot, pi->pi_func, path, guest_cid);\n\n\tsc = calloc(1, sizeof(struct pci_vtsock_softc));\n\n\tLIST_INIT(&sc->free_list);\n\tLIST_INIT(&sc->inuse_list);\n\n\tfor (i = 0; i < VTSOCK_MAXSOCKS; i++) {\n\t\tstruct pci_vtsock_sock *str = &sc->socks[i];\n\t\tint err = pthread_mutex_init(&str->mtx, NULL);\n\t\tassert(err == 0);\n\t\tstr->state = SOCK_FREE;\n\t\tstr->fd = -1;\n\t\tstr->port_generation = 0;\n\t\tLIST_INSERT_HEAD(&sc->free_list, str, list);\n\t}\n\n\tsc->nr_fwds = 0;\n\tfor (i = 0; i < VTSOCK_MAXFWDS; i++) {\n\t\tstruct pci_vtsock_forward *fwd = &sc->fwds[i];\n\t\tfwd->listen_fd = -1;\n\t}\n\n\tpthread_mutex_init(&sc->vssc_mtx, NULL);\n\tpthread_mutex_init(&sc->reply_mtx, NULL);\n\tpthread_rwlock_init(&sc->list_rwlock, NULL);\n\n\tsc->path = strdup(path);\n\n\t/* init virtio softc and virtqueues */\n\tvi_softc_linkup(&sc->vssc_vs, &vtsock_vi_consts, sc, pi, sc->vssc_vqs);\n\tsc->vssc_vs.vs_mtx = &sc->vssc_mtx;\n\n\tsc->vssc_vqs[VTSOCK_QUEUE_RX].vq_qsize = VTSOCK_RINGSZ;\n\tsc->vssc_vqs[VTSOCK_QUEUE_RX].vq_notify = pci_vtsock_notify_rx;\n\n\tsc->vssc_vqs[VTSOCK_QUEUE_TX].vq_qsize = VTSOCK_RINGSZ;\n\tsc->vssc_vqs[VTSOCK_QUEUE_TX].vq_notify = pci_vtsock_notify_tx;\n\n\t/* Unused, make it small */\n\tsc->vssc_vqs[VTSOCK_QUEUE_EVT].vq_qsize = 4;\n\tsc->vssc_vqs[VTSOCK_QUEUE_EVT].vq_notify = pci_vtsock_notify_evt;\n\n\t/* setup virtio sock config space */\n\tsc->vssc_cfg.guest_cid = guest_cid;\n\n\t/*\n\t * Should we move some of this into virtio.c?  Could\n\t * have the device, class, and subdev_0 as fields in\n\t * the virtio constants structure.\n\t */\n\tpci_set_cfgdata16(pi, PCIR_DEVICE, VIRTIO_DEV_SOCK);\n\tpci_set_cfgdata16(pi, PCIR_VENDOR, VIRTIO_VENDOR);\n\tpci_set_cfgdata8(pi, PCIR_REVID, 0 /*LEGACY 1*/);\n\tpci_set_cfgdata8(pi, PCIR_CLASS, PCIC_NETWORK);\n\tpci_set_cfgdata16(pi, PCIR_SUBDEV_0, VIRTIO_TYPE_SOCK);\n\tpci_set_cfgdata16(pi, PCIR_SUBVEND_0, VIRTIO_VENDOR);\n\n\tif (vi_intr_init(&sc->vssc_vs, 1, fbsdrun_virtio_msix()))\n\t\treturn (1);\n\tvi_set_io_bar(&sc->vssc_vs, 0);\n\n\tsc->connect_fd = -1;\n\tif (open_connect_socket(sc))\n\t\treturn (1);\n\n\tif (open_forward_sockets(sc, guest_forwards))\n\t\treturn (1);\n\n\tif (pipe(pipefds))\n\t\treturn (1);\n\tsc->tx_wake_fd = pipefds[0];\n\tsc->tx_kick_fd = pipefds[1];\n\n\tassert(sc->tx_wake_fd < FD_SETSIZE);\n\n\tsc->rx_kick_pending = false;\n\n\tif (pthread_create(&sc->tx_thread, NULL,\n\t\t\t   pci_vtsock_tx_thread, sc))\n\t\treturn (1);\n\n\tif (pipe(pipefds))\n\t\treturn (1);\n\tsc->rx_wake_fd = pipefds[0];\n\tsc->rx_kick_fd = pipefds[1];\n\n\tassert(sc->rx_wake_fd < FD_SETSIZE);\n\n\tsc->reply_prod = 0;\n\tsc->reply_cons = 0;\n\n\tif (pthread_create(&sc->rx_thread, NULL,\n\t\t\t   pci_vtsock_rx_thread, sc))\n\t\treturn (1);\n\n\treturn (0);\n}\n\nstatic int\npci_vtsock_cfgwrite(UNUSED void *vsc, int offset, UNUSED int size,\n\tUNUSED uint32_t value)\n{\n\tDPRINTF((\"vtsock: write to readonly reg %d\\n\\r\", offset));\n\treturn (1);\n}\n\nstatic int\npci_vtsock_cfgread(void *vsc, int offset, int size, uint32_t *retval)\n{\n\tstruct pci_vtsock_softc *sc = vsc;\n\tvoid *ptr;\n\n\tDPRINTF((\"vtsock: %d byte read pci reg %d\\n\\r\", size, offset));\n\n\t/* our caller has already verified offset and size */\n\tptr = (uint8_t *)&sc->vssc_cfg + offset;\n\tmemcpy(retval, ptr, size);\n\treturn (0);\n}\n\nstatic struct pci_devemu pci_de_vsock = {\n\t.pe_emu =\t\"virtio-sock\",\n\t.pe_init =\tpci_vtsock_init,\n\t.pe_barwrite =\tvi_pci_write,\n\t.pe_barread =\tvi_pci_read\n};\nPCI_EMUL_SET(pci_de_vsock);\n"], "fixing_code": ["/*-\n * Copyright (c) 2016 Docker, Inc.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer\n *    in this position and unchanged.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n/*\n * virtio vsock emulation based on v4 specification\n *    http://markmail.org/message/porhou5zv3wqjz6h\n * Tested against the Linux implementation at\n *    git@github.com:stefanha/linux.git#vsock @ 563d2a770dfa\n * Backported to v4.1.19:\n *    git cherry-pick -x 11aa9c2 f6a835b 4ef7ea9 8566b86 \\\n *                       ea3803c a9f9df1 1bb5b77 0c734eb \\\n *                       139bbcd 563d2a7\n */\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/uio.h>\n#include <sys/un.h>\n#include <sys/time.h>\n#include <sys/queue.h>\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <strings.h>\n#include <unistd.h>\n#include <errno.h>\n\n#include <xhyve/pci_emul.h>\n#include <xhyve/virtio.h>\n#include <xhyve/xhyve.h>\n\n#define VTSOCK_RINGSZ 256\n\n#define VTSOCK_QUEUE_RX\t\t0\n#define VTSOCK_QUEUE_TX\t\t1\n#define VTSOCK_QUEUE_EVT\t2\n#define VTSOCK_QUEUES\t\t3\n\n#define VTSOCK_MAXSEGS\t\t32\n\n#define VTSOCK_MAXSOCKS\t1024\n#define VTSOCK_MAXFWDS\t4\n\n/* Number of seconds to wait after sending an OP_SHUTDOWN flags == ALL before\n * we RST the connection ourselves.\n */\n#define SHUTDOWN_RST_DELAY\t30\n\n/*\n * Host capabilities\n */\n#define VTSOCK_S_HOSTCAPS 0\n#if 0\n\t(VIRTIO_RING_F_INDIRECT_DESC) /* indirect descriptors */\n#endif\n\n/*\n * Config space \"registers\"\n */\nstruct vtsock_config {\n\tuint64_t guest_cid;\n} __packed;\n\n/*\n * Fixed-size block header\n */\n\nstruct virtio_sock_hdr {\n\tuint64_t src_cid;\n\tuint64_t dst_cid;\n\tuint32_t src_port;\n\tuint32_t dst_port;\n\tuint32_t len;\n#define VIRTIO_VSOCK_TYPE_STREAM 1\n\tuint16_t type;\n#define VIRTIO_VSOCK_OP_INVALID 0\n\t/* Connect operations */\n#define VIRTIO_VSOCK_OP_REQUEST 1\n#define VIRTIO_VSOCK_OP_RESPONSE 2\n#define VIRTIO_VSOCK_OP_RST 3\n#define VIRTIO_VSOCK_OP_SHUTDOWN 4\n\t/* To send payload */\n#define VIRTIO_VSOCK_OP_RW 5\n\t/* Tell the peer our credit info */\n#define VIRTIO_VSOCK_OP_CREDIT_UPDATE 6\n\t/* Request the peer to send the credit info to us */\n#define VIRTIO_VSOCK_OP_CREDIT_REQUEST 7\n\tuint16_t op;\n\tuint32_t flags;\n#define VIRTIO_VSOCK_FLAG_SHUTDOWN_RX (1U<<0) /* Peer will not receive any more data */\n#define VIRTIO_VSOCK_FLAG_SHUTDOWN_TX (1U<<1) /* Peer will not transmit any more data */\n#define VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL (VIRTIO_VSOCK_FLAG_SHUTDOWN_RX|VIRTIO_VSOCK_FLAG_SHUTDOWN_TX)\n\tuint32_t buf_alloc;\n\tuint32_t fwd_cnt;\n} __packed;\n\n/*\n * Debug printf\n */\nstatic int pci_vtsock_debug = 0;\n#define DPRINTF(params) do { if (pci_vtsock_debug) { printf params; fflush(stdout); } } while(0)\n/* Protocol logging */\n#define PPRINTF(params) do { if (0) { printf params;  fflush(stdout); } } while(0)\n\n/* XXX need to use rx and tx more consistently */\n\nstruct vsock_addr {\n\tuint64_t cid;\n\tuint32_t port;\n};\n#define PRIcid \"%08\"PRIx64\n#define PRIport \"%08\"PRIx32\n\n#define SCNcid \"%08\"SCNx64\n#define SCNport \"%08\"SCNx32\n#define SCNaddr SCNcid \".\" SCNport\n\n#ifdef PRI_ADDR_PREFIX\n#define PRIaddr PRI_ADDR_PREFIX PRIcid \".\" PRIport\n#else\n#define PRIaddr PRIcid \".\" PRIport\n#endif\n\n#ifndef CONNECT_SOCKET_NAME\n#define CONNECT_SOCKET_NAME \"connect\"\n#endif\n\n#define FMTADDR(a) a.cid, a.port\n\n#define WRITE_BUF_LENGTH (128*1024)\n\nstruct pci_vtsock_sock {\n\tpthread_mutex_t mtx;\n\n\t/* Either on softc->free_list or softc->inuse_list */\n\tLIST_ENTRY(pci_vtsock_sock) list;\n\n\t/* For tx and rx thread local use respectively */\n\tLIST_ENTRY(pci_vtsock_sock) tx_queue;\n\tLIST_ENTRY(pci_vtsock_sock) rx_queue;\n\n\t/*\n\t * To allocate a sock:\n\t *\n\t *   Take list_rwlock for writing\n\t *\n\t *     Grab a sock from head of free_list\n\t *\n\t *     If a FREE sock is found take its lock before removing it\n\t *     from the list and setting its state to CONNECTING.\n\t *\n\t *     Add the sock to inuse_list.\n\t *\n\t *   Drop list_rwlock\n\t *\n\t * To free a sock:\n\t *\n\t *   Set state to CLOSING_TX and kick the tx thread[*].\n\t *\n\t * Then the following will happen:\n\t *\n\t * ,-TX thread:\n\t * |\n\t * | The TX loop will take list_rwlock for reading (as part of\n\t * | its normal start of loop processing) and:\n\t * |\n\t * |   Take the socket's lock and discover state == CLOSING_TX\n\t * |\n\t * |   Set state == CLOSING_RX\n\t * |\n\t * |   Note that an RX kick is needed\n\t * |\n         * | Release list_rwlock\n\t * |\n\t * `-Kick the rx thread if required\n\t *\n\t * ,-RX thread:\n\t * |\n\t * | The RX loop will take list_rwlock for reading (as part of\n\t * | its normal start of loop processing) and:\n\t * |\n\t * |   Take the socket's lock and discover state == CLOSING_RX\n\t * |\n\t * |   Put the socket on a local \"to be closed\" queue\n\t * |\n         * | Release list_rwlock\n\t * |\n\t * | If there a sockets to be closed, take list_rwlock for\n\t * | writing, and for each socket:\n\t * |\n\t * |   close the fd, set state == FREE\n\t * |\n\t * |   remove socket from inuse_list, add to free_list\n\t * |\n\t * |   drop the socket's lock\n\t * |\n\t * `-Drop list_rwlock\n\t *\n\t * [*] Callers in the TX loop (only) may when closing a socket\n\t * choose to skip the initial CLOSING_TX state (which exists\n\t * only to ensure that the fd is not current in the tx select,\n\t * which it cannot be if the TX thread is doing the close) and\n\t * go straight to CLOSING_RX kicking the rx thread instead. If\n\t * the close is initiated by the RX thread (or anywhere else)\n\t * then it must go through the full\n\t * CLOSING_TX->CLOSING_RX->FREE path.\n\t */\n\tenum {\n\t\tSOCK_FREE, /* Initial state */\n\t\tSOCK_CONNECTING,\n\t\tSOCK_CONNECTED,\n\t\tSOCK_CLOSING_TX,\n\t\tSOCK_CLOSING_RX,\n\t} state;\n\t/* fd is:\n\t *   >= 0\tWhen state == CONNECTED,\n\t *     -1\tOtherwise\n\t */\n\tint fd;\n\tuint16_t port_generation;\n\t/* valid when SOCK_CONNECTED only */\n\tuint32_t local_shutdown, peer_shutdown;\n\ttime_t rst_deadline; /* When local_shutdown==ALL, expect RST before */\n\n\tstruct vsock_addr local_addr;\n\tstruct vsock_addr peer_addr;\n\n\tuint32_t buf_alloc;\n\tuint32_t fwd_cnt;\n\n\tbool credit_update_required;\n\tuint32_t rx_cnt; /* Amount we have sent to the peer */\n\tuint32_t peer_buf_alloc; /* From the peer */\n\tuint32_t peer_fwd_cnt; /* From the peer */\n\n\t/* Write buffer. We do not update fwd_cnt until we drain the _whole_ buffer */\n\tuint8_t write_buf[WRITE_BUF_LENGTH];\n\tunsigned int write_buf_head, write_buf_tail;\n};\n\nstruct pci_vtsock_forward {\n\tint listen_fd;\n\tuint32_t port;\n};\n\n/*\n * Per-device softc\n */\n/*\n * Lock order (outer most first): XXX more thought needed.\n *\n *   vssc_mtx is taken by the core and is often held during callbacks\n *   (e.g. it is held during a vq_notify or pci cfg access). It\n *   protects virtio resources.\n *\n *   list_rwlock, protects free and inuse lists (rdlock for traversal)\n *\n *   sock->mtx protects the contents of the sock struct, including the\n *   state.\n *\n *   reply_mtx protects reply_{ring,prod,cons}\n */\nLIST_HEAD(sock_list_head, pci_vtsock_sock);\nstruct pci_vtsock_softc {\n\tstruct virtio_softc vssc_vs;\n\tpthread_mutex_t vssc_mtx;\n\tchar *path;\n\tstruct vqueue_info vssc_vqs[VTSOCK_QUEUES];\n\tstruct vtsock_config vssc_cfg;\n\n\t/* list_mtx protects free_list and inuse_list heads */\n\tpthread_rwlock_t list_rwlock;\n\tstruct sock_list_head free_list, inuse_list;\n\tstruct pci_vtsock_sock socks[VTSOCK_MAXSOCKS];\n\n\tstruct pci_vtsock_forward fwds[VTSOCK_MAXFWDS];\n\tint nr_fwds;\n\n\tpthread_t tx_thread;\n\tint tx_kick_fd, tx_wake_fd; /* Write to kick, select on wake */\n\tbool rx_kick_pending;\n\tint connect_fd; /* */\n\n\tpthread_t rx_thread;\n\tint rx_kick_fd, rx_wake_fd; /* Write to kick, select on wake */\n\n\tpthread_mutex_t reply_mtx;\n#define VTSOCK_REPLYRINGSZ (2*VTSOCK_RINGSZ)\n\tstruct virtio_sock_hdr reply_ring[VTSOCK_REPLYRINGSZ];\n\tint reply_prod, reply_cons;\n\t/*\n\t * If reply_prod == reply_cons then the ring is empty,\n\t * otherwise there is data in it.\n\t *\n\t * If the ring is not empty then there MUST always be a 1 slot\n\t * buffer between the producer and the consumer pointers\n\t * (i.e. the ring size is effectively one less than expected).\n\t *\n\t * If this invariant is violated and we consume the final free\n\t * slot then reply_prod would have caught up to reply_cons and\n\t * the ring would be considered empty rather than\n\t * full. Therefore we consider the ring full when:\n\t *\n\t *    (reply_prod + 1) % VTSOCK_REPLYRINGSZ == reply_cons.\n\t */\n#define REPLY_RING_EMPTY(sc) (sc->reply_cons == sc->reply_prod)\n//#define REPLY_RING_FULL(sc) ((sc->reply_prod + 1) % VTSOCK_REPLYRINGSZ == sc->reply_cons)\n};\n\n\n/* Protocol stuff */\n\n/* Reserved CIDs */\n#define VMADDR_CID_ANY (uint64_t) -1U\n//#define VMADDR_CID_HYPERVISOR 0\n//#define VMADDR_CID_RESERVED 1\n#define VMADDR_CID_HOST 2\n\n#define VMADDR_CID_MAX UINT32_MAX /* Athough CID's are 64-bit in the protocol, we only support 32-bits */\n\nstatic void pci_vtsock_reset(void *);\nstatic void pci_vtsock_notify_tx(void *, struct vqueue_info *);\nstatic void pci_vtsock_notify_rx(void *, struct vqueue_info *);\nstatic int pci_vtsock_cfgread(void *, int, int, uint32_t *);\nstatic int pci_vtsock_cfgwrite(void *, int, int, uint32_t);\nstatic void *pci_vtsock_rx_thread(void *vssc);\n\nstatic bool sock_is_buffering(struct pci_vtsock_sock *sock);\n\nstatic struct virtio_consts vtsock_vi_consts = {\n\t\"vtsock\", /* our name */\n\tVTSOCK_QUEUES,\n\tsizeof(struct vtsock_config), /* config reg size */\n\tpci_vtsock_reset, /* reset */\n\tNULL, /* no device-wide qnotify */\n\tpci_vtsock_cfgread, /* read PCI config */\n\tpci_vtsock_cfgwrite, /* write PCI config */\n\tNULL, /* apply negotiated features */\n\tVTSOCK_S_HOSTCAPS, /* our capabilities */\n};\n\nstatic void pci_vtsock_reset(void *vsc)\n{\n\tstruct pci_vtsock_softc *sc = vsc;\n\n\tDPRINTF((\"vtsock: device reset requested !\\n\"));\n\tvi_reset_dev(&sc->vssc_vs);\n\t/* XXX TODO: close/reset all socks */\n}\n\nstatic const char * const opnames[] = {\n\t[VIRTIO_VSOCK_OP_INVALID] = \"INVALID\",\n\t[VIRTIO_VSOCK_OP_REQUEST] = \"REQUEST\",\n\t[VIRTIO_VSOCK_OP_RESPONSE] = \"RESPONSE\",\n\t[VIRTIO_VSOCK_OP_RST] = \"RST\",\n\t[VIRTIO_VSOCK_OP_SHUTDOWN] = \"SHUTDOWN\",\n\t[VIRTIO_VSOCK_OP_RW] = \"RW\",\n\t[VIRTIO_VSOCK_OP_CREDIT_UPDATE] = \"CREDIT_UPDATE\",\n\t[VIRTIO_VSOCK_OP_CREDIT_REQUEST] = \"CREDIT_REQUEST\"\n};\n\nstatic int max_fd(int a, int b)\n{\n\tif (a > b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\n/*\n * Returns >= 0 number of fds on success or -1 to indicate caller\n * should retry. On any failure which cannot be retried logs and exits.\n */\nstatic int xselect(const char *ctx,\n\t\t   int nfds, fd_set *readfds, fd_set *writefds,\n\t\t   fd_set *errorfds, struct timeval *timeout)\n{\n\tint rc = select(nfds, readfds, writefds, errorfds, timeout);\n\tif (rc >= 0) return rc;\n\n\t/*\n\t * http://pubs.opengroup.org/onlinepubs/009695399/functions/select.html\n\t * lists EINTR, EBADF and EINVAL. EINTR is recoverable and should be\n\t * retried.\n\t */\n\tif (errno == EINTR) return -1;\n\t/*\n\t * OSX select(2) man page lists EAGAIN in addition to the above.\n\t * EAGAIN should be retried.\n\t*/\n\tif (errno == EAGAIN) return -1;\n\n\tfprintf(stderr, \"%s: select() failed %d: %s\\n\",\n\t\tctx, errno, strerror(errno));\n\tabort();\n}\n\nstatic size_t iovec_clip(struct iovec **iov, int *iov_len, size_t bytes)\n{\n\tsize_t ret = 0;\n\tint i;\n\tfor (i = 0; i < *iov_len && ret < bytes; i++) {\n\t\tif ((bytes-ret) < (*iov)[i].iov_len)\n\t\t\t(*iov)[i].iov_len = bytes - ret;\n\t\tret += (*iov)[i].iov_len;\n\t}\n\t*iov_len = i;\n\treturn ret;\n}\n\n/* Pulls @bytes from @iov into @buf. @buf can be NULL, in which case this just discards @bytes */\nstatic size_t iovec_pull(struct iovec **iov, int *iov_len, void *buf, size_t bytes)\n{\n\tsize_t res = 0;\n\n\t//DPRINTF((\"iovec_pull %zd bytes into %p. iov=%p, iov_len=%d\\n\",\n\t//\t bytes, (void *)buf, (void *)*iov, *iov_len));\n\n\twhile (res < bytes && *iov_len) {\n\t\tsize_t c = (bytes - res) < (*iov)[0].iov_len ? (bytes - res) : (*iov)[0].iov_len;\n\n\t\t//DPRINTF((\"Copy %zd/%zd bytes from base=%p to buf=%p\\n\",\n\t\t//\t c, (*iov)[0].iov_len, (void*)(*iov)[0].iov_base, (void*)buf));\n\n\t\tif (buf) memcpy(buf, (*iov)[0].iov_base, c);\n\n\t\t(*iov)[0].iov_len -= c;\n\t\t(*iov)[0].iov_base = (char *)(*iov)[0].iov_base + c;\n\n\t\t//DPRINTF((\"iov %p is now %zd bytes at %p\\n\", (void *)*iov,\n\t\t//\t (*iov)[0].iov_len, (void *)(*iov)[0].iov_base));\n\n\t\tif ((*iov)[0].iov_len == 0) {\n\t\t\t(*iov)++;\n\t\t\t(*iov_len)--;\n\t\t\t//DPRINTF((\"iov elem consumed, now iov=%p, iov_len=%d\\n\", (void *)*iov, *iov_len));\n\t\t}\n\n\t\tif (buf) buf = (char *)buf + c;\n\t\t//DPRINTF((\"buf now %p\\n\", (void *)buf));\n\n\t\tres += c;\n\t}\n\t//DPRINTF((\"iovec_pull pulled %zd/%zd bytes\\n\", res, bytes));\n\n\treturn res;\n}\n\nstatic size_t iovec_push(struct iovec **iov, int *iov_len, void *buf, size_t bytes)\n{\n\tsize_t res = 0;\n\n\t//DPRINTF((\"iovec_push %zd bytes from %p. iov=%p, iov_len=%d\\n\",\n\t//\t bytes, (void *)buf, (void *)*iov, *iov_len));\n\n\twhile (res < bytes && *iov_len) {\n\t\tsize_t c = (bytes - res) < (*iov)[0].iov_len ? (bytes - res) : (*iov)[0].iov_len;\n\n\t\t//DPRINTF((\"Copy %zd/%zd bytes from buf=%p to base=%p\\n\",\n\t\t//\t c, (*iov)[0].iov_len, (void *)buf, (void *)(*iov)[0].iov_base));\n\n\t\tmemcpy((*iov)[0].iov_base, buf, c);\n\n\t\t(*iov)[0].iov_len -= c;\n\t\t(*iov)[0].iov_base = (char *)(*iov)[0].iov_base + c;\n\n\t\t//DPRINTF((\"iov %p is now %zd bytes at %p\\n\", (void *)*iov,\n\t\t//\t (*iov)[0].iov_len, (void *)(*iov)[0].iov_base));\n\n\t\tif ((*iov)[0].iov_len == 0) {\n\t\t\t(*iov)++;\n\t\t\t(*iov_len)--;\n\t\t\t//DPRINTF((\"iov elem consumed, now iov=%p, iov_len=%d\\n\", (void *)*iov, *iov_len));\n\t\t}\n\n\t\tbuf = (char *)buf + c;\n\t\t//DPRINTF((\"buf now %p\\n\", (void *)buf));\n\n\t\tres += c;\n\t}\n\n\treturn res;\n}\n\nstatic void dprint_iovec(struct iovec *iov, int iovec_len, const char *ctx)\n{\n\tint i;\n\tif (!pci_vtsock_debug) return;\n\tDPRINTF((\"%s: IOV:%p ELEMS:%d\\n\", ctx, (void *)iov, iovec_len));\n\tfor (i = 0; i < iovec_len; i++)\n\t\tDPRINTF((\"%s:  %d = %zu @ %p\\n\",\n\t\t\t ctx, i, iov[i].iov_len, (void *)iov[i].iov_base));\n}\n\nstatic void dprint_chain(struct iovec *iov, int iovec_len, const char *ctx)\n{\n\tint i;\n\tif (!pci_vtsock_debug) return;\n\tDPRINTF((\"%s: CHAIN:%p ELEMS:%d\\n\", ctx, (void *)iov, iovec_len));\n\tfor (i = 0; i < iovec_len; i++)\n\t\tDPRINTF((\"%s:  %d = %zu @ %p\\n\",\n\t\t\t ctx, i, iov[i].iov_len, (void *)iov[i].iov_base));\n}\n\n\nstatic void dprint_header(struct virtio_sock_hdr *hdr, bool tx, const char *ctx)\n{\n\tif (!pci_vtsock_debug) return;\n\tassert(hdr->op < nitems(opnames));\n\n\tDPRINTF((\"%s: %sSRC:\"PRIaddr\" DST:\"PRIaddr\"\\n\",\n\t\t ctx, tx ? \"<=\" : \"=>\",\n\t\t hdr->src_cid, hdr->src_port, hdr->dst_cid, hdr->dst_port));\n\tDPRINTF((\"%s:   LEN:%08\"PRIx32\" TYPE:%04\"PRIx16\" OP:%\"PRId16\"=%s\\n\",\n\t\t ctx, hdr->len, hdr->type, hdr->op,\n\t\t opnames[hdr->op] ? opnames[hdr->op] : \"<unknown>\"));\n\tDPRINTF((\"%s:  FLAGS:%08\"PRIx32\" BUF_ALLOC:%08\"PRIx32\" FWD_CNT:%08\"PRIx32\"\\n\",\n\t\t ctx, hdr->flags, hdr->buf_alloc, hdr->fwd_cnt));\n}\n\nstatic void put_sock(struct pci_vtsock_sock *s)\n{\n\tint err = pthread_mutex_unlock(&s->mtx);\n\tassert(err == 0);\n}\n\nstatic struct pci_vtsock_sock *get_sock(struct pci_vtsock_sock *s)\n{\n\tint err = pthread_mutex_lock(&s->mtx);\n\tassert(err == 0);\n\treturn s;\n}\n\n/* Returns a locked sock */\nstatic struct pci_vtsock_sock *lookup_sock(struct pci_vtsock_softc *sc,\n\t\t\t\t\t   uint16_t type,\n\t\t\t\t\t   struct vsock_addr local_addr,\n\t\t\t\t\t   struct vsock_addr peer_addr)\n{\n\tstruct pci_vtsock_sock *s;\n\n\tassert(type == VIRTIO_VSOCK_TYPE_STREAM);\n\n\tpthread_rwlock_rdlock(&sc->list_rwlock);\n\tLIST_FOREACH(s, &sc->inuse_list, list) {\n\t\tget_sock(s);\n\n\t\tif ((s->state == SOCK_CONNECTED || s->state == SOCK_CONNECTING) &&\n\t\t    s->peer_addr.cid == peer_addr.cid &&\n\t\t    s->peer_addr.port == peer_addr.port &&\n\t\t    s->local_addr.cid == local_addr.cid &&\n\t\t    s->local_addr.port == local_addr.port) {\n\t\t\tgoto found;\n\t\t}\n\n\t\tput_sock(s);\n\t}\n\n\ts = NULL;\n\nfound:\n\tpthread_rwlock_unlock(&sc->list_rwlock);\n\treturn s;\n}\n\n\n/* Returns NULL on failure or a locked socket on success */\nstatic struct pci_vtsock_sock *alloc_sock(struct pci_vtsock_softc *sc)\n{\n\tstruct pci_vtsock_sock *s;\n\n\tpthread_rwlock_wrlock(&sc->list_rwlock);\n\ts = LIST_FIRST(&sc->free_list);\n\tif (s) {\n\t\tget_sock(s);\n\t\tLIST_REMOVE(s, list);\n\t\tLIST_INSERT_HEAD(&sc->inuse_list, s, list);\n\t\ts->state = SOCK_CONNECTING;\n\t}\n\tpthread_rwlock_unlock(&sc->list_rwlock);\n\n\tif (!s) return NULL;\n\n\ts->buf_alloc = WRITE_BUF_LENGTH;\n\ts->fwd_cnt = 0;\n\n\ts->peer_buf_alloc = 0;\n\ts->peer_fwd_cnt = 0;\n\ts->rx_cnt = 0;\n\ts->credit_update_required = false;\n\n\ts->local_shutdown = 0;\n\ts->peer_shutdown = 0;\n\n\ts->write_buf_head = s->write_buf_tail = 0;\n\n\treturn s;\n}\n\n/* Caller must hold sc->list_rwlock AND s->lock. This function will\n * free s and release s->lock but not sc->list_rwlock\n */\nstatic void free_sock(struct pci_vtsock_softc *sc, struct pci_vtsock_sock *s)\n{\n\tLIST_REMOVE(s, list);\n\ts->state = SOCK_FREE;\n\n\tLIST_INSERT_HEAD(&sc->free_list, s, list);\n\n\tput_sock(s);\n}\n\nstatic int set_socket_options(struct pci_vtsock_sock *s)\n{\n\tint rc, buf_alloc = (int)s->buf_alloc;\n\tsocklen_t opt_len;\n\n\trc = setsockopt(s->fd, SOL_SOCKET, SO_SNDBUF,\n\t\t\t&buf_alloc, sizeof(buf_alloc));\n\tif ( rc < 0 ) {\n\t\tDPRINTF((\"Failed to set SO_SNDBUF on fd %d: %s\\n\",\n\t\t\t s->fd, strerror(errno)));\n\t\treturn rc;\n\t}\n\n\trc = setsockopt(s->fd, SOL_SOCKET, SO_RCVBUF,\n\t\t\t&buf_alloc, sizeof(buf_alloc));\n\tif ( rc < 0 ) {\n\t\tDPRINTF((\"Failed to set SO_RCVBUF on fd %d: %s\\n\",\n\t\t\t s->fd, strerror(errno)));\n\t\treturn rc;\n\t}\n\n\topt_len = sizeof(buf_alloc);\n\trc = getsockopt(s->fd, SOL_SOCKET, SO_SNDBUF,\n\t\t\t&buf_alloc, &opt_len);\n\tif ( rc < 0 ) {\n\t\tDPRINTF((\"Failed to get SO_SNDBUF on fd %d: %s\\n\",\n\t\t\t s->fd, strerror(errno)));\n\t\treturn rc;\n\t}\n\t/* If we didn't get what we asked for then expose this to the other end */\n\tif (buf_alloc < (int)s->buf_alloc) {\n\t\tPPRINTF((\"fd %d SO_SNDBUF is 0x%x not 0x%x as requested, clamping\\n\",\n\t\t\t s->fd, buf_alloc, s->buf_alloc));\n\t\ts->buf_alloc = (uint32_t)buf_alloc;\n\t}\n\n\treturn 0;\n}\n\n\n/* On success the socket returned will be locked, the caller is\n * responsible for calling put_sock() on it.\n */\nstatic struct pci_vtsock_sock *connect_sock(struct pci_vtsock_softc *sc,\n\t\t\t\t\t    struct vsock_addr local_addr,\n\t\t\t\t\t    struct vsock_addr peer_addr,\n\t\t\t\t\t    uint32_t peer_buf_alloc,\n\t\t\t\t\t    uint32_t peer_fwd_cnt)\n{\n\tstruct pci_vtsock_sock *s;\n\tstruct sockaddr_un un;\n\tint rc, fd = -1;\n\n\ts = alloc_sock(sc);\n\tif (s == NULL) {\n\t\tDPRINTF((\"TX: No available socks\\n\"));\n\t\tgoto err;\n\t}\n\n\tDPRINTF((\"TX: Assigned sock %ld at %p\\n\",\n\t\t s - &sc->socks[0], (void *)s));\n\n\tbzero(&un, sizeof(un));\n\n\tun.sun_len = 0; /* Unused? */\n\tun.sun_family = AF_UNIX;\n\trc = snprintf(un.sun_path, sizeof(un.sun_path),\n\t\t     \"%s/\"PRIaddr, sc->path, FMTADDR(local_addr));\n\tif (rc < 0) {\n\t\tDPRINTF((\"TX: Failed to format socket path\\n\"));\n\t\tgoto err;\n\t}\n\n\tfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\tDPRINTF((\"TX: socket failed for %s: %s\\n\",\n\t\t\t un.sun_path, strerror(errno)));\n\t\tgoto err;\n\t}\n\n\tif (fd >= FD_SETSIZE) {\n\t\tDPRINTF((\"TX: socket fd %d > FD_SETSIZE %d\\n\", fd, FD_SETSIZE));\n\t\tgoto err;\n\t}\n\n\trc = connect(fd, (struct sockaddr *)&un, sizeof(un));\n\tif (rc < 0) {\n\t\tDPRINTF((\"TX: connect failed for %s: %s\\n\",\n\t\t\t un.sun_path, strerror(errno)));\n\t\tgoto err;\n\t}\n\n\trc = fcntl(fd, F_SETFL, O_NONBLOCK);\n\tif (rc < 0) {\n\t\tDPRINTF((\"TX: O_NONBLOCK failed for %s: %s\\n\",\n\t\t\t un.sun_path, strerror(errno)));\n\t\tgoto err;\n\t}\n\n\tDPRINTF((\"TX: Socket path %s opened on fd %d\\n\", un.sun_path, fd));\n\n\ts->fd = fd;\n\ts->peer_addr = peer_addr;\n\ts->local_addr = local_addr;\n\n\ts->peer_buf_alloc = peer_buf_alloc;\n\ts->peer_fwd_cnt = peer_fwd_cnt;\n\n\trc = set_socket_options(s);\n\tif (rc < 0) goto err;\n\n\tPPRINTF((\"TX: SOCK connected (%d) \"PRIaddr\" <=> \"PRIaddr\"\\n\",\n\t\t s->fd, FMTADDR(s->local_addr), FMTADDR(s->peer_addr)));\n\ts->state = SOCK_CONNECTED;\n\n\treturn s;\n\nerr:\n\tif (fd >= 0) close(fd);\n\tif (s) {\n\t\tpthread_rwlock_wrlock(&sc->list_rwlock);\n\t\tfree_sock(sc, s);\n\t\tpthread_rwlock_unlock(&sc->list_rwlock);\n\t}\n\treturn NULL;\n}\n\nstatic void kick_rx(struct pci_vtsock_softc *sc, const char *why)\n{\n\tchar dummy;\n\tssize_t nr;\n\tsc->rx_kick_pending = false;\n\tnr = write(sc->rx_kick_fd, &dummy, 1);\n\tassert(nr == 1);\n\tDPRINTF((\"RX: kicked rx thread: %s\\n\", why));\n}\n\nstatic void kick_tx(struct pci_vtsock_softc *sc, const char *why)\n{\n\tchar dummy;\n\tssize_t nr;\n\tnr = write(sc->tx_kick_fd, &dummy, 1);\n\tassert(nr == 1);\n\tDPRINTF((\"TX: kicked tx thread: %s\\n\", why));\n}\n\n/* Reflect peer_shutdown into local fd */\nstatic void shutdown_peer_local_fd(struct pci_vtsock_sock *s, uint32_t mode,\n\t\t\t\t       const char *ctx)\n{\n\tint rc;\n\tint how;\n\tconst char *how_str;\n\tuint32_t new = mode | s->peer_shutdown;\n\tuint32_t set = s->peer_shutdown ^ new;\n\tuint32_t new_local = s->local_shutdown;\n\n\tassert((mode & ~VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL) == 0);\n\tassert(mode != 0);\n\n\tDPRINTF((\"%s: PEER CUR %\"PRIx32\", MODE %\"PRIx32\", NEW %\"PRIx32\", SET %\"PRIx32\"\\n\",\n\t\t ctx, s->peer_shutdown, mode, new, set));\n\n\tswitch (set) {\n\tcase 0:\n\t\treturn;\n\tcase VIRTIO_VSOCK_FLAG_SHUTDOWN_TX:\n\t\tif (sock_is_buffering(s))\n\t\t{\n\t\t\tPPRINTF((\"%s: fd: %d SHUT_WR while buffering, deferring local shutdown\\n\", ctx, s->fd));\n\t\t\thow = 0;\n\t\t\thow_str = \"none\";\n\t\t} else  {\n\t\t\thow = SHUT_WR;\n\t\t\thow_str = \"SHUT_WR\";\n\t\t\tnew_local |= VIRTIO_VSOCK_FLAG_SHUTDOWN_RX;\n\t\t}\n\t\tbreak;\n\tcase VIRTIO_VSOCK_FLAG_SHUTDOWN_RX:\n\t\thow = SHUT_RD;\n\t\thow_str = \"SHUT_RD\";\n\t\tnew_local = s->local_shutdown | VIRTIO_VSOCK_FLAG_SHUTDOWN_TX;\n\t\tbreak;\n\tcase VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL:\n\t\tif (sock_is_buffering(s)) {\n\t\t\tPPRINTF((\"%s: fd: %d SHUT_RDWR while buffering, deferring local SHUT_WR\\n\", ctx, s->fd));\n\t\t\thow = SHUT_RD;\n\t\t\thow_str = \"SHUT_RD\";\n\t\t\tnew_local |= VIRTIO_VSOCK_FLAG_SHUTDOWN_TX;\n\t\t} else {\n\t\t\thow = SHUT_RDWR;\n\t\t\thow_str = \"SHUT_RDWR\";\n\t\t\tnew_local |= VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t}\n\n\tif (how) {\n\t\trc = shutdown(s->fd, how);\n\t\tDPRINTF((\"%s: shutdown_peer: shutdown(%d, %s)\\n\", ctx, s->fd, how_str));\n\t\tif (rc < 0 && errno != ENOTCONN) {\n\t\t\tDPRINTF((\"%s: shutdown(%d, %s) for peer shutdown failed: %s\\n\",\n\t\t\t\t ctx, s->fd, how_str, strerror(errno)));\n\t\t\tabort();\n\t\t}\n\t}\n\n\ts->local_shutdown = new_local;\n\ts->peer_shutdown = new;\n}\n\n/* The caller must have sent something (probably OP_RST, but perhaps\n * OP_SHUTDOWN) to the peer already.\n */\nstatic void close_sock(struct pci_vtsock_softc *sc,  struct pci_vtsock_sock *s,\n\t\t       const char *ctx)\n{\n\tif (!s) return;\n\tDPRINTF((\"%s: Closing sock %p\\n\", ctx, (void *)s));\n\n\tshutdown_peer_local_fd(s, VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL, ctx);\n\n\ts->state = SOCK_CLOSING_TX;\n\tkick_tx(sc, \"sock closed\");\n}\n\n/*\n * Caller should send OP_SHUTDOWN with flags == s->local_shutdown after calling this.\n */\nstatic void shutdown_local_sock(const char *ctx,\n\t\t\t\tstruct pci_vtsock_sock *s,\n\t\t\t\tuint32_t mode)\n{\n\tuint32_t new, set;\n\n\tassert((mode & ~VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL) == 0);\n\n\tif (s->state != SOCK_CONNECTED) return;\n\n\tassert(s->local_shutdown != VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL);\n\n\tDPRINTF((\"%s: fd %d: LOCAL SHUTDOWN 0x%\"PRIx32\" (0x%\"PRIx32\")\\n\",\n\t\t ctx, s->fd, mode, s->peer_shutdown));\n\n\tnew = mode | s->local_shutdown;\n\tset = s->local_shutdown ^ new;\n\ts->local_shutdown = new;\n\n\tDPRINTF((\"%s: setting 0x%\"PRIx32\" mode is now 0x%\"PRIx32\" (peer 0x%\"PRIx32\")\\n\",\n\t\t ctx, set, s->local_shutdown, s->peer_shutdown));\n\n\tif (s->local_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_RX && s->write_buf_tail > 0) {\n\t\tPPRINTF((\"%s: discarding %d bytes from buffer\\n\", ctx,\n\t\t\t s->write_buf_tail - s->write_buf_head));\n\t\ts->write_buf_tail = s->write_buf_head = 0;\n\t}\n\n\tif (s->local_shutdown == VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL)\n\t\ts->rst_deadline = time(NULL) + SHUTDOWN_RST_DELAY;\n}\n\nstatic void set_credit_update_required(struct pci_vtsock_softc *sc,\n\t\t\t\t       struct pci_vtsock_sock *sock)\n{\n\tif (sock->credit_update_required) return;\n\tsock->credit_update_required = true;\n\tsc->rx_kick_pending = true;\n}\n\nstatic void send_response_common(struct pci_vtsock_softc *sc,\n\t\t\t\t struct vsock_addr local_addr,\n\t\t\t\t struct vsock_addr peer_addr,\n\t\t\t\t uint16_t op, uint16_t type, uint32_t flags,\n\t\t\t\t uint32_t buf_alloc, uint32_t fwd_cnt)\n{\n\tstruct virtio_sock_hdr *hdr;\n\tint slot;\n\n\tassert(op != VIRTIO_VSOCK_OP_RW);\n\tassert(flags == 0 || op == VIRTIO_VSOCK_OP_SHUTDOWN);\n\n\tpthread_mutex_lock(&sc->reply_mtx);\n\n\tslot = sc->reply_prod++;\n\tif (sc->reply_prod == VTSOCK_REPLYRINGSZ)\n\t\tsc->reply_prod = 0;\n\tDPRINTF((\"TX: QUEUING REPLY IN SLOT %x (prod %x, cons %x)\\n\",\n\t\t slot, sc->reply_prod, sc->reply_cons));\n\t/*\n\t * We have just incremented reply_prod above but we hold the\n\t * lock so the consumer cannot have caught us up. Hence for\n\t * the ring to appear empty it must actually have just overflowed.\n\t */\n\tassert(!REPLY_RING_EMPTY(sc));\n\n\thdr = &sc->reply_ring[slot];\n\n\thdr->src_cid = local_addr.cid;\n\thdr->src_port = local_addr.port;\n\n\thdr->dst_cid = peer_addr.cid;\n\thdr->dst_port = peer_addr.port;\n\n\thdr->len = 0;\n\thdr->type = type;\n\thdr->op = op;\n\thdr->flags = flags;\n\n\thdr->buf_alloc = buf_alloc;\n\thdr->fwd_cnt = fwd_cnt;\n\n\tdprint_header(hdr, 0, \"TX\");\n\n\tpthread_mutex_unlock(&sc->reply_mtx);\n\n\tsc->rx_kick_pending = true;\n}\n\nstatic void send_response_sock(struct pci_vtsock_softc *sc,\n\t\t\t\t uint16_t op, uint32_t flags,\n\t\t\t\t const struct pci_vtsock_sock *sock)\n{\n\tsend_response_common(sc, sock->local_addr, sock->peer_addr,\n\t\t\t     op, VIRTIO_VSOCK_TYPE_STREAM, flags,\n\t\t\t     sock->buf_alloc, sock->fwd_cnt);\n}\n\nstatic void send_response_nosock(struct pci_vtsock_softc *sc, uint16_t op,\n\t\t\t\t uint16_t type,\n\t\t\t\t struct vsock_addr local_addr,\n\t\t\t\t struct vsock_addr peer_addr)\n{\n\tsend_response_common(sc, local_addr, peer_addr,\n\t\t\t     op, type, 0, 0, 0);\n}\n\nstatic bool sock_is_buffering(struct pci_vtsock_sock *sock)\n{\n\treturn sock->write_buf_tail > 0;\n}\n\nstatic int buffer_write(struct pci_vtsock_sock *sock,\n\t\t\tuint32_t len, struct iovec *iov, int iov_len)\n{\n\tsize_t nr;\n\tif (len > WRITE_BUF_LENGTH - sock->write_buf_tail) {\n\t\tDPRINTF((\"TX: fd %d unable to buffer write of 0x%\"PRIx32\" bytes,\"\n\t\t\t \" buffer use 0x%x/0x%x, 0x%x remaining\\n\",\n\t\t\t sock->fd, len, sock->write_buf_tail,\n\t\t\t WRITE_BUF_LENGTH,\n\t\t\t WRITE_BUF_LENGTH - sock->write_buf_tail));\n\t\treturn -1;\n\t}\n\n\tnr = iovec_pull(&iov, &iov_len,\n\t\t\t&sock->write_buf[sock->write_buf_tail], len);\n\tassert(nr == len);\n\tassert(iov_len == 0);\n\n\tsock->write_buf_tail += nr;\n\tDPRINTF((\"TX: fd %d buffered 0x%\"PRIx32\" bytes (0x%x/0x%x)\\n\",\n\t\t sock->fd, len, sock->write_buf_tail, WRITE_BUF_LENGTH));\n\n\treturn 0;\n}\n\nstatic void buffer_drain(struct pci_vtsock_softc *sc,\n\t\t\t struct pci_vtsock_sock *sock)\n{\n\tssize_t nr;\n\n\tDPRINTF((\"TX: buffer drain on fd %d 0x%x-0x%x/0x%x\\n\",\n\t\t sock->fd, sock->write_buf_head, sock->write_buf_tail,\n\t\t WRITE_BUF_LENGTH));\n\n\tassert(sock_is_buffering(sock));\n\tassert(sock->write_buf_head < sock->write_buf_tail);\n\n\tnr = write(sock->fd, &sock->write_buf[sock->write_buf_head],\n\t\t   sock->write_buf_tail - sock->write_buf_head);\n\tif (nr == -1) {\n\t\tif (errno == EPIPE) {\n\t\t\t/* Assume EOF and shutdown */\n\t\t\tshutdown_local_sock(\"TX\", sock, VIRTIO_VSOCK_FLAG_SHUTDOWN_RX);\n\t\t\tsend_response_sock(sc, VIRTIO_VSOCK_OP_SHUTDOWN,\n\t\t\t\t\t   sock->local_shutdown, sock);\n\t\t\treturn;\n\t\t} else if (errno == EAGAIN) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tPPRINTF((\"TX: write fd=%d failed with %d %s\\n\", sock->fd,\n\t\t\t\t errno, strerror(errno)));\n\t\t\tsend_response_sock(sc, VIRTIO_VSOCK_OP_RST, 0, sock);\n\t\t\tclose_sock(sc, sock, \"TX\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tDPRINTF((\"TX: drained %zd/%\"PRId32\" bytes\\n\", nr,\n\t\t sock->write_buf_tail - sock->write_buf_head));\n\tsock->write_buf_head += nr;\n\tif (sock->write_buf_head < sock->write_buf_tail)\n\t\treturn;\n\n\t/* Buffer completely drained, reset and update peer.  NB: We\n\t * only update fwd_cnt once the buffer is empty rather than as\n\t * we go, in the hopes that we then won't need to buffer so\n\t * much as we go on.\n\t */\n\tDPRINTF((\"TX: fd %d buffer drained of 0x%x bytes\\n\",\n\t\t sock->fd, sock->write_buf_head));\n\tsock->fwd_cnt += sock->write_buf_head;\n\tsock->write_buf_head = sock->write_buf_tail = 0;\n\n\t/* shutdown_peer_local_fd will have deferred this if we were buffering */\n\tif ((sock->peer_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_TX) &&\n\t    !(sock->local_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_RX)) {\n\t\tint rc = shutdown(sock->fd, SHUT_WR);\n\t\tPPRINTF((\"TX: buffer_drained, performing pending shutdown(%d, SHUT_WR)\\n\", sock->fd));\n\t\tif (rc < 0 && errno != ENOTCONN) {\n\t\t\tDPRINTF((\"TX: shutdown(%d, SHUT_WR) after buffer drain failed: %s\\n\",\n\t\t\t\t sock->fd, strerror(errno)));\n\t\t\tabort();\n\t\t}\n\t\tsock->local_shutdown |= VIRTIO_VSOCK_FLAG_SHUTDOWN_RX;\n\t}\n\n\tset_credit_update_required(sc, sock);\n}\n\n/* -> 1 == success, update peer credit\n * -> 0 == success, don't update peer credit\n */\nstatic int handle_write(struct pci_vtsock_softc *sc,\n\t\t\tstruct pci_vtsock_sock *sock,\n\t\t\tuint32_t len, struct iovec *iov, int iov_len)\n{\n\tssize_t num;\n\n\tif (sock_is_buffering(sock)) {\n\t\treturn buffer_write(sock, len, iov, iov_len);\n\t}\n\n\tnum = writev(sock->fd, iov, iov_len);\n\tif (num == -1) {\n\t\tif (errno == EPIPE) {\n\t\t\t/* Assume EOF and shutdown */\n\t\t\tPPRINTF((\"TX: writev fd=%d failed with EPIPE => SHUTDOWN_RX\\n\", sock->fd));\n\t\t\tshutdown_local_sock(\"TX\", sock, VIRTIO_VSOCK_FLAG_SHUTDOWN_RX);\n\t\t\tsend_response_sock(sc, VIRTIO_VSOCK_OP_SHUTDOWN,\n\t\t\t\t\t   sock->local_shutdown, sock);\n\t\t\treturn 0;\n\t\t} else if (errno == EAGAIN) {\n\t\t\tnum = 0;\n\t\t} else {\n\t\t\tPPRINTF((\"TX: writev fd=%d failed with %d %s\\n\", sock->fd,\n\t\t\t\t errno, strerror(errno)));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tDPRINTF((\"TX: wrote %zd/%\"PRId32\" bytes\\n\", num, len));\n\tsock->fwd_cnt += num;\n\tif (num == len) {\n\t\treturn 1;\n\t} else { /* Buffer the rest */\n\t\tsize_t pulled = iovec_pull(&iov, &iov_len, NULL, (size_t)num);\n\t\tassert(pulled == (size_t)num);\n\t\treturn buffer_write(sock, len - (uint32_t)num, iov, iov_len);\n\t}\n}\n\nstatic void pci_vtsock_proc_tx(struct pci_vtsock_softc *sc,\n\t\t\t       struct vqueue_info *vq)\n{\n\tstruct pci_vtsock_sock *sock;\n\tstruct iovec iov_array[VTSOCK_MAXSEGS], *iov = iov_array;\n\tuint16_t idx, flags[VTSOCK_MAXSEGS];\n\tstruct virtio_sock_hdr hdr;\n\tint iovec_len;\n\tsize_t pulled;\n\n\tiovec_len = vq_getchain(vq, &idx, iov, VTSOCK_MAXSEGS, flags);\n\tif (iovec_len < 0) {\n\t\tfprintf(stderr, \"TX: failed to get chain at idx %\"PRIx16\"\\n\", idx);\n\t\treturn;\n\t}\n\n\tassert(iovec_len <= VTSOCK_MAXSEGS);\n\n\tDPRINTF((\"TX: chain with %d buffers at idx %\"PRIx16\"\\n\",\n\t\t iovec_len, idx));\n\tdprint_chain(iov, iovec_len, \"TX\");\n\t//assert(iov[0].iov_len >= sizeof(*hdr));\n\t//hdr = iov[0].iov_base;\n\n\tpulled = iovec_pull(&iov, &iovec_len, &hdr, sizeof(hdr));\n\tassert(pulled == sizeof(hdr));\n\n\tdprint_header(&hdr, 1, \"TX\");\n\n\tdprint_iovec(iov, iovec_len, \"TX\");\n\n\tif (hdr.src_cid != sc->vssc_cfg.guest_cid ||\n\t    hdr.dst_cid != VMADDR_CID_HOST ||\n\t    hdr.type != VIRTIO_VSOCK_TYPE_STREAM) {\n\t\tDPRINTF((\"TX: Bad src/dst address/type\\n\"));\n\t\tsend_response_nosock(sc, VIRTIO_VSOCK_OP_RST,\n\t\t\t\t     hdr.type,\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = hdr.dst_cid,\n\t\t\t\t\t     .port =hdr.dst_port\n\t\t\t\t     },\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = hdr.src_cid,\n\t\t\t\t\t     .port =hdr.src_port\n\t\t\t\t     });\n\t\tvq_relchain(vq, idx, 0);\n\t\treturn;\n\t}\n\n\tsock = lookup_sock(sc, VIRTIO_VSOCK_TYPE_STREAM,\n\t\t\t   (struct vsock_addr) {\n\t\t\t\t   .cid = hdr.dst_cid,\n\t\t\t\t\t   .port =hdr.dst_port\n\t\t\t   },\n\t\t\t   (struct vsock_addr) {\n\t\t\t\t   .cid = hdr.src_cid,\n\t\t\t\t\t   .port =hdr.src_port\n\t\t\t   });\n\n\tif (sock) {\n\t\tsock->peer_buf_alloc = hdr.buf_alloc;\n\t\tsock->peer_fwd_cnt = hdr.fwd_cnt;\n\t}\n\n\tswitch (hdr.op) {\n\tcase VIRTIO_VSOCK_OP_INVALID:\n\t\tPPRINTF((\"TX: => INVALID\\n\"));\n\t\tgoto do_rst;\n\n\tcase VIRTIO_VSOCK_OP_REQUEST:\n\t\t/* Attempt to (re)connect existing sock? Naughty! */\n\t\t/* Or is it -- what are the semantics? */\n\t\tif (sock) {\n\t\t\tPPRINTF((\"TX: Attempt to reconnect sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\n\t\tif (hdr.dst_cid == sc->vssc_cfg.guest_cid) {\n\t\t\tPPRINTF((\"TX: Attempt to connect back to guest\\n!\"));\n\t\t\tgoto do_rst;\n\t\t}\n\n\t\tsock = connect_sock(sc,\n\t\t\t\t    (struct vsock_addr){\n\t\t\t\t\t    .cid = hdr.dst_cid, .port = hdr.dst_port\n\t\t\t\t    },\n\t\t\t\t    (struct vsock_addr){\n\t\t\t\t\t    .cid = hdr.src_cid, .port = hdr.src_port\n\t\t\t\t    }, hdr.buf_alloc, hdr.fwd_cnt);\n\t\tif (!sock) {\n\t\t\tPPRINTF((\"TX: Failed to open sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\n\t\tsend_response_sock(sc, VIRTIO_VSOCK_OP_RESPONSE, 0, sock);\n\t\tvq_relchain(vq, idx, 0);\n\t\t/* No rx kick required, send_response_sock did one */\n\t\tbreak;\n\n\tcase VIRTIO_VSOCK_OP_RESPONSE:\n\t\tif (!sock) {\n\t\t\tPPRINTF((\"TX: RESPONSE to non-existent sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->state != SOCK_CONNECTING) {\n\t\t\tPPRINTF((\"TX: RESPONSE to non-connecting sock (state %d)\\n\",\n\t\t\t\t sock->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tPPRINTF((\"TX: SOCK connected (%d) \"PRIaddr\" <=> \"PRIaddr\"\\n\",\n\t\t\t sock->fd, FMTADDR(sock->local_addr), FMTADDR(sock->peer_addr)));\n\t\tsock->state = SOCK_CONNECTED;\n\t\tvq_relchain(vq, idx, 0);\n\t\tkick_rx(sc, \"new outgoing sock\");\n\t\tbreak;\n\n\tcase VIRTIO_VSOCK_OP_RST:\n\t\t/* No response */\n\t\tif (!sock)\n\t\t\tPPRINTF((\"TX: RST to non-existent sock\\n\"));\n\t\tclose_sock(sc, sock, \"TX\");\n\t\tvq_relchain(vq, idx, 0);\n\t\tbreak;\n\n\tcase VIRTIO_VSOCK_OP_SHUTDOWN:\n\t\tif (!sock) {\n\t\t\tDPRINTF((\"TX: SHUTDOWN to non-existent sock \"PRIcid\".\"PRIport\"\\n\",\n\t\t\t\t hdr.dst_cid, hdr.dst_port));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->state != SOCK_CONNECTED) {\n\t\t\tPPRINTF((\"TX: SHUTDOWN to non-connected sock (state %d)\\n\",\n\t\t\t\t sock->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (hdr.flags & ~VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL) {\n\t\t\tPPRINTF((\"TX: SHUTDOWN with reserved flags %\"PRIx32\"\\n\",\n\t\t\t\t hdr.flags));\n\t\t\tgoto do_rst; /* ??? */\n\t\t}\n\t\tif (!(hdr.flags & VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL)) {\n\t\t\tPPRINTF((\"TX: SHUTDOWN with no flags %\"PRIx32\"\\n\",\n\t\t\t\t hdr.flags));\n\t\t\tgoto do_rst; /* ??? */\n\t\t}\n\n\t\tshutdown_peer_local_fd(sock, hdr.flags, \"TX\");\n\n\t\t/* If the peer is now SHUTDOWN_ALL then we should send\n\t\t * a RST to the peer to finalise the shutdown.\n\t\t */\n\t\tif (sock->peer_shutdown == VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL)\n\t\t\tgoto do_rst;\n\n\t\tvq_relchain(vq, idx, 0);\n\t\tbreak;\n\n\tcase VIRTIO_VSOCK_OP_RW:\n\t{\n\t\tint rc;\n\n\t\tif (!sock) {\n\t\t\tPPRINTF((\"TX: RW with no sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->state != SOCK_CONNECTED) {\n\t\t\tPPRINTF((\"TX: RW to non-connected sock (state %d)\\n\",\n\t\t\t\t sock->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->peer_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_TX) {\n\t\t\tPPRINTF((\"TX: RW to socket with peer_shutdown.TX\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->local_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_RX) {\n\t\t\tPPRINTF((\"TX: RW to socket with local_shutdown.RX\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\trc = handle_write(sc, sock, hdr.len, iov, iovec_len);\n\t\tif (rc < 0) goto do_rst;\n\t\tvq_relchain(vq, idx, 0);\n\t\tif (rc == 1)\n\t\t\tset_credit_update_required(sc, sock);\n\t\tbreak;\n\t}\n\n\tcase VIRTIO_VSOCK_OP_CREDIT_UPDATE:\n\t\tif (!sock) {\n\t\t\tPPRINTF((\"TX: CREDIT_UPDATE to non-existent sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->state != SOCK_CONNECTED) {\n\t\t\tPPRINTF((\"TX: CREDIT_UPDATE to non-connected sock (state %d)\\n\",\n\t\t\t\t sock->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\t/* No response needed, we updated above */\n\t\tvq_relchain(vq, idx, 0);\n\t\t/* But kick rx thread to attempt to send more */\n\t\tsc->rx_kick_pending = true;\n\t\tbreak;\n\n\tcase VIRTIO_VSOCK_OP_CREDIT_REQUEST:\n\t\tif (!sock) {\n\t\t\tPPRINTF((\"TX: CREDIT_REQUEST to non-existent sock\\n\"));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tif (sock->state != SOCK_CONNECTED) {\n\t\t\tPPRINTF((\"TX: CREDIT_REQUEST to non-connected sock (state %d)\\n\",\n\t\t\t\t sock->state));\n\t\t\tgoto do_rst;\n\t\t}\n\t\tvq_relchain(vq, idx, 0);\n\t\tset_credit_update_required(sc, sock);\n\t\tbreak;\n\t}\n\n\tif (sock)\n\t\tput_sock(sock);\n\n\treturn;\n\ndo_rst:\n\tif (sock)\n\t\tsend_response_sock(sc, VIRTIO_VSOCK_OP_RST, 0, sock);\n\telse\n\t\tsend_response_nosock(sc, VIRTIO_VSOCK_OP_RST, hdr.type,\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = hdr.dst_cid,\n\t\t\t\t\t     .port =hdr.dst_port\n\t\t\t\t     },\n\t\t\t\t     (struct vsock_addr) {\n\t\t\t\t\t     .cid = hdr.src_cid,\n\t\t\t\t\t     .port =hdr.src_port\n\t\t\t\t     });\n\tvq_relchain(vq, idx, 0);\n\tclose_sock(sc, sock, \"TX\");\n\tif (sock) put_sock(sock);\n\treturn;\n}\n\nstatic void handle_connect_fd(struct pci_vtsock_softc *sc, int accept_fd, uint64_t cid, uint32_t port)\n{\n\tint fd, rc;\n\tchar buf[8 + 1 + 8 + 1 + 1]; /* %08x.%08x\\n\\0 */\n\tssize_t bytes;\n\tstruct pci_vtsock_sock *sock = NULL;\n\n\tfd = accept(accept_fd, NULL, NULL);\n\tif (fd < 0) {\n\t\tfprintf(stderr,\n\t\t\t\"TX: Unable to accept incoming connection: %d (%s)\\n\",\n\t\t\terrno, strerror(errno));\n\t\treturn;\n\t}\n\n\tif (fd >= FD_SETSIZE) {\n\t\tfprintf(stderr, \"TX: Unable to accept incoming connection: fd %d > FD_SETSIZE %d\\n\",\n\t\t\tfd, FD_SETSIZE);\n\t\tclose(fd);\n\t\tgoto err;\n\t}\n\n\tDPRINTF((\"TX: Connect attempt on connect fd => %d\\n\", fd));\n\n\tif (cid == VMADDR_CID_ANY) {\n\t\tdo {\n\t\t\tbytes = read(fd, buf, sizeof(buf)-1);\n\t\t} while (bytes == -1 && errno == EAGAIN);\n\n\t\tif (bytes != sizeof(buf) - 1) {\n\t\t\tDPRINTF((\"TX: Short read on connect %zd/%zd\\n\", bytes, sizeof(buf)-1));\n\t\t\tif (bytes == -1) DPRINTF((\"TX: errno: %s\\n\", strerror(errno)));\n\t\t\tgoto err;\n\t\t}\n\t\tbuf[sizeof(buf)-1] = '\\0';\n\n\t\tif (buf[sizeof(buf)-2] != '\\n') {\n\t\t\tDPRINTF((\"TX: No newline on connect %s\\n\", buf));\n\t\t\tgoto err;\n\t\t}\n\n\t\tDPRINTF((\"TX: Connect to %s\", buf));\n\n\t\trc = sscanf(buf, SCNaddr\"\\n\", &cid, &port);\n\t\tif (rc != 2) {\n\t\t\tDPRINTF((\"TX: Failed to parse connect attempt\\n\"));\n\t\t\tgoto err;\n\t\t}\n\t\tDPRINTF((\"TX: Connection requested to \"PRIaddr\"\\n\", cid, port));\n\t} else {\n\t\tDPRINTF((\"TX: Forwarding connection to \"PRIaddr\"\\n\", cid, port));\n\t}\n\n\tif (cid >= VMADDR_CID_MAX) {\n\t\tDPRINTF((\"TX: Attempt to connect to CID over 32-bit\\n\"));\n\t\tgoto err;\n\t}\n\tif (cid != sc->vssc_cfg.guest_cid) {\n\t\tDPRINTF((\"TX: Attempt to connect to non-guest CID\\n\"));\n\t\tgoto err;\n\t}\n\n\tsock = alloc_sock(sc);\n\n\tif (sock == NULL) {\n\t\tDPRINTF((\"TX: No available sockets for connect\\n\"));\n\t\tgoto err;\n\t}\n\n\tDPRINTF((\"TX: Assigned sock %ld at %p for connect\\n\",\n\t\t sock - &sc->socks[0], (void *)sock));\n\n\tsock->fd = fd;\n\tsock->peer_addr.cid = cid;\n\tsock->peer_addr.port = port;\n\tsock->local_addr.cid = VMADDR_CID_HOST;\n\t/* Start at 2^16 to be larger than a TCP port, add a\n\t * generation counter to reduce port reuse.\n\t * XXX Allocate properly.\n         */\n\tsock->local_addr.port = ((uint32_t)(sock - &sc->socks[0] + 1) << 16)\n\t\t+ (++sock->port_generation);\n\n\trc = set_socket_options(sock);\n\tif (rc < 0) goto err;\n\n\tput_sock(sock);\n\n\tPPRINTF((\"TX: SOCK connecting (%d) \"PRIaddr\" <=> \"PRIaddr\"\\n\",\n\t\t sock->fd, FMTADDR(sock->local_addr), FMTADDR(sock->peer_addr)));\n\tsend_response_sock(sc, VIRTIO_VSOCK_OP_REQUEST, 0, sock);\n\n\treturn;\nerr:\n\tif (sock) {\n\t\tpthread_rwlock_wrlock(&sc->list_rwlock);\n\t\tfree_sock(sc, sock);\n\t\tpthread_rwlock_unlock(&sc->list_rwlock);\n\t}\n\tclose(fd);\n}\n\nstatic void *pci_vtsock_tx_thread(void *vsc)\n{\n\tstruct pci_vtsock_softc *sc = vsc;\n\tstruct vqueue_info *vq = &sc->vssc_vqs[VTSOCK_QUEUE_TX];\n\tfd_set rfd, wfd;\n\tLIST_HEAD(tx_queue, pci_vtsock_sock) queue;\n\n\tpthread_setname_np(\"vsock:tx\");\n\n\tassert(sc);\n\tassert(sc->tx_wake_fd != -1);\n\tassert(sc->connect_fd != -1);\n\n\twhile(1) {\n\t\tbool kick_rx_closing = false;\n\t\tint i, nrfd, maxfd, nr;\n\t\tint buffering = 0;\n\t\tstruct pci_vtsock_sock *s;\n\t\tstruct timeval *select_timeout = NULL, select_timeout_5s;\n\n\t\tLIST_INIT(&queue);\n\n\t\tFD_ZERO(&rfd);\n\t\tFD_ZERO(&wfd);\n\n\t\tFD_SET(sc->tx_wake_fd, &rfd);\n\t\tmaxfd = sc->tx_wake_fd;\n\n\t\tFD_SET(sc->connect_fd, &rfd);\n\t\tmaxfd = max_fd(sc->connect_fd, maxfd);\n\t\tnrfd = 2;\n\n\t\tfor (i = 0; i < sc->nr_fwds; i++) {\n\t\t\tstruct pci_vtsock_forward *fwd = &sc->fwds[i];\n\t\t\tassert(fwd->listen_fd != -1);\n\t\t\tFD_SET(fwd->listen_fd, &rfd);\n\t\t\tmaxfd = max_fd(fwd->listen_fd, maxfd);\n\t\t\tnrfd++;\n\t\t}\n\n\t\tpthread_rwlock_rdlock(&sc->list_rwlock);\n\t\tLIST_FOREACH(s, &sc->inuse_list, list) {\n\t\t\tget_sock(s);\n\n\t\t\tswitch (s->state) {\n\t\t\tcase SOCK_CLOSING_TX: /* Closing comes through here */\n\t\t\t\tif (sock_is_buffering(s))\n\t\t\t\t\tbreak;\n\n\t\t\t        /* Close down */\n\t\t\t\tassert(s->local_shutdown == VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL ||\n\t\t\t\t       s->peer_shutdown == VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL);\n\n\t\t\t\tDPRINTF((\"TX: Closing sock %p fd %d local %\"PRIx32\" peer %\"PRIx32\"\\n\",\n\t\t\t\t\t (void *)s, s->fd,\n\t\t\t\t\t s->local_shutdown,\n\t\t\t\t\t s->peer_shutdown));\n\t\t\t\tPPRINTF((\"TX: SOCK closed (%d) \"PRIaddr\" <=> \"PRIaddr\"\\n\",\n\t\t\t\t\t s->fd,\n\t\t\t\t\t FMTADDR(s->local_addr), FMTADDR(s->peer_addr)));\n\n\t\t\t\ts->state = SOCK_CLOSING_RX;\n\n\t\t\t\tkick_rx_closing = true;\n\n\t\t\t\tput_sock(s);\n\t\t\t\tcontinue;\n\t\t\tcase SOCK_CONNECTED:\n\t\t\t\tbreak;\n\t\t\tcase SOCK_FREE:\n\t\t\tcase SOCK_CONNECTING:\n\t\t\tcase SOCK_CLOSING_RX:\n\t\t\t\tput_sock(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tassert(s->fd >= 0);\n\n\t\t\tif (s->local_shutdown == VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL) {\n\t\t\t\ttime_t now = time(NULL);\n\n\t\t\t\t/* Has deadline for peer to return a RST expired? */\n\t\t\t\tif (now > s->rst_deadline) {\n\t\t\t\t\tsend_response_sock(sc, VIRTIO_VSOCK_OP_RST, 0, s);\n\t\t\t\t\tclose_sock(sc, s, \"TX\");\n\t\t\t\t\tput_sock(s);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (select_timeout == NULL) {\n\t\t\t\t\tselect_timeout_5s.tv_sec = 5;\n\t\t\t\t\tselect_timeout_5s.tv_usec = 0;\n\t\t\t\t\tselect_timeout = &select_timeout_5s;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (s->local_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_RX) {\n\t\t\t\tput_sock(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (sock_is_buffering(s)) {\n\t\t\t\tFD_SET(s->fd, &wfd);\n\t\t\t\tmaxfd = max_fd(s->fd, maxfd);\n\t\t\t\tbuffering++;\n\t\t\t\tnrfd++;\n\t\t\t\tLIST_INSERT_HEAD(&queue, s, tx_queue);\n\t\t\t}\n\t\t\tput_sock(s);\n\t\t}\n\t\tpthread_rwlock_unlock(&sc->list_rwlock);\n\t\tassert(maxfd < FD_SETSIZE);\n\n\t\tif (kick_rx_closing)\n\t\t\tkick_rx(sc, \"tx closing\");\n\n\t\tDPRINTF((\"TX: *** selecting on %d fds (buffering: %d)\\n\",\n\t\t\t nrfd, buffering));\n\t\tnr = xselect(\"TX\", maxfd + 1, &rfd, &wfd, NULL, select_timeout);\n\t\tif (nr < 0) continue;\n\t\tDPRINTF((\"TX:\\nTX: *** %d/%d fds are readable/writeable\\n\", nr, nrfd));\n\n\t\tif (FD_ISSET(sc->tx_wake_fd, &rfd)) {\n\t\t\t/* Eat the notification(s) */\n\t\t\tchar dummy[128];\n\t\t\tssize_t rd_dummy = read(sc->tx_wake_fd, &dummy, sizeof(dummy));\n\t\t\tassert(rd_dummy >= 1);\n\t\t\t/* Restart select now that we have some descriptors */\n\t\t\tDPRINTF((\"TX: thread got %zd kicks (have descs: %s)\\n\",\n\t\t\t\t rd_dummy,\n\t\t\t\t vq_has_descs(vq) ? \"yes\" : \"no\"));\n\t\t}\n\n\t\tif (FD_ISSET(sc->connect_fd, &rfd)) {\n\t\t\tDPRINTF((\"TX: Handling connect fd\\n\"));\n\t\t\thandle_connect_fd(sc, sc->connect_fd, VMADDR_CID_ANY, 0);\n\t\t}\n\n\t\tfor (i = 0; i < sc->nr_fwds; i++) {\n\t\t\tstruct pci_vtsock_forward *fwd = &sc->fwds[i];\n\t\t\tif (FD_ISSET(fwd->listen_fd, &rfd)) {\n\t\t\t\tDPRINTF((\"Attempt to connect to forwarded guest port %\"PRId32\"\\n\", fwd->port));\n\t\t\t\thandle_connect_fd(sc, fwd->listen_fd, sc->vssc_cfg.guest_cid, fwd->port);\n\t\t\t}\n\t\t}\n\n\t\tif (buffering) {\n\t\t\tLIST_FOREACH(s, &queue, tx_queue) {\n\t\t\t\tget_sock(s);\n\t\t\t\tif (s->state != SOCK_CONNECTED && s->state != SOCK_CLOSING_TX) {\n\t\t\t\t\tput_sock(s);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (FD_ISSET(s->fd, &wfd)) {\n\t\t\t\t\tbuffer_drain(sc, s);\n\t\t\t\t}\n\t\t\t\tput_sock(s);\n\t\t\t}\n\t\t}\n\n\t\twhile (vq_has_descs(vq))\n\t\t\tpci_vtsock_proc_tx(sc, vq);\n\n\t\tif (vq_ring_ready(vq))\n\t\t\tvq_endchains(vq, 1);\n\n\t\tif (sc->rx_kick_pending) {\n\t\t\tkick_rx(sc, \"end of tx loop\");\n\t\t}\n\t\tDPRINTF((\"TX: All work complete\\n\"));\n\t}\n}\n\nstatic void pci_vtsock_notify_tx(void *vsc, struct vqueue_info *vq)\n{\n\tstruct pci_vtsock_softc *sc = vsc;\n\n\tassert(vq == &sc->vssc_vqs[VTSOCK_QUEUE_TX]);\n\tkick_tx(sc, \"notify\");\n}\n\n/*\n * Returns:\n *  -1 == no descriptors available, nothing sent, s->credit_update_required untouched\n *   0 == nothing done (sock has shutdown, peer has no buffers, nothing on Unix socket)\n *  >0 == number of bytes read\n *\n * If return is >= 0 then will have sent something to the other end\n * (an OP_CREDIT_UPDATE if no other traffic was generated) and thus\n * s->credit_update_required will be false on exit if return is >= 0.\n */\nstatic ssize_t pci_vtsock_proc_rx(struct pci_vtsock_softc *sc,\n\t\t\t\t  struct vqueue_info *vq,\n\t\t\t\t  struct pci_vtsock_sock *s)\n{\n\tstruct virtio_sock_hdr *hdr;\n\tstruct iovec iov_array[VTSOCK_MAXSEGS], *iov = iov_array;\n\tuint16_t flags[VTSOCK_MAXSEGS];\n\tuint16_t idx;\n\tuint32_t peer_free;\n\tint iovec_len;\n\tsize_t pushed;\n\tssize_t len;\n\n\tassert(s->fd >= 0);\n\n\tif (!vq_has_descs(vq)) {\n\t\tDPRINTF((\"RX: no queues!\\n\"));\n\t\treturn -1;\n\t}\n\n\tiovec_len = vq_getchain(vq, &idx, iov, VTSOCK_MAXSEGS, flags);\n\tDPRINTF((\"RX: virtio-vsock: got %d elem rx chain\\n\", iovec_len));\n\tdprint_chain(iov, iovec_len, \"RX\");\n\n\tassert(iovec_len >= 1);\n\t/* XXX needed so we can update len after the read */\n\tassert(iov[0].iov_len >= sizeof(*hdr));\n\n\thdr = iov[0].iov_base;\n\thdr->src_cid = s->local_addr.cid;\n\thdr->src_port = s->local_addr.port;\n\thdr->dst_cid = s->peer_addr.cid;\n\thdr->dst_port = s->peer_addr.port;\n\thdr->len = 0; /* XXX */\n\thdr->type = VIRTIO_VSOCK_TYPE_STREAM;\n\thdr->op = VIRTIO_VSOCK_OP_RW;\n\thdr->flags = 0;\n\thdr->buf_alloc = s->buf_alloc;\n\thdr->fwd_cnt = s->fwd_cnt;\n\n\tpeer_free = s->peer_buf_alloc - (s->rx_cnt - s->peer_fwd_cnt);\n\tDPRINTF((\"RX:\\tpeer free = %\"PRIx32\"\\n\", peer_free));\n\tif (!peer_free) goto credit_update; /* No space */\n\n\tpushed = iovec_push(&iov, &iovec_len, hdr, sizeof(*hdr));\n\tassert(pushed == sizeof(*hdr));\n\n\tiovec_clip(&iov, &iovec_len, peer_free);\n\n\tlen = readv(s->fd, iov, iovec_len);\n\tif (len == -1) {\n\t\tif (errno == EAGAIN) { /* Nothing to read/would block */\n\t\t\tDPRINTF((\"RX: readv fd=%d EAGAIN\\n\", s->fd));\n\t\t\tgoto credit_update;\n\t\t}\n\t\tPPRINTF((\"RX: readv fd=%d failed with %d %s\\n\",\n\t\t\t s->fd, errno, strerror(errno)));\n\t\thdr->op = VIRTIO_VSOCK_OP_RST;\n\t\thdr->flags = 0;\n\t\thdr->len = 0;\n\t\tdprint_header(hdr, 0, \"RX\");\n\t\ts->credit_update_required = false;\n\t\tvq_relchain(vq, idx, sizeof(*hdr));\n\t\tclose_sock(sc, s, \"RX\");\n\t\treturn 0;\n\t}\n\tDPRINTF((\"RX: readv put %zd bytes into iov\\n\", len));\n\tif (len == 0) { /* Not actually anything to read -- EOF */\n\t\tPPRINTF((\"RX: readv fd=%d EOF => SHUTDOWN_TX\\n\", s->fd));\n\t\tshutdown_local_sock(\"RX\", s, VIRTIO_VSOCK_FLAG_SHUTDOWN_TX);\n\t\thdr->op = VIRTIO_VSOCK_OP_SHUTDOWN;\n\t\thdr->flags = s->local_shutdown;\n\t\thdr->len = 0;\n\t\tdprint_header(hdr, 0, \"RX\");\n\t\ts->credit_update_required = false;\n\t\tvq_relchain(vq, idx, sizeof(*hdr));\n\t\treturn 0;\n\t}\n\thdr->len = (uint32_t)len;\n\n\ts->rx_cnt += len;\n\n\tdprint_header(hdr, 0, \"RX\");\n\ts->credit_update_required = false;\n\tvq_relchain(vq, idx, sizeof(*hdr) + (uint32_t)len);\n\n\treturn len;\n\ncredit_update:\n\tif (s->credit_update_required) {\n\t\thdr->op = VIRTIO_VSOCK_OP_CREDIT_UPDATE;\n\t\thdr->flags = 0;\n\t\thdr->len = 0;\n\t\tdprint_header(hdr, 0, \"RX\");\n\t\ts->credit_update_required = false;\n\t\tvq_relchain(vq, idx, sizeof(*hdr));\n\t} else {\n\t\tvq_retchain(vq);\n\t}\n\treturn 0;\n}\n\n/* True if there is more to do */\nstatic bool rx_do_one_reply(struct pci_vtsock_softc *sc,\n\t\t\t    struct vqueue_info *vq)\n{\n\tstruct virtio_sock_hdr *hdr;\n\tstruct iovec iov_array[VTSOCK_MAXSEGS], *iov = iov_array;\n\tint iovec_len;\n\tuint16_t idx;\n\tsize_t pushed;\n\tint slot;\n\tbool more_to_do = false;\n\n\tif (REPLY_RING_EMPTY(sc))\n\t\tgoto done;\n\n\tslot = sc->reply_cons++;\n\tif (sc->reply_cons == VTSOCK_REPLYRINGSZ)\n\t\tsc->reply_cons = 0;\n\n\thdr = &sc->reply_ring[slot];\n\n\tiovec_len = vq_getchain(vq, &idx, iov, VTSOCK_MAXSEGS, NULL);\n\tDPRINTF((\"RX: reply: got %d elem rx chain for slot %x (prod %x, cons %x)\\n\",\n\t\t iovec_len, slot, sc->reply_prod, sc->reply_cons));\n\n\tassert(iovec_len >= 1);\n\n\tpushed = iovec_push(&iov, &iovec_len, hdr, sizeof(*hdr));\n\tassert(pushed == sizeof(*hdr));\n\n\tvq_relchain(vq, idx, sizeof(*hdr));\n\n\tmore_to_do = !REPLY_RING_EMPTY(sc);\n\ndone:\n\treturn more_to_do;\n}\n\n/* true on success, false if no descriptors */\nstatic bool send_credit_update(struct vqueue_info *vq,\n\t\t\t       struct pci_vtsock_sock *s)\n{\n\tstruct virtio_sock_hdr *hdr;\n\tstruct iovec iov_array[VTSOCK_MAXSEGS], *iov = iov_array;\n\tuint16_t idx;\n\tint iovec_len;\n\n\tassert(s->fd >= 0);\n\n\tif (!vq_has_descs(vq)) {\n\t\tDPRINTF((\"RX: no queues for credit update!\\n\"));\n\t\treturn false;\n\t}\n\n\tiovec_len = vq_getchain(vq, &idx, iov, VTSOCK_MAXSEGS, NULL);\n\tDPRINTF((\"RX: virtio-vsock: got %d elem rx chain for credit update\\n\", iovec_len));\n\tdprint_chain(iov, iovec_len, \"RX\");\n\n\tassert(iovec_len >= 1);\n\tassert(iov[0].iov_len >= sizeof(*hdr));\n\n\thdr = iov[0].iov_base;\n\thdr->src_cid = s->local_addr.cid;\n\thdr->src_port = s->local_addr.port;\n\thdr->dst_cid = s->peer_addr.cid;\n\thdr->dst_port = s->peer_addr.port;\n\thdr->len = 0;\n\thdr->type = VIRTIO_VSOCK_TYPE_STREAM;\n\thdr->op = VIRTIO_VSOCK_OP_CREDIT_UPDATE;\n\thdr->flags = 0;\n\thdr->buf_alloc = s->buf_alloc;\n\thdr->fwd_cnt = s->fwd_cnt;\n\n\tdprint_header(hdr, 0, \"RX\");\n\n\tvq_relchain(vq, idx, sizeof(*hdr));\n\n\treturn true;\n}\n\nstatic void *pci_vtsock_rx_thread(void *vsc)\n{\n\tstruct pci_vtsock_softc *sc = vsc;\n\tstruct vqueue_info *vq = &sc->vssc_vqs[VTSOCK_QUEUE_RX];\n\tfd_set rfd;\n\tbool poll_socks = true;\n\tstruct pci_vtsock_sock *s, *ts;\n\tLIST_HEAD(rx_queue, pci_vtsock_sock) queue;\n\tLIST_HEAD(rx_closing_queue, pci_vtsock_sock) closing_queue;\n\n\tassert(sc);\n\tassert(sc->rx_wake_fd != -1);\n\n\tpthread_setname_np(\"vsock:rx\");\n\nrx_done:\n\n\twhile (1) {\n\t\tint nrfd, maxfd, nr;\n\t\tbool did_some_work = true;\n\t\tbool pending_credit_updates = false;\n\t\tstruct timeval zero_timeout = {\n\t\t\t.tv_sec = 0,\n\t\t\t.tv_usec = 0,\n\t\t};\n\n\t\tFD_ZERO(&rfd);\n\n\t\tLIST_INIT(&queue);\n\t\tLIST_INIT(&closing_queue);\n\n\t\tFD_SET(sc->rx_wake_fd, &rfd);\n\t\tmaxfd = sc->rx_wake_fd;\n\t\tnrfd = 1;\n\n\t\tpthread_rwlock_rdlock(&sc->list_rwlock);\n\t\tLIST_FOREACH(s, &sc->inuse_list, list) {\n\t\t\tbool polling = true;\n\t\t\tuint32_t peer_free;\n\n\t\t\tget_sock(s);\n\n\t\t\tif (s->state == SOCK_CLOSING_RX) { /* Closing comes through here */\n\t\t\t\tassert(s->local_shutdown == VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL ||\n\t\t\t\t       s->peer_shutdown == VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL);\n\n\t\t\t\tDPRINTF((\"RX: Closing sock %p fd %d local %\"PRIx32\" peer %\"PRIx32\"\\n\",\n\t\t\t\t\t (void *)s, s->fd,\n\t\t\t\t\t s->local_shutdown,\n\t\t\t\t\t s->peer_shutdown));\n\t\t\t\tPPRINTF((\"RX: SOCK closed (%d) \"PRIaddr\" <=> \"PRIaddr\"\\n\",\n\t\t\t\t\t s->fd,\n\t\t\t\t\t FMTADDR(s->local_addr), FMTADDR(s->peer_addr)));\n\n\t\t\t\tclose(s->fd);\n\t\t\t\ts->fd = -1;\n\n\t\t\t\t/* Cannot move to free list with only\n\t\t\t\t * rdlock on list_rwlock, queue on a\n\t\t\t\t * local list */\n\t\t\t\tLIST_INSERT_HEAD(&closing_queue, s, rx_queue);\n\n\t\t\t\tput_sock(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (s->state != SOCK_CONNECTED || !poll_socks) {\n\t\t\t\tput_sock(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (s->local_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_TX)\n\t\t\t\tpolling = false;\n\n\t\t\tif (s->peer_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_RX)\n\t\t\t\tpolling = false;\n\n\t\t\tif (s->credit_update_required)\n\t\t\t\tpending_credit_updates = true;\n\n\t\t\tassert(s->fd >= 0);\n\t\t\tpeer_free = s->peer_buf_alloc - (s->rx_cnt - s->peer_fwd_cnt);\n\t\t\tDPRINTF((\"RX: sock %p (%d): peer free = %\"PRId32\"\\n\",\n\t\t\t\t (void*)s, s->fd, peer_free));\n\t\t\tif (peer_free == 0)\n\t\t\t\tpolling = false;\n\n\t\t\tif (polling) {\n\t\t\t\tFD_SET(s->fd, &rfd);\n\t\t\t\tmaxfd = max_fd(s->fd, maxfd);\n\t\t\t\tnrfd++;\n\t\t\t}\n\n\t\t\tif (polling || s->credit_update_required)\n\t\t\t\tLIST_INSERT_HEAD(&queue, s, rx_queue);\n\n\t\t\tput_sock(s);\n\t\t}\n\t\tpthread_rwlock_unlock(&sc->list_rwlock);\n\n\t\tif (!LIST_EMPTY(&closing_queue)) {\n\t\t\tpthread_rwlock_wrlock(&sc->list_rwlock);\n\n\t\t\tLIST_FOREACH(s, &closing_queue, rx_queue) {\n\t\t\t\tget_sock(s);\n\t\t\t\tfree_sock(sc, s);\n\t\t\t}\n\n\t\t\tpthread_rwlock_unlock(&sc->list_rwlock);\n\t\t}\n\n\t\t/* Unlocked during select */\n\t\tassert(maxfd < FD_SETSIZE);\n\n\t\tDPRINTF((\"RX: *** thread selecting on %d fds (socks: %s)\\n\",\n\t\t\t nrfd, poll_socks ? \"yes\" : \"no\"));\n\n\t\t/*\n\t\t * If we have pending_credit_updates then pass zero\n\t\t * timeout to poll the fds but don't block so we will\n\t\t * immediately handle whatever work we can, including\n\t\t * the pending credit updates.\n\t\t */\n\t\tnr = xselect(\"RX\", maxfd + 1, &rfd, NULL, NULL,\n\t\t\t    pending_credit_updates ? &zero_timeout : NULL);\n\t\tif (nr < 0) continue;\n\t\tDPRINTF((\"RX:\\nRX: *** %d/%d fds are readable (descs: %s)\\n\",\n\t\t\t nr, nrfd, vq_has_descs(vq) ? \"yes\" : \"no\"));\n\n\t\tif (FD_ISSET(sc->rx_wake_fd, &rfd)) {\n\t\t\t/* Eat the notification(s) */\n\t\t\tchar dummy[128];\n\t\t\tssize_t rd_dummy = read(sc->rx_wake_fd, &dummy, 128);\n\t\t\tassert(rd_dummy >= 1);\n\t\t\t/* Restart select now that we have some\n\t\t\t * descriptors. It's possible that synchronous\n\t\t\t * responses sent from the tx thread have\n\t\t\t * eaten them all though, so check.\n\t\t\t */\n\t\t\tDPRINTF((\"RX: thread got %zd kicks (have descs: %s)\\n\",\n\t\t\t\t rd_dummy, vq_has_descs(vq) ? \"yes\" : \"no\"));\n\n// XXX need to check sockets in order to process the reply ring, so\n// cannot make this tempting looking optimisation.\n//\n//\t\t\tif (nr == 1) {\n//\t\t\t\t /* Must have been the kicker fd, in\n//\t\t\t\t  * which case there is no point\n//\t\t\t\t  * checking the socks.\n//\t\t\t\t  */\n//\t\t\t\tDPRINTF((\"RX: Kicked w/ no other fds -- restarting select()\\n\"));\n//\t\t\t\tgoto rx_done;\n//\t\t\t}\n\n\t\t\t/* We might have some descriptors, so it might be worth polling the socks again */\n\t\t\tpoll_socks = true;\n\t\t}\n\n\t\tif (!vq_has_descs(vq)) {\n\t\t\tDPRINTF((\"RX: No descs -- restarting select()\\n\"));\n\t\t\tpoll_socks = false; /* Don't poll socks next time */\n\t\t\tgoto rx_done;\n\t\t}\n\n\t\twhile (did_some_work) {\n\t\t\tint nr_data_rx = 0;\n\t\t\tbool more_replies_pending = true; /* Assume there is */\n\t\t\tdid_some_work = false;\n\n\t\t\tDPRINTF((\"RX: Handling pending replies first\\n\"));\n\t\t\tpthread_mutex_lock(&sc->reply_mtx);\n\t\t\twhile (vq_has_descs(vq)) {\n\t\t\t\tmore_replies_pending = rx_do_one_reply(sc, vq);\n\t\t\t\tif (!more_replies_pending) break;\n\t\t\t\tdid_some_work = true;\n\t\t\t}\n\t\t\tpthread_mutex_unlock(&sc->reply_mtx);\n\n\t\t\tif (more_replies_pending) {\n\t\t\t\tDPRINTF((\"RX: No more descriptors for pending replies\\n\"));\n\t\t\t\tpoll_socks = false; /* Still replies to send, so don't handle socks yet */\n\t\t\t\tvq_endchains(vq, 1);\n\t\t\t\tgoto rx_done;\n\t\t\t}\n\n\t\t\tDPRINTF((\"RX: Checking all socks\\n\"));\n\n\t\t\tLIST_FOREACH_SAFE(s, &queue, rx_queue, ts) {\n\t\t\t\t/*\n\t\t\t\t * Check for new replies in the reply\n\t\t\t\t * ring frequently in order to avoid\n\t\t\t\t * possible deadlock due to filling\n\t\t\t\t * both vrings with data leaving no\n\t\t\t\t * space for replies. See \"Virtqueue\n\t\t\t\t * Flow Control\" in the spec.\n\t\t\t\t */\n\t\t\t\tif (nr_data_rx++ >= 8) {\n\t\t\t\t\tbool replies_pending;\n\t\t\t\t\tpthread_mutex_lock(&sc->reply_mtx);\n\t\t\t\t\treplies_pending = !REPLY_RING_EMPTY(sc);\n\t\t\t\t\tpthread_mutex_unlock(&sc->reply_mtx);\n\t\t\t\t\tif (replies_pending) break;\n\t\t\t\t}\n\n\t\t\t\tget_sock(s);\n\n\t\t\t\tif (s->state != SOCK_CONNECTED) {\n\t\t\t\t\tLIST_REMOVE(s, rx_queue);\n\t\t\t\t\tput_sock(s);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassert(s->fd >= 0);\n\n\t\t\t\tif (FD_ISSET(s->fd, &rfd)) {\n\t\t\t\t\tssize_t bytes;\n\t\t\t\t\tDPRINTF((\"RX: event on sock %p fd %d\\n\",\n\t\t\t\t\t\t (void *)s, s->fd));\n\t\t\t\t\tbytes = pci_vtsock_proc_rx(sc, vq, s);\n\t\t\t\t\tif (bytes == -1) {\n\t\t\t\t\t\t/* Consumed all descriptors, stop */\n\t\t\t\t\t\tDPRINTF((\"RX: No more descriptors\\n\"));\n\t\t\t\t\t\tvq_endchains(vq, 1);\n\t\t\t\t\t\tput_sock(s);\n\t\t\t\t\t\tgoto rx_done;\n\t\t\t\t\t} else if (bytes == 0) {\n\t\t\t\t\t\tLIST_REMOVE(s, rx_queue);\n\t\t\t\t\t\tFD_CLR(s->fd, &rfd);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdid_some_work = true;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * If proc_rx returned >= 0\n\t\t\t\t\t * then it is guaranteed to\n\t\t\t\t\t * have sent something and\n\t\t\t\t\t * thus a credit update is no\n\t\t\t\t\t * longer required. We have\n\t\t\t\t\t * handled the < 0 case above.\n\t\t\t\t\t */\n\t\t\t\t\tassert(s->credit_update_required == false);\n\t\t\t\t} else if (s->credit_update_required) {\n\t\t\t\t\tif (send_credit_update(vq, s)) {\n\t\t\t\t\t\ts->credit_update_required = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Consumed all descriptors, stop */\n\t\t\t\t\t\tDPRINTF((\"RX: No more descriptors\\n\"));\n\t\t\t\t\t\tvq_endchains(vq, 1);\n\t\t\t\t\t\tput_sock(s);\n\t\t\t\t\t\tgoto rx_done;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* Was nothing to do */\n\t\t\t\t\tLIST_REMOVE(s, rx_queue);\n\t\t\t\t}\n\n\t\t\t\tput_sock(s);\n\t\t\t}\n\t\t}\n\n\t\tDPRINTF((\"RX: All work complete\\n\"));\n\t\tvq_endchains(vq, 0);\n\t}\n}\n\n\nstatic void pci_vtsock_notify_rx(void *vsc, struct vqueue_info *vq)\n{\n\tstruct pci_vtsock_softc *sc = vsc;\n\n\tassert(vq == &sc->vssc_vqs[VTSOCK_QUEUE_RX]);\n\tassert(sc->rx_wake_fd >= 0);\n\n\tkick_rx(sc, \"notify\");\n}\n\nstatic void pci_vtsock_notify_evt(void *vsc, struct vqueue_info *vq)\n{\n\tstruct pci_vtsock_softc *sc = vsc;\n\n\tDPRINTF((\"vtsock: evt notify sc=%p vq=%zd(%p)\\n\",\n\t\t (void *)sc, vq - &sc->vssc_vqs[VTSOCK_QUEUE_RX], (void *)vq));\n}\n\nstatic int listen_un(struct sockaddr_un *un)\n{\n\tint fd, rc;\n\n\trc = unlink(un->sun_path);\n\tif (rc < 0 && errno != ENOENT) {\n\t\tperror(\"Failed to unlink unix socket path\");\n\t\treturn -1;\n\t}\n\n\tfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (fd < 0) {\n\t\tperror(\"Failed to open unix socket\");\n\t\treturn -1;\n\t}\n\n\trc = bind(fd, (struct sockaddr *)un, sizeof(*un));\n\tif (rc < 0) {\n\t\tperror(\"Failed to bind() unix socket\");\n\t\treturn -1;\n\t}\n\n\trc = listen(fd, SOMAXCONN);\n\tif (rc < 0) {\n\t\tperror(\"Failed to listen() unix socket\");\n\t\treturn -1;\n\t}\n\n\t/* XXX Any chown/chmod needed? */\n\n\trc = fcntl(fd, F_SETFL, O_NONBLOCK);\n\tif (rc < 0) {\n\t\tperror(\"O_NONBLOCK failed for unix socket\\n\");\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n\nstatic int open_connect_socket(struct pci_vtsock_softc *sc)\n{\n\tstruct sockaddr_un un;\n\tint fd, rc;\n\n\tassert(sc->connect_fd == -1);\n\n\tbzero(&un, sizeof(un));\n\n\tun.sun_len = 0; /* Unused? */\n\tun.sun_family = AF_UNIX;\n\trc = snprintf(un.sun_path, sizeof(un.sun_path),\n\t\t     \"%s/\"CONNECT_SOCKET_NAME, sc->path);\n\tif (rc < 0) {\n\t\tperror(\"Failed to format connect socket path\");\n\t\treturn 1;\n\t}\n\tDPRINTF((\"Connect socket is %s\\n\", un.sun_path));\n\n\tfd = listen_un(&un);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"failed to open connect socket\\n\");\n\t\treturn 1;\n\t}\n\n\tsc->connect_fd = fd;\n\tassert(sc->connect_fd < FD_SETSIZE);\n\n\tDPRINTF((\"Connect socket %s is fd %d\\n\", un.sun_path, fd));\n\n\treturn 0;\n}\n\nstatic int open_one_forward_socket(struct pci_vtsock_softc *sc, uint32_t port)\n{\n\tstruct sockaddr_un un, sl;\n\tstruct pci_vtsock_forward *fwd;\n\tint fd, rc;\n\n\tif (sc->nr_fwds == VTSOCK_MAXFWDS)  {\n\t\tfprintf(stderr, \"Too many forwards\\n\");\n\t\treturn 1;\n\t}\n\n\tfwd = &sc->fwds[sc->nr_fwds++];\n\tassert(fwd->listen_fd == -1);\n\n\tbzero(&un, sizeof(un));\n\n\tun.sun_len = 0; /* Unused? */\n\tun.sun_family = AF_UNIX;\n\trc = snprintf(un.sun_path, sizeof(un.sun_path),\n\t\t     \"%s/\"PRIaddr, sc->path, sc->vssc_cfg.guest_cid, port);\n\tif (rc < 0) {\n\t\tperror(\"Failed to format forward socket path\");\n\t\treturn 1;\n\t}\n\trc = snprintf(sl.sun_path, sizeof(sl.sun_path),\n\t\t     \"%s/guest.\"PRIport, sc->path, port);\n\tif (rc < 0) {\n\t\tperror(\"Failed to format forward socket symlink path\");\n\t\treturn 1;\n\t}\n\n\trc = unlink(sl.sun_path);\n\tif (rc < 0 && errno != ENOENT) {\n\t\tperror(\"Failed to unlink forward socket symlink path\");\n\t\treturn 1;\n\t}\n\n\tfd = listen_un(&un);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed to open forward socket\\n\");\n\t\treturn 1;\n\t}\n\n\trc = symlink(&un.sun_path[strlen(sc->path) + 1], sl.sun_path);\n\tif (rc < 0) {\n\t\tperror(\"Failed to create forward socket symlink\\n\");\n\t\tclose(fd);\n\t\treturn 1;\n\t}\n\n\tfwd->listen_fd = fd;\n\tassert(fwd->listen_fd < FD_SETSIZE);\n\n\tfwd->port = port;\n\n\tDPRINTF((\"forwarding port %\"PRId32\" to the guest\\n\", port));\n\n\treturn 0;\n}\n\nstatic int open_forward_sockets(struct pci_vtsock_softc *sc,\n\t\t\t\tchar *guest_forwards)\n{\n\tchar *s = guest_forwards, *e;\n\tint rc;\n\n\tif (!guest_forwards) return 0;\n\n\twhile (*s != '\\0') {\n\t\tunsigned long ul;\n\n\t\trc = 1;\n\t\terrno = 0;\n\t\tul = strtoul(s, &e, 0);\n\n\t\tif (errno) {\n\t\t\tfprintf(stderr, \"failed to parse forward \\\"%s\\\": %s\\n\",\n\t\t\t\ts, strerror(errno));\n\t\t\tgoto err;\n\t\t}\n\t\tif (ul >= UINT32_MAX) {\n\t\t\tfprintf(stderr, \"invalid guest port forward %ld\\n\", ul);\n\t\t\tgoto err;\n\t\t}\n\n\t\trc = open_one_forward_socket(sc, (uint32_t)ul);\n\t\tif (rc) goto err;\n\n\t\ts = e;\n\t\tif (*s == ';') s++;\n\t}\n\n\trc = 0;\nerr:\n\tfree(guest_forwards);\n\treturn rc;\n\n}\n\nstatic int pci_vtsock_cfgread(void *, int, int, uint32_t *);\nstatic int pci_vtsock_cfgwrite(void *, int, int, uint32_t);\n\nstatic char *\ncopy_up_to_comma(const char *from)\n{\n\tchar *comma = strchr(from, ',');\n\tchar *tmp = NULL;\n\tif (comma == NULL) {\n\t\ttmp = strdup(from); /* rest of string */\n\t} else {\n\t\tsize_t length = (size_t)(comma - from);\n\t\ttmp = strndup(from, length);\n\t}\n\treturn tmp;\n}\n\nstatic int\npci_vtsock_init(struct pci_devinst *pi, char *opts)\n{\n\tuint64_t guest_cid = VMADDR_CID_ANY;\n\tconst char *path = NULL;\n\tchar *guest_forwards = NULL;\n\tstruct pci_vtsock_softc *sc;\n\tstruct sockaddr_un un;\n\tint i, pipefds[2];\n\n\tif (opts == NULL) {\n\t\tprintf(\"virtio-sock: configuration required\\n\");\n\t\treturn (1);\n\t}\n\n\twhile (1) {\n\t\tchar *next;\n\t\tif (! opts)\n\t\t\tbreak;\n\t\tnext = strchr(opts, ',');\n\t\tif (next)\n\t\t\tnext[0] = '\\0';\n\t\tif (strncmp(opts, \"guest_cid=\", 10) == 0) {\n\t\t\tint tmp = atoi(&opts[10]);\n\t\t\tif (tmp <= 0) {\n\t\t\t\tfprintf(stderr, \"bad guest cid: %s\\r\\n\", opts);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tguest_cid = (uint32_t)tmp;\n\t\t} else if (strncmp(opts, \"path=\", 5) == 0) {\n\t\t\tpath = copy_up_to_comma(opts + 5);\n\t\t} else if (strncmp(opts, \"guest_forwards=\", 15) == 0) {\n\t\t\tguest_forwards = copy_up_to_comma(opts + 15);\n\t\t} else {\n\t\t\tfprintf(stderr, \"invalid option: %s\\r\\n\", opts);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (! next)\n\t\t\tbreak;\n\t\topts = &next[1];\n\t}\n\tif (guest_cid == VMADDR_CID_ANY || path == NULL) {\n\t\tfprintf(stderr, \"guest_cid and path options are both required.\\n\");\n\t\treturn 1;\n\t}\n\n\tif (guest_cid <= VMADDR_CID_HOST || guest_cid >= VMADDR_CID_MAX) {\n\t\tfprintf(stderr, \"invalid guest_cid \"PRIcid\"\\n\", guest_cid);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * We need to be able to construct socket paths of the form\n\t * \"%08x.%08x\" cid,port.\n\t */\n\tif (strlen(path) + sizeof(\"/00000000.00000000\") > sizeof(un.sun_path)) {\n\t\tprintf(\"virtio-sock: path too long\\n\");\n\t\treturn (1);\n\t}\n\n\t/* XXX confirm path exists and is a directory */\n\n\tfprintf(stderr, \"vsock init %d:%d = %s, guest_cid = \"PRIcid\"\\n\\r\",\n\t\tpi->pi_slot, pi->pi_func, path, guest_cid);\n\n\tsc = calloc(1, sizeof(struct pci_vtsock_softc));\n\n\tLIST_INIT(&sc->free_list);\n\tLIST_INIT(&sc->inuse_list);\n\n\tfor (i = 0; i < VTSOCK_MAXSOCKS; i++) {\n\t\tstruct pci_vtsock_sock *str = &sc->socks[i];\n\t\tint err = pthread_mutex_init(&str->mtx, NULL);\n\t\tassert(err == 0);\n\t\tstr->state = SOCK_FREE;\n\t\tstr->fd = -1;\n\t\tstr->port_generation = 0;\n\t\tLIST_INSERT_HEAD(&sc->free_list, str, list);\n\t}\n\n\tsc->nr_fwds = 0;\n\tfor (i = 0; i < VTSOCK_MAXFWDS; i++) {\n\t\tstruct pci_vtsock_forward *fwd = &sc->fwds[i];\n\t\tfwd->listen_fd = -1;\n\t}\n\n\tpthread_mutex_init(&sc->vssc_mtx, NULL);\n\tpthread_mutex_init(&sc->reply_mtx, NULL);\n\tpthread_rwlock_init(&sc->list_rwlock, NULL);\n\n\tsc->path = strdup(path);\n\n\t/* init virtio softc and virtqueues */\n\tvi_softc_linkup(&sc->vssc_vs, &vtsock_vi_consts, sc, pi, sc->vssc_vqs);\n\tsc->vssc_vs.vs_mtx = &sc->vssc_mtx;\n\n\tsc->vssc_vqs[VTSOCK_QUEUE_RX].vq_qsize = VTSOCK_RINGSZ;\n\tsc->vssc_vqs[VTSOCK_QUEUE_RX].vq_notify = pci_vtsock_notify_rx;\n\n\tsc->vssc_vqs[VTSOCK_QUEUE_TX].vq_qsize = VTSOCK_RINGSZ;\n\tsc->vssc_vqs[VTSOCK_QUEUE_TX].vq_notify = pci_vtsock_notify_tx;\n\n\t/* Unused, make it small */\n\tsc->vssc_vqs[VTSOCK_QUEUE_EVT].vq_qsize = 4;\n\tsc->vssc_vqs[VTSOCK_QUEUE_EVT].vq_notify = pci_vtsock_notify_evt;\n\n\t/* setup virtio sock config space */\n\tsc->vssc_cfg.guest_cid = guest_cid;\n\n\t/*\n\t * Should we move some of this into virtio.c?  Could\n\t * have the device, class, and subdev_0 as fields in\n\t * the virtio constants structure.\n\t */\n\tpci_set_cfgdata16(pi, PCIR_DEVICE, VIRTIO_DEV_SOCK);\n\tpci_set_cfgdata16(pi, PCIR_VENDOR, VIRTIO_VENDOR);\n\tpci_set_cfgdata8(pi, PCIR_REVID, 0 /*LEGACY 1*/);\n\tpci_set_cfgdata8(pi, PCIR_CLASS, PCIC_NETWORK);\n\tpci_set_cfgdata16(pi, PCIR_SUBDEV_0, VIRTIO_TYPE_SOCK);\n\tpci_set_cfgdata16(pi, PCIR_SUBVEND_0, VIRTIO_VENDOR);\n\n\tif (vi_intr_init(&sc->vssc_vs, 1, fbsdrun_virtio_msix()))\n\t\treturn (1);\n\tvi_set_io_bar(&sc->vssc_vs, 0);\n\n\tsc->connect_fd = -1;\n\tif (open_connect_socket(sc))\n\t\treturn (1);\n\n\tif (open_forward_sockets(sc, guest_forwards))\n\t\treturn (1);\n\n\tif (pipe(pipefds))\n\t\treturn (1);\n\tsc->tx_wake_fd = pipefds[0];\n\tsc->tx_kick_fd = pipefds[1];\n\n\tassert(sc->tx_wake_fd < FD_SETSIZE);\n\n\tsc->rx_kick_pending = false;\n\n\tif (pthread_create(&sc->tx_thread, NULL,\n\t\t\t   pci_vtsock_tx_thread, sc))\n\t\treturn (1);\n\n\tif (pipe(pipefds))\n\t\treturn (1);\n\tsc->rx_wake_fd = pipefds[0];\n\tsc->rx_kick_fd = pipefds[1];\n\n\tassert(sc->rx_wake_fd < FD_SETSIZE);\n\n\tsc->reply_prod = 0;\n\tsc->reply_cons = 0;\n\n\tif (pthread_create(&sc->rx_thread, NULL,\n\t\t\t   pci_vtsock_rx_thread, sc))\n\t\treturn (1);\n\n\treturn (0);\n}\n\nstatic int\npci_vtsock_cfgwrite(UNUSED void *vsc, int offset, UNUSED int size,\n\tUNUSED uint32_t value)\n{\n\tDPRINTF((\"vtsock: write to readonly reg %d\\n\\r\", offset));\n\treturn (1);\n}\n\nstatic int\npci_vtsock_cfgread(void *vsc, int offset, int size, uint32_t *retval)\n{\n\tstruct pci_vtsock_softc *sc = vsc;\n\tvoid *ptr;\n\n\tDPRINTF((\"vtsock: %d byte read pci reg %d\\n\\r\", size, offset));\n\n\t/* our caller has already verified offset and size */\n\tptr = (uint8_t *)&sc->vssc_cfg + offset;\n\tmemcpy(retval, ptr, size);\n\treturn (0);\n}\n\nstatic struct pci_devemu pci_de_vsock = {\n\t.pe_emu =\t\"virtio-sock\",\n\t.pe_init =\tpci_vtsock_init,\n\t.pe_barwrite =\tvi_pci_write,\n\t.pe_barread =\tvi_pci_read\n};\nPCI_EMUL_SET(pci_de_vsock);\n"], "filenames": ["src/lib/pci_virtio_sock.c"], "buggy_code_start_loc": [1123], "buggy_code_end_loc": [1123], "fixing_code_start_loc": [1124], "fixing_code_end_loc": [1129], "type": "CWE-908", "message": "HyperKit is a toolkit for embedding hypervisor capabilities in an application. In versions 0.20210107, function `pci_vtsock_proc_tx` in `virtio-sock` can lead to to uninitialized memory use. In this situation, there is a check for the return value to be less or equal to `VTSOCK_MAXSEGS`, but that check is not sufficient because the function can return `-1` if it finds an error it cannot recover from. Moreover, the negative return value will be used by `iovec_pull` in a while condition that can further lead to more corruption because the function is not designed to handle a negative `iov_len`. This issue may lead to a guest crashing the host causing a denial of service and, under certain circumstance, memory corruption. This issue is fixed in commit af5eba2360a7351c08dfd9767d9be863a50ebaba.", "other": {"cve": {"id": "CVE-2021-32846", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-17T23:15:12.037", "lastModified": "2023-02-28T20:28:54.537", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "HyperKit is a toolkit for embedding hypervisor capabilities in an application. In versions 0.20210107, function `pci_vtsock_proc_tx` in `virtio-sock` can lead to to uninitialized memory use. In this situation, there is a check for the return value to be less or equal to `VTSOCK_MAXSEGS`, but that check is not sufficient because the function can return `-1` if it finds an error it cannot recover from. Moreover, the negative return value will be used by `iovec_pull` in a while condition that can further lead to more corruption because the function is not designed to handle a negative `iov_len`. This issue may lead to a guest crashing the host causing a denial of service and, under certain circumstance, memory corruption. This issue is fixed in commit af5eba2360a7351c08dfd9767d9be863a50ebaba."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.5, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-908"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-908"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mobyproject:hyperkit:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.20210107", "matchCriteriaId": "0AE32831-24E2-44FD-939C-E6F799A5D632"}]}]}], "references": [{"url": "https://github.com/moby/hyperkit/commit/af5eba2360a7351c08dfd9767d9be863a50ebaba", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/moby/hyperkit/pull/313", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://securitylab.github.com/advisories/GHSL-2021-054_057-moby-hyperkit/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/moby/hyperkit/commit/af5eba2360a7351c08dfd9767d9be863a50ebaba"}}