{"buggy_code": ["/*\n  The code below is mostly derived from cx_bsdiff (written by Anthony\n  Tuininga, http://cx-bsdiff.sourceforge.net/).  The cx_bsdiff code in\n  turn was derived from bsdiff, the standalone utility produced for BSD\n  which can be found at http://www.daemonology.net/bsdiff.\n*/\n\n#define PY_SSIZE_T_CLEAN\n#include <Python.h>\n\n#if PY_MAJOR_VERSION >= 3\n#define IS_PY3K\n#endif\n\n\n#define MIN(x, y)  (((x) < (y)) ? (x) : (y))\n\n\nstatic void split(off_t *I, off_t *V, off_t start, off_t len, off_t h)\n{\n    off_t i, j, k, x, tmp, jj, kk;\n\n    if (len < 16) {\n        for (k = start; k < start + len; k += j) {\n            j = 1;\n            x = V[I[k] + h];\n            for (i = 1; k + i < start + len; i++) {\n                if (V[I[k + i] + h] < x) {\n                    x = V[I[k + i] + h];\n                    j = 0;\n                }\n                if (V[I[k + i] + h] == x) {\n                    tmp = I[k + j];\n                    I[k + j] = I[k + i];\n                    I[k + i] = tmp;\n                    j++;\n                }\n            }\n            for (i = 0; i < j; i++)\n                V[I[k + i]] = k + j - 1;\n            if (j == 1)\n                I[k] = -1;\n        }\n\n    } else {\n\n        jj = 0;\n        kk = 0;\n        x = V[I[start + len / 2] + h];\n        for (i = start; i < start + len; i++) {\n            if (V[I[i] + h] < x)\n                jj++;\n            if (V[I[i] + h] == x)\n                kk++;\n        }\n        jj += start;\n        kk += jj;\n\n        j = 0;\n        k = 0;\n        i = start;\n        while (i < jj) {\n            if (V[I[i] + h] < x) {\n                i++;\n            } else if (V[I[i] + h] == x) {\n                tmp = I[i];\n                I[i] = I[jj + j];\n                I[jj + j] = tmp;\n                j++;\n            } else {\n                tmp = I[i];\n                I[i] = I[kk + k];\n                I[kk + k] = tmp;\n                k++;\n            }\n        }\n\n        while (jj + j < kk) {\n            if (V[I[jj + j] + h] == x) {\n                j++;\n            } else {\n                tmp = I[jj + j];\n                I[jj + j] = I[kk + k];\n                I[kk + k] = tmp;\n                k++;\n            }\n        }\n\n        if (jj > start)\n            split(I, V, start, jj - start, h);\n\n        for (i = 0; i < kk - jj; i++)\n            V[I[jj + i]] = kk - 1;\n        if (jj == kk - 1)\n            I[jj] = -1;\n        if (start + len > kk)\n            split(I, V, kk, start + len - kk, h);\n    }\n}\n\n\nstatic void qsufsort(off_t *I, off_t *V, unsigned char *old, off_t oldsize)\n{\n    off_t buckets[256], i, h, len;\n\n    for (i = 0; i < 256; i++)\n        buckets[i] = 0;\n    for (i = 0; i < oldsize; i++)\n        buckets[old[i]]++;\n    for (i = 1; i < 256; i++)\n        buckets[i] += buckets[i - 1];\n    for (i = 255; i > 0; i--)\n        buckets[i] = buckets[i - 1];\n    buckets[0] = 0;\n\n    for (i = 0; i < oldsize; i++)\n        I[++buckets[old[i]]] = i;\n    I[0] = oldsize;\n    for (i = 0; i < oldsize; i++)\n        V[i] = buckets[old[i]];\n    V[oldsize] = 0;\n    for (i = 1; i < 256; i++)\n        if (buckets[i] == buckets[i - 1] + 1)\n            I[buckets[i]] = -1;\n    I[0] = -1;\n\n    for (h = 1; I[0] != -(oldsize + 1); h += h) {\n        len = 0;\n        for (i = 0; i < oldsize + 1;) {\n            if (I[i] < 0) {\n                len -= I[i];\n                i -= I[i];\n            } else {\n                if (len)\n                    I[i - len] = -len;\n                len = V[I[i]] + 1 - i;\n                split(I, V, i, len, h);\n                i += len;\n                len=0;\n            }\n        }\n        if (len)\n            I[i - len] = -len;\n    }\n\n    for (i = 0; i < oldsize + 1; i++)\n        I[V[i]] = i;\n}\n\n\nstatic off_t matchlen(unsigned char *old, off_t oldsize,\n                      unsigned char *new, off_t newsize)\n{\n    off_t i;\n\n    for (i = 0; (i < oldsize) && (i < newsize); i++)\n        if (old[i] != new[i])\n            break;\n    return i;\n}\n\n\nstatic off_t search(off_t *I,\n                    unsigned char *old, off_t oldsize,\n                    unsigned char *new, off_t newsize,\n                    off_t st, off_t en, off_t *pos)\n{\n    off_t x, y;\n\n    if (en - st < 2) {\n        x = matchlen(old + I[st], oldsize - I[st], new, newsize);\n        y = matchlen(old + I[en], oldsize - I[en], new, newsize);\n\n        if (x > y) {\n            *pos = I[st];\n            return x;\n        } else {\n            *pos = I[en];\n            return y;\n        }\n    }\n\n    x = st + (en - st) / 2;\n    if (memcmp(old + I[x], new, MIN(oldsize - I[x], newsize)) < 0) {\n        return search(I, old, oldsize, new, newsize, x, en, pos);\n    } else {\n        return search(I, old, oldsize, new, newsize, st, x, pos);\n    }\n}\n\n\n/* performs a diff between the two data streams and returns a tuple\n   containing the control, diff and extra blocks that bsdiff produces\n*/\nstatic PyObject* diff(PyObject* self, PyObject* args)\n{\n    off_t lastscan, lastpos, lastoffset, oldscore, scsc, overlap, Ss, lens;\n    off_t *I, *V, dblen, eblen, scan, pos, len, s, Sf, lenf, Sb, lenb, i;\n    PyObject *controlTuples, *tuple, *results, *temp;\n    Py_ssize_t origDataLength, newDataLength;\n    char *origData, *newData;\n    unsigned char *db, *eb;\n\n    if (!PyArg_ParseTuple(args, \"s#s#\",\n                          &origData, &origDataLength,\n                          &newData, &newDataLength))\n        return NULL;\n\n    /* create the control tuple */\n    controlTuples = PyList_New(0);\n    if (!controlTuples)\n        return NULL;\n\n    /* perform sort on original data */\n    I = PyMem_Malloc((origDataLength + 1) * sizeof(off_t));\n    if (!I) {\n        Py_DECREF(controlTuples);\n        return PyErr_NoMemory();\n    }\n    V = PyMem_Malloc((origDataLength + 1) * sizeof(off_t));\n    if (!V) {\n        Py_DECREF(controlTuples);\n        PyMem_Free(I);\n        return PyErr_NoMemory();\n    }\n    Py_BEGIN_ALLOW_THREADS  /* release GIL */\n    qsufsort(I, V, (unsigned char *) origData, origDataLength);\n    Py_END_ALLOW_THREADS\n    PyMem_Free(V);\n\n    /* allocate memory for the diff and extra blocks */\n    db = PyMem_Malloc(newDataLength + 1);\n    if (!db) {\n        Py_DECREF(controlTuples);\n        PyMem_Free(I);\n        return PyErr_NoMemory();\n    }\n    eb = PyMem_Malloc(newDataLength + 1);\n    if (!eb) {\n        Py_DECREF(controlTuples);\n        PyMem_Free(I);\n        PyMem_Free(db);\n        return PyErr_NoMemory();\n    }\n    dblen = 0;\n    eblen = 0;\n\n    /* perform the diff */\n    len = 0;\n    scan = 0;\n    lastscan = 0;\n    lastpos = 0;\n    lastoffset = 0;\n    pos = 0;\n    while (scan < newDataLength) {\n        oldscore = 0;\n\n        Py_BEGIN_ALLOW_THREADS  /* release GIL */\n        for (scsc = scan += len; scan < newDataLength; scan++) {\n            len = search(I, (unsigned char *) origData, origDataLength,\n                         (unsigned char *) newData + scan,\n                         newDataLength - scan, 0, origDataLength, &pos);\n            for (; scsc < scan + len; scsc++)\n                if ((scsc + lastoffset < origDataLength) &&\n                          (origData[scsc + lastoffset] == newData[scsc]))\n                    oldscore++;\n            if (((len == oldscore) && (len != 0)) || (len > oldscore + 8))\n                break;\n            if ((scan + lastoffset < origDataLength) &&\n                      (origData[scan + lastoffset] == newData[scan]))\n                oldscore--;\n        }\n        Py_END_ALLOW_THREADS\n\n        if ((len != oldscore) || (scan == newDataLength)) {\n            s = 0;\n            Sf = 0;\n            lenf = 0;\n            for (i = 0; (lastscan + i < scan) &&\n                     (lastpos + i < origDataLength);) {\n                if (origData[lastpos + i] == newData[lastscan + i])\n                    s++;\n                i++;\n                if (s * 2 - i > Sf * 2 - lenf) {\n                    Sf = s;\n                    lenf = i;\n                }\n            }\n\n            lenb = 0;\n            if (scan < newDataLength) {\n                s = 0;\n                Sb = 0;\n                for (i = 1; (scan >= lastscan + i) && (pos >= i); i++) {\n                    if (origData[pos - i] == newData[scan - i])\n                        s++;\n                    if (s * 2 - i > Sb * 2 - lenb) {\n                        Sb = s;\n                        lenb = i;\n                    }\n                }\n            }\n\n            if (lastscan + lenf > scan - lenb) {\n                overlap = (lastscan + lenf) - (scan - lenb);\n                s = 0;\n                Ss = 0;\n                lens = 0;\n                for (i = 0; i < overlap; i++) {\n                    if (newData[lastscan + lenf - overlap + i] ==\n                            origData[lastpos + lenf - overlap + i])\n                        s++;\n                    if (newData[scan - lenb + i]== origData[pos - lenb + i])\n                        s--;\n                    if (s > Ss) {\n                        Ss = s;\n                        lens = i + 1;\n                    }\n                }\n\n                lenf += lens - overlap;\n                lenb -= lens;\n            }\n\n            for (i = 0; i < lenf; i++)\n                db[dblen + i] = newData[lastscan + i] - origData[lastpos + i];\n            for (i = 0; i < (scan - lenb) - (lastscan + lenf); i++)\n                eb[eblen + i] = newData[lastscan + lenf + i];\n\n            dblen += lenf;\n            eblen += (scan - lenb) - (lastscan + lenf);\n\n            tuple = PyTuple_New(3);\n            if (!tuple) {\n                Py_DECREF(controlTuples);\n                PyMem_Free(I);\n                PyMem_Free(db);\n                PyMem_Free(eb);\n                return NULL;\n            }\n            PyTuple_SET_ITEM(tuple, 0, PyLong_FromLong(lenf));\n            PyTuple_SET_ITEM(tuple, 1,\n                    PyLong_FromLong((scan - lenb) - (lastscan + lenf)));\n            PyTuple_SET_ITEM(tuple, 2,\n                    PyLong_FromLong((pos - lenb) - (lastpos + lenf)));\n            if (PyList_Append(controlTuples, tuple) < 0) {\n                Py_DECREF(controlTuples);\n                Py_DECREF(tuple);\n                PyMem_Free(I);\n                PyMem_Free(db);\n                PyMem_Free(eb);\n                return NULL;\n            }\n            Py_DECREF(tuple);\n\n            lastscan = scan - lenb;\n            lastpos = pos - lenb;\n            lastoffset = pos - scan;\n        }\n    }\n\n    PyMem_Free(I);\n    results = PyTuple_New(3);\n    if (!results) {\n        PyMem_Free(db);\n        PyMem_Free(eb);\n        return NULL;\n    }\n    PyTuple_SET_ITEM(results, 0, controlTuples);\n    temp = PyBytes_FromStringAndSize((char *) db, dblen);\n    PyMem_Free(db);\n    if (!temp) {\n        PyMem_Free(eb);\n        Py_DECREF(results);\n        return NULL;\n    }\n    PyTuple_SET_ITEM(results, 1, temp);\n    temp = PyBytes_FromStringAndSize((char *) eb, eblen);\n    PyMem_Free(eb);\n    if (!temp) {\n        Py_DECREF(results);\n        return NULL;\n    }\n    PyTuple_SET_ITEM(results, 2, temp);\n\n    return results;\n}\n\n\n/* takes the original data and the control, diff and extra blocks produced\n   by bsdiff and returns the new data\n*/\nstatic PyObject* patch(PyObject* self, PyObject* args)\n{\n    char *origData, *newData, *diffBlock, *extraBlock, *diffPtr, *extraPtr;\n    Py_ssize_t origDataLength, newDataLength, diffBlockLength, extraBlockLength;\n    PyObject *controlTuples, *tuple, *results;\n    off_t oldpos, newpos, x, y, z;\n    int i, j, numTuples;\n\n    if (!PyArg_ParseTuple(args, \"s#nO!s#s#\",\n                          &origData, &origDataLength, &newDataLength,\n                          &PyList_Type, &controlTuples,\n                          &diffBlock, &diffBlockLength,\n                          &extraBlock, &extraBlockLength))\n        return NULL;\n\n    /* allocate the memory for the new data */\n    newData = PyMem_Malloc(newDataLength + 1);\n    if (!newData)\n        return PyErr_NoMemory();\n\n    oldpos = 0;\n    newpos = 0;\n    diffPtr = diffBlock;\n    extraPtr = extraBlock;\n    numTuples = PyList_GET_SIZE(controlTuples);\n    for (i = 0; i < numTuples; i++) {\n        tuple = PyList_GET_ITEM(controlTuples, i);\n        if (!PyTuple_Check(tuple)) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_TypeError, \"expecting tuple\");\n            return NULL;\n        }\n        if (PyTuple_GET_SIZE(tuple) != 3) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_TypeError, \"expecting tuple of size 3\");\n            return NULL;\n        }\n        x = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 0));\n        y = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 1));\n        z = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 2));\n        if (newpos + x > newDataLength ||\n                diffPtr + x > diffBlock + diffBlockLength ||\n                extraPtr + y > extraBlock + extraBlockLength) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_ValueError, \"corrupt patch (overflow)\");\n            return NULL;\n        }\n        memcpy(newData + newpos, diffPtr, x);\n        diffPtr += x;\n        for (j = 0; j < x; j++)\n            if ((oldpos + j >= 0) && (oldpos + j < origDataLength))\n                newData[newpos + j] += origData[oldpos + j];\n        newpos += x;\n        oldpos += x;\n        memcpy(newData + newpos, extraPtr, y);\n        extraPtr += y;\n        newpos += y;\n        oldpos += z;\n    }\n\n    /* confirm that a valid patch was applied */\n    if (newpos != newDataLength ||\n            diffPtr != diffBlock + diffBlockLength ||\n            extraPtr != extraBlock + extraBlockLength) {\n        PyMem_Free(newData);\n        PyErr_SetString(PyExc_ValueError, \"corrupt patch (underflow)\");\n        return NULL;\n    }\n\n    results = PyBytes_FromStringAndSize(newData, newDataLength);\n    PyMem_Free(newData);\n    return results;\n}\n\n\n/* encode an integer value as 8 bytes */\nstatic PyObject *encode_int64(PyObject *self, PyObject *value)\n{\n    long long x;\n    char bs[8], sign = 0x00;\n    int i;\n\n    if (!PyArg_Parse(value, \"L\", &x))\n        return NULL;\n\n    if (x < 0) {\n        x = -x;\n        sign = 0x80;\n    }\n    for (i = 0; i < 8; i++) {\n        bs[i] = x & 0xff;\n        x >>= 8;  /* x /= 256 */\n    }\n    bs[7] |= sign;\n    return PyBytes_FromStringAndSize(bs, 8);\n}\n\n\n/* decode an off_t value from 8 bytes */\nstatic PyObject *decode_int64(PyObject *self, PyObject *string)\n{\n    long long x;\n    char *bs;\n    int i;\n\n    if (!PyBytes_Check(string)) {\n        PyErr_SetString(PyExc_TypeError, \"bytes expected\");\n        return NULL;\n    }\n    if (PyBytes_Size(string) != 8) {\n        PyErr_SetString(PyExc_ValueError, \"8 bytes expected\");\n        return NULL;\n    }\n    bs = PyBytes_AsString(string);\n\n    x = bs[7] & 0x7F;\n    for (i = 6; i >= 0; i--) {\n        x <<= 8;  /* x = x * 256 + (unsigned char) bs[i]; */\n        x |= (unsigned char) bs[i];\n    }\n    if (bs[7] & 0x80)\n        x = -x;\n    return PyLong_FromLongLong(x);\n}\n\n\n/* declaration of methods supported by this module */\nstatic PyMethodDef module_functions[] = {\n    {\"diff\", diff, METH_VARARGS},\n    {\"patch\", patch, METH_VARARGS},\n    {\"encode_int64\", encode_int64, METH_O},\n    {\"decode_int64\", decode_int64, METH_O},\n    {NULL, NULL, 0, NULL}  /* Sentinel */\n};\n\n/* initialization routine for the shared libary */\n#ifdef IS_PY3K\nstatic PyModuleDef moduledef = {\n    PyModuleDef_HEAD_INIT, \"core\", 0, -1, module_functions,\n};\n\nPyMODINIT_FUNC\nPyInit_core(void)\n{\n    PyObject *m;\n\n    m = PyModule_Create(&moduledef);\n    if (m == NULL)\n        return NULL;\n    return m;\n}\n#else\nPyMODINIT_FUNC\ninitcore(void)\n{\n    Py_InitModule(\"core\", module_functions);\n}\n#endif\n"], "fixing_code": ["/*\n  The code below is mostly derived from cx_bsdiff (written by Anthony\n  Tuininga, http://cx-bsdiff.sourceforge.net/).  The cx_bsdiff code in\n  turn was derived from bsdiff, the standalone utility produced for BSD\n  which can be found at http://www.daemonology.net/bsdiff.\n*/\n\n#define PY_SSIZE_T_CLEAN\n#include <Python.h>\n\n#if PY_MAJOR_VERSION >= 3\n#define IS_PY3K\n#endif\n\n\n#define MIN(x, y)  (((x) < (y)) ? (x) : (y))\n\n\nstatic void split(off_t *I, off_t *V, off_t start, off_t len, off_t h)\n{\n    off_t i, j, k, x, tmp, jj, kk;\n\n    if (len < 16) {\n        for (k = start; k < start + len; k += j) {\n            j = 1;\n            x = V[I[k] + h];\n            for (i = 1; k + i < start + len; i++) {\n                if (V[I[k + i] + h] < x) {\n                    x = V[I[k + i] + h];\n                    j = 0;\n                }\n                if (V[I[k + i] + h] == x) {\n                    tmp = I[k + j];\n                    I[k + j] = I[k + i];\n                    I[k + i] = tmp;\n                    j++;\n                }\n            }\n            for (i = 0; i < j; i++)\n                V[I[k + i]] = k + j - 1;\n            if (j == 1)\n                I[k] = -1;\n        }\n\n    } else {\n\n        jj = 0;\n        kk = 0;\n        x = V[I[start + len / 2] + h];\n        for (i = start; i < start + len; i++) {\n            if (V[I[i] + h] < x)\n                jj++;\n            if (V[I[i] + h] == x)\n                kk++;\n        }\n        jj += start;\n        kk += jj;\n\n        j = 0;\n        k = 0;\n        i = start;\n        while (i < jj) {\n            if (V[I[i] + h] < x) {\n                i++;\n            } else if (V[I[i] + h] == x) {\n                tmp = I[i];\n                I[i] = I[jj + j];\n                I[jj + j] = tmp;\n                j++;\n            } else {\n                tmp = I[i];\n                I[i] = I[kk + k];\n                I[kk + k] = tmp;\n                k++;\n            }\n        }\n\n        while (jj + j < kk) {\n            if (V[I[jj + j] + h] == x) {\n                j++;\n            } else {\n                tmp = I[jj + j];\n                I[jj + j] = I[kk + k];\n                I[kk + k] = tmp;\n                k++;\n            }\n        }\n\n        if (jj > start)\n            split(I, V, start, jj - start, h);\n\n        for (i = 0; i < kk - jj; i++)\n            V[I[jj + i]] = kk - 1;\n        if (jj == kk - 1)\n            I[jj] = -1;\n        if (start + len > kk)\n            split(I, V, kk, start + len - kk, h);\n    }\n}\n\n\nstatic void qsufsort(off_t *I, off_t *V, unsigned char *old, off_t oldsize)\n{\n    off_t buckets[256], i, h, len;\n\n    for (i = 0; i < 256; i++)\n        buckets[i] = 0;\n    for (i = 0; i < oldsize; i++)\n        buckets[old[i]]++;\n    for (i = 1; i < 256; i++)\n        buckets[i] += buckets[i - 1];\n    for (i = 255; i > 0; i--)\n        buckets[i] = buckets[i - 1];\n    buckets[0] = 0;\n\n    for (i = 0; i < oldsize; i++)\n        I[++buckets[old[i]]] = i;\n    I[0] = oldsize;\n    for (i = 0; i < oldsize; i++)\n        V[i] = buckets[old[i]];\n    V[oldsize] = 0;\n    for (i = 1; i < 256; i++)\n        if (buckets[i] == buckets[i - 1] + 1)\n            I[buckets[i]] = -1;\n    I[0] = -1;\n\n    for (h = 1; I[0] != -(oldsize + 1); h += h) {\n        len = 0;\n        for (i = 0; i < oldsize + 1;) {\n            if (I[i] < 0) {\n                len -= I[i];\n                i -= I[i];\n            } else {\n                if (len)\n                    I[i - len] = -len;\n                len = V[I[i]] + 1 - i;\n                split(I, V, i, len, h);\n                i += len;\n                len=0;\n            }\n        }\n        if (len)\n            I[i - len] = -len;\n    }\n\n    for (i = 0; i < oldsize + 1; i++)\n        I[V[i]] = i;\n}\n\n\nstatic off_t matchlen(unsigned char *old, off_t oldsize,\n                      unsigned char *new, off_t newsize)\n{\n    off_t i;\n\n    for (i = 0; (i < oldsize) && (i < newsize); i++)\n        if (old[i] != new[i])\n            break;\n    return i;\n}\n\n\nstatic off_t search(off_t *I,\n                    unsigned char *old, off_t oldsize,\n                    unsigned char *new, off_t newsize,\n                    off_t st, off_t en, off_t *pos)\n{\n    off_t x, y;\n\n    if (en - st < 2) {\n        x = matchlen(old + I[st], oldsize - I[st], new, newsize);\n        y = matchlen(old + I[en], oldsize - I[en], new, newsize);\n\n        if (x > y) {\n            *pos = I[st];\n            return x;\n        } else {\n            *pos = I[en];\n            return y;\n        }\n    }\n\n    x = st + (en - st) / 2;\n    if (memcmp(old + I[x], new, MIN(oldsize - I[x], newsize)) < 0) {\n        return search(I, old, oldsize, new, newsize, x, en, pos);\n    } else {\n        return search(I, old, oldsize, new, newsize, st, x, pos);\n    }\n}\n\n\n/* performs a diff between the two data streams and returns a tuple\n   containing the control, diff and extra blocks that bsdiff produces\n*/\nstatic PyObject* diff(PyObject* self, PyObject* args)\n{\n    off_t lastscan, lastpos, lastoffset, oldscore, scsc, overlap, Ss, lens;\n    off_t *I, *V, dblen, eblen, scan, pos, len, s, Sf, lenf, Sb, lenb, i;\n    PyObject *controlTuples, *tuple, *results, *temp;\n    Py_ssize_t origDataLength, newDataLength;\n    char *origData, *newData;\n    unsigned char *db, *eb;\n\n    if (!PyArg_ParseTuple(args, \"s#s#\",\n                          &origData, &origDataLength,\n                          &newData, &newDataLength))\n        return NULL;\n\n    /* create the control tuple */\n    controlTuples = PyList_New(0);\n    if (!controlTuples)\n        return NULL;\n\n    /* perform sort on original data */\n    I = PyMem_Malloc((origDataLength + 1) * sizeof(off_t));\n    if (!I) {\n        Py_DECREF(controlTuples);\n        return PyErr_NoMemory();\n    }\n    V = PyMem_Malloc((origDataLength + 1) * sizeof(off_t));\n    if (!V) {\n        Py_DECREF(controlTuples);\n        PyMem_Free(I);\n        return PyErr_NoMemory();\n    }\n    Py_BEGIN_ALLOW_THREADS  /* release GIL */\n    qsufsort(I, V, (unsigned char *) origData, origDataLength);\n    Py_END_ALLOW_THREADS\n    PyMem_Free(V);\n\n    /* allocate memory for the diff and extra blocks */\n    db = PyMem_Malloc(newDataLength + 1);\n    if (!db) {\n        Py_DECREF(controlTuples);\n        PyMem_Free(I);\n        return PyErr_NoMemory();\n    }\n    eb = PyMem_Malloc(newDataLength + 1);\n    if (!eb) {\n        Py_DECREF(controlTuples);\n        PyMem_Free(I);\n        PyMem_Free(db);\n        return PyErr_NoMemory();\n    }\n    dblen = 0;\n    eblen = 0;\n\n    /* perform the diff */\n    len = 0;\n    scan = 0;\n    lastscan = 0;\n    lastpos = 0;\n    lastoffset = 0;\n    pos = 0;\n    while (scan < newDataLength) {\n        oldscore = 0;\n\n        Py_BEGIN_ALLOW_THREADS  /* release GIL */\n        for (scsc = scan += len; scan < newDataLength; scan++) {\n            len = search(I, (unsigned char *) origData, origDataLength,\n                         (unsigned char *) newData + scan,\n                         newDataLength - scan, 0, origDataLength, &pos);\n            for (; scsc < scan + len; scsc++)\n                if ((scsc + lastoffset < origDataLength) &&\n                          (origData[scsc + lastoffset] == newData[scsc]))\n                    oldscore++;\n            if (((len == oldscore) && (len != 0)) || (len > oldscore + 8))\n                break;\n            if ((scan + lastoffset < origDataLength) &&\n                      (origData[scan + lastoffset] == newData[scan]))\n                oldscore--;\n        }\n        Py_END_ALLOW_THREADS\n\n        if ((len != oldscore) || (scan == newDataLength)) {\n            s = 0;\n            Sf = 0;\n            lenf = 0;\n            for (i = 0; (lastscan + i < scan) &&\n                     (lastpos + i < origDataLength);) {\n                if (origData[lastpos + i] == newData[lastscan + i])\n                    s++;\n                i++;\n                if (s * 2 - i > Sf * 2 - lenf) {\n                    Sf = s;\n                    lenf = i;\n                }\n            }\n\n            lenb = 0;\n            if (scan < newDataLength) {\n                s = 0;\n                Sb = 0;\n                for (i = 1; (scan >= lastscan + i) && (pos >= i); i++) {\n                    if (origData[pos - i] == newData[scan - i])\n                        s++;\n                    if (s * 2 - i > Sb * 2 - lenb) {\n                        Sb = s;\n                        lenb = i;\n                    }\n                }\n            }\n\n            if (lastscan + lenf > scan - lenb) {\n                overlap = (lastscan + lenf) - (scan - lenb);\n                s = 0;\n                Ss = 0;\n                lens = 0;\n                for (i = 0; i < overlap; i++) {\n                    if (newData[lastscan + lenf - overlap + i] ==\n                            origData[lastpos + lenf - overlap + i])\n                        s++;\n                    if (newData[scan - lenb + i]== origData[pos - lenb + i])\n                        s--;\n                    if (s > Ss) {\n                        Ss = s;\n                        lens = i + 1;\n                    }\n                }\n\n                lenf += lens - overlap;\n                lenb -= lens;\n            }\n\n            for (i = 0; i < lenf; i++)\n                db[dblen + i] = newData[lastscan + i] - origData[lastpos + i];\n            for (i = 0; i < (scan - lenb) - (lastscan + lenf); i++)\n                eb[eblen + i] = newData[lastscan + lenf + i];\n\n            dblen += lenf;\n            eblen += (scan - lenb) - (lastscan + lenf);\n\n            tuple = PyTuple_New(3);\n            if (!tuple) {\n                Py_DECREF(controlTuples);\n                PyMem_Free(I);\n                PyMem_Free(db);\n                PyMem_Free(eb);\n                return NULL;\n            }\n            PyTuple_SET_ITEM(tuple, 0, PyLong_FromLong(lenf));\n            PyTuple_SET_ITEM(tuple, 1,\n                    PyLong_FromLong((scan - lenb) - (lastscan + lenf)));\n            PyTuple_SET_ITEM(tuple, 2,\n                    PyLong_FromLong((pos - lenb) - (lastpos + lenf)));\n            if (PyList_Append(controlTuples, tuple) < 0) {\n                Py_DECREF(controlTuples);\n                Py_DECREF(tuple);\n                PyMem_Free(I);\n                PyMem_Free(db);\n                PyMem_Free(eb);\n                return NULL;\n            }\n            Py_DECREF(tuple);\n\n            lastscan = scan - lenb;\n            lastpos = pos - lenb;\n            lastoffset = pos - scan;\n        }\n    }\n\n    PyMem_Free(I);\n    results = PyTuple_New(3);\n    if (!results) {\n        PyMem_Free(db);\n        PyMem_Free(eb);\n        return NULL;\n    }\n    PyTuple_SET_ITEM(results, 0, controlTuples);\n    temp = PyBytes_FromStringAndSize((char *) db, dblen);\n    PyMem_Free(db);\n    if (!temp) {\n        PyMem_Free(eb);\n        Py_DECREF(results);\n        return NULL;\n    }\n    PyTuple_SET_ITEM(results, 1, temp);\n    temp = PyBytes_FromStringAndSize((char *) eb, eblen);\n    PyMem_Free(eb);\n    if (!temp) {\n        Py_DECREF(results);\n        return NULL;\n    }\n    PyTuple_SET_ITEM(results, 2, temp);\n\n    return results;\n}\n\n\n/* takes the original data and the control, diff and extra blocks produced\n   by bsdiff and returns the new data\n*/\nstatic PyObject* patch(PyObject* self, PyObject* args)\n{\n    char *origData, *newData, *diffBlock, *extraBlock, *diffPtr, *extraPtr;\n    Py_ssize_t origDataLength, newDataLength, diffBlockLength, extraBlockLength;\n    PyObject *controlTuples, *tuple, *results;\n    off_t oldpos, newpos, x, y, z;\n    int i, j, numTuples;\n\n    if (!PyArg_ParseTuple(args, \"s#nO!s#s#\",\n                          &origData, &origDataLength, &newDataLength,\n                          &PyList_Type, &controlTuples,\n                          &diffBlock, &diffBlockLength,\n                          &extraBlock, &extraBlockLength))\n        return NULL;\n\n    /* allocate the memory for the new data */\n    newData = PyMem_Malloc(newDataLength + 1);\n    if (!newData)\n        return PyErr_NoMemory();\n\n    oldpos = 0;\n    newpos = 0;\n    diffPtr = diffBlock;\n    extraPtr = extraBlock;\n    numTuples = PyList_GET_SIZE(controlTuples);\n    for (i = 0; i < numTuples; i++) {\n        tuple = PyList_GET_ITEM(controlTuples, i);\n        if (!PyTuple_Check(tuple)) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_TypeError, \"expecting tuple\");\n            return NULL;\n        }\n        if (PyTuple_GET_SIZE(tuple) != 3) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_TypeError, \"expecting tuple of size 3\");\n            return NULL;\n        }\n        x = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 0));\n        y = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 1));\n        z = PyLong_AsLong(PyTuple_GET_ITEM(tuple, 2));\n        if (newpos + x > newDataLength ||\n                diffPtr + x > diffBlock + diffBlockLength) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_ValueError, \"corrupt patch (overflow)\");\n            return NULL;\n        }\n        memcpy(newData + newpos, diffPtr, x);\n        diffPtr += x;\n        for (j = 0; j < x; j++)\n            if ((oldpos + j >= 0) && (oldpos + j < origDataLength))\n                newData[newpos + j] += origData[oldpos + j];\n        newpos += x;\n        oldpos += x;\n        if (newpos + y > newDataLength ||\n                extraPtr + y > extraBlock + extraBlockLength) {\n            PyMem_Free(newData);\n            PyErr_SetString(PyExc_ValueError, \"corrupt patch (overflow)\");\n            return NULL;\n        }\n        memcpy(newData + newpos, extraPtr, y);\n        extraPtr += y;\n        newpos += y;\n        oldpos += z;\n    }\n\n    /* confirm that a valid patch was applied */\n    if (newpos != newDataLength ||\n            diffPtr != diffBlock + diffBlockLength ||\n            extraPtr != extraBlock + extraBlockLength) {\n        PyMem_Free(newData);\n        PyErr_SetString(PyExc_ValueError, \"corrupt patch (underflow)\");\n        return NULL;\n    }\n\n    results = PyBytes_FromStringAndSize(newData, newDataLength);\n    PyMem_Free(newData);\n    return results;\n}\n\n\n/* encode an integer value as 8 bytes */\nstatic PyObject *encode_int64(PyObject *self, PyObject *value)\n{\n    long long x;\n    char bs[8], sign = 0x00;\n    int i;\n\n    if (!PyArg_Parse(value, \"L\", &x))\n        return NULL;\n\n    if (x < 0) {\n        x = -x;\n        sign = 0x80;\n    }\n    for (i = 0; i < 8; i++) {\n        bs[i] = x & 0xff;\n        x >>= 8;  /* x /= 256 */\n    }\n    bs[7] |= sign;\n    return PyBytes_FromStringAndSize(bs, 8);\n}\n\n\n/* decode an off_t value from 8 bytes */\nstatic PyObject *decode_int64(PyObject *self, PyObject *string)\n{\n    long long x;\n    char *bs;\n    int i;\n\n    if (!PyBytes_Check(string)) {\n        PyErr_SetString(PyExc_TypeError, \"bytes expected\");\n        return NULL;\n    }\n    if (PyBytes_Size(string) != 8) {\n        PyErr_SetString(PyExc_ValueError, \"8 bytes expected\");\n        return NULL;\n    }\n    bs = PyBytes_AsString(string);\n\n    x = bs[7] & 0x7F;\n    for (i = 6; i >= 0; i--) {\n        x <<= 8;  /* x = x * 256 + (unsigned char) bs[i]; */\n        x |= (unsigned char) bs[i];\n    }\n    if (bs[7] & 0x80)\n        x = -x;\n    return PyLong_FromLongLong(x);\n}\n\n\n/* declaration of methods supported by this module */\nstatic PyMethodDef module_functions[] = {\n    {\"diff\", diff, METH_VARARGS},\n    {\"patch\", patch, METH_VARARGS},\n    {\"encode_int64\", encode_int64, METH_O},\n    {\"decode_int64\", decode_int64, METH_O},\n    {NULL, NULL, 0, NULL}  /* Sentinel */\n};\n\n/* initialization routine for the shared libary */\n#ifdef IS_PY3K\nstatic PyModuleDef moduledef = {\n    PyModuleDef_HEAD_INIT, \"core\", 0, -1, module_functions,\n};\n\nPyMODINIT_FUNC\nPyInit_core(void)\n{\n    PyObject *m;\n\n    m = PyModule_Create(&moduledef);\n    if (m == NULL)\n        return NULL;\n    return m;\n}\n#else\nPyMODINIT_FUNC\ninitcore(void)\n{\n    Py_InitModule(\"core\", module_functions);\n}\n#endif\n"], "filenames": ["bsdiff4/core.c"], "buggy_code_start_loc": [434], "buggy_code_end_loc": [446], "fixing_code_start_loc": [434], "fixing_code_end_loc": [452], "type": "CWE-787", "message": "A buffer overflow in the patching routine of bsdiff4 before 1.2.0 allows an attacker to write to heap memory (beyond allocated bounds) via a crafted patch file.", "other": {"cve": {"id": "CVE-2020-15904", "sourceIdentifier": "cve@mitre.org", "published": "2020-07-22T23:15:11.330", "lastModified": "2023-01-28T02:04:20.120", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A buffer overflow in the patching routine of bsdiff4 before 1.2.0 allows an attacker to write to heap memory (beyond allocated bounds) via a crafted patch file."}, {"lang": "es", "value": "Un desbordamiento del b\u00fafer en la rutina de parches de bsdiff4 versiones anteriores a 1.2.0, permite a un atacante escribir en la regi\u00f3n heap de la memoria (m\u00e1s all\u00e1 de los l\u00edmites asignados) por medio de un archivo de parche dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pypi:bsdiff4:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.0", "matchCriteriaId": "9C2BAC82-E6D4-46F1-A2A2-69191C2A7B2E"}]}]}], "references": [{"url": "https://github.com/ilanschnell/bsdiff4/blob/master/CHANGELOG.txt", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/ilanschnell/bsdiff4/commit/49a4cee2feef7deaf9d89e5e793a8824930284d7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ilanschnell/bsdiff4/commit/49a4cee2feef7deaf9d89e5e793a8824930284d7"}}