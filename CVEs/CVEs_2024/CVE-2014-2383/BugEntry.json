{"buggy_code": ["<?php\n/**\n * Command line utility to use dompdf.\n * Can also be used with HTTP GET parameters\n * \n * @package dompdf\n * @link    http://dompdf.github.com/\n * @author  Benj Carson <benjcarson@digitaljunkies.ca>\n * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n */\n\n/**\n * Display command line usage\n */\nfunction dompdf_usage() {\n  $default_paper_size = DOMPDF_DEFAULT_PAPER_SIZE;\n  \n  echo <<<EOD\n  \nUsage: {$_SERVER[\"argv\"][0]} [options] html_file\n\nhtml_file can be a filename, a url if fopen_wrappers are enabled, or the '-' character to read from standard input.\n\nOptions:\n -h             Show this message\n -l             List available paper sizes\n -p size        Paper size; something like 'letter', 'A4', 'legal', etc.  \n                  The default is '$default_paper_size'\n -o orientation Either 'portrait' or 'landscape'.  Default is 'portrait'\n -b path        Set the 'document root' of the html_file.  \n                  Relative urls (for stylesheets) are resolved using this directory.  \n                  Default is the directory of html_file.\n -f file        The output filename.  Default is the input [html_file].pdf\n -v             Verbose: display html parsing warnings and file not found errors.\n -d             Very verbose: display oodles of debugging output: every frame \n                  in the tree printed to stdout.\n -t             Comma separated list of debugging types (page-break,reflow,split)\n \nEOD;\nexit;\n}\n\n/**\n * Parses command line options\n * \n * @return array The command line options\n */\nfunction getoptions() {\n\n  $opts = array();\n\n  if ( $_SERVER[\"argc\"] == 1 )\n    return $opts;\n\n  $i = 1;\n  while ($i < $_SERVER[\"argc\"]) {\n\n    switch ($_SERVER[\"argv\"][$i]) {\n\n    case \"--help\":\n    case \"-h\":\n      $opts[\"h\"] = true;\n      $i++;\n      break;\n\n    case \"-l\":\n      $opts[\"l\"] = true;\n      $i++;\n      break;\n\n    case \"-p\":\n      if ( !isset($_SERVER[\"argv\"][$i+1]) )\n        die(\"-p switch requires a size parameter\\n\");\n      $opts[\"p\"] = $_SERVER[\"argv\"][$i+1];\n      $i += 2;\n      break;\n\n    case \"-o\":\n      if ( !isset($_SERVER[\"argv\"][$i+1]) )\n        die(\"-o switch requires an orientation parameter\\n\");\n      $opts[\"o\"] = $_SERVER[\"argv\"][$i+1];\n      $i += 2;\n      break;\n\n    case \"-b\":\n      if ( !isset($_SERVER[\"argv\"][$i+1]) )\n        die(\"-b switch requires a path parameter\\n\");\n      $opts[\"b\"] = $_SERVER[\"argv\"][$i+1];\n      $i += 2;\n      break;\n\n    case \"-f\":\n      if ( !isset($_SERVER[\"argv\"][$i+1]) )\n        die(\"-f switch requires a filename parameter\\n\");\n      $opts[\"f\"] = $_SERVER[\"argv\"][$i+1];\n      $i += 2;\n      break;\n\n    case \"-v\":\n      $opts[\"v\"] = true;\n      $i++;\n      break;\n\n    case \"-d\":\n      $opts[\"d\"] = true;\n      $i++;\n      break;\n\n    case \"-t\":\n      if ( !isset($_SERVER['argv'][$i + 1]) )\n        die(\"-t switch requires a comma separated list of types\\n\");\n      $opts[\"t\"] = $_SERVER['argv'][$i+1];\n      $i += 2;\n      break;\n\n   default:\n      $opts[\"filename\"] = $_SERVER[\"argv\"][$i];\n      $i++;\n      break;\n    }\n\n  }\n  return $opts;\n}\n\nrequire_once(\"dompdf_config.inc.php\");\nglobal $_dompdf_show_warnings, $_dompdf_debug, $_DOMPDF_DEBUG_TYPES;\n\n$sapi = php_sapi_name();\n$options = array();\n\nswitch ( $sapi ) {\n\n case \"cli\":\n\n  $opts = getoptions();\n\n  if ( isset($opts[\"h\"]) || (!isset($opts[\"filename\"]) && !isset($opts[\"l\"])) ) {\n    dompdf_usage();\n    exit;\n  }\n\n  if ( isset($opts[\"l\"]) ) {\n    echo \"\\nUnderstood paper sizes:\\n\";\n\n    foreach (array_keys(CPDF_Adapter::$PAPER_SIZES) as $size)\n      echo \"  \" . mb_strtoupper($size) . \"\\n\";\n    exit;\n  }\n  $file = $opts[\"filename\"];\n\n  if ( isset($opts[\"p\"]) )\n    $paper = $opts[\"p\"];\n  else\n    $paper = DOMPDF_DEFAULT_PAPER_SIZE;\n\n  if ( isset($opts[\"o\"]) )\n    $orientation = $opts[\"o\"];\n  else\n    $orientation = \"portrait\";\n\n  if ( isset($opts[\"b\"]) )\n    $base_path = $opts[\"b\"];\n\n  if ( isset($opts[\"f\"]) )\n    $outfile = $opts[\"f\"];\n  else {\n    if ( $file === \"-\" )\n      $outfile = \"dompdf_out.pdf\";\n    else\n      $outfile = str_ireplace(array(\".html\", \".htm\", \".php\"), \"\", $file) . \".pdf\";\n  }\n\n  if ( isset($opts[\"v\"]) )\n    $_dompdf_show_warnings = true;\n\n  if ( isset($opts[\"d\"]) ) {\n    $_dompdf_show_warnings = true;\n    $_dompdf_debug = true;\n  }\n\n  if ( isset($opts['t']) ) {\n    $arr = split(',',$opts['t']);\n    $types = array();\n    foreach ($arr as $type)\n      $types[ trim($type) ] = 1;\n    $_DOMPDF_DEBUG_TYPES = $types;\n  }\n  \n  $save_file = true;\n\n  break;\n\n default:\n\n  if ( isset($_GET[\"input_file\"]) )\n    $file = rawurldecode($_GET[\"input_file\"]);\n  else\n    throw new DOMPDF_Exception(\"An input file is required (i.e. input_file _GET variable).\");\n  \n  if ( isset($_GET[\"paper\"]) )\n    $paper = rawurldecode($_GET[\"paper\"]);\n  else\n    $paper = DOMPDF_DEFAULT_PAPER_SIZE;\n  \n  if ( isset($_GET[\"orientation\"]) )\n    $orientation = rawurldecode($_GET[\"orientation\"]);\n  else\n    $orientation = \"portrait\";\n  \n  if ( isset($_GET[\"base_path\"]) ) {\n    $base_path = rawurldecode($_GET[\"base_path\"]);\n    $file = $base_path . $file; # Set the input file\n  }  \n  \n  if ( isset($_GET[\"options\"]) ) {\n    $options = $_GET[\"options\"];\n  }\n  \n  $file_parts = explode_url($file);\n  \n  /* Check to see if the input file is local and, if so, that the base path falls within that specified by DOMDPF_CHROOT */\n  if(($file_parts['protocol'] == '' || $file_parts['protocol'] === 'file://')) {\n    $file = realpath($file);\n    if ( strpos($file, DOMPDF_CHROOT) !== 0 ) {\n      throw new DOMPDF_Exception(\"Permission denied on $file. The file could not be found under the directory specified by DOMPDF_CHROOT.\");\n    }\n  }\n  \n  $outfile = \"dompdf_out.pdf\"; # Don't allow them to set the output file\n  $save_file = false; # Don't save the file\n  \n  break;\n}\n\n$dompdf = new DOMPDF();\n\nif ( $file === \"-\" ) {\n  $str = \"\";\n  while ( !feof(STDIN) )\n    $str .= fread(STDIN, 4096);\n\n  $dompdf->load_html($str);\n\n} else\n  $dompdf->load_html_file($file);\n\nif ( isset($base_path) ) {\n  $dompdf->set_base_path($base_path);\n}\n\n$dompdf->set_paper($paper, $orientation);\n\n$dompdf->render();\n\nif ( $_dompdf_show_warnings ) {\n  global $_dompdf_warnings;\n  foreach ($_dompdf_warnings as $msg)\n    echo $msg . \"\\n\";\n  echo $dompdf->get_canvas()->get_cpdf()->messages;\n  flush();\n}\n\nif ( $save_file ) {\n//   if ( !is_writable($outfile) )\n//     throw new DOMPDF_Exception(\"'$outfile' is not writable.\");\n  if ( strtolower(DOMPDF_PDF_BACKEND) === \"gd\" )\n    $outfile = str_replace(\".pdf\", \".png\", $outfile);\n\n  list($proto, $host, $path, $file) = explode_url($outfile);\n  if ( $proto != \"\" ) // i.e. not file://\n    $outfile = $file; // just save it locally, FIXME? could save it like wget: ./host/basepath/file\n\n  $outfile = realpath(dirname($outfile)) . DIRECTORY_SEPARATOR . basename($outfile);\n\n  if ( strpos($outfile, DOMPDF_CHROOT) !== 0 )\n    throw new DOMPDF_Exception(\"Permission denied.\");\n\n  file_put_contents($outfile, $dompdf->output( array(\"compress\" => 0) ));\n  exit(0);\n}\n\nif ( !headers_sent() ) {\n  $dompdf->stream($outfile, $options);\n}\n", "<?php\n/**\n * @package dompdf\n * @link    http://dompdf.github.com/\n * @author  Benj Carson <benjcarson@digitaljunkies.ca>\n * @author  Fabien M\u00e9nager <fabien.menager@gmail.com>\n * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n */\n\n/**\n * DOMPDF - PHP5 HTML to PDF renderer\n *\n * DOMPDF loads HTML and does its best to render it as a PDF.  It gets its\n * name from the new DomDocument PHP5 extension.  Source HTML is first\n * parsed by a DomDocument object.  DOMPDF takes the resulting DOM tree and\n * attaches a {@link Frame} object to each node.  {@link Frame} objects store\n * positioning and layout information and each has a reference to a {@link\n * Style} object.\n *\n * Style information is loaded and parsed (see {@link Stylesheet}) and is\n * applied to the frames in the tree by using XPath.  CSS selectors are\n * converted into XPath queries, and the computed {@link Style} objects are\n * applied to the {@link Frame}s.\n *\n * {@link Frame}s are then decorated (in the design pattern sense of the\n * word) based on their CSS display property ({@link\n * http://www.w3.org/TR/CSS21/visuren.html#propdef-display}).\n * Frame_Decorators augment the basic {@link Frame} class by adding\n * additional properties and methods specific to the particular type of\n * {@link Frame}.  For example, in the CSS layout model, block frames\n * (display: block;) contain line boxes that are usually filled with text or\n * other inline frames.  The Block_Frame_Decorator therefore adds a $lines\n * property as well as methods to add {@link Frame}s to lines and to add\n * additional lines.  {@link Frame}s also are attached to specific\n * Positioner and {@link Frame_Reflower} objects that contain the\n * positioining and layout algorithm for a specific type of frame,\n * respectively.  This is an application of the Strategy pattern.\n *\n * Layout, or reflow, proceeds recursively (post-order) starting at the root\n * of the document.  Space constraints (containing block width & height) are\n * pushed down, and resolved positions and sizes bubble up.  Thus, every\n * {@link Frame} in the document tree is traversed once (except for tables\n * which use a two-pass layout algorithm).  If you are interested in the\n * details, see the reflow() method of the Reflower classes.\n *\n * Rendering is relatively straightforward once layout is complete. {@link\n * Frame}s are rendered using an adapted {@link Cpdf} class, originally\n * written by Wayne Munro, http://www.ros.co.nz/pdf/.  (Some performance\n * related changes have been made to the original {@link Cpdf} class, and\n * the {@link CPDF_Adapter} class provides a simple, stateless interface to\n * PDF generation.)  PDFLib support has now also been added, via the {@link\n * PDFLib_Adapter}.\n *\n *\n * @package dompdf\n */\nclass DOMPDF {\n\n  /**\n   * DomDocument representing the HTML document\n   *\n   * @var DOMDocument\n   */\n  protected $_xml;\n\n  /**\n   * Frame_Tree derived from the DOM tree\n   *\n   * @var Frame_Tree\n   */\n  protected $_tree;\n\n  /**\n   * Stylesheet for the document\n   *\n   * @var Stylesheet\n   */\n  protected $_css;\n\n  /**\n   * Actual PDF renderer\n   *\n   * @var Canvas\n   */\n  protected $_pdf;\n\n  /**\n   * Desired paper size ('letter', 'legal', 'A4', etc.)\n   *\n   * @var string\n   */\n  protected $_paper_size;\n\n  /**\n   * Paper orientation ('portrait' or 'landscape')\n   *\n   * @var string\n   */\n  protected $_paper_orientation;\n\n  /**\n   * Callbacks on new page and new element\n   *\n   * @var array\n   */\n  protected $_callbacks;\n\n  /**\n   * Experimental caching capability\n   *\n   * @var string\n   */\n  private $_cache_id;\n\n  /**\n   * Base hostname\n   *\n   * Used for relative paths/urls\n   * @var string\n   */\n  protected $_base_host;\n\n  /**\n   * Absolute base path\n   *\n   * Used for relative paths/urls\n   * @var string\n   */\n  protected $_base_path;\n\n  /**\n   * Protcol used to request file (file://, http://, etc)\n   *\n   * @var string\n   */\n  protected $_protocol;\n\n  /**\n   * HTTP context created with stream_context_create()\n   * Will be used for file_get_contents\n   *\n   * @var resource\n   */\n  protected $_http_context;\n\n  /**\n   * Timestamp of the script start time\n   *\n   * @var int\n   */\n  private $_start_time = null;\n\n  /**\n   * The system's locale\n   *\n   * @var string\n   */\n  private $_system_locale = null;\n\n  /**\n   * Tells if the system's locale is the C standard one\n   *\n   * @var bool\n   */\n  private $_locale_standard = false;\n\n  /**\n   * The default view of the PDF in the viewer\n   *\n   * @var string\n   */\n  private $_default_view = \"Fit\";\n\n  /**\n   * The default view options of the PDF in the viewer\n   *\n   * @var array\n   */\n  private $_default_view_options = array();\n\n  /**\n   * Tells wether the DOM document is in quirksmode (experimental)\n   *\n   * @var bool\n   */\n  private $_quirksmode = false;\n\n  /**\n   * The list of built-in fonts\n   *\n   * @var array\n   */\n  public static $native_fonts = array(\n    \"courier\", \"courier-bold\", \"courier-oblique\", \"courier-boldoblique\",\n    \"helvetica\", \"helvetica-bold\", \"helvetica-oblique\", \"helvetica-boldoblique\",\n    \"times-roman\", \"times-bold\", \"times-italic\", \"times-bolditalic\",\n    \"symbol\", \"zapfdinbats\"\n  );\n\n  private $_options = array(\n    // Directories\n    \"temp_dir\"                 => DOMPDF_TEMP_DIR,\n    \"font_dir\"                 => DOMPDF_FONT_DIR,\n    \"font_cache\"               => DOMPDF_FONT_CACHE,\n    \"chroot\"                   => DOMPDF_CHROOT,\n    \"log_output_file\"          => DOMPDF_LOG_OUTPUT_FILE,\n\n    // Rendering\n    \"default_media_type\"       => DOMPDF_DEFAULT_MEDIA_TYPE,\n    \"default_paper_size\"       => DOMPDF_DEFAULT_PAPER_SIZE,\n    \"default_font\"             => DOMPDF_DEFAULT_FONT,\n    \"dpi\"                      => DOMPDF_DPI,\n    \"font_height_ratio\"        => DOMPDF_FONT_HEIGHT_RATIO,\n\n    // Features\n    \"enable_unicode\"           => DOMPDF_UNICODE_ENABLED,\n    \"enable_php\"               => DOMPDF_ENABLE_PHP,\n    \"enable_remote\"            => DOMPDF_ENABLE_REMOTE,\n    \"enable_css_float\"         => DOMPDF_ENABLE_CSS_FLOAT,\n    \"enable_javascript\"        => DOMPDF_ENABLE_JAVASCRIPT,\n    \"enable_html5_parser\"      => DOMPDF_ENABLE_HTML5PARSER,\n    \"enable_font_subsetting\"   => DOMPDF_ENABLE_FONTSUBSETTING,\n\n    // Debug\n    \"debug_png\"                => DEBUGPNG,\n    \"debug_keep_temp\"          => DEBUGKEEPTEMP,\n    \"debug_css\"                => DEBUGCSS,\n    \"debug_layout\"             => DEBUG_LAYOUT,\n    \"debug_layout_lines\"       => DEBUG_LAYOUT_LINES,\n    \"debug_layout_blocks\"      => DEBUG_LAYOUT_BLOCKS,\n    \"debug_layout_inline\"      => DEBUG_LAYOUT_INLINE,\n    \"debug_layout_padding_box\" => DEBUG_LAYOUT_PADDINGBOX,\n\n    // Admin\n    \"admin_username\"           => DOMPDF_ADMIN_USERNAME,\n    \"admin_password\"           => DOMPDF_ADMIN_PASSWORD,\n  );\n\n  /**\n   * Class constructor\n   */\n  function __construct() {\n    $this->_locale_standard = sprintf('%.1f', 1.0) == '1.0';\n\n    $this->save_locale();\n\n    $this->_messages = array();\n    $this->_css = new Stylesheet($this);\n    $this->_pdf = null;\n    $this->_paper_size = DOMPDF_DEFAULT_PAPER_SIZE;\n    $this->_paper_orientation = \"portrait\";\n    $this->_base_protocol = \"\";\n    $this->_base_host = \"\";\n    $this->_base_path = \"\";\n    $this->_http_context = null;\n    $this->_callbacks = array();\n    $this->_cache_id = null;\n\n    $this->restore_locale();\n  }\n\n  /**\n   * Class destructor\n   */\n  function __destruct() {\n    clear_object($this);\n  }\n\n  /**\n   * Get the dompdf option value\n   *\n   * @param string $key\n   *\n   * @return mixed\n   * @throws DOMPDF_Exception\n   */\n  function get_option($key) {\n    if ( !array_key_exists($key, $this->_options) ) {\n      throw new DOMPDF_Exception(\"Option '$key' doesn't exist\");\n    }\n\n    return $this->_options[$key];\n  }\n\n  /**\n   * @param string $key\n   * @param mixed  $value\n   *\n   * @throws DOMPDF_Exception\n   */\n  function set_option($key, $value) {\n    if ( !array_key_exists($key, $this->_options) ) {\n      throw new DOMPDF_Exception(\"Option '$key' doesn't exist\");\n    }\n\n    $this->_options[$key] = $value;\n  }\n\n  /**\n   * @param array $options\n   */\n  function set_options(array $options) {\n    foreach ($options as $key => $value) {\n      $this->set_option($key, $value);\n    }\n  }\n\n  /**\n   * Save the system's locale configuration and\n   * set the right value for numeric formatting\n   */\n  private function save_locale() {\n    if ( $this->_locale_standard ) {\n      return;\n    }\n\n    $this->_system_locale = setlocale(LC_NUMERIC, \"0\");\n    setlocale(LC_NUMERIC, \"C\");\n  }\n\n  /**\n   * Restore the system's locale configuration\n   */\n  private function restore_locale() {\n    if ( $this->_locale_standard ) {\n      return;\n    }\n\n    setlocale(LC_NUMERIC, $this->_system_locale);\n  }\n\n  /**\n   * Returns the underlying {@link Frame_Tree} object\n   *\n   * @return Frame_Tree\n   */\n  function get_tree() {\n    return $this->_tree;\n  }\n\n  /**\n   * Sets the protocol to use\n   * FIXME validate these\n   *\n   * @param string $proto\n   */\n  function set_protocol($proto) {\n    $this->_protocol = $proto;\n  }\n\n  /**\n   * Sets the base hostname\n   *\n   * @param string $host\n   */\n  function set_host($host) {\n    $this->_base_host = $host;\n  }\n\n  /**\n   * Sets the base path\n   *\n   * @param string $path\n   */\n  function set_base_path($path) {\n    $this->_base_path = $path;\n  }\n\n  /**\n   * Sets the HTTP context\n   *\n   * @param resource $http_context\n   */\n  function set_http_context($http_context) {\n    $this->_http_context = $http_context;\n  }\n\n  /**\n   * Sets the default view\n   *\n   * @param string $default_view The default document view\n   * @param array  $options      The view's options\n   */\n  function set_default_view($default_view, $options) {\n    $this->_default_view = $default_view;\n    $this->_default_view_options = $options;\n  }\n\n  /**\n   * Returns the protocol in use\n   *\n   * @return string\n   */\n  function get_protocol() {\n    return $this->_protocol;\n  }\n\n  /**\n   * Returns the base hostname\n   *\n   * @return string\n   */\n  function get_host() {\n    return $this->_base_host;\n  }\n\n  /**\n   * Returns the base path\n   *\n   * @return string\n   */\n  function get_base_path() {\n    return $this->_base_path;\n  }\n\n  /**\n   * Returns the HTTP context\n   *\n   * @return resource\n   */\n  function get_http_context() {\n    return $this->_http_context;\n  }\n\n  /**\n   * Return the underlying Canvas instance (e.g. CPDF_Adapter, GD_Adapter)\n   *\n   * @return Canvas\n   */\n  function get_canvas() {\n    return $this->_pdf;\n  }\n\n  /**\n   * Returns the callbacks array\n   *\n   * @return array\n   */\n  function get_callbacks() {\n    return $this->_callbacks;\n  }\n\n  /**\n   * Returns the stylesheet\n   *\n   * @return Stylesheet\n   */\n  function get_css() {\n    return $this->_css;\n  }\n\n  /**\n   * @return DOMDocument\n   */\n  function get_dom() {\n    return $this->_xml;\n  }\n\n  /**\n   * Loads an HTML file\n   * Parse errors are stored in the global array _dompdf_warnings.\n   *\n   * @param string $file a filename or url to load\n   *\n   * @throws DOMPDF_Exception\n   */\n  function load_html_file($file) {\n    $this->save_locale();\n\n    // Store parsing warnings as messages (this is to prevent output to the\n    // browser if the html is ugly and the dom extension complains,\n    // preventing the pdf from being streamed.)\n    if ( !$this->_protocol && !$this->_base_host && !$this->_base_path ) {\n      list($this->_protocol, $this->_base_host, $this->_base_path) = explode_url($file);\n    }\n\n    if ( !$this->get_option(\"enable_remote\") && ($this->_protocol != \"\" && $this->_protocol !== \"file://\" ) ) {\n      throw new DOMPDF_Exception(\"Remote file requested, but DOMPDF_ENABLE_REMOTE is false.\");\n    }\n\n    if ($this->_protocol == \"\" || $this->_protocol === \"file://\") {\n\n      // Get the full path to $file, returns false if the file doesn't exist\n      $realfile = realpath($file);\n      if ( !$realfile ) {\n        throw new DOMPDF_Exception(\"File '$file' not found.\");\n      }\n\n      $chroot = $this->get_option(\"chroot\");\n      if ( strpos($realfile, $chroot) !== 0 ) {\n        throw new DOMPDF_Exception(\"Permission denied on $file. The file could not be found under the directory specified by DOMPDF_CHROOT.\");\n      }\n\n      // Exclude dot files (e.g. .htaccess)\n      if ( substr(basename($realfile), 0, 1) === \".\" ) {\n        throw new DOMPDF_Exception(\"Permission denied on $file.\");\n      }\n\n      $file = $realfile;\n    }\n\n    $contents = file_get_contents($file, null, $this->_http_context);\n    $encoding = null;\n\n    // See http://the-stickman.com/web-development/php/getting-http-response-headers-when-using-file_get_contents/\n    if ( isset($http_response_header) ) {\n      foreach($http_response_header as $_header) {\n        if ( preg_match(\"@Content-Type:\\s*[\\w/]+;\\s*?charset=([^\\s]+)@i\", $_header, $matches) ) {\n          $encoding = strtoupper($matches[1]);\n          break;\n        }\n      }\n    }\n\n    $this->restore_locale();\n\n    $this->load_html($contents, $encoding);\n  }\n\n  /**\n   * Loads an HTML string\n   * Parse errors are stored in the global array _dompdf_warnings.\n   * @todo use the $encoding variable\n   *\n   * @param string $str      HTML text to load\n   * @param string $encoding Not used yet\n   */\n  function load_html($str, $encoding = null) {\n    $this->save_locale();\n\n    // FIXME: Determine character encoding, switch to UTF8, update meta tag. Need better http/file stream encoding detection, currently relies on text or meta tag.\n    mb_detect_order('auto');\n\n    if (mb_detect_encoding($str) !== 'UTF-8') {\n      $metatags = array(\n        '@<meta\\s+http-equiv=\"Content-Type\"\\s+content=\"(?:[\\w/]+)(?:;\\s*?charset=([^\\s\"]+))?@i',\n        '@<meta\\s+content=\"(?:[\\w/]+)(?:;\\s*?charset=([^\\s\"]+))\"?\\s+http-equiv=\"Content-Type\"@i',\n        '@<meta [^>]*charset\\s*=\\s*[\"\\']?\\s*([^\"\\' ]+)@i',\n      );\n\n      foreach($metatags as $metatag) {\n        if (preg_match($metatag, $str, $matches)) break;\n      }\n\n      if (mb_detect_encoding($str) == '') {\n        if (isset($matches[1])) {\n          $encoding = strtoupper($matches[1]);\n        }\n        else {\n          $encoding = 'UTF-8';\n        }\n      }\n      else {\n        if ( isset($matches[1]) ) {\n          $encoding = strtoupper($matches[1]);\n        }\n        else {\n          $encoding = 'auto';\n        }\n      }\n\n      if ( $encoding !== 'UTF-8' ) {\n        $str = mb_convert_encoding($str, 'UTF-8', $encoding);\n      }\n\n      if ( isset($matches[1]) ) {\n        $str = preg_replace('/charset=([^\\s\"]+)/i', 'charset=UTF-8', $str);\n      }\n      else {\n        $str = str_replace('<head>', '<head><meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">', $str);\n      }\n    }\n    else {\n      $encoding = 'UTF-8';\n    }\n\n    // remove BOM mark from UTF-8, it's treated as document text by DOMDocument\n    // FIXME: roll this into the encoding detection using UTF-8/16/32 BOM (http://us2.php.net/manual/en/function.mb-detect-encoding.php#91051)?\n    if ( substr($str, 0, 3) == chr(0xEF).chr(0xBB).chr(0xBF) ) {\n      $str = substr($str, 3);\n    }\n\n    // Parse embedded php, first-pass\n    if ( $this->get_option(\"enable_php\") ) {\n      ob_start();\n      eval(\"?\" . \">$str\");\n      $str = ob_get_clean();\n    }\n\n    // if the document contains non utf-8 with a utf-8 meta tag chars and was \n    // detected as utf-8 by mbstring, problems could happen.\n    // http://devzone.zend.com/article/8855\n    if ( $encoding !== 'UTF-8' ) {\n      $re = '/<meta ([^>]*)((?:charset=[^\"\\' ]+)([^>]*)|(?:charset=[\"\\'][^\"\\' ]+[\"\\']))([^>]*)>/i';\n      $str = preg_replace($re, '<meta $1$3>', $str);\n    }\n\n    // Store parsing warnings as messages\n    set_error_handler(\"record_warnings\");\n\n    // @todo Take the quirksmode into account\n    // http://hsivonen.iki.fi/doctype/\n    // https://developer.mozilla.org/en/mozilla's_quirks_mode\n    $quirksmode = false;\n\n    if ( $this->get_option(\"enable_html5_parser\") ) {\n      $tokenizer = new HTML5_Tokenizer($str);\n      $tokenizer->parse();\n      $doc = $tokenizer->save();\n\n      // Remove #text children nodes in nodes that shouldn't have\n      $tag_names = array(\"html\", \"table\", \"tbody\", \"thead\", \"tfoot\", \"tr\");\n      foreach($tag_names as $tag_name) {\n        $nodes = $doc->getElementsByTagName($tag_name);\n\n        foreach($nodes as $node) {\n          self::remove_text_nodes($node);\n        }\n      }\n\n      $quirksmode = ($tokenizer->getTree()->getQuirksMode() > HTML5_TreeBuilder::NO_QUIRKS);\n    }\n    else {\n      // loadHTML assumes ISO-8859-1 unless otherwise specified, but there are\n      // bugs in how DOMDocument determines the actual encoding. Converting to\n      // HTML-ENTITIES prior to import appears to resolve the issue.\n      // http://devzone.zend.com/1538/php-dom-xml-extension-encoding-processing/ (see #4)\n      // http://stackoverflow.com/a/11310258/264628\n      $doc = new DOMDocument();\n      $doc->preserveWhiteSpace = true;\n      $doc->loadHTML( mb_convert_encoding( $str , 'HTML-ENTITIES' , 'UTF-8' ) );\n\n      // If some text is before the doctype, we are in quirksmode\n      if ( preg_match(\"/^(.+)<!doctype/i\", ltrim($str), $matches) ) {\n        $quirksmode = true;\n      }\n      // If no doctype is provided, we are in quirksmode\n      elseif ( !preg_match(\"/^<!doctype/i\", ltrim($str), $matches) ) {\n        $quirksmode = true;\n      }\n      else {\n        // HTML5 <!DOCTYPE html>\n        if ( !$doc->doctype->publicId && !$doc->doctype->systemId ) {\n          $quirksmode = false;\n        }\n\n        // not XHTML\n        if ( !preg_match(\"/xhtml/i\", $doc->doctype->publicId) ) {\n          $quirksmode = true;\n        }\n      }\n    }\n\n    $this->_xml = $doc;\n    $this->_quirksmode = $quirksmode;\n\n    $this->_tree = new Frame_Tree($this->_xml);\n\n    restore_error_handler();\n\n    $this->restore_locale();\n  }\n\n  static function remove_text_nodes(DOMNode $node) {\n    $children = array();\n    for ($i = 0; $i < $node->childNodes->length; $i++) {\n      $child = $node->childNodes->item($i);\n      if ( $child->nodeName === \"#text\" ) {\n        $children[] = $child;\n      }\n    }\n\n    foreach($children as $child) {\n      $node->removeChild($child);\n    }\n  }\n\n  /**\n   * Builds the {@link Frame_Tree}, loads any CSS and applies the styles to\n   * the {@link Frame_Tree}\n   */\n  protected function _process_html() {\n    $this->_tree->build_tree();\n\n    $this->_css->load_css_file(Stylesheet::DEFAULT_STYLESHEET, Stylesheet::ORIG_UA);\n\n    $acceptedmedia = Stylesheet::$ACCEPTED_GENERIC_MEDIA_TYPES;\n    $acceptedmedia[] = $this->get_option(\"default_media_type\");\n\n    // <base href=\"\" />\n    $base_nodes = $this->_xml->getElementsByTagName(\"base\");\n    if ( $base_nodes->length && ($href = $base_nodes->item(0)->getAttribute(\"href\")) ) {\n      list($this->_protocol, $this->_base_host, $this->_base_path) = explode_url($href);\n    }\n\n    // Set the base path of the Stylesheet to that of the file being processed\n    $this->_css->set_protocol($this->_protocol);\n    $this->_css->set_host($this->_base_host);\n    $this->_css->set_base_path($this->_base_path);\n\n    // Get all the stylesheets so that they are processed in document order\n    $xpath = new DOMXPath($this->_xml);\n    $stylesheets = $xpath->query(\"//*[name() = 'link' or name() = 'style']\");\n\n    foreach($stylesheets as $tag) {\n      switch (strtolower($tag->nodeName)) {\n        // load <link rel=\"STYLESHEET\" ... /> tags\n        case \"link\":\n          if ( mb_strtolower(stripos($tag->getAttribute(\"rel\"), \"stylesheet\") !== false) || // may be \"appendix stylesheet\"\n            mb_strtolower($tag->getAttribute(\"type\")) === \"text/css\" ) {\n            //Check if the css file is for an accepted media type\n            //media not given then always valid\n            $formedialist = preg_split(\"/[\\s\\n,]/\", $tag->getAttribute(\"media\"),-1, PREG_SPLIT_NO_EMPTY);\n            if ( count($formedialist) > 0 ) {\n              $accept = false;\n              foreach ( $formedialist as $type ) {\n                if ( in_array(mb_strtolower(trim($type)), $acceptedmedia) ) {\n                  $accept = true;\n                  break;\n                }\n              }\n\n              if (!$accept) {\n                //found at least one mediatype, but none of the accepted ones\n                //Skip this css file.\n                continue;\n              }\n            }\n\n            $url = $tag->getAttribute(\"href\");\n            $url = build_url($this->_protocol, $this->_base_host, $this->_base_path, $url);\n\n            $this->_css->load_css_file($url, Stylesheet::ORIG_AUTHOR);\n          }\n          break;\n\n        // load <style> tags\n        case \"style\":\n          // Accept all <style> tags by default (note this is contrary to W3C\n          // HTML 4.0 spec:\n          // http://www.w3.org/TR/REC-html40/present/styles.html#adef-media\n          // which states that the default media type is 'screen'\n          if ( $tag->hasAttributes() &&\n            ($media = $tag->getAttribute(\"media\")) &&\n            !in_array($media, $acceptedmedia) ) {\n            continue;\n          }\n\n          $css = \"\";\n          if ( $tag->hasChildNodes() ) {\n            $child = $tag->firstChild;\n            while ( $child ) {\n              $css .= $child->nodeValue; // Handle <style><!-- blah --></style>\n              $child = $child->nextSibling;\n            }\n          }\n          else {\n            $css = $tag->nodeValue;\n          }\n\n          $this->_css->load_css($css);\n          break;\n      }\n    }\n  }\n\n  /**\n   * Sets the paper size & orientation\n   *\n   * @param string $size 'letter', 'legal', 'A4', etc. {@link CPDF_Adapter::$PAPER_SIZES}\n   * @param string $orientation 'portrait' or 'landscape'\n   */\n  function set_paper($size, $orientation = \"portrait\") {\n    $this->_paper_size = $size;\n    $this->_paper_orientation = $orientation;\n  }\n\n  /**\n   * Enable experimental caching capability\n   * @access private\n   */\n  function enable_caching($cache_id) {\n    $this->_cache_id = $cache_id;\n  }\n\n  /**\n   * Sets callbacks for events like rendering of pages and elements.\n   * The callbacks array contains arrays with 'event' set to 'begin_page',\n   * 'end_page', 'begin_frame', or 'end_frame' and 'f' set to a function or\n   * object plus method to be called.\n   *\n   * The function 'f' must take an array as argument, which contains info\n   * about the event.\n   *\n   * @param array $callbacks the set of callbacks to set\n   */\n  function set_callbacks($callbacks) {\n    if (is_array($callbacks)) {\n      $this->_callbacks = array();\n      foreach ($callbacks as $c) {\n        if (is_array($c) && isset($c['event']) && isset($c['f'])) {\n          $event = $c['event'];\n          $f = $c['f'];\n          if (is_callable($f) && is_string($event)) {\n            $this->_callbacks[$event][] = $f;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the quirks mode\n   *\n   * @return boolean true if quirks mode is active\n   */\n  function get_quirksmode(){\n    return $this->_quirksmode;\n  }\n\n  function parse_default_view($value) {\n    $valid = array(\"XYZ\", \"Fit\", \"FitH\", \"FitV\", \"FitR\", \"FitB\", \"FitBH\", \"FitBV\");\n\n    $options = preg_split(\"/\\s*,\\s*/\", trim($value));\n    $default_view = array_shift($options);\n\n    if ( !in_array($default_view, $valid) ) {\n      return false;\n    }\n\n    $this->set_default_view($default_view, $options);\n    return true;\n  }\n\n  /**\n   * Renders the HTML to PDF\n   */\n  function render() {\n    $this->save_locale();\n\n    $log_output_file = $this->get_option(\"log_output_file\");\n    if ( $log_output_file ) {\n      if ( !file_exists($log_output_file) && is_writable(dirname($log_output_file)) ) {\n        touch($log_output_file);\n      }\n\n      $this->_start_time = microtime(true);\n      ob_start();\n    }\n\n    //enable_mem_profile();\n\n    $this->_process_html();\n\n    $this->_css->apply_styles($this->_tree);\n\n    // @page style rules : size, margins\n    $page_styles = $this->_css->get_page_styles();\n\n    $base_page_style = $page_styles[\"base\"];\n    unset($page_styles[\"base\"]);\n\n    foreach($page_styles as $_page_style) {\n      $_page_style->inherit($base_page_style);\n    }\n\n    if ( is_array($base_page_style->size) ) {\n      $this->set_paper(array(0, 0, $base_page_style->size[0], $base_page_style->size[1]));\n    }\n\n    $this->_pdf = Canvas_Factory::get_instance($this, $this->_paper_size, $this->_paper_orientation);\n    Font_Metrics::init($this->_pdf);\n\n    if ( $this->get_option(\"enable_font_subsetting\") && $this->_pdf instanceof CPDF_Adapter ) {\n      foreach ($this->_tree->get_frames() as $frame) {\n        $style = $frame->get_style();\n        $node  = $frame->get_node();\n\n        // Handle text nodes\n        if ( $node->nodeName === \"#text\" ) {\n          $this->_pdf->register_string_subset($style->font_family, $node->nodeValue);\n          continue;\n        }\n\n        // Handle generated content (list items)\n        if ( $style->display === \"list-item\" ) {\n          $chars = List_Bullet_Renderer::get_counter_chars($style->list_style_type);\n          $this->_pdf->register_string_subset($style->font_family, $chars);\n          continue;\n        }\n        \n        // Handle other generated content (pseudo elements)\n        // FIXME: This only captures the text of the stylesheet declaration,\n        //        not the actual generated content, and forces all possible counter\n        //        values. See notes in issue #750.\n        if ( $frame->get_node()->nodeName == \"dompdf_generated\" ) {\n          // all possible counter values\n          $chars = List_Bullet_Renderer::get_counter_chars('decimal');\n          $this->_pdf->register_string_subset($style->font_family, $chars);\n          $chars = List_Bullet_Renderer::get_counter_chars('upper-alpha');\n          $this->_pdf->register_string_subset($style->font_family, $chars);\n          $chars = List_Bullet_Renderer::get_counter_chars('lower-alpha');\n          $this->_pdf->register_string_subset($style->font_family, $chars);\n          $chars = List_Bullet_Renderer::get_counter_chars('lower-greek');\n          $this->_pdf->register_string_subset($style->font_family, $chars);\n          // the text of the stylesheet declaration\n          $this->_pdf->register_string_subset($style->font_family, $style->content);\n          continue;\n        }\n      }\n    }\n\n    $root = null;\n\n    foreach ($this->_tree->get_frames() as $frame) {\n      // Set up the root frame\n      if ( is_null($root) ) {\n        $root = Frame_Factory::decorate_root( $this->_tree->get_root(), $this );\n        continue;\n      }\n\n      // Create the appropriate decorators, reflowers & positioners.\n      Frame_Factory::decorate_frame($frame, $this, $root);\n    }\n\n    // Add meta information\n    $title = $this->_xml->getElementsByTagName(\"title\");\n    if ( $title->length ) {\n      $this->_pdf->add_info(\"Title\", trim($title->item(0)->nodeValue));\n    }\n\n    $metas = $this->_xml->getElementsByTagName(\"meta\");\n    $labels = array(\n      \"author\" => \"Author\",\n      \"keywords\" => \"Keywords\",\n      \"description\" => \"Subject\",\n    );\n    foreach($metas as $meta) {\n      $name = mb_strtolower($meta->getAttribute(\"name\"));\n      $value = trim($meta->getAttribute(\"content\"));\n\n      if ( isset($labels[$name]) ) {\n        $this->_pdf->add_info($labels[$name], $value);\n        continue;\n      }\n\n      if ( $name === \"dompdf.view\" && $this->parse_default_view($value) ) {\n        $this->_pdf->set_default_view($this->_default_view, $this->_default_view_options);\n      }\n    }\n\n    $root->set_containing_block(0, 0, $this->_pdf->get_width(), $this->_pdf->get_height());\n    $root->set_renderer(new Renderer($this));\n\n    // This is where the magic happens:\n    $root->reflow();\n\n    // Clean up cached images\n    Image_Cache::clear();\n\n    global $_dompdf_warnings, $_dompdf_show_warnings;\n    if ( $_dompdf_show_warnings ) {\n      echo '<b>DOMPDF Warnings</b><br><pre>';\n      foreach ($_dompdf_warnings as $msg) {\n        echo $msg . \"\\n\";\n      }\n      echo $this->get_canvas()->get_cpdf()->messages;\n      echo '</pre>';\n      flush();\n    }\n\n    $this->restore_locale();\n  }\n\n  /**\n   * Add meta information to the PDF after rendering\n   */\n  function add_info($label, $value) {\n    if ( !is_null($this->_pdf) ) {\n      $this->_pdf->add_info($label, $value);\n    }\n  }\n\n  /**\n   * Writes the output buffer in the log file\n   *\n   * @return void\n   */\n  private function write_log() {\n    $log_output_file = $this->get_option(\"log_output_file\");\n    if ( !$log_output_file || !is_writable($log_output_file) ) {\n      return;\n    }\n\n    $frames = Frame::$ID_COUNTER;\n    $memory = DOMPDF_memory_usage() / 1024;\n    $time = (microtime(true) - $this->_start_time) * 1000;\n\n    $out = sprintf(\n      \"<span style='color: #000' title='Frames'>%6d</span>\".\n        \"<span style='color: #009' title='Memory'>%10.2f KB</span>\".\n        \"<span style='color: #900' title='Time'>%10.2f ms</span>\".\n        \"<span  title='Quirksmode'>  \".\n        ($this->_quirksmode ? \"<span style='color: #d00'> ON</span>\" : \"<span style='color: #0d0'>OFF</span>\").\n        \"</span><br />\", $frames, $memory, $time);\n\n    $out .= ob_get_clean();\n\n    $log_output_file = $this->get_option(\"log_output_file\");\n    file_put_contents($log_output_file, $out);\n  }\n\n  /**\n   * Streams the PDF to the client\n   *\n   * The file will open a download dialog by default.  The options\n   * parameter controls the output.  Accepted options are:\n   *\n   * 'Accept-Ranges' => 1 or 0 - if this is not set to 1, then this\n   *    header is not included, off by default this header seems to\n   *    have caused some problems despite the fact that it is supposed\n   *    to solve them, so I am leaving it off by default.\n   *\n   * 'compress' = > 1 or 0 - apply content stream compression, this is\n   *    on (1) by default\n   *\n   * 'Attachment' => 1 or 0 - if 1, force the browser to open a\n   *    download dialog, on (1) by default\n   *\n   * @param string $filename the name of the streamed file\n   * @param array  $options header options (see above)\n   */\n  function stream($filename, $options = null) {\n    $this->save_locale();\n\n    $this->write_log();\n\n    if ( !is_null($this->_pdf) ) {\n      $this->_pdf->stream($filename, $options);\n    }\n\n    $this->restore_locale();\n  }\n\n  /**\n   * Returns the PDF as a string\n   *\n   * The file will open a download dialog by default.  The options\n   * parameter controls the output.  Accepted options are:\n   *\n   *\n   * 'compress' = > 1 or 0 - apply content stream compression, this is\n   *    on (1) by default\n   *\n   *\n   * @param array  $options options (see above)\n   *\n   * @return string\n   */\n  function output($options = null) {\n    $this->save_locale();\n\n    $this->write_log();\n\n    if ( is_null($this->_pdf) ) {\n      return null;\n    }\n\n    $output = $this->_pdf->output( $options );\n\n    $this->restore_locale();\n\n    return $output;\n  }\n\n  /**\n   * Returns the underlying HTML document as a string\n   *\n   * @return string\n   */\n  function output_html() {\n    return $this->_xml->saveHTML();\n  }\n}\n"], "fixing_code": ["<?php\n/**\n * Command line utility to use dompdf.\n * Can also be used with HTTP GET parameters\n * \n * @package dompdf\n * @link    http://dompdf.github.com/\n * @author  Benj Carson <benjcarson@digitaljunkies.ca>\n * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n */\n\n/**\n * Display command line usage\n */\nfunction dompdf_usage() {\n  $default_paper_size = DOMPDF_DEFAULT_PAPER_SIZE;\n  \n  echo <<<EOD\n  \nUsage: {$_SERVER[\"argv\"][0]} [options] html_file\n\nhtml_file can be a filename, a url if fopen_wrappers are enabled, or the '-' character to read from standard input.\n\nOptions:\n -h             Show this message\n -l             List available paper sizes\n -p size        Paper size; something like 'letter', 'A4', 'legal', etc.  \n                  The default is '$default_paper_size'\n -o orientation Either 'portrait' or 'landscape'.  Default is 'portrait'\n -b path        Set the 'document root' of the html_file.  \n                  Relative urls (for stylesheets) are resolved using this directory.  \n                  Default is the directory of html_file.\n -f file        The output filename.  Default is the input [html_file].pdf\n -v             Verbose: display html parsing warnings and file not found errors.\n -d             Very verbose: display oodles of debugging output: every frame \n                  in the tree printed to stdout.\n -t             Comma separated list of debugging types (page-break,reflow,split)\n \nEOD;\nexit;\n}\n\n/**\n * Parses command line options\n * \n * @return array The command line options\n */\nfunction getoptions() {\n\n  $opts = array();\n\n  if ( $_SERVER[\"argc\"] == 1 )\n    return $opts;\n\n  $i = 1;\n  while ($i < $_SERVER[\"argc\"]) {\n\n    switch ($_SERVER[\"argv\"][$i]) {\n\n    case \"--help\":\n    case \"-h\":\n      $opts[\"h\"] = true;\n      $i++;\n      break;\n\n    case \"-l\":\n      $opts[\"l\"] = true;\n      $i++;\n      break;\n\n    case \"-p\":\n      if ( !isset($_SERVER[\"argv\"][$i+1]) )\n        die(\"-p switch requires a size parameter\\n\");\n      $opts[\"p\"] = $_SERVER[\"argv\"][$i+1];\n      $i += 2;\n      break;\n\n    case \"-o\":\n      if ( !isset($_SERVER[\"argv\"][$i+1]) )\n        die(\"-o switch requires an orientation parameter\\n\");\n      $opts[\"o\"] = $_SERVER[\"argv\"][$i+1];\n      $i += 2;\n      break;\n\n    case \"-b\":\n      if ( !isset($_SERVER[\"argv\"][$i+1]) )\n        die(\"-b switch requires a path parameter\\n\");\n      $opts[\"b\"] = $_SERVER[\"argv\"][$i+1];\n      $i += 2;\n      break;\n\n    case \"-f\":\n      if ( !isset($_SERVER[\"argv\"][$i+1]) )\n        die(\"-f switch requires a filename parameter\\n\");\n      $opts[\"f\"] = $_SERVER[\"argv\"][$i+1];\n      $i += 2;\n      break;\n\n    case \"-v\":\n      $opts[\"v\"] = true;\n      $i++;\n      break;\n\n    case \"-d\":\n      $opts[\"d\"] = true;\n      $i++;\n      break;\n\n    case \"-t\":\n      if ( !isset($_SERVER['argv'][$i + 1]) )\n        die(\"-t switch requires a comma separated list of types\\n\");\n      $opts[\"t\"] = $_SERVER['argv'][$i+1];\n      $i += 2;\n      break;\n\n   default:\n      $opts[\"filename\"] = $_SERVER[\"argv\"][$i];\n      $i++;\n      break;\n    }\n\n  }\n  return $opts;\n}\n\nrequire_once(\"dompdf_config.inc.php\");\nglobal $_dompdf_show_warnings, $_dompdf_debug, $_DOMPDF_DEBUG_TYPES;\n\n$sapi = php_sapi_name();\n$options = array();\n\nswitch ( $sapi ) {\n\n case \"cli\":\n\n  $opts = getoptions();\n\n  if ( isset($opts[\"h\"]) || (!isset($opts[\"filename\"]) && !isset($opts[\"l\"])) ) {\n    dompdf_usage();\n    exit;\n  }\n\n  if ( isset($opts[\"l\"]) ) {\n    echo \"\\nUnderstood paper sizes:\\n\";\n\n    foreach (array_keys(CPDF_Adapter::$PAPER_SIZES) as $size)\n      echo \"  \" . mb_strtoupper($size) . \"\\n\";\n    exit;\n  }\n  $file = $opts[\"filename\"];\n\n  if ( isset($opts[\"p\"]) )\n    $paper = $opts[\"p\"];\n  else\n    $paper = DOMPDF_DEFAULT_PAPER_SIZE;\n\n  if ( isset($opts[\"o\"]) )\n    $orientation = $opts[\"o\"];\n  else\n    $orientation = \"portrait\";\n\n  if ( isset($opts[\"b\"]) )\n    $base_path = $opts[\"b\"];\n\n  if ( isset($opts[\"f\"]) )\n    $outfile = $opts[\"f\"];\n  else {\n    if ( $file === \"-\" )\n      $outfile = \"dompdf_out.pdf\";\n    else\n      $outfile = str_ireplace(array(\".html\", \".htm\", \".php\"), \"\", $file) . \".pdf\";\n  }\n\n  if ( isset($opts[\"v\"]) )\n    $_dompdf_show_warnings = true;\n\n  if ( isset($opts[\"d\"]) ) {\n    $_dompdf_show_warnings = true;\n    $_dompdf_debug = true;\n  }\n\n  if ( isset($opts['t']) ) {\n    $arr = split(',',$opts['t']);\n    $types = array();\n    foreach ($arr as $type)\n      $types[ trim($type) ] = 1;\n    $_DOMPDF_DEBUG_TYPES = $types;\n  }\n  \n  $save_file = true;\n\n  break;\n\n default:\n\n  if ( isset($_GET[\"input_file\"]) )\n    $file = rawurldecode($_GET[\"input_file\"]);\n  else\n    throw new DOMPDF_Exception(\"An input file is required (i.e. input_file _GET variable).\");\n  \n  if ( isset($_GET[\"paper\"]) )\n    $paper = rawurldecode($_GET[\"paper\"]);\n  else\n    $paper = DOMPDF_DEFAULT_PAPER_SIZE;\n  \n  if ( isset($_GET[\"orientation\"]) )\n    $orientation = rawurldecode($_GET[\"orientation\"]);\n  else\n    $orientation = \"portrait\";\n  \n  if ( isset($_GET[\"base_path\"]) ) {\n    $base_path = rawurldecode($_GET[\"base_path\"]);\n    $file = $base_path . $file; # Set the input file\n  }  \n  \n  if ( isset($_GET[\"options\"]) ) {\n    $options = $_GET[\"options\"];\n  }\n  \n  $file_parts = explode_url($file);\n  \n  /* Check to see if the input file is local and, if so, that the base path falls within that specified by DOMDPF_CHROOT */\n  if(($file_parts['protocol'] == '' || $file_parts['protocol'] === 'file://')) {\n    $file = realpath($file);\n    if ( strpos($file, DOMPDF_CHROOT) !== 0 ) {\n      throw new DOMPDF_Exception(\"Permission denied on $file. The file could not be found under the directory specified by DOMPDF_CHROOT.\");\n    }\n  }\n  \n  if($file_parts['protocol'] === 'php://') {\n    throw new DOMPDF_Exception(\"Permission denied on $file. This script does not allow PHP streams.\");\n  }\n  \n  $outfile = \"dompdf_out.pdf\"; # Don't allow them to set the output file\n  $save_file = false; # Don't save the file\n  \n  break;\n}\n\n$dompdf = new DOMPDF();\n\nif ( $file === \"-\" ) {\n  $str = \"\";\n  while ( !feof(STDIN) )\n    $str .= fread(STDIN, 4096);\n\n  $dompdf->load_html($str);\n\n} else\n  $dompdf->load_html_file($file);\n\nif ( isset($base_path) ) {\n  $dompdf->set_base_path($base_path);\n}\n\n$dompdf->set_paper($paper, $orientation);\n\n$dompdf->render();\n\nif ( $_dompdf_show_warnings ) {\n  global $_dompdf_warnings;\n  foreach ($_dompdf_warnings as $msg)\n    echo $msg . \"\\n\";\n  echo $dompdf->get_canvas()->get_cpdf()->messages;\n  flush();\n}\n\nif ( $save_file ) {\n//   if ( !is_writable($outfile) )\n//     throw new DOMPDF_Exception(\"'$outfile' is not writable.\");\n  if ( strtolower(DOMPDF_PDF_BACKEND) === \"gd\" )\n    $outfile = str_replace(\".pdf\", \".png\", $outfile);\n\n  list($proto, $host, $path, $file) = explode_url($outfile);\n  if ( $proto != \"\" ) // i.e. not file://\n    $outfile = $file; // just save it locally, FIXME? could save it like wget: ./host/basepath/file\n\n  $outfile = realpath(dirname($outfile)) . DIRECTORY_SEPARATOR . basename($outfile);\n\n  if ( strpos($outfile, DOMPDF_CHROOT) !== 0 )\n    throw new DOMPDF_Exception(\"Permission denied.\");\n\n  file_put_contents($outfile, $dompdf->output( array(\"compress\" => 0) ));\n  exit(0);\n}\n\nif ( !headers_sent() ) {\n  $dompdf->stream($outfile, $options);\n}\n", "<?php\n/**\n * @package dompdf\n * @link    http://dompdf.github.com/\n * @author  Benj Carson <benjcarson@digitaljunkies.ca>\n * @author  Fabien M\u00e9nager <fabien.menager@gmail.com>\n * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License\n */\n\n/**\n * DOMPDF - PHP5 HTML to PDF renderer\n *\n * DOMPDF loads HTML and does its best to render it as a PDF.  It gets its\n * name from the new DomDocument PHP5 extension.  Source HTML is first\n * parsed by a DomDocument object.  DOMPDF takes the resulting DOM tree and\n * attaches a {@link Frame} object to each node.  {@link Frame} objects store\n * positioning and layout information and each has a reference to a {@link\n * Style} object.\n *\n * Style information is loaded and parsed (see {@link Stylesheet}) and is\n * applied to the frames in the tree by using XPath.  CSS selectors are\n * converted into XPath queries, and the computed {@link Style} objects are\n * applied to the {@link Frame}s.\n *\n * {@link Frame}s are then decorated (in the design pattern sense of the\n * word) based on their CSS display property ({@link\n * http://www.w3.org/TR/CSS21/visuren.html#propdef-display}).\n * Frame_Decorators augment the basic {@link Frame} class by adding\n * additional properties and methods specific to the particular type of\n * {@link Frame}.  For example, in the CSS layout model, block frames\n * (display: block;) contain line boxes that are usually filled with text or\n * other inline frames.  The Block_Frame_Decorator therefore adds a $lines\n * property as well as methods to add {@link Frame}s to lines and to add\n * additional lines.  {@link Frame}s also are attached to specific\n * Positioner and {@link Frame_Reflower} objects that contain the\n * positioining and layout algorithm for a specific type of frame,\n * respectively.  This is an application of the Strategy pattern.\n *\n * Layout, or reflow, proceeds recursively (post-order) starting at the root\n * of the document.  Space constraints (containing block width & height) are\n * pushed down, and resolved positions and sizes bubble up.  Thus, every\n * {@link Frame} in the document tree is traversed once (except for tables\n * which use a two-pass layout algorithm).  If you are interested in the\n * details, see the reflow() method of the Reflower classes.\n *\n * Rendering is relatively straightforward once layout is complete. {@link\n * Frame}s are rendered using an adapted {@link Cpdf} class, originally\n * written by Wayne Munro, http://www.ros.co.nz/pdf/.  (Some performance\n * related changes have been made to the original {@link Cpdf} class, and\n * the {@link CPDF_Adapter} class provides a simple, stateless interface to\n * PDF generation.)  PDFLib support has now also been added, via the {@link\n * PDFLib_Adapter}.\n *\n *\n * @package dompdf\n */\nclass DOMPDF {\n\n  /**\n   * DomDocument representing the HTML document\n   *\n   * @var DOMDocument\n   */\n  protected $_xml;\n\n  /**\n   * Frame_Tree derived from the DOM tree\n   *\n   * @var Frame_Tree\n   */\n  protected $_tree;\n\n  /**\n   * Stylesheet for the document\n   *\n   * @var Stylesheet\n   */\n  protected $_css;\n\n  /**\n   * Actual PDF renderer\n   *\n   * @var Canvas\n   */\n  protected $_pdf;\n\n  /**\n   * Desired paper size ('letter', 'legal', 'A4', etc.)\n   *\n   * @var string\n   */\n  protected $_paper_size;\n\n  /**\n   * Paper orientation ('portrait' or 'landscape')\n   *\n   * @var string\n   */\n  protected $_paper_orientation;\n\n  /**\n   * Callbacks on new page and new element\n   *\n   * @var array\n   */\n  protected $_callbacks;\n\n  /**\n   * Experimental caching capability\n   *\n   * @var string\n   */\n  private $_cache_id;\n\n  /**\n   * Base hostname\n   *\n   * Used for relative paths/urls\n   * @var string\n   */\n  protected $_base_host;\n\n  /**\n   * Absolute base path\n   *\n   * Used for relative paths/urls\n   * @var string\n   */\n  protected $_base_path;\n\n  /**\n   * Protcol used to request file (file://, http://, etc)\n   *\n   * @var string\n   */\n  protected $_protocol;\n\n  /**\n   * HTTP context created with stream_context_create()\n   * Will be used for file_get_contents\n   *\n   * @var resource\n   */\n  protected $_http_context;\n\n  /**\n   * Timestamp of the script start time\n   *\n   * @var int\n   */\n  private $_start_time = null;\n\n  /**\n   * The system's locale\n   *\n   * @var string\n   */\n  private $_system_locale = null;\n\n  /**\n   * Tells if the system's locale is the C standard one\n   *\n   * @var bool\n   */\n  private $_locale_standard = false;\n\n  /**\n   * The default view of the PDF in the viewer\n   *\n   * @var string\n   */\n  private $_default_view = \"Fit\";\n\n  /**\n   * The default view options of the PDF in the viewer\n   *\n   * @var array\n   */\n  private $_default_view_options = array();\n\n  /**\n   * Tells wether the DOM document is in quirksmode (experimental)\n   *\n   * @var bool\n   */\n  private $_quirksmode = false;\n\n  /**\n   * The list of built-in fonts\n   *\n   * @var array\n   */\n  public static $native_fonts = array(\n    \"courier\", \"courier-bold\", \"courier-oblique\", \"courier-boldoblique\",\n    \"helvetica\", \"helvetica-bold\", \"helvetica-oblique\", \"helvetica-boldoblique\",\n    \"times-roman\", \"times-bold\", \"times-italic\", \"times-bolditalic\",\n    \"symbol\", \"zapfdinbats\"\n  );\n\n  private $_options = array(\n    // Directories\n    \"temp_dir\"                 => DOMPDF_TEMP_DIR,\n    \"font_dir\"                 => DOMPDF_FONT_DIR,\n    \"font_cache\"               => DOMPDF_FONT_CACHE,\n    \"chroot\"                   => DOMPDF_CHROOT,\n    \"log_output_file\"          => DOMPDF_LOG_OUTPUT_FILE,\n\n    // Rendering\n    \"default_media_type\"       => DOMPDF_DEFAULT_MEDIA_TYPE,\n    \"default_paper_size\"       => DOMPDF_DEFAULT_PAPER_SIZE,\n    \"default_font\"             => DOMPDF_DEFAULT_FONT,\n    \"dpi\"                      => DOMPDF_DPI,\n    \"font_height_ratio\"        => DOMPDF_FONT_HEIGHT_RATIO,\n\n    // Features\n    \"enable_unicode\"           => DOMPDF_UNICODE_ENABLED,\n    \"enable_php\"               => DOMPDF_ENABLE_PHP,\n    \"enable_remote\"            => DOMPDF_ENABLE_REMOTE,\n    \"enable_css_float\"         => DOMPDF_ENABLE_CSS_FLOAT,\n    \"enable_javascript\"        => DOMPDF_ENABLE_JAVASCRIPT,\n    \"enable_html5_parser\"      => DOMPDF_ENABLE_HTML5PARSER,\n    \"enable_font_subsetting\"   => DOMPDF_ENABLE_FONTSUBSETTING,\n\n    // Debug\n    \"debug_png\"                => DEBUGPNG,\n    \"debug_keep_temp\"          => DEBUGKEEPTEMP,\n    \"debug_css\"                => DEBUGCSS,\n    \"debug_layout\"             => DEBUG_LAYOUT,\n    \"debug_layout_lines\"       => DEBUG_LAYOUT_LINES,\n    \"debug_layout_blocks\"      => DEBUG_LAYOUT_BLOCKS,\n    \"debug_layout_inline\"      => DEBUG_LAYOUT_INLINE,\n    \"debug_layout_padding_box\" => DEBUG_LAYOUT_PADDINGBOX,\n\n    // Admin\n    \"admin_username\"           => DOMPDF_ADMIN_USERNAME,\n    \"admin_password\"           => DOMPDF_ADMIN_PASSWORD,\n  );\n\n  /**\n   * Class constructor\n   */\n  function __construct() {\n    $this->_locale_standard = sprintf('%.1f', 1.0) == '1.0';\n\n    $this->save_locale();\n\n    $this->_messages = array();\n    $this->_css = new Stylesheet($this);\n    $this->_pdf = null;\n    $this->_paper_size = DOMPDF_DEFAULT_PAPER_SIZE;\n    $this->_paper_orientation = \"portrait\";\n    $this->_base_protocol = \"\";\n    $this->_base_host = \"\";\n    $this->_base_path = \"\";\n    $this->_http_context = null;\n    $this->_callbacks = array();\n    $this->_cache_id = null;\n\n    $this->restore_locale();\n  }\n\n  /**\n   * Class destructor\n   */\n  function __destruct() {\n    clear_object($this);\n  }\n\n  /**\n   * Get the dompdf option value\n   *\n   * @param string $key\n   *\n   * @return mixed\n   * @throws DOMPDF_Exception\n   */\n  function get_option($key) {\n    if ( !array_key_exists($key, $this->_options) ) {\n      throw new DOMPDF_Exception(\"Option '$key' doesn't exist\");\n    }\n\n    return $this->_options[$key];\n  }\n\n  /**\n   * @param string $key\n   * @param mixed  $value\n   *\n   * @throws DOMPDF_Exception\n   */\n  function set_option($key, $value) {\n    if ( !array_key_exists($key, $this->_options) ) {\n      throw new DOMPDF_Exception(\"Option '$key' doesn't exist\");\n    }\n\n    $this->_options[$key] = $value;\n  }\n\n  /**\n   * @param array $options\n   */\n  function set_options(array $options) {\n    foreach ($options as $key => $value) {\n      $this->set_option($key, $value);\n    }\n  }\n\n  /**\n   * Save the system's locale configuration and\n   * set the right value for numeric formatting\n   */\n  private function save_locale() {\n    if ( $this->_locale_standard ) {\n      return;\n    }\n\n    $this->_system_locale = setlocale(LC_NUMERIC, \"0\");\n    setlocale(LC_NUMERIC, \"C\");\n  }\n\n  /**\n   * Restore the system's locale configuration\n   */\n  private function restore_locale() {\n    if ( $this->_locale_standard ) {\n      return;\n    }\n\n    setlocale(LC_NUMERIC, $this->_system_locale);\n  }\n\n  /**\n   * Returns the underlying {@link Frame_Tree} object\n   *\n   * @return Frame_Tree\n   */\n  function get_tree() {\n    return $this->_tree;\n  }\n\n  /**\n   * Sets the protocol to use\n   * FIXME validate these\n   *\n   * @param string $proto\n   */\n  function set_protocol($proto) {\n    $this->_protocol = $proto;\n  }\n\n  /**\n   * Sets the base hostname\n   *\n   * @param string $host\n   */\n  function set_host($host) {\n    $this->_base_host = $host;\n  }\n\n  /**\n   * Sets the base path\n   *\n   * @param string $path\n   */\n  function set_base_path($path) {\n    $this->_base_path = $path;\n  }\n\n  /**\n   * Sets the HTTP context\n   *\n   * @param resource $http_context\n   */\n  function set_http_context($http_context) {\n    $this->_http_context = $http_context;\n  }\n\n  /**\n   * Sets the default view\n   *\n   * @param string $default_view The default document view\n   * @param array  $options      The view's options\n   */\n  function set_default_view($default_view, $options) {\n    $this->_default_view = $default_view;\n    $this->_default_view_options = $options;\n  }\n\n  /**\n   * Returns the protocol in use\n   *\n   * @return string\n   */\n  function get_protocol() {\n    return $this->_protocol;\n  }\n\n  /**\n   * Returns the base hostname\n   *\n   * @return string\n   */\n  function get_host() {\n    return $this->_base_host;\n  }\n\n  /**\n   * Returns the base path\n   *\n   * @return string\n   */\n  function get_base_path() {\n    return $this->_base_path;\n  }\n\n  /**\n   * Returns the HTTP context\n   *\n   * @return resource\n   */\n  function get_http_context() {\n    return $this->_http_context;\n  }\n\n  /**\n   * Return the underlying Canvas instance (e.g. CPDF_Adapter, GD_Adapter)\n   *\n   * @return Canvas\n   */\n  function get_canvas() {\n    return $this->_pdf;\n  }\n\n  /**\n   * Returns the callbacks array\n   *\n   * @return array\n   */\n  function get_callbacks() {\n    return $this->_callbacks;\n  }\n\n  /**\n   * Returns the stylesheet\n   *\n   * @return Stylesheet\n   */\n  function get_css() {\n    return $this->_css;\n  }\n\n  /**\n   * @return DOMDocument\n   */\n  function get_dom() {\n    return $this->_xml;\n  }\n\n  /**\n   * Loads an HTML file\n   * Parse errors are stored in the global array _dompdf_warnings.\n   *\n   * @param string $file a filename or url to load\n   *\n   * @throws DOMPDF_Exception\n   */\n  function load_html_file($file) {\n    $this->save_locale();\n\n    // Store parsing warnings as messages (this is to prevent output to the\n    // browser if the html is ugly and the dom extension complains,\n    // preventing the pdf from being streamed.)\n    if ( !$this->_protocol && !$this->_base_host && !$this->_base_path ) {\n      list($this->_protocol, $this->_base_host, $this->_base_path) = explode_url($file);\n    }\n\n    if ( !$this->get_option(\"enable_remote\") && ($this->_protocol != \"\" && $this->_protocol !== \"file://\" ) ) {\n      throw new DOMPDF_Exception(\"Remote file requested, but DOMPDF_ENABLE_REMOTE is false.\");\n    }\n\n    if ($this->_protocol == \"\" || $this->_protocol === \"file://\") {\n\n      // Get the full path to $file, returns false if the file doesn't exist\n      $realfile = realpath($file);\n      if ( !$realfile ) {\n        throw new DOMPDF_Exception(\"File '$file' not found.\");\n      }\n\n      $chroot = $this->get_option(\"chroot\");\n      if ( strpos($realfile, $chroot) !== 0 ) {\n        throw new DOMPDF_Exception(\"Permission denied on $file. The file could not be found under the directory specified by DOMPDF_CHROOT.\");\n      }\n\n      // Exclude dot files (e.g. .htaccess)\n      if ( substr(basename($realfile), 0, 1) === \".\" ) {\n        throw new DOMPDF_Exception(\"Permission denied on $file.\");\n      }\n\n      $file = $realfile;\n    }\n\n    $contents = file_get_contents($file, null, $this->_http_context);\n    $encoding = null;\n\n    // See http://the-stickman.com/web-development/php/getting-http-response-headers-when-using-file_get_contents/\n    if ( isset($http_response_header) ) {\n      foreach($http_response_header as $_header) {\n        if ( preg_match(\"@Content-Type:\\s*[\\w/]+;\\s*?charset=([^\\s]+)@i\", $_header, $matches) ) {\n          $encoding = strtoupper($matches[1]);\n          break;\n        }\n      }\n    }\n\n    $this->restore_locale();\n\n    $this->load_html($contents, $encoding);\n  }\n\n  /**\n   * Loads an HTML string\n   * Parse errors are stored in the global array _dompdf_warnings.\n   * @todo use the $encoding variable\n   *\n   * @param string $str      HTML text to load\n   * @param string $encoding Not used yet\n   */\n  function load_html($str, $encoding = null) {\n    $this->save_locale();\n\n    // FIXME: Determine character encoding, switch to UTF8, update meta tag. Need better http/file stream encoding detection, currently relies on text or meta tag.\n    mb_detect_order('auto');\n\n    if (mb_detect_encoding($str) !== 'UTF-8') {\n      $metatags = array(\n        '@<meta\\s+http-equiv=\"Content-Type\"\\s+content=\"(?:[\\w/]+)(?:;\\s*?charset=([^\\s\"]+))?@i',\n        '@<meta\\s+content=\"(?:[\\w/]+)(?:;\\s*?charset=([^\\s\"]+))\"?\\s+http-equiv=\"Content-Type\"@i',\n        '@<meta [^>]*charset\\s*=\\s*[\"\\']?\\s*([^\"\\' ]+)@i',\n      );\n\n      foreach($metatags as $metatag) {\n        if (preg_match($metatag, $str, $matches)) break;\n      }\n\n      if (mb_detect_encoding($str) == '') {\n        if (isset($matches[1])) {\n          $encoding = strtoupper($matches[1]);\n        }\n        else {\n          $encoding = 'UTF-8';\n        }\n      }\n      else {\n        if ( isset($matches[1]) ) {\n          $encoding = strtoupper($matches[1]);\n        }\n        else {\n          $encoding = 'auto';\n        }\n      }\n\n      if ( $encoding !== 'UTF-8' ) {\n        $str = mb_convert_encoding($str, 'UTF-8', $encoding);\n      }\n\n      if ( isset($matches[1]) ) {\n        $str = preg_replace('/charset=([^\\s\"]+)/i', 'charset=UTF-8', $str);\n      }\n      else {\n        $str = str_replace('<head>', '<head><meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">', $str);\n      }\n    }\n    else {\n      $encoding = 'UTF-8';\n    }\n\n    // remove BOM mark from UTF-8, it's treated as document text by DOMDocument\n    // FIXME: roll this into the encoding detection using UTF-8/16/32 BOM (http://us2.php.net/manual/en/function.mb-detect-encoding.php#91051)?\n    if ( substr($str, 0, 3) == chr(0xEF).chr(0xBB).chr(0xBF) ) {\n      $str = substr($str, 3);\n    }\n\n    // if the document contains non utf-8 with a utf-8 meta tag chars and was \n    // detected as utf-8 by mbstring, problems could happen.\n    // http://devzone.zend.com/article/8855\n    if ( $encoding !== 'UTF-8' ) {\n      $re = '/<meta ([^>]*)((?:charset=[^\"\\' ]+)([^>]*)|(?:charset=[\"\\'][^\"\\' ]+[\"\\']))([^>]*)>/i';\n      $str = preg_replace($re, '<meta $1$3>', $str);\n    }\n\n    // Store parsing warnings as messages\n    set_error_handler(\"record_warnings\");\n\n    // @todo Take the quirksmode into account\n    // http://hsivonen.iki.fi/doctype/\n    // https://developer.mozilla.org/en/mozilla's_quirks_mode\n    $quirksmode = false;\n\n    if ( $this->get_option(\"enable_html5_parser\") ) {\n      $tokenizer = new HTML5_Tokenizer($str);\n      $tokenizer->parse();\n      $doc = $tokenizer->save();\n\n      // Remove #text children nodes in nodes that shouldn't have\n      $tag_names = array(\"html\", \"table\", \"tbody\", \"thead\", \"tfoot\", \"tr\");\n      foreach($tag_names as $tag_name) {\n        $nodes = $doc->getElementsByTagName($tag_name);\n\n        foreach($nodes as $node) {\n          self::remove_text_nodes($node);\n        }\n      }\n\n      $quirksmode = ($tokenizer->getTree()->getQuirksMode() > HTML5_TreeBuilder::NO_QUIRKS);\n    }\n    else {\n      // loadHTML assumes ISO-8859-1 unless otherwise specified, but there are\n      // bugs in how DOMDocument determines the actual encoding. Converting to\n      // HTML-ENTITIES prior to import appears to resolve the issue.\n      // http://devzone.zend.com/1538/php-dom-xml-extension-encoding-processing/ (see #4)\n      // http://stackoverflow.com/a/11310258/264628\n      $doc = new DOMDocument();\n      $doc->preserveWhiteSpace = true;\n      $doc->loadHTML( mb_convert_encoding( $str , 'HTML-ENTITIES' , 'UTF-8' ) );\n\n      // If some text is before the doctype, we are in quirksmode\n      if ( preg_match(\"/^(.+)<!doctype/i\", ltrim($str), $matches) ) {\n        $quirksmode = true;\n      }\n      // If no doctype is provided, we are in quirksmode\n      elseif ( !preg_match(\"/^<!doctype/i\", ltrim($str), $matches) ) {\n        $quirksmode = true;\n      }\n      else {\n        // HTML5 <!DOCTYPE html>\n        if ( !$doc->doctype->publicId && !$doc->doctype->systemId ) {\n          $quirksmode = false;\n        }\n\n        // not XHTML\n        if ( !preg_match(\"/xhtml/i\", $doc->doctype->publicId) ) {\n          $quirksmode = true;\n        }\n      }\n    }\n\n    $this->_xml = $doc;\n    $this->_quirksmode = $quirksmode;\n\n    $this->_tree = new Frame_Tree($this->_xml);\n\n    restore_error_handler();\n\n    $this->restore_locale();\n  }\n\n  static function remove_text_nodes(DOMNode $node) {\n    $children = array();\n    for ($i = 0; $i < $node->childNodes->length; $i++) {\n      $child = $node->childNodes->item($i);\n      if ( $child->nodeName === \"#text\" ) {\n        $children[] = $child;\n      }\n    }\n\n    foreach($children as $child) {\n      $node->removeChild($child);\n    }\n  }\n\n  /**\n   * Builds the {@link Frame_Tree}, loads any CSS and applies the styles to\n   * the {@link Frame_Tree}\n   */\n  protected function _process_html() {\n    $this->_tree->build_tree();\n\n    $this->_css->load_css_file(Stylesheet::DEFAULT_STYLESHEET, Stylesheet::ORIG_UA);\n\n    $acceptedmedia = Stylesheet::$ACCEPTED_GENERIC_MEDIA_TYPES;\n    $acceptedmedia[] = $this->get_option(\"default_media_type\");\n\n    // <base href=\"\" />\n    $base_nodes = $this->_xml->getElementsByTagName(\"base\");\n    if ( $base_nodes->length && ($href = $base_nodes->item(0)->getAttribute(\"href\")) ) {\n      list($this->_protocol, $this->_base_host, $this->_base_path) = explode_url($href);\n    }\n\n    // Set the base path of the Stylesheet to that of the file being processed\n    $this->_css->set_protocol($this->_protocol);\n    $this->_css->set_host($this->_base_host);\n    $this->_css->set_base_path($this->_base_path);\n\n    // Get all the stylesheets so that they are processed in document order\n    $xpath = new DOMXPath($this->_xml);\n    $stylesheets = $xpath->query(\"//*[name() = 'link' or name() = 'style']\");\n\n    foreach($stylesheets as $tag) {\n      switch (strtolower($tag->nodeName)) {\n        // load <link rel=\"STYLESHEET\" ... /> tags\n        case \"link\":\n          if ( mb_strtolower(stripos($tag->getAttribute(\"rel\"), \"stylesheet\") !== false) || // may be \"appendix stylesheet\"\n            mb_strtolower($tag->getAttribute(\"type\")) === \"text/css\" ) {\n            //Check if the css file is for an accepted media type\n            //media not given then always valid\n            $formedialist = preg_split(\"/[\\s\\n,]/\", $tag->getAttribute(\"media\"),-1, PREG_SPLIT_NO_EMPTY);\n            if ( count($formedialist) > 0 ) {\n              $accept = false;\n              foreach ( $formedialist as $type ) {\n                if ( in_array(mb_strtolower(trim($type)), $acceptedmedia) ) {\n                  $accept = true;\n                  break;\n                }\n              }\n\n              if (!$accept) {\n                //found at least one mediatype, but none of the accepted ones\n                //Skip this css file.\n                continue;\n              }\n            }\n\n            $url = $tag->getAttribute(\"href\");\n            $url = build_url($this->_protocol, $this->_base_host, $this->_base_path, $url);\n\n            $this->_css->load_css_file($url, Stylesheet::ORIG_AUTHOR);\n          }\n          break;\n\n        // load <style> tags\n        case \"style\":\n          // Accept all <style> tags by default (note this is contrary to W3C\n          // HTML 4.0 spec:\n          // http://www.w3.org/TR/REC-html40/present/styles.html#adef-media\n          // which states that the default media type is 'screen'\n          if ( $tag->hasAttributes() &&\n            ($media = $tag->getAttribute(\"media\")) &&\n            !in_array($media, $acceptedmedia) ) {\n            continue;\n          }\n\n          $css = \"\";\n          if ( $tag->hasChildNodes() ) {\n            $child = $tag->firstChild;\n            while ( $child ) {\n              $css .= $child->nodeValue; // Handle <style><!-- blah --></style>\n              $child = $child->nextSibling;\n            }\n          }\n          else {\n            $css = $tag->nodeValue;\n          }\n\n          $this->_css->load_css($css);\n          break;\n      }\n    }\n  }\n\n  /**\n   * Sets the paper size & orientation\n   *\n   * @param string $size 'letter', 'legal', 'A4', etc. {@link CPDF_Adapter::$PAPER_SIZES}\n   * @param string $orientation 'portrait' or 'landscape'\n   */\n  function set_paper($size, $orientation = \"portrait\") {\n    $this->_paper_size = $size;\n    $this->_paper_orientation = $orientation;\n  }\n\n  /**\n   * Enable experimental caching capability\n   * @access private\n   */\n  function enable_caching($cache_id) {\n    $this->_cache_id = $cache_id;\n  }\n\n  /**\n   * Sets callbacks for events like rendering of pages and elements.\n   * The callbacks array contains arrays with 'event' set to 'begin_page',\n   * 'end_page', 'begin_frame', or 'end_frame' and 'f' set to a function or\n   * object plus method to be called.\n   *\n   * The function 'f' must take an array as argument, which contains info\n   * about the event.\n   *\n   * @param array $callbacks the set of callbacks to set\n   */\n  function set_callbacks($callbacks) {\n    if (is_array($callbacks)) {\n      $this->_callbacks = array();\n      foreach ($callbacks as $c) {\n        if (is_array($c) && isset($c['event']) && isset($c['f'])) {\n          $event = $c['event'];\n          $f = $c['f'];\n          if (is_callable($f) && is_string($event)) {\n            $this->_callbacks[$event][] = $f;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the quirks mode\n   *\n   * @return boolean true if quirks mode is active\n   */\n  function get_quirksmode(){\n    return $this->_quirksmode;\n  }\n\n  function parse_default_view($value) {\n    $valid = array(\"XYZ\", \"Fit\", \"FitH\", \"FitV\", \"FitR\", \"FitB\", \"FitBH\", \"FitBV\");\n\n    $options = preg_split(\"/\\s*,\\s*/\", trim($value));\n    $default_view = array_shift($options);\n\n    if ( !in_array($default_view, $valid) ) {\n      return false;\n    }\n\n    $this->set_default_view($default_view, $options);\n    return true;\n  }\n\n  /**\n   * Renders the HTML to PDF\n   */\n  function render() {\n    $this->save_locale();\n\n    $log_output_file = $this->get_option(\"log_output_file\");\n    if ( $log_output_file ) {\n      if ( !file_exists($log_output_file) && is_writable(dirname($log_output_file)) ) {\n        touch($log_output_file);\n      }\n\n      $this->_start_time = microtime(true);\n      ob_start();\n    }\n\n    //enable_mem_profile();\n\n    $this->_process_html();\n\n    $this->_css->apply_styles($this->_tree);\n\n    // @page style rules : size, margins\n    $page_styles = $this->_css->get_page_styles();\n\n    $base_page_style = $page_styles[\"base\"];\n    unset($page_styles[\"base\"]);\n\n    foreach($page_styles as $_page_style) {\n      $_page_style->inherit($base_page_style);\n    }\n\n    if ( is_array($base_page_style->size) ) {\n      $this->set_paper(array(0, 0, $base_page_style->size[0], $base_page_style->size[1]));\n    }\n\n    $this->_pdf = Canvas_Factory::get_instance($this, $this->_paper_size, $this->_paper_orientation);\n    Font_Metrics::init($this->_pdf);\n\n    if ( $this->get_option(\"enable_font_subsetting\") && $this->_pdf instanceof CPDF_Adapter ) {\n      foreach ($this->_tree->get_frames() as $frame) {\n        $style = $frame->get_style();\n        $node  = $frame->get_node();\n\n        // Handle text nodes\n        if ( $node->nodeName === \"#text\" ) {\n          $this->_pdf->register_string_subset($style->font_family, $node->nodeValue);\n          continue;\n        }\n\n        // Handle generated content (list items)\n        if ( $style->display === \"list-item\" ) {\n          $chars = List_Bullet_Renderer::get_counter_chars($style->list_style_type);\n          $this->_pdf->register_string_subset($style->font_family, $chars);\n          continue;\n        }\n        \n        // Handle other generated content (pseudo elements)\n        // FIXME: This only captures the text of the stylesheet declaration,\n        //        not the actual generated content, and forces all possible counter\n        //        values. See notes in issue #750.\n        if ( $frame->get_node()->nodeName == \"dompdf_generated\" ) {\n          // all possible counter values\n          $chars = List_Bullet_Renderer::get_counter_chars('decimal');\n          $this->_pdf->register_string_subset($style->font_family, $chars);\n          $chars = List_Bullet_Renderer::get_counter_chars('upper-alpha');\n          $this->_pdf->register_string_subset($style->font_family, $chars);\n          $chars = List_Bullet_Renderer::get_counter_chars('lower-alpha');\n          $this->_pdf->register_string_subset($style->font_family, $chars);\n          $chars = List_Bullet_Renderer::get_counter_chars('lower-greek');\n          $this->_pdf->register_string_subset($style->font_family, $chars);\n          // the text of the stylesheet declaration\n          $this->_pdf->register_string_subset($style->font_family, $style->content);\n          continue;\n        }\n      }\n    }\n\n    $root = null;\n\n    foreach ($this->_tree->get_frames() as $frame) {\n      // Set up the root frame\n      if ( is_null($root) ) {\n        $root = Frame_Factory::decorate_root( $this->_tree->get_root(), $this );\n        continue;\n      }\n\n      // Create the appropriate decorators, reflowers & positioners.\n      Frame_Factory::decorate_frame($frame, $this, $root);\n    }\n\n    // Add meta information\n    $title = $this->_xml->getElementsByTagName(\"title\");\n    if ( $title->length ) {\n      $this->_pdf->add_info(\"Title\", trim($title->item(0)->nodeValue));\n    }\n\n    $metas = $this->_xml->getElementsByTagName(\"meta\");\n    $labels = array(\n      \"author\" => \"Author\",\n      \"keywords\" => \"Keywords\",\n      \"description\" => \"Subject\",\n    );\n    foreach($metas as $meta) {\n      $name = mb_strtolower($meta->getAttribute(\"name\"));\n      $value = trim($meta->getAttribute(\"content\"));\n\n      if ( isset($labels[$name]) ) {\n        $this->_pdf->add_info($labels[$name], $value);\n        continue;\n      }\n\n      if ( $name === \"dompdf.view\" && $this->parse_default_view($value) ) {\n        $this->_pdf->set_default_view($this->_default_view, $this->_default_view_options);\n      }\n    }\n\n    $root->set_containing_block(0, 0, $this->_pdf->get_width(), $this->_pdf->get_height());\n    $root->set_renderer(new Renderer($this));\n\n    // This is where the magic happens:\n    $root->reflow();\n\n    // Clean up cached images\n    Image_Cache::clear();\n\n    global $_dompdf_warnings, $_dompdf_show_warnings;\n    if ( $_dompdf_show_warnings ) {\n      echo '<b>DOMPDF Warnings</b><br><pre>';\n      foreach ($_dompdf_warnings as $msg) {\n        echo $msg . \"\\n\";\n      }\n      echo $this->get_canvas()->get_cpdf()->messages;\n      echo '</pre>';\n      flush();\n    }\n\n    $this->restore_locale();\n  }\n\n  /**\n   * Add meta information to the PDF after rendering\n   */\n  function add_info($label, $value) {\n    if ( !is_null($this->_pdf) ) {\n      $this->_pdf->add_info($label, $value);\n    }\n  }\n\n  /**\n   * Writes the output buffer in the log file\n   *\n   * @return void\n   */\n  private function write_log() {\n    $log_output_file = $this->get_option(\"log_output_file\");\n    if ( !$log_output_file || !is_writable($log_output_file) ) {\n      return;\n    }\n\n    $frames = Frame::$ID_COUNTER;\n    $memory = DOMPDF_memory_usage() / 1024;\n    $time = (microtime(true) - $this->_start_time) * 1000;\n\n    $out = sprintf(\n      \"<span style='color: #000' title='Frames'>%6d</span>\".\n        \"<span style='color: #009' title='Memory'>%10.2f KB</span>\".\n        \"<span style='color: #900' title='Time'>%10.2f ms</span>\".\n        \"<span  title='Quirksmode'>  \".\n        ($this->_quirksmode ? \"<span style='color: #d00'> ON</span>\" : \"<span style='color: #0d0'>OFF</span>\").\n        \"</span><br />\", $frames, $memory, $time);\n\n    $out .= ob_get_clean();\n\n    $log_output_file = $this->get_option(\"log_output_file\");\n    file_put_contents($log_output_file, $out);\n  }\n\n  /**\n   * Streams the PDF to the client\n   *\n   * The file will open a download dialog by default.  The options\n   * parameter controls the output.  Accepted options are:\n   *\n   * 'Accept-Ranges' => 1 or 0 - if this is not set to 1, then this\n   *    header is not included, off by default this header seems to\n   *    have caused some problems despite the fact that it is supposed\n   *    to solve them, so I am leaving it off by default.\n   *\n   * 'compress' = > 1 or 0 - apply content stream compression, this is\n   *    on (1) by default\n   *\n   * 'Attachment' => 1 or 0 - if 1, force the browser to open a\n   *    download dialog, on (1) by default\n   *\n   * @param string $filename the name of the streamed file\n   * @param array  $options header options (see above)\n   */\n  function stream($filename, $options = null) {\n    $this->save_locale();\n\n    $this->write_log();\n\n    if ( !is_null($this->_pdf) ) {\n      $this->_pdf->stream($filename, $options);\n    }\n\n    $this->restore_locale();\n  }\n\n  /**\n   * Returns the PDF as a string\n   *\n   * The file will open a download dialog by default.  The options\n   * parameter controls the output.  Accepted options are:\n   *\n   *\n   * 'compress' = > 1 or 0 - apply content stream compression, this is\n   *    on (1) by default\n   *\n   *\n   * @param array  $options options (see above)\n   *\n   * @return string\n   */\n  function output($options = null) {\n    $this->save_locale();\n\n    $this->write_log();\n\n    if ( is_null($this->_pdf) ) {\n      return null;\n    }\n\n    $output = $this->_pdf->output( $options );\n\n    $this->restore_locale();\n\n    return $output;\n  }\n\n  /**\n   * Returns the underlying HTML document as a string\n   *\n   * @return string\n   */\n  function output_html() {\n    return $this->_xml->saveHTML();\n  }\n}\n"], "filenames": ["dompdf.php", "include/dompdf.cls.php"], "buggy_code_start_loc": [229, 583], "buggy_code_end_loc": [229, 590], "fixing_code_start_loc": [230, 582], "fixing_code_end_loc": [234, 582], "type": "CWE-200", "message": "dompdf.php in dompdf before 0.6.1, when DOMPDF_ENABLE_PHP is enabled, allows context-dependent attackers to bypass chroot protections and read arbitrary files via a PHP protocol and wrappers in the input_file parameter, as demonstrated by a php://filter/read=convert.base64-encode/resource in the input_file parameter.", "other": {"cve": {"id": "CVE-2014-2383", "sourceIdentifier": "cve@mitre.org", "published": "2014-04-28T14:09:06.707", "lastModified": "2023-02-02T12:15:08.520", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "dompdf.php in dompdf before 0.6.1, when DOMPDF_ENABLE_PHP is enabled, allows context-dependent attackers to bypass chroot protections and read arbitrary files via a PHP protocol and wrappers in the input_file parameter, as demonstrated by a php://filter/read=convert.base64-encode/resource in the input_file parameter."}, {"lang": "es", "value": "dompdf.php en dompdf anterior a 0.6.1, cuando DOMPDF_ENABLE_PHP est\u00e1 habilitado, permite a atacantes dependientes de contexto evadir protecciones chroot y leer archivos arbitrarios a trav\u00e9s de un protocolo PHP y envoltorios en el par\u00e1metro input_file, tal y como fue demostrado por un php://filter/read=convert.base64-encode/resource en el par\u00e1metro input_file."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dompdf:dompdf:*:beta3:*:*:*:*:*:*", "versionEndIncluding": "0.6.0", "matchCriteriaId": "8695C9FA-C3ED-45EB-8533-C8C78C413DBE"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2014/Apr/258", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/archive/1/531912/100/0/threaded", "source": "cve@mitre.org", "tags": ["Broken Link", "Third Party Advisory", "VDB Entry"]}, {"url": "https://explore.avertium.com/resource/lfi-rfi-escalation-to-rce", "source": "cve@mitre.org"}, {"url": "https://github.com/dompdf/dompdf/commit/23a693993299e669306929e3d49a4a1f7b3fb028", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.portcullis-security.com/security-research-and-downloads/security-advisories/cve-2014-2383/", "source": "cve@mitre.org", "tags": ["Broken Link"]}]}, "github_commit_url": "https://github.com/dompdf/dompdf/commit/23a693993299e669306929e3d49a4a1f7b3fb028"}}