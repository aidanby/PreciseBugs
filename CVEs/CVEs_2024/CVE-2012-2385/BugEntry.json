{"buggy_code": ["/*\n    Mosh: the mobile shell\n    Copyright 2012 Keith Winstein\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n\n#include \"terminaldispatcher.h\"\n#include \"parseraction.h\"\n#include \"terminalframebuffer.h\"\n\nusing namespace Terminal;\n\nDispatcher::Dispatcher()\n  : params(), parsed_params(), parsed( false ), dispatch_chars(),\n    OSC_string(), terminal_to_host()\n{}\n\nvoid Dispatcher::newparamchar( const Parser::Param *act )\n{\n  assert( act->char_present );\n  assert( (act->ch == ';') || ( (act->ch >= '0') && (act->ch <= '9') ) );\n  if ( params.length() < 100 ) {\n    /* enough for 16 five-char params plus 15 semicolons */\n    params.push_back( act->ch );\n    act->handled = true;\n  }\n  parsed = false;\n}\n\nvoid Dispatcher::collect( const Parser::Collect *act )\n{\n  assert( act->char_present );\n  if ( ( dispatch_chars.length() < 8 ) /* never should need more than 2 */\n       && ( act->ch <= 255 ) ) {  /* ignore non-8-bit */    \n    dispatch_chars.push_back( act->ch );\n    act->handled = true;\n  }\n}\n\nvoid Dispatcher::clear( const Parser::Clear *act )\n{\n  params.clear();\n  dispatch_chars.clear();\n  parsed = false;\n  act->handled = true;\n}\n\nvoid Dispatcher::parse_params( void )\n{\n  if ( parsed ) {\n    return;\n  }\n\n  parsed_params.clear();\n  const char *str = params.c_str();\n  const char *segment_begin = str;\n\n  while ( 1 ) {\n    const char *segment_end = strchr( segment_begin, ';' );\n    if ( segment_end == NULL ) {\n      break;\n    }\n\n    errno = 0;\n    char *endptr;\n    int val = strtol( segment_begin, &endptr, 10 );\n    if ( endptr == segment_begin ) {\n      val = -1;\n    }\n    if ( errno == 0 || segment_begin == endptr ) {\n      parsed_params.push_back( val );\n    }\n\n    segment_begin = segment_end + 1;\n  }\n\n  /* get last param */\n  errno = 0;\n  char *endptr;\n  int val = strtol( segment_begin, &endptr, 10 );\n  if ( endptr == segment_begin ) {\n    val = -1;\n  }\n  if ( errno == 0 || segment_begin == endptr ) {\n    parsed_params.push_back( val );\n  }\n\n  parsed = true;\n}\n\nint Dispatcher::getparam( size_t N, int defaultval )\n{\n  int ret = defaultval;\n  if ( !parsed ) {\n    parse_params();\n  }\n\n  if ( parsed_params.size() > N ) {\n    ret = parsed_params[ N ];\n  }\n  if ( ret < 1 ) ret = defaultval;\n\n  return ret;\n}\n\nint Dispatcher::param_count( void )\n{\n  if ( !parsed ) {\n    parse_params();\n  }\n\n  return parsed_params.size();\n}\n\nstd::string Dispatcher::str( void )\n{\n  char assum[ 64 ];\n  snprintf( assum, 64, \"[dispatch=\\\"%s\\\" params=\\\"%s\\\"]\",\n\t    dispatch_chars.c_str(), params.c_str() );\n  return std::string( assum );\n}\n\n/* construct on first use to avoid static initialization order crash */\nDispatchRegistry & Terminal::get_global_dispatch_registry( void )\n{\n  static DispatchRegistry global_dispatch_registry;\n  return global_dispatch_registry;\n}\n\nstatic void register_function( Function_Type type,\n\t\t\t       std::string dispatch_chars,\n\t\t\t       Function f )\n{\n  switch ( type ) {\n  case ESCAPE:\n    get_global_dispatch_registry().escape.insert( dispatch_map_t::value_type( dispatch_chars, f ) );\n    break;\n  case CSI:\n    get_global_dispatch_registry().CSI.insert( dispatch_map_t::value_type( dispatch_chars, f ) );\n    break;\n  case CONTROL:\n    get_global_dispatch_registry().control.insert( dispatch_map_t::value_type( dispatch_chars, f ) );\n    break;\n  }\n}\n\nFunction::Function( Function_Type type, std::string dispatch_chars,\n\t\t    void (*s_function)( Framebuffer *, Dispatcher * ),\n\t\t    bool s_clears_wrap_state )\n  : function( s_function ), clears_wrap_state( s_clears_wrap_state )\n{\n  register_function( type, dispatch_chars, *this );\n}\n\nvoid Dispatcher::dispatch( Function_Type type, const Parser::Action *act, Framebuffer *fb )\n{\n  /* add final char to dispatch key */\n  if ( (type == ESCAPE) || (type == CSI) ) {\n    assert( act->char_present );\n    Parser::Collect act2;\n    act2.char_present = true;\n    act2.ch = act->ch;\n    collect( &act2 ); \n  }\n\n  dispatch_map_t *map = NULL;\n  switch ( type ) {\n  case ESCAPE:  map = &get_global_dispatch_registry().escape;  break;\n  case CSI:     map = &get_global_dispatch_registry().CSI;     break;\n  case CONTROL: map = &get_global_dispatch_registry().control; break;\n  }\n\n  std::string key = dispatch_chars;\n  if ( type == CONTROL ) {\n    assert( act->ch <= 255 );\n    char ctrlstr[ 2 ] = { (char)act->ch, 0 };\n    key = std::string( ctrlstr, 1 );\n  }\n\n  dispatch_map_t::const_iterator i = map->find( key );\n  if ( i == map->end() ) {\n    /* unknown function */\n    fb->ds.next_print_will_wrap = false;\n    return;\n  } else {\n    act->handled = true;\n    if ( i->second.clears_wrap_state ) {\n      fb->ds.next_print_will_wrap = false;\n    }\n    return i->second.function( fb, this );\n  }\n}\n\nvoid Dispatcher::OSC_put( const Parser::OSC_Put *act )\n{\n  assert( act->char_present );\n  if ( OSC_string.size() < 256 ) { /* should be a long enough window title */\n    OSC_string.push_back( act->ch );\n    act->handled = true;\n  }\n}\n\nvoid Dispatcher::OSC_start( const Parser::OSC_Start *act )\n{\n  OSC_string.clear();\n  act->handled = true;\n}\n\nbool Dispatcher::operator==( const Dispatcher &x ) const\n{\n  return ( params == x.params ) && ( parsed_params == x.parsed_params ) && ( parsed == x.parsed )\n    && ( dispatch_chars == x.dispatch_chars ) && ( OSC_string == x.OSC_string ) && ( terminal_to_host == x.terminal_to_host );\n}\n", "/*\n    Mosh: the mobile shell\n    Copyright 2012 Keith Winstein\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef TERMINALDISPATCHER_HPP\n#define TERMINALDISPATCHER_HPP\n\n#include <vector>\n#include <string>\n#include <map>\n\nnamespace Parser {\n  class Action;\n  class Param;\n  class Collect;\n  class Clear;\n  class Esc_Dispatch;\n  class CSI_Dispatch;\n  class Execute;\n  class OSC_Start;\n  class OSC_Put;\n  class OSC_End;\n}\n\nnamespace Terminal {\n  class Framebuffer;\n  class Dispatcher;\n\n  enum Function_Type { ESCAPE, CSI, CONTROL };\n\n  class Function {\n  public:\n    Function() : function( NULL ), clears_wrap_state( true ) {}\n    Function( Function_Type type, std::string dispatch_chars,\n\t      void (*s_function)( Framebuffer *, Dispatcher * ),\n\t      bool s_clears_wrap_state = true );\n    void (*function)( Framebuffer *, Dispatcher * );\n    bool clears_wrap_state;\n  };\n\n  typedef std::map<std::string, Function> dispatch_map_t;\n\n  class DispatchRegistry {\n  public:\n    dispatch_map_t escape;\n    dispatch_map_t CSI;\n    dispatch_map_t control;\n\n    DispatchRegistry() : escape(), CSI(), control() {}\n  };\n\n  DispatchRegistry & get_global_dispatch_registry( void );\n\n  class Dispatcher {\n  private:\n    std::string params;\n    std::vector<int> parsed_params;\n    bool parsed;\n\n    std::string dispatch_chars;\n    std::vector<wchar_t> OSC_string; /* only used to set the window title */\n\n    void parse_params( void );\n\n  public:\n    std::string terminal_to_host; /* this is the reply string */\n\n    Dispatcher();\n    int getparam( size_t N, int defaultval );\n    int param_count( void );\n\n    void newparamchar( const Parser::Param *act );\n    void collect( const Parser::Collect *act );\n    void clear( const Parser::Clear *act );\n    \n    std::string str( void );\n\n    void dispatch( Function_Type type, const Parser::Action *act, Framebuffer *fb );\n    std::string get_dispatch_chars( void ) { return dispatch_chars; }\n    std::vector<wchar_t> get_OSC_string( void ) { return OSC_string; }\n\n    void OSC_put( const Parser::OSC_Put *act );\n    void OSC_start( const Parser::OSC_Start *act );\n    void OSC_dispatch( const Parser::OSC_End *act, Framebuffer *fb );\n\n    bool operator==( const Dispatcher &x ) const;\n  };\n}\n\n#endif\n"], "fixing_code": ["/*\n    Mosh: the mobile shell\n    Copyright 2012 Keith Winstein\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n#include <errno.h>\n#include <stdlib.h>\n\n#include \"terminaldispatcher.h\"\n#include \"parseraction.h\"\n#include \"terminalframebuffer.h\"\n\nusing namespace Terminal;\n\nDispatcher::Dispatcher()\n  : params(), parsed_params(), parsed( false ), dispatch_chars(),\n    OSC_string(), terminal_to_host()\n{}\n\nvoid Dispatcher::newparamchar( const Parser::Param *act )\n{\n  assert( act->char_present );\n  assert( (act->ch == ';') || ( (act->ch >= '0') && (act->ch <= '9') ) );\n  if ( params.length() < 100 ) {\n    /* enough for 16 five-char params plus 15 semicolons */\n    params.push_back( act->ch );\n    act->handled = true;\n  }\n  parsed = false;\n}\n\nvoid Dispatcher::collect( const Parser::Collect *act )\n{\n  assert( act->char_present );\n  if ( ( dispatch_chars.length() < 8 ) /* never should need more than 2 */\n       && ( act->ch <= 255 ) ) {  /* ignore non-8-bit */    \n    dispatch_chars.push_back( act->ch );\n    act->handled = true;\n  }\n}\n\nvoid Dispatcher::clear( const Parser::Clear *act )\n{\n  params.clear();\n  dispatch_chars.clear();\n  parsed = false;\n  act->handled = true;\n}\n\nvoid Dispatcher::parse_params( void )\n{\n  if ( parsed ) {\n    return;\n  }\n\n  parsed_params.clear();\n  const char *str = params.c_str();\n  const char *segment_begin = str;\n\n  while ( 1 ) {\n    const char *segment_end = strchr( segment_begin, ';' );\n    if ( segment_end == NULL ) {\n      break;\n    }\n\n    errno = 0;\n    char *endptr;\n    int val = strtol( segment_begin, &endptr, 10 );\n    if ( endptr == segment_begin ) {\n      val = -1;\n    }\n    if ( errno == 0 || segment_begin == endptr ) {\n      parsed_params.push_back( val );\n    }\n\n    segment_begin = segment_end + 1;\n  }\n\n  /* get last param */\n  errno = 0;\n  char *endptr;\n  int val = strtol( segment_begin, &endptr, 10 );\n  if ( endptr == segment_begin ) {\n    val = -1;\n  }\n  if ( errno == 0 || segment_begin == endptr ) {\n    parsed_params.push_back( val );\n  }\n\n  parsed = true;\n}\n\nint Dispatcher::getparam( size_t N, int defaultval )\n{\n  int ret = defaultval;\n  if ( !parsed ) {\n    parse_params();\n  }\n\n  if ( parsed_params.size() > N ) {\n    ret = parsed_params[ N ];\n  }\n\n  if ( ret > PARAM_MAX ) {\n    ret = defaultval;\n  }\n\n  if ( ret < 1 ) ret = defaultval;\n\n  return ret;\n}\n\nint Dispatcher::param_count( void )\n{\n  if ( !parsed ) {\n    parse_params();\n  }\n\n  return parsed_params.size();\n}\n\nstd::string Dispatcher::str( void )\n{\n  char assum[ 64 ];\n  snprintf( assum, 64, \"[dispatch=\\\"%s\\\" params=\\\"%s\\\"]\",\n\t    dispatch_chars.c_str(), params.c_str() );\n  return std::string( assum );\n}\n\n/* construct on first use to avoid static initialization order crash */\nDispatchRegistry & Terminal::get_global_dispatch_registry( void )\n{\n  static DispatchRegistry global_dispatch_registry;\n  return global_dispatch_registry;\n}\n\nstatic void register_function( Function_Type type,\n\t\t\t       std::string dispatch_chars,\n\t\t\t       Function f )\n{\n  switch ( type ) {\n  case ESCAPE:\n    get_global_dispatch_registry().escape.insert( dispatch_map_t::value_type( dispatch_chars, f ) );\n    break;\n  case CSI:\n    get_global_dispatch_registry().CSI.insert( dispatch_map_t::value_type( dispatch_chars, f ) );\n    break;\n  case CONTROL:\n    get_global_dispatch_registry().control.insert( dispatch_map_t::value_type( dispatch_chars, f ) );\n    break;\n  }\n}\n\nFunction::Function( Function_Type type, std::string dispatch_chars,\n\t\t    void (*s_function)( Framebuffer *, Dispatcher * ),\n\t\t    bool s_clears_wrap_state )\n  : function( s_function ), clears_wrap_state( s_clears_wrap_state )\n{\n  register_function( type, dispatch_chars, *this );\n}\n\nvoid Dispatcher::dispatch( Function_Type type, const Parser::Action *act, Framebuffer *fb )\n{\n  /* add final char to dispatch key */\n  if ( (type == ESCAPE) || (type == CSI) ) {\n    assert( act->char_present );\n    Parser::Collect act2;\n    act2.char_present = true;\n    act2.ch = act->ch;\n    collect( &act2 ); \n  }\n\n  dispatch_map_t *map = NULL;\n  switch ( type ) {\n  case ESCAPE:  map = &get_global_dispatch_registry().escape;  break;\n  case CSI:     map = &get_global_dispatch_registry().CSI;     break;\n  case CONTROL: map = &get_global_dispatch_registry().control; break;\n  }\n\n  std::string key = dispatch_chars;\n  if ( type == CONTROL ) {\n    assert( act->ch <= 255 );\n    char ctrlstr[ 2 ] = { (char)act->ch, 0 };\n    key = std::string( ctrlstr, 1 );\n  }\n\n  dispatch_map_t::const_iterator i = map->find( key );\n  if ( i == map->end() ) {\n    /* unknown function */\n    fb->ds.next_print_will_wrap = false;\n    return;\n  } else {\n    act->handled = true;\n    if ( i->second.clears_wrap_state ) {\n      fb->ds.next_print_will_wrap = false;\n    }\n    return i->second.function( fb, this );\n  }\n}\n\nvoid Dispatcher::OSC_put( const Parser::OSC_Put *act )\n{\n  assert( act->char_present );\n  if ( OSC_string.size() < 256 ) { /* should be a long enough window title */\n    OSC_string.push_back( act->ch );\n    act->handled = true;\n  }\n}\n\nvoid Dispatcher::OSC_start( const Parser::OSC_Start *act )\n{\n  OSC_string.clear();\n  act->handled = true;\n}\n\nbool Dispatcher::operator==( const Dispatcher &x ) const\n{\n  return ( params == x.params ) && ( parsed_params == x.parsed_params ) && ( parsed == x.parsed )\n    && ( dispatch_chars == x.dispatch_chars ) && ( OSC_string == x.OSC_string ) && ( terminal_to_host == x.terminal_to_host );\n}\n", "/*\n    Mosh: the mobile shell\n    Copyright 2012 Keith Winstein\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef TERMINALDISPATCHER_HPP\n#define TERMINALDISPATCHER_HPP\n\n#include <vector>\n#include <string>\n#include <map>\n\nnamespace Parser {\n  class Action;\n  class Param;\n  class Collect;\n  class Clear;\n  class Esc_Dispatch;\n  class CSI_Dispatch;\n  class Execute;\n  class OSC_Start;\n  class OSC_Put;\n  class OSC_End;\n}\n\nnamespace Terminal {\n  class Framebuffer;\n  class Dispatcher;\n\n  enum Function_Type { ESCAPE, CSI, CONTROL };\n\n  class Function {\n  public:\n    Function() : function( NULL ), clears_wrap_state( true ) {}\n    Function( Function_Type type, std::string dispatch_chars,\n\t      void (*s_function)( Framebuffer *, Dispatcher * ),\n\t      bool s_clears_wrap_state = true );\n    void (*function)( Framebuffer *, Dispatcher * );\n    bool clears_wrap_state;\n  };\n\n  typedef std::map<std::string, Function> dispatch_map_t;\n\n  class DispatchRegistry {\n  public:\n    dispatch_map_t escape;\n    dispatch_map_t CSI;\n    dispatch_map_t control;\n\n    DispatchRegistry() : escape(), CSI(), control() {}\n  };\n\n  DispatchRegistry & get_global_dispatch_registry( void );\n\n  class Dispatcher {\n  private:\n    std::string params;\n    std::vector<int> parsed_params;\n    bool parsed;\n\n    std::string dispatch_chars;\n    std::vector<wchar_t> OSC_string; /* only used to set the window title */\n\n    void parse_params( void );\n\n  public:\n    static const int PARAM_MAX = 65535;\n    /* prevent evil escape sequences from causing long loops */\n\n    std::string terminal_to_host; /* this is the reply string */\n\n    Dispatcher();\n    int getparam( size_t N, int defaultval );\n    int param_count( void );\n\n    void newparamchar( const Parser::Param *act );\n    void collect( const Parser::Collect *act );\n    void clear( const Parser::Clear *act );\n    \n    std::string str( void );\n\n    void dispatch( Function_Type type, const Parser::Action *act, Framebuffer *fb );\n    std::string get_dispatch_chars( void ) { return dispatch_chars; }\n    std::vector<wchar_t> get_OSC_string( void ) { return OSC_string; }\n\n    void OSC_put( const Parser::OSC_Put *act );\n    void OSC_start( const Parser::OSC_Start *act );\n    void OSC_dispatch( const Parser::OSC_End *act, Framebuffer *fb );\n\n    bool operator==( const Dispatcher &x ) const;\n  };\n}\n\n#endif\n"], "filenames": ["src/terminal/terminaldispatcher.cc", "src/terminal/terminaldispatcher.h"], "buggy_code_start_loc": [118, 79], "buggy_code_end_loc": [118, 79], "fixing_code_start_loc": [119, 80], "fixing_code_end_loc": [124, 83], "type": "CWE-399", "message": "The terminal dispatcher in mosh before 1.2.1 allows remote authenticated users to cause a denial of service (long loop and CPU consumption) via an escape sequence with a large repeat count value.", "other": {"cve": {"id": "CVE-2012-2385", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-29T19:55:03.673", "lastModified": "2017-08-29T01:31:36.117", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The terminal dispatcher in mosh before 1.2.1 allows remote authenticated users to cause a denial of service (long loop and CPU consumption) via an escape sequence with a large repeat count value."}, {"lang": "es", "value": "El gestor de terminales (\"terminal dispatcher\") de mosh anteriores a 1.2.1 permite a usuarios autenticados remotos provocar una denegaci\u00f3n de servicio (bucle extenso y consumo de la CPU) a trav\u00e9s de una secuencia de escape con un valor repetido varias veces."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:keith_winstein:mosh:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.2-2", "matchCriteriaId": "749052CB-2810-4C63-9CD1-09126FD33BEF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:keith_winstein:mosh:0.98c:*:*:*:*:*:*:*", "matchCriteriaId": "6FE64BFE-579E-4F08-A510-5C505CDC6767"}, {"vulnerable": true, "criteria": "cpe:2.3:a:keith_winstein:mosh:1.0:*:*:*:*:*:*:*", "matchCriteriaId": "D64FC1A8-A19B-4594-85A1-36F177AB2C8C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:keith_winstein:mosh:1.1:*:*:*:*:*:*:*", "matchCriteriaId": "36E00175-618B-4C55-983D-9C407BCEF385"}, {"vulnerable": true, "criteria": "cpe:2.3:a:keith_winstein:mosh:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "F13CC59B-E80F-4C90-9570-D5A782322329"}, {"vulnerable": true, "criteria": "cpe:2.3:a:keith_winstein:mosh:1.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "01EE4E30-4186-4973-A24D-BE1B1FCB1F24"}, {"vulnerable": true, "criteria": "cpe:2.3:a:keith_winstein:mosh:1.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "0D686163-2060-4544-939E-9DBC99A42E08"}, {"vulnerable": true, "criteria": "cpe:2.3:a:keith_winstein:mosh:1.1.3-1:*:*:*:*:*:*:*", "matchCriteriaId": "5EFB1E1B-469B-4BF5-A87F-15F0856C06E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:keith_winstein:mosh:1.1.3-2:*:*:*:*:*:*:*", "matchCriteriaId": "1D8A2450-A42E-4553-9B25-EA560AD99A9A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:keith_winstein:mosh:1.2:*:*:*:*:*:*:*", "matchCriteriaId": "479FD965-8DE7-44CD-9112-9F00845B0CDF"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-June/082766.html", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-June/082814.html", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-June/082850.html", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2012/05/22/9", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/53646", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=823943", "source": "secalert@redhat.com"}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/75779", "source": "secalert@redhat.com"}, {"url": "https://github.com/keithw/mosh/blob/master/ChangeLog", "source": "secalert@redhat.com"}, {"url": "https://github.com/keithw/mosh/commit/9791768705528e911bfca6c4d8aa88139035060e", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://github.com/keithw/mosh/issues/271", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/keithw/mosh/commit/9791768705528e911bfca6c4d8aa88139035060e"}}