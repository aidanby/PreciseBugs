{"buggy_code": ["//\n// Copyright (C) 1993-1996 Id Software, Inc.\n// Copyright (C) 2016-2017 Alexey Khokholov (Nuke.YKT)\n// Copyright (C) 2017 Alexandre-Xavier Labont\ufffd-Lamoureux\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tMain loop menu stuff.\n//\tDefault Config File.\n//\tPCX Screenshots.\n//\n\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include <ctype.h>\n\n\n#include \"doomdef.h\"\n\n#include \"z_zone.h\"\n\n#include \"w_wad.h\"\n\n#include \"i_system.h\"\n#include \"v_video.h\"\n\n#include \"hu_stuff.h\"\n\n// State.\n#include \"doomstat.h\"\n\n// Data.\n#include \"dstrings.h\"\n\n#include \"m_misc.h\"\n\n\nint\t\tmyargc;\nchar**\t\tmyargv;\n\n//\n// M_DrawText\n// Returns the final X coordinate\n// HU_Init must have been called to init the font\n//\nextern patch_t*\t\thu_font[HU_FONTSIZE];\n\nint\nM_DrawText\n( int\t\tx,\n  int\t\ty,\n  boolean\tdirect,\n  char*\t\tstring )\n{\n    int \tc;\n    int\t\tw;\n\n    while (*string)\n    {\n\tc = toupper(*string) - HU_FONTSTART;\n\tstring++;\n\tif (c < 0 || c> HU_FONTSIZE)\n\t{\n\t    x += 4;\n\t    continue;\n\t}\n\t\t\n\tw = SHORT (hu_font[c]->width);\n\tif (x+w > SCREENWIDTH)\n\t    break;\n\tif (direct)\n\t    V_DrawPatchDirect(x, y, 0, hu_font[c]);\n\telse\n\t    V_DrawPatch(x, y, 0, hu_font[c]);\n\tx+=w;\n    }\n\n    return x;\n}\n\n//\n// M_CheckParm\n// Checks for the given parameter\n// in the program's command line arguments.\n// Returns the argument number (1 to argc-1)\n// or 0 if not present\nint M_CheckParm (char *check)\n{\n    int\t\ti;\n\n    for (i = 1;i<myargc;i++)\n    {\n\tif ( !strcasecmp(check, myargv[i]) )\n\t    return i;\n    }\n\n    return 0;\n}\n\n\n//\n// M_Random\n// Returns a 0-255 number\n//\nunsigned char rndtable[256] = {\n    0,   8, 109, 220, 222, 241, 149, 107,  75, 248, 254, 140,  16,  66 ,\n    74,  21, 211,  47,  80, 242, 154,  27, 205, 128, 161,  89,  77,  36 ,\n    95, 110,  85,  48, 212, 140, 211, 249,  22,  79, 200,  50,  28, 188 ,\n    52, 140, 202, 120,  68, 145,  62,  70, 184, 190,  91, 197, 152, 224 ,\n    149, 104,  25, 178, 252, 182, 202, 182, 141, 197,   4,  81, 181, 242 ,\n    145,  42,  39, 227, 156, 198, 225, 193, 219,  93, 122, 175, 249,   0 ,\n    175, 143,  70, 239,  46, 246, 163,  53, 163, 109, 168, 135,   2, 235 ,\n    25,  92,  20, 145, 138,  77,  69, 166,  78, 176, 173, 212, 166, 113 ,\n    94, 161,  41,  50, 239,  49, 111, 164,  70,  60,   2,  37, 171,  75 ,\n    136, 156,  11,  56,  42, 146, 138, 229,  73, 146,  77,  61,  98, 196 ,\n    135, 106,  63, 197, 195,  86,  96, 203, 113, 101, 170, 247, 181, 113 ,\n    80, 250, 108,   7, 255, 237, 129, 226,  79, 107, 112, 166, 103, 241 ,\n    24, 223, 239, 120, 198,  58,  60,  82, 128,   3, 184,  66, 143, 224 ,\n    145, 224,  81, 206, 163,  45,  63,  90, 168, 114,  59,  33, 159,  95 ,\n    28, 139, 123,  98, 125, 196,  15,  70, 194, 253,  54,  14, 109, 226 ,\n    71,  17, 161,  93, 186,  87, 244, 138,  20,  52, 123, 251,  26,  36 ,\n    17,  46,  52, 231, 232,  76,  31, 221,  84,  37, 216, 165, 212, 106 ,\n    197, 242,  98,  43,  39, 175, 254, 145, 190,  84, 118, 222, 187, 136 ,\n    120, 163, 236, 249\n};\n\nint\trndindex = 0;\nint\tprndindex = 0;\n\n// Which one is deterministic?\nint P_Random (void)\n{\n    prndindex = (prndindex+1)&0xff;\n    return rndtable[prndindex];\n}\n\nint M_Random (void)\n{\n    rndindex = (rndindex+1)&0xff;\n    return rndtable[rndindex];\n}\n\nvoid M_ClearRandom (void)\n{\n    rndindex = prndindex = 0;\n}\n\nvoid M_ClearBox (fixed_t *box)\n{\n    box[BOXTOP] = box[BOXRIGHT] = MININT;\n    box[BOXBOTTOM] = box[BOXLEFT] = MAXINT;\n}\n\nvoid\nM_AddToBox\n( fixed_t*\tbox,\n  fixed_t\tx,\n  fixed_t\ty )\n{\n    if (x<box[BOXLEFT])\n\tbox[BOXLEFT] = x;\n    else if (x>box[BOXRIGHT])\n\tbox[BOXRIGHT] = x;\n    if (y<box[BOXBOTTOM])\n\tbox[BOXBOTTOM] = y;\n    else if (y>box[BOXTOP])\n\tbox[BOXTOP] = y;\n}\n\n//\n// M_WriteFile\n//\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n\nboolean\nM_WriteFile\n( char const*\tname,\n  void*\t\tsource,\n  int\t\tlength )\n{\n    int\t\thandle;\n    int\t\tcount;\n\t\n    handle = open ( name, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666);\n\n    if (handle == -1)\n\treturn false;\n\n    count = write (handle, source, length);\n    close (handle);\n\t\n    if (count < length)\n\treturn false;\n\t\t\n    return true;\n}\n\n\n//\n// M_ReadFile\n//\nint\nM_ReadFile\n( char const*\tname,\n  byte**\tbuffer )\n{\n    int\thandle, count, length;\n    struct stat\tfileinfo;\n    byte\t\t*buf;\n\t\n    handle = open (name, O_RDONLY | O_BINARY, 0666);\n    if (handle == -1)\n\tI_Error (\"Couldn't read file %s\", name);\n    if (fstat (handle,&fileinfo) == -1)\n\tI_Error (\"Couldn't read file %s\", name);\n    length = fileinfo.st_size;\n    buf = Z_Malloc (length, PU_STATIC, NULL);\n    count = read (handle, buf, length);\n    close (handle);\n\t\n    if (count < length)\n\tI_Error (\"Couldn't read file %s\", name);\n\t\t\n    *buffer = buf;\n    return length;\n}\n\n\n//\n// DEFAULTS\n//\nint\t\tusemouse;\nint\t\tusejoystick;\n\nextern int\tkey_right;\nextern int\tkey_left;\nextern int\tkey_up;\nextern int\tkey_down;\n\nextern int\tkey_strafeleft;\nextern int\tkey_straferight;\n\nextern int\tkey_fire;\nextern int\tkey_use;\nextern int\tkey_strafe;\nextern int\tkey_speed;\n\nextern int\tmousebfire;\nextern int\tmousebstrafe;\nextern int\tmousebforward;\n\nextern int\tjoybfire;\nextern int\tjoybstrafe;\nextern int\tjoybuse;\nextern int\tjoybspeed;\n\nextern int\tviewwidth;\nextern int\tviewheight;\n\nextern int\tmouseSensitivity;\nextern int\tshowMessages;\n\nextern int\tdetailLevel;\n\nextern int\tscreenblocks;\n\nextern int\tshowMessages;\n\n// machine-independent sound params\nextern\tint\tnumChannels;\n\nextern int sfxVolume;\nextern int musicVolume;\nextern int snd_SBport, snd_SBirq, snd_SBdma;\nextern int snd_Mport;\n\nextern char*\tchat_macros[];\n\n\n\ntypedef struct\n{\n    char*\tname;\n    int*\tlocation;\n    int\t\tdefaultvalue;\n    int\t\tscantranslate;\t\t// PC scan code hack\n    int\t\tuntranslated;\t\t// lousy hack\n} default_t;\n\n#define SC_UPARROW              0x48\n#define SC_DOWNARROW            0x50\n#define SC_LEFTARROW            0x4b\n#define SC_RIGHTARROW           0x4d\n#define SC_RCTRL                0x1d\n#define SC_RALT                 0x38\n#define SC_RSHIFT               0x36\n#define SC_SPACE                0x39\n#define SC_COMMA                0x33\n#define SC_PERIOD               0x34\n#define SC_PAGEUP               0x49\n#define SC_INSERT               0x52\n#define SC_HOME                 0x47\n#define SC_PAGEDOWN             0x51\n#define SC_DELETE               0x53\n#define SC_END                  0x4f\n#define SC_ENTER                0x1c\n\n#define SC_KEY_A                0x1e\n#define SC_KEY_B                0x30\n#define SC_KEY_C                0x2e\n#define SC_KEY_D                0x20\n#define SC_KEY_E                0x12\n#define SC_KEY_F                0x21\n#define SC_KEY_G                0x22\n#define SC_KEY_H                0x23\n#define SC_KEY_I                0x17\n#define SC_KEY_J                0x24\n#define SC_KEY_K                0x25\n#define SC_KEY_L                0x26\n#define SC_KEY_M                0x32\n#define SC_KEY_N                0x31\n#define SC_KEY_O                0x18\n#define SC_KEY_P                0x19\n#define SC_KEY_Q                0x10\n#define SC_KEY_R                0x13\n#define SC_KEY_S                0x1f\n#define SC_KEY_T                0x14\n#define SC_KEY_U                0x16\n#define SC_KEY_V                0x2f\n#define SC_KEY_W                0x11\n#define SC_KEY_X                0x2d\n#define SC_KEY_Y                0x15\n#define SC_KEY_Z                0x2c\n#define SC_BACKSPACE            0x0e\n\ndefault_t\tdefaults[] =\n{\n    {\"mouse_sensitivity\",&mouseSensitivity, 5},\n    {\"sfx_volume\",&sfxVolume, 8},\n    {\"music_volume\",&musicVolume, 8},\n    {\"show_messages\",&showMessages, 1},\n    \n    {\"key_right\",&key_right, SC_RIGHTARROW, 1},\n    {\"key_left\",&key_left, SC_LEFTARROW, 1},\n    {\"key_up\",&key_up, SC_UPARROW, 1},\n    {\"key_down\",&key_down, SC_DOWNARROW, 1},\n    {\"key_strafeleft\",&key_strafeleft, SC_COMMA, 1},\n    {\"key_straferight\",&key_straferight, SC_PERIOD, 1},\n\n    {\"key_fire\",&key_fire, SC_RCTRL, 1},\n    {\"key_use\",&key_use, SC_SPACE, 1},\n    {\"key_strafe\",&key_strafe, SC_RALT, 1},\n    {\"key_speed\",&key_speed, SC_RSHIFT, 1},\n\n    {\"use_mouse\",&usemouse, 1},\n    {\"mouseb_fire\",&mousebfire,0},\n    {\"mouseb_strafe\",&mousebstrafe,1},\n    {\"mouseb_forward\",&mousebforward,2},\n\n    {\"use_joystick\",&usejoystick, 0},\n    {\"joyb_fire\",&joybfire,0},\n    {\"joyb_strafe\",&joybstrafe,1},\n    {\"joyb_use\",&joybuse,3},\n    {\"joyb_speed\",&joybspeed,2},\n\n    {\"screenblocks\",&screenblocks, 9},\n    {\"detaillevel\",&detailLevel, 0},\n\n    {\"snd_channels\",&numChannels, 3},\n    {\"snd_musicdevice\",&snd_DesiredMusicDevice, 0},\n    {\"snd_sfxdevice\",&snd_DesiredSfxDevice, 0},\n    {\"snd_sbport\",&snd_SBport, 0x220},\n    {\"snd_sbirq\",&snd_SBirq, 5},\n    {\"snd_sbdma\",&snd_SBdma, 1},\n    {\"snd_mport\",&snd_Mport, 0x330},\n\n    {\"usegamma\",&usegamma, 0},\n\n    {\"chatmacro0\", (int *) &chat_macros[0], (int) HUSTR_CHATMACRO0 },\n    {\"chatmacro1\", (int *) &chat_macros[1], (int) HUSTR_CHATMACRO1 },\n    {\"chatmacro2\", (int *) &chat_macros[2], (int) HUSTR_CHATMACRO2 },\n    {\"chatmacro3\", (int *) &chat_macros[3], (int) HUSTR_CHATMACRO3 },\n    {\"chatmacro4\", (int *) &chat_macros[4], (int) HUSTR_CHATMACRO4 },\n    {\"chatmacro5\", (int *) &chat_macros[5], (int) HUSTR_CHATMACRO5 },\n    {\"chatmacro6\", (int *) &chat_macros[6], (int) HUSTR_CHATMACRO6 },\n    {\"chatmacro7\", (int *) &chat_macros[7], (int) HUSTR_CHATMACRO7 },\n    {\"chatmacro8\", (int *) &chat_macros[8], (int) HUSTR_CHATMACRO8 },\n    {\"chatmacro9\", (int *) &chat_macros[9], (int) HUSTR_CHATMACRO9 }\n\n};\n\nint\tnumdefaults;\nchar*\tdefaultfile;\n\n\n//\n// M_SaveDefaults\n//\nvoid M_SaveDefaults (void)\n{\n    int\t\ti;\n    int\t\tv;\n    FILE*\tf;\n\t\n    f = fopen (defaultfile, \"w\");\n    if (!f)\n\treturn; // can't write the file, but don't complain\n\t\t\n    for (i=0 ; i<numdefaults ; i++)\n    {\n        if (defaults[i].scantranslate)\n            defaults[i].location = &defaults[i].untranslated;\n\n\tif (defaults[i].defaultvalue > -0xfff\n\t    && defaults[i].defaultvalue < 0xfff)\n\t{\n\t    v = *defaults[i].location;\n\t    fprintf (f,\"%s\\t\\t%i\\n\",defaults[i].name,v);\n\t} else {\n\t    fprintf (f,\"%s\\t\\t\\\"%s\\\"\\n\",defaults[i].name,\n\t\t     * (char **) (defaults[i].location));\n\t}\n    }\n\t\n    fclose (f);\n}\n\n\n//\n// M_LoadDefaults\n//\nextern byte\tscantokey[128];\n\nvoid M_LoadDefaults (void)\n{\n    int\t\ti;\n    int\t\tlen;\n    FILE*\tf;\n    char\tdef[80];\n    char\tstrparm[100];\n    char*\tnewstring;\n    int\t\tparm;\n    boolean\tisstring;\n    \n    // set everything to base values\n    numdefaults = sizeof(defaults)/sizeof(defaults[0]);\n    for (i=0 ; i<numdefaults ; i++)\n\t*defaults[i].location = defaults[i].defaultvalue;\n    \n    // check for a custom default file\n    i = M_CheckParm (\"-config\");\n    if (i && i<myargc-1)\n    {\n\tdefaultfile = myargv[i+1];\n\tprintf (\"\tdefault file: %s\\n\",defaultfile);\n    }\n    else\n\tdefaultfile = basedefault;\n    \n    // read the file in, overriding any set defaults\n    f = fopen (defaultfile, \"r\");\n    if (f)\n    {\n\twhile (!feof(f))\n\t{\n\t    isstring = false;\n\t    if (fscanf (f, \"%79s %[^\\n]\\n\", def, strparm) == 2)\n\t    {\n\t\tif (strparm[0] == '\"')\n\t\t{\n\t\t    // get a string default\n\t\t    isstring = true;\n\t\t    len = strlen(strparm);\n\t\t    newstring = (char *) malloc(len);\n\t\t    strparm[len-1] = 0;\n\t\t    strcpy(newstring, strparm+1);\n\t\t}\n\t\telse if (strparm[0] == '0' && strparm[1] == 'x')\n\t\t    sscanf(strparm+2, \"%x\", &parm);\n\t\telse\n\t\t    sscanf(strparm, \"%i\", &parm);\n\t\tfor (i=0 ; i<numdefaults ; i++)\n\t\t    if (!strcmp(def, defaults[i].name))\n\t\t    {\n\t\t\tif (!isstring)\n\t\t\t    *defaults[i].location = parm;\n\t\t\telse\n\t\t\t    *defaults[i].location =\n\t\t\t\t(int) newstring;\n\t\t\tbreak;\n\t\t    }\n\t    }\n\t}\n\t\t\n\tfclose (f);\n    }\n\n    for (i = 0; i < numdefaults; i++)\n    {\n        if (defaults[i].scantranslate)\n        {\n            parm = *defaults[i].location;\n            defaults[i].untranslated = parm;\n            *defaults[i].location = scantokey[parm];\n        }\n    }\n}\n\n\n//\n// SCREEN SHOTS\n//\n\n\ntypedef struct\n{\n    char\t\tmanufacturer;\n    char\t\tversion;\n    char\t\tencoding;\n    char\t\tbits_per_pixel;\n\n    unsigned short\txmin;\n    unsigned short\tymin;\n    unsigned short\txmax;\n    unsigned short\tymax;\n    \n    unsigned short\thres;\n    unsigned short\tvres;\n\n    unsigned char\tpalette[48];\n    \n    char\t\treserved;\n    char\t\tcolor_planes;\n    unsigned short\tbytes_per_line;\n    unsigned short\tpalette_type;\n    \n    char\t\tfiller[58];\n    unsigned char\tdata;\t\t// unbounded\n} pcx_t;\n\n\n//\n// WritePCXfile\n//\nvoid\nWritePCXfile\n( char*\t\tfilename,\n  byte*\t\tdata,\n  int\t\twidth,\n  int\t\theight,\n  byte*\t\tpalette )\n{\n    int\t\ti;\n    int\t\tlength;\n    pcx_t*\tpcx;\n    byte*\tpack;\n\t\n    pcx = Z_Malloc (width*height*2+1000, PU_STATIC, NULL);\n\n    pcx->manufacturer = 0x0a;\t\t// PCX id\n    pcx->version = 5;\t\t\t// 256 color\n    pcx->encoding = 1;\t\t\t// uncompressed\n    pcx->bits_per_pixel = 8;\t\t// 256 color\n    pcx->xmin = 0;\n    pcx->ymin = 0;\n    pcx->xmax = SHORT(width-1);\n    pcx->ymax = SHORT(height-1);\n    pcx->hres = SHORT(width);\n    pcx->vres = SHORT(height);\n    memset (pcx->palette,0,sizeof(pcx->palette));\n    pcx->color_planes = 1;\t\t// chunky image\n    pcx->bytes_per_line = SHORT(width);\n    pcx->palette_type = SHORT(2);\t// not a grey scale\n    memset (pcx->filler,0,sizeof(pcx->filler));\n\n\n    // pack the image\n    pack = &pcx->data;\n\t\n    for (i=0 ; i<width*height ; i++)\n    {\n\tif ( (*data & 0xc0) != 0xc0)\n\t    *pack++ = *data++;\n\telse\n\t{\n\t    *pack++ = 0xc1;\n\t    *pack++ = *data++;\n\t}\n    }\n    \n    // write the palette\n    *pack++ = 0x0c;\t// palette ID byte\n    for (i=0 ; i<768 ; i++)\n\t*pack++ = *palette++;\n    \n    // write output file\n    length = pack - (byte *)pcx;\n    M_WriteFile (filename, pcx, length);\n\n    Z_Free (pcx);\n}\n\n\n//\n// M_ScreenShot\n//\nvoid M_ScreenShot (void)\n{\n    int\t\ti;\n    byte*\tlinear;\n    char\tlbmname[12];\n    \n    // munge planar buffer to linear\n    linear = screens[2];\n    I_ReadScreen (linear);\n    \n    // find a file name to save it to\n    strcpy(lbmname,\"DOOM00.pcx\");\n\t\t\n    for (i=0 ; i<=99 ; i++)\n    {\n\tlbmname[4] = i/10 + '0';\n\tlbmname[5] = i%10 + '0';\n\tif (access(lbmname,0) == -1)\n\t    break;\t// file doesn't exist\n    }\n    if (i==100)\n\tI_Error (\"M_ScreenShot: Couldn't create a PCX\");\n    \n    // save the pcx file\n    WritePCXfile (lbmname, linear,\n\t\t  SCREENWIDTH, SCREENHEIGHT,\n\t\t  W_CacheLumpName (\"PLAYPAL\",PU_CACHE));\n\t\n    players[consoleplayer].message = \"screen shot\";\n}\n\n\n"], "fixing_code": ["//\n// Copyright (C) 1993-1996 Id Software, Inc.\n// Copyright (C) 2016-2017 Alexey Khokholov (Nuke.YKT)\n// Copyright (C) 2017 Alexandre-Xavier Labont\ufffd-Lamoureux\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tMain loop menu stuff.\n//\tDefault Config File.\n//\tPCX Screenshots.\n//\n\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include <ctype.h>\n\n\n#include \"doomdef.h\"\n\n#include \"z_zone.h\"\n\n#include \"w_wad.h\"\n\n#include \"i_system.h\"\n#include \"v_video.h\"\n\n#include \"hu_stuff.h\"\n\n// State.\n#include \"doomstat.h\"\n\n// Data.\n#include \"dstrings.h\"\n\n#include \"m_misc.h\"\n\n\nint\t\tmyargc;\nchar**\t\tmyargv;\n\n//\n// M_DrawText\n// Returns the final X coordinate\n// HU_Init must have been called to init the font\n//\nextern patch_t*\t\thu_font[HU_FONTSIZE];\n\nint\nM_DrawText\n( int\t\tx,\n  int\t\ty,\n  boolean\tdirect,\n  char*\t\tstring )\n{\n    int \tc;\n    int\t\tw;\n\n    while (*string)\n    {\n\tc = toupper(*string) - HU_FONTSTART;\n\tstring++;\n\tif (c < 0 || c> HU_FONTSIZE)\n\t{\n\t    x += 4;\n\t    continue;\n\t}\n\t\t\n\tw = SHORT (hu_font[c]->width);\n\tif (x+w > SCREENWIDTH)\n\t    break;\n\tif (direct)\n\t    V_DrawPatchDirect(x, y, 0, hu_font[c]);\n\telse\n\t    V_DrawPatch(x, y, 0, hu_font[c]);\n\tx+=w;\n    }\n\n    return x;\n}\n\n//\n// M_CheckParm\n// Checks for the given parameter\n// in the program's command line arguments.\n// Returns the argument number (1 to argc-1)\n// or 0 if not present\nint M_CheckParm (char *check)\n{\n    int\t\ti;\n\n    for (i = 1;i<myargc;i++)\n    {\n\tif ( !strcasecmp(check, myargv[i]) )\n\t    return i;\n    }\n\n    return 0;\n}\n\n\n//\n// M_Random\n// Returns a 0-255 number\n//\nunsigned char rndtable[256] = {\n    0,   8, 109, 220, 222, 241, 149, 107,  75, 248, 254, 140,  16,  66 ,\n    74,  21, 211,  47,  80, 242, 154,  27, 205, 128, 161,  89,  77,  36 ,\n    95, 110,  85,  48, 212, 140, 211, 249,  22,  79, 200,  50,  28, 188 ,\n    52, 140, 202, 120,  68, 145,  62,  70, 184, 190,  91, 197, 152, 224 ,\n    149, 104,  25, 178, 252, 182, 202, 182, 141, 197,   4,  81, 181, 242 ,\n    145,  42,  39, 227, 156, 198, 225, 193, 219,  93, 122, 175, 249,   0 ,\n    175, 143,  70, 239,  46, 246, 163,  53, 163, 109, 168, 135,   2, 235 ,\n    25,  92,  20, 145, 138,  77,  69, 166,  78, 176, 173, 212, 166, 113 ,\n    94, 161,  41,  50, 239,  49, 111, 164,  70,  60,   2,  37, 171,  75 ,\n    136, 156,  11,  56,  42, 146, 138, 229,  73, 146,  77,  61,  98, 196 ,\n    135, 106,  63, 197, 195,  86,  96, 203, 113, 101, 170, 247, 181, 113 ,\n    80, 250, 108,   7, 255, 237, 129, 226,  79, 107, 112, 166, 103, 241 ,\n    24, 223, 239, 120, 198,  58,  60,  82, 128,   3, 184,  66, 143, 224 ,\n    145, 224,  81, 206, 163,  45,  63,  90, 168, 114,  59,  33, 159,  95 ,\n    28, 139, 123,  98, 125, 196,  15,  70, 194, 253,  54,  14, 109, 226 ,\n    71,  17, 161,  93, 186,  87, 244, 138,  20,  52, 123, 251,  26,  36 ,\n    17,  46,  52, 231, 232,  76,  31, 221,  84,  37, 216, 165, 212, 106 ,\n    197, 242,  98,  43,  39, 175, 254, 145, 190,  84, 118, 222, 187, 136 ,\n    120, 163, 236, 249\n};\n\nint\trndindex = 0;\nint\tprndindex = 0;\n\n// Which one is deterministic?\nint P_Random (void)\n{\n    prndindex = (prndindex+1)&0xff;\n    return rndtable[prndindex];\n}\n\nint M_Random (void)\n{\n    rndindex = (rndindex+1)&0xff;\n    return rndtable[rndindex];\n}\n\nvoid M_ClearRandom (void)\n{\n    rndindex = prndindex = 0;\n}\n\nvoid M_ClearBox (fixed_t *box)\n{\n    box[BOXTOP] = box[BOXRIGHT] = MININT;\n    box[BOXBOTTOM] = box[BOXLEFT] = MAXINT;\n}\n\nvoid\nM_AddToBox\n( fixed_t*\tbox,\n  fixed_t\tx,\n  fixed_t\ty )\n{\n    if (x<box[BOXLEFT])\n\tbox[BOXLEFT] = x;\n    else if (x>box[BOXRIGHT])\n\tbox[BOXRIGHT] = x;\n    if (y<box[BOXBOTTOM])\n\tbox[BOXBOTTOM] = y;\n    else if (y>box[BOXTOP])\n\tbox[BOXTOP] = y;\n}\n\n//\n// M_WriteFile\n//\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n\nboolean\nM_WriteFile\n( char const*\tname,\n  void*\t\tsource,\n  int\t\tlength )\n{\n    int\t\thandle;\n    int\t\tcount;\n\t\n    handle = open ( name, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666);\n\n    if (handle == -1)\n\treturn false;\n\n    count = write (handle, source, length);\n    close (handle);\n\t\n    if (count < length)\n\treturn false;\n\t\t\n    return true;\n}\n\n\n//\n// M_ReadFile\n//\nint\nM_ReadFile\n( char const*\tname,\n  byte**\tbuffer )\n{\n    int\thandle, count, length;\n    struct stat\tfileinfo;\n    byte\t\t*buf;\n\t\n    handle = open (name, O_RDONLY | O_BINARY, 0666);\n    if (handle == -1)\n\tI_Error (\"Couldn't read file %s\", name);\n    if (fstat (handle,&fileinfo) == -1)\n\tI_Error (\"Couldn't read file %s\", name);\n    length = fileinfo.st_size;\n    buf = Z_Malloc (length, PU_STATIC, NULL);\n    count = read (handle, buf, length);\n    close (handle);\n\t\n    if (count < length)\n\tI_Error (\"Couldn't read file %s\", name);\n\t\t\n    *buffer = buf;\n    return length;\n}\n\n\n//\n// DEFAULTS\n//\nint\t\tusemouse;\nint\t\tusejoystick;\n\nextern int\tkey_right;\nextern int\tkey_left;\nextern int\tkey_up;\nextern int\tkey_down;\n\nextern int\tkey_strafeleft;\nextern int\tkey_straferight;\n\nextern int\tkey_fire;\nextern int\tkey_use;\nextern int\tkey_strafe;\nextern int\tkey_speed;\n\nextern int\tmousebfire;\nextern int\tmousebstrafe;\nextern int\tmousebforward;\n\nextern int\tjoybfire;\nextern int\tjoybstrafe;\nextern int\tjoybuse;\nextern int\tjoybspeed;\n\nextern int\tviewwidth;\nextern int\tviewheight;\n\nextern int\tmouseSensitivity;\nextern int\tshowMessages;\n\nextern int\tdetailLevel;\n\nextern int\tscreenblocks;\n\nextern int\tshowMessages;\n\n// machine-independent sound params\nextern\tint\tnumChannels;\n\nextern int sfxVolume;\nextern int musicVolume;\nextern int snd_SBport, snd_SBirq, snd_SBdma;\nextern int snd_Mport;\n\nextern char*\tchat_macros[];\n\n\n\ntypedef struct\n{\n    char*\tname;\n    int*\tlocation;\n    int\t\tdefaultvalue;\n    int\t\tscantranslate;\t\t// PC scan code hack\n    int\t\tuntranslated;\t\t// lousy hack\n} default_t;\n\n#define SC_UPARROW              0x48\n#define SC_DOWNARROW            0x50\n#define SC_LEFTARROW            0x4b\n#define SC_RIGHTARROW           0x4d\n#define SC_RCTRL                0x1d\n#define SC_RALT                 0x38\n#define SC_RSHIFT               0x36\n#define SC_SPACE                0x39\n#define SC_COMMA                0x33\n#define SC_PERIOD               0x34\n#define SC_PAGEUP               0x49\n#define SC_INSERT               0x52\n#define SC_HOME                 0x47\n#define SC_PAGEDOWN             0x51\n#define SC_DELETE               0x53\n#define SC_END                  0x4f\n#define SC_ENTER                0x1c\n\n#define SC_KEY_A                0x1e\n#define SC_KEY_B                0x30\n#define SC_KEY_C                0x2e\n#define SC_KEY_D                0x20\n#define SC_KEY_E                0x12\n#define SC_KEY_F                0x21\n#define SC_KEY_G                0x22\n#define SC_KEY_H                0x23\n#define SC_KEY_I                0x17\n#define SC_KEY_J                0x24\n#define SC_KEY_K                0x25\n#define SC_KEY_L                0x26\n#define SC_KEY_M                0x32\n#define SC_KEY_N                0x31\n#define SC_KEY_O                0x18\n#define SC_KEY_P                0x19\n#define SC_KEY_Q                0x10\n#define SC_KEY_R                0x13\n#define SC_KEY_S                0x1f\n#define SC_KEY_T                0x14\n#define SC_KEY_U                0x16\n#define SC_KEY_V                0x2f\n#define SC_KEY_W                0x11\n#define SC_KEY_X                0x2d\n#define SC_KEY_Y                0x15\n#define SC_KEY_Z                0x2c\n#define SC_BACKSPACE            0x0e\n\ndefault_t\tdefaults[] =\n{\n    {\"mouse_sensitivity\",&mouseSensitivity, 5},\n    {\"sfx_volume\",&sfxVolume, 8},\n    {\"music_volume\",&musicVolume, 8},\n    {\"show_messages\",&showMessages, 1},\n    \n    {\"key_right\",&key_right, SC_RIGHTARROW, 1},\n    {\"key_left\",&key_left, SC_LEFTARROW, 1},\n    {\"key_up\",&key_up, SC_UPARROW, 1},\n    {\"key_down\",&key_down, SC_DOWNARROW, 1},\n    {\"key_strafeleft\",&key_strafeleft, SC_COMMA, 1},\n    {\"key_straferight\",&key_straferight, SC_PERIOD, 1},\n\n    {\"key_fire\",&key_fire, SC_RCTRL, 1},\n    {\"key_use\",&key_use, SC_SPACE, 1},\n    {\"key_strafe\",&key_strafe, SC_RALT, 1},\n    {\"key_speed\",&key_speed, SC_RSHIFT, 1},\n\n    {\"use_mouse\",&usemouse, 1},\n    {\"mouseb_fire\",&mousebfire,0},\n    {\"mouseb_strafe\",&mousebstrafe,1},\n    {\"mouseb_forward\",&mousebforward,2},\n\n    {\"use_joystick\",&usejoystick, 0},\n    {\"joyb_fire\",&joybfire,0},\n    {\"joyb_strafe\",&joybstrafe,1},\n    {\"joyb_use\",&joybuse,3},\n    {\"joyb_speed\",&joybspeed,2},\n\n    {\"screenblocks\",&screenblocks, 9},\n    {\"detaillevel\",&detailLevel, 0},\n\n    {\"snd_channels\",&numChannels, 3},\n    {\"snd_musicdevice\",&snd_DesiredMusicDevice, 0},\n    {\"snd_sfxdevice\",&snd_DesiredSfxDevice, 0},\n    {\"snd_sbport\",&snd_SBport, 0x220},\n    {\"snd_sbirq\",&snd_SBirq, 5},\n    {\"snd_sbdma\",&snd_SBdma, 1},\n    {\"snd_mport\",&snd_Mport, 0x330},\n\n    {\"usegamma\",&usegamma, 0},\n\n    {\"chatmacro0\", (int *) &chat_macros[0], (int) HUSTR_CHATMACRO0 },\n    {\"chatmacro1\", (int *) &chat_macros[1], (int) HUSTR_CHATMACRO1 },\n    {\"chatmacro2\", (int *) &chat_macros[2], (int) HUSTR_CHATMACRO2 },\n    {\"chatmacro3\", (int *) &chat_macros[3], (int) HUSTR_CHATMACRO3 },\n    {\"chatmacro4\", (int *) &chat_macros[4], (int) HUSTR_CHATMACRO4 },\n    {\"chatmacro5\", (int *) &chat_macros[5], (int) HUSTR_CHATMACRO5 },\n    {\"chatmacro6\", (int *) &chat_macros[6], (int) HUSTR_CHATMACRO6 },\n    {\"chatmacro7\", (int *) &chat_macros[7], (int) HUSTR_CHATMACRO7 },\n    {\"chatmacro8\", (int *) &chat_macros[8], (int) HUSTR_CHATMACRO8 },\n    {\"chatmacro9\", (int *) &chat_macros[9], (int) HUSTR_CHATMACRO9 }\n\n};\n\nint\tnumdefaults;\nchar*\tdefaultfile;\n\n\n//\n// M_SaveDefaults\n//\nvoid M_SaveDefaults (void)\n{\n    int\t\ti;\n    int\t\tv;\n    FILE*\tf;\n\t\n    f = fopen (defaultfile, \"w\");\n    if (!f)\n\treturn; // can't write the file, but don't complain\n\t\t\n    for (i=0 ; i<numdefaults ; i++)\n    {\n        if (defaults[i].scantranslate)\n            defaults[i].location = &defaults[i].untranslated;\n\n\tif (defaults[i].defaultvalue > -0xfff\n\t    && defaults[i].defaultvalue < 0xfff)\n\t{\n\t    v = *defaults[i].location;\n\t    fprintf (f,\"%s\\t\\t%i\\n\",defaults[i].name,v);\n\t} else {\n\t    fprintf (f,\"%s\\t\\t\\\"%s\\\"\\n\",defaults[i].name,\n\t\t     * (char **) (defaults[i].location));\n\t}\n    }\n\t\n    fclose (f);\n}\n\n\n//\n// M_LoadDefaults\n//\nextern byte\tscantokey[128];\n\nvoid M_LoadDefaults (void)\n{\n    int\t\ti;\n    int\t\tlen;\n    FILE*\tf;\n    char\tdef[80];\n    char\tstrparm[100];\n    char*\tnewstring;\n    int\t\tparm;\n    boolean\tisstring;\n    \n    // set everything to base values\n    numdefaults = sizeof(defaults)/sizeof(defaults[0]);\n    for (i=0 ; i<numdefaults ; i++)\n\t*defaults[i].location = defaults[i].defaultvalue;\n    \n    // check for a custom default file\n    i = M_CheckParm (\"-config\");\n    if (i && i<myargc-1)\n    {\n\tdefaultfile = myargv[i+1];\n\tprintf (\"\tdefault file: %s\\n\",defaultfile);\n    }\n    else\n\tdefaultfile = basedefault;\n    \n    // read the file in, overriding any set defaults\n    f = fopen (defaultfile, \"r\");\n    if (f)\n    {\n\twhile (!feof(f))\n\t{\n\t    isstring = false;\n\t    if (fscanf (f, \"%79s %99[^\\n]\\n\", def, strparm) == 2)\n\t    {\n\t\tif (strparm[0] == '\"')\n\t\t{\n\t\t    // get a string default\n\t\t    isstring = true;\n\t\t    len = strlen(strparm);\n\t\t    newstring = (char *) malloc(len);\n\t\t    strparm[len-1] = 0;\n\t\t    strcpy(newstring, strparm+1);\n\t\t}\n\t\telse if (strparm[0] == '0' && strparm[1] == 'x')\n\t\t    sscanf(strparm+2, \"%x\", &parm);\n\t\telse\n\t\t    sscanf(strparm, \"%i\", &parm);\n\t\tfor (i=0 ; i<numdefaults ; i++)\n\t\t    if (!strcmp(def, defaults[i].name))\n\t\t    {\n\t\t\tif (!isstring)\n\t\t\t    *defaults[i].location = parm;\n\t\t\telse\n\t\t\t    *defaults[i].location =\n\t\t\t\t(int) newstring;\n\t\t\tbreak;\n\t\t    }\n\t    }\n\t}\n\t\t\n\tfclose (f);\n    }\n\n    for (i = 0; i < numdefaults; i++)\n    {\n        if (defaults[i].scantranslate)\n        {\n            parm = *defaults[i].location;\n            defaults[i].untranslated = parm;\n            *defaults[i].location = scantokey[parm];\n        }\n    }\n}\n\n\n//\n// SCREEN SHOTS\n//\n\n\ntypedef struct\n{\n    char\t\tmanufacturer;\n    char\t\tversion;\n    char\t\tencoding;\n    char\t\tbits_per_pixel;\n\n    unsigned short\txmin;\n    unsigned short\tymin;\n    unsigned short\txmax;\n    unsigned short\tymax;\n    \n    unsigned short\thres;\n    unsigned short\tvres;\n\n    unsigned char\tpalette[48];\n    \n    char\t\treserved;\n    char\t\tcolor_planes;\n    unsigned short\tbytes_per_line;\n    unsigned short\tpalette_type;\n    \n    char\t\tfiller[58];\n    unsigned char\tdata;\t\t// unbounded\n} pcx_t;\n\n\n//\n// WritePCXfile\n//\nvoid\nWritePCXfile\n( char*\t\tfilename,\n  byte*\t\tdata,\n  int\t\twidth,\n  int\t\theight,\n  byte*\t\tpalette )\n{\n    int\t\ti;\n    int\t\tlength;\n    pcx_t*\tpcx;\n    byte*\tpack;\n\t\n    pcx = Z_Malloc (width*height*2+1000, PU_STATIC, NULL);\n\n    pcx->manufacturer = 0x0a;\t\t// PCX id\n    pcx->version = 5;\t\t\t// 256 color\n    pcx->encoding = 1;\t\t\t// uncompressed\n    pcx->bits_per_pixel = 8;\t\t// 256 color\n    pcx->xmin = 0;\n    pcx->ymin = 0;\n    pcx->xmax = SHORT(width-1);\n    pcx->ymax = SHORT(height-1);\n    pcx->hres = SHORT(width);\n    pcx->vres = SHORT(height);\n    memset (pcx->palette,0,sizeof(pcx->palette));\n    pcx->color_planes = 1;\t\t// chunky image\n    pcx->bytes_per_line = SHORT(width);\n    pcx->palette_type = SHORT(2);\t// not a grey scale\n    memset (pcx->filler,0,sizeof(pcx->filler));\n\n\n    // pack the image\n    pack = &pcx->data;\n\t\n    for (i=0 ; i<width*height ; i++)\n    {\n\tif ( (*data & 0xc0) != 0xc0)\n\t    *pack++ = *data++;\n\telse\n\t{\n\t    *pack++ = 0xc1;\n\t    *pack++ = *data++;\n\t}\n    }\n    \n    // write the palette\n    *pack++ = 0x0c;\t// palette ID byte\n    for (i=0 ; i<768 ; i++)\n\t*pack++ = *palette++;\n    \n    // write output file\n    length = pack - (byte *)pcx;\n    M_WriteFile (filename, pcx, length);\n\n    Z_Free (pcx);\n}\n\n\n//\n// M_ScreenShot\n//\nvoid M_ScreenShot (void)\n{\n    int\t\ti;\n    byte*\tlinear;\n    char\tlbmname[12];\n    \n    // munge planar buffer to linear\n    linear = screens[2];\n    I_ReadScreen (linear);\n    \n    // find a file name to save it to\n    strcpy(lbmname,\"DOOM00.pcx\");\n\t\t\n    for (i=0 ; i<=99 ; i++)\n    {\n\tlbmname[4] = i/10 + '0';\n\tlbmname[5] = i%10 + '0';\n\tif (access(lbmname,0) == -1)\n\t    break;\t// file doesn't exist\n    }\n    if (i==100)\n\tI_Error (\"M_ScreenShot: Couldn't create a PCX\");\n    \n    // save the pcx file\n    WritePCXfile (lbmname, linear,\n\t\t  SCREENWIDTH, SCREENHEIGHT,\n\t\t  W_CacheLumpName (\"PLAYPAL\",PU_CACHE));\n\t\n    players[consoleplayer].message = \"screen shot\";\n}\n\n\n"], "filenames": ["m_misc.c"], "buggy_code_start_loc": [482], "buggy_code_end_loc": [483], "fixing_code_start_loc": [482], "fixing_code_end_loc": [483], "type": "CWE-120", "message": "A buffer overflow in the M_LoadDefaults function in m_misc.c in id Tech 1 (aka Doom engine) allows arbitrary code execution via an unsafe usage of fscanf, because it does not limit the number of characters to be read in a format argument.", "other": {"cve": {"id": "CVE-2020-15007", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-24T11:15:12.090", "lastModified": "2020-07-08T14:33:01.137", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A buffer overflow in the M_LoadDefaults function in m_misc.c in id Tech 1 (aka Doom engine) allows arbitrary code execution via an unsafe usage of fscanf, because it does not limit the number of characters to be read in a format argument."}, {"lang": "es", "value": "Un desbordamiento del b\u00fafer en la funci\u00f3n M_LoadDefaults en el archivo m_misc.c en id Tech versi\u00f3n 1 (tambi\u00e9n se conoce como motor Doom), permite una ejecuci\u00f3n de c\u00f3digo arbitrario por medio de un uso no seguro de fscanf, porque no limita el n\u00famero de caracteres para ser le\u00eddo en un argumento de formato"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:idsoftware:tech_1:-:*:*:*:*:*:*:*", "matchCriteriaId": "10E62151-61CA-4011-8537-F5EB5F9381A1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:doom_vanille_project:doom_vanille:*:*:*:*:*:*:*:*", "versionEndExcluding": "671", "matchCriteriaId": "FDA88BB8-8E08-4022-A080-2EBEB0C5EA90"}]}]}], "references": [{"url": "https://github.com/AXDOOMER/doom-vanille/commit/8a6d9a02fa991a91ff90ccdc73b5ceabaa6cb9ec", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://twitter.com/notrevenant/status/1268654123903340544", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/AXDOOMER/doom-vanille/commit/8a6d9a02fa991a91ff90ccdc73b5ceabaa6cb9ec"}}