{"buggy_code": ["# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nForms used for Horizon's auth mechanisms.\n\"\"\"\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\nfrom keystoneclient import exceptions as keystone_exceptions\n\nfrom horizon import api\nfrom horizon import base\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef _set_session_data(request, token):\n    request.session['serviceCatalog'] = token.serviceCatalog\n    request.session['tenant'] = token.tenant['name']\n    request.session['tenant_id'] = token.tenant['id']\n    request.session['token'] = token.id\n    request.session['user_name'] = token.user['name']\n    request.session['user_id'] = token.user['id']\n    request.session['roles'] = token.user['roles']\n\n\nclass Login(forms.SelfHandlingForm):\n    \"\"\" Form used for logging in a user.\n\n    Handles authentication with Keystone, choosing a tenant, and fetching\n    a scoped token token for that tenant. Redirects to the URL returned\n    by :meth:`horizon.get_user_home` if successful.\n\n    Subclass of :class:`~horizon.forms.SelfHandlingForm`.\n    \"\"\"\n    region = forms.ChoiceField(label=_(\"Region\"), required=False)\n    username = forms.CharField(label=_(\"User Name\"))\n    password = forms.CharField(label=_(\"Password\"),\n                               widget=forms.PasswordInput(render_value=False))\n\n    def __init__(self, *args, **kwargs):\n        super(Login, self).__init__(*args, **kwargs)\n        # FIXME(gabriel): When we switch to region-only settings, we can\n        # remove this default region business.\n        default_region = (settings.OPENSTACK_KEYSTONE_URL, \"Default Region\")\n        regions = getattr(settings, 'AVAILABLE_REGIONS', [default_region])\n        self.fields['region'].choices = regions\n        if len(regions) == 1:\n            self.fields['region'].initial = default_region[0]\n            self.fields['region'].widget = forms.widgets.HiddenInput()\n\n    def handle(self, request, data):\n        if 'user_name' in request.session:\n            if request.session['user_name'] != data['username']:\n                # To avoid reusing another user's session, create a\n                # new, empty session if the existing session\n                # corresponds to a different authenticated user.\n                request.session.flush()\n        # Always cycle the session key when viewing the login form to\n        # prevent session fixation\n        request.session.cycle_key()\n\n        # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n        # form post doesn't include a region.\n        endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n        region_name = dict(self.fields['region'].choices)[endpoint]\n        request.session['region_endpoint'] = endpoint\n        request.session['region_name'] = region_name\n\n        redirect_to = request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n\n        if data.get('tenant', None):\n            try:\n                token = api.token_create(request,\n                                         data.get('tenant'),\n                                         data['username'],\n                                         data['password'])\n                tenants = api.tenant_list_for_token(request, token.id)\n            except:\n                msg = _('Unable to authenticate for that project.')\n                exceptions.handle(request,\n                                  message=msg,\n                                  escalate=True)\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n            redirect = redirect_to or base.Horizon.get_user_home(user)\n            return shortcuts.redirect(redirect)\n\n        elif data.get('username', None):\n            try:\n                unscoped_token = api.token_create(request,\n                                                  '',\n                                                  data['username'],\n                                                  data['password'])\n            except keystone_exceptions.Unauthorized:\n                exceptions.handle(request,\n                                  _('Invalid user name or password.'))\n            except:\n                # If we get here we don't want to show a stack trace to the\n                # user. However, if we fail here, there may be bad session\n                # data that's been cached already.\n                request.user_logout()\n                exceptions.handle(request,\n                                  message=_(\"An error occurred authenticating.\"\n                                            \" Please try again later.\"),\n                                  escalate=True)\n\n            # Unscoped token\n            request.session['unscoped_token'] = unscoped_token.id\n            request.user.username = data['username']\n\n            # Get the tenant list, and log in using first tenant\n            # FIXME (anthony): add tenant chooser here?\n            try:\n                tenants = api.tenant_list_for_token(request, unscoped_token.id)\n            except:\n                exceptions.handle(request)\n                tenants = []\n\n            # Abort if there are no valid tenants for this user\n            if not tenants:\n                messages.error(request,\n                               _('You are not authorized for any projects.') %\n                                {\"user\": data['username']},\n                               extra_tags=\"login\")\n                return\n\n            # Create a token.\n            # NOTE(gabriel): Keystone can return tenants that you're\n            # authorized to administer but not to log into as a user, so in\n            # the case of an Unauthorized error we should iterate through\n            # the tenants until one succeeds or we've failed them all.\n            while tenants:\n                tenant = tenants.pop()\n                try:\n                    token = api.token_create_scoped(request,\n                                                    tenant.id,\n                                                    unscoped_token.id)\n                    break\n                except:\n                    # This will continue for recognized Unauthorized\n                    # exceptions from keystoneclient.\n                    exceptions.handle(request, ignore=True)\n                    token = None\n            if token is None:\n                raise exceptions.NotAuthorized(\n                    _(\"You are not authorized for any available projects.\"))\n\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n        redirect = redirect_to or base.Horizon.get_user_home(user)\n        return shortcuts.redirect(redirect)\n\n\nclass LoginWithTenant(Login):\n    \"\"\"\n    Exactly like :class:`.Login` but includes the tenant id as a field\n    so that the process of choosing a default tenant is bypassed.\n    \"\"\"\n    region = forms.ChoiceField(required=False)\n    username = forms.CharField(max_length=\"20\",\n                       widget=forms.TextInput(attrs={'readonly': 'readonly'}))\n    tenant = forms.CharField(widget=forms.HiddenInput())\n"], "fixing_code": ["# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nForms used for Horizon's auth mechanisms.\n\"\"\"\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.http import same_origin\nfrom django.utils.translation import ugettext as _\nfrom keystoneclient import exceptions as keystone_exceptions\n\nfrom horizon import api\nfrom horizon import base\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef _set_session_data(request, token):\n    request.session['serviceCatalog'] = token.serviceCatalog\n    request.session['tenant'] = token.tenant['name']\n    request.session['tenant_id'] = token.tenant['id']\n    request.session['token'] = token.id\n    request.session['user_name'] = token.user['name']\n    request.session['user_id'] = token.user['id']\n    request.session['roles'] = token.user['roles']\n\n\nclass Login(forms.SelfHandlingForm):\n    \"\"\" Form used for logging in a user.\n\n    Handles authentication with Keystone, choosing a tenant, and fetching\n    a scoped token token for that tenant. Redirects to the URL returned\n    by :meth:`horizon.get_user_home` if successful.\n\n    Subclass of :class:`~horizon.forms.SelfHandlingForm`.\n    \"\"\"\n    region = forms.ChoiceField(label=_(\"Region\"), required=False)\n    username = forms.CharField(label=_(\"User Name\"))\n    password = forms.CharField(label=_(\"Password\"),\n                               widget=forms.PasswordInput(render_value=False))\n\n    def __init__(self, *args, **kwargs):\n        super(Login, self).__init__(*args, **kwargs)\n        # FIXME(gabriel): When we switch to region-only settings, we can\n        # remove this default region business.\n        default_region = (settings.OPENSTACK_KEYSTONE_URL, \"Default Region\")\n        regions = getattr(settings, 'AVAILABLE_REGIONS', [default_region])\n        self.fields['region'].choices = regions\n        if len(regions) == 1:\n            self.fields['region'].initial = default_region[0]\n            self.fields['region'].widget = forms.widgets.HiddenInput()\n\n    def handle(self, request, data):\n        if 'user_name' in request.session:\n            if request.session['user_name'] != data['username']:\n                # To avoid reusing another user's session, create a\n                # new, empty session if the existing session\n                # corresponds to a different authenticated user.\n                request.session.flush()\n        # Always cycle the session key when viewing the login form to\n        # prevent session fixation\n        request.session.cycle_key()\n\n        # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n        # form post doesn't include a region.\n        endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n        region_name = dict(self.fields['region'].choices)[endpoint]\n        request.session['region_endpoint'] = endpoint\n        request.session['region_name'] = region_name\n\n        redirect_to = request.REQUEST.get(REDIRECT_FIELD_NAME, None)\n        # Make sure the requested redirect matches the protocol,\n        # domain, and port of this request\n        if redirect_to and not same_origin(\n                request.build_absolute_uri(redirect_to),\n                request.build_absolute_uri()):\n            redirect_to = None\n\n        if data.get('tenant', None):\n            try:\n                token = api.token_create(request,\n                                         data.get('tenant'),\n                                         data['username'],\n                                         data['password'])\n                tenants = api.tenant_list_for_token(request, token.id)\n            except:\n                msg = _('Unable to authenticate for that project.')\n                exceptions.handle(request,\n                                  message=msg,\n                                  escalate=True)\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n            redirect = redirect_to or base.Horizon.get_user_home(user)\n            return shortcuts.redirect(redirect)\n\n        elif data.get('username', None):\n            try:\n                unscoped_token = api.token_create(request,\n                                                  '',\n                                                  data['username'],\n                                                  data['password'])\n            except keystone_exceptions.Unauthorized:\n                exceptions.handle(request,\n                                  _('Invalid user name or password.'))\n            except:\n                # If we get here we don't want to show a stack trace to the\n                # user. However, if we fail here, there may be bad session\n                # data that's been cached already.\n                request.user_logout()\n                exceptions.handle(request,\n                                  message=_(\"An error occurred authenticating.\"\n                                            \" Please try again later.\"),\n                                  escalate=True)\n\n            # Unscoped token\n            request.session['unscoped_token'] = unscoped_token.id\n            request.user.username = data['username']\n\n            # Get the tenant list, and log in using first tenant\n            # FIXME (anthony): add tenant chooser here?\n            try:\n                tenants = api.tenant_list_for_token(request, unscoped_token.id)\n            except:\n                exceptions.handle(request)\n                tenants = []\n\n            # Abort if there are no valid tenants for this user\n            if not tenants:\n                messages.error(request,\n                               _('You are not authorized for any projects.') %\n                                {\"user\": data['username']},\n                               extra_tags=\"login\")\n                return\n\n            # Create a token.\n            # NOTE(gabriel): Keystone can return tenants that you're\n            # authorized to administer but not to log into as a user, so in\n            # the case of an Unauthorized error we should iterate through\n            # the tenants until one succeeds or we've failed them all.\n            while tenants:\n                tenant = tenants.pop()\n                try:\n                    token = api.token_create_scoped(request,\n                                                    tenant.id,\n                                                    unscoped_token.id)\n                    break\n                except:\n                    # This will continue for recognized Unauthorized\n                    # exceptions from keystoneclient.\n                    exceptions.handle(request, ignore=True)\n                    token = None\n            if token is None:\n                raise exceptions.NotAuthorized(\n                    _(\"You are not authorized for any available projects.\"))\n\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n        redirect = redirect_to or base.Horizon.get_user_home(user)\n        return shortcuts.redirect(redirect)\n\n\nclass LoginWithTenant(Login):\n    \"\"\"\n    Exactly like :class:`.Login` but includes the tenant id as a field\n    so that the process of choosing a default tenant is bypassed.\n    \"\"\"\n    region = forms.ChoiceField(required=False)\n    username = forms.CharField(max_length=\"20\",\n                       widget=forms.TextInput(attrs={'readonly': 'readonly'}))\n    tenant = forms.CharField(widget=forms.HiddenInput())\n"], "filenames": ["horizon/views/auth_forms.py"], "buggy_code_start_loc": [30], "buggy_code_end_loc": [98], "fixing_code_start_loc": [31], "fixing_code_end_loc": [105], "type": "CWE-20", "message": "Open redirect vulnerability in views/auth_forms.py in OpenStack Dashboard (Horizon) Essex (2012.1) allows remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via a URL in the next parameter to auth/login/. NOTE: this issue was originally assigned CVE-2012-3542 by mistake.", "other": {"cve": {"id": "CVE-2012-3540", "sourceIdentifier": "secalert@redhat.com", "published": "2012-09-05T23:55:02.460", "lastModified": "2023-02-13T04:34:27.550", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Open redirect vulnerability in views/auth_forms.py in OpenStack Dashboard (Horizon) Essex (2012.1) allows remote attackers to redirect users to arbitrary web sites and conduct phishing attacks via a URL in the next parameter to auth/login/. NOTE: this issue was originally assigned CVE-2012-3542 by mistake."}, {"lang": "es", "value": "Una vulnerabilidad de redireci\u00f3n abierta en views/auth_forms.py en OpenStack Dashboard (Horizon) Essex (2012.1) permite a atacantes remotos redirigir a los usuarios a sitios web arbitrarios y llevar a cabo ataques de phishing a trav\u00e9s de una URL en el par\u00e1metro siguiente a auth/login/. NOTA: este problema se le asign\u00f3 originalmente CVE-2012-3542 por error"}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openstack:horizon:2012.1:*:*:*:*:*:*:*", "matchCriteriaId": "8FC7F2DB-92EA-4074-8882-367721CC1705"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2012/08/30/4", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2012/08/30/5", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/55329", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-1565-1", "source": "secalert@redhat.com"}, {"url": "https://bugs.launchpad.net/horizon/+bug/1039077", "source": "secalert@redhat.com"}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/78196", "source": "secalert@redhat.com"}, {"url": "https://github.com/openstack/horizon/commit/35eada8a27323c0f83c400177797927aba6bc99b", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://lists.launchpad.net/openstack/msg16278.html", "source": "secalert@redhat.com"}, {"url": "https://lists.launchpad.net/openstack/msg16281.html", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/openstack/horizon/commit/35eada8a27323c0f83c400177797927aba6bc99b"}}