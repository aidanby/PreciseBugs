{"buggy_code": ["package com.databasir.core.infrastructure.driver;\n\nimport com.databasir.core.domain.DomainErrors;\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.ClassUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.StreamUtils;\nimport org.springframework.web.client.RestClientException;\nimport org.springframework.web.client.RestTemplate;\n\nimport java.io.*;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\nimport java.util.jar.JarFile;\n\n@Component\n@Slf4j\n@RequiredArgsConstructor\npublic class DriverResources {\n\n    @Value(\"${databasir.db.driver-directory}\")\n    private String driverBaseDirectory;\n\n    private final RestTemplate restTemplate;\n\n    public DriverResult loadFromLocal(String localPath) {\n        File driverFile = Paths.get(localPath).toFile();\n        if (driverFile.exists()) {\n            return new DriverResult(localPath, driverFile);\n        } else {\n            throw DomainErrors.LOAD_DRIVER_FAILED.exception();\n        }\n    }\n\n    public DriverResult tempLoadFromRemote(String remoteUrl) {\n        Path dirPath;\n        try {\n            dirPath = Files.createTempDirectory(\"databasir-drivers\");\n        } catch (IOException e) {\n            log.error(\"load driver error cause create temp dir failed\", e);\n            throw DomainErrors.DOWNLOAD_DRIVER_ERROR.exception();\n        }\n        File file = download(remoteUrl, dirPath.toString());\n        return new DriverResult(file.getAbsolutePath(), file);\n    }\n\n    private File download(String driverFileUrl, String parentDir) {\n        Path parentDirPath = Paths.get(parentDir);\n        try {\n            Files.createDirectories(parentDirPath);\n        } catch (IOException e) {\n            log.error(\"\u4e0b\u8f7d\u9a71\u52a8\u65f6\u521b\u5efa\u76ee\u5f55\u5931\u8d25\", e);\n            throw DomainErrors.DOWNLOAD_DRIVER_ERROR.exception(e);\n        }\n\n        // download\n        try {\n            return restTemplate.execute(driverFileUrl, HttpMethod.GET, null, response -> {\n                if (response.getStatusCode().is2xxSuccessful()) {\n                    String prefix = System.currentTimeMillis() + \"\";\n                    String originFileName = response.getHeaders().getContentDisposition().getFilename();\n                    String filename;\n                    if (originFileName == null) {\n                        URL url = new URL(driverFileUrl);\n                        String nameFromUrl = FilenameUtils.getName(url.getPath());\n                        if (StringUtils.endsWith(nameFromUrl, \".jar\")) {\n                            filename = prefix + \"-\" + nameFromUrl;\n                        } else {\n                            filename = prefix + \".jar\";\n                        }\n                    } else {\n                        filename = prefix + \"-\" + originFileName;\n                    }\n                    File targetFile = Paths.get(parentDir, filename).toFile();\n                    FileOutputStream out = new FileOutputStream(targetFile);\n                    StreamUtils.copy(response.getBody(), out);\n                    IOUtils.closeQuietly(out, ex -> log.error(\"close file error\", ex));\n                    log.info(\"{} download success \", targetFile);\n                    return targetFile;\n                } else {\n                    log.error(\"{} download error from {}: {} \", parentDir, driverFileUrl, response);\n                    throw DomainErrors.DOWNLOAD_DRIVER_ERROR.exception(\"\u9a71\u52a8\u4e0b\u8f7d\u5931\u8d25\uff1a\"\n                            + response.getStatusCode()\n                            + \", \"\n                            + response.getStatusText());\n                }\n            });\n        } catch (RestClientException e) {\n            log.error(parentDir + \" download driver error\", e);\n            throw DomainErrors.DOWNLOAD_DRIVER_ERROR.exception(e.getMessage());\n        }\n    }\n\n    public void deleteByDatabaseType(String databaseType) {\n        String baseDir = driverBaseDirectory + \"/\" + databaseType;\n        Path path = Paths.get(baseDir);\n        try {\n            if (Files.exists(path)) {\n                Files.list(path).forEach(file -> {\n                    try {\n                        Files.deleteIfExists(file);\n                    } catch (IOException e) {\n                        log.error(\"delete file error \" + file, e);\n                    }\n                });\n            }\n            Files.deleteIfExists(path);\n        } catch (IOException e) {\n            log.error(\"delete driver error \" + databaseType, e);\n        }\n    }\n\n    public String resolveDriverClassNameFromRemote(String driverFileUrl) {\n        DriverResult driverResult = tempLoadFromRemote(driverFileUrl);\n        File driverFile = driverResult.getDriverFile();\n        String className = resolveDriverClassName(driverFile);\n        try {\n            Files.deleteIfExists(driverFile.toPath());\n        } catch (IOException e) {\n            log.error(\"delete driver error from \" + driverResult.getDriverFilePath(), e);\n        }\n        return className;\n    }\n\n    public String resolveDriverClassNameFromLocal(String driverFilePath) {\n        File driverFile = Paths.get(driverFilePath).toFile();\n        if (!driverFile.exists()) {\n            throw DomainErrors.DRIVER_CLASS_NOT_FOUND.exception(\"\u9a71\u52a8\u6587\u4ef6\u4e0d\u5b58\u5728\uff0c\u8bf7\u91cd\u65b0\u4e0a\u4f20\");\n        }\n        return resolveDriverClassName(driverFile);\n    }\n\n    public String resolveDriverClassName(File driverFile) {\n        JarFile jarFile = null;\n        try {\n            jarFile = new JarFile(driverFile);\n        } catch (IOException e) {\n            log.error(\"resolve driver class name error\", e);\n            throw DomainErrors.DRIVER_CLASS_NOT_FOUND.exception(e.getMessage());\n        }\n\n        final JarFile driverJar = jarFile;\n        String driverClassName = jarFile.stream()\n                .filter(entry -> entry.getName().contains(\"META-INF/services/java.sql.Driver\"))\n                .findFirst()\n                .map(entry -> {\n                    InputStream stream = null;\n                    BufferedReader reader = null;\n                    try {\n                        stream = driverJar.getInputStream(entry);\n                        reader = new BufferedReader(new InputStreamReader(stream));\n                        return reader.readLine();\n                    } catch (IOException e) {\n                        log.error(\"resolve driver class name error\", e);\n                        throw DomainErrors.DRIVER_CLASS_NOT_FOUND.exception(e.getMessage());\n                    } finally {\n                        IOUtils.closeQuietly(reader, ex -> log.error(\"close reader error\", ex));\n                    }\n                })\n                .orElseThrow(DomainErrors.DRIVER_CLASS_NOT_FOUND::exception);\n        IOUtils.closeQuietly(jarFile, ex -> log.error(\"close jar file error\", ex));\n        return driverClassName;\n    }\n\n    public void validateDriverJar(File driverFile, String className) {\n        URLClassLoader loader = null;\n        try {\n            loader = new URLClassLoader(\n                    new URL[]{driverFile.toURI().toURL()},\n                    this.getClass().getClassLoader()\n            );\n        } catch (MalformedURLException e) {\n            log.error(\"load driver jar error \", e);\n            throw DomainErrors.DOWNLOAD_DRIVER_ERROR.exception(e.getMessage());\n        }\n\n        try {\n            Class clazz = Class.forName(className, false, loader);\n            boolean isValid = ClassUtils.getAllInterfaces(clazz)\n                    .stream()\n                    .anyMatch(cls -> cls.getName().equals(\"java.sql.Driver\"));\n            if (!isValid) {\n                throw DomainErrors.DRIVER_CLASS_NOT_FOUND.exception(\"\u4e0d\u5408\u6cd5\u7684\u9a71\u52a8\u7c7b\uff0c\u8bf7\u91cd\u65b0\u6307\u5b9a\");\n            }\n        } catch (ClassNotFoundException e) {\n            log.error(\"init driver error\", e);\n            throw DomainErrors.DRIVER_CLASS_NOT_FOUND.exception(\"\u9a71\u52a8\u521d\u59cb\u5316\u5f02\u5e38, \u8bf7\u68c0\u67e5\u9a71\u52a8\u7c7b\u540d\uff1a\" + e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(loader);\n        }\n    }\n\n    public String copyToStandardDirectory(File sourceFile, String databaseType) {\n        String targetFile = targetDriverFile(databaseType, sourceFile.getName());\n        try {\n            Path target = Paths.get(targetFile);\n            Files.createDirectories(target.getParent());\n            Files.copy(sourceFile.toPath(), target, StandardCopyOption.REPLACE_EXISTING);\n            return targetFile;\n        } catch (IOException e) {\n            log.error(\"copy driver file error\", e);\n            throw DomainErrors.DOWNLOAD_DRIVER_ERROR.exception(e.getMessage());\n        }\n    }\n\n    private String targetDriverFile(String databaseType, String fileName) {\n        return driverBaseDirectory\n                + \"/\" + databaseType\n                + \"/\" + fileName;\n    }\n}\n"], "fixing_code": ["package com.databasir.core.infrastructure.driver;\n\nimport com.databasir.core.domain.DomainErrors;\nimport lombok.RequiredArgsConstructor;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.ClassUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.StreamUtils;\nimport org.springframework.web.client.RestClientException;\nimport org.springframework.web.client.RestTemplate;\n\nimport java.io.*;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\nimport java.util.jar.JarFile;\n\n@Component\n@Slf4j\n@RequiredArgsConstructor\npublic class DriverResources {\n\n    @Value(\"${databasir.db.driver-directory}\")\n    private String driverBaseDirectory;\n\n    private final RestTemplate restTemplate;\n\n    public DriverResult loadFromLocal(String localPath) {\n        File driverFile = Paths.get(localPath).toFile();\n        if (driverFile.exists()) {\n            return new DriverResult(localPath, driverFile);\n        } else {\n            throw DomainErrors.LOAD_DRIVER_FAILED.exception();\n        }\n    }\n\n    public DriverResult tempLoadFromRemote(String remoteUrl) {\n        Path dirPath;\n        try {\n            dirPath = Files.createTempDirectory(\"databasir-drivers\");\n        } catch (IOException e) {\n            log.error(\"load driver error cause create temp dir failed\", e);\n            throw DomainErrors.DOWNLOAD_DRIVER_ERROR.exception();\n        }\n        File file = download(remoteUrl, dirPath.toString());\n        return new DriverResult(file.getAbsolutePath(), file);\n    }\n\n    private File download(String driverFileUrl, String parentDir) {\n        Path parentDirPath = Paths.get(parentDir);\n        try {\n            Files.createDirectories(parentDirPath);\n        } catch (IOException e) {\n            log.error(\"create directory for driver failed\", e);\n            throw DomainErrors.DOWNLOAD_DRIVER_ERROR.exception(e);\n        }\n\n        // download\n        try {\n            return restTemplate.execute(driverFileUrl, HttpMethod.GET, null, response -> {\n                if (response.getStatusCode().is2xxSuccessful()) {\n                    String prefix = System.currentTimeMillis() + \"\";\n                    String originFileName = response.getHeaders().getContentDisposition().getFilename();\n                    String filename;\n                    if (originFileName == null) {\n                        URL url = new URL(driverFileUrl);\n                        String nameFromUrl = FilenameUtils.getName(url.getPath());\n                        if (StringUtils.endsWith(nameFromUrl, \".jar\")) {\n                            filename = prefix + \"-\" + nameFromUrl;\n                        } else {\n                            filename = prefix + \".jar\";\n                        }\n                    } else {\n                        filename = prefix + \"-\" + originFileName;\n                    }\n                    File targetFile = Paths.get(parentDir, filename).toFile();\n                    FileOutputStream out = new FileOutputStream(targetFile);\n                    StreamUtils.copy(response.getBody(), out);\n                    IOUtils.closeQuietly(out, ex -> log.error(\"close file error\", ex));\n                    log.info(\"{} download success \", targetFile);\n                    return targetFile;\n                } else {\n                    log.error(\"{} download error from {}: {} \", parentDir, driverFileUrl, response);\n                    throw DomainErrors.DOWNLOAD_DRIVER_ERROR.exception(\"\u9a71\u52a8\u4e0b\u8f7d\u5931\u8d25\uff1a\"\n                            + response.getStatusCode()\n                            + \", \"\n                            + response.getStatusText());\n                }\n            });\n        } catch (RestClientException e) {\n            String msg = String.format(\"download driver from %s to %s failed\", driverFileUrl, parentDir);\n            log.error(msg, e);\n            throw DomainErrors.DOWNLOAD_DRIVER_ERROR.exception(msg);\n        }\n    }\n\n    public void deleteByDatabaseType(String databaseType) {\n        String baseDir = driverBaseDirectory + \"/\" + databaseType;\n        Path path = Paths.get(baseDir);\n        try {\n            if (Files.exists(path)) {\n                Files.list(path).forEach(file -> {\n                    try {\n                        Files.deleteIfExists(file);\n                    } catch (IOException e) {\n                        log.error(\"delete file error \" + file, e);\n                    }\n                });\n            }\n            Files.deleteIfExists(path);\n        } catch (IOException e) {\n            log.error(\"delete driver error \" + databaseType, e);\n        }\n    }\n\n    public String resolveDriverClassNameFromRemote(String driverFileUrl) {\n        DriverResult driverResult = tempLoadFromRemote(driverFileUrl);\n        File driverFile = driverResult.getDriverFile();\n        String className = resolveDriverClassName(driverFile);\n        try {\n            Files.deleteIfExists(driverFile.toPath());\n        } catch (IOException e) {\n            log.error(\"delete driver error from \" + driverResult.getDriverFilePath(), e);\n        }\n        return className;\n    }\n\n    public String resolveDriverClassNameFromLocal(String driverFilePath) {\n        File driverFile = Paths.get(driverFilePath).toFile();\n        if (!driverFile.exists()) {\n            throw DomainErrors.DRIVER_CLASS_NOT_FOUND.exception(\"\u9a71\u52a8\u6587\u4ef6\u4e0d\u5b58\u5728\uff0c\u8bf7\u91cd\u65b0\u4e0a\u4f20\");\n        }\n        return resolveDriverClassName(driverFile);\n    }\n\n    public String resolveDriverClassName(File driverFile) {\n        JarFile jarFile = null;\n        try {\n            jarFile = new JarFile(driverFile);\n        } catch (IOException e) {\n            log.error(\"resolve driver class name error\", e);\n            throw DomainErrors.DRIVER_CLASS_NOT_FOUND.exception(e.getMessage());\n        }\n\n        final JarFile driverJar = jarFile;\n        String driverClassName = jarFile.stream()\n                .filter(entry -> entry.getName().contains(\"META-INF/services/java.sql.Driver\"))\n                .findFirst()\n                .map(entry -> {\n                    InputStream stream = null;\n                    BufferedReader reader = null;\n                    try {\n                        stream = driverJar.getInputStream(entry);\n                        reader = new BufferedReader(new InputStreamReader(stream));\n                        return reader.readLine();\n                    } catch (IOException e) {\n                        log.error(\"resolve driver class name error\", e);\n                        throw DomainErrors.DRIVER_CLASS_NOT_FOUND.exception(e.getMessage());\n                    } finally {\n                        IOUtils.closeQuietly(reader, ex -> log.error(\"close reader error\", ex));\n                    }\n                })\n                .orElseThrow(DomainErrors.DRIVER_CLASS_NOT_FOUND::exception);\n        IOUtils.closeQuietly(jarFile, ex -> log.error(\"close jar file error\", ex));\n        return driverClassName;\n    }\n\n    public void validateDriverJar(File driverFile, String className) {\n        URLClassLoader loader = null;\n        try {\n            loader = new URLClassLoader(\n                    new URL[]{driverFile.toURI().toURL()},\n                    this.getClass().getClassLoader()\n            );\n        } catch (MalformedURLException e) {\n            log.error(\"load driver jar error \", e);\n            throw DomainErrors.DOWNLOAD_DRIVER_ERROR.exception(e.getMessage());\n        }\n\n        try {\n            Class clazz = Class.forName(className, false, loader);\n            boolean isValid = ClassUtils.getAllInterfaces(clazz)\n                    .stream()\n                    .anyMatch(cls -> cls.getName().equals(\"java.sql.Driver\"));\n            if (!isValid) {\n                throw DomainErrors.DRIVER_CLASS_NOT_FOUND.exception(\"\u4e0d\u5408\u6cd5\u7684\u9a71\u52a8\u7c7b\uff0c\u8bf7\u91cd\u65b0\u6307\u5b9a\");\n            }\n        } catch (ClassNotFoundException e) {\n            log.error(\"init driver error\", e);\n            throw DomainErrors.DRIVER_CLASS_NOT_FOUND.exception(\"\u9a71\u52a8\u521d\u59cb\u5316\u5f02\u5e38, \u8bf7\u68c0\u67e5\u9a71\u52a8\u7c7b\u540d\uff1a\" + e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(loader);\n        }\n    }\n\n    public String copyToStandardDirectory(File sourceFile, String databaseType) {\n        String targetFile = targetDriverFile(databaseType, sourceFile.getName());\n        try {\n            Path target = Paths.get(targetFile);\n            Files.createDirectories(target.getParent());\n            Files.copy(sourceFile.toPath(), target, StandardCopyOption.REPLACE_EXISTING);\n            return targetFile;\n        } catch (IOException e) {\n            log.error(\"copy driver file error\", e);\n            throw DomainErrors.DOWNLOAD_DRIVER_ERROR.exception(e.getMessage());\n        }\n    }\n\n    private String targetDriverFile(String databaseType, String fileName) {\n        return driverBaseDirectory\n                + \"/\" + databaseType\n                + \"/\" + fileName;\n    }\n}\n"], "filenames": ["core/src/main/java/com/databasir/core/infrastructure/driver/DriverResources.java"], "buggy_code_start_loc": [63], "buggy_code_end_loc": [102], "fixing_code_start_loc": [63], "fixing_code_end_loc": [103], "type": "CWE-918", "message": "Databasir is a database metadata management platform. Databasir <= 1.06 has Server-Side Request Forgery (SSRF) vulnerability. The SSRF is triggered by a sending a **single** HTTP POST request to create a databaseType. By supplying a `jdbcDriverFileUrl` that returns a non `200` response code, the url is executed, the response is logged (both in terminal and in database) and is included in the response. This would allow an attackers to obtain the real IP address and scan Intranet information. This issue was fixed in version 1.0.7.", "other": {"cve": {"id": "CVE-2022-31196", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-02T20:15:08.440", "lastModified": "2022-09-08T03:30:34.267", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Databasir is a database metadata management platform. Databasir <= 1.06 has Server-Side Request Forgery (SSRF) vulnerability. The SSRF is triggered by a sending a **single** HTTP POST request to create a databaseType. By supplying a `jdbcDriverFileUrl` that returns a non `200` response code, the url is executed, the response is logged (both in terminal and in database) and is included in the response. This would allow an attackers to obtain the real IP address and scan Intranet information. This issue was fixed in version 1.0.7."}, {"lang": "es", "value": "Databasir es una plataforma de administraci\u00f3n de metadatos de bases de datos. Databasir versiones anteriores a 1.06 incluy\u00e9ndola, presenta una vulnerabilidad de tipo Server-Side Request Forgery (SSRF). La SSRF es desencadenada mediante el env\u00edo de una **sola** petici\u00f3n HTTP POST para crear una base de datosType. Al suministrar un \"jdbcDriverFileUrl\" que devuelve un c\u00f3digo de respuesta que no es \"200\", la url es ejecutada, la respuesta es registrada (tanto en el terminal como en la base de datos) y es incluido en la respuesta. Esto permitir\u00eda a un atacante obtener la direcci\u00f3n IP real y escanear la informaci\u00f3n de la Intranet. Este problema fue corregido en versi\u00f3n 1.0.7"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 7.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:databasir:databasir:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.7", "matchCriteriaId": "6CFB6810-D4F4-428F-B799-30955E9B3D0F"}]}]}], "references": [{"url": "https://github.com/vran-dev/databasir/commit/226c20e0c9124037671a91d6b3e5083bd2462058", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/vran-dev/databasir/releases/tag/v1.0.7", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/vran-dev/databasir/security/advisories/GHSA-qvg8-427f-852q", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vran-dev/databasir/commit/226c20e0c9124037671a91d6b3e5083bd2462058"}}