{"buggy_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n#define EIGEN_USE_THREADS\n\n#include <algorithm>\n#include <cmath>\n#include <random>\n#include <vector>\n\n#include \"tensorflow/core/kernels/fractional_pool_common.h\"\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/numeric_op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/lib/random/random.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/mutex.h\"\n#include \"tensorflow/core/util/guarded_philox_random.h\"\n\nnamespace tensorflow {\ntypedef Eigen::ThreadPoolDevice CPUDevice;\n\ntemplate <typename T>\nclass FractionalAvgPoolOp : public OpKernel {\n public:\n  explicit FractionalAvgPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\n                    \"pooling_ratio field must specify 4 dimensions\"));\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional average pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      // If both seeds are not set when deterministic_ is true, force set seeds.\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }\n\n  void Compute(OpKernelContext* context) override {\n    typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n        ConstEigenMatrixMap;\n    typedef Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n        EigenMatrixMap;\n\n    constexpr int tensor_in_and_out_dims = 4;\n\n    const Tensor& tensor_in = context->input(0);\n    OP_REQUIRES(context, tensor_in.dims() == tensor_in_and_out_dims,\n                errors::InvalidArgument(\"tensor_in must be 4-dimensional\"));\n\n    std::vector<int> input_size(tensor_in_and_out_dims);\n    std::vector<int> output_size(tensor_in_and_out_dims);\n    for (int i = 0; i < tensor_in_and_out_dims; ++i) {\n      input_size[i] = tensor_in.dim_size(i);\n      OP_REQUIRES(\n          context, pooling_ratio_[i] <= input_size[i],\n          errors::InvalidArgument(\n              \"Pooling ratio cannot be bigger than input tensor dim size.\"));\n    }\n    // Output size.\n    for (int i = 0; i < tensor_in_and_out_dims; ++i) {\n      output_size[i] =\n          static_cast<int>(std::floor(input_size[i] / pooling_ratio_[i]));\n      DCHECK_GT(output_size[i], 0);\n    }\n\n    // Generate pooling sequence.\n    std::vector<int64_t> row_cum_seq;\n    std::vector<int64_t> col_cum_seq;\n    GuardedPhiloxRandom generator;\n    generator.Init(seed_, seed2_);\n    row_cum_seq = GeneratePoolingSequence(input_size[1], output_size[1],\n                                          &generator, pseudo_random_);\n    col_cum_seq = GeneratePoolingSequence(input_size[2], output_size[2],\n                                          &generator, pseudo_random_);\n\n    // Prepare output.\n    Tensor* output_tensor = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                0,\n                                TensorShape({output_size[0], output_size[1],\n                                             output_size[2], output_size[3]}),\n                                &output_tensor));\n    Tensor* output_row_seq_tensor = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\n                     1, TensorShape({static_cast<int64_t>(row_cum_seq.size())}),\n                     &output_row_seq_tensor));\n    Tensor* output_col_seq_tensor = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\n                     2, TensorShape({static_cast<int64_t>(col_cum_seq.size())}),\n                     &output_col_seq_tensor));\n\n    ConstEigenMatrixMap in_mat(tensor_in.flat<T>().data(), input_size[3],\n                               input_size[2] * input_size[1] * input_size[0]);\n\n    EigenMatrixMap out_mat(output_tensor->flat<T>().data(), output_size[3],\n                           output_size[2] * output_size[1] * output_size[0]);\n    // out_count corresponds to number of elements in each pooling cell.\n    Eigen::Matrix<T, Eigen::Dynamic, 1> out_count(out_mat.cols());\n\n    // Initializes the output tensor and out_count with 0.\n    out_mat.setZero();\n    out_count.setZero();\n\n    auto output_row_seq_flat = output_row_seq_tensor->flat<int64_t>();\n    auto output_col_seq_flat = output_col_seq_tensor->flat<int64_t>();\n\n    // Set output tensors.\n    for (int i = 0; i < row_cum_seq.size(); ++i) {\n      output_row_seq_flat(i) = row_cum_seq[i];\n    }\n\n    for (int i = 0; i < col_cum_seq.size(); ++i) {\n      output_col_seq_flat(i) = col_cum_seq[i];\n    }\n\n    // For both input and output,\n    // 0: batch\n    // 1: row / row\n    // 2: col / col\n    // 3: depth / channel\n    const int64_t row_max = input_size[1] - 1;\n    const int64_t col_max = input_size[2] - 1;\n    for (int64_t b = 0; b < input_size[0]; ++b) {\n      // row sequence.\n      for (int64_t hs = 0; hs < row_cum_seq.size() - 1; ++hs) {\n        // row start and end.\n        const int64_t row_start = row_cum_seq[hs];\n        int64_t row_end =\n            overlapping_ ? row_cum_seq[hs + 1] : row_cum_seq[hs + 1] - 1;\n        row_end = std::min(row_end, row_max);\n\n        // col sequence.\n        for (int64_t ws = 0; ws < col_cum_seq.size() - 1; ++ws) {\n          const int64_t out_offset =\n              (b * output_size[1] + hs) * output_size[2] + ws;\n          // col start and end.\n          const int64_t col_start = col_cum_seq[ws];\n          int64_t col_end =\n              overlapping_ ? col_cum_seq[ws + 1] : col_cum_seq[ws + 1] - 1;\n          col_end = std::min(col_end, col_max);\n          for (int64_t h = row_start; h <= row_end; ++h) {\n            for (int64_t w = col_start; w <= col_end; ++w) {\n              const int64_t in_offset =\n                  (b * input_size[1] + h) * input_size[2] + w;\n              out_mat.col(out_offset) += in_mat.col(in_offset);\n              out_count(out_offset)++;\n            }\n          }\n        }\n      }\n    }\n    DCHECK_GT(out_count.minCoeff(), 0);\n    out_mat.array().rowwise() /= out_count.transpose().array();\n  }\n\n private:\n  bool deterministic_;\n  int64_t seed_;\n  int64_t seed2_;\n  std::vector<float> pooling_ratio_;\n  bool pseudo_random_;\n  bool overlapping_;\n};\n\n#define REGISTER_FRACTIONALAVGPOOL(type)                                      \\\n  REGISTER_KERNEL_BUILDER(                                                    \\\n      Name(\"FractionalAvgPool\").Device(DEVICE_CPU).TypeConstraint<type>(\"T\"), \\\n      FractionalAvgPoolOp<type>)\n\nREGISTER_FRACTIONALAVGPOOL(int32);\nREGISTER_FRACTIONALAVGPOOL(int64_t);\nREGISTER_FRACTIONALAVGPOOL(float);\nREGISTER_FRACTIONALAVGPOOL(double);\n\n#undef REGISTER_FRACTIONALAVGPOOL\n\ntemplate <class T>\nclass FractionalAvgPoolGradOp : public OpKernel {\n public:\n  explicit FractionalAvgPoolGradOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    // Here's the basic idea:\n    // Batch and depth dimension are independent from row and col dimension. And\n    // because FractionalAvgPool currently only support pooling along row and\n    // col, we can basically think of this 4D tensor backpropagation as\n    // operation of a series of 2D planes.\n    //\n    // For each element of a 'slice' (2D plane) of output_backprop, we need to\n    // figure out its contributors when doing FractionalAvgPool operation. This\n    // can be done based on row_pooling_sequence, col_pooling_seq and\n    // overlapping.\n    // Once we figure out the original contributors, we just need to evenly\n    // divide the value of this element among these contributors.\n    //\n    // Internally, we divide the out_backprop tensor and store it in a temporary\n    // tensor of double type. And cast it to the corresponding type.\n    typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n        ConstEigenMatrixMap;\n    typedef Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>\n        EigenDoubleMatrixMap;\n\n    // Grab the inputs.\n    const Tensor& orig_input_tensor_shape = context->input(0);\n    OP_REQUIRES(context,\n                orig_input_tensor_shape.dims() == 1 &&\n                    orig_input_tensor_shape.NumElements() == 4,\n                errors::InvalidArgument(\"original input tensor shape must be\"\n                                        \"1-dimensional and 4 elements\"));\n    const Tensor& out_backprop = context->input(1);\n    const Tensor& row_seq_tensor = context->input(2);\n    const Tensor& col_seq_tensor = context->input(3);\n\n    const int64_t out_batch = out_backprop.dim_size(0);\n    const int64_t out_rows = out_backprop.dim_size(1);\n    const int64_t out_cols = out_backprop.dim_size(2);\n    const int64_t out_depth = out_backprop.dim_size(3);\n\n    OP_REQUIRES(context, row_seq_tensor.NumElements() > out_rows,\n                errors::InvalidArgument(\"Given out_backprop shape \",\n                                        out_backprop.shape().DebugString(),\n                                        \", row_seq_tensor must have at least \",\n                                        out_rows + 1, \" elements, but got \",\n                                        row_seq_tensor.NumElements()));\n    OP_REQUIRES(context, col_seq_tensor.NumElements() > out_cols,\n                errors::InvalidArgument(\"Given out_backprop shape \",\n                                        out_backprop.shape().DebugString(),\n                                        \", col_seq_tensor must have at least \",\n                                        out_cols + 1, \" elements, but got \",\n                                        col_seq_tensor.NumElements()));\n\n    auto row_seq_tensor_flat = row_seq_tensor.flat<int64_t>();\n    auto col_seq_tensor_flat = col_seq_tensor.flat<int64_t>();\n    auto orig_input_tensor_shape_flat = orig_input_tensor_shape.flat<int64_t>();\n\n    const int64_t in_batch = orig_input_tensor_shape_flat(0);\n    const int64_t in_rows = orig_input_tensor_shape_flat(1);\n    const int64_t in_cols = orig_input_tensor_shape_flat(2);\n    const int64_t in_depth = orig_input_tensor_shape_flat(3);\n    OP_REQUIRES(\n        context, in_batch != 0,\n        errors::InvalidArgument(\"Batch dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_rows != 0,\n        errors::InvalidArgument(\"Rows dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_cols != 0,\n        errors::InvalidArgument(\"Columns dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_depth != 0,\n        errors::InvalidArgument(\"Depth dimension of input must not be 0\"));\n\n    constexpr int tensor_in_and_out_dims = 4;\n    // Transform orig_input_tensor_shape into TensorShape\n    TensorShape in_shape;\n    for (auto i = 0; i < tensor_in_and_out_dims; ++i) {\n      in_shape.AddDim(orig_input_tensor_shape_flat(i));\n    }\n\n    // Create intermediate in_backprop.\n    Tensor in_backprop_tensor_temp;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp(\n                                {0}, DataTypeToEnum<double>::v(), in_shape,\n                                &in_backprop_tensor_temp));\n    in_backprop_tensor_temp.flat<double>().setZero();\n    // Transform 4D tensor to 2D matrix.\n    EigenDoubleMatrixMap in_backprop_tensor_temp_mat(\n        in_backprop_tensor_temp.flat<double>().data(), in_depth,\n        in_cols * in_rows * in_batch);\n    ConstEigenMatrixMap out_backprop_mat(out_backprop.flat<T>().data(),\n                                         out_depth,\n                                         out_cols * out_rows * out_batch);\n    // Loop through each element of out_backprop and evenly distribute the\n    // element to the corresponding pooling cell.\n    const int64_t in_max_row_index = in_rows - 1;\n    const int64_t in_max_col_index = in_cols - 1;\n    for (int64_t b = 0; b < out_batch; ++b) {\n      for (int64_t r = 0; r < out_rows; ++r) {\n        const int64_t in_row_start = row_seq_tensor_flat(r);\n\n        int64_t in_row_end = overlapping_ ? row_seq_tensor_flat(r + 1)\n                                          : row_seq_tensor_flat(r + 1) - 1;\n        in_row_end = std::min(in_row_end, in_max_row_index);\n        OP_REQUIRES(context, in_row_start >= 0 && in_row_end >= 0,\n                    errors::InvalidArgument(\n                        \"Row sequence tensor values must not be negative, got \",\n                        row_seq_tensor_flat));\n\n        for (int64_t c = 0; c < out_cols; ++c) {\n          const int64_t in_col_start = col_seq_tensor_flat(c);\n          int64_t in_col_end = overlapping_ ? col_seq_tensor_flat(c + 1)\n                                            : col_seq_tensor_flat(c + 1) - 1;\n          in_col_end = std::min(in_col_end, in_max_col_index);\n\n          OP_REQUIRES(\n              context, in_col_start >= 0 && in_col_end >= 0,\n              errors::InvalidArgument(\n                  \"Column sequence tensor values must not be negative, got \",\n                  col_seq_tensor_flat));\n          const int64_t num_elements_in_pooling_cell =\n              (in_row_end - in_row_start + 1) * (in_col_end - in_col_start + 1);\n          const int64_t out_index = (b * out_rows + r) * out_cols + c;\n          // Now we can evenly distribute out_backprop(b, h, w, *) to\n          // in_backprop(b, hs:he, ws:we, *).\n          for (int64_t in_r = in_row_start; in_r <= in_row_end; ++in_r) {\n            for (int64_t in_c = in_col_start; in_c <= in_col_end; ++in_c) {\n              const int64_t in_index = (b * in_rows + in_r) * in_cols + in_c;\n              // Walk through each channel (depth).\n              for (int64_t d = 0; d < out_depth; ++d) {\n                const double out_backprop_element = static_cast<double>(\n                    out_backprop_mat.coeffRef(d, out_index));\n                double& in_backprop_ref =\n                    in_backprop_tensor_temp_mat.coeffRef(d, in_index);\n                in_backprop_ref +=\n                    out_backprop_element / num_elements_in_pooling_cell;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Depending on the type, cast double to type T.\n    Tensor* in_backprop_tensor = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, in_shape, &in_backprop_tensor));\n    auto in_backprop_tensor_flat = in_backprop_tensor->flat<T>();\n    auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp.flat<double>();\n    for (int64_t i = 0; i < in_backprop_tensor_flat.size(); ++i) {\n      in_backprop_tensor_flat(i) =\n          static_cast<T>(in_backprop_tensor_temp_flat(i));\n    }\n  }\n\n private:\n  bool overlapping_;\n};\n\n#define REGISTER_FRACTIONALAVGPOOLGRAD(type)              \\\n  REGISTER_KERNEL_BUILDER(Name(\"FractionalAvgPoolGrad\")   \\\n                              .Device(DEVICE_CPU)         \\\n                              .TypeConstraint<type>(\"T\"), \\\n                          FractionalAvgPoolGradOp<type>)\n\nREGISTER_FRACTIONALAVGPOOLGRAD(int32);\nREGISTER_FRACTIONALAVGPOOLGRAD(int64_t);\nREGISTER_FRACTIONALAVGPOOLGRAD(float);\nREGISTER_FRACTIONALAVGPOOLGRAD(double);\n\n#undef REGISTER_FRACTIONALAVGPOOLGRAD\n}  // namespace tensorflow\n", "# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for fractional average pool operation.\"\"\"\n\nimport math\n\nimport numpy as np\n\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import gen_nn_ops\nfrom tensorflow.python.ops import gradient_checker\nfrom tensorflow.python.ops import nn_ops\nimport tensorflow.python.ops.nn_grad  # pylint: disable=unused-import\nfrom tensorflow.python.platform import test\n\n\nclass FractionalAvgTest(test.TestCase):\n\n  # Random number generate with seed.\n  _PRNG = np.random.RandomState(341261000)\n  _SEED = 341261001\n\n  def _AvgPoolAlongRows(self, input_matrix, row_seq, overlapping):\n    \"\"\"Perform average pool along row of a 2-D matrix based on row_seq.\n\n    Args:\n      input_matrix: A 2-D matrix.\n      row_seq: Cumulative pooling sequence along row.\n      overlapping: Whether or not use overlapping when pooling.\n\n    Returns:\n      A 2-D matrix, with\n        * num_rows = len(row_seq)-1\n        * num_cols = input_matrix.num_cols.\n    \"\"\"\n    output_image = np.zeros(input_matrix.shape[1])\n    row_max = row_seq[-1]\n    for i in range(row_seq.shape[0] - 1):\n      row_start = row_seq[i]\n      row_end = row_seq[i + 1] + 1 if overlapping else row_seq[i + 1]\n      row_end = min(row_end, row_max)\n      output_image = np.vstack((output_image, np.mean(\n          input_matrix[row_start:row_end, :], axis=0)))  # axis 0 is along row\n    # remove the sentinel row\n    return output_image[1:, :]\n\n  def _AvgPoolAlongCols(self, input_matrix, col_seq, overlapping):\n    \"\"\"Perform average pool along column of a 2-D matrix based on col_seq.\n\n    Args:\n      input_matrix: A 2-D matrix.\n      col_seq: Cumulative pooling sequence along column.\n      overlapping: Whether or not use overlapping when pooling.\n\n    Returns:\n      A 2-D matrix, with\n        * num_rows = input_matrix.num_rows\n        * num_cols = len(col_seq)-1.\n    \"\"\"\n    input_matrix = input_matrix.transpose()\n    output_matrix = self._AvgPoolAlongRows(input_matrix, col_seq, overlapping)\n    return output_matrix.transpose()\n\n  def _GetExpectedFractionalAvgPoolResult(self, input_tensor, row_seq, col_seq,\n                                          overlapping):\n    \"\"\"Get expected fractional average pooling result.\n\n    row_seq and col_seq together defines the fractional pooling region.\n\n    Args:\n      input_tensor: Original input tensor, assuming it is a 4-D tensor, with\n        dimension as [batch, height/row, width/column, channels/depth].\n      row_seq: Cumulative pooling sequence along row.\n      col_seq: Cumulative pooling sequence along column.\n      overlapping: Use overlapping when doing pooling.\n\n    Returns:\n      A 4-D tensor that is the result of average pooling on input_tensor based\n        on pooling region defined by row_seq and col_seq, conditioned on whether\n        or not overlapping is used.\n    \"\"\"\n    input_shape = input_tensor.shape\n    output_shape = (input_shape[0], len(row_seq) - 1, len(col_seq) - 1,\n                    input_shape[3])\n    output_tensor = np.zeros(shape=output_shape, dtype=input_tensor.dtype)\n    for batch in range(input_shape[0]):\n      for channel in range(input_shape[3]):\n        two_dim_slice = input_tensor[batch, :, :, channel]\n        tmp = self._AvgPoolAlongRows(two_dim_slice, row_seq, overlapping)\n        output_tensor[batch, :, :, channel] = self._AvgPoolAlongCols(\n            tmp, col_seq, overlapping)\n\n    return output_tensor\n\n  def _ValidateFractionalAvgPoolResult(self, input_tensor, pooling_ratio,\n                                       pseudo_random, overlapping):\n    \"\"\"Validate FractionalAvgPool's result against expected.\n\n    Expected result is computed given input_tensor, and pooling region defined\n    by row_seq and col_seq.\n\n    Args:\n      input_tensor: A tensor or numpy ndarray.\n      pooling_ratio: A list or tuple of length 4, first and last element be 1.\n      pseudo_random: Use pseudo random method to generate pooling sequence.\n      overlapping: Use overlapping when pooling.\n\n    Returns:\n      None\n    \"\"\"\n    with self.cached_session() as sess:\n      p, r, c = nn_ops.fractional_avg_pool_v2(\n          input_tensor,\n          pooling_ratio,\n          pseudo_random,\n          overlapping,\n          seed=self._SEED)\n      actual, row_seq, col_seq = self.evaluate([p, r, c])\n      expected = self._GetExpectedFractionalAvgPoolResult(input_tensor, row_seq,\n                                                          col_seq, overlapping)\n      self.assertShapeEqual(expected, p)\n      self.assertAllClose(expected, actual)\n\n  def _testVisually(self):\n    \"\"\"Manual test by printing out intermediate result of a small random tensor.\n\n    Since _GetExpectedFractionalAvgPoolResult is 'automated', it feels safer to\n    have a test case that you can see what's happening.\n    This test will generate a small, random, int 2D matrix, and feed it to\n    FractionalAvgPool and _GetExpectedFractionalAvgPoolResult.\n    \"\"\"\n    num_rows = 6\n    num_cols = 6\n    tensor_shape = (1, num_rows, num_cols, 1)\n    pseudo_random = False\n    for overlapping in True, False:\n      print(\"-\" * 70)\n      print(\"Testing FractionalAvgPool with overlapping = {}\".format(\n          overlapping))\n      rand_mat = self._PRNG.randint(10, size=tensor_shape)\n      pooling_ratio = [1, math.sqrt(2), math.sqrt(2), 1]\n      with self.cached_session() as sess:\n        p, r, c = nn_ops.fractional_avg_pool_v2(\n            rand_mat.astype(np.float32),\n            pooling_ratio,\n            pseudo_random,\n            overlapping,\n            seed=self._SEED)\n        tensor_output, row_seq, col_seq = self.evaluate([p, r, c])\n        expected_result = self._GetExpectedFractionalAvgPoolResult(\n            rand_mat.astype(np.float32), row_seq, col_seq, overlapping)\n        print(\"row sequence:\")\n        print(row_seq)\n        print(\"column sequence:\")\n        print(col_seq)\n\n        print(\"Input:\")\n        # Print input with pooling region marked.\n        for i in range(num_rows):\n          row_to_print = []\n          for j in range(num_cols):\n            if j in col_seq:\n              row_to_print.append(\"|\")\n            row_to_print.append(str(rand_mat[0, i, j, 0]))\n          row_to_print.append(\"|\")\n          if i in row_seq:\n            print(\"-\" * 2 * len(row_to_print))\n          print(\" \".join(row_to_print))\n        print(\"-\" * 2 * len(row_to_print))\n\n        print(\"Output from FractionalAvgPool:\")\n        print(tensor_output[0, :, :, 0])\n        print(\"Expected result:\")\n        print(expected_result[0, :, :, 0])\n\n  def testAllInputOptions(self):\n    \"\"\"Try all possible input options for fractional_avg_pool.\n    \"\"\"\n    num_batches = 5\n    num_channels = 3\n    num_rows = 20\n    num_cols = 30\n    for pseudo_random in True, False:\n      for overlapping in True, False:\n        tensor_shape = (num_batches, num_rows, num_cols, num_channels)\n        # random tensor with value in [-500.0, 500.0)\n        rand_mat = self._PRNG.random_sample(tensor_shape) * 1000 - 500\n        self._ValidateFractionalAvgPoolResult(\n            rand_mat, [1, math.sqrt(3), math.sqrt(2), 1], pseudo_random,\n            overlapping)\n\n  def testIntegerTensorInput(self):\n    \"\"\"Test FractionalAvgPool works fine when input tensor is integer type.\n    \"\"\"\n    pseudo_random = True\n    overlapping = True\n    tensor_shape = (1, 6, 6, 1)\n    # pyformat: disable\n    mat = np.array([\n        [2, 6, 4, 1, 3, 6],\n        [8, 9, 1, 6, 6, 8],\n        [3, 9, 8, 2, 5, 6],\n        [2, 7, 9, 5, 4, 5],\n        [8, 5, 0, 5, 7, 4],\n        [4, 4, 5, 9, 7, 2]\n    ])\n    # pyformat: enable\n    self._ValidateFractionalAvgPoolResult(mat.reshape(tensor_shape),\n                                          [1, math.sqrt(3), math.sqrt(2), 1],\n                                          pseudo_random, overlapping)\n\n  def testDifferentTensorShapes(self):\n    \"\"\"Test different shapes of input tensor.\n\n    Mainly test different combinations of num_rows and num_cols.\n    \"\"\"\n    pseudo_random = True\n    overlapping = True\n    for num_batches in [1, 3]:\n      for num_channels in [1, 3]:\n        for num_rows in [10, 20, 50]:\n          for num_cols in [10, 20, 50]:\n            tensor_shape = (num_batches, num_rows, num_cols, num_channels)\n            # random tensor with value in [-500.0, 500.0)\n            rand_mat = self._PRNG.random_sample(tensor_shape) * 1000 - 500\n            self._ValidateFractionalAvgPoolResult(\n                rand_mat, [1, math.sqrt(3), math.sqrt(2), 1], pseudo_random,\n                overlapping)\n\n  def testLargePoolingRatio(self):\n    \"\"\"Test when pooling ratio is not within [1, 2).\n    \"\"\"\n    pseudo_random = True\n    overlapping = True\n    num_batches = 3\n    num_channels = 3\n    num_rows = 30\n    num_cols = 50\n    tensor_shape = (num_batches, num_rows, num_cols, num_channels)\n    for row_ratio in [math.sqrt(11), math.sqrt(37)]:\n      for col_ratio in [math.sqrt(11), math.sqrt(27)]:\n        # random tensor with value in [-500.0, 500.0)\n        rand_mat = self._PRNG.random_sample(tensor_shape) * 1000 - 500\n        self._ValidateFractionalAvgPoolResult(rand_mat,\n                                              [1, row_ratio, col_ratio, 1],\n                                              pseudo_random, overlapping)\n\n  def testDivisiblePoolingRatio(self):\n    \"\"\"Test when num of rows/cols can evenly divide pooling ratio.\n\n    This is a case regular average pooling can handle. Should be handled by\n    fractional pooling as well.\n    \"\"\"\n    pseudo_random = True\n    overlapping = True\n    num_batches = 3\n    num_channels = 3\n    num_rows = 30\n    num_cols = 50\n    tensor_shape = (num_batches, num_rows, num_cols, num_channels)\n    # random tensor with value in [-500.0, 500.0)\n    rand_mat = self._PRNG.random_sample(tensor_shape) * 1000 - 500\n    self._ValidateFractionalAvgPoolResult(rand_mat, [1, 2, 2, 1], pseudo_random,\n                                          overlapping)\n\n  @test_util.run_deprecated_v1\n  def testDifferentInputTensorShape(self):\n    \"\"\"Runs the operation in one session with different input tensor shapes.\"\"\"\n    with self.cached_session() as sess:\n      input_holder = array_ops.placeholder(dtypes.float32,\n                                           [None, None, None, 3])\n      pooling_ratio = [1, 1.5, 1.5, 1]\n      pseudo_random = False\n      overlapping = False\n      p, r, c = nn_ops.fractional_avg_pool_v2(\n          input_holder,\n          pooling_ratio,\n          pseudo_random,\n          overlapping,\n          seed=self._SEED)\n      # First run.\n      input_a = np.zeros([3, 32, 32, 3])\n      actual, row_seq, col_seq = sess.run([p, r, c], {input_holder: input_a})\n      expected = self._GetExpectedFractionalAvgPoolResult(\n          input_a, row_seq, col_seq, overlapping)\n      self.assertSequenceEqual(expected.shape, actual.shape)\n      # Second run.\n      input_b = np.zeros([4, 60, 60, 3])\n      actual, row_seq, col_seq = sess.run([p, r, c], {input_holder: input_b})\n      expected = self._GetExpectedFractionalAvgPoolResult(\n          input_b, row_seq, col_seq, overlapping)\n      self.assertSequenceEqual(expected.shape, actual.shape)\n\n  def testNegativeSeqValuesForGradOp(self):\n    with self.assertRaisesRegex(\n        errors.InvalidArgumentError,\n        r\"Row sequence tensor values must not be negative.*\"):\n      y = nn_ops.gen_nn_ops.fractional_avg_pool_grad(\n          orig_input_tensor_shape=[2, 2, 2, 2],\n          out_backprop=[[[[1, 2], [3, 4], [5, 6]], [[7, 8], [9, 10], [11,\n                                                                      12]]]],\n          row_pooling_sequence=[-10, 1, 2, 3],\n          col_pooling_sequence=[1, 2, 3, 4],\n          overlapping=True)\n\n      self.evaluate(y)\n      with self.assertRaisesRegex(\n          errors.InvalidArgumentError,\n          r\"Column sequence tensor values must not be negative.*\"):\n        z = nn_ops.gen_nn_ops.fractional_avg_pool_grad(\n            orig_input_tensor_shape=[2, 2, 2, 2],\n            out_backprop=[[[[1, 2], [3, 4], [5, 6]], [[7, 8], [9, 10], [11,\n                                                                        12]]]],\n            row_pooling_sequence=[10, 1, 2, 3],\n            col_pooling_sequence=[1, 2, -3, 4],\n            overlapping=True)\n\n        self.evaluate(z)\n\n\nclass FractionalAvgPoolGradTest(test.TestCase):\n  \"\"\"Tests for FractionalAvgPoolGrad.\n\n  Two types of tests for FractionalAvgPoolGrad.\n  1) Test fractional_avg_pool_grad() directly.\n    This type of test relies on gen_nn_ops.avg_pool_grad() returns the\n  correct result. For example:\n    * input_tensor_shape = (1, 10, 10, 1)\n    * window_size = (1, 2, 2, 1)\n    * stride_size = (1, 2, 2, 1)\n    * padding: not really important, since 10/2 is divisible\n  avg pooling should generate the same result as fractional avg pooling with:\n    * row_sequence = [0, 2, 4, 6, 8, 10]\n    * col_sequence = [0, 2, 4, 6, 8, 10]\n    * overlapping = False\n  This also means their gradients in such case will be the same.\n\n  Similarly, when\n    * input_tensor_shape = (1, 7, 7, 1)\n    * window_size = (1, 3, 3, 1)\n    * stride_size = (1, 2, 2, 1)\n    * padding: not important\n  avg pooling should generate the same result as fractional avg pooling with:\n    * row_sequence = [0, 2, 4, 7]\n    * col_sequence = [0, 2, 4, 7]\n    * overlapping = True\n  2) Test through compute_gradient_error()\n  \"\"\"\n  _PRNG = np.random.RandomState(341261004)\n  _SEED = 341261005\n\n  def _GenerateRandomInputTensor(self, shape):\n    num_elements = 1\n    for dim_size in shape:\n      num_elements *= dim_size\n    x = self._PRNG.rand(num_elements) * 1000\n    return x.reshape(shape)\n\n  def testDirectNotUseOverlapping(self):\n    for num_batches in [1, 3]:\n      for row_window_size in [2, 5]:\n        for col_window_size in [2, 4]:\n          num_rows = row_window_size * 5\n          num_cols = col_window_size * 7\n          for num_channels in [1, 2]:\n            input_shape = (num_batches, num_rows, num_cols, num_channels)\n            with self.cached_session() as _:\n              input_tensor = constant_op.constant(\n                  self._GenerateRandomInputTensor(input_shape).astype(\n                      np.float32))\n              window_size = [1, row_window_size, col_window_size, 1]\n              stride_size = [1, row_window_size, col_window_size, 1]\n              padding = \"VALID\"\n              output_tensor = nn_ops.avg_pool(input_tensor, window_size,\n                                              stride_size, padding)\n              output_data = self.evaluate(output_tensor)\n              num_elements = 1\n              for dim_size in output_data.shape:\n                num_elements *= dim_size\n              output_backprop = (self._PRNG.rand(num_elements) *\n                                 1000).reshape(output_data.shape)\n              input_backprop_tensor = gen_nn_ops.avg_pool_grad(\n                  input_tensor.get_shape(), output_backprop, window_size,\n                  stride_size, padding)\n              input_backprop = self.evaluate(input_backprop_tensor)\n              row_seq = list(range(0, num_rows + 1, row_window_size))\n              col_seq = list(range(0, num_cols + 1, col_window_size))\n              fap_input_backprop_tensor = gen_nn_ops.fractional_avg_pool_grad(\n                  input_tensor.get_shape(),\n                  output_backprop,\n                  row_seq,\n                  col_seq,\n                  overlapping=False)\n              fap_input_backprop = self.evaluate(fap_input_backprop_tensor)\n              self.assertShapeEqual(input_backprop, fap_input_backprop_tensor)\n              self.assertAllClose(input_backprop, fap_input_backprop)\n\n  def testDirectUseOverlapping(self):\n    for num_batches in [1, 3]:\n      for row_window_size in [2, 5]:\n        for col_window_size in [2, 4]:\n          num_rows = (row_window_size - 1) * 5 + 1\n          num_cols = (col_window_size - 1) * 7 + 1\n          for num_channels in [1, 2]:\n            input_shape = (num_batches, num_rows, num_cols, num_channels)\n            with self.cached_session() as _:\n              input_tensor = constant_op.constant(\n                  self._GenerateRandomInputTensor(input_shape).astype(\n                      np.float32))\n              window_size = [1, row_window_size, col_window_size, 1]\n              stride_size = [1, row_window_size - 1, col_window_size - 1, 1]\n              padding = \"VALID\"\n              output_tensor = nn_ops.avg_pool(input_tensor, window_size,\n                                              stride_size, padding)\n              output_data = self.evaluate(output_tensor)\n              num_elements = 1\n              for dim_size in output_data.shape:\n                num_elements *= dim_size\n              output_backprop = (self._PRNG.rand(num_elements) *\n                                 1000).reshape(output_data.shape)\n              input_backprop_tensor = gen_nn_ops.avg_pool_grad(\n                  input_tensor.get_shape(), output_backprop, window_size,\n                  stride_size, padding)\n              input_backprop = self.evaluate(input_backprop_tensor)\n              row_seq = list(range(0, num_rows, row_window_size - 1))\n              col_seq = list(range(0, num_cols, col_window_size - 1))\n              row_seq[-1] += 1\n              col_seq[-1] += 1\n              fap_input_backprop_tensor = gen_nn_ops.fractional_avg_pool_grad(\n                  input_tensor.get_shape(),\n                  output_backprop,\n                  row_seq,\n                  col_seq,\n                  overlapping=True)\n              fap_input_backprop = self.evaluate(fap_input_backprop_tensor)\n              self.assertShapeEqual(input_backprop, fap_input_backprop_tensor)\n              self.assertAllClose(input_backprop, fap_input_backprop)\n\n  @test_util.run_deprecated_v1\n  def testAllInputOptionsThroughGradientError(self):\n    input_shape = (1, 7, 13, 1)\n    input_data = self._GenerateRandomInputTensor(input_shape)\n    pooling_ratio = [1, math.sqrt(2), math.sqrt(3), 1]\n\n    for pseudo_random in True, False:\n      for overlapping in True, False:\n        with self.cached_session() as _:\n          input_tensor = constant_op.constant(input_data, shape=input_shape)\n          output_tensor, unused_a, unused_b = nn_ops.fractional_avg_pool_v2(\n              input_tensor,\n              pooling_ratio,\n              pseudo_random=pseudo_random,\n              overlapping=overlapping,\n              seed=self._SEED)\n          output_data = self.evaluate(output_tensor)\n          output_shape = output_data.shape\n          # error_margin and delta setting is similar to avg_pool_grad.\n          error_margin = 1e-4\n          gradient_error = gradient_checker.compute_gradient_error(\n              input_tensor,\n              input_shape,\n              output_tensor,\n              output_shape,\n              x_init_value=input_data.reshape(input_shape),\n              delta=1e-2)\n          self.assertLess(gradient_error, error_margin)\n\n  @test_util.run_deprecated_v1\n  def testDifferentTensorShapesThroughGradientError(self):\n    pseudo_random = True\n    overlapping = True\n    pooling_ratio = [1, math.sqrt(3), math.sqrt(2), 1]\n    for num_batches in [1, 2]:\n      for num_rows in [5, 13]:\n        for num_cols in [5, 11]:\n          for num_channels in [1, 3]:\n            input_shape = (num_batches, num_rows, num_cols, num_channels)\n            input_data = self._GenerateRandomInputTensor(input_shape)\n            with self.cached_session() as _:\n              input_tensor = constant_op.constant(input_data, shape=input_shape)\n              output_tensor, unused_a, unused_b = nn_ops.fractional_avg_pool_v2(\n                  input_tensor,\n                  pooling_ratio,\n                  pseudo_random=pseudo_random,\n                  overlapping=overlapping,\n                  seed=self._SEED)\n              output_data = self.evaluate(output_tensor)\n              output_shape = output_data.shape\n              # error_margin and delta setting is similar to avg_pool_grad.\n              error_margin = 1e-4\n              gradient_error = gradient_checker.compute_gradient_error(\n                  input_tensor,\n                  input_shape,\n                  output_tensor,\n                  output_shape,\n                  x_init_value=input_data.reshape(input_shape),\n                  delta=1e-2)\n              self.assertLess(gradient_error, error_margin)\n\n  @test_util.run_deprecated_v1\n  def testLargePoolingRatioThroughGradientError(self):\n    input_shape = (1, 17, 23, 1)\n    input_data = self._GenerateRandomInputTensor(input_shape)\n    pooling_ratio = (1, math.sqrt(13), math.sqrt(7), 1)\n    output_shape = [int(a / b) for a, b in zip(input_shape, pooling_ratio)]\n    overlapping = True\n    pseudo_random = False\n\n    with self.cached_session() as _:\n      input_tensor = constant_op.constant(input_data, shape=input_shape)\n      output_tensor, unused_a, unused_b = nn_ops.fractional_avg_pool_v2(\n          input_tensor,\n          pooling_ratio,\n          pseudo_random=pseudo_random,\n          overlapping=overlapping,\n          seed=self._SEED)\n      # error_margin and delta setting is similar to avg_pool_grad.\n      error_margin = 1e-4\n      gradient_error = gradient_checker.compute_gradient_error(\n          input_tensor,\n          input_shape,\n          output_tensor,\n          output_shape,\n          x_init_value=input_data.reshape(input_shape),\n          delta=1e-2)\n      self.assertLess(gradient_error, error_margin)\n\n\nif __name__ == \"__main__\":\n  test.main()\n"], "fixing_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#define EIGEN_USE_THREADS\n\n#include <algorithm>\n#include <cmath>\n#include <random>\n#include <vector>\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/numeric_op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/kernels/fractional_pool_common.h\"\n#include \"tensorflow/core/lib/random/random.h\"\n#include \"tensorflow/core/platform/logging.h\"\n#include \"tensorflow/core/platform/mutex.h\"\n#include \"tensorflow/core/util/guarded_philox_random.h\"\n#include \"tensorflow/core/util/overflow.h\"\n\nnamespace tensorflow {\ntypedef Eigen::ThreadPoolDevice CPUDevice;\n\ntemplate <typename T>\nclass FractionalAvgPoolOp : public OpKernel {\n public:\n  explicit FractionalAvgPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\n                    \"pooling_ratio field must specify 4 dimensions\"));\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional average pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      // If both seeds are not set when deterministic_ is true, force set seeds.\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }\n\n  void Compute(OpKernelContext* context) override {\n    typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n        ConstEigenMatrixMap;\n    typedef Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n        EigenMatrixMap;\n\n    constexpr int tensor_in_and_out_dims = 4;\n\n    const Tensor& tensor_in = context->input(0);\n    OP_REQUIRES(context, tensor_in.dims() == tensor_in_and_out_dims,\n                errors::InvalidArgument(\"tensor_in must be 4-dimensional\"));\n\n    std::vector<int> input_size(tensor_in_and_out_dims);\n    std::vector<int> output_size(tensor_in_and_out_dims);\n    for (int i = 0; i < tensor_in_and_out_dims; ++i) {\n      input_size[i] = tensor_in.dim_size(i);\n      OP_REQUIRES(\n          context, pooling_ratio_[i] <= input_size[i],\n          errors::InvalidArgument(\n              \"Pooling ratio cannot be bigger than input tensor dim size.\"));\n    }\n    // Output size.\n    for (int i = 0; i < tensor_in_and_out_dims; ++i) {\n      output_size[i] =\n          static_cast<int>(std::floor(input_size[i] / pooling_ratio_[i]));\n      DCHECK_GT(output_size[i], 0);\n    }\n\n    // Generate pooling sequence.\n    std::vector<int64_t> row_cum_seq;\n    std::vector<int64_t> col_cum_seq;\n    GuardedPhiloxRandom generator;\n    generator.Init(seed_, seed2_);\n    row_cum_seq = GeneratePoolingSequence(input_size[1], output_size[1],\n                                          &generator, pseudo_random_);\n    col_cum_seq = GeneratePoolingSequence(input_size[2], output_size[2],\n                                          &generator, pseudo_random_);\n\n    // Prepare output.\n    Tensor* output_tensor = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                0,\n                                TensorShape({output_size[0], output_size[1],\n                                             output_size[2], output_size[3]}),\n                                &output_tensor));\n    Tensor* output_row_seq_tensor = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\n                     1, TensorShape({static_cast<int64_t>(row_cum_seq.size())}),\n                     &output_row_seq_tensor));\n    Tensor* output_col_seq_tensor = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\n                     2, TensorShape({static_cast<int64_t>(col_cum_seq.size())}),\n                     &output_col_seq_tensor));\n\n    ConstEigenMatrixMap in_mat(tensor_in.flat<T>().data(), input_size[3],\n                               input_size[2] * input_size[1] * input_size[0]);\n\n    EigenMatrixMap out_mat(output_tensor->flat<T>().data(), output_size[3],\n                           output_size[2] * output_size[1] * output_size[0]);\n    // out_count corresponds to number of elements in each pooling cell.\n    Eigen::Matrix<T, Eigen::Dynamic, 1> out_count(out_mat.cols());\n\n    // Initializes the output tensor and out_count with 0.\n    out_mat.setZero();\n    out_count.setZero();\n\n    auto output_row_seq_flat = output_row_seq_tensor->flat<int64_t>();\n    auto output_col_seq_flat = output_col_seq_tensor->flat<int64_t>();\n\n    // Set output tensors.\n    for (int i = 0; i < row_cum_seq.size(); ++i) {\n      output_row_seq_flat(i) = row_cum_seq[i];\n    }\n\n    for (int i = 0; i < col_cum_seq.size(); ++i) {\n      output_col_seq_flat(i) = col_cum_seq[i];\n    }\n\n    // For both input and output,\n    // 0: batch\n    // 1: row / row\n    // 2: col / col\n    // 3: depth / channel\n    const int64_t row_max = input_size[1] - 1;\n    const int64_t col_max = input_size[2] - 1;\n    for (int64_t b = 0; b < input_size[0]; ++b) {\n      // row sequence.\n      for (int64_t hs = 0; hs < row_cum_seq.size() - 1; ++hs) {\n        // row start and end.\n        const int64_t row_start = row_cum_seq[hs];\n        int64_t row_end =\n            overlapping_ ? row_cum_seq[hs + 1] : row_cum_seq[hs + 1] - 1;\n        row_end = std::min(row_end, row_max);\n\n        // col sequence.\n        for (int64_t ws = 0; ws < col_cum_seq.size() - 1; ++ws) {\n          const int64_t out_offset =\n              (b * output_size[1] + hs) * output_size[2] + ws;\n          // col start and end.\n          const int64_t col_start = col_cum_seq[ws];\n          int64_t col_end =\n              overlapping_ ? col_cum_seq[ws + 1] : col_cum_seq[ws + 1] - 1;\n          col_end = std::min(col_end, col_max);\n          for (int64_t h = row_start; h <= row_end; ++h) {\n            for (int64_t w = col_start; w <= col_end; ++w) {\n              const int64_t in_offset =\n                  (b * input_size[1] + h) * input_size[2] + w;\n              out_mat.col(out_offset) += in_mat.col(in_offset);\n              out_count(out_offset)++;\n            }\n          }\n        }\n      }\n    }\n    DCHECK_GT(out_count.minCoeff(), 0);\n    out_mat.array().rowwise() /= out_count.transpose().array();\n  }\n\n private:\n  bool deterministic_;\n  int64_t seed_;\n  int64_t seed2_;\n  std::vector<float> pooling_ratio_;\n  bool pseudo_random_;\n  bool overlapping_;\n};\n\n#define REGISTER_FRACTIONALAVGPOOL(type)                                      \\\n  REGISTER_KERNEL_BUILDER(                                                    \\\n      Name(\"FractionalAvgPool\").Device(DEVICE_CPU).TypeConstraint<type>(\"T\"), \\\n      FractionalAvgPoolOp<type>)\n\nREGISTER_FRACTIONALAVGPOOL(int32);\nREGISTER_FRACTIONALAVGPOOL(int64_t);\nREGISTER_FRACTIONALAVGPOOL(float);\nREGISTER_FRACTIONALAVGPOOL(double);\n\n#undef REGISTER_FRACTIONALAVGPOOL\n\ntemplate <class T>\nclass FractionalAvgPoolGradOp : public OpKernel {\n public:\n  explicit FractionalAvgPoolGradOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    // Here's the basic idea:\n    // Batch and depth dimension are independent from row and col dimension. And\n    // because FractionalAvgPool currently only support pooling along row and\n    // col, we can basically think of this 4D tensor backpropagation as\n    // operation of a series of 2D planes.\n    //\n    // For each element of a 'slice' (2D plane) of output_backprop, we need to\n    // figure out its contributors when doing FractionalAvgPool operation. This\n    // can be done based on row_pooling_sequence, col_pooling_seq and\n    // overlapping.\n    // Once we figure out the original contributors, we just need to evenly\n    // divide the value of this element among these contributors.\n    //\n    // Internally, we divide the out_backprop tensor and store it in a temporary\n    // tensor of double type. And cast it to the corresponding type.\n    typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n        ConstEigenMatrixMap;\n    typedef Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>\n        EigenDoubleMatrixMap;\n\n    // Grab the inputs.\n    const Tensor& orig_input_tensor_shape = context->input(0);\n    OP_REQUIRES(context,\n                orig_input_tensor_shape.dims() == 1 &&\n                    orig_input_tensor_shape.NumElements() == 4,\n                errors::InvalidArgument(\"original input tensor shape must be\"\n                                        \"1-dimensional and 4 elements\"));\n    int64_t num_elements = 1;\n    for (int i = 0; i < orig_input_tensor_shape.dims(); i++) {\n      OP_REQUIRES(context, orig_input_tensor_shape.dim_size(i) > 0,\n                  errors::InvalidArgument(\n                      \"orig_input_tensor_shape must be positive, got: \",\n                      orig_input_tensor_shape.dim_size(i)));\n      num_elements = MultiplyWithoutOverflow(\n          num_elements, orig_input_tensor_shape.dim_size(i));\n      OP_REQUIRES(\n          context, num_elements > 0,\n          errors::InvalidArgument(\n              \"The total elements specified by orig_input_tensor_shape\",\n              \" is too large. Encountered overflow after multiplying \",\n              orig_input_tensor_shape.dim_size(i), \", result: \", num_elements));\n    }\n\n    const Tensor& out_backprop = context->input(1);\n    OP_REQUIRES(context, out_backprop.dims() == 4,\n                errors::InvalidArgument(\"out_backprop must be 4-dimensional\"));\n    for (int i = 0; i < out_backprop.dims(); i++) {\n      OP_REQUIRES(context, out_backprop.dim_size(i) > 0,\n                  errors::InvalidArgument(\n                      \"out_backprop must be positive for all dimension, got:\",\n                      out_backprop.dim_size(i)));\n    }\n\n    const Tensor& row_seq_tensor = context->input(2);\n    const Tensor& col_seq_tensor = context->input(3);\n\n    const int64_t out_batch = out_backprop.dim_size(0);\n    const int64_t out_rows = out_backprop.dim_size(1);\n    const int64_t out_cols = out_backprop.dim_size(2);\n    const int64_t out_depth = out_backprop.dim_size(3);\n\n    OP_REQUIRES(context, row_seq_tensor.NumElements() > out_rows,\n                errors::InvalidArgument(\"Given out_backprop shape \",\n                                        out_backprop.shape().DebugString(),\n                                        \", row_seq_tensor must have at least \",\n                                        out_rows + 1, \" elements, but got \",\n                                        row_seq_tensor.NumElements()));\n    OP_REQUIRES(context, col_seq_tensor.NumElements() > out_cols,\n                errors::InvalidArgument(\"Given out_backprop shape \",\n                                        out_backprop.shape().DebugString(),\n                                        \", col_seq_tensor must have at least \",\n                                        out_cols + 1, \" elements, but got \",\n                                        col_seq_tensor.NumElements()));\n\n    auto row_seq_tensor_flat = row_seq_tensor.flat<int64_t>();\n    auto col_seq_tensor_flat = col_seq_tensor.flat<int64_t>();\n    auto orig_input_tensor_shape_flat = orig_input_tensor_shape.flat<int64_t>();\n\n    const int64_t in_batch = orig_input_tensor_shape_flat(0);\n    const int64_t in_rows = orig_input_tensor_shape_flat(1);\n    const int64_t in_cols = orig_input_tensor_shape_flat(2);\n    const int64_t in_depth = orig_input_tensor_shape_flat(3);\n    OP_REQUIRES(\n        context, in_batch != 0,\n        errors::InvalidArgument(\"Batch dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_rows != 0,\n        errors::InvalidArgument(\"Rows dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_cols != 0,\n        errors::InvalidArgument(\"Columns dimension of input must not be 0\"));\n    OP_REQUIRES(\n        context, in_depth != 0,\n        errors::InvalidArgument(\"Depth dimension of input must not be 0\"));\n\n    constexpr int tensor_in_and_out_dims = 4;\n    // Transform orig_input_tensor_shape into TensorShape\n    TensorShape in_shape;\n    for (auto i = 0; i < tensor_in_and_out_dims; ++i) {\n      in_shape.AddDim(orig_input_tensor_shape_flat(i));\n    }\n\n    // Create intermediate in_backprop.\n    Tensor in_backprop_tensor_temp;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp(\n                                {0}, DataTypeToEnum<double>::v(), in_shape,\n                                &in_backprop_tensor_temp));\n    in_backprop_tensor_temp.flat<double>().setZero();\n    // Transform 4D tensor to 2D matrix.\n    EigenDoubleMatrixMap in_backprop_tensor_temp_mat(\n        in_backprop_tensor_temp.flat<double>().data(), in_depth,\n        in_cols * in_rows * in_batch);\n    ConstEigenMatrixMap out_backprop_mat(out_backprop.flat<T>().data(),\n                                         out_depth,\n                                         out_cols * out_rows * out_batch);\n    // Loop through each element of out_backprop and evenly distribute the\n    // element to the corresponding pooling cell.\n    const int64_t in_max_row_index = in_rows - 1;\n    const int64_t in_max_col_index = in_cols - 1;\n    for (int64_t b = 0; b < out_batch; ++b) {\n      for (int64_t r = 0; r < out_rows; ++r) {\n        const int64_t in_row_start = row_seq_tensor_flat(r);\n\n        int64_t in_row_end = overlapping_ ? row_seq_tensor_flat(r + 1)\n                                          : row_seq_tensor_flat(r + 1) - 1;\n        in_row_end = std::min(in_row_end, in_max_row_index);\n        OP_REQUIRES(context, in_row_start >= 0 && in_row_end >= 0,\n                    errors::InvalidArgument(\n                        \"Row sequence tensor values must not be negative, got \",\n                        row_seq_tensor_flat));\n\n        for (int64_t c = 0; c < out_cols; ++c) {\n          const int64_t in_col_start = col_seq_tensor_flat(c);\n          int64_t in_col_end = overlapping_ ? col_seq_tensor_flat(c + 1)\n                                            : col_seq_tensor_flat(c + 1) - 1;\n          in_col_end = std::min(in_col_end, in_max_col_index);\n\n          OP_REQUIRES(\n              context, in_col_start >= 0 && in_col_end >= 0,\n              errors::InvalidArgument(\n                  \"Column sequence tensor values must not be negative, got \",\n                  col_seq_tensor_flat));\n          const int64_t num_elements_in_pooling_cell =\n              (in_row_end - in_row_start + 1) * (in_col_end - in_col_start + 1);\n          const int64_t out_index = (b * out_rows + r) * out_cols + c;\n          // Now we can evenly distribute out_backprop(b, h, w, *) to\n          // in_backprop(b, hs:he, ws:we, *).\n          for (int64_t in_r = in_row_start; in_r <= in_row_end; ++in_r) {\n            for (int64_t in_c = in_col_start; in_c <= in_col_end; ++in_c) {\n              const int64_t in_index = (b * in_rows + in_r) * in_cols + in_c;\n              // Walk through each channel (depth).\n              for (int64_t d = 0; d < out_depth; ++d) {\n                const double out_backprop_element = static_cast<double>(\n                    out_backprop_mat.coeffRef(d, out_index));\n                double& in_backprop_ref =\n                    in_backprop_tensor_temp_mat.coeffRef(d, in_index);\n                in_backprop_ref +=\n                    out_backprop_element / num_elements_in_pooling_cell;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Depending on the type, cast double to type T.\n    Tensor* in_backprop_tensor = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, in_shape, &in_backprop_tensor));\n    auto in_backprop_tensor_flat = in_backprop_tensor->flat<T>();\n    auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp.flat<double>();\n    for (int64_t i = 0; i < in_backprop_tensor_flat.size(); ++i) {\n      in_backprop_tensor_flat(i) =\n          static_cast<T>(in_backprop_tensor_temp_flat(i));\n    }\n  }\n\n private:\n  bool overlapping_;\n};\n\n#define REGISTER_FRACTIONALAVGPOOLGRAD(type)              \\\n  REGISTER_KERNEL_BUILDER(Name(\"FractionalAvgPoolGrad\")   \\\n                              .Device(DEVICE_CPU)         \\\n                              .TypeConstraint<type>(\"T\"), \\\n                          FractionalAvgPoolGradOp<type>)\n\nREGISTER_FRACTIONALAVGPOOLGRAD(int32);\nREGISTER_FRACTIONALAVGPOOLGRAD(int64_t);\nREGISTER_FRACTIONALAVGPOOLGRAD(float);\nREGISTER_FRACTIONALAVGPOOLGRAD(double);\n\n#undef REGISTER_FRACTIONALAVGPOOLGRAD\n}  // namespace tensorflow\n", "# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for fractional average pool operation.\"\"\"\n\nimport math\n\nimport numpy as np\n\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import gen_nn_ops\nfrom tensorflow.python.ops import gradient_checker\nfrom tensorflow.python.ops import nn_ops\nimport tensorflow.python.ops.nn_grad  # pylint: disable=unused-import\nfrom tensorflow.python.platform import test\n\n\nclass FractionalAvgTest(test.TestCase):\n\n  # Random number generate with seed.\n  _PRNG = np.random.RandomState(341261000)\n  _SEED = 341261001\n\n  def _AvgPoolAlongRows(self, input_matrix, row_seq, overlapping):\n    \"\"\"Perform average pool along row of a 2-D matrix based on row_seq.\n\n    Args:\n      input_matrix: A 2-D matrix.\n      row_seq: Cumulative pooling sequence along row.\n      overlapping: Whether or not use overlapping when pooling.\n\n    Returns:\n      A 2-D matrix, with\n        * num_rows = len(row_seq)-1\n        * num_cols = input_matrix.num_cols.\n    \"\"\"\n    output_image = np.zeros(input_matrix.shape[1])\n    row_max = row_seq[-1]\n    for i in range(row_seq.shape[0] - 1):\n      row_start = row_seq[i]\n      row_end = row_seq[i + 1] + 1 if overlapping else row_seq[i + 1]\n      row_end = min(row_end, row_max)\n      output_image = np.vstack((output_image, np.mean(\n          input_matrix[row_start:row_end, :], axis=0)))  # axis 0 is along row\n    # remove the sentinel row\n    return output_image[1:, :]\n\n  def _AvgPoolAlongCols(self, input_matrix, col_seq, overlapping):\n    \"\"\"Perform average pool along column of a 2-D matrix based on col_seq.\n\n    Args:\n      input_matrix: A 2-D matrix.\n      col_seq: Cumulative pooling sequence along column.\n      overlapping: Whether or not use overlapping when pooling.\n\n    Returns:\n      A 2-D matrix, with\n        * num_rows = input_matrix.num_rows\n        * num_cols = len(col_seq)-1.\n    \"\"\"\n    input_matrix = input_matrix.transpose()\n    output_matrix = self._AvgPoolAlongRows(input_matrix, col_seq, overlapping)\n    return output_matrix.transpose()\n\n  def _GetExpectedFractionalAvgPoolResult(self, input_tensor, row_seq, col_seq,\n                                          overlapping):\n    \"\"\"Get expected fractional average pooling result.\n\n    row_seq and col_seq together defines the fractional pooling region.\n\n    Args:\n      input_tensor: Original input tensor, assuming it is a 4-D tensor, with\n        dimension as [batch, height/row, width/column, channels/depth].\n      row_seq: Cumulative pooling sequence along row.\n      col_seq: Cumulative pooling sequence along column.\n      overlapping: Use overlapping when doing pooling.\n\n    Returns:\n      A 4-D tensor that is the result of average pooling on input_tensor based\n        on pooling region defined by row_seq and col_seq, conditioned on whether\n        or not overlapping is used.\n    \"\"\"\n    input_shape = input_tensor.shape\n    output_shape = (input_shape[0], len(row_seq) - 1, len(col_seq) - 1,\n                    input_shape[3])\n    output_tensor = np.zeros(shape=output_shape, dtype=input_tensor.dtype)\n    for batch in range(input_shape[0]):\n      for channel in range(input_shape[3]):\n        two_dim_slice = input_tensor[batch, :, :, channel]\n        tmp = self._AvgPoolAlongRows(two_dim_slice, row_seq, overlapping)\n        output_tensor[batch, :, :, channel] = self._AvgPoolAlongCols(\n            tmp, col_seq, overlapping)\n\n    return output_tensor\n\n  def _ValidateFractionalAvgPoolResult(self, input_tensor, pooling_ratio,\n                                       pseudo_random, overlapping):\n    \"\"\"Validate FractionalAvgPool's result against expected.\n\n    Expected result is computed given input_tensor, and pooling region defined\n    by row_seq and col_seq.\n\n    Args:\n      input_tensor: A tensor or numpy ndarray.\n      pooling_ratio: A list or tuple of length 4, first and last element be 1.\n      pseudo_random: Use pseudo random method to generate pooling sequence.\n      overlapping: Use overlapping when pooling.\n\n    Returns:\n      None\n    \"\"\"\n    with self.cached_session() as sess:\n      p, r, c = nn_ops.fractional_avg_pool_v2(\n          input_tensor,\n          pooling_ratio,\n          pseudo_random,\n          overlapping,\n          seed=self._SEED)\n      actual, row_seq, col_seq = self.evaluate([p, r, c])\n      expected = self._GetExpectedFractionalAvgPoolResult(input_tensor, row_seq,\n                                                          col_seq, overlapping)\n      self.assertShapeEqual(expected, p)\n      self.assertAllClose(expected, actual)\n\n  def _testVisually(self):\n    \"\"\"Manual test by printing out intermediate result of a small random tensor.\n\n    Since _GetExpectedFractionalAvgPoolResult is 'automated', it feels safer to\n    have a test case that you can see what's happening.\n    This test will generate a small, random, int 2D matrix, and feed it to\n    FractionalAvgPool and _GetExpectedFractionalAvgPoolResult.\n    \"\"\"\n    num_rows = 6\n    num_cols = 6\n    tensor_shape = (1, num_rows, num_cols, 1)\n    pseudo_random = False\n    for overlapping in True, False:\n      print(\"-\" * 70)\n      print(\"Testing FractionalAvgPool with overlapping = {}\".format(\n          overlapping))\n      rand_mat = self._PRNG.randint(10, size=tensor_shape)\n      pooling_ratio = [1, math.sqrt(2), math.sqrt(2), 1]\n      with self.cached_session() as sess:\n        p, r, c = nn_ops.fractional_avg_pool_v2(\n            rand_mat.astype(np.float32),\n            pooling_ratio,\n            pseudo_random,\n            overlapping,\n            seed=self._SEED)\n        tensor_output, row_seq, col_seq = self.evaluate([p, r, c])\n        expected_result = self._GetExpectedFractionalAvgPoolResult(\n            rand_mat.astype(np.float32), row_seq, col_seq, overlapping)\n        print(\"row sequence:\")\n        print(row_seq)\n        print(\"column sequence:\")\n        print(col_seq)\n\n        print(\"Input:\")\n        # Print input with pooling region marked.\n        for i in range(num_rows):\n          row_to_print = []\n          for j in range(num_cols):\n            if j in col_seq:\n              row_to_print.append(\"|\")\n            row_to_print.append(str(rand_mat[0, i, j, 0]))\n          row_to_print.append(\"|\")\n          if i in row_seq:\n            print(\"-\" * 2 * len(row_to_print))\n          print(\" \".join(row_to_print))\n        print(\"-\" * 2 * len(row_to_print))\n\n        print(\"Output from FractionalAvgPool:\")\n        print(tensor_output[0, :, :, 0])\n        print(\"Expected result:\")\n        print(expected_result[0, :, :, 0])\n\n  def testAllInputOptions(self):\n    \"\"\"Try all possible input options for fractional_avg_pool.\n    \"\"\"\n    num_batches = 5\n    num_channels = 3\n    num_rows = 20\n    num_cols = 30\n    for pseudo_random in True, False:\n      for overlapping in True, False:\n        tensor_shape = (num_batches, num_rows, num_cols, num_channels)\n        # random tensor with value in [-500.0, 500.0)\n        rand_mat = self._PRNG.random_sample(tensor_shape) * 1000 - 500\n        self._ValidateFractionalAvgPoolResult(\n            rand_mat, [1, math.sqrt(3), math.sqrt(2), 1], pseudo_random,\n            overlapping)\n\n  def testIntegerTensorInput(self):\n    \"\"\"Test FractionalAvgPool works fine when input tensor is integer type.\n    \"\"\"\n    pseudo_random = True\n    overlapping = True\n    tensor_shape = (1, 6, 6, 1)\n    # pyformat: disable\n    mat = np.array([\n        [2, 6, 4, 1, 3, 6],\n        [8, 9, 1, 6, 6, 8],\n        [3, 9, 8, 2, 5, 6],\n        [2, 7, 9, 5, 4, 5],\n        [8, 5, 0, 5, 7, 4],\n        [4, 4, 5, 9, 7, 2]\n    ])\n    # pyformat: enable\n    self._ValidateFractionalAvgPoolResult(mat.reshape(tensor_shape),\n                                          [1, math.sqrt(3), math.sqrt(2), 1],\n                                          pseudo_random, overlapping)\n\n  def testDifferentTensorShapes(self):\n    \"\"\"Test different shapes of input tensor.\n\n    Mainly test different combinations of num_rows and num_cols.\n    \"\"\"\n    pseudo_random = True\n    overlapping = True\n    for num_batches in [1, 3]:\n      for num_channels in [1, 3]:\n        for num_rows in [10, 20, 50]:\n          for num_cols in [10, 20, 50]:\n            tensor_shape = (num_batches, num_rows, num_cols, num_channels)\n            # random tensor with value in [-500.0, 500.0)\n            rand_mat = self._PRNG.random_sample(tensor_shape) * 1000 - 500\n            self._ValidateFractionalAvgPoolResult(\n                rand_mat, [1, math.sqrt(3), math.sqrt(2), 1], pseudo_random,\n                overlapping)\n\n  def testLargePoolingRatio(self):\n    \"\"\"Test when pooling ratio is not within [1, 2).\n    \"\"\"\n    pseudo_random = True\n    overlapping = True\n    num_batches = 3\n    num_channels = 3\n    num_rows = 30\n    num_cols = 50\n    tensor_shape = (num_batches, num_rows, num_cols, num_channels)\n    for row_ratio in [math.sqrt(11), math.sqrt(37)]:\n      for col_ratio in [math.sqrt(11), math.sqrt(27)]:\n        # random tensor with value in [-500.0, 500.0)\n        rand_mat = self._PRNG.random_sample(tensor_shape) * 1000 - 500\n        self._ValidateFractionalAvgPoolResult(rand_mat,\n                                              [1, row_ratio, col_ratio, 1],\n                                              pseudo_random, overlapping)\n\n  def testDivisiblePoolingRatio(self):\n    \"\"\"Test when num of rows/cols can evenly divide pooling ratio.\n\n    This is a case regular average pooling can handle. Should be handled by\n    fractional pooling as well.\n    \"\"\"\n    pseudo_random = True\n    overlapping = True\n    num_batches = 3\n    num_channels = 3\n    num_rows = 30\n    num_cols = 50\n    tensor_shape = (num_batches, num_rows, num_cols, num_channels)\n    # random tensor with value in [-500.0, 500.0)\n    rand_mat = self._PRNG.random_sample(tensor_shape) * 1000 - 500\n    self._ValidateFractionalAvgPoolResult(rand_mat, [1, 2, 2, 1], pseudo_random,\n                                          overlapping)\n\n  @test_util.run_deprecated_v1\n  def testDifferentInputTensorShape(self):\n    \"\"\"Runs the operation in one session with different input tensor shapes.\"\"\"\n    with self.cached_session() as sess:\n      input_holder = array_ops.placeholder(dtypes.float32,\n                                           [None, None, None, 3])\n      pooling_ratio = [1, 1.5, 1.5, 1]\n      pseudo_random = False\n      overlapping = False\n      p, r, c = nn_ops.fractional_avg_pool_v2(\n          input_holder,\n          pooling_ratio,\n          pseudo_random,\n          overlapping,\n          seed=self._SEED)\n      # First run.\n      input_a = np.zeros([3, 32, 32, 3])\n      actual, row_seq, col_seq = sess.run([p, r, c], {input_holder: input_a})\n      expected = self._GetExpectedFractionalAvgPoolResult(\n          input_a, row_seq, col_seq, overlapping)\n      self.assertSequenceEqual(expected.shape, actual.shape)\n      # Second run.\n      input_b = np.zeros([4, 60, 60, 3])\n      actual, row_seq, col_seq = sess.run([p, r, c], {input_holder: input_b})\n      expected = self._GetExpectedFractionalAvgPoolResult(\n          input_b, row_seq, col_seq, overlapping)\n      self.assertSequenceEqual(expected.shape, actual.shape)\n\n  def testNegativeSeqValuesForGradOp(self):\n    with self.assertRaisesRegex(\n        errors.InvalidArgumentError,\n        r\"Row sequence tensor values must not be negative.*\"):\n      y = nn_ops.gen_nn_ops.fractional_avg_pool_grad(\n          orig_input_tensor_shape=[2, 2, 2, 2],\n          out_backprop=[[[[1, 2], [3, 4], [5, 6]], [[7, 8], [9, 10], [11,\n                                                                      12]]]],\n          row_pooling_sequence=[-10, 1, 2, 3],\n          col_pooling_sequence=[1, 2, 3, 4],\n          overlapping=True)\n\n      self.evaluate(y)\n      with self.assertRaisesRegex(\n          errors.InvalidArgumentError,\n          r\"Column sequence tensor values must not be negative.*\"):\n        z = nn_ops.gen_nn_ops.fractional_avg_pool_grad(\n            orig_input_tensor_shape=[2, 2, 2, 2],\n            out_backprop=[[[[1, 2], [3, 4], [5, 6]], [[7, 8], [9, 10], [11,\n                                                                        12]]]],\n            row_pooling_sequence=[10, 1, 2, 3],\n            col_pooling_sequence=[1, 2, -3, 4],\n            overlapping=True)\n\n        self.evaluate(z)\n\n\nclass FractionalAvgPoolGradTest(test.TestCase):\n  \"\"\"Tests for FractionalAvgPoolGrad.\n\n  Two types of tests for FractionalAvgPoolGrad.\n  1) Test fractional_avg_pool_grad() directly.\n    This type of test relies on gen_nn_ops.avg_pool_grad() returns the\n  correct result. For example:\n    * input_tensor_shape = (1, 10, 10, 1)\n    * window_size = (1, 2, 2, 1)\n    * stride_size = (1, 2, 2, 1)\n    * padding: not really important, since 10/2 is divisible\n  avg pooling should generate the same result as fractional avg pooling with:\n    * row_sequence = [0, 2, 4, 6, 8, 10]\n    * col_sequence = [0, 2, 4, 6, 8, 10]\n    * overlapping = False\n  This also means their gradients in such case will be the same.\n\n  Similarly, when\n    * input_tensor_shape = (1, 7, 7, 1)\n    * window_size = (1, 3, 3, 1)\n    * stride_size = (1, 2, 2, 1)\n    * padding: not important\n  avg pooling should generate the same result as fractional avg pooling with:\n    * row_sequence = [0, 2, 4, 7]\n    * col_sequence = [0, 2, 4, 7]\n    * overlapping = True\n  2) Test through compute_gradient_error()\n  \"\"\"\n  _PRNG = np.random.RandomState(341261004)\n  _SEED = 341261005\n\n  def _GenerateRandomInputTensor(self, shape):\n    num_elements = 1\n    for dim_size in shape:\n      num_elements *= dim_size\n    x = self._PRNG.rand(num_elements) * 1000\n    return x.reshape(shape)\n\n  def testDirectNotUseOverlapping(self):\n    for num_batches in [1, 3]:\n      for row_window_size in [2, 5]:\n        for col_window_size in [2, 4]:\n          num_rows = row_window_size * 5\n          num_cols = col_window_size * 7\n          for num_channels in [1, 2]:\n            input_shape = (num_batches, num_rows, num_cols, num_channels)\n            with self.cached_session() as _:\n              input_tensor = constant_op.constant(\n                  self._GenerateRandomInputTensor(input_shape).astype(\n                      np.float32))\n              window_size = [1, row_window_size, col_window_size, 1]\n              stride_size = [1, row_window_size, col_window_size, 1]\n              padding = \"VALID\"\n              output_tensor = nn_ops.avg_pool(input_tensor, window_size,\n                                              stride_size, padding)\n              output_data = self.evaluate(output_tensor)\n              num_elements = 1\n              for dim_size in output_data.shape:\n                num_elements *= dim_size\n              output_backprop = (self._PRNG.rand(num_elements) *\n                                 1000).reshape(output_data.shape)\n              input_backprop_tensor = gen_nn_ops.avg_pool_grad(\n                  input_tensor.get_shape(), output_backprop, window_size,\n                  stride_size, padding)\n              input_backprop = self.evaluate(input_backprop_tensor)\n              row_seq = list(range(0, num_rows + 1, row_window_size))\n              col_seq = list(range(0, num_cols + 1, col_window_size))\n              fap_input_backprop_tensor = gen_nn_ops.fractional_avg_pool_grad(\n                  input_tensor.get_shape(),\n                  output_backprop,\n                  row_seq,\n                  col_seq,\n                  overlapping=False)\n              fap_input_backprop = self.evaluate(fap_input_backprop_tensor)\n              self.assertShapeEqual(input_backprop, fap_input_backprop_tensor)\n              self.assertAllClose(input_backprop, fap_input_backprop)\n\n  def testDirectUseOverlapping(self):\n    for num_batches in [1, 3]:\n      for row_window_size in [2, 5]:\n        for col_window_size in [2, 4]:\n          num_rows = (row_window_size - 1) * 5 + 1\n          num_cols = (col_window_size - 1) * 7 + 1\n          for num_channels in [1, 2]:\n            input_shape = (num_batches, num_rows, num_cols, num_channels)\n            with self.cached_session() as _:\n              input_tensor = constant_op.constant(\n                  self._GenerateRandomInputTensor(input_shape).astype(\n                      np.float32))\n              window_size = [1, row_window_size, col_window_size, 1]\n              stride_size = [1, row_window_size - 1, col_window_size - 1, 1]\n              padding = \"VALID\"\n              output_tensor = nn_ops.avg_pool(input_tensor, window_size,\n                                              stride_size, padding)\n              output_data = self.evaluate(output_tensor)\n              num_elements = 1\n              for dim_size in output_data.shape:\n                num_elements *= dim_size\n              output_backprop = (self._PRNG.rand(num_elements) *\n                                 1000).reshape(output_data.shape)\n              input_backprop_tensor = gen_nn_ops.avg_pool_grad(\n                  input_tensor.get_shape(), output_backprop, window_size,\n                  stride_size, padding)\n              input_backprop = self.evaluate(input_backprop_tensor)\n              row_seq = list(range(0, num_rows, row_window_size - 1))\n              col_seq = list(range(0, num_cols, col_window_size - 1))\n              row_seq[-1] += 1\n              col_seq[-1] += 1\n              fap_input_backprop_tensor = gen_nn_ops.fractional_avg_pool_grad(\n                  input_tensor.get_shape(),\n                  output_backprop,\n                  row_seq,\n                  col_seq,\n                  overlapping=True)\n              fap_input_backprop = self.evaluate(fap_input_backprop_tensor)\n              self.assertShapeEqual(input_backprop, fap_input_backprop_tensor)\n              self.assertAllClose(input_backprop, fap_input_backprop)\n\n  @test_util.run_deprecated_v1\n  def testAllInputOptionsThroughGradientError(self):\n    input_shape = (1, 7, 13, 1)\n    input_data = self._GenerateRandomInputTensor(input_shape)\n    pooling_ratio = [1, math.sqrt(2), math.sqrt(3), 1]\n\n    for pseudo_random in True, False:\n      for overlapping in True, False:\n        with self.cached_session() as _:\n          input_tensor = constant_op.constant(input_data, shape=input_shape)\n          output_tensor, unused_a, unused_b = nn_ops.fractional_avg_pool_v2(\n              input_tensor,\n              pooling_ratio,\n              pseudo_random=pseudo_random,\n              overlapping=overlapping,\n              seed=self._SEED)\n          output_data = self.evaluate(output_tensor)\n          output_shape = output_data.shape\n          # error_margin and delta setting is similar to avg_pool_grad.\n          error_margin = 1e-4\n          gradient_error = gradient_checker.compute_gradient_error(\n              input_tensor,\n              input_shape,\n              output_tensor,\n              output_shape,\n              x_init_value=input_data.reshape(input_shape),\n              delta=1e-2)\n          self.assertLess(gradient_error, error_margin)\n\n  @test_util.run_deprecated_v1\n  def testDifferentTensorShapesThroughGradientError(self):\n    pseudo_random = True\n    overlapping = True\n    pooling_ratio = [1, math.sqrt(3), math.sqrt(2), 1]\n    for num_batches in [1, 2]:\n      for num_rows in [5, 13]:\n        for num_cols in [5, 11]:\n          for num_channels in [1, 3]:\n            input_shape = (num_batches, num_rows, num_cols, num_channels)\n            input_data = self._GenerateRandomInputTensor(input_shape)\n            with self.cached_session() as _:\n              input_tensor = constant_op.constant(input_data, shape=input_shape)\n              output_tensor, unused_a, unused_b = nn_ops.fractional_avg_pool_v2(\n                  input_tensor,\n                  pooling_ratio,\n                  pseudo_random=pseudo_random,\n                  overlapping=overlapping,\n                  seed=self._SEED)\n              output_data = self.evaluate(output_tensor)\n              output_shape = output_data.shape\n              # error_margin and delta setting is similar to avg_pool_grad.\n              error_margin = 1e-4\n              gradient_error = gradient_checker.compute_gradient_error(\n                  input_tensor,\n                  input_shape,\n                  output_tensor,\n                  output_shape,\n                  x_init_value=input_data.reshape(input_shape),\n                  delta=1e-2)\n              self.assertLess(gradient_error, error_margin)\n\n  @test_util.run_deprecated_v1\n  def testLargePoolingRatioThroughGradientError(self):\n    input_shape = (1, 17, 23, 1)\n    input_data = self._GenerateRandomInputTensor(input_shape)\n    pooling_ratio = (1, math.sqrt(13), math.sqrt(7), 1)\n    output_shape = [int(a / b) for a, b in zip(input_shape, pooling_ratio)]\n    overlapping = True\n    pseudo_random = False\n\n    with self.cached_session() as _:\n      input_tensor = constant_op.constant(input_data, shape=input_shape)\n      output_tensor, unused_a, unused_b = nn_ops.fractional_avg_pool_v2(\n          input_tensor,\n          pooling_ratio,\n          pseudo_random=pseudo_random,\n          overlapping=overlapping,\n          seed=self._SEED)\n      # error_margin and delta setting is similar to avg_pool_grad.\n      error_margin = 1e-4\n      gradient_error = gradient_checker.compute_gradient_error(\n          input_tensor,\n          input_shape,\n          output_tensor,\n          output_shape,\n          x_init_value=input_data.reshape(input_shape),\n          delta=1e-2)\n      self.assertLess(gradient_error, error_margin)\n\n  def testInvalidSeqRaiseErrorForFractionalAvgPoolGrad(self):\n    with self.assertRaises((errors.InvalidArgumentError, ValueError)):\n      with self.cached_session() as _:\n        overlapping = True\n        orig_input_tensor_shape = constant_op.constant(\n            -1879048192, shape=[4], dtype=dtypes.int64)\n        out_backprop = constant_op.constant([],\n                                            shape=[0, 0, 0, 0],\n                                            dtype=dtypes.float64)\n        row_pooling_sequence = constant_op.constant(\n            1, shape=[4], dtype=dtypes.int64)\n        col_pooling_sequence = constant_op.constant(\n            1, shape=[4], dtype=dtypes.int64)\n        t = gen_nn_ops.fractional_avg_pool_grad(\n            orig_input_tensor_shape=orig_input_tensor_shape,\n            out_backprop=out_backprop,\n            row_pooling_sequence=row_pooling_sequence,\n            col_pooling_sequence=col_pooling_sequence,\n            overlapping=overlapping)\n        self.evaluate(t)\n\n\nif __name__ == \"__main__\":\n  test.main()\n"], "filenames": ["tensorflow/core/kernels/fractional_avg_pool_op.cc", "tensorflow/python/kernel_tests/nn_ops/fractional_avg_pool_op_test.py"], "buggy_code_start_loc": [14, 543], "buggy_code_end_loc": [244, 543], "fixing_code_start_loc": [15, 544], "fixing_code_end_loc": [271, 565], "type": "CWE-617", "message": "TensorFlow is an open source platform for machine learning. The implementation of `FractionalAvgPoolGrad` does not fully validate the input `orig_input_tensor_shape`. This results in an overflow that results in a `CHECK` failure which can be used to trigger a denial of service attack. We have patched the issue in GitHub commit 03a659d7be9a1154fdf5eeac221e5950fec07dad. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-35963", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-16T20:15:10.640", "lastModified": "2022-09-21T16:35:47.377", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. The implementation of `FractionalAvgPoolGrad` does not fully validate the input `orig_input_tensor_shape`. This results in an overflow that results in a `CHECK` failure which can be used to trigger a denial of service attack. We have patched the issue in GitHub commit 03a659d7be9a1154fdf5eeac221e5950fec07dad. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto para el aprendizaje autom\u00e1tico. La implementaci\u00f3n de \"FractionalAvgPoolGrad\" no comprueba completamente la entrada \"orig_input_tensor_shape\". Esto resulta en un desbordamiento que resulta en un fallo de \"CHECK\" que puede ser usado para desencadenar un ataque de denegaci\u00f3n de servicio. Hemos parcheado el problema en el commit 03a659d7be9a1154fdf5eeac221e5950fec07dad de GitHub. La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.10.0. Tambi\u00e9n seleccionaremos este compromiso en TensorFlow versi\u00f3n 2.9.1, TensorFlow versi\u00f3n 2.8.1, y TensorFlow versi\u00f3n 2.7.2, ya que estos tambi\u00e9n est\u00e1n afectados y todav\u00eda est\u00e1n en el rango admitido. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.7.0", "versionEndExcluding": "2.7.2", "matchCriteriaId": "C4DFBF2D-5283-42F6-8800-D653BFA5CE82"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C3684238-B1B8-4134-9FED-8A3733E1F39B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "08DF9052-55EF-4B54-94C6-EC9B4FC87DE1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc0:*:*:*:*:*:*", "matchCriteriaId": "1DBFBCE2-0A01-4575-BE45-6775ABFB8B28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc1:*:*:*:*:*:*", "matchCriteriaId": "89806CF9-E423-4CA6-A01A-8175C260CB24"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc2:*:*:*:*:*:*", "matchCriteriaId": "F2B80690-A257-4E16-BD27-9AE045BC56ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc3:*:*:*:*:*:*", "matchCriteriaId": "F335F9A4-5AB8-4E53-BC18-E01F7C653E5E"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/03a659d7be9a1154fdf5eeac221e5950fec07dad", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-84jm-4cf3-9jfm", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/03a659d7be9a1154fdf5eeac221e5950fec07dad"}}