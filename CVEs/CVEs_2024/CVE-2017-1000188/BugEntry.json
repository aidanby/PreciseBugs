{"buggy_code": ["/*\n * EJS Embedded JavaScript templates\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\n'use strict';\n\n/**\n * @file Embedded JavaScript templating engine.\n * @author Matthew Eernisse <mde@fleegix.org>\n * @author Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\n * @project EJS\n * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}\n */\n\n/**\n * EJS internal functions.\n *\n * Technically this \"module\" lies in the same file as {@link module:ejs}, for\n * the sake of organization all the private functions re grouped into this\n * module.\n *\n * @module ejs-internal\n * @private\n */\n\n/**\n * Embedded JavaScript templating engine.\n *\n * @module ejs\n * @public\n */\n\nvar fs = require('fs');\nvar path = require('path');\nvar utils = require('./utils');\n\nvar scopeOptionWarned = false;\nvar _VERSION_STRING = require('../package.json').version;\nvar _DEFAULT_DELIMITER = '%';\nvar _DEFAULT_LOCALS_NAME = 'locals';\nvar _REGEX_STRING = '(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)';\nvar _OPTS = [ 'cache', 'filename', 'delimiter', 'scope', 'context',\n        'debug', 'compileDebug', 'client', '_with', 'root', 'rmWhitespace',\n        'strict', 'localsName'];\nvar _BOM = /^\\uFEFF/;\n\n/**\n * EJS template function cache. This can be a LRU object from lru-cache NPM\n * module. By default, it is {@link module:utils.cache}, a simple in-process\n * cache that grows continuously.\n *\n * @type {Cache}\n */\n\nexports.cache = utils.cache;\n\n/**\n * Name of the object containing the locals.\n *\n * This variable is overridden by {@link Options}`.localsName` if it is not\n * `undefined`.\n *\n * @type {String}\n * @public\n */\n\nexports.localsName = _DEFAULT_LOCALS_NAME;\n\n/**\n * Get the path to the included file from the parent file path and the\n * specified path.\n *\n * @param {String}  name     specified path\n * @param {String}  filename parent file path\n * @param {Boolean} isDir    parent file path whether is directory\n * @return {String}\n */\nexports.resolveInclude = function(name, filename, isDir) {\n  var dirname = path.dirname;\n  var extname = path.extname;\n  var resolve = path.resolve;\n  var includePath = resolve(isDir ? filename : dirname(filename), name);\n  var ext = extname(name);\n  if (!ext) {\n    includePath += '.ejs';\n  }\n  return includePath;\n};\n\n/**\n * Get the path to the included file by Options\n *\n * @param  {String}  path    specified path\n * @param  {Options} options compilation options\n * @return {String}\n */\nfunction getIncludePath(path, options){\n  var includePath;\n  if (path.charAt(0) == '/') {\n    includePath = exports.resolveInclude(path.replace(/^\\/*/,''), options.root || '/', true);\n  }\n  else {\n    if (!options.filename) {\n      throw new Error('`include` use relative path requires the \\'filename\\' option.');\n    }\n    includePath = exports.resolveInclude(path, options.filename);\n  }\n  return includePath;\n}\n\n/**\n * Get the template from a string or a file, either compiled on-the-fly or\n * read from cache (if enabled), and cache the template if needed.\n *\n * If `template` is not set, the file specified in `options.filename` will be\n * read.\n *\n * If `options.cache` is true, this function reads the file from\n * `options.filename` so it must be set prior to calling this function.\n *\n * @memberof module:ejs-internal\n * @param {Options} options   compilation options\n * @param {String} [template] template source\n * @return {(TemplateFunction|ClientFunction)}\n * Depending on the value of `options.client`, either type might be returned.\n * @static\n */\n\nfunction handleCache(options, template) {\n  var func;\n  var filename = options.filename;\n  var hasTemplate = arguments.length > 1;\n\n  if (options.cache) {\n    if (!filename) {\n      throw new Error('cache option requires a filename');\n    }\n    func = exports.cache.get(filename);\n    if (func) {\n      return func;\n    }\n    if (!hasTemplate) {\n      template = fs.readFileSync(filename).toString().replace(_BOM, '');\n    }\n  }\n  else if (!hasTemplate) {\n    // istanbul ignore if: should not happen at all\n    if (!filename) {\n      throw new Error('Internal EJS error: no file name or template '\n                    + 'provided');\n    }\n    template = fs.readFileSync(filename).toString().replace(_BOM, '');\n  }\n  func = exports.compile(template, options);\n  if (options.cache) {\n    exports.cache.set(filename, func);\n  }\n  return func;\n}\n\n/**\n * Get the template function.\n *\n * If `options.cache` is `true`, then the template is cached.\n *\n * @memberof module:ejs-internal\n * @param {String}  path    path for the specified file\n * @param {Options} options compilation options\n * @return {(TemplateFunction|ClientFunction)}\n * Depending on the value of `options.client`, either type might be returned\n * @static\n */\n\nfunction includeFile(path, options) {\n  var opts = utils.shallowCopy({}, options);\n  opts.filename = getIncludePath(path, opts);\n  return handleCache(opts);\n}\n\n/**\n * Get the JavaScript source of an included file.\n *\n * @memberof module:ejs-internal\n * @param {String}  path    path for the specified file\n * @param {Options} options compilation options\n * @return {Object}\n * @static\n */\n\nfunction includeSource(path, options) {\n  var opts = utils.shallowCopy({}, options);\n  var includePath;\n  var template;\n  includePath = getIncludePath(path,opts);\n  template = fs.readFileSync(includePath).toString().replace(_BOM, '');\n  opts.filename = includePath;\n  var templ = new Template(template, opts);\n  templ.generateSource();\n  return {\n    source: templ.source,\n    filename: includePath,\n    template: template\n  };\n}\n\n/**\n * Re-throw the given `err` in context to the `str` of ejs, `filename`, and\n * `lineno`.\n *\n * @implements RethrowCallback\n * @memberof module:ejs-internal\n * @param {Error}  err      Error object\n * @param {String} str      EJS source\n * @param {String} filename file name of the EJS file\n * @param {String} lineno   line number of the error\n * @static\n */\n\nfunction rethrow(err, str, filename, lineno){\n  var lines = str.split('\\n');\n  var start = Math.max(lineno - 3, 0);\n  var end = Math.min(lines.length, lineno + 3);\n  // Error context\n  var context = lines.slice(start, end).map(function (line, i){\n    var curr = i + start + 1;\n    return (curr == lineno ? ' >> ' : '    ')\n      + curr\n      + '| '\n      + line;\n  }).join('\\n');\n\n  // Alter exception message\n  err.path = filename;\n  err.message = (filename || 'ejs') + ':'\n    + lineno + '\\n'\n    + context + '\\n\\n'\n    + err.message;\n\n  throw err;\n}\n\n/**\n * Copy properties in data object that are recognized as options to an\n * options object.\n *\n * This is used for compatibility with earlier versions of EJS and Express.js.\n *\n * @memberof module:ejs-internal\n * @param {Object}  data data object\n * @param {Options} opts options object\n * @static\n */\n\nfunction cpOptsInData(data, opts) {\n  _OPTS.forEach(function (p) {\n    if (typeof data[p] != 'undefined') {\n      // Disallow setting the root opt for includes via a passed data obj\n      // Unsanitized, parameterized use of `render` could allow the\n      // include directory to be reset, opening up the possibility of\n      // remote code execution\n      if (p == 'root') {\n        return;\n      }\n      opts[p] = data[p];\n    }\n  });\n}\n\nfunction stripSemi(str) {\n  return str.replace(/;(\\s*$)/, '$1');\n}\n\n/**\n * Compile the given `str` of ejs into a template function.\n *\n * @param {String}  template EJS template\n *\n * @param {Options} opts     compilation options\n *\n * @return {(TemplateFunction|ClientFunction)}\n * Depending on the value of `opts.client`, either type might be returned.\n * @public\n */\n\nexports.compile = function compile(template, opts) {\n  var templ;\n\n  // v1 compat\n  // 'scope' is 'context'\n  // FIXME: Remove this in a future version\n  if (opts && opts.scope) {\n    if (!scopeOptionWarned){\n      console.warn('`scope` option is deprecated and will be removed in EJS 3');\n      scopeOptionWarned = true;\n    }\n    if (!opts.context) {\n      opts.context = opts.scope;\n    }\n    delete opts.scope;\n  }\n  templ = new Template(template, opts);\n  return templ.compile();\n};\n\n/**\n * Render the given `template` of ejs.\n *\n * If you would like to include options but not data, you need to explicitly\n * call this function with `data` being an empty object or `null`.\n *\n * @param {String}   template EJS template\n * @param {Object}  [data={}] template data\n * @param {Options} [opts={}] compilation and rendering options\n * @return {String}\n * @public\n */\n\nexports.render = function (template, d, o) {\n  var data = d || {};\n  var opts = o || {};\n\n  // No options object -- if there are optiony names\n  // in the data, copy them to options\n  if (arguments.length == 2) {\n    cpOptsInData(data, opts);\n  }\n\n  return handleCache(opts, template)(data);\n};\n\n/**\n * Render an EJS file at the given `path` and callback `cb(err, str)`.\n *\n * If you would like to include options but not data, you need to explicitly\n * call this function with `data` being an empty object or `null`.\n *\n * @param {String}             path     path to the EJS file\n * @param {Object}            [data={}] template data\n * @param {Options}           [opts={}] compilation and rendering options\n * @param {RenderFileCallback} cb callback\n * @public\n */\n\nexports.renderFile = function () {\n  var args = Array.prototype.slice.call(arguments);\n  var filename = args.shift();\n  var cb = args.pop();\n  var data = args.shift() || {};\n  var opts = args.pop() || {};\n  var result;\n\n  // Don't pollute passed in opts obj with new vals\n  opts = utils.shallowCopy({}, opts);\n\n  // No options object -- if there are optiony names\n  // in the data, copy them to options\n  if (arguments.length == 3) {\n    // Express 4\n    if (data.settings && data.settings['view options']) {\n      cpOptsInData(data.settings['view options'], opts);\n    }\n    // Express 3 and lower\n    else {\n      cpOptsInData(data, opts);\n    }\n  }\n  opts.filename = filename;\n\n  try {\n    result = handleCache(opts)(data);\n  }\n  catch(err) {\n    return cb(err);\n  }\n  return cb(null, result);\n};\n\n/**\n * Clear intermediate JavaScript cache. Calls {@link Cache#reset}.\n * @public\n */\n\nexports.clearCache = function () {\n  exports.cache.reset();\n};\n\nfunction Template(text, opts) {\n  opts = opts || {};\n  var options = {};\n  this.templateText = text;\n  this.mode = null;\n  this.truncate = false;\n  this.currentLine = 1;\n  this.source = '';\n  this.dependencies = [];\n  options.client = opts.client || false;\n  options.escapeFunction = opts.escape || utils.escapeXML;\n  options.compileDebug = opts.compileDebug !== false;\n  options.debug = !!opts.debug;\n  options.filename = opts.filename;\n  options.delimiter = opts.delimiter || exports.delimiter || _DEFAULT_DELIMITER;\n  options.strict = opts.strict || false;\n  options.context = opts.context;\n  options.cache = opts.cache || false;\n  options.rmWhitespace = opts.rmWhitespace;\n  options.root = opts.root;\n  options.localsName = opts.localsName || exports.localsName || _DEFAULT_LOCALS_NAME;\n\n  if (options.strict) {\n    options._with = false;\n  }\n  else {\n    options._with = typeof opts._with != 'undefined' ? opts._with : true;\n  }\n\n  this.opts = options;\n\n  this.regex = this.createRegex();\n}\n\nTemplate.modes = {\n  EVAL: 'eval',\n  ESCAPED: 'escaped',\n  RAW: 'raw',\n  COMMENT: 'comment',\n  LITERAL: 'literal'\n};\n\nTemplate.prototype = {\n  createRegex: function () {\n    var str = _REGEX_STRING;\n    var delim = utils.escapeRegExpChars(this.opts.delimiter);\n    str = str.replace(/%/g, delim);\n    return new RegExp(str);\n  },\n\n  compile: function () {\n    var src;\n    var fn;\n    var opts = this.opts;\n    var prepended = '';\n    var appended = '';\n    var escape = opts.escapeFunction;\n\n    if (!this.source) {\n      this.generateSource();\n      prepended += '  var __output = [], __append = __output.push.bind(__output);' + '\\n';\n      if (opts._with !== false) {\n        prepended +=  '  with (' + opts.localsName + ' || {}) {' + '\\n';\n        appended += '  }' + '\\n';\n      }\n      appended += '  return __output.join(\"\");' + '\\n';\n      this.source = prepended + this.source + appended;\n    }\n\n    if (opts.compileDebug) {\n      src = 'var __line = 1' + '\\n'\n          + '  , __lines = ' + JSON.stringify(this.templateText) + '\\n'\n          + '  , __filename = ' + (opts.filename ?\n                JSON.stringify(opts.filename) : 'undefined') + ';' + '\\n'\n          + 'try {' + '\\n'\n          + this.source\n          + '} catch (e) {' + '\\n'\n          + '  rethrow(e, __lines, __filename, __line);' + '\\n'\n          + '}' + '\\n';\n    }\n    else {\n      src = this.source;\n    }\n\n    if (opts.debug) {\n      console.log(src);\n    }\n\n    if (opts.client) {\n      src = 'escape = escape || ' + escape.toString() + ';' + '\\n' + src;\n      if (opts.compileDebug) {\n        src = 'rethrow = rethrow || ' + rethrow.toString() + ';' + '\\n' + src;\n      }\n    }\n\n    if (opts.strict) {\n      src = '\"use strict\";\\n' + src;\n    }\n\n    try {\n      fn = new Function(opts.localsName + ', escape, include, rethrow', src);\n    }\n    catch(e) {\n      // istanbul ignore else\n      if (e instanceof SyntaxError) {\n        if (opts.filename) {\n          e.message += ' in ' + opts.filename;\n        }\n        e.message += ' while compiling ejs\\n\\n';\n        e.message += 'If the above error is not helpful, you may want to try EJS-Lint:\\n';\n        e.message += 'https://github.com/RyanZim/EJS-Lint';\n      }\n      throw e;\n    }\n\n    if (opts.client) {\n      fn.dependencies = this.dependencies;\n      return fn;\n    }\n\n    // Return a callable function which will execute the function\n    // created by the source-code, with the passed data as locals\n    // Adds a local `include` function which allows full recursive include\n    var returnedFn = function (data) {\n      var include = function (path, includeData) {\n        var d = utils.shallowCopy({}, data);\n        if (includeData) {\n          d = utils.shallowCopy(d, includeData);\n        }\n        return includeFile(path, opts)(d);\n      };\n      return fn.apply(opts.context, [data || {}, escape, include, rethrow]);\n    };\n    returnedFn.dependencies = this.dependencies;\n    return returnedFn;\n  },\n\n  generateSource: function () {\n    var opts = this.opts;\n\n    if (opts.rmWhitespace) {\n      // Have to use two separate replace here as `^` and `$` operators don't\n      // work well with `\\r`.\n      this.templateText =\n        this.templateText.replace(/\\r/g, '').replace(/^\\s+|\\s+$/gm, '');\n    }\n\n    // Slurp spaces and tabs before <%_ and after _%>\n    this.templateText =\n      this.templateText.replace(/[ \\t]*<%_/gm, '<%_').replace(/_%>[ \\t]*/gm, '_%>');\n\n    var self = this;\n    var matches = this.parseTemplateText();\n    var d = this.opts.delimiter;\n\n    if (matches && matches.length) {\n      matches.forEach(function (line, index) {\n        var opening;\n        var closing;\n        var include;\n        var includeOpts;\n        var includeObj;\n        var includeSrc;\n        // If this is an opening tag, check for closing tags\n        // FIXME: May end up with some false positives here\n        // Better to store modes as k/v with '<' + delimiter as key\n        // Then this can simply check against the map\n        if ( line.indexOf('<' + d) === 0        // If it is a tag\n          && line.indexOf('<' + d + d) !== 0) { // and is not escaped\n          closing = matches[index + 2];\n          if (!(closing == d + '>' || closing == '-' + d + '>' || closing == '_' + d + '>')) {\n            throw new Error('Could not find matching close tag for \"' + line + '\".');\n          }\n        }\n        // HACK: backward-compat `include` preprocessor directives\n        if ((include = line.match(/^\\s*include\\s+(\\S+)/))) {\n          opening = matches[index - 1];\n          // Must be in EVAL or RAW mode\n          if (opening && (opening == '<' + d || opening == '<' + d + '-' || opening == '<' + d + '_')) {\n            includeOpts = utils.shallowCopy({}, self.opts);\n            includeObj = includeSource(include[1], includeOpts);\n            if (self.opts.compileDebug) {\n              includeSrc =\n                  '    ; (function(){' + '\\n'\n                  + '      var __line = 1' + '\\n'\n                  + '      , __lines = ' + JSON.stringify(includeObj.template) + '\\n'\n                  + '      , __filename = ' + JSON.stringify(includeObj.filename) + ';' + '\\n'\n                  + '      try {' + '\\n'\n                  + includeObj.source\n                  + '      } catch (e) {' + '\\n'\n                  + '        rethrow(e, __lines, __filename, __line);' + '\\n'\n                  + '      }' + '\\n'\n                  + '    ; }).call(this)' + '\\n';\n            }else{\n              includeSrc = '    ; (function(){' + '\\n' + includeObj.source +\n                  '    ; }).call(this)' + '\\n';\n            }\n            self.source += includeSrc;\n            self.dependencies.push(exports.resolveInclude(include[1],\n                includeOpts.filename));\n            return;\n          }\n        }\n        self.scanLine(line);\n      });\n    }\n\n  },\n\n  parseTemplateText: function () {\n    var str = this.templateText;\n    var pat = this.regex;\n    var result = pat.exec(str);\n    var arr = [];\n    var firstPos;\n\n    while (result) {\n      firstPos = result.index;\n\n      if (firstPos !== 0) {\n        arr.push(str.substring(0, firstPos));\n        str = str.slice(firstPos);\n      }\n\n      arr.push(result[0]);\n      str = str.slice(result[0].length);\n      result = pat.exec(str);\n    }\n\n    if (str) {\n      arr.push(str);\n    }\n\n    return arr;\n  },\n\n  scanLine: function (line) {\n    var self = this;\n    var d = this.opts.delimiter;\n    var newLineCount = 0;\n\n    function _addOutput() {\n      if (self.truncate) {\n        // Only replace single leading linebreak in the line after\n        // -%> tag -- this is the single, trailing linebreak\n        // after the tag that the truncation mode replaces\n        // Handle Win / Unix / old Mac linebreaks -- do the \\r\\n\n        // combo first in the regex-or\n        line = line.replace(/^(?:\\r\\n|\\r|\\n)/, '');\n        self.truncate = false;\n      }\n      else if (self.opts.rmWhitespace) {\n        // rmWhitespace has already removed trailing spaces, just need\n        // to remove linebreaks\n        line = line.replace(/^\\n/, '');\n      }\n      if (!line) {\n        return;\n      }\n\n      // Preserve literal slashes\n      line = line.replace(/\\\\/g, '\\\\\\\\');\n\n      // Convert linebreaks\n      line = line.replace(/\\n/g, '\\\\n');\n      line = line.replace(/\\r/g, '\\\\r');\n\n      // Escape double-quotes\n      // - this will be the delimiter during execution\n      line = line.replace(/\"/g, '\\\\\"');\n      self.source += '    ; __append(\"' + line + '\")' + '\\n';\n    }\n\n    newLineCount = (line.split('\\n').length - 1);\n\n    switch (line) {\n    case '<' + d:\n    case '<' + d + '_':\n      this.mode = Template.modes.EVAL;\n      break;\n    case '<' + d + '=':\n      this.mode = Template.modes.ESCAPED;\n      break;\n    case '<' + d + '-':\n      this.mode = Template.modes.RAW;\n      break;\n    case '<' + d + '#':\n      this.mode = Template.modes.COMMENT;\n      break;\n    case '<' + d + d:\n      this.mode = Template.modes.LITERAL;\n      this.source += '    ; __append(\"' + line.replace('<' + d + d, '<' + d) + '\")' + '\\n';\n      break;\n    case d + d + '>':\n      this.mode = Template.modes.LITERAL;\n      this.source += '    ; __append(\"' + line.replace(d + d + '>', d + '>') + '\")' + '\\n';\n      break;\n    case d + '>':\n    case '-' + d + '>':\n    case '_' + d + '>':\n      if (this.mode == Template.modes.LITERAL) {\n        _addOutput();\n      }\n\n      this.mode = null;\n      this.truncate = line.indexOf('-') === 0 || line.indexOf('_') === 0;\n      break;\n    default:\n        // In script mode, depends on type of tag\n      if (this.mode) {\n          // If '//' is found without a line break, add a line break.\n        switch (this.mode) {\n        case Template.modes.EVAL:\n        case Template.modes.ESCAPED:\n        case Template.modes.RAW:\n          if (line.lastIndexOf('//') > line.lastIndexOf('\\n')) {\n            line += '\\n';\n          }\n        }\n        switch (this.mode) {\n            // Just executing code\n        case Template.modes.EVAL:\n          this.source += '    ; ' + line + '\\n';\n          break;\n            // Exec, esc, and output\n        case Template.modes.ESCAPED:\n          this.source += '    ; __append(escape(' + stripSemi(line) + '))' + '\\n';\n          break;\n            // Exec and output\n        case Template.modes.RAW:\n          this.source += '    ; __append(' + stripSemi(line) + ')' + '\\n';\n          break;\n        case Template.modes.COMMENT:\n              // Do nothing\n          break;\n            // Literal <%% mode, append as raw output\n        case Template.modes.LITERAL:\n          _addOutput();\n          break;\n        }\n      }\n        // In string mode, just add the output\n      else {\n        _addOutput();\n      }\n    }\n\n    if (self.opts.compileDebug && newLineCount) {\n      this.currentLine += newLineCount;\n      this.source += '    ; __line = ' + this.currentLine + '\\n';\n    }\n  }\n};\n\n/**\n * Escape characters reserved in XML.\n *\n * This is simply an export of {@link module:utils.escapeXML}.\n *\n * If `markup` is `undefined` or `null`, the empty string is returned.\n *\n * @param {String} markup Input string\n * @return {String} Escaped string\n * @public\n * @func\n * */\nexports.escapeXML = utils.escapeXML;\n\n/**\n * Express.js support.\n *\n * This is an alias for {@link module:ejs.renderFile}, in order to support\n * Express.js out-of-the-box.\n *\n * @func\n */\n\nexports.__express = exports.renderFile;\n\n// Add require support\n/* istanbul ignore else */\nif (require.extensions) {\n  require.extensions['.ejs'] = function (module, flnm) {\n    var filename = flnm || /* istanbul ignore next */ module.filename;\n    var options = {\n      filename: filename,\n      client: true\n    };\n    var template = fs.readFileSync(filename).toString();\n    var fn = exports.compile(template, options);\n    module._compile('module.exports = ' + fn.toString() + ';', filename);\n  };\n}\n\n/**\n * Version of EJS.\n *\n * @readonly\n * @type {String}\n * @public\n */\n\nexports.VERSION = _VERSION_STRING;\n\n/* istanbul ignore if */\nif (typeof window != 'undefined') {\n  window.ejs = exports;\n}\n", "/* jshint mocha: true */\n/* eslint-env node, mocha */\n\n/**\n * Module dependencies.\n */\n\nvar ejs = require('..');\nvar fs = require('fs');\nvar read = fs.readFileSync;\nvar assert = require('assert');\nvar path = require('path');\nvar LRU = require('lru-cache');\n\ntry {\n  fs.mkdirSync(__dirname + '/tmp');\n} catch (ex) {\n  if (ex.code !== 'EEXIST') {\n    throw ex;\n  }\n}\n\n// From https://gist.github.com/pguillory/729616\nfunction hook_stdio(stream, callback) {\n  var old_write = stream.write;\n\n  stream.write = (function() {\n    return function(string, encoding, fd) {\n      callback(string, encoding, fd);\n    };\n  })(stream.write);\n\n  return function() {\n    stream.write = old_write;\n  };\n}\n\n/**\n * Load fixture `name`.\n */\n\nfunction fixture(name) {\n  return read('test/fixtures/' + name, 'utf8');\n}\n\n/**\n * User fixtures.\n */\n\nvar users = [];\nusers.push({name: 'geddy'});\nusers.push({name: 'neil'});\nusers.push({name: 'alex'});\n\nsuite('ejs.compile(str, options)', function () {\n  test('compile to a function', function () {\n    var fn = ejs.compile('<p>yay</p>');\n    assert.equal(fn(), '<p>yay</p>');\n  });\n\n  test('empty input works', function () {\n    var fn = ejs.compile('');\n    assert.equal(fn(), '');\n  });\n\n  test('throw if there are syntax errors', function () {\n    try {\n      ejs.compile(fixture('fail.ejs'));\n    }\n    catch (err) {\n      assert.ok(err.message.indexOf('compiling ejs') > -1);\n\n      try {\n        ejs.compile(fixture('fail.ejs'), {filename: 'fail.ejs'});\n      }\n      catch (err) {\n        assert.ok(err.message.indexOf('fail.ejs') > -1);\n        return;\n      }\n    }\n    throw new Error('no error reported when there should be');\n  });\n\n  test('allow customizing delimiter local var', function () {\n    var fn;\n    fn = ejs.compile('<p><?= name ?></p>', {delimiter: '?'});\n    assert.equal(fn({name: 'geddy'}), '<p>geddy</p>');\n\n    fn = ejs.compile('<p><:= name :></p>', {delimiter: ':'});\n    assert.equal(fn({name: 'geddy'}), '<p>geddy</p>');\n\n    fn = ejs.compile('<p><$= name $></p>', {delimiter: '$'});\n    assert.equal(fn({name: 'geddy'}), '<p>geddy</p>');\n  });\n\n  test('default to using ejs.delimiter', function () {\n    var fn;\n    ejs.delimiter = '&';\n    fn = ejs.compile('<p><&= name &></p>');\n    assert.equal(fn({name: 'geddy'}), '<p>geddy</p>');\n\n    fn = ejs.compile('<p><|= name |></p>', {delimiter: '|'});\n    assert.equal(fn({name: 'geddy'}), '<p>geddy</p>');\n    delete ejs.delimiter;\n  });\n\n  test('have a working client option', function () {\n    var fn;\n    var str;\n    var preFn;\n    fn = ejs.compile('<p><%= foo %></p>', {client: true});\n    str = fn.toString();\n    if (!process.env.running_under_istanbul) {\n      eval('var preFn = ' + str);\n      assert.equal(preFn({foo: 'bar'}), '<p>bar</p>');\n    }\n  });\n\n  test('support client mode without locals', function () {\n    var fn;\n    var str;\n    var preFn;\n    fn = ejs.compile('<p><%= \"foo\" %></p>', {client: true});\n    str = fn.toString();\n    if (!process.env.running_under_istanbul) {\n      eval('var preFn = ' + str);\n      assert.equal(preFn(), '<p>foo</p>');\n    }\n  });\n\n  test('not include rethrow() in client mode if compileDebug is false', function () {\n    var fn = ejs.compile('<p><%= \"foo\" %></p>', {\n      client: true,\n      compileDebug: false\n    });\n    // There could be a `rethrow` in the function declaration\n    assert((fn.toString().match(/rethrow/g) || []).length <= 1);\n  });\n\n  test('support custom escape function', function () {\n    var customEscape;\n    var fn;\n    customEscape = function customEscape(str) {\n      return !str ? '' : str.toUpperCase();\n    };\n    fn = ejs.compile('HELLO <%= name %>', {escape: customEscape});\n    assert.equal(fn({name: 'world'}), 'HELLO WORLD');\n  });\n\n  test('support custom escape function in client mode', function () {\n    var customEscape;\n    var fn;\n    var str;\n    customEscape = function customEscape(str) {\n      return !str ? '' : str.toUpperCase();\n    };\n    fn = ejs.compile('HELLO <%= name %>', {escape: customEscape, client: true});\n    str = fn.toString();\n    if (!process.env.running_under_istanbul) {\n      eval('var preFn = ' + str);\n      assert.equal(preFn({name: 'world'}), 'HELLO WORLD'); // eslint-disable-line no-undef\n    }\n  });\n\n  test('strict mode works', function () {\n    assert.equal(ejs.render(fixture('strict.ejs'), {}, {strict: true}), 'true');\n  });\n\n});\n\nsuite('ejs.render(str, data, opts)', function () {\n  test('render the template', function () {\n    assert.equal(ejs.render('<p>yay</p>'), '<p>yay</p>');\n  });\n\n  test('empty input works', function () {\n    assert.equal(ejs.render(''), '');\n  });\n\n  test('undefined renders nothing escaped', function () {\n    assert.equal(ejs.render('<%= undefined %>'), '');\n  });\n\n  test('undefined renders nothing raw', function () {\n    assert.equal(ejs.render('<%- undefined %>'), '');\n  });\n\n  test('null renders nothing escaped', function () {\n    assert.equal(ejs.render('<%= null %>'), '');\n  });\n\n  test('null renders nothing raw', function () {\n    assert.equal(ejs.render('<%- null %>'), '');\n  });\n\n  test('zero-value data item renders something escaped', function () {\n    assert.equal(ejs.render('<%= 0 %>'), '0');\n  });\n\n  test('zero-value data object renders something raw', function () {\n    assert.equal(ejs.render('<%- 0 %>'), '0');\n  });\n\n  test('accept locals', function () {\n    assert.equal(ejs.render('<p><%= name %></p>', {name: 'geddy'}),\n        '<p>geddy</p>');\n  });\n\n  test('accept locals without using with() {}', function () {\n    assert.equal(ejs.render('<p><%= locals.name %></p>', {name: 'geddy'},\n                            {_with: false}),\n        '<p>geddy</p>');\n    assert.throws(function() {\n      ejs.render('<p><%= name %></p>', {name: 'geddy'},\n                 {_with: false});\n    }, /name is not defined/);\n  });\n\n  test('accept custom name for locals', function () {\n    ejs.localsName = 'it';\n    assert.equal(ejs.render('<p><%= it.name %></p>', {name: 'geddy'},\n                            {_with: false}),\n        '<p>geddy</p>');\n    assert.throws(function() {\n      ejs.render('<p><%= name %></p>', {name: 'geddy'},\n                 {_with: false});\n    }, /name is not defined/);\n    ejs.localsName = 'locals';\n  });\n\n  test('support caching', function () {\n    var file = __dirname + '/tmp/render.ejs';\n    var options = {cache: true, filename: file};\n    var out = ejs.render('<p>Old</p>', {}, options);\n    var expected = '<p>Old</p>';\n    assert.equal(out, expected);\n    // Assert no change, still in cache\n    out = ejs.render('<p>New</p>', {}, options);\n    assert.equal(out, expected);\n  });\n\n  test('support LRU caching', function () {\n    var oldCache = ejs.cache;\n    var file = __dirname + '/tmp/render.ejs';\n    var options = {cache: true, filename: file};\n    var out;\n    var expected = '<p>Old</p>';\n\n    // Switch to LRU\n    ejs.cache = LRU();\n\n    out = ejs.render('<p>Old</p>', {}, options);\n    assert.equal(out, expected);\n    // Assert no change, still in cache\n    out = ejs.render('<p>New</p>', {}, options);\n    assert.equal(out, expected);\n\n    // Restore system cache\n    ejs.cache = oldCache;\n  });\n\n  test('opts.context', function () {\n    var ctxt = {foo: 'FOO'};\n    var out = ejs.render('<%= this.foo %>', {}, {context: ctxt});\n    assert.equal(out, ctxt.foo);\n  });\n});\n\nsuite('ejs.renderFile(path, [data], [options], fn)', function () {\n  test('render a file', function(done) {\n    ejs.renderFile('test/fixtures/para.ejs', function(err, html) {\n      if (err) {\n        return done(err);\n      }\n      assert.equal(html, '<p>hey</p>\\n');\n      done();\n    });\n  });\n\n  test('accept locals', function(done) {\n    var data =  {name: 'fonebone'};\n    var options = {delimiter: '$'};\n    ejs.renderFile('test/fixtures/user.ejs', data, options, function(err, html) {\n      if (err) {\n        return done(err);\n      }\n      assert.equal(html, '<h1>fonebone</h1>\\n');\n      done();\n    });\n  });\n\n  test('accept locals without using with() {}', function(done) {\n    var data =  {name: 'fonebone'};\n    var options = {delimiter: '$', _with: false};\n    var doneCount = 0;\n    ejs.renderFile('test/fixtures/user-no-with.ejs', data, options, function(err, html) {\n      if (err) {\n        if (doneCount === 2) {\n          return;\n        }\n        doneCount = 2;\n        return done(err);\n      }\n      assert.equal(html, '<h1>fonebone</h1>\\n');\n      doneCount++;\n      if (doneCount === 2) {\n        done();\n      }\n    });\n    ejs.renderFile('test/fixtures/user.ejs', data, options, function(err) {\n      if (!err) {\n        if (doneCount === 2) {\n          return;\n        }\n        doneCount = 2;\n        return done(new Error('error not thrown'));\n      }\n      doneCount++;\n      if (doneCount === 2) {\n        done();\n      }\n    });\n  });\n\n  test('not catch err thrown by callback', function(done) {\n    var data =  {name: 'fonebone'};\n    var options = {delimiter: '$'};\n    var counter = 0;\n\n    var d = require('domain').create();\n    d.on('error', function (err) {\n      assert.equal(counter, 1);\n      assert.equal(err.message, 'Exception in callback');\n      done();\n    });\n    d.run(function () {\n      // process.nextTick() needed to work around mochajs/mocha#513\n      //\n      // tl;dr: mocha doesn't support synchronous exception throwing in\n      // domains. Have to make it async. Ticket closed because: \"domains are\n      // deprecated :D\"\n      process.nextTick(function () {\n        ejs.renderFile('test/fixtures/user.ejs', data, options, function(err) {\n          counter++;\n          if (err) {\n            assert.notEqual(err.message, 'Exception in callback');\n            return done(err);\n          }\n          throw new Error('Exception in callback');\n        });\n      });\n    });\n  });\n\n  test('support caching', function (done) {\n    var expected = '<p>Old</p>';\n    var file = __dirname + '/tmp/renderFile.ejs';\n    var options = {cache: true};\n    fs.writeFileSync(file, '<p>Old</p>');\n\n    ejs.renderFile(file, {}, options, function (err, out) {\n      if (err) {\n        done(err);\n      }\n      fs.writeFileSync(file, '<p>New</p>');\n      assert.equal(out, expected);\n\n      ejs.renderFile(file, {}, options, function (err, out) {\n        if (err) {\n          done(err);\n        }\n        // Assert no change, still in cache\n        assert.equal(out, expected);\n        done();\n      });\n    });\n  });\n\n  test('opts.context', function (done) {\n    var ctxt = {foo: 'FOO'};\n    ejs.renderFile('test/fixtures/with-context.ejs', {}, {context: ctxt}, function(err, html) {\n      if (err) {\n        return done(err);\n      }\n      assert.equal(html, ctxt.foo + '\\n');\n      done();\n    });\n\n  });\n});\n\nsuite('cache specific', function () {\n  test('`clearCache` work properly', function () {\n    var expected = '<p>Old</p>';\n    var file = __dirname + '/tmp/clearCache.ejs';\n    var options = {cache: true, filename: file};\n    var out = ejs.render('<p>Old</p>', {}, options);\n    assert.equal(out, expected);\n\n    ejs.clearCache();\n\n    expected = '<p>New</p>';\n    out = ejs.render('<p>New</p>', {}, options);\n    assert.equal(out, expected);\n  });\n\n  test('`clearCache` work properly, LRU', function () {\n    var expected = '<p>Old</p>';\n    var oldCache = ejs.cache;\n    var file = __dirname + '/tmp/clearCache.ejs';\n    var options = {cache: true, filename: file};\n    var out;\n\n    ejs.cache = LRU();\n\n    out = ejs.render('<p>Old</p>', {}, options);\n    assert.equal(out, expected);\n    ejs.clearCache();\n    expected = '<p>New</p>';\n    out = ejs.render('<p>New</p>', {}, options);\n    assert.equal(out, expected);\n\n    ejs.cache = oldCache;\n  });\n\n  test('LRU with cache-size 1', function () {\n    var oldCache = ejs.cache;\n    var options;\n    var out;\n    var expected;\n    var file;\n\n    ejs.cache = LRU(1);\n\n    file = __dirname + '/tmp/render1.ejs';\n    options = {cache: true, filename: file};\n    out = ejs.render('<p>File1</p>', {}, options);\n    expected = '<p>File1</p>';\n    assert.equal(out, expected);\n\n    // Same filename, different template, but output\n    // should be the same because cache\n    file = __dirname + '/tmp/render1.ejs';\n    options = {cache: true, filename: file};\n    out = ejs.render('<p>ChangedFile1</p>', {}, options);\n    expected = '<p>File1</p>';\n    assert.equal(out, expected);\n\n    // Different filiename -- output should be different,\n    // and previous cache-entry should be evicted\n    file = __dirname + '/tmp/render2.ejs';\n    options = {cache: true, filename: file};\n    out = ejs.render('<p>File2</p>', {}, options);\n    expected = '<p>File2</p>';\n    assert.equal(out, expected);\n\n    // Entry with first filename should now be out of cache,\n    // results should be different\n    file = __dirname + '/tmp/render1.ejs';\n    options = {cache: true, filename: file};\n    out = ejs.render('<p>ChangedFile1</p>', {}, options);\n    expected = '<p>ChangedFile1</p>';\n    assert.equal(out, expected);\n\n    ejs.cache = oldCache;\n  });\n});\n\nsuite('<%', function () {\n  test('without semicolons', function () {\n    assert.equal(ejs.render(fixture('no.semicolons.ejs')),\n        fixture('no.semicolons.html'));\n  });\n});\n\nsuite('<%=', function () {\n  test('should not throw an error with a // comment on the final line', function () {\n    assert.equal(ejs.render('<%=\\n// a comment\\nname\\n// another comment %>', {name: '&nbsp;<script>'}),\n      '&amp;nbsp;&lt;script&gt;');\n  });\n\n  test('escape &amp;<script>', function () {\n    assert.equal(ejs.render('<%= name %>', {name: '&nbsp;<script>'}),\n        '&amp;nbsp;&lt;script&gt;');\n  });\n\n  test('should escape \\'', function () {\n    assert.equal(ejs.render('<%= name %>', {name: 'The Jones\\'s'}),\n      'The Jones&#39;s');\n  });\n\n  test('should escape &foo_bar;', function () {\n    assert.equal(ejs.render('<%= name %>', {name: '&foo_bar;'}),\n      '&amp;foo_bar;');\n  });\n\n  test('should accept custom function', function() {\n\n    var customEscape = function customEscape(str) {\n      return !str ? '' : str.toUpperCase();\n    };\n\n    assert.equal(\n      ejs.render('<%= name %>', {name: 'The Jones\\'s'}, {escape: customEscape}),\n      'THE JONES\\'S'\n    );\n  });\n});\n\nsuite('<%-', function () {\n  test('should not throw an error with a // comment on the final line', function () {\n    assert.equal(ejs.render('<%-\\n// a comment\\nname\\n// another comment %>', {name: '&nbsp;<script>'}),\n        '&nbsp;<script>');\n  });\n\n  test('not escape', function () {\n    assert.equal(ejs.render('<%- name %>', {name: '<script>'}),\n        '<script>');\n  });\n\n  test('terminate gracefully if no close tag is found', function () {\n    try {\n      ejs.compile('<h1>oops</h1><%- name ->');\n      throw new Error('Expected parse failure');\n    }\n    catch (err) {\n      assert.ok(err.message.indexOf('Could not find matching close tag for') > -1);\n    }\n  });\n});\n\nsuite('%>', function () {\n  test('produce newlines', function () {\n    assert.equal(ejs.render(fixture('newlines.ejs'), {users: users}),\n      fixture('newlines.html'));\n  });\n  test('works with `-%>` interspersed', function () {\n    assert.equal(ejs.render(fixture('newlines.mixed.ejs'), {users: users}),\n      fixture('newlines.mixed.html'));\n  });\n  test('consecutive tags work', function () {\n    assert.equal(ejs.render(fixture('consecutive-tags.ejs')),\n      fixture('consecutive-tags.html'));\n  });\n});\n\nsuite('-%>', function () {\n  test('not produce newlines', function () {\n    assert.equal(ejs.render(fixture('no.newlines.ejs'), {users: users}),\n      fixture('no.newlines.html'));\n  });\n  test('stack traces work', function () {\n    try {\n      ejs.render(fixture('no.newlines.error.ejs'));\n    }\n    catch (e) {\n      if (e.message.indexOf('>> 4| <%= qdata %>') > -1) {\n        return;\n      }\n      throw e;\n    }\n    throw new Error('Expected ReferenceError');\n  });\n\n  test('works with unix style', function () {\n    var content = '<ul><% -%>\\n'\n    + '<% users.forEach(function(user){ -%>\\n'\n    + '<li><%= user.name -%></li>\\n'\n    + '<% }) -%>\\n'\n    + '</ul><% -%>\\n';\n\n    var expectedResult = '<ul><li>geddy</li>\\n<li>neil</li>\\n<li>alex</li>\\n</ul>';\n    var fn;\n    fn = ejs.compile(content);\n    assert.equal(fn({users: users}),\n      expectedResult);\n  });\n\n  test('works with windows style', function () {\n    var content = '<ul><% -%>\\r\\n'\n    + '<% users.forEach(function(user){ -%>\\r\\n'\n    + '<li><%= user.name -%></li>\\r\\n'\n    + '<% }) -%>\\r\\n'\n    + '</ul><% -%>\\r\\n';\n\n    var expectedResult = '<ul><li>geddy</li>\\r\\n<li>neil</li>\\r\\n<li>alex</li>\\r\\n</ul>';\n    var fn;\n    fn = ejs.compile(content);\n    assert.equal(fn({users: users}),\n      expectedResult);\n  });\n});\n\nsuite('<%%', function () {\n  test('produce literals', function () {\n    assert.equal(ejs.render('<%%- \"foo\" %>'),\n      '<%- \"foo\" %>');\n  });\n  test('work without an end tag', function () {\n    assert.equal(ejs.render('<%%'), '<%');\n    assert.equal(ejs.render(fixture('literal.ejs'), {}, {delimiter: ' '}),\n      fixture('literal.html'));\n  });\n});\n\nsuite('%%>', function () {\n  test('produce literal', function () {\n    assert.equal(ejs.render('%%>'),\n        '%>');\n    assert.equal(ejs.render('  >', {}, {delimiter: ' '}),\n        ' >');\n  });\n});\n\nsuite('<%_ and _%>', function () {\n  test('slurps spaces and tabs', function () {\n    assert.equal(ejs.render(fixture('space-and-tab-slurp.ejs'), {users: users}),\n      fixture('space-and-tab-slurp.html'));\n  });\n});\n\nsuite('single quotes', function () {\n  test('not mess up the constructed function', function () {\n    assert.equal(ejs.render(fixture('single-quote.ejs')),\n      fixture('single-quote.html'));\n  });\n});\n\nsuite('double quotes', function () {\n  test('not mess up the constructed function', function () {\n    assert.equal(ejs.render(fixture('double-quote.ejs')),\n      fixture('double-quote.html'));\n  });\n});\n\nsuite('backslashes', function () {\n  test('escape', function () {\n    assert.equal(ejs.render(fixture('backslash.ejs')),\n      fixture('backslash.html'));\n  });\n});\n\nsuite('messed up whitespace', function () {\n  test('work', function () {\n    assert.equal(ejs.render(fixture('messed.ejs'), {users: users}),\n      fixture('messed.html'));\n  });\n});\n\nsuite('exceptions', function () {\n  test('produce useful stack traces', function () {\n    try {\n      ejs.render(fixture('error.ejs'), {}, {filename: 'error.ejs'});\n    }\n    catch (err) {\n      assert.equal(err.path, 'error.ejs');\n      assert.equal(err.stack.split('\\n').slice(0, 8).join('\\n'), fixture('error.out'));\n      return;\n    }\n    throw new Error('no error reported when there should be');\n  });\n\n  test('not include fancy stack info if compileDebug is false', function () {\n    try {\n      ejs.render(fixture('error.ejs'), {}, {\n        filename: 'error.ejs',\n        compileDebug: false\n      });\n    }\n    catch (err) {\n      assert.ok(!err.path);\n      assert.notEqual(err.stack.split('\\n').slice(0, 8).join('\\n'), fixture('error.out'));\n      return;\n    }\n    throw new Error('no error reported when there should be');\n  });\n\n  var unhook = null;\n  test('log JS source when debug is set', function (done) {\n    var out = '';\n    var needToExit = false;\n    unhook = hook_stdio(process.stdout, function (str) {\n      out += str;\n      if (needToExit) {\n        return;\n      }\n      if (out.indexOf('__output')) {\n        needToExit = true;\n        unhook();\n        unhook = null;\n        return done();\n      }\n    });\n    ejs.render(fixture('hello-world.ejs'), {}, {debug: true});\n  });\n  teardown(function() {\n    if (!unhook) {\n      return;\n    }\n    unhook();\n    unhook = null;\n  });\n});\n\nsuite('rmWhitespace', function () {\n  test('works', function () {\n    assert.equal(ejs.render(fixture('rmWhitespace.ejs'), {}, {rmWhitespace: true}),\n        fixture('rmWhitespace.html'));\n  });\n});\n\nsuite('include()', function () {\n  test('include ejs', function () {\n    var file = 'test/fixtures/include-simple.ejs';\n    assert.equal(ejs.render(fixture('include-simple.ejs'), {}, {filename: file}),\n        fixture('include-simple.html'));\n  });\n\n  test('include ejs fails without `filename`', function () {\n    try {\n      ejs.render(fixture('include-simple.ejs'));\n    }\n    catch (err) {\n      assert.ok(err.message.indexOf('requires the \\'filename\\' option') > -1);\n      return;\n    }\n    throw new Error('expected inclusion error');\n  });\n\n  test('strips BOM', function () {\n    assert.equal(\n      ejs.render('<%- include(\"fixtures/includes/bom.ejs\") %>',\n        {}, {filename: path.join(__dirname, 'f.ejs')}),\n      '<p>This is a file with BOM.</p>\\n');\n  });\n\n  test('include ejs with locals', function () {\n    var file = 'test/fixtures/include.ejs';\n    assert.equal(ejs.render(fixture('include.ejs'), {pets: users}, {filename: file, delimiter: '@'}),\n        fixture('include.html'));\n  });\n\n  test('include ejs with absolute path and locals', function () {\n    var file = 'test/fixtures/include-abspath.ejs';\n    assert.equal(ejs.render(fixture('include-abspath.ejs'),\n      {dir: path.join(__dirname, 'fixtures'), pets: users, path: path},\n      {filename: file, delimiter: '@'}),\n        fixture('include.html'));\n  });\n\n  test('include ejs with set root path', function () {\n    var file = 'test/fixtures/include-root.ejs';\n    var viewsPath = path.join(__dirname, 'fixtures');\n    assert.equal(ejs.render(fixture('include-root.ejs'), {pets: users}, {filename: file, delimiter: '@',root:viewsPath}),\n      fixture('include.html'));\n\n  });\n\n  test('work when nested', function () {\n    var file = 'test/fixtures/menu.ejs';\n    assert.equal(ejs.render(fixture('menu.ejs'), {pets: users}, {filename: file}),\n        fixture('menu.html'));\n  });\n\n  test('work with a variable path', function () {\n    var file = 'test/fixtures/menu_var.ejs';\n    var includePath = 'includes/menu-item';\n    assert.equal(ejs.render(fixture('menu.ejs'), {pets: users, varPath:  includePath}, {filename: file}),\n      fixture('menu.html'));\n  });\n\n  test('include arbitrary files as-is', function () {\n    var file = 'test/fixtures/include.css.ejs';\n    assert.equal(ejs.render(fixture('include.css.ejs'), {pets: users}, {filename: file}),\n        fixture('include.css.html'));\n  });\n\n  test('pass compileDebug to include', function () {\n    var file = 'test/fixtures/include.ejs';\n    var fn;\n    fn = ejs.compile(fixture('include.ejs'), {\n      filename: file,\n      delimiter: '@',\n      compileDebug: false\n    });\n    try {\n      // Render without a required variable reference\n      fn({foo: 'asdf'});\n    }\n    catch(e) {\n      assert.equal(e.message, 'pets is not defined');\n      assert.ok(!e.path);\n      return;\n    }\n    throw new Error('no error reported when there should be');\n  });\n\n  test('is dynamic', function () {\n    fs.writeFileSync(__dirname + '/tmp/include.ejs', '<p>Old</p>');\n    var file = 'test/fixtures/include_cache.ejs';\n    var options = {filename: file};\n    var out = ejs.compile(fixture('include_cache.ejs'), options);\n    assert.equal(out(), '<p>Old</p>\\n');\n\n    fs.writeFileSync(__dirname + '/tmp/include.ejs', '<p>New</p>');\n    assert.equal(out(), '<p>New</p>\\n');\n  });\n\n  test('support caching', function () {\n    fs.writeFileSync(__dirname + '/tmp/include.ejs', '<p>Old</p>');\n    var file = 'test/fixtures/include_cache.ejs';\n    var options = {cache: true, filename: file};\n    var out = ejs.render(fixture('include_cache.ejs'), {}, options);\n    var expected = fixture('include_cache.html');\n    assert.equal(out, expected);\n    out = ejs.render(fixture('include_cache.ejs'), {}, options);\n    // No change, still in cache\n    assert.equal(out, expected);\n    fs.writeFileSync(__dirname + '/tmp/include.ejs', '<p>New</p>');\n    out = ejs.render(fixture('include_cache.ejs'), {}, options);\n    assert.equal(out, expected);\n  });\n\n});\n\nsuite('preprocessor include', function () {\n  test('work', function () {\n    var file = 'test/fixtures/include_preprocessor.ejs';\n    assert.equal(ejs.render(fixture('include_preprocessor.ejs'), {pets: users}, {filename: file, delimiter: '@'}),\n        fixture('include_preprocessor.html'));\n  });\n\n  test('no false positives', function () {\n    assert.equal(ejs.render('<% %> include foo <% %>'), ' include foo ');\n  });\n\n  test('fails without `filename`', function () {\n    try {\n      ejs.render(fixture('include_preprocessor.ejs'), {pets: users}, {delimiter: '@'});\n    }\n    catch (err) {\n      assert.ok(err.message.indexOf('requires the \\'filename\\' option') > -1);\n      return;\n    }\n    throw new Error('expected inclusion error');\n  });\n\n  test('strips BOM', function () {\n    assert.equal(\n      ejs.render('<% include fixtures/includes/bom.ejs %>',\n        {}, {filename: path.join(__dirname, 'f.ejs')}),\n      '<p>This is a file with BOM.</p>\\n');\n  });\n\n  test('work when nested', function () {\n    var file = 'test/fixtures/menu_preprocessor.ejs';\n    assert.equal(ejs.render(fixture('menu_preprocessor.ejs'), {pets: users}, {filename: file}),\n        fixture('menu_preprocessor.html'));\n  });\n\n  test('tracks dependency correctly', function () {\n    var file = 'test/fixtures/menu_preprocessor.ejs';\n    var fn = ejs.compile(fixture('menu_preprocessor.ejs'), {filename: file});\n    assert(fn.dependencies.length);\n  });\n\n  test('include arbitrary files as-is', function () {\n    var file = 'test/fixtures/include_preprocessor.css.ejs';\n    assert.equal(ejs.render(fixture('include_preprocessor.css.ejs'), {pets: users}, {filename: file}),\n        fixture('include_preprocessor.css.html'));\n  });\n\n  test('pass compileDebug to include', function () {\n    var file = 'test/fixtures/include_preprocessor.ejs';\n    var fn;\n    fn = ejs.compile(fixture('include_preprocessor.ejs'), {\n      filename: file,\n      delimiter: '@',\n      compileDebug: false\n    });\n    try {\n      // Render without a required variable reference\n      fn({foo: 'asdf'});\n    }\n    catch(e) {\n      assert.equal(e.message, 'pets is not defined');\n      assert.ok(!e.path);\n      return;\n    }\n    throw new Error('no error reported when there should be');\n  });\n\n  test('is static', function () {\n    fs.writeFileSync(__dirname + '/tmp/include_preprocessor.ejs', '<p>Old</p>');\n    var file = 'test/fixtures/include_preprocessor_cache.ejs';\n    var options = {filename: file};\n    var out = ejs.compile(fixture('include_preprocessor_cache.ejs'), options);\n    assert.equal(out(), '<p>Old</p>\\n');\n\n    fs.writeFileSync(__dirname + '/tmp/include_preprocessor.ejs', '<p>New</p>');\n    assert.equal(out(), '<p>Old</p>\\n');\n  });\n\n  test('support caching', function () {\n    fs.writeFileSync(__dirname + '/tmp/include_preprocessor.ejs', '<p>Old</p>');\n    var file = 'test/fixtures/include_preprocessor_cache.ejs';\n    var options = {cache: true, filename: file};\n    var out = ejs.render(fixture('include_preprocessor_cache.ejs'), {}, options);\n    var expected = fixture('include_preprocessor_cache.html');\n    assert.equal(out, expected);\n    fs.writeFileSync(__dirname + '/tmp/include_preprocessor.ejs', '<p>New</p>');\n    out = ejs.render(fixture('include_preprocessor_cache.ejs'), {}, options);\n    assert.equal(out, expected);\n  });\n\n  test('whitespace slurp and rmWhitespace work', function() {\n    var file = 'test/fixtures/include_preprocessor_line_slurp.ejs';\n    var template = fixture('include_preprocessor_line_slurp.ejs');\n    var expected = fixture('include_preprocessor_line_slurp.html');\n    var options = {rmWhitespace: true, filename: file};\n    assert.equal(ejs.render(template, options),\n        expected);\n  });\n\n});\n\nsuite('comments', function () {\n  test('fully render with comments removed', function () {\n    assert.equal(ejs.render(fixture('comments.ejs')),\n        fixture('comments.html'));\n  });\n});\n\nsuite('require', function () {\n\n  // Only works with inline/preprocessor includes\n  test('allow ejs templates to be required as node modules', function () {\n    var file = 'test/fixtures/include_preprocessor.ejs';\n    var template = require(__dirname + '/fixtures/menu_preprocessor.ejs');\n    if (!process.env.running_under_istanbul) {\n      assert.equal(template({filename: file, pets: users}),\n          fixture('menu_preprocessor.html'));\n    }\n  });\n});\n\nsuite('examples', function () {\n  function noop () {}\n  fs.readdirSync('examples').forEach(function (f) {\n    if (!/\\.js$/.test(f)) {\n      return;\n    }\n    suite(f, function () {\n      test('doesn\\'t throw any errors', function () {\n        var stderr = hook_stdio(process.stderr, noop);\n        var stdout = hook_stdio(process.stdout, noop);\n        try {\n          require('../examples/' + f);\n        }\n        catch (ex) {\n          stdout();\n          stderr();\n          throw ex;\n        }\n        stdout();\n        stderr();\n      });\n    });\n  });\n});\n"], "fixing_code": ["/*\n * EJS Embedded JavaScript templates\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\n'use strict';\n\n/**\n * @file Embedded JavaScript templating engine.\n * @author Matthew Eernisse <mde@fleegix.org>\n * @author Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\n * @project EJS\n * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}\n */\n\n/**\n * EJS internal functions.\n *\n * Technically this \"module\" lies in the same file as {@link module:ejs}, for\n * the sake of organization all the private functions re grouped into this\n * module.\n *\n * @module ejs-internal\n * @private\n */\n\n/**\n * Embedded JavaScript templating engine.\n *\n * @module ejs\n * @public\n */\n\nvar fs = require('fs');\nvar path = require('path');\nvar utils = require('./utils');\n\nvar scopeOptionWarned = false;\nvar _VERSION_STRING = require('../package.json').version;\nvar _DEFAULT_DELIMITER = '%';\nvar _DEFAULT_LOCALS_NAME = 'locals';\nvar _REGEX_STRING = '(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)';\nvar _OPTS = [ 'cache', 'filename', 'delimiter', 'scope', 'context',\n        'debug', 'compileDebug', 'client', '_with', 'root', 'rmWhitespace',\n        'strict', 'localsName'];\nvar _OPTS_IN_DATA_BLACKLIST = {\n      cache: true,\n      filename: true,\n      root: true,\n      localsName: true\n    };\nvar _BOM = /^\\uFEFF/;\n\n/**\n * EJS template function cache. This can be a LRU object from lru-cache NPM\n * module. By default, it is {@link module:utils.cache}, a simple in-process\n * cache that grows continuously.\n *\n * @type {Cache}\n */\n\nexports.cache = utils.cache;\n\n/**\n * Name of the object containing the locals.\n *\n * This variable is overridden by {@link Options}`.localsName` if it is not\n * `undefined`.\n *\n * @type {String}\n * @public\n */\n\nexports.localsName = _DEFAULT_LOCALS_NAME;\n\n/**\n * Get the path to the included file from the parent file path and the\n * specified path.\n *\n * @param {String}  name     specified path\n * @param {String}  filename parent file path\n * @param {Boolean} isDir    parent file path whether is directory\n * @return {String}\n */\nexports.resolveInclude = function(name, filename, isDir) {\n  var dirname = path.dirname;\n  var extname = path.extname;\n  var resolve = path.resolve;\n  var includePath = resolve(isDir ? filename : dirname(filename), name);\n  var ext = extname(name);\n  if (!ext) {\n    includePath += '.ejs';\n  }\n  return includePath;\n};\n\n/**\n * Get the path to the included file by Options\n *\n * @param  {String}  path    specified path\n * @param  {Options} options compilation options\n * @return {String}\n */\nfunction getIncludePath(path, options){\n  var includePath;\n  if (path.charAt(0) == '/') {\n    includePath = exports.resolveInclude(path.replace(/^\\/*/,''), options.root || '/', true);\n  }\n  else {\n    if (!options.filename) {\n      throw new Error('`include` use relative path requires the \\'filename\\' option.');\n    }\n    includePath = exports.resolveInclude(path, options.filename);\n  }\n  return includePath;\n}\n\n/**\n * Get the template from a string or a file, either compiled on-the-fly or\n * read from cache (if enabled), and cache the template if needed.\n *\n * If `template` is not set, the file specified in `options.filename` will be\n * read.\n *\n * If `options.cache` is true, this function reads the file from\n * `options.filename` so it must be set prior to calling this function.\n *\n * @memberof module:ejs-internal\n * @param {Options} options   compilation options\n * @param {String} [template] template source\n * @return {(TemplateFunction|ClientFunction)}\n * Depending on the value of `options.client`, either type might be returned.\n * @static\n */\n\nfunction handleCache(options, template) {\n  var func;\n  var filename = options.filename;\n  var hasTemplate = arguments.length > 1;\n\n  if (options.cache) {\n    if (!filename) {\n      throw new Error('cache option requires a filename');\n    }\n    func = exports.cache.get(filename);\n    if (func) {\n      return func;\n    }\n    if (!hasTemplate) {\n      template = fs.readFileSync(filename).toString().replace(_BOM, '');\n    }\n  }\n  else if (!hasTemplate) {\n    // istanbul ignore if: should not happen at all\n    if (!filename) {\n      throw new Error('Internal EJS error: no file name or template '\n                    + 'provided');\n    }\n    template = fs.readFileSync(filename).toString().replace(_BOM, '');\n  }\n  func = exports.compile(template, options);\n  if (options.cache) {\n    exports.cache.set(filename, func);\n  }\n  return func;\n}\n\n/**\n * Get the template function.\n *\n * If `options.cache` is `true`, then the template is cached.\n *\n * @memberof module:ejs-internal\n * @param {String}  path    path for the specified file\n * @param {Options} options compilation options\n * @return {(TemplateFunction|ClientFunction)}\n * Depending on the value of `options.client`, either type might be returned\n * @static\n */\n\nfunction includeFile(path, options) {\n  var opts = utils.shallowCopy({}, options);\n  opts.filename = getIncludePath(path, opts);\n  return handleCache(opts);\n}\n\n/**\n * Get the JavaScript source of an included file.\n *\n * @memberof module:ejs-internal\n * @param {String}  path    path for the specified file\n * @param {Options} options compilation options\n * @return {Object}\n * @static\n */\n\nfunction includeSource(path, options) {\n  var opts = utils.shallowCopy({}, options);\n  var includePath;\n  var template;\n  includePath = getIncludePath(path,opts);\n  template = fs.readFileSync(includePath).toString().replace(_BOM, '');\n  opts.filename = includePath;\n  var templ = new Template(template, opts);\n  templ.generateSource();\n  return {\n    source: templ.source,\n    filename: includePath,\n    template: template\n  };\n}\n\n/**\n * Re-throw the given `err` in context to the `str` of ejs, `filename`, and\n * `lineno`.\n *\n * @implements RethrowCallback\n * @memberof module:ejs-internal\n * @param {Error}  err      Error object\n * @param {String} str      EJS source\n * @param {String} filename file name of the EJS file\n * @param {String} lineno   line number of the error\n * @static\n */\n\nfunction rethrow(err, str, filename, lineno){\n  var lines = str.split('\\n');\n  var start = Math.max(lineno - 3, 0);\n  var end = Math.min(lines.length, lineno + 3);\n  // Error context\n  var context = lines.slice(start, end).map(function (line, i){\n    var curr = i + start + 1;\n    return (curr == lineno ? ' >> ' : '    ')\n      + curr\n      + '| '\n      + line;\n  }).join('\\n');\n\n  // Alter exception message\n  err.path = filename;\n  err.message = (filename || 'ejs') + ':'\n    + lineno + '\\n'\n    + context + '\\n\\n'\n    + err.message;\n\n  throw err;\n}\n\n/**\n * Copy properties in data object that are recognized as options to an\n * options object.\n *\n * This is used for compatibility with earlier versions of EJS and Express.js.\n *\n * @memberof module:ejs-internal\n * @param {Object}  data data object\n * @param {Options} opts options object\n * @static\n */\n\nfunction cpOptsInData(data, opts) {\n  _OPTS.forEach(function (p) {\n    if (typeof data[p] != 'undefined') {\n      // Disallow passing potentially dangerous opts in the data\n      // These opts should not be settable via a `render` call\n      if (_OPTS_IN_DATA_BLACKLIST[p]) {\n        return;\n      }\n      opts[p] = data[p];\n    }\n  });\n}\n\nfunction stripSemi(str) {\n  return str.replace(/;(\\s*$)/, '$1');\n}\n\n/**\n * Compile the given `str` of ejs into a template function.\n *\n * @param {String}  template EJS template\n *\n * @param {Options} opts     compilation options\n *\n * @return {(TemplateFunction|ClientFunction)}\n * Depending on the value of `opts.client`, either type might be returned.\n * @public\n */\n\nexports.compile = function compile(template, opts) {\n  var templ;\n\n  // v1 compat\n  // 'scope' is 'context'\n  // FIXME: Remove this in a future version\n  if (opts && opts.scope) {\n    if (!scopeOptionWarned){\n      console.warn('`scope` option is deprecated and will be removed in EJS 3');\n      scopeOptionWarned = true;\n    }\n    if (!opts.context) {\n      opts.context = opts.scope;\n    }\n    delete opts.scope;\n  }\n  templ = new Template(template, opts);\n  return templ.compile();\n};\n\n/**\n * Render the given `template` of ejs.\n *\n * If you would like to include options but not data, you need to explicitly\n * call this function with `data` being an empty object or `null`.\n *\n * @param {String}   template EJS template\n * @param {Object}  [data={}] template data\n * @param {Options} [opts={}] compilation and rendering options\n * @return {String}\n * @public\n */\n\nexports.render = function (template, d, o) {\n  var data = d || {};\n  var opts = o || {};\n\n  // No options object -- if there are optiony names\n  // in the data, copy them to options\n  if (arguments.length == 2) {\n    cpOptsInData(data, opts);\n  }\n\n  return handleCache(opts, template)(data);\n};\n\n/**\n * Render an EJS file at the given `path` and callback `cb(err, str)`.\n *\n * If you would like to include options but not data, you need to explicitly\n * call this function with `data` being an empty object or `null`.\n *\n * @param {String}             path     path to the EJS file\n * @param {Object}            [data={}] template data\n * @param {Options}           [opts={}] compilation and rendering options\n * @param {RenderFileCallback} cb callback\n * @public\n */\n\nexports.renderFile = function () {\n  var args = Array.prototype.slice.call(arguments);\n  var filename = args.shift();\n  var cb = args.pop();\n  var data = args.shift() || {};\n  var opts = args.pop() || {};\n  var result;\n\n  // Don't pollute passed in opts obj with new vals\n  opts = utils.shallowCopy({}, opts);\n\n  // No options object -- if there are optiony names\n  // in the data, copy them to options\n  if (arguments.length == 3) {\n    // Express 4\n    if (data.settings && data.settings['view options']) {\n      cpOptsInData(data.settings['view options'], opts);\n    }\n    // Express 3 and lower\n    else {\n      cpOptsInData(data, opts);\n    }\n  }\n  opts.filename = filename;\n\n  try {\n    result = handleCache(opts)(data);\n  }\n  catch(err) {\n    return cb(err);\n  }\n  return cb(null, result);\n};\n\n/**\n * Clear intermediate JavaScript cache. Calls {@link Cache#reset}.\n * @public\n */\n\nexports.clearCache = function () {\n  exports.cache.reset();\n};\n\nfunction Template(text, opts) {\n  opts = opts || {};\n  var options = {};\n  this.templateText = text;\n  this.mode = null;\n  this.truncate = false;\n  this.currentLine = 1;\n  this.source = '';\n  this.dependencies = [];\n  options.client = opts.client || false;\n  options.escapeFunction = opts.escape || utils.escapeXML;\n  options.compileDebug = opts.compileDebug !== false;\n  options.debug = !!opts.debug;\n  options.filename = opts.filename;\n  options.delimiter = opts.delimiter || exports.delimiter || _DEFAULT_DELIMITER;\n  options.strict = opts.strict || false;\n  options.context = opts.context;\n  options.cache = opts.cache || false;\n  options.rmWhitespace = opts.rmWhitespace;\n  options.root = opts.root;\n  options.localsName = opts.localsName || exports.localsName || _DEFAULT_LOCALS_NAME;\n\n  if (options.strict) {\n    options._with = false;\n  }\n  else {\n    options._with = typeof opts._with != 'undefined' ? opts._with : true;\n  }\n\n  this.opts = options;\n\n  this.regex = this.createRegex();\n}\n\nTemplate.modes = {\n  EVAL: 'eval',\n  ESCAPED: 'escaped',\n  RAW: 'raw',\n  COMMENT: 'comment',\n  LITERAL: 'literal'\n};\n\nTemplate.prototype = {\n  createRegex: function () {\n    var str = _REGEX_STRING;\n    var delim = utils.escapeRegExpChars(this.opts.delimiter);\n    str = str.replace(/%/g, delim);\n    return new RegExp(str);\n  },\n\n  compile: function () {\n    var src;\n    var fn;\n    var opts = this.opts;\n    var prepended = '';\n    var appended = '';\n    var escape = opts.escapeFunction;\n\n    if (!this.source) {\n      this.generateSource();\n      prepended += '  var __output = [], __append = __output.push.bind(__output);' + '\\n';\n      if (opts._with !== false) {\n        prepended +=  '  with (' + opts.localsName + ' || {}) {' + '\\n';\n        appended += '  }' + '\\n';\n      }\n      appended += '  return __output.join(\"\");' + '\\n';\n      this.source = prepended + this.source + appended;\n    }\n\n    if (opts.compileDebug) {\n      src = 'var __line = 1' + '\\n'\n          + '  , __lines = ' + JSON.stringify(this.templateText) + '\\n'\n          + '  , __filename = ' + (opts.filename ?\n                JSON.stringify(opts.filename) : 'undefined') + ';' + '\\n'\n          + 'try {' + '\\n'\n          + this.source\n          + '} catch (e) {' + '\\n'\n          + '  rethrow(e, __lines, __filename, __line);' + '\\n'\n          + '}' + '\\n';\n    }\n    else {\n      src = this.source;\n    }\n\n    if (opts.debug) {\n      console.log(src);\n    }\n\n    if (opts.client) {\n      src = 'escape = escape || ' + escape.toString() + ';' + '\\n' + src;\n      if (opts.compileDebug) {\n        src = 'rethrow = rethrow || ' + rethrow.toString() + ';' + '\\n' + src;\n      }\n    }\n\n    if (opts.strict) {\n      src = '\"use strict\";\\n' + src;\n    }\n\n    try {\n      fn = new Function(opts.localsName + ', escape, include, rethrow', src);\n    }\n    catch(e) {\n      // istanbul ignore else\n      if (e instanceof SyntaxError) {\n        if (opts.filename) {\n          e.message += ' in ' + opts.filename;\n        }\n        e.message += ' while compiling ejs\\n\\n';\n        e.message += 'If the above error is not helpful, you may want to try EJS-Lint:\\n';\n        e.message += 'https://github.com/RyanZim/EJS-Lint';\n      }\n      throw e;\n    }\n\n    if (opts.client) {\n      fn.dependencies = this.dependencies;\n      return fn;\n    }\n\n    // Return a callable function which will execute the function\n    // created by the source-code, with the passed data as locals\n    // Adds a local `include` function which allows full recursive include\n    var returnedFn = function (data) {\n      var include = function (path, includeData) {\n        var d = utils.shallowCopy({}, data);\n        if (includeData) {\n          d = utils.shallowCopy(d, includeData);\n        }\n        return includeFile(path, opts)(d);\n      };\n      return fn.apply(opts.context, [data || {}, escape, include, rethrow]);\n    };\n    returnedFn.dependencies = this.dependencies;\n    return returnedFn;\n  },\n\n  generateSource: function () {\n    var opts = this.opts;\n\n    if (opts.rmWhitespace) {\n      // Have to use two separate replace here as `^` and `$` operators don't\n      // work well with `\\r`.\n      this.templateText =\n        this.templateText.replace(/\\r/g, '').replace(/^\\s+|\\s+$/gm, '');\n    }\n\n    // Slurp spaces and tabs before <%_ and after _%>\n    this.templateText =\n      this.templateText.replace(/[ \\t]*<%_/gm, '<%_').replace(/_%>[ \\t]*/gm, '_%>');\n\n    var self = this;\n    var matches = this.parseTemplateText();\n    var d = this.opts.delimiter;\n\n    if (matches && matches.length) {\n      matches.forEach(function (line, index) {\n        var opening;\n        var closing;\n        var include;\n        var includeOpts;\n        var includeObj;\n        var includeSrc;\n        // If this is an opening tag, check for closing tags\n        // FIXME: May end up with some false positives here\n        // Better to store modes as k/v with '<' + delimiter as key\n        // Then this can simply check against the map\n        if ( line.indexOf('<' + d) === 0        // If it is a tag\n          && line.indexOf('<' + d + d) !== 0) { // and is not escaped\n          closing = matches[index + 2];\n          if (!(closing == d + '>' || closing == '-' + d + '>' || closing == '_' + d + '>')) {\n            throw new Error('Could not find matching close tag for \"' + line + '\".');\n          }\n        }\n        // HACK: backward-compat `include` preprocessor directives\n        if ((include = line.match(/^\\s*include\\s+(\\S+)/))) {\n          opening = matches[index - 1];\n          // Must be in EVAL or RAW mode\n          if (opening && (opening == '<' + d || opening == '<' + d + '-' || opening == '<' + d + '_')) {\n            includeOpts = utils.shallowCopy({}, self.opts);\n            includeObj = includeSource(include[1], includeOpts);\n            if (self.opts.compileDebug) {\n              includeSrc =\n                  '    ; (function(){' + '\\n'\n                  + '      var __line = 1' + '\\n'\n                  + '      , __lines = ' + JSON.stringify(includeObj.template) + '\\n'\n                  + '      , __filename = ' + JSON.stringify(includeObj.filename) + ';' + '\\n'\n                  + '      try {' + '\\n'\n                  + includeObj.source\n                  + '      } catch (e) {' + '\\n'\n                  + '        rethrow(e, __lines, __filename, __line);' + '\\n'\n                  + '      }' + '\\n'\n                  + '    ; }).call(this)' + '\\n';\n            }else{\n              includeSrc = '    ; (function(){' + '\\n' + includeObj.source +\n                  '    ; }).call(this)' + '\\n';\n            }\n            self.source += includeSrc;\n            self.dependencies.push(exports.resolveInclude(include[1],\n                includeOpts.filename));\n            return;\n          }\n        }\n        self.scanLine(line);\n      });\n    }\n\n  },\n\n  parseTemplateText: function () {\n    var str = this.templateText;\n    var pat = this.regex;\n    var result = pat.exec(str);\n    var arr = [];\n    var firstPos;\n\n    while (result) {\n      firstPos = result.index;\n\n      if (firstPos !== 0) {\n        arr.push(str.substring(0, firstPos));\n        str = str.slice(firstPos);\n      }\n\n      arr.push(result[0]);\n      str = str.slice(result[0].length);\n      result = pat.exec(str);\n    }\n\n    if (str) {\n      arr.push(str);\n    }\n\n    return arr;\n  },\n\n  scanLine: function (line) {\n    var self = this;\n    var d = this.opts.delimiter;\n    var newLineCount = 0;\n\n    function _addOutput() {\n      if (self.truncate) {\n        // Only replace single leading linebreak in the line after\n        // -%> tag -- this is the single, trailing linebreak\n        // after the tag that the truncation mode replaces\n        // Handle Win / Unix / old Mac linebreaks -- do the \\r\\n\n        // combo first in the regex-or\n        line = line.replace(/^(?:\\r\\n|\\r|\\n)/, '');\n        self.truncate = false;\n      }\n      else if (self.opts.rmWhitespace) {\n        // rmWhitespace has already removed trailing spaces, just need\n        // to remove linebreaks\n        line = line.replace(/^\\n/, '');\n      }\n      if (!line) {\n        return;\n      }\n\n      // Preserve literal slashes\n      line = line.replace(/\\\\/g, '\\\\\\\\');\n\n      // Convert linebreaks\n      line = line.replace(/\\n/g, '\\\\n');\n      line = line.replace(/\\r/g, '\\\\r');\n\n      // Escape double-quotes\n      // - this will be the delimiter during execution\n      line = line.replace(/\"/g, '\\\\\"');\n      self.source += '    ; __append(\"' + line + '\")' + '\\n';\n    }\n\n    newLineCount = (line.split('\\n').length - 1);\n\n    switch (line) {\n    case '<' + d:\n    case '<' + d + '_':\n      this.mode = Template.modes.EVAL;\n      break;\n    case '<' + d + '=':\n      this.mode = Template.modes.ESCAPED;\n      break;\n    case '<' + d + '-':\n      this.mode = Template.modes.RAW;\n      break;\n    case '<' + d + '#':\n      this.mode = Template.modes.COMMENT;\n      break;\n    case '<' + d + d:\n      this.mode = Template.modes.LITERAL;\n      this.source += '    ; __append(\"' + line.replace('<' + d + d, '<' + d) + '\")' + '\\n';\n      break;\n    case d + d + '>':\n      this.mode = Template.modes.LITERAL;\n      this.source += '    ; __append(\"' + line.replace(d + d + '>', d + '>') + '\")' + '\\n';\n      break;\n    case d + '>':\n    case '-' + d + '>':\n    case '_' + d + '>':\n      if (this.mode == Template.modes.LITERAL) {\n        _addOutput();\n      }\n\n      this.mode = null;\n      this.truncate = line.indexOf('-') === 0 || line.indexOf('_') === 0;\n      break;\n    default:\n        // In script mode, depends on type of tag\n      if (this.mode) {\n          // If '//' is found without a line break, add a line break.\n        switch (this.mode) {\n        case Template.modes.EVAL:\n        case Template.modes.ESCAPED:\n        case Template.modes.RAW:\n          if (line.lastIndexOf('//') > line.lastIndexOf('\\n')) {\n            line += '\\n';\n          }\n        }\n        switch (this.mode) {\n            // Just executing code\n        case Template.modes.EVAL:\n          this.source += '    ; ' + line + '\\n';\n          break;\n            // Exec, esc, and output\n        case Template.modes.ESCAPED:\n          this.source += '    ; __append(escape(' + stripSemi(line) + '))' + '\\n';\n          break;\n            // Exec and output\n        case Template.modes.RAW:\n          this.source += '    ; __append(' + stripSemi(line) + ')' + '\\n';\n          break;\n        case Template.modes.COMMENT:\n              // Do nothing\n          break;\n            // Literal <%% mode, append as raw output\n        case Template.modes.LITERAL:\n          _addOutput();\n          break;\n        }\n      }\n        // In string mode, just add the output\n      else {\n        _addOutput();\n      }\n    }\n\n    if (self.opts.compileDebug && newLineCount) {\n      this.currentLine += newLineCount;\n      this.source += '    ; __line = ' + this.currentLine + '\\n';\n    }\n  }\n};\n\n/**\n * Escape characters reserved in XML.\n *\n * This is simply an export of {@link module:utils.escapeXML}.\n *\n * If `markup` is `undefined` or `null`, the empty string is returned.\n *\n * @param {String} markup Input string\n * @return {String} Escaped string\n * @public\n * @func\n * */\nexports.escapeXML = utils.escapeXML;\n\n/**\n * Express.js support.\n *\n * This is an alias for {@link module:ejs.renderFile}, in order to support\n * Express.js out-of-the-box.\n *\n * @func\n */\n\nexports.__express = exports.renderFile;\n\n// Add require support\n/* istanbul ignore else */\nif (require.extensions) {\n  require.extensions['.ejs'] = function (module, flnm) {\n    var filename = flnm || /* istanbul ignore next */ module.filename;\n    var options = {\n      filename: filename,\n      client: true\n    };\n    var template = fs.readFileSync(filename).toString();\n    var fn = exports.compile(template, options);\n    module._compile('module.exports = ' + fn.toString() + ';', filename);\n  };\n}\n\n/**\n * Version of EJS.\n *\n * @readonly\n * @type {String}\n * @public\n */\n\nexports.VERSION = _VERSION_STRING;\n\n/* istanbul ignore if */\nif (typeof window != 'undefined') {\n  window.ejs = exports;\n}\n", "/* jshint mocha: true */\n/* eslint-env node, mocha */\n\n/**\n * Module dependencies.\n */\n\nvar ejs = require('..');\nvar fs = require('fs');\nvar read = fs.readFileSync;\nvar assert = require('assert');\nvar path = require('path');\nvar LRU = require('lru-cache');\n\ntry {\n  fs.mkdirSync(__dirname + '/tmp');\n} catch (ex) {\n  if (ex.code !== 'EEXIST') {\n    throw ex;\n  }\n}\n\n// From https://gist.github.com/pguillory/729616\nfunction hook_stdio(stream, callback) {\n  var old_write = stream.write;\n\n  stream.write = (function() {\n    return function(string, encoding, fd) {\n      callback(string, encoding, fd);\n    };\n  })(stream.write);\n\n  return function() {\n    stream.write = old_write;\n  };\n}\n\n/**\n * Load fixture `name`.\n */\n\nfunction fixture(name) {\n  return read('test/fixtures/' + name, 'utf8');\n}\n\n/**\n * User fixtures.\n */\n\nvar users = [];\nusers.push({name: 'geddy'});\nusers.push({name: 'neil'});\nusers.push({name: 'alex'});\n\nsuite('ejs.compile(str, options)', function () {\n  test('compile to a function', function () {\n    var fn = ejs.compile('<p>yay</p>');\n    assert.equal(fn(), '<p>yay</p>');\n  });\n\n  test('empty input works', function () {\n    var fn = ejs.compile('');\n    assert.equal(fn(), '');\n  });\n\n  test('throw if there are syntax errors', function () {\n    try {\n      ejs.compile(fixture('fail.ejs'));\n    }\n    catch (err) {\n      assert.ok(err.message.indexOf('compiling ejs') > -1);\n\n      try {\n        ejs.compile(fixture('fail.ejs'), {filename: 'fail.ejs'});\n      }\n      catch (err) {\n        assert.ok(err.message.indexOf('fail.ejs') > -1);\n        return;\n      }\n    }\n    throw new Error('no error reported when there should be');\n  });\n\n  test('allow customizing delimiter local var', function () {\n    var fn;\n    fn = ejs.compile('<p><?= name ?></p>', {delimiter: '?'});\n    assert.equal(fn({name: 'geddy'}), '<p>geddy</p>');\n\n    fn = ejs.compile('<p><:= name :></p>', {delimiter: ':'});\n    assert.equal(fn({name: 'geddy'}), '<p>geddy</p>');\n\n    fn = ejs.compile('<p><$= name $></p>', {delimiter: '$'});\n    assert.equal(fn({name: 'geddy'}), '<p>geddy</p>');\n  });\n\n  test('default to using ejs.delimiter', function () {\n    var fn;\n    ejs.delimiter = '&';\n    fn = ejs.compile('<p><&= name &></p>');\n    assert.equal(fn({name: 'geddy'}), '<p>geddy</p>');\n\n    fn = ejs.compile('<p><|= name |></p>', {delimiter: '|'});\n    assert.equal(fn({name: 'geddy'}), '<p>geddy</p>');\n    delete ejs.delimiter;\n  });\n\n  test('have a working client option', function () {\n    var fn;\n    var str;\n    var preFn;\n    fn = ejs.compile('<p><%= foo %></p>', {client: true});\n    str = fn.toString();\n    if (!process.env.running_under_istanbul) {\n      eval('var preFn = ' + str);\n      assert.equal(preFn({foo: 'bar'}), '<p>bar</p>');\n    }\n  });\n\n  test('support client mode without locals', function () {\n    var fn;\n    var str;\n    var preFn;\n    fn = ejs.compile('<p><%= \"foo\" %></p>', {client: true});\n    str = fn.toString();\n    if (!process.env.running_under_istanbul) {\n      eval('var preFn = ' + str);\n      assert.equal(preFn(), '<p>foo</p>');\n    }\n  });\n\n  test('not include rethrow() in client mode if compileDebug is false', function () {\n    var fn = ejs.compile('<p><%= \"foo\" %></p>', {\n      client: true,\n      compileDebug: false\n    });\n    // There could be a `rethrow` in the function declaration\n    assert((fn.toString().match(/rethrow/g) || []).length <= 1);\n  });\n\n  test('support custom escape function', function () {\n    var customEscape;\n    var fn;\n    customEscape = function customEscape(str) {\n      return !str ? '' : str.toUpperCase();\n    };\n    fn = ejs.compile('HELLO <%= name %>', {escape: customEscape});\n    assert.equal(fn({name: 'world'}), 'HELLO WORLD');\n  });\n\n  test('support custom escape function in client mode', function () {\n    var customEscape;\n    var fn;\n    var str;\n    customEscape = function customEscape(str) {\n      return !str ? '' : str.toUpperCase();\n    };\n    fn = ejs.compile('HELLO <%= name %>', {escape: customEscape, client: true});\n    str = fn.toString();\n    if (!process.env.running_under_istanbul) {\n      eval('var preFn = ' + str);\n      assert.equal(preFn({name: 'world'}), 'HELLO WORLD'); // eslint-disable-line no-undef\n    }\n  });\n\n  test('strict mode works', function () {\n    assert.equal(ejs.render(fixture('strict.ejs'), {}, {strict: true}), 'true');\n  });\n\n});\n\n/* Old API -- remove when this shim goes away */\nsuite('ejs.render(str, dataAndOpts)', function () {\n  test('render the template with data/opts passed together', function () {\n    assert.equal(ejs.render('<p><?= foo ?></p>', {foo: 'yay', delimiter: '?'}),\n        '<p>yay</p>');\n  });\n\n  test('disallow unsafe opts passed along in data', function () {\n    assert.equal(ejs.render('<p><?= locals.foo ?></p>',\n        // localsName should not get reset because it's blacklisted\n        {_with: false, foo: 'yay', delimiter: '?', localsName: '_'}),\n        '<p>yay</p>');\n  });\n});\n\nsuite('ejs.render(str, data, opts)', function () {\n  test('render the template', function () {\n    assert.equal(ejs.render('<p>yay</p>'), '<p>yay</p>');\n  });\n\n  test('empty input works', function () {\n    assert.equal(ejs.render(''), '');\n  });\n\n  test('undefined renders nothing escaped', function () {\n    assert.equal(ejs.render('<%= undefined %>'), '');\n  });\n\n  test('undefined renders nothing raw', function () {\n    assert.equal(ejs.render('<%- undefined %>'), '');\n  });\n\n  test('null renders nothing escaped', function () {\n    assert.equal(ejs.render('<%= null %>'), '');\n  });\n\n  test('null renders nothing raw', function () {\n    assert.equal(ejs.render('<%- null %>'), '');\n  });\n\n  test('zero-value data item renders something escaped', function () {\n    assert.equal(ejs.render('<%= 0 %>'), '0');\n  });\n\n  test('zero-value data object renders something raw', function () {\n    assert.equal(ejs.render('<%- 0 %>'), '0');\n  });\n\n  test('accept locals', function () {\n    assert.equal(ejs.render('<p><%= name %></p>', {name: 'geddy'}),\n        '<p>geddy</p>');\n  });\n\n  test('accept locals without using with() {}', function () {\n    assert.equal(ejs.render('<p><%= locals.name %></p>', {name: 'geddy'},\n                            {_with: false}),\n        '<p>geddy</p>');\n    assert.throws(function() {\n      ejs.render('<p><%= name %></p>', {name: 'geddy'},\n                 {_with: false});\n    }, /name is not defined/);\n  });\n\n  test('accept custom name for locals', function () {\n    ejs.localsName = 'it';\n    assert.equal(ejs.render('<p><%= it.name %></p>', {name: 'geddy'},\n                            {_with: false}),\n        '<p>geddy</p>');\n    assert.throws(function() {\n      ejs.render('<p><%= name %></p>', {name: 'geddy'},\n                 {_with: false});\n    }, /name is not defined/);\n    ejs.localsName = 'locals';\n  });\n\n  test('support caching', function () {\n    var file = __dirname + '/tmp/render.ejs';\n    var options = {cache: true, filename: file};\n    var out = ejs.render('<p>Old</p>', {}, options);\n    var expected = '<p>Old</p>';\n    assert.equal(out, expected);\n    // Assert no change, still in cache\n    out = ejs.render('<p>New</p>', {}, options);\n    assert.equal(out, expected);\n  });\n\n  test('support LRU caching', function () {\n    var oldCache = ejs.cache;\n    var file = __dirname + '/tmp/render.ejs';\n    var options = {cache: true, filename: file};\n    var out;\n    var expected = '<p>Old</p>';\n\n    // Switch to LRU\n    ejs.cache = LRU();\n\n    out = ejs.render('<p>Old</p>', {}, options);\n    assert.equal(out, expected);\n    // Assert no change, still in cache\n    out = ejs.render('<p>New</p>', {}, options);\n    assert.equal(out, expected);\n\n    // Restore system cache\n    ejs.cache = oldCache;\n  });\n\n  test('opts.context', function () {\n    var ctxt = {foo: 'FOO'};\n    var out = ejs.render('<%= this.foo %>', {}, {context: ctxt});\n    assert.equal(out, ctxt.foo);\n  });\n});\n\nsuite('ejs.renderFile(path, [data], [options], fn)', function () {\n  test('render a file', function(done) {\n    ejs.renderFile('test/fixtures/para.ejs', function(err, html) {\n      if (err) {\n        return done(err);\n      }\n      assert.equal(html, '<p>hey</p>\\n');\n      done();\n    });\n  });\n\n  test('accept locals', function(done) {\n    var data =  {name: 'fonebone'};\n    var options = {delimiter: '$'};\n    ejs.renderFile('test/fixtures/user.ejs', data, options, function(err, html) {\n      if (err) {\n        return done(err);\n      }\n      assert.equal(html, '<h1>fonebone</h1>\\n');\n      done();\n    });\n  });\n\n  test('accept locals without using with() {}', function(done) {\n    var data =  {name: 'fonebone'};\n    var options = {delimiter: '$', _with: false};\n    var doneCount = 0;\n    ejs.renderFile('test/fixtures/user-no-with.ejs', data, options, function(err, html) {\n      if (err) {\n        if (doneCount === 2) {\n          return;\n        }\n        doneCount = 2;\n        return done(err);\n      }\n      assert.equal(html, '<h1>fonebone</h1>\\n');\n      doneCount++;\n      if (doneCount === 2) {\n        done();\n      }\n    });\n    ejs.renderFile('test/fixtures/user.ejs', data, options, function(err) {\n      if (!err) {\n        if (doneCount === 2) {\n          return;\n        }\n        doneCount = 2;\n        return done(new Error('error not thrown'));\n      }\n      doneCount++;\n      if (doneCount === 2) {\n        done();\n      }\n    });\n  });\n\n  test('not catch err thrown by callback', function(done) {\n    var data =  {name: 'fonebone'};\n    var options = {delimiter: '$'};\n    var counter = 0;\n\n    var d = require('domain').create();\n    d.on('error', function (err) {\n      assert.equal(counter, 1);\n      assert.equal(err.message, 'Exception in callback');\n      done();\n    });\n    d.run(function () {\n      // process.nextTick() needed to work around mochajs/mocha#513\n      //\n      // tl;dr: mocha doesn't support synchronous exception throwing in\n      // domains. Have to make it async. Ticket closed because: \"domains are\n      // deprecated :D\"\n      process.nextTick(function () {\n        ejs.renderFile('test/fixtures/user.ejs', data, options, function(err) {\n          counter++;\n          if (err) {\n            assert.notEqual(err.message, 'Exception in callback');\n            return done(err);\n          }\n          throw new Error('Exception in callback');\n        });\n      });\n    });\n  });\n\n  test('support caching', function (done) {\n    var expected = '<p>Old</p>';\n    var file = __dirname + '/tmp/renderFile.ejs';\n    var options = {cache: true};\n    fs.writeFileSync(file, '<p>Old</p>');\n\n    ejs.renderFile(file, {}, options, function (err, out) {\n      if (err) {\n        done(err);\n      }\n      fs.writeFileSync(file, '<p>New</p>');\n      assert.equal(out, expected);\n\n      ejs.renderFile(file, {}, options, function (err, out) {\n        if (err) {\n          done(err);\n        }\n        // Assert no change, still in cache\n        assert.equal(out, expected);\n        done();\n      });\n    });\n  });\n\n  test('opts.context', function (done) {\n    var ctxt = {foo: 'FOO'};\n    ejs.renderFile('test/fixtures/with-context.ejs', {}, {context: ctxt}, function(err, html) {\n      if (err) {\n        return done(err);\n      }\n      assert.equal(html, ctxt.foo + '\\n');\n      done();\n    });\n\n  });\n});\n\nsuite('cache specific', function () {\n  test('`clearCache` work properly', function () {\n    var expected = '<p>Old</p>';\n    var file = __dirname + '/tmp/clearCache.ejs';\n    var options = {cache: true, filename: file};\n    var out = ejs.render('<p>Old</p>', {}, options);\n    assert.equal(out, expected);\n\n    ejs.clearCache();\n\n    expected = '<p>New</p>';\n    out = ejs.render('<p>New</p>', {}, options);\n    assert.equal(out, expected);\n  });\n\n  test('`clearCache` work properly, LRU', function () {\n    var expected = '<p>Old</p>';\n    var oldCache = ejs.cache;\n    var file = __dirname + '/tmp/clearCache.ejs';\n    var options = {cache: true, filename: file};\n    var out;\n\n    ejs.cache = LRU();\n\n    out = ejs.render('<p>Old</p>', {}, options);\n    assert.equal(out, expected);\n    ejs.clearCache();\n    expected = '<p>New</p>';\n    out = ejs.render('<p>New</p>', {}, options);\n    assert.equal(out, expected);\n\n    ejs.cache = oldCache;\n  });\n\n  test('LRU with cache-size 1', function () {\n    var oldCache = ejs.cache;\n    var options;\n    var out;\n    var expected;\n    var file;\n\n    ejs.cache = LRU(1);\n\n    file = __dirname + '/tmp/render1.ejs';\n    options = {cache: true, filename: file};\n    out = ejs.render('<p>File1</p>', {}, options);\n    expected = '<p>File1</p>';\n    assert.equal(out, expected);\n\n    // Same filename, different template, but output\n    // should be the same because cache\n    file = __dirname + '/tmp/render1.ejs';\n    options = {cache: true, filename: file};\n    out = ejs.render('<p>ChangedFile1</p>', {}, options);\n    expected = '<p>File1</p>';\n    assert.equal(out, expected);\n\n    // Different filiename -- output should be different,\n    // and previous cache-entry should be evicted\n    file = __dirname + '/tmp/render2.ejs';\n    options = {cache: true, filename: file};\n    out = ejs.render('<p>File2</p>', {}, options);\n    expected = '<p>File2</p>';\n    assert.equal(out, expected);\n\n    // Entry with first filename should now be out of cache,\n    // results should be different\n    file = __dirname + '/tmp/render1.ejs';\n    options = {cache: true, filename: file};\n    out = ejs.render('<p>ChangedFile1</p>', {}, options);\n    expected = '<p>ChangedFile1</p>';\n    assert.equal(out, expected);\n\n    ejs.cache = oldCache;\n  });\n});\n\nsuite('<%', function () {\n  test('without semicolons', function () {\n    assert.equal(ejs.render(fixture('no.semicolons.ejs')),\n        fixture('no.semicolons.html'));\n  });\n});\n\nsuite('<%=', function () {\n  test('should not throw an error with a // comment on the final line', function () {\n    assert.equal(ejs.render('<%=\\n// a comment\\nname\\n// another comment %>', {name: '&nbsp;<script>'}),\n      '&amp;nbsp;&lt;script&gt;');\n  });\n\n  test('escape &amp;<script>', function () {\n    assert.equal(ejs.render('<%= name %>', {name: '&nbsp;<script>'}),\n        '&amp;nbsp;&lt;script&gt;');\n  });\n\n  test('should escape \\'', function () {\n    assert.equal(ejs.render('<%= name %>', {name: 'The Jones\\'s'}),\n      'The Jones&#39;s');\n  });\n\n  test('should escape &foo_bar;', function () {\n    assert.equal(ejs.render('<%= name %>', {name: '&foo_bar;'}),\n      '&amp;foo_bar;');\n  });\n\n  test('should accept custom function', function() {\n\n    var customEscape = function customEscape(str) {\n      return !str ? '' : str.toUpperCase();\n    };\n\n    assert.equal(\n      ejs.render('<%= name %>', {name: 'The Jones\\'s'}, {escape: customEscape}),\n      'THE JONES\\'S'\n    );\n  });\n});\n\nsuite('<%-', function () {\n  test('should not throw an error with a // comment on the final line', function () {\n    assert.equal(ejs.render('<%-\\n// a comment\\nname\\n// another comment %>', {name: '&nbsp;<script>'}),\n        '&nbsp;<script>');\n  });\n\n  test('not escape', function () {\n    assert.equal(ejs.render('<%- name %>', {name: '<script>'}),\n        '<script>');\n  });\n\n  test('terminate gracefully if no close tag is found', function () {\n    try {\n      ejs.compile('<h1>oops</h1><%- name ->');\n      throw new Error('Expected parse failure');\n    }\n    catch (err) {\n      assert.ok(err.message.indexOf('Could not find matching close tag for') > -1);\n    }\n  });\n});\n\nsuite('%>', function () {\n  test('produce newlines', function () {\n    assert.equal(ejs.render(fixture('newlines.ejs'), {users: users}),\n      fixture('newlines.html'));\n  });\n  test('works with `-%>` interspersed', function () {\n    assert.equal(ejs.render(fixture('newlines.mixed.ejs'), {users: users}),\n      fixture('newlines.mixed.html'));\n  });\n  test('consecutive tags work', function () {\n    assert.equal(ejs.render(fixture('consecutive-tags.ejs')),\n      fixture('consecutive-tags.html'));\n  });\n});\n\nsuite('-%>', function () {\n  test('not produce newlines', function () {\n    assert.equal(ejs.render(fixture('no.newlines.ejs'), {users: users}),\n      fixture('no.newlines.html'));\n  });\n  test('stack traces work', function () {\n    try {\n      ejs.render(fixture('no.newlines.error.ejs'));\n    }\n    catch (e) {\n      if (e.message.indexOf('>> 4| <%= qdata %>') > -1) {\n        return;\n      }\n      throw e;\n    }\n    throw new Error('Expected ReferenceError');\n  });\n\n  test('works with unix style', function () {\n    var content = '<ul><% -%>\\n'\n    + '<% users.forEach(function(user){ -%>\\n'\n    + '<li><%= user.name -%></li>\\n'\n    + '<% }) -%>\\n'\n    + '</ul><% -%>\\n';\n\n    var expectedResult = '<ul><li>geddy</li>\\n<li>neil</li>\\n<li>alex</li>\\n</ul>';\n    var fn;\n    fn = ejs.compile(content);\n    assert.equal(fn({users: users}),\n      expectedResult);\n  });\n\n  test('works with windows style', function () {\n    var content = '<ul><% -%>\\r\\n'\n    + '<% users.forEach(function(user){ -%>\\r\\n'\n    + '<li><%= user.name -%></li>\\r\\n'\n    + '<% }) -%>\\r\\n'\n    + '</ul><% -%>\\r\\n';\n\n    var expectedResult = '<ul><li>geddy</li>\\r\\n<li>neil</li>\\r\\n<li>alex</li>\\r\\n</ul>';\n    var fn;\n    fn = ejs.compile(content);\n    assert.equal(fn({users: users}),\n      expectedResult);\n  });\n});\n\nsuite('<%%', function () {\n  test('produce literals', function () {\n    assert.equal(ejs.render('<%%- \"foo\" %>'),\n      '<%- \"foo\" %>');\n  });\n  test('work without an end tag', function () {\n    assert.equal(ejs.render('<%%'), '<%');\n    assert.equal(ejs.render(fixture('literal.ejs'), {}, {delimiter: ' '}),\n      fixture('literal.html'));\n  });\n});\n\nsuite('%%>', function () {\n  test('produce literal', function () {\n    assert.equal(ejs.render('%%>'),\n        '%>');\n    assert.equal(ejs.render('  >', {}, {delimiter: ' '}),\n        ' >');\n  });\n});\n\nsuite('<%_ and _%>', function () {\n  test('slurps spaces and tabs', function () {\n    assert.equal(ejs.render(fixture('space-and-tab-slurp.ejs'), {users: users}),\n      fixture('space-and-tab-slurp.html'));\n  });\n});\n\nsuite('single quotes', function () {\n  test('not mess up the constructed function', function () {\n    assert.equal(ejs.render(fixture('single-quote.ejs')),\n      fixture('single-quote.html'));\n  });\n});\n\nsuite('double quotes', function () {\n  test('not mess up the constructed function', function () {\n    assert.equal(ejs.render(fixture('double-quote.ejs')),\n      fixture('double-quote.html'));\n  });\n});\n\nsuite('backslashes', function () {\n  test('escape', function () {\n    assert.equal(ejs.render(fixture('backslash.ejs')),\n      fixture('backslash.html'));\n  });\n});\n\nsuite('messed up whitespace', function () {\n  test('work', function () {\n    assert.equal(ejs.render(fixture('messed.ejs'), {users: users}),\n      fixture('messed.html'));\n  });\n});\n\nsuite('exceptions', function () {\n  test('produce useful stack traces', function () {\n    try {\n      ejs.render(fixture('error.ejs'), {}, {filename: 'error.ejs'});\n    }\n    catch (err) {\n      assert.equal(err.path, 'error.ejs');\n      assert.equal(err.stack.split('\\n').slice(0, 8).join('\\n'), fixture('error.out'));\n      return;\n    }\n    throw new Error('no error reported when there should be');\n  });\n\n  test('not include fancy stack info if compileDebug is false', function () {\n    try {\n      ejs.render(fixture('error.ejs'), {}, {\n        filename: 'error.ejs',\n        compileDebug: false\n      });\n    }\n    catch (err) {\n      assert.ok(!err.path);\n      assert.notEqual(err.stack.split('\\n').slice(0, 8).join('\\n'), fixture('error.out'));\n      return;\n    }\n    throw new Error('no error reported when there should be');\n  });\n\n  var unhook = null;\n  test('log JS source when debug is set', function (done) {\n    var out = '';\n    var needToExit = false;\n    unhook = hook_stdio(process.stdout, function (str) {\n      out += str;\n      if (needToExit) {\n        return;\n      }\n      if (out.indexOf('__output')) {\n        needToExit = true;\n        unhook();\n        unhook = null;\n        return done();\n      }\n    });\n    ejs.render(fixture('hello-world.ejs'), {}, {debug: true});\n  });\n  teardown(function() {\n    if (!unhook) {\n      return;\n    }\n    unhook();\n    unhook = null;\n  });\n});\n\nsuite('rmWhitespace', function () {\n  test('works', function () {\n    assert.equal(ejs.render(fixture('rmWhitespace.ejs'), {}, {rmWhitespace: true}),\n        fixture('rmWhitespace.html'));\n  });\n});\n\nsuite('include()', function () {\n  test('include ejs', function () {\n    var file = 'test/fixtures/include-simple.ejs';\n    assert.equal(ejs.render(fixture('include-simple.ejs'), {}, {filename: file}),\n        fixture('include-simple.html'));\n  });\n\n  test('include ejs fails without `filename`', function () {\n    try {\n      ejs.render(fixture('include-simple.ejs'));\n    }\n    catch (err) {\n      assert.ok(err.message.indexOf('requires the \\'filename\\' option') > -1);\n      return;\n    }\n    throw new Error('expected inclusion error');\n  });\n\n  test('strips BOM', function () {\n    assert.equal(\n      ejs.render('<%- include(\"fixtures/includes/bom.ejs\") %>',\n        {}, {filename: path.join(__dirname, 'f.ejs')}),\n      '<p>This is a file with BOM.</p>\\n');\n  });\n\n  test('include ejs with locals', function () {\n    var file = 'test/fixtures/include.ejs';\n    assert.equal(ejs.render(fixture('include.ejs'), {pets: users}, {filename: file, delimiter: '@'}),\n        fixture('include.html'));\n  });\n\n  test('include ejs with absolute path and locals', function () {\n    var file = 'test/fixtures/include-abspath.ejs';\n    assert.equal(ejs.render(fixture('include-abspath.ejs'),\n      {dir: path.join(__dirname, 'fixtures'), pets: users, path: path},\n      {filename: file, delimiter: '@'}),\n        fixture('include.html'));\n  });\n\n  test('include ejs with set root path', function () {\n    var file = 'test/fixtures/include-root.ejs';\n    var viewsPath = path.join(__dirname, 'fixtures');\n    assert.equal(ejs.render(fixture('include-root.ejs'), {pets: users}, {filename: file, delimiter: '@',root:viewsPath}),\n      fixture('include.html'));\n  });\n\n  test('work when nested', function () {\n    var file = 'test/fixtures/menu.ejs';\n    assert.equal(ejs.render(fixture('menu.ejs'), {pets: users}, {filename: file}),\n        fixture('menu.html'));\n  });\n\n  test('work with a variable path', function () {\n    var file = 'test/fixtures/menu_var.ejs';\n    var includePath = 'includes/menu-item';\n    assert.equal(ejs.render(fixture('menu.ejs'), {pets: users, varPath:  includePath}, {filename: file}),\n      fixture('menu.html'));\n  });\n\n  test('include arbitrary files as-is', function () {\n    var file = 'test/fixtures/include.css.ejs';\n    assert.equal(ejs.render(fixture('include.css.ejs'), {pets: users}, {filename: file}),\n        fixture('include.css.html'));\n  });\n\n  test('pass compileDebug to include', function () {\n    var file = 'test/fixtures/include.ejs';\n    var fn;\n    fn = ejs.compile(fixture('include.ejs'), {\n      filename: file,\n      delimiter: '@',\n      compileDebug: false\n    });\n    try {\n      // Render without a required variable reference\n      fn({foo: 'asdf'});\n    }\n    catch(e) {\n      assert.equal(e.message, 'pets is not defined');\n      assert.ok(!e.path);\n      return;\n    }\n    throw new Error('no error reported when there should be');\n  });\n\n  test('is dynamic', function () {\n    fs.writeFileSync(__dirname + '/tmp/include.ejs', '<p>Old</p>');\n    var file = 'test/fixtures/include_cache.ejs';\n    var options = {filename: file};\n    var out = ejs.compile(fixture('include_cache.ejs'), options);\n    assert.equal(out(), '<p>Old</p>\\n');\n\n    fs.writeFileSync(__dirname + '/tmp/include.ejs', '<p>New</p>');\n    assert.equal(out(), '<p>New</p>\\n');\n  });\n\n  test('support caching', function () {\n    fs.writeFileSync(__dirname + '/tmp/include.ejs', '<p>Old</p>');\n    var file = 'test/fixtures/include_cache.ejs';\n    var options = {cache: true, filename: file};\n    var out = ejs.render(fixture('include_cache.ejs'), {}, options);\n    var expected = fixture('include_cache.html');\n    assert.equal(out, expected);\n    out = ejs.render(fixture('include_cache.ejs'), {}, options);\n    // No change, still in cache\n    assert.equal(out, expected);\n    fs.writeFileSync(__dirname + '/tmp/include.ejs', '<p>New</p>');\n    out = ejs.render(fixture('include_cache.ejs'), {}, options);\n    assert.equal(out, expected);\n  });\n\n});\n\nsuite('preprocessor include', function () {\n  test('work', function () {\n    var file = 'test/fixtures/include_preprocessor.ejs';\n    assert.equal(ejs.render(fixture('include_preprocessor.ejs'), {pets: users}, {filename: file, delimiter: '@'}),\n        fixture('include_preprocessor.html'));\n  });\n\n  test('no false positives', function () {\n    assert.equal(ejs.render('<% %> include foo <% %>'), ' include foo ');\n  });\n\n  test('fails without `filename`', function () {\n    try {\n      ejs.render(fixture('include_preprocessor.ejs'), {pets: users}, {delimiter: '@'});\n    }\n    catch (err) {\n      assert.ok(err.message.indexOf('requires the \\'filename\\' option') > -1);\n      return;\n    }\n    throw new Error('expected inclusion error');\n  });\n\n  test('strips BOM', function () {\n    assert.equal(\n      ejs.render('<% include fixtures/includes/bom.ejs %>',\n        {}, {filename: path.join(__dirname, 'f.ejs')}),\n      '<p>This is a file with BOM.</p>\\n');\n  });\n\n  test('work when nested', function () {\n    var file = 'test/fixtures/menu_preprocessor.ejs';\n    assert.equal(ejs.render(fixture('menu_preprocessor.ejs'), {pets: users}, {filename: file}),\n        fixture('menu_preprocessor.html'));\n  });\n\n  test('tracks dependency correctly', function () {\n    var file = 'test/fixtures/menu_preprocessor.ejs';\n    var fn = ejs.compile(fixture('menu_preprocessor.ejs'), {filename: file});\n    assert(fn.dependencies.length);\n  });\n\n  test('include arbitrary files as-is', function () {\n    var file = 'test/fixtures/include_preprocessor.css.ejs';\n    assert.equal(ejs.render(fixture('include_preprocessor.css.ejs'), {pets: users}, {filename: file}),\n        fixture('include_preprocessor.css.html'));\n  });\n\n  test('pass compileDebug to include', function () {\n    var file = 'test/fixtures/include_preprocessor.ejs';\n    var fn;\n    fn = ejs.compile(fixture('include_preprocessor.ejs'), {\n      filename: file,\n      delimiter: '@',\n      compileDebug: false\n    });\n    try {\n      // Render without a required variable reference\n      fn({foo: 'asdf'});\n    }\n    catch(e) {\n      assert.equal(e.message, 'pets is not defined');\n      assert.ok(!e.path);\n      return;\n    }\n    throw new Error('no error reported when there should be');\n  });\n\n  test('is static', function () {\n    fs.writeFileSync(__dirname + '/tmp/include_preprocessor.ejs', '<p>Old</p>');\n    var file = 'test/fixtures/include_preprocessor_cache.ejs';\n    var options = {filename: file};\n    var out = ejs.compile(fixture('include_preprocessor_cache.ejs'), options);\n    assert.equal(out(), '<p>Old</p>\\n');\n\n    fs.writeFileSync(__dirname + '/tmp/include_preprocessor.ejs', '<p>New</p>');\n    assert.equal(out(), '<p>Old</p>\\n');\n  });\n\n  test('support caching', function () {\n    fs.writeFileSync(__dirname + '/tmp/include_preprocessor.ejs', '<p>Old</p>');\n    var file = 'test/fixtures/include_preprocessor_cache.ejs';\n    var options = {cache: true, filename: file};\n    var out = ejs.render(fixture('include_preprocessor_cache.ejs'), {}, options);\n    var expected = fixture('include_preprocessor_cache.html');\n    assert.equal(out, expected);\n    fs.writeFileSync(__dirname + '/tmp/include_preprocessor.ejs', '<p>New</p>');\n    out = ejs.render(fixture('include_preprocessor_cache.ejs'), {}, options);\n    assert.equal(out, expected);\n  });\n\n  test('whitespace slurp and rmWhitespace work', function() {\n    var file = 'test/fixtures/include_preprocessor_line_slurp.ejs';\n    var template = fixture('include_preprocessor_line_slurp.ejs');\n    var expected = fixture('include_preprocessor_line_slurp.html');\n    var options = {rmWhitespace: true, filename: file};\n    assert.equal(ejs.render(template, {}, options),\n        expected);\n  });\n\n});\n\nsuite('comments', function () {\n  test('fully render with comments removed', function () {\n    assert.equal(ejs.render(fixture('comments.ejs')),\n        fixture('comments.html'));\n  });\n});\n\nsuite('require', function () {\n\n  // Only works with inline/preprocessor includes\n  test('allow ejs templates to be required as node modules', function () {\n    var file = 'test/fixtures/include_preprocessor.ejs';\n    var template = require(__dirname + '/fixtures/menu_preprocessor.ejs');\n    if (!process.env.running_under_istanbul) {\n      assert.equal(template({filename: file, pets: users}),\n          fixture('menu_preprocessor.html'));\n    }\n  });\n});\n\nsuite('examples', function () {\n  function noop () {}\n  fs.readdirSync('examples').forEach(function (f) {\n    if (!/\\.js$/.test(f)) {\n      return;\n    }\n    suite(f, function () {\n      test('doesn\\'t throw any errors', function () {\n        var stderr = hook_stdio(process.stderr, noop);\n        var stdout = hook_stdio(process.stdout, noop);\n        try {\n          require('../examples/' + f);\n        }\n        catch (ex) {\n          stdout();\n          stderr();\n          throw ex;\n        }\n        stdout();\n        stderr();\n      });\n    });\n  });\n});\n"], "filenames": ["lib/ejs.js", "test/ejs.js"], "buggy_code_start_loc": [58, 168], "buggy_code_end_loc": [276, 922], "fixing_code_start_loc": [59, 169], "fixing_code_end_loc": [280, 936], "type": "CWE-79", "message": "nodejs ejs version older than 2.5.5 is vulnerable to a Cross-site-scripting in the ejs.renderFile() resulting in code injection", "other": {"cve": {"id": "CVE-2017-1000188", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-17T03:29:00.267", "lastModified": "2017-11-30T11:57:32.303", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "nodejs ejs version older than 2.5.5 is vulnerable to a Cross-site-scripting in the ejs.renderFile() resulting in code injection"}, {"lang": "es", "value": "ejs de nodejs en versiones anteriores a la 2.5.5 es vulnerable a Cross-Site Scripting (XSS) en la funci\u00f3n ejs.renderFile(), provocando una inyecci\u00f3n de c\u00f3digo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ejs:ejs:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.5.5", "matchCriteriaId": "CDD07DBF-3C84-4096-9711-16FB3112F848"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/101889", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/mde/ejs/commit/49264e0037e313a0a3e033450b5c184112516d8f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mde/ejs/commit/49264e0037e313a0a3e033450b5c184112516d8f"}}