{"buggy_code": ["/*\n\n Copyright 2016 Christian Hoene, Symonics GmbH\n\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <errno.h>\n#include <assert.h>\n#include <inttypes.h>\n#include \"reader.h\"\n\nstatic int log2i(int a) {\n\treturn round(log2(a));\n}\n\nstatic int directblockRead(struct READER *reader, struct DATAOBJECT *dataobject,\n\t\tstruct FRACTALHEAP *fractalheap) {\n\n\tchar buf[4], *name, *value;\n\tint size, offset_size, length_size, err, len;\n\tuint8_t typeandversion;\n\tuint64_t unknown, heap_header_address, block_offset, block_size, offset,\n\t\t\tlength;\n\tlong store;\n\tstruct DIR *dir;\n\tstruct MYSOFA_ATTRIBUTE *attr;\n\n\tUNUSED(offset);\n\tUNUSED(block_size);\n\tUNUSED(block_offset);\n\n\t/* read signature */\n\tif (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"FHDB\", 4)) {\n\t\tlog(\"cannot read signature of fractal heap indirect block\\n\");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t}\n\tlog(\"%08\" PRIX64 \" %.4s\\n\", (uint64_t )ftell(reader->fhd) - 4, buf);\n\n\tif (fgetc(reader->fhd) != 0) {\n\t\tlog(\"object FHDB must have version 0\\n\");\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t}\n\n\t/* ignore heap_header_address */\n\tif (fseek(reader->fhd, reader->superblock.size_of_offsets, SEEK_CUR) < 0)\n\t\treturn errno;\n\n\tsize = (fractalheap->maximum_heap_size + 7) / 8;\n\tblock_offset = readValue(reader, size);\n\n\tif (fractalheap->flags & 2)\n\t\tif (fseek(reader->fhd, 4, SEEK_CUR))\n\t\t\treturn errno;\n\n\toffset_size = ceilf(log2f(fractalheap->maximum_heap_size) / 8);\n\tif (fractalheap->maximum_direct_block_size < fractalheap->maximum_size)\n\t\tlength_size = ceilf(log2f(fractalheap->maximum_direct_block_size) / 8);\n\telse\n\t\tlength_size = ceilf(log2f(fractalheap->maximum_size) / 8);\n\n\tlog(\" %d %\" PRIu64 \" %d\\n\",size,block_offset,offset_size);\n\n\t/*\n\t * 00003e00  00 46 48 44 42 00 40 02  00 00 00 00 00 00 00 00  |.FHDB.@.........|\n\t 00003e10  00 00 00 83 8d ac f6 >03  00 0c 00 08 00 04 00 00  |................|\n\t 00003e20  43 6f 6e 76 65 6e 74 69  6f 6e 73 00 13 00 00 00  |Conventions.....|\n\t 00003e30  04 00 00 00 02 00 00 00  53 4f 46 41< 03 00 08 00  |........SOFA....|\n\t 00003e40  08 00 04 00 00 56 65 72  73 69 6f 6e 00 13 00 00  |.....Version....|\n\t 00003e50  00 03 00 00 00 02 00 00  00 30 2e 36 03 00 10 00  |.........0.6....|\n\t 00003e60  08 00 04 00 00 53 4f 46  41 43 6f 6e 76 65 6e 74  |.....SOFAConvent|\n\t 00003e70  69 6f 6e 73 00 13 00 00  00 13 00 00 00 02 00 00  |ions............|\n\t 00003e80  00 53 69 6d 70 6c 65 46  72 65 65 46 69 65 6c 64  |.SimpleFreeField|\n\t 00003e90  48 52 49 52 03 00 17 00  08 00 04 00 00 53 4f 46  |HRIR.........SOF|\n\t 00003ea0  41 43 6f 6e 76 65 6e 74  69 6f 6e 73 56 65 72 73  |AConventionsVers|\n\t 00003eb0  69 6f 6e 00 13 00 00 00  03 00 00 00 02 00 00 00  |ion.............|\n\t *\n\t */\n\tdo {\n\t\ttypeandversion = (uint8_t) fgetc(reader->fhd);\n\t\toffset = readValue(reader, offset_size);\n\t\tlength = readValue(reader, length_size);\n\t\tif (offset > 0x10000000 || length > 0x10000000)\n\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\n\t\tlog(\" %d %4\" PRIX64 \" %\" PRIX64 \" %08lX\\n\",typeandversion,offset,length,ftell(reader->fhd));\n\n\t\t/* TODO: for the following part, the specification is incomplete */\n\t\tif (typeandversion == 3) {\n\t\t\t/*\n\t\t\t * this seems to be a name and value pair\n\t\t\t */\n\n\t\t\tif (readValue(reader, 5) != 0x0000040008) {\n\t\t\t\tlog(\"FHDB type 3 unsupported values\");\n\t\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t\t\t}\n\n\t\t\tif (!(name = malloc(length+1)))\n\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\tif (fread(name, 1, length, reader->fhd) != length) {\n\t\t\t\tfree(name);\n\t\t\t\treturn MYSOFA_READ_ERROR;\n\t\t\t}\n\t\t\tname[length]=0;\t\n\n\t\t\tif (readValue(reader, 4) != 0x00000013) {\n\t\t\t\tlog(\"FHDB type 3 unsupported values\");\n\t\t\t\tfree(name);\n\t\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t\t\t}\n\n\t\t\tlen = (int) readValue(reader, 2);\n\t\t\tif (len > 0x1000 || len < 0) {\n\t\t\t\tfree(name);\n\t\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t\t\t}\n\n\t\t\t/* TODO: Get definition of this field */\n\t\t\tunknown = readValue(reader, 6);\n\t\t\tif (unknown == 0x000000020200)\n\t\t\t\tvalue = NULL;\n\t\t\telse if (unknown == 0x000000020000) {\n\t\t\t\tif (!(value = malloc(len + 1))) {\n\t\t\t\t\tfree(name);\n\t\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\t\t}\n\t\t\t\tif (fread(value, 1, len, reader->fhd) != len) {\n\t\t\t\t\tfree(value);\n\t\t\t\t\tfree(name);\n\t\t\t\t\treturn MYSOFA_READ_ERROR;\n\t\t\t\t}\n\t\t\t\tvalue[len] = 0;\n\t\t\t} else if (unknown == 0x20000020000) {\n\t\t\t\tif (!(value = malloc(5))) {\n\t\t\t\t\tfree(name);\n\t\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\t\t}\n\t\t\t\tstrcpy(value, \"\");\n\t\t\t} else {\n\t\t\t\tlog(\"FHDB type 3 unsupported values: %12\" PRIX64 \"\\n\",unknown);\n\t\t\t\tfree(name);\n\t\t\t\t/* TODO:\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT; */\n\t\t\t\treturn MYSOFA_OK;\n\t\t\t} \n\t\t\tlog(\" %s = %s\\n\", name, value);\n\n\t\t\tattr = malloc(sizeof(struct MYSOFA_ATTRIBUTE));\n\t\t\tattr->name = name;\n\t\t\tattr->value = value;\n\t\t\tattr->next = dataobject->attributes;\n\t\t\tdataobject->attributes = attr;\n\n\t\t} else if (typeandversion == 1) {\n\t\t\t/*\n\t\t\t * pointer to another data object\n\t\t\t */\n\t\t\tunknown = readValue(reader, 6);\n\t\t\tif (unknown) {\n\t\t\t\tlog(\"FHDB type 1 unsupported values\\n\");\n\t\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t\t\t}\n\n\t\t\tlen = fgetc(reader->fhd);\n\t\t\tif (len < 0)\n\t\t\t\treturn MYSOFA_READ_ERROR;\n\t\t\tassert(len < 0x100);\n\n\t\t\tif (!(name = malloc(len + 1)))\n\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\tif (fread(name, 1, len, reader->fhd) != len) {\n\t\t\t\tfree(name);\n\t\t\t\treturn MYSOFA_READ_ERROR;\n\t\t\t}\n\t\t\tname[len] = 0;\n\n\t\t\theap_header_address = readValue(reader,\n\t\t\t\t\treader->superblock.size_of_offsets);\n\n\t\t\tlog(\"\\nfractal head type 1 length %4\" PRIX64 \" name %s address %\" PRIX64 \"\\n\", length, name, heap_header_address);\n\n\t\t\tdir = malloc(sizeof(struct DIR));\n\t\t\tif (!dir) {\n\t\t\t\tfree(name);\n\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\t}\n\t\t\tmemset(dir, 0, sizeof(*dir));\n\n\t\t\tdir->next = dataobject->directory;\n\t\t\tdataobject->directory = dir;\n\n\t\t\tstore = ftell(reader->fhd);\n\t\t\tif (fseek(reader->fhd, heap_header_address, SEEK_SET)) {\n\t\t\t\tfree(name);\n\t\t\t\treturn errno;\n\t\t\t}\n\n\t\t\terr = dataobjectRead(reader, &dir->dataobject, name);\n\t\t\tif (err) {\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tif (store < 0) {\n\t\t\t\treturn errno;\n\t\t\t}\n\t\t\tif (fseek(reader->fhd, store, SEEK_SET) < 0)\n\t\t\t\treturn errno;\n\n\t\t} else if (typeandversion != 0) {\n\t\t\t/* TODO is must be avoided somehow */\n\t\t\tlog(\"fractal head unknown type %d\\n\", typeandversion);\n\t\t\t/*\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT; */\n\t\t\treturn MYSOFA_OK;\n\t\t}\n\n\t} while (typeandversion != 0);\n\n\treturn MYSOFA_OK;\n}\n\n/*  III.G. Disk Format: Level 1G - Fractal Heap\n * indirect block\n */\n\nstatic int indirectblockRead(struct READER *reader,\n\t\tstruct DATAOBJECT *dataobject, struct FRACTALHEAP *fractalheap,\n\t\tuint64_t iblock_size) {\n\tint size, nrows, max_dblock_rows, k, n, err;\n\tuint32_t filter_mask;\n\tuint64_t heap_header_address, block_offset, child_direct_block = 0,\n\t\t\tsize_filtered, child_indirect_block;\n\tlong store;\n\n\tchar buf[4];\n\n\tUNUSED(size_filtered);\n\tUNUSED(heap_header_address);\n\tUNUSED(filter_mask);\n\n\t/* read signature */\n\tif (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"FHIB\", 4)) {\n\t\tlog(\"cannot read signature of fractal heap indirect block\\n\");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t}\n\tlog(\"%08\" PRIX64 \" %.4s\\n\", (uint64_t )ftell(reader->fhd) - 4, buf);\n\n\tif (fgetc(reader->fhd) != 0) {\n\t\tlog(\"object FHIB must have version 0\\n\");\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t}\n\n\t/* ignore it */\n\theap_header_address = readValue(reader, reader->superblock.size_of_offsets);\n\n\tsize = (fractalheap->maximum_heap_size + 7) / 8;\n\tblock_offset = readValue(reader, size);\n\n\tif (block_offset) {\n\t\tlog(\"FHIB block offset is not 0\\n\");\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t}\n\n\t/*\t The number of rows of blocks, nrows, in an indirect block of size iblock_size is given by the following expression: */\n\tnrows = (log2i(iblock_size) - log2i(fractalheap->starting_block_size)) + 1;\n\n\t/* The maximum number of rows of direct blocks, max_dblock_rows, in any indirect block of a fractal heap is given by the following expression: */\n\tmax_dblock_rows = (log2i(fractalheap->maximum_direct_block_size)\n\t\t\t- log2i(fractalheap->starting_block_size)) + 2;\n\n\t/* Using the computed values for nrows and max_dblock_rows, along with the Width of the doubling table, the number of direct and indirect block entries (K and N in the indirect block description, below) in an indirect block can be computed: */\n\tif (nrows < max_dblock_rows)\n\t\tk = nrows * fractalheap->table_width;\n\telse\n\t\tk = max_dblock_rows * fractalheap->table_width;\n\n\t/* If nrows is less than or equal to max_dblock_rows, N is 0. Otherwise, N is simply computed: */\n\tn = k - (max_dblock_rows * fractalheap->table_width);\n\n\twhile (k > 0) {\n\t\tchild_direct_block = readValue(reader,\n\t\t\t\treader->superblock.size_of_offsets);\n\t\tif (fractalheap->encoded_length > 0) {\n\t\t\tsize_filtered = readValue(reader,\n\t\t\t\t\treader->superblock.size_of_lengths);\n\t\t\tfilter_mask = readValue(reader, 4);\n\t\t}\n\t\tlog(\">> %d %\" PRIX64 \" %d\\n\",k,child_direct_block,size);\n\t\tif (validAddress(reader, child_direct_block)) {\n\t\t\tstore = ftell(reader->fhd);\n\t\t\tif (fseek(reader->fhd, child_direct_block, SEEK_SET) < 0)\n\t\t\t\treturn errno;\n\t\t\terr = directblockRead(reader, dataobject, fractalheap);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (store < 0)\n\t\t\t\treturn MYSOFA_READ_ERROR;\n\t\t\tif (fseek(reader->fhd, store, SEEK_SET) < 0)\n\t\t\t\treturn errno;\n\t\t}\n\n\t\tk--;\n\t}\n\n\twhile (n > 0) {\n\t\tchild_indirect_block = readValue(reader,\n\t\t\t\treader->superblock.size_of_offsets);\n\n\t\tif (validAddress(reader, child_direct_block)) {\n\t\t\tstore = ftell(reader->fhd);\n\t\t\tif (fseek(reader->fhd, child_indirect_block, SEEK_SET) < 0)\n\t\t\t\treturn errno;\n\t\t\terr = indirectblockRead(reader, dataobject, fractalheap,\n\t\t\t\t\tiblock_size * 2);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (store < 0)\n\t\t\t\treturn MYSOFA_READ_ERROR;\n\t\t\tif (fseek(reader->fhd, store, SEEK_SET) < 0)\n\t\t\t\treturn errno;\n\t\t}\n\n\t\tn--;\n\t}\n\n\treturn MYSOFA_OK;\n}\n\n/*  III.G. Disk Format: Level 1G - Fractal Heap\n\n 00000240  46 52 48 50 00 08 00 00  00 02 00 10 00 00 00 00  |FRHP............|\n 00000250  00 00 00 00 00 00 ff ff  ff ff ff ff ff ff a3 0b  |................|\n 00000260  00 00 00 00 00 00 1e 03  00 00 00 00 00 00 00 10  |................|\n 00000270  00 00 00 00 00 00 00 08  00 00 00 00 00 00 00 08  |................|\n 00000280  00 00 00 00 00 00 16 00  00 00 00 00 00 00 00 00  |................|\n 00000290  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n 000002a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 04 00  |................|\n 000002b0  00 04 00 00 00 00 00 00  00 00 01 00 00 00 00 00  |................|\n 000002c0  28 00 01 00 29 32 00 00  00 00 00 00 01 00 60 49  |(...)2........`I|\n 000002d0  32 1d 42 54 48 44 00 08  00 02 00 00 11 00 00 00  |2.BTHD..........|\n\n */\n\nint fractalheapRead(struct READER *reader, struct DATAOBJECT *dataobject,\n\t\tstruct FRACTALHEAP *fractalheap) {\n\tint err;\n\tchar buf[4];\n\n\t/* read signature */\n\tif (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"FRHP\", 4)) {\n\t\tlog(\"cannot read signature of fractal heap\\n\");\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t}\n\tlog(\"%\" PRIX64 \" %.4s\\n\", (uint64_t )ftell(reader->fhd) - 4, buf);\n\n\tif (fgetc(reader->fhd) != 0) {\n\t\tlog(\"object fractal heap must have version 0\\n\");\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t}\n\n\tfractalheap->heap_id_length = (uint16_t) readValue(reader, 2);\n\tfractalheap->encoded_length = (uint16_t) readValue(reader, 2);\n\tif (fractalheap->encoded_length > 0x8000)\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\tfractalheap->flags = (uint8_t) fgetc(reader->fhd);\n\tfractalheap->maximum_size = (uint32_t) readValue(reader, 4);\n\n\tfractalheap->next_huge_object_id = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\tfractalheap->btree_address_of_huge_objects = readValue(reader,\n\t\t\treader->superblock.size_of_offsets);\n\tfractalheap->free_space = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\tfractalheap->address_free_space = readValue(reader,\n\t\t\treader->superblock.size_of_offsets);\n\tfractalheap->amount_managed_space = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\tfractalheap->amount_allocated_space = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\tfractalheap->offset_managed_space = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\tfractalheap->number_managed_objects = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\tfractalheap->size_huge_objects = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\tfractalheap->number_huge_objects = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\tfractalheap->size_tiny_objects = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\tfractalheap->number_tiny_objects = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\n\tfractalheap->table_width = (uint16_t) readValue(reader, 2);\n\n\tfractalheap->starting_block_size = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\tfractalheap->maximum_direct_block_size = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\n\tfractalheap->maximum_heap_size = (uint16_t) readValue(reader, 2);\n\tfractalheap->starting_row = (uint16_t) readValue(reader, 2);\n\n\tfractalheap->address_of_root_block = readValue(reader,\n\t\t\treader->superblock.size_of_offsets);\n\n\tfractalheap->current_row = (uint16_t) readValue(reader, 2);\n\n\tif (fractalheap->encoded_length > 0) {\n\n\t\tfractalheap->size_of_filtered_block = readValue(reader,\n\t\t\t\treader->superblock.size_of_lengths);\n\t\tfractalheap->fitler_mask = (uint32_t) readValue(reader, 4);\n\n\t\tfractalheap->filter_information = malloc(fractalheap->encoded_length);\n\t\tif (!fractalheap->filter_information)\n\t\t\treturn MYSOFA_NO_MEMORY;\n\n\t\tif (fread(fractalheap->filter_information, 1,\n\t\t\t\tfractalheap->encoded_length, reader->fhd)\n\t\t\t\t!= fractalheap->encoded_length) {\n\t\t\tfree(fractalheap->filter_information);\n\t\t\treturn MYSOFA_READ_ERROR;\n\t\t}\n\t}\n\n\tif (fseek(reader->fhd, 4, SEEK_CUR) < 0) { /* skip checksum */\n\t\treturn MYSOFA_READ_ERROR;\n\t}\n\n\tif (fractalheap->number_huge_objects) {\n\t\tlog(\"cannot handle huge objects\\n\");\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t}\n\n\tif (fractalheap->number_tiny_objects) {\n\t\tlog(\"cannot handle tiny objects\\n\");\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t}\n\n\tif (validAddress(reader, fractalheap->address_of_root_block)) {\n\n\t\tif (fseek(reader->fhd, fractalheap->address_of_root_block, SEEK_SET)\n\t\t\t\t< 0)\n\t\t\treturn errno;\n\t\tif (fractalheap->current_row)\n\t\t\terr = indirectblockRead(reader, dataobject, fractalheap,\n\t\t\t\t\tfractalheap->starting_block_size);\n\t\telse {\n\t\t\terr = directblockRead(reader, dataobject, fractalheap);\n\n\t\t}\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn MYSOFA_OK;\n}\n\nvoid fractalheapFree(struct FRACTALHEAP *fractalheap) {\n\tfree(fractalheap->filter_information);\n}\n\n", "/*\n\n Copyright 2016 Christian Hoene, Symonics GmbH\n\n */\n\n#ifndef READER_H_\n#define READER_H_\n\n#include <stdio.h>\n#include <stdint.h>\n#include \"../hrtf/mysofa.h\"\n\n#ifdef VDEBUG\n#define log(...) {fprintf (stderr, \"%s:%d: \", __FILE__, __LINE__);fprintf (stderr, __VA_ARGS__);}\n#else\n#define log(...) \n#endif\n\n#define UNUSED(x) (void)(x)\n\nstruct READER;\nstruct DIR;\nstruct DATAOBJECT;\n\nunion RECORD {\n\tstruct TYPE5 {\n\t\tuint32_t hash_of_name;\n\t\tuint64_t heap_id;\n\t} type5;\n};\n\nstruct BTREE {\n\tuint8_t type, split_percent, merge_percent;\n\tuint16_t record_size, depth, number_of_records;\n\tuint32_t node_size;\n\tuint64_t root_node_address, total_number;\n\n\tunion RECORD *records;\n};\n\nint btreeRead(struct READER *reader, struct BTREE *btree);\nvoid btreeFree(struct BTREE *btree);\n\nstruct GCOL {\n\tuint16_t heap_object_index;\n\tuint64_t object_size;\n\n\tuint64_t address;\n\n\tuint64_t value;\n\n\tstruct GCOL *next;\n};\n\nstruct FRACTALHEAP {\n\tuint8_t flags;\n\tuint16_t heap_id_length, encoded_length, table_width, maximum_heap_size,\n\t\t\tstarting_row, current_row;\n\tuint32_t maximum_size, fitler_mask;\n\tuint64_t next_huge_object_id, btree_address_of_huge_objects, free_space,\n\t\t\taddress_free_space, amount_managed_space, amount_allocated_space,\n\t\t\toffset_managed_space, number_managed_objects, size_huge_objects,\n\t\t\tnumber_huge_objects, size_tiny_objects, number_tiny_objects,\n\t\t\tstarting_block_size, maximum_direct_block_size,\n\t\t\taddress_of_root_block, size_of_filtered_block;\n\tuint8_t *filter_information;\n};\n\nint fractalheapRead(struct READER *reader, struct DATAOBJECT *dataobject,\n\t\tstruct FRACTALHEAP *fractalheap);\nvoid fractalheapFree(struct FRACTALHEAP *fractalheap);\n\nstruct LINKINFO {\n\tuint8_t flags;\n\tuint64_t maximum_creation_index, fractal_heap_address, address_btree_index,\n\t\t\taddress_btree_order;\n};\n\nstruct GROUPINFO {\n\tuint8_t flags;\n\tuint64_t maximum_compact_value, minimum_dense_value, number_of_entries,\n\t\t\tlength_of_entries;\n};\n\nstruct ATTRIBUTEINFO {\n\tuint8_t flags;\n\tuint64_t maximum_creation_index, fractal_heap_address, attribute_name_btree,\n\t\t\tattribute_creation_order_btree;\n};\n\nstruct DATASPACE {\n\tuint64_t dimension_size[4], dimension_max_size[4];\n\tuint8_t dimensionality, flags, type;\n};\n\nstruct DATATYPE {\n\tuint8_t class_and_version;\n\tuint32_t class_bit_field, size;\n\n\tunion {\n\t\tstruct {\n\t\t\tuint16_t bit_offset, bit_precision;\n\t\t} i;\n\t\tstruct {\n\t\t\tuint16_t bit_offset, bit_precision;\n\t\t\tuint8_t exponent_location, exponent_size, mantissa_location,\n\t\t\t\t\tmantissa_size;\n\t\t\tuint32_t exponent_bias;\n\t\t} f;\n\t} u;\n\n\tuint32_t list; /* size of a list in bytes */\n};\n\nstruct DATAOBJECT {\n\tchar *name;\n\n\tuint64_t address;\n\tuint8_t flags;\n\n\tstruct DATATYPE dt;\n\tstruct DATASPACE ds;\n\tstruct LINKINFO li;\n\tstruct GROUPINFO gi;\n\tstruct ATTRIBUTEINFO ai;\n\n\tstruct BTREE objects_btree;\n\tstruct FRACTALHEAP objects_heap;\n\tstruct BTREE attributes_btree;\n\tstruct FRACTALHEAP attributes_heap;\n\n\tint datalayout_chunk[4];\n\n\tstruct MYSOFA_ATTRIBUTE *attributes;\n\tstruct DIR *directory;\n\n\tvoid *data;\n\tint data_len;\n\n\tchar *string;\n\n\t/* list of all current data objects */\n\tstruct DATAOBJECT *all;\n\n};\n\nint dataobjectRead(struct READER *reader, struct DATAOBJECT *dataobject,\n\t\tchar *name);\nvoid dataobjectFree(struct READER *reader, struct DATAOBJECT *dataobject);\n\nstruct DIR {\n\tstruct DIR *next;\n\n\tstruct DATAOBJECT dataobject;\n};\n\nstruct SUPERBLOCK {\n\tuint8_t size_of_offsets;\n\tuint8_t size_of_lengths;\n\n\tuint64_t base_address, superblock_extension_address, end_of_file_address,\n\t\t\troot_group_object_header_address;\n\n\tstruct DATAOBJECT dataobject;\n};\n\nint superblockRead(struct READER *reader, struct SUPERBLOCK *superblock);\nvoid superblockFree(struct READER *reader, struct SUPERBLOCK *superblock);\n\nint gcolRead(struct READER *reader, uint64_t gcol, int reference,\n\t\tuint64_t *dataobject);\nvoid gcolFree(struct GCOL *gcol);\n\nint treeRead(struct READER *reader, struct DATAOBJECT *data);\n\nstruct READER {\n\tFILE *fhd;\n\n\tstruct DATAOBJECT *all;\n\n\tstruct SUPERBLOCK superblock;\n\n\tstruct GCOL *gcol;\n};\n\nint validAddress(struct READER *reader, uint64_t address);\nuint64_t readValue(struct READER *reader, int size);\n\nint gunzip(int inlen, char *in, int *outlen, char *out);\n\nchar *mysofa_strdup(const char *s);\n\n#endif /* READER_H_ */\n", "/*\n\n Copyright 2016 Christian Hoene, Symonics GmbH\n\n */\n\n#include <errno.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"mysofa_export.h\"\n#include \"mysofa.h\"\n#include \"../hdf/reader.h\"\n#include \"../config.h\"\n\n/* checks file address.\n * NULL is an invalid address indicating a invalid field\n */\nint validAddress(struct READER *reader, uint64_t address) {\n\treturn address > 0 && address < reader->superblock.end_of_file_address;\n}\n\n/* little endian */\nuint64_t readValue(struct READER *reader, int size) {\n\tint i, c;\n\tuint64_t value;\n\tc = fgetc(reader->fhd);\n\tif (c < 0)\n\t\treturn 0xffffffffffffffffLL;\n\tvalue = (uint8_t) c;\n\tfor (i = 1; i < size; i++) {\n\t\tc = fgetc(reader->fhd);\n\t\tif (c < 0)\n\t\t\treturn 0xffffffffffffffffLL;\n\t\tvalue |= ((uint64_t) c) << (i * 8);\n\t}\n\treturn value;\n}\n\nstatic int mystrcmp(char *s1, char *s2) {\n\tif (s1 == NULL && s2 == NULL)\n\t\treturn 0;\n\tif (s1 == NULL)\n\t\treturn -1;\n\tif (s2 == NULL)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}\n\nstatic int checkAttribute(struct MYSOFA_ATTRIBUTE *attribute, char *name,\n\t\tchar *value) {\n\twhile (attribute) {\n\t\tif (!mystrcmp(attribute->name, name)\n\t\t\t\t&& !mystrcmp(attribute->value, value))\n\t\t\treturn MYSOFA_OK;\n\t\tattribute = attribute->next;\n\t}\n\n\treturn MYSOFA_INVALID_FORMAT;\n}\n\nstatic int getDimension(unsigned *dim, struct DATAOBJECT *dataobject) {\n\tint err;\n\tstruct MYSOFA_ATTRIBUTE *attr = dataobject->attributes;\n\n\tif (!!(err = checkAttribute(dataobject->attributes, \"CLASS\",\n\t\t\t\"DIMENSION_SCALE\")))\n\t\treturn err;\n\n\twhile (attr) {\n\t\tlog(\" %s=%s\\n\",attr->name,attr->value);\n\n\t\tif (!strcmp(attr->name, \"NAME\")\n\t\t\t\t&& attr->value && !strncmp(attr->value,\n\t\t\t\t\t\t\"This is a netCDF dimension but not a netCDF variable.\",\n\t\t\t\t\t\t53)) {\n\t\t\tchar *p = attr->value + strlen(attr->value) - 1;\n\t\t\twhile (isdigit(*p)) {\n\t\t\t\tp--;\n\t\t\t}\n\t\t\tp++;\n\t\t\t*dim = atoi(p);\n\t\t\tlog(\"NETCDF DIM %u\\n\",*dim);\n\t\t\treturn MYSOFA_OK;\n\t\t}\n\t\tattr = attr->next;\n\t}\n\treturn MYSOFA_INVALID_FORMAT;\n}\n\nstatic int getArray(struct MYSOFA_ARRAY *array, struct DATAOBJECT *dataobject) {\n\tfloat *p1;\n\tdouble *p2;\n\tint i;\n\n\tstruct MYSOFA_ATTRIBUTE *attr = dataobject->attributes;\n\twhile (attr) {\n\t\tlog(\" %s=%s\\n\",attr->name,attr->value);\n\n\t\tattr = attr->next;\n\t}\n\n\tif (dataobject->dt.u.f.bit_precision != 64)\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\n\tarray->attributes = dataobject->attributes;\n\tdataobject->attributes = NULL;\n\tarray->elements = dataobject->data_len / 8;\n\n\tp1 = dataobject->data;\n\tp2 = dataobject->data;\n\tfor (i = 0; i < array->elements; i++)\n\t\t*p1++ = *p2++;\n\tarray->values = realloc(dataobject->data, array->elements * sizeof(float));\n\n\tdataobject->data = NULL;\n\n\treturn MYSOFA_OK;\n}\n\nstatic struct MYSOFA_HRTF *getHrtf(struct READER *reader, int *err) {\n\tint dimensionflags = 0;\n\tstruct DIR *dir = reader->superblock.dataobject.directory;\n\n\tstruct MYSOFA_HRTF *hrtf = malloc(sizeof(struct MYSOFA_HRTF));\n\tif (!hrtf) {\n\t\t*err = errno;\n\t\treturn NULL;\n\t}\n\tmemset(hrtf, 0, sizeof(struct MYSOFA_HRTF));\n\n\t/* copy SOFA file attributes */\n\thrtf->attributes = reader->superblock.dataobject.attributes;\n\treader->superblock.dataobject.attributes = NULL;\n\n\t/* check SOFA file attributes */\n\tif (!!(*err = checkAttribute(hrtf->attributes, \"Conventions\", \"SOFA\")))\n\t\tgoto error;\n\n\t/* read dimensions */\n\twhile (dir) {\n\t\tif (dir->dataobject.name && dir->dataobject.name[0]\n\t\t\t\t&& dir->dataobject.name[1] == 0) {\n\t\t\tswitch (dir->dataobject.name[0]) {\n\t\t\tcase 'I':\n\t\t\t\t*err = getDimension(&hrtf->I, &dir->dataobject);\n\t\t\t\tdimensionflags |= 1;\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\t*err = getDimension(&hrtf->C, &dir->dataobject);\n\t\t\t\tdimensionflags |= 2;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\t*err = getDimension(&hrtf->R, &dir->dataobject);\n\t\t\t\tdimensionflags |= 4;\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\t*err = getDimension(&hrtf->E, &dir->dataobject);\n\t\t\t\tdimensionflags |= 8;\n\t\t\t\tbreak;\n\t\t\tcase 'N':\n\t\t\t\t*err = getDimension(&hrtf->N, &dir->dataobject);\n\t\t\t\tdimensionflags |= 0x10;\n\t\t\t\tbreak;\n\t\t\tcase 'M':\n\t\t\t\t*err = getDimension(&hrtf->M, &dir->dataobject);\n\t\t\t\tdimensionflags |= 0x20;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tbreak; /* be graceful, some issues with API version 0.4.4 */\n\t\t\tdefault:\n\t\t\t\tlog(\"UNKNOWN SOFA VARIABLE %s\", dir->dataobject.name);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (*err)\n\t\t\t\tgoto error;\n\t\t}\n\t\tdir = dir->next;\n\t}\n\n\tif (dimensionflags != 0x3f || hrtf->I != 1 || hrtf->C != 3) {\n\t\tlog(\"dimensions are missing or wrong\\n\");\n\t\tgoto error;\n\t}\n\n\tdir = reader->superblock.dataobject.directory;\n\twhile (dir) {\n\n\t\tif(!dir->dataobject.name) {\n\t\t\tlog(\"SOFA VARIABLE IS NULL.\\n\");\n\t\t}\n\t\telse if (!strcmp(dir->dataobject.name, \"ListenerPosition\")) {\n\t\t\t*err = getArray(&hrtf->ListenerPosition, &dir->dataobject);\n\t\t} else if (!strcmp(dir->dataobject.name, \"ReceiverPosition\")) {\n\t\t\t*err = getArray(&hrtf->ReceiverPosition, &dir->dataobject);\n\t\t} else if (!strcmp(dir->dataobject.name, \"SourcePosition\")) {\n\t\t\t*err = getArray(&hrtf->SourcePosition, &dir->dataobject);\n\t\t} else if (!strcmp(dir->dataobject.name, \"EmitterPosition\")) {\n\t\t\t*err = getArray(&hrtf->EmitterPosition, &dir->dataobject);\n\t\t} else if (!strcmp(dir->dataobject.name, \"ListenerUp\")) {\n\t\t\t*err = getArray(&hrtf->ListenerUp, &dir->dataobject);\n\t\t} else if (!strcmp(dir->dataobject.name, \"ListenerView\")) {\n\t\t\t*err = getArray(&hrtf->ListenerView, &dir->dataobject);\n\t\t} else if (!strcmp(dir->dataobject.name, \"Data.IR\")) {\n\t\t\t*err = getArray(&hrtf->DataIR, &dir->dataobject);\n\t\t} else if (!strcmp(dir->dataobject.name, \"Data.SamplingRate\")) {\n\t\t\t*err = getArray(&hrtf->DataSamplingRate, &dir->dataobject);\n\t\t} else if (!strcmp(dir->dataobject.name, \"Data.Delay\")) {\n\t\t\t*err = getArray(&hrtf->DataDelay, &dir->dataobject);\n\t\t} else {\n\t\t\tif (!(dir->dataobject.name[0] && !dir->dataobject.name[1]))\n\t\t\t\tlog(\"UNKNOWN SOFA VARIABLE %s.\\n\", dir->dataobject.name);\n\t\t}\n\t\tdir = dir->next;\n\t}\n\n\treturn hrtf;\n\n\terror: free(hrtf);\n\tif (!*err)\n\t\t*err = MYSOFA_INVALID_FORMAT;\n\treturn NULL;\n}\n\nMYSOFA_EXPORT struct MYSOFA_HRTF* mysofa_load(const char *filename, int *err) {\n\tstruct READER reader;\n\tstruct MYSOFA_HRTF *hrtf = NULL;\n\n\tif (filename == NULL)\n\t\tfilename = CMAKE_INSTALL_PREFIX \"/share/libmysofa/default.sofa\";\n\n\tif (strcmp(filename, \"-\"))\n\t\treader.fhd = fopen(filename, \"rb\");\n\telse\n\t\treader.fhd = stdin;\n\n\tif (!reader.fhd) {\n\t\tlog(\"cannot open file %s\\n\", filename);\n\t\t*err = errno;\n\t\treturn NULL;\n\t}\n\treader.gcol = NULL;\n\treader.all = NULL;\n\n\t*err = superblockRead(&reader, &reader.superblock);\n\n\tif (!*err) {\n\t\thrtf = getHrtf(&reader, err);\n\t}\n\n\tsuperblockFree(&reader, &reader.superblock);\n\tgcolFree(reader.gcol);\n\tif (strcmp(filename, \"-\"))\n\t\tfclose(reader.fhd);\n\n\treturn hrtf;\n}\n\nstatic void arrayFree(struct MYSOFA_ARRAY *array) {\n\twhile (array->attributes) {\n\t\tstruct MYSOFA_ATTRIBUTE *next = array->attributes->next;\n\t\tfree(array->attributes->name);\n\t\tfree(array->attributes->value);\n\t\tfree(array->attributes);\n\t\tarray->attributes = next;\n\t}\n\tfree(array->values);\n}\n\nMYSOFA_EXPORT void mysofa_free(struct MYSOFA_HRTF *hrtf) {\n\tif (!hrtf)\n\t\treturn;\n\n\twhile (hrtf->attributes) {\n\t\tstruct MYSOFA_ATTRIBUTE *next = hrtf->attributes->next;\n\t\tfree(hrtf->attributes->name);\n\t\tfree(hrtf->attributes->value);\n\t\tfree(hrtf->attributes);\n\t\thrtf->attributes = next;\n\t}\n\n\tarrayFree(&hrtf->ListenerPosition);\n\tarrayFree(&hrtf->ReceiverPosition);\n\tarrayFree(&hrtf->SourcePosition);\n\tarrayFree(&hrtf->EmitterPosition);\n\tarrayFree(&hrtf->ListenerUp);\n\tarrayFree(&hrtf->ListenerView);\n\tarrayFree(&hrtf->DataIR);\n\tarrayFree(&hrtf->DataSamplingRate);\n\tarrayFree(&hrtf->DataDelay);\n\tfree(hrtf);\n}\n\nMYSOFA_EXPORT void mysofa_getversion(int *major, int *minor, int *patch) {\n\t*major = CPACK_PACKAGE_VERSION_MAJOR;\n\t*minor = CPACK_PACKAGE_VERSION_MINOR;\n\t*patch = CPACK_PACKAGE_VERSION_PATCH;\n}\n\n"], "fixing_code": ["/*\n\n Copyright 2016 Christian Hoene, Symonics GmbH\n\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <errno.h>\n#include <assert.h>\n#include <inttypes.h>\n#include \"reader.h\"\n\nstatic int log2i(int a) {\n\treturn round(log2(a));\n}\n\nstatic int directblockRead(struct READER *reader, struct DATAOBJECT *dataobject,\n\t\tstruct FRACTALHEAP *fractalheap) {\n\n\tchar buf[4], *name, *value;\n\tint size, offset_size, length_size, err, len;\n\tuint8_t typeandversion;\n\tuint64_t unknown, heap_header_address, block_offset, block_size, offset,\n\t\t\tlength;\n\tlong store;\n\tstruct DIR *dir;\n\tstruct MYSOFA_ATTRIBUTE *attr;\n\n\tUNUSED(offset);\n\tUNUSED(block_size);\n\tUNUSED(block_offset);\n\n\tif(reader->recursive_counter >= 10)\n\t\treturn MYSOFA_INVALID_FORMAT;\n\telse\n\t\treader->recursive_counter++;\n\n\t/* read signature */\n\tif (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"FHDB\", 4)) {\n\t\tlog(\"cannot read signature of fractal heap indirect block\\n\");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t}\n\tlog(\"%08\" PRIX64 \" %.4s stack %d\\n\", (uint64_t )ftell(reader->fhd) - 4, buf, reader->recursive_counter);\n\n\tif (fgetc(reader->fhd) != 0) {\n\t\tlog(\"object FHDB must have version 0\\n\");\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t}\n\n\t/* ignore heap_header_address */\n\tif (fseek(reader->fhd, reader->superblock.size_of_offsets, SEEK_CUR) < 0)\n\t\treturn errno;\n\n\tsize = (fractalheap->maximum_heap_size + 7) / 8;\n\tblock_offset = readValue(reader, size);\n\n\tif (fractalheap->flags & 2)\n\t\tif (fseek(reader->fhd, 4, SEEK_CUR))\n\t\t\treturn errno;\n\n\toffset_size = ceilf(log2f(fractalheap->maximum_heap_size) / 8);\n\tif (fractalheap->maximum_direct_block_size < fractalheap->maximum_size)\n\t\tlength_size = ceilf(log2f(fractalheap->maximum_direct_block_size) / 8);\n\telse\n\t\tlength_size = ceilf(log2f(fractalheap->maximum_size) / 8);\n\n\tlog(\" %d %\" PRIu64 \" %d\\n\",size,block_offset,offset_size);\n\n\t/*\n\t * 00003e00  00 46 48 44 42 00 40 02  00 00 00 00 00 00 00 00  |.FHDB.@.........|\n\t 00003e10  00 00 00 83 8d ac f6 >03  00 0c 00 08 00 04 00 00  |................|\n\t 00003e20  43 6f 6e 76 65 6e 74 69  6f 6e 73 00 13 00 00 00  |Conventions.....|\n\t 00003e30  04 00 00 00 02 00 00 00  53 4f 46 41< 03 00 08 00  |........SOFA....|\n\t 00003e40  08 00 04 00 00 56 65 72  73 69 6f 6e 00 13 00 00  |.....Version....|\n\t 00003e50  00 03 00 00 00 02 00 00  00 30 2e 36 03 00 10 00  |.........0.6....|\n\t 00003e60  08 00 04 00 00 53 4f 46  41 43 6f 6e 76 65 6e 74  |.....SOFAConvent|\n\t 00003e70  69 6f 6e 73 00 13 00 00  00 13 00 00 00 02 00 00  |ions............|\n\t 00003e80  00 53 69 6d 70 6c 65 46  72 65 65 46 69 65 6c 64  |.SimpleFreeField|\n\t 00003e90  48 52 49 52 03 00 17 00  08 00 04 00 00 53 4f 46  |HRIR.........SOF|\n\t 00003ea0  41 43 6f 6e 76 65 6e 74  69 6f 6e 73 56 65 72 73  |AConventionsVers|\n\t 00003eb0  69 6f 6e 00 13 00 00 00  03 00 00 00 02 00 00 00  |ion.............|\n\t *\n\t */\n\tdo {\n\t\ttypeandversion = (uint8_t) fgetc(reader->fhd);\n\t\toffset = readValue(reader, offset_size);\n\t\tlength = readValue(reader, length_size);\n\t\tif (offset > 0x10000000 || length > 0x10000000)\n\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\n\t\tlog(\" %d %4\" PRIX64 \" %\" PRIX64 \" %08lX\\n\",typeandversion,offset,length,ftell(reader->fhd));\n\n\t\t/* TODO: for the following part, the specification is incomplete */\n\t\tif (typeandversion == 3) {\n\t\t\t/*\n\t\t\t * this seems to be a name and value pair\n\t\t\t */\n\n\t\t\tif (readValue(reader, 5) != 0x0000040008) {\n\t\t\t\tlog(\"FHDB type 3 unsupported values\");\n\t\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t\t\t}\n\n\t\t\tif (!(name = malloc(length+1)))\n\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\tif (fread(name, 1, length, reader->fhd) != length) {\n\t\t\t\tfree(name);\n\t\t\t\treturn MYSOFA_READ_ERROR;\n\t\t\t}\n\t\t\tname[length]=0;\t\n\n\t\t\tif (readValue(reader, 4) != 0x00000013) {\n\t\t\t\tlog(\"FHDB type 3 unsupported values\");\n\t\t\t\tfree(name);\n\t\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t\t\t}\n\n\t\t\tlen = (int) readValue(reader, 2);\n\t\t\tif (len > 0x1000 || len < 0) {\n\t\t\t\tfree(name);\n\t\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t\t\t}\n\n\t\t\t/* TODO: Get definition of this field */\n\t\t\tunknown = readValue(reader, 6);\n\t\t\tif (unknown == 0x000000020200)\n\t\t\t\tvalue = NULL;\n\t\t\telse if (unknown == 0x000000020000) {\n\t\t\t\tif (!(value = malloc(len + 1))) {\n\t\t\t\t\tfree(name);\n\t\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\t\t}\n\t\t\t\tif (fread(value, 1, len, reader->fhd) != len) {\n\t\t\t\t\tfree(value);\n\t\t\t\t\tfree(name);\n\t\t\t\t\treturn MYSOFA_READ_ERROR;\n\t\t\t\t}\n\t\t\t\tvalue[len] = 0;\n\t\t\t} else if (unknown == 0x20000020000) {\n\t\t\t\tif (!(value = malloc(5))) {\n\t\t\t\t\tfree(name);\n\t\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\t\t}\n\t\t\t\tstrcpy(value, \"\");\n\t\t\t} else {\n\t\t\t\tlog(\"FHDB type 3 unsupported values: %12\" PRIX64 \"\\n\",unknown);\n\t\t\t\tfree(name);\n\t\t\t\t/* TODO:\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT; */\n\t\t\t\treturn MYSOFA_OK;\n\t\t\t} \n\t\t\tlog(\" %s = %s\\n\", name, value);\n\n\t\t\tattr = malloc(sizeof(struct MYSOFA_ATTRIBUTE));\n\t\t\tattr->name = name;\n\t\t\tattr->value = value;\n\t\t\tattr->next = dataobject->attributes;\n\t\t\tdataobject->attributes = attr;\n\n\t\t} else if (typeandversion == 1) {\n\t\t\t/*\n\t\t\t * pointer to another data object\n\t\t\t */\n\t\t\tunknown = readValue(reader, 6);\n\t\t\tif (unknown) {\n\t\t\t\tlog(\"FHDB type 1 unsupported values\\n\");\n\t\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t\t\t}\n\n\t\t\tlen = fgetc(reader->fhd);\n\t\t\tif (len < 0)\n\t\t\t\treturn MYSOFA_READ_ERROR;\n\t\t\tassert(len < 0x100);\n\n\t\t\tif (!(name = malloc(len + 1)))\n\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\tif (fread(name, 1, len, reader->fhd) != len) {\n\t\t\t\tfree(name);\n\t\t\t\treturn MYSOFA_READ_ERROR;\n\t\t\t}\n\t\t\tname[len] = 0;\n\n\t\t\theap_header_address = readValue(reader,\n\t\t\t\t\treader->superblock.size_of_offsets);\n\n\t\t\tlog(\"\\nfractal head type 1 length %4\" PRIX64 \" name %s address %\" PRIX64 \"\\n\", length, name, heap_header_address);\n\n\t\t\tdir = malloc(sizeof(struct DIR));\n\t\t\tif (!dir) {\n\t\t\t\tfree(name);\n\t\t\t\treturn MYSOFA_NO_MEMORY;\n\t\t\t}\n\t\t\tmemset(dir, 0, sizeof(*dir));\n\n\t\t\tdir->next = dataobject->directory;\n\t\t\tdataobject->directory = dir;\n\n\t\t\tstore = ftell(reader->fhd);\n\t\t\tif (fseek(reader->fhd, heap_header_address, SEEK_SET)) {\n\t\t\t\tfree(name);\n\t\t\t\treturn errno;\n\t\t\t}\n\n\t\t\terr = dataobjectRead(reader, &dir->dataobject, name);\n\t\t\tif (err) {\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tif (store < 0) {\n\t\t\t\treturn errno;\n\t\t\t}\n\t\t\tif (fseek(reader->fhd, store, SEEK_SET) < 0)\n\t\t\t\treturn errno;\n\n\t\t} else if (typeandversion != 0) {\n\t\t\t/* TODO is must be avoided somehow */\n\t\t\tlog(\"fractal head unknown type %d\\n\", typeandversion);\n\t\t\t/*\t\t\treturn MYSOFA_UNSUPPORTED_FORMAT; */\n\t\t\treturn MYSOFA_OK;\n\t\t}\n\n\t} while (typeandversion != 0);\n\n\treader->recursive_counter--;\n\treturn MYSOFA_OK;\n}\n\n/*  III.G. Disk Format: Level 1G - Fractal Heap\n * indirect block\n */\n\nstatic int indirectblockRead(struct READER *reader,\n\t\tstruct DATAOBJECT *dataobject, struct FRACTALHEAP *fractalheap,\n\t\tuint64_t iblock_size) {\n\tint size, nrows, max_dblock_rows, k, n, err;\n\tuint32_t filter_mask;\n\tuint64_t heap_header_address, block_offset, child_direct_block = 0,\n\t\t\tsize_filtered, child_indirect_block;\n\tlong store;\n\n\tchar buf[4];\n\n\tUNUSED(size_filtered);\n\tUNUSED(heap_header_address);\n\tUNUSED(filter_mask);\n\n\t/* read signature */\n\tif (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"FHIB\", 4)) {\n\t\tlog(\"cannot read signature of fractal heap indirect block\\n\");\n\t\treturn MYSOFA_INVALID_FORMAT;\n\t}\n\tlog(\"%08\" PRIX64 \" %.4s\\n\", (uint64_t )ftell(reader->fhd) - 4, buf);\n\n\tif (fgetc(reader->fhd) != 0) {\n\t\tlog(\"object FHIB must have version 0\\n\");\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t}\n\n\t/* ignore it */\n\theap_header_address = readValue(reader, reader->superblock.size_of_offsets);\n\n\tsize = (fractalheap->maximum_heap_size + 7) / 8;\n\tblock_offset = readValue(reader, size);\n\n\tif (block_offset) {\n\t\tlog(\"FHIB block offset is not 0\\n\");\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t}\n\n\t/*\t The number of rows of blocks, nrows, in an indirect block of size iblock_size is given by the following expression: */\n\tnrows = (log2i(iblock_size) - log2i(fractalheap->starting_block_size)) + 1;\n\n\t/* The maximum number of rows of direct blocks, max_dblock_rows, in any indirect block of a fractal heap is given by the following expression: */\n\tmax_dblock_rows = (log2i(fractalheap->maximum_direct_block_size)\n\t\t\t- log2i(fractalheap->starting_block_size)) + 2;\n\n\t/* Using the computed values for nrows and max_dblock_rows, along with the Width of the doubling table, the number of direct and indirect block entries (K and N in the indirect block description, below) in an indirect block can be computed: */\n\tif (nrows < max_dblock_rows)\n\t\tk = nrows * fractalheap->table_width;\n\telse\n\t\tk = max_dblock_rows * fractalheap->table_width;\n\n\t/* If nrows is less than or equal to max_dblock_rows, N is 0. Otherwise, N is simply computed: */\n\tn = k - (max_dblock_rows * fractalheap->table_width);\n\n\twhile (k > 0) {\n\t\tchild_direct_block = readValue(reader,\n\t\t\t\treader->superblock.size_of_offsets);\n\t\tif (fractalheap->encoded_length > 0) {\n\t\t\tsize_filtered = readValue(reader,\n\t\t\t\t\treader->superblock.size_of_lengths);\n\t\t\tfilter_mask = readValue(reader, 4);\n\t\t}\n\t\tlog(\">> %d %\" PRIX64 \" %d\\n\",k,child_direct_block,size);\n\t\tif (validAddress(reader, child_direct_block)) {\n\t\t\tstore = ftell(reader->fhd);\n\t\t\tif (fseek(reader->fhd, child_direct_block, SEEK_SET) < 0)\n\t\t\t\treturn errno;\n\t\t\terr = directblockRead(reader, dataobject, fractalheap);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (store < 0)\n\t\t\t\treturn MYSOFA_READ_ERROR;\n\t\t\tif (fseek(reader->fhd, store, SEEK_SET) < 0)\n\t\t\t\treturn errno;\n\t\t}\n\n\t\tk--;\n\t}\n\n\twhile (n > 0) {\n\t\tchild_indirect_block = readValue(reader,\n\t\t\t\treader->superblock.size_of_offsets);\n\n\t\tif (validAddress(reader, child_direct_block)) {\n\t\t\tstore = ftell(reader->fhd);\n\t\t\tif (fseek(reader->fhd, child_indirect_block, SEEK_SET) < 0)\n\t\t\t\treturn errno;\n\t\t\terr = indirectblockRead(reader, dataobject, fractalheap,\n\t\t\t\t\tiblock_size * 2);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (store < 0)\n\t\t\t\treturn MYSOFA_READ_ERROR;\n\t\t\tif (fseek(reader->fhd, store, SEEK_SET) < 0)\n\t\t\t\treturn errno;\n\t\t}\n\n\t\tn--;\n\t}\n\n\treturn MYSOFA_OK;\n}\n\n/*  III.G. Disk Format: Level 1G - Fractal Heap\n\n 00000240  46 52 48 50 00 08 00 00  00 02 00 10 00 00 00 00  |FRHP............|\n 00000250  00 00 00 00 00 00 ff ff  ff ff ff ff ff ff a3 0b  |................|\n 00000260  00 00 00 00 00 00 1e 03  00 00 00 00 00 00 00 10  |................|\n 00000270  00 00 00 00 00 00 00 08  00 00 00 00 00 00 00 08  |................|\n 00000280  00 00 00 00 00 00 16 00  00 00 00 00 00 00 00 00  |................|\n 00000290  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n 000002a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 04 00  |................|\n 000002b0  00 04 00 00 00 00 00 00  00 00 01 00 00 00 00 00  |................|\n 000002c0  28 00 01 00 29 32 00 00  00 00 00 00 01 00 60 49  |(...)2........`I|\n 000002d0  32 1d 42 54 48 44 00 08  00 02 00 00 11 00 00 00  |2.BTHD..........|\n\n */\n\nint fractalheapRead(struct READER *reader, struct DATAOBJECT *dataobject,\n\t\tstruct FRACTALHEAP *fractalheap) {\n\tint err;\n\tchar buf[4];\n\n\t/* read signature */\n\tif (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, \"FRHP\", 4)) {\n\t\tlog(\"cannot read signature of fractal heap\\n\");\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t}\n\tlog(\"%\" PRIX64 \" %.4s\\n\", (uint64_t )ftell(reader->fhd) - 4, buf);\n\n\tif (fgetc(reader->fhd) != 0) {\n\t\tlog(\"object fractal heap must have version 0\\n\");\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t}\n\n\tfractalheap->heap_id_length = (uint16_t) readValue(reader, 2);\n\tfractalheap->encoded_length = (uint16_t) readValue(reader, 2);\n\tif (fractalheap->encoded_length > 0x8000)\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\tfractalheap->flags = (uint8_t) fgetc(reader->fhd);\n\tfractalheap->maximum_size = (uint32_t) readValue(reader, 4);\n\n\tfractalheap->next_huge_object_id = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\tfractalheap->btree_address_of_huge_objects = readValue(reader,\n\t\t\treader->superblock.size_of_offsets);\n\tfractalheap->free_space = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\tfractalheap->address_free_space = readValue(reader,\n\t\t\treader->superblock.size_of_offsets);\n\tfractalheap->amount_managed_space = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\tfractalheap->amount_allocated_space = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\tfractalheap->offset_managed_space = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\tfractalheap->number_managed_objects = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\tfractalheap->size_huge_objects = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\tfractalheap->number_huge_objects = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\tfractalheap->size_tiny_objects = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\tfractalheap->number_tiny_objects = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\n\tfractalheap->table_width = (uint16_t) readValue(reader, 2);\n\n\tfractalheap->starting_block_size = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\tfractalheap->maximum_direct_block_size = readValue(reader,\n\t\t\treader->superblock.size_of_lengths);\n\n\tfractalheap->maximum_heap_size = (uint16_t) readValue(reader, 2);\n\tfractalheap->starting_row = (uint16_t) readValue(reader, 2);\n\n\tfractalheap->address_of_root_block = readValue(reader,\n\t\t\treader->superblock.size_of_offsets);\n\n\tfractalheap->current_row = (uint16_t) readValue(reader, 2);\n\n\tif (fractalheap->encoded_length > 0) {\n\n\t\tfractalheap->size_of_filtered_block = readValue(reader,\n\t\t\t\treader->superblock.size_of_lengths);\n\t\tfractalheap->fitler_mask = (uint32_t) readValue(reader, 4);\n\n\t\tfractalheap->filter_information = malloc(fractalheap->encoded_length);\n\t\tif (!fractalheap->filter_information)\n\t\t\treturn MYSOFA_NO_MEMORY;\n\n\t\tif (fread(fractalheap->filter_information, 1,\n\t\t\t\tfractalheap->encoded_length, reader->fhd)\n\t\t\t\t!= fractalheap->encoded_length) {\n\t\t\tfree(fractalheap->filter_information);\n\t\t\treturn MYSOFA_READ_ERROR;\n\t\t}\n\t}\n\n\tif (fseek(reader->fhd, 4, SEEK_CUR) < 0) { /* skip checksum */\n\t\treturn MYSOFA_READ_ERROR;\n\t}\n\n\tif (fractalheap->number_huge_objects) {\n\t\tlog(\"cannot handle huge objects\\n\");\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t}\n\n\tif (fractalheap->number_tiny_objects) {\n\t\tlog(\"cannot handle tiny objects\\n\");\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\t}\n\n\tif (validAddress(reader, fractalheap->address_of_root_block)) {\n\n\t\tif (fseek(reader->fhd, fractalheap->address_of_root_block, SEEK_SET)\n\t\t\t\t< 0)\n\t\t\treturn errno;\n\t\tif (fractalheap->current_row)\n\t\t\terr = indirectblockRead(reader, dataobject, fractalheap,\n\t\t\t\t\tfractalheap->starting_block_size);\n\t\telse {\n\t\t\terr = directblockRead(reader, dataobject, fractalheap);\n\n\t\t}\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn MYSOFA_OK;\n}\n\nvoid fractalheapFree(struct FRACTALHEAP *fractalheap) {\n\tfree(fractalheap->filter_information);\n}\n\n", "/*\n\n Copyright 2016 Christian Hoene, Symonics GmbH\n\n */\n\n#ifndef READER_H_\n#define READER_H_\n\n#include <stdio.h>\n#include <stdint.h>\n#include \"../hrtf/mysofa.h\"\n\n#ifdef VDEBUG\n#define log(...) {fprintf (stderr, \"%s:%d: \", __FILE__, __LINE__);fprintf (stderr, __VA_ARGS__);}\n#else\n#define log(...) \n#endif\n\n#define UNUSED(x) (void)(x)\n\nstruct READER;\nstruct DIR;\nstruct DATAOBJECT;\n\nunion RECORD {\n\tstruct TYPE5 {\n\t\tuint32_t hash_of_name;\n\t\tuint64_t heap_id;\n\t} type5;\n};\n\nstruct BTREE {\n\tuint8_t type, split_percent, merge_percent;\n\tuint16_t record_size, depth, number_of_records;\n\tuint32_t node_size;\n\tuint64_t root_node_address, total_number;\n\n\tunion RECORD *records;\n};\n\nint btreeRead(struct READER *reader, struct BTREE *btree);\nvoid btreeFree(struct BTREE *btree);\n\nstruct GCOL {\n\tuint16_t heap_object_index;\n\tuint64_t object_size;\n\n\tuint64_t address;\n\n\tuint64_t value;\n\n\tstruct GCOL *next;\n};\n\nstruct FRACTALHEAP {\n\tuint8_t flags;\n\tuint16_t heap_id_length, encoded_length, table_width, maximum_heap_size,\n\t\t\tstarting_row, current_row;\n\tuint32_t maximum_size, fitler_mask;\n\tuint64_t next_huge_object_id, btree_address_of_huge_objects, free_space,\n\t\t\taddress_free_space, amount_managed_space, amount_allocated_space,\n\t\t\toffset_managed_space, number_managed_objects, size_huge_objects,\n\t\t\tnumber_huge_objects, size_tiny_objects, number_tiny_objects,\n\t\t\tstarting_block_size, maximum_direct_block_size,\n\t\t\taddress_of_root_block, size_of_filtered_block;\n\tuint8_t *filter_information;\n};\n\nint fractalheapRead(struct READER *reader, struct DATAOBJECT *dataobject,\n\t\tstruct FRACTALHEAP *fractalheap);\nvoid fractalheapFree(struct FRACTALHEAP *fractalheap);\n\nstruct LINKINFO {\n\tuint8_t flags;\n\tuint64_t maximum_creation_index, fractal_heap_address, address_btree_index,\n\t\t\taddress_btree_order;\n};\n\nstruct GROUPINFO {\n\tuint8_t flags;\n\tuint64_t maximum_compact_value, minimum_dense_value, number_of_entries,\n\t\t\tlength_of_entries;\n};\n\nstruct ATTRIBUTEINFO {\n\tuint8_t flags;\n\tuint64_t maximum_creation_index, fractal_heap_address, attribute_name_btree,\n\t\t\tattribute_creation_order_btree;\n};\n\nstruct DATASPACE {\n\tuint64_t dimension_size[4], dimension_max_size[4];\n\tuint8_t dimensionality, flags, type;\n};\n\nstruct DATATYPE {\n\tuint8_t class_and_version;\n\tuint32_t class_bit_field, size;\n\n\tunion {\n\t\tstruct {\n\t\t\tuint16_t bit_offset, bit_precision;\n\t\t} i;\n\t\tstruct {\n\t\t\tuint16_t bit_offset, bit_precision;\n\t\t\tuint8_t exponent_location, exponent_size, mantissa_location,\n\t\t\t\t\tmantissa_size;\n\t\t\tuint32_t exponent_bias;\n\t\t} f;\n\t} u;\n\n\tuint32_t list; /* size of a list in bytes */\n};\n\nstruct DATAOBJECT {\n\tchar *name;\n\n\tuint64_t address;\n\tuint8_t flags;\n\n\tstruct DATATYPE dt;\n\tstruct DATASPACE ds;\n\tstruct LINKINFO li;\n\tstruct GROUPINFO gi;\n\tstruct ATTRIBUTEINFO ai;\n\n\tstruct BTREE objects_btree;\n\tstruct FRACTALHEAP objects_heap;\n\tstruct BTREE attributes_btree;\n\tstruct FRACTALHEAP attributes_heap;\n\n\tint datalayout_chunk[4];\n\n\tstruct MYSOFA_ATTRIBUTE *attributes;\n\tstruct DIR *directory;\n\n\tvoid *data;\n\tint data_len;\n\n\tchar *string;\n\n\t/* list of all current data objects */\n\tstruct DATAOBJECT *all;\n\n};\n\nint dataobjectRead(struct READER *reader, struct DATAOBJECT *dataobject,\n\t\tchar *name);\nvoid dataobjectFree(struct READER *reader, struct DATAOBJECT *dataobject);\n\nstruct DIR {\n\tstruct DIR *next;\n\n\tstruct DATAOBJECT dataobject;\n};\n\nstruct SUPERBLOCK {\n\tuint8_t size_of_offsets;\n\tuint8_t size_of_lengths;\n\n\tuint64_t base_address, superblock_extension_address, end_of_file_address,\n\t\t\troot_group_object_header_address;\n\n\tstruct DATAOBJECT dataobject;\n};\n\nint superblockRead(struct READER *reader, struct SUPERBLOCK *superblock);\nvoid superblockFree(struct READER *reader, struct SUPERBLOCK *superblock);\n\nint gcolRead(struct READER *reader, uint64_t gcol, int reference,\n\t\tuint64_t *dataobject);\nvoid gcolFree(struct GCOL *gcol);\n\nint treeRead(struct READER *reader, struct DATAOBJECT *data);\n\nstruct READER {\n\tFILE *fhd;\n\n\tstruct DATAOBJECT *all;\n\n\tstruct SUPERBLOCK superblock;\n\n\tstruct GCOL *gcol;\n\n\tint recursive_counter;\n};\n\nint validAddress(struct READER *reader, uint64_t address);\nuint64_t readValue(struct READER *reader, int size);\n\nint gunzip(int inlen, char *in, int *outlen, char *out);\n\nchar *mysofa_strdup(const char *s);\n\n#endif /* READER_H_ */\n", "/*\n\n Copyright 2016 Christian Hoene, Symonics GmbH\n\n */\n\n#include <errno.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"mysofa_export.h\"\n#include \"mysofa.h\"\n#include \"../hdf/reader.h\"\n#include \"../config.h\"\n\n/* checks file address.\n * NULL is an invalid address indicating a invalid field\n */\nint validAddress(struct READER *reader, uint64_t address) {\n\treturn address > 0 && address < reader->superblock.end_of_file_address;\n}\n\n/* little endian */\nuint64_t readValue(struct READER *reader, int size) {\n\tint i, c;\n\tuint64_t value;\n\tc = fgetc(reader->fhd);\n\tif (c < 0)\n\t\treturn 0xffffffffffffffffLL;\n\tvalue = (uint8_t) c;\n\tfor (i = 1; i < size; i++) {\n\t\tc = fgetc(reader->fhd);\n\t\tif (c < 0)\n\t\t\treturn 0xffffffffffffffffLL;\n\t\tvalue |= ((uint64_t) c) << (i * 8);\n\t}\n\treturn value;\n}\n\nstatic int mystrcmp(char *s1, char *s2) {\n\tif (s1 == NULL && s2 == NULL)\n\t\treturn 0;\n\tif (s1 == NULL)\n\t\treturn -1;\n\tif (s2 == NULL)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}\n\nstatic int checkAttribute(struct MYSOFA_ATTRIBUTE *attribute, char *name,\n\t\tchar *value) {\n\twhile (attribute) {\n\t\tif (!mystrcmp(attribute->name, name)\n\t\t\t\t&& !mystrcmp(attribute->value, value))\n\t\t\treturn MYSOFA_OK;\n\t\tattribute = attribute->next;\n\t}\n\n\treturn MYSOFA_INVALID_FORMAT;\n}\n\nstatic int getDimension(unsigned *dim, struct DATAOBJECT *dataobject) {\n\tint err;\n\tstruct MYSOFA_ATTRIBUTE *attr = dataobject->attributes;\n\n\tif (!!(err = checkAttribute(dataobject->attributes, \"CLASS\",\n\t\t\t\"DIMENSION_SCALE\")))\n\t\treturn err;\n\n\twhile (attr) {\n\t\tlog(\" %s=%s\\n\",attr->name,attr->value);\n\n\t\tif (!strcmp(attr->name, \"NAME\")\n\t\t\t\t&& attr->value && !strncmp(attr->value,\n\t\t\t\t\t\t\"This is a netCDF dimension but not a netCDF variable.\",\n\t\t\t\t\t\t53)) {\n\t\t\tchar *p = attr->value + strlen(attr->value) - 1;\n\t\t\twhile (isdigit(*p)) {\n\t\t\t\tp--;\n\t\t\t}\n\t\t\tp++;\n\t\t\t*dim = atoi(p);\n\t\t\tlog(\"NETCDF DIM %u\\n\",*dim);\n\t\t\treturn MYSOFA_OK;\n\t\t}\n\t\tattr = attr->next;\n\t}\n\treturn MYSOFA_INVALID_FORMAT;\n}\n\nstatic int getArray(struct MYSOFA_ARRAY *array, struct DATAOBJECT *dataobject) {\n\tfloat *p1;\n\tdouble *p2;\n\tint i;\n\n\tstruct MYSOFA_ATTRIBUTE *attr = dataobject->attributes;\n\twhile (attr) {\n\t\tlog(\" %s=%s\\n\",attr->name,attr->value);\n\n\t\tattr = attr->next;\n\t}\n\n\tif (dataobject->dt.u.f.bit_precision != 64)\n\t\treturn MYSOFA_UNSUPPORTED_FORMAT;\n\n\tarray->attributes = dataobject->attributes;\n\tdataobject->attributes = NULL;\n\tarray->elements = dataobject->data_len / 8;\n\n\tp1 = dataobject->data;\n\tp2 = dataobject->data;\n\tfor (i = 0; i < array->elements; i++)\n\t\t*p1++ = *p2++;\n\tarray->values = realloc(dataobject->data, array->elements * sizeof(float));\n\n\tdataobject->data = NULL;\n\n\treturn MYSOFA_OK;\n}\n\nstatic struct MYSOFA_HRTF *getHrtf(struct READER *reader, int *err) {\n\tint dimensionflags = 0;\n\tstruct DIR *dir = reader->superblock.dataobject.directory;\n\n\tstruct MYSOFA_HRTF *hrtf = malloc(sizeof(struct MYSOFA_HRTF));\n\tif (!hrtf) {\n\t\t*err = errno;\n\t\treturn NULL;\n\t}\n\tmemset(hrtf, 0, sizeof(struct MYSOFA_HRTF));\n\n\t/* copy SOFA file attributes */\n\thrtf->attributes = reader->superblock.dataobject.attributes;\n\treader->superblock.dataobject.attributes = NULL;\n\n\t/* check SOFA file attributes */\n\tif (!!(*err = checkAttribute(hrtf->attributes, \"Conventions\", \"SOFA\")))\n\t\tgoto error;\n\n\t/* read dimensions */\n\twhile (dir) {\n\t\tif (dir->dataobject.name && dir->dataobject.name[0]\n\t\t\t\t&& dir->dataobject.name[1] == 0) {\n\t\t\tswitch (dir->dataobject.name[0]) {\n\t\t\tcase 'I':\n\t\t\t\t*err = getDimension(&hrtf->I, &dir->dataobject);\n\t\t\t\tdimensionflags |= 1;\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\t*err = getDimension(&hrtf->C, &dir->dataobject);\n\t\t\t\tdimensionflags |= 2;\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\t*err = getDimension(&hrtf->R, &dir->dataobject);\n\t\t\t\tdimensionflags |= 4;\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\t*err = getDimension(&hrtf->E, &dir->dataobject);\n\t\t\t\tdimensionflags |= 8;\n\t\t\t\tbreak;\n\t\t\tcase 'N':\n\t\t\t\t*err = getDimension(&hrtf->N, &dir->dataobject);\n\t\t\t\tdimensionflags |= 0x10;\n\t\t\t\tbreak;\n\t\t\tcase 'M':\n\t\t\t\t*err = getDimension(&hrtf->M, &dir->dataobject);\n\t\t\t\tdimensionflags |= 0x20;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tbreak; /* be graceful, some issues with API version 0.4.4 */\n\t\t\tdefault:\n\t\t\t\tlog(\"UNKNOWN SOFA VARIABLE %s\", dir->dataobject.name);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (*err)\n\t\t\t\tgoto error;\n\t\t}\n\t\tdir = dir->next;\n\t}\n\n\tif (dimensionflags != 0x3f || hrtf->I != 1 || hrtf->C != 3) {\n\t\tlog(\"dimensions are missing or wrong\\n\");\n\t\tgoto error;\n\t}\n\n\tdir = reader->superblock.dataobject.directory;\n\twhile (dir) {\n\n\t\tif(!dir->dataobject.name) {\n\t\t\tlog(\"SOFA VARIABLE IS NULL.\\n\");\n\t\t}\n\t\telse if (!strcmp(dir->dataobject.name, \"ListenerPosition\")) {\n\t\t\t*err = getArray(&hrtf->ListenerPosition, &dir->dataobject);\n\t\t} else if (!strcmp(dir->dataobject.name, \"ReceiverPosition\")) {\n\t\t\t*err = getArray(&hrtf->ReceiverPosition, &dir->dataobject);\n\t\t} else if (!strcmp(dir->dataobject.name, \"SourcePosition\")) {\n\t\t\t*err = getArray(&hrtf->SourcePosition, &dir->dataobject);\n\t\t} else if (!strcmp(dir->dataobject.name, \"EmitterPosition\")) {\n\t\t\t*err = getArray(&hrtf->EmitterPosition, &dir->dataobject);\n\t\t} else if (!strcmp(dir->dataobject.name, \"ListenerUp\")) {\n\t\t\t*err = getArray(&hrtf->ListenerUp, &dir->dataobject);\n\t\t} else if (!strcmp(dir->dataobject.name, \"ListenerView\")) {\n\t\t\t*err = getArray(&hrtf->ListenerView, &dir->dataobject);\n\t\t} else if (!strcmp(dir->dataobject.name, \"Data.IR\")) {\n\t\t\t*err = getArray(&hrtf->DataIR, &dir->dataobject);\n\t\t} else if (!strcmp(dir->dataobject.name, \"Data.SamplingRate\")) {\n\t\t\t*err = getArray(&hrtf->DataSamplingRate, &dir->dataobject);\n\t\t} else if (!strcmp(dir->dataobject.name, \"Data.Delay\")) {\n\t\t\t*err = getArray(&hrtf->DataDelay, &dir->dataobject);\n\t\t} else {\n\t\t\tif (!(dir->dataobject.name[0] && !dir->dataobject.name[1]))\n\t\t\t\tlog(\"UNKNOWN SOFA VARIABLE %s.\\n\", dir->dataobject.name);\n\t\t}\n\t\tdir = dir->next;\n\t}\n\n\treturn hrtf;\n\n\terror: free(hrtf);\n\tif (!*err)\n\t\t*err = MYSOFA_INVALID_FORMAT;\n\treturn NULL;\n}\n\nMYSOFA_EXPORT struct MYSOFA_HRTF* mysofa_load(const char *filename, int *err) {\n\tstruct READER reader;\n\tstruct MYSOFA_HRTF *hrtf = NULL;\n\n\tif (filename == NULL)\n\t\tfilename = CMAKE_INSTALL_PREFIX \"/share/libmysofa/default.sofa\";\n\n\tif (strcmp(filename, \"-\"))\n\t\treader.fhd = fopen(filename, \"rb\");\n\telse\n\t\treader.fhd = stdin;\n\n\tif (!reader.fhd) {\n\t\tlog(\"cannot open file %s\\n\", filename);\n\t\t*err = errno;\n\t\treturn NULL;\n\t}\n\treader.gcol = NULL;\n\treader.all = NULL;\n\treader.recursive_counter = 0;\n\n\t*err = superblockRead(&reader, &reader.superblock);\n\n\tif (!*err) {\n\t\thrtf = getHrtf(&reader, err);\n\t}\n\n\tsuperblockFree(&reader, &reader.superblock);\n\tgcolFree(reader.gcol);\n\tif (strcmp(filename, \"-\"))\n\t\tfclose(reader.fhd);\n\n\treturn hrtf;\n}\n\nstatic void arrayFree(struct MYSOFA_ARRAY *array) {\n\twhile (array->attributes) {\n\t\tstruct MYSOFA_ATTRIBUTE *next = array->attributes->next;\n\t\tfree(array->attributes->name);\n\t\tfree(array->attributes->value);\n\t\tfree(array->attributes);\n\t\tarray->attributes = next;\n\t}\n\tfree(array->values);\n}\n\nMYSOFA_EXPORT void mysofa_free(struct MYSOFA_HRTF *hrtf) {\n\tif (!hrtf)\n\t\treturn;\n\n\twhile (hrtf->attributes) {\n\t\tstruct MYSOFA_ATTRIBUTE *next = hrtf->attributes->next;\n\t\tfree(hrtf->attributes->name);\n\t\tfree(hrtf->attributes->value);\n\t\tfree(hrtf->attributes);\n\t\thrtf->attributes = next;\n\t}\n\n\tarrayFree(&hrtf->ListenerPosition);\n\tarrayFree(&hrtf->ReceiverPosition);\n\tarrayFree(&hrtf->SourcePosition);\n\tarrayFree(&hrtf->EmitterPosition);\n\tarrayFree(&hrtf->ListenerUp);\n\tarrayFree(&hrtf->ListenerView);\n\tarrayFree(&hrtf->DataIR);\n\tarrayFree(&hrtf->DataSamplingRate);\n\tarrayFree(&hrtf->DataDelay);\n\tfree(hrtf);\n}\n\nMYSOFA_EXPORT void mysofa_getversion(int *major, int *minor, int *patch) {\n\t*major = CPACK_PACKAGE_VERSION_MAJOR;\n\t*minor = CPACK_PACKAGE_VERSION_MINOR;\n\t*patch = CPACK_PACKAGE_VERSION_PATCH;\n}\n\n"], "filenames": ["src/hdf/fractalhead.c", "src/hdf/reader.h", "src/hrtf/reader.c"], "buggy_code_start_loc": [35, 184, 246], "buggy_code_end_loc": [220, 184, 246], "fixing_code_start_loc": [36, 185, 247], "fixing_code_end_loc": [227, 187, 248], "type": "CWE-787", "message": "libmysofa before 2019-11-24 does not properly restrict recursive function calls, as demonstrated by reports of stack consumption in readOHDRHeaderMessageDatatype in dataobject.c and directblockRead in fractalhead.c. NOTE: a download of v0.9 after 2019-12-06 should fully remediate this issue.", "other": {"cve": {"id": "CVE-2019-20016", "sourceIdentifier": "cve@mitre.org", "published": "2019-12-27T02:15:10.467", "lastModified": "2020-01-08T21:22:52.120", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libmysofa before 2019-11-24 does not properly restrict recursive function calls, as demonstrated by reports of stack consumption in readOHDRHeaderMessageDatatype in dataobject.c and directblockRead in fractalhead.c. NOTE: a download of v0.9 after 2019-12-06 should fully remediate this issue."}, {"lang": "es", "value": "libmysofa anterior a la versi\u00f3n  2019-11-24 no restringe adecuadamente las llamadas a funciones recursivas, como lo demuestran los informes de consumo de pila en readOHDRHeaderMessageDatatype en dataobject.c y directblockRead en fractalhead.c. NOTA: una descarga de v0.9 despu\u00e9s de 2019-12-06 deber\u00eda remediar completamente este problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:symonics:libmysofa:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9", "matchCriteriaId": "433A645E-4A6E-4B59-BD0E-DCC5AFA7AB9E"}]}]}], "references": [{"url": "https://github.com/hoene/libmysofa/commit/2e6fac6ab6156dae8e8c6f417741388084b70d6f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/hoene/libmysofa/issues/83", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/hoene/libmysofa/issues/84", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hoene/libmysofa/commit/2e6fac6ab6156dae8e8c6f417741388084b70d6f"}}