{"buggy_code": ["#!/bin/bash\n# Shadow .01 Based off of DTSD\n# Script that follows the log and feeds the log into the search functions and database\n\nMYSQLDTSD_SERVERLOG_LOGSTRING=\"TEXT NOT NULL\"\nMYSQLDTSD_SERVERLOG_LOGDATE=TIMESTAMP\n\nMYSQLDTSD_log_LOGSTRING=\"VARCHAR(256) NOT NULL\"\nMYSQLDTSD_log_LOGDATE=TIMESTAMP\nMYSQLALTER_log_LOGSTRING=\"UNIQUE INDEX\"\n\nMYSQLDTSD_COMMANDDB_LOGDATE=TIMESTAMP\nMYSQLDTSD_COMMANDDB_PARAMETER=\"TEXT NOT NULL\"\nMYSQLDTSD_COMMANDDB_COMMAND=\"TEXT NOT NULL\"\n\nMYSQLDTSD_SEARCHDB_SEARCHSTRING=\"VARCHAR(255)\"\nMYSQLDTSD_SEARCHDB_SEARCHFUNCTION=\"VARCHAR(50)\"\n\nDTSDDEFAULTVALUE_USERAMDRIVE=no\n\n# The current logging script works by feeding the current starmade log into the database and then searching the database to find matches with search\n# strings and their associated functions\ncore_logloop() {\n\tif [ \"$USERAMDRIVE\" = \"no\" ]\n\tthen\n\t\tWRITEDIR=$CONFIGDTSD_INSTALLPATH\n\telse\n\t\tWRITEDIR=\"/dev/shm\"\n\tfi\n# This function is testing a solution to the sluggishness of the current_core loop.  Currently it inserts lines into the database while they are received from a log file.\n\tlog_myerasetable SERVERLOG\n\tlog_myerasetable TRIGGERDB\n\tlog_myerasetable COMMANDDB\n\tlog_myerasetable DUEL\n\tMYSQLSTART=0\n\tsleep 5\n\twhile true\n\tdo\n\t\tLOGACTIVE=false\n\t\tNUMOFLINES=$(wc -l $CONFIGDTSD_INSTALLPATH/StarMade/logs/log.txt.0 | cut -d\" \" -f1) \n# In case Linestart does not have a value give it an integer value of 1.  The prevents a startup error on the script.\n\t\tif [ -z \"$LINESTART\" ]\n\t\tthen\n\t\t\tLINESTART=$NUMOFLINES\n\t\t\t#echo \"Start at line $LINESTART\"\n\t\tfi\n# Since the Starmade log file rolls after 4mb the Linestart must be reset back to something reasonable when this happens or the script will hang. Special thanks to LordDragon for helping trouble shoot this\n\t\tif [ \"$LINESTART\" -gt \"$NUMOFLINES\" ]\n\t\tthen\n\t\t\techo \"Log file for $CONFIGDTSD_SERVICE has been reset or rolled over\"\n\t\t\tLINESTART=$NUMOFLINES\n\t\tfi\n# If the number of lines read from the log file is greater than last line read + 1 from the log then feed more lines.\n\t\tif [ \"$NUMOFLINES\" -gt \"$LINESTART\" ] \n\t\tthen\n\t\t\tLOGACTIVE=true\n\t\t\t#echo \"$NUMOFLINES is the total lines of the log\"\n\t\t\t#echo \"$LINESTART is linestart\"\n\t\t\tlet LINESTART++\n# Use sed to gather the current selection of lines\n\t\t\tsed -n \"$LINESTART,$NUMOFLINES p\" $CONFIGDTSD_INSTALLPATH/StarMade/logs/log.txt.0 > $WRITEDIR/SERVERLOG.txt\n# Remove any quotes from the log to prevent processing issues in mysql\n\t\t\tsed -i 's/\\\"//g' $WRITEDIR/SERVERLOG.txt\n# Mysqlimport is a command line version of load data infile and rapidly inserts a file into Mysql\n\t\t\tmysqlimport --user=$CONFIGDTSD_MYSQLUSER --password=$CONFIGDTSD_MYSQLPASS --columns=LOGSTRING --fields-terminated-by='\\n' --silent --local dtsddb $WRITEDIR/SERVERLOG.txt\n# Get the last line of the MYSQL table Serverlog where th log is being dumped\n\t\t\tMYSQLSTOP=$(mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -sNe \"SELECT line FROM SERVERLOG ORDER BY line DESC LIMIT 1;\")\n\t\t\t#echo \"MYSQLSTOP $MYSQLSTOP\"\n\t\t\t#echo \"MYSQLSTART $MYSQLSTART\"\n\t\t\tlet MYSQLSTART++\n# Search through the log from the last mysqlstart and the current mysqlstop and insert any matched into the Commanddb\n\t\t\tmysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -e  \"INSERT INTO COMMANDDB (PARAMETER, COMMAND) SELECT SERVERLOG.LOGSTRING, SEARCHDB.SEARCHFUNCTION FROM SERVERLOG, SEARCHDB WHERE LOCATE(SEARCHDB.SEARCHSTRING, SERVERLOG.LOGSTRING) > 0 AND SERVERLOG.line <= $MYSQLSTOP AND SERVERLOG.line >= $MYSQLSTART ORDER BY SERVERLOG.line ASC;\"\n\t\t\tLINESTART=$NUMOFLINES\n\t\t\tlet MYSQLSTART=$MYSQLSTOP\n\t\tfi\n# Quick check to save Mysql time to see if commands are in the Commanddb\n\t\tCHECKCOMMANDS=$(mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -sNe \"SELECT 1 FROM COMMANDDB LIMIT 1;\")\n\t\tif [ -n \"${CHECKCOMMANDS-unset}\" ]\n\t\tthen\n#\t\techo \"CHECKCOMMANDS $CHECKCOMMANDS\"\n#\t\techo \"commands detected\"\n# Set the field seperator to newline so commands and parameters are received as a single array variable and not broken up by the normal space field seperator\n\t\t\tOLD_IFS=$IFS\n\t\t\tIFS=$'\\n'\n# Gather command and parameter\n\t\t\tRECIEVEDCOMMAND=( $(mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -sNe \"select COMMAND from COMMANDDB order by line asc;\") )\n\t\t\tRECIEVEDPARAMETER=( $(mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -sNe \"select PARAMETER from COMMANDDB order by line asc;\") )\n# Reset the field seperator so it does not cause issues with the rest of the execution of the script\n\t\t\tIFS=$OLD_IFS\n# Reset the database so the same command is not read repeatedly \n\t\t\tmysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -e \"truncate table COMMANDDB;\"\n\t\t\tCOMMANDARRAY=0\n\t\t\tPARAMETERARRAY=0\n# Go through each command and parameter received and execute them with eval\n\t\t\twhile [ -n \"${RECIEVEDCOMMAND[$COMMANDARRAY]+set}\" ]\n\t\t\tdo\n\t\t\t\tRECIEVEDCOMMAND=${RECIEVEDCOMMAND[$COMMANDARRAY]}\n\t\t\t\tRECIEVEDPARAMETER=${RECIEVEDPARAMETER[$PARAMETERARRAY]}\n\t\t\t\t#echo \"executing $RECIEVEDCOMMAND $RECIEVEDPARAMETER\"\n\t\t\t\teval $RECIEVEDCOMMAND '$RECIEVEDPARAMETER'\n\t\t\t\tlet COMMANDARRAY++\n\t\t\t\tlet PARAMETERARRAY++\n\t\t\tdone\n\t\tfi\n\tif [ \"$LOGACTIVE\" = \"false\" ]\n\tthen\n\t\tsleep 0.5\n\tfi\n\tdone\n}\ncore_makesearchdb() {\n# Make the search database which contains all the search strings and their related functions\n\tlog_myerasetable SEARCHDB\n\tSEARCHVAR=( $(compgen -v | grep LOGSEARCH_ ) )\n\tSEARCHARRAY=0\n\twhile [ -n \"${SEARCHVAR[$SEARCHARRAY]+set}\" ]\n\tdo\n\t\tCURRENTSEARCH=${SEARCHVAR[$SEARCHARRAY]}\n\t\tCURRENTSEARCHSTRING=${!CURRENTSEARCH}\n\t\tCURRENTSEARCHFUNCTION=${CURRENTSEARCH#*_}\n\t\tlib_myinsert SEARCHDB SEARCHFUNCTION \"$CURRENTSEARCHFUNCTION\"\n\t\tlib_myupdate SEARCHDB SEARCHSTRING \"$CURRENTSEARCHSTRING\" SEARCHFUNCTION $CURRENTSEARCHFUNCTION\n\t\tlet SEARCHARRAY++\n\tdone\n}\n\n########################OLD FUNCTIONS########################\n\ncore_loadlog() {\n# This function is testing a solution to the sluggishness of the tailog function.  Currently it used Mysqlimport to rapidly insert lines into a table with a unique column.  This way the file can be loaded into the database again and again without adding duplicate lines.\n\n\tlog_myerasetable log\n\twhile lib_check_server_running\n\tdo \n\t\t mysqlimport --user=$CONFIGDTSD_MYSQLUSER --password=$CONFIGDTSD_MYSQLPASS --columns=LOGSTRING --fields-terminated-by='\\n' --silent --local dtsddb $CONFIGDTSD_INSTALLPATH/StarMade/logs/log.txt.0\n# Sleep added here to keep it from burning up the CPU.  This value can be modified based upon how aggressive you want the script to run.\n\t\t sleep 1\n\tdone\n}\n\ncore_taillog() {\n\tlog_myerasetable SERVERLOG\n# Tail with -F to prevent rollover file from stopping read is extremely fast and lightweight method for feeding log lines into the database\n\ttail -F $CONFIGDTSD_INSTALLPATH/StarMade/logs/log.txt.0 |\n    while read a; do\n# Quotations will cause Mysql to error so they are removed with a in line edit \n\t\tSTRING=${a//\\\"/}\n#\t\techo \"INSERT INTO SERVERLOG LOGSTRING $STRING\"\n\t\tmysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -e \"INSERT INTO SERVERLOG (LOGSTRING) VALUES (\\\"$STRING\\\");\"\n    done\n}\ncore_search_executelog() {\n\tlog_myerasetable TRIGGERDB\n\tlog_myerasetable COMMANDDB\n\twhile true\n\tdo \n\t\tNUMOFLINES=$(mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -sNe \"SELECT line FROM log ORDER BY line DESC LIMIT 1;\")\n\t\t#echo \"Here is the last line of the log $NUMOFLINES\"\n\t\t# if the number of lines isn't detected it is because no lines have been fed yet\n\t\tif [ -z \"$NUMOFLINES\" ]\n\t\tthen\n\t\t\tNUMOFLINES=0\n#\t\t\techo \"Setting numoflines to 0\"\n\t\tfi\n\t\tif [ -z \"$LINESTART\" ]\n\t\tthen\n\t\t\tLINESTART=$NUMOFLINES\n#\t\t\techo \"Start at line $LINESTART\"\n\t\tfi\n\t\tif [ \"$NUMOFLINES\" -gt \"$LINESTART\" ] \n\t\tthen\n#\t\t\techo \"$NUMOFLINES is the total lines of the log\"\n#\t\t\techo \"$LINESTART is linestart\"\n\t\t\tlet LINESTART++\n\t\t\tmysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -e  \"INSERT INTO COMMANDDB (PARAMETER, COMMAND) SELECT log.LOGSTRING, SEARCHDB.SEARCHFUNCTION FROM log, SEARCHDB WHERE LOCATE(SEARCHDB.SEARCHSTRING, log.LOGSTRING) > 0 AND log.line <= $NUMOFLINES AND log.line >= $LINESTART ORDER BY log.line ASC\"\n\t\t\tLINESTART=$NUMOFLINES\n\t\tfi\n\t\tOLD_IFS=$IFS\n\t\tIFS=$'\\n'\n\t\tRECIEVEDCOMMAND=( $(mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -sNe \"select COMMAND from COMMANDDB order by line asc;\") )\n\t\tRECIEVEDPARAMETER=( $(mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -sNe \"select PARAMETER from COMMANDDB order by line asc;\") )\n\t\tmysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -e \"truncate table COMMANDDB;\"\n\t\tIFS=$OLD_IFS\n\t\tCOMMANDARRAY=0\n\t\tPARAMETERARRAY=0\n\t\twhile [ -n \"${RECIEVEDCOMMAND[$COMMANDARRAY]+set}\" ]\n\t\tdo\n\t\t\tRECIEVEDCOMMAND=${RECIEVEDCOMMAND[$COMMANDARRAY]}\n\t\t\tRECIEVEDPARAMETER=${RECIEVEDPARAMETER[$PARAMETERARRAY]}\n\t\t\techo \"executing $RECIEVEDCOMMAND $RECIEVEDPARAMETER\"\n\t\t\teval $RECIEVEDCOMMAND '$RECIEVEDPARAMETER'\n\t\t\tlet COMMANDARRAY++\n\t\t\tlet PARAMETERARRAY++\n\t\tdone\n\t\tsleep 1\n\tdone\n}\n\n", "#!/bin/bash\n# Shadow .01 Based off of DTSD\n# Location of all the functions related to the chat system\n\nMYSQLDTSD_CHATLOG_SENDER=\"VARCHAR(25)\"\nMYSQLDTSD_CHATLOG_CHATSTRING=TEXT\nMYSQLDTSD_CHATLOG_RECIEVER=\"VARCHAR(25)\"\nMYSQLDTSD_CHATLOG_LOGDATE=TIMESTAMP\n\nLOGSEARCH_chat_log=\"[CHANNELROUTER] RECEIVED MESSAGE ON Server(0): [CHAT]\"\nLOGSEARCH_chat_commands=\"[CHANNELROUTER] RECEIVED MESSAGE ON Server(0): [CHAT]\"\n\nchat_log() {\n    MYCHATSTRING=\"${@:1}\"\n\tMYCHATSTRING=${MYCHATSTRING#*]}\n# Below example of Chat string received\n# [CHANNELROUTER] RECEIVED MESSAGE ON Server(0): [CHAT][sender=Doomsider][receiverType=CHANNEL][receiver=all][message=hey]\n# String manipulation with parameter expansion is used here to cut at the first = which reveals the sender \n# followed by the rest of MYCHATSTRING\t\n\tCUTSTRING=${MYCHATSTRING#*=}\n# Remove everything after first ] to get just the name of the sender\n\tSENDERNAME=${CUTSTRING%%]*}\n# Removes at the second =\n\tCUTSTRING=${CUTSTRING#*=}\n# Remove everything after ] to get receivertype\n\tRECEIVERTYPE=${CUTSTRING%%]*}\n# Removes at the third =\n\tCUTSTRING=${CUTSTRING#*=}\n# Remove everything after ] to get receiver\n\tRECEIVERNAME=${CUTSTRING%%]*}\n# Removes at the fourth =\n\tCUTSTRING=${CUTSTRING#*=}\n# Remove everything after ] to get message\n\tMESSAGESTRING=${CUTSTRING%%]*}\n\techo \"This was sent to chat log $@\"\n\techo \"This was the message $MESSAGESTRING\"\n\techo \"This was sender $SENDERNAME\"\n\techo \"This was receiver $RECEIVERNAME\"\n\techo \"This was receivertype $RECEIVERTYPE\"\n# [CHAT is error value for SENDERNAME\n\tmysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -e \"INSERT INTO CHATLOG (SENDER, CHATSTRING, RECIEVER) VALUES (\\\"$SENDERNAME\\\",\\\"$MESSAGESTRING\\\",\\\"$RECEIVERNAME\\\");\"\n}\nchat_commands() {\n    MYCHATSTRING=\"${@:1}\"\n\tMYCHATSTRING=${MYCHATSTRING#*]}\n# String manipulation with parameter expansion is used here to cut at the first = which reveals the sender \n# followed by the rest of MYCHATSTRING\t\n\tCUTSTRING=${MYCHATSTRING#*=}\n# Remove everything after first ] to get just the name of the sender\n\tSENDERNAME=${CUTSTRING%%]*}\n# Removes at the second =\n\tCUTSTRING=${CUTSTRING#*=}\n# Remove everything after ] to get receivertype\n\tRECEIVERTYPE=${CUTSTRING%%]*}\n# Removes at the third =\n\tCUTSTRING=${CUTSTRING#*=}\n# Remove everything after ] to get receiver\n\tRECEIVERNAME=${CUTSTRING%%]*}\n# Removes at the fourth =\n\tCUTSTRING=${CUTSTRING#*=}\n# Remove everything after ] to get message\n\tMESSAGESTRING=${CUTSTRING%%]*}\n# Get the first letter of message string to test if it is a !\n\tMESSAGEFIRSTLETTER=${MESSAGESTRING:0:1}\n# Add the playername into the database if it does not exist\n\tlib_myinsert PLAYERDB NAME $SENDERNAME\n\tlib_myupdate PLAYERDB ONLINE y NAME $SENDERNAME\n\tif [ \"$MESSAGEFIRSTLETTER\" == \"!\" ]\n\tthen\n\t\techo \"chat command triggered\"\n\t\tCHATCOMMANDS=( $(compgen -A function | grep chatcommand_) )\n\t\tMESSAGECUT=${MESSAGESTRING#*!}\n\t\techo \"Message Cut $MESSAGECUT\"\n# Feed the message string into an array so we can work with it as commands\t\t\n\t\tCOMMANDARRAY=($MESSAGECUT)\n\t\tUSERCOMMAND=${COMMANDARRAY[0]}\n\t\tUSERCOMMAND=${USERCOMMAND^^}\n\t\tUSERPARAMETERS=${COMMANDARRAY[@]:1}\n\t\techo \"User is $SENDERNAME\"\n\t\techo \"Command is $USERCOMMAND\"\n\t\techo ${#USERCOMMAND}\n\t\techo \"Parameters are $USERPARAMETERS\"\n\t\techo \"List of chat commands $CHATCOMMANDS[@]\"\n\t\tCHATCOMMANDARRAY=0\n        COMMANDFOUND=false\n\t\twhile [ -n \"${CHATCOMMANDS[$CHATCOMMANDARRAY]+set}\" ] \n\t\tdo\n            CURRENTCHATCOMMAND=${CHATCOMMANDS[$CHATCOMMANDARRAY]}\n#\t\techo \"This is the current Chat Command $CURRENTCHATCOMMAND\"\n            CUTCHATCOMMAND=${CURRENTCHATCOMMAND#*_}\n#\t\techo \"This remove chatcommand to get only the command name $CUTCHATCOMMAND\"\n            if [ \"$CUTCHATCOMMAND\" = \"$USERCOMMAND\" ]\n            then\n                echo \"Chat Command found\"\n                COMMANDFOUND=true\n                if check_player_rank_allowed $USERCOMMAND $SENDERNAME\n                then\n                    eval $CURRENTCHATCOMMAND \"$SENDERNAME\" $USERPARAMETERS\n                else\n                    echo \"Command not authorized\"\n                    lib_screensend $CONFIGDTSD_MAINSCREEN /pm $SENDERNAME \"You do not have permission to use that command!\"\n                fi\n                let CHATCOMMANDARRAY++\n            else\n                let CHATCOMMANDARRAY++\n            fi\n\t\tdone\n\t\tif [ $COMMANDFOUND = false ]\n        then\n            lib_screensend $CONFIGDTSD_MAINSCREEN /pm $SENDERNAME \"Unknown command. Please use !HELP for a list of the commands you can use\"\n        fi\n\tfi\t\n}"], "fixing_code": ["#!/bin/bash\n# Shadow .01 Based off of DTSD\n# Script that follows the log and feeds the log into the search functions and database\n\nMYSQLDTSD_SERVERLOG_LOGSTRING=\"TEXT NOT NULL\"\nMYSQLDTSD_SERVERLOG_LOGDATE=TIMESTAMP\n\nMYSQLDTSD_log_LOGSTRING=\"VARCHAR(256) NOT NULL\"\nMYSQLDTSD_log_LOGDATE=TIMESTAMP\nMYSQLALTER_log_LOGSTRING=\"UNIQUE INDEX\"\n\nMYSQLDTSD_COMMANDDB_LOGDATE=TIMESTAMP\nMYSQLDTSD_COMMANDDB_PARAMETER=\"TEXT NOT NULL\"\nMYSQLDTSD_COMMANDDB_COMMAND=\"TEXT NOT NULL\"\n\nMYSQLDTSD_SEARCHDB_SEARCHSTRING=\"VARCHAR(255)\"\nMYSQLDTSD_SEARCHDB_SEARCHFUNCTION=\"VARCHAR(50)\"\n\nDTSDDEFAULTVALUE_USERAMDRIVE=no\n\n# The current logging script works by feeding the current starmade log into the database and then searching the database to find matches with search\n# strings and their associated functions\ncore_logloop() {\n\tif [ \"$USERAMDRIVE\" = \"no\" ]\n\tthen\n\t\tWRITEDIR=$CONFIGDTSD_INSTALLPATH\n\telse\n\t\tWRITEDIR=\"/dev/shm\"\n\tfi\n# This function is testing a solution to the sluggishness of the current_core loop.  Currently it inserts lines into the database while they are received from a log file.\n\tlog_myerasetable SERVERLOG\n\tlog_myerasetable TRIGGERDB\n\tlog_myerasetable COMMANDDB\n\tlog_myerasetable DUEL\n\tMYSQLSTART=0\n\tsleep 5\n\twhile true\n\tdo\n\t\tLOGACTIVE=false\n\t\tNUMOFLINES=$(wc -l $CONFIGDTSD_INSTALLPATH/StarMade/logs/log.txt.0 | cut -d\" \" -f1) \n# In case Linestart does not have a value give it an integer value of 1.  The prevents a startup error on the script.\n\t\tif [ -z \"$LINESTART\" ]\n\t\tthen\n\t\t\tLINESTART=$NUMOFLINES\n\t\t\t#echo \"Start at line $LINESTART\"\n\t\tfi\n# Since the Starmade log file rolls after 4mb the Linestart must be reset back to something reasonable when this happens or the script will hang. Special thanks to LordDragon for helping trouble shoot this\n\t\tif [ \"$LINESTART\" -gt \"$NUMOFLINES\" ]\n\t\tthen\n\t\t\techo \"Log file for $CONFIGDTSD_SERVICE has been reset or rolled over\"\n\t\t\tLINESTART=$NUMOFLINES\n\t\tfi\n# If the number of lines read from the log file is greater than last line read + 1 from the log then feed more lines.\n\t\tif [ \"$NUMOFLINES\" -gt \"$LINESTART\" ] \n\t\tthen\n\t\t\tLOGACTIVE=true\n\t\t\t#echo \"$NUMOFLINES is the total lines of the log\"\n\t\t\t#echo \"$LINESTART is linestart\"\n\t\t\tlet LINESTART++\n# Use sed to gather the current selection of lines\n\t\t\tsed -n \"$LINESTART,$NUMOFLINES p\" $CONFIGDTSD_INSTALLPATH/StarMade/logs/log.txt.0 > $WRITEDIR/SERVERLOG.txt\n# Remove any quotes from the log to prevent processing issues in mysql\n\t\t\tsed -i 's/\\\"//g' $WRITEDIR/SERVERLOG.txt\n# Mysqlimport is a command line version of load data infile and rapidly inserts a file into Mysql\n\t\t\tmysqlimport --user=$CONFIGDTSD_MYSQLUSER --password=$CONFIGDTSD_MYSQLPASS --columns=LOGSTRING --fields-terminated-by='\\n' --silent --local dtsddb $WRITEDIR/SERVERLOG.txt\n# Get the last line of the MYSQL table Serverlog where th log is being dumped\n\t\t\tMYSQLSTOP=$(mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -sNe \"SELECT line FROM SERVERLOG ORDER BY line DESC LIMIT 1;\")\n\t\t\t#echo \"MYSQLSTOP $MYSQLSTOP\"\n\t\t\t#echo \"MYSQLSTART $MYSQLSTART\"\n\t\t\tlet MYSQLSTART++\n# Search through the log from the last mysqlstart and the current mysqlstop and insert any matched into the Commanddb\n\t\t\tmysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -e  \"INSERT INTO COMMANDDB (PARAMETER, COMMAND) SELECT SERVERLOG.LOGSTRING, SEARCHDB.SEARCHFUNCTION FROM SERVERLOG, SEARCHDB WHERE LOCATE(SEARCHDB.SEARCHSTRING, SERVERLOG.LOGSTRING) > 0 AND SERVERLOG.line <= $MYSQLSTOP AND SERVERLOG.line >= $MYSQLSTART ORDER BY SERVERLOG.line ASC;\"\n\t\t\tLINESTART=$NUMOFLINES\n\t\t\tlet MYSQLSTART=$MYSQLSTOP\n\t\tfi\n# Quick check to save Mysql time to see if commands are in the Commanddb\n\t\tCHECKCOMMANDS=$(mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -sNe \"SELECT 1 FROM COMMANDDB LIMIT 1;\")\n\t\tif [ -n \"${CHECKCOMMANDS-unset}\" ]\n\t\tthen\n#\t\techo \"CHECKCOMMANDS $CHECKCOMMANDS\"\n#\t\techo \"commands detected\"\n# Set the field seperator to newline so commands and parameters are received as a single array variable and not broken up by the normal space field seperator\n\t\t\tOLD_IFS=$IFS\n\t\t\tIFS=$'\\n'\n# Gather command and parameter\n\t\t\tRECIEVEDCOMMAND=( $(mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -sNe \"select COMMAND from COMMANDDB order by line asc;\") )\n\t\t\tRECIEVEDPARAMETER=( $(mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -sNe \"select PARAMETER from COMMANDDB order by line asc;\") )\n# Reset the field seperator so it does not cause issues with the rest of the execution of the script\n\t\t\tIFS=$OLD_IFS\n# Reset the database so the same command is not read repeatedly \n\t\t\tmysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -e \"truncate table COMMANDDB;\"\n\t\t\tPOSITIONCOMMANDARRAY=0\n\t\t\tPARAMETERARRAY=0\n# Go through each command and parameter received and execute them with eval\n\t\t\twhile [ -n \"${RECIEVEDCOMMAND[$POSITIONCOMMANDARRAY]+set}\" ]\n\t\t\tdo\n\t\t\t\tRECIEVEDCOMMAND=${RECIEVEDCOMMAND[$POSITIONCOMMANDARRAY]}\n\t\t\t\tRECIEVEDPARAMETER=${RECIEVEDPARAMETER[$PARAMETERARRAY]}\n\t\t\t\t#echo \"executing $RECIEVEDCOMMAND $RECIEVEDPARAMETER\"\n\t\t\t\t$RECIEVEDCOMMAND ${RECIEVEDPARAMETER}\n\t\t\t\tlet POSITIONCOMMANDARRAY++\n\t\t\t\tlet PARAMETERARRAY++\n\t\t\tdone\n\t\tfi\n\tif [ \"$LOGACTIVE\" = \"false\" ]\n\tthen\n\t\tsleep 0.5\n\tfi\n\tdone\n}\n# Trap is used here to restart logloop if it exits due to a bad call\n# trap core_logloop EXIT\ncore_makesearchdb() {\n# Make the search database which contains all the search strings and their related functions\n\tlog_myerasetable SEARCHDB\n\tSEARCHVAR=( $(compgen -v | grep LOGSEARCH_ ) )\n\tSEARCHARRAY=0\n\twhile [ -n \"${SEARCHVAR[$SEARCHARRAY]+set}\" ]\n\tdo\n\t\tCURRENTSEARCH=${SEARCHVAR[$SEARCHARRAY]}\n\t\tCURRENTSEARCHSTRING=${!CURRENTSEARCH}\n\t\tCURRENTSEARCHFUNCTION=${CURRENTSEARCH#*_}\n\t\tlib_myinsert SEARCHDB SEARCHFUNCTION \"$CURRENTSEARCHFUNCTION\"\n\t\tlib_myupdate SEARCHDB SEARCHSTRING \"$CURRENTSEARCHSTRING\" SEARCHFUNCTION $CURRENTSEARCHFUNCTION\n\t\tlet SEARCHARRAY++\n\tdone\n}\n\n########################OLD FUNCTIONS########################\n\ncore_loadlog() {\n# This function is testing a solution to the sluggishness of the tailog function.  Currently it used Mysqlimport to rapidly insert lines into a table with a unique column.  This way the file can be loaded into the database again and again without adding duplicate lines.\n\n\tlog_myerasetable log\n\twhile lib_check_server_running\n\tdo \n\t\t mysqlimport --user=$CONFIGDTSD_MYSQLUSER --password=$CONFIGDTSD_MYSQLPASS --columns=LOGSTRING --fields-terminated-by='\\n' --silent --local dtsddb $CONFIGDTSD_INSTALLPATH/StarMade/logs/log.txt.0\n# Sleep added here to keep it from burning up the CPU.  This value can be modified based upon how aggressive you want the script to run.\n\t\t sleep 1\n\tdone\n}\n\ncore_taillog() {\n\tlog_myerasetable SERVERLOG\n# Tail with -F to prevent rollover file from stopping read is extremely fast and lightweight method for feeding log lines into the database\n\ttail -F $CONFIGDTSD_INSTALLPATH/StarMade/logs/log.txt.0 |\n    while read a; do\n# Quotations will cause Mysql to error so they are removed with a in line edit \n\t\tSTRING=${a//\\\"/}\n#\t\techo \"INSERT INTO SERVERLOG LOGSTRING $STRING\"\n\t\tmysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -e \"INSERT INTO SERVERLOG (LOGSTRING) VALUES (\\\"$STRING\\\");\"\n    done\n}\ncore_search_executelog() {\n\tlog_myerasetable TRIGGERDB\n\tlog_myerasetable COMMANDDB\n\twhile true\n\tdo \n\t\tNUMOFLINES=$(mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -sNe \"SELECT line FROM log ORDER BY line DESC LIMIT 1;\")\n\t\t#echo \"Here is the last line of the log $NUMOFLINES\"\n\t\t# if the number of lines isn't detected it is because no lines have been fed yet\n\t\tif [ -z \"$NUMOFLINES\" ]\n\t\tthen\n\t\t\tNUMOFLINES=0\n#\t\t\techo \"Setting numoflines to 0\"\n\t\tfi\n\t\tif [ -z \"$LINESTART\" ]\n\t\tthen\n\t\t\tLINESTART=$NUMOFLINES\n#\t\t\techo \"Start at line $LINESTART\"\n\t\tfi\n\t\tif [ \"$NUMOFLINES\" -gt \"$LINESTART\" ] \n\t\tthen\n#\t\t\techo \"$NUMOFLINES is the total lines of the log\"\n#\t\t\techo \"$LINESTART is linestart\"\n\t\t\tlet LINESTART++\n\t\t\tmysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -e  \"INSERT INTO COMMANDDB (PARAMETER, COMMAND) SELECT log.LOGSTRING, SEARCHDB.SEARCHFUNCTION FROM log, SEARCHDB WHERE LOCATE(SEARCHDB.SEARCHSTRING, log.LOGSTRING) > 0 AND log.line <= $NUMOFLINES AND log.line >= $LINESTART ORDER BY log.line ASC\"\n\t\t\tLINESTART=$NUMOFLINES\n\t\tfi\n\t\tOLD_IFS=$IFS\n\t\tIFS=$'\\n'\n\t\tRECIEVEDCOMMAND=( $(mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -sNe \"select COMMAND from COMMANDDB order by line asc;\") )\n\t\tRECIEVEDPARAMETER=( $(mysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -sNe \"select PARAMETER from COMMANDDB order by line asc;\") )\n\t\tmysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -e \"truncate table COMMANDDB;\"\n\t\tIFS=$OLD_IFS\n\t\tCOMMANDARRAY=0\n\t\tPARAMETERARRAY=0\n\t\twhile [ -n \"${RECIEVEDCOMMAND[$COMMANDARRAY]+set}\" ]\n\t\tdo\n\t\t\tRECIEVEDCOMMAND=${RECIEVEDCOMMAND[$COMMANDARRAY]}\n\t\t\tRECIEVEDPARAMETER=${RECIEVEDPARAMETER[$PARAMETERARRAY]}\n\t\t\techo \"executing $RECIEVEDCOMMAND $RECIEVEDPARAMETER\"\n\t\t\teval $RECIEVEDCOMMAND '$RECIEVEDPARAMETER'\n\t\t\tlet COMMANDARRAY++\n\t\t\tlet PARAMETERARRAY++\n\t\tdone\n\t\tsleep 1\n\tdone\n}\n\n", "#!/bin/bash\n# Shadow .01 Based off of DTSD\n# Location of all the functions related to the chat system\n\nMYSQLDTSD_CHATLOG_SENDER=\"VARCHAR(25)\"\nMYSQLDTSD_CHATLOG_CHATSTRING=TEXT\nMYSQLDTSD_CHATLOG_RECIEVER=\"VARCHAR(25)\"\nMYSQLDTSD_CHATLOG_LOGDATE=TIMESTAMP\n\nLOGSEARCH_chat_log=\"[CHANNELROUTER] RECEIVED MESSAGE ON Server(0): [CHAT]\"\nLOGSEARCH_chat_commands=\"[CHANNELROUTER] RECEIVED MESSAGE ON Server(0): [CHAT]\"\n\nchat_log() {\n    MYCHATSTRING=\"${@:1}\"\n\tMYCHATSTRING=${MYCHATSTRING#*]}\n# Below example of Chat string received\n# [CHANNELROUTER] RECEIVED MESSAGE ON Server(0): [CHAT][sender=Doomsider][receiverType=CHANNEL][receiver=all][message=hey]\n# String manipulation with parameter expansion is used here to cut at the first = which reveals the sender \n# followed by the rest of MYCHATSTRING\t\n\tCUTSTRING=${MYCHATSTRING#*=}\n# Remove everything after first ] to get just the name of the sender\n\tSENDERNAME=${CUTSTRING%%]*}\n# Removes at the second =\n\tCUTSTRING=${CUTSTRING#*=}\n# Remove everything after ] to get receivertype\n\tRECEIVERTYPE=${CUTSTRING%%]*}\n# Removes at the third =\n\tCUTSTRING=${CUTSTRING#*=}\n# Remove everything after ] to get receiver\n\tRECEIVERNAME=${CUTSTRING%%]*}\n# Removes at the fourth =\n\tCUTSTRING=${CUTSTRING#*=}\n# Remove everything after ] to get message\n\tMESSAGESTRING=${CUTSTRING%%]*}\n\t#echo \"This was sent to chat log $@\"\n\t#echo \"This was the message $MESSAGESTRING\"\n\t#echo \"This was sender $SENDERNAME\"\n\t#echo \"This was receiver $RECEIVERNAME\"\n\t#echo \"This was receivertype $RECEIVERTYPE\"\n# [CHAT is error value for SENDERNAME\n\tmysql --defaults-extra-file=$CONFIGDTSD_INSTALLPATH/core/shadow.cnf -e \"INSERT INTO CHATLOG (SENDER, CHATSTRING, RECIEVER) VALUES (\\\"$SENDERNAME\\\",\\\"$MESSAGESTRING\\\",\\\"$RECEIVERNAME\\\");\"\n}\nchat_commands() {\n    MYCHATSTRING=\"${@:1}\"\n\tMYCHATSTRING=${MYCHATSTRING#*]}\n# String manipulation with parameter expansion is used here to cut at the first = which reveals the sender \n# followed by the rest of MYCHATSTRING\t\n\tCUTSTRING=${MYCHATSTRING#*=}\n# Remove everything after first ] to get just the name of the sender\n\tSENDERNAME=${CUTSTRING%%]*}\n# Removes at the second =\n\tCUTSTRING=${CUTSTRING#*=}\n# Remove everything after ] to get receivertype\n\tRECEIVERTYPE=${CUTSTRING%%]*}\n# Removes at the third =\n\tCUTSTRING=${CUTSTRING#*=}\n# Remove everything after ] to get receiver\n\tRECEIVERNAME=${CUTSTRING%%]*}\n# Removes at the fourth =\n\tCUTSTRING=${CUTSTRING#*=}\n# Remove everything after ] to get message\n\tMESSAGESTRING=${CUTSTRING%%]*}\n# Get the first letter of message string to test if it is a !\n\tMESSAGEFIRSTLETTER=${MESSAGESTRING:0:1}\n# Add the playername into the database if it does not exist\n\tlib_myinsert PLAYERDB NAME $SENDERNAME\n\tlib_myupdate PLAYERDB ONLINE y NAME $SENDERNAME\n\tif [ \"$MESSAGEFIRSTLETTER\" == \"!\" ]\n\tthen\n\t\techo \"chat command triggered\"\n\t\tCHATCOMMANDS=( $(compgen -A function | grep chatcommand_) )\n\t\tMESSAGECUT=${MESSAGESTRING#*!}\n\t\techo \"Message Cut $MESSAGECUT\"\n# Feed the message string into an array so we can work with it as commands\t\t\n\t\tCOMMANDARRAY=($MESSAGECUT)\n\t\tUSERCOMMAND=${COMMANDARRAY[0]}\n\t\tUSERCOMMAND=${USERCOMMAND^^}\n\t\tUSERCOMMAND=\"chatcommand_$USERCOMMAND\"\n\t\tUSERPARAMETERS=${COMMANDARRAY[@]:1}\n\t\techo \"User is $SENDERNAME\"\n\t\techo \"Command is $USERCOMMAND\"\n\t\techo ${#USERCOMMAND}\n\t\techo \"Parameters are $USERPARAMETERS\"\n\t\t#echo \"List of chat commands ${CHATCOMMANDS[@]}\"\n\t\tif lib_arraycontains CHATCOMMANDS $USERCOMMAND\n\t\tthen \n\t\t\techo \"Chat command found\"\n\t\t    USERCOMMAND=${USERCOMMAND#*_}\n\t\t\tif check_player_rank_allowed $USERCOMMAND $SENDERNAME\n            then\n\t\t\t\tUSERCOMMAND=\"chatcommand_$USERCOMMAND\"\n\t\t\t\t$USERCOMMAND \"$SENDERNAME\" $USERPARAMETERS\n            else\n\t\t\t\techo \"Command not authorized\"\n\t\t\t\tlib_screensend $CONFIGDTSD_MAINSCREEN /pm $SENDERNAME \"You do not have permission to use that command!\"\n\t\t\tfi\n        \n\t\telse\n\t\t\techo \"No matching chat command\"\n\t\t\tlib_screensend $CONFIGDTSD_MAINSCREEN /pm $SENDERNAME \"Unknown command. Please use !HELP for a list of the commands you can use\"\n\t\tfi\n\tfi\t\n}"], "filenames": ["core/core_loops.dtsd", "modules/chatfunctions.dtsd"], "buggy_code_start_loc": [92, 35], "buggy_code_end_loc": [110, 112], "fixing_code_start_loc": [92, 35], "fixing_code_end_loc": [113, 102], "type": "NVD-CWE-noinfo", "message": "A vulnerability was found in doomsider shadow. It has been classified as problematic. Affected is an unknown function. The manipulation leads to denial of service. Attacking locally is a requirement. Continious delivery with rolling releases is used by this product. Therefore, no version details of affected nor updated releases are available. The name of the patch is 3332c5ba9ec3014ddc74e2147190a050eee97bc0. It is recommended to apply a patch to fix this issue. VDB-221478 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2016-15024", "sourceIdentifier": "cna@vuldb.com", "published": "2023-02-19T18:15:10.067", "lastModified": "2023-03-07T15:13:27.360", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in doomsider shadow. It has been classified as problematic. Affected is an unknown function. The manipulation leads to denial of service. Attacking locally is a requirement. Continious delivery with rolling releases is used by this product. Therefore, no version details of affected nor updated releases are available. The name of the patch is 3332c5ba9ec3014ddc74e2147190a050eee97bc0. It is recommended to apply a patch to fix this issue. VDB-221478 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 2.5, "baseSeverity": "LOW"}, "exploitabilityScore": 1.0, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:H/Au:S/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "HIGH", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 1.0}, "baseSeverity": "LOW", "exploitabilityScore": 1.5, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-404"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:doomsider_shadow_project:doomsider_shadow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2016-06-09", "matchCriteriaId": "7F68D9C5-41D9-415F-B181-8C334017F11A"}]}]}], "references": [{"url": "https://github.com/doomsider/shadow/commit/3332c5ba9ec3014ddc74e2147190a050eee97bc0", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://vuldb.com/?ctiid.221478", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.221478", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/doomsider/shadow/commit/3332c5ba9ec3014ddc74e2147190a050eee97bc0"}}