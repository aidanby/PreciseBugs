{"buggy_code": ["#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/proc_ns.h>\n#include <linux/magic.h>\n#include <linux/ktime.h>\n#include <linux/seq_file.h>\n#include <linux/user_namespace.h>\n#include <linux/nsfs.h>\n#include <linux/uaccess.h>\n\nstatic struct vfsmount *nsfs_mnt;\n\nstatic long ns_ioctl(struct file *filp, unsigned int ioctl,\n\t\t\tunsigned long arg);\nstatic const struct file_operations ns_file_operations = {\n\t.llseek\t\t= no_llseek,\n\t.unlocked_ioctl = ns_ioctl,\n};\n\nstatic char *ns_dname(struct dentry *dentry, char *buffer, int buflen)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tconst struct proc_ns_operations *ns_ops = dentry->d_fsdata;\n\n\treturn dynamic_dname(dentry, buffer, buflen, \"%s:[%lu]\",\n\t\tns_ops->name, inode->i_ino);\n}\n\nstatic void ns_prune_dentry(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tif (inode) {\n\t\tstruct ns_common *ns = inode->i_private;\n\t\tatomic_long_set(&ns->stashed, 0);\n\t}\n}\n\nconst struct dentry_operations ns_dentry_operations =\n{\n\t.d_prune\t= ns_prune_dentry,\n\t.d_delete\t= always_delete_dentry,\n\t.d_dname\t= ns_dname,\n};\n\nstatic void nsfs_evict(struct inode *inode)\n{\n\tstruct ns_common *ns = inode->i_private;\n\tclear_inode(inode);\n\tns->ops->put(ns);\n}\n\nstatic void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct qstr qname = { .name = \"\", };\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &qname);\n\tif (!dentry) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\td_instantiate(dentry, inode);\n\tdentry->d_fsdata = (void *)ns->ops;\n\td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n\tif (d) {\n\t\td_delete(dentry);\t/* make sure ->d_prune() does nothing */\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}\n\nvoid *ns_get_path(struct path *path, struct task_struct *task,\n\t\t\tconst struct proc_ns_operations *ns_ops)\n{\n\tstruct ns_common *ns;\n\tvoid *ret;\n\nagain:\n\tns = ns_ops->get(task);\n\tif (!ns)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tret = __ns_get_path(path, ns);\n\tif (IS_ERR(ret) && PTR_ERR(ret) == -EAGAIN)\n\t\tgoto again;\n\treturn ret;\n}\n\nint open_related_ns(struct ns_common *ns,\n\t\t   struct ns_common *(*get_ns)(struct ns_common *ns))\n{\n\tstruct path path = {};\n\tstruct file *f;\n\tvoid *err;\n\tint fd;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\twhile (1) {\n\t\tstruct ns_common *relative;\n\n\t\trelative = get_ns(ns);\n\t\tif (IS_ERR(relative)) {\n\t\t\tput_unused_fd(fd);\n\t\t\treturn PTR_ERR(relative);\n\t\t}\n\n\t\terr = __ns_get_path(&path, relative);\n\t\tif (IS_ERR(err) && PTR_ERR(err) == -EAGAIN)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (IS_ERR(err)) {\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(err);\n\t}\n\n\tf = dentry_open(&path, O_RDONLY, current_cred());\n\tpath_put(&path);\n\tif (IS_ERR(f)) {\n\t\tput_unused_fd(fd);\n\t\tfd = PTR_ERR(f);\n\t} else\n\t\tfd_install(fd, f);\n\n\treturn fd;\n}\n\nstatic long ns_ioctl(struct file *filp, unsigned int ioctl,\n\t\t\tunsigned long arg)\n{\n\tstruct user_namespace *user_ns;\n\tstruct ns_common *ns = get_proc_ns(file_inode(filp));\n\tuid_t __user *argp;\n\tuid_t uid;\n\n\tswitch (ioctl) {\n\tcase NS_GET_USERNS:\n\t\treturn open_related_ns(ns, ns_get_owner);\n\tcase NS_GET_PARENT:\n\t\tif (!ns->ops->get_parent)\n\t\t\treturn -EINVAL;\n\t\treturn open_related_ns(ns, ns->ops->get_parent);\n\tcase NS_GET_NSTYPE:\n\t\treturn ns->ops->type;\n\tcase NS_GET_OWNER_UID:\n\t\tif (ns->ops->type != CLONE_NEWUSER)\n\t\t\treturn -EINVAL;\n\t\tuser_ns = container_of(ns, struct user_namespace, ns);\n\t\targp = (uid_t __user *) arg;\n\t\tuid = from_kuid_munged(current_user_ns(), user_ns->owner);\n\t\treturn put_user(uid, argp);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nint ns_get_name(char *buf, size_t size, struct task_struct *task,\n\t\t\tconst struct proc_ns_operations *ns_ops)\n{\n\tstruct ns_common *ns;\n\tint res = -ENOENT;\n\tns = ns_ops->get(task);\n\tif (ns) {\n\t\tres = snprintf(buf, size, \"%s:[%u]\", ns_ops->name, ns->inum);\n\t\tns_ops->put(ns);\n\t}\n\treturn res;\n}\n\nstruct file *proc_ns_fget(int fd)\n{\n\tstruct file *file;\n\n\tfile = fget(fd);\n\tif (!file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (file->f_op != &ns_file_operations)\n\t\tgoto out_invalid;\n\n\treturn file;\n\nout_invalid:\n\tfput(file);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic int nsfs_show_path(struct seq_file *seq, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tconst struct proc_ns_operations *ns_ops = dentry->d_fsdata;\n\n\tseq_printf(seq, \"%s:[%lu]\", ns_ops->name, inode->i_ino);\n\treturn 0;\n}\n\nstatic const struct super_operations nsfs_ops = {\n\t.statfs = simple_statfs,\n\t.evict_inode = nsfs_evict,\n\t.show_path = nsfs_show_path,\n};\nstatic struct dentry *nsfs_mount(struct file_system_type *fs_type,\n\t\t\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_pseudo(fs_type, \"nsfs:\", &nsfs_ops,\n\t\t\t&ns_dentry_operations, NSFS_MAGIC);\n}\nstatic struct file_system_type nsfs = {\n\t.name = \"nsfs\",\n\t.mount = nsfs_mount,\n\t.kill_sb = kill_anon_super,\n};\n\nvoid __init nsfs_init(void)\n{\n\tnsfs_mnt = kern_mount(&nsfs);\n\tif (IS_ERR(nsfs_mnt))\n\t\tpanic(\"can't set nsfs up\\n\");\n\tnsfs_mnt->mnt_sb->s_flags &= ~MS_NOUSER;\n}\n"], "fixing_code": ["#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/proc_ns.h>\n#include <linux/magic.h>\n#include <linux/ktime.h>\n#include <linux/seq_file.h>\n#include <linux/user_namespace.h>\n#include <linux/nsfs.h>\n#include <linux/uaccess.h>\n\nstatic struct vfsmount *nsfs_mnt;\n\nstatic long ns_ioctl(struct file *filp, unsigned int ioctl,\n\t\t\tunsigned long arg);\nstatic const struct file_operations ns_file_operations = {\n\t.llseek\t\t= no_llseek,\n\t.unlocked_ioctl = ns_ioctl,\n};\n\nstatic char *ns_dname(struct dentry *dentry, char *buffer, int buflen)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tconst struct proc_ns_operations *ns_ops = dentry->d_fsdata;\n\n\treturn dynamic_dname(dentry, buffer, buflen, \"%s:[%lu]\",\n\t\tns_ops->name, inode->i_ino);\n}\n\nstatic void ns_prune_dentry(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tif (inode) {\n\t\tstruct ns_common *ns = inode->i_private;\n\t\tatomic_long_set(&ns->stashed, 0);\n\t}\n}\n\nconst struct dentry_operations ns_dentry_operations =\n{\n\t.d_prune\t= ns_prune_dentry,\n\t.d_delete\t= always_delete_dentry,\n\t.d_dname\t= ns_dname,\n};\n\nstatic void nsfs_evict(struct inode *inode)\n{\n\tstruct ns_common *ns = inode->i_private;\n\tclear_inode(inode);\n\tns->ops->put(ns);\n}\n\nstatic void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct qstr qname = { .name = \"\", };\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &qname);\n\tif (!dentry) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\td_instantiate(dentry, inode);\n\tdentry->d_flags |= DCACHE_RCUACCESS;\n\tdentry->d_fsdata = (void *)ns->ops;\n\td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n\tif (d) {\n\t\td_delete(dentry);\t/* make sure ->d_prune() does nothing */\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}\n\nvoid *ns_get_path(struct path *path, struct task_struct *task,\n\t\t\tconst struct proc_ns_operations *ns_ops)\n{\n\tstruct ns_common *ns;\n\tvoid *ret;\n\nagain:\n\tns = ns_ops->get(task);\n\tif (!ns)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tret = __ns_get_path(path, ns);\n\tif (IS_ERR(ret) && PTR_ERR(ret) == -EAGAIN)\n\t\tgoto again;\n\treturn ret;\n}\n\nint open_related_ns(struct ns_common *ns,\n\t\t   struct ns_common *(*get_ns)(struct ns_common *ns))\n{\n\tstruct path path = {};\n\tstruct file *f;\n\tvoid *err;\n\tint fd;\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn fd;\n\n\twhile (1) {\n\t\tstruct ns_common *relative;\n\n\t\trelative = get_ns(ns);\n\t\tif (IS_ERR(relative)) {\n\t\t\tput_unused_fd(fd);\n\t\t\treturn PTR_ERR(relative);\n\t\t}\n\n\t\terr = __ns_get_path(&path, relative);\n\t\tif (IS_ERR(err) && PTR_ERR(err) == -EAGAIN)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (IS_ERR(err)) {\n\t\tput_unused_fd(fd);\n\t\treturn PTR_ERR(err);\n\t}\n\n\tf = dentry_open(&path, O_RDONLY, current_cred());\n\tpath_put(&path);\n\tif (IS_ERR(f)) {\n\t\tput_unused_fd(fd);\n\t\tfd = PTR_ERR(f);\n\t} else\n\t\tfd_install(fd, f);\n\n\treturn fd;\n}\n\nstatic long ns_ioctl(struct file *filp, unsigned int ioctl,\n\t\t\tunsigned long arg)\n{\n\tstruct user_namespace *user_ns;\n\tstruct ns_common *ns = get_proc_ns(file_inode(filp));\n\tuid_t __user *argp;\n\tuid_t uid;\n\n\tswitch (ioctl) {\n\tcase NS_GET_USERNS:\n\t\treturn open_related_ns(ns, ns_get_owner);\n\tcase NS_GET_PARENT:\n\t\tif (!ns->ops->get_parent)\n\t\t\treturn -EINVAL;\n\t\treturn open_related_ns(ns, ns->ops->get_parent);\n\tcase NS_GET_NSTYPE:\n\t\treturn ns->ops->type;\n\tcase NS_GET_OWNER_UID:\n\t\tif (ns->ops->type != CLONE_NEWUSER)\n\t\t\treturn -EINVAL;\n\t\tuser_ns = container_of(ns, struct user_namespace, ns);\n\t\targp = (uid_t __user *) arg;\n\t\tuid = from_kuid_munged(current_user_ns(), user_ns->owner);\n\t\treturn put_user(uid, argp);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nint ns_get_name(char *buf, size_t size, struct task_struct *task,\n\t\t\tconst struct proc_ns_operations *ns_ops)\n{\n\tstruct ns_common *ns;\n\tint res = -ENOENT;\n\tns = ns_ops->get(task);\n\tif (ns) {\n\t\tres = snprintf(buf, size, \"%s:[%u]\", ns_ops->name, ns->inum);\n\t\tns_ops->put(ns);\n\t}\n\treturn res;\n}\n\nstruct file *proc_ns_fget(int fd)\n{\n\tstruct file *file;\n\n\tfile = fget(fd);\n\tif (!file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (file->f_op != &ns_file_operations)\n\t\tgoto out_invalid;\n\n\treturn file;\n\nout_invalid:\n\tfput(file);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic int nsfs_show_path(struct seq_file *seq, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tconst struct proc_ns_operations *ns_ops = dentry->d_fsdata;\n\n\tseq_printf(seq, \"%s:[%lu]\", ns_ops->name, inode->i_ino);\n\treturn 0;\n}\n\nstatic const struct super_operations nsfs_ops = {\n\t.statfs = simple_statfs,\n\t.evict_inode = nsfs_evict,\n\t.show_path = nsfs_show_path,\n};\nstatic struct dentry *nsfs_mount(struct file_system_type *fs_type,\n\t\t\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_pseudo(fs_type, \"nsfs:\", &nsfs_ops,\n\t\t\t&ns_dentry_operations, NSFS_MAGIC);\n}\nstatic struct file_system_type nsfs = {\n\t.name = \"nsfs\",\n\t.mount = nsfs_mount,\n\t.kill_sb = kill_anon_super,\n};\n\nvoid __init nsfs_init(void)\n{\n\tnsfs_mnt = kern_mount(&nsfs);\n\tif (IS_ERR(nsfs_mnt))\n\t\tpanic(\"can't set nsfs up\\n\");\n\tnsfs_mnt->mnt_sb->s_flags &= ~MS_NOUSER;\n}\n"], "filenames": ["fs/nsfs.c"], "buggy_code_start_loc": [93], "buggy_code_end_loc": [93], "fixing_code_start_loc": [94], "fixing_code_end_loc": [95], "type": "CWE-362", "message": "An issue was discovered in the __ns_get_path function in fs/nsfs.c in the Linux kernel before 4.11. Due to a race condition when accessing files, a Use After Free condition can occur. This also affects all Android releases from CAF using the Linux kernel (Android for MSM, Firefox OS for MSM, QRD Android) before security patch level 2018-07-05.", "other": {"cve": {"id": "CVE-2018-5873", "sourceIdentifier": "product-security@qualcomm.com", "published": "2018-07-06T19:29:01.060", "lastModified": "2018-08-29T13:49:24.353", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the __ns_get_path function in fs/nsfs.c in the Linux kernel before 4.11. Due to a race condition when accessing files, a Use After Free condition can occur. This also affects all Android releases from CAF using the Linux kernel (Android for MSM, Firefox OS for MSM, QRD Android) before security patch level 2018-07-05."}, {"lang": "es", "value": "Debido a una condici\u00f3n de carrera al acceder a los archivos en todas las distribuciones de Android de CAF (Android for MSM, Firefox OS for MSM y QRD Android) que utilizan el kernel de Linux antes del parche de seguridad de nivel del 05/07/2018, puede ocurrir una condici\u00f3n de uso de memoria previamente liberada en el kernel."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}, {"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:google:android:-:*:*:*:*:*:*:*", "matchCriteriaId": "F8B9FEC8-73B6-43B8-B24E-1F7C20D91D26"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:-:*:*:*:*:*:*:*", "matchCriteriaId": "703AF700-7A70-47E2-BC3A-7FD03B3CA9C1"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=073c516ff73557a8f7315066856c04b50383ac34", "source": "product-security@qualcomm.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/073c516ff73557a8f7315066856c04b50383ac34", "source": "product-security@qualcomm.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://source.android.com/security/bulletin/2018-07-01", "source": "product-security@qualcomm.com", "tags": ["Vendor Advisory"]}, {"url": "https://source.codeaurora.org/quic/la/kernel/msm-4.9/commit/?id=34742aaf7cb16c95edba4a7afed6d2c4fa7e434b", "source": "product-security@qualcomm.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.codeaurora.org/security-bulletin/2018/07/02/july-2018-code-aurora-security-bulletin", "source": "product-security@qualcomm.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/073c516ff73557a8f7315066856c04b50383ac34"}}