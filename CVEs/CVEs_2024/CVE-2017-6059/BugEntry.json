{"buggy_code": ["01/14/2017\n- use dynamic memory buffer for writing HTTP call responses; solves curl/mpm-event interference; see #207\n- bump to 2.1.4rc1\n\n01/10/2017\n- don't crash when data is POST-ed to the redirect URL, it has just 1 POST parameter and it is not \"response_mode\"\n\n01/2/2017\n- remove trailing linebreaks from input in test-cmd tool\n- bump copyright year to 2017\n\n12/14/2016\n- support Libre SSL, see #205, thanks @AliceWonderMiscreations\n- update OIDC logout support to Front-Channel Logout 1.0 draft 01: http://openid.net/specs/openid-connect-frontchannel-1_0.html\n- bump to 2.1.4rc0\n\n12/13/2016\n- release 2.1.3\n\n12/12/2016\n- don't rollover session id's and keep the same session cookie name for cache storage over session updates\n- bump to 2.1.3rc0\n\n11/19/2016\n- release 2.1.2\n\n11/18/2016\n- fix crash when searching for keys with a kid, there's no initial match and x5t values exist for the non-matching keys; closes #196\n\n11/9/2016\n- remove stale claims from session when refreshing them from the userinfo endpoint fails; addresses #194\n- release 2.1.1\n\n11/8/2016\n- log readable error messages when memcache operations fail\n\n11/6/2016\n- fix memory leak when skipping jwks_uri keys with a non-matching \"use\" value\n\n11/4/2016\n- always restore id_token/claims on sub-requests so e.g. listing claims-protected subdirectories will work\n- remove obsolete functions for storing the session in the request state\n- bump to 2.1.1rc0\n\n11/3/2016\n- remove obsolete sessions from session cache; thanks @stevedave\n\n11/1/2016\n- release version 2.1.0\n\n10/28/2016\n- don't include encryption keys from the jwks_uri when verifying a JWT and no kid has been specified\n- fix memory leaks in composite claim handling\n\n10/27/2016\n- handle aggregated and distributed claims from the userinfo endpoint\n- only pick private_key_jwt token endpoint authentication if a private key is configured; closes #189\n- bump to 2.0.1rc7\n\n10/24/2016\n- add OpenID Connect RP certification test script\n- handle non-integer exp/iat timestamps; closes #187; thanks @drdivano\n\n10/21/2016\n- bugfix: first truncate files before writing them\n- support refreshing provider metadata based on timestamp and OIDCProviderMetadataRefreshInterval\n\n10/20/2016\n- bugfix: correctly truncate encryption keys derived from client secret for algorithms that require a key size < 256 bits\n- add test/test-cmd tool\n- bugfix: return error on session cache failures; closes #185; thanks @solsson\n- bump to 2.0.1rc6\n\n10/18/2016\n- bugfix: JWTs with a header that doesn't specify a `kid` that would not validate when used with more than 1 key; closes #184; thanks @solsson\n- bump to 2.0.1rc5\n\n10/13/2016\n- urlencode provider URL cache key to fix file cache backend issue; closes #179, thanks @djahandarie\n\n10/9/2016\n- fix null pointer segfault in debug printout in oidc_util_read_form_encoded_params\n- fix OIDCOAuthAcceptTokenAs parsing flaw introduced in 2.0.0rc5\n- bump to 2.0.1rc4\n\n10/2/2016\n- support presenting the access token to the userinfo endpoint in a POST parameter\n- bump to 2.0.1rc3\n\n9/30/2016\n- support WebFinger Discovery with URL-style user identifiers\n\n9/28/2016\n- fix memory leak in oidc_jwk_to_json\n- add \"remove_at_cache\" hook; addresses #177\n- bump to 2.0.1rc2\n\n9/27/2016\n- add support for Request URI with signed and/or encrypted Request Objects\n- bump to 2.0.1rc1\n\n9/22/2016\n- refuse webfinger responses with an href value that is not on secure https\n- add userinfo JWT response verification and decryption\n\n9/20/2016\n- log the JWT header before optional decryption is applied\n\n9/19/2016\n- check that a sub claim returned from the userinfo endpoint matches the one in the id_token\n- fix issue in oidc_metadata_parse_url so that static default would not be honored\n  - this only affected server-wide OIDCClientJwksUri usage in dynamic client registration\n- non-functional changes for OIDC RP certification:\n  - explicitly log the client authentication method when calling the token endpoint\n  - log the keys that are included for token verification\n- bump to 2.0.1rc0\n\n9/9/2016\n- fix overriding provider token endpoint auth with static config when not set in .conf file\n- don't add our own cookies to the incoming headers\n- allow stripping cookies from the Cookie header sent to the application/backend with OIDCStripCookies\n- release 2.0.0\n\n9/5/2016\n- encapsulate (sub-)directory config handling and fix merging so values can be set back to default values in subdirs\n- bump to 2.0.0rc5\n\n9/2/2016\n- fix JWK creation when no client secret is set e.g. in Implicit flows; closes #168; thanks @asc1\n- bump to 2.0.0rc4\n\n9/1/2016\n- fix HTML decoding of OIDCPreservePost data; closes #165\n- limit max POST data size to 1Mb\n- allow chunked data in POST handling; revise handler\n- change preserve POST JSON data format to urlencoded for performance reasons\n\n8/31/2016\n- allow setting the token endpoint authentication method in the .conf file (for dynamic client registration that sets the .client)\n\n8/30/2016\n- pass refresh token in header/environment variable with OIDCPassRefreshToken; thanks Amit Joshi\n- fix front-channel img-style logout with newer versions of PingFederate that don't send an Accept: image/png header\n\n8/29/2016\n- preserve POST data across authentication requests and discovery with OIDCPreservePost\n- bump to 2.0.0rc3\n\n8/24/2016\n- fix parsing of OIDCOAuthAcceptTokenAs to accept options following \":\"\n- bump to 2.0.0rc2\n\n8/5/2016\n- delete the debian directory\n- rename OIDCOAuthTokenEndpointCert/Key to OIDCOAuthIntrospectionEndpointCert/Key\n- pre-release 2.0.0rc1\n\n7/30/2016\n- encrypt state/session JWT cookies and session JWT cache values for non-shm storages\n\n7/29/2016\n- use cjose - https://github.com/cisco/cjose (master) - for JOSE functions\n- use stricter input parsing functions for configuration values\n- bump to 2.0.0rc0\n\n7/21/2016\n- support TLS client authentication to token and introspection endpoints\n- bump to 1.9.0rc3\n\n7/19/2016\n- add support for chunked session cookies; closes #153; thanks @glatzert \n- bump to 1.9.0rc2\n\n7/9/2016\n- fix Elliptic Curve signature verification for corrupted input\n- support OpenSSL 1.1.x\n- bump to 1.9.0rc1\n\n7/5/2016\n- use AUTHZ_DENIED instead of HTTP_UNAUTHORIZED in oidc_authz_checker; closes #151; thanks @gwollman\n- use signed JWTs for state/session cookies\n- achieve smaller client-cookie sizes for regular cases; no id_token is stored in the session:\n  - (optional) id_token_hint no longer available in session management calls (logout/prompt=none) with \"OIDCSessionType client-cookie\"\n  - \"OIDCPassIDTokenAs serialized\" is not available with \"OIDCSessionType client-cookie\"\n- bump to 1.9.0rc0\n\n6/27/2016\n- use EVP_CIPHER_CTX_new to avoid compilation errors with OpenSSL 1.1.0\n- release 1.8.10\n\n6/22/2016\n- don't use local port setting for current URL determination when X-Forwarded-Host has been set\n- bump to 1.8.10rc4\n\n6/20/2016\n- fix memory leak in OAuth access token introspection result caching (introduced only in 1.8.10rc0)\n- fix setting private_key_jwt or client_secret_jwt with OIDCProviderTokenEndpointAuth\n- bump to 1.8.10rc3\n\n6/19/2016\n- allow setting OIDCRemoteUserClaim with values obtained from the userinfo endpoint; thanks @steve-dave\n- fix OIDCUnAuthAction pass mode for Apache 2.4 and in case `Require claim` primitives used for 2.4 and 2.2; thanks @steve-dave\n- bump to 1.8.10rc2\n\n6/15/2016\n- add support for JWT based client authentication to the token endpoint (client_secret_jwt, private_key_jwt)\n- bump to 1.8.10rc1\n\n6/9/2016\n- add per-path configurable token introspection result cache expiry with OIDCOAuthTokenIntrospectionInterval\n- bump to 1.8.10rc0\n\n6/5/2016\n- release 1.8.9\n\n5/9/2016\n- support 410 option on OIDCUnAuthAction; closes #141\n- bump to 1.8.9rc6\n\n5/1/2016\n- avoid segmentation fault on invalid OIDC configuration when OIDCRedirectURI is not set; fixes #138; thanks @brianwcook\n- bump to 1.8.9rc5\n\n4/18/2016\n- fix get_current_url (proxy) case where r->parsed_uri.path would be null\n\n4/13/2016\n- improve X-Forwarded-Host handling over Host in a) port detection and b) remove port from host value\n- bump to 1.8.9rc4\n\n4/10/2016\n- do not require OIDCClientSecret in configs; allows for Implicit grant without setting a dummy client secret; closes #130\n- allow for public clients calling the token endpoint\n- bump to 1.8.9rc3\n\n4/9/2016\n- ensure that claims from id_token are available for authz also when OIDCPassIDTokenAs does not contain \"claims\"; closes #129\n- bump to 1.8.9rc2\n\n4/3/2016\n- return WWW-Authenticate header and error messages on OAuth paths where access is not granted; closes #124; thanks @spinto\n- bump to 1.8.9rc1\n\n4/1/2016\n- apr_jwe_decrypt_content_aesgcm() null terminate string, #128, thanks @jdennis\n- bump to 1.8.9rc0\n\n3/10/2016\n- release 1.8.8\n\n3/7/2016\n- issue a warning if the \"openid\" scope is not requested\n\n3/6/2016\n- sanitize the OIDCAuthNHeader value before setting the header; thanks @rfk\n- bump to 1.8.8rc7\n\n3/5/2016\n- log exact version of OpenSSL and EC/GCM/Redis support\n- tidy up auth_openidc.conf docs\n- bump to 1.8.8rc6\n\n2/26/2016\n- add option to refresh claims from the userinfo endpoint using OIDCUserInfoRefreshInterval; see #119\n- merge id_token claims in to the set of claims used for authorization for Apache >=2.4; see #120\n- bump to 1.8.8rc5\n\n2/23/2016\n- make state cookie a session cookie and clean expired cookies on entry (merge of fix-firefox-cookie-storage)\n- fix HTML error template initialization in vhosts\n- bump to 1.8.8rc4\n\n2/22/2016\n- don't authenticate (redirect/state) when X-Requested-With header exists; as suggested in #113\n- bump to 1.8.8rc3\n\n2/18/2016\n- pass plain state to the token endpoint on code flows: https://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation-01\n- fix loose (prefix-only) matching of cookie names\n- allow passing OAuth bearer token as a cookie (OIDCOAuthAcceptTokenAs extension for PingAccess)\n- bump to 1.8.8rc2\n\n2/11/2016\n- include token_endpoint_auth_method in dynamic client registration request, set to selected method from provider\n\n2/10/2016\n- Elliptic Curve support now requires OpenSSL 1.0.1 detection\n- bump to 1.8.8rc1\n\n1/14/2016\n- add support for passing in OAuth bearer tokens as one or more of: header, post param or query param (OIDCOAuthAcceptTokenAs)\n- bump to 1.8.8rc0\n\n1/8/2016\n- release 1.8.7\n\n1/7/2016\n- update copyright year\n\n12/17/2015\n- enforce strict matching of issuer in Discovery document against the originally requested issuer\n- check iss/client_id if present in an authentication response\n- push a hash of state to the token endpoint on code flows\n- bump to 1.8.7rc4\n\n12/9/2015\n- improve debug logging around session management capabilities (i.e. enabled/disabled)\n- return 404 for op/rp iframes if session management is not enabled\n- bump to 1.8.7rc3\n\n12/4/2015\n- add support for RFC 7636 PKCE plain & S256 https://tools.ietf.org/html/rfc7636\n- bump to 1.8.7rc2\n\n12/3/2015\n- fix crash when using a custom error template and the error description is NULL\n- fix crash when target_link_uri is not a valid URI or parts are empty\n- fix memory corruption when using custom html template across different server requests; closes #106\n- bump to 1.8.7rc1\n\n11/18/2015\n- fix compiler warning on double sizeof call; close #103; thanks to @dcb314\n- bump to 1.8.7rc0\n\n10/26/2015\n- add option to make session cookie persistent; closes #97\n- release 1.8.6\n\n10/19/2015\n- add support for applying a custom HTML error template with OIDCHTMLErrorTemplate\n- bump to 1.8.6rc3\n\n10/12/2015\n- check the cookie domain that the session was created for against the configured domain\n- log a warning if the Set-Cookie value length is greater than 4093 bytes\n- include and prioritize the X-Forwarded-Host header in hostname determination\n- allow for missing Host header i.e. HTTP 1.0\n- return DONE instead of HTTP_UNAUTHORIZED with Discovery page (prevent double HTML in HTTP 1.0)\n- use apr_strnatcmp instead of strcmp in util.c and mod_auth_openidc.c\n- bump to 1.8.6rc2\n\n10/9/2015\n- support subdomain cookies in OIDCCookieDomain checks; PR #96, thanks @pfiled\n- bump to 1.8.6rc1\n\n10/6/2015\n- add key identifier (\"kid\") option to `OIDCOAuthVerifySharedKeys`, `OIDCOAuthVerifyCertFiles` and `OIDCPublicKeyFiles` configs\n- bump to 1.8.6rc0\n\n9/21/2015\n- support (non-sid-based) HTTP logout: http://openid.net/specs/openid-connect-logout-1_0.html\n- release 1.8.5\n\n9/16/2015\n- improve logging on provider/client/conf metadata parsing failures; closes #94\n- bump to 1.8.5rc7\n\n9/9/2015\n- fix parsing of OIDCOAuthTokenExpiryClaim, thanks to @bester #90\n- bump to 1.8.5rc6\n\n9/4/2015\n- add CSRF protection to external Discovery as well\n- allow browser back after authorization response, see #89\n- handle invalid (expired) authorization response state by sending the user to OIDCDefaultURL, see #86\n- bump to 1.8.5rc5\n\n8/26/2015\n- add CSRF protection to Discovery\n- bump to 1.8.5rc4\n\n8/19/2015\n- support encrypted JWTs using A192KW for key encryption and A192CBC-HS384 for content encryption\n- bump to 1.8.5rc3\n\n8/15/2015\n- support encrypted JWTs using RSA-OAEP for key encryption and A128GCM,A192GCM,A256GCM for content encryption\n- bump to 1.8.5rc2\n\n8/4/2015\n- support for OIDCUnAuthAction: how to act on unauthenticated requests (OIDCReturn401 is deprecated)\n- bump to 1.8.5rc1\n\n7/15/2015\n- add authentication option for Redis server with OIDCRedisCachePassword\n- bump to 1.8.5rc0\n\n7/3/2015\n- allow for compilation on Windows using VS 2013\n- bump to 1.8.4\n\n6/30/2015\n- improve memcache logging: don't report cache misses as an error, thanks to @scottdear\n- work around JSON timestamp print modifier issue (%lld) on some platforms, thanks to @ralphvanetten\n- bump to 1.8.4rc3\n\n6/24/2015\n- support passing claims as environment variables (OIDCPassClaimsAs)\n- bump to 1.8.4rc1\n\n6/22/2015\n- correct debug printout in oidc_util_read_form_encoded_params\n\n6/20/2015\n- avoid double free of JWT after parsing errors have been encountered\n- bump to 1.8.4rc0\n\n6/19/2015\n- make public keys for encrypted access tokens available in OAuth-only configurations; fixes #74\n- remove exceptions for accounts.google.com since Google is OpenID Connect compliant now\n- release 1.8.3\n\n6/15/2015\n- add a complete JWT sample that includes validation of \"exp\" and \"iat\" to the test suite\n\n6/10/2015\n- allow JSON string values for the \"active\" claim in access token validation responses\n- bump to 1.8.3rc4\n\n6/7/2015\n- improve error logging on non-supported JWT signing/encryption algorithms\n- bump to 1.8.3rc3\n\n5/31/2015\n- merge id_token (\"iss\"!) and user info claims for authz processing\n- bump to 1.8.3rc2\n\n5/29/2015\n- fix hash comparison when padded, thanks to @steverc as mentioned in #65\n- fix post-logout URL being set to SSO URL\n- add post-logout URL validation, thanks to @davidbernick\n- bump to 1.8.3rc1\n\n5/18/2015\n- fix OpenSSL version detection for Elliptic Curve support in apr_jwt_signature_to_jwk_type: include opensslv.h\n- fix hash length calculation for Elliptic Curve algorithms\n- release 1.8.2\n\n5/5/2015\n- release 1.8.1\n\n4/21/2015\n- allow setting OIDCDiscoverURL inside of Directory and Location directives as well\n- bump to 1.8.1rc5\n\n4/20/2015\n- allow setting OIDCCookie outside of Directory and Location directives as well\n- bump to 1.8.1rc4\n\n4/17/2015\n- add support for applying regular expressions to OIDCRemoteUserClaim and OIDCOAuthRemoteUserClaim\n- bump to 1.8.1rc3\n\n4/12/2015\n- make token expiry parsing of introspection result configurable (OIDCOAuthTokenExpiryClaim)\n- increase SHM cache key size from 255 to 512 (allows for JWT access tokens cache keys for introspection result)\n- bump to 1.8.1rc2\n\n4/1/2015\n- avoid timing attacks on symmetric key signature/hash comparisons as pointed out by @timmclean\n- bump to 1.8.1rc1\n\n3/19/2015\n- merge #57: fix build with OpenSSL <1.0 re. apr_jws_signature_is_ec (thanks to @szakharchenko)\n\n2/26/2015\n- release 1.8.0\n\n2/23/2015\n- avoid including line feeds in header values (thanks to @forkbomber and @ekanthi)\n- bump to 1.8.0rc5\n\n2/16/2015\n- fix free() crash on simple-valued error printouts\n- fix returning keys without a \"kid\"\n- fix searching for keys with a \"x5t\" thumbprint\n- refactor response type handling; more strict matching of requested response type\n- make compiled in Redis support optional\n- fix oauth.introspection_endpoint_method in initialization\n- bump to 1.8.0rc4\n\n2/15/2015\n- add support for configurable introspection HTTP method (OIDCOAuthIntrospectionEndpointMethod)\n- add preliminary support for GET-style logout\n- bump to 1.8.0rc2\n\n2/12/2015\n- add support for configuration of maximum session duration\n- bump to 1.8.0rc1\n\n2/9/2015\n- check JWT signature against all configured keys (jwks_uri) if no \"kid\" is provided, not just the first one\n- revise JOSE JWS handling part 2\n- complete support for local JWT access token validation\n- bump to 1.8.0rc0\n\n2/5/2015\n- fix symmetric key decryption of JWTs (A128CBC-HS256/A256CBC-HS512)\n- sha256 client secrets before using them as symmetric keys for decryption\n- extended decryption test coverage; avoid double printouts on error\n- refactor JWT header parsing\n- simplify JWK URI refresh handling\n- release 1.7.3\n\n2/4/2015\n- revise JOSE JWK handling part 1\n- change change target_uri parameter name to target_link_uri following draft-bradley-oauth-jwt-encoded-state-03\n- extended tests with stubs\n- refactor JWT validation (iss, exp, iat)\n- fix memory leak with RSA key conversion in apr_jwk.c - apr_jwk_rsa_bio_to_key\n- bump to 1.7.3rc4\n\n1/25/2015\n- Allow {... \"error\": null ...} in JSON responses. (@fatlotus)\n\n1/22/2015\n- fix configuration validation check where no config would be checked if OIDCProviderIssuer is set\n  but both OIDRedirectURI and OIDCCryptoPassphrase are not set\n- add preliminary support for local JWT access token validation\n- bump to 1.7.3rc1\n- sanitize set cookie syntax (get rid of extraneous \";\")\n\n1/21/2015\n- add support for OIDCOAuthIntrospectionTokenParamName (incl. Google OAuth 2.0 access token validation)\n- add a sample OAuth 2.0 config for Google access tokens to README.md\n- release 1.7.2\n\n- add APXS2_OPTS to configure.ac to accommodate RPM builds\n- bump to 1.7.3rc0\n- fix JWT timestamp (iat/exp) initialization issue\n- fix README.md on Google's scope required for returning the \"hd\" claim\n\n1/14/2015\n- add Apache function stubs to enable extending the scope of tests\n- add tests for oidc_proto_validate_access_token and oidc_proto_validate_code\n- bump to 1.7.2rc3\n\n1/12/2015\n- improve accuracy of expired/invalid session handling\n\n1/11/2015\n- add error type and return values to JOSE functions\n- fix return result on error in function that decrypts CEK\n- bump to 1.7.2rc2\n\n1/1/2015\n- update copyright to 2015\n- use json_int_t (seconds) for \"exp\" and \"iat\" fields, instead of apr_time_t (microseconds) \n- correct expiry debug printout\n- bump to 1.7.2rc1\n\n12/15/2014\n- fix Redis reconnect behavior: avoid keep reconnecting after first failure\n- bump to 1.7.2rc0\n\n12/12/2014\n- support passing cookies specified in OIDCPassCookies from browser on to OP/AS calls (for loadbalancing purposes)\n- release 1.7.1\n- document OIDCPassCookies in auth_openidc.conf\n\n12/10/2014\n- reconnect to the Redis server after I/O failure as raised in #43\n- bump to 1.7.1rc4\n\n12/8/2014\n- return http 500 when detecting requests that will loop on return\n- bump to 1.7.1rc3\n\n12/3/2014\n- require the expiring access_token on the refresh hook for XSRF protection\n- pass error codes back to the caller when the refresh hook fails\n- bump to 1.7.1rc2\n\n12/2/2014\n- improve handling of non-string (=non-compliant) error responses\n\n11/26/2014\n- make shared memory cache entry max size configurable through OIDCCacheShmEntrySizeMax\n- add OIDCReturn401 configuration primitive\n- bump to 1.7.1rc1\n\n11/11/2014\n- allow OIDCRedirectURI's with an empty path and fix crash; thanks to @CedricCabessa\n\n11/9/2014\n- support for adding configurable JSON parameters to Dynamic Client Registration requests\n\n11/5/2014\n- release 1.7.0\n\n10/30/2014\n- correct expires_in conversion\n- first stab at HTML templating and make all html HTML 4.01 Strict compliant\n- bump to 1.7.0rc4\n\n10/29/2014\n- document refresh flow\n\n10/28/2014\n- scrub all OIDC_ headers\n- add support for the refresh_token flow + hook\n- pass the expires_in as an absolute timestamp in OIDC_access_token_expires\n- use a global mutex for the Redis cache\n- bump to 1.7.0rc3\n\n10/27/2014\n- generalize support for OAuth 2.0 token introspection and conform to:\n  https://tools.ietf.org/html/draft-ietf-oauth-introspection-00\n\n10/26/2014\n- support regular expressions in Require statements\n\n10/24/2014\n- add support for Redis cache backend; there's a dependency on hiredis headers/library now\n\n10/21/2014\n- refactor nonce generation and remove base64url padding from value\n\n10/13/2014\n- add libssl-dev to Debian control build dependencies\n- release 1.6.0\n\n10/6/2014\n- apply html encoding to error display\n- bump version number to 1.6.0rc4\n\n10/2/2014\n- avoid crash when downloading metadata from OIDCProviderMetadataURL fails\n- set OIDCProviderMetadataURL retrieval interval to 24 hours\n- return error on configurations mixing OIDCProviderMetadataURL and OIDCMetadataDir\n- bump version number to 1.6.0rc3\n\n10/1/2014\n- support provider configuration from a metadata URL (OIDCProviderMetadataURL)\n- bump version number to 1.6.0rc2\n\n9/30/2014\n- be less strict about issuer validation in metadata\n- refactor metadata.c\n- improve logging about userinfo endpoint\n\n9/29/2014\n- refactor cache so it is partitioned in to sections (i.e. avoid future key collisions)\n\n9/25/2014\n- add support for \"x5c\" JWK representation\n- return JWKS on jwks_uri with content-type \"application/json\"\n\n9/17/2014\n- remove support for the X-Frame-Options as it is not needed in 302s\n- create and use log macros that printout function name\n\n9/16/2014\n- support for passing runtime determined authentication request parameters in the discovery response\n- include name/version in logs and bump to 1.6.0rc1\n- don't use the X-Frame-Options by default\n\n9/13/2014\n- add support for the X-Frame-Options header as recommended by the spec\n\n9/12/2014\n- set expiry on state cookies; don't clear session cookie after cache miss or corruption\n- fix JSON array memory leak in oauth.c\n\n9/10/2014\n- merge #34 (g10f), fix session management Javascript bug\n\n9/3/2014\n- improve error handling on hitting the redirect URI directly\n- fix set_slot functions for algorithm/url used as default for dynamic registration\n- rewording of auth_openidc.conf docs on JWK settings\n\n9/1/2014\n- add session management based on http://openid.net/specs/openid-connect-session-1_0.html (draft 21)\n\n8/29/2014\n- add configuration option to POST extra parameters to the token endpoint\n\n8/26/2014\n- correct cookie_path comparison\n- release 1.5.5\n\n8/20/2014\n- correctly error out on flows where no id_token was provided (\"token\")\n\n8/19/2014\n- fix debug printout on open redirect prevention\n- cleanup in-memory crypto context on shutdown\n- use default of \"/\" for OIDCCookiePath to simplify quickstart/simple deployments\n- disable OIDCMetadataDir in sample/default config file\n- clear session cookie after cache miss or corruption\n\n8/18/2014\n- add HttpOnly flag to cookies by default; can be disabled by config\n\n8/14/2014\n- support for passing the id_token in multiple formats (claims|payload|serialized)\n- release 1.5.4\n\n8/13/2014\n- pass the access_token in OIDC_access_token header to the application\n\n8/9/2014\n- merge #21 (Latinovic) to close #18 (big endian JWE issue)\n- merge #20 (wadahiro), support for \"none\" JWT signing algorithm\n\n8/1/2014\n- fix cache initialization/destroy leak\n- release 1.5.3\n\n7/26/2014\n- refactor http code; cleanup JSON encoding in client registration\n- refactor padding handling in base64url encoding/decoding\n\n7/20/2014\n- check for open redirect on passed target_link_uri\n- prevent JWE timing attacks on CEK; add JWE test\n- include client_id and scope values in resolved access_token\n\n7/1/2014\n- pass JSON objects in app HTTP headers as plain JSON\n- correct printout in id_token hash comparisons\n- add more tests\n- release 1.5.2\n\n6/12/2014\n- support third-party-initiated login as defined in the spec\n- release 1.5.1\n- fix PF OAuth 2.0 RS functionality after upgrading to jansson\n\n6/6/2014\n- more changes for Debian packaging (1.5-3)\n\n6/5/2014\n- do not set Secure cookies for plain HTTP\n- add warning/errors when configured hosts/domains do not match\n- release 1.5\n- changes for Debian packaging\n\n6/4/2014\n- fix passing integer claims on non-Mac OS X systems\n- fix claims-based authorization with integer values (@martinsrom)\n- fix getting the id_token from request state and error logging\n- add AUTHORS file with credits\n- migrate README to Markdown README.md\n\n6/3/2014\n- change JSON parser from https://github.com/moriyoshi/apr-json to http://www.digip.org/jansson/\n\n6/2/2014\n- handle X-Forwarded-Proto/X-Forwarded-Port when running behind a proxy/load-balancer\n- release version 1.4\n\n6/1/2014\n- compile with OpenSSL <1.0 and but then disable Elliptic Curve verification\n- fix jwks_uri setting in nested vhosts\n- use OpenSSL_add_all_digests in initialization and EVP_cleanup on shutdown\n\n5/31/2014\n- README additions/improvements\n\n5/29/2014\n- correct big endian detection\n- allow for key identification in JWKs based on thumbprint (x5t)\n\n5/24/2014\n- add cache destroy function and destroy shm cache resources on shutdown\n\n5/23/2014\n- doc corrections to auth_openidc.conf\n\n5/22/2014\n- add implementation of OP-initiated-SSO based on:\n  http://tools.ietf.org/html/draft-bradley-oauth-jwt-encoded-state-01\n- fix nonce caching for replay prevention\n\n5/21/2014\n- correct README on enabling Google+ APIs before applying the sample Google configs\n- fix AuthNHeader setting and allow server-wide config too\n- avoid segfault on corrupted/non- JSON/JWT input\n\n5/20/2014\n- fix URL assembly when running on non-standard port\n- release 1.3\n\n5/17/2014\n- support outgoing proxy using OIDCOutgoingProxy\n- correct sample configs in documentation for missing OIDCCookiePath\n- support OIDCCookiePath in server-wide config as well\n\n5/13/2014\n- support configurable (custom) query parameters in the authorization request\n\n5/12/2014\n- support encrypted JWTs using A128KW and A256KW for the Content Encryption Key\n- support A256CBC-HS512 encrypted JWTs\n- support custom client JWKs URI\n\n5/8/2014\n- support encrypted JWTs using RSA1_5 and A128CBC-HS256\n\n5/2/2014\n- do not use ap_get_remote_host for browser fingerprinting\n\n5/1/2014\n- split out custom client config into separate <issuer>.conf file\n- allow to override client_contact, client_name and registration_token in .conf file\n- remove OIDCRegistrationToken command for the static OP config\n\n4/29/2014\n- support JWT verification of ES256, ES384 and ES512 algorithms\n\n4/28/2014\n- support configurable response_mode (fragment, query or form_post)\n- use nonce in all flows except for OP Google and flows \"code\" or \"code token\"\n\n4/26/2014\n- make client secret optional (support self-issued OP)\n\n4/25/2014\n- support Hybrid flows\n\n4/24/2014\n- fix using Bearer token Authorization header on JSON POST calls\n- support using a Bearer token on client registration calls\n\n4/22/2014\n- match request and response type \n- check at_hash value on \"token id_token\" implicit flow\n- use shared memory caching by default\n- release 1.2\n\n4/19/2014\n- store response_type in state and make state a JSON object\n\n4/18/2014\n- support RSASSA-PSS token signing algorithms (PS256,PS384,PS512)\n\n4/17/2014\n- improve session inactivity timeout handling\n\n4/16/2014\n- set REMOTE_USER and HTTP headers on OAuth 2.0 protected paths\n\n4/15/2014\n- add session inactivity timeout\n- register all supported response_types during client registration and try\n  to pick the one that matches the configured default\n- use long timeouts on JWK retrieval calls\n- allow for non-null but empty query parameters on implicit authorization response\n- simplify azp/aud and nonce handling\n- change session_type naming (to \"server-cache\"/\"client-cookie\")\n\n4/14/2014\n- factor out JOSE related code\n\n4/3/2014\n- add configurable claim name for the REMOTE_USER variable, optionally postfixed with the  url-encoded\n  issuer value; the default for the remote username is \"sub@\" now, makeing it unique across OPs\n- some refactoring of id_token validation functions\n- add INSTALL, move auth_openidc.conf to main directory\n- release 1.1\n\n3/28/2014\n- fix Require claim name mismatch for Apache 2.4\n- fix hmac method/printout naming artifacts from earlier\nauto-search-and-replace\n- release v1.0.1\n\n3/27/2014\n- initial import named mod_auth_openidc\n- updated README\n- fix debian/changelog\n", "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/***************************************************************************\n * Copyright (C) 2013-2017 Ping Identity Corporation\n * All rights reserved.\n *\n * For further information please contact:\n *\n *      Ping Identity Corporation\n *      1099 18th St Suite 2950\n *      Denver, CO 80202\n *      303.468.2900\n *      http://www.pingidentity.com\n *\n * DISCLAIMER OF WARRANTIES:\n *\n * THE SOFTWARE PROVIDED HEREUNDER IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT\n * ANY WARRANTIES OR REPRESENTATIONS EXPRESS, IMPLIED OR STATUTORY; INCLUDING,\n * WITHOUT LIMITATION, WARRANTIES OF QUALITY, PERFORMANCE, NONINFRINGEMENT,\n * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  NOR ARE THERE ANY\n * WARRANTIES CREATED BY A COURSE OR DEALING, COURSE OF PERFORMANCE OR TRADE\n * USAGE.  FURTHERMORE, THERE ARE NO WARRANTIES THAT THE SOFTWARE WILL MEET\n * YOUR NEEDS OR BE FREE FROM ERRORS, OR THAT THE OPERATION OF THE SOFTWARE\n * WILL BE UNINTERRUPTED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Initially based on mod_auth_cas.c:\n * https://github.com/Jasig/mod_auth_cas\n *\n * Other code copied/borrowed/adapted:\n * shared memory caching: mod_auth_mellon\n *\n * @Author: Hans Zandbelt - hzandbelt@pingidentity.com\n *\n **************************************************************************/\n\n#include \"apr_hash.h\"\n#include \"apr_strings.h\"\n#include \"ap_config.h\"\n#include \"ap_provider.h\"\n#include \"apr_lib.h\"\n#include \"apr_file_io.h\"\n#include \"apr_sha1.h\"\n#include \"apr_base64.h\"\n\n#include \"httpd.h\"\n#include \"http_core.h\"\n#include \"http_config.h\"\n#include \"http_log.h\"\n#include \"http_protocol.h\"\n#include \"http_request.h\"\n\n#include \"mod_auth_openidc.h\"\n\n// TODO:\n// - sort out oidc_cfg vs. oidc_dir_cfg stuff\n// - rigid input checking on discovery responses\n// - check self-issued support\n// - README.quickstart\n// - refresh metadata once-per too? (for non-signing key changes)\n\nextern module AP_MODULE_DECLARE_DATA auth_openidc_module;\n\n/*\n * clean any suspicious headers in the HTTP request sent by the user agent\n */\nstatic void oidc_scrub_request_headers(request_rec *r, const char *claim_prefix,\n\t\tconst char *authn_header) {\n\n\tconst int prefix_len = claim_prefix ? strlen(claim_prefix) : 0;\n\n\t/* get an array representation of the incoming HTTP headers */\n\tconst apr_array_header_t * const h = apr_table_elts(r->headers_in);\n\n\t/* table to keep the non-suspicious headers */\n\tapr_table_t *clean_headers = apr_table_make(r->pool, h->nelts);\n\n\t/* loop over the incoming HTTP headers */\n\tconst apr_table_entry_t * const e = (const apr_table_entry_t *) h->elts;\n\tint i;\n\tfor (i = 0; i < h->nelts; i++) {\n\t\tconst char * const k = e[i].key;\n\n\t\t/* is this header's name equivalent to the header that mod_auth_openidc would set for the authenticated user? */\n\t\tconst int authn_header_matches = (k != NULL) && authn_header\n\t\t\t\t&& (oidc_strnenvcmp(k, authn_header, -1) == 0);\n\n\t\t/*\n\t\t * would this header be interpreted as a mod_auth_openidc attribute? Note\n\t\t * that prefix_len will be zero if no attr_prefix is defined,\n\t\t * so this will always be false. Also note that we do not\n\t\t * scrub headers if the prefix is empty because every header\n\t\t * would match.\n\t\t */\n\t\tconst int prefix_matches = (k != NULL) && prefix_len\n\t\t\t\t&& (oidc_strnenvcmp(k, claim_prefix, prefix_len) == 0);\n\n\t\t/* add to the clean_headers if non-suspicious, skip and report otherwise */\n\t\tif (!prefix_matches && !authn_header_matches) {\n\t\t\tapr_table_addn(clean_headers, k, e[i].val);\n\t\t} else {\n\t\t\toidc_warn(r, \"scrubbed suspicious request header (%s: %.32s)\", k,\n\t\t\t\t\te[i].val);\n\t\t}\n\t}\n\n\t/* overwrite the incoming headers with the cleaned result */\n\tr->headers_in = clean_headers;\n}\n\n/*\n * strip the session cookie from the headers sent to the application/backend\n */\nstatic void oidc_strip_cookies(request_rec *r) {\n\n\tchar *cookie, *ctx, *result = NULL;\n\tconst char *name = NULL;\n\tint i;\n\n\tapr_array_header_t *strip = oidc_dir_cfg_strip_cookies(r);\n\n\tchar *cookies = apr_pstrdup(r->pool,\n\t\t\t(char *) apr_table_get(r->headers_in, \"Cookie\"));\n\n\tif ((cookies != NULL) && (strip != NULL)) {\n\n\t\toidc_debug(r,\n\t\t\t\t\"looking for the following cookies to strip from cookie header: %s\",\n\t\t\t\tapr_array_pstrcat(r->pool, strip, ','));\n\n\t\tcookie = apr_strtok(cookies, \";\", &ctx);\n\n\t\tdo {\n\t\t\twhile (cookie != NULL && *cookie == ' ')\n\t\t\t\tcookie++;\n\n\t\t\tfor (i = 0; i < strip->nelts; i++) {\n\t\t\t\tname = ((const char**) strip->elts)[i];\n\t\t\t\tif ((strncmp(cookie, name, strlen(name)) == 0)\n\t\t\t\t\t\t&& (cookie[strlen(name)] == '=')) {\n\t\t\t\t\toidc_debug(r, \"stripping: %s\", name);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i == strip->nelts) {\n\t\t\t\tresult =\n\t\t\t\t\t\tresult ?\n\t\t\t\t\t\t\t\tapr_psprintf(r->pool, \"%s;%s\", result, cookie) :\n\t\t\t\t\t\t\t\tcookie;\n\t\t\t}\n\n\t\t\tcookie = apr_strtok(NULL, \";\", &ctx);\n\t\t} while (cookie != NULL);\n\n\t\tif (result != NULL) {\n\t\t\toidc_debug(r, \"set cookie to backend to: %s\",\n\t\t\t\t\tresult ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \"\\\"%s\\\"\", result) : \"<null>\");\n\t\t\tapr_table_set(r->headers_in, \"Cookie\", result);\n\t\t} else {\n\t\t\toidc_debug(r, \"unsetting all cookies to backend\");\n\t\t\tapr_table_unset(r->headers_in, \"Cookie\");\n\t\t}\n\n\t}\n}\n\n#define OIDC_SHA1_LEN 20\n\n/*\n * calculates a hash value based on request fingerprint plus a provided nonce string.\n */\nstatic char *oidc_get_browser_state_hash(request_rec *r, const char *nonce) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* helper to hold to header values */\n\tconst char *value = NULL;\n\t/* the hash context */\n\tapr_sha1_ctx_t sha1;\n\n\t/* Initialize the hash context */\n\tapr_sha1_init(&sha1);\n\n\t/* get the X_FORWARDED_FOR header value  */\n\tvalue = (char *) apr_table_get(r->headers_in, \"X_FORWARDED_FOR\");\n\t/* if we have a value for this header, concat it to the hash input */\n\tif (value != NULL)\n\t\tapr_sha1_update(&sha1, value, strlen(value));\n\n\t/* get the USER_AGENT header value  */\n\tvalue = (char *) apr_table_get(r->headers_in, \"USER_AGENT\");\n\t/* if we have a value for this header, concat it to the hash input */\n\tif (value != NULL)\n\t\tapr_sha1_update(&sha1, value, strlen(value));\n\n\t/* get the remote client IP address or host name */\n\t/*\n\tint remotehost_is_ip;\n\tvalue = ap_get_remote_host(r->connection, r->per_dir_config,\n\t\t\tREMOTE_NOLOOKUP, &remotehost_is_ip);\n\tapr_sha1_update(&sha1, value, strlen(value));\n\t*/\n\n\t/* concat the nonce parameter to the hash input */\n\tapr_sha1_update(&sha1, nonce, strlen(nonce));\n\n\t/* finalize the hash input and calculate the resulting hash output */\n\tunsigned char hash[OIDC_SHA1_LEN];\n\tapr_sha1_final(hash, &sha1);\n\n\t/* base64url-encode the resulting hash and return it */\n\tchar *result = NULL;\n\toidc_base64url_encode(r, &result, (const char *) hash, OIDC_SHA1_LEN, TRUE);\n\treturn result;\n}\n\n/*\n * return the name for the state cookie\n */\nstatic char *oidc_get_state_cookie_name(request_rec *r, const char *state) {\n\treturn apr_psprintf(r->pool, \"%s%s\", OIDCStateCookiePrefix, state);\n}\n\n/*\n * return the static provider configuration, i.e. from a metadata URL or configuration primitives\n */\nstatic apr_byte_t oidc_provider_static_config(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t **provider) {\n\n\tjson_t *j_provider = NULL;\n\tconst char *s_json = NULL;\n\n\t/* see if we should configure a static provider based on external (cached) metadata */\n\tif ((c->metadata_dir != NULL) || (c->provider.metadata_url == NULL)) {\n\t\t*provider = &c->provider;\n\t\treturn TRUE;\n\t}\n\n\tc->cache->get(r, OIDC_CACHE_SECTION_PROVIDER,\n\t\t\toidc_util_escape_string(r, c->provider.metadata_url), &s_json);\n\n\tif (s_json == NULL) {\n\n\t\tif (oidc_metadata_provider_retrieve(r, c, NULL,\n\t\t\t\tc->provider.metadata_url, &j_provider, &s_json) == FALSE) {\n\t\t\toidc_error(r, \"could not retrieve metadata from url: %s\",\n\t\t\t\t\tc->provider.metadata_url);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tc->cache->set(r, OIDC_CACHE_SECTION_PROVIDER,\n\t\t\t\toidc_util_escape_string(r, c->provider.metadata_url), s_json,\n\t\t\t\tapr_time_now()\n\t\t\t\t+ (c->provider_metadata_refresh_interval <= 0 ?\n\t\t\t\t\t\tapr_time_from_sec(\n\t\t\t\t\t\t\t\tOIDC_CACHE_PROVIDER_METADATA_EXPIRY_DEFAULT) :\n\t\t\t\t\t\t\t\tc->provider_metadata_refresh_interval));\n\n\t} else {\n\n\t\t/* correct parsing and validation was already done when it was put in the cache */\n\t\tj_provider = json_loads(s_json, 0, 0);\n\t}\n\n\t*provider = apr_pcalloc(r->pool, sizeof(oidc_provider_t));\n\tmemcpy(*provider, &c->provider, sizeof(oidc_provider_t));\n\n\tif (oidc_metadata_provider_parse(r, c, j_provider, *provider) == FALSE) {\n\t\toidc_error(r, \"could not parse metadata from url: %s\",\n\t\t\t\tc->provider.metadata_url);\n\t\tif (j_provider)\n\t\t\tjson_decref(j_provider);\n\t\treturn FALSE;\n\t}\n\n\tjson_decref(j_provider);\n\n\treturn TRUE;\n}\n\n/*\n * return the oidc_provider_t struct for the specified issuer\n */\nstatic oidc_provider_t *oidc_get_provider_for_issuer(request_rec *r,\n\t\toidc_cfg *c, const char *issuer, apr_byte_t allow_discovery) {\n\n\t/* by default we'll assume that we're dealing with a single statically configured OP */\n\toidc_provider_t *provider = NULL;\n\tif (oidc_provider_static_config(r, c, &provider) == FALSE)\n\t\treturn NULL;\n\n\t/* unless a metadata directory was configured, so we'll try and get the provider settings from there */\n\tif (c->metadata_dir != NULL) {\n\n\t\t/* try and get metadata from the metadata directory for the OP that sent this response */\n\t\tif ((oidc_metadata_get(r, c, issuer, &provider, allow_discovery)\n\t\t\t\t== FALSE) || (provider == NULL)) {\n\n\t\t\t/* don't know nothing about this OP/issuer */\n\t\t\toidc_error(r, \"no provider metadata found for issuer \\\"%s\\\"\",\n\t\t\t\t\tissuer);\n\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn provider;\n}\n\n/*\n * find out whether the request is a response from an IDP discovery page\n */\nstatic apr_byte_t oidc_is_discovery_response(request_rec *r, oidc_cfg *cfg) {\n\t/*\n\t * prereq: this is a call to the configured redirect_uri, now see if:\n\t * the OIDC_DISC_OP_PARAM is present\n\t */\n\treturn oidc_util_request_has_parameter(r, OIDC_DISC_OP_PARAM)\n\t\t\t|| oidc_util_request_has_parameter(r, OIDC_DISC_USER_PARAM);\n}\n\n/*\n * return the HTTP method being called: only for POST data persistence purposes\n */\nstatic const char *oidc_original_request_method(request_rec *r, oidc_cfg *cfg,\n\t\tapr_byte_t handle_discovery_response) {\n\tconst char *method = OIDC_METHOD_GET;\n\n\tchar *m = NULL;\n\tif ((handle_discovery_response == TRUE)\n\t\t\t&& (oidc_util_request_matches_url(r, cfg->redirect_uri))\n\t\t\t&& (oidc_is_discovery_response(r, cfg))) {\n\t\toidc_util_get_request_parameter(r, OIDC_DISC_RM_PARAM, &m);\n\t\tif (m != NULL)\n\t\t\tmethod = apr_pstrdup(r->pool, m);\n\t} else {\n\n\t\t/*\n\t\t * if POST preserve is not enabled for this location, there's no point in preserving\n\t\t * the method either which would result in POSTing empty data on return;\n\t\t * so we revert to legacy behavior\n\t\t */\n\t\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\t\treturn OIDC_METHOD_GET;\n\n\t\tconst char *content_type = apr_table_get(r->headers_in, \"Content-Type\");\n\t\tif ((r->method_number == M_POST)\n\t\t\t\t&& (apr_strnatcmp(content_type,\n\t\t\t\t\t\t\"application/x-www-form-urlencoded\") == 0))\n\t\t\tmethod = OIDC_METHOD_FORM_POST;\n\t}\n\n\toidc_debug(r, \"return: %s\", method);\n\n\treturn method;\n}\n\n/*\n * send an OpenID Connect authorization request to the specified provider preserving POST parameters using HTML5 storage\n */\napr_byte_t oidc_post_preserve_javascript(request_rec *r, const char *location,\n\t\tchar **javascript, char **javascript_method) {\n\n\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\treturn FALSE;\n\n\toidc_debug(r, \"enter\");\n\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\n\tif (apr_strnatcmp(method, OIDC_METHOD_FORM_POST) != 0)\n\t\treturn FALSE;\n\n\t/* read the parameters that are POST-ed to us */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params) == FALSE) {\n\t\toidc_error(r, \"something went wrong when reading the POST parameters\");\n\t\treturn FALSE;\n\t}\n\n\tconst apr_array_header_t *arr = apr_table_elts(params);\n\tconst apr_table_entry_t *elts = (const apr_table_entry_t*) arr->elts;\n\tint i;\n\tchar *json = \"\";\n\tfor (i = 0; i < arr->nelts; i++) {\n\t\tjson = apr_psprintf(r->pool, \"%s'%s': '%s'%s\", json,\n\t\t\t\toidc_util_escape_string(r, elts[i].key),\n\t\t\t\toidc_util_escape_string(r, elts[i].val),\n\t\t\t\ti < arr->nelts - 1 ? \",\" : \"\");\n\t}\n\tjson = apr_psprintf(r->pool, \"{ %s }\", json);\n\n\tconst char *jmethod = \"preserveOnLoad\";\n\tconst char *jscript =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        localStorage.setItem('mod_auth_openidc_preserve_post_params', JSON.stringify(%s));\\n\"\n\t\t\t\t\t\"        %s\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", jmethod, json,\n\t\t\t\t\tlocation ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \"window.location='%s';\\n\",\n\t\t\t\t\t\t\t\t\tlocation) :\n\t\t\t\t\t\t\t\t\t\"\");\n\tif (location == NULL) {\n\t\tif (javascript_method)\n\t\t\t*javascript_method = apr_pstrdup(r->pool, jmethod);\n\t\tif (javascript)\n\t\t\t*javascript = apr_pstrdup(r->pool, jscript);\n\t} else {\n\t\toidc_util_html_send(r, \"Preserving...\", jscript, jmethod,\n\t\t\t\t\"<p>Preserving...</p>\", DONE);\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * restore POST parameters on original_url from HTML5 local storage\n */\nstatic int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(localStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t localStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = decodeURIComponent(key);\\n\"\n\t\t\t\t\t\"          input.value = decodeURIComponent(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = '%s';\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, original_url);\n\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tDONE);\n}\n\n/*\n * parse state that was sent to us by the issuer\n */\nstatic apr_byte_t oidc_unsolicited_proto_state(request_rec *r, oidc_cfg *c,\n\t\tconst char *state, json_t **proto_state) {\n\n\tchar *alg = NULL;\n\toidc_debug(r, \"enter: state header=%s\",\n\t\t\toidc_proto_peek_jwt_header(r, state, &alg));\n\n\toidc_jose_error_t err;\n\toidc_jwk_t *jwk = NULL;\n\tif (oidc_util_create_symmetric_key(r, c->provider.client_secret,\n\t\t\toidc_alg2keysize(alg), \"sha256\",\n\t\t\tTRUE, &jwk) == FALSE)\n\t\treturn FALSE;\n\n\toidc_jwt_t *jwt = NULL;\n\tif (oidc_jwt_parse(r->pool, state, &jwt,\n\t\t\toidc_util_merge_symmetric_key(r->pool, c->private_keys, jwk),\n\t\t\t&err) == FALSE) {\n\t\toidc_error(r,\n\t\t\t\t\"could not parse JWT from state: invalid unsolicited response: %s\",\n\t\t\t\toidc_jose_e2s(r->pool, err));\n\t\treturn FALSE;\n\t}\n\n\toidc_jwk_destroy(jwk);\n\toidc_debug(r, \"successfully parsed JWT from state\");\n\n\tif (jwt->payload.iss == NULL) {\n\t\toidc_error(r, \"no \\\"iss\\\" could be retrieved from JWT state, aborting\");\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\toidc_provider_t *provider = oidc_get_provider_for_issuer(r, c,\n\t\t\tjwt->payload.iss, FALSE);\n\tif (provider == NULL) {\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\t/* validate the state JWT, validating optional exp + iat */\n\tif (oidc_proto_validate_jwt(r, jwt, provider->issuer, FALSE, FALSE,\n\t\t\tprovider->idtoken_iat_slack) == FALSE) {\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\tchar *rfp = NULL;\n\tif (oidc_jose_get_string(r->pool, jwt->payload.value.json, \"rfp\", TRUE,\n\t\t\t&rfp, &err) == FALSE) {\n\t\toidc_error(r,\n\t\t\t\t\"no \\\"rfp\\\" claim could be retrieved from JWT state, aborting: %s\",\n\t\t\t\toidc_jose_e2s(r->pool, err));\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\tif (apr_strnatcmp(rfp, \"iss\") != 0) {\n\t\toidc_error(r, \"\\\"rfp\\\" (%s) does not match \\\"iss\\\", aborting\", rfp);\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\tchar *target_link_uri = NULL;\n\toidc_jose_get_string(r->pool, jwt->payload.value.json, \"target_link_uri\",\n\t\t\tFALSE, &target_link_uri, NULL);\n\tif (target_link_uri == NULL) {\n\t\tif (c->default_sso_url == NULL) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"no \\\"target_link_uri\\\" claim could be retrieved from JWT state and no OIDCDefaultURL is set, aborting\");\n\t\t\toidc_jwt_destroy(jwt);\n\t\t\treturn FALSE;\n\t\t}\n\t\ttarget_link_uri = c->default_sso_url;\n\t}\n\n\tif (c->metadata_dir != NULL) {\n\t\tif ((oidc_metadata_get(r, c, jwt->payload.iss, &provider, FALSE)\n\t\t\t\t== FALSE) || (provider == NULL)) {\n\t\t\toidc_error(r, \"no provider metadata found for provider \\\"%s\\\"\",\n\t\t\t\t\tjwt->payload.iss);\n\t\t\toidc_jwt_destroy(jwt);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tchar *jti = NULL;\n\toidc_jose_get_string(r->pool, jwt->payload.value.json, \"jti\", FALSE, &jti,\n\t\t\tNULL);\n\tif (jti == NULL) {\n\t\tchar *cser = oidc_jwt_serialize(r->pool, jwt, &err);\n\t\tif (cser == NULL)\n\t\t\treturn FALSE;\n\t\tif (oidc_util_hash_string_and_base64url_encode(r, \"sha256\", cser,\n\t\t\t\t&jti) == FALSE) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"oidc_util_hash_string_and_base64url_encode returned an error\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tconst char *replay = NULL;\n\tc->cache->get(r, OIDC_CACHE_SECTION_JTI, jti, &replay);\n\tif (replay != NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"the jti value (%s) passed in the browser state was found in the cache already; possible replay attack!?\",\n\t\t\t\tjti);\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\t/* jti cache duration is the configured replay prevention window for token issuance plus 10 seconds for safety */\n\tapr_time_t jti_cache_duration = apr_time_from_sec(\n\t\t\tprovider->idtoken_iat_slack * 2 + 10);\n\n\t/* store it in the cache for the calculated duration */\n\tc->cache->set(r, OIDC_CACHE_SECTION_JTI, jti, jti,\n\t\t\tapr_time_now() + jti_cache_duration);\n\n\toidc_debug(r,\n\t\t\t\"jti \\\"%s\\\" validated successfully and is now cached for %\" APR_TIME_T_FMT \" seconds\",\n\t\t\tjti, apr_time_sec(jti_cache_duration));\n\n\tjwk = NULL;\n\tif (oidc_util_create_symmetric_key(r, c->provider.client_secret, 0,\n\t\t\tNULL, TRUE, &jwk) == FALSE)\n\t\treturn FALSE;\n\n\toidc_jwks_uri_t jwks_uri = { provider->jwks_uri,\n\t\t\tprovider->jwks_refresh_interval, provider->ssl_validate_server };\n\tif (oidc_proto_jwt_verify(r, c, jwt, &jwks_uri,\n\t\t\toidc_util_merge_symmetric_key(r->pool, NULL, jwk)) == FALSE) {\n\t\toidc_error(r, \"state JWT could not be validated, aborting\");\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\toidc_jwk_destroy(jwk);\n\toidc_debug(r, \"successfully verified state JWT\");\n\n\t*proto_state = json_object();\n\tjson_object_set_new(*proto_state, \"issuer\", json_string(jwt->payload.iss));\n\tjson_object_set_new(*proto_state, \"original_url\",\n\t\t\tjson_string(target_link_uri));\n\tjson_object_set_new(*proto_state, \"original_method\", json_string(\"get\"));\n\tjson_object_set_new(*proto_state, \"response_mode\",\n\t\t\tjson_string(provider->response_mode));\n\tjson_object_set_new(*proto_state, \"response_type\",\n\t\t\tjson_string(provider->response_type));\n\tjson_object_set_new(*proto_state, \"timestamp\",\n\t\t\tjson_integer(apr_time_sec(apr_time_now())));\n\n\toidc_jwt_destroy(jwt);\n\n\treturn TRUE;\n}\n\n/* obtain the state from the cookie value */\nstatic json_t * oidc_get_state_from_cookie(request_rec *r, oidc_cfg *c,\n\t\tconst char *cookieValue) {\n\tjson_t *result = NULL;\n\toidc_util_jwt_verify(r, c->crypto_passphrase, cookieValue, &result);\n\treturn result;\n}\n\nstatic void oidc_clean_expired_state_cookies(request_rec *r, oidc_cfg *c) {\n\tchar *cookie, *tokenizerCtx;\n\tchar *cookies = apr_pstrdup(r->pool,\n\t\t\t(char *) apr_table_get(r->headers_in, \"Cookie\"));\n\tif (cookies != NULL) {\n\t\tcookie = apr_strtok(cookies, \";\", &tokenizerCtx);\n\t\tdo {\n\t\t\twhile (cookie != NULL && *cookie == ' ')\n\t\t\t\tcookie++;\n\t\t\tif (strstr(cookie, OIDCStateCookiePrefix) == cookie) {\n\t\t\t\tchar *cookieName = cookie;\n\t\t\t\twhile (cookie != NULL && *cookie != '=')\n\t\t\t\t\tcookie++;\n\t\t\t\tif (*cookie == '=') {\n\t\t\t\t\t*cookie = '\\0';\n\t\t\t\t\tcookie++;\n\t\t\t\t\tjson_t *state = oidc_get_state_from_cookie(r, c, cookie);\n\t\t\t\t\tif (state != NULL) {\n\t\t\t\t\t\tjson_t *v = json_object_get(state, \"timestamp\");\n\t\t\t\t\t\tapr_time_t now = apr_time_sec(apr_time_now());\n\t\t\t\t\t\tif (now > json_integer_value(v) + c->state_timeout) {\n\t\t\t\t\t\t\toidc_error(r, \"state has expired\");\n\t\t\t\t\t\t\toidc_util_set_cookie(r, cookieName, \"\", 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjson_decref(state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcookie = apr_strtok(NULL, \";\", &tokenizerCtx);\n\t\t} while (cookie != NULL);\n\t}\n}\n\n/*\n * restore the state that was maintained between authorization request and response in an encrypted cookie\n */\nstatic apr_byte_t oidc_restore_proto_state(request_rec *r, oidc_cfg *c,\n\t\tconst char *state, json_t **proto_state) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* clean expired state cookies to avoid pollution */\n\toidc_clean_expired_state_cookies(r, c);\n\n\tconst char *cookieName = oidc_get_state_cookie_name(r, state);\n\n\t/* get the state cookie value first */\n\tchar *cookieValue = oidc_util_get_cookie(r, cookieName);\n\tif (cookieValue == NULL) {\n\t\toidc_error(r, \"no \\\"%s\\\" state cookie found\", cookieName);\n\t\treturn oidc_unsolicited_proto_state(r, c, state, proto_state);\n\t}\n\n\t/* clear state cookie because we don't need it anymore */\n\toidc_util_set_cookie(r, cookieName, \"\", 0);\n\n\t*proto_state = oidc_get_state_from_cookie(r, c, cookieValue);\n\tif (*proto_state == NULL)\n\t\treturn FALSE;\n\n\tjson_t *v = json_object_get(*proto_state, \"nonce\");\n\n\t/* calculate the hash of the browser fingerprint concatenated with the nonce */\n\tchar *calc = oidc_get_browser_state_hash(r, json_string_value(v));\n\t/* compare the calculated hash with the value provided in the authorization response */\n\tif (apr_strnatcmp(calc, state) != 0) {\n\t\toidc_error(r,\n\t\t\t\t\"calculated state from cookie does not match state parameter passed back in URL: \\\"%s\\\" != \\\"%s\\\"\",\n\t\t\t\tstate, calc);\n\t\tjson_decref(*proto_state);\n\t\treturn FALSE;\n\t}\n\n\tv = json_object_get(*proto_state, \"timestamp\");\n\tapr_time_t now = apr_time_sec(apr_time_now());\n\n\t/* check that the timestamp is not beyond the valid interval */\n\tif (now > json_integer_value(v) + c->state_timeout) {\n\t\toidc_error(r, \"state has expired\");\n\t\tjson_decref(*proto_state);\n\t\treturn FALSE;\n\t}\n\n\t/* add the state */\n\tjson_object_set_new(*proto_state, \"state\", json_string(state));\n\n\tchar *s_value = json_dumps(*proto_state, JSON_ENCODE_ANY);\n\toidc_debug(r, \"restored state: %s\", s_value);\n\tfree(s_value);\n\n\t/* we've made it */\n\treturn TRUE;\n}\n\n/*\n * set the state that is maintained between an authorization request and an authorization response\n * in a cookie in the browser that is cryptographically bound to that state\n */\nstatic apr_byte_t oidc_authorization_request_set_cookie(request_rec *r,\n\t\toidc_cfg *c, const char *state, json_t *proto_state) {\n\t/*\n\t * create a cookie consisting of 8 elements:\n\t * random value, original URL, original method, issuer, response_type, response_mod, prompt and timestamp\n\t * encoded as JSON\n\t */\n\n\t/* encrypt the resulting JSON value  */\n\tchar *cookieValue = NULL;\n\n\tif (oidc_util_jwt_create(r, c->crypto_passphrase, proto_state,\n\t\t\t&cookieValue) == FALSE)\n\t\treturn FALSE;\n\n\t/* clean expired state cookies to avoid pollution */\n\toidc_clean_expired_state_cookies(r, c);\n\n\t/* assemble the cookie name for the state cookie */\n\tconst char *cookieName = oidc_get_state_cookie_name(r, state);\n\n\t/* set it as a cookie */\n\toidc_util_set_cookie(r, cookieName, cookieValue, -1);\n\n\t//free(s_value);\n\n\treturn TRUE;\n}\n\n/*\n * get the mod_auth_openidc related context from the (userdata in the) request\n * (used for passing state between various Apache request processing stages and hook callbacks)\n */\nstatic apr_table_t *oidc_request_state(request_rec *rr) {\n\n\t/* our state is always stored in the main request */\n\trequest_rec *r = (rr->main != NULL) ? rr->main : rr;\n\n\t/* our state is a table, get it */\n\tapr_table_t *state = NULL;\n\tapr_pool_userdata_get((void **) &state, OIDC_USERDATA_KEY, r->pool);\n\n\t/* if it does not exist, we'll create a new table */\n\tif (state == NULL) {\n\t\tstate = apr_table_make(r->pool, 5);\n\t\tapr_pool_userdata_set(state, OIDC_USERDATA_KEY, NULL, r->pool);\n\t}\n\n\t/* return the resulting table, always non-null now */\n\treturn state;\n}\n\n/*\n * set a name/value pair in the mod_auth_openidc-specific request context\n * (used for passing state between various Apache request processing stages and hook callbacks)\n */\nvoid oidc_request_state_set(request_rec *r, const char *key, const char *value) {\n\n\t/* get a handle to the global state, which is a table */\n\tapr_table_t *state = oidc_request_state(r);\n\n\t/* put the name/value pair in that table */\n\tapr_table_setn(state, key, value);\n}\n\n/*\n * get a name/value pair from the mod_auth_openidc-specific request context\n * (used for passing state between various Apache request processing stages and hook callbacks)\n */\nconst char*oidc_request_state_get(request_rec *r, const char *key) {\n\n\t/* get a handle to the global state, which is a table */\n\tapr_table_t *state = oidc_request_state(r);\n\n\t/* return the value from the table */\n\treturn apr_table_get(state, key);\n}\n\n/*\n * set the claims from a JSON object (c.q. id_token or user_info response) stored\n * in the session in to HTTP headers passed on to the application\n */\nstatic apr_byte_t oidc_set_app_claims(request_rec *r,\n\t\tconst oidc_cfg * const cfg, oidc_session_t *session,\n\t\tconst char *s_claims) {\n\n\tjson_t *j_claims = NULL;\n\n\t/* decode the string-encoded attributes in to a JSON structure */\n\tif (s_claims != NULL) {\n\t\tjson_error_t json_error;\n\t\tj_claims = json_loads(s_claims, 0, &json_error);\n\n\t\tif (j_claims == NULL) {\n\t\t\t/* whoops, JSON has been corrupted */\n\t\t\toidc_error(r,\n\t\t\t\t\t\"unable to parse \\\"%s\\\" JSON stored in the session: %s\",\n\t\t\t\t\ts_claims, json_error.text);\n\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/* set the resolved claims a HTTP headers for the application */\n\tif (j_claims != NULL) {\n\t\toidc_util_set_app_infos(r, j_claims, cfg->claim_prefix,\n\t\t\t\tcfg->claim_delimiter, oidc_cfg_dir_pass_info_in_headers(r),\n\t\t\t\toidc_cfg_dir_pass_info_in_envvars(r));\n\n\t\t/* release resources */\n\t\tjson_decref(j_claims);\n\t}\n\n\treturn TRUE;\n}\n\nstatic int oidc_authenticate_user(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t *provider, const char *original_url,\n\t\tconst char *login_hint, const char *id_token_hint, const char *prompt,\n\t\tconst char *auth_request_params);\n\n/*\n * log message about max session duration\n */\nstatic void oidc_log_session_expires(request_rec *r, apr_time_t session_expires) {\n\tchar buf[APR_RFC822_DATE_LEN + 1];\n\tapr_rfc822_date(buf, session_expires);\n\toidc_debug(r, \"session expires %s (in %\" APR_TIME_T_FMT \" secs from now)\",\n\t\t\tbuf, apr_time_sec(session_expires - apr_time_now()));\n}\n\n/*\n * check if maximum session duration was exceeded\n */\nstatic int oidc_check_max_session_duration(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session) {\n\tconst char *s_session_expires = NULL;\n\tapr_time_t session_expires;\n\n\t/* get the session expiry from the session data */\n\toidc_session_get(r, session, OIDC_SESSION_EXPIRES_SESSION_KEY,\n\t\t\t&s_session_expires);\n\n\t/* convert the string to a timestamp */\n\tsscanf(s_session_expires, \"%\" APR_TIME_T_FMT, &session_expires);\n\n\t/* check the expire timestamp against the current time */\n\tif (apr_time_now() > session_expires) {\n\t\toidc_warn(r, \"maximum session duration exceeded for user: %s\",\n\t\t\t\tsession->remote_user);\n\t\toidc_session_kill(r, session);\n\t\treturn oidc_authenticate_user(r, cfg, NULL, oidc_get_current_url(r),\n\t\t\t\tNULL,\n\t\t\t\tNULL, NULL, NULL);\n\t}\n\n\t/* log message about max session duration */\n\toidc_log_session_expires(r, session_expires);\n\n\treturn OK;\n}\n\n/*\n * validate received session cookie against the domain it was issued for:\n *\n * this handles the case where the cache configured is a the same single memcache, Redis, or file\n * backend for different (virtual) hosts, or a client-side cookie protected with the same secret\n *\n * it also handles the case that a cookie is unexpectedly shared across multiple hosts in\n * name-based virtual hosting even though the OP(s) would be the same\n */\nstatic apr_byte_t oidc_check_cookie_domain(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session) {\n\tconst char *c_cookie_domain =\n\t\t\tcfg->cookie_domain ?\n\t\t\t\t\tcfg->cookie_domain : oidc_get_current_url_host(r);\n\tconst char *s_cookie_domain = NULL;\n\toidc_session_get(r, session, OIDC_COOKIE_DOMAIN_SESSION_KEY,\n\t\t\t&s_cookie_domain);\n\tif ((s_cookie_domain == NULL)\n\t\t\t|| (apr_strnatcmp(c_cookie_domain, s_cookie_domain) != 0)) {\n\t\toidc_warn(r,\n\t\t\t\t\"aborting: detected attempt to play cookie against a different domain/host than issued for! (issued=%s, current=%s)\",\n\t\t\t\ts_cookie_domain, c_cookie_domain);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * get a handle to the provider configuration via the \"issuer\" stored in the session\n */\napr_byte_t oidc_get_provider_from_session(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, oidc_provider_t **provider) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* get the issuer value from the session state */\n\tconst char *issuer = NULL;\n\toidc_session_get(r, session, OIDC_ISSUER_SESSION_KEY, &issuer);\n\tif (issuer == NULL) {\n\t\toidc_error(r, \"session corrupted: no issuer found in session\");\n\t\treturn FALSE;\n\t}\n\n\t/* get the provider info associated with the issuer value */\n\toidc_provider_t *p = oidc_get_provider_for_issuer(r, c, issuer, FALSE);\n\tif (p == NULL) {\n\t\toidc_error(r, \"session corrupted: no provider found for issuer: %s\",\n\t\t\t\tissuer);\n\t\treturn FALSE;\n\t}\n\n\t*provider = p;\n\n\treturn TRUE;\n}\n\n/*\n * store the access token expiry timestamp in the session, based on the expires_in\n */\nstatic void oidc_store_access_token_expiry(request_rec *r,\n\t\toidc_session_t *session, int expires_in) {\n\tif (expires_in != -1) {\n\t\toidc_session_set(r, session, OIDC_ACCESSTOKEN_EXPIRES_SESSION_KEY,\n\t\t\t\tapr_psprintf(r->pool, \"%\" APR_TIME_T_FMT,\n\t\t\t\t\t\tapr_time_sec(apr_time_now()) + expires_in));\n\t}\n}\n\n/*\n * store claims resolved from the userinfo endpoint in the session\n */\nstatic void oidc_store_userinfo_claims(request_rec *r, oidc_session_t *session,\n\t\toidc_provider_t *provider, const char *claims) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* see if we've resolved any claims */\n\tif (claims != NULL) {\n\t\t/*\n\t\t * Successfully decoded a set claims from the response so we can store them\n\t\t * (well actually the stringified representation in the response)\n\t\t * in the session context safely now\n\t\t */\n\t\toidc_session_set(r, session, OIDC_CLAIMS_SESSION_KEY, claims);\n\n\t} else {\n\t\t/*\n\t\t * clear the existing claims because we could not refresh them\n\t\t */\n\t\toidc_session_set(r, session, OIDC_CLAIMS_SESSION_KEY, NULL);\n\n\t}\n\n\t/* store the last refresh time if we've configured a userinfo refresh interval */\n\tif (provider->userinfo_refresh_interval > 0)\n\t\toidc_session_set(r, session, OIDC_USERINFO_LAST_REFRESH_SESSION_KEY,\n\t\t\t\tapr_psprintf(r->pool, \"%\" APR_TIME_T_FMT, apr_time_now()));\n}\n\n/*\n * execute refresh token grant to refresh the existing access token\n */\nstatic apr_byte_t oidc_refresh_access_token(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, oidc_provider_t *provider,\n\t\tchar **new_access_token) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* get the refresh token that was stored in the session */\n\tconst char *refresh_token = NULL;\n\toidc_session_get(r, session, OIDC_REFRESHTOKEN_SESSION_KEY, &refresh_token);\n\tif (refresh_token == NULL) {\n\t\toidc_warn(r,\n\t\t\t\t\"refresh token routine called but no refresh_token found in the session\");\n\t\treturn FALSE;\n\t}\n\n\t/* elements returned in the refresh response */\n\tchar *s_id_token = NULL;\n\tint expires_in = -1;\n\tchar *s_token_type = NULL;\n\tchar *s_access_token = NULL;\n\tchar *s_refresh_token = NULL;\n\n\t/* refresh the tokens by calling the token endpoint */\n\tif (oidc_proto_refresh_request(r, c, provider, refresh_token, &s_id_token,\n\t\t\t&s_access_token, &s_token_type, &expires_in,\n\t\t\t&s_refresh_token) == FALSE) {\n\t\toidc_error(r, \"access_token could not be refreshed\");\n\t\treturn FALSE;\n\t}\n\n\t/* store the new access_token in the session and discard the old one */\n\toidc_session_set(r, session, OIDC_ACCESSTOKEN_SESSION_KEY, s_access_token);\n\toidc_store_access_token_expiry(r, session, expires_in);\n\n\t/* see if we need to return it as a parameter */\n\tif (new_access_token != NULL)\n\t\t*new_access_token = s_access_token;\n\n\t/* if we have a new refresh token (rolling refresh), store it in the session and overwrite the old one */\n\tif (s_refresh_token != NULL)\n\t\toidc_session_set(r, session, OIDC_REFRESHTOKEN_SESSION_KEY,\n\t\t\t\ts_refresh_token);\n\n\treturn TRUE;\n}\n\n/*\n * retrieve claims from the userinfo endpoint and return the stringified response\n */\nstatic const char *oidc_retrieve_claims_from_userinfo_endpoint(request_rec *r,\n\t\toidc_cfg *c, oidc_provider_t *provider, const char *access_token,\n\t\toidc_session_t *session, char *id_token_sub) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* see if a userinfo endpoint is set, otherwise there's nothing to do for us */\n\tif (provider->userinfo_endpoint_url == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"not retrieving userinfo claims because userinfo_endpoint is not set\");\n\t\treturn NULL;\n\t}\n\n\t/* see if there's an access token, otherwise we can't call the userinfo endpoint at all */\n\tif (access_token == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"not retrieving userinfo claims because access_token is not provided\");\n\t\treturn NULL;\n\t}\n\n\tif ((id_token_sub == NULL) && (session != NULL)) {\n\n\t\t// when refreshing claims from the userinfo endpoint\n\n\t\tconst char *s_id_token_claims = NULL;\n\t\toidc_session_get(r, session, OIDC_IDTOKEN_CLAIMS_SESSION_KEY,\n\t\t\t\t&s_id_token_claims);\n\n\t\tif (s_id_token_claims == NULL) {\n\t\t\toidc_error(r, \"no id_token claims provided\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tjson_error_t json_error;\n\t\tjson_t *id_token_claims = json_loads(s_id_token_claims, 0, &json_error);\n\n\t\tif (id_token_claims == NULL) {\n\t\t\toidc_error(r, \"JSON parsing (json_loads) failed: %s (%s)\",\n\t\t\t\t\tjson_error.text, s_id_token_claims);\n\t\t\treturn NULL;\n\t\t}\n\n\t\toidc_jose_get_string(r->pool, id_token_claims, \"sub\", FALSE, &id_token_sub, NULL);\n\t}\n\n\t// TODO: return code should indicate whether the token expired or some other error occurred\n\t// TODO: long-term: session storage should be JSON (with explicit types and less conversion, using standard routines)\n\n\t/* try to get claims from the userinfo endpoint using the provided access token */\n\tconst char *result = NULL;\n\tif (oidc_proto_resolve_userinfo(r, c, provider, id_token_sub, access_token,\n\t\t\t&result) == FALSE) {\n\n\t\t/* see if we have an existing session and we are refreshing the user info claims */\n\t\tif (session != NULL) {\n\n\t\t\t/* first call to user info endpoint failed, but the access token may have just expired, so refresh it */\n\t\t\tchar *access_token = NULL;\n\t\t\tif (oidc_refresh_access_token(r, c, session, provider,\n\t\t\t\t\t&access_token) == TRUE) {\n\n\t\t\t\t/* try again with the new access token */\n\t\t\t\tif (oidc_proto_resolve_userinfo(r, c, provider, id_token_sub, access_token,\n\t\t\t\t\t\t&result) == FALSE) {\n\n\t\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\t\"resolving user info claims with the refreshed access token failed, nothing will be stored in the session\");\n\t\t\t\t\tresult = NULL;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\toidc_warn(r,\n\t\t\t\t\t\t\"refreshing access token failed, claims will not be retrieved/refreshed from the userinfo endpoint\");\n\t\t\t\tresult = NULL;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\toidc_error(r,\n\t\t\t\t\t\"resolving user info claims with the existing/provided access token failed, nothing will be stored in the session\");\n\t\t\tresult = NULL;\n\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/*\n * get (new) claims from the userinfo endpoint\n */\nstatic apr_byte_t oidc_refresh_claims_from_userinfo_endpoint(request_rec *r,\n\t\toidc_cfg *cfg, oidc_session_t *session) {\n\n\toidc_provider_t *provider = NULL;\n\tconst char *claims = NULL;\n\tchar *access_token = NULL;\n\n\t/* get the current provider info */\n\tif (oidc_get_provider_from_session(r, cfg, session, &provider) == FALSE)\n\t\treturn FALSE;\n\n\t/* see if we can do anything here, i.e. we have a userinfo endpoint and a refresh interval is configured */\n\tapr_time_t interval = apr_time_from_sec(\n\t\t\tprovider->userinfo_refresh_interval);\n\n\toidc_debug(r, \"userinfo_endpoint=%s, interval=%d\",\n\t\t\tprovider->userinfo_endpoint_url,\n\t\t\tprovider->userinfo_refresh_interval);\n\n\tif ((provider->userinfo_endpoint_url != NULL) && (interval > 0)) {\n\n\t\t/* get the last refresh timestamp from the session info */\n\t\tapr_time_t last_refresh = 0;\n\t\tconst char *s_last_refresh = NULL;\n\t\toidc_session_get(r, session, OIDC_USERINFO_LAST_REFRESH_SESSION_KEY,\n\t\t\t\t&s_last_refresh);\n\t\tif (s_last_refresh != NULL) {\n\t\t\tsscanf(s_last_refresh, \"%\" APR_TIME_T_FMT, &last_refresh);\n\t\t}\n\n\t\toidc_debug(r, \"refresh needed in: %\" APR_TIME_T_FMT \" seconds\",\n\t\t\t\tapr_time_sec(last_refresh + interval - apr_time_now()));\n\n\t\t/* see if we need to refresh again */\n\t\tif (last_refresh + interval < apr_time_now()) {\n\n\t\t\t/* get the current access token */\n\t\t\toidc_session_get(r, session, OIDC_ACCESSTOKEN_SESSION_KEY,\n\t\t\t\t\t(const char **) &access_token);\n\n\t\t\t/* retrieve the current claims */\n\t\t\tclaims = oidc_retrieve_claims_from_userinfo_endpoint(r, cfg,\n\t\t\t\t\tprovider, access_token, session, NULL);\n\n\t\t\t/* store claims resolved from userinfo endpoint */\n\t\t\toidc_store_userinfo_claims(r, session, provider, claims);\n\n\t\t\t/* indicated something changed */\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n/*\n * copy the claims and id_token from the session to the request state and optionally return them\n */\nstatic void oidc_copy_tokens_to_request_state(request_rec *r,\n\t\toidc_session_t *session, const char **s_id_token, const char **s_claims) {\n\n\tconst char *id_token = NULL, *claims = NULL;\n\n\toidc_session_get(r, session, OIDC_IDTOKEN_CLAIMS_SESSION_KEY, &id_token);\n\toidc_session_get(r, session, OIDC_CLAIMS_SESSION_KEY, &claims);\n\n\toidc_debug(r, \"id_token=%s claims=%s\", id_token, claims);\n\n\tif (id_token != NULL) {\n\t\toidc_request_state_set(r, OIDC_IDTOKEN_CLAIMS_SESSION_KEY, id_token);\n\t\tif (s_id_token != NULL)\n\t\t\t*s_id_token = id_token;\n\t}\n\n\tif (claims != NULL) {\n\t\toidc_request_state_set(r, OIDC_CLAIMS_SESSION_KEY, claims);\n\t\tif (s_claims != NULL)\n\t\t\t*s_claims = claims;\n\t}\n}\n\n/*\n * handle the case where we have identified an existing authentication session for a user\n */\nstatic int oidc_handle_existing_session(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* get the header name in which the remote user name needs to be passed */\n\tchar *authn_header = oidc_cfg_dir_authn_header(r);\n\tint pass_headers = oidc_cfg_dir_pass_info_in_headers(r);\n\tint pass_envvars = oidc_cfg_dir_pass_info_in_envvars(r);\n\n\t/* verify current cookie domain against issued cookie domain */\n\tif (oidc_check_cookie_domain(r, cfg, session) == FALSE)\n\t\treturn HTTP_UNAUTHORIZED;\n\n\t/* check if the maximum session duration was exceeded */\n\tint rc = oidc_check_max_session_duration(r, cfg, session);\n\tif (rc != OK)\n\t\treturn rc;\n\n\t/* if needed, refresh claims from the user info endpoint */\n\tapr_byte_t needs_save = oidc_refresh_claims_from_userinfo_endpoint(r, cfg,\n\t\t\tsession);\n\n\t/*\n\t * we're going to pass the information that we have to the application,\n\t * but first we need to scrub the headers that we're going to use for security reasons\n\t */\n\tif (cfg->scrub_request_headers != 0) {\n\n\t\t/* scrub all headers starting with OIDC_ first */\n\t\toidc_scrub_request_headers(r, OIDC_DEFAULT_HEADER_PREFIX,\n\t\t\t\toidc_cfg_dir_authn_header(r));\n\n\t\t/*\n\t\t * then see if the claim headers need to be removed on top of that\n\t\t * (i.e. the prefix does not start with the default OIDC_)\n\t\t */\n\t\tif ((strstr(cfg->claim_prefix, OIDC_DEFAULT_HEADER_PREFIX)\n\t\t\t\t!= cfg->claim_prefix)) {\n\t\t\toidc_scrub_request_headers(r, cfg->claim_prefix, NULL);\n\t\t}\n\t}\n\n\t/* set the user authentication HTTP header if set and required */\n\tif ((r->user != NULL) && (authn_header != NULL))\n\t\toidc_util_set_header(r, authn_header, r->user);\n\n\tconst char *s_claims = NULL;\n\tconst char *s_id_token = NULL;\n\n\t/* copy id_token and claims from session to request state and obtain their values */\n\toidc_copy_tokens_to_request_state(r, session, &s_id_token, &s_claims);\n\n\t/* set the claims in the app headers  */\n\tif (oidc_set_app_claims(r, cfg, session, s_claims) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_CLAIMS)) {\n\t\t/* set the id_token in the app headers */\n\t\tif (oidc_set_app_claims(r, cfg, session, s_id_token) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_PAYLOAD)) {\n\t\t/* pass the id_token JSON object to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, \"id_token_payload\", s_id_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\tif (cfg->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_SERIALIZED)) {\n\t\t\tconst char *s_id_token = NULL;\n\t\t\t/* get the compact serialized JWT from the session */\n\t\t\toidc_session_get(r, session, OIDC_IDTOKEN_SESSION_KEY, &s_id_token);\n\t\t\t/* pass the compact serialized JWT to the app in a header or environment variable */\n\t\t\toidc_util_set_app_info(r, \"id_token\", s_id_token,\n\t\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t\t}\n\t} else {\n\t\toidc_error(r,\n\t\t\t\t\"session type \\\"client-cookie\\\" does not allow storing/passing the id_token; use \\\"OIDCSessionType server-cache\\\" for that\");\n\t}\n\n\t/* set the refresh_token in the app headers/variables, if enabled for this location/directory */\n\tconst char *refresh_token = NULL;\n\toidc_session_get(r, session, OIDC_REFRESHTOKEN_SESSION_KEY, &refresh_token);\n\tif ((oidc_cfg_dir_pass_refresh_token(r) != 0) && (refresh_token != NULL)) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, \"refresh_token\", refresh_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\t/* set the access_token in the app headers/variables */\n\tconst char *access_token = NULL;\n\toidc_session_get(r, session, OIDC_ACCESSTOKEN_SESSION_KEY, &access_token);\n\tif (access_token != NULL) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, \"access_token\", access_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\t/* set the expiry timestamp in the app headers/variables */\n\tconst char *access_token_expires = NULL;\n\toidc_session_get(r, session, OIDC_ACCESSTOKEN_EXPIRES_SESSION_KEY,\n\t\t\t&access_token_expires);\n\tif (access_token_expires != NULL) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, \"access_token_expires\", access_token_expires,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\t/*\n\t * reset the session inactivity timer\n\t * but only do this once per 10% of the inactivity timeout interval (with a max to 60 seconds)\n\t * for performance reasons\n\t *\n\t * now there's a small chance that the session ends 10% (or a minute) earlier than configured/expected\n\t * cq. when there's a request after a recent save (so no update) and then no activity happens until\n\t * a request comes in just before the session should expire\n\t * (\"recent\" and \"just before\" refer to 10%-with-a-max-of-60-seconds of the inactivity interval after\n\t * the start/last-update and before the expiry of the session respectively)\n\t *\n\t * this is be deemed acceptable here because of performance gain\n\t */\n\tapr_time_t interval = apr_time_from_sec(cfg->session_inactivity_timeout);\n\tapr_time_t now = apr_time_now();\n\tapr_time_t slack = interval / 10;\n\tif (slack > apr_time_from_sec(60))\n\t\tslack = apr_time_from_sec(60);\n\tif (session->expiry - now < interval - slack) {\n\t\tsession->expiry = now + interval;\n\t\tneeds_save = TRUE;\n\t}\n\n\t/* check if something was updated in the session and we need to save it again */\n\tif (needs_save)\n\t\tif (oidc_session_save(r, session) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t/* return \"user authenticated\" status */\n\treturn OK;\n}\n\n/*\n * helper function for basic/implicit client flows upon receiving an authorization response:\n * check that it matches the state stored in the browser and return the variables associated\n * with the state, such as original_url and OP oidc_provider_t pointer.\n */\nstatic apr_byte_t oidc_authorization_response_match_state(request_rec *r,\n\t\toidc_cfg *c, const char *state, struct oidc_provider_t **provider,\n\t\tjson_t **proto_state) {\n\n\toidc_debug(r, \"enter (state=%s)\", state);\n\n\tif ((state == NULL) || (apr_strnatcmp(state, \"\") == 0)) {\n\t\toidc_error(r, \"state parameter is not set\");\n\t\treturn FALSE;\n\t}\n\n\t/* check the state parameter against what we stored in a cookie */\n\tif (oidc_restore_proto_state(r, c, state, proto_state) == FALSE) {\n\t\toidc_error(r, \"unable to restore state\");\n\t\treturn FALSE;\n\t}\n\n\t*provider = oidc_get_provider_for_issuer(r, c,\n\t\t\tjson_string_value(json_object_get(*proto_state, \"issuer\")), FALSE);\n\n\treturn (*provider != NULL);\n}\n\n/*\n * redirect the browser to the session logout endpoint\n */\nstatic int oidc_session_redirect_parent_window_to_logout(request_rec *r,\n\t\toidc_cfg *c) {\n\n\toidc_debug(r, \"enter\");\n\n\tchar *java_script = apr_psprintf(r->pool,\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      window.top.location.href = '%s?session=logout';\\n\"\n\t\t\t\"    </script>\\n\", c->redirect_uri);\n\n\treturn oidc_util_html_send(r, \"Redirecting...\", java_script, NULL, NULL,\n\t\t\tDONE);\n}\n\n/*\n * handle an error returned by the OP\n */\nstatic int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,\n\t\tjson_t *proto_state, const char *error, const char *error_description) {\n\tconst char *prompt =\n\t\t\tjson_object_get(proto_state, \"prompt\") ?\n\t\t\t\t\tapr_pstrdup(r->pool,\n\t\t\t\t\t\t\tjson_string_value(\n\t\t\t\t\t\t\t\t\tjson_object_get(proto_state, \"prompt\"))) :\n\t\t\t\t\t\t\t\t\tNULL;\n\tjson_decref(proto_state);\n\tif ((prompt != NULL) && (apr_strnatcmp(prompt, \"none\") == 0)) {\n\t\treturn oidc_session_redirect_parent_window_to_logout(r, c);\n\t}\n\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\tapr_psprintf(r->pool, \"OpenID Connect Provider error: %s\", error),\n\t\t\terror_description, DONE);\n}\n\n/*\n * set the unique user identifier that will be propagated in the Apache r->user and REMOTE_USER variables\n */\nstatic apr_byte_t oidc_get_remote_user(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t *provider, oidc_jwt_t *jwt, char **user,\n\t\tconst char *s_claims) {\n\n\tchar *issuer = provider->issuer;\n\tchar *claim_name = apr_pstrdup(r->pool, c->remote_user_claim.claim_name);\n\tint n = strlen(claim_name);\n\tint post_fix_with_issuer = (claim_name[n - 1] == '@');\n\tif (post_fix_with_issuer) {\n\t\tclaim_name[n - 1] = '\\0';\n\t\tissuer =\n\t\t\t\t(strstr(issuer, \"https://\") == NULL) ?\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer) :\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer + strlen(\"https://\"));\n\t}\n\n\t/* extract the username claim (default: \"sub\") from the id_token payload or user claims */\n\tchar *username = NULL;\n\tjson_error_t json_error;\n\tjson_t *claims = json_loads(s_claims, 0, &json_error);\n\tif (claims == NULL) {\n\t\tusername = apr_pstrdup(r->pool,\n\t\t\t\tjson_string_value(\n\t\t\t\t\t\tjson_object_get(jwt->payload.value.json, claim_name)));\n\t} else {\n\t\toidc_util_json_merge(jwt->payload.value.json, claims);\n\t\tusername = apr_pstrdup(r->pool,\n\t\t\t\tjson_string_value(json_object_get(claims, claim_name)));\n\t\tjson_decref(claims);\n\t}\n\n\tif (username == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"OIDCRemoteUserClaim is set to \\\"%s\\\", but the id_token JSON payload and user claims did not contain a \\\"%s\\\" string\",\n\t\t\t\tc->remote_user_claim.claim_name, claim_name);\n\t\t*user = NULL;\n\t\treturn FALSE;\n\t}\n\n\t/* set the unique username in the session (will propagate to r->user/REMOTE_USER) */\n\t*user = post_fix_with_issuer ?\n\t\t\tapr_psprintf(r->pool, \"%s@%s\", username, issuer) : username;\n\n\tif (c->remote_user_claim.reg_exp != NULL) {\n\n\t\tchar *error_str = NULL;\n\t\tif (oidc_util_regexp_first_match(r->pool, *user,\n\t\t\t\tc->remote_user_claim.reg_exp, user, &error_str) == FALSE) {\n\t\t\toidc_error(r, \"oidc_util_regexp_first_match failed: %s\", error_str);\n\t\t\t*user = NULL;\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\toidc_debug(r, \"set user to \\\"%s\\\"\", *user);\n\n\treturn TRUE;\n}\n\n/*\n * store resolved information in the session\n */\nstatic apr_byte_t oidc_save_in_session(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, oidc_provider_t *provider,\n\t\tconst char *remoteUser, const char *id_token, oidc_jwt_t *id_token_jwt,\n\t\tconst char *claims, const char *access_token, const int expires_in,\n\t\tconst char *refresh_token, const char *session_state, const char *state,\n\t\tconst char *original_url) {\n\n\t/* store the user in the session */\n\tsession->remote_user = remoteUser;\n\n\t/* set the session expiry to the inactivity timeout */\n\tsession->expiry =\n\t\t\tapr_time_now() + apr_time_from_sec(c->session_inactivity_timeout);\n\n\t/* store the claims payload in the id_token for later reference */\n\toidc_session_set(r, session, OIDC_IDTOKEN_CLAIMS_SESSION_KEY,\n\t\t\tid_token_jwt->payload.value.str);\n\n\tif (c->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\t/* store the compact serialized representation of the id_token for later reference  */\n\t\toidc_session_set(r, session, OIDC_IDTOKEN_SESSION_KEY, id_token);\n\t}\n\n\t/* store the issuer in the session (at least needed for session mgmt and token refresh */\n\toidc_session_set(r, session, OIDC_ISSUER_SESSION_KEY, provider->issuer);\n\n\t/* store the state and original URL in the session for handling browser-back more elegantly */\n\toidc_session_set(r, session, OIDC_REQUEST_STATE_SESSION_KEY, state);\n\toidc_session_set(r, session, OIDC_REQUEST_ORIGINAL_URL, original_url);\n\n\tif ((session_state != NULL) && (provider->check_session_iframe != NULL)) {\n\t\t/* store the session state and required parameters session management  */\n\t\toidc_session_set(r, session, OIDC_SESSION_STATE_SESSION_KEY,\n\t\t\t\tsession_state);\n\t\toidc_session_set(r, session, OIDC_CHECK_IFRAME_SESSION_KEY,\n\t\t\t\tprovider->check_session_iframe);\n\t\toidc_session_set(r, session, OIDC_CLIENTID_SESSION_KEY,\n\t\t\t\tprovider->client_id);\n\t\toidc_debug(r,\n\t\t\t\t\"session management enabled: stored session_state (%s), check_session_iframe (%s) and client_id (%s) in the session\",\n\t\t\t\tsession_state, provider->check_session_iframe,\n\t\t\t\tprovider->client_id);\n\t} else {\n\t\toidc_debug(r,\n\t\t\t\t\"session management disabled: session_state (%s) and/or check_session_iframe (%s) is not provided\",\n\t\t\t\tsession_state, provider->check_session_iframe);\n\t}\n\n\tif (provider->end_session_endpoint != NULL)\n\t\toidc_session_set(r, session, OIDC_LOGOUT_ENDPOINT_SESSION_KEY,\n\t\t\t\tprovider->end_session_endpoint);\n\n\t/* store claims resolved from userinfo endpoint */\n\toidc_store_userinfo_claims(r, session, provider, claims);\n\n\t/* see if we have an access_token */\n\tif (access_token != NULL) {\n\t\t/* store the access_token in the session context */\n\t\toidc_session_set(r, session, OIDC_ACCESSTOKEN_SESSION_KEY,\n\t\t\t\taccess_token);\n\t\t/* store the associated expires_in value */\n\t\toidc_store_access_token_expiry(r, session, expires_in);\n\t}\n\n\t/* see if we have a refresh_token */\n\tif (refresh_token != NULL) {\n\t\t/* store the refresh_token in the session context */\n\t\toidc_session_set(r, session, OIDC_REFRESHTOKEN_SESSION_KEY,\n\t\t\t\trefresh_token);\n\t}\n\n\t/* store max session duration in the session as a hard cut-off expiry timestamp */\n\tapr_time_t session_expires =\n\t\t\t(provider->session_max_duration == 0) ?\n\t\t\t\t\tapr_time_from_sec(id_token_jwt->payload.exp) :\n\t\t\t\t\t(apr_time_now()\n\t\t\t\t\t\t\t+ apr_time_from_sec(provider->session_max_duration));\n\toidc_session_set(r, session, OIDC_SESSION_EXPIRES_SESSION_KEY,\n\t\t\tapr_psprintf(r->pool, \"%\" APR_TIME_T_FMT, session_expires));\n\n\t/* log message about max session duration */\n\toidc_log_session_expires(r, session_expires);\n\n\t/* store the domain for which this session is valid */\n\toidc_session_set(r, session, OIDC_COOKIE_DOMAIN_SESSION_KEY,\n\t\t\tc->cookie_domain ? c->cookie_domain : oidc_get_current_url_host(r));\n\n\t/* store the session */\n\treturn oidc_session_save(r, session);\n}\n\n/*\n * parse the expiry for the access token\n */\nstatic int oidc_parse_expires_in(request_rec *r, const char *expires_in) {\n\tif (expires_in != NULL) {\n\t\tchar *ptr = NULL;\n\t\tlong number = strtol(expires_in, &ptr, 10);\n\t\tif (number <= 0) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"could not convert \\\"expires_in\\\" value (%s) to a number\",\n\t\t\t\t\texpires_in);\n\t\t\treturn -1;\n\t\t}\n\t\treturn number;\n\t}\n\treturn -1;\n}\n\n/*\n * handle the different flows (hybrid, implicit, Authorization Code)\n */\nstatic apr_byte_t oidc_handle_flows(request_rec *r, oidc_cfg *c,\n\t\tjson_t *proto_state, oidc_provider_t *provider, apr_table_t *params,\n\t\tconst char *response_mode, oidc_jwt_t **jwt) {\n\n\tapr_byte_t rc = FALSE;\n\n\tconst char *requested_response_type = json_string_value(\n\t\t\tjson_object_get(proto_state, \"response_type\"));\n\n\t/* handle the requested response type/mode */\n\tif (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\t\"code id_token token\")) {\n\t\trc = oidc_proto_authorization_response_code_idtoken_token(r, c,\n\t\t\t\tproto_state, provider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\t\"code id_token\")) {\n\t\trc = oidc_proto_authorization_response_code_idtoken(r, c, proto_state,\n\t\t\t\tprovider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\t\"code token\")) {\n\t\trc = oidc_proto_handle_authorization_response_code_token(r, c,\n\t\t\t\tproto_state, provider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\t\"code\")) {\n\t\trc = oidc_proto_handle_authorization_response_code(r, c, proto_state,\n\t\t\t\tprovider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\t\"id_token token\")) {\n\t\trc = oidc_proto_handle_authorization_response_idtoken_token(r, c,\n\t\t\t\tproto_state, provider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\t\"id_token\")) {\n\t\trc = oidc_proto_handle_authorization_response_idtoken(r, c, proto_state,\n\t\t\t\tprovider, params, response_mode, jwt);\n\t} else {\n\t\toidc_error(r, \"unsupported response type: \\\"%s\\\"\",\n\t\t\t\trequested_response_type);\n\t}\n\n\tif ((rc == FALSE) && (*jwt != NULL)) {\n\t\toidc_jwt_destroy(*jwt);\n\t\t*jwt = NULL;\n\t}\n\n\treturn rc;\n}\n\n/* handle the browser back on an authorization response */\nstatic apr_byte_t oidc_handle_browser_back(request_rec *r, const char *r_state,\n\t\toidc_session_t *session) {\n\n\t/*  see if we have an existing session and browser-back was used */\n\tconst char *s_state = NULL, *o_url = NULL;\n\n\tif (session->remote_user != NULL) {\n\n\t\toidc_session_get(r, session, OIDC_REQUEST_STATE_SESSION_KEY, &s_state);\n\t\toidc_session_get(r, session, OIDC_REQUEST_ORIGINAL_URL, &o_url);\n\n\t\tif ((r_state != NULL) && (s_state != NULL)\n\t\t\t\t&& (apr_strnatcmp(r_state, s_state) == 0)) {\n\n\t\t\t/* log the browser back event detection */\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"browser back detected, redirecting to original URL: %s\",\n\t\t\t\t\to_url);\n\n\t\t\t/* go back to the URL that he originally tried to access */\n\t\t\tapr_table_add(r->headers_out, \"Location\", o_url);\n\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\n\treturn FALSE;\n}\n\n/*\n * complete the handling of an authorization response by obtaining, parsing and verifying the\n * id_token and storing the authenticated user state in the session\n */\nstatic int oidc_handle_authorization_response(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, apr_table_t *params, const char *response_mode) {\n\n\toidc_debug(r, \"enter, response_mode=%s\", response_mode);\n\n\toidc_provider_t *provider = NULL;\n\tjson_t *proto_state = NULL;\n\toidc_jwt_t *jwt = NULL;\n\n\t/* see if this response came from a browser-back event */\n\tif (oidc_handle_browser_back(r, apr_table_get(params, \"state\"),\n\t\t\tsession) == TRUE)\n\t\treturn HTTP_MOVED_TEMPORARILY;\n\n\t/* match the returned state parameter against the state stored in the browser */\n\tif (oidc_authorization_response_match_state(r, c,\n\t\t\tapr_table_get(params, \"state\"), &provider, &proto_state) == FALSE) {\n\t\tif (c->default_sso_url != NULL) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"invalid authorization response state; a default SSO URL is set, sending the user there: %s\",\n\t\t\t\t\tc->default_sso_url);\n\t\t\tapr_table_add(r->headers_out, \"Location\", c->default_sso_url);\n\t\t\treturn HTTP_MOVED_TEMPORARILY;\n\t\t}\n\t\toidc_error(r,\n\t\t\t\t\"invalid authorization response state and no default SSO URL is set, sending an error...\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* see if the response is an error response */\n\tif (apr_table_get(params, \"error\") != NULL)\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\tapr_table_get(params, \"error\"),\n\t\t\t\tapr_table_get(params, \"error_description\"));\n\n\t/* handle the code, implicit or hybrid flow */\n\tif (oidc_handle_flows(r, c, proto_state, provider, params, response_mode,\n\t\t\t&jwt) == FALSE)\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\"Error in handling response type.\", NULL);\n\n\tif (jwt == NULL) {\n\t\toidc_error(r, \"no id_token was provided\");\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\"No id_token was provided.\", NULL);\n\t}\n\n\tint expires_in = oidc_parse_expires_in(r,\n\t\t\tapr_table_get(params, \"expires_in\"));\n\n\t/*\n\t * optionally resolve additional claims against the userinfo endpoint\n\t * parsed claims are not actually used here but need to be parsed anyway for error checking purposes\n\t */\n\tconst char *claims = oidc_retrieve_claims_from_userinfo_endpoint(r, c,\n\t\t\tprovider, apr_table_get(params, \"access_token\"), NULL, jwt->payload.sub);\n\n\t/* restore the original protected URL that the user was trying to access */\n\tconst char *original_url = apr_pstrdup(r->pool,\n\t\t\tjson_string_value(json_object_get(proto_state, \"original_url\")));\n\tconst char *original_method = apr_pstrdup(r->pool,\n\t\t\tjson_string_value(json_object_get(proto_state, \"original_method\")));\n\n\t/* set the user */\n\tif (oidc_get_remote_user(r, c, provider, jwt, &r->user, claims) == TRUE) {\n\n\t\t/* session management: if the user in the new response is not equal to the old one, error out */\n\t\tif ((json_object_get(proto_state, \"prompt\") != NULL)\n\t\t\t\t&& (apr_strnatcmp(\n\t\t\t\t\t\tjson_string_value(\n\t\t\t\t\t\t\t\tjson_object_get(proto_state, \"prompt\")), \"none\")\n\t\t\t\t\t\t== 0)) {\n\t\t\t// TOOD: actually need to compare sub? (need to store it in the session separately then\n\t\t\t//const char *sub = NULL;\n\t\t\t//oidc_session_get(r, session, \"sub\", &sub);\n\t\t\t//if (apr_strnatcmp(sub, jwt->payload.sub) != 0) {\n\t\t\tif (apr_strnatcmp(session->remote_user, r->user) != 0) {\n\t\t\t\toidc_warn(r,\n\t\t\t\t\t\t\"user set from new id_token is different from current one\");\n\t\t\t\toidc_jwt_destroy(jwt);\n\t\t\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\t\t\"User changed!\", NULL);\n\t\t\t}\n\t\t}\n\n\t\t/* store resolved information in the session */\n\t\tif (oidc_save_in_session(r, c, session, provider, r->user,\n\t\t\t\tapr_table_get(params, \"id_token\"), jwt, claims,\n\t\t\t\tapr_table_get(params, \"access_token\"), expires_in,\n\t\t\t\tapr_table_get(params, \"refresh_token\"),\n\t\t\t\tapr_table_get(params, \"session_state\"),\n\t\t\t\tapr_table_get(params, \"state\"), original_url) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t} else {\n\t\toidc_error(r, \"remote user could not be set\");\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\"Remote user could not be set: contact the website administrator\",\n\t\t\t\tNULL);\n\t}\n\n\t/* cleanup */\n\tjson_decref(proto_state);\n\toidc_jwt_destroy(jwt);\n\n\t/* check that we've actually authenticated a user; functions as error handling for oidc_get_remote_user */\n\tif (r->user == NULL)\n\t\treturn HTTP_UNAUTHORIZED;\n\n\t/* log the successful response */\n\toidc_debug(r,\n\t\t\t\"session created and stored, returning to original URL: %s, original method: %s\",\n\t\t\toriginal_url, original_method);\n\n\t/* check whether form post data was preserved; if so restore it */\n\tif (apr_strnatcmp(original_method, OIDC_METHOD_FORM_POST) == 0) {\n\t\treturn oidc_request_post_preserved_restore(r, original_url);\n\t}\n\n\t/* now we've authenticated the user so go back to the URL that he originally tried to access */\n\tapr_table_add(r->headers_out, \"Location\", original_url);\n\n\t/* do the actual redirect to the original URL */\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\n/*\n * handle an OpenID Connect Authorization Response using the POST (+fragment->POST) response_mode\n */\nstatic int oidc_handle_post_authorization_response(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* initialize local variables */\n\tchar *response_mode = NULL;\n\n\t/* read the parameters that are POST-ed to us */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params) == FALSE) {\n\t\toidc_error(r, \"something went wrong when reading the POST parameters\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* see if we've got any POST-ed data at all */\n\tif ((apr_table_elts(params)->nelts < 1)\n\t\t\t|| ((apr_table_elts(params)->nelts == 1)\n\t\t\t\t\t&& apr_table_get(params, \"response_mode\")\n\t\t\t\t\t&& (apr_strnatcmp(apr_table_get(params, \"response_mode\"),\n\t\t\t\t\t\t\t\"fragment\") == 0))) {\n\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\"Invalid Request\",\n\t\t\t\t\"You've hit an OpenID Connect Redirect URI with no parameters, this is an invalid request; you should not open this URL in your browser directly, or have the server administrator use a different OIDCRedirectURI setting.\",\n\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t}\n\n\t/* get the parameters */\n\tresponse_mode = (char *) apr_table_get(params, \"response_mode\");\n\n\t/* do the actual implicit work */\n\treturn oidc_handle_authorization_response(r, c, session, params,\n\t\t\tresponse_mode ? response_mode : \"form_post\");\n}\n\n/*\n * handle an OpenID Connect Authorization Response using the redirect response_mode\n */\nstatic int oidc_handle_redirect_authorization_response(request_rec *r,\n\t\toidc_cfg *c, oidc_session_t *session) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* read the parameters from the query string */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\toidc_util_read_form_encoded_params(r, params, r->args);\n\n\t/* do the actual work */\n\treturn oidc_handle_authorization_response(r, c, session, params, \"query\");\n}\n\n/*\n * present the user with an OP selection screen\n */\nstatic int oidc_discovery(request_rec *r, oidc_cfg *cfg) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* obtain the URL we're currently accessing, to be stored in the state/session */\n\tchar *current_url = oidc_get_current_url(r);\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\n\t/* generate CSRF token */\n\tchar *csrf = NULL;\n\tif (oidc_proto_generate_nonce(r, &csrf, 8) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\tchar *discover_url = oidc_cfg_dir_discover_url(r);\n\t/* see if there's an external discovery page configured */\n\tif (discover_url != NULL) {\n\n\t\t/* yes, assemble the parameters for external discovery */\n\t\tchar *url = apr_psprintf(r->pool, \"%s%s%s=%s&%s=%s&%s=%s&%s=%s\",\n\t\t\t\tdiscover_url, strchr(discover_url, '?') != NULL ? \"&\" : \"?\",\n\t\t\t\t\t\tOIDC_DISC_RT_PARAM, oidc_util_escape_string(r, current_url),\n\t\t\t\t\t\tOIDC_DISC_RM_PARAM, method,\n\t\t\t\t\t\tOIDC_DISC_CB_PARAM,\n\t\t\t\t\t\toidc_util_escape_string(r, cfg->redirect_uri),\n\t\t\t\t\t\tOIDC_CSRF_NAME, oidc_util_escape_string(r, csrf));\n\n\t\t/* log what we're about to do */\n\t\toidc_debug(r, \"redirecting to external discovery page: %s\", url);\n\n\t\t/* set CSRF cookie */\n\t\toidc_util_set_cookie(r, OIDC_CSRF_NAME, csrf, -1);\n\n\t\t/* see if we need to preserve POST parameters through Javascript/HTML5 storage */\n\t\tif (oidc_post_preserve_javascript(r, url, NULL, NULL) == TRUE)\n\t\t\treturn DONE;\n\n\t\t/* do the actual redirect to an external discovery page */\n\t\tapr_table_add(r->headers_out, \"Location\", url);\n\t\treturn HTTP_MOVED_TEMPORARILY;\n\t}\n\n\t/* get a list of all providers configured in the metadata directory */\n\tapr_array_header_t *arr = NULL;\n\tif (oidc_metadata_list(r, cfg, &arr) == FALSE)\n\t\treturn oidc_util_html_send_error(r, cfg->error_template,\n\t\t\t\t\"Configuration Error\",\n\t\t\t\t\"No configured providers found, contact your administrator\",\n\t\t\t\tHTTP_UNAUTHORIZED);\n\n\t/* assemble a where-are-you-from IDP discovery HTML page */\n\tconst char *s = \"\t\t\t<h3>Select your OpenID Connect Identity Provider</h3>\\n\";\n\n\t/* list all configured providers in there */\n\tint i;\n\tfor (i = 0; i < arr->nelts; i++) {\n\t\tconst char *issuer = ((const char**) arr->elts)[i];\n\t\t// TODO: html escape (especially & character)\n\n\t\tchar *display =\n\t\t\t\t(strstr(issuer, \"https://\") == NULL) ?\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer) :\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer + strlen(\"https://\"));\n\n\t\t/* strip port number */\n\t\t//char *p = strstr(display, \":\");\n\t\t//if (p != NULL) *p = '\\0';\n\t\t/* point back to the redirect_uri, where the selection is handled, with an IDP selection and return_to URL */\n\t\ts =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"%s<p><a href=\\\"%s?%s=%s&amp;%s=%s&amp;%s=%s&amp;%s=%s\\\">%s</a></p>\\n\",\n\t\t\t\t\t\ts, cfg->redirect_uri, OIDC_DISC_OP_PARAM,\n\t\t\t\t\t\toidc_util_escape_string(r, issuer),\n\t\t\t\t\t\tOIDC_DISC_RT_PARAM,\n\t\t\t\t\t\toidc_util_escape_string(r, current_url),\n\t\t\t\t\t\tOIDC_DISC_RM_PARAM, method,\n\t\t\t\t\t\tOIDC_CSRF_NAME, csrf, display);\n\t}\n\n\t/* add an option to enter an account or issuer name for dynamic OP discovery */\n\ts = apr_psprintf(r->pool, \"%s<form method=\\\"get\\\" action=\\\"%s\\\">\\n\", s,\n\t\t\tcfg->redirect_uri);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\tOIDC_DISC_RT_PARAM, current_url);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\tOIDC_DISC_RM_PARAM, method);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\tOIDC_CSRF_NAME, csrf);\n\ts =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"%s<p>Or enter your account name (eg. &quot;mike@seed.gluu.org&quot;, or an IDP identifier (eg. &quot;mitreid.org&quot;):</p>\\n\",\n\t\t\t\t\ts);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"text\\\" name=\\\"%s\\\" value=\\\"%s\\\"></p>\\n\", s,\n\t\t\tOIDC_DISC_OP_PARAM, \"\");\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"submit\\\" value=\\\"Submit\\\"></p>\\n\", s);\n\ts = apr_psprintf(r->pool, \"%s</form>\\n\", s);\n\n\toidc_util_set_cookie(r, OIDC_CSRF_NAME, csrf, -1);\n\n\tchar *javascript = NULL, *javascript_method = NULL;\n\tchar *html_head =\n\t\t\t\"<style type=\\\"text/css\\\">body {text-align: center}</style>\";\n\tif (oidc_post_preserve_javascript(r, NULL, &javascript,\n\t\t\t&javascript_method) == TRUE)\n\t\thtml_head = apr_psprintf(r->pool, \"%s%s\", html_head, javascript);\n\n\t/* now send the HTML contents to the user agent */\n\treturn oidc_util_html_send(r, \"OpenID Connect Provider Discovery\",\n\t\t\thtml_head, javascript_method, s, DONE);\n}\n\n/*\n * authenticate the user to the selected OP, if the OP is not selected yet perform discovery first\n */\nstatic int oidc_authenticate_user(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t *provider, const char *original_url,\n\t\tconst char *login_hint, const char *id_token_hint, const char *prompt,\n\t\tconst char *auth_request_params) {\n\n\toidc_debug(r, \"enter\");\n\n\tif (provider == NULL) {\n\n\t\t// TODO: should we use an explicit redirect to the discovery endpoint (maybe a \"discovery\" param to the redirect_uri)?\n\t\tif (c->metadata_dir != NULL)\n\t\t\treturn oidc_discovery(r, c);\n\n\t\t/* we're not using multiple OP's configured in a metadata directory, pick the statically configured OP */\n\t\tif (oidc_provider_static_config(r, c, &provider) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* generate the random nonce value that correlates requests and responses */\n\tchar *nonce = NULL;\n\tif (oidc_proto_generate_nonce(r, &nonce, OIDC_PROTO_NONCE_LENGTH) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\tchar *code_verifier = NULL;\n\tchar *code_challenge = NULL;\n\n\tif ((oidc_util_spaced_string_contains(r->pool, provider->response_type,\n\t\t\t\"code\") == TRUE) && (provider->pkce_method != NULL)) {\n\n\t\t/* generate the code verifier value that correlates authorization requests and code exchange requests */\n\t\tif (oidc_proto_generate_code_verifier(r, &code_verifier,\n\t\t\t\tOIDC_PROTO_CODE_VERIFIER_LENGTH) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t\t/* generate the PKCE code challenge */\n\t\tif (oidc_proto_generate_code_challenge(r, code_verifier,\n\t\t\t\t&code_challenge, provider->pkce_method) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* create the state between request/response */\n\tjson_t *proto_state = json_object();\n\tjson_object_set_new(proto_state, \"original_url\", json_string(original_url));\n\tjson_object_set_new(proto_state, \"original_method\",\n\t\t\tjson_string(oidc_original_request_method(r, c, TRUE)));\n\tjson_object_set_new(proto_state, \"issuer\", json_string(provider->issuer));\n\tjson_object_set_new(proto_state, \"response_type\",\n\t\t\tjson_string(provider->response_type));\n\tjson_object_set_new(proto_state, \"nonce\", json_string(nonce));\n\tjson_object_set_new(proto_state, \"timestamp\",\n\t\t\tjson_integer(apr_time_sec(apr_time_now())));\n\tif (provider->response_mode)\n\t\tjson_object_set_new(proto_state, \"response_mode\",\n\t\t\t\tjson_string(provider->response_mode));\n\tif (prompt)\n\t\tjson_object_set_new(proto_state, \"prompt\", json_string(prompt));\n\tif (code_verifier)\n\t\tjson_object_set_new(proto_state, \"code_verifier\",\n\t\t\t\tjson_string(code_verifier));\n\n\t/* get a hash value that fingerprints the browser concatenated with the random input */\n\tchar *state = oidc_get_browser_state_hash(r, nonce);\n\n\t/* create state that restores the context when the authorization response comes in; cryptographically bind it to the browser */\n\tif (oidc_authorization_request_set_cookie(r, c, state, proto_state) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t/*\n\t * printout errors if Cookie settings are not going to work\n\t */\n\tapr_uri_t o_uri;\n\tmemset(&o_uri, 0, sizeof(apr_uri_t));\n\tapr_uri_t r_uri;\n\tmemset(&r_uri, 0, sizeof(apr_uri_t));\n\tapr_uri_parse(r->pool, original_url, &o_uri);\n\tapr_uri_parse(r->pool, c->redirect_uri, &r_uri);\n\tif ((apr_strnatcmp(o_uri.scheme, r_uri.scheme) != 0)\n\t\t\t&& (apr_strnatcmp(r_uri.scheme, \"https\") == 0)) {\n\t\toidc_error(r,\n\t\t\t\t\"the URL scheme (%s) of the configured OIDCRedirectURI does not match the URL scheme of the URL being accessed (%s): the \\\"state\\\" and \\\"session\\\" cookies will not be shared between the two!\",\n\t\t\t\tr_uri.scheme, o_uri.scheme);\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif (c->cookie_domain == NULL) {\n\t\tif (apr_strnatcmp(o_uri.hostname, r_uri.hostname) != 0) {\n\t\t\tchar *p = strstr(o_uri.hostname, r_uri.hostname);\n\t\t\tif ((p == NULL) || (apr_strnatcmp(r_uri.hostname, p) != 0)) {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"the URL hostname (%s) of the configured OIDCRedirectURI does not match the URL hostname of the URL being accessed (%s): the \\\"state\\\" and \\\"session\\\" cookies will not be shared between the two!\",\n\t\t\t\t\t\tr_uri.hostname, o_uri.hostname);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!oidc_util_cookie_domain_valid(r_uri.hostname, c->cookie_domain)) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"the domain (%s) configured in OIDCCookieDomain does not match the URL hostname (%s) of the URL being accessed (%s): setting \\\"state\\\" and \\\"session\\\" cookies will not work!!\",\n\t\t\t\t\tc->cookie_domain, o_uri.hostname, original_url);\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t}\n\t}\n\n\t/* send off to the OpenID Connect Provider */\n\t// TODO: maybe show intermediate/progress screen \"redirecting to\"\n\treturn oidc_proto_authorization_request(r, provider, login_hint,\n\t\t\tc->redirect_uri, state, proto_state, id_token_hint, code_challenge,\n\t\t\tauth_request_params);\n}\n\n/*\n * check if the target_link_uri matches to configuration settings to prevent an open redirect\n */\nstatic int oidc_target_link_uri_matches_configuration(request_rec *r,\n\t\toidc_cfg *cfg, const char *target_link_uri) {\n\n\tapr_uri_t o_uri;\n\tapr_uri_parse(r->pool, target_link_uri, &o_uri);\n\tif (o_uri.hostname == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"could not parse the \\\"target_link_uri\\\" (%s) in to a valid URL: aborting.\",\n\t\t\t\ttarget_link_uri);\n\t\treturn FALSE;\n\t}\n\n\tapr_uri_t r_uri;\n\tapr_uri_parse(r->pool, cfg->redirect_uri, &r_uri);\n\n\tif (cfg->cookie_domain == NULL) {\n\t\t/* cookie_domain set: see if the target_link_uri matches the redirect_uri host (because the session cookie will be set host-wide) */\n\t\tif (apr_strnatcmp(o_uri.hostname, r_uri.hostname) != 0) {\n\t\t\tchar *p = strstr(o_uri.hostname, r_uri.hostname);\n\t\t\tif ((p == NULL) || (apr_strnatcmp(r_uri.hostname, p) != 0)) {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"the URL hostname (%s) of the configured OIDCRedirectURI does not match the URL hostname of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\t\tr_uri.hostname, o_uri.hostname);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* cookie_domain set: see if the target_link_uri is within the cookie_domain */\n\t\tchar *p = strstr(o_uri.hostname, cfg->cookie_domain);\n\t\tif ((p == NULL) || (apr_strnatcmp(cfg->cookie_domain, p) != 0)) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"the domain (%s) configured in OIDCCookieDomain does not match the URL hostname (%s) of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\tcfg->cookie_domain, o_uri.hostname, target_link_uri);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/* see if the cookie_path setting matches the target_link_uri path */\n\tchar *cookie_path = oidc_cfg_dir_cookie_path(r);\n\tif (cookie_path != NULL) {\n\t\tchar *p = (o_uri.path != NULL) ? strstr(o_uri.path, cookie_path) : NULL;\n\t\tif ((p == NULL) || (p != o_uri.path)) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"the path (%s) configured in OIDCCookiePath does not match the URL path (%s) of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\tcfg->cookie_domain, o_uri.path, target_link_uri);\n\t\t\treturn FALSE;\n\t\t} else if (strlen(o_uri.path) > strlen(cookie_path)) {\n\t\t\tint n = strlen(cookie_path);\n\t\t\tif (cookie_path[n - 1] == '/')\n\t\t\t\tn--;\n\t\t\tif (o_uri.path[n] != '/') {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"the path (%s) configured in OIDCCookiePath does not match the URL path (%s) of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\t\tcfg->cookie_domain, o_uri.path, target_link_uri);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n\n/*\n * handle a response from an IDP discovery page and/or handle 3rd-party initiated SSO\n */\nstatic int oidc_handle_discovery_response(request_rec *r, oidc_cfg *c) {\n\n\t/* variables to hold the values returned in the response */\n\tchar *issuer = NULL, *target_link_uri = NULL, *login_hint = NULL,\n\t\t\t*auth_request_params = NULL, *csrf_cookie, *csrf_query = NULL,\n\t\t\t*user = NULL;\n\toidc_provider_t *provider = NULL;\n\n\toidc_util_get_request_parameter(r, OIDC_DISC_OP_PARAM, &issuer);\n\toidc_util_get_request_parameter(r, OIDC_DISC_USER_PARAM, &user);\n\toidc_util_get_request_parameter(r, OIDC_DISC_RT_PARAM, &target_link_uri);\n\toidc_util_get_request_parameter(r, OIDC_DISC_LH_PARAM, &login_hint);\n\toidc_util_get_request_parameter(r, OIDC_DISC_AR_PARAM,\n\t\t\t&auth_request_params);\n\toidc_util_get_request_parameter(r, OIDC_CSRF_NAME, &csrf_query);\n\tcsrf_cookie = oidc_util_get_cookie(r, OIDC_CSRF_NAME);\n\n\t/* do CSRF protection if not 3rd party initiated SSO */\n\tif (csrf_cookie) {\n\n\t\t/* clean CSRF cookie */\n\t\toidc_util_set_cookie(r, OIDC_CSRF_NAME, \"\", 0);\n\n\t\t/* compare CSRF cookie value with query parameter value */\n\t\tif ((csrf_query == NULL)\n\t\t\t\t|| apr_strnatcmp(csrf_query, csrf_cookie) != 0) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"CSRF protection failed, no Discovery and dynamic client registration will be allowed\");\n\t\t\tcsrf_cookie = NULL;\n\t\t}\n\t}\n\n\t// TODO: trim issuer/accountname/domain input and do more input validation\n\n\toidc_debug(r,\n\t\t\t\"issuer=\\\"%s\\\", target_link_uri=\\\"%s\\\", login_hint=\\\"%s\\\", user=\\\"%s\\\"\",\n\t\t\tissuer, target_link_uri, login_hint, user);\n\n\tif (target_link_uri == NULL) {\n\t\tif (c->default_sso_url == NULL) {\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"SSO to this module without specifying a \\\"target_link_uri\\\" parameter is not possible because OIDCDefaultURL is not set.\",\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t}\n\t\ttarget_link_uri = c->default_sso_url;\n\t}\n\n\t/* do open redirect prevention */\n\tif (oidc_target_link_uri_matches_configuration(r, c,\n\t\t\ttarget_link_uri) == FALSE) {\n\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\"Invalid Request\",\n\t\t\t\t\"\\\"target_link_uri\\\" parameter does not match configuration settings, aborting to prevent an open redirect.\",\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t}\n\n\t/* find out if the user entered an account name or selected an OP manually */\n\tif (user != NULL) {\n\n\t\tif (login_hint == NULL)\n\t\t\tlogin_hint = apr_pstrdup(r->pool, user);\n\n\t\t/* normalize the user identifier */\n\t\tif (strstr(user, \"https://\") != user)\n\t\t\tuser = apr_psprintf(r->pool, \"https://%s\", user);\n\n\t\t/* got an user identifier as input, perform OP discovery with that */\n\t\tif (oidc_proto_url_based_discovery(r, c, user, &issuer) == FALSE) {\n\n\t\t\t/* something did not work out, show a user facing error */\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"Could not resolve the provided user identifier to an OpenID Connect provider; check your syntax.\",\n\t\t\t\t\tHTTP_NOT_FOUND);\n\t\t}\n\n\t\t/* issuer is set now, so let's continue as planned */\n\n\t} else if (strstr(issuer, \"@\") != NULL) {\n\n\t\tif (login_hint == NULL) {\n\t\t\tlogin_hint = apr_pstrdup(r->pool, issuer);\n\t\t\t//char *p = strstr(issuer, \"@\");\n\t\t\t//*p = '\\0';\n\t\t}\n\n\t\t/* got an account name as input, perform OP discovery with that */\n\t\tif (oidc_proto_account_based_discovery(r, c, issuer, &issuer) == FALSE) {\n\n\t\t\t/* something did not work out, show a user facing error */\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"Could not resolve the provided account name to an OpenID Connect provider; check your syntax.\",\n\t\t\t\t\tHTTP_NOT_FOUND);\n\t\t}\n\n\t\t/* issuer is set now, so let's continue as planned */\n\n\t}\n\n\t/* strip trailing '/' */\n\tint n = strlen(issuer);\n\tif (issuer[n - 1] == '/')\n\t\tissuer[n - 1] = '\\0';\n\n\t/* try and get metadata from the metadata directories for the selected OP */\n\tif ((oidc_metadata_get(r, c, issuer, &provider, csrf_cookie != NULL) == TRUE)\n\t\t\t&& (provider != NULL)) {\n\n\t\t/* now we've got a selected OP, send the user there to authenticate */\n\t\treturn oidc_authenticate_user(r, c, provider, target_link_uri,\n\t\t\t\tlogin_hint, NULL, NULL, auth_request_params);\n\t}\n\n\t/* something went wrong */\n\treturn oidc_util_html_send_error(r, c->error_template, \"Invalid Request\",\n\t\t\t\"Could not find valid provider metadata for the selected OpenID Connect provider; contact the administrator\",\n\t\t\tHTTP_NOT_FOUND);\n}\n\nstatic apr_uint32_t oidc_transparent_pixel[17] = { 0x474e5089, 0x0a1a0a0d,\n\t\t0x0d000000, 0x52444849, 0x01000000, 0x01000000, 0x00000408, 0x0c1cb500,\n\t\t0x00000002, 0x4144490b, 0x639c7854, 0x0000cffa, 0x02010702, 0x71311c9a,\n\t\t0x00000000, 0x444e4549, 0x826042ae };\n\nstatic apr_byte_t oidc_is_front_channel_logout(const char *logout_param_value) {\n\treturn ((logout_param_value != NULL)\n\t\t\t&& ((apr_strnatcmp(logout_param_value,\n\t\t\t\t\tOIDC_GET_STYLE_LOGOUT_PARAM_VALUE) == 0)\n\t\t\t\t\t|| (apr_strnatcmp(logout_param_value,\n\t\t\t\t\t\t\tOIDC_IMG_STYLE_LOGOUT_PARAM_VALUE) == 0)));\n}\n\n/*\n * handle a local logout\n */\nstatic int oidc_handle_logout_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *url) {\n\n\toidc_debug(r, \"enter (url=%s)\", url);\n\n\t/* if there's no remote_user then there's no (stored) session to kill */\n\tif (session->remote_user != NULL) {\n\n\t\t/* remove session state (cq. cache entry and cookie) */\n\t\toidc_session_kill(r, session);\n\t}\n\n\t/* see if this is the OP calling us */\n\tif (oidc_is_front_channel_logout(url)) {\n\n\t\t/* set recommended cache control headers */\n\t\tapr_table_add(r->err_headers_out, \"Cache-Control\",\n\t\t\t\t\"no-cache, no-store\");\n\t\tapr_table_add(r->err_headers_out, \"Pragma\", \"no-cache\");\n\t\tapr_table_add(r->err_headers_out, \"P3P\", \"CAO PSA OUR\");\n\t\tapr_table_add(r->err_headers_out, \"Expires\", \"0\");\n\t\tapr_table_add(r->err_headers_out, \"X-Frame-Options\", \"DENY\");\n\n\t\t/* see if this is PF-PA style logout in which case we return a transparent pixel */\n\t\tconst char *accept = apr_table_get(r->headers_in, \"Accept\");\n\t\tif ((apr_strnatcmp(url, OIDC_IMG_STYLE_LOGOUT_PARAM_VALUE) == 0)\n\t\t\t\t|| ((accept) && strstr(accept, \"image/png\"))) {\n\t\t\treturn oidc_util_http_send(r,\n\t\t\t\t\t(const char *) &oidc_transparent_pixel,\n\t\t\t\t\tsizeof(oidc_transparent_pixel), \"image/png\", DONE);\n\t\t}\n\n\t\t/* standard HTTP based logout: should be called in an iframe from the OP */\n\t\treturn oidc_util_html_send(r, \"Logged Out\", NULL, NULL,\n\t\t\t\t\"<p>Logged Out</p>\", DONE);\n\t}\n\n\t/* see if we don't need to go somewhere special after killing the session locally */\n\tif (url == NULL)\n\t\treturn oidc_util_html_send(r, \"Logged Out\", NULL, NULL,\n\t\t\t\t\"<p>Logged Out</p>\", DONE);\n\n\t/* send the user to the specified where-to-go-after-logout URL */\n\tapr_table_add(r->headers_out, \"Location\", url);\n\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\n/*\n * perform (single) logout\n */\nstatic int oidc_handle_logout(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\t/* pickup the command or URL where the user wants to go after logout */\n\tchar *url = NULL;\n\toidc_util_get_request_parameter(r, \"logout\", &url);\n\n\toidc_debug(r, \"enter (url=%s)\", url);\n\n\tif (oidc_is_front_channel_logout(url)) {\n\t\treturn oidc_handle_logout_request(r, c, session, url);\n\t}\n\n\tif ((url == NULL) || (apr_strnatcmp(url, \"\") == 0)) {\n\n\t\turl = c->default_slo_url;\n\n\t} else {\n\n\t\t/* do input validation on the logout parameter value */\n\n\t\tconst char *error_description = NULL;\n\t\tapr_uri_t uri;\n\n\t\tif (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS) {\n\t\t\tconst char *error_description = apr_psprintf(r->pool,\n\t\t\t\t\t\"Logout URL malformed: %s\", url);\n\t\t\toidc_error(r, \"%s\", error_description);\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Malformed URL\", error_description,\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\n\t\t}\n\n\t\tif ((strstr(r->hostname, uri.hostname) == NULL)\n\t\t\t\t|| (strstr(uri.hostname, r->hostname) == NULL)) {\n\t\t\terror_description =\n\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n\t\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), r->hostname);\n\t\t\toidc_error(r, \"%s\", error_description);\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\", error_description,\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t}\n\n\t\t/* validate the URL to prevent HTTP header splitting */\n\t\tif (((strstr(url, \"\\n\") != NULL) || strstr(url, \"\\r\") != NULL)) {\n\t\t\terror_description =\n\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\"logout value \\\"%s\\\" contains illegal \\\"\\n\\\" or \\\"\\r\\\" character(s)\",\n\t\t\t\t\t\t\turl);\n\t\t\toidc_error(r, \"%s\", error_description);\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\", error_description,\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t}\n\t}\n\n\tconst char *end_session_endpoint = NULL;\n\toidc_session_get(r, session, OIDC_LOGOUT_ENDPOINT_SESSION_KEY,\n\t\t\t&end_session_endpoint);\n\tif (end_session_endpoint != NULL) {\n\n\t\tconst char *id_token_hint = NULL;\n\t\toidc_session_get(r, session, OIDC_IDTOKEN_SESSION_KEY, &id_token_hint);\n\n\t\tchar *logout_request = apr_pstrdup(r->pool, end_session_endpoint);\n\t\tif (id_token_hint != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool, \"%s%sid_token_hint=%s\",\n\t\t\t\t\tlogout_request,\n\t\t\t\t\tstrchr(logout_request, '?') != NULL ? \"&\" : \"?\",\n\t\t\t\t\t\t\toidc_util_escape_string(r, id_token_hint));\n\t\t}\n\n\t\tif (url != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool,\n\t\t\t\t\t\"%s%spost_logout_redirect_uri=%s\", logout_request,\n\t\t\t\t\tstrchr(logout_request, '?') != NULL ? \"&\" : \"?\",\n\t\t\t\t\t\t\toidc_util_escape_string(r, url));\n\t\t}\n\t\turl = logout_request;\n\t}\n\n\treturn oidc_handle_logout_request(r, c, session, url);\n}\n\n/*\n * handle request for JWKs\n */\nint oidc_handle_jwks(request_rec *r, oidc_cfg *c) {\n\n\t/* pickup requested JWKs type */\n\t//\tchar *jwks_type = NULL;\n\t//\toidc_util_get_request_parameter(r, \"jwks\", &jwks_type);\n\tchar *jwks = apr_pstrdup(r->pool, \"{ \\\"keys\\\" : [\");\n\tapr_hash_index_t *hi = NULL;\n\tapr_byte_t first = TRUE;\n\toidc_jose_error_t err;\n\n\tif (c->public_keys != NULL) {\n\n\t\t/* loop over the RSA public keys */\n\t\tfor (hi = apr_hash_first(r->pool, c->public_keys); hi; hi =\n\t\t\t\tapr_hash_next(hi)) {\n\n\t\t\tconst char *s_kid = NULL;\n\t\t\toidc_jwk_t *jwk = NULL;\n\t\t\tchar *s_json = NULL;\n\n\t\t\tapr_hash_this(hi, (const void**) &s_kid, NULL, (void**) &jwk);\n\n\t\t\tif (oidc_jwk_to_json(r->pool, jwk, &s_json, &err) == TRUE) {\n\t\t\t\tjwks = apr_psprintf(r->pool, \"%s%s %s \", jwks, first ? \"\" : \",\",\n\t\t\t\t\t\ts_json);\n\t\t\t\tfirst = FALSE;\n\t\t\t} else {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"could not convert RSA JWK to JSON using oidc_jwk_to_json: %s\",\n\t\t\t\t\t\toidc_jose_e2s(r->pool, err));\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: send stuff if first == FALSE?\n\tjwks = apr_psprintf(r->pool, \"%s ] }\", jwks);\n\n\treturn oidc_util_http_send(r, jwks, strlen(jwks), \"application/json\", DONE);\n}\n\nstatic int oidc_handle_session_management_iframe_op(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *check_session_iframe) {\n\toidc_debug(r, \"enter\");\n\tapr_table_add(r->headers_out, \"Location\", check_session_iframe);\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\nstatic int oidc_handle_session_management_iframe_rp(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *client_id,\n\t\tconst char *check_session_iframe) {\n\n\toidc_debug(r, \"enter\");\n\n\tconst char *java_script =\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      var targetOrigin  = '%s';\\n\"\n\t\t\t\"      var message = '%s' + ' ' + '%s';\\n\"\n\t\t\t\"\t   var timerID;\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function checkSession() {\\n\"\n\t\t\t\"        console.log('checkSession: posting ' + message + ' to ' + targetOrigin);\\n\"\n\t\t\t\"        var win = window.parent.document.getElementById('%s').contentWindow;\\n\"\n\t\t\t\"        win.postMessage( message, targetOrigin);\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function setTimer() {\\n\"\n\t\t\t\"        checkSession();\\n\"\n\t\t\t\"        timerID = setInterval('checkSession()', %s);\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function receiveMessage(e) {\\n\"\n\t\t\t\"        console.log('receiveMessage: ' + e.data + ' from ' + e.origin);\\n\"\n\t\t\t\"        if (e.origin !== targetOrigin ) {\\n\"\n\t\t\t\"          console.log('receiveMessage: cross-site scripting attack?');\\n\"\n\t\t\t\"          return;\\n\"\n\t\t\t\"        }\\n\"\n\t\t\t\"        if (e.data != 'unchanged') {\\n\"\n\t\t\t\"          clearInterval(timerID);\\n\"\n\t\t\t\"          if (e.data == 'changed') {\\n\"\n\t\t\t\"\t\t     window.location.href = '%s?session=check';\\n\"\n\t\t\t\"          } else {\\n\"\n\t\t\t\"\t\t     window.location.href = '%s?session=logout';\\n\"\n\t\t\t\"          }\\n\"\n\t\t\t\"        }\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      window.addEventListener('message', receiveMessage, false);\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"    </script>\\n\";\n\n\t/* determine the origin for the check_session_iframe endpoint */\n\tchar *origin = apr_pstrdup(r->pool, check_session_iframe);\n\tapr_uri_t uri;\n\tapr_uri_parse(r->pool, check_session_iframe, &uri);\n\tchar *p = strstr(origin, uri.path);\n\t*p = '\\0';\n\n\t/* the element identifier for the OP iframe */\n\tconst char *op_iframe_id = \"openidc-op\";\n\n\t/* restore the OP session_state from the session */\n\tconst char *session_state = NULL;\n\toidc_session_get(r, session, OIDC_SESSION_STATE_SESSION_KEY,\n\t\t\t&session_state);\n\tif (session_state == NULL) {\n\t\toidc_warn(r,\n\t\t\t\t\"no session_state found in the session; the OP does probably not support session management!?\");\n\t\treturn DONE;\n\t}\n\n\tchar *s_poll_interval = NULL;\n\toidc_util_get_request_parameter(r, \"poll\", &s_poll_interval);\n\tif (s_poll_interval == NULL)\n\t\ts_poll_interval = \"3000\";\n\n\tjava_script = apr_psprintf(r->pool, java_script, origin, client_id,\n\t\t\tsession_state, op_iframe_id, s_poll_interval, c->redirect_uri,\n\t\t\tc->redirect_uri);\n\n\treturn oidc_util_html_send(r, NULL, java_script, \"setTimer\", NULL, DONE);\n}\n\n/*\n * handle session management request\n */\nstatic int oidc_handle_session_management(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\tchar *cmd = NULL;\n\tconst char *id_token_hint = NULL, *client_id = NULL, *check_session_iframe =\n\t\t\tNULL;\n\toidc_provider_t *provider = NULL;\n\n\t/* get the command passed to the session management handler */\n\toidc_util_get_request_parameter(r, \"session\", &cmd);\n\tif (cmd == NULL) {\n\t\toidc_error(r, \"session management handler called with no command\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* see if this is a local logout during session management */\n\tif (apr_strnatcmp(\"logout\", cmd) == 0) {\n\t\toidc_debug(r,\n\t\t\t\t\"[session=logout] calling oidc_handle_logout_request because of session mgmt local logout call.\");\n\t\treturn oidc_handle_logout_request(r, c, session, c->default_slo_url);\n\t}\n\n\t/* see if this is a request for the OP iframe */\n\tif (apr_strnatcmp(\"iframe_op\", cmd) == 0) {\n\t\toidc_session_get(r, session, OIDC_CHECK_IFRAME_SESSION_KEY,\n\t\t\t\t&check_session_iframe);\n\t\tif (check_session_iframe != NULL) {\n\t\t\treturn oidc_handle_session_management_iframe_op(r, c, session,\n\t\t\t\t\tcheck_session_iframe);\n\t\t}\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* see if this is a request for the RP iframe */\n\tif (apr_strnatcmp(\"iframe_rp\", cmd) == 0) {\n\t\toidc_session_get(r, session, OIDC_CLIENTID_SESSION_KEY, &client_id);\n\t\toidc_session_get(r, session, OIDC_CHECK_IFRAME_SESSION_KEY,\n\t\t\t\t&check_session_iframe);\n\t\tif ((client_id != NULL) && (check_session_iframe != NULL)) {\n\t\t\treturn oidc_handle_session_management_iframe_rp(r, c, session,\n\t\t\t\t\tclient_id, check_session_iframe);\n\t\t}\n\t\toidc_debug(r,\n\t\t\t\t\"iframe_rp command issued but no client (%s) and/or no check_session_iframe (%s) set\",\n\t\t\t\tclient_id, check_session_iframe);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* see if this is a request check the login state with the OP */\n\tif (apr_strnatcmp(\"check\", cmd) == 0) {\n\t\toidc_session_get(r, session, OIDC_IDTOKEN_SESSION_KEY, &id_token_hint);\n\t\toidc_get_provider_from_session(r, c, session, &provider);\n\t\tif ((session->remote_user != NULL) && (provider != NULL)) {\n\t\t\treturn oidc_authenticate_user(r, c, provider,\n\t\t\t\t\tapr_psprintf(r->pool, \"%s?session=iframe_rp\",\n\t\t\t\t\t\t\tc->redirect_uri), NULL, id_token_hint, \"none\", NULL);\n\t\t}\n\t\toidc_debug(r,\n\t\t\t\t\"[session=check] calling oidc_handle_logout_request because no session found.\");\n\t\treturn oidc_session_redirect_parent_window_to_logout(r, c);\n\t}\n\n\t/* handle failure in fallthrough */\n\toidc_error(r, \"unknown command: %s\", cmd);\n\n\treturn HTTP_INTERNAL_SERVER_ERROR;\n}\n\n/*\n * handle refresh token request\n */\nstatic int oidc_handle_refresh_token_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\tchar *return_to = NULL;\n\tchar *r_access_token = NULL;\n\tchar *error_code = NULL;\n\n\t/* get the command passed to the session management handler */\n\toidc_util_get_request_parameter(r, \"refresh\", &return_to);\n\toidc_util_get_request_parameter(r, \"access_token\", &r_access_token);\n\n\t/* check the input parameters */\n\tif (return_to == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"refresh token request handler called with no URL to return to\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif (r_access_token == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"refresh token request handler called with no access_token parameter\");\n\t\terror_code = \"no_access_token\";\n\t\tgoto end;\n\t}\n\n\tchar *s_access_token = NULL;\n\toidc_session_get(r, session, OIDC_ACCESSTOKEN_SESSION_KEY,\n\t\t\t(const char **) &s_access_token);\n\tif (s_access_token == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"no existing access_token found in the session, nothing to refresh\");\n\t\terror_code = \"no_access_token_exists\";\n\t\tgoto end;\n\t}\n\n\t/* compare the access_token parameter used for XSRF protection */\n\tif (apr_strnatcmp(s_access_token, r_access_token) != 0) {\n\t\toidc_error(r,\n\t\t\t\t\"access_token passed in refresh request does not match the one stored in the session\");\n\t\terror_code = \"no_access_token_match\";\n\t\tgoto end;\n\t}\n\n\t/* get a handle to the provider configuration */\n\toidc_provider_t *provider = NULL;\n\tif (oidc_get_provider_from_session(r, c, session, &provider) == FALSE) {\n\t\terror_code = \"session_corruption\";\n\t\tgoto end;\n\t}\n\n\t/* execute the actual refresh grant */\n\tif (oidc_refresh_access_token(r, c, session, provider, NULL) == FALSE) {\n\t\toidc_error(r, \"access_token could not be refreshed\");\n\t\terror_code = \"refresh_failed\";\n\t\tgoto end;\n\t}\n\n\t/* store the session */\n\tif (oidc_session_save(r, session) == FALSE) {\n\t\terror_code = \"session_corruption\";\n\t\tgoto end;\n\t}\n\nend:\n\n\t/* pass optional error message to the return URL */\n\tif (error_code != NULL)\n\t\treturn_to = apr_psprintf(r->pool, \"%s%serror_code=%s\", return_to,\n\t\t\t\tstrchr(return_to, '?') ? \"&\" : \"?\",\n\t\t\t\t\t\toidc_util_escape_string(r, error_code));\n\n\t/* add the redirect location header */\n\tapr_table_add(r->headers_out, \"Location\", return_to);\n\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\n/*\n * handle request object by reference request\n */\nstatic int oidc_handle_request_uri(request_rec *r, oidc_cfg *c) {\n\n\tchar *request_ref = NULL;\n\toidc_util_get_request_parameter(r, \"request_uri\", &request_ref);\n\tif (request_ref == NULL) {\n\t\toidc_error(r, \"no \\\"request_uri\\\" parameter found\");\n\t\treturn HTTP_BAD_REQUEST;\n\t}\n\n\tconst char *jwt = NULL;\n\tc->cache->get(r, OIDC_CACHE_SECTION_REQUEST_URI, request_ref, &jwt);\n\tif (jwt == NULL) {\n\t\toidc_error(r, \"no cached JWT found for request_uri reference: %s\",\n\t\t\t\trequest_ref);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\tc->cache->set(r, OIDC_CACHE_SECTION_REQUEST_URI, request_ref, NULL, 0);\n\n\treturn oidc_util_http_send(r, jwt, strlen(jwt), \" application/jwt\", DONE);\n}\n\n/*\n * handle a request to invalidate a cached access token introspection result\n */\nstatic int oidc_handle_remove_at_cache(request_rec *r, oidc_cfg *c) {\n\tchar *access_token = NULL;\n\toidc_util_get_request_parameter(r, \"remove_at_cache\", &access_token);\n\n\tconst char *cache_entry = NULL;\n\tc->cache->get(r, OIDC_CACHE_SECTION_ACCESS_TOKEN, access_token, &cache_entry);\n\tif (cache_entry == NULL) {\n\t\toidc_error(r, \"no cached access token found for value: %s\", access_token);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\tc->cache->set(r, OIDC_CACHE_SECTION_ACCESS_TOKEN, access_token, NULL, 0);\n\n\treturn DONE;\n}\n\n/*\n * handle all requests to the redirect_uri\n */\nint oidc_handle_redirect_uri_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\tif (oidc_proto_is_redirect_authorization_response(r, c)) {\n\n\t\t/* this is an authorization response from the OP using the Basic Client profile or a Hybrid flow*/\n\t\treturn oidc_handle_redirect_authorization_response(r, c, session);\n\n\t} else if (oidc_proto_is_post_authorization_response(r, c)) {\n\n\t\t/* this is an authorization response using the fragment(+POST) response_mode with the Implicit Client profile */\n\t\treturn oidc_handle_post_authorization_response(r, c, session);\n\n\t} else if (oidc_is_discovery_response(r, c)) {\n\n\t\t/* this is response from the OP discovery page */\n\t\treturn oidc_handle_discovery_response(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r, \"logout\")) {\n\n\t\t/* handle logout */\n\t\treturn oidc_handle_logout(r, c, session);\n\n\t} else if (oidc_util_request_has_parameter(r, \"jwks\")) {\n\n\t\t/* handle JWKs request */\n\t\treturn oidc_handle_jwks(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r, \"session\")) {\n\n\t\t/* handle session management request */\n\t\treturn oidc_handle_session_management(r, c, session);\n\n\t} else if (oidc_util_request_has_parameter(r, \"refresh\")) {\n\n\t\t/* handle refresh token request */\n\t\treturn oidc_handle_refresh_token_request(r, c, session);\n\n\t} else if (oidc_util_request_has_parameter(r, \"request_uri\")) {\n\n\t\t/* handle request object by reference request */\n\t\treturn oidc_handle_request_uri(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r, \"remove_at_cache\")) {\n\n\t\t/* handle request to invalidate access token cache */\n\t\treturn oidc_handle_remove_at_cache(r, c);\n\n\t} else if ((r->args == NULL) || (apr_strnatcmp(r->args, \"\") == 0)) {\n\n\t\t/* this is a \"bare\" request to the redirect URI, indicating implicit flow using the fragment response_mode */\n\t\treturn oidc_proto_javascript_implicit(r, c);\n\t}\n\n\t/* this is not an authorization response or logout request */\n\n\t/* check for \"error\" response */\n\tif (oidc_util_request_has_parameter(r, \"error\")) {\n\n//\t\tchar *error = NULL, *descr = NULL;\n//\t\toidc_util_get_request_parameter(r, \"error\", &error);\n//\t\toidc_util_get_request_parameter(r, \"error_description\", &descr);\n//\n//\t\t/* send user facing error to browser */\n//\t\treturn oidc_util_html_send_error(r, error, descr, DONE);\n\t\toidc_handle_redirect_authorization_response(r, c, session);\n\t}\n\n\t/* something went wrong */\n\treturn oidc_util_html_send_error(r, c->error_template, \"Invalid Request\",\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"The OpenID Connect callback URL received an invalid request: %s\",\n\t\t\t\t\tr->args), HTTP_INTERNAL_SERVER_ERROR);\n}\n\n/*\n * main routine: handle OpenID Connect authentication\n */\nstatic int oidc_check_userid_openidc(request_rec *r, oidc_cfg *c) {\n\n\tif (c->redirect_uri == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"configuration error: the authentication type is set to \\\"openid-connect\\\" but OIDCRedirectURI has not been set\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* check if this is a sub-request or an initial request */\n\tif (ap_is_initial_req(r)) {\n\n\t\tint rc = OK;\n\n\t\t/* load the session from the request state; this will be a new \"empty\" session if no state exists */\n\t\toidc_session_t *session = NULL;\n\t\toidc_session_load(r, &session);\n\n\t\t/* see if the initial request is to the redirect URI; this handles potential logout too */\n\t\tif (oidc_util_request_matches_url(r, c->redirect_uri)) {\n\n\t\t\t/* handle request to the redirect_uri */\n\t\t\trc = oidc_handle_redirect_uri_request(r, c, session);\n\n\t\t\t/* free resources allocated for the session */\n\t\t\toidc_session_free(r, session);\n\n\t\t\treturn rc;\n\n\t\t/* initial request to non-redirect URI, check if we have an existing session */\n\t\t} else if (session->remote_user != NULL) {\n\n\t\t\t/* set the user in the main request for further (incl. sub-request) processing */\n\t\t\tr->user = (char *) session->remote_user;\n\n\t\t\t/* this is initial request and we already have a session */\n\t\t\trc = oidc_handle_existing_session(r, c, session);\n\n\t\t\t/* free resources allocated for the session */\n\t\t\toidc_session_free(r, session);\n\n\t\t\t/* strip any cookies that we need to */\n\t\t\toidc_strip_cookies(r);\n\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* free resources allocated for the session */\n\t\toidc_session_free(r, session);\n\n\t\t/*\n\t\t * else: initial request, we have no session and it is not an authorization or\n\t\t *       discovery response: just hit the default flow for unauthenticated users\n\t\t */\n\t} else {\n\n\t\t/* not an initial request, try to recycle what we've already established in the main request */\n\t\tif (r->main != NULL)\n\t\t\tr->user = r->main->user;\n\t\telse if (r->prev != NULL)\n\t\t\tr->user = r->prev->user;\n\n\t\tif (r->user != NULL) {\n\n\t\t\t/* this is a sub-request and we have a session (headers will have been scrubbed and set already) */\n\t\t\toidc_debug(r,\n\t\t\t\t\t\"recycling user '%s' from initial request for sub-request\",\n\t\t\t\t\tr->user);\n\n\t\t\t/*\n\t\t\t * apparently request state can get lost in sub-requests, so let's see\n\t\t\t * if we need to restore id_token and/or claims from the session cache\n\t\t\t */\n\t\t\tconst char *s_id_token = oidc_request_state_get(r,\n\t\t\t\t\tOIDC_IDTOKEN_CLAIMS_SESSION_KEY);\n\t\t\tif (s_id_token == NULL) {\n\n\t\t\t\toidc_session_t *session = NULL;\n\t\t\t\toidc_session_load(r, &session);\n\n\t\t\t\toidc_copy_tokens_to_request_state(r, session, NULL, NULL);\n\n\t\t\t\t/* free resources allocated for the session */\n\t\t\t\toidc_session_free(r, session);\n\t\t\t}\n\n\t\t\t/* strip any cookies that we need to */\n\t\t\toidc_strip_cookies(r);\n\n\t\t\treturn OK;\n\t\t}\n\t\t/*\n\t\t * else: not initial request, but we could not find a session, so:\n\t\t * just hit the default flow for unauthenticated users\n\t\t */\n\t}\n\n\t/* find out which action we need to take when encountering an unauthenticated request */\n\tswitch (oidc_dir_cfg_unauth_action(r)) {\n\t\tcase OIDC_UNAUTH_RETURN410:\n\t\t\treturn HTTP_GONE;\n\t\tcase OIDC_UNAUTH_RETURN401:\n\t\t\treturn HTTP_UNAUTHORIZED;\n\t\tcase OIDC_UNAUTH_PASS:\n\t\t\tr->user = \"\";\n\t\t\treturn OK;\n\t\tcase OIDC_UNAUTH_AUTHENTICATE:\n\t\t\t/* if this is a Javascript path we won't redirect the user and create a state cookie */\n\t\t\tif (apr_table_get(r->headers_in, \"X-Requested-With\") != NULL)\n\t\t\t\treturn HTTP_UNAUTHORIZED;\n\t\t\tbreak;\n\t}\n\n\t/* else: no session (regardless of whether it is main or sub-request), go and authenticate the user */\n\treturn oidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, NULL);\n}\n\n/*\n * generic Apache authentication hook for this module: dispatches to OpenID Connect or OAuth 2.0 specific routines\n */\nint oidc_check_user_id(request_rec *r) {\n\n\toidc_cfg *c = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\t/* log some stuff about the incoming HTTP request */\n\toidc_debug(r, \"incoming request: \\\"%s?%s\\\", ap_is_initial_req(r)=%d\",\n\t\t\tr->parsed_uri.path, r->args, ap_is_initial_req(r));\n\n\t/* see if any authentication has been defined at all */\n\tif (ap_auth_type(r) == NULL)\n\t\treturn DECLINED;\n\n\t/* see if we've configured OpenID Connect user authentication for this request */\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r), \"openid-connect\")\n\t\t\t== 0)\n\t\treturn oidc_check_userid_openidc(r, c);\n\n\t/* see if we've configured OAuth 2.0 access control for this request */\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r), \"oauth20\") == 0)\n\t\treturn oidc_oauth_check_userid(r, c);\n\n\t/* this is not for us but for some other handler */\n\treturn DECLINED;\n}\n\n/*\n * get the claims and id_token from request state\n */\nstatic void oidc_authz_get_claims_and_idtoken(request_rec *r, json_t **claims,\n\t\tjson_t **id_token) {\n\tconst char *s_claims = oidc_request_state_get(r, OIDC_CLAIMS_SESSION_KEY);\n\tconst char *s_id_token = oidc_request_state_get(r,\n\t\t\tOIDC_IDTOKEN_CLAIMS_SESSION_KEY);\n\tjson_error_t json_error;\n\tif (s_claims != NULL) {\n\t\t*claims = json_loads(s_claims, 0, &json_error);\n\t\tif (*claims == NULL) {\n\t\t\toidc_error(r, \"could not restore claims from request state: %s\",\n\t\t\t\t\tjson_error.text);\n\t\t}\n\t}\n\tif (s_id_token != NULL) {\n\t\t*id_token = json_loads(s_id_token, 0, &json_error);\n\t\tif (*id_token == NULL) {\n\t\t\toidc_error(r, \"could not restore id_token from request state: %s\",\n\t\t\t\t\tjson_error.text);\n\t\t}\n\t}\n}\n\n#if MODULE_MAGIC_NUMBER_MAJOR >= 20100714\n/*\n * generic Apache >=2.4 authorization hook for this module\n * handles both OpenID Connect or OAuth 2.0 in the same way, based on the claims stored in the session\n */\nauthz_status oidc_authz_checker(request_rec *r, const char *require_args, const void *parsed_require_args) {\n\n\t/* check for anonymous access and PASS mode */\n\tif (r->user != NULL && strlen(r->user) == 0) {\n\t\tr->user = NULL;\n\t\tif (oidc_dir_cfg_unauth_action(r) == OIDC_UNAUTH_PASS) return AUTHZ_GRANTED;\n\t}\n\n\t/* get the set of claims from the request state (they've been set in the authentication part earlier */\n\tjson_t *claims = NULL, *id_token = NULL;\n\toidc_authz_get_claims_and_idtoken(r, &claims, &id_token);\n\n\t/* merge id_token claims (e.g. \"iss\") in to claims json object */\n\tif (claims)\n\t\toidc_util_json_merge(id_token, claims);\n\n\t/* dispatch to the >=2.4 specific authz routine */\n\tauthz_status rc = oidc_authz_worker24(r, claims ? claims : id_token, require_args);\n\n\t/* cleanup */\n\tif (claims) json_decref(claims);\n\tif (id_token) json_decref(id_token);\n\n\tif ((rc == AUTHZ_DENIED) && ap_auth_type(r)\n\t\t\t&& (apr_strnatcasecmp((const char *) ap_auth_type(r), \"oauth20\")\n\t\t\t\t\t== 0))\n\t\toidc_oauth_return_www_authenticate(r, \"insufficient_scope\", \"Different scope(s) or other claims required\");\n\n\treturn rc;\n}\n#else\n/*\n * generic Apache <2.4 authorization hook for this module\n * handles both OpenID Connect and OAuth 2.0 in the same way, based on the claims stored in the request context\n */\nint oidc_auth_checker(request_rec *r) {\n\n\t/* check for anonymous access and PASS mode */\n\tif (r->user != NULL && strlen(r->user) == 0) {\n\t\tr->user = NULL;\n\t\tif (oidc_dir_cfg_unauth_action(r) == OIDC_UNAUTH_PASS)\n\t\t\treturn OK;\n\t}\n\n\t/* get the set of claims from the request state (they've been set in the authentication part earlier */\n\tjson_t *claims = NULL, *id_token = NULL;\n\toidc_authz_get_claims_and_idtoken(r, &claims, &id_token);\n\n\t/* get the Require statements */\n\tconst apr_array_header_t * const reqs_arr = ap_requires(r);\n\n\t/* see if we have any */\n\tconst require_line * const reqs =\n\t\t\treqs_arr ? (require_line *) reqs_arr->elts : NULL;\n\tif (!reqs_arr) {\n\t\toidc_debug(r,\n\t\t\t\t\"no require statements found, so declining to perform authorization.\");\n\t\treturn DECLINED;\n\t}\n\n\t/* merge id_token claims (e.g. \"iss\") in to claims json object */\n\tif (claims)\n\t\toidc_util_json_merge(id_token, claims);\n\n\t/* dispatch to the <2.4 specific authz routine */\n\tint rc = oidc_authz_worker(r, claims ? claims : id_token, reqs,\n\t\t\treqs_arr->nelts);\n\n\t/* cleanup */\n\tif (claims)\n\t\tjson_decref(claims);\n\tif (id_token)\n\t\tjson_decref(id_token);\n\n\tif ((rc == HTTP_UNAUTHORIZED) && ap_auth_type(r)\n\t\t\t&& (apr_strnatcasecmp((const char *) ap_auth_type(r), \"oauth20\")\n\t\t\t\t\t== 0))\n\t\toidc_oauth_return_www_authenticate(r, \"insufficient_scope\",\n\t\t\t\t\"Different scope(s) or other claims required\");\n\n\treturn rc;\n}\n#endif\n\nextern const command_rec oidc_config_cmds[];\n\nmodule AP_MODULE_DECLARE_DATA auth_openidc_module = {\n\t\tSTANDARD20_MODULE_STUFF,\n\t\toidc_create_dir_config,\n\t\toidc_merge_dir_config,\n\t\toidc_create_server_config,\n\t\toidc_merge_server_config,\n\t\toidc_config_cmds,\n\t\toidc_register_hooks\n};\n"], "fixing_code": ["01/18/2017\n- don't echo the query parameters on the error page when an invalid request is made to the Redirect URI; closes #212; thanks @LukasReschke\n\n01/14/2017\n- use dynamic memory buffer for writing HTTP call responses; solves curl/mpm-event interference; see #207\n- bump to 2.1.4rc1\n\n01/10/2017\n- don't crash when data is POST-ed to the redirect URL, it has just 1 POST parameter and it is not \"response_mode\"\n\n01/2/2017\n- remove trailing linebreaks from input in test-cmd tool\n- bump copyright year to 2017\n\n12/14/2016\n- support Libre SSL, see #205, thanks @AliceWonderMiscreations\n- update OIDC logout support to Front-Channel Logout 1.0 draft 01: http://openid.net/specs/openid-connect-frontchannel-1_0.html\n- bump to 2.1.4rc0\n\n12/13/2016\n- release 2.1.3\n\n12/12/2016\n- don't rollover session id's and keep the same session cookie name for cache storage over session updates\n- bump to 2.1.3rc0\n\n11/19/2016\n- release 2.1.2\n\n11/18/2016\n- fix crash when searching for keys with a kid, there's no initial match and x5t values exist for the non-matching keys; closes #196\n\n11/9/2016\n- remove stale claims from session when refreshing them from the userinfo endpoint fails; addresses #194\n- release 2.1.1\n\n11/8/2016\n- log readable error messages when memcache operations fail\n\n11/6/2016\n- fix memory leak when skipping jwks_uri keys with a non-matching \"use\" value\n\n11/4/2016\n- always restore id_token/claims on sub-requests so e.g. listing claims-protected subdirectories will work\n- remove obsolete functions for storing the session in the request state\n- bump to 2.1.1rc0\n\n11/3/2016\n- remove obsolete sessions from session cache; thanks @stevedave\n\n11/1/2016\n- release version 2.1.0\n\n10/28/2016\n- don't include encryption keys from the jwks_uri when verifying a JWT and no kid has been specified\n- fix memory leaks in composite claim handling\n\n10/27/2016\n- handle aggregated and distributed claims from the userinfo endpoint\n- only pick private_key_jwt token endpoint authentication if a private key is configured; closes #189\n- bump to 2.0.1rc7\n\n10/24/2016\n- add OpenID Connect RP certification test script\n- handle non-integer exp/iat timestamps; closes #187; thanks @drdivano\n\n10/21/2016\n- bugfix: first truncate files before writing them\n- support refreshing provider metadata based on timestamp and OIDCProviderMetadataRefreshInterval\n\n10/20/2016\n- bugfix: correctly truncate encryption keys derived from client secret for algorithms that require a key size < 256 bits\n- add test/test-cmd tool\n- bugfix: return error on session cache failures; closes #185; thanks @solsson\n- bump to 2.0.1rc6\n\n10/18/2016\n- bugfix: JWTs with a header that doesn't specify a `kid` that would not validate when used with more than 1 key; closes #184; thanks @solsson\n- bump to 2.0.1rc5\n\n10/13/2016\n- urlencode provider URL cache key to fix file cache backend issue; closes #179, thanks @djahandarie\n\n10/9/2016\n- fix null pointer segfault in debug printout in oidc_util_read_form_encoded_params\n- fix OIDCOAuthAcceptTokenAs parsing flaw introduced in 2.0.0rc5\n- bump to 2.0.1rc4\n\n10/2/2016\n- support presenting the access token to the userinfo endpoint in a POST parameter\n- bump to 2.0.1rc3\n\n9/30/2016\n- support WebFinger Discovery with URL-style user identifiers\n\n9/28/2016\n- fix memory leak in oidc_jwk_to_json\n- add \"remove_at_cache\" hook; addresses #177\n- bump to 2.0.1rc2\n\n9/27/2016\n- add support for Request URI with signed and/or encrypted Request Objects\n- bump to 2.0.1rc1\n\n9/22/2016\n- refuse webfinger responses with an href value that is not on secure https\n- add userinfo JWT response verification and decryption\n\n9/20/2016\n- log the JWT header before optional decryption is applied\n\n9/19/2016\n- check that a sub claim returned from the userinfo endpoint matches the one in the id_token\n- fix issue in oidc_metadata_parse_url so that static default would not be honored\n  - this only affected server-wide OIDCClientJwksUri usage in dynamic client registration\n- non-functional changes for OIDC RP certification:\n  - explicitly log the client authentication method when calling the token endpoint\n  - log the keys that are included for token verification\n- bump to 2.0.1rc0\n\n9/9/2016\n- fix overriding provider token endpoint auth with static config when not set in .conf file\n- don't add our own cookies to the incoming headers\n- allow stripping cookies from the Cookie header sent to the application/backend with OIDCStripCookies\n- release 2.0.0\n\n9/5/2016\n- encapsulate (sub-)directory config handling and fix merging so values can be set back to default values in subdirs\n- bump to 2.0.0rc5\n\n9/2/2016\n- fix JWK creation when no client secret is set e.g. in Implicit flows; closes #168; thanks @asc1\n- bump to 2.0.0rc4\n\n9/1/2016\n- fix HTML decoding of OIDCPreservePost data; closes #165\n- limit max POST data size to 1Mb\n- allow chunked data in POST handling; revise handler\n- change preserve POST JSON data format to urlencoded for performance reasons\n\n8/31/2016\n- allow setting the token endpoint authentication method in the .conf file (for dynamic client registration that sets the .client)\n\n8/30/2016\n- pass refresh token in header/environment variable with OIDCPassRefreshToken; thanks Amit Joshi\n- fix front-channel img-style logout with newer versions of PingFederate that don't send an Accept: image/png header\n\n8/29/2016\n- preserve POST data across authentication requests and discovery with OIDCPreservePost\n- bump to 2.0.0rc3\n\n8/24/2016\n- fix parsing of OIDCOAuthAcceptTokenAs to accept options following \":\"\n- bump to 2.0.0rc2\n\n8/5/2016\n- delete the debian directory\n- rename OIDCOAuthTokenEndpointCert/Key to OIDCOAuthIntrospectionEndpointCert/Key\n- pre-release 2.0.0rc1\n\n7/30/2016\n- encrypt state/session JWT cookies and session JWT cache values for non-shm storages\n\n7/29/2016\n- use cjose - https://github.com/cisco/cjose (master) - for JOSE functions\n- use stricter input parsing functions for configuration values\n- bump to 2.0.0rc0\n\n7/21/2016\n- support TLS client authentication to token and introspection endpoints\n- bump to 1.9.0rc3\n\n7/19/2016\n- add support for chunked session cookies; closes #153; thanks @glatzert \n- bump to 1.9.0rc2\n\n7/9/2016\n- fix Elliptic Curve signature verification for corrupted input\n- support OpenSSL 1.1.x\n- bump to 1.9.0rc1\n\n7/5/2016\n- use AUTHZ_DENIED instead of HTTP_UNAUTHORIZED in oidc_authz_checker; closes #151; thanks @gwollman\n- use signed JWTs for state/session cookies\n- achieve smaller client-cookie sizes for regular cases; no id_token is stored in the session:\n  - (optional) id_token_hint no longer available in session management calls (logout/prompt=none) with \"OIDCSessionType client-cookie\"\n  - \"OIDCPassIDTokenAs serialized\" is not available with \"OIDCSessionType client-cookie\"\n- bump to 1.9.0rc0\n\n6/27/2016\n- use EVP_CIPHER_CTX_new to avoid compilation errors with OpenSSL 1.1.0\n- release 1.8.10\n\n6/22/2016\n- don't use local port setting for current URL determination when X-Forwarded-Host has been set\n- bump to 1.8.10rc4\n\n6/20/2016\n- fix memory leak in OAuth access token introspection result caching (introduced only in 1.8.10rc0)\n- fix setting private_key_jwt or client_secret_jwt with OIDCProviderTokenEndpointAuth\n- bump to 1.8.10rc3\n\n6/19/2016\n- allow setting OIDCRemoteUserClaim with values obtained from the userinfo endpoint; thanks @steve-dave\n- fix OIDCUnAuthAction pass mode for Apache 2.4 and in case `Require claim` primitives used for 2.4 and 2.2; thanks @steve-dave\n- bump to 1.8.10rc2\n\n6/15/2016\n- add support for JWT based client authentication to the token endpoint (client_secret_jwt, private_key_jwt)\n- bump to 1.8.10rc1\n\n6/9/2016\n- add per-path configurable token introspection result cache expiry with OIDCOAuthTokenIntrospectionInterval\n- bump to 1.8.10rc0\n\n6/5/2016\n- release 1.8.9\n\n5/9/2016\n- support 410 option on OIDCUnAuthAction; closes #141\n- bump to 1.8.9rc6\n\n5/1/2016\n- avoid segmentation fault on invalid OIDC configuration when OIDCRedirectURI is not set; fixes #138; thanks @brianwcook\n- bump to 1.8.9rc5\n\n4/18/2016\n- fix get_current_url (proxy) case where r->parsed_uri.path would be null\n\n4/13/2016\n- improve X-Forwarded-Host handling over Host in a) port detection and b) remove port from host value\n- bump to 1.8.9rc4\n\n4/10/2016\n- do not require OIDCClientSecret in configs; allows for Implicit grant without setting a dummy client secret; closes #130\n- allow for public clients calling the token endpoint\n- bump to 1.8.9rc3\n\n4/9/2016\n- ensure that claims from id_token are available for authz also when OIDCPassIDTokenAs does not contain \"claims\"; closes #129\n- bump to 1.8.9rc2\n\n4/3/2016\n- return WWW-Authenticate header and error messages on OAuth paths where access is not granted; closes #124; thanks @spinto\n- bump to 1.8.9rc1\n\n4/1/2016\n- apr_jwe_decrypt_content_aesgcm() null terminate string, #128, thanks @jdennis\n- bump to 1.8.9rc0\n\n3/10/2016\n- release 1.8.8\n\n3/7/2016\n- issue a warning if the \"openid\" scope is not requested\n\n3/6/2016\n- sanitize the OIDCAuthNHeader value before setting the header; thanks @rfk\n- bump to 1.8.8rc7\n\n3/5/2016\n- log exact version of OpenSSL and EC/GCM/Redis support\n- tidy up auth_openidc.conf docs\n- bump to 1.8.8rc6\n\n2/26/2016\n- add option to refresh claims from the userinfo endpoint using OIDCUserInfoRefreshInterval; see #119\n- merge id_token claims in to the set of claims used for authorization for Apache >=2.4; see #120\n- bump to 1.8.8rc5\n\n2/23/2016\n- make state cookie a session cookie and clean expired cookies on entry (merge of fix-firefox-cookie-storage)\n- fix HTML error template initialization in vhosts\n- bump to 1.8.8rc4\n\n2/22/2016\n- don't authenticate (redirect/state) when X-Requested-With header exists; as suggested in #113\n- bump to 1.8.8rc3\n\n2/18/2016\n- pass plain state to the token endpoint on code flows: https://tools.ietf.org/html/draft-jones-oauth-mix-up-mitigation-01\n- fix loose (prefix-only) matching of cookie names\n- allow passing OAuth bearer token as a cookie (OIDCOAuthAcceptTokenAs extension for PingAccess)\n- bump to 1.8.8rc2\n\n2/11/2016\n- include token_endpoint_auth_method in dynamic client registration request, set to selected method from provider\n\n2/10/2016\n- Elliptic Curve support now requires OpenSSL 1.0.1 detection\n- bump to 1.8.8rc1\n\n1/14/2016\n- add support for passing in OAuth bearer tokens as one or more of: header, post param or query param (OIDCOAuthAcceptTokenAs)\n- bump to 1.8.8rc0\n\n1/8/2016\n- release 1.8.7\n\n1/7/2016\n- update copyright year\n\n12/17/2015\n- enforce strict matching of issuer in Discovery document against the originally requested issuer\n- check iss/client_id if present in an authentication response\n- push a hash of state to the token endpoint on code flows\n- bump to 1.8.7rc4\n\n12/9/2015\n- improve debug logging around session management capabilities (i.e. enabled/disabled)\n- return 404 for op/rp iframes if session management is not enabled\n- bump to 1.8.7rc3\n\n12/4/2015\n- add support for RFC 7636 PKCE plain & S256 https://tools.ietf.org/html/rfc7636\n- bump to 1.8.7rc2\n\n12/3/2015\n- fix crash when using a custom error template and the error description is NULL\n- fix crash when target_link_uri is not a valid URI or parts are empty\n- fix memory corruption when using custom html template across different server requests; closes #106\n- bump to 1.8.7rc1\n\n11/18/2015\n- fix compiler warning on double sizeof call; close #103; thanks to @dcb314\n- bump to 1.8.7rc0\n\n10/26/2015\n- add option to make session cookie persistent; closes #97\n- release 1.8.6\n\n10/19/2015\n- add support for applying a custom HTML error template with OIDCHTMLErrorTemplate\n- bump to 1.8.6rc3\n\n10/12/2015\n- check the cookie domain that the session was created for against the configured domain\n- log a warning if the Set-Cookie value length is greater than 4093 bytes\n- include and prioritize the X-Forwarded-Host header in hostname determination\n- allow for missing Host header i.e. HTTP 1.0\n- return DONE instead of HTTP_UNAUTHORIZED with Discovery page (prevent double HTML in HTTP 1.0)\n- use apr_strnatcmp instead of strcmp in util.c and mod_auth_openidc.c\n- bump to 1.8.6rc2\n\n10/9/2015\n- support subdomain cookies in OIDCCookieDomain checks; PR #96, thanks @pfiled\n- bump to 1.8.6rc1\n\n10/6/2015\n- add key identifier (\"kid\") option to `OIDCOAuthVerifySharedKeys`, `OIDCOAuthVerifyCertFiles` and `OIDCPublicKeyFiles` configs\n- bump to 1.8.6rc0\n\n9/21/2015\n- support (non-sid-based) HTTP logout: http://openid.net/specs/openid-connect-logout-1_0.html\n- release 1.8.5\n\n9/16/2015\n- improve logging on provider/client/conf metadata parsing failures; closes #94\n- bump to 1.8.5rc7\n\n9/9/2015\n- fix parsing of OIDCOAuthTokenExpiryClaim, thanks to @bester #90\n- bump to 1.8.5rc6\n\n9/4/2015\n- add CSRF protection to external Discovery as well\n- allow browser back after authorization response, see #89\n- handle invalid (expired) authorization response state by sending the user to OIDCDefaultURL, see #86\n- bump to 1.8.5rc5\n\n8/26/2015\n- add CSRF protection to Discovery\n- bump to 1.8.5rc4\n\n8/19/2015\n- support encrypted JWTs using A192KW for key encryption and A192CBC-HS384 for content encryption\n- bump to 1.8.5rc3\n\n8/15/2015\n- support encrypted JWTs using RSA-OAEP for key encryption and A128GCM,A192GCM,A256GCM for content encryption\n- bump to 1.8.5rc2\n\n8/4/2015\n- support for OIDCUnAuthAction: how to act on unauthenticated requests (OIDCReturn401 is deprecated)\n- bump to 1.8.5rc1\n\n7/15/2015\n- add authentication option for Redis server with OIDCRedisCachePassword\n- bump to 1.8.5rc0\n\n7/3/2015\n- allow for compilation on Windows using VS 2013\n- bump to 1.8.4\n\n6/30/2015\n- improve memcache logging: don't report cache misses as an error, thanks to @scottdear\n- work around JSON timestamp print modifier issue (%lld) on some platforms, thanks to @ralphvanetten\n- bump to 1.8.4rc3\n\n6/24/2015\n- support passing claims as environment variables (OIDCPassClaimsAs)\n- bump to 1.8.4rc1\n\n6/22/2015\n- correct debug printout in oidc_util_read_form_encoded_params\n\n6/20/2015\n- avoid double free of JWT after parsing errors have been encountered\n- bump to 1.8.4rc0\n\n6/19/2015\n- make public keys for encrypted access tokens available in OAuth-only configurations; fixes #74\n- remove exceptions for accounts.google.com since Google is OpenID Connect compliant now\n- release 1.8.3\n\n6/15/2015\n- add a complete JWT sample that includes validation of \"exp\" and \"iat\" to the test suite\n\n6/10/2015\n- allow JSON string values for the \"active\" claim in access token validation responses\n- bump to 1.8.3rc4\n\n6/7/2015\n- improve error logging on non-supported JWT signing/encryption algorithms\n- bump to 1.8.3rc3\n\n5/31/2015\n- merge id_token (\"iss\"!) and user info claims for authz processing\n- bump to 1.8.3rc2\n\n5/29/2015\n- fix hash comparison when padded, thanks to @steverc as mentioned in #65\n- fix post-logout URL being set to SSO URL\n- add post-logout URL validation, thanks to @davidbernick\n- bump to 1.8.3rc1\n\n5/18/2015\n- fix OpenSSL version detection for Elliptic Curve support in apr_jwt_signature_to_jwk_type: include opensslv.h\n- fix hash length calculation for Elliptic Curve algorithms\n- release 1.8.2\n\n5/5/2015\n- release 1.8.1\n\n4/21/2015\n- allow setting OIDCDiscoverURL inside of Directory and Location directives as well\n- bump to 1.8.1rc5\n\n4/20/2015\n- allow setting OIDCCookie outside of Directory and Location directives as well\n- bump to 1.8.1rc4\n\n4/17/2015\n- add support for applying regular expressions to OIDCRemoteUserClaim and OIDCOAuthRemoteUserClaim\n- bump to 1.8.1rc3\n\n4/12/2015\n- make token expiry parsing of introspection result configurable (OIDCOAuthTokenExpiryClaim)\n- increase SHM cache key size from 255 to 512 (allows for JWT access tokens cache keys for introspection result)\n- bump to 1.8.1rc2\n\n4/1/2015\n- avoid timing attacks on symmetric key signature/hash comparisons as pointed out by @timmclean\n- bump to 1.8.1rc1\n\n3/19/2015\n- merge #57: fix build with OpenSSL <1.0 re. apr_jws_signature_is_ec (thanks to @szakharchenko)\n\n2/26/2015\n- release 1.8.0\n\n2/23/2015\n- avoid including line feeds in header values (thanks to @forkbomber and @ekanthi)\n- bump to 1.8.0rc5\n\n2/16/2015\n- fix free() crash on simple-valued error printouts\n- fix returning keys without a \"kid\"\n- fix searching for keys with a \"x5t\" thumbprint\n- refactor response type handling; more strict matching of requested response type\n- make compiled in Redis support optional\n- fix oauth.introspection_endpoint_method in initialization\n- bump to 1.8.0rc4\n\n2/15/2015\n- add support for configurable introspection HTTP method (OIDCOAuthIntrospectionEndpointMethod)\n- add preliminary support for GET-style logout\n- bump to 1.8.0rc2\n\n2/12/2015\n- add support for configuration of maximum session duration\n- bump to 1.8.0rc1\n\n2/9/2015\n- check JWT signature against all configured keys (jwks_uri) if no \"kid\" is provided, not just the first one\n- revise JOSE JWS handling part 2\n- complete support for local JWT access token validation\n- bump to 1.8.0rc0\n\n2/5/2015\n- fix symmetric key decryption of JWTs (A128CBC-HS256/A256CBC-HS512)\n- sha256 client secrets before using them as symmetric keys for decryption\n- extended decryption test coverage; avoid double printouts on error\n- refactor JWT header parsing\n- simplify JWK URI refresh handling\n- release 1.7.3\n\n2/4/2015\n- revise JOSE JWK handling part 1\n- change change target_uri parameter name to target_link_uri following draft-bradley-oauth-jwt-encoded-state-03\n- extended tests with stubs\n- refactor JWT validation (iss, exp, iat)\n- fix memory leak with RSA key conversion in apr_jwk.c - apr_jwk_rsa_bio_to_key\n- bump to 1.7.3rc4\n\n1/25/2015\n- Allow {... \"error\": null ...} in JSON responses. (@fatlotus)\n\n1/22/2015\n- fix configuration validation check where no config would be checked if OIDCProviderIssuer is set\n  but both OIDRedirectURI and OIDCCryptoPassphrase are not set\n- add preliminary support for local JWT access token validation\n- bump to 1.7.3rc1\n- sanitize set cookie syntax (get rid of extraneous \";\")\n\n1/21/2015\n- add support for OIDCOAuthIntrospectionTokenParamName (incl. Google OAuth 2.0 access token validation)\n- add a sample OAuth 2.0 config for Google access tokens to README.md\n- release 1.7.2\n\n- add APXS2_OPTS to configure.ac to accommodate RPM builds\n- bump to 1.7.3rc0\n- fix JWT timestamp (iat/exp) initialization issue\n- fix README.md on Google's scope required for returning the \"hd\" claim\n\n1/14/2015\n- add Apache function stubs to enable extending the scope of tests\n- add tests for oidc_proto_validate_access_token and oidc_proto_validate_code\n- bump to 1.7.2rc3\n\n1/12/2015\n- improve accuracy of expired/invalid session handling\n\n1/11/2015\n- add error type and return values to JOSE functions\n- fix return result on error in function that decrypts CEK\n- bump to 1.7.2rc2\n\n1/1/2015\n- update copyright to 2015\n- use json_int_t (seconds) for \"exp\" and \"iat\" fields, instead of apr_time_t (microseconds) \n- correct expiry debug printout\n- bump to 1.7.2rc1\n\n12/15/2014\n- fix Redis reconnect behavior: avoid keep reconnecting after first failure\n- bump to 1.7.2rc0\n\n12/12/2014\n- support passing cookies specified in OIDCPassCookies from browser on to OP/AS calls (for loadbalancing purposes)\n- release 1.7.1\n- document OIDCPassCookies in auth_openidc.conf\n\n12/10/2014\n- reconnect to the Redis server after I/O failure as raised in #43\n- bump to 1.7.1rc4\n\n12/8/2014\n- return http 500 when detecting requests that will loop on return\n- bump to 1.7.1rc3\n\n12/3/2014\n- require the expiring access_token on the refresh hook for XSRF protection\n- pass error codes back to the caller when the refresh hook fails\n- bump to 1.7.1rc2\n\n12/2/2014\n- improve handling of non-string (=non-compliant) error responses\n\n11/26/2014\n- make shared memory cache entry max size configurable through OIDCCacheShmEntrySizeMax\n- add OIDCReturn401 configuration primitive\n- bump to 1.7.1rc1\n\n11/11/2014\n- allow OIDCRedirectURI's with an empty path and fix crash; thanks to @CedricCabessa\n\n11/9/2014\n- support for adding configurable JSON parameters to Dynamic Client Registration requests\n\n11/5/2014\n- release 1.7.0\n\n10/30/2014\n- correct expires_in conversion\n- first stab at HTML templating and make all html HTML 4.01 Strict compliant\n- bump to 1.7.0rc4\n\n10/29/2014\n- document refresh flow\n\n10/28/2014\n- scrub all OIDC_ headers\n- add support for the refresh_token flow + hook\n- pass the expires_in as an absolute timestamp in OIDC_access_token_expires\n- use a global mutex for the Redis cache\n- bump to 1.7.0rc3\n\n10/27/2014\n- generalize support for OAuth 2.0 token introspection and conform to:\n  https://tools.ietf.org/html/draft-ietf-oauth-introspection-00\n\n10/26/2014\n- support regular expressions in Require statements\n\n10/24/2014\n- add support for Redis cache backend; there's a dependency on hiredis headers/library now\n\n10/21/2014\n- refactor nonce generation and remove base64url padding from value\n\n10/13/2014\n- add libssl-dev to Debian control build dependencies\n- release 1.6.0\n\n10/6/2014\n- apply html encoding to error display\n- bump version number to 1.6.0rc4\n\n10/2/2014\n- avoid crash when downloading metadata from OIDCProviderMetadataURL fails\n- set OIDCProviderMetadataURL retrieval interval to 24 hours\n- return error on configurations mixing OIDCProviderMetadataURL and OIDCMetadataDir\n- bump version number to 1.6.0rc3\n\n10/1/2014\n- support provider configuration from a metadata URL (OIDCProviderMetadataURL)\n- bump version number to 1.6.0rc2\n\n9/30/2014\n- be less strict about issuer validation in metadata\n- refactor metadata.c\n- improve logging about userinfo endpoint\n\n9/29/2014\n- refactor cache so it is partitioned in to sections (i.e. avoid future key collisions)\n\n9/25/2014\n- add support for \"x5c\" JWK representation\n- return JWKS on jwks_uri with content-type \"application/json\"\n\n9/17/2014\n- remove support for the X-Frame-Options as it is not needed in 302s\n- create and use log macros that printout function name\n\n9/16/2014\n- support for passing runtime determined authentication request parameters in the discovery response\n- include name/version in logs and bump to 1.6.0rc1\n- don't use the X-Frame-Options by default\n\n9/13/2014\n- add support for the X-Frame-Options header as recommended by the spec\n\n9/12/2014\n- set expiry on state cookies; don't clear session cookie after cache miss or corruption\n- fix JSON array memory leak in oauth.c\n\n9/10/2014\n- merge #34 (g10f), fix session management Javascript bug\n\n9/3/2014\n- improve error handling on hitting the redirect URI directly\n- fix set_slot functions for algorithm/url used as default for dynamic registration\n- rewording of auth_openidc.conf docs on JWK settings\n\n9/1/2014\n- add session management based on http://openid.net/specs/openid-connect-session-1_0.html (draft 21)\n\n8/29/2014\n- add configuration option to POST extra parameters to the token endpoint\n\n8/26/2014\n- correct cookie_path comparison\n- release 1.5.5\n\n8/20/2014\n- correctly error out on flows where no id_token was provided (\"token\")\n\n8/19/2014\n- fix debug printout on open redirect prevention\n- cleanup in-memory crypto context on shutdown\n- use default of \"/\" for OIDCCookiePath to simplify quickstart/simple deployments\n- disable OIDCMetadataDir in sample/default config file\n- clear session cookie after cache miss or corruption\n\n8/18/2014\n- add HttpOnly flag to cookies by default; can be disabled by config\n\n8/14/2014\n- support for passing the id_token in multiple formats (claims|payload|serialized)\n- release 1.5.4\n\n8/13/2014\n- pass the access_token in OIDC_access_token header to the application\n\n8/9/2014\n- merge #21 (Latinovic) to close #18 (big endian JWE issue)\n- merge #20 (wadahiro), support for \"none\" JWT signing algorithm\n\n8/1/2014\n- fix cache initialization/destroy leak\n- release 1.5.3\n\n7/26/2014\n- refactor http code; cleanup JSON encoding in client registration\n- refactor padding handling in base64url encoding/decoding\n\n7/20/2014\n- check for open redirect on passed target_link_uri\n- prevent JWE timing attacks on CEK; add JWE test\n- include client_id and scope values in resolved access_token\n\n7/1/2014\n- pass JSON objects in app HTTP headers as plain JSON\n- correct printout in id_token hash comparisons\n- add more tests\n- release 1.5.2\n\n6/12/2014\n- support third-party-initiated login as defined in the spec\n- release 1.5.1\n- fix PF OAuth 2.0 RS functionality after upgrading to jansson\n\n6/6/2014\n- more changes for Debian packaging (1.5-3)\n\n6/5/2014\n- do not set Secure cookies for plain HTTP\n- add warning/errors when configured hosts/domains do not match\n- release 1.5\n- changes for Debian packaging\n\n6/4/2014\n- fix passing integer claims on non-Mac OS X systems\n- fix claims-based authorization with integer values (@martinsrom)\n- fix getting the id_token from request state and error logging\n- add AUTHORS file with credits\n- migrate README to Markdown README.md\n\n6/3/2014\n- change JSON parser from https://github.com/moriyoshi/apr-json to http://www.digip.org/jansson/\n\n6/2/2014\n- handle X-Forwarded-Proto/X-Forwarded-Port when running behind a proxy/load-balancer\n- release version 1.4\n\n6/1/2014\n- compile with OpenSSL <1.0 and but then disable Elliptic Curve verification\n- fix jwks_uri setting in nested vhosts\n- use OpenSSL_add_all_digests in initialization and EVP_cleanup on shutdown\n\n5/31/2014\n- README additions/improvements\n\n5/29/2014\n- correct big endian detection\n- allow for key identification in JWKs based on thumbprint (x5t)\n\n5/24/2014\n- add cache destroy function and destroy shm cache resources on shutdown\n\n5/23/2014\n- doc corrections to auth_openidc.conf\n\n5/22/2014\n- add implementation of OP-initiated-SSO based on:\n  http://tools.ietf.org/html/draft-bradley-oauth-jwt-encoded-state-01\n- fix nonce caching for replay prevention\n\n5/21/2014\n- correct README on enabling Google+ APIs before applying the sample Google configs\n- fix AuthNHeader setting and allow server-wide config too\n- avoid segfault on corrupted/non- JSON/JWT input\n\n5/20/2014\n- fix URL assembly when running on non-standard port\n- release 1.3\n\n5/17/2014\n- support outgoing proxy using OIDCOutgoingProxy\n- correct sample configs in documentation for missing OIDCCookiePath\n- support OIDCCookiePath in server-wide config as well\n\n5/13/2014\n- support configurable (custom) query parameters in the authorization request\n\n5/12/2014\n- support encrypted JWTs using A128KW and A256KW for the Content Encryption Key\n- support A256CBC-HS512 encrypted JWTs\n- support custom client JWKs URI\n\n5/8/2014\n- support encrypted JWTs using RSA1_5 and A128CBC-HS256\n\n5/2/2014\n- do not use ap_get_remote_host for browser fingerprinting\n\n5/1/2014\n- split out custom client config into separate <issuer>.conf file\n- allow to override client_contact, client_name and registration_token in .conf file\n- remove OIDCRegistrationToken command for the static OP config\n\n4/29/2014\n- support JWT verification of ES256, ES384 and ES512 algorithms\n\n4/28/2014\n- support configurable response_mode (fragment, query or form_post)\n- use nonce in all flows except for OP Google and flows \"code\" or \"code token\"\n\n4/26/2014\n- make client secret optional (support self-issued OP)\n\n4/25/2014\n- support Hybrid flows\n\n4/24/2014\n- fix using Bearer token Authorization header on JSON POST calls\n- support using a Bearer token on client registration calls\n\n4/22/2014\n- match request and response type \n- check at_hash value on \"token id_token\" implicit flow\n- use shared memory caching by default\n- release 1.2\n\n4/19/2014\n- store response_type in state and make state a JSON object\n\n4/18/2014\n- support RSASSA-PSS token signing algorithms (PS256,PS384,PS512)\n\n4/17/2014\n- improve session inactivity timeout handling\n\n4/16/2014\n- set REMOTE_USER and HTTP headers on OAuth 2.0 protected paths\n\n4/15/2014\n- add session inactivity timeout\n- register all supported response_types during client registration and try\n  to pick the one that matches the configured default\n- use long timeouts on JWK retrieval calls\n- allow for non-null but empty query parameters on implicit authorization response\n- simplify azp/aud and nonce handling\n- change session_type naming (to \"server-cache\"/\"client-cookie\")\n\n4/14/2014\n- factor out JOSE related code\n\n4/3/2014\n- add configurable claim name for the REMOTE_USER variable, optionally postfixed with the  url-encoded\n  issuer value; the default for the remote username is \"sub@\" now, makeing it unique across OPs\n- some refactoring of id_token validation functions\n- add INSTALL, move auth_openidc.conf to main directory\n- release 1.1\n\n3/28/2014\n- fix Require claim name mismatch for Apache 2.4\n- fix hmac method/printout naming artifacts from earlier\nauto-search-and-replace\n- release v1.0.1\n\n3/27/2014\n- initial import named mod_auth_openidc\n- updated README\n- fix debian/changelog\n", "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/***************************************************************************\n * Copyright (C) 2013-2017 Ping Identity Corporation\n * All rights reserved.\n *\n * For further information please contact:\n *\n *      Ping Identity Corporation\n *      1099 18th St Suite 2950\n *      Denver, CO 80202\n *      303.468.2900\n *      http://www.pingidentity.com\n *\n * DISCLAIMER OF WARRANTIES:\n *\n * THE SOFTWARE PROVIDED HEREUNDER IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT\n * ANY WARRANTIES OR REPRESENTATIONS EXPRESS, IMPLIED OR STATUTORY; INCLUDING,\n * WITHOUT LIMITATION, WARRANTIES OF QUALITY, PERFORMANCE, NONINFRINGEMENT,\n * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  NOR ARE THERE ANY\n * WARRANTIES CREATED BY A COURSE OR DEALING, COURSE OF PERFORMANCE OR TRADE\n * USAGE.  FURTHERMORE, THERE ARE NO WARRANTIES THAT THE SOFTWARE WILL MEET\n * YOUR NEEDS OR BE FREE FROM ERRORS, OR THAT THE OPERATION OF THE SOFTWARE\n * WILL BE UNINTERRUPTED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Initially based on mod_auth_cas.c:\n * https://github.com/Jasig/mod_auth_cas\n *\n * Other code copied/borrowed/adapted:\n * shared memory caching: mod_auth_mellon\n *\n * @Author: Hans Zandbelt - hzandbelt@pingidentity.com\n *\n **************************************************************************/\n\n#include \"apr_hash.h\"\n#include \"apr_strings.h\"\n#include \"ap_config.h\"\n#include \"ap_provider.h\"\n#include \"apr_lib.h\"\n#include \"apr_file_io.h\"\n#include \"apr_sha1.h\"\n#include \"apr_base64.h\"\n\n#include \"httpd.h\"\n#include \"http_core.h\"\n#include \"http_config.h\"\n#include \"http_log.h\"\n#include \"http_protocol.h\"\n#include \"http_request.h\"\n\n#include \"mod_auth_openidc.h\"\n\n// TODO:\n// - sort out oidc_cfg vs. oidc_dir_cfg stuff\n// - rigid input checking on discovery responses\n// - check self-issued support\n// - README.quickstart\n// - refresh metadata once-per too? (for non-signing key changes)\n\nextern module AP_MODULE_DECLARE_DATA auth_openidc_module;\n\n/*\n * clean any suspicious headers in the HTTP request sent by the user agent\n */\nstatic void oidc_scrub_request_headers(request_rec *r, const char *claim_prefix,\n\t\tconst char *authn_header) {\n\n\tconst int prefix_len = claim_prefix ? strlen(claim_prefix) : 0;\n\n\t/* get an array representation of the incoming HTTP headers */\n\tconst apr_array_header_t * const h = apr_table_elts(r->headers_in);\n\n\t/* table to keep the non-suspicious headers */\n\tapr_table_t *clean_headers = apr_table_make(r->pool, h->nelts);\n\n\t/* loop over the incoming HTTP headers */\n\tconst apr_table_entry_t * const e = (const apr_table_entry_t *) h->elts;\n\tint i;\n\tfor (i = 0; i < h->nelts; i++) {\n\t\tconst char * const k = e[i].key;\n\n\t\t/* is this header's name equivalent to the header that mod_auth_openidc would set for the authenticated user? */\n\t\tconst int authn_header_matches = (k != NULL) && authn_header\n\t\t\t\t&& (oidc_strnenvcmp(k, authn_header, -1) == 0);\n\n\t\t/*\n\t\t * would this header be interpreted as a mod_auth_openidc attribute? Note\n\t\t * that prefix_len will be zero if no attr_prefix is defined,\n\t\t * so this will always be false. Also note that we do not\n\t\t * scrub headers if the prefix is empty because every header\n\t\t * would match.\n\t\t */\n\t\tconst int prefix_matches = (k != NULL) && prefix_len\n\t\t\t\t&& (oidc_strnenvcmp(k, claim_prefix, prefix_len) == 0);\n\n\t\t/* add to the clean_headers if non-suspicious, skip and report otherwise */\n\t\tif (!prefix_matches && !authn_header_matches) {\n\t\t\tapr_table_addn(clean_headers, k, e[i].val);\n\t\t} else {\n\t\t\toidc_warn(r, \"scrubbed suspicious request header (%s: %.32s)\", k,\n\t\t\t\t\te[i].val);\n\t\t}\n\t}\n\n\t/* overwrite the incoming headers with the cleaned result */\n\tr->headers_in = clean_headers;\n}\n\n/*\n * strip the session cookie from the headers sent to the application/backend\n */\nstatic void oidc_strip_cookies(request_rec *r) {\n\n\tchar *cookie, *ctx, *result = NULL;\n\tconst char *name = NULL;\n\tint i;\n\n\tapr_array_header_t *strip = oidc_dir_cfg_strip_cookies(r);\n\n\tchar *cookies = apr_pstrdup(r->pool,\n\t\t\t(char *) apr_table_get(r->headers_in, \"Cookie\"));\n\n\tif ((cookies != NULL) && (strip != NULL)) {\n\n\t\toidc_debug(r,\n\t\t\t\t\"looking for the following cookies to strip from cookie header: %s\",\n\t\t\t\tapr_array_pstrcat(r->pool, strip, ','));\n\n\t\tcookie = apr_strtok(cookies, \";\", &ctx);\n\n\t\tdo {\n\t\t\twhile (cookie != NULL && *cookie == ' ')\n\t\t\t\tcookie++;\n\n\t\t\tfor (i = 0; i < strip->nelts; i++) {\n\t\t\t\tname = ((const char**) strip->elts)[i];\n\t\t\t\tif ((strncmp(cookie, name, strlen(name)) == 0)\n\t\t\t\t\t\t&& (cookie[strlen(name)] == '=')) {\n\t\t\t\t\toidc_debug(r, \"stripping: %s\", name);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i == strip->nelts) {\n\t\t\t\tresult =\n\t\t\t\t\t\tresult ?\n\t\t\t\t\t\t\t\tapr_psprintf(r->pool, \"%s;%s\", result, cookie) :\n\t\t\t\t\t\t\t\tcookie;\n\t\t\t}\n\n\t\t\tcookie = apr_strtok(NULL, \";\", &ctx);\n\t\t} while (cookie != NULL);\n\n\t\tif (result != NULL) {\n\t\t\toidc_debug(r, \"set cookie to backend to: %s\",\n\t\t\t\t\tresult ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \"\\\"%s\\\"\", result) : \"<null>\");\n\t\t\tapr_table_set(r->headers_in, \"Cookie\", result);\n\t\t} else {\n\t\t\toidc_debug(r, \"unsetting all cookies to backend\");\n\t\t\tapr_table_unset(r->headers_in, \"Cookie\");\n\t\t}\n\n\t}\n}\n\n#define OIDC_SHA1_LEN 20\n\n/*\n * calculates a hash value based on request fingerprint plus a provided nonce string.\n */\nstatic char *oidc_get_browser_state_hash(request_rec *r, const char *nonce) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* helper to hold to header values */\n\tconst char *value = NULL;\n\t/* the hash context */\n\tapr_sha1_ctx_t sha1;\n\n\t/* Initialize the hash context */\n\tapr_sha1_init(&sha1);\n\n\t/* get the X_FORWARDED_FOR header value  */\n\tvalue = (char *) apr_table_get(r->headers_in, \"X_FORWARDED_FOR\");\n\t/* if we have a value for this header, concat it to the hash input */\n\tif (value != NULL)\n\t\tapr_sha1_update(&sha1, value, strlen(value));\n\n\t/* get the USER_AGENT header value  */\n\tvalue = (char *) apr_table_get(r->headers_in, \"USER_AGENT\");\n\t/* if we have a value for this header, concat it to the hash input */\n\tif (value != NULL)\n\t\tapr_sha1_update(&sha1, value, strlen(value));\n\n\t/* get the remote client IP address or host name */\n\t/*\n\tint remotehost_is_ip;\n\tvalue = ap_get_remote_host(r->connection, r->per_dir_config,\n\t\t\tREMOTE_NOLOOKUP, &remotehost_is_ip);\n\tapr_sha1_update(&sha1, value, strlen(value));\n\t*/\n\n\t/* concat the nonce parameter to the hash input */\n\tapr_sha1_update(&sha1, nonce, strlen(nonce));\n\n\t/* finalize the hash input and calculate the resulting hash output */\n\tunsigned char hash[OIDC_SHA1_LEN];\n\tapr_sha1_final(hash, &sha1);\n\n\t/* base64url-encode the resulting hash and return it */\n\tchar *result = NULL;\n\toidc_base64url_encode(r, &result, (const char *) hash, OIDC_SHA1_LEN, TRUE);\n\treturn result;\n}\n\n/*\n * return the name for the state cookie\n */\nstatic char *oidc_get_state_cookie_name(request_rec *r, const char *state) {\n\treturn apr_psprintf(r->pool, \"%s%s\", OIDCStateCookiePrefix, state);\n}\n\n/*\n * return the static provider configuration, i.e. from a metadata URL or configuration primitives\n */\nstatic apr_byte_t oidc_provider_static_config(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t **provider) {\n\n\tjson_t *j_provider = NULL;\n\tconst char *s_json = NULL;\n\n\t/* see if we should configure a static provider based on external (cached) metadata */\n\tif ((c->metadata_dir != NULL) || (c->provider.metadata_url == NULL)) {\n\t\t*provider = &c->provider;\n\t\treturn TRUE;\n\t}\n\n\tc->cache->get(r, OIDC_CACHE_SECTION_PROVIDER,\n\t\t\toidc_util_escape_string(r, c->provider.metadata_url), &s_json);\n\n\tif (s_json == NULL) {\n\n\t\tif (oidc_metadata_provider_retrieve(r, c, NULL,\n\t\t\t\tc->provider.metadata_url, &j_provider, &s_json) == FALSE) {\n\t\t\toidc_error(r, \"could not retrieve metadata from url: %s\",\n\t\t\t\t\tc->provider.metadata_url);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tc->cache->set(r, OIDC_CACHE_SECTION_PROVIDER,\n\t\t\t\toidc_util_escape_string(r, c->provider.metadata_url), s_json,\n\t\t\t\tapr_time_now()\n\t\t\t\t+ (c->provider_metadata_refresh_interval <= 0 ?\n\t\t\t\t\t\tapr_time_from_sec(\n\t\t\t\t\t\t\t\tOIDC_CACHE_PROVIDER_METADATA_EXPIRY_DEFAULT) :\n\t\t\t\t\t\t\t\tc->provider_metadata_refresh_interval));\n\n\t} else {\n\n\t\t/* correct parsing and validation was already done when it was put in the cache */\n\t\tj_provider = json_loads(s_json, 0, 0);\n\t}\n\n\t*provider = apr_pcalloc(r->pool, sizeof(oidc_provider_t));\n\tmemcpy(*provider, &c->provider, sizeof(oidc_provider_t));\n\n\tif (oidc_metadata_provider_parse(r, c, j_provider, *provider) == FALSE) {\n\t\toidc_error(r, \"could not parse metadata from url: %s\",\n\t\t\t\tc->provider.metadata_url);\n\t\tif (j_provider)\n\t\t\tjson_decref(j_provider);\n\t\treturn FALSE;\n\t}\n\n\tjson_decref(j_provider);\n\n\treturn TRUE;\n}\n\n/*\n * return the oidc_provider_t struct for the specified issuer\n */\nstatic oidc_provider_t *oidc_get_provider_for_issuer(request_rec *r,\n\t\toidc_cfg *c, const char *issuer, apr_byte_t allow_discovery) {\n\n\t/* by default we'll assume that we're dealing with a single statically configured OP */\n\toidc_provider_t *provider = NULL;\n\tif (oidc_provider_static_config(r, c, &provider) == FALSE)\n\t\treturn NULL;\n\n\t/* unless a metadata directory was configured, so we'll try and get the provider settings from there */\n\tif (c->metadata_dir != NULL) {\n\n\t\t/* try and get metadata from the metadata directory for the OP that sent this response */\n\t\tif ((oidc_metadata_get(r, c, issuer, &provider, allow_discovery)\n\t\t\t\t== FALSE) || (provider == NULL)) {\n\n\t\t\t/* don't know nothing about this OP/issuer */\n\t\t\toidc_error(r, \"no provider metadata found for issuer \\\"%s\\\"\",\n\t\t\t\t\tissuer);\n\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn provider;\n}\n\n/*\n * find out whether the request is a response from an IDP discovery page\n */\nstatic apr_byte_t oidc_is_discovery_response(request_rec *r, oidc_cfg *cfg) {\n\t/*\n\t * prereq: this is a call to the configured redirect_uri, now see if:\n\t * the OIDC_DISC_OP_PARAM is present\n\t */\n\treturn oidc_util_request_has_parameter(r, OIDC_DISC_OP_PARAM)\n\t\t\t|| oidc_util_request_has_parameter(r, OIDC_DISC_USER_PARAM);\n}\n\n/*\n * return the HTTP method being called: only for POST data persistence purposes\n */\nstatic const char *oidc_original_request_method(request_rec *r, oidc_cfg *cfg,\n\t\tapr_byte_t handle_discovery_response) {\n\tconst char *method = OIDC_METHOD_GET;\n\n\tchar *m = NULL;\n\tif ((handle_discovery_response == TRUE)\n\t\t\t&& (oidc_util_request_matches_url(r, cfg->redirect_uri))\n\t\t\t&& (oidc_is_discovery_response(r, cfg))) {\n\t\toidc_util_get_request_parameter(r, OIDC_DISC_RM_PARAM, &m);\n\t\tif (m != NULL)\n\t\t\tmethod = apr_pstrdup(r->pool, m);\n\t} else {\n\n\t\t/*\n\t\t * if POST preserve is not enabled for this location, there's no point in preserving\n\t\t * the method either which would result in POSTing empty data on return;\n\t\t * so we revert to legacy behavior\n\t\t */\n\t\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\t\treturn OIDC_METHOD_GET;\n\n\t\tconst char *content_type = apr_table_get(r->headers_in, \"Content-Type\");\n\t\tif ((r->method_number == M_POST)\n\t\t\t\t&& (apr_strnatcmp(content_type,\n\t\t\t\t\t\t\"application/x-www-form-urlencoded\") == 0))\n\t\t\tmethod = OIDC_METHOD_FORM_POST;\n\t}\n\n\toidc_debug(r, \"return: %s\", method);\n\n\treturn method;\n}\n\n/*\n * send an OpenID Connect authorization request to the specified provider preserving POST parameters using HTML5 storage\n */\napr_byte_t oidc_post_preserve_javascript(request_rec *r, const char *location,\n\t\tchar **javascript, char **javascript_method) {\n\n\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\treturn FALSE;\n\n\toidc_debug(r, \"enter\");\n\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\n\tif (apr_strnatcmp(method, OIDC_METHOD_FORM_POST) != 0)\n\t\treturn FALSE;\n\n\t/* read the parameters that are POST-ed to us */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params) == FALSE) {\n\t\toidc_error(r, \"something went wrong when reading the POST parameters\");\n\t\treturn FALSE;\n\t}\n\n\tconst apr_array_header_t *arr = apr_table_elts(params);\n\tconst apr_table_entry_t *elts = (const apr_table_entry_t*) arr->elts;\n\tint i;\n\tchar *json = \"\";\n\tfor (i = 0; i < arr->nelts; i++) {\n\t\tjson = apr_psprintf(r->pool, \"%s'%s': '%s'%s\", json,\n\t\t\t\toidc_util_escape_string(r, elts[i].key),\n\t\t\t\toidc_util_escape_string(r, elts[i].val),\n\t\t\t\ti < arr->nelts - 1 ? \",\" : \"\");\n\t}\n\tjson = apr_psprintf(r->pool, \"{ %s }\", json);\n\n\tconst char *jmethod = \"preserveOnLoad\";\n\tconst char *jscript =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        localStorage.setItem('mod_auth_openidc_preserve_post_params', JSON.stringify(%s));\\n\"\n\t\t\t\t\t\"        %s\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", jmethod, json,\n\t\t\t\t\tlocation ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \"window.location='%s';\\n\",\n\t\t\t\t\t\t\t\t\tlocation) :\n\t\t\t\t\t\t\t\t\t\"\");\n\tif (location == NULL) {\n\t\tif (javascript_method)\n\t\t\t*javascript_method = apr_pstrdup(r->pool, jmethod);\n\t\tif (javascript)\n\t\t\t*javascript = apr_pstrdup(r->pool, jscript);\n\t} else {\n\t\toidc_util_html_send(r, \"Preserving...\", jscript, jmethod,\n\t\t\t\t\"<p>Preserving...</p>\", DONE);\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * restore POST parameters on original_url from HTML5 local storage\n */\nstatic int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(localStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t localStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = decodeURIComponent(key);\\n\"\n\t\t\t\t\t\"          input.value = decodeURIComponent(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = '%s';\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, original_url);\n\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tDONE);\n}\n\n/*\n * parse state that was sent to us by the issuer\n */\nstatic apr_byte_t oidc_unsolicited_proto_state(request_rec *r, oidc_cfg *c,\n\t\tconst char *state, json_t **proto_state) {\n\n\tchar *alg = NULL;\n\toidc_debug(r, \"enter: state header=%s\",\n\t\t\toidc_proto_peek_jwt_header(r, state, &alg));\n\n\toidc_jose_error_t err;\n\toidc_jwk_t *jwk = NULL;\n\tif (oidc_util_create_symmetric_key(r, c->provider.client_secret,\n\t\t\toidc_alg2keysize(alg), \"sha256\",\n\t\t\tTRUE, &jwk) == FALSE)\n\t\treturn FALSE;\n\n\toidc_jwt_t *jwt = NULL;\n\tif (oidc_jwt_parse(r->pool, state, &jwt,\n\t\t\toidc_util_merge_symmetric_key(r->pool, c->private_keys, jwk),\n\t\t\t&err) == FALSE) {\n\t\toidc_error(r,\n\t\t\t\t\"could not parse JWT from state: invalid unsolicited response: %s\",\n\t\t\t\toidc_jose_e2s(r->pool, err));\n\t\treturn FALSE;\n\t}\n\n\toidc_jwk_destroy(jwk);\n\toidc_debug(r, \"successfully parsed JWT from state\");\n\n\tif (jwt->payload.iss == NULL) {\n\t\toidc_error(r, \"no \\\"iss\\\" could be retrieved from JWT state, aborting\");\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\toidc_provider_t *provider = oidc_get_provider_for_issuer(r, c,\n\t\t\tjwt->payload.iss, FALSE);\n\tif (provider == NULL) {\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\t/* validate the state JWT, validating optional exp + iat */\n\tif (oidc_proto_validate_jwt(r, jwt, provider->issuer, FALSE, FALSE,\n\t\t\tprovider->idtoken_iat_slack) == FALSE) {\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\tchar *rfp = NULL;\n\tif (oidc_jose_get_string(r->pool, jwt->payload.value.json, \"rfp\", TRUE,\n\t\t\t&rfp, &err) == FALSE) {\n\t\toidc_error(r,\n\t\t\t\t\"no \\\"rfp\\\" claim could be retrieved from JWT state, aborting: %s\",\n\t\t\t\toidc_jose_e2s(r->pool, err));\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\tif (apr_strnatcmp(rfp, \"iss\") != 0) {\n\t\toidc_error(r, \"\\\"rfp\\\" (%s) does not match \\\"iss\\\", aborting\", rfp);\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\tchar *target_link_uri = NULL;\n\toidc_jose_get_string(r->pool, jwt->payload.value.json, \"target_link_uri\",\n\t\t\tFALSE, &target_link_uri, NULL);\n\tif (target_link_uri == NULL) {\n\t\tif (c->default_sso_url == NULL) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"no \\\"target_link_uri\\\" claim could be retrieved from JWT state and no OIDCDefaultURL is set, aborting\");\n\t\t\toidc_jwt_destroy(jwt);\n\t\t\treturn FALSE;\n\t\t}\n\t\ttarget_link_uri = c->default_sso_url;\n\t}\n\n\tif (c->metadata_dir != NULL) {\n\t\tif ((oidc_metadata_get(r, c, jwt->payload.iss, &provider, FALSE)\n\t\t\t\t== FALSE) || (provider == NULL)) {\n\t\t\toidc_error(r, \"no provider metadata found for provider \\\"%s\\\"\",\n\t\t\t\t\tjwt->payload.iss);\n\t\t\toidc_jwt_destroy(jwt);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tchar *jti = NULL;\n\toidc_jose_get_string(r->pool, jwt->payload.value.json, \"jti\", FALSE, &jti,\n\t\t\tNULL);\n\tif (jti == NULL) {\n\t\tchar *cser = oidc_jwt_serialize(r->pool, jwt, &err);\n\t\tif (cser == NULL)\n\t\t\treturn FALSE;\n\t\tif (oidc_util_hash_string_and_base64url_encode(r, \"sha256\", cser,\n\t\t\t\t&jti) == FALSE) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"oidc_util_hash_string_and_base64url_encode returned an error\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tconst char *replay = NULL;\n\tc->cache->get(r, OIDC_CACHE_SECTION_JTI, jti, &replay);\n\tif (replay != NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"the jti value (%s) passed in the browser state was found in the cache already; possible replay attack!?\",\n\t\t\t\tjti);\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\t/* jti cache duration is the configured replay prevention window for token issuance plus 10 seconds for safety */\n\tapr_time_t jti_cache_duration = apr_time_from_sec(\n\t\t\tprovider->idtoken_iat_slack * 2 + 10);\n\n\t/* store it in the cache for the calculated duration */\n\tc->cache->set(r, OIDC_CACHE_SECTION_JTI, jti, jti,\n\t\t\tapr_time_now() + jti_cache_duration);\n\n\toidc_debug(r,\n\t\t\t\"jti \\\"%s\\\" validated successfully and is now cached for %\" APR_TIME_T_FMT \" seconds\",\n\t\t\tjti, apr_time_sec(jti_cache_duration));\n\n\tjwk = NULL;\n\tif (oidc_util_create_symmetric_key(r, c->provider.client_secret, 0,\n\t\t\tNULL, TRUE, &jwk) == FALSE)\n\t\treturn FALSE;\n\n\toidc_jwks_uri_t jwks_uri = { provider->jwks_uri,\n\t\t\tprovider->jwks_refresh_interval, provider->ssl_validate_server };\n\tif (oidc_proto_jwt_verify(r, c, jwt, &jwks_uri,\n\t\t\toidc_util_merge_symmetric_key(r->pool, NULL, jwk)) == FALSE) {\n\t\toidc_error(r, \"state JWT could not be validated, aborting\");\n\t\toidc_jwt_destroy(jwt);\n\t\treturn FALSE;\n\t}\n\n\toidc_jwk_destroy(jwk);\n\toidc_debug(r, \"successfully verified state JWT\");\n\n\t*proto_state = json_object();\n\tjson_object_set_new(*proto_state, \"issuer\", json_string(jwt->payload.iss));\n\tjson_object_set_new(*proto_state, \"original_url\",\n\t\t\tjson_string(target_link_uri));\n\tjson_object_set_new(*proto_state, \"original_method\", json_string(\"get\"));\n\tjson_object_set_new(*proto_state, \"response_mode\",\n\t\t\tjson_string(provider->response_mode));\n\tjson_object_set_new(*proto_state, \"response_type\",\n\t\t\tjson_string(provider->response_type));\n\tjson_object_set_new(*proto_state, \"timestamp\",\n\t\t\tjson_integer(apr_time_sec(apr_time_now())));\n\n\toidc_jwt_destroy(jwt);\n\n\treturn TRUE;\n}\n\n/* obtain the state from the cookie value */\nstatic json_t * oidc_get_state_from_cookie(request_rec *r, oidc_cfg *c,\n\t\tconst char *cookieValue) {\n\tjson_t *result = NULL;\n\toidc_util_jwt_verify(r, c->crypto_passphrase, cookieValue, &result);\n\treturn result;\n}\n\nstatic void oidc_clean_expired_state_cookies(request_rec *r, oidc_cfg *c) {\n\tchar *cookie, *tokenizerCtx;\n\tchar *cookies = apr_pstrdup(r->pool,\n\t\t\t(char *) apr_table_get(r->headers_in, \"Cookie\"));\n\tif (cookies != NULL) {\n\t\tcookie = apr_strtok(cookies, \";\", &tokenizerCtx);\n\t\tdo {\n\t\t\twhile (cookie != NULL && *cookie == ' ')\n\t\t\t\tcookie++;\n\t\t\tif (strstr(cookie, OIDCStateCookiePrefix) == cookie) {\n\t\t\t\tchar *cookieName = cookie;\n\t\t\t\twhile (cookie != NULL && *cookie != '=')\n\t\t\t\t\tcookie++;\n\t\t\t\tif (*cookie == '=') {\n\t\t\t\t\t*cookie = '\\0';\n\t\t\t\t\tcookie++;\n\t\t\t\t\tjson_t *state = oidc_get_state_from_cookie(r, c, cookie);\n\t\t\t\t\tif (state != NULL) {\n\t\t\t\t\t\tjson_t *v = json_object_get(state, \"timestamp\");\n\t\t\t\t\t\tapr_time_t now = apr_time_sec(apr_time_now());\n\t\t\t\t\t\tif (now > json_integer_value(v) + c->state_timeout) {\n\t\t\t\t\t\t\toidc_error(r, \"state has expired\");\n\t\t\t\t\t\t\toidc_util_set_cookie(r, cookieName, \"\", 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjson_decref(state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcookie = apr_strtok(NULL, \";\", &tokenizerCtx);\n\t\t} while (cookie != NULL);\n\t}\n}\n\n/*\n * restore the state that was maintained between authorization request and response in an encrypted cookie\n */\nstatic apr_byte_t oidc_restore_proto_state(request_rec *r, oidc_cfg *c,\n\t\tconst char *state, json_t **proto_state) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* clean expired state cookies to avoid pollution */\n\toidc_clean_expired_state_cookies(r, c);\n\n\tconst char *cookieName = oidc_get_state_cookie_name(r, state);\n\n\t/* get the state cookie value first */\n\tchar *cookieValue = oidc_util_get_cookie(r, cookieName);\n\tif (cookieValue == NULL) {\n\t\toidc_error(r, \"no \\\"%s\\\" state cookie found\", cookieName);\n\t\treturn oidc_unsolicited_proto_state(r, c, state, proto_state);\n\t}\n\n\t/* clear state cookie because we don't need it anymore */\n\toidc_util_set_cookie(r, cookieName, \"\", 0);\n\n\t*proto_state = oidc_get_state_from_cookie(r, c, cookieValue);\n\tif (*proto_state == NULL)\n\t\treturn FALSE;\n\n\tjson_t *v = json_object_get(*proto_state, \"nonce\");\n\n\t/* calculate the hash of the browser fingerprint concatenated with the nonce */\n\tchar *calc = oidc_get_browser_state_hash(r, json_string_value(v));\n\t/* compare the calculated hash with the value provided in the authorization response */\n\tif (apr_strnatcmp(calc, state) != 0) {\n\t\toidc_error(r,\n\t\t\t\t\"calculated state from cookie does not match state parameter passed back in URL: \\\"%s\\\" != \\\"%s\\\"\",\n\t\t\t\tstate, calc);\n\t\tjson_decref(*proto_state);\n\t\treturn FALSE;\n\t}\n\n\tv = json_object_get(*proto_state, \"timestamp\");\n\tapr_time_t now = apr_time_sec(apr_time_now());\n\n\t/* check that the timestamp is not beyond the valid interval */\n\tif (now > json_integer_value(v) + c->state_timeout) {\n\t\toidc_error(r, \"state has expired\");\n\t\tjson_decref(*proto_state);\n\t\treturn FALSE;\n\t}\n\n\t/* add the state */\n\tjson_object_set_new(*proto_state, \"state\", json_string(state));\n\n\tchar *s_value = json_dumps(*proto_state, JSON_ENCODE_ANY);\n\toidc_debug(r, \"restored state: %s\", s_value);\n\tfree(s_value);\n\n\t/* we've made it */\n\treturn TRUE;\n}\n\n/*\n * set the state that is maintained between an authorization request and an authorization response\n * in a cookie in the browser that is cryptographically bound to that state\n */\nstatic apr_byte_t oidc_authorization_request_set_cookie(request_rec *r,\n\t\toidc_cfg *c, const char *state, json_t *proto_state) {\n\t/*\n\t * create a cookie consisting of 8 elements:\n\t * random value, original URL, original method, issuer, response_type, response_mod, prompt and timestamp\n\t * encoded as JSON\n\t */\n\n\t/* encrypt the resulting JSON value  */\n\tchar *cookieValue = NULL;\n\n\tif (oidc_util_jwt_create(r, c->crypto_passphrase, proto_state,\n\t\t\t&cookieValue) == FALSE)\n\t\treturn FALSE;\n\n\t/* clean expired state cookies to avoid pollution */\n\toidc_clean_expired_state_cookies(r, c);\n\n\t/* assemble the cookie name for the state cookie */\n\tconst char *cookieName = oidc_get_state_cookie_name(r, state);\n\n\t/* set it as a cookie */\n\toidc_util_set_cookie(r, cookieName, cookieValue, -1);\n\n\t//free(s_value);\n\n\treturn TRUE;\n}\n\n/*\n * get the mod_auth_openidc related context from the (userdata in the) request\n * (used for passing state between various Apache request processing stages and hook callbacks)\n */\nstatic apr_table_t *oidc_request_state(request_rec *rr) {\n\n\t/* our state is always stored in the main request */\n\trequest_rec *r = (rr->main != NULL) ? rr->main : rr;\n\n\t/* our state is a table, get it */\n\tapr_table_t *state = NULL;\n\tapr_pool_userdata_get((void **) &state, OIDC_USERDATA_KEY, r->pool);\n\n\t/* if it does not exist, we'll create a new table */\n\tif (state == NULL) {\n\t\tstate = apr_table_make(r->pool, 5);\n\t\tapr_pool_userdata_set(state, OIDC_USERDATA_KEY, NULL, r->pool);\n\t}\n\n\t/* return the resulting table, always non-null now */\n\treturn state;\n}\n\n/*\n * set a name/value pair in the mod_auth_openidc-specific request context\n * (used for passing state between various Apache request processing stages and hook callbacks)\n */\nvoid oidc_request_state_set(request_rec *r, const char *key, const char *value) {\n\n\t/* get a handle to the global state, which is a table */\n\tapr_table_t *state = oidc_request_state(r);\n\n\t/* put the name/value pair in that table */\n\tapr_table_setn(state, key, value);\n}\n\n/*\n * get a name/value pair from the mod_auth_openidc-specific request context\n * (used for passing state between various Apache request processing stages and hook callbacks)\n */\nconst char*oidc_request_state_get(request_rec *r, const char *key) {\n\n\t/* get a handle to the global state, which is a table */\n\tapr_table_t *state = oidc_request_state(r);\n\n\t/* return the value from the table */\n\treturn apr_table_get(state, key);\n}\n\n/*\n * set the claims from a JSON object (c.q. id_token or user_info response) stored\n * in the session in to HTTP headers passed on to the application\n */\nstatic apr_byte_t oidc_set_app_claims(request_rec *r,\n\t\tconst oidc_cfg * const cfg, oidc_session_t *session,\n\t\tconst char *s_claims) {\n\n\tjson_t *j_claims = NULL;\n\n\t/* decode the string-encoded attributes in to a JSON structure */\n\tif (s_claims != NULL) {\n\t\tjson_error_t json_error;\n\t\tj_claims = json_loads(s_claims, 0, &json_error);\n\n\t\tif (j_claims == NULL) {\n\t\t\t/* whoops, JSON has been corrupted */\n\t\t\toidc_error(r,\n\t\t\t\t\t\"unable to parse \\\"%s\\\" JSON stored in the session: %s\",\n\t\t\t\t\ts_claims, json_error.text);\n\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/* set the resolved claims a HTTP headers for the application */\n\tif (j_claims != NULL) {\n\t\toidc_util_set_app_infos(r, j_claims, cfg->claim_prefix,\n\t\t\t\tcfg->claim_delimiter, oidc_cfg_dir_pass_info_in_headers(r),\n\t\t\t\toidc_cfg_dir_pass_info_in_envvars(r));\n\n\t\t/* release resources */\n\t\tjson_decref(j_claims);\n\t}\n\n\treturn TRUE;\n}\n\nstatic int oidc_authenticate_user(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t *provider, const char *original_url,\n\t\tconst char *login_hint, const char *id_token_hint, const char *prompt,\n\t\tconst char *auth_request_params);\n\n/*\n * log message about max session duration\n */\nstatic void oidc_log_session_expires(request_rec *r, apr_time_t session_expires) {\n\tchar buf[APR_RFC822_DATE_LEN + 1];\n\tapr_rfc822_date(buf, session_expires);\n\toidc_debug(r, \"session expires %s (in %\" APR_TIME_T_FMT \" secs from now)\",\n\t\t\tbuf, apr_time_sec(session_expires - apr_time_now()));\n}\n\n/*\n * check if maximum session duration was exceeded\n */\nstatic int oidc_check_max_session_duration(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session) {\n\tconst char *s_session_expires = NULL;\n\tapr_time_t session_expires;\n\n\t/* get the session expiry from the session data */\n\toidc_session_get(r, session, OIDC_SESSION_EXPIRES_SESSION_KEY,\n\t\t\t&s_session_expires);\n\n\t/* convert the string to a timestamp */\n\tsscanf(s_session_expires, \"%\" APR_TIME_T_FMT, &session_expires);\n\n\t/* check the expire timestamp against the current time */\n\tif (apr_time_now() > session_expires) {\n\t\toidc_warn(r, \"maximum session duration exceeded for user: %s\",\n\t\t\t\tsession->remote_user);\n\t\toidc_session_kill(r, session);\n\t\treturn oidc_authenticate_user(r, cfg, NULL, oidc_get_current_url(r),\n\t\t\t\tNULL,\n\t\t\t\tNULL, NULL, NULL);\n\t}\n\n\t/* log message about max session duration */\n\toidc_log_session_expires(r, session_expires);\n\n\treturn OK;\n}\n\n/*\n * validate received session cookie against the domain it was issued for:\n *\n * this handles the case where the cache configured is a the same single memcache, Redis, or file\n * backend for different (virtual) hosts, or a client-side cookie protected with the same secret\n *\n * it also handles the case that a cookie is unexpectedly shared across multiple hosts in\n * name-based virtual hosting even though the OP(s) would be the same\n */\nstatic apr_byte_t oidc_check_cookie_domain(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session) {\n\tconst char *c_cookie_domain =\n\t\t\tcfg->cookie_domain ?\n\t\t\t\t\tcfg->cookie_domain : oidc_get_current_url_host(r);\n\tconst char *s_cookie_domain = NULL;\n\toidc_session_get(r, session, OIDC_COOKIE_DOMAIN_SESSION_KEY,\n\t\t\t&s_cookie_domain);\n\tif ((s_cookie_domain == NULL)\n\t\t\t|| (apr_strnatcmp(c_cookie_domain, s_cookie_domain) != 0)) {\n\t\toidc_warn(r,\n\t\t\t\t\"aborting: detected attempt to play cookie against a different domain/host than issued for! (issued=%s, current=%s)\",\n\t\t\t\ts_cookie_domain, c_cookie_domain);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\n/*\n * get a handle to the provider configuration via the \"issuer\" stored in the session\n */\napr_byte_t oidc_get_provider_from_session(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, oidc_provider_t **provider) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* get the issuer value from the session state */\n\tconst char *issuer = NULL;\n\toidc_session_get(r, session, OIDC_ISSUER_SESSION_KEY, &issuer);\n\tif (issuer == NULL) {\n\t\toidc_error(r, \"session corrupted: no issuer found in session\");\n\t\treturn FALSE;\n\t}\n\n\t/* get the provider info associated with the issuer value */\n\toidc_provider_t *p = oidc_get_provider_for_issuer(r, c, issuer, FALSE);\n\tif (p == NULL) {\n\t\toidc_error(r, \"session corrupted: no provider found for issuer: %s\",\n\t\t\t\tissuer);\n\t\treturn FALSE;\n\t}\n\n\t*provider = p;\n\n\treturn TRUE;\n}\n\n/*\n * store the access token expiry timestamp in the session, based on the expires_in\n */\nstatic void oidc_store_access_token_expiry(request_rec *r,\n\t\toidc_session_t *session, int expires_in) {\n\tif (expires_in != -1) {\n\t\toidc_session_set(r, session, OIDC_ACCESSTOKEN_EXPIRES_SESSION_KEY,\n\t\t\t\tapr_psprintf(r->pool, \"%\" APR_TIME_T_FMT,\n\t\t\t\t\t\tapr_time_sec(apr_time_now()) + expires_in));\n\t}\n}\n\n/*\n * store claims resolved from the userinfo endpoint in the session\n */\nstatic void oidc_store_userinfo_claims(request_rec *r, oidc_session_t *session,\n\t\toidc_provider_t *provider, const char *claims) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* see if we've resolved any claims */\n\tif (claims != NULL) {\n\t\t/*\n\t\t * Successfully decoded a set claims from the response so we can store them\n\t\t * (well actually the stringified representation in the response)\n\t\t * in the session context safely now\n\t\t */\n\t\toidc_session_set(r, session, OIDC_CLAIMS_SESSION_KEY, claims);\n\n\t} else {\n\t\t/*\n\t\t * clear the existing claims because we could not refresh them\n\t\t */\n\t\toidc_session_set(r, session, OIDC_CLAIMS_SESSION_KEY, NULL);\n\n\t}\n\n\t/* store the last refresh time if we've configured a userinfo refresh interval */\n\tif (provider->userinfo_refresh_interval > 0)\n\t\toidc_session_set(r, session, OIDC_USERINFO_LAST_REFRESH_SESSION_KEY,\n\t\t\t\tapr_psprintf(r->pool, \"%\" APR_TIME_T_FMT, apr_time_now()));\n}\n\n/*\n * execute refresh token grant to refresh the existing access token\n */\nstatic apr_byte_t oidc_refresh_access_token(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, oidc_provider_t *provider,\n\t\tchar **new_access_token) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* get the refresh token that was stored in the session */\n\tconst char *refresh_token = NULL;\n\toidc_session_get(r, session, OIDC_REFRESHTOKEN_SESSION_KEY, &refresh_token);\n\tif (refresh_token == NULL) {\n\t\toidc_warn(r,\n\t\t\t\t\"refresh token routine called but no refresh_token found in the session\");\n\t\treturn FALSE;\n\t}\n\n\t/* elements returned in the refresh response */\n\tchar *s_id_token = NULL;\n\tint expires_in = -1;\n\tchar *s_token_type = NULL;\n\tchar *s_access_token = NULL;\n\tchar *s_refresh_token = NULL;\n\n\t/* refresh the tokens by calling the token endpoint */\n\tif (oidc_proto_refresh_request(r, c, provider, refresh_token, &s_id_token,\n\t\t\t&s_access_token, &s_token_type, &expires_in,\n\t\t\t&s_refresh_token) == FALSE) {\n\t\toidc_error(r, \"access_token could not be refreshed\");\n\t\treturn FALSE;\n\t}\n\n\t/* store the new access_token in the session and discard the old one */\n\toidc_session_set(r, session, OIDC_ACCESSTOKEN_SESSION_KEY, s_access_token);\n\toidc_store_access_token_expiry(r, session, expires_in);\n\n\t/* see if we need to return it as a parameter */\n\tif (new_access_token != NULL)\n\t\t*new_access_token = s_access_token;\n\n\t/* if we have a new refresh token (rolling refresh), store it in the session and overwrite the old one */\n\tif (s_refresh_token != NULL)\n\t\toidc_session_set(r, session, OIDC_REFRESHTOKEN_SESSION_KEY,\n\t\t\t\ts_refresh_token);\n\n\treturn TRUE;\n}\n\n/*\n * retrieve claims from the userinfo endpoint and return the stringified response\n */\nstatic const char *oidc_retrieve_claims_from_userinfo_endpoint(request_rec *r,\n\t\toidc_cfg *c, oidc_provider_t *provider, const char *access_token,\n\t\toidc_session_t *session, char *id_token_sub) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* see if a userinfo endpoint is set, otherwise there's nothing to do for us */\n\tif (provider->userinfo_endpoint_url == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"not retrieving userinfo claims because userinfo_endpoint is not set\");\n\t\treturn NULL;\n\t}\n\n\t/* see if there's an access token, otherwise we can't call the userinfo endpoint at all */\n\tif (access_token == NULL) {\n\t\toidc_debug(r,\n\t\t\t\t\"not retrieving userinfo claims because access_token is not provided\");\n\t\treturn NULL;\n\t}\n\n\tif ((id_token_sub == NULL) && (session != NULL)) {\n\n\t\t// when refreshing claims from the userinfo endpoint\n\n\t\tconst char *s_id_token_claims = NULL;\n\t\toidc_session_get(r, session, OIDC_IDTOKEN_CLAIMS_SESSION_KEY,\n\t\t\t\t&s_id_token_claims);\n\n\t\tif (s_id_token_claims == NULL) {\n\t\t\toidc_error(r, \"no id_token claims provided\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tjson_error_t json_error;\n\t\tjson_t *id_token_claims = json_loads(s_id_token_claims, 0, &json_error);\n\n\t\tif (id_token_claims == NULL) {\n\t\t\toidc_error(r, \"JSON parsing (json_loads) failed: %s (%s)\",\n\t\t\t\t\tjson_error.text, s_id_token_claims);\n\t\t\treturn NULL;\n\t\t}\n\n\t\toidc_jose_get_string(r->pool, id_token_claims, \"sub\", FALSE, &id_token_sub, NULL);\n\t}\n\n\t// TODO: return code should indicate whether the token expired or some other error occurred\n\t// TODO: long-term: session storage should be JSON (with explicit types and less conversion, using standard routines)\n\n\t/* try to get claims from the userinfo endpoint using the provided access token */\n\tconst char *result = NULL;\n\tif (oidc_proto_resolve_userinfo(r, c, provider, id_token_sub, access_token,\n\t\t\t&result) == FALSE) {\n\n\t\t/* see if we have an existing session and we are refreshing the user info claims */\n\t\tif (session != NULL) {\n\n\t\t\t/* first call to user info endpoint failed, but the access token may have just expired, so refresh it */\n\t\t\tchar *access_token = NULL;\n\t\t\tif (oidc_refresh_access_token(r, c, session, provider,\n\t\t\t\t\t&access_token) == TRUE) {\n\n\t\t\t\t/* try again with the new access token */\n\t\t\t\tif (oidc_proto_resolve_userinfo(r, c, provider, id_token_sub, access_token,\n\t\t\t\t\t\t&result) == FALSE) {\n\n\t\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\t\"resolving user info claims with the refreshed access token failed, nothing will be stored in the session\");\n\t\t\t\t\tresult = NULL;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\toidc_warn(r,\n\t\t\t\t\t\t\"refreshing access token failed, claims will not be retrieved/refreshed from the userinfo endpoint\");\n\t\t\t\tresult = NULL;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\toidc_error(r,\n\t\t\t\t\t\"resolving user info claims with the existing/provided access token failed, nothing will be stored in the session\");\n\t\t\tresult = NULL;\n\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/*\n * get (new) claims from the userinfo endpoint\n */\nstatic apr_byte_t oidc_refresh_claims_from_userinfo_endpoint(request_rec *r,\n\t\toidc_cfg *cfg, oidc_session_t *session) {\n\n\toidc_provider_t *provider = NULL;\n\tconst char *claims = NULL;\n\tchar *access_token = NULL;\n\n\t/* get the current provider info */\n\tif (oidc_get_provider_from_session(r, cfg, session, &provider) == FALSE)\n\t\treturn FALSE;\n\n\t/* see if we can do anything here, i.e. we have a userinfo endpoint and a refresh interval is configured */\n\tapr_time_t interval = apr_time_from_sec(\n\t\t\tprovider->userinfo_refresh_interval);\n\n\toidc_debug(r, \"userinfo_endpoint=%s, interval=%d\",\n\t\t\tprovider->userinfo_endpoint_url,\n\t\t\tprovider->userinfo_refresh_interval);\n\n\tif ((provider->userinfo_endpoint_url != NULL) && (interval > 0)) {\n\n\t\t/* get the last refresh timestamp from the session info */\n\t\tapr_time_t last_refresh = 0;\n\t\tconst char *s_last_refresh = NULL;\n\t\toidc_session_get(r, session, OIDC_USERINFO_LAST_REFRESH_SESSION_KEY,\n\t\t\t\t&s_last_refresh);\n\t\tif (s_last_refresh != NULL) {\n\t\t\tsscanf(s_last_refresh, \"%\" APR_TIME_T_FMT, &last_refresh);\n\t\t}\n\n\t\toidc_debug(r, \"refresh needed in: %\" APR_TIME_T_FMT \" seconds\",\n\t\t\t\tapr_time_sec(last_refresh + interval - apr_time_now()));\n\n\t\t/* see if we need to refresh again */\n\t\tif (last_refresh + interval < apr_time_now()) {\n\n\t\t\t/* get the current access token */\n\t\t\toidc_session_get(r, session, OIDC_ACCESSTOKEN_SESSION_KEY,\n\t\t\t\t\t(const char **) &access_token);\n\n\t\t\t/* retrieve the current claims */\n\t\t\tclaims = oidc_retrieve_claims_from_userinfo_endpoint(r, cfg,\n\t\t\t\t\tprovider, access_token, session, NULL);\n\n\t\t\t/* store claims resolved from userinfo endpoint */\n\t\t\toidc_store_userinfo_claims(r, session, provider, claims);\n\n\t\t\t/* indicated something changed */\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n/*\n * copy the claims and id_token from the session to the request state and optionally return them\n */\nstatic void oidc_copy_tokens_to_request_state(request_rec *r,\n\t\toidc_session_t *session, const char **s_id_token, const char **s_claims) {\n\n\tconst char *id_token = NULL, *claims = NULL;\n\n\toidc_session_get(r, session, OIDC_IDTOKEN_CLAIMS_SESSION_KEY, &id_token);\n\toidc_session_get(r, session, OIDC_CLAIMS_SESSION_KEY, &claims);\n\n\toidc_debug(r, \"id_token=%s claims=%s\", id_token, claims);\n\n\tif (id_token != NULL) {\n\t\toidc_request_state_set(r, OIDC_IDTOKEN_CLAIMS_SESSION_KEY, id_token);\n\t\tif (s_id_token != NULL)\n\t\t\t*s_id_token = id_token;\n\t}\n\n\tif (claims != NULL) {\n\t\toidc_request_state_set(r, OIDC_CLAIMS_SESSION_KEY, claims);\n\t\tif (s_claims != NULL)\n\t\t\t*s_claims = claims;\n\t}\n}\n\n/*\n * handle the case where we have identified an existing authentication session for a user\n */\nstatic int oidc_handle_existing_session(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* get the header name in which the remote user name needs to be passed */\n\tchar *authn_header = oidc_cfg_dir_authn_header(r);\n\tint pass_headers = oidc_cfg_dir_pass_info_in_headers(r);\n\tint pass_envvars = oidc_cfg_dir_pass_info_in_envvars(r);\n\n\t/* verify current cookie domain against issued cookie domain */\n\tif (oidc_check_cookie_domain(r, cfg, session) == FALSE)\n\t\treturn HTTP_UNAUTHORIZED;\n\n\t/* check if the maximum session duration was exceeded */\n\tint rc = oidc_check_max_session_duration(r, cfg, session);\n\tif (rc != OK)\n\t\treturn rc;\n\n\t/* if needed, refresh claims from the user info endpoint */\n\tapr_byte_t needs_save = oidc_refresh_claims_from_userinfo_endpoint(r, cfg,\n\t\t\tsession);\n\n\t/*\n\t * we're going to pass the information that we have to the application,\n\t * but first we need to scrub the headers that we're going to use for security reasons\n\t */\n\tif (cfg->scrub_request_headers != 0) {\n\n\t\t/* scrub all headers starting with OIDC_ first */\n\t\toidc_scrub_request_headers(r, OIDC_DEFAULT_HEADER_PREFIX,\n\t\t\t\toidc_cfg_dir_authn_header(r));\n\n\t\t/*\n\t\t * then see if the claim headers need to be removed on top of that\n\t\t * (i.e. the prefix does not start with the default OIDC_)\n\t\t */\n\t\tif ((strstr(cfg->claim_prefix, OIDC_DEFAULT_HEADER_PREFIX)\n\t\t\t\t!= cfg->claim_prefix)) {\n\t\t\toidc_scrub_request_headers(r, cfg->claim_prefix, NULL);\n\t\t}\n\t}\n\n\t/* set the user authentication HTTP header if set and required */\n\tif ((r->user != NULL) && (authn_header != NULL))\n\t\toidc_util_set_header(r, authn_header, r->user);\n\n\tconst char *s_claims = NULL;\n\tconst char *s_id_token = NULL;\n\n\t/* copy id_token and claims from session to request state and obtain their values */\n\toidc_copy_tokens_to_request_state(r, session, &s_id_token, &s_claims);\n\n\t/* set the claims in the app headers  */\n\tif (oidc_set_app_claims(r, cfg, session, s_claims) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_CLAIMS)) {\n\t\t/* set the id_token in the app headers */\n\t\tif (oidc_set_app_claims(r, cfg, session, s_id_token) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_PAYLOAD)) {\n\t\t/* pass the id_token JSON object to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, \"id_token_payload\", s_id_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\tif (cfg->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_SERIALIZED)) {\n\t\t\tconst char *s_id_token = NULL;\n\t\t\t/* get the compact serialized JWT from the session */\n\t\t\toidc_session_get(r, session, OIDC_IDTOKEN_SESSION_KEY, &s_id_token);\n\t\t\t/* pass the compact serialized JWT to the app in a header or environment variable */\n\t\t\toidc_util_set_app_info(r, \"id_token\", s_id_token,\n\t\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t\t}\n\t} else {\n\t\toidc_error(r,\n\t\t\t\t\"session type \\\"client-cookie\\\" does not allow storing/passing the id_token; use \\\"OIDCSessionType server-cache\\\" for that\");\n\t}\n\n\t/* set the refresh_token in the app headers/variables, if enabled for this location/directory */\n\tconst char *refresh_token = NULL;\n\toidc_session_get(r, session, OIDC_REFRESHTOKEN_SESSION_KEY, &refresh_token);\n\tif ((oidc_cfg_dir_pass_refresh_token(r) != 0) && (refresh_token != NULL)) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, \"refresh_token\", refresh_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\t/* set the access_token in the app headers/variables */\n\tconst char *access_token = NULL;\n\toidc_session_get(r, session, OIDC_ACCESSTOKEN_SESSION_KEY, &access_token);\n\tif (access_token != NULL) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, \"access_token\", access_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\t/* set the expiry timestamp in the app headers/variables */\n\tconst char *access_token_expires = NULL;\n\toidc_session_get(r, session, OIDC_ACCESSTOKEN_EXPIRES_SESSION_KEY,\n\t\t\t&access_token_expires);\n\tif (access_token_expires != NULL) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, \"access_token_expires\", access_token_expires,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\t/*\n\t * reset the session inactivity timer\n\t * but only do this once per 10% of the inactivity timeout interval (with a max to 60 seconds)\n\t * for performance reasons\n\t *\n\t * now there's a small chance that the session ends 10% (or a minute) earlier than configured/expected\n\t * cq. when there's a request after a recent save (so no update) and then no activity happens until\n\t * a request comes in just before the session should expire\n\t * (\"recent\" and \"just before\" refer to 10%-with-a-max-of-60-seconds of the inactivity interval after\n\t * the start/last-update and before the expiry of the session respectively)\n\t *\n\t * this is be deemed acceptable here because of performance gain\n\t */\n\tapr_time_t interval = apr_time_from_sec(cfg->session_inactivity_timeout);\n\tapr_time_t now = apr_time_now();\n\tapr_time_t slack = interval / 10;\n\tif (slack > apr_time_from_sec(60))\n\t\tslack = apr_time_from_sec(60);\n\tif (session->expiry - now < interval - slack) {\n\t\tsession->expiry = now + interval;\n\t\tneeds_save = TRUE;\n\t}\n\n\t/* check if something was updated in the session and we need to save it again */\n\tif (needs_save)\n\t\tif (oidc_session_save(r, session) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t/* return \"user authenticated\" status */\n\treturn OK;\n}\n\n/*\n * helper function for basic/implicit client flows upon receiving an authorization response:\n * check that it matches the state stored in the browser and return the variables associated\n * with the state, such as original_url and OP oidc_provider_t pointer.\n */\nstatic apr_byte_t oidc_authorization_response_match_state(request_rec *r,\n\t\toidc_cfg *c, const char *state, struct oidc_provider_t **provider,\n\t\tjson_t **proto_state) {\n\n\toidc_debug(r, \"enter (state=%s)\", state);\n\n\tif ((state == NULL) || (apr_strnatcmp(state, \"\") == 0)) {\n\t\toidc_error(r, \"state parameter is not set\");\n\t\treturn FALSE;\n\t}\n\n\t/* check the state parameter against what we stored in a cookie */\n\tif (oidc_restore_proto_state(r, c, state, proto_state) == FALSE) {\n\t\toidc_error(r, \"unable to restore state\");\n\t\treturn FALSE;\n\t}\n\n\t*provider = oidc_get_provider_for_issuer(r, c,\n\t\t\tjson_string_value(json_object_get(*proto_state, \"issuer\")), FALSE);\n\n\treturn (*provider != NULL);\n}\n\n/*\n * redirect the browser to the session logout endpoint\n */\nstatic int oidc_session_redirect_parent_window_to_logout(request_rec *r,\n\t\toidc_cfg *c) {\n\n\toidc_debug(r, \"enter\");\n\n\tchar *java_script = apr_psprintf(r->pool,\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      window.top.location.href = '%s?session=logout';\\n\"\n\t\t\t\"    </script>\\n\", c->redirect_uri);\n\n\treturn oidc_util_html_send(r, \"Redirecting...\", java_script, NULL, NULL,\n\t\t\tDONE);\n}\n\n/*\n * handle an error returned by the OP\n */\nstatic int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,\n\t\tjson_t *proto_state, const char *error, const char *error_description) {\n\tconst char *prompt =\n\t\t\tjson_object_get(proto_state, \"prompt\") ?\n\t\t\t\t\tapr_pstrdup(r->pool,\n\t\t\t\t\t\t\tjson_string_value(\n\t\t\t\t\t\t\t\t\tjson_object_get(proto_state, \"prompt\"))) :\n\t\t\t\t\t\t\t\t\tNULL;\n\tjson_decref(proto_state);\n\tif ((prompt != NULL) && (apr_strnatcmp(prompt, \"none\") == 0)) {\n\t\treturn oidc_session_redirect_parent_window_to_logout(r, c);\n\t}\n\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\tapr_psprintf(r->pool, \"OpenID Connect Provider error: %s\", error),\n\t\t\terror_description, DONE);\n}\n\n/*\n * set the unique user identifier that will be propagated in the Apache r->user and REMOTE_USER variables\n */\nstatic apr_byte_t oidc_get_remote_user(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t *provider, oidc_jwt_t *jwt, char **user,\n\t\tconst char *s_claims) {\n\n\tchar *issuer = provider->issuer;\n\tchar *claim_name = apr_pstrdup(r->pool, c->remote_user_claim.claim_name);\n\tint n = strlen(claim_name);\n\tint post_fix_with_issuer = (claim_name[n - 1] == '@');\n\tif (post_fix_with_issuer) {\n\t\tclaim_name[n - 1] = '\\0';\n\t\tissuer =\n\t\t\t\t(strstr(issuer, \"https://\") == NULL) ?\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer) :\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer + strlen(\"https://\"));\n\t}\n\n\t/* extract the username claim (default: \"sub\") from the id_token payload or user claims */\n\tchar *username = NULL;\n\tjson_error_t json_error;\n\tjson_t *claims = json_loads(s_claims, 0, &json_error);\n\tif (claims == NULL) {\n\t\tusername = apr_pstrdup(r->pool,\n\t\t\t\tjson_string_value(\n\t\t\t\t\t\tjson_object_get(jwt->payload.value.json, claim_name)));\n\t} else {\n\t\toidc_util_json_merge(jwt->payload.value.json, claims);\n\t\tusername = apr_pstrdup(r->pool,\n\t\t\t\tjson_string_value(json_object_get(claims, claim_name)));\n\t\tjson_decref(claims);\n\t}\n\n\tif (username == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"OIDCRemoteUserClaim is set to \\\"%s\\\", but the id_token JSON payload and user claims did not contain a \\\"%s\\\" string\",\n\t\t\t\tc->remote_user_claim.claim_name, claim_name);\n\t\t*user = NULL;\n\t\treturn FALSE;\n\t}\n\n\t/* set the unique username in the session (will propagate to r->user/REMOTE_USER) */\n\t*user = post_fix_with_issuer ?\n\t\t\tapr_psprintf(r->pool, \"%s@%s\", username, issuer) : username;\n\n\tif (c->remote_user_claim.reg_exp != NULL) {\n\n\t\tchar *error_str = NULL;\n\t\tif (oidc_util_regexp_first_match(r->pool, *user,\n\t\t\t\tc->remote_user_claim.reg_exp, user, &error_str) == FALSE) {\n\t\t\toidc_error(r, \"oidc_util_regexp_first_match failed: %s\", error_str);\n\t\t\t*user = NULL;\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\toidc_debug(r, \"set user to \\\"%s\\\"\", *user);\n\n\treturn TRUE;\n}\n\n/*\n * store resolved information in the session\n */\nstatic apr_byte_t oidc_save_in_session(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, oidc_provider_t *provider,\n\t\tconst char *remoteUser, const char *id_token, oidc_jwt_t *id_token_jwt,\n\t\tconst char *claims, const char *access_token, const int expires_in,\n\t\tconst char *refresh_token, const char *session_state, const char *state,\n\t\tconst char *original_url) {\n\n\t/* store the user in the session */\n\tsession->remote_user = remoteUser;\n\n\t/* set the session expiry to the inactivity timeout */\n\tsession->expiry =\n\t\t\tapr_time_now() + apr_time_from_sec(c->session_inactivity_timeout);\n\n\t/* store the claims payload in the id_token for later reference */\n\toidc_session_set(r, session, OIDC_IDTOKEN_CLAIMS_SESSION_KEY,\n\t\t\tid_token_jwt->payload.value.str);\n\n\tif (c->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\t/* store the compact serialized representation of the id_token for later reference  */\n\t\toidc_session_set(r, session, OIDC_IDTOKEN_SESSION_KEY, id_token);\n\t}\n\n\t/* store the issuer in the session (at least needed for session mgmt and token refresh */\n\toidc_session_set(r, session, OIDC_ISSUER_SESSION_KEY, provider->issuer);\n\n\t/* store the state and original URL in the session for handling browser-back more elegantly */\n\toidc_session_set(r, session, OIDC_REQUEST_STATE_SESSION_KEY, state);\n\toidc_session_set(r, session, OIDC_REQUEST_ORIGINAL_URL, original_url);\n\n\tif ((session_state != NULL) && (provider->check_session_iframe != NULL)) {\n\t\t/* store the session state and required parameters session management  */\n\t\toidc_session_set(r, session, OIDC_SESSION_STATE_SESSION_KEY,\n\t\t\t\tsession_state);\n\t\toidc_session_set(r, session, OIDC_CHECK_IFRAME_SESSION_KEY,\n\t\t\t\tprovider->check_session_iframe);\n\t\toidc_session_set(r, session, OIDC_CLIENTID_SESSION_KEY,\n\t\t\t\tprovider->client_id);\n\t\toidc_debug(r,\n\t\t\t\t\"session management enabled: stored session_state (%s), check_session_iframe (%s) and client_id (%s) in the session\",\n\t\t\t\tsession_state, provider->check_session_iframe,\n\t\t\t\tprovider->client_id);\n\t} else {\n\t\toidc_debug(r,\n\t\t\t\t\"session management disabled: session_state (%s) and/or check_session_iframe (%s) is not provided\",\n\t\t\t\tsession_state, provider->check_session_iframe);\n\t}\n\n\tif (provider->end_session_endpoint != NULL)\n\t\toidc_session_set(r, session, OIDC_LOGOUT_ENDPOINT_SESSION_KEY,\n\t\t\t\tprovider->end_session_endpoint);\n\n\t/* store claims resolved from userinfo endpoint */\n\toidc_store_userinfo_claims(r, session, provider, claims);\n\n\t/* see if we have an access_token */\n\tif (access_token != NULL) {\n\t\t/* store the access_token in the session context */\n\t\toidc_session_set(r, session, OIDC_ACCESSTOKEN_SESSION_KEY,\n\t\t\t\taccess_token);\n\t\t/* store the associated expires_in value */\n\t\toidc_store_access_token_expiry(r, session, expires_in);\n\t}\n\n\t/* see if we have a refresh_token */\n\tif (refresh_token != NULL) {\n\t\t/* store the refresh_token in the session context */\n\t\toidc_session_set(r, session, OIDC_REFRESHTOKEN_SESSION_KEY,\n\t\t\t\trefresh_token);\n\t}\n\n\t/* store max session duration in the session as a hard cut-off expiry timestamp */\n\tapr_time_t session_expires =\n\t\t\t(provider->session_max_duration == 0) ?\n\t\t\t\t\tapr_time_from_sec(id_token_jwt->payload.exp) :\n\t\t\t\t\t(apr_time_now()\n\t\t\t\t\t\t\t+ apr_time_from_sec(provider->session_max_duration));\n\toidc_session_set(r, session, OIDC_SESSION_EXPIRES_SESSION_KEY,\n\t\t\tapr_psprintf(r->pool, \"%\" APR_TIME_T_FMT, session_expires));\n\n\t/* log message about max session duration */\n\toidc_log_session_expires(r, session_expires);\n\n\t/* store the domain for which this session is valid */\n\toidc_session_set(r, session, OIDC_COOKIE_DOMAIN_SESSION_KEY,\n\t\t\tc->cookie_domain ? c->cookie_domain : oidc_get_current_url_host(r));\n\n\t/* store the session */\n\treturn oidc_session_save(r, session);\n}\n\n/*\n * parse the expiry for the access token\n */\nstatic int oidc_parse_expires_in(request_rec *r, const char *expires_in) {\n\tif (expires_in != NULL) {\n\t\tchar *ptr = NULL;\n\t\tlong number = strtol(expires_in, &ptr, 10);\n\t\tif (number <= 0) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"could not convert \\\"expires_in\\\" value (%s) to a number\",\n\t\t\t\t\texpires_in);\n\t\t\treturn -1;\n\t\t}\n\t\treturn number;\n\t}\n\treturn -1;\n}\n\n/*\n * handle the different flows (hybrid, implicit, Authorization Code)\n */\nstatic apr_byte_t oidc_handle_flows(request_rec *r, oidc_cfg *c,\n\t\tjson_t *proto_state, oidc_provider_t *provider, apr_table_t *params,\n\t\tconst char *response_mode, oidc_jwt_t **jwt) {\n\n\tapr_byte_t rc = FALSE;\n\n\tconst char *requested_response_type = json_string_value(\n\t\t\tjson_object_get(proto_state, \"response_type\"));\n\n\t/* handle the requested response type/mode */\n\tif (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\t\"code id_token token\")) {\n\t\trc = oidc_proto_authorization_response_code_idtoken_token(r, c,\n\t\t\t\tproto_state, provider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\t\"code id_token\")) {\n\t\trc = oidc_proto_authorization_response_code_idtoken(r, c, proto_state,\n\t\t\t\tprovider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\t\"code token\")) {\n\t\trc = oidc_proto_handle_authorization_response_code_token(r, c,\n\t\t\t\tproto_state, provider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\t\"code\")) {\n\t\trc = oidc_proto_handle_authorization_response_code(r, c, proto_state,\n\t\t\t\tprovider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\t\"id_token token\")) {\n\t\trc = oidc_proto_handle_authorization_response_idtoken_token(r, c,\n\t\t\t\tproto_state, provider, params, response_mode, jwt);\n\t} else if (oidc_util_spaced_string_equals(r->pool, requested_response_type,\n\t\t\t\"id_token\")) {\n\t\trc = oidc_proto_handle_authorization_response_idtoken(r, c, proto_state,\n\t\t\t\tprovider, params, response_mode, jwt);\n\t} else {\n\t\toidc_error(r, \"unsupported response type: \\\"%s\\\"\",\n\t\t\t\trequested_response_type);\n\t}\n\n\tif ((rc == FALSE) && (*jwt != NULL)) {\n\t\toidc_jwt_destroy(*jwt);\n\t\t*jwt = NULL;\n\t}\n\n\treturn rc;\n}\n\n/* handle the browser back on an authorization response */\nstatic apr_byte_t oidc_handle_browser_back(request_rec *r, const char *r_state,\n\t\toidc_session_t *session) {\n\n\t/*  see if we have an existing session and browser-back was used */\n\tconst char *s_state = NULL, *o_url = NULL;\n\n\tif (session->remote_user != NULL) {\n\n\t\toidc_session_get(r, session, OIDC_REQUEST_STATE_SESSION_KEY, &s_state);\n\t\toidc_session_get(r, session, OIDC_REQUEST_ORIGINAL_URL, &o_url);\n\n\t\tif ((r_state != NULL) && (s_state != NULL)\n\t\t\t\t&& (apr_strnatcmp(r_state, s_state) == 0)) {\n\n\t\t\t/* log the browser back event detection */\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"browser back detected, redirecting to original URL: %s\",\n\t\t\t\t\to_url);\n\n\t\t\t/* go back to the URL that he originally tried to access */\n\t\t\tapr_table_add(r->headers_out, \"Location\", o_url);\n\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\n\treturn FALSE;\n}\n\n/*\n * complete the handling of an authorization response by obtaining, parsing and verifying the\n * id_token and storing the authenticated user state in the session\n */\nstatic int oidc_handle_authorization_response(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, apr_table_t *params, const char *response_mode) {\n\n\toidc_debug(r, \"enter, response_mode=%s\", response_mode);\n\n\toidc_provider_t *provider = NULL;\n\tjson_t *proto_state = NULL;\n\toidc_jwt_t *jwt = NULL;\n\n\t/* see if this response came from a browser-back event */\n\tif (oidc_handle_browser_back(r, apr_table_get(params, \"state\"),\n\t\t\tsession) == TRUE)\n\t\treturn HTTP_MOVED_TEMPORARILY;\n\n\t/* match the returned state parameter against the state stored in the browser */\n\tif (oidc_authorization_response_match_state(r, c,\n\t\t\tapr_table_get(params, \"state\"), &provider, &proto_state) == FALSE) {\n\t\tif (c->default_sso_url != NULL) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"invalid authorization response state; a default SSO URL is set, sending the user there: %s\",\n\t\t\t\t\tc->default_sso_url);\n\t\t\tapr_table_add(r->headers_out, \"Location\", c->default_sso_url);\n\t\t\treturn HTTP_MOVED_TEMPORARILY;\n\t\t}\n\t\toidc_error(r,\n\t\t\t\t\"invalid authorization response state and no default SSO URL is set, sending an error...\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* see if the response is an error response */\n\tif (apr_table_get(params, \"error\") != NULL)\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\tapr_table_get(params, \"error\"),\n\t\t\t\tapr_table_get(params, \"error_description\"));\n\n\t/* handle the code, implicit or hybrid flow */\n\tif (oidc_handle_flows(r, c, proto_state, provider, params, response_mode,\n\t\t\t&jwt) == FALSE)\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\"Error in handling response type.\", NULL);\n\n\tif (jwt == NULL) {\n\t\toidc_error(r, \"no id_token was provided\");\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\"No id_token was provided.\", NULL);\n\t}\n\n\tint expires_in = oidc_parse_expires_in(r,\n\t\t\tapr_table_get(params, \"expires_in\"));\n\n\t/*\n\t * optionally resolve additional claims against the userinfo endpoint\n\t * parsed claims are not actually used here but need to be parsed anyway for error checking purposes\n\t */\n\tconst char *claims = oidc_retrieve_claims_from_userinfo_endpoint(r, c,\n\t\t\tprovider, apr_table_get(params, \"access_token\"), NULL, jwt->payload.sub);\n\n\t/* restore the original protected URL that the user was trying to access */\n\tconst char *original_url = apr_pstrdup(r->pool,\n\t\t\tjson_string_value(json_object_get(proto_state, \"original_url\")));\n\tconst char *original_method = apr_pstrdup(r->pool,\n\t\t\tjson_string_value(json_object_get(proto_state, \"original_method\")));\n\n\t/* set the user */\n\tif (oidc_get_remote_user(r, c, provider, jwt, &r->user, claims) == TRUE) {\n\n\t\t/* session management: if the user in the new response is not equal to the old one, error out */\n\t\tif ((json_object_get(proto_state, \"prompt\") != NULL)\n\t\t\t\t&& (apr_strnatcmp(\n\t\t\t\t\t\tjson_string_value(\n\t\t\t\t\t\t\t\tjson_object_get(proto_state, \"prompt\")), \"none\")\n\t\t\t\t\t\t== 0)) {\n\t\t\t// TOOD: actually need to compare sub? (need to store it in the session separately then\n\t\t\t//const char *sub = NULL;\n\t\t\t//oidc_session_get(r, session, \"sub\", &sub);\n\t\t\t//if (apr_strnatcmp(sub, jwt->payload.sub) != 0) {\n\t\t\tif (apr_strnatcmp(session->remote_user, r->user) != 0) {\n\t\t\t\toidc_warn(r,\n\t\t\t\t\t\t\"user set from new id_token is different from current one\");\n\t\t\t\toidc_jwt_destroy(jwt);\n\t\t\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\t\t\"User changed!\", NULL);\n\t\t\t}\n\t\t}\n\n\t\t/* store resolved information in the session */\n\t\tif (oidc_save_in_session(r, c, session, provider, r->user,\n\t\t\t\tapr_table_get(params, \"id_token\"), jwt, claims,\n\t\t\t\tapr_table_get(params, \"access_token\"), expires_in,\n\t\t\t\tapr_table_get(params, \"refresh_token\"),\n\t\t\t\tapr_table_get(params, \"session_state\"),\n\t\t\t\tapr_table_get(params, \"state\"), original_url) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t} else {\n\t\toidc_error(r, \"remote user could not be set\");\n\t\treturn oidc_authorization_response_error(r, c, proto_state,\n\t\t\t\t\"Remote user could not be set: contact the website administrator\",\n\t\t\t\tNULL);\n\t}\n\n\t/* cleanup */\n\tjson_decref(proto_state);\n\toidc_jwt_destroy(jwt);\n\n\t/* check that we've actually authenticated a user; functions as error handling for oidc_get_remote_user */\n\tif (r->user == NULL)\n\t\treturn HTTP_UNAUTHORIZED;\n\n\t/* log the successful response */\n\toidc_debug(r,\n\t\t\t\"session created and stored, returning to original URL: %s, original method: %s\",\n\t\t\toriginal_url, original_method);\n\n\t/* check whether form post data was preserved; if so restore it */\n\tif (apr_strnatcmp(original_method, OIDC_METHOD_FORM_POST) == 0) {\n\t\treturn oidc_request_post_preserved_restore(r, original_url);\n\t}\n\n\t/* now we've authenticated the user so go back to the URL that he originally tried to access */\n\tapr_table_add(r->headers_out, \"Location\", original_url);\n\n\t/* do the actual redirect to the original URL */\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\n/*\n * handle an OpenID Connect Authorization Response using the POST (+fragment->POST) response_mode\n */\nstatic int oidc_handle_post_authorization_response(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* initialize local variables */\n\tchar *response_mode = NULL;\n\n\t/* read the parameters that are POST-ed to us */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params) == FALSE) {\n\t\toidc_error(r, \"something went wrong when reading the POST parameters\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* see if we've got any POST-ed data at all */\n\tif ((apr_table_elts(params)->nelts < 1)\n\t\t\t|| ((apr_table_elts(params)->nelts == 1)\n\t\t\t\t\t&& apr_table_get(params, \"response_mode\")\n\t\t\t\t\t&& (apr_strnatcmp(apr_table_get(params, \"response_mode\"),\n\t\t\t\t\t\t\t\"fragment\") == 0))) {\n\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\"Invalid Request\",\n\t\t\t\t\"You've hit an OpenID Connect Redirect URI with no parameters, this is an invalid request; you should not open this URL in your browser directly, or have the server administrator use a different OIDCRedirectURI setting.\",\n\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t}\n\n\t/* get the parameters */\n\tresponse_mode = (char *) apr_table_get(params, \"response_mode\");\n\n\t/* do the actual implicit work */\n\treturn oidc_handle_authorization_response(r, c, session, params,\n\t\t\tresponse_mode ? response_mode : \"form_post\");\n}\n\n/*\n * handle an OpenID Connect Authorization Response using the redirect response_mode\n */\nstatic int oidc_handle_redirect_authorization_response(request_rec *r,\n\t\toidc_cfg *c, oidc_session_t *session) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* read the parameters from the query string */\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\toidc_util_read_form_encoded_params(r, params, r->args);\n\n\t/* do the actual work */\n\treturn oidc_handle_authorization_response(r, c, session, params, \"query\");\n}\n\n/*\n * present the user with an OP selection screen\n */\nstatic int oidc_discovery(request_rec *r, oidc_cfg *cfg) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* obtain the URL we're currently accessing, to be stored in the state/session */\n\tchar *current_url = oidc_get_current_url(r);\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\n\t/* generate CSRF token */\n\tchar *csrf = NULL;\n\tif (oidc_proto_generate_nonce(r, &csrf, 8) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\tchar *discover_url = oidc_cfg_dir_discover_url(r);\n\t/* see if there's an external discovery page configured */\n\tif (discover_url != NULL) {\n\n\t\t/* yes, assemble the parameters for external discovery */\n\t\tchar *url = apr_psprintf(r->pool, \"%s%s%s=%s&%s=%s&%s=%s&%s=%s\",\n\t\t\t\tdiscover_url, strchr(discover_url, '?') != NULL ? \"&\" : \"?\",\n\t\t\t\t\t\tOIDC_DISC_RT_PARAM, oidc_util_escape_string(r, current_url),\n\t\t\t\t\t\tOIDC_DISC_RM_PARAM, method,\n\t\t\t\t\t\tOIDC_DISC_CB_PARAM,\n\t\t\t\t\t\toidc_util_escape_string(r, cfg->redirect_uri),\n\t\t\t\t\t\tOIDC_CSRF_NAME, oidc_util_escape_string(r, csrf));\n\n\t\t/* log what we're about to do */\n\t\toidc_debug(r, \"redirecting to external discovery page: %s\", url);\n\n\t\t/* set CSRF cookie */\n\t\toidc_util_set_cookie(r, OIDC_CSRF_NAME, csrf, -1);\n\n\t\t/* see if we need to preserve POST parameters through Javascript/HTML5 storage */\n\t\tif (oidc_post_preserve_javascript(r, url, NULL, NULL) == TRUE)\n\t\t\treturn DONE;\n\n\t\t/* do the actual redirect to an external discovery page */\n\t\tapr_table_add(r->headers_out, \"Location\", url);\n\t\treturn HTTP_MOVED_TEMPORARILY;\n\t}\n\n\t/* get a list of all providers configured in the metadata directory */\n\tapr_array_header_t *arr = NULL;\n\tif (oidc_metadata_list(r, cfg, &arr) == FALSE)\n\t\treturn oidc_util_html_send_error(r, cfg->error_template,\n\t\t\t\t\"Configuration Error\",\n\t\t\t\t\"No configured providers found, contact your administrator\",\n\t\t\t\tHTTP_UNAUTHORIZED);\n\n\t/* assemble a where-are-you-from IDP discovery HTML page */\n\tconst char *s = \"\t\t\t<h3>Select your OpenID Connect Identity Provider</h3>\\n\";\n\n\t/* list all configured providers in there */\n\tint i;\n\tfor (i = 0; i < arr->nelts; i++) {\n\t\tconst char *issuer = ((const char**) arr->elts)[i];\n\t\t// TODO: html escape (especially & character)\n\n\t\tchar *display =\n\t\t\t\t(strstr(issuer, \"https://\") == NULL) ?\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer) :\n\t\t\t\t\t\tapr_pstrdup(r->pool, issuer + strlen(\"https://\"));\n\n\t\t/* strip port number */\n\t\t//char *p = strstr(display, \":\");\n\t\t//if (p != NULL) *p = '\\0';\n\t\t/* point back to the redirect_uri, where the selection is handled, with an IDP selection and return_to URL */\n\t\ts =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"%s<p><a href=\\\"%s?%s=%s&amp;%s=%s&amp;%s=%s&amp;%s=%s\\\">%s</a></p>\\n\",\n\t\t\t\t\t\ts, cfg->redirect_uri, OIDC_DISC_OP_PARAM,\n\t\t\t\t\t\toidc_util_escape_string(r, issuer),\n\t\t\t\t\t\tOIDC_DISC_RT_PARAM,\n\t\t\t\t\t\toidc_util_escape_string(r, current_url),\n\t\t\t\t\t\tOIDC_DISC_RM_PARAM, method,\n\t\t\t\t\t\tOIDC_CSRF_NAME, csrf, display);\n\t}\n\n\t/* add an option to enter an account or issuer name for dynamic OP discovery */\n\ts = apr_psprintf(r->pool, \"%s<form method=\\\"get\\\" action=\\\"%s\\\">\\n\", s,\n\t\t\tcfg->redirect_uri);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\tOIDC_DISC_RT_PARAM, current_url);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\tOIDC_DISC_RM_PARAM, method);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"hidden\\\" name=\\\"%s\\\" value=\\\"%s\\\"><p>\\n\", s,\n\t\t\tOIDC_CSRF_NAME, csrf);\n\ts =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"%s<p>Or enter your account name (eg. &quot;mike@seed.gluu.org&quot;, or an IDP identifier (eg. &quot;mitreid.org&quot;):</p>\\n\",\n\t\t\t\t\ts);\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"text\\\" name=\\\"%s\\\" value=\\\"%s\\\"></p>\\n\", s,\n\t\t\tOIDC_DISC_OP_PARAM, \"\");\n\ts = apr_psprintf(r->pool,\n\t\t\t\"%s<p><input type=\\\"submit\\\" value=\\\"Submit\\\"></p>\\n\", s);\n\ts = apr_psprintf(r->pool, \"%s</form>\\n\", s);\n\n\toidc_util_set_cookie(r, OIDC_CSRF_NAME, csrf, -1);\n\n\tchar *javascript = NULL, *javascript_method = NULL;\n\tchar *html_head =\n\t\t\t\"<style type=\\\"text/css\\\">body {text-align: center}</style>\";\n\tif (oidc_post_preserve_javascript(r, NULL, &javascript,\n\t\t\t&javascript_method) == TRUE)\n\t\thtml_head = apr_psprintf(r->pool, \"%s%s\", html_head, javascript);\n\n\t/* now send the HTML contents to the user agent */\n\treturn oidc_util_html_send(r, \"OpenID Connect Provider Discovery\",\n\t\t\thtml_head, javascript_method, s, DONE);\n}\n\n/*\n * authenticate the user to the selected OP, if the OP is not selected yet perform discovery first\n */\nstatic int oidc_authenticate_user(request_rec *r, oidc_cfg *c,\n\t\toidc_provider_t *provider, const char *original_url,\n\t\tconst char *login_hint, const char *id_token_hint, const char *prompt,\n\t\tconst char *auth_request_params) {\n\n\toidc_debug(r, \"enter\");\n\n\tif (provider == NULL) {\n\n\t\t// TODO: should we use an explicit redirect to the discovery endpoint (maybe a \"discovery\" param to the redirect_uri)?\n\t\tif (c->metadata_dir != NULL)\n\t\t\treturn oidc_discovery(r, c);\n\n\t\t/* we're not using multiple OP's configured in a metadata directory, pick the statically configured OP */\n\t\tif (oidc_provider_static_config(r, c, &provider) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* generate the random nonce value that correlates requests and responses */\n\tchar *nonce = NULL;\n\tif (oidc_proto_generate_nonce(r, &nonce, OIDC_PROTO_NONCE_LENGTH) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\tchar *code_verifier = NULL;\n\tchar *code_challenge = NULL;\n\n\tif ((oidc_util_spaced_string_contains(r->pool, provider->response_type,\n\t\t\t\"code\") == TRUE) && (provider->pkce_method != NULL)) {\n\n\t\t/* generate the code verifier value that correlates authorization requests and code exchange requests */\n\t\tif (oidc_proto_generate_code_verifier(r, &code_verifier,\n\t\t\t\tOIDC_PROTO_CODE_VERIFIER_LENGTH) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t\t/* generate the PKCE code challenge */\n\t\tif (oidc_proto_generate_code_challenge(r, code_verifier,\n\t\t\t\t&code_challenge, provider->pkce_method) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* create the state between request/response */\n\tjson_t *proto_state = json_object();\n\tjson_object_set_new(proto_state, \"original_url\", json_string(original_url));\n\tjson_object_set_new(proto_state, \"original_method\",\n\t\t\tjson_string(oidc_original_request_method(r, c, TRUE)));\n\tjson_object_set_new(proto_state, \"issuer\", json_string(provider->issuer));\n\tjson_object_set_new(proto_state, \"response_type\",\n\t\t\tjson_string(provider->response_type));\n\tjson_object_set_new(proto_state, \"nonce\", json_string(nonce));\n\tjson_object_set_new(proto_state, \"timestamp\",\n\t\t\tjson_integer(apr_time_sec(apr_time_now())));\n\tif (provider->response_mode)\n\t\tjson_object_set_new(proto_state, \"response_mode\",\n\t\t\t\tjson_string(provider->response_mode));\n\tif (prompt)\n\t\tjson_object_set_new(proto_state, \"prompt\", json_string(prompt));\n\tif (code_verifier)\n\t\tjson_object_set_new(proto_state, \"code_verifier\",\n\t\t\t\tjson_string(code_verifier));\n\n\t/* get a hash value that fingerprints the browser concatenated with the random input */\n\tchar *state = oidc_get_browser_state_hash(r, nonce);\n\n\t/* create state that restores the context when the authorization response comes in; cryptographically bind it to the browser */\n\tif (oidc_authorization_request_set_cookie(r, c, state, proto_state) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t/*\n\t * printout errors if Cookie settings are not going to work\n\t */\n\tapr_uri_t o_uri;\n\tmemset(&o_uri, 0, sizeof(apr_uri_t));\n\tapr_uri_t r_uri;\n\tmemset(&r_uri, 0, sizeof(apr_uri_t));\n\tapr_uri_parse(r->pool, original_url, &o_uri);\n\tapr_uri_parse(r->pool, c->redirect_uri, &r_uri);\n\tif ((apr_strnatcmp(o_uri.scheme, r_uri.scheme) != 0)\n\t\t\t&& (apr_strnatcmp(r_uri.scheme, \"https\") == 0)) {\n\t\toidc_error(r,\n\t\t\t\t\"the URL scheme (%s) of the configured OIDCRedirectURI does not match the URL scheme of the URL being accessed (%s): the \\\"state\\\" and \\\"session\\\" cookies will not be shared between the two!\",\n\t\t\t\tr_uri.scheme, o_uri.scheme);\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif (c->cookie_domain == NULL) {\n\t\tif (apr_strnatcmp(o_uri.hostname, r_uri.hostname) != 0) {\n\t\t\tchar *p = strstr(o_uri.hostname, r_uri.hostname);\n\t\t\tif ((p == NULL) || (apr_strnatcmp(r_uri.hostname, p) != 0)) {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"the URL hostname (%s) of the configured OIDCRedirectURI does not match the URL hostname of the URL being accessed (%s): the \\\"state\\\" and \\\"session\\\" cookies will not be shared between the two!\",\n\t\t\t\t\t\tr_uri.hostname, o_uri.hostname);\n\t\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!oidc_util_cookie_domain_valid(r_uri.hostname, c->cookie_domain)) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"the domain (%s) configured in OIDCCookieDomain does not match the URL hostname (%s) of the URL being accessed (%s): setting \\\"state\\\" and \\\"session\\\" cookies will not work!!\",\n\t\t\t\t\tc->cookie_domain, o_uri.hostname, original_url);\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t\t}\n\t}\n\n\t/* send off to the OpenID Connect Provider */\n\t// TODO: maybe show intermediate/progress screen \"redirecting to\"\n\treturn oidc_proto_authorization_request(r, provider, login_hint,\n\t\t\tc->redirect_uri, state, proto_state, id_token_hint, code_challenge,\n\t\t\tauth_request_params);\n}\n\n/*\n * check if the target_link_uri matches to configuration settings to prevent an open redirect\n */\nstatic int oidc_target_link_uri_matches_configuration(request_rec *r,\n\t\toidc_cfg *cfg, const char *target_link_uri) {\n\n\tapr_uri_t o_uri;\n\tapr_uri_parse(r->pool, target_link_uri, &o_uri);\n\tif (o_uri.hostname == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"could not parse the \\\"target_link_uri\\\" (%s) in to a valid URL: aborting.\",\n\t\t\t\ttarget_link_uri);\n\t\treturn FALSE;\n\t}\n\n\tapr_uri_t r_uri;\n\tapr_uri_parse(r->pool, cfg->redirect_uri, &r_uri);\n\n\tif (cfg->cookie_domain == NULL) {\n\t\t/* cookie_domain set: see if the target_link_uri matches the redirect_uri host (because the session cookie will be set host-wide) */\n\t\tif (apr_strnatcmp(o_uri.hostname, r_uri.hostname) != 0) {\n\t\t\tchar *p = strstr(o_uri.hostname, r_uri.hostname);\n\t\t\tif ((p == NULL) || (apr_strnatcmp(r_uri.hostname, p) != 0)) {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"the URL hostname (%s) of the configured OIDCRedirectURI does not match the URL hostname of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\t\tr_uri.hostname, o_uri.hostname);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* cookie_domain set: see if the target_link_uri is within the cookie_domain */\n\t\tchar *p = strstr(o_uri.hostname, cfg->cookie_domain);\n\t\tif ((p == NULL) || (apr_strnatcmp(cfg->cookie_domain, p) != 0)) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"the domain (%s) configured in OIDCCookieDomain does not match the URL hostname (%s) of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\tcfg->cookie_domain, o_uri.hostname, target_link_uri);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/* see if the cookie_path setting matches the target_link_uri path */\n\tchar *cookie_path = oidc_cfg_dir_cookie_path(r);\n\tif (cookie_path != NULL) {\n\t\tchar *p = (o_uri.path != NULL) ? strstr(o_uri.path, cookie_path) : NULL;\n\t\tif ((p == NULL) || (p != o_uri.path)) {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"the path (%s) configured in OIDCCookiePath does not match the URL path (%s) of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\tcfg->cookie_domain, o_uri.path, target_link_uri);\n\t\t\treturn FALSE;\n\t\t} else if (strlen(o_uri.path) > strlen(cookie_path)) {\n\t\t\tint n = strlen(cookie_path);\n\t\t\tif (cookie_path[n - 1] == '/')\n\t\t\t\tn--;\n\t\t\tif (o_uri.path[n] != '/') {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"the path (%s) configured in OIDCCookiePath does not match the URL path (%s) of the \\\"target_link_uri\\\" (%s): aborting to prevent an open redirect.\",\n\t\t\t\t\t\tcfg->cookie_domain, o_uri.path, target_link_uri);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n\n/*\n * handle a response from an IDP discovery page and/or handle 3rd-party initiated SSO\n */\nstatic int oidc_handle_discovery_response(request_rec *r, oidc_cfg *c) {\n\n\t/* variables to hold the values returned in the response */\n\tchar *issuer = NULL, *target_link_uri = NULL, *login_hint = NULL,\n\t\t\t*auth_request_params = NULL, *csrf_cookie, *csrf_query = NULL,\n\t\t\t*user = NULL;\n\toidc_provider_t *provider = NULL;\n\n\toidc_util_get_request_parameter(r, OIDC_DISC_OP_PARAM, &issuer);\n\toidc_util_get_request_parameter(r, OIDC_DISC_USER_PARAM, &user);\n\toidc_util_get_request_parameter(r, OIDC_DISC_RT_PARAM, &target_link_uri);\n\toidc_util_get_request_parameter(r, OIDC_DISC_LH_PARAM, &login_hint);\n\toidc_util_get_request_parameter(r, OIDC_DISC_AR_PARAM,\n\t\t\t&auth_request_params);\n\toidc_util_get_request_parameter(r, OIDC_CSRF_NAME, &csrf_query);\n\tcsrf_cookie = oidc_util_get_cookie(r, OIDC_CSRF_NAME);\n\n\t/* do CSRF protection if not 3rd party initiated SSO */\n\tif (csrf_cookie) {\n\n\t\t/* clean CSRF cookie */\n\t\toidc_util_set_cookie(r, OIDC_CSRF_NAME, \"\", 0);\n\n\t\t/* compare CSRF cookie value with query parameter value */\n\t\tif ((csrf_query == NULL)\n\t\t\t\t|| apr_strnatcmp(csrf_query, csrf_cookie) != 0) {\n\t\t\toidc_warn(r,\n\t\t\t\t\t\"CSRF protection failed, no Discovery and dynamic client registration will be allowed\");\n\t\t\tcsrf_cookie = NULL;\n\t\t}\n\t}\n\n\t// TODO: trim issuer/accountname/domain input and do more input validation\n\n\toidc_debug(r,\n\t\t\t\"issuer=\\\"%s\\\", target_link_uri=\\\"%s\\\", login_hint=\\\"%s\\\", user=\\\"%s\\\"\",\n\t\t\tissuer, target_link_uri, login_hint, user);\n\n\tif (target_link_uri == NULL) {\n\t\tif (c->default_sso_url == NULL) {\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"SSO to this module without specifying a \\\"target_link_uri\\\" parameter is not possible because OIDCDefaultURL is not set.\",\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t}\n\t\ttarget_link_uri = c->default_sso_url;\n\t}\n\n\t/* do open redirect prevention */\n\tif (oidc_target_link_uri_matches_configuration(r, c,\n\t\t\ttarget_link_uri) == FALSE) {\n\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\"Invalid Request\",\n\t\t\t\t\"\\\"target_link_uri\\\" parameter does not match configuration settings, aborting to prevent an open redirect.\",\n\t\t\t\tHTTP_UNAUTHORIZED);\n\t}\n\n\t/* find out if the user entered an account name or selected an OP manually */\n\tif (user != NULL) {\n\n\t\tif (login_hint == NULL)\n\t\t\tlogin_hint = apr_pstrdup(r->pool, user);\n\n\t\t/* normalize the user identifier */\n\t\tif (strstr(user, \"https://\") != user)\n\t\t\tuser = apr_psprintf(r->pool, \"https://%s\", user);\n\n\t\t/* got an user identifier as input, perform OP discovery with that */\n\t\tif (oidc_proto_url_based_discovery(r, c, user, &issuer) == FALSE) {\n\n\t\t\t/* something did not work out, show a user facing error */\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"Could not resolve the provided user identifier to an OpenID Connect provider; check your syntax.\",\n\t\t\t\t\tHTTP_NOT_FOUND);\n\t\t}\n\n\t\t/* issuer is set now, so let's continue as planned */\n\n\t} else if (strstr(issuer, \"@\") != NULL) {\n\n\t\tif (login_hint == NULL) {\n\t\t\tlogin_hint = apr_pstrdup(r->pool, issuer);\n\t\t\t//char *p = strstr(issuer, \"@\");\n\t\t\t//*p = '\\0';\n\t\t}\n\n\t\t/* got an account name as input, perform OP discovery with that */\n\t\tif (oidc_proto_account_based_discovery(r, c, issuer, &issuer) == FALSE) {\n\n\t\t\t/* something did not work out, show a user facing error */\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\",\n\t\t\t\t\t\"Could not resolve the provided account name to an OpenID Connect provider; check your syntax.\",\n\t\t\t\t\tHTTP_NOT_FOUND);\n\t\t}\n\n\t\t/* issuer is set now, so let's continue as planned */\n\n\t}\n\n\t/* strip trailing '/' */\n\tint n = strlen(issuer);\n\tif (issuer[n - 1] == '/')\n\t\tissuer[n - 1] = '\\0';\n\n\t/* try and get metadata from the metadata directories for the selected OP */\n\tif ((oidc_metadata_get(r, c, issuer, &provider, csrf_cookie != NULL) == TRUE)\n\t\t\t&& (provider != NULL)) {\n\n\t\t/* now we've got a selected OP, send the user there to authenticate */\n\t\treturn oidc_authenticate_user(r, c, provider, target_link_uri,\n\t\t\t\tlogin_hint, NULL, NULL, auth_request_params);\n\t}\n\n\t/* something went wrong */\n\treturn oidc_util_html_send_error(r, c->error_template, \"Invalid Request\",\n\t\t\t\"Could not find valid provider metadata for the selected OpenID Connect provider; contact the administrator\",\n\t\t\tHTTP_NOT_FOUND);\n}\n\nstatic apr_uint32_t oidc_transparent_pixel[17] = { 0x474e5089, 0x0a1a0a0d,\n\t\t0x0d000000, 0x52444849, 0x01000000, 0x01000000, 0x00000408, 0x0c1cb500,\n\t\t0x00000002, 0x4144490b, 0x639c7854, 0x0000cffa, 0x02010702, 0x71311c9a,\n\t\t0x00000000, 0x444e4549, 0x826042ae };\n\nstatic apr_byte_t oidc_is_front_channel_logout(const char *logout_param_value) {\n\treturn ((logout_param_value != NULL)\n\t\t\t&& ((apr_strnatcmp(logout_param_value,\n\t\t\t\t\tOIDC_GET_STYLE_LOGOUT_PARAM_VALUE) == 0)\n\t\t\t\t\t|| (apr_strnatcmp(logout_param_value,\n\t\t\t\t\t\t\tOIDC_IMG_STYLE_LOGOUT_PARAM_VALUE) == 0)));\n}\n\n/*\n * handle a local logout\n */\nstatic int oidc_handle_logout_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *url) {\n\n\toidc_debug(r, \"enter (url=%s)\", url);\n\n\t/* if there's no remote_user then there's no (stored) session to kill */\n\tif (session->remote_user != NULL) {\n\n\t\t/* remove session state (cq. cache entry and cookie) */\n\t\toidc_session_kill(r, session);\n\t}\n\n\t/* see if this is the OP calling us */\n\tif (oidc_is_front_channel_logout(url)) {\n\n\t\t/* set recommended cache control headers */\n\t\tapr_table_add(r->err_headers_out, \"Cache-Control\",\n\t\t\t\t\"no-cache, no-store\");\n\t\tapr_table_add(r->err_headers_out, \"Pragma\", \"no-cache\");\n\t\tapr_table_add(r->err_headers_out, \"P3P\", \"CAO PSA OUR\");\n\t\tapr_table_add(r->err_headers_out, \"Expires\", \"0\");\n\t\tapr_table_add(r->err_headers_out, \"X-Frame-Options\", \"DENY\");\n\n\t\t/* see if this is PF-PA style logout in which case we return a transparent pixel */\n\t\tconst char *accept = apr_table_get(r->headers_in, \"Accept\");\n\t\tif ((apr_strnatcmp(url, OIDC_IMG_STYLE_LOGOUT_PARAM_VALUE) == 0)\n\t\t\t\t|| ((accept) && strstr(accept, \"image/png\"))) {\n\t\t\treturn oidc_util_http_send(r,\n\t\t\t\t\t(const char *) &oidc_transparent_pixel,\n\t\t\t\t\tsizeof(oidc_transparent_pixel), \"image/png\", DONE);\n\t\t}\n\n\t\t/* standard HTTP based logout: should be called in an iframe from the OP */\n\t\treturn oidc_util_html_send(r, \"Logged Out\", NULL, NULL,\n\t\t\t\t\"<p>Logged Out</p>\", DONE);\n\t}\n\n\t/* see if we don't need to go somewhere special after killing the session locally */\n\tif (url == NULL)\n\t\treturn oidc_util_html_send(r, \"Logged Out\", NULL, NULL,\n\t\t\t\t\"<p>Logged Out</p>\", DONE);\n\n\t/* send the user to the specified where-to-go-after-logout URL */\n\tapr_table_add(r->headers_out, \"Location\", url);\n\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\n/*\n * perform (single) logout\n */\nstatic int oidc_handle_logout(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\t/* pickup the command or URL where the user wants to go after logout */\n\tchar *url = NULL;\n\toidc_util_get_request_parameter(r, \"logout\", &url);\n\n\toidc_debug(r, \"enter (url=%s)\", url);\n\n\tif (oidc_is_front_channel_logout(url)) {\n\t\treturn oidc_handle_logout_request(r, c, session, url);\n\t}\n\n\tif ((url == NULL) || (apr_strnatcmp(url, \"\") == 0)) {\n\n\t\turl = c->default_slo_url;\n\n\t} else {\n\n\t\t/* do input validation on the logout parameter value */\n\n\t\tconst char *error_description = NULL;\n\t\tapr_uri_t uri;\n\n\t\tif (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS) {\n\t\t\tconst char *error_description = apr_psprintf(r->pool,\n\t\t\t\t\t\"Logout URL malformed: %s\", url);\n\t\t\toidc_error(r, \"%s\", error_description);\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Malformed URL\", error_description,\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\n\t\t}\n\n\t\tif ((strstr(r->hostname, uri.hostname) == NULL)\n\t\t\t\t|| (strstr(uri.hostname, r->hostname) == NULL)) {\n\t\t\terror_description =\n\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n\t\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), r->hostname);\n\t\t\toidc_error(r, \"%s\", error_description);\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\", error_description,\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t}\n\n\t\t/* validate the URL to prevent HTTP header splitting */\n\t\tif (((strstr(url, \"\\n\") != NULL) || strstr(url, \"\\r\") != NULL)) {\n\t\t\terror_description =\n\t\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\t\"logout value \\\"%s\\\" contains illegal \\\"\\n\\\" or \\\"\\r\\\" character(s)\",\n\t\t\t\t\t\t\turl);\n\t\t\toidc_error(r, \"%s\", error_description);\n\t\t\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\t\t\t\"Invalid Request\", error_description,\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n\t\t}\n\t}\n\n\tconst char *end_session_endpoint = NULL;\n\toidc_session_get(r, session, OIDC_LOGOUT_ENDPOINT_SESSION_KEY,\n\t\t\t&end_session_endpoint);\n\tif (end_session_endpoint != NULL) {\n\n\t\tconst char *id_token_hint = NULL;\n\t\toidc_session_get(r, session, OIDC_IDTOKEN_SESSION_KEY, &id_token_hint);\n\n\t\tchar *logout_request = apr_pstrdup(r->pool, end_session_endpoint);\n\t\tif (id_token_hint != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool, \"%s%sid_token_hint=%s\",\n\t\t\t\t\tlogout_request,\n\t\t\t\t\tstrchr(logout_request, '?') != NULL ? \"&\" : \"?\",\n\t\t\t\t\t\t\toidc_util_escape_string(r, id_token_hint));\n\t\t}\n\n\t\tif (url != NULL) {\n\t\t\tlogout_request = apr_psprintf(r->pool,\n\t\t\t\t\t\"%s%spost_logout_redirect_uri=%s\", logout_request,\n\t\t\t\t\tstrchr(logout_request, '?') != NULL ? \"&\" : \"?\",\n\t\t\t\t\t\t\toidc_util_escape_string(r, url));\n\t\t}\n\t\turl = logout_request;\n\t}\n\n\treturn oidc_handle_logout_request(r, c, session, url);\n}\n\n/*\n * handle request for JWKs\n */\nint oidc_handle_jwks(request_rec *r, oidc_cfg *c) {\n\n\t/* pickup requested JWKs type */\n\t//\tchar *jwks_type = NULL;\n\t//\toidc_util_get_request_parameter(r, \"jwks\", &jwks_type);\n\tchar *jwks = apr_pstrdup(r->pool, \"{ \\\"keys\\\" : [\");\n\tapr_hash_index_t *hi = NULL;\n\tapr_byte_t first = TRUE;\n\toidc_jose_error_t err;\n\n\tif (c->public_keys != NULL) {\n\n\t\t/* loop over the RSA public keys */\n\t\tfor (hi = apr_hash_first(r->pool, c->public_keys); hi; hi =\n\t\t\t\tapr_hash_next(hi)) {\n\n\t\t\tconst char *s_kid = NULL;\n\t\t\toidc_jwk_t *jwk = NULL;\n\t\t\tchar *s_json = NULL;\n\n\t\t\tapr_hash_this(hi, (const void**) &s_kid, NULL, (void**) &jwk);\n\n\t\t\tif (oidc_jwk_to_json(r->pool, jwk, &s_json, &err) == TRUE) {\n\t\t\t\tjwks = apr_psprintf(r->pool, \"%s%s %s \", jwks, first ? \"\" : \",\",\n\t\t\t\t\t\ts_json);\n\t\t\t\tfirst = FALSE;\n\t\t\t} else {\n\t\t\t\toidc_error(r,\n\t\t\t\t\t\t\"could not convert RSA JWK to JSON using oidc_jwk_to_json: %s\",\n\t\t\t\t\t\toidc_jose_e2s(r->pool, err));\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: send stuff if first == FALSE?\n\tjwks = apr_psprintf(r->pool, \"%s ] }\", jwks);\n\n\treturn oidc_util_http_send(r, jwks, strlen(jwks), \"application/json\", DONE);\n}\n\nstatic int oidc_handle_session_management_iframe_op(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *check_session_iframe) {\n\toidc_debug(r, \"enter\");\n\tapr_table_add(r->headers_out, \"Location\", check_session_iframe);\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\nstatic int oidc_handle_session_management_iframe_rp(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session, const char *client_id,\n\t\tconst char *check_session_iframe) {\n\n\toidc_debug(r, \"enter\");\n\n\tconst char *java_script =\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      var targetOrigin  = '%s';\\n\"\n\t\t\t\"      var message = '%s' + ' ' + '%s';\\n\"\n\t\t\t\"\t   var timerID;\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function checkSession() {\\n\"\n\t\t\t\"        console.log('checkSession: posting ' + message + ' to ' + targetOrigin);\\n\"\n\t\t\t\"        var win = window.parent.document.getElementById('%s').contentWindow;\\n\"\n\t\t\t\"        win.postMessage( message, targetOrigin);\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function setTimer() {\\n\"\n\t\t\t\"        checkSession();\\n\"\n\t\t\t\"        timerID = setInterval('checkSession()', %s);\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      function receiveMessage(e) {\\n\"\n\t\t\t\"        console.log('receiveMessage: ' + e.data + ' from ' + e.origin);\\n\"\n\t\t\t\"        if (e.origin !== targetOrigin ) {\\n\"\n\t\t\t\"          console.log('receiveMessage: cross-site scripting attack?');\\n\"\n\t\t\t\"          return;\\n\"\n\t\t\t\"        }\\n\"\n\t\t\t\"        if (e.data != 'unchanged') {\\n\"\n\t\t\t\"          clearInterval(timerID);\\n\"\n\t\t\t\"          if (e.data == 'changed') {\\n\"\n\t\t\t\"\t\t     window.location.href = '%s?session=check';\\n\"\n\t\t\t\"          } else {\\n\"\n\t\t\t\"\t\t     window.location.href = '%s?session=logout';\\n\"\n\t\t\t\"          }\\n\"\n\t\t\t\"        }\\n\"\n\t\t\t\"      }\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"      window.addEventListener('message', receiveMessage, false);\\n\"\n\t\t\t\"\\n\"\n\t\t\t\"    </script>\\n\";\n\n\t/* determine the origin for the check_session_iframe endpoint */\n\tchar *origin = apr_pstrdup(r->pool, check_session_iframe);\n\tapr_uri_t uri;\n\tapr_uri_parse(r->pool, check_session_iframe, &uri);\n\tchar *p = strstr(origin, uri.path);\n\t*p = '\\0';\n\n\t/* the element identifier for the OP iframe */\n\tconst char *op_iframe_id = \"openidc-op\";\n\n\t/* restore the OP session_state from the session */\n\tconst char *session_state = NULL;\n\toidc_session_get(r, session, OIDC_SESSION_STATE_SESSION_KEY,\n\t\t\t&session_state);\n\tif (session_state == NULL) {\n\t\toidc_warn(r,\n\t\t\t\t\"no session_state found in the session; the OP does probably not support session management!?\");\n\t\treturn DONE;\n\t}\n\n\tchar *s_poll_interval = NULL;\n\toidc_util_get_request_parameter(r, \"poll\", &s_poll_interval);\n\tif (s_poll_interval == NULL)\n\t\ts_poll_interval = \"3000\";\n\n\tjava_script = apr_psprintf(r->pool, java_script, origin, client_id,\n\t\t\tsession_state, op_iframe_id, s_poll_interval, c->redirect_uri,\n\t\t\tc->redirect_uri);\n\n\treturn oidc_util_html_send(r, NULL, java_script, \"setTimer\", NULL, DONE);\n}\n\n/*\n * handle session management request\n */\nstatic int oidc_handle_session_management(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\tchar *cmd = NULL;\n\tconst char *id_token_hint = NULL, *client_id = NULL, *check_session_iframe =\n\t\t\tNULL;\n\toidc_provider_t *provider = NULL;\n\n\t/* get the command passed to the session management handler */\n\toidc_util_get_request_parameter(r, \"session\", &cmd);\n\tif (cmd == NULL) {\n\t\toidc_error(r, \"session management handler called with no command\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* see if this is a local logout during session management */\n\tif (apr_strnatcmp(\"logout\", cmd) == 0) {\n\t\toidc_debug(r,\n\t\t\t\t\"[session=logout] calling oidc_handle_logout_request because of session mgmt local logout call.\");\n\t\treturn oidc_handle_logout_request(r, c, session, c->default_slo_url);\n\t}\n\n\t/* see if this is a request for the OP iframe */\n\tif (apr_strnatcmp(\"iframe_op\", cmd) == 0) {\n\t\toidc_session_get(r, session, OIDC_CHECK_IFRAME_SESSION_KEY,\n\t\t\t\t&check_session_iframe);\n\t\tif (check_session_iframe != NULL) {\n\t\t\treturn oidc_handle_session_management_iframe_op(r, c, session,\n\t\t\t\t\tcheck_session_iframe);\n\t\t}\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* see if this is a request for the RP iframe */\n\tif (apr_strnatcmp(\"iframe_rp\", cmd) == 0) {\n\t\toidc_session_get(r, session, OIDC_CLIENTID_SESSION_KEY, &client_id);\n\t\toidc_session_get(r, session, OIDC_CHECK_IFRAME_SESSION_KEY,\n\t\t\t\t&check_session_iframe);\n\t\tif ((client_id != NULL) && (check_session_iframe != NULL)) {\n\t\t\treturn oidc_handle_session_management_iframe_rp(r, c, session,\n\t\t\t\t\tclient_id, check_session_iframe);\n\t\t}\n\t\toidc_debug(r,\n\t\t\t\t\"iframe_rp command issued but no client (%s) and/or no check_session_iframe (%s) set\",\n\t\t\t\tclient_id, check_session_iframe);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* see if this is a request check the login state with the OP */\n\tif (apr_strnatcmp(\"check\", cmd) == 0) {\n\t\toidc_session_get(r, session, OIDC_IDTOKEN_SESSION_KEY, &id_token_hint);\n\t\toidc_get_provider_from_session(r, c, session, &provider);\n\t\tif ((session->remote_user != NULL) && (provider != NULL)) {\n\t\t\treturn oidc_authenticate_user(r, c, provider,\n\t\t\t\t\tapr_psprintf(r->pool, \"%s?session=iframe_rp\",\n\t\t\t\t\t\t\tc->redirect_uri), NULL, id_token_hint, \"none\", NULL);\n\t\t}\n\t\toidc_debug(r,\n\t\t\t\t\"[session=check] calling oidc_handle_logout_request because no session found.\");\n\t\treturn oidc_session_redirect_parent_window_to_logout(r, c);\n\t}\n\n\t/* handle failure in fallthrough */\n\toidc_error(r, \"unknown command: %s\", cmd);\n\n\treturn HTTP_INTERNAL_SERVER_ERROR;\n}\n\n/*\n * handle refresh token request\n */\nstatic int oidc_handle_refresh_token_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\tchar *return_to = NULL;\n\tchar *r_access_token = NULL;\n\tchar *error_code = NULL;\n\n\t/* get the command passed to the session management handler */\n\toidc_util_get_request_parameter(r, \"refresh\", &return_to);\n\toidc_util_get_request_parameter(r, \"access_token\", &r_access_token);\n\n\t/* check the input parameters */\n\tif (return_to == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"refresh token request handler called with no URL to return to\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif (r_access_token == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"refresh token request handler called with no access_token parameter\");\n\t\terror_code = \"no_access_token\";\n\t\tgoto end;\n\t}\n\n\tchar *s_access_token = NULL;\n\toidc_session_get(r, session, OIDC_ACCESSTOKEN_SESSION_KEY,\n\t\t\t(const char **) &s_access_token);\n\tif (s_access_token == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"no existing access_token found in the session, nothing to refresh\");\n\t\terror_code = \"no_access_token_exists\";\n\t\tgoto end;\n\t}\n\n\t/* compare the access_token parameter used for XSRF protection */\n\tif (apr_strnatcmp(s_access_token, r_access_token) != 0) {\n\t\toidc_error(r,\n\t\t\t\t\"access_token passed in refresh request does not match the one stored in the session\");\n\t\terror_code = \"no_access_token_match\";\n\t\tgoto end;\n\t}\n\n\t/* get a handle to the provider configuration */\n\toidc_provider_t *provider = NULL;\n\tif (oidc_get_provider_from_session(r, c, session, &provider) == FALSE) {\n\t\terror_code = \"session_corruption\";\n\t\tgoto end;\n\t}\n\n\t/* execute the actual refresh grant */\n\tif (oidc_refresh_access_token(r, c, session, provider, NULL) == FALSE) {\n\t\toidc_error(r, \"access_token could not be refreshed\");\n\t\terror_code = \"refresh_failed\";\n\t\tgoto end;\n\t}\n\n\t/* store the session */\n\tif (oidc_session_save(r, session) == FALSE) {\n\t\terror_code = \"session_corruption\";\n\t\tgoto end;\n\t}\n\nend:\n\n\t/* pass optional error message to the return URL */\n\tif (error_code != NULL)\n\t\treturn_to = apr_psprintf(r->pool, \"%s%serror_code=%s\", return_to,\n\t\t\t\tstrchr(return_to, '?') ? \"&\" : \"?\",\n\t\t\t\t\t\toidc_util_escape_string(r, error_code));\n\n\t/* add the redirect location header */\n\tapr_table_add(r->headers_out, \"Location\", return_to);\n\n\treturn HTTP_MOVED_TEMPORARILY;\n}\n\n/*\n * handle request object by reference request\n */\nstatic int oidc_handle_request_uri(request_rec *r, oidc_cfg *c) {\n\n\tchar *request_ref = NULL;\n\toidc_util_get_request_parameter(r, \"request_uri\", &request_ref);\n\tif (request_ref == NULL) {\n\t\toidc_error(r, \"no \\\"request_uri\\\" parameter found\");\n\t\treturn HTTP_BAD_REQUEST;\n\t}\n\n\tconst char *jwt = NULL;\n\tc->cache->get(r, OIDC_CACHE_SECTION_REQUEST_URI, request_ref, &jwt);\n\tif (jwt == NULL) {\n\t\toidc_error(r, \"no cached JWT found for request_uri reference: %s\",\n\t\t\t\trequest_ref);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\tc->cache->set(r, OIDC_CACHE_SECTION_REQUEST_URI, request_ref, NULL, 0);\n\n\treturn oidc_util_http_send(r, jwt, strlen(jwt), \" application/jwt\", DONE);\n}\n\n/*\n * handle a request to invalidate a cached access token introspection result\n */\nstatic int oidc_handle_remove_at_cache(request_rec *r, oidc_cfg *c) {\n\tchar *access_token = NULL;\n\toidc_util_get_request_parameter(r, \"remove_at_cache\", &access_token);\n\n\tconst char *cache_entry = NULL;\n\tc->cache->get(r, OIDC_CACHE_SECTION_ACCESS_TOKEN, access_token, &cache_entry);\n\tif (cache_entry == NULL) {\n\t\toidc_error(r, \"no cached access token found for value: %s\", access_token);\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\tc->cache->set(r, OIDC_CACHE_SECTION_ACCESS_TOKEN, access_token, NULL, 0);\n\n\treturn DONE;\n}\n\n/*\n * handle all requests to the redirect_uri\n */\nint oidc_handle_redirect_uri_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\n\tif (oidc_proto_is_redirect_authorization_response(r, c)) {\n\n\t\t/* this is an authorization response from the OP using the Basic Client profile or a Hybrid flow*/\n\t\treturn oidc_handle_redirect_authorization_response(r, c, session);\n\n\t} else if (oidc_proto_is_post_authorization_response(r, c)) {\n\n\t\t/* this is an authorization response using the fragment(+POST) response_mode with the Implicit Client profile */\n\t\treturn oidc_handle_post_authorization_response(r, c, session);\n\n\t} else if (oidc_is_discovery_response(r, c)) {\n\n\t\t/* this is response from the OP discovery page */\n\t\treturn oidc_handle_discovery_response(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r, \"logout\")) {\n\n\t\t/* handle logout */\n\t\treturn oidc_handle_logout(r, c, session);\n\n\t} else if (oidc_util_request_has_parameter(r, \"jwks\")) {\n\n\t\t/* handle JWKs request */\n\t\treturn oidc_handle_jwks(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r, \"session\")) {\n\n\t\t/* handle session management request */\n\t\treturn oidc_handle_session_management(r, c, session);\n\n\t} else if (oidc_util_request_has_parameter(r, \"refresh\")) {\n\n\t\t/* handle refresh token request */\n\t\treturn oidc_handle_refresh_token_request(r, c, session);\n\n\t} else if (oidc_util_request_has_parameter(r, \"request_uri\")) {\n\n\t\t/* handle request object by reference request */\n\t\treturn oidc_handle_request_uri(r, c);\n\n\t} else if (oidc_util_request_has_parameter(r, \"remove_at_cache\")) {\n\n\t\t/* handle request to invalidate access token cache */\n\t\treturn oidc_handle_remove_at_cache(r, c);\n\n\t} else if ((r->args == NULL) || (apr_strnatcmp(r->args, \"\") == 0)) {\n\n\t\t/* this is a \"bare\" request to the redirect URI, indicating implicit flow using the fragment response_mode */\n\t\treturn oidc_proto_javascript_implicit(r, c);\n\t}\n\n\t/* this is not an authorization response or logout request */\n\n\t/* check for \"error\" response */\n\tif (oidc_util_request_has_parameter(r, \"error\")) {\n\n//\t\tchar *error = NULL, *descr = NULL;\n//\t\toidc_util_get_request_parameter(r, \"error\", &error);\n//\t\toidc_util_get_request_parameter(r, \"error_description\", &descr);\n//\n//\t\t/* send user facing error to browser */\n//\t\treturn oidc_util_html_send_error(r, error, descr, DONE);\n\t\toidc_handle_redirect_authorization_response(r, c, session);\n\t}\n\n\t/* something went wrong */\n\treturn oidc_util_html_send_error(r, c->error_template, \"Invalid Request\",\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"The OpenID Connect callback URL received an invalid request\"),\n\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n}\n\n/*\n * main routine: handle OpenID Connect authentication\n */\nstatic int oidc_check_userid_openidc(request_rec *r, oidc_cfg *c) {\n\n\tif (c->redirect_uri == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"configuration error: the authentication type is set to \\\"openid-connect\\\" but OIDCRedirectURI has not been set\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* check if this is a sub-request or an initial request */\n\tif (ap_is_initial_req(r)) {\n\n\t\tint rc = OK;\n\n\t\t/* load the session from the request state; this will be a new \"empty\" session if no state exists */\n\t\toidc_session_t *session = NULL;\n\t\toidc_session_load(r, &session);\n\n\t\t/* see if the initial request is to the redirect URI; this handles potential logout too */\n\t\tif (oidc_util_request_matches_url(r, c->redirect_uri)) {\n\n\t\t\t/* handle request to the redirect_uri */\n\t\t\trc = oidc_handle_redirect_uri_request(r, c, session);\n\n\t\t\t/* free resources allocated for the session */\n\t\t\toidc_session_free(r, session);\n\n\t\t\treturn rc;\n\n\t\t/* initial request to non-redirect URI, check if we have an existing session */\n\t\t} else if (session->remote_user != NULL) {\n\n\t\t\t/* set the user in the main request for further (incl. sub-request) processing */\n\t\t\tr->user = (char *) session->remote_user;\n\n\t\t\t/* this is initial request and we already have a session */\n\t\t\trc = oidc_handle_existing_session(r, c, session);\n\n\t\t\t/* free resources allocated for the session */\n\t\t\toidc_session_free(r, session);\n\n\t\t\t/* strip any cookies that we need to */\n\t\t\toidc_strip_cookies(r);\n\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* free resources allocated for the session */\n\t\toidc_session_free(r, session);\n\n\t\t/*\n\t\t * else: initial request, we have no session and it is not an authorization or\n\t\t *       discovery response: just hit the default flow for unauthenticated users\n\t\t */\n\t} else {\n\n\t\t/* not an initial request, try to recycle what we've already established in the main request */\n\t\tif (r->main != NULL)\n\t\t\tr->user = r->main->user;\n\t\telse if (r->prev != NULL)\n\t\t\tr->user = r->prev->user;\n\n\t\tif (r->user != NULL) {\n\n\t\t\t/* this is a sub-request and we have a session (headers will have been scrubbed and set already) */\n\t\t\toidc_debug(r,\n\t\t\t\t\t\"recycling user '%s' from initial request for sub-request\",\n\t\t\t\t\tr->user);\n\n\t\t\t/*\n\t\t\t * apparently request state can get lost in sub-requests, so let's see\n\t\t\t * if we need to restore id_token and/or claims from the session cache\n\t\t\t */\n\t\t\tconst char *s_id_token = oidc_request_state_get(r,\n\t\t\t\t\tOIDC_IDTOKEN_CLAIMS_SESSION_KEY);\n\t\t\tif (s_id_token == NULL) {\n\n\t\t\t\toidc_session_t *session = NULL;\n\t\t\t\toidc_session_load(r, &session);\n\n\t\t\t\toidc_copy_tokens_to_request_state(r, session, NULL, NULL);\n\n\t\t\t\t/* free resources allocated for the session */\n\t\t\t\toidc_session_free(r, session);\n\t\t\t}\n\n\t\t\t/* strip any cookies that we need to */\n\t\t\toidc_strip_cookies(r);\n\n\t\t\treturn OK;\n\t\t}\n\t\t/*\n\t\t * else: not initial request, but we could not find a session, so:\n\t\t * just hit the default flow for unauthenticated users\n\t\t */\n\t}\n\n\t/* find out which action we need to take when encountering an unauthenticated request */\n\tswitch (oidc_dir_cfg_unauth_action(r)) {\n\t\tcase OIDC_UNAUTH_RETURN410:\n\t\t\treturn HTTP_GONE;\n\t\tcase OIDC_UNAUTH_RETURN401:\n\t\t\treturn HTTP_UNAUTHORIZED;\n\t\tcase OIDC_UNAUTH_PASS:\n\t\t\tr->user = \"\";\n\t\t\treturn OK;\n\t\tcase OIDC_UNAUTH_AUTHENTICATE:\n\t\t\t/* if this is a Javascript path we won't redirect the user and create a state cookie */\n\t\t\tif (apr_table_get(r->headers_in, \"X-Requested-With\") != NULL)\n\t\t\t\treturn HTTP_UNAUTHORIZED;\n\t\t\tbreak;\n\t}\n\n\t/* else: no session (regardless of whether it is main or sub-request), go and authenticate the user */\n\treturn oidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, NULL);\n}\n\n/*\n * generic Apache authentication hook for this module: dispatches to OpenID Connect or OAuth 2.0 specific routines\n */\nint oidc_check_user_id(request_rec *r) {\n\n\toidc_cfg *c = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\t/* log some stuff about the incoming HTTP request */\n\toidc_debug(r, \"incoming request: \\\"%s?%s\\\", ap_is_initial_req(r)=%d\",\n\t\t\tr->parsed_uri.path, r->args, ap_is_initial_req(r));\n\n\t/* see if any authentication has been defined at all */\n\tif (ap_auth_type(r) == NULL)\n\t\treturn DECLINED;\n\n\t/* see if we've configured OpenID Connect user authentication for this request */\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r), \"openid-connect\")\n\t\t\t== 0)\n\t\treturn oidc_check_userid_openidc(r, c);\n\n\t/* see if we've configured OAuth 2.0 access control for this request */\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r), \"oauth20\") == 0)\n\t\treturn oidc_oauth_check_userid(r, c);\n\n\t/* this is not for us but for some other handler */\n\treturn DECLINED;\n}\n\n/*\n * get the claims and id_token from request state\n */\nstatic void oidc_authz_get_claims_and_idtoken(request_rec *r, json_t **claims,\n\t\tjson_t **id_token) {\n\tconst char *s_claims = oidc_request_state_get(r, OIDC_CLAIMS_SESSION_KEY);\n\tconst char *s_id_token = oidc_request_state_get(r,\n\t\t\tOIDC_IDTOKEN_CLAIMS_SESSION_KEY);\n\tjson_error_t json_error;\n\tif (s_claims != NULL) {\n\t\t*claims = json_loads(s_claims, 0, &json_error);\n\t\tif (*claims == NULL) {\n\t\t\toidc_error(r, \"could not restore claims from request state: %s\",\n\t\t\t\t\tjson_error.text);\n\t\t}\n\t}\n\tif (s_id_token != NULL) {\n\t\t*id_token = json_loads(s_id_token, 0, &json_error);\n\t\tif (*id_token == NULL) {\n\t\t\toidc_error(r, \"could not restore id_token from request state: %s\",\n\t\t\t\t\tjson_error.text);\n\t\t}\n\t}\n}\n\n#if MODULE_MAGIC_NUMBER_MAJOR >= 20100714\n/*\n * generic Apache >=2.4 authorization hook for this module\n * handles both OpenID Connect or OAuth 2.0 in the same way, based on the claims stored in the session\n */\nauthz_status oidc_authz_checker(request_rec *r, const char *require_args, const void *parsed_require_args) {\n\n\t/* check for anonymous access and PASS mode */\n\tif (r->user != NULL && strlen(r->user) == 0) {\n\t\tr->user = NULL;\n\t\tif (oidc_dir_cfg_unauth_action(r) == OIDC_UNAUTH_PASS) return AUTHZ_GRANTED;\n\t}\n\n\t/* get the set of claims from the request state (they've been set in the authentication part earlier */\n\tjson_t *claims = NULL, *id_token = NULL;\n\toidc_authz_get_claims_and_idtoken(r, &claims, &id_token);\n\n\t/* merge id_token claims (e.g. \"iss\") in to claims json object */\n\tif (claims)\n\t\toidc_util_json_merge(id_token, claims);\n\n\t/* dispatch to the >=2.4 specific authz routine */\n\tauthz_status rc = oidc_authz_worker24(r, claims ? claims : id_token, require_args);\n\n\t/* cleanup */\n\tif (claims) json_decref(claims);\n\tif (id_token) json_decref(id_token);\n\n\tif ((rc == AUTHZ_DENIED) && ap_auth_type(r)\n\t\t\t&& (apr_strnatcasecmp((const char *) ap_auth_type(r), \"oauth20\")\n\t\t\t\t\t== 0))\n\t\toidc_oauth_return_www_authenticate(r, \"insufficient_scope\", \"Different scope(s) or other claims required\");\n\n\treturn rc;\n}\n#else\n/*\n * generic Apache <2.4 authorization hook for this module\n * handles both OpenID Connect and OAuth 2.0 in the same way, based on the claims stored in the request context\n */\nint oidc_auth_checker(request_rec *r) {\n\n\t/* check for anonymous access and PASS mode */\n\tif (r->user != NULL && strlen(r->user) == 0) {\n\t\tr->user = NULL;\n\t\tif (oidc_dir_cfg_unauth_action(r) == OIDC_UNAUTH_PASS)\n\t\t\treturn OK;\n\t}\n\n\t/* get the set of claims from the request state (they've been set in the authentication part earlier */\n\tjson_t *claims = NULL, *id_token = NULL;\n\toidc_authz_get_claims_and_idtoken(r, &claims, &id_token);\n\n\t/* get the Require statements */\n\tconst apr_array_header_t * const reqs_arr = ap_requires(r);\n\n\t/* see if we have any */\n\tconst require_line * const reqs =\n\t\t\treqs_arr ? (require_line *) reqs_arr->elts : NULL;\n\tif (!reqs_arr) {\n\t\toidc_debug(r,\n\t\t\t\t\"no require statements found, so declining to perform authorization.\");\n\t\treturn DECLINED;\n\t}\n\n\t/* merge id_token claims (e.g. \"iss\") in to claims json object */\n\tif (claims)\n\t\toidc_util_json_merge(id_token, claims);\n\n\t/* dispatch to the <2.4 specific authz routine */\n\tint rc = oidc_authz_worker(r, claims ? claims : id_token, reqs,\n\t\t\treqs_arr->nelts);\n\n\t/* cleanup */\n\tif (claims)\n\t\tjson_decref(claims);\n\tif (id_token)\n\t\tjson_decref(id_token);\n\n\tif ((rc == HTTP_UNAUTHORIZED) && ap_auth_type(r)\n\t\t\t&& (apr_strnatcasecmp((const char *) ap_auth_type(r), \"oauth20\")\n\t\t\t\t\t== 0))\n\t\toidc_oauth_return_www_authenticate(r, \"insufficient_scope\",\n\t\t\t\t\"Different scope(s) or other claims required\");\n\n\treturn rc;\n}\n#endif\n\nextern const command_rec oidc_config_cmds[];\n\nmodule AP_MODULE_DECLARE_DATA auth_openidc_module = {\n\t\tSTANDARD20_MODULE_STUFF,\n\t\toidc_create_dir_config,\n\t\toidc_merge_dir_config,\n\t\toidc_create_server_config,\n\t\toidc_merge_server_config,\n\t\toidc_config_cmds,\n\t\toidc_register_hooks\n};\n"], "filenames": ["ChangeLog", "src/mod_auth_openidc.c"], "buggy_code_start_loc": [0, 2848], "buggy_code_end_loc": [0, 2850], "fixing_code_start_loc": [1, 2848], "fixing_code_end_loc": [4, 2850], "type": "CWE-20", "message": "Mod_auth_openidc.c in the Ping Identity OpenID Connect authentication module for Apache (aka mod_auth_openidc) before 2.14 allows remote attackers to spoof page content via a malicious URL provided to the user, which triggers an invalid request.", "other": {"cve": {"id": "CVE-2017-6059", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-12T20:59:00.763", "lastModified": "2023-05-25T20:18:46.990", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Mod_auth_openidc.c in the Ping Identity OpenID Connect authentication module for Apache (aka mod_auth_openidc) before 2.14 allows remote attackers to spoof page content via a malicious URL provided to the user, which triggers an invalid request."}, {"lang": "es", "value": "Mod_auth_openidc.c en el m\u00f3dulo de autenticaci\u00f3n Ping Identity OpenID Connect para Apache (tambi\u00e9n conocido como mod_auth_openidc) en versiones anteriores a 2.14 permite a los atacantes remotos falsificar el contenido de la p\u00e1gina a trav\u00e9s de una URL malintencionada proporcionada al usuario, lo que desencadena una solicitud no v\u00e1lida."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openidc:mod_auth_openidc:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.4", "matchCriteriaId": "1296F955-6E42-43B5-846A-E8AAA7348301"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2017/02/17/6", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96299", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:2112", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/pingidentity/mod_auth_openidc/commit/612e309bfffd6f9b8ad7cdccda3019fc0865f3b4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pingidentity/mod_auth_openidc/issues/212", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/pingidentity/mod_auth_openidc/releases/tag/v2.1.4", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2V3HIGXMUKJGOBMAQAQPGC7G5YYWSUVA/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EJXBG3DG2FUYFGTUTSJFMPIINVFKKB4Z/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WTWUMQ46GZY3O4WU4JCF333LN53R2XQH/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pingidentity/mod_auth_openidc/commit/612e309bfffd6f9b8ad7cdccda3019fc0865f3b4"}}