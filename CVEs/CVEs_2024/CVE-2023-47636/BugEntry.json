{"buggy_code": ["<?php\ndeclare(strict_types=1);\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Admin\\Asset;\n\nuse League\\Flysystem\\FilesystemException;\nuse League\\Flysystem\\UnableToReadFile;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\AdminAbstractController;\nuse Pimcore\\Bundle\\AdminBundle\\Event\\AdminEvents;\nuse Pimcore\\Bundle\\AdminBundle\\Helper\\GridHelperService;\nuse Pimcore\\Bundle\\AdminBundle\\Model\\GridConfig;\nuse Pimcore\\Bundle\\AdminBundle\\Model\\GridConfigFavourite;\nuse Pimcore\\Bundle\\AdminBundle\\Model\\GridConfigShare;\nuse Pimcore\\Bundle\\AdminBundle\\Tool;\nuse Pimcore\\Db;\nuse Pimcore\\Loader\\ImplementationLoader\\Exception\\UnsupportedException;\nuse Pimcore\\Localization\\LocaleServiceInterface;\nuse Pimcore\\Logger;\nuse Pimcore\\Model\\Asset;\nuse Pimcore\\Model\\Element;\nuse Pimcore\\Model\\Metadata;\nuse Pimcore\\Model\\User;\nuse Pimcore\\Security\\SecurityHelper;\nuse Pimcore\\Tool\\Session;\nuse Pimcore\\Tool\\Storage;\nuse Pimcore\\Version;\nuse Symfony\\Component\\EventDispatcher\\GenericEvent;\nuse Symfony\\Component\\HttpFoundation\\BinaryFileResponse;\nuse Symfony\\Component\\HttpFoundation\\HeaderUtils;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\n\n/**\n * @Route(\"/asset-helper\")\n *\n * @internal\n */\nclass AssetHelperController extends AdminAbstractController\n{\n    public function __construct(\n        protected EventDispatcherInterface $eventDispatcher,\n    ) {\n    }\n\n    public function getMyOwnGridColumnConfigs(int $userId, string $classId, string $searchType): array\n    {\n        $db = Db::get();\n        $configListingConditionParts = [];\n        $configListingConditionParts[] = 'ownerId = ' . $userId;\n        $configListingConditionParts[] = 'classId = ' . $db->quote($classId);\n\n        if ($searchType) {\n            $configListingConditionParts[] = 'searchType = ' . $db->quote($searchType);\n        }\n\n        $configCondition = implode(' AND ', $configListingConditionParts);\n        $configListing = new GridConfig\\Listing();\n        $configListing->setOrderKey('name');\n        $configListing->setOrder('ASC');\n        $configListing->setCondition($configCondition);\n        $configListing = $configListing->load();\n\n        $configData = [];\n        if (is_array($configListing)) {\n            foreach ($configListing as $config) {\n                $configData[] = $config->getObjectVars();\n            }\n        }\n\n        return $configData;\n    }\n\n    /**\n     * @param User $user\n     * @param string $classId\n     * @param string|null $searchType\n     *\n     * @return array\n     */\n    public function getSharedGridColumnConfigs(User $user, string $classId, string $searchType = null): array\n    {\n        $db = Db::get();\n\n        $configListing = [];\n\n        $userIds = [$user->getId()];\n        // collect all roles\n        $userIds = array_merge($userIds, $user->getRoles());\n        $userIds = implode(',', $userIds);\n\n        $query = 'select distinct c1.id from gridconfigs c1, gridconfig_shares s\n                    where (c1.searchType = ' . $db->quote($searchType) . ' and ((c1.id = s.gridConfigId and s.sharedWithUserId IN (' . $userIds . '))) and c1.classId = ' . $db->quote($classId) . ')\n                            UNION distinct select c2.id from gridconfigs c2 where shareGlobally = 1 and c2.classId = '. $db->quote($classId) . '  and c2.ownerId != ' . $db->quote($user->getId());\n\n        $ids = $db->fetchFirstColumn($query);\n\n        if ($ids) {\n            $ids = implode(',', $ids);\n            $configListing = new GridConfig\\Listing();\n            $configListing->setOrderKey('name');\n            $configListing->setOrder('ASC');\n            $configListing->setCondition('id in (' . $ids . ')');\n            $configListing = $configListing->load();\n        }\n\n        $configData = [];\n        if (is_array($configListing)) {\n            foreach ($configListing as $config) {\n                $configData[] = $config->getObjectVars();\n            }\n        }\n\n        return $configData;\n    }\n\n    /**\n     * @Route(\"/grid-delete-column-config\", name=\"pimcore_admin_asset_assethelper_griddeletecolumnconfig\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridDeleteColumnConfigAction(Request $request): JsonResponse\n    {\n        $gridConfigId = (int) $request->get('gridConfigId');\n        $gridConfig = GridConfig::getById($gridConfigId);\n        $success = false;\n        if ($gridConfig) {\n            if ($gridConfig->getOwnerId() != $this->getAdminUser()->getId()) {\n                throw new \\Exception(\"don't mess with someone elses grid config\");\n            }\n\n            $gridConfig->delete();\n            $success = true;\n        }\n\n        $newGridConfig = $this->doGetGridColumnConfig($request, true);\n        $newGridConfig['deleteSuccess'] = $success;\n\n        return $this->adminJson($newGridConfig);\n    }\n\n    /**\n     * @Route(\"/grid-get-column-config\", name=\"pimcore_admin_asset_assethelper_gridgetcolumnconfig\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridGetColumnConfigAction(Request $request): JsonResponse\n    {\n        $result = $this->doGetGridColumnConfig($request);\n\n        return $this->adminJson($result);\n    }\n\n    public function doGetGridColumnConfig(Request $request, bool $isDelete = false): array\n    {\n        $gridConfigId = null;\n\n        $classId = $request->get('id');\n        $type = $request->get('type');\n\n        $context = ['purpose' => 'gridconfig'];\n\n        $types = [];\n        if ($request->get('types')) {\n            $types = explode(',', $request->get('types'));\n        }\n\n        $userId = $this->getAdminUser()->getId();\n\n        $requestedGridConfigId = $isDelete ? '' : $request->get('gridConfigId', '');\n\n        // grid config\n        $gridConfig = [];\n        $searchType = $request->get('searchType');\n\n        if (strlen($requestedGridConfigId) == 0) {\n            // check if there is a favourite view\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId($userId, $classId, 0, $searchType);\n\n            if ($favourite) {\n                $requestedGridConfigId = $favourite->getGridConfigId();\n            }\n        }\n\n        if (is_numeric($requestedGridConfigId) && $requestedGridConfigId > 0) {\n            $db = Db::get();\n            $savedGridConfig = GridConfig::getById((int) $requestedGridConfigId);\n\n            if ($savedGridConfig) {\n                $shared = null;\n\n                try {\n                    $userIds = [$this->getAdminUser()->getId()];\n                    $userIds = array_merge($userIds, $this->getAdminUser()->getRoles());\n                    $userIds = implode(',', $userIds);\n                    $shared = ($savedGridConfig->getOwnerId() != $userId && $savedGridConfig->isShareGlobally()) || $db->fetchOne('select * from gridconfig_shares where sharedWithUserId IN (' . $userIds . ') and gridConfigId = ' . $savedGridConfig->getId());\n                } catch (\\Exception $e) {\n                }\n\n                if (!$shared && $savedGridConfig->getOwnerId() != $this->getAdminUser()->getId()) {\n                    throw new \\Exception('You are neither the owner of this config nor it is shared with you');\n                }\n                $gridConfigId = $savedGridConfig->getId();\n                $gridConfig = $savedGridConfig->getConfig();\n                $gridConfig = json_decode($gridConfig, true);\n                $gridConfigName = $savedGridConfig->getName();\n                $gridConfigDescription = $savedGridConfig->getDescription();\n                $sharedGlobally = $savedGridConfig->isShareGlobally();\n                $setAsFavourite = $savedGridConfig->isSetAsFavourite();\n            }\n        }\n\n        $availableFields = [];\n        $language = '';\n\n        if (empty($gridConfig)) {\n            $availableFields = $this->getDefaultGridFields(\n                $request->query->getBoolean('no_system_columns'),\n                [], //maybe required for types other than metadata\n                $context,\n                $types\n            );\n        } else {\n            $savedColumns = $gridConfig['columns'];\n\n            foreach ($savedColumns as $key => $sc) {\n                if (!$sc['hidden']) {\n                    $colConfig = $this->getFieldGridConfig($sc, $language, null);\n                    if ($colConfig) {\n                        $availableFields[] = $colConfig;\n                    }\n                }\n            }\n        }\n        usort($availableFields, function ($a, $b) {\n            if ($a['position'] == $b['position']) {\n                return 0;\n            }\n\n            return ($a['position'] < $b['position']) ? -1 : 1;\n        });\n\n        $availableConfigs = $classId ? $this->getMyOwnGridColumnConfigs($userId, $classId, $searchType) : [];\n        $sharedConfigs = $classId ? $this->getSharedGridColumnConfigs($this->getAdminUser(), $classId, $searchType) : [];\n        $settings = $this->getShareSettings((int)$gridConfigId);\n        $settings['gridConfigId'] = (int)$gridConfigId;\n        $settings['gridConfigName'] = $gridConfigName ?? null;\n        $settings['gridConfigDescription'] = $gridConfigDescription ?? null;\n        $settings['shareGlobally'] = $sharedGlobally ?? null;\n        $settings['setAsFavourite'] = $setAsFavourite ?? null;\n        $settings['isShared'] = !$gridConfigId || ($shared ?? null);\n\n        $context = $gridConfig['context'] ?? null;\n        if ($context) {\n            $context = json_decode($context, true);\n        }\n\n        return [\n            'sortinfo' => isset($gridConfig['sortinfo']) ? $gridConfig['sortinfo'] : false,\n            'availableFields' => $availableFields,\n            'settings' => $settings,\n            'onlyDirectChildren' => isset($gridConfig['onlyDirectChildren']) ? $gridConfig['onlyDirectChildren'] : false,\n            'onlyUnreferenced' => isset($gridConfig['onlyUnreferenced']) ? $gridConfig['onlyUnreferenced'] : false,\n            'pageSize' => isset($gridConfig['pageSize']) ? $gridConfig['pageSize'] : false,\n            'availableConfigs' => $availableConfigs,\n            'sharedConfigs' => $sharedConfigs,\n            'context' => $context,\n        ];\n    }\n\n    /**\n     * @param array $field\n     * @param string $language\n     * @param string|null $keyPrefix\n     *\n     * @return array|null\n     */\n    protected function getFieldGridConfig(array $field, string $language = '', string $keyPrefix = null): ?array\n    {\n        $defaulMetadataFields = ['copyright', 'alt', 'title'];\n        $predefined = null;\n\n        if (isset($field['fieldConfig']['layout']['name'])) {\n            $predefined = Metadata\\Predefined::getByName($field['fieldConfig']['layout']['name']);\n        }\n\n        $key = $field['name'];\n        if ($keyPrefix) {\n            $key = $keyPrefix . $key;\n        }\n        $fieldDef = explode('~', $field['name']);\n        $field['name'] = $fieldDef[0];\n\n        if (isset($fieldDef[1]) && $fieldDef[1] === 'system') {\n            $type = 'system';\n        } elseif (in_array($fieldDef[0], $defaulMetadataFields)) {\n            $type = 'input';\n        } else {\n            $type = $field['fieldConfig']['type'];\n            if (isset($fieldDef[1])) {\n                $field['fieldConfig']['label'] = $field['fieldConfig']['layout']['title'] = $fieldDef[0] . ' (' . $fieldDef[1] . ')';\n                $field['fieldConfig']['layout']['icon'] = Tool::getLanguageFlagFile($fieldDef[1], true);\n            }\n        }\n\n        $result = [\n            'key' => $key,\n            'type' => $type,\n            'label' => $field['fieldConfig']['label'] ?? $key,\n            'width' => $field['width'],\n            'position' => $field['position'],\n            'language' => $field['fieldConfig']['language'] ?? null,\n            'layout' => $field['fieldConfig']['layout'] ?? null,\n        ];\n\n        if (isset($field['locked'])) {\n            $result['locked'] = $field['locked'];\n        }\n\n        if ($type === 'select' && $predefined) {\n            $field['fieldConfig']['layout']['config'] = $predefined->getConfig();\n            $result['layout'] = $field['fieldConfig']['layout'];\n        } elseif ($type === 'document' || $type === 'asset' || $type === 'object') {\n            $result['layout']['fieldtype'] = 'manyToOneRelation';\n            $result['layout']['subtype'] = $type;\n        }\n\n        $assetGetFieldGridConfig = new GenericEvent($this, [\n            'field' => $field,\n            'result' => $result,\n        ]);\n\n        $this->eventDispatcher->dispatch($assetGetFieldGridConfig, AdminEvents::ASSET_GET_FIELD_GRID_CONFIG);\n        $result = $assetGetFieldGridConfig->getArgument('result');\n\n        return $result;\n    }\n\n    public function getDefaultGridFields(bool $noSystemColumns, array $fields, array $context, array $types = []): array\n    {\n        $count = 0;\n        $availableFields = [];\n\n        if (!$noSystemColumns) {\n            foreach (Asset\\Service::GRID_SYSTEM_COLUMNS as $sc) {\n                if (empty($types)) {\n                    $availableFields[] = [\n                        'key' => $sc . '~system',\n                        'type' => 'system',\n                        'label' => $sc,\n                        'position' => $count, ];\n                    $count++;\n                }\n            }\n        }\n\n        return $availableFields;\n    }\n\n    /**\n     * @Route(\"/prepare-helper-column-configs\", name=\"pimcore_admin_asset_assethelper_preparehelpercolumnconfigs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function prepareHelperColumnConfigs(Request $request): JsonResponse\n    {\n        $helperColumns = [];\n        $newData = [];\n        $data = json_decode($request->get('columns'));\n        /** @var \\stdClass $item */\n        foreach ($data as $item) {\n            if (!empty($item->isOperator)) {\n                $itemKey = '#' . uniqid();\n\n                $item->key = $itemKey;\n                $newData[] = $item;\n                $helperColumns[$itemKey] = $item;\n            } else {\n                $newData[] = $item;\n            }\n        }\n\n        Session::useBag($request->getSession(), function (AttributeBagInterface $session) use ($helperColumns) {\n            $existingColumns = $session->get('helpercolumns', []);\n            $helperColumns = array_merge($helperColumns, $existingColumns);\n            $session->set('helpercolumns', $helperColumns);\n        }, 'pimcore_gridconfig');\n\n        return $this->adminJson(['success' => true, 'columns' => $newData]);\n    }\n\n    /**\n     * @Route(\"/grid-mark-favourite-column-config\", name=\"pimcore_admin_asset_assethelper_gridmarkfavouritecolumnconfig\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridMarkFavouriteColumnConfigAction(Request $request): JsonResponse\n    {\n        $classId = $request->get('classId');\n        $asset = Asset::getById($classId);\n\n        if ($asset->isAllowed('list')) {\n            $gridConfigId = (int) $request->get('gridConfigId');\n            $searchType = $request->get('searchType');\n            $type = $request->get('type');\n            $user = $this->getAdminUser();\n\n            $favourite = new GridConfigFavourite();\n            $favourite->setOwnerId($user->getId());\n            $favourite->setClassId($classId);\n            $favourite->setSearchType($searchType);\n            $favourite->setType($type);\n            $specializedConfigs = false;\n\n            try {\n                if ($gridConfigId != 0) {\n                    $gridConfig = GridConfig::getById($gridConfigId);\n                    $favourite->setGridConfigId($gridConfig->getId());\n                }\n\n                $favourite->setObjectId(0);\n                $favourite->save();\n            } catch (\\Exception $e) {\n                $favourite->delete();\n            }\n\n            return $this->adminJson(['success' => true, 'spezializedConfigs' => $specializedConfigs]);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    protected function getShareSettings(int $gridConfigId): array\n    {\n        $result = [\n            'sharedUserIds' => [],\n            'sharedRoleIds' => [],\n        ];\n\n        $db = Db::get();\n        $allShares = $db->fetchAllAssociative('select s.sharedWithUserId, u.type from gridconfig_shares s, users u\n                      where s.sharedWithUserId = u.id and s.gridConfigId = ' . $gridConfigId);\n\n        if ($allShares) {\n            foreach ($allShares as $share) {\n                $type = $share['type'];\n                $key = 'shared' . ucfirst($type) . 'Ids';\n                $result[$key][] = $share['sharedWithUserId'];\n            }\n        }\n\n        foreach ($result as $idx => $value) {\n            $value = $value ? implode(',', $value) : '';\n            $result[$idx] = $value;\n        }\n\n        return $result;\n    }\n\n    /**\n     * @Route(\"/grid-save-column-config\", name=\"pimcore_admin_asset_assethelper_gridsavecolumnconfig\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridSaveColumnConfigAction(Request $request): JsonResponse\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException();\n        }\n\n        if ($asset->isAllowed('list')) {\n            try {\n                $classId = $request->get('class_id');\n                $context = $request->get('context');\n\n                $searchType = $request->get('searchType');\n                $type = $request->get('type');\n\n                // grid config\n                $gridConfigData = $this->decodeJson($request->get('gridconfig'));\n                $gridConfigData['pimcore_version'] = Version::getVersion();\n                $gridConfigData['pimcore_revision'] = Version::getRevision();\n                $gridConfigData['context'] = $context;\n                unset($gridConfigData['settings']['isShared']);\n\n                $metadata = $request->get('settings');\n                $metadata = json_decode($metadata, true);\n\n                $gridConfigId = $metadata['gridConfigId'];\n                $gridConfig = null;\n                if ($gridConfigId) {\n                    $gridConfig = GridConfig::getById($gridConfigId);\n                }\n\n                if ($gridConfig && $gridConfig->getOwnerId() != $this->getAdminUser()->getId()) {\n                    throw new \\Exception(\"don't mess around with somebody else's configuration\");\n                }\n\n                $this->updateGridConfigShares($gridConfig, $metadata);\n\n                if ($metadata['setAsFavourite'] && $this->getAdminUser()->isAdmin()) {\n                    $this->updateGridConfigFavourites($gridConfig, $metadata);\n                }\n\n                if (!$gridConfig) {\n                    $gridConfig = new GridConfig();\n                    $gridConfig->setName(date('c'));\n                    $gridConfig->setClassId($classId);\n                    $gridConfig->setSearchType($searchType);\n                    $gridConfig->setType($type);\n\n                    $gridConfig->setOwnerId($this->getAdminUser()->getId());\n                }\n\n                if ($metadata) {\n                    $gridConfig->setName($metadata['gridConfigName']);\n                    $gridConfig->setDescription($metadata['gridConfigDescription']);\n                    $gridConfig->setShareGlobally($metadata['shareGlobally'] && $this->getAdminUser()->isAdmin());\n                    $gridConfig->setSetAsFavourite($metadata['setAsFavourite'] && $this->getAdminUser()->isAdmin());\n                }\n\n                $gridConfigData = json_encode($gridConfigData);\n                $gridConfig->setConfig($gridConfigData);\n                $gridConfig->save();\n\n                $userId = $this->getAdminUser()->getId();\n\n                $availableConfigs = $this->getMyOwnGridColumnConfigs($userId, $classId, $searchType);\n                $sharedConfigs = $this->getSharedGridColumnConfigs($this->getAdminUser(), $classId, $searchType);\n\n                $settings = $this->getShareSettings($gridConfig->getId());\n                $settings['gridConfigId'] = (int)$gridConfig->getId();\n                $settings['gridConfigName'] = $gridConfig->getName();\n                $settings['gridConfigDescription'] = $gridConfig->getDescription();\n                $settings['shareGlobally'] = $gridConfig->isShareGlobally();\n                $settings['setAsFavourite'] = $gridConfig->isSetAsFavourite();\n                $settings['isShared'] = $gridConfig->getOwnerId() != $this->getAdminUser()->getId();\n\n                return $this->adminJson([\n                    'success' => true,\n                    'settings' => $settings,\n                    'availableConfigs' => $availableConfigs,\n                    'sharedConfigs' => $sharedConfigs,\n                ]);\n            } catch (\\Exception $e) {\n                return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n            }\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @param GridConfig|null $gridConfig\n     * @param array $metadata\n     *\n     * @throws \\Exception\n     */\n    protected function updateGridConfigShares(?GridConfig $gridConfig, array $metadata): void\n    {\n        $user = $this->getAdminUser();\n        if (!$gridConfig || !$user->isAllowed('share_configurations')) {\n            // nothing to do\n            return;\n        }\n\n        if ($gridConfig->getOwnerId() != $this->getAdminUser()->getId()) {\n            throw new \\Exception(\"don't mess with someone elses grid config\");\n        }\n        $combinedShares = [];\n        $sharedUserIds = $metadata['sharedUserIds'];\n        $sharedRoleIds = $metadata['sharedRoleIds'];\n\n        if ($sharedUserIds) {\n            $combinedShares = explode(',', $sharedUserIds);\n        }\n\n        if ($sharedRoleIds) {\n            $sharedRoleIds = explode(',', $sharedRoleIds);\n            $combinedShares = array_merge($combinedShares, $sharedRoleIds);\n        }\n\n        $db = Db::get();\n        $db->delete('gridconfig_shares', ['gridConfigId' => $gridConfig->getId()]);\n\n        foreach ($combinedShares as $id) {\n            $share = new GridConfigShare();\n            $share->setGridConfigId($gridConfig->getId());\n            $share->setSharedWithUserId((int) $id);\n            $share->save();\n        }\n    }\n\n    /**\n     * @param GridConfig|null $gridConfig\n     * @param array $metadata\n     *\n     * @throws \\Exception\n     */\n    protected function updateGridConfigFavourites(?GridConfig $gridConfig, array $metadata): void\n    {\n        $currentUser = $this->getAdminUser();\n\n        if (!$gridConfig || $currentUser === null || !$currentUser->isAllowed('share_configurations')) {\n            // nothing to do\n            return;\n        }\n\n        if (!$currentUser->isAdmin() && (int) $gridConfig->getOwnerId() !== $currentUser->getId()) {\n            throw new \\Exception(\"don't mess with someone elses grid config\");\n        }\n\n        $sharedUsers = [];\n\n        if ($metadata['shareGlobally'] === false) {\n            $sharedUserIds = $metadata['sharedUserIds'];\n\n            if ($sharedUserIds) {\n                $sharedUsers = explode(',', $sharedUserIds);\n            }\n        }\n\n        if ($metadata['shareGlobally'] === true) {\n            $users = new User\\Listing();\n            $users->setCondition('id = ?', $currentUser->getId());\n\n            foreach ($users as $user) {\n                $sharedUsers[] = $user->getId();\n            }\n        }\n\n        foreach ($sharedUsers as $id) {\n            // Check if the user has already a favourite\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId(\n                (int) $id,\n                $gridConfig->getClassId(),\n                0,\n                $gridConfig->getSearchType()\n            );\n\n            if ($favourite instanceof GridConfigFavourite) {\n                $favouriteGridConfig = GridConfig::getById($favourite->getGridConfigId());\n\n                if ($favouriteGridConfig instanceof GridConfig) {\n                    // Check if the grid config was shared globally if that is *not* the case we also not update\n                    if ($favouriteGridConfig->isShareGlobally() === false) {\n                        continue;\n                    }\n\n                    // Check if the user is the owner. If that is the case we do not update the favourite\n                    if ((int) $favouriteGridConfig->getOwnerId() === (int) $id) {\n                        continue;\n                    }\n                }\n            }\n\n            $favourite = new GridConfigFavourite();\n            $favourite->setGridConfigId($gridConfig->getId());\n            $favourite->setClassId($gridConfig->getClassId());\n            $favourite->setObjectId(0);\n            $favourite->setOwnerId($id);\n            $favourite->setType($gridConfig->getType());\n            $favourite->setSearchType($gridConfig->getSearchType());\n            $favourite->save();\n        }\n    }\n\n    /**\n     * @Route(\"/get-export-jobs\", name=\"pimcore_admin_asset_assethelper_getexportjobs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param GridHelperService $gridHelperService\n     *\n     * @return JsonResponse\n     */\n    public function getExportJobsAction(Request $request, GridHelperService $gridHelperService): JsonResponse\n    {\n        $allParams = array_merge($request->request->all(), $request->query->all());\n        $list = $gridHelperService->prepareAssetListingForGrid($allParams, $this->getAdminUser());\n\n        if (empty($ids = $allParams['ids'] ?? '')) {\n            $ids = $list->loadIdList();\n        }\n\n        $jobs = array_chunk($ids, 20);\n\n        $fileHandle = uniqid('asset-export-');\n        $storage = Storage::get('temp');\n        $storage->write($this->getCsvFile($fileHandle), '');\n\n        return $this->adminJson(['success' => true, 'jobs' => $jobs, 'fileHandle' => $fileHandle]);\n    }\n\n    /**\n     * @Route(\"/do-export\", name=\"pimcore_admin_asset_assethelper_doexport\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param LocaleServiceInterface $localeService\n     *\n     * @return JsonResponse\n     */\n    public function doExportAction(Request $request, LocaleServiceInterface $localeService): JsonResponse\n    {\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $ids = $request->get('ids');\n        $settings = $request->get('settings');\n        $settings = json_decode($settings, true);\n        $delimiter = $settings['delimiter'] ?? ';';\n        $language = str_replace('default', '', $request->get('language'));\n\n        $list = new Asset\\Listing();\n\n        $quotedIds = [];\n        foreach ($ids as $id) {\n            $quotedIds[] = $list->quote($id);\n        }\n\n        $list->setCondition('id IN (' . implode(',', $quotedIds) . ')');\n        $list->setOrderKey(' FIELD(id, ' . implode(',', $quotedIds) . ')', false);\n\n        $fields = $request->get('fields');\n\n        $addTitles = (bool) $request->get('initial');\n\n        $csv = $this->getCsvData($request, $language, $list, $fields, $addTitles);\n\n        $storage = Storage::get('temp');\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        $fileStream = $storage->readStream($csvFile);\n\n        $temp = tmpfile();\n        stream_copy_to_stream($fileStream, $temp, null, 0);\n\n        $firstLine = true;\n        foreach ($csv as $line) {\n            if ($addTitles && $firstLine) {\n                $firstLine = false;\n                $line = implode($delimiter, $line) . \"\\r\\n\";\n                fwrite($temp, $line);\n            } else {\n                fwrite($temp, implode($delimiter, array_map([$this, 'encodeFunc'], $line)) . \"\\r\\n\");\n            }\n        }\n\n        $storage->writeStream($csvFile, $temp);\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    public function encodeFunc(?string $value): string\n    {\n        $value = str_replace('\"', '\"\"', $value ?? '');\n\n        //force wrap value in quotes and return\n        return '\"' . $value . '\"';\n    }\n\n    protected function getCsvData(Request $request, string $language, Asset\\Listing $list, array $fields, bool $addTitles = true): array\n    {\n        //create csv\n        $csv = [];\n\n        $unsupportedFields = ['preview~system', 'size~system'];\n        $fields = array_diff($fields, $unsupportedFields);\n\n        if ($addTitles) {\n            $columns = $fields;\n            foreach ($columns as $columnIdx => $columnKey) {\n                $columns[$columnIdx] = '\"' . $columnKey . '\"';\n            }\n            $csv[] = $columns;\n        }\n\n        foreach ($list->load() as $asset) {\n            if ($fields) {\n                $dataRows = [];\n                foreach ($fields as $field) {\n                    $fieldDef = explode('~', $field);\n                    $getter = 'get' . ucfirst($fieldDef[0]);\n\n                    if (isset($fieldDef[1])) {\n                        if ($fieldDef[1] == 'system' && method_exists($asset, $getter)) {\n                            $data = $asset->$getter($language);\n                        } else {\n                            $fieldDef[1] = str_replace('none', '', $fieldDef[1]);\n                            $data = $asset->getMetadata($fieldDef[0], $fieldDef[1], true);\n                        }\n                    } else {\n                        $data = $asset->getMetadata($field, $language, true);\n                    }\n\n                    if ($data instanceof Element\\ElementInterface) {\n                        $data = $data->getRealFullPath();\n                    }\n                    $dataRows[] = $data;\n                }\n                $dataRows = Element\\Service::escapeCsvRecord($dataRows);\n                $csv[] = $dataRows;\n            }\n        }\n\n        return $csv;\n    }\n\n    protected function extractLanguage(Request $request): string\n    {\n        $requestedLanguage = $request->get('language');\n        if ($requestedLanguage) {\n            if ($requestedLanguage != 'default') {\n                $request->setLocale($requestedLanguage);\n            }\n        } else {\n            $requestedLanguage = $request->getLocale();\n        }\n\n        return $requestedLanguage;\n    }\n\n    protected function getCsvFile(string $fileHandle): string\n    {\n        return $fileHandle . '.csv';\n    }\n\n    /**\n     * @Route(\"/download-csv-file\", name=\"pimcore_admin_asset_assethelper_downloadcsvfile\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function downloadCsvFileAction(Request $request): Response\n    {\n        $storage = Storage::get('temp');\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        try {\n            $csvData = $storage->read($csvFile);\n            $response = new Response($csvData);\n            $response->headers->set('Content-Type', 'application/csv');\n            $disposition = HeaderUtils::makeDisposition(\n                HeaderUtils::DISPOSITION_ATTACHMENT,\n                'export.csv'\n            );\n\n            $response->headers->set('Content-Disposition', $disposition);\n            $storage->delete($csvFile);\n\n            return $response;\n        } catch (FilesystemException | UnableToReadFile $exception) {\n            // handle the error\n            throw $this->createNotFoundException('CSV file not found');\n        }\n    }\n\n    /**\n     * @Route(\"/download-xlsx-file\", name=\"pimcore_admin_asset_assethelper_downloadxlsxfile\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param GridHelperService $gridHelperService\n     *\n     * @return BinaryFileResponse\n     */\n    public function downloadXlsxFileAction(Request $request, GridHelperService $gridHelperService): BinaryFileResponse\n    {\n        $storage = Storage::get('temp');\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        try {\n            return $gridHelperService->createXlsxExportFile($storage, $fileHandle, $csvFile);\n        } catch (\\Exception | FilesystemException | UnableToReadFile $exception) {\n            // handle the error\n            throw $this->createNotFoundException('XLSX file not found');\n        }\n    }\n\n    /**\n     * @Route(\"/get-metadata-for-column-config\", name=\"pimcore_admin_asset_assethelper_getmetadataforcolumnconfig\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getMetadataForColumnConfigAction(Request $request): JsonResponse\n    {\n        $result = [];\n\n        //default metadata\n        $defaultMetadataNames = ['copyright', 'alt', 'title'];\n        foreach ($defaultMetadataNames as $defaultMetadata) {\n            $defaultColumns[] = ['title' => $defaultMetadata, 'name' => $defaultMetadata, 'datatype' => 'data', 'fieldtype' => 'input'];\n        }\n        $result['defaultColumns']['nodeLabel'] = 'default_metadata';\n        $result['defaultColumns']['nodeType'] = 'image';\n        $result['defaultColumns']['children'] = $defaultColumns;\n\n        //predefined metadata\n        $list = Metadata\\Predefined\\Listing::getByTargetType('asset');\n        $metadataItems = [];\n        $tmp = [];\n        foreach ($list as $item) {\n            //only allow unique metadata columns with subtypes\n            $uniqueKey = $item->getName().'_'.$item->getTargetSubtype();\n            if (!in_array($uniqueKey, $tmp) && !in_array($item->getName(), $defaultMetadataNames)) {\n                $tmp[] = $uniqueKey;\n                $item->expand();\n                $name = SecurityHelper::convertHtmlSpecialChars($item->getName());\n                $metadataItems[] = [\n                    'title' => $name,\n                    'name' => $name,\n                    'subtype' => $item->getTargetSubtype(),\n                    'datatype' => 'data',\n                    'fieldtype' => $item->getType(),\n                    'config' => $item->getConfig(),\n                ];\n            }\n        }\n\n        $result['metadataColumns']['children'] = $metadataItems;\n        $result['metadataColumns']['nodeLabel'] = 'predefined_metadata';\n        $result['metadataColumns']['nodeType'] = 'metadata';\n\n        //system columns\n        $systemColumnNames = Asset\\Service::GRID_SYSTEM_COLUMNS;\n        $systemColumns = [];\n        foreach ($systemColumnNames as $systemColumn) {\n            $systemColumns[] = ['title' => $systemColumn, 'name' => $systemColumn, 'datatype' => 'data', 'fieldtype' => 'system'];\n        }\n        $result['systemColumns']['nodeLabel'] = 'system_columns';\n        $result['systemColumns']['nodeType'] = 'system';\n        $result['systemColumns']['children'] = $systemColumns;\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @Route(\"/get-batch-jobs\", name=\"pimcore_admin_asset_assethelper_getbatchjobs\", methods={\"POST\"})\n     *\n     *\n     */\n    public function getBatchJobsAction(Request $request, GridHelperService $gridHelperService): JsonResponse\n    {\n        if ($request->get('language')) {\n            $request->setLocale($request->get('language'));\n        }\n\n        $allParams = array_merge($request->request->all(), $request->query->all());\n        $list = $gridHelperService->prepareAssetListingForGrid($allParams, $this->getAdminUser());\n\n        $jobs = $list->loadIdList();\n\n        return $this->adminJson(['success' => true, 'jobs' => $jobs]);\n    }\n\n    /**\n     * @Route(\"/batch\", name=\"pimcore_admin_asset_assethelper_batch\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     */\n    public function batchAction(Request $request, EventDispatcherInterface $eventDispatcher): JsonResponse\n    {\n        try {\n            if ($request->get('data')) {\n                $loader = \\Pimcore::getContainer()->get('pimcore.implementation_loader.asset.metadata.data');\n\n                $data = $this->decodeJson($request->get('data'), true);\n\n                $updateEvent = new GenericEvent($this, [\n                    'data' => $data,\n                    'processed' => false,\n                ]);\n\n                $eventDispatcher->dispatch($updateEvent, AdminEvents::ASSET_LIST_BEFORE_BATCH_UPDATE);\n\n                $processed = $updateEvent->getArgument('processed');\n\n                if ($processed) {\n                    return $this->adminJson(['success' => true]);\n                }\n\n                $language = null;\n                if (isset($data['language'])) {\n                    $language = $data['language'] != 'default' ? $data['language'] : null;\n                }\n\n                $asset = Asset::getById($data['job']);\n\n                if ($asset) {\n                    if (!$asset->isAllowed('publish')) {\n                        throw new \\Exception(\"Permission denied. You don't have the rights to save this asset.\");\n                    }\n\n                    $metadata = $asset->getMetadata(null, null, false, true);\n                    $dirty = false;\n\n                    $name = $data['name'];\n                    $value = $data['value'];\n\n                    if ($data['valueType'] == 'object') {\n                        $value = $this->decodeJson($value);\n                    }\n\n                    $fieldDef = explode('~', $name);\n                    $name = $fieldDef[0];\n                    if (count($fieldDef) > 1) {\n                        $language = ($fieldDef[1] == 'none' ? '' : $fieldDef[1]);\n                    }\n\n                    foreach ($metadata as $idx => &$em) {\n                        if ($em['name'] == $name && $em['language'] == $language) {\n                            try {\n                                $dataImpl = $loader->build($em['type']);\n                                $value = $dataImpl->getDataFromListfolderGrid($value, $em);\n                            } catch (UnsupportedException $le) {\n                                Logger::error('could not resolve metadata implementation for ' . $em['type']);\n                            }\n                            $em['data'] = $value;\n                            $dirty = true;\n\n                            break;\n                        }\n                    }\n\n                    if (!$dirty) {\n                        $defaulMetadata = ['title', 'alt', 'copyright'];\n                        if (in_array($name, $defaulMetadata)) {\n                            $newEm = [\n                                'name' => $name,\n                                'language' => $language,\n                                'type' => 'input',\n                                'data' => $value,\n                            ];\n\n                            try {\n                                $dataImpl = $loader->build($newEm['type']);\n                                $newEm['data'] = $dataImpl->getDataFromListfolderGrid($value, $newEm);\n                            } catch (UnsupportedException $le) {\n                                Logger::error('could not resolve metadata implementation for ' . $newEm['type']);\n                            }\n\n                            $metadata[] = $newEm;\n                            $dirty = true;\n                        } else {\n                            $predefined = Metadata\\Predefined::getByName($name);\n                            if ($predefined && (empty($predefined->getTargetSubtype())\n                                    || $predefined->getTargetSubtype() == $asset->getType())) {\n                                $newEm = [\n                                    'name' => $name,\n                                    'language' => $language,\n                                    'type' => $predefined->getType(),\n                                    'data' => $value,\n                                ];\n\n                                try {\n                                    $dataImpl = $loader->build($newEm['type']);\n                                    $newEm['data'] = $dataImpl->getDataFromListfolderGrid($value, $newEm);\n                                } catch (UnsupportedException $le) {\n                                    Logger::error('could not resolve metadata implementation for ' . $newEm['type']);\n                                }\n\n                                $metadata[] = $newEm;\n\n                                $dirty = true;\n                            }\n                        }\n                    }\n\n                    try {\n                        if ($dirty) {\n                            // $metadata = Asset\\Service::minimizeMetadata($metadata, \"grid\");\n                            $asset->setMetadataRaw($metadata);\n                            $asset->save();\n\n                            return $this->adminJson(['success' => true]);\n                        }\n                    } catch (\\Exception $e) {\n                        return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n                    }\n                } else {\n                    Logger::debug('AssetHelperController::batchAction => There is no asset left to update.');\n\n                    return $this->adminJson(['success' => false, 'message' => 'AssetHelperController::batchAction => There is no asset left to update.']);\n                }\n            }\n        } catch (\\Exception $e) {\n            Logger::err((string)$e);\n\n            return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n        }\n\n        return $this->adminJson(['success' => false, 'message' => 'something went wrong.']);\n    }\n}\n", "<?php\ndeclare(strict_types=1);\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Admin\\DataObject;\n\nuse League\\Flysystem\\FilesystemException;\nuse League\\Flysystem\\UnableToReadFile;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\AdminAbstractController;\nuse Pimcore\\Bundle\\AdminBundle\\Event\\AdminEvents;\nuse Pimcore\\Bundle\\AdminBundle\\Helper\\GridHelperService;\nuse Pimcore\\Bundle\\AdminBundle\\Model\\GridConfig;\nuse Pimcore\\Bundle\\AdminBundle\\Model\\GridConfigFavourite;\nuse Pimcore\\Bundle\\AdminBundle\\Model\\GridConfigShare;\nuse Pimcore\\Config;\nuse Pimcore\\Db;\nuse Pimcore\\Localization\\LocaleServiceInterface;\nuse Pimcore\\Logger;\nuse Pimcore\\Model\\DataObject;\nuse Pimcore\\Model\\User;\nuse Pimcore\\Security\\SecurityHelper;\nuse Pimcore\\Tool;\nuse Pimcore\\Tool\\Storage;\nuse Pimcore\\Version;\nuse Symfony\\Component\\EventDispatcher\\GenericEvent;\nuse Symfony\\Component\\Filesystem\\Filesystem;\nuse Symfony\\Component\\HttpFoundation\\BinaryFileResponse;\nuse Symfony\\Component\\HttpFoundation\\HeaderUtils;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\n\n/**\n * @Route(\"/object-helper\", name=\"pimcore_admin_dataobject_dataobjecthelper_\")\n *\n * @internal\n */\nclass DataObjectHelperController extends AdminAbstractController\n{\n    const SYSTEM_COLUMNS = ['id', 'fullpath', 'key', 'published', 'creationDate', 'modificationDate', 'filename', 'classname'];\n\n    /**\n     * @Route(\"/load-object-data\", name=\"loadobjectdata\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function loadObjectDataAction(Request $request): JsonResponse\n    {\n        $object = DataObject::getById((int) $request->get('id'));\n        $result = [];\n        if ($object) {\n            $result['success'] = true;\n            $fields = $request->get('fields');\n            $result['fields'] = DataObject\\Service::gridObjectData($object, $fields);\n        } else {\n            $result['success'] = false;\n        }\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @param int $userId\n     * @param string $classId\n     * @param string|null $searchType\n     *\n     * @return array\n     */\n    public function getMyOwnGridColumnConfigs(int $userId, string $classId, string $searchType = null): array\n    {\n        $db = Db::get();\n        $configListingConditionParts = [];\n        $configListingConditionParts[] = 'ownerId = ' . $userId;\n        $configListingConditionParts[] = 'classId = ' . $db->quote($classId);\n\n        if ($searchType) {\n            $configListingConditionParts[] = 'searchType = ' . $db->quote($searchType);\n        }\n\n        $configCondition = implode(' AND ', $configListingConditionParts);\n        $configListing = new GridConfig\\Listing();\n        $configListing->setOrderKey('name');\n        $configListing->setOrder('ASC');\n        $configListing->setCondition($configCondition);\n        $configListing = $configListing->load();\n\n        $configData = [];\n        if (is_array($configListing)) {\n            foreach ($configListing as $config) {\n                $configData[] = $config->getObjectVars();\n            }\n        }\n\n        return $configData;\n    }\n\n    /**\n     * @param User $user\n     * @param string $classId\n     * @param string|null $searchType\n     *\n     * @return array\n     */\n    public function getSharedGridColumnConfigs(User $user, string $classId, string $searchType = null): array\n    {\n        $configListing = [];\n\n        $userIds = [$user->getId()];\n        // collect all roles\n        $userIds = array_merge($userIds, $user->getRoles());\n        $userIds = implode(',', $userIds);\n        $db = Db::get();\n\n        $query = 'select distinct c1.id from gridconfigs c1, gridconfig_shares s\n                    where (c1.searchType = ' . $db->quote($searchType) . ' and ((c1.id = s.gridConfigId and s.sharedWithUserId IN (' . $userIds . '))) and c1.classId = ' . $db->quote($classId) . ')\n                            UNION distinct select c2.id from gridconfigs c2 where shareGlobally = 1 and c2.classId = '. $db->quote($classId) . '  and c2.ownerId != ' . $db->quote($user->getId());\n\n        $ids = $db->fetchFirstColumn($query);\n\n        if ($ids) {\n            $ids = implode(',', $ids);\n            $configListing = new GridConfig\\Listing();\n            $configListing->setOrderKey('name');\n            $configListing->setOrder('ASC');\n            $configListing->setCondition('id in (' . $ids . ')');\n            $configListing = $configListing->load();\n        }\n\n        $configData = [];\n        if (is_array($configListing)) {\n            foreach ($configListing as $config) {\n                $configData[] = $config->getObjectVars();\n            }\n        }\n\n        return $configData;\n    }\n\n    /**\n     * @Route(\"/get-export-configs\", name=\"getexportconfigs\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getExportConfigsAction(Request $request): JsonResponse\n    {\n        $classId = $request->get('classId');\n        $list = $this->getMyOwnGridColumnConfigs($this->getAdminUser()->getId(), $classId);\n        if (!is_array($list)) {\n            $list = [];\n        }\n        $list = array_merge($list, $this->getSharedGridColumnConfigs($this->getAdminUser(), $classId));\n        $result = [];\n\n        $result[] = [\n            'id' => -1,\n            'name' => '--default--',\n        ];\n\n        if ($list) {\n            /** @var GridConfig $config */\n            foreach ($list as $config) {\n                $result[] = [\n                    'id' => $config['id'],\n                    'name' => $config['name'],\n                ];\n            }\n        }\n\n        return $this->adminJson(['success' => true, 'data' => $result]);\n    }\n\n    /**\n     * @Route(\"/grid-delete-column-config\", name=\"griddeletecolumnconfig\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     * @param Config $config\n     *\n     * @return JsonResponse\n     */\n    public function gridDeleteColumnConfigAction(Request $request, EventDispatcherInterface $eventDispatcher, Config $config): JsonResponse\n    {\n        $gridConfigId = (int)$request->get('gridConfigId');\n        $gridConfig = GridConfig::getById($gridConfigId);\n        $success = false;\n        if ($gridConfig) {\n            if ($gridConfig->getOwnerId() != $this->getAdminUser()->getId() && !$this->getAdminUser()->isAdmin()) {\n                throw new \\Exception(\"don't mess with someone elses grid config\");\n            }\n\n            $gridConfig->delete();\n            $success = true;\n        }\n\n        $newGridConfig = $this->doGetGridColumnConfig($request, $config, true);\n        $newGridConfig['deleteSuccess'] = $success;\n\n        $event = new GenericEvent($this, [\n            'data' => $newGridConfig,\n            'request' => $request,\n            'config' => $config,\n            'context' => 'delete',\n        ]);\n\n        $eventDispatcher->dispatch($event, AdminEvents::OBJECT_GRID_GET_COLUMN_CONFIG_PRE_SEND_DATA);\n        $newGridConfig = $event->getArgument('data');\n\n        return $this->adminJson($newGridConfig);\n    }\n\n    /**\n     * @Route(\"/grid-get-column-config\", name=\"gridgetcolumnconfig\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     * @param Config $config\n     *\n     * @return JsonResponse\n     */\n    public function gridGetColumnConfigAction(Request $request, EventDispatcherInterface $eventDispatcher, Config $config): JsonResponse\n    {\n        $result = $this->doGetGridColumnConfig($request, $config);\n\n        $event = new GenericEvent($this, [\n            'data' => $result,\n            'request' => $request,\n            'config' => $config,\n            'context' => 'get',\n        ]);\n\n        $eventDispatcher->dispatch($event, AdminEvents::OBJECT_GRID_GET_COLUMN_CONFIG_PRE_SEND_DATA);\n        $result = $event->getArgument('data');\n\n        return $this->adminJson($result);\n    }\n\n    public function doGetGridColumnConfig(Request $request, Config $config, bool $isDelete = false): array\n    {\n        $class = null;\n        $fields = null;\n\n        if ($request->get('id')) {\n            $class = DataObject\\ClassDefinition::getById($request->get('id'));\n        } elseif ($request->get('name')) {\n            $class = DataObject\\ClassDefinition::getByName($request->get('name'));\n        }\n\n        $gridConfigId = null;\n        $gridType = 'search';\n        if ($request->get('gridtype')) {\n            $gridType = $request->get('gridtype');\n        }\n\n        $objectId = (int) $request->get('objectId');\n\n        if ($objectId) {\n            $fields = DataObject\\Service::getCustomGridFieldDefinitions($class->getId(), $objectId);\n        }\n\n        $context = ['purpose' => 'gridconfig'];\n        if ($class) {\n            $context['class'] = $class;\n        }\n\n        if ($objectId) {\n            $object = DataObject::getById($objectId);\n            $context['object'] = $object;\n        }\n\n        if (!$fields && $class) {\n            $fields = $class->getFieldDefinitions();\n        }\n\n        $types = [];\n        if ($request->get('types')) {\n            $types = explode(',', $request->get('types'));\n        }\n\n        $userId = $this->getAdminUser()->getId();\n\n        $requestedGridConfigId = $isDelete ? null : $request->get('gridConfigId');\n\n        // grid config\n        $gridConfig = [];\n        $searchType = $request->get('searchType');\n\n        if (strlen($requestedGridConfigId ?? '') == 0 && $class) {\n            // check if there is a favourite view\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId($userId, $class->getId(), $objectId ?: 0, $searchType);\n            if (!$favourite && $objectId) {\n                $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId($userId, $class->getId(), 0, $searchType);\n            }\n\n            if ($favourite) {\n                $requestedGridConfigId = $favourite->getGridConfigId();\n            }\n        }\n\n        if (is_numeric($requestedGridConfigId) && $requestedGridConfigId > 0) {\n            $db = Db::get();\n            $savedGridConfig = GridConfig::getById((int) $requestedGridConfigId);\n\n            if ($savedGridConfig) {\n                $shared = false;\n                if (!$this->getAdminUser()->isAdmin()) {\n                    $userIds = [$this->getAdminUser()->getId()];\n                    $userIds = array_merge($userIds, $this->getAdminUser()->getRoles());\n                    $userIds = implode(',', $userIds);\n                    $shared = ($savedGridConfig->getOwnerId() != $userId && $savedGridConfig->isShareGlobally()) || $db->fetchOne('select 1 from gridconfig_shares where sharedWithUserId IN ('.$userIds.') and gridConfigId = '.$savedGridConfig->getId());\n                    //                  $shared = $savedGridConfig->isShareGlobally() || GridConfigShare::getByGridConfigAndSharedWithId($savedGridConfig->getId(), $this->getUser()->getId());\n\n                    if (!$shared && $savedGridConfig->getOwnerId() != $this->getAdminUser()->getId()) {\n                        throw new \\Exception('You are neither the owner of this config nor it is shared with you');\n                    }\n                }\n\n                $gridConfigId = $savedGridConfig->getId();\n                $gridConfig = $savedGridConfig->getConfig();\n                $gridConfig = json_decode($gridConfig, true);\n                $gridConfigName = SecurityHelper::convertHtmlSpecialChars($savedGridConfig->getName());\n                $owner = $savedGridConfig->getOwnerId();\n                $ownerObject = User::getById($owner);\n                if ($ownerObject instanceof User) {\n                    $owner = $ownerObject->getName();\n                }\n                $modificationDate = $savedGridConfig->getModificationDate();\n                $gridConfigDescription = SecurityHelper::convertHtmlSpecialChars($savedGridConfig->getDescription());\n                $sharedGlobally = $savedGridConfig->isShareGlobally();\n                $setAsFavourite = $savedGridConfig->isSetAsFavourite();\n                $saveFilters = $savedGridConfig->isSaveFilters();\n\n                foreach($gridConfig['columns'] as &$column) {\n                    if (array_key_exists('isOperator', $column) && $column['isOperator']) {\n                        $colAttributes = &$column['fieldConfig']['attributes'];\n                        SecurityHelper::convertHtmlSpecialCharsArrayKeys($colAttributes, ['label', 'attribute', 'param1']);\n                    }\n                }\n            }\n        }\n\n        $localizedFields = [];\n        $objectbrickFields = [];\n        if (is_array($fields)) {\n            foreach ($fields as $key => $field) {\n                if ($field instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    $localizedFields[] = $field;\n                } elseif ($field instanceof DataObject\\ClassDefinition\\Data\\Objectbricks) {\n                    $objectbrickFields[] = $field;\n                }\n            }\n        }\n\n        $availableFields = [];\n\n        if (empty($gridConfig)) {\n            $availableFields = $this->getDefaultGridFields(\n                $request->query->getBoolean('no_system_columns'),\n                $class,\n                $gridType,\n                $request->query->getBoolean('no_brick_columns'),\n                $fields,\n                $context,\n                $objectId,\n                $types\n            );\n        } else {\n            $savedColumns = $gridConfig['columns'];\n            foreach ($savedColumns as $key => $sc) {\n                if (!$sc['hidden']) {\n                    if (in_array($key, self::SYSTEM_COLUMNS)) {\n                        $colConfig = [\n                            'key' => $key,\n                            'type' => 'system',\n                            'label' => $key,\n                            'locked' => $sc['locked'] ?? null,\n                            'position' => $sc['position'],\n                        ];\n                        if (isset($sc['width'])) {\n                            $colConfig['width'] = $sc['width'];\n                        }\n                        $availableFields[] = $colConfig;\n                    } else {\n                        $keyParts = explode('~', $key);\n\n                        if (substr($key, 0, 1) == '~') {\n                            // not needed for now\n                            $type = $keyParts[1];\n                            //                            $field = $keyParts[2];\n                            $groupAndKeyId = explode('-', $keyParts[3]);\n                            $keyId = (int) $groupAndKeyId[1];\n\n                            if ($type == 'classificationstore') {\n                                $keyDef = DataObject\\Classificationstore\\KeyConfig::getById($keyId);\n                                if ($keyDef) {\n                                    $keyFieldDef = json_decode($keyDef->getDefinition(), true);\n                                    if ($keyFieldDef) {\n                                        $keyFieldDef = \\Pimcore\\Model\\DataObject\\Classificationstore\\Service::getFieldDefinitionFromJson($keyFieldDef, $keyDef->getType());\n                                        $fieldConfig = $this->getFieldGridConfig($keyFieldDef, $gridType, (string)$sc['position'], true, null, $class, $objectId);\n                                        if ($fieldConfig) {\n                                            $fieldConfig['key'] = $key;\n                                            $fieldConfig['label'] = '#' . $keyFieldDef->getTitle();\n                                            if (isset($sc['locked'])) {\n                                                $fieldConfig['locked'] = $sc['locked'];\n                                            }\n                                            $availableFields[] = $fieldConfig;\n                                        }\n                                    }\n                                }\n                            }\n                        } elseif (count($keyParts) > 1) {\n                            $brick = $keyParts[0];\n                            $brickDescriptor = null;\n\n                            if (strpos($brick, '?') !== false) {\n                                $brickDescriptor = substr($brick, 1);\n                                $brickDescriptor = json_decode($brickDescriptor, true);\n                                $keyPrefix = $brick . '~';\n                                $brick = $brickDescriptor['containerKey'];\n                            } else {\n                                $keyPrefix = $brick . '~';\n                            }\n\n                            $fieldname = $keyParts[1];\n\n                            $brickClass = DataObject\\Objectbrick\\Definition::getByKey($brick);\n\n                            $fd = null;\n                            if ($brickClass instanceof DataObject\\Objectbrick\\Definition) {\n                                if ($brickDescriptor) {\n                                    $innerContainer = $brickDescriptor['innerContainer'] ?? 'localizedfields';\n                                    /** @var DataObject\\ClassDefinition\\Data\\Localizedfields $localizedFields */\n                                    $localizedFields = $brickClass->getFieldDefinition($innerContainer);\n                                    $fd = $localizedFields->getFieldDefinition($brickDescriptor['brickfield']);\n                                } else {\n                                    $fd = $brickClass->getFieldDefinition($fieldname);\n                                }\n                            }\n\n                            if ($fd !== null) {\n                                $fieldConfig = $this->getFieldGridConfig($fd, $gridType, (string)$sc['position'], true, $keyPrefix, $class, $objectId);\n                                if (!empty($fieldConfig)) {\n                                    if (isset($sc['width'])) {\n                                        $fieldConfig['width'] = $sc['width'];\n                                    }\n                                    if (isset($sc['locked'])) {\n                                        $fieldConfig['locked'] = $sc['locked'];\n                                    }\n                                    $availableFields[] = $fieldConfig;\n                                }\n                            }\n                        } else {\n                            if (DataObject\\Service::isHelperGridColumnConfig($key)) {\n                                $calculatedColumnConfig = $this->getCalculatedColumnConfig($request, $savedColumns[$key]);\n                                if ($calculatedColumnConfig) {\n                                    $availableFields[] = $calculatedColumnConfig;\n                                }\n                            } else {\n                                $fd = $class->getFieldDefinition($key);\n                                //if not found, look for localized fields\n                                if (empty($fd)) {\n                                    foreach ($localizedFields as $lf) {\n                                        $fd = $lf->getFieldDefinition($key);\n                                        if (!empty($fd)) {\n                                            break;\n                                        }\n                                    }\n                                }\n\n                                if (!empty($fd)) {\n                                    $fieldConfig = $this->getFieldGridConfig($fd, $gridType, (string)$sc['position'], true, null, $class, $objectId);\n                                    if (!empty($fieldConfig)) {\n                                        if (isset($sc['width'])) {\n                                            $fieldConfig['width'] = $sc['width'];\n                                        }\n                                        if (isset($sc['locked'])) {\n                                            $fieldConfig['locked'] = $sc['locked'];\n                                        }\n                                        $availableFields[] = $fieldConfig;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        usort($availableFields, function ($a, $b) {\n            if ($a['position'] == $b['position']) {\n                return 0;\n            }\n\n            return ($a['position'] < $b['position']) ? -1 : 1;\n        });\n\n        $frontendLanguages = Tool\\Admin::reorderWebsiteLanguages(\\Pimcore\\Tool\\Admin::getCurrentUser(), $config['general']['valid_languages']);\n        if ($frontendLanguages) {\n            $language = $frontendLanguages[0];\n        } else {\n            $language = $request->getLocale();\n        }\n\n        if (!Tool::isValidLanguage($language)) {\n            $validLanguages = Tool::getValidLanguages();\n            $language = $validLanguages[0];\n        }\n\n        if (!empty($gridConfig) && !empty($gridConfig['language'])) {\n            $language = $gridConfig['language'];\n        }\n\n        $availableConfigs = $class ? $this->getMyOwnGridColumnConfigs($userId, $class->getId(), $searchType) : [];\n        $sharedConfigs = $class ? $this->getSharedGridColumnConfigs($this->getAdminUser(), $class->getId(), $searchType) : [];\n        $settings = $this->getShareSettings((int)$gridConfigId);\n        $settings['gridConfigId'] = (int)$gridConfigId;\n        $settings['gridConfigName'] = $gridConfigName ?? null;\n        $settings['gridConfigDescription'] = $gridConfigDescription ?? null;\n        $settings['owner'] = $owner ?? null;\n        $settings['modificationDate'] = $modificationDate ?? null;\n        $settings['shareGlobally'] = $sharedGlobally ?? null;\n        $settings['setAsFavourite'] = $setAsFavourite ?? null;\n        $settings['saveFilters'] = $saveFilters ?? null;\n        $settings['isShared'] = !$gridConfigId || ($shared ?? null);\n\n        $context = $gridConfig['context'] ?? null;\n        if ($context) {\n            $context = json_decode($context, true);\n        }\n\n        return [\n            'sortinfo' => $gridConfig['sortinfo'] ?? false,\n            'language' => $language,\n            'availableFields' => $availableFields,\n            'settings' => $settings,\n            'onlyDirectChildren' => $gridConfig['onlyDirectChildren'] ?? false,\n            'pageSize' => $gridConfig['pageSize'] ?? false,\n            'availableConfigs' => $availableConfigs,\n            'sharedConfigs' => $sharedConfigs,\n            'context' => $context,\n            'searchFilter' => $gridConfig['searchFilter'] ?? '',\n            'filter' => $gridConfig['filter'] ?? [],\n        ];\n    }\n\n    /**\n     * @param DataObject\\ClassDefinition\\Data[]|null $fields\n     */\n    public function getDefaultGridFields(bool $noSystemColumns, ?DataObject\\ClassDefinition $class, string $gridType, bool $noBrickColumns, ?array $fields, array $context, int $objectId, array $types = []): array\n    {\n        $count = 0;\n        $availableFields = [];\n\n        if (!$noSystemColumns && $class) {\n            $vis = $class->getPropertyVisibility();\n            foreach (self::SYSTEM_COLUMNS as $sc) {\n                $key = $sc;\n                if ($key === 'fullpath') {\n                    $key = 'path';\n                }\n\n                if (empty($types) && (!empty($vis[$gridType][$key]) || $gridType === 'all')) {\n                    $availableFields[] = [\n                        'key' => $sc,\n                        'type' => 'system',\n                        'label' => $sc,\n                        'position' => $count, ];\n                    $count++;\n                }\n            }\n        }\n\n        $includeBricks = !$noBrickColumns;\n\n        if (is_array($fields)) {\n            foreach ($fields as $key => $field) {\n                if ($field instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    foreach ($field->getFieldDefinitions($context) as $fd) {\n                        if (empty($types) || in_array($fd->getFieldType(), $types)) {\n                            $fieldConfig = $this->getFieldGridConfig($fd, $gridType, (string)$count, false, null, $class, $objectId);\n                            if (!empty($fieldConfig)) {\n                                $availableFields[] = $fieldConfig;\n                                $count++;\n                            }\n                        }\n                    }\n                } elseif ($field instanceof DataObject\\ClassDefinition\\Data\\Objectbricks && $includeBricks) {\n                    if (in_array($field->getFieldType(), $types)) {\n                        $fieldConfig = $this->getFieldGridConfig($field, $gridType, (string)$count, false, null, $class, $objectId);\n                        if (!empty($fieldConfig)) {\n                            $availableFields[] = $fieldConfig;\n                            $count++;\n                        }\n                    } else {\n                        $allowedTypes = $field->getAllowedTypes();\n                        if (!empty($allowedTypes)) {\n                            foreach ($allowedTypes as $t) {\n                                $brickClass = DataObject\\Objectbrick\\Definition::getByKey($t);\n                                $brickFields = $brickClass->getFieldDefinitions($context);\n\n                                $this->appendBrickFields($field, $brickFields, $availableFields, $gridType, $count, $t, $class, $objectId);\n                            }\n                        }\n                    }\n                } else {\n                    if (empty($types) || in_array($field->getFieldType(), $types)) {\n                        $fieldConfig = $this->getFieldGridConfig($field, $gridType, (string)$count, !empty($types), null, $class, $objectId);\n                        if (!empty($fieldConfig)) {\n                            $availableFields[] = $fieldConfig;\n                            $count++;\n                        }\n                    }\n                }\n            }\n        }\n\n        return $availableFields;\n    }\n\n    /**\n     * @param DataObject\\ClassDefinition\\Data $field\n     * @param DataObject\\ClassDefinition\\Data[] $brickFields\n     * @param array $availableFields\n     * @param string $gridType\n     * @param int $count\n     * @param string $brickType\n     * @param DataObject\\ClassDefinition $class\n     * @param int $objectId\n     * @param array|null $context\n     */\n    protected function appendBrickFields(DataObject\\ClassDefinition\\Data $field, array $brickFields, array &$availableFields, string $gridType, int &$count, string $brickType, DataObject\\ClassDefinition $class, int $objectId, array $context = null): void\n    {\n        if (!empty($brickFields)) {\n            foreach ($brickFields as $bf) {\n                if ($bf instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    $localizedFieldDefinitions = $bf->getFieldDefinitions();\n\n                    $localizedContext = [\n                        'containerKey' => $brickType,\n                        'fieldname' => $field->getName(),\n                    ];\n\n                    $this->appendBrickFields($bf, $localizedFieldDefinitions, $availableFields, $gridType, $count, $brickType, $class, $objectId, $localizedContext);\n                } else {\n                    if ($context) {\n                        $context['brickfield'] = $bf->getName();\n                        $keyPrefix = '?' . json_encode($context) . '~';\n                    } else {\n                        $keyPrefix = $brickType . '~';\n                    }\n                    $fieldConfig = $this->getFieldGridConfig($bf, $gridType, (string)$count, false, $keyPrefix, $class, $objectId);\n                    if (!empty($fieldConfig)) {\n                        $availableFields[] = $fieldConfig;\n                        $count++;\n                    }\n                }\n            }\n        }\n    }\n\n    protected function getCalculatedColumnConfig(Request $request, array $config): mixed\n    {\n        try {\n            $calculatedColumnConfig = Tool\\Session::useBag($request->getSession(), function (AttributeBagInterface $session) use ($config) {\n                //otherwise create a new one\n\n                $calculatedColumn = [];\n                // note that we have to generate a new key!\n\n                $existingKey = $config['fieldConfig']['key'];\n                $calculatedColumnConfig['key'] = $existingKey;\n                $calculatedColumnConfig['position'] = $config['position'];\n                $calculatedColumnConfig['isOperator'] = true;\n                $calculatedColumnConfig['attributes'] = $config['fieldConfig']['attributes'];\n                $calculatedColumnConfig['width'] = $config['width'];\n                $calculatedColumnConfig['locked'] = $config['locked'];\n\n                $existingColumns = $session->get('helpercolumns', []);\n\n                if (isset($existingColumns[$existingKey])) {\n                    // if the configuration is still in the session, then reuse it\n                    return $calculatedColumnConfig;\n                }\n\n                $newKey = '#' . uniqid();\n                $calculatedColumnConfig['key'] = $newKey;\n\n                // prepare a column config on the fly\n                $phpConfig = json_encode($config['fieldConfig']);\n                $phpConfig = json_decode($phpConfig);\n                $helperColumns = [];\n                $helperColumns[$newKey] = $phpConfig;\n\n                $helperColumns = array_merge($helperColumns, $existingColumns);\n                $session->set('helpercolumns', $helperColumns);\n\n                return $calculatedColumnConfig;\n            }, 'pimcore_gridconfig');\n\n            return $calculatedColumnConfig;\n        } catch (\\Exception $e) {\n            Logger::error((string) $e);\n        }\n\n        return null;\n    }\n\n    /**\n     * @Route(\"/prepare-helper-column-configs\", name=\"preparehelpercolumnconfigs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function prepareHelperColumnConfigs(Request $request): JsonResponse\n    {\n        $helperColumns = [];\n        $newData = [];\n        /** @var \\stdClass[] $data */\n        $data = json_decode($request->get('columns'));\n        foreach ($data as $item) {\n            if (!empty($item->isOperator)) {\n                $itemKey = '#' . uniqid();\n\n                $item->key = $itemKey;\n                $newData[] = $item;\n                $helperColumns[$itemKey] = $item;\n            } else {\n                $newData[] = $item;\n            }\n        }\n\n        Tool\\Session::useBag($request->getSession(), function (AttributeBagInterface $session) use ($helperColumns) {\n            $existingColumns = $session->get('helpercolumns', []);\n            $helperColumns = array_merge($helperColumns, $existingColumns);\n            $session->set('helpercolumns', $helperColumns);\n        }, 'pimcore_gridconfig');\n\n        return $this->adminJson(['success' => true, 'columns' => $newData]);\n    }\n\n    /**\n     * @Route(\"/grid-config-apply-to-all\", name=\"gridconfigapplytoall\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridConfigApplyToAllAction(Request $request): JsonResponse\n    {\n        $objectId = $request->request->getInt('objectId');\n        $object = DataObject::getById($objectId);\n\n        if ($object->isAllowed('list')) {\n            $classId = $request->get('classId');\n            $searchType = $request->get('searchType');\n            $user = $this->getAdminUser();\n            $db = Db::get();\n            $db->executeQuery('delete from gridconfig_favourites where '\n                . 'ownerId = ' . $user->getId()\n                . ' and classId = ' . $db->quote($classId) .\n                ' and searchType = ' . $db->quote($searchType)\n                . ' and objectId != ' . $objectId . ' and objectId != 0');\n\n            return $this->adminJson(['success' => true]);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @Route(\"/grid-mark-favourite-column-config\", name=\"gridmarkfavouritecolumnconfig\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridMarkFavouriteColumnConfigAction(Request $request): JsonResponse\n    {\n        $objectId = (int)$request->get('objectId');\n        $object = DataObject::getById($objectId);\n\n        if ($object->isAllowed('list')) {\n            $classId = $request->get('classId');\n            $gridConfigId = $request->get('gridConfigId');\n            $searchType = $request->get('searchType');\n            $global = $request->get('global');\n            $user = $this->getAdminUser();\n            $type = $request->get('type');\n\n            $favourite = new GridConfigFavourite();\n            $favourite->setOwnerId($user->getId());\n            $class = DataObject\\ClassDefinition::getById($classId);\n            if (!$class) {\n                throw new \\Exception('class ' . $classId . ' does not exist anymore');\n            }\n            $favourite->setClassId($classId);\n            $favourite->setSearchType($searchType);\n            $favourite->setType($type);\n            $specializedConfigs = false;\n\n            try {\n                if ($gridConfigId != 0) {\n                    $gridConfig = GridConfig::getById((int)$gridConfigId);\n                    $favourite->setGridConfigId($gridConfig->getId());\n                }\n                $favourite->setObjectId($objectId);\n                $favourite->save();\n\n                if ($global) {\n                    $favourite->setObjectId(0);\n                    $favourite->save();\n                }\n                $db = Db::get();\n                $count = $db->fetchOne('select * from gridconfig_favourites where '\n                    . 'ownerId = ' . $user->getId()\n                    . ' and classId = ' . $db->quote($classId).\n                    ' and searchType = ' . $db->quote($searchType)\n                    . ' and objectId != ' . $objectId . ' and objectId != 0'\n                    . ' and `type` != ' . $db->quote($type));\n                $specializedConfigs = $count > 0;\n            } catch (\\Exception $e) {\n                $favourite->delete();\n            }\n\n            return $this->adminJson(['success' => true, 'spezializedConfigs' => $specializedConfigs]);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    protected function getShareSettings(int $gridConfigId): array\n    {\n        $result = [\n            'sharedUserIds' => [],\n            'sharedRoleIds' => [],\n        ];\n\n        $db = Db::get();\n        $allShares = $db->fetchAllAssociative('select s.sharedWithUserId, u.type from gridconfig_shares s, users u\n                      where s.sharedWithUserId = u.id and s.gridConfigId = ' . $gridConfigId);\n\n        if ($allShares) {\n            foreach ($allShares as $share) {\n                $type = $share['type'];\n                $key = 'shared' . ucfirst($type) . 'Ids';\n                $result[$key][] = $share['sharedWithUserId'];\n            }\n        }\n\n        foreach ($result as $idx => $value) {\n            $value = $value ? implode(',', $value) : '';\n            $result[$idx] = $value;\n        }\n\n        return $result;\n    }\n\n    /**\n     * @Route(\"/grid-save-column-config\", name=\"gridsavecolumnconfig\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridSaveColumnConfigAction(Request $request): JsonResponse\n    {\n        $objectId = $request->request->getInt('id');\n        $object   = DataObject::getById($objectId);\n\n        if ($object->isAllowed('list')) {\n            try {\n                $classId = $request->get('class_id');\n                $context = $request->get('context');\n\n                $searchType = $request->get('searchType');\n\n                // grid config\n                $gridConfigData = $this->decodeJson($request->get('gridconfig'));\n                $gridConfigData['pimcore_version'] = Version::getVersion();\n                $gridConfigData['pimcore_revision'] = Version::getRevision();\n\n                $gridConfigData['context'] = $context;\n\n                unset($gridConfigData['settings']['isShared']);\n\n                $metadata = $request->get('settings');\n                $metadata = json_decode($metadata, true);\n\n                $gridConfigId = $metadata['gridConfigId'];\n                $gridConfig = null;\n                if ($gridConfigId) {\n                    $gridConfig = GridConfig::getById($gridConfigId);\n                }\n\n                if ($gridConfig && $gridConfig->getOwnerId() != $this->getAdminUser()->getId() && !$this->getAdminUser()->isAdmin()) {\n                    throw new \\Exception(\"don't mess around with somebody elses configuration\");\n                }\n\n                $this->updateGridConfigShares($gridConfig, $metadata);\n\n                if ($metadata['setAsFavourite'] && $this->getAdminUser()->isAdmin()) {\n                    $this->updateGridConfigFavourites($gridConfig, $metadata, $objectId);\n                }\n\n                if (!$gridConfig) {\n                    $gridConfig = new GridConfig();\n                    $gridConfig->setName(date('c'));\n                    $gridConfig->setClassId($classId);\n                    $gridConfig->setSearchType($searchType);\n\n                    $gridConfig->setOwnerId($this->getAdminUser()->getId());\n                }\n\n                if ($metadata) {\n                    $gridConfig->setName(SecurityHelper::convertHtmlSpecialChars($metadata['gridConfigName']));\n                    $gridConfig->setDescription(SecurityHelper::convertHtmlSpecialChars($metadata['gridConfigDescription']));\n                    $gridConfig->setShareGlobally($metadata['shareGlobally'] && $this->getAdminUser()->isAdmin());\n                    $gridConfig->setSetAsFavourite($metadata['setAsFavourite'] && $this->getAdminUser()->isAdmin());\n                    $gridConfig->setSaveFilters($metadata['saveFilters'] ?? false);\n                }\n\n                $gridConfigData = json_encode($gridConfigData);\n                $gridConfig->setConfig($gridConfigData);\n                $gridConfig->save();\n\n                $userId = $this->getAdminUser()->getId();\n\n                $availableConfigs = $this->getMyOwnGridColumnConfigs($userId, $classId, $searchType);\n                $sharedConfigs = $this->getSharedGridColumnConfigs($this->getAdminUser(), $classId, $searchType);\n\n                $settings = $this->getShareSettings($gridConfig->getId());\n                $settings['gridConfigId'] = (int)$gridConfig->getId();\n                $settings['gridConfigName'] = SecurityHelper::convertHtmlSpecialChars($gridConfig->getName());\n                $settings['gridConfigDescription'] = SecurityHelper::convertHtmlSpecialChars($gridConfig->getDescription());\n                $settings['shareGlobally'] = $gridConfig->isShareGlobally();\n                $settings['setAsFavourite'] = $gridConfig->isSetAsFavourite();\n                $settings['saveFilters'] = $gridConfig->isSaveFilters();\n                $settings['isShared'] = $gridConfig->getOwnerId() != $this->getAdminUser()->getId() && !$this->getAdminUser()->isAdmin();\n\n                return $this->adminJson([\n                    'success' => true,\n                    'settings' => $settings,\n                    'availableConfigs' => $availableConfigs,\n                    'sharedConfigs' => $sharedConfigs,\n                ]);\n            } catch (\\Exception $e) {\n                return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n            }\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @param GridConfig|null $gridConfig\n     * @param array $metadata\n     *\n     * @throws \\Exception\n     */\n    protected function updateGridConfigShares(?GridConfig $gridConfig, array $metadata): void\n    {\n        $user = $this->getAdminUser();\n        if (!$gridConfig || !$user->isAllowed('share_configurations')) {\n            // nothing to do\n            return;\n        }\n\n        if ($gridConfig->getOwnerId() != $user->getId() && !$user->isAdmin()) {\n            throw new \\Exception(\"don't mess with someone elses grid config\");\n        }\n        $combinedShares = [];\n        $sharedUserIds = $metadata['sharedUserIds'];\n        $sharedRoleIds = $metadata['sharedRoleIds'];\n\n        if ($sharedUserIds) {\n            $combinedShares = explode(',', $sharedUserIds);\n        }\n\n        if ($sharedRoleIds) {\n            $sharedRoleIds = explode(',', $sharedRoleIds);\n            $combinedShares = array_merge($combinedShares, $sharedRoleIds);\n        }\n\n        $db = Db::get();\n        $db->delete('gridconfig_shares', ['gridConfigId' => $gridConfig->getId()]);\n\n        foreach ($combinedShares as $id) {\n            $share = new GridConfigShare();\n            $share->setGridConfigId($gridConfig->getId());\n            $share->setSharedWithUserId((int) $id);\n            $share->save();\n        }\n    }\n\n    /**\n     * @param GridConfig|null $gridConfig\n     * @param array $metadata\n     * @param int $objectId\n     *\n     * @throws \\Exception\n     */\n    protected function updateGridConfigFavourites(?GridConfig $gridConfig, array $metadata, int $objectId): void\n    {\n        $currentUser = $this->getAdminUser();\n\n        if (!$gridConfig || $currentUser === null || !$currentUser->isAllowed('share_configurations')) {\n            // nothing to do\n            return;\n        }\n\n        if (!$currentUser->isAdmin() && (int) $gridConfig->getOwnerId() !== $currentUser->getId()) {\n            throw new \\Exception(\"don't mess with someone elses grid config\");\n        }\n\n        $sharedUsers = [];\n\n        if ($metadata['shareGlobally'] === false) {\n            $sharedUserIds = $metadata['sharedUserIds'];\n\n            if ($sharedUserIds) {\n                $sharedUsers = explode(',', $sharedUserIds);\n            }\n        }\n\n        if ($metadata['shareGlobally'] === true) {\n            $users = new User\\Listing();\n            $users->setCondition('id = ?', $currentUser->getId());\n\n            foreach ($users as $user) {\n                $sharedUsers[] = $user->getId();\n            }\n        }\n\n        foreach ($sharedUsers as $id) {\n            $global    = true;\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId(\n                (int) $id,\n                $gridConfig->getClassId(),\n                $objectId,\n                $gridConfig->getSearchType()\n            );\n\n            // If the user has already a favourite for that object we check the current favourite and decide if we update\n            if ($favourite instanceof GridConfigFavourite) {\n                $favouriteGridConfig = GridConfig::getById($favourite->getGridConfigId());\n\n                if ($favouriteGridConfig instanceof GridConfig) {\n                    // Check if the grid config was shared globally if that is *not* the case we also not update\n                    if ($favouriteGridConfig->isShareGlobally() === false) {\n                        continue;\n                    }\n\n                    // Check if the user is the owner. If that is the case we do not update the favourite\n                    if ((int) $favouriteGridConfig->getOwnerId() === (int) $id) {\n                        continue;\n                    }\n                }\n            }\n\n            // Check if the user has already a global favourite then we do not save the favourite as global\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId(\n                (int) $id,\n                $gridConfig->getClassId(),\n                0,\n                $gridConfig->getSearchType()\n            );\n\n            if ($favourite instanceof GridConfigFavourite) {\n                $favouriteGridConfig = GridConfig::getById($favourite->getGridConfigId());\n\n                if ($favouriteGridConfig instanceof GridConfig) {\n                    // Check if the grid config was shared globally if that is *not* the case we also not update\n                    if ($favouriteGridConfig->isShareGlobally() === false) {\n                        $global = false;\n                    }\n\n                    // Check if the user is the owner. If that is the case we do not update the global favourite\n                    if ($favouriteGridConfig->getOwnerId() === (int) $id) {\n                        $global = false;\n                    }\n                }\n            }\n\n            $favourite = new GridConfigFavourite();\n            $favourite->setGridConfigId($gridConfig->getId());\n            $favourite->setClassId($gridConfig->getClassId());\n            $favourite->setObjectId($objectId);\n            $favourite->setOwnerId($id);\n            $favourite->setType($gridConfig->getType());\n            $favourite->setSearchType($gridConfig->getSearchType());\n            $favourite->save();\n\n            if ($global === true) {\n                $favourite->setObjectId(0);\n                $favourite->save();\n            }\n        }\n    }\n\n    /**\n     * @param DataObject\\ClassDefinition\\Data $field\n     * @param string $gridType\n     * @param string $position\n     * @param bool $force\n     * @param string|null $keyPrefix\n     * @param DataObject\\ClassDefinition|null $class\n     * @param int|null $objectId\n     *\n     * @return array|null\n     */\n    protected function getFieldGridConfig(DataObject\\ClassDefinition\\Data $field, string $gridType, string $position, bool $force = false, string $keyPrefix = null, DataObject\\ClassDefinition $class = null, int $objectId = null): ?array\n    {\n        $key = $keyPrefix . $field->getName();\n        $config = null;\n        $title = $field->getName();\n        if (method_exists($field, 'getTitle')) {\n            if ($field->getTitle()) {\n                $title = $field->getTitle();\n            }\n        }\n\n        if ($field instanceof DataObject\\ClassDefinition\\Data\\Slider) {\n            $config['minValue'] = $field->getMinValue();\n            $config['maxValue'] = $field->getMaxValue();\n            $config['increment'] = $field->getIncrement();\n        }\n\n        if (method_exists($field, 'getWidth')) {\n            $config['width'] = $field->getWidth();\n        }\n        if (method_exists($field, 'getHeight')) {\n            $config['height'] = $field->getHeight();\n        }\n\n        $visible = false;\n        if ($gridType == 'search') {\n            $visible = $field->getVisibleSearch();\n        } elseif ($gridType == 'grid') {\n            $visible = $field->getVisibleGridView();\n        } elseif ($gridType == 'all') {\n            $visible = true;\n        }\n\n        if (!$field->getInvisible() && ($force || $visible)) {\n            $context = ['purpose' => 'gridconfig'];\n            if ($class) {\n                $context['class'] = $class;\n            }\n\n            if ($objectId) {\n                $object = DataObject::getById($objectId);\n                $context['object'] = $object;\n            }\n            DataObject\\Service::enrichLayoutDefinition($field, null, $context);\n\n            $result = [\n                'key' => $key,\n                'type' => $field->getFieldType(),\n                'label' => $title,\n                'config' => $config,\n                'layout' => $field,\n                'position' => $position,\n            ];\n\n            if ($field instanceof DataObject\\ClassDefinition\\Data\\EncryptedField) {\n                $result['delegateDatatype'] = $field->getDelegateDatatype();\n            }\n\n            return $result;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * IMPORTER\n     */\n\n    /**\n     * @Route(\"/import-upload\", name=\"importupload\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function importUploadAction(Request $request, Filesystem $filesystem): JsonResponse\n    {\n        $data = file_get_contents($_FILES['Filedata']['tmp_name']);\n        $data = Tool\\Text::convertToUTF8($data);\n\n        $importId = $request->get('importId');\n        $importId = str_replace('..', '', $importId);\n        $importFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/import_' . $importId;\n        $filesystem->dumpFile($importFile, $data);\n\n        $importFileOriginal = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/import_' . $importId . '_original';\n        $filesystem->dumpFile($importFileOriginal, $data);\n\n        $response = $this->adminJson([\n            'success' => true,\n        ]);\n\n        // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n        // Ext.form.Action.Submit and mark the submission as failed\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    protected function extractLanguage(Request $request): string\n    {\n        $requestedLanguage = $request->get('language');\n        if ($requestedLanguage) {\n            if ($requestedLanguage != 'default') {\n                $request->setLocale($requestedLanguage);\n            }\n        } else {\n            $requestedLanguage = $request->getLocale();\n        }\n\n        return $requestedLanguage;\n    }\n\n    protected function getCsvFile(string $fileHandle): string\n    {\n        return $fileHandle . '.csv';\n    }\n\n    /**\n     * @Route(\"/get-export-jobs\", name=\"getexportjobs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param GridHelperService $gridHelperService\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     */\n    public function getExportJobsAction(Request $request, GridHelperService $gridHelperService, EventDispatcherInterface $eventDispatcher): JsonResponse\n    {\n        $requestedLanguage = $this->extractLanguage($request);\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $list = $gridHelperService->prepareListingForGrid($allParams, $requestedLanguage, $this->getAdminUser());\n\n        $beforeListPrepareEvent = new GenericEvent($this, [\n            'list' => $list,\n            'context' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($beforeListPrepareEvent, AdminEvents::OBJECT_LIST_BEFORE_EXPORT_PREPARE);\n\n        $list = $beforeListPrepareEvent->getArgument('list');\n\n        $ids = $list->loadIdList();\n\n        $jobs = array_chunk($ids, 20);\n\n        $fileHandle = uniqid('export-');\n\n        $storage = Storage::get('temp');\n        $storage->write($this->getCsvFile($fileHandle), '');\n\n        return $this->adminJson(['success' => true, 'jobs' => $jobs, 'fileHandle' => $fileHandle]);\n    }\n\n    /**\n     * @Route(\"/do-export\", name=\"doexport\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param LocaleServiceInterface $localeService\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function doExportAction(Request $request, LocaleServiceInterface $localeService, EventDispatcherInterface $eventDispatcher): JsonResponse\n    {\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $ids = $request->get('ids');\n        $settings = $request->get('settings');\n        $settings = json_decode($settings, true);\n        $delimiter = $settings['delimiter'] ?? ';';\n        $header = $settings['header'] ?? 'title';\n\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $enableInheritance = $settings['enableInheritance'] ?? false;\n        DataObject\\Concrete::setGetInheritedValues($enableInheritance);\n\n        $class = DataObject\\ClassDefinition::getById($request->get('classId'));\n\n        if (!$class) {\n            throw new \\Exception('No class definition found');\n        }\n\n        $className = $class->getName();\n        $listClass = '\\\\Pimcore\\\\Model\\\\DataObject\\\\' . ucfirst($className) . '\\\\Listing';\n\n        /** @var \\Pimcore\\Model\\DataObject\\Listing $list */\n        $list = new $listClass();\n\n        $quotedIds = [];\n        foreach ($ids as $id) {\n            $quotedIds[] = $list->quote($id);\n        }\n\n        $list->setObjectTypes(DataObject::$types);\n        $list->setCondition('id IN (' . implode(',', $quotedIds) . ')');\n        $list->setOrderKey(' FIELD(id, ' . implode(',', $quotedIds) . ')', false);\n\n        $beforeListExportEvent = new GenericEvent($this, [\n            'list' => $list,\n            'context' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($beforeListExportEvent, AdminEvents::OBJECT_LIST_BEFORE_EXPORT);\n\n        $list = $beforeListExportEvent->getArgument('list');\n\n        $fields = json_decode($request->get('fields')[0], true);\n\n        $addTitles = (bool) $request->get('initial');\n\n        $requestedLanguage = $this->extractLanguage($request);\n\n        $contextFromRequest = $request->get('context');\n        if ($contextFromRequest) {\n            $contextFromRequest = json_decode($contextFromRequest, true);\n        }\n\n        $context = [\n            'source' => 'pimcore-export',\n        ];\n\n        if (is_array($contextFromRequest)) {\n            $context = array_merge($context, $contextFromRequest);\n        }\n\n        $csv = DataObject\\Service::getCsvData($requestedLanguage, $localeService, $list, $fields, $header, $addTitles, $context);\n\n        $storage = Storage::get('temp');\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        $fileStream = $storage->readStream($csvFile);\n\n        $temp = tmpfile();\n        stream_copy_to_stream($fileStream, $temp, null, 0);\n\n        $firstLine = true;\n\n        if ($request->get('initial') && $header === 'no_header') {\n            array_shift($csv);\n            $firstLine = false;\n        }\n\n        $lineCount = count($csv);\n\n        if (!$addTitles && $lineCount > 0) {\n            fwrite($temp, \"\\r\\n\");\n        }\n\n        for ($i = 0; $i < $lineCount; $i++) {\n            $line = $csv[$i];\n            if ($addTitles && $firstLine) {\n                $firstLine = false;\n                $line = implode($delimiter, $line);\n                fwrite($temp, $line);\n            } else {\n                fwrite($temp, implode($delimiter, array_map([$this, 'encodeFunc'], $line)));\n            }\n            if ($i < $lineCount - 1) {\n                fwrite($temp, \"\\r\\n\");\n            }\n        }\n        $storage->writeStream($csvFile, $temp);\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    public function encodeFunc(string $value): string\n    {\n        $value = str_replace('\"', '\"\"', $value);\n\n        //force wrap value in quotes and return\n        return '\"' . $value . '\"';\n    }\n\n    /**\n     * @Route(\"/download-csv-file\", name=\"downloadcsvfile\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function downloadCsvFileAction(Request $request): Response\n    {\n        $storage = Storage::get('temp');\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        try {\n            $csvData = $storage->read($csvFile);\n            $response = new Response($csvData);\n            $response->headers->set('Content-Type', 'application/csv');\n            $disposition = HeaderUtils::makeDisposition(\n                HeaderUtils::DISPOSITION_ATTACHMENT,\n                'export.csv'\n            );\n\n            $response->headers->set('Content-Disposition', $disposition);\n            $storage->delete($csvFile);\n\n            return $response;\n        } catch (FilesystemException | UnableToReadFile $exception) {\n            // handle the error\n            throw $this->createNotFoundException('CSV file not found');\n        }\n    }\n\n    /**\n     * @Route(\"/download-xlsx-file\", name=\"downloadxlsxfile\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param GridHelperService $gridHelperService\n     *\n     * @return BinaryFileResponse\n     */\n    public function downloadXlsxFileAction(Request $request, GridHelperService $gridHelperService): BinaryFileResponse\n    {\n        $storage = Storage::get('temp');\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        try {\n            return $gridHelperService->createXlsxExportFile($storage, $fileHandle, $csvFile);\n        } catch (\\Exception | FilesystemException | UnableToReadFile $exception) {\n            // handle the error\n            throw $this->createNotFoundException('XLSX file not found');\n        }\n    }\n\n    /**\n     * Flattens object data to an array with key=>value where\n     * value is simply a string representation of the value (for objects, hrefs and assets the full path is used)\n     *\n     * @param DataObject\\Concrete $object\n     *\n     * @return array\n     */\n    protected function csvObjectData(DataObject\\Concrete $object): array\n    {\n        $o = [];\n        foreach ($object->getClass()->getFieldDefinitions() as $key => $value) {\n            $o[$key] = $value->getForCsvExport($object);\n        }\n\n        $o['id (system)'] = $object->getId();\n        $o['key (system)'] = $object->getKey();\n        $o['fullpath (system)'] = $object->getRealFullPath();\n        $o['published (system)'] = $object->isPublished();\n        $o['type (system)'] = $object->getType();\n\n        return $o;\n    }\n\n    /**\n     * @Route(\"/get-batch-jobs\", name=\"getbatchjobs\", methods={\"POST\"})\n     *\n     *\n     */\n    public function getBatchJobsAction(Request $request, GridHelperService $gridHelperService): JsonResponse\n    {\n        if ($request->get('language')) {\n            $request->setLocale($request->get('language'));\n        }\n\n        $allParams = array_merge($request->request->all(), $request->query->all());\n        $list = $gridHelperService->prepareListingForGrid($allParams, $request->getLocale(), $this->getAdminUser());\n\n        $jobs = $list->loadIdList();\n\n        return $this->adminJson(['success' => true, 'jobs' => $jobs]);\n    }\n\n    /**\n     * @Route(\"/batch\", name=\"batch\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function batchAction(Request $request): JsonResponse\n    {\n        $success = true;\n\n        try {\n            if ($request->get('data')) {\n                $params = $this->decodeJson($request->get('data'), true);\n                $object = DataObject\\Concrete::getById($params['job']);\n\n                if ($object) {\n                    $name = $params['name'];\n\n                    if (!$object->isAllowed('save') || ($name === 'published' && !$object->isAllowed('publish'))) {\n                        throw new \\Exception(\"Permission denied. You don't have the rights to save this object.\");\n                    }\n\n                    $append = $params['append'] ?? false;\n                    $remove = $params['remove'] ?? false;\n\n                    $className = $object->getClassName();\n                    $class = DataObject\\ClassDefinition::getByName($className);\n                    $value = $params['value'];\n                    if ($params['valueType'] == 'object') {\n                        $value = $this->decodeJson($value);\n                    }\n\n                    $parts = explode('~', $name);\n\n                    if (substr($name, 0, 1) == '~') {\n                        $type = $parts[1];\n                        $field = $parts[2];\n                        $keyId = $parts[3];\n\n                        if ($type == 'classificationstore') {\n                            $requestedLanguage = $params['language'];\n                            if ($requestedLanguage) {\n                                if ($requestedLanguage != 'default') {\n                                    $request->setLocale($requestedLanguage);\n                                }\n                            } else {\n                                $requestedLanguage = $request->getLocale();\n                            }\n\n                            $groupKeyId = explode('-', $keyId);\n                            $groupId = (int) $groupKeyId[0];\n                            $keyId = (int) $groupKeyId[1];\n\n                            $getter = 'get' . ucfirst($field);\n                            if (method_exists($object, $getter)) {\n                                /** @var DataObject\\ClassDefinition\\Data\\Classificationstore $csFieldDefinition */\n                                $csFieldDefinition = $object->getClass()->getFieldDefinition($field);\n                                $csLanguage = $requestedLanguage;\n                                if (!$csFieldDefinition->isLocalized()) {\n                                    $csLanguage = 'default';\n                                }\n\n                                /** @var DataObject\\ClassDefinition\\Data\\Classificationstore $fd */\n                                $fd = $class->getFieldDefinition($field);\n                                $keyConfig = $fd->getKeyConfiguration($keyId);\n                                $dataDefinition = DataObject\\Classificationstore\\Service::getFieldDefinitionFromKeyConfig($keyConfig);\n\n                                /** @var DataObject\\Classificationstore $classificationStoreData */\n                                $classificationStoreData = $object->$getter();\n                                if ($append) {\n                                    $oldValue = $classificationStoreData->getLocalizedKeyValue($groupId, $keyId);\n                                    $value = $dataDefinition->appendData($oldValue, $value);\n                                }\n                                if ($remove) {\n                                    $oldValue = $classificationStoreData->getLocalizedKeyValue($groupId, $keyId);\n                                    $value = $dataDefinition->removeData($oldValue, $value);\n                                }\n                                $classificationStoreData->setLocalizedKeyValue(\n                                    $groupId,\n                                    $keyId,\n                                    $dataDefinition->getDataFromEditmode($value),\n                                    $csLanguage\n                                );\n                            }\n                        }\n                    } elseif (count($parts) > 1) {\n                        // check for bricks\n                        $brickType = $parts[0];\n\n                        if (strpos($brickType, '?') !== false) {\n                            $brickDescriptor = substr($brickType, 1);\n                            $brickDescriptor = json_decode($brickDescriptor, true);\n                            $brickType = $brickDescriptor['containerKey'];\n                        }\n                        $brickKey = $parts[1];\n                        $brickField = DataObject\\Service::getFieldForBrickType($object->getClass(), $brickType);\n\n                        $fieldGetter = 'get' . ucfirst($brickField);\n                        $brickGetter = 'get' . ucfirst($brickType);\n                        $valueSetter = 'set' . ucfirst($brickKey);\n\n                        $brick = $object->$fieldGetter()->$brickGetter();\n                        if (empty($brick)) {\n                            $classname = '\\\\Pimcore\\\\Model\\\\DataObject\\\\Objectbrick\\\\Data\\\\' . ucfirst($brickType);\n                            $brickSetter = 'set' . ucfirst($brickType);\n                            $brick = new $classname($object);\n                            $object->$fieldGetter()->$brickSetter($brick);\n                        }\n\n                        $brickClass = DataObject\\Objectbrick\\Definition::getByKey($brickType);\n                        $field = $brickClass->getFieldDefinition($brickKey);\n\n                        $newData = $field->getDataFromEditmode($value, $object);\n\n                        if ($append) {\n                            $valueGetter = 'get' . ucfirst($brickKey);\n                            $existingData = $brick->$valueGetter();\n                            $newData = $field->appendData($existingData, $newData);\n                        }\n                        if ($remove) {\n                            $valueGetter = 'get' . ucfirst($brickKey);\n                            $existingData = $brick->$valueGetter();\n                            $newData = $field->removeData($existingData, $newData);\n                        }\n\n                        $localizedFields = $brickClass->getFieldDefinition('localizedfields');\n                        $isLocalizedField = false;\n                        if ($localizedFields instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                            if ($localizedFields->getFieldDefinition($brickKey)) {\n                                $isLocalizedField = true;\n                            }\n                        }\n\n                        if ($isLocalizedField) {\n                            $brick->$valueSetter($newData, $params['language']);\n                        } else {\n                            $brick->$valueSetter($newData);\n                        }\n                    } else {\n                        // everything else\n                        $field = $class->getFieldDefinition($name);\n                        if ($field) {\n                            $newData = $field->getDataFromEditmode($value, $object);\n\n                            if ($append) {\n                                $existingData = $object->{'get' . $name}();\n                                $newData = $field->appendData($existingData, $newData);\n                            }\n                            if ($remove) {\n                                $existingData = $object->{'get' . $name}();\n                                $newData = $field->removeData($existingData, $newData);\n                            }\n                            $object->setValue($name, $newData);\n                        } else {\n                            // check if it is a localized field\n                            if ($params['language']) {\n                                $localizedField = $class->getFieldDefinition('localizedfields');\n                                if ($localizedField instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                                    $field = $localizedField->getFieldDefinition($name);\n                                    if ($field) {\n                                        $getter = 'get' . $name;\n                                        $setter = 'set' . $name;\n                                        $newData = $field->getDataFromEditmode($value, $object);\n                                        if ($append) {\n                                            $existingData = $object->$getter($params['language']);\n                                            $newData = $field->appendData($existingData, $newData);\n                                        }\n                                        if ($remove) {\n                                            $existingData = $object->$getter($request->get('language'));\n                                            $newData = $field->removeData($existingData, $newData);\n                                        }\n\n                                        $object->$setter($newData, $params['language']);\n                                    }\n                                }\n                            }\n\n                            // seems to be a system field, this is actually only possible for the \"published\" field yet\n                            if ($name == 'published') {\n                                if ($value === 'false' || empty($value)) {\n                                    $object->setPublished(false);\n                                } else {\n                                    $object->setPublished(true);\n                                }\n                            }\n                        }\n                    }\n\n                    try {\n                        // don't check for mandatory fields here\n                        $object->setOmitMandatoryCheck(!$object->isPublished());\n                        $object->setUserModification($this->getAdminUser()->getId());\n                        $object->save();\n                        $success = true;\n                    } catch (\\Exception $e) {\n                        return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n                    }\n                } else {\n                    Logger::debug('DataObjectController::batchAction => There is no object left to update.');\n\n                    return $this->adminJson(['success' => false, 'message' => 'DataObjectController::batchAction => There is no object left to update.']);\n                }\n            }\n        } catch (\\Exception $e) {\n            Logger::err((string) $e);\n\n            return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n        }\n\n        return $this->adminJson(['success' => $success]);\n    }\n\n    /**\n     * @Route(\"/get-available-visible-vields\", name=\"getavailablevisiblefields\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getAvailableVisibleFieldsAction(Request $request): JsonResponse\n    {\n        $class = null;\n        $fields = null;\n\n        $classList = [];\n        $classNameList = [];\n\n        if ($request->get('classes')) {\n            $classNameList = $request->get('classes');\n            $classNameList = explode(',', $classNameList);\n            foreach ($classNameList as $className) {\n                $class = DataObject\\ClassDefinition::getByName($className);\n                if ($class) {\n                    $classList[] = $class;\n                }\n            }\n        }\n\n        if (!$classList) {\n            return $this->adminJson(['availableFields' => []]);\n        }\n        $availableFields = [];\n        foreach (self::SYSTEM_COLUMNS as $field) {\n            $availableFields[] = [\n                'key' => $field,\n                'value' => $field,\n            ];\n        }\n\n        /** @var DataObject\\ClassDefinition\\Data[] $commonFields */\n        $commonFields = [];\n\n        $firstOne = true;\n        foreach ($classNameList as $className) {\n            $class = DataObject\\ClassDefinition::getByName($className);\n            if ($class) {\n                $fds = $class->getFieldDefinitions();\n\n                $additionalFieldNames = array_keys($fds);\n                $localizedFields = $class->getFieldDefinition('localizedfields');\n                if ($localizedFields instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    $lfNames = array_keys($localizedFields->getFieldDefinitions());\n                    $additionalFieldNames = array_merge($additionalFieldNames, $lfNames);\n                }\n\n                foreach ($commonFields as $commonFieldKey => $commonFieldDefinition) {\n                    if (!in_array($commonFieldKey, $additionalFieldNames)) {\n                        unset($commonFields[$commonFieldKey]);\n                    }\n                }\n\n                $this->processAvailableFieldDefinitions($fds, $firstOne, $commonFields);\n\n                $firstOne = false;\n            }\n        }\n\n        $commonFieldKeys = array_keys($commonFields);\n        foreach ($commonFieldKeys as $field) {\n            $availableFields[] = [\n                'key' => $field,\n                'value' => $field,\n            ];\n        }\n\n        return $this->adminJson(['availableFields' => $availableFields]);\n    }\n\n    /**\n     * @param DataObject\\ClassDefinition\\Data[] $fds\n     * @param bool $firstOne\n     * @param DataObject\\ClassDefinition\\Data[] $commonFields\n     */\n    protected function processAvailableFieldDefinitions(array $fds, bool &$firstOne, array &$commonFields): void\n    {\n        foreach ($fds as $fd) {\n            if ($fd instanceof DataObject\\ClassDefinition\\Data\\Fieldcollections || $fd instanceof DataObject\\ClassDefinition\\Data\\Objectbricks\n                || $fd instanceof DataObject\\ClassDefinition\\Data\\Block) {\n                continue;\n            }\n\n            if ($fd instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                $lfDefs = $fd->getFieldDefinitions();\n                $this->processAvailableFieldDefinitions($lfDefs, $firstOne, $commonFields);\n            } elseif ($firstOne || (isset($commonFields[$fd->getName()]) && $commonFields[$fd->getName()]->getFieldtype() == $fd->getFieldtype())) {\n                $commonFields[$fd->getName()] = $fd;\n            }\n        }\n    }\n}\n"], "fixing_code": ["<?php\ndeclare(strict_types=1);\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Admin\\Asset;\n\nuse League\\Flysystem\\FilesystemException;\nuse League\\Flysystem\\UnableToReadFile;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\AdminAbstractController;\nuse Pimcore\\Bundle\\AdminBundle\\Event\\AdminEvents;\nuse Pimcore\\Bundle\\AdminBundle\\Helper\\GridHelperService;\nuse Pimcore\\Bundle\\AdminBundle\\Model\\GridConfig;\nuse Pimcore\\Bundle\\AdminBundle\\Model\\GridConfigFavourite;\nuse Pimcore\\Bundle\\AdminBundle\\Model\\GridConfigShare;\nuse Pimcore\\Bundle\\AdminBundle\\Tool;\nuse Pimcore\\Db;\nuse Pimcore\\File;\nuse Pimcore\\Loader\\ImplementationLoader\\Exception\\UnsupportedException;\nuse Pimcore\\Logger;\nuse Pimcore\\Model\\Asset;\nuse Pimcore\\Model\\Element;\nuse Pimcore\\Model\\Metadata;\nuse Pimcore\\Model\\User;\nuse Pimcore\\Security\\SecurityHelper;\nuse Pimcore\\Tool\\Session;\nuse Pimcore\\Tool\\Storage;\nuse Pimcore\\Version;\nuse Symfony\\Component\\EventDispatcher\\GenericEvent;\nuse Symfony\\Component\\HttpFoundation\\BinaryFileResponse;\nuse Symfony\\Component\\HttpFoundation\\HeaderUtils;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\n\n/**\n * @Route(\"/asset-helper\")\n *\n * @internal\n */\nclass AssetHelperController extends AdminAbstractController\n{\n    public function __construct(\n        protected EventDispatcherInterface $eventDispatcher,\n    ) {\n    }\n\n    public function getMyOwnGridColumnConfigs(int $userId, string $classId, string $searchType): array\n    {\n        $db = Db::get();\n        $configListingConditionParts = [];\n        $configListingConditionParts[] = 'ownerId = ' . $userId;\n        $configListingConditionParts[] = 'classId = ' . $db->quote($classId);\n\n        if ($searchType) {\n            $configListingConditionParts[] = 'searchType = ' . $db->quote($searchType);\n        }\n\n        $configCondition = implode(' AND ', $configListingConditionParts);\n        $configListing = new GridConfig\\Listing();\n        $configListing->setOrderKey('name');\n        $configListing->setOrder('ASC');\n        $configListing->setCondition($configCondition);\n        $configListing = $configListing->load();\n\n        $configData = [];\n        if (is_array($configListing)) {\n            foreach ($configListing as $config) {\n                $configData[] = $config->getObjectVars();\n            }\n        }\n\n        return $configData;\n    }\n\n    /**\n     * @param User $user\n     * @param string $classId\n     * @param string|null $searchType\n     *\n     * @return array\n     */\n    public function getSharedGridColumnConfigs(User $user, string $classId, string $searchType = null): array\n    {\n        $db = Db::get();\n\n        $configListing = [];\n\n        $userIds = [$user->getId()];\n        // collect all roles\n        $userIds = array_merge($userIds, $user->getRoles());\n        $userIds = implode(',', $userIds);\n\n        $query = 'select distinct c1.id from gridconfigs c1, gridconfig_shares s\n                    where (c1.searchType = ' . $db->quote($searchType) . ' and ((c1.id = s.gridConfigId and s.sharedWithUserId IN (' . $userIds . '))) and c1.classId = ' . $db->quote($classId) . ')\n                            UNION distinct select c2.id from gridconfigs c2 where shareGlobally = 1 and c2.classId = '. $db->quote($classId) . '  and c2.ownerId != ' . $db->quote($user->getId());\n\n        $ids = $db->fetchFirstColumn($query);\n\n        if ($ids) {\n            $ids = implode(',', $ids);\n            $configListing = new GridConfig\\Listing();\n            $configListing->setOrderKey('name');\n            $configListing->setOrder('ASC');\n            $configListing->setCondition('id in (' . $ids . ')');\n            $configListing = $configListing->load();\n        }\n\n        $configData = [];\n        if (is_array($configListing)) {\n            foreach ($configListing as $config) {\n                $configData[] = $config->getObjectVars();\n            }\n        }\n\n        return $configData;\n    }\n\n    /**\n     * @Route(\"/grid-delete-column-config\", name=\"pimcore_admin_asset_assethelper_griddeletecolumnconfig\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridDeleteColumnConfigAction(Request $request): JsonResponse\n    {\n        $gridConfigId = (int) $request->get('gridConfigId');\n        $gridConfig = GridConfig::getById($gridConfigId);\n        $success = false;\n        if ($gridConfig) {\n            if ($gridConfig->getOwnerId() != $this->getAdminUser()->getId()) {\n                throw new \\Exception(\"don't mess with someone elses grid config\");\n            }\n\n            $gridConfig->delete();\n            $success = true;\n        }\n\n        $newGridConfig = $this->doGetGridColumnConfig($request, true);\n        $newGridConfig['deleteSuccess'] = $success;\n\n        return $this->adminJson($newGridConfig);\n    }\n\n    /**\n     * @Route(\"/grid-get-column-config\", name=\"pimcore_admin_asset_assethelper_gridgetcolumnconfig\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridGetColumnConfigAction(Request $request): JsonResponse\n    {\n        $result = $this->doGetGridColumnConfig($request);\n\n        return $this->adminJson($result);\n    }\n\n    public function doGetGridColumnConfig(Request $request, bool $isDelete = false): array\n    {\n        $gridConfigId = null;\n\n        $classId = $request->get('id');\n        $type = $request->get('type');\n\n        $context = ['purpose' => 'gridconfig'];\n\n        $types = [];\n        if ($request->get('types')) {\n            $types = explode(',', $request->get('types'));\n        }\n\n        $userId = $this->getAdminUser()->getId();\n\n        $requestedGridConfigId = $isDelete ? '' : $request->get('gridConfigId', '');\n\n        // grid config\n        $gridConfig = [];\n        $searchType = $request->get('searchType');\n\n        if (strlen($requestedGridConfigId) == 0) {\n            // check if there is a favourite view\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId($userId, $classId, 0, $searchType);\n\n            if ($favourite) {\n                $requestedGridConfigId = $favourite->getGridConfigId();\n            }\n        }\n\n        if (is_numeric($requestedGridConfigId) && $requestedGridConfigId > 0) {\n            $db = Db::get();\n            $savedGridConfig = GridConfig::getById((int) $requestedGridConfigId);\n\n            if ($savedGridConfig) {\n                $shared = null;\n\n                try {\n                    $userIds = [$this->getAdminUser()->getId()];\n                    $userIds = array_merge($userIds, $this->getAdminUser()->getRoles());\n                    $userIds = implode(',', $userIds);\n                    $shared = ($savedGridConfig->getOwnerId() != $userId && $savedGridConfig->isShareGlobally()) || $db->fetchOne('select * from gridconfig_shares where sharedWithUserId IN (' . $userIds . ') and gridConfigId = ' . $savedGridConfig->getId());\n                } catch (\\Exception $e) {\n                }\n\n                if (!$shared && $savedGridConfig->getOwnerId() != $this->getAdminUser()->getId()) {\n                    throw new \\Exception('You are neither the owner of this config nor it is shared with you');\n                }\n                $gridConfigId = $savedGridConfig->getId();\n                $gridConfig = $savedGridConfig->getConfig();\n                $gridConfig = json_decode($gridConfig, true);\n                $gridConfigName = $savedGridConfig->getName();\n                $gridConfigDescription = $savedGridConfig->getDescription();\n                $sharedGlobally = $savedGridConfig->isShareGlobally();\n                $setAsFavourite = $savedGridConfig->isSetAsFavourite();\n            }\n        }\n\n        $availableFields = [];\n        $language = '';\n\n        if (empty($gridConfig)) {\n            $availableFields = $this->getDefaultGridFields(\n                $request->query->getBoolean('no_system_columns'),\n                [], //maybe required for types other than metadata\n                $context,\n                $types\n            );\n        } else {\n            $savedColumns = $gridConfig['columns'];\n\n            foreach ($savedColumns as $key => $sc) {\n                if (!$sc['hidden']) {\n                    $colConfig = $this->getFieldGridConfig($sc, $language, null);\n                    if ($colConfig) {\n                        $availableFields[] = $colConfig;\n                    }\n                }\n            }\n        }\n        usort($availableFields, function ($a, $b) {\n            if ($a['position'] == $b['position']) {\n                return 0;\n            }\n\n            return ($a['position'] < $b['position']) ? -1 : 1;\n        });\n\n        $availableConfigs = $classId ? $this->getMyOwnGridColumnConfigs($userId, $classId, $searchType) : [];\n        $sharedConfigs = $classId ? $this->getSharedGridColumnConfigs($this->getAdminUser(), $classId, $searchType) : [];\n        $settings = $this->getShareSettings((int)$gridConfigId);\n        $settings['gridConfigId'] = (int)$gridConfigId;\n        $settings['gridConfigName'] = $gridConfigName ?? null;\n        $settings['gridConfigDescription'] = $gridConfigDescription ?? null;\n        $settings['shareGlobally'] = $sharedGlobally ?? null;\n        $settings['setAsFavourite'] = $setAsFavourite ?? null;\n        $settings['isShared'] = !$gridConfigId || ($shared ?? null);\n\n        $context = $gridConfig['context'] ?? null;\n        if ($context) {\n            $context = json_decode($context, true);\n        }\n\n        return [\n            'sortinfo' => isset($gridConfig['sortinfo']) ? $gridConfig['sortinfo'] : false,\n            'availableFields' => $availableFields,\n            'settings' => $settings,\n            'onlyDirectChildren' => isset($gridConfig['onlyDirectChildren']) ? $gridConfig['onlyDirectChildren'] : false,\n            'onlyUnreferenced' => isset($gridConfig['onlyUnreferenced']) ? $gridConfig['onlyUnreferenced'] : false,\n            'pageSize' => isset($gridConfig['pageSize']) ? $gridConfig['pageSize'] : false,\n            'availableConfigs' => $availableConfigs,\n            'sharedConfigs' => $sharedConfigs,\n            'context' => $context,\n        ];\n    }\n\n    /**\n     * @param array $field\n     * @param string $language\n     * @param string|null $keyPrefix\n     *\n     * @return array|null\n     */\n    protected function getFieldGridConfig(array $field, string $language = '', string $keyPrefix = null): ?array\n    {\n        $defaulMetadataFields = ['copyright', 'alt', 'title'];\n        $predefined = null;\n\n        if (isset($field['fieldConfig']['layout']['name'])) {\n            $predefined = Metadata\\Predefined::getByName($field['fieldConfig']['layout']['name']);\n        }\n\n        $key = $field['name'];\n        if ($keyPrefix) {\n            $key = $keyPrefix . $key;\n        }\n        $fieldDef = explode('~', $field['name']);\n        $field['name'] = $fieldDef[0];\n\n        if (isset($fieldDef[1]) && $fieldDef[1] === 'system') {\n            $type = 'system';\n        } elseif (in_array($fieldDef[0], $defaulMetadataFields)) {\n            $type = 'input';\n        } else {\n            $type = $field['fieldConfig']['type'];\n            if (isset($fieldDef[1])) {\n                $field['fieldConfig']['label'] = $field['fieldConfig']['layout']['title'] = $fieldDef[0] . ' (' . $fieldDef[1] . ')';\n                $field['fieldConfig']['layout']['icon'] = Tool::getLanguageFlagFile($fieldDef[1], true);\n            }\n        }\n\n        $result = [\n            'key' => $key,\n            'type' => $type,\n            'label' => $field['fieldConfig']['label'] ?? $key,\n            'width' => $field['width'],\n            'position' => $field['position'],\n            'language' => $field['fieldConfig']['language'] ?? null,\n            'layout' => $field['fieldConfig']['layout'] ?? null,\n        ];\n\n        if (isset($field['locked'])) {\n            $result['locked'] = $field['locked'];\n        }\n\n        if ($type === 'select' && $predefined) {\n            $field['fieldConfig']['layout']['config'] = $predefined->getConfig();\n            $result['layout'] = $field['fieldConfig']['layout'];\n        } elseif ($type === 'document' || $type === 'asset' || $type === 'object') {\n            $result['layout']['fieldtype'] = 'manyToOneRelation';\n            $result['layout']['subtype'] = $type;\n        }\n\n        $assetGetFieldGridConfig = new GenericEvent($this, [\n            'field' => $field,\n            'result' => $result,\n        ]);\n\n        $this->eventDispatcher->dispatch($assetGetFieldGridConfig, AdminEvents::ASSET_GET_FIELD_GRID_CONFIG);\n        $result = $assetGetFieldGridConfig->getArgument('result');\n\n        return $result;\n    }\n\n    public function getDefaultGridFields(bool $noSystemColumns, array $fields, array $context, array $types = []): array\n    {\n        $count = 0;\n        $availableFields = [];\n\n        if (!$noSystemColumns) {\n            foreach (Asset\\Service::GRID_SYSTEM_COLUMNS as $sc) {\n                if (empty($types)) {\n                    $availableFields[] = [\n                        'key' => $sc . '~system',\n                        'type' => 'system',\n                        'label' => $sc,\n                        'position' => $count, ];\n                    $count++;\n                }\n            }\n        }\n\n        return $availableFields;\n    }\n\n    /**\n     * @Route(\"/prepare-helper-column-configs\", name=\"pimcore_admin_asset_assethelper_preparehelpercolumnconfigs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function prepareHelperColumnConfigs(Request $request): JsonResponse\n    {\n        $helperColumns = [];\n        $newData = [];\n        $data = json_decode($request->get('columns'));\n        /** @var \\stdClass $item */\n        foreach ($data as $item) {\n            if (!empty($item->isOperator)) {\n                $itemKey = '#' . uniqid();\n\n                $item->key = $itemKey;\n                $newData[] = $item;\n                $helperColumns[$itemKey] = $item;\n            } else {\n                $newData[] = $item;\n            }\n        }\n\n        Session::useBag($request->getSession(), function (AttributeBagInterface $session) use ($helperColumns) {\n            $existingColumns = $session->get('helpercolumns', []);\n            $helperColumns = array_merge($helperColumns, $existingColumns);\n            $session->set('helpercolumns', $helperColumns);\n        }, 'pimcore_gridconfig');\n\n        return $this->adminJson(['success' => true, 'columns' => $newData]);\n    }\n\n    /**\n     * @Route(\"/grid-mark-favourite-column-config\", name=\"pimcore_admin_asset_assethelper_gridmarkfavouritecolumnconfig\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridMarkFavouriteColumnConfigAction(Request $request): JsonResponse\n    {\n        $classId = $request->get('classId');\n        $asset = Asset::getById($classId);\n\n        if ($asset->isAllowed('list')) {\n            $gridConfigId = (int) $request->get('gridConfigId');\n            $searchType = $request->get('searchType');\n            $type = $request->get('type');\n            $user = $this->getAdminUser();\n\n            $favourite = new GridConfigFavourite();\n            $favourite->setOwnerId($user->getId());\n            $favourite->setClassId($classId);\n            $favourite->setSearchType($searchType);\n            $favourite->setType($type);\n            $specializedConfigs = false;\n\n            try {\n                if ($gridConfigId != 0) {\n                    $gridConfig = GridConfig::getById($gridConfigId);\n                    $favourite->setGridConfigId($gridConfig->getId());\n                }\n\n                $favourite->setObjectId(0);\n                $favourite->save();\n            } catch (\\Exception $e) {\n                $favourite->delete();\n            }\n\n            return $this->adminJson(['success' => true, 'spezializedConfigs' => $specializedConfigs]);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    protected function getShareSettings(int $gridConfigId): array\n    {\n        $result = [\n            'sharedUserIds' => [],\n            'sharedRoleIds' => [],\n        ];\n\n        $db = Db::get();\n        $allShares = $db->fetchAllAssociative('select s.sharedWithUserId, u.type from gridconfig_shares s, users u\n                      where s.sharedWithUserId = u.id and s.gridConfigId = ' . $gridConfigId);\n\n        if ($allShares) {\n            foreach ($allShares as $share) {\n                $type = $share['type'];\n                $key = 'shared' . ucfirst($type) . 'Ids';\n                $result[$key][] = $share['sharedWithUserId'];\n            }\n        }\n\n        foreach ($result as $idx => $value) {\n            $value = $value ? implode(',', $value) : '';\n            $result[$idx] = $value;\n        }\n\n        return $result;\n    }\n\n    /**\n     * @Route(\"/grid-save-column-config\", name=\"pimcore_admin_asset_assethelper_gridsavecolumnconfig\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridSaveColumnConfigAction(Request $request): JsonResponse\n    {\n        $asset = Asset::getById((int) $request->get('id'));\n\n        if (!$asset) {\n            throw $this->createNotFoundException();\n        }\n\n        if ($asset->isAllowed('list')) {\n            try {\n                $classId = $request->get('class_id');\n                $context = $request->get('context');\n\n                $searchType = $request->get('searchType');\n                $type = $request->get('type');\n\n                // grid config\n                $gridConfigData = $this->decodeJson($request->get('gridconfig'));\n                $gridConfigData['pimcore_version'] = Version::getVersion();\n                $gridConfigData['pimcore_revision'] = Version::getRevision();\n                $gridConfigData['context'] = $context;\n                unset($gridConfigData['settings']['isShared']);\n\n                $metadata = $request->get('settings');\n                $metadata = json_decode($metadata, true);\n\n                $gridConfigId = $metadata['gridConfigId'];\n                $gridConfig = null;\n                if ($gridConfigId) {\n                    $gridConfig = GridConfig::getById($gridConfigId);\n                }\n\n                if ($gridConfig && $gridConfig->getOwnerId() != $this->getAdminUser()->getId()) {\n                    throw new \\Exception(\"don't mess around with somebody else's configuration\");\n                }\n\n                $this->updateGridConfigShares($gridConfig, $metadata);\n\n                if ($metadata['setAsFavourite'] && $this->getAdminUser()->isAdmin()) {\n                    $this->updateGridConfigFavourites($gridConfig, $metadata);\n                }\n\n                if (!$gridConfig) {\n                    $gridConfig = new GridConfig();\n                    $gridConfig->setName(date('c'));\n                    $gridConfig->setClassId($classId);\n                    $gridConfig->setSearchType($searchType);\n                    $gridConfig->setType($type);\n\n                    $gridConfig->setOwnerId($this->getAdminUser()->getId());\n                }\n\n                if ($metadata) {\n                    $gridConfig->setName($metadata['gridConfigName']);\n                    $gridConfig->setDescription($metadata['gridConfigDescription']);\n                    $gridConfig->setShareGlobally($metadata['shareGlobally'] && $this->getAdminUser()->isAdmin());\n                    $gridConfig->setSetAsFavourite($metadata['setAsFavourite'] && $this->getAdminUser()->isAdmin());\n                }\n\n                $gridConfigData = json_encode($gridConfigData);\n                $gridConfig->setConfig($gridConfigData);\n                $gridConfig->save();\n\n                $userId = $this->getAdminUser()->getId();\n\n                $availableConfigs = $this->getMyOwnGridColumnConfigs($userId, $classId, $searchType);\n                $sharedConfigs = $this->getSharedGridColumnConfigs($this->getAdminUser(), $classId, $searchType);\n\n                $settings = $this->getShareSettings($gridConfig->getId());\n                $settings['gridConfigId'] = (int)$gridConfig->getId();\n                $settings['gridConfigName'] = $gridConfig->getName();\n                $settings['gridConfigDescription'] = $gridConfig->getDescription();\n                $settings['shareGlobally'] = $gridConfig->isShareGlobally();\n                $settings['setAsFavourite'] = $gridConfig->isSetAsFavourite();\n                $settings['isShared'] = $gridConfig->getOwnerId() != $this->getAdminUser()->getId();\n\n                return $this->adminJson([\n                    'success' => true,\n                    'settings' => $settings,\n                    'availableConfigs' => $availableConfigs,\n                    'sharedConfigs' => $sharedConfigs,\n                ]);\n            } catch (\\Exception $e) {\n                return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n            }\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @param GridConfig|null $gridConfig\n     * @param array $metadata\n     *\n     * @throws \\Exception\n     */\n    protected function updateGridConfigShares(?GridConfig $gridConfig, array $metadata): void\n    {\n        $user = $this->getAdminUser();\n        if (!$gridConfig || !$user->isAllowed('share_configurations')) {\n            // nothing to do\n            return;\n        }\n\n        if ($gridConfig->getOwnerId() != $this->getAdminUser()->getId()) {\n            throw new \\Exception(\"don't mess with someone elses grid config\");\n        }\n        $combinedShares = [];\n        $sharedUserIds = $metadata['sharedUserIds'];\n        $sharedRoleIds = $metadata['sharedRoleIds'];\n\n        if ($sharedUserIds) {\n            $combinedShares = explode(',', $sharedUserIds);\n        }\n\n        if ($sharedRoleIds) {\n            $sharedRoleIds = explode(',', $sharedRoleIds);\n            $combinedShares = array_merge($combinedShares, $sharedRoleIds);\n        }\n\n        $db = Db::get();\n        $db->delete('gridconfig_shares', ['gridConfigId' => $gridConfig->getId()]);\n\n        foreach ($combinedShares as $id) {\n            $share = new GridConfigShare();\n            $share->setGridConfigId($gridConfig->getId());\n            $share->setSharedWithUserId((int) $id);\n            $share->save();\n        }\n    }\n\n    /**\n     * @param GridConfig|null $gridConfig\n     * @param array $metadata\n     *\n     * @throws \\Exception\n     */\n    protected function updateGridConfigFavourites(?GridConfig $gridConfig, array $metadata): void\n    {\n        $currentUser = $this->getAdminUser();\n\n        if (!$gridConfig || $currentUser === null || !$currentUser->isAllowed('share_configurations')) {\n            // nothing to do\n            return;\n        }\n\n        if (!$currentUser->isAdmin() && (int) $gridConfig->getOwnerId() !== $currentUser->getId()) {\n            throw new \\Exception(\"don't mess with someone elses grid config\");\n        }\n\n        $sharedUsers = [];\n\n        if ($metadata['shareGlobally'] === false) {\n            $sharedUserIds = $metadata['sharedUserIds'];\n\n            if ($sharedUserIds) {\n                $sharedUsers = explode(',', $sharedUserIds);\n            }\n        }\n\n        if ($metadata['shareGlobally'] === true) {\n            $users = new User\\Listing();\n            $users->setCondition('id = ?', $currentUser->getId());\n\n            foreach ($users as $user) {\n                $sharedUsers[] = $user->getId();\n            }\n        }\n\n        foreach ($sharedUsers as $id) {\n            // Check if the user has already a favourite\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId(\n                (int) $id,\n                $gridConfig->getClassId(),\n                0,\n                $gridConfig->getSearchType()\n            );\n\n            if ($favourite instanceof GridConfigFavourite) {\n                $favouriteGridConfig = GridConfig::getById($favourite->getGridConfigId());\n\n                if ($favouriteGridConfig instanceof GridConfig) {\n                    // Check if the grid config was shared globally if that is *not* the case we also not update\n                    if ($favouriteGridConfig->isShareGlobally() === false) {\n                        continue;\n                    }\n\n                    // Check if the user is the owner. If that is the case we do not update the favourite\n                    if ((int) $favouriteGridConfig->getOwnerId() === (int) $id) {\n                        continue;\n                    }\n                }\n            }\n\n            $favourite = new GridConfigFavourite();\n            $favourite->setGridConfigId($gridConfig->getId());\n            $favourite->setClassId($gridConfig->getClassId());\n            $favourite->setObjectId(0);\n            $favourite->setOwnerId($id);\n            $favourite->setType($gridConfig->getType());\n            $favourite->setSearchType($gridConfig->getSearchType());\n            $favourite->save();\n        }\n    }\n\n    /**\n     * @Route(\"/get-export-jobs\", name=\"pimcore_admin_asset_assethelper_getexportjobs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param GridHelperService $gridHelperService\n     *\n     * @return JsonResponse\n     */\n    public function getExportJobsAction(Request $request, GridHelperService $gridHelperService): JsonResponse\n    {\n        $allParams = array_merge($request->request->all(), $request->query->all());\n        $list = $gridHelperService->prepareAssetListingForGrid($allParams, $this->getAdminUser());\n\n        if (empty($ids = $allParams['ids'] ?? '')) {\n            $ids = $list->loadIdList();\n        }\n\n        $jobs = array_chunk($ids, 20);\n\n        $fileHandle = uniqid('asset-export-');\n        $storage = Storage::get('temp');\n        $storage->write($this->getCsvFile($fileHandle), '');\n\n        return $this->adminJson(['success' => true, 'jobs' => $jobs, 'fileHandle' => $fileHandle]);\n    }\n\n    /**\n     * @Route(\"/do-export\", name=\"pimcore_admin_asset_assethelper_doexport\", methods={\"POST\"})\n     *\n     * @throws FilesystemException\n     */\n    public function doExportAction(Request $request): JsonResponse\n    {\n        $fileHandle = File::getValidFilename($request->get('fileHandle'));\n        $ids = $request->get('ids');\n        $settings = json_decode($request->get('settings'), true);\n        $delimiter = $settings['delimiter'] ?? ';';\n        $language = str_replace('default', '', $request->get('language'));\n\n        $list = new Asset\\Listing();\n\n        $quotedIds = [];\n        foreach ($ids as $id) {\n            $quotedIds[] = $list->quote($id);\n        }\n\n        $list->setCondition('id IN (' . implode(',', $quotedIds) . ')');\n        $list->setOrderKey(' FIELD(id, ' . implode(',', $quotedIds) . ')', false);\n\n        $fields = $request->get('fields');\n\n        $addTitles = (bool) $request->get('initial');\n\n        $csv = $this->getCsvData($request, $language, $list, $fields, $addTitles);\n\n        try {\n            $storage = Storage::get('temp');\n            $csvFile = $this->getCsvFile($fileHandle);\n\n            $fileStream = $storage->readStream($csvFile);\n\n            $temp = tmpfile();\n            stream_copy_to_stream($fileStream, $temp, null, 0);\n\n            $firstLine = true;\n            foreach ($csv as $line) {\n                if ($addTitles && $firstLine) {\n                    $firstLine = false;\n                    $line = implode($delimiter, $line) . \"\\r\\n\";\n                    fwrite($temp, $line);\n                } else {\n                    fwrite($temp, implode($delimiter, array_map([$this, 'encodeFunc'], $line)) . \"\\r\\n\");\n                }\n            }\n            $storage->writeStream($csvFile, $temp);\n        } catch (UnableToReadFile $exception) {\n            Logger::err($exception->getMessage());\n\n            return $this->adminJson(\n                [\n                    'success' => false,\n                    'message' => sprintf('export file not found: %s', $fileHandle)\n                ]\n            );\n        }\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    public function encodeFunc(?string $value): string\n    {\n        $value = str_replace('\"', '\"\"', $value ?? '');\n\n        //force wrap value in quotes and return\n        return '\"' . $value . '\"';\n    }\n\n    protected function getCsvData(Request $request, string $language, Asset\\Listing $list, array $fields, bool $addTitles = true): array\n    {\n        //create csv\n        $csv = [];\n\n        $unsupportedFields = ['preview~system', 'size~system'];\n        $fields = array_diff($fields, $unsupportedFields);\n\n        if ($addTitles) {\n            $columns = $fields;\n            foreach ($columns as $columnIdx => $columnKey) {\n                $columns[$columnIdx] = '\"' . $columnKey . '\"';\n            }\n            $csv[] = $columns;\n        }\n\n        foreach ($list->load() as $asset) {\n            if ($fields) {\n                $dataRows = [];\n                foreach ($fields as $field) {\n                    $fieldDef = explode('~', $field);\n                    $getter = 'get' . ucfirst($fieldDef[0]);\n\n                    if (isset($fieldDef[1])) {\n                        if ($fieldDef[1] == 'system' && method_exists($asset, $getter)) {\n                            $data = $asset->$getter($language);\n                        } else {\n                            $fieldDef[1] = str_replace('none', '', $fieldDef[1]);\n                            $data = $asset->getMetadata($fieldDef[0], $fieldDef[1], true);\n                        }\n                    } else {\n                        $data = $asset->getMetadata($field, $language, true);\n                    }\n\n                    if ($data instanceof Element\\ElementInterface) {\n                        $data = $data->getRealFullPath();\n                    }\n                    $dataRows[] = $data;\n                }\n                $dataRows = Element\\Service::escapeCsvRecord($dataRows);\n                $csv[] = $dataRows;\n            }\n        }\n\n        return $csv;\n    }\n\n    protected function extractLanguage(Request $request): string\n    {\n        $requestedLanguage = $request->get('language');\n        if ($requestedLanguage) {\n            if ($requestedLanguage != 'default') {\n                $request->setLocale($requestedLanguage);\n            }\n        } else {\n            $requestedLanguage = $request->getLocale();\n        }\n\n        return $requestedLanguage;\n    }\n\n    protected function getCsvFile(string $fileHandle): string\n    {\n        return $fileHandle . '.csv';\n    }\n\n    /**\n     * @Route(\"/download-csv-file\", name=\"pimcore_admin_asset_assethelper_downloadcsvfile\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function downloadCsvFileAction(Request $request): Response\n    {\n        $storage = Storage::get('temp');\n        $fileHandle = File::getValidFilename($request->get('fileHandle'));\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        try {\n            $csvData = $storage->read($csvFile);\n            $response = new Response($csvData);\n            $response->headers->set('Content-Type', 'application/csv');\n            $disposition = HeaderUtils::makeDisposition(\n                HeaderUtils::DISPOSITION_ATTACHMENT,\n                'export.csv'\n            );\n\n            $response->headers->set('Content-Disposition', $disposition);\n            $storage->delete($csvFile);\n\n            return $response;\n        } catch (FilesystemException | UnableToReadFile $exception) {\n            // handle the error\n            throw $this->createNotFoundException('CSV file not found');\n        }\n    }\n\n    /**\n     * @Route(\"/download-xlsx-file\", name=\"pimcore_admin_asset_assethelper_downloadxlsxfile\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param GridHelperService $gridHelperService\n     *\n     * @return BinaryFileResponse\n     */\n    public function downloadXlsxFileAction(Request $request, GridHelperService $gridHelperService): BinaryFileResponse\n    {\n        $storage = Storage::get('temp');\n        $fileHandle = File::getValidFilename($request->get('fileHandle'));\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        try {\n            return $gridHelperService->createXlsxExportFile($storage, $fileHandle, $csvFile);\n        } catch (\\Exception | FilesystemException | UnableToReadFile $exception) {\n            // handle the error\n            throw $this->createNotFoundException('XLSX file not found');\n        }\n    }\n\n    /**\n     * @Route(\"/get-metadata-for-column-config\", name=\"pimcore_admin_asset_assethelper_getmetadataforcolumnconfig\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getMetadataForColumnConfigAction(Request $request): JsonResponse\n    {\n        $result = [];\n\n        //default metadata\n        $defaultMetadataNames = ['copyright', 'alt', 'title'];\n        foreach ($defaultMetadataNames as $defaultMetadata) {\n            $defaultColumns[] = ['title' => $defaultMetadata, 'name' => $defaultMetadata, 'datatype' => 'data', 'fieldtype' => 'input'];\n        }\n        $result['defaultColumns']['nodeLabel'] = 'default_metadata';\n        $result['defaultColumns']['nodeType'] = 'image';\n        $result['defaultColumns']['children'] = $defaultColumns;\n\n        //predefined metadata\n        $list = Metadata\\Predefined\\Listing::getByTargetType('asset');\n        $metadataItems = [];\n        $tmp = [];\n        foreach ($list as $item) {\n            //only allow unique metadata columns with subtypes\n            $uniqueKey = $item->getName().'_'.$item->getTargetSubtype();\n            if (!in_array($uniqueKey, $tmp) && !in_array($item->getName(), $defaultMetadataNames)) {\n                $tmp[] = $uniqueKey;\n                $item->expand();\n                $name = SecurityHelper::convertHtmlSpecialChars($item->getName());\n                $metadataItems[] = [\n                    'title' => $name,\n                    'name' => $name,\n                    'subtype' => $item->getTargetSubtype(),\n                    'datatype' => 'data',\n                    'fieldtype' => $item->getType(),\n                    'config' => $item->getConfig(),\n                ];\n            }\n        }\n\n        $result['metadataColumns']['children'] = $metadataItems;\n        $result['metadataColumns']['nodeLabel'] = 'predefined_metadata';\n        $result['metadataColumns']['nodeType'] = 'metadata';\n\n        //system columns\n        $systemColumnNames = Asset\\Service::GRID_SYSTEM_COLUMNS;\n        $systemColumns = [];\n        foreach ($systemColumnNames as $systemColumn) {\n            $systemColumns[] = ['title' => $systemColumn, 'name' => $systemColumn, 'datatype' => 'data', 'fieldtype' => 'system'];\n        }\n        $result['systemColumns']['nodeLabel'] = 'system_columns';\n        $result['systemColumns']['nodeType'] = 'system';\n        $result['systemColumns']['children'] = $systemColumns;\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @Route(\"/get-batch-jobs\", name=\"pimcore_admin_asset_assethelper_getbatchjobs\", methods={\"POST\"})\n     *\n     *\n     */\n    public function getBatchJobsAction(Request $request, GridHelperService $gridHelperService): JsonResponse\n    {\n        if ($request->get('language')) {\n            $request->setLocale($request->get('language'));\n        }\n\n        $allParams = array_merge($request->request->all(), $request->query->all());\n        $list = $gridHelperService->prepareAssetListingForGrid($allParams, $this->getAdminUser());\n\n        $jobs = $list->loadIdList();\n\n        return $this->adminJson(['success' => true, 'jobs' => $jobs]);\n    }\n\n    /**\n     * @Route(\"/batch\", name=\"pimcore_admin_asset_assethelper_batch\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     */\n    public function batchAction(Request $request, EventDispatcherInterface $eventDispatcher): JsonResponse\n    {\n        try {\n            if ($request->get('data')) {\n                $loader = \\Pimcore::getContainer()->get('pimcore.implementation_loader.asset.metadata.data');\n\n                $data = $this->decodeJson($request->get('data'), true);\n\n                $updateEvent = new GenericEvent($this, [\n                    'data' => $data,\n                    'processed' => false,\n                ]);\n\n                $eventDispatcher->dispatch($updateEvent, AdminEvents::ASSET_LIST_BEFORE_BATCH_UPDATE);\n\n                $processed = $updateEvent->getArgument('processed');\n\n                if ($processed) {\n                    return $this->adminJson(['success' => true]);\n                }\n\n                $language = null;\n                if (isset($data['language'])) {\n                    $language = $data['language'] != 'default' ? $data['language'] : null;\n                }\n\n                $asset = Asset::getById($data['job']);\n\n                if ($asset) {\n                    if (!$asset->isAllowed('publish')) {\n                        throw new \\Exception(\"Permission denied. You don't have the rights to save this asset.\");\n                    }\n\n                    $metadata = $asset->getMetadata(null, null, false, true);\n                    $dirty = false;\n\n                    $name = $data['name'];\n                    $value = $data['value'];\n\n                    if ($data['valueType'] == 'object') {\n                        $value = $this->decodeJson($value);\n                    }\n\n                    $fieldDef = explode('~', $name);\n                    $name = $fieldDef[0];\n                    if (count($fieldDef) > 1) {\n                        $language = ($fieldDef[1] == 'none' ? '' : $fieldDef[1]);\n                    }\n\n                    foreach ($metadata as $idx => &$em) {\n                        if ($em['name'] == $name && $em['language'] == $language) {\n                            try {\n                                $dataImpl = $loader->build($em['type']);\n                                $value = $dataImpl->getDataFromListfolderGrid($value, $em);\n                            } catch (UnsupportedException $le) {\n                                Logger::error('could not resolve metadata implementation for ' . $em['type']);\n                            }\n                            $em['data'] = $value;\n                            $dirty = true;\n\n                            break;\n                        }\n                    }\n\n                    if (!$dirty) {\n                        $defaulMetadata = ['title', 'alt', 'copyright'];\n                        if (in_array($name, $defaulMetadata)) {\n                            $newEm = [\n                                'name' => $name,\n                                'language' => $language,\n                                'type' => 'input',\n                                'data' => $value,\n                            ];\n\n                            try {\n                                $dataImpl = $loader->build($newEm['type']);\n                                $newEm['data'] = $dataImpl->getDataFromListfolderGrid($value, $newEm);\n                            } catch (UnsupportedException $le) {\n                                Logger::error('could not resolve metadata implementation for ' . $newEm['type']);\n                            }\n\n                            $metadata[] = $newEm;\n                            $dirty = true;\n                        } else {\n                            $predefined = Metadata\\Predefined::getByName($name);\n                            if ($predefined && (empty($predefined->getTargetSubtype())\n                                    || $predefined->getTargetSubtype() == $asset->getType())) {\n                                $newEm = [\n                                    'name' => $name,\n                                    'language' => $language,\n                                    'type' => $predefined->getType(),\n                                    'data' => $value,\n                                ];\n\n                                try {\n                                    $dataImpl = $loader->build($newEm['type']);\n                                    $newEm['data'] = $dataImpl->getDataFromListfolderGrid($value, $newEm);\n                                } catch (UnsupportedException $le) {\n                                    Logger::error('could not resolve metadata implementation for ' . $newEm['type']);\n                                }\n\n                                $metadata[] = $newEm;\n\n                                $dirty = true;\n                            }\n                        }\n                    }\n\n                    try {\n                        if ($dirty) {\n                            // $metadata = Asset\\Service::minimizeMetadata($metadata, \"grid\");\n                            $asset->setMetadataRaw($metadata);\n                            $asset->save();\n\n                            return $this->adminJson(['success' => true]);\n                        }\n                    } catch (\\Exception $e) {\n                        return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n                    }\n                } else {\n                    Logger::debug('AssetHelperController::batchAction => There is no asset left to update.');\n\n                    return $this->adminJson(['success' => false, 'message' => 'AssetHelperController::batchAction => There is no asset left to update.']);\n                }\n            }\n        } catch (\\Exception $e) {\n            Logger::err((string)$e);\n\n            return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n        }\n\n        return $this->adminJson(['success' => false, 'message' => 'something went wrong.']);\n    }\n}\n", "<?php\ndeclare(strict_types=1);\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Admin\\DataObject;\n\nuse League\\Flysystem\\FilesystemException;\nuse League\\Flysystem\\UnableToReadFile;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\AdminAbstractController;\nuse Pimcore\\Bundle\\AdminBundle\\Event\\AdminEvents;\nuse Pimcore\\Bundle\\AdminBundle\\Helper\\GridHelperService;\nuse Pimcore\\Bundle\\AdminBundle\\Model\\GridConfig;\nuse Pimcore\\Bundle\\AdminBundle\\Model\\GridConfigFavourite;\nuse Pimcore\\Bundle\\AdminBundle\\Model\\GridConfigShare;\nuse Pimcore\\Config;\nuse Pimcore\\Db;\nuse Pimcore\\File;\nuse Pimcore\\Localization\\LocaleServiceInterface;\nuse Pimcore\\Logger;\nuse Pimcore\\Model\\DataObject;\nuse Pimcore\\Model\\DataObject\\Listing;\nuse Pimcore\\Model\\User;\nuse Pimcore\\Security\\SecurityHelper;\nuse Pimcore\\Tool;\nuse Pimcore\\Tool\\Storage;\nuse Pimcore\\Version;\nuse Symfony\\Component\\EventDispatcher\\GenericEvent;\nuse Symfony\\Component\\Filesystem\\Filesystem;\nuse Symfony\\Component\\HttpFoundation\\BinaryFileResponse;\nuse Symfony\\Component\\HttpFoundation\\HeaderUtils;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\n\n/**\n * @Route(\"/object-helper\", name=\"pimcore_admin_dataobject_dataobjecthelper_\")\n *\n * @internal\n */\nclass DataObjectHelperController extends AdminAbstractController\n{\n    const SYSTEM_COLUMNS = ['id', 'fullpath', 'key', 'published', 'creationDate', 'modificationDate', 'filename', 'classname'];\n\n    /**\n     * @Route(\"/load-object-data\", name=\"loadobjectdata\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function loadObjectDataAction(Request $request): JsonResponse\n    {\n        $object = DataObject::getById((int) $request->get('id'));\n        $result = [];\n        if ($object) {\n            $result['success'] = true;\n            $fields = $request->get('fields');\n            $result['fields'] = DataObject\\Service::gridObjectData($object, $fields);\n        } else {\n            $result['success'] = false;\n        }\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @param int $userId\n     * @param string $classId\n     * @param string|null $searchType\n     *\n     * @return array\n     */\n    public function getMyOwnGridColumnConfigs(int $userId, string $classId, string $searchType = null): array\n    {\n        $db = Db::get();\n        $configListingConditionParts = [];\n        $configListingConditionParts[] = 'ownerId = ' . $userId;\n        $configListingConditionParts[] = 'classId = ' . $db->quote($classId);\n\n        if ($searchType) {\n            $configListingConditionParts[] = 'searchType = ' . $db->quote($searchType);\n        }\n\n        $configCondition = implode(' AND ', $configListingConditionParts);\n        $configListing = new GridConfig\\Listing();\n        $configListing->setOrderKey('name');\n        $configListing->setOrder('ASC');\n        $configListing->setCondition($configCondition);\n        $configListing = $configListing->load();\n\n        $configData = [];\n        if (is_array($configListing)) {\n            foreach ($configListing as $config) {\n                $configData[] = $config->getObjectVars();\n            }\n        }\n\n        return $configData;\n    }\n\n    /**\n     * @param User $user\n     * @param string $classId\n     * @param string|null $searchType\n     *\n     * @return array\n     */\n    public function getSharedGridColumnConfigs(User $user, string $classId, string $searchType = null): array\n    {\n        $configListing = [];\n\n        $userIds = [$user->getId()];\n        // collect all roles\n        $userIds = array_merge($userIds, $user->getRoles());\n        $userIds = implode(',', $userIds);\n        $db = Db::get();\n\n        $query = 'select distinct c1.id from gridconfigs c1, gridconfig_shares s\n                    where (c1.searchType = ' . $db->quote($searchType) . ' and ((c1.id = s.gridConfigId and s.sharedWithUserId IN (' . $userIds . '))) and c1.classId = ' . $db->quote($classId) . ')\n                            UNION distinct select c2.id from gridconfigs c2 where shareGlobally = 1 and c2.classId = '. $db->quote($classId) . '  and c2.ownerId != ' . $db->quote($user->getId());\n\n        $ids = $db->fetchFirstColumn($query);\n\n        if ($ids) {\n            $ids = implode(',', $ids);\n            $configListing = new GridConfig\\Listing();\n            $configListing->setOrderKey('name');\n            $configListing->setOrder('ASC');\n            $configListing->setCondition('id in (' . $ids . ')');\n            $configListing = $configListing->load();\n        }\n\n        $configData = [];\n        if (is_array($configListing)) {\n            foreach ($configListing as $config) {\n                $configData[] = $config->getObjectVars();\n            }\n        }\n\n        return $configData;\n    }\n\n    /**\n     * @Route(\"/get-export-configs\", name=\"getexportconfigs\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getExportConfigsAction(Request $request): JsonResponse\n    {\n        $classId = $request->get('classId');\n        $list = $this->getMyOwnGridColumnConfigs($this->getAdminUser()->getId(), $classId);\n        if (!is_array($list)) {\n            $list = [];\n        }\n        $list = array_merge($list, $this->getSharedGridColumnConfigs($this->getAdminUser(), $classId));\n        $result = [];\n\n        $result[] = [\n            'id' => -1,\n            'name' => '--default--',\n        ];\n\n        if ($list) {\n            /** @var GridConfig $config */\n            foreach ($list as $config) {\n                $result[] = [\n                    'id' => $config['id'],\n                    'name' => $config['name'],\n                ];\n            }\n        }\n\n        return $this->adminJson(['success' => true, 'data' => $result]);\n    }\n\n    /**\n     * @Route(\"/grid-delete-column-config\", name=\"griddeletecolumnconfig\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     * @param Config $config\n     *\n     * @return JsonResponse\n     */\n    public function gridDeleteColumnConfigAction(Request $request, EventDispatcherInterface $eventDispatcher, Config $config): JsonResponse\n    {\n        $gridConfigId = (int)$request->get('gridConfigId');\n        $gridConfig = GridConfig::getById($gridConfigId);\n        $success = false;\n        if ($gridConfig) {\n            if ($gridConfig->getOwnerId() != $this->getAdminUser()->getId() && !$this->getAdminUser()->isAdmin()) {\n                throw new \\Exception(\"don't mess with someone elses grid config\");\n            }\n\n            $gridConfig->delete();\n            $success = true;\n        }\n\n        $newGridConfig = $this->doGetGridColumnConfig($request, $config, true);\n        $newGridConfig['deleteSuccess'] = $success;\n\n        $event = new GenericEvent($this, [\n            'data' => $newGridConfig,\n            'request' => $request,\n            'config' => $config,\n            'context' => 'delete',\n        ]);\n\n        $eventDispatcher->dispatch($event, AdminEvents::OBJECT_GRID_GET_COLUMN_CONFIG_PRE_SEND_DATA);\n        $newGridConfig = $event->getArgument('data');\n\n        return $this->adminJson($newGridConfig);\n    }\n\n    /**\n     * @Route(\"/grid-get-column-config\", name=\"gridgetcolumnconfig\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     * @param Config $config\n     *\n     * @return JsonResponse\n     */\n    public function gridGetColumnConfigAction(Request $request, EventDispatcherInterface $eventDispatcher, Config $config): JsonResponse\n    {\n        $result = $this->doGetGridColumnConfig($request, $config);\n\n        $event = new GenericEvent($this, [\n            'data' => $result,\n            'request' => $request,\n            'config' => $config,\n            'context' => 'get',\n        ]);\n\n        $eventDispatcher->dispatch($event, AdminEvents::OBJECT_GRID_GET_COLUMN_CONFIG_PRE_SEND_DATA);\n        $result = $event->getArgument('data');\n\n        return $this->adminJson($result);\n    }\n\n    public function doGetGridColumnConfig(Request $request, Config $config, bool $isDelete = false): array\n    {\n        $class = null;\n        $fields = null;\n\n        if ($request->get('id')) {\n            $class = DataObject\\ClassDefinition::getById($request->get('id'));\n        } elseif ($request->get('name')) {\n            $class = DataObject\\ClassDefinition::getByName($request->get('name'));\n        }\n\n        $gridConfigId = null;\n        $gridType = 'search';\n        if ($request->get('gridtype')) {\n            $gridType = $request->get('gridtype');\n        }\n\n        $objectId = (int) $request->get('objectId');\n\n        if ($objectId) {\n            $fields = DataObject\\Service::getCustomGridFieldDefinitions($class->getId(), $objectId);\n        }\n\n        $context = ['purpose' => 'gridconfig'];\n        if ($class) {\n            $context['class'] = $class;\n        }\n\n        if ($objectId) {\n            $object = DataObject::getById($objectId);\n            $context['object'] = $object;\n        }\n\n        if (!$fields && $class) {\n            $fields = $class->getFieldDefinitions();\n        }\n\n        $types = [];\n        if ($request->get('types')) {\n            $types = explode(',', $request->get('types'));\n        }\n\n        $userId = $this->getAdminUser()->getId();\n\n        $requestedGridConfigId = $isDelete ? null : $request->get('gridConfigId');\n\n        // grid config\n        $gridConfig = [];\n        $searchType = $request->get('searchType');\n\n        if (strlen($requestedGridConfigId ?? '') == 0 && $class) {\n            // check if there is a favourite view\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId($userId, $class->getId(), $objectId ?: 0, $searchType);\n            if (!$favourite && $objectId) {\n                $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId($userId, $class->getId(), 0, $searchType);\n            }\n\n            if ($favourite) {\n                $requestedGridConfigId = $favourite->getGridConfigId();\n            }\n        }\n\n        if (is_numeric($requestedGridConfigId) && $requestedGridConfigId > 0) {\n            $db = Db::get();\n            $savedGridConfig = GridConfig::getById((int) $requestedGridConfigId);\n\n            if ($savedGridConfig) {\n                $shared = false;\n                if (!$this->getAdminUser()->isAdmin()) {\n                    $userIds = [$this->getAdminUser()->getId()];\n                    $userIds = array_merge($userIds, $this->getAdminUser()->getRoles());\n                    $userIds = implode(',', $userIds);\n                    $shared = ($savedGridConfig->getOwnerId() != $userId && $savedGridConfig->isShareGlobally()) || $db->fetchOne('select 1 from gridconfig_shares where sharedWithUserId IN ('.$userIds.') and gridConfigId = '.$savedGridConfig->getId());\n                    //                  $shared = $savedGridConfig->isShareGlobally() || GridConfigShare::getByGridConfigAndSharedWithId($savedGridConfig->getId(), $this->getUser()->getId());\n\n                    if (!$shared && $savedGridConfig->getOwnerId() != $this->getAdminUser()->getId()) {\n                        throw new \\Exception('You are neither the owner of this config nor it is shared with you');\n                    }\n                }\n\n                $gridConfigId = $savedGridConfig->getId();\n                $gridConfig = $savedGridConfig->getConfig();\n                $gridConfig = json_decode($gridConfig, true);\n                $gridConfigName = SecurityHelper::convertHtmlSpecialChars($savedGridConfig->getName());\n                $owner = $savedGridConfig->getOwnerId();\n                $ownerObject = User::getById($owner);\n                if ($ownerObject instanceof User) {\n                    $owner = $ownerObject->getName();\n                }\n                $modificationDate = $savedGridConfig->getModificationDate();\n                $gridConfigDescription = SecurityHelper::convertHtmlSpecialChars($savedGridConfig->getDescription());\n                $sharedGlobally = $savedGridConfig->isShareGlobally();\n                $setAsFavourite = $savedGridConfig->isSetAsFavourite();\n                $saveFilters = $savedGridConfig->isSaveFilters();\n\n                foreach($gridConfig['columns'] as &$column) {\n                    if (array_key_exists('isOperator', $column) && $column['isOperator']) {\n                        $colAttributes = &$column['fieldConfig']['attributes'];\n                        SecurityHelper::convertHtmlSpecialCharsArrayKeys($colAttributes, ['label', 'attribute', 'param1']);\n                    }\n                }\n            }\n        }\n\n        $localizedFields = [];\n        $objectbrickFields = [];\n        if (is_array($fields)) {\n            foreach ($fields as $key => $field) {\n                if ($field instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    $localizedFields[] = $field;\n                } elseif ($field instanceof DataObject\\ClassDefinition\\Data\\Objectbricks) {\n                    $objectbrickFields[] = $field;\n                }\n            }\n        }\n\n        $availableFields = [];\n\n        if (empty($gridConfig)) {\n            $availableFields = $this->getDefaultGridFields(\n                $request->query->getBoolean('no_system_columns'),\n                $class,\n                $gridType,\n                $request->query->getBoolean('no_brick_columns'),\n                $fields,\n                $context,\n                $objectId,\n                $types\n            );\n        } else {\n            $savedColumns = $gridConfig['columns'];\n            foreach ($savedColumns as $key => $sc) {\n                if (!$sc['hidden']) {\n                    if (in_array($key, self::SYSTEM_COLUMNS)) {\n                        $colConfig = [\n                            'key' => $key,\n                            'type' => 'system',\n                            'label' => $key,\n                            'locked' => $sc['locked'] ?? null,\n                            'position' => $sc['position'],\n                        ];\n                        if (isset($sc['width'])) {\n                            $colConfig['width'] = $sc['width'];\n                        }\n                        $availableFields[] = $colConfig;\n                    } else {\n                        $keyParts = explode('~', $key);\n\n                        if (substr($key, 0, 1) == '~') {\n                            // not needed for now\n                            $type = $keyParts[1];\n                            //                            $field = $keyParts[2];\n                            $groupAndKeyId = explode('-', $keyParts[3]);\n                            $keyId = (int) $groupAndKeyId[1];\n\n                            if ($type == 'classificationstore') {\n                                $keyDef = DataObject\\Classificationstore\\KeyConfig::getById($keyId);\n                                if ($keyDef) {\n                                    $keyFieldDef = json_decode($keyDef->getDefinition(), true);\n                                    if ($keyFieldDef) {\n                                        $keyFieldDef = \\Pimcore\\Model\\DataObject\\Classificationstore\\Service::getFieldDefinitionFromJson($keyFieldDef, $keyDef->getType());\n                                        $fieldConfig = $this->getFieldGridConfig($keyFieldDef, $gridType, (string)$sc['position'], true, null, $class, $objectId);\n                                        if ($fieldConfig) {\n                                            $fieldConfig['key'] = $key;\n                                            $fieldConfig['label'] = '#' . $keyFieldDef->getTitle();\n                                            if (isset($sc['locked'])) {\n                                                $fieldConfig['locked'] = $sc['locked'];\n                                            }\n                                            $availableFields[] = $fieldConfig;\n                                        }\n                                    }\n                                }\n                            }\n                        } elseif (count($keyParts) > 1) {\n                            $brick = $keyParts[0];\n                            $brickDescriptor = null;\n\n                            if (strpos($brick, '?') !== false) {\n                                $brickDescriptor = substr($brick, 1);\n                                $brickDescriptor = json_decode($brickDescriptor, true);\n                                $keyPrefix = $brick . '~';\n                                $brick = $brickDescriptor['containerKey'];\n                            } else {\n                                $keyPrefix = $brick . '~';\n                            }\n\n                            $fieldname = $keyParts[1];\n\n                            $brickClass = DataObject\\Objectbrick\\Definition::getByKey($brick);\n\n                            $fd = null;\n                            if ($brickClass instanceof DataObject\\Objectbrick\\Definition) {\n                                if ($brickDescriptor) {\n                                    $innerContainer = $brickDescriptor['innerContainer'] ?? 'localizedfields';\n                                    /** @var DataObject\\ClassDefinition\\Data\\Localizedfields $localizedFields */\n                                    $localizedFields = $brickClass->getFieldDefinition($innerContainer);\n                                    $fd = $localizedFields->getFieldDefinition($brickDescriptor['brickfield']);\n                                } else {\n                                    $fd = $brickClass->getFieldDefinition($fieldname);\n                                }\n                            }\n\n                            if ($fd !== null) {\n                                $fieldConfig = $this->getFieldGridConfig($fd, $gridType, (string)$sc['position'], true, $keyPrefix, $class, $objectId);\n                                if (!empty($fieldConfig)) {\n                                    if (isset($sc['width'])) {\n                                        $fieldConfig['width'] = $sc['width'];\n                                    }\n                                    if (isset($sc['locked'])) {\n                                        $fieldConfig['locked'] = $sc['locked'];\n                                    }\n                                    $availableFields[] = $fieldConfig;\n                                }\n                            }\n                        } else {\n                            if (DataObject\\Service::isHelperGridColumnConfig($key)) {\n                                $calculatedColumnConfig = $this->getCalculatedColumnConfig($request, $savedColumns[$key]);\n                                if ($calculatedColumnConfig) {\n                                    $availableFields[] = $calculatedColumnConfig;\n                                }\n                            } else {\n                                $fd = $class->getFieldDefinition($key);\n                                //if not found, look for localized fields\n                                if (empty($fd)) {\n                                    foreach ($localizedFields as $lf) {\n                                        $fd = $lf->getFieldDefinition($key);\n                                        if (!empty($fd)) {\n                                            break;\n                                        }\n                                    }\n                                }\n\n                                if (!empty($fd)) {\n                                    $fieldConfig = $this->getFieldGridConfig($fd, $gridType, (string)$sc['position'], true, null, $class, $objectId);\n                                    if (!empty($fieldConfig)) {\n                                        if (isset($sc['width'])) {\n                                            $fieldConfig['width'] = $sc['width'];\n                                        }\n                                        if (isset($sc['locked'])) {\n                                            $fieldConfig['locked'] = $sc['locked'];\n                                        }\n                                        $availableFields[] = $fieldConfig;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        usort($availableFields, function ($a, $b) {\n            if ($a['position'] == $b['position']) {\n                return 0;\n            }\n\n            return ($a['position'] < $b['position']) ? -1 : 1;\n        });\n\n        $frontendLanguages = Tool\\Admin::reorderWebsiteLanguages(\\Pimcore\\Tool\\Admin::getCurrentUser(), $config['general']['valid_languages']);\n        if ($frontendLanguages) {\n            $language = $frontendLanguages[0];\n        } else {\n            $language = $request->getLocale();\n        }\n\n        if (!Tool::isValidLanguage($language)) {\n            $validLanguages = Tool::getValidLanguages();\n            $language = $validLanguages[0];\n        }\n\n        if (!empty($gridConfig) && !empty($gridConfig['language'])) {\n            $language = $gridConfig['language'];\n        }\n\n        $availableConfigs = $class ? $this->getMyOwnGridColumnConfigs($userId, $class->getId(), $searchType) : [];\n        $sharedConfigs = $class ? $this->getSharedGridColumnConfigs($this->getAdminUser(), $class->getId(), $searchType) : [];\n        $settings = $this->getShareSettings((int)$gridConfigId);\n        $settings['gridConfigId'] = (int)$gridConfigId;\n        $settings['gridConfigName'] = $gridConfigName ?? null;\n        $settings['gridConfigDescription'] = $gridConfigDescription ?? null;\n        $settings['owner'] = $owner ?? null;\n        $settings['modificationDate'] = $modificationDate ?? null;\n        $settings['shareGlobally'] = $sharedGlobally ?? null;\n        $settings['setAsFavourite'] = $setAsFavourite ?? null;\n        $settings['saveFilters'] = $saveFilters ?? null;\n        $settings['isShared'] = !$gridConfigId || ($shared ?? null);\n\n        $context = $gridConfig['context'] ?? null;\n        if ($context) {\n            $context = json_decode($context, true);\n        }\n\n        return [\n            'sortinfo' => $gridConfig['sortinfo'] ?? false,\n            'language' => $language,\n            'availableFields' => $availableFields,\n            'settings' => $settings,\n            'onlyDirectChildren' => $gridConfig['onlyDirectChildren'] ?? false,\n            'pageSize' => $gridConfig['pageSize'] ?? false,\n            'availableConfigs' => $availableConfigs,\n            'sharedConfigs' => $sharedConfigs,\n            'context' => $context,\n            'searchFilter' => $gridConfig['searchFilter'] ?? '',\n            'filter' => $gridConfig['filter'] ?? [],\n        ];\n    }\n\n    /**\n     * @param DataObject\\ClassDefinition\\Data[]|null $fields\n     */\n    public function getDefaultGridFields(bool $noSystemColumns, ?DataObject\\ClassDefinition $class, string $gridType, bool $noBrickColumns, ?array $fields, array $context, int $objectId, array $types = []): array\n    {\n        $count = 0;\n        $availableFields = [];\n\n        if (!$noSystemColumns && $class) {\n            $vis = $class->getPropertyVisibility();\n            foreach (self::SYSTEM_COLUMNS as $sc) {\n                $key = $sc;\n                if ($key === 'fullpath') {\n                    $key = 'path';\n                }\n\n                if (empty($types) && (!empty($vis[$gridType][$key]) || $gridType === 'all')) {\n                    $availableFields[] = [\n                        'key' => $sc,\n                        'type' => 'system',\n                        'label' => $sc,\n                        'position' => $count, ];\n                    $count++;\n                }\n            }\n        }\n\n        $includeBricks = !$noBrickColumns;\n\n        if (is_array($fields)) {\n            foreach ($fields as $key => $field) {\n                if ($field instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    foreach ($field->getFieldDefinitions($context) as $fd) {\n                        if (empty($types) || in_array($fd->getFieldType(), $types)) {\n                            $fieldConfig = $this->getFieldGridConfig($fd, $gridType, (string)$count, false, null, $class, $objectId);\n                            if (!empty($fieldConfig)) {\n                                $availableFields[] = $fieldConfig;\n                                $count++;\n                            }\n                        }\n                    }\n                } elseif ($field instanceof DataObject\\ClassDefinition\\Data\\Objectbricks && $includeBricks) {\n                    if (in_array($field->getFieldType(), $types)) {\n                        $fieldConfig = $this->getFieldGridConfig($field, $gridType, (string)$count, false, null, $class, $objectId);\n                        if (!empty($fieldConfig)) {\n                            $availableFields[] = $fieldConfig;\n                            $count++;\n                        }\n                    } else {\n                        $allowedTypes = $field->getAllowedTypes();\n                        if (!empty($allowedTypes)) {\n                            foreach ($allowedTypes as $t) {\n                                $brickClass = DataObject\\Objectbrick\\Definition::getByKey($t);\n                                $brickFields = $brickClass->getFieldDefinitions($context);\n\n                                $this->appendBrickFields($field, $brickFields, $availableFields, $gridType, $count, $t, $class, $objectId);\n                            }\n                        }\n                    }\n                } else {\n                    if (empty($types) || in_array($field->getFieldType(), $types)) {\n                        $fieldConfig = $this->getFieldGridConfig($field, $gridType, (string)$count, !empty($types), null, $class, $objectId);\n                        if (!empty($fieldConfig)) {\n                            $availableFields[] = $fieldConfig;\n                            $count++;\n                        }\n                    }\n                }\n            }\n        }\n\n        return $availableFields;\n    }\n\n    /**\n     * @param DataObject\\ClassDefinition\\Data $field\n     * @param DataObject\\ClassDefinition\\Data[] $brickFields\n     * @param array $availableFields\n     * @param string $gridType\n     * @param int $count\n     * @param string $brickType\n     * @param DataObject\\ClassDefinition $class\n     * @param int $objectId\n     * @param array|null $context\n     */\n    protected function appendBrickFields(DataObject\\ClassDefinition\\Data $field, array $brickFields, array &$availableFields, string $gridType, int &$count, string $brickType, DataObject\\ClassDefinition $class, int $objectId, array $context = null): void\n    {\n        if (!empty($brickFields)) {\n            foreach ($brickFields as $bf) {\n                if ($bf instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    $localizedFieldDefinitions = $bf->getFieldDefinitions();\n\n                    $localizedContext = [\n                        'containerKey' => $brickType,\n                        'fieldname' => $field->getName(),\n                    ];\n\n                    $this->appendBrickFields($bf, $localizedFieldDefinitions, $availableFields, $gridType, $count, $brickType, $class, $objectId, $localizedContext);\n                } else {\n                    if ($context) {\n                        $context['brickfield'] = $bf->getName();\n                        $keyPrefix = '?' . json_encode($context) . '~';\n                    } else {\n                        $keyPrefix = $brickType . '~';\n                    }\n                    $fieldConfig = $this->getFieldGridConfig($bf, $gridType, (string)$count, false, $keyPrefix, $class, $objectId);\n                    if (!empty($fieldConfig)) {\n                        $availableFields[] = $fieldConfig;\n                        $count++;\n                    }\n                }\n            }\n        }\n    }\n\n    protected function getCalculatedColumnConfig(Request $request, array $config): mixed\n    {\n        try {\n            $calculatedColumnConfig = Tool\\Session::useBag($request->getSession(), function (AttributeBagInterface $session) use ($config) {\n                //otherwise create a new one\n\n                $calculatedColumn = [];\n                // note that we have to generate a new key!\n\n                $existingKey = $config['fieldConfig']['key'];\n                $calculatedColumnConfig['key'] = $existingKey;\n                $calculatedColumnConfig['position'] = $config['position'];\n                $calculatedColumnConfig['isOperator'] = true;\n                $calculatedColumnConfig['attributes'] = $config['fieldConfig']['attributes'];\n                $calculatedColumnConfig['width'] = $config['width'];\n                $calculatedColumnConfig['locked'] = $config['locked'];\n\n                $existingColumns = $session->get('helpercolumns', []);\n\n                if (isset($existingColumns[$existingKey])) {\n                    // if the configuration is still in the session, then reuse it\n                    return $calculatedColumnConfig;\n                }\n\n                $newKey = '#' . uniqid();\n                $calculatedColumnConfig['key'] = $newKey;\n\n                // prepare a column config on the fly\n                $phpConfig = json_encode($config['fieldConfig']);\n                $phpConfig = json_decode($phpConfig);\n                $helperColumns = [];\n                $helperColumns[$newKey] = $phpConfig;\n\n                $helperColumns = array_merge($helperColumns, $existingColumns);\n                $session->set('helpercolumns', $helperColumns);\n\n                return $calculatedColumnConfig;\n            }, 'pimcore_gridconfig');\n\n            return $calculatedColumnConfig;\n        } catch (\\Exception $e) {\n            Logger::error((string) $e);\n        }\n\n        return null;\n    }\n\n    /**\n     * @Route(\"/prepare-helper-column-configs\", name=\"preparehelpercolumnconfigs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function prepareHelperColumnConfigs(Request $request): JsonResponse\n    {\n        $helperColumns = [];\n        $newData = [];\n        /** @var \\stdClass[] $data */\n        $data = json_decode($request->get('columns'));\n        foreach ($data as $item) {\n            if (!empty($item->isOperator)) {\n                $itemKey = '#' . uniqid();\n\n                $item->key = $itemKey;\n                $newData[] = $item;\n                $helperColumns[$itemKey] = $item;\n            } else {\n                $newData[] = $item;\n            }\n        }\n\n        Tool\\Session::useBag($request->getSession(), function (AttributeBagInterface $session) use ($helperColumns) {\n            $existingColumns = $session->get('helpercolumns', []);\n            $helperColumns = array_merge($helperColumns, $existingColumns);\n            $session->set('helpercolumns', $helperColumns);\n        }, 'pimcore_gridconfig');\n\n        return $this->adminJson(['success' => true, 'columns' => $newData]);\n    }\n\n    /**\n     * @Route(\"/grid-config-apply-to-all\", name=\"gridconfigapplytoall\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridConfigApplyToAllAction(Request $request): JsonResponse\n    {\n        $objectId = $request->request->getInt('objectId');\n        $object = DataObject::getById($objectId);\n\n        if ($object->isAllowed('list')) {\n            $classId = $request->get('classId');\n            $searchType = $request->get('searchType');\n            $user = $this->getAdminUser();\n            $db = Db::get();\n            $db->executeQuery('delete from gridconfig_favourites where '\n                . 'ownerId = ' . $user->getId()\n                . ' and classId = ' . $db->quote($classId) .\n                ' and searchType = ' . $db->quote($searchType)\n                . ' and objectId != ' . $objectId . ' and objectId != 0');\n\n            return $this->adminJson(['success' => true]);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @Route(\"/grid-mark-favourite-column-config\", name=\"gridmarkfavouritecolumnconfig\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridMarkFavouriteColumnConfigAction(Request $request): JsonResponse\n    {\n        $objectId = (int)$request->get('objectId');\n        $object = DataObject::getById($objectId);\n\n        if ($object->isAllowed('list')) {\n            $classId = $request->get('classId');\n            $gridConfigId = $request->get('gridConfigId');\n            $searchType = $request->get('searchType');\n            $global = $request->get('global');\n            $user = $this->getAdminUser();\n            $type = $request->get('type');\n\n            $favourite = new GridConfigFavourite();\n            $favourite->setOwnerId($user->getId());\n            $class = DataObject\\ClassDefinition::getById($classId);\n            if (!$class) {\n                throw new \\Exception('class ' . $classId . ' does not exist anymore');\n            }\n            $favourite->setClassId($classId);\n            $favourite->setSearchType($searchType);\n            $favourite->setType($type);\n            $specializedConfigs = false;\n\n            try {\n                if ($gridConfigId != 0) {\n                    $gridConfig = GridConfig::getById((int)$gridConfigId);\n                    $favourite->setGridConfigId($gridConfig->getId());\n                }\n                $favourite->setObjectId($objectId);\n                $favourite->save();\n\n                if ($global) {\n                    $favourite->setObjectId(0);\n                    $favourite->save();\n                }\n                $db = Db::get();\n                $count = $db->fetchOne('select * from gridconfig_favourites where '\n                    . 'ownerId = ' . $user->getId()\n                    . ' and classId = ' . $db->quote($classId).\n                    ' and searchType = ' . $db->quote($searchType)\n                    . ' and objectId != ' . $objectId . ' and objectId != 0'\n                    . ' and `type` != ' . $db->quote($type));\n                $specializedConfigs = $count > 0;\n            } catch (\\Exception $e) {\n                $favourite->delete();\n            }\n\n            return $this->adminJson(['success' => true, 'spezializedConfigs' => $specializedConfigs]);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    protected function getShareSettings(int $gridConfigId): array\n    {\n        $result = [\n            'sharedUserIds' => [],\n            'sharedRoleIds' => [],\n        ];\n\n        $db = Db::get();\n        $allShares = $db->fetchAllAssociative('select s.sharedWithUserId, u.type from gridconfig_shares s, users u\n                      where s.sharedWithUserId = u.id and s.gridConfigId = ' . $gridConfigId);\n\n        if ($allShares) {\n            foreach ($allShares as $share) {\n                $type = $share['type'];\n                $key = 'shared' . ucfirst($type) . 'Ids';\n                $result[$key][] = $share['sharedWithUserId'];\n            }\n        }\n\n        foreach ($result as $idx => $value) {\n            $value = $value ? implode(',', $value) : '';\n            $result[$idx] = $value;\n        }\n\n        return $result;\n    }\n\n    /**\n     * @Route(\"/grid-save-column-config\", name=\"gridsavecolumnconfig\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridSaveColumnConfigAction(Request $request): JsonResponse\n    {\n        $objectId = $request->request->getInt('id');\n        $object   = DataObject::getById($objectId);\n\n        if ($object->isAllowed('list')) {\n            try {\n                $classId = $request->get('class_id');\n                $context = $request->get('context');\n\n                $searchType = $request->get('searchType');\n\n                // grid config\n                $gridConfigData = $this->decodeJson($request->get('gridconfig'));\n                $gridConfigData['pimcore_version'] = Version::getVersion();\n                $gridConfigData['pimcore_revision'] = Version::getRevision();\n\n                $gridConfigData['context'] = $context;\n\n                unset($gridConfigData['settings']['isShared']);\n\n                $metadata = $request->get('settings');\n                $metadata = json_decode($metadata, true);\n\n                $gridConfigId = $metadata['gridConfigId'];\n                $gridConfig = null;\n                if ($gridConfigId) {\n                    $gridConfig = GridConfig::getById($gridConfigId);\n                }\n\n                if ($gridConfig && $gridConfig->getOwnerId() != $this->getAdminUser()->getId() && !$this->getAdminUser()->isAdmin()) {\n                    throw new \\Exception(\"don't mess around with somebody elses configuration\");\n                }\n\n                $this->updateGridConfigShares($gridConfig, $metadata);\n\n                if ($metadata['setAsFavourite'] && $this->getAdminUser()->isAdmin()) {\n                    $this->updateGridConfigFavourites($gridConfig, $metadata, $objectId);\n                }\n\n                if (!$gridConfig) {\n                    $gridConfig = new GridConfig();\n                    $gridConfig->setName(date('c'));\n                    $gridConfig->setClassId($classId);\n                    $gridConfig->setSearchType($searchType);\n\n                    $gridConfig->setOwnerId($this->getAdminUser()->getId());\n                }\n\n                if ($metadata) {\n                    $gridConfig->setName(SecurityHelper::convertHtmlSpecialChars($metadata['gridConfigName']));\n                    $gridConfig->setDescription(SecurityHelper::convertHtmlSpecialChars($metadata['gridConfigDescription']));\n                    $gridConfig->setShareGlobally($metadata['shareGlobally'] && $this->getAdminUser()->isAdmin());\n                    $gridConfig->setSetAsFavourite($metadata['setAsFavourite'] && $this->getAdminUser()->isAdmin());\n                    $gridConfig->setSaveFilters($metadata['saveFilters'] ?? false);\n                }\n\n                $gridConfigData = json_encode($gridConfigData);\n                $gridConfig->setConfig($gridConfigData);\n                $gridConfig->save();\n\n                $userId = $this->getAdminUser()->getId();\n\n                $availableConfigs = $this->getMyOwnGridColumnConfigs($userId, $classId, $searchType);\n                $sharedConfigs = $this->getSharedGridColumnConfigs($this->getAdminUser(), $classId, $searchType);\n\n                $settings = $this->getShareSettings($gridConfig->getId());\n                $settings['gridConfigId'] = (int)$gridConfig->getId();\n                $settings['gridConfigName'] = SecurityHelper::convertHtmlSpecialChars($gridConfig->getName());\n                $settings['gridConfigDescription'] = SecurityHelper::convertHtmlSpecialChars($gridConfig->getDescription());\n                $settings['shareGlobally'] = $gridConfig->isShareGlobally();\n                $settings['setAsFavourite'] = $gridConfig->isSetAsFavourite();\n                $settings['saveFilters'] = $gridConfig->isSaveFilters();\n                $settings['isShared'] = $gridConfig->getOwnerId() != $this->getAdminUser()->getId() && !$this->getAdminUser()->isAdmin();\n\n                return $this->adminJson([\n                    'success' => true,\n                    'settings' => $settings,\n                    'availableConfigs' => $availableConfigs,\n                    'sharedConfigs' => $sharedConfigs,\n                ]);\n            } catch (\\Exception $e) {\n                return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n            }\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @param GridConfig|null $gridConfig\n     * @param array $metadata\n     *\n     * @throws \\Exception\n     */\n    protected function updateGridConfigShares(?GridConfig $gridConfig, array $metadata): void\n    {\n        $user = $this->getAdminUser();\n        if (!$gridConfig || !$user->isAllowed('share_configurations')) {\n            // nothing to do\n            return;\n        }\n\n        if ($gridConfig->getOwnerId() != $user->getId() && !$user->isAdmin()) {\n            throw new \\Exception(\"don't mess with someone elses grid config\");\n        }\n        $combinedShares = [];\n        $sharedUserIds = $metadata['sharedUserIds'];\n        $sharedRoleIds = $metadata['sharedRoleIds'];\n\n        if ($sharedUserIds) {\n            $combinedShares = explode(',', $sharedUserIds);\n        }\n\n        if ($sharedRoleIds) {\n            $sharedRoleIds = explode(',', $sharedRoleIds);\n            $combinedShares = array_merge($combinedShares, $sharedRoleIds);\n        }\n\n        $db = Db::get();\n        $db->delete('gridconfig_shares', ['gridConfigId' => $gridConfig->getId()]);\n\n        foreach ($combinedShares as $id) {\n            $share = new GridConfigShare();\n            $share->setGridConfigId($gridConfig->getId());\n            $share->setSharedWithUserId((int) $id);\n            $share->save();\n        }\n    }\n\n    /**\n     * @param GridConfig|null $gridConfig\n     * @param array $metadata\n     * @param int $objectId\n     *\n     * @throws \\Exception\n     */\n    protected function updateGridConfigFavourites(?GridConfig $gridConfig, array $metadata, int $objectId): void\n    {\n        $currentUser = $this->getAdminUser();\n\n        if (!$gridConfig || $currentUser === null || !$currentUser->isAllowed('share_configurations')) {\n            // nothing to do\n            return;\n        }\n\n        if (!$currentUser->isAdmin() && (int) $gridConfig->getOwnerId() !== $currentUser->getId()) {\n            throw new \\Exception(\"don't mess with someone elses grid config\");\n        }\n\n        $sharedUsers = [];\n\n        if ($metadata['shareGlobally'] === false) {\n            $sharedUserIds = $metadata['sharedUserIds'];\n\n            if ($sharedUserIds) {\n                $sharedUsers = explode(',', $sharedUserIds);\n            }\n        }\n\n        if ($metadata['shareGlobally'] === true) {\n            $users = new User\\Listing();\n            $users->setCondition('id = ?', $currentUser->getId());\n\n            foreach ($users as $user) {\n                $sharedUsers[] = $user->getId();\n            }\n        }\n\n        foreach ($sharedUsers as $id) {\n            $global    = true;\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId(\n                (int) $id,\n                $gridConfig->getClassId(),\n                $objectId,\n                $gridConfig->getSearchType()\n            );\n\n            // If the user has already a favourite for that object we check the current favourite and decide if we update\n            if ($favourite instanceof GridConfigFavourite) {\n                $favouriteGridConfig = GridConfig::getById($favourite->getGridConfigId());\n\n                if ($favouriteGridConfig instanceof GridConfig) {\n                    // Check if the grid config was shared globally if that is *not* the case we also not update\n                    if ($favouriteGridConfig->isShareGlobally() === false) {\n                        continue;\n                    }\n\n                    // Check if the user is the owner. If that is the case we do not update the favourite\n                    if ((int) $favouriteGridConfig->getOwnerId() === (int) $id) {\n                        continue;\n                    }\n                }\n            }\n\n            // Check if the user has already a global favourite then we do not save the favourite as global\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId(\n                (int) $id,\n                $gridConfig->getClassId(),\n                0,\n                $gridConfig->getSearchType()\n            );\n\n            if ($favourite instanceof GridConfigFavourite) {\n                $favouriteGridConfig = GridConfig::getById($favourite->getGridConfigId());\n\n                if ($favouriteGridConfig instanceof GridConfig) {\n                    // Check if the grid config was shared globally if that is *not* the case we also not update\n                    if ($favouriteGridConfig->isShareGlobally() === false) {\n                        $global = false;\n                    }\n\n                    // Check if the user is the owner. If that is the case we do not update the global favourite\n                    if ($favouriteGridConfig->getOwnerId() === (int) $id) {\n                        $global = false;\n                    }\n                }\n            }\n\n            $favourite = new GridConfigFavourite();\n            $favourite->setGridConfigId($gridConfig->getId());\n            $favourite->setClassId($gridConfig->getClassId());\n            $favourite->setObjectId($objectId);\n            $favourite->setOwnerId($id);\n            $favourite->setType($gridConfig->getType());\n            $favourite->setSearchType($gridConfig->getSearchType());\n            $favourite->save();\n\n            if ($global === true) {\n                $favourite->setObjectId(0);\n                $favourite->save();\n            }\n        }\n    }\n\n    /**\n     * @param DataObject\\ClassDefinition\\Data $field\n     * @param string $gridType\n     * @param string $position\n     * @param bool $force\n     * @param string|null $keyPrefix\n     * @param DataObject\\ClassDefinition|null $class\n     * @param int|null $objectId\n     *\n     * @return array|null\n     */\n    protected function getFieldGridConfig(DataObject\\ClassDefinition\\Data $field, string $gridType, string $position, bool $force = false, string $keyPrefix = null, DataObject\\ClassDefinition $class = null, int $objectId = null): ?array\n    {\n        $key = $keyPrefix . $field->getName();\n        $config = null;\n        $title = $field->getName();\n        if (method_exists($field, 'getTitle')) {\n            if ($field->getTitle()) {\n                $title = $field->getTitle();\n            }\n        }\n\n        if ($field instanceof DataObject\\ClassDefinition\\Data\\Slider) {\n            $config['minValue'] = $field->getMinValue();\n            $config['maxValue'] = $field->getMaxValue();\n            $config['increment'] = $field->getIncrement();\n        }\n\n        if (method_exists($field, 'getWidth')) {\n            $config['width'] = $field->getWidth();\n        }\n        if (method_exists($field, 'getHeight')) {\n            $config['height'] = $field->getHeight();\n        }\n\n        $visible = false;\n        if ($gridType == 'search') {\n            $visible = $field->getVisibleSearch();\n        } elseif ($gridType == 'grid') {\n            $visible = $field->getVisibleGridView();\n        } elseif ($gridType == 'all') {\n            $visible = true;\n        }\n\n        if (!$field->getInvisible() && ($force || $visible)) {\n            $context = ['purpose' => 'gridconfig'];\n            if ($class) {\n                $context['class'] = $class;\n            }\n\n            if ($objectId) {\n                $object = DataObject::getById($objectId);\n                $context['object'] = $object;\n            }\n            DataObject\\Service::enrichLayoutDefinition($field, null, $context);\n\n            $result = [\n                'key' => $key,\n                'type' => $field->getFieldType(),\n                'label' => $title,\n                'config' => $config,\n                'layout' => $field,\n                'position' => $position,\n            ];\n\n            if ($field instanceof DataObject\\ClassDefinition\\Data\\EncryptedField) {\n                $result['delegateDatatype'] = $field->getDelegateDatatype();\n            }\n\n            return $result;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * IMPORTER\n     */\n\n    /**\n     * @Route(\"/import-upload\", name=\"importupload\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function importUploadAction(Request $request, Filesystem $filesystem): JsonResponse\n    {\n        $data = file_get_contents($_FILES['Filedata']['tmp_name']);\n        $data = Tool\\Text::convertToUTF8($data);\n\n        $importId = $request->get('importId');\n        $importId = str_replace('..', '', $importId);\n        $importFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/import_' . $importId;\n        $filesystem->dumpFile($importFile, $data);\n\n        $importFileOriginal = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/import_' . $importId . '_original';\n        $filesystem->dumpFile($importFileOriginal, $data);\n\n        $response = $this->adminJson([\n            'success' => true,\n        ]);\n\n        // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n        // Ext.form.Action.Submit and mark the submission as failed\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    protected function extractLanguage(Request $request): string\n    {\n        $requestedLanguage = $request->get('language');\n        if ($requestedLanguage) {\n            if ($requestedLanguage != 'default') {\n                $request->setLocale($requestedLanguage);\n            }\n        } else {\n            $requestedLanguage = $request->getLocale();\n        }\n\n        return $requestedLanguage;\n    }\n\n    protected function getCsvFile(string $fileHandle): string\n    {\n        return $fileHandle . '.csv';\n    }\n\n    /**\n     * @Route(\"/get-export-jobs\", name=\"getexportjobs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param GridHelperService $gridHelperService\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     */\n    public function getExportJobsAction(Request $request, GridHelperService $gridHelperService, EventDispatcherInterface $eventDispatcher): JsonResponse\n    {\n        $requestedLanguage = $this->extractLanguage($request);\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $list = $gridHelperService->prepareListingForGrid($allParams, $requestedLanguage, $this->getAdminUser());\n\n        $beforeListPrepareEvent = new GenericEvent($this, [\n            'list' => $list,\n            'context' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($beforeListPrepareEvent, AdminEvents::OBJECT_LIST_BEFORE_EXPORT_PREPARE);\n\n        $list = $beforeListPrepareEvent->getArgument('list');\n\n        $ids = $list->loadIdList();\n\n        $jobs = array_chunk($ids, 20);\n\n        $fileHandle = uniqid('export-');\n\n        $storage = Storage::get('temp');\n        $storage->write($this->getCsvFile($fileHandle), '');\n\n        return $this->adminJson(['success' => true, 'jobs' => $jobs, 'fileHandle' => $fileHandle]);\n    }\n\n    /**\n     * @Route(\"/do-export\", name=\"doexport\", methods={\"POST\"})\n     *\n     * @throws \\Exception|FilesystemException\n     */\n    public function doExportAction(\n        Request $request,\n        LocaleServiceInterface $localeService,\n        EventDispatcherInterface $eventDispatcher\n    ): JsonResponse\n    {\n        $fileHandle = File::getValidFilename($request->get('fileHandle'));\n        $ids = $request->get('ids');\n        $settings = json_decode($request->get('settings'), true);\n        $delimiter = $settings['delimiter'] ?? ';';\n        $header = $settings['header'] ?? 'title';\n\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $enableInheritance = $settings['enableInheritance'] ?? false;\n        DataObject\\Concrete::setGetInheritedValues($enableInheritance);\n\n        $class = DataObject\\ClassDefinition::getById($request->get('classId'));\n\n        if (!$class) {\n            throw new \\InvalidArgumentException('No class definition found');\n        }\n\n        $className = $class->getName();\n        $listClass = '\\\\Pimcore\\\\Model\\\\DataObject\\\\' . ucfirst($className) . '\\\\Listing';\n\n        /** @var Listing $list */\n        $list = new $listClass();\n\n        $quotedIds = [];\n        foreach ($ids as $id) {\n            $quotedIds[] = $list->quote($id);\n        }\n\n        $list->setObjectTypes(DataObject::$types);\n        $list->setCondition('id IN (' . implode(',', $quotedIds) . ')');\n        $list->setOrderKey(' FIELD(id, ' . implode(',', $quotedIds) . ')', false);\n\n        $beforeListExportEvent = new GenericEvent($this, [\n            'list' => $list,\n            'context' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($beforeListExportEvent, AdminEvents::OBJECT_LIST_BEFORE_EXPORT);\n\n        $list = $beforeListExportEvent->getArgument('list');\n\n        $fields = json_decode($request->get('fields')[0], true);\n\n        $addTitles = (bool) $request->get('initial');\n\n        $requestedLanguage = $this->extractLanguage($request);\n\n        $context = [\n            'source' => 'pimcore-export',\n        ];\n\n        $contextFromRequest = $request->get('context');\n        if ($contextFromRequest) {\n            $contextFromRequest = json_decode($contextFromRequest, true);\n            $context = array_merge($context, $contextFromRequest);\n        }\n\n        $csv = DataObject\\Service::getCsvData(\n            $requestedLanguage,\n            $localeService,\n            $list,\n            $fields,\n            $header,\n            $addTitles,\n            $context\n        );\n\n        try {\n            $storage = Storage::get('temp');\n            $csvFile = $this->getCsvFile($fileHandle);\n\n            $fileStream = $storage->readStream($csvFile);\n\n            $temp = tmpfile();\n            stream_copy_to_stream($fileStream, $temp, null, 0);\n\n            $firstLine = true;\n\n            if ($request->get('initial') && $header === 'no_header') {\n                array_shift($csv);\n                $firstLine = false;\n            }\n\n            $lineCount = count($csv);\n\n            if (!$addTitles && $lineCount > 0) {\n                fwrite($temp, \"\\r\\n\");\n            }\n\n            for ($i = 0; $i < $lineCount; $i++) {\n                $line = $csv[$i];\n                if ($addTitles && $firstLine) {\n                    $firstLine = false;\n                    $line = implode($delimiter, $line);\n                    fwrite($temp, $line);\n                } else {\n                    fwrite($temp, implode($delimiter, array_map([$this, 'encodeFunc'], $line)));\n                }\n                if ($i < $lineCount - 1) {\n                    fwrite($temp, \"\\r\\n\");\n                }\n            }\n            $storage->writeStream($csvFile, $temp);\n        } catch (UnableToReadFile $exception) {\n            Logger::err($exception->getMessage());\n\n            return $this->adminJson(\n                [\n                    'success' => false,\n                    'message' => sprintf('export file not found: %s', $fileHandle)\n                ]\n            );\n        }\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    public function encodeFunc(string $value): string\n    {\n        $value = str_replace('\"', '\"\"', $value);\n\n        //force wrap value in quotes and return\n        return '\"' . $value . '\"';\n    }\n\n    /**\n     * @Route(\"/download-csv-file\", name=\"downloadcsvfile\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function downloadCsvFileAction(Request $request): Response\n    {\n        $storage = Storage::get('temp');\n        $fileHandle = File::getValidFilename($request->get('fileHandle'));\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        try {\n            $csvData = $storage->read($csvFile);\n            $response = new Response($csvData);\n            $response->headers->set('Content-Type', 'application/csv');\n            $disposition = HeaderUtils::makeDisposition(\n                HeaderUtils::DISPOSITION_ATTACHMENT,\n                'export.csv'\n            );\n\n            $response->headers->set('Content-Disposition', $disposition);\n            $storage->delete($csvFile);\n\n            return $response;\n        } catch (FilesystemException | UnableToReadFile $exception) {\n            // handle the error\n            throw $this->createNotFoundException('CSV file not found');\n        }\n    }\n\n    /**\n     * @Route(\"/download-xlsx-file\", name=\"downloadxlsxfile\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param GridHelperService $gridHelperService\n     *\n     * @return BinaryFileResponse\n     */\n    public function downloadXlsxFileAction(Request $request, GridHelperService $gridHelperService): BinaryFileResponse\n    {\n        $storage = Storage::get('temp');\n        $fileHandle = File::getValidFilename($request->get('fileHandle'));\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        try {\n            return $gridHelperService->createXlsxExportFile($storage, $fileHandle, $csvFile);\n        } catch (\\Exception | FilesystemException | UnableToReadFile $exception) {\n            // handle the error\n            throw $this->createNotFoundException('XLSX file not found');\n        }\n    }\n\n    /**\n     * Flattens object data to an array with key=>value where\n     * value is simply a string representation of the value (for objects, hrefs and assets the full path is used)\n     *\n     * @param DataObject\\Concrete $object\n     *\n     * @return array\n     */\n    protected function csvObjectData(DataObject\\Concrete $object): array\n    {\n        $o = [];\n        foreach ($object->getClass()->getFieldDefinitions() as $key => $value) {\n            $o[$key] = $value->getForCsvExport($object);\n        }\n\n        $o['id (system)'] = $object->getId();\n        $o['key (system)'] = $object->getKey();\n        $o['fullpath (system)'] = $object->getRealFullPath();\n        $o['published (system)'] = $object->isPublished();\n        $o['type (system)'] = $object->getType();\n\n        return $o;\n    }\n\n    /**\n     * @Route(\"/get-batch-jobs\", name=\"getbatchjobs\", methods={\"POST\"})\n     *\n     *\n     */\n    public function getBatchJobsAction(Request $request, GridHelperService $gridHelperService): JsonResponse\n    {\n        if ($request->get('language')) {\n            $request->setLocale($request->get('language'));\n        }\n\n        $allParams = array_merge($request->request->all(), $request->query->all());\n        $list = $gridHelperService->prepareListingForGrid($allParams, $request->getLocale(), $this->getAdminUser());\n\n        $jobs = $list->loadIdList();\n\n        return $this->adminJson(['success' => true, 'jobs' => $jobs]);\n    }\n\n    /**\n     * @Route(\"/batch\", name=\"batch\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function batchAction(Request $request): JsonResponse\n    {\n        $success = true;\n\n        try {\n            if ($request->get('data')) {\n                $params = $this->decodeJson($request->get('data'), true);\n                $object = DataObject\\Concrete::getById($params['job']);\n\n                if ($object) {\n                    $name = $params['name'];\n\n                    if (!$object->isAllowed('save') || ($name === 'published' && !$object->isAllowed('publish'))) {\n                        throw new \\Exception(\"Permission denied. You don't have the rights to save this object.\");\n                    }\n\n                    $append = $params['append'] ?? false;\n                    $remove = $params['remove'] ?? false;\n\n                    $className = $object->getClassName();\n                    $class = DataObject\\ClassDefinition::getByName($className);\n                    $value = $params['value'];\n                    if ($params['valueType'] == 'object') {\n                        $value = $this->decodeJson($value);\n                    }\n\n                    $parts = explode('~', $name);\n\n                    if (substr($name, 0, 1) == '~') {\n                        $type = $parts[1];\n                        $field = $parts[2];\n                        $keyId = $parts[3];\n\n                        if ($type == 'classificationstore') {\n                            $requestedLanguage = $params['language'];\n                            if ($requestedLanguage) {\n                                if ($requestedLanguage != 'default') {\n                                    $request->setLocale($requestedLanguage);\n                                }\n                            } else {\n                                $requestedLanguage = $request->getLocale();\n                            }\n\n                            $groupKeyId = explode('-', $keyId);\n                            $groupId = (int) $groupKeyId[0];\n                            $keyId = (int) $groupKeyId[1];\n\n                            $getter = 'get' . ucfirst($field);\n                            if (method_exists($object, $getter)) {\n                                /** @var DataObject\\ClassDefinition\\Data\\Classificationstore $csFieldDefinition */\n                                $csFieldDefinition = $object->getClass()->getFieldDefinition($field);\n                                $csLanguage = $requestedLanguage;\n                                if (!$csFieldDefinition->isLocalized()) {\n                                    $csLanguage = 'default';\n                                }\n\n                                /** @var DataObject\\ClassDefinition\\Data\\Classificationstore $fd */\n                                $fd = $class->getFieldDefinition($field);\n                                $keyConfig = $fd->getKeyConfiguration($keyId);\n                                $dataDefinition = DataObject\\Classificationstore\\Service::getFieldDefinitionFromKeyConfig($keyConfig);\n\n                                /** @var DataObject\\Classificationstore $classificationStoreData */\n                                $classificationStoreData = $object->$getter();\n                                if ($append) {\n                                    $oldValue = $classificationStoreData->getLocalizedKeyValue($groupId, $keyId);\n                                    $value = $dataDefinition->appendData($oldValue, $value);\n                                }\n                                if ($remove) {\n                                    $oldValue = $classificationStoreData->getLocalizedKeyValue($groupId, $keyId);\n                                    $value = $dataDefinition->removeData($oldValue, $value);\n                                }\n                                $classificationStoreData->setLocalizedKeyValue(\n                                    $groupId,\n                                    $keyId,\n                                    $dataDefinition->getDataFromEditmode($value),\n                                    $csLanguage\n                                );\n                            }\n                        }\n                    } elseif (count($parts) > 1) {\n                        // check for bricks\n                        $brickType = $parts[0];\n\n                        if (strpos($brickType, '?') !== false) {\n                            $brickDescriptor = substr($brickType, 1);\n                            $brickDescriptor = json_decode($brickDescriptor, true);\n                            $brickType = $brickDescriptor['containerKey'];\n                        }\n                        $brickKey = $parts[1];\n                        $brickField = DataObject\\Service::getFieldForBrickType($object->getClass(), $brickType);\n\n                        $fieldGetter = 'get' . ucfirst($brickField);\n                        $brickGetter = 'get' . ucfirst($brickType);\n                        $valueSetter = 'set' . ucfirst($brickKey);\n\n                        $brick = $object->$fieldGetter()->$brickGetter();\n                        if (empty($brick)) {\n                            $classname = '\\\\Pimcore\\\\Model\\\\DataObject\\\\Objectbrick\\\\Data\\\\' . ucfirst($brickType);\n                            $brickSetter = 'set' . ucfirst($brickType);\n                            $brick = new $classname($object);\n                            $object->$fieldGetter()->$brickSetter($brick);\n                        }\n\n                        $brickClass = DataObject\\Objectbrick\\Definition::getByKey($brickType);\n                        $field = $brickClass->getFieldDefinition($brickKey);\n\n                        $newData = $field->getDataFromEditmode($value, $object);\n\n                        if ($append) {\n                            $valueGetter = 'get' . ucfirst($brickKey);\n                            $existingData = $brick->$valueGetter();\n                            $newData = $field->appendData($existingData, $newData);\n                        }\n                        if ($remove) {\n                            $valueGetter = 'get' . ucfirst($brickKey);\n                            $existingData = $brick->$valueGetter();\n                            $newData = $field->removeData($existingData, $newData);\n                        }\n\n                        $localizedFields = $brickClass->getFieldDefinition('localizedfields');\n                        $isLocalizedField = false;\n                        if ($localizedFields instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                            if ($localizedFields->getFieldDefinition($brickKey)) {\n                                $isLocalizedField = true;\n                            }\n                        }\n\n                        if ($isLocalizedField) {\n                            $brick->$valueSetter($newData, $params['language']);\n                        } else {\n                            $brick->$valueSetter($newData);\n                        }\n                    } else {\n                        // everything else\n                        $field = $class->getFieldDefinition($name);\n                        if ($field) {\n                            $newData = $field->getDataFromEditmode($value, $object);\n\n                            if ($append) {\n                                $existingData = $object->{'get' . $name}();\n                                $newData = $field->appendData($existingData, $newData);\n                            }\n                            if ($remove) {\n                                $existingData = $object->{'get' . $name}();\n                                $newData = $field->removeData($existingData, $newData);\n                            }\n                            $object->setValue($name, $newData);\n                        } else {\n                            // check if it is a localized field\n                            if ($params['language']) {\n                                $localizedField = $class->getFieldDefinition('localizedfields');\n                                if ($localizedField instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                                    $field = $localizedField->getFieldDefinition($name);\n                                    if ($field) {\n                                        $getter = 'get' . $name;\n                                        $setter = 'set' . $name;\n                                        $newData = $field->getDataFromEditmode($value, $object);\n                                        if ($append) {\n                                            $existingData = $object->$getter($params['language']);\n                                            $newData = $field->appendData($existingData, $newData);\n                                        }\n                                        if ($remove) {\n                                            $existingData = $object->$getter($request->get('language'));\n                                            $newData = $field->removeData($existingData, $newData);\n                                        }\n\n                                        $object->$setter($newData, $params['language']);\n                                    }\n                                }\n                            }\n\n                            // seems to be a system field, this is actually only possible for the \"published\" field yet\n                            if ($name == 'published') {\n                                if ($value === 'false' || empty($value)) {\n                                    $object->setPublished(false);\n                                } else {\n                                    $object->setPublished(true);\n                                }\n                            }\n                        }\n                    }\n\n                    try {\n                        // don't check for mandatory fields here\n                        $object->setOmitMandatoryCheck(!$object->isPublished());\n                        $object->setUserModification($this->getAdminUser()->getId());\n                        $object->save();\n                        $success = true;\n                    } catch (\\Exception $e) {\n                        return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n                    }\n                } else {\n                    Logger::debug('DataObjectController::batchAction => There is no object left to update.');\n\n                    return $this->adminJson(['success' => false, 'message' => 'DataObjectController::batchAction => There is no object left to update.']);\n                }\n            }\n        } catch (\\Exception $e) {\n            Logger::err((string) $e);\n\n            return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n        }\n\n        return $this->adminJson(['success' => $success]);\n    }\n\n    /**\n     * @Route(\"/get-available-visible-vields\", name=\"getavailablevisiblefields\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getAvailableVisibleFieldsAction(Request $request): JsonResponse\n    {\n        $class = null;\n        $fields = null;\n\n        $classList = [];\n        $classNameList = [];\n\n        if ($request->get('classes')) {\n            $classNameList = $request->get('classes');\n            $classNameList = explode(',', $classNameList);\n            foreach ($classNameList as $className) {\n                $class = DataObject\\ClassDefinition::getByName($className);\n                if ($class) {\n                    $classList[] = $class;\n                }\n            }\n        }\n\n        if (!$classList) {\n            return $this->adminJson(['availableFields' => []]);\n        }\n        $availableFields = [];\n        foreach (self::SYSTEM_COLUMNS as $field) {\n            $availableFields[] = [\n                'key' => $field,\n                'value' => $field,\n            ];\n        }\n\n        /** @var DataObject\\ClassDefinition\\Data[] $commonFields */\n        $commonFields = [];\n\n        $firstOne = true;\n        foreach ($classNameList as $className) {\n            $class = DataObject\\ClassDefinition::getByName($className);\n            if ($class) {\n                $fds = $class->getFieldDefinitions();\n\n                $additionalFieldNames = array_keys($fds);\n                $localizedFields = $class->getFieldDefinition('localizedfields');\n                if ($localizedFields instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    $lfNames = array_keys($localizedFields->getFieldDefinitions());\n                    $additionalFieldNames = array_merge($additionalFieldNames, $lfNames);\n                }\n\n                foreach ($commonFields as $commonFieldKey => $commonFieldDefinition) {\n                    if (!in_array($commonFieldKey, $additionalFieldNames)) {\n                        unset($commonFields[$commonFieldKey]);\n                    }\n                }\n\n                $this->processAvailableFieldDefinitions($fds, $firstOne, $commonFields);\n\n                $firstOne = false;\n            }\n        }\n\n        $commonFieldKeys = array_keys($commonFields);\n        foreach ($commonFieldKeys as $field) {\n            $availableFields[] = [\n                'key' => $field,\n                'value' => $field,\n            ];\n        }\n\n        return $this->adminJson(['availableFields' => $availableFields]);\n    }\n\n    /**\n     * @param DataObject\\ClassDefinition\\Data[] $fds\n     * @param bool $firstOne\n     * @param DataObject\\ClassDefinition\\Data[] $commonFields\n     */\n    protected function processAvailableFieldDefinitions(array $fds, bool &$firstOne, array &$commonFields): void\n    {\n        foreach ($fds as $fd) {\n            if ($fd instanceof DataObject\\ClassDefinition\\Data\\Fieldcollections || $fd instanceof DataObject\\ClassDefinition\\Data\\Objectbricks\n                || $fd instanceof DataObject\\ClassDefinition\\Data\\Block) {\n                continue;\n            }\n\n            if ($fd instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                $lfDefs = $fd->getFieldDefinitions();\n                $this->processAvailableFieldDefinitions($lfDefs, $firstOne, $commonFields);\n            } elseif ($firstOne || (isset($commonFields[$fd->getName()]) && $commonFields[$fd->getName()]->getFieldtype() == $fd->getFieldtype())) {\n                $commonFields[$fd->getName()] = $fd;\n            }\n        }\n    }\n}\n"], "filenames": ["src/Controller/Admin/Asset/AssetHelperController.php", "src/Controller/Admin/DataObject/DataObjectHelperController.php"], "buggy_code_start_loc": [28, 28], "buggy_code_end_loc": [897, 1449], "fixing_code_start_loc": [29, 29], "fixing_code_end_loc": [903, 1464], "type": "CWE-209", "message": "The Pimcore Admin Classic Bundle provides a Backend UI for Pimcore. Full Path Disclosure (FPD) vulnerabilities enable the attacker to see the path to the webroot/file. e.g.: /home/omg/htdocs/file/. Certain vulnerabilities, such as using the load_file() (within a SQL Injection) query to view the page source, require the attacker to have the full path to the file they wish to view. In the case of pimcore, the fopen() function here doesn't have an error handle when the file doesn't exist on the server so the server response raises the full path \"fopen(/var/www/html/var/tmp/export-{ uniqe id}.csv)\". This issue has been patched in commit `10d178ef771` which has been included in release version 1.2.1. Users are advised to upgrade. There are no known workarounds for this vulnerability.\n", "other": {"cve": {"id": "CVE-2023-47636", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-15T20:15:07.803", "lastModified": "2023-11-22T22:37:57.443", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Pimcore Admin Classic Bundle provides a Backend UI for Pimcore. Full Path Disclosure (FPD) vulnerabilities enable the attacker to see the path to the webroot/file. e.g.: /home/omg/htdocs/file/. Certain vulnerabilities, such as using the load_file() (within a SQL Injection) query to view the page source, require the attacker to have the full path to the file they wish to view. In the case of pimcore, the fopen() function here doesn't have an error handle when the file doesn't exist on the server so the server response raises the full path \"fopen(/var/www/html/var/tmp/export-{ uniqe id}.csv)\". This issue has been patched in commit `10d178ef771` which has been included in release version 1.2.1. Users are advised to upgrade. There are no known workarounds for this vulnerability.\n"}, {"lang": "es", "value": "El paquete Pimcore Admin Classic proporciona una interfaz de usuario de backend para Pimcore. Las vulnerabilidades de Full Path Disclosure (FPD) permiten al atacante ver la ruta al archivo/ra\u00edz web. Por ejemplo: /home/omg/htdocs/file/. Ciertas vulnerabilidades, como el uso de la consulta load_file() (dentro de una inyecci\u00f3n SQL) para ver el origen de la p\u00e1gina, requieren que el atacante tenga la ruta completa al archivo que desea ver. En el caso de pimcore, la funci\u00f3n fopen() aqu\u00ed no tiene un controlador de error cuando el archivo no existe en el servidor, por lo que la respuesta del servidor genera la ruta completa \"fopen(/var/www/html/var/tmp/export-{uniqe id}.csv)\". Este problema se solucion\u00f3 en el commit `10d178ef771` que se incluy\u00f3 en la versi\u00f3n 1.2.1. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-209"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pimcore:admin_classic_bundle:*:*:*:*:*:pimcore:*:*", "versionEndExcluding": "1.2.1", "matchCriteriaId": "F97407FD-0069-4A96-8B4B-62B7CD344E93"}]}]}], "references": [{"url": "https://github.com/pimcore/admin-ui-classic-bundle/commit/10d178ef771097604a256c1192b098af9ec57a87", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/pimcore/admin-ui-classic-bundle/security/advisories/GHSA-c8hj-w239-5gvf", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://huntr.com/bounties/4af4db18-9fd4-43e9-8bc6-c88aaf76839c/", "source": "security-advisories@github.com", "tags": ["Exploit"]}]}, "github_commit_url": "https://github.com/pimcore/admin-ui-classic-bundle/commit/10d178ef771097604a256c1192b098af9ec57a87"}}