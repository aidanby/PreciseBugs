{"buggy_code": ["/*\n *  Phusion Passenger - https://www.phusionpassenger.com/\n *  Copyright (c) 2011-2017 Phusion Holding B.V.\n *\n *  \"Passenger\", \"Phusion Passenger\" and \"Union Station\" are registered\n *  trademarks of Phusion Holding B.V.\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n#ifndef _PASSENGER_SPAWNING_KIT_SPAWNER_H_\n#define _PASSENGER_SPAWNING_KIT_SPAWNER_H_\n\n/*\n * This file implements application spawning support. Several classes\n * are provided which all implement the Spawner interface. The spawn()\n * method spawns an application process based on the given options\n * and returns a Process object which contains information about the\n * spawned process.\n *\n * The DirectSpawner class spawns application processes directly.\n *\n * The SmartSpawner class spawns application processes through a\n * preloader process. The preloader process loads the application\n * code into its address space and then listens on a socket for spawn\n * commands. Upon receiving a spawn command, it will fork() itself.\n * This makes spawning multiple application processes much faster.\n * Note that a single SmartSpawner instance is only usable for a\n * single application.\n *\n * DummySpawner doesn't do anything. It returns dummy Process objects.\n *\n * DirectSpawner, SmartSpawner and DummySpawner all implement the Spawner interface.\n *\n * SpawnerFactory is a convenience class which takes an Options objects\n * and figures out, based on options.spawnMethod, whether to create\n * a DirectSpawner or a SmartSpawner. In case of the smart spawning\n * method, SpawnerFactory also automatically figures out which preloader\n * to use based on options.appType.\n */\n\n#include <string>\n#include <map>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <boost/make_shared.hpp>\n#include <boost/shared_array.hpp>\n#include <boost/bind.hpp>\n#include <boost/foreach.hpp>\n#include <boost/move/move.hpp>\n#include <oxt/system_calls.hpp>\n#include <oxt/backtrace.hpp>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cerrno>\n#include <cassert>\n#include <unistd.h>\n#include <pwd.h>\n#include <grp.h>\n#include <dirent.h>\n#include <adhoc_lve.h>\n#include <modp_b64.h>\n#include <FileDescriptor.h>\n#include <Exceptions.h>\n#include <StaticString.h>\n#include <Utils.h>\n#include <Utils/BufferedIO.h>\n#include <Utils/ScopeGuard.h>\n#include <Utils/Timer.h>\n#include <Utils/IOUtils.h>\n#include <Utils/StrIntUtils.h>\n#include <Utils/ProcessMetricsCollector.h>\n#include <Core/SpawningKit/Config.h>\n#include <Core/SpawningKit/Options.h>\n#include <Core/SpawningKit/Result.h>\n#include <Core/SpawningKit/BackgroundIOCapturer.h>\n#include <Core/SpawningKit/UserSwitchingRules.h>\n\nnamespace tut {\n\tstruct ApplicationPool2_DirectSpawnerTest;\n\tstruct ApplicationPool2_SmartSpawnerTest;\n}\n\nnamespace Passenger {\nnamespace SpawningKit {\n\nusing namespace std;\nusing namespace boost;\nusing namespace oxt;\n\n\nclass Spawner {\nprotected:\n\tfriend struct tut::ApplicationPool2_DirectSpawnerTest;\n\tfriend struct tut::ApplicationPool2_SmartSpawnerTest;\n\n\t/**\n\t * A temporary directory for spawned child processes to write\n\t * debugging information to. It is removed after spawning has\n\t * determined to be successful or failed.\n\t */\n\tclass DebugDir {\n\tprivate:\n\t\tstring path;\n\n\t\tstatic void doClosedir(DIR *dir) {\n\t\t\tclosedir(dir);\n\t\t}\n\n\tpublic:\n\t\tDebugDir(uid_t uid, gid_t gid) {\n\t\t\tchar buf[PATH_MAX] = \"/tmp/passenger.spawn-debug.XXXXXXXXXX\";\n\t\t\tconst char *result = mkdtemp(buf);\n\t\t\tif (result == NULL) {\n\t\t\t\tint e = errno;\n\t\t\t\tthrow SystemException(\"Cannot create a temporary directory \"\n\t\t\t\t\t\"in the format of '/tmp/passenger-spawn-debug.XXX'\", e);\n\t\t\t} else {\n\t\t\t\tpath = result;\n\t\t\t\tboost::this_thread::disable_interruption di;\n\t\t\t\tboost::this_thread::disable_syscall_interruption dsi;\n\t\t\t\tsyscalls::chown(result, uid, gid);\n\t\t\t}\n\t\t}\n\n\t\t~DebugDir() {\n\t\t\tremoveDirTree(path);\n\t\t}\n\n\t\tconst string &getPath() const {\n\t\t\treturn path;\n\t\t}\n\n\t\tmap<string, string> readAll() {\n\t\t\tmap<string, string> result;\n\t\t\tDIR *dir = opendir(path.c_str());\n\t\t\tScopeGuard guard(boost::bind(doClosedir, dir));\n\t\t\tstruct dirent *ent;\n\n\t\t\twhile ((ent = readdir(dir)) != NULL) {\n\t\t\t\tif (ent->d_name[0] != '.') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresult.insert(make_pair<string, string>(\n\t\t\t\t\t\t\tent->d_name,\n\t\t\t\t\t\t\tPassenger::readAll(path + \"/\" + ent->d_name)));\n\t\t\t\t\t} catch (const SystemException &) {\n\t\t\t\t\t\t// Do nothing.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t};\n\n\ttypedef boost::shared_ptr<DebugDir> DebugDirPtr;\n\n\t/**\n\t * Contains information that will be used after fork()ing but before exec()ing,\n\t * such as the intended app root, the UID it should switch to, the\n\t * groups it should assume, etc. This structure is allocated before forking\n\t * because after forking and before exec() it may not be safe to allocate memory.\n\t */\n\tstruct SpawnPreparationInfo {\n\t\t// General\n\n\t\t/** Absolute application root path. */\n\t\tstring appRoot;\n\t\t/** Absolute pre-exec chroot path. If no chroot is configured, then this is \"/\". */\n\t\tstring chrootDir;\n\t\t/** Absolute application root path inside the chroot. If no chroot is\n\t\t * configured then this is is equal to appRoot. */\n\t\tstring appRootInsideChroot;\n\t\t/** A list of all parent directories of the appRoot, as well as appRoot itself.\n\t\t * The pre-exec chroot directory is included, and this list goes no futher than that.\n\t\t * For example if appRoot is /var/jail/foo/bar/baz and the chroot is /var/jail,\n\t\t * then this list contains:\n\t\t *   /var/jail/foo\n\t\t *   /var/jail/foo/bar\n\t\t *   /var/jail/foo/bar/baz\n\t\t */\n\t\tvector<string> appRootPaths;\n\t\t/** Same as appRootPaths, but without the chroot component. For example if\n\t\t * appRoot is /var/jail/foo/bar/baz and the chroot is /var/jail, then this list\n\t\t * contains:\n\t\t *   /foo\n\t\t *   /foo/bar\n\t\t *   /foo/bar/baz\n\t\t */\n\t\tvector<string> appRootPathsInsideChroot;\n\n\t\tUserSwitchingInfo userSwitching;\n\n\t\t// Other information\n\t\tstring codeRevision;\n\t};\n\n\t/**\n\t * Structure containing arguments and working state for negotiating\n\t * the spawning protocol.\n\t */\n\tstruct NegotiationDetails {\n\t\t/****** Arguments ******/\n\n\t\t/** The preparation info of the process we're negotiating with. It's used\n\t\t * by security validators to check whether the information sent back by the\n\t\t * process make any sense. */\n\t\tSpawnPreparationInfo *preparation;\n\t\t/** This object captures the process's stderr while negotiation is in progress.\n\t\t * (Recall that negotiation is performed over the process's stdout while stderr\n\t\t * is used purely for outputting messages.)\n\t\t * If the negotiation protocol fails, then any output captured by this object\n\t\t * will be stored into the resulting SpawnException's error page. */\n\t\tBackgroundIOCapturerPtr stderrCapturer;\n\t\t/** The PID of the process we're negotiating with. */\n\t\tpid_t pid;\n\t\tFileDescriptor adminSocket;\n\t\tFileDescriptor errorPipe;\n\t\tconst Options *options;\n\t\tDebugDirPtr debugDir;\n\n\t\t/****** Working state ******/\n\t\tBufferedIO io;\n\t\tstring gupid;\n\t\tunsigned long long spawnStartTime;\n\t\tunsigned long long timeout;\n\n\t\tNegotiationDetails() {\n\t\t\tpreparation = NULL;\n\t\t\tpid = 0;\n\t\t\toptions = NULL;\n\t\t\tspawnStartTime = 0;\n\t\t\ttimeout = 0;\n\t\t}\n\t};\n\nprivate:\n\t/**\n\t * Appends key + \"\\0\" + value + \"\\0\" to 'output'.\n\t */\n\tstatic void appendNullTerminatedKeyValue(string &output, const StaticString &key,\n\t\tconst StaticString &value)\n\t{\n\t\toutput.append(key.data(), key.size());\n\t\toutput.append(1, '\\0');\n\t\toutput.append(value.data(), value.size());\n\t\toutput.append(1, '\\0');\n\t}\n\n\tvoid sendSpawnRequest(NegotiationDetails &details) {\n\t\tTRACE_POINT();\n\t\ttry {\n\t\t\tconst size_t UNIX_PATH_MAX = sizeof(((struct sockaddr_un *) 0)->sun_path);\n\t\t\tstring data = \"You have control 1.0\\n\"\n\t\t\t\t\"passenger_root: \" + config->resourceLocator->getInstallSpec() + \"\\n\"\n\t\t\t\t\"passenger_version: \" PASSENGER_VERSION \"\\n\"\n\t\t\t\t\"ruby_libdir: \" + config->resourceLocator->getRubyLibDir() + \"\\n\"\n\t\t\t\t\"gupid: \" + details.gupid + \"\\n\"\n\t\t\t\t\"UNIX_PATH_MAX: \" + toString(UNIX_PATH_MAX) + \"\\n\";\n\t\t\tif (!details.options->apiKey.empty()) {\n\t\t\t\tdata.append(\"connect_password: \" + details.options->apiKey + \"\\n\");\n\t\t\t}\n\t\t\tif (!config->instanceDir.empty()) {\n\t\t\t\tdata.append(\"instance_dir: \" + config->instanceDir + \"\\n\");\n\t\t\t\tdata.append(\"socket_dir: \" + config->instanceDir + \"/apps.s\\n\");\n\t\t\t}\n\n\t\t\tvector<string> args;\n\t\t\tvector<string>::const_iterator it, end;\n\t\t\tdetails.options->toVector(args, *config->resourceLocator, Options::SPAWN_OPTIONS);\n\t\t\tfor (it = args.begin(); it != args.end(); it++) {\n\t\t\t\tconst string &key = *it;\n\t\t\t\tit++;\n\t\t\t\tconst string &value = *it;\n\t\t\t\tdata.append(key + \": \" + value + \"\\n\");\n\t\t\t}\n\n\t\t\tvector<StaticString> lines;\n\t\t\tsplit(data, '\\n', lines);\n\t\t\tforeach (const StaticString line, lines) {\n\t\t\t\tP_DEBUG(\"[App \" << details.pid << \" stdin >>] \" << line);\n\t\t\t}\n\t\t\twriteExact(details.adminSocket, data, &details.timeout);\n\t\t\twriteExact(details.adminSocket, \"\\n\", &details.timeout);\n\t\t} catch (const SystemException &e) {\n\t\t\tif (e.code() == EPIPE) {\n\t\t\t\t/* Ignore this. Process might have written an\n\t\t\t\t * error response before reading the arguments,\n\t\t\t\t * in which case we'll want to show that instead.\n\t\t\t\t */\n\t\t\t} else {\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\t}\n\n\tResult handleSpawnResponse(NegotiationDetails &details) {\n\t\tTRACE_POINT();\n\t\tJson::Value sockets;\n\t\tResult result;\n\n\t\twhile (true) {\n\t\t\tstring line;\n\n\t\t\ttry {\n\t\t\t\tline = readMessageLine(details);\n\t\t\t} catch (const SystemException &e) {\n\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\"web application. There was an I/O error while reading its \"\n\t\t\t\t\t\"startup response: \" + e.sys(),\n\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\tdetails);\n\t\t\t} catch (const TimeoutException &) {\n\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\"web application: it did not write a startup response in time. \"\n\t\t\t\t\t\"If your app needs more time to start you can increase the \"\n\t\t\t\t\t\"Passenger start timeout config option.\",\n\t\t\t\t\tSpawnException::APP_STARTUP_TIMEOUT,\n\t\t\t\t\tdetails);\n\t\t\t}\n\n\t\t\tif (line.empty()) {\n\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\"web application. It unexpectedly closed the connection while \"\n\t\t\t\t\t\"sending its startup response.\",\n\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\tdetails);\n\t\t\t} else if (line[line.size() - 1] != '\\n') {\n\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\"web application. It sent a line without a newline character \"\n\t\t\t\t\t\"in its startup response.\",\n\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\tdetails);\n\t\t\t} else if (line == \"\\n\") {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstring::size_type pos = line.find(\": \");\n\t\t\tif (pos == string::npos) {\n\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\"web application. It sent a startup response line without \"\n\t\t\t\t\t\"separator.\",\n\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\tdetails);\n\t\t\t}\n\n\t\t\tstring key = line.substr(0, pos);\n\t\t\tstring value = line.substr(pos + 2, line.size() - pos - 3);\n\t\t\tif (key == \"socket\") {\n\t\t\t\t// socket: <name>;<address>;<protocol>;<concurrency>\n\t\t\t\t// TODO: in case of TCP sockets, check whether it points to localhost\n\t\t\t\t// TODO: in case of unix sockets, check whether filename is absolute\n\t\t\t\t// and whether owner is correct\n\t\t\t\tvector<string> args;\n\t\t\t\tsplit(value, ';', args);\n\t\t\t\tif (args.size() == 4) {\n\t\t\t\t\tstring error = validateSocketAddress(details, args[1]);\n\t\t\t\t\tif (!error.empty()) {\n\t\t\t\t\t\tthrowAppSpawnException(\n\t\t\t\t\t\t\t\"An error occurred while starting the web application. \" + error,\n\t\t\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\t\t\tdetails);\n\t\t\t\t\t}\n\n\t\t\t\t\tJson::Value socket;\n\t\t\t\t\tsocket[\"name\"] = args[0];\n\t\t\t\t\tsocket[\"address\"] = fixupSocketAddress(*details.options, args[1]);\n\t\t\t\t\tsocket[\"protocol\"] = args[2];\n\t\t\t\t\tsocket[\"concurrency\"] = atoi(args[3]);\n\t\t\t\t\tsockets.append(socket);\n\t\t\t\t} else {\n\t\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\t\"web application. It reported a wrongly formatted 'socket'\"\n\t\t\t\t\t\t\"response value: '\" + value + \"'\",\n\t\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\t\tdetails);\n\t\t\t\t}\n\t\t\t} else if (key == \"pid\") {\n\t\t\t\t// pid: <PID>\n\t\t\t\tpid_t pid = atoi(value);\n\t\t\t\tProcessMetricsCollector collector;\n\t\t\t\tvector<pid_t> pids;\n\n\t\t\t\tpids.push_back(pid);\n\t\t\t\tProcessMetricMap metrics = collector.collect(pids);\n\t\t\t\tif (metrics[pid].uid != details.preparation->userSwitching.uid) {\n\t\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\t\"web application. The PID that the loader has returned does \"\n\t\t\t\t\t\t\"not have the same UID as the loader itself.\",\n\t\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\t\tdetails);\n\t\t\t\t}\n\t\t\t\tdetails.pid = pid;\n\t\t\t} else {\n\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\"web application. It sent an unknown startup response line \"\n\t\t\t\t\t\"called '\" + key + \"'.\",\n\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\tdetails);\n\t\t\t}\n\t\t}\n\n\t\tif (!hasSessionSockets(sockets)) {\n\t\t\tthrowAppSpawnException(\"An error occured while starting the web \"\n\t\t\t\t\"application. It did not advertise any session sockets.\",\n\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\tdetails);\n\t\t}\n\n\t\tresult[\"type\"] = \"os_process\";\n\t\tresult[\"pid\"] = (int) details.pid;\n\t\tresult[\"gupid\"] = details.gupid;\n\t\tresult[\"sockets\"] = sockets;\n\t\tresult[\"code_revision\"] = details.preparation->codeRevision;\n\t\tresult[\"spawner_creation_time\"] = (Json::UInt64) creationTime;\n\t\tresult[\"spawn_start_time\"] = (Json::UInt64) details.spawnStartTime;\n\t\tresult.adminSocket = details.adminSocket;\n\t\tresult.errorPipe = details.errorPipe;\n\t\treturn result;\n\t}\n\n\tbool hasSessionSockets(const Json::Value &sockets) const {\n\t\tJson::Value::const_iterator it, end = sockets.end();\n\n\t\tfor (it = sockets.begin(); it != end; it++) {\n\t\t\tconst Json::Value &socket = *it;\n\t\t\tif (socket[\"protocol\"] == \"session\" || socket[\"protocol\"] == \"http_session\") {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\nprotected:\n\tConfigPtr config;\n\n\tstatic void nonInterruptableKillAndWaitpid(pid_t pid) {\n\t\tboost::this_thread::disable_syscall_interruption dsi;\n\t\tsyscalls::kill(pid, SIGKILL);\n\t\tsyscalls::waitpid(pid, NULL, 0);\n\t}\n\n\t/**\n\t * Behaves like <tt>waitpid(pid, status, WNOHANG)</tt>, but waits at most\n\t * <em>timeout</em> miliseconds for the process to exit.\n\t */\n\tstatic int timedWaitpid(pid_t pid, int *status, unsigned long long timeout) {\n\t\tTimer<SystemTime::GRAN_10MSEC> timer;\n\t\tint ret;\n\n\t\tdo {\n\t\t\tret = syscalls::waitpid(pid, status, WNOHANG);\n\t\t\tif (ret > 0 || ret == -1) {\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\tsyscalls::usleep(10000);\n\t\t\t}\n\t\t} while (timer.elapsed() < timeout);\n\t\treturn 0; // timed out\n\t}\n\n\tstatic string fixupSocketAddress(const Options &options, const string &address) {\n\t\tTRACE_POINT();\n\t\tif (!options.preexecChroot.empty() && !options.postexecChroot.empty()) {\n\t\t\tServerAddressType type = getSocketAddressType(address);\n\t\t\tif (type == SAT_UNIX) {\n\t\t\t\tstring filename = parseUnixSocketAddress(address);\n\t\t\t\tstring fixedAddress = \"unix:\";\n\t\t\t\tif (!options.preexecChroot.empty()) {\n\t\t\t\t\tfixedAddress.append(options.preexecChroot.data(),\n\t\t\t\t\t\toptions.preexecChroot.size());\n\t\t\t\t}\n\t\t\t\tif (!options.postexecChroot.empty()) {\n\t\t\t\t\tfixedAddress.append(options.postexecChroot.data(),\n\t\t\t\t\t\toptions.postexecChroot.size());\n\t\t\t\t}\n\t\t\t\tfixedAddress.append(filename);\n\t\t\t\treturn fixedAddress;\n\t\t\t} else {\n\t\t\t\treturn address;\n\t\t\t}\n\t\t} else {\n\t\t\treturn address;\n\t\t}\n\t}\n\n\tbool isAbsolutePath(const StaticString &path) const {\n\t\tif (path.empty() || path[0] != '/') {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tvector<string> components;\n\t\t\tstring component;\n\n\t\t\tsplit(path, '/', components);\n\t\t\tcomponents.erase(components.begin());\n\t\t\tforeach (component, components) {\n\t\t\t\tif (component.empty() || component == \".\" || component == \"..\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Given a 'socket:' information string obtained from the spawned process,\n\t * validates whether it is correct.\n\t */\n\tstring validateSocketAddress(NegotiationDetails &details, const string &_address) const {\n\t\tstring address = _address;\n\t\tstringstream error;\n\n\t\tswitch (getSocketAddressType(address)) {\n\t\tcase SAT_UNIX: {\n\t\t\taddress = fixupSocketAddress(*details.options, address);\n\t\t\tstring filename = parseUnixSocketAddress(address);\n\n\t\t\t// Verify that the socket filename is absolute.\n\t\t\tif (!isAbsolutePath(filename)) {\n\t\t\t\terror << \"It reported a non-absolute socket filename: \\\"\" <<\n\t\t\t\t\tcEscapeString(filename) << \"\\\"\";\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Verify that the process owns the socket.\n\t\t\tstruct stat buf;\n\t\t\tif (lstat(filename.c_str(), &buf) == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\terror << \"It reported an inaccessible socket filename: \\\"\" <<\n\t\t\t\t\tcEscapeString(filename) << \"\\\" (lstat() failed with errno \" <<\n\t\t\t\t\te << \": \" << strerror(e) << \")\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (buf.st_uid != details.preparation->userSwitching.uid) {\n\t\t\t\terror << \"It advertised a Unix domain socket that has a different \" <<\n\t\t\t\t\t\"owner than expected (should be UID \" << details.preparation->userSwitching.uid <<\n\t\t\t\t\t\", but actual UID was \" << buf.st_uid << \")\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase SAT_TCP:\n\t\t\t// TODO: validate that the socket is localhost.\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror << \"It reported an unsupported socket address type: \\\"\" <<\n\t\t\t\tcEscapeString(address) << \"\\\"\";\n\t\t\tbreak;\n\t\t}\n\n\t\treturn error.str();\n\t}\n\n\tstatic void checkChrootDirectories(const Options &options) {\n\t\tif (!options.preexecChroot.empty()) {\n\t\t\t// TODO: check whether appRoot is a child directory of preexecChroot\n\t\t\t// and whether postexecChroot is a child directory of appRoot.\n\t\t}\n\t}\n\n\tstatic void createCommandArgs(const vector<string> &command,\n\t\tshared_array<const char *> &args)\n\t{\n\t\targs.reset(new const char *[command.size()]);\n\t\tfor (unsigned int i = 1; i < command.size(); i++) {\n\t\t\targs[i - 1] = command[i].c_str();\n\t\t}\n\t\targs[command.size() - 1] = NULL;\n\t}\n\n\tvoid possiblyRaiseInternalError(const Options &options) {\n\t\tif (options.raiseInternalError) {\n\t\t\tthrow RuntimeException(\"An internal error!\");\n\t\t}\n\t}\n\n\tvoid throwAppSpawnException(const string &msg,\n\t\tSpawnException::ErrorKind errorKind,\n\t\tNegotiationDetails &details)\n\t{\n\t\tTRACE_POINT();\n\t\t// Stop the stderr capturing thread and get the captured stderr\n\t\t// output so far.\n\t\tstring stderrOutput;\n\t\tif (details.stderrCapturer != NULL) {\n\t\t\tstderrOutput = details.stderrCapturer->stop();\n\t\t}\n\n\t\t// If the exception wasn't due to a timeout, try to capture the\n\t\t// remaining stderr output for at most 2 seconds.\n\t\tif (errorKind != SpawnException::PRELOADER_STARTUP_TIMEOUT\n\t\t && errorKind != SpawnException::APP_STARTUP_TIMEOUT\n\t\t && details.stderrCapturer != NULL)\n\t\t{\n\t\t\tbool done = false;\n\t\t\tunsigned long long timeout = 2000;\n\t\t\twhile (!done) {\n\t\t\t\tchar buf[1024 * 32];\n\t\t\t\tunsigned int ret;\n\n\t\t\t\ttry {\n\t\t\t\t\tret = readExact(details.stderrCapturer->getFd(), buf,\n\t\t\t\t\t\tsizeof(buf), &timeout);\n\t\t\t\t\tif (ret == 0) {\n\t\t\t\t\t\tdone = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstderrOutput.append(buf, ret);\n\t\t\t\t\t}\n\t\t\t\t} catch (const SystemException &e) {\n\t\t\t\t\tP_WARN(\"Stderr I/O capture error: \" << e.what());\n\t\t\t\t\tdone = true;\n\t\t\t\t} catch (const TimeoutException &) {\n\t\t\t\t\tdone = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdetails.stderrCapturer.reset();\n\n\t\t// Now throw SpawnException with the captured stderr output\n\t\t// as error response.\n\t\tSpawnException e(msg,\n\t\t\tcreateErrorPageFromStderrOutput(msg, errorKind, stderrOutput),\n\t\t\ttrue,\n\t\t\terrorKind);\n\t\tannotateAppSpawnException(e, details);\n\t\tthrowSpawnException(e, *details.options);\n\t}\n\n\tvoid throwSpawnException(SpawnException &e, const Options &options) {\n\t\tif (config->errorHandler != NULL) {\n\t\t\tconfig->errorHandler(config, e, options);\n\t\t}\n\t\tthrow e;\n\t}\n\n\tvirtual void annotateAppSpawnException(SpawnException &e, NegotiationDetails &details) {\n\t\tif (details.debugDir != NULL) {\n\t\t\te.addAnnotations(details.debugDir->readAll());\n\t\t}\n\t}\n\n\tstring createErrorPageFromStderrOutput(const string &msg,\n\t\tSpawnException::ErrorKind errorKind,\n\t\tconst string &stderrOutput)\n\t{\n\t\t// These kinds of SpawnExceptions are not supposed to be handled through this function.\n\t\tassert(errorKind != SpawnException::PRELOADER_STARTUP_EXPLAINABLE_ERROR);\n\t\tassert(errorKind != SpawnException::APP_STARTUP_EXPLAINABLE_ERROR);\n\n\t\tstring result = escapeHTML(msg);\n\n\t\tif (errorKind == SpawnException::PRELOADER_STARTUP_TIMEOUT\n\t\t || errorKind == SpawnException::APP_STARTUP_TIMEOUT\n\t\t || errorKind == SpawnException::PRELOADER_STARTUP_ERROR\n\t\t || errorKind == SpawnException::APP_STARTUP_ERROR)\n\t\t{\n\t\t\tresult.append(\" Please read <a href=\\\"https://github.com/phusion/passenger/wiki/Debugging-application-startup-problems\\\">this article</a> \"\n\t\t\t\t\"for more information about this problem.\");\n\t\t}\n\t\tresult.append(\"<br>\\n<h2>Raw process output:</h2>\\n\");\n\n\t\tif (strip(stderrOutput).empty()) {\n\t\t\tresult.append(\"(empty)\");\n\t\t} else {\n\t\t\tresult.append(\"<pre>\");\n\t\t\tresult.append(escapeHTML(stderrOutput));\n\t\t\tresult.append(\"</pre>\");\n\t\t}\n\n\t\treturn result;\n\t}\n\n\ttemplate<typename Details>\n\tstring readMessageLine(Details &details) {\n\t\tTRACE_POINT();\n\t\twhile (true) {\n\t\t\tstring result = details.io.readLine(1024 * 16, &details.timeout);\n\t\t\tstring line = result;\n\t\t\tif (!line.empty() && line[line.size() - 1] == '\\n') {\n\t\t\t\tline.erase(line.size() - 1, 1);\n\t\t\t}\n\n\t\t\tif (result.empty()) {\n\t\t\t\t// EOF\n\t\t\t\treturn result;\n\t\t\t} else if (startsWith(result, \"!> \")) {\n\t\t\t\tP_DEBUG(\"[App \" << details.pid << \" stdout] \" << line);\n\t\t\t\tresult.erase(0, sizeof(\"!> \") - 1);\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\tif (details.stderrCapturer != NULL) {\n\t\t\t\t\tdetails.stderrCapturer->appendToBuffer(result);\n\t\t\t\t}\n\t\t\t\tLoggingKit::logAppOutput(details.pid, \"stdout\", line.data(), line.size());\n\t\t\t}\n\t\t}\n\t}\n\n\tSpawnPreparationInfo prepareSpawn(const Options &options) {\n\t\tTRACE_POINT();\n\t\tSpawnPreparationInfo info;\n\t\tprepareChroot(info, options);\n\t\tinfo.userSwitching = prepareUserSwitching(options);\n\t\tprepareSwitchingWorkingDirectory(info, options);\n\t\tinferApplicationInfo(info);\n\t\treturn info;\n\t}\n\n\tvoid prepareChroot(SpawnPreparationInfo &info, const Options &options) {\n\t\tTRACE_POINT();\n\t\tinfo.appRoot = absolutizePath(options.appRoot);\n\t\tif (options.preexecChroot.empty()) {\n\t\t\tinfo.chrootDir = \"/\";\n\t\t} else {\n\t\t\tinfo.chrootDir = absolutizePath(options.preexecChroot);\n\t\t}\n\t\tif (info.appRoot != info.chrootDir && startsWith(info.appRoot, info.chrootDir + \"/\")) {\n\t\t\tSpawnException e(\"Invalid configuration: '\" + info.chrootDir +\n\t\t\t\t\"' has been configured as the chroot jail, but the application \" +\n\t\t\t\t\"root directory '\" + info.appRoot + \"' is not a subdirectory of the \" +\n\t\t\t\t\"chroot directory, which it must be.\");\n\t\t\tthrowSpawnException(e, options);\n\t\t}\n\t\tif (info.appRoot == info.chrootDir) {\n\t\t\tinfo.appRootInsideChroot = \"/\";\n\t\t} else if (info.chrootDir == \"/\") {\n\t\t\tinfo.appRootInsideChroot = info.appRoot;\n\t\t} else {\n\t\t\tinfo.appRootInsideChroot = info.appRoot.substr(info.chrootDir.size());\n\t\t}\n\t}\n\n\tvoid prepareSwitchingWorkingDirectory(SpawnPreparationInfo &info, const Options &options) const {\n\t\tvector<string> components;\n\t\tsplit(info.appRootInsideChroot, '/', components);\n\t\tassert(components.front() == \"\");\n\t\tcomponents.erase(components.begin());\n\n\t\tfor (unsigned int i = 0; i < components.size(); i++) {\n\t\t\tstring path;\n\t\t\tfor (unsigned int j = 0; j <= i; j++) {\n\t\t\t\tpath.append(\"/\");\n\t\t\t\tpath.append(components[j]);\n\t\t\t}\n\t\t\tif (path.empty()) {\n\t\t\t\tpath = \"/\";\n\t\t\t}\n\t\t\tif (info.chrootDir == \"/\") {\n\t\t\t\tinfo.appRootPaths.push_back(path);\n\t\t\t} else {\n\t\t\t\tinfo.appRootPaths.push_back(info.chrootDir + path);\n\t\t\t}\n\t\t\tinfo.appRootPathsInsideChroot.push_back(path);\n\t\t}\n\n\t\tassert(info.appRootPathsInsideChroot.back() == info.appRootInsideChroot);\n\t}\n\n\tvoid inferApplicationInfo(SpawnPreparationInfo &info) const {\n\t\tinfo.codeRevision = readFromRevisionFile(info);\n\t\tif (info.codeRevision.empty()) {\n\t\t\tinfo.codeRevision = inferCodeRevisionFromCapistranoSymlink(info);\n\t\t}\n\t}\n\n\tstring readFromRevisionFile(const SpawnPreparationInfo &info) const {\n\t\tstring filename = info.appRoot + \"/REVISION\";\n\t\ttry {\n\t\t\tif (fileExists(filename)) {\n\t\t\t\treturn strip(readAll(filename));\n\t\t\t}\n\t\t} catch (const SystemException &e) {\n\t\t\tP_WARN(\"Cannot access \" << filename << \": \" << e.what());\n\t\t}\n\t\treturn string();\n\t}\n\n\tstring inferCodeRevisionFromCapistranoSymlink(const SpawnPreparationInfo &info) const {\n\t\tif (extractBaseName(info.appRoot) == \"current\") {\n\t\t\tchar buf[PATH_MAX + 1];\n\t\t\tssize_t ret;\n\n\t\t\tdo {\n\t\t\t\tret = readlink(info.appRoot.c_str(), buf, PATH_MAX);\n\t\t\t} while (ret == -1 && errno == EINTR);\n\t\t\tif (ret == -1) {\n\t\t\t\tif (errno == EINVAL) {\n\t\t\t\t\treturn string();\n\t\t\t\t} else {\n\t\t\t\t\tint e = errno;\n\t\t\t\t\tP_WARN(\"Cannot read symlink \" << info.appRoot << \": \" << strerror(e));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbuf[ret] = '\\0';\n\t\t\treturn extractBaseName(buf);\n\t\t} else {\n\t\t\treturn string();\n\t\t}\n\t}\n\n\tbool shouldLoadShellEnvvars(const Options &options, const SpawnPreparationInfo &preparation) const {\n\t\tif (options.loadShellEnvvars) {\n\t\t\tstring shellName = extractBaseName(preparation.userSwitching.shell);\n\t\t\tbool retVal = shellName == \"bash\" || shellName == \"zsh\" || shellName == \"ksh\";\n\t\t\tP_DEBUG(\"shellName = '\" << shellName << \"' in [bash,zsh,ksh]: \" << (retVal ? \"true\" : \"false\"));\n\t\t\treturn retVal;\n\t\t} else {\n\t\t\tP_DEBUG(\"options.loadShellEnvvars = false\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstring serializeEnvvarsFromPoolOptions(const Options &options) const {\n\t\tvector< pair<StaticString, StaticString> >::const_iterator it, end;\n\t\tstring result;\n\n\t\tappendNullTerminatedKeyValue(result, \"IN_PASSENGER\", \"1\");\n\t\tappendNullTerminatedKeyValue(result, \"PYTHONUNBUFFERED\", \"1\");\n\t\tappendNullTerminatedKeyValue(result, \"NODE_PATH\", config->resourceLocator->getNodeLibDir());\n\t\tappendNullTerminatedKeyValue(result, \"RAILS_ENV\", options.environment);\n\t\tappendNullTerminatedKeyValue(result, \"RACK_ENV\", options.environment);\n\t\tappendNullTerminatedKeyValue(result, \"WSGI_ENV\", options.environment);\n\t\tappendNullTerminatedKeyValue(result, \"NODE_ENV\", options.environment);\n\t\tappendNullTerminatedKeyValue(result, \"PASSENGER_APP_ENV\", options.environment);\n\t\tif (!options.baseURI.empty() && options.baseURI != \"/\") {\n\t\t\tappendNullTerminatedKeyValue(result,\n\t\t\t\t\"RAILS_RELATIVE_URL_ROOT\",\n\t\t\t\toptions.baseURI);\n\t\t\tappendNullTerminatedKeyValue(result,\n\t\t\t\t\"RACK_BASE_URI\",\n\t\t\t\toptions.baseURI);\n\t\t\tappendNullTerminatedKeyValue(result,\n\t\t\t\t\"PASSENGER_BASE_URI\",\n\t\t\t\toptions.baseURI);\n\t\t}\n\n\t\tstring envvarsData;\n\t\ttry {\n\t\t\tenvvarsData = modp::b64_decode(options.environmentVariables.data(),\n\t\t\t\toptions.environmentVariables.size());\n\t\t} catch (const std::runtime_error &) {\n\t\t\tP_WARN(\"Unable to decode base64-encoded environment variables: \" <<\n\t\t\t\toptions.environmentVariables);\n\t\t\tenvvarsData.clear();\n\t\t}\n\n\t\tif (!envvarsData.empty()) {\n\t\t\t// The envvars data is in the same format as `result`,\n\t\t\t// so we can just append it.\n\t\t\tresult.append(envvarsData);\n\t\t}\n\n\t\ttry {\n\t\t\treturn modp::b64_encode(result);\n\t\t} catch (const std::runtime_error &) {\n\t\t\tthrow RuntimeException(\"Unable to encode data into a base64 string\");\n\t\t}\n\t}\n\n\tvoid enterLveJail(const struct passwd * pw) {\n\t\tif (!pw)\n\t\t\treturn;\n\n\t\tstring lve_init_err;\n\t\tadhoc_lve::LibLve& liblve = adhoc_lve::LveInitSignleton::getInstance(&lve_init_err);\n\t\tif (liblve.is_error())\n\t\t{\n\t\t\tprintf(\"!> Error\\n\");\n\t\t\tprintf(\"!> \\n\");\n\t\t\tprintf(\"!> Failed to init LVE library%s%s\\n\",\n\t\t\t       lve_init_err.empty()? \"\" : \": \",\n\t\t\t       lve_init_err.c_str());\n\t\t\tfflush(stdout);\n\t\t\t_exit(1);\n\t\t}\n\n\t\tif (!liblve.is_lve_available())\n\t\t\treturn;\n\n\t\tstring jail_err;\n\t\tint rc = liblve.jail(pw, jail_err);\n\t\tif (rc < 0)\n\t\t{\n\t\t\tprintf(\"!> Error\\n\");\n\t\t\tprintf(\"!> \\n\");\n\t\t\tprintf(\"enterLve() failed: %s\\n\", jail_err.c_str());\n\t\t\tfflush(stdout);\n\t\t\t_exit(1);\n\t\t}\n\t}\n\n\tvoid switchUser(const SpawnPreparationInfo &info) {\n\t\tif (info.userSwitching.enabled) {\n\t\t\tenterLveJail(&info.userSwitching.lveUserPwd);\n\n\t\t\tbool setgroupsCalled = false;\n\t\t\t#ifdef HAVE_GETGROUPLIST\n\t\t\t\tif (info.userSwitching.ngroups <= NGROUPS_MAX) {\n\t\t\t\t\tsetgroupsCalled = true;\n\t\t\t\t\tif (setgroups(info.userSwitching.ngroups,\n\t\t\t\t\t\tinfo.userSwitching.gidset.get()) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tint e = errno;\n\t\t\t\t\t\tprintf(\"!> Error\\n\");\n\t\t\t\t\t\tprintf(\"!> \\n\");\n\t\t\t\t\t\tprintf(\"setgroups(%d, ...) failed: %s (errno=%d)\\n\",\n\t\t\t\t\t\t\tinfo.userSwitching.ngroups, strerror(e), e);\n\t\t\t\t\t\tfflush(stdout);\n\t\t\t\t\t\t_exit(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t#endif\n\t\t\tif (!setgroupsCalled && initgroups(info.userSwitching.username.c_str(),\n\t\t\t\tinfo.userSwitching.gid) == -1)\n\t\t\t{\n\t\t\t\tint e = errno;\n\t\t\t\tprintf(\"!> Error\\n\");\n\t\t\t\tprintf(\"!> \\n\");\n\t\t\t\tprintf(\"initgroups() failed: %s (errno=%d)\\n\",\n\t\t\t\t\tstrerror(e), e);\n\t\t\t\tfflush(stdout);\n\t\t\t\t_exit(1);\n\t\t\t}\n\t\t\tif (setgid(info.userSwitching.gid) == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\tprintf(\"!> Error\\n\");\n\t\t\t\tprintf(\"!> \\n\");\n\t\t\t\tprintf(\"setgid() failed: %s (errno=%d)\\n\",\n\t\t\t\t\tstrerror(e), e);\n\t\t\t\tfflush(stdout);\n\t\t\t\t_exit(1);\n\t\t\t}\n\t\t\tif (setuid(info.userSwitching.uid) == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\tprintf(\"!> Error\\n\");\n\t\t\t\tprintf(\"!> \\n\");\n\t\t\t\tprintf(\"setuid() failed: %s (errno=%d)\\n\",\n\t\t\t\t\tstrerror(e), e);\n\t\t\t\tfflush(stdout);\n\t\t\t\t_exit(1);\n\t\t\t}\n\n\t\t\t// We set these environment variables here instead of\n\t\t\t// in the SpawnPreparer because SpawnPreparer might\n\t\t\t// be executed by bash, but these environment variables\n\t\t\t// must be set before bash.\n\t\t\tsetenv(\"USER\", info.userSwitching.username.c_str(), 1);\n\t\t\tsetenv(\"LOGNAME\", info.userSwitching.username.c_str(), 1);\n\t\t\tsetenv(\"SHELL\", info.userSwitching.shell.c_str(), 1);\n\t\t\tsetenv(\"HOME\", info.userSwitching.home.c_str(), 1);\n\t\t\t// The application root may contain one or more symlinks\n\t\t\t// in its path. If the application calls getcwd(), it will\n\t\t\t// get the resolved path.\n\t\t\t//\n\t\t\t// It turns out that there is no such thing as a path without\n\t\t\t// unresolved symlinks. The shell presents a working directory with\n\t\t\t// unresolved symlinks (which it calls the \"logical working directory\"),\n\t\t\t// but that is an illusion provided by the shell. The shell reports\n\t\t\t// the logical working directory though the PWD environment variable.\n\t\t\t//\n\t\t\t// See also:\n\t\t\t// https://github.com/phusion/passenger/issues/1596#issuecomment-138154045\n\t\t\t// http://git.savannah.gnu.org/cgit/coreutils.git/tree/src/pwd.c\n\t\t\t// http://www.opensource.apple.com/source/shell_cmds/shell_cmds-170/pwd/pwd.c\n\t\t\tsetenv(\"PWD\", info.appRoot.c_str(), 1);\n\t\t}\n\t}\n\n\tvoid setChroot(const SpawnPreparationInfo &info) {\n\t\tif (info.chrootDir != \"/\") {\n\t\t\tint ret = chroot(info.chrootDir.c_str());\n\t\t\tif (ret == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\tfprintf(stderr, \"Cannot chroot() to '%s': %s (errno=%d)\\n\",\n\t\t\t\t\tinfo.chrootDir.c_str(),\n\t\t\t\t\tstrerror(e),\n\t\t\t\t\te);\n\t\t\t\tfflush(stderr);\n\t\t\t\t_exit(1);\n\t\t\t}\n\n\t\t\tret = chdir(\"/\");\n\t\t\tif (ret == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\tfprintf(stderr, \"Cannot chdir(\\\"/\\\") inside chroot: %s (errno=%d)\\n\",\n\t\t\t\t\tstrerror(e),\n\t\t\t\t\te);\n\t\t\t\tfflush(stderr);\n\t\t\t\t_exit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid setUlimits(const Options &options) {\n\t\tif (options.fileDescriptorUlimit != 0) {\n\t\t\tstruct rlimit limit;\n\t\t\tint ret;\n\n\t\t\tlimit.rlim_cur = options.fileDescriptorUlimit;\n\t\t\tlimit.rlim_max = options.fileDescriptorUlimit;\n\t\t\tdo {\n\t\t\t\tret = setrlimit(RLIMIT_NOFILE, &limit);\n\t\t\t} while (ret == -1 && errno == EINTR);\n\n\t\t\tif (ret == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\tfprintf(stderr, \"Unable to set file descriptor ulimit to %u: %s (errno=%d)\",\n\t\t\t\t\toptions.fileDescriptorUlimit, strerror(e), e);\n\t\t\t\tfflush(stderr);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid setWorkingDirectory(const SpawnPreparationInfo &info) {\n\t\tvector<string>::const_iterator it, end = info.appRootPathsInsideChroot.end();\n\t\tint ret;\n\n\t\tfor (it = info.appRootPathsInsideChroot.begin(); it != end; it++) {\n\t\t\tstruct stat buf;\n\t\t\tret = stat(it->c_str(), &buf);\n\t\t\tif (ret == -1 && errno == EACCES) {\n\t\t\t\tchar parent[PATH_MAX];\n\t\t\t\tconst char *end = strrchr(it->c_str(), '/');\n\t\t\t\tmemcpy(parent, it->c_str(), end - it->c_str());\n\t\t\t\tparent[end - it->c_str()] = '\\0';\n\n\t\t\t\tprintf(\"!> Error\\n\");\n\t\t\t\tprintf(\"!> \\n\");\n\t\t\t\tprintf(\"This web application process is being run as user '%s' and group '%s' \"\n\t\t\t\t\t\"and must be able to access its application root directory '%s'. \"\n\t\t\t\t\t\"However, the parent directory '%s' has wrong permissions, thereby \"\n\t\t\t\t\t\"preventing this process from accessing its application root directory. \"\n\t\t\t\t\t\"Please fix the permissions of the directory '%s' first.\\n\",\n\t\t\t\t\tinfo.userSwitching.username.c_str(),\n\t\t\t\t\tinfo.userSwitching.groupname.c_str(),\n\t\t\t\t\tinfo.appRootPaths.back().c_str(),\n\t\t\t\t\tparent,\n\t\t\t\t\tparent);\n\t\t\t\tfflush(stdout);\n\t\t\t\t_exit(1);\n\t\t\t} else if (ret == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\tprintf(\"!> Error\\n\");\n\t\t\t\tprintf(\"!> \\n\");\n\t\t\t\tprintf(\"Unable to stat() directory '%s': %s (errno=%d)\\n\",\n\t\t\t\t\tit->c_str(), strerror(e), e);\n\t\t\t\tfflush(stdout);\n\t\t\t\t_exit(1);\n\t\t\t}\n\t\t}\n\n\t\tret = chdir(info.appRootPathsInsideChroot.back().c_str());\n\t\tif (ret == 0) {\n\t\t\tsetenv(\"PWD\", info.appRootPathsInsideChroot.back().c_str(), 1);\n\t\t} else if (ret == -1 && errno == EACCES) {\n\t\t\tprintf(\"!> Error\\n\");\n\t\t\tprintf(\"!> \\n\");\n\t\t\tprintf(\"This web application process is being run as user '%s' and group '%s' \"\n\t\t\t\t\"and must be able to access its application root directory '%s'. \"\n\t\t\t\t\"However this directory is not accessible because it has wrong permissions. \"\n\t\t\t\t\"Please fix these permissions first.\\n\",\n\t\t\t\tinfo.userSwitching.username.c_str(),\n\t\t\t\tinfo.userSwitching.groupname.c_str(),\n\t\t\t\tinfo.appRootPaths.back().c_str());\n\t\t\tfflush(stdout);\n\t\t\t_exit(1);\n\t\t} else {\n\t\t\tint e = errno;\n\t\t\tprintf(\"!> Error\\n\");\n\t\t\tprintf(\"!> \\n\");\n\t\t\tprintf(\"Unable to change working directory to '%s': %s (errno=%d)\\n\",\n\t\t\t\tinfo.appRootPathsInsideChroot.back().c_str(), strerror(e), e);\n\t\t\tfflush(stdout);\n\t\t\t_exit(1);\n\t\t}\n\t}\n\n\t/**\n\t * Execute the process spawning negotiation protocol.\n\t */\n\tResult negotiateSpawn(NegotiationDetails &details) {\n\t\tTRACE_POINT();\n\t\tdetails.spawnStartTime = SystemTime::getUsec();\n\t\tdetails.gupid = integerToHex(SystemTime::get() / 60) + \"-\" +\n\t\t\tconfig->randomGenerator->generateAsciiString(10);\n\t\tdetails.timeout = details.options->startTimeout * 1000;\n\n\t\tstring result;\n\t\ttry {\n\t\t\tresult = readMessageLine(details);\n\t\t} catch (const SystemException &e) {\n\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\"web application. There was an I/O error while reading its \"\n\t\t\t\t\"handshake message: \" + e.sys(),\n\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\tdetails);\n\t\t} catch (const TimeoutException &) {\n\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\"web application: it did not write a handshake message in time.\",\n\t\t\t\tSpawnException::APP_STARTUP_TIMEOUT,\n\t\t\t\tdetails);\n\t\t}\n\n\t\tprotocol_begin:\n\t\tif (result == \"I have control 1.0\\n\") {\n\t\t\tUPDATE_TRACE_POINT();\n\t\t\tsendSpawnRequest(details);\n\t\t\ttry {\n\t\t\t\tresult = readMessageLine(details);\n\t\t\t} catch (const SystemException &e) {\n\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\"web application. There was an I/O error while reading its \"\n\t\t\t\t\t\"startup response: \" + e.sys(),\n\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\tdetails);\n\t\t\t} catch (const TimeoutException &) {\n\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\"web application: it did not write a startup response in time. \"\n\t\t\t\t\t\"If your app needs more time to start you can increase the \"\n\t\t\t\t\t\"Passenger start timeout config option.\",\n\t\t\t\t\tSpawnException::APP_STARTUP_TIMEOUT,\n\t\t\t\t\tdetails);\n\t\t\t}\n\t\t\tif (result == \"Ready\\n\") {\n\t\t\t\treturn handleSpawnResponse(details);\n\t\t\t} else if (result == \"Error\\n\") {\n\t\t\t\thandleSpawnErrorResponse(details);\n\t\t\t} else if (result == \"I have control 1.0\\n\") {\n\t\t\t\tgoto protocol_begin;\n\t\t\t} else {\n\t\t\t\thandleInvalidSpawnResponseType(result, details);\n\t\t\t}\n\t\t} else {\n\t\t\tUPDATE_TRACE_POINT();\n\t\t\tif (result == \"Error\\n\") {\n\t\t\t\thandleSpawnErrorResponse(details);\n\t\t\t} else {\n\t\t\t\thandleInvalidSpawnResponseType(result, details);\n\t\t\t}\n\t\t}\n\t\treturn Result(); // Never reached.\n\t}\n\n\tvoid handleSpawnErrorResponse(NegotiationDetails &details) {\n\t\tTRACE_POINT();\n\t\tmap<string, string> attributes;\n\n\t\twhile (true) {\n\t\t\tstring line = readMessageLine(details);\n\t\t\tif (line.empty()) {\n\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\"web application. It unexpected closed the connection while \"\n\t\t\t\t\t\"sending its startup response.\",\n\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\tdetails);\n\t\t\t} else if (line[line.size() - 1] != '\\n') {\n\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\"web application. It sent a line without a newline character \"\n\t\t\t\t\t\"in its startup response.\",\n\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\tdetails);\n\t\t\t} else if (line == \"\\n\") {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstring::size_type pos = line.find(\": \");\n\t\t\tif (pos == string::npos) {\n\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\"web application. It sent a startup response line without \"\n\t\t\t\t\t\"separator.\",\n\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\tdetails);\n\t\t\t}\n\n\t\t\tstring key = line.substr(0, pos);\n\t\t\tstring value = line.substr(pos + 2, line.size() - pos - 3);\n\t\t\tattributes[key] = value;\n\t\t}\n\n\t\ttry {\n\t\t\tstring message = details.io.readAll(&details.timeout);\n\t\t\tSpawnException e(\"An error occured while starting the web application.\",\n\t\t\t\tmessage,\n\t\t\t\tattributes[\"html\"] == \"true\",\n\t\t\t\tSpawnException::APP_STARTUP_EXPLAINABLE_ERROR);\n\t\t\tannotateAppSpawnException(e, details);\n\t\t\tthrowSpawnException(e, *details.options);\n\t\t} catch (const SystemException &e) {\n\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\"web application. It tried to report an error message, but \"\n\t\t\t\t\"an I/O error occurred while reading this error message: \" +\n\t\t\t\te.sys(),\n\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\tdetails);\n\t\t} catch (const TimeoutException &) {\n\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\"web application. It tried to report an error message, but \"\n\t\t\t\t\"it took too much time doing that.\",\n\t\t\t\tSpawnException::APP_STARTUP_TIMEOUT,\n\t\t\t\tdetails);\n\t\t}\n\t}\n\n\tvoid handleInvalidSpawnResponseType(const string &line, NegotiationDetails &details) {\n\t\tif (line.empty()) {\n\t\t\tthrowAppSpawnException(\"An error occurred while starting \"\n\t\t\t\t\"the web application. It exited before signalling successful \"\n\t\t\t\t\"startup back to \" PROGRAM_NAME \".\",\n\t\t\t\tSpawnException::APP_STARTUP_ERROR,\n\t\t\t\tdetails);\n\t\t} else {\n\t\t\tthrowAppSpawnException(\"An error occurred while starting \"\n\t\t\t\t\"the web application. It sent an unknown response type \\\"\" +\n\t\t\t\tcEscapeString(line) + \"\\\".\",\n\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\tdetails);\n\t\t}\n\t}\n\npublic:\n\t/**\n\t * Timestamp at which this Spawner was created. Microseconds resolution.\n\t */\n\tconst unsigned long long creationTime;\n\n\tSpawner(const ConfigPtr &_config)\n\t\t: config(_config),\n\t\t  creationTime(SystemTime::getUsec())\n\t\t{ }\n\n\tvirtual ~Spawner() { }\n\n\tvirtual Result spawn(const Options &options) = 0;\n\n\tvirtual bool cleanable() const {\n\t\treturn false;\n\t}\n\n\tvirtual void cleanup() {\n\t\t// Do nothing.\n\t}\n\n\tvirtual unsigned long long lastUsed() const {\n\t\treturn 0;\n\t}\n\n\tConfigPtr getConfig() const {\n\t\treturn config;\n\t}\n};\ntypedef boost::shared_ptr<Spawner> SpawnerPtr;\n\n\n} // namespace SpawningKit\n} // namespace Passenger\n\n#endif /* _PASSENGER_SPAWNING_KIT_SPAWNER_H_ */\n"], "fixing_code": ["/*\n *  Phusion Passenger - https://www.phusionpassenger.com/\n *  Copyright (c) 2011-2017 Phusion Holding B.V.\n *\n *  \"Passenger\", \"Phusion Passenger\" and \"Union Station\" are registered\n *  trademarks of Phusion Holding B.V.\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n#ifndef _PASSENGER_SPAWNING_KIT_SPAWNER_H_\n#define _PASSENGER_SPAWNING_KIT_SPAWNER_H_\n\n/*\n * This file implements application spawning support. Several classes\n * are provided which all implement the Spawner interface. The spawn()\n * method spawns an application process based on the given options\n * and returns a Process object which contains information about the\n * spawned process.\n *\n * The DirectSpawner class spawns application processes directly.\n *\n * The SmartSpawner class spawns application processes through a\n * preloader process. The preloader process loads the application\n * code into its address space and then listens on a socket for spawn\n * commands. Upon receiving a spawn command, it will fork() itself.\n * This makes spawning multiple application processes much faster.\n * Note that a single SmartSpawner instance is only usable for a\n * single application.\n *\n * DummySpawner doesn't do anything. It returns dummy Process objects.\n *\n * DirectSpawner, SmartSpawner and DummySpawner all implement the Spawner interface.\n *\n * SpawnerFactory is a convenience class which takes an Options objects\n * and figures out, based on options.spawnMethod, whether to create\n * a DirectSpawner or a SmartSpawner. In case of the smart spawning\n * method, SpawnerFactory also automatically figures out which preloader\n * to use based on options.appType.\n */\n\n#include <string>\n#include <map>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <boost/make_shared.hpp>\n#include <boost/shared_array.hpp>\n#include <boost/bind.hpp>\n#include <boost/foreach.hpp>\n#include <boost/move/move.hpp>\n#include <oxt/system_calls.hpp>\n#include <oxt/backtrace.hpp>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cerrno>\n#include <cassert>\n#include <unistd.h>\n#include <pwd.h>\n#include <grp.h>\n#include <dirent.h>\n#include <adhoc_lve.h>\n#include <modp_b64.h>\n#include <FileDescriptor.h>\n#include <Exceptions.h>\n#include <StaticString.h>\n#include <Utils.h>\n#include <Utils/BufferedIO.h>\n#include <Utils/ScopeGuard.h>\n#include <Utils/Timer.h>\n#include <Utils/IOUtils.h>\n#include <Utils/StrIntUtils.h>\n#include <Utils/ProcessMetricsCollector.h>\n#include <Core/SpawningKit/Config.h>\n#include <Core/SpawningKit/Options.h>\n#include <Core/SpawningKit/Result.h>\n#include <Core/SpawningKit/BackgroundIOCapturer.h>\n#include <Core/SpawningKit/UserSwitchingRules.h>\n\nnamespace tut {\n\tstruct ApplicationPool2_DirectSpawnerTest;\n\tstruct ApplicationPool2_SmartSpawnerTest;\n}\n\nnamespace Passenger {\nnamespace SpawningKit {\n\nusing namespace std;\nusing namespace boost;\nusing namespace oxt;\n\n\nclass Spawner {\nprotected:\n\tfriend struct tut::ApplicationPool2_DirectSpawnerTest;\n\tfriend struct tut::ApplicationPool2_SmartSpawnerTest;\n\n\t/**\n\t * A temporary directory for spawned child processes to write\n\t * debugging information to. It is removed after spawning has\n\t * determined to be successful or failed.\n\t */\n\tclass DebugDir {\n\tprivate:\n\t\tstring path;\n\n\t\tstatic void doClosedir(DIR *dir) {\n\t\t\tclosedir(dir);\n\t\t}\n\n\tpublic:\n\t\tDebugDir(uid_t uid, gid_t gid) {\n\t\t\tchar buf[PATH_MAX] = \"/tmp/passenger.spawn-debug.XXXXXXXXXX\";\n\t\t\tconst char *result = mkdtemp(buf);\n\t\t\tif (result == NULL) {\n\t\t\t\tint e = errno;\n\t\t\t\tthrow SystemException(\"Cannot create a temporary directory \"\n\t\t\t\t\t\"in the format of '/tmp/passenger-spawn-debug.XXX'\", e);\n\t\t\t} else {\n\t\t\t\tpath = result;\n\t\t\t\tboost::this_thread::disable_interruption di;\n\t\t\t\tboost::this_thread::disable_syscall_interruption dsi;\n\t\t\t\tsyscalls::chown(result, uid, gid);\n\t\t\t}\n\t\t}\n\n\t\t~DebugDir() {\n\t\t\tremoveDirTree(path);\n\t\t}\n\n\t\tconst string &getPath() const {\n\t\t\treturn path;\n\t\t}\n\n\t\tmap<string, string> readAll() {\n\t\t\tmap<string, string> result;\n\t\t\tDIR *dir = opendir(path.c_str());\n\t\t\tScopeGuard guard(boost::bind(doClosedir, dir));\n\t\t\tstruct dirent *ent;\n\n\t\t\twhile ((ent = readdir(dir)) != NULL) {\n\t\t\t\tif (ent->d_name[0] != '.') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresult.insert(make_pair<string, string>(\n\t\t\t\t\t\t\tent->d_name,\n\t\t\t\t\t\t\tPassenger::readAll(path + \"/\" + ent->d_name)));\n\t\t\t\t\t} catch (const SystemException &) {\n\t\t\t\t\t\t// Do nothing.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t};\n\n\ttypedef boost::shared_ptr<DebugDir> DebugDirPtr;\n\n\t/**\n\t * Contains information that will be used after fork()ing but before exec()ing,\n\t * such as the intended app root, the UID it should switch to, the\n\t * groups it should assume, etc. This structure is allocated before forking\n\t * because after forking and before exec() it may not be safe to allocate memory.\n\t */\n\tstruct SpawnPreparationInfo {\n\t\t// General\n\n\t\t/** Absolute application root path. */\n\t\tstring appRoot;\n\t\t/** Absolute pre-exec chroot path. If no chroot is configured, then this is \"/\". */\n\t\tstring chrootDir;\n\t\t/** Absolute application root path inside the chroot. If no chroot is\n\t\t * configured then this is is equal to appRoot. */\n\t\tstring appRootInsideChroot;\n\t\t/** A list of all parent directories of the appRoot, as well as appRoot itself.\n\t\t * The pre-exec chroot directory is included, and this list goes no futher than that.\n\t\t * For example if appRoot is /var/jail/foo/bar/baz and the chroot is /var/jail,\n\t\t * then this list contains:\n\t\t *   /var/jail/foo\n\t\t *   /var/jail/foo/bar\n\t\t *   /var/jail/foo/bar/baz\n\t\t */\n\t\tvector<string> appRootPaths;\n\t\t/** Same as appRootPaths, but without the chroot component. For example if\n\t\t * appRoot is /var/jail/foo/bar/baz and the chroot is /var/jail, then this list\n\t\t * contains:\n\t\t *   /foo\n\t\t *   /foo/bar\n\t\t *   /foo/bar/baz\n\t\t */\n\t\tvector<string> appRootPathsInsideChroot;\n\n\t\tUserSwitchingInfo userSwitching;\n\n\t\t// Other information\n\t\tstring codeRevision;\n\t};\n\n\t/**\n\t * Structure containing arguments and working state for negotiating\n\t * the spawning protocol.\n\t */\n\tstruct NegotiationDetails {\n\t\t/****** Arguments ******/\n\n\t\t/** The preparation info of the process we're negotiating with. It's used\n\t\t * by security validators to check whether the information sent back by the\n\t\t * process make any sense. */\n\t\tSpawnPreparationInfo *preparation;\n\t\t/** This object captures the process's stderr while negotiation is in progress.\n\t\t * (Recall that negotiation is performed over the process's stdout while stderr\n\t\t * is used purely for outputting messages.)\n\t\t * If the negotiation protocol fails, then any output captured by this object\n\t\t * will be stored into the resulting SpawnException's error page. */\n\t\tBackgroundIOCapturerPtr stderrCapturer;\n\t\t/** The PID of the process we're negotiating with. */\n\t\tpid_t pid;\n\t\tFileDescriptor adminSocket;\n\t\tFileDescriptor errorPipe;\n\t\tconst Options *options;\n\t\tDebugDirPtr debugDir;\n\n\t\t/****** Working state ******/\n\t\tBufferedIO io;\n\t\tstring gupid;\n\t\tunsigned long long spawnStartTime;\n\t\tunsigned long long timeout;\n\n\t\tNegotiationDetails() {\n\t\t\tpreparation = NULL;\n\t\t\tpid = 0;\n\t\t\toptions = NULL;\n\t\t\tspawnStartTime = 0;\n\t\t\ttimeout = 0;\n\t\t}\n\t};\n\nprivate:\n\t/**\n\t * Appends key + \"\\0\" + value + \"\\0\" to 'output'.\n\t */\n\tstatic void appendNullTerminatedKeyValue(string &output, const StaticString &key,\n\t\tconst StaticString &value)\n\t{\n\t\toutput.append(key.data(), key.size());\n\t\toutput.append(1, '\\0');\n\t\toutput.append(value.data(), value.size());\n\t\toutput.append(1, '\\0');\n\t}\n\n\tvoid sendSpawnRequest(NegotiationDetails &details) {\n\t\tTRACE_POINT();\n\t\ttry {\n\t\t\tconst size_t UNIX_PATH_MAX = sizeof(((struct sockaddr_un *) 0)->sun_path);\n\t\t\tstring data = \"You have control 1.0\\n\"\n\t\t\t\t\"passenger_root: \" + config->resourceLocator->getInstallSpec() + \"\\n\"\n\t\t\t\t\"passenger_version: \" PASSENGER_VERSION \"\\n\"\n\t\t\t\t\"ruby_libdir: \" + config->resourceLocator->getRubyLibDir() + \"\\n\"\n\t\t\t\t\"gupid: \" + details.gupid + \"\\n\"\n\t\t\t\t\"UNIX_PATH_MAX: \" + toString(UNIX_PATH_MAX) + \"\\n\";\n\t\t\tif (!details.options->apiKey.empty()) {\n\t\t\t\tdata.append(\"connect_password: \" + details.options->apiKey + \"\\n\");\n\t\t\t}\n\t\t\tif (!config->instanceDir.empty()) {\n\t\t\t\tdata.append(\"instance_dir: \" + config->instanceDir + \"\\n\");\n\t\t\t\tdata.append(\"socket_dir: \" + config->instanceDir + \"/apps.s\\n\");\n\t\t\t}\n\n\t\t\tvector<string> args;\n\t\t\tvector<string>::const_iterator it, end;\n\t\t\tdetails.options->toVector(args, *config->resourceLocator, Options::SPAWN_OPTIONS);\n\t\t\tfor (it = args.begin(); it != args.end(); it++) {\n\t\t\t\tconst string &key = *it;\n\t\t\t\tit++;\n\t\t\t\tconst string &value = *it;\n\t\t\t\tdata.append(key + \": \" + value + \"\\n\");\n\t\t\t}\n\n\t\t\tvector<StaticString> lines;\n\t\t\tsplit(data, '\\n', lines);\n\t\t\tforeach (const StaticString line, lines) {\n\t\t\t\tP_DEBUG(\"[App \" << details.pid << \" stdin >>] \" << line);\n\t\t\t}\n\t\t\twriteExact(details.adminSocket, data, &details.timeout);\n\t\t\twriteExact(details.adminSocket, \"\\n\", &details.timeout);\n\t\t} catch (const SystemException &e) {\n\t\t\tif (e.code() == EPIPE) {\n\t\t\t\t/* Ignore this. Process might have written an\n\t\t\t\t * error response before reading the arguments,\n\t\t\t\t * in which case we'll want to show that instead.\n\t\t\t\t */\n\t\t\t} else {\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\t}\n\n\tResult handleSpawnResponse(NegotiationDetails &details) {\n\t\tTRACE_POINT();\n\t\tJson::Value sockets;\n\t\tResult result;\n\n\t\twhile (true) {\n\t\t\tstring line;\n\n\t\t\ttry {\n\t\t\t\tline = readMessageLine(details);\n\t\t\t} catch (const SystemException &e) {\n\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\"web application. There was an I/O error while reading its \"\n\t\t\t\t\t\"startup response: \" + e.sys(),\n\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\tdetails);\n\t\t\t} catch (const TimeoutException &) {\n\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\"web application: it did not write a startup response in time. \"\n\t\t\t\t\t\"If your app needs more time to start you can increase the \"\n\t\t\t\t\t\"Passenger start timeout config option.\",\n\t\t\t\t\tSpawnException::APP_STARTUP_TIMEOUT,\n\t\t\t\t\tdetails);\n\t\t\t}\n\n\t\t\tif (line.empty()) {\n\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\"web application. It unexpectedly closed the connection while \"\n\t\t\t\t\t\"sending its startup response.\",\n\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\tdetails);\n\t\t\t} else if (line[line.size() - 1] != '\\n') {\n\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\"web application. It sent a line without a newline character \"\n\t\t\t\t\t\"in its startup response.\",\n\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\tdetails);\n\t\t\t} else if (line == \"\\n\") {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstring::size_type pos = line.find(\": \");\n\t\t\tif (pos == string::npos) {\n\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\"web application. It sent a startup response line without \"\n\t\t\t\t\t\"separator.\",\n\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\tdetails);\n\t\t\t}\n\n\t\t\tstring key = line.substr(0, pos);\n\t\t\tstring value = line.substr(pos + 2, line.size() - pos - 3);\n\t\t\tif (key == \"socket\") {\n\t\t\t\t// socket: <name>;<address>;<protocol>;<concurrency>\n\t\t\t\t// TODO: in case of TCP sockets, check whether it points to localhost\n\t\t\t\t// TODO: in case of unix sockets, check whether filename is absolute\n\t\t\t\t// and whether owner is correct\n\t\t\t\tvector<string> args;\n\t\t\t\tsplit(value, ';', args);\n\t\t\t\tif (args.size() == 4) {\n\t\t\t\t\tstring error = validateSocketAddress(details, args[1]);\n\t\t\t\t\tif (!error.empty()) {\n\t\t\t\t\t\tthrowAppSpawnException(\n\t\t\t\t\t\t\t\"An error occurred while starting the web application. \" + error,\n\t\t\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\t\t\tdetails);\n\t\t\t\t\t}\n\n\t\t\t\t\tJson::Value socket;\n\t\t\t\t\tsocket[\"name\"] = args[0];\n\t\t\t\t\tsocket[\"address\"] = fixupSocketAddress(*details.options, args[1]);\n\t\t\t\t\tsocket[\"protocol\"] = args[2];\n\t\t\t\t\tsocket[\"concurrency\"] = atoi(args[3]);\n\t\t\t\t\tsockets.append(socket);\n\t\t\t\t} else {\n\t\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\t\"web application. It reported a wrongly formatted 'socket'\"\n\t\t\t\t\t\t\"response value: '\" + value + \"'\",\n\t\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\t\tdetails);\n\t\t\t\t}\n\t\t\t} else if (key == \"pid\") {\n\t\t\t\t// pid: <PID>\n\t\t\t\tpid_t pid = atoi(value);\n\t\t\t\tProcessMetricsCollector collector;\n\t\t\t\tvector<pid_t> pids;\n\n\t\t\t\tpids.push_back(pid);\n\t\t\t\tProcessMetricMap metrics = collector.collect(pids);\n\t\t\t\tif (metrics[pid].uid != details.preparation->userSwitching.uid) {\n\t\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\t\"web application. The PID that the loader has returned does \"\n\t\t\t\t\t\t\"not have the same UID as the loader itself.\",\n\t\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\t\tdetails);\n\t\t\t\t}\n\t\t\t\tdetails.pid = pid;\n\t\t\t} else {\n\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\"web application. It sent an unknown startup response line \"\n\t\t\t\t\t\"called '\" + key + \"'.\",\n\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\tdetails);\n\t\t\t}\n\t\t}\n\n\t\tif (!hasSessionSockets(sockets)) {\n\t\t\tthrowAppSpawnException(\"An error occured while starting the web \"\n\t\t\t\t\"application. It did not advertise any session sockets.\",\n\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\tdetails);\n\t\t}\n\n\t\tresult[\"type\"] = \"os_process\";\n\t\tresult[\"pid\"] = (int) details.pid;\n\t\tresult[\"gupid\"] = details.gupid;\n\t\tresult[\"sockets\"] = sockets;\n\t\tresult[\"code_revision\"] = details.preparation->codeRevision;\n\t\tresult[\"spawner_creation_time\"] = (Json::UInt64) creationTime;\n\t\tresult[\"spawn_start_time\"] = (Json::UInt64) details.spawnStartTime;\n\t\tresult.adminSocket = details.adminSocket;\n\t\tresult.errorPipe = details.errorPipe;\n\t\treturn result;\n\t}\n\n\tbool hasSessionSockets(const Json::Value &sockets) const {\n\t\tJson::Value::const_iterator it, end = sockets.end();\n\n\t\tfor (it = sockets.begin(); it != end; it++) {\n\t\t\tconst Json::Value &socket = *it;\n\t\t\tif (socket[\"protocol\"] == \"session\" || socket[\"protocol\"] == \"http_session\") {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\nprotected:\n\tConfigPtr config;\n\n\tstatic void nonInterruptableKillAndWaitpid(pid_t pid) {\n\t\tboost::this_thread::disable_syscall_interruption dsi;\n\t\tsyscalls::kill(pid, SIGKILL);\n\t\tsyscalls::waitpid(pid, NULL, 0);\n\t}\n\n\t/**\n\t * Behaves like <tt>waitpid(pid, status, WNOHANG)</tt>, but waits at most\n\t * <em>timeout</em> miliseconds for the process to exit.\n\t */\n\tstatic int timedWaitpid(pid_t pid, int *status, unsigned long long timeout) {\n\t\tTimer<SystemTime::GRAN_10MSEC> timer;\n\t\tint ret;\n\n\t\tdo {\n\t\t\tret = syscalls::waitpid(pid, status, WNOHANG);\n\t\t\tif (ret > 0 || ret == -1) {\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\tsyscalls::usleep(10000);\n\t\t\t}\n\t\t} while (timer.elapsed() < timeout);\n\t\treturn 0; // timed out\n\t}\n\n\tstatic string fixupSocketAddress(const Options &options, const string &address) {\n\t\tTRACE_POINT();\n\t\tif (!options.preexecChroot.empty() && !options.postexecChroot.empty()) {\n\t\t\tServerAddressType type = getSocketAddressType(address);\n\t\t\tif (type == SAT_UNIX) {\n\t\t\t\tstring filename = parseUnixSocketAddress(address);\n\t\t\t\tstring fixedAddress = \"unix:\";\n\t\t\t\tif (!options.preexecChroot.empty()) {\n\t\t\t\t\tfixedAddress.append(options.preexecChroot.data(),\n\t\t\t\t\t\toptions.preexecChroot.size());\n\t\t\t\t}\n\t\t\t\tif (!options.postexecChroot.empty()) {\n\t\t\t\t\tfixedAddress.append(options.postexecChroot.data(),\n\t\t\t\t\t\toptions.postexecChroot.size());\n\t\t\t\t}\n\t\t\t\tfixedAddress.append(filename);\n\t\t\t\treturn fixedAddress;\n\t\t\t} else {\n\t\t\t\treturn address;\n\t\t\t}\n\t\t} else {\n\t\t\treturn address;\n\t\t}\n\t}\n\n\tbool isAbsolutePath(const StaticString &path) const {\n\t\tif (path.empty() || path[0] != '/') {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tvector<string> components;\n\t\t\tstring component;\n\n\t\t\tsplit(path, '/', components);\n\t\t\tcomponents.erase(components.begin());\n\t\t\tforeach (component, components) {\n\t\t\t\tif (component.empty() || component == \".\" || component == \"..\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Given a 'socket:' information string obtained from the spawned process,\n\t * validates whether it is correct.\n\t */\n\tstring validateSocketAddress(NegotiationDetails &details, const string &_address) const {\n\t\tstring address = _address;\n\t\tstringstream error;\n\n\t\tswitch (getSocketAddressType(address)) {\n\t\tcase SAT_UNIX: {\n\t\t\taddress = fixupSocketAddress(*details.options, address);\n\t\t\tstring filename = parseUnixSocketAddress(address);\n\n\t\t\t// Verify that the socket filename is absolute.\n\t\t\tif (!isAbsolutePath(filename)) {\n\t\t\t\terror << \"It reported a non-absolute socket filename: \\\"\" <<\n\t\t\t\t\tcEscapeString(filename) << \"\\\"\";\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Verify that the process owns the socket.\n\t\t\tstruct stat buf;\n\t\t\tif (lstat(filename.c_str(), &buf) == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\terror << \"It reported an inaccessible socket filename: \\\"\" <<\n\t\t\t\t\tcEscapeString(filename) << \"\\\" (lstat() failed with errno \" <<\n\t\t\t\t\te << \": \" << strerror(e) << \")\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (buf.st_uid != details.preparation->userSwitching.uid) {\n\t\t\t\terror << \"It advertised a Unix domain socket that has a different \" <<\n\t\t\t\t\t\"owner than expected (should be UID \" << details.preparation->userSwitching.uid <<\n\t\t\t\t\t\", but actual UID was \" << buf.st_uid << \")\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase SAT_TCP:\n\t\t\t// TODO: validate that the socket is localhost.\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror << \"It reported an unsupported socket address type: \\\"\" <<\n\t\t\t\tcEscapeString(address) << \"\\\"\";\n\t\t\tbreak;\n\t\t}\n\n\t\treturn error.str();\n\t}\n\n\tstatic void checkChrootDirectories(const Options &options) {\n\t\tif (!options.preexecChroot.empty()) {\n\t\t\t// TODO: check whether appRoot is a child directory of preexecChroot\n\t\t\t// and whether postexecChroot is a child directory of appRoot.\n\t\t}\n\t}\n\n\tstatic void createCommandArgs(const vector<string> &command,\n\t\tshared_array<const char *> &args)\n\t{\n\t\targs.reset(new const char *[command.size()]);\n\t\tfor (unsigned int i = 1; i < command.size(); i++) {\n\t\t\targs[i - 1] = command[i].c_str();\n\t\t}\n\t\targs[command.size() - 1] = NULL;\n\t}\n\n\tvoid possiblyRaiseInternalError(const Options &options) {\n\t\tif (options.raiseInternalError) {\n\t\t\tthrow RuntimeException(\"An internal error!\");\n\t\t}\n\t}\n\n\tvoid throwAppSpawnException(const string &msg,\n\t\tSpawnException::ErrorKind errorKind,\n\t\tNegotiationDetails &details)\n\t{\n\t\tTRACE_POINT();\n\t\t// Stop the stderr capturing thread and get the captured stderr\n\t\t// output so far.\n\t\tstring stderrOutput;\n\t\tif (details.stderrCapturer != NULL) {\n\t\t\tstderrOutput = details.stderrCapturer->stop();\n\t\t}\n\n\t\t// If the exception wasn't due to a timeout, try to capture the\n\t\t// remaining stderr output for at most 2 seconds.\n\t\tif (errorKind != SpawnException::PRELOADER_STARTUP_TIMEOUT\n\t\t && errorKind != SpawnException::APP_STARTUP_TIMEOUT\n\t\t && details.stderrCapturer != NULL)\n\t\t{\n\t\t\tbool done = false;\n\t\t\tunsigned long long timeout = 2000;\n\t\t\twhile (!done) {\n\t\t\t\tchar buf[1024 * 32];\n\t\t\t\tunsigned int ret;\n\n\t\t\t\ttry {\n\t\t\t\t\tret = readExact(details.stderrCapturer->getFd(), buf,\n\t\t\t\t\t\tsizeof(buf), &timeout);\n\t\t\t\t\tif (ret == 0) {\n\t\t\t\t\t\tdone = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstderrOutput.append(buf, ret);\n\t\t\t\t\t}\n\t\t\t\t} catch (const SystemException &e) {\n\t\t\t\t\tP_WARN(\"Stderr I/O capture error: \" << e.what());\n\t\t\t\t\tdone = true;\n\t\t\t\t} catch (const TimeoutException &) {\n\t\t\t\t\tdone = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdetails.stderrCapturer.reset();\n\n\t\t// Now throw SpawnException with the captured stderr output\n\t\t// as error response.\n\t\tSpawnException e(msg,\n\t\t\tcreateErrorPageFromStderrOutput(msg, errorKind, stderrOutput),\n\t\t\ttrue,\n\t\t\terrorKind);\n\t\tannotateAppSpawnException(e, details);\n\t\tthrowSpawnException(e, *details.options);\n\t}\n\n\tvoid throwSpawnException(SpawnException &e, const Options &options) {\n\t\tif (config->errorHandler != NULL) {\n\t\t\tconfig->errorHandler(config, e, options);\n\t\t}\n\t\tthrow e;\n\t}\n\n\tvirtual void annotateAppSpawnException(SpawnException &e, NegotiationDetails &details) {\n\t\tif (details.debugDir != NULL) {\n\t\t\te.addAnnotations(details.debugDir->readAll());\n\t\t}\n\t}\n\n\tstring createErrorPageFromStderrOutput(const string &msg,\n\t\tSpawnException::ErrorKind errorKind,\n\t\tconst string &stderrOutput)\n\t{\n\t\t// These kinds of SpawnExceptions are not supposed to be handled through this function.\n\t\tassert(errorKind != SpawnException::PRELOADER_STARTUP_EXPLAINABLE_ERROR);\n\t\tassert(errorKind != SpawnException::APP_STARTUP_EXPLAINABLE_ERROR);\n\n\t\tstring result = escapeHTML(msg);\n\n\t\tif (errorKind == SpawnException::PRELOADER_STARTUP_TIMEOUT\n\t\t || errorKind == SpawnException::APP_STARTUP_TIMEOUT\n\t\t || errorKind == SpawnException::PRELOADER_STARTUP_ERROR\n\t\t || errorKind == SpawnException::APP_STARTUP_ERROR)\n\t\t{\n\t\t\tresult.append(\" Please read <a href=\\\"https://github.com/phusion/passenger/wiki/Debugging-application-startup-problems\\\">this article</a> \"\n\t\t\t\t\"for more information about this problem.\");\n\t\t}\n\t\tresult.append(\"<br>\\n<h2>Raw process output:</h2>\\n\");\n\n\t\tif (strip(stderrOutput).empty()) {\n\t\t\tresult.append(\"(empty)\");\n\t\t} else {\n\t\t\tresult.append(\"<pre>\");\n\t\t\tresult.append(escapeHTML(stderrOutput));\n\t\t\tresult.append(\"</pre>\");\n\t\t}\n\n\t\treturn result;\n\t}\n\n\ttemplate<typename Details>\n\tstring readMessageLine(Details &details) {\n\t\tTRACE_POINT();\n\t\twhile (true) {\n\t\t\tstring result = details.io.readLine(1024 * 16, &details.timeout);\n\t\t\tstring line = result;\n\t\t\tif (!line.empty() && line[line.size() - 1] == '\\n') {\n\t\t\t\tline.erase(line.size() - 1, 1);\n\t\t\t}\n\n\t\t\tif (result.empty()) {\n\t\t\t\t// EOF\n\t\t\t\treturn result;\n\t\t\t} else if (startsWith(result, \"!> \")) {\n\t\t\t\tP_DEBUG(\"[App \" << details.pid << \" stdout] \" << line);\n\t\t\t\tresult.erase(0, sizeof(\"!> \") - 1);\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\tif (details.stderrCapturer != NULL) {\n\t\t\t\t\tdetails.stderrCapturer->appendToBuffer(result);\n\t\t\t\t}\n\t\t\t\tLoggingKit::logAppOutput(details.pid, \"stdout\", line.data(), line.size());\n\t\t\t}\n\t\t}\n\t}\n\n\tSpawnPreparationInfo prepareSpawn(const Options &options) {\n\t\tTRACE_POINT();\n\t\tSpawnPreparationInfo info;\n\t\tprepareChroot(info, options);\n\t\tinfo.userSwitching = prepareUserSwitching(options);\n\t\tprepareSwitchingWorkingDirectory(info, options);\n\t\treturn info;\n\t}\n\n\tvoid prepareChroot(SpawnPreparationInfo &info, const Options &options) {\n\t\tTRACE_POINT();\n\t\tinfo.appRoot = absolutizePath(options.appRoot);\n\t\tif (options.preexecChroot.empty()) {\n\t\t\tinfo.chrootDir = \"/\";\n\t\t} else {\n\t\t\tinfo.chrootDir = absolutizePath(options.preexecChroot);\n\t\t}\n\t\tif (info.appRoot != info.chrootDir && startsWith(info.appRoot, info.chrootDir + \"/\")) {\n\t\t\tSpawnException e(\"Invalid configuration: '\" + info.chrootDir +\n\t\t\t\t\"' has been configured as the chroot jail, but the application \" +\n\t\t\t\t\"root directory '\" + info.appRoot + \"' is not a subdirectory of the \" +\n\t\t\t\t\"chroot directory, which it must be.\");\n\t\t\tthrowSpawnException(e, options);\n\t\t}\n\t\tif (info.appRoot == info.chrootDir) {\n\t\t\tinfo.appRootInsideChroot = \"/\";\n\t\t} else if (info.chrootDir == \"/\") {\n\t\t\tinfo.appRootInsideChroot = info.appRoot;\n\t\t} else {\n\t\t\tinfo.appRootInsideChroot = info.appRoot.substr(info.chrootDir.size());\n\t\t}\n\t}\n\n\tvoid prepareSwitchingWorkingDirectory(SpawnPreparationInfo &info, const Options &options) const {\n\t\tvector<string> components;\n\t\tsplit(info.appRootInsideChroot, '/', components);\n\t\tassert(components.front() == \"\");\n\t\tcomponents.erase(components.begin());\n\n\t\tfor (unsigned int i = 0; i < components.size(); i++) {\n\t\t\tstring path;\n\t\t\tfor (unsigned int j = 0; j <= i; j++) {\n\t\t\t\tpath.append(\"/\");\n\t\t\t\tpath.append(components[j]);\n\t\t\t}\n\t\t\tif (path.empty()) {\n\t\t\t\tpath = \"/\";\n\t\t\t}\n\t\t\tif (info.chrootDir == \"/\") {\n\t\t\t\tinfo.appRootPaths.push_back(path);\n\t\t\t} else {\n\t\t\t\tinfo.appRootPaths.push_back(info.chrootDir + path);\n\t\t\t}\n\t\t\tinfo.appRootPathsInsideChroot.push_back(path);\n\t\t}\n\n\t\tassert(info.appRootPathsInsideChroot.back() == info.appRootInsideChroot);\n\t}\n\n#ifdef false\n\tvoid inferApplicationInfo(SpawnPreparationInfo &info) const {\n\t\tinfo.codeRevision = readFromRevisionFile(info);\n\t\tif (info.codeRevision.empty()) {\n\t\t\tinfo.codeRevision = inferCodeRevisionFromCapistranoSymlink(info);\n\t\t}\n\t}\n\n\tstring readFromRevisionFile(const SpawnPreparationInfo &info) const {\n\t\tstring filename = info.appRoot + \"/REVISION\";\n\t\ttry {\n\t\t\tif (fileExists(filename)) {\n\t\t\t\treturn strip(readAll(filename));\n\t\t\t}\n\t\t} catch (const SystemException &e) {\n\t\t\tP_WARN(\"Cannot access \" << filename << \": \" << e.what());\n\t\t}\n\t\treturn string();\n\t}\n\n\tstring inferCodeRevisionFromCapistranoSymlink(const SpawnPreparationInfo &info) const {\n\t\tif (extractBaseName(info.appRoot) == \"current\") {\n\t\t\tchar buf[PATH_MAX + 1];\n\t\t\tssize_t ret;\n\n\t\t\tdo {\n\t\t\t\tret = readlink(info.appRoot.c_str(), buf, PATH_MAX);\n\t\t\t} while (ret == -1 && errno == EINTR);\n\t\t\tif (ret == -1) {\n\t\t\t\tif (errno == EINVAL) {\n\t\t\t\t\treturn string();\n\t\t\t\t} else {\n\t\t\t\t\tint e = errno;\n\t\t\t\t\tP_WARN(\"Cannot read symlink \" << info.appRoot << \": \" << strerror(e));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbuf[ret] = '\\0';\n\t\t\treturn extractBaseName(buf);\n\t\t} else {\n\t\t\treturn string();\n\t\t}\n\t}\n#endif\n\n\tbool shouldLoadShellEnvvars(const Options &options, const SpawnPreparationInfo &preparation) const {\n\t\tif (options.loadShellEnvvars) {\n\t\t\tstring shellName = extractBaseName(preparation.userSwitching.shell);\n\t\t\tbool retVal = shellName == \"bash\" || shellName == \"zsh\" || shellName == \"ksh\";\n\t\t\tP_DEBUG(\"shellName = '\" << shellName << \"' in [bash,zsh,ksh]: \" << (retVal ? \"true\" : \"false\"));\n\t\t\treturn retVal;\n\t\t} else {\n\t\t\tP_DEBUG(\"options.loadShellEnvvars = false\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstring serializeEnvvarsFromPoolOptions(const Options &options) const {\n\t\tvector< pair<StaticString, StaticString> >::const_iterator it, end;\n\t\tstring result;\n\n\t\tappendNullTerminatedKeyValue(result, \"IN_PASSENGER\", \"1\");\n\t\tappendNullTerminatedKeyValue(result, \"PYTHONUNBUFFERED\", \"1\");\n\t\tappendNullTerminatedKeyValue(result, \"NODE_PATH\", config->resourceLocator->getNodeLibDir());\n\t\tappendNullTerminatedKeyValue(result, \"RAILS_ENV\", options.environment);\n\t\tappendNullTerminatedKeyValue(result, \"RACK_ENV\", options.environment);\n\t\tappendNullTerminatedKeyValue(result, \"WSGI_ENV\", options.environment);\n\t\tappendNullTerminatedKeyValue(result, \"NODE_ENV\", options.environment);\n\t\tappendNullTerminatedKeyValue(result, \"PASSENGER_APP_ENV\", options.environment);\n\t\tif (!options.baseURI.empty() && options.baseURI != \"/\") {\n\t\t\tappendNullTerminatedKeyValue(result,\n\t\t\t\t\"RAILS_RELATIVE_URL_ROOT\",\n\t\t\t\toptions.baseURI);\n\t\t\tappendNullTerminatedKeyValue(result,\n\t\t\t\t\"RACK_BASE_URI\",\n\t\t\t\toptions.baseURI);\n\t\t\tappendNullTerminatedKeyValue(result,\n\t\t\t\t\"PASSENGER_BASE_URI\",\n\t\t\t\toptions.baseURI);\n\t\t}\n\n\t\tstring envvarsData;\n\t\ttry {\n\t\t\tenvvarsData = modp::b64_decode(options.environmentVariables.data(),\n\t\t\t\toptions.environmentVariables.size());\n\t\t} catch (const std::runtime_error &) {\n\t\t\tP_WARN(\"Unable to decode base64-encoded environment variables: \" <<\n\t\t\t\toptions.environmentVariables);\n\t\t\tenvvarsData.clear();\n\t\t}\n\n\t\tif (!envvarsData.empty()) {\n\t\t\t// The envvars data is in the same format as `result`,\n\t\t\t// so we can just append it.\n\t\t\tresult.append(envvarsData);\n\t\t}\n\n\t\ttry {\n\t\t\treturn modp::b64_encode(result);\n\t\t} catch (const std::runtime_error &) {\n\t\t\tthrow RuntimeException(\"Unable to encode data into a base64 string\");\n\t\t}\n\t}\n\n\tvoid enterLveJail(const struct passwd * pw) {\n\t\tif (!pw)\n\t\t\treturn;\n\n\t\tstring lve_init_err;\n\t\tadhoc_lve::LibLve& liblve = adhoc_lve::LveInitSignleton::getInstance(&lve_init_err);\n\t\tif (liblve.is_error())\n\t\t{\n\t\t\tprintf(\"!> Error\\n\");\n\t\t\tprintf(\"!> \\n\");\n\t\t\tprintf(\"!> Failed to init LVE library%s%s\\n\",\n\t\t\t       lve_init_err.empty()? \"\" : \": \",\n\t\t\t       lve_init_err.c_str());\n\t\t\tfflush(stdout);\n\t\t\t_exit(1);\n\t\t}\n\n\t\tif (!liblve.is_lve_available())\n\t\t\treturn;\n\n\t\tstring jail_err;\n\t\tint rc = liblve.jail(pw, jail_err);\n\t\tif (rc < 0)\n\t\t{\n\t\t\tprintf(\"!> Error\\n\");\n\t\t\tprintf(\"!> \\n\");\n\t\t\tprintf(\"enterLve() failed: %s\\n\", jail_err.c_str());\n\t\t\tfflush(stdout);\n\t\t\t_exit(1);\n\t\t}\n\t}\n\n\tvoid switchUser(const SpawnPreparationInfo &info) {\n\t\tif (info.userSwitching.enabled) {\n\t\t\tenterLveJail(&info.userSwitching.lveUserPwd);\n\n\t\t\tbool setgroupsCalled = false;\n\t\t\t#ifdef HAVE_GETGROUPLIST\n\t\t\t\tif (info.userSwitching.ngroups <= NGROUPS_MAX) {\n\t\t\t\t\tsetgroupsCalled = true;\n\t\t\t\t\tif (setgroups(info.userSwitching.ngroups,\n\t\t\t\t\t\tinfo.userSwitching.gidset.get()) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tint e = errno;\n\t\t\t\t\t\tprintf(\"!> Error\\n\");\n\t\t\t\t\t\tprintf(\"!> \\n\");\n\t\t\t\t\t\tprintf(\"setgroups(%d, ...) failed: %s (errno=%d)\\n\",\n\t\t\t\t\t\t\tinfo.userSwitching.ngroups, strerror(e), e);\n\t\t\t\t\t\tfflush(stdout);\n\t\t\t\t\t\t_exit(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t#endif\n\t\t\tif (!setgroupsCalled && initgroups(info.userSwitching.username.c_str(),\n\t\t\t\tinfo.userSwitching.gid) == -1)\n\t\t\t{\n\t\t\t\tint e = errno;\n\t\t\t\tprintf(\"!> Error\\n\");\n\t\t\t\tprintf(\"!> \\n\");\n\t\t\t\tprintf(\"initgroups() failed: %s (errno=%d)\\n\",\n\t\t\t\t\tstrerror(e), e);\n\t\t\t\tfflush(stdout);\n\t\t\t\t_exit(1);\n\t\t\t}\n\t\t\tif (setgid(info.userSwitching.gid) == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\tprintf(\"!> Error\\n\");\n\t\t\t\tprintf(\"!> \\n\");\n\t\t\t\tprintf(\"setgid() failed: %s (errno=%d)\\n\",\n\t\t\t\t\tstrerror(e), e);\n\t\t\t\tfflush(stdout);\n\t\t\t\t_exit(1);\n\t\t\t}\n\t\t\tif (setuid(info.userSwitching.uid) == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\tprintf(\"!> Error\\n\");\n\t\t\t\tprintf(\"!> \\n\");\n\t\t\t\tprintf(\"setuid() failed: %s (errno=%d)\\n\",\n\t\t\t\t\tstrerror(e), e);\n\t\t\t\tfflush(stdout);\n\t\t\t\t_exit(1);\n\t\t\t}\n\n\t\t\t// We set these environment variables here instead of\n\t\t\t// in the SpawnPreparer because SpawnPreparer might\n\t\t\t// be executed by bash, but these environment variables\n\t\t\t// must be set before bash.\n\t\t\tsetenv(\"USER\", info.userSwitching.username.c_str(), 1);\n\t\t\tsetenv(\"LOGNAME\", info.userSwitching.username.c_str(), 1);\n\t\t\tsetenv(\"SHELL\", info.userSwitching.shell.c_str(), 1);\n\t\t\tsetenv(\"HOME\", info.userSwitching.home.c_str(), 1);\n\t\t\t// The application root may contain one or more symlinks\n\t\t\t// in its path. If the application calls getcwd(), it will\n\t\t\t// get the resolved path.\n\t\t\t//\n\t\t\t// It turns out that there is no such thing as a path without\n\t\t\t// unresolved symlinks. The shell presents a working directory with\n\t\t\t// unresolved symlinks (which it calls the \"logical working directory\"),\n\t\t\t// but that is an illusion provided by the shell. The shell reports\n\t\t\t// the logical working directory though the PWD environment variable.\n\t\t\t//\n\t\t\t// See also:\n\t\t\t// https://github.com/phusion/passenger/issues/1596#issuecomment-138154045\n\t\t\t// http://git.savannah.gnu.org/cgit/coreutils.git/tree/src/pwd.c\n\t\t\t// http://www.opensource.apple.com/source/shell_cmds/shell_cmds-170/pwd/pwd.c\n\t\t\tsetenv(\"PWD\", info.appRoot.c_str(), 1);\n\t\t}\n\t}\n\n\tvoid setChroot(const SpawnPreparationInfo &info) {\n\t\tif (info.chrootDir != \"/\") {\n\t\t\tint ret = chroot(info.chrootDir.c_str());\n\t\t\tif (ret == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\tfprintf(stderr, \"Cannot chroot() to '%s': %s (errno=%d)\\n\",\n\t\t\t\t\tinfo.chrootDir.c_str(),\n\t\t\t\t\tstrerror(e),\n\t\t\t\t\te);\n\t\t\t\tfflush(stderr);\n\t\t\t\t_exit(1);\n\t\t\t}\n\n\t\t\tret = chdir(\"/\");\n\t\t\tif (ret == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\tfprintf(stderr, \"Cannot chdir(\\\"/\\\") inside chroot: %s (errno=%d)\\n\",\n\t\t\t\t\tstrerror(e),\n\t\t\t\t\te);\n\t\t\t\tfflush(stderr);\n\t\t\t\t_exit(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid setUlimits(const Options &options) {\n\t\tif (options.fileDescriptorUlimit != 0) {\n\t\t\tstruct rlimit limit;\n\t\t\tint ret;\n\n\t\t\tlimit.rlim_cur = options.fileDescriptorUlimit;\n\t\t\tlimit.rlim_max = options.fileDescriptorUlimit;\n\t\t\tdo {\n\t\t\t\tret = setrlimit(RLIMIT_NOFILE, &limit);\n\t\t\t} while (ret == -1 && errno == EINTR);\n\n\t\t\tif (ret == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\tfprintf(stderr, \"Unable to set file descriptor ulimit to %u: %s (errno=%d)\",\n\t\t\t\t\toptions.fileDescriptorUlimit, strerror(e), e);\n\t\t\t\tfflush(stderr);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid setWorkingDirectory(const SpawnPreparationInfo &info) {\n\t\tvector<string>::const_iterator it, end = info.appRootPathsInsideChroot.end();\n\t\tint ret;\n\n\t\tfor (it = info.appRootPathsInsideChroot.begin(); it != end; it++) {\n\t\t\tstruct stat buf;\n\t\t\tret = stat(it->c_str(), &buf);\n\t\t\tif (ret == -1 && errno == EACCES) {\n\t\t\t\tchar parent[PATH_MAX];\n\t\t\t\tconst char *end = strrchr(it->c_str(), '/');\n\t\t\t\tmemcpy(parent, it->c_str(), end - it->c_str());\n\t\t\t\tparent[end - it->c_str()] = '\\0';\n\n\t\t\t\tprintf(\"!> Error\\n\");\n\t\t\t\tprintf(\"!> \\n\");\n\t\t\t\tprintf(\"This web application process is being run as user '%s' and group '%s' \"\n\t\t\t\t\t\"and must be able to access its application root directory '%s'. \"\n\t\t\t\t\t\"However, the parent directory '%s' has wrong permissions, thereby \"\n\t\t\t\t\t\"preventing this process from accessing its application root directory. \"\n\t\t\t\t\t\"Please fix the permissions of the directory '%s' first.\\n\",\n\t\t\t\t\tinfo.userSwitching.username.c_str(),\n\t\t\t\t\tinfo.userSwitching.groupname.c_str(),\n\t\t\t\t\tinfo.appRootPaths.back().c_str(),\n\t\t\t\t\tparent,\n\t\t\t\t\tparent);\n\t\t\t\tfflush(stdout);\n\t\t\t\t_exit(1);\n\t\t\t} else if (ret == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\tprintf(\"!> Error\\n\");\n\t\t\t\tprintf(\"!> \\n\");\n\t\t\t\tprintf(\"Unable to stat() directory '%s': %s (errno=%d)\\n\",\n\t\t\t\t\tit->c_str(), strerror(e), e);\n\t\t\t\tfflush(stdout);\n\t\t\t\t_exit(1);\n\t\t\t}\n\t\t}\n\n\t\tret = chdir(info.appRootPathsInsideChroot.back().c_str());\n\t\tif (ret == 0) {\n\t\t\tsetenv(\"PWD\", info.appRootPathsInsideChroot.back().c_str(), 1);\n\t\t} else if (ret == -1 && errno == EACCES) {\n\t\t\tprintf(\"!> Error\\n\");\n\t\t\tprintf(\"!> \\n\");\n\t\t\tprintf(\"This web application process is being run as user '%s' and group '%s' \"\n\t\t\t\t\"and must be able to access its application root directory '%s'. \"\n\t\t\t\t\"However this directory is not accessible because it has wrong permissions. \"\n\t\t\t\t\"Please fix these permissions first.\\n\",\n\t\t\t\tinfo.userSwitching.username.c_str(),\n\t\t\t\tinfo.userSwitching.groupname.c_str(),\n\t\t\t\tinfo.appRootPaths.back().c_str());\n\t\t\tfflush(stdout);\n\t\t\t_exit(1);\n\t\t} else {\n\t\t\tint e = errno;\n\t\t\tprintf(\"!> Error\\n\");\n\t\t\tprintf(\"!> \\n\");\n\t\t\tprintf(\"Unable to change working directory to '%s': %s (errno=%d)\\n\",\n\t\t\t\tinfo.appRootPathsInsideChroot.back().c_str(), strerror(e), e);\n\t\t\tfflush(stdout);\n\t\t\t_exit(1);\n\t\t}\n\t}\n\n\t/**\n\t * Execute the process spawning negotiation protocol.\n\t */\n\tResult negotiateSpawn(NegotiationDetails &details) {\n\t\tTRACE_POINT();\n\t\tdetails.spawnStartTime = SystemTime::getUsec();\n\t\tdetails.gupid = integerToHex(SystemTime::get() / 60) + \"-\" +\n\t\t\tconfig->randomGenerator->generateAsciiString(10);\n\t\tdetails.timeout = details.options->startTimeout * 1000;\n\n\t\tstring result;\n\t\ttry {\n\t\t\tresult = readMessageLine(details);\n\t\t} catch (const SystemException &e) {\n\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\"web application. There was an I/O error while reading its \"\n\t\t\t\t\"handshake message: \" + e.sys(),\n\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\tdetails);\n\t\t} catch (const TimeoutException &) {\n\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\"web application: it did not write a handshake message in time.\",\n\t\t\t\tSpawnException::APP_STARTUP_TIMEOUT,\n\t\t\t\tdetails);\n\t\t}\n\n\t\tprotocol_begin:\n\t\tif (result == \"I have control 1.0\\n\") {\n\t\t\tUPDATE_TRACE_POINT();\n\t\t\tsendSpawnRequest(details);\n\t\t\ttry {\n\t\t\t\tresult = readMessageLine(details);\n\t\t\t} catch (const SystemException &e) {\n\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\"web application. There was an I/O error while reading its \"\n\t\t\t\t\t\"startup response: \" + e.sys(),\n\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\tdetails);\n\t\t\t} catch (const TimeoutException &) {\n\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\"web application: it did not write a startup response in time. \"\n\t\t\t\t\t\"If your app needs more time to start you can increase the \"\n\t\t\t\t\t\"Passenger start timeout config option.\",\n\t\t\t\t\tSpawnException::APP_STARTUP_TIMEOUT,\n\t\t\t\t\tdetails);\n\t\t\t}\n\t\t\tif (result == \"Ready\\n\") {\n\t\t\t\treturn handleSpawnResponse(details);\n\t\t\t} else if (result == \"Error\\n\") {\n\t\t\t\thandleSpawnErrorResponse(details);\n\t\t\t} else if (result == \"I have control 1.0\\n\") {\n\t\t\t\tgoto protocol_begin;\n\t\t\t} else {\n\t\t\t\thandleInvalidSpawnResponseType(result, details);\n\t\t\t}\n\t\t} else {\n\t\t\tUPDATE_TRACE_POINT();\n\t\t\tif (result == \"Error\\n\") {\n\t\t\t\thandleSpawnErrorResponse(details);\n\t\t\t} else {\n\t\t\t\thandleInvalidSpawnResponseType(result, details);\n\t\t\t}\n\t\t}\n\t\treturn Result(); // Never reached.\n\t}\n\n\tvoid handleSpawnErrorResponse(NegotiationDetails &details) {\n\t\tTRACE_POINT();\n\t\tmap<string, string> attributes;\n\n\t\twhile (true) {\n\t\t\tstring line = readMessageLine(details);\n\t\t\tif (line.empty()) {\n\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\"web application. It unexpected closed the connection while \"\n\t\t\t\t\t\"sending its startup response.\",\n\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\tdetails);\n\t\t\t} else if (line[line.size() - 1] != '\\n') {\n\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\"web application. It sent a line without a newline character \"\n\t\t\t\t\t\"in its startup response.\",\n\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\tdetails);\n\t\t\t} else if (line == \"\\n\") {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstring::size_type pos = line.find(\": \");\n\t\t\tif (pos == string::npos) {\n\t\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\t\"web application. It sent a startup response line without \"\n\t\t\t\t\t\"separator.\",\n\t\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\t\tdetails);\n\t\t\t}\n\n\t\t\tstring key = line.substr(0, pos);\n\t\t\tstring value = line.substr(pos + 2, line.size() - pos - 3);\n\t\t\tattributes[key] = value;\n\t\t}\n\n\t\ttry {\n\t\t\tstring message = details.io.readAll(&details.timeout);\n\t\t\tSpawnException e(\"An error occured while starting the web application.\",\n\t\t\t\tmessage,\n\t\t\t\tattributes[\"html\"] == \"true\",\n\t\t\t\tSpawnException::APP_STARTUP_EXPLAINABLE_ERROR);\n\t\t\tannotateAppSpawnException(e, details);\n\t\t\tthrowSpawnException(e, *details.options);\n\t\t} catch (const SystemException &e) {\n\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\"web application. It tried to report an error message, but \"\n\t\t\t\t\"an I/O error occurred while reading this error message: \" +\n\t\t\t\te.sys(),\n\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\tdetails);\n\t\t} catch (const TimeoutException &) {\n\t\t\tthrowAppSpawnException(\"An error occurred while starting the \"\n\t\t\t\t\"web application. It tried to report an error message, but \"\n\t\t\t\t\"it took too much time doing that.\",\n\t\t\t\tSpawnException::APP_STARTUP_TIMEOUT,\n\t\t\t\tdetails);\n\t\t}\n\t}\n\n\tvoid handleInvalidSpawnResponseType(const string &line, NegotiationDetails &details) {\n\t\tif (line.empty()) {\n\t\t\tthrowAppSpawnException(\"An error occurred while starting \"\n\t\t\t\t\"the web application. It exited before signalling successful \"\n\t\t\t\t\"startup back to \" PROGRAM_NAME \".\",\n\t\t\t\tSpawnException::APP_STARTUP_ERROR,\n\t\t\t\tdetails);\n\t\t} else {\n\t\t\tthrowAppSpawnException(\"An error occurred while starting \"\n\t\t\t\t\"the web application. It sent an unknown response type \\\"\" +\n\t\t\t\tcEscapeString(line) + \"\\\".\",\n\t\t\t\tSpawnException::APP_STARTUP_PROTOCOL_ERROR,\n\t\t\t\tdetails);\n\t\t}\n\t}\n\npublic:\n\t/**\n\t * Timestamp at which this Spawner was created. Microseconds resolution.\n\t */\n\tconst unsigned long long creationTime;\n\n\tSpawner(const ConfigPtr &_config)\n\t\t: config(_config),\n\t\t  creationTime(SystemTime::getUsec())\n\t\t{ }\n\n\tvirtual ~Spawner() { }\n\n\tvirtual Result spawn(const Options &options) = 0;\n\n\tvirtual bool cleanable() const {\n\t\treturn false;\n\t}\n\n\tvirtual void cleanup() {\n\t\t// Do nothing.\n\t}\n\n\tvirtual unsigned long long lastUsed() const {\n\t\treturn 0;\n\t}\n\n\tConfigPtr getConfig() const {\n\t\treturn config;\n\t}\n};\ntypedef boost::shared_ptr<Spawner> SpawnerPtr;\n\n\n} // namespace SpawningKit\n} // namespace Passenger\n\n#endif /* _PASSENGER_SPAWNING_KIT_SPAWNER_H_ */\n"], "filenames": ["src/agent/Core/SpawningKit/Spawner.h"], "buggy_code_start_loc": [724], "buggy_code_end_loc": [819], "fixing_code_start_loc": [723], "fixing_code_end_loc": [821], "type": "CWE-200", "message": "In agent/Core/SpawningKit/Spawner.h in Phusion Passenger 5.1.10 (fixed in Passenger Open Source 5.1.11 and Passenger Enterprise 5.1.10), if Passenger is running as root, it is possible to list the contents of arbitrary files on a system by symlinking a file named REVISION from the application root folder to a file of choice and querying passenger-status --show=xml.", "other": {"cve": {"id": "CVE-2017-16355", "sourceIdentifier": "cve@mitre.org", "published": "2017-12-14T22:29:00.210", "lastModified": "2019-10-28T15:31:55.957", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In agent/Core/SpawningKit/Spawner.h in Phusion Passenger 5.1.10 (fixed in Passenger Open Source 5.1.11 and Passenger Enterprise 5.1.10), if Passenger is running as root, it is possible to list the contents of arbitrary files on a system by symlinking a file named REVISION from the application root folder to a file of choice and querying passenger-status --show=xml."}, {"lang": "es", "value": "En agent/Core/SpawningKit/Spawner.h en Phusion Passenger 5.1.10 (corregido en Passenger Open Source 5.1.11 y Passenger Enterprise 5.1.10), si Passenger se est\u00e1 ejecutando como root, es posible listar el contenido de archivos arbitrarios en un sistema vinculando simb\u00f3licamente un archivo llamado REVISION de la carpeta root de la aplicaci\u00f3n a un archivo de libre elecci\u00f3n y consultando passenger-status --show=xml."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:H/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 1.2}, "baseSeverity": "LOW", "exploitabilityScore": 1.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:phusion:passenger:*:*:*:*:enterprise:*:*:*", "versionStartIncluding": "5.0.10", "versionEndExcluding": "5.1.10", "matchCriteriaId": "7E734B94-2D51-47B0-9AEF-E736969D2E82"}, {"vulnerable": true, "criteria": "cpe:2.3:a:phusion:passenger:*:*:*:*:open_source:*:*:*", "versionStartIncluding": "5.0.10", "versionEndExcluding": "5.1.11", "matchCriteriaId": "285B15FA-D517-437D-8C69-D7C6CBAB9468"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://blog.phusion.nl/2017/10/13/passenger-security-advisory-5-1-11/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/phusion/passenger/commit/4043718264095cde6623c2cbe8c644541036d7bf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Mar/34", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2019/dsa-4415", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/phusion/passenger/commit/4043718264095cde6623c2cbe8c644541036d7bf"}}