{"buggy_code": ["/* radare - LGPL - Copyright 2011-2016 - pancake */\n\n#include <r_cons.h>\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_bin.h>\n#include \"dex/dex.h\"\n#define r_hash_adler32 __adler32\n#include \"../../hash/adler32.c\"\n\nextern struct r_bin_dbginfo_t r_bin_dbginfo_dex;\n\n#define DEBUG_PRINTF 0\n\n#if DEBUG_PRINTF\n#define dprintf eprintf\n#else\n#define dprintf if (0)eprintf\n#endif\n\nstatic bool dexdump = false;\nstatic Sdb *mdb = NULL;\nstatic Sdb *cdb = NULL; // TODO: remove if it is not used\n\nstatic char *getstr(RBinDexObj *bin, int idx) {\n\tut8 buf[6];\n\tut64 len;\n\tint uleblen;\n\tif (!bin || idx < 0 || idx >= bin->header.strings_size ||\n\t\t!bin->strings) {\n\t\treturn NULL;\n\t}\n\tif (bin->strings[idx] >= bin->size) {\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_read_at (bin->b, bin->strings[idx], buf, sizeof (buf)) < 1) {\n\t\treturn NULL;\n\t}\n\tuleblen = r_uleb128 (buf, sizeof (buf), &len) - buf;\n\tif (!uleblen || uleblen >= bin->size) {\n\t\treturn NULL;\n\t}\n\tif (!len || len >= bin->size) {\n\t\treturn NULL;\n\t}\n\t// TODO: improve this ugly fix\n\tchar c = 'a';\n\twhile (c) {\n\t\tut64 offset = bin->strings[idx] + uleblen + len;\n\t\tif (offset >= bin->size || offset < len) {\n\t\t\treturn NULL;\n\t\t}\n\t\tr_buf_read_at (bin->b, offset, (ut8*)&c, 1);\n\t\tlen++;\n\t}\n\tif ((int)len > 0 && len < R_BIN_SIZEOF_STRINGS) {\n\t\tchar *str = calloc (1, len + 1);\n\t\tif (str) {\n\t\t\tr_buf_read_at (bin->b, (bin->strings[idx]) + uleblen,\n\t\t\t\t\t\t(ut8 *)str, len);\n\t\t\tstr[len] = 0;\n\t\t\treturn str;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic int countOnes(ut32 val) {\n\tint count = 0;\n\tval = val - ((val >> 1) & 0x55555555);\n\tval = (val & 0x33333333) + ((val >> 2) & 0x33333333);\n\tcount = (((val + (val >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;\n\treturn count;\n}\n\ntypedef enum {\n\tkAccessForClass  = 0,\n\tkAccessForMethod = 1,\n\tkAccessForField  = 2,\n\tkAccessForMAX\n} AccessFor;\n\nstatic char *createAccessFlagStr(ut32 flags, AccessFor forWhat) {\n\t#define NUM_FLAGS 18\n\tstatic const char* kAccessStrings[kAccessForMAX][NUM_FLAGS] = {\n\t\t{\n\t\t\t/* class, inner class */\n\t\t\t\"PUBLIC\",           /* 0x0001 */\n\t\t\t\"PRIVATE\",          /* 0x0002 */\n\t\t\t\"PROTECTED\",        /* 0x0004 */\n\t\t\t\"STATIC\",           /* 0x0008 */\n\t\t\t\"FINAL\",            /* 0x0010 */\n\t\t\t\"?\",                /* 0x0020 */\n\t\t\t\"?\",                /* 0x0040 */\n\t\t\t\"?\",                /* 0x0080 */\n\t\t\t\"?\",                /* 0x0100 */\n\t\t\t\"INTERFACE\",        /* 0x0200 */\n\t\t\t\"ABSTRACT\",         /* 0x0400 */\n\t\t\t\"?\",                /* 0x0800 */\n\t\t\t\"SYNTHETIC\",        /* 0x1000 */\n\t\t\t\"ANNOTATION\",       /* 0x2000 */\n\t\t\t\"ENUM\",             /* 0x4000 */\n\t\t\t\"?\",                /* 0x8000 */\n\t\t\t\"VERIFIED\",         /* 0x10000 */\n\t\t\t\"OPTIMIZED\",        /* 0x20000 */\n\t\t},\n\t\t{\n\t\t\t/* method */\n\t\t\t\"PUBLIC\",           /* 0x0001 */\n\t\t\t\"PRIVATE\",          /* 0x0002 */\n\t\t\t\"PROTECTED\",        /* 0x0004 */\n\t\t\t\"STATIC\",           /* 0x0008 */\n\t\t\t\"FINAL\",            /* 0x0010 */\n\t\t\t\"SYNCHRONIZED\",     /* 0x0020 */\n\t\t\t\"BRIDGE\",           /* 0x0040 */\n\t\t\t\"VARARGS\",          /* 0x0080 */\n\t\t\t\"NATIVE\",           /* 0x0100 */\n\t\t\t\"?\",                /* 0x0200 */\n\t\t\t\"ABSTRACT\",         /* 0x0400 */\n\t\t\t\"STRICT\",           /* 0x0800 */\n\t\t\t\"SYNTHETIC\",        /* 0x1000 */\n\t\t\t\"?\",                /* 0x2000 */\n\t\t\t\"?\",                /* 0x4000 */\n\t\t\t\"MIRANDA\",          /* 0x8000 */\n\t\t\t\"CONSTRUCTOR\",      /* 0x10000 */\n\t\t\t\"DECLARED_SYNCHRONIZED\", /* 0x20000 */\n\t\t},\n\t\t{\n\t\t\t/* field */\n\t\t\t\"PUBLIC\",           /* 0x0001 */\n\t\t\t\"PRIVATE\",          /* 0x0002 */\n\t\t\t\"PROTECTED\",        /* 0x0004 */\n\t\t\t\"STATIC\",           /* 0x0008 */\n\t\t\t\"FINAL\",            /* 0x0010 */\n\t\t\t\"?\",                /* 0x0020 */\n\t\t\t\"VOLATILE\",         /* 0x0040 */\n\t\t\t\"TRANSIENT\",        /* 0x0080 */\n\t\t\t\"?\",                /* 0x0100 */\n\t\t\t\"?\",                /* 0x0200 */\n\t\t\t\"?\",                /* 0x0400 */\n\t\t\t\"?\",                /* 0x0800 */\n\t\t\t\"SYNTHETIC\",        /* 0x1000 */\n\t\t\t\"?\",                /* 0x2000 */\n\t\t\t\"ENUM\",             /* 0x4000 */\n\t\t\t\"?\",                /* 0x8000 */\n\t\t\t\"?\",                /* 0x10000 */\n\t\t\t\"?\",                /* 0x20000 */\n\t\t},\n\t};\n\tconst int kLongest = 21;\n\tint i, count;\n\tchar* str;\n\tchar* cp;\n\tcount = countOnes(flags);\n\t// XXX check if this allocation is safe what if all the arithmetic\n\t// produces a huge number????\n\tcp = str = (char*) malloc (count * (kLongest + 1) + 1);\n\tfor (i = 0; i < NUM_FLAGS; i++) {\n\t\tif (flags & 0x01) {\n\t\t\tconst char* accessStr = kAccessStrings[forWhat][i];\n\t\t\tint len = strlen(accessStr);\n\t\t\tif (cp != str) {\n\t\t\t\t*cp++ = ' ';\n\t\t\t}\n\t\t\tmemcpy(cp, accessStr, len);\n\t\t\tcp += len;\n\t\t}\n\t\tflags >>= 1;\n\t}\n\t*cp = '\\0';\n\treturn str;\n}\n\nstatic char *dex_type_descriptor(RBinDexObj *bin, int type_idx) {\n\tif (type_idx < 0 || type_idx >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\treturn getstr (bin, bin->types[type_idx].descriptor_id);\n}\n\nstatic char *dex_method_signature(RBinDexObj *bin, int method_idx) {\n\tut32 proto_id, params_off, type_id, list_size;\n\tchar *r, *return_type = NULL, *signature = NULL, *buff = NULL; \n\tut8 *bufptr;\n\tut16 type_idx;\n\tint pos = 0, i, size = 1;\n\n\tif (method_idx < 0 || method_idx >= bin->header.method_size) {\n\t\treturn NULL;\n\t}\n\tproto_id = bin->methods[method_idx].proto_id;\n\tif (proto_id >= bin->header.prototypes_size) {\n\t\treturn NULL;\n\t}\n\tparams_off = bin->protos[proto_id].parameters_off;\n\tif (params_off  >= bin->size) {\n\t\treturn NULL;\n\t}\n\ttype_id = bin->protos[proto_id].return_type_id;\n\tif (type_id >= bin->header.types_size ) {\n\t\treturn NULL;\n\t}\n\treturn_type = getstr (bin, bin->types[type_id].descriptor_id);\n\tif (!return_type) {\n\t\treturn NULL;\n\t}\n\tif (!params_off) {\n\t\treturn r_str_newf (\"()%s\", return_type);;\n\t}\n\tbufptr = bin->b->buf;\n\t// size of the list, in entries\n\tlist_size = r_read_le32 (bufptr + params_off); \n\t//XXX again list_size is user controlled huge loop\n\tfor (i = 0; i < list_size; i++) {\n\t\tint buff_len = 0;\n\t\tif (params_off + 4 + (i * 2) >= bin->size) {\n\t\t\tbreak;\n\t\t}\n\t\ttype_idx = r_read_le16 (bufptr + params_off + 4 + (i * 2));\n\t\tif (type_idx < 0 ||\n\t\t    type_idx >=\n\t\t\t    bin->header.types_size || type_idx >= bin->size) {\n\t\t\tbreak;\n\t\t}\n\t\tbuff = getstr (bin, bin->types[type_idx].descriptor_id);\n\t\tif (!buff) {\n\t\t\tbreak;\n\t\t}\n\t\tbuff_len = strlen (buff);\n\t\tsize += buff_len + 1;\n\t\tsignature = realloc (signature, size);\n\t\tstrcpy (signature + pos, buff);\n\t\tpos += buff_len;\n\t\tsignature[pos] = '\\0';\n\t}\n\tr = r_str_newf (\"(%s)%s\", signature, return_type);\n\tfree (buff);\n\tfree (signature);\n\treturn r;\n}\n\nstatic RList *dex_method_signature2(RBinDexObj *bin, int method_idx) {\n\tut32 proto_id, params_off, list_size;\n\tchar *buff = NULL; \n\tut8 *bufptr;\n\tut16 type_idx;\n\tint i;\n\n\tRList *params = r_list_newf (free);\n\tif (!params) {\n\t\treturn NULL;\n\t}\n\tif (method_idx < 0 || method_idx >= bin->header.method_size) {\n\t\tgoto out_error;\n\t}\n\tproto_id = bin->methods[method_idx].proto_id;\n\tif (proto_id >= bin->header.prototypes_size) {\n\t\tgoto out_error;\n\t}\n\tparams_off = bin->protos[proto_id].parameters_off;\n\tif (params_off  >= bin->size) {\n\t\tgoto out_error;\n\t}\n\tif (!params_off) {\n\t\treturn params;\n\t}\n\tbufptr = bin->b->buf;\n\t// size of the list, in entries\n\tlist_size = r_read_le32 (bufptr + params_off); \n\t//XXX list_size tainted it may produce huge loop\n\tfor (i = 0; i < list_size; i++) {\n\t\tut64 of = params_off + 4 + (i * 2);\n\t\tif (of >= bin->size || of < params_off) {\n\t\t\tbreak;\n\t\t}\n\t\ttype_idx = r_read_le16 (bufptr + of);\n\t\tif (type_idx >= bin->header.types_size ||\n\t\t    type_idx > bin->size) {\n\t\t\tbreak;\n\t\t}\n\t\tbuff = getstr (bin, bin->types[type_idx].descriptor_id);\n\t\tif (!buff) {\n\t\t\tbreak;\n\t\t}\n\t\tr_list_append (params, buff);\n\t}\n\treturn params;\nout_error:\n\tr_list_free (params);\n\treturn NULL;\n}\n\n// TODO: fix this, now has more registers that it should\n// https://github.com/android/platform_dalvik/blob/0641c2b4836fae3ee8daf6c0af45c316c84d5aeb/libdex/DexDebugInfo.cpp#L312\n// https://github.com/android/platform_dalvik/blob/0641c2b4836fae3ee8daf6c0af45c316c84d5aeb/libdex/DexDebugInfo.cpp#L141\nstatic void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t  RBinDexClass *c, int MI, int MA, int paddr, int ins_size,\n\t\t\t\t  int insns_size, char *class_name, int regsz,\n\t\t\t\t  int debug_info_off) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tconst ut8 *p4 = r_buf_get_at (binfile->buf, debug_info_off, NULL);\n\tconst ut8 *p4_end = p4 + binfile->buf->length - debug_info_off;\n\tut64 line_start;\n\tut64 parameters_size;\n\tut64 param_type_idx;\n\tut16 argReg = regsz - ins_size;\n\tut64 source_file_idx = c->source_file;\n\tRList *params, *debug_positions, *emitted_debug_locals = NULL; \n\tbool keep = true;\n\tif (argReg >= regsz) {\n\t\t//return; // this return breaks tests\n\t}\n\tp4 = r_uleb128 (p4, p4_end - p4, &line_start);\n\tp4 = r_uleb128 (p4, p4_end - p4, &parameters_size);\n\t// TODO: check when we should use source_file\n\t// The state machine consists of five registers\n\tut32 address = 0;\n\tut32 line = line_start;\n\tif (!(debug_positions = r_list_newf ((RListFree)free))) {\n\t\treturn;\t\n\t}\n\tif (!(emitted_debug_locals = r_list_newf ((RListFree)free))) {\n\t\tr_list_free (debug_positions);\n\t\treturn;\n\t}\n\n\tstruct dex_debug_local_t debug_locals[regsz];\n\tmemset (debug_locals, 0, sizeof (struct dex_debug_local_t) * regsz);\n\tif (!(MA & 0x0008)) {\n\t\tdebug_locals[argReg].name = \"this\";\n\t\tdebug_locals[argReg].descriptor = r_str_newf(\"%s;\", class_name);\n\t\tdebug_locals[argReg].startAddress = 0;\n\t\tdebug_locals[argReg].signature = NULL;\n\t\tdebug_locals[argReg].live = true;\n\t\targReg++;\n\t}\n\tif (!(params = dex_method_signature2 (bin, MI))) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\treturn;\n\t}\n\n\tRListIter *iter = r_list_iterator (params);\n\tchar *name;\n\tchar *type;\n\tint reg;\n\n\tr_list_foreach (params, iter, type) {\n\t\tif ((argReg >= regsz) || !type || parameters_size <= 0) {\n\t\t\tr_list_free (debug_positions);\n\t\t\tr_list_free (params);\n\t\t\tr_list_free (emitted_debug_locals);\n\t\t\treturn;\n\t\t}\n\t\tp4 = r_uleb128 (p4, p4_end - p4, &param_type_idx); // read uleb128p1\n\t\tparam_type_idx -= 1;\n\t\tname = getstr (bin, param_type_idx);\n\t\treg = argReg;\n\t\tswitch (type[0]) {\n\t\tcase 'D':\n\t\tcase 'J':\n\t\t\targReg += 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\targReg += 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (name) {\n\t\t\tdebug_locals[reg].name = name;\n\t\t\tdebug_locals[reg].descriptor = type;\n\t\t\tdebug_locals[reg].signature = NULL;\n\t\t\tdebug_locals[reg].startAddress = address;\n\t\t\tdebug_locals[reg].live = true;\n\t\t}\n\t\t--parameters_size;\n\t}\n\n\tut8 opcode = *(p4++) & 0xff;\n\twhile (keep) {\n\t\tswitch (opcode) {\n\t\tcase 0x0: // DBG_END_SEQUENCE\n\t\t\tkeep = false;\n\t\t\tbreak;\n\t\tcase 0x1: // DBG_ADVANCE_PC\n\t\t\t{\n\t\t\tut64 addr_diff;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &addr_diff);\n\t\t\taddress += addr_diff;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x2: // DBG_ADVANCE_LINE\n\t\t\t{\n\t\t\tst64 line_diff = r_sleb128 (&p4, p4_end);\n\t\t\tline += line_diff;\n\t\t\t}\n\t\t\tbreak;\t\n\t\tcase 0x3: // DBG_START_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx); \n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx); \n\t\t\ttype_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = NULL;\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t//eprintf(\"DBG_START_LOCAL %x %x %x\\n\", register_num, name_idx, type_idx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x4: //DBG_START_LOCAL_EXTENDED\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tut64 sig_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx);\n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx);\n\t\t\ttype_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &sig_idx);\n\t\t\tsig_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = getstr (bin, sig_idx);\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x5: // DBG_END_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].live = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x6: // DBG_RESTART_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tif (!debug_locals[register_num].live) {\n\t\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x7: //DBG_SET_PROLOGUE_END\n\t\t\tbreak;\n\t\tcase 0x8: //DBG_SET_PROLOGUE_BEGIN\n\t\t\tbreak;\n\t\tcase 0x9:\n\t\t\t{\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &source_file_idx);\n\t\t\tsource_file_idx--;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\tint adjusted_opcode = opcode - 0x0a;\n\t\t\taddress += (adjusted_opcode / 15);\n\t\t\tline += -4 + (adjusted_opcode % 15);\n\t\t\tstruct dex_debug_position_t *position =\n\t\t\t\tmalloc (sizeof (struct dex_debug_position_t));\n\t\t\tif (!position) {\n\t\t\t\tkeep = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tposition->source_file_idx = source_file_idx;\n\t\t\tposition->address = address;\n\t\t\tposition->line = line;\n\t\t\tr_list_append (debug_positions, position);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\topcode = *(p4++) & 0xff;\n\t}\n\n\tif (!binfile->sdb_addrinfo) {\n\t\tbinfile->sdb_addrinfo = sdb_new0 ();\n\t}\n\n\tchar *fileline;\n\tchar offset[64];\n\tchar *offset_ptr;\n\n\tRListIter *iter1;\n\tstruct dex_debug_position_t *pos;\n\tr_list_foreach (debug_positions, iter1, pos) {\n\t\tfileline = r_str_newf (\"%s|%\"PFMT64d, getstr (bin, pos->source_file_idx), pos->line);\n\t\toffset_ptr = sdb_itoa (pos->address + paddr, offset, 16);\n\t\tsdb_set (binfile->sdb_addrinfo, offset_ptr, fileline, 0);\n\t\tsdb_set (binfile->sdb_addrinfo, fileline, offset_ptr, 0);\n\t}\n\n\tif (!dexdump) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\tr_list_free (params);\n\t\treturn;\n\t}\n\n\tRListIter *iter2;\n\tstruct dex_debug_position_t *position;\n\n\trbin->cb_printf (\"      positions     :\\n\");\n\tr_list_foreach (debug_positions, iter2, position) {\n\t\trbin->cb_printf (\"        0x%04llx line=%llu\\n\",\n\t\t\t\t position->address, position->line);\n\t}\n\n\trbin->cb_printf (\"      locals        :\\n\");\n\n\tRListIter *iter3;\n\tstruct dex_debug_local_t *local;\n\tr_list_foreach (emitted_debug_locals, iter3, local) {\n\t\tif (local->signature) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor,\n\t\t\t\tlocal->signature);\n\t\t} else {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor);\n\t\t}\n\t}\n\n\tfor (reg = 0; reg < regsz; reg++) {\n\t\tif (debug_locals[reg].live) {\n\t\t\tif (debug_locals[reg].signature) {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s \"\n\t\t\t\t\t\"%s\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor,\n\t\t\t\t\tdebug_locals[reg].signature);\n\t\t\t} else {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\"\n\t\t\t\t\t\"\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor);\n\t\t\t}\n\t\t}\n\t}\n\tr_list_free (debug_positions);\n\tr_list_free (emitted_debug_locals);\n\tr_list_free (params);\n}\n\nstatic int check (RBinFile *arch);\nstatic int check_bytes (const ut8 *buf, ut64 length);\n\nstatic Sdb *get_sdb (RBinObject *o) {\n\tif (!o || !o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tstruct r_bin_dex_obj_t *bin = (struct r_bin_dex_obj_t *) o->bin_obj;\n\tif (bin->kv) {\n\t\treturn bin->kv;\n\t}\n\treturn NULL;\n}\n\nstatic void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){\n\tvoid *res = NULL;\n\tRBuffer *tbuf = NULL;\n\tif (!buf || !sz || sz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\ttbuf = r_buf_new ();\n\tif (!tbuf) {\n\t\treturn NULL;\n\t}\t\t \n\tr_buf_set_bytes (tbuf, buf, sz);\n\tres = r_bin_dex_new_buf (tbuf);\n\tr_buf_free (tbuf);\n\treturn res;\n}\n\nstatic int load(RBinFile *arch) {\n\tconst ut8 *bytes = arch ? r_buf_buffer (arch->buf) : NULL;\n\tut64 sz = arch ? r_buf_size (arch->buf): 0;\n\n\tif (!arch || !arch->o) {\n\t\treturn false;\n\t}\n\tarch->o->bin_obj = load_bytes (arch, bytes, sz, arch->o->loadaddr, arch->sdb);\n\treturn arch->o->bin_obj ? true: false;\n}\n\nstatic ut64 baddr(RBinFile *arch) {\n\treturn 0;\n}\n\nstatic int check(RBinFile *arch) {\n\tconst ut8 *bytes = arch ? r_buf_buffer (arch->buf) : NULL;\n\tut64 sz = arch ? r_buf_size (arch->buf): 0;\n\treturn check_bytes (bytes, sz);\n}\n\nstatic int check_bytes(const ut8 *buf, ut64 length) {\n\tif (!buf || length < 8) {\n\t\treturn false;\n\t}\n\t// Non-extended opcode dex file\n\tif (!memcmp (buf, \"dex\\n035\\0\", 8)) {\n\t\treturn true;\n\t}\n\t// Extended (jumnbo) opcode dex file, ICS+ only (sdk level 14+)\n\tif (!memcmp (buf, \"dex\\n036\\0\", 8)) {\n\t\treturn true;\n\t}\n\t// M3 (Nov-Dec 07)\n\tif (!memcmp (buf, \"dex\\n009\\0\", 8)) {\n\t\treturn true;\n\t}\n\t// M5 (Feb-Mar 08)\n\tif (!memcmp (buf, \"dex\\n009\\0\", 8)) {\n\t\treturn true;\n\t}\n\t// Default fall through, should still be a dex file\n\tif (!memcmp (buf, \"dex\\n\", 4)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic RBinInfo *info(RBinFile *arch) {\n\tRBinHash *h;\n\tRBinInfo *ret = R_NEW0 (RBinInfo);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->file = arch->file? strdup (arch->file): NULL;\n\tret->type = strdup (\"DEX CLASS\");\n\tret->has_va = false;\n\tret->bclass = r_bin_dex_get_version (arch->o->bin_obj);\n\tret->rclass = strdup (\"class\");\n\tret->os = strdup (\"linux\");\n\tret->subsystem = strdup (\"any\");\n\tret->machine = strdup (\"Dalvik VM\");\n\th = &ret->sum[0];\n\th->type = \"sha1\";\n\th->len = 20;\n\th->addr = 12;\n\th->from = 12;\n\th->to = arch->buf->length-32;\n\tmemcpy (h->buf, arch->buf->buf+12, 20);\n\th = &ret->sum[1];\n\th->type = \"adler32\";\n\th->len = 4;\n\th->addr = 0x8;\n\th->from = 12;\n\th->to = arch->buf->length-h->from;\n\th = &ret->sum[2];\n\th->type = 0;\n\tmemcpy (h->buf, arch->buf->buf + 8, 4);\n\t{\n\t\tut32 *fc = (ut32 *)(arch->buf->buf + 8);\n\t\tut32  cc = __adler32 (arch->buf->buf + 12, arch->buf->length - 12);\n\t\tif (*fc != cc) {\n\t\t\teprintf (\"# adler32 checksum doesn't match. Type this to fix it:\\n\");\n\t\t\teprintf (\"wx `#sha1 $s-32 @32` @12 ; wx `#adler32 $s-12 @12` @8\\n\");\n\t\t}\n\t}\n\tret->arch = strdup (\"dalvik\");\n\tret->lang = \"dalvik\";\n\tret->bits = 32;\n\tret->big_endian = 0;\n\tret->dbg_info = 0; //1 | 4 | 8; /* Stripped | LineNums | Syms */\n\treturn ret;\n}\n\nstatic RList *strings(RBinFile *arch) {\n\tstruct r_bin_dex_obj_t *bin = NULL;\n\tRBinString *ptr = NULL;\n\tRList *ret = NULL;\n\tint i, len;\n\tut8 buf[6];\n\tut64 off;\n\tif (!arch || !arch->o) {\n\t\treturn NULL;\n\t}\n\tbin = (struct r_bin_dex_obj_t *) arch->o->bin_obj;\n\tif (!bin || !bin->strings) {\n\t\treturn NULL;\n\t}\n\tif (bin->header.strings_size > bin->size) {\n\t\tbin->strings = NULL;\n\t\treturn NULL;\n\t}\n\tif (!(ret = r_list_newf (free))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < bin->header.strings_size; i++) {\n\t\tif (!(ptr = R_NEW0 (RBinString))) {\n\t\t\tbreak;\n\t\t}\n\t\tif (bin->strings[i] > bin->size || bin->strings[i] + 6 > bin->size) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tr_buf_read_at (bin->b, bin->strings[i], (ut8*)&buf, 6);\n\t\tlen = dex_read_uleb128 (buf);\n\n\t\tif (len > 1 && len < R_BIN_SIZEOF_STRINGS) {\n\t\t\tptr->string = malloc (len + 1);\n\t\t\tif (!ptr->string) {\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\toff = bin->strings[i] + dex_uleb128_len (buf);\n\t\t\tif (off + len >= bin->size || off + len < len) {\n\t\t\t\tfree (ptr->string);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tr_buf_read_at (bin->b, off, (ut8*)ptr->string, len);\n\t\t\tptr->string[len] = 0;\n\t\t\tptr->vaddr = ptr->paddr = bin->strings[i];\n\t\t\tptr->size = len;\n\t\t\tptr->length = len;\n\t\t\tptr->ordinal = i+1;\n\t\t\tr_list_append (ret, ptr);\n\t\t} else {\n\t\t\tfree (ptr);\n\t\t}\n\t}\n\treturn ret;\nout_error:\n\tr_list_free (ret);\n\tfree (ptr);\n\treturn NULL;\n}\n\nstatic char *dex_method_name(RBinDexObj *bin, int idx) {\n\tif (idx < 0 || idx >= bin->header.method_size) {\n\t\treturn NULL;\n\t}\n\tint cid = bin->methods[idx].class_id;\n\tif (cid < 0 || cid >= bin->header.strings_size) {\n\t\treturn NULL;\n\t}\n\tint tid = bin->methods[idx].name_id;\n\tif (tid < 0 || tid >= bin->header.strings_size) {\n\t\treturn NULL;\n\t}\n\treturn getstr (bin, tid);\n}\n\nstatic char *dex_class_name_byid(RBinDexObj *bin, int cid) {\n\tint tid;\n\tif (!bin || !bin->types) {\n\t\treturn NULL;\n\t}\n\tif (cid < 0 || cid >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\ttid = bin->types[cid].descriptor_id;\n\treturn getstr (bin, tid);\n}\n\nstatic char *dex_class_name(RBinDexObj *bin, RBinDexClass *c) {\n\treturn dex_class_name_byid (bin, c->class_id);\n}\n\nstatic char *dex_field_name(RBinDexObj *bin, int fid) {\n\tint cid, tid, type_id;\n\tif (!bin || !bin->fields) {\n\t\treturn NULL;\n\t}\n\tif (fid < 0 || fid >= bin->header.fields_size) {\n\t\treturn NULL;\n\t}\n\tcid = bin->fields[fid].class_id;\n\tif (cid < 0 || cid >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\ttype_id = bin->fields[fid].type_id;\n\tif (type_id < 0 || type_id >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\ttid = bin->fields[fid].name_id;\n\treturn r_str_newf (\"%s->%s %s\", getstr (bin, bin->types[cid].descriptor_id),\n\t\tgetstr (bin, tid), getstr (bin, bin->types[type_id].descriptor_id));\n}\n\nstatic char *dex_method_fullname(RBinDexObj *bin, int method_idx) {\n\tif (!bin || !bin->types) {\n\t\treturn NULL;\n\t}\n\tif (method_idx < 0 || method_idx >= bin->header.method_size) {\n\t\treturn NULL;\n\t}\n\tint cid = bin->methods[method_idx].class_id;\n\tif (cid < 0 || cid >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\tchar *name = dex_method_name (bin, method_idx);\n\tchar *class_name = dex_class_name_byid (bin, cid);\n\tclass_name = r_str_replace (class_name, \";\", \"\", 0); //TODO: move to func\n\tchar *signature = dex_method_signature (bin, method_idx);\n\tchar *flagname = r_str_newf (\"%s.%s%s\", class_name, name, signature);\n\tfree (name);\n\tfree (class_name);\n\tfree (signature);\n\treturn flagname;\n}\n\nstatic ut64 dex_get_type_offset(RBinFile *arch, int type_idx) {\n\tRBinDexObj *bin = (RBinDexObj*) arch->o->bin_obj;\n\tif (!bin || !bin->types) {\n\t\treturn 0;\n\t}\n\tif (type_idx < 0 || type_idx >= bin->header.types_size) {\n\t\treturn 0;\n\t}\n\treturn bin->header.types_offset + type_idx * 0x04; //&bin->types[type_idx];\n}\n\nstatic void __r_bin_class_free(RBinClass *p) {\n\tr_list_free (p->methods);\n\tr_list_free (p->fields);\n\tr_bin_class_free (p);\n}\n\nstatic char *dex_class_super_name(RBinDexObj *bin, RBinDexClass *c) {\n\tint cid, tid;\n\tif (!bin || !c || !bin->types) {\n\t\treturn NULL;\n\t}\n\tcid = c->super_class;\n\tif (cid < 0 || cid >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\ttid = bin->types[cid].descriptor_id;\n\treturn getstr (bin, tid);\n}\n\nstatic const ut8 *parse_dex_class_fields(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t\t  RBinDexClass *c, RBinClass *cls,\n\t\t\t\t\t  const ut8 *p, const ut8 *p_end,\n\t\t\t\t\t  int *sym_count, ut64 fields_count,\n\t\t\t\t\t  bool is_sfield) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tut64 lastIndex = 0;\n\tut8 ff[sizeof (DexField)] = {0};\n\tint total, i, tid;\n\tDexField field;\n\tconst char* type_str;\n\tfor (i = 0; i < fields_count; i++) {\n\t\tut64 fieldIndex, accessFlags;\n\t\t\n\t\tp = r_uleb128 (p, p_end - p, &fieldIndex); // fieldIndex\n\t\tp = r_uleb128 (p, p_end - p, &accessFlags); // accessFlags\n\t\tfieldIndex += lastIndex;\n\t\ttotal = bin->header.fields_offset + (sizeof (DexField) * fieldIndex);\n\t\tif (total >= bin->size || total < bin->header.fields_offset) {\n\t\t\tbreak;\t\n\t\t}\n\t\tif (r_buf_read_at (binfile->buf, total, ff,\n\t\t\t\tsizeof (DexField)) != sizeof (DexField)) {\n\t\t\tbreak;\n\t\t}\n\t\tfield.class_id = r_read_le16 (ff);\n\t\tfield.type_id = r_read_le16 (ff + 2);\n\t\tfield.name_id = r_read_le32 (ff + 4);\n\t\tchar *fieldName = getstr (bin, field.name_id);\n\t\tif (field.type_id >= bin->header.types_size) {\n\t\t\tbreak;\n\t\t}\n\t\ttid = bin->types[field.type_id].descriptor_id;\n\t\ttype_str = getstr (bin, tid);\n\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\tif (is_sfield) {\n\t\t\tsym->name = r_str_newf (\"%s.sfield_%s:%s\", cls->name,\n\t\t\t\t\t\tfieldName, type_str);\n\t\t\tsym->type = r_str_const (\"STATIC\");\n\t\t} else {\n\t\t\tsym->name = r_str_newf (\"%s.ifield_%s:%s\", cls->name,\n\t\t\t\t\t\tfieldName, type_str);\n\t\t\tsym->type = r_str_const (\"FIELD\");\n\t\t}\n\t\tsym->name = r_str_replace (sym->name, \"method.\", \"\", 0);\n\t\t//sym->name = r_str_replace (sym->name, \";\", \"\", 0);\n\t\tsym->paddr = sym->vaddr = total;\n\t\tsym->ordinal = (*sym_count)++;\n\t\t\n\t\tif (dexdump) {\n\t\t\tconst char *accessStr = createAccessFlagStr (\n\t\t\t\taccessFlags, kAccessForField);\n\t\t\trbin->cb_printf (\"    #%d              : (in %s;)\\n\", i,\n\t\t\t\t\t cls->name);\n\t\t\trbin->cb_printf (\"      name          : '%s'\\n\", fieldName);\n\t\t\trbin->cb_printf (\"      type          : '%s'\\n\", type_str);\n\t\t\trbin->cb_printf (\"      access        : 0x%04x (%s)\\n\",\n\t\t\t\t\t (unsigned int)accessFlags, accessStr);\n\t\t}\n\n\t\tr_list_append (bin->methods_list, sym);\n\t\tr_list_append (cls->fields, sym);\n\n\t\tlastIndex = fieldIndex;\n\t}\n\treturn p;\n}\n\n// TODO: refactor this method\n// XXX it needs a lot of love!!!\nstatic const ut8 *parse_dex_class_method(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t\t  RBinDexClass *c, RBinClass *cls,\n\t\t\t\t\t  const ut8 *p, const ut8 *p_end,\n\t\t\t\t\t  int *sym_count, ut64 DM, int *methods,\n\t\t\t\t\t  bool is_direct) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tut8 ff2[16] = {0};\n\tut8 ff3[8] = {0};\n\tint i;\n\tut64 omi = 0;\n\tbool catchAll;\n\tut16 regsz, ins_size, outs_size, tries_size;\n\tut16 handler_off, start_addr, insn_count;\n\tut32 debug_info_off, insns_size;\n\tconst ut8 *encoded_method_addr;\n\tfor (i = 0; i < DM; i++) {\n\t\tencoded_method_addr = p;\n\t\tchar *method_name, *flag_name;\n\t\tut64 MI, MA, MC;\n\t\tp = r_uleb128 (p, p_end - p, &MI);\n\t\tMI += omi;\n\t\tomi = MI;\n\t\tp = r_uleb128 (p, p_end - p, &MA);\n\t\tp = r_uleb128 (p, p_end - p, &MC);\n\t\t// TODO: MOVE CHECKS OUTSIDE!\n\t\tif (MI < bin->header.method_size) {\n\t\t\tif (methods) {\n\t\t\t\tmethods[MI] = 1;\n\t\t\t}\n\t\t}\n\t\tmethod_name = dex_method_name (bin, MI);\n\t\tchar *signature = dex_method_signature (bin, MI);\n\t\tif (!method_name) {\n\t\t\tmethod_name = strdup (\"unknown\");\n\t\t}\n\t\tflag_name = r_str_newf (\"%s.method.%s%s\", cls->name,\n\t\t\t\t\tmethod_name, signature);\n\t\tif (!flag_name) {\n\t\t\tR_FREE (method_name);\n\t\t\tR_FREE (signature);\n\t\t\tcontinue;\n\t\t}\n\t\t// TODO: check size\n\t\t// ut64 prolog_size = 2 + 2 + 2 + 2 + 4 + 4;\n\t\tut64 v2, handler_type, handler_addr;\n\t\tint t;\n\t\tif (MC > 0) { \n\t\t\t// TODO: parse debug info\n\t\t\t// XXX why binfile->buf->base???\n\t\t\tif (MC + 16 >= bin->size || MC + 16 < MC) {\n\t\t\t\tR_FREE (method_name);\n\t\t\t\tR_FREE (flag_name);\n\t\t\t\tR_FREE (signature);\n\t\t\t\tcontinue;\n\t\t\t}\t\n\t\t\tif (r_buf_read_at (binfile->buf,\n\t\t\t\t\t   binfile->buf->base + MC, ff2,\n\t\t\t\t\t   16) < 1) {\n\t\t\t\tR_FREE (method_name);\n\t\t\t\tR_FREE (flag_name);\n\t\t\t\tR_FREE (signature);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tregsz = r_read_le16 (ff2);\n\t\t\tins_size = r_read_le16 (ff2 + 2);\n\t\t\touts_size = r_read_le16 (ff2 + 4);\n\t\t\ttries_size = r_read_le16 (ff2 + 6);\n\t\t\tdebug_info_off = r_read_le32 (ff2 + 8);\n\t\t\tinsns_size = r_read_le32 (ff2 + 12);\n\t\t\tint padd = 0;\n\t\t\tif (tries_size > 0 && insns_size % 2) {\n\t\t\t\tpadd = 2;\n\t\t\t}\n\t\t\tt = 16 + 2 * insns_size + padd;\n\t\t}\n\t\tif (dexdump) {\n\t\t\tconst char* accessStr = createAccessFlagStr (MA, kAccessForMethod);\n\t\t\trbin->cb_printf (\"    #%d              : (in %s;)\\n\", i, cls->name);\n\t\t\trbin->cb_printf (\"      name          : '%s'\\n\", method_name);\n\t\t\trbin->cb_printf (\"      type          : '%s'\\n\", signature);\n\t\t\trbin->cb_printf (\"      access        : 0x%04x (%s)\\n\",\n\t\t\t\t\t (unsigned int)MA, accessStr);\n\t\t}\n\n\t\tif (MC > 0) {\n\t\t\tif (dexdump) {\n\t\t\t\trbin->cb_printf (\"      code          -\\n\");\n\t\t\t\trbin->cb_printf (\"      registers     : %d\\n\", regsz);\n\t\t\t\trbin->cb_printf (\"      ins           : %d\\n\", ins_size);\n\t\t\t\trbin->cb_printf (\"      outs          : %d\\n\", outs_size);\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"      insns size    : %d 16-bit code \"\n\t\t\t\t\t\"units\\n\",\n\t\t\t\t\tinsns_size);\n\t\t\t}\n\t\t\tif (tries_size > 0) {\n\t\t\t\tif (dexdump) {\n\t\t\t\t\trbin->cb_printf (\"      catches       : %d\\n\", tries_size);\n\t\t\t\t}\n\t\t\t\tint j, m = 0;\n\t\t\t\t//XXX bucle controlled by tainted variable it could produces huge loop\n\t\t\t\tfor (j = 0; j < tries_size; ++j) {\n\t\t\t\t\tut64 offset = MC + t + j * 8;\n\t\t\t\t\tif (offset >= bin->size || offset < MC) {\n\t\t\t\t\t\tR_FREE (signature);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (r_buf_read_at (\n\t\t\t\t\t\t    binfile->buf,\n\t\t\t\t\t\t    binfile->buf->base + offset,\n\t\t\t\t\t\t    ff3, 8) < 1) {\n\t\t\t\t\t\t// free (method_name);\n\t\t\t\t\t\tR_FREE (signature);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstart_addr = r_read_le32 (ff3);\n\t\t\t\t\tinsn_count = r_read_le16 (ff3 + 4);\n\t\t\t\t\thandler_off = r_read_le16 (ff3 + 6);\n\t\t\t\t\tchar* s = NULL;\n\t\t\t\t\tif (dexdump) {\n\t\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\t\"        0x%04x - \"\n\t\t\t\t\t\t\t\"0x%04x\\n\",\n\t\t\t\t\t\t\tstart_addr,\n\t\t\t\t\t\t\t(start_addr +\n\t\t\t\t\t\t\t insn_count));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconst ut8 *p3, *p3_end;\n\t\t\t\t\t//XXX tries_size is tainted and oob here\n\t\t\t\t\tint off = MC + t + tries_size * 8 + handler_off;\n\t\t\t\t\tif (off >= bin->size || off < tries_size) {\n\t\t\t\t\t\tR_FREE (signature);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp3 = r_buf_get_at (binfile->buf, off, NULL);\n\t\t\t\t\tp3_end = p3 + binfile->buf->length - off;\n\t\t\t\t\tst64 size = r_sleb128 (&p3, p3_end);\n\n\t\t\t\t\tif (size <= 0) {\n\t\t\t\t\t\tcatchAll = true;\n\t\t\t\t\t\tsize = -size;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcatchAll = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (m = 0; m < size; m++) {\n\t\t\t\t\t\tp3 = r_uleb128 (p3, p3_end - p3, &handler_type);\n\t\t\t\t\t\tp3 = r_uleb128 (p3, p3_end - p3, &handler_addr);\n\n\t\t\t\t\t\tif (handler_type > 0 &&\n\t\t\t\t\t\t    handler_type <\n\t\t\t\t\t\t\t    bin->header.types_size) {\n\t\t\t\t\t\t\ts = getstr (bin, bin->types[handler_type].descriptor_id);\n\t\t\t\t\t\t\tif (dexdump) {\n\t\t\t\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\t\t\t\"          %s \"\n\t\t\t\t\t\t\t\t\t\"-> 0x%04llx\\n\",\n\t\t\t\t\t\t\t\t\ts,\n\t\t\t\t\t\t\t\t\thandler_addr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (dexdump) {\n\t\t\t\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\t\t\t\"          \"\n\t\t\t\t\t\t\t\t\t\"(error) -> \"\n\t\t\t\t\t\t\t\t\t\"0x%04llx\\n\",\n\t\t\t\t\t\t\t\t\thandler_addr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (catchAll) {\n\t\t\t\t\t\tp3 = r_uleb128 (p3, p3_end - p3, &v2);\n\t\t\t\t\t\tif (dexdump) {\n\t\t\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\t\t\"          \"\n\t\t\t\t\t\t\t\t\"<any> -> \"\n\t\t\t\t\t\t\t\t\"0x%04llx\\n\",\n\t\t\t\t\t\t\t\tv2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dexdump) {\n\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\"      catches       : \"\n\t\t\t\t\t\t\"(none)\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (dexdump) {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"      code          : (none)\\n\");\n\t\t\t}\n\t\t}\n\t\tif (*flag_name) {\n\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\tsym->name = flag_name;\n\t\t\t// is_direct is no longer used\n\t\t\t// if method has code *addr points to code\n\t\t\t// otherwise it points to the encoded method\n\t\t\tif (MC > 0) { \n\t\t\t\tsym->type = r_str_const (\"FUNC\");\n\t\t\t\tsym->paddr = MC;// + 0x10;\n\t\t\t\tsym->vaddr = MC;// + 0x10;\n\t\t\t} else {\n\t\t\t\tsym->type = r_str_const (\"METH\");\n\t\t\t\tsym->paddr = encoded_method_addr - binfile->buf->buf;\n\t\t\t\tsym->vaddr = encoded_method_addr - binfile->buf->buf;\n\t\t\t}\n\t\t\tif ((MA & 0x1) == 0x1) {\n\t\t\t\tsym->bind = r_str_const (\"GLOBAL\");\n\t\t\t} else {\n\t\t\t\tsym->bind = r_str_const (\"LOCAL\");\n\t\t\t}\n\t\t\tsym->ordinal = (*sym_count)++;\n\t\t\tif (MC > 0) {\n\t\t\t\tif (r_buf_read_at (binfile->buf, binfile->buf->base + MC, ff2, 16) < 1) {\n\t\t\t\t\tR_FREE (sym);\n\t\t\t\t\tR_FREE (signature);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//ut16 regsz = r_read_le16 (ff2);\n\t\t\t\t//ut16 ins_size = r_read_le16 (ff2 + 2);\n\t\t\t\t//ut16 outs_size = r_read_le16 (ff2 + 4);\n\t\t\t\tut16 tries_size = r_read_le16 (ff2 + 6);\n\t\t\t\t//ut32 debug_info_off = r_read_le32 (ff2 + 8);\n\t\t\t\tut32 insns_size = r_read_le32 (ff2 + 12);\n\t\t\t\tut64 prolog_size = 2 + 2 + 2 + 2 + 4 + 4;\n\t\t\t\tif (tries_size > 0) {\n\t\t\t\t\t//prolog_size += 2 + 8*tries_size; // we need to parse all so the catch info...\n\t\t\t\t}\n\t\t\t\t// TODO: prolog_size\n\t\t\t\tsym->paddr = MC + prolog_size;// + 0x10;\n\t\t\t\tsym->vaddr = MC + prolog_size;// + 0x10;\n\t\t\t\t//if (is_direct) {\n\t\t\t\tsym->size = insns_size * 2;\n\t\t\t\t//}\n\t\t\t\t//eprintf(\"%s (0x%x-0x%x) size=%d\\nregsz=%d\\ninsns_size=%d\\nouts_size=%d\\ntries_size=%d\\ninsns_size=%d\\n\", flag_name, sym->vaddr, sym->vaddr+sym->size, prolog_size, regsz, ins_size, outs_size, tries_size, insns_size);\n\t\t\t\tr_list_append (bin->methods_list, sym);\n\t\t\t\tr_list_append (cls->methods, sym);\n\n\t\t\t\tif (bin->code_from > sym->paddr) {\n\t\t\t\t\tbin->code_from = sym->paddr;\n\t\t\t\t}\n\t\t\t\tif (bin->code_to < sym->paddr) {\n\t\t\t\t\tbin->code_to = sym->paddr;\n\t\t\t\t}\n\n\t\t\t\tif (!mdb) {\n\t\t\t\t\tmdb = sdb_new0 ();\n\t\t\t\t}\n\t\t\t\tsdb_num_set (mdb, sdb_fmt (0, \"method.%d\", MI), sym->paddr, 0);\n\t\t\t\t// -----------------\n\t\t\t\t// WORK IN PROGRESS\n\t\t\t\t// -----------------\n\t\t\t\tif (0) {\n\t\t\t\t\tif (MA & 0x10000) { //ACC_CONSTRUCTOR\n\t\t\t\t\t\tif (!cdb) {\n\t\t\t\t\t\t\tcdb = sdb_new0 ();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsdb_num_set (cdb, sdb_fmt (0, \"%d\", c->class_id), sym->paddr, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsym->size = 0;\n\t\t\t\tr_list_append (bin->methods_list, sym);\n\t\t\t\tr_list_append (cls->methods, sym);\n\t\t\t}\n\t\t\tif (MC > 0 && debug_info_off > 0 && bin->header.data_offset < debug_info_off &&\n\t\t\t\tdebug_info_off < bin->header.data_offset + bin->header.data_size) {\n\t\t\t\tdex_parse_debug_item (binfile, bin, c, MI, MA, sym->paddr, ins_size, \n\t\t\t\t\tinsns_size, cls->name, regsz, debug_info_off);\n\t\t\t} else if (MC > 0) {\n\t\t\t\tif (dexdump) {\n\t\t\t\t\trbin->cb_printf (\"      positions     :\\n\");\n\t\t\t\t\trbin->cb_printf (\"      locals        :\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tR_FREE (flag_name);\n\t\t}\n\t\tR_FREE (signature);\n\t\tR_FREE (method_name);\n\t}\n\treturn p;\n}\n\nstatic void parse_class(RBinFile *binfile, RBinDexObj *bin, RBinDexClass *c,\n\t\t\t int class_index, int *methods, int *sym_count) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\n\tchar *class_name;\n\tint z;\n\tconst ut8 *p, *p_end;\n\n\tif (!c) {\n\t\treturn;\n\t}\n\n\tclass_name = dex_class_name (bin, c);\n\tclass_name = r_str_replace (class_name, \";\", \"\", 0); //TODO: move to func\n\n\tif (!class_name || !*class_name) {\n\t\treturn;\n\t}\n\n\tRBinClass *cls = R_NEW0 (RBinClass);\n\tif (!cls) {\n\t\treturn;\n\t}\n\tcls->name = class_name;\n\tcls->index = class_index;\n\tcls->addr = bin->header.class_offset + class_index * DEX_CLASS_SIZE;\n\tcls->methods = r_list_new ();\n\tif (!cls->methods) {\n\t\tfree (cls);\n\t\treturn;\n\t}\n\tcls->fields = r_list_new ();\n\tif (!cls->fields) {\n\t\tr_list_free (cls->methods);\n\t\tfree (cls);\n\t\treturn;\n\t}\n\tr_list_append (bin->classes_list, cls);\n\tif (dexdump) {\n\t\trbin->cb_printf (\"  Class descriptor  : '%s;'\\n\", class_name);\n\t\trbin->cb_printf (\n\t\t\t\"  Access flags      : 0x%04x (%s)\\n\", c->access_flags,\n\t\t\tcreateAccessFlagStr (c->access_flags, kAccessForClass));\n\t\trbin->cb_printf (\"  Superclass        : '%s'\\n\",\n\t\t\t\t dex_class_super_name (bin, c));\n\t\trbin->cb_printf (\"  Interfaces        -\\n\");\n\t}\n\n\tif (c->interfaces_offset > 0 &&\n\t    bin->header.data_offset < c->interfaces_offset &&\n\t    c->interfaces_offset <\n\t\t    bin->header.data_offset + bin->header.data_size) {\n\t\tp = r_buf_get_at (binfile->buf, c->interfaces_offset, NULL);\n\t\tint types_list_size = r_read_le32 (p);\n\t\tif (types_list_size < 0 || types_list_size >= bin->header.types_size ) {\n\t\t\treturn;\n\t\t}\n\t\tfor (z = 0; z < types_list_size; z++) {\n\t\t\tint t = r_read_le16 (p + 4 + z * 2);\n\t\t\tif (t > 0 && t < bin->header.types_size ) {\n\t\t\t\tint tid = bin->types[t].descriptor_id;\n\t\t\t\tif (dexdump) {\n\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\"    #%d              : '%s'\\n\",\n\t\t\t\t\t\tz, getstr (bin, tid));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: this is quite ugly\n\tif (!c || !c->class_data_offset) {\n\t\tif (dexdump) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"  Static fields     -\\n  Instance fields   \"\n\t\t\t\t\"-\\n  Direct methods    -\\n  Virtual methods   \"\n\t\t\t\t\"-\\n\");\n\t\t}\n\t} else {\n\t\t// TODO: move to func, def or inline\n\t\t// class_data_offset => [class_offset, class_defs_off+class_defs_size*32]\n\t\tif (bin->header.class_offset > c->class_data_offset ||\n\t\t    c->class_data_offset <\n\t\t\t    bin->header.class_offset +\n\t\t\t\t    bin->header.class_size * DEX_CLASS_SIZE) {\n\t\t\treturn;\n\t\t}\n\n\t\tp = r_buf_get_at (binfile->buf, c->class_data_offset, NULL);\n\t\tp_end = p + binfile->buf->length - c->class_data_offset;\n\t\t//XXX check for NULL!!\n\t\tc->class_data = (struct dex_class_data_item_t *)malloc (\n\t\t\tsizeof (struct dex_class_data_item_t));\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->static_fields_size);\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->instance_fields_size);\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->direct_methods_size);\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->virtual_methods_size);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Static fields     -\\n\"); \n\t\t}\n\t\tp = parse_dex_class_fields (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->static_fields_size, true);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Instance fields   -\\n\");\n\t\t}\n\t\tp = parse_dex_class_fields (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->instance_fields_size, false);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Direct methods    -\\n\");\n\t\t}\n\t\tp = parse_dex_class_method (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->direct_methods_size, methods, true);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Virtual methods   -\\n\");\n\t\t}\n\t\tp = parse_dex_class_method (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->virtual_methods_size, methods, false);\n\t}\n\n\tif (dexdump) { \n\t\tchar *source_file = getstr (bin, c->source_file);\n\t\tif (!source_file) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"  source_file_idx   : %d (unknown)\\n\\n\",\n\t\t\t\tc->source_file);\n\t\t} else {\n\t\t\trbin->cb_printf (\"  source_file_idx   : %d (%s)\\n\\n\",\n\t\t\t\t\t c->source_file, source_file);\n\t\t}\n\t}\n\t// TODO:!!!!\n\t// FIX: FREE BEFORE ALLOCATE!!!\n\t//free (class_name);\n}\n\nstatic bool is_class_idx_in_code_classes(RBinDexObj *bin, int class_idx) {\n\tint i;\n\tfor (i = 0; i < bin->header.class_size; i++) {\n\t\tif (class_idx == bin->classes[i].class_id) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int dex_loadcode(RBinFile *arch, RBinDexObj *bin) {\n\tstruct r_bin_t *rbin = arch->rbin;\n\tint i;\n\tint *methods = NULL;\n\tint sym_count = 0;\n\n\t// doublecheck??\n\tif (!bin || bin->methods_list) {\n\t\treturn false;\n\t}\n\tbin->code_from = UT64_MAX;\n\tbin->code_to = 0;\n\tbin->methods_list = r_list_newf ((RListFree)free);\n\tif (!bin->methods_list) {\n\t\treturn false;\n\t}\n\tbin->imports_list = r_list_newf ((RListFree)free);\n\tif (!bin->imports_list) {\n\t\tr_list_free (bin->methods_list);\n\t\treturn false;\n\t}\n\tbin->classes_list = r_list_newf ((RListFree)__r_bin_class_free);\n\tif (!bin->classes_list) {\n\t\tr_list_free (bin->methods_list);\n\t\tr_list_free (bin->imports_list);\n\t\treturn false;\n\t}\n\n\tif (bin->header.method_size>bin->size) {\n\t\tbin->header.method_size = 0;\n\t\treturn false;\n\t}\n\n\t/* WrapDown the header sizes to avoid huge allocations */\n\tbin->header.method_size = R_MIN (bin->header.method_size, bin->size);\n\tbin->header.class_size = R_MIN (bin->header.class_size, bin->size);\n\tbin->header.strings_size = R_MIN (bin->header.strings_size, bin->size);\n\n\t// TODO: is this posible after R_MIN ??\n\tif (bin->header.strings_size > bin->size) {\n\t\teprintf (\"Invalid strings size\\n\");\n\t\treturn false;\n\t}\n\n\tif (bin->classes) {\n\t\tut64 amount = sizeof (int) * bin->header.method_size;\n\t\tif (amount > UT32_MAX || amount < bin->header.method_size) {\n\t\t\treturn false;\n\t\t}\n\t\tmethods = calloc (1, amount + 1);\n\t\tfor (i = 0; i < bin->header.class_size; i++) {\n\t\t\tchar *super_name, *class_name;\n\t\t\tstruct dex_class_t *c = &bin->classes[i];\n\t\t\tclass_name = dex_class_name (bin, c);\n\t\t\tsuper_name = dex_class_super_name (bin, c);\n\t\t\tif (dexdump) { \n\t\t\t\trbin->cb_printf (\"Class #%d            -\\n\", i);\n\t\t\t}\n\t\t\tparse_class (arch, bin, c, i, methods, &sym_count);\n\t\t\tfree (class_name);\n\t\t\tfree (super_name);\n\t\t}\n\t}\n\n\tif (methods) {\n\t\tint import_count = 0;\n\t\tint sym_count = bin->methods_list->length;\n\n\t\tfor (i = 0; i < bin->header.method_size; i++) {\n\t\t\tint len = 0;\n\t\t\tif (methods[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (bin->methods[i].class_id > bin->header.types_size - 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (is_class_idx_in_code_classes(bin, bin->methods[i].class_id)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchar *class_name = getstr (\n\t\t\t\tbin, bin->types[bin->methods[i].class_id]\n\t\t\t\t\t\t.descriptor_id);\n\t\t\tif (!class_name) {\n\t\t\t\tfree (class_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlen = strlen (class_name);\n\t\t\tif (len < 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclass_name[len - 1] = 0; // remove last char \";\"\n\t\t\tchar *method_name = dex_method_name (bin, i);\n\t\t\tchar *signature = dex_method_signature (bin, i);\n\t\t\tif (method_name && *method_name) {\n\t\t\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\t\t\timp->name  = r_str_newf (\"%s.method.%s%s\", class_name, method_name, signature);\n\t\t\t\timp->type = r_str_const (\"FUNC\");\n\t\t\t\timp->bind = r_str_const (\"NONE\");\n\t\t\t\timp->ordinal = import_count++;\n\t\t\t\tr_list_append (bin->imports_list, imp);\n\n\t\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\t\tsym->name = r_str_newf (\"imp.%s\", imp->name);\n\t\t\t\tsym->type = r_str_const (\"FUNC\");\n\t\t\t\tsym->bind = r_str_const (\"NONE\");\n\t\t\t\t//XXX so damn unsafe check buffer boundaries!!!!\n\t\t\t\t//XXX use r_buf API!!\n\t\t\t\tsym->paddr = sym->vaddr = bin->b->base + bin->header.method_offset + (sizeof (struct dex_method_t) * i) ;\n\t\t\t\tsym->ordinal = sym_count++;\n\t\t\t\tr_list_append (bin->methods_list, sym);\n\t\t\t\tsdb_num_set (mdb, sdb_fmt (0, \"method.%d\", i), sym->paddr, 0);\n\t\t\t}\n\t\t\tfree (method_name);\n\t\t\tfree (signature);\n\t\t\tfree (class_name);\n\t\t}\n\t\tfree (methods);\n\t}\n\treturn true;\n}\n\nstatic RList* imports(RBinFile *arch) {\n\tRBinDexObj *bin = (RBinDexObj*) arch->o->bin_obj;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin && bin->imports_list) {\n\t\treturn bin->imports_list;\n\t}\n\tdex_loadcode (arch, bin);\n\treturn bin->imports_list;\n}\n\nstatic RList *methods(RBinFile *arch) {\n\tRBinDexObj *bin;\n\tif (!arch || !arch->o || !arch->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tbin = (RBinDexObj*) arch->o->bin_obj;\n\tif (!bin->methods_list) {\n\t\tdex_loadcode (arch, bin);\n\t}\n\treturn bin->methods_list;\n}\n\nstatic RList *classes(RBinFile *arch) {\n\tRBinDexObj *bin;\n\tif (!arch || !arch->o || !arch->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tbin = (RBinDexObj*) arch->o->bin_obj;\n\tif (!bin->classes_list) {\n\t\tdex_loadcode (arch, bin);\n\t}\n\treturn bin->classes_list;\n}\n\nstatic int already_entry(RList *entries, ut64 vaddr) {\n\tRBinAddr *e;\n\tRListIter *iter;\n\tr_list_foreach (entries, iter, e) {\n\t\tif (e->vaddr == vaddr) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic RList *entries(RBinFile *arch) {\n\tRListIter *iter;\n\tRBinDexObj *bin;\n\tRBinSymbol *m;\n\tRBinAddr *ptr;\n\tRList *ret;\n\n\tif (!arch || !arch->o || !arch->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tbin = (RBinDexObj*) arch->o->bin_obj;\n\tret = r_list_newf ((RListFree)free);\n\n\tif (!bin->methods_list) {\n\t\tdex_loadcode (arch, bin);\n\t}\n\n\t// STEP 1. \".onCreate(Landroid/os/Bundle;)V\"\n\tr_list_foreach (bin->methods_list, iter, m) {\n\t\tif (strlen (m->name) > 30 && m->bind && \n\t\t\t!strcmp(m->bind, \"GLOBAL\") &&\n\t\t    !strcmp (m->name + strlen (m->name) - 31,\n\t\t\t     \".onCreate(Landroid/os/Bundle;)V\")) {\n\t\t\tif (!already_entry (ret, m->paddr)) {\n\t\t\t\tif ((ptr = R_NEW0 (RBinAddr))) {\n\t\t\t\t\tptr->paddr = ptr->vaddr = m->paddr;\n\t\t\t\t\tr_list_append (ret, ptr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// STEP 2. \".main([Ljava/lang/String;)V\"\n\tif (r_list_empty (ret)) {\n\t\tr_list_foreach (bin->methods_list, iter, m) {\n\t\t\tif (strlen (m->name) > 26 &&\n\t\t\t    !strcmp (m->name + strlen (m->name) - 27,\n\t\t\t\t     \".main([Ljava/lang/String;)V\")) {\n\t\t\t\tif (!already_entry (ret, m->paddr)) {\n\t\t\t\t\tif ((ptr = R_NEW0 (RBinAddr))) {\n\t\t\t\t\t\tptr->paddr = ptr->vaddr = m->paddr;\n\t\t\t\t\t\tr_list_append (ret, ptr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t}\n\n\t// STEP 3. NOTHING FOUND POINT TO CODE_INIT\n\tif (r_list_empty (ret)) {\n\t\tif (!already_entry (ret, bin->code_from)) {\n\t\t\tptr = R_NEW0 (RBinAddr);\n\t\t\tif (ptr) {\n\t\t\t\tptr->paddr = ptr->vaddr = bin->code_from;\n\t\t\t\tr_list_append (ret, ptr);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic ut64 offset_of_method_idx(RBinFile *arch, struct r_bin_dex_obj_t *dex, int idx) {\n\tut64 off = dex->header.method_offset + idx;\n\toff = sdb_num_get (mdb, sdb_fmt (0, \"method.%d\", idx), 0);\n\treturn (ut64) off;\n}\n\n// TODO: change all return type for all getoffset\nstatic int getoffset(RBinFile *arch, int type, int idx) {\n\tstruct r_bin_dex_obj_t *dex = arch->o->bin_obj;\n\tswitch (type) {\n\tcase 'm': // methods\n\t\t// TODO: ADD CHECK\n\t\treturn offset_of_method_idx (arch, dex, idx);\n\tcase 'o': // objects\n\t\tbreak;\n\tcase 's': // strings\n\t\tif (dex->header.strings_size > idx) {\n\t\t\tif (dex->strings) return dex->strings[idx];\n\t\t}\n\t\tbreak;\n\tcase 't': // type\n\t\treturn dex_get_type_offset (arch, idx);\n\tcase 'c': // class\n\t\treturn dex_get_type_offset (arch, idx);\n\t\t//return sdb_num_get (cdb, sdb_fmt (0, \"%d\", idx), 0);\n\t}\n\treturn -1;\n}\n\nstatic char *getname(RBinFile *arch, int type, int idx) {\n\tstruct r_bin_dex_obj_t *dex = arch->o->bin_obj;\n\tswitch (type) {\n\tcase 'm': // methods\n\t\treturn dex_method_fullname (dex, idx);\n\tcase 'c': // classes\n\t\treturn dex_class_name_byid (dex, idx);\n\tcase 'f': // fields\n\t\treturn dex_field_name (dex, idx);\n\t}\n\treturn NULL;\n}\n\nstatic RList *sections(RBinFile *arch) {\n\tstruct r_bin_dex_obj_t *bin = arch->o->bin_obj;\n\tRList *ml = methods (arch);\n\tRBinSection *ptr = NULL;\n\tint ns, fsymsz = 0;\n\tRList *ret = NULL;\n\tRListIter *iter;\n\tRBinSymbol *m;\n\tint fsym = 0;\n\n\tr_list_foreach (ml, iter, m) {\n\t\tif (!fsym || m->paddr < fsym) {\n\t\t\tfsym = m->paddr;\n\t\t}\n\t\tns = m->paddr + m->size;\n\t\tif (ns > arch->buf->length) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ns > fsymsz) {\n\t\t\tfsymsz = ns;\n\t\t}\n\t}\n\tif (!fsym) {\n\t\treturn NULL;\n\t}\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\tret->free = free;\n\n\tif ((ptr = R_NEW0 (RBinSection))) {\n\t\tstrcpy (ptr->name, \"header\");\n\t\tptr->size = ptr->vsize = sizeof (struct dex_header_t);\n\t\tptr->paddr= ptr->vaddr = 0;\n\t\tptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_MAP;\n\t\tptr->add = true;\n\t\tr_list_append (ret, ptr);\n\t}\n\tif ((ptr = R_NEW0 (RBinSection))) {\n\t\tstrcpy (ptr->name, \"constpool\");\n\t\t//ptr->size = ptr->vsize = fsym;\n\t\tptr->paddr= ptr->vaddr = sizeof (struct dex_header_t);\n\t\tptr->size = bin->code_from - ptr->vaddr; // fix size\n\t\tptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_MAP;\n\t\tptr->add = true;\n\t\tr_list_append (ret, ptr);\n\t}\n\tif ((ptr = R_NEW0 (RBinSection))) {\n\t\tstrcpy (ptr->name, \"code\");\n\t\tptr->vaddr = ptr->paddr = bin->code_from; //ptr->vaddr = fsym;\n\t\tptr->size = bin->code_to - ptr->paddr;\n\t\tptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_EXECUTABLE | R_BIN_SCN_MAP;\n\t\tptr->add = true;\n\t\tr_list_append (ret, ptr);\n\t}\n\tif ((ptr = R_NEW0 (RBinSection))) {\n\t\t//ut64 sz = arch ? r_buf_size (arch->buf): 0;\n\t\tstrcpy (ptr->name, \"data\");\n\t\tptr->paddr = ptr->vaddr = fsymsz+fsym;\n\t\tif (ptr->vaddr > arch->buf->length) {\n\t\t\tptr->paddr = ptr->vaddr = bin->code_to;\n\t\t\tptr->size = ptr->vsize = arch->buf->length - ptr->vaddr;\n\t\t} else {\n\t\t\tptr->size = ptr->vsize = arch->buf->length - ptr->vaddr;\n\t\t\t// hacky workaround\n\t\t\t//dprintf (\"Hack\\n\");\n\t\t\t//ptr->size = ptr->vsize = 1024;\n\t\t}\n\t\tptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_MAP; //|2;\n\t\tptr->add = true;\n\t\tr_list_append (ret, ptr);\n\t}\n\treturn ret;\n}\n\nstatic void header(RBinFile *arch) {\n\tstruct r_bin_dex_obj_t *bin = arch->o->bin_obj;\n\tstruct r_bin_t *rbin = arch->rbin;\n\n\trbin->cb_printf (\"DEX file header:\\n\");\n\trbin->cb_printf (\"magic               : 'dex\\\\n035\\\\0'\\n\");\n\trbin->cb_printf (\"checksum            : %x\\n\", bin->header.checksum);\n\trbin->cb_printf (\"signature           : %02x%02x...%02x%02x\\n\", bin->header.signature[0], bin->header.signature[1], bin->header.signature[18], bin->header.signature[19]);\n\trbin->cb_printf (\"file_size           : %d\\n\", bin->header.size);\n\trbin->cb_printf (\"header_size         : %d\\n\", bin->header.header_size);\n\trbin->cb_printf (\"link_size           : %d\\n\", bin->header.linksection_size);\n\trbin->cb_printf (\"link_off            : %d (0x%06x)\\n\", bin->header.linksection_offset, bin->header.linksection_offset);\n\trbin->cb_printf (\"string_ids_size     : %d\\n\", bin->header.strings_size);\n\trbin->cb_printf (\"string_ids_off      : %d (0x%06x)\\n\", bin->header.strings_offset, bin->header.strings_offset);\n\trbin->cb_printf (\"type_ids_size       : %d\\n\", bin->header.types_size);\n\trbin->cb_printf (\"type_ids_off        : %d (0x%06x)\\n\", bin->header.types_offset, bin->header.types_offset);\n\trbin->cb_printf (\"proto_ids_size       : %d\\n\", bin->header.prototypes_size);\n\trbin->cb_printf (\"proto_ids_off        : %d (0x%06x)\\n\", bin->header.prototypes_offset, bin->header.prototypes_offset);\n\trbin->cb_printf (\"field_ids_size      : %d\\n\", bin->header.fields_size);\n\trbin->cb_printf (\"field_ids_off       : %d (0x%06x)\\n\", bin->header.fields_offset, bin->header.fields_offset);\n\trbin->cb_printf (\"method_ids_size     : %d\\n\", bin->header.method_size);\n\trbin->cb_printf (\"method_ids_off      : %d (0x%06x)\\n\", bin->header.method_offset, bin->header.method_offset);\n\trbin->cb_printf (\"class_defs_size     : %d\\n\", bin->header.class_size);\n\trbin->cb_printf (\"class_defs_off      : %d (0x%06x)\\n\", bin->header.class_offset, bin->header.class_offset);\n\trbin->cb_printf (\"data_size           : %d\\n\", bin->header.data_size);\n\trbin->cb_printf (\"data_off            : %d (0x%06x)\\n\\n\", bin->header.data_offset, bin->header.data_offset);\n\n\t// TODO: print information stored in the RBIN not this ugly fix\n\tdexdump = true;\n\tbin->methods_list = NULL;\n\tdex_loadcode (arch, bin);\n\tdexdump = false;\n}\n\nstatic ut64 size(RBinFile *arch) {\n\tint ret;\n\tut32 off = 0, len = 0;\n\tut8 u32s[sizeof (ut32)] = {0};\n\n\tret = r_buf_read_at (arch->buf, 108, u32s, 4);\n\tif (ret != 4) {\n\t\treturn 0;\n\t}\n\toff = r_read_le32 (u32s);\n\tret = r_buf_read_at (arch->buf, 104, u32s, 4);\n\tif (ret != 4) {\n\t\treturn 0;\n\t}\n\tlen = r_read_le32 (u32s);\n\treturn off + len;\n}\n\nRBinPlugin r_bin_plugin_dex = {\n\t.name = \"dex\",\n\t.desc = \"dex format bin plugin\",\n\t.license = \"LGPL3\",\n\t.get_sdb = &get_sdb,\n\t.load = &load,\n\t.load_bytes = &load_bytes,\n\t.check = &check,\n\t.check_bytes = &check_bytes,\n\t.baddr = &baddr,\n\t.entries = entries,\n\t.classes = classes,\n\t.sections = sections,\n\t.symbols = methods,\n\t.imports = imports,\n\t.strings = strings,\n\t.info = &info,\n\t.header = &header,\n\t.size = &size,\n\t.get_offset = &getoffset,\n\t.get_name = &getname,\n\t.dbginfo = &r_bin_dbginfo_dex,\n};\n\n#ifndef CORELIB\nRLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_dex,\n\t.version = R2_VERSION\n};\n#endif\n"], "fixing_code": ["/* radare - LGPL - Copyright 2011-2016 - pancake */\n\n#include <r_cons.h>\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_bin.h>\n#include \"dex/dex.h\"\n#define r_hash_adler32 __adler32\n#include \"../../hash/adler32.c\"\n\nextern struct r_bin_dbginfo_t r_bin_dbginfo_dex;\n\n#define DEBUG_PRINTF 0\n\n#if DEBUG_PRINTF\n#define dprintf eprintf\n#else\n#define dprintf if (0)eprintf\n#endif\n\nstatic bool dexdump = false;\nstatic Sdb *mdb = NULL;\nstatic Sdb *cdb = NULL; // TODO: remove if it is not used\n\nstatic char *getstr(RBinDexObj *bin, int idx) {\n\tut8 buf[6];\n\tut64 len;\n\tint uleblen;\n\tif (!bin || idx < 0 || idx >= bin->header.strings_size ||\n\t\t!bin->strings) {\n\t\treturn NULL;\n\t}\n\tif (bin->strings[idx] >= bin->size) {\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_read_at (bin->b, bin->strings[idx], buf, sizeof (buf)) < 1) {\n\t\treturn NULL;\n\t}\n\tuleblen = r_uleb128 (buf, sizeof (buf), &len) - buf;\n\tif (!uleblen || uleblen >= bin->size) {\n\t\treturn NULL;\n\t}\n\tif (!len || len >= bin->size) {\n\t\treturn NULL;\n\t}\n\t// TODO: improve this ugly fix\n\tchar c = 'a';\n\twhile (c) {\n\t\tut64 offset = bin->strings[idx] + uleblen + len;\n\t\tif (offset >= bin->size || offset < len) {\n\t\t\treturn NULL;\n\t\t}\n\t\tr_buf_read_at (bin->b, offset, (ut8*)&c, 1);\n\t\tlen++;\n\t}\n\tif ((int)len > 0 && len < R_BIN_SIZEOF_STRINGS) {\n\t\tchar *str = calloc (1, len + 1);\n\t\tif (str) {\n\t\t\tr_buf_read_at (bin->b, (bin->strings[idx]) + uleblen,\n\t\t\t\t\t\t(ut8 *)str, len);\n\t\t\tstr[len] = 0;\n\t\t\treturn str;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic int countOnes(ut32 val) {\n\tint count = 0;\n\tval = val - ((val >> 1) & 0x55555555);\n\tval = (val & 0x33333333) + ((val >> 2) & 0x33333333);\n\tcount = (((val + (val >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;\n\treturn count;\n}\n\ntypedef enum {\n\tkAccessForClass  = 0,\n\tkAccessForMethod = 1,\n\tkAccessForField  = 2,\n\tkAccessForMAX\n} AccessFor;\n\nstatic char *createAccessFlagStr(ut32 flags, AccessFor forWhat) {\n\t#define NUM_FLAGS 18\n\tstatic const char* kAccessStrings[kAccessForMAX][NUM_FLAGS] = {\n\t\t{\n\t\t\t/* class, inner class */\n\t\t\t\"PUBLIC\",           /* 0x0001 */\n\t\t\t\"PRIVATE\",          /* 0x0002 */\n\t\t\t\"PROTECTED\",        /* 0x0004 */\n\t\t\t\"STATIC\",           /* 0x0008 */\n\t\t\t\"FINAL\",            /* 0x0010 */\n\t\t\t\"?\",                /* 0x0020 */\n\t\t\t\"?\",                /* 0x0040 */\n\t\t\t\"?\",                /* 0x0080 */\n\t\t\t\"?\",                /* 0x0100 */\n\t\t\t\"INTERFACE\",        /* 0x0200 */\n\t\t\t\"ABSTRACT\",         /* 0x0400 */\n\t\t\t\"?\",                /* 0x0800 */\n\t\t\t\"SYNTHETIC\",        /* 0x1000 */\n\t\t\t\"ANNOTATION\",       /* 0x2000 */\n\t\t\t\"ENUM\",             /* 0x4000 */\n\t\t\t\"?\",                /* 0x8000 */\n\t\t\t\"VERIFIED\",         /* 0x10000 */\n\t\t\t\"OPTIMIZED\",        /* 0x20000 */\n\t\t},\n\t\t{\n\t\t\t/* method */\n\t\t\t\"PUBLIC\",           /* 0x0001 */\n\t\t\t\"PRIVATE\",          /* 0x0002 */\n\t\t\t\"PROTECTED\",        /* 0x0004 */\n\t\t\t\"STATIC\",           /* 0x0008 */\n\t\t\t\"FINAL\",            /* 0x0010 */\n\t\t\t\"SYNCHRONIZED\",     /* 0x0020 */\n\t\t\t\"BRIDGE\",           /* 0x0040 */\n\t\t\t\"VARARGS\",          /* 0x0080 */\n\t\t\t\"NATIVE\",           /* 0x0100 */\n\t\t\t\"?\",                /* 0x0200 */\n\t\t\t\"ABSTRACT\",         /* 0x0400 */\n\t\t\t\"STRICT\",           /* 0x0800 */\n\t\t\t\"SYNTHETIC\",        /* 0x1000 */\n\t\t\t\"?\",                /* 0x2000 */\n\t\t\t\"?\",                /* 0x4000 */\n\t\t\t\"MIRANDA\",          /* 0x8000 */\n\t\t\t\"CONSTRUCTOR\",      /* 0x10000 */\n\t\t\t\"DECLARED_SYNCHRONIZED\", /* 0x20000 */\n\t\t},\n\t\t{\n\t\t\t/* field */\n\t\t\t\"PUBLIC\",           /* 0x0001 */\n\t\t\t\"PRIVATE\",          /* 0x0002 */\n\t\t\t\"PROTECTED\",        /* 0x0004 */\n\t\t\t\"STATIC\",           /* 0x0008 */\n\t\t\t\"FINAL\",            /* 0x0010 */\n\t\t\t\"?\",                /* 0x0020 */\n\t\t\t\"VOLATILE\",         /* 0x0040 */\n\t\t\t\"TRANSIENT\",        /* 0x0080 */\n\t\t\t\"?\",                /* 0x0100 */\n\t\t\t\"?\",                /* 0x0200 */\n\t\t\t\"?\",                /* 0x0400 */\n\t\t\t\"?\",                /* 0x0800 */\n\t\t\t\"SYNTHETIC\",        /* 0x1000 */\n\t\t\t\"?\",                /* 0x2000 */\n\t\t\t\"ENUM\",             /* 0x4000 */\n\t\t\t\"?\",                /* 0x8000 */\n\t\t\t\"?\",                /* 0x10000 */\n\t\t\t\"?\",                /* 0x20000 */\n\t\t},\n\t};\n\tconst int kLongest = 21;\n\tint i, count;\n\tchar* str;\n\tchar* cp;\n\tcount = countOnes(flags);\n\t// XXX check if this allocation is safe what if all the arithmetic\n\t// produces a huge number????\n\tcp = str = (char*) malloc (count * (kLongest + 1) + 1);\n\tfor (i = 0; i < NUM_FLAGS; i++) {\n\t\tif (flags & 0x01) {\n\t\t\tconst char* accessStr = kAccessStrings[forWhat][i];\n\t\t\tint len = strlen(accessStr);\n\t\t\tif (cp != str) {\n\t\t\t\t*cp++ = ' ';\n\t\t\t}\n\t\t\tmemcpy(cp, accessStr, len);\n\t\t\tcp += len;\n\t\t}\n\t\tflags >>= 1;\n\t}\n\t*cp = '\\0';\n\treturn str;\n}\n\nstatic char *dex_type_descriptor(RBinDexObj *bin, int type_idx) {\n\tif (type_idx < 0 || type_idx >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\treturn getstr (bin, bin->types[type_idx].descriptor_id);\n}\n\nstatic char *dex_method_signature(RBinDexObj *bin, int method_idx) {\n\tut32 proto_id, params_off, type_id, list_size;\n\tchar *r, *return_type = NULL, *signature = NULL, *buff = NULL; \n\tut8 *bufptr;\n\tut16 type_idx;\n\tint pos = 0, i, size = 1;\n\n\tif (method_idx < 0 || method_idx >= bin->header.method_size) {\n\t\treturn NULL;\n\t}\n\tproto_id = bin->methods[method_idx].proto_id;\n\tif (proto_id >= bin->header.prototypes_size) {\n\t\treturn NULL;\n\t}\n\tparams_off = bin->protos[proto_id].parameters_off;\n\tif (params_off  >= bin->size) {\n\t\treturn NULL;\n\t}\n\ttype_id = bin->protos[proto_id].return_type_id;\n\tif (type_id >= bin->header.types_size ) {\n\t\treturn NULL;\n\t}\n\treturn_type = getstr (bin, bin->types[type_id].descriptor_id);\n\tif (!return_type) {\n\t\treturn NULL;\n\t}\n\tif (!params_off) {\n\t\treturn r_str_newf (\"()%s\", return_type);;\n\t}\n\tbufptr = bin->b->buf;\n\t// size of the list, in entries\n\tlist_size = r_read_le32 (bufptr + params_off); \n\t//XXX again list_size is user controlled huge loop\n\tfor (i = 0; i < list_size; i++) {\n\t\tint buff_len = 0;\n\t\tif (params_off + 4 + (i * 2) >= bin->size) {\n\t\t\tbreak;\n\t\t}\n\t\ttype_idx = r_read_le16 (bufptr + params_off + 4 + (i * 2));\n\t\tif (type_idx < 0 ||\n\t\t    type_idx >=\n\t\t\t    bin->header.types_size || type_idx >= bin->size) {\n\t\t\tbreak;\n\t\t}\n\t\tbuff = getstr (bin, bin->types[type_idx].descriptor_id);\n\t\tif (!buff) {\n\t\t\tbreak;\n\t\t}\n\t\tbuff_len = strlen (buff);\n\t\tsize += buff_len + 1;\n\t\tsignature = realloc (signature, size);\n\t\tstrcpy (signature + pos, buff);\n\t\tpos += buff_len;\n\t\tsignature[pos] = '\\0';\n\t}\n\tr = r_str_newf (\"(%s)%s\", signature, return_type);\n\tfree (buff);\n\tfree (signature);\n\treturn r;\n}\n\nstatic RList *dex_method_signature2(RBinDexObj *bin, int method_idx) {\n\tut32 proto_id, params_off, list_size;\n\tchar *buff = NULL; \n\tut8 *bufptr;\n\tut16 type_idx;\n\tint i;\n\n\tRList *params = r_list_newf (free);\n\tif (!params) {\n\t\treturn NULL;\n\t}\n\tif (method_idx < 0 || method_idx >= bin->header.method_size) {\n\t\tgoto out_error;\n\t}\n\tproto_id = bin->methods[method_idx].proto_id;\n\tif (proto_id >= bin->header.prototypes_size) {\n\t\tgoto out_error;\n\t}\n\tparams_off = bin->protos[proto_id].parameters_off;\n\tif (params_off  >= bin->size) {\n\t\tgoto out_error;\n\t}\n\tif (!params_off) {\n\t\treturn params;\n\t}\n\tbufptr = bin->b->buf;\n\t// size of the list, in entries\n\tlist_size = r_read_le32 (bufptr + params_off); \n\t//XXX list_size tainted it may produce huge loop\n\tfor (i = 0; i < list_size; i++) {\n\t\tut64 of = params_off + 4 + (i * 2);\n\t\tif (of >= bin->size || of < params_off) {\n\t\t\tbreak;\n\t\t}\n\t\ttype_idx = r_read_le16 (bufptr + of);\n\t\tif (type_idx >= bin->header.types_size ||\n\t\t    type_idx > bin->size) {\n\t\t\tbreak;\n\t\t}\n\t\tbuff = getstr (bin, bin->types[type_idx].descriptor_id);\n\t\tif (!buff) {\n\t\t\tbreak;\n\t\t}\n\t\tr_list_append (params, buff);\n\t}\n\treturn params;\nout_error:\n\tr_list_free (params);\n\treturn NULL;\n}\n\n// TODO: fix this, now has more registers that it should\n// https://github.com/android/platform_dalvik/blob/0641c2b4836fae3ee8daf6c0af45c316c84d5aeb/libdex/DexDebugInfo.cpp#L312\n// https://github.com/android/platform_dalvik/blob/0641c2b4836fae3ee8daf6c0af45c316c84d5aeb/libdex/DexDebugInfo.cpp#L141\nstatic void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t  RBinDexClass *c, int MI, int MA, int paddr, int ins_size,\n\t\t\t\t  int insns_size, char *class_name, int regsz,\n\t\t\t\t  int debug_info_off) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tconst ut8 *p4 = r_buf_get_at (binfile->buf, debug_info_off, NULL);\n\tconst ut8 *p4_end = p4 + binfile->buf->length - debug_info_off;\n\tut64 line_start;\n\tut64 parameters_size;\n\tut64 param_type_idx;\n\tut16 argReg = regsz - ins_size;\n\tut64 source_file_idx = c->source_file;\n\tRList *params, *debug_positions, *emitted_debug_locals = NULL; \n\tbool keep = true;\n\tif (argReg > regsz) {\n\t\treturn; // this return breaks tests\n\t}\n\tp4 = r_uleb128 (p4, p4_end - p4, &line_start);\n\tp4 = r_uleb128 (p4, p4_end - p4, &parameters_size);\n\t// TODO: check when we should use source_file\n\t// The state machine consists of five registers\n\tut32 address = 0;\n\tut32 line = line_start;\n\tif (!(debug_positions = r_list_newf ((RListFree)free))) {\n\t\treturn;\t\n\t}\n\tif (!(emitted_debug_locals = r_list_newf ((RListFree)free))) {\n\t\tr_list_free (debug_positions);\n\t\treturn;\n\t}\n\n\tstruct dex_debug_local_t debug_locals[regsz];\n\tmemset (debug_locals, 0, sizeof (struct dex_debug_local_t) * regsz);\n\tif (!(MA & 0x0008)) {\n\t\tdebug_locals[argReg].name = \"this\";\n\t\tdebug_locals[argReg].descriptor = r_str_newf(\"%s;\", class_name);\n\t\tdebug_locals[argReg].startAddress = 0;\n\t\tdebug_locals[argReg].signature = NULL;\n\t\tdebug_locals[argReg].live = true;\n\t\targReg++;\n\t}\n\tif (!(params = dex_method_signature2 (bin, MI))) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\treturn;\n\t}\n\n\tRListIter *iter = r_list_iterator (params);\n\tchar *name;\n\tchar *type;\n\tint reg;\n\n\tr_list_foreach (params, iter, type) {\n\t\tif ((argReg >= regsz) || !type || parameters_size <= 0) {\n\t\t\tr_list_free (debug_positions);\n\t\t\tr_list_free (params);\n\t\t\tr_list_free (emitted_debug_locals);\n\t\t\treturn;\n\t\t}\n\t\tp4 = r_uleb128 (p4, p4_end - p4, &param_type_idx); // read uleb128p1\n\t\tparam_type_idx -= 1;\n\t\tname = getstr (bin, param_type_idx);\n\t\treg = argReg;\n\t\tswitch (type[0]) {\n\t\tcase 'D':\n\t\tcase 'J':\n\t\t\targReg += 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\targReg += 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (name) {\n\t\t\tdebug_locals[reg].name = name;\n\t\t\tdebug_locals[reg].descriptor = type;\n\t\t\tdebug_locals[reg].signature = NULL;\n\t\t\tdebug_locals[reg].startAddress = address;\n\t\t\tdebug_locals[reg].live = true;\n\t\t}\n\t\t--parameters_size;\n\t}\n\n\tut8 opcode = *(p4++) & 0xff;\n\twhile (keep) {\n\t\tswitch (opcode) {\n\t\tcase 0x0: // DBG_END_SEQUENCE\n\t\t\tkeep = false;\n\t\t\tbreak;\n\t\tcase 0x1: // DBG_ADVANCE_PC\n\t\t\t{\n\t\t\tut64 addr_diff;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &addr_diff);\n\t\t\taddress += addr_diff;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x2: // DBG_ADVANCE_LINE\n\t\t\t{\n\t\t\tst64 line_diff = r_sleb128 (&p4, p4_end);\n\t\t\tline += line_diff;\n\t\t\t}\n\t\t\tbreak;\t\n\t\tcase 0x3: // DBG_START_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx); \n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx); \n\t\t\ttype_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = NULL;\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t//eprintf(\"DBG_START_LOCAL %x %x %x\\n\", register_num, name_idx, type_idx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x4: //DBG_START_LOCAL_EXTENDED\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tut64 name_idx;\n\t\t\tut64 type_idx;\n\t\t\tut64 sig_idx;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &name_idx);\n\t\t\tname_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &type_idx);\n\t\t\ttype_idx -= 1;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &sig_idx);\n\t\t\tsig_idx -= 1;\n\t\t\tif (register_num >= regsz) {\n\t\t\t\tr_list_free (debug_positions);\n\t\t\t\tr_list_free (params);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Emit what was previously there, if anything\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\n\t\t\tdebug_locals[register_num].name = getstr (bin, name_idx);\n\t\t\tdebug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx);\n\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\tdebug_locals[register_num].signature = getstr (bin, sig_idx);\n\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x5: // DBG_END_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\t// emitLocalCbIfLive\n\t\t\tif (debug_locals[register_num].live) {\n\t\t\t\tstruct dex_debug_local_t *local = malloc (\n\t\t\t\t\tsizeof (struct dex_debug_local_t));\n\t\t\t\tif (!local) {\n\t\t\t\t\tkeep = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlocal->name = debug_locals[register_num].name;\n\t\t\t\tlocal->descriptor = debug_locals[register_num].descriptor;\n\t\t\t\tlocal->startAddress = debug_locals[register_num].startAddress;\n\t\t\t\tlocal->signature = debug_locals[register_num].signature;\n\t\t\t\tlocal->live = true;\n\t\t\t\tlocal->reg = register_num;\n\t\t\t\tlocal->endAddress = address;\n\t\t\t\tr_list_append (emitted_debug_locals, local);\n\t\t\t}\n\t\t\tdebug_locals[register_num].live = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x6: // DBG_RESTART_LOCAL\n\t\t\t{\n\t\t\tut64 register_num;\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &register_num);\n\t\t\tif (!debug_locals[register_num].live) {\n\t\t\t\tdebug_locals[register_num].startAddress = address;\n\t\t\t\tdebug_locals[register_num].live = true;\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x7: //DBG_SET_PROLOGUE_END\n\t\t\tbreak;\n\t\tcase 0x8: //DBG_SET_PROLOGUE_BEGIN\n\t\t\tbreak;\n\t\tcase 0x9:\n\t\t\t{\n\t\t\tp4 = r_uleb128 (p4, p4_end - p4, &source_file_idx);\n\t\t\tsource_file_idx--;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\tint adjusted_opcode = opcode - 0x0a;\n\t\t\taddress += (adjusted_opcode / 15);\n\t\t\tline += -4 + (adjusted_opcode % 15);\n\t\t\tstruct dex_debug_position_t *position =\n\t\t\t\tmalloc (sizeof (struct dex_debug_position_t));\n\t\t\tif (!position) {\n\t\t\t\tkeep = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tposition->source_file_idx = source_file_idx;\n\t\t\tposition->address = address;\n\t\t\tposition->line = line;\n\t\t\tr_list_append (debug_positions, position);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\topcode = *(p4++) & 0xff;\n\t}\n\n\tif (!binfile->sdb_addrinfo) {\n\t\tbinfile->sdb_addrinfo = sdb_new0 ();\n\t}\n\n\tchar *fileline;\n\tchar offset[64];\n\tchar *offset_ptr;\n\n\tRListIter *iter1;\n\tstruct dex_debug_position_t *pos;\n\tr_list_foreach (debug_positions, iter1, pos) {\n\t\tfileline = r_str_newf (\"%s|%\"PFMT64d, getstr (bin, pos->source_file_idx), pos->line);\n\t\toffset_ptr = sdb_itoa (pos->address + paddr, offset, 16);\n\t\tsdb_set (binfile->sdb_addrinfo, offset_ptr, fileline, 0);\n\t\tsdb_set (binfile->sdb_addrinfo, fileline, offset_ptr, 0);\n\t}\n\n\tif (!dexdump) {\n\t\tr_list_free (debug_positions);\n\t\tr_list_free (emitted_debug_locals);\n\t\tr_list_free (params);\n\t\treturn;\n\t}\n\n\tRListIter *iter2;\n\tstruct dex_debug_position_t *position;\n\n\trbin->cb_printf (\"      positions     :\\n\");\n\tr_list_foreach (debug_positions, iter2, position) {\n\t\trbin->cb_printf (\"        0x%04llx line=%llu\\n\",\n\t\t\t\t position->address, position->line);\n\t}\n\n\trbin->cb_printf (\"      locals        :\\n\");\n\n\tRListIter *iter3;\n\tstruct dex_debug_local_t *local;\n\tr_list_foreach (emitted_debug_locals, iter3, local) {\n\t\tif (local->signature) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor,\n\t\t\t\tlocal->signature);\n\t\t} else {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\\n\",\n\t\t\t\tlocal->startAddress, local->endAddress,\n\t\t\t\tlocal->reg, local->name, local->descriptor);\n\t\t}\n\t}\n\n\tfor (reg = 0; reg < regsz; reg++) {\n\t\tif (debug_locals[reg].live) {\n\t\t\tif (debug_locals[reg].signature) {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s \"\n\t\t\t\t\t\"%s\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor,\n\t\t\t\t\tdebug_locals[reg].signature);\n\t\t\t} else {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"        0x%04x - 0x%04x reg=%d %s %s\"\n\t\t\t\t\t\"\\n\",\n\t\t\t\t\tdebug_locals[reg].startAddress,\n\t\t\t\t\tinsns_size, reg, debug_locals[reg].name,\n\t\t\t\t\tdebug_locals[reg].descriptor);\n\t\t\t}\n\t\t}\n\t}\n\tr_list_free (debug_positions);\n\tr_list_free (emitted_debug_locals);\n\tr_list_free (params);\n}\n\nstatic int check (RBinFile *arch);\nstatic int check_bytes (const ut8 *buf, ut64 length);\n\nstatic Sdb *get_sdb (RBinObject *o) {\n\tif (!o || !o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tstruct r_bin_dex_obj_t *bin = (struct r_bin_dex_obj_t *) o->bin_obj;\n\tif (bin->kv) {\n\t\treturn bin->kv;\n\t}\n\treturn NULL;\n}\n\nstatic void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){\n\tvoid *res = NULL;\n\tRBuffer *tbuf = NULL;\n\tif (!buf || !sz || sz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\ttbuf = r_buf_new ();\n\tif (!tbuf) {\n\t\treturn NULL;\n\t}\t\t \n\tr_buf_set_bytes (tbuf, buf, sz);\n\tres = r_bin_dex_new_buf (tbuf);\n\tr_buf_free (tbuf);\n\treturn res;\n}\n\nstatic int load(RBinFile *arch) {\n\tconst ut8 *bytes = arch ? r_buf_buffer (arch->buf) : NULL;\n\tut64 sz = arch ? r_buf_size (arch->buf): 0;\n\n\tif (!arch || !arch->o) {\n\t\treturn false;\n\t}\n\tarch->o->bin_obj = load_bytes (arch, bytes, sz, arch->o->loadaddr, arch->sdb);\n\treturn arch->o->bin_obj ? true: false;\n}\n\nstatic ut64 baddr(RBinFile *arch) {\n\treturn 0;\n}\n\nstatic int check(RBinFile *arch) {\n\tconst ut8 *bytes = arch ? r_buf_buffer (arch->buf) : NULL;\n\tut64 sz = arch ? r_buf_size (arch->buf): 0;\n\treturn check_bytes (bytes, sz);\n}\n\nstatic int check_bytes(const ut8 *buf, ut64 length) {\n\tif (!buf || length < 8) {\n\t\treturn false;\n\t}\n\t// Non-extended opcode dex file\n\tif (!memcmp (buf, \"dex\\n035\\0\", 8)) {\n\t\treturn true;\n\t}\n\t// Extended (jumnbo) opcode dex file, ICS+ only (sdk level 14+)\n\tif (!memcmp (buf, \"dex\\n036\\0\", 8)) {\n\t\treturn true;\n\t}\n\t// M3 (Nov-Dec 07)\n\tif (!memcmp (buf, \"dex\\n009\\0\", 8)) {\n\t\treturn true;\n\t}\n\t// M5 (Feb-Mar 08)\n\tif (!memcmp (buf, \"dex\\n009\\0\", 8)) {\n\t\treturn true;\n\t}\n\t// Default fall through, should still be a dex file\n\tif (!memcmp (buf, \"dex\\n\", 4)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic RBinInfo *info(RBinFile *arch) {\n\tRBinHash *h;\n\tRBinInfo *ret = R_NEW0 (RBinInfo);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->file = arch->file? strdup (arch->file): NULL;\n\tret->type = strdup (\"DEX CLASS\");\n\tret->has_va = false;\n\tret->bclass = r_bin_dex_get_version (arch->o->bin_obj);\n\tret->rclass = strdup (\"class\");\n\tret->os = strdup (\"linux\");\n\tret->subsystem = strdup (\"any\");\n\tret->machine = strdup (\"Dalvik VM\");\n\th = &ret->sum[0];\n\th->type = \"sha1\";\n\th->len = 20;\n\th->addr = 12;\n\th->from = 12;\n\th->to = arch->buf->length-32;\n\tmemcpy (h->buf, arch->buf->buf+12, 20);\n\th = &ret->sum[1];\n\th->type = \"adler32\";\n\th->len = 4;\n\th->addr = 0x8;\n\th->from = 12;\n\th->to = arch->buf->length-h->from;\n\th = &ret->sum[2];\n\th->type = 0;\n\tmemcpy (h->buf, arch->buf->buf + 8, 4);\n\t{\n\t\tut32 *fc = (ut32 *)(arch->buf->buf + 8);\n\t\tut32  cc = __adler32 (arch->buf->buf + 12, arch->buf->length - 12);\n\t\tif (*fc != cc) {\n\t\t\teprintf (\"# adler32 checksum doesn't match. Type this to fix it:\\n\");\n\t\t\teprintf (\"wx `#sha1 $s-32 @32` @12 ; wx `#adler32 $s-12 @12` @8\\n\");\n\t\t}\n\t}\n\tret->arch = strdup (\"dalvik\");\n\tret->lang = \"dalvik\";\n\tret->bits = 32;\n\tret->big_endian = 0;\n\tret->dbg_info = 0; //1 | 4 | 8; /* Stripped | LineNums | Syms */\n\treturn ret;\n}\n\nstatic RList *strings(RBinFile *arch) {\n\tstruct r_bin_dex_obj_t *bin = NULL;\n\tRBinString *ptr = NULL;\n\tRList *ret = NULL;\n\tint i, len;\n\tut8 buf[6];\n\tut64 off;\n\tif (!arch || !arch->o) {\n\t\treturn NULL;\n\t}\n\tbin = (struct r_bin_dex_obj_t *) arch->o->bin_obj;\n\tif (!bin || !bin->strings) {\n\t\treturn NULL;\n\t}\n\tif (bin->header.strings_size > bin->size) {\n\t\tbin->strings = NULL;\n\t\treturn NULL;\n\t}\n\tif (!(ret = r_list_newf (free))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < bin->header.strings_size; i++) {\n\t\tif (!(ptr = R_NEW0 (RBinString))) {\n\t\t\tbreak;\n\t\t}\n\t\tif (bin->strings[i] > bin->size || bin->strings[i] + 6 > bin->size) {\n\t\t\tgoto out_error;\n\t\t}\n\t\tr_buf_read_at (bin->b, bin->strings[i], (ut8*)&buf, 6);\n\t\tlen = dex_read_uleb128 (buf);\n\n\t\tif (len > 1 && len < R_BIN_SIZEOF_STRINGS) {\n\t\t\tptr->string = malloc (len + 1);\n\t\t\tif (!ptr->string) {\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\toff = bin->strings[i] + dex_uleb128_len (buf);\n\t\t\tif (off + len >= bin->size || off + len < len) {\n\t\t\t\tfree (ptr->string);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tr_buf_read_at (bin->b, off, (ut8*)ptr->string, len);\n\t\t\tptr->string[len] = 0;\n\t\t\tptr->vaddr = ptr->paddr = bin->strings[i];\n\t\t\tptr->size = len;\n\t\t\tptr->length = len;\n\t\t\tptr->ordinal = i+1;\n\t\t\tr_list_append (ret, ptr);\n\t\t} else {\n\t\t\tfree (ptr);\n\t\t}\n\t}\n\treturn ret;\nout_error:\n\tr_list_free (ret);\n\tfree (ptr);\n\treturn NULL;\n}\n\nstatic char *dex_method_name(RBinDexObj *bin, int idx) {\n\tif (idx < 0 || idx >= bin->header.method_size) {\n\t\treturn NULL;\n\t}\n\tint cid = bin->methods[idx].class_id;\n\tif (cid < 0 || cid >= bin->header.strings_size) {\n\t\treturn NULL;\n\t}\n\tint tid = bin->methods[idx].name_id;\n\tif (tid < 0 || tid >= bin->header.strings_size) {\n\t\treturn NULL;\n\t}\n\treturn getstr (bin, tid);\n}\n\nstatic char *dex_class_name_byid(RBinDexObj *bin, int cid) {\n\tint tid;\n\tif (!bin || !bin->types) {\n\t\treturn NULL;\n\t}\n\tif (cid < 0 || cid >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\ttid = bin->types[cid].descriptor_id;\n\treturn getstr (bin, tid);\n}\n\nstatic char *dex_class_name(RBinDexObj *bin, RBinDexClass *c) {\n\treturn dex_class_name_byid (bin, c->class_id);\n}\n\nstatic char *dex_field_name(RBinDexObj *bin, int fid) {\n\tint cid, tid, type_id;\n\tif (!bin || !bin->fields) {\n\t\treturn NULL;\n\t}\n\tif (fid < 0 || fid >= bin->header.fields_size) {\n\t\treturn NULL;\n\t}\n\tcid = bin->fields[fid].class_id;\n\tif (cid < 0 || cid >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\ttype_id = bin->fields[fid].type_id;\n\tif (type_id < 0 || type_id >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\ttid = bin->fields[fid].name_id;\n\treturn r_str_newf (\"%s->%s %s\", getstr (bin, bin->types[cid].descriptor_id),\n\t\tgetstr (bin, tid), getstr (bin, bin->types[type_id].descriptor_id));\n}\n\nstatic char *dex_method_fullname(RBinDexObj *bin, int method_idx) {\n\tif (!bin || !bin->types) {\n\t\treturn NULL;\n\t}\n\tif (method_idx < 0 || method_idx >= bin->header.method_size) {\n\t\treturn NULL;\n\t}\n\tint cid = bin->methods[method_idx].class_id;\n\tif (cid < 0 || cid >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\tchar *name = dex_method_name (bin, method_idx);\n\tchar *class_name = dex_class_name_byid (bin, cid);\n\tclass_name = r_str_replace (class_name, \";\", \"\", 0); //TODO: move to func\n\tchar *signature = dex_method_signature (bin, method_idx);\n\tchar *flagname = r_str_newf (\"%s.%s%s\", class_name, name, signature);\n\tfree (name);\n\tfree (class_name);\n\tfree (signature);\n\treturn flagname;\n}\n\nstatic ut64 dex_get_type_offset(RBinFile *arch, int type_idx) {\n\tRBinDexObj *bin = (RBinDexObj*) arch->o->bin_obj;\n\tif (!bin || !bin->types) {\n\t\treturn 0;\n\t}\n\tif (type_idx < 0 || type_idx >= bin->header.types_size) {\n\t\treturn 0;\n\t}\n\treturn bin->header.types_offset + type_idx * 0x04; //&bin->types[type_idx];\n}\n\nstatic void __r_bin_class_free(RBinClass *p) {\n\tr_list_free (p->methods);\n\tr_list_free (p->fields);\n\tr_bin_class_free (p);\n}\n\nstatic char *dex_class_super_name(RBinDexObj *bin, RBinDexClass *c) {\n\tint cid, tid;\n\tif (!bin || !c || !bin->types) {\n\t\treturn NULL;\n\t}\n\tcid = c->super_class;\n\tif (cid < 0 || cid >= bin->header.types_size) {\n\t\treturn NULL;\n\t}\n\ttid = bin->types[cid].descriptor_id;\n\treturn getstr (bin, tid);\n}\n\nstatic const ut8 *parse_dex_class_fields(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t\t  RBinDexClass *c, RBinClass *cls,\n\t\t\t\t\t  const ut8 *p, const ut8 *p_end,\n\t\t\t\t\t  int *sym_count, ut64 fields_count,\n\t\t\t\t\t  bool is_sfield) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tut64 lastIndex = 0;\n\tut8 ff[sizeof (DexField)] = {0};\n\tint total, i, tid;\n\tDexField field;\n\tconst char* type_str;\n\tfor (i = 0; i < fields_count; i++) {\n\t\tut64 fieldIndex, accessFlags;\n\t\t\n\t\tp = r_uleb128 (p, p_end - p, &fieldIndex); // fieldIndex\n\t\tp = r_uleb128 (p, p_end - p, &accessFlags); // accessFlags\n\t\tfieldIndex += lastIndex;\n\t\ttotal = bin->header.fields_offset + (sizeof (DexField) * fieldIndex);\n\t\tif (total >= bin->size || total < bin->header.fields_offset) {\n\t\t\tbreak;\t\n\t\t}\n\t\tif (r_buf_read_at (binfile->buf, total, ff,\n\t\t\t\tsizeof (DexField)) != sizeof (DexField)) {\n\t\t\tbreak;\n\t\t}\n\t\tfield.class_id = r_read_le16 (ff);\n\t\tfield.type_id = r_read_le16 (ff + 2);\n\t\tfield.name_id = r_read_le32 (ff + 4);\n\t\tchar *fieldName = getstr (bin, field.name_id);\n\t\tif (field.type_id >= bin->header.types_size) {\n\t\t\tbreak;\n\t\t}\n\t\ttid = bin->types[field.type_id].descriptor_id;\n\t\ttype_str = getstr (bin, tid);\n\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\tif (is_sfield) {\n\t\t\tsym->name = r_str_newf (\"%s.sfield_%s:%s\", cls->name,\n\t\t\t\t\t\tfieldName, type_str);\n\t\t\tsym->type = r_str_const (\"STATIC\");\n\t\t} else {\n\t\t\tsym->name = r_str_newf (\"%s.ifield_%s:%s\", cls->name,\n\t\t\t\t\t\tfieldName, type_str);\n\t\t\tsym->type = r_str_const (\"FIELD\");\n\t\t}\n\t\tsym->name = r_str_replace (sym->name, \"method.\", \"\", 0);\n\t\t//sym->name = r_str_replace (sym->name, \";\", \"\", 0);\n\t\tsym->paddr = sym->vaddr = total;\n\t\tsym->ordinal = (*sym_count)++;\n\t\t\n\t\tif (dexdump) {\n\t\t\tconst char *accessStr = createAccessFlagStr (\n\t\t\t\taccessFlags, kAccessForField);\n\t\t\trbin->cb_printf (\"    #%d              : (in %s;)\\n\", i,\n\t\t\t\t\t cls->name);\n\t\t\trbin->cb_printf (\"      name          : '%s'\\n\", fieldName);\n\t\t\trbin->cb_printf (\"      type          : '%s'\\n\", type_str);\n\t\t\trbin->cb_printf (\"      access        : 0x%04x (%s)\\n\",\n\t\t\t\t\t (unsigned int)accessFlags, accessStr);\n\t\t}\n\n\t\tr_list_append (bin->methods_list, sym);\n\t\tr_list_append (cls->fields, sym);\n\n\t\tlastIndex = fieldIndex;\n\t}\n\treturn p;\n}\n\n// TODO: refactor this method\n// XXX it needs a lot of love!!!\nstatic const ut8 *parse_dex_class_method(RBinFile *binfile, RBinDexObj *bin,\n\t\t\t\t\t  RBinDexClass *c, RBinClass *cls,\n\t\t\t\t\t  const ut8 *p, const ut8 *p_end,\n\t\t\t\t\t  int *sym_count, ut64 DM, int *methods,\n\t\t\t\t\t  bool is_direct) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\tut8 ff2[16] = {0};\n\tut8 ff3[8] = {0};\n\tint i;\n\tut64 omi = 0;\n\tbool catchAll;\n\tut16 regsz, ins_size, outs_size, tries_size;\n\tut16 handler_off, start_addr, insn_count;\n\tut32 debug_info_off, insns_size;\n\tconst ut8 *encoded_method_addr;\n\tfor (i = 0; i < DM; i++) {\n\t\tencoded_method_addr = p;\n\t\tchar *method_name, *flag_name;\n\t\tut64 MI, MA, MC;\n\t\tp = r_uleb128 (p, p_end - p, &MI);\n\t\tMI += omi;\n\t\tomi = MI;\n\t\tp = r_uleb128 (p, p_end - p, &MA);\n\t\tp = r_uleb128 (p, p_end - p, &MC);\n\t\t// TODO: MOVE CHECKS OUTSIDE!\n\t\tif (MI < bin->header.method_size) {\n\t\t\tif (methods) {\n\t\t\t\tmethods[MI] = 1;\n\t\t\t}\n\t\t}\n\t\tmethod_name = dex_method_name (bin, MI);\n\t\tchar *signature = dex_method_signature (bin, MI);\n\t\tif (!method_name) {\n\t\t\tmethod_name = strdup (\"unknown\");\n\t\t}\n\t\tflag_name = r_str_newf (\"%s.method.%s%s\", cls->name,\n\t\t\t\t\tmethod_name, signature);\n\t\tif (!flag_name) {\n\t\t\tR_FREE (method_name);\n\t\t\tR_FREE (signature);\n\t\t\tcontinue;\n\t\t}\n\t\t// TODO: check size\n\t\t// ut64 prolog_size = 2 + 2 + 2 + 2 + 4 + 4;\n\t\tut64 v2, handler_type, handler_addr;\n\t\tint t;\n\t\tif (MC > 0) { \n\t\t\t// TODO: parse debug info\n\t\t\t// XXX why binfile->buf->base???\n\t\t\tif (MC + 16 >= bin->size || MC + 16 < MC) {\n\t\t\t\tR_FREE (method_name);\n\t\t\t\tR_FREE (flag_name);\n\t\t\t\tR_FREE (signature);\n\t\t\t\tcontinue;\n\t\t\t}\t\n\t\t\tif (r_buf_read_at (binfile->buf,\n\t\t\t\t\t   binfile->buf->base + MC, ff2,\n\t\t\t\t\t   16) < 1) {\n\t\t\t\tR_FREE (method_name);\n\t\t\t\tR_FREE (flag_name);\n\t\t\t\tR_FREE (signature);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tregsz = r_read_le16 (ff2);\n\t\t\tins_size = r_read_le16 (ff2 + 2);\n\t\t\touts_size = r_read_le16 (ff2 + 4);\n\t\t\ttries_size = r_read_le16 (ff2 + 6);\n\t\t\tdebug_info_off = r_read_le32 (ff2 + 8);\n\t\t\tinsns_size = r_read_le32 (ff2 + 12);\n\t\t\tint padd = 0;\n\t\t\tif (tries_size > 0 && insns_size % 2) {\n\t\t\t\tpadd = 2;\n\t\t\t}\n\t\t\tt = 16 + 2 * insns_size + padd;\n\t\t}\n\t\tif (dexdump) {\n\t\t\tconst char* accessStr = createAccessFlagStr (MA, kAccessForMethod);\n\t\t\trbin->cb_printf (\"    #%d              : (in %s;)\\n\", i, cls->name);\n\t\t\trbin->cb_printf (\"      name          : '%s'\\n\", method_name);\n\t\t\trbin->cb_printf (\"      type          : '%s'\\n\", signature);\n\t\t\trbin->cb_printf (\"      access        : 0x%04x (%s)\\n\",\n\t\t\t\t\t (unsigned int)MA, accessStr);\n\t\t}\n\n\t\tif (MC > 0) {\n\t\t\tif (dexdump) {\n\t\t\t\trbin->cb_printf (\"      code          -\\n\");\n\t\t\t\trbin->cb_printf (\"      registers     : %d\\n\", regsz);\n\t\t\t\trbin->cb_printf (\"      ins           : %d\\n\", ins_size);\n\t\t\t\trbin->cb_printf (\"      outs          : %d\\n\", outs_size);\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"      insns size    : %d 16-bit code \"\n\t\t\t\t\t\"units\\n\",\n\t\t\t\t\tinsns_size);\n\t\t\t}\n\t\t\tif (tries_size > 0) {\n\t\t\t\tif (dexdump) {\n\t\t\t\t\trbin->cb_printf (\"      catches       : %d\\n\", tries_size);\n\t\t\t\t}\n\t\t\t\tint j, m = 0;\n\t\t\t\t//XXX bucle controlled by tainted variable it could produces huge loop\n\t\t\t\tfor (j = 0; j < tries_size; ++j) {\n\t\t\t\t\tut64 offset = MC + t + j * 8;\n\t\t\t\t\tif (offset >= bin->size || offset < MC) {\n\t\t\t\t\t\tR_FREE (signature);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (r_buf_read_at (\n\t\t\t\t\t\t    binfile->buf,\n\t\t\t\t\t\t    binfile->buf->base + offset,\n\t\t\t\t\t\t    ff3, 8) < 1) {\n\t\t\t\t\t\t// free (method_name);\n\t\t\t\t\t\tR_FREE (signature);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tstart_addr = r_read_le32 (ff3);\n\t\t\t\t\tinsn_count = r_read_le16 (ff3 + 4);\n\t\t\t\t\thandler_off = r_read_le16 (ff3 + 6);\n\t\t\t\t\tchar* s = NULL;\n\t\t\t\t\tif (dexdump) {\n\t\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\t\"        0x%04x - \"\n\t\t\t\t\t\t\t\"0x%04x\\n\",\n\t\t\t\t\t\t\tstart_addr,\n\t\t\t\t\t\t\t(start_addr +\n\t\t\t\t\t\t\t insn_count));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tconst ut8 *p3, *p3_end;\n\t\t\t\t\t//XXX tries_size is tainted and oob here\n\t\t\t\t\tint off = MC + t + tries_size * 8 + handler_off;\n\t\t\t\t\tif (off >= bin->size || off < tries_size) {\n\t\t\t\t\t\tR_FREE (signature);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp3 = r_buf_get_at (binfile->buf, off, NULL);\n\t\t\t\t\tp3_end = p3 + binfile->buf->length - off;\n\t\t\t\t\tst64 size = r_sleb128 (&p3, p3_end);\n\n\t\t\t\t\tif (size <= 0) {\n\t\t\t\t\t\tcatchAll = true;\n\t\t\t\t\t\tsize = -size;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcatchAll = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (m = 0; m < size; m++) {\n\t\t\t\t\t\tp3 = r_uleb128 (p3, p3_end - p3, &handler_type);\n\t\t\t\t\t\tp3 = r_uleb128 (p3, p3_end - p3, &handler_addr);\n\n\t\t\t\t\t\tif (handler_type > 0 &&\n\t\t\t\t\t\t    handler_type <\n\t\t\t\t\t\t\t    bin->header.types_size) {\n\t\t\t\t\t\t\ts = getstr (bin, bin->types[handler_type].descriptor_id);\n\t\t\t\t\t\t\tif (dexdump) {\n\t\t\t\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\t\t\t\"          %s \"\n\t\t\t\t\t\t\t\t\t\"-> 0x%04llx\\n\",\n\t\t\t\t\t\t\t\t\ts,\n\t\t\t\t\t\t\t\t\thandler_addr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (dexdump) {\n\t\t\t\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\t\t\t\"          \"\n\t\t\t\t\t\t\t\t\t\"(error) -> \"\n\t\t\t\t\t\t\t\t\t\"0x%04llx\\n\",\n\t\t\t\t\t\t\t\t\thandler_addr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (catchAll) {\n\t\t\t\t\t\tp3 = r_uleb128 (p3, p3_end - p3, &v2);\n\t\t\t\t\t\tif (dexdump) {\n\t\t\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\t\t\"          \"\n\t\t\t\t\t\t\t\t\"<any> -> \"\n\t\t\t\t\t\t\t\t\"0x%04llx\\n\",\n\t\t\t\t\t\t\t\tv2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dexdump) {\n\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\"      catches       : \"\n\t\t\t\t\t\t\"(none)\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (dexdump) {\n\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\"      code          : (none)\\n\");\n\t\t\t}\n\t\t}\n\t\tif (*flag_name) {\n\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\tsym->name = flag_name;\n\t\t\t// is_direct is no longer used\n\t\t\t// if method has code *addr points to code\n\t\t\t// otherwise it points to the encoded method\n\t\t\tif (MC > 0) { \n\t\t\t\tsym->type = r_str_const (\"FUNC\");\n\t\t\t\tsym->paddr = MC;// + 0x10;\n\t\t\t\tsym->vaddr = MC;// + 0x10;\n\t\t\t} else {\n\t\t\t\tsym->type = r_str_const (\"METH\");\n\t\t\t\tsym->paddr = encoded_method_addr - binfile->buf->buf;\n\t\t\t\tsym->vaddr = encoded_method_addr - binfile->buf->buf;\n\t\t\t}\n\t\t\tif ((MA & 0x1) == 0x1) {\n\t\t\t\tsym->bind = r_str_const (\"GLOBAL\");\n\t\t\t} else {\n\t\t\t\tsym->bind = r_str_const (\"LOCAL\");\n\t\t\t}\n\t\t\tsym->ordinal = (*sym_count)++;\n\t\t\tif (MC > 0) {\n\t\t\t\tif (r_buf_read_at (binfile->buf, binfile->buf->base + MC, ff2, 16) < 1) {\n\t\t\t\t\tR_FREE (sym);\n\t\t\t\t\tR_FREE (signature);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//ut16 regsz = r_read_le16 (ff2);\n\t\t\t\t//ut16 ins_size = r_read_le16 (ff2 + 2);\n\t\t\t\t//ut16 outs_size = r_read_le16 (ff2 + 4);\n\t\t\t\tut16 tries_size = r_read_le16 (ff2 + 6);\n\t\t\t\t//ut32 debug_info_off = r_read_le32 (ff2 + 8);\n\t\t\t\tut32 insns_size = r_read_le32 (ff2 + 12);\n\t\t\t\tut64 prolog_size = 2 + 2 + 2 + 2 + 4 + 4;\n\t\t\t\tif (tries_size > 0) {\n\t\t\t\t\t//prolog_size += 2 + 8*tries_size; // we need to parse all so the catch info...\n\t\t\t\t}\n\t\t\t\t// TODO: prolog_size\n\t\t\t\tsym->paddr = MC + prolog_size;// + 0x10;\n\t\t\t\tsym->vaddr = MC + prolog_size;// + 0x10;\n\t\t\t\t//if (is_direct) {\n\t\t\t\tsym->size = insns_size * 2;\n\t\t\t\t//}\n\t\t\t\t//eprintf(\"%s (0x%x-0x%x) size=%d\\nregsz=%d\\ninsns_size=%d\\nouts_size=%d\\ntries_size=%d\\ninsns_size=%d\\n\", flag_name, sym->vaddr, sym->vaddr+sym->size, prolog_size, regsz, ins_size, outs_size, tries_size, insns_size);\n\t\t\t\tr_list_append (bin->methods_list, sym);\n\t\t\t\tr_list_append (cls->methods, sym);\n\n\t\t\t\tif (bin->code_from > sym->paddr) {\n\t\t\t\t\tbin->code_from = sym->paddr;\n\t\t\t\t}\n\t\t\t\tif (bin->code_to < sym->paddr) {\n\t\t\t\t\tbin->code_to = sym->paddr;\n\t\t\t\t}\n\n\t\t\t\tif (!mdb) {\n\t\t\t\t\tmdb = sdb_new0 ();\n\t\t\t\t}\n\t\t\t\tsdb_num_set (mdb, sdb_fmt (0, \"method.%d\", MI), sym->paddr, 0);\n\t\t\t\t// -----------------\n\t\t\t\t// WORK IN PROGRESS\n\t\t\t\t// -----------------\n\t\t\t\tif (0) {\n\t\t\t\t\tif (MA & 0x10000) { //ACC_CONSTRUCTOR\n\t\t\t\t\t\tif (!cdb) {\n\t\t\t\t\t\t\tcdb = sdb_new0 ();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsdb_num_set (cdb, sdb_fmt (0, \"%d\", c->class_id), sym->paddr, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsym->size = 0;\n\t\t\t\tr_list_append (bin->methods_list, sym);\n\t\t\t\tr_list_append (cls->methods, sym);\n\t\t\t}\n\t\t\tif (MC > 0 && debug_info_off > 0 && bin->header.data_offset < debug_info_off &&\n\t\t\t\tdebug_info_off < bin->header.data_offset + bin->header.data_size) {\n\t\t\t\tdex_parse_debug_item (binfile, bin, c, MI, MA, sym->paddr, ins_size, \n\t\t\t\t\tinsns_size, cls->name, regsz, debug_info_off);\n\t\t\t} else if (MC > 0) {\n\t\t\t\tif (dexdump) {\n\t\t\t\t\trbin->cb_printf (\"      positions     :\\n\");\n\t\t\t\t\trbin->cb_printf (\"      locals        :\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tR_FREE (flag_name);\n\t\t}\n\t\tR_FREE (signature);\n\t\tR_FREE (method_name);\n\t}\n\treturn p;\n}\n\nstatic void parse_class(RBinFile *binfile, RBinDexObj *bin, RBinDexClass *c,\n\t\t\t int class_index, int *methods, int *sym_count) {\n\tstruct r_bin_t *rbin = binfile->rbin;\n\n\tchar *class_name;\n\tint z;\n\tconst ut8 *p, *p_end;\n\n\tif (!c) {\n\t\treturn;\n\t}\n\n\tclass_name = dex_class_name (bin, c);\n\tclass_name = r_str_replace (class_name, \";\", \"\", 0); //TODO: move to func\n\n\tif (!class_name || !*class_name) {\n\t\treturn;\n\t}\n\n\tRBinClass *cls = R_NEW0 (RBinClass);\n\tif (!cls) {\n\t\treturn;\n\t}\n\tcls->name = class_name;\n\tcls->index = class_index;\n\tcls->addr = bin->header.class_offset + class_index * DEX_CLASS_SIZE;\n\tcls->methods = r_list_new ();\n\tif (!cls->methods) {\n\t\tfree (cls);\n\t\treturn;\n\t}\n\tcls->fields = r_list_new ();\n\tif (!cls->fields) {\n\t\tr_list_free (cls->methods);\n\t\tfree (cls);\n\t\treturn;\n\t}\n\tr_list_append (bin->classes_list, cls);\n\tif (dexdump) {\n\t\trbin->cb_printf (\"  Class descriptor  : '%s;'\\n\", class_name);\n\t\trbin->cb_printf (\n\t\t\t\"  Access flags      : 0x%04x (%s)\\n\", c->access_flags,\n\t\t\tcreateAccessFlagStr (c->access_flags, kAccessForClass));\n\t\trbin->cb_printf (\"  Superclass        : '%s'\\n\",\n\t\t\t\t dex_class_super_name (bin, c));\n\t\trbin->cb_printf (\"  Interfaces        -\\n\");\n\t}\n\n\tif (c->interfaces_offset > 0 &&\n\t    bin->header.data_offset < c->interfaces_offset &&\n\t    c->interfaces_offset <\n\t\t    bin->header.data_offset + bin->header.data_size) {\n\t\tp = r_buf_get_at (binfile->buf, c->interfaces_offset, NULL);\n\t\tint types_list_size = r_read_le32 (p);\n\t\tif (types_list_size < 0 || types_list_size >= bin->header.types_size ) {\n\t\t\treturn;\n\t\t}\n\t\tfor (z = 0; z < types_list_size; z++) {\n\t\t\tint t = r_read_le16 (p + 4 + z * 2);\n\t\t\tif (t > 0 && t < bin->header.types_size ) {\n\t\t\t\tint tid = bin->types[t].descriptor_id;\n\t\t\t\tif (dexdump) {\n\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\"    #%d              : '%s'\\n\",\n\t\t\t\t\t\tz, getstr (bin, tid));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: this is quite ugly\n\tif (!c || !c->class_data_offset) {\n\t\tif (dexdump) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"  Static fields     -\\n  Instance fields   \"\n\t\t\t\t\"-\\n  Direct methods    -\\n  Virtual methods   \"\n\t\t\t\t\"-\\n\");\n\t\t}\n\t} else {\n\t\t// TODO: move to func, def or inline\n\t\t// class_data_offset => [class_offset, class_defs_off+class_defs_size*32]\n\t\tif (bin->header.class_offset > c->class_data_offset ||\n\t\t    c->class_data_offset <\n\t\t\t    bin->header.class_offset +\n\t\t\t\t    bin->header.class_size * DEX_CLASS_SIZE) {\n\t\t\treturn;\n\t\t}\n\n\t\tp = r_buf_get_at (binfile->buf, c->class_data_offset, NULL);\n\t\tp_end = p + binfile->buf->length - c->class_data_offset;\n\t\t//XXX check for NULL!!\n\t\tc->class_data = (struct dex_class_data_item_t *)malloc (\n\t\t\tsizeof (struct dex_class_data_item_t));\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->static_fields_size);\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->instance_fields_size);\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->direct_methods_size);\n\t\tp = r_uleb128 (p, p_end - p, &c->class_data->virtual_methods_size);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Static fields     -\\n\"); \n\t\t}\n\t\tp = parse_dex_class_fields (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->static_fields_size, true);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Instance fields   -\\n\");\n\t\t}\n\t\tp = parse_dex_class_fields (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->instance_fields_size, false);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Direct methods    -\\n\");\n\t\t}\n\t\tp = parse_dex_class_method (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->direct_methods_size, methods, true);\n\n\t\tif (dexdump) { \n\t\t\trbin->cb_printf (\"  Virtual methods   -\\n\");\n\t\t}\n\t\tp = parse_dex_class_method (\n\t\t\tbinfile, bin, c, cls, p, p_end, sym_count,\n\t\t\tc->class_data->virtual_methods_size, methods, false);\n\t}\n\n\tif (dexdump) { \n\t\tchar *source_file = getstr (bin, c->source_file);\n\t\tif (!source_file) {\n\t\t\trbin->cb_printf (\n\t\t\t\t\"  source_file_idx   : %d (unknown)\\n\\n\",\n\t\t\t\tc->source_file);\n\t\t} else {\n\t\t\trbin->cb_printf (\"  source_file_idx   : %d (%s)\\n\\n\",\n\t\t\t\t\t c->source_file, source_file);\n\t\t}\n\t}\n\t// TODO:!!!!\n\t// FIX: FREE BEFORE ALLOCATE!!!\n\t//free (class_name);\n}\n\nstatic bool is_class_idx_in_code_classes(RBinDexObj *bin, int class_idx) {\n\tint i;\n\tfor (i = 0; i < bin->header.class_size; i++) {\n\t\tif (class_idx == bin->classes[i].class_id) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int dex_loadcode(RBinFile *arch, RBinDexObj *bin) {\n\tstruct r_bin_t *rbin = arch->rbin;\n\tint i;\n\tint *methods = NULL;\n\tint sym_count = 0;\n\n\t// doublecheck??\n\tif (!bin || bin->methods_list) {\n\t\treturn false;\n\t}\n\tbin->code_from = UT64_MAX;\n\tbin->code_to = 0;\n\tbin->methods_list = r_list_newf ((RListFree)free);\n\tif (!bin->methods_list) {\n\t\treturn false;\n\t}\n\tbin->imports_list = r_list_newf ((RListFree)free);\n\tif (!bin->imports_list) {\n\t\tr_list_free (bin->methods_list);\n\t\treturn false;\n\t}\n\tbin->classes_list = r_list_newf ((RListFree)__r_bin_class_free);\n\tif (!bin->classes_list) {\n\t\tr_list_free (bin->methods_list);\n\t\tr_list_free (bin->imports_list);\n\t\treturn false;\n\t}\n\n\tif (bin->header.method_size>bin->size) {\n\t\tbin->header.method_size = 0;\n\t\treturn false;\n\t}\n\n\t/* WrapDown the header sizes to avoid huge allocations */\n\tbin->header.method_size = R_MIN (bin->header.method_size, bin->size);\n\tbin->header.class_size = R_MIN (bin->header.class_size, bin->size);\n\tbin->header.strings_size = R_MIN (bin->header.strings_size, bin->size);\n\n\t// TODO: is this posible after R_MIN ??\n\tif (bin->header.strings_size > bin->size) {\n\t\teprintf (\"Invalid strings size\\n\");\n\t\treturn false;\n\t}\n\n\tif (bin->classes) {\n\t\tut64 amount = sizeof (int) * bin->header.method_size;\n\t\tif (amount > UT32_MAX || amount < bin->header.method_size) {\n\t\t\treturn false;\n\t\t}\n\t\tmethods = calloc (1, amount + 1);\n\t\tfor (i = 0; i < bin->header.class_size; i++) {\n\t\t\tchar *super_name, *class_name;\n\t\t\tstruct dex_class_t *c = &bin->classes[i];\n\t\t\tclass_name = dex_class_name (bin, c);\n\t\t\tsuper_name = dex_class_super_name (bin, c);\n\t\t\tif (dexdump) { \n\t\t\t\trbin->cb_printf (\"Class #%d            -\\n\", i);\n\t\t\t}\n\t\t\tparse_class (arch, bin, c, i, methods, &sym_count);\n\t\t\tfree (class_name);\n\t\t\tfree (super_name);\n\t\t}\n\t}\n\n\tif (methods) {\n\t\tint import_count = 0;\n\t\tint sym_count = bin->methods_list->length;\n\n\t\tfor (i = 0; i < bin->header.method_size; i++) {\n\t\t\tint len = 0;\n\t\t\tif (methods[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (bin->methods[i].class_id > bin->header.types_size - 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (is_class_idx_in_code_classes(bin, bin->methods[i].class_id)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchar *class_name = getstr (\n\t\t\t\tbin, bin->types[bin->methods[i].class_id]\n\t\t\t\t\t\t.descriptor_id);\n\t\t\tif (!class_name) {\n\t\t\t\tfree (class_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlen = strlen (class_name);\n\t\t\tif (len < 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclass_name[len - 1] = 0; // remove last char \";\"\n\t\t\tchar *method_name = dex_method_name (bin, i);\n\t\t\tchar *signature = dex_method_signature (bin, i);\n\t\t\tif (method_name && *method_name) {\n\t\t\t\tRBinImport *imp = R_NEW0 (RBinImport);\n\t\t\t\timp->name  = r_str_newf (\"%s.method.%s%s\", class_name, method_name, signature);\n\t\t\t\timp->type = r_str_const (\"FUNC\");\n\t\t\t\timp->bind = r_str_const (\"NONE\");\n\t\t\t\timp->ordinal = import_count++;\n\t\t\t\tr_list_append (bin->imports_list, imp);\n\n\t\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\t\tsym->name = r_str_newf (\"imp.%s\", imp->name);\n\t\t\t\tsym->type = r_str_const (\"FUNC\");\n\t\t\t\tsym->bind = r_str_const (\"NONE\");\n\t\t\t\t//XXX so damn unsafe check buffer boundaries!!!!\n\t\t\t\t//XXX use r_buf API!!\n\t\t\t\tsym->paddr = sym->vaddr = bin->b->base + bin->header.method_offset + (sizeof (struct dex_method_t) * i) ;\n\t\t\t\tsym->ordinal = sym_count++;\n\t\t\t\tr_list_append (bin->methods_list, sym);\n\t\t\t\tsdb_num_set (mdb, sdb_fmt (0, \"method.%d\", i), sym->paddr, 0);\n\t\t\t}\n\t\t\tfree (method_name);\n\t\t\tfree (signature);\n\t\t\tfree (class_name);\n\t\t}\n\t\tfree (methods);\n\t}\n\treturn true;\n}\n\nstatic RList* imports(RBinFile *arch) {\n\tRBinDexObj *bin = (RBinDexObj*) arch->o->bin_obj;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin && bin->imports_list) {\n\t\treturn bin->imports_list;\n\t}\n\tdex_loadcode (arch, bin);\n\treturn bin->imports_list;\n}\n\nstatic RList *methods(RBinFile *arch) {\n\tRBinDexObj *bin;\n\tif (!arch || !arch->o || !arch->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tbin = (RBinDexObj*) arch->o->bin_obj;\n\tif (!bin->methods_list) {\n\t\tdex_loadcode (arch, bin);\n\t}\n\treturn bin->methods_list;\n}\n\nstatic RList *classes(RBinFile *arch) {\n\tRBinDexObj *bin;\n\tif (!arch || !arch->o || !arch->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tbin = (RBinDexObj*) arch->o->bin_obj;\n\tif (!bin->classes_list) {\n\t\tdex_loadcode (arch, bin);\n\t}\n\treturn bin->classes_list;\n}\n\nstatic int already_entry(RList *entries, ut64 vaddr) {\n\tRBinAddr *e;\n\tRListIter *iter;\n\tr_list_foreach (entries, iter, e) {\n\t\tif (e->vaddr == vaddr) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic RList *entries(RBinFile *arch) {\n\tRListIter *iter;\n\tRBinDexObj *bin;\n\tRBinSymbol *m;\n\tRBinAddr *ptr;\n\tRList *ret;\n\n\tif (!arch || !arch->o || !arch->o->bin_obj) {\n\t\treturn NULL;\n\t}\n\tbin = (RBinDexObj*) arch->o->bin_obj;\n\tret = r_list_newf ((RListFree)free);\n\n\tif (!bin->methods_list) {\n\t\tdex_loadcode (arch, bin);\n\t}\n\n\t// STEP 1. \".onCreate(Landroid/os/Bundle;)V\"\n\tr_list_foreach (bin->methods_list, iter, m) {\n\t\tif (strlen (m->name) > 30 && m->bind && \n\t\t\t!strcmp(m->bind, \"GLOBAL\") &&\n\t\t    !strcmp (m->name + strlen (m->name) - 31,\n\t\t\t     \".onCreate(Landroid/os/Bundle;)V\")) {\n\t\t\tif (!already_entry (ret, m->paddr)) {\n\t\t\t\tif ((ptr = R_NEW0 (RBinAddr))) {\n\t\t\t\t\tptr->paddr = ptr->vaddr = m->paddr;\n\t\t\t\t\tr_list_append (ret, ptr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// STEP 2. \".main([Ljava/lang/String;)V\"\n\tif (r_list_empty (ret)) {\n\t\tr_list_foreach (bin->methods_list, iter, m) {\n\t\t\tif (strlen (m->name) > 26 &&\n\t\t\t    !strcmp (m->name + strlen (m->name) - 27,\n\t\t\t\t     \".main([Ljava/lang/String;)V\")) {\n\t\t\t\tif (!already_entry (ret, m->paddr)) {\n\t\t\t\t\tif ((ptr = R_NEW0 (RBinAddr))) {\n\t\t\t\t\t\tptr->paddr = ptr->vaddr = m->paddr;\n\t\t\t\t\t\tr_list_append (ret, ptr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t}\n\n\t// STEP 3. NOTHING FOUND POINT TO CODE_INIT\n\tif (r_list_empty (ret)) {\n\t\tif (!already_entry (ret, bin->code_from)) {\n\t\t\tptr = R_NEW0 (RBinAddr);\n\t\t\tif (ptr) {\n\t\t\t\tptr->paddr = ptr->vaddr = bin->code_from;\n\t\t\t\tr_list_append (ret, ptr);\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic ut64 offset_of_method_idx(RBinFile *arch, struct r_bin_dex_obj_t *dex, int idx) {\n\tut64 off = dex->header.method_offset + idx;\n\toff = sdb_num_get (mdb, sdb_fmt (0, \"method.%d\", idx), 0);\n\treturn (ut64) off;\n}\n\n// TODO: change all return type for all getoffset\nstatic int getoffset(RBinFile *arch, int type, int idx) {\n\tstruct r_bin_dex_obj_t *dex = arch->o->bin_obj;\n\tswitch (type) {\n\tcase 'm': // methods\n\t\t// TODO: ADD CHECK\n\t\treturn offset_of_method_idx (arch, dex, idx);\n\tcase 'o': // objects\n\t\tbreak;\n\tcase 's': // strings\n\t\tif (dex->header.strings_size > idx) {\n\t\t\tif (dex->strings) return dex->strings[idx];\n\t\t}\n\t\tbreak;\n\tcase 't': // type\n\t\treturn dex_get_type_offset (arch, idx);\n\tcase 'c': // class\n\t\treturn dex_get_type_offset (arch, idx);\n\t\t//return sdb_num_get (cdb, sdb_fmt (0, \"%d\", idx), 0);\n\t}\n\treturn -1;\n}\n\nstatic char *getname(RBinFile *arch, int type, int idx) {\n\tstruct r_bin_dex_obj_t *dex = arch->o->bin_obj;\n\tswitch (type) {\n\tcase 'm': // methods\n\t\treturn dex_method_fullname (dex, idx);\n\tcase 'c': // classes\n\t\treturn dex_class_name_byid (dex, idx);\n\tcase 'f': // fields\n\t\treturn dex_field_name (dex, idx);\n\t}\n\treturn NULL;\n}\n\nstatic RList *sections(RBinFile *arch) {\n\tstruct r_bin_dex_obj_t *bin = arch->o->bin_obj;\n\tRList *ml = methods (arch);\n\tRBinSection *ptr = NULL;\n\tint ns, fsymsz = 0;\n\tRList *ret = NULL;\n\tRListIter *iter;\n\tRBinSymbol *m;\n\tint fsym = 0;\n\n\tr_list_foreach (ml, iter, m) {\n\t\tif (!fsym || m->paddr < fsym) {\n\t\t\tfsym = m->paddr;\n\t\t}\n\t\tns = m->paddr + m->size;\n\t\tif (ns > arch->buf->length) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ns > fsymsz) {\n\t\t\tfsymsz = ns;\n\t\t}\n\t}\n\tif (!fsym) {\n\t\treturn NULL;\n\t}\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\tret->free = free;\n\n\tif ((ptr = R_NEW0 (RBinSection))) {\n\t\tstrcpy (ptr->name, \"header\");\n\t\tptr->size = ptr->vsize = sizeof (struct dex_header_t);\n\t\tptr->paddr= ptr->vaddr = 0;\n\t\tptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_MAP;\n\t\tptr->add = true;\n\t\tr_list_append (ret, ptr);\n\t}\n\tif ((ptr = R_NEW0 (RBinSection))) {\n\t\tstrcpy (ptr->name, \"constpool\");\n\t\t//ptr->size = ptr->vsize = fsym;\n\t\tptr->paddr= ptr->vaddr = sizeof (struct dex_header_t);\n\t\tptr->size = bin->code_from - ptr->vaddr; // fix size\n\t\tptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_MAP;\n\t\tptr->add = true;\n\t\tr_list_append (ret, ptr);\n\t}\n\tif ((ptr = R_NEW0 (RBinSection))) {\n\t\tstrcpy (ptr->name, \"code\");\n\t\tptr->vaddr = ptr->paddr = bin->code_from; //ptr->vaddr = fsym;\n\t\tptr->size = bin->code_to - ptr->paddr;\n\t\tptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_EXECUTABLE | R_BIN_SCN_MAP;\n\t\tptr->add = true;\n\t\tr_list_append (ret, ptr);\n\t}\n\tif ((ptr = R_NEW0 (RBinSection))) {\n\t\t//ut64 sz = arch ? r_buf_size (arch->buf): 0;\n\t\tstrcpy (ptr->name, \"data\");\n\t\tptr->paddr = ptr->vaddr = fsymsz+fsym;\n\t\tif (ptr->vaddr > arch->buf->length) {\n\t\t\tptr->paddr = ptr->vaddr = bin->code_to;\n\t\t\tptr->size = ptr->vsize = arch->buf->length - ptr->vaddr;\n\t\t} else {\n\t\t\tptr->size = ptr->vsize = arch->buf->length - ptr->vaddr;\n\t\t\t// hacky workaround\n\t\t\t//dprintf (\"Hack\\n\");\n\t\t\t//ptr->size = ptr->vsize = 1024;\n\t\t}\n\t\tptr->srwx = R_BIN_SCN_READABLE | R_BIN_SCN_MAP; //|2;\n\t\tptr->add = true;\n\t\tr_list_append (ret, ptr);\n\t}\n\treturn ret;\n}\n\nstatic void header(RBinFile *arch) {\n\tstruct r_bin_dex_obj_t *bin = arch->o->bin_obj;\n\tstruct r_bin_t *rbin = arch->rbin;\n\n\trbin->cb_printf (\"DEX file header:\\n\");\n\trbin->cb_printf (\"magic               : 'dex\\\\n035\\\\0'\\n\");\n\trbin->cb_printf (\"checksum            : %x\\n\", bin->header.checksum);\n\trbin->cb_printf (\"signature           : %02x%02x...%02x%02x\\n\", bin->header.signature[0], bin->header.signature[1], bin->header.signature[18], bin->header.signature[19]);\n\trbin->cb_printf (\"file_size           : %d\\n\", bin->header.size);\n\trbin->cb_printf (\"header_size         : %d\\n\", bin->header.header_size);\n\trbin->cb_printf (\"link_size           : %d\\n\", bin->header.linksection_size);\n\trbin->cb_printf (\"link_off            : %d (0x%06x)\\n\", bin->header.linksection_offset, bin->header.linksection_offset);\n\trbin->cb_printf (\"string_ids_size     : %d\\n\", bin->header.strings_size);\n\trbin->cb_printf (\"string_ids_off      : %d (0x%06x)\\n\", bin->header.strings_offset, bin->header.strings_offset);\n\trbin->cb_printf (\"type_ids_size       : %d\\n\", bin->header.types_size);\n\trbin->cb_printf (\"type_ids_off        : %d (0x%06x)\\n\", bin->header.types_offset, bin->header.types_offset);\n\trbin->cb_printf (\"proto_ids_size       : %d\\n\", bin->header.prototypes_size);\n\trbin->cb_printf (\"proto_ids_off        : %d (0x%06x)\\n\", bin->header.prototypes_offset, bin->header.prototypes_offset);\n\trbin->cb_printf (\"field_ids_size      : %d\\n\", bin->header.fields_size);\n\trbin->cb_printf (\"field_ids_off       : %d (0x%06x)\\n\", bin->header.fields_offset, bin->header.fields_offset);\n\trbin->cb_printf (\"method_ids_size     : %d\\n\", bin->header.method_size);\n\trbin->cb_printf (\"method_ids_off      : %d (0x%06x)\\n\", bin->header.method_offset, bin->header.method_offset);\n\trbin->cb_printf (\"class_defs_size     : %d\\n\", bin->header.class_size);\n\trbin->cb_printf (\"class_defs_off      : %d (0x%06x)\\n\", bin->header.class_offset, bin->header.class_offset);\n\trbin->cb_printf (\"data_size           : %d\\n\", bin->header.data_size);\n\trbin->cb_printf (\"data_off            : %d (0x%06x)\\n\\n\", bin->header.data_offset, bin->header.data_offset);\n\n\t// TODO: print information stored in the RBIN not this ugly fix\n\tdexdump = true;\n\tbin->methods_list = NULL;\n\tdex_loadcode (arch, bin);\n\tdexdump = false;\n}\n\nstatic ut64 size(RBinFile *arch) {\n\tint ret;\n\tut32 off = 0, len = 0;\n\tut8 u32s[sizeof (ut32)] = {0};\n\n\tret = r_buf_read_at (arch->buf, 108, u32s, 4);\n\tif (ret != 4) {\n\t\treturn 0;\n\t}\n\toff = r_read_le32 (u32s);\n\tret = r_buf_read_at (arch->buf, 104, u32s, 4);\n\tif (ret != 4) {\n\t\treturn 0;\n\t}\n\tlen = r_read_le32 (u32s);\n\treturn off + len;\n}\n\nRBinPlugin r_bin_plugin_dex = {\n\t.name = \"dex\",\n\t.desc = \"dex format bin plugin\",\n\t.license = \"LGPL3\",\n\t.get_sdb = &get_sdb,\n\t.load = &load,\n\t.load_bytes = &load_bytes,\n\t.check = &check,\n\t.check_bytes = &check_bytes,\n\t.baddr = &baddr,\n\t.entries = entries,\n\t.classes = classes,\n\t.sections = sections,\n\t.symbols = methods,\n\t.imports = imports,\n\t.strings = strings,\n\t.info = &info,\n\t.header = &header,\n\t.size = &size,\n\t.get_offset = &getoffset,\n\t.get_name = &getname,\n\t.dbginfo = &r_bin_dbginfo_dex,\n};\n\n#ifndef CORELIB\nRLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_BIN,\n\t.data = &r_bin_plugin_dex,\n\t.version = R2_VERSION\n};\n#endif\n"], "filenames": ["libr/bin/p/bin_dex.c"], "buggy_code_start_loc": [312], "buggy_code_end_loc": [314], "fixing_code_start_loc": [312], "fixing_code_end_loc": [314], "type": "CWE-119", "message": "The dex_parse_debug_item function in libr/bin/p/bin_dex.c in radare2 1.2.1 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted DEX file.", "other": {"cve": {"id": "CVE-2017-6319", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-02T01:59:00.173", "lastModified": "2017-03-04T02:59:01.033", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The dex_parse_debug_item function in libr/bin/p/bin_dex.c in radare2 1.2.1 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted DEX file."}, {"lang": "es", "value": "La funci\u00f3n dex_parse_debug_item en libr/bin/p/bin_dex.c en radare2 1.2.1 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (desbordamiento de b\u00fafer y ca\u00edda de la aplicaci\u00f3n) o posiblemente tener otro impacto no especificado a trav\u00e9s de un archivo DEX manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "1E2BB74D-D369-43D4-9EDB-3F0DD27091B0"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/96520", "source": "cve@mitre.org"}, {"url": "https://github.com/radare/radare2/commit/ad55822430a03fe075221b543efb434567e9e431", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/radare/radare2/issues/6836", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/ad55822430a03fe075221b543efb434567e9e431"}}