{"buggy_code": ["/* anet.c -- Basic TCP socket stuff made a bit less boring\n *\n * Copyright (c) 2006-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"fmacros.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/time.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n#include <netdb.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <stdio.h>\n\n#include \"anet.h\"\n#include \"config.h\"\n#include \"util.h\"\n\n#define UNUSED(x) (void)(x)\n\nstatic void anetSetError(char *err, const char *fmt, ...)\n{\n    va_list ap;\n\n    if (!err) return;\n    va_start(ap, fmt);\n    vsnprintf(err, ANET_ERR_LEN, fmt, ap);\n    va_end(ap);\n}\n\nint anetGetError(int fd) {\n    int sockerr = 0;\n    socklen_t errlen = sizeof(sockerr);\n\n    if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &sockerr, &errlen) == -1)\n        sockerr = errno;\n    return sockerr;\n}\n\nint anetSetBlock(char *err, int fd, int non_block) {\n    int flags;\n\n    /* Set the socket blocking (if non_block is zero) or non-blocking.\n     * Note that fcntl(2) for F_GETFL and F_SETFL can't be\n     * interrupted by a signal. */\n    if ((flags = fcntl(fd, F_GETFL)) == -1) {\n        anetSetError(err, \"fcntl(F_GETFL): %s\", strerror(errno));\n        return ANET_ERR;\n    }\n\n    /* Check if this flag has been set or unset, if so, \n     * then there is no need to call fcntl to set/unset it again. */\n    if (!!(flags & O_NONBLOCK) == !!non_block)\n        return ANET_OK;\n\n    if (non_block)\n        flags |= O_NONBLOCK;\n    else\n        flags &= ~O_NONBLOCK;\n\n    if (fcntl(fd, F_SETFL, flags) == -1) {\n        anetSetError(err, \"fcntl(F_SETFL,O_NONBLOCK): %s\", strerror(errno));\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}\n\nint anetNonBlock(char *err, int fd) {\n    return anetSetBlock(err,fd,1);\n}\n\nint anetBlock(char *err, int fd) {\n    return anetSetBlock(err,fd,0);\n}\n\n/* Enable the FD_CLOEXEC on the given fd to avoid fd leaks. \n * This function should be invoked for fd's on specific places \n * where fork + execve system calls are called. */\nint anetCloexec(int fd) {\n    int r;\n    int flags;\n\n    do {\n        r = fcntl(fd, F_GETFD);\n    } while (r == -1 && errno == EINTR);\n\n    if (r == -1 || (r & FD_CLOEXEC))\n        return r;\n\n    flags = r | FD_CLOEXEC;\n\n    do {\n        r = fcntl(fd, F_SETFD, flags);\n    } while (r == -1 && errno == EINTR);\n\n    return r;\n}\n\n/* Set TCP keep alive option to detect dead peers. The interval option\n * is only used for Linux as we are using Linux-specific APIs to set\n * the probe send time, interval, and count. */\nint anetKeepAlive(char *err, int fd, int interval)\n{\n    int val = 1;\n\n    if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val)) == -1)\n    {\n        anetSetError(err, \"setsockopt SO_KEEPALIVE: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n\n#ifdef __linux__\n    /* Default settings are more or less garbage, with the keepalive time\n     * set to 7200 by default on Linux. Modify settings to make the feature\n     * actually useful. */\n\n    /* Send first probe after interval. */\n    val = interval;\n    if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &val, sizeof(val)) < 0) {\n        anetSetError(err, \"setsockopt TCP_KEEPIDLE: %s\\n\", strerror(errno));\n        return ANET_ERR;\n    }\n\n    /* Send next probes after the specified interval. Note that we set the\n     * delay as interval / 3, as we send three probes before detecting\n     * an error (see the next setsockopt call). */\n    val = interval/3;\n    if (val == 0) val = 1;\n    if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &val, sizeof(val)) < 0) {\n        anetSetError(err, \"setsockopt TCP_KEEPINTVL: %s\\n\", strerror(errno));\n        return ANET_ERR;\n    }\n\n    /* Consider the socket in error state after three we send three ACK\n     * probes without getting a reply. */\n    val = 3;\n    if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &val, sizeof(val)) < 0) {\n        anetSetError(err, \"setsockopt TCP_KEEPCNT: %s\\n\", strerror(errno));\n        return ANET_ERR;\n    }\n#elif defined(__APPLE__)\n    /* Set idle time with interval */\n    val = interval;\n    if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &val, sizeof(val)) < 0) {\n        anetSetError(err, \"setsockopt TCP_KEEPALIVE: %s\\n\", strerror(errno));\n        return ANET_ERR;\n    }\n#else\n    ((void) interval); /* Avoid unused var warning for non Linux systems. */\n#endif\n\n    return ANET_OK;\n}\n\nstatic int anetSetTcpNoDelay(char *err, int fd, int val)\n{\n    if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &val, sizeof(val)) == -1)\n    {\n        anetSetError(err, \"setsockopt TCP_NODELAY: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}\n\nint anetEnableTcpNoDelay(char *err, int fd)\n{\n    return anetSetTcpNoDelay(err, fd, 1);\n}\n\nint anetDisableTcpNoDelay(char *err, int fd)\n{\n    return anetSetTcpNoDelay(err, fd, 0);\n}\n\n/* Set the socket send timeout (SO_SNDTIMEO socket option) to the specified\n * number of milliseconds, or disable it if the 'ms' argument is zero. */\nint anetSendTimeout(char *err, int fd, long long ms) {\n    struct timeval tv;\n\n    tv.tv_sec = ms/1000;\n    tv.tv_usec = (ms%1000)*1000;\n    if (setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) == -1) {\n        anetSetError(err, \"setsockopt SO_SNDTIMEO: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}\n\n/* Set the socket receive timeout (SO_RCVTIMEO socket option) to the specified\n * number of milliseconds, or disable it if the 'ms' argument is zero. */\nint anetRecvTimeout(char *err, int fd, long long ms) {\n    struct timeval tv;\n\n    tv.tv_sec = ms/1000;\n    tv.tv_usec = (ms%1000)*1000;\n    if (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) == -1) {\n        anetSetError(err, \"setsockopt SO_RCVTIMEO: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}\n\n/* Resolve the hostname \"host\" and set the string representation of the\n * IP address into the buffer pointed by \"ipbuf\".\n *\n * If flags is set to ANET_IP_ONLY the function only resolves hostnames\n * that are actually already IPv4 or IPv6 addresses. This turns the function\n * into a validating / normalizing function. */\nint anetResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len,\n                       int flags)\n{\n    struct addrinfo hints, *info;\n    int rv;\n\n    memset(&hints,0,sizeof(hints));\n    if (flags & ANET_IP_ONLY) hints.ai_flags = AI_NUMERICHOST;\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = SOCK_STREAM;  /* specify socktype to avoid dups */\n\n    if ((rv = getaddrinfo(host, NULL, &hints, &info)) != 0) {\n        anetSetError(err, \"%s\", gai_strerror(rv));\n        return ANET_ERR;\n    }\n    if (info->ai_family == AF_INET) {\n        struct sockaddr_in *sa = (struct sockaddr_in *)info->ai_addr;\n        inet_ntop(AF_INET, &(sa->sin_addr), ipbuf, ipbuf_len);\n    } else {\n        struct sockaddr_in6 *sa = (struct sockaddr_in6 *)info->ai_addr;\n        inet_ntop(AF_INET6, &(sa->sin6_addr), ipbuf, ipbuf_len);\n    }\n\n    freeaddrinfo(info);\n    return ANET_OK;\n}\n\nstatic int anetSetReuseAddr(char *err, int fd) {\n    int yes = 1;\n    /* Make sure connection-intensive things like the redis benchmark\n     * will be able to close/open sockets a zillion of times */\n    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)) == -1) {\n        anetSetError(err, \"setsockopt SO_REUSEADDR: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}\n\nstatic int anetCreateSocket(char *err, int domain) {\n    int s;\n    if ((s = socket(domain, SOCK_STREAM, 0)) == -1) {\n        anetSetError(err, \"creating socket: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n\n    /* Make sure connection-intensive things like the redis benchmark\n     * will be able to close/open sockets a zillion of times */\n    if (anetSetReuseAddr(err,s) == ANET_ERR) {\n        close(s);\n        return ANET_ERR;\n    }\n    return s;\n}\n\n#define ANET_CONNECT_NONE 0\n#define ANET_CONNECT_NONBLOCK 1\n#define ANET_CONNECT_BE_BINDING 2 /* Best effort binding. */\nstatic int anetTcpGenericConnect(char *err, const char *addr, int port,\n                                 const char *source_addr, int flags)\n{\n    int s = ANET_ERR, rv;\n    char portstr[6];  /* strlen(\"65535\") + 1; */\n    struct addrinfo hints, *servinfo, *bservinfo, *p, *b;\n\n    snprintf(portstr,sizeof(portstr),\"%d\",port);\n    memset(&hints,0,sizeof(hints));\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = SOCK_STREAM;\n\n    if ((rv = getaddrinfo(addr,portstr,&hints,&servinfo)) != 0) {\n        anetSetError(err, \"%s\", gai_strerror(rv));\n        return ANET_ERR;\n    }\n    for (p = servinfo; p != NULL; p = p->ai_next) {\n        /* Try to create the socket and to connect it.\n         * If we fail in the socket() call, or on connect(), we retry with\n         * the next entry in servinfo. */\n        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)\n            continue;\n        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;\n        if (flags & ANET_CONNECT_NONBLOCK && anetNonBlock(err,s) != ANET_OK)\n            goto error;\n        if (source_addr) {\n            int bound = 0;\n            /* Using getaddrinfo saves us from self-determining IPv4 vs IPv6 */\n            if ((rv = getaddrinfo(source_addr, NULL, &hints, &bservinfo)) != 0)\n            {\n                anetSetError(err, \"%s\", gai_strerror(rv));\n                goto error;\n            }\n            for (b = bservinfo; b != NULL; b = b->ai_next) {\n                if (bind(s,b->ai_addr,b->ai_addrlen) != -1) {\n                    bound = 1;\n                    break;\n                }\n            }\n            freeaddrinfo(bservinfo);\n            if (!bound) {\n                anetSetError(err, \"bind: %s\", strerror(errno));\n                goto error;\n            }\n        }\n        if (connect(s,p->ai_addr,p->ai_addrlen) == -1) {\n            /* If the socket is non-blocking, it is ok for connect() to\n             * return an EINPROGRESS error here. */\n            if (errno == EINPROGRESS && flags & ANET_CONNECT_NONBLOCK)\n                goto end;\n            close(s);\n            s = ANET_ERR;\n            continue;\n        }\n\n        /* If we ended an iteration of the for loop without errors, we\n         * have a connected socket. Let's return to the caller. */\n        goto end;\n    }\n    if (p == NULL)\n        anetSetError(err, \"creating socket: %s\", strerror(errno));\n\nerror:\n    if (s != ANET_ERR) {\n        close(s);\n        s = ANET_ERR;\n    }\n\nend:\n    freeaddrinfo(servinfo);\n\n    /* Handle best effort binding: if a binding address was used, but it is\n     * not possible to create a socket, try again without a binding address. */\n    if (s == ANET_ERR && source_addr && (flags & ANET_CONNECT_BE_BINDING)) {\n        return anetTcpGenericConnect(err,addr,port,NULL,flags);\n    } else {\n        return s;\n    }\n}\n\nint anetTcpNonBlockConnect(char *err, const char *addr, int port)\n{\n    return anetTcpGenericConnect(err,addr,port,NULL,ANET_CONNECT_NONBLOCK);\n}\n\nint anetTcpNonBlockBestEffortBindConnect(char *err, const char *addr, int port,\n                                         const char *source_addr)\n{\n    return anetTcpGenericConnect(err,addr,port,source_addr,\n            ANET_CONNECT_NONBLOCK|ANET_CONNECT_BE_BINDING);\n}\n\nint anetUnixGenericConnect(char *err, const char *path, int flags)\n{\n    int s;\n    struct sockaddr_un sa;\n\n    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)\n        return ANET_ERR;\n\n    sa.sun_family = AF_LOCAL;\n    redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));\n    if (flags & ANET_CONNECT_NONBLOCK) {\n        if (anetNonBlock(err,s) != ANET_OK) {\n            close(s);\n            return ANET_ERR;\n        }\n    }\n    if (connect(s,(struct sockaddr*)&sa,sizeof(sa)) == -1) {\n        if (errno == EINPROGRESS &&\n            flags & ANET_CONNECT_NONBLOCK)\n            return s;\n\n        anetSetError(err, \"connect: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n    return s;\n}\n\nstatic int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {\n    if (bind(s,sa,len) == -1) {\n        anetSetError(err, \"bind: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n\n    if (listen(s, backlog) == -1) {\n        anetSetError(err, \"listen: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}\n\nstatic int anetV6Only(char *err, int s) {\n    int yes = 1;\n    if (setsockopt(s,IPPROTO_IPV6,IPV6_V6ONLY,&yes,sizeof(yes)) == -1) {\n        anetSetError(err, \"setsockopt: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}\n\nstatic int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog)\n{\n    int s = -1, rv;\n    char _port[6];  /* strlen(\"65535\") */\n    struct addrinfo hints, *servinfo, *p;\n\n    snprintf(_port,6,\"%d\",port);\n    memset(&hints,0,sizeof(hints));\n    hints.ai_family = af;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_PASSIVE;    /* No effect if bindaddr != NULL */\n    if (bindaddr && !strcmp(\"*\", bindaddr))\n        bindaddr = NULL;\n    if (af == AF_INET6 && bindaddr && !strcmp(\"::*\", bindaddr))\n        bindaddr = NULL;\n\n    if ((rv = getaddrinfo(bindaddr,_port,&hints,&servinfo)) != 0) {\n        anetSetError(err, \"%s\", gai_strerror(rv));\n        return ANET_ERR;\n    }\n    for (p = servinfo; p != NULL; p = p->ai_next) {\n        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)\n            continue;\n\n        if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;\n        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;\n        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;\n        goto end;\n    }\n    if (p == NULL) {\n        anetSetError(err, \"unable to bind socket, errno: %d\", errno);\n        goto error;\n    }\n\nerror:\n    if (s != -1) close(s);\n    s = ANET_ERR;\nend:\n    freeaddrinfo(servinfo);\n    return s;\n}\n\nint anetTcpServer(char *err, int port, char *bindaddr, int backlog)\n{\n    return _anetTcpServer(err, port, bindaddr, AF_INET, backlog);\n}\n\nint anetTcp6Server(char *err, int port, char *bindaddr, int backlog)\n{\n    return _anetTcpServer(err, port, bindaddr, AF_INET6, backlog);\n}\n\nint anetUnixServer(char *err, char *path, mode_t perm, int backlog)\n{\n    int s;\n    struct sockaddr_un sa;\n\n    if (strlen(path) > sizeof(sa.sun_path)-1) {\n        anetSetError(err,\"unix socket path too long (%zu), must be under %zu\", strlen(path), sizeof(sa.sun_path));\n        return ANET_ERR;\n    }\n    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)\n        return ANET_ERR;\n\n    memset(&sa,0,sizeof(sa));\n    sa.sun_family = AF_LOCAL;\n    redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));\n    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR)\n        return ANET_ERR;\n    if (perm)\n        chmod(sa.sun_path, perm);\n    return s;\n}\n\n/* Accept a connection and also make sure the socket is non-blocking, and CLOEXEC.\n * returns the new socket FD, or -1 on error. */\nstatic int anetGenericAccept(char *err, int s, struct sockaddr *sa, socklen_t *len) {\n    int fd;\n    do {\n        /* Use the accept4() call on linux to simultaneously accept and\n         * set a socket as non-blocking. */\n#ifdef HAVE_ACCEPT4\n        fd = accept4(s, sa, len,  SOCK_NONBLOCK | SOCK_CLOEXEC);\n#else\n        fd = accept(s,sa,len);\n#endif\n    } while(fd == -1 && errno == EINTR);\n    if (fd == -1) {\n        anetSetError(err, \"accept: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n#ifndef HAVE_ACCEPT4\n    if (anetCloexec(fd) == -1) {\n        anetSetError(err, \"anetCloexec: %s\", strerror(errno));\n        close(fd);\n        return ANET_ERR;\n    }\n    if (anetNonBlock(err, fd) != ANET_OK) {\n        close(fd);\n        return ANET_ERR;\n    }\n#endif\n    return fd;\n}\n\n/* Accept a connection and also make sure the socket is non-blocking, and CLOEXEC.\n * returns the new socket FD, or -1 on error. */\nint anetTcpAccept(char *err, int serversock, char *ip, size_t ip_len, int *port) {\n    int fd;\n    struct sockaddr_storage sa;\n    socklen_t salen = sizeof(sa);\n    if ((fd = anetGenericAccept(err,serversock,(struct sockaddr*)&sa,&salen)) == ANET_ERR)\n        return ANET_ERR;\n\n    if (sa.ss_family == AF_INET) {\n        struct sockaddr_in *s = (struct sockaddr_in *)&sa;\n        if (ip) inet_ntop(AF_INET,(void*)&(s->sin_addr),ip,ip_len);\n        if (port) *port = ntohs(s->sin_port);\n    } else {\n        struct sockaddr_in6 *s = (struct sockaddr_in6 *)&sa;\n        if (ip) inet_ntop(AF_INET6,(void*)&(s->sin6_addr),ip,ip_len);\n        if (port) *port = ntohs(s->sin6_port);\n    }\n    return fd;\n}\n\n/* Accept a connection and also make sure the socket is non-blocking, and CLOEXEC.\n * returns the new socket FD, or -1 on error. */\nint anetUnixAccept(char *err, int s) {\n    int fd;\n    struct sockaddr_un sa;\n    socklen_t salen = sizeof(sa);\n    if ((fd = anetGenericAccept(err,s,(struct sockaddr*)&sa,&salen)) == ANET_ERR)\n        return ANET_ERR;\n\n    return fd;\n}\n\nint anetFdToString(int fd, char *ip, size_t ip_len, int *port, int remote) {\n    struct sockaddr_storage sa;\n    socklen_t salen = sizeof(sa);\n\n    if (remote) {\n        if (getpeername(fd, (struct sockaddr *)&sa, &salen) == -1) goto error;\n    } else {\n        if (getsockname(fd, (struct sockaddr *)&sa, &salen) == -1) goto error;\n    }\n\n    if (sa.ss_family == AF_INET) {\n        struct sockaddr_in *s = (struct sockaddr_in *)&sa;\n        if (ip) {\n            if (inet_ntop(AF_INET,(void*)&(s->sin_addr),ip,ip_len) == NULL)\n                goto error;\n        }\n        if (port) *port = ntohs(s->sin_port);\n    } else if (sa.ss_family == AF_INET6) {\n        struct sockaddr_in6 *s = (struct sockaddr_in6 *)&sa;\n        if (ip) {\n            if (inet_ntop(AF_INET6,(void*)&(s->sin6_addr),ip,ip_len) == NULL)\n                goto error;\n        }\n        if (port) *port = ntohs(s->sin6_port);\n    } else if (sa.ss_family == AF_UNIX) {\n        if (ip) {\n            int res = snprintf(ip, ip_len, \"/unixsocket\");\n            if (res < 0 || (unsigned int) res >= ip_len) goto error;\n        }\n        if (port) *port = 0;\n    } else {\n        goto error;\n    }\n    return 0;\n\nerror:\n    if (ip) {\n        if (ip_len >= 2) {\n            ip[0] = '?';\n            ip[1] = '\\0';\n        } else if (ip_len == 1) {\n            ip[0] = '\\0';\n        }\n    }\n    if (port) *port = 0;\n    return -1;\n}\n\n/* Create a pipe buffer with given flags for read end and write end.\n * Note that it supports the file flags defined by pipe2() and fcntl(F_SETFL),\n * and one of the use cases is O_CLOEXEC|O_NONBLOCK. */\nint anetPipe(int fds[2], int read_flags, int write_flags) {\n    int pipe_flags = 0;\n#if defined(__linux__) || defined(__FreeBSD__)\n    /* When possible, try to leverage pipe2() to apply flags that are common to both ends.\n     * There is no harm to set O_CLOEXEC to prevent fd leaks. */\n    pipe_flags = O_CLOEXEC | (read_flags & write_flags);\n    if (pipe2(fds, pipe_flags)) {\n        /* Fail on real failures, and fallback to simple pipe if pipe2 is unsupported. */\n        if (errno != ENOSYS && errno != EINVAL)\n            return -1;\n        pipe_flags = 0;\n    } else {\n        /* If the flags on both ends are identical, no need to do anything else. */\n        if ((O_CLOEXEC | read_flags) == (O_CLOEXEC | write_flags))\n            return 0;\n        /* Clear the flags which have already been set using pipe2. */\n        read_flags &= ~pipe_flags;\n        write_flags &= ~pipe_flags;\n    }\n#endif\n\n    /* When we reach here with pipe_flags of 0, it means pipe2 failed (or was not attempted),\n     * so we try to use pipe. Otherwise, we skip and proceed to set specific flags below. */\n    if (pipe_flags == 0 && pipe(fds))\n        return -1;\n\n    /* File descriptor flags.\n     * Currently, only one such flag is defined: FD_CLOEXEC, the close-on-exec flag. */\n    if (read_flags & O_CLOEXEC)\n        if (fcntl(fds[0], F_SETFD, FD_CLOEXEC))\n            goto error;\n    if (write_flags & O_CLOEXEC)\n        if (fcntl(fds[1], F_SETFD, FD_CLOEXEC))\n            goto error;\n\n    /* File status flags after clearing the file descriptor flag O_CLOEXEC. */\n    read_flags &= ~O_CLOEXEC;\n    if (read_flags)\n        if (fcntl(fds[0], F_SETFL, read_flags))\n            goto error;\n    write_flags &= ~O_CLOEXEC;\n    if (write_flags)\n        if (fcntl(fds[1], F_SETFL, write_flags))\n            goto error;\n\n    return 0;\n\nerror:\n    close(fds[0]);\n    close(fds[1]);\n    return -1;\n}\n\nint anetSetSockMarkId(char *err, int fd, uint32_t id) {\n#ifdef HAVE_SOCKOPTMARKID\n    if (setsockopt(fd, SOL_SOCKET, SOCKOPTMARKID, (void *)&id, sizeof(id)) == -1) {\n        anetSetError(err, \"setsockopt: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n    return ANET_OK;\n#else\n    UNUSED(fd);\n    UNUSED(id);\n    anetSetError(err,\"anetSetSockMarkid unsupported on this platform\");\n    return ANET_OK;\n#endif\n}\n\nint anetIsFifo(char *filepath) {\n    struct stat sb;\n    if (stat(filepath, &sb) == -1) return 0;\n    return S_ISFIFO(sb.st_mode);\n}\n"], "fixing_code": ["/* anet.c -- Basic TCP socket stuff made a bit less boring\n *\n * Copyright (c) 2006-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"fmacros.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/time.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n#include <netdb.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <stdio.h>\n\n#include \"anet.h\"\n#include \"config.h\"\n#include \"util.h\"\n\n#define UNUSED(x) (void)(x)\n\nstatic void anetSetError(char *err, const char *fmt, ...)\n{\n    va_list ap;\n\n    if (!err) return;\n    va_start(ap, fmt);\n    vsnprintf(err, ANET_ERR_LEN, fmt, ap);\n    va_end(ap);\n}\n\nint anetGetError(int fd) {\n    int sockerr = 0;\n    socklen_t errlen = sizeof(sockerr);\n\n    if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &sockerr, &errlen) == -1)\n        sockerr = errno;\n    return sockerr;\n}\n\nint anetSetBlock(char *err, int fd, int non_block) {\n    int flags;\n\n    /* Set the socket blocking (if non_block is zero) or non-blocking.\n     * Note that fcntl(2) for F_GETFL and F_SETFL can't be\n     * interrupted by a signal. */\n    if ((flags = fcntl(fd, F_GETFL)) == -1) {\n        anetSetError(err, \"fcntl(F_GETFL): %s\", strerror(errno));\n        return ANET_ERR;\n    }\n\n    /* Check if this flag has been set or unset, if so, \n     * then there is no need to call fcntl to set/unset it again. */\n    if (!!(flags & O_NONBLOCK) == !!non_block)\n        return ANET_OK;\n\n    if (non_block)\n        flags |= O_NONBLOCK;\n    else\n        flags &= ~O_NONBLOCK;\n\n    if (fcntl(fd, F_SETFL, flags) == -1) {\n        anetSetError(err, \"fcntl(F_SETFL,O_NONBLOCK): %s\", strerror(errno));\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}\n\nint anetNonBlock(char *err, int fd) {\n    return anetSetBlock(err,fd,1);\n}\n\nint anetBlock(char *err, int fd) {\n    return anetSetBlock(err,fd,0);\n}\n\n/* Enable the FD_CLOEXEC on the given fd to avoid fd leaks. \n * This function should be invoked for fd's on specific places \n * where fork + execve system calls are called. */\nint anetCloexec(int fd) {\n    int r;\n    int flags;\n\n    do {\n        r = fcntl(fd, F_GETFD);\n    } while (r == -1 && errno == EINTR);\n\n    if (r == -1 || (r & FD_CLOEXEC))\n        return r;\n\n    flags = r | FD_CLOEXEC;\n\n    do {\n        r = fcntl(fd, F_SETFD, flags);\n    } while (r == -1 && errno == EINTR);\n\n    return r;\n}\n\n/* Set TCP keep alive option to detect dead peers. The interval option\n * is only used for Linux as we are using Linux-specific APIs to set\n * the probe send time, interval, and count. */\nint anetKeepAlive(char *err, int fd, int interval)\n{\n    int val = 1;\n\n    if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val)) == -1)\n    {\n        anetSetError(err, \"setsockopt SO_KEEPALIVE: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n\n#ifdef __linux__\n    /* Default settings are more or less garbage, with the keepalive time\n     * set to 7200 by default on Linux. Modify settings to make the feature\n     * actually useful. */\n\n    /* Send first probe after interval. */\n    val = interval;\n    if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &val, sizeof(val)) < 0) {\n        anetSetError(err, \"setsockopt TCP_KEEPIDLE: %s\\n\", strerror(errno));\n        return ANET_ERR;\n    }\n\n    /* Send next probes after the specified interval. Note that we set the\n     * delay as interval / 3, as we send three probes before detecting\n     * an error (see the next setsockopt call). */\n    val = interval/3;\n    if (val == 0) val = 1;\n    if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &val, sizeof(val)) < 0) {\n        anetSetError(err, \"setsockopt TCP_KEEPINTVL: %s\\n\", strerror(errno));\n        return ANET_ERR;\n    }\n\n    /* Consider the socket in error state after three we send three ACK\n     * probes without getting a reply. */\n    val = 3;\n    if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &val, sizeof(val)) < 0) {\n        anetSetError(err, \"setsockopt TCP_KEEPCNT: %s\\n\", strerror(errno));\n        return ANET_ERR;\n    }\n#elif defined(__APPLE__)\n    /* Set idle time with interval */\n    val = interval;\n    if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &val, sizeof(val)) < 0) {\n        anetSetError(err, \"setsockopt TCP_KEEPALIVE: %s\\n\", strerror(errno));\n        return ANET_ERR;\n    }\n#else\n    ((void) interval); /* Avoid unused var warning for non Linux systems. */\n#endif\n\n    return ANET_OK;\n}\n\nstatic int anetSetTcpNoDelay(char *err, int fd, int val)\n{\n    if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &val, sizeof(val)) == -1)\n    {\n        anetSetError(err, \"setsockopt TCP_NODELAY: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}\n\nint anetEnableTcpNoDelay(char *err, int fd)\n{\n    return anetSetTcpNoDelay(err, fd, 1);\n}\n\nint anetDisableTcpNoDelay(char *err, int fd)\n{\n    return anetSetTcpNoDelay(err, fd, 0);\n}\n\n/* Set the socket send timeout (SO_SNDTIMEO socket option) to the specified\n * number of milliseconds, or disable it if the 'ms' argument is zero. */\nint anetSendTimeout(char *err, int fd, long long ms) {\n    struct timeval tv;\n\n    tv.tv_sec = ms/1000;\n    tv.tv_usec = (ms%1000)*1000;\n    if (setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) == -1) {\n        anetSetError(err, \"setsockopt SO_SNDTIMEO: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}\n\n/* Set the socket receive timeout (SO_RCVTIMEO socket option) to the specified\n * number of milliseconds, or disable it if the 'ms' argument is zero. */\nint anetRecvTimeout(char *err, int fd, long long ms) {\n    struct timeval tv;\n\n    tv.tv_sec = ms/1000;\n    tv.tv_usec = (ms%1000)*1000;\n    if (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) == -1) {\n        anetSetError(err, \"setsockopt SO_RCVTIMEO: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}\n\n/* Resolve the hostname \"host\" and set the string representation of the\n * IP address into the buffer pointed by \"ipbuf\".\n *\n * If flags is set to ANET_IP_ONLY the function only resolves hostnames\n * that are actually already IPv4 or IPv6 addresses. This turns the function\n * into a validating / normalizing function. */\nint anetResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len,\n                       int flags)\n{\n    struct addrinfo hints, *info;\n    int rv;\n\n    memset(&hints,0,sizeof(hints));\n    if (flags & ANET_IP_ONLY) hints.ai_flags = AI_NUMERICHOST;\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = SOCK_STREAM;  /* specify socktype to avoid dups */\n\n    if ((rv = getaddrinfo(host, NULL, &hints, &info)) != 0) {\n        anetSetError(err, \"%s\", gai_strerror(rv));\n        return ANET_ERR;\n    }\n    if (info->ai_family == AF_INET) {\n        struct sockaddr_in *sa = (struct sockaddr_in *)info->ai_addr;\n        inet_ntop(AF_INET, &(sa->sin_addr), ipbuf, ipbuf_len);\n    } else {\n        struct sockaddr_in6 *sa = (struct sockaddr_in6 *)info->ai_addr;\n        inet_ntop(AF_INET6, &(sa->sin6_addr), ipbuf, ipbuf_len);\n    }\n\n    freeaddrinfo(info);\n    return ANET_OK;\n}\n\nstatic int anetSetReuseAddr(char *err, int fd) {\n    int yes = 1;\n    /* Make sure connection-intensive things like the redis benchmark\n     * will be able to close/open sockets a zillion of times */\n    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)) == -1) {\n        anetSetError(err, \"setsockopt SO_REUSEADDR: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}\n\nstatic int anetCreateSocket(char *err, int domain) {\n    int s;\n    if ((s = socket(domain, SOCK_STREAM, 0)) == -1) {\n        anetSetError(err, \"creating socket: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n\n    /* Make sure connection-intensive things like the redis benchmark\n     * will be able to close/open sockets a zillion of times */\n    if (anetSetReuseAddr(err,s) == ANET_ERR) {\n        close(s);\n        return ANET_ERR;\n    }\n    return s;\n}\n\n#define ANET_CONNECT_NONE 0\n#define ANET_CONNECT_NONBLOCK 1\n#define ANET_CONNECT_BE_BINDING 2 /* Best effort binding. */\nstatic int anetTcpGenericConnect(char *err, const char *addr, int port,\n                                 const char *source_addr, int flags)\n{\n    int s = ANET_ERR, rv;\n    char portstr[6];  /* strlen(\"65535\") + 1; */\n    struct addrinfo hints, *servinfo, *bservinfo, *p, *b;\n\n    snprintf(portstr,sizeof(portstr),\"%d\",port);\n    memset(&hints,0,sizeof(hints));\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = SOCK_STREAM;\n\n    if ((rv = getaddrinfo(addr,portstr,&hints,&servinfo)) != 0) {\n        anetSetError(err, \"%s\", gai_strerror(rv));\n        return ANET_ERR;\n    }\n    for (p = servinfo; p != NULL; p = p->ai_next) {\n        /* Try to create the socket and to connect it.\n         * If we fail in the socket() call, or on connect(), we retry with\n         * the next entry in servinfo. */\n        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)\n            continue;\n        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;\n        if (flags & ANET_CONNECT_NONBLOCK && anetNonBlock(err,s) != ANET_OK)\n            goto error;\n        if (source_addr) {\n            int bound = 0;\n            /* Using getaddrinfo saves us from self-determining IPv4 vs IPv6 */\n            if ((rv = getaddrinfo(source_addr, NULL, &hints, &bservinfo)) != 0)\n            {\n                anetSetError(err, \"%s\", gai_strerror(rv));\n                goto error;\n            }\n            for (b = bservinfo; b != NULL; b = b->ai_next) {\n                if (bind(s,b->ai_addr,b->ai_addrlen) != -1) {\n                    bound = 1;\n                    break;\n                }\n            }\n            freeaddrinfo(bservinfo);\n            if (!bound) {\n                anetSetError(err, \"bind: %s\", strerror(errno));\n                goto error;\n            }\n        }\n        if (connect(s,p->ai_addr,p->ai_addrlen) == -1) {\n            /* If the socket is non-blocking, it is ok for connect() to\n             * return an EINPROGRESS error here. */\n            if (errno == EINPROGRESS && flags & ANET_CONNECT_NONBLOCK)\n                goto end;\n            close(s);\n            s = ANET_ERR;\n            continue;\n        }\n\n        /* If we ended an iteration of the for loop without errors, we\n         * have a connected socket. Let's return to the caller. */\n        goto end;\n    }\n    if (p == NULL)\n        anetSetError(err, \"creating socket: %s\", strerror(errno));\n\nerror:\n    if (s != ANET_ERR) {\n        close(s);\n        s = ANET_ERR;\n    }\n\nend:\n    freeaddrinfo(servinfo);\n\n    /* Handle best effort binding: if a binding address was used, but it is\n     * not possible to create a socket, try again without a binding address. */\n    if (s == ANET_ERR && source_addr && (flags & ANET_CONNECT_BE_BINDING)) {\n        return anetTcpGenericConnect(err,addr,port,NULL,flags);\n    } else {\n        return s;\n    }\n}\n\nint anetTcpNonBlockConnect(char *err, const char *addr, int port)\n{\n    return anetTcpGenericConnect(err,addr,port,NULL,ANET_CONNECT_NONBLOCK);\n}\n\nint anetTcpNonBlockBestEffortBindConnect(char *err, const char *addr, int port,\n                                         const char *source_addr)\n{\n    return anetTcpGenericConnect(err,addr,port,source_addr,\n            ANET_CONNECT_NONBLOCK|ANET_CONNECT_BE_BINDING);\n}\n\nint anetUnixGenericConnect(char *err, const char *path, int flags)\n{\n    int s;\n    struct sockaddr_un sa;\n\n    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)\n        return ANET_ERR;\n\n    sa.sun_family = AF_LOCAL;\n    redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));\n    if (flags & ANET_CONNECT_NONBLOCK) {\n        if (anetNonBlock(err,s) != ANET_OK) {\n            close(s);\n            return ANET_ERR;\n        }\n    }\n    if (connect(s,(struct sockaddr*)&sa,sizeof(sa)) == -1) {\n        if (errno == EINPROGRESS &&\n            flags & ANET_CONNECT_NONBLOCK)\n            return s;\n\n        anetSetError(err, \"connect: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n    return s;\n}\n\nstatic int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog, mode_t perm) {\n    if (bind(s,sa,len) == -1) {\n        anetSetError(err, \"bind: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n\n    if (sa->sa_family == AF_LOCAL && perm)\n        chmod(((struct sockaddr_un *) sa)->sun_path, perm);\n\n    if (listen(s, backlog) == -1) {\n        anetSetError(err, \"listen: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}\n\nstatic int anetV6Only(char *err, int s) {\n    int yes = 1;\n    if (setsockopt(s,IPPROTO_IPV6,IPV6_V6ONLY,&yes,sizeof(yes)) == -1) {\n        anetSetError(err, \"setsockopt: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}\n\nstatic int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog)\n{\n    int s = -1, rv;\n    char _port[6];  /* strlen(\"65535\") */\n    struct addrinfo hints, *servinfo, *p;\n\n    snprintf(_port,6,\"%d\",port);\n    memset(&hints,0,sizeof(hints));\n    hints.ai_family = af;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_PASSIVE;    /* No effect if bindaddr != NULL */\n    if (bindaddr && !strcmp(\"*\", bindaddr))\n        bindaddr = NULL;\n    if (af == AF_INET6 && bindaddr && !strcmp(\"::*\", bindaddr))\n        bindaddr = NULL;\n\n    if ((rv = getaddrinfo(bindaddr,_port,&hints,&servinfo)) != 0) {\n        anetSetError(err, \"%s\", gai_strerror(rv));\n        return ANET_ERR;\n    }\n    for (p = servinfo; p != NULL; p = p->ai_next) {\n        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)\n            continue;\n\n        if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;\n        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;\n        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog,0) == ANET_ERR) s = ANET_ERR;\n        goto end;\n    }\n    if (p == NULL) {\n        anetSetError(err, \"unable to bind socket, errno: %d\", errno);\n        goto error;\n    }\n\nerror:\n    if (s != -1) close(s);\n    s = ANET_ERR;\nend:\n    freeaddrinfo(servinfo);\n    return s;\n}\n\nint anetTcpServer(char *err, int port, char *bindaddr, int backlog)\n{\n    return _anetTcpServer(err, port, bindaddr, AF_INET, backlog);\n}\n\nint anetTcp6Server(char *err, int port, char *bindaddr, int backlog)\n{\n    return _anetTcpServer(err, port, bindaddr, AF_INET6, backlog);\n}\n\nint anetUnixServer(char *err, char *path, mode_t perm, int backlog)\n{\n    int s;\n    struct sockaddr_un sa;\n\n    if (strlen(path) > sizeof(sa.sun_path)-1) {\n        anetSetError(err,\"unix socket path too long (%zu), must be under %zu\", strlen(path), sizeof(sa.sun_path));\n        return ANET_ERR;\n    }\n    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)\n        return ANET_ERR;\n\n    memset(&sa,0,sizeof(sa));\n    sa.sun_family = AF_LOCAL;\n    redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));\n    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog,perm) == ANET_ERR)\n        return ANET_ERR;\n    return s;\n}\n\n/* Accept a connection and also make sure the socket is non-blocking, and CLOEXEC.\n * returns the new socket FD, or -1 on error. */\nstatic int anetGenericAccept(char *err, int s, struct sockaddr *sa, socklen_t *len) {\n    int fd;\n    do {\n        /* Use the accept4() call on linux to simultaneously accept and\n         * set a socket as non-blocking. */\n#ifdef HAVE_ACCEPT4\n        fd = accept4(s, sa, len,  SOCK_NONBLOCK | SOCK_CLOEXEC);\n#else\n        fd = accept(s,sa,len);\n#endif\n    } while(fd == -1 && errno == EINTR);\n    if (fd == -1) {\n        anetSetError(err, \"accept: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n#ifndef HAVE_ACCEPT4\n    if (anetCloexec(fd) == -1) {\n        anetSetError(err, \"anetCloexec: %s\", strerror(errno));\n        close(fd);\n        return ANET_ERR;\n    }\n    if (anetNonBlock(err, fd) != ANET_OK) {\n        close(fd);\n        return ANET_ERR;\n    }\n#endif\n    return fd;\n}\n\n/* Accept a connection and also make sure the socket is non-blocking, and CLOEXEC.\n * returns the new socket FD, or -1 on error. */\nint anetTcpAccept(char *err, int serversock, char *ip, size_t ip_len, int *port) {\n    int fd;\n    struct sockaddr_storage sa;\n    socklen_t salen = sizeof(sa);\n    if ((fd = anetGenericAccept(err,serversock,(struct sockaddr*)&sa,&salen)) == ANET_ERR)\n        return ANET_ERR;\n\n    if (sa.ss_family == AF_INET) {\n        struct sockaddr_in *s = (struct sockaddr_in *)&sa;\n        if (ip) inet_ntop(AF_INET,(void*)&(s->sin_addr),ip,ip_len);\n        if (port) *port = ntohs(s->sin_port);\n    } else {\n        struct sockaddr_in6 *s = (struct sockaddr_in6 *)&sa;\n        if (ip) inet_ntop(AF_INET6,(void*)&(s->sin6_addr),ip,ip_len);\n        if (port) *port = ntohs(s->sin6_port);\n    }\n    return fd;\n}\n\n/* Accept a connection and also make sure the socket is non-blocking, and CLOEXEC.\n * returns the new socket FD, or -1 on error. */\nint anetUnixAccept(char *err, int s) {\n    int fd;\n    struct sockaddr_un sa;\n    socklen_t salen = sizeof(sa);\n    if ((fd = anetGenericAccept(err,s,(struct sockaddr*)&sa,&salen)) == ANET_ERR)\n        return ANET_ERR;\n\n    return fd;\n}\n\nint anetFdToString(int fd, char *ip, size_t ip_len, int *port, int remote) {\n    struct sockaddr_storage sa;\n    socklen_t salen = sizeof(sa);\n\n    if (remote) {\n        if (getpeername(fd, (struct sockaddr *)&sa, &salen) == -1) goto error;\n    } else {\n        if (getsockname(fd, (struct sockaddr *)&sa, &salen) == -1) goto error;\n    }\n\n    if (sa.ss_family == AF_INET) {\n        struct sockaddr_in *s = (struct sockaddr_in *)&sa;\n        if (ip) {\n            if (inet_ntop(AF_INET,(void*)&(s->sin_addr),ip,ip_len) == NULL)\n                goto error;\n        }\n        if (port) *port = ntohs(s->sin_port);\n    } else if (sa.ss_family == AF_INET6) {\n        struct sockaddr_in6 *s = (struct sockaddr_in6 *)&sa;\n        if (ip) {\n            if (inet_ntop(AF_INET6,(void*)&(s->sin6_addr),ip,ip_len) == NULL)\n                goto error;\n        }\n        if (port) *port = ntohs(s->sin6_port);\n    } else if (sa.ss_family == AF_UNIX) {\n        if (ip) {\n            int res = snprintf(ip, ip_len, \"/unixsocket\");\n            if (res < 0 || (unsigned int) res >= ip_len) goto error;\n        }\n        if (port) *port = 0;\n    } else {\n        goto error;\n    }\n    return 0;\n\nerror:\n    if (ip) {\n        if (ip_len >= 2) {\n            ip[0] = '?';\n            ip[1] = '\\0';\n        } else if (ip_len == 1) {\n            ip[0] = '\\0';\n        }\n    }\n    if (port) *port = 0;\n    return -1;\n}\n\n/* Create a pipe buffer with given flags for read end and write end.\n * Note that it supports the file flags defined by pipe2() and fcntl(F_SETFL),\n * and one of the use cases is O_CLOEXEC|O_NONBLOCK. */\nint anetPipe(int fds[2], int read_flags, int write_flags) {\n    int pipe_flags = 0;\n#if defined(__linux__) || defined(__FreeBSD__)\n    /* When possible, try to leverage pipe2() to apply flags that are common to both ends.\n     * There is no harm to set O_CLOEXEC to prevent fd leaks. */\n    pipe_flags = O_CLOEXEC | (read_flags & write_flags);\n    if (pipe2(fds, pipe_flags)) {\n        /* Fail on real failures, and fallback to simple pipe if pipe2 is unsupported. */\n        if (errno != ENOSYS && errno != EINVAL)\n            return -1;\n        pipe_flags = 0;\n    } else {\n        /* If the flags on both ends are identical, no need to do anything else. */\n        if ((O_CLOEXEC | read_flags) == (O_CLOEXEC | write_flags))\n            return 0;\n        /* Clear the flags which have already been set using pipe2. */\n        read_flags &= ~pipe_flags;\n        write_flags &= ~pipe_flags;\n    }\n#endif\n\n    /* When we reach here with pipe_flags of 0, it means pipe2 failed (or was not attempted),\n     * so we try to use pipe. Otherwise, we skip and proceed to set specific flags below. */\n    if (pipe_flags == 0 && pipe(fds))\n        return -1;\n\n    /* File descriptor flags.\n     * Currently, only one such flag is defined: FD_CLOEXEC, the close-on-exec flag. */\n    if (read_flags & O_CLOEXEC)\n        if (fcntl(fds[0], F_SETFD, FD_CLOEXEC))\n            goto error;\n    if (write_flags & O_CLOEXEC)\n        if (fcntl(fds[1], F_SETFD, FD_CLOEXEC))\n            goto error;\n\n    /* File status flags after clearing the file descriptor flag O_CLOEXEC. */\n    read_flags &= ~O_CLOEXEC;\n    if (read_flags)\n        if (fcntl(fds[0], F_SETFL, read_flags))\n            goto error;\n    write_flags &= ~O_CLOEXEC;\n    if (write_flags)\n        if (fcntl(fds[1], F_SETFL, write_flags))\n            goto error;\n\n    return 0;\n\nerror:\n    close(fds[0]);\n    close(fds[1]);\n    return -1;\n}\n\nint anetSetSockMarkId(char *err, int fd, uint32_t id) {\n#ifdef HAVE_SOCKOPTMARKID\n    if (setsockopt(fd, SOL_SOCKET, SOCKOPTMARKID, (void *)&id, sizeof(id)) == -1) {\n        anetSetError(err, \"setsockopt: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n    return ANET_OK;\n#else\n    UNUSED(fd);\n    UNUSED(id);\n    anetSetError(err,\"anetSetSockMarkid unsupported on this platform\");\n    return ANET_OK;\n#endif\n}\n\nint anetIsFifo(char *filepath) {\n    struct stat sb;\n    if (stat(filepath, &sb) == -1) return 0;\n    return S_ISFIFO(sb.st_mode);\n}\n"], "filenames": ["src/anet.c"], "buggy_code_start_loc": [420], "buggy_code_end_loc": [515], "fixing_code_start_loc": [420], "fixing_code_end_loc": [516], "type": "CWE-668", "message": "Redis is an in-memory database that persists on disk. On startup, Redis begins listening on a Unix socket before adjusting its permissions to the user-provided configuration. If a permissive umask(2) is used, this creates a race condition that enables, during a short period of time, another process to establish an otherwise unauthorized connection. This problem has existed since Redis 2.6.0-RC1. This issue has been addressed in Redis versions 7.2.2, 7.0.14 and 6.2.14. Users are advised to upgrade. For users unable to upgrade, it is possible to work around the problem by disabling Unix sockets, starting Redis with a restrictive umask, or storing the Unix socket file in a protected directory.", "other": {"cve": {"id": "CVE-2023-45145", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-18T21:15:09.560", "lastModified": "2024-01-21T02:30:07.690", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Redis is an in-memory database that persists on disk. On startup, Redis begins listening on a Unix socket before adjusting its permissions to the user-provided configuration. If a permissive umask(2) is used, this creates a race condition that enables, during a short period of time, another process to establish an otherwise unauthorized connection. This problem has existed since Redis 2.6.0-RC1. This issue has been addressed in Redis versions 7.2.2, 7.0.14 and 6.2.14. Users are advised to upgrade. For users unable to upgrade, it is possible to work around the problem by disabling Unix sockets, starting Redis with a restrictive umask, or storing the Unix socket file in a protected directory."}, {"lang": "es", "value": "Redis es una base de datos en memoria que persiste en el disco. Al iniciarse, Redis comienza a escuchar en un socket Unix antes de ajustar sus permisos a la configuraci\u00f3n proporcionada por el usuario. Si se utiliza una umask(2) permisiva, esto crea una condici\u00f3n de ejecuci\u00f3n que permite, durante un corto per\u00edodo de tiempo, que otro proceso establezca una conexi\u00f3n que de otro modo no estar\u00eda autorizada. Este problema existe desde Redis 2.6.0-RC1. Este problema se solucion\u00f3 en las versiones 7.2.2, 7.0.14 y 6.2.14 de Redis. Se recomienda a los usuarios que actualicen. Para los usuarios que no pueden actualizar, es posible workaround el problema deshabilitando los sockets Unix, iniciando Redis con una m\u00e1scara de usuario restrictiva o almacenando el archivo del socket Unix en un directorio protegido."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.0, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.0, "impactScore": 2.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-668"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.6.0", "versionEndExcluding": "6.2.14", "matchCriteriaId": "2BC37265-09C9-4A98-A97A-3950F80D2641"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0", "versionEndExcluding": "7.0.14", "matchCriteriaId": "869B9F5D-E5C4-4C43-8F3D-1ECB973A6E71"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.2.0", "versionEndExcluding": "7.2.2", "matchCriteriaId": "484F4B31-F45C-4AD1-9D19-119E89039777"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:2.6.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "988AF66E-727F-4579-9BA8-55B42D534FE0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:39:*:*:*:*:*:*:*", "matchCriteriaId": "B8EDB836-4E6A-4B71-B9B2-AA3E03E0F646"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/redis/redis/commit/03345ddc7faf7af079485f2cbe5d17a1611cbce1", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/redis/redis/security/advisories/GHSA-ghmp-889m-7cvx", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/10/msg00032.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/464JPNBWE433ZGYXO3KN72VR3KJPWHAW/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BNEK2K4IE7MPKRD6H36JXZMJKYS6I5GQ/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DZMGTTV5XM4LA66FSIJSETNBBRRPJYOQ/", "source": "security-advisories@github.com", "tags": ["Mailing List"]}, {"url": "https://security.netapp.com/advisory/ntap-20231116-0014/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/redis/redis/commit/03345ddc7faf7af079485f2cbe5d17a1611cbce1"}}