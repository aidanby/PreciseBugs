{"buggy_code": ["const { parseType } = require('@strapi/utils');\n\n/*\n  Rules\n  1 in dynamicZones if on is found populate and fields get ignored\n  2 populating * populates 1 level + 1 level of dynamic zones\n  3 fields and populate in dynamic zones get replicated to all its children example:\n  fields=[\"field\"] If A and B both have the field field and c does not then field will be populated on a and b\n  4 if populate[name] = true then load 1 level deep + 1 level of dynamic zones\n\n*/\n\nconst protectPopulate = (populate, info) => {\n  let mainBoolean;\n  try {\n    mainBoolean = parseType('boolean', populate);\n  } catch (error) {\n    //Is not a boolean\n  }\n  if (mainBoolean === true || mainBoolean === false) {\n    populate = {};\n  }\n  //fields\n  if (typeof info.on === 'undefined') {\n    if (typeof info.fields === 'undefined') {\n      populate.fields = [];\n    } else if (typeof populate.fields === 'undefined') {\n      //Don't have to check main mainBoolean since if it is true fields is also \"undefined\"\n      populate.fields = info.fields;\n    } else if (Array.isArray(populate.fields)) {\n      let fields = [];\n      populate.fields.forEach((value) => {\n        if (info.fields.includes(value)) {\n          fields.push(value);\n        }\n      });\n      populate.fields = fields;\n    } else {\n      //Unexpected input handle it if it was empty\n      populate.fields = info.fields;\n    }\n  }\n  //Deal with array input for populate\n  if (Array.isArray(populate.populate)) {\n    const data = {};\n    populate.populate.forEach((key) => {\n      let data2 = data;\n      const list = key.split('.');\n      list.forEach((key) => {\n        if (typeof data2.populate === 'undefined') {\n          data2.populate = {};\n        }\n        if (typeof data2.populate[key] === 'undefined') {\n          data2.populate[key] = {};\n        }\n        data2 = data2.populate[key];\n      });\n    });\n    populate.populate = data.populate;\n  }\n\n  //on and populate\n  if (typeof info.on !== 'undefined') {\n    //dynamicZone\n    if (typeof populate.on !== 'undefined') {\n      //on\n      if (Object.keys(info.on).length === 0) {\n        populate = { on: {} };\n      } else if (mainBoolean == true) {\n        let populateAllowed = {};\n        for (const key of Object.keys(info.on)) {\n          let populateData = protectPopulate({}, info.on[key]);\n          populateAllowed[key] = populateData;\n        }\n        populate.on = populateAllowed;\n      } else if (typeof populate.on !== 'undefined') {\n        let populateAllowed = {};\n        for (const [key, _] of Object.entries(populate.on)) {\n          if (key in info.on) {\n            let data = protectPopulate(populate.on[key], info.on[key]);\n            populateAllowed[key] = data;\n          }\n        }\n        populate.on = populateAllowed;\n      }\n    } else if (typeof populate.populate !== 'undefined' || Array.isArray(populate.fields)) {\n      //populate\n      const AllowedList = {};\n      AllowedList['on'] = {};\n      Object.keys(info.on).forEach((key) => {\n        let data = protectPopulate(JSON.parse(JSON.stringify(populate)), info.on[key]);\n        AllowedList['on'][key] = data;\n      });\n      populate = AllowedList;\n    } else {\n      //empty\n      let AllowedList = {};\n      AllowedList['on'] = {};\n      Object.keys(info.on).forEach((key) => {\n        let data = protectPopulate({}, info.on[key]);\n        AllowedList['on'][key] = data;\n      });\n      delete populate['fields'];\n      delete populate['populate'];\n      populate = AllowedList;\n    }\n  } else {\n    //populate\n    if (typeof info.populate === 'undefined') {\n      populate.populate = {};\n    } else if (populate.populate === '*' || mainBoolean === true) {\n      let populateAllowed = {};\n      for (const key of Object.keys(info.populate)) {\n        let data = protectPopulate({}, info.populate[key]);\n        populateAllowed[key] = data;\n      }\n      populate.populate = populateAllowed;\n    } else if (typeof populate.populate !== 'undefined') {\n      let populateAllowed = {};\n      for (const [key, _] of Object.entries(populate.populate)) {\n        if (key in info.populate) {\n          let data = protectPopulate(populate.populate[key], info.populate[key]);\n          populateAllowed[key] = data;\n        }\n      }\n      populate.populate = populateAllowed;\n    }\n  }\n  return populate;\n};\n\nconst joinsFiltersArray = ['$or', '$and'];\nconst joinsFiltersObject = ['$not'];\nconst protectFilters = (filters, info) => {\n  if (filters === undefined) {\n    return undefined;\n  }\n  let filtersAllowed = {};\n  for (const key of Object.keys(filters)) {\n    //TODO check if joinsFilters are cease sensative\n    if (joinsFiltersArray.includes(key)) {\n      if (Array.isArray(filters[key])) {\n        filtersAllowed[key] = [];\n        for (const object of filters[key]) {\n          if (typeof object === 'object') {\n            filtersAllowed[key].push(protectFilters(object, info));\n          }\n        }\n      }\n    } else if (joinsFiltersObject.includes(key)) {\n      for (const object of Object.keys(filters[key])) {\n        if (typeof object === 'object') {\n          filtersAllowed[key] = protectFilters(object, info);\n        }\n      }\n    } else if (Array.isArray(info.fields) && info.fields.includes(key)) {\n      filtersAllowed[key] = filters[key];\n    } else if (info.populate !== undefined && info.populate[key] !== undefined) {\n      filtersAllowed[key] = protectFilters(filters[key], info.populate[key]);\n    }\n  }\n  return filtersAllowed;\n};\n\nconst protectRoute = (query, info) => {\n  const savePopulate = protectPopulate(query, info);\n  query.populate = savePopulate.populate;\n  query.fields = savePopulate.fields;\n  query.filters = protectFilters(query.filters, info);\n  return query;\n};\n\nmodule.exports = {\n  protectPopulate,\n  protectFilters,\n  protectRoute,\n};\n"], "fixing_code": ["const { parseType } = require('@strapi/utils');\n\n/*\n  Rules\n  1 in dynamicZones if on is found populate and fields get ignored\n  2 populating * populates 1 level + 1 level of dynamic zones\n  3 fields and populate in dynamic zones get replicated to all its children example:\n  fields=[\"field\"] If A and B both have the field field and c does not then field will be populated on a and b\n  4 if populate[name] = true then load 1 level deep + 1 level of dynamic zones\n\n*/\n\nconst protectPopulate = (populate, info) => {\n  let mainBoolean;\n  try {\n    mainBoolean = parseType('boolean', populate);\n  } catch (error) {\n    //Is not a boolean\n  }\n  if (mainBoolean === true || mainBoolean === false) {\n    populate = {};\n  }\n  //fields\n  if (typeof info.on === 'undefined') {\n    if (typeof info.fields === 'undefined') {\n      populate.fields = ['id'];\n    } else if (typeof populate.fields === 'undefined') {\n      //Don't have to check main mainBoolean since if it is true fields is also \"undefined\"\n      populate.fields = ['id', ...info.fields];\n    } else if (Array.isArray(populate.fields)) {\n      let fields = ['id'];\n      populate.fields.forEach((value) => {\n        if (info.fields.includes(value)) {\n          fields.push(value);\n        }\n      });\n      populate.fields = fields;\n    } else {\n      //Unexpected input handle it if it was empty\n      populate.fields = ['id', ...info.fields];\n    }\n  }\n  //Deal with array input for populate\n  if (Array.isArray(populate.populate)) {\n    const data = {};\n    populate.populate.forEach((key) => {\n      let data2 = data;\n      const list = key.split('.');\n      list.forEach((key) => {\n        if (typeof data2.populate === 'undefined') {\n          data2.populate = {};\n        }\n        if (typeof data2.populate[key] === 'undefined') {\n          data2.populate[key] = {};\n        }\n        data2 = data2.populate[key];\n      });\n    });\n    populate.populate = data.populate;\n  }\n\n  //on and populate\n  if (typeof info.on !== 'undefined') {\n    //dynamicZone\n    if (typeof populate.on !== 'undefined') {\n      //on\n      if (Object.keys(info.on).length === 0) {\n        populate = { on: {} };\n      } else if (mainBoolean == true) {\n        let populateAllowed = {};\n        for (const key of Object.keys(info.on)) {\n          let populateData = protectPopulate({}, info.on[key]);\n          populateAllowed[key] = populateData;\n        }\n        populate.on = populateAllowed;\n      } else if (typeof populate.on !== 'undefined') {\n        let populateAllowed = {};\n        for (const [key, _] of Object.entries(populate.on)) {\n          if (key in info.on) {\n            let data = protectPopulate(populate.on[key], info.on[key]);\n            populateAllowed[key] = data;\n          }\n        }\n        populate.on = populateAllowed;\n      }\n    } else if (typeof populate.populate !== 'undefined' || Array.isArray(populate.fields)) {\n      //populate\n      const AllowedList = {};\n      AllowedList['on'] = {};\n      Object.keys(info.on).forEach((key) => {\n        let data = protectPopulate(JSON.parse(JSON.stringify(populate)), info.on[key]);\n        AllowedList['on'][key] = data;\n      });\n      populate = AllowedList;\n    } else {\n      //empty\n      let AllowedList = {};\n      AllowedList['on'] = {};\n      Object.keys(info.on).forEach((key) => {\n        let data = protectPopulate({}, info.on[key]);\n        AllowedList['on'][key] = data;\n      });\n      delete populate['fields'];\n      delete populate['populate'];\n      populate = AllowedList;\n    }\n  } else {\n    //DZ\n    //populate\n    if (typeof info.populate === 'undefined') {\n      populate.populate = {};\n    } else if (populate.populate === '*' || mainBoolean === true) {\n      let populateAllowed = {};\n      for (const key of Object.keys(info.populate)) {\n        let data = protectPopulate({}, info.populate[key]);\n        populateAllowed[key] = data;\n      }\n      populate.populate = populateAllowed;\n    } else if (typeof populate.populate !== 'undefined') {\n      let populateAllowed = {};\n      for (const [key, _] of Object.entries(populate.populate)) {\n        if (key in info.populate) {\n          let data = protectPopulate(populate.populate[key], info.populate[key]);\n          populateAllowed[key] = data;\n        }\n      }\n      populate.populate = populateAllowed;\n    }\n  }\n  return populate;\n};\n\nconst joinsFiltersArray = ['$or', '$and'];\nconst joinsFiltersObject = ['$not'];\nconst protectFilters = (filters, info) => {\n  if (filters === undefined) {\n    return undefined;\n  }\n  let filtersAllowed = {};\n  for (const key of Object.keys(filters)) {\n    //TODO check if joinsFilters are cease sensative\n    if (joinsFiltersArray.includes(key)) {\n      if (Array.isArray(filters[key])) {\n        filtersAllowed[key] = [];\n        for (const object of filters[key]) {\n          if (typeof object === 'object') {\n            filtersAllowed[key].push(protectFilters(object, info));\n          }\n        }\n      }\n    } else if (joinsFiltersObject.includes(key)) {\n      for (const object of Object.keys(filters[key])) {\n        if (typeof object === 'object') {\n          filtersAllowed[key] = protectFilters(object, info);\n        }\n      }\n    } else if (Array.isArray(info.fields) && info.fields.includes(key)) {\n      filtersAllowed[key] = filters[key];\n    } else if (info.populate !== undefined && info.populate[key] !== undefined) {\n      filtersAllowed[key] = protectFilters(filters[key], info.populate[key]);\n    }\n  }\n  return filtersAllowed;\n};\n\nconst protectRoute = (query, info) => {\n  const savePopulate = protectPopulate(query, info);\n  query.populate = savePopulate.populate || savePopulate.on;\n  query.fields = savePopulate.fields;\n  query.filters = protectFilters(query.filters, info);\n  return query;\n};\n\nmodule.exports = {\n  protectPopulate,\n  protectFilters,\n  protectRoute,\n};\n"], "filenames": ["server/middlewares/helpers/protect-route.js"], "buggy_code_start_loc": [26], "buggy_code_end_loc": [168], "fixing_code_start_loc": [26], "fixing_code_end_loc": [169], "type": "CWE-863", "message": "The Strapi Protected Populate Plugin protects `get` endpoints from revealing too much information. Prior to version 1.3.4, users were able to bypass the field level security. Users who tried to populate something that they didn't have access to could populate those fields anyway. This issue has been patched in version 1.3.4. There are no known workarounds.", "other": {"cve": {"id": "CVE-2023-48218", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-20T17:15:13.543", "lastModified": "2023-11-29T20:52:27.770", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Strapi Protected Populate Plugin protects `get` endpoints from revealing too much information. Prior to version 1.3.4, users were able to bypass the field level security. Users who tried to populate something that they didn't have access to could populate those fields anyway. This issue has been patched in version 1.3.4. There are no known workarounds."}, {"lang": "es", "value": "El complemento Strapi Protected Populate protege los endpoints \"get\" para que no revelen demasiada informaci\u00f3n. Antes de la versi\u00f3n 1.3.4, los usuarios pod\u00edan omitir la seguridad a nivel de campo. Los usuarios que intentaron completar algo a lo que no ten\u00edan acceso pod\u00edan completar esos campos de todos modos. Este problema se solucion\u00f3 en la versi\u00f3n 1.3.4. No se conocen workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:strapi:protected_populate:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.4", "matchCriteriaId": "7E302923-4968-48AB-BA63-4F0EFA16885B"}]}]}], "references": [{"url": "https://github.com/strapi-community/strapi-plugin-protected-populate/commit/05441066d64e09dd55937d9f089962e9ebe2fb39", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/strapi-community/strapi-plugin-protected-populate/releases/tag/v1.3.4", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/strapi-community/strapi-plugin-protected-populate/security/advisories/GHSA-6h67-934r-82g7", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/strapi-community/strapi-plugin-protected-populate/commit/05441066d64e09dd55937d9f089962e9ebe2fb39"}}