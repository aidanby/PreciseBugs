{"buggy_code": ["/*\n * DCCP connection tracking protocol helper\n *\n * Copyright (c) 2005, 2006, 2008 Patrick McHardy <kaber@trash.net>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n *\n */\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/spinlock.h>\n#include <linux/skbuff.h>\n#include <linux/dccp.h>\n#include <linux/slab.h>\n\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n\n#include <linux/netfilter/nfnetlink_conntrack.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_l4proto.h>\n#include <net/netfilter/nf_conntrack_ecache.h>\n#include <net/netfilter/nf_log.h>\n\n/* Timeouts are based on values from RFC4340:\n *\n * - REQUEST:\n *\n *   8.1.2. Client Request\n *\n *   A client MAY give up on its DCCP-Requests after some time\n *   (3 minutes, for example).\n *\n * - RESPOND:\n *\n *   8.1.3. Server Response\n *\n *   It MAY also leave the RESPOND state for CLOSED after a timeout of\n *   not less than 4MSL (8 minutes);\n *\n * - PARTOPEN:\n *\n *   8.1.5. Handshake Completion\n *\n *   If the client remains in PARTOPEN for more than 4MSL (8 minutes),\n *   it SHOULD reset the connection with Reset Code 2, \"Aborted\".\n *\n * - OPEN:\n *\n *   The DCCP timestamp overflows after 11.9 hours. If the connection\n *   stays idle this long the sequence number won't be recognized\n *   as valid anymore.\n *\n * - CLOSEREQ/CLOSING:\n *\n *   8.3. Termination\n *\n *   The retransmission timer should initially be set to go off in two\n *   round-trip times and should back off to not less than once every\n *   64 seconds ...\n *\n * - TIMEWAIT:\n *\n *   4.3. States\n *\n *   A server or client socket remains in this state for 2MSL (4 minutes)\n *   after the connection has been town down, ...\n */\n\n#define DCCP_MSL (2 * 60 * HZ)\n\nstatic const char * const dccp_state_names[] = {\n\t[CT_DCCP_NONE]\t\t= \"NONE\",\n\t[CT_DCCP_REQUEST]\t= \"REQUEST\",\n\t[CT_DCCP_RESPOND]\t= \"RESPOND\",\n\t[CT_DCCP_PARTOPEN]\t= \"PARTOPEN\",\n\t[CT_DCCP_OPEN]\t\t= \"OPEN\",\n\t[CT_DCCP_CLOSEREQ]\t= \"CLOSEREQ\",\n\t[CT_DCCP_CLOSING]\t= \"CLOSING\",\n\t[CT_DCCP_TIMEWAIT]\t= \"TIMEWAIT\",\n\t[CT_DCCP_IGNORE]\t= \"IGNORE\",\n\t[CT_DCCP_INVALID]\t= \"INVALID\",\n};\n\n#define sNO\tCT_DCCP_NONE\n#define sRQ\tCT_DCCP_REQUEST\n#define sRS\tCT_DCCP_RESPOND\n#define sPO\tCT_DCCP_PARTOPEN\n#define sOP\tCT_DCCP_OPEN\n#define sCR\tCT_DCCP_CLOSEREQ\n#define sCG\tCT_DCCP_CLOSING\n#define sTW\tCT_DCCP_TIMEWAIT\n#define sIG\tCT_DCCP_IGNORE\n#define sIV\tCT_DCCP_INVALID\n\n/*\n * DCCP state transition table\n *\n * The assumption is the same as for TCP tracking:\n *\n * We are the man in the middle. All the packets go through us but might\n * get lost in transit to the destination. It is assumed that the destination\n * can't receive segments we haven't seen.\n *\n * The following states exist:\n *\n * NONE:\tInitial state, expecting Request\n * REQUEST:\tRequest seen, waiting for Response from server\n * RESPOND:\tResponse from server seen, waiting for Ack from client\n * PARTOPEN:\tAck after Response seen, waiting for packet other than Response,\n * \t\tReset or Sync from server\n * OPEN:\tPacket other than Response, Reset or Sync seen\n * CLOSEREQ:\tCloseReq from server seen, expecting Close from client\n * CLOSING:\tClose seen, expecting Reset\n * TIMEWAIT:\tReset seen\n * IGNORE:\tNot determinable whether packet is valid\n *\n * Some states exist only on one side of the connection: REQUEST, RESPOND,\n * PARTOPEN, CLOSEREQ. For the other side these states are equivalent to\n * the one it was in before.\n *\n * Packets are marked as ignored (sIG) if we don't know if they're valid\n * (for example a reincarnation of a connection we didn't notice is dead\n * already) and the server may send back a connection closing Reset or a\n * Response. They're also used for Sync/SyncAck packets, which we don't\n * care about.\n */\nstatic const u_int8_t\ndccp_state_table[CT_DCCP_ROLE_MAX + 1][DCCP_PKT_SYNCACK + 1][CT_DCCP_MAX + 1] = {\n\t[CT_DCCP_ROLE_CLIENT] = {\n\t\t[DCCP_PKT_REQUEST] = {\n\t\t/*\n\t\t * sNO -> sRQ\t\tRegular Request\n\t\t * sRQ -> sRQ\t\tRetransmitted Request or reincarnation\n\t\t * sRS -> sRS\t\tRetransmitted Request (apparently Response\n\t\t * \t\t\tgot lost after we saw it) or reincarnation\n\t\t * sPO -> sIG\t\tIgnore, conntrack might be out of sync\n\t\t * sOP -> sIG\t\tIgnore, conntrack might be out of sync\n\t\t * sCR -> sIG\t\tIgnore, conntrack might be out of sync\n\t\t * sCG -> sIG\t\tIgnore, conntrack might be out of sync\n\t\t * sTW -> sRQ\t\tReincarnation\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO. sOP, sCR, sCG, sTW, */\n\t\t\tsRQ, sRQ, sRS, sIG, sIG, sIG, sIG, sRQ,\n\t\t},\n\t\t[DCCP_PKT_RESPONSE] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tInvalid\n\t\t * sRQ -> sIG\t\tIgnore, might be response to ignored Request\n\t\t * sRS -> sIG\t\tIgnore, might be response to ignored Request\n\t\t * sPO -> sIG\t\tIgnore, might be response to ignored Request\n\t\t * sOP -> sIG\t\tIgnore, might be response to ignored Request\n\t\t * sCR -> sIG\t\tIgnore, might be response to ignored Request\n\t\t * sCG -> sIG\t\tIgnore, might be response to ignored Request\n\t\t * sTW -> sIV\t\tInvalid, reincarnation in reverse direction\n\t\t *\t\t\tgoes through sRQ\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIG, sIG, sIG, sIG, sIG, sIG, sIV,\n\t\t},\n\t\t[DCCP_PKT_ACK] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tNo connection\n\t\t * sRQ -> sIV\t\tNo connection\n\t\t * sRS -> sPO\t\tAck for Response, move to PARTOPEN (8.1.5.)\n\t\t * sPO -> sPO\t\tRetransmitted Ack for Response, remain in PARTOPEN\n\t\t * sOP -> sOP\t\tRegular ACK, remain in OPEN\n\t\t * sCR -> sCR\t\tAck in CLOSEREQ MAY be processed (8.3.)\n\t\t * sCG -> sCG\t\tAck in CLOSING MAY be processed (8.3.)\n\t\t * sTW -> sIV\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIV, sPO, sPO, sOP, sCR, sCG, sIV\n\t\t},\n\t\t[DCCP_PKT_DATA] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tNo connection\n\t\t * sRQ -> sIV\t\tNo connection\n\t\t * sRS -> sIV\t\tNo connection\n\t\t * sPO -> sIV\t\tMUST use DataAck in PARTOPEN state (8.1.5.)\n\t\t * sOP -> sOP\t\tRegular Data packet\n\t\t * sCR -> sCR\t\tData in CLOSEREQ MAY be processed (8.3.)\n\t\t * sCG -> sCG\t\tData in CLOSING MAY be processed (8.3.)\n\t\t * sTW -> sIV\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIV, sIV, sIV, sOP, sCR, sCG, sIV,\n\t\t},\n\t\t[DCCP_PKT_DATAACK] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tNo connection\n\t\t * sRQ -> sIV\t\tNo connection\n\t\t * sRS -> sPO\t\tAck for Response, move to PARTOPEN (8.1.5.)\n\t\t * sPO -> sPO\t\tRemain in PARTOPEN state\n\t\t * sOP -> sOP\t\tRegular DataAck packet in OPEN state\n\t\t * sCR -> sCR\t\tDataAck in CLOSEREQ MAY be processed (8.3.)\n\t\t * sCG -> sCG\t\tDataAck in CLOSING MAY be processed (8.3.)\n\t\t * sTW -> sIV\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIV, sPO, sPO, sOP, sCR, sCG, sIV\n\t\t},\n\t\t[DCCP_PKT_CLOSEREQ] = {\n\t\t/*\n\t\t * CLOSEREQ may only be sent by the server.\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIV, sIV, sIV, sIV, sIV, sIV, sIV\n\t\t},\n\t\t[DCCP_PKT_CLOSE] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tNo connection\n\t\t * sRQ -> sIV\t\tNo connection\n\t\t * sRS -> sIV\t\tNo connection\n\t\t * sPO -> sCG\t\tClient-initiated close\n\t\t * sOP -> sCG\t\tClient-initiated close\n\t\t * sCR -> sCG\t\tClose in response to CloseReq (8.3.)\n\t\t * sCG -> sCG\t\tRetransmit\n\t\t * sTW -> sIV\t\tLate retransmit, already in TIME_WAIT\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIV, sIV, sCG, sCG, sCG, sIV, sIV\n\t\t},\n\t\t[DCCP_PKT_RESET] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tNo connection\n\t\t * sRQ -> sTW\t\tSync received or timeout, SHOULD send Reset (8.1.1.)\n\t\t * sRS -> sTW\t\tResponse received without Request\n\t\t * sPO -> sTW\t\tTimeout, SHOULD send Reset (8.1.5.)\n\t\t * sOP -> sTW\t\tConnection reset\n\t\t * sCR -> sTW\t\tConnection reset\n\t\t * sCG -> sTW\t\tConnection reset\n\t\t * sTW -> sIG\t\tIgnore (don't refresh timer)\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sTW, sTW, sTW, sTW, sTW, sTW, sIG\n\t\t},\n\t\t[DCCP_PKT_SYNC] = {\n\t\t/*\n\t\t * We currently ignore Sync packets\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIG, sIG, sIG, sIG, sIG, sIG, sIG, sIG,\n\t\t},\n\t\t[DCCP_PKT_SYNCACK] = {\n\t\t/*\n\t\t * We currently ignore SyncAck packets\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIG, sIG, sIG, sIG, sIG, sIG, sIG, sIG,\n\t\t},\n\t},\n\t[CT_DCCP_ROLE_SERVER] = {\n\t\t[DCCP_PKT_REQUEST] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tInvalid\n\t\t * sRQ -> sIG\t\tIgnore, conntrack might be out of sync\n\t\t * sRS -> sIG\t\tIgnore, conntrack might be out of sync\n\t\t * sPO -> sIG\t\tIgnore, conntrack might be out of sync\n\t\t * sOP -> sIG\t\tIgnore, conntrack might be out of sync\n\t\t * sCR -> sIG\t\tIgnore, conntrack might be out of sync\n\t\t * sCG -> sIG\t\tIgnore, conntrack might be out of sync\n\t\t * sTW -> sRQ\t\tReincarnation, must reverse roles\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIG, sIG, sIG, sIG, sIG, sIG, sRQ\n\t\t},\n\t\t[DCCP_PKT_RESPONSE] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tResponse without Request\n\t\t * sRQ -> sRS\t\tResponse to clients Request\n\t\t * sRS -> sRS\t\tRetransmitted Response (8.1.3. SHOULD NOT)\n\t\t * sPO -> sIG\t\tResponse to an ignored Request or late retransmit\n\t\t * sOP -> sIG\t\tIgnore, might be response to ignored Request\n\t\t * sCR -> sIG\t\tIgnore, might be response to ignored Request\n\t\t * sCG -> sIG\t\tIgnore, might be response to ignored Request\n\t\t * sTW -> sIV\t\tInvalid, Request from client in sTW moves to sRQ\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sRS, sRS, sIG, sIG, sIG, sIG, sIV\n\t\t},\n\t\t[DCCP_PKT_ACK] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tNo connection\n\t\t * sRQ -> sIV\t\tNo connection\n\t\t * sRS -> sIV\t\tNo connection\n\t\t * sPO -> sOP\t\tEnter OPEN state (8.1.5.)\n\t\t * sOP -> sOP\t\tRegular Ack in OPEN state\n\t\t * sCR -> sIV\t\tWaiting for Close from client\n\t\t * sCG -> sCG\t\tAck in CLOSING MAY be processed (8.3.)\n\t\t * sTW -> sIV\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIV, sIV, sOP, sOP, sIV, sCG, sIV\n\t\t},\n\t\t[DCCP_PKT_DATA] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tNo connection\n\t\t * sRQ -> sIV\t\tNo connection\n\t\t * sRS -> sIV\t\tNo connection\n\t\t * sPO -> sOP\t\tEnter OPEN state (8.1.5.)\n\t\t * sOP -> sOP\t\tRegular Data packet in OPEN state\n\t\t * sCR -> sIV\t\tWaiting for Close from client\n\t\t * sCG -> sCG\t\tData in CLOSING MAY be processed (8.3.)\n\t\t * sTW -> sIV\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIV, sIV, sOP, sOP, sIV, sCG, sIV\n\t\t},\n\t\t[DCCP_PKT_DATAACK] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tNo connection\n\t\t * sRQ -> sIV\t\tNo connection\n\t\t * sRS -> sIV\t\tNo connection\n\t\t * sPO -> sOP\t\tEnter OPEN state (8.1.5.)\n\t\t * sOP -> sOP\t\tRegular DataAck in OPEN state\n\t\t * sCR -> sIV\t\tWaiting for Close from client\n\t\t * sCG -> sCG\t\tData in CLOSING MAY be processed (8.3.)\n\t\t * sTW -> sIV\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIV, sIV, sOP, sOP, sIV, sCG, sIV\n\t\t},\n\t\t[DCCP_PKT_CLOSEREQ] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tNo connection\n\t\t * sRQ -> sIV\t\tNo connection\n\t\t * sRS -> sIV\t\tNo connection\n\t\t * sPO -> sOP -> sCR\tMove directly to CLOSEREQ (8.1.5.)\n\t\t * sOP -> sCR\t\tCloseReq in OPEN state\n\t\t * sCR -> sCR\t\tRetransmit\n\t\t * sCG -> sCR\t\tSimultaneous close, client sends another Close\n\t\t * sTW -> sIV\t\tAlready closed\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIV, sIV, sCR, sCR, sCR, sCR, sIV\n\t\t},\n\t\t[DCCP_PKT_CLOSE] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tNo connection\n\t\t * sRQ -> sIV\t\tNo connection\n\t\t * sRS -> sIV\t\tNo connection\n\t\t * sPO -> sOP -> sCG\tMove direcly to CLOSING\n\t\t * sOP -> sCG\t\tMove to CLOSING\n\t\t * sCR -> sIV\t\tClose after CloseReq is invalid\n\t\t * sCG -> sCG\t\tRetransmit\n\t\t * sTW -> sIV\t\tAlready closed\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIV, sIV, sCG, sCG, sIV, sCG, sIV\n\t\t},\n\t\t[DCCP_PKT_RESET] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tNo connection\n\t\t * sRQ -> sTW\t\tReset in response to Request\n\t\t * sRS -> sTW\t\tTimeout, SHOULD send Reset (8.1.3.)\n\t\t * sPO -> sTW\t\tTimeout, SHOULD send Reset (8.1.3.)\n\t\t * sOP -> sTW\n\t\t * sCR -> sTW\n\t\t * sCG -> sTW\n\t\t * sTW -> sIG\t\tIgnore (don't refresh timer)\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW, sTW */\n\t\t\tsIV, sTW, sTW, sTW, sTW, sTW, sTW, sTW, sIG\n\t\t},\n\t\t[DCCP_PKT_SYNC] = {\n\t\t/*\n\t\t * We currently ignore Sync packets\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIG, sIG, sIG, sIG, sIG, sIG, sIG, sIG,\n\t\t},\n\t\t[DCCP_PKT_SYNCACK] = {\n\t\t/*\n\t\t * We currently ignore SyncAck packets\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIG, sIG, sIG, sIG, sIG, sIG, sIG, sIG,\n\t\t},\n\t},\n};\n\n/* this module per-net specifics */\nstatic int dccp_net_id __read_mostly;\nstruct dccp_net {\n\tstruct nf_proto_net pn;\n\tint dccp_loose;\n\tunsigned int dccp_timeout[CT_DCCP_MAX + 1];\n};\n\nstatic inline struct dccp_net *dccp_pernet(struct net *net)\n{\n\treturn net_generic(net, dccp_net_id);\n}\n\nstatic bool dccp_pkt_to_tuple(const struct sk_buff *skb, unsigned int dataoff,\n\t\t\t      struct nf_conntrack_tuple *tuple)\n{\n\tstruct dccp_hdr _hdr, *dh;\n\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_hdr), &_hdr);\n\tif (dh == NULL)\n\t\treturn false;\n\n\ttuple->src.u.dccp.port = dh->dccph_sport;\n\ttuple->dst.u.dccp.port = dh->dccph_dport;\n\treturn true;\n}\n\nstatic bool dccp_invert_tuple(struct nf_conntrack_tuple *inv,\n\t\t\t      const struct nf_conntrack_tuple *tuple)\n{\n\tinv->src.u.dccp.port = tuple->dst.u.dccp.port;\n\tinv->dst.u.dccp.port = tuple->src.u.dccp.port;\n\treturn true;\n}\n\nstatic bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t     unsigned int dataoff, unsigned int *timeouts)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tstruct dccp_net *dn;\n\tstruct dccp_hdr _dh, *dh;\n\tconst char *msg;\n\tu_int8_t state;\n\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tBUG_ON(dh == NULL);\n\n\tstate = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];\n\tswitch (state) {\n\tdefault:\n\t\tdn = dccp_pernet(net);\n\t\tif (dn->dccp_loose == 0) {\n\t\t\tmsg = \"nf_ct_dccp: not picking up existing connection \";\n\t\t\tgoto out_invalid;\n\t\t}\n\tcase CT_DCCP_REQUEST:\n\t\tbreak;\n\tcase CT_DCCP_INVALID:\n\t\tmsg = \"nf_ct_dccp: invalid state transition \";\n\t\tgoto out_invalid;\n\t}\n\n\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\n\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\n\tct->proto.dccp.state = CT_DCCP_NONE;\n\tct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;\n\tct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;\n\tct->proto.dccp.handshake_seq = 0;\n\treturn true;\n\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, nf_ct_l3num(ct), 0, skb, NULL, NULL,\n\t\t\t      NULL, \"%s\", msg);\n\treturn false;\n}\n\nstatic u64 dccp_ack_seq(const struct dccp_hdr *dh)\n{\n\tconst struct dccp_hdr_ack_bits *dhack;\n\n\tdhack = (void *)dh + __dccp_basic_hdr_len(dh);\n\treturn ((u64)ntohs(dhack->dccph_ack_nr_high) << 32) +\n\t\t     ntohl(dhack->dccph_ack_nr_low);\n}\n\nstatic unsigned int *dccp_get_timeouts(struct net *net)\n{\n\treturn dccp_pernet(net)->dccp_timeout;\n}\n\nstatic int dccp_packet(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t       unsigned int dataoff, enum ip_conntrack_info ctinfo,\n\t\t       u_int8_t pf, unsigned int hooknum,\n\t\t       unsigned int *timeouts)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\tstruct dccp_hdr _dh, *dh;\n\tu_int8_t type, old_state, new_state;\n\tenum ct_dccp_roles role;\n\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tBUG_ON(dh == NULL);\n\ttype = dh->dccph_type;\n\n\tif (type == DCCP_PKT_RESET &&\n\t    !test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {\n\t\t/* Tear down connection immediately if only reply is a RESET */\n\t\tnf_ct_kill_acct(ct, ctinfo, skb);\n\t\treturn NF_ACCEPT;\n\t}\n\n\tspin_lock_bh(&ct->lock);\n\n\trole = ct->proto.dccp.role[dir];\n\told_state = ct->proto.dccp.state;\n\tnew_state = dccp_state_table[role][type][old_state];\n\n\tswitch (new_state) {\n\tcase CT_DCCP_REQUEST:\n\t\tif (old_state == CT_DCCP_TIMEWAIT &&\n\t\t    role == CT_DCCP_ROLE_SERVER) {\n\t\t\t/* Reincarnation in the reverse direction: reopen and\n\t\t\t * reverse client/server roles. */\n\t\t\tct->proto.dccp.role[dir] = CT_DCCP_ROLE_CLIENT;\n\t\t\tct->proto.dccp.role[!dir] = CT_DCCP_ROLE_SERVER;\n\t\t}\n\t\tbreak;\n\tcase CT_DCCP_RESPOND:\n\t\tif (old_state == CT_DCCP_REQUEST)\n\t\t\tct->proto.dccp.handshake_seq = dccp_hdr_seq(dh);\n\t\tbreak;\n\tcase CT_DCCP_PARTOPEN:\n\t\tif (old_state == CT_DCCP_RESPOND &&\n\t\t    type == DCCP_PKT_ACK &&\n\t\t    dccp_ack_seq(dh) == ct->proto.dccp.handshake_seq)\n\t\t\tset_bit(IPS_ASSURED_BIT, &ct->status);\n\t\tbreak;\n\tcase CT_DCCP_IGNORE:\n\t\t/*\n\t\t * Connection tracking might be out of sync, so we ignore\n\t\t * packets that might establish a new connection and resync\n\t\t * if the server responds with a valid Response.\n\t\t */\n\t\tif (ct->proto.dccp.last_dir == !dir &&\n\t\t    ct->proto.dccp.last_pkt == DCCP_PKT_REQUEST &&\n\t\t    type == DCCP_PKT_RESPONSE) {\n\t\t\tct->proto.dccp.role[!dir] = CT_DCCP_ROLE_CLIENT;\n\t\t\tct->proto.dccp.role[dir] = CT_DCCP_ROLE_SERVER;\n\t\t\tct->proto.dccp.handshake_seq = dccp_hdr_seq(dh);\n\t\t\tnew_state = CT_DCCP_RESPOND;\n\t\t\tbreak;\n\t\t}\n\t\tct->proto.dccp.last_dir = dir;\n\t\tct->proto.dccp.last_pkt = type;\n\n\t\tspin_unlock_bh(&ct->lock);\n\t\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL,\n\t\t\t\t      \"nf_ct_dccp: invalid packet ignored \");\n\t\treturn NF_ACCEPT;\n\tcase CT_DCCP_INVALID:\n\t\tspin_unlock_bh(&ct->lock);\n\t\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL,\n\t\t\t\t      \"nf_ct_dccp: invalid state transition \");\n\t\treturn -NF_ACCEPT;\n\t}\n\n\tct->proto.dccp.last_dir = dir;\n\tct->proto.dccp.last_pkt = type;\n\tct->proto.dccp.state = new_state;\n\tspin_unlock_bh(&ct->lock);\n\n\tif (new_state != old_state)\n\t\tnf_conntrack_event_cache(IPCT_PROTOINFO, ct);\n\n\tnf_ct_refresh_acct(ct, ctinfo, skb, timeouts[new_state]);\n\n\treturn NF_ACCEPT;\n}\n\nstatic int dccp_error(struct net *net, struct nf_conn *tmpl,\n\t\t      struct sk_buff *skb, unsigned int dataoff,\n\t\t      enum ip_conntrack_info *ctinfo,\n\t\t      u_int8_t pf, unsigned int hooknum)\n{\n\tstruct dccp_hdr _dh, *dh;\n\tunsigned int dccp_len = skb->len - dataoff;\n\tunsigned int cscov;\n\tconst char *msg;\n\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tif (dh == NULL) {\n\t\tmsg = \"nf_ct_dccp: short packet \";\n\t\tgoto out_invalid;\n\t}\n\n\tif (dh->dccph_doff * 4 < sizeof(struct dccp_hdr) ||\n\t    dh->dccph_doff * 4 > dccp_len) {\n\t\tmsg = \"nf_ct_dccp: truncated/malformed packet \";\n\t\tgoto out_invalid;\n\t}\n\n\tcscov = dccp_len;\n\tif (dh->dccph_cscov) {\n\t\tcscov = (dh->dccph_cscov - 1) * 4;\n\t\tif (cscov > dccp_len) {\n\t\t\tmsg = \"nf_ct_dccp: bad checksum coverage \";\n\t\t\tgoto out_invalid;\n\t\t}\n\t}\n\n\tif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\n\t    nf_checksum_partial(skb, hooknum, dataoff, cscov, IPPROTO_DCCP,\n\t\t\t\tpf)) {\n\t\tmsg = \"nf_ct_dccp: bad checksum \";\n\t\tgoto out_invalid;\n\t}\n\n\tif (dh->dccph_type >= DCCP_PKT_INVALID) {\n\t\tmsg = \"nf_ct_dccp: reserved packet type \";\n\t\tgoto out_invalid;\n\t}\n\n\treturn NF_ACCEPT;\n\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL, \"%s\", msg);\n\treturn -NF_ACCEPT;\n}\n\nstatic int dccp_print_tuple(struct seq_file *s,\n\t\t\t    const struct nf_conntrack_tuple *tuple)\n{\n\treturn seq_printf(s, \"sport=%hu dport=%hu \",\n\t\t\t  ntohs(tuple->src.u.dccp.port),\n\t\t\t  ntohs(tuple->dst.u.dccp.port));\n}\n\nstatic int dccp_print_conntrack(struct seq_file *s, struct nf_conn *ct)\n{\n\treturn seq_printf(s, \"%s \", dccp_state_names[ct->proto.dccp.state]);\n}\n\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK)\nstatic int dccp_to_nlattr(struct sk_buff *skb, struct nlattr *nla,\n\t\t\t  struct nf_conn *ct)\n{\n\tstruct nlattr *nest_parms;\n\n\tspin_lock_bh(&ct->lock);\n\tnest_parms = nla_nest_start(skb, CTA_PROTOINFO_DCCP | NLA_F_NESTED);\n\tif (!nest_parms)\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(skb, CTA_PROTOINFO_DCCP_STATE, ct->proto.dccp.state) ||\n\t    nla_put_u8(skb, CTA_PROTOINFO_DCCP_ROLE,\n\t\t       ct->proto.dccp.role[IP_CT_DIR_ORIGINAL]) ||\n\t    nla_put_be64(skb, CTA_PROTOINFO_DCCP_HANDSHAKE_SEQ,\n\t\t\t cpu_to_be64(ct->proto.dccp.handshake_seq)))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest_parms);\n\tspin_unlock_bh(&ct->lock);\n\treturn 0;\n\nnla_put_failure:\n\tspin_unlock_bh(&ct->lock);\n\treturn -1;\n}\n\nstatic const struct nla_policy dccp_nla_policy[CTA_PROTOINFO_DCCP_MAX + 1] = {\n\t[CTA_PROTOINFO_DCCP_STATE]\t= { .type = NLA_U8 },\n\t[CTA_PROTOINFO_DCCP_ROLE]\t= { .type = NLA_U8 },\n\t[CTA_PROTOINFO_DCCP_HANDSHAKE_SEQ] = { .type = NLA_U64 },\n};\n\nstatic int nlattr_to_dccp(struct nlattr *cda[], struct nf_conn *ct)\n{\n\tstruct nlattr *attr = cda[CTA_PROTOINFO_DCCP];\n\tstruct nlattr *tb[CTA_PROTOINFO_DCCP_MAX + 1];\n\tint err;\n\n\tif (!attr)\n\t\treturn 0;\n\n\terr = nla_parse_nested(tb, CTA_PROTOINFO_DCCP_MAX, attr,\n\t\t\t       dccp_nla_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[CTA_PROTOINFO_DCCP_STATE] ||\n\t    !tb[CTA_PROTOINFO_DCCP_ROLE] ||\n\t    nla_get_u8(tb[CTA_PROTOINFO_DCCP_ROLE]) > CT_DCCP_ROLE_MAX ||\n\t    nla_get_u8(tb[CTA_PROTOINFO_DCCP_STATE]) >= CT_DCCP_IGNORE) {\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_bh(&ct->lock);\n\tct->proto.dccp.state = nla_get_u8(tb[CTA_PROTOINFO_DCCP_STATE]);\n\tif (nla_get_u8(tb[CTA_PROTOINFO_DCCP_ROLE]) == CT_DCCP_ROLE_CLIENT) {\n\t\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\n\t\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\n\t} else {\n\t\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_SERVER;\n\t\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_CLIENT;\n\t}\n\tif (tb[CTA_PROTOINFO_DCCP_HANDSHAKE_SEQ]) {\n\t\tct->proto.dccp.handshake_seq =\n\t\tbe64_to_cpu(nla_get_be64(tb[CTA_PROTOINFO_DCCP_HANDSHAKE_SEQ]));\n\t}\n\tspin_unlock_bh(&ct->lock);\n\treturn 0;\n}\n\nstatic int dccp_nlattr_size(void)\n{\n\treturn nla_total_size(0)\t/* CTA_PROTOINFO_DCCP */\n\t\t+ nla_policy_len(dccp_nla_policy, CTA_PROTOINFO_DCCP_MAX + 1);\n}\n\n#endif\n\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK_TIMEOUT)\n\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nfnetlink_cttimeout.h>\n\nstatic int dccp_timeout_nlattr_to_obj(struct nlattr *tb[],\n\t\t\t\t      struct net *net, void *data)\n{\n\tstruct dccp_net *dn = dccp_pernet(net);\n\tunsigned int *timeouts = data;\n\tint i;\n\n\t/* set default DCCP timeouts. */\n\tfor (i=0; i<CT_DCCP_MAX; i++)\n\t\ttimeouts[i] = dn->dccp_timeout[i];\n\n\t/* there's a 1:1 mapping between attributes and protocol states. */\n\tfor (i=CTA_TIMEOUT_DCCP_UNSPEC+1; i<CTA_TIMEOUT_DCCP_MAX+1; i++) {\n\t\tif (tb[i]) {\n\t\t\ttimeouts[i] = ntohl(nla_get_be32(tb[i])) * HZ;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\ndccp_timeout_obj_to_nlattr(struct sk_buff *skb, const void *data)\n{\n        const unsigned int *timeouts = data;\n\tint i;\n\n\tfor (i=CTA_TIMEOUT_DCCP_UNSPEC+1; i<CTA_TIMEOUT_DCCP_MAX+1; i++) {\n\t\tif (nla_put_be32(skb, i, htonl(timeouts[i] / HZ)))\n\t\t\tgoto nla_put_failure;\n\t}\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOSPC;\n}\n\nstatic const struct nla_policy\ndccp_timeout_nla_policy[CTA_TIMEOUT_DCCP_MAX+1] = {\n\t[CTA_TIMEOUT_DCCP_REQUEST]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_DCCP_RESPOND]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_DCCP_PARTOPEN]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_DCCP_OPEN]\t\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_DCCP_CLOSEREQ]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_DCCP_CLOSING]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_DCCP_TIMEWAIT]\t= { .type = NLA_U32 },\n};\n#endif /* CONFIG_NF_CT_NETLINK_TIMEOUT */\n\n#ifdef CONFIG_SYSCTL\n/* template, data assigned later */\nstatic struct ctl_table dccp_sysctl_table[] = {\n\t{\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_request\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_respond\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_partopen\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_open\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_closereq\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_closing\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_timewait\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"nf_conntrack_dccp_loose\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{ }\n};\n#endif /* CONFIG_SYSCTL */\n\nstatic int dccp_kmemdup_sysctl_table(struct net *net, struct nf_proto_net *pn,\n\t\t\t\t     struct dccp_net *dn)\n{\n#ifdef CONFIG_SYSCTL\n\tif (pn->ctl_table)\n\t\treturn 0;\n\n\tpn->ctl_table = kmemdup(dccp_sysctl_table,\n\t\t\t\tsizeof(dccp_sysctl_table),\n\t\t\t\tGFP_KERNEL);\n\tif (!pn->ctl_table)\n\t\treturn -ENOMEM;\n\n\tpn->ctl_table[0].data = &dn->dccp_timeout[CT_DCCP_REQUEST];\n\tpn->ctl_table[1].data = &dn->dccp_timeout[CT_DCCP_RESPOND];\n\tpn->ctl_table[2].data = &dn->dccp_timeout[CT_DCCP_PARTOPEN];\n\tpn->ctl_table[3].data = &dn->dccp_timeout[CT_DCCP_OPEN];\n\tpn->ctl_table[4].data = &dn->dccp_timeout[CT_DCCP_CLOSEREQ];\n\tpn->ctl_table[5].data = &dn->dccp_timeout[CT_DCCP_CLOSING];\n\tpn->ctl_table[6].data = &dn->dccp_timeout[CT_DCCP_TIMEWAIT];\n\tpn->ctl_table[7].data = &dn->dccp_loose;\n\n\t/* Don't export sysctls to unprivileged users */\n\tif (net->user_ns != &init_user_ns)\n\t\tpn->ctl_table[0].procname = NULL;\n#endif\n\treturn 0;\n}\n\nstatic int dccp_init_net(struct net *net, u_int16_t proto)\n{\n\tstruct dccp_net *dn = dccp_pernet(net);\n\tstruct nf_proto_net *pn = &dn->pn;\n\n\tif (!pn->users) {\n\t\t/* default values */\n\t\tdn->dccp_loose = 1;\n\t\tdn->dccp_timeout[CT_DCCP_REQUEST]\t= 2 * DCCP_MSL;\n\t\tdn->dccp_timeout[CT_DCCP_RESPOND]\t= 4 * DCCP_MSL;\n\t\tdn->dccp_timeout[CT_DCCP_PARTOPEN]\t= 4 * DCCP_MSL;\n\t\tdn->dccp_timeout[CT_DCCP_OPEN]\t\t= 12 * 3600 * HZ;\n\t\tdn->dccp_timeout[CT_DCCP_CLOSEREQ]\t= 64 * HZ;\n\t\tdn->dccp_timeout[CT_DCCP_CLOSING]\t= 64 * HZ;\n\t\tdn->dccp_timeout[CT_DCCP_TIMEWAIT]\t= 2 * DCCP_MSL;\n\t}\n\n\treturn dccp_kmemdup_sysctl_table(net, pn, dn);\n}\n\nstatic struct nf_conntrack_l4proto dccp_proto4 __read_mostly = {\n\t.l3proto\t\t= AF_INET,\n\t.l4proto\t\t= IPPROTO_DCCP,\n\t.name\t\t\t= \"dccp\",\n\t.pkt_to_tuple\t\t= dccp_pkt_to_tuple,\n\t.invert_tuple\t\t= dccp_invert_tuple,\n\t.new\t\t\t= dccp_new,\n\t.packet\t\t\t= dccp_packet,\n\t.get_timeouts\t\t= dccp_get_timeouts,\n\t.error\t\t\t= dccp_error,\n\t.print_tuple\t\t= dccp_print_tuple,\n\t.print_conntrack\t= dccp_print_conntrack,\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK)\n\t.to_nlattr\t\t= dccp_to_nlattr,\n\t.nlattr_size\t\t= dccp_nlattr_size,\n\t.from_nlattr\t\t= nlattr_to_dccp,\n\t.tuple_to_nlattr\t= nf_ct_port_tuple_to_nlattr,\n\t.nlattr_tuple_size\t= nf_ct_port_nlattr_tuple_size,\n\t.nlattr_to_tuple\t= nf_ct_port_nlattr_to_tuple,\n\t.nla_policy\t\t= nf_ct_port_nla_policy,\n#endif\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK_TIMEOUT)\n\t.ctnl_timeout\t\t= {\n\t\t.nlattr_to_obj\t= dccp_timeout_nlattr_to_obj,\n\t\t.obj_to_nlattr\t= dccp_timeout_obj_to_nlattr,\n\t\t.nlattr_max\t= CTA_TIMEOUT_DCCP_MAX,\n\t\t.obj_size\t= sizeof(unsigned int) * CT_DCCP_MAX,\n\t\t.nla_policy\t= dccp_timeout_nla_policy,\n\t},\n#endif /* CONFIG_NF_CT_NETLINK_TIMEOUT */\n\t.net_id\t\t\t= &dccp_net_id,\n\t.init_net\t\t= dccp_init_net,\n};\n\nstatic struct nf_conntrack_l4proto dccp_proto6 __read_mostly = {\n\t.l3proto\t\t= AF_INET6,\n\t.l4proto\t\t= IPPROTO_DCCP,\n\t.name\t\t\t= \"dccp\",\n\t.pkt_to_tuple\t\t= dccp_pkt_to_tuple,\n\t.invert_tuple\t\t= dccp_invert_tuple,\n\t.new\t\t\t= dccp_new,\n\t.packet\t\t\t= dccp_packet,\n\t.get_timeouts\t\t= dccp_get_timeouts,\n\t.error\t\t\t= dccp_error,\n\t.print_tuple\t\t= dccp_print_tuple,\n\t.print_conntrack\t= dccp_print_conntrack,\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK)\n\t.to_nlattr\t\t= dccp_to_nlattr,\n\t.nlattr_size\t\t= dccp_nlattr_size,\n\t.from_nlattr\t\t= nlattr_to_dccp,\n\t.tuple_to_nlattr\t= nf_ct_port_tuple_to_nlattr,\n\t.nlattr_tuple_size\t= nf_ct_port_nlattr_tuple_size,\n\t.nlattr_to_tuple\t= nf_ct_port_nlattr_to_tuple,\n\t.nla_policy\t\t= nf_ct_port_nla_policy,\n#endif\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK_TIMEOUT)\n\t.ctnl_timeout\t\t= {\n\t\t.nlattr_to_obj\t= dccp_timeout_nlattr_to_obj,\n\t\t.obj_to_nlattr\t= dccp_timeout_obj_to_nlattr,\n\t\t.nlattr_max\t= CTA_TIMEOUT_DCCP_MAX,\n\t\t.obj_size\t= sizeof(unsigned int) * CT_DCCP_MAX,\n\t\t.nla_policy\t= dccp_timeout_nla_policy,\n\t},\n#endif /* CONFIG_NF_CT_NETLINK_TIMEOUT */\n\t.net_id\t\t\t= &dccp_net_id,\n\t.init_net\t\t= dccp_init_net,\n};\n\nstatic __net_init int dccp_net_init(struct net *net)\n{\n\tint ret = 0;\n\tret = nf_ct_l4proto_pernet_register(net, &dccp_proto4);\n\tif (ret < 0) {\n\t\tpr_err(\"nf_conntrack_dccp4: pernet registration failed.\\n\");\n\t\tgoto out;\n\t}\n\tret = nf_ct_l4proto_pernet_register(net, &dccp_proto6);\n\tif (ret < 0) {\n\t\tpr_err(\"nf_conntrack_dccp6: pernet registration failed.\\n\");\n\t\tgoto cleanup_dccp4;\n\t}\n\treturn 0;\ncleanup_dccp4:\n\tnf_ct_l4proto_pernet_unregister(net, &dccp_proto4);\nout:\n\treturn ret;\n}\n\nstatic __net_exit void dccp_net_exit(struct net *net)\n{\n\tnf_ct_l4proto_pernet_unregister(net, &dccp_proto6);\n\tnf_ct_l4proto_pernet_unregister(net, &dccp_proto4);\n}\n\nstatic struct pernet_operations dccp_net_ops = {\n\t.init = dccp_net_init,\n\t.exit = dccp_net_exit,\n\t.id   = &dccp_net_id,\n\t.size = sizeof(struct dccp_net),\n};\n\nstatic int __init nf_conntrack_proto_dccp_init(void)\n{\n\tint ret;\n\n\tret = register_pernet_subsys(&dccp_net_ops);\n\tif (ret < 0)\n\t\tgoto out_pernet;\n\n\tret = nf_ct_l4proto_register(&dccp_proto4);\n\tif (ret < 0)\n\t\tgoto out_dccp4;\n\n\tret = nf_ct_l4proto_register(&dccp_proto6);\n\tif (ret < 0)\n\t\tgoto out_dccp6;\n\n\treturn 0;\nout_dccp6:\n\tnf_ct_l4proto_unregister(&dccp_proto4);\nout_dccp4:\n\tunregister_pernet_subsys(&dccp_net_ops);\nout_pernet:\n\treturn ret;\n}\n\nstatic void __exit nf_conntrack_proto_dccp_fini(void)\n{\n\tnf_ct_l4proto_unregister(&dccp_proto6);\n\tnf_ct_l4proto_unregister(&dccp_proto4);\n\tunregister_pernet_subsys(&dccp_net_ops);\n}\n\nmodule_init(nf_conntrack_proto_dccp_init);\nmodule_exit(nf_conntrack_proto_dccp_fini);\n\nMODULE_AUTHOR(\"Patrick McHardy <kaber@trash.net>\");\nMODULE_DESCRIPTION(\"DCCP connection tracking protocol helper\");\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/*\n * DCCP connection tracking protocol helper\n *\n * Copyright (c) 2005, 2006, 2008 Patrick McHardy <kaber@trash.net>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n *\n */\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/spinlock.h>\n#include <linux/skbuff.h>\n#include <linux/dccp.h>\n#include <linux/slab.h>\n\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n\n#include <linux/netfilter/nfnetlink_conntrack.h>\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_l4proto.h>\n#include <net/netfilter/nf_conntrack_ecache.h>\n#include <net/netfilter/nf_log.h>\n\n/* Timeouts are based on values from RFC4340:\n *\n * - REQUEST:\n *\n *   8.1.2. Client Request\n *\n *   A client MAY give up on its DCCP-Requests after some time\n *   (3 minutes, for example).\n *\n * - RESPOND:\n *\n *   8.1.3. Server Response\n *\n *   It MAY also leave the RESPOND state for CLOSED after a timeout of\n *   not less than 4MSL (8 minutes);\n *\n * - PARTOPEN:\n *\n *   8.1.5. Handshake Completion\n *\n *   If the client remains in PARTOPEN for more than 4MSL (8 minutes),\n *   it SHOULD reset the connection with Reset Code 2, \"Aborted\".\n *\n * - OPEN:\n *\n *   The DCCP timestamp overflows after 11.9 hours. If the connection\n *   stays idle this long the sequence number won't be recognized\n *   as valid anymore.\n *\n * - CLOSEREQ/CLOSING:\n *\n *   8.3. Termination\n *\n *   The retransmission timer should initially be set to go off in two\n *   round-trip times and should back off to not less than once every\n *   64 seconds ...\n *\n * - TIMEWAIT:\n *\n *   4.3. States\n *\n *   A server or client socket remains in this state for 2MSL (4 minutes)\n *   after the connection has been town down, ...\n */\n\n#define DCCP_MSL (2 * 60 * HZ)\n\nstatic const char * const dccp_state_names[] = {\n\t[CT_DCCP_NONE]\t\t= \"NONE\",\n\t[CT_DCCP_REQUEST]\t= \"REQUEST\",\n\t[CT_DCCP_RESPOND]\t= \"RESPOND\",\n\t[CT_DCCP_PARTOPEN]\t= \"PARTOPEN\",\n\t[CT_DCCP_OPEN]\t\t= \"OPEN\",\n\t[CT_DCCP_CLOSEREQ]\t= \"CLOSEREQ\",\n\t[CT_DCCP_CLOSING]\t= \"CLOSING\",\n\t[CT_DCCP_TIMEWAIT]\t= \"TIMEWAIT\",\n\t[CT_DCCP_IGNORE]\t= \"IGNORE\",\n\t[CT_DCCP_INVALID]\t= \"INVALID\",\n};\n\n#define sNO\tCT_DCCP_NONE\n#define sRQ\tCT_DCCP_REQUEST\n#define sRS\tCT_DCCP_RESPOND\n#define sPO\tCT_DCCP_PARTOPEN\n#define sOP\tCT_DCCP_OPEN\n#define sCR\tCT_DCCP_CLOSEREQ\n#define sCG\tCT_DCCP_CLOSING\n#define sTW\tCT_DCCP_TIMEWAIT\n#define sIG\tCT_DCCP_IGNORE\n#define sIV\tCT_DCCP_INVALID\n\n/*\n * DCCP state transition table\n *\n * The assumption is the same as for TCP tracking:\n *\n * We are the man in the middle. All the packets go through us but might\n * get lost in transit to the destination. It is assumed that the destination\n * can't receive segments we haven't seen.\n *\n * The following states exist:\n *\n * NONE:\tInitial state, expecting Request\n * REQUEST:\tRequest seen, waiting for Response from server\n * RESPOND:\tResponse from server seen, waiting for Ack from client\n * PARTOPEN:\tAck after Response seen, waiting for packet other than Response,\n * \t\tReset or Sync from server\n * OPEN:\tPacket other than Response, Reset or Sync seen\n * CLOSEREQ:\tCloseReq from server seen, expecting Close from client\n * CLOSING:\tClose seen, expecting Reset\n * TIMEWAIT:\tReset seen\n * IGNORE:\tNot determinable whether packet is valid\n *\n * Some states exist only on one side of the connection: REQUEST, RESPOND,\n * PARTOPEN, CLOSEREQ. For the other side these states are equivalent to\n * the one it was in before.\n *\n * Packets are marked as ignored (sIG) if we don't know if they're valid\n * (for example a reincarnation of a connection we didn't notice is dead\n * already) and the server may send back a connection closing Reset or a\n * Response. They're also used for Sync/SyncAck packets, which we don't\n * care about.\n */\nstatic const u_int8_t\ndccp_state_table[CT_DCCP_ROLE_MAX + 1][DCCP_PKT_SYNCACK + 1][CT_DCCP_MAX + 1] = {\n\t[CT_DCCP_ROLE_CLIENT] = {\n\t\t[DCCP_PKT_REQUEST] = {\n\t\t/*\n\t\t * sNO -> sRQ\t\tRegular Request\n\t\t * sRQ -> sRQ\t\tRetransmitted Request or reincarnation\n\t\t * sRS -> sRS\t\tRetransmitted Request (apparently Response\n\t\t * \t\t\tgot lost after we saw it) or reincarnation\n\t\t * sPO -> sIG\t\tIgnore, conntrack might be out of sync\n\t\t * sOP -> sIG\t\tIgnore, conntrack might be out of sync\n\t\t * sCR -> sIG\t\tIgnore, conntrack might be out of sync\n\t\t * sCG -> sIG\t\tIgnore, conntrack might be out of sync\n\t\t * sTW -> sRQ\t\tReincarnation\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO. sOP, sCR, sCG, sTW, */\n\t\t\tsRQ, sRQ, sRS, sIG, sIG, sIG, sIG, sRQ,\n\t\t},\n\t\t[DCCP_PKT_RESPONSE] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tInvalid\n\t\t * sRQ -> sIG\t\tIgnore, might be response to ignored Request\n\t\t * sRS -> sIG\t\tIgnore, might be response to ignored Request\n\t\t * sPO -> sIG\t\tIgnore, might be response to ignored Request\n\t\t * sOP -> sIG\t\tIgnore, might be response to ignored Request\n\t\t * sCR -> sIG\t\tIgnore, might be response to ignored Request\n\t\t * sCG -> sIG\t\tIgnore, might be response to ignored Request\n\t\t * sTW -> sIV\t\tInvalid, reincarnation in reverse direction\n\t\t *\t\t\tgoes through sRQ\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIG, sIG, sIG, sIG, sIG, sIG, sIV,\n\t\t},\n\t\t[DCCP_PKT_ACK] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tNo connection\n\t\t * sRQ -> sIV\t\tNo connection\n\t\t * sRS -> sPO\t\tAck for Response, move to PARTOPEN (8.1.5.)\n\t\t * sPO -> sPO\t\tRetransmitted Ack for Response, remain in PARTOPEN\n\t\t * sOP -> sOP\t\tRegular ACK, remain in OPEN\n\t\t * sCR -> sCR\t\tAck in CLOSEREQ MAY be processed (8.3.)\n\t\t * sCG -> sCG\t\tAck in CLOSING MAY be processed (8.3.)\n\t\t * sTW -> sIV\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIV, sPO, sPO, sOP, sCR, sCG, sIV\n\t\t},\n\t\t[DCCP_PKT_DATA] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tNo connection\n\t\t * sRQ -> sIV\t\tNo connection\n\t\t * sRS -> sIV\t\tNo connection\n\t\t * sPO -> sIV\t\tMUST use DataAck in PARTOPEN state (8.1.5.)\n\t\t * sOP -> sOP\t\tRegular Data packet\n\t\t * sCR -> sCR\t\tData in CLOSEREQ MAY be processed (8.3.)\n\t\t * sCG -> sCG\t\tData in CLOSING MAY be processed (8.3.)\n\t\t * sTW -> sIV\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIV, sIV, sIV, sOP, sCR, sCG, sIV,\n\t\t},\n\t\t[DCCP_PKT_DATAACK] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tNo connection\n\t\t * sRQ -> sIV\t\tNo connection\n\t\t * sRS -> sPO\t\tAck for Response, move to PARTOPEN (8.1.5.)\n\t\t * sPO -> sPO\t\tRemain in PARTOPEN state\n\t\t * sOP -> sOP\t\tRegular DataAck packet in OPEN state\n\t\t * sCR -> sCR\t\tDataAck in CLOSEREQ MAY be processed (8.3.)\n\t\t * sCG -> sCG\t\tDataAck in CLOSING MAY be processed (8.3.)\n\t\t * sTW -> sIV\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIV, sPO, sPO, sOP, sCR, sCG, sIV\n\t\t},\n\t\t[DCCP_PKT_CLOSEREQ] = {\n\t\t/*\n\t\t * CLOSEREQ may only be sent by the server.\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIV, sIV, sIV, sIV, sIV, sIV, sIV\n\t\t},\n\t\t[DCCP_PKT_CLOSE] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tNo connection\n\t\t * sRQ -> sIV\t\tNo connection\n\t\t * sRS -> sIV\t\tNo connection\n\t\t * sPO -> sCG\t\tClient-initiated close\n\t\t * sOP -> sCG\t\tClient-initiated close\n\t\t * sCR -> sCG\t\tClose in response to CloseReq (8.3.)\n\t\t * sCG -> sCG\t\tRetransmit\n\t\t * sTW -> sIV\t\tLate retransmit, already in TIME_WAIT\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIV, sIV, sCG, sCG, sCG, sIV, sIV\n\t\t},\n\t\t[DCCP_PKT_RESET] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tNo connection\n\t\t * sRQ -> sTW\t\tSync received or timeout, SHOULD send Reset (8.1.1.)\n\t\t * sRS -> sTW\t\tResponse received without Request\n\t\t * sPO -> sTW\t\tTimeout, SHOULD send Reset (8.1.5.)\n\t\t * sOP -> sTW\t\tConnection reset\n\t\t * sCR -> sTW\t\tConnection reset\n\t\t * sCG -> sTW\t\tConnection reset\n\t\t * sTW -> sIG\t\tIgnore (don't refresh timer)\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sTW, sTW, sTW, sTW, sTW, sTW, sIG\n\t\t},\n\t\t[DCCP_PKT_SYNC] = {\n\t\t/*\n\t\t * We currently ignore Sync packets\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIG, sIG, sIG, sIG, sIG, sIG, sIG, sIG,\n\t\t},\n\t\t[DCCP_PKT_SYNCACK] = {\n\t\t/*\n\t\t * We currently ignore SyncAck packets\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIG, sIG, sIG, sIG, sIG, sIG, sIG, sIG,\n\t\t},\n\t},\n\t[CT_DCCP_ROLE_SERVER] = {\n\t\t[DCCP_PKT_REQUEST] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tInvalid\n\t\t * sRQ -> sIG\t\tIgnore, conntrack might be out of sync\n\t\t * sRS -> sIG\t\tIgnore, conntrack might be out of sync\n\t\t * sPO -> sIG\t\tIgnore, conntrack might be out of sync\n\t\t * sOP -> sIG\t\tIgnore, conntrack might be out of sync\n\t\t * sCR -> sIG\t\tIgnore, conntrack might be out of sync\n\t\t * sCG -> sIG\t\tIgnore, conntrack might be out of sync\n\t\t * sTW -> sRQ\t\tReincarnation, must reverse roles\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIG, sIG, sIG, sIG, sIG, sIG, sRQ\n\t\t},\n\t\t[DCCP_PKT_RESPONSE] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tResponse without Request\n\t\t * sRQ -> sRS\t\tResponse to clients Request\n\t\t * sRS -> sRS\t\tRetransmitted Response (8.1.3. SHOULD NOT)\n\t\t * sPO -> sIG\t\tResponse to an ignored Request or late retransmit\n\t\t * sOP -> sIG\t\tIgnore, might be response to ignored Request\n\t\t * sCR -> sIG\t\tIgnore, might be response to ignored Request\n\t\t * sCG -> sIG\t\tIgnore, might be response to ignored Request\n\t\t * sTW -> sIV\t\tInvalid, Request from client in sTW moves to sRQ\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sRS, sRS, sIG, sIG, sIG, sIG, sIV\n\t\t},\n\t\t[DCCP_PKT_ACK] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tNo connection\n\t\t * sRQ -> sIV\t\tNo connection\n\t\t * sRS -> sIV\t\tNo connection\n\t\t * sPO -> sOP\t\tEnter OPEN state (8.1.5.)\n\t\t * sOP -> sOP\t\tRegular Ack in OPEN state\n\t\t * sCR -> sIV\t\tWaiting for Close from client\n\t\t * sCG -> sCG\t\tAck in CLOSING MAY be processed (8.3.)\n\t\t * sTW -> sIV\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIV, sIV, sOP, sOP, sIV, sCG, sIV\n\t\t},\n\t\t[DCCP_PKT_DATA] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tNo connection\n\t\t * sRQ -> sIV\t\tNo connection\n\t\t * sRS -> sIV\t\tNo connection\n\t\t * sPO -> sOP\t\tEnter OPEN state (8.1.5.)\n\t\t * sOP -> sOP\t\tRegular Data packet in OPEN state\n\t\t * sCR -> sIV\t\tWaiting for Close from client\n\t\t * sCG -> sCG\t\tData in CLOSING MAY be processed (8.3.)\n\t\t * sTW -> sIV\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIV, sIV, sOP, sOP, sIV, sCG, sIV\n\t\t},\n\t\t[DCCP_PKT_DATAACK] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tNo connection\n\t\t * sRQ -> sIV\t\tNo connection\n\t\t * sRS -> sIV\t\tNo connection\n\t\t * sPO -> sOP\t\tEnter OPEN state (8.1.5.)\n\t\t * sOP -> sOP\t\tRegular DataAck in OPEN state\n\t\t * sCR -> sIV\t\tWaiting for Close from client\n\t\t * sCG -> sCG\t\tData in CLOSING MAY be processed (8.3.)\n\t\t * sTW -> sIV\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIV, sIV, sOP, sOP, sIV, sCG, sIV\n\t\t},\n\t\t[DCCP_PKT_CLOSEREQ] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tNo connection\n\t\t * sRQ -> sIV\t\tNo connection\n\t\t * sRS -> sIV\t\tNo connection\n\t\t * sPO -> sOP -> sCR\tMove directly to CLOSEREQ (8.1.5.)\n\t\t * sOP -> sCR\t\tCloseReq in OPEN state\n\t\t * sCR -> sCR\t\tRetransmit\n\t\t * sCG -> sCR\t\tSimultaneous close, client sends another Close\n\t\t * sTW -> sIV\t\tAlready closed\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIV, sIV, sCR, sCR, sCR, sCR, sIV\n\t\t},\n\t\t[DCCP_PKT_CLOSE] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tNo connection\n\t\t * sRQ -> sIV\t\tNo connection\n\t\t * sRS -> sIV\t\tNo connection\n\t\t * sPO -> sOP -> sCG\tMove direcly to CLOSING\n\t\t * sOP -> sCG\t\tMove to CLOSING\n\t\t * sCR -> sIV\t\tClose after CloseReq is invalid\n\t\t * sCG -> sCG\t\tRetransmit\n\t\t * sTW -> sIV\t\tAlready closed\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIV, sIV, sIV, sCG, sCG, sIV, sCG, sIV\n\t\t},\n\t\t[DCCP_PKT_RESET] = {\n\t\t/*\n\t\t * sNO -> sIV\t\tNo connection\n\t\t * sRQ -> sTW\t\tReset in response to Request\n\t\t * sRS -> sTW\t\tTimeout, SHOULD send Reset (8.1.3.)\n\t\t * sPO -> sTW\t\tTimeout, SHOULD send Reset (8.1.3.)\n\t\t * sOP -> sTW\n\t\t * sCR -> sTW\n\t\t * sCG -> sTW\n\t\t * sTW -> sIG\t\tIgnore (don't refresh timer)\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW, sTW */\n\t\t\tsIV, sTW, sTW, sTW, sTW, sTW, sTW, sTW, sIG\n\t\t},\n\t\t[DCCP_PKT_SYNC] = {\n\t\t/*\n\t\t * We currently ignore Sync packets\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIG, sIG, sIG, sIG, sIG, sIG, sIG, sIG,\n\t\t},\n\t\t[DCCP_PKT_SYNCACK] = {\n\t\t/*\n\t\t * We currently ignore SyncAck packets\n\t\t *\n\t\t *\tsNO, sRQ, sRS, sPO, sOP, sCR, sCG, sTW */\n\t\t\tsIG, sIG, sIG, sIG, sIG, sIG, sIG, sIG,\n\t\t},\n\t},\n};\n\n/* this module per-net specifics */\nstatic int dccp_net_id __read_mostly;\nstruct dccp_net {\n\tstruct nf_proto_net pn;\n\tint dccp_loose;\n\tunsigned int dccp_timeout[CT_DCCP_MAX + 1];\n};\n\nstatic inline struct dccp_net *dccp_pernet(struct net *net)\n{\n\treturn net_generic(net, dccp_net_id);\n}\n\nstatic bool dccp_pkt_to_tuple(const struct sk_buff *skb, unsigned int dataoff,\n\t\t\t      struct nf_conntrack_tuple *tuple)\n{\n\tstruct dccp_hdr _hdr, *dh;\n\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_hdr), &_hdr);\n\tif (dh == NULL)\n\t\treturn false;\n\n\ttuple->src.u.dccp.port = dh->dccph_sport;\n\ttuple->dst.u.dccp.port = dh->dccph_dport;\n\treturn true;\n}\n\nstatic bool dccp_invert_tuple(struct nf_conntrack_tuple *inv,\n\t\t\t      const struct nf_conntrack_tuple *tuple)\n{\n\tinv->src.u.dccp.port = tuple->dst.u.dccp.port;\n\tinv->dst.u.dccp.port = tuple->src.u.dccp.port;\n\treturn true;\n}\n\nstatic bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t     unsigned int dataoff, unsigned int *timeouts)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tstruct dccp_net *dn;\n\tstruct dccp_hdr _dh, *dh;\n\tconst char *msg;\n\tu_int8_t state;\n\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);\n\tBUG_ON(dh == NULL);\n\n\tstate = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];\n\tswitch (state) {\n\tdefault:\n\t\tdn = dccp_pernet(net);\n\t\tif (dn->dccp_loose == 0) {\n\t\t\tmsg = \"nf_ct_dccp: not picking up existing connection \";\n\t\t\tgoto out_invalid;\n\t\t}\n\tcase CT_DCCP_REQUEST:\n\t\tbreak;\n\tcase CT_DCCP_INVALID:\n\t\tmsg = \"nf_ct_dccp: invalid state transition \";\n\t\tgoto out_invalid;\n\t}\n\n\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\n\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\n\tct->proto.dccp.state = CT_DCCP_NONE;\n\tct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;\n\tct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;\n\tct->proto.dccp.handshake_seq = 0;\n\treturn true;\n\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, nf_ct_l3num(ct), 0, skb, NULL, NULL,\n\t\t\t      NULL, \"%s\", msg);\n\treturn false;\n}\n\nstatic u64 dccp_ack_seq(const struct dccp_hdr *dh)\n{\n\tconst struct dccp_hdr_ack_bits *dhack;\n\n\tdhack = (void *)dh + __dccp_basic_hdr_len(dh);\n\treturn ((u64)ntohs(dhack->dccph_ack_nr_high) << 32) +\n\t\t     ntohl(dhack->dccph_ack_nr_low);\n}\n\nstatic unsigned int *dccp_get_timeouts(struct net *net)\n{\n\treturn dccp_pernet(net)->dccp_timeout;\n}\n\nstatic int dccp_packet(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t       unsigned int dataoff, enum ip_conntrack_info ctinfo,\n\t\t       u_int8_t pf, unsigned int hooknum,\n\t\t       unsigned int *timeouts)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\n\tstruct dccp_hdr _dh, *dh;\n\tu_int8_t type, old_state, new_state;\n\tenum ct_dccp_roles role;\n\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);\n\tBUG_ON(dh == NULL);\n\ttype = dh->dccph_type;\n\n\tif (type == DCCP_PKT_RESET &&\n\t    !test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {\n\t\t/* Tear down connection immediately if only reply is a RESET */\n\t\tnf_ct_kill_acct(ct, ctinfo, skb);\n\t\treturn NF_ACCEPT;\n\t}\n\n\tspin_lock_bh(&ct->lock);\n\n\trole = ct->proto.dccp.role[dir];\n\told_state = ct->proto.dccp.state;\n\tnew_state = dccp_state_table[role][type][old_state];\n\n\tswitch (new_state) {\n\tcase CT_DCCP_REQUEST:\n\t\tif (old_state == CT_DCCP_TIMEWAIT &&\n\t\t    role == CT_DCCP_ROLE_SERVER) {\n\t\t\t/* Reincarnation in the reverse direction: reopen and\n\t\t\t * reverse client/server roles. */\n\t\t\tct->proto.dccp.role[dir] = CT_DCCP_ROLE_CLIENT;\n\t\t\tct->proto.dccp.role[!dir] = CT_DCCP_ROLE_SERVER;\n\t\t}\n\t\tbreak;\n\tcase CT_DCCP_RESPOND:\n\t\tif (old_state == CT_DCCP_REQUEST)\n\t\t\tct->proto.dccp.handshake_seq = dccp_hdr_seq(dh);\n\t\tbreak;\n\tcase CT_DCCP_PARTOPEN:\n\t\tif (old_state == CT_DCCP_RESPOND &&\n\t\t    type == DCCP_PKT_ACK &&\n\t\t    dccp_ack_seq(dh) == ct->proto.dccp.handshake_seq)\n\t\t\tset_bit(IPS_ASSURED_BIT, &ct->status);\n\t\tbreak;\n\tcase CT_DCCP_IGNORE:\n\t\t/*\n\t\t * Connection tracking might be out of sync, so we ignore\n\t\t * packets that might establish a new connection and resync\n\t\t * if the server responds with a valid Response.\n\t\t */\n\t\tif (ct->proto.dccp.last_dir == !dir &&\n\t\t    ct->proto.dccp.last_pkt == DCCP_PKT_REQUEST &&\n\t\t    type == DCCP_PKT_RESPONSE) {\n\t\t\tct->proto.dccp.role[!dir] = CT_DCCP_ROLE_CLIENT;\n\t\t\tct->proto.dccp.role[dir] = CT_DCCP_ROLE_SERVER;\n\t\t\tct->proto.dccp.handshake_seq = dccp_hdr_seq(dh);\n\t\t\tnew_state = CT_DCCP_RESPOND;\n\t\t\tbreak;\n\t\t}\n\t\tct->proto.dccp.last_dir = dir;\n\t\tct->proto.dccp.last_pkt = type;\n\n\t\tspin_unlock_bh(&ct->lock);\n\t\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL,\n\t\t\t\t      \"nf_ct_dccp: invalid packet ignored \");\n\t\treturn NF_ACCEPT;\n\tcase CT_DCCP_INVALID:\n\t\tspin_unlock_bh(&ct->lock);\n\t\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL,\n\t\t\t\t      \"nf_ct_dccp: invalid state transition \");\n\t\treturn -NF_ACCEPT;\n\t}\n\n\tct->proto.dccp.last_dir = dir;\n\tct->proto.dccp.last_pkt = type;\n\tct->proto.dccp.state = new_state;\n\tspin_unlock_bh(&ct->lock);\n\n\tif (new_state != old_state)\n\t\tnf_conntrack_event_cache(IPCT_PROTOINFO, ct);\n\n\tnf_ct_refresh_acct(ct, ctinfo, skb, timeouts[new_state]);\n\n\treturn NF_ACCEPT;\n}\n\nstatic int dccp_error(struct net *net, struct nf_conn *tmpl,\n\t\t      struct sk_buff *skb, unsigned int dataoff,\n\t\t      enum ip_conntrack_info *ctinfo,\n\t\t      u_int8_t pf, unsigned int hooknum)\n{\n\tstruct dccp_hdr _dh, *dh;\n\tunsigned int dccp_len = skb->len - dataoff;\n\tunsigned int cscov;\n\tconst char *msg;\n\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);\n\tif (dh == NULL) {\n\t\tmsg = \"nf_ct_dccp: short packet \";\n\t\tgoto out_invalid;\n\t}\n\n\tif (dh->dccph_doff * 4 < sizeof(struct dccp_hdr) ||\n\t    dh->dccph_doff * 4 > dccp_len) {\n\t\tmsg = \"nf_ct_dccp: truncated/malformed packet \";\n\t\tgoto out_invalid;\n\t}\n\n\tcscov = dccp_len;\n\tif (dh->dccph_cscov) {\n\t\tcscov = (dh->dccph_cscov - 1) * 4;\n\t\tif (cscov > dccp_len) {\n\t\t\tmsg = \"nf_ct_dccp: bad checksum coverage \";\n\t\t\tgoto out_invalid;\n\t\t}\n\t}\n\n\tif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\n\t    nf_checksum_partial(skb, hooknum, dataoff, cscov, IPPROTO_DCCP,\n\t\t\t\tpf)) {\n\t\tmsg = \"nf_ct_dccp: bad checksum \";\n\t\tgoto out_invalid;\n\t}\n\n\tif (dh->dccph_type >= DCCP_PKT_INVALID) {\n\t\tmsg = \"nf_ct_dccp: reserved packet type \";\n\t\tgoto out_invalid;\n\t}\n\n\treturn NF_ACCEPT;\n\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL, \"%s\", msg);\n\treturn -NF_ACCEPT;\n}\n\nstatic int dccp_print_tuple(struct seq_file *s,\n\t\t\t    const struct nf_conntrack_tuple *tuple)\n{\n\treturn seq_printf(s, \"sport=%hu dport=%hu \",\n\t\t\t  ntohs(tuple->src.u.dccp.port),\n\t\t\t  ntohs(tuple->dst.u.dccp.port));\n}\n\nstatic int dccp_print_conntrack(struct seq_file *s, struct nf_conn *ct)\n{\n\treturn seq_printf(s, \"%s \", dccp_state_names[ct->proto.dccp.state]);\n}\n\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK)\nstatic int dccp_to_nlattr(struct sk_buff *skb, struct nlattr *nla,\n\t\t\t  struct nf_conn *ct)\n{\n\tstruct nlattr *nest_parms;\n\n\tspin_lock_bh(&ct->lock);\n\tnest_parms = nla_nest_start(skb, CTA_PROTOINFO_DCCP | NLA_F_NESTED);\n\tif (!nest_parms)\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(skb, CTA_PROTOINFO_DCCP_STATE, ct->proto.dccp.state) ||\n\t    nla_put_u8(skb, CTA_PROTOINFO_DCCP_ROLE,\n\t\t       ct->proto.dccp.role[IP_CT_DIR_ORIGINAL]) ||\n\t    nla_put_be64(skb, CTA_PROTOINFO_DCCP_HANDSHAKE_SEQ,\n\t\t\t cpu_to_be64(ct->proto.dccp.handshake_seq)))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest_parms);\n\tspin_unlock_bh(&ct->lock);\n\treturn 0;\n\nnla_put_failure:\n\tspin_unlock_bh(&ct->lock);\n\treturn -1;\n}\n\nstatic const struct nla_policy dccp_nla_policy[CTA_PROTOINFO_DCCP_MAX + 1] = {\n\t[CTA_PROTOINFO_DCCP_STATE]\t= { .type = NLA_U8 },\n\t[CTA_PROTOINFO_DCCP_ROLE]\t= { .type = NLA_U8 },\n\t[CTA_PROTOINFO_DCCP_HANDSHAKE_SEQ] = { .type = NLA_U64 },\n};\n\nstatic int nlattr_to_dccp(struct nlattr *cda[], struct nf_conn *ct)\n{\n\tstruct nlattr *attr = cda[CTA_PROTOINFO_DCCP];\n\tstruct nlattr *tb[CTA_PROTOINFO_DCCP_MAX + 1];\n\tint err;\n\n\tif (!attr)\n\t\treturn 0;\n\n\terr = nla_parse_nested(tb, CTA_PROTOINFO_DCCP_MAX, attr,\n\t\t\t       dccp_nla_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[CTA_PROTOINFO_DCCP_STATE] ||\n\t    !tb[CTA_PROTOINFO_DCCP_ROLE] ||\n\t    nla_get_u8(tb[CTA_PROTOINFO_DCCP_ROLE]) > CT_DCCP_ROLE_MAX ||\n\t    nla_get_u8(tb[CTA_PROTOINFO_DCCP_STATE]) >= CT_DCCP_IGNORE) {\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_bh(&ct->lock);\n\tct->proto.dccp.state = nla_get_u8(tb[CTA_PROTOINFO_DCCP_STATE]);\n\tif (nla_get_u8(tb[CTA_PROTOINFO_DCCP_ROLE]) == CT_DCCP_ROLE_CLIENT) {\n\t\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\n\t\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\n\t} else {\n\t\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_SERVER;\n\t\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_CLIENT;\n\t}\n\tif (tb[CTA_PROTOINFO_DCCP_HANDSHAKE_SEQ]) {\n\t\tct->proto.dccp.handshake_seq =\n\t\tbe64_to_cpu(nla_get_be64(tb[CTA_PROTOINFO_DCCP_HANDSHAKE_SEQ]));\n\t}\n\tspin_unlock_bh(&ct->lock);\n\treturn 0;\n}\n\nstatic int dccp_nlattr_size(void)\n{\n\treturn nla_total_size(0)\t/* CTA_PROTOINFO_DCCP */\n\t\t+ nla_policy_len(dccp_nla_policy, CTA_PROTOINFO_DCCP_MAX + 1);\n}\n\n#endif\n\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK_TIMEOUT)\n\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/nfnetlink_cttimeout.h>\n\nstatic int dccp_timeout_nlattr_to_obj(struct nlattr *tb[],\n\t\t\t\t      struct net *net, void *data)\n{\n\tstruct dccp_net *dn = dccp_pernet(net);\n\tunsigned int *timeouts = data;\n\tint i;\n\n\t/* set default DCCP timeouts. */\n\tfor (i=0; i<CT_DCCP_MAX; i++)\n\t\ttimeouts[i] = dn->dccp_timeout[i];\n\n\t/* there's a 1:1 mapping between attributes and protocol states. */\n\tfor (i=CTA_TIMEOUT_DCCP_UNSPEC+1; i<CTA_TIMEOUT_DCCP_MAX+1; i++) {\n\t\tif (tb[i]) {\n\t\t\ttimeouts[i] = ntohl(nla_get_be32(tb[i])) * HZ;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\ndccp_timeout_obj_to_nlattr(struct sk_buff *skb, const void *data)\n{\n        const unsigned int *timeouts = data;\n\tint i;\n\n\tfor (i=CTA_TIMEOUT_DCCP_UNSPEC+1; i<CTA_TIMEOUT_DCCP_MAX+1; i++) {\n\t\tif (nla_put_be32(skb, i, htonl(timeouts[i] / HZ)))\n\t\t\tgoto nla_put_failure;\n\t}\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOSPC;\n}\n\nstatic const struct nla_policy\ndccp_timeout_nla_policy[CTA_TIMEOUT_DCCP_MAX+1] = {\n\t[CTA_TIMEOUT_DCCP_REQUEST]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_DCCP_RESPOND]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_DCCP_PARTOPEN]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_DCCP_OPEN]\t\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_DCCP_CLOSEREQ]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_DCCP_CLOSING]\t= { .type = NLA_U32 },\n\t[CTA_TIMEOUT_DCCP_TIMEWAIT]\t= { .type = NLA_U32 },\n};\n#endif /* CONFIG_NF_CT_NETLINK_TIMEOUT */\n\n#ifdef CONFIG_SYSCTL\n/* template, data assigned later */\nstatic struct ctl_table dccp_sysctl_table[] = {\n\t{\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_request\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_respond\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_partopen\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_open\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_closereq\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_closing\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"nf_conntrack_dccp_timeout_timewait\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"nf_conntrack_dccp_loose\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{ }\n};\n#endif /* CONFIG_SYSCTL */\n\nstatic int dccp_kmemdup_sysctl_table(struct net *net, struct nf_proto_net *pn,\n\t\t\t\t     struct dccp_net *dn)\n{\n#ifdef CONFIG_SYSCTL\n\tif (pn->ctl_table)\n\t\treturn 0;\n\n\tpn->ctl_table = kmemdup(dccp_sysctl_table,\n\t\t\t\tsizeof(dccp_sysctl_table),\n\t\t\t\tGFP_KERNEL);\n\tif (!pn->ctl_table)\n\t\treturn -ENOMEM;\n\n\tpn->ctl_table[0].data = &dn->dccp_timeout[CT_DCCP_REQUEST];\n\tpn->ctl_table[1].data = &dn->dccp_timeout[CT_DCCP_RESPOND];\n\tpn->ctl_table[2].data = &dn->dccp_timeout[CT_DCCP_PARTOPEN];\n\tpn->ctl_table[3].data = &dn->dccp_timeout[CT_DCCP_OPEN];\n\tpn->ctl_table[4].data = &dn->dccp_timeout[CT_DCCP_CLOSEREQ];\n\tpn->ctl_table[5].data = &dn->dccp_timeout[CT_DCCP_CLOSING];\n\tpn->ctl_table[6].data = &dn->dccp_timeout[CT_DCCP_TIMEWAIT];\n\tpn->ctl_table[7].data = &dn->dccp_loose;\n\n\t/* Don't export sysctls to unprivileged users */\n\tif (net->user_ns != &init_user_ns)\n\t\tpn->ctl_table[0].procname = NULL;\n#endif\n\treturn 0;\n}\n\nstatic int dccp_init_net(struct net *net, u_int16_t proto)\n{\n\tstruct dccp_net *dn = dccp_pernet(net);\n\tstruct nf_proto_net *pn = &dn->pn;\n\n\tif (!pn->users) {\n\t\t/* default values */\n\t\tdn->dccp_loose = 1;\n\t\tdn->dccp_timeout[CT_DCCP_REQUEST]\t= 2 * DCCP_MSL;\n\t\tdn->dccp_timeout[CT_DCCP_RESPOND]\t= 4 * DCCP_MSL;\n\t\tdn->dccp_timeout[CT_DCCP_PARTOPEN]\t= 4 * DCCP_MSL;\n\t\tdn->dccp_timeout[CT_DCCP_OPEN]\t\t= 12 * 3600 * HZ;\n\t\tdn->dccp_timeout[CT_DCCP_CLOSEREQ]\t= 64 * HZ;\n\t\tdn->dccp_timeout[CT_DCCP_CLOSING]\t= 64 * HZ;\n\t\tdn->dccp_timeout[CT_DCCP_TIMEWAIT]\t= 2 * DCCP_MSL;\n\t}\n\n\treturn dccp_kmemdup_sysctl_table(net, pn, dn);\n}\n\nstatic struct nf_conntrack_l4proto dccp_proto4 __read_mostly = {\n\t.l3proto\t\t= AF_INET,\n\t.l4proto\t\t= IPPROTO_DCCP,\n\t.name\t\t\t= \"dccp\",\n\t.pkt_to_tuple\t\t= dccp_pkt_to_tuple,\n\t.invert_tuple\t\t= dccp_invert_tuple,\n\t.new\t\t\t= dccp_new,\n\t.packet\t\t\t= dccp_packet,\n\t.get_timeouts\t\t= dccp_get_timeouts,\n\t.error\t\t\t= dccp_error,\n\t.print_tuple\t\t= dccp_print_tuple,\n\t.print_conntrack\t= dccp_print_conntrack,\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK)\n\t.to_nlattr\t\t= dccp_to_nlattr,\n\t.nlattr_size\t\t= dccp_nlattr_size,\n\t.from_nlattr\t\t= nlattr_to_dccp,\n\t.tuple_to_nlattr\t= nf_ct_port_tuple_to_nlattr,\n\t.nlattr_tuple_size\t= nf_ct_port_nlattr_tuple_size,\n\t.nlattr_to_tuple\t= nf_ct_port_nlattr_to_tuple,\n\t.nla_policy\t\t= nf_ct_port_nla_policy,\n#endif\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK_TIMEOUT)\n\t.ctnl_timeout\t\t= {\n\t\t.nlattr_to_obj\t= dccp_timeout_nlattr_to_obj,\n\t\t.obj_to_nlattr\t= dccp_timeout_obj_to_nlattr,\n\t\t.nlattr_max\t= CTA_TIMEOUT_DCCP_MAX,\n\t\t.obj_size\t= sizeof(unsigned int) * CT_DCCP_MAX,\n\t\t.nla_policy\t= dccp_timeout_nla_policy,\n\t},\n#endif /* CONFIG_NF_CT_NETLINK_TIMEOUT */\n\t.net_id\t\t\t= &dccp_net_id,\n\t.init_net\t\t= dccp_init_net,\n};\n\nstatic struct nf_conntrack_l4proto dccp_proto6 __read_mostly = {\n\t.l3proto\t\t= AF_INET6,\n\t.l4proto\t\t= IPPROTO_DCCP,\n\t.name\t\t\t= \"dccp\",\n\t.pkt_to_tuple\t\t= dccp_pkt_to_tuple,\n\t.invert_tuple\t\t= dccp_invert_tuple,\n\t.new\t\t\t= dccp_new,\n\t.packet\t\t\t= dccp_packet,\n\t.get_timeouts\t\t= dccp_get_timeouts,\n\t.error\t\t\t= dccp_error,\n\t.print_tuple\t\t= dccp_print_tuple,\n\t.print_conntrack\t= dccp_print_conntrack,\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK)\n\t.to_nlattr\t\t= dccp_to_nlattr,\n\t.nlattr_size\t\t= dccp_nlattr_size,\n\t.from_nlattr\t\t= nlattr_to_dccp,\n\t.tuple_to_nlattr\t= nf_ct_port_tuple_to_nlattr,\n\t.nlattr_tuple_size\t= nf_ct_port_nlattr_tuple_size,\n\t.nlattr_to_tuple\t= nf_ct_port_nlattr_to_tuple,\n\t.nla_policy\t\t= nf_ct_port_nla_policy,\n#endif\n#if IS_ENABLED(CONFIG_NF_CT_NETLINK_TIMEOUT)\n\t.ctnl_timeout\t\t= {\n\t\t.nlattr_to_obj\t= dccp_timeout_nlattr_to_obj,\n\t\t.obj_to_nlattr\t= dccp_timeout_obj_to_nlattr,\n\t\t.nlattr_max\t= CTA_TIMEOUT_DCCP_MAX,\n\t\t.obj_size\t= sizeof(unsigned int) * CT_DCCP_MAX,\n\t\t.nla_policy\t= dccp_timeout_nla_policy,\n\t},\n#endif /* CONFIG_NF_CT_NETLINK_TIMEOUT */\n\t.net_id\t\t\t= &dccp_net_id,\n\t.init_net\t\t= dccp_init_net,\n};\n\nstatic __net_init int dccp_net_init(struct net *net)\n{\n\tint ret = 0;\n\tret = nf_ct_l4proto_pernet_register(net, &dccp_proto4);\n\tif (ret < 0) {\n\t\tpr_err(\"nf_conntrack_dccp4: pernet registration failed.\\n\");\n\t\tgoto out;\n\t}\n\tret = nf_ct_l4proto_pernet_register(net, &dccp_proto6);\n\tif (ret < 0) {\n\t\tpr_err(\"nf_conntrack_dccp6: pernet registration failed.\\n\");\n\t\tgoto cleanup_dccp4;\n\t}\n\treturn 0;\ncleanup_dccp4:\n\tnf_ct_l4proto_pernet_unregister(net, &dccp_proto4);\nout:\n\treturn ret;\n}\n\nstatic __net_exit void dccp_net_exit(struct net *net)\n{\n\tnf_ct_l4proto_pernet_unregister(net, &dccp_proto6);\n\tnf_ct_l4proto_pernet_unregister(net, &dccp_proto4);\n}\n\nstatic struct pernet_operations dccp_net_ops = {\n\t.init = dccp_net_init,\n\t.exit = dccp_net_exit,\n\t.id   = &dccp_net_id,\n\t.size = sizeof(struct dccp_net),\n};\n\nstatic int __init nf_conntrack_proto_dccp_init(void)\n{\n\tint ret;\n\n\tret = register_pernet_subsys(&dccp_net_ops);\n\tif (ret < 0)\n\t\tgoto out_pernet;\n\n\tret = nf_ct_l4proto_register(&dccp_proto4);\n\tif (ret < 0)\n\t\tgoto out_dccp4;\n\n\tret = nf_ct_l4proto_register(&dccp_proto6);\n\tif (ret < 0)\n\t\tgoto out_dccp6;\n\n\treturn 0;\nout_dccp6:\n\tnf_ct_l4proto_unregister(&dccp_proto4);\nout_dccp4:\n\tunregister_pernet_subsys(&dccp_net_ops);\nout_pernet:\n\treturn ret;\n}\n\nstatic void __exit nf_conntrack_proto_dccp_fini(void)\n{\n\tnf_ct_l4proto_unregister(&dccp_proto6);\n\tnf_ct_l4proto_unregister(&dccp_proto4);\n\tunregister_pernet_subsys(&dccp_net_ops);\n}\n\nmodule_init(nf_conntrack_proto_dccp_init);\nmodule_exit(nf_conntrack_proto_dccp_fini);\n\nMODULE_AUTHOR(\"Patrick McHardy <kaber@trash.net>\");\nMODULE_DESCRIPTION(\"DCCP connection tracking protocol helper\");\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["net/netfilter/nf_conntrack_proto_dccp.c"], "buggy_code_start_loc": [431], "buggy_code_end_loc": [581], "fixing_code_start_loc": [431], "fixing_code_end_loc": [581], "type": "CWE-20", "message": "net/netfilter/nf_conntrack_proto_dccp.c in the Linux kernel through 3.13.6 uses a DCCP header pointer incorrectly, which allows remote attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a DCCP packet that triggers a call to the (1) dccp_new, (2) dccp_packet, or (3) dccp_error function.", "other": {"cve": {"id": "CVE-2014-2523", "sourceIdentifier": "cve@mitre.org", "published": "2014-03-24T16:40:48.140", "lastModified": "2023-01-19T16:26:35.167", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "net/netfilter/nf_conntrack_proto_dccp.c in the Linux kernel through 3.13.6 uses a DCCP header pointer incorrectly, which allows remote attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a DCCP packet that triggers a call to the (1) dccp_new, (2) dccp_packet, or (3) dccp_error function."}, {"lang": "es", "value": "net/netfilter/nf_conntrack_proto_dccp.c en el kernel de Linux hasta 3.13.6 utiliza un puntero de cabecera DCCP incorrectamente, lo que permite a atacantes remotos causar una denegaci\u00f3n de servicio (ca\u00edda de sistema) o posiblemente ejecutar c\u00f3digo arbitrario a trav\u00e9s de un paquete DCCP que provoca una llamada la funci\u00f3n (1) dccp_new, (2) dccp_packet o (3) dccp_error."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.57", "matchCriteriaId": "30DD9401-EECC-40F5-82AB-E3D03817B960"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3", "versionEndExcluding": "3.4.86", "matchCriteriaId": "4AB54625-6E2E-4C08-A6BA-284169A8C654"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.5", "versionEndExcluding": "3.10.36", "matchCriteriaId": "C16E63A1-A814-4D73-9077-CC7C4A243D97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.11", "versionEndExcluding": "3.12.17", "matchCriteriaId": "770EFFD5-FB33-4641-AF30-4A46D73FDCEA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.13.0", "versionEndExcluding": "3.13.9", "matchCriteriaId": "00810E41-14AF-466F-9BE2-DD9E8F3C5A08"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:10.04:*:*:*:-:*:*:*", "matchCriteriaId": "01EDA41C-6B2E-49AF-B503-EB3882265C11"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=b22f5126a24b3b2f15448c3f2a254fc10cbc2b92", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://twitter.com/grsecurity/statuses/445496197399461888", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/03/17/7", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/66279", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1029945", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-2173-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2174-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1077343", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/91910", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/b22f5126a24b3b2f15448c3f2a254fc10cbc2b92"}}