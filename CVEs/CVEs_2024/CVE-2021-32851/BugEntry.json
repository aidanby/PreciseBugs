{"buggy_code": ["{\n  \"name\": \"mind-elixir\",\n  \"version\": \"0.18.0\",\n  \"description\": \"Mind elixir is a free open source mind map core.\",\n  \"main\": \"dist/MindElixir.js\",\n  \"scripts\": {\n    \"start\": \"webpack-dev-server --mode development --env.dist=0\",\n    \"startd\": \"webpack-dev-server --mode development --env.dist=1\",\n    \"test\": \"jest --runInBand\",\n    \"build\": \"webpack --mode production\",\n    \"doc\": \"./node_modules/.bin/jsdoc src/ -R readme.md -c conf.json\",\n    \"md\": \"./node_modules/.bin/jsdoc2md 'src/*.js' > api.md\",\n    \"publish2\": \"npm run build && npm version patch -m \\\"build: release %s\\\" && npm publish\",\n    \"beta\": \"npm run build && npm publish --tag beta\"\n  },\n  \"files\": [\n    \"package.json\",\n    \"dist\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/ssshooter/mind-elixir-core\"\n  },\n  \"homepage\": \"https://mindelixir.ink/\",\n  \"author\": \"ssshooter\",\n  \"license\": \"MIT\",\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.4.5\",\n    \"@babel/plugin-transform-runtime\": \"^7.12.10\",\n    \"@babel/preset-env\": \"^7.11.5\",\n    \"@babel/runtime\": \"^7.15.4\",\n    \"@typescript-eslint/parser\": \"^5.0.0\",\n    \"babel-loader\": \"^8.0.6\",\n    \"canvg\": \"^3.0.6\",\n    \"css-loader\": \"^2.1.1\",\n    \"docdash\": \"^1.1.1\",\n    \"eslint\": \"^8.0.0\",\n    \"file-loader\": \"^4.0.0\",\n    \"html-webpack-plugin\": \"^5.3.2\",\n    \"jest\": \"^26.4.2\",\n    \"jsdoc\": \"^3.6.3\",\n    \"jsdoc-to-markdown\": \"^5.0.0\",\n    \"less\": \"^3.9.0\",\n    \"less-loader\": \"^5.0.0\",\n    \"puppeteer\": \"^5.2.1\",\n    \"puppeteer-to-istanbul\": \"^1.4.0\",\n    \"regenerator-runtime\": \"^0.13.7\",\n    \"style-loader\": \"^0.23.1\",\n    \"ts-loader\": \"^9.2.6\",\n    \"typescript\": \"^4.4.3\",\n    \"uglifyjs-webpack-plugin\": \"^2.1.3\",\n    \"url-loader\": \"^2.0.0\",\n    \"webpack\": \"5.58.1\",\n    \"webpack-bundle-analyzer\": \"^3.3.2\",\n    \"webpack-cli\": \"^3.3.2\",\n    \"webpack-dev-server\": \"^3.5.1\"\n  }\n}\n", "![mindelixir logo](https://raw.githubusercontent.com/ssshooter/mind-elixir-core/master/logo.png)\n\n<p>\n  <a href=\"https://www.npmjs.com/package/mind-elixir\">\n    <img src=\"https://img.shields.io/npm/v/mind-elixir\" alt=\"version\">\n  </a>\n  <img src=\"https://img.shields.io/npm/l/mind-elixir\" alt=\"license\">\n  <a href=\"https://app.codacy.com/gh/ssshooter/mind-elixir-core?utm_source=github.com&utm_medium=referral&utm_content=ssshooter/mind-elixir-core&utm_campaign=Badge_Grade_Settings\">\n    <img src=\"https://api.codacy.com/project/badge/Grade/09fadec5bf094886b30cea6aabf3a88b\" alt=\"code quality\">\n  </a>\n  <a href=\"https://bundlephobia.com/result?p=mind-elixir\">\n    <img src=\"https://badgen.net/bundlephobia/dependency-count/mind-elixir\" alt=\"dependency-count\">\n  </a>\n  <a href=\"https://packagephobia.com/result?p=mind-elixir\">\n    <img src=\"https://packagephobia.com/badge?p=mind-elixir\" alt=\"dependency-count\">\n  </a>\n</p>\n\nMind elixir is a free open source mind map core.\n\n[\u4e2d\u6587](https://github.com/ssshooter/mind-elixir-core/blob/master/readme.cn.md)\n\n## Use now\n\n![mindelixir](https://raw.githubusercontent.com/ssshooter/mind-elixir-core/master/screenshot.png)\n\nhttps://mindelixir.ink/#/\n\n### Playground\n\nhttps://codepen.io/ssshooter/pen/GVQRYK\n\nwith React https://codesandbox.io/s/mind-elixir-react-9sisb\n\nwith Vue https://codesandbox.io/s/mind-elixir-vue-nqjjl\n\n## Use in your project\n\n### Install\n\n#### NPM\n\n```bash\nnpm i mind-elixir -S\n```\n\n```javascript\nimport MindElixir, { E } from 'mind-elixir'\n```\n\n#### Script tag\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/regenerator-runtime\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/mind-elixir/dist/mind-elixir.js\"></script>\n```\n\n### HTML structure\n\n```html\n<div id=\"map\"></div>\n<style>\n  #map {\n    height: 500px;\n    width: 100%;\n  }\n</style>\n```\n\n### Init\n\n```javascript\nimport MindElixir, { E } from 'mind-elixir'\nimport { exportSvg, exportPng } from '../dist/painter'\nimport example from '../dist/example1'\n\nlet options = {\n  el: '#map',\n  direction: MindElixir.LEFT,\n  // create new map data\n  data: MindElixir.new('new topic') or example,\n  // the data return from `.getAllData()`\n  draggable: true, // default true\n  contextMenu: true, // default true\n  toolBar: true, // default true\n  nodeMenu: true, // default true\n  keypress: true, // default true\n  locale: 'en', // [zh_CN,zh_TW,en,ja,pt] waiting for PRs\n  overflowHidden: false, // default false\n  primaryLinkStyle: 2, // [1,2] default 1\n  primaryNodeVerticalGap: 15, // default 25\n  primaryNodeHorizontalGap: 15, // default 65\n  contextMenuOption: {\n    focus: true,\n    link: true,\n    extend: [\n      {\n        name: 'Node edit',\n        onclick: () => {\n          alert('extend menu')\n        },\n      },\n    ],\n  },\n  allowUndo: false,\n  before: {\n    insertSibling(el, obj) {\n      return true\n    },\n    async addChild(el, obj) {\n      await sleep()\n      return true\n    },\n  },\n}\n\nlet mind = new MindElixir(options)\nmind.init()\n\n// get a node\nE('node-id')\n\n```\n\n### Data Structure\n\n```javascript\n// whole node data structure up to now\n{\n  topic: 'node topic',\n  id: 'bd1c24420cd2c2f5',\n  style: { fontSize: '32', color: '#3298db', background: '#ecf0f1' },\n  parent: null,\n  tags: ['Tag'],\n  icons: ['\ud83d\ude00'],\n  hyperLink: 'https://github.com/ssshooter/mind-elixir-core',\n}\n```\n\n### Event Handling\n\n```javascript\nmind.bus.addListener('operation', operation => {\n  console.log(operation)\n  // return {\n  //   name: action name,\n  //   obj: target object\n  // }\n\n  // name: [insertSibling|addChild|removeNode|beginEdit|finishEdit]\n  // obj: target\n\n  // name: moveNode\n  // obj: {from:target1,to:target2}\n})\nmind.bus.addListener('selectNode', node => {\n  console.log(node)\n})\n```\n\n### Data Export\n\n```javascript\nmind.getAllData() // javascript object, see src/example.js\nmind.getAllDataString() // stringify object\nmind.getAllDataMd() // markdown\n```\n\n### Export as image\n\n```javascript\nimport painter from 'mind-elixir/dist/painter'\npainter.exportSvg()\npainter.exportPng()\n```\n\n### Operation Guards\n\n```javascript\nlet mind = new MindElixir({\n  ...\n  before: {\n    insertSibling(el, obj) {\n      console.log(el, obj)\n      if (this.currentNode.nodeObj.parent.root) {\n        return false\n      }\n      return true\n    },\n    async addChild(el, obj) {\n      await sleep()\n      if (this.currentNode.nodeObj.parent.root) {\n        return false\n      }\n      return true\n    },\n  },\n})\n```\n\n## Doc\n\nhttps://doc.mindelixir.ink/\n", "import i18n from '../i18n'\n\nexport default function(mind, option) {\n  const createTips = words => {\n    const div = document.createElement('div')\n    div.innerHTML = words\n    div.style.cssText = 'position:absolute;bottom:20px;left:50%;transform:translateX(-50%);'\n    return div\n  }\n  const createLi = (id, name, keyname) => {\n    const li = document.createElement('li')\n    li.id = id\n    li.innerHTML = `<span>${name}</span><span>${keyname}</span>`\n    return li\n  }\n  const locale = i18n[mind.locale] ? mind.locale : 'en'\n\n  const add_child = createLi('cm-add_child', i18n[locale].addChild, 'tab')\n  const add_sibling = createLi('cm-add_sibling', i18n[locale].addSibling, 'enter')\n  const remove_child = createLi(\n    'cm-remove_child',\n    i18n[locale].removeNode,\n    'delete'\n  )\n  const focus = createLi('cm-fucus', i18n[locale].focus, '')\n  const unfocus = createLi('cm-unfucus', i18n[locale].cancelFocus, '')\n  const up = createLi('cm-up', i18n[locale].moveUp, 'PgUp')\n  const down = createLi('cm-down', i18n[locale].moveDown, 'Pgdn')\n  const link = createLi('cm-down', i18n[locale].link, '')\n\n  const menuUl = document.createElement('ul')\n  menuUl.className = 'menu-list'\n  menuUl.appendChild(add_child)\n  menuUl.appendChild(add_sibling)\n  menuUl.appendChild(remove_child)\n  if (!option || option.focus) {\n    menuUl.appendChild(focus)\n    menuUl.appendChild(unfocus)\n  }\n  menuUl.appendChild(up)\n  menuUl.appendChild(down)\n  if (!option || option.link) {\n    menuUl.appendChild(link)\n  }\n  if (option && option.extend) {\n    for (let i = 0; i < option.extend.length; i++) {\n      const item = option.extend[i]\n      const dom = createLi(item.name, item.name, item.key || '')\n      menuUl.appendChild(dom)\n      dom.onclick = e => {\n        item.onclick(e)\n      }\n    }\n  }\n  const menuContainer = document.createElement('cmenu')\n  menuContainer.appendChild(menuUl)\n  menuContainer.hidden = true\n\n  mind.container.append(menuContainer)\n  let isRoot = true\n  mind.container.oncontextmenu = function(e) {\n    e.preventDefault()\n    if (!mind.editable) return\n    // console.log(e.pageY, e.screenY, e.clientY)\n    const target = e.target\n    if (target.tagName === 'TPC') {\n      if (target.parentElement.tagName === 'ROOT') {\n        isRoot = true\n      } else {\n        isRoot = false\n      }\n      if (isRoot) {\n        focus.className = 'disabled'\n        up.className = 'disabled'\n        down.className = 'disabled'\n        add_sibling.className = 'disabled'\n        remove_child.className = 'disabled'\n      } else {\n        focus.className = ''\n        up.className = ''\n        down.className = ''\n        add_sibling.className = ''\n        remove_child.className = ''\n      }\n      mind.selectNode(target)\n      menuContainer.hidden = false\n      const height = menuUl.offsetHeight\n      const width = menuUl.offsetWidth\n      if (height + e.clientY > window.innerHeight) {\n        menuUl.style.top = ''\n        menuUl.style.bottom = '0px'\n      } else {\n        menuUl.style.bottom = ''\n        menuUl.style.top = e.clientY + 15 + 'px'\n      }\n      if (width + e.clientX > window.innerWidth) {\n        menuUl.style.left = ''\n        menuUl.style.right = '0px'\n      } else {\n        menuUl.style.right = ''\n        menuUl.style.left = e.clientX + 10 + 'px'\n      }\n    }\n  }\n\n  menuContainer.onclick = e => {\n    if (e.target === menuContainer) menuContainer.hidden = true\n  }\n\n  add_child.onclick = e => {\n    mind.addChild()\n    menuContainer.hidden = true\n  }\n  add_sibling.onclick = e => {\n    if (isRoot) return\n    mind.insertSibling()\n    menuContainer.hidden = true\n  }\n  remove_child.onclick = e => {\n    if (isRoot) return\n    mind.removeNode()\n    menuContainer.hidden = true\n  }\n  focus.onclick = e => {\n    if (isRoot) return\n    mind.focusNode(mind.currentNode)\n    menuContainer.hidden = true\n  }\n  unfocus.onclick = e => {\n    mind.cancelFocus()\n    menuContainer.hidden = true\n  }\n  up.onclick = e => {\n    if (isRoot) return\n    mind.moveUpNode()\n    menuContainer.hidden = true\n  }\n  down.onclick = e => {\n    if (isRoot) return\n    mind.moveDownNode()\n    menuContainer.hidden = true\n  }\n  link.onclick = e => {\n    menuContainer.hidden = true\n    const from = mind.currentNode\n    const tips = createTips(i18n[locale].clickTips)\n    mind.container.appendChild(tips)\n    mind.map.addEventListener(\n      'click',\n      e => {\n        e.preventDefault()\n        tips.remove()\n        if (\n          e.target.parentElement.nodeName === 'T' ||\n          e.target.parentElement.nodeName === 'ROOT'\n        ) {\n          mind.createLink(from, mind.currentNode)\n        } else {\n          console.log('\u53d6\u6d88\u8fde\u63a5')\n        }\n      },\n      {\n        once: true,\n      }\n    )\n  }\n}\n", "import i18n from '../i18n'\n\nconst createDiv = (id, name) => {\n  const div = document.createElement('div')\n  div.id = id\n  div.innerHTML = `<span>${name}</span>`\n  return div\n}\n\nconst colorList = [\n  '#2c3e50',\n  '#34495e',\n  '#7f8c8d',\n  '#94a5a6',\n  '#bdc3c7',\n  '#ecf0f1',\n  '#8e44ad',\n  '#9b59b6',\n  '#2980b9',\n  '#3298db',\n  '#c0392c',\n  '#e74c3c',\n  '#d35400',\n  '#f39c11',\n  '#f1c40e',\n  '#17a085',\n  '#27ae61',\n  '#2ecc71',\n]\n\nexport default function(mind) {\n  const locale = i18n[mind.locale] ? mind.locale : 'en'\n  let bgOrFont\n  const styleDiv = createDiv('nm-style', 'style')\n  const tagDiv = createDiv('nm-tag', 'tag')\n  const iconDiv = createDiv('nm-icon', 'icon')\n\n  styleDiv.innerHTML = `\n      <div class=\"nm-fontsize-container\">\n        ${['15', '24', '32']\n    .map(size => {\n      return `<div class=\"size\"  data-size=\"${size}\">\n        <svg class=\"icon\" style=\"width: ${size}px;height: ${size}px\" aria-hidden=\"true\">\n          <use xlink:href=\"#icon-a\"></use>\n        </svg></div>`\n    })\n    .join('')}<div class=\"bold\"><svg class=\"icon\" aria-hidden=\"true\">\n  <use xlink:href=\"#icon-B\"></use>\n  </svg></div>\n      </div>\n      <div class=\"nm-fontcolor-container\">\n        ${colorList\n    .map(color => {\n      return `<div class=\"split6\"><div class=\"palette\" data-color=\"${color}\" style=\"background-color: ${color};\"></div></div>`\n    })\n    .join('')}\n      </div>\n      <div class=\"bof\">\n      <span class=\"font\">${i18n[locale].font}</span>\n      <span class=\"background\">${i18n[locale].background}</span>\n      </div>\n  `\n  tagDiv.innerHTML = `\n      ${i18n[locale].tag}<input class=\"nm-tag\" tabindex=\"-1\" placeholder=\"${i18n[locale].tagsSeparate}\" /><br>\n  `\n  iconDiv.innerHTML = `\n      ${i18n[locale].icon}<input class=\"nm-icon\" tabindex=\"-1\" placeholder=\"${i18n[locale].iconsSeparate}\" /><br>\n  `\n\n  const menuContainer = document.createElement('nmenu')\n  menuContainer.innerHTML = `\n  <div class=\"button-container\"><svg class=\"icon\" aria-hidden=\"true\">\n  <use xlink:href=\"#icon-close\"></use>\n  </svg></div>\n  `\n  menuContainer.appendChild(styleDiv)\n  menuContainer.appendChild(tagDiv)\n  menuContainer.appendChild(iconDiv)\n  menuContainer.hidden = true\n\n  function clearSelect(klass, remove) {\n    var elems = mind.container.querySelectorAll(klass)\n    ;[].forEach.call(elems, function(el) {\n      el.classList.remove(remove)\n    })\n  }\n\n  mind.container.append(menuContainer)\n  const sizeSelector = menuContainer.querySelectorAll('.size')\n  const bold:HTMLElement = menuContainer.querySelector('.bold')\n  const buttonContainer:HTMLElement = menuContainer.querySelector('.button-container')\n  const fontBtn:HTMLElement = menuContainer.querySelector('.font')\n  const tagInput:HTMLInputElement = mind.container.querySelector('.nm-tag')\n  const iconInput:HTMLInputElement = mind.container.querySelector('.nm-icon')\n  menuContainer.onclick = e => {\n    if (!mind.currentNode) return\n    const nodeObj = mind.currentNode.nodeObj\n    const target = e.target as HTMLElement\n    if (target.className === 'palette') {\n      if (!nodeObj.style) nodeObj.style = {}\n      clearSelect('.palette', 'nmenu-selected')\n      target.className = 'palette nmenu-selected'\n      if (bgOrFont === 'font') {\n        nodeObj.style.color = target.dataset.color\n      } else if (bgOrFont === 'background') {\n        nodeObj.style.background = target.dataset.color\n      }\n      mind.updateNodeStyle(nodeObj)\n    } else if (target.className === 'background') {\n      clearSelect('.palette', 'nmenu-selected')\n      bgOrFont = 'background'\n      target.className = 'background selected'\n      target.previousElementSibling.className = 'font'\n      if (nodeObj.style && nodeObj.style.background) {\n        menuContainer.querySelector(\n          '.palette[data-color=\"' + nodeObj.style.background + '\"]'\n        ).className = 'palette nmenu-selected'\n      }\n    } else if (target.className === 'font') {\n      clearSelect('.palette', 'nmenu-selected')\n      bgOrFont = 'font'\n      target.className = 'font selected'\n      target.nextElementSibling.className = 'background'\n      if (nodeObj.style && nodeObj.style.color) {\n        menuContainer.querySelector(\n          '.palette[data-color=\"' + nodeObj.style.color + '\"]'\n        ).className = 'palette nmenu-selected'\n      }\n    }\n  }\n  Array.from(sizeSelector).map(\n    dom => {\n      (dom as HTMLElement).onclick = e => {\n        if (!mind.currentNode.nodeObj.style) mind.currentNode.nodeObj.style = {}\n        clearSelect('.size', 'size-selected')\n        const size = e.currentTarget as HTMLElement\n        mind.currentNode.nodeObj.style.fontSize = size.dataset.size\n        size.className = 'size size-selected'\n        mind.updateNodeStyle(mind.currentNode.nodeObj)\n      }\n    }\n  )\n  bold.onclick = (e:MouseEvent & { currentTarget: Element}) => {\n    if (!mind.currentNode.nodeObj.style) mind.currentNode.nodeObj.style = {}\n    if (mind.currentNode.nodeObj.style.fontWeight === 'bold') {\n      delete mind.currentNode.nodeObj.style.fontWeight\n      e.currentTarget.className = 'bold'\n      mind.updateNodeStyle(mind.currentNode.nodeObj)\n    } else {\n      mind.currentNode.nodeObj.style.fontWeight = 'bold'\n      e.currentTarget.className = 'bold size-selected'\n      mind.updateNodeStyle(mind.currentNode.nodeObj)\n    }\n  }\n  tagInput.onchange = (e:InputEvent & { target: HTMLInputElement}) => {\n    if (!mind.currentNode) return\n    if (e.target.value) {\n      const newTags = e.target.value.split(',')\n      mind.updateNodeTags(mind.currentNode.nodeObj, newTags)\n    }\n  }\n  iconInput.onchange = (e:InputEvent & { target: HTMLInputElement}) => {\n    if (!mind.currentNode) return\n    if (e.target.value) {\n      const newIcons = e.target.value.split(',')\n      mind.updateNodeIcons(mind.currentNode.nodeObj, newIcons)\n    }\n  }\n  let state = 'open'\n  buttonContainer.onclick = e => {\n    if (state === 'open') {\n      state = 'close'\n      menuContainer.className = 'close'\n      buttonContainer.innerHTML = `<svg class=\"icon\" aria-hidden=\"true\"><use xlink:href=\"#icon-menu\"></use></svg>`\n    } else {\n      state = 'open'\n      menuContainer.className = ''\n      buttonContainer.innerHTML = `<svg class=\"icon\" aria-hidden=\"true\"><use xlink:href=\"#icon-close\"></use></svg>`\n    }\n  }\n  mind.bus.addListener('unselectNode', function() {\n    menuContainer.hidden = true\n  })\n  mind.bus.addListener('selectNode', function(nodeObj) {\n    menuContainer.hidden = false\n    clearSelect('.palette', 'nmenu-selected')\n    clearSelect('.size', 'size-selected')\n    clearSelect('.bold', 'size-selected')\n    bgOrFont = 'font'\n    fontBtn.className = 'font selected'\n    fontBtn.nextElementSibling.className = 'background'\n    if (nodeObj.style) {\n      if (nodeObj.style.fontSize) {\n        menuContainer.querySelector(\n          '.size[data-size=\"' + nodeObj.style.fontSize + '\"]'\n        ).className = 'size size-selected'\n      }\n      if (nodeObj.style.fontWeight) { menuContainer.querySelector('.bold').className = 'bold size-selected' }\n      if (nodeObj.style.color) {\n        menuContainer.querySelector(\n          '.palette[data-color=\"' + nodeObj.style.color + '\"]'\n        ).className = 'palette nmenu-selected'\n      }\n    }\n    if (nodeObj.tags) {\n      tagInput.value = nodeObj.tags.join(',')\n    } else {\n      tagInput.value = ''\n    }\n    if (nodeObj.icons) {\n      iconInput.value = nodeObj.icons.join(',')\n    } else {\n      iconInput.value = ''\n    }\n  })\n}\n", "const createButton = (id, name) => {\n  const button = document.createElement('span')\n  button.id = id\n  button.innerHTML = `<svg class=\"icon\" aria-hidden=\"true\">\n    <use xlink:href=\"#icon-${name}\"></use>\n  </svg>`\n  return button\n}\n\nfunction createToolBarRBContainer(mind) {\n  const toolBarRBContainer = document.createElement('toolbar')\n  const fc = createButton('fullscreen', 'full')\n  const gc = createButton('toCenter', 'living')\n  const zo = createButton('zoomout', 'move')\n  const zi = createButton('zoomin', 'add')\n  const percentage = document.createElement('span')\n  percentage.innerHTML = '100%'\n  toolBarRBContainer.appendChild(fc)\n  toolBarRBContainer.appendChild(gc)\n  toolBarRBContainer.appendChild(zo)\n  toolBarRBContainer.appendChild(zi)\n  // toolBarRBContainer.appendChild(percentage)\n  toolBarRBContainer.className = 'rb'\n  fc.onclick = () => {\n    mind.container.requestFullscreen()\n  }\n  gc.onclick = () => {\n    mind.toCenter()\n  }\n  zo.onclick = () => {\n    if (mind.scaleVal < 0.6) return\n    mind.scale((mind.scaleVal -= 0.2))\n  }\n  zi.onclick = () => {\n    if (mind.scaleVal > 1.6) return\n    mind.scale((mind.scaleVal += 0.2))\n  }\n  return toolBarRBContainer\n}\nfunction createToolBarLTContainer(mind) {\n  const toolBarLTContainer = document.createElement('toolbar')\n  const l = createButton('tbltl', 'left')\n  const r = createButton('tbltr', 'right')\n  const s = createButton('tblts', 'side')\n\n  toolBarLTContainer.appendChild(l)\n  toolBarLTContainer.appendChild(r)\n  toolBarLTContainer.appendChild(s)\n  toolBarLTContainer.className = 'lt'\n  l.onclick = () => {\n    mind.initLeft()\n  }\n  r.onclick = () => {\n    mind.initRight()\n  }\n  s.onclick = () => {\n    mind.initSide()\n  }\n  return toolBarLTContainer\n}\n\nexport default function(mind) {\n  mind.container.append(createToolBarRBContainer(mind))\n  mind.container.append(createToolBarLTContainer(mind))\n}\n", "import { LEFT, RIGHT, SIDE } from '../const'\nimport vari from '../var'\nimport { NodeObj } from '../index'\n\nexport type Top = HTMLElement\n\nexport type Group = HTMLElement\n\nexport interface Topic extends HTMLElement {\n  nodeObj?: NodeObj\n}\n\nexport interface Expander extends HTMLElement {\n  expanded?: boolean\n}\n\n// DOM manipulation\nconst $d = document\nexport const findEle = (id: string, instance?) => {\n  const scope = instance ? instance.mindElixirBox : $d\n  return scope.querySelector(`[data-nodeid=me${id}]`)\n}\n\nexport const createGroup = function(nodeObj: NodeObj) {\n  const grp: Group = $d.createElement('GRP')\n  const top: Top = createTop(nodeObj)\n  grp.appendChild(top)\n  if (nodeObj.children && nodeObj.children.length > 0) {\n    top.appendChild(createExpander(nodeObj.expanded))\n    if (nodeObj.expanded !== false) {\n      const children = createChildren(nodeObj.children)\n      grp.appendChild(children)\n    }\n  }\n  return { grp, top }\n}\n\nexport const shapeTpc = function(tpc: Topic, nodeObj: NodeObj) {\n  tpc.innerHTML = nodeObj.topic\n\n  if (nodeObj.style) {\n    tpc.style.color = nodeObj.style.color || 'inherit'\n    tpc.style.background = nodeObj.style.background || 'inherit'\n    tpc.style.fontSize = nodeObj.style.fontSize + 'px'\n    tpc.style.fontWeight = nodeObj.style.fontWeight || 'normal'\n  }\n\n  // TODO allow to add online image\n  // if (nodeObj.image) {\n  //   const imgContainer = $d.createElement('img')\n  //   imgContainer.src = nodeObj.image.url\n  //   imgContainer.style.width = nodeObj.image.width + 'px'\n  //   tpc.appendChild(imgContainer)\n  // }\n  if (nodeObj.hyperLink) {\n    const linkContainer = $d.createElement('a')\n    linkContainer.className = 'hyper-link'\n    linkContainer.target = '_blank'\n    linkContainer.innerHTML = '\ud83d\udd17'\n    linkContainer.href = nodeObj.hyperLink\n    tpc.appendChild(linkContainer)\n  }\n  if (nodeObj.icons) {\n    const iconsContainer = $d.createElement('span')\n    iconsContainer.className = 'icons'\n    iconsContainer.innerHTML = nodeObj.icons\n      .map(icon => `<span>${icon}</span>`)\n      .join('')\n    tpc.appendChild(iconsContainer)\n  }\n  if (nodeObj.tags) {\n    const tagsContainer = $d.createElement('div')\n    tagsContainer.className = 'tags'\n    tagsContainer.innerHTML = nodeObj.tags\n      .map(tag => `<span>${tag}</span>`)\n      .join('')\n    tpc.appendChild(tagsContainer)\n  }\n}\n\nexport const createTop = function(nodeObj: NodeObj): Top {\n  const top = $d.createElement('t')\n  const tpc = createTopic(nodeObj)\n  shapeTpc(tpc, nodeObj)\n  top.appendChild(tpc)\n  return top\n}\n\nexport const createTopic = function(nodeObj: NodeObj): Topic {\n  const topic: Topic = $d.createElement('tpc')\n  topic.nodeObj = nodeObj\n  topic.dataset.nodeid = 'me' + nodeObj.id\n  topic.draggable = vari.draggable\n  return topic\n}\n\nexport function selectText(div: HTMLElement) {\n  const range = $d.createRange()\n  range.selectNodeContents(div)\n  const getSelection = window.getSelection()\n  if (getSelection) {\n    getSelection.removeAllRanges()\n    getSelection.addRange(range)\n  }\n}\n\nexport function createInputDiv(tpc: Topic) {\n  console.time('createInputDiv')\n  if (!tpc) return\n  let div = $d.createElement('div')\n  const origin = tpc.childNodes[0].textContent as string\n  tpc.appendChild(div)\n  div.innerHTML = origin\n  div.contentEditable = 'true'\n  div.spellcheck = false\n  div.style.cssText = `min-width:${tpc.offsetWidth - 8}px;`\n  if (this.direction === LEFT) div.style.right = '0'\n  div.focus()\n\n  selectText(div)\n  this.inputDiv = div\n\n  this.bus.fire('operation', {\n    name: 'beginEdit',\n    obj: tpc.nodeObj,\n  })\n\n  div.addEventListener('keydown', e => {\n    e.stopPropagation()\n    const key = e.key\n    console.log(e, key)\n    if (key === 'Enter' || key === 'Tab') {\n      // keep wrap for shift enter\n      if (e.shiftKey) return\n\n      e.preventDefault()\n      this.inputDiv.blur()\n      this.map.focus()\n    }\n  })\n  div.addEventListener('blur', () => {\n    if (!div) return // \u9632\u6b62\u91cd\u590dblur\n    const node = tpc.nodeObj\n    const topic = div.textContent!.trim()\n    if (topic === '') node.topic = origin\n    else node.topic = topic\n    div.remove()\n    this.inputDiv = div = null\n    this.bus.fire('operation', {\n      name: 'finishEdit',\n      obj: node,\n      origin,\n    })\n    if (topic === origin) return // \u6ca1\u6709\u4fee\u6539\u4e0d\u505a\u5904\u7406\n    tpc.childNodes[0].textContent = node.topic\n    this.linkDiv()\n  })\n  console.timeEnd('createInputDiv')\n}\n\nexport const createExpander = function(expanded: boolean | undefined): Expander {\n  const expander: Expander = $d.createElement('epd')\n  // \u5305\u542b\u672a\u5b9a\u4e49 expanded \u7684\u60c5\u51b5\uff0c\u672a\u5b9a\u4e49\u89c6\u4e3a\u5c55\u5f00\n  expander.innerHTML = expanded !== false ? '-' : '+'\n  expander.expanded = expanded !== false\n  expander.className = expanded !== false ? 'minus' : ''\n  return expander\n}\n\n/**\n * traversal data and generate dom structure of mind map\n * @ignore\n * @param {object} data node data object\n * @param {object} container node container(mostly primary node)\n * @param {number} direction primary node direction\n * @return {ChildrenElement} children element.\n */\nexport function createChildren(data: NodeObj[], container?: HTMLElement, direction?) {\n  let chldr: HTMLElement\n  if (container) {\n    chldr = container\n  } else {\n    chldr = $d.createElement('children')\n  }\n  for (let i = 0; i < data.length; i++) {\n    const nodeObj = data[i]\n    const grp = $d.createElement('GRP')\n    if (direction === LEFT) {\n      grp.className = 'lhs'\n    } else if (direction === RIGHT) {\n      grp.className = 'rhs'\n    } else if (direction === SIDE) {\n      if (nodeObj.direction === LEFT) {\n        grp.className = 'lhs'\n      } else if (nodeObj.direction === RIGHT) {\n        grp.className = 'rhs'\n      }\n    }\n    const top = createTop(nodeObj)\n    if (nodeObj.children && nodeObj.children.length > 0) {\n      top.appendChild(createExpander(nodeObj.expanded))\n      grp.appendChild(top)\n      if (nodeObj.expanded !== false) {\n        const children = createChildren(nodeObj.children)\n        grp.appendChild(children)\n      }\n    } else {\n      grp.appendChild(top)\n    }\n    chldr.appendChild(grp)\n  }\n  return chldr\n}\n\n// Set primary nodes' direction and invoke createChildren()\nexport function layout() {\n  console.time('layout')\n  this.root.innerHTML = ''\n  this.box.innerHTML = ''\n  const tpc = createTopic(this.nodeData)\n  shapeTpc(tpc, this.nodeData) // shape root tpc\n  tpc.draggable = false\n  this.root.appendChild(tpc)\n\n  const primaryNodes: NodeObj[] = this.nodeData.children\n  if (!primaryNodes || primaryNodes.length === 0) return\n  if (this.direction === SIDE) {\n    // initiate direction of primary nodes\n    let lcount = 0\n    let rcount = 0\n    primaryNodes.map(node => {\n      if (node.direction === undefined) {\n        if (lcount <= rcount) {\n          node.direction = LEFT\n          lcount += 1\n        } else {\n          node.direction = RIGHT\n          rcount += 1\n        }\n      } else {\n        if (node.direction === LEFT) {\n          lcount += 1\n        } else {\n          rcount += 1\n        }\n      }\n    })\n  }\n  createChildren(this.nodeData.children, this.box, this.direction)\n  console.timeEnd('layout')\n}\n", "import vari from '../var'\nimport { NodeObj } from '../index'\n\nexport const isMobile = (): boolean =>\n  /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n    navigator.userAgent\n  )\n\nexport const rgbHex = (rgb) => {\n  return rgb.replace(\n    /\\brgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/g,\n    function($0, $1, $2, $3) {\n      return '#' + ('0' + Number($1).toString(16)).substr(-2) + ('0' + Number($2).toString(16)).substr(-2) + ('0' + Number($3).toString(16)).substr(-2)\n    })\n}\n\nexport const getObjById = function(id: string, data: NodeObj) {\n  data = data || this.nodeData\n  if (data.id === id) {\n    return data\n  } else if (data.children && data.children.length) {\n    for (let i = 0; i < data.children.length; i++) {\n      const res = getObjById(id, data.children[i])\n      if (res) return res\n    }\n  } else {\n    return null\n  }\n}\n\nexport const addParentLink = (data: NodeObj, parent?: NodeObj) => {\n  data.parent = parent\n  if (data.children) {\n    for (let i = 0; i < data.children.length; i++) {\n      addParentLink(data.children[i], data)\n    }\n  }\n}\n\nexport const throttle = (fn: (any) => void, wait: number) => {\n  var pre = Date.now()\n  return function() {\n    var context = this\n    var args = arguments\n    var now = Date.now()\n    if (now - pre >= wait) {\n      fn.apply(context, args)\n      pre = Date.now()\n    }\n  }\n}\n\nexport function getArrowPoints(p3x: number, p3y: number, p4x: number, p4y: number) {\n  const deltay = p4y - p3y\n  const deltax = p3x - p4x\n  let angle = (Math.atan(Math.abs(deltay) / Math.abs(deltax)) / 3.14) * 180\n  if (deltax < 0 && deltay > 0) {\n    angle = 180 - angle\n  }\n  if (deltax < 0 && deltay < 0) {\n    angle = 180 + angle\n  }\n  if (deltax > 0 && deltay < 0) {\n    angle = 360 - angle\n  }\n  const arrowLength = 20\n  const arrowAngle = 30\n  var a1 = angle + arrowAngle\n  const a2 = angle - arrowAngle\n  return {\n    x1: p4x + Math.cos((Math.PI * a1) / 180) * arrowLength,\n    y1: p4y - Math.sin((Math.PI * a1) / 180) * arrowLength,\n    x2: p4x + Math.cos((Math.PI * a2) / 180) * arrowLength,\n    y2: p4y - Math.sin((Math.PI * a2) / 180) * arrowLength,\n  }\n}\n\nexport function calcP1(fromData, p2x, p2y) {\n  let x, y\n  const k = (fromData.cy - p2y) / (p2x - fromData.cx)\n  if (k > fromData.h / fromData.w || k < -fromData.h / fromData.w) {\n    if (fromData.cy - p2y < 0) {\n      x = fromData.cx - fromData.h / 2 / k\n      y = fromData.cy + fromData.h / 2\n    } else {\n      x = fromData.cx + fromData.h / 2 / k\n      y = fromData.cy - fromData.h / 2\n    }\n  } else {\n    // console.log('\u659c\u7387', k)\n    // console.log('fromData.cx-x', fromData.cx - p2x)\n    if (fromData.cx - p2x < 0) {\n      x = fromData.cx + fromData.w / 2\n      y = fromData.cy - (fromData.w * k) / 2\n    } else {\n      x = fromData.cx - fromData.w / 2\n      y = fromData.cy + (fromData.w * k) / 2\n    }\n  }\n  return {\n    x,\n    y,\n  }\n}\n\nexport function calcP4(toData, p3x, p3y) {\n  let x, y\n  const k = (toData.cy - p3y) / (p3x - toData.cx)\n  if (k > toData.h / toData.w || k < -toData.h / toData.w) {\n    if (toData.cy - p3y < 0) {\n      x = toData.cx - toData.h / 2 / k\n      y = toData.cy + toData.h / 2\n    } else {\n      x = toData.cx + toData.h / 2 / k\n      y = toData.cy - toData.h / 2\n    }\n  } else {\n    // console.log('\u659c\u7387', k)\n    // console.log('toData.cx-x', toData.cx - p3x)\n    if (toData.cx - p3x < 0) {\n      x = toData.cx + toData.w / 2\n      y = toData.cy - (toData.w * k) / 2\n    } else {\n      x = toData.cx - toData.w / 2\n      y = toData.cy + (toData.w * k) / 2\n    }\n  }\n  return {\n    x,\n    y,\n  }\n}\n\nexport function generateUUID(): string {\n  return (\n    new Date().getTime().toString(16) + Math.random().toString(16).substr(2)\n  ).substr(2, 16)\n}\n\nexport function generateNewObj(): NodeObj {\n  const id = generateUUID()\n  return {\n    topic: vari.newTopicName || 'new node',\n    id,\n  }\n}\n\nexport function generateNewLink(from, to) {\n  const id = generateUUID()\n  return {\n    id,\n    name: '',\n    from,\n    to,\n    delta1: { x: 0, y: -100 },\n    delta2: { x: 0, y: -100 },\n  }\n}\n\nexport function checkMoveValid(from: NodeObj, to: NodeObj) {\n  let valid = true\n  while (to.parent) {\n    if (to.parent === from) {\n      valid = false\n      break\n    }\n    to = to.parent\n  }\n  return valid\n}\n\nexport function getObjSibling(obj: NodeObj): NodeObj {\n  const childrenList = obj.parent.children\n  const index = childrenList.indexOf(obj)\n  if (index + 1 >= childrenList.length) {\n    // \u6700\u540e\u4e00\u4e2a\n    return null\n  } else {\n    return childrenList[index + 1]\n  }\n}\n\nexport function moveUpObj(obj: NodeObj) {\n  const childrenList = obj.parent.children\n  const index = childrenList.indexOf(obj)\n  const t = childrenList[index]\n  if (index === 0) {\n    childrenList[index] = childrenList[childrenList.length - 1]\n    childrenList[childrenList.length - 1] = t\n  } else {\n    childrenList[index] = childrenList[index - 1]\n    childrenList[index - 1] = t\n  }\n}\n\nexport function moveDownObj(obj: NodeObj) {\n  const childrenList = obj.parent.children\n  const index = childrenList.indexOf(obj)\n  const t = childrenList[index]\n  if (index === childrenList.length - 1) {\n    childrenList[index] = childrenList[0]\n    childrenList[0] = t\n  } else {\n    childrenList[index] = childrenList[index + 1]\n    childrenList[index + 1] = t\n  }\n}\n\nexport function removeNodeObj(obj: NodeObj) {\n  const childrenList = obj.parent.children\n  const index = childrenList.indexOf(obj)\n  childrenList.splice(index, 1)\n  return childrenList.length\n}\n\nexport function insertNodeObj(obj: NodeObj, newObj: NodeObj) {\n  const childrenList = obj.parent.children\n  const index = childrenList.indexOf(obj)\n  childrenList.splice(index + 1, 0, newObj)\n}\n\nexport function insertBeforeNodeObj(obj: NodeObj, newObj: NodeObj) {\n  const childrenList = obj.parent.children\n  const index = childrenList.indexOf(obj)\n  childrenList.splice(index, 0, newObj)\n}\n\nexport function moveNodeObj(from: NodeObj, to: NodeObj) {\n  removeNodeObj(from)\n  if (to.children) to.children.push(from)\n  else to.children = [from]\n}\n\nexport function moveNodeBeforeObj(from: NodeObj, to: NodeObj) {\n  removeNodeObj(from)\n  const childrenList = to.parent.children\n  let toIndex = 0\n  for (let i = 0; i < childrenList.length; i++) {\n    if (childrenList[i] === to) {\n      toIndex = i\n      break\n    }\n  }\n  childrenList.splice(toIndex, 0, from)\n}\n\nexport function moveNodeAfterObj(from: NodeObj, to: NodeObj) {\n  removeNodeObj(from)\n  const childrenList = to.parent.children\n  let toIndex = 0\n  for (let i = 0; i < childrenList.length; i++) {\n    if (childrenList[i] === to) {\n      toIndex = i\n      break\n    }\n  }\n  childrenList.splice(toIndex + 1, 0, from)\n}\n\nexport const dragMoveHelper = {\n  afterMoving: false, // \u533a\u522bclick\u4e8b\u4ef6\n  mousedown: false,\n  lastX: null,\n  lastY: null,\n  onMove(e, container) {\n    if (this.mousedown) {\n      this.afterMoving = true\n      if (!this.lastX) {\n        this.lastX = e.pageX\n        this.lastY = e.pageY\n        return\n      }\n      const deltaX = this.lastX - e.pageX\n      const deltaY = this.lastY - e.pageY\n      container.scrollTo(\n        container.scrollLeft + deltaX,\n        container.scrollTop + deltaY\n      )\n      this.lastX = e.pageX\n      this.lastY = e.pageY\n    }\n  },\n  clear() {\n    this.afterMoving = false\n    this.mousedown = false\n    this.lastX = null\n    this.lastY = null\n  },\n}\n\nexport function LinkDragMoveHelper(dom) {\n  this.dom = dom\n  this.mousedown = false\n  this.lastX = null\n  this.lastY = null\n}\n\nLinkDragMoveHelper.prototype.init = function(map, cb) {\n  this.handleMouseMove = e => {\n    e.stopPropagation()\n    if (this.mousedown) {\n      if (!this.lastX) {\n        this.lastX = e.pageX\n        this.lastY = e.pageY\n        return\n      }\n      const deltaX = this.lastX - e.pageX\n      const deltaY = this.lastY - e.pageY\n      cb(deltaX, deltaY)\n      this.lastX = e.pageX\n      this.lastY = e.pageY\n    }\n  }\n  this.handleMouseDown = e => {\n    e.stopPropagation()\n    this.mousedown = true\n  }\n  this.handleClear = e => {\n    e.stopPropagation()\n    this.clear()\n  }\n  map.addEventListener('mousemove', this.handleMouseMove)\n  map.addEventListener('mouseleave', this.handleClear)\n  map.addEventListener('mouseup', this.handleClear)\n  this.dom.addEventListener('mousedown', this.handleMouseDown)\n}\n\nLinkDragMoveHelper.prototype.destory = function(map) {\n  map.removeEventListener('mousemove', this.handleMouseMove)\n  map.removeEventListener('mouseleave', this.handleClear)\n  map.removeEventListener('mouseup', this.handleClear)\n  this.dom.removeEventListener('mousedown', this.handleMouseDown)\n}\n\nLinkDragMoveHelper.prototype.clear = function() {\n  this.mousedown = false\n  this.lastX = null\n  this.lastY = null\n}\n"], "fixing_code": ["{\n  \"name\": \"mind-elixir\",\n  \"version\": \"0.18.1\",\n  \"description\": \"Mind elixir is a free open source mind map core.\",\n  \"main\": \"dist/MindElixir.js\",\n  \"scripts\": {\n    \"start\": \"webpack-dev-server --mode development --env.dist=0\",\n    \"startd\": \"webpack-dev-server --mode development --env.dist=1\",\n    \"test\": \"jest --runInBand\",\n    \"build\": \"webpack --mode production\",\n    \"doc\": \"./node_modules/.bin/jsdoc src/ -R readme.md -c conf.json\",\n    \"md\": \"./node_modules/.bin/jsdoc2md 'src/*.js' > api.md\",\n    \"publish2\": \"npm run build && npm version patch -m \\\"build: release %s\\\" && npm publish\",\n    \"beta\": \"npm run build && npm publish --tag beta\"\n  },\n  \"files\": [\n    \"package.json\",\n    \"dist\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/ssshooter/mind-elixir-core\"\n  },\n  \"homepage\": \"https://mindelixir.ink/\",\n  \"author\": \"ssshooter\",\n  \"license\": \"MIT\",\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.4.5\",\n    \"@babel/plugin-transform-runtime\": \"^7.12.10\",\n    \"@babel/preset-env\": \"^7.11.5\",\n    \"@babel/runtime\": \"^7.15.4\",\n    \"@typescript-eslint/parser\": \"^5.0.0\",\n    \"babel-loader\": \"^8.0.6\",\n    \"canvg\": \"^3.0.6\",\n    \"css-loader\": \"^2.1.1\",\n    \"docdash\": \"^1.1.1\",\n    \"eslint\": \"^8.0.0\",\n    \"file-loader\": \"^4.0.0\",\n    \"html-webpack-plugin\": \"^5.3.2\",\n    \"jest\": \"^26.4.2\",\n    \"jsdoc\": \"^3.6.3\",\n    \"jsdoc-to-markdown\": \"^5.0.0\",\n    \"less\": \"^3.9.0\",\n    \"less-loader\": \"^5.0.0\",\n    \"puppeteer\": \"^5.2.1\",\n    \"puppeteer-to-istanbul\": \"^1.4.0\",\n    \"regenerator-runtime\": \"^0.13.7\",\n    \"style-loader\": \"^0.23.1\",\n    \"ts-loader\": \"^9.2.6\",\n    \"typescript\": \"^4.4.3\",\n    \"uglifyjs-webpack-plugin\": \"^2.1.3\",\n    \"url-loader\": \"^2.0.0\",\n    \"webpack\": \"5.58.1\",\n    \"webpack-bundle-analyzer\": \"^3.3.2\",\n    \"webpack-cli\": \"^3.3.2\",\n    \"webpack-dev-server\": \"^3.5.1\"\n  }\n}\n", "![mindelixir logo](https://raw.githubusercontent.com/ssshooter/mind-elixir-core/master/logo.png)\n\n<p>\n  <a href=\"https://www.npmjs.com/package/mind-elixir\">\n    <img src=\"https://img.shields.io/npm/v/mind-elixir\" alt=\"version\">\n  </a>\n  <img src=\"https://img.shields.io/npm/l/mind-elixir\" alt=\"license\">\n  <a href=\"https://app.codacy.com/gh/ssshooter/mind-elixir-core?utm_source=github.com&utm_medium=referral&utm_content=ssshooter/mind-elixir-core&utm_campaign=Badge_Grade_Settings\">\n    <img src=\"https://api.codacy.com/project/badge/Grade/09fadec5bf094886b30cea6aabf3a88b\" alt=\"code quality\">\n  </a>\n  <a href=\"https://bundlephobia.com/result?p=mind-elixir\">\n    <img src=\"https://badgen.net/bundlephobia/dependency-count/mind-elixir\" alt=\"dependency-count\">\n  </a>\n  <a href=\"https://packagephobia.com/result?p=mind-elixir\">\n    <img src=\"https://packagephobia.com/badge?p=mind-elixir\" alt=\"dependency-count\">\n  </a>\n</p>\n\nMind elixir is a free open source mind map core.\n\n[\u4e2d\u6587](https://github.com/ssshooter/mind-elixir-core/blob/master/readme.cn.md)\n\n## Use now\n\n![mindelixir](https://raw.githubusercontent.com/ssshooter/mind-elixir-core/master/screenshot.png)\n\nhttps://mindelixir.ink/#/\n\n### Playground\n\nhttps://codepen.io/ssshooter/pen/GVQRYK\n\nwith React https://codesandbox.io/s/mind-elixir-react-9sisb\n\nwith Vue https://codesandbox.io/s/mind-elixir-vue-nqjjl\n\n## Use in your project\n\n### Install\n\n#### NPM\n\n```bash\nnpm i mind-elixir -S\n```\n\n```javascript\nimport MindElixir, { E } from 'mind-elixir'\n```\n\n#### Script tag\n\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/mind-elixir/dist/mind-elixir.js\"></script>\n```\n\n### HTML structure\n\n```html\n<div id=\"map\"></div>\n<style>\n  #map {\n    height: 500px;\n    width: 100%;\n  }\n</style>\n```\n\n### Init\n\n```javascript\nimport MindElixir, { E } from 'mind-elixir'\nimport { exportSvg, exportPng } from '../dist/painter'\nimport example from '../dist/example1'\n\nlet options = {\n  el: '#map',\n  direction: MindElixir.LEFT,\n  // create new map data\n  data: MindElixir.new('new topic') or example,\n  // the data return from `.getAllData()`\n  draggable: true, // default true\n  contextMenu: true, // default true\n  toolBar: true, // default true\n  nodeMenu: true, // default true\n  keypress: true, // default true\n  locale: 'en', // [zh_CN,zh_TW,en,ja,pt] waiting for PRs\n  overflowHidden: false, // default false\n  primaryLinkStyle: 2, // [1,2] default 1\n  primaryNodeVerticalGap: 15, // default 25\n  primaryNodeHorizontalGap: 15, // default 65\n  contextMenuOption: {\n    focus: true,\n    link: true,\n    extend: [\n      {\n        name: 'Node edit',\n        onclick: () => {\n          alert('extend menu')\n        },\n      },\n    ],\n  },\n  allowUndo: false,\n  before: {\n    insertSibling(el, obj) {\n      return true\n    },\n    async addChild(el, obj) {\n      await sleep()\n      return true\n    },\n  },\n}\n\nlet mind = new MindElixir(options)\nmind.init()\n\n// get a node\nE('node-id')\n\n```\n\n### Data Structure\n\n```javascript\n// whole node data structure up to now\n{\n  topic: 'node topic',\n  id: 'bd1c24420cd2c2f5',\n  style: { fontSize: '32', color: '#3298db', background: '#ecf0f1' },\n  parent: null,\n  tags: ['Tag'],\n  icons: ['\ud83d\ude00'],\n  hyperLink: 'https://github.com/ssshooter/mind-elixir-core',\n}\n```\n\n### Event Handling\n\n```javascript\nmind.bus.addListener('operation', operation => {\n  console.log(operation)\n  // return {\n  //   name: action name,\n  //   obj: target object\n  // }\n\n  // name: [insertSibling|addChild|removeNode|beginEdit|finishEdit]\n  // obj: target\n\n  // name: moveNode\n  // obj: {from:target1,to:target2}\n})\nmind.bus.addListener('selectNode', node => {\n  console.log(node)\n})\n```\n\n### Data Export\n\n```javascript\nmind.getAllData() // javascript object, see src/example.js\nmind.getAllDataString() // stringify object\nmind.getAllDataMd() // markdown\n```\n\n### Export as image\n\n```javascript\nimport painter from 'mind-elixir/dist/painter'\npainter.exportSvg()\npainter.exportPng()\n```\n\n### Operation Guards\n\n```javascript\nlet mind = new MindElixir({\n  ...\n  before: {\n    insertSibling(el, obj) {\n      console.log(el, obj)\n      if (this.currentNode.nodeObj.parent.root) {\n        return false\n      }\n      return true\n    },\n    async addChild(el, obj) {\n      await sleep()\n      if (this.currentNode.nodeObj.parent.root) {\n        return false\n      }\n      return true\n    },\n  },\n})\n```\n\n## Doc\n\nhttps://doc.mindelixir.ink/\n", "import i18n from '../i18n'\nimport { encodeHTML } from '../utils/index'\n\nexport default function(mind, option) {\n  const createTips = words => {\n    const div = document.createElement('div')\n    div.innerText = words\n    div.style.cssText = 'position:absolute;bottom:20px;left:50%;transform:translateX(-50%);'\n    return div\n  }\n  const createLi = (id, name, keyname) => {\n    const li = document.createElement('li')\n    li.id = id\n    li.innerHTML = `<span>${encodeHTML(name)}</span><span>${encodeHTML(keyname)}</span>`\n    return li\n  }\n  const locale = i18n[mind.locale] ? mind.locale : 'en'\n\n  const add_child = createLi('cm-add_child', i18n[locale].addChild, 'tab')\n  const add_sibling = createLi('cm-add_sibling', i18n[locale].addSibling, 'enter')\n  const remove_child = createLi(\n    'cm-remove_child',\n    i18n[locale].removeNode,\n    'delete'\n  )\n  const focus = createLi('cm-fucus', i18n[locale].focus, '')\n  const unfocus = createLi('cm-unfucus', i18n[locale].cancelFocus, '')\n  const up = createLi('cm-up', i18n[locale].moveUp, 'PgUp')\n  const down = createLi('cm-down', i18n[locale].moveDown, 'Pgdn')\n  const link = createLi('cm-down', i18n[locale].link, '')\n\n  const menuUl = document.createElement('ul')\n  menuUl.className = 'menu-list'\n  menuUl.appendChild(add_child)\n  menuUl.appendChild(add_sibling)\n  menuUl.appendChild(remove_child)\n  if (!option || option.focus) {\n    menuUl.appendChild(focus)\n    menuUl.appendChild(unfocus)\n  }\n  menuUl.appendChild(up)\n  menuUl.appendChild(down)\n  if (!option || option.link) {\n    menuUl.appendChild(link)\n  }\n  if (option && option.extend) {\n    for (let i = 0; i < option.extend.length; i++) {\n      const item = option.extend[i]\n      const dom = createLi(item.name, item.name, item.key || '')\n      menuUl.appendChild(dom)\n      dom.onclick = e => {\n        item.onclick(e)\n      }\n    }\n  }\n  const menuContainer = document.createElement('cmenu')\n  menuContainer.appendChild(menuUl)\n  menuContainer.hidden = true\n\n  mind.container.append(menuContainer)\n  let isRoot = true\n  mind.container.oncontextmenu = function(e) {\n    e.preventDefault()\n    if (!mind.editable) return\n    // console.log(e.pageY, e.screenY, e.clientY)\n    const target = e.target\n    if (target.tagName === 'TPC') {\n      if (target.parentElement.tagName === 'ROOT') {\n        isRoot = true\n      } else {\n        isRoot = false\n      }\n      if (isRoot) {\n        focus.className = 'disabled'\n        up.className = 'disabled'\n        down.className = 'disabled'\n        add_sibling.className = 'disabled'\n        remove_child.className = 'disabled'\n      } else {\n        focus.className = ''\n        up.className = ''\n        down.className = ''\n        add_sibling.className = ''\n        remove_child.className = ''\n      }\n      mind.selectNode(target)\n      menuContainer.hidden = false\n      const height = menuUl.offsetHeight\n      const width = menuUl.offsetWidth\n      if (height + e.clientY > window.innerHeight) {\n        menuUl.style.top = ''\n        menuUl.style.bottom = '0px'\n      } else {\n        menuUl.style.bottom = ''\n        menuUl.style.top = e.clientY + 15 + 'px'\n      }\n      if (width + e.clientX > window.innerWidth) {\n        menuUl.style.left = ''\n        menuUl.style.right = '0px'\n      } else {\n        menuUl.style.right = ''\n        menuUl.style.left = e.clientX + 10 + 'px'\n      }\n    }\n  }\n\n  menuContainer.onclick = e => {\n    if (e.target === menuContainer) menuContainer.hidden = true\n  }\n\n  add_child.onclick = e => {\n    mind.addChild()\n    menuContainer.hidden = true\n  }\n  add_sibling.onclick = e => {\n    if (isRoot) return\n    mind.insertSibling()\n    menuContainer.hidden = true\n  }\n  remove_child.onclick = e => {\n    if (isRoot) return\n    mind.removeNode()\n    menuContainer.hidden = true\n  }\n  focus.onclick = e => {\n    if (isRoot) return\n    mind.focusNode(mind.currentNode)\n    menuContainer.hidden = true\n  }\n  unfocus.onclick = e => {\n    mind.cancelFocus()\n    menuContainer.hidden = true\n  }\n  up.onclick = e => {\n    if (isRoot) return\n    mind.moveUpNode()\n    menuContainer.hidden = true\n  }\n  down.onclick = e => {\n    if (isRoot) return\n    mind.moveDownNode()\n    menuContainer.hidden = true\n  }\n  link.onclick = e => {\n    menuContainer.hidden = true\n    const from = mind.currentNode\n    const tips = createTips(i18n[locale].clickTips)\n    mind.container.appendChild(tips)\n    mind.map.addEventListener(\n      'click',\n      e => {\n        e.preventDefault()\n        tips.remove()\n        if (\n          e.target.parentElement.nodeName === 'T' ||\n          e.target.parentElement.nodeName === 'ROOT'\n        ) {\n          mind.createLink(from, mind.currentNode)\n        } else {\n          console.log('\u53d6\u6d88\u8fde\u63a5')\n        }\n      },\n      {\n        once: true,\n      }\n    )\n  }\n}\n", "import i18n from '../i18n'\n\nconst createDiv = (id) => {\n  const div = document.createElement('div')\n  div.id = id\n  return div\n}\n\nconst colorList = [\n  '#2c3e50',\n  '#34495e',\n  '#7f8c8d',\n  '#94a5a6',\n  '#bdc3c7',\n  '#ecf0f1',\n  '#8e44ad',\n  '#9b59b6',\n  '#2980b9',\n  '#3298db',\n  '#c0392c',\n  '#e74c3c',\n  '#d35400',\n  '#f39c11',\n  '#f1c40e',\n  '#17a085',\n  '#27ae61',\n  '#2ecc71',\n]\n\nexport default function(mind) {\n  const locale = i18n[mind.locale] ? mind.locale : 'en'\n  let bgOrFont\n  const styleDiv = createDiv('nm-style')\n  const tagDiv = createDiv('nm-tag')\n  const iconDiv = createDiv('nm-icon')\n\n  styleDiv.innerHTML = `\n      <div class=\"nm-fontsize-container\">\n        ${['15', '24', '32']\n    .map(size => {\n      return `<div class=\"size\"  data-size=\"${size}\">\n        <svg class=\"icon\" style=\"width: ${size}px;height: ${size}px\" aria-hidden=\"true\">\n          <use xlink:href=\"#icon-a\"></use>\n        </svg></div>`\n    })\n    .join('')}<div class=\"bold\"><svg class=\"icon\" aria-hidden=\"true\">\n  <use xlink:href=\"#icon-B\"></use>\n  </svg></div>\n      </div>\n      <div class=\"nm-fontcolor-container\">\n        ${colorList\n    .map(color => {\n      return `<div class=\"split6\"><div class=\"palette\" data-color=\"${color}\" style=\"background-color: ${color};\"></div></div>`\n    })\n    .join('')}\n      </div>\n      <div class=\"bof\">\n      <span class=\"font\">${i18n[locale].font}</span>\n      <span class=\"background\">${i18n[locale].background}</span>\n      </div>\n  `\n  tagDiv.innerHTML = `${i18n[locale].tag}<input class=\"nm-tag\" tabindex=\"-1\" placeholder=\"${i18n[locale].tagsSeparate}\" /><br>`\n  iconDiv.innerHTML = `${i18n[locale].icon}<input class=\"nm-icon\" tabindex=\"-1\" placeholder=\"${i18n[locale].iconsSeparate}\" /><br>`\n\n  const menuContainer = document.createElement('nmenu')\n  menuContainer.innerHTML = `\n  <div class=\"button-container\"><svg class=\"icon\" aria-hidden=\"true\">\n  <use xlink:href=\"#icon-close\"></use>\n  </svg></div>\n  `\n  menuContainer.appendChild(styleDiv)\n  menuContainer.appendChild(tagDiv)\n  menuContainer.appendChild(iconDiv)\n  menuContainer.hidden = true\n\n  function clearSelect(klass, remove) {\n    var elems = mind.container.querySelectorAll(klass)\n    ;[].forEach.call(elems, function(el) {\n      el.classList.remove(remove)\n    })\n  }\n\n  mind.container.append(menuContainer)\n  const sizeSelector = menuContainer.querySelectorAll('.size')\n  const bold:HTMLElement = menuContainer.querySelector('.bold')\n  const buttonContainer:HTMLElement = menuContainer.querySelector('.button-container')\n  const fontBtn:HTMLElement = menuContainer.querySelector('.font')\n  const tagInput:HTMLInputElement = mind.container.querySelector('.nm-tag')\n  const iconInput:HTMLInputElement = mind.container.querySelector('.nm-icon')\n  menuContainer.onclick = e => {\n    if (!mind.currentNode) return\n    const nodeObj = mind.currentNode.nodeObj\n    const target = e.target as HTMLElement\n    if (target.className === 'palette') {\n      if (!nodeObj.style) nodeObj.style = {}\n      clearSelect('.palette', 'nmenu-selected')\n      target.className = 'palette nmenu-selected'\n      if (bgOrFont === 'font') {\n        nodeObj.style.color = target.dataset.color\n      } else if (bgOrFont === 'background') {\n        nodeObj.style.background = target.dataset.color\n      }\n      mind.updateNodeStyle(nodeObj)\n    } else if (target.className === 'background') {\n      clearSelect('.palette', 'nmenu-selected')\n      bgOrFont = 'background'\n      target.className = 'background selected'\n      target.previousElementSibling.className = 'font'\n      if (nodeObj.style && nodeObj.style.background) {\n        menuContainer.querySelector(\n          '.palette[data-color=\"' + nodeObj.style.background + '\"]'\n        ).className = 'palette nmenu-selected'\n      }\n    } else if (target.className === 'font') {\n      clearSelect('.palette', 'nmenu-selected')\n      bgOrFont = 'font'\n      target.className = 'font selected'\n      target.nextElementSibling.className = 'background'\n      if (nodeObj.style && nodeObj.style.color) {\n        menuContainer.querySelector(\n          '.palette[data-color=\"' + nodeObj.style.color + '\"]'\n        ).className = 'palette nmenu-selected'\n      }\n    }\n  }\n  Array.from(sizeSelector).map(\n    dom => {\n      (dom as HTMLElement).onclick = e => {\n        if (!mind.currentNode.nodeObj.style) mind.currentNode.nodeObj.style = {}\n        clearSelect('.size', 'size-selected')\n        const size = e.currentTarget as HTMLElement\n        mind.currentNode.nodeObj.style.fontSize = size.dataset.size\n        size.className = 'size size-selected'\n        mind.updateNodeStyle(mind.currentNode.nodeObj)\n      }\n    }\n  )\n  bold.onclick = (e:MouseEvent & { currentTarget: Element}) => {\n    if (!mind.currentNode.nodeObj.style) mind.currentNode.nodeObj.style = {}\n    if (mind.currentNode.nodeObj.style.fontWeight === 'bold') {\n      delete mind.currentNode.nodeObj.style.fontWeight\n      e.currentTarget.className = 'bold'\n      mind.updateNodeStyle(mind.currentNode.nodeObj)\n    } else {\n      mind.currentNode.nodeObj.style.fontWeight = 'bold'\n      e.currentTarget.className = 'bold size-selected'\n      mind.updateNodeStyle(mind.currentNode.nodeObj)\n    }\n  }\n  tagInput.onchange = (e:InputEvent & { target: HTMLInputElement}) => {\n    if (!mind.currentNode) return\n    if (e.target.value) {\n      const newTags = e.target.value.split(',')\n      mind.updateNodeTags(mind.currentNode.nodeObj, newTags)\n    }\n  }\n  iconInput.onchange = (e:InputEvent & { target: HTMLInputElement}) => {\n    if (!mind.currentNode) return\n    if (e.target.value) {\n      const newIcons = e.target.value.split(',')\n      mind.updateNodeIcons(mind.currentNode.nodeObj, newIcons)\n    }\n  }\n  let state = 'open'\n  buttonContainer.onclick = e => {\n    if (state === 'open') {\n      state = 'close'\n      menuContainer.className = 'close'\n      buttonContainer.innerHTML = `<svg class=\"icon\" aria-hidden=\"true\"><use xlink:href=\"#icon-menu\"></use></svg>`\n    } else {\n      state = 'open'\n      menuContainer.className = ''\n      buttonContainer.innerHTML = `<svg class=\"icon\" aria-hidden=\"true\"><use xlink:href=\"#icon-close\"></use></svg>`\n    }\n  }\n  mind.bus.addListener('unselectNode', function() {\n    menuContainer.hidden = true\n  })\n  mind.bus.addListener('selectNode', function(nodeObj) {\n    menuContainer.hidden = false\n    clearSelect('.palette', 'nmenu-selected')\n    clearSelect('.size', 'size-selected')\n    clearSelect('.bold', 'size-selected')\n    bgOrFont = 'font'\n    fontBtn.className = 'font selected'\n    fontBtn.nextElementSibling.className = 'background'\n    if (nodeObj.style) {\n      if (nodeObj.style.fontSize) {\n        menuContainer.querySelector(\n          '.size[data-size=\"' + nodeObj.style.fontSize + '\"]'\n        ).className = 'size size-selected'\n      }\n      if (nodeObj.style.fontWeight) { menuContainer.querySelector('.bold').className = 'bold size-selected' }\n      if (nodeObj.style.color) {\n        menuContainer.querySelector(\n          '.palette[data-color=\"' + nodeObj.style.color + '\"]'\n        ).className = 'palette nmenu-selected'\n      }\n    }\n    if (nodeObj.tags) {\n      tagInput.value = nodeObj.tags.join(',')\n    } else {\n      tagInput.value = ''\n    }\n    if (nodeObj.icons) {\n      iconInput.value = nodeObj.icons.join(',')\n    } else {\n      iconInput.value = ''\n    }\n  })\n}\n", "const createButton = (id, name) => {\n  const button = document.createElement('span')\n  button.id = id\n  button.innerHTML = `<svg class=\"icon\" aria-hidden=\"true\">\n    <use xlink:href=\"#icon-${name}\"></use>\n  </svg>`\n  return button\n}\n\nfunction createToolBarRBContainer(mind) {\n  const toolBarRBContainer = document.createElement('toolbar')\n  const fc = createButton('fullscreen', 'full')\n  const gc = createButton('toCenter', 'living')\n  const zo = createButton('zoomout', 'move')\n  const zi = createButton('zoomin', 'add')\n  const percentage = document.createElement('span')\n  percentage.innerText = '100%'\n  toolBarRBContainer.appendChild(fc)\n  toolBarRBContainer.appendChild(gc)\n  toolBarRBContainer.appendChild(zo)\n  toolBarRBContainer.appendChild(zi)\n  // toolBarRBContainer.appendChild(percentage)\n  toolBarRBContainer.className = 'rb'\n  fc.onclick = () => {\n    mind.container.requestFullscreen()\n  }\n  gc.onclick = () => {\n    mind.toCenter()\n  }\n  zo.onclick = () => {\n    if (mind.scaleVal < 0.6) return\n    mind.scale((mind.scaleVal -= 0.2))\n  }\n  zi.onclick = () => {\n    if (mind.scaleVal > 1.6) return\n    mind.scale((mind.scaleVal += 0.2))\n  }\n  return toolBarRBContainer\n}\nfunction createToolBarLTContainer(mind) {\n  const toolBarLTContainer = document.createElement('toolbar')\n  const l = createButton('tbltl', 'left')\n  const r = createButton('tbltr', 'right')\n  const s = createButton('tblts', 'side')\n\n  toolBarLTContainer.appendChild(l)\n  toolBarLTContainer.appendChild(r)\n  toolBarLTContainer.appendChild(s)\n  toolBarLTContainer.className = 'lt'\n  l.onclick = () => {\n    mind.initLeft()\n  }\n  r.onclick = () => {\n    mind.initRight()\n  }\n  s.onclick = () => {\n    mind.initSide()\n  }\n  return toolBarLTContainer\n}\n\nexport default function(mind) {\n  mind.container.append(createToolBarRBContainer(mind))\n  mind.container.append(createToolBarLTContainer(mind))\n}\n", "import { LEFT, RIGHT, SIDE } from '../const'\nimport vari from '../var'\nimport { NodeObj } from '../index'\nimport { encodeHTML } from '../utils/index'\nexport type Top = HTMLElement\n\nexport type Group = HTMLElement\n\nexport interface Topic extends HTMLElement {\n  nodeObj?: NodeObj\n}\n\nexport interface Expander extends HTMLElement {\n  expanded?: boolean\n}\n\n// DOM manipulation\nconst $d = document\nexport const findEle = (id: string, instance?) => {\n  const scope = instance ? instance.mindElixirBox : $d\n  return scope.querySelector(`[data-nodeid=me${id}]`)\n}\n\nexport const createGroup = function(nodeObj: NodeObj) {\n  const grp: Group = $d.createElement('GRP')\n  const top: Top = createTop(nodeObj)\n  grp.appendChild(top)\n  if (nodeObj.children && nodeObj.children.length > 0) {\n    top.appendChild(createExpander(nodeObj.expanded))\n    if (nodeObj.expanded !== false) {\n      const children = createChildren(nodeObj.children)\n      grp.appendChild(children)\n    }\n  }\n  return { grp, top }\n}\n\nexport const shapeTpc = function(tpc: Topic, nodeObj: NodeObj) {\n  tpc.innerText = nodeObj.topic\n\n  if (nodeObj.style) {\n    tpc.style.color = nodeObj.style.color || 'inherit'\n    tpc.style.background = nodeObj.style.background || 'inherit'\n    tpc.style.fontSize = nodeObj.style.fontSize + 'px'\n    tpc.style.fontWeight = nodeObj.style.fontWeight || 'normal'\n  }\n\n  // TODO allow to add online image\n  // if (nodeObj.image) {\n  //   const imgContainer = $d.createElement('img')\n  //   imgContainer.src = nodeObj.image.url\n  //   imgContainer.style.width = nodeObj.image.width + 'px'\n  //   tpc.appendChild(imgContainer)\n  // }\n  if (nodeObj.hyperLink) {\n    const linkContainer = $d.createElement('a')\n    linkContainer.className = 'hyper-link'\n    linkContainer.target = '_blank'\n    linkContainer.innerText = '\ud83d\udd17'\n    linkContainer.href = nodeObj.hyperLink\n    tpc.appendChild(linkContainer)\n  }\n  if (nodeObj.icons) {\n    const iconsContainer = $d.createElement('span')\n    iconsContainer.className = 'icons'\n    iconsContainer.innerHTML = nodeObj.icons\n      .map(icon => `<span>${encodeHTML(icon)}</span>`)\n      .join('')\n    tpc.appendChild(iconsContainer)\n  }\n  if (nodeObj.tags) {\n    const tagsContainer = $d.createElement('div')\n    tagsContainer.className = 'tags'\n    tagsContainer.innerHTML = nodeObj.tags\n      .map(tag => `<span>${encodeHTML(tag)}</span>`)\n      .join('')\n    tpc.appendChild(tagsContainer)\n  }\n}\n\nexport const createTop = function(nodeObj: NodeObj): Top {\n  const top = $d.createElement('t')\n  const tpc = createTopic(nodeObj)\n  shapeTpc(tpc, nodeObj)\n  top.appendChild(tpc)\n  return top\n}\n\nexport const createTopic = function(nodeObj: NodeObj): Topic {\n  const topic: Topic = $d.createElement('tpc')\n  topic.nodeObj = nodeObj\n  topic.dataset.nodeid = 'me' + nodeObj.id\n  topic.draggable = vari.draggable\n  return topic\n}\n\nexport function selectText(div: HTMLElement) {\n  const range = $d.createRange()\n  range.selectNodeContents(div)\n  const getSelection = window.getSelection()\n  if (getSelection) {\n    getSelection.removeAllRanges()\n    getSelection.addRange(range)\n  }\n}\n\nexport function createInputDiv(tpc: Topic) {\n  console.time('createInputDiv')\n  if (!tpc) return\n  let div = $d.createElement('div')\n  const origin = tpc.childNodes[0].textContent as string\n  tpc.appendChild(div)\n  div.innerText = origin\n  div.contentEditable = 'true'\n  div.spellcheck = false\n  div.style.cssText = `min-width:${tpc.offsetWidth - 8}px;`\n  if (this.direction === LEFT) div.style.right = '0'\n  div.focus()\n\n  selectText(div)\n  this.inputDiv = div\n\n  this.bus.fire('operation', {\n    name: 'beginEdit',\n    obj: tpc.nodeObj,\n  })\n\n  div.addEventListener('keydown', e => {\n    e.stopPropagation()\n    const key = e.key\n    console.log(e, key)\n    if (key === 'Enter' || key === 'Tab') {\n      // keep wrap for shift enter\n      if (e.shiftKey) return\n\n      e.preventDefault()\n      this.inputDiv.blur()\n      this.map.focus()\n    }\n  })\n  div.addEventListener('blur', () => {\n    if (!div) return // \u9632\u6b62\u91cd\u590dblur\n    const node = tpc.nodeObj\n    const topic = div.textContent!.trim()\n    if (topic === '') node.topic = origin\n    else node.topic = topic\n    div.remove()\n    this.inputDiv = div = null\n    this.bus.fire('operation', {\n      name: 'finishEdit',\n      obj: node,\n      origin,\n    })\n    if (topic === origin) return // \u6ca1\u6709\u4fee\u6539\u4e0d\u505a\u5904\u7406\n    tpc.childNodes[0].textContent = node.topic\n    this.linkDiv()\n  })\n  console.timeEnd('createInputDiv')\n}\n\nexport const createExpander = function(expanded: boolean | undefined): Expander {\n  const expander: Expander = $d.createElement('epd')\n  // \u5305\u542b\u672a\u5b9a\u4e49 expanded \u7684\u60c5\u51b5\uff0c\u672a\u5b9a\u4e49\u89c6\u4e3a\u5c55\u5f00\n  expander.innerText = expanded !== false ? '-' : '+'\n  expander.expanded = expanded !== false\n  expander.className = expanded !== false ? 'minus' : ''\n  return expander\n}\n\n/**\n * traversal data and generate dom structure of mind map\n * @ignore\n * @param {object} data node data object\n * @param {object} container node container(mostly primary node)\n * @param {number} direction primary node direction\n * @return {ChildrenElement} children element.\n */\nexport function createChildren(data: NodeObj[], container?: HTMLElement, direction?) {\n  let chldr: HTMLElement\n  if (container) {\n    chldr = container\n  } else {\n    chldr = $d.createElement('children')\n  }\n  for (let i = 0; i < data.length; i++) {\n    const nodeObj = data[i]\n    const grp = $d.createElement('GRP')\n    if (direction === LEFT) {\n      grp.className = 'lhs'\n    } else if (direction === RIGHT) {\n      grp.className = 'rhs'\n    } else if (direction === SIDE) {\n      if (nodeObj.direction === LEFT) {\n        grp.className = 'lhs'\n      } else if (nodeObj.direction === RIGHT) {\n        grp.className = 'rhs'\n      }\n    }\n    const top = createTop(nodeObj)\n    if (nodeObj.children && nodeObj.children.length > 0) {\n      top.appendChild(createExpander(nodeObj.expanded))\n      grp.appendChild(top)\n      if (nodeObj.expanded !== false) {\n        const children = createChildren(nodeObj.children)\n        grp.appendChild(children)\n      }\n    } else {\n      grp.appendChild(top)\n    }\n    chldr.appendChild(grp)\n  }\n  return chldr\n}\n\n// Set primary nodes' direction and invoke createChildren()\nexport function layout() {\n  console.time('layout')\n  this.root.innerHTML = ''\n  this.box.innerHTML = ''\n  const tpc = createTopic(this.nodeData)\n  shapeTpc(tpc, this.nodeData) // shape root tpc\n  tpc.draggable = false\n  this.root.appendChild(tpc)\n\n  const primaryNodes: NodeObj[] = this.nodeData.children\n  if (!primaryNodes || primaryNodes.length === 0) return\n  if (this.direction === SIDE) {\n    // initiate direction of primary nodes\n    let lcount = 0\n    let rcount = 0\n    primaryNodes.map(node => {\n      if (node.direction === undefined) {\n        if (lcount <= rcount) {\n          node.direction = LEFT\n          lcount += 1\n        } else {\n          node.direction = RIGHT\n          rcount += 1\n        }\n      } else {\n        if (node.direction === LEFT) {\n          lcount += 1\n        } else {\n          rcount += 1\n        }\n      }\n    })\n  }\n  createChildren(this.nodeData.children, this.box, this.direction)\n  console.timeEnd('layout')\n}\n", "import vari from '../var'\nimport { NodeObj } from '../index'\n\nexport function encodeHTML(s) {\n  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\"/g, '&quot;')\n}\n\nexport const isMobile = (): boolean =>\n  /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n    navigator.userAgent\n  )\n\nexport const rgbHex = (rgb) => {\n  return rgb.replace(\n    /\\brgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/g,\n    function($0, $1, $2, $3) {\n      return '#' + ('0' + Number($1).toString(16)).substr(-2) + ('0' + Number($2).toString(16)).substr(-2) + ('0' + Number($3).toString(16)).substr(-2)\n    })\n}\n\nexport const getObjById = function(id: string, data: NodeObj) {\n  data = data || this.nodeData\n  if (data.id === id) {\n    return data\n  } else if (data.children && data.children.length) {\n    for (let i = 0; i < data.children.length; i++) {\n      const res = getObjById(id, data.children[i])\n      if (res) return res\n    }\n  } else {\n    return null\n  }\n}\n\nexport const addParentLink = (data: NodeObj, parent?: NodeObj) => {\n  data.parent = parent\n  if (data.children) {\n    for (let i = 0; i < data.children.length; i++) {\n      addParentLink(data.children[i], data)\n    }\n  }\n}\n\nexport const throttle = (fn: (any) => void, wait: number) => {\n  var pre = Date.now()\n  return function() {\n    var context = this\n    var args = arguments\n    var now = Date.now()\n    if (now - pre >= wait) {\n      fn.apply(context, args)\n      pre = Date.now()\n    }\n  }\n}\n\nexport function getArrowPoints(p3x: number, p3y: number, p4x: number, p4y: number) {\n  const deltay = p4y - p3y\n  const deltax = p3x - p4x\n  let angle = (Math.atan(Math.abs(deltay) / Math.abs(deltax)) / 3.14) * 180\n  if (deltax < 0 && deltay > 0) {\n    angle = 180 - angle\n  }\n  if (deltax < 0 && deltay < 0) {\n    angle = 180 + angle\n  }\n  if (deltax > 0 && deltay < 0) {\n    angle = 360 - angle\n  }\n  const arrowLength = 20\n  const arrowAngle = 30\n  var a1 = angle + arrowAngle\n  const a2 = angle - arrowAngle\n  return {\n    x1: p4x + Math.cos((Math.PI * a1) / 180) * arrowLength,\n    y1: p4y - Math.sin((Math.PI * a1) / 180) * arrowLength,\n    x2: p4x + Math.cos((Math.PI * a2) / 180) * arrowLength,\n    y2: p4y - Math.sin((Math.PI * a2) / 180) * arrowLength,\n  }\n}\n\nexport function calcP1(fromData, p2x, p2y) {\n  let x, y\n  const k = (fromData.cy - p2y) / (p2x - fromData.cx)\n  if (k > fromData.h / fromData.w || k < -fromData.h / fromData.w) {\n    if (fromData.cy - p2y < 0) {\n      x = fromData.cx - fromData.h / 2 / k\n      y = fromData.cy + fromData.h / 2\n    } else {\n      x = fromData.cx + fromData.h / 2 / k\n      y = fromData.cy - fromData.h / 2\n    }\n  } else {\n    // console.log('\u659c\u7387', k)\n    // console.log('fromData.cx-x', fromData.cx - p2x)\n    if (fromData.cx - p2x < 0) {\n      x = fromData.cx + fromData.w / 2\n      y = fromData.cy - (fromData.w * k) / 2\n    } else {\n      x = fromData.cx - fromData.w / 2\n      y = fromData.cy + (fromData.w * k) / 2\n    }\n  }\n  return {\n    x,\n    y,\n  }\n}\n\nexport function calcP4(toData, p3x, p3y) {\n  let x, y\n  const k = (toData.cy - p3y) / (p3x - toData.cx)\n  if (k > toData.h / toData.w || k < -toData.h / toData.w) {\n    if (toData.cy - p3y < 0) {\n      x = toData.cx - toData.h / 2 / k\n      y = toData.cy + toData.h / 2\n    } else {\n      x = toData.cx + toData.h / 2 / k\n      y = toData.cy - toData.h / 2\n    }\n  } else {\n    // console.log('\u659c\u7387', k)\n    // console.log('toData.cx-x', toData.cx - p3x)\n    if (toData.cx - p3x < 0) {\n      x = toData.cx + toData.w / 2\n      y = toData.cy - (toData.w * k) / 2\n    } else {\n      x = toData.cx - toData.w / 2\n      y = toData.cy + (toData.w * k) / 2\n    }\n  }\n  return {\n    x,\n    y,\n  }\n}\n\nexport function generateUUID(): string {\n  return (\n    new Date().getTime().toString(16) + Math.random().toString(16).substr(2)\n  ).substr(2, 16)\n}\n\nexport function generateNewObj(): NodeObj {\n  const id = generateUUID()\n  return {\n    topic: vari.newTopicName || 'new node',\n    id,\n  }\n}\n\nexport function generateNewLink(from, to) {\n  const id = generateUUID()\n  return {\n    id,\n    name: '',\n    from,\n    to,\n    delta1: { x: 0, y: -100 },\n    delta2: { x: 0, y: -100 },\n  }\n}\n\nexport function checkMoveValid(from: NodeObj, to: NodeObj) {\n  let valid = true\n  while (to.parent) {\n    if (to.parent === from) {\n      valid = false\n      break\n    }\n    to = to.parent\n  }\n  return valid\n}\n\nexport function getObjSibling(obj: NodeObj): NodeObj {\n  const childrenList = obj.parent.children\n  const index = childrenList.indexOf(obj)\n  if (index + 1 >= childrenList.length) {\n    // \u6700\u540e\u4e00\u4e2a\n    return null\n  } else {\n    return childrenList[index + 1]\n  }\n}\n\nexport function moveUpObj(obj: NodeObj) {\n  const childrenList = obj.parent.children\n  const index = childrenList.indexOf(obj)\n  const t = childrenList[index]\n  if (index === 0) {\n    childrenList[index] = childrenList[childrenList.length - 1]\n    childrenList[childrenList.length - 1] = t\n  } else {\n    childrenList[index] = childrenList[index - 1]\n    childrenList[index - 1] = t\n  }\n}\n\nexport function moveDownObj(obj: NodeObj) {\n  const childrenList = obj.parent.children\n  const index = childrenList.indexOf(obj)\n  const t = childrenList[index]\n  if (index === childrenList.length - 1) {\n    childrenList[index] = childrenList[0]\n    childrenList[0] = t\n  } else {\n    childrenList[index] = childrenList[index + 1]\n    childrenList[index + 1] = t\n  }\n}\n\nexport function removeNodeObj(obj: NodeObj) {\n  const childrenList = obj.parent.children\n  const index = childrenList.indexOf(obj)\n  childrenList.splice(index, 1)\n  return childrenList.length\n}\n\nexport function insertNodeObj(obj: NodeObj, newObj: NodeObj) {\n  const childrenList = obj.parent.children\n  const index = childrenList.indexOf(obj)\n  childrenList.splice(index + 1, 0, newObj)\n}\n\nexport function insertBeforeNodeObj(obj: NodeObj, newObj: NodeObj) {\n  const childrenList = obj.parent.children\n  const index = childrenList.indexOf(obj)\n  childrenList.splice(index, 0, newObj)\n}\n\nexport function moveNodeObj(from: NodeObj, to: NodeObj) {\n  removeNodeObj(from)\n  if (to.children) to.children.push(from)\n  else to.children = [from]\n}\n\nexport function moveNodeBeforeObj(from: NodeObj, to: NodeObj) {\n  removeNodeObj(from)\n  const childrenList = to.parent.children\n  let toIndex = 0\n  for (let i = 0; i < childrenList.length; i++) {\n    if (childrenList[i] === to) {\n      toIndex = i\n      break\n    }\n  }\n  childrenList.splice(toIndex, 0, from)\n}\n\nexport function moveNodeAfterObj(from: NodeObj, to: NodeObj) {\n  removeNodeObj(from)\n  const childrenList = to.parent.children\n  let toIndex = 0\n  for (let i = 0; i < childrenList.length; i++) {\n    if (childrenList[i] === to) {\n      toIndex = i\n      break\n    }\n  }\n  childrenList.splice(toIndex + 1, 0, from)\n}\n\nexport const dragMoveHelper = {\n  afterMoving: false, // \u533a\u522bclick\u4e8b\u4ef6\n  mousedown: false,\n  lastX: null,\n  lastY: null,\n  onMove(e, container) {\n    if (this.mousedown) {\n      this.afterMoving = true\n      if (!this.lastX) {\n        this.lastX = e.pageX\n        this.lastY = e.pageY\n        return\n      }\n      const deltaX = this.lastX - e.pageX\n      const deltaY = this.lastY - e.pageY\n      container.scrollTo(\n        container.scrollLeft + deltaX,\n        container.scrollTop + deltaY\n      )\n      this.lastX = e.pageX\n      this.lastY = e.pageY\n    }\n  },\n  clear() {\n    this.afterMoving = false\n    this.mousedown = false\n    this.lastX = null\n    this.lastY = null\n  },\n}\n\nexport function LinkDragMoveHelper(dom) {\n  this.dom = dom\n  this.mousedown = false\n  this.lastX = null\n  this.lastY = null\n}\n\nLinkDragMoveHelper.prototype.init = function(map, cb) {\n  this.handleMouseMove = e => {\n    e.stopPropagation()\n    if (this.mousedown) {\n      if (!this.lastX) {\n        this.lastX = e.pageX\n        this.lastY = e.pageY\n        return\n      }\n      const deltaX = this.lastX - e.pageX\n      const deltaY = this.lastY - e.pageY\n      cb(deltaX, deltaY)\n      this.lastX = e.pageX\n      this.lastY = e.pageY\n    }\n  }\n  this.handleMouseDown = e => {\n    e.stopPropagation()\n    this.mousedown = true\n  }\n  this.handleClear = e => {\n    e.stopPropagation()\n    this.clear()\n  }\n  map.addEventListener('mousemove', this.handleMouseMove)\n  map.addEventListener('mouseleave', this.handleClear)\n  map.addEventListener('mouseup', this.handleClear)\n  this.dom.addEventListener('mousedown', this.handleMouseDown)\n}\n\nLinkDragMoveHelper.prototype.destory = function(map) {\n  map.removeEventListener('mousemove', this.handleMouseMove)\n  map.removeEventListener('mouseleave', this.handleClear)\n  map.removeEventListener('mouseup', this.handleClear)\n  this.dom.removeEventListener('mousedown', this.handleMouseDown)\n}\n\nLinkDragMoveHelper.prototype.clear = function() {\n  this.mousedown = false\n  this.lastX = null\n  this.lastY = null\n}\n"], "filenames": ["package.json", "readme.md", "src/plugin/contextMenu.ts", "src/plugin/nodeMenu.ts", "src/plugin/toolBar.ts", "src/utils/dom.ts", "src/utils/index.ts"], "buggy_code_start_loc": [3, 54, 1, 3, 17, 4, 2], "buggy_code_end_loc": [4, 55, 14, 69, 18, 165, 2], "fixing_code_start_loc": [3, 53, 2, 3, 17, 4, 3], "fixing_code_end_loc": [4, 53, 15, 64, 18, 165, 7], "type": "CWE-79", "message": "Mind-elixir is a free, open source mind map core. Prior to version 0.18.1, mind-elixir is prone to cross-site scripting when handling untrusted menus. This issue is patched in version 0.18.1", "other": {"cve": {"id": "CVE-2021-32851", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-20T22:15:11.073", "lastModified": "2023-03-02T19:21:08.230", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Mind-elixir is a free, open source mind map core. Prior to version 0.18.1, mind-elixir is prone to cross-site scripting when handling untrusted menus. This issue is patched in version 0.18.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mind-elixir_project:mind-elixir:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "0.18.1", "matchCriteriaId": "52528643-88BB-4911-9573-C803E5F716AE"}]}]}], "references": [{"url": "https://github.com/ssshooter/mind-elixir-core/blob/79942a68b14c8875ab7d270b1ad25bfff351b04c/src/plugin/contextMenu.js#L13", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/ssshooter/mind-elixir-core/commit/073485269ac83af24371f35bd08507defa885655", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://securitylab.github.com/advisories/GHSL-2021-1047_Mind-elixir/", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ssshooter/mind-elixir-core/commit/073485269ac83af24371f35bd08507defa885655"}}