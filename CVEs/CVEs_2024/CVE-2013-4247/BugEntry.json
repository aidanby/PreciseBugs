{"buggy_code": ["/*\n *   fs/cifs/connect.c\n *\n *   Copyright (C) International Business Machines  Corp., 2002,2011\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */\n#include <linux/fs.h>\n#include <linux/net.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/ctype.h>\n#include <linux/utsname.h>\n#include <linux/mempool.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/pagevec.h>\n#include <linux/freezer.h>\n#include <linux/namei.h>\n#include <asm/uaccess.h>\n#include <asm/processor.h>\n#include <linux/inet.h>\n#include <linux/module.h>\n#include <keys/user-type.h>\n#include <net/ipv6.h>\n#include <linux/parser.h>\n\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_fs_sb.h\"\n#include \"ntlmssp.h\"\n#include \"nterr.h\"\n#include \"rfc1002pdu.h\"\n#include \"fscache.h\"\n\n#define CIFS_PORT 445\n#define RFC1001_PORT 139\n\nextern mempool_t *cifs_req_poolp;\n\n/* FIXME: should these be tunable? */\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n#define TLINK_IDLE_EXPIRE\t(600 * HZ)\n\nenum {\n\n\t/* Mount options that take no arguments */\n\tOpt_user_xattr, Opt_nouser_xattr,\n\tOpt_forceuid, Opt_noforceuid,\n\tOpt_forcegid, Opt_noforcegid,\n\tOpt_noblocksend, Opt_noautotune,\n\tOpt_hard, Opt_soft, Opt_perm, Opt_noperm,\n\tOpt_mapchars, Opt_nomapchars, Opt_sfu,\n\tOpt_nosfu, Opt_nodfs, Opt_posixpaths,\n\tOpt_noposixpaths, Opt_nounix,\n\tOpt_nocase,\n\tOpt_brl, Opt_nobrl,\n\tOpt_forcemandatorylock, Opt_setuids,\n\tOpt_nosetuids, Opt_dynperm, Opt_nodynperm,\n\tOpt_nohard, Opt_nosoft,\n\tOpt_nointr, Opt_intr,\n\tOpt_nostrictsync, Opt_strictsync,\n\tOpt_serverino, Opt_noserverino,\n\tOpt_rwpidforward, Opt_cifsacl, Opt_nocifsacl,\n\tOpt_acl, Opt_noacl, Opt_locallease,\n\tOpt_sign, Opt_seal, Opt_noac,\n\tOpt_fsc, Opt_mfsymlinks,\n\tOpt_multiuser, Opt_sloppy,\n\n\t/* Mount options which take numeric value */\n\tOpt_backupuid, Opt_backupgid, Opt_uid,\n\tOpt_cruid, Opt_gid, Opt_file_mode,\n\tOpt_dirmode, Opt_port,\n\tOpt_rsize, Opt_wsize, Opt_actimeo,\n\n\t/* Mount options which take string value */\n\tOpt_user, Opt_pass, Opt_ip,\n\tOpt_domain, Opt_srcaddr, Opt_iocharset,\n\tOpt_netbiosname, Opt_servern,\n\tOpt_ver, Opt_vers, Opt_sec, Opt_cache,\n\n\t/* Mount options to be ignored */\n\tOpt_ignore,\n\n\t/* Options which could be blank */\n\tOpt_blank_pass,\n\tOpt_blank_user,\n\tOpt_blank_ip,\n\n\tOpt_err\n};\n\nstatic const match_table_t cifs_mount_option_tokens = {\n\n\t{ Opt_user_xattr, \"user_xattr\" },\n\t{ Opt_nouser_xattr, \"nouser_xattr\" },\n\t{ Opt_forceuid, \"forceuid\" },\n\t{ Opt_noforceuid, \"noforceuid\" },\n\t{ Opt_forcegid, \"forcegid\" },\n\t{ Opt_noforcegid, \"noforcegid\" },\n\t{ Opt_noblocksend, \"noblocksend\" },\n\t{ Opt_noautotune, \"noautotune\" },\n\t{ Opt_hard, \"hard\" },\n\t{ Opt_soft, \"soft\" },\n\t{ Opt_perm, \"perm\" },\n\t{ Opt_noperm, \"noperm\" },\n\t{ Opt_mapchars, \"mapchars\" },\n\t{ Opt_nomapchars, \"nomapchars\" },\n\t{ Opt_sfu, \"sfu\" },\n\t{ Opt_nosfu, \"nosfu\" },\n\t{ Opt_nodfs, \"nodfs\" },\n\t{ Opt_posixpaths, \"posixpaths\" },\n\t{ Opt_noposixpaths, \"noposixpaths\" },\n\t{ Opt_nounix, \"nounix\" },\n\t{ Opt_nounix, \"nolinux\" },\n\t{ Opt_nocase, \"nocase\" },\n\t{ Opt_nocase, \"ignorecase\" },\n\t{ Opt_brl, \"brl\" },\n\t{ Opt_nobrl, \"nobrl\" },\n\t{ Opt_nobrl, \"nolock\" },\n\t{ Opt_forcemandatorylock, \"forcemandatorylock\" },\n\t{ Opt_forcemandatorylock, \"forcemand\" },\n\t{ Opt_setuids, \"setuids\" },\n\t{ Opt_nosetuids, \"nosetuids\" },\n\t{ Opt_dynperm, \"dynperm\" },\n\t{ Opt_nodynperm, \"nodynperm\" },\n\t{ Opt_nohard, \"nohard\" },\n\t{ Opt_nosoft, \"nosoft\" },\n\t{ Opt_nointr, \"nointr\" },\n\t{ Opt_intr, \"intr\" },\n\t{ Opt_nostrictsync, \"nostrictsync\" },\n\t{ Opt_strictsync, \"strictsync\" },\n\t{ Opt_serverino, \"serverino\" },\n\t{ Opt_noserverino, \"noserverino\" },\n\t{ Opt_rwpidforward, \"rwpidforward\" },\n\t{ Opt_cifsacl, \"cifsacl\" },\n\t{ Opt_nocifsacl, \"nocifsacl\" },\n\t{ Opt_acl, \"acl\" },\n\t{ Opt_noacl, \"noacl\" },\n\t{ Opt_locallease, \"locallease\" },\n\t{ Opt_sign, \"sign\" },\n\t{ Opt_seal, \"seal\" },\n\t{ Opt_noac, \"noac\" },\n\t{ Opt_fsc, \"fsc\" },\n\t{ Opt_mfsymlinks, \"mfsymlinks\" },\n\t{ Opt_multiuser, \"multiuser\" },\n\t{ Opt_sloppy, \"sloppy\" },\n\n\t{ Opt_backupuid, \"backupuid=%s\" },\n\t{ Opt_backupgid, \"backupgid=%s\" },\n\t{ Opt_uid, \"uid=%s\" },\n\t{ Opt_cruid, \"cruid=%s\" },\n\t{ Opt_gid, \"gid=%s\" },\n\t{ Opt_file_mode, \"file_mode=%s\" },\n\t{ Opt_dirmode, \"dirmode=%s\" },\n\t{ Opt_dirmode, \"dir_mode=%s\" },\n\t{ Opt_port, \"port=%s\" },\n\t{ Opt_rsize, \"rsize=%s\" },\n\t{ Opt_wsize, \"wsize=%s\" },\n\t{ Opt_actimeo, \"actimeo=%s\" },\n\n\t{ Opt_blank_user, \"user=\" },\n\t{ Opt_blank_user, \"username=\" },\n\t{ Opt_user, \"user=%s\" },\n\t{ Opt_user, \"username=%s\" },\n\t{ Opt_blank_pass, \"pass=\" },\n\t{ Opt_blank_pass, \"password=\" },\n\t{ Opt_pass, \"pass=%s\" },\n\t{ Opt_pass, \"password=%s\" },\n\t{ Opt_blank_ip, \"ip=\" },\n\t{ Opt_blank_ip, \"addr=\" },\n\t{ Opt_ip, \"ip=%s\" },\n\t{ Opt_ip, \"addr=%s\" },\n\t{ Opt_ignore, \"unc=%s\" },\n\t{ Opt_ignore, \"target=%s\" },\n\t{ Opt_ignore, \"path=%s\" },\n\t{ Opt_domain, \"dom=%s\" },\n\t{ Opt_domain, \"domain=%s\" },\n\t{ Opt_domain, \"workgroup=%s\" },\n\t{ Opt_srcaddr, \"srcaddr=%s\" },\n\t{ Opt_ignore, \"prefixpath=%s\" },\n\t{ Opt_iocharset, \"iocharset=%s\" },\n\t{ Opt_netbiosname, \"netbiosname=%s\" },\n\t{ Opt_servern, \"servern=%s\" },\n\t{ Opt_ver, \"ver=%s\" },\n\t{ Opt_vers, \"vers=%s\" },\n\t{ Opt_sec, \"sec=%s\" },\n\t{ Opt_cache, \"cache=%s\" },\n\n\t{ Opt_ignore, \"cred\" },\n\t{ Opt_ignore, \"credentials\" },\n\t{ Opt_ignore, \"cred=%s\" },\n\t{ Opt_ignore, \"credentials=%s\" },\n\t{ Opt_ignore, \"guest\" },\n\t{ Opt_ignore, \"rw\" },\n\t{ Opt_ignore, \"ro\" },\n\t{ Opt_ignore, \"suid\" },\n\t{ Opt_ignore, \"nosuid\" },\n\t{ Opt_ignore, \"exec\" },\n\t{ Opt_ignore, \"noexec\" },\n\t{ Opt_ignore, \"nodev\" },\n\t{ Opt_ignore, \"noauto\" },\n\t{ Opt_ignore, \"dev\" },\n\t{ Opt_ignore, \"mand\" },\n\t{ Opt_ignore, \"nomand\" },\n\t{ Opt_ignore, \"_netdev\" },\n\n\t{ Opt_err, NULL }\n};\n\nenum {\n\tOpt_sec_krb5, Opt_sec_krb5i, Opt_sec_krb5p,\n\tOpt_sec_ntlmsspi, Opt_sec_ntlmssp,\n\tOpt_ntlm, Opt_sec_ntlmi, Opt_sec_ntlmv2,\n\tOpt_sec_ntlmv2i, Opt_sec_lanman,\n\tOpt_sec_none,\n\n\tOpt_sec_err\n};\n\nstatic const match_table_t cifs_secflavor_tokens = {\n\t{ Opt_sec_krb5, \"krb5\" },\n\t{ Opt_sec_krb5i, \"krb5i\" },\n\t{ Opt_sec_krb5p, \"krb5p\" },\n\t{ Opt_sec_ntlmsspi, \"ntlmsspi\" },\n\t{ Opt_sec_ntlmssp, \"ntlmssp\" },\n\t{ Opt_ntlm, \"ntlm\" },\n\t{ Opt_sec_ntlmi, \"ntlmi\" },\n\t{ Opt_sec_ntlmv2, \"nontlm\" },\n\t{ Opt_sec_ntlmv2, \"ntlmv2\" },\n\t{ Opt_sec_ntlmv2i, \"ntlmv2i\" },\n\t{ Opt_sec_lanman, \"lanman\" },\n\t{ Opt_sec_none, \"none\" },\n\n\t{ Opt_sec_err, NULL }\n};\n\n/* cache flavors */\nenum {\n\tOpt_cache_loose,\n\tOpt_cache_strict,\n\tOpt_cache_none,\n\tOpt_cache_err\n};\n\nstatic const match_table_t cifs_cacheflavor_tokens = {\n\t{ Opt_cache_loose, \"loose\" },\n\t{ Opt_cache_strict, \"strict\" },\n\t{ Opt_cache_none, \"none\" },\n\t{ Opt_cache_err, NULL }\n};\n\nstatic const match_table_t cifs_smb_version_tokens = {\n\t{ Smb_1, SMB1_VERSION_STRING },\n\t{ Smb_20, SMB20_VERSION_STRING},\n\t{ Smb_21, SMB21_VERSION_STRING },\n\t{ Smb_30, SMB30_VERSION_STRING },\n};\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\nstatic void tlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink);\nstatic void cifs_prune_tlinks(struct work_struct *work);\nstatic int cifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\t\t\tconst char *devname);\n\n/*\n * cifs tcp session reconnection\n *\n * mark tcp session as reconnecting so temporarily locked\n * mark all smb sessions as reconnecting for tcp session\n * reconnect tcp session\n * wake up waiters on reconnection? - (not needed currently)\n */\nint\ncifs_reconnect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tstruct list_head *tmp, *tmp2;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct mid_q_entry *mid_entry;\n\tstruct list_head retry_list;\n\n\tspin_lock(&GlobalMid_Lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\t/* the demux thread will exit normally\n\t\tnext time through the loop */\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\t} else\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\tspin_unlock(&GlobalMid_Lock);\n\tserver->maxBuf = 0;\n#ifdef CONFIG_CIFS_SMB2\n\tserver->max_read = 0;\n#endif\n\n\tcifs_dbg(FYI, \"Reconnecting tcp session\\n\");\n\n\t/* before reconnecting the tcp session, mark the smb session (uid)\n\t\tand the tid bad so they are not used until reconnected */\n\tcifs_dbg(FYI, \"%s: marking sessions and tcons for reconnect\\n\",\n\t\t __func__);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifs_ses, smb_ses_list);\n\t\tses->need_reconnect = true;\n\t\tses->ipc_tid = 0;\n\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp2, struct cifs_tcon, tcon_list);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* do not want to be sending data on a socket we are freeing */\n\tcifs_dbg(FYI, \"%s: tearing down socket\\n\", __func__);\n\tmutex_lock(&server->srv_mutex);\n\tif (server->ssocket) {\n\t\tcifs_dbg(FYI, \"State: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcifs_dbg(FYI, \"Post shutdown state: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\tserver->sequence_number = 0;\n\tserver->session_estab = false;\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tserver->lstrp = jiffies;\n\tmutex_unlock(&server->srv_mutex);\n\n\t/* mark submitted MIDs for retry and issue callback */\n\tINIT_LIST_HEAD(&retry_list);\n\tcifs_dbg(FYI, \"%s: moving mids to private list\\n\", __func__);\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tif (mid_entry->mid_state == MID_REQUEST_SUBMITTED)\n\t\t\tmid_entry->mid_state = MID_RETRY_NEEDED;\n\t\tlist_move(&mid_entry->qhead, &retry_list);\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_dbg(FYI, \"%s: issuing mid callbacks\\n\", __func__);\n\tlist_for_each_safe(tmp, tmp2, &retry_list) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tlist_del_init(&mid_entry->qhead);\n\t\tmid_entry->callback(mid_entry);\n\t}\n\n\tdo {\n\t\ttry_to_freeze();\n\n\t\t/* we should try only the port we connected to before */\n\t\trc = generic_ip_connect(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"reconnect error %d\\n\", rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\t} while (server->tcpStatus == CifsNeedReconnect);\n\n\treturn rc;\n}\n\nstatic void\ncifs_echo_request(struct work_struct *work)\n{\n\tint rc;\n\tstruct TCP_Server_Info *server = container_of(work,\n\t\t\t\t\tstruct TCP_Server_Info, echo.work);\n\n\t/*\n\t * We cannot send an echo if it is disabled or until the\n\t * NEGOTIATE_PROTOCOL request is done, which is indicated by\n\t * server->ops->need_neg() == true. Also, no need to ping if\n\t * we got a response recently.\n\t */\n\tif (!server->ops->need_neg || server->ops->need_neg(server) ||\n\t    (server->ops->can_echo && !server->ops->can_echo(server)) ||\n\t    time_before(jiffies, server->lstrp + SMB_ECHO_INTERVAL - HZ))\n\t\tgoto requeue_echo;\n\n\trc = server->ops->echo ? server->ops->echo(server) : -ENOSYS;\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Unable to send echo request to server: %s\\n\",\n\t\t\t server->hostname);\n\nrequeue_echo:\n\tqueue_delayed_work(cifsiod_wq, &server->echo, SMB_ECHO_INTERVAL);\n}\n\nstatic bool\nallocate_buffers(struct TCP_Server_Info *server)\n{\n\tif (!server->bigbuf) {\n\t\tserver->bigbuf = (char *)cifs_buf_get();\n\t\tif (!server->bigbuf) {\n\t\t\tcifs_dbg(VFS, \"No memory for large SMB response\\n\");\n\t\t\tmsleep(3000);\n\t\t\t/* retry will check if exiting */\n\t\t\treturn false;\n\t\t}\n\t} else if (server->large_buf) {\n\t\t/* we are reusing a dirty large buf, clear its start */\n\t\tmemset(server->bigbuf, 0, HEADER_SIZE(server));\n\t}\n\n\tif (!server->smallbuf) {\n\t\tserver->smallbuf = (char *)cifs_small_buf_get();\n\t\tif (!server->smallbuf) {\n\t\t\tcifs_dbg(VFS, \"No memory for SMB response\\n\");\n\t\t\tmsleep(1000);\n\t\t\t/* retry will check if exiting */\n\t\t\treturn false;\n\t\t}\n\t\t/* beginning of smb buffer is cleared in our buf_get */\n\t} else {\n\t\t/* if existing small buf clear beginning */\n\t\tmemset(server->smallbuf, 0, HEADER_SIZE(server));\n\t}\n\n\treturn true;\n}\n\nstatic bool\nserver_unresponsive(struct TCP_Server_Info *server)\n{\n\t/*\n\t * We need to wait 2 echo intervals to make sure we handle such\n\t * situations right:\n\t * 1s  client sends a normal SMB request\n\t * 2s  client gets a response\n\t * 30s echo workqueue job pops, and decides we got a response recently\n\t *     and don't need to send another\n\t * ...\n\t * 65s kernel_recvmsg times out, and we see that we haven't gotten\n\t *     a response in >60s.\n\t */\n\tif (server->tcpStatus == CifsGood &&\n\t    time_after(jiffies, server->lstrp + 2 * SMB_ECHO_INTERVAL)) {\n\t\tcifs_dbg(VFS, \"Server %s has not responded in %d seconds. Reconnecting...\\n\",\n\t\t\t server->hostname, (2 * SMB_ECHO_INTERVAL) / HZ);\n\t\tcifs_reconnect(server);\n\t\twake_up(&server->response_q);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n * kvec_array_init - clone a kvec array, and advance into it\n * @new:\tpointer to memory for cloned array\n * @iov:\tpointer to original array\n * @nr_segs:\tnumber of members in original array\n * @bytes:\tnumber of bytes to advance into the cloned array\n *\n * This function will copy the array provided in iov to a section of memory\n * and advance the specified number of bytes into the new array. It returns\n * the number of segments in the new array. \"new\" must be at least as big as\n * the original iov array.\n */\nstatic unsigned int\nkvec_array_init(struct kvec *new, struct kvec *iov, unsigned int nr_segs,\n\t\tsize_t bytes)\n{\n\tsize_t base = 0;\n\n\twhile (bytes || !iov->iov_len) {\n\t\tint copy = min(bytes, iov->iov_len);\n\n\t\tbytes -= copy;\n\t\tbase += copy;\n\t\tif (iov->iov_len == base) {\n\t\t\tiov++;\n\t\t\tnr_segs--;\n\t\t\tbase = 0;\n\t\t}\n\t}\n\tmemcpy(new, iov, sizeof(*iov) * nr_segs);\n\tnew->iov_base += base;\n\tnew->iov_len -= base;\n\treturn nr_segs;\n}\n\nstatic struct kvec *\nget_server_iovec(struct TCP_Server_Info *server, unsigned int nr_segs)\n{\n\tstruct kvec *new_iov;\n\n\tif (server->iov && nr_segs <= server->nr_iov)\n\t\treturn server->iov;\n\n\t/* not big enough -- allocate a new one and release the old */\n\tnew_iov = kmalloc(sizeof(*new_iov) * nr_segs, GFP_NOFS);\n\tif (new_iov) {\n\t\tkfree(server->iov);\n\t\tserver->iov = new_iov;\n\t\tserver->nr_iov = nr_segs;\n\t}\n\treturn new_iov;\n}\n\nint\ncifs_readv_from_socket(struct TCP_Server_Info *server, struct kvec *iov_orig,\n\t\t       unsigned int nr_segs, unsigned int to_read)\n{\n\tint length = 0;\n\tint total_read;\n\tunsigned int segs;\n\tstruct msghdr smb_msg;\n\tstruct kvec *iov;\n\n\tiov = get_server_iovec(server, nr_segs);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\tsmb_msg.msg_control = NULL;\n\tsmb_msg.msg_controllen = 0;\n\n\tfor (total_read = 0; to_read; total_read += length, to_read -= length) {\n\t\ttry_to_freeze();\n\n\t\tif (server_unresponsive(server)) {\n\t\t\ttotal_read = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tsegs = kvec_array_init(iov, iov_orig, nr_segs, total_read);\n\n\t\tlength = kernel_recvmsg(server->ssocket, &smb_msg,\n\t\t\t\t\tiov, segs, to_read, 0);\n\n\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\ttotal_read = -ESHUTDOWN;\n\t\t\tbreak;\n\t\t} else if (server->tcpStatus == CifsNeedReconnect) {\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -EAGAIN;\n\t\t\tbreak;\n\t\t} else if (length == -ERESTARTSYS ||\n\t\t\t   length == -EAGAIN ||\n\t\t\t   length == -EINTR) {\n\t\t\t/*\n\t\t\t * Minimum sleep to prevent looping, allowing socket\n\t\t\t * to clear and app threads to set tcpStatus\n\t\t\t * CifsNeedReconnect if server hung.\n\t\t\t */\n\t\t\tusleep_range(1000, 2000);\n\t\t\tlength = 0;\n\t\t\tcontinue;\n\t\t} else if (length <= 0) {\n\t\t\tcifs_dbg(FYI, \"Received no data or error: expecting %d\\n\"\n\t\t\t\t \"got %d\", to_read, length);\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn total_read;\n}\n\nint\ncifs_read_from_socket(struct TCP_Server_Info *server, char *buf,\n\t\t      unsigned int to_read)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = buf;\n\tiov.iov_len = to_read;\n\n\treturn cifs_readv_from_socket(server, &iov, 1, to_read);\n}\n\nstatic bool\nis_smb_response(struct TCP_Server_Info *server, unsigned char type)\n{\n\t/*\n\t * The first byte big endian of the length field,\n\t * is actually not part of the length but the type\n\t * with the most common, zero, as regular data.\n\t */\n\tswitch (type) {\n\tcase RFC1002_SESSION_MESSAGE:\n\t\t/* Regular SMB response */\n\t\treturn true;\n\tcase RFC1002_SESSION_KEEP_ALIVE:\n\t\tcifs_dbg(FYI, \"RFC 1002 session keep alive\\n\");\n\t\tbreak;\n\tcase RFC1002_POSITIVE_SESSION_RESPONSE:\n\t\tcifs_dbg(FYI, \"RFC 1002 positive session response\\n\");\n\t\tbreak;\n\tcase RFC1002_NEGATIVE_SESSION_RESPONSE:\n\t\t/*\n\t\t * We get this from Windows 98 instead of an error on\n\t\t * SMB negprot response.\n\t\t */\n\t\tcifs_dbg(FYI, \"RFC 1002 negative session response\\n\");\n\t\t/* give server a second to clean up */\n\t\tmsleep(1000);\n\t\t/*\n\t\t * Always try 445 first on reconnect since we get NACK\n\t\t * on some if we ever connected to port 139 (the NACK\n\t\t * is since we do not begin with RFC1001 session\n\t\t * initialize frame).\n\t\t */\n\t\tcifs_set_port((struct sockaddr *)&server->dstaddr, CIFS_PORT);\n\t\tcifs_reconnect(server);\n\t\twake_up(&server->response_q);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"RFC 1002 unknown response type 0x%x\\n\", type);\n\t\tcifs_reconnect(server);\n\t}\n\n\treturn false;\n}\n\nvoid\ndequeue_mid(struct mid_q_entry *mid, bool malformed)\n{\n#ifdef CONFIG_CIFS_STATS2\n\tmid->when_received = jiffies;\n#endif\n\tspin_lock(&GlobalMid_Lock);\n\tif (!malformed)\n\t\tmid->mid_state = MID_RESPONSE_RECEIVED;\n\telse\n\t\tmid->mid_state = MID_RESPONSE_MALFORMED;\n\tlist_del_init(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n}\n\nstatic void\nhandle_mid(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t   char *buf, int malformed)\n{\n\tif (server->ops->check_trans2 &&\n\t    server->ops->check_trans2(mid, server, buf, malformed))\n\t\treturn;\n\tmid->resp_buf = buf;\n\tmid->large_buf = server->large_buf;\n\t/* Was previous buf put in mpx struct for multi-rsp? */\n\tif (!mid->multiRsp) {\n\t\t/* smb buffer will be freed by user thread */\n\t\tif (server->large_buf)\n\t\t\tserver->bigbuf = NULL;\n\t\telse\n\t\t\tserver->smallbuf = NULL;\n\t}\n\tdequeue_mid(mid, malformed);\n}\n\nstatic void clean_demultiplex_info(struct TCP_Server_Info *server)\n{\n\tint length;\n\n\t/* take it off the list, if it's not already */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\twake_up_all(&server->response_q);\n\n\t/* check if we have blocked requests that need to free */\n\tspin_lock(&server->req_lock);\n\tif (server->credits <= 0)\n\t\tserver->credits = 1;\n\tspin_unlock(&server->req_lock);\n\t/*\n\t * Although there should not be any requests blocked on this queue it\n\t * can not hurt to be paranoid and try to wake up requests that may\n\t * haven been blocked when more than 50 at time were on the wire to the\n\t * same server - they now will see the session is in exit state and get\n\t * out of SendReceive.\n\t */\n\twake_up_all(&server->request_q);\n\t/* give those requests time to exit */\n\tmsleep(125);\n\n\tif (server->ssocket) {\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\tstruct list_head dispose_list;\n\t\tstruct mid_q_entry *mid_entry;\n\t\tstruct list_head *tmp, *tmp2;\n\n\t\tINIT_LIST_HEAD(&dispose_list);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\t\tcifs_dbg(FYI, \"Clearing mid 0x%llx\\n\", mid_entry->mid);\n\t\t\tmid_entry->mid_state = MID_SHUTDOWN;\n\t\t\tlist_move(&mid_entry->qhead, &dispose_list);\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\n\t\t/* now walk dispose list and issue callbacks */\n\t\tlist_for_each_safe(tmp, tmp2, &dispose_list) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\t\tcifs_dbg(FYI, \"Callback mid 0x%llx\\n\", mid_entry->mid);\n\t\t\tlist_del_init(&mid_entry->qhead);\n\t\t\tmid_entry->callback(mid_entry);\n\t\t}\n\t\t/* 1/8th of sec is more than enough time for them to exit */\n\t\tmsleep(125);\n\t}\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\t/*\n\t\t * mpx threads have not exited yet give them at least the smb\n\t\t * send timeout time for long ops.\n\t\t *\n\t\t * Due to delays on oplock break requests, we need to wait at\n\t\t * least 45 seconds before giving up on a request getting a\n\t\t * response and going ahead and killing cifsd.\n\t\t */\n\t\tcifs_dbg(FYI, \"Wait for exit from demultiplex thread\\n\");\n\t\tmsleep(46000);\n\t\t/*\n\t\t * If threads still have not exited they are probably never\n\t\t * coming home not much else we can do but free the memory.\n\t\t */\n\t}\n\n\tkfree(server->hostname);\n\tkfree(server->iov);\n\tkfree(server);\n\n\tlength = atomic_dec_return(&tcpSesAllocCount);\n\tif (length > 0)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv,\n\t\t\t\tGFP_KERNEL);\n}\n\nstatic int\nstandard_receive3(struct TCP_Server_Info *server, struct mid_q_entry *mid)\n{\n\tint length;\n\tchar *buf = server->smallbuf;\n\tunsigned int pdu_length = get_rfc1002_length(buf);\n\n\t/* make sure this will fit in a large buffer */\n\tif (pdu_length > CIFSMaxBufSize + MAX_HEADER_SIZE(server) - 4) {\n\t\tcifs_dbg(VFS, \"SMB response too long (%u bytes)\\n\", pdu_length);\n\t\tcifs_reconnect(server);\n\t\twake_up(&server->response_q);\n\t\treturn -EAGAIN;\n\t}\n\n\t/* switch to large buffer if too big for a small one */\n\tif (pdu_length > MAX_CIFS_SMALL_BUFFER_SIZE - 4) {\n\t\tserver->large_buf = true;\n\t\tmemcpy(server->bigbuf, buf, server->total_read);\n\t\tbuf = server->bigbuf;\n\t}\n\n\t/* now read the rest */\n\tlength = cifs_read_from_socket(server, buf + HEADER_SIZE(server) - 1,\n\t\t\t\tpdu_length - HEADER_SIZE(server) + 1 + 4);\n\tif (length < 0)\n\t\treturn length;\n\tserver->total_read += length;\n\n\tdump_smb(buf, server->total_read);\n\n\t/*\n\t * We know that we received enough to get to the MID as we\n\t * checked the pdu_length earlier. Now check to see\n\t * if the rest of the header is OK. We borrow the length\n\t * var for the rest of the loop to avoid a new stack var.\n\t *\n\t * 48 bytes is enough to display the header and a little bit\n\t * into the payload for debugging purposes.\n\t */\n\tlength = server->ops->check_message(buf, server->total_read);\n\tif (length != 0)\n\t\tcifs_dump_mem(\"Bad SMB: \", buf,\n\t\t\tmin_t(unsigned int, server->total_read, 48));\n\n\tif (server->ops->is_status_pending &&\n\t    server->ops->is_status_pending(buf, server, length))\n\t\treturn -1;\n\n\tif (!mid)\n\t\treturn length;\n\n\thandle_mid(mid, server, buf, length);\n\treturn 0;\n}\n\nstatic int\ncifs_demultiplex_thread(void *p)\n{\n\tint length;\n\tstruct TCP_Server_Info *server = p;\n\tunsigned int pdu_length;\n\tchar *buf = NULL;\n\tstruct task_struct *task_to_wake = NULL;\n\tstruct mid_q_entry *mid_entry;\n\n\tcurrent->flags |= PF_MEMALLOC;\n\tcifs_dbg(FYI, \"Demultiplex PID: %d\\n\", task_pid_nr(current));\n\n\tlength = atomic_inc_return(&tcpSesAllocCount);\n\tif (length > 1)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv,\n\t\t\t\tGFP_KERNEL);\n\n\tset_freezable();\n\twhile (server->tcpStatus != CifsExiting) {\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\n\t\tif (!allocate_buffers(server))\n\t\t\tcontinue;\n\n\t\tserver->large_buf = false;\n\t\tbuf = server->smallbuf;\n\t\tpdu_length = 4; /* enough to get RFC1001 header */\n\n\t\tlength = cifs_read_from_socket(server, buf, pdu_length);\n\t\tif (length < 0)\n\t\t\tcontinue;\n\t\tserver->total_read = length;\n\n\t\t/*\n\t\t * The right amount was read from socket - 4 bytes,\n\t\t * so we can now interpret the length field.\n\t\t */\n\t\tpdu_length = get_rfc1002_length(buf);\n\n\t\tcifs_dbg(FYI, \"RFC1002 header 0x%x\\n\", pdu_length);\n\t\tif (!is_smb_response(server, buf[0]))\n\t\t\tcontinue;\n\n\t\t/* make sure we have enough to get to the MID */\n\t\tif (pdu_length < HEADER_SIZE(server) - 1 - 4) {\n\t\t\tcifs_dbg(VFS, \"SMB response too short (%u bytes)\\n\",\n\t\t\t\t pdu_length);\n\t\t\tcifs_reconnect(server);\n\t\t\twake_up(&server->response_q);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* read down to the MID */\n\t\tlength = cifs_read_from_socket(server, buf + 4,\n\t\t\t\t\t       HEADER_SIZE(server) - 1 - 4);\n\t\tif (length < 0)\n\t\t\tcontinue;\n\t\tserver->total_read += length;\n\n\t\tmid_entry = server->ops->find_mid(server, buf);\n\n\t\tif (!mid_entry || !mid_entry->receive)\n\t\t\tlength = standard_receive3(server, mid_entry);\n\t\telse\n\t\t\tlength = mid_entry->receive(server, mid_entry);\n\n\t\tif (length < 0)\n\t\t\tcontinue;\n\n\t\tif (server->large_buf)\n\t\t\tbuf = server->bigbuf;\n\n\t\tserver->lstrp = jiffies;\n\t\tif (mid_entry != NULL) {\n\t\t\tif (!mid_entry->multiRsp || mid_entry->multiEnd)\n\t\t\t\tmid_entry->callback(mid_entry);\n\t\t} else if (!server->ops->is_oplock_break ||\n\t\t\t   !server->ops->is_oplock_break(buf, server)) {\n\t\t\tcifs_dbg(VFS, \"No task to wake, unknown frame received! NumMids %d\\n\",\n\t\t\t\t atomic_read(&midCount));\n\t\t\tcifs_dump_mem(\"Received Data is: \", buf,\n\t\t\t\t      HEADER_SIZE(server));\n#ifdef CONFIG_CIFS_DEBUG2\n\t\t\tif (server->ops->dump_detail)\n\t\t\t\tserver->ops->dump_detail(buf);\n\t\t\tcifs_dump_mids(server);\n#endif /* CIFS_DEBUG2 */\n\n\t\t}\n\t} /* end while !EXITING */\n\n\t/* buffer usually freed in free_mid - need to free it here on exit */\n\tcifs_buf_release(server->bigbuf);\n\tif (server->smallbuf) /* no sense logging a debug message if NULL */\n\t\tcifs_small_buf_release(server->smallbuf);\n\n\ttask_to_wake = xchg(&server->tsk, NULL);\n\tclean_demultiplex_info(server);\n\n\t/* if server->tsk was NULL then wait for a signal before exiting */\n\tif (!task_to_wake) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\twhile (!signal_pending(current)) {\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t}\n\t\tset_current_state(TASK_RUNNING);\n\t}\n\n\tmodule_put_and_exit(0);\n}\n\n/* extract the host portion of the UNC string */\nstatic char *\nextract_hostname(const char *unc)\n{\n\tconst char *src;\n\tchar *dst, *delim;\n\tunsigned int len;\n\n\t/* skip double chars at beginning of string */\n\t/* BB: check validity of these bytes? */\n\tsrc = unc + 2;\n\n\t/* delimiter between hostname and sharename is always '\\\\' now */\n\tdelim = strchr(src, '\\\\');\n\tif (!delim)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlen = delim - src;\n\tdst = kmalloc((len + 1), GFP_KERNEL);\n\tif (dst == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(dst, src, len);\n\tdst[len] = '\\0';\n\n\treturn dst;\n}\n\nstatic int get_option_ul(substring_t args[], unsigned long *option)\n{\n\tint rc;\n\tchar *string;\n\n\tstring = match_strdup(args);\n\tif (string == NULL)\n\t\treturn -ENOMEM;\n\trc = kstrtoul(string, 0, option);\n\tkfree(string);\n\n\treturn rc;\n}\n\nstatic int get_option_uid(substring_t args[], kuid_t *result)\n{\n\tunsigned long value;\n\tkuid_t uid;\n\tint rc;\n\n\trc = get_option_ul(args, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tuid = make_kuid(current_user_ns(), value);\n\tif (!uid_valid(uid))\n\t\treturn -EINVAL;\n\n\t*result = uid;\n\treturn 0;\n}\n\nstatic int get_option_gid(substring_t args[], kgid_t *result)\n{\n\tunsigned long value;\n\tkgid_t gid;\n\tint rc;\n\n\trc = get_option_ul(args, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tgid = make_kgid(current_user_ns(), value);\n\tif (!gid_valid(gid))\n\t\treturn -EINVAL;\n\n\t*result = gid;\n\treturn 0;\n}\n\nstatic int cifs_parse_security_flavors(char *value,\n\t\t\t\t       struct smb_vol *vol)\n{\n\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tswitch (match_token(value, cifs_secflavor_tokens, args)) {\n\tcase Opt_sec_krb5:\n\t\tvol->secFlg |= CIFSSEC_MAY_KRB5 | CIFSSEC_MAY_SIGN;\n\t\tbreak;\n\tcase Opt_sec_krb5i:\n\t\tvol->secFlg |= CIFSSEC_MAY_KRB5 | CIFSSEC_MUST_SIGN;\n\t\tbreak;\n\tcase Opt_sec_krb5p:\n\t\t/* vol->secFlg |= CIFSSEC_MUST_SEAL | CIFSSEC_MAY_KRB5; */\n\t\tcifs_dbg(VFS, \"Krb5 cifs privacy not supported\\n\");\n\t\tbreak;\n\tcase Opt_sec_ntlmssp:\n\t\tvol->secFlg |= CIFSSEC_MAY_NTLMSSP;\n\t\tbreak;\n\tcase Opt_sec_ntlmsspi:\n\t\tvol->secFlg |= CIFSSEC_MAY_NTLMSSP | CIFSSEC_MUST_SIGN;\n\t\tbreak;\n\tcase Opt_ntlm:\n\t\t/* ntlm is default so can be turned off too */\n\t\tvol->secFlg |= CIFSSEC_MAY_NTLM;\n\t\tbreak;\n\tcase Opt_sec_ntlmi:\n\t\tvol->secFlg |= CIFSSEC_MAY_NTLM | CIFSSEC_MUST_SIGN;\n\t\tbreak;\n\tcase Opt_sec_ntlmv2:\n\t\tvol->secFlg |= CIFSSEC_MAY_NTLMV2;\n\t\tbreak;\n\tcase Opt_sec_ntlmv2i:\n\t\tvol->secFlg |= CIFSSEC_MAY_NTLMV2 | CIFSSEC_MUST_SIGN;\n\t\tbreak;\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\tcase Opt_sec_lanman:\n\t\tvol->secFlg |= CIFSSEC_MAY_LANMAN;\n\t\tbreak;\n#endif\n\tcase Opt_sec_none:\n\t\tvol->nullauth = 1;\n\t\tvol->secFlg |= CIFSSEC_MAY_NTLM;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"bad security option: %s\\n\", value);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ncifs_parse_cache_flavor(char *value, struct smb_vol *vol)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tswitch (match_token(value, cifs_cacheflavor_tokens, args)) {\n\tcase Opt_cache_loose:\n\t\tvol->direct_io = false;\n\t\tvol->strict_io = false;\n\t\tbreak;\n\tcase Opt_cache_strict:\n\t\tvol->direct_io = false;\n\t\tvol->strict_io = true;\n\t\tbreak;\n\tcase Opt_cache_none:\n\t\tvol->direct_io = true;\n\t\tvol->strict_io = false;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"bad cache= option: %s\\n\", value);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\ncifs_parse_smb_version(char *value, struct smb_vol *vol)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tswitch (match_token(value, cifs_smb_version_tokens, args)) {\n\tcase Smb_1:\n\t\tvol->ops = &smb1_operations;\n\t\tvol->vals = &smb1_values;\n\t\tbreak;\n#ifdef CONFIG_CIFS_SMB2\n\tcase Smb_20:\n\t\tvol->ops = &smb21_operations; /* currently identical with 2.1 */\n\t\tvol->vals = &smb20_values;\n\t\tbreak;\n\tcase Smb_21:\n\t\tvol->ops = &smb21_operations;\n\t\tvol->vals = &smb21_values;\n\t\tbreak;\n\tcase Smb_30:\n\t\tvol->ops = &smb30_operations;\n\t\tvol->vals = &smb30_values;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tcifs_dbg(VFS, \"Unknown vers= option specified: %s\\n\", value);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Parse a devname into substrings and populate the vol->UNC and vol->prepath\n * fields with the result. Returns 0 on success and an error otherwise.\n */\nstatic int\ncifs_parse_devname(const char *devname, struct smb_vol *vol)\n{\n\tchar *pos;\n\tconst char *delims = \"/\\\\\";\n\tsize_t len;\n\n\t/* make sure we have a valid UNC double delimiter prefix */\n\tlen = strspn(devname, delims);\n\tif (len != 2)\n\t\treturn -EINVAL;\n\n\t/* find delimiter between host and sharename */\n\tpos = strpbrk(devname + 2, delims);\n\tif (!pos)\n\t\treturn -EINVAL;\n\n\t/* skip past delimiter */\n\t++pos;\n\n\t/* now go until next delimiter or end of string */\n\tlen = strcspn(pos, delims);\n\n\t/* move \"pos\" up to delimiter or NULL */\n\tpos += len;\n\tvol->UNC = kstrndup(devname, pos - devname, GFP_KERNEL);\n\tif (!vol->UNC)\n\t\treturn -ENOMEM;\n\n\tconvert_delimiter(vol->UNC, '\\\\');\n\n\t/* If pos is NULL, or is a bogus trailing delimiter then no prepath */\n\tif (!*pos++ || !*pos)\n\t\treturn 0;\n\n\tvol->prepath = kstrdup(pos, GFP_KERNEL);\n\tif (!vol->prepath)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int\ncifs_parse_mount_options(const char *mountdata, const char *devname,\n\t\t\t struct smb_vol *vol)\n{\n\tchar *data, *end;\n\tchar *mountdata_copy = NULL, *options;\n\tunsigned int  temp_len, i, j;\n\tchar separator[2];\n\tshort int override_uid = -1;\n\tshort int override_gid = -1;\n\tbool uid_specified = false;\n\tbool gid_specified = false;\n\tbool sloppy = false;\n\tchar *invalid = NULL;\n\tchar *nodename = utsname()->nodename;\n\tchar *string = NULL;\n\tchar *tmp_end, *value;\n\tchar delim;\n\tbool got_ip = false;\n\tunsigned short port = 0;\n\tstruct sockaddr *dstaddr = (struct sockaddr *)&vol->dstaddr;\n\n\tseparator[0] = ',';\n\tseparator[1] = 0;\n\tdelim = separator[0];\n\n\t/* ensure we always start with zeroed-out smb_vol */\n\tmemset(vol, 0, sizeof(*vol));\n\n\t/*\n\t * does not have to be perfect mapping since field is\n\t * informational, only used for servers that do not support\n\t * port 445 and it can be overridden at mount time\n\t */\n\tmemset(vol->source_rfc1001_name, 0x20, RFC1001_NAME_LEN);\n\tfor (i = 0; i < strnlen(nodename, RFC1001_NAME_LEN); i++)\n\t\tvol->source_rfc1001_name[i] = toupper(nodename[i]);\n\n\tvol->source_rfc1001_name[RFC1001_NAME_LEN] = 0;\n\t/* null target name indicates to use *SMBSERVR default called name\n\t   if we end up sending RFC1001 session initialize */\n\tvol->target_rfc1001_name[0] = 0;\n\tvol->cred_uid = current_uid();\n\tvol->linux_uid = current_uid();\n\tvol->linux_gid = current_gid();\n\n\t/* default to only allowing write access to owner of the mount */\n\tvol->dir_mode = vol->file_mode = S_IRUGO | S_IXUGO | S_IWUSR;\n\n\t/* vol->retry default is 0 (i.e. \"soft\" limited retry not hard retry) */\n\t/* default is always to request posix paths. */\n\tvol->posix_paths = 1;\n\t/* default to using server inode numbers where available */\n\tvol->server_ino = 1;\n\n\t/* default is to use strict cifs caching semantics */\n\tvol->strict_io = true;\n\n\tvol->actimeo = CIFS_DEF_ACTIMEO;\n\n\t/* FIXME: add autonegotiation -- for now, SMB1 is default */\n\tvol->ops = &smb1_operations;\n\tvol->vals = &smb1_values;\n\n\tif (!mountdata)\n\t\tgoto cifs_parse_mount_err;\n\n\tmountdata_copy = kstrndup(mountdata, PAGE_SIZE, GFP_KERNEL);\n\tif (!mountdata_copy)\n\t\tgoto cifs_parse_mount_err;\n\n\toptions = mountdata_copy;\n\tend = options + strlen(options);\n\n\tif (strncmp(options, \"sep=\", 4) == 0) {\n\t\tif (options[4] != 0) {\n\t\t\tseparator[0] = options[4];\n\t\t\toptions += 5;\n\t\t} else {\n\t\t\tcifs_dbg(FYI, \"Null separator not allowed\\n\");\n\t\t}\n\t}\n\tvol->backupuid_specified = false; /* no backup intent for a user */\n\tvol->backupgid_specified = false; /* no backup intent for a group */\n\n\tswitch (cifs_parse_devname(devname, vol)) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOMEM:\n\t\tcifs_dbg(VFS, \"Unable to allocate memory for devname.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\tcase -EINVAL:\n\t\tcifs_dbg(VFS, \"Malformed UNC in devname.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Unknown error parsing devname.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n\twhile ((data = strsep(&options, separator)) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tunsigned long option;\n\t\tint token;\n\n\t\tif (!*data)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(data, cifs_mount_option_tokens, args);\n\n\t\tswitch (token) {\n\n\t\t/* Ingnore the following */\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\n\t\t/* Boolean values */\n\t\tcase Opt_user_xattr:\n\t\t\tvol->no_xattr = 0;\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tvol->no_xattr = 1;\n\t\t\tbreak;\n\t\tcase Opt_forceuid:\n\t\t\toverride_uid = 1;\n\t\t\tbreak;\n\t\tcase Opt_noforceuid:\n\t\t\toverride_uid = 0;\n\t\t\tbreak;\n\t\tcase Opt_forcegid:\n\t\t\toverride_gid = 1;\n\t\t\tbreak;\n\t\tcase Opt_noforcegid:\n\t\t\toverride_gid = 0;\n\t\t\tbreak;\n\t\tcase Opt_noblocksend:\n\t\t\tvol->noblocksnd = 1;\n\t\t\tbreak;\n\t\tcase Opt_noautotune:\n\t\t\tvol->noautotune = 1;\n\t\t\tbreak;\n\t\tcase Opt_hard:\n\t\t\tvol->retry = 1;\n\t\t\tbreak;\n\t\tcase Opt_soft:\n\t\t\tvol->retry = 0;\n\t\t\tbreak;\n\t\tcase Opt_perm:\n\t\t\tvol->noperm = 0;\n\t\t\tbreak;\n\t\tcase Opt_noperm:\n\t\t\tvol->noperm = 1;\n\t\t\tbreak;\n\t\tcase Opt_mapchars:\n\t\t\tvol->remap = 1;\n\t\t\tbreak;\n\t\tcase Opt_nomapchars:\n\t\t\tvol->remap = 0;\n\t\t\tbreak;\n\t\tcase Opt_sfu:\n\t\t\tvol->sfu_emul = 1;\n\t\t\tbreak;\n\t\tcase Opt_nosfu:\n\t\t\tvol->sfu_emul = 0;\n\t\t\tbreak;\n\t\tcase Opt_nodfs:\n\t\t\tvol->nodfs = 1;\n\t\t\tbreak;\n\t\tcase Opt_posixpaths:\n\t\t\tvol->posix_paths = 1;\n\t\t\tbreak;\n\t\tcase Opt_noposixpaths:\n\t\t\tvol->posix_paths = 0;\n\t\t\tbreak;\n\t\tcase Opt_nounix:\n\t\t\tvol->no_linux_ext = 1;\n\t\t\tbreak;\n\t\tcase Opt_nocase:\n\t\t\tvol->nocase = 1;\n\t\t\tbreak;\n\t\tcase Opt_brl:\n\t\t\tvol->nobrl =  0;\n\t\t\tbreak;\n\t\tcase Opt_nobrl:\n\t\t\tvol->nobrl =  1;\n\t\t\t/*\n\t\t\t * turn off mandatory locking in mode\n\t\t\t * if remote locking is turned off since the\n\t\t\t * local vfs will do advisory\n\t\t\t */\n\t\t\tif (vol->file_mode ==\n\t\t\t\t(S_IALLUGO & ~(S_ISUID | S_IXGRP)))\n\t\t\t\tvol->file_mode = S_IALLUGO;\n\t\t\tbreak;\n\t\tcase Opt_forcemandatorylock:\n\t\t\tvol->mand_lock = 1;\n\t\t\tbreak;\n\t\tcase Opt_setuids:\n\t\t\tvol->setuids = 1;\n\t\t\tbreak;\n\t\tcase Opt_nosetuids:\n\t\t\tvol->setuids = 0;\n\t\t\tbreak;\n\t\tcase Opt_dynperm:\n\t\t\tvol->dynperm = true;\n\t\t\tbreak;\n\t\tcase Opt_nodynperm:\n\t\t\tvol->dynperm = false;\n\t\t\tbreak;\n\t\tcase Opt_nohard:\n\t\t\tvol->retry = 0;\n\t\t\tbreak;\n\t\tcase Opt_nosoft:\n\t\t\tvol->retry = 1;\n\t\t\tbreak;\n\t\tcase Opt_nointr:\n\t\t\tvol->intr = 0;\n\t\t\tbreak;\n\t\tcase Opt_intr:\n\t\t\tvol->intr = 1;\n\t\t\tbreak;\n\t\tcase Opt_nostrictsync:\n\t\t\tvol->nostrictsync = 1;\n\t\t\tbreak;\n\t\tcase Opt_strictsync:\n\t\t\tvol->nostrictsync = 0;\n\t\t\tbreak;\n\t\tcase Opt_serverino:\n\t\t\tvol->server_ino = 1;\n\t\t\tbreak;\n\t\tcase Opt_noserverino:\n\t\t\tvol->server_ino = 0;\n\t\t\tbreak;\n\t\tcase Opt_rwpidforward:\n\t\t\tvol->rwpidforward = 1;\n\t\t\tbreak;\n\t\tcase Opt_cifsacl:\n\t\t\tvol->cifs_acl = 1;\n\t\t\tbreak;\n\t\tcase Opt_nocifsacl:\n\t\t\tvol->cifs_acl = 0;\n\t\t\tbreak;\n\t\tcase Opt_acl:\n\t\t\tvol->no_psx_acl = 0;\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tvol->no_psx_acl = 1;\n\t\t\tbreak;\n\t\tcase Opt_locallease:\n\t\t\tvol->local_lease = 1;\n\t\t\tbreak;\n\t\tcase Opt_sign:\n\t\t\tvol->secFlg |= CIFSSEC_MUST_SIGN;\n\t\t\tbreak;\n\t\tcase Opt_seal:\n\t\t\t/* we do not do the following in secFlags because seal\n\t\t\t * is a per tree connection (mount) not a per socket\n\t\t\t * or per-smb connection option in the protocol\n\t\t\t * vol->secFlg |= CIFSSEC_MUST_SEAL;\n\t\t\t */\n\t\t\tvol->seal = 1;\n\t\t\tbreak;\n\t\tcase Opt_noac:\n\t\t\tprintk(KERN_WARNING \"CIFS: Mount option noac not \"\n\t\t\t\t\"supported. Instead set \"\n\t\t\t\t\"/proc/fs/cifs/LookupCacheEnabled to 0\\n\");\n\t\t\tbreak;\n\t\tcase Opt_fsc:\n#ifndef CONFIG_CIFS_FSCACHE\n\t\t\tcifs_dbg(VFS, \"FS-Cache support needs CONFIG_CIFS_FSCACHE kernel config option set\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n#endif\n\t\t\tvol->fsc = true;\n\t\t\tbreak;\n\t\tcase Opt_mfsymlinks:\n\t\t\tvol->mfsymlinks = true;\n\t\t\tbreak;\n\t\tcase Opt_multiuser:\n\t\t\tvol->multiuser = true;\n\t\t\tbreak;\n\t\tcase Opt_sloppy:\n\t\t\tsloppy = true;\n\t\t\tbreak;\n\n\t\t/* Numeric Values */\n\t\tcase Opt_backupuid:\n\t\t\tif (get_option_uid(args, &vol->backupuid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid backupuid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->backupuid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_backupgid:\n\t\t\tif (get_option_gid(args, &vol->backupgid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid backupgid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->backupgid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (get_option_uid(args, &vol->linux_uid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid uid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tuid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_cruid:\n\t\t\tif (get_option_uid(args, &vol->cred_uid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid cruid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (get_option_gid(args, &vol->linux_gid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid gid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tgid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_file_mode:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid file_mode value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->file_mode = option;\n\t\t\tbreak;\n\t\tcase Opt_dirmode:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid dir_mode value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->dir_mode = option;\n\t\t\tbreak;\n\t\tcase Opt_port:\n\t\t\tif (get_option_ul(args, &option) ||\n\t\t\t    option > USHRT_MAX) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid port value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tport = (unsigned short)option;\n\t\t\tbreak;\n\t\tcase Opt_rsize:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid rsize value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->rsize = option;\n\t\t\tbreak;\n\t\tcase Opt_wsize:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid wsize value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->wsize = option;\n\t\t\tbreak;\n\t\tcase Opt_actimeo:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid actimeo value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->actimeo = HZ * option;\n\t\t\tif (vol->actimeo > CIFS_MAX_ACTIMEO) {\n\t\t\t\tcifs_dbg(VFS, \"attribute cache timeout too large\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* String Arguments */\n\n\t\tcase Opt_blank_user:\n\t\t\t/* null user, ie. anonymous authentication */\n\t\t\tvol->nullauth = 1;\n\t\t\tvol->username = NULL;\n\t\t\tbreak;\n\t\tcase Opt_user:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strnlen(string, MAX_USERNAME_SIZE) >\n\t\t\t\t\t\t\tMAX_USERNAME_SIZE) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: username too long\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->username = kstrdup(string, GFP_KERNEL);\n\t\t\tif (!vol->username)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tcase Opt_blank_pass:\n\t\t\t/* passwords have to be handled differently\n\t\t\t * to allow the character used for deliminator\n\t\t\t * to be passed within them\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * Check if this is a case where the  password\n\t\t\t * starts with a delimiter\n\t\t\t */\n\t\t\ttmp_end = strchr(data, '=');\n\t\t\ttmp_end++;\n\t\t\tif (!(tmp_end < end && tmp_end[1] == delim)) {\n\t\t\t\t/* No it is not. Set the password to NULL */\n\t\t\t\tvol->password = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Yes it is. Drop down to Opt_pass below.*/\n\t\tcase Opt_pass:\n\t\t\t/* Obtain the value string */\n\t\t\tvalue = strchr(data, '=');\n\t\t\tvalue++;\n\n\t\t\t/* Set tmp_end to end of the string */\n\t\t\ttmp_end = (char *) value + strlen(value);\n\n\t\t\t/* Check if following character is the deliminator\n\t\t\t * If yes, we have encountered a double deliminator\n\t\t\t * reset the NULL character to the deliminator\n\t\t\t */\n\t\t\tif (tmp_end < end && tmp_end[1] == delim) {\n\t\t\t\ttmp_end[0] = delim;\n\n\t\t\t\t/* Keep iterating until we get to a single\n\t\t\t\t * deliminator OR the end\n\t\t\t\t */\n\t\t\t\twhile ((tmp_end = strchr(tmp_end, delim))\n\t\t\t\t\t!= NULL && (tmp_end[1] == delim)) {\n\t\t\t\t\t\ttmp_end = (char *) &tmp_end[2];\n\t\t\t\t}\n\n\t\t\t\t/* Reset var options to point to next element */\n\t\t\t\tif (tmp_end) {\n\t\t\t\t\ttmp_end[0] = '\\0';\n\t\t\t\t\toptions = (char *) &tmp_end[1];\n\t\t\t\t} else\n\t\t\t\t\t/* Reached the end of the mount option\n\t\t\t\t\t * string */\n\t\t\t\t\toptions = end;\n\t\t\t}\n\n\t\t\t/* Now build new password string */\n\t\t\ttemp_len = strlen(value);\n\t\t\tvol->password = kzalloc(temp_len+1, GFP_KERNEL);\n\t\t\tif (vol->password == NULL) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: no memory \"\n\t\t\t\t\t\t    \"for password\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\n\t\t\tfor (i = 0, j = 0; i < temp_len; i++, j++) {\n\t\t\t\tvol->password[j] = value[i];\n\t\t\t\tif ((value[i] == delim) &&\n\t\t\t\t     value[i+1] == delim)\n\t\t\t\t\t/* skip the second deliminator */\n\t\t\t\t\ti++;\n\t\t\t}\n\t\t\tvol->password[j] = '\\0';\n\t\t\tbreak;\n\t\tcase Opt_blank_ip:\n\t\t\t/* FIXME: should this be an error instead? */\n\t\t\tgot_ip = false;\n\t\t\tbreak;\n\t\tcase Opt_ip:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (!cifs_convert_address(dstaddr, string,\n\t\t\t\t\tstrlen(string))) {\n\t\t\t\tprintk(KERN_ERR \"CIFS: bad ip= option (%s).\\n\",\n\t\t\t\t\tstring);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tgot_ip = true;\n\t\t\tbreak;\n\t\tcase Opt_domain:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strnlen(string, 256) == 256) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: domain name too\"\n\t\t\t\t\t\t    \" long\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\n\t\t\tvol->domainname = kstrdup(string, GFP_KERNEL);\n\t\t\tif (!vol->domainname) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: no memory \"\n\t\t\t\t\t\t    \"for domainname\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tcifs_dbg(FYI, \"Domain name set\\n\");\n\t\t\tbreak;\n\t\tcase Opt_srcaddr:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (!cifs_convert_address(\n\t\t\t\t\t(struct sockaddr *)&vol->srcaddr,\n\t\t\t\t\tstring, strlen(string))) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS:  Could not parse\"\n\t\t\t\t\t\t    \" srcaddr: %s\\n\", string);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_iocharset:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strnlen(string, 1024) >= 65) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: iocharset name \"\n\t\t\t\t\t\t    \"too long.\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\n\t\t\t if (strnicmp(string, \"default\", 7) != 0) {\n\t\t\t\tvol->iocharset = kstrdup(string,\n\t\t\t\t\t\t\t GFP_KERNEL);\n\t\t\t\tif (!vol->iocharset) {\n\t\t\t\t\tprintk(KERN_WARNING \"CIFS: no memory\"\n\t\t\t\t\t\t\t    \"for charset\\n\");\n\t\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* if iocharset not set then load_nls_default\n\t\t\t * is used by caller\n\t\t\t */\n\t\t\t cifs_dbg(FYI, \"iocharset set to %s\\n\", string);\n\t\t\tbreak;\n\t\tcase Opt_netbiosname:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tmemset(vol->source_rfc1001_name, 0x20,\n\t\t\t\tRFC1001_NAME_LEN);\n\t\t\t/*\n\t\t\t * FIXME: are there cases in which a comma can\n\t\t\t * be valid in workstation netbios name (and\n\t\t\t * need special handling)?\n\t\t\t */\n\t\t\tfor (i = 0; i < RFC1001_NAME_LEN; i++) {\n\t\t\t\t/* don't ucase netbiosname for user */\n\t\t\t\tif (string[i] == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tvol->source_rfc1001_name[i] = string[i];\n\t\t\t}\n\t\t\t/* The string has 16th byte zero still from\n\t\t\t * set at top of the function\n\t\t\t */\n\t\t\tif (i == RFC1001_NAME_LEN && string[i] != 0)\n\t\t\t\tprintk(KERN_WARNING \"CIFS: netbiosname\"\n\t\t\t\t       \" longer than 15 truncated.\\n\");\n\n\t\t\tbreak;\n\t\tcase Opt_servern:\n\t\t\t/* servernetbiosname specified override *SMBSERVER */\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\t/* last byte, type, is 0x20 for servr type */\n\t\t\tmemset(vol->target_rfc1001_name, 0x20,\n\t\t\t\tRFC1001_NAME_LEN_WITH_NULL);\n\n\t\t\t/* BB are there cases in which a comma can be\n\t\t\t   valid in this workstation netbios name\n\t\t\t   (and need special handling)? */\n\n\t\t\t/* user or mount helper must uppercase the\n\t\t\t   netbios name */\n\t\t\tfor (i = 0; i < 15; i++) {\n\t\t\t\tif (string[i] == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tvol->target_rfc1001_name[i] = string[i];\n\t\t\t}\n\t\t\t/* The string has 16th byte zero still from\n\t\t\t   set at top of the function  */\n\t\t\tif (i == RFC1001_NAME_LEN && string[i] != 0)\n\t\t\t\tprintk(KERN_WARNING \"CIFS: server net\"\n\t\t\t\t       \"biosname longer than 15 truncated.\\n\");\n\t\t\tbreak;\n\t\tcase Opt_ver:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strnicmp(string, \"1\", 1) == 0) {\n\t\t\t\t/* This is the default */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* For all other value, error */\n\t\t\tprintk(KERN_WARNING \"CIFS: Invalid version\"\n\t\t\t\t\t    \" specified\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\tcase Opt_vers:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (cifs_parse_smb_version(string, vol) != 0)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tcase Opt_sec:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (cifs_parse_security_flavors(string, vol) != 0)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tcase Opt_cache:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (cifs_parse_cache_flavor(string, vol) != 0)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * An option we don't recognize. Save it off for later\n\t\t\t * if we haven't already found one\n\t\t\t */\n\t\t\tif (!invalid)\n\t\t\t\tinvalid = data;\n\t\t\tbreak;\n\t\t}\n\t\t/* Free up any allocated string */\n\t\tkfree(string);\n\t\tstring = NULL;\n\t}\n\n\tif (!sloppy && invalid) {\n\t\tprintk(KERN_ERR \"CIFS: Unknown mount option \\\"%s\\\"\\n\", invalid);\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n#ifndef CONFIG_KEYS\n\t/* Muliuser mounts require CONFIG_KEYS support */\n\tif (vol->multiuser) {\n\t\tcifs_dbg(VFS, \"Multiuser mounts require kernels with CONFIG_KEYS enabled\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n#endif\n\tif (!vol->UNC) {\n\t\tcifs_dbg(VFS, \"CIFS mount error: No usable UNC path provided in device string!\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n\t/* make sure UNC has a share name */\n\tif (!strchr(vol->UNC + 3, '\\\\')) {\n\t\tcifs_dbg(VFS, \"Malformed UNC. Unable to find share name.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n\tif (!got_ip) {\n\t\t/* No ip= option specified? Try to get it from UNC */\n\t\tif (!cifs_convert_address(dstaddr, &vol->UNC[2],\n\t\t\t\t\t\tstrlen(&vol->UNC[2]))) {\n\t\t\tprintk(KERN_ERR \"Unable to determine destination \"\n\t\t\t\t\t\"address.\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t}\n\n\t/* set the port that we got earlier */\n\tcifs_set_port(dstaddr, port);\n\n\tif (uid_specified)\n\t\tvol->override_uid = override_uid;\n\telse if (override_uid == 1)\n\t\tprintk(KERN_NOTICE \"CIFS: ignoring forceuid mount option \"\n\t\t\t\t   \"specified with no uid= option.\\n\");\n\n\tif (gid_specified)\n\t\tvol->override_gid = override_gid;\n\telse if (override_gid == 1)\n\t\tprintk(KERN_NOTICE \"CIFS: ignoring forcegid mount option \"\n\t\t\t\t   \"specified with no gid= option.\\n\");\n\n\tkfree(mountdata_copy);\n\treturn 0;\n\nout_nomem:\n\tprintk(KERN_WARNING \"Could not allocate temporary buffer\\n\");\ncifs_parse_mount_err:\n\tkfree(string);\n\tkfree(mountdata_copy);\n\treturn 1;\n}\n\n/** Returns true if srcaddr isn't specified and rhs isn't\n * specified, or if srcaddr is specified and\n * matches the IP address of the rhs argument.\n */\nstatic bool\nsrcip_matches(struct sockaddr *srcaddr, struct sockaddr *rhs)\n{\n\tswitch (srcaddr->sa_family) {\n\tcase AF_UNSPEC:\n\t\treturn (rhs->sa_family == AF_UNSPEC);\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *saddr4 = (struct sockaddr_in *)srcaddr;\n\t\tstruct sockaddr_in *vaddr4 = (struct sockaddr_in *)rhs;\n\t\treturn (saddr4->sin_addr.s_addr == vaddr4->sin_addr.s_addr);\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *saddr6 = (struct sockaddr_in6 *)srcaddr;\n\t\tstruct sockaddr_in6 *vaddr6 = (struct sockaddr_in6 *)rhs;\n\t\treturn ipv6_addr_equal(&saddr6->sin6_addr, &vaddr6->sin6_addr);\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false; /* don't expect to be here */\n\t}\n}\n\n/*\n * If no port is specified in addr structure, we try to match with 445 port\n * and if it fails - with 139 ports. It should be called only if address\n * families of server and addr are equal.\n */\nstatic bool\nmatch_port(struct TCP_Server_Info *server, struct sockaddr *addr)\n{\n\t__be16 port, *sport;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tsport = &((struct sockaddr_in *) &server->dstaddr)->sin_port;\n\t\tport = ((struct sockaddr_in *) addr)->sin_port;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsport = &((struct sockaddr_in6 *) &server->dstaddr)->sin6_port;\n\t\tport = ((struct sockaddr_in6 *) addr)->sin6_port;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false;\n\t}\n\n\tif (!port) {\n\t\tport = htons(CIFS_PORT);\n\t\tif (port == *sport)\n\t\t\treturn true;\n\n\t\tport = htons(RFC1001_PORT);\n\t}\n\n\treturn port == *sport;\n}\n\nstatic bool\nmatch_address(struct TCP_Server_Info *server, struct sockaddr *addr,\n\t      struct sockaddr *srcaddr)\n{\n\tswitch (addr->sa_family) {\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *addr4 = (struct sockaddr_in *)addr;\n\t\tstruct sockaddr_in *srv_addr4 =\n\t\t\t\t\t(struct sockaddr_in *)&server->dstaddr;\n\n\t\tif (addr4->sin_addr.s_addr != srv_addr4->sin_addr.s_addr)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)addr;\n\t\tstruct sockaddr_in6 *srv_addr6 =\n\t\t\t\t\t(struct sockaddr_in6 *)&server->dstaddr;\n\n\t\tif (!ipv6_addr_equal(&addr6->sin6_addr,\n\t\t\t\t     &srv_addr6->sin6_addr))\n\t\t\treturn false;\n\t\tif (addr6->sin6_scope_id != srv_addr6->sin6_scope_id)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false; /* don't expect to be here */\n\t}\n\n\tif (!srcip_matches(srcaddr, (struct sockaddr *)&server->srcaddr))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nmatch_security(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tunsigned int secFlags;\n\n\tif (vol->secFlg & (~(CIFSSEC_MUST_SIGN | CIFSSEC_MUST_SEAL)))\n\t\tsecFlags = vol->secFlg;\n\telse\n\t\tsecFlags = global_secflags | vol->secFlg;\n\n\tswitch (server->secType) {\n\tcase LANMAN:\n\t\tif (!(secFlags & (CIFSSEC_MAY_LANMAN|CIFSSEC_MAY_PLNTXT)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase NTLMv2:\n\t\tif (!(secFlags & CIFSSEC_MAY_NTLMV2))\n\t\t\treturn false;\n\t\tbreak;\n\tcase NTLM:\n\t\tif (!(secFlags & CIFSSEC_MAY_NTLM))\n\t\t\treturn false;\n\t\tbreak;\n\tcase Kerberos:\n\t\tif (!(secFlags & CIFSSEC_MAY_KRB5))\n\t\t\treturn false;\n\t\tbreak;\n\tcase RawNTLMSSP:\n\t\tif (!(secFlags & CIFSSEC_MAY_NTLMSSP))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\t/* shouldn't happen */\n\t\treturn false;\n\t}\n\n\t/* now check if signing mode is acceptable */\n\tif ((secFlags & CIFSSEC_MAY_SIGN) == 0 &&\n\t    (server->sec_mode & SECMODE_SIGN_REQUIRED))\n\t\t\treturn false;\n\telse if (((secFlags & CIFSSEC_MUST_SIGN) == CIFSSEC_MUST_SIGN) &&\n\t\t (server->sec_mode &\n\t\t  (SECMODE_SIGN_ENABLED|SECMODE_SIGN_REQUIRED)) == 0)\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic int match_server(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tstruct sockaddr *addr = (struct sockaddr *)&vol->dstaddr;\n\n\tif ((server->vals != vol->vals) || (server->ops != vol->ops))\n\t\treturn 0;\n\n\tif (!net_eq(cifs_net_ns(server), current->nsproxy->net_ns))\n\t\treturn 0;\n\n\tif (!match_address(server, addr,\n\t\t\t   (struct sockaddr *)&vol->srcaddr))\n\t\treturn 0;\n\n\tif (!match_port(server, addr))\n\t\treturn 0;\n\n\tif (!match_security(server, vol))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic struct TCP_Server_Info *\ncifs_find_tcp_session(struct smb_vol *vol)\n{\n\tstruct TCP_Server_Info *server;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {\n\t\tif (!match_server(server, vol))\n\t\t\tcontinue;\n\n\t\t++server->srv_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tcifs_dbg(FYI, \"Existing tcp session with server found\\n\");\n\t\treturn server;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nstatic void\ncifs_put_tcp_session(struct TCP_Server_Info *server)\n{\n\tstruct task_struct *task;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tput_net(cifs_net_ns(server));\n\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcancel_delayed_work_sync(&server->echo);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_crypto_shash_release(server);\n\tcifs_fscache_release_client_cookie(server);\n\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tforce_sig(SIGKILL, task);\n}\n\nstatic struct TCP_Server_Info *\ncifs_get_tcp_session(struct smb_vol *volume_info)\n{\n\tstruct TCP_Server_Info *tcp_ses = NULL;\n\tint rc;\n\n\tcifs_dbg(FYI, \"UNC: %s\\n\", volume_info->UNC);\n\n\t/* see if we already have a matching tcp_ses */\n\ttcp_ses = cifs_find_tcp_session(volume_info);\n\tif (tcp_ses)\n\t\treturn tcp_ses;\n\n\ttcp_ses = kzalloc(sizeof(struct TCP_Server_Info), GFP_KERNEL);\n\tif (!tcp_ses) {\n\t\trc = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\trc = cifs_crypto_shash_allocate(tcp_ses);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"could not setup hash structures rc %d\\n\", rc);\n\t\tgoto out_err;\n\t}\n\n\ttcp_ses->ops = volume_info->ops;\n\ttcp_ses->vals = volume_info->vals;\n\tcifs_set_net_ns(tcp_ses, get_net(current->nsproxy->net_ns));\n\ttcp_ses->hostname = extract_hostname(volume_info->UNC);\n\tif (IS_ERR(tcp_ses->hostname)) {\n\t\trc = PTR_ERR(tcp_ses->hostname);\n\t\tgoto out_err_crypto_release;\n\t}\n\n\ttcp_ses->noblocksnd = volume_info->noblocksnd;\n\ttcp_ses->noautotune = volume_info->noautotune;\n\ttcp_ses->tcp_nodelay = volume_info->sockopt_tcp_nodelay;\n\ttcp_ses->in_flight = 0;\n\ttcp_ses->credits = 1;\n\tinit_waitqueue_head(&tcp_ses->response_q);\n\tinit_waitqueue_head(&tcp_ses->request_q);\n\tINIT_LIST_HEAD(&tcp_ses->pending_mid_q);\n\tmutex_init(&tcp_ses->srv_mutex);\n\tmemcpy(tcp_ses->workstation_RFC1001_name,\n\t\tvolume_info->source_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\tmemcpy(tcp_ses->server_RFC1001_name,\n\t\tvolume_info->target_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\ttcp_ses->session_estab = false;\n\ttcp_ses->sequence_number = 0;\n\ttcp_ses->lstrp = jiffies;\n\tspin_lock_init(&tcp_ses->req_lock);\n\tINIT_LIST_HEAD(&tcp_ses->tcp_ses_list);\n\tINIT_LIST_HEAD(&tcp_ses->smb_ses_list);\n\tINIT_DELAYED_WORK(&tcp_ses->echo, cifs_echo_request);\n\tmemcpy(&tcp_ses->srcaddr, &volume_info->srcaddr,\n\t       sizeof(tcp_ses->srcaddr));\n\tmemcpy(&tcp_ses->dstaddr, &volume_info->dstaddr,\n\t\tsizeof(tcp_ses->dstaddr));\n\t/*\n\t * at this point we are the only ones with the pointer\n\t * to the struct since the kernel thread not created yet\n\t * no need to spinlock this init of tcpStatus or srv_count\n\t */\n\ttcp_ses->tcpStatus = CifsNew;\n\t++tcp_ses->srv_count;\n\n\trc = ip_connect(tcp_ses);\n\tif (rc < 0) {\n\t\tcifs_dbg(VFS, \"Error connecting to socket. Aborting operation.\\n\");\n\t\tgoto out_err_crypto_release;\n\t}\n\n\t/*\n\t * since we're in a cifs function already, we know that\n\t * this will succeed. No need for try_module_get().\n\t */\n\t__module_get(THIS_MODULE);\n\ttcp_ses->tsk = kthread_run(cifs_demultiplex_thread,\n\t\t\t\t  tcp_ses, \"cifsd\");\n\tif (IS_ERR(tcp_ses->tsk)) {\n\t\trc = PTR_ERR(tcp_ses->tsk);\n\t\tcifs_dbg(VFS, \"error %d create cifsd thread\\n\", rc);\n\t\tmodule_put(THIS_MODULE);\n\t\tgoto out_err_crypto_release;\n\t}\n\ttcp_ses->tcpStatus = CifsNeedNegotiate;\n\n\t/* thread spawned, put it on the list */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcp_ses->tcp_ses_list, &cifs_tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcifs_fscache_get_client_cookie(tcp_ses);\n\n\t/* queue echo request delayed work */\n\tqueue_delayed_work(cifsiod_wq, &tcp_ses->echo, SMB_ECHO_INTERVAL);\n\n\treturn tcp_ses;\n\nout_err_crypto_release:\n\tcifs_crypto_shash_release(tcp_ses);\n\n\tput_net(cifs_net_ns(tcp_ses));\n\nout_err:\n\tif (tcp_ses) {\n\t\tif (!IS_ERR(tcp_ses->hostname))\n\t\t\tkfree(tcp_ses->hostname);\n\t\tif (tcp_ses->ssocket)\n\t\t\tsock_release(tcp_ses->ssocket);\n\t\tkfree(tcp_ses);\n\t}\n\treturn ERR_PTR(rc);\n}\n\nstatic int match_session(struct cifs_ses *ses, struct smb_vol *vol)\n{\n\tswitch (ses->server->secType) {\n\tcase Kerberos:\n\t\tif (!uid_eq(vol->cred_uid, ses->cred_uid))\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\t/* NULL username means anonymous session */\n\t\tif (ses->user_name == NULL) {\n\t\t\tif (!vol->nullauth)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* anything else takes username/password */\n\t\tif (strncmp(ses->user_name,\n\t\t\t    vol->username ? vol->username : \"\",\n\t\t\t    MAX_USERNAME_SIZE))\n\t\t\treturn 0;\n\t\tif (strlen(vol->username) != 0 &&\n\t\t    ses->password != NULL &&\n\t\t    strncmp(ses->password,\n\t\t\t    vol->password ? vol->password : \"\",\n\t\t\t    MAX_PASSWORD_SIZE))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic struct cifs_ses *\ncifs_find_smb_ses(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tstruct cifs_ses *ses;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n\t\tif (!match_session(ses, vol))\n\t\t\tcontinue;\n\t\t++ses->ses_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nstatic void\ncifs_put_smb_ses(struct cifs_ses *ses)\n{\n\tunsigned int xid;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcifs_dbg(FYI, \"%s: ses_count=%d\\n\", __func__, ses->ses_count);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--ses->ses_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tlist_del_init(&ses->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tif (ses->status == CifsGood && server->ops->logoff) {\n\t\txid = get_xid();\n\t\tserver->ops->logoff(xid, ses);\n\t\t_free_xid(xid);\n\t}\n\tsesInfoFree(ses);\n\tcifs_put_tcp_session(server);\n}\n\n#ifdef CONFIG_KEYS\n\n/* strlen(\"cifs:a:\") + INET6_ADDRSTRLEN + 1 */\n#define CIFSCREDS_DESC_SIZE (7 + INET6_ADDRSTRLEN + 1)\n\n/* Populate username and pw fields from keyring if possible */\nstatic int\ncifs_set_cifscreds(struct smb_vol *vol, struct cifs_ses *ses)\n{\n\tint rc = 0;\n\tchar *desc, *delim, *payload;\n\tssize_t len;\n\tstruct key *key;\n\tstruct TCP_Server_Info *server = ses->server;\n\tstruct sockaddr_in *sa;\n\tstruct sockaddr_in6 *sa6;\n\tstruct user_key_payload *upayload;\n\n\tdesc = kmalloc(CIFSCREDS_DESC_SIZE, GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\t/* try to find an address key first */\n\tswitch (server->dstaddr.ss_family) {\n\tcase AF_INET:\n\t\tsa = (struct sockaddr_in *)&server->dstaddr;\n\t\tsprintf(desc, \"cifs:a:%pI4\", &sa->sin_addr.s_addr);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsa6 = (struct sockaddr_in6 *)&server->dstaddr;\n\t\tsprintf(desc, \"cifs:a:%pI6c\", &sa6->sin6_addr.s6_addr);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(FYI, \"Bad ss_family (%hu)\\n\",\n\t\t\t server->dstaddr.ss_family);\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tcifs_dbg(FYI, \"%s: desc=%s\\n\", __func__, desc);\n\tkey = request_key(&key_type_logon, desc, \"\");\n\tif (IS_ERR(key)) {\n\t\tif (!ses->domainName) {\n\t\t\tcifs_dbg(FYI, \"domainName is NULL\\n\");\n\t\t\trc = PTR_ERR(key);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\t/* didn't work, try to find a domain key */\n\t\tsprintf(desc, \"cifs:d:%s\", ses->domainName);\n\t\tcifs_dbg(FYI, \"%s: desc=%s\\n\", __func__, desc);\n\t\tkey = request_key(&key_type_logon, desc, \"\");\n\t\tif (IS_ERR(key)) {\n\t\t\trc = PTR_ERR(key);\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tdown_read(&key->sem);\n\tupayload = key->payload.data;\n\tif (IS_ERR_OR_NULL(upayload)) {\n\t\trc = upayload ? PTR_ERR(upayload) : -EINVAL;\n\t\tgoto out_key_put;\n\t}\n\n\t/* find first : in payload */\n\tpayload = (char *)upayload->data;\n\tdelim = strnchr(payload, upayload->datalen, ':');\n\tcifs_dbg(FYI, \"payload=%s\\n\", payload);\n\tif (!delim) {\n\t\tcifs_dbg(FYI, \"Unable to find ':' in payload (datalen=%d)\\n\",\n\t\t\t upayload->datalen);\n\t\trc = -EINVAL;\n\t\tgoto out_key_put;\n\t}\n\n\tlen = delim - payload;\n\tif (len > MAX_USERNAME_SIZE || len <= 0) {\n\t\tcifs_dbg(FYI, \"Bad value from username search (len=%zd)\\n\",\n\t\t\t len);\n\t\trc = -EINVAL;\n\t\tgoto out_key_put;\n\t}\n\n\tvol->username = kstrndup(payload, len, GFP_KERNEL);\n\tif (!vol->username) {\n\t\tcifs_dbg(FYI, \"Unable to allocate %zd bytes for username\\n\",\n\t\t\t len);\n\t\trc = -ENOMEM;\n\t\tgoto out_key_put;\n\t}\n\tcifs_dbg(FYI, \"%s: username=%s\\n\", __func__, vol->username);\n\n\tlen = key->datalen - (len + 1);\n\tif (len > MAX_PASSWORD_SIZE || len <= 0) {\n\t\tcifs_dbg(FYI, \"Bad len for password search (len=%zd)\\n\", len);\n\t\trc = -EINVAL;\n\t\tkfree(vol->username);\n\t\tvol->username = NULL;\n\t\tgoto out_key_put;\n\t}\n\n\t++delim;\n\tvol->password = kstrndup(delim, len, GFP_KERNEL);\n\tif (!vol->password) {\n\t\tcifs_dbg(FYI, \"Unable to allocate %zd bytes for password\\n\",\n\t\t\t len);\n\t\trc = -ENOMEM;\n\t\tkfree(vol->username);\n\t\tvol->username = NULL;\n\t\tgoto out_key_put;\n\t}\n\nout_key_put:\n\tup_read(&key->sem);\n\tkey_put(key);\nout_err:\n\tkfree(desc);\n\tcifs_dbg(FYI, \"%s: returning %d\\n\", __func__, rc);\n\treturn rc;\n}\n#else /* ! CONFIG_KEYS */\nstatic inline int\ncifs_set_cifscreds(struct smb_vol *vol __attribute__((unused)),\n\t\t   struct cifs_ses *ses __attribute__((unused)))\n{\n\treturn -ENOSYS;\n}\n#endif /* CONFIG_KEYS */\n\nstatic struct cifs_ses *\ncifs_get_smb_ses(struct TCP_Server_Info *server, struct smb_vol *volume_info)\n{\n\tint rc = -ENOMEM;\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\n\txid = get_xid();\n\n\tses = cifs_find_smb_ses(server, volume_info);\n\tif (ses) {\n\t\tcifs_dbg(FYI, \"Existing smb sess found (status=%d)\\n\",\n\t\t\t ses->status);\n\n\t\tmutex_lock(&ses->session_mutex);\n\t\trc = cifs_negotiate_protocol(xid, ses);\n\t\tif (rc) {\n\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t/* problem -- put our ses reference */\n\t\t\tcifs_put_smb_ses(ses);\n\t\t\tfree_xid(xid);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t\tif (ses->need_reconnect) {\n\t\t\tcifs_dbg(FYI, \"Session needs reconnect\\n\");\n\t\t\trc = cifs_setup_session(xid, ses,\n\t\t\t\t\t\tvolume_info->local_nls);\n\t\t\tif (rc) {\n\t\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t\t/* problem -- put our reference */\n\t\t\t\tcifs_put_smb_ses(ses);\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&ses->session_mutex);\n\n\t\t/* existing SMB ses has a server reference already */\n\t\tcifs_put_tcp_session(server);\n\t\tfree_xid(xid);\n\t\treturn ses;\n\t}\n\n\tcifs_dbg(FYI, \"Existing smb sess not found\\n\");\n\tses = sesInfoAlloc();\n\tif (ses == NULL)\n\t\tgoto get_ses_fail;\n\n\t/* new SMB session uses our server ref */\n\tses->server = server;\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsprintf(ses->serverName, \"%pI6\", &addr6->sin6_addr);\n\telse\n\t\tsprintf(ses->serverName, \"%pI4\", &addr->sin_addr);\n\n\tif (volume_info->username) {\n\t\tses->user_name = kstrdup(volume_info->username, GFP_KERNEL);\n\t\tif (!ses->user_name)\n\t\t\tgoto get_ses_fail;\n\t}\n\n\t/* volume_info->password freed at unmount */\n\tif (volume_info->password) {\n\t\tses->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!ses->password)\n\t\t\tgoto get_ses_fail;\n\t}\n\tif (volume_info->domainname) {\n\t\tses->domainName = kstrdup(volume_info->domainname, GFP_KERNEL);\n\t\tif (!ses->domainName)\n\t\t\tgoto get_ses_fail;\n\t}\n\tses->cred_uid = volume_info->cred_uid;\n\tses->linux_uid = volume_info->linux_uid;\n\n\tses->overrideSecFlg = volume_info->secFlg;\n\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(xid, ses);\n\tif (!rc)\n\t\trc = cifs_setup_session(xid, ses, volume_info->local_nls);\n\tmutex_unlock(&ses->session_mutex);\n\tif (rc)\n\t\tgoto get_ses_fail;\n\n\t/* success, put it on the list */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&ses->smb_ses_list, &server->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tfree_xid(xid);\n\treturn ses;\n\nget_ses_fail:\n\tsesInfoFree(ses);\n\tfree_xid(xid);\n\treturn ERR_PTR(rc);\n}\n\nstatic int match_tcon(struct cifs_tcon *tcon, const char *unc)\n{\n\tif (tcon->tidStatus == CifsExiting)\n\t\treturn 0;\n\tif (strncmp(tcon->treeName, unc, MAX_TREE_SIZE))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic struct cifs_tcon *\ncifs_find_tcon(struct cifs_ses *ses, const char *unc)\n{\n\tstruct list_head *tmp;\n\tstruct cifs_tcon *tcon;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &ses->tcon_list) {\n\t\ttcon = list_entry(tmp, struct cifs_tcon, tcon_list);\n\t\tif (!match_tcon(tcon, unc))\n\t\t\tcontinue;\n\t\t++tcon->tc_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn tcon;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nstatic void\ncifs_put_tcon(struct cifs_tcon *tcon)\n{\n\tunsigned int xid;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tcifs_dbg(FYI, \"%s: tc_count=%d\\n\", __func__, tcon->tc_count);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--tcon->tc_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tlist_del_init(&tcon->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\txid = get_xid();\n\tif (ses->server->ops->tree_disconnect)\n\t\tses->server->ops->tree_disconnect(xid, tcon);\n\t_free_xid(xid);\n\n\tcifs_fscache_release_super_cookie(tcon);\n\ttconInfoFree(tcon);\n\tcifs_put_smb_ses(ses);\n}\n\nstatic struct cifs_tcon *\ncifs_get_tcon(struct cifs_ses *ses, struct smb_vol *volume_info)\n{\n\tint rc, xid;\n\tstruct cifs_tcon *tcon;\n\n\ttcon = cifs_find_tcon(ses, volume_info->UNC);\n\tif (tcon) {\n\t\tcifs_dbg(FYI, \"Found match on UNC path\\n\");\n\t\t/* existing tcon already has a reference */\n\t\tcifs_put_smb_ses(ses);\n\t\tif (tcon->seal != volume_info->seal)\n\t\t\tcifs_dbg(VFS, \"transport encryption setting conflicts with existing tid\\n\");\n\t\treturn tcon;\n\t}\n\n\tif (!ses->server->ops->tree_connect) {\n\t\trc = -ENOSYS;\n\t\tgoto out_fail;\n\t}\n\n\ttcon = tconInfoAlloc();\n\tif (tcon == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out_fail;\n\t}\n\n\ttcon->ses = ses;\n\tif (volume_info->password) {\n\t\ttcon->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!tcon->password) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\t/*\n\t * BB Do we need to wrap session_mutex around this TCon call and Unix\n\t * SetFS as we do on SessSetup and reconnect?\n\t */\n\txid = get_xid();\n\trc = ses->server->ops->tree_connect(xid, ses, volume_info->UNC, tcon,\n\t\t\t\t\t    volume_info->local_nls);\n\tfree_xid(xid);\n\tcifs_dbg(FYI, \"Tcon rc = %d\\n\", rc);\n\tif (rc)\n\t\tgoto out_fail;\n\n\tif (volume_info->nodfs) {\n\t\ttcon->Flags &= ~SMB_SHARE_IS_IN_DFS;\n\t\tcifs_dbg(FYI, \"DFS disabled (%d)\\n\", tcon->Flags);\n\t}\n\ttcon->seal = volume_info->seal;\n\t/*\n\t * We can have only one retry value for a connection to a share so for\n\t * resources mounted more than once to the same server share the last\n\t * value passed in for the retry flag is used.\n\t */\n\ttcon->retry = volume_info->retry;\n\ttcon->nocase = volume_info->nocase;\n\ttcon->local_lease = volume_info->local_lease;\n\tINIT_LIST_HEAD(&tcon->pending_opens);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcon->tcon_list, &ses->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcifs_fscache_get_super_cookie(tcon);\n\n\treturn tcon;\n\nout_fail:\n\ttconInfoFree(tcon);\n\treturn ERR_PTR(rc);\n}\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}\n\nstatic inline struct tcon_link *\ncifs_sb_master_tlink(struct cifs_sb_info *cifs_sb)\n{\n\treturn cifs_sb->master_tlink;\n}\n\nstatic int\ncompare_mount_options(struct super_block *sb, struct cifs_mnt_data *mnt_data)\n{\n\tstruct cifs_sb_info *old = CIFS_SB(sb);\n\tstruct cifs_sb_info *new = mnt_data->cifs_sb;\n\n\tif ((sb->s_flags & CIFS_MS_MASK) != (mnt_data->flags & CIFS_MS_MASK))\n\t\treturn 0;\n\n\tif ((old->mnt_cifs_flags & CIFS_MOUNT_MASK) !=\n\t    (new->mnt_cifs_flags & CIFS_MOUNT_MASK))\n\t\treturn 0;\n\n\t/*\n\t * We want to share sb only if we don't specify an r/wsize or\n\t * specified r/wsize is greater than or equal to existing one.\n\t */\n\tif (new->wsize && new->wsize < old->wsize)\n\t\treturn 0;\n\n\tif (new->rsize && new->rsize < old->rsize)\n\t\treturn 0;\n\n\tif (!uid_eq(old->mnt_uid, new->mnt_uid) || !gid_eq(old->mnt_gid, new->mnt_gid))\n\t\treturn 0;\n\n\tif (old->mnt_file_mode != new->mnt_file_mode ||\n\t    old->mnt_dir_mode != new->mnt_dir_mode)\n\t\treturn 0;\n\n\tif (strcmp(old->local_nls->charset, new->local_nls->charset))\n\t\treturn 0;\n\n\tif (old->actimeo != new->actimeo)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nint\ncifs_match_super(struct super_block *sb, void *data)\n{\n\tstruct cifs_mnt_data *mnt_data = (struct cifs_mnt_data *)data;\n\tstruct smb_vol *volume_info;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct TCP_Server_Info *tcp_srv;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink;\n\tint rc = 0;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tcifs_sb = CIFS_SB(sb);\n\ttlink = cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\tif (IS_ERR(tlink)) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn rc;\n\t}\n\ttcon = tlink_tcon(tlink);\n\tses = tcon->ses;\n\ttcp_srv = ses->server;\n\n\tvolume_info = mnt_data->vol;\n\n\tif (!match_server(tcp_srv, volume_info) ||\n\t    !match_session(ses, volume_info) ||\n\t    !match_tcon(tcon, volume_info->UNC)) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = compare_mount_options(sb, mnt_data);\nout:\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nint\nget_dfs_path(const unsigned int xid, struct cifs_ses *ses, const char *old_path,\n\t     const struct nls_table *nls_codepage, unsigned int *num_referrals,\n\t     struct dfs_info3_param **referrals, int remap)\n{\n\tchar *temp_unc;\n\tint rc = 0;\n\n\tif (!ses->server->ops->tree_connect || !ses->server->ops->get_dfs_refer)\n\t\treturn -ENOSYS;\n\n\t*num_referrals = 0;\n\t*referrals = NULL;\n\n\tif (ses->ipc_tid == 0) {\n\t\ttemp_unc = kmalloc(2 /* for slashes */ +\n\t\t\tstrnlen(ses->serverName, SERVER_NAME_LEN_WITH_NULL * 2)\n\t\t\t\t+ 1 + 4 /* slash IPC$ */ + 2, GFP_KERNEL);\n\t\tif (temp_unc == NULL)\n\t\t\treturn -ENOMEM;\n\t\ttemp_unc[0] = '\\\\';\n\t\ttemp_unc[1] = '\\\\';\n\t\tstrcpy(temp_unc + 2, ses->serverName);\n\t\tstrcpy(temp_unc + 2 + strlen(ses->serverName), \"\\\\IPC$\");\n\t\trc = ses->server->ops->tree_connect(xid, ses, temp_unc, NULL,\n\t\t\t\t\t\t    nls_codepage);\n\t\tcifs_dbg(FYI, \"Tcon rc = %d ipc_tid = %d\\n\", rc, ses->ipc_tid);\n\t\tkfree(temp_unc);\n\t}\n\tif (rc == 0)\n\t\trc = ses->server->ops->get_dfs_refer(xid, ses, old_path,\n\t\t\t\t\t\t     referrals, num_referrals,\n\t\t\t\t\t\t     nls_codepage, remap);\n\t/*\n\t * BB - map targetUNCs to dfs_info3 structures, here or in\n\t * ses->server->ops->get_dfs_refer.\n\t */\n\n\treturn rc;\n}\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nstatic struct lock_class_key cifs_key[2];\nstatic struct lock_class_key cifs_slock_key[2];\n\nstatic inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(sock_owned_by_user(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET-CIFS\",\n\t\t&cifs_slock_key[0], \"sk_lock-AF_INET-CIFS\", &cifs_key[0]);\n}\n\nstatic inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(sock_owned_by_user(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET6-CIFS\",\n\t\t&cifs_slock_key[1], \"sk_lock-AF_INET6-CIFS\", &cifs_key[1]);\n}\n#else\nstatic inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n}\n\nstatic inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n}\n#endif\n\n/* See RFC1001 section 14 on representation of Netbios names */\nstatic void rfc1002mangle(char *target, char *source, unsigned int length)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0, j = 0; i < (length); i++) {\n\t\t/* mask a nibble at a time and encode */\n\t\ttarget[j] = 'A' + (0x0F & (source[i] >> 4));\n\t\ttarget[j+1] = 'A' + (0x0F & source[i]);\n\t\tj += 2;\n\t}\n\n}\n\nstatic int\nbind_socket(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tif (server->srcaddr.ss_family != AF_UNSPEC) {\n\t\t/* Bind to the specified local IP address */\n\t\tstruct socket *socket = server->ssocket;\n\t\trc = socket->ops->bind(socket,\n\t\t\t\t       (struct sockaddr *) &server->srcaddr,\n\t\t\t\t       sizeof(server->srcaddr));\n\t\tif (rc < 0) {\n\t\t\tstruct sockaddr_in *saddr4;\n\t\t\tstruct sockaddr_in6 *saddr6;\n\t\t\tsaddr4 = (struct sockaddr_in *)&server->srcaddr;\n\t\t\tsaddr6 = (struct sockaddr_in6 *)&server->srcaddr;\n\t\t\tif (saddr6->sin6_family == AF_INET6)\n\t\t\t\tcifs_dbg(VFS, \"Failed to bind to: %pI6c, error: %d\\n\",\n\t\t\t\t\t &saddr6->sin6_addr, rc);\n\t\t\telse\n\t\t\t\tcifs_dbg(VFS, \"Failed to bind to: %pI4, error: %d\\n\",\n\t\t\t\t\t &saddr4->sin_addr.s_addr, rc);\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int\nip_rfc1001_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t/*\n\t * some servers require RFC1001 sessinit before sending\n\t * negprot - BB check reconnection in case where second\n\t * sessinit is sent but no second negprot\n\t */\n\tstruct rfc1002_session_packet *ses_init_buf;\n\tstruct smb_hdr *smb_buf;\n\tses_init_buf = kzalloc(sizeof(struct rfc1002_session_packet),\n\t\t\t       GFP_KERNEL);\n\tif (ses_init_buf) {\n\t\tses_init_buf->trailer.session_req.called_len = 32;\n\n\t\tif (server->server_RFC1001_name &&\n\t\t    server->server_RFC1001_name[0] != 0)\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.called_name,\n\t\t\t\t      server->server_RFC1001_name,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\telse\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.called_name,\n\t\t\t\t      DEFAULT_CIFS_CALLED_NAME,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\tses_init_buf->trailer.session_req.calling_len = 32;\n\n\t\t/*\n\t\t * calling name ends in null (byte 16) from old smb\n\t\t * convention.\n\t\t */\n\t\tif (server->workstation_RFC1001_name &&\n\t\t    server->workstation_RFC1001_name[0] != 0)\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name,\n\t\t\t\t      server->workstation_RFC1001_name,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\telse\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name,\n\t\t\t\t      \"LINUX_CIFS_CLNT\",\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\tses_init_buf->trailer.session_req.scope1 = 0;\n\t\tses_init_buf->trailer.session_req.scope2 = 0;\n\t\tsmb_buf = (struct smb_hdr *)ses_init_buf;\n\n\t\t/* sizeof RFC1002_SESSION_REQUEST with no scope */\n\t\tsmb_buf->smb_buf_length = cpu_to_be32(0x81000044);\n\t\trc = smb_send(server, smb_buf, 0x44);\n\t\tkfree(ses_init_buf);\n\t\t/*\n\t\t * RFC1001 layer in at least one server\n\t\t * requires very short break before negprot\n\t\t * presumably because not expecting negprot\n\t\t * to follow so fast.  This is a simple\n\t\t * solution that works without\n\t\t * complicating the code and causes no\n\t\t * significant slowing down on mount\n\t\t * for everyone else\n\t\t */\n\t\tusleep_range(1000, 2000);\n\t}\n\t/*\n\t * else the negprot may still work without this\n\t * even though malloc failed\n\t */\n\n\treturn rc;\n}\n\nstatic int\ngeneric_ip_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t__be16 sport;\n\tint slen, sfamily;\n\tstruct socket *socket = server->ssocket;\n\tstruct sockaddr *saddr;\n\n\tsaddr = (struct sockaddr *) &server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6) {\n\t\tsport = ((struct sockaddr_in6 *) saddr)->sin6_port;\n\t\tslen = sizeof(struct sockaddr_in6);\n\t\tsfamily = AF_INET6;\n\t} else {\n\t\tsport = ((struct sockaddr_in *) saddr)->sin_port;\n\t\tslen = sizeof(struct sockaddr_in);\n\t\tsfamily = AF_INET;\n\t}\n\n\tif (socket == NULL) {\n\t\trc = __sock_create(cifs_net_ns(server), sfamily, SOCK_STREAM,\n\t\t\t\t   IPPROTO_TCP, &socket, 1);\n\t\tif (rc < 0) {\n\t\t\tcifs_dbg(VFS, \"Error %d creating socket\\n\", rc);\n\t\t\tserver->ssocket = NULL;\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* BB other socket options to set KEEPALIVE, NODELAY? */\n\t\tcifs_dbg(FYI, \"Socket created\\n\");\n\t\tserver->ssocket = socket;\n\t\tsocket->sk->sk_allocation = GFP_NOFS;\n\t\tif (sfamily == AF_INET6)\n\t\t\tcifs_reclassify_socket6(socket);\n\t\telse\n\t\t\tcifs_reclassify_socket4(socket);\n\t}\n\n\trc = bind_socket(server);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/*\n\t * Eventually check for other socket options to change from\n\t * the default. sock_setsockopt not used because it expects\n\t * user space buffer\n\t */\n\tsocket->sk->sk_rcvtimeo = 7 * HZ;\n\tsocket->sk->sk_sndtimeo = 5 * HZ;\n\n\t/* make the bufsizes depend on wsize/rsize and max requests */\n\tif (server->noautotune) {\n\t\tif (socket->sk->sk_sndbuf < (200 * 1024))\n\t\t\tsocket->sk->sk_sndbuf = 200 * 1024;\n\t\tif (socket->sk->sk_rcvbuf < (140 * 1024))\n\t\t\tsocket->sk->sk_rcvbuf = 140 * 1024;\n\t}\n\n\tif (server->tcp_nodelay) {\n\t\tint val = 1;\n\t\trc = kernel_setsockopt(socket, SOL_TCP, TCP_NODELAY,\n\t\t\t\t(char *)&val, sizeof(val));\n\t\tif (rc)\n\t\t\tcifs_dbg(FYI, \"set TCP_NODELAY socket option error %d\\n\",\n\t\t\t\t rc);\n\t}\n\n\tcifs_dbg(FYI, \"sndbuf %d rcvbuf %d rcvtimeo 0x%lx\\n\",\n\t\t socket->sk->sk_sndbuf,\n\t\t socket->sk->sk_rcvbuf, socket->sk->sk_rcvtimeo);\n\n\trc = socket->ops->connect(socket, saddr, slen, 0);\n\tif (rc < 0) {\n\t\tcifs_dbg(FYI, \"Error %d connecting to server\\n\", rc);\n\t\tsock_release(socket);\n\t\tserver->ssocket = NULL;\n\t\treturn rc;\n\t}\n\n\tif (sport == htons(RFC1001_PORT))\n\t\trc = ip_rfc1001_connect(server);\n\n\treturn rc;\n}\n\nstatic int\nip_connect(struct TCP_Server_Info *server)\n{\n\t__be16 *sport;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsport = &addr6->sin6_port;\n\telse\n\t\tsport = &addr->sin_port;\n\n\tif (*sport == 0) {\n\t\tint rc;\n\n\t\t/* try with 445 port at first */\n\t\t*sport = htons(CIFS_PORT);\n\n\t\trc = generic_ip_connect(server);\n\t\tif (rc >= 0)\n\t\t\treturn rc;\n\n\t\t/* if it failed, try with 139 port */\n\t\t*sport = htons(RFC1001_PORT);\n\t}\n\n\treturn generic_ip_connect(server);\n}\n\nvoid reset_cifs_unix_caps(unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t  struct cifs_sb_info *cifs_sb, struct smb_vol *vol_info)\n{\n\t/* if we are reconnecting then should we check to see if\n\t * any requested capabilities changed locally e.g. via\n\t * remount but we can not do much about it here\n\t * if they have (even if we could detect it by the following)\n\t * Perhaps we could add a backpointer to array of sb from tcon\n\t * or if we change to make all sb to same share the same\n\t * sb as NFS - then we only have one backpointer to sb.\n\t * What if we wanted to mount the server share twice once with\n\t * and once without posixacls or posix paths? */\n\t__u64 saved_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\tif (vol_info && vol_info->no_linux_ext) {\n\t\ttcon->fsUnixInfo.Capability = 0;\n\t\ttcon->unix_ext = 0; /* Unix Extensions disabled */\n\t\tcifs_dbg(FYI, \"Linux protocol extensions disabled\\n\");\n\t\treturn;\n\t} else if (vol_info)\n\t\ttcon->unix_ext = 1; /* Unix Extensions supported */\n\n\tif (tcon->unix_ext == 0) {\n\t\tcifs_dbg(FYI, \"Unix extensions disabled so not set on reconnect\\n\");\n\t\treturn;\n\t}\n\n\tif (!CIFSSMBQFSUnixInfo(xid, tcon)) {\n\t\t__u64 cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\t\tcifs_dbg(FYI, \"unix caps which server supports %lld\\n\", cap);\n\t\t/* check for reconnect case in which we do not\n\t\t   want to change the mount behavior if we can avoid it */\n\t\tif (vol_info == NULL) {\n\t\t\t/* turn off POSIX ACL and PATHNAMES if not set\n\t\t\t   originally at mount time */\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_ACL_CAP) == 0)\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\t\t\tcifs_dbg(VFS, \"POSIXPATH support change\\n\");\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\t\t} else if ((cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tcifs_dbg(VFS, \"possible reconnect error\\n\");\n\t\t\t\tcifs_dbg(VFS, \"server disabled POSIX path support\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(VFS, \"per-share encryption not supported yet\\n\");\n\n\t\tcap &= CIFS_UNIX_CAP_MASK;\n\t\tif (vol_info && vol_info->no_psx_acl)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\telse if (CIFS_UNIX_POSIX_ACL_CAP & cap) {\n\t\t\tcifs_dbg(FYI, \"negotiated posix acl support\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIXACL;\n\t\t}\n\n\t\tif (vol_info && vol_info->posix_paths == 0)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\telse if (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) {\n\t\t\tcifs_dbg(FYI, \"negotiate posix pathnames\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIX_PATHS;\n\t\t}\n\n\t\tcifs_dbg(FYI, \"Negotiate caps 0x%x\\n\", (int)cap);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\tif (cap & CIFS_UNIX_FCNTL_CAP)\n\t\t\tcifs_dbg(FYI, \"FCNTL cap\\n\");\n\t\tif (cap & CIFS_UNIX_EXTATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"EXTATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX path cap\\n\");\n\t\tif (cap & CIFS_UNIX_XATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"XATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_ACL_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX ACL cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_READ_CAP)\n\t\t\tcifs_dbg(FYI, \"very large read cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_WRITE_CAP)\n\t\t\tcifs_dbg(FYI, \"very large write cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_CAP)\n\t\t\tcifs_dbg(FYI, \"transport encryption cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(FYI, \"mandatory transport encryption cap\\n\");\n#endif /* CIFS_DEBUG2 */\n\t\tif (CIFSSMBSetFSUnixInfo(xid, tcon, cap)) {\n\t\t\tif (vol_info == NULL) {\n\t\t\t\tcifs_dbg(FYI, \"resetting capabilities failed\\n\");\n\t\t\t} else\n\t\t\t\tcifs_dbg(VFS, \"Negotiating Unix capabilities with the server failed. Consider mounting with the Unix Extensions disabled if problems are found by specifying the nounix mount option.\\n\");\n\n\t\t}\n\t}\n}\n\nvoid cifs_setup_cifs_sb(struct smb_vol *pvolume_info,\n\t\t\tstruct cifs_sb_info *cifs_sb)\n{\n\tINIT_DELAYED_WORK(&cifs_sb->prune_tlinks, cifs_prune_tlinks);\n\n\tspin_lock_init(&cifs_sb->tlink_tree_lock);\n\tcifs_sb->tlink_tree = RB_ROOT;\n\n\t/*\n\t * Temporarily set r/wsize for matching superblock. If we end up using\n\t * new sb then client will later negotiate it downward if needed.\n\t */\n\tcifs_sb->rsize = pvolume_info->rsize;\n\tcifs_sb->wsize = pvolume_info->wsize;\n\n\tcifs_sb->mnt_uid = pvolume_info->linux_uid;\n\tcifs_sb->mnt_gid = pvolume_info->linux_gid;\n\tcifs_sb->mnt_file_mode = pvolume_info->file_mode;\n\tcifs_sb->mnt_dir_mode = pvolume_info->dir_mode;\n\tcifs_dbg(FYI, \"file mode: 0x%hx  dir mode: 0x%hx\\n\",\n\t\t cifs_sb->mnt_file_mode, cifs_sb->mnt_dir_mode);\n\n\tcifs_sb->actimeo = pvolume_info->actimeo;\n\tcifs_sb->local_nls = pvolume_info->local_nls;\n\n\tif (pvolume_info->noperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_PERM;\n\tif (pvolume_info->setuids)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SET_UID;\n\tif (pvolume_info->server_ino)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SERVER_INUM;\n\tif (pvolume_info->remap)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MAP_SPECIAL_CHR;\n\tif (pvolume_info->no_xattr)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_XATTR;\n\tif (pvolume_info->sfu_emul)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_UNX_EMUL;\n\tif (pvolume_info->nobrl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_BRL;\n\tif (pvolume_info->nostrictsync)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOSSYNC;\n\tif (pvolume_info->mand_lock)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOPOSIXBRL;\n\tif (pvolume_info->rwpidforward)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_RWPIDFORWARD;\n\tif (pvolume_info->cifs_acl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_ACL;\n\tif (pvolume_info->backupuid_specified) {\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_BACKUPUID;\n\t\tcifs_sb->mnt_backupuid = pvolume_info->backupuid;\n\t}\n\tif (pvolume_info->backupgid_specified) {\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_BACKUPGID;\n\t\tcifs_sb->mnt_backupgid = pvolume_info->backupgid;\n\t}\n\tif (pvolume_info->override_uid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_UID;\n\tif (pvolume_info->override_gid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_GID;\n\tif (pvolume_info->dynperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DYNPERM;\n\tif (pvolume_info->fsc)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_FSCACHE;\n\tif (pvolume_info->multiuser)\n\t\tcifs_sb->mnt_cifs_flags |= (CIFS_MOUNT_MULTIUSER |\n\t\t\t\t\t    CIFS_MOUNT_NO_PERM);\n\tif (pvolume_info->strict_io)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_STRICT_IO;\n\tif (pvolume_info->direct_io) {\n\t\tcifs_dbg(FYI, \"mounting share using direct i/o\\n\");\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DIRECT_IO;\n\t}\n\tif (pvolume_info->mfsymlinks) {\n\t\tif (pvolume_info->sfu_emul) {\n\t\t\tcifs_dbg(VFS, \"mount option mfsymlinks ignored if sfu mount option is used\\n\");\n\t\t} else {\n\t\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MF_SYMLINKS;\n\t\t}\n\t}\n\n\tif ((pvolume_info->cifs_acl) && (pvolume_info->dynperm))\n\t\tcifs_dbg(VFS, \"mount option dynperm ignored if cifsacl mount option supported\\n\");\n}\n\nstatic void\ncleanup_volume_info_contents(struct smb_vol *volume_info)\n{\n\tkfree(volume_info->username);\n\tkzfree(volume_info->password);\n\tkfree(volume_info->UNC);\n\tkfree(volume_info->domainname);\n\tkfree(volume_info->iocharset);\n\tkfree(volume_info->prepath);\n}\n\nvoid\ncifs_cleanup_volume_info(struct smb_vol *volume_info)\n{\n\tif (!volume_info)\n\t\treturn;\n\tcleanup_volume_info_contents(volume_info);\n\tkfree(volume_info);\n}\n\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\n/*\n * cifs_build_path_to_root returns full path to root when we do not have an\n * exiting connection (tcon)\n */\nstatic char *\nbuild_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(full_path, vol->UNC, unc_len);\n\tpos = full_path + unc_len;\n\n\tif (pplen) {\n\t\t*pos++ = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos, vol->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\n\t*pos = '\\0'; /* add trailing null */\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}\n\n/*\n * Perform a dfs referral query for a share and (optionally) prefix\n *\n * If a referral is found, cifs_sb->mountdata will be (re-)allocated\n * to a string containing updated options for the submount.  Otherwise it\n * will be left untouched.\n *\n * Returns the rc from get_dfs_path to the caller, which can be used to\n * determine whether there were referrals.\n */\nstatic int\nexpand_dfs_referral(const unsigned int xid, struct cifs_ses *ses,\n\t\t    struct smb_vol *volume_info, struct cifs_sb_info *cifs_sb,\n\t\t    int check_prefix)\n{\n\tint rc;\n\tunsigned int num_referrals = 0;\n\tstruct dfs_info3_param *referrals = NULL;\n\tchar *full_path = NULL, *ref_path = NULL, *mdata = NULL;\n\n\tfull_path = build_unc_path_to_root(volume_info, cifs_sb);\n\tif (IS_ERR(full_path))\n\t\treturn PTR_ERR(full_path);\n\n\t/* For DFS paths, skip the first '\\' of the UNC */\n\tref_path = check_prefix ? full_path + 1 : volume_info->UNC + 1;\n\n\trc = get_dfs_path(xid, ses, ref_path, cifs_sb->local_nls,\n\t\t\t  &num_referrals, &referrals,\n\t\t\t  cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\n\tif (!rc && num_referrals > 0) {\n\t\tchar *fake_devname = NULL;\n\n\t\tmdata = cifs_compose_mount_options(cifs_sb->mountdata,\n\t\t\t\t\t\t   full_path + 1, referrals,\n\t\t\t\t\t\t   &fake_devname);\n\n\t\tfree_dfs_info_array(referrals, num_referrals);\n\n\t\tif (IS_ERR(mdata)) {\n\t\t\trc = PTR_ERR(mdata);\n\t\t\tmdata = NULL;\n\t\t} else {\n\t\t\tcleanup_volume_info_contents(volume_info);\n\t\t\trc = cifs_setup_volume_info(volume_info, mdata,\n\t\t\t\t\t\t\tfake_devname);\n\t\t}\n\t\tkfree(fake_devname);\n\t\tkfree(cifs_sb->mountdata);\n\t\tcifs_sb->mountdata = mdata;\n\t}\n\tkfree(full_path);\n\treturn rc;\n}\n#endif\n\nstatic int\ncifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\tconst char *devname)\n{\n\tint rc = 0;\n\n\tif (cifs_parse_mount_options(mount_data, devname, volume_info))\n\t\treturn -EINVAL;\n\n\tif (volume_info->nullauth) {\n\t\tcifs_dbg(FYI, \"Anonymous login\\n\");\n\t\tkfree(volume_info->username);\n\t\tvolume_info->username = NULL;\n\t} else if (volume_info->username) {\n\t\t/* BB fixme parse for domain name here */\n\t\tcifs_dbg(FYI, \"Username: %s\\n\", volume_info->username);\n\t} else {\n\t\tcifs_dbg(VFS, \"No username specified\\n\");\n\t/* In userspace mount helper we can get user name from alternate\n\t   locations such as env variables and files on disk */\n\t\treturn -EINVAL;\n\t}\n\n\t/* this is needed for ASCII cp to Unicode converts */\n\tif (volume_info->iocharset == NULL) {\n\t\t/* load_nls_default cannot return null */\n\t\tvolume_info->local_nls = load_nls_default();\n\t} else {\n\t\tvolume_info->local_nls = load_nls(volume_info->iocharset);\n\t\tif (volume_info->local_nls == NULL) {\n\t\t\tcifs_dbg(VFS, \"CIFS mount error: iocharset %s not found\\n\",\n\t\t\t\t volume_info->iocharset);\n\t\t\treturn -ELIBACC;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstruct smb_vol *\ncifs_get_volume_info(char *mount_data, const char *devname)\n{\n\tint rc;\n\tstruct smb_vol *volume_info;\n\n\tvolume_info = kmalloc(sizeof(struct smb_vol), GFP_KERNEL);\n\tif (!volume_info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc = cifs_setup_volume_info(volume_info, mount_data, devname);\n\tif (rc) {\n\t\tcifs_cleanup_volume_info(volume_info);\n\t\tvolume_info = ERR_PTR(rc);\n\t}\n\n\treturn volume_info;\n}\n\nint\ncifs_mount(struct cifs_sb_info *cifs_sb, struct smb_vol *volume_info)\n{\n\tint rc;\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tchar   *full_path;\n\tstruct tcon_link *tlink;\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tint referral_walks_count = 0;\n#endif\n\n\trc = bdi_setup_and_register(&cifs_sb->bdi, \"cifs\", BDI_CAP_MAP_COPY);\n\tif (rc)\n\t\treturn rc;\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\ntry_mount_again:\n\t/* cleanup activities if we're chasing a referral */\n\tif (referral_walks_count) {\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (ses)\n\t\t\tcifs_put_smb_ses(ses);\n\n\t\tfree_xid(xid);\n\t}\n#endif\n\trc = 0;\n\ttcon = NULL;\n\tses = NULL;\n\tserver = NULL;\n\tfull_path = NULL;\n\ttlink = NULL;\n\n\txid = get_xid();\n\n\t/* get a reference to a tcp session */\n\tserver = cifs_get_tcp_session(volume_info);\n\tif (IS_ERR(server)) {\n\t\trc = PTR_ERR(server);\n\t\tbdi_destroy(&cifs_sb->bdi);\n\t\tgoto out;\n\t}\n\n\t/* get a reference to a SMB session */\n\tses = cifs_get_smb_ses(server, volume_info);\n\tif (IS_ERR(ses)) {\n\t\trc = PTR_ERR(ses);\n\t\tses = NULL;\n\t\tgoto mount_fail_check;\n\t}\n\n\t/* search for existing tcon to this server share */\n\ttcon = cifs_get_tcon(ses, volume_info);\n\tif (IS_ERR(tcon)) {\n\t\trc = PTR_ERR(tcon);\n\t\ttcon = NULL;\n\t\tgoto remote_path_check;\n\t}\n\n\t/* tell server which Unix caps we support */\n\tif (cap_unix(tcon->ses)) {\n\t\t/* reset of caps checks mount to see if unix extensions\n\t\t   disabled for just this mount */\n\t\treset_cifs_unix_caps(xid, tcon, cifs_sb, volume_info);\n\t\tif ((tcon->ses->server->tcpStatus == CifsNeedReconnect) &&\n\t\t    (le64_to_cpu(tcon->fsUnixInfo.Capability) &\n\t\t     CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)) {\n\t\t\trc = -EACCES;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t} else\n\t\ttcon->unix_ext = 0; /* server does not support them */\n\n\t/* do not care if a following call succeed - informational */\n\tif (!tcon->ipc && server->ops->qfs_tcon)\n\t\tserver->ops->qfs_tcon(xid, tcon);\n\n\tcifs_sb->wsize = server->ops->negotiate_wsize(tcon, volume_info);\n\tcifs_sb->rsize = server->ops->negotiate_rsize(tcon, volume_info);\n\n\t/* tune readahead according to rsize */\n\tcifs_sb->bdi.ra_pages = cifs_sb->rsize / PAGE_CACHE_SIZE;\n\nremote_path_check:\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t/*\n\t * Perform an unconditional check for whether there are DFS\n\t * referrals for this path without prefix, to provide support\n\t * for DFS referrals from w2k8 servers which don't seem to respond\n\t * with PATH_NOT_COVERED to requests that include the prefix.\n\t * Chase the referral if found, otherwise continue normally.\n\t */\n\tif (referral_walks_count == 0) {\n\t\tint refrc = expand_dfs_referral(xid, ses, volume_info, cifs_sb,\n\t\t\t\t\t\tfalse);\n\t\tif (!refrc) {\n\t\t\treferral_walks_count++;\n\t\t\tgoto try_mount_again;\n\t\t}\n\t}\n#endif\n\n\t/* check if a whole path is not remote */\n\tif (!rc && tcon) {\n\t\tif (!server->ops->is_path_accessible) {\n\t\t\trc = -ENOSYS;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\t/*\n\t\t * cifs_build_path_to_root works only when we have a valid tcon\n\t\t */\n\t\tfull_path = cifs_build_path_to_root(volume_info, cifs_sb, tcon);\n\t\tif (full_path == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\trc = server->ops->is_path_accessible(xid, tcon, cifs_sb,\n\t\t\t\t\t\t     full_path);\n\t\tif (rc != 0 && rc != -EREMOTE) {\n\t\t\tkfree(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\tkfree(full_path);\n\t}\n\n\t/* get referral if needed */\n\tif (rc == -EREMOTE) {\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t\tif (referral_walks_count > MAX_NESTED_LINKS) {\n\t\t\t/*\n\t\t\t * BB: when we implement proper loop detection,\n\t\t\t *     we will remove this check. But now we need it\n\t\t\t *     to prevent an indefinite loop if 'DFS tree' is\n\t\t\t *     misconfigured (i.e. has loops).\n\t\t\t */\n\t\t\trc = -ELOOP;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\n\t\trc = expand_dfs_referral(xid, ses, volume_info, cifs_sb, true);\n\n\t\tif (!rc) {\n\t\t\treferral_walks_count++;\n\t\t\tgoto try_mount_again;\n\t\t}\n\t\tgoto mount_fail_check;\n#else /* No DFS support, return error on mount */\n\t\trc = -EOPNOTSUPP;\n#endif\n\t}\n\n\tif (rc)\n\t\tgoto mount_fail_check;\n\n\t/* now, hang the tcon off of the superblock */\n\ttlink = kzalloc(sizeof *tlink, GFP_KERNEL);\n\tif (tlink == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto mount_fail_check;\n\t}\n\n\ttlink->tl_uid = ses->linux_uid;\n\ttlink->tl_tcon = tcon;\n\ttlink->tl_time = jiffies;\n\tset_bit(TCON_LINK_MASTER, &tlink->tl_flags);\n\tset_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\n\tcifs_sb->master_tlink = tlink;\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(cifsiod_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n\nmount_fail_check:\n\t/* on error free sesinfo and tcon struct if needed */\n\tif (rc) {\n\t\t/* If find_unc succeeded then rc == 0 so we can not end */\n\t\t/* up accidentally freeing someone elses tcon struct */\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (ses)\n\t\t\tcifs_put_smb_ses(ses);\n\t\telse\n\t\t\tcifs_put_tcp_session(server);\n\t\tbdi_destroy(&cifs_sb->bdi);\n\t}\n\nout:\n\tfree_xid(xid);\n\treturn rc;\n}\n\n/*\n * Issue a TREE_CONNECT request. Note that for IPC$ shares, that the tcon\n * pointer may be NULL.\n */\nint\nCIFSTCon(const unsigned int xid, struct cifs_ses *ses,\n\t const char *tree, struct cifs_tcon *tcon,\n\t const struct nls_table *nls_codepage)\n{\n\tstruct smb_hdr *smb_buffer;\n\tstruct smb_hdr *smb_buffer_response;\n\tTCONX_REQ *pSMB;\n\tTCONX_RSP *pSMBr;\n\tunsigned char *bcc_ptr;\n\tint rc = 0;\n\tint length;\n\t__u16 bytes_left, count;\n\n\tif (ses == NULL)\n\t\treturn -EIO;\n\n\tsmb_buffer = cifs_buf_get();\n\tif (smb_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tsmb_buffer_response = smb_buffer;\n\n\theader_assemble(smb_buffer, SMB_COM_TREE_CONNECT_ANDX,\n\t\t\tNULL /*no tid */ , 4 /*wct */ );\n\n\tsmb_buffer->Mid = get_next_mid(ses->server);\n\tsmb_buffer->Uid = ses->Suid;\n\tpSMB = (TCONX_REQ *) smb_buffer;\n\tpSMBr = (TCONX_RSP *) smb_buffer_response;\n\n\tpSMB->AndXCommand = 0xFF;\n\tpSMB->Flags = cpu_to_le16(TCON_EXTENDED_SECINFO);\n\tbcc_ptr = &pSMB->Password[0];\n\tif (!tcon || (ses->server->sec_mode & SECMODE_USER)) {\n\t\tpSMB->PasswordLength = cpu_to_le16(1);\t/* minimum */\n\t\t*bcc_ptr = 0; /* password is null byte */\n\t\tbcc_ptr++;              /* skip password */\n\t\t/* already aligned so no need to do it below */\n\t} else {\n\t\tpSMB->PasswordLength = cpu_to_le16(CIFS_AUTH_RESP_SIZE);\n\t\t/* BB FIXME add code to fail this if NTLMv2 or Kerberos\n\t\t   specified as required (when that support is added to\n\t\t   the vfs in the future) as only NTLM or the much\n\t\t   weaker LANMAN (which we do not send by default) is accepted\n\t\t   by Samba (not sure whether other servers allow\n\t\t   NTLMv2 password here) */\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t\tif ((global_secflags & CIFSSEC_MAY_LANMAN) &&\n\t\t    (ses->server->secType == LANMAN))\n\t\t\tcalc_lanman_hash(tcon->password, ses->server->cryptkey,\n\t\t\t\t\t ses->server->sec_mode &\n\t\t\t\t\t    SECMODE_PW_ENCRYPT ? true : false,\n\t\t\t\t\t bcc_ptr);\n\t\telse\n#endif /* CIFS_WEAK_PW_HASH */\n\t\trc = SMBNTencrypt(tcon->password, ses->server->cryptkey,\n\t\t\t\t\tbcc_ptr, nls_codepage);\n\n\t\tbcc_ptr += CIFS_AUTH_RESP_SIZE;\n\t\tif (ses->capabilities & CAP_UNICODE) {\n\t\t\t/* must align unicode strings */\n\t\t\t*bcc_ptr = 0; /* null byte password */\n\t\t\tbcc_ptr++;\n\t\t}\n\t}\n\n\tif (ses->server->sec_mode &\n\t\t\t(SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED))\n\t\tsmb_buffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_UNICODE;\n\t\tlength =\n\t\t    cifs_strtoUTF16((__le16 *) bcc_ptr, tree,\n\t\t\t6 /* max utf8 char length in bytes */ *\n\t\t\t(/* server len*/ + 256 /* share len */), nls_codepage);\n\t\tbcc_ptr += 2 * length;\t/* convert num 16 bit words to bytes */\n\t\tbcc_ptr += 2;\t/* skip trailing null */\n\t} else {\t\t/* ASCII */\n\t\tstrcpy(bcc_ptr, tree);\n\t\tbcc_ptr += strlen(tree) + 1;\n\t}\n\tstrcpy(bcc_ptr, \"?????\");\n\tbcc_ptr += strlen(\"?????\");\n\tbcc_ptr += 1;\n\tcount = bcc_ptr - &pSMB->Password[0];\n\tpSMB->hdr.smb_buf_length = cpu_to_be32(be32_to_cpu(\n\t\t\t\t\tpSMB->hdr.smb_buf_length) + count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, ses, smb_buffer, smb_buffer_response, &length,\n\t\t\t 0);\n\n\t/* above now done in SendReceive */\n\tif ((rc == 0) && (tcon != NULL)) {\n\t\tbool is_unicode;\n\n\t\ttcon->tidStatus = CifsGood;\n\t\ttcon->need_reconnect = false;\n\t\ttcon->tid = smb_buffer_response->Tid;\n\t\tbcc_ptr = pByteArea(smb_buffer_response);\n\t\tbytes_left = get_bcc(smb_buffer_response);\n\t\tlength = strnlen(bcc_ptr, bytes_left - 2);\n\t\tif (smb_buffer->Flags2 & SMBFLG2_UNICODE)\n\t\t\tis_unicode = true;\n\t\telse\n\t\t\tis_unicode = false;\n\n\n\t\t/* skip service field (NB: this field is always ASCII) */\n\t\tif (length == 3) {\n\t\t\tif ((bcc_ptr[0] == 'I') && (bcc_ptr[1] == 'P') &&\n\t\t\t    (bcc_ptr[2] == 'C')) {\n\t\t\t\tcifs_dbg(FYI, \"IPC connection\\n\");\n\t\t\t\ttcon->ipc = 1;\n\t\t\t}\n\t\t} else if (length == 2) {\n\t\t\tif ((bcc_ptr[0] == 'A') && (bcc_ptr[1] == ':')) {\n\t\t\t\t/* the most common case */\n\t\t\t\tcifs_dbg(FYI, \"disk share connection\\n\");\n\t\t\t}\n\t\t}\n\t\tbcc_ptr += length + 1;\n\t\tbytes_left -= (length + 1);\n\t\tstrncpy(tcon->treeName, tree, MAX_TREE_SIZE);\n\n\t\t/* mostly informational -- no need to fail on error here */\n\t\tkfree(tcon->nativeFileSystem);\n\t\ttcon->nativeFileSystem = cifs_strndup_from_utf16(bcc_ptr,\n\t\t\t\t\t\t      bytes_left, is_unicode,\n\t\t\t\t\t\t      nls_codepage);\n\n\t\tcifs_dbg(FYI, \"nativeFileSystem=%s\\n\", tcon->nativeFileSystem);\n\n\t\tif ((smb_buffer_response->WordCount == 3) ||\n\t\t\t (smb_buffer_response->WordCount == 7))\n\t\t\t/* field is in same location */\n\t\t\ttcon->Flags = le16_to_cpu(pSMBr->OptionalSupport);\n\t\telse\n\t\t\ttcon->Flags = 0;\n\t\tcifs_dbg(FYI, \"Tcon flags: 0x%x\\n\", tcon->Flags);\n\t} else if ((rc == 0) && tcon == NULL) {\n\t\t/* all we need to save for IPC$ connection */\n\t\tses->ipc_tid = smb_buffer_response->Tid;\n\t}\n\n\tcifs_buf_release(smb_buffer);\n\treturn rc;\n}\n\nvoid\ncifs_umount(struct cifs_sb_info *cifs_sb)\n{\n\tstruct rb_root *root = &cifs_sb->tlink_tree;\n\tstruct rb_node *node;\n\tstruct tcon_link *tlink;\n\n\tcancel_delayed_work_sync(&cifs_sb->prune_tlinks);\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\twhile ((node = rb_first(root))) {\n\t\ttlink = rb_entry(node, struct tcon_link, tl_rbnode);\n\t\tcifs_get_tlink(tlink);\n\t\tclear_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\t\trb_erase(node, root);\n\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\tcifs_put_tlink(tlink);\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t}\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tbdi_destroy(&cifs_sb->bdi);\n\tkfree(cifs_sb->mountdata);\n\tunload_nls(cifs_sb->local_nls);\n\tkfree(cifs_sb);\n}\n\nint\ncifs_negotiate_protocol(const unsigned int xid, struct cifs_ses *ses)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tif (!server->ops->need_neg || !server->ops->negotiate)\n\t\treturn -ENOSYS;\n\n\t/* only send once per connect */\n\tif (!server->ops->need_neg(server))\n\t\treturn 0;\n\n\tset_credits(server, 1);\n\n\trc = server->ops->negotiate(xid, ses);\n\tif (rc == 0) {\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (server->tcpStatus == CifsNeedNegotiate)\n\t\t\tserver->tcpStatus = CifsGood;\n\t\telse\n\t\t\trc = -EHOSTDOWN;\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\treturn rc;\n}\n\nint\ncifs_setup_session(const unsigned int xid, struct cifs_ses *ses,\n\t\t   struct nls_table *nls_info)\n{\n\tint rc = -ENOSYS;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tses->flags = 0;\n\tses->capabilities = server->capabilities;\n\tif (linuxExtEnabled == 0)\n\t\tses->capabilities &= (~server->vals->cap_unix);\n\n\tcifs_dbg(FYI, \"Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\\n\",\n\t\t server->sec_mode, server->capabilities, server->timeAdj);\n\n\tif (server->ops->sess_setup)\n\t\trc = server->ops->sess_setup(xid, ses, nls_info);\n\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in SessSetup = %d\\n\", rc);\n\t} else {\n\t\tmutex_lock(&server->srv_mutex);\n\t\tif (!server->session_estab) {\n\t\t\tserver->session_key.response = ses->auth_key.response;\n\t\t\tserver->session_key.len = ses->auth_key.len;\n\t\t\tserver->sequence_number = 0x2;\n\t\t\tserver->session_estab = true;\n\t\t\tses->auth_key.response = NULL;\n\t\t}\n\t\tmutex_unlock(&server->srv_mutex);\n\n\t\tcifs_dbg(FYI, \"CIFS Session Established successfully\\n\");\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tses->status = CifsGood;\n\t\tses->need_reconnect = false;\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n\tses->auth_key.len = 0;\n\tkfree(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\n\treturn rc;\n}\n\nstatic int\ncifs_set_vol_auth(struct smb_vol *vol, struct cifs_ses *ses)\n{\n\tswitch (ses->server->secType) {\n\tcase Kerberos:\n\t\tvol->secFlg = CIFSSEC_MUST_KRB5;\n\t\treturn 0;\n\tcase NTLMv2:\n\t\tvol->secFlg = CIFSSEC_MUST_NTLMV2;\n\t\tbreak;\n\tcase NTLM:\n\t\tvol->secFlg = CIFSSEC_MUST_NTLM;\n\t\tbreak;\n\tcase RawNTLMSSP:\n\t\tvol->secFlg = CIFSSEC_MUST_NTLMSSP;\n\t\tbreak;\n\tcase LANMAN:\n\t\tvol->secFlg = CIFSSEC_MUST_LANMAN;\n\t\tbreak;\n\t}\n\n\treturn cifs_set_cifscreds(vol, ses);\n}\n\nstatic struct cifs_tcon *\ncifs_construct_tcon(struct cifs_sb_info *cifs_sb, kuid_t fsuid)\n{\n\tint rc;\n\tstruct cifs_tcon *master_tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon = NULL;\n\tstruct smb_vol *vol_info;\n\n\tvol_info = kzalloc(sizeof(*vol_info), GFP_KERNEL);\n\tif (vol_info == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvol_info->local_nls = cifs_sb->local_nls;\n\tvol_info->linux_uid = fsuid;\n\tvol_info->cred_uid = fsuid;\n\tvol_info->UNC = master_tcon->treeName;\n\tvol_info->retry = master_tcon->retry;\n\tvol_info->nocase = master_tcon->nocase;\n\tvol_info->local_lease = master_tcon->local_lease;\n\tvol_info->no_linux_ext = !master_tcon->unix_ext;\n\n\trc = cifs_set_vol_auth(vol_info, master_tcon->ses);\n\tif (rc) {\n\t\ttcon = ERR_PTR(rc);\n\t\tgoto out;\n\t}\n\n\t/* get a reference for the same TCP session */\n\tspin_lock(&cifs_tcp_ses_lock);\n\t++master_tcon->ses->server->srv_count;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tses = cifs_get_smb_ses(master_tcon->ses->server, vol_info);\n\tif (IS_ERR(ses)) {\n\t\ttcon = (struct cifs_tcon *)ses;\n\t\tcifs_put_tcp_session(master_tcon->ses->server);\n\t\tgoto out;\n\t}\n\n\ttcon = cifs_get_tcon(ses, vol_info);\n\tif (IS_ERR(tcon)) {\n\t\tcifs_put_smb_ses(ses);\n\t\tgoto out;\n\t}\n\n\tif (cap_unix(ses))\n\t\treset_cifs_unix_caps(0, tcon, NULL, vol_info);\nout:\n\tkfree(vol_info->username);\n\tkfree(vol_info->password);\n\tkfree(vol_info);\n\n\treturn tcon;\n}\n\nstruct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}\n\nstatic int\ncifs_sb_tcon_pending_wait(void *unused)\n{\n\tschedule();\n\treturn signal_pending(current) ? -ERESTARTSYS : 0;\n}\n\n/* find and return a tlink with given uid */\nstatic struct tcon_link *\ntlink_rb_search(struct rb_root *root, kuid_t uid)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct tcon_link *tlink;\n\n\twhile (node) {\n\t\ttlink = rb_entry(node, struct tcon_link, tl_rbnode);\n\n\t\tif (uid_gt(tlink->tl_uid, uid))\n\t\t\tnode = node->rb_left;\n\t\telse if (uid_lt(tlink->tl_uid, uid))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn tlink;\n\t}\n\treturn NULL;\n}\n\n/* insert a tcon_link into the tree */\nstatic void\ntlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct tcon_link *tlink;\n\n\twhile (*new) {\n\t\ttlink = rb_entry(*new, struct tcon_link, tl_rbnode);\n\t\tparent = *new;\n\n\t\tif (uid_gt(tlink->tl_uid, new_tlink->tl_uid))\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_tlink->tl_rbnode, parent, new);\n\trb_insert_color(&new_tlink->tl_rbnode, root);\n}\n\n/*\n * Find or construct an appropriate tcon given a cifs_sb and the fsuid of the\n * current task.\n *\n * If the superblock doesn't refer to a multiuser mount, then just return\n * the master tcon for the mount.\n *\n * First, search the rbtree for an existing tcon for this fsuid. If one\n * exists, then check to see if it's pending construction. If it is then wait\n * for construction to complete. Once it's no longer pending, check to see if\n * it failed and either return an error or retry construction, depending on\n * the timeout.\n *\n * If one doesn't exist then insert a new tcon_link struct into the tree and\n * try to construct a new one.\n */\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  cifs_sb_tcon_pending_wait,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}\n\n/*\n * periodic workqueue job that scans tcon_tree for a superblock and closes\n * out tcons.\n */\nstatic void\ncifs_prune_tlinks(struct work_struct *work)\n{\n\tstruct cifs_sb_info *cifs_sb = container_of(work, struct cifs_sb_info,\n\t\t\t\t\t\t    prune_tlinks.work);\n\tstruct rb_root *root = &cifs_sb->tlink_tree;\n\tstruct rb_node *node = rb_first(root);\n\tstruct rb_node *tmp;\n\tstruct tcon_link *tlink;\n\n\t/*\n\t * Because we drop the spinlock in the loop in order to put the tlink\n\t * it's not guarded against removal of links from the tree. The only\n\t * places that remove entries from the tree are this function and\n\t * umounts. Because this function is non-reentrant and is canceled\n\t * before umount can proceed, this is safe.\n\t */\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\tnode = rb_first(root);\n\twhile (node != NULL) {\n\t\ttmp = node;\n\t\tnode = rb_next(tmp);\n\t\ttlink = rb_entry(tmp, struct tcon_link, tl_rbnode);\n\n\t\tif (test_bit(TCON_LINK_MASTER, &tlink->tl_flags) ||\n\t\t    atomic_read(&tlink->tl_count) != 0 ||\n\t\t    time_after(tlink->tl_time + TLINK_IDLE_EXPIRE, jiffies))\n\t\t\tcontinue;\n\n\t\tcifs_get_tlink(tlink);\n\t\tclear_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\t\trb_erase(tmp, root);\n\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\tcifs_put_tlink(tlink);\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t}\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(cifsiod_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n}\n"], "fixing_code": ["/*\n *   fs/cifs/connect.c\n *\n *   Copyright (C) International Business Machines  Corp., 2002,2011\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */\n#include <linux/fs.h>\n#include <linux/net.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/ctype.h>\n#include <linux/utsname.h>\n#include <linux/mempool.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/pagevec.h>\n#include <linux/freezer.h>\n#include <linux/namei.h>\n#include <asm/uaccess.h>\n#include <asm/processor.h>\n#include <linux/inet.h>\n#include <linux/module.h>\n#include <keys/user-type.h>\n#include <net/ipv6.h>\n#include <linux/parser.h>\n\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_fs_sb.h\"\n#include \"ntlmssp.h\"\n#include \"nterr.h\"\n#include \"rfc1002pdu.h\"\n#include \"fscache.h\"\n\n#define CIFS_PORT 445\n#define RFC1001_PORT 139\n\nextern mempool_t *cifs_req_poolp;\n\n/* FIXME: should these be tunable? */\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n#define TLINK_IDLE_EXPIRE\t(600 * HZ)\n\nenum {\n\n\t/* Mount options that take no arguments */\n\tOpt_user_xattr, Opt_nouser_xattr,\n\tOpt_forceuid, Opt_noforceuid,\n\tOpt_forcegid, Opt_noforcegid,\n\tOpt_noblocksend, Opt_noautotune,\n\tOpt_hard, Opt_soft, Opt_perm, Opt_noperm,\n\tOpt_mapchars, Opt_nomapchars, Opt_sfu,\n\tOpt_nosfu, Opt_nodfs, Opt_posixpaths,\n\tOpt_noposixpaths, Opt_nounix,\n\tOpt_nocase,\n\tOpt_brl, Opt_nobrl,\n\tOpt_forcemandatorylock, Opt_setuids,\n\tOpt_nosetuids, Opt_dynperm, Opt_nodynperm,\n\tOpt_nohard, Opt_nosoft,\n\tOpt_nointr, Opt_intr,\n\tOpt_nostrictsync, Opt_strictsync,\n\tOpt_serverino, Opt_noserverino,\n\tOpt_rwpidforward, Opt_cifsacl, Opt_nocifsacl,\n\tOpt_acl, Opt_noacl, Opt_locallease,\n\tOpt_sign, Opt_seal, Opt_noac,\n\tOpt_fsc, Opt_mfsymlinks,\n\tOpt_multiuser, Opt_sloppy,\n\n\t/* Mount options which take numeric value */\n\tOpt_backupuid, Opt_backupgid, Opt_uid,\n\tOpt_cruid, Opt_gid, Opt_file_mode,\n\tOpt_dirmode, Opt_port,\n\tOpt_rsize, Opt_wsize, Opt_actimeo,\n\n\t/* Mount options which take string value */\n\tOpt_user, Opt_pass, Opt_ip,\n\tOpt_domain, Opt_srcaddr, Opt_iocharset,\n\tOpt_netbiosname, Opt_servern,\n\tOpt_ver, Opt_vers, Opt_sec, Opt_cache,\n\n\t/* Mount options to be ignored */\n\tOpt_ignore,\n\n\t/* Options which could be blank */\n\tOpt_blank_pass,\n\tOpt_blank_user,\n\tOpt_blank_ip,\n\n\tOpt_err\n};\n\nstatic const match_table_t cifs_mount_option_tokens = {\n\n\t{ Opt_user_xattr, \"user_xattr\" },\n\t{ Opt_nouser_xattr, \"nouser_xattr\" },\n\t{ Opt_forceuid, \"forceuid\" },\n\t{ Opt_noforceuid, \"noforceuid\" },\n\t{ Opt_forcegid, \"forcegid\" },\n\t{ Opt_noforcegid, \"noforcegid\" },\n\t{ Opt_noblocksend, \"noblocksend\" },\n\t{ Opt_noautotune, \"noautotune\" },\n\t{ Opt_hard, \"hard\" },\n\t{ Opt_soft, \"soft\" },\n\t{ Opt_perm, \"perm\" },\n\t{ Opt_noperm, \"noperm\" },\n\t{ Opt_mapchars, \"mapchars\" },\n\t{ Opt_nomapchars, \"nomapchars\" },\n\t{ Opt_sfu, \"sfu\" },\n\t{ Opt_nosfu, \"nosfu\" },\n\t{ Opt_nodfs, \"nodfs\" },\n\t{ Opt_posixpaths, \"posixpaths\" },\n\t{ Opt_noposixpaths, \"noposixpaths\" },\n\t{ Opt_nounix, \"nounix\" },\n\t{ Opt_nounix, \"nolinux\" },\n\t{ Opt_nocase, \"nocase\" },\n\t{ Opt_nocase, \"ignorecase\" },\n\t{ Opt_brl, \"brl\" },\n\t{ Opt_nobrl, \"nobrl\" },\n\t{ Opt_nobrl, \"nolock\" },\n\t{ Opt_forcemandatorylock, \"forcemandatorylock\" },\n\t{ Opt_forcemandatorylock, \"forcemand\" },\n\t{ Opt_setuids, \"setuids\" },\n\t{ Opt_nosetuids, \"nosetuids\" },\n\t{ Opt_dynperm, \"dynperm\" },\n\t{ Opt_nodynperm, \"nodynperm\" },\n\t{ Opt_nohard, \"nohard\" },\n\t{ Opt_nosoft, \"nosoft\" },\n\t{ Opt_nointr, \"nointr\" },\n\t{ Opt_intr, \"intr\" },\n\t{ Opt_nostrictsync, \"nostrictsync\" },\n\t{ Opt_strictsync, \"strictsync\" },\n\t{ Opt_serverino, \"serverino\" },\n\t{ Opt_noserverino, \"noserverino\" },\n\t{ Opt_rwpidforward, \"rwpidforward\" },\n\t{ Opt_cifsacl, \"cifsacl\" },\n\t{ Opt_nocifsacl, \"nocifsacl\" },\n\t{ Opt_acl, \"acl\" },\n\t{ Opt_noacl, \"noacl\" },\n\t{ Opt_locallease, \"locallease\" },\n\t{ Opt_sign, \"sign\" },\n\t{ Opt_seal, \"seal\" },\n\t{ Opt_noac, \"noac\" },\n\t{ Opt_fsc, \"fsc\" },\n\t{ Opt_mfsymlinks, \"mfsymlinks\" },\n\t{ Opt_multiuser, \"multiuser\" },\n\t{ Opt_sloppy, \"sloppy\" },\n\n\t{ Opt_backupuid, \"backupuid=%s\" },\n\t{ Opt_backupgid, \"backupgid=%s\" },\n\t{ Opt_uid, \"uid=%s\" },\n\t{ Opt_cruid, \"cruid=%s\" },\n\t{ Opt_gid, \"gid=%s\" },\n\t{ Opt_file_mode, \"file_mode=%s\" },\n\t{ Opt_dirmode, \"dirmode=%s\" },\n\t{ Opt_dirmode, \"dir_mode=%s\" },\n\t{ Opt_port, \"port=%s\" },\n\t{ Opt_rsize, \"rsize=%s\" },\n\t{ Opt_wsize, \"wsize=%s\" },\n\t{ Opt_actimeo, \"actimeo=%s\" },\n\n\t{ Opt_blank_user, \"user=\" },\n\t{ Opt_blank_user, \"username=\" },\n\t{ Opt_user, \"user=%s\" },\n\t{ Opt_user, \"username=%s\" },\n\t{ Opt_blank_pass, \"pass=\" },\n\t{ Opt_blank_pass, \"password=\" },\n\t{ Opt_pass, \"pass=%s\" },\n\t{ Opt_pass, \"password=%s\" },\n\t{ Opt_blank_ip, \"ip=\" },\n\t{ Opt_blank_ip, \"addr=\" },\n\t{ Opt_ip, \"ip=%s\" },\n\t{ Opt_ip, \"addr=%s\" },\n\t{ Opt_ignore, \"unc=%s\" },\n\t{ Opt_ignore, \"target=%s\" },\n\t{ Opt_ignore, \"path=%s\" },\n\t{ Opt_domain, \"dom=%s\" },\n\t{ Opt_domain, \"domain=%s\" },\n\t{ Opt_domain, \"workgroup=%s\" },\n\t{ Opt_srcaddr, \"srcaddr=%s\" },\n\t{ Opt_ignore, \"prefixpath=%s\" },\n\t{ Opt_iocharset, \"iocharset=%s\" },\n\t{ Opt_netbiosname, \"netbiosname=%s\" },\n\t{ Opt_servern, \"servern=%s\" },\n\t{ Opt_ver, \"ver=%s\" },\n\t{ Opt_vers, \"vers=%s\" },\n\t{ Opt_sec, \"sec=%s\" },\n\t{ Opt_cache, \"cache=%s\" },\n\n\t{ Opt_ignore, \"cred\" },\n\t{ Opt_ignore, \"credentials\" },\n\t{ Opt_ignore, \"cred=%s\" },\n\t{ Opt_ignore, \"credentials=%s\" },\n\t{ Opt_ignore, \"guest\" },\n\t{ Opt_ignore, \"rw\" },\n\t{ Opt_ignore, \"ro\" },\n\t{ Opt_ignore, \"suid\" },\n\t{ Opt_ignore, \"nosuid\" },\n\t{ Opt_ignore, \"exec\" },\n\t{ Opt_ignore, \"noexec\" },\n\t{ Opt_ignore, \"nodev\" },\n\t{ Opt_ignore, \"noauto\" },\n\t{ Opt_ignore, \"dev\" },\n\t{ Opt_ignore, \"mand\" },\n\t{ Opt_ignore, \"nomand\" },\n\t{ Opt_ignore, \"_netdev\" },\n\n\t{ Opt_err, NULL }\n};\n\nenum {\n\tOpt_sec_krb5, Opt_sec_krb5i, Opt_sec_krb5p,\n\tOpt_sec_ntlmsspi, Opt_sec_ntlmssp,\n\tOpt_ntlm, Opt_sec_ntlmi, Opt_sec_ntlmv2,\n\tOpt_sec_ntlmv2i, Opt_sec_lanman,\n\tOpt_sec_none,\n\n\tOpt_sec_err\n};\n\nstatic const match_table_t cifs_secflavor_tokens = {\n\t{ Opt_sec_krb5, \"krb5\" },\n\t{ Opt_sec_krb5i, \"krb5i\" },\n\t{ Opt_sec_krb5p, \"krb5p\" },\n\t{ Opt_sec_ntlmsspi, \"ntlmsspi\" },\n\t{ Opt_sec_ntlmssp, \"ntlmssp\" },\n\t{ Opt_ntlm, \"ntlm\" },\n\t{ Opt_sec_ntlmi, \"ntlmi\" },\n\t{ Opt_sec_ntlmv2, \"nontlm\" },\n\t{ Opt_sec_ntlmv2, \"ntlmv2\" },\n\t{ Opt_sec_ntlmv2i, \"ntlmv2i\" },\n\t{ Opt_sec_lanman, \"lanman\" },\n\t{ Opt_sec_none, \"none\" },\n\n\t{ Opt_sec_err, NULL }\n};\n\n/* cache flavors */\nenum {\n\tOpt_cache_loose,\n\tOpt_cache_strict,\n\tOpt_cache_none,\n\tOpt_cache_err\n};\n\nstatic const match_table_t cifs_cacheflavor_tokens = {\n\t{ Opt_cache_loose, \"loose\" },\n\t{ Opt_cache_strict, \"strict\" },\n\t{ Opt_cache_none, \"none\" },\n\t{ Opt_cache_err, NULL }\n};\n\nstatic const match_table_t cifs_smb_version_tokens = {\n\t{ Smb_1, SMB1_VERSION_STRING },\n\t{ Smb_20, SMB20_VERSION_STRING},\n\t{ Smb_21, SMB21_VERSION_STRING },\n\t{ Smb_30, SMB30_VERSION_STRING },\n};\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\nstatic void tlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink);\nstatic void cifs_prune_tlinks(struct work_struct *work);\nstatic int cifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\t\t\tconst char *devname);\n\n/*\n * cifs tcp session reconnection\n *\n * mark tcp session as reconnecting so temporarily locked\n * mark all smb sessions as reconnecting for tcp session\n * reconnect tcp session\n * wake up waiters on reconnection? - (not needed currently)\n */\nint\ncifs_reconnect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tstruct list_head *tmp, *tmp2;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct mid_q_entry *mid_entry;\n\tstruct list_head retry_list;\n\n\tspin_lock(&GlobalMid_Lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\t/* the demux thread will exit normally\n\t\tnext time through the loop */\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\t} else\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\tspin_unlock(&GlobalMid_Lock);\n\tserver->maxBuf = 0;\n#ifdef CONFIG_CIFS_SMB2\n\tserver->max_read = 0;\n#endif\n\n\tcifs_dbg(FYI, \"Reconnecting tcp session\\n\");\n\n\t/* before reconnecting the tcp session, mark the smb session (uid)\n\t\tand the tid bad so they are not used until reconnected */\n\tcifs_dbg(FYI, \"%s: marking sessions and tcons for reconnect\\n\",\n\t\t __func__);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifs_ses, smb_ses_list);\n\t\tses->need_reconnect = true;\n\t\tses->ipc_tid = 0;\n\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp2, struct cifs_tcon, tcon_list);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\t/* do not want to be sending data on a socket we are freeing */\n\tcifs_dbg(FYI, \"%s: tearing down socket\\n\", __func__);\n\tmutex_lock(&server->srv_mutex);\n\tif (server->ssocket) {\n\t\tcifs_dbg(FYI, \"State: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcifs_dbg(FYI, \"Post shutdown state: 0x%x Flags: 0x%lx\\n\",\n\t\t\t server->ssocket->state, server->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\tserver->sequence_number = 0;\n\tserver->session_estab = false;\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tserver->lstrp = jiffies;\n\tmutex_unlock(&server->srv_mutex);\n\n\t/* mark submitted MIDs for retry and issue callback */\n\tINIT_LIST_HEAD(&retry_list);\n\tcifs_dbg(FYI, \"%s: moving mids to private list\\n\", __func__);\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tif (mid_entry->mid_state == MID_REQUEST_SUBMITTED)\n\t\t\tmid_entry->mid_state = MID_RETRY_NEEDED;\n\t\tlist_move(&mid_entry->qhead, &retry_list);\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_dbg(FYI, \"%s: issuing mid callbacks\\n\", __func__);\n\tlist_for_each_safe(tmp, tmp2, &retry_list) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\tlist_del_init(&mid_entry->qhead);\n\t\tmid_entry->callback(mid_entry);\n\t}\n\n\tdo {\n\t\ttry_to_freeze();\n\n\t\t/* we should try only the port we connected to before */\n\t\trc = generic_ip_connect(server);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI, \"reconnect error %d\\n\", rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsNeedNegotiate;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t\t}\n\t} while (server->tcpStatus == CifsNeedReconnect);\n\n\treturn rc;\n}\n\nstatic void\ncifs_echo_request(struct work_struct *work)\n{\n\tint rc;\n\tstruct TCP_Server_Info *server = container_of(work,\n\t\t\t\t\tstruct TCP_Server_Info, echo.work);\n\n\t/*\n\t * We cannot send an echo if it is disabled or until the\n\t * NEGOTIATE_PROTOCOL request is done, which is indicated by\n\t * server->ops->need_neg() == true. Also, no need to ping if\n\t * we got a response recently.\n\t */\n\tif (!server->ops->need_neg || server->ops->need_neg(server) ||\n\t    (server->ops->can_echo && !server->ops->can_echo(server)) ||\n\t    time_before(jiffies, server->lstrp + SMB_ECHO_INTERVAL - HZ))\n\t\tgoto requeue_echo;\n\n\trc = server->ops->echo ? server->ops->echo(server) : -ENOSYS;\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Unable to send echo request to server: %s\\n\",\n\t\t\t server->hostname);\n\nrequeue_echo:\n\tqueue_delayed_work(cifsiod_wq, &server->echo, SMB_ECHO_INTERVAL);\n}\n\nstatic bool\nallocate_buffers(struct TCP_Server_Info *server)\n{\n\tif (!server->bigbuf) {\n\t\tserver->bigbuf = (char *)cifs_buf_get();\n\t\tif (!server->bigbuf) {\n\t\t\tcifs_dbg(VFS, \"No memory for large SMB response\\n\");\n\t\t\tmsleep(3000);\n\t\t\t/* retry will check if exiting */\n\t\t\treturn false;\n\t\t}\n\t} else if (server->large_buf) {\n\t\t/* we are reusing a dirty large buf, clear its start */\n\t\tmemset(server->bigbuf, 0, HEADER_SIZE(server));\n\t}\n\n\tif (!server->smallbuf) {\n\t\tserver->smallbuf = (char *)cifs_small_buf_get();\n\t\tif (!server->smallbuf) {\n\t\t\tcifs_dbg(VFS, \"No memory for SMB response\\n\");\n\t\t\tmsleep(1000);\n\t\t\t/* retry will check if exiting */\n\t\t\treturn false;\n\t\t}\n\t\t/* beginning of smb buffer is cleared in our buf_get */\n\t} else {\n\t\t/* if existing small buf clear beginning */\n\t\tmemset(server->smallbuf, 0, HEADER_SIZE(server));\n\t}\n\n\treturn true;\n}\n\nstatic bool\nserver_unresponsive(struct TCP_Server_Info *server)\n{\n\t/*\n\t * We need to wait 2 echo intervals to make sure we handle such\n\t * situations right:\n\t * 1s  client sends a normal SMB request\n\t * 2s  client gets a response\n\t * 30s echo workqueue job pops, and decides we got a response recently\n\t *     and don't need to send another\n\t * ...\n\t * 65s kernel_recvmsg times out, and we see that we haven't gotten\n\t *     a response in >60s.\n\t */\n\tif (server->tcpStatus == CifsGood &&\n\t    time_after(jiffies, server->lstrp + 2 * SMB_ECHO_INTERVAL)) {\n\t\tcifs_dbg(VFS, \"Server %s has not responded in %d seconds. Reconnecting...\\n\",\n\t\t\t server->hostname, (2 * SMB_ECHO_INTERVAL) / HZ);\n\t\tcifs_reconnect(server);\n\t\twake_up(&server->response_q);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n * kvec_array_init - clone a kvec array, and advance into it\n * @new:\tpointer to memory for cloned array\n * @iov:\tpointer to original array\n * @nr_segs:\tnumber of members in original array\n * @bytes:\tnumber of bytes to advance into the cloned array\n *\n * This function will copy the array provided in iov to a section of memory\n * and advance the specified number of bytes into the new array. It returns\n * the number of segments in the new array. \"new\" must be at least as big as\n * the original iov array.\n */\nstatic unsigned int\nkvec_array_init(struct kvec *new, struct kvec *iov, unsigned int nr_segs,\n\t\tsize_t bytes)\n{\n\tsize_t base = 0;\n\n\twhile (bytes || !iov->iov_len) {\n\t\tint copy = min(bytes, iov->iov_len);\n\n\t\tbytes -= copy;\n\t\tbase += copy;\n\t\tif (iov->iov_len == base) {\n\t\t\tiov++;\n\t\t\tnr_segs--;\n\t\t\tbase = 0;\n\t\t}\n\t}\n\tmemcpy(new, iov, sizeof(*iov) * nr_segs);\n\tnew->iov_base += base;\n\tnew->iov_len -= base;\n\treturn nr_segs;\n}\n\nstatic struct kvec *\nget_server_iovec(struct TCP_Server_Info *server, unsigned int nr_segs)\n{\n\tstruct kvec *new_iov;\n\n\tif (server->iov && nr_segs <= server->nr_iov)\n\t\treturn server->iov;\n\n\t/* not big enough -- allocate a new one and release the old */\n\tnew_iov = kmalloc(sizeof(*new_iov) * nr_segs, GFP_NOFS);\n\tif (new_iov) {\n\t\tkfree(server->iov);\n\t\tserver->iov = new_iov;\n\t\tserver->nr_iov = nr_segs;\n\t}\n\treturn new_iov;\n}\n\nint\ncifs_readv_from_socket(struct TCP_Server_Info *server, struct kvec *iov_orig,\n\t\t       unsigned int nr_segs, unsigned int to_read)\n{\n\tint length = 0;\n\tint total_read;\n\tunsigned int segs;\n\tstruct msghdr smb_msg;\n\tstruct kvec *iov;\n\n\tiov = get_server_iovec(server, nr_segs);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\tsmb_msg.msg_control = NULL;\n\tsmb_msg.msg_controllen = 0;\n\n\tfor (total_read = 0; to_read; total_read += length, to_read -= length) {\n\t\ttry_to_freeze();\n\n\t\tif (server_unresponsive(server)) {\n\t\t\ttotal_read = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tsegs = kvec_array_init(iov, iov_orig, nr_segs, total_read);\n\n\t\tlength = kernel_recvmsg(server->ssocket, &smb_msg,\n\t\t\t\t\tiov, segs, to_read, 0);\n\n\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\ttotal_read = -ESHUTDOWN;\n\t\t\tbreak;\n\t\t} else if (server->tcpStatus == CifsNeedReconnect) {\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -EAGAIN;\n\t\t\tbreak;\n\t\t} else if (length == -ERESTARTSYS ||\n\t\t\t   length == -EAGAIN ||\n\t\t\t   length == -EINTR) {\n\t\t\t/*\n\t\t\t * Minimum sleep to prevent looping, allowing socket\n\t\t\t * to clear and app threads to set tcpStatus\n\t\t\t * CifsNeedReconnect if server hung.\n\t\t\t */\n\t\t\tusleep_range(1000, 2000);\n\t\t\tlength = 0;\n\t\t\tcontinue;\n\t\t} else if (length <= 0) {\n\t\t\tcifs_dbg(FYI, \"Received no data or error: expecting %d\\n\"\n\t\t\t\t \"got %d\", to_read, length);\n\t\t\tcifs_reconnect(server);\n\t\t\ttotal_read = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn total_read;\n}\n\nint\ncifs_read_from_socket(struct TCP_Server_Info *server, char *buf,\n\t\t      unsigned int to_read)\n{\n\tstruct kvec iov;\n\n\tiov.iov_base = buf;\n\tiov.iov_len = to_read;\n\n\treturn cifs_readv_from_socket(server, &iov, 1, to_read);\n}\n\nstatic bool\nis_smb_response(struct TCP_Server_Info *server, unsigned char type)\n{\n\t/*\n\t * The first byte big endian of the length field,\n\t * is actually not part of the length but the type\n\t * with the most common, zero, as regular data.\n\t */\n\tswitch (type) {\n\tcase RFC1002_SESSION_MESSAGE:\n\t\t/* Regular SMB response */\n\t\treturn true;\n\tcase RFC1002_SESSION_KEEP_ALIVE:\n\t\tcifs_dbg(FYI, \"RFC 1002 session keep alive\\n\");\n\t\tbreak;\n\tcase RFC1002_POSITIVE_SESSION_RESPONSE:\n\t\tcifs_dbg(FYI, \"RFC 1002 positive session response\\n\");\n\t\tbreak;\n\tcase RFC1002_NEGATIVE_SESSION_RESPONSE:\n\t\t/*\n\t\t * We get this from Windows 98 instead of an error on\n\t\t * SMB negprot response.\n\t\t */\n\t\tcifs_dbg(FYI, \"RFC 1002 negative session response\\n\");\n\t\t/* give server a second to clean up */\n\t\tmsleep(1000);\n\t\t/*\n\t\t * Always try 445 first on reconnect since we get NACK\n\t\t * on some if we ever connected to port 139 (the NACK\n\t\t * is since we do not begin with RFC1001 session\n\t\t * initialize frame).\n\t\t */\n\t\tcifs_set_port((struct sockaddr *)&server->dstaddr, CIFS_PORT);\n\t\tcifs_reconnect(server);\n\t\twake_up(&server->response_q);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"RFC 1002 unknown response type 0x%x\\n\", type);\n\t\tcifs_reconnect(server);\n\t}\n\n\treturn false;\n}\n\nvoid\ndequeue_mid(struct mid_q_entry *mid, bool malformed)\n{\n#ifdef CONFIG_CIFS_STATS2\n\tmid->when_received = jiffies;\n#endif\n\tspin_lock(&GlobalMid_Lock);\n\tif (!malformed)\n\t\tmid->mid_state = MID_RESPONSE_RECEIVED;\n\telse\n\t\tmid->mid_state = MID_RESPONSE_MALFORMED;\n\tlist_del_init(&mid->qhead);\n\tspin_unlock(&GlobalMid_Lock);\n}\n\nstatic void\nhandle_mid(struct mid_q_entry *mid, struct TCP_Server_Info *server,\n\t   char *buf, int malformed)\n{\n\tif (server->ops->check_trans2 &&\n\t    server->ops->check_trans2(mid, server, buf, malformed))\n\t\treturn;\n\tmid->resp_buf = buf;\n\tmid->large_buf = server->large_buf;\n\t/* Was previous buf put in mpx struct for multi-rsp? */\n\tif (!mid->multiRsp) {\n\t\t/* smb buffer will be freed by user thread */\n\t\tif (server->large_buf)\n\t\t\tserver->bigbuf = NULL;\n\t\telse\n\t\t\tserver->smallbuf = NULL;\n\t}\n\tdequeue_mid(mid, malformed);\n}\n\nstatic void clean_demultiplex_info(struct TCP_Server_Info *server)\n{\n\tint length;\n\n\t/* take it off the list, if it's not already */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\twake_up_all(&server->response_q);\n\n\t/* check if we have blocked requests that need to free */\n\tspin_lock(&server->req_lock);\n\tif (server->credits <= 0)\n\t\tserver->credits = 1;\n\tspin_unlock(&server->req_lock);\n\t/*\n\t * Although there should not be any requests blocked on this queue it\n\t * can not hurt to be paranoid and try to wake up requests that may\n\t * haven been blocked when more than 50 at time were on the wire to the\n\t * same server - they now will see the session is in exit state and get\n\t * out of SendReceive.\n\t */\n\twake_up_all(&server->request_q);\n\t/* give those requests time to exit */\n\tmsleep(125);\n\n\tif (server->ssocket) {\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\tstruct list_head dispose_list;\n\t\tstruct mid_q_entry *mid_entry;\n\t\tstruct list_head *tmp, *tmp2;\n\n\t\tINIT_LIST_HEAD(&dispose_list);\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tlist_for_each_safe(tmp, tmp2, &server->pending_mid_q) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\t\tcifs_dbg(FYI, \"Clearing mid 0x%llx\\n\", mid_entry->mid);\n\t\t\tmid_entry->mid_state = MID_SHUTDOWN;\n\t\t\tlist_move(&mid_entry->qhead, &dispose_list);\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\n\t\t/* now walk dispose list and issue callbacks */\n\t\tlist_for_each_safe(tmp, tmp2, &dispose_list) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\t\tcifs_dbg(FYI, \"Callback mid 0x%llx\\n\", mid_entry->mid);\n\t\t\tlist_del_init(&mid_entry->qhead);\n\t\t\tmid_entry->callback(mid_entry);\n\t\t}\n\t\t/* 1/8th of sec is more than enough time for them to exit */\n\t\tmsleep(125);\n\t}\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\t/*\n\t\t * mpx threads have not exited yet give them at least the smb\n\t\t * send timeout time for long ops.\n\t\t *\n\t\t * Due to delays on oplock break requests, we need to wait at\n\t\t * least 45 seconds before giving up on a request getting a\n\t\t * response and going ahead and killing cifsd.\n\t\t */\n\t\tcifs_dbg(FYI, \"Wait for exit from demultiplex thread\\n\");\n\t\tmsleep(46000);\n\t\t/*\n\t\t * If threads still have not exited they are probably never\n\t\t * coming home not much else we can do but free the memory.\n\t\t */\n\t}\n\n\tkfree(server->hostname);\n\tkfree(server->iov);\n\tkfree(server);\n\n\tlength = atomic_dec_return(&tcpSesAllocCount);\n\tif (length > 0)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv,\n\t\t\t\tGFP_KERNEL);\n}\n\nstatic int\nstandard_receive3(struct TCP_Server_Info *server, struct mid_q_entry *mid)\n{\n\tint length;\n\tchar *buf = server->smallbuf;\n\tunsigned int pdu_length = get_rfc1002_length(buf);\n\n\t/* make sure this will fit in a large buffer */\n\tif (pdu_length > CIFSMaxBufSize + MAX_HEADER_SIZE(server) - 4) {\n\t\tcifs_dbg(VFS, \"SMB response too long (%u bytes)\\n\", pdu_length);\n\t\tcifs_reconnect(server);\n\t\twake_up(&server->response_q);\n\t\treturn -EAGAIN;\n\t}\n\n\t/* switch to large buffer if too big for a small one */\n\tif (pdu_length > MAX_CIFS_SMALL_BUFFER_SIZE - 4) {\n\t\tserver->large_buf = true;\n\t\tmemcpy(server->bigbuf, buf, server->total_read);\n\t\tbuf = server->bigbuf;\n\t}\n\n\t/* now read the rest */\n\tlength = cifs_read_from_socket(server, buf + HEADER_SIZE(server) - 1,\n\t\t\t\tpdu_length - HEADER_SIZE(server) + 1 + 4);\n\tif (length < 0)\n\t\treturn length;\n\tserver->total_read += length;\n\n\tdump_smb(buf, server->total_read);\n\n\t/*\n\t * We know that we received enough to get to the MID as we\n\t * checked the pdu_length earlier. Now check to see\n\t * if the rest of the header is OK. We borrow the length\n\t * var for the rest of the loop to avoid a new stack var.\n\t *\n\t * 48 bytes is enough to display the header and a little bit\n\t * into the payload for debugging purposes.\n\t */\n\tlength = server->ops->check_message(buf, server->total_read);\n\tif (length != 0)\n\t\tcifs_dump_mem(\"Bad SMB: \", buf,\n\t\t\tmin_t(unsigned int, server->total_read, 48));\n\n\tif (server->ops->is_status_pending &&\n\t    server->ops->is_status_pending(buf, server, length))\n\t\treturn -1;\n\n\tif (!mid)\n\t\treturn length;\n\n\thandle_mid(mid, server, buf, length);\n\treturn 0;\n}\n\nstatic int\ncifs_demultiplex_thread(void *p)\n{\n\tint length;\n\tstruct TCP_Server_Info *server = p;\n\tunsigned int pdu_length;\n\tchar *buf = NULL;\n\tstruct task_struct *task_to_wake = NULL;\n\tstruct mid_q_entry *mid_entry;\n\n\tcurrent->flags |= PF_MEMALLOC;\n\tcifs_dbg(FYI, \"Demultiplex PID: %d\\n\", task_pid_nr(current));\n\n\tlength = atomic_inc_return(&tcpSesAllocCount);\n\tif (length > 1)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv,\n\t\t\t\tGFP_KERNEL);\n\n\tset_freezable();\n\twhile (server->tcpStatus != CifsExiting) {\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\n\t\tif (!allocate_buffers(server))\n\t\t\tcontinue;\n\n\t\tserver->large_buf = false;\n\t\tbuf = server->smallbuf;\n\t\tpdu_length = 4; /* enough to get RFC1001 header */\n\n\t\tlength = cifs_read_from_socket(server, buf, pdu_length);\n\t\tif (length < 0)\n\t\t\tcontinue;\n\t\tserver->total_read = length;\n\n\t\t/*\n\t\t * The right amount was read from socket - 4 bytes,\n\t\t * so we can now interpret the length field.\n\t\t */\n\t\tpdu_length = get_rfc1002_length(buf);\n\n\t\tcifs_dbg(FYI, \"RFC1002 header 0x%x\\n\", pdu_length);\n\t\tif (!is_smb_response(server, buf[0]))\n\t\t\tcontinue;\n\n\t\t/* make sure we have enough to get to the MID */\n\t\tif (pdu_length < HEADER_SIZE(server) - 1 - 4) {\n\t\t\tcifs_dbg(VFS, \"SMB response too short (%u bytes)\\n\",\n\t\t\t\t pdu_length);\n\t\t\tcifs_reconnect(server);\n\t\t\twake_up(&server->response_q);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* read down to the MID */\n\t\tlength = cifs_read_from_socket(server, buf + 4,\n\t\t\t\t\t       HEADER_SIZE(server) - 1 - 4);\n\t\tif (length < 0)\n\t\t\tcontinue;\n\t\tserver->total_read += length;\n\n\t\tmid_entry = server->ops->find_mid(server, buf);\n\n\t\tif (!mid_entry || !mid_entry->receive)\n\t\t\tlength = standard_receive3(server, mid_entry);\n\t\telse\n\t\t\tlength = mid_entry->receive(server, mid_entry);\n\n\t\tif (length < 0)\n\t\t\tcontinue;\n\n\t\tif (server->large_buf)\n\t\t\tbuf = server->bigbuf;\n\n\t\tserver->lstrp = jiffies;\n\t\tif (mid_entry != NULL) {\n\t\t\tif (!mid_entry->multiRsp || mid_entry->multiEnd)\n\t\t\t\tmid_entry->callback(mid_entry);\n\t\t} else if (!server->ops->is_oplock_break ||\n\t\t\t   !server->ops->is_oplock_break(buf, server)) {\n\t\t\tcifs_dbg(VFS, \"No task to wake, unknown frame received! NumMids %d\\n\",\n\t\t\t\t atomic_read(&midCount));\n\t\t\tcifs_dump_mem(\"Received Data is: \", buf,\n\t\t\t\t      HEADER_SIZE(server));\n#ifdef CONFIG_CIFS_DEBUG2\n\t\t\tif (server->ops->dump_detail)\n\t\t\t\tserver->ops->dump_detail(buf);\n\t\t\tcifs_dump_mids(server);\n#endif /* CIFS_DEBUG2 */\n\n\t\t}\n\t} /* end while !EXITING */\n\n\t/* buffer usually freed in free_mid - need to free it here on exit */\n\tcifs_buf_release(server->bigbuf);\n\tif (server->smallbuf) /* no sense logging a debug message if NULL */\n\t\tcifs_small_buf_release(server->smallbuf);\n\n\ttask_to_wake = xchg(&server->tsk, NULL);\n\tclean_demultiplex_info(server);\n\n\t/* if server->tsk was NULL then wait for a signal before exiting */\n\tif (!task_to_wake) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\twhile (!signal_pending(current)) {\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t}\n\t\tset_current_state(TASK_RUNNING);\n\t}\n\n\tmodule_put_and_exit(0);\n}\n\n/* extract the host portion of the UNC string */\nstatic char *\nextract_hostname(const char *unc)\n{\n\tconst char *src;\n\tchar *dst, *delim;\n\tunsigned int len;\n\n\t/* skip double chars at beginning of string */\n\t/* BB: check validity of these bytes? */\n\tsrc = unc + 2;\n\n\t/* delimiter between hostname and sharename is always '\\\\' now */\n\tdelim = strchr(src, '\\\\');\n\tif (!delim)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlen = delim - src;\n\tdst = kmalloc((len + 1), GFP_KERNEL);\n\tif (dst == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(dst, src, len);\n\tdst[len] = '\\0';\n\n\treturn dst;\n}\n\nstatic int get_option_ul(substring_t args[], unsigned long *option)\n{\n\tint rc;\n\tchar *string;\n\n\tstring = match_strdup(args);\n\tif (string == NULL)\n\t\treturn -ENOMEM;\n\trc = kstrtoul(string, 0, option);\n\tkfree(string);\n\n\treturn rc;\n}\n\nstatic int get_option_uid(substring_t args[], kuid_t *result)\n{\n\tunsigned long value;\n\tkuid_t uid;\n\tint rc;\n\n\trc = get_option_ul(args, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tuid = make_kuid(current_user_ns(), value);\n\tif (!uid_valid(uid))\n\t\treturn -EINVAL;\n\n\t*result = uid;\n\treturn 0;\n}\n\nstatic int get_option_gid(substring_t args[], kgid_t *result)\n{\n\tunsigned long value;\n\tkgid_t gid;\n\tint rc;\n\n\trc = get_option_ul(args, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tgid = make_kgid(current_user_ns(), value);\n\tif (!gid_valid(gid))\n\t\treturn -EINVAL;\n\n\t*result = gid;\n\treturn 0;\n}\n\nstatic int cifs_parse_security_flavors(char *value,\n\t\t\t\t       struct smb_vol *vol)\n{\n\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tswitch (match_token(value, cifs_secflavor_tokens, args)) {\n\tcase Opt_sec_krb5:\n\t\tvol->secFlg |= CIFSSEC_MAY_KRB5 | CIFSSEC_MAY_SIGN;\n\t\tbreak;\n\tcase Opt_sec_krb5i:\n\t\tvol->secFlg |= CIFSSEC_MAY_KRB5 | CIFSSEC_MUST_SIGN;\n\t\tbreak;\n\tcase Opt_sec_krb5p:\n\t\t/* vol->secFlg |= CIFSSEC_MUST_SEAL | CIFSSEC_MAY_KRB5; */\n\t\tcifs_dbg(VFS, \"Krb5 cifs privacy not supported\\n\");\n\t\tbreak;\n\tcase Opt_sec_ntlmssp:\n\t\tvol->secFlg |= CIFSSEC_MAY_NTLMSSP;\n\t\tbreak;\n\tcase Opt_sec_ntlmsspi:\n\t\tvol->secFlg |= CIFSSEC_MAY_NTLMSSP | CIFSSEC_MUST_SIGN;\n\t\tbreak;\n\tcase Opt_ntlm:\n\t\t/* ntlm is default so can be turned off too */\n\t\tvol->secFlg |= CIFSSEC_MAY_NTLM;\n\t\tbreak;\n\tcase Opt_sec_ntlmi:\n\t\tvol->secFlg |= CIFSSEC_MAY_NTLM | CIFSSEC_MUST_SIGN;\n\t\tbreak;\n\tcase Opt_sec_ntlmv2:\n\t\tvol->secFlg |= CIFSSEC_MAY_NTLMV2;\n\t\tbreak;\n\tcase Opt_sec_ntlmv2i:\n\t\tvol->secFlg |= CIFSSEC_MAY_NTLMV2 | CIFSSEC_MUST_SIGN;\n\t\tbreak;\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\tcase Opt_sec_lanman:\n\t\tvol->secFlg |= CIFSSEC_MAY_LANMAN;\n\t\tbreak;\n#endif\n\tcase Opt_sec_none:\n\t\tvol->nullauth = 1;\n\t\tvol->secFlg |= CIFSSEC_MAY_NTLM;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"bad security option: %s\\n\", value);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ncifs_parse_cache_flavor(char *value, struct smb_vol *vol)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tswitch (match_token(value, cifs_cacheflavor_tokens, args)) {\n\tcase Opt_cache_loose:\n\t\tvol->direct_io = false;\n\t\tvol->strict_io = false;\n\t\tbreak;\n\tcase Opt_cache_strict:\n\t\tvol->direct_io = false;\n\t\tvol->strict_io = true;\n\t\tbreak;\n\tcase Opt_cache_none:\n\t\tvol->direct_io = true;\n\t\tvol->strict_io = false;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"bad cache= option: %s\\n\", value);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\ncifs_parse_smb_version(char *value, struct smb_vol *vol)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\tswitch (match_token(value, cifs_smb_version_tokens, args)) {\n\tcase Smb_1:\n\t\tvol->ops = &smb1_operations;\n\t\tvol->vals = &smb1_values;\n\t\tbreak;\n#ifdef CONFIG_CIFS_SMB2\n\tcase Smb_20:\n\t\tvol->ops = &smb21_operations; /* currently identical with 2.1 */\n\t\tvol->vals = &smb20_values;\n\t\tbreak;\n\tcase Smb_21:\n\t\tvol->ops = &smb21_operations;\n\t\tvol->vals = &smb21_values;\n\t\tbreak;\n\tcase Smb_30:\n\t\tvol->ops = &smb30_operations;\n\t\tvol->vals = &smb30_values;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tcifs_dbg(VFS, \"Unknown vers= option specified: %s\\n\", value);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Parse a devname into substrings and populate the vol->UNC and vol->prepath\n * fields with the result. Returns 0 on success and an error otherwise.\n */\nstatic int\ncifs_parse_devname(const char *devname, struct smb_vol *vol)\n{\n\tchar *pos;\n\tconst char *delims = \"/\\\\\";\n\tsize_t len;\n\n\t/* make sure we have a valid UNC double delimiter prefix */\n\tlen = strspn(devname, delims);\n\tif (len != 2)\n\t\treturn -EINVAL;\n\n\t/* find delimiter between host and sharename */\n\tpos = strpbrk(devname + 2, delims);\n\tif (!pos)\n\t\treturn -EINVAL;\n\n\t/* skip past delimiter */\n\t++pos;\n\n\t/* now go until next delimiter or end of string */\n\tlen = strcspn(pos, delims);\n\n\t/* move \"pos\" up to delimiter or NULL */\n\tpos += len;\n\tvol->UNC = kstrndup(devname, pos - devname, GFP_KERNEL);\n\tif (!vol->UNC)\n\t\treturn -ENOMEM;\n\n\tconvert_delimiter(vol->UNC, '\\\\');\n\n\t/* If pos is NULL, or is a bogus trailing delimiter then no prepath */\n\tif (!*pos++ || !*pos)\n\t\treturn 0;\n\n\tvol->prepath = kstrdup(pos, GFP_KERNEL);\n\tif (!vol->prepath)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int\ncifs_parse_mount_options(const char *mountdata, const char *devname,\n\t\t\t struct smb_vol *vol)\n{\n\tchar *data, *end;\n\tchar *mountdata_copy = NULL, *options;\n\tunsigned int  temp_len, i, j;\n\tchar separator[2];\n\tshort int override_uid = -1;\n\tshort int override_gid = -1;\n\tbool uid_specified = false;\n\tbool gid_specified = false;\n\tbool sloppy = false;\n\tchar *invalid = NULL;\n\tchar *nodename = utsname()->nodename;\n\tchar *string = NULL;\n\tchar *tmp_end, *value;\n\tchar delim;\n\tbool got_ip = false;\n\tunsigned short port = 0;\n\tstruct sockaddr *dstaddr = (struct sockaddr *)&vol->dstaddr;\n\n\tseparator[0] = ',';\n\tseparator[1] = 0;\n\tdelim = separator[0];\n\n\t/* ensure we always start with zeroed-out smb_vol */\n\tmemset(vol, 0, sizeof(*vol));\n\n\t/*\n\t * does not have to be perfect mapping since field is\n\t * informational, only used for servers that do not support\n\t * port 445 and it can be overridden at mount time\n\t */\n\tmemset(vol->source_rfc1001_name, 0x20, RFC1001_NAME_LEN);\n\tfor (i = 0; i < strnlen(nodename, RFC1001_NAME_LEN); i++)\n\t\tvol->source_rfc1001_name[i] = toupper(nodename[i]);\n\n\tvol->source_rfc1001_name[RFC1001_NAME_LEN] = 0;\n\t/* null target name indicates to use *SMBSERVR default called name\n\t   if we end up sending RFC1001 session initialize */\n\tvol->target_rfc1001_name[0] = 0;\n\tvol->cred_uid = current_uid();\n\tvol->linux_uid = current_uid();\n\tvol->linux_gid = current_gid();\n\n\t/* default to only allowing write access to owner of the mount */\n\tvol->dir_mode = vol->file_mode = S_IRUGO | S_IXUGO | S_IWUSR;\n\n\t/* vol->retry default is 0 (i.e. \"soft\" limited retry not hard retry) */\n\t/* default is always to request posix paths. */\n\tvol->posix_paths = 1;\n\t/* default to using server inode numbers where available */\n\tvol->server_ino = 1;\n\n\t/* default is to use strict cifs caching semantics */\n\tvol->strict_io = true;\n\n\tvol->actimeo = CIFS_DEF_ACTIMEO;\n\n\t/* FIXME: add autonegotiation -- for now, SMB1 is default */\n\tvol->ops = &smb1_operations;\n\tvol->vals = &smb1_values;\n\n\tif (!mountdata)\n\t\tgoto cifs_parse_mount_err;\n\n\tmountdata_copy = kstrndup(mountdata, PAGE_SIZE, GFP_KERNEL);\n\tif (!mountdata_copy)\n\t\tgoto cifs_parse_mount_err;\n\n\toptions = mountdata_copy;\n\tend = options + strlen(options);\n\n\tif (strncmp(options, \"sep=\", 4) == 0) {\n\t\tif (options[4] != 0) {\n\t\t\tseparator[0] = options[4];\n\t\t\toptions += 5;\n\t\t} else {\n\t\t\tcifs_dbg(FYI, \"Null separator not allowed\\n\");\n\t\t}\n\t}\n\tvol->backupuid_specified = false; /* no backup intent for a user */\n\tvol->backupgid_specified = false; /* no backup intent for a group */\n\n\tswitch (cifs_parse_devname(devname, vol)) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOMEM:\n\t\tcifs_dbg(VFS, \"Unable to allocate memory for devname.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\tcase -EINVAL:\n\t\tcifs_dbg(VFS, \"Malformed UNC in devname.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\tdefault:\n\t\tcifs_dbg(VFS, \"Unknown error parsing devname.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n\twhile ((data = strsep(&options, separator)) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tunsigned long option;\n\t\tint token;\n\n\t\tif (!*data)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(data, cifs_mount_option_tokens, args);\n\n\t\tswitch (token) {\n\n\t\t/* Ingnore the following */\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\n\t\t/* Boolean values */\n\t\tcase Opt_user_xattr:\n\t\t\tvol->no_xattr = 0;\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tvol->no_xattr = 1;\n\t\t\tbreak;\n\t\tcase Opt_forceuid:\n\t\t\toverride_uid = 1;\n\t\t\tbreak;\n\t\tcase Opt_noforceuid:\n\t\t\toverride_uid = 0;\n\t\t\tbreak;\n\t\tcase Opt_forcegid:\n\t\t\toverride_gid = 1;\n\t\t\tbreak;\n\t\tcase Opt_noforcegid:\n\t\t\toverride_gid = 0;\n\t\t\tbreak;\n\t\tcase Opt_noblocksend:\n\t\t\tvol->noblocksnd = 1;\n\t\t\tbreak;\n\t\tcase Opt_noautotune:\n\t\t\tvol->noautotune = 1;\n\t\t\tbreak;\n\t\tcase Opt_hard:\n\t\t\tvol->retry = 1;\n\t\t\tbreak;\n\t\tcase Opt_soft:\n\t\t\tvol->retry = 0;\n\t\t\tbreak;\n\t\tcase Opt_perm:\n\t\t\tvol->noperm = 0;\n\t\t\tbreak;\n\t\tcase Opt_noperm:\n\t\t\tvol->noperm = 1;\n\t\t\tbreak;\n\t\tcase Opt_mapchars:\n\t\t\tvol->remap = 1;\n\t\t\tbreak;\n\t\tcase Opt_nomapchars:\n\t\t\tvol->remap = 0;\n\t\t\tbreak;\n\t\tcase Opt_sfu:\n\t\t\tvol->sfu_emul = 1;\n\t\t\tbreak;\n\t\tcase Opt_nosfu:\n\t\t\tvol->sfu_emul = 0;\n\t\t\tbreak;\n\t\tcase Opt_nodfs:\n\t\t\tvol->nodfs = 1;\n\t\t\tbreak;\n\t\tcase Opt_posixpaths:\n\t\t\tvol->posix_paths = 1;\n\t\t\tbreak;\n\t\tcase Opt_noposixpaths:\n\t\t\tvol->posix_paths = 0;\n\t\t\tbreak;\n\t\tcase Opt_nounix:\n\t\t\tvol->no_linux_ext = 1;\n\t\t\tbreak;\n\t\tcase Opt_nocase:\n\t\t\tvol->nocase = 1;\n\t\t\tbreak;\n\t\tcase Opt_brl:\n\t\t\tvol->nobrl =  0;\n\t\t\tbreak;\n\t\tcase Opt_nobrl:\n\t\t\tvol->nobrl =  1;\n\t\t\t/*\n\t\t\t * turn off mandatory locking in mode\n\t\t\t * if remote locking is turned off since the\n\t\t\t * local vfs will do advisory\n\t\t\t */\n\t\t\tif (vol->file_mode ==\n\t\t\t\t(S_IALLUGO & ~(S_ISUID | S_IXGRP)))\n\t\t\t\tvol->file_mode = S_IALLUGO;\n\t\t\tbreak;\n\t\tcase Opt_forcemandatorylock:\n\t\t\tvol->mand_lock = 1;\n\t\t\tbreak;\n\t\tcase Opt_setuids:\n\t\t\tvol->setuids = 1;\n\t\t\tbreak;\n\t\tcase Opt_nosetuids:\n\t\t\tvol->setuids = 0;\n\t\t\tbreak;\n\t\tcase Opt_dynperm:\n\t\t\tvol->dynperm = true;\n\t\t\tbreak;\n\t\tcase Opt_nodynperm:\n\t\t\tvol->dynperm = false;\n\t\t\tbreak;\n\t\tcase Opt_nohard:\n\t\t\tvol->retry = 0;\n\t\t\tbreak;\n\t\tcase Opt_nosoft:\n\t\t\tvol->retry = 1;\n\t\t\tbreak;\n\t\tcase Opt_nointr:\n\t\t\tvol->intr = 0;\n\t\t\tbreak;\n\t\tcase Opt_intr:\n\t\t\tvol->intr = 1;\n\t\t\tbreak;\n\t\tcase Opt_nostrictsync:\n\t\t\tvol->nostrictsync = 1;\n\t\t\tbreak;\n\t\tcase Opt_strictsync:\n\t\t\tvol->nostrictsync = 0;\n\t\t\tbreak;\n\t\tcase Opt_serverino:\n\t\t\tvol->server_ino = 1;\n\t\t\tbreak;\n\t\tcase Opt_noserverino:\n\t\t\tvol->server_ino = 0;\n\t\t\tbreak;\n\t\tcase Opt_rwpidforward:\n\t\t\tvol->rwpidforward = 1;\n\t\t\tbreak;\n\t\tcase Opt_cifsacl:\n\t\t\tvol->cifs_acl = 1;\n\t\t\tbreak;\n\t\tcase Opt_nocifsacl:\n\t\t\tvol->cifs_acl = 0;\n\t\t\tbreak;\n\t\tcase Opt_acl:\n\t\t\tvol->no_psx_acl = 0;\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tvol->no_psx_acl = 1;\n\t\t\tbreak;\n\t\tcase Opt_locallease:\n\t\t\tvol->local_lease = 1;\n\t\t\tbreak;\n\t\tcase Opt_sign:\n\t\t\tvol->secFlg |= CIFSSEC_MUST_SIGN;\n\t\t\tbreak;\n\t\tcase Opt_seal:\n\t\t\t/* we do not do the following in secFlags because seal\n\t\t\t * is a per tree connection (mount) not a per socket\n\t\t\t * or per-smb connection option in the protocol\n\t\t\t * vol->secFlg |= CIFSSEC_MUST_SEAL;\n\t\t\t */\n\t\t\tvol->seal = 1;\n\t\t\tbreak;\n\t\tcase Opt_noac:\n\t\t\tprintk(KERN_WARNING \"CIFS: Mount option noac not \"\n\t\t\t\t\"supported. Instead set \"\n\t\t\t\t\"/proc/fs/cifs/LookupCacheEnabled to 0\\n\");\n\t\t\tbreak;\n\t\tcase Opt_fsc:\n#ifndef CONFIG_CIFS_FSCACHE\n\t\t\tcifs_dbg(VFS, \"FS-Cache support needs CONFIG_CIFS_FSCACHE kernel config option set\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n#endif\n\t\t\tvol->fsc = true;\n\t\t\tbreak;\n\t\tcase Opt_mfsymlinks:\n\t\t\tvol->mfsymlinks = true;\n\t\t\tbreak;\n\t\tcase Opt_multiuser:\n\t\t\tvol->multiuser = true;\n\t\t\tbreak;\n\t\tcase Opt_sloppy:\n\t\t\tsloppy = true;\n\t\t\tbreak;\n\n\t\t/* Numeric Values */\n\t\tcase Opt_backupuid:\n\t\t\tif (get_option_uid(args, &vol->backupuid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid backupuid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->backupuid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_backupgid:\n\t\t\tif (get_option_gid(args, &vol->backupgid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid backupgid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->backupgid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (get_option_uid(args, &vol->linux_uid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid uid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tuid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_cruid:\n\t\t\tif (get_option_uid(args, &vol->cred_uid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid cruid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (get_option_gid(args, &vol->linux_gid)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid gid value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tgid_specified = true;\n\t\t\tbreak;\n\t\tcase Opt_file_mode:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid file_mode value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->file_mode = option;\n\t\t\tbreak;\n\t\tcase Opt_dirmode:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid dir_mode value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->dir_mode = option;\n\t\t\tbreak;\n\t\tcase Opt_port:\n\t\t\tif (get_option_ul(args, &option) ||\n\t\t\t    option > USHRT_MAX) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid port value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tport = (unsigned short)option;\n\t\t\tbreak;\n\t\tcase Opt_rsize:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid rsize value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->rsize = option;\n\t\t\tbreak;\n\t\tcase Opt_wsize:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid wsize value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->wsize = option;\n\t\t\tbreak;\n\t\tcase Opt_actimeo:\n\t\t\tif (get_option_ul(args, &option)) {\n\t\t\t\tcifs_dbg(VFS, \"%s: Invalid actimeo value\\n\",\n\t\t\t\t\t __func__);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->actimeo = HZ * option;\n\t\t\tif (vol->actimeo > CIFS_MAX_ACTIMEO) {\n\t\t\t\tcifs_dbg(VFS, \"attribute cache timeout too large\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* String Arguments */\n\n\t\tcase Opt_blank_user:\n\t\t\t/* null user, ie. anonymous authentication */\n\t\t\tvol->nullauth = 1;\n\t\t\tvol->username = NULL;\n\t\t\tbreak;\n\t\tcase Opt_user:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strnlen(string, MAX_USERNAME_SIZE) >\n\t\t\t\t\t\t\tMAX_USERNAME_SIZE) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: username too long\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tvol->username = kstrdup(string, GFP_KERNEL);\n\t\t\tif (!vol->username)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tcase Opt_blank_pass:\n\t\t\t/* passwords have to be handled differently\n\t\t\t * to allow the character used for deliminator\n\t\t\t * to be passed within them\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * Check if this is a case where the  password\n\t\t\t * starts with a delimiter\n\t\t\t */\n\t\t\ttmp_end = strchr(data, '=');\n\t\t\ttmp_end++;\n\t\t\tif (!(tmp_end < end && tmp_end[1] == delim)) {\n\t\t\t\t/* No it is not. Set the password to NULL */\n\t\t\t\tvol->password = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Yes it is. Drop down to Opt_pass below.*/\n\t\tcase Opt_pass:\n\t\t\t/* Obtain the value string */\n\t\t\tvalue = strchr(data, '=');\n\t\t\tvalue++;\n\n\t\t\t/* Set tmp_end to end of the string */\n\t\t\ttmp_end = (char *) value + strlen(value);\n\n\t\t\t/* Check if following character is the deliminator\n\t\t\t * If yes, we have encountered a double deliminator\n\t\t\t * reset the NULL character to the deliminator\n\t\t\t */\n\t\t\tif (tmp_end < end && tmp_end[1] == delim) {\n\t\t\t\ttmp_end[0] = delim;\n\n\t\t\t\t/* Keep iterating until we get to a single\n\t\t\t\t * deliminator OR the end\n\t\t\t\t */\n\t\t\t\twhile ((tmp_end = strchr(tmp_end, delim))\n\t\t\t\t\t!= NULL && (tmp_end[1] == delim)) {\n\t\t\t\t\t\ttmp_end = (char *) &tmp_end[2];\n\t\t\t\t}\n\n\t\t\t\t/* Reset var options to point to next element */\n\t\t\t\tif (tmp_end) {\n\t\t\t\t\ttmp_end[0] = '\\0';\n\t\t\t\t\toptions = (char *) &tmp_end[1];\n\t\t\t\t} else\n\t\t\t\t\t/* Reached the end of the mount option\n\t\t\t\t\t * string */\n\t\t\t\t\toptions = end;\n\t\t\t}\n\n\t\t\t/* Now build new password string */\n\t\t\ttemp_len = strlen(value);\n\t\t\tvol->password = kzalloc(temp_len+1, GFP_KERNEL);\n\t\t\tif (vol->password == NULL) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: no memory \"\n\t\t\t\t\t\t    \"for password\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\n\t\t\tfor (i = 0, j = 0; i < temp_len; i++, j++) {\n\t\t\t\tvol->password[j] = value[i];\n\t\t\t\tif ((value[i] == delim) &&\n\t\t\t\t     value[i+1] == delim)\n\t\t\t\t\t/* skip the second deliminator */\n\t\t\t\t\ti++;\n\t\t\t}\n\t\t\tvol->password[j] = '\\0';\n\t\t\tbreak;\n\t\tcase Opt_blank_ip:\n\t\t\t/* FIXME: should this be an error instead? */\n\t\t\tgot_ip = false;\n\t\t\tbreak;\n\t\tcase Opt_ip:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (!cifs_convert_address(dstaddr, string,\n\t\t\t\t\tstrlen(string))) {\n\t\t\t\tprintk(KERN_ERR \"CIFS: bad ip= option (%s).\\n\",\n\t\t\t\t\tstring);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tgot_ip = true;\n\t\t\tbreak;\n\t\tcase Opt_domain:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strnlen(string, 256) == 256) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: domain name too\"\n\t\t\t\t\t\t    \" long\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\n\t\t\tvol->domainname = kstrdup(string, GFP_KERNEL);\n\t\t\tif (!vol->domainname) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: no memory \"\n\t\t\t\t\t\t    \"for domainname\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tcifs_dbg(FYI, \"Domain name set\\n\");\n\t\t\tbreak;\n\t\tcase Opt_srcaddr:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (!cifs_convert_address(\n\t\t\t\t\t(struct sockaddr *)&vol->srcaddr,\n\t\t\t\t\tstring, strlen(string))) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS:  Could not parse\"\n\t\t\t\t\t\t    \" srcaddr: %s\\n\", string);\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_iocharset:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strnlen(string, 1024) >= 65) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: iocharset name \"\n\t\t\t\t\t\t    \"too long.\\n\");\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t}\n\n\t\t\t if (strnicmp(string, \"default\", 7) != 0) {\n\t\t\t\tvol->iocharset = kstrdup(string,\n\t\t\t\t\t\t\t GFP_KERNEL);\n\t\t\t\tif (!vol->iocharset) {\n\t\t\t\t\tprintk(KERN_WARNING \"CIFS: no memory\"\n\t\t\t\t\t\t\t    \"for charset\\n\");\n\t\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* if iocharset not set then load_nls_default\n\t\t\t * is used by caller\n\t\t\t */\n\t\t\t cifs_dbg(FYI, \"iocharset set to %s\\n\", string);\n\t\t\tbreak;\n\t\tcase Opt_netbiosname:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tmemset(vol->source_rfc1001_name, 0x20,\n\t\t\t\tRFC1001_NAME_LEN);\n\t\t\t/*\n\t\t\t * FIXME: are there cases in which a comma can\n\t\t\t * be valid in workstation netbios name (and\n\t\t\t * need special handling)?\n\t\t\t */\n\t\t\tfor (i = 0; i < RFC1001_NAME_LEN; i++) {\n\t\t\t\t/* don't ucase netbiosname for user */\n\t\t\t\tif (string[i] == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tvol->source_rfc1001_name[i] = string[i];\n\t\t\t}\n\t\t\t/* The string has 16th byte zero still from\n\t\t\t * set at top of the function\n\t\t\t */\n\t\t\tif (i == RFC1001_NAME_LEN && string[i] != 0)\n\t\t\t\tprintk(KERN_WARNING \"CIFS: netbiosname\"\n\t\t\t\t       \" longer than 15 truncated.\\n\");\n\n\t\t\tbreak;\n\t\tcase Opt_servern:\n\t\t\t/* servernetbiosname specified override *SMBSERVER */\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\t/* last byte, type, is 0x20 for servr type */\n\t\t\tmemset(vol->target_rfc1001_name, 0x20,\n\t\t\t\tRFC1001_NAME_LEN_WITH_NULL);\n\n\t\t\t/* BB are there cases in which a comma can be\n\t\t\t   valid in this workstation netbios name\n\t\t\t   (and need special handling)? */\n\n\t\t\t/* user or mount helper must uppercase the\n\t\t\t   netbios name */\n\t\t\tfor (i = 0; i < 15; i++) {\n\t\t\t\tif (string[i] == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tvol->target_rfc1001_name[i] = string[i];\n\t\t\t}\n\t\t\t/* The string has 16th byte zero still from\n\t\t\t   set at top of the function  */\n\t\t\tif (i == RFC1001_NAME_LEN && string[i] != 0)\n\t\t\t\tprintk(KERN_WARNING \"CIFS: server net\"\n\t\t\t\t       \"biosname longer than 15 truncated.\\n\");\n\t\t\tbreak;\n\t\tcase Opt_ver:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (strnicmp(string, \"1\", 1) == 0) {\n\t\t\t\t/* This is the default */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* For all other value, error */\n\t\t\tprintk(KERN_WARNING \"CIFS: Invalid version\"\n\t\t\t\t\t    \" specified\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\tcase Opt_vers:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (cifs_parse_smb_version(string, vol) != 0)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tcase Opt_sec:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (cifs_parse_security_flavors(string, vol) != 0)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tcase Opt_cache:\n\t\t\tstring = match_strdup(args);\n\t\t\tif (string == NULL)\n\t\t\t\tgoto out_nomem;\n\n\t\t\tif (cifs_parse_cache_flavor(string, vol) != 0)\n\t\t\t\tgoto cifs_parse_mount_err;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * An option we don't recognize. Save it off for later\n\t\t\t * if we haven't already found one\n\t\t\t */\n\t\t\tif (!invalid)\n\t\t\t\tinvalid = data;\n\t\t\tbreak;\n\t\t}\n\t\t/* Free up any allocated string */\n\t\tkfree(string);\n\t\tstring = NULL;\n\t}\n\n\tif (!sloppy && invalid) {\n\t\tprintk(KERN_ERR \"CIFS: Unknown mount option \\\"%s\\\"\\n\", invalid);\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n#ifndef CONFIG_KEYS\n\t/* Muliuser mounts require CONFIG_KEYS support */\n\tif (vol->multiuser) {\n\t\tcifs_dbg(VFS, \"Multiuser mounts require kernels with CONFIG_KEYS enabled\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n#endif\n\tif (!vol->UNC) {\n\t\tcifs_dbg(VFS, \"CIFS mount error: No usable UNC path provided in device string!\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n\t/* make sure UNC has a share name */\n\tif (!strchr(vol->UNC + 3, '\\\\')) {\n\t\tcifs_dbg(VFS, \"Malformed UNC. Unable to find share name.\\n\");\n\t\tgoto cifs_parse_mount_err;\n\t}\n\n\tif (!got_ip) {\n\t\t/* No ip= option specified? Try to get it from UNC */\n\t\tif (!cifs_convert_address(dstaddr, &vol->UNC[2],\n\t\t\t\t\t\tstrlen(&vol->UNC[2]))) {\n\t\t\tprintk(KERN_ERR \"Unable to determine destination \"\n\t\t\t\t\t\"address.\\n\");\n\t\t\tgoto cifs_parse_mount_err;\n\t\t}\n\t}\n\n\t/* set the port that we got earlier */\n\tcifs_set_port(dstaddr, port);\n\n\tif (uid_specified)\n\t\tvol->override_uid = override_uid;\n\telse if (override_uid == 1)\n\t\tprintk(KERN_NOTICE \"CIFS: ignoring forceuid mount option \"\n\t\t\t\t   \"specified with no uid= option.\\n\");\n\n\tif (gid_specified)\n\t\tvol->override_gid = override_gid;\n\telse if (override_gid == 1)\n\t\tprintk(KERN_NOTICE \"CIFS: ignoring forcegid mount option \"\n\t\t\t\t   \"specified with no gid= option.\\n\");\n\n\tkfree(mountdata_copy);\n\treturn 0;\n\nout_nomem:\n\tprintk(KERN_WARNING \"Could not allocate temporary buffer\\n\");\ncifs_parse_mount_err:\n\tkfree(string);\n\tkfree(mountdata_copy);\n\treturn 1;\n}\n\n/** Returns true if srcaddr isn't specified and rhs isn't\n * specified, or if srcaddr is specified and\n * matches the IP address of the rhs argument.\n */\nstatic bool\nsrcip_matches(struct sockaddr *srcaddr, struct sockaddr *rhs)\n{\n\tswitch (srcaddr->sa_family) {\n\tcase AF_UNSPEC:\n\t\treturn (rhs->sa_family == AF_UNSPEC);\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *saddr4 = (struct sockaddr_in *)srcaddr;\n\t\tstruct sockaddr_in *vaddr4 = (struct sockaddr_in *)rhs;\n\t\treturn (saddr4->sin_addr.s_addr == vaddr4->sin_addr.s_addr);\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *saddr6 = (struct sockaddr_in6 *)srcaddr;\n\t\tstruct sockaddr_in6 *vaddr6 = (struct sockaddr_in6 *)rhs;\n\t\treturn ipv6_addr_equal(&saddr6->sin6_addr, &vaddr6->sin6_addr);\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false; /* don't expect to be here */\n\t}\n}\n\n/*\n * If no port is specified in addr structure, we try to match with 445 port\n * and if it fails - with 139 ports. It should be called only if address\n * families of server and addr are equal.\n */\nstatic bool\nmatch_port(struct TCP_Server_Info *server, struct sockaddr *addr)\n{\n\t__be16 port, *sport;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tsport = &((struct sockaddr_in *) &server->dstaddr)->sin_port;\n\t\tport = ((struct sockaddr_in *) addr)->sin_port;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsport = &((struct sockaddr_in6 *) &server->dstaddr)->sin6_port;\n\t\tport = ((struct sockaddr_in6 *) addr)->sin6_port;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false;\n\t}\n\n\tif (!port) {\n\t\tport = htons(CIFS_PORT);\n\t\tif (port == *sport)\n\t\t\treturn true;\n\n\t\tport = htons(RFC1001_PORT);\n\t}\n\n\treturn port == *sport;\n}\n\nstatic bool\nmatch_address(struct TCP_Server_Info *server, struct sockaddr *addr,\n\t      struct sockaddr *srcaddr)\n{\n\tswitch (addr->sa_family) {\n\tcase AF_INET: {\n\t\tstruct sockaddr_in *addr4 = (struct sockaddr_in *)addr;\n\t\tstruct sockaddr_in *srv_addr4 =\n\t\t\t\t\t(struct sockaddr_in *)&server->dstaddr;\n\n\t\tif (addr4->sin_addr.s_addr != srv_addr4->sin_addr.s_addr)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\tcase AF_INET6: {\n\t\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)addr;\n\t\tstruct sockaddr_in6 *srv_addr6 =\n\t\t\t\t\t(struct sockaddr_in6 *)&server->dstaddr;\n\n\t\tif (!ipv6_addr_equal(&addr6->sin6_addr,\n\t\t\t\t     &srv_addr6->sin6_addr))\n\t\t\treturn false;\n\t\tif (addr6->sin6_scope_id != srv_addr6->sin6_scope_id)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false; /* don't expect to be here */\n\t}\n\n\tif (!srcip_matches(srcaddr, (struct sockaddr *)&server->srcaddr))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nmatch_security(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tunsigned int secFlags;\n\n\tif (vol->secFlg & (~(CIFSSEC_MUST_SIGN | CIFSSEC_MUST_SEAL)))\n\t\tsecFlags = vol->secFlg;\n\telse\n\t\tsecFlags = global_secflags | vol->secFlg;\n\n\tswitch (server->secType) {\n\tcase LANMAN:\n\t\tif (!(secFlags & (CIFSSEC_MAY_LANMAN|CIFSSEC_MAY_PLNTXT)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase NTLMv2:\n\t\tif (!(secFlags & CIFSSEC_MAY_NTLMV2))\n\t\t\treturn false;\n\t\tbreak;\n\tcase NTLM:\n\t\tif (!(secFlags & CIFSSEC_MAY_NTLM))\n\t\t\treturn false;\n\t\tbreak;\n\tcase Kerberos:\n\t\tif (!(secFlags & CIFSSEC_MAY_KRB5))\n\t\t\treturn false;\n\t\tbreak;\n\tcase RawNTLMSSP:\n\t\tif (!(secFlags & CIFSSEC_MAY_NTLMSSP))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\t/* shouldn't happen */\n\t\treturn false;\n\t}\n\n\t/* now check if signing mode is acceptable */\n\tif ((secFlags & CIFSSEC_MAY_SIGN) == 0 &&\n\t    (server->sec_mode & SECMODE_SIGN_REQUIRED))\n\t\t\treturn false;\n\telse if (((secFlags & CIFSSEC_MUST_SIGN) == CIFSSEC_MUST_SIGN) &&\n\t\t (server->sec_mode &\n\t\t  (SECMODE_SIGN_ENABLED|SECMODE_SIGN_REQUIRED)) == 0)\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic int match_server(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tstruct sockaddr *addr = (struct sockaddr *)&vol->dstaddr;\n\n\tif ((server->vals != vol->vals) || (server->ops != vol->ops))\n\t\treturn 0;\n\n\tif (!net_eq(cifs_net_ns(server), current->nsproxy->net_ns))\n\t\treturn 0;\n\n\tif (!match_address(server, addr,\n\t\t\t   (struct sockaddr *)&vol->srcaddr))\n\t\treturn 0;\n\n\tif (!match_port(server, addr))\n\t\treturn 0;\n\n\tif (!match_security(server, vol))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic struct TCP_Server_Info *\ncifs_find_tcp_session(struct smb_vol *vol)\n{\n\tstruct TCP_Server_Info *server;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {\n\t\tif (!match_server(server, vol))\n\t\t\tcontinue;\n\n\t\t++server->srv_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\tcifs_dbg(FYI, \"Existing tcp session with server found\\n\");\n\t\treturn server;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nstatic void\ncifs_put_tcp_session(struct TCP_Server_Info *server)\n{\n\tstruct task_struct *task;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tput_net(cifs_net_ns(server));\n\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcancel_delayed_work_sync(&server->echo);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_crypto_shash_release(server);\n\tcifs_fscache_release_client_cookie(server);\n\n\tkfree(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tforce_sig(SIGKILL, task);\n}\n\nstatic struct TCP_Server_Info *\ncifs_get_tcp_session(struct smb_vol *volume_info)\n{\n\tstruct TCP_Server_Info *tcp_ses = NULL;\n\tint rc;\n\n\tcifs_dbg(FYI, \"UNC: %s\\n\", volume_info->UNC);\n\n\t/* see if we already have a matching tcp_ses */\n\ttcp_ses = cifs_find_tcp_session(volume_info);\n\tif (tcp_ses)\n\t\treturn tcp_ses;\n\n\ttcp_ses = kzalloc(sizeof(struct TCP_Server_Info), GFP_KERNEL);\n\tif (!tcp_ses) {\n\t\trc = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\trc = cifs_crypto_shash_allocate(tcp_ses);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"could not setup hash structures rc %d\\n\", rc);\n\t\tgoto out_err;\n\t}\n\n\ttcp_ses->ops = volume_info->ops;\n\ttcp_ses->vals = volume_info->vals;\n\tcifs_set_net_ns(tcp_ses, get_net(current->nsproxy->net_ns));\n\ttcp_ses->hostname = extract_hostname(volume_info->UNC);\n\tif (IS_ERR(tcp_ses->hostname)) {\n\t\trc = PTR_ERR(tcp_ses->hostname);\n\t\tgoto out_err_crypto_release;\n\t}\n\n\ttcp_ses->noblocksnd = volume_info->noblocksnd;\n\ttcp_ses->noautotune = volume_info->noautotune;\n\ttcp_ses->tcp_nodelay = volume_info->sockopt_tcp_nodelay;\n\ttcp_ses->in_flight = 0;\n\ttcp_ses->credits = 1;\n\tinit_waitqueue_head(&tcp_ses->response_q);\n\tinit_waitqueue_head(&tcp_ses->request_q);\n\tINIT_LIST_HEAD(&tcp_ses->pending_mid_q);\n\tmutex_init(&tcp_ses->srv_mutex);\n\tmemcpy(tcp_ses->workstation_RFC1001_name,\n\t\tvolume_info->source_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\tmemcpy(tcp_ses->server_RFC1001_name,\n\t\tvolume_info->target_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\ttcp_ses->session_estab = false;\n\ttcp_ses->sequence_number = 0;\n\ttcp_ses->lstrp = jiffies;\n\tspin_lock_init(&tcp_ses->req_lock);\n\tINIT_LIST_HEAD(&tcp_ses->tcp_ses_list);\n\tINIT_LIST_HEAD(&tcp_ses->smb_ses_list);\n\tINIT_DELAYED_WORK(&tcp_ses->echo, cifs_echo_request);\n\tmemcpy(&tcp_ses->srcaddr, &volume_info->srcaddr,\n\t       sizeof(tcp_ses->srcaddr));\n\tmemcpy(&tcp_ses->dstaddr, &volume_info->dstaddr,\n\t\tsizeof(tcp_ses->dstaddr));\n\t/*\n\t * at this point we are the only ones with the pointer\n\t * to the struct since the kernel thread not created yet\n\t * no need to spinlock this init of tcpStatus or srv_count\n\t */\n\ttcp_ses->tcpStatus = CifsNew;\n\t++tcp_ses->srv_count;\n\n\trc = ip_connect(tcp_ses);\n\tif (rc < 0) {\n\t\tcifs_dbg(VFS, \"Error connecting to socket. Aborting operation.\\n\");\n\t\tgoto out_err_crypto_release;\n\t}\n\n\t/*\n\t * since we're in a cifs function already, we know that\n\t * this will succeed. No need for try_module_get().\n\t */\n\t__module_get(THIS_MODULE);\n\ttcp_ses->tsk = kthread_run(cifs_demultiplex_thread,\n\t\t\t\t  tcp_ses, \"cifsd\");\n\tif (IS_ERR(tcp_ses->tsk)) {\n\t\trc = PTR_ERR(tcp_ses->tsk);\n\t\tcifs_dbg(VFS, \"error %d create cifsd thread\\n\", rc);\n\t\tmodule_put(THIS_MODULE);\n\t\tgoto out_err_crypto_release;\n\t}\n\ttcp_ses->tcpStatus = CifsNeedNegotiate;\n\n\t/* thread spawned, put it on the list */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcp_ses->tcp_ses_list, &cifs_tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcifs_fscache_get_client_cookie(tcp_ses);\n\n\t/* queue echo request delayed work */\n\tqueue_delayed_work(cifsiod_wq, &tcp_ses->echo, SMB_ECHO_INTERVAL);\n\n\treturn tcp_ses;\n\nout_err_crypto_release:\n\tcifs_crypto_shash_release(tcp_ses);\n\n\tput_net(cifs_net_ns(tcp_ses));\n\nout_err:\n\tif (tcp_ses) {\n\t\tif (!IS_ERR(tcp_ses->hostname))\n\t\t\tkfree(tcp_ses->hostname);\n\t\tif (tcp_ses->ssocket)\n\t\t\tsock_release(tcp_ses->ssocket);\n\t\tkfree(tcp_ses);\n\t}\n\treturn ERR_PTR(rc);\n}\n\nstatic int match_session(struct cifs_ses *ses, struct smb_vol *vol)\n{\n\tswitch (ses->server->secType) {\n\tcase Kerberos:\n\t\tif (!uid_eq(vol->cred_uid, ses->cred_uid))\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\t/* NULL username means anonymous session */\n\t\tif (ses->user_name == NULL) {\n\t\t\tif (!vol->nullauth)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* anything else takes username/password */\n\t\tif (strncmp(ses->user_name,\n\t\t\t    vol->username ? vol->username : \"\",\n\t\t\t    MAX_USERNAME_SIZE))\n\t\t\treturn 0;\n\t\tif (strlen(vol->username) != 0 &&\n\t\t    ses->password != NULL &&\n\t\t    strncmp(ses->password,\n\t\t\t    vol->password ? vol->password : \"\",\n\t\t\t    MAX_PASSWORD_SIZE))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic struct cifs_ses *\ncifs_find_smb_ses(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tstruct cifs_ses *ses;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n\t\tif (!match_session(ses, vol))\n\t\t\tcontinue;\n\t\t++ses->ses_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nstatic void\ncifs_put_smb_ses(struct cifs_ses *ses)\n{\n\tunsigned int xid;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcifs_dbg(FYI, \"%s: ses_count=%d\\n\", __func__, ses->ses_count);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--ses->ses_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tlist_del_init(&ses->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tif (ses->status == CifsGood && server->ops->logoff) {\n\t\txid = get_xid();\n\t\tserver->ops->logoff(xid, ses);\n\t\t_free_xid(xid);\n\t}\n\tsesInfoFree(ses);\n\tcifs_put_tcp_session(server);\n}\n\n#ifdef CONFIG_KEYS\n\n/* strlen(\"cifs:a:\") + INET6_ADDRSTRLEN + 1 */\n#define CIFSCREDS_DESC_SIZE (7 + INET6_ADDRSTRLEN + 1)\n\n/* Populate username and pw fields from keyring if possible */\nstatic int\ncifs_set_cifscreds(struct smb_vol *vol, struct cifs_ses *ses)\n{\n\tint rc = 0;\n\tchar *desc, *delim, *payload;\n\tssize_t len;\n\tstruct key *key;\n\tstruct TCP_Server_Info *server = ses->server;\n\tstruct sockaddr_in *sa;\n\tstruct sockaddr_in6 *sa6;\n\tstruct user_key_payload *upayload;\n\n\tdesc = kmalloc(CIFSCREDS_DESC_SIZE, GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\t/* try to find an address key first */\n\tswitch (server->dstaddr.ss_family) {\n\tcase AF_INET:\n\t\tsa = (struct sockaddr_in *)&server->dstaddr;\n\t\tsprintf(desc, \"cifs:a:%pI4\", &sa->sin_addr.s_addr);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsa6 = (struct sockaddr_in6 *)&server->dstaddr;\n\t\tsprintf(desc, \"cifs:a:%pI6c\", &sa6->sin6_addr.s6_addr);\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(FYI, \"Bad ss_family (%hu)\\n\",\n\t\t\t server->dstaddr.ss_family);\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tcifs_dbg(FYI, \"%s: desc=%s\\n\", __func__, desc);\n\tkey = request_key(&key_type_logon, desc, \"\");\n\tif (IS_ERR(key)) {\n\t\tif (!ses->domainName) {\n\t\t\tcifs_dbg(FYI, \"domainName is NULL\\n\");\n\t\t\trc = PTR_ERR(key);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\t/* didn't work, try to find a domain key */\n\t\tsprintf(desc, \"cifs:d:%s\", ses->domainName);\n\t\tcifs_dbg(FYI, \"%s: desc=%s\\n\", __func__, desc);\n\t\tkey = request_key(&key_type_logon, desc, \"\");\n\t\tif (IS_ERR(key)) {\n\t\t\trc = PTR_ERR(key);\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tdown_read(&key->sem);\n\tupayload = key->payload.data;\n\tif (IS_ERR_OR_NULL(upayload)) {\n\t\trc = upayload ? PTR_ERR(upayload) : -EINVAL;\n\t\tgoto out_key_put;\n\t}\n\n\t/* find first : in payload */\n\tpayload = (char *)upayload->data;\n\tdelim = strnchr(payload, upayload->datalen, ':');\n\tcifs_dbg(FYI, \"payload=%s\\n\", payload);\n\tif (!delim) {\n\t\tcifs_dbg(FYI, \"Unable to find ':' in payload (datalen=%d)\\n\",\n\t\t\t upayload->datalen);\n\t\trc = -EINVAL;\n\t\tgoto out_key_put;\n\t}\n\n\tlen = delim - payload;\n\tif (len > MAX_USERNAME_SIZE || len <= 0) {\n\t\tcifs_dbg(FYI, \"Bad value from username search (len=%zd)\\n\",\n\t\t\t len);\n\t\trc = -EINVAL;\n\t\tgoto out_key_put;\n\t}\n\n\tvol->username = kstrndup(payload, len, GFP_KERNEL);\n\tif (!vol->username) {\n\t\tcifs_dbg(FYI, \"Unable to allocate %zd bytes for username\\n\",\n\t\t\t len);\n\t\trc = -ENOMEM;\n\t\tgoto out_key_put;\n\t}\n\tcifs_dbg(FYI, \"%s: username=%s\\n\", __func__, vol->username);\n\n\tlen = key->datalen - (len + 1);\n\tif (len > MAX_PASSWORD_SIZE || len <= 0) {\n\t\tcifs_dbg(FYI, \"Bad len for password search (len=%zd)\\n\", len);\n\t\trc = -EINVAL;\n\t\tkfree(vol->username);\n\t\tvol->username = NULL;\n\t\tgoto out_key_put;\n\t}\n\n\t++delim;\n\tvol->password = kstrndup(delim, len, GFP_KERNEL);\n\tif (!vol->password) {\n\t\tcifs_dbg(FYI, \"Unable to allocate %zd bytes for password\\n\",\n\t\t\t len);\n\t\trc = -ENOMEM;\n\t\tkfree(vol->username);\n\t\tvol->username = NULL;\n\t\tgoto out_key_put;\n\t}\n\nout_key_put:\n\tup_read(&key->sem);\n\tkey_put(key);\nout_err:\n\tkfree(desc);\n\tcifs_dbg(FYI, \"%s: returning %d\\n\", __func__, rc);\n\treturn rc;\n}\n#else /* ! CONFIG_KEYS */\nstatic inline int\ncifs_set_cifscreds(struct smb_vol *vol __attribute__((unused)),\n\t\t   struct cifs_ses *ses __attribute__((unused)))\n{\n\treturn -ENOSYS;\n}\n#endif /* CONFIG_KEYS */\n\nstatic struct cifs_ses *\ncifs_get_smb_ses(struct TCP_Server_Info *server, struct smb_vol *volume_info)\n{\n\tint rc = -ENOMEM;\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\n\txid = get_xid();\n\n\tses = cifs_find_smb_ses(server, volume_info);\n\tif (ses) {\n\t\tcifs_dbg(FYI, \"Existing smb sess found (status=%d)\\n\",\n\t\t\t ses->status);\n\n\t\tmutex_lock(&ses->session_mutex);\n\t\trc = cifs_negotiate_protocol(xid, ses);\n\t\tif (rc) {\n\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t/* problem -- put our ses reference */\n\t\t\tcifs_put_smb_ses(ses);\n\t\t\tfree_xid(xid);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t\tif (ses->need_reconnect) {\n\t\t\tcifs_dbg(FYI, \"Session needs reconnect\\n\");\n\t\t\trc = cifs_setup_session(xid, ses,\n\t\t\t\t\t\tvolume_info->local_nls);\n\t\t\tif (rc) {\n\t\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t\t/* problem -- put our reference */\n\t\t\t\tcifs_put_smb_ses(ses);\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&ses->session_mutex);\n\n\t\t/* existing SMB ses has a server reference already */\n\t\tcifs_put_tcp_session(server);\n\t\tfree_xid(xid);\n\t\treturn ses;\n\t}\n\n\tcifs_dbg(FYI, \"Existing smb sess not found\\n\");\n\tses = sesInfoAlloc();\n\tif (ses == NULL)\n\t\tgoto get_ses_fail;\n\n\t/* new SMB session uses our server ref */\n\tses->server = server;\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsprintf(ses->serverName, \"%pI6\", &addr6->sin6_addr);\n\telse\n\t\tsprintf(ses->serverName, \"%pI4\", &addr->sin_addr);\n\n\tif (volume_info->username) {\n\t\tses->user_name = kstrdup(volume_info->username, GFP_KERNEL);\n\t\tif (!ses->user_name)\n\t\t\tgoto get_ses_fail;\n\t}\n\n\t/* volume_info->password freed at unmount */\n\tif (volume_info->password) {\n\t\tses->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!ses->password)\n\t\t\tgoto get_ses_fail;\n\t}\n\tif (volume_info->domainname) {\n\t\tses->domainName = kstrdup(volume_info->domainname, GFP_KERNEL);\n\t\tif (!ses->domainName)\n\t\t\tgoto get_ses_fail;\n\t}\n\tses->cred_uid = volume_info->cred_uid;\n\tses->linux_uid = volume_info->linux_uid;\n\n\tses->overrideSecFlg = volume_info->secFlg;\n\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(xid, ses);\n\tif (!rc)\n\t\trc = cifs_setup_session(xid, ses, volume_info->local_nls);\n\tmutex_unlock(&ses->session_mutex);\n\tif (rc)\n\t\tgoto get_ses_fail;\n\n\t/* success, put it on the list */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&ses->smb_ses_list, &server->smb_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tfree_xid(xid);\n\treturn ses;\n\nget_ses_fail:\n\tsesInfoFree(ses);\n\tfree_xid(xid);\n\treturn ERR_PTR(rc);\n}\n\nstatic int match_tcon(struct cifs_tcon *tcon, const char *unc)\n{\n\tif (tcon->tidStatus == CifsExiting)\n\t\treturn 0;\n\tif (strncmp(tcon->treeName, unc, MAX_TREE_SIZE))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic struct cifs_tcon *\ncifs_find_tcon(struct cifs_ses *ses, const char *unc)\n{\n\tstruct list_head *tmp;\n\tstruct cifs_tcon *tcon;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &ses->tcon_list) {\n\t\ttcon = list_entry(tmp, struct cifs_tcon, tcon_list);\n\t\tif (!match_tcon(tcon, unc))\n\t\t\tcontinue;\n\t\t++tcon->tc_count;\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn tcon;\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nstatic void\ncifs_put_tcon(struct cifs_tcon *tcon)\n{\n\tunsigned int xid;\n\tstruct cifs_ses *ses = tcon->ses;\n\n\tcifs_dbg(FYI, \"%s: tc_count=%d\\n\", __func__, tcon->tc_count);\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--tcon->tc_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tlist_del_init(&tcon->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\txid = get_xid();\n\tif (ses->server->ops->tree_disconnect)\n\t\tses->server->ops->tree_disconnect(xid, tcon);\n\t_free_xid(xid);\n\n\tcifs_fscache_release_super_cookie(tcon);\n\ttconInfoFree(tcon);\n\tcifs_put_smb_ses(ses);\n}\n\nstatic struct cifs_tcon *\ncifs_get_tcon(struct cifs_ses *ses, struct smb_vol *volume_info)\n{\n\tint rc, xid;\n\tstruct cifs_tcon *tcon;\n\n\ttcon = cifs_find_tcon(ses, volume_info->UNC);\n\tif (tcon) {\n\t\tcifs_dbg(FYI, \"Found match on UNC path\\n\");\n\t\t/* existing tcon already has a reference */\n\t\tcifs_put_smb_ses(ses);\n\t\tif (tcon->seal != volume_info->seal)\n\t\t\tcifs_dbg(VFS, \"transport encryption setting conflicts with existing tid\\n\");\n\t\treturn tcon;\n\t}\n\n\tif (!ses->server->ops->tree_connect) {\n\t\trc = -ENOSYS;\n\t\tgoto out_fail;\n\t}\n\n\ttcon = tconInfoAlloc();\n\tif (tcon == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out_fail;\n\t}\n\n\ttcon->ses = ses;\n\tif (volume_info->password) {\n\t\ttcon->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!tcon->password) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\t/*\n\t * BB Do we need to wrap session_mutex around this TCon call and Unix\n\t * SetFS as we do on SessSetup and reconnect?\n\t */\n\txid = get_xid();\n\trc = ses->server->ops->tree_connect(xid, ses, volume_info->UNC, tcon,\n\t\t\t\t\t    volume_info->local_nls);\n\tfree_xid(xid);\n\tcifs_dbg(FYI, \"Tcon rc = %d\\n\", rc);\n\tif (rc)\n\t\tgoto out_fail;\n\n\tif (volume_info->nodfs) {\n\t\ttcon->Flags &= ~SMB_SHARE_IS_IN_DFS;\n\t\tcifs_dbg(FYI, \"DFS disabled (%d)\\n\", tcon->Flags);\n\t}\n\ttcon->seal = volume_info->seal;\n\t/*\n\t * We can have only one retry value for a connection to a share so for\n\t * resources mounted more than once to the same server share the last\n\t * value passed in for the retry flag is used.\n\t */\n\ttcon->retry = volume_info->retry;\n\ttcon->nocase = volume_info->nocase;\n\ttcon->local_lease = volume_info->local_lease;\n\tINIT_LIST_HEAD(&tcon->pending_opens);\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcon->tcon_list, &ses->tcon_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tcifs_fscache_get_super_cookie(tcon);\n\n\treturn tcon;\n\nout_fail:\n\ttconInfoFree(tcon);\n\treturn ERR_PTR(rc);\n}\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}\n\nstatic inline struct tcon_link *\ncifs_sb_master_tlink(struct cifs_sb_info *cifs_sb)\n{\n\treturn cifs_sb->master_tlink;\n}\n\nstatic int\ncompare_mount_options(struct super_block *sb, struct cifs_mnt_data *mnt_data)\n{\n\tstruct cifs_sb_info *old = CIFS_SB(sb);\n\tstruct cifs_sb_info *new = mnt_data->cifs_sb;\n\n\tif ((sb->s_flags & CIFS_MS_MASK) != (mnt_data->flags & CIFS_MS_MASK))\n\t\treturn 0;\n\n\tif ((old->mnt_cifs_flags & CIFS_MOUNT_MASK) !=\n\t    (new->mnt_cifs_flags & CIFS_MOUNT_MASK))\n\t\treturn 0;\n\n\t/*\n\t * We want to share sb only if we don't specify an r/wsize or\n\t * specified r/wsize is greater than or equal to existing one.\n\t */\n\tif (new->wsize && new->wsize < old->wsize)\n\t\treturn 0;\n\n\tif (new->rsize && new->rsize < old->rsize)\n\t\treturn 0;\n\n\tif (!uid_eq(old->mnt_uid, new->mnt_uid) || !gid_eq(old->mnt_gid, new->mnt_gid))\n\t\treturn 0;\n\n\tif (old->mnt_file_mode != new->mnt_file_mode ||\n\t    old->mnt_dir_mode != new->mnt_dir_mode)\n\t\treturn 0;\n\n\tif (strcmp(old->local_nls->charset, new->local_nls->charset))\n\t\treturn 0;\n\n\tif (old->actimeo != new->actimeo)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nint\ncifs_match_super(struct super_block *sb, void *data)\n{\n\tstruct cifs_mnt_data *mnt_data = (struct cifs_mnt_data *)data;\n\tstruct smb_vol *volume_info;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct TCP_Server_Info *tcp_srv;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct tcon_link *tlink;\n\tint rc = 0;\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tcifs_sb = CIFS_SB(sb);\n\ttlink = cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\tif (IS_ERR(tlink)) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn rc;\n\t}\n\ttcon = tlink_tcon(tlink);\n\tses = tcon->ses;\n\ttcp_srv = ses->server;\n\n\tvolume_info = mnt_data->vol;\n\n\tif (!match_server(tcp_srv, volume_info) ||\n\t    !match_session(ses, volume_info) ||\n\t    !match_tcon(tcon, volume_info->UNC)) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = compare_mount_options(sb, mnt_data);\nout:\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}\n\nint\nget_dfs_path(const unsigned int xid, struct cifs_ses *ses, const char *old_path,\n\t     const struct nls_table *nls_codepage, unsigned int *num_referrals,\n\t     struct dfs_info3_param **referrals, int remap)\n{\n\tchar *temp_unc;\n\tint rc = 0;\n\n\tif (!ses->server->ops->tree_connect || !ses->server->ops->get_dfs_refer)\n\t\treturn -ENOSYS;\n\n\t*num_referrals = 0;\n\t*referrals = NULL;\n\n\tif (ses->ipc_tid == 0) {\n\t\ttemp_unc = kmalloc(2 /* for slashes */ +\n\t\t\tstrnlen(ses->serverName, SERVER_NAME_LEN_WITH_NULL * 2)\n\t\t\t\t+ 1 + 4 /* slash IPC$ */ + 2, GFP_KERNEL);\n\t\tif (temp_unc == NULL)\n\t\t\treturn -ENOMEM;\n\t\ttemp_unc[0] = '\\\\';\n\t\ttemp_unc[1] = '\\\\';\n\t\tstrcpy(temp_unc + 2, ses->serverName);\n\t\tstrcpy(temp_unc + 2 + strlen(ses->serverName), \"\\\\IPC$\");\n\t\trc = ses->server->ops->tree_connect(xid, ses, temp_unc, NULL,\n\t\t\t\t\t\t    nls_codepage);\n\t\tcifs_dbg(FYI, \"Tcon rc = %d ipc_tid = %d\\n\", rc, ses->ipc_tid);\n\t\tkfree(temp_unc);\n\t}\n\tif (rc == 0)\n\t\trc = ses->server->ops->get_dfs_refer(xid, ses, old_path,\n\t\t\t\t\t\t     referrals, num_referrals,\n\t\t\t\t\t\t     nls_codepage, remap);\n\t/*\n\t * BB - map targetUNCs to dfs_info3 structures, here or in\n\t * ses->server->ops->get_dfs_refer.\n\t */\n\n\treturn rc;\n}\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nstatic struct lock_class_key cifs_key[2];\nstatic struct lock_class_key cifs_slock_key[2];\n\nstatic inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(sock_owned_by_user(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET-CIFS\",\n\t\t&cifs_slock_key[0], \"sk_lock-AF_INET-CIFS\", &cifs_key[0]);\n}\n\nstatic inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(sock_owned_by_user(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET6-CIFS\",\n\t\t&cifs_slock_key[1], \"sk_lock-AF_INET6-CIFS\", &cifs_key[1]);\n}\n#else\nstatic inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n}\n\nstatic inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n}\n#endif\n\n/* See RFC1001 section 14 on representation of Netbios names */\nstatic void rfc1002mangle(char *target, char *source, unsigned int length)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0, j = 0; i < (length); i++) {\n\t\t/* mask a nibble at a time and encode */\n\t\ttarget[j] = 'A' + (0x0F & (source[i] >> 4));\n\t\ttarget[j+1] = 'A' + (0x0F & source[i]);\n\t\tj += 2;\n\t}\n\n}\n\nstatic int\nbind_socket(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tif (server->srcaddr.ss_family != AF_UNSPEC) {\n\t\t/* Bind to the specified local IP address */\n\t\tstruct socket *socket = server->ssocket;\n\t\trc = socket->ops->bind(socket,\n\t\t\t\t       (struct sockaddr *) &server->srcaddr,\n\t\t\t\t       sizeof(server->srcaddr));\n\t\tif (rc < 0) {\n\t\t\tstruct sockaddr_in *saddr4;\n\t\t\tstruct sockaddr_in6 *saddr6;\n\t\t\tsaddr4 = (struct sockaddr_in *)&server->srcaddr;\n\t\t\tsaddr6 = (struct sockaddr_in6 *)&server->srcaddr;\n\t\t\tif (saddr6->sin6_family == AF_INET6)\n\t\t\t\tcifs_dbg(VFS, \"Failed to bind to: %pI6c, error: %d\\n\",\n\t\t\t\t\t &saddr6->sin6_addr, rc);\n\t\t\telse\n\t\t\t\tcifs_dbg(VFS, \"Failed to bind to: %pI4, error: %d\\n\",\n\t\t\t\t\t &saddr4->sin_addr.s_addr, rc);\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic int\nip_rfc1001_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t/*\n\t * some servers require RFC1001 sessinit before sending\n\t * negprot - BB check reconnection in case where second\n\t * sessinit is sent but no second negprot\n\t */\n\tstruct rfc1002_session_packet *ses_init_buf;\n\tstruct smb_hdr *smb_buf;\n\tses_init_buf = kzalloc(sizeof(struct rfc1002_session_packet),\n\t\t\t       GFP_KERNEL);\n\tif (ses_init_buf) {\n\t\tses_init_buf->trailer.session_req.called_len = 32;\n\n\t\tif (server->server_RFC1001_name &&\n\t\t    server->server_RFC1001_name[0] != 0)\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.called_name,\n\t\t\t\t      server->server_RFC1001_name,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\telse\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.called_name,\n\t\t\t\t      DEFAULT_CIFS_CALLED_NAME,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\tses_init_buf->trailer.session_req.calling_len = 32;\n\n\t\t/*\n\t\t * calling name ends in null (byte 16) from old smb\n\t\t * convention.\n\t\t */\n\t\tif (server->workstation_RFC1001_name &&\n\t\t    server->workstation_RFC1001_name[0] != 0)\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name,\n\t\t\t\t      server->workstation_RFC1001_name,\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\telse\n\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t      session_req.calling_name,\n\t\t\t\t      \"LINUX_CIFS_CLNT\",\n\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\tses_init_buf->trailer.session_req.scope1 = 0;\n\t\tses_init_buf->trailer.session_req.scope2 = 0;\n\t\tsmb_buf = (struct smb_hdr *)ses_init_buf;\n\n\t\t/* sizeof RFC1002_SESSION_REQUEST with no scope */\n\t\tsmb_buf->smb_buf_length = cpu_to_be32(0x81000044);\n\t\trc = smb_send(server, smb_buf, 0x44);\n\t\tkfree(ses_init_buf);\n\t\t/*\n\t\t * RFC1001 layer in at least one server\n\t\t * requires very short break before negprot\n\t\t * presumably because not expecting negprot\n\t\t * to follow so fast.  This is a simple\n\t\t * solution that works without\n\t\t * complicating the code and causes no\n\t\t * significant slowing down on mount\n\t\t * for everyone else\n\t\t */\n\t\tusleep_range(1000, 2000);\n\t}\n\t/*\n\t * else the negprot may still work without this\n\t * even though malloc failed\n\t */\n\n\treturn rc;\n}\n\nstatic int\ngeneric_ip_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\t__be16 sport;\n\tint slen, sfamily;\n\tstruct socket *socket = server->ssocket;\n\tstruct sockaddr *saddr;\n\n\tsaddr = (struct sockaddr *) &server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6) {\n\t\tsport = ((struct sockaddr_in6 *) saddr)->sin6_port;\n\t\tslen = sizeof(struct sockaddr_in6);\n\t\tsfamily = AF_INET6;\n\t} else {\n\t\tsport = ((struct sockaddr_in *) saddr)->sin_port;\n\t\tslen = sizeof(struct sockaddr_in);\n\t\tsfamily = AF_INET;\n\t}\n\n\tif (socket == NULL) {\n\t\trc = __sock_create(cifs_net_ns(server), sfamily, SOCK_STREAM,\n\t\t\t\t   IPPROTO_TCP, &socket, 1);\n\t\tif (rc < 0) {\n\t\t\tcifs_dbg(VFS, \"Error %d creating socket\\n\", rc);\n\t\t\tserver->ssocket = NULL;\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* BB other socket options to set KEEPALIVE, NODELAY? */\n\t\tcifs_dbg(FYI, \"Socket created\\n\");\n\t\tserver->ssocket = socket;\n\t\tsocket->sk->sk_allocation = GFP_NOFS;\n\t\tif (sfamily == AF_INET6)\n\t\t\tcifs_reclassify_socket6(socket);\n\t\telse\n\t\t\tcifs_reclassify_socket4(socket);\n\t}\n\n\trc = bind_socket(server);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t/*\n\t * Eventually check for other socket options to change from\n\t * the default. sock_setsockopt not used because it expects\n\t * user space buffer\n\t */\n\tsocket->sk->sk_rcvtimeo = 7 * HZ;\n\tsocket->sk->sk_sndtimeo = 5 * HZ;\n\n\t/* make the bufsizes depend on wsize/rsize and max requests */\n\tif (server->noautotune) {\n\t\tif (socket->sk->sk_sndbuf < (200 * 1024))\n\t\t\tsocket->sk->sk_sndbuf = 200 * 1024;\n\t\tif (socket->sk->sk_rcvbuf < (140 * 1024))\n\t\t\tsocket->sk->sk_rcvbuf = 140 * 1024;\n\t}\n\n\tif (server->tcp_nodelay) {\n\t\tint val = 1;\n\t\trc = kernel_setsockopt(socket, SOL_TCP, TCP_NODELAY,\n\t\t\t\t(char *)&val, sizeof(val));\n\t\tif (rc)\n\t\t\tcifs_dbg(FYI, \"set TCP_NODELAY socket option error %d\\n\",\n\t\t\t\t rc);\n\t}\n\n\tcifs_dbg(FYI, \"sndbuf %d rcvbuf %d rcvtimeo 0x%lx\\n\",\n\t\t socket->sk->sk_sndbuf,\n\t\t socket->sk->sk_rcvbuf, socket->sk->sk_rcvtimeo);\n\n\trc = socket->ops->connect(socket, saddr, slen, 0);\n\tif (rc < 0) {\n\t\tcifs_dbg(FYI, \"Error %d connecting to server\\n\", rc);\n\t\tsock_release(socket);\n\t\tserver->ssocket = NULL;\n\t\treturn rc;\n\t}\n\n\tif (sport == htons(RFC1001_PORT))\n\t\trc = ip_rfc1001_connect(server);\n\n\treturn rc;\n}\n\nstatic int\nip_connect(struct TCP_Server_Info *server)\n{\n\t__be16 *sport;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;\n\n\tif (server->dstaddr.ss_family == AF_INET6)\n\t\tsport = &addr6->sin6_port;\n\telse\n\t\tsport = &addr->sin_port;\n\n\tif (*sport == 0) {\n\t\tint rc;\n\n\t\t/* try with 445 port at first */\n\t\t*sport = htons(CIFS_PORT);\n\n\t\trc = generic_ip_connect(server);\n\t\tif (rc >= 0)\n\t\t\treturn rc;\n\n\t\t/* if it failed, try with 139 port */\n\t\t*sport = htons(RFC1001_PORT);\n\t}\n\n\treturn generic_ip_connect(server);\n}\n\nvoid reset_cifs_unix_caps(unsigned int xid, struct cifs_tcon *tcon,\n\t\t\t  struct cifs_sb_info *cifs_sb, struct smb_vol *vol_info)\n{\n\t/* if we are reconnecting then should we check to see if\n\t * any requested capabilities changed locally e.g. via\n\t * remount but we can not do much about it here\n\t * if they have (even if we could detect it by the following)\n\t * Perhaps we could add a backpointer to array of sb from tcon\n\t * or if we change to make all sb to same share the same\n\t * sb as NFS - then we only have one backpointer to sb.\n\t * What if we wanted to mount the server share twice once with\n\t * and once without posixacls or posix paths? */\n\t__u64 saved_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\tif (vol_info && vol_info->no_linux_ext) {\n\t\ttcon->fsUnixInfo.Capability = 0;\n\t\ttcon->unix_ext = 0; /* Unix Extensions disabled */\n\t\tcifs_dbg(FYI, \"Linux protocol extensions disabled\\n\");\n\t\treturn;\n\t} else if (vol_info)\n\t\ttcon->unix_ext = 1; /* Unix Extensions supported */\n\n\tif (tcon->unix_ext == 0) {\n\t\tcifs_dbg(FYI, \"Unix extensions disabled so not set on reconnect\\n\");\n\t\treturn;\n\t}\n\n\tif (!CIFSSMBQFSUnixInfo(xid, tcon)) {\n\t\t__u64 cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\t\tcifs_dbg(FYI, \"unix caps which server supports %lld\\n\", cap);\n\t\t/* check for reconnect case in which we do not\n\t\t   want to change the mount behavior if we can avoid it */\n\t\tif (vol_info == NULL) {\n\t\t\t/* turn off POSIX ACL and PATHNAMES if not set\n\t\t\t   originally at mount time */\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_ACL_CAP) == 0)\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\t\t\tcifs_dbg(VFS, \"POSIXPATH support change\\n\");\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\t\t} else if ((cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tcifs_dbg(VFS, \"possible reconnect error\\n\");\n\t\t\t\tcifs_dbg(VFS, \"server disabled POSIX path support\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(VFS, \"per-share encryption not supported yet\\n\");\n\n\t\tcap &= CIFS_UNIX_CAP_MASK;\n\t\tif (vol_info && vol_info->no_psx_acl)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\telse if (CIFS_UNIX_POSIX_ACL_CAP & cap) {\n\t\t\tcifs_dbg(FYI, \"negotiated posix acl support\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIXACL;\n\t\t}\n\n\t\tif (vol_info && vol_info->posix_paths == 0)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\telse if (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) {\n\t\t\tcifs_dbg(FYI, \"negotiate posix pathnames\\n\");\n\t\t\tif (cifs_sb)\n\t\t\t\tcifs_sb->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIX_PATHS;\n\t\t}\n\n\t\tcifs_dbg(FYI, \"Negotiate caps 0x%x\\n\", (int)cap);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\tif (cap & CIFS_UNIX_FCNTL_CAP)\n\t\t\tcifs_dbg(FYI, \"FCNTL cap\\n\");\n\t\tif (cap & CIFS_UNIX_EXTATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"EXTATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX path cap\\n\");\n\t\tif (cap & CIFS_UNIX_XATTR_CAP)\n\t\t\tcifs_dbg(FYI, \"XATTR cap\\n\");\n\t\tif (cap & CIFS_UNIX_POSIX_ACL_CAP)\n\t\t\tcifs_dbg(FYI, \"POSIX ACL cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_READ_CAP)\n\t\t\tcifs_dbg(FYI, \"very large read cap\\n\");\n\t\tif (cap & CIFS_UNIX_LARGE_WRITE_CAP)\n\t\t\tcifs_dbg(FYI, \"very large write cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_CAP)\n\t\t\tcifs_dbg(FYI, \"transport encryption cap\\n\");\n\t\tif (cap & CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)\n\t\t\tcifs_dbg(FYI, \"mandatory transport encryption cap\\n\");\n#endif /* CIFS_DEBUG2 */\n\t\tif (CIFSSMBSetFSUnixInfo(xid, tcon, cap)) {\n\t\t\tif (vol_info == NULL) {\n\t\t\t\tcifs_dbg(FYI, \"resetting capabilities failed\\n\");\n\t\t\t} else\n\t\t\t\tcifs_dbg(VFS, \"Negotiating Unix capabilities with the server failed. Consider mounting with the Unix Extensions disabled if problems are found by specifying the nounix mount option.\\n\");\n\n\t\t}\n\t}\n}\n\nvoid cifs_setup_cifs_sb(struct smb_vol *pvolume_info,\n\t\t\tstruct cifs_sb_info *cifs_sb)\n{\n\tINIT_DELAYED_WORK(&cifs_sb->prune_tlinks, cifs_prune_tlinks);\n\n\tspin_lock_init(&cifs_sb->tlink_tree_lock);\n\tcifs_sb->tlink_tree = RB_ROOT;\n\n\t/*\n\t * Temporarily set r/wsize for matching superblock. If we end up using\n\t * new sb then client will later negotiate it downward if needed.\n\t */\n\tcifs_sb->rsize = pvolume_info->rsize;\n\tcifs_sb->wsize = pvolume_info->wsize;\n\n\tcifs_sb->mnt_uid = pvolume_info->linux_uid;\n\tcifs_sb->mnt_gid = pvolume_info->linux_gid;\n\tcifs_sb->mnt_file_mode = pvolume_info->file_mode;\n\tcifs_sb->mnt_dir_mode = pvolume_info->dir_mode;\n\tcifs_dbg(FYI, \"file mode: 0x%hx  dir mode: 0x%hx\\n\",\n\t\t cifs_sb->mnt_file_mode, cifs_sb->mnt_dir_mode);\n\n\tcifs_sb->actimeo = pvolume_info->actimeo;\n\tcifs_sb->local_nls = pvolume_info->local_nls;\n\n\tif (pvolume_info->noperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_PERM;\n\tif (pvolume_info->setuids)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SET_UID;\n\tif (pvolume_info->server_ino)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SERVER_INUM;\n\tif (pvolume_info->remap)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MAP_SPECIAL_CHR;\n\tif (pvolume_info->no_xattr)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_XATTR;\n\tif (pvolume_info->sfu_emul)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_UNX_EMUL;\n\tif (pvolume_info->nobrl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_BRL;\n\tif (pvolume_info->nostrictsync)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOSSYNC;\n\tif (pvolume_info->mand_lock)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOPOSIXBRL;\n\tif (pvolume_info->rwpidforward)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_RWPIDFORWARD;\n\tif (pvolume_info->cifs_acl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_ACL;\n\tif (pvolume_info->backupuid_specified) {\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_BACKUPUID;\n\t\tcifs_sb->mnt_backupuid = pvolume_info->backupuid;\n\t}\n\tif (pvolume_info->backupgid_specified) {\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_BACKUPGID;\n\t\tcifs_sb->mnt_backupgid = pvolume_info->backupgid;\n\t}\n\tif (pvolume_info->override_uid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_UID;\n\tif (pvolume_info->override_gid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_GID;\n\tif (pvolume_info->dynperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DYNPERM;\n\tif (pvolume_info->fsc)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_FSCACHE;\n\tif (pvolume_info->multiuser)\n\t\tcifs_sb->mnt_cifs_flags |= (CIFS_MOUNT_MULTIUSER |\n\t\t\t\t\t    CIFS_MOUNT_NO_PERM);\n\tif (pvolume_info->strict_io)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_STRICT_IO;\n\tif (pvolume_info->direct_io) {\n\t\tcifs_dbg(FYI, \"mounting share using direct i/o\\n\");\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DIRECT_IO;\n\t}\n\tif (pvolume_info->mfsymlinks) {\n\t\tif (pvolume_info->sfu_emul) {\n\t\t\tcifs_dbg(VFS, \"mount option mfsymlinks ignored if sfu mount option is used\\n\");\n\t\t} else {\n\t\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MF_SYMLINKS;\n\t\t}\n\t}\n\n\tif ((pvolume_info->cifs_acl) && (pvolume_info->dynperm))\n\t\tcifs_dbg(VFS, \"mount option dynperm ignored if cifsacl mount option supported\\n\");\n}\n\nstatic void\ncleanup_volume_info_contents(struct smb_vol *volume_info)\n{\n\tkfree(volume_info->username);\n\tkzfree(volume_info->password);\n\tkfree(volume_info->UNC);\n\tkfree(volume_info->domainname);\n\tkfree(volume_info->iocharset);\n\tkfree(volume_info->prepath);\n}\n\nvoid\ncifs_cleanup_volume_info(struct smb_vol *volume_info)\n{\n\tif (!volume_info)\n\t\treturn;\n\tcleanup_volume_info_contents(volume_info);\n\tkfree(volume_info);\n}\n\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\n/*\n * cifs_build_path_to_root returns full path to root when we do not have an\n * exiting connection (tcon)\n */\nstatic char *\nbuild_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(full_path, vol->UNC, unc_len);\n\tpos = full_path + unc_len;\n\n\tif (pplen) {\n\t\t*pos = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos + 1, vol->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\n\t*pos = '\\0'; /* add trailing null */\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}\n\n/*\n * Perform a dfs referral query for a share and (optionally) prefix\n *\n * If a referral is found, cifs_sb->mountdata will be (re-)allocated\n * to a string containing updated options for the submount.  Otherwise it\n * will be left untouched.\n *\n * Returns the rc from get_dfs_path to the caller, which can be used to\n * determine whether there were referrals.\n */\nstatic int\nexpand_dfs_referral(const unsigned int xid, struct cifs_ses *ses,\n\t\t    struct smb_vol *volume_info, struct cifs_sb_info *cifs_sb,\n\t\t    int check_prefix)\n{\n\tint rc;\n\tunsigned int num_referrals = 0;\n\tstruct dfs_info3_param *referrals = NULL;\n\tchar *full_path = NULL, *ref_path = NULL, *mdata = NULL;\n\n\tfull_path = build_unc_path_to_root(volume_info, cifs_sb);\n\tif (IS_ERR(full_path))\n\t\treturn PTR_ERR(full_path);\n\n\t/* For DFS paths, skip the first '\\' of the UNC */\n\tref_path = check_prefix ? full_path + 1 : volume_info->UNC + 1;\n\n\trc = get_dfs_path(xid, ses, ref_path, cifs_sb->local_nls,\n\t\t\t  &num_referrals, &referrals,\n\t\t\t  cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\n\tif (!rc && num_referrals > 0) {\n\t\tchar *fake_devname = NULL;\n\n\t\tmdata = cifs_compose_mount_options(cifs_sb->mountdata,\n\t\t\t\t\t\t   full_path + 1, referrals,\n\t\t\t\t\t\t   &fake_devname);\n\n\t\tfree_dfs_info_array(referrals, num_referrals);\n\n\t\tif (IS_ERR(mdata)) {\n\t\t\trc = PTR_ERR(mdata);\n\t\t\tmdata = NULL;\n\t\t} else {\n\t\t\tcleanup_volume_info_contents(volume_info);\n\t\t\trc = cifs_setup_volume_info(volume_info, mdata,\n\t\t\t\t\t\t\tfake_devname);\n\t\t}\n\t\tkfree(fake_devname);\n\t\tkfree(cifs_sb->mountdata);\n\t\tcifs_sb->mountdata = mdata;\n\t}\n\tkfree(full_path);\n\treturn rc;\n}\n#endif\n\nstatic int\ncifs_setup_volume_info(struct smb_vol *volume_info, char *mount_data,\n\t\t\tconst char *devname)\n{\n\tint rc = 0;\n\n\tif (cifs_parse_mount_options(mount_data, devname, volume_info))\n\t\treturn -EINVAL;\n\n\tif (volume_info->nullauth) {\n\t\tcifs_dbg(FYI, \"Anonymous login\\n\");\n\t\tkfree(volume_info->username);\n\t\tvolume_info->username = NULL;\n\t} else if (volume_info->username) {\n\t\t/* BB fixme parse for domain name here */\n\t\tcifs_dbg(FYI, \"Username: %s\\n\", volume_info->username);\n\t} else {\n\t\tcifs_dbg(VFS, \"No username specified\\n\");\n\t/* In userspace mount helper we can get user name from alternate\n\t   locations such as env variables and files on disk */\n\t\treturn -EINVAL;\n\t}\n\n\t/* this is needed for ASCII cp to Unicode converts */\n\tif (volume_info->iocharset == NULL) {\n\t\t/* load_nls_default cannot return null */\n\t\tvolume_info->local_nls = load_nls_default();\n\t} else {\n\t\tvolume_info->local_nls = load_nls(volume_info->iocharset);\n\t\tif (volume_info->local_nls == NULL) {\n\t\t\tcifs_dbg(VFS, \"CIFS mount error: iocharset %s not found\\n\",\n\t\t\t\t volume_info->iocharset);\n\t\t\treturn -ELIBACC;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstruct smb_vol *\ncifs_get_volume_info(char *mount_data, const char *devname)\n{\n\tint rc;\n\tstruct smb_vol *volume_info;\n\n\tvolume_info = kmalloc(sizeof(struct smb_vol), GFP_KERNEL);\n\tif (!volume_info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc = cifs_setup_volume_info(volume_info, mount_data, devname);\n\tif (rc) {\n\t\tcifs_cleanup_volume_info(volume_info);\n\t\tvolume_info = ERR_PTR(rc);\n\t}\n\n\treturn volume_info;\n}\n\nint\ncifs_mount(struct cifs_sb_info *cifs_sb, struct smb_vol *volume_info)\n{\n\tint rc;\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tchar   *full_path;\n\tstruct tcon_link *tlink;\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tint referral_walks_count = 0;\n#endif\n\n\trc = bdi_setup_and_register(&cifs_sb->bdi, \"cifs\", BDI_CAP_MAP_COPY);\n\tif (rc)\n\t\treturn rc;\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\ntry_mount_again:\n\t/* cleanup activities if we're chasing a referral */\n\tif (referral_walks_count) {\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (ses)\n\t\t\tcifs_put_smb_ses(ses);\n\n\t\tfree_xid(xid);\n\t}\n#endif\n\trc = 0;\n\ttcon = NULL;\n\tses = NULL;\n\tserver = NULL;\n\tfull_path = NULL;\n\ttlink = NULL;\n\n\txid = get_xid();\n\n\t/* get a reference to a tcp session */\n\tserver = cifs_get_tcp_session(volume_info);\n\tif (IS_ERR(server)) {\n\t\trc = PTR_ERR(server);\n\t\tbdi_destroy(&cifs_sb->bdi);\n\t\tgoto out;\n\t}\n\n\t/* get a reference to a SMB session */\n\tses = cifs_get_smb_ses(server, volume_info);\n\tif (IS_ERR(ses)) {\n\t\trc = PTR_ERR(ses);\n\t\tses = NULL;\n\t\tgoto mount_fail_check;\n\t}\n\n\t/* search for existing tcon to this server share */\n\ttcon = cifs_get_tcon(ses, volume_info);\n\tif (IS_ERR(tcon)) {\n\t\trc = PTR_ERR(tcon);\n\t\ttcon = NULL;\n\t\tgoto remote_path_check;\n\t}\n\n\t/* tell server which Unix caps we support */\n\tif (cap_unix(tcon->ses)) {\n\t\t/* reset of caps checks mount to see if unix extensions\n\t\t   disabled for just this mount */\n\t\treset_cifs_unix_caps(xid, tcon, cifs_sb, volume_info);\n\t\tif ((tcon->ses->server->tcpStatus == CifsNeedReconnect) &&\n\t\t    (le64_to_cpu(tcon->fsUnixInfo.Capability) &\n\t\t     CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP)) {\n\t\t\trc = -EACCES;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t} else\n\t\ttcon->unix_ext = 0; /* server does not support them */\n\n\t/* do not care if a following call succeed - informational */\n\tif (!tcon->ipc && server->ops->qfs_tcon)\n\t\tserver->ops->qfs_tcon(xid, tcon);\n\n\tcifs_sb->wsize = server->ops->negotiate_wsize(tcon, volume_info);\n\tcifs_sb->rsize = server->ops->negotiate_rsize(tcon, volume_info);\n\n\t/* tune readahead according to rsize */\n\tcifs_sb->bdi.ra_pages = cifs_sb->rsize / PAGE_CACHE_SIZE;\n\nremote_path_check:\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t/*\n\t * Perform an unconditional check for whether there are DFS\n\t * referrals for this path without prefix, to provide support\n\t * for DFS referrals from w2k8 servers which don't seem to respond\n\t * with PATH_NOT_COVERED to requests that include the prefix.\n\t * Chase the referral if found, otherwise continue normally.\n\t */\n\tif (referral_walks_count == 0) {\n\t\tint refrc = expand_dfs_referral(xid, ses, volume_info, cifs_sb,\n\t\t\t\t\t\tfalse);\n\t\tif (!refrc) {\n\t\t\treferral_walks_count++;\n\t\t\tgoto try_mount_again;\n\t\t}\n\t}\n#endif\n\n\t/* check if a whole path is not remote */\n\tif (!rc && tcon) {\n\t\tif (!server->ops->is_path_accessible) {\n\t\t\trc = -ENOSYS;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\t/*\n\t\t * cifs_build_path_to_root works only when we have a valid tcon\n\t\t */\n\t\tfull_path = cifs_build_path_to_root(volume_info, cifs_sb, tcon);\n\t\tif (full_path == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\trc = server->ops->is_path_accessible(xid, tcon, cifs_sb,\n\t\t\t\t\t\t     full_path);\n\t\tif (rc != 0 && rc != -EREMOTE) {\n\t\t\tkfree(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\tkfree(full_path);\n\t}\n\n\t/* get referral if needed */\n\tif (rc == -EREMOTE) {\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t\tif (referral_walks_count > MAX_NESTED_LINKS) {\n\t\t\t/*\n\t\t\t * BB: when we implement proper loop detection,\n\t\t\t *     we will remove this check. But now we need it\n\t\t\t *     to prevent an indefinite loop if 'DFS tree' is\n\t\t\t *     misconfigured (i.e. has loops).\n\t\t\t */\n\t\t\trc = -ELOOP;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\n\t\trc = expand_dfs_referral(xid, ses, volume_info, cifs_sb, true);\n\n\t\tif (!rc) {\n\t\t\treferral_walks_count++;\n\t\t\tgoto try_mount_again;\n\t\t}\n\t\tgoto mount_fail_check;\n#else /* No DFS support, return error on mount */\n\t\trc = -EOPNOTSUPP;\n#endif\n\t}\n\n\tif (rc)\n\t\tgoto mount_fail_check;\n\n\t/* now, hang the tcon off of the superblock */\n\ttlink = kzalloc(sizeof *tlink, GFP_KERNEL);\n\tif (tlink == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto mount_fail_check;\n\t}\n\n\ttlink->tl_uid = ses->linux_uid;\n\ttlink->tl_tcon = tcon;\n\ttlink->tl_time = jiffies;\n\tset_bit(TCON_LINK_MASTER, &tlink->tl_flags);\n\tset_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\n\tcifs_sb->master_tlink = tlink;\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(cifsiod_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n\nmount_fail_check:\n\t/* on error free sesinfo and tcon struct if needed */\n\tif (rc) {\n\t\t/* If find_unc succeeded then rc == 0 so we can not end */\n\t\t/* up accidentally freeing someone elses tcon struct */\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (ses)\n\t\t\tcifs_put_smb_ses(ses);\n\t\telse\n\t\t\tcifs_put_tcp_session(server);\n\t\tbdi_destroy(&cifs_sb->bdi);\n\t}\n\nout:\n\tfree_xid(xid);\n\treturn rc;\n}\n\n/*\n * Issue a TREE_CONNECT request. Note that for IPC$ shares, that the tcon\n * pointer may be NULL.\n */\nint\nCIFSTCon(const unsigned int xid, struct cifs_ses *ses,\n\t const char *tree, struct cifs_tcon *tcon,\n\t const struct nls_table *nls_codepage)\n{\n\tstruct smb_hdr *smb_buffer;\n\tstruct smb_hdr *smb_buffer_response;\n\tTCONX_REQ *pSMB;\n\tTCONX_RSP *pSMBr;\n\tunsigned char *bcc_ptr;\n\tint rc = 0;\n\tint length;\n\t__u16 bytes_left, count;\n\n\tif (ses == NULL)\n\t\treturn -EIO;\n\n\tsmb_buffer = cifs_buf_get();\n\tif (smb_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tsmb_buffer_response = smb_buffer;\n\n\theader_assemble(smb_buffer, SMB_COM_TREE_CONNECT_ANDX,\n\t\t\tNULL /*no tid */ , 4 /*wct */ );\n\n\tsmb_buffer->Mid = get_next_mid(ses->server);\n\tsmb_buffer->Uid = ses->Suid;\n\tpSMB = (TCONX_REQ *) smb_buffer;\n\tpSMBr = (TCONX_RSP *) smb_buffer_response;\n\n\tpSMB->AndXCommand = 0xFF;\n\tpSMB->Flags = cpu_to_le16(TCON_EXTENDED_SECINFO);\n\tbcc_ptr = &pSMB->Password[0];\n\tif (!tcon || (ses->server->sec_mode & SECMODE_USER)) {\n\t\tpSMB->PasswordLength = cpu_to_le16(1);\t/* minimum */\n\t\t*bcc_ptr = 0; /* password is null byte */\n\t\tbcc_ptr++;              /* skip password */\n\t\t/* already aligned so no need to do it below */\n\t} else {\n\t\tpSMB->PasswordLength = cpu_to_le16(CIFS_AUTH_RESP_SIZE);\n\t\t/* BB FIXME add code to fail this if NTLMv2 or Kerberos\n\t\t   specified as required (when that support is added to\n\t\t   the vfs in the future) as only NTLM or the much\n\t\t   weaker LANMAN (which we do not send by default) is accepted\n\t\t   by Samba (not sure whether other servers allow\n\t\t   NTLMv2 password here) */\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t\tif ((global_secflags & CIFSSEC_MAY_LANMAN) &&\n\t\t    (ses->server->secType == LANMAN))\n\t\t\tcalc_lanman_hash(tcon->password, ses->server->cryptkey,\n\t\t\t\t\t ses->server->sec_mode &\n\t\t\t\t\t    SECMODE_PW_ENCRYPT ? true : false,\n\t\t\t\t\t bcc_ptr);\n\t\telse\n#endif /* CIFS_WEAK_PW_HASH */\n\t\trc = SMBNTencrypt(tcon->password, ses->server->cryptkey,\n\t\t\t\t\tbcc_ptr, nls_codepage);\n\n\t\tbcc_ptr += CIFS_AUTH_RESP_SIZE;\n\t\tif (ses->capabilities & CAP_UNICODE) {\n\t\t\t/* must align unicode strings */\n\t\t\t*bcc_ptr = 0; /* null byte password */\n\t\t\tbcc_ptr++;\n\t\t}\n\t}\n\n\tif (ses->server->sec_mode &\n\t\t\t(SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED))\n\t\tsmb_buffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_UNICODE;\n\t\tlength =\n\t\t    cifs_strtoUTF16((__le16 *) bcc_ptr, tree,\n\t\t\t6 /* max utf8 char length in bytes */ *\n\t\t\t(/* server len*/ + 256 /* share len */), nls_codepage);\n\t\tbcc_ptr += 2 * length;\t/* convert num 16 bit words to bytes */\n\t\tbcc_ptr += 2;\t/* skip trailing null */\n\t} else {\t\t/* ASCII */\n\t\tstrcpy(bcc_ptr, tree);\n\t\tbcc_ptr += strlen(tree) + 1;\n\t}\n\tstrcpy(bcc_ptr, \"?????\");\n\tbcc_ptr += strlen(\"?????\");\n\tbcc_ptr += 1;\n\tcount = bcc_ptr - &pSMB->Password[0];\n\tpSMB->hdr.smb_buf_length = cpu_to_be32(be32_to_cpu(\n\t\t\t\t\tpSMB->hdr.smb_buf_length) + count);\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, ses, smb_buffer, smb_buffer_response, &length,\n\t\t\t 0);\n\n\t/* above now done in SendReceive */\n\tif ((rc == 0) && (tcon != NULL)) {\n\t\tbool is_unicode;\n\n\t\ttcon->tidStatus = CifsGood;\n\t\ttcon->need_reconnect = false;\n\t\ttcon->tid = smb_buffer_response->Tid;\n\t\tbcc_ptr = pByteArea(smb_buffer_response);\n\t\tbytes_left = get_bcc(smb_buffer_response);\n\t\tlength = strnlen(bcc_ptr, bytes_left - 2);\n\t\tif (smb_buffer->Flags2 & SMBFLG2_UNICODE)\n\t\t\tis_unicode = true;\n\t\telse\n\t\t\tis_unicode = false;\n\n\n\t\t/* skip service field (NB: this field is always ASCII) */\n\t\tif (length == 3) {\n\t\t\tif ((bcc_ptr[0] == 'I') && (bcc_ptr[1] == 'P') &&\n\t\t\t    (bcc_ptr[2] == 'C')) {\n\t\t\t\tcifs_dbg(FYI, \"IPC connection\\n\");\n\t\t\t\ttcon->ipc = 1;\n\t\t\t}\n\t\t} else if (length == 2) {\n\t\t\tif ((bcc_ptr[0] == 'A') && (bcc_ptr[1] == ':')) {\n\t\t\t\t/* the most common case */\n\t\t\t\tcifs_dbg(FYI, \"disk share connection\\n\");\n\t\t\t}\n\t\t}\n\t\tbcc_ptr += length + 1;\n\t\tbytes_left -= (length + 1);\n\t\tstrncpy(tcon->treeName, tree, MAX_TREE_SIZE);\n\n\t\t/* mostly informational -- no need to fail on error here */\n\t\tkfree(tcon->nativeFileSystem);\n\t\ttcon->nativeFileSystem = cifs_strndup_from_utf16(bcc_ptr,\n\t\t\t\t\t\t      bytes_left, is_unicode,\n\t\t\t\t\t\t      nls_codepage);\n\n\t\tcifs_dbg(FYI, \"nativeFileSystem=%s\\n\", tcon->nativeFileSystem);\n\n\t\tif ((smb_buffer_response->WordCount == 3) ||\n\t\t\t (smb_buffer_response->WordCount == 7))\n\t\t\t/* field is in same location */\n\t\t\ttcon->Flags = le16_to_cpu(pSMBr->OptionalSupport);\n\t\telse\n\t\t\ttcon->Flags = 0;\n\t\tcifs_dbg(FYI, \"Tcon flags: 0x%x\\n\", tcon->Flags);\n\t} else if ((rc == 0) && tcon == NULL) {\n\t\t/* all we need to save for IPC$ connection */\n\t\tses->ipc_tid = smb_buffer_response->Tid;\n\t}\n\n\tcifs_buf_release(smb_buffer);\n\treturn rc;\n}\n\nvoid\ncifs_umount(struct cifs_sb_info *cifs_sb)\n{\n\tstruct rb_root *root = &cifs_sb->tlink_tree;\n\tstruct rb_node *node;\n\tstruct tcon_link *tlink;\n\n\tcancel_delayed_work_sync(&cifs_sb->prune_tlinks);\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\twhile ((node = rb_first(root))) {\n\t\ttlink = rb_entry(node, struct tcon_link, tl_rbnode);\n\t\tcifs_get_tlink(tlink);\n\t\tclear_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\t\trb_erase(node, root);\n\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\tcifs_put_tlink(tlink);\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t}\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tbdi_destroy(&cifs_sb->bdi);\n\tkfree(cifs_sb->mountdata);\n\tunload_nls(cifs_sb->local_nls);\n\tkfree(cifs_sb);\n}\n\nint\ncifs_negotiate_protocol(const unsigned int xid, struct cifs_ses *ses)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tif (!server->ops->need_neg || !server->ops->negotiate)\n\t\treturn -ENOSYS;\n\n\t/* only send once per connect */\n\tif (!server->ops->need_neg(server))\n\t\treturn 0;\n\n\tset_credits(server, 1);\n\n\trc = server->ops->negotiate(xid, ses);\n\tif (rc == 0) {\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (server->tcpStatus == CifsNeedNegotiate)\n\t\t\tserver->tcpStatus = CifsGood;\n\t\telse\n\t\t\trc = -EHOSTDOWN;\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\treturn rc;\n}\n\nint\ncifs_setup_session(const unsigned int xid, struct cifs_ses *ses,\n\t\t   struct nls_table *nls_info)\n{\n\tint rc = -ENOSYS;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tses->flags = 0;\n\tses->capabilities = server->capabilities;\n\tif (linuxExtEnabled == 0)\n\t\tses->capabilities &= (~server->vals->cap_unix);\n\n\tcifs_dbg(FYI, \"Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\\n\",\n\t\t server->sec_mode, server->capabilities, server->timeAdj);\n\n\tif (server->ops->sess_setup)\n\t\trc = server->ops->sess_setup(xid, ses, nls_info);\n\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Send error in SessSetup = %d\\n\", rc);\n\t} else {\n\t\tmutex_lock(&server->srv_mutex);\n\t\tif (!server->session_estab) {\n\t\t\tserver->session_key.response = ses->auth_key.response;\n\t\t\tserver->session_key.len = ses->auth_key.len;\n\t\t\tserver->sequence_number = 0x2;\n\t\t\tserver->session_estab = true;\n\t\t\tses->auth_key.response = NULL;\n\t\t}\n\t\tmutex_unlock(&server->srv_mutex);\n\n\t\tcifs_dbg(FYI, \"CIFS Session Established successfully\\n\");\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tses->status = CifsGood;\n\t\tses->need_reconnect = false;\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n\tses->auth_key.len = 0;\n\tkfree(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\n\treturn rc;\n}\n\nstatic int\ncifs_set_vol_auth(struct smb_vol *vol, struct cifs_ses *ses)\n{\n\tswitch (ses->server->secType) {\n\tcase Kerberos:\n\t\tvol->secFlg = CIFSSEC_MUST_KRB5;\n\t\treturn 0;\n\tcase NTLMv2:\n\t\tvol->secFlg = CIFSSEC_MUST_NTLMV2;\n\t\tbreak;\n\tcase NTLM:\n\t\tvol->secFlg = CIFSSEC_MUST_NTLM;\n\t\tbreak;\n\tcase RawNTLMSSP:\n\t\tvol->secFlg = CIFSSEC_MUST_NTLMSSP;\n\t\tbreak;\n\tcase LANMAN:\n\t\tvol->secFlg = CIFSSEC_MUST_LANMAN;\n\t\tbreak;\n\t}\n\n\treturn cifs_set_cifscreds(vol, ses);\n}\n\nstatic struct cifs_tcon *\ncifs_construct_tcon(struct cifs_sb_info *cifs_sb, kuid_t fsuid)\n{\n\tint rc;\n\tstruct cifs_tcon *master_tcon = cifs_sb_master_tcon(cifs_sb);\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon = NULL;\n\tstruct smb_vol *vol_info;\n\n\tvol_info = kzalloc(sizeof(*vol_info), GFP_KERNEL);\n\tif (vol_info == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvol_info->local_nls = cifs_sb->local_nls;\n\tvol_info->linux_uid = fsuid;\n\tvol_info->cred_uid = fsuid;\n\tvol_info->UNC = master_tcon->treeName;\n\tvol_info->retry = master_tcon->retry;\n\tvol_info->nocase = master_tcon->nocase;\n\tvol_info->local_lease = master_tcon->local_lease;\n\tvol_info->no_linux_ext = !master_tcon->unix_ext;\n\n\trc = cifs_set_vol_auth(vol_info, master_tcon->ses);\n\tif (rc) {\n\t\ttcon = ERR_PTR(rc);\n\t\tgoto out;\n\t}\n\n\t/* get a reference for the same TCP session */\n\tspin_lock(&cifs_tcp_ses_lock);\n\t++master_tcon->ses->server->srv_count;\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tses = cifs_get_smb_ses(master_tcon->ses->server, vol_info);\n\tif (IS_ERR(ses)) {\n\t\ttcon = (struct cifs_tcon *)ses;\n\t\tcifs_put_tcp_session(master_tcon->ses->server);\n\t\tgoto out;\n\t}\n\n\ttcon = cifs_get_tcon(ses, vol_info);\n\tif (IS_ERR(tcon)) {\n\t\tcifs_put_smb_ses(ses);\n\t\tgoto out;\n\t}\n\n\tif (cap_unix(ses))\n\t\treset_cifs_unix_caps(0, tcon, NULL, vol_info);\nout:\n\tkfree(vol_info->username);\n\tkfree(vol_info->password);\n\tkfree(vol_info);\n\n\treturn tcon;\n}\n\nstruct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}\n\nstatic int\ncifs_sb_tcon_pending_wait(void *unused)\n{\n\tschedule();\n\treturn signal_pending(current) ? -ERESTARTSYS : 0;\n}\n\n/* find and return a tlink with given uid */\nstatic struct tcon_link *\ntlink_rb_search(struct rb_root *root, kuid_t uid)\n{\n\tstruct rb_node *node = root->rb_node;\n\tstruct tcon_link *tlink;\n\n\twhile (node) {\n\t\ttlink = rb_entry(node, struct tcon_link, tl_rbnode);\n\n\t\tif (uid_gt(tlink->tl_uid, uid))\n\t\t\tnode = node->rb_left;\n\t\telse if (uid_lt(tlink->tl_uid, uid))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn tlink;\n\t}\n\treturn NULL;\n}\n\n/* insert a tcon_link into the tree */\nstatic void\ntlink_rb_insert(struct rb_root *root, struct tcon_link *new_tlink)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct tcon_link *tlink;\n\n\twhile (*new) {\n\t\ttlink = rb_entry(*new, struct tcon_link, tl_rbnode);\n\t\tparent = *new;\n\n\t\tif (uid_gt(tlink->tl_uid, new_tlink->tl_uid))\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_tlink->tl_rbnode, parent, new);\n\trb_insert_color(&new_tlink->tl_rbnode, root);\n}\n\n/*\n * Find or construct an appropriate tcon given a cifs_sb and the fsuid of the\n * current task.\n *\n * If the superblock doesn't refer to a multiuser mount, then just return\n * the master tcon for the mount.\n *\n * First, search the rbtree for an existing tcon for this fsuid. If one\n * exists, then check to see if it's pending construction. If it is then wait\n * for construction to complete. Once it's no longer pending, check to see if\n * it failed and either return an error or retry construction, depending on\n * the timeout.\n *\n * If one doesn't exist then insert a new tcon_link struct into the tree and\n * try to construct a new one.\n */\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  cifs_sb_tcon_pending_wait,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}\n\n/*\n * periodic workqueue job that scans tcon_tree for a superblock and closes\n * out tcons.\n */\nstatic void\ncifs_prune_tlinks(struct work_struct *work)\n{\n\tstruct cifs_sb_info *cifs_sb = container_of(work, struct cifs_sb_info,\n\t\t\t\t\t\t    prune_tlinks.work);\n\tstruct rb_root *root = &cifs_sb->tlink_tree;\n\tstruct rb_node *node = rb_first(root);\n\tstruct rb_node *tmp;\n\tstruct tcon_link *tlink;\n\n\t/*\n\t * Because we drop the spinlock in the loop in order to put the tlink\n\t * it's not guarded against removal of links from the tree. The only\n\t * places that remove entries from the tree are this function and\n\t * umounts. Because this function is non-reentrant and is canceled\n\t * before umount can proceed, this is safe.\n\t */\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\tnode = rb_first(root);\n\twhile (node != NULL) {\n\t\ttmp = node;\n\t\tnode = rb_next(tmp);\n\t\ttlink = rb_entry(tmp, struct tcon_link, tl_rbnode);\n\n\t\tif (test_bit(TCON_LINK_MASTER, &tlink->tl_flags) ||\n\t\t    atomic_read(&tlink->tl_count) != 0 ||\n\t\t    time_after(tlink->tl_time + TLINK_IDLE_EXPIRE, jiffies))\n\t\t\tcontinue;\n\n\t\tcifs_get_tlink(tlink);\n\t\tclear_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\t\trb_erase(tmp, root);\n\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\tcifs_put_tlink(tlink);\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t}\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(cifsiod_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n}\n"], "filenames": ["fs/cifs/connect.c"], "buggy_code_start_loc": [3282], "buggy_code_end_loc": [3284], "fixing_code_start_loc": [3282], "fixing_code_end_loc": [3284], "type": "CWE-189", "message": "Off-by-one error in the build_unc_path_to_root function in fs/cifs/connect.c in the Linux kernel before 3.9.6 allows remote attackers to cause a denial of service (memory corruption and system crash) via a DFS share mount operation that triggers use of an unexpected DFS referral name length.", "other": {"cve": {"id": "CVE-2013-4247", "sourceIdentifier": "secalert@redhat.com", "published": "2013-08-25T03:27:32.960", "lastModified": "2023-02-13T04:45:10.230", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Off-by-one error in the build_unc_path_to_root function in fs/cifs/connect.c in the Linux kernel before 3.9.6 allows remote attackers to cause a denial of service (memory corruption and system crash) via a DFS share mount operation that triggers use of an unexpected DFS referral name length."}, {"lang": "es", "value": "Error de superaci\u00f3n de l\u00edmite (off-by-one) en la funci\u00f3n build_unc_path_to_root en fs/cifs/connect.c en Linux kernel anterior a v3.9.6 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (corrupci\u00f3n de memoria y ca\u00edda del sistema) a trav\u00e9s de una operaci\u00f3n de montaje DFS compartido lo que provoca el uso de un DFS inesperado referido a la longitud del nombre."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-189"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.8", "versionEndExcluding": "3.9.6", "matchCriteriaId": "0C23085C-93BE-474E-845B-3BD66661D58F"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=1fc29bacedeabb278080e31bb9c1ecb49f143c3b", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.9.6", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2013/08/14/10", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=998401", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/1fc29bacedeabb278080e31bb9c1ecb49f143c3b", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/1fc29bacedeabb278080e31bb9c1ecb49f143c3b"}}