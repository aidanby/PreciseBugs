{"buggy_code": ["#VERSION,2.09\n###############################################################################\n#  Copyright (C) 2006 Chris Sullo\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; version 2\n#  of the License only.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to\n#  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n###############################################################################\n# PURPOSE:\n# Check for outdated items in banner\n###############################################################################\nsub nikto_outdated_init {\n    my $id = { name        => \"outdated\",\n               full_name   => \"Outdated\",\n               author      => \"Sullo\",\n               description => \"Checks to see whether the web server is the latest version.\",\n               copyright   => \"2008 Chris Sullo\",\n               hooks       => { scan => { method => \\&nikto_outdated, }, },\n               };\n    return $id;\n}\n\nsub nikto_outdated {\n    my ($mark) = @_;\n    return if $mark->{'terminate'};\n\n    # Process banner to populate @BUILDITEMS for later eval\n\n    # If banner has nothing that can be a version... return\n    if ($mark->{'banner'} !~ /(?:\\d|\\/|\\.)/) { return; }\n\n    # If Apache, split on space...\n    elsif (   ($mark->{'banner'} =~ /apache/i)\n           || (($mark->{'banner'} =~ /\\s/) && ($mark->{'banner'} =~ /\\//))) {\n        foreach my $item (split(/ /, $mark->{'banner'})) {\n            $mark->{'components'}->{$item} = 1;\n        }\n    }\n\n    # Some specific (and common) banner processing\n    # WebLogic: strip all the date info...\n    elsif ($mark->{'banner'} =~ /weblogic/i) {\n        my @T = split(/ /, $mark->{'banner'});\n        $mark->{'components'}->{ $T[0] . '\\/' . $T[1] } = 1;\n    }\n\n    # SiteScope: strip all the date info...\n    elsif ($mark->{'banner'} =~ /sitescope/i) {\n        my @T = split(/ /, $mark->{'banner'});\n        $mark->{'components'}->{ $T[0] } = 1;\n    }\n\n    # Jetty: strip the ( ) away:\n    elsif ($mark->{'banner'} =~ /jetty\\(/i) {\n        $mark->{'banner'} =~ /Jetty\\(([0-9a-zA-Z.\\-]+)\\)/i;\n        $mark->{'components'}->{ 'Jetty/' . $1 } = 1;\n    }\n\n    # Some, like WEBrick, have multiple items but no spaces\n    elsif (($mark->{'banner'} !~ /\\s/) && ($mark->{'banner'} =~ /\\/.*\\//) && ($mark->{'banner'} =~ /\\(/)) {\n\n        # try converting () t spaces\n        foreach my $item (split(/[\\(\\)]/, $mark->{'banner'})) {\n            $mark->{'components'}->{$item} = 1;\n        }\n    }\n\n    # Finally, unknown banners\n    else {\n\n        # use the last non 0-9 . a-z char as a sepr (' ', '-', '_' etc)\n        my $sepr = $mark->{'banner'};\n        $sepr =~ s/[a-zA-Z0-9\\.\\(\\)]//gi;\n        if ($sepr eq '') {\n            $MATCHSTRING = $mark->{'banner'};\n        }\n        else {\n            $sepr = substr($sepr, (length($sepr) - 1), 1);\n\n            # break up ID string on $sepr\n            my @T = split(/$sepr/, $mark->{'banner'});\n\n            # assume last is version...\n            for ($i = 0 ; $i < $#T ; $i++) { $MATCHSTRING .= \"$T[$i] \"; }\n        }\n        $MATCHSTRING =~ s/\\s+$//;\n        $mark->{'components'}->{$MATCHSTRING} = 1;\n        nprint(\"Server Version String:$MATCHSTRING\", \"d\");\n    }\n\n    my ($v, $V, $BI, $k) = \"\";\n\n    # For each running component\n    foreach $BI (keys %{ $mark->{'components'} }) {\n        my $have_match = 0;\n\n        # Check it against each value from db_outdated\n        foreach $V (sort keys %OVERS) {\n            next if $V eq '';\n            if ($BI =~ /^$V/i)    # software name matched\n            {\n                $have_match = 1;\n\n                # nab version\n                foreach $k (keys %{ $OVERS{$V} }) {\n                    if ($k eq \"\")    { next; }\n                    if ($k eq \"tid\") { next; }\n                    $v = $k;\n                }\n\n                # do version check (return true if we should alert)\n                if (vereval($v, $BI, $V, $mark)) {\n                    my $msg = $OVERS{$V}{$v};\n                    $msg =~ s/\\@RUNNING_VER/$BI/g;\n                    $msg =~ s/\\@CURRENT_VER/$v/g;\n                    chomp($msg);\n                    add_vulnerability($mark, $msg, $OVERS{$V}{'tid'}, 0, \"HEAD\", \"/\");\n                }\n            }\n        }\n        if (!$have_match) { $mark->{'components'}->{'$BI'} = 2; }\n    }\n    return;\n}\n\n# do version evaluation\n# arguments:\n#\t0: latest version as defined in db_outdated\n#\t1: running item being evaluated\n#\t2: item being matched against in db_outdated\n#\t3: mark hash\nsub vereval {\n\n    # split both by last char of $_[2], as it is the name to version separator\n    my $sepr = substr($_[2], (length($_[2]) - 1), 1);\n    nprint(\"nikto_outdated.plugin: verstring: $_[2], sepr:$sepr\", \"d\");\n\n    my $CURRENT      = lc($_[0]);\n    my $RUNNING      = lc($_[1]);\n    my $CURRENT_ORIG = $CURRENT;\n    my $RUNNING_ORIG = $RUNNING;\n    my $mark         = $_[3];\n\n    nprint(\"nikto_outdated.plugin: \\$CURRENT:$CURRENT:\\$RUNNING:$RUNNING:\", \"d\");\n\n    my @T = split(/$sepr/, $CURRENT);\n    $CURRENT = $T[$#T];                    # should be version...\n    @T       = split(/$sepr/, $RUNNING);\n    $RUNNING = $T[$#T];                    # should be version...\n\n    # convert alphas to numerics so we can do a real comparison\n    $CURRENT =~ s/([^0-9\\.]){1}/\".\" . ord($1) . \".\"/eg;\n    $RUNNING =~ s/([^0-9\\.]){1}/\".\" . ord($1) . \".\"/eg;\n    $RUNNING =~ s/\\.+/\\./g;\n    $CURRENT =~ s/\\.+/\\./g;\n    $RUNNING =~ s/^\\.//;\n    $CURRENT =~ s/^\\.//;\n    $RUNNING =~ s/\\.$//;\n    $CURRENT =~ s/\\.$//;\n\n    nprint(\"nikto_outdated.plugin: \\$CURRENT:$CURRENT:\\$RUNNING:$RUNNING\\: (after numberifcation)\",\n           \"d\");\n\n    if (($CURRENT !~ /[a-z]/) && ($RUNNING !~ /[a-z]/)) {\n        @CUR = split(/\\./, $CURRENT);\n        @RUN = split(/\\./, $RUNNING);\n    }\n    else {\n        @CUR = split(//, $CURRENT);\n        @RUN = split(//, $RUNNING);\n    }\n\n    # start with 0... eval each in turn...\n    for (my $i = 0 ; $i <= $#CUR ; $i++) {\n        nprint(\"nikto_outdated.plugin: major compare: \\$CUR[$i]:$CUR[$i]: \\$RUN[$i]:$RUN[$i]:\",\n               \"d\");\n        if ($CUR[$i] > $RUN[$i]) { return 1; }    # running is older\n        if (($CUR[$i] ne \"\") && ($RUN[$i] eq \"\")) { return 1; }    # running is older\n        if ($CUR[$i] < $RUN[$i])                                   # running is newer\n        {\n            my $string = $_[1];\n            $string =~ s/\\s/\\%20/g;\n            $mark->{'components'}->{$string} = 2;\n            return 0;\n        }\n    }\n    return 0;    # running is the same version if we make it here\n}\n\n1;\n", "#VERSION,2.07\n###############################################################################\n#  Copyright (C) 2007 Chris Sullo\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; version 2\n#  of the License only.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to\n#  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n###############################################################################\n# PURPOSE:\n# CSV Reporting\n###############################################################################\nsub nikto_report_csv_init {\n    my $id = { name              => \"report_csv\",\n               full_name         => \"CSV reports\",\n               author            => \"Tautology\",\n               description       => \"Produces a CSV report.\",\n               report_head       => \\&csv_open,\n               report_host_start => \\&csv_host_start,\n               report_item       => \\&csv_item,\n               report_format     => 'csv',\n               copyright         => \"2008 Chris Sullo\"\n               };\n    return $id;\n}\n\n###############################################################################\n# open output file\nsub csv_open {\n    my ($file) = @_;\n    print STDERR \"+ ERROR: Output file not specified.\\n\" if $file eq '';\n\n    # Open file and produce header\n    open(OUT, \">>$file\") || die print STDERR \"+ ERROR: Unable to open '$file' for write: $@\\n\";\n\n    # Write header\n    print OUT \"\\\"$VARIABLES{'name'} - v$VARIABLES{'version'}/$VARIABLES{'core_version'}\\\"\\n\";\n    return OUT;\n}\n\n###############################################################################\n# start output\nsub csv_host_start {\n    my ($handle, $mark) = @_;\n    $mark->{'banner'} =~ s/\"/\\\\\"/g;\n    my $hostname = $mark->{'vhost'} ? $mark->{'vhost'} : $mark->{'hostname'};\n    print $handle \"\\\"$hostname\\\",\"\n      . \"\\\"$mark->{'ip'}\\\",\"\n      . \"\\\"$mark->{'port'}\\\",\" . \"\\\"\\\",\" . \"\\\"\\\",\" . \"\\\"\\\",\"\n      . \"\\\"$mark->{'banner'}\\\"\\n\";\n    return;\n}\n\n###############################################################################\n# print an item\nsub csv_item {\n    my ($handle, $mark, $item) = @_;\n    foreach my $uri (split(' ', $item->{'uri'})) {\n        my $line = '';\n    \tmy $hostname = $item->{'mark'}->{'vhost'} ? $item->{'mark'}->{'vhost'} : $item->{'mark'}->{'hostname'};\n        $line .= \"\\\"$hostname\\\",\";\n        $line .= \"\\\"$item->{'mark'}->{'ip'}\\\",\";\n        $line .= \"\\\"$item->{'mark'}->{'port'}\\\",\";\n\n        $line .= \"\\\"\";\n        if ($item->{'osvdb'} ne '') { $line .= \"OSVDB-\" . $item->{'osvdb'}; }\n        $line .= \"\\\",\";\n\n        $line .= \"\\\"\";\n        if ($item->{'method'} ne '') { $line .= $item->{'method'}; }\n        $line .= \"\\\",\";\n\n        $line .= \"\\\"\";\n        if (($uri ne '') && ($mark->{'root'} ne '') && ($uri !~ /^$mark->{'root'}/))\n\t\t\t{ $line .= $mark->{'root'} . $uri; }\n\t\telse { $line .= $uri; }\n        $line .= \"\\\",\";\n\t\n\t\tmy $msg = $item->{'message'};\n\t\t$uri=quotemeta($uri);\n\t\tmy $root = quotemeta($mark->{'root'});\n\t\t$msg =~ s/^$uri:\\s//;\n\t\t$msg =~ s/^$root$uri:\\s//;\n        $msg =~ s/\"/\\\\\"/g;\n        $line .= \"\\\"$msg\\\"\";\n        print $handle \"$line\\n\";\n    }\n}\n\n1;\n"], "fixing_code": ["#VERSION,2.09\n###############################################################################\n#  Copyright (C) 2006 Chris Sullo\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; version 2\n#  of the License only.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to\n#  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n###############################################################################\n# PURPOSE:\n# Check for outdated items in banner\n###############################################################################\nsub nikto_outdated_init {\n    my $id = { name        => \"outdated\",\n               full_name   => \"Outdated\",\n               author      => \"Sullo\",\n               description => \"Checks to see whether the web server is the latest version.\",\n               copyright   => \"2008 Chris Sullo\",\n               hooks       => { scan => { method => \\&nikto_outdated, }, },\n               };\n    return $id;\n}\n\nsub nikto_outdated {\n    my ($mark) = @_;\n    return if $mark->{'terminate'};\n\n    # Process banner to populate @BUILDITEMS for later eval\n\n    # If banner has nothing that can be a version... return\n    if ($mark->{'banner'} !~ /(?:\\d|\\/|\\.)/) { return; }\n\n    # If Apache, split on space...\n    elsif (   ($mark->{'banner'} =~ /apache/i)\n           || (($mark->{'banner'} =~ /\\s/) && ($mark->{'banner'} =~ /\\//))) {\n        foreach my $item (split(/ /, $mark->{'banner'})) {\n            $mark->{'components'}->{$item} = 1;\n        }\n    }\n\n    # Some specific (and common) banner processing\n    # WebLogic: strip all the date info...\n    elsif ($mark->{'banner'} =~ /weblogic/i) {\n        my @T = split(/ /, $mark->{'banner'});\n        $mark->{'components'}->{ $T[0] . '\\/' . $T[1] } = 1;\n    }\n\n    # SiteScope: strip all the date info...\n    elsif ($mark->{'banner'} =~ /sitescope/i) {\n        my @T = split(/ /, $mark->{'banner'});\n        $mark->{'components'}->{ $T[0] } = 1;\n    }\n\n    # Jetty: strip the ( ) away:\n    elsif ($mark->{'banner'} =~ /jetty\\(/i) {\n        $mark->{'banner'} =~ /Jetty\\(([0-9a-zA-Z.\\-]+)\\)/i;\n        $mark->{'components'}->{ 'Jetty/' . $1 } = 1;\n    }\n\n    # Some, like WEBrick, have multiple items but no spaces\n    elsif (($mark->{'banner'} !~ /\\s/) && ($mark->{'banner'} =~ /\\/.*\\//) && ($mark->{'banner'} =~ /\\(/)) {\n\n        # try converting () t spaces\n        foreach my $item (split(/[\\(\\)]/, $mark->{'banner'})) {\n            $mark->{'components'}->{$item} = 1;\n        }\n    }\n\n    # Finally, unknown banners\n    else {\n\n        # use the last non 0-9 . a-z char as a sepr (' ', '-', '_' etc)\n        my $sepr = $mark->{'banner'};\n        $sepr =~ s/[a-zA-Z0-9\\.\\(\\)]//gi;\n        if ($sepr eq '') {\n            $MATCHSTRING = $mark->{'banner'};\n        }\n        else {\n            $sepr = substr($sepr, (length($sepr) - 1), 1);\n\n            # break up ID string on $sepr\n            my @T = split(/\\\\$sepr/, $mark->{'banner'});\n\n            # assume last is version...\n            for ($i = 0 ; $i < $#T ; $i++) { $MATCHSTRING .= \"$T[$i] \"; }\n        }\n        $MATCHSTRING =~ s/\\s+$//;\n        $mark->{'components'}->{$MATCHSTRING} = 1;\n        nprint(\"Server Version String:$MATCHSTRING\", \"d\");\n    }\n\n    my ($v, $V, $BI, $k) = \"\";\n\n    # For each running component\n    foreach $BI (keys %{ $mark->{'components'} }) {\n        my $have_match = 0;\n\n        # Check it against each value from db_outdated\n        foreach $V (sort keys %OVERS) {\n            next if $V eq '';\n            if ($BI =~ /^$V/i)    # software name matched\n            {\n                $have_match = 1;\n\n                # nab version\n                foreach $k (keys %{ $OVERS{$V} }) {\n                    if ($k eq \"\")    { next; }\n                    if ($k eq \"tid\") { next; }\n                    $v = $k;\n                }\n\n                # do version check (return true if we should alert)\n                if (vereval($v, $BI, $V, $mark)) {\n                    my $msg = $OVERS{$V}{$v};\n                    $msg =~ s/\\@RUNNING_VER/$BI/g;\n                    $msg =~ s/\\@CURRENT_VER/$v/g;\n                    chomp($msg);\n                    add_vulnerability($mark, $msg, $OVERS{$V}{'tid'}, 0, \"HEAD\", \"/\");\n                }\n            }\n        }\n        if (!$have_match) { $mark->{'components'}->{'$BI'} = 2; }\n    }\n    return;\n}\n\n# do version evaluation\n# arguments:\n#\t0: latest version as defined in db_outdated\n#\t1: running item being evaluated\n#\t2: item being matched against in db_outdated\n#\t3: mark hash\nsub vereval {\n\n    # split both by last char of $_[2], as it is the name to version separator\n    my $sepr = substr($_[2], (length($_[2]) - 1), 1);\n    nprint(\"nikto_outdated.plugin: verstring: $_[2], sepr:$sepr\", \"d\");\n\n    my $CURRENT      = lc($_[0]);\n    my $RUNNING      = lc($_[1]);\n    my $CURRENT_ORIG = $CURRENT;\n    my $RUNNING_ORIG = $RUNNING;\n    my $mark         = $_[3];\n\n    nprint(\"nikto_outdated.plugin: \\$CURRENT:$CURRENT:\\$RUNNING:$RUNNING:\", \"d\");\n\n    my @T = split(/$sepr/, $CURRENT);\n    $CURRENT = $T[$#T];                    # should be version...\n    @T       = split(/$sepr/, $RUNNING);\n    $RUNNING = $T[$#T];                    # should be version...\n\n    # convert alphas to numerics so we can do a real comparison\n    $CURRENT =~ s/([^0-9\\.]){1}/\".\" . ord($1) . \".\"/eg;\n    $RUNNING =~ s/([^0-9\\.]){1}/\".\" . ord($1) . \".\"/eg;\n    $RUNNING =~ s/\\.+/\\./g;\n    $CURRENT =~ s/\\.+/\\./g;\n    $RUNNING =~ s/^\\.//;\n    $CURRENT =~ s/^\\.//;\n    $RUNNING =~ s/\\.$//;\n    $CURRENT =~ s/\\.$//;\n\n    nprint(\"nikto_outdated.plugin: \\$CURRENT:$CURRENT:\\$RUNNING:$RUNNING\\: (after numberifcation)\",\n           \"d\");\n\n    if (($CURRENT !~ /[a-z]/) && ($RUNNING !~ /[a-z]/)) {\n        @CUR = split(/\\./, $CURRENT);\n        @RUN = split(/\\./, $RUNNING);\n    }\n    else {\n        @CUR = split(//, $CURRENT);\n        @RUN = split(//, $RUNNING);\n    }\n\n    # start with 0... eval each in turn...\n    for (my $i = 0 ; $i <= $#CUR ; $i++) {\n        nprint(\"nikto_outdated.plugin: major compare: \\$CUR[$i]:$CUR[$i]: \\$RUN[$i]:$RUN[$i]:\",\n               \"d\");\n        if ($CUR[$i] > $RUN[$i]) { return 1; }    # running is older\n        if (($CUR[$i] ne \"\") && ($RUN[$i] eq \"\")) { return 1; }    # running is older\n        if ($CUR[$i] < $RUN[$i])                                   # running is newer\n        {\n            my $string = $_[1];\n            $string =~ s/\\s/\\%20/g;\n            $mark->{'components'}->{$string} = 2;\n            return 0;\n        }\n    }\n    return 0;    # running is the same version if we make it here\n}\n\n1;\n", "#VERSION,2.07\n###############################################################################\n#  Copyright (C) 2007 Chris Sullo\n#\n#  This program is free software; you can redistribute it and/or\n#  modify it under the terms of the GNU General Public License\n#  as published by the Free Software Foundation; version 2\n#  of the License only.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program; if not, write to\n#  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n###############################################################################\n# PURPOSE:\n# CSV Reporting\n###############################################################################\nsub nikto_report_csv_init {\n    my $id = { name              => \"report_csv\",\n               full_name         => \"CSV reports\",\n               author            => \"Tautology\",\n               description       => \"Produces a CSV report.\",\n               report_head       => \\&csv_open,\n               report_host_start => \\&csv_host_start,\n               report_item       => \\&csv_item,\n               report_format     => 'csv',\n               copyright         => \"2008 Chris Sullo\"\n               };\n    return $id;\n}\n\n###############################################################################\n# open output file\nsub csv_open {\n    my ($file) = @_;\n    print STDERR \"+ ERROR: Output file not specified.\\n\" if $file eq '';\n\n    # Open file and produce header\n    open(OUT, \">>$file\") || die print STDERR \"+ ERROR: Unable to open '$file' for write: $@\\n\";\n\n    # Write header\n    print OUT \"\\\"$VARIABLES{'name'} - v$VARIABLES{'version'}/$VARIABLES{'core_version'}\\\"\\n\";\n    return OUT;\n}\n\n###############################################################################\n# start output\nsub csv_host_start {\n    my ($handle, $mark) = @_;\n    $mark->{'banner'} =~ s/\"/\\\\\"/g;\n    my $hostname = $mark->{'vhost'} ? $mark->{'vhost'} : $mark->{'hostname'};\n    print $handle \"\\\"\" . csv_safecell($hostname) . \"\\\",\"\n      . \"\\\"\" . csv_safecell($mark->{'ip'}) . \"\\\",\"\n      . \"\\\"\" . csv_safecell($mark->{'port'}) . \"\\\",\" . \"\\\"\\\",\" . \"\\\"\\\",\" . \"\\\"\\\",\"\n      #. \"\\\"\" . $mark->{'banner'} . \"\\\"\\n\";\n      . \"\\\"\" . csv_safecell($mark->{'banner'}) . \"\\\"\\n\";\n    return;\n}\n\n###############################################################################\n# print an item\nsub csv_item {\n    my ($handle, $mark, $item) = @_;\n    foreach my $uri (split(' ', $item->{'uri'})) {\n        my $line = '';\n    \tmy $hostname = $item->{'mark'}->{'vhost'} ? $item->{'mark'}->{'vhost'} : $item->{'mark'}->{'hostname'};\n        $line .= \"\\\"\" . csv_safecell($hostname) . \"\\\",\";\n        $line .= \"\\\"\" . csv_safecell($item->{'mark'}->{'ip'}) . \\\",\";\n        $line .= \"\\\"\" . csv_safecell($item->{'mark'}->{'port'}) . \"\\\",\";\n\n        $line .= \"\\\"\";\n        if ($item->{'osvdb'} ne '') { $line .= \"OSVDB-\" . $item->{'osvdb'}; }\n        $line .= \"\\\",\";\n\n        $line .= \"\\\"\";\n        if ($item->{'method'} ne '') { $line .= csv_safecell($item->{'method'}); }\n        $line .= \"\\\",\";\n\n        $line .= \"\\\"\";\n        if (($uri ne '') && ($mark->{'root'} ne '') && ($uri !~ /^$mark->{'root'}/))\n\t\t\t{ $line .= csv_safecell($mark->{'root'}) . $uri; }\n\t\telse { $line .= csv_safecell($uri); }\n        $line .= \"\\\",\";\n\t\n\tmy $msg = $item->{'message'};\n\t$uri=quotemeta($uri);\n\tmy $root = quotemeta($mark->{'root'});\n\t$msg =~ s/^$uri:\\s//;\n\t$msg =~ s/^$root$uri:\\s//;\n        $msg =~ s/\"/\\\\\"/g;\n        $line .= \"\\\"\" . csv_safecell($msg) .\"\\\"\";\n        print $handle \"$line\\n\";\n    }\n}\n\n###############################################################################\n# prevent CSV injection attacks\nsub csv_safecell {\n    my $celldata = $_[0] || return;\n    if ($celldata =~ /^[=+@-]/) { $celldata = \"'\" . $celldata; }\n    return $celldata;\n}\n\n1;\n"], "filenames": ["program/plugins/nikto_outdated.plugin", "program/plugins/nikto_report_csv.plugin"], "buggy_code_start_loc": [91, 56], "buggy_code_end_loc": [92, 98], "fixing_code_start_loc": [91, 56], "fixing_code_end_loc": [92, 108], "type": "CWE-1236", "message": "CSV Injection vulnerability in Nikto 2.1.6 and earlier allows remote attackers to inject arbitrary OS commands via the Server field in an HTTP response header, which is directly injected into a CSV report.", "other": {"cve": {"id": "CVE-2018-11652", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-01T15:29:00.517", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "CSV Injection vulnerability in Nikto 2.1.6 and earlier allows remote attackers to inject arbitrary OS commands via the Server field in an HTTP response header, which is directly injected into a CSV report."}, {"lang": "es", "value": "Vulnerabilidad de inyecci\u00f3n CSV en Nikto en versiones 2.1.6 y anteriores permite que atacantes remotos inyecten comandos arbitrarios del sistema operativo mediante el campo Server en una cabecera de respuesta HTTP, que se inyecta directamente en un informe CSV."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1236"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cirt.net:nikto:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.1.6", "matchCriteriaId": "6F787B89-4DD6-4BEC-A6A7-0529BC27C16E"}]}]}], "references": [{"url": "https://github.com/sullo/nikto/commit/e759b3300aace5314fe3d30800c8bd83c81c29f7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/44899/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/sullo/nikto/commit/e759b3300aace5314fe3d30800c8bd83c81c29f7"}}