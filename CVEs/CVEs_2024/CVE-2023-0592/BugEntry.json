{"buggy_code": ["#!/usr/bin/env python3\n\nimport argparse\nimport struct\nimport stat\nimport os\nimport sys\nimport zlib\nimport binascii\nimport lzo\nimport mmap\nimport contextlib\nimport cstruct\n\nfrom jefferson import jffs2_lzma, rtime\n\n\ndef PAD(x):\n    return ((x) + 3) & ~3\n\n\nJFFS2_OLD_MAGIC_BITMASK = 0x1984\nJFFS2_MAGIC_BITMASK = 0x1985\nJFFS2_COMPR_NONE = 0x00\nJFFS2_COMPR_ZERO = 0x01\nJFFS2_COMPR_RTIME = 0x02\nJFFS2_COMPR_RUBINMIPS = 0x03\nJFFS2_COMPR_COPY = 0x04\nJFFS2_COMPR_DYNRUBIN = 0x05\nJFFS2_COMPR_ZLIB = 0x06\nJFFS2_COMPR_LZO = 0x07\nJFFS2_COMPR_LZMA = 0x08\n\n# /* Compatibility flags. */\nJFFS2_COMPAT_MASK = 0xC000  # /* What do to if an unknown nodetype is found */\nJFFS2_NODE_ACCURATE = 0x2000\n# /* INCOMPAT: Fail to mount the filesystem */\nJFFS2_FEATURE_INCOMPAT = 0xC000\n# /* ROCOMPAT: Mount read-only */\nJFFS2_FEATURE_ROCOMPAT = 0x8000\n# /* RWCOMPAT_COPY: Mount read/write, and copy the node when it's GC'd */\nJFFS2_FEATURE_RWCOMPAT_COPY = 0x4000\n# /* RWCOMPAT_DELETE: Mount read/write, and delete the node when it's GC'd */\nJFFS2_FEATURE_RWCOMPAT_DELETE = 0x0000\n\nJFFS2_NODETYPE_DIRENT = JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 1\nJFFS2_NODETYPE_INODE = JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 2\nJFFS2_NODETYPE_CLEANMARKER = JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 3\nJFFS2_NODETYPE_PADDING = JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 4\nJFFS2_NODETYPE_SUMMARY = JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 6\nJFFS2_NODETYPE_XATTR = JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 8\nJFFS2_NODETYPE_XREF = JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 9\n\ndef mtd_crc(data):\n    return (binascii.crc32(data, -1) ^ -1) & 0xFFFFFFFF\n\ndef is_safe_path(basedir, path, follow_symlinks=True):\n    if follow_symlinks:\n        matchpath = os.path.realpath(path)\n    else:\n        matchpath = os.path.abspath(path)\n    return basedir == os.path.commonpath((basedir, matchpath))\n\ncstruct.typedef(\"uint8\", \"uint8_t\")\ncstruct.typedef(\"uint16\", \"jint16_t\")\ncstruct.typedef(\"uint32\", \"jint32_t\")\ncstruct.typedef(\"uint32\", \"jmode_t\")\n\n\nclass Jffs2_unknown_node(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            /* All start like this */\n            jint16_t magic;\n            jint16_t nodetype;\n            jint32_t totlen; /* So we can skip over nodes we don't grok */\n            jint32_t hdr_crc;\n        }\n    \"\"\"\n\n    def unpack(self, data):\n        cstruct.CStruct.unpack(self, data[: self.size])\n        comp_hrd_crc = mtd_crc(data[: self.size - 4])\n\n        if comp_hrd_crc == self.hdr_crc:\n            self.hdr_crc_match = True\n        else:\n            # print(\"hdr_crc does not match!\")\n            self.hdr_crc_match = False\n\n\nclass Jffs2_raw_dirent(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            jint16_t magic;\n            jint16_t nodetype;      /* == JFFS2_NODETYPE_DIRENT */\n            jint32_t totlen;\n            jint32_t hdr_crc;\n            jint32_t pino;\n            jint32_t version;\n            jint32_t ino; /* == zero for unlink */\n            jint32_t mctime;\n            uint8_t nsize;\n            uint8_t type;\n            uint8_t unused[2];\n            jint32_t node_crc;\n            jint32_t name_crc;\n        /* uint8_t data[0]; -> name */\n        }\n    \"\"\"\n\n    def unpack(self, data, node_offset):\n        cstruct.CStruct.unpack(self, data[: self.size])\n        self.name = data[self.size : self.size + self.nsize].tobytes()\n        self.node_offset = node_offset\n\n        if mtd_crc(data[: self.size - 8]) == self.node_crc:\n            self.node_crc_match = True\n        else:\n            print(\"node_crc does not match!\")\n            self.node_crc_match = False\n\n        if mtd_crc(self.name) == self.name_crc:\n            self.name_crc_match = True\n        else:\n            print(\"data_crc does not match!\")\n            self.name_crc_match = False\n\n    def __str__(self):\n        result = []\n        for field in self.__fields__ + [\"name\", \"node_offset\"]:\n            result.append(field + \"=\" + str(getattr(self, field, None)))\n        return type(self).__name__ + \"(\" + \", \".join(result) + \")\"\n\n\nclass Jffs2_raw_inode(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            jint16_t magic;      /* A constant magic number.  */\n            jint16_t nodetype;   /* == JFFS2_NODETYPE_INODE */\n            jint32_t totlen;     /* Total length of this node (inc data, etc.) */\n            jint32_t hdr_crc;\n            jint32_t ino;        /* Inode number.  */\n            jint32_t version;    /* Version number.  */\n            jmode_t mode;       /* The file's type or mode.  */\n            jint16_t uid;        /* The file's owner.  */\n            jint16_t gid;        /* The file's group.  */\n            jint32_t isize;      /* Total resultant size of this inode (used for truncations)  */\n            jint32_t atime;      /* Last access time.  */\n            jint32_t mtime;      /* Last modification time.  */\n            jint32_t ctime;      /* Change time.  */\n            jint32_t offset;     /* Where to begin to write.  */\n            jint32_t csize;      /* (Compressed) data size */\n            jint32_t dsize;      /* Size of the node's data. (after decompression) */\n            uint8_t compr;       /* Compression algorithm used */\n            uint8_t usercompr;   /* Compression algorithm requested by the user */\n            jint16_t flags;      /* See JFFS2_INO_FLAG_* */\n            jint32_t data_crc;   /* CRC for the (compressed) data.  */\n            jint32_t node_crc;   /* CRC for the raw inode (excluding data)  */\n            /* uint8_t data[0]; */\n        }\n    \"\"\"\n\n    def unpack(self, data):\n        cstruct.CStruct.unpack(self, data[: self.size])\n\n        node_data = data[self.size : self.size + self.csize].tobytes()\n        try:\n            if self.compr == JFFS2_COMPR_NONE:\n                self.data = node_data\n            elif self.compr == JFFS2_COMPR_ZERO:\n                self.data = b\"\\x00\" * self.dsize\n            elif self.compr == JFFS2_COMPR_ZLIB:\n                self.data = zlib.decompress(node_data)\n            elif self.compr == JFFS2_COMPR_RTIME:\n                self.data = rtime.decompress(node_data, self.dsize)\n            elif self.compr == JFFS2_COMPR_LZMA:\n                self.data = jffs2_lzma.decompress(node_data, self.dsize)\n            elif self.compr == JFFS2_COMPR_LZO:\n                self.data = lzo.decompress(node_data, False, self.dsize)\n            else:\n                print(\"compression not implemented\", self)\n                print(node_data.hex()[:20])\n                self.data = node_data\n        except Exception as e:\n            print(\"Decompression error on inode {}: {}\".format(self.ino, e), file=sys.stderr)\n            self.data = b\"\\x00\" * self.dsize\n\n        if len(self.data) != self.dsize:\n            print(\"data length mismatch!\")\n\n        if mtd_crc(data[: self.size - 8]) == self.node_crc:\n            self.node_crc_match = True\n        else:\n            print(\"hdr_crc does not match!\")\n            self.node_crc_match = False\n\n        if mtd_crc(node_data) == self.data_crc:\n            self.data_crc_match = True\n        else:\n            print(\"data_crc does not match!\")\n            self.data_crc_match = False\n\n\nclass Jffs2_device_node_old(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            jint16_t old_id;\n        }\n    \"\"\"\n\n\nclass Jffs2_device_node_new(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            jint32_t new_id;\n        }\n    \"\"\"\n\n\nNODETYPES = {\n    JFFS2_FEATURE_INCOMPAT: Jffs2_unknown_node,\n    JFFS2_NODETYPE_DIRENT: Jffs2_raw_dirent,\n    JFFS2_NODETYPE_INODE: Jffs2_raw_inode,\n    JFFS2_NODETYPE_CLEANMARKER: \"JFFS2_NODETYPE_CLEANMARKER\",\n    JFFS2_NODETYPE_PADDING: \"JFFS2_NODETYPE_PADDING\",\n}\n\n\ndef set_endianness(endianness):\n    global Jffs2_device_node_new, Jffs2_device_node_old, Jffs2_unknown_node, Jffs2_raw_dirent, Jffs2_raw_inode, Jffs2_raw_summary, Jffs2_raw_xattr, Jffs2_raw_xref\n\n    Jffs2_device_node_new = Jffs2_device_node_new.parse(\n        Jffs2_device_node_new.__def__,\n        __name__=Jffs2_device_node_new.__name__,\n        __byte_order__=endianness,\n    )\n\n    Jffs2_device_node_old = Jffs2_device_node_old.parse(\n        Jffs2_device_node_old.__def__,\n        __name__=Jffs2_device_node_old.__name__,\n        __byte_order__=endianness,\n    )\n\n    Jffs2_unknown_node = Jffs2_unknown_node.parse(\n        Jffs2_unknown_node.__def__,\n        __name__=Jffs2_unknown_node.__name__,\n        __byte_order__=endianness,\n    )\n\n    Jffs2_raw_dirent = Jffs2_raw_dirent.parse(\n        Jffs2_raw_dirent.__def__,\n        __name__=Jffs2_raw_dirent.__name__,\n        __byte_order__=endianness,\n    )\n\n    Jffs2_raw_inode = Jffs2_raw_inode.parse(\n        Jffs2_raw_inode.__def__,\n        __name__=Jffs2_raw_inode.__name__,\n        __byte_order__=endianness,\n    )\n\n\ndef scan_fs(content, endianness, verbose=False):\n    pos = 0\n    jffs2_old_magic_bitmask_str = struct.pack(endianness + \"H\", JFFS2_OLD_MAGIC_BITMASK)\n    jffs2_magic_bitmask_str = struct.pack(endianness + \"H\", JFFS2_MAGIC_BITMASK)\n    content_mv = memoryview(content)\n\n    fs = {}\n    fs[JFFS2_NODETYPE_INODE] = {}\n    fs[JFFS2_NODETYPE_DIRENT] = {}\n\n    while True:\n        find_result = content.find(\n            jffs2_magic_bitmask_str, pos, len(content) - Jffs2_unknown_node.size\n        )\n        find_result_old = content.find(\n            jffs2_old_magic_bitmask_str, pos, len(content) - Jffs2_unknown_node.size\n        )\n        if find_result == -1 and find_result_old == -1:\n            break\n        if find_result != -1:\n            pos = find_result\n        else:\n            pos = find_result_old\n\n        unknown_node = Jffs2_unknown_node()\n        unknown_node.unpack(content_mv[pos : pos + unknown_node.size])\n        if not unknown_node.hdr_crc_match:\n            pos += 1\n            continue\n        offset = pos\n        pos += PAD(unknown_node.totlen)\n\n        if unknown_node.magic in [\n             JFFS2_MAGIC_BITMASK,\n             JFFS2_OLD_MAGIC_BITMASK,\n        ]:\n            if unknown_node.nodetype in NODETYPES:\n                if unknown_node.nodetype == JFFS2_NODETYPE_DIRENT:\n                    dirent = Jffs2_raw_dirent()\n                    dirent.unpack(content_mv[0 + offset :], offset)\n                    if dirent.ino in fs[JFFS2_NODETYPE_DIRENT]:\n                        if dirent.version > fs[JFFS2_NODETYPE_DIRENT][dirent.ino].version:\n                            fs[JFFS2_NODETYPE_DIRENT][dirent.ino] = dirent\n                    else:\n                        fs[JFFS2_NODETYPE_DIRENT][dirent.ino] = dirent\n                    if verbose:\n                        print(\"0x%08X:\" % (offset), dirent)\n                elif unknown_node.nodetype == JFFS2_NODETYPE_INODE:\n                    inode = Jffs2_raw_inode()\n                    inode.unpack(content_mv[0 + offset :])\n\n                    if inode.ino in fs[JFFS2_NODETYPE_INODE]:\n                        fs[JFFS2_NODETYPE_INODE][inode.ino].append(inode)\n                    else:\n                        fs[JFFS2_NODETYPE_INODE][inode.ino] = [inode]\n                    if verbose:\n                        print(\"0x%08X:\" % (offset), inode)\n                elif unknown_node.nodetype == JFFS2_NODETYPE_CLEANMARKER:\n                    pass\n                elif unknown_node.nodetype == JFFS2_NODETYPE_PADDING:\n                    pass\n                elif unknown_node.nodetype == JFFS2_NODETYPE_SUMMARY:\n                    pass\n                elif unknown_node.nodetype == JFFS2_NODETYPE_XATTR:\n                    pass\n                elif unknown_node.nodetype == JFFS2_NODETYPE_XREF:\n                    pass\n                else:\n                    print(\"Unknown node type\", unknown_node.nodetype, unknown_node)\n    content_mv.release()\n    return fs\n\n\ndef get_device(inode):\n    if not stat.S_ISBLK(inode.mode) and not stat.S_ISCHR(inode.mode):\n        return None\n\n    if inode.dsize == len(Jffs2_device_node_new):\n        node = Jffs2_device_node_new()\n        node.unpack(inode.data)\n        return os.makedev(\n            (node.new_id & 0xFFF00) >> 8,\n            (node.new_id & 0xFF) | ((node.new_id >> 12) & 0xFFF00),\n        )\n\n    if inode.dsize == len(Jffs2_device_node_old):\n        node = Jffs2_device_node_old()\n        node.unpack(inode.data)\n        return os.makedev((node.old_id >> 8) & 0xFF, node.old_id & 0xFF)\n    return None\n\ndef sort_version(item):\n    return item.version\n\ndef dump_fs(fs, target):\n    node_dict = {}\n\n    for dirent in fs[JFFS2_NODETYPE_DIRENT].values():\n        dirent.inodes = []\n        for ino, inodes in fs[JFFS2_NODETYPE_INODE].items():\n            if ino == dirent.ino:\n                dirent.inodes = sorted(inodes, key=sort_version)\n        node_dict[dirent.ino] = dirent\n\n    for dirent in fs[JFFS2_NODETYPE_DIRENT].values():\n        pnode_pino = dirent.pino\n        pnodes = []\n        for _ in range(100):\n            if pnode_pino not in node_dict:\n                break\n            pnode = node_dict[pnode_pino]\n            pnode_pino = pnode.pino\n            pnodes.append(pnode)\n        pnodes.reverse()\n\n        node_names = []\n\n        for pnode in pnodes:\n            node_names.append(pnode.name.decode())\n        node_names.append(dirent.name.decode())\n        path = \"/\".join(node_names)\n\n        target_path = os.path.realpath(os.path.join(os.getcwd(), target, path))\n\n        if not is_safe_path(target, target_path):\n            print(f\"Path traversal attempt to {target_path}, discarding.\")\n            continue\n\n        for inode in dirent.inodes:\n            try:\n                if stat.S_ISDIR(inode.mode):\n                    print(\"writing S_ISDIR\", path)\n                    if not os.path.isdir(target_path):\n                        os.makedirs(target_path)\n                elif stat.S_ISLNK(inode.mode):\n                    print(\"writing S_ISLNK\", path)\n                    if not os.path.islink(target_path):\n                        if os.path.exists(target_path):\n                            continue\n                        os.symlink(inode.data, target_path)\n                elif stat.S_ISREG(inode.mode):\n                    print(\"writing S_ISREG\", path)\n                    if not os.path.isfile(target_path):\n                        if not os.path.isdir(os.path.dirname(target_path)):\n                            os.makedirs(os.path.dirname(target_path))\n                        with open(target_path, \"wb\") as fd:\n                            for inode in dirent.inodes:\n                                fd.seek(inode.offset)\n                                fd.write(inode.data)\n                    os.chmod(target_path, stat.S_IMODE(inode.mode))\n                    break\n                elif stat.S_ISCHR(inode.mode):\n                    print(\"writing S_ISBLK\", path)\n                    os.mknod(target_path, inode.mode, get_device(inode))\n                elif stat.S_ISBLK(inode.mode):\n                    print(\"writing S_ISBLK\", path)\n                    os.mknod(target_path, inode.mode, get_device(inode))\n                elif stat.S_ISFIFO(inode.mode):\n                    print(\"skipping S_ISFIFO\", path)\n                elif stat.S_ISSOCK(inode.mode):\n                    print(\"skipping S_ISSOCK\", path)\n                else:\n                    print(\"unhandled inode.mode: %o\" % inode.mode, inode, dirent)\n\n            except OSError as error:\n                print(\"OS error(%i): %s\" % (error.errno, error.strerror), inode, dirent)\n\n\ndef main():\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"-v\", \"--verbose\", help=\"increase output verbosity\", action=\"store_true\"\n    )\n    parser.add_argument(\n        \"-f\", \"--force\", help=\"overwrite destination directory\", action=\"store_true\"\n    )\n    parser.add_argument(\"filesystem\", type=str, help=\"path to filesystem\")\n    parser.add_argument(\n        \"-d\",\n        \"--dest\",\n        type=str,\n        default=\"jffs2-root\",\n        help=\"destination directory (default: jffs-root)\",\n    )\n\n    args = parser.parse_args()\n    dest_path = os.path.join(os.getcwd(), args.dest)\n\n    if os.path.exists(dest_path):\n        if not args.force:\n            print(\"Destination path already exists!\")\n            return\n    else:\n        os.mkdir(dest_path)\n\n    with contextlib.ExitStack() as context_stack:\n        filesystem = context_stack.enter_context(open(args.filesystem, \"rb\"))\n        filesystem_len = os.fstat(filesystem.fileno()).st_size\n        if 0 == filesystem_len:\n            return\n        content = context_stack.enter_context(\n            mmap.mmap(filesystem.fileno(), filesystem_len, access=mmap.ACCESS_READ)\n        )\n        magic = struct.unpack(\"<H\", content[0:2])[0]\n        if magic in [JFFS2_OLD_MAGIC_BITMASK, JFFS2_MAGIC_BITMASK]:\n            endianness = cstruct.LITTLE_ENDIAN\n        else:\n            endianness = cstruct.BIG_ENDIAN\n\n        set_endianness(endianness)\n\n        fs = scan_fs(content, endianness, verbose=args.verbose)\n        print(\"dumping fs to %s (endianness: %s)\" % (dest_path, endianness))\n        for key, value in fs.items():\n            print(\"%s count: %i\" % (NODETYPES[key].__name__, len(value)))\n\n        if not os.path.exists(dest_path):\n            os.mkdir(dest_path)\n\n        dump_fs(fs, dest_path)\n        print(\"-\" * 10)\n\nif __name__ == \"__main__\":\n    main()\n"], "fixing_code": ["#!/usr/bin/env python3\n\nimport argparse\nimport struct\nimport stat\nimport os\nimport sys\nimport zlib\nimport binascii\nimport lzo\nimport mmap\nimport contextlib\nimport cstruct\n\nfrom jefferson import jffs2_lzma, rtime\n\n\ndef PAD(x):\n    return ((x) + 3) & ~3\n\n\nJFFS2_OLD_MAGIC_BITMASK = 0x1984\nJFFS2_MAGIC_BITMASK = 0x1985\nJFFS2_COMPR_NONE = 0x00\nJFFS2_COMPR_ZERO = 0x01\nJFFS2_COMPR_RTIME = 0x02\nJFFS2_COMPR_RUBINMIPS = 0x03\nJFFS2_COMPR_COPY = 0x04\nJFFS2_COMPR_DYNRUBIN = 0x05\nJFFS2_COMPR_ZLIB = 0x06\nJFFS2_COMPR_LZO = 0x07\nJFFS2_COMPR_LZMA = 0x08\n\n# /* Compatibility flags. */\nJFFS2_COMPAT_MASK = 0xC000  # /* What do to if an unknown nodetype is found */\nJFFS2_NODE_ACCURATE = 0x2000\n# /* INCOMPAT: Fail to mount the filesystem */\nJFFS2_FEATURE_INCOMPAT = 0xC000\n# /* ROCOMPAT: Mount read-only */\nJFFS2_FEATURE_ROCOMPAT = 0x8000\n# /* RWCOMPAT_COPY: Mount read/write, and copy the node when it's GC'd */\nJFFS2_FEATURE_RWCOMPAT_COPY = 0x4000\n# /* RWCOMPAT_DELETE: Mount read/write, and delete the node when it's GC'd */\nJFFS2_FEATURE_RWCOMPAT_DELETE = 0x0000\n\nJFFS2_NODETYPE_DIRENT = JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 1\nJFFS2_NODETYPE_INODE = JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 2\nJFFS2_NODETYPE_CLEANMARKER = JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 3\nJFFS2_NODETYPE_PADDING = JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 4\nJFFS2_NODETYPE_SUMMARY = JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 6\nJFFS2_NODETYPE_XATTR = JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 8\nJFFS2_NODETYPE_XREF = JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 9\n\ndef mtd_crc(data):\n    return (binascii.crc32(data, -1) ^ -1) & 0xFFFFFFFF\n\ndef is_safe_path(basedir, real_path):\n    basedir = os.path.realpath(basedir)\n    return basedir == os.path.commonpath((basedir, real_path))\n\ncstruct.typedef(\"uint8\", \"uint8_t\")\ncstruct.typedef(\"uint16\", \"jint16_t\")\ncstruct.typedef(\"uint32\", \"jint32_t\")\ncstruct.typedef(\"uint32\", \"jmode_t\")\n\n\nclass Jffs2_unknown_node(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            /* All start like this */\n            jint16_t magic;\n            jint16_t nodetype;\n            jint32_t totlen; /* So we can skip over nodes we don't grok */\n            jint32_t hdr_crc;\n        }\n    \"\"\"\n\n    def unpack(self, data):\n        cstruct.CStruct.unpack(self, data[: self.size])\n        comp_hrd_crc = mtd_crc(data[: self.size - 4])\n\n        if comp_hrd_crc == self.hdr_crc:\n            self.hdr_crc_match = True\n        else:\n            # print(\"hdr_crc does not match!\")\n            self.hdr_crc_match = False\n\n\nclass Jffs2_raw_dirent(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            jint16_t magic;\n            jint16_t nodetype;      /* == JFFS2_NODETYPE_DIRENT */\n            jint32_t totlen;\n            jint32_t hdr_crc;\n            jint32_t pino;\n            jint32_t version;\n            jint32_t ino; /* == zero for unlink */\n            jint32_t mctime;\n            uint8_t nsize;\n            uint8_t type;\n            uint8_t unused[2];\n            jint32_t node_crc;\n            jint32_t name_crc;\n        /* uint8_t data[0]; -> name */\n        }\n    \"\"\"\n\n    def unpack(self, data, node_offset):\n        cstruct.CStruct.unpack(self, data[: self.size])\n        self.name = data[self.size : self.size + self.nsize].tobytes()\n        self.node_offset = node_offset\n\n        if mtd_crc(data[: self.size - 8]) == self.node_crc:\n            self.node_crc_match = True\n        else:\n            print(\"node_crc does not match!\")\n            self.node_crc_match = False\n\n        if mtd_crc(self.name) == self.name_crc:\n            self.name_crc_match = True\n        else:\n            print(\"data_crc does not match!\")\n            self.name_crc_match = False\n\n    def __str__(self):\n        result = []\n        for field in self.__fields__ + [\"name\", \"node_offset\"]:\n            result.append(field + \"=\" + str(getattr(self, field, None)))\n        return type(self).__name__ + \"(\" + \", \".join(result) + \")\"\n\n\nclass Jffs2_raw_inode(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            jint16_t magic;      /* A constant magic number.  */\n            jint16_t nodetype;   /* == JFFS2_NODETYPE_INODE */\n            jint32_t totlen;     /* Total length of this node (inc data, etc.) */\n            jint32_t hdr_crc;\n            jint32_t ino;        /* Inode number.  */\n            jint32_t version;    /* Version number.  */\n            jmode_t mode;       /* The file's type or mode.  */\n            jint16_t uid;        /* The file's owner.  */\n            jint16_t gid;        /* The file's group.  */\n            jint32_t isize;      /* Total resultant size of this inode (used for truncations)  */\n            jint32_t atime;      /* Last access time.  */\n            jint32_t mtime;      /* Last modification time.  */\n            jint32_t ctime;      /* Change time.  */\n            jint32_t offset;     /* Where to begin to write.  */\n            jint32_t csize;      /* (Compressed) data size */\n            jint32_t dsize;      /* Size of the node's data. (after decompression) */\n            uint8_t compr;       /* Compression algorithm used */\n            uint8_t usercompr;   /* Compression algorithm requested by the user */\n            jint16_t flags;      /* See JFFS2_INO_FLAG_* */\n            jint32_t data_crc;   /* CRC for the (compressed) data.  */\n            jint32_t node_crc;   /* CRC for the raw inode (excluding data)  */\n            /* uint8_t data[0]; */\n        }\n    \"\"\"\n\n    def unpack(self, data):\n        cstruct.CStruct.unpack(self, data[: self.size])\n\n        node_data = data[self.size : self.size + self.csize].tobytes()\n        try:\n            if self.compr == JFFS2_COMPR_NONE:\n                self.data = node_data\n            elif self.compr == JFFS2_COMPR_ZERO:\n                self.data = b\"\\x00\" * self.dsize\n            elif self.compr == JFFS2_COMPR_ZLIB:\n                self.data = zlib.decompress(node_data)\n            elif self.compr == JFFS2_COMPR_RTIME:\n                self.data = rtime.decompress(node_data, self.dsize)\n            elif self.compr == JFFS2_COMPR_LZMA:\n                self.data = jffs2_lzma.decompress(node_data, self.dsize)\n            elif self.compr == JFFS2_COMPR_LZO:\n                self.data = lzo.decompress(node_data, False, self.dsize)\n            else:\n                print(\"compression not implemented\", self)\n                print(node_data.hex()[:20])\n                self.data = node_data\n        except Exception as e:\n            print(\"Decompression error on inode {}: {}\".format(self.ino, e), file=sys.stderr)\n            self.data = b\"\\x00\" * self.dsize\n\n        if len(self.data) != self.dsize:\n            print(\"data length mismatch!\")\n\n        if mtd_crc(data[: self.size - 8]) == self.node_crc:\n            self.node_crc_match = True\n        else:\n            print(\"hdr_crc does not match!\")\n            self.node_crc_match = False\n\n        if mtd_crc(node_data) == self.data_crc:\n            self.data_crc_match = True\n        else:\n            print(\"data_crc does not match!\")\n            self.data_crc_match = False\n\n\nclass Jffs2_device_node_old(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            jint16_t old_id;\n        }\n    \"\"\"\n\n\nclass Jffs2_device_node_new(cstruct.CStruct):\n    __byte_order__ = cstruct.LITTLE_ENDIAN\n    __def__ = \"\"\"\n        struct {\n            jint32_t new_id;\n        }\n    \"\"\"\n\n\nNODETYPES = {\n    JFFS2_FEATURE_INCOMPAT: Jffs2_unknown_node,\n    JFFS2_NODETYPE_DIRENT: Jffs2_raw_dirent,\n    JFFS2_NODETYPE_INODE: Jffs2_raw_inode,\n    JFFS2_NODETYPE_CLEANMARKER: \"JFFS2_NODETYPE_CLEANMARKER\",\n    JFFS2_NODETYPE_PADDING: \"JFFS2_NODETYPE_PADDING\",\n}\n\n\ndef set_endianness(endianness):\n    global Jffs2_device_node_new, Jffs2_device_node_old, Jffs2_unknown_node, Jffs2_raw_dirent, Jffs2_raw_inode, Jffs2_raw_summary, Jffs2_raw_xattr, Jffs2_raw_xref\n\n    Jffs2_device_node_new = Jffs2_device_node_new.parse(\n        Jffs2_device_node_new.__def__,\n        __name__=Jffs2_device_node_new.__name__,\n        __byte_order__=endianness,\n    )\n\n    Jffs2_device_node_old = Jffs2_device_node_old.parse(\n        Jffs2_device_node_old.__def__,\n        __name__=Jffs2_device_node_old.__name__,\n        __byte_order__=endianness,\n    )\n\n    Jffs2_unknown_node = Jffs2_unknown_node.parse(\n        Jffs2_unknown_node.__def__,\n        __name__=Jffs2_unknown_node.__name__,\n        __byte_order__=endianness,\n    )\n\n    Jffs2_raw_dirent = Jffs2_raw_dirent.parse(\n        Jffs2_raw_dirent.__def__,\n        __name__=Jffs2_raw_dirent.__name__,\n        __byte_order__=endianness,\n    )\n\n    Jffs2_raw_inode = Jffs2_raw_inode.parse(\n        Jffs2_raw_inode.__def__,\n        __name__=Jffs2_raw_inode.__name__,\n        __byte_order__=endianness,\n    )\n\n\ndef scan_fs(content, endianness, verbose=False):\n    pos = 0\n    jffs2_old_magic_bitmask_str = struct.pack(endianness + \"H\", JFFS2_OLD_MAGIC_BITMASK)\n    jffs2_magic_bitmask_str = struct.pack(endianness + \"H\", JFFS2_MAGIC_BITMASK)\n    content_mv = memoryview(content)\n\n    fs = {}\n    fs[JFFS2_NODETYPE_INODE] = {}\n    fs[JFFS2_NODETYPE_DIRENT] = {}\n\n    while True:\n        find_result = content.find(\n            jffs2_magic_bitmask_str, pos, len(content) - Jffs2_unknown_node.size\n        )\n        find_result_old = content.find(\n            jffs2_old_magic_bitmask_str, pos, len(content) - Jffs2_unknown_node.size\n        )\n        if find_result == -1 and find_result_old == -1:\n            break\n        if find_result != -1:\n            pos = find_result\n        else:\n            pos = find_result_old\n\n        unknown_node = Jffs2_unknown_node()\n        unknown_node.unpack(content_mv[pos : pos + unknown_node.size])\n        if not unknown_node.hdr_crc_match:\n            pos += 1\n            continue\n        offset = pos\n        pos += PAD(unknown_node.totlen)\n\n        if unknown_node.magic in [\n             JFFS2_MAGIC_BITMASK,\n             JFFS2_OLD_MAGIC_BITMASK,\n        ]:\n            if unknown_node.nodetype in NODETYPES:\n                if unknown_node.nodetype == JFFS2_NODETYPE_DIRENT:\n                    dirent = Jffs2_raw_dirent()\n                    dirent.unpack(content_mv[0 + offset :], offset)\n                    if dirent.ino in fs[JFFS2_NODETYPE_DIRENT]:\n                        if dirent.version > fs[JFFS2_NODETYPE_DIRENT][dirent.ino].version:\n                            fs[JFFS2_NODETYPE_DIRENT][dirent.ino] = dirent\n                    else:\n                        fs[JFFS2_NODETYPE_DIRENT][dirent.ino] = dirent\n                    if verbose:\n                        print(\"0x%08X:\" % (offset), dirent)\n                elif unknown_node.nodetype == JFFS2_NODETYPE_INODE:\n                    inode = Jffs2_raw_inode()\n                    inode.unpack(content_mv[0 + offset :])\n\n                    if inode.ino in fs[JFFS2_NODETYPE_INODE]:\n                        fs[JFFS2_NODETYPE_INODE][inode.ino].append(inode)\n                    else:\n                        fs[JFFS2_NODETYPE_INODE][inode.ino] = [inode]\n                    if verbose:\n                        print(\"0x%08X:\" % (offset), inode)\n                elif unknown_node.nodetype == JFFS2_NODETYPE_CLEANMARKER:\n                    pass\n                elif unknown_node.nodetype == JFFS2_NODETYPE_PADDING:\n                    pass\n                elif unknown_node.nodetype == JFFS2_NODETYPE_SUMMARY:\n                    pass\n                elif unknown_node.nodetype == JFFS2_NODETYPE_XATTR:\n                    pass\n                elif unknown_node.nodetype == JFFS2_NODETYPE_XREF:\n                    pass\n                else:\n                    print(\"Unknown node type\", unknown_node.nodetype, unknown_node)\n    content_mv.release()\n    return fs\n\n\ndef get_device(inode):\n    if not stat.S_ISBLK(inode.mode) and not stat.S_ISCHR(inode.mode):\n        return None\n\n    if inode.dsize == len(Jffs2_device_node_new):\n        node = Jffs2_device_node_new()\n        node.unpack(inode.data)\n        return os.makedev(\n            (node.new_id & 0xFFF00) >> 8,\n            (node.new_id & 0xFF) | ((node.new_id >> 12) & 0xFFF00),\n        )\n\n    if inode.dsize == len(Jffs2_device_node_old):\n        node = Jffs2_device_node_old()\n        node.unpack(inode.data)\n        return os.makedev((node.old_id >> 8) & 0xFF, node.old_id & 0xFF)\n    return None\n\ndef sort_version(item):\n    return item.version\n\ndef dump_fs(fs, target):\n    node_dict = {}\n\n    for dirent in fs[JFFS2_NODETYPE_DIRENT].values():\n        dirent.inodes = []\n        for ino, inodes in fs[JFFS2_NODETYPE_INODE].items():\n            if ino == dirent.ino:\n                dirent.inodes = sorted(inodes, key=sort_version)\n        node_dict[dirent.ino] = dirent\n\n    for dirent in fs[JFFS2_NODETYPE_DIRENT].values():\n        pnode_pino = dirent.pino\n        pnodes = []\n        for _ in range(100):\n            if pnode_pino not in node_dict:\n                break\n            pnode = node_dict[pnode_pino]\n            pnode_pino = pnode.pino\n            pnodes.append(pnode)\n        pnodes.reverse()\n\n        node_names = []\n\n        for pnode in pnodes:\n            node_names.append(pnode.name.decode())\n        node_names.append(dirent.name.decode())\n        path = \"/\".join(node_names)\n\n        target_path = os.path.realpath(os.path.join(target, path))\n\n        if not is_safe_path(target, target_path):\n            print(f\"Path traversal attempt to {target_path}, discarding.\")\n            continue\n\n        for inode in dirent.inodes:\n            try:\n                if stat.S_ISDIR(inode.mode):\n                    print(\"writing S_ISDIR\", path)\n                    if not os.path.isdir(target_path):\n                        os.makedirs(target_path)\n                elif stat.S_ISLNK(inode.mode):\n                    print(\"writing S_ISLNK\", path)\n                    if not os.path.islink(target_path):\n                        if os.path.exists(target_path):\n                            continue\n                        os.symlink(inode.data, target_path)\n                elif stat.S_ISREG(inode.mode):\n                    print(\"writing S_ISREG\", path)\n                    if not os.path.isfile(target_path):\n                        if not os.path.isdir(os.path.dirname(target_path)):\n                            os.makedirs(os.path.dirname(target_path))\n                        with open(target_path, \"wb\") as fd:\n                            for inode in dirent.inodes:\n                                fd.seek(inode.offset)\n                                fd.write(inode.data)\n                    os.chmod(target_path, stat.S_IMODE(inode.mode))\n                    break\n                elif stat.S_ISCHR(inode.mode):\n                    print(\"writing S_ISBLK\", path)\n                    os.mknod(target_path, inode.mode, get_device(inode))\n                elif stat.S_ISBLK(inode.mode):\n                    print(\"writing S_ISBLK\", path)\n                    os.mknod(target_path, inode.mode, get_device(inode))\n                elif stat.S_ISFIFO(inode.mode):\n                    print(\"skipping S_ISFIFO\", path)\n                elif stat.S_ISSOCK(inode.mode):\n                    print(\"skipping S_ISSOCK\", path)\n                else:\n                    print(\"unhandled inode.mode: %o\" % inode.mode, inode, dirent)\n\n            except OSError as error:\n                print(\"OS error(%i): %s\" % (error.errno, error.strerror), inode, dirent)\n\n\ndef main():\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"-v\", \"--verbose\", help=\"increase output verbosity\", action=\"store_true\"\n    )\n    parser.add_argument(\n        \"-f\", \"--force\", help=\"overwrite destination directory\", action=\"store_true\"\n    )\n    parser.add_argument(\"filesystem\", type=str, help=\"path to filesystem\")\n    parser.add_argument(\n        \"-d\",\n        \"--dest\",\n        type=str,\n        default=\"jffs2-root\",\n        help=\"destination directory (default: jffs-root)\",\n    )\n\n    args = parser.parse_args()\n    dest_path = os.path.join(os.getcwd(), args.dest)\n\n    if os.path.exists(dest_path):\n        if not args.force:\n            print(\"Destination path already exists!\")\n            return\n    else:\n        os.mkdir(dest_path)\n\n    with contextlib.ExitStack() as context_stack:\n        filesystem = context_stack.enter_context(open(args.filesystem, \"rb\"))\n        filesystem_len = os.fstat(filesystem.fileno()).st_size\n        if 0 == filesystem_len:\n            return\n        content = context_stack.enter_context(\n            mmap.mmap(filesystem.fileno(), filesystem_len, access=mmap.ACCESS_READ)\n        )\n        magic = struct.unpack(\"<H\", content[0:2])[0]\n        if magic in [JFFS2_OLD_MAGIC_BITMASK, JFFS2_MAGIC_BITMASK]:\n            endianness = cstruct.LITTLE_ENDIAN\n        else:\n            endianness = cstruct.BIG_ENDIAN\n\n        set_endianness(endianness)\n\n        fs = scan_fs(content, endianness, verbose=args.verbose)\n        print(\"dumping fs to %s (endianness: %s)\" % (dest_path, endianness))\n        for key, value in fs.items():\n            print(\"%s count: %i\" % (NODETYPES[key].__name__, len(value)))\n\n        if not os.path.exists(dest_path):\n            os.mkdir(dest_path)\n\n        dump_fs(fs, dest_path)\n        print(\"-\" * 10)\n\nif __name__ == \"__main__\":\n    main()\n"], "filenames": ["src/scripts/jefferson"], "buggy_code_start_loc": [57], "buggy_code_end_loc": [392], "fixing_code_start_loc": [57], "fixing_code_end_loc": [389], "type": "CWE-22", "message": "A path traversal vulnerability affects jefferson's JFFS2 filesystem extractor. By crafting malicious JFFS2 files, attackers could force jefferson to write outside of the extraction directory.This issue affects jefferson: before 0.4.1.", "other": {"cve": {"id": "CVE-2023-0592", "sourceIdentifier": "research@onekey.com", "published": "2023-01-31T10:15:10.373", "lastModified": "2023-02-08T16:34:42.127", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A path traversal vulnerability affects jefferson's JFFS2 filesystem extractor. By crafting malicious JFFS2 files, attackers could force jefferson to write outside of the extraction directory.This issue affects jefferson: before 0.4.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "research@onekey.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "research@onekey.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jefferson_project:jefferson:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.4.1", "matchCriteriaId": "0F4F244F-8F65-4E92-8C70-21E27FB3D652"}]}]}], "references": [{"url": "https://github.com/sviehb/jefferson/commit/971aca1a8b3b9f4fcb4674fa9621d3349195cdc6", "source": "research@onekey.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://onekey.com/blog/security-advisory-remote-command-execution-in-binwalk/", "source": "research@onekey.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sviehb/jefferson/commit/971aca1a8b3b9f4fcb4674fa9621d3349195cdc6"}}