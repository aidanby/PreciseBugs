{"buggy_code": ["<?php\ndeclare(strict_types=1);\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\EcommerceFrameworkBundle\\Controller;\n\nuse GuzzleHttp\\ClientInterface;\nuse Knp\\Component\\Pager\\PaginatorInterface;\nuse Pimcore\\Bundle\\AdminBundle\\Security\\CsrfProtectionHandler;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\Factory;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\Model\\AbstractOrder;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\Model\\AbstractOrderItem;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\Model\\CheckoutableInterface;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\OrderManager\\Order\\Listing;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\OrderManager\\Order\\Listing\\Filter\\OrderDateTime;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\OrderManager\\Order\\Listing\\Filter\\OrderSearch;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\OrderManager\\Order\\Listing\\Filter\\ProductType;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\OrderManager\\V7\\OrderManagerInterface;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\PaymentManager\\PaymentManagerInterface;\nuse Pimcore\\Cache;\nuse Pimcore\\Controller\\KernelControllerEventInterface;\nuse Pimcore\\Controller\\UserAwareController;\nuse Pimcore\\Localization\\IntlFormatter;\nuse Pimcore\\Localization\\LocaleServiceInterface;\nuse Pimcore\\Model\\DataObject;\nuse Pimcore\\Model\\DataObject\\ClassDefinition\\Data\\ManyToOneRelation;\nuse Pimcore\\Model\\DataObject\\Concrete;\nuse Pimcore\\Model\\DataObject\\Localizedfield;\nuse Pimcore\\Model\\DataObject\\OnlineShopOrder;\nuse Pimcore\\Model\\DataObject\\OnlineShopOrderItem;\nuse Pimcore\\Model\\User;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\Event\\ControllerEvent;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\Translation\\LocaleAwareInterface;\nuse Symfony\\Contracts\\Translation\\TranslatorInterface;\n\n/**\n * Class AdminOrderController\n *\n * @internal\n *\n * @Route(\"/admin-order\")\n *\n */\nclass AdminOrderController extends UserAwareController implements KernelControllerEventInterface\n{\n    protected OrderManagerInterface $orderManager;\n\n    protected PaymentManagerInterface $paymentManager;\n\n    public function __construct(protected TranslatorInterface $translator)\n    {\n    }\n\n    public function onKernelControllerEvent(ControllerEvent $event): void\n    {\n        // set language\n        $user = $this->tokenResolver->getUser();\n\n        if ($user) {\n            if ($this->translator instanceof LocaleAwareInterface) {\n                $this->translator->setLocale($user->getLanguage());\n            }\n            $event->getRequest()->setLocale($user->getLanguage());\n        }\n\n        // enable inherited values\n        DataObject::setGetInheritedValues(true);\n        Localizedfield::setGetFallbackValues(true);\n\n        $this->orderManager = Factory::getInstance()->getOrderManager();\n        $this->paymentManager = Factory::getInstance()->getPaymentManager();\n    }\n\n    /**\n     * @Route(\"/list\", name=\"pimcore_ecommerce_backend_admin-order_list\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param IntlFormatter $formatter\n     * @param PaginatorInterface $paginator\n     *\n     * @return Response\n     */\n    public function listAction(Request $request, IntlFormatter $formatter, PaginatorInterface $paginator): Response\n    {\n        // create new order list\n        /** @var Listing $list */\n        $list = $this->orderManager->createOrderList();\n\n        // set list type\n        $list->setListType($request->get('type', $list::LIST_TYPE_ORDER));\n\n        // set order state\n        $list->setOrderState(AbstractOrder::ORDER_STATE_COMMITTED);\n\n        // add select fields\n        $list->addSelectField('order.OrderDate');\n        $list->addSelectField('order.orderNumber AS OrderNumber');\n        if ($list->getListType() == $list::LIST_TYPE_ORDER) {\n            $list->addSelectField('order.totalPrice AS TotalPrice');\n        } elseif ($list->getListType() == $list::LIST_TYPE_ORDER_ITEM) {\n            $list->addSelectField('orderItem.totalPrice AS TotalPrice');\n        }\n        $list->addSelectField('count(orderItem.id) AS Items');\n\n        // Search\n        if ($request->get('q')) {\n            $q = htmlentities($request->get('q'));\n            $search = $request->get('search');\n            switch ($search) {\n                case 'productType':\n                    $filterProductType = new ProductType();\n                    $filterProductType->setTypes([$q]);\n                    $list->addFilter($filterProductType);\n\n                    break;\n\n                case 'order':\n                default:\n                    $filterOrder = new OrderSearch();\n                    $filterOrder->setKeyword($q);\n                    $list->addFilter($filterOrder);\n\n                    break;\n            }\n        }\n\n        // add Date Filter\n        if ($request->query->has('from') === false && $request->query->has('till') === false) {\n            // als default, nehmen wir den ersten des aktuellen monats\n            $from = new \\DateTime('first day of this month');\n            $request->query->set('from', $from->format('Y-m-d'));\n        }\n\n        $filterDate = new OrderDateTime();\n        if ($request->get('from') || $request->get('till')) {\n            $from = $request->get('from') ? new \\DateTime($request->get('from')) : null;\n            $till = $request->get('till') ? new \\DateTime($request->get('till')) : null;\n            if ($till) {\n                $till->add(new \\DateInterval('P1D'));\n            }\n\n            if ($from) {\n                $filterDate->setFrom($from);\n            }\n            if ($till) {\n                $filterDate->setTill($till);\n            }\n        }\n        $list->addFilter($filterDate);\n\n        if (!empty($request->get('pricingRule'))) {\n            $pricingRuleId = $request->get('pricingRule');\n\n            //apply filter on PricingRule(OrderItem)\n            $list->joinPricingRule();\n\n            //apply filter on PriceModifications\n            $list->joinPriceModifications();\n            $list->getQueryBuilder()->andWhere('pricingRule.ruleId = :pricingRuleId OR OrderPriceModifications.pricingRuleId = :pricingRuleId')->setParameter('pricingRuleId', $pricingRuleId);\n        }\n\n        // set default order\n        $list->setOrder('order.orderDate desc');\n\n        // Paginate the results of the query\n        $paginator = $paginator->paginate(\n            $list,\n            $request->query->getInt('page', 1),\n            10\n        );\n\n        return $this->render('@PimcoreEcommerceFramework/admin_order/list.html.twig', [\n            'paginator' => $paginator,\n            'pimcoreUser' => \\Pimcore\\Tool\\Admin::getCurrentUser(),\n            'listPricingRule' => new \\Pimcore\\Bundle\\EcommerceFrameworkBundle\\PricingManager\\Rule\\Listing(),\n            'defaultCurrency' => Factory::getInstance()->getEnvironment()->getDefaultCurrency(),\n            'formatter' => $formatter,\n        ]);\n    }\n\n    /**\n     * @Route(\"/detail\", name=\"pimcore_ecommerce_backend_admin-order_detail\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param ClientInterface $client\n     * @param IntlFormatter $formatter\n     * @param LocaleServiceInterface $localeService\n     *\n     * @return Response\n     */\n    public function detailAction(\n        Request $request,\n        ClientInterface $client,\n        IntlFormatter $formatter,\n        LocaleServiceInterface $localeService\n    ): Response {\n        $pimcoreSymfonyConfig = $this->getParameter('pimcore.config');\n\n        // init\n        $order = OnlineShopOrder::getById((int) $request->get('id'));\n        if (!$order) {\n            throw $this->createNotFoundException();\n        }\n        $orderAgent = $this->orderManager->createOrderAgent($order);\n\n        /**\n         * @param array $address\n         *\n         * @return string\n         */\n        $geoPoint = function (array $address) use ($pimcoreSymfonyConfig, $client) {\n            $baseUrl = $pimcoreSymfonyConfig['maps']['geocoding_url_template'];\n            $url = str_replace(\n                '{q}',\n                urlencode(\n                    $address[0]\n                    . ' ' . $address[1]\n                    . ' ' . $address[2]\n                    . ' ' . $address[3]\n                ),\n                $baseUrl\n            );\n\n            $json = null;\n\n            try {\n                $response = $client->request('GET', $url);\n                if ($response->getStatusCode() < 300) {\n                    $json = json_decode((string)$response->getBody());\n                    if (is_array($json)) {\n                        $json = $json[0];\n                    }\n                }\n            } catch (\\Exception $e) {\n                // noting to do\n            }\n\n            return $json;\n        };\n\n        // get geo points\n        $invoiceAddressCacheKey = 'pimcore_order_invoice_address_' . $order->getId();\n        if (!$geoAddressInvoice = Cache::load($invoiceAddressCacheKey)) {\n            $geoAddressInvoice = $geoPoint([$order->getCustomerStreet(), $order->getCustomerZip(), $order->getCustomerCity(), $order->getCustomerCountry()]);\n            Cache::save(\n                $geoAddressInvoice,\n                $invoiceAddressCacheKey,\n                [ 'object_' . $order->getId() ]\n            );\n        }\n\n        $geoAddressDelivery = null;\n        if ($order->getDeliveryStreet() && $order->getDeliveryZip()) {\n            $deliveryAddressCacheKey = 'pimcore_order_delivery_address_' . $order->getId();\n            if (!$geoAddressDelivery = Cache::load($deliveryAddressCacheKey)) {\n                $geoAddressDelivery = $geoPoint([$order->getDeliveryStreet(), $order->getDeliveryZip(), $order->getDeliveryCity(), $order->getDeliveryCountry()]);\n                Cache::save(\n                    $geoAddressDelivery,\n                    $deliveryAddressCacheKey,\n                    [ 'object_' . $order->getId() ]\n                );\n            }\n        }\n\n        // get customer info\n        $arrCustomerAccount = [];\n        if ($order->getCustomer()) {\n            // init\n            $customer = $order->getCustomer();\n\n            // register\n            $register = \\DateTime::createFromFormat('U', (string) $order->getCreationDate());\n            $arrCustomerAccount['created'] = $formatter->formatDateTime($register, IntlFormatter::DATE_MEDIUM);\n\n            // mail\n            if (method_exists($customer, 'getEMail')) {\n                $arrCustomerAccount['email'] = $customer->getEMail();\n            }\n\n            // order count\n            $addOrderCount = function () use ($customer, &$arrCustomerAccount) {\n                $order = new OnlineShopOrder();\n                $field = $order->getClass()->getFieldDefinition('customer');\n                if ($field instanceof ManyToOneRelation) {\n                    $classes = $field->getClasses();\n                    if (count($classes) === 1) {\n                        /** @var \\Pimcore\\Model\\DataObject\\Concrete $class */\n                        $class = 'Pimcore\\Model\\DataObject\\\\' . reset($classes)['classes'];\n\n                        $orderList = $this->orderManager->createOrderList();\n                        $orderList->joinCustomer($class::classId());\n\n                        $orderList->getQueryBuilder()->andWhere('customer.id = :customer_oid')->setParameter('customer_oid', $customer->getId());\n\n                        $arrCustomerAccount['orderCount'] = $orderList->count();\n                    }\n                }\n            };\n            $addOrderCount();\n        }\n\n        // create timeline\n        $arrIcons = [\n            'itemChangeAmount' => 'fa fa-pen', 'itemCancel' => 'fa fa-times', 'itemComplaint' => 'fa fa-exclamation-triangle',\n        ];\n\n        $arrContext = [\n            'itemChangeAmount' => 'secondary', 'itemCancel' => 'danger', 'itemComplaint' => 'warning',\n        ];\n\n        $arrTimeline = [];\n        $date = new \\DateTime();\n        foreach ($orderAgent->getFullChangeLog() as $note) {\n            $quantity = null;\n\n            // get avatar\n            $user = $note->getUser() ? User::getById($note->getUser()) : null;\n            $avatar = $user ? sprintf('/admin/user/get-image?id=%d', $user->getId()) : null;\n\n            // group events\n            $date->setTimestamp($note->getDate());\n            $group = $formatter->formatDateTime($date, IntlFormatter::DATE_MEDIUM);\n\n            // load reference\n            $reference = Concrete::getById($note->getCid());\n            $title = $reference instanceof AbstractOrderItem && $reference->getProduct() instanceof CheckoutableInterface\n                ? $reference->getProduct()->getOSName()\n                : null\n            ;\n\n            if (isset($note->getData()['quantity'])) {\n                $quantity = $note->getData()['quantity']['data'];\n            } elseif (isset($note->getData()['amount.new'])) {\n                $quantity = $note->getData()['amount.new']['data'];\n            }\n\n            // add\n            $arrTimeline[$group][] = [\n                'icon' => $arrIcons[$note->getTitle()] ?? '',\n                'context' => $arrContext[$note->getTitle()] ?? 'default',\n                'type' => $note->getTitle(),\n                'date' => $formatter->formatDateTime($date->setTimestamp($note->getDate()), IntlFormatter::DATETIME_MEDIUM),\n                'avatar' => $avatar,\n                'user' => $user ? $user->getName() : null,\n                'message' => $note->getData()['message']['data'] ?? '',\n                'title' => $title ?: $note->getTitle(),\n                'quantity' => $quantity,\n            ];\n        }\n\n        $paymentProviders = $this->paymentManager->getProviderTypes();\n\n        return $this->render('@PimcoreEcommerceFramework/admin_order/detail.html.twig', [\n            'pimcoreUser' => \\Pimcore\\Tool\\Admin::getCurrentUser(),\n            'orderAgent' => $orderAgent,\n            'timeLine' => $arrTimeline,\n            'geoAddressInvoice' => $geoAddressInvoice,\n            'arrCustomerAccount' => $arrCustomerAccount,\n            'geoAddressDelivery' => $geoAddressDelivery,\n            'pimcoreSymfonyConfig' => $pimcoreSymfonyConfig,\n            'formatter' => $formatter,\n            'locale' => $localeService,\n            'paymentProviders' => $paymentProviders,\n        ]);\n    }\n\n    /**\n     * @Route(\"/item-cancel\", name=\"pimcore_ecommerce_backend_admin-order_item-cancel\", methods={\"GET\", \"POST\"})\n     *\n     * @param Request $request\n     * @param CsrfProtectionHandler $csrfProtection\n     *\n     * @return Response\n     */\n    public function itemCancelAction(Request $request, CsrfProtectionHandler $csrfProtection): Response\n    {\n        // init\n        $orderItem = OnlineShopOrderItem::getById((int) $request->get('id'));\n        if (!$orderItem) {\n            throw $this->createNotFoundException();\n        }\n        $order = $orderItem->getOrder();\n\n        if ($request->get('confirmed') && $orderItem->isCancelAble()) {\n            $csrfProtection->checkCsrfToken($request);\n            // init\n            $agent = $this->orderManager->createOrderAgent($order);\n\n            // cancel\n            $note = $agent->itemCancel($orderItem);\n\n            // extend log\n            $note->addData('message', 'text', $request->get('message'));\n            $note->save();\n\n            // redir\n            $url = $this->generateUrl('pimcore_ecommerce_backend_admin-order_detail', ['id' => $order->getId()]);\n\n            return $this->redirect($url);\n        }\n\n        return $this->render('@PimcoreEcommerceFramework/admin_order/item_cancel.html.twig', [\n            'orderItem' => $orderItem,\n        ]);\n    }\n\n    /**\n     * @Route(\"/item-edit\", name=\"pimcore_ecommerce_backend_admin-order_item-edit\", methods={\"GET\", \"POST\"})\n     *\n     */\n    public function itemEditAction(Request $request, CsrfProtectionHandler $csrfProtectionHandler): Response\n    {\n        // init\n        $orderItem = OnlineShopOrderItem::getById((int) $request->get('id'));\n        if (!$orderItem) {\n            throw $this->createNotFoundException();\n        }\n        $order = $orderItem->getOrder();\n\n        if ($request->get('confirmed')) {\n            $csrfProtectionHandler->checkCsrfToken($request);\n\n            // change item\n            $agent = $this->orderManager->createOrderAgent($order);\n            $note = $agent->itemChangeAmount($orderItem, (float) $request->get('quantity'));\n\n            // extend log\n            $note->addData('message', 'text', $request->get('message')); // 'text','date','document','asset','object','bool'\n            $note->save();\n\n            // redir\n            $url = $this->generateUrl('pimcore_ecommerce_backend_admin-order_detail', ['id' => $order->getId()]);\n\n            return $this->redirect($url);\n        }\n\n        return $this->render('@PimcoreEcommerceFramework/admin_order/item_edit.html.twig', [\n            'orderItem' => $orderItem,\n        ]);\n    }\n\n    /**\n     * @Route(\"/item-complaint\", name=\"pimcore_ecommerce_backend_admin-order_item-complaint\", methods={\"GET\", \"POST\"})\n     *\n     */\n    public function itemComplaintAction(Request $request, CsrfProtectionHandler $csrfProtectionHandler): Response\n    {\n        // init\n        $orderItem = OnlineShopOrderItem::getById((int) $request->get('id'));\n        if (!$orderItem) {\n            throw $this->createNotFoundException();\n        }\n        $order = $orderItem->getOrder();\n\n        if ($request->get('confirmed')) {\n            $csrfProtectionHandler->checkCsrfToken($request);\n\n            // change item\n            $agent = $this->orderManager->createOrderAgent($order);\n            $note = $agent->itemComplaint($orderItem, (float) $request->get('quantity'));\n\n            // extend log\n            $note->addData('message', 'text', $request->get('message'));\n            $note->save();\n\n            // redir\n            $url = $this->generateUrl('pimcore_ecommerce_backend_admin-order_detail', ['id' => $order->getId()]);\n\n            return $this->redirect($url);\n        }\n\n        return $this->render('@PimcoreEcommerceFramework/admin_order/item_complaint.html.twig', [\n            'orderItem' => $orderItem,\n        ]);\n    }\n}\n", "<?php\ndeclare(strict_types=1);\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\EcommerceFrameworkBundle\\Controller;\n\nuse Pimcore\\Controller\\UserAwareController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Component\\Routing\\RouterInterface;\n\n/**\n * Class ConfigController\n *\n * @Route(\"/config\")\n *\n * @internal\n */\nclass ConfigController extends UserAwareController\n{\n    /**\n     * ConfigController constructor.\n     *\n     * @param RouterInterface $router\n     */\n    public function __construct(private RouterInterface $router)\n    {\n        $this->router = $router;\n    }\n\n    /**\n     * @Route(\"/js-config\", name=\"pimcore_ecommerceframework_config_jsconfig\", methods={\"GET\"})\n     *\n     * @return Response\n     */\n    public function jsConfigAction(): Response\n    {\n        $config = $this->getParameter('pimcore_ecommerce.pimcore.config');\n\n        $orderList = $config['menu']['order_list'];\n        if ($orderList['route']) {\n            $orderList['route'] = $this->router->generate($orderList['route']);\n        } elseif ($orderList['path']) {\n            $orderList['route'] = $orderList['path'];\n        }\n\n        unset($orderList['path']);\n\n        $config['menu']['order_list'] = $orderList;\n\n        $javascript = 'pimcore.registerNS(\"pimcore.bundle.EcommerceFramework.config\");' . PHP_EOL;\n\n        $javascript .= 'pimcore.bundle.EcommerceFramework.config = ';\n        $javascript .= json_encode($config) . ';';\n\n        $response = new Response($javascript);\n        $response->headers->set('Content-Type', 'application/javascript');\n\n        return $response;\n    }\n}\n", "<?php\ndeclare(strict_types=1);\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\EcommerceFrameworkBundle\\Controller;\n\nuse Pimcore\\Controller\\FrontendController;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\n\n/**\n * Class FindologicController\n *\n * Routing see routing.yaml\n *\n * @internal\n */\nclass FindologicController extends FrontendController\n{\n    /**\n     * create xml output for findologic\n     */\n    public function exportAction(Request $request): Response\n    {\n        // init\n        $start = (int)$request->get('start');\n        $count = (int)$request->get('count', 200);\n        $shopKey = $request->get('shopkey');\n\n        $db = \\Pimcore\\Db::getConnection();\n\n        if ($request->get('id')) {\n            $query = \"SELECT SQL_CALC_FOUND_ROWS id, data FROM {$this->getExportTableName()} WHERE shop_key = :shop_key and id = :id LIMIT {$start}, {$count}\";\n            $items = $db->fetchAllAssociative($query, ['shop_key' => $shopKey, 'id' => (int) $request->get('id')]);\n        }\n        // load export items\n        elseif ($request->get('type')) {\n            $query = \"SELECT SQL_CALC_FOUND_ROWS id, data FROM {$this->getExportTableName()} WHERE shop_key = :shop_key and `type` = :type LIMIT {$start}, {$count}\";\n            $items = $db->fetchAllAssociative($query, ['shop_key' => $shopKey, 'type' => $request->get('type')]);\n        } else {\n            $query = \"SELECT SQL_CALC_FOUND_ROWS id, data FROM {$this->getExportTableName()} WHERE shop_key = :shop_key LIMIT {$start}, {$count}\";\n            $items = $db->fetchAllAssociative($query, ['shop_key' => $shopKey]);\n        }\n\n        // get counts\n        $indexCount = $db->fetchOne('SELECT FOUND_ROWS()');\n        $itemCount = count($items);\n\n        // create xml header\n        $xml = <<<XML\n<?xml version=\"1.0\"?>\n<findologic version=\"0.9\">\n    <items start=\"{$start}\" count=\"{$itemCount}\" total=\"{$indexCount}\">\nXML;\n\n        // add items\n        $transmitIds = [];\n        foreach ($items as $row) {\n            $xml .= $row['data'];\n\n            $transmitIds[] = $row['id'];\n        }\n\n        // complete xml\n        $xml .= <<<XML\n    </items>\n</findologic>\nXML;\n\n        // output\n        if ($request->get('validate')) {\n            $doc = new \\DOMDocument();\n            $doc->loadXML($xml);\n\n            $response = new Response();\n            var_dump($doc->schemaValidate('bundles/pimcoreecommerceframework/vendor/findologic/export.xsd'));\n        } else {\n            $response = new Response($xml);\n            $response->headers->set('Content-Type', 'text/xml');\n\n            // mark items as transmitted\n            if ($transmitIds) {\n                $db->executeQuery(sprintf(\n                    'UPDATE %1$s SET last_transmit = now() WHERE id in(%2$s)',\n                    $this->getExportTableName(),\n                    implode(',', $transmitIds)\n                ));\n            }\n        }\n\n        return $response;\n    }\n\n    protected function getExportTableName(): string\n    {\n        return 'ecommerceframework_productindex_export_findologic';\n    }\n}\n", "<?php\ndeclare(strict_types=1);\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\EcommerceFrameworkBundle\\Controller;\n\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\Event\\AdminEvents;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\Factory;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\IndexService\\ProductList\\ProductListInterface;\nuse Pimcore\\Controller\\Traits\\JsonHelperTrait;\nuse Pimcore\\Controller\\UserAwareController;\nuse Symfony\\Component\\EventDispatcher\\GenericEvent;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\nuse Symfony\\Contracts\\Translation\\TranslatorInterface;\n\n/**\n * Class IndexController\n *\n * @Route(\"/index\")\n *\n * @internal\n */\nclass IndexController extends UserAwareController\n{\n    use JsonHelperTrait;\n\n    /**\n     * @Route(\"/get-filter-groups\", name=\"pimcore_ecommerceframework_index_getfiltergroups\", methods={\"GET\"})\n     *\n     * @return JsonResponse\n     */\n    public function getFilterGroupsAction(): JsonResponse\n    {\n        $indexService = Factory::getInstance()->getIndexService();\n        $tenants = Factory::getInstance()->getAllTenants();\n\n        $filterGroups = $indexService->getAllFilterGroups();\n        if ($tenants) {\n            foreach ($tenants as $tenant) {\n                $filterGroups = array_merge($filterGroups, $indexService->getAllFilterGroups($tenant));\n            }\n        }\n\n        $data = [];\n        if ($filterGroups) {\n            sort($filterGroups);\n            foreach ($filterGroups as $group) {\n                $data[$group] = ['data' => $group];\n            }\n        }\n\n        return $this->jsonResponse(['data' => array_values($data)]);\n    }\n\n    /**\n     * @Route(\"/get-values-for-filter-field\", name=\"pimcore_ecommerceframework_index_getvaluesforfilterfield\", methods={\"GET\"})\n     */\n    public function getValuesForFilterFieldAction(Request $request, EventDispatcherInterface $eventDispatcher): JsonResponse\n    {\n        try {\n            $data = [];\n            $factory = Factory::getInstance();\n\n            if ($request->get('field')) {\n                if ($request->get('tenant')) {\n                    Factory::getInstance()->getEnvironment()->setCurrentAssortmentTenant($request->get('tenant'));\n                }\n\n                $indexService = $factory->getIndexService();\n                $filterService = $factory->getFilterService();\n\n                $columnGroup = '';\n                $filterGroups = $indexService->getAllFilterGroups();\n                foreach ($filterGroups as $filterGroup) {\n                    $fields = $indexService->getIndexAttributesByFilterGroup($filterGroup);\n                    foreach ($fields as $field) {\n                        if ($field == $request->get('field')) {\n                            $columnGroup = $filterGroup;\n\n                            break 2;\n                        }\n                    }\n                }\n\n                $factory->getEnvironment()->setCurrentAssortmentSubTenant(null);\n                $productList = $factory->getIndexService()->getProductListForCurrentTenant();\n                $helper = $filterService->getFilterGroupHelper();\n                $data = $helper->getGroupByValuesForFilterGroup($columnGroup, $productList, $request->get('field'));\n            }\n\n            $event = new GenericEvent(null, ['data' => $data, 'field' => $request->get('field')]);\n            $eventDispatcher->dispatch($event, AdminEvents::GET_VALUES_FOR_FILTER_FIELD_PRE_SEND_DATA);\n            $data = $event->getArgument('data');\n\n            return $this->jsonResponse(['data' => array_values($data)]);\n        } catch (\\Exception $e) {\n            return $this->jsonResponse(['message' => $e->getMessage()]);\n        }\n    }\n\n    /**\n     * @Route(\"/get-fields\", name=\"pimcore_ecommerceframework_index_getfields\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     * @param TranslatorInterface $translator\n     *\n     * @return JsonResponse\n     */\n    public function getFieldsAction(Request $request, EventDispatcherInterface $eventDispatcher, TranslatorInterface $translator): JsonResponse\n    {\n        $indexService = Factory::getInstance()->getIndexService();\n\n        if ($request->get('filtergroup')) {\n            $filtergroups = $request->get('filtergroup');\n\n            $indexColumns = [];\n            foreach ($filtergroups as $filtergroup) {\n                $indexColumns = array_merge($indexColumns, $indexService->getIndexAttributesByFilterGroup($filtergroup, $request->get('tenant')));\n            }\n        } else {\n            if ($request->get('show_all_fields') == 'true') {\n                $indexColumns = $indexService->getIndexAttributes(false, $request->get('tenant'));\n            } else {\n                $indexColumns = $indexService->getIndexAttributes(true, $request->get('tenant'));\n            }\n        }\n\n        if (!$indexColumns) {\n            $indexColumns = [];\n        }\n\n        $fields = [];\n\n        if ($request->get('add_empty') == 'true') {\n            $fields[' '] = ['key' => '', 'name' => '(' . $translator->trans('empty', [], 'messages') . ')'];\n        }\n\n        foreach ($indexColumns as $c) {\n            $fields[$c] = ['key' => $c, 'name' => $translator->trans($c, [], 'admin')];\n        }\n\n        if ($request->get('specific_price_field') == 'true') {\n            $fields[ProductListInterface::ORDERKEY_PRICE] = [\n                'key' => ProductListInterface::ORDERKEY_PRICE,\n                'name' => $translator->trans(ProductListInterface::ORDERKEY_PRICE, [], 'admin'),\n            ];\n        }\n\n        ksort($fields);\n\n        $event = new GenericEvent(null, ['data' => $fields]);\n        $eventDispatcher->dispatch($event, AdminEvents::GET_INDEX_FIELD_NAMES_PRE_SEND_DATA);\n        $data = $event->getArgument('data');\n\n        return $this->jsonResponse(['data' => array_values($data)]);\n    }\n\n    /**\n     * @Route(\"/get-all-tenants\", name=\"pimcore_ecommerceframework_index_getalltenants\", methods={\"GET\"})\n     *\n     * @param TranslatorInterface $translator\n     *\n     * @return JsonResponse\n     */\n    public function getAllTenantsAction(TranslatorInterface $translator): JsonResponse\n    {\n        $tenants = Factory::getInstance()->getAllTenants();\n        $data = [];\n\n        if ($tenants) {\n            foreach ($tenants as $tenant) {\n                $data[] = ['key' => $tenant, 'name' => $translator->trans($tenant, [], 'admin')];\n            }\n        }\n\n        return $this->jsonResponse(['data' => $data]);\n    }\n}\n", "<?php\ndeclare(strict_types=1);\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\EcommerceFrameworkBundle\\Controller;\n\nuse Exception;\n\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\Factory;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\PricingManager\\Rule;\nuse Pimcore\\Controller\\KernelControllerEventInterface;\nuse Pimcore\\Controller\\Traits\\JsonHelperTrait;\nuse Pimcore\\Controller\\UserAwareController;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpKernel\\Event\\ControllerEvent;\nuse Symfony\\Component\\HttpKernel\\Exception\\NotFoundHttpException;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\n\n/**\n * Class ConfigController\n *\n * @Route(\"/pricing\")\n *\n * @internal\n */\nclass PricingController extends UserAwareController implements KernelControllerEventInterface\n{\n    use JsonHelperTrait;\n\n    public function onKernelControllerEvent(ControllerEvent $event): void\n    {\n        // permission check\n        $access = $this->getPimcoreUser()->isAllowed('bundle_ecommerce_pricing_rules');\n        if (!$access) {\n            throw new \\Exception('this function requires \"bundle_ecommerce_pricing_rules\" permission!');\n        }\n    }\n\n    /**\n     * @Route(\"/list\", name=\"pimcore_ecommerceframework_pricing_list\", methods={\"GET\"})\n     */\n    public function listAction(): JsonResponse\n    {\n        $rules = new Rule\\Listing();\n        $rules->setOrderKey('prio');\n        $rules->setOrder('ASC');\n\n        $json = [];\n        foreach ($rules->load() as $rule) {\n            if ($rule->getActive()) {\n                $icon = 'bundle_ecommerce_pricing_icon_rule_' . $rule->getBehavior();\n                $title = 'Verhalten: ' . $rule->getBehavior();\n            } else {\n                $icon = 'bundle_ecommerce_pricing_icon_rule_disabled';\n                $title = 'Deaktiviert';\n            }\n\n            $json[] = [\n                'iconCls' => $icon,\n                'id' => $rule->getId(),\n                'text' => $rule->getName(),\n                'qtipCfg' => [\n                    'xtype' => 'quicktip',\n                    'title' => $rule->getLabel(),\n                    'text' => $title,\n                ],\n            ];\n        }\n\n        return $this->jsonResponse($json);\n    }\n\n    /**\n     * get priceing rule details as json\n     *\n     * @Route(\"/get\", name=\"pimcore_ecommerceframework_pricing_get\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     *\n     * @throws NotFoundHttpException\n     */\n    public function getAction(Request $request): JsonResponse\n    {\n        $rule = Rule::getById((int) $request->get('id'));\n        if ($rule) {\n            // get data\n            $condition = $rule->getCondition();\n            $localizedLabel = [];\n            $localizedDescription = [];\n\n            foreach (\\Pimcore\\Tool::getValidLanguages() as $lang) {\n                $localizedLabel[$lang] = $rule->getLabel($lang);\n                $localizedDescription[$lang] = $rule->getDescription($lang);\n            }\n\n            // create json config\n            $json = [\n                'id' => $rule->getId(),\n                'name' => $rule->getName(),\n                'label' => $localizedLabel,\n                'description' => $localizedDescription,\n                'behavior' => $rule->getBehavior(),\n                'active' => $rule->getActive(),\n                'condition' => $condition ? json_decode($condition->toJSON()) : '',\n                'actions' => [],\n            ];\n\n            foreach ($rule->getActions() as $action) {\n                $json['actions'][] = json_decode($action->toJSON());\n            }\n\n            return $this->jsonResponse($json);\n        }\n\n        throw $this->createNotFoundException('Rule not found');\n    }\n\n    /**\n     * add new rule\n     *\n     * @Route(\"/add\", name=\"pimcore_ecommerceframework_pricing_add\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function addAction(Request $request): JsonResponse\n    {\n        // send json respone\n        $return = [\n            'success' => false,\n            'message' => '',\n        ];\n\n        // save rule\n        try {\n            $rule = new Rule();\n            $rule->setName($request->get('name'));\n            $rule->save();\n\n            $return['success'] = true;\n            $return['id'] = $rule->getId();\n        } catch (\\Exception $e) {\n            $return['message'] = $e->getMessage();\n        }\n\n        // send respone\n        return $this->jsonResponse($return);\n    }\n\n    /**\n     * delete exiting rule\n     *\n     * @Route(\"/delete\", name=\"pimcore_ecommerceframework_pricing_delete\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function deleteAction(Request $request): JsonResponse\n    {\n        // send json respone\n        $return = [\n            'success' => false,\n            'message' => '',\n        ];\n\n        // delete rule\n        try {\n            $rule = Rule::getById((int) $request->get('id'));\n            $rule->delete();\n            $return['success'] = true;\n        } catch (\\Exception $e) {\n            $return['message'] = $e->getMessage();\n        }\n\n        // send respone\n        return $this->jsonResponse($return);\n    }\n\n    /**\n     * @Route(\"/copy\", name=\"pimcore_ecommerceframework_pricing_copy\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     * copy existing rule\n     */\n    public function copyAction(Request $request): JsonResponse\n    {\n        // send json respone\n        $return = [\n            'success' => false,\n            'message' => '',\n        ];\n\n        // copy rule\n        try {\n            /** @var Rule $ruleSource */\n            $ruleSource = Rule::getById((int) $request->get('id'));\n            $rules = (new Rule\\Listing())->load();\n\n            $name = $ruleSource->getName() . '_copy';\n\n            // Get new unique name.\n            do {\n                $uniqueName = true;\n\n                foreach ($rules as $rule) {\n                    if ($rule->getName() == $name) {\n                        $uniqueName = false;\n                        $name .= '_copy';\n\n                        break;\n                    }\n                }\n            } while (!$uniqueName);\n\n            // Clone and save new rule.\n            $newRule = clone $ruleSource;\n            $newRule->setId(null);\n            $newRule->setName($name);\n            $newRule->save();\n\n            $return['success'] = true;\n        } catch (\\Exception $e) {\n            $return['message'] = $e->getMessage();\n        }\n\n        // send respone\n        return $this->jsonResponse($return);\n    }\n\n    /**\n     * @Route(\"/rename\", name=\"pimcore_ecommerceframework_pricing_rename\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     * rename exiting rule\n     */\n    public function renameAction(Request $request): JsonResponse\n    {\n        // send json respone\n        $return = [\n            'success' => false,\n            'message' => '',\n        ];\n\n        $ruleId = $request->request->getInt('id');\n        $ruleNewName = $request->request->get('name');\n\n        try {\n            if ($ruleId && $ruleNewName && preg_match('/^[a-zA-Z0-9_\\-]+$/', $ruleNewName)) {\n                $renameRule = Rule::getById($ruleId);\n\n                if ($renameRule->getName() != $ruleNewName) {\n                    $rules = (new Rule\\Listing())->load();\n\n                    // Check if rulename is available.\n                    foreach ($rules as $rule) {\n                        if ($rule->getName() == $ruleNewName) {\n                            throw new Exception('Rulename already exists.');\n                        }\n                    }\n\n                    $renameRule->setName($ruleNewName);\n                    $renameRule->save();\n                }\n\n                $return['success'] = true;\n            }\n        } catch (Exception $e) {\n            $return['message'] = $e->getMessage();\n        }\n\n        // send respone\n        return $this->jsonResponse($return);\n    }\n\n    /**\n     * save rule config\n     *\n     * @Route(\"/save\", name=\"pimcore_ecommerceframework_pricing_save\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function saveAction(Request $request): JsonResponse\n    {\n        // send json respone\n        $return = [\n            'success' => false,\n            'message' => '',\n        ];\n\n        // save rule config\n        try {\n            $data = json_decode($request->get('data'));\n            $rule = Rule::getById((int) $request->get('id'));\n\n            // apply basic settings\n            $rule->setBehavior($data->settings->behavior)\n                ->setActive((bool)$data->settings->active);\n\n            // apply lang fields\n            foreach (\\Pimcore\\Tool::getValidLanguages() as $lang) {\n                $rule->setLabel($data->settings->{'label.' . $lang}, $lang);\n                $rule->setDescription($data->settings->{'description.' . $lang}, $lang);\n            }\n\n            // create root condition\n            $rootContainer = new \\stdClass();\n            $rootContainer->parent = null;\n            $rootContainer->operator = null;\n            $rootContainer->type = 'Bracket';\n            $rootContainer->conditions = [];\n\n            // create a tree from the flat structure\n            $currentContainer = $rootContainer;\n            foreach ($data->conditions as $settings) {\n                // handle brackets\n                if ($settings->bracketLeft == true) {\n                    $newContainer = new \\stdClass();\n                    $newContainer->parent = $currentContainer;\n                    $newContainer->type = 'Bracket';\n                    $newContainer->conditions = [];\n\n                    // move condition from current item to bracket item\n                    $newContainer->operator = $settings->operator;\n                    $settings->operator = null;\n\n                    $currentContainer->conditions[] = $newContainer;\n                    $currentContainer = $newContainer;\n                }\n\n                $currentContainer->conditions[] = $settings;\n\n                if ($settings->bracketRight == true) {\n                    $old = $currentContainer;\n                    $currentContainer = $currentContainer->parent;\n                    unset($old->parent);\n                }\n            }\n\n            // create rule condition\n            $condition = Factory::getInstance()->getPricingManager()->getCondition($rootContainer->type);\n            $condition->fromJSON(json_encode($rootContainer));\n            $rule->setCondition($condition);\n\n            // save action\n            $arrActions = [];\n            foreach ($data->actions as $setting) {\n                $action = Factory::getInstance()->getPricingManager()->getAction($setting->type);\n                $action->fromJSON(json_encode($setting));\n                $arrActions[] = $action;\n            }\n            $rule->setActions($arrActions);\n\n            // save rule\n            $rule->save();\n\n            // finish\n            $return['success'] = true;\n            $return['id'] = $rule->getId();\n        } catch (\\Exception $e) {\n            $return['message'] = $e->getMessage();\n        }\n\n        // send respone\n        return $this->jsonResponse($return);\n    }\n\n    /**\n     * @Route(\"/save-order\", name=\"pimcore_ecommerceframework_pricing_save-order\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function saveOrderAction(Request $request): JsonResponse\n    {\n        // send json respone\n        $return = [\n            'success' => false,\n            'message' => '',\n        ];\n\n        // save order\n        $rules = json_decode($request->get('rules'));\n        foreach ($rules as $id => $prio) {\n            $rule = Rule::getById((int)$id);\n            if ($rule) {\n                $rule->setPrio((int)$prio)->save();\n            }\n        }\n        $return['success'] = true;\n\n        // send respone\n        return $this->jsonResponse($return);\n    }\n\n    /**\n     * @Route(\"/get-config\", name=\"pimcore_ecommerceframework_pricing_get-config\", methods={\"GET\"})\n     *\n     * @return JsonResponse\n     */\n    public function getConfigAction(): JsonResponse\n    {\n        $pricingManager = Factory::getInstance()->getPricingManager();\n\n        return $this->jsonResponse([\n            'condition' => array_keys($pricingManager->getConditionMapping()),\n            'action' => array_keys($pricingManager->getActionMapping()),\n        ]);\n    }\n}\n", "<?php\ndeclare(strict_types=1);\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\EcommerceFrameworkBundle\\Controller;\n\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\VoucherService\\TokenManager\\ExportableTokenManagerInterface;\nuse Pimcore\\Controller\\FrontendController;\nuse Pimcore\\Controller\\KernelControllerEventInterface;\nuse Pimcore\\Model\\DataObject;\nuse Pimcore\\Model\\DataObject\\Localizedfield;\nuse Pimcore\\Model\\DataObject\\OnlineShopVoucherSeries;\nuse Pimcore\\Security\\User\\TokenStorageUserResolver;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\Event\\ControllerEvent;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\Translation\\LocaleAwareInterface;\nuse Symfony\\Contracts\\Translation\\TranslatorInterface;\n\n/**\n * Class VoucherController\n *\n * @Route(\"/voucher\")\n *\n * @internal\n */\nclass VoucherController extends FrontendController implements KernelControllerEventInterface\n{\n    protected TokenStorageUserResolver $tokenResolver;\n\n    protected TranslatorInterface $translator;\n\n    /**\n     * @param TokenStorageUserResolver $tokenStorageUserResolver\n     * @param TranslatorInterface $translator\n     */\n    public function __construct(TokenStorageUserResolver $tokenStorageUserResolver, TranslatorInterface $translator)\n    {\n        $this->tokenResolver = $tokenStorageUserResolver;\n        $this->translator = $translator;\n    }\n\n    public function onKernelControllerEvent(ControllerEvent $event): void\n    {\n        // set language\n        $user = $this->tokenResolver->getUser();\n\n        if ($user) {\n            if ($this->translator instanceof LocaleAwareInterface) {\n                $this->translator->setLocale($user->getLanguage());\n            }\n            $event->getRequest()->setLocale($user->getLanguage());\n        }\n\n        // enable inherited values\n        DataObject::setGetInheritedValues(true);\n        Localizedfield::setGetFallbackValues(true);\n    }\n\n    /**\n     * Loads and shows voucherservice backend tab\n     *\n     * @Route(\"/voucher-code-tab\", name=\"pimcore_ecommerce_backend_voucher_voucher-code-tab\", methods={\"GET\"})\n     */\n    public function voucherCodeTabAction(Request $request): Response\n    {\n        $onlineShopVoucherSeries = OnlineShopVoucherSeries::getById((int) $request->get('id'));\n\n        if (!$onlineShopVoucherSeries) {\n            throw $this->createNotFoundException('Voucher series not found');\n        }\n\n        $paramsBag = [];\n        if ($tokenManager = $onlineShopVoucherSeries->getTokenManager()) {\n            $paramsBag['series'] = $onlineShopVoucherSeries;\n            $paramsBag['voucherType'] = $tokenManager->getConfiguration()->getType();\n\n            if ($tokenManager instanceof ExportableTokenManagerInterface) {\n                $paramsBag['supportsExport'] = true;\n            }\n\n            $renderScript = $tokenManager->prepareConfigurationView($paramsBag, $request->query->all());\n\n            return $this->render($renderScript, $paramsBag);\n        } else {\n            $paramsBag['errors'] = ['bundle_ecommerce_voucherservice_msg-error-config-missing'];\n\n            return $this->render('@PimcoreEcommerceFramework/voucher/voucher_code_tab_error.html.twig', $paramsBag);\n        }\n    }\n\n    /**\n     * Export tokens to file. The action should implement all export formats defined in ExportableTokenManagerInterface.\n     *\n     * @Route(\"/export-tokens\", name=\"pimcore_ecommerce_backend_voucher_export-tokens\", methods={\"GET\"})\n     */\n    public function exportTokensAction(Request $request): Response\n    {\n        $onlineShopVoucherSeries = OnlineShopVoucherSeries::getById((int) $request->get('id'));\n\n        if (!$onlineShopVoucherSeries) {\n            throw $this->createNotFoundException('Voucher series not found');\n        }\n\n        $tokenManager = $onlineShopVoucherSeries->getTokenManager();\n        if (!(null !== $tokenManager && $tokenManager instanceof ExportableTokenManagerInterface)) {\n            throw new \\InvalidArgumentException('Token manager does not support exporting');\n        }\n\n        $format = $request->get('format', ExportableTokenManagerInterface::FORMAT_CSV);\n        $contentType = null;\n        $suffix = null;\n        $download = true;\n\n        switch ($format) {\n            case ExportableTokenManagerInterface::FORMAT_CSV:\n                $result = $tokenManager->exportCsv($request->query->all());\n                $contentType = 'text/csv';\n                $suffix = 'csv';\n\n                break;\n\n            case ExportableTokenManagerInterface::FORMAT_PLAIN:\n                $result = $tokenManager->exportPlain($request->query->all());\n                $contentType = 'text/plain';\n                $suffix = 'txt';\n                $download = false;\n\n                break;\n\n            default:\n                throw new \\InvalidArgumentException('Invalid format');\n        }\n\n        $response = new Response($result);\n        $response->headers->set('Content-Type', $contentType);\n        $response->headers->set('Content-Length', (string) strlen($result));\n\n        if ($download && null !== $suffix) {\n            $response->headers->set('Content-Disposition', sprintf('attachment; filename=\"voucher-export.%s\"', $suffix));\n        }\n\n        return $response;\n    }\n\n    /**\n     * Generates new Tokens or Applies single token settings.\n     *\n     * @Route(\"/generate\", name=\"pimcore_ecommerce_backend_voucher_generate\", methods={\"GET\"})\n     */\n    public function generateAction(Request $request): Response\n    {\n        $onlineShopVoucherSeries = OnlineShopVoucherSeries::getById((int) $request->get('id'));\n\n        if (!$onlineShopVoucherSeries) {\n            throw $this->createNotFoundException('Could not get voucher series, probably you did not provide a correct id.');\n        }\n\n        if ($tokenManager = $onlineShopVoucherSeries->getTokenManager()) {\n            $result = $tokenManager->insertOrUpdateVoucherSeries();\n\n            $params = ['id' => $request->get('id')]; //$request->query->all();\n\n            if ($result === false) {\n                $params['error'] = $this->translator->trans('bundle_ecommerce_voucherservice_msg-error-generation', [], 'admin');\n            } else {\n                $params['success'] = $this->translator->trans('bundle_ecommerce_voucherservice_msg-success-generation', [], 'admin');\n            }\n\n            return $this->redirectToRoute(\n                'pimcore_ecommerce_backend_voucher_voucher-code-tab',\n                $params\n            );\n        }\n\n        throw $this->createNotFoundException();\n    }\n\n    /**\n     * Removes tokens due to given filter parameters.\n     *\n     * @Route(\"/cleanup\", name=\"pimcore_ecommerce_backend_voucher_cleanup\", methods={\"POST\"})\n     */\n    public function cleanupAction(Request $request): Response\n    {\n        $onlineShopVoucherSeries = OnlineShopVoucherSeries::getById((int) $request->get('id'));\n\n        if (!$onlineShopVoucherSeries) {\n            throw $this->createNotFoundException('Could not get voucher series, probably you did not provide a correct id.');\n        }\n        if ($tokenManager = $onlineShopVoucherSeries->getTokenManager()) {\n            // Prepare cleanUp parameter array.\n            $params = ['id' => $request->get('id')]; // $request->query->all();\n            $request->get('usage') ? $params['usage'] = $request->get('usage') : '';\n            $request->get('olderThan') ? $params['olderThan'] = $request->get('olderThan') : '';\n\n            if (empty($params['usage'])) {\n                $params['error'] = $this->translator->trans('bundle_ecommerce_voucherservice_msg-error-required-missing', [], 'admin');\n            } elseif ($tokenManager->cleanUpCodes($params)) {\n                $params['success'] = $this->translator->trans('bundle_ecommerce_voucherservice_msg-success-cleanup', [], 'admin');\n            } else {\n                $params['error'] = $this->translator->trans('bundle_ecommerce_voucherservice_msg-error-cleanup', [], 'admin');\n            }\n\n            return $this->redirectToRoute(\n                'pimcore_ecommerce_backend_voucher_voucher-code-tab',\n                $params\n            );\n        }\n\n        throw $this->createNotFoundException();\n    }\n\n    /**\n     * Removes token reservations due to given duration.\n     *\n     * @Route(\"/cleanup-reservations\", name=\"pimcore_ecommerce_backend_voucher_cleanup-reservations\", methods={\"POST\"})\n     *\n     */\n    public function cleanupReservationsAction(Request $request): \\Symfony\\Component\\HttpFoundation\\RedirectResponse\n    {\n        $duration = $request->get('duration');\n        $id = $request->request->getInt('id');\n\n        if ($duration === '') {\n            return $this->redirectToRoute(\n                'pimcore_ecommerce_backend_voucher_voucher-code-tab',\n                ['error' => $this->translator->trans('bundle_ecommerce_voucherservice_msg-error-cleanup-reservations-duration-missing', [], 'admin'), 'id' => $id]\n            );\n        }\n\n        $onlineShopVoucherSeries = DataObject::getById($id);\n        if ($onlineShopVoucherSeries instanceof OnlineShopVoucherSeries) {\n            if ($tokenManager = $onlineShopVoucherSeries->getTokenManager()) {\n                if ($tokenManager->cleanUpReservations((int)$duration, $id)) {\n                    return $this->redirectToRoute(\n                        'pimcore_ecommerce_backend_voucher_voucher-code-tab',\n                        ['success' => $this->translator->trans('bundle_ecommerce_voucherservice_msg-success-cleanup-reservations', [], 'admin'), 'id' => $id]\n                    );\n                }\n            }\n        }\n\n        return $this->redirectToRoute(\n            'pimcore_ecommerce_backend_voucher_voucher-code-tab',\n            ['error' => $this->translator->trans('bundle_ecommerce_voucherservice_msg-error-cleanup-reservations', [], 'admin'), 'id' => $id]\n        );\n    }\n}\n"], "fixing_code": ["<?php\ndeclare(strict_types=1);\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\EcommerceFrameworkBundle\\Controller;\n\nuse GuzzleHttp\\ClientInterface;\nuse Knp\\Component\\Pager\\PaginatorInterface;\nuse Pimcore\\Bundle\\AdminBundle\\Security\\CsrfProtectionHandler;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\Factory;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\Model\\AbstractOrder;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\Model\\AbstractOrderItem;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\Model\\CheckoutableInterface;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\OrderManager\\Order\\Listing;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\OrderManager\\Order\\Listing\\Filter\\OrderDateTime;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\OrderManager\\Order\\Listing\\Filter\\OrderSearch;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\OrderManager\\Order\\Listing\\Filter\\ProductType;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\OrderManager\\V7\\OrderManagerInterface;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\PaymentManager\\PaymentManagerInterface;\nuse Pimcore\\Cache;\nuse Pimcore\\Controller\\KernelControllerEventInterface;\nuse Pimcore\\Controller\\UserAwareController;\nuse Pimcore\\Localization\\IntlFormatter;\nuse Pimcore\\Localization\\LocaleServiceInterface;\nuse Pimcore\\Model\\DataObject;\nuse Pimcore\\Model\\DataObject\\ClassDefinition\\Data\\ManyToOneRelation;\nuse Pimcore\\Model\\DataObject\\Concrete;\nuse Pimcore\\Model\\DataObject\\Localizedfield;\nuse Pimcore\\Model\\DataObject\\OnlineShopOrder;\nuse Pimcore\\Model\\DataObject\\OnlineShopOrderItem;\nuse Pimcore\\Model\\User;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\Event\\ControllerEvent;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\Translation\\LocaleAwareInterface;\nuse Symfony\\Contracts\\Translation\\TranslatorInterface;\n\n/**\n * Class AdminOrderController\n *\n * @internal\n *\n * @Route(\"/admin-order\")\n *\n */\nclass AdminOrderController extends UserAwareController implements KernelControllerEventInterface\n{\n    protected OrderManagerInterface $orderManager;\n\n    protected PaymentManagerInterface $paymentManager;\n\n    public function __construct(protected TranslatorInterface $translator)\n    {\n    }\n\n    public function onKernelControllerEvent(ControllerEvent $event): void\n    {\n        $this->checkPermission('bundle_ecommerce_back-office_order');\n\n        // set language\n        $user = $this->tokenResolver->getUser();\n\n        if ($user) {\n            if ($this->translator instanceof LocaleAwareInterface) {\n                $this->translator->setLocale($user->getLanguage());\n            }\n            $event->getRequest()->setLocale($user->getLanguage());\n        }\n\n        // enable inherited values\n        DataObject::setGetInheritedValues(true);\n        Localizedfield::setGetFallbackValues(true);\n\n        $this->orderManager = Factory::getInstance()->getOrderManager();\n        $this->paymentManager = Factory::getInstance()->getPaymentManager();\n    }\n\n    /**\n     * @Route(\"/list\", name=\"pimcore_ecommerce_backend_admin-order_list\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param IntlFormatter $formatter\n     * @param PaginatorInterface $paginator\n     *\n     * @return Response\n     */\n    public function listAction(Request $request, IntlFormatter $formatter, PaginatorInterface $paginator): Response\n    {\n        // create new order list\n        /** @var Listing $list */\n        $list = $this->orderManager->createOrderList();\n\n        // set list type\n        $list->setListType($request->get('type', $list::LIST_TYPE_ORDER));\n\n        // set order state\n        $list->setOrderState(AbstractOrder::ORDER_STATE_COMMITTED);\n\n        // add select fields\n        $list->addSelectField('order.OrderDate');\n        $list->addSelectField('order.orderNumber AS OrderNumber');\n        if ($list->getListType() == $list::LIST_TYPE_ORDER) {\n            $list->addSelectField('order.totalPrice AS TotalPrice');\n        } elseif ($list->getListType() == $list::LIST_TYPE_ORDER_ITEM) {\n            $list->addSelectField('orderItem.totalPrice AS TotalPrice');\n        }\n        $list->addSelectField('count(orderItem.id) AS Items');\n\n        // Search\n        if ($request->get('q')) {\n            $q = htmlentities($request->get('q'));\n            $search = $request->get('search');\n            switch ($search) {\n                case 'productType':\n                    $filterProductType = new ProductType();\n                    $filterProductType->setTypes([$q]);\n                    $list->addFilter($filterProductType);\n\n                    break;\n\n                case 'order':\n                default:\n                    $filterOrder = new OrderSearch();\n                    $filterOrder->setKeyword($q);\n                    $list->addFilter($filterOrder);\n\n                    break;\n            }\n        }\n\n        // add Date Filter\n        if ($request->query->has('from') === false && $request->query->has('till') === false) {\n            // als default, nehmen wir den ersten des aktuellen monats\n            $from = new \\DateTime('first day of this month');\n            $request->query->set('from', $from->format('Y-m-d'));\n        }\n\n        $filterDate = new OrderDateTime();\n        if ($request->get('from') || $request->get('till')) {\n            $from = $request->get('from') ? new \\DateTime($request->get('from')) : null;\n            $till = $request->get('till') ? new \\DateTime($request->get('till')) : null;\n            if ($till) {\n                $till->add(new \\DateInterval('P1D'));\n            }\n\n            if ($from) {\n                $filterDate->setFrom($from);\n            }\n            if ($till) {\n                $filterDate->setTill($till);\n            }\n        }\n        $list->addFilter($filterDate);\n\n        if (!empty($request->get('pricingRule'))) {\n            $pricingRuleId = $request->get('pricingRule');\n\n            //apply filter on PricingRule(OrderItem)\n            $list->joinPricingRule();\n\n            //apply filter on PriceModifications\n            $list->joinPriceModifications();\n            $list->getQueryBuilder()->andWhere('pricingRule.ruleId = :pricingRuleId OR OrderPriceModifications.pricingRuleId = :pricingRuleId')->setParameter('pricingRuleId', $pricingRuleId);\n        }\n\n        // set default order\n        $list->setOrder('order.orderDate desc');\n\n        // Paginate the results of the query\n        $paginator = $paginator->paginate(\n            $list,\n            $request->query->getInt('page', 1),\n            10\n        );\n\n        return $this->render('@PimcoreEcommerceFramework/admin_order/list.html.twig', [\n            'paginator' => $paginator,\n            'pimcoreUser' => \\Pimcore\\Tool\\Admin::getCurrentUser(),\n            'listPricingRule' => new \\Pimcore\\Bundle\\EcommerceFrameworkBundle\\PricingManager\\Rule\\Listing(),\n            'defaultCurrency' => Factory::getInstance()->getEnvironment()->getDefaultCurrency(),\n            'formatter' => $formatter,\n        ]);\n    }\n\n    /**\n     * @Route(\"/detail\", name=\"pimcore_ecommerce_backend_admin-order_detail\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param ClientInterface $client\n     * @param IntlFormatter $formatter\n     * @param LocaleServiceInterface $localeService\n     *\n     * @return Response\n     */\n    public function detailAction(\n        Request $request,\n        ClientInterface $client,\n        IntlFormatter $formatter,\n        LocaleServiceInterface $localeService\n    ): Response {\n        $pimcoreSymfonyConfig = $this->getParameter('pimcore.config');\n\n        // init\n        $order = OnlineShopOrder::getById((int) $request->get('id'));\n        if (!$order) {\n            throw $this->createNotFoundException();\n        }\n        $orderAgent = $this->orderManager->createOrderAgent($order);\n\n        /**\n         * @param array $address\n         *\n         * @return string\n         */\n        $geoPoint = function (array $address) use ($pimcoreSymfonyConfig, $client) {\n            $baseUrl = $pimcoreSymfonyConfig['maps']['geocoding_url_template'];\n            $url = str_replace(\n                '{q}',\n                urlencode(\n                    $address[0]\n                    . ' ' . $address[1]\n                    . ' ' . $address[2]\n                    . ' ' . $address[3]\n                ),\n                $baseUrl\n            );\n\n            $json = null;\n\n            try {\n                $response = $client->request('GET', $url);\n                if ($response->getStatusCode() < 300) {\n                    $json = json_decode((string)$response->getBody());\n                    if (is_array($json)) {\n                        $json = $json[0];\n                    }\n                }\n            } catch (\\Exception $e) {\n                // noting to do\n            }\n\n            return $json;\n        };\n\n        // get geo points\n        $invoiceAddressCacheKey = 'pimcore_order_invoice_address_' . $order->getId();\n        if (!$geoAddressInvoice = Cache::load($invoiceAddressCacheKey)) {\n            $geoAddressInvoice = $geoPoint([$order->getCustomerStreet(), $order->getCustomerZip(), $order->getCustomerCity(), $order->getCustomerCountry()]);\n            Cache::save(\n                $geoAddressInvoice,\n                $invoiceAddressCacheKey,\n                [ 'object_' . $order->getId() ]\n            );\n        }\n\n        $geoAddressDelivery = null;\n        if ($order->getDeliveryStreet() && $order->getDeliveryZip()) {\n            $deliveryAddressCacheKey = 'pimcore_order_delivery_address_' . $order->getId();\n            if (!$geoAddressDelivery = Cache::load($deliveryAddressCacheKey)) {\n                $geoAddressDelivery = $geoPoint([$order->getDeliveryStreet(), $order->getDeliveryZip(), $order->getDeliveryCity(), $order->getDeliveryCountry()]);\n                Cache::save(\n                    $geoAddressDelivery,\n                    $deliveryAddressCacheKey,\n                    [ 'object_' . $order->getId() ]\n                );\n            }\n        }\n\n        // get customer info\n        $arrCustomerAccount = [];\n        if ($order->getCustomer()) {\n            // init\n            $customer = $order->getCustomer();\n\n            // register\n            $register = \\DateTime::createFromFormat('U', (string) $order->getCreationDate());\n            $arrCustomerAccount['created'] = $formatter->formatDateTime($register, IntlFormatter::DATE_MEDIUM);\n\n            // mail\n            if (method_exists($customer, 'getEMail')) {\n                $arrCustomerAccount['email'] = $customer->getEMail();\n            }\n\n            // order count\n            $addOrderCount = function () use ($customer, &$arrCustomerAccount) {\n                $order = new OnlineShopOrder();\n                $field = $order->getClass()->getFieldDefinition('customer');\n                if ($field instanceof ManyToOneRelation) {\n                    $classes = $field->getClasses();\n                    if (count($classes) === 1) {\n                        /** @var \\Pimcore\\Model\\DataObject\\Concrete $class */\n                        $class = 'Pimcore\\Model\\DataObject\\\\' . reset($classes)['classes'];\n\n                        $orderList = $this->orderManager->createOrderList();\n                        $orderList->joinCustomer($class::classId());\n\n                        $orderList->getQueryBuilder()->andWhere('customer.id = :customer_oid')->setParameter('customer_oid', $customer->getId());\n\n                        $arrCustomerAccount['orderCount'] = $orderList->count();\n                    }\n                }\n            };\n            $addOrderCount();\n        }\n\n        // create timeline\n        $arrIcons = [\n            'itemChangeAmount' => 'fa fa-pen', 'itemCancel' => 'fa fa-times', 'itemComplaint' => 'fa fa-exclamation-triangle',\n        ];\n\n        $arrContext = [\n            'itemChangeAmount' => 'secondary', 'itemCancel' => 'danger', 'itemComplaint' => 'warning',\n        ];\n\n        $arrTimeline = [];\n        $date = new \\DateTime();\n        foreach ($orderAgent->getFullChangeLog() as $note) {\n            $quantity = null;\n\n            // get avatar\n            $user = $note->getUser() ? User::getById($note->getUser()) : null;\n            $avatar = $user ? sprintf('/admin/user/get-image?id=%d', $user->getId()) : null;\n\n            // group events\n            $date->setTimestamp($note->getDate());\n            $group = $formatter->formatDateTime($date, IntlFormatter::DATE_MEDIUM);\n\n            // load reference\n            $reference = Concrete::getById($note->getCid());\n            $title = $reference instanceof AbstractOrderItem && $reference->getProduct() instanceof CheckoutableInterface\n                ? $reference->getProduct()->getOSName()\n                : null\n            ;\n\n            if (isset($note->getData()['quantity'])) {\n                $quantity = $note->getData()['quantity']['data'];\n            } elseif (isset($note->getData()['amount.new'])) {\n                $quantity = $note->getData()['amount.new']['data'];\n            }\n\n            // add\n            $arrTimeline[$group][] = [\n                'icon' => $arrIcons[$note->getTitle()] ?? '',\n                'context' => $arrContext[$note->getTitle()] ?? 'default',\n                'type' => $note->getTitle(),\n                'date' => $formatter->formatDateTime($date->setTimestamp($note->getDate()), IntlFormatter::DATETIME_MEDIUM),\n                'avatar' => $avatar,\n                'user' => $user ? $user->getName() : null,\n                'message' => $note->getData()['message']['data'] ?? '',\n                'title' => $title ?: $note->getTitle(),\n                'quantity' => $quantity,\n            ];\n        }\n\n        $paymentProviders = $this->paymentManager->getProviderTypes();\n\n        return $this->render('@PimcoreEcommerceFramework/admin_order/detail.html.twig', [\n            'pimcoreUser' => \\Pimcore\\Tool\\Admin::getCurrentUser(),\n            'orderAgent' => $orderAgent,\n            'timeLine' => $arrTimeline,\n            'geoAddressInvoice' => $geoAddressInvoice,\n            'arrCustomerAccount' => $arrCustomerAccount,\n            'geoAddressDelivery' => $geoAddressDelivery,\n            'pimcoreSymfonyConfig' => $pimcoreSymfonyConfig,\n            'formatter' => $formatter,\n            'locale' => $localeService,\n            'paymentProviders' => $paymentProviders,\n        ]);\n    }\n\n    /**\n     * @Route(\"/item-cancel\", name=\"pimcore_ecommerce_backend_admin-order_item-cancel\", methods={\"GET\", \"POST\"})\n     *\n     * @param Request $request\n     * @param CsrfProtectionHandler $csrfProtection\n     *\n     * @return Response\n     */\n    public function itemCancelAction(Request $request, CsrfProtectionHandler $csrfProtection): Response\n    {\n        // init\n        $orderItem = OnlineShopOrderItem::getById((int) $request->get('id'));\n        if (!$orderItem) {\n            throw $this->createNotFoundException();\n        }\n        $order = $orderItem->getOrder();\n\n        if ($request->get('confirmed') && $orderItem->isCancelAble()) {\n            $csrfProtection->checkCsrfToken($request);\n            // init\n            $agent = $this->orderManager->createOrderAgent($order);\n\n            // cancel\n            $note = $agent->itemCancel($orderItem);\n\n            // extend log\n            $note->addData('message', 'text', $request->get('message'));\n            $note->save();\n\n            // redir\n            $url = $this->generateUrl('pimcore_ecommerce_backend_admin-order_detail', ['id' => $order->getId()]);\n\n            return $this->redirect($url);\n        }\n\n        return $this->render('@PimcoreEcommerceFramework/admin_order/item_cancel.html.twig', [\n            'orderItem' => $orderItem,\n        ]);\n    }\n\n    /**\n     * @Route(\"/item-edit\", name=\"pimcore_ecommerce_backend_admin-order_item-edit\", methods={\"GET\", \"POST\"})\n     *\n     */\n    public function itemEditAction(Request $request, CsrfProtectionHandler $csrfProtectionHandler): Response\n    {\n        // init\n        $orderItem = OnlineShopOrderItem::getById((int) $request->get('id'));\n        if (!$orderItem) {\n            throw $this->createNotFoundException();\n        }\n        $order = $orderItem->getOrder();\n\n        if ($request->get('confirmed')) {\n            $csrfProtectionHandler->checkCsrfToken($request);\n\n            // change item\n            $agent = $this->orderManager->createOrderAgent($order);\n            $note = $agent->itemChangeAmount($orderItem, (float) $request->get('quantity'));\n\n            // extend log\n            $note->addData('message', 'text', $request->get('message')); // 'text','date','document','asset','object','bool'\n            $note->save();\n\n            // redir\n            $url = $this->generateUrl('pimcore_ecommerce_backend_admin-order_detail', ['id' => $order->getId()]);\n\n            return $this->redirect($url);\n        }\n\n        return $this->render('@PimcoreEcommerceFramework/admin_order/item_edit.html.twig', [\n            'orderItem' => $orderItem,\n        ]);\n    }\n\n    /**\n     * @Route(\"/item-complaint\", name=\"pimcore_ecommerce_backend_admin-order_item-complaint\", methods={\"GET\", \"POST\"})\n     *\n     */\n    public function itemComplaintAction(Request $request, CsrfProtectionHandler $csrfProtectionHandler): Response\n    {\n        // init\n        $orderItem = OnlineShopOrderItem::getById((int) $request->get('id'));\n        if (!$orderItem) {\n            throw $this->createNotFoundException();\n        }\n        $order = $orderItem->getOrder();\n\n        if ($request->get('confirmed')) {\n            $csrfProtectionHandler->checkCsrfToken($request);\n\n            // change item\n            $agent = $this->orderManager->createOrderAgent($order);\n            $note = $agent->itemComplaint($orderItem, (float) $request->get('quantity'));\n\n            // extend log\n            $note->addData('message', 'text', $request->get('message'));\n            $note->save();\n\n            // redir\n            $url = $this->generateUrl('pimcore_ecommerce_backend_admin-order_detail', ['id' => $order->getId()]);\n\n            return $this->redirect($url);\n        }\n\n        return $this->render('@PimcoreEcommerceFramework/admin_order/item_complaint.html.twig', [\n            'orderItem' => $orderItem,\n        ]);\n    }\n}\n", "<?php\ndeclare(strict_types=1);\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\EcommerceFrameworkBundle\\Controller;\n\nuse Pimcore\\Controller\\KernelControllerEventInterface;\nuse Pimcore\\Controller\\UserAwareController;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\Event\\ControllerEvent;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Component\\Routing\\RouterInterface;\n\n/**\n * Class ConfigController\n *\n * @Route(\"/config\")\n *\n * @internal\n */\nclass ConfigController extends UserAwareController implements KernelControllerEventInterface\n{\n    /**\n     * ConfigController constructor.\n     *\n     * @param RouterInterface $router\n     */\n    public function __construct(private RouterInterface $router)\n    {\n        $this->router = $router;\n    }\n\n    public function onKernelControllerEvent(ControllerEvent $event): void\n    {\n        $this->checkPermission('bundle_ecommerce_back-office_order');\n    }\n\n    /**\n     * @Route(\"/js-config\", name=\"pimcore_ecommerceframework_config_jsconfig\", methods={\"GET\"})\n     *\n     * @return Response\n     */\n    public function jsConfigAction(): Response\n    {\n        $config = $this->getParameter('pimcore_ecommerce.pimcore.config');\n\n        $orderList = $config['menu']['order_list'];\n        if ($orderList['route']) {\n            $orderList['route'] = $this->router->generate($orderList['route']);\n        } elseif ($orderList['path']) {\n            $orderList['route'] = $orderList['path'];\n        }\n\n        unset($orderList['path']);\n\n        $config['menu']['order_list'] = $orderList;\n\n        $javascript = 'pimcore.registerNS(\"pimcore.bundle.EcommerceFramework.config\");' . PHP_EOL;\n\n        $javascript .= 'pimcore.bundle.EcommerceFramework.config = ';\n        $javascript .= json_encode($config) . ';';\n\n        $response = new Response($javascript);\n        $response->headers->set('Content-Type', 'application/javascript');\n\n        return $response;\n    }\n}\n", "<?php\ndeclare(strict_types=1);\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\EcommerceFrameworkBundle\\Controller;\n\nuse Pimcore\\Controller\\KernelControllerEventInterface;\nuse Pimcore\\Controller\\UserAwareController;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\Event\\ControllerEvent;\n\n/**\n * Class FindologicController\n *\n * Routing see routing.yaml\n *\n * @internal\n */\nclass FindologicController extends UserAwareController implements KernelControllerEventInterface\n{\n    public function onKernelControllerEvent(ControllerEvent $event): void\n    {\n        $this->checkPermission('bundle_ecommerce_back-office_order');\n    }\n\n    /**\n     * create xml output for findologic\n     */\n    public function exportAction(Request $request): Response\n    {\n        // init\n        $start = (int)$request->get('start');\n        $count = (int)$request->get('count', 200);\n        $shopKey = $request->get('shopkey');\n\n        $db = \\Pimcore\\Db::getConnection();\n\n        if ($request->get('id')) {\n            $query = \"SELECT SQL_CALC_FOUND_ROWS id, data FROM {$this->getExportTableName()} WHERE shop_key = :shop_key and id = :id LIMIT {$start}, {$count}\";\n            $items = $db->fetchAllAssociative($query, ['shop_key' => $shopKey, 'id' => (int) $request->get('id')]);\n        }\n        // load export items\n        elseif ($request->get('type')) {\n            $query = \"SELECT SQL_CALC_FOUND_ROWS id, data FROM {$this->getExportTableName()} WHERE shop_key = :shop_key and `type` = :type LIMIT {$start}, {$count}\";\n            $items = $db->fetchAllAssociative($query, ['shop_key' => $shopKey, 'type' => $request->get('type')]);\n        } else {\n            $query = \"SELECT SQL_CALC_FOUND_ROWS id, data FROM {$this->getExportTableName()} WHERE shop_key = :shop_key LIMIT {$start}, {$count}\";\n            $items = $db->fetchAllAssociative($query, ['shop_key' => $shopKey]);\n        }\n\n        // get counts\n        $indexCount = $db->fetchOne('SELECT FOUND_ROWS()');\n        $itemCount = count($items);\n\n        // create xml header\n        $xml = <<<XML\n<?xml version=\"1.0\"?>\n<findologic version=\"0.9\">\n    <items start=\"{$start}\" count=\"{$itemCount}\" total=\"{$indexCount}\">\nXML;\n\n        // add items\n        $transmitIds = [];\n        foreach ($items as $row) {\n            $xml .= $row['data'];\n\n            $transmitIds[] = $row['id'];\n        }\n\n        // complete xml\n        $xml .= <<<XML\n    </items>\n</findologic>\nXML;\n\n        // output\n        if ($request->get('validate')) {\n            $doc = new \\DOMDocument();\n            $doc->loadXML($xml);\n\n            $response = new Response();\n            var_dump($doc->schemaValidate('bundles/pimcoreecommerceframework/vendor/findologic/export.xsd'));\n        } else {\n            $response = new Response($xml);\n            $response->headers->set('Content-Type', 'text/xml');\n\n            // mark items as transmitted\n            if ($transmitIds) {\n                $db->executeQuery(sprintf(\n                    'UPDATE %1$s SET last_transmit = now() WHERE id in(%2$s)',\n                    $this->getExportTableName(),\n                    implode(',', $transmitIds)\n                ));\n            }\n        }\n\n        return $response;\n    }\n\n    protected function getExportTableName(): string\n    {\n        return 'ecommerceframework_productindex_export_findologic';\n    }\n}\n", "<?php\ndeclare(strict_types=1);\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\EcommerceFrameworkBundle\\Controller;\n\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\Event\\AdminEvents;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\Factory;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\IndexService\\ProductList\\ProductListInterface;\nuse Pimcore\\Controller\\KernelControllerEventInterface;\nuse Pimcore\\Controller\\Traits\\JsonHelperTrait;\nuse Pimcore\\Controller\\UserAwareController;\nuse Symfony\\Component\\EventDispatcher\\GenericEvent;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpKernel\\Event\\ControllerEvent;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\nuse Symfony\\Contracts\\Translation\\TranslatorInterface;\n\n/**\n * Class IndexController\n *\n * @Route(\"/index\")\n *\n * @internal\n */\nclass IndexController extends UserAwareController implements KernelControllerEventInterface\n{\n    use JsonHelperTrait;\n\n    public function onKernelControllerEvent(ControllerEvent $event): void\n    {\n        $this->checkPermission('bundle_ecommerce_back-office_order');\n    }\n\n    /**\n     * @Route(\"/get-filter-groups\", name=\"pimcore_ecommerceframework_index_getfiltergroups\", methods={\"GET\"})\n     *\n     * @return JsonResponse\n     */\n    public function getFilterGroupsAction(): JsonResponse\n    {\n        $indexService = Factory::getInstance()->getIndexService();\n        $tenants = Factory::getInstance()->getAllTenants();\n\n        $filterGroups = $indexService->getAllFilterGroups();\n        if ($tenants) {\n            foreach ($tenants as $tenant) {\n                $filterGroups = array_merge($filterGroups, $indexService->getAllFilterGroups($tenant));\n            }\n        }\n\n        $data = [];\n        if ($filterGroups) {\n            sort($filterGroups);\n            foreach ($filterGroups as $group) {\n                $data[$group] = ['data' => $group];\n            }\n        }\n\n        return $this->jsonResponse(['data' => array_values($data)]);\n    }\n\n    /**\n     * @Route(\"/get-values-for-filter-field\", name=\"pimcore_ecommerceframework_index_getvaluesforfilterfield\", methods={\"GET\"})\n     */\n    public function getValuesForFilterFieldAction(Request $request, EventDispatcherInterface $eventDispatcher): JsonResponse\n    {\n        try {\n            $data = [];\n            $factory = Factory::getInstance();\n\n            if ($request->get('field')) {\n                if ($request->get('tenant')) {\n                    Factory::getInstance()->getEnvironment()->setCurrentAssortmentTenant($request->get('tenant'));\n                }\n\n                $indexService = $factory->getIndexService();\n                $filterService = $factory->getFilterService();\n\n                $columnGroup = '';\n                $filterGroups = $indexService->getAllFilterGroups();\n                foreach ($filterGroups as $filterGroup) {\n                    $fields = $indexService->getIndexAttributesByFilterGroup($filterGroup);\n                    foreach ($fields as $field) {\n                        if ($field == $request->get('field')) {\n                            $columnGroup = $filterGroup;\n\n                            break 2;\n                        }\n                    }\n                }\n\n                $factory->getEnvironment()->setCurrentAssortmentSubTenant(null);\n                $productList = $factory->getIndexService()->getProductListForCurrentTenant();\n                $helper = $filterService->getFilterGroupHelper();\n                $data = $helper->getGroupByValuesForFilterGroup($columnGroup, $productList, $request->get('field'));\n            }\n\n            $event = new GenericEvent(null, ['data' => $data, 'field' => $request->get('field')]);\n            $eventDispatcher->dispatch($event, AdminEvents::GET_VALUES_FOR_FILTER_FIELD_PRE_SEND_DATA);\n            $data = $event->getArgument('data');\n\n            return $this->jsonResponse(['data' => array_values($data)]);\n        } catch (\\Exception $e) {\n            return $this->jsonResponse(['message' => $e->getMessage()]);\n        }\n    }\n\n    /**\n     * @Route(\"/get-fields\", name=\"pimcore_ecommerceframework_index_getfields\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     * @param TranslatorInterface $translator\n     *\n     * @return JsonResponse\n     */\n    public function getFieldsAction(Request $request, EventDispatcherInterface $eventDispatcher, TranslatorInterface $translator): JsonResponse\n    {\n        $indexService = Factory::getInstance()->getIndexService();\n\n        if ($request->get('filtergroup')) {\n            $filtergroups = $request->get('filtergroup');\n\n            $indexColumns = [];\n            foreach ($filtergroups as $filtergroup) {\n                $indexColumns = array_merge($indexColumns, $indexService->getIndexAttributesByFilterGroup($filtergroup, $request->get('tenant')));\n            }\n        } else {\n            if ($request->get('show_all_fields') == 'true') {\n                $indexColumns = $indexService->getIndexAttributes(false, $request->get('tenant'));\n            } else {\n                $indexColumns = $indexService->getIndexAttributes(true, $request->get('tenant'));\n            }\n        }\n\n        if (!$indexColumns) {\n            $indexColumns = [];\n        }\n\n        $fields = [];\n\n        if ($request->get('add_empty') == 'true') {\n            $fields[' '] = ['key' => '', 'name' => '(' . $translator->trans('empty', [], 'messages') . ')'];\n        }\n\n        foreach ($indexColumns as $c) {\n            $fields[$c] = ['key' => $c, 'name' => $translator->trans($c, [], 'admin')];\n        }\n\n        if ($request->get('specific_price_field') == 'true') {\n            $fields[ProductListInterface::ORDERKEY_PRICE] = [\n                'key' => ProductListInterface::ORDERKEY_PRICE,\n                'name' => $translator->trans(ProductListInterface::ORDERKEY_PRICE, [], 'admin'),\n            ];\n        }\n\n        ksort($fields);\n\n        $event = new GenericEvent(null, ['data' => $fields]);\n        $eventDispatcher->dispatch($event, AdminEvents::GET_INDEX_FIELD_NAMES_PRE_SEND_DATA);\n        $data = $event->getArgument('data');\n\n        return $this->jsonResponse(['data' => array_values($data)]);\n    }\n\n    /**\n     * @Route(\"/get-all-tenants\", name=\"pimcore_ecommerceframework_index_getalltenants\", methods={\"GET\"})\n     *\n     * @param TranslatorInterface $translator\n     *\n     * @return JsonResponse\n     */\n    public function getAllTenantsAction(TranslatorInterface $translator): JsonResponse\n    {\n        $tenants = Factory::getInstance()->getAllTenants();\n        $data = [];\n\n        if ($tenants) {\n            foreach ($tenants as $tenant) {\n                $data[] = ['key' => $tenant, 'name' => $translator->trans($tenant, [], 'admin')];\n            }\n        }\n\n        return $this->jsonResponse(['data' => $data]);\n    }\n}\n", "<?php\ndeclare(strict_types=1);\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\EcommerceFrameworkBundle\\Controller;\n\nuse Exception;\n\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\Factory;\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\PricingManager\\Rule;\nuse Pimcore\\Controller\\KernelControllerEventInterface;\nuse Pimcore\\Controller\\Traits\\JsonHelperTrait;\nuse Pimcore\\Controller\\UserAwareController;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpKernel\\Event\\ControllerEvent;\nuse Symfony\\Component\\HttpKernel\\Exception\\NotFoundHttpException;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\n\n/**\n * Class ConfigController\n *\n * @Route(\"/pricing\")\n *\n * @internal\n */\nclass PricingController extends UserAwareController implements KernelControllerEventInterface\n{\n    use JsonHelperTrait;\n\n    public function onKernelControllerEvent(ControllerEvent $event): void\n    {\n        // permission check\n        $this->checkPermission('bundle_ecommerce_pricing_rules');\n    }\n\n    /**\n     * @Route(\"/list\", name=\"pimcore_ecommerceframework_pricing_list\", methods={\"GET\"})\n     */\n    public function listAction(): JsonResponse\n    {\n        $rules = new Rule\\Listing();\n        $rules->setOrderKey('prio');\n        $rules->setOrder('ASC');\n\n        $json = [];\n        foreach ($rules->load() as $rule) {\n            if ($rule->getActive()) {\n                $icon = 'bundle_ecommerce_pricing_icon_rule_' . $rule->getBehavior();\n                $title = 'Verhalten: ' . $rule->getBehavior();\n            } else {\n                $icon = 'bundle_ecommerce_pricing_icon_rule_disabled';\n                $title = 'Deaktiviert';\n            }\n\n            $json[] = [\n                'iconCls' => $icon,\n                'id' => $rule->getId(),\n                'text' => $rule->getName(),\n                'qtipCfg' => [\n                    'xtype' => 'quicktip',\n                    'title' => $rule->getLabel(),\n                    'text' => $title,\n                ],\n            ];\n        }\n\n        return $this->jsonResponse($json);\n    }\n\n    /**\n     * get priceing rule details as json\n     *\n     * @Route(\"/get\", name=\"pimcore_ecommerceframework_pricing_get\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     *\n     * @throws NotFoundHttpException\n     */\n    public function getAction(Request $request): JsonResponse\n    {\n        $rule = Rule::getById((int) $request->get('id'));\n        if ($rule) {\n            // get data\n            $condition = $rule->getCondition();\n            $localizedLabel = [];\n            $localizedDescription = [];\n\n            foreach (\\Pimcore\\Tool::getValidLanguages() as $lang) {\n                $localizedLabel[$lang] = $rule->getLabel($lang);\n                $localizedDescription[$lang] = $rule->getDescription($lang);\n            }\n\n            // create json config\n            $json = [\n                'id' => $rule->getId(),\n                'name' => $rule->getName(),\n                'label' => $localizedLabel,\n                'description' => $localizedDescription,\n                'behavior' => $rule->getBehavior(),\n                'active' => $rule->getActive(),\n                'condition' => $condition ? json_decode($condition->toJSON()) : '',\n                'actions' => [],\n            ];\n\n            foreach ($rule->getActions() as $action) {\n                $json['actions'][] = json_decode($action->toJSON());\n            }\n\n            return $this->jsonResponse($json);\n        }\n\n        throw $this->createNotFoundException('Rule not found');\n    }\n\n    /**\n     * add new rule\n     *\n     * @Route(\"/add\", name=\"pimcore_ecommerceframework_pricing_add\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function addAction(Request $request): JsonResponse\n    {\n        // send json respone\n        $return = [\n            'success' => false,\n            'message' => '',\n        ];\n\n        // save rule\n        try {\n            $rule = new Rule();\n            $rule->setName($request->get('name'));\n            $rule->save();\n\n            $return['success'] = true;\n            $return['id'] = $rule->getId();\n        } catch (\\Exception $e) {\n            $return['message'] = $e->getMessage();\n        }\n\n        // send respone\n        return $this->jsonResponse($return);\n    }\n\n    /**\n     * delete exiting rule\n     *\n     * @Route(\"/delete\", name=\"pimcore_ecommerceframework_pricing_delete\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function deleteAction(Request $request): JsonResponse\n    {\n        // send json respone\n        $return = [\n            'success' => false,\n            'message' => '',\n        ];\n\n        // delete rule\n        try {\n            $rule = Rule::getById((int) $request->get('id'));\n            $rule->delete();\n            $return['success'] = true;\n        } catch (\\Exception $e) {\n            $return['message'] = $e->getMessage();\n        }\n\n        // send respone\n        return $this->jsonResponse($return);\n    }\n\n    /**\n     * @Route(\"/copy\", name=\"pimcore_ecommerceframework_pricing_copy\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     * copy existing rule\n     */\n    public function copyAction(Request $request): JsonResponse\n    {\n        // send json respone\n        $return = [\n            'success' => false,\n            'message' => '',\n        ];\n\n        // copy rule\n        try {\n            /** @var Rule $ruleSource */\n            $ruleSource = Rule::getById((int) $request->get('id'));\n            $rules = (new Rule\\Listing())->load();\n\n            $name = $ruleSource->getName() . '_copy';\n\n            // Get new unique name.\n            do {\n                $uniqueName = true;\n\n                foreach ($rules as $rule) {\n                    if ($rule->getName() == $name) {\n                        $uniqueName = false;\n                        $name .= '_copy';\n\n                        break;\n                    }\n                }\n            } while (!$uniqueName);\n\n            // Clone and save new rule.\n            $newRule = clone $ruleSource;\n            $newRule->setId(null);\n            $newRule->setName($name);\n            $newRule->save();\n\n            $return['success'] = true;\n        } catch (\\Exception $e) {\n            $return['message'] = $e->getMessage();\n        }\n\n        // send respone\n        return $this->jsonResponse($return);\n    }\n\n    /**\n     * @Route(\"/rename\", name=\"pimcore_ecommerceframework_pricing_rename\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     * rename exiting rule\n     */\n    public function renameAction(Request $request): JsonResponse\n    {\n        // send json respone\n        $return = [\n            'success' => false,\n            'message' => '',\n        ];\n\n        $ruleId = $request->request->getInt('id');\n        $ruleNewName = $request->request->get('name');\n\n        try {\n            if ($ruleId && $ruleNewName && preg_match('/^[a-zA-Z0-9_\\-]+$/', $ruleNewName)) {\n                $renameRule = Rule::getById($ruleId);\n\n                if ($renameRule->getName() != $ruleNewName) {\n                    $rules = (new Rule\\Listing())->load();\n\n                    // Check if rulename is available.\n                    foreach ($rules as $rule) {\n                        if ($rule->getName() == $ruleNewName) {\n                            throw new Exception('Rulename already exists.');\n                        }\n                    }\n\n                    $renameRule->setName($ruleNewName);\n                    $renameRule->save();\n                }\n\n                $return['success'] = true;\n            }\n        } catch (Exception $e) {\n            $return['message'] = $e->getMessage();\n        }\n\n        // send respone\n        return $this->jsonResponse($return);\n    }\n\n    /**\n     * save rule config\n     *\n     * @Route(\"/save\", name=\"pimcore_ecommerceframework_pricing_save\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function saveAction(Request $request): JsonResponse\n    {\n        // send json respone\n        $return = [\n            'success' => false,\n            'message' => '',\n        ];\n\n        // save rule config\n        try {\n            $data = json_decode($request->get('data'));\n            $rule = Rule::getById((int) $request->get('id'));\n\n            // apply basic settings\n            $rule->setBehavior($data->settings->behavior)\n                ->setActive((bool)$data->settings->active);\n\n            // apply lang fields\n            foreach (\\Pimcore\\Tool::getValidLanguages() as $lang) {\n                $rule->setLabel($data->settings->{'label.' . $lang}, $lang);\n                $rule->setDescription($data->settings->{'description.' . $lang}, $lang);\n            }\n\n            // create root condition\n            $rootContainer = new \\stdClass();\n            $rootContainer->parent = null;\n            $rootContainer->operator = null;\n            $rootContainer->type = 'Bracket';\n            $rootContainer->conditions = [];\n\n            // create a tree from the flat structure\n            $currentContainer = $rootContainer;\n            foreach ($data->conditions as $settings) {\n                // handle brackets\n                if ($settings->bracketLeft == true) {\n                    $newContainer = new \\stdClass();\n                    $newContainer->parent = $currentContainer;\n                    $newContainer->type = 'Bracket';\n                    $newContainer->conditions = [];\n\n                    // move condition from current item to bracket item\n                    $newContainer->operator = $settings->operator;\n                    $settings->operator = null;\n\n                    $currentContainer->conditions[] = $newContainer;\n                    $currentContainer = $newContainer;\n                }\n\n                $currentContainer->conditions[] = $settings;\n\n                if ($settings->bracketRight == true) {\n                    $old = $currentContainer;\n                    $currentContainer = $currentContainer->parent;\n                    unset($old->parent);\n                }\n            }\n\n            // create rule condition\n            $condition = Factory::getInstance()->getPricingManager()->getCondition($rootContainer->type);\n            $condition->fromJSON(json_encode($rootContainer));\n            $rule->setCondition($condition);\n\n            // save action\n            $arrActions = [];\n            foreach ($data->actions as $setting) {\n                $action = Factory::getInstance()->getPricingManager()->getAction($setting->type);\n                $action->fromJSON(json_encode($setting));\n                $arrActions[] = $action;\n            }\n            $rule->setActions($arrActions);\n\n            // save rule\n            $rule->save();\n\n            // finish\n            $return['success'] = true;\n            $return['id'] = $rule->getId();\n        } catch (\\Exception $e) {\n            $return['message'] = $e->getMessage();\n        }\n\n        // send respone\n        return $this->jsonResponse($return);\n    }\n\n    /**\n     * @Route(\"/save-order\", name=\"pimcore_ecommerceframework_pricing_save-order\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function saveOrderAction(Request $request): JsonResponse\n    {\n        // send json respone\n        $return = [\n            'success' => false,\n            'message' => '',\n        ];\n\n        // save order\n        $rules = json_decode($request->get('rules'));\n        foreach ($rules as $id => $prio) {\n            $rule = Rule::getById((int)$id);\n            if ($rule) {\n                $rule->setPrio((int)$prio)->save();\n            }\n        }\n        $return['success'] = true;\n\n        // send respone\n        return $this->jsonResponse($return);\n    }\n\n    /**\n     * @Route(\"/get-config\", name=\"pimcore_ecommerceframework_pricing_get-config\", methods={\"GET\"})\n     *\n     * @return JsonResponse\n     */\n    public function getConfigAction(): JsonResponse\n    {\n        $pricingManager = Factory::getInstance()->getPricingManager();\n\n        return $this->jsonResponse([\n            'condition' => array_keys($pricingManager->getConditionMapping()),\n            'action' => array_keys($pricingManager->getActionMapping()),\n        ]);\n    }\n}\n", "<?php\ndeclare(strict_types=1);\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\EcommerceFrameworkBundle\\Controller;\n\nuse Pimcore\\Bundle\\EcommerceFrameworkBundle\\VoucherService\\TokenManager\\ExportableTokenManagerInterface;\nuse Pimcore\\Controller\\KernelControllerEventInterface;\nuse Pimcore\\Controller\\UserAwareController;\nuse Pimcore\\Model\\DataObject;\nuse Pimcore\\Model\\DataObject\\Localizedfield;\nuse Pimcore\\Model\\DataObject\\OnlineShopVoucherSeries;\nuse Pimcore\\Security\\User\\TokenStorageUserResolver;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\Event\\ControllerEvent;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\Translation\\LocaleAwareInterface;\nuse Symfony\\Contracts\\Translation\\TranslatorInterface;\n\n/**\n * Class VoucherController\n *\n * @Route(\"/voucher\")\n *\n * @internal\n */\nclass VoucherController extends UserAwareController implements KernelControllerEventInterface\n{\n    protected TokenStorageUserResolver $tokenResolver;\n\n    protected TranslatorInterface $translator;\n\n    /**\n     * @param TokenStorageUserResolver $tokenStorageUserResolver\n     * @param TranslatorInterface $translator\n     */\n    public function __construct(TokenStorageUserResolver $tokenStorageUserResolver, TranslatorInterface $translator)\n    {\n        $this->tokenResolver = $tokenStorageUserResolver;\n        $this->translator = $translator;\n    }\n\n    public function onKernelControllerEvent(ControllerEvent $event): void\n    {\n        $this->checkPermission('bundle_ecommerce_pricing_rules');\n\n        // set language\n        $user = $this->tokenResolver->getUser();\n\n        if ($user) {\n            if ($this->translator instanceof LocaleAwareInterface) {\n                $this->translator->setLocale($user->getLanguage());\n            }\n            $event->getRequest()->setLocale($user->getLanguage());\n        }\n\n        // enable inherited values\n        DataObject::setGetInheritedValues(true);\n        Localizedfield::setGetFallbackValues(true);\n    }\n\n    /**\n     * Loads and shows voucherservice backend tab\n     *\n     * @Route(\"/voucher-code-tab\", name=\"pimcore_ecommerce_backend_voucher_voucher-code-tab\", methods={\"GET\"})\n     */\n    public function voucherCodeTabAction(Request $request): Response\n    {\n        $onlineShopVoucherSeries = OnlineShopVoucherSeries::getById((int) $request->get('id'));\n\n        if (!$onlineShopVoucherSeries) {\n            throw $this->createNotFoundException('Voucher series not found');\n        }\n\n        $paramsBag = [];\n        if ($tokenManager = $onlineShopVoucherSeries->getTokenManager()) {\n            $paramsBag['series'] = $onlineShopVoucherSeries;\n            $paramsBag['voucherType'] = $tokenManager->getConfiguration()->getType();\n\n            if ($tokenManager instanceof ExportableTokenManagerInterface) {\n                $paramsBag['supportsExport'] = true;\n            }\n\n            $renderScript = $tokenManager->prepareConfigurationView($paramsBag, $request->query->all());\n\n            return $this->render($renderScript, $paramsBag);\n        } else {\n            $paramsBag['errors'] = ['bundle_ecommerce_voucherservice_msg-error-config-missing'];\n\n            return $this->render('@PimcoreEcommerceFramework/voucher/voucher_code_tab_error.html.twig', $paramsBag);\n        }\n    }\n\n    /**\n     * Export tokens to file. The action should implement all export formats defined in ExportableTokenManagerInterface.\n     *\n     * @Route(\"/export-tokens\", name=\"pimcore_ecommerce_backend_voucher_export-tokens\", methods={\"GET\"})\n     */\n    public function exportTokensAction(Request $request): Response\n    {\n        $onlineShopVoucherSeries = OnlineShopVoucherSeries::getById((int) $request->get('id'));\n\n        if (!$onlineShopVoucherSeries) {\n            throw $this->createNotFoundException('Voucher series not found');\n        }\n\n        $tokenManager = $onlineShopVoucherSeries->getTokenManager();\n        if (!(null !== $tokenManager && $tokenManager instanceof ExportableTokenManagerInterface)) {\n            throw new \\InvalidArgumentException('Token manager does not support exporting');\n        }\n\n        $format = $request->get('format', ExportableTokenManagerInterface::FORMAT_CSV);\n        $contentType = null;\n        $suffix = null;\n        $download = true;\n\n        switch ($format) {\n            case ExportableTokenManagerInterface::FORMAT_CSV:\n                $result = $tokenManager->exportCsv($request->query->all());\n                $contentType = 'text/csv';\n                $suffix = 'csv';\n\n                break;\n\n            case ExportableTokenManagerInterface::FORMAT_PLAIN:\n                $result = $tokenManager->exportPlain($request->query->all());\n                $contentType = 'text/plain';\n                $suffix = 'txt';\n                $download = false;\n\n                break;\n\n            default:\n                throw new \\InvalidArgumentException('Invalid format');\n        }\n\n        $response = new Response($result);\n        $response->headers->set('Content-Type', $contentType);\n        $response->headers->set('Content-Length', (string) strlen($result));\n\n        if ($download && null !== $suffix) {\n            $response->headers->set('Content-Disposition', sprintf('attachment; filename=\"voucher-export.%s\"', $suffix));\n        }\n\n        return $response;\n    }\n\n    /**\n     * Generates new Tokens or Applies single token settings.\n     *\n     * @Route(\"/generate\", name=\"pimcore_ecommerce_backend_voucher_generate\", methods={\"GET\"})\n     */\n    public function generateAction(Request $request): Response\n    {\n        $onlineShopVoucherSeries = OnlineShopVoucherSeries::getById((int) $request->get('id'));\n\n        if (!$onlineShopVoucherSeries) {\n            throw $this->createNotFoundException('Could not get voucher series, probably you did not provide a correct id.');\n        }\n\n        if ($tokenManager = $onlineShopVoucherSeries->getTokenManager()) {\n            $result = $tokenManager->insertOrUpdateVoucherSeries();\n\n            $params = ['id' => $request->get('id')]; //$request->query->all();\n\n            if ($result === false) {\n                $params['error'] = $this->translator->trans('bundle_ecommerce_voucherservice_msg-error-generation', [], 'admin');\n            } else {\n                $params['success'] = $this->translator->trans('bundle_ecommerce_voucherservice_msg-success-generation', [], 'admin');\n            }\n\n            return $this->redirectToRoute(\n                'pimcore_ecommerce_backend_voucher_voucher-code-tab',\n                $params\n            );\n        }\n\n        throw $this->createNotFoundException();\n    }\n\n    /**\n     * Removes tokens due to given filter parameters.\n     *\n     * @Route(\"/cleanup\", name=\"pimcore_ecommerce_backend_voucher_cleanup\", methods={\"POST\"})\n     */\n    public function cleanupAction(Request $request): Response\n    {\n        $onlineShopVoucherSeries = OnlineShopVoucherSeries::getById((int) $request->get('id'));\n\n        if (!$onlineShopVoucherSeries) {\n            throw $this->createNotFoundException('Could not get voucher series, probably you did not provide a correct id.');\n        }\n        if ($tokenManager = $onlineShopVoucherSeries->getTokenManager()) {\n            // Prepare cleanUp parameter array.\n            $params = ['id' => $request->get('id')]; // $request->query->all();\n            $request->get('usage') ? $params['usage'] = $request->get('usage') : '';\n            $request->get('olderThan') ? $params['olderThan'] = $request->get('olderThan') : '';\n\n            if (empty($params['usage'])) {\n                $params['error'] = $this->translator->trans('bundle_ecommerce_voucherservice_msg-error-required-missing', [], 'admin');\n            } elseif ($tokenManager->cleanUpCodes($params)) {\n                $params['success'] = $this->translator->trans('bundle_ecommerce_voucherservice_msg-success-cleanup', [], 'admin');\n            } else {\n                $params['error'] = $this->translator->trans('bundle_ecommerce_voucherservice_msg-error-cleanup', [], 'admin');\n            }\n\n            return $this->redirectToRoute(\n                'pimcore_ecommerce_backend_voucher_voucher-code-tab',\n                $params\n            );\n        }\n\n        throw $this->createNotFoundException();\n    }\n\n    /**\n     * Removes token reservations due to given duration.\n     *\n     * @Route(\"/cleanup-reservations\", name=\"pimcore_ecommerce_backend_voucher_cleanup-reservations\", methods={\"POST\"})\n     *\n     */\n    public function cleanupReservationsAction(Request $request): \\Symfony\\Component\\HttpFoundation\\RedirectResponse\n    {\n        $duration = $request->get('duration');\n        $id = $request->request->getInt('id');\n\n        if ($duration === '') {\n            return $this->redirectToRoute(\n                'pimcore_ecommerce_backend_voucher_voucher-code-tab',\n                ['error' => $this->translator->trans('bundle_ecommerce_voucherservice_msg-error-cleanup-reservations-duration-missing', [], 'admin'), 'id' => $id]\n            );\n        }\n\n        $onlineShopVoucherSeries = DataObject::getById($id);\n        if ($onlineShopVoucherSeries instanceof OnlineShopVoucherSeries) {\n            if ($tokenManager = $onlineShopVoucherSeries->getTokenManager()) {\n                if ($tokenManager->cleanUpReservations((int)$duration, $id)) {\n                    return $this->redirectToRoute(\n                        'pimcore_ecommerce_backend_voucher_voucher-code-tab',\n                        ['success' => $this->translator->trans('bundle_ecommerce_voucherservice_msg-success-cleanup-reservations', [], 'admin'), 'id' => $id]\n                    );\n                }\n            }\n        }\n\n        return $this->redirectToRoute(\n            'pimcore_ecommerce_backend_voucher_voucher-code-tab',\n            ['error' => $this->translator->trans('bundle_ecommerce_voucherservice_msg-error-cleanup-reservations', [], 'admin'), 'id' => $id]\n        );\n    }\n}\n"], "filenames": ["src/Controller/AdminOrderController.php", "src/Controller/ConfigController.php", "src/Controller/FindologicController.php", "src/Controller/IndexController.php", "src/Controller/PricingController.php", "src/Controller/VoucherController.php"], "buggy_code_start_loc": [70, 18, 19, 21, 46, 20], "buggy_code_end_loc": [70, 40, 31, 40, 50, 57], "fixing_code_start_loc": [71, 19, 19, 22, 46, 19], "fixing_code_end_loc": [73, 48, 39, 48, 47, 60], "type": "NVD-CWE-Other", "message": "ecommerce-framework-bundle is the Pimcore Ecommerce Framework Bundle. An authenticated and unauthorized user can access the back-office orders list and be able to query over the information returned. Access control and permissions are not being enforced. This vulnerability has been patched in version 1.0.10.", "other": {"cve": {"id": "CVE-2024-21665", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-11T01:15:45.413", "lastModified": "2024-01-17T22:18:50.007", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ecommerce-framework-bundle is the Pimcore Ecommerce Framework Bundle. An authenticated and unauthorized user can access the back-office orders list and be able to query over the information returned. Access control and permissions are not being enforced. This vulnerability has been patched in version 1.0.10."}, {"lang": "es", "value": "ecommerce-framework-bundle es el paquete Pimcore Ecommerce Framework. Un usuario autenticado y no autorizado puede acceder a la lista de pedidos administrativos y consultar la informaci\u00f3n devuelta. No se aplican controles de acceso ni permisos. Esta vulnerabilidad ha sido parcheada en la versi\u00f3n 1.0.10."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pimcore:e-commerce_framework:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.10", "matchCriteriaId": "48398AC0-C6E1-42B8-84A7-EF1E65C55749"}]}]}], "references": [{"url": "https://github.com/pimcore/ecommerce-framework-bundle/blob/ff6ff287b6eb468bb940909c56970363596e5c21/src/Controller/AdminOrderController.php#L98", "source": "security-advisories@github.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/pimcore/ecommerce-framework-bundle/commit/05dec000ed009828084d05cf686f468afd1f464e", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/pimcore/ecommerce-framework-bundle/releases/tag/v1.0.10", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/pimcore/ecommerce-framework-bundle/security/advisories/GHSA-cx99-25hr-5jxf", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/pimcore/ecommerce-framework-bundle/commit/05dec000ed009828084d05cf686f468afd1f464e"}}