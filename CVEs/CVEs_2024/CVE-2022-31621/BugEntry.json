{"buggy_code": ["/******************************************************\nCopyright (c) 2011-2013 Percona LLC and/or its affiliates.\n\nStreaming implementation for XtraBackup.\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; version 2 of the License.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA\n\n*******************************************************/\n\n#include <mysql_version.h>\n#include <my_base.h>\n#include \"common.h\"\n#include \"datasink.h\"\n#include \"xbstream.h\"\n\ntypedef struct {\n\txb_wstream_t\t*xbstream;\n\tds_file_t\t*dest_file;\n\tpthread_mutex_t\tmutex;\n} ds_stream_ctxt_t;\n\ntypedef struct {\n\txb_wstream_file_t\t*xbstream_file;\n\tds_stream_ctxt_t\t*stream_ctxt;\n} ds_stream_file_t;\n\n/***********************************************************************\nGeneral streaming interface */\n\nstatic ds_ctxt_t *xbstream_init(const char *root);\nstatic ds_file_t *xbstream_open(ds_ctxt_t *ctxt, const char *path,\n\t\t\t      MY_STAT *mystat);\nstatic int xbstream_write(ds_file_t *file, const uchar *buf, size_t len);\nstatic int xbstream_close(ds_file_t *file);\nstatic void xbstream_deinit(ds_ctxt_t *ctxt);\n\ndatasink_t datasink_xbstream = {\n\t&xbstream_init,\n\t&xbstream_open,\n\t&xbstream_write,\n\t&xbstream_close,\n\t&dummy_remove,\n\t&xbstream_deinit\n};\n\nstatic\nssize_t\nmy_xbstream_write_callback(xb_wstream_file_t *f __attribute__((unused)),\n\t\t       void *userdata, const void *buf, size_t len)\n{\n\tds_stream_ctxt_t\t*stream_ctxt;\n\n\tstream_ctxt = (ds_stream_ctxt_t *) userdata;\n\n\txb_ad(stream_ctxt != NULL);\n\txb_ad(stream_ctxt->dest_file != NULL);\n\n\tif (!ds_write(stream_ctxt->dest_file, buf, len)) {\n\t\treturn len;\n\t}\n\treturn -1;\n}\n\nstatic\nds_ctxt_t *\nxbstream_init(const char *root __attribute__((unused)))\n{\n\tds_ctxt_t\t\t*ctxt;\n\tds_stream_ctxt_t\t*stream_ctxt;\n\txb_wstream_t *xbstream;\n\n\tctxt = (ds_ctxt_t *)my_malloc(sizeof(ds_ctxt_t) + sizeof(ds_stream_ctxt_t),\n\t\t\t MYF(MY_FAE));\n\tstream_ctxt = (ds_stream_ctxt_t *)(ctxt + 1);\n\n\tif (pthread_mutex_init(&stream_ctxt->mutex, NULL)) {\n\t\tmsg(\"xbstream_init: pthread_mutex_init() failed.\");\n\t\tgoto err;\n\t}\n\n\txbstream = xb_stream_write_new();\n\tif (xbstream == NULL) {\n\t\tmsg(\"xb_stream_write_new() failed.\");\n\t\tgoto err;\n\t}\n\tstream_ctxt->xbstream = xbstream;\n\tstream_ctxt->dest_file = NULL;\n\n\tctxt->ptr = stream_ctxt;\n\n\treturn ctxt;\n\nerr:\n\tmy_free(ctxt);\n\treturn NULL;\n}\n\nstatic\nds_file_t *\nxbstream_open(ds_ctxt_t *ctxt, const char *path, MY_STAT *mystat)\n{\n\tds_file_t\t\t*file;\n\tds_stream_file_t\t*stream_file;\n\tds_stream_ctxt_t\t*stream_ctxt;\n\tds_ctxt_t\t\t*dest_ctxt;\n\txb_wstream_t\t\t*xbstream;\n\txb_wstream_file_t\t*xbstream_file;\n\n\n\txb_ad(ctxt->pipe_ctxt != NULL);\n\tdest_ctxt = ctxt->pipe_ctxt;\n\n\tstream_ctxt = (ds_stream_ctxt_t *) ctxt->ptr;\n\n\tpthread_mutex_lock(&stream_ctxt->mutex);\n\tif (stream_ctxt->dest_file == NULL) {\n\t\tstream_ctxt->dest_file = ds_open(dest_ctxt, path, mystat);\n\t\tif (stream_ctxt->dest_file == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tpthread_mutex_unlock(&stream_ctxt->mutex);\n\n\tfile = (ds_file_t *) my_malloc(sizeof(ds_file_t) +\n\t\t\t\t       sizeof(ds_stream_file_t),\n\t\t\t\t       MYF(MY_FAE));\n\tstream_file = (ds_stream_file_t *) (file + 1);\n\n\txbstream = stream_ctxt->xbstream;\n\n\txbstream_file = xb_stream_write_open(xbstream, path, mystat,\n\t\t                             stream_ctxt,\n\t\t\t\t\t     my_xbstream_write_callback);\n\n\tif (xbstream_file == NULL) {\n\t\tmsg(\"xb_stream_write_open() failed.\");\n\t\tgoto err;\n\t}\n\n\tstream_file->xbstream_file = xbstream_file;\n\tstream_file->stream_ctxt = stream_ctxt;\n\tfile->ptr = stream_file;\n\tfile->path = stream_ctxt->dest_file->path;\n\n\treturn file;\n\nerr:\n\tif (stream_ctxt->dest_file) {\n\t\tds_close(stream_ctxt->dest_file);\n\t\tstream_ctxt->dest_file = NULL;\n\t}\n\tmy_free(file);\n\n\treturn NULL;\n}\n\nstatic\nint\nxbstream_write(ds_file_t *file, const uchar *buf, size_t len)\n{\n\tds_stream_file_t\t*stream_file;\n\txb_wstream_file_t\t*xbstream_file;\n\n\n\tstream_file = (ds_stream_file_t *) file->ptr;\n\n\txbstream_file = stream_file->xbstream_file;\n\n\tif (xb_stream_write_data(xbstream_file, buf, len)) {\n\t\tmsg(\"xb_stream_write_data() failed.\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic\nint\nxbstream_close(ds_file_t *file)\n{\n\tds_stream_file_t\t*stream_file;\n\tint\t\t\trc = 0;\n\n\tstream_file = (ds_stream_file_t *)file->ptr;\n\n\trc = xb_stream_write_close(stream_file->xbstream_file);\n\n\tmy_free(file);\n\n\treturn rc;\n}\n\nstatic\nvoid\nxbstream_deinit(ds_ctxt_t *ctxt)\n{\n\tds_stream_ctxt_t\t*stream_ctxt;\n\n\tstream_ctxt = (ds_stream_ctxt_t *) ctxt->ptr;\n\n\tif (xb_stream_write_done(stream_ctxt->xbstream)) {\n\t\tmsg(\"xb_stream_done() failed.\");\n\t}\n\n\tif (stream_ctxt->dest_file) {\n\t\tds_close(stream_ctxt->dest_file);\n\t\tstream_ctxt->dest_file = NULL;\n\t}\n\n\tpthread_mutex_destroy(&stream_ctxt->mutex);\n\n\tmy_free(ctxt);\n}\n"], "fixing_code": ["/******************************************************\nCopyright (c) 2011-2013 Percona LLC and/or its affiliates.\n\nStreaming implementation for XtraBackup.\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; version 2 of the License.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA\n\n*******************************************************/\n\n#include <mysql_version.h>\n#include <my_base.h>\n#include \"common.h\"\n#include \"datasink.h\"\n#include \"xbstream.h\"\n\ntypedef struct {\n\txb_wstream_t\t*xbstream;\n\tds_file_t\t*dest_file;\n\tpthread_mutex_t\tmutex;\n} ds_stream_ctxt_t;\n\ntypedef struct {\n\txb_wstream_file_t\t*xbstream_file;\n\tds_stream_ctxt_t\t*stream_ctxt;\n} ds_stream_file_t;\n\n/***********************************************************************\nGeneral streaming interface */\n\nstatic ds_ctxt_t *xbstream_init(const char *root);\nstatic ds_file_t *xbstream_open(ds_ctxt_t *ctxt, const char *path,\n\t\t\t      MY_STAT *mystat);\nstatic int xbstream_write(ds_file_t *file, const uchar *buf, size_t len);\nstatic int xbstream_close(ds_file_t *file);\nstatic void xbstream_deinit(ds_ctxt_t *ctxt);\n\ndatasink_t datasink_xbstream = {\n\t&xbstream_init,\n\t&xbstream_open,\n\t&xbstream_write,\n\t&xbstream_close,\n\t&dummy_remove,\n\t&xbstream_deinit\n};\n\nstatic\nssize_t\nmy_xbstream_write_callback(xb_wstream_file_t *f __attribute__((unused)),\n\t\t       void *userdata, const void *buf, size_t len)\n{\n\tds_stream_ctxt_t\t*stream_ctxt;\n\n\tstream_ctxt = (ds_stream_ctxt_t *) userdata;\n\n\txb_ad(stream_ctxt != NULL);\n\txb_ad(stream_ctxt->dest_file != NULL);\n\n\tif (!ds_write(stream_ctxt->dest_file, buf, len)) {\n\t\treturn len;\n\t}\n\treturn -1;\n}\n\nstatic\nds_ctxt_t *\nxbstream_init(const char *root __attribute__((unused)))\n{\n\tds_ctxt_t\t\t*ctxt;\n\tds_stream_ctxt_t\t*stream_ctxt;\n\txb_wstream_t *xbstream;\n\n\tctxt = (ds_ctxt_t *)my_malloc(sizeof(ds_ctxt_t) + sizeof(ds_stream_ctxt_t),\n\t\t\t MYF(MY_FAE));\n\tstream_ctxt = (ds_stream_ctxt_t *)(ctxt + 1);\n\n\tif (pthread_mutex_init(&stream_ctxt->mutex, NULL)) {\n\t\tmsg(\"xbstream_init: pthread_mutex_init() failed.\");\n\t\tgoto err;\n\t}\n\n\txbstream = xb_stream_write_new();\n\tif (xbstream == NULL) {\n\t\tmsg(\"xb_stream_write_new() failed.\");\n\t\tgoto err;\n\t}\n\tstream_ctxt->xbstream = xbstream;\n\tstream_ctxt->dest_file = NULL;\n\n\tctxt->ptr = stream_ctxt;\n\n\treturn ctxt;\n\nerr:\n\tmy_free(ctxt);\n\treturn NULL;\n}\n\nstatic\nds_file_t *\nxbstream_open(ds_ctxt_t *ctxt, const char *path, MY_STAT *mystat)\n{\n\tds_file_t\t\t*file;\n\tds_stream_file_t\t*stream_file;\n\tds_stream_ctxt_t\t*stream_ctxt;\n\tds_ctxt_t\t\t*dest_ctxt;\n\txb_wstream_t\t\t*xbstream;\n\txb_wstream_file_t\t*xbstream_file;\n\n\n\txb_ad(ctxt->pipe_ctxt != NULL);\n\tdest_ctxt = ctxt->pipe_ctxt;\n\n\tstream_ctxt = (ds_stream_ctxt_t *) ctxt->ptr;\n\n\tpthread_mutex_lock(&stream_ctxt->mutex);\n\tif (stream_ctxt->dest_file == NULL) {\n\t\tstream_ctxt->dest_file = ds_open(dest_ctxt, path, mystat);\n\t}\n\tpthread_mutex_unlock(&stream_ctxt->mutex);\n\tif (stream_ctxt->dest_file == NULL) {\n\t\treturn NULL;\n\t}\n\n\tfile = (ds_file_t *) my_malloc(sizeof(ds_file_t) +\n\t\t\t\t       sizeof(ds_stream_file_t),\n\t\t\t\t       MYF(MY_FAE));\n\tif (!file) {\n\t\tmsg(\"my_malloc() failed.\");\n\t\tgoto err;\n\t}\n\tstream_file = (ds_stream_file_t *) (file + 1);\n\n\txbstream = stream_ctxt->xbstream;\n\n\txbstream_file = xb_stream_write_open(xbstream, path, mystat,\n\t\t                             stream_ctxt,\n\t\t\t\t\t     my_xbstream_write_callback);\n\n\tif (xbstream_file == NULL) {\n\t\tmsg(\"xb_stream_write_open() failed.\");\n\t\tgoto err;\n\t}\n\n\tstream_file->xbstream_file = xbstream_file;\n\tstream_file->stream_ctxt = stream_ctxt;\n\tfile->ptr = stream_file;\n\tfile->path = stream_ctxt->dest_file->path;\n\n\treturn file;\n\nerr:\n\tif (stream_ctxt->dest_file) {\n\t\tds_close(stream_ctxt->dest_file);\n\t\tstream_ctxt->dest_file = NULL;\n\t}\n\tmy_free(file);\n\n\treturn NULL;\n}\n\nstatic\nint\nxbstream_write(ds_file_t *file, const uchar *buf, size_t len)\n{\n\tds_stream_file_t\t*stream_file;\n\txb_wstream_file_t\t*xbstream_file;\n\n\n\tstream_file = (ds_stream_file_t *) file->ptr;\n\n\txbstream_file = stream_file->xbstream_file;\n\n\tif (xb_stream_write_data(xbstream_file, buf, len)) {\n\t\tmsg(\"xb_stream_write_data() failed.\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic\nint\nxbstream_close(ds_file_t *file)\n{\n\tds_stream_file_t\t*stream_file;\n\tint\t\t\trc = 0;\n\n\tstream_file = (ds_stream_file_t *)file->ptr;\n\n\trc = xb_stream_write_close(stream_file->xbstream_file);\n\n\tmy_free(file);\n\n\treturn rc;\n}\n\nstatic\nvoid\nxbstream_deinit(ds_ctxt_t *ctxt)\n{\n\tds_stream_ctxt_t\t*stream_ctxt;\n\n\tstream_ctxt = (ds_stream_ctxt_t *) ctxt->ptr;\n\n\tif (xb_stream_write_done(stream_ctxt->xbstream)) {\n\t\tmsg(\"xb_stream_done() failed.\");\n\t}\n\n\tif (stream_ctxt->dest_file) {\n\t\tds_close(stream_ctxt->dest_file);\n\t\tstream_ctxt->dest_file = NULL;\n\t}\n\n\tpthread_mutex_destroy(&stream_ctxt->mutex);\n\n\tmy_free(ctxt);\n}\n"], "filenames": ["extra/mariabackup/ds_xbstream.cc"], "buggy_code_start_loc": [129], "buggy_code_end_loc": [137], "fixing_code_start_loc": [128], "fixing_code_end_loc": [142], "type": "CWE-667", "message": "MariaDB Server before 10.7 is vulnerable to Denial of Service. In extra/mariabackup/ds_xbstream.cc, when an error occurs (stream_ctxt->dest_file == NULL) while executing the method xbstream_open, the held lock is not released correctly, which allows local users to trigger a denial of service due to the deadlock.", "other": {"cve": {"id": "CVE-2022-31621", "sourceIdentifier": "cve@mitre.org", "published": "2022-05-25T21:15:08.573", "lastModified": "2022-11-05T01:55:18.800", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MariaDB Server before 10.7 is vulnerable to Denial of Service. In extra/mariabackup/ds_xbstream.cc, when an error occurs (stream_ctxt->dest_file == NULL) while executing the method xbstream_open, the held lock is not released correctly, which allows local users to trigger a denial of service due to the deadlock."}, {"lang": "es", "value": "MariaDB Server versiones anteriores a 10.7, es vulnerable a una denegaci\u00f3n de servicio. En el archivo xtra/mariabackup/ds_xbstream.cc, cuando es producido un error (stream_ctxt-)dest_file == NULL) mientras es ejecutado el m\u00e9todo xbstream_open, el bloqueo mantenido no es liberado correctamente, lo que permite a usuarios locales desencadenar una denegaci\u00f3n de servicio debido al bloqueo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-667"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mariadb:mariadb:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.2.41", "matchCriteriaId": "0A447A17-E295-4F60-AC74-E04F843E9FE8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mariadb:mariadb:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.3.0", "versionEndExcluding": "10.3.32", "matchCriteriaId": "705DFD55-1C4B-41E3-BD84-EE76F9B497E2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mariadb:mariadb:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.4.0", "versionEndExcluding": "10.4.22", "matchCriteriaId": "A8F611A5-866A-4E49-9689-0A47B05FA738"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mariadb:mariadb:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.5.0", "versionEndExcluding": "10.5.13", "matchCriteriaId": "0A15558C-2B98-4AA5-9775-A1A4374D7BD6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mariadb:mariadb:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.6.0", "versionEndExcluding": "10.6.5", "matchCriteriaId": "73DE2000-2CBA-4811-AD1F-F6EB3B9E4556"}]}]}], "references": [{"url": "https://github.com/MariaDB/server/commit/b1351c15946349f9daa7e5297fb2ac6f3139e4a8", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://jira.mariadb.org/browse/MDEV-26574?filter=-2", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Permissions Required", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220707-0006/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/MariaDB/server/commit/b1351c15946349f9daa7e5297fb2ac6f3139e4a8"}}