{"buggy_code": ["/*\n * Copyright \u00a9 2015 Red Hat, Inc\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n * Authors:\n *       Alexander Larsson <alexl@redhat.com>\n */\n\n#include \"config.h\"\n\n#include <unistd.h>\n#include <string.h>\n\n#include \"flatpak-proxy.h\"\n\n#include <gio/gunixsocketaddress.h>\n#include <gio/gunixconnection.h>\n#include <gio/gunixfdmessage.h>\n\n/**\n * The proxy listens to a unix domain socket, and for each new\n * connection it opens up a new connection to a specified dbus bus\n * address (typically the session bus) and forwards data between the\n * two. During the authentication phase all data is forwarded as\n * received, and additionally for the first 1 byte zero we also send\n * the proxy credentials to the bus.\n *\n * Once the connection is authenticated there are two modes, filtered\n * and unfiltered. In the unfiltered mode we just send all messages on\n * as we receive, but in the in the filtering mode we apply a policy,\n * which is similar to the policy supported by kdbus.\n *\n * The policy for the filtering consists of a mapping from well-known\n * names to a policy that is either SEE, TALK or OWN. The default\n * initial policy is that the the user is only allowed to TALK to the\n * bus itself (org.freedesktop.DBus, or no destination specified), and\n * TALK to its own unique id. All other clients are invisible. The\n * well-known names can be specified exactly, or as a simple one-level\n * wildcard like \"org.foo.*\" which matches \"org.foo.bar\", but not\n * \"org.foobar\" or \"org.foo.bar.gazonk\".\n *\n * Polices are specified for well-known names, but they also affect\n * the owner of that name, so that the policy for a unique id is the\n * superset of the polices for all the names it owns. Due to technical\n * reasons the policy for a unique name is \"sticky\", in that we keep\n * the highest policy granted by a once-owned name even when the client\n * releases that name. This is impossible to avoid in a race-free way\n * in a proxy. But this is rarely a problem in practice, as clients\n * rarely release names and stay on the bus.\n *\n * Here is a description of the policy levels:\n * (all policy levels also imply the ones before it)\n *\n * SEE:\n *    The name/id is visible in the ListNames reply\n *    The name/id is visible in the ListActivatableNames reply\n *    You can call GetNameOwner on the name\n *    You can call NameHasOwner on the name\n *    You see NameOwnerChanged signals on the name\n *    You see NameOwnerChanged signals on the id when the client disconnects\n *    You can call the GetXXX methods on the name/id to get e.g. the peer pid\n *    You get AccessDenied rather than NameHasNoOwner when sending messages to the name/id\n *\n * FILTERED:\n *    You can send *some* method calls to the name (not id)\n *\n * TALK:\n *    You can send any method calls and signals to the name/id\n *    You will receive broadcast signals from the name/id (if you have a match rule for them)\n *    You can call StartServiceByName on the name\n *\n * OWN:\n *    You are allowed to call RequestName/ReleaseName/ListQueuedOwners on the name.\n *\n * The policy applies only to signals and method calls. All replies\n * (errors or method returns) are allowed once for an outstanding\n * method call, and never otherwise.\n *\n * Every peer on the bus is considered priviledged, and we thus trust\n * it. So we rely on similar proxies to be running for all untrusted\n * clients. Any such priviledged peer is allowed to send method call\n * or unicast signal messages to the proxied client. Once another peer\n * sends you a message the unique id of that peer is now made visible\n * (policy SEE) to the proxied client, allowing the client to track\n * caller lifetimes via NameOwnerChanged signals.\n *\n * Differences to kdbus custom endpoint policies:\n *\n *  * The proxy will return the credentials (like pid) of the proxy,\n *    not the real client.\n *\n *  * Policy is not dropped when a peer releases a name.\n *\n *  * Peers that call you become visible (SEE) (and get signals for\n *    NameOwnerChange disconnect) In kdbus currently custom endpoints\n *    never get NameOwnerChange signals for unique ids, but this is\n *    problematic as it disallows a services to track lifetimes of its\n *    clients.\n *\n * Mode of operation\n *\n * Once authenticated we receive incoming messages one at a time,\n * and then we demarshal the message headers to make routing decisions.\n * This means we trust the bus to do message format validation, etc.\n * (because we don't parse the body). Also we assume that the bus verifies\n * reply_serials, i.e. that a reply can only be sent once and by the real\n * recipient of an previously sent method call.\n *\n * We don't however trust the serials from the client. We verify that\n * they are strictly increasing to make sure the code is not confused\n * by serials being reused.\n *\n * In order to track the ownership of the allowed names we hijack the\n * connection after the initial Hello message, sending AddMatch,\n * ListNames and GetNameOwner messages to get a proper view of who\n * owns the names atm. Then we listen to NameOwnerChanged events for\n * further updates. This causes a slight offset between serials in the\n * client and serials as seen by the bus.\n *\n * After that the filter is strictly passive, in that we never\n * construct our own requests. For each message received from the\n * client we look up the type and the destination policy and make a\n * decision to either pass it on as is, rewrite it before passing on\n * (for instance ListName replies), drop it completely, or return a\n * made-up reply/error to the sender.\n *\n * When returning a made-up reply we replace the actual message with a\n * Ping request to the bus with the same serial and replace the resulting\n * reply with the made up reply (with the serial from the Ping reply).\n * This means we keep the strict message ordering and serial numbers of\n * the bus.\n *\n * Policy is applied to unique ids in the following cases:\n *  * During startup we call AddWatch for signals on all policy names\n *    and wildcards (using arg0namespace) so that we get NameOwnerChanged\n *    events which we use to update the unique id policies.\n *  * During startup we create synthetic GetNameOwner requests for all\n *    normal policy names, and if there are wildcarded names we create a\n *    synthetic ListNames request and use the results of that to do further\n *    GetNameOwner for the existing names matching the wildcards. When we get\n *    replies for the GetNameOwner requests the unique id policy is updated.\n *  * When we get a method call from a unique id, it gets SEE\n *  * When we get a reply to the initial Hello request we give\n *    our own assigned unique id policy TALK.\n *\n * All messages sent to the bus itself are fully demarshalled\n * and handled on a per-method basis:\n *\n * Hello, AddMatch, RemoveMatch, GetId: Always allowed\n * ListNames, ListActivatableNames: Always allowed, but response filtered\n * UpdateActivationEnvironment, BecomeMonitor: Always denied\n * RequestName, ReleaseName, ListQueuedOwners: Only allowed if arg0 is a name with policy OWN\n * NameHasOwner, GetNameOwner: Only pass on if arg0 is a name with policy SEE, otherwise return synthetic reply\n * StartServiceByName: Only allowed if policy TALK on arg0\n * GetConnectionUnixProcessID, GetConnectionCredentials,\n *  GetAdtAuditSessionData, GetConnectionSELinuxSecurityContext,\n *  GetConnectionUnixUser: Allowed if policy SEE on arg0\n *\n * For unknown methods, we return a synthetic error.\n */\n\ntypedef struct FlatpakProxyClient FlatpakProxyClient;\n\n/* We start looking ignoring the first cr-lf\n   since there is no previous line initially */\n#define AUTH_END_INIT_OFFSET 2\n#define AUTH_END_STRING \"\\r\\nBEGIN\\r\\n\"\n\ntypedef enum {\n  EXPECTED_REPLY_NONE,\n  EXPECTED_REPLY_NORMAL,\n  EXPECTED_REPLY_HELLO,\n  EXPECTED_REPLY_FILTER,\n  EXPECTED_REPLY_FAKE_GET_NAME_OWNER,\n  EXPECTED_REPLY_FAKE_LIST_NAMES,\n  EXPECTED_REPLY_LIST_NAMES,\n  EXPECTED_REPLY_REWRITE,\n} ExpectedReplyType;\n\ntypedef struct\n{\n  gsize    size;\n  gsize    pos;\n  int      refcount;\n  gboolean send_credentials;\n  GList   *control_messages;\n\n  guchar   data[16];\n  /* data continues here */\n} Buffer;\n\ntypedef struct\n{\n  Buffer     *buffer;\n  gboolean    big_endian;\n  guchar      type;\n  guchar      flags;\n  guint32     length;\n  guint32     serial;\n  const char *path;\n  const char *interface;\n  const char *member;\n  const char *error_name;\n  const char *destination;\n  const char *sender;\n  const char *signature;\n  gboolean    has_reply_serial;\n  guint32     reply_serial;\n  guint32     unix_fds;\n} Header;\n\ntypedef struct\n{\n  char *path;\n  char *interface;\n  char *member;\n} Filter;\n\nstatic void header_free (Header *header);\nG_DEFINE_AUTOPTR_CLEANUP_FUNC (Header, header_free)\n\ntypedef struct\n{\n  gboolean            got_first_byte; /* always true on bus side */\n  gboolean            closed; /* always true on bus side */\n\n  FlatpakProxyClient *client;\n  GSocketConnection  *connection;\n  GSource            *in_source;\n  GSource            *out_source;\n\n  GBytes             *extra_input_data;\n  Buffer             *current_read_buffer;\n  Buffer              header_buffer;\n\n  GList              *buffers; /* to be sent */\n  GList              *control_messages;\n\n  GHashTable         *expected_replies;\n} ProxySide;\n\nstruct FlatpakProxyClient\n{\n  GObject       parent;\n\n  FlatpakProxy *proxy;\n\n  gboolean      authenticated;\n  int           auth_end_offset;\n\n  ProxySide     client_side;\n  ProxySide     bus_side;\n\n  /* Filtering data: */\n  guint32     serial_offset;\n  guint32     hello_serial;\n  guint32     last_serial;\n  GHashTable *rewrite_reply;\n  GHashTable *get_owner_reply;\n\n  GHashTable *unique_id_policy;\n};\n\ntypedef struct\n{\n  GObjectClass parent_class;\n} FlatpakProxyClientClass;\n\nstruct FlatpakProxy\n{\n  GSocketService parent;\n\n  gboolean       log_messages;\n\n  GList         *clients;\n  char          *socket_path;\n  char          *dbus_address;\n\n  gboolean       filter;\n  gboolean       sloppy_names;\n\n  GHashTable    *wildcard_policy;\n  GHashTable    *policy;\n  GHashTable    *filters;\n};\n\ntypedef struct\n{\n  GSocketServiceClass parent_class;\n} FlatpakProxyClass;\n\n\nenum {\n  PROP_0,\n\n  PROP_DBUS_ADDRESS,\n  PROP_SOCKET_PATH\n};\n\n#define FLATPAK_TYPE_PROXY flatpak_proxy_get_type ()\n#define FLATPAK_PROXY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FLATPAK_TYPE_PROXY, FlatpakProxy))\n#define FLATPAK_IS_PROXY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FLATPAK_TYPE_PROXY))\n\n\n#define FLATPAK_TYPE_PROXY_CLIENT flatpak_proxy_client_get_type ()\n#define FLATPAK_PROXY_CLIENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FLATPAK_TYPE_PROXY_CLIENT, FlatpakProxyClient))\n#define FLATPAK_IS_PROXY_CLIENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FLATPAK_TYPE_PROXY_CLIENT))\n\nGType flatpak_proxy_client_get_type (void);\n\nG_DEFINE_TYPE (FlatpakProxy, flatpak_proxy, G_TYPE_SOCKET_SERVICE)\nG_DEFINE_TYPE (FlatpakProxyClient, flatpak_proxy_client, G_TYPE_OBJECT)\n\nstatic void start_reading (ProxySide *side);\nstatic void stop_reading (ProxySide *side);\n\nstatic void\nbuffer_unref (Buffer *buffer)\n{\n  g_assert (buffer->refcount > 0);\n  buffer->refcount--;\n\n  if (buffer->refcount == 0)\n    {\n      g_list_free_full (buffer->control_messages, g_object_unref);\n      g_free (buffer);\n    }\n}\n\nstatic Buffer *\nbuffer_ref (Buffer *buffer)\n{\n  g_assert (buffer->refcount > 0);\n  buffer->refcount++;\n  return buffer;\n}\n\nstatic void\nfree_side (ProxySide *side)\n{\n  g_clear_object (&side->connection);\n  g_clear_pointer (&side->extra_input_data, g_bytes_unref);\n\n  g_list_free_full (side->buffers, (GDestroyNotify) buffer_unref);\n  g_list_free_full (side->control_messages, (GDestroyNotify) g_object_unref);\n\n  if (side->in_source)\n    g_source_destroy (side->in_source);\n  if (side->out_source)\n    g_source_destroy (side->out_source);\n\n  g_hash_table_destroy (side->expected_replies);\n}\n\nstatic void\nflatpak_proxy_client_finalize (GObject *object)\n{\n  FlatpakProxyClient *client = FLATPAK_PROXY_CLIENT (object);\n\n  client->proxy->clients = g_list_remove (client->proxy->clients, client);\n  g_clear_object (&client->proxy);\n\n  g_hash_table_destroy (client->rewrite_reply);\n  g_hash_table_destroy (client->get_owner_reply);\n  g_hash_table_destroy (client->unique_id_policy);\n\n  free_side (&client->client_side);\n  free_side (&client->bus_side);\n\n  G_OBJECT_CLASS (flatpak_proxy_client_parent_class)->finalize (object);\n}\n\nstatic void\nflatpak_proxy_client_class_init (FlatpakProxyClientClass *klass)\n{\n  GObjectClass *object_class = G_OBJECT_CLASS (klass);\n\n  object_class->finalize = flatpak_proxy_client_finalize;\n}\n\nstatic void\ninit_side (FlatpakProxyClient *client, ProxySide *side)\n{\n  side->got_first_byte = (side == &client->bus_side);\n  side->client = client;\n  side->header_buffer.size = 16;\n  side->header_buffer.pos = 0;\n  side->current_read_buffer = &side->header_buffer;\n  side->expected_replies = g_hash_table_new (g_direct_hash, g_direct_equal);\n}\n\nstatic void\nflatpak_proxy_client_init (FlatpakProxyClient *client)\n{\n  init_side (client, &client->client_side);\n  init_side (client, &client->bus_side);\n\n  client->auth_end_offset = AUTH_END_INIT_OFFSET;\n  client->rewrite_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);\n  client->get_owner_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);\n  client->unique_id_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n}\n\nstatic FlatpakProxyClient *\nflatpak_proxy_client_new (FlatpakProxy *proxy, GSocketConnection *connection)\n{\n  FlatpakProxyClient *client;\n\n  g_socket_set_blocking (g_socket_connection_get_socket (connection), FALSE);\n\n  client = g_object_new (FLATPAK_TYPE_PROXY_CLIENT, NULL);\n  client->proxy = g_object_ref (proxy);\n  client->client_side.connection = g_object_ref (connection);\n\n  proxy->clients = g_list_prepend (proxy->clients, client);\n\n  return client;\n}\n\nstatic FlatpakPolicy\nflatpak_proxy_get_wildcard_policy (FlatpakProxy *proxy,\n                                   const char   *_name)\n{\n  guint policy, wildcard_policy = 0;\n  char *dot;\n  g_autofree char *name = g_strdup (_name);\n\n  dot = name + strlen (name);\n  while (dot)\n    {\n      *dot = 0;\n      policy = GPOINTER_TO_INT (g_hash_table_lookup (proxy->wildcard_policy, name));\n      wildcard_policy = MAX (wildcard_policy, policy);\n      dot = strrchr (name, '.');\n    }\n\n  return wildcard_policy;\n}\n\nstatic FlatpakPolicy\nflatpak_proxy_get_policy (FlatpakProxy *proxy,\n                          const char   *name)\n{\n  guint policy, wildcard_policy;\n\n  policy = GPOINTER_TO_INT (g_hash_table_lookup (proxy->policy, name));\n\n  wildcard_policy = flatpak_proxy_get_wildcard_policy (proxy, name);\n\n  return MAX (policy, wildcard_policy);\n}\n\nvoid\nflatpak_proxy_set_filter (FlatpakProxy *proxy,\n                          gboolean      filter)\n{\n  proxy->filter = filter;\n}\n\nvoid\nflatpak_proxy_set_sloppy_names (FlatpakProxy *proxy,\n                                gboolean      sloppy_names)\n{\n  proxy->sloppy_names = sloppy_names;\n}\n\nvoid\nflatpak_proxy_set_log_messages (FlatpakProxy *proxy,\n                                gboolean      log)\n{\n  proxy->log_messages = log;\n}\n\nvoid\nflatpak_proxy_add_policy (FlatpakProxy *proxy,\n                          const char   *name,\n                          FlatpakPolicy policy)\n{\n  guint current_policy = GPOINTER_TO_INT (g_hash_table_lookup (proxy->policy, name));\n\n  current_policy = MAX (policy, current_policy);\n\n  g_hash_table_replace (proxy->policy, g_strdup (name), GINT_TO_POINTER (current_policy));\n}\n\nvoid\nflatpak_proxy_add_wildcarded_policy (FlatpakProxy *proxy,\n                                     const char   *name,\n                                     FlatpakPolicy policy)\n{\n  g_hash_table_replace (proxy->wildcard_policy, g_strdup (name), GINT_TO_POINTER (policy));\n}\n\nstatic void\nfilter_free (Filter *filter)\n{\n  g_free (filter->path);\n  g_free (filter->interface);\n  g_free (filter->member);\n  g_free (filter);\n}\n\nstatic void\nfilter_list_free (GList *filters)\n{\n  g_list_free_full (filters, (GDestroyNotify)filter_free);\n}\n\n/* rules are of the form [org.the.interface.[method|*]][@/obj/path] */\nstatic Filter *\nfilter_new (const char *rule)\n{\n  Filter *filter = g_new0 (Filter, 1);\n  const char *obj_path_start = NULL;\n  const char *method_end = NULL;\n\n  obj_path_start = strchr (rule, '@');\n  if (obj_path_start && obj_path_start[1] != 0)\n    filter->path = g_strdup (obj_path_start + 1);\n\n  if (obj_path_start != NULL)\n    method_end = obj_path_start;\n  else\n    method_end = rule + strlen(rule);\n\n  if (rule[0] != '@')\n    {\n      filter->interface = g_strndup (rule, method_end - rule);\n      char *dot = strrchr (filter->interface, '.');\n      if (dot != NULL)\n        {\n          *dot = 0;\n          if (strcmp (dot+1, \"*\") != 0)\n            filter->member = g_strdup (dot + 1);\n         }\n    }\n\n  return filter;\n}\n\n\nvoid\nflatpak_proxy_add_filter (FlatpakProxy *proxy,\n                          const char   *name,\n                          const char   *rule)\n{\n  Filter *filter;\n  GList *filters, *new_filters;\n\n  filter = filter_new (rule);\n  if (g_hash_table_lookup_extended (proxy->filters,\n                                    name,\n                                    NULL, (void **)&filters))\n    {\n      new_filters = g_list_append (filters, filter);\n      g_assert (new_filters == filters);\n    }\n  else\n    {\n      filters = g_list_append (NULL, filter);\n      g_hash_table_insert (proxy->filters, g_strdup (name), filters);\n    }\n}\n\nstatic void\nflatpak_proxy_finalize (GObject *object)\n{\n  FlatpakProxy *proxy = FLATPAK_PROXY (object);\n\n  if (g_socket_service_is_active (G_SOCKET_SERVICE (proxy)))\n    unlink (proxy->socket_path);\n\n  g_assert (proxy->clients == NULL);\n\n  g_hash_table_destroy (proxy->policy);\n  g_hash_table_destroy (proxy->wildcard_policy);\n  g_hash_table_destroy (proxy->filters);\n\n  g_free (proxy->socket_path);\n  g_free (proxy->dbus_address);\n\n  G_OBJECT_CLASS (flatpak_proxy_parent_class)->finalize (object);\n}\n\nstatic void\nflatpak_proxy_set_property (GObject      *object,\n                            guint         prop_id,\n                            const GValue *value,\n                            GParamSpec   *pspec)\n{\n  FlatpakProxy *proxy = FLATPAK_PROXY (object);\n\n  switch (prop_id)\n    {\n    case PROP_DBUS_ADDRESS:\n      proxy->dbus_address = g_value_dup_string (value);\n      break;\n\n    case PROP_SOCKET_PATH:\n      proxy->socket_path = g_value_dup_string (value);\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}\n\nstatic void\nflatpak_proxy_get_property (GObject    *object,\n                            guint       prop_id,\n                            GValue     *value,\n                            GParamSpec *pspec)\n{\n  FlatpakProxy *proxy = FLATPAK_PROXY (object);\n\n  switch (prop_id)\n    {\n    case PROP_DBUS_ADDRESS:\n      g_value_set_string (value, proxy->dbus_address);\n      break;\n\n    case PROP_SOCKET_PATH:\n      g_value_set_string (value, proxy->socket_path);\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}\n\nstatic Buffer *\nbuffer_new (gsize size, Buffer *old)\n{\n  Buffer *buffer = g_malloc0 (sizeof (Buffer) + size - 16);\n\n  buffer->control_messages = NULL;\n  buffer->size = size;\n  buffer->refcount = 1;\n\n  if (old)\n    {\n      buffer->pos = old->pos;\n      /* Takes ownership of any old control messages */\n      buffer->control_messages = old->control_messages;\n      old->control_messages = NULL;\n\n      g_assert (size >= old->size);\n      memcpy (buffer->data, old->data, old->size);\n    }\n\n  return buffer;\n}\n\nstatic ProxySide *\nget_other_side (ProxySide *side)\n{\n  FlatpakProxyClient *client = side->client;\n\n  if (side == &client->client_side)\n    return &client->bus_side;\n\n  return &client->client_side;\n}\n\nstatic void\nside_closed (ProxySide *side)\n{\n  GSocket *socket, *other_socket;\n  ProxySide *other_side = get_other_side (side);\n\n  if (side->closed)\n    return;\n\n  socket = g_socket_connection_get_socket (side->connection);\n  g_socket_close (socket, NULL);\n  side->closed = TRUE;\n\n  other_socket = g_socket_connection_get_socket (other_side->connection);\n  if (!other_side->closed && other_side->buffers == NULL)\n    {\n      g_socket_close (other_socket, NULL);\n      other_side->closed = TRUE;\n    }\n\n  if (other_side->closed)\n    {\n      g_object_unref (side->client);\n    }\n  else\n    {\n      GError *error = NULL;\n\n      if (!g_socket_shutdown (other_socket, TRUE, FALSE, &error))\n        {\n          g_warning (\"Unable to shutdown read side: %s\", error->message);\n          g_error_free (error);\n        }\n    }\n}\n\nstatic gboolean\nbuffer_read (ProxySide *side,\n             Buffer    *buffer,\n             GSocket   *socket)\n{\n  gssize res;\n  GInputVector v;\n  GError *error = NULL;\n  GSocketControlMessage **messages;\n  int num_messages, i;\n\n  if (side->extra_input_data)\n    {\n      gsize extra_size;\n      const guchar *extra_bytes = g_bytes_get_data (side->extra_input_data, &extra_size);\n\n      res = MIN (extra_size, buffer->size - buffer->pos);\n      memcpy (&buffer->data[buffer->pos], extra_bytes, res);\n\n      if (res < extra_size)\n        {\n          side->extra_input_data =\n            g_bytes_new_with_free_func (extra_bytes + res,\n                                        extra_size - res,\n                                        (GDestroyNotify) g_bytes_unref,\n                                        side->extra_input_data);\n        }\n      else\n        {\n          g_clear_pointer (&side->extra_input_data, g_bytes_unref);\n        }\n    }\n  else\n    {\n      int flags = 0;\n      v.buffer = &buffer->data[buffer->pos];\n      v.size = buffer->size - buffer->pos;\n\n      res = g_socket_receive_message (socket, NULL, &v, 1,\n                                      &messages,\n                                      &num_messages,\n                                      &flags, NULL, &error);\n      if (res < 0 && g_error_matches (error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK))\n        {\n          g_error_free (error);\n          return FALSE;\n        }\n\n      if (res <= 0)\n        {\n          if (res != 0)\n            {\n              g_debug (\"Error reading from socket: %s\", error->message);\n              g_error_free (error);\n            }\n\n          side_closed (side);\n          return FALSE;\n        }\n\n      for (i = 0; i < num_messages; i++)\n        buffer->control_messages = g_list_append (buffer->control_messages, messages[i]);\n\n      g_free (messages);\n    }\n\n  buffer->pos += res;\n  return TRUE;\n}\n\nstatic gboolean\nbuffer_write (ProxySide *side,\n              Buffer    *buffer,\n              GSocket   *socket)\n{\n  gssize res;\n  GOutputVector v;\n  GError *error = NULL;\n  GSocketControlMessage **messages = NULL;\n  int i, n_messages;\n  GList *l;\n\n  if (buffer->send_credentials &&\n      G_IS_UNIX_CONNECTION (side->connection))\n    {\n      g_assert (buffer->size == 1);\n\n      if (!g_unix_connection_send_credentials (G_UNIX_CONNECTION (side->connection),\n                                               NULL,\n                                               &error))\n        {\n          if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK))\n            {\n              g_error_free (error);\n              return FALSE;\n            }\n\n          g_warning (\"Error writing credentials to socket: %s\", error->message);\n          g_error_free (error);\n\n          side_closed (side);\n          return FALSE;\n        }\n\n      buffer->pos = 1;\n      return TRUE;\n    }\n\n  n_messages = g_list_length (buffer->control_messages);\n  messages = g_new (GSocketControlMessage *, n_messages);\n  for (l = buffer->control_messages, i = 0; l != NULL; l = l->next, i++)\n    messages[i] = l->data;\n\n  v.buffer = &buffer->data[buffer->pos];\n  v.size = buffer->size - buffer->pos;\n\n  res = g_socket_send_message (socket, NULL, &v, 1,\n                               messages, n_messages,\n                               G_SOCKET_MSG_NONE, NULL, &error);\n  g_free (messages);\n  if (res < 0 && g_error_matches (error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK))\n    {\n      g_error_free (error);\n      return FALSE;\n    }\n\n  if (res <= 0)\n    {\n      if (res < 0)\n        {\n          g_warning (\"Error writing credentials to socket: %s\", error->message);\n          g_error_free (error);\n        }\n\n      side_closed (side);\n      return FALSE;\n    }\n\n  g_list_free_full (buffer->control_messages, g_object_unref);\n  buffer->control_messages = NULL;\n\n  buffer->pos += res;\n  return TRUE;\n}\n\nstatic gboolean\nside_out_cb (GSocket *socket, GIOCondition condition, gpointer user_data)\n{\n  ProxySide *side = user_data;\n  FlatpakProxyClient *client = side->client;\n  gboolean retval = G_SOURCE_CONTINUE;\n\n  g_object_ref (client);\n\n  while (side->buffers)\n    {\n      Buffer *buffer = side->buffers->data;\n\n      if (buffer_write (side, buffer, socket))\n        {\n          if (buffer->pos == buffer->size)\n            {\n              side->buffers = g_list_delete_link (side->buffers, side->buffers);\n              buffer_unref (buffer);\n            }\n        }\n      else\n        {\n          break;\n        }\n    }\n\n  if (side->buffers == NULL)\n    {\n      ProxySide *other_side = get_other_side (side);\n\n      side->out_source = NULL;\n      retval = G_SOURCE_REMOVE;\n\n      if (other_side->closed)\n        side_closed (side);\n    }\n\n  g_object_unref (client);\n\n  return retval;\n}\n\nstatic void\nqueue_expected_reply (ProxySide *side, guint32 serial, ExpectedReplyType type)\n{\n  g_hash_table_replace (side->expected_replies,\n                        GUINT_TO_POINTER (serial),\n                        GUINT_TO_POINTER (type));\n}\n\nstatic ExpectedReplyType\nsteal_expected_reply (ProxySide *side, guint32 serial)\n{\n  ExpectedReplyType type;\n\n  type = GPOINTER_TO_UINT (g_hash_table_lookup (side->expected_replies,\n                                                GUINT_TO_POINTER (serial)));\n  if (type)\n    g_hash_table_remove (side->expected_replies,\n                         GUINT_TO_POINTER (serial));\n  return type;\n}\n\n\nstatic void\nqueue_outgoing_buffer (ProxySide *side, Buffer *buffer)\n{\n  if (side->out_source == NULL)\n    {\n      GSocket *socket;\n\n      socket = g_socket_connection_get_socket (side->connection);\n      side->out_source = g_socket_create_source (socket, G_IO_OUT, NULL);\n      g_source_set_callback (side->out_source, (GSourceFunc) side_out_cb, side, NULL);\n      g_source_attach (side->out_source, NULL);\n      g_source_unref (side->out_source);\n    }\n\n  buffer->pos = 0;\n  side->buffers = g_list_append (side->buffers, buffer);\n}\n\nstatic guint32\nread_uint32 (Header *header, guint8 *ptr)\n{\n  if (header->big_endian)\n    return GUINT32_FROM_BE (*(guint32 *) ptr);\n  else\n    return GUINT32_FROM_LE (*(guint32 *) ptr);\n}\n\nstatic void\nwrite_uint32 (Header *header, guint8 *ptr, guint32 val)\n{\n  if (header->big_endian)\n    *(guint32 *) ptr = GUINT32_TO_BE (val);\n  else\n    *(guint32 *) ptr = GUINT32_TO_LE (val);\n}\n\nstatic inline guint32\nalign_by_8 (guint32 offset)\n{\n  return (offset + 8 - 1) & ~(8 - 1);\n}\n\nstatic inline guint32\nalign_by_4 (guint32 offset)\n{\n  return (offset + 4 - 1) & ~(4 - 1);\n}\n\nstatic const char *\nget_signature (Buffer *buffer, guint32 *offset, guint32 end_offset)\n{\n  guint8 len;\n  char *str;\n\n  if (*offset >= end_offset)\n    return FALSE;\n\n  len = buffer->data[*offset];\n  (*offset)++;\n\n  if ((*offset) + len + 1 > end_offset)\n    return FALSE;\n\n  if (buffer->data[(*offset) + len] != 0)\n    return FALSE;\n\n  str = (char *) &buffer->data[(*offset)];\n  *offset += len + 1;\n\n  return str;\n}\n\nstatic const char *\nget_string (Buffer *buffer, Header *header, guint32 *offset, guint32 end_offset)\n{\n  guint8 len;\n  char *str;\n\n  *offset = align_by_4 (*offset);\n  if (*offset + 4  >= end_offset)\n    return FALSE;\n\n  len = read_uint32 (header, &buffer->data[*offset]);\n  *offset += 4;\n\n  if ((*offset) + len + 1 > end_offset)\n    return FALSE;\n\n  if (buffer->data[(*offset) + len] != 0)\n    return FALSE;\n\n  str = (char *) &buffer->data[(*offset)];\n  *offset += len + 1;\n\n  return str;\n}\n\nstatic void\nheader_free (Header *header)\n{\n  if (header->buffer)\n    buffer_unref (header->buffer);\n  g_free (header);\n}\n\nstatic Header *\nparse_header (Buffer *buffer, guint32 serial_offset, guint32 reply_serial_offset, guint32 hello_serial)\n{\n  guint32 array_len, header_len;\n  guint32 offset, end_offset;\n  guint8 header_type;\n  guint32 reply_serial_pos = 0;\n  const char *signature;\n  g_autoptr(Header) header = g_new0 (Header, 1);\n\n  header->buffer = buffer_ref (buffer);\n\n  if (buffer->size < 16)\n    return NULL;\n\n  if (buffer->data[3] != 1) /* Protocol version */\n    return NULL;\n\n  if (buffer->data[0] == 'B')\n    header->big_endian = TRUE;\n  else if (buffer->data[0] == 'l')\n    header->big_endian = FALSE;\n  else\n    return NULL;\n\n  header->type = buffer->data[1];\n  header->flags = buffer->data[2];\n\n  header->length = read_uint32 (header, &buffer->data[4]);\n  header->serial = read_uint32 (header, &buffer->data[8]);\n\n  if (header->serial == 0)\n    return NULL;\n\n  array_len = read_uint32 (header, &buffer->data[12]);\n\n  header_len = align_by_8 (12 + 4 + array_len);\n  g_assert (buffer->size >= header_len); /* We should have verified this when reading in the message */\n  if (header_len > buffer->size)\n    return NULL;\n\n  offset = 12 + 4;\n  end_offset = offset + array_len;\n\n  while (offset < end_offset)\n    {\n      offset = align_by_8 (offset); /* Structs must be 8 byte aligned */\n      if (offset >= end_offset)\n        return NULL;\n\n      header_type = buffer->data[offset++];\n      if (offset >= end_offset)\n        return NULL;\n\n      signature = get_signature (buffer, &offset, end_offset);\n      if (signature == NULL)\n        return NULL;\n\n      switch (header_type)\n        {\n        case G_DBUS_MESSAGE_HEADER_FIELD_INVALID:\n          return NULL;\n\n        case G_DBUS_MESSAGE_HEADER_FIELD_PATH:\n          if (strcmp (signature, \"o\") != 0)\n            return NULL;\n          header->path = get_string (buffer, header, &offset, end_offset);\n          if (header->path == NULL)\n            return NULL;\n          break;\n\n        case G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE:\n          if (strcmp (signature, \"s\") != 0)\n            return NULL;\n          header->interface = get_string (buffer, header, &offset, end_offset);\n          if (header->interface == NULL)\n            return NULL;\n          break;\n\n        case G_DBUS_MESSAGE_HEADER_FIELD_MEMBER:\n          if (strcmp (signature, \"s\") != 0)\n            return NULL;\n          header->member = get_string (buffer, header, &offset, end_offset);\n          if (header->member == NULL)\n            return NULL;\n          break;\n\n        case G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME:\n          if (strcmp (signature, \"s\") != 0)\n            return NULL;\n          header->error_name = get_string (buffer, header, &offset, end_offset);\n          if (header->error_name == NULL)\n            return NULL;\n          break;\n\n        case G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL:\n          if (offset + 4 > end_offset)\n            return NULL;\n\n          header->has_reply_serial = TRUE;\n          reply_serial_pos = offset;\n          header->reply_serial = read_uint32 (header, &buffer->data[offset]);\n          offset += 4;\n          break;\n\n        case G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION:\n          if (strcmp (signature, \"s\") != 0)\n            return NULL;\n          header->destination = get_string (buffer, header, &offset, end_offset);\n          if (header->destination == NULL)\n            return NULL;\n          break;\n\n        case G_DBUS_MESSAGE_HEADER_FIELD_SENDER:\n          if (strcmp (signature, \"s\") != 0)\n            return NULL;\n          header->sender = get_string (buffer, header, &offset, end_offset);\n          if (header->sender == NULL)\n            return NULL;\n          break;\n\n        case G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE:\n          if (strcmp (signature, \"g\") != 0)\n            return NULL;\n          header->signature = get_signature (buffer, &offset, end_offset);\n          if (header->signature == NULL)\n            return NULL;\n          break;\n\n        case G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS:\n          if (offset + 4 > end_offset)\n            return NULL;\n\n          header->unix_fds = read_uint32 (header, &buffer->data[offset]);\n          offset += 4;\n          break;\n\n        default:\n          /* Unknown header field, for safety, fail parse */\n          return NULL;\n        }\n    }\n\n  switch (header->type)\n    {\n    case G_DBUS_MESSAGE_TYPE_METHOD_CALL:\n      if (header->path == NULL || header->member == NULL)\n        return NULL;\n      break;\n\n    case G_DBUS_MESSAGE_TYPE_METHOD_RETURN:\n      if (!header->has_reply_serial)\n        return NULL;\n      break;\n\n    case G_DBUS_MESSAGE_TYPE_ERROR:\n      if (header->error_name  == NULL || !header->has_reply_serial)\n        return NULL;\n      break;\n\n    case G_DBUS_MESSAGE_TYPE_SIGNAL:\n      if (header->path == NULL ||\n          header->interface == NULL ||\n          header->member == NULL)\n        return NULL;\n      if (strcmp (header->path, \"/org/freedesktop/DBus/Local\") == 0 ||\n          strcmp (header->interface, \"org.freedesktop.DBus.Local\") == 0)\n        return NULL;\n      break;\n\n    default:\n      /* Unknown message type, for safety, fail parse */\n      return NULL;\n    }\n\n  if (serial_offset > 0)\n    {\n      header->serial += serial_offset;\n      write_uint32 (header, &buffer->data[8], header->serial);\n    }\n\n  if (reply_serial_offset > 0 &&\n      header->has_reply_serial &&\n      header->reply_serial > hello_serial + reply_serial_offset)\n    write_uint32 (header, &buffer->data[reply_serial_pos], header->reply_serial - reply_serial_offset);\n\n  return g_steal_pointer (&header);\n}\n\nstatic void\nprint_outgoing_header (Header *header)\n{\n  switch (header->type)\n    {\n    case G_DBUS_MESSAGE_TYPE_METHOD_CALL:\n      g_print (\"C%d: -> %s call %s.%s at %s\\n\",\n               header->serial,\n               header->destination ? header->destination : \"(no dest)\",\n               header->interface ? header->interface : \"\",\n               header->member ? header->member : \"\",\n               header->path ? header->path : \"\");\n      break;\n\n    case G_DBUS_MESSAGE_TYPE_METHOD_RETURN:\n      g_print (\"C%d: -> %s return from B%d\\n\",\n               header->serial,\n               header->destination ? header->destination : \"(no dest)\",\n               header->reply_serial);\n      break;\n\n    case G_DBUS_MESSAGE_TYPE_ERROR:\n      g_print (\"C%d: -> %s return error %s from B%d\\n\",\n               header->serial,\n               header->destination ? header->destination : \"(no dest)\",\n               header->error_name ? header->error_name : \"(no error)\",\n               header->reply_serial);\n      break;\n\n    case G_DBUS_MESSAGE_TYPE_SIGNAL:\n      g_print (\"C%d: -> %s signal %s.%s at %s\\n\",\n               header->serial,\n               header->destination ? header->destination : \"all\",\n               header->interface ? header->interface : \"\",\n               header->member ? header->member : \"\",\n               header->path ? header->path : \"\");\n      break;\n\n    default:\n      g_print (\"unknown message type\\n\");\n    }\n}\n\nstatic void\nprint_incoming_header (Header *header)\n{\n  switch (header->type)\n    {\n    case G_DBUS_MESSAGE_TYPE_METHOD_CALL:\n      g_print (\"B%d: <- %s call %s.%s at %s\\n\",\n               header->serial,\n               header->sender ? header->sender : \"(no sender)\",\n               header->interface ? header->interface : \"\",\n               header->member ? header->member : \"\",\n               header->path ? header->path : \"\");\n      break;\n\n    case G_DBUS_MESSAGE_TYPE_METHOD_RETURN:\n      g_print (\"B%d: <- %s return from C%d\\n\",\n               header->serial,\n               header->sender ? header->sender : \"(no sender)\",\n               header->reply_serial);\n      break;\n\n    case G_DBUS_MESSAGE_TYPE_ERROR:\n      g_print (\"B%d: <- %s return error %s from C%d\\n\",\n               header->serial,\n               header->sender ? header->sender : \"(no sender)\",\n               header->error_name ? header->error_name : \"(no error)\",\n               header->reply_serial);\n      break;\n\n    case G_DBUS_MESSAGE_TYPE_SIGNAL:\n      g_print (\"B%d: <- %s signal %s.%s at %s\\n\",\n               header->serial,\n               header->sender ? header->sender : \"(no sender)\",\n               header->interface ? header->interface : \"\",\n               header->member ? header->member : \"\",\n               header->path ? header->path : \"\");\n      break;\n\n    default:\n      g_print (\"unknown message type\\n\");\n    }\n}\n\nstatic FlatpakPolicy\nflatpak_proxy_client_get_policy (FlatpakProxyClient *client, const char *source)\n{\n  if (source == NULL)\n    return FLATPAK_POLICY_TALK; /* All clients can talk to the bus itself */\n\n  if (source[0] == ':')\n    return GPOINTER_TO_UINT (g_hash_table_lookup (client->unique_id_policy, source));\n\n  return flatpak_proxy_get_policy (client->proxy, source);\n}\n\nstatic void\nflatpak_proxy_client_update_unique_id_policy (FlatpakProxyClient *client,\n                                              const char         *unique_id,\n                                              FlatpakPolicy       policy)\n{\n  if (policy > FLATPAK_POLICY_NONE)\n    {\n      FlatpakPolicy old_policy;\n      old_policy = GPOINTER_TO_UINT (g_hash_table_lookup (client->unique_id_policy, unique_id));\n      if (policy > old_policy)\n        g_hash_table_replace (client->unique_id_policy, g_strdup (unique_id), GINT_TO_POINTER (policy));\n    }\n}\n\nstatic void\nflatpak_proxy_client_update_unique_id_policy_from_name (FlatpakProxyClient *client,\n                                                        const char         *unique_id,\n                                                        const char         *as_name)\n{\n  flatpak_proxy_client_update_unique_id_policy (client,\n                                                unique_id,\n                                                flatpak_proxy_get_policy (client->proxy, as_name));\n}\n\n\nstatic gboolean\nclient_message_generates_reply (Header *header)\n{\n  switch (header->type)\n    {\n    case G_DBUS_MESSAGE_TYPE_METHOD_CALL:\n      return (header->flags & G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED) == 0;\n\n    case G_DBUS_MESSAGE_TYPE_SIGNAL:\n    case G_DBUS_MESSAGE_TYPE_METHOD_RETURN:\n    case G_DBUS_MESSAGE_TYPE_ERROR:\n    default:\n      return FALSE;\n    }\n}\n\nstatic Buffer *\nmessage_to_buffer (GDBusMessage *message)\n{\n  Buffer *buffer;\n  guchar *blob;\n  gsize blob_size;\n\n  blob = g_dbus_message_to_blob (message, &blob_size, G_DBUS_CAPABILITY_FLAGS_NONE, NULL);\n  buffer = buffer_new (blob_size, NULL);\n  memcpy (buffer->data, blob, blob_size);\n  g_free (blob);\n\n  return buffer;\n}\n\nstatic GDBusMessage *\nget_error_for_header (FlatpakProxyClient *client, Header *header, const char *error)\n{\n  GDBusMessage *reply;\n\n  reply = g_dbus_message_new ();\n  g_dbus_message_set_message_type (reply, G_DBUS_MESSAGE_TYPE_ERROR);\n  g_dbus_message_set_flags (reply, G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED);\n  g_dbus_message_set_reply_serial (reply, header->serial - client->serial_offset);\n  g_dbus_message_set_error_name (reply, error);\n  g_dbus_message_set_body (reply, g_variant_new (\"(s)\", error));\n\n  return reply;\n}\n\nstatic GDBusMessage *\nget_bool_reply_for_header (FlatpakProxyClient *client, Header *header, gboolean val)\n{\n  GDBusMessage *reply;\n\n  reply = g_dbus_message_new ();\n  g_dbus_message_set_message_type (reply, G_DBUS_MESSAGE_TYPE_METHOD_RETURN);\n  g_dbus_message_set_flags (reply, G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED);\n  g_dbus_message_set_reply_serial (reply, header->serial - client->serial_offset);\n  g_dbus_message_set_body (reply, g_variant_new (\"(b)\", val));\n\n  return reply;\n}\n\nstatic Buffer *\nget_ping_buffer_for_header (Header *header)\n{\n  Buffer *buffer;\n  GDBusMessage *dummy;\n\n  dummy = g_dbus_message_new_method_call (NULL, \"/\", \"org.freedesktop.DBus.Peer\", \"Ping\");\n  g_dbus_message_set_serial (dummy, header->serial);\n  g_dbus_message_set_flags (dummy, header->flags);\n\n  buffer = message_to_buffer (dummy);\n\n  g_object_unref (dummy);\n\n  return buffer;\n}\n\nstatic Buffer *\nget_error_for_roundtrip (FlatpakProxyClient *client, Header *header, const char *error_name)\n{\n  Buffer *ping_buffer = get_ping_buffer_for_header (header);\n  GDBusMessage *reply;\n\n  reply = get_error_for_header (client, header, error_name);\n  g_hash_table_replace (client->rewrite_reply, GINT_TO_POINTER (header->serial), reply);\n  return ping_buffer;\n}\n\nstatic Buffer *\nget_bool_reply_for_roundtrip (FlatpakProxyClient *client, Header *header, gboolean val)\n{\n  Buffer *ping_buffer = get_ping_buffer_for_header (header);\n  GDBusMessage *reply;\n\n  reply = get_bool_reply_for_header (client, header, val);\n  g_hash_table_replace (client->rewrite_reply, GINT_TO_POINTER (header->serial), reply);\n\n  return ping_buffer;\n}\n\ntypedef enum {\n  HANDLE_PASS,\n  HANDLE_DENY,\n  HANDLE_HIDE,\n  HANDLE_FILTER_NAME_LIST_REPLY,\n  HANDLE_FILTER_HAS_OWNER_REPLY,\n  HANDLE_FILTER_GET_OWNER_REPLY,\n  HANDLE_VALIDATE_OWN,\n  HANDLE_VALIDATE_SEE,\n  HANDLE_VALIDATE_TALK,\n  HANDLE_VALIDATE_MATCH,\n} BusHandler;\n\nstatic gboolean\nis_for_bus (Header *header)\n{\n  return g_strcmp0 (header->destination, \"org.freedesktop.DBus\") == 0;\n}\n\nstatic gboolean\nis_dbus_method_call (Header *header)\n{\n  return\n    is_for_bus (header) &&\n    header->type == G_DBUS_MESSAGE_TYPE_METHOD_CALL &&\n    g_strcmp0 (header->interface, \"org.freedesktop.DBus\") == 0;\n}\n\nstatic gboolean\nis_introspection_call (Header *header)\n{\n  return\n    header->type == G_DBUS_MESSAGE_TYPE_METHOD_CALL &&\n    g_strcmp0 (header->interface, \"org.freedesktop.DBus.Introspectable\") == 0;\n}\n\nstatic BusHandler\nget_dbus_method_handler (FlatpakProxyClient *client, Header *header)\n{\n  FlatpakPolicy policy;\n  const char *method;\n\n  if (header->has_reply_serial)\n    {\n      ExpectedReplyType expected_reply =\n        steal_expected_reply (&client->bus_side,\n                              header->reply_serial);\n      if (expected_reply == EXPECTED_REPLY_NONE)\n        return HANDLE_DENY;\n\n      return HANDLE_PASS;\n    }\n\n  policy = flatpak_proxy_client_get_policy (client, header->destination);\n  if (policy < FLATPAK_POLICY_SEE)\n    return HANDLE_HIDE;\n  if (policy < FLATPAK_POLICY_FILTERED)\n    return HANDLE_DENY;\n\n  if (policy == FLATPAK_POLICY_FILTERED)\n    {\n      GList *filters = NULL, *l;\n\n      if (header->destination)\n        filters = g_hash_table_lookup (client->proxy->filters, header->destination);\n      for (l = filters; l != NULL; l = l->next)\n        {\n          Filter *filter = l->data;\n\n          if (header->type == G_DBUS_MESSAGE_TYPE_METHOD_CALL &&\n              (filter->path == NULL || g_strcmp0 (filter->path, header->path) == 0) &&\n              (filter->interface == NULL || g_strcmp0 (filter->interface, header->interface) == 0) &&\n              (filter->member == NULL || g_strcmp0 (filter->member, header->member) == 0))\n            return HANDLE_PASS;\n        }\n\n      return HANDLE_DENY;\n    }\n\n  if (!is_for_bus (header))\n    return HANDLE_PASS;\n\n  if (is_introspection_call (header))\n    {\n      return HANDLE_PASS;\n    }\n  else if (is_dbus_method_call (header))\n    {\n      method = header->member;\n      if (method == NULL)\n        return HANDLE_DENY;\n\n      if (strcmp (method, \"AddMatch\") == 0)\n        return HANDLE_VALIDATE_MATCH;\n\n      if (strcmp (method, \"Hello\") == 0 ||\n          strcmp (method, \"RemoveMatch\") == 0 ||\n          strcmp (method, \"GetId\") == 0)\n        return HANDLE_PASS;\n\n      if (strcmp (method, \"UpdateActivationEnvironment\") == 0 ||\n          strcmp (method, \"BecomeMonitor\") == 0)\n        return HANDLE_DENY;\n\n      if (strcmp (method, \"RequestName\") == 0 ||\n          strcmp (method, \"ReleaseName\") == 0 ||\n          strcmp (method, \"ListQueuedOwners\") == 0)\n        return HANDLE_VALIDATE_OWN;\n\n      if (strcmp (method, \"NameHasOwner\") == 0)\n        return HANDLE_FILTER_HAS_OWNER_REPLY;\n\n      if (strcmp (method, \"GetNameOwner\") == 0)\n        return HANDLE_FILTER_GET_OWNER_REPLY;\n\n      if (strcmp (method, \"GetConnectionUnixProcessID\") == 0 ||\n          strcmp (method, \"GetConnectionCredentials\") == 0 ||\n          strcmp (method, \"GetAdtAuditSessionData\") == 0 ||\n          strcmp (method, \"GetConnectionSELinuxSecurityContext\") == 0 ||\n          strcmp (method, \"GetConnectionUnixUser\") == 0)\n        return HANDLE_VALIDATE_SEE;\n\n      if (strcmp (method, \"StartServiceByName\") == 0)\n        return HANDLE_VALIDATE_TALK;\n\n      if (strcmp (method, \"ListNames\") == 0 ||\n          strcmp (method, \"ListActivatableNames\") == 0)\n        return HANDLE_FILTER_NAME_LIST_REPLY;\n\n      g_warning (\"Unknown bus method %s\", method);\n      return HANDLE_DENY;\n    }\n  else\n    {\n      return HANDLE_DENY;\n    }\n}\n\nstatic FlatpakPolicy\npolicy_from_handler (BusHandler handler)\n{\n  switch (handler)\n    {\n    case HANDLE_VALIDATE_OWN:\n      return FLATPAK_POLICY_OWN;\n\n    case HANDLE_VALIDATE_TALK:\n      return FLATPAK_POLICY_TALK;\n\n    case HANDLE_VALIDATE_SEE:\n      return FLATPAK_POLICY_SEE;\n\n    default:\n      return FLATPAK_POLICY_NONE;\n    }\n}\n\nstatic char *\nget_arg0_string (Buffer *buffer)\n{\n  GDBusMessage *message = g_dbus_message_new_from_blob (buffer->data, buffer->size, 0, NULL);\n  GVariant *body;\n  g_autoptr(GVariant) arg0 = NULL;\n  char *name = NULL;\n\n  if (message != NULL &&\n      (body = g_dbus_message_get_body (message)) != NULL &&\n      (arg0 = g_variant_get_child_value (body, 0)) != NULL &&\n      g_variant_is_of_type (arg0, G_VARIANT_TYPE_STRING))\n    name = g_variant_dup_string (arg0, NULL);\n\n  g_object_unref (message);\n\n  return name;\n}\n\nstatic gboolean\nvalidate_arg0_match (FlatpakProxyClient *client, Buffer *buffer)\n{\n  GDBusMessage *message = g_dbus_message_new_from_blob (buffer->data, buffer->size, 0, NULL);\n  GVariant *body, *arg0;\n  const char *match;\n  gboolean res = TRUE;\n\n  if (message != NULL &&\n      (body = g_dbus_message_get_body (message)) != NULL &&\n      (arg0 = g_variant_get_child_value (body, 0)) != NULL &&\n      g_variant_is_of_type (arg0, G_VARIANT_TYPE_STRING))\n    {\n      match = g_variant_get_string (arg0, NULL);\n      if (strstr (match, \"eavesdrop=\") != NULL)\n        res = FALSE;\n    }\n\n  g_object_unref (message);\n  return res;\n}\n\nstatic gboolean\nvalidate_arg0_name (FlatpakProxyClient *client, Buffer *buffer, FlatpakPolicy required_policy, FlatpakPolicy *has_policy)\n{\n  GDBusMessage *message = g_dbus_message_new_from_blob (buffer->data, buffer->size, 0, NULL);\n  GVariant *body, *arg0;\n  const char *name;\n  FlatpakPolicy name_policy;\n  gboolean res = FALSE;\n\n  if (has_policy)\n    *has_policy = FLATPAK_POLICY_NONE;\n\n  if (message != NULL &&\n      (body = g_dbus_message_get_body (message)) != NULL &&\n      (arg0 = g_variant_get_child_value (body, 0)) != NULL &&\n      g_variant_is_of_type (arg0, G_VARIANT_TYPE_STRING))\n    {\n      name = g_variant_get_string (arg0, NULL);\n      name_policy = flatpak_proxy_client_get_policy (client, name);\n\n      if (has_policy)\n        *has_policy = name_policy;\n\n      if (name_policy >= required_policy)\n        res = TRUE;\n      else if (client->proxy->log_messages)\n        g_print (\"Filtering message due to arg0 %s, policy: %d (required %d)\\n\", name, name_policy, required_policy);\n    }\n\n  g_object_unref (message);\n  return res;\n}\n\nstatic Buffer *\nfilter_names_list (FlatpakProxyClient *client, Buffer *buffer)\n{\n  GDBusMessage *message = g_dbus_message_new_from_blob (buffer->data, buffer->size, 0, NULL);\n  GVariant *body, *arg0, *new_names;\n  const gchar **names;\n  int i;\n  GVariantBuilder builder;\n  Buffer *filtered;\n\n  if (message == NULL ||\n      (body = g_dbus_message_get_body (message)) == NULL ||\n      (arg0 = g_variant_get_child_value (body, 0)) == NULL ||\n      !g_variant_is_of_type (arg0, G_VARIANT_TYPE_STRING_ARRAY))\n    return NULL;\n\n  names = g_variant_get_strv (arg0, NULL);\n\n  g_variant_builder_init (&builder, G_VARIANT_TYPE_STRING_ARRAY);\n  for (i = 0; names[i] != NULL; i++)\n    {\n      if (flatpak_proxy_client_get_policy (client, names[i]) >= FLATPAK_POLICY_SEE)\n        g_variant_builder_add (&builder, \"s\", names[i]);\n    }\n  g_free (names);\n\n  new_names = g_variant_builder_end (&builder);\n  g_dbus_message_set_body (message,\n                           g_variant_new_tuple (&new_names, 1));\n\n  filtered = message_to_buffer (message);\n  g_object_unref (message);\n  return filtered;\n}\n\nstatic gboolean\nmessage_is_name_owner_changed (FlatpakProxyClient *client, Header *header)\n{\n  if (header->type == G_DBUS_MESSAGE_TYPE_SIGNAL &&\n      g_strcmp0 (header->sender, \"org.freedesktop.DBus\") == 0 &&\n      g_strcmp0 (header->interface, \"org.freedesktop.DBus\") == 0 &&\n      g_strcmp0 (header->member, \"NameOwnerChanged\") == 0)\n    return TRUE;\n  return FALSE;\n}\n\nstatic gboolean\nshould_filter_name_owner_changed (FlatpakProxyClient *client, Buffer *buffer)\n{\n  GDBusMessage *message = g_dbus_message_new_from_blob (buffer->data, buffer->size, 0, NULL);\n  GVariant *body, *arg0, *arg1, *arg2;\n  const gchar *name, *old, *new;\n  gboolean filter = TRUE;\n\n  if (message == NULL ||\n      (body = g_dbus_message_get_body (message)) == NULL ||\n      (arg0 = g_variant_get_child_value (body, 0)) == NULL ||\n      !g_variant_is_of_type (arg0, G_VARIANT_TYPE_STRING) ||\n      (arg1 = g_variant_get_child_value (body, 1)) == NULL ||\n      !g_variant_is_of_type (arg1, G_VARIANT_TYPE_STRING) ||\n      (arg2 = g_variant_get_child_value (body, 2)) == NULL ||\n      !g_variant_is_of_type (arg2, G_VARIANT_TYPE_STRING))\n    return TRUE;\n\n  name = g_variant_get_string (arg0, NULL);\n  old = g_variant_get_string (arg1, NULL);\n  new = g_variant_get_string (arg2, NULL);\n\n  if (flatpak_proxy_client_get_policy (client, name) >= FLATPAK_POLICY_SEE ||\n      (client->proxy->sloppy_names && name[0] == ':'))\n    {\n      if (name[0] != ':')\n        {\n          if (old[0] != 0)\n            flatpak_proxy_client_update_unique_id_policy_from_name (client, old, name);\n\n          if (new[0] != 0)\n            flatpak_proxy_client_update_unique_id_policy_from_name (client, new, name);\n        }\n\n      filter = FALSE;\n    }\n\n  g_object_unref (message);\n\n  return filter;\n}\n\nstatic GList *\nside_get_n_unix_fds (ProxySide *side, int n_fds)\n{\n  GList *res = NULL;\n\n  while (side->control_messages != NULL)\n    {\n      GSocketControlMessage *control_message = side->control_messages->data;\n\n      if (G_IS_UNIX_FD_MESSAGE (control_message))\n        {\n          GUnixFDMessage *fd_message = G_UNIX_FD_MESSAGE (control_message);\n          GUnixFDList *fd_list = g_unix_fd_message_get_fd_list (fd_message);\n          int len = g_unix_fd_list_get_length (fd_list);\n\n          /* I believe that socket control messages are never merged, and\n             the sender side sends only one unix-fd-list per message, so\n             at this point there should always be one full fd list\n             per requested number of fds */\n          if (len != n_fds)\n            {\n              g_warning (\"Not right nr of fds in socket message\");\n              return NULL;\n            }\n\n          side->control_messages = g_list_delete_link (side->control_messages, side->control_messages);\n\n          return g_list_append (NULL, control_message);\n        }\n\n      g_object_unref (control_message);\n      side->control_messages = g_list_delete_link (side->control_messages, side->control_messages);\n    }\n\n  return res;\n}\n\nstatic gboolean\nupdate_socket_messages (ProxySide *side, Buffer *buffer, Header *header)\n{\n  /* We may accidentally combine multiple control messages into one\n     buffer when we receive (since we can do several recvs), so we\n     keep a list of all we get and then only re-attach the amount\n     specified in the header to the buffer. */\n\n  side->control_messages = g_list_concat (side->control_messages, buffer->control_messages);\n  buffer->control_messages = NULL;\n  if (header->unix_fds > 0)\n    {\n      buffer->control_messages = side_get_n_unix_fds (side, header->unix_fds);\n      if (buffer->control_messages == NULL)\n        {\n          g_warning (\"Not enough fds for message\");\n          side_closed (side);\n          buffer_unref (buffer);\n          return FALSE;\n        }\n    }\n  return TRUE;\n}\n\nstatic void\nqueue_fake_message (FlatpakProxyClient *client, GDBusMessage *message, ExpectedReplyType reply_type)\n{\n  Buffer *buffer;\n\n  client->last_serial++;\n  client->serial_offset++;\n  g_dbus_message_set_serial (message, client->last_serial);\n  buffer = message_to_buffer (message);\n  g_object_unref (message);\n\n  queue_outgoing_buffer (&client->bus_side, buffer);\n  queue_expected_reply (&client->client_side, client->last_serial, reply_type);\n}\n\n/* After the first Hello message we need to synthesize a bunch of messages to synchronize the\n   ownership state for the names in the policy */\nstatic void\nqueue_initial_name_ops (FlatpakProxyClient *client)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n  gboolean has_wildcards = FALSE;\n\n  g_hash_table_iter_init (&iter, client->proxy->policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char *name = key;\n      GDBusMessage *message;\n      GVariant *match;\n\n      if (strcmp (name, \"org.freedesktop.DBus\") == 0)\n        continue;\n\n      /* AddMatch the name so we get told about ownership changes.\n         Do it before the GetNameOwner to avoid races */\n      message = g_dbus_message_new_method_call (\"org.freedesktop.DBus\", \"/\", \"org.freedesktop.DBus\", \"AddMatch\");\n      match = g_variant_new_printf (\"type='signal',sender='org.freedesktop.DBus',interface='org.freedesktop.DBus',member='NameOwnerChanged',arg0='%s'\", name);\n      g_dbus_message_set_body (message, g_variant_new_tuple (&match, 1));\n      queue_fake_message (client, message, EXPECTED_REPLY_FILTER);\n\n      if (client->proxy->log_messages)\n        g_print (\"C%d: -> org.freedesktop.DBus fake AddMatch for %s\\n\", client->last_serial, name);\n\n      /* Get the current owner of the name (if any) so we can apply policy to it */\n      message = g_dbus_message_new_method_call (\"org.freedesktop.DBus\", \"/\", \"org.freedesktop.DBus\", \"GetNameOwner\");\n      g_dbus_message_set_body (message, g_variant_new (\"(s)\", name));\n      queue_fake_message (client, message, EXPECTED_REPLY_FAKE_GET_NAME_OWNER);\n      g_hash_table_replace (client->get_owner_reply, GINT_TO_POINTER (client->last_serial), g_strdup (name));\n\n      if (client->proxy->log_messages)\n        g_print (\"C%d: -> org.freedesktop.DBus fake GetNameOwner for %s\\n\", client->last_serial, name);\n    }\n\n  /* Same for wildcard proxies. Only here we don't know the actual names to GetNameOwner for, so we have to\n     list all current names */\n  g_hash_table_iter_init (&iter, client->proxy->wildcard_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char *name = key;\n      GDBusMessage *message;\n      GVariant *match;\n\n      has_wildcards = TRUE;\n\n      /* AddMatch the name with arg0namespace so we get told about ownership changes to all subnames.\n         Do it before the GetNameOwner to avoid races */\n      message = g_dbus_message_new_method_call (\"org.freedesktop.DBus\", \"/\", \"org.freedesktop.DBus\", \"AddMatch\");\n      match = g_variant_new_printf (\"type='signal',sender='org.freedesktop.DBus',interface='org.freedesktop.DBus',member='NameOwnerChanged',arg0namespace='%s'\", name);\n      g_dbus_message_set_body (message, g_variant_new_tuple (&match, 1));\n      queue_fake_message (client, message, EXPECTED_REPLY_FILTER);\n\n      if (client->proxy->log_messages)\n        g_print (\"C%d: -> org.freedesktop.DBus fake AddMatch for %s.*\\n\", client->last_serial, name);\n    }\n\n  if (has_wildcards)\n    {\n      GDBusMessage *message;\n\n      /* AddMatch the name so we get told about ownership changes.\n         Do it before the GetNameOwner to avoid races */\n      message = g_dbus_message_new_method_call (\"org.freedesktop.DBus\", \"/\", \"org.freedesktop.DBus\", \"ListNames\");\n      g_dbus_message_set_body (message, g_variant_new (\"()\"));\n      queue_fake_message (client, message, EXPECTED_REPLY_FAKE_LIST_NAMES);\n\n      if (client->proxy->log_messages)\n        g_print (\"C%d: -> org.freedesktop.DBus fake ListNames\\n\", client->last_serial);\n\n      /* Stop reading from the client, to avoid incoming messages fighting with the ListNames roundtrip.\n         We will start it again once we have handled the ListNames reply */\n      stop_reading (&client->client_side);\n    }\n}\n\nstatic void\nqueue_wildcard_initial_name_ops (FlatpakProxyClient *client, Header *header, Buffer *buffer)\n{\n  GDBusMessage *decoded_message = g_dbus_message_new_from_blob (buffer->data, buffer->size, 0, NULL);\n  GVariant *body, *arg0;\n\n  if (decoded_message != NULL &&\n      header->type == G_DBUS_MESSAGE_TYPE_METHOD_RETURN &&\n      (body = g_dbus_message_get_body (decoded_message)) != NULL &&\n      (arg0 = g_variant_get_child_value (body, 0)) != NULL &&\n      g_variant_is_of_type (arg0, G_VARIANT_TYPE_STRING_ARRAY))\n    {\n      const gchar **names = g_variant_get_strv (arg0, NULL);\n      int i;\n\n      /* Loop over all current names and get the owner for all the ones that match our wildcard\n         policies so that we can update the unique id policies for those */\n      for (i = 0; names[i] != NULL; i++)\n        {\n          const char *name = names[i];\n\n          if (name[0] != ':' &&\n              flatpak_proxy_get_wildcard_policy (client->proxy, name) != FLATPAK_POLICY_NONE)\n            {\n              /* Get the current owner of the name (if any) so we can apply policy to it */\n              GDBusMessage *message = g_dbus_message_new_method_call (\"org.freedesktop.DBus\", \"/\", \"org.freedesktop.DBus\", \"GetNameOwner\");\n              g_dbus_message_set_body (message, g_variant_new (\"(s)\", name));\n              queue_fake_message (client, message, EXPECTED_REPLY_FAKE_GET_NAME_OWNER);\n              g_hash_table_replace (client->get_owner_reply, GINT_TO_POINTER (client->last_serial), g_strdup (name));\n\n              if (client->proxy->log_messages)\n                g_print (\"C%d: -> org.freedesktop.DBus fake GetNameOwner for %s\\n\", client->last_serial, name);\n            }\n        }\n      g_free (names);\n    }\n\n  g_object_unref (decoded_message);\n}\n\n\nstatic void\ngot_buffer_from_client (FlatpakProxyClient *client, ProxySide *side, Buffer *buffer)\n{\n  ExpectedReplyType expecting_reply = EXPECTED_REPLY_NONE;\n\n  if (client->authenticated && client->proxy->filter)\n    {\n      g_autoptr(Header) header = NULL;;\n      BusHandler handler;\n\n      /* Filter and rewrite outgoing messages as needed */\n\n      header = parse_header (buffer, client->serial_offset, 0, 0);\n      if (header == NULL)\n        {\n          g_warning (\"Invalid message header format\");\n          side_closed (side);\n          buffer_unref (buffer);\n          return;\n        }\n\n      if (!update_socket_messages (side, buffer, header))\n        return;\n\n      /* Make sure the client is not playing games with the serials, as that\n         could confuse us. */\n      if (header->serial <= client->last_serial)\n        {\n          g_warning (\"Invalid client serial\");\n          side_closed (side);\n          buffer_unref (buffer);\n          return;\n        }\n      client->last_serial = header->serial;\n\n      if (client->proxy->log_messages)\n        print_outgoing_header (header);\n\n      /* Keep track of the initial Hello request so that we can read\n         the reply which has our assigned unique id */\n      if (is_dbus_method_call (header) &&\n          g_strcmp0 (header->member, \"Hello\") == 0)\n        {\n          expecting_reply = EXPECTED_REPLY_HELLO;\n          client->hello_serial = header->serial;\n        }\n\n      handler = get_dbus_method_handler (client, header);\n\n      switch (handler)\n        {\n        case HANDLE_FILTER_HAS_OWNER_REPLY:\n        case HANDLE_FILTER_GET_OWNER_REPLY:\n          if (!validate_arg0_name (client, buffer, FLATPAK_POLICY_SEE, NULL))\n            {\n              g_clear_pointer (&buffer, buffer_unref);\n              if (handler == HANDLE_FILTER_GET_OWNER_REPLY)\n                buffer = get_error_for_roundtrip (client, header,\n                                                  \"org.freedesktop.DBus.Error.NameHasNoOwner\");\n              else\n                buffer = get_bool_reply_for_roundtrip (client, header, FALSE);\n\n              expecting_reply = EXPECTED_REPLY_REWRITE;\n              break;\n            }\n\n          goto handle_pass;\n\n        case HANDLE_VALIDATE_MATCH:\n          if (!validate_arg0_match (client, buffer))\n            {\n              if (client->proxy->log_messages)\n                g_print (\"*DENIED* (ping)\\n\");\n              g_clear_pointer (&buffer, buffer_unref);\n              buffer = get_error_for_roundtrip (client, header,\n                                                \"org.freedesktop.DBus.Error.AccessDenied\");\n              expecting_reply = EXPECTED_REPLY_REWRITE;\n              break;\n            }\n\n          goto handle_pass;\n\n        case HANDLE_VALIDATE_OWN:\n        case HANDLE_VALIDATE_SEE:\n        case HANDLE_VALIDATE_TALK:\n          {\n            FlatpakPolicy name_policy;\n            if (validate_arg0_name (client, buffer, policy_from_handler (handler), &name_policy))\n              goto handle_pass;\n\n            if (name_policy < (int) FLATPAK_POLICY_SEE)\n              goto handle_hide;\n            else\n              goto handle_deny;\n          }\n\n        case HANDLE_FILTER_NAME_LIST_REPLY:\n          expecting_reply = EXPECTED_REPLY_LIST_NAMES;\n          goto handle_pass;\n\n        case HANDLE_PASS:\nhandle_pass:\n          if (client_message_generates_reply (header))\n            {\n              if (expecting_reply == EXPECTED_REPLY_NONE)\n                expecting_reply = EXPECTED_REPLY_NORMAL;\n            }\n\n          break;\n\n        case HANDLE_HIDE:\nhandle_hide:\n          g_clear_pointer (&buffer, buffer_unref);\n\n          if (client_message_generates_reply (header))\n            {\n              const char *error;\n\n              if (client->proxy->log_messages)\n                g_print (\"*HIDDEN* (ping)\\n\");\n\n              if ((header->destination != NULL && header->destination[0] == ':') ||\n                  (header->flags & G_DBUS_MESSAGE_FLAGS_NO_AUTO_START) != 0)\n                error = \"org.freedesktop.DBus.Error.NameHasNoOwner\";\n              else\n                error = \"org.freedesktop.DBus.Error.ServiceUnknown\";\n\n              buffer = get_error_for_roundtrip (client, header, error);\n              expecting_reply = EXPECTED_REPLY_REWRITE;\n            }\n          else\n            {\n              if (client->proxy->log_messages)\n                g_print (\"*HIDDEN*\\n\");\n            }\n          break;\n\n        default:\n        case HANDLE_DENY:\nhandle_deny:\n          g_clear_pointer (&buffer, buffer_unref);\n\n          if (client_message_generates_reply (header))\n            {\n              if (client->proxy->log_messages)\n                g_print (\"*DENIED* (ping)\\n\");\n\n              buffer = get_error_for_roundtrip (client, header,\n                                                \"org.freedesktop.DBus.Error.AccessDenied\");\n              expecting_reply = EXPECTED_REPLY_REWRITE;\n            }\n          else\n            {\n              if (client->proxy->log_messages)\n                g_print (\"*DENIED*\\n\");\n            }\n          break;\n        }\n\n      if (buffer != NULL && expecting_reply != EXPECTED_REPLY_NONE)\n        queue_expected_reply (side, header->serial, expecting_reply);\n    }\n\n  if (buffer)\n    queue_outgoing_buffer (&client->bus_side, buffer);\n\n  if (buffer != NULL && expecting_reply == EXPECTED_REPLY_HELLO)\n    queue_initial_name_ops (client);\n}\n\nstatic void\ngot_buffer_from_bus (FlatpakProxyClient *client, ProxySide *side, Buffer *buffer)\n{\n  if (client->authenticated && client->proxy->filter)\n    {\n      g_autoptr(Header) header = NULL;;\n      GDBusMessage *rewritten;\n      FlatpakPolicy policy;\n      ExpectedReplyType expected_reply;\n\n      /* Filter and rewrite incoming messages as needed */\n\n      header = parse_header (buffer, 0, client->serial_offset, client->hello_serial);\n      if (header == NULL)\n        {\n          g_warning (\"Invalid message header format\");\n          buffer_unref (buffer);\n          side_closed (side);\n          return;\n        }\n\n      if (!update_socket_messages (side, buffer, header))\n        return;\n\n      if (client->proxy->log_messages)\n        print_incoming_header (header);\n\n      if (header->has_reply_serial)\n        {\n          expected_reply = steal_expected_reply (get_other_side (side), header->reply_serial);\n\n          /* We only allow replies we expect */\n          if (expected_reply == EXPECTED_REPLY_NONE)\n            {\n              if (client->proxy->log_messages)\n                g_print (\"*Unexpected reply*\\n\");\n              buffer_unref (buffer);\n              return;\n            }\n\n          switch (expected_reply)\n            {\n            case EXPECTED_REPLY_HELLO:\n              /* When we get the initial reply to Hello, allow all\n                 further communications to our own unique id. */\n              if (header->type == G_DBUS_MESSAGE_TYPE_METHOD_RETURN)\n                {\n                  g_autofree char *my_id = get_arg0_string (buffer);\n                  flatpak_proxy_client_update_unique_id_policy (client, my_id, FLATPAK_POLICY_TALK);\n                  break;\n                }\n\n            case EXPECTED_REPLY_REWRITE:\n              /* Replace a roundtrip ping with the rewritten message */\n\n              rewritten = g_hash_table_lookup (client->rewrite_reply,\n                                               GINT_TO_POINTER (header->reply_serial));\n\n              if (client->proxy->log_messages)\n                g_print (\"*REWRITTEN*\\n\");\n\n              g_dbus_message_set_serial (rewritten, header->serial);\n              g_clear_pointer (&buffer, buffer_unref);\n              buffer = message_to_buffer (rewritten);\n\n              g_hash_table_remove (client->rewrite_reply,\n                                   GINT_TO_POINTER (header->reply_serial));\n              break;\n\n            case EXPECTED_REPLY_FAKE_LIST_NAMES:\n              /* This is a reply from the bus to a fake ListNames\n                 request, request ownership of any name matching a\n                 wildcard policy */\n\n              queue_wildcard_initial_name_ops (client, header, buffer);\n\n              /* Don't forward fake replies to the app */\n              if (client->proxy->log_messages)\n                g_print (\"*SKIPPED*\\n\");\n              g_clear_pointer (&buffer, buffer_unref);\n\n              /* Start reading the clients requests now that we are done with the names */\n              start_reading (&client->client_side);\n              break;\n\n            case EXPECTED_REPLY_FAKE_GET_NAME_OWNER:\n              /* This is a reply from the bus to a fake GetNameOwner\n                 request, update the policy for this unique name based on\n                 the policy */\n              {\n                char *requested_name = g_hash_table_lookup (client->get_owner_reply, GINT_TO_POINTER (header->reply_serial));\n\n                if (header->type == G_DBUS_MESSAGE_TYPE_METHOD_RETURN)\n                  {\n                    g_autofree char *owner = get_arg0_string (buffer);\n                    flatpak_proxy_client_update_unique_id_policy_from_name (client, owner, requested_name);\n                  }\n\n                g_hash_table_remove (client->get_owner_reply, GINT_TO_POINTER (header->reply_serial));\n\n                /* Don't forward fake replies to the app */\n                if (client->proxy->log_messages)\n                  g_print (\"*SKIPPED*\\n\");\n                g_clear_pointer (&buffer, buffer_unref);\n                break;\n              }\n\n            case EXPECTED_REPLY_FILTER:\n              if (client->proxy->log_messages)\n                g_print (\"*SKIPPED*\\n\");\n              g_clear_pointer (&buffer, buffer_unref);\n              break;\n\n            case EXPECTED_REPLY_LIST_NAMES:\n              /* This is a reply from the bus to a ListNames request, filter\n                 it according to the policy */\n              if (header->type == G_DBUS_MESSAGE_TYPE_METHOD_RETURN)\n                {\n                  Buffer *filtered_buffer;\n\n                  filtered_buffer = filter_names_list (client, buffer);\n                  g_clear_pointer (&buffer, buffer_unref);\n                  buffer = filtered_buffer;\n                }\n\n              break;\n\n            case EXPECTED_REPLY_NORMAL:\n              break;\n\n            default:\n              g_warning (\"Unexpected expected reply type %d\", expected_reply);\n            }\n        }\n      else /* Not reply */\n        {\n\n          /* Don't allow reply types with no reply_serial */\n          if (header->type == G_DBUS_MESSAGE_TYPE_METHOD_RETURN ||\n              header->type == G_DBUS_MESSAGE_TYPE_ERROR)\n            {\n              if (client->proxy->log_messages)\n                g_print (\"*Invalid reply*\\n\");\n              g_clear_pointer (&buffer, buffer_unref);\n            }\n\n          /* We filter all NameOwnerChanged signal according to the policy */\n          if (message_is_name_owner_changed (client, header))\n            {\n              if (should_filter_name_owner_changed (client, buffer))\n                g_clear_pointer (&buffer, buffer_unref);\n            }\n        }\n\n      /* All incoming broadcast signals are filtered according to policy */\n      if (header->type == G_DBUS_MESSAGE_TYPE_SIGNAL && header->destination == NULL)\n        {\n          policy = flatpak_proxy_client_get_policy (client, header->sender);\n          if (policy < FLATPAK_POLICY_TALK)\n            {\n              if (client->proxy->log_messages)\n                g_print (\"*FILTERED IN*\\n\");\n              g_clear_pointer (&buffer, buffer_unref);\n            }\n        }\n\n      /* We received and forwarded a message from a trusted peer. Make the policy for\n         this unique id SEE so that the client can track its lifetime. */\n      if (buffer && header->sender && header->sender[0] == ':')\n        flatpak_proxy_client_update_unique_id_policy (client, header->sender, FLATPAK_POLICY_SEE);\n\n      if (buffer && client_message_generates_reply (header))\n        queue_expected_reply (side, header->serial, EXPECTED_REPLY_NORMAL);\n    }\n\n  if (buffer)\n    queue_outgoing_buffer (&client->client_side, buffer);\n}\n\nstatic void\ngot_buffer_from_side (ProxySide *side, Buffer *buffer)\n{\n  FlatpakProxyClient *client = side->client;\n\n  if (side == &client->client_side)\n    got_buffer_from_client (client, side, buffer);\n  else\n    got_buffer_from_bus (client, side, buffer);\n}\n\nstatic gssize\nfind_auth_end (FlatpakProxyClient *client, Buffer *buffer)\n{\n  guchar *match;\n  int i;\n\n  /* First try to match any leftover at the start */\n  if (client->auth_end_offset > 0)\n    {\n      gsize left = strlen (AUTH_END_STRING) - client->auth_end_offset;\n      gsize to_match = MIN (left, buffer->pos);\n      /* Matched at least up to to_match */\n      if (memcmp (buffer->data, &AUTH_END_STRING[client->auth_end_offset], to_match) == 0)\n        {\n          client->auth_end_offset += to_match;\n\n          /* Matched all */\n          if (client->auth_end_offset == strlen (AUTH_END_STRING))\n            return to_match;\n\n          /* Matched to end of buffer */\n          return -1;\n        }\n\n      /* Did not actually match at start */\n      client->auth_end_offset = -1;\n    }\n\n  /* Look for whole match inside buffer */\n  match = memmem (buffer, buffer->pos,\n                  AUTH_END_STRING, strlen (AUTH_END_STRING));\n  if (match != NULL)\n    return match - buffer->data + strlen (AUTH_END_STRING);\n\n  /* Record longest prefix match at the end */\n  for (i = MIN (strlen (AUTH_END_STRING) - 1, buffer->pos); i > 0; i--)\n    {\n      if (memcmp (buffer->data + buffer->pos - i, AUTH_END_STRING, i) == 0)\n        {\n          client->auth_end_offset = i;\n          break;\n        }\n    }\n\n  return -1;\n}\n\nstatic gboolean\nside_in_cb (GSocket *socket, GIOCondition condition, gpointer user_data)\n{\n  ProxySide *side = user_data;\n  FlatpakProxyClient *client = side->client;\n  GError *error = NULL;\n  Buffer *buffer;\n  gboolean retval = G_SOURCE_CONTINUE;\n\n  g_object_ref (client);\n\n  while (!side->closed)\n    {\n      if (!side->got_first_byte)\n        buffer = buffer_new (1, NULL);\n      else if (!client->authenticated)\n        buffer = buffer_new (64, NULL);\n      else\n        buffer = side->current_read_buffer;\n\n      if (!buffer_read (side, buffer, socket))\n        {\n          if (buffer != side->current_read_buffer)\n              buffer_unref (buffer);\n          break;\n        }\n\n      if (!client->authenticated)\n        {\n          if (buffer->pos > 0)\n            {\n              gboolean found_auth_end = FALSE;\n              gsize extra_data;\n\n              buffer->size = buffer->pos;\n              if (!side->got_first_byte)\n                {\n                  buffer->send_credentials = TRUE;\n                  side->got_first_byte = TRUE;\n                }\n              /* Look for end of authentication mechanism */\n              else if (side == &client->client_side)\n                {\n                  gssize auth_end = find_auth_end (client, buffer);\n\n                  if (auth_end >= 0)\n                    {\n                      found_auth_end = TRUE;\n                      buffer->size = auth_end;\n                      extra_data = buffer->pos - buffer->size;\n\n                      /* We may have gotten some extra data which is not part of\n                         the auth handshake, keep it for the next iteration. */\n                      if (extra_data > 0)\n                        side->extra_input_data = g_bytes_new (buffer->data + buffer->size, extra_data);\n                    }\n                }\n\n              got_buffer_from_side (side, buffer);\n\n              if (found_auth_end)\n                client->authenticated = TRUE;\n            }\n          else\n            {\n              buffer_unref (buffer);\n            }\n        }\n      else if (buffer->pos == buffer->size)\n        {\n          if (buffer == &side->header_buffer)\n            {\n              gssize required;\n              required = g_dbus_message_bytes_needed (buffer->data, buffer->size, &error);\n              if (required < 0)\n                {\n                  g_warning (\"Invalid message header read\");\n                  side_closed (side);\n                }\n              else\n                {\n                  side->current_read_buffer = buffer_new (required, buffer);\n                }\n            }\n          else\n            {\n              got_buffer_from_side (side, buffer);\n              side->header_buffer.pos = 0;\n              side->current_read_buffer = &side->header_buffer;\n            }\n        }\n    }\n\n  if (side->closed)\n    {\n      side->in_source = NULL;\n      retval = G_SOURCE_REMOVE;\n    }\n\n  g_object_unref (client);\n\n  return retval;\n}\n\nstatic void\nstart_reading (ProxySide *side)\n{\n  GSocket *socket;\n\n  socket = g_socket_connection_get_socket (side->connection);\n  side->in_source = g_socket_create_source (socket, G_IO_IN, NULL);\n  g_source_set_callback (side->in_source, (GSourceFunc) side_in_cb, side, NULL);\n  g_source_attach (side->in_source, NULL);\n  g_source_unref (side->in_source);\n}\n\nstatic void\nstop_reading (ProxySide *side)\n{\n  if (side->in_source)\n    {\n      g_source_destroy (side->in_source);\n      side->in_source = NULL;\n    }\n}\n\n\nstatic void\nclient_connected_to_dbus (GObject      *source_object,\n                          GAsyncResult *res,\n                          gpointer      user_data)\n{\n  FlatpakProxyClient *client = user_data;\n  GSocketConnection *connection;\n  GError *error = NULL;\n  GIOStream *stream;\n\n  stream = g_dbus_address_get_stream_finish (res, NULL, &error);\n  if (stream == NULL)\n    {\n      g_warning (\"Failed to connect to bus: %s\", error->message);\n      g_object_unref (client);\n      return;\n    }\n\n  connection = G_SOCKET_CONNECTION (stream);\n  g_socket_set_blocking (g_socket_connection_get_socket (connection), FALSE);\n  client->bus_side.connection = connection;\n\n  start_reading (&client->client_side);\n  start_reading (&client->bus_side);\n}\n\nstatic gboolean\nflatpak_proxy_incoming (GSocketService    *service,\n                        GSocketConnection *connection,\n                        GObject           *source_object)\n{\n  FlatpakProxy *proxy = FLATPAK_PROXY (service);\n  FlatpakProxyClient *client;\n\n  client = flatpak_proxy_client_new (proxy, connection);\n\n  g_dbus_address_get_stream (proxy->dbus_address,\n                             NULL,\n                             client_connected_to_dbus,\n                             client);\n  return TRUE;\n}\n\nstatic void\nflatpak_proxy_init (FlatpakProxy *proxy)\n{\n  proxy->policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  proxy->filters = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify)filter_list_free);\n  proxy->wildcard_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  flatpak_proxy_add_policy (proxy, \"org.freedesktop.DBus\", FLATPAK_POLICY_TALK);\n}\n\nstatic void\nflatpak_proxy_class_init (FlatpakProxyClass *klass)\n{\n  GObjectClass *object_class = G_OBJECT_CLASS (klass);\n  GSocketServiceClass *socket_service_class = G_SOCKET_SERVICE_CLASS (klass);\n\n  object_class->get_property = flatpak_proxy_get_property;\n  object_class->set_property = flatpak_proxy_set_property;\n  object_class->finalize = flatpak_proxy_finalize;\n\n  socket_service_class->incoming = flatpak_proxy_incoming;\n\n  g_object_class_install_property (object_class,\n                                   PROP_DBUS_ADDRESS,\n                                   g_param_spec_string (\"dbus-address\",\n                                                        \"\",\n                                                        \"\",\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));\n  g_object_class_install_property (object_class,\n                                   PROP_SOCKET_PATH,\n                                   g_param_spec_string (\"socket-path\",\n                                                        \"\",\n                                                        \"\",\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));\n\n}\n\nFlatpakProxy *\nflatpak_proxy_new (const char *dbus_address,\n                   const char *socket_path)\n{\n  FlatpakProxy *proxy;\n\n  proxy = g_object_new (FLATPAK_TYPE_PROXY, \"dbus-address\", dbus_address, \"socket-path\", socket_path, NULL);\n  return proxy;\n}\n\ngboolean\nflatpak_proxy_start (FlatpakProxy *proxy, GError **error)\n{\n  GSocketAddress *address;\n  gboolean res;\n\n  unlink (proxy->socket_path);\n\n  address = g_unix_socket_address_new (proxy->socket_path);\n\n  error = NULL;\n  res = g_socket_listener_add_address (G_SOCKET_LISTENER (proxy),\n                                       address,\n                                       G_SOCKET_TYPE_STREAM,\n                                       G_SOCKET_PROTOCOL_DEFAULT,\n                                       NULL, /* source_object */\n                                       NULL, /* effective_address */\n                                       error);\n  g_object_unref (address);\n\n  if (!res)\n    return FALSE;\n\n\n  g_socket_service_start (G_SOCKET_SERVICE (proxy));\n  return TRUE;\n}\n\nvoid\nflatpak_proxy_stop (FlatpakProxy *proxy)\n{\n  unlink (proxy->socket_path);\n\n  g_socket_service_stop (G_SOCKET_SERVICE (proxy));\n}\n"], "fixing_code": ["/*\n * Copyright \u00a9 2015 Red Hat, Inc\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n * Authors:\n *       Alexander Larsson <alexl@redhat.com>\n */\n\n#include \"config.h\"\n\n#include <unistd.h>\n#include <string.h>\n\n#include \"flatpak-proxy.h\"\n\n#include <gio/gunixsocketaddress.h>\n#include <gio/gunixconnection.h>\n#include <gio/gunixfdmessage.h>\n\n/**\n * The proxy listens to a unix domain socket, and for each new\n * connection it opens up a new connection to a specified dbus bus\n * address (typically the session bus) and forwards data between the\n * two. During the authentication phase all data is forwarded as\n * received, and additionally for the first 1 byte zero we also send\n * the proxy credentials to the bus.\n *\n * Once the connection is authenticated there are two modes, filtered\n * and unfiltered. In the unfiltered mode we just send all messages on\n * as we receive, but in the in the filtering mode we apply a policy,\n * which is similar to the policy supported by kdbus.\n *\n * The policy for the filtering consists of a mapping from well-known\n * names to a policy that is either SEE, TALK or OWN. The default\n * initial policy is that the the user is only allowed to TALK to the\n * bus itself (org.freedesktop.DBus, or no destination specified), and\n * TALK to its own unique id. All other clients are invisible. The\n * well-known names can be specified exactly, or as a simple one-level\n * wildcard like \"org.foo.*\" which matches \"org.foo.bar\", but not\n * \"org.foobar\" or \"org.foo.bar.gazonk\".\n *\n * Polices are specified for well-known names, but they also affect\n * the owner of that name, so that the policy for a unique id is the\n * superset of the polices for all the names it owns. Due to technical\n * reasons the policy for a unique name is \"sticky\", in that we keep\n * the highest policy granted by a once-owned name even when the client\n * releases that name. This is impossible to avoid in a race-free way\n * in a proxy. But this is rarely a problem in practice, as clients\n * rarely release names and stay on the bus.\n *\n * Here is a description of the policy levels:\n * (all policy levels also imply the ones before it)\n *\n * SEE:\n *    The name/id is visible in the ListNames reply\n *    The name/id is visible in the ListActivatableNames reply\n *    You can call GetNameOwner on the name\n *    You can call NameHasOwner on the name\n *    You see NameOwnerChanged signals on the name\n *    You see NameOwnerChanged signals on the id when the client disconnects\n *    You can call the GetXXX methods on the name/id to get e.g. the peer pid\n *    You get AccessDenied rather than NameHasNoOwner when sending messages to the name/id\n *\n * FILTERED:\n *    You can send *some* method calls to the name (not id)\n *\n * TALK:\n *    You can send any method calls and signals to the name/id\n *    You will receive broadcast signals from the name/id (if you have a match rule for them)\n *    You can call StartServiceByName on the name\n *\n * OWN:\n *    You are allowed to call RequestName/ReleaseName/ListQueuedOwners on the name.\n *\n * The policy applies only to signals and method calls. All replies\n * (errors or method returns) are allowed once for an outstanding\n * method call, and never otherwise.\n *\n * Every peer on the bus is considered priviledged, and we thus trust\n * it. So we rely on similar proxies to be running for all untrusted\n * clients. Any such priviledged peer is allowed to send method call\n * or unicast signal messages to the proxied client. Once another peer\n * sends you a message the unique id of that peer is now made visible\n * (policy SEE) to the proxied client, allowing the client to track\n * caller lifetimes via NameOwnerChanged signals.\n *\n * Differences to kdbus custom endpoint policies:\n *\n *  * The proxy will return the credentials (like pid) of the proxy,\n *    not the real client.\n *\n *  * Policy is not dropped when a peer releases a name.\n *\n *  * Peers that call you become visible (SEE) (and get signals for\n *    NameOwnerChange disconnect) In kdbus currently custom endpoints\n *    never get NameOwnerChange signals for unique ids, but this is\n *    problematic as it disallows a services to track lifetimes of its\n *    clients.\n *\n * Mode of operation\n *\n * Once authenticated we receive incoming messages one at a time,\n * and then we demarshal the message headers to make routing decisions.\n * This means we trust the bus to do message format validation, etc.\n * (because we don't parse the body). Also we assume that the bus verifies\n * reply_serials, i.e. that a reply can only be sent once and by the real\n * recipient of an previously sent method call.\n *\n * We don't however trust the serials from the client. We verify that\n * they are strictly increasing to make sure the code is not confused\n * by serials being reused.\n *\n * In order to track the ownership of the allowed names we hijack the\n * connection after the initial Hello message, sending AddMatch,\n * ListNames and GetNameOwner messages to get a proper view of who\n * owns the names atm. Then we listen to NameOwnerChanged events for\n * further updates. This causes a slight offset between serials in the\n * client and serials as seen by the bus.\n *\n * After that the filter is strictly passive, in that we never\n * construct our own requests. For each message received from the\n * client we look up the type and the destination policy and make a\n * decision to either pass it on as is, rewrite it before passing on\n * (for instance ListName replies), drop it completely, or return a\n * made-up reply/error to the sender.\n *\n * When returning a made-up reply we replace the actual message with a\n * Ping request to the bus with the same serial and replace the resulting\n * reply with the made up reply (with the serial from the Ping reply).\n * This means we keep the strict message ordering and serial numbers of\n * the bus.\n *\n * Policy is applied to unique ids in the following cases:\n *  * During startup we call AddWatch for signals on all policy names\n *    and wildcards (using arg0namespace) so that we get NameOwnerChanged\n *    events which we use to update the unique id policies.\n *  * During startup we create synthetic GetNameOwner requests for all\n *    normal policy names, and if there are wildcarded names we create a\n *    synthetic ListNames request and use the results of that to do further\n *    GetNameOwner for the existing names matching the wildcards. When we get\n *    replies for the GetNameOwner requests the unique id policy is updated.\n *  * When we get a method call from a unique id, it gets SEE\n *  * When we get a reply to the initial Hello request we give\n *    our own assigned unique id policy TALK.\n *\n * All messages sent to the bus itself are fully demarshalled\n * and handled on a per-method basis:\n *\n * Hello, AddMatch, RemoveMatch, GetId: Always allowed\n * ListNames, ListActivatableNames: Always allowed, but response filtered\n * UpdateActivationEnvironment, BecomeMonitor: Always denied\n * RequestName, ReleaseName, ListQueuedOwners: Only allowed if arg0 is a name with policy OWN\n * NameHasOwner, GetNameOwner: Only pass on if arg0 is a name with policy SEE, otherwise return synthetic reply\n * StartServiceByName: Only allowed if policy TALK on arg0\n * GetConnectionUnixProcessID, GetConnectionCredentials,\n *  GetAdtAuditSessionData, GetConnectionSELinuxSecurityContext,\n *  GetConnectionUnixUser: Allowed if policy SEE on arg0\n *\n * For unknown methods, we return a synthetic error.\n */\n\ntypedef struct FlatpakProxyClient FlatpakProxyClient;\n\n#define FIND_AUTH_END_CONTINUE -1\n#define FIND_AUTH_END_ABORT -2\n\n#define AUTH_LINE_SENTINEL \"\\r\\n\"\n#define AUTH_BEGIN \"BEGIN\"\n\ntypedef enum {\n  EXPECTED_REPLY_NONE,\n  EXPECTED_REPLY_NORMAL,\n  EXPECTED_REPLY_HELLO,\n  EXPECTED_REPLY_FILTER,\n  EXPECTED_REPLY_FAKE_GET_NAME_OWNER,\n  EXPECTED_REPLY_FAKE_LIST_NAMES,\n  EXPECTED_REPLY_LIST_NAMES,\n  EXPECTED_REPLY_REWRITE,\n} ExpectedReplyType;\n\ntypedef struct\n{\n  gsize    size;\n  gsize    pos;\n  int      refcount;\n  gboolean send_credentials;\n  GList   *control_messages;\n\n  guchar   data[16];\n  /* data continues here */\n} Buffer;\n\ntypedef struct\n{\n  Buffer     *buffer;\n  gboolean    big_endian;\n  guchar      type;\n  guchar      flags;\n  guint32     length;\n  guint32     serial;\n  const char *path;\n  const char *interface;\n  const char *member;\n  const char *error_name;\n  const char *destination;\n  const char *sender;\n  const char *signature;\n  gboolean    has_reply_serial;\n  guint32     reply_serial;\n  guint32     unix_fds;\n} Header;\n\ntypedef struct\n{\n  char *path;\n  char *interface;\n  char *member;\n} Filter;\n\nstatic void header_free (Header *header);\nG_DEFINE_AUTOPTR_CLEANUP_FUNC (Header, header_free)\n\ntypedef struct\n{\n  gboolean            got_first_byte; /* always true on bus side */\n  gboolean            closed; /* always true on bus side */\n\n  FlatpakProxyClient *client;\n  GSocketConnection  *connection;\n  GSource            *in_source;\n  GSource            *out_source;\n\n  GBytes             *extra_input_data;\n  Buffer             *current_read_buffer;\n  Buffer              header_buffer;\n\n  GList              *buffers; /* to be sent */\n  GList              *control_messages;\n\n  GHashTable         *expected_replies;\n} ProxySide;\n\nstruct FlatpakProxyClient\n{\n  GObject       parent;\n\n  FlatpakProxy *proxy;\n\n  gboolean      authenticated;\n  GByteArray   *auth_buffer;\n\n  ProxySide     client_side;\n  ProxySide     bus_side;\n\n  /* Filtering data: */\n  guint32     serial_offset;\n  guint32     hello_serial;\n  guint32     last_serial;\n  GHashTable *rewrite_reply;\n  GHashTable *get_owner_reply;\n\n  GHashTable *unique_id_policy;\n};\n\ntypedef struct\n{\n  GObjectClass parent_class;\n} FlatpakProxyClientClass;\n\nstruct FlatpakProxy\n{\n  GSocketService parent;\n\n  gboolean       log_messages;\n\n  GList         *clients;\n  char          *socket_path;\n  char          *dbus_address;\n\n  gboolean       filter;\n  gboolean       sloppy_names;\n\n  GHashTable    *wildcard_policy;\n  GHashTable    *policy;\n  GHashTable    *filters;\n};\n\ntypedef struct\n{\n  GSocketServiceClass parent_class;\n} FlatpakProxyClass;\n\n\nenum {\n  PROP_0,\n\n  PROP_DBUS_ADDRESS,\n  PROP_SOCKET_PATH\n};\n\n#define FLATPAK_TYPE_PROXY flatpak_proxy_get_type ()\n#define FLATPAK_PROXY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FLATPAK_TYPE_PROXY, FlatpakProxy))\n#define FLATPAK_IS_PROXY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FLATPAK_TYPE_PROXY))\n\n\n#define FLATPAK_TYPE_PROXY_CLIENT flatpak_proxy_client_get_type ()\n#define FLATPAK_PROXY_CLIENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FLATPAK_TYPE_PROXY_CLIENT, FlatpakProxyClient))\n#define FLATPAK_IS_PROXY_CLIENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FLATPAK_TYPE_PROXY_CLIENT))\n\nGType flatpak_proxy_client_get_type (void);\n\nG_DEFINE_TYPE (FlatpakProxy, flatpak_proxy, G_TYPE_SOCKET_SERVICE)\nG_DEFINE_TYPE (FlatpakProxyClient, flatpak_proxy_client, G_TYPE_OBJECT)\n\nstatic void start_reading (ProxySide *side);\nstatic void stop_reading (ProxySide *side);\n\nstatic void\nbuffer_unref (Buffer *buffer)\n{\n  g_assert (buffer->refcount > 0);\n  buffer->refcount--;\n\n  if (buffer->refcount == 0)\n    {\n      g_list_free_full (buffer->control_messages, g_object_unref);\n      g_free (buffer);\n    }\n}\n\nstatic Buffer *\nbuffer_ref (Buffer *buffer)\n{\n  g_assert (buffer->refcount > 0);\n  buffer->refcount++;\n  return buffer;\n}\n\nstatic void\nfree_side (ProxySide *side)\n{\n  g_clear_object (&side->connection);\n  g_clear_pointer (&side->extra_input_data, g_bytes_unref);\n\n  g_list_free_full (side->buffers, (GDestroyNotify) buffer_unref);\n  g_list_free_full (side->control_messages, (GDestroyNotify) g_object_unref);\n\n  if (side->in_source)\n    g_source_destroy (side->in_source);\n  if (side->out_source)\n    g_source_destroy (side->out_source);\n\n  g_hash_table_destroy (side->expected_replies);\n}\n\nstatic void\nflatpak_proxy_client_finalize (GObject *object)\n{\n  FlatpakProxyClient *client = FLATPAK_PROXY_CLIENT (object);\n\n  client->proxy->clients = g_list_remove (client->proxy->clients, client);\n  g_clear_object (&client->proxy);\n\n  g_byte_array_free (client->auth_buffer, TRUE);\n  g_hash_table_destroy (client->rewrite_reply);\n  g_hash_table_destroy (client->get_owner_reply);\n  g_hash_table_destroy (client->unique_id_policy);\n\n  free_side (&client->client_side);\n  free_side (&client->bus_side);\n\n  G_OBJECT_CLASS (flatpak_proxy_client_parent_class)->finalize (object);\n}\n\nstatic void\nflatpak_proxy_client_class_init (FlatpakProxyClientClass *klass)\n{\n  GObjectClass *object_class = G_OBJECT_CLASS (klass);\n\n  object_class->finalize = flatpak_proxy_client_finalize;\n}\n\nstatic void\ninit_side (FlatpakProxyClient *client, ProxySide *side)\n{\n  side->got_first_byte = (side == &client->bus_side);\n  side->client = client;\n  side->header_buffer.size = 16;\n  side->header_buffer.pos = 0;\n  side->current_read_buffer = &side->header_buffer;\n  side->expected_replies = g_hash_table_new (g_direct_hash, g_direct_equal);\n}\n\nstatic void\nflatpak_proxy_client_init (FlatpakProxyClient *client)\n{\n  init_side (client, &client->client_side);\n  init_side (client, &client->bus_side);\n\n  client->auth_buffer = g_byte_array_new ();\n  client->rewrite_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);\n  client->get_owner_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);\n  client->unique_id_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n}\n\nstatic FlatpakProxyClient *\nflatpak_proxy_client_new (FlatpakProxy *proxy, GSocketConnection *connection)\n{\n  FlatpakProxyClient *client;\n\n  g_socket_set_blocking (g_socket_connection_get_socket (connection), FALSE);\n\n  client = g_object_new (FLATPAK_TYPE_PROXY_CLIENT, NULL);\n  client->proxy = g_object_ref (proxy);\n  client->client_side.connection = g_object_ref (connection);\n\n  proxy->clients = g_list_prepend (proxy->clients, client);\n\n  return client;\n}\n\nstatic FlatpakPolicy\nflatpak_proxy_get_wildcard_policy (FlatpakProxy *proxy,\n                                   const char   *_name)\n{\n  guint policy, wildcard_policy = 0;\n  char *dot;\n  g_autofree char *name = g_strdup (_name);\n\n  dot = name + strlen (name);\n  while (dot)\n    {\n      *dot = 0;\n      policy = GPOINTER_TO_INT (g_hash_table_lookup (proxy->wildcard_policy, name));\n      wildcard_policy = MAX (wildcard_policy, policy);\n      dot = strrchr (name, '.');\n    }\n\n  return wildcard_policy;\n}\n\nstatic FlatpakPolicy\nflatpak_proxy_get_policy (FlatpakProxy *proxy,\n                          const char   *name)\n{\n  guint policy, wildcard_policy;\n\n  policy = GPOINTER_TO_INT (g_hash_table_lookup (proxy->policy, name));\n\n  wildcard_policy = flatpak_proxy_get_wildcard_policy (proxy, name);\n\n  return MAX (policy, wildcard_policy);\n}\n\nvoid\nflatpak_proxy_set_filter (FlatpakProxy *proxy,\n                          gboolean      filter)\n{\n  proxy->filter = filter;\n}\n\nvoid\nflatpak_proxy_set_sloppy_names (FlatpakProxy *proxy,\n                                gboolean      sloppy_names)\n{\n  proxy->sloppy_names = sloppy_names;\n}\n\nvoid\nflatpak_proxy_set_log_messages (FlatpakProxy *proxy,\n                                gboolean      log)\n{\n  proxy->log_messages = log;\n}\n\nvoid\nflatpak_proxy_add_policy (FlatpakProxy *proxy,\n                          const char   *name,\n                          FlatpakPolicy policy)\n{\n  guint current_policy = GPOINTER_TO_INT (g_hash_table_lookup (proxy->policy, name));\n\n  current_policy = MAX (policy, current_policy);\n\n  g_hash_table_replace (proxy->policy, g_strdup (name), GINT_TO_POINTER (current_policy));\n}\n\nvoid\nflatpak_proxy_add_wildcarded_policy (FlatpakProxy *proxy,\n                                     const char   *name,\n                                     FlatpakPolicy policy)\n{\n  g_hash_table_replace (proxy->wildcard_policy, g_strdup (name), GINT_TO_POINTER (policy));\n}\n\nstatic void\nfilter_free (Filter *filter)\n{\n  g_free (filter->path);\n  g_free (filter->interface);\n  g_free (filter->member);\n  g_free (filter);\n}\n\nstatic void\nfilter_list_free (GList *filters)\n{\n  g_list_free_full (filters, (GDestroyNotify)filter_free);\n}\n\n/* rules are of the form [org.the.interface.[method|*]][@/obj/path] */\nstatic Filter *\nfilter_new (const char *rule)\n{\n  Filter *filter = g_new0 (Filter, 1);\n  const char *obj_path_start = NULL;\n  const char *method_end = NULL;\n\n  obj_path_start = strchr (rule, '@');\n  if (obj_path_start && obj_path_start[1] != 0)\n    filter->path = g_strdup (obj_path_start + 1);\n\n  if (obj_path_start != NULL)\n    method_end = obj_path_start;\n  else\n    method_end = rule + strlen(rule);\n\n  if (rule[0] != '@')\n    {\n      filter->interface = g_strndup (rule, method_end - rule);\n      char *dot = strrchr (filter->interface, '.');\n      if (dot != NULL)\n        {\n          *dot = 0;\n          if (strcmp (dot+1, \"*\") != 0)\n            filter->member = g_strdup (dot + 1);\n         }\n    }\n\n  return filter;\n}\n\n\nvoid\nflatpak_proxy_add_filter (FlatpakProxy *proxy,\n                          const char   *name,\n                          const char   *rule)\n{\n  Filter *filter;\n  GList *filters, *new_filters;\n\n  filter = filter_new (rule);\n  if (g_hash_table_lookup_extended (proxy->filters,\n                                    name,\n                                    NULL, (void **)&filters))\n    {\n      new_filters = g_list_append (filters, filter);\n      g_assert (new_filters == filters);\n    }\n  else\n    {\n      filters = g_list_append (NULL, filter);\n      g_hash_table_insert (proxy->filters, g_strdup (name), filters);\n    }\n}\n\nstatic void\nflatpak_proxy_finalize (GObject *object)\n{\n  FlatpakProxy *proxy = FLATPAK_PROXY (object);\n\n  if (g_socket_service_is_active (G_SOCKET_SERVICE (proxy)))\n    unlink (proxy->socket_path);\n\n  g_assert (proxy->clients == NULL);\n\n  g_hash_table_destroy (proxy->policy);\n  g_hash_table_destroy (proxy->wildcard_policy);\n  g_hash_table_destroy (proxy->filters);\n\n  g_free (proxy->socket_path);\n  g_free (proxy->dbus_address);\n\n  G_OBJECT_CLASS (flatpak_proxy_parent_class)->finalize (object);\n}\n\nstatic void\nflatpak_proxy_set_property (GObject      *object,\n                            guint         prop_id,\n                            const GValue *value,\n                            GParamSpec   *pspec)\n{\n  FlatpakProxy *proxy = FLATPAK_PROXY (object);\n\n  switch (prop_id)\n    {\n    case PROP_DBUS_ADDRESS:\n      proxy->dbus_address = g_value_dup_string (value);\n      break;\n\n    case PROP_SOCKET_PATH:\n      proxy->socket_path = g_value_dup_string (value);\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}\n\nstatic void\nflatpak_proxy_get_property (GObject    *object,\n                            guint       prop_id,\n                            GValue     *value,\n                            GParamSpec *pspec)\n{\n  FlatpakProxy *proxy = FLATPAK_PROXY (object);\n\n  switch (prop_id)\n    {\n    case PROP_DBUS_ADDRESS:\n      g_value_set_string (value, proxy->dbus_address);\n      break;\n\n    case PROP_SOCKET_PATH:\n      g_value_set_string (value, proxy->socket_path);\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}\n\nstatic Buffer *\nbuffer_new (gsize size, Buffer *old)\n{\n  Buffer *buffer = g_malloc0 (sizeof (Buffer) + size - 16);\n\n  buffer->control_messages = NULL;\n  buffer->size = size;\n  buffer->refcount = 1;\n\n  if (old)\n    {\n      buffer->pos = old->pos;\n      /* Takes ownership of any old control messages */\n      buffer->control_messages = old->control_messages;\n      old->control_messages = NULL;\n\n      g_assert (size >= old->size);\n      memcpy (buffer->data, old->data, old->size);\n    }\n\n  return buffer;\n}\n\nstatic ProxySide *\nget_other_side (ProxySide *side)\n{\n  FlatpakProxyClient *client = side->client;\n\n  if (side == &client->client_side)\n    return &client->bus_side;\n\n  return &client->client_side;\n}\n\nstatic void\nside_closed (ProxySide *side)\n{\n  GSocket *socket, *other_socket;\n  ProxySide *other_side = get_other_side (side);\n\n  if (side->closed)\n    return;\n\n  socket = g_socket_connection_get_socket (side->connection);\n  g_socket_close (socket, NULL);\n  side->closed = TRUE;\n\n  other_socket = g_socket_connection_get_socket (other_side->connection);\n  if (!other_side->closed && other_side->buffers == NULL)\n    {\n      g_socket_close (other_socket, NULL);\n      other_side->closed = TRUE;\n    }\n\n  if (other_side->closed)\n    {\n      g_object_unref (side->client);\n    }\n  else\n    {\n      GError *error = NULL;\n\n      if (!g_socket_shutdown (other_socket, TRUE, FALSE, &error))\n        {\n          g_warning (\"Unable to shutdown read side: %s\", error->message);\n          g_error_free (error);\n        }\n    }\n}\n\nstatic gboolean\nbuffer_read (ProxySide *side,\n             Buffer    *buffer,\n             GSocket   *socket)\n{\n  gssize res;\n  GInputVector v;\n  GError *error = NULL;\n  GSocketControlMessage **messages;\n  int num_messages, i;\n\n  if (side->extra_input_data)\n    {\n      gsize extra_size;\n      const guchar *extra_bytes = g_bytes_get_data (side->extra_input_data, &extra_size);\n\n      res = MIN (extra_size, buffer->size - buffer->pos);\n      memcpy (&buffer->data[buffer->pos], extra_bytes, res);\n\n      if (res < extra_size)\n        {\n          side->extra_input_data =\n            g_bytes_new_with_free_func (extra_bytes + res,\n                                        extra_size - res,\n                                        (GDestroyNotify) g_bytes_unref,\n                                        side->extra_input_data);\n        }\n      else\n        {\n          g_clear_pointer (&side->extra_input_data, g_bytes_unref);\n        }\n    }\n  else\n    {\n      int flags = 0;\n      v.buffer = &buffer->data[buffer->pos];\n      v.size = buffer->size - buffer->pos;\n\n      res = g_socket_receive_message (socket, NULL, &v, 1,\n                                      &messages,\n                                      &num_messages,\n                                      &flags, NULL, &error);\n      if (res < 0 && g_error_matches (error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK))\n        {\n          g_error_free (error);\n          return FALSE;\n        }\n\n      if (res <= 0)\n        {\n          if (res != 0)\n            {\n              g_debug (\"Error reading from socket: %s\", error->message);\n              g_error_free (error);\n            }\n\n          side_closed (side);\n          return FALSE;\n        }\n\n      for (i = 0; i < num_messages; i++)\n        buffer->control_messages = g_list_append (buffer->control_messages, messages[i]);\n\n      g_free (messages);\n    }\n\n  buffer->pos += res;\n  return TRUE;\n}\n\nstatic gboolean\nbuffer_write (ProxySide *side,\n              Buffer    *buffer,\n              GSocket   *socket)\n{\n  gssize res;\n  GOutputVector v;\n  GError *error = NULL;\n  GSocketControlMessage **messages = NULL;\n  int i, n_messages;\n  GList *l;\n\n  if (buffer->send_credentials &&\n      G_IS_UNIX_CONNECTION (side->connection))\n    {\n      g_assert (buffer->size == 1);\n\n      if (!g_unix_connection_send_credentials (G_UNIX_CONNECTION (side->connection),\n                                               NULL,\n                                               &error))\n        {\n          if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK))\n            {\n              g_error_free (error);\n              return FALSE;\n            }\n\n          g_warning (\"Error writing credentials to socket: %s\", error->message);\n          g_error_free (error);\n\n          side_closed (side);\n          return FALSE;\n        }\n\n      buffer->pos = 1;\n      return TRUE;\n    }\n\n  n_messages = g_list_length (buffer->control_messages);\n  messages = g_new (GSocketControlMessage *, n_messages);\n  for (l = buffer->control_messages, i = 0; l != NULL; l = l->next, i++)\n    messages[i] = l->data;\n\n  v.buffer = &buffer->data[buffer->pos];\n  v.size = buffer->size - buffer->pos;\n\n  res = g_socket_send_message (socket, NULL, &v, 1,\n                               messages, n_messages,\n                               G_SOCKET_MSG_NONE, NULL, &error);\n  g_free (messages);\n  if (res < 0 && g_error_matches (error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK))\n    {\n      g_error_free (error);\n      return FALSE;\n    }\n\n  if (res <= 0)\n    {\n      if (res < 0)\n        {\n          g_warning (\"Error writing credentials to socket: %s\", error->message);\n          g_error_free (error);\n        }\n\n      side_closed (side);\n      return FALSE;\n    }\n\n  g_list_free_full (buffer->control_messages, g_object_unref);\n  buffer->control_messages = NULL;\n\n  buffer->pos += res;\n  return TRUE;\n}\n\nstatic gboolean\nside_out_cb (GSocket *socket, GIOCondition condition, gpointer user_data)\n{\n  ProxySide *side = user_data;\n  FlatpakProxyClient *client = side->client;\n  gboolean retval = G_SOURCE_CONTINUE;\n\n  g_object_ref (client);\n\n  while (side->buffers)\n    {\n      Buffer *buffer = side->buffers->data;\n\n      if (buffer_write (side, buffer, socket))\n        {\n          if (buffer->pos == buffer->size)\n            {\n              side->buffers = g_list_delete_link (side->buffers, side->buffers);\n              buffer_unref (buffer);\n            }\n        }\n      else\n        {\n          break;\n        }\n    }\n\n  if (side->buffers == NULL)\n    {\n      ProxySide *other_side = get_other_side (side);\n\n      side->out_source = NULL;\n      retval = G_SOURCE_REMOVE;\n\n      if (other_side->closed)\n        side_closed (side);\n    }\n\n  g_object_unref (client);\n\n  return retval;\n}\n\nstatic void\nqueue_expected_reply (ProxySide *side, guint32 serial, ExpectedReplyType type)\n{\n  g_hash_table_replace (side->expected_replies,\n                        GUINT_TO_POINTER (serial),\n                        GUINT_TO_POINTER (type));\n}\n\nstatic ExpectedReplyType\nsteal_expected_reply (ProxySide *side, guint32 serial)\n{\n  ExpectedReplyType type;\n\n  type = GPOINTER_TO_UINT (g_hash_table_lookup (side->expected_replies,\n                                                GUINT_TO_POINTER (serial)));\n  if (type)\n    g_hash_table_remove (side->expected_replies,\n                         GUINT_TO_POINTER (serial));\n  return type;\n}\n\n\nstatic void\nqueue_outgoing_buffer (ProxySide *side, Buffer *buffer)\n{\n  if (side->out_source == NULL)\n    {\n      GSocket *socket;\n\n      socket = g_socket_connection_get_socket (side->connection);\n      side->out_source = g_socket_create_source (socket, G_IO_OUT, NULL);\n      g_source_set_callback (side->out_source, (GSourceFunc) side_out_cb, side, NULL);\n      g_source_attach (side->out_source, NULL);\n      g_source_unref (side->out_source);\n    }\n\n  buffer->pos = 0;\n  side->buffers = g_list_append (side->buffers, buffer);\n}\n\nstatic guint32\nread_uint32 (Header *header, guint8 *ptr)\n{\n  if (header->big_endian)\n    return GUINT32_FROM_BE (*(guint32 *) ptr);\n  else\n    return GUINT32_FROM_LE (*(guint32 *) ptr);\n}\n\nstatic void\nwrite_uint32 (Header *header, guint8 *ptr, guint32 val)\n{\n  if (header->big_endian)\n    *(guint32 *) ptr = GUINT32_TO_BE (val);\n  else\n    *(guint32 *) ptr = GUINT32_TO_LE (val);\n}\n\nstatic inline guint32\nalign_by_8 (guint32 offset)\n{\n  return (offset + 8 - 1) & ~(8 - 1);\n}\n\nstatic inline guint32\nalign_by_4 (guint32 offset)\n{\n  return (offset + 4 - 1) & ~(4 - 1);\n}\n\nstatic const char *\nget_signature (Buffer *buffer, guint32 *offset, guint32 end_offset)\n{\n  guint8 len;\n  char *str;\n\n  if (*offset >= end_offset)\n    return FALSE;\n\n  len = buffer->data[*offset];\n  (*offset)++;\n\n  if ((*offset) + len + 1 > end_offset)\n    return FALSE;\n\n  if (buffer->data[(*offset) + len] != 0)\n    return FALSE;\n\n  str = (char *) &buffer->data[(*offset)];\n  *offset += len + 1;\n\n  return str;\n}\n\nstatic const char *\nget_string (Buffer *buffer, Header *header, guint32 *offset, guint32 end_offset)\n{\n  guint8 len;\n  char *str;\n\n  *offset = align_by_4 (*offset);\n  if (*offset + 4  >= end_offset)\n    return FALSE;\n\n  len = read_uint32 (header, &buffer->data[*offset]);\n  *offset += 4;\n\n  if ((*offset) + len + 1 > end_offset)\n    return FALSE;\n\n  if (buffer->data[(*offset) + len] != 0)\n    return FALSE;\n\n  str = (char *) &buffer->data[(*offset)];\n  *offset += len + 1;\n\n  return str;\n}\n\nstatic void\nheader_free (Header *header)\n{\n  if (header->buffer)\n    buffer_unref (header->buffer);\n  g_free (header);\n}\n\nstatic Header *\nparse_header (Buffer *buffer, guint32 serial_offset, guint32 reply_serial_offset, guint32 hello_serial)\n{\n  guint32 array_len, header_len;\n  guint32 offset, end_offset;\n  guint8 header_type;\n  guint32 reply_serial_pos = 0;\n  const char *signature;\n  g_autoptr(Header) header = g_new0 (Header, 1);\n\n  header->buffer = buffer_ref (buffer);\n\n  if (buffer->size < 16)\n    return NULL;\n\n  if (buffer->data[3] != 1) /* Protocol version */\n    return NULL;\n\n  if (buffer->data[0] == 'B')\n    header->big_endian = TRUE;\n  else if (buffer->data[0] == 'l')\n    header->big_endian = FALSE;\n  else\n    return NULL;\n\n  header->type = buffer->data[1];\n  header->flags = buffer->data[2];\n\n  header->length = read_uint32 (header, &buffer->data[4]);\n  header->serial = read_uint32 (header, &buffer->data[8]);\n\n  if (header->serial == 0)\n    return NULL;\n\n  array_len = read_uint32 (header, &buffer->data[12]);\n\n  header_len = align_by_8 (12 + 4 + array_len);\n  g_assert (buffer->size >= header_len); /* We should have verified this when reading in the message */\n  if (header_len > buffer->size)\n    return NULL;\n\n  offset = 12 + 4;\n  end_offset = offset + array_len;\n\n  while (offset < end_offset)\n    {\n      offset = align_by_8 (offset); /* Structs must be 8 byte aligned */\n      if (offset >= end_offset)\n        return NULL;\n\n      header_type = buffer->data[offset++];\n      if (offset >= end_offset)\n        return NULL;\n\n      signature = get_signature (buffer, &offset, end_offset);\n      if (signature == NULL)\n        return NULL;\n\n      switch (header_type)\n        {\n        case G_DBUS_MESSAGE_HEADER_FIELD_INVALID:\n          return NULL;\n\n        case G_DBUS_MESSAGE_HEADER_FIELD_PATH:\n          if (strcmp (signature, \"o\") != 0)\n            return NULL;\n          header->path = get_string (buffer, header, &offset, end_offset);\n          if (header->path == NULL)\n            return NULL;\n          break;\n\n        case G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE:\n          if (strcmp (signature, \"s\") != 0)\n            return NULL;\n          header->interface = get_string (buffer, header, &offset, end_offset);\n          if (header->interface == NULL)\n            return NULL;\n          break;\n\n        case G_DBUS_MESSAGE_HEADER_FIELD_MEMBER:\n          if (strcmp (signature, \"s\") != 0)\n            return NULL;\n          header->member = get_string (buffer, header, &offset, end_offset);\n          if (header->member == NULL)\n            return NULL;\n          break;\n\n        case G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME:\n          if (strcmp (signature, \"s\") != 0)\n            return NULL;\n          header->error_name = get_string (buffer, header, &offset, end_offset);\n          if (header->error_name == NULL)\n            return NULL;\n          break;\n\n        case G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL:\n          if (offset + 4 > end_offset)\n            return NULL;\n\n          header->has_reply_serial = TRUE;\n          reply_serial_pos = offset;\n          header->reply_serial = read_uint32 (header, &buffer->data[offset]);\n          offset += 4;\n          break;\n\n        case G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION:\n          if (strcmp (signature, \"s\") != 0)\n            return NULL;\n          header->destination = get_string (buffer, header, &offset, end_offset);\n          if (header->destination == NULL)\n            return NULL;\n          break;\n\n        case G_DBUS_MESSAGE_HEADER_FIELD_SENDER:\n          if (strcmp (signature, \"s\") != 0)\n            return NULL;\n          header->sender = get_string (buffer, header, &offset, end_offset);\n          if (header->sender == NULL)\n            return NULL;\n          break;\n\n        case G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE:\n          if (strcmp (signature, \"g\") != 0)\n            return NULL;\n          header->signature = get_signature (buffer, &offset, end_offset);\n          if (header->signature == NULL)\n            return NULL;\n          break;\n\n        case G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS:\n          if (offset + 4 > end_offset)\n            return NULL;\n\n          header->unix_fds = read_uint32 (header, &buffer->data[offset]);\n          offset += 4;\n          break;\n\n        default:\n          /* Unknown header field, for safety, fail parse */\n          return NULL;\n        }\n    }\n\n  switch (header->type)\n    {\n    case G_DBUS_MESSAGE_TYPE_METHOD_CALL:\n      if (header->path == NULL || header->member == NULL)\n        return NULL;\n      break;\n\n    case G_DBUS_MESSAGE_TYPE_METHOD_RETURN:\n      if (!header->has_reply_serial)\n        return NULL;\n      break;\n\n    case G_DBUS_MESSAGE_TYPE_ERROR:\n      if (header->error_name  == NULL || !header->has_reply_serial)\n        return NULL;\n      break;\n\n    case G_DBUS_MESSAGE_TYPE_SIGNAL:\n      if (header->path == NULL ||\n          header->interface == NULL ||\n          header->member == NULL)\n        return NULL;\n      if (strcmp (header->path, \"/org/freedesktop/DBus/Local\") == 0 ||\n          strcmp (header->interface, \"org.freedesktop.DBus.Local\") == 0)\n        return NULL;\n      break;\n\n    default:\n      /* Unknown message type, for safety, fail parse */\n      return NULL;\n    }\n\n  if (serial_offset > 0)\n    {\n      header->serial += serial_offset;\n      write_uint32 (header, &buffer->data[8], header->serial);\n    }\n\n  if (reply_serial_offset > 0 &&\n      header->has_reply_serial &&\n      header->reply_serial > hello_serial + reply_serial_offset)\n    write_uint32 (header, &buffer->data[reply_serial_pos], header->reply_serial - reply_serial_offset);\n\n  return g_steal_pointer (&header);\n}\n\nstatic void\nprint_outgoing_header (Header *header)\n{\n  switch (header->type)\n    {\n    case G_DBUS_MESSAGE_TYPE_METHOD_CALL:\n      g_print (\"C%d: -> %s call %s.%s at %s\\n\",\n               header->serial,\n               header->destination ? header->destination : \"(no dest)\",\n               header->interface ? header->interface : \"\",\n               header->member ? header->member : \"\",\n               header->path ? header->path : \"\");\n      break;\n\n    case G_DBUS_MESSAGE_TYPE_METHOD_RETURN:\n      g_print (\"C%d: -> %s return from B%d\\n\",\n               header->serial,\n               header->destination ? header->destination : \"(no dest)\",\n               header->reply_serial);\n      break;\n\n    case G_DBUS_MESSAGE_TYPE_ERROR:\n      g_print (\"C%d: -> %s return error %s from B%d\\n\",\n               header->serial,\n               header->destination ? header->destination : \"(no dest)\",\n               header->error_name ? header->error_name : \"(no error)\",\n               header->reply_serial);\n      break;\n\n    case G_DBUS_MESSAGE_TYPE_SIGNAL:\n      g_print (\"C%d: -> %s signal %s.%s at %s\\n\",\n               header->serial,\n               header->destination ? header->destination : \"all\",\n               header->interface ? header->interface : \"\",\n               header->member ? header->member : \"\",\n               header->path ? header->path : \"\");\n      break;\n\n    default:\n      g_print (\"unknown message type\\n\");\n    }\n}\n\nstatic void\nprint_incoming_header (Header *header)\n{\n  switch (header->type)\n    {\n    case G_DBUS_MESSAGE_TYPE_METHOD_CALL:\n      g_print (\"B%d: <- %s call %s.%s at %s\\n\",\n               header->serial,\n               header->sender ? header->sender : \"(no sender)\",\n               header->interface ? header->interface : \"\",\n               header->member ? header->member : \"\",\n               header->path ? header->path : \"\");\n      break;\n\n    case G_DBUS_MESSAGE_TYPE_METHOD_RETURN:\n      g_print (\"B%d: <- %s return from C%d\\n\",\n               header->serial,\n               header->sender ? header->sender : \"(no sender)\",\n               header->reply_serial);\n      break;\n\n    case G_DBUS_MESSAGE_TYPE_ERROR:\n      g_print (\"B%d: <- %s return error %s from C%d\\n\",\n               header->serial,\n               header->sender ? header->sender : \"(no sender)\",\n               header->error_name ? header->error_name : \"(no error)\",\n               header->reply_serial);\n      break;\n\n    case G_DBUS_MESSAGE_TYPE_SIGNAL:\n      g_print (\"B%d: <- %s signal %s.%s at %s\\n\",\n               header->serial,\n               header->sender ? header->sender : \"(no sender)\",\n               header->interface ? header->interface : \"\",\n               header->member ? header->member : \"\",\n               header->path ? header->path : \"\");\n      break;\n\n    default:\n      g_print (\"unknown message type\\n\");\n    }\n}\n\nstatic FlatpakPolicy\nflatpak_proxy_client_get_policy (FlatpakProxyClient *client, const char *source)\n{\n  if (source == NULL)\n    return FLATPAK_POLICY_TALK; /* All clients can talk to the bus itself */\n\n  if (source[0] == ':')\n    return GPOINTER_TO_UINT (g_hash_table_lookup (client->unique_id_policy, source));\n\n  return flatpak_proxy_get_policy (client->proxy, source);\n}\n\nstatic void\nflatpak_proxy_client_update_unique_id_policy (FlatpakProxyClient *client,\n                                              const char         *unique_id,\n                                              FlatpakPolicy       policy)\n{\n  if (policy > FLATPAK_POLICY_NONE)\n    {\n      FlatpakPolicy old_policy;\n      old_policy = GPOINTER_TO_UINT (g_hash_table_lookup (client->unique_id_policy, unique_id));\n      if (policy > old_policy)\n        g_hash_table_replace (client->unique_id_policy, g_strdup (unique_id), GINT_TO_POINTER (policy));\n    }\n}\n\nstatic void\nflatpak_proxy_client_update_unique_id_policy_from_name (FlatpakProxyClient *client,\n                                                        const char         *unique_id,\n                                                        const char         *as_name)\n{\n  flatpak_proxy_client_update_unique_id_policy (client,\n                                                unique_id,\n                                                flatpak_proxy_get_policy (client->proxy, as_name));\n}\n\n\nstatic gboolean\nclient_message_generates_reply (Header *header)\n{\n  switch (header->type)\n    {\n    case G_DBUS_MESSAGE_TYPE_METHOD_CALL:\n      return (header->flags & G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED) == 0;\n\n    case G_DBUS_MESSAGE_TYPE_SIGNAL:\n    case G_DBUS_MESSAGE_TYPE_METHOD_RETURN:\n    case G_DBUS_MESSAGE_TYPE_ERROR:\n    default:\n      return FALSE;\n    }\n}\n\nstatic Buffer *\nmessage_to_buffer (GDBusMessage *message)\n{\n  Buffer *buffer;\n  guchar *blob;\n  gsize blob_size;\n\n  blob = g_dbus_message_to_blob (message, &blob_size, G_DBUS_CAPABILITY_FLAGS_NONE, NULL);\n  buffer = buffer_new (blob_size, NULL);\n  memcpy (buffer->data, blob, blob_size);\n  g_free (blob);\n\n  return buffer;\n}\n\nstatic GDBusMessage *\nget_error_for_header (FlatpakProxyClient *client, Header *header, const char *error)\n{\n  GDBusMessage *reply;\n\n  reply = g_dbus_message_new ();\n  g_dbus_message_set_message_type (reply, G_DBUS_MESSAGE_TYPE_ERROR);\n  g_dbus_message_set_flags (reply, G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED);\n  g_dbus_message_set_reply_serial (reply, header->serial - client->serial_offset);\n  g_dbus_message_set_error_name (reply, error);\n  g_dbus_message_set_body (reply, g_variant_new (\"(s)\", error));\n\n  return reply;\n}\n\nstatic GDBusMessage *\nget_bool_reply_for_header (FlatpakProxyClient *client, Header *header, gboolean val)\n{\n  GDBusMessage *reply;\n\n  reply = g_dbus_message_new ();\n  g_dbus_message_set_message_type (reply, G_DBUS_MESSAGE_TYPE_METHOD_RETURN);\n  g_dbus_message_set_flags (reply, G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED);\n  g_dbus_message_set_reply_serial (reply, header->serial - client->serial_offset);\n  g_dbus_message_set_body (reply, g_variant_new (\"(b)\", val));\n\n  return reply;\n}\n\nstatic Buffer *\nget_ping_buffer_for_header (Header *header)\n{\n  Buffer *buffer;\n  GDBusMessage *dummy;\n\n  dummy = g_dbus_message_new_method_call (NULL, \"/\", \"org.freedesktop.DBus.Peer\", \"Ping\");\n  g_dbus_message_set_serial (dummy, header->serial);\n  g_dbus_message_set_flags (dummy, header->flags);\n\n  buffer = message_to_buffer (dummy);\n\n  g_object_unref (dummy);\n\n  return buffer;\n}\n\nstatic Buffer *\nget_error_for_roundtrip (FlatpakProxyClient *client, Header *header, const char *error_name)\n{\n  Buffer *ping_buffer = get_ping_buffer_for_header (header);\n  GDBusMessage *reply;\n\n  reply = get_error_for_header (client, header, error_name);\n  g_hash_table_replace (client->rewrite_reply, GINT_TO_POINTER (header->serial), reply);\n  return ping_buffer;\n}\n\nstatic Buffer *\nget_bool_reply_for_roundtrip (FlatpakProxyClient *client, Header *header, gboolean val)\n{\n  Buffer *ping_buffer = get_ping_buffer_for_header (header);\n  GDBusMessage *reply;\n\n  reply = get_bool_reply_for_header (client, header, val);\n  g_hash_table_replace (client->rewrite_reply, GINT_TO_POINTER (header->serial), reply);\n\n  return ping_buffer;\n}\n\ntypedef enum {\n  HANDLE_PASS,\n  HANDLE_DENY,\n  HANDLE_HIDE,\n  HANDLE_FILTER_NAME_LIST_REPLY,\n  HANDLE_FILTER_HAS_OWNER_REPLY,\n  HANDLE_FILTER_GET_OWNER_REPLY,\n  HANDLE_VALIDATE_OWN,\n  HANDLE_VALIDATE_SEE,\n  HANDLE_VALIDATE_TALK,\n  HANDLE_VALIDATE_MATCH,\n} BusHandler;\n\nstatic gboolean\nis_for_bus (Header *header)\n{\n  return g_strcmp0 (header->destination, \"org.freedesktop.DBus\") == 0;\n}\n\nstatic gboolean\nis_dbus_method_call (Header *header)\n{\n  return\n    is_for_bus (header) &&\n    header->type == G_DBUS_MESSAGE_TYPE_METHOD_CALL &&\n    g_strcmp0 (header->interface, \"org.freedesktop.DBus\") == 0;\n}\n\nstatic gboolean\nis_introspection_call (Header *header)\n{\n  return\n    header->type == G_DBUS_MESSAGE_TYPE_METHOD_CALL &&\n    g_strcmp0 (header->interface, \"org.freedesktop.DBus.Introspectable\") == 0;\n}\n\nstatic BusHandler\nget_dbus_method_handler (FlatpakProxyClient *client, Header *header)\n{\n  FlatpakPolicy policy;\n  const char *method;\n\n  if (header->has_reply_serial)\n    {\n      ExpectedReplyType expected_reply =\n        steal_expected_reply (&client->bus_side,\n                              header->reply_serial);\n      if (expected_reply == EXPECTED_REPLY_NONE)\n        return HANDLE_DENY;\n\n      return HANDLE_PASS;\n    }\n\n  policy = flatpak_proxy_client_get_policy (client, header->destination);\n  if (policy < FLATPAK_POLICY_SEE)\n    return HANDLE_HIDE;\n  if (policy < FLATPAK_POLICY_FILTERED)\n    return HANDLE_DENY;\n\n  if (policy == FLATPAK_POLICY_FILTERED)\n    {\n      GList *filters = NULL, *l;\n\n      if (header->destination)\n        filters = g_hash_table_lookup (client->proxy->filters, header->destination);\n      for (l = filters; l != NULL; l = l->next)\n        {\n          Filter *filter = l->data;\n\n          if (header->type == G_DBUS_MESSAGE_TYPE_METHOD_CALL &&\n              (filter->path == NULL || g_strcmp0 (filter->path, header->path) == 0) &&\n              (filter->interface == NULL || g_strcmp0 (filter->interface, header->interface) == 0) &&\n              (filter->member == NULL || g_strcmp0 (filter->member, header->member) == 0))\n            return HANDLE_PASS;\n        }\n\n      return HANDLE_DENY;\n    }\n\n  if (!is_for_bus (header))\n    return HANDLE_PASS;\n\n  if (is_introspection_call (header))\n    {\n      return HANDLE_PASS;\n    }\n  else if (is_dbus_method_call (header))\n    {\n      method = header->member;\n      if (method == NULL)\n        return HANDLE_DENY;\n\n      if (strcmp (method, \"AddMatch\") == 0)\n        return HANDLE_VALIDATE_MATCH;\n\n      if (strcmp (method, \"Hello\") == 0 ||\n          strcmp (method, \"RemoveMatch\") == 0 ||\n          strcmp (method, \"GetId\") == 0)\n        return HANDLE_PASS;\n\n      if (strcmp (method, \"UpdateActivationEnvironment\") == 0 ||\n          strcmp (method, \"BecomeMonitor\") == 0)\n        return HANDLE_DENY;\n\n      if (strcmp (method, \"RequestName\") == 0 ||\n          strcmp (method, \"ReleaseName\") == 0 ||\n          strcmp (method, \"ListQueuedOwners\") == 0)\n        return HANDLE_VALIDATE_OWN;\n\n      if (strcmp (method, \"NameHasOwner\") == 0)\n        return HANDLE_FILTER_HAS_OWNER_REPLY;\n\n      if (strcmp (method, \"GetNameOwner\") == 0)\n        return HANDLE_FILTER_GET_OWNER_REPLY;\n\n      if (strcmp (method, \"GetConnectionUnixProcessID\") == 0 ||\n          strcmp (method, \"GetConnectionCredentials\") == 0 ||\n          strcmp (method, \"GetAdtAuditSessionData\") == 0 ||\n          strcmp (method, \"GetConnectionSELinuxSecurityContext\") == 0 ||\n          strcmp (method, \"GetConnectionUnixUser\") == 0)\n        return HANDLE_VALIDATE_SEE;\n\n      if (strcmp (method, \"StartServiceByName\") == 0)\n        return HANDLE_VALIDATE_TALK;\n\n      if (strcmp (method, \"ListNames\") == 0 ||\n          strcmp (method, \"ListActivatableNames\") == 0)\n        return HANDLE_FILTER_NAME_LIST_REPLY;\n\n      g_warning (\"Unknown bus method %s\", method);\n      return HANDLE_DENY;\n    }\n  else\n    {\n      return HANDLE_DENY;\n    }\n}\n\nstatic FlatpakPolicy\npolicy_from_handler (BusHandler handler)\n{\n  switch (handler)\n    {\n    case HANDLE_VALIDATE_OWN:\n      return FLATPAK_POLICY_OWN;\n\n    case HANDLE_VALIDATE_TALK:\n      return FLATPAK_POLICY_TALK;\n\n    case HANDLE_VALIDATE_SEE:\n      return FLATPAK_POLICY_SEE;\n\n    default:\n      return FLATPAK_POLICY_NONE;\n    }\n}\n\nstatic char *\nget_arg0_string (Buffer *buffer)\n{\n  GDBusMessage *message = g_dbus_message_new_from_blob (buffer->data, buffer->size, 0, NULL);\n  GVariant *body;\n  g_autoptr(GVariant) arg0 = NULL;\n  char *name = NULL;\n\n  if (message != NULL &&\n      (body = g_dbus_message_get_body (message)) != NULL &&\n      (arg0 = g_variant_get_child_value (body, 0)) != NULL &&\n      g_variant_is_of_type (arg0, G_VARIANT_TYPE_STRING))\n    name = g_variant_dup_string (arg0, NULL);\n\n  g_object_unref (message);\n\n  return name;\n}\n\nstatic gboolean\nvalidate_arg0_match (FlatpakProxyClient *client, Buffer *buffer)\n{\n  GDBusMessage *message = g_dbus_message_new_from_blob (buffer->data, buffer->size, 0, NULL);\n  GVariant *body, *arg0;\n  const char *match;\n  gboolean res = TRUE;\n\n  if (message != NULL &&\n      (body = g_dbus_message_get_body (message)) != NULL &&\n      (arg0 = g_variant_get_child_value (body, 0)) != NULL &&\n      g_variant_is_of_type (arg0, G_VARIANT_TYPE_STRING))\n    {\n      match = g_variant_get_string (arg0, NULL);\n      if (strstr (match, \"eavesdrop=\") != NULL)\n        res = FALSE;\n    }\n\n  g_object_unref (message);\n  return res;\n}\n\nstatic gboolean\nvalidate_arg0_name (FlatpakProxyClient *client, Buffer *buffer, FlatpakPolicy required_policy, FlatpakPolicy *has_policy)\n{\n  GDBusMessage *message = g_dbus_message_new_from_blob (buffer->data, buffer->size, 0, NULL);\n  GVariant *body, *arg0;\n  const char *name;\n  FlatpakPolicy name_policy;\n  gboolean res = FALSE;\n\n  if (has_policy)\n    *has_policy = FLATPAK_POLICY_NONE;\n\n  if (message != NULL &&\n      (body = g_dbus_message_get_body (message)) != NULL &&\n      (arg0 = g_variant_get_child_value (body, 0)) != NULL &&\n      g_variant_is_of_type (arg0, G_VARIANT_TYPE_STRING))\n    {\n      name = g_variant_get_string (arg0, NULL);\n      name_policy = flatpak_proxy_client_get_policy (client, name);\n\n      if (has_policy)\n        *has_policy = name_policy;\n\n      if (name_policy >= required_policy)\n        res = TRUE;\n      else if (client->proxy->log_messages)\n        g_print (\"Filtering message due to arg0 %s, policy: %d (required %d)\\n\", name, name_policy, required_policy);\n    }\n\n  g_object_unref (message);\n  return res;\n}\n\nstatic Buffer *\nfilter_names_list (FlatpakProxyClient *client, Buffer *buffer)\n{\n  GDBusMessage *message = g_dbus_message_new_from_blob (buffer->data, buffer->size, 0, NULL);\n  GVariant *body, *arg0, *new_names;\n  const gchar **names;\n  int i;\n  GVariantBuilder builder;\n  Buffer *filtered;\n\n  if (message == NULL ||\n      (body = g_dbus_message_get_body (message)) == NULL ||\n      (arg0 = g_variant_get_child_value (body, 0)) == NULL ||\n      !g_variant_is_of_type (arg0, G_VARIANT_TYPE_STRING_ARRAY))\n    return NULL;\n\n  names = g_variant_get_strv (arg0, NULL);\n\n  g_variant_builder_init (&builder, G_VARIANT_TYPE_STRING_ARRAY);\n  for (i = 0; names[i] != NULL; i++)\n    {\n      if (flatpak_proxy_client_get_policy (client, names[i]) >= FLATPAK_POLICY_SEE)\n        g_variant_builder_add (&builder, \"s\", names[i]);\n    }\n  g_free (names);\n\n  new_names = g_variant_builder_end (&builder);\n  g_dbus_message_set_body (message,\n                           g_variant_new_tuple (&new_names, 1));\n\n  filtered = message_to_buffer (message);\n  g_object_unref (message);\n  return filtered;\n}\n\nstatic gboolean\nmessage_is_name_owner_changed (FlatpakProxyClient *client, Header *header)\n{\n  if (header->type == G_DBUS_MESSAGE_TYPE_SIGNAL &&\n      g_strcmp0 (header->sender, \"org.freedesktop.DBus\") == 0 &&\n      g_strcmp0 (header->interface, \"org.freedesktop.DBus\") == 0 &&\n      g_strcmp0 (header->member, \"NameOwnerChanged\") == 0)\n    return TRUE;\n  return FALSE;\n}\n\nstatic gboolean\nshould_filter_name_owner_changed (FlatpakProxyClient *client, Buffer *buffer)\n{\n  GDBusMessage *message = g_dbus_message_new_from_blob (buffer->data, buffer->size, 0, NULL);\n  GVariant *body, *arg0, *arg1, *arg2;\n  const gchar *name, *old, *new;\n  gboolean filter = TRUE;\n\n  if (message == NULL ||\n      (body = g_dbus_message_get_body (message)) == NULL ||\n      (arg0 = g_variant_get_child_value (body, 0)) == NULL ||\n      !g_variant_is_of_type (arg0, G_VARIANT_TYPE_STRING) ||\n      (arg1 = g_variant_get_child_value (body, 1)) == NULL ||\n      !g_variant_is_of_type (arg1, G_VARIANT_TYPE_STRING) ||\n      (arg2 = g_variant_get_child_value (body, 2)) == NULL ||\n      !g_variant_is_of_type (arg2, G_VARIANT_TYPE_STRING))\n    return TRUE;\n\n  name = g_variant_get_string (arg0, NULL);\n  old = g_variant_get_string (arg1, NULL);\n  new = g_variant_get_string (arg2, NULL);\n\n  if (flatpak_proxy_client_get_policy (client, name) >= FLATPAK_POLICY_SEE ||\n      (client->proxy->sloppy_names && name[0] == ':'))\n    {\n      if (name[0] != ':')\n        {\n          if (old[0] != 0)\n            flatpak_proxy_client_update_unique_id_policy_from_name (client, old, name);\n\n          if (new[0] != 0)\n            flatpak_proxy_client_update_unique_id_policy_from_name (client, new, name);\n        }\n\n      filter = FALSE;\n    }\n\n  g_object_unref (message);\n\n  return filter;\n}\n\nstatic GList *\nside_get_n_unix_fds (ProxySide *side, int n_fds)\n{\n  GList *res = NULL;\n\n  while (side->control_messages != NULL)\n    {\n      GSocketControlMessage *control_message = side->control_messages->data;\n\n      if (G_IS_UNIX_FD_MESSAGE (control_message))\n        {\n          GUnixFDMessage *fd_message = G_UNIX_FD_MESSAGE (control_message);\n          GUnixFDList *fd_list = g_unix_fd_message_get_fd_list (fd_message);\n          int len = g_unix_fd_list_get_length (fd_list);\n\n          /* I believe that socket control messages are never merged, and\n             the sender side sends only one unix-fd-list per message, so\n             at this point there should always be one full fd list\n             per requested number of fds */\n          if (len != n_fds)\n            {\n              g_warning (\"Not right nr of fds in socket message\");\n              return NULL;\n            }\n\n          side->control_messages = g_list_delete_link (side->control_messages, side->control_messages);\n\n          return g_list_append (NULL, control_message);\n        }\n\n      g_object_unref (control_message);\n      side->control_messages = g_list_delete_link (side->control_messages, side->control_messages);\n    }\n\n  return res;\n}\n\nstatic gboolean\nupdate_socket_messages (ProxySide *side, Buffer *buffer, Header *header)\n{\n  /* We may accidentally combine multiple control messages into one\n     buffer when we receive (since we can do several recvs), so we\n     keep a list of all we get and then only re-attach the amount\n     specified in the header to the buffer. */\n\n  side->control_messages = g_list_concat (side->control_messages, buffer->control_messages);\n  buffer->control_messages = NULL;\n  if (header->unix_fds > 0)\n    {\n      buffer->control_messages = side_get_n_unix_fds (side, header->unix_fds);\n      if (buffer->control_messages == NULL)\n        {\n          g_warning (\"Not enough fds for message\");\n          side_closed (side);\n          buffer_unref (buffer);\n          return FALSE;\n        }\n    }\n  return TRUE;\n}\n\nstatic void\nqueue_fake_message (FlatpakProxyClient *client, GDBusMessage *message, ExpectedReplyType reply_type)\n{\n  Buffer *buffer;\n\n  client->last_serial++;\n  client->serial_offset++;\n  g_dbus_message_set_serial (message, client->last_serial);\n  buffer = message_to_buffer (message);\n  g_object_unref (message);\n\n  queue_outgoing_buffer (&client->bus_side, buffer);\n  queue_expected_reply (&client->client_side, client->last_serial, reply_type);\n}\n\n/* After the first Hello message we need to synthesize a bunch of messages to synchronize the\n   ownership state for the names in the policy */\nstatic void\nqueue_initial_name_ops (FlatpakProxyClient *client)\n{\n  GHashTableIter iter;\n  gpointer key, value;\n  gboolean has_wildcards = FALSE;\n\n  g_hash_table_iter_init (&iter, client->proxy->policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char *name = key;\n      GDBusMessage *message;\n      GVariant *match;\n\n      if (strcmp (name, \"org.freedesktop.DBus\") == 0)\n        continue;\n\n      /* AddMatch the name so we get told about ownership changes.\n         Do it before the GetNameOwner to avoid races */\n      message = g_dbus_message_new_method_call (\"org.freedesktop.DBus\", \"/\", \"org.freedesktop.DBus\", \"AddMatch\");\n      match = g_variant_new_printf (\"type='signal',sender='org.freedesktop.DBus',interface='org.freedesktop.DBus',member='NameOwnerChanged',arg0='%s'\", name);\n      g_dbus_message_set_body (message, g_variant_new_tuple (&match, 1));\n      queue_fake_message (client, message, EXPECTED_REPLY_FILTER);\n\n      if (client->proxy->log_messages)\n        g_print (\"C%d: -> org.freedesktop.DBus fake AddMatch for %s\\n\", client->last_serial, name);\n\n      /* Get the current owner of the name (if any) so we can apply policy to it */\n      message = g_dbus_message_new_method_call (\"org.freedesktop.DBus\", \"/\", \"org.freedesktop.DBus\", \"GetNameOwner\");\n      g_dbus_message_set_body (message, g_variant_new (\"(s)\", name));\n      queue_fake_message (client, message, EXPECTED_REPLY_FAKE_GET_NAME_OWNER);\n      g_hash_table_replace (client->get_owner_reply, GINT_TO_POINTER (client->last_serial), g_strdup (name));\n\n      if (client->proxy->log_messages)\n        g_print (\"C%d: -> org.freedesktop.DBus fake GetNameOwner for %s\\n\", client->last_serial, name);\n    }\n\n  /* Same for wildcard proxies. Only here we don't know the actual names to GetNameOwner for, so we have to\n     list all current names */\n  g_hash_table_iter_init (&iter, client->proxy->wildcard_policy);\n  while (g_hash_table_iter_next (&iter, &key, &value))\n    {\n      const char *name = key;\n      GDBusMessage *message;\n      GVariant *match;\n\n      has_wildcards = TRUE;\n\n      /* AddMatch the name with arg0namespace so we get told about ownership changes to all subnames.\n         Do it before the GetNameOwner to avoid races */\n      message = g_dbus_message_new_method_call (\"org.freedesktop.DBus\", \"/\", \"org.freedesktop.DBus\", \"AddMatch\");\n      match = g_variant_new_printf (\"type='signal',sender='org.freedesktop.DBus',interface='org.freedesktop.DBus',member='NameOwnerChanged',arg0namespace='%s'\", name);\n      g_dbus_message_set_body (message, g_variant_new_tuple (&match, 1));\n      queue_fake_message (client, message, EXPECTED_REPLY_FILTER);\n\n      if (client->proxy->log_messages)\n        g_print (\"C%d: -> org.freedesktop.DBus fake AddMatch for %s.*\\n\", client->last_serial, name);\n    }\n\n  if (has_wildcards)\n    {\n      GDBusMessage *message;\n\n      /* AddMatch the name so we get told about ownership changes.\n         Do it before the GetNameOwner to avoid races */\n      message = g_dbus_message_new_method_call (\"org.freedesktop.DBus\", \"/\", \"org.freedesktop.DBus\", \"ListNames\");\n      g_dbus_message_set_body (message, g_variant_new (\"()\"));\n      queue_fake_message (client, message, EXPECTED_REPLY_FAKE_LIST_NAMES);\n\n      if (client->proxy->log_messages)\n        g_print (\"C%d: -> org.freedesktop.DBus fake ListNames\\n\", client->last_serial);\n\n      /* Stop reading from the client, to avoid incoming messages fighting with the ListNames roundtrip.\n         We will start it again once we have handled the ListNames reply */\n      stop_reading (&client->client_side);\n    }\n}\n\nstatic void\nqueue_wildcard_initial_name_ops (FlatpakProxyClient *client, Header *header, Buffer *buffer)\n{\n  GDBusMessage *decoded_message = g_dbus_message_new_from_blob (buffer->data, buffer->size, 0, NULL);\n  GVariant *body, *arg0;\n\n  if (decoded_message != NULL &&\n      header->type == G_DBUS_MESSAGE_TYPE_METHOD_RETURN &&\n      (body = g_dbus_message_get_body (decoded_message)) != NULL &&\n      (arg0 = g_variant_get_child_value (body, 0)) != NULL &&\n      g_variant_is_of_type (arg0, G_VARIANT_TYPE_STRING_ARRAY))\n    {\n      const gchar **names = g_variant_get_strv (arg0, NULL);\n      int i;\n\n      /* Loop over all current names and get the owner for all the ones that match our wildcard\n         policies so that we can update the unique id policies for those */\n      for (i = 0; names[i] != NULL; i++)\n        {\n          const char *name = names[i];\n\n          if (name[0] != ':' &&\n              flatpak_proxy_get_wildcard_policy (client->proxy, name) != FLATPAK_POLICY_NONE)\n            {\n              /* Get the current owner of the name (if any) so we can apply policy to it */\n              GDBusMessage *message = g_dbus_message_new_method_call (\"org.freedesktop.DBus\", \"/\", \"org.freedesktop.DBus\", \"GetNameOwner\");\n              g_dbus_message_set_body (message, g_variant_new (\"(s)\", name));\n              queue_fake_message (client, message, EXPECTED_REPLY_FAKE_GET_NAME_OWNER);\n              g_hash_table_replace (client->get_owner_reply, GINT_TO_POINTER (client->last_serial), g_strdup (name));\n\n              if (client->proxy->log_messages)\n                g_print (\"C%d: -> org.freedesktop.DBus fake GetNameOwner for %s\\n\", client->last_serial, name);\n            }\n        }\n      g_free (names);\n    }\n\n  g_object_unref (decoded_message);\n}\n\n\nstatic void\ngot_buffer_from_client (FlatpakProxyClient *client, ProxySide *side, Buffer *buffer)\n{\n  ExpectedReplyType expecting_reply = EXPECTED_REPLY_NONE;\n\n  if (client->authenticated && client->proxy->filter)\n    {\n      g_autoptr(Header) header = NULL;;\n      BusHandler handler;\n\n      /* Filter and rewrite outgoing messages as needed */\n\n      header = parse_header (buffer, client->serial_offset, 0, 0);\n      if (header == NULL)\n        {\n          g_warning (\"Invalid message header format\");\n          side_closed (side);\n          buffer_unref (buffer);\n          return;\n        }\n\n      if (!update_socket_messages (side, buffer, header))\n        return;\n\n      /* Make sure the client is not playing games with the serials, as that\n         could confuse us. */\n      if (header->serial <= client->last_serial)\n        {\n          g_warning (\"Invalid client serial\");\n          side_closed (side);\n          buffer_unref (buffer);\n          return;\n        }\n      client->last_serial = header->serial;\n\n      if (client->proxy->log_messages)\n        print_outgoing_header (header);\n\n      /* Keep track of the initial Hello request so that we can read\n         the reply which has our assigned unique id */\n      if (is_dbus_method_call (header) &&\n          g_strcmp0 (header->member, \"Hello\") == 0)\n        {\n          expecting_reply = EXPECTED_REPLY_HELLO;\n          client->hello_serial = header->serial;\n        }\n\n      handler = get_dbus_method_handler (client, header);\n\n      switch (handler)\n        {\n        case HANDLE_FILTER_HAS_OWNER_REPLY:\n        case HANDLE_FILTER_GET_OWNER_REPLY:\n          if (!validate_arg0_name (client, buffer, FLATPAK_POLICY_SEE, NULL))\n            {\n              g_clear_pointer (&buffer, buffer_unref);\n              if (handler == HANDLE_FILTER_GET_OWNER_REPLY)\n                buffer = get_error_for_roundtrip (client, header,\n                                                  \"org.freedesktop.DBus.Error.NameHasNoOwner\");\n              else\n                buffer = get_bool_reply_for_roundtrip (client, header, FALSE);\n\n              expecting_reply = EXPECTED_REPLY_REWRITE;\n              break;\n            }\n\n          goto handle_pass;\n\n        case HANDLE_VALIDATE_MATCH:\n          if (!validate_arg0_match (client, buffer))\n            {\n              if (client->proxy->log_messages)\n                g_print (\"*DENIED* (ping)\\n\");\n              g_clear_pointer (&buffer, buffer_unref);\n              buffer = get_error_for_roundtrip (client, header,\n                                                \"org.freedesktop.DBus.Error.AccessDenied\");\n              expecting_reply = EXPECTED_REPLY_REWRITE;\n              break;\n            }\n\n          goto handle_pass;\n\n        case HANDLE_VALIDATE_OWN:\n        case HANDLE_VALIDATE_SEE:\n        case HANDLE_VALIDATE_TALK:\n          {\n            FlatpakPolicy name_policy;\n            if (validate_arg0_name (client, buffer, policy_from_handler (handler), &name_policy))\n              goto handle_pass;\n\n            if (name_policy < (int) FLATPAK_POLICY_SEE)\n              goto handle_hide;\n            else\n              goto handle_deny;\n          }\n\n        case HANDLE_FILTER_NAME_LIST_REPLY:\n          expecting_reply = EXPECTED_REPLY_LIST_NAMES;\n          goto handle_pass;\n\n        case HANDLE_PASS:\nhandle_pass:\n          if (client_message_generates_reply (header))\n            {\n              if (expecting_reply == EXPECTED_REPLY_NONE)\n                expecting_reply = EXPECTED_REPLY_NORMAL;\n            }\n\n          break;\n\n        case HANDLE_HIDE:\nhandle_hide:\n          g_clear_pointer (&buffer, buffer_unref);\n\n          if (client_message_generates_reply (header))\n            {\n              const char *error;\n\n              if (client->proxy->log_messages)\n                g_print (\"*HIDDEN* (ping)\\n\");\n\n              if ((header->destination != NULL && header->destination[0] == ':') ||\n                  (header->flags & G_DBUS_MESSAGE_FLAGS_NO_AUTO_START) != 0)\n                error = \"org.freedesktop.DBus.Error.NameHasNoOwner\";\n              else\n                error = \"org.freedesktop.DBus.Error.ServiceUnknown\";\n\n              buffer = get_error_for_roundtrip (client, header, error);\n              expecting_reply = EXPECTED_REPLY_REWRITE;\n            }\n          else\n            {\n              if (client->proxy->log_messages)\n                g_print (\"*HIDDEN*\\n\");\n            }\n          break;\n\n        default:\n        case HANDLE_DENY:\nhandle_deny:\n          g_clear_pointer (&buffer, buffer_unref);\n\n          if (client_message_generates_reply (header))\n            {\n              if (client->proxy->log_messages)\n                g_print (\"*DENIED* (ping)\\n\");\n\n              buffer = get_error_for_roundtrip (client, header,\n                                                \"org.freedesktop.DBus.Error.AccessDenied\");\n              expecting_reply = EXPECTED_REPLY_REWRITE;\n            }\n          else\n            {\n              if (client->proxy->log_messages)\n                g_print (\"*DENIED*\\n\");\n            }\n          break;\n        }\n\n      if (buffer != NULL && expecting_reply != EXPECTED_REPLY_NONE)\n        queue_expected_reply (side, header->serial, expecting_reply);\n    }\n\n  if (buffer)\n    queue_outgoing_buffer (&client->bus_side, buffer);\n\n  if (buffer != NULL && expecting_reply == EXPECTED_REPLY_HELLO)\n    queue_initial_name_ops (client);\n}\n\nstatic void\ngot_buffer_from_bus (FlatpakProxyClient *client, ProxySide *side, Buffer *buffer)\n{\n  if (client->authenticated && client->proxy->filter)\n    {\n      g_autoptr(Header) header = NULL;;\n      GDBusMessage *rewritten;\n      FlatpakPolicy policy;\n      ExpectedReplyType expected_reply;\n\n      /* Filter and rewrite incoming messages as needed */\n\n      header = parse_header (buffer, 0, client->serial_offset, client->hello_serial);\n      if (header == NULL)\n        {\n          g_warning (\"Invalid message header format\");\n          buffer_unref (buffer);\n          side_closed (side);\n          return;\n        }\n\n      if (!update_socket_messages (side, buffer, header))\n        return;\n\n      if (client->proxy->log_messages)\n        print_incoming_header (header);\n\n      if (header->has_reply_serial)\n        {\n          expected_reply = steal_expected_reply (get_other_side (side), header->reply_serial);\n\n          /* We only allow replies we expect */\n          if (expected_reply == EXPECTED_REPLY_NONE)\n            {\n              if (client->proxy->log_messages)\n                g_print (\"*Unexpected reply*\\n\");\n              buffer_unref (buffer);\n              return;\n            }\n\n          switch (expected_reply)\n            {\n            case EXPECTED_REPLY_HELLO:\n              /* When we get the initial reply to Hello, allow all\n                 further communications to our own unique id. */\n              if (header->type == G_DBUS_MESSAGE_TYPE_METHOD_RETURN)\n                {\n                  g_autofree char *my_id = get_arg0_string (buffer);\n                  flatpak_proxy_client_update_unique_id_policy (client, my_id, FLATPAK_POLICY_TALK);\n                  break;\n                }\n\n            case EXPECTED_REPLY_REWRITE:\n              /* Replace a roundtrip ping with the rewritten message */\n\n              rewritten = g_hash_table_lookup (client->rewrite_reply,\n                                               GINT_TO_POINTER (header->reply_serial));\n\n              if (client->proxy->log_messages)\n                g_print (\"*REWRITTEN*\\n\");\n\n              g_dbus_message_set_serial (rewritten, header->serial);\n              g_clear_pointer (&buffer, buffer_unref);\n              buffer = message_to_buffer (rewritten);\n\n              g_hash_table_remove (client->rewrite_reply,\n                                   GINT_TO_POINTER (header->reply_serial));\n              break;\n\n            case EXPECTED_REPLY_FAKE_LIST_NAMES:\n              /* This is a reply from the bus to a fake ListNames\n                 request, request ownership of any name matching a\n                 wildcard policy */\n\n              queue_wildcard_initial_name_ops (client, header, buffer);\n\n              /* Don't forward fake replies to the app */\n              if (client->proxy->log_messages)\n                g_print (\"*SKIPPED*\\n\");\n              g_clear_pointer (&buffer, buffer_unref);\n\n              /* Start reading the clients requests now that we are done with the names */\n              start_reading (&client->client_side);\n              break;\n\n            case EXPECTED_REPLY_FAKE_GET_NAME_OWNER:\n              /* This is a reply from the bus to a fake GetNameOwner\n                 request, update the policy for this unique name based on\n                 the policy */\n              {\n                char *requested_name = g_hash_table_lookup (client->get_owner_reply, GINT_TO_POINTER (header->reply_serial));\n\n                if (header->type == G_DBUS_MESSAGE_TYPE_METHOD_RETURN)\n                  {\n                    g_autofree char *owner = get_arg0_string (buffer);\n                    flatpak_proxy_client_update_unique_id_policy_from_name (client, owner, requested_name);\n                  }\n\n                g_hash_table_remove (client->get_owner_reply, GINT_TO_POINTER (header->reply_serial));\n\n                /* Don't forward fake replies to the app */\n                if (client->proxy->log_messages)\n                  g_print (\"*SKIPPED*\\n\");\n                g_clear_pointer (&buffer, buffer_unref);\n                break;\n              }\n\n            case EXPECTED_REPLY_FILTER:\n              if (client->proxy->log_messages)\n                g_print (\"*SKIPPED*\\n\");\n              g_clear_pointer (&buffer, buffer_unref);\n              break;\n\n            case EXPECTED_REPLY_LIST_NAMES:\n              /* This is a reply from the bus to a ListNames request, filter\n                 it according to the policy */\n              if (header->type == G_DBUS_MESSAGE_TYPE_METHOD_RETURN)\n                {\n                  Buffer *filtered_buffer;\n\n                  filtered_buffer = filter_names_list (client, buffer);\n                  g_clear_pointer (&buffer, buffer_unref);\n                  buffer = filtered_buffer;\n                }\n\n              break;\n\n            case EXPECTED_REPLY_NORMAL:\n              break;\n\n            default:\n              g_warning (\"Unexpected expected reply type %d\", expected_reply);\n            }\n        }\n      else /* Not reply */\n        {\n\n          /* Don't allow reply types with no reply_serial */\n          if (header->type == G_DBUS_MESSAGE_TYPE_METHOD_RETURN ||\n              header->type == G_DBUS_MESSAGE_TYPE_ERROR)\n            {\n              if (client->proxy->log_messages)\n                g_print (\"*Invalid reply*\\n\");\n              g_clear_pointer (&buffer, buffer_unref);\n            }\n\n          /* We filter all NameOwnerChanged signal according to the policy */\n          if (message_is_name_owner_changed (client, header))\n            {\n              if (should_filter_name_owner_changed (client, buffer))\n                g_clear_pointer (&buffer, buffer_unref);\n            }\n        }\n\n      /* All incoming broadcast signals are filtered according to policy */\n      if (header->type == G_DBUS_MESSAGE_TYPE_SIGNAL && header->destination == NULL)\n        {\n          policy = flatpak_proxy_client_get_policy (client, header->sender);\n          if (policy < FLATPAK_POLICY_TALK)\n            {\n              if (client->proxy->log_messages)\n                g_print (\"*FILTERED IN*\\n\");\n              g_clear_pointer (&buffer, buffer_unref);\n            }\n        }\n\n      /* We received and forwarded a message from a trusted peer. Make the policy for\n         this unique id SEE so that the client can track its lifetime. */\n      if (buffer && header->sender && header->sender[0] == ':')\n        flatpak_proxy_client_update_unique_id_policy (client, header->sender, FLATPAK_POLICY_SEE);\n\n      if (buffer && client_message_generates_reply (header))\n        queue_expected_reply (side, header->serial, EXPECTED_REPLY_NORMAL);\n    }\n\n  if (buffer)\n    queue_outgoing_buffer (&client->client_side, buffer);\n}\n\nstatic void\ngot_buffer_from_side (ProxySide *side, Buffer *buffer)\n{\n  FlatpakProxyClient *client = side->client;\n\n  if (side == &client->client_side)\n    got_buffer_from_client (client, side, buffer);\n  else\n    got_buffer_from_bus (client, side, buffer);\n}\n\n#define _DBUS_ISASCII(c) ((c) != '\\0' && (((c) & ~0x7f) == 0))\n\nstatic gboolean\nauth_line_is_valid (guint8 *line, guint8 *line_end)\n{\n  guint8 *p;\n\n  for (p = line; p < line_end; p++)\n    {\n      if (!_DBUS_ISASCII(*p))\n        return FALSE;\n\n      /* Technically, the dbus spec allows all ASCII characters, but for robustness we also\n         fail if we see any control characters. Such low values will appear in  potential attacks,\n         but will never happen in real sasl (where all binary data is hex encoded). */\n      if (*p < ' ')\n        return FALSE;\n    }\n\n  /* For robustness we require the first char of the line to be an upper case letter.\n     This is not technically required by the dbus spec, but all commands are upper\n     case, and there is no provisioning for whitespace before the command, so in practice\n     this is true, and this means we're not confused by e.g. initial whitespace. */\n  if (line[0] < 'A' || line[0] > 'Z')\n    return FALSE;\n\n  return TRUE;\n}\n\nstatic gboolean\nauth_line_is_begin (guint8 *line)\n{\n  guint8 next_char;\n\n  if (!g_str_has_prefix ((char *)line, AUTH_BEGIN))\n    return FALSE;\n\n  /* dbus-daemon accepts either nothing, or a whitespace followed by anything as end of auth */\n  next_char = line[strlen (AUTH_BEGIN)];\n  return (next_char == 0 ||\n          next_char == ' ' ||\n          next_char == '\\t');\n}\n\nstatic gssize\nfind_auth_end (FlatpakProxyClient *client, Buffer *buffer)\n{\n  goffset offset = 0;\n  gsize original_size = client->auth_buffer->len;\n\n  /* Add the new data to the remaining data from last iteration */\n  g_byte_array_append (client->auth_buffer, buffer->data, buffer->pos);\n\n  while (TRUE)\n    {\n      guint8 *line_start = client->auth_buffer->data + offset;\n      gsize remaining_data = client->auth_buffer->len - offset;\n      guint8 *line_end;\n\n      line_end = memmem (line_start, remaining_data,\n                         AUTH_LINE_SENTINEL, strlen (AUTH_LINE_SENTINEL));\n      if (line_end) /* Found end of line */\n        {\n          offset = (line_end + strlen (AUTH_LINE_SENTINEL) - line_start);\n\n          if (!auth_line_is_valid (line_start, line_end))\n            return FIND_AUTH_END_ABORT;\n\n          *line_end = 0;\n          if (auth_line_is_begin (line_start))\n            return offset - original_size;\n\n          /* continue with next line */\n        }\n      else\n        {\n          /* No end-of-line in this buffer */\n          g_byte_array_remove_range (client->auth_buffer, 0, offset);\n\n          /* Abort if more than 16k before newline, similar to what dbus-daemon does */\n          if (client->auth_buffer->len >= 16*1024)\n            return FIND_AUTH_END_ABORT;\n\n          return FIND_AUTH_END_CONTINUE;\n        }\n    }\n}\n\nstatic gboolean\nside_in_cb (GSocket *socket, GIOCondition condition, gpointer user_data)\n{\n  ProxySide *side = user_data;\n  FlatpakProxyClient *client = side->client;\n  GError *error = NULL;\n  Buffer *buffer;\n  gboolean retval = G_SOURCE_CONTINUE;\n\n  g_object_ref (client);\n\n  while (!side->closed)\n    {\n      if (!side->got_first_byte)\n        buffer = buffer_new (1, NULL);\n      else if (!client->authenticated)\n        buffer = buffer_new (64, NULL);\n      else\n        buffer = side->current_read_buffer;\n\n      if (!buffer_read (side, buffer, socket))\n        {\n          if (buffer != side->current_read_buffer)\n              buffer_unref (buffer);\n          break;\n        }\n\n      if (!client->authenticated)\n        {\n          if (buffer->pos > 0)\n            {\n              gboolean found_auth_end = FALSE;\n              gsize extra_data;\n\n              buffer->size = buffer->pos;\n              if (!side->got_first_byte)\n                {\n                  buffer->send_credentials = TRUE;\n                  side->got_first_byte = TRUE;\n                }\n              /* Look for end of authentication mechanism */\n              else if (side == &client->client_side)\n                {\n                  gssize auth_end = find_auth_end (client, buffer);\n\n                  if (auth_end >= 0)\n                    {\n                      found_auth_end = TRUE;\n                      buffer->size = auth_end;\n                      extra_data = buffer->pos - buffer->size;\n\n                      /* We may have gotten some extra data which is not part of\n                         the auth handshake, keep it for the next iteration. */\n                      if (extra_data > 0)\n                        side->extra_input_data = g_bytes_new (buffer->data + buffer->size, extra_data);\n                    }\n                  else if (auth_end == FIND_AUTH_END_ABORT)\n                    {\n                      buffer_unref (buffer);\n                      if (client->proxy->log_messages)\n                        g_print (\"Invalid AUTH line, aborting\\n\");\n                      side_closed (side);\n                      break;\n                    }\n                }\n\n              got_buffer_from_side (side, buffer);\n\n              if (found_auth_end)\n                client->authenticated = TRUE;\n            }\n          else\n            {\n              buffer_unref (buffer);\n            }\n        }\n      else if (buffer->pos == buffer->size)\n        {\n          if (buffer == &side->header_buffer)\n            {\n              gssize required;\n              required = g_dbus_message_bytes_needed (buffer->data, buffer->size, &error);\n              if (required < 0)\n                {\n                  g_warning (\"Invalid message header read\");\n                  side_closed (side);\n                }\n              else\n                {\n                  side->current_read_buffer = buffer_new (required, buffer);\n                }\n            }\n          else\n            {\n              got_buffer_from_side (side, buffer);\n              side->header_buffer.pos = 0;\n              side->current_read_buffer = &side->header_buffer;\n            }\n        }\n    }\n\n  if (side->closed)\n    {\n      side->in_source = NULL;\n      retval = G_SOURCE_REMOVE;\n    }\n\n  g_object_unref (client);\n\n  return retval;\n}\n\nstatic void\nstart_reading (ProxySide *side)\n{\n  GSocket *socket;\n\n  socket = g_socket_connection_get_socket (side->connection);\n  side->in_source = g_socket_create_source (socket, G_IO_IN, NULL);\n  g_source_set_callback (side->in_source, (GSourceFunc) side_in_cb, side, NULL);\n  g_source_attach (side->in_source, NULL);\n  g_source_unref (side->in_source);\n}\n\nstatic void\nstop_reading (ProxySide *side)\n{\n  if (side->in_source)\n    {\n      g_source_destroy (side->in_source);\n      side->in_source = NULL;\n    }\n}\n\n\nstatic void\nclient_connected_to_dbus (GObject      *source_object,\n                          GAsyncResult *res,\n                          gpointer      user_data)\n{\n  FlatpakProxyClient *client = user_data;\n  GSocketConnection *connection;\n  GError *error = NULL;\n  GIOStream *stream;\n\n  stream = g_dbus_address_get_stream_finish (res, NULL, &error);\n  if (stream == NULL)\n    {\n      g_warning (\"Failed to connect to bus: %s\", error->message);\n      g_object_unref (client);\n      return;\n    }\n\n  connection = G_SOCKET_CONNECTION (stream);\n  g_socket_set_blocking (g_socket_connection_get_socket (connection), FALSE);\n  client->bus_side.connection = connection;\n\n  start_reading (&client->client_side);\n  start_reading (&client->bus_side);\n}\n\nstatic gboolean\nflatpak_proxy_incoming (GSocketService    *service,\n                        GSocketConnection *connection,\n                        GObject           *source_object)\n{\n  FlatpakProxy *proxy = FLATPAK_PROXY (service);\n  FlatpakProxyClient *client;\n\n  client = flatpak_proxy_client_new (proxy, connection);\n\n  g_dbus_address_get_stream (proxy->dbus_address,\n                             NULL,\n                             client_connected_to_dbus,\n                             client);\n  return TRUE;\n}\n\nstatic void\nflatpak_proxy_init (FlatpakProxy *proxy)\n{\n  proxy->policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  proxy->filters = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify)filter_list_free);\n  proxy->wildcard_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  flatpak_proxy_add_policy (proxy, \"org.freedesktop.DBus\", FLATPAK_POLICY_TALK);\n}\n\nstatic void\nflatpak_proxy_class_init (FlatpakProxyClass *klass)\n{\n  GObjectClass *object_class = G_OBJECT_CLASS (klass);\n  GSocketServiceClass *socket_service_class = G_SOCKET_SERVICE_CLASS (klass);\n\n  object_class->get_property = flatpak_proxy_get_property;\n  object_class->set_property = flatpak_proxy_set_property;\n  object_class->finalize = flatpak_proxy_finalize;\n\n  socket_service_class->incoming = flatpak_proxy_incoming;\n\n  g_object_class_install_property (object_class,\n                                   PROP_DBUS_ADDRESS,\n                                   g_param_spec_string (\"dbus-address\",\n                                                        \"\",\n                                                        \"\",\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));\n  g_object_class_install_property (object_class,\n                                   PROP_SOCKET_PATH,\n                                   g_param_spec_string (\"socket-path\",\n                                                        \"\",\n                                                        \"\",\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));\n\n}\n\nFlatpakProxy *\nflatpak_proxy_new (const char *dbus_address,\n                   const char *socket_path)\n{\n  FlatpakProxy *proxy;\n\n  proxy = g_object_new (FLATPAK_TYPE_PROXY, \"dbus-address\", dbus_address, \"socket-path\", socket_path, NULL);\n  return proxy;\n}\n\ngboolean\nflatpak_proxy_start (FlatpakProxy *proxy, GError **error)\n{\n  GSocketAddress *address;\n  gboolean res;\n\n  unlink (proxy->socket_path);\n\n  address = g_unix_socket_address_new (proxy->socket_path);\n\n  error = NULL;\n  res = g_socket_listener_add_address (G_SOCKET_LISTENER (proxy),\n                                       address,\n                                       G_SOCKET_TYPE_STREAM,\n                                       G_SOCKET_PROTOCOL_DEFAULT,\n                                       NULL, /* source_object */\n                                       NULL, /* effective_address */\n                                       error);\n  g_object_unref (address);\n\n  if (!res)\n    return FALSE;\n\n\n  g_socket_service_start (G_SOCKET_SERVICE (proxy));\n  return TRUE;\n}\n\nvoid\nflatpak_proxy_stop (FlatpakProxy *proxy)\n{\n  unlink (proxy->socket_path);\n\n  g_socket_service_stop (G_SOCKET_SERVICE (proxy));\n}\n"], "filenames": ["dbus-proxy/flatpak-proxy.c"], "buggy_code_start_loc": [176], "buggy_code_end_loc": [2419], "fixing_code_start_loc": [176], "fixing_code_end_loc": [2471], "type": "CWE-436", "message": "In dbus-proxy/flatpak-proxy.c in Flatpak before 0.8.9, and 0.9.x and 0.10.x before 0.10.3, crafted D-Bus messages to the host can be used to break out of the sandbox, because whitespace handling in the proxy is not identical to whitespace handling in the daemon.", "other": {"cve": {"id": "CVE-2018-6560", "sourceIdentifier": "cve@mitre.org", "published": "2018-02-02T14:29:01.637", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In dbus-proxy/flatpak-proxy.c in Flatpak before 0.8.9, and 0.9.x and 0.10.x before 0.10.3, crafted D-Bus messages to the host can be used to break out of the sandbox, because whitespace handling in the proxy is not identical to whitespace handling in the daemon."}, {"lang": "es", "value": "En dbus-proxy/flatpak-proxy.c en Flatpak en versiones anteriores a la 0.8.9, 0.9.x y 0.10.x anteriores a la 0.10.3, se pueden utilizar mensajes D-Bus manipulados para salir del sandbox, ya que la gesti\u00f3n de los espacios en blanco en el proxy no es id\u00e9ntica a c\u00f3mo gestiona el demonio los espacios en blanco."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.0, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-436"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:flatpak:flatpak:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.9", "matchCriteriaId": "9C4E0F04-6995-4A94-B405-C3308AAB6F97"}, {"vulnerable": true, "criteria": "cpe:2.3:a:flatpak:flatpak:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.9.1", "versionEndIncluding": "0.9.99", "matchCriteriaId": "8CB0303E-0F7B-44F7-9222-C31FB21D9F84"}, {"vulnerable": true, "criteria": "cpe:2.3:a:flatpak:flatpak:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.10.0", "versionEndExcluding": "0.10.3", "matchCriteriaId": "B6DD99F6-6E1B-4E28-8472-D71EC457F3F6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "A4E9DD8A-A68B-4A69-8B01-BFF92A2020A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "BF77CDCF-B9C9-427D-B2BF-36650FB2148C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2018:2766", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/flatpak/flatpak/commit/52346bf187b5a7f1c0fe9075b328b7ad6abe78f6", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/flatpak/flatpak/releases/tag/0.10.3", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/flatpak/flatpak/releases/tag/0.8.9", "source": "cve@mitre.org", "tags": ["Release Notes"]}]}, "github_commit_url": "https://github.com/flatpak/flatpak/commit/52346bf187b5a7f1c0fe9075b328b7ad6abe78f6"}}