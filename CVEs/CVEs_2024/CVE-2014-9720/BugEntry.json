{"buggy_code": ["from __future__ import absolute_import, division, print_function, with_statement\nfrom tornado import gen\nfrom tornado.escape import json_decode, utf8, to_unicode, recursive_unicode, native_str, to_basestring\nfrom tornado.httputil import format_timestamp\nfrom tornado.iostream import IOStream\nfrom tornado.log import app_log, gen_log\nfrom tornado.simple_httpclient import SimpleAsyncHTTPClient\nfrom tornado.template import DictLoader\nfrom tornado.testing import AsyncHTTPTestCase, ExpectLog\nfrom tornado.test.util import unittest\nfrom tornado.util import u, bytes_type, ObjectDict, unicode_type\nfrom tornado.web import RequestHandler, authenticated, Application, asynchronous, url, HTTPError, StaticFileHandler, _create_signature_v1, create_signed_value, decode_signed_value, ErrorHandler, UIModule, MissingArgumentError\n\nimport binascii\nimport datetime\nimport email.utils\nimport logging\nimport os\nimport re\nimport socket\nimport sys\n\ntry:\n    import urllib.parse as urllib_parse  # py3\nexcept ImportError:\n    import urllib as urllib_parse  # py2\n\nwsgi_safe_tests = []\n\nrelpath = lambda *a: os.path.join(os.path.dirname(__file__), *a)\n\n\ndef wsgi_safe(cls):\n    wsgi_safe_tests.append(cls)\n    return cls\n\n\nclass WebTestCase(AsyncHTTPTestCase):\n    \"\"\"Base class for web tests that also supports WSGI mode.\n\n    Override get_handlers and get_app_kwargs instead of get_app.\n    Append to wsgi_safe to have it run in wsgi_test as well.\n    \"\"\"\n    def get_app(self):\n        self.app = Application(self.get_handlers(), **self.get_app_kwargs())\n        return self.app\n\n    def get_handlers(self):\n        raise NotImplementedError()\n\n    def get_app_kwargs(self):\n        return {}\n\n\nclass SimpleHandlerTestCase(WebTestCase):\n    \"\"\"Simplified base class for tests that work with a single handler class.\n\n    To use, define a nested class named ``Handler``.\n    \"\"\"\n    def get_handlers(self):\n        return [('/', self.Handler)]\n\n\nclass HelloHandler(RequestHandler):\n    def get(self):\n        self.write('hello')\n\n\nclass CookieTestRequestHandler(RequestHandler):\n    # stub out enough methods to make the secure_cookie functions work\n    def __init__(self):\n        # don't call super.__init__\n        self._cookies = {}\n        self.application = ObjectDict(settings=dict(cookie_secret='0123456789'))\n\n    def get_cookie(self, name):\n        return self._cookies.get(name)\n\n    def set_cookie(self, name, value, expires_days=None):\n        self._cookies[name] = value\n\n\n# See SignedValueTest below for more.\nclass SecureCookieV1Test(unittest.TestCase):\n    def test_round_trip(self):\n        handler = CookieTestRequestHandler()\n        handler.set_secure_cookie('foo', b'bar', version=1)\n        self.assertEqual(handler.get_secure_cookie('foo', min_version=1),\n                         b'bar')\n\n    def test_cookie_tampering_future_timestamp(self):\n        handler = CookieTestRequestHandler()\n        # this string base64-encodes to '12345678'\n        handler.set_secure_cookie('foo', binascii.a2b_hex(b'd76df8e7aefc'),\n                                  version=1)\n        cookie = handler._cookies['foo']\n        match = re.match(br'12345678\\|([0-9]+)\\|([0-9a-f]+)', cookie)\n        self.assertTrue(match)\n        timestamp = match.group(1)\n        sig = match.group(2)\n        self.assertEqual(\n            _create_signature_v1(handler.application.settings[\"cookie_secret\"],\n                              'foo', '12345678', timestamp),\n            sig)\n        # shifting digits from payload to timestamp doesn't alter signature\n        # (this is not desirable behavior, just confirming that that's how it\n        # works)\n        self.assertEqual(\n            _create_signature_v1(handler.application.settings[\"cookie_secret\"],\n                              'foo', '1234', b'5678' + timestamp),\n            sig)\n        # tamper with the cookie\n        handler._cookies['foo'] = utf8('1234|5678%s|%s' % (\n            to_basestring(timestamp), to_basestring(sig)))\n        # it gets rejected\n        with ExpectLog(gen_log, \"Cookie timestamp in future\"):\n            self.assertTrue(\n                handler.get_secure_cookie('foo', min_version=1) is None)\n\n    def test_arbitrary_bytes(self):\n        # Secure cookies accept arbitrary data (which is base64 encoded).\n        # Note that normal cookies accept only a subset of ascii.\n        handler = CookieTestRequestHandler()\n        handler.set_secure_cookie('foo', b'\\xe9', version=1)\n        self.assertEqual(handler.get_secure_cookie('foo', min_version=1), b'\\xe9')\n\n\nclass CookieTest(WebTestCase):\n    def get_handlers(self):\n        class SetCookieHandler(RequestHandler):\n            def get(self):\n                # Try setting cookies with different argument types\n                # to ensure that everything gets encoded correctly\n                self.set_cookie(\"str\", \"asdf\")\n                self.set_cookie(\"unicode\", u(\"qwer\"))\n                self.set_cookie(\"bytes\", b\"zxcv\")\n\n        class GetCookieHandler(RequestHandler):\n            def get(self):\n                self.write(self.get_cookie(\"foo\", \"default\"))\n\n        class SetCookieDomainHandler(RequestHandler):\n            def get(self):\n                # unicode domain and path arguments shouldn't break things\n                # either (see bug #285)\n                self.set_cookie(\"unicode_args\", \"blah\", domain=u(\"foo.com\"),\n                                path=u(\"/foo\"))\n\n        class SetCookieSpecialCharHandler(RequestHandler):\n            def get(self):\n                self.set_cookie(\"equals\", \"a=b\")\n                self.set_cookie(\"semicolon\", \"a;b\")\n                self.set_cookie(\"quote\", 'a\"b')\n\n        class SetCookieOverwriteHandler(RequestHandler):\n            def get(self):\n                self.set_cookie(\"a\", \"b\", domain=\"example.com\")\n                self.set_cookie(\"c\", \"d\", domain=\"example.com\")\n                # A second call with the same name clobbers the first.\n                # Attributes from the first call are not carried over.\n                self.set_cookie(\"a\", \"e\")\n\n        return [(\"/set\", SetCookieHandler),\n                (\"/get\", GetCookieHandler),\n                (\"/set_domain\", SetCookieDomainHandler),\n                (\"/special_char\", SetCookieSpecialCharHandler),\n                (\"/set_overwrite\", SetCookieOverwriteHandler),\n                ]\n\n    def test_set_cookie(self):\n        response = self.fetch(\"/set\")\n        self.assertEqual(sorted(response.headers.get_list(\"Set-Cookie\")),\n                         [\"bytes=zxcv; Path=/\",\n                          \"str=asdf; Path=/\",\n                          \"unicode=qwer; Path=/\",\n                          ])\n\n    def test_get_cookie(self):\n        response = self.fetch(\"/get\", headers={\"Cookie\": \"foo=bar\"})\n        self.assertEqual(response.body, b\"bar\")\n\n        response = self.fetch(\"/get\", headers={\"Cookie\": 'foo=\"bar\"'})\n        self.assertEqual(response.body, b\"bar\")\n\n        response = self.fetch(\"/get\", headers={\"Cookie\": \"/=exception;\"})\n        self.assertEqual(response.body, b\"default\")\n\n    def test_set_cookie_domain(self):\n        response = self.fetch(\"/set_domain\")\n        self.assertEqual(response.headers.get_list(\"Set-Cookie\"),\n                         [\"unicode_args=blah; Domain=foo.com; Path=/foo\"])\n\n    def test_cookie_special_char(self):\n        response = self.fetch(\"/special_char\")\n        headers = sorted(response.headers.get_list(\"Set-Cookie\"))\n        self.assertEqual(len(headers), 3)\n        self.assertEqual(headers[0], 'equals=\"a=b\"; Path=/')\n        self.assertEqual(headers[1], 'quote=\"a\\\\\"b\"; Path=/')\n        # python 2.7 octal-escapes the semicolon; older versions leave it alone\n        self.assertTrue(headers[2] in ('semicolon=\"a;b\"; Path=/',\n                                       'semicolon=\"a\\\\073b\"; Path=/'),\n                        headers[2])\n\n        data = [('foo=a=b', 'a=b'),\n                ('foo=\"a=b\"', 'a=b'),\n                ('foo=\"a;b\"', 'a;b'),\n                # ('foo=a\\\\073b', 'a;b'),  # even encoded, \";\" is a delimiter\n                ('foo=\"a\\\\073b\"', 'a;b'),\n                ('foo=\"a\\\\\"b\"', 'a\"b'),\n                ]\n        for header, expected in data:\n            logging.debug(\"trying %r\", header)\n            response = self.fetch(\"/get\", headers={\"Cookie\": header})\n            self.assertEqual(response.body, utf8(expected))\n\n    def test_set_cookie_overwrite(self):\n        response = self.fetch(\"/set_overwrite\")\n        headers = response.headers.get_list(\"Set-Cookie\")\n        self.assertEqual(sorted(headers),\n                         [\"a=e; Path=/\", \"c=d; Domain=example.com; Path=/\"])\n\n\nclass AuthRedirectRequestHandler(RequestHandler):\n    def initialize(self, login_url):\n        self.login_url = login_url\n\n    def get_login_url(self):\n        return self.login_url\n\n    @authenticated\n    def get(self):\n        # we'll never actually get here because the test doesn't follow redirects\n        self.send_error(500)\n\n\nclass AuthRedirectTest(WebTestCase):\n    def get_handlers(self):\n        return [('/relative', AuthRedirectRequestHandler,\n                 dict(login_url='/login')),\n                ('/absolute', AuthRedirectRequestHandler,\n                 dict(login_url='http://example.com/login'))]\n\n    def test_relative_auth_redirect(self):\n        self.http_client.fetch(self.get_url('/relative'), self.stop,\n                               follow_redirects=False)\n        response = self.wait()\n        self.assertEqual(response.code, 302)\n        self.assertEqual(response.headers['Location'], '/login?next=%2Frelative')\n\n    def test_absolute_auth_redirect(self):\n        self.http_client.fetch(self.get_url('/absolute'), self.stop,\n                               follow_redirects=False)\n        response = self.wait()\n        self.assertEqual(response.code, 302)\n        self.assertTrue(re.match(\n            'http://example.com/login\\?next=http%3A%2F%2Flocalhost%3A[0-9]+%2Fabsolute',\n            response.headers['Location']), response.headers['Location'])\n\n\nclass ConnectionCloseHandler(RequestHandler):\n    def initialize(self, test):\n        self.test = test\n\n    @asynchronous\n    def get(self):\n        self.test.on_handler_waiting()\n\n    def on_connection_close(self):\n        self.test.on_connection_close()\n\n\nclass ConnectionCloseTest(WebTestCase):\n    def get_handlers(self):\n        return [('/', ConnectionCloseHandler, dict(test=self))]\n\n    def test_connection_close(self):\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n        s.connect((\"localhost\", self.get_http_port()))\n        self.stream = IOStream(s, io_loop=self.io_loop)\n        self.stream.write(b\"GET / HTTP/1.0\\r\\n\\r\\n\")\n        self.wait()\n\n    def on_handler_waiting(self):\n        logging.debug('handler waiting')\n        self.stream.close()\n\n    def on_connection_close(self):\n        logging.debug('connection closed')\n        self.stop()\n\n\nclass EchoHandler(RequestHandler):\n    def get(self, *path_args):\n        # Type checks: web.py interfaces convert argument values to\n        # unicode strings (by default, but see also decode_argument).\n        # In httpserver.py (i.e. self.request.arguments), they're left\n        # as bytes.  Keys are always native strings.\n        for key in self.request.arguments:\n            if type(key) != str:\n                raise Exception(\"incorrect type for key: %r\" % type(key))\n            for value in self.request.arguments[key]:\n                if type(value) != bytes_type:\n                    raise Exception(\"incorrect type for value: %r\" %\n                                    type(value))\n            for value in self.get_arguments(key):\n                if type(value) != unicode_type:\n                    raise Exception(\"incorrect type for value: %r\" %\n                                    type(value))\n        for arg in path_args:\n            if type(arg) != unicode_type:\n                raise Exception(\"incorrect type for path arg: %r\" % type(arg))\n        self.write(dict(path=self.request.path,\n                        path_args=path_args,\n                        args=recursive_unicode(self.request.arguments)))\n\n\nclass RequestEncodingTest(WebTestCase):\n    def get_handlers(self):\n        return [(\"/group/(.*)\", EchoHandler),\n                (\"/slashes/([^/]*)/([^/]*)\", EchoHandler),\n                ]\n\n    def fetch_json(self, path):\n        return json_decode(self.fetch(path).body)\n\n    def test_group_question_mark(self):\n        # Ensure that url-encoded question marks are handled properly\n        self.assertEqual(self.fetch_json('/group/%3F'),\n                         dict(path='/group/%3F', path_args=['?'], args={}))\n        self.assertEqual(self.fetch_json('/group/%3F?%3F=%3F'),\n                         dict(path='/group/%3F', path_args=['?'], args={'?': ['?']}))\n\n    def test_group_encoding(self):\n        # Path components and query arguments should be decoded the same way\n        self.assertEqual(self.fetch_json('/group/%C3%A9?arg=%C3%A9'),\n                         {u(\"path\"): u(\"/group/%C3%A9\"),\n                          u(\"path_args\"): [u(\"\\u00e9\")],\n                          u(\"args\"): {u(\"arg\"): [u(\"\\u00e9\")]}})\n\n    def test_slashes(self):\n        # Slashes may be escaped to appear as a single \"directory\" in the path,\n        # but they are then unescaped when passed to the get() method.\n        self.assertEqual(self.fetch_json('/slashes/foo/bar'),\n                         dict(path=\"/slashes/foo/bar\",\n                              path_args=[\"foo\", \"bar\"],\n                              args={}))\n        self.assertEqual(self.fetch_json('/slashes/a%2Fb/c%2Fd'),\n                         dict(path=\"/slashes/a%2Fb/c%2Fd\",\n                              path_args=[\"a/b\", \"c/d\"],\n                              args={}))\n\n\nclass TypeCheckHandler(RequestHandler):\n    def prepare(self):\n        self.errors = {}\n\n        self.check_type('status', self.get_status(), int)\n\n        # get_argument is an exception from the general rule of using\n        # type str for non-body data mainly for historical reasons.\n        self.check_type('argument', self.get_argument('foo'), unicode_type)\n        self.check_type('cookie_key', list(self.cookies.keys())[0], str)\n        self.check_type('cookie_value', list(self.cookies.values())[0].value, str)\n\n        # Secure cookies return bytes because they can contain arbitrary\n        # data, but regular cookies are native strings.\n        if list(self.cookies.keys()) != ['asdf']:\n            raise Exception(\"unexpected values for cookie keys: %r\" %\n                            self.cookies.keys())\n        self.check_type('get_secure_cookie', self.get_secure_cookie('asdf'), bytes_type)\n        self.check_type('get_cookie', self.get_cookie('asdf'), str)\n\n        self.check_type('xsrf_token', self.xsrf_token, bytes_type)\n        self.check_type('xsrf_form_html', self.xsrf_form_html(), str)\n\n        self.check_type('reverse_url', self.reverse_url('typecheck', 'foo'), str)\n\n        self.check_type('request_summary', self._request_summary(), str)\n\n    def get(self, path_component):\n        # path_component uses type unicode instead of str for consistency\n        # with get_argument()\n        self.check_type('path_component', path_component, unicode_type)\n        self.write(self.errors)\n\n    def post(self, path_component):\n        self.check_type('path_component', path_component, unicode_type)\n        self.write(self.errors)\n\n    def check_type(self, name, obj, expected_type):\n        actual_type = type(obj)\n        if expected_type != actual_type:\n            self.errors[name] = \"expected %s, got %s\" % (expected_type,\n                                                         actual_type)\n\n\nclass DecodeArgHandler(RequestHandler):\n    def decode_argument(self, value, name=None):\n        if type(value) != bytes_type:\n            raise Exception(\"unexpected type for value: %r\" % type(value))\n        # use self.request.arguments directly to avoid recursion\n        if 'encoding' in self.request.arguments:\n            return value.decode(to_unicode(self.request.arguments['encoding'][0]))\n        else:\n            return value\n\n    def get(self, arg):\n        def describe(s):\n            if type(s) == bytes_type:\n                return [\"bytes\", native_str(binascii.b2a_hex(s))]\n            elif type(s) == unicode_type:\n                return [\"unicode\", s]\n            raise Exception(\"unknown type\")\n        self.write({'path': describe(arg),\n                    'query': describe(self.get_argument(\"foo\")),\n                    })\n\n\nclass LinkifyHandler(RequestHandler):\n    def get(self):\n        self.render(\"linkify.html\", message=\"http://example.com\")\n\n\nclass UIModuleResourceHandler(RequestHandler):\n    def get(self):\n        self.render(\"page.html\", entries=[1, 2])\n\n\nclass OptionalPathHandler(RequestHandler):\n    def get(self, path):\n        self.write({\"path\": path})\n\n\nclass FlowControlHandler(RequestHandler):\n    # These writes are too small to demonstrate real flow control,\n    # but at least it shows that the callbacks get run.\n    @asynchronous\n    def get(self):\n        self.write(\"1\")\n        self.flush(callback=self.step2)\n\n    def step2(self):\n        self.write(\"2\")\n        self.flush(callback=self.step3)\n\n    def step3(self):\n        self.write(\"3\")\n        self.finish()\n\n\nclass MultiHeaderHandler(RequestHandler):\n    def get(self):\n        self.set_header(\"x-overwrite\", \"1\")\n        self.set_header(\"X-Overwrite\", 2)\n        self.add_header(\"x-multi\", 3)\n        self.add_header(\"X-Multi\", \"4\")\n\n\nclass RedirectHandler(RequestHandler):\n    def get(self):\n        if self.get_argument('permanent', None) is not None:\n            self.redirect('/', permanent=int(self.get_argument('permanent')))\n        elif self.get_argument('status', None) is not None:\n            self.redirect('/', status=int(self.get_argument('status')))\n        else:\n            raise Exception(\"didn't get permanent or status arguments\")\n\n\nclass EmptyFlushCallbackHandler(RequestHandler):\n    @gen.engine\n    @asynchronous\n    def get(self):\n        # Ensure that the flush callback is run whether or not there\n        # was any output.\n        yield gen.Task(self.flush)  # \"empty\" flush, but writes headers\n        yield gen.Task(self.flush)  # empty flush\n        self.write(\"o\")\n        yield gen.Task(self.flush)  # flushes the \"o\"\n        yield gen.Task(self.flush)  # empty flush\n        self.finish(\"k\")\n\n\nclass HeaderInjectionHandler(RequestHandler):\n    def get(self):\n        try:\n            self.set_header(\"X-Foo\", \"foo\\r\\nX-Bar: baz\")\n            raise Exception(\"Didn't get expected exception\")\n        except ValueError as e:\n            if \"Unsafe header value\" in str(e):\n                self.finish(b\"ok\")\n            else:\n                raise\n\n\nclass GetArgumentHandler(RequestHandler):\n    def prepare(self):\n        if self.get_argument('source', None) == 'query':\n            method = self.get_query_argument\n        elif self.get_argument('source', None) == 'body':\n            method = self.get_body_argument\n        else:\n            method = self.get_argument\n        self.finish(method(\"foo\", \"default\"))\n\n\nclass GetArgumentsHandler(RequestHandler):\n    def prepare(self):\n        self.finish(dict(default=self.get_arguments(\"foo\"),\n                         query=self.get_query_arguments(\"foo\"),\n                         body=self.get_body_arguments(\"foo\")))\n\n\n# This test is shared with wsgi_test.py\n@wsgi_safe\nclass WSGISafeWebTest(WebTestCase):\n    COOKIE_SECRET = \"WebTest.COOKIE_SECRET\"\n\n    def get_app_kwargs(self):\n        loader = DictLoader({\n            \"linkify.html\": \"{% module linkify(message) %}\",\n            \"page.html\": \"\"\"\\\n<html><head></head><body>\n{% for e in entries %}\n{% module Template(\"entry.html\", entry=e) %}\n{% end %}\n</body></html>\"\"\",\n            \"entry.html\": \"\"\"\\\n{{ set_resources(embedded_css=\".entry { margin-bottom: 1em; }\", embedded_javascript=\"js_embed()\", css_files=[\"/base.css\", \"/foo.css\"], javascript_files=\"/common.js\", html_head=\"<meta>\", html_body='<script src=\"/analytics.js\"/>') }}\n<div class=\"entry\">...</div>\"\"\",\n        })\n        return dict(template_loader=loader,\n                    autoescape=\"xhtml_escape\",\n                    cookie_secret=self.COOKIE_SECRET)\n\n    def tearDown(self):\n        super(WSGISafeWebTest, self).tearDown()\n        RequestHandler._template_loaders.clear()\n\n    def get_handlers(self):\n        urls = [\n            url(\"/typecheck/(.*)\", TypeCheckHandler, name='typecheck'),\n            url(\"/decode_arg/(.*)\", DecodeArgHandler, name='decode_arg'),\n            url(\"/decode_arg_kw/(?P<arg>.*)\", DecodeArgHandler),\n            url(\"/linkify\", LinkifyHandler),\n            url(\"/uimodule_resources\", UIModuleResourceHandler),\n            url(\"/optional_path/(.+)?\", OptionalPathHandler),\n            url(\"/multi_header\", MultiHeaderHandler),\n            url(\"/redirect\", RedirectHandler),\n            url(\"/header_injection\", HeaderInjectionHandler),\n            url(\"/get_argument\", GetArgumentHandler),\n            url(\"/get_arguments\", GetArgumentsHandler),\n        ]\n        return urls\n\n    def fetch_json(self, *args, **kwargs):\n        response = self.fetch(*args, **kwargs)\n        response.rethrow()\n        return json_decode(response.body)\n\n    def test_types(self):\n        cookie_value = to_unicode(create_signed_value(self.COOKIE_SECRET,\n                                                      \"asdf\", \"qwer\"))\n        response = self.fetch(\"/typecheck/asdf?foo=bar\",\n                              headers={\"Cookie\": \"asdf=\" + cookie_value})\n        data = json_decode(response.body)\n        self.assertEqual(data, {})\n\n        response = self.fetch(\"/typecheck/asdf?foo=bar\", method=\"POST\",\n                              headers={\"Cookie\": \"asdf=\" + cookie_value},\n                              body=\"foo=bar\")\n\n    def test_decode_argument(self):\n        # These urls all decode to the same thing\n        urls = [\"/decode_arg/%C3%A9?foo=%C3%A9&encoding=utf-8\",\n                \"/decode_arg/%E9?foo=%E9&encoding=latin1\",\n                \"/decode_arg_kw/%E9?foo=%E9&encoding=latin1\",\n                ]\n        for url in urls:\n            response = self.fetch(url)\n            response.rethrow()\n            data = json_decode(response.body)\n            self.assertEqual(data, {u('path'): [u('unicode'), u('\\u00e9')],\n                                    u('query'): [u('unicode'), u('\\u00e9')],\n                                    })\n\n        response = self.fetch(\"/decode_arg/%C3%A9?foo=%C3%A9\")\n        response.rethrow()\n        data = json_decode(response.body)\n        self.assertEqual(data, {u('path'): [u('bytes'), u('c3a9')],\n                                u('query'): [u('bytes'), u('c3a9')],\n                                })\n\n    def test_decode_argument_invalid_unicode(self):\n        # test that invalid unicode in URLs causes 400, not 500\n        with ExpectLog(gen_log, \".*Invalid unicode.*\"):\n            response = self.fetch(\"/typecheck/invalid%FF\")\n            self.assertEqual(response.code, 400)\n            response = self.fetch(\"/typecheck/invalid?foo=%FF\")\n            self.assertEqual(response.code, 400)\n\n    def test_decode_argument_plus(self):\n        # These urls are all equivalent.\n        urls = [\"/decode_arg/1%20%2B%201?foo=1%20%2B%201&encoding=utf-8\",\n                \"/decode_arg/1%20+%201?foo=1+%2B+1&encoding=utf-8\"]\n        for url in urls:\n            response = self.fetch(url)\n            response.rethrow()\n            data = json_decode(response.body)\n            self.assertEqual(data, {u('path'): [u('unicode'), u('1 + 1')],\n                                    u('query'): [u('unicode'), u('1 + 1')],\n                                    })\n\n    def test_reverse_url(self):\n        self.assertEqual(self.app.reverse_url('decode_arg', 'foo'),\n                         '/decode_arg/foo')\n        self.assertEqual(self.app.reverse_url('decode_arg', 42),\n                         '/decode_arg/42')\n        self.assertEqual(self.app.reverse_url('decode_arg', b'\\xe9'),\n                         '/decode_arg/%E9')\n        self.assertEqual(self.app.reverse_url('decode_arg', u('\\u00e9')),\n                         '/decode_arg/%C3%A9')\n        self.assertEqual(self.app.reverse_url('decode_arg', '1 + 1'),\n                         '/decode_arg/1%20%2B%201')\n\n    def test_uimodule_unescaped(self):\n        response = self.fetch(\"/linkify\")\n        self.assertEqual(response.body,\n                         b\"<a href=\\\"http://example.com\\\">http://example.com</a>\")\n\n    def test_uimodule_resources(self):\n        response = self.fetch(\"/uimodule_resources\")\n        self.assertEqual(response.body, b\"\"\"\\\n<html><head><link href=\"/base.css\" type=\"text/css\" rel=\"stylesheet\"/><link href=\"/foo.css\" type=\"text/css\" rel=\"stylesheet\"/>\n<style type=\"text/css\">\n.entry { margin-bottom: 1em; }\n</style>\n<meta>\n</head><body>\n\n\n<div class=\"entry\">...</div>\n\n\n<div class=\"entry\">...</div>\n\n<script src=\"/common.js\" type=\"text/javascript\"></script>\n<script type=\"text/javascript\">\n//<![CDATA[\njs_embed()\n//]]>\n</script>\n<script src=\"/analytics.js\"/>\n</body></html>\"\"\")\n\n    def test_optional_path(self):\n        self.assertEqual(self.fetch_json(\"/optional_path/foo\"),\n                         {u(\"path\"): u(\"foo\")})\n        self.assertEqual(self.fetch_json(\"/optional_path/\"),\n                         {u(\"path\"): None})\n\n    def test_multi_header(self):\n        response = self.fetch(\"/multi_header\")\n        self.assertEqual(response.headers[\"x-overwrite\"], \"2\")\n        self.assertEqual(response.headers.get_list(\"x-multi\"), [\"3\", \"4\"])\n\n    def test_redirect(self):\n        response = self.fetch(\"/redirect?permanent=1\", follow_redirects=False)\n        self.assertEqual(response.code, 301)\n        response = self.fetch(\"/redirect?permanent=0\", follow_redirects=False)\n        self.assertEqual(response.code, 302)\n        response = self.fetch(\"/redirect?status=307\", follow_redirects=False)\n        self.assertEqual(response.code, 307)\n\n    def test_header_injection(self):\n        response = self.fetch(\"/header_injection\")\n        self.assertEqual(response.body, b\"ok\")\n\n    def test_get_argument(self):\n        response = self.fetch(\"/get_argument?foo=bar\")\n        self.assertEqual(response.body, b\"bar\")\n        response = self.fetch(\"/get_argument?foo=\")\n        self.assertEqual(response.body, b\"\")\n        response = self.fetch(\"/get_argument\")\n        self.assertEqual(response.body, b\"default\")\n\n        # Test merging of query and body arguments.\n        # In singular form, body arguments take precedence over query arguments.\n        body = urllib_parse.urlencode(dict(foo=\"hello\"))\n        response = self.fetch(\"/get_argument?foo=bar\", method=\"POST\", body=body)\n        self.assertEqual(response.body, b\"hello\")\n        # In plural methods they are merged.\n        response = self.fetch(\"/get_arguments?foo=bar\",\n                              method=\"POST\", body=body)\n        self.assertEqual(json_decode(response.body),\n                         dict(default=['bar', 'hello'],\n                              query=['bar'],\n                              body=['hello']))\n\n    def test_get_query_arguments(self):\n        # send as a post so we can ensure the separation between query\n        # string and body arguments.\n        body = urllib_parse.urlencode(dict(foo=\"hello\"))\n        response = self.fetch(\"/get_argument?source=query&foo=bar\",\n                              method=\"POST\", body=body)\n        self.assertEqual(response.body, b\"bar\")\n        response = self.fetch(\"/get_argument?source=query&foo=\",\n                              method=\"POST\", body=body)\n        self.assertEqual(response.body, b\"\")\n        response = self.fetch(\"/get_argument?source=query\",\n                              method=\"POST\", body=body)\n        self.assertEqual(response.body, b\"default\")\n\n    def test_get_body_arguments(self):\n        body = urllib_parse.urlencode(dict(foo=\"bar\"))\n        response = self.fetch(\"/get_argument?source=body&foo=hello\",\n                              method=\"POST\", body=body)\n        self.assertEqual(response.body, b\"bar\")\n\n        body = urllib_parse.urlencode(dict(foo=\"\"))\n        response = self.fetch(\"/get_argument?source=body&foo=hello\",\n                              method=\"POST\", body=body)\n        self.assertEqual(response.body, b\"\")\n\n        body = urllib_parse.urlencode(dict())\n        response = self.fetch(\"/get_argument?source=body&foo=hello\",\n                              method=\"POST\", body=body)\n        self.assertEqual(response.body, b\"default\")\n\n    def test_no_gzip(self):\n        response = self.fetch('/get_argument')\n        self.assertNotIn('Accept-Encoding', response.headers.get('Vary', ''))\n        self.assertNotIn('gzip', response.headers.get('Content-Encoding', ''))\n\n\nclass NonWSGIWebTests(WebTestCase):\n    def get_handlers(self):\n        return [(\"/flow_control\", FlowControlHandler),\n                (\"/empty_flush\", EmptyFlushCallbackHandler),\n                ]\n\n    def test_flow_control(self):\n        self.assertEqual(self.fetch(\"/flow_control\").body, b\"123\")\n\n    def test_empty_flush(self):\n        response = self.fetch(\"/empty_flush\")\n        self.assertEqual(response.body, b\"ok\")\n\n\n@wsgi_safe\nclass ErrorResponseTest(WebTestCase):\n    def get_handlers(self):\n        class DefaultHandler(RequestHandler):\n            def get(self):\n                if self.get_argument(\"status\", None):\n                    raise HTTPError(int(self.get_argument(\"status\")))\n                1 / 0\n\n        class WriteErrorHandler(RequestHandler):\n            def get(self):\n                if self.get_argument(\"status\", None):\n                    self.send_error(int(self.get_argument(\"status\")))\n                else:\n                    1 / 0\n\n            def write_error(self, status_code, **kwargs):\n                self.set_header(\"Content-Type\", \"text/plain\")\n                if \"exc_info\" in kwargs:\n                    self.write(\"Exception: %s\" % kwargs[\"exc_info\"][0].__name__)\n                else:\n                    self.write(\"Status: %d\" % status_code)\n\n        class GetErrorHtmlHandler(RequestHandler):\n            def get(self):\n                if self.get_argument(\"status\", None):\n                    self.send_error(int(self.get_argument(\"status\")))\n                else:\n                    1 / 0\n\n            def get_error_html(self, status_code, **kwargs):\n                self.set_header(\"Content-Type\", \"text/plain\")\n                if \"exception\" in kwargs:\n                    self.write(\"Exception: %s\" % sys.exc_info()[0].__name__)\n                else:\n                    self.write(\"Status: %d\" % status_code)\n\n        class FailedWriteErrorHandler(RequestHandler):\n            def get(self):\n                1 / 0\n\n            def write_error(self, status_code, **kwargs):\n                raise Exception(\"exception in write_error\")\n\n        return [url(\"/default\", DefaultHandler),\n                url(\"/write_error\", WriteErrorHandler),\n                url(\"/get_error_html\", GetErrorHtmlHandler),\n                url(\"/failed_write_error\", FailedWriteErrorHandler),\n                ]\n\n    def test_default(self):\n        with ExpectLog(app_log, \"Uncaught exception\"):\n            response = self.fetch(\"/default\")\n            self.assertEqual(response.code, 500)\n            self.assertTrue(b\"500: Internal Server Error\" in response.body)\n\n            response = self.fetch(\"/default?status=503\")\n            self.assertEqual(response.code, 503)\n            self.assertTrue(b\"503: Service Unavailable\" in response.body)\n\n    def test_write_error(self):\n        with ExpectLog(app_log, \"Uncaught exception\"):\n            response = self.fetch(\"/write_error\")\n            self.assertEqual(response.code, 500)\n            self.assertEqual(b\"Exception: ZeroDivisionError\", response.body)\n\n            response = self.fetch(\"/write_error?status=503\")\n            self.assertEqual(response.code, 503)\n            self.assertEqual(b\"Status: 503\", response.body)\n\n    def test_get_error_html(self):\n        with ExpectLog(app_log, \"Uncaught exception\"):\n            response = self.fetch(\"/get_error_html\")\n            self.assertEqual(response.code, 500)\n            self.assertEqual(b\"Exception: ZeroDivisionError\", response.body)\n\n            response = self.fetch(\"/get_error_html?status=503\")\n            self.assertEqual(response.code, 503)\n            self.assertEqual(b\"Status: 503\", response.body)\n\n    def test_failed_write_error(self):\n        with ExpectLog(app_log, \"Uncaught exception\"):\n            response = self.fetch(\"/failed_write_error\")\n            self.assertEqual(response.code, 500)\n            self.assertEqual(b\"\", response.body)\n\n\n@wsgi_safe\nclass StaticFileTest(WebTestCase):\n    # The expected MD5 hash of robots.txt, used in tests that call\n    # StaticFileHandler.get_version\n    robots_txt_hash = b\"f71d20196d4caf35b6a670db8c70b03d\"\n    static_dir = os.path.join(os.path.dirname(__file__), 'static')\n\n    def get_handlers(self):\n        class StaticUrlHandler(RequestHandler):\n            def get(self, path):\n                with_v = int(self.get_argument('include_version', 1))\n                self.write(self.static_url(path, include_version=with_v))\n\n        class AbsoluteStaticUrlHandler(StaticUrlHandler):\n            include_host = True\n\n        class OverrideStaticUrlHandler(RequestHandler):\n            def get(self, path):\n                do_include = bool(self.get_argument(\"include_host\"))\n                self.include_host = not do_include\n\n                regular_url = self.static_url(path)\n                override_url = self.static_url(path, include_host=do_include)\n                if override_url == regular_url:\n                    return self.write(str(False))\n\n                protocol = self.request.protocol + \"://\"\n                protocol_length = len(protocol)\n                check_regular = regular_url.find(protocol, 0, protocol_length)\n                check_override = override_url.find(protocol, 0, protocol_length)\n\n                if do_include:\n                    result = (check_override == 0 and check_regular == -1)\n                else:\n                    result = (check_override == -1 and check_regular == 0)\n                self.write(str(result))\n\n        return [('/static_url/(.*)', StaticUrlHandler),\n                ('/abs_static_url/(.*)', AbsoluteStaticUrlHandler),\n                ('/override_static_url/(.*)', OverrideStaticUrlHandler)]\n\n    def get_app_kwargs(self):\n        return dict(static_path=relpath('static'))\n\n    def test_static_files(self):\n        response = self.fetch('/robots.txt')\n        self.assertTrue(b\"Disallow: /\" in response.body)\n\n        response = self.fetch('/static/robots.txt')\n        self.assertTrue(b\"Disallow: /\" in response.body)\n\n    def test_static_url(self):\n        response = self.fetch(\"/static_url/robots.txt\")\n        self.assertEqual(response.body,\n                         b\"/static/robots.txt?v=\" + self.robots_txt_hash)\n\n    def test_absolute_static_url(self):\n        response = self.fetch(\"/abs_static_url/robots.txt\")\n        self.assertEqual(response.body, (\n            utf8(self.get_url(\"/\")) +\n            b\"static/robots.txt?v=\" +\n            self.robots_txt_hash\n        ))\n\n    def test_relative_version_exclusion(self):\n        response = self.fetch(\"/static_url/robots.txt?include_version=0\")\n        self.assertEqual(response.body, b\"/static/robots.txt\")\n\n    def test_absolute_version_exclusion(self):\n        response = self.fetch(\"/abs_static_url/robots.txt?include_version=0\")\n        self.assertEqual(response.body,\n                         utf8(self.get_url(\"/\") + \"static/robots.txt\"))\n\n    def test_include_host_override(self):\n        self._trigger_include_host_check(False)\n        self._trigger_include_host_check(True)\n\n    def _trigger_include_host_check(self, include_host):\n        path = \"/override_static_url/robots.txt?include_host=%s\"\n        response = self.fetch(path % int(include_host))\n        self.assertEqual(response.body, utf8(str(True)))\n\n    def test_static_304_if_modified_since(self):\n        response1 = self.fetch(\"/static/robots.txt\")\n        response2 = self.fetch(\"/static/robots.txt\", headers={\n            'If-Modified-Since': response1.headers['Last-Modified']})\n        self.assertEqual(response2.code, 304)\n        self.assertTrue('Content-Length' not in response2.headers)\n        self.assertTrue('Last-Modified' not in response2.headers)\n\n    def test_static_304_if_none_match(self):\n        response1 = self.fetch(\"/static/robots.txt\")\n        response2 = self.fetch(\"/static/robots.txt\", headers={\n            'If-None-Match': response1.headers['Etag']})\n        self.assertEqual(response2.code, 304)\n\n    def test_static_if_modified_since_pre_epoch(self):\n        # On windows, the functions that work with time_t do not accept\n        # negative values, and at least one client (processing.js) seems\n        # to use if-modified-since 1/1/1960 as a cache-busting technique.\n        response = self.fetch(\"/static/robots.txt\", headers={\n            'If-Modified-Since': 'Fri, 01 Jan 1960 00:00:00 GMT'})\n        self.assertEqual(response.code, 200)\n\n    def test_static_if_modified_since_time_zone(self):\n        # Instead of the value from Last-Modified, make requests with times\n        # chosen just before and after the known modification time\n        # of the file to ensure that the right time zone is being used\n        # when parsing If-Modified-Since.\n        stat = os.stat(relpath('static/robots.txt'))\n\n        response = self.fetch('/static/robots.txt', headers={\n            'If-Modified-Since': format_timestamp(stat.st_mtime - 1)})\n        self.assertEqual(response.code, 200)\n        response = self.fetch('/static/robots.txt', headers={\n            'If-Modified-Since': format_timestamp(stat.st_mtime + 1)})\n        self.assertEqual(response.code, 304)\n\n    def test_static_etag(self):\n        response = self.fetch('/static/robots.txt')\n        self.assertEqual(utf8(response.headers.get(\"Etag\")),\n                         b'\"' + self.robots_txt_hash + b'\"')\n\n    def test_static_with_range(self):\n        response = self.fetch('/static/robots.txt', headers={\n            'Range': 'bytes=0-9'})\n        self.assertEqual(response.code, 206)\n        self.assertEqual(response.body, b\"User-agent\")\n        self.assertEqual(utf8(response.headers.get(\"Etag\")),\n                         b'\"' + self.robots_txt_hash + b'\"')\n        self.assertEqual(response.headers.get(\"Content-Length\"), \"10\")\n        self.assertEqual(response.headers.get(\"Content-Range\"),\n                         \"bytes 0-9/26\")\n\n    def test_static_with_range_full_file(self):\n        response = self.fetch('/static/robots.txt', headers={\n            'Range': 'bytes=0-'})\n        # Note: Chrome refuses to play audio if it gets an HTTP 206 in response\n        # to ``Range: bytes=0-`` :(\n        self.assertEqual(response.code, 200)\n        robots_file_path = os.path.join(self.static_dir, \"robots.txt\")\n        with open(robots_file_path) as f:\n            self.assertEqual(response.body, utf8(f.read()))\n        self.assertEqual(response.headers.get(\"Content-Length\"), \"26\")\n        self.assertEqual(response.headers.get(\"Content-Range\"), None)\n\n    def test_static_with_range_full_past_end(self):\n        response = self.fetch('/static/robots.txt', headers={\n            'Range': 'bytes=0-10000000'})\n        self.assertEqual(response.code, 200)\n        robots_file_path = os.path.join(self.static_dir, \"robots.txt\")\n        with open(robots_file_path) as f:\n            self.assertEqual(response.body, utf8(f.read()))\n        self.assertEqual(response.headers.get(\"Content-Length\"), \"26\")\n        self.assertEqual(response.headers.get(\"Content-Range\"), None)\n\n    def test_static_with_range_partial_past_end(self):\n        response = self.fetch('/static/robots.txt', headers={\n            'Range': 'bytes=1-10000000'})\n        self.assertEqual(response.code, 206)\n        robots_file_path = os.path.join(self.static_dir, \"robots.txt\")\n        with open(robots_file_path) as f:\n            self.assertEqual(response.body, utf8(f.read()[1:]))\n        self.assertEqual(response.headers.get(\"Content-Length\"), \"25\")\n        self.assertEqual(response.headers.get(\"Content-Range\"), \"bytes 1-25/26\")\n\n    def test_static_with_range_end_edge(self):\n        response = self.fetch('/static/robots.txt', headers={\n            'Range': 'bytes=22-'})\n        self.assertEqual(response.body, b\": /\\n\")\n        self.assertEqual(response.headers.get(\"Content-Length\"), \"4\")\n        self.assertEqual(response.headers.get(\"Content-Range\"),\n                         \"bytes 22-25/26\")\n\n    def test_static_with_range_neg_end(self):\n        response = self.fetch('/static/robots.txt', headers={\n            'Range': 'bytes=-4'})\n        self.assertEqual(response.body, b\": /\\n\")\n        self.assertEqual(response.headers.get(\"Content-Length\"), \"4\")\n        self.assertEqual(response.headers.get(\"Content-Range\"),\n                         \"bytes 22-25/26\")\n\n    def test_static_invalid_range(self):\n        response = self.fetch('/static/robots.txt', headers={\n            'Range': 'asdf'})\n        self.assertEqual(response.code, 200)\n\n    def test_static_unsatisfiable_range_zero_suffix(self):\n        response = self.fetch('/static/robots.txt', headers={\n            'Range': 'bytes=-0'})\n        self.assertEqual(response.headers.get(\"Content-Range\"),\n                         \"bytes */26\")\n        self.assertEqual(response.code, 416)\n\n    def test_static_unsatisfiable_range_invalid_start(self):\n        response = self.fetch('/static/robots.txt', headers={\n            'Range': 'bytes=26'})\n        self.assertEqual(response.code, 416)\n        self.assertEqual(response.headers.get(\"Content-Range\"),\n                         \"bytes */26\")\n\n    def test_static_head(self):\n        response = self.fetch('/static/robots.txt', method='HEAD')\n        self.assertEqual(response.code, 200)\n        # No body was returned, but we did get the right content length.\n        self.assertEqual(response.body, b'')\n        self.assertEqual(response.headers['Content-Length'], '26')\n        self.assertEqual(utf8(response.headers['Etag']),\n                         b'\"' + self.robots_txt_hash + b'\"')\n\n    def test_static_head_range(self):\n        response = self.fetch('/static/robots.txt', method='HEAD',\n                              headers={'Range': 'bytes=1-4'})\n        self.assertEqual(response.code, 206)\n        self.assertEqual(response.body, b'')\n        self.assertEqual(response.headers['Content-Length'], '4')\n        self.assertEqual(utf8(response.headers['Etag']),\n                         b'\"' + self.robots_txt_hash + b'\"')\n\n    def test_static_range_if_none_match(self):\n        response = self.fetch('/static/robots.txt', headers={\n            'Range': 'bytes=1-4',\n            'If-None-Match': b'\"' + self.robots_txt_hash + b'\"'})\n        self.assertEqual(response.code, 304)\n        self.assertEqual(response.body, b'')\n        self.assertTrue('Content-Length' not in response.headers)\n        self.assertEqual(utf8(response.headers['Etag']),\n                         b'\"' + self.robots_txt_hash + b'\"')\n\n    def test_static_404(self):\n        response = self.fetch('/static/blarg')\n        self.assertEqual(response.code, 404)\n\n\n@wsgi_safe\nclass StaticDefaultFilenameTest(WebTestCase):\n    def get_app_kwargs(self):\n        return dict(static_path=relpath('static'),\n                    static_handler_args=dict(default_filename='index.html'))\n\n    def get_handlers(self):\n        return []\n\n    def test_static_default_filename(self):\n        response = self.fetch('/static/dir/', follow_redirects=False)\n        self.assertEqual(response.code, 200)\n        self.assertEqual(b'this is the index\\n', response.body)\n\n    def test_static_default_redirect(self):\n        response = self.fetch('/static/dir', follow_redirects=False)\n        self.assertEqual(response.code, 301)\n        self.assertTrue(response.headers['Location'].endswith('/static/dir/'))\n\n\n@wsgi_safe\nclass StaticFileWithPathTest(WebTestCase):\n    def get_app_kwargs(self):\n        return dict(static_path=relpath('static'),\n                    static_handler_args=dict(default_filename='index.html'))\n\n    def get_handlers(self):\n        return [(\"/foo/(.*)\", StaticFileHandler, {\n            \"path\": relpath(\"templates/\"),\n        })]\n\n    def test_serve(self):\n        response = self.fetch(\"/foo/utf8.html\")\n        self.assertEqual(response.body, b\"H\\xc3\\xa9llo\\n\")\n\n\n@wsgi_safe\nclass CustomStaticFileTest(WebTestCase):\n    def get_handlers(self):\n        class MyStaticFileHandler(StaticFileHandler):\n            @classmethod\n            def make_static_url(cls, settings, path):\n                version_hash = cls.get_version(settings, path)\n                extension_index = path.rindex('.')\n                before_version = path[:extension_index]\n                after_version = path[(extension_index + 1):]\n                return '/static/%s.%s.%s' % (before_version, version_hash,\n                                             after_version)\n\n            def parse_url_path(self, url_path):\n                extension_index = url_path.rindex('.')\n                version_index = url_path.rindex('.', 0, extension_index)\n                return '%s%s' % (url_path[:version_index],\n                                 url_path[extension_index:])\n\n            @classmethod\n            def get_absolute_path(cls, settings, path):\n                return 'CustomStaticFileTest:' + path\n\n            def validate_absolute_path(self, root, absolute_path):\n                return absolute_path\n\n            @classmethod\n            def get_content(self, path, start=None, end=None):\n                assert start is None and end is None\n                if path == 'CustomStaticFileTest:foo.txt':\n                    return b'bar'\n                raise Exception(\"unexpected path %r\" % path)\n\n            def get_modified_time(self):\n                return None\n\n            @classmethod\n            def get_version(cls, settings, path):\n                return \"42\"\n\n        class StaticUrlHandler(RequestHandler):\n            def get(self, path):\n                self.write(self.static_url(path))\n\n        self.static_handler_class = MyStaticFileHandler\n\n        return [(\"/static_url/(.*)\", StaticUrlHandler)]\n\n    def get_app_kwargs(self):\n        return dict(static_path=\"dummy\",\n                    static_handler_class=self.static_handler_class)\n\n    def test_serve(self):\n        response = self.fetch(\"/static/foo.42.txt\")\n        self.assertEqual(response.body, b\"bar\")\n\n    def test_static_url(self):\n        with ExpectLog(gen_log, \"Could not open static file\", required=False):\n            response = self.fetch(\"/static_url/foo.txt\")\n            self.assertEqual(response.body, b\"/static/foo.42.txt\")\n\n\n@wsgi_safe\nclass HostMatchingTest(WebTestCase):\n    class Handler(RequestHandler):\n        def initialize(self, reply):\n            self.reply = reply\n\n        def get(self):\n            self.write(self.reply)\n\n    def get_handlers(self):\n        return [(\"/foo\", HostMatchingTest.Handler, {\"reply\": \"wildcard\"})]\n\n    def test_host_matching(self):\n        self.app.add_handlers(\"www.example.com\",\n                              [(\"/foo\", HostMatchingTest.Handler, {\"reply\": \"[0]\"})])\n        self.app.add_handlers(r\"www\\.example\\.com\",\n                              [(\"/bar\", HostMatchingTest.Handler, {\"reply\": \"[1]\"})])\n        self.app.add_handlers(\"www.example.com\",\n                              [(\"/baz\", HostMatchingTest.Handler, {\"reply\": \"[2]\"})])\n\n        response = self.fetch(\"/foo\")\n        self.assertEqual(response.body, b\"wildcard\")\n        response = self.fetch(\"/bar\")\n        self.assertEqual(response.code, 404)\n        response = self.fetch(\"/baz\")\n        self.assertEqual(response.code, 404)\n\n        response = self.fetch(\"/foo\", headers={'Host': 'www.example.com'})\n        self.assertEqual(response.body, b\"[0]\")\n        response = self.fetch(\"/bar\", headers={'Host': 'www.example.com'})\n        self.assertEqual(response.body, b\"[1]\")\n        response = self.fetch(\"/baz\", headers={'Host': 'www.example.com'})\n        self.assertEqual(response.body, b\"[2]\")\n\n\n@wsgi_safe\nclass NamedURLSpecGroupsTest(WebTestCase):\n    def get_handlers(self):\n        class EchoHandler(RequestHandler):\n            def get(self, path):\n                self.write(path)\n\n        return [(\"/str/(?P<path>.*)\", EchoHandler),\n                (u(\"/unicode/(?P<path>.*)\"), EchoHandler)]\n\n    def test_named_urlspec_groups(self):\n        response = self.fetch(\"/str/foo\")\n        self.assertEqual(response.body, b\"foo\")\n\n        response = self.fetch(\"/unicode/bar\")\n        self.assertEqual(response.body, b\"bar\")\n\n\n@wsgi_safe\nclass ClearHeaderTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def get(self):\n            self.set_header(\"h1\", \"foo\")\n            self.set_header(\"h2\", \"bar\")\n            self.clear_header(\"h1\")\n            self.clear_header(\"nonexistent\")\n\n    def test_clear_header(self):\n        response = self.fetch(\"/\")\n        self.assertTrue(\"h1\" not in response.headers)\n        self.assertEqual(response.headers[\"h2\"], \"bar\")\n\n\n@wsgi_safe\nclass Header304Test(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def get(self):\n            self.set_header(\"Content-Language\", \"en_US\")\n            self.write(\"hello\")\n\n    def test_304_headers(self):\n        response1 = self.fetch('/')\n        self.assertEqual(response1.headers[\"Content-Length\"], \"5\")\n        self.assertEqual(response1.headers[\"Content-Language\"], \"en_US\")\n\n        response2 = self.fetch('/', headers={\n            'If-None-Match': response1.headers[\"Etag\"]})\n        self.assertEqual(response2.code, 304)\n        self.assertTrue(\"Content-Length\" not in response2.headers)\n        self.assertTrue(\"Content-Language\" not in response2.headers)\n        # Not an entity header, but should not be added to 304s by chunking\n        self.assertTrue(\"Transfer-Encoding\" not in response2.headers)\n\n\n@wsgi_safe\nclass StatusReasonTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def get(self):\n            reason = self.request.arguments.get('reason', [])\n            self.set_status(int(self.get_argument('code')),\n                            reason=reason[0] if reason else None)\n\n    def get_http_client(self):\n        # simple_httpclient only: curl doesn't expose the reason string\n        return SimpleAsyncHTTPClient(io_loop=self.io_loop)\n\n    def test_status(self):\n        response = self.fetch(\"/?code=304\")\n        self.assertEqual(response.code, 304)\n        self.assertEqual(response.reason, \"Not Modified\")\n        response = self.fetch(\"/?code=304&reason=Foo\")\n        self.assertEqual(response.code, 304)\n        self.assertEqual(response.reason, \"Foo\")\n        response = self.fetch(\"/?code=682&reason=Bar\")\n        self.assertEqual(response.code, 682)\n        self.assertEqual(response.reason, \"Bar\")\n        with ExpectLog(app_log, 'Uncaught exception'):\n            response = self.fetch(\"/?code=682\")\n        self.assertEqual(response.code, 500)\n\n\n@wsgi_safe\nclass DateHeaderTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def get(self):\n            self.write(\"hello\")\n\n    def test_date_header(self):\n        response = self.fetch('/')\n        header_date = datetime.datetime(\n            *email.utils.parsedate(response.headers['Date'])[:6])\n        self.assertTrue(header_date - datetime.datetime.utcnow() <\n                        datetime.timedelta(seconds=2))\n\n\n@wsgi_safe\nclass RaiseWithReasonTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def get(self):\n            raise HTTPError(682, reason=\"Foo\")\n\n    def get_http_client(self):\n        # simple_httpclient only: curl doesn't expose the reason string\n        return SimpleAsyncHTTPClient(io_loop=self.io_loop)\n\n    def test_raise_with_reason(self):\n        response = self.fetch(\"/\")\n        self.assertEqual(response.code, 682)\n        self.assertEqual(response.reason, \"Foo\")\n        self.assertIn(b'682: Foo', response.body)\n\n    def test_httperror_str(self):\n        self.assertEqual(str(HTTPError(682, reason=\"Foo\")), \"HTTP 682: Foo\")\n\n\n@wsgi_safe\nclass ErrorHandlerXSRFTest(WebTestCase):\n    def get_handlers(self):\n        # note that if the handlers list is empty we get the default_host\n        # redirect fallback instead of a 404, so test with both an\n        # explicitly defined error handler and an implicit 404.\n        return [('/error', ErrorHandler, dict(status_code=417))]\n\n    def get_app_kwargs(self):\n        return dict(xsrf_cookies=True)\n\n    def test_error_xsrf(self):\n        response = self.fetch('/error', method='POST', body='')\n        self.assertEqual(response.code, 417)\n\n    def test_404_xsrf(self):\n        response = self.fetch('/404', method='POST', body='')\n        self.assertEqual(response.code, 404)\n\n\nclass GzipTestCase(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def get(self):\n            if self.get_argument('vary', None):\n                self.set_header('Vary', self.get_argument('vary'))\n            self.write('hello world')\n\n    def get_app_kwargs(self):\n        return dict(gzip=True)\n\n    def test_gzip(self):\n        response = self.fetch('/')\n        self.assertEqual(response.headers['Content-Encoding'], 'gzip')\n        self.assertEqual(response.headers['Vary'], 'Accept-Encoding')\n\n    def test_gzip_not_requested(self):\n        response = self.fetch('/', use_gzip=False)\n        self.assertNotIn('Content-Encoding', response.headers)\n        self.assertEqual(response.headers['Vary'], 'Accept-Encoding')\n\n    def test_vary_already_present(self):\n        response = self.fetch('/?vary=Accept-Language')\n        self.assertEqual(response.headers['Vary'],\n                         'Accept-Language, Accept-Encoding')\n\n\n@wsgi_safe\nclass PathArgsInPrepareTest(WebTestCase):\n    class Handler(RequestHandler):\n        def prepare(self):\n            self.write(dict(args=self.path_args, kwargs=self.path_kwargs))\n\n        def get(self, path):\n            assert path == 'foo'\n            self.finish()\n\n    def get_handlers(self):\n        return [('/pos/(.*)', self.Handler),\n                ('/kw/(?P<path>.*)', self.Handler)]\n\n    def test_pos(self):\n        response = self.fetch('/pos/foo')\n        response.rethrow()\n        data = json_decode(response.body)\n        self.assertEqual(data, {'args': ['foo'], 'kwargs': {}})\n\n    def test_kw(self):\n        response = self.fetch('/kw/foo')\n        response.rethrow()\n        data = json_decode(response.body)\n        self.assertEqual(data, {'args': [], 'kwargs': {'path': 'foo'}})\n\n\n@wsgi_safe\nclass ClearAllCookiesTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def get(self):\n            self.clear_all_cookies()\n            self.write('ok')\n\n    def test_clear_all_cookies(self):\n        response = self.fetch('/', headers={'Cookie': 'foo=bar; baz=xyzzy'})\n        set_cookies = sorted(response.headers.get_list('Set-Cookie'))\n        self.assertTrue(set_cookies[0].startswith('baz=;'))\n        self.assertTrue(set_cookies[1].startswith('foo=;'))\n\n\nclass PermissionError(Exception):\n    pass\n\n\n@wsgi_safe\nclass ExceptionHandlerTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def get(self):\n            exc = self.get_argument('exc')\n            if exc == 'http':\n                raise HTTPError(410, \"no longer here\")\n            elif exc == 'zero':\n                1 / 0\n            elif exc == 'permission':\n                raise PermissionError('not allowed')\n\n        def write_error(self, status_code, **kwargs):\n            if 'exc_info' in kwargs:\n                typ, value, tb = kwargs['exc_info']\n                if isinstance(value, PermissionError):\n                    self.set_status(403)\n                    self.write('PermissionError')\n                    return\n            RequestHandler.write_error(self, status_code, **kwargs)\n\n        def log_exception(self, typ, value, tb):\n            if isinstance(value, PermissionError):\n                app_log.warning('custom logging for PermissionError: %s',\n                                value.args[0])\n            else:\n                RequestHandler.log_exception(self, typ, value, tb)\n\n    def test_http_error(self):\n        # HTTPErrors are logged as warnings with no stack trace.\n        # TODO: extend ExpectLog to test this more precisely\n        with ExpectLog(gen_log, '.*no longer here'):\n            response = self.fetch('/?exc=http')\n            self.assertEqual(response.code, 410)\n\n    def test_unknown_error(self):\n        # Unknown errors are logged as errors with a stack trace.\n        with ExpectLog(app_log, 'Uncaught exception'):\n            response = self.fetch('/?exc=zero')\n            self.assertEqual(response.code, 500)\n\n    def test_known_error(self):\n        # log_exception can override logging behavior, and write_error\n        # can override the response.\n        with ExpectLog(app_log,\n                       'custom logging for PermissionError: not allowed'):\n            response = self.fetch('/?exc=permission')\n            self.assertEqual(response.code, 403)\n\n\n@wsgi_safe\nclass UIMethodUIModuleTest(SimpleHandlerTestCase):\n    \"\"\"Test that UI methods and modules are created correctly and\n    associated with the handler.\n    \"\"\"\n    class Handler(RequestHandler):\n        def get(self):\n            self.render('foo.html')\n\n        def value(self):\n            return self.get_argument(\"value\")\n\n    def get_app_kwargs(self):\n        def my_ui_method(handler, x):\n            return \"In my_ui_method(%s) with handler value %s.\" % (\n                x, handler.value())\n        class MyModule(UIModule):\n            def render(self, x):\n                return \"In MyModule(%s) with handler value %s.\" % (\n                    x, self.handler.value())\n\n        loader = DictLoader({\n            'foo.html': '{{ my_ui_method(42) }} {% module MyModule(123) %}',\n        })\n        return dict(template_loader=loader,\n                    ui_methods={'my_ui_method': my_ui_method},\n                    ui_modules={'MyModule': MyModule})\n\n    def tearDown(self):\n        super(UIMethodUIModuleTest, self).tearDown()\n        # TODO: fix template loader caching so this isn't necessary.\n        RequestHandler._template_loaders.clear()\n\n    def test_ui_method(self):\n        response = self.fetch('/?value=asdf')\n        self.assertEqual(response.body,\n                         b'In my_ui_method(42) with handler value asdf. '\n                         b'In MyModule(123) with handler value asdf.')\n\n\n@wsgi_safe\nclass GetArgumentErrorTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def get(self):\n            try:\n                self.get_argument('foo')\n                self.write({})\n            except MissingArgumentError as e:\n                self.write({'arg_name': e.arg_name,\n                            'log_message': e.log_message})\n\n    def test_catch_error(self):\n        response = self.fetch('/')\n        self.assertEqual(json_decode(response.body),\n                         {'arg_name': 'foo',\n                          'log_message': 'Missing argument foo'})\n\n\nclass MultipleExceptionTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        exc_count = 0\n\n        @asynchronous\n        def get(self):\n            from tornado.ioloop import IOLoop\n            IOLoop.current().add_callback(lambda: 1 / 0)\n            IOLoop.current().add_callback(lambda: 1 / 0)\n\n        def log_exception(self, typ, value, tb):\n            MultipleExceptionTest.Handler.exc_count += 1\n\n    def test_multi_exception(self):\n        # This test verifies that multiple exceptions raised into the same\n        # ExceptionStackContext do not generate extraneous log entries\n        # due to \"Cannot send error response after headers written\".\n        # log_exception is called, but it does not proceed to send_error.\n        response = self.fetch('/')\n        self.assertEqual(response.code, 500)\n        response = self.fetch('/')\n        self.assertEqual(response.code, 500)\n        # Each of our two requests generated two exceptions, we should have\n        # seen at least three of them by now (the fourth may still be\n        # in the queue).\n        self.assertGreater(MultipleExceptionTest.Handler.exc_count, 2)\n\n\n@wsgi_safe\nclass SetCurrentUserTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def prepare(self):\n            self.current_user = 'Ben'\n\n        def get(self):\n            self.write('Hello %s' % self.current_user)\n\n    def test_set_current_user(self):\n        # Ensure that current_user can be assigned to normally for apps\n        # that want to forgo the lazy get_current_user property\n        response = self.fetch('/')\n        self.assertEqual(response.body, b'Hello Ben')\n\n\n@wsgi_safe\nclass GetCurrentUserTest(WebTestCase):\n    def get_app_kwargs(self):\n        class WithoutUserModule(UIModule):\n            def render(self):\n                return ''\n\n        class WithUserModule(UIModule):\n            def render(self):\n                return str(self.current_user)\n\n        loader = DictLoader({\n            'without_user.html': '',\n            'with_user.html': '{{ current_user }}',\n            'without_user_module.html': '{% module WithoutUserModule() %}',\n            'with_user_module.html': '{% module WithUserModule() %}',\n        })\n        return dict(template_loader=loader,\n                    ui_modules={'WithUserModule': WithUserModule,\n                                'WithoutUserModule': WithoutUserModule})\n\n    def tearDown(self):\n        super(GetCurrentUserTest, self).tearDown()\n        RequestHandler._template_loaders.clear()\n\n    def get_handlers(self):\n        class CurrentUserHandler(RequestHandler):\n            def prepare(self):\n                self.has_loaded_current_user = False\n\n            def get_current_user(self):\n                self.has_loaded_current_user = True\n                return ''\n\n        class WithoutUserHandler(CurrentUserHandler):\n            def get(self):\n                self.render_string('without_user.html')\n                self.finish(str(self.has_loaded_current_user))\n\n        class WithUserHandler(CurrentUserHandler):\n            def get(self):\n                self.render_string('with_user.html')\n                self.finish(str(self.has_loaded_current_user))\n\n        class CurrentUserModuleHandler(CurrentUserHandler):\n            def get_template_namespace(self):\n                # If RequestHandler.get_template_namespace is called, then\n                # get_current_user is evaluated. Until #820 is fixed, this\n                # is a small hack to circumvent the issue.\n                return self.ui\n\n        class WithoutUserModuleHandler(CurrentUserModuleHandler):\n            def get(self):\n                self.render_string('without_user_module.html')\n                self.finish(str(self.has_loaded_current_user))\n\n        class WithUserModuleHandler(CurrentUserModuleHandler):\n            def get(self):\n                self.render_string('with_user_module.html')\n                self.finish(str(self.has_loaded_current_user))\n\n        return [('/without_user', WithoutUserHandler),\n                ('/with_user', WithUserHandler),\n                ('/without_user_module', WithoutUserModuleHandler),\n                ('/with_user_module', WithUserModuleHandler)]\n\n    @unittest.skip('needs fix')\n    def test_get_current_user_is_lazy(self):\n        # TODO: Make this test pass. See #820.\n        response = self.fetch('/without_user')\n        self.assertEqual(response.body, b'False')\n\n    def test_get_current_user_works(self):\n        response = self.fetch('/with_user')\n        self.assertEqual(response.body, b'True')\n\n    def test_get_current_user_from_ui_module_is_lazy(self):\n        response = self.fetch('/without_user_module')\n        self.assertEqual(response.body, b'False')\n\n    def test_get_current_user_from_ui_module_works(self):\n        response = self.fetch('/with_user_module')\n        self.assertEqual(response.body, b'True')\n\n\n@wsgi_safe\nclass UnimplementedHTTPMethodsTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        pass\n\n    def test_unimplemented_standard_methods(self):\n        for method in ['HEAD', 'GET', 'DELETE', 'OPTIONS']:\n            response = self.fetch('/', method=method)\n            self.assertEqual(response.code, 405)\n        for method in ['POST', 'PUT']:\n            response = self.fetch('/', method=method, body=b'')\n            self.assertEqual(response.code, 405)\n\n\nclass UnimplementedNonStandardMethodsTest(SimpleHandlerTestCase):\n    # wsgiref.validate complains about unknown methods in a way that makes\n    # this test not wsgi_safe.\n    class Handler(RequestHandler):\n        def other(self):\n            # Even though this method exists, it won't get called automatically\n            # because it is not in SUPPORTED_METHODS.\n            self.write('other')\n\n    def test_unimplemented_patch(self):\n        # PATCH is recently standardized; Tornado supports it by default\n        # but wsgiref.validate doesn't like it.\n        response = self.fetch('/', method='PATCH', body=b'')\n        self.assertEqual(response.code, 405)\n\n    def test_unimplemented_other(self):\n        response = self.fetch('/', method='OTHER',\n                              allow_nonstandard_methods=True)\n        self.assertEqual(response.code, 405)\n\n\n@wsgi_safe\nclass AllHTTPMethodsTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def method(self):\n            self.write(self.request.method)\n\n        get = delete = options = post = put = method\n\n    def test_standard_methods(self):\n        response = self.fetch('/', method='HEAD')\n        self.assertEqual(response.body, b'')\n        for method in ['GET', 'DELETE', 'OPTIONS']:\n            response = self.fetch('/', method=method)\n            self.assertEqual(response.body, utf8(method))\n        for method in ['POST', 'PUT']:\n            response = self.fetch('/', method=method, body=b'')\n            self.assertEqual(response.body, utf8(method))\n\n\nclass PatchMethodTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        SUPPORTED_METHODS = RequestHandler.SUPPORTED_METHODS + ('OTHER',)\n\n        def patch(self):\n            self.write('patch')\n\n        def other(self):\n            self.write('other')\n\n    def test_patch(self):\n        response = self.fetch('/', method='PATCH', body=b'')\n        self.assertEqual(response.body, b'patch')\n\n    def test_other(self):\n        response = self.fetch('/', method='OTHER',\n                              allow_nonstandard_methods=True)\n        self.assertEqual(response.body, b'other')\n\n\n@wsgi_safe\nclass FinishInPrepareTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def prepare(self):\n            self.finish('done')\n\n        def get(self):\n            # It's difficult to assert for certain that a method did not\n            # or will not be called in an asynchronous context, but this\n            # will be logged noisily if it is reached.\n            raise Exception('should not reach this method')\n\n    def test_finish_in_prepare(self):\n        response = self.fetch('/')\n        self.assertEqual(response.body, b'done')\n\n\n@wsgi_safe\nclass Default404Test(WebTestCase):\n    def get_handlers(self):\n        # If there are no handlers at all a default redirect handler gets added.\n        return [('/foo', RequestHandler)]\n\n    def test_404(self):\n        response = self.fetch('/')\n        self.assertEqual(response.code, 404)\n        self.assertEqual(response.body,\n                         b'<html><title>404: Not Found</title>'\n                         b'<body>404: Not Found</body></html>')\n\n\n@wsgi_safe\nclass Custom404Test(WebTestCase):\n    def get_handlers(self):\n        return [('/foo', RequestHandler)]\n\n    def get_app_kwargs(self):\n        class Custom404Handler(RequestHandler):\n            def get(self):\n                self.set_status(404)\n                self.write('custom 404 response')\n\n        return dict(default_handler_class=Custom404Handler)\n\n    def test_404(self):\n        response = self.fetch('/')\n        self.assertEqual(response.code, 404)\n        self.assertEqual(response.body, b'custom 404 response')\n\n\n@wsgi_safe\nclass DefaultHandlerArgumentsTest(WebTestCase):\n    def get_handlers(self):\n        return [('/foo', RequestHandler)]\n\n    def get_app_kwargs(self):\n        return dict(default_handler_class=ErrorHandler,\n                    default_handler_args=dict(status_code=403))\n\n    def test_403(self):\n        response = self.fetch('/')\n        self.assertEqual(response.code, 403)\n\n\n@wsgi_safe\nclass HandlerByNameTest(WebTestCase):\n    def get_handlers(self):\n        # All three are equivalent.\n        return [('/hello1', HelloHandler),\n                ('/hello2', 'tornado.test.web_test.HelloHandler'),\n                url('/hello3', 'tornado.test.web_test.HelloHandler'),\n                ]\n\n    def test_handler_by_name(self):\n        resp = self.fetch('/hello1')\n        self.assertEqual(resp.body, b'hello')\n        resp = self.fetch('/hello2')\n        self.assertEqual(resp.body, b'hello')\n        resp = self.fetch('/hello3')\n        self.assertEqual(resp.body, b'hello')\n\n\nclass SignedValueTest(unittest.TestCase):\n    SECRET = \"It's a secret to everybody\"\n\n    def past(self):\n        return self.present() - 86400 * 32\n\n    def present(self):\n        return 1300000000\n\n    def test_known_values(self):\n        signed_v1 = create_signed_value(SignedValueTest.SECRET, \"key\", \"value\",\n                                        version=1, clock=self.present)\n        self.assertEqual(\n            signed_v1,\n            b\"dmFsdWU=|1300000000|31c934969f53e48164c50768b40cbd7e2daaaa4f\")\n\n        signed_v2 = create_signed_value(SignedValueTest.SECRET, \"key\", \"value\",\n                                        version=2, clock=self.present)\n        self.assertEqual(\n            signed_v2,\n            b\"2|1:0|10:1300000000|3:key|8:dmFsdWU=|\"\n            b\"3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e152\")\n\n        signed_default = create_signed_value(SignedValueTest.SECRET,\n                                             \"key\", \"value\", clock=self.present)\n        self.assertEqual(signed_default, signed_v2)\n\n        decoded_v1 = decode_signed_value(SignedValueTest.SECRET, \"key\",\n                                         signed_v1, min_version=1,\n                                         clock=self.present)\n        self.assertEqual(decoded_v1, b\"value\")\n\n        decoded_v2 = decode_signed_value(SignedValueTest.SECRET, \"key\",\n                                         signed_v2, min_version=2,\n                                         clock=self.present)\n        self.assertEqual(decoded_v2, b\"value\")\n\n    def test_name_swap(self):\n        signed1 = create_signed_value(SignedValueTest.SECRET, \"key1\", \"value\",\n                                      clock=self.present)\n        signed2 = create_signed_value(SignedValueTest.SECRET, \"key2\", \"value\",\n                                      clock=self.present)\n        # Try decoding each string with the other's \"name\"\n        decoded1 = decode_signed_value(SignedValueTest.SECRET, \"key2\", signed1,\n                                       clock=self.present)\n        self.assertIs(decoded1, None)\n        decoded2 = decode_signed_value(SignedValueTest.SECRET, \"key1\", signed2,\n                                       clock=self.present)\n        self.assertIs(decoded2, None)\n\n    def test_expired(self):\n        signed = create_signed_value(SignedValueTest.SECRET, \"key1\", \"value\",\n                                     clock=self.past)\n        decoded_past = decode_signed_value(SignedValueTest.SECRET, \"key1\",\n                                           signed, clock=self.past)\n        self.assertEqual(decoded_past, b\"value\")\n        decoded_present = decode_signed_value(SignedValueTest.SECRET, \"key1\",\n                                              signed, clock=self.present)\n        self.assertIs(decoded_present, None)\n\n    def test_payload_tampering(self):\n        # These cookies are variants of the one in test_known_values.\n        sig = \"3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e152\"\n        def validate(prefix):\n            return (b'value' ==\n                    decode_signed_value(SignedValueTest.SECRET, \"key\",\n                                        prefix + sig, clock=self.present))\n        self.assertTrue(validate(\"2|1:0|10:1300000000|3:key|8:dmFsdWU=|\"))\n        # Change key version\n        self.assertFalse(validate(\"2|1:1|10:1300000000|3:key|8:dmFsdWU=|\"))\n        # length mismatch (field too short)\n        self.assertFalse(validate(\"2|1:0|10:130000000|3:key|8:dmFsdWU=|\"))\n        # length mismatch (field too long)\n        self.assertFalse(validate(\"2|1:0|10:1300000000|3:keey|8:dmFsdWU=|\"))\n\n    def test_signature_tampering(self):\n        prefix = \"2|1:0|10:1300000000|3:key|8:dmFsdWU=|\"\n        def validate(sig):\n            return (b'value' ==\n                    decode_signed_value(SignedValueTest.SECRET, \"key\",\n                                        prefix + sig, clock=self.present))\n        self.assertTrue(validate(\n            \"3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e152\"))\n        # All zeros\n        self.assertFalse(validate(\"0\" * 32))\n        # Change one character\n        self.assertFalse(validate(\n            \"4d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e152\"))\n        # Change another character\n        self.assertFalse(validate(\n            \"3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e153\"))\n        # Truncate\n        self.assertFalse(validate(\n            \"3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e15\"))\n        # Lengthen\n        self.assertFalse(validate(\n            \"3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e1538\"))\n\n    def test_non_ascii(self):\n        value = b\"\\xe9\"\n        signed = create_signed_value(SignedValueTest.SECRET, \"key\", value,\n                                     clock=self.present)\n        decoded = decode_signed_value(SignedValueTest.SECRET, \"key\", signed,\n                                      clock=self.present)\n        self.assertEqual(value, decoded)\n\n\n@wsgi_safe\nclass XSRFTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def get(self):\n            self.write(self.xsrf_token)\n\n        def post(self):\n            self.write(\"ok\")\n\n    def get_app_kwargs(self):\n        return dict(xsrf_cookies=True)\n\n    def setUp(self):\n        super(XSRFTest, self).setUp()\n        self.xsrf_token = self.get_token()\n\n    def get_token(self, old_token=None):\n        if old_token is not None:\n            headers = self.cookie_headers(old_token)\n        else:\n            headers = None\n        response = self.fetch(\"/\", headers=headers)\n        response.rethrow()\n        return native_str(response.body)\n\n    def cookie_headers(self, token=None):\n        if token is None:\n            token = self.xsrf_token\n        return {\"Cookie\": \"_xsrf=\" + token}\n\n    def test_xsrf_fail_no_token(self):\n        with ExpectLog(gen_log, \".*'_xsrf' argument missing\"):\n            response = self.fetch(\"/\", method=\"POST\", body=b\"\")\n        self.assertEqual(response.code, 403)\n\n    def test_xsrf_fail_body_no_cookie(self):\n        with ExpectLog(gen_log, \".*XSRF cookie does not match POST\"):\n            response = self.fetch(\n                \"/\", method=\"POST\",\n                body=urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)))\n        self.assertEqual(response.code, 403)\n\n    def test_xsrf_fail_cookie_no_body(self):\n        with ExpectLog(gen_log, \".*'_xsrf' argument missing\"):\n            response = self.fetch(\n                \"/\", method=\"POST\", body=b\"\",\n                headers=self.cookie_headers())\n        self.assertEqual(response.code, 403)\n\n    def test_xsrf_success_post_body(self):\n        response = self.fetch(\n            \"/\", method=\"POST\",\n            body=urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)),\n            headers=self.cookie_headers())\n        self.assertEqual(response.code, 200)\n\n    def test_xsrf_success_query_string(self):\n        response = self.fetch(\n            \"/?\" + urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)),\n            method=\"POST\", body=b\"\",\n            headers=self.cookie_headers())\n        self.assertEqual(response.code, 200)\n\n    def test_xsrf_success_header(self):\n        response = self.fetch(\"/\", method=\"POST\", body=b\"\",\n                              headers=dict({\"X-Xsrftoken\": self.xsrf_token},\n                                           **self.cookie_headers()))\n        self.assertEqual(response.code, 200)\n\n    def test_distinct_tokens(self):\n        # Every request gets a distinct token.\n        NUM_TOKENS = 10\n        tokens = set()\n        for i in range(NUM_TOKENS):\n            tokens.add(self.get_token())\n        self.assertEqual(len(tokens), NUM_TOKENS)\n\n    def test_cross_user(self):\n        token2 = self.get_token()\n        # Each token can be used to authenticate its own request.\n        for token in (self.xsrf_token, token2):\n            response  = self.fetch(\n                \"/\", method=\"POST\",\n                body=urllib_parse.urlencode(dict(_xsrf=token)),\n                headers=self.cookie_headers(token))\n            self.assertEqual(response.code, 200)\n        # Sending one in the cookie and the other in the body is not allowed.\n        for cookie_token, body_token in ((self.xsrf_token, token2),\n                                         (token2, self.xsrf_token)):\n            with ExpectLog(gen_log, '.*XSRF cookie does not match POST'):\n                response = self.fetch(\n                    \"/\", method=\"POST\",\n                    body=urllib_parse.urlencode(dict(_xsrf=body_token)),\n                    headers=self.cookie_headers(cookie_token))\n            self.assertEqual(response.code, 403)\n\n    def test_refresh_token(self):\n        token = self.xsrf_token\n        # A user's token is stable over time.  Refreshing the page in one tab\n        # might update the cookie while an older tab still has the old cookie\n        # in its DOM.  Simulate this scenario by passing a constant token\n        # in the body and re-querying for the token.\n        for i in range(5):\n            token = self.get_token(token)\n            # Implementation detail: the same token is returned each time\n            self.assertEqual(token, self.xsrf_token)\n            response = self.fetch(\n                \"/\", method=\"POST\",\n                body=urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)),\n                headers=self.cookie_headers(token))\n            self.assertEqual(response.code, 200)\n", "from __future__ import absolute_import, division, print_function, with_statement\n\nimport traceback\n\nfrom tornado.concurrent import Future\nfrom tornado.httpclient import HTTPError, HTTPRequest\nfrom tornado.log import gen_log\nfrom tornado.testing import AsyncHTTPTestCase, gen_test, bind_unused_port, ExpectLog\nfrom tornado.test.util import unittest, skipOnTravis\nfrom tornado.web import Application, RequestHandler\n\ntry:\n    import tornado.websocket\nexcept ImportError:\n    # The unittest module presents misleading errors on ImportError\n    # (it acts as if websocket_test could not be found, hiding the underlying\n    # error).  If we get an ImportError here (which could happen due to\n    # TORNADO_EXTENSION=1), print some extra information before failing.\n    traceback.print_exc()\n    raise\n\nfrom tornado.websocket import WebSocketHandler, websocket_connect, WebSocketError, _websocket_mask_python\n\ntry:\n    from tornado import speedups\nexcept ImportError:\n    speedups = None\n\n\nclass TestWebSocketHandler(WebSocketHandler):\n    \"\"\"Base class for testing handlers that exposes the on_close event.\n\n    This allows for deterministic cleanup of the associated socket.\n    \"\"\"\n    def initialize(self, close_future):\n        self.close_future = close_future\n\n    def on_close(self):\n        self.close_future.set_result(None)\n\n\nclass EchoHandler(TestWebSocketHandler):\n    def on_message(self, message):\n        self.write_message(message, isinstance(message, bytes))\n\n\nclass HeaderHandler(TestWebSocketHandler):\n    def open(self):\n        self.write_message(self.request.headers.get('X-Test', ''))\n\n\nclass NonWebSocketHandler(RequestHandler):\n    def get(self):\n        self.write('ok')\n\n\nclass WebSocketTest(AsyncHTTPTestCase):\n    def get_app(self):\n        self.close_future = Future()\n        return Application([\n            ('/echo', EchoHandler, dict(close_future=self.close_future)),\n            ('/non_ws', NonWebSocketHandler),\n            ('/header', HeaderHandler, dict(close_future=self.close_future)),\n        ])\n\n    @gen_test\n    def test_websocket_gen(self):\n        ws = yield websocket_connect(\n            'ws://localhost:%d/echo' % self.get_http_port(),\n            io_loop=self.io_loop)\n        ws.write_message('hello')\n        response = yield ws.read_message()\n        self.assertEqual(response, 'hello')\n        ws.close()\n        yield self.close_future\n\n    def test_websocket_callbacks(self):\n        websocket_connect(\n            'ws://localhost:%d/echo' % self.get_http_port(),\n            io_loop=self.io_loop, callback=self.stop)\n        ws = self.wait().result()\n        ws.write_message('hello')\n        ws.read_message(self.stop)\n        response = self.wait().result()\n        self.assertEqual(response, 'hello')\n        ws.close()\n        yield self.close_future\n\n    @gen_test\n    def test_websocket_http_fail(self):\n        with self.assertRaises(HTTPError) as cm:\n            yield websocket_connect(\n                'ws://localhost:%d/notfound' % self.get_http_port(),\n                io_loop=self.io_loop)\n        self.assertEqual(cm.exception.code, 404)\n\n    @gen_test\n    def test_websocket_http_success(self):\n        with self.assertRaises(WebSocketError):\n            yield websocket_connect(\n                'ws://localhost:%d/non_ws' % self.get_http_port(),\n                io_loop=self.io_loop)\n\n    @skipOnTravis\n    @gen_test\n    def test_websocket_network_timeout(self):\n        sock, port = bind_unused_port()\n        sock.close()\n        with self.assertRaises(HTTPError) as cm:\n            with ExpectLog(gen_log, \".*\"):\n                yield websocket_connect(\n                    'ws://localhost:%d/' % port,\n                    io_loop=self.io_loop,\n                    connect_timeout=0.01)\n        self.assertEqual(cm.exception.code, 599)\n\n    @gen_test\n    def test_websocket_network_fail(self):\n        sock, port = bind_unused_port()\n        sock.close()\n        with self.assertRaises(HTTPError) as cm:\n            with ExpectLog(gen_log, \".*\"):\n                yield websocket_connect(\n                    'ws://localhost:%d/' % port,\n                    io_loop=self.io_loop,\n                    connect_timeout=3600)\n        self.assertEqual(cm.exception.code, 599)\n\n    @gen_test\n    def test_websocket_close_buffered_data(self):\n        ws = yield websocket_connect(\n            'ws://localhost:%d/echo' % self.get_http_port())\n        ws.write_message('hello')\n        ws.write_message('world')\n        ws.stream.close()\n        yield self.close_future\n\n    @gen_test\n    def test_websocket_headers(self):\n        # Ensure that arbitrary headers can be passed through websocket_connect.\n        ws = yield websocket_connect(\n            HTTPRequest('ws://localhost:%d/header' % self.get_http_port(),\n                        headers={'X-Test': 'hello'}))\n        response = yield ws.read_message()\n        self.assertEqual(response, 'hello')\n        ws.close()\n        yield self.close_future\n\n\nclass MaskFunctionMixin(object):\n    # Subclasses should define self.mask(mask, data)\n    def test_mask(self):\n        self.assertEqual(self.mask(b'abcd', b''), b'')\n        self.assertEqual(self.mask(b'abcd', b'b'), b'\\x03')\n        self.assertEqual(self.mask(b'abcd', b'54321'), b'TVPVP')\n        self.assertEqual(self.mask(b'ZXCV', b'98765432'), b'c`t`olpd')\n        # Include test cases with \\x00 bytes (to ensure that the C\n        # extension isn't depending on null-terminated strings) and\n        # bytes with the high bit set (to smoke out signedness issues).\n        self.assertEqual(self.mask(b'\\x00\\x01\\x02\\x03',\n                                   b'\\xff\\xfb\\xfd\\xfc\\xfe\\xfa'),\n                         b'\\xff\\xfa\\xff\\xff\\xfe\\xfb')\n        self.assertEqual(self.mask(b'\\xff\\xfb\\xfd\\xfc',\n                                   b'\\x00\\x01\\x02\\x03\\x04\\x05'),\n                         b'\\xff\\xfa\\xff\\xff\\xfb\\xfe')\n\n\nclass PythonMaskFunctionTest(MaskFunctionMixin, unittest.TestCase):\n    def mask(self, mask, data):\n        return _websocket_mask_python(mask, data)\n\n\n@unittest.skipIf(speedups is None, \"tornado.speedups module not present\")\nclass CythonMaskFunctionTest(MaskFunctionMixin, unittest.TestCase):\n    def mask(self, mask, data):\n        return speedups.websocket_mask(mask, data)\n", "\"\"\"Miscellaneous utility functions and classes.\n\nThis module is used internally by Tornado.  It is not necessarily expected\nthat the functions and classes defined here will be useful to other\napplications, but they are documented here in case they are.\n\nThe one public-facing part of this module is the `Configurable` class\nand its `~Configurable.configure` method, which becomes a part of the\ninterface of its subclasses, including `.AsyncHTTPClient`, `.IOLoop`,\nand `.Resolver`.\n\"\"\"\n\nfrom __future__ import absolute_import, division, print_function, with_statement\n\nimport inspect\nimport sys\nimport zlib\n\n\nclass ObjectDict(dict):\n    \"\"\"Makes a dictionary behave like an object, with attribute-style access.\n    \"\"\"\n    def __getattr__(self, name):\n        try:\n            return self[name]\n        except KeyError:\n            raise AttributeError(name)\n\n    def __setattr__(self, name, value):\n        self[name] = value\n\n\nclass GzipDecompressor(object):\n    \"\"\"Streaming gzip decompressor.\n\n    The interface is like that of `zlib.decompressobj` (without the\n    optional arguments, but it understands gzip headers and checksums.\n    \"\"\"\n    def __init__(self):\n        # Magic parameter makes zlib module understand gzip header\n        # http://stackoverflow.com/questions/1838699/how-can-i-decompress-a-gzip-stream-with-zlib\n        # This works on cpython and pypy, but not jython.\n        self.decompressobj = zlib.decompressobj(16 + zlib.MAX_WBITS)\n\n    def decompress(self, value):\n        \"\"\"Decompress a chunk, returning newly-available data.\n\n        Some data may be buffered for later processing; `flush` must\n        be called when there is no more input data to ensure that\n        all data was processed.\n        \"\"\"\n        return self.decompressobj.decompress(value)\n\n    def flush(self):\n        \"\"\"Return any remaining buffered data not yet returned by decompress.\n\n        Also checks for errors such as truncated input.\n        No other methods may be called on this object after `flush`.\n        \"\"\"\n        return self.decompressobj.flush()\n\n\ndef import_object(name):\n    \"\"\"Imports an object by name.\n\n    import_object('x') is equivalent to 'import x'.\n    import_object('x.y.z') is equivalent to 'from x.y import z'.\n\n    >>> import tornado.escape\n    >>> import_object('tornado.escape') is tornado.escape\n    True\n    >>> import_object('tornado.escape.utf8') is tornado.escape.utf8\n    True\n    >>> import_object('tornado') is tornado\n    True\n    >>> import_object('tornado.missing_module')\n    Traceback (most recent call last):\n        ...\n    ImportError: No module named missing_module\n    \"\"\"\n    if name.count('.') == 0:\n        return __import__(name, None, None)\n\n    parts = name.split('.')\n    obj = __import__('.'.join(parts[:-1]), None, None, [parts[-1]], 0)\n    try:\n        return getattr(obj, parts[-1])\n    except AttributeError:\n        raise ImportError(\"No module named %s\" % parts[-1])\n\n\n# Fake unicode literal support:  Python 3.2 doesn't have the u'' marker for\n# literal strings, and alternative solutions like \"from __future__ import\n# unicode_literals\" have other problems (see PEP 414).  u() can be applied\n# to ascii strings that include \\u escapes (but they must not contain\n# literal non-ascii characters).\nif type('') is not type(b''):\n    def u(s):\n        return s\n    bytes_type = bytes\n    unicode_type = str\n    basestring_type = str\nelse:\n    def u(s):\n        return s.decode('unicode_escape')\n    bytes_type = str\n    unicode_type = unicode\n    basestring_type = basestring\n\n\nif sys.version_info > (3,):\n    exec(\"\"\"\ndef raise_exc_info(exc_info):\n    raise exc_info[1].with_traceback(exc_info[2])\n\ndef exec_in(code, glob, loc=None):\n    if isinstance(code, str):\n        code = compile(code, '<string>', 'exec', dont_inherit=True)\n    exec(code, glob, loc)\n\"\"\")\nelse:\n    exec(\"\"\"\ndef raise_exc_info(exc_info):\n    raise exc_info[0], exc_info[1], exc_info[2]\n\ndef exec_in(code, glob, loc=None):\n    if isinstance(code, basestring):\n        # exec(string) inherits the caller's future imports; compile\n        # the string first to prevent that.\n        code = compile(code, '<string>', 'exec', dont_inherit=True)\n    exec code in glob, loc\n\"\"\")\n\n\nclass Configurable(object):\n    \"\"\"Base class for configurable interfaces.\n\n    A configurable interface is an (abstract) class whose constructor\n    acts as a factory function for one of its implementation subclasses.\n    The implementation subclass as well as optional keyword arguments to\n    its initializer can be set globally at runtime with `configure`.\n\n    By using the constructor as the factory method, the interface\n    looks like a normal class, `isinstance` works as usual, etc.  This\n    pattern is most useful when the choice of implementation is likely\n    to be a global decision (e.g. when `~select.epoll` is available,\n    always use it instead of `~select.select`), or when a\n    previously-monolithic class has been split into specialized\n    subclasses.\n\n    Configurable subclasses must define the class methods\n    `configurable_base` and `configurable_default`, and use the instance\n    method `initialize` instead of ``__init__``.\n    \"\"\"\n    __impl_class = None\n    __impl_kwargs = None\n\n    def __new__(cls, **kwargs):\n        base = cls.configurable_base()\n        args = {}\n        if cls is base:\n            impl = cls.configured_class()\n            if base.__impl_kwargs:\n                args.update(base.__impl_kwargs)\n        else:\n            impl = cls\n        args.update(kwargs)\n        instance = super(Configurable, cls).__new__(impl)\n        # initialize vs __init__ chosen for compatiblity with AsyncHTTPClient\n        # singleton magic.  If we get rid of that we can switch to __init__\n        # here too.\n        instance.initialize(**args)\n        return instance\n\n    @classmethod\n    def configurable_base(cls):\n        \"\"\"Returns the base class of a configurable hierarchy.\n\n        This will normally return the class in which it is defined.\n        (which is *not* necessarily the same as the cls classmethod parameter).\n        \"\"\"\n        raise NotImplementedError()\n\n    @classmethod\n    def configurable_default(cls):\n        \"\"\"Returns the implementation class to be used if none is configured.\"\"\"\n        raise NotImplementedError()\n\n    def initialize(self):\n        \"\"\"Initialize a `Configurable` subclass instance.\n\n        Configurable classes should use `initialize` instead of ``__init__``.\n        \"\"\"\n\n    @classmethod\n    def configure(cls, impl, **kwargs):\n        \"\"\"Sets the class to use when the base class is instantiated.\n\n        Keyword arguments will be saved and added to the arguments passed\n        to the constructor.  This can be used to set global defaults for\n        some parameters.\n        \"\"\"\n        base = cls.configurable_base()\n        if isinstance(impl, (unicode_type, bytes_type)):\n            impl = import_object(impl)\n        if impl is not None and not issubclass(impl, cls):\n            raise ValueError(\"Invalid subclass of %s\" % cls)\n        base.__impl_class = impl\n        base.__impl_kwargs = kwargs\n\n    @classmethod\n    def configured_class(cls):\n        \"\"\"Returns the currently configured class.\"\"\"\n        base = cls.configurable_base()\n        if cls.__impl_class is None:\n            base.__impl_class = cls.configurable_default()\n        return base.__impl_class\n\n    @classmethod\n    def _save_configuration(cls):\n        base = cls.configurable_base()\n        return (base.__impl_class, base.__impl_kwargs)\n\n    @classmethod\n    def _restore_configuration(cls, saved):\n        base = cls.configurable_base()\n        base.__impl_class = saved[0]\n        base.__impl_kwargs = saved[1]\n\n\nclass ArgReplacer(object):\n    \"\"\"Replaces one value in an ``args, kwargs`` pair.\n\n    Inspects the function signature to find an argument by name\n    whether it is passed by position or keyword.  For use in decorators\n    and similar wrappers.\n    \"\"\"\n    def __init__(self, func, name):\n        self.name = name\n        try:\n            self.arg_pos = inspect.getargspec(func).args.index(self.name)\n        except ValueError:\n            # Not a positional parameter\n            self.arg_pos = None\n\n    def replace(self, new_value, args, kwargs):\n        \"\"\"Replace the named argument in ``args, kwargs`` with ``new_value``.\n\n        Returns ``(old_value, args, kwargs)``.  The returned ``args`` and\n        ``kwargs`` objects may not be the same as the input objects, or\n        the input objects may be mutated.\n\n        If the named argument was not found, ``new_value`` will be added\n        to ``kwargs`` and None will be returned as ``old_value``.\n        \"\"\"\n        if self.arg_pos is not None and len(args) > self.arg_pos:\n            # The arg to replace is passed positionally\n            old_value = args[self.arg_pos]\n            args = list(args)  # *args is normally a tuple\n            args[self.arg_pos] = new_value\n        else:\n            # The arg to replace is either omitted or passed by keyword.\n            old_value = kwargs.get(self.name)\n            kwargs[self.name] = new_value\n        return old_value, args, kwargs\n\n\ndef doctests():\n    import doctest\n    return doctest.DocTestSuite()\n", "#!/usr/bin/env python\n#\n# Copyright 2009 Facebook\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\n\"\"\"``tornado.web`` provides a simple web framework with asynchronous\nfeatures that allow it to scale to large numbers of open connections,\nmaking it ideal for `long polling\n<http://en.wikipedia.org/wiki/Push_technology#Long_polling>`_.\n\nHere is a simple \"Hello, world\" example app::\n\n    import tornado.ioloop\n    import tornado.web\n\n    class MainHandler(tornado.web.RequestHandler):\n        def get(self):\n            self.write(\"Hello, world\")\n\n    if __name__ == \"__main__\":\n        application = tornado.web.Application([\n            (r\"/\", MainHandler),\n        ])\n        application.listen(8888)\n        tornado.ioloop.IOLoop.instance().start()\n\nSee the :doc:`Tornado overview <overview>` for more details and a good getting\nstarted guide.\n\nThread-safety notes\n-------------------\n\nIn general, methods on `RequestHandler` and elsewhere in Tornado are\nnot thread-safe.  In particular, methods such as\n`~RequestHandler.write()`, `~RequestHandler.finish()`, and\n`~RequestHandler.flush()` must only be called from the main thread.  If\nyou use multiple threads it is important to use `.IOLoop.add_callback`\nto transfer control back to the main thread before finishing the\nrequest.\n\"\"\"\n\nfrom __future__ import absolute_import, division, print_function, with_statement\n\n\nimport base64\nimport binascii\nimport datetime\nimport email.utils\nimport functools\nimport gzip\nimport hashlib\nimport hmac\nimport mimetypes\nimport numbers\nimport os.path\nimport re\nimport stat\nimport sys\nimport threading\nimport time\nimport tornado\nimport traceback\nimport types\nimport uuid\n\nfrom tornado.concurrent import Future\nfrom tornado import escape\nfrom tornado import httputil\nfrom tornado import locale\nfrom tornado.log import access_log, app_log, gen_log\nfrom tornado import stack_context\nfrom tornado import template\nfrom tornado.escape import utf8, _unicode\nfrom tornado.util import bytes_type, import_object, ObjectDict, raise_exc_info, unicode_type\n\ntry:\n    from io import BytesIO  # python 3\nexcept ImportError:\n    from cStringIO import StringIO as BytesIO  # python 2\n\ntry:\n    import Cookie  # py2\nexcept ImportError:\n    import http.cookies as Cookie  # py3\n\ntry:\n    import urlparse  # py2\nexcept ImportError:\n    import urllib.parse as urlparse  # py3\n\ntry:\n    from urllib import urlencode  # py2\nexcept ImportError:\n    from urllib.parse import urlencode  # py3\n\n\nMIN_SUPPORTED_SIGNED_VALUE_VERSION = 1\n\"\"\"The oldest signed value version supported by this version of Tornado.\n\nSigned values older than this version cannot be decoded.\n\n.. versionadded:: 3.2.1\n\"\"\"\n\nMAX_SUPPORTED_SIGNED_VALUE_VERSION = 2\n\"\"\"The newest signed value version supported by this version of Tornado.\n\nSigned values newer than this version cannot be decoded.\n\n.. versionadded:: 3.2.1\n\"\"\"\n\nDEFAULT_SIGNED_VALUE_VERSION = 2\n\"\"\"The signed value version produced by `.RequestHandler.create_signed_value`.\n\nMay be overridden by passing a ``version`` keyword argument.\n\n.. versionadded:: 3.2.1\n\"\"\"\n\nDEFAULT_SIGNED_VALUE_MIN_VERSION = 1\n\"\"\"The oldest signed value accepted by `.RequestHandler.get_secure_cookie`.\n\nMay be overrided by passing a ``min_version`` keyword argument.\n\n.. versionadded:: 3.2.1\n\"\"\"\n\n\nclass RequestHandler(object):\n    \"\"\"Subclass this class and define `get()` or `post()` to make a handler.\n\n    If you want to support more methods than the standard GET/HEAD/POST, you\n    should override the class variable ``SUPPORTED_METHODS`` in your\n    `RequestHandler` subclass.\n    \"\"\"\n    SUPPORTED_METHODS = (\"GET\", \"HEAD\", \"POST\", \"DELETE\", \"PATCH\", \"PUT\",\n                         \"OPTIONS\")\n\n    _template_loaders = {}  # {path: template.BaseLoader}\n    _template_loader_lock = threading.Lock()\n    _remove_control_chars_regex = re.compile(r\"[\\x00-\\x08\\x0e-\\x1f]\")\n\n    def __init__(self, application, request, **kwargs):\n        super(RequestHandler, self).__init__()\n\n        self.application = application\n        self.request = request\n        self._headers_written = False\n        self._finished = False\n        self._auto_finish = True\n        self._transforms = None  # will be set in _execute\n        self.path_args = None\n        self.path_kwargs = None\n        self.ui = ObjectDict((n, self._ui_method(m)) for n, m in\n                             application.ui_methods.items())\n        # UIModules are available as both `modules` and `_tt_modules` in the\n        # template namespace.  Historically only `modules` was available\n        # but could be clobbered by user additions to the namespace.\n        # The template {% module %} directive looks in `_tt_modules` to avoid\n        # possible conflicts.\n        self.ui[\"_tt_modules\"] = _UIModuleNamespace(self,\n                                                    application.ui_modules)\n        self.ui[\"modules\"] = self.ui[\"_tt_modules\"]\n        self.clear()\n        # Check since connection is not available in WSGI\n        if getattr(self.request, \"connection\", None):\n            self.request.connection.set_close_callback(\n                self.on_connection_close)\n        self.initialize(**kwargs)\n\n    def initialize(self):\n        \"\"\"Hook for subclass initialization.\n\n        A dictionary passed as the third argument of a url spec will be\n        supplied as keyword arguments to initialize().\n\n        Example::\n\n            class ProfileHandler(RequestHandler):\n                def initialize(self, database):\n                    self.database = database\n\n                def get(self, username):\n                    ...\n\n            app = Application([\n                (r'/user/(.*)', ProfileHandler, dict(database=database)),\n                ])\n        \"\"\"\n        pass\n\n    @property\n    def settings(self):\n        \"\"\"An alias for `self.application.settings <Application.settings>`.\"\"\"\n        return self.application.settings\n\n    def head(self, *args, **kwargs):\n        raise HTTPError(405)\n\n    def get(self, *args, **kwargs):\n        raise HTTPError(405)\n\n    def post(self, *args, **kwargs):\n        raise HTTPError(405)\n\n    def delete(self, *args, **kwargs):\n        raise HTTPError(405)\n\n    def patch(self, *args, **kwargs):\n        raise HTTPError(405)\n\n    def put(self, *args, **kwargs):\n        raise HTTPError(405)\n\n    def options(self, *args, **kwargs):\n        raise HTTPError(405)\n\n    def prepare(self):\n        \"\"\"Called at the beginning of a request before  `get`/`post`/etc.\n\n        Override this method to perform common initialization regardless\n        of the request method.\n\n        Asynchronous support: Decorate this method with `.gen.coroutine`\n        or `.return_future` to make it asynchronous (the\n        `asynchronous` decorator cannot be used on `prepare`).\n        If this method returns a `.Future` execution will not proceed\n        until the `.Future` is done.\n\n        .. versionadded:: 3.1\n           Asynchronous support.\n        \"\"\"\n        pass\n\n    def on_finish(self):\n        \"\"\"Called after the end of a request.\n\n        Override this method to perform cleanup, logging, etc.\n        This method is a counterpart to `prepare`.  ``on_finish`` may\n        not produce any output, as it is called after the response\n        has been sent to the client.\n        \"\"\"\n        pass\n\n    def on_connection_close(self):\n        \"\"\"Called in async handlers if the client closed the connection.\n\n        Override this to clean up resources associated with\n        long-lived connections.  Note that this method is called only if\n        the connection was closed during asynchronous processing; if you\n        need to do cleanup after every request override `on_finish`\n        instead.\n\n        Proxies may keep a connection open for a time (perhaps\n        indefinitely) after the client has gone away, so this method\n        may not be called promptly after the end user closes their\n        connection.\n        \"\"\"\n        pass\n\n    def clear(self):\n        \"\"\"Resets all headers and content for this response.\"\"\"\n        self._headers = httputil.HTTPHeaders({\n            \"Server\": \"TornadoServer/%s\" % tornado.version,\n            \"Content-Type\": \"text/html; charset=UTF-8\",\n            \"Date\": httputil.format_timestamp(time.time()),\n        })\n        self.set_default_headers()\n        if (not self.request.supports_http_1_1() and\n            getattr(self.request, 'connection', None) and\n                not self.request.connection.no_keep_alive):\n            conn_header = self.request.headers.get(\"Connection\")\n            if conn_header and (conn_header.lower() == \"keep-alive\"):\n                self._headers[\"Connection\"] = \"Keep-Alive\"\n        self._write_buffer = []\n        self._status_code = 200\n        self._reason = httputil.responses[200]\n\n    def set_default_headers(self):\n        \"\"\"Override this to set HTTP headers at the beginning of the request.\n\n        For example, this is the place to set a custom ``Server`` header.\n        Note that setting such headers in the normal flow of request\n        processing may not do what you want, since headers may be reset\n        during error handling.\n        \"\"\"\n        pass\n\n    def set_status(self, status_code, reason=None):\n        \"\"\"Sets the status code for our response.\n\n        :arg int status_code: Response status code. If ``reason`` is ``None``,\n            it must be present in `httplib.responses <http.client.responses>`.\n        :arg string reason: Human-readable reason phrase describing the status\n            code. If ``None``, it will be filled in from\n            `httplib.responses <http.client.responses>`.\n        \"\"\"\n        self._status_code = status_code\n        if reason is not None:\n            self._reason = escape.native_str(reason)\n        else:\n            try:\n                self._reason = httputil.responses[status_code]\n            except KeyError:\n                raise ValueError(\"unknown status code %d\", status_code)\n\n    def get_status(self):\n        \"\"\"Returns the status code for our response.\"\"\"\n        return self._status_code\n\n    def set_header(self, name, value):\n        \"\"\"Sets the given response header name and value.\n\n        If a datetime is given, we automatically format it according to the\n        HTTP specification. If the value is not a string, we convert it to\n        a string. All header values are then encoded as UTF-8.\n        \"\"\"\n        self._headers[name] = self._convert_header_value(value)\n\n    def add_header(self, name, value):\n        \"\"\"Adds the given response header and value.\n\n        Unlike `set_header`, `add_header` may be called multiple times\n        to return multiple values for the same header.\n        \"\"\"\n        self._headers.add(name, self._convert_header_value(value))\n\n    def clear_header(self, name):\n        \"\"\"Clears an outgoing header, undoing a previous `set_header` call.\n\n        Note that this method does not apply to multi-valued headers\n        set by `add_header`.\n        \"\"\"\n        if name in self._headers:\n            del self._headers[name]\n\n    _INVALID_HEADER_CHAR_RE = re.compile(br\"[\\x00-\\x1f]\")\n\n    def _convert_header_value(self, value):\n        if isinstance(value, bytes_type):\n            pass\n        elif isinstance(value, unicode_type):\n            value = value.encode('utf-8')\n        elif isinstance(value, numbers.Integral):\n            # return immediately since we know the converted value will be safe\n            return str(value)\n        elif isinstance(value, datetime.datetime):\n            return httputil.format_timestamp(value)\n        else:\n            raise TypeError(\"Unsupported header value %r\" % value)\n        # If \\n is allowed into the header, it is possible to inject\n        # additional headers or split the request. Also cap length to\n        # prevent obviously erroneous values.\n        if (len(value) > 4000 or\n                RequestHandler._INVALID_HEADER_CHAR_RE.search(value)):\n            raise ValueError(\"Unsafe header value %r\", value)\n        return value\n\n    _ARG_DEFAULT = []\n\n    def get_argument(self, name, default=_ARG_DEFAULT, strip=True):\n        \"\"\"Returns the value of the argument with the given name.\n\n        If default is not provided, the argument is considered to be\n        required, and we raise a `MissingArgumentError` if it is missing.\n\n        If the argument appears in the url more than once, we return the\n        last value.\n\n        The returned value is always unicode.\n        \"\"\"\n        return self._get_argument(name, default, self.request.arguments, strip)\n\n    def get_arguments(self, name, strip=True):\n        \"\"\"Returns a list of the arguments with the given name.\n\n        If the argument is not present, returns an empty list.\n\n        The returned values are always unicode.\n        \"\"\"\n        return self._get_arguments(name, self.request.arguments, strip)\n\n    def get_body_argument(self, name, default=_ARG_DEFAULT, strip=True):\n        \"\"\"Returns the value of the argument with the given name\n        from the request body.\n\n        If default is not provided, the argument is considered to be\n        required, and we raise a `MissingArgumentError` if it is missing.\n\n        If the argument appears in the url more than once, we return the\n        last value.\n\n        The returned value is always unicode.\n\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_argument(name, default, self.request.body_arguments, strip)\n\n    def get_body_arguments(self, name, strip=True):\n        \"\"\"Returns a list of the body arguments with the given name.\n\n        If the argument is not present, returns an empty list.\n\n        The returned values are always unicode.\n\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_arguments(name, self.request.body_arguments, strip)\n\n    def get_query_argument(self, name, default=_ARG_DEFAULT, strip=True):\n        \"\"\"Returns the value of the argument with the given name\n        from the request query string.\n\n        If default is not provided, the argument is considered to be\n        required, and we raise a `MissingArgumentError` if it is missing.\n\n        If the argument appears in the url more than once, we return the\n        last value.\n\n        The returned value is always unicode.\n\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_argument(name, default, self.request.query_arguments, strip)\n\n    def get_query_arguments(self, name, strip=True):\n        \"\"\"Returns a list of the query arguments with the given name.\n\n        If the argument is not present, returns an empty list.\n\n        The returned values are always unicode.\n\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_arguments(name, self.request.query_arguments, strip)\n\n    def _get_argument(self, name, default, source, strip=True):\n        args = self._get_arguments(name, source, strip=strip)\n        if not args:\n            if default is self._ARG_DEFAULT:\n                raise MissingArgumentError(name)\n            return default\n        return args[-1]\n\n    def _get_arguments(self, name, source, strip=True):\n        values = []\n        for v in source.get(name, []):\n            v = self.decode_argument(v, name=name)\n            if isinstance(v, unicode_type):\n                # Get rid of any weird control chars (unless decoding gave\n                # us bytes, in which case leave it alone)\n                v = RequestHandler._remove_control_chars_regex.sub(\" \", v)\n            if strip:\n                v = v.strip()\n            values.append(v)\n        return values\n\n    def decode_argument(self, value, name=None):\n        \"\"\"Decodes an argument from the request.\n\n        The argument has been percent-decoded and is now a byte string.\n        By default, this method decodes the argument as utf-8 and returns\n        a unicode string, but this may be overridden in subclasses.\n\n        This method is used as a filter for both `get_argument()` and for\n        values extracted from the url and passed to `get()`/`post()`/etc.\n\n        The name of the argument is provided if known, but may be None\n        (e.g. for unnamed groups in the url regex).\n        \"\"\"\n        try:\n            return _unicode(value)\n        except UnicodeDecodeError:\n            raise HTTPError(400, \"Invalid unicode in %s: %r\" %\n                            (name or \"url\", value[:40]))\n\n    @property\n    def cookies(self):\n        \"\"\"An alias for `self.request.cookies <.httpserver.HTTPRequest.cookies>`.\"\"\"\n        return self.request.cookies\n\n    def get_cookie(self, name, default=None):\n        \"\"\"Gets the value of the cookie with the given name, else default.\"\"\"\n        if self.request.cookies is not None and name in self.request.cookies:\n            return self.request.cookies[name].value\n        return default\n\n    def set_cookie(self, name, value, domain=None, expires=None, path=\"/\",\n                   expires_days=None, **kwargs):\n        \"\"\"Sets the given cookie name/value with the given options.\n\n        Additional keyword arguments are set on the Cookie.Morsel\n        directly.\n        See http://docs.python.org/library/cookie.html#morsel-objects\n        for available attributes.\n        \"\"\"\n        # The cookie library only accepts type str, in both python 2 and 3\n        name = escape.native_str(name)\n        value = escape.native_str(value)\n        if re.search(r\"[\\x00-\\x20]\", name + value):\n            # Don't let us accidentally inject bad stuff\n            raise ValueError(\"Invalid cookie %r: %r\" % (name, value))\n        if not hasattr(self, \"_new_cookie\"):\n            self._new_cookie = Cookie.SimpleCookie()\n        if name in self._new_cookie:\n            del self._new_cookie[name]\n        self._new_cookie[name] = value\n        morsel = self._new_cookie[name]\n        if domain:\n            morsel[\"domain\"] = domain\n        if expires_days is not None and not expires:\n            expires = datetime.datetime.utcnow() + datetime.timedelta(\n                days=expires_days)\n        if expires:\n            morsel[\"expires\"] = httputil.format_timestamp(expires)\n        if path:\n            morsel[\"path\"] = path\n        for k, v in kwargs.items():\n            if k == 'max_age':\n                k = 'max-age'\n            morsel[k] = v\n\n    def clear_cookie(self, name, path=\"/\", domain=None):\n        \"\"\"Deletes the cookie with the given name.\n\n        Due to limitations of the cookie protocol, you must pass the same\n        path and domain to clear a cookie as were used when that cookie\n        was set (but there is no way to find out on the server side\n        which values were used for a given cookie).\n        \"\"\"\n        expires = datetime.datetime.utcnow() - datetime.timedelta(days=365)\n        self.set_cookie(name, value=\"\", path=path, expires=expires,\n                        domain=domain)\n\n    def clear_all_cookies(self, path=\"/\", domain=None):\n        \"\"\"Deletes all the cookies the user sent with this request.\n\n        See `clear_cookie` for more information on the path and domain\n        parameters.\n\n        .. versionchanged:: 3.2\n\n           Added the ``path`` and ``domain`` parameters.\n        \"\"\"\n        for name in self.request.cookies:\n            self.clear_cookie(name, path=path, domain=domain)\n\n    def set_secure_cookie(self, name, value, expires_days=30, version=None,\n                          **kwargs):\n        \"\"\"Signs and timestamps a cookie so it cannot be forged.\n\n        You must specify the ``cookie_secret`` setting in your Application\n        to use this method. It should be a long, random sequence of bytes\n        to be used as the HMAC secret for the signature.\n\n        To read a cookie set with this method, use `get_secure_cookie()`.\n\n        Note that the ``expires_days`` parameter sets the lifetime of the\n        cookie in the browser, but is independent of the ``max_age_days``\n        parameter to `get_secure_cookie`.\n\n        Secure cookies may contain arbitrary byte values, not just unicode\n        strings (unlike regular cookies)\n\n        .. versionchanged:: 3.2.1\n\n           Added the ``version`` argument.  Introduced cookie version 2\n           and made it the default.\n        \"\"\"\n        self.set_cookie(name, self.create_signed_value(name, value,\n                                                       version=version),\n                        expires_days=expires_days, **kwargs)\n\n    def create_signed_value(self, name, value, version=None):\n        \"\"\"Signs and timestamps a string so it cannot be forged.\n\n        Normally used via set_secure_cookie, but provided as a separate\n        method for non-cookie uses.  To decode a value not stored\n        as a cookie use the optional value argument to get_secure_cookie.\n\n        .. versionchanged:: 3.2.1\n\n           Added the ``version`` argument.  Introduced cookie version 2\n           and made it the default.\n        \"\"\"\n        self.require_setting(\"cookie_secret\", \"secure cookies\")\n        return create_signed_value(self.application.settings[\"cookie_secret\"],\n                                   name, value, version=version)\n\n    def get_secure_cookie(self, name, value=None, max_age_days=31,\n                          min_version=None):\n        \"\"\"Returns the given signed cookie if it validates, or None.\n\n        The decoded cookie value is returned as a byte string (unlike\n        `get_cookie`).\n\n        .. versionchanged:: 3.2.1\n\n           Added the ``min_version`` argument.  Introduced cookie version 2;\n           both versions 1 and 2 are accepted by default.\n        \"\"\"\n        self.require_setting(\"cookie_secret\", \"secure cookies\")\n        if value is None:\n            value = self.get_cookie(name)\n        return decode_signed_value(self.application.settings[\"cookie_secret\"],\n                                   name, value, max_age_days=max_age_days,\n                                   min_version=min_version)\n\n    def redirect(self, url, permanent=False, status=None):\n        \"\"\"Sends a redirect to the given (optionally relative) URL.\n\n        If the ``status`` argument is specified, that value is used as the\n        HTTP status code; otherwise either 301 (permanent) or 302\n        (temporary) is chosen based on the ``permanent`` argument.\n        The default is 302 (temporary).\n        \"\"\"\n        if self._headers_written:\n            raise Exception(\"Cannot redirect after headers have been written\")\n        if status is None:\n            status = 301 if permanent else 302\n        else:\n            assert isinstance(status, int) and 300 <= status <= 399\n        self.set_status(status)\n        self.set_header(\"Location\", urlparse.urljoin(utf8(self.request.uri),\n                                                     utf8(url)))\n        self.finish()\n\n    def write(self, chunk):\n        \"\"\"Writes the given chunk to the output buffer.\n\n        To write the output to the network, use the flush() method below.\n\n        If the given chunk is a dictionary, we write it as JSON and set\n        the Content-Type of the response to be ``application/json``.\n        (if you want to send JSON as a different ``Content-Type``, call\n        set_header *after* calling write()).\n\n        Note that lists are not converted to JSON because of a potential\n        cross-site security vulnerability.  All JSON output should be\n        wrapped in a dictionary.  More details at\n        http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx\n        \"\"\"\n        if self._finished:\n            raise RuntimeError(\"Cannot write() after finish().  May be caused \"\n                               \"by using async operations without the \"\n                               \"@asynchronous decorator.\")\n        if isinstance(chunk, dict):\n            chunk = escape.json_encode(chunk)\n            self.set_header(\"Content-Type\", \"application/json; charset=UTF-8\")\n        chunk = utf8(chunk)\n        self._write_buffer.append(chunk)\n\n    def render(self, template_name, **kwargs):\n        \"\"\"Renders the template with the given arguments as the response.\"\"\"\n        html = self.render_string(template_name, **kwargs)\n\n        # Insert the additional JS and CSS added by the modules on the page\n        js_embed = []\n        js_files = []\n        css_embed = []\n        css_files = []\n        html_heads = []\n        html_bodies = []\n        for module in getattr(self, \"_active_modules\", {}).values():\n            embed_part = module.embedded_javascript()\n            if embed_part:\n                js_embed.append(utf8(embed_part))\n            file_part = module.javascript_files()\n            if file_part:\n                if isinstance(file_part, (unicode_type, bytes_type)):\n                    js_files.append(file_part)\n                else:\n                    js_files.extend(file_part)\n            embed_part = module.embedded_css()\n            if embed_part:\n                css_embed.append(utf8(embed_part))\n            file_part = module.css_files()\n            if file_part:\n                if isinstance(file_part, (unicode_type, bytes_type)):\n                    css_files.append(file_part)\n                else:\n                    css_files.extend(file_part)\n            head_part = module.html_head()\n            if head_part:\n                html_heads.append(utf8(head_part))\n            body_part = module.html_body()\n            if body_part:\n                html_bodies.append(utf8(body_part))\n\n        def is_absolute(path):\n            return any(path.startswith(x) for x in [\"/\", \"http:\", \"https:\"])\n        if js_files:\n            # Maintain order of JavaScript files given by modules\n            paths = []\n            unique_paths = set()\n            for path in js_files:\n                if not is_absolute(path):\n                    path = self.static_url(path)\n                if path not in unique_paths:\n                    paths.append(path)\n                    unique_paths.add(path)\n            js = ''.join('<script src=\"' + escape.xhtml_escape(p) +\n                         '\" type=\"text/javascript\"></script>'\n                         for p in paths)\n            sloc = html.rindex(b'</body>')\n            html = html[:sloc] + utf8(js) + b'\\n' + html[sloc:]\n        if js_embed:\n            js = b'<script type=\"text/javascript\">\\n//<![CDATA[\\n' + \\\n                b'\\n'.join(js_embed) + b'\\n//]]>\\n</script>'\n            sloc = html.rindex(b'</body>')\n            html = html[:sloc] + js + b'\\n' + html[sloc:]\n        if css_files:\n            paths = []\n            unique_paths = set()\n            for path in css_files:\n                if not is_absolute(path):\n                    path = self.static_url(path)\n                if path not in unique_paths:\n                    paths.append(path)\n                    unique_paths.add(path)\n            css = ''.join('<link href=\"' + escape.xhtml_escape(p) + '\" '\n                          'type=\"text/css\" rel=\"stylesheet\"/>'\n                          for p in paths)\n            hloc = html.index(b'</head>')\n            html = html[:hloc] + utf8(css) + b'\\n' + html[hloc:]\n        if css_embed:\n            css = b'<style type=\"text/css\">\\n' + b'\\n'.join(css_embed) + \\\n                b'\\n</style>'\n            hloc = html.index(b'</head>')\n            html = html[:hloc] + css + b'\\n' + html[hloc:]\n        if html_heads:\n            hloc = html.index(b'</head>')\n            html = html[:hloc] + b''.join(html_heads) + b'\\n' + html[hloc:]\n        if html_bodies:\n            hloc = html.index(b'</body>')\n            html = html[:hloc] + b''.join(html_bodies) + b'\\n' + html[hloc:]\n        self.finish(html)\n\n    def render_string(self, template_name, **kwargs):\n        \"\"\"Generate the given template with the given arguments.\n\n        We return the generated byte string (in utf8). To generate and\n        write a template as a response, use render() above.\n        \"\"\"\n        # If no template_path is specified, use the path of the calling file\n        template_path = self.get_template_path()\n        if not template_path:\n            frame = sys._getframe(0)\n            web_file = frame.f_code.co_filename\n            while frame.f_code.co_filename == web_file:\n                frame = frame.f_back\n            template_path = os.path.dirname(frame.f_code.co_filename)\n        with RequestHandler._template_loader_lock:\n            if template_path not in RequestHandler._template_loaders:\n                loader = self.create_template_loader(template_path)\n                RequestHandler._template_loaders[template_path] = loader\n            else:\n                loader = RequestHandler._template_loaders[template_path]\n        t = loader.load(template_name)\n        namespace = self.get_template_namespace()\n        namespace.update(kwargs)\n        return t.generate(**namespace)\n\n    def get_template_namespace(self):\n        \"\"\"Returns a dictionary to be used as the default template namespace.\n\n        May be overridden by subclasses to add or modify values.\n\n        The results of this method will be combined with additional\n        defaults in the `tornado.template` module and keyword arguments\n        to `render` or `render_string`.\n        \"\"\"\n        namespace = dict(\n            handler=self,\n            request=self.request,\n            current_user=self.current_user,\n            locale=self.locale,\n            _=self.locale.translate,\n            static_url=self.static_url,\n            xsrf_form_html=self.xsrf_form_html,\n            reverse_url=self.reverse_url\n        )\n        namespace.update(self.ui)\n        return namespace\n\n    def create_template_loader(self, template_path):\n        \"\"\"Returns a new template loader for the given path.\n\n        May be overridden by subclasses.  By default returns a\n        directory-based loader on the given path, using the\n        ``autoescape`` application setting.  If a ``template_loader``\n        application setting is supplied, uses that instead.\n        \"\"\"\n        settings = self.application.settings\n        if \"template_loader\" in settings:\n            return settings[\"template_loader\"]\n        kwargs = {}\n        if \"autoescape\" in settings:\n            # autoescape=None means \"no escaping\", so we have to be sure\n            # to only pass this kwarg if the user asked for it.\n            kwargs[\"autoescape\"] = settings[\"autoescape\"]\n        return template.Loader(template_path, **kwargs)\n\n    def flush(self, include_footers=False, callback=None):\n        \"\"\"Flushes the current output buffer to the network.\n\n        The ``callback`` argument, if given, can be used for flow control:\n        it will be run when all flushed data has been written to the socket.\n        Note that only one flush callback can be outstanding at a time;\n        if another flush occurs before the previous flush's callback\n        has been run, the previous callback will be discarded.\n        \"\"\"\n        if self.application._wsgi:\n            # WSGI applications cannot usefully support flush, so just make\n            # it a no-op (and run the callback immediately).\n            if callback is not None:\n                callback()\n            return\n\n        chunk = b\"\".join(self._write_buffer)\n        self._write_buffer = []\n        if not self._headers_written:\n            self._headers_written = True\n            for transform in self._transforms:\n                self._status_code, self._headers, chunk = \\\n                    transform.transform_first_chunk(\n                        self._status_code, self._headers, chunk, include_footers)\n            headers = self._generate_headers()\n        else:\n            for transform in self._transforms:\n                chunk = transform.transform_chunk(chunk, include_footers)\n            headers = b\"\"\n\n        # Ignore the chunk and only write the headers for HEAD requests\n        if self.request.method == \"HEAD\":\n            if headers:\n                self.request.write(headers, callback=callback)\n            return\n\n        self.request.write(headers + chunk, callback=callback)\n\n    def finish(self, chunk=None):\n        \"\"\"Finishes this response, ending the HTTP request.\"\"\"\n        if self._finished:\n            raise RuntimeError(\"finish() called twice.  May be caused \"\n                               \"by using async operations without the \"\n                               \"@asynchronous decorator.\")\n\n        if chunk is not None:\n            self.write(chunk)\n\n        # Automatically support ETags and add the Content-Length header if\n        # we have not flushed any content yet.\n        if not self._headers_written:\n            if (self._status_code == 200 and\n                self.request.method in (\"GET\", \"HEAD\") and\n                    \"Etag\" not in self._headers):\n                self.set_etag_header()\n                if self.check_etag_header():\n                    self._write_buffer = []\n                    self.set_status(304)\n            if self._status_code == 304:\n                assert not self._write_buffer, \"Cannot send body with 304\"\n                self._clear_headers_for_304()\n            elif \"Content-Length\" not in self._headers:\n                content_length = sum(len(part) for part in self._write_buffer)\n                self.set_header(\"Content-Length\", content_length)\n\n        if hasattr(self.request, \"connection\"):\n            # Now that the request is finished, clear the callback we\n            # set on the HTTPConnection (which would otherwise prevent the\n            # garbage collection of the RequestHandler when there\n            # are keepalive connections)\n            self.request.connection.set_close_callback(None)\n\n        if not self.application._wsgi:\n            self.flush(include_footers=True)\n            self.request.finish()\n            self._log()\n        self._finished = True\n        self.on_finish()\n        # Break up a reference cycle between this handler and the\n        # _ui_module closures to allow for faster GC on CPython.\n        self.ui = None\n\n    def send_error(self, status_code=500, **kwargs):\n        \"\"\"Sends the given HTTP error code to the browser.\n\n        If `flush()` has already been called, it is not possible to send\n        an error, so this method will simply terminate the response.\n        If output has been written but not yet flushed, it will be discarded\n        and replaced with the error page.\n\n        Override `write_error()` to customize the error page that is returned.\n        Additional keyword arguments are passed through to `write_error`.\n        \"\"\"\n        if self._headers_written:\n            gen_log.error(\"Cannot send error response after headers written\")\n            if not self._finished:\n                self.finish()\n            return\n        self.clear()\n\n        reason = None\n        if 'exc_info' in kwargs:\n            exception = kwargs['exc_info'][1]\n            if isinstance(exception, HTTPError) and exception.reason:\n                reason = exception.reason\n        self.set_status(status_code, reason=reason)\n        try:\n            self.write_error(status_code, **kwargs)\n        except Exception:\n            app_log.error(\"Uncaught exception in write_error\", exc_info=True)\n        if not self._finished:\n            self.finish()\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"Override to implement custom error pages.\n\n        ``write_error`` may call `write`, `render`, `set_header`, etc\n        to produce output as usual.\n\n        If this error was caused by an uncaught exception (including\n        HTTPError), an ``exc_info`` triple will be available as\n        ``kwargs[\"exc_info\"]``.  Note that this exception may not be\n        the \"current\" exception for purposes of methods like\n        ``sys.exc_info()`` or ``traceback.format_exc``.\n\n        For historical reasons, if a method ``get_error_html`` exists,\n        it will be used instead of the default ``write_error`` implementation.\n        ``get_error_html`` returned a string instead of producing output\n        normally, and had different semantics for exception handling.\n        Users of ``get_error_html`` are encouraged to convert their code\n        to override ``write_error`` instead.\n        \"\"\"\n        if hasattr(self, 'get_error_html'):\n            if 'exc_info' in kwargs:\n                exc_info = kwargs.pop('exc_info')\n                kwargs['exception'] = exc_info[1]\n                try:\n                    # Put the traceback into sys.exc_info()\n                    raise_exc_info(exc_info)\n                except Exception:\n                    self.finish(self.get_error_html(status_code, **kwargs))\n            else:\n                self.finish(self.get_error_html(status_code, **kwargs))\n            return\n        if self.settings.get(\"serve_traceback\") and \"exc_info\" in kwargs:\n            # in debug mode, try to send a traceback\n            self.set_header('Content-Type', 'text/plain')\n            for line in traceback.format_exception(*kwargs[\"exc_info\"]):\n                self.write(line)\n            self.finish()\n        else:\n            self.finish(\"<html><title>%(code)d: %(message)s</title>\"\n                        \"<body>%(code)d: %(message)s</body></html>\" % {\n                            \"code\": status_code,\n                            \"message\": self._reason,\n                        })\n\n    @property\n    def locale(self):\n        \"\"\"The local for the current session.\n\n        Determined by either `get_user_locale`, which you can override to\n        set the locale based on, e.g., a user preference stored in a\n        database, or `get_browser_locale`, which uses the ``Accept-Language``\n        header.\n        \"\"\"\n        if not hasattr(self, \"_locale\"):\n            self._locale = self.get_user_locale()\n            if not self._locale:\n                self._locale = self.get_browser_locale()\n                assert self._locale\n        return self._locale\n\n    def get_user_locale(self):\n        \"\"\"Override to determine the locale from the authenticated user.\n\n        If None is returned, we fall back to `get_browser_locale()`.\n\n        This method should return a `tornado.locale.Locale` object,\n        most likely obtained via a call like ``tornado.locale.get(\"en\")``\n        \"\"\"\n        return None\n\n    def get_browser_locale(self, default=\"en_US\"):\n        \"\"\"Determines the user's locale from ``Accept-Language`` header.\n\n        See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4\n        \"\"\"\n        if \"Accept-Language\" in self.request.headers:\n            languages = self.request.headers[\"Accept-Language\"].split(\",\")\n            locales = []\n            for language in languages:\n                parts = language.strip().split(\";\")\n                if len(parts) > 1 and parts[1].startswith(\"q=\"):\n                    try:\n                        score = float(parts[1][2:])\n                    except (ValueError, TypeError):\n                        score = 0.0\n                else:\n                    score = 1.0\n                locales.append((parts[0], score))\n            if locales:\n                locales.sort(key=lambda pair: pair[1], reverse=True)\n                codes = [l[0] for l in locales]\n                return locale.get(*codes)\n        return locale.get(default)\n\n    @property\n    def current_user(self):\n        \"\"\"The authenticated user for this request.\n\n        This is a cached version of `get_current_user`, which you can\n        override to set the user based on, e.g., a cookie. If that\n        method is not overridden, this method always returns None.\n\n        We lazy-load the current user the first time this method is called\n        and cache the result after that.\n        \"\"\"\n        if not hasattr(self, \"_current_user\"):\n            self._current_user = self.get_current_user()\n        return self._current_user\n\n    @current_user.setter\n    def current_user(self, value):\n        self._current_user = value\n\n    def get_current_user(self):\n        \"\"\"Override to determine the current user from, e.g., a cookie.\"\"\"\n        return None\n\n    def get_login_url(self):\n        \"\"\"Override to customize the login URL based on the request.\n\n        By default, we use the ``login_url`` application setting.\n        \"\"\"\n        self.require_setting(\"login_url\", \"@tornado.web.authenticated\")\n        return self.application.settings[\"login_url\"]\n\n    def get_template_path(self):\n        \"\"\"Override to customize template path for each handler.\n\n        By default, we use the ``template_path`` application setting.\n        Return None to load templates relative to the calling file.\n        \"\"\"\n        return self.application.settings.get(\"template_path\")\n\n    @property\n    def xsrf_token(self):\n        \"\"\"The XSRF-prevention token for the current user/session.\n\n        To prevent cross-site request forgery, we set an '_xsrf' cookie\n        and include the same '_xsrf' value as an argument with all POST\n        requests. If the two do not match, we reject the form submission\n        as a potential forgery.\n\n        See http://en.wikipedia.org/wiki/Cross-site_request_forgery\n        \"\"\"\n        if not hasattr(self, \"_xsrf_token\"):\n            token = self.get_cookie(\"_xsrf\")\n            if not token:\n                token = binascii.b2a_hex(os.urandom(16))\n                expires_days = 30 if self.current_user else None\n                self.set_cookie(\"_xsrf\", token, expires_days=expires_days)\n            self._xsrf_token = token\n        return self._xsrf_token\n\n    def check_xsrf_cookie(self):\n        \"\"\"Verifies that the ``_xsrf`` cookie matches the ``_xsrf`` argument.\n\n        To prevent cross-site request forgery, we set an ``_xsrf``\n        cookie and include the same value as a non-cookie\n        field with all ``POST`` requests. If the two do not match, we\n        reject the form submission as a potential forgery.\n\n        The ``_xsrf`` value may be set as either a form field named ``_xsrf``\n        or in a custom HTTP header named ``X-XSRFToken`` or ``X-CSRFToken``\n        (the latter is accepted for compatibility with Django).\n\n        See http://en.wikipedia.org/wiki/Cross-site_request_forgery\n\n        Prior to release 1.1.1, this check was ignored if the HTTP header\n        ``X-Requested-With: XMLHTTPRequest`` was present.  This exception\n        has been shown to be insecure and has been removed.  For more\n        information please see\n        http://www.djangoproject.com/weblog/2011/feb/08/security/\n        http://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails\n        \"\"\"\n        token = (self.get_argument(\"_xsrf\", None) or\n                 self.request.headers.get(\"X-Xsrftoken\") or\n                 self.request.headers.get(\"X-Csrftoken\"))\n        if not token:\n            raise HTTPError(403, \"'_xsrf' argument missing from POST\")\n        if not _time_independent_equals(utf8(self.xsrf_token), utf8(token)):\n            raise HTTPError(403, \"XSRF cookie does not match POST argument\")\n\n    def xsrf_form_html(self):\n        \"\"\"An HTML ``<input/>`` element to be included with all POST forms.\n\n        It defines the ``_xsrf`` input value, which we check on all POST\n        requests to prevent cross-site request forgery. If you have set\n        the ``xsrf_cookies`` application setting, you must include this\n        HTML within all of your HTML forms.\n\n        In a template, this method should be called with ``{% module\n        xsrf_form_html() %}``\n\n        See `check_xsrf_cookie()` above for more information.\n        \"\"\"\n        return '<input type=\"hidden\" name=\"_xsrf\" value=\"' + \\\n            escape.xhtml_escape(self.xsrf_token) + '\"/>'\n\n    def static_url(self, path, include_host=None, **kwargs):\n        \"\"\"Returns a static URL for the given relative static file path.\n\n        This method requires you set the ``static_path`` setting in your\n        application (which specifies the root directory of your static\n        files).\n\n        This method returns a versioned url (by default appending\n        ``?v=<signature>``), which allows the static files to be\n        cached indefinitely.  This can be disabled by passing\n        ``include_version=False`` (in the default implementation;\n        other static file implementations are not required to support\n        this, but they may support other options).\n\n        By default this method returns URLs relative to the current\n        host, but if ``include_host`` is true the URL returned will be\n        absolute.  If this handler has an ``include_host`` attribute,\n        that value will be used as the default for all `static_url`\n        calls that do not pass ``include_host`` as a keyword argument.\n\n        \"\"\"\n        self.require_setting(\"static_path\", \"static_url\")\n        get_url = self.settings.get(\"static_handler_class\",\n                                    StaticFileHandler).make_static_url\n\n        if include_host is None:\n            include_host = getattr(self, \"include_host\", False)\n\n        if include_host:\n            base = self.request.protocol + \"://\" + self.request.host\n        else:\n            base = \"\"\n\n        return base + get_url(self.settings, path, **kwargs)\n\n    def async_callback(self, callback, *args, **kwargs):\n        \"\"\"Obsolete - catches exceptions from the wrapped function.\n\n        This function is unnecessary since Tornado 1.1.\n        \"\"\"\n        if callback is None:\n            return None\n        if args or kwargs:\n            callback = functools.partial(callback, *args, **kwargs)\n\n        def wrapper(*args, **kwargs):\n            try:\n                return callback(*args, **kwargs)\n            except Exception as e:\n                if self._headers_written:\n                    app_log.error(\"Exception after headers written\",\n                                  exc_info=True)\n                else:\n                    self._handle_request_exception(e)\n        return wrapper\n\n    def require_setting(self, name, feature=\"this feature\"):\n        \"\"\"Raises an exception if the given app setting is not defined.\"\"\"\n        if not self.application.settings.get(name):\n            raise Exception(\"You must define the '%s' setting in your \"\n                            \"application to use %s\" % (name, feature))\n\n    def reverse_url(self, name, *args):\n        \"\"\"Alias for `Application.reverse_url`.\"\"\"\n        return self.application.reverse_url(name, *args)\n\n    def compute_etag(self):\n        \"\"\"Computes the etag header to be used for this request.\n\n        By default uses a hash of the content written so far.\n\n        May be overridden to provide custom etag implementations,\n        or may return None to disable tornado's default etag support.\n        \"\"\"\n        hasher = hashlib.sha1()\n        for part in self._write_buffer:\n            hasher.update(part)\n        return '\"%s\"' % hasher.hexdigest()\n\n    def set_etag_header(self):\n        \"\"\"Sets the response's Etag header using ``self.compute_etag()``.\n\n        Note: no header will be set if ``compute_etag()`` returns ``None``.\n\n        This method is called automatically when the request is finished.\n        \"\"\"\n        etag = self.compute_etag()\n        if etag is not None:\n            self.set_header(\"Etag\", etag)\n\n    def check_etag_header(self):\n        \"\"\"Checks the ``Etag`` header against requests's ``If-None-Match``.\n\n        Returns ``True`` if the request's Etag matches and a 304 should be\n        returned. For example::\n\n            self.set_etag_header()\n            if self.check_etag_header():\n                self.set_status(304)\n                return\n\n        This method is called automatically when the request is finished,\n        but may be called earlier for applications that override\n        `compute_etag` and want to do an early check for ``If-None-Match``\n        before completing the request.  The ``Etag`` header should be set\n        (perhaps with `set_etag_header`) before calling this method.\n        \"\"\"\n        etag = self._headers.get(\"Etag\")\n        inm = utf8(self.request.headers.get(\"If-None-Match\", \"\"))\n        return bool(etag and inm and inm.find(etag) >= 0)\n\n    def _stack_context_handle_exception(self, type, value, traceback):\n        try:\n            # For historical reasons _handle_request_exception only takes\n            # the exception value instead of the full triple,\n            # so re-raise the exception to ensure that it's in\n            # sys.exc_info()\n            raise_exc_info((type, value, traceback))\n        except Exception:\n            self._handle_request_exception(value)\n        return True\n\n    def _execute(self, transforms, *args, **kwargs):\n        \"\"\"Executes this request with the given output transforms.\"\"\"\n        self._transforms = transforms\n        try:\n            if self.request.method not in self.SUPPORTED_METHODS:\n                raise HTTPError(405)\n            self.path_args = [self.decode_argument(arg) for arg in args]\n            self.path_kwargs = dict((k, self.decode_argument(v, name=k))\n                                    for (k, v) in kwargs.items())\n            # If XSRF cookies are turned on, reject form submissions without\n            # the proper cookie\n            if self.request.method not in (\"GET\", \"HEAD\", \"OPTIONS\") and \\\n                    self.application.settings.get(\"xsrf_cookies\"):\n                self.check_xsrf_cookie()\n            self._when_complete(self.prepare(), self._execute_method)\n        except Exception as e:\n            self._handle_request_exception(e)\n\n    def _when_complete(self, result, callback):\n        try:\n            if result is None:\n                callback()\n            elif isinstance(result, Future):\n                if result.done():\n                    if result.result() is not None:\n                        raise ValueError('Expected None, got %r' % result.result())\n                    callback()\n                else:\n                    # Delayed import of IOLoop because it's not available\n                    # on app engine\n                    from tornado.ioloop import IOLoop\n                    IOLoop.current().add_future(\n                        result, functools.partial(self._when_complete,\n                                                  callback=callback))\n            else:\n                raise ValueError(\"Expected Future or None, got %r\" % result)\n        except Exception as e:\n            self._handle_request_exception(e)\n\n    def _execute_method(self):\n        if not self._finished:\n            method = getattr(self, self.request.method.lower())\n            self._when_complete(method(*self.path_args, **self.path_kwargs),\n                                self._execute_finish)\n\n    def _execute_finish(self):\n        if self._auto_finish and not self._finished:\n            self.finish()\n\n    def _generate_headers(self):\n        reason = self._reason\n        lines = [utf8(self.request.version + \" \" +\n                      str(self._status_code) +\n                      \" \" + reason)]\n        lines.extend([utf8(n) + b\": \" + utf8(v) for n, v in self._headers.get_all()])\n\n        if hasattr(self, \"_new_cookie\"):\n            for cookie in self._new_cookie.values():\n                lines.append(utf8(\"Set-Cookie: \" + cookie.OutputString(None)))\n        return b\"\\r\\n\".join(lines) + b\"\\r\\n\\r\\n\"\n\n    def _log(self):\n        \"\"\"Logs the current request.\n\n        Sort of deprecated since this functionality was moved to the\n        Application, but left in place for the benefit of existing apps\n        that have overridden this method.\n        \"\"\"\n        self.application.log_request(self)\n\n    def _request_summary(self):\n        return self.request.method + \" \" + self.request.uri + \\\n            \" (\" + self.request.remote_ip + \")\"\n\n    def _handle_request_exception(self, e):\n        self.log_exception(*sys.exc_info())\n        if self._finished:\n            # Extra errors after the request has been finished should\n            # be logged, but there is no reason to continue to try and\n            # send a response.\n            return\n        if isinstance(e, HTTPError):\n            if e.status_code not in httputil.responses and not e.reason:\n                gen_log.error(\"Bad HTTP status code: %d\", e.status_code)\n                self.send_error(500, exc_info=sys.exc_info())\n            else:\n                self.send_error(e.status_code, exc_info=sys.exc_info())\n        else:\n            self.send_error(500, exc_info=sys.exc_info())\n\n    def log_exception(self, typ, value, tb):\n        \"\"\"Override to customize logging of uncaught exceptions.\n\n        By default logs instances of `HTTPError` as warnings without\n        stack traces (on the ``tornado.general`` logger), and all\n        other exceptions as errors with stack traces (on the\n        ``tornado.application`` logger).\n\n        .. versionadded:: 3.1\n        \"\"\"\n        if isinstance(value, HTTPError):\n            if value.log_message:\n                format = \"%d %s: \" + value.log_message\n                args = ([value.status_code, self._request_summary()] +\n                        list(value.args))\n                gen_log.warning(format, *args)\n        else:\n            app_log.error(\"Uncaught exception %s\\n%r\", self._request_summary(),\n                          self.request, exc_info=(typ, value, tb))\n\n    def _ui_module(self, name, module):\n        def render(*args, **kwargs):\n            if not hasattr(self, \"_active_modules\"):\n                self._active_modules = {}\n            if name not in self._active_modules:\n                self._active_modules[name] = module(self)\n            rendered = self._active_modules[name].render(*args, **kwargs)\n            return rendered\n        return render\n\n    def _ui_method(self, method):\n        return lambda *args, **kwargs: method(self, *args, **kwargs)\n\n    def _clear_headers_for_304(self):\n        # 304 responses should not contain entity headers (defined in\n        # http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.1)\n        # not explicitly allowed by\n        # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5\n        headers = [\"Allow\", \"Content-Encoding\", \"Content-Language\",\n                   \"Content-Length\", \"Content-MD5\", \"Content-Range\",\n                   \"Content-Type\", \"Last-Modified\"]\n        for h in headers:\n            self.clear_header(h)\n\n\ndef asynchronous(method):\n    \"\"\"Wrap request handler methods with this if they are asynchronous.\n\n    This decorator is unnecessary if the method is also decorated with\n    ``@gen.coroutine`` (it is legal but unnecessary to use the two\n    decorators together, in which case ``@asynchronous`` must be\n    first).\n\n    This decorator should only be applied to the :ref:`HTTP verb\n    methods <verbs>`; its behavior is undefined for any other method.\n    This decorator does not *make* a method asynchronous; it tells\n    the framework that the method *is* asynchronous.  For this decorator\n    to be useful the method must (at least sometimes) do something\n    asynchronous.\n\n    If this decorator is given, the response is not finished when the\n    method returns. It is up to the request handler to call\n    `self.finish() <RequestHandler.finish>` to finish the HTTP\n    request. Without this decorator, the request is automatically\n    finished when the ``get()`` or ``post()`` method returns. Example::\n\n       class MyRequestHandler(web.RequestHandler):\n           @web.asynchronous\n           def get(self):\n              http = httpclient.AsyncHTTPClient()\n              http.fetch(\"http://friendfeed.com/\", self._on_download)\n\n           def _on_download(self, response):\n              self.write(\"Downloaded!\")\n              self.finish()\n\n    .. versionadded:: 3.1\n       The ability to use ``@gen.coroutine`` without ``@asynchronous``.\n    \"\"\"\n    # Delay the IOLoop import because it's not available on app engine.\n    from tornado.ioloop import IOLoop\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        if self.application._wsgi:\n            raise Exception(\"@asynchronous is not supported for WSGI apps\")\n        self._auto_finish = False\n        with stack_context.ExceptionStackContext(\n                self._stack_context_handle_exception):\n            result = method(self, *args, **kwargs)\n            if isinstance(result, Future):\n                # If @asynchronous is used with @gen.coroutine, (but\n                # not @gen.engine), we can automatically finish the\n                # request when the future resolves.  Additionally,\n                # the Future will swallow any exceptions so we need\n                # to throw them back out to the stack context to finish\n                # the request.\n                def future_complete(f):\n                    f.result()\n                    if not self._finished:\n                        self.finish()\n                IOLoop.current().add_future(result, future_complete)\n                # Once we have done this, hide the Future from our\n                # caller (i.e. RequestHandler._when_complete), which\n                # would otherwise set up its own callback and\n                # exception handler (resulting in exceptions being\n                # logged twice).\n                return None\n            return result\n    return wrapper\n\n\ndef removeslash(method):\n    \"\"\"Use this decorator to remove trailing slashes from the request path.\n\n    For example, a request to ``/foo/`` would redirect to ``/foo`` with this\n    decorator. Your request handler mapping should use a regular expression\n    like ``r'/foo/*'`` in conjunction with using the decorator.\n    \"\"\"\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        if self.request.path.endswith(\"/\"):\n            if self.request.method in (\"GET\", \"HEAD\"):\n                uri = self.request.path.rstrip(\"/\")\n                if uri:  # don't try to redirect '/' to ''\n                    if self.request.query:\n                        uri += \"?\" + self.request.query\n                    self.redirect(uri, permanent=True)\n                    return\n            else:\n                raise HTTPError(404)\n        return method(self, *args, **kwargs)\n    return wrapper\n\n\ndef addslash(method):\n    \"\"\"Use this decorator to add a missing trailing slash to the request path.\n\n    For example, a request to ``/foo`` would redirect to ``/foo/`` with this\n    decorator. Your request handler mapping should use a regular expression\n    like ``r'/foo/?'`` in conjunction with using the decorator.\n    \"\"\"\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        if not self.request.path.endswith(\"/\"):\n            if self.request.method in (\"GET\", \"HEAD\"):\n                uri = self.request.path + \"/\"\n                if self.request.query:\n                    uri += \"?\" + self.request.query\n                self.redirect(uri, permanent=True)\n                return\n            raise HTTPError(404)\n        return method(self, *args, **kwargs)\n    return wrapper\n\n\nclass Application(object):\n    \"\"\"A collection of request handlers that make up a web application.\n\n    Instances of this class are callable and can be passed directly to\n    HTTPServer to serve the application::\n\n        application = web.Application([\n            (r\"/\", MainPageHandler),\n        ])\n        http_server = httpserver.HTTPServer(application)\n        http_server.listen(8080)\n        ioloop.IOLoop.instance().start()\n\n    The constructor for this class takes in a list of `URLSpec` objects\n    or (regexp, request_class) tuples. When we receive requests, we\n    iterate over the list in order and instantiate an instance of the\n    first request class whose regexp matches the request path.\n    The request class can be specified as either a class object or a\n    (fully-qualified) name.\n\n    Each tuple can contain additional elements, which correspond to the\n    arguments to the `URLSpec` constructor.  (Prior to Tornado 3.2, this\n    only tuples of two or three elements were allowed).\n\n    A dictionary may be passed as the third element of the tuple,\n    which will be used as keyword arguments to the handler's\n    constructor and `~RequestHandler.initialize` method.  This pattern\n    is used for the `StaticFileHandler` in this example (note that a\n    `StaticFileHandler` can be installed automatically with the\n    static_path setting described below)::\n\n        application = web.Application([\n            (r\"/static/(.*)\", web.StaticFileHandler, {\"path\": \"/var/www\"}),\n        ])\n\n    We support virtual hosts with the `add_handlers` method, which takes in\n    a host regular expression as the first argument::\n\n        application.add_handlers(r\"www\\.myhost\\.com\", [\n            (r\"/article/([0-9]+)\", ArticleHandler),\n        ])\n\n    You can serve static files by sending the ``static_path`` setting\n    as a keyword argument. We will serve those files from the\n    ``/static/`` URI (this is configurable with the\n    ``static_url_prefix`` setting), and we will serve ``/favicon.ico``\n    and ``/robots.txt`` from the same directory.  A custom subclass of\n    `StaticFileHandler` can be specified with the\n    ``static_handler_class`` setting.\n\n    \"\"\"\n    def __init__(self, handlers=None, default_host=\"\", transforms=None,\n                 wsgi=False, **settings):\n        if transforms is None:\n            self.transforms = []\n            if settings.get(\"gzip\"):\n                self.transforms.append(GZipContentEncoding)\n            self.transforms.append(ChunkedTransferEncoding)\n        else:\n            self.transforms = transforms\n        self.handlers = []\n        self.named_handlers = {}\n        self.default_host = default_host\n        self.settings = settings\n        self.ui_modules = {'linkify': _linkify,\n                           'xsrf_form_html': _xsrf_form_html,\n                           'Template': TemplateModule,\n                           }\n        self.ui_methods = {}\n        self._wsgi = wsgi\n        self._load_ui_modules(settings.get(\"ui_modules\", {}))\n        self._load_ui_methods(settings.get(\"ui_methods\", {}))\n        if self.settings.get(\"static_path\"):\n            path = self.settings[\"static_path\"]\n            handlers = list(handlers or [])\n            static_url_prefix = settings.get(\"static_url_prefix\",\n                                             \"/static/\")\n            static_handler_class = settings.get(\"static_handler_class\",\n                                                StaticFileHandler)\n            static_handler_args = settings.get(\"static_handler_args\", {})\n            static_handler_args['path'] = path\n            for pattern in [re.escape(static_url_prefix) + r\"(.*)\",\n                            r\"/(favicon\\.ico)\", r\"/(robots\\.txt)\"]:\n                handlers.insert(0, (pattern, static_handler_class,\n                                    static_handler_args))\n        if handlers:\n            self.add_handlers(\".*$\", handlers)\n\n        if self.settings.get('debug'):\n            self.settings.setdefault('autoreload', True)\n            self.settings.setdefault('compiled_template_cache', False)\n            self.settings.setdefault('static_hash_cache', False)\n            self.settings.setdefault('serve_traceback', True)\n\n        # Automatically reload modified modules\n        if self.settings.get('autoreload') and not wsgi:\n            from tornado import autoreload\n            autoreload.start()\n\n    def listen(self, port, address=\"\", **kwargs):\n        \"\"\"Starts an HTTP server for this application on the given port.\n\n        This is a convenience alias for creating an `.HTTPServer`\n        object and calling its listen method.  Keyword arguments not\n        supported by `HTTPServer.listen <.TCPServer.listen>` are passed to the\n        `.HTTPServer` constructor.  For advanced uses\n        (e.g. multi-process mode), do not use this method; create an\n        `.HTTPServer` and call its\n        `.TCPServer.bind`/`.TCPServer.start` methods directly.\n\n        Note that after calling this method you still need to call\n        ``IOLoop.instance().start()`` to start the server.\n        \"\"\"\n        # import is here rather than top level because HTTPServer\n        # is not importable on appengine\n        from tornado.httpserver import HTTPServer\n        server = HTTPServer(self, **kwargs)\n        server.listen(port, address)\n\n    def add_handlers(self, host_pattern, host_handlers):\n        \"\"\"Appends the given handlers to our handler list.\n\n        Host patterns are processed sequentially in the order they were\n        added. All matching patterns will be considered.\n        \"\"\"\n        if not host_pattern.endswith(\"$\"):\n            host_pattern += \"$\"\n        handlers = []\n        # The handlers with the wildcard host_pattern are a special\n        # case - they're added in the constructor but should have lower\n        # precedence than the more-precise handlers added later.\n        # If a wildcard handler group exists, it should always be last\n        # in the list, so insert new groups just before it.\n        if self.handlers and self.handlers[-1][0].pattern == '.*$':\n            self.handlers.insert(-1, (re.compile(host_pattern), handlers))\n        else:\n            self.handlers.append((re.compile(host_pattern), handlers))\n\n        for spec in host_handlers:\n            if isinstance(spec, (tuple, list)):\n                assert len(spec) in (2, 3, 4)\n                spec = URLSpec(*spec)\n            handlers.append(spec)\n            if spec.name:\n                if spec.name in self.named_handlers:\n                    app_log.warning(\n                        \"Multiple handlers named %s; replacing previous value\",\n                        spec.name)\n                self.named_handlers[spec.name] = spec\n\n    def add_transform(self, transform_class):\n        self.transforms.append(transform_class)\n\n    def _get_host_handlers(self, request):\n        host = request.host.lower().split(':')[0]\n        matches = []\n        for pattern, handlers in self.handlers:\n            if pattern.match(host):\n                matches.extend(handlers)\n        # Look for default host if not behind load balancer (for debugging)\n        if not matches and \"X-Real-Ip\" not in request.headers:\n            for pattern, handlers in self.handlers:\n                if pattern.match(self.default_host):\n                    matches.extend(handlers)\n        return matches or None\n\n    def _load_ui_methods(self, methods):\n        if isinstance(methods, types.ModuleType):\n            self._load_ui_methods(dict((n, getattr(methods, n))\n                                       for n in dir(methods)))\n        elif isinstance(methods, list):\n            for m in methods:\n                self._load_ui_methods(m)\n        else:\n            for name, fn in methods.items():\n                if not name.startswith(\"_\") and hasattr(fn, \"__call__\") \\\n                        and name[0].lower() == name[0]:\n                    self.ui_methods[name] = fn\n\n    def _load_ui_modules(self, modules):\n        if isinstance(modules, types.ModuleType):\n            self._load_ui_modules(dict((n, getattr(modules, n))\n                                       for n in dir(modules)))\n        elif isinstance(modules, list):\n            for m in modules:\n                self._load_ui_modules(m)\n        else:\n            assert isinstance(modules, dict)\n            for name, cls in modules.items():\n                try:\n                    if issubclass(cls, UIModule):\n                        self.ui_modules[name] = cls\n                except TypeError:\n                    pass\n\n    def __call__(self, request):\n        \"\"\"Called by HTTPServer to execute the request.\"\"\"\n        transforms = [t(request) for t in self.transforms]\n        handler = None\n        args = []\n        kwargs = {}\n        handlers = self._get_host_handlers(request)\n        if not handlers:\n            handler = RedirectHandler(\n                self, request, url=\"http://\" + self.default_host + \"/\")\n        else:\n            for spec in handlers:\n                match = spec.regex.match(request.path)\n                if match:\n                    handler = spec.handler_class(self, request, **spec.kwargs)\n                    if spec.regex.groups:\n                        # None-safe wrapper around url_unescape to handle\n                        # unmatched optional groups correctly\n                        def unquote(s):\n                            if s is None:\n                                return s\n                            return escape.url_unescape(s, encoding=None,\n                                                       plus=False)\n                        # Pass matched groups to the handler.  Since\n                        # match.groups() includes both named and unnamed groups,\n                        # we want to use either groups or groupdict but not both.\n                        # Note that args are passed as bytes so the handler can\n                        # decide what encoding to use.\n\n                        if spec.regex.groupindex:\n                            kwargs = dict(\n                                (str(k), unquote(v))\n                                for (k, v) in match.groupdict().items())\n                        else:\n                            args = [unquote(s) for s in match.groups()]\n                    break\n            if not handler:\n                if self.settings.get('default_handler_class'):\n                    handler_class = self.settings['default_handler_class']\n                    handler_args = self.settings.get(\n                        'default_handler_args', {})\n                else:\n                    handler_class = ErrorHandler\n                    handler_args = dict(status_code=404)\n                handler = handler_class(self, request, **handler_args)\n\n        # If template cache is disabled (usually in the debug mode),\n        # re-compile templates and reload static files on every\n        # request so you don't need to restart to see changes\n        if not self.settings.get(\"compiled_template_cache\", True):\n            with RequestHandler._template_loader_lock:\n                for loader in RequestHandler._template_loaders.values():\n                    loader.reset()\n        if not self.settings.get('static_hash_cache', True):\n            StaticFileHandler.reset()\n\n        handler._execute(transforms, *args, **kwargs)\n        return handler\n\n    def reverse_url(self, name, *args):\n        \"\"\"Returns a URL path for handler named ``name``\n\n        The handler must be added to the application as a named `URLSpec`.\n\n        Args will be substituted for capturing groups in the `URLSpec` regex.\n        They will be converted to strings if necessary, encoded as utf8,\n        and url-escaped.\n        \"\"\"\n        if name in self.named_handlers:\n            return self.named_handlers[name].reverse(*args)\n        raise KeyError(\"%s not found in named urls\" % name)\n\n    def log_request(self, handler):\n        \"\"\"Writes a completed HTTP request to the logs.\n\n        By default writes to the python root logger.  To change\n        this behavior either subclass Application and override this method,\n        or pass a function in the application settings dictionary as\n        ``log_function``.\n        \"\"\"\n        if \"log_function\" in self.settings:\n            self.settings[\"log_function\"](handler)\n            return\n        if handler.get_status() < 400:\n            log_method = access_log.info\n        elif handler.get_status() < 500:\n            log_method = access_log.warning\n        else:\n            log_method = access_log.error\n        request_time = 1000.0 * handler.request.request_time()\n        log_method(\"%d %s %.2fms\", handler.get_status(),\n                   handler._request_summary(), request_time)\n\n\nclass HTTPError(Exception):\n    \"\"\"An exception that will turn into an HTTP error response.\n\n    Raising an `HTTPError` is a convenient alternative to calling\n    `RequestHandler.send_error` since it automatically ends the\n    current function.\n\n    :arg int status_code: HTTP status code.  Must be listed in\n        `httplib.responses <http.client.responses>` unless the ``reason``\n        keyword argument is given.\n    :arg string log_message: Message to be written to the log for this error\n        (will not be shown to the user unless the `Application` is in debug\n        mode).  May contain ``%s``-style placeholders, which will be filled\n        in with remaining positional parameters.\n    :arg string reason: Keyword-only argument.  The HTTP \"reason\" phrase\n        to pass in the status line along with ``status_code``.  Normally\n        determined automatically from ``status_code``, but can be used\n        to use a non-standard numeric code.\n    \"\"\"\n    def __init__(self, status_code, log_message=None, *args, **kwargs):\n        self.status_code = status_code\n        self.log_message = log_message\n        self.args = args\n        self.reason = kwargs.get('reason', None)\n\n    def __str__(self):\n        message = \"HTTP %d: %s\" % (\n            self.status_code,\n            self.reason or httputil.responses.get(self.status_code, 'Unknown'))\n        if self.log_message:\n            return message + \" (\" + (self.log_message % self.args) + \")\"\n        else:\n            return message\n\n\nclass MissingArgumentError(HTTPError):\n    \"\"\"Exception raised by `RequestHandler.get_argument`.\n\n    This is a subclass of `HTTPError`, so if it is uncaught a 400 response\n    code will be used instead of 500 (and a stack trace will not be logged).\n\n    .. versionadded:: 3.1\n    \"\"\"\n    def __init__(self, arg_name):\n        super(MissingArgumentError, self).__init__(\n            400, 'Missing argument %s' % arg_name)\n        self.arg_name = arg_name\n\n\nclass ErrorHandler(RequestHandler):\n    \"\"\"Generates an error response with ``status_code`` for all requests.\"\"\"\n    def initialize(self, status_code):\n        self.set_status(status_code)\n\n    def prepare(self):\n        raise HTTPError(self._status_code)\n\n    def check_xsrf_cookie(self):\n        # POSTs to an ErrorHandler don't actually have side effects,\n        # so we don't need to check the xsrf token.  This allows POSTs\n        # to the wrong url to return a 404 instead of 403.\n        pass\n\n\nclass RedirectHandler(RequestHandler):\n    \"\"\"Redirects the client to the given URL for all GET requests.\n\n    You should provide the keyword argument ``url`` to the handler, e.g.::\n\n        application = web.Application([\n            (r\"/oldpath\", web.RedirectHandler, {\"url\": \"/newpath\"}),\n        ])\n    \"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        self.redirect(self._url, permanent=self._permanent)\n\n\nclass StaticFileHandler(RequestHandler):\n    \"\"\"A simple handler that can serve static content from a directory.\n\n    A `StaticFileHandler` is configured automatically if you pass the\n    ``static_path`` keyword argument to `Application`.  This handler\n    can be customized with the ``static_url_prefix``, ``static_handler_class``,\n    and ``static_handler_args`` settings.\n\n    To map an additional path to this handler for a static data directory\n    you would add a line to your application like::\n\n        application = web.Application([\n            (r\"/content/(.*)\", web.StaticFileHandler, {\"path\": \"/var/www\"}),\n        ])\n\n    The handler constructor requires a ``path`` argument, which specifies the\n    local root directory of the content to be served.\n\n    Note that a capture group in the regex is required to parse the value for\n    the ``path`` argument to the get() method (different than the constructor\n    argument above); see `URLSpec` for details.\n\n    To maximize the effectiveness of browser caching, this class supports\n    versioned urls (by default using the argument ``?v=``).  If a version\n    is given, we instruct the browser to cache this file indefinitely.\n    `make_static_url` (also available as `RequestHandler.static_url`) can\n    be used to construct a versioned url.\n\n    This handler is intended primarily for use in development and light-duty\n    file serving; for heavy traffic it will be more efficient to use\n    a dedicated static file server (such as nginx or Apache).  We support\n    the HTTP ``Accept-Ranges`` mechanism to return partial content (because\n    some browsers require this functionality to be present to seek in\n    HTML5 audio or video), but this handler should not be used with\n    files that are too large to fit comfortably in memory.\n\n    **Subclassing notes**\n\n    This class is designed to be extensible by subclassing, but because\n    of the way static urls are generated with class methods rather than\n    instance methods, the inheritance patterns are somewhat unusual.\n    Be sure to use the ``@classmethod`` decorator when overriding a\n    class method.  Instance methods may use the attributes ``self.path``\n    ``self.absolute_path``, and ``self.modified``.\n\n    Subclasses should only override methods discussed in this section;\n    overriding other methods is error-prone.  Overriding\n    ``StaticFileHandler.get`` is particularly problematic due to the\n    tight coupling with ``compute_etag`` and other methods.\n\n    To change the way static urls are generated (e.g. to match the behavior\n    of another server or CDN), override `make_static_url`, `parse_url_path`,\n    `get_cache_time`, and/or `get_version`.\n\n    To replace all interaction with the filesystem (e.g. to serve\n    static content from a database), override `get_content`,\n    `get_content_size`, `get_modified_time`, `get_absolute_path`, and\n    `validate_absolute_path`.\n\n    .. versionchanged:: 3.1\n       Many of the methods for subclasses were added in Tornado 3.1.\n    \"\"\"\n    CACHE_MAX_AGE = 86400 * 365 * 10  # 10 years\n\n    _static_hashes = {}\n    _lock = threading.Lock()  # protects _static_hashes\n\n    def initialize(self, path, default_filename=None):\n        self.root = path\n        self.default_filename = default_filename\n\n    @classmethod\n    def reset(cls):\n        with cls._lock:\n            cls._static_hashes = {}\n\n    def head(self, path):\n        self.get(path, include_body=False)\n\n    def get(self, path, include_body=True):\n        # Set up our path instance variables.\n        self.path = self.parse_url_path(path)\n        del path  # make sure we don't refer to path instead of self.path again\n        absolute_path = self.get_absolute_path(self.root, self.path)\n        self.absolute_path = self.validate_absolute_path(\n            self.root, absolute_path)\n        if self.absolute_path is None:\n            return\n\n        self.modified = self.get_modified_time()\n        self.set_headers()\n\n        if self.should_return_304():\n            self.set_status(304)\n            return\n\n        request_range = None\n        range_header = self.request.headers.get(\"Range\")\n        if range_header:\n            # As per RFC 2616 14.16, if an invalid Range header is specified,\n            # the request will be treated as if the header didn't exist.\n            request_range = httputil._parse_request_range(range_header)\n\n        if request_range:\n            start, end = request_range\n            size = self.get_content_size()\n            if (start is not None and start >= size) or end == 0:\n                # As per RFC 2616 14.35.1, a range is not satisfiable only: if\n                # the first requested byte is equal to or greater than the\n                # content, or when a suffix with length 0 is specified\n                self.set_status(416)  # Range Not Satisfiable\n                self.set_header(\"Content-Type\", \"text/plain\")\n                self.set_header(\"Content-Range\", \"bytes */%s\" % (size, ))\n                return\n            if start is not None and start < 0:\n                start += size\n            if end is not None and end > size:\n                # Clients sometimes blindly use a large range to limit their\n                # download size; cap the endpoint at the actual file size.\n                end = size\n            # Note: only return HTTP 206 if less than the entire range has been\n            # requested. Not only is this semantically correct, but Chrome\n            # refuses to play audio if it gets an HTTP 206 in response to\n            # ``Range: bytes=0-``.\n            if size != (end or size) - (start or 0):\n                self.set_status(206)  # Partial Content\n                self.set_header(\"Content-Range\",\n                                httputil._get_content_range(start, end, size))\n        else:\n            start = end = None\n        content = self.get_content(self.absolute_path, start, end)\n        if isinstance(content, bytes_type):\n            content = [content]\n        content_length = 0\n        for chunk in content:\n            if include_body:\n                self.write(chunk)\n            else:\n                content_length += len(chunk)\n        if not include_body:\n            assert self.request.method == \"HEAD\"\n            self.set_header(\"Content-Length\", content_length)\n\n    def compute_etag(self):\n        \"\"\"Sets the ``Etag`` header based on static url version.\n\n        This allows efficient ``If-None-Match`` checks against cached\n        versions, and sends the correct ``Etag`` for a partial response\n        (i.e. the same ``Etag`` as the full file).\n\n        .. versionadded:: 3.1\n        \"\"\"\n        version_hash = self._get_cached_version(self.absolute_path)\n        if not version_hash:\n            return None\n        return '\"%s\"' % (version_hash, )\n\n    def set_headers(self):\n        \"\"\"Sets the content and caching headers on the response.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        self.set_header(\"Accept-Ranges\", \"bytes\")\n        self.set_etag_header()\n\n        if self.modified is not None:\n            self.set_header(\"Last-Modified\", self.modified)\n\n        content_type = self.get_content_type()\n        if content_type:\n            self.set_header(\"Content-Type\", content_type)\n\n        cache_time = self.get_cache_time(self.path, self.modified, content_type)\n        if cache_time > 0:\n            self.set_header(\"Expires\", datetime.datetime.utcnow() +\n                            datetime.timedelta(seconds=cache_time))\n            self.set_header(\"Cache-Control\", \"max-age=\" + str(cache_time))\n\n        self.set_extra_headers(self.path)\n\n    def should_return_304(self):\n        \"\"\"Returns True if the headers indicate that we should return 304.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        if self.check_etag_header():\n            return True\n\n        # Check the If-Modified-Since, and don't send the result if the\n        # content has not been modified\n        ims_value = self.request.headers.get(\"If-Modified-Since\")\n        if ims_value is not None:\n            date_tuple = email.utils.parsedate(ims_value)\n            if date_tuple is not None:\n                if_since = datetime.datetime(*date_tuple[:6])\n                if if_since >= self.modified:\n                    return True\n\n        return False\n\n    @classmethod\n    def get_absolute_path(cls, root, path):\n        \"\"\"Returns the absolute location of ``path`` relative to ``root``.\n\n        ``root`` is the path configured for this `StaticFileHandler`\n        (in most cases the ``static_path`` `Application` setting).\n\n        This class method may be overridden in subclasses.  By default\n        it returns a filesystem path, but other strings may be used\n        as long as they are unique and understood by the subclass's\n        overridden `get_content`.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        abspath = os.path.abspath(os.path.join(root, path))\n        return abspath\n\n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n\n        ``root`` is the configured path for the `StaticFileHandler`,\n        and ``path`` is the result of `get_absolute_path`\n\n        This is an instance method called during request processing,\n        so it may raise `HTTPError` or use methods like\n        `RequestHandler.redirect` (return None after redirecting to\n        halt further processing).  This is where 404 errors for missing files\n        are generated.\n\n        This method may modify the path before returning it, but note that\n        any such modifications will not be understood by `make_static_url`.\n\n        In instance methods, this method's result is available as\n        ``self.absolute_path``.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        root = os.path.abspath(root)\n        # os.path.abspath strips a trailing /\n        # it needs to be temporarily added back for requests to root/\n        if not (absolute_path + os.path.sep).startswith(root):\n            raise HTTPError(403, \"%s is not in root static directory\",\n                            self.path)\n        if (os.path.isdir(absolute_path) and\n                self.default_filename is not None):\n            # need to look at the request.path here for when path is empty\n            # but there is some prefix to the path that was already\n            # trimmed by the routing\n            if not self.request.path.endswith(\"/\"):\n                self.redirect(self.request.path + \"/\", permanent=True)\n                return\n            absolute_path = os.path.join(absolute_path, self.default_filename)\n        if not os.path.exists(absolute_path):\n            raise HTTPError(404)\n        if not os.path.isfile(absolute_path):\n            raise HTTPError(403, \"%s is not a file\", self.path)\n        return absolute_path\n\n    @classmethod\n    def get_content(cls, abspath, start=None, end=None):\n        \"\"\"Retrieve the content of the requested resource which is located\n        at the given absolute path.\n\n        This class method may be overridden by subclasses.  Note that its\n        signature is different from other overridable class methods\n        (no ``settings`` argument); this is deliberate to ensure that\n        ``abspath`` is able to stand on its own as a cache key.\n\n        This method should either return a byte string or an iterator\n        of byte strings.  The latter is preferred for large files\n        as it helps reduce memory fragmentation.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        with open(abspath, \"rb\") as file:\n            if start is not None:\n                file.seek(start)\n            if end is not None:\n                remaining = end - (start or 0)\n            else:\n                remaining = None\n            while True:\n                chunk_size = 64 * 1024\n                if remaining is not None and remaining < chunk_size:\n                    chunk_size = remaining\n                chunk = file.read(chunk_size)\n                if chunk:\n                    if remaining is not None:\n                        remaining -= len(chunk)\n                    yield chunk\n                else:\n                    if remaining is not None:\n                        assert remaining == 0\n                    return\n\n    @classmethod\n    def get_content_version(cls, abspath):\n        \"\"\"Returns a version string for the resource at the given path.\n\n        This class method may be overridden by subclasses.  The\n        default implementation is a hash of the file's contents.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        data = cls.get_content(abspath)\n        hasher = hashlib.md5()\n        if isinstance(data, bytes_type):\n            hasher.update(data)\n        else:\n            for chunk in data:\n                hasher.update(chunk)\n        return hasher.hexdigest()\n\n    def _stat(self):\n        if not hasattr(self, '_stat_result'):\n            self._stat_result = os.stat(self.absolute_path)\n        return self._stat_result\n\n    def get_content_size(self):\n        \"\"\"Retrieve the total size of the resource at the given path.\n\n        This method may be overridden by subclasses. It will only\n        be called if a partial result is requested from `get_content`\n\n        .. versionadded:: 3.1\n        \"\"\"\n        stat_result = self._stat()\n        return stat_result[stat.ST_SIZE]\n\n    def get_modified_time(self):\n        \"\"\"Returns the time that ``self.absolute_path`` was last modified.\n\n        May be overridden in subclasses.  Should return a `~datetime.datetime`\n        object or None.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        stat_result = self._stat()\n        modified = datetime.datetime.utcfromtimestamp(stat_result[stat.ST_MTIME])\n        return modified\n\n    def get_content_type(self):\n        \"\"\"Returns the ``Content-Type`` header to be used for this request.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        mime_type, encoding = mimetypes.guess_type(self.absolute_path)\n        return mime_type\n\n    def set_extra_headers(self, path):\n        \"\"\"For subclass to add extra headers to the response\"\"\"\n        pass\n\n    def get_cache_time(self, path, modified, mime_type):\n        \"\"\"Override to customize cache control behavior.\n\n        Return a positive number of seconds to make the result\n        cacheable for that amount of time or 0 to mark resource as\n        cacheable for an unspecified amount of time (subject to\n        browser heuristics).\n\n        By default returns cache expiry of 10 years for resources requested\n        with ``v`` argument.\n        \"\"\"\n        return self.CACHE_MAX_AGE if \"v\" in self.request.arguments else 0\n\n    @classmethod\n    def make_static_url(cls, settings, path, include_version=True):\n        \"\"\"Constructs a versioned url for the given path.\n\n        This method may be overridden in subclasses (but note that it\n        is a class method rather than an instance method).  Subclasses\n        are only required to implement the signature\n        ``make_static_url(cls, settings, path)``; other keyword\n        arguments may be passed through `~RequestHandler.static_url`\n        but are not standard.\n\n        ``settings`` is the `Application.settings` dictionary.  ``path``\n        is the static path being requested.  The url returned should be\n        relative to the current host.\n\n        ``include_version`` determines whether the generated URL should\n        include the query string containing the version hash of the\n        file corresponding to the given ``path``.\n\n        \"\"\"\n        url = settings.get('static_url_prefix', '/static/') + path\n        if not include_version:\n            return url\n\n        version_hash = cls.get_version(settings, path)\n        if not version_hash:\n            return url\n\n        return '%s?v=%s' % (url, version_hash)\n\n    def parse_url_path(self, url_path):\n        \"\"\"Converts a static URL path into a filesystem path.\n\n        ``url_path`` is the path component of the URL with\n        ``static_url_prefix`` removed.  The return value should be\n        filesystem path relative to ``static_path``.\n\n        This is the inverse of `make_static_url`.\n        \"\"\"\n        if os.path.sep != \"/\":\n            url_path = url_path.replace(\"/\", os.path.sep)\n        return url_path\n\n    @classmethod\n    def get_version(cls, settings, path):\n        \"\"\"Generate the version string to be used in static URLs.\n\n        ``settings`` is the `Application.settings` dictionary and ``path``\n        is the relative location of the requested asset on the filesystem.\n        The returned value should be a string, or ``None`` if no version\n        could be determined.\n\n        .. versionchanged:: 3.1\n           This method was previously recommended for subclasses to override;\n           `get_content_version` is now preferred as it allows the base\n           class to handle caching of the result.\n        \"\"\"\n        abs_path = cls.get_absolute_path(settings['static_path'], path)\n        return cls._get_cached_version(abs_path)\n\n    @classmethod\n    def _get_cached_version(cls, abs_path):\n        with cls._lock:\n            hashes = cls._static_hashes\n            if abs_path not in hashes:\n                try:\n                    hashes[abs_path] = cls.get_content_version(abs_path)\n                except Exception:\n                    gen_log.error(\"Could not open static file %r\", abs_path)\n                    hashes[abs_path] = None\n            hsh = hashes.get(abs_path)\n            if hsh:\n                return hsh\n        return None\n\n\nclass FallbackHandler(RequestHandler):\n    \"\"\"A `RequestHandler` that wraps another HTTP server callback.\n\n    The fallback is a callable object that accepts an\n    `~.httpserver.HTTPRequest`, such as an `Application` or\n    `tornado.wsgi.WSGIContainer`.  This is most useful to use both\n    Tornado ``RequestHandlers`` and WSGI in the same server.  Typical\n    usage::\n\n        wsgi_app = tornado.wsgi.WSGIContainer(\n            django.core.handlers.wsgi.WSGIHandler())\n        application = tornado.web.Application([\n            (r\"/foo\", FooHandler),\n            (r\".*\", FallbackHandler, dict(fallback=wsgi_app),\n        ])\n    \"\"\"\n    def initialize(self, fallback):\n        self.fallback = fallback\n\n    def prepare(self):\n        self.fallback(self.request)\n        self._finished = True\n\n\nclass OutputTransform(object):\n    \"\"\"A transform modifies the result of an HTTP request (e.g., GZip encoding)\n\n    A new transform instance is created for every request. See the\n    ChunkedTransferEncoding example below if you want to implement a\n    new Transform.\n    \"\"\"\n    def __init__(self, request):\n        pass\n\n    def transform_first_chunk(self, status_code, headers, chunk, finishing):\n        return status_code, headers, chunk\n\n    def transform_chunk(self, chunk, finishing):\n        return chunk\n\n\nclass GZipContentEncoding(OutputTransform):\n    \"\"\"Applies the gzip content encoding to the response.\n\n    See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11\n    \"\"\"\n    CONTENT_TYPES = set([\n        \"text/plain\", \"text/html\", \"text/css\", \"text/xml\", \"application/javascript\",\n        \"application/x-javascript\", \"application/xml\", \"application/atom+xml\",\n        \"text/javascript\", \"application/json\", \"application/xhtml+xml\"])\n    MIN_LENGTH = 5\n\n    def __init__(self, request):\n        self._gzipping = request.supports_http_1_1() and \\\n            \"gzip\" in request.headers.get(\"Accept-Encoding\", \"\")\n\n    def transform_first_chunk(self, status_code, headers, chunk, finishing):\n        if 'Vary' in headers:\n            headers['Vary'] += b', Accept-Encoding'\n        else:\n            headers['Vary'] = b'Accept-Encoding'\n        if self._gzipping:\n            ctype = _unicode(headers.get(\"Content-Type\", \"\")).split(\";\")[0]\n            self._gzipping = (ctype in self.CONTENT_TYPES) and \\\n                (not finishing or len(chunk) >= self.MIN_LENGTH) and \\\n                (finishing or \"Content-Length\" not in headers) and \\\n                (\"Content-Encoding\" not in headers)\n        if self._gzipping:\n            headers[\"Content-Encoding\"] = \"gzip\"\n            self._gzip_value = BytesIO()\n            self._gzip_file = gzip.GzipFile(mode=\"w\", fileobj=self._gzip_value)\n            chunk = self.transform_chunk(chunk, finishing)\n            if \"Content-Length\" in headers:\n                headers[\"Content-Length\"] = str(len(chunk))\n        return status_code, headers, chunk\n\n    def transform_chunk(self, chunk, finishing):\n        if self._gzipping:\n            self._gzip_file.write(chunk)\n            if finishing:\n                self._gzip_file.close()\n            else:\n                self._gzip_file.flush()\n            chunk = self._gzip_value.getvalue()\n            self._gzip_value.truncate(0)\n            self._gzip_value.seek(0)\n        return chunk\n\n\nclass ChunkedTransferEncoding(OutputTransform):\n    \"\"\"Applies the chunked transfer encoding to the response.\n\n    See http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6.1\n    \"\"\"\n    def __init__(self, request):\n        self._chunking = request.supports_http_1_1()\n\n    def transform_first_chunk(self, status_code, headers, chunk, finishing):\n        # 304 responses have no body (not even a zero-length body), and so\n        # should not have either Content-Length or Transfer-Encoding headers.\n        if self._chunking and status_code != 304:\n            # No need to chunk the output if a Content-Length is specified\n            if \"Content-Length\" in headers or \"Transfer-Encoding\" in headers:\n                self._chunking = False\n            else:\n                headers[\"Transfer-Encoding\"] = \"chunked\"\n                chunk = self.transform_chunk(chunk, finishing)\n        return status_code, headers, chunk\n\n    def transform_chunk(self, block, finishing):\n        if self._chunking:\n            # Don't write out empty chunks because that means END-OF-STREAM\n            # with chunked encoding\n            if block:\n                block = utf8(\"%x\" % len(block)) + b\"\\r\\n\" + block + b\"\\r\\n\"\n            if finishing:\n                block += b\"0\\r\\n\\r\\n\"\n        return block\n\n\ndef authenticated(method):\n    \"\"\"Decorate methods with this to require that the user be logged in.\n\n    If the user is not logged in, they will be redirected to the configured\n    `login url <RequestHandler.get_login_url>`.\n    \"\"\"\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        if not self.current_user:\n            if self.request.method in (\"GET\", \"HEAD\"):\n                url = self.get_login_url()\n                if \"?\" not in url:\n                    if urlparse.urlsplit(url).scheme:\n                        # if login url is absolute, make next absolute too\n                        next_url = self.request.full_url()\n                    else:\n                        next_url = self.request.uri\n                    url += \"?\" + urlencode(dict(next=next_url))\n                self.redirect(url)\n                return\n            raise HTTPError(403)\n        return method(self, *args, **kwargs)\n    return wrapper\n\n\nclass UIModule(object):\n    \"\"\"A re-usable, modular UI unit on a page.\n\n    UI modules often execute additional queries, and they can include\n    additional CSS and JavaScript that will be included in the output\n    page, which is automatically inserted on page render.\n    \"\"\"\n    def __init__(self, handler):\n        self.handler = handler\n        self.request = handler.request\n        self.ui = handler.ui\n        self.locale = handler.locale\n\n    @property\n    def current_user(self):\n        return self.handler.current_user\n\n    def render(self, *args, **kwargs):\n        \"\"\"Overridden in subclasses to return this module's output.\"\"\"\n        raise NotImplementedError()\n\n    def embedded_javascript(self):\n        \"\"\"Returns a JavaScript string that will be embedded in the page.\"\"\"\n        return None\n\n    def javascript_files(self):\n        \"\"\"Returns a list of JavaScript files required by this module.\"\"\"\n        return None\n\n    def embedded_css(self):\n        \"\"\"Returns a CSS string that will be embedded in the page.\"\"\"\n        return None\n\n    def css_files(self):\n        \"\"\"Returns a list of CSS files required by this module.\"\"\"\n        return None\n\n    def html_head(self):\n        \"\"\"Returns a CSS string that will be put in the <head/> element\"\"\"\n        return None\n\n    def html_body(self):\n        \"\"\"Returns an HTML string that will be put in the <body/> element\"\"\"\n        return None\n\n    def render_string(self, path, **kwargs):\n        \"\"\"Renders a template and returns it as a string.\"\"\"\n        return self.handler.render_string(path, **kwargs)\n\n\nclass _linkify(UIModule):\n    def render(self, text, **kwargs):\n        return escape.linkify(text, **kwargs)\n\n\nclass _xsrf_form_html(UIModule):\n    def render(self):\n        return self.handler.xsrf_form_html()\n\n\nclass TemplateModule(UIModule):\n    \"\"\"UIModule that simply renders the given template.\n\n    {% module Template(\"foo.html\") %} is similar to {% include \"foo.html\" %},\n    but the module version gets its own namespace (with kwargs passed to\n    Template()) instead of inheriting the outer template's namespace.\n\n    Templates rendered through this module also get access to UIModule's\n    automatic javascript/css features.  Simply call set_resources\n    inside the template and give it keyword arguments corresponding to\n    the methods on UIModule: {{ set_resources(js_files=static_url(\"my.js\")) }}\n    Note that these resources are output once per template file, not once\n    per instantiation of the template, so they must not depend on\n    any arguments to the template.\n    \"\"\"\n    def __init__(self, handler):\n        super(TemplateModule, self).__init__(handler)\n        # keep resources in both a list and a dict to preserve order\n        self._resource_list = []\n        self._resource_dict = {}\n\n    def render(self, path, **kwargs):\n        def set_resources(**kwargs):\n            if path not in self._resource_dict:\n                self._resource_list.append(kwargs)\n                self._resource_dict[path] = kwargs\n            else:\n                if self._resource_dict[path] != kwargs:\n                    raise ValueError(\"set_resources called with different \"\n                                     \"resources for the same template\")\n            return \"\"\n        return self.render_string(path, set_resources=set_resources,\n                                  **kwargs)\n\n    def _get_resources(self, key):\n        return (r[key] for r in self._resource_list if key in r)\n\n    def embedded_javascript(self):\n        return \"\\n\".join(self._get_resources(\"embedded_javascript\"))\n\n    def javascript_files(self):\n        result = []\n        for f in self._get_resources(\"javascript_files\"):\n            if isinstance(f, (unicode_type, bytes_type)):\n                result.append(f)\n            else:\n                result.extend(f)\n        return result\n\n    def embedded_css(self):\n        return \"\\n\".join(self._get_resources(\"embedded_css\"))\n\n    def css_files(self):\n        result = []\n        for f in self._get_resources(\"css_files\"):\n            if isinstance(f, (unicode_type, bytes_type)):\n                result.append(f)\n            else:\n                result.extend(f)\n        return result\n\n    def html_head(self):\n        return \"\".join(self._get_resources(\"html_head\"))\n\n    def html_body(self):\n        return \"\".join(self._get_resources(\"html_body\"))\n\n\nclass _UIModuleNamespace(object):\n    \"\"\"Lazy namespace which creates UIModule proxies bound to a handler.\"\"\"\n    def __init__(self, handler, ui_modules):\n        self.handler = handler\n        self.ui_modules = ui_modules\n\n    def __getitem__(self, key):\n        return self.handler._ui_module(key, self.ui_modules[key])\n\n    def __getattr__(self, key):\n        try:\n            return self[key]\n        except KeyError as e:\n            raise AttributeError(str(e))\n\n\nclass URLSpec(object):\n    \"\"\"Specifies mappings between URLs and handlers.\"\"\"\n    def __init__(self, pattern, handler, kwargs=None, name=None):\n        \"\"\"Parameters:\n\n        * ``pattern``: Regular expression to be matched.  Any groups\n          in the regex will be passed in to the handler's get/post/etc\n          methods as arguments.\n\n        * ``handler_class``: `RequestHandler` subclass to be invoked.\n\n        * ``kwargs`` (optional): A dictionary of additional arguments\n          to be passed to the handler's constructor.\n\n        * ``name`` (optional): A name for this handler.  Used by\n          `Application.reverse_url`.\n        \"\"\"\n        if not pattern.endswith('$'):\n            pattern += '$'\n        self.regex = re.compile(pattern)\n        assert len(self.regex.groupindex) in (0, self.regex.groups), \\\n            (\"groups in url regexes must either be all named or all \"\n             \"positional: %r\" % self.regex.pattern)\n\n        if isinstance(handler, str):\n            # import the Module and instantiate the class\n            # Must be a fully qualified name (module.ClassName)\n            handler = import_object(handler)\n\n        self.handler_class = handler\n        self.kwargs = kwargs or {}\n        self.name = name\n        self._path, self._group_count = self._find_groups()\n\n    def __repr__(self):\n        return '%s(%r, %s, kwargs=%r, name=%r)' % \\\n            (self.__class__.__name__, self.regex.pattern,\n             self.handler_class, self.kwargs, self.name)\n\n    def _find_groups(self):\n        \"\"\"Returns a tuple (reverse string, group count) for a url.\n\n        For example: Given the url pattern /([0-9]{4})/([a-z-]+)/, this method\n        would return ('/%s/%s/', 2).\n        \"\"\"\n        pattern = self.regex.pattern\n        if pattern.startswith('^'):\n            pattern = pattern[1:]\n        if pattern.endswith('$'):\n            pattern = pattern[:-1]\n\n        if self.regex.groups != pattern.count('('):\n            # The pattern is too complicated for our simplistic matching,\n            # so we can't support reversing it.\n            return (None, None)\n\n        pieces = []\n        for fragment in pattern.split('('):\n            if ')' in fragment:\n                paren_loc = fragment.index(')')\n                if paren_loc >= 0:\n                    pieces.append('%s' + fragment[paren_loc + 1:])\n            else:\n                pieces.append(fragment)\n\n        return (''.join(pieces), self.regex.groups)\n\n    def reverse(self, *args):\n        assert self._path is not None, \\\n            \"Cannot reverse url regex \" + self.regex.pattern\n        assert len(args) == self._group_count, \"required number of arguments \"\\\n            \"not found\"\n        if not len(args):\n            return self._path\n        converted_args = []\n        for a in args:\n            if not isinstance(a, (unicode_type, bytes_type)):\n                a = str(a)\n            converted_args.append(escape.url_escape(utf8(a), plus=False))\n        return self._path % tuple(converted_args)\n\nurl = URLSpec\n\n\nif hasattr(hmac, 'compare_digest'):  # python 3.3\n    _time_independent_equals = hmac.compare_digest\nelse:\n    def _time_independent_equals(a, b):\n        if len(a) != len(b):\n            return False\n        result = 0\n        if isinstance(a[0], int):  # python3 byte strings\n            for x, y in zip(a, b):\n                result |= x ^ y\n        else:  # python2\n            for x, y in zip(a, b):\n                result |= ord(x) ^ ord(y)\n        return result == 0\n\n\ndef create_signed_value(secret, name, value, version=None, clock=None):\n    if version is None:\n        version = DEFAULT_SIGNED_VALUE_VERSION\n    if clock is None:\n        clock = time.time\n    timestamp = utf8(str(int(clock())))\n    value = base64.b64encode(utf8(value))\n    if version == 1:\n        signature = _create_signature_v1(secret, name, value, timestamp)\n        value = b\"|\".join([value, timestamp, signature])\n        return value\n    elif version == 2:\n        # The v2 format consists of a version number and a series of\n        # length-prefixed fields \"%d:%s\", the last of which is a\n        # signature, all separated by pipes.  All numbers are in\n        # decimal format with no leading zeros.  The signature is an\n        # HMAC-SHA256 of the whole string up to that point, including\n        # the final pipe.\n        #\n        # The fields are:\n        # - format version (i.e. 2; no length prefix)\n        # - key version (currently 0; reserved for future key rotation features)\n        # - timestamp (integer seconds since epoch)\n        # - name (not encoded; assumed to be ~alphanumeric)\n        # - value (base64-encoded)\n        # - signature (hex-encoded; no length prefix)\n        def format_field(s):\n            return utf8(\"%d:\" % len(s)) + utf8(s)\n        to_sign = b\"|\".join([\n            b\"2|1:0\",\n            format_field(timestamp),\n            format_field(name),\n            format_field(value),\n            b''])\n        signature = _create_signature_v2(secret, to_sign)\n        return to_sign + signature\n    else:\n        raise ValueError(\"Unsupported version %d\" % version)\n\n# A leading version number in decimal with no leading zeros, followed by a pipe.\n_signed_value_version_re = re.compile(br\"^([1-9][0-9]*)\\|(.*)$\")\n\ndef decode_signed_value(secret, name, value, max_age_days=31, clock=None,min_version=None):\n    if clock is None:\n        clock = time.time\n    if min_version is None:\n        min_version = DEFAULT_SIGNED_VALUE_MIN_VERSION\n    if min_version > 2:\n        raise ValueError(\"Unsupported min_version %d\" % min_version)\n    if not value:\n        return None\n\n    # Figure out what version this is.  Version 1 did not include an\n    # explicit version field and started with arbitrary base64 data,\n    # which makes this tricky.\n    value = utf8(value)\n    m = _signed_value_version_re.match(value)\n    if m is None:\n        version = 1\n    else:\n        try:\n            version = int(m.group(1))\n            if version > 999:\n                # Certain payloads from the version-less v1 format may\n                # be parsed as valid integers.  Due to base64 padding\n                # restrictions, this can only happen for numbers whose\n                # length is a multiple of 4, so we can treat all\n                # numbers up to 999 as versions, and for the rest we\n                # fall back to v1 format.\n                version = 1\n        except ValueError:\n            version = 1\n\n    if version < min_version:\n        return None\n    if version == 1:\n        return _decode_signed_value_v1(secret, name, value, max_age_days, clock)\n    elif version == 2:\n        return _decode_signed_value_v2(secret, name, value, max_age_days, clock)\n    else:\n        return None\n\ndef _decode_signed_value_v1(secret, name, value, max_age_days, clock):\n    parts = utf8(value).split(b\"|\")\n    if len(parts) != 3:\n        return None\n    signature = _create_signature_v1(secret, name, parts[0], parts[1])\n    if not _time_independent_equals(parts[2], signature):\n        gen_log.warning(\"Invalid cookie signature %r\", value)\n        return None\n    timestamp = int(parts[1])\n    if timestamp < clock() - max_age_days * 86400:\n        gen_log.warning(\"Expired cookie %r\", value)\n        return None\n    if timestamp > clock() + 31 * 86400:\n        # _cookie_signature does not hash a delimiter between the\n        # parts of the cookie, so an attacker could transfer trailing\n        # digits from the payload to the timestamp without altering the\n        # signature.  For backwards compatibility, sanity-check timestamp\n        # here instead of modifying _cookie_signature.\n        gen_log.warning(\"Cookie timestamp in future; possible tampering %r\", value)\n        return None\n    if parts[1].startswith(b\"0\"):\n        gen_log.warning(\"Tampered cookie %r\", value)\n        return None\n    try:\n        return base64.b64decode(parts[0])\n    except Exception:\n        return None\n\n\ndef _decode_signed_value_v2(secret, name, value, max_age_days, clock):\n    def _consume_field(s):\n        length, _, rest = s.partition(b':')\n        n = int(length)\n        field_value = rest[:n]\n        # In python 3, indexing bytes returns small integers; we must\n        # use a slice to get a byte string as in python 2.\n        if rest[n:n+1] != b'|':\n            raise ValueError(\"malformed v2 signed value field\")\n        rest = rest[n+1:]\n        return field_value, rest\n    rest = value[2:]  # remove version number\n    try:\n        key_version, rest = _consume_field(rest)\n        timestamp, rest = _consume_field(rest)\n        name_field, rest = _consume_field(rest)\n        value_field, rest = _consume_field(rest)\n    except ValueError:\n        return None\n    passed_sig = rest\n    signed_string = value[:-len(passed_sig)]\n    expected_sig = _create_signature_v2(secret, signed_string)\n    if not _time_independent_equals(passed_sig, expected_sig):\n        return None\n    if name_field != utf8(name):\n        return None\n    timestamp = int(timestamp)\n    if timestamp < clock() - max_age_days * 86400:\n        # The signature has expired.\n        return None\n    try:\n        return base64.b64decode(value_field)\n    except Exception:\n        return None\n\n\ndef _create_signature_v1(secret, *parts):\n    hash = hmac.new(utf8(secret), digestmod=hashlib.sha1)\n    for part in parts:\n        hash.update(utf8(part))\n    return utf8(hash.hexdigest())\n\ndef _create_signature_v2(secret, s):\n    hash = hmac.new(utf8(secret), digestmod=hashlib.sha256)\n    hash.update(utf8(s))\n    return utf8(hash.hexdigest())\n", "\"\"\"Implementation of the WebSocket protocol.\n\n`WebSockets <http://dev.w3.org/html5/websockets/>`_ allow for bidirectional\ncommunication between the browser and server.\n\n.. warning::\n\n   The WebSocket protocol was recently finalized as `RFC 6455\n   <http://tools.ietf.org/html/rfc6455>`_ and is not yet supported in\n   all browsers.  Refer to http://caniuse.com/websockets for details\n   on compatibility.  In addition, during development the protocol\n   went through several incompatible versions, and some browsers only\n   support older versions.  By default this module only supports the\n   latest version of the protocol, but optional support for an older\n   version (known as \"draft 76\" or \"hixie-76\") can be enabled by\n   overriding `WebSocketHandler.allow_draft76` (see that method's\n   documentation for caveats).\n\"\"\"\n\nfrom __future__ import absolute_import, division, print_function, with_statement\n# Author: Jacob Kristhammar, 2010\n\nimport array\nimport base64\nimport collections\nimport functools\nimport hashlib\nimport os\nimport struct\nimport time\nimport tornado.escape\nimport tornado.web\n\nfrom tornado.concurrent import TracebackFuture\nfrom tornado.escape import utf8, native_str\nfrom tornado import httpclient, httputil\nfrom tornado.ioloop import IOLoop\nfrom tornado.iostream import StreamClosedError\nfrom tornado.log import gen_log, app_log\nfrom tornado.netutil import Resolver\nfrom tornado import simple_httpclient\nfrom tornado.util import bytes_type, unicode_type\n\ntry:\n    xrange  # py2\nexcept NameError:\n    xrange = range  # py3\n\n\nclass WebSocketError(Exception):\n    pass\n\n\nclass WebSocketClosedError(WebSocketError):\n    \"\"\"Raised by operations on a closed connection.\n\n    .. versionadded:: 3.2\n    \"\"\"\n    pass\n\n\nclass WebSocketHandler(tornado.web.RequestHandler):\n    \"\"\"Subclass this class to create a basic WebSocket handler.\n\n    Override `on_message` to handle incoming messages, and use\n    `write_message` to send messages to the client. You can also\n    override `open` and `on_close` to handle opened and closed\n    connections.\n\n    See http://dev.w3.org/html5/websockets/ for details on the\n    JavaScript interface.  The protocol is specified at\n    http://tools.ietf.org/html/rfc6455.\n\n    Here is an example WebSocket handler that echos back all received messages\n    back to the client::\n\n      class EchoWebSocket(websocket.WebSocketHandler):\n          def open(self):\n              print \"WebSocket opened\"\n\n          def on_message(self, message):\n              self.write_message(u\"You said: \" + message)\n\n          def on_close(self):\n              print \"WebSocket closed\"\n\n    WebSockets are not standard HTTP connections. The \"handshake\" is\n    HTTP, but after the handshake, the protocol is\n    message-based. Consequently, most of the Tornado HTTP facilities\n    are not available in handlers of this type. The only communication\n    methods available to you are `write_message()`, `ping()`, and\n    `close()`. Likewise, your request handler class should implement\n    `open()` method rather than ``get()`` or ``post()``.\n\n    If you map the handler above to ``/websocket`` in your application, you can\n    invoke it in JavaScript with::\n\n      var ws = new WebSocket(\"ws://localhost:8888/websocket\");\n      ws.onopen = function() {\n         ws.send(\"Hello, world\");\n      };\n      ws.onmessage = function (evt) {\n         alert(evt.data);\n      };\n\n    This script pops up an alert box that says \"You said: Hello, world\".\n    \"\"\"\n    def __init__(self, application, request, **kwargs):\n        tornado.web.RequestHandler.__init__(self, application, request,\n                                            **kwargs)\n        self.stream = request.connection.stream\n        self.ws_connection = None\n\n    def _execute(self, transforms, *args, **kwargs):\n        self.open_args = args\n        self.open_kwargs = kwargs\n\n        # Websocket only supports GET method\n        if self.request.method != 'GET':\n            self.stream.write(tornado.escape.utf8(\n                \"HTTP/1.1 405 Method Not Allowed\\r\\n\\r\\n\"\n            ))\n            self.stream.close()\n            return\n\n        # Upgrade header should be present and should be equal to WebSocket\n        if self.request.headers.get(\"Upgrade\", \"\").lower() != 'websocket':\n            self.stream.write(tornado.escape.utf8(\n                \"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\"\n                \"Can \\\"Upgrade\\\" only to \\\"WebSocket\\\".\"\n            ))\n            self.stream.close()\n            return\n\n        # Connection header should be upgrade. Some proxy servers/load balancers\n        # might mess with it.\n        headers = self.request.headers\n        connection = map(lambda s: s.strip().lower(), headers.get(\"Connection\", \"\").split(\",\"))\n        if 'upgrade' not in connection:\n            self.stream.write(tornado.escape.utf8(\n                \"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\"\n                \"\\\"Connection\\\" must be \\\"Upgrade\\\".\"\n            ))\n            self.stream.close()\n            return\n\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if self.request.headers.get(\"Sec-WebSocket-Version\") in (\"7\", \"8\", \"13\"):\n            self.ws_connection = WebSocketProtocol13(self)\n            self.ws_connection.accept_connection()\n        elif (self.allow_draft76() and\n              \"Sec-WebSocket-Version\" not in self.request.headers):\n            self.ws_connection = WebSocketProtocol76(self)\n            self.ws_connection.accept_connection()\n        else:\n            self.stream.write(tornado.escape.utf8(\n                \"HTTP/1.1 426 Upgrade Required\\r\\n\"\n                \"Sec-WebSocket-Version: 8\\r\\n\\r\\n\"))\n            self.stream.close()\n\n    def write_message(self, message, binary=False):\n        \"\"\"Sends the given message to the client of this Web Socket.\n\n        The message may be either a string or a dict (which will be\n        encoded as json).  If the ``binary`` argument is false, the\n        message will be sent as utf8; in binary mode any byte string\n        is allowed.\n\n        If the connection is already closed, raises `WebSocketClosedError`.\n\n        .. versionchanged:: 3.2\n           `WebSocketClosedError` was added (previously a closed connection\n           would raise an `AttributeError`)\n        \"\"\"\n        if self.ws_connection is None:\n            raise WebSocketClosedError()\n        if isinstance(message, dict):\n            message = tornado.escape.json_encode(message)\n        self.ws_connection.write_message(message, binary=binary)\n\n    def select_subprotocol(self, subprotocols):\n        \"\"\"Invoked when a new WebSocket requests specific subprotocols.\n\n        ``subprotocols`` is a list of strings identifying the\n        subprotocols proposed by the client.  This method may be\n        overridden to return one of those strings to select it, or\n        ``None`` to not select a subprotocol.  Failure to select a\n        subprotocol does not automatically abort the connection,\n        although clients may close the connection if none of their\n        proposed subprotocols was selected.\n        \"\"\"\n        return None\n\n    def open(self):\n        \"\"\"Invoked when a new WebSocket is opened.\n\n        The arguments to `open` are extracted from the `tornado.web.URLSpec`\n        regular expression, just like the arguments to\n        `tornado.web.RequestHandler.get`.\n        \"\"\"\n        pass\n\n    def on_message(self, message):\n        \"\"\"Handle incoming messages on the WebSocket\n\n        This method must be overridden.\n        \"\"\"\n        raise NotImplementedError\n\n    def ping(self, data):\n        \"\"\"Send ping frame to the remote end.\"\"\"\n        if self.ws_connection is None:\n            raise WebSocketClosedError()\n        self.ws_connection.write_ping(data)\n\n    def on_pong(self, data):\n        \"\"\"Invoked when the response to a ping frame is received.\"\"\"\n        pass\n\n    def on_close(self):\n        \"\"\"Invoked when the WebSocket is closed.\"\"\"\n        pass\n\n    def close(self):\n        \"\"\"Closes this Web Socket.\n\n        Once the close handshake is successful the socket will be closed.\n        \"\"\"\n        if self.ws_connection:\n            self.ws_connection.close()\n            self.ws_connection = None\n\n    def allow_draft76(self):\n        \"\"\"Override to enable support for the older \"draft76\" protocol.\n\n        The draft76 version of the websocket protocol is disabled by\n        default due to security concerns, but it can be enabled by\n        overriding this method to return True.\n\n        Connections using the draft76 protocol do not support the\n        ``binary=True`` flag to `write_message`.\n\n        Support for the draft76 protocol is deprecated and will be\n        removed in a future version of Tornado.\n        \"\"\"\n        return False\n\n    def set_nodelay(self, value):\n        \"\"\"Set the no-delay flag for this stream.\n\n        By default, small messages may be delayed and/or combined to minimize\n        the number of packets sent.  This can sometimes cause 200-500ms delays\n        due to the interaction between Nagle's algorithm and TCP delayed\n        ACKs.  To reduce this delay (at the expense of possibly increasing\n        bandwidth usage), call ``self.set_nodelay(True)`` once the websocket\n        connection is established.\n\n        See `.BaseIOStream.set_nodelay` for additional details.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        self.stream.set_nodelay(value)\n\n    def get_websocket_scheme(self):\n        \"\"\"Return the url scheme used for this request, either \"ws\" or \"wss\".\n\n        This is normally decided by HTTPServer, but applications\n        may wish to override this if they are using an SSL proxy\n        that does not provide the X-Scheme header as understood\n        by HTTPServer.\n\n        Note that this is only used by the draft76 protocol.\n        \"\"\"\n        return \"wss\" if self.request.protocol == \"https\" else \"ws\"\n\n    def async_callback(self, callback, *args, **kwargs):\n        \"\"\"Obsolete - catches exceptions from the wrapped function.\n\n        This function is normally unncecessary thanks to\n        `tornado.stack_context`.\n        \"\"\"\n        return self.ws_connection.async_callback(callback, *args, **kwargs)\n\n    def _not_supported(self, *args, **kwargs):\n        raise Exception(\"Method not supported for Web Sockets\")\n\n    def on_connection_close(self):\n        if self.ws_connection:\n            self.ws_connection.on_connection_close()\n            self.ws_connection = None\n            self.on_close()\n\n\nfor method in [\"write\", \"redirect\", \"set_header\", \"send_error\", \"set_cookie\",\n               \"set_status\", \"flush\", \"finish\"]:\n    setattr(WebSocketHandler, method, WebSocketHandler._not_supported)\n\n\nclass WebSocketProtocol(object):\n    \"\"\"Base class for WebSocket protocol versions.\n    \"\"\"\n    def __init__(self, handler):\n        self.handler = handler\n        self.request = handler.request\n        self.stream = handler.stream\n        self.client_terminated = False\n        self.server_terminated = False\n\n    def async_callback(self, callback, *args, **kwargs):\n        \"\"\"Wrap callbacks with this if they are used on asynchronous requests.\n\n        Catches exceptions properly and closes this WebSocket if an exception\n        is uncaught.\n        \"\"\"\n        if args or kwargs:\n            callback = functools.partial(callback, *args, **kwargs)\n\n        def wrapper(*args, **kwargs):\n            try:\n                return callback(*args, **kwargs)\n            except Exception:\n                app_log.error(\"Uncaught exception in %s\",\n                              self.request.path, exc_info=True)\n                self._abort()\n        return wrapper\n\n    def on_connection_close(self):\n        self._abort()\n\n    def _abort(self):\n        \"\"\"Instantly aborts the WebSocket connection by closing the socket\"\"\"\n        self.client_terminated = True\n        self.server_terminated = True\n        self.stream.close()  # forcibly tear down the connection\n        self.close()  # let the subclass cleanup\n\n\nclass WebSocketProtocol76(WebSocketProtocol):\n    \"\"\"Implementation of the WebSockets protocol, version hixie-76.\n\n    This class provides basic functionality to process WebSockets requests as\n    specified in\n    http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-76\n    \"\"\"\n    def __init__(self, handler):\n        WebSocketProtocol.__init__(self, handler)\n        self.challenge = None\n        self._waiting = None\n\n    def accept_connection(self):\n        try:\n            self._handle_websocket_headers()\n        except ValueError:\n            gen_log.debug(\"Malformed WebSocket request received\")\n            self._abort()\n            return\n\n        scheme = self.handler.get_websocket_scheme()\n\n        # draft76 only allows a single subprotocol\n        subprotocol_header = ''\n        subprotocol = self.request.headers.get(\"Sec-WebSocket-Protocol\", None)\n        if subprotocol:\n            selected = self.handler.select_subprotocol([subprotocol])\n            if selected:\n                assert selected == subprotocol\n                subprotocol_header = \"Sec-WebSocket-Protocol: %s\\r\\n\" % selected\n\n        # Write the initial headers before attempting to read the challenge.\n        # This is necessary when using proxies (such as HAProxy), which\n        # need to see the Upgrade headers before passing through the\n        # non-HTTP traffic that follows.\n        self.stream.write(tornado.escape.utf8(\n            \"HTTP/1.1 101 WebSocket Protocol Handshake\\r\\n\"\n            \"Upgrade: WebSocket\\r\\n\"\n            \"Connection: Upgrade\\r\\n\"\n            \"Server: TornadoServer/%(version)s\\r\\n\"\n            \"Sec-WebSocket-Origin: %(origin)s\\r\\n\"\n            \"Sec-WebSocket-Location: %(scheme)s://%(host)s%(uri)s\\r\\n\"\n            \"%(subprotocol)s\"\n            \"\\r\\n\" % (dict(\n                version=tornado.version,\n                origin=self.request.headers[\"Origin\"],\n                scheme=scheme,\n                host=self.request.host,\n                uri=self.request.uri,\n                subprotocol=subprotocol_header))))\n        self.stream.read_bytes(8, self._handle_challenge)\n\n    def challenge_response(self, challenge):\n        \"\"\"Generates the challenge response that's needed in the handshake\n\n        The challenge parameter should be the raw bytes as sent from the\n        client.\n        \"\"\"\n        key_1 = self.request.headers.get(\"Sec-Websocket-Key1\")\n        key_2 = self.request.headers.get(\"Sec-Websocket-Key2\")\n        try:\n            part_1 = self._calculate_part(key_1)\n            part_2 = self._calculate_part(key_2)\n        except ValueError:\n            raise ValueError(\"Invalid Keys/Challenge\")\n        return self._generate_challenge_response(part_1, part_2, challenge)\n\n    def _handle_challenge(self, challenge):\n        try:\n            challenge_response = self.challenge_response(challenge)\n        except ValueError:\n            gen_log.debug(\"Malformed key data in WebSocket request\")\n            self._abort()\n            return\n        self._write_response(challenge_response)\n\n    def _write_response(self, challenge):\n        self.stream.write(challenge)\n        self.async_callback(self.handler.open)(*self.handler.open_args, **self.handler.open_kwargs)\n        self._receive_message()\n\n    def _handle_websocket_headers(self):\n        \"\"\"Verifies all invariant- and required headers\n\n        If a header is missing or have an incorrect value ValueError will be\n        raised\n        \"\"\"\n        fields = (\"Origin\", \"Host\", \"Sec-Websocket-Key1\",\n                  \"Sec-Websocket-Key2\")\n        if not all(map(lambda f: self.request.headers.get(f), fields)):\n            raise ValueError(\"Missing/Invalid WebSocket headers\")\n\n    def _calculate_part(self, key):\n        \"\"\"Processes the key headers and calculates their key value.\n\n        Raises ValueError when feed invalid key.\"\"\"\n        # pyflakes complains about variable reuse if both of these lines use 'c'\n        number = int(''.join(c for c in key if c.isdigit()))\n        spaces = len([c2 for c2 in key if c2.isspace()])\n        try:\n            key_number = number // spaces\n        except (ValueError, ZeroDivisionError):\n            raise ValueError\n        return struct.pack(\">I\", key_number)\n\n    def _generate_challenge_response(self, part_1, part_2, part_3):\n        m = hashlib.md5()\n        m.update(part_1)\n        m.update(part_2)\n        m.update(part_3)\n        return m.digest()\n\n    def _receive_message(self):\n        self.stream.read_bytes(1, self._on_frame_type)\n\n    def _on_frame_type(self, byte):\n        frame_type = ord(byte)\n        if frame_type == 0x00:\n            self.stream.read_until(b\"\\xff\", self._on_end_delimiter)\n        elif frame_type == 0xff:\n            self.stream.read_bytes(1, self._on_length_indicator)\n        else:\n            self._abort()\n\n    def _on_end_delimiter(self, frame):\n        if not self.client_terminated:\n            self.async_callback(self.handler.on_message)(\n                frame[:-1].decode(\"utf-8\", \"replace\"))\n        if not self.client_terminated:\n            self._receive_message()\n\n    def _on_length_indicator(self, byte):\n        if ord(byte) != 0x00:\n            self._abort()\n            return\n        self.client_terminated = True\n        self.close()\n\n    def write_message(self, message, binary=False):\n        \"\"\"Sends the given message to the client of this Web Socket.\"\"\"\n        if binary:\n            raise ValueError(\n                \"Binary messages not supported by this version of websockets\")\n        if isinstance(message, unicode_type):\n            message = message.encode(\"utf-8\")\n        assert isinstance(message, bytes_type)\n        self.stream.write(b\"\\x00\" + message + b\"\\xff\")\n\n    def write_ping(self, data):\n        \"\"\"Send ping frame.\"\"\"\n        raise ValueError(\"Ping messages not supported by this version of websockets\")\n\n    def close(self):\n        \"\"\"Closes the WebSocket connection.\"\"\"\n        if not self.server_terminated:\n            if not self.stream.closed():\n                self.stream.write(\"\\xff\\x00\")\n            self.server_terminated = True\n        if self.client_terminated:\n            if self._waiting is not None:\n                self.stream.io_loop.remove_timeout(self._waiting)\n            self._waiting = None\n            self.stream.close()\n        elif self._waiting is None:\n            self._waiting = self.stream.io_loop.add_timeout(\n                time.time() + 5, self._abort)\n\n\nclass WebSocketProtocol13(WebSocketProtocol):\n    \"\"\"Implementation of the WebSocket protocol from RFC 6455.\n\n    This class supports versions 7 and 8 of the protocol in addition to the\n    final version 13.\n    \"\"\"\n    def __init__(self, handler, mask_outgoing=False):\n        WebSocketProtocol.__init__(self, handler)\n        self.mask_outgoing = mask_outgoing\n        self._final_frame = False\n        self._frame_opcode = None\n        self._masked_frame = None\n        self._frame_mask = None\n        self._frame_length = None\n        self._fragmented_message_buffer = None\n        self._fragmented_message_opcode = None\n        self._waiting = None\n\n    def accept_connection(self):\n        try:\n            self._handle_websocket_headers()\n            self._accept_connection()\n        except ValueError:\n            gen_log.debug(\"Malformed WebSocket request received\", exc_info=True)\n            self._abort()\n            return\n\n    def _handle_websocket_headers(self):\n        \"\"\"Verifies all invariant- and required headers\n\n        If a header is missing or have an incorrect value ValueError will be\n        raised\n        \"\"\"\n        fields = (\"Host\", \"Sec-Websocket-Key\", \"Sec-Websocket-Version\")\n        if not all(map(lambda f: self.request.headers.get(f), fields)):\n            raise ValueError(\"Missing/Invalid WebSocket headers\")\n\n    @staticmethod\n    def compute_accept_value(key):\n        \"\"\"Computes the value for the Sec-WebSocket-Accept header,\n        given the value for Sec-WebSocket-Key.\n        \"\"\"\n        sha1 = hashlib.sha1()\n        sha1.update(utf8(key))\n        sha1.update(b\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\")  # Magic value\n        return native_str(base64.b64encode(sha1.digest()))\n\n    def _challenge_response(self):\n        return WebSocketProtocol13.compute_accept_value(\n            self.request.headers.get(\"Sec-Websocket-Key\"))\n\n    def _accept_connection(self):\n        subprotocol_header = ''\n        subprotocols = self.request.headers.get(\"Sec-WebSocket-Protocol\", '')\n        subprotocols = [s.strip() for s in subprotocols.split(',')]\n        if subprotocols:\n            selected = self.handler.select_subprotocol(subprotocols)\n            if selected:\n                assert selected in subprotocols\n                subprotocol_header = \"Sec-WebSocket-Protocol: %s\\r\\n\" % selected\n\n        self.stream.write(tornado.escape.utf8(\n            \"HTTP/1.1 101 Switching Protocols\\r\\n\"\n            \"Upgrade: websocket\\r\\n\"\n            \"Connection: Upgrade\\r\\n\"\n            \"Sec-WebSocket-Accept: %s\\r\\n\"\n            \"%s\"\n            \"\\r\\n\" % (self._challenge_response(), subprotocol_header)))\n\n        self.async_callback(self.handler.open)(*self.handler.open_args, **self.handler.open_kwargs)\n        self._receive_frame()\n\n    def _write_frame(self, fin, opcode, data):\n        if fin:\n            finbit = 0x80\n        else:\n            finbit = 0\n        frame = struct.pack(\"B\", finbit | opcode)\n        l = len(data)\n        if self.mask_outgoing:\n            mask_bit = 0x80\n        else:\n            mask_bit = 0\n        if l < 126:\n            frame += struct.pack(\"B\", l | mask_bit)\n        elif l <= 0xFFFF:\n            frame += struct.pack(\"!BH\", 126 | mask_bit, l)\n        else:\n            frame += struct.pack(\"!BQ\", 127 | mask_bit, l)\n        if self.mask_outgoing:\n            mask = os.urandom(4)\n            data = mask + _websocket_mask(mask, data)\n        frame += data\n        self.stream.write(frame)\n\n    def write_message(self, message, binary=False):\n        \"\"\"Sends the given message to the client of this Web Socket.\"\"\"\n        if binary:\n            opcode = 0x2\n        else:\n            opcode = 0x1\n        message = tornado.escape.utf8(message)\n        assert isinstance(message, bytes_type)\n        try:\n            self._write_frame(True, opcode, message)\n        except StreamClosedError:\n            self._abort()\n\n    def write_ping(self, data):\n        \"\"\"Send ping frame.\"\"\"\n        assert isinstance(data, bytes_type)\n        self._write_frame(True, 0x9, data)\n\n    def _receive_frame(self):\n        try:\n            self.stream.read_bytes(2, self._on_frame_start)\n        except StreamClosedError:\n            self._abort()\n\n    def _on_frame_start(self, data):\n        header, payloadlen = struct.unpack(\"BB\", data)\n        self._final_frame = header & 0x80\n        reserved_bits = header & 0x70\n        self._frame_opcode = header & 0xf\n        self._frame_opcode_is_control = self._frame_opcode & 0x8\n        if reserved_bits:\n            # client is using as-yet-undefined extensions; abort\n            self._abort()\n            return\n        self._masked_frame = bool(payloadlen & 0x80)\n        payloadlen = payloadlen & 0x7f\n        if self._frame_opcode_is_control and payloadlen >= 126:\n            # control frames must have payload < 126\n            self._abort()\n            return\n        try:\n            if payloadlen < 126:\n                self._frame_length = payloadlen\n                if self._masked_frame:\n                    self.stream.read_bytes(4, self._on_masking_key)\n                else:\n                    self.stream.read_bytes(self._frame_length, self._on_frame_data)\n            elif payloadlen == 126:\n                self.stream.read_bytes(2, self._on_frame_length_16)\n            elif payloadlen == 127:\n                self.stream.read_bytes(8, self._on_frame_length_64)\n        except StreamClosedError:\n            self._abort()\n\n    def _on_frame_length_16(self, data):\n        self._frame_length = struct.unpack(\"!H\", data)[0]\n        try:\n            if self._masked_frame:\n                self.stream.read_bytes(4, self._on_masking_key)\n            else:\n                self.stream.read_bytes(self._frame_length, self._on_frame_data)\n        except StreamClosedError:\n            self._abort()\n\n    def _on_frame_length_64(self, data):\n        self._frame_length = struct.unpack(\"!Q\", data)[0]\n        try:\n            if self._masked_frame:\n                self.stream.read_bytes(4, self._on_masking_key)\n            else:\n                self.stream.read_bytes(self._frame_length, self._on_frame_data)\n        except StreamClosedError:\n            self._abort()\n\n    def _on_masking_key(self, data):\n        self._frame_mask = data\n        try:\n            self.stream.read_bytes(self._frame_length, self._on_masked_frame_data)\n        except StreamClosedError:\n            self._abort()\n\n    def _on_masked_frame_data(self, data):\n        self._on_frame_data(_websocket_mask(self._frame_mask, data))\n\n    def _on_frame_data(self, data):\n        if self._frame_opcode_is_control:\n            # control frames may be interleaved with a series of fragmented\n            # data frames, so control frames must not interact with\n            # self._fragmented_*\n            if not self._final_frame:\n                # control frames must not be fragmented\n                self._abort()\n                return\n            opcode = self._frame_opcode\n        elif self._frame_opcode == 0:  # continuation frame\n            if self._fragmented_message_buffer is None:\n                # nothing to continue\n                self._abort()\n                return\n            self._fragmented_message_buffer += data\n            if self._final_frame:\n                opcode = self._fragmented_message_opcode\n                data = self._fragmented_message_buffer\n                self._fragmented_message_buffer = None\n        else:  # start of new data message\n            if self._fragmented_message_buffer is not None:\n                # can't start new message until the old one is finished\n                self._abort()\n                return\n            if self._final_frame:\n                opcode = self._frame_opcode\n            else:\n                self._fragmented_message_opcode = self._frame_opcode\n                self._fragmented_message_buffer = data\n\n        if self._final_frame:\n            self._handle_message(opcode, data)\n\n        if not self.client_terminated:\n            self._receive_frame()\n\n    def _handle_message(self, opcode, data):\n        if self.client_terminated:\n            return\n\n        if opcode == 0x1:\n            # UTF-8 data\n            try:\n                decoded = data.decode(\"utf-8\")\n            except UnicodeDecodeError:\n                self._abort()\n                return\n            self.async_callback(self.handler.on_message)(decoded)\n        elif opcode == 0x2:\n            # Binary data\n            self.async_callback(self.handler.on_message)(data)\n        elif opcode == 0x8:\n            # Close\n            self.client_terminated = True\n            self.close()\n        elif opcode == 0x9:\n            # Ping\n            self._write_frame(True, 0xA, data)\n        elif opcode == 0xA:\n            # Pong\n            self.async_callback(self.handler.on_pong)(data)\n        else:\n            self._abort()\n\n    def close(self):\n        \"\"\"Closes the WebSocket connection.\"\"\"\n        if not self.server_terminated:\n            if not self.stream.closed():\n                self._write_frame(True, 0x8, b\"\")\n            self.server_terminated = True\n        if self.client_terminated:\n            if self._waiting is not None:\n                self.stream.io_loop.remove_timeout(self._waiting)\n                self._waiting = None\n            self.stream.close()\n        elif self._waiting is None:\n            # Give the client a few seconds to complete a clean shutdown,\n            # otherwise just close the connection.\n            self._waiting = self.stream.io_loop.add_timeout(\n                self.stream.io_loop.time() + 5, self._abort)\n\n\nclass WebSocketClientConnection(simple_httpclient._HTTPConnection):\n    \"\"\"WebSocket client connection.\n\n    This class should not be instantiated directly; use the\n    `websocket_connect` function instead.\n    \"\"\"\n    def __init__(self, io_loop, request):\n        self.connect_future = TracebackFuture()\n        self.read_future = None\n        self.read_queue = collections.deque()\n        self.key = base64.b64encode(os.urandom(16))\n\n        scheme, sep, rest = request.url.partition(':')\n        scheme = {'ws': 'http', 'wss': 'https'}[scheme]\n        request.url = scheme + sep + rest\n        request.headers.update({\n            'Upgrade': 'websocket',\n            'Connection': 'Upgrade',\n            'Sec-WebSocket-Key': self.key,\n            'Sec-WebSocket-Version': '13',\n        })\n\n        self.resolver = Resolver(io_loop=io_loop)\n        super(WebSocketClientConnection, self).__init__(\n            io_loop, None, request, lambda: None, self._on_http_response,\n            104857600, self.resolver)\n\n    def close(self):\n        \"\"\"Closes the websocket connection.\n\n        .. versionadded:: 3.2\n        \"\"\"\n        if self.protocol is not None:\n            self.protocol.close()\n            self.protocol = None\n\n    def _on_close(self):\n        self.on_message(None)\n        self.resolver.close()\n        super(WebSocketClientConnection, self)._on_close()\n\n    def _on_http_response(self, response):\n        if not self.connect_future.done():\n            if response.error:\n                self.connect_future.set_exception(response.error)\n            else:\n                self.connect_future.set_exception(WebSocketError(\n                    \"Non-websocket response\"))\n\n    def _handle_1xx(self, code):\n        assert code == 101\n        assert self.headers['Upgrade'].lower() == 'websocket'\n        assert self.headers['Connection'].lower() == 'upgrade'\n        accept = WebSocketProtocol13.compute_accept_value(self.key)\n        assert self.headers['Sec-Websocket-Accept'] == accept\n\n        self.protocol = WebSocketProtocol13(self, mask_outgoing=True)\n        self.protocol._receive_frame()\n\n        if self._timeout is not None:\n            self.io_loop.remove_timeout(self._timeout)\n            self._timeout = None\n\n        self.connect_future.set_result(self)\n\n    def write_message(self, message, binary=False):\n        \"\"\"Sends a message to the WebSocket server.\"\"\"\n        self.protocol.write_message(message, binary)\n\n    def read_message(self, callback=None):\n        \"\"\"Reads a message from the WebSocket server.\n\n        Returns a future whose result is the message, or None\n        if the connection is closed.  If a callback argument\n        is given it will be called with the future when it is\n        ready.\n        \"\"\"\n        assert self.read_future is None\n        future = TracebackFuture()\n        if self.read_queue:\n            future.set_result(self.read_queue.popleft())\n        else:\n            self.read_future = future\n        if callback is not None:\n            self.io_loop.add_future(future, callback)\n        return future\n\n    def on_message(self, message):\n        if self.read_future is not None:\n            self.read_future.set_result(message)\n            self.read_future = None\n        else:\n            self.read_queue.append(message)\n\n    def on_pong(self, data):\n        pass\n\n\ndef websocket_connect(url, io_loop=None, callback=None, connect_timeout=None):\n    \"\"\"Client-side websocket support.\n\n    Takes a url and returns a Future whose result is a\n    `WebSocketClientConnection`.\n\n    .. versionchanged:: 3.2\n       Also accepts ``HTTPRequest`` objects in place of urls.\n    \"\"\"\n    if io_loop is None:\n        io_loop = IOLoop.current()\n    if isinstance(url, httpclient.HTTPRequest):\n        assert connect_timeout is None\n        request = url\n        # Copy and convert the headers dict/object (see comments in\n        # AsyncHTTPClient.fetch)\n        request.headers = httputil.HTTPHeaders(request.headers)\n    else:\n        request = httpclient.HTTPRequest(url, connect_timeout=connect_timeout)\n    request = httpclient._RequestProxy(\n        request, httpclient.HTTPRequest._DEFAULTS)\n    conn = WebSocketClientConnection(io_loop, request)\n    if callback is not None:\n        io_loop.add_future(conn.connect_future, callback)\n    return conn.connect_future\n\n\ndef _websocket_mask_python(mask, data):\n    \"\"\"Websocket masking function.\n\n    `mask` is a `bytes` object of length 4; `data` is a `bytes` object of any length.\n    Returns a `bytes` object of the same length as `data` with the mask applied\n    as specified in section 5.3 of RFC 6455.\n\n    This pure-python implementation may be replaced by an optimized version when available.\n    \"\"\"\n    mask = array.array(\"B\", mask)\n    unmasked = array.array(\"B\", data)\n    for i in xrange(len(data)):\n        unmasked[i] = unmasked[i] ^ mask[i % 4]\n    if hasattr(unmasked, 'tobytes'):\n        # tostring was deprecated in py32.  It hasn't been removed,\n        # but since we turn on deprecation warnings in our tests\n        # we need to use the right one.\n        return unmasked.tobytes()\n    else:\n        return unmasked.tostring()\n\nif (os.environ.get('TORNADO_NO_EXTENSION') or\n    os.environ.get('TORNADO_EXTENSION') == '0'):\n    # These environment variables exist to make it easier to do performance\n    # comparisons; they are not guaranteed to remain supported in the future.\n    _websocket_mask = _websocket_mask_python\nelse:\n    try:\n        from tornado.speedups import websocket_mask as _websocket_mask\n    except ImportError:\n        if os.environ.get('TORNADO_EXTENSION') == '1':\n            raise\n        _websocket_mask = _websocket_mask_python\n"], "fixing_code": ["from __future__ import absolute_import, division, print_function, with_statement\nfrom tornado import gen\nfrom tornado.escape import json_decode, utf8, to_unicode, recursive_unicode, native_str, to_basestring\nfrom tornado.httputil import format_timestamp\nfrom tornado.iostream import IOStream\nfrom tornado.log import app_log, gen_log\nfrom tornado.simple_httpclient import SimpleAsyncHTTPClient\nfrom tornado.template import DictLoader\nfrom tornado.testing import AsyncHTTPTestCase, ExpectLog\nfrom tornado.test.util import unittest\nfrom tornado.util import u, bytes_type, ObjectDict, unicode_type\nfrom tornado.web import RequestHandler, authenticated, Application, asynchronous, url, HTTPError, StaticFileHandler, _create_signature_v1, create_signed_value, decode_signed_value, ErrorHandler, UIModule, MissingArgumentError\n\nimport binascii\nimport datetime\nimport email.utils\nimport logging\nimport os\nimport re\nimport socket\nimport sys\n\ntry:\n    import urllib.parse as urllib_parse  # py3\nexcept ImportError:\n    import urllib as urllib_parse  # py2\n\nwsgi_safe_tests = []\n\nrelpath = lambda *a: os.path.join(os.path.dirname(__file__), *a)\n\n\ndef wsgi_safe(cls):\n    wsgi_safe_tests.append(cls)\n    return cls\n\n\nclass WebTestCase(AsyncHTTPTestCase):\n    \"\"\"Base class for web tests that also supports WSGI mode.\n\n    Override get_handlers and get_app_kwargs instead of get_app.\n    Append to wsgi_safe to have it run in wsgi_test as well.\n    \"\"\"\n    def get_app(self):\n        self.app = Application(self.get_handlers(), **self.get_app_kwargs())\n        return self.app\n\n    def get_handlers(self):\n        raise NotImplementedError()\n\n    def get_app_kwargs(self):\n        return {}\n\n\nclass SimpleHandlerTestCase(WebTestCase):\n    \"\"\"Simplified base class for tests that work with a single handler class.\n\n    To use, define a nested class named ``Handler``.\n    \"\"\"\n    def get_handlers(self):\n        return [('/', self.Handler)]\n\n\nclass HelloHandler(RequestHandler):\n    def get(self):\n        self.write('hello')\n\n\nclass CookieTestRequestHandler(RequestHandler):\n    # stub out enough methods to make the secure_cookie functions work\n    def __init__(self):\n        # don't call super.__init__\n        self._cookies = {}\n        self.application = ObjectDict(settings=dict(cookie_secret='0123456789'))\n\n    def get_cookie(self, name):\n        return self._cookies.get(name)\n\n    def set_cookie(self, name, value, expires_days=None):\n        self._cookies[name] = value\n\n\n# See SignedValueTest below for more.\nclass SecureCookieV1Test(unittest.TestCase):\n    def test_round_trip(self):\n        handler = CookieTestRequestHandler()\n        handler.set_secure_cookie('foo', b'bar', version=1)\n        self.assertEqual(handler.get_secure_cookie('foo', min_version=1),\n                         b'bar')\n\n    def test_cookie_tampering_future_timestamp(self):\n        handler = CookieTestRequestHandler()\n        # this string base64-encodes to '12345678'\n        handler.set_secure_cookie('foo', binascii.a2b_hex(b'd76df8e7aefc'),\n                                  version=1)\n        cookie = handler._cookies['foo']\n        match = re.match(br'12345678\\|([0-9]+)\\|([0-9a-f]+)', cookie)\n        self.assertTrue(match)\n        timestamp = match.group(1)\n        sig = match.group(2)\n        self.assertEqual(\n            _create_signature_v1(handler.application.settings[\"cookie_secret\"],\n                              'foo', '12345678', timestamp),\n            sig)\n        # shifting digits from payload to timestamp doesn't alter signature\n        # (this is not desirable behavior, just confirming that that's how it\n        # works)\n        self.assertEqual(\n            _create_signature_v1(handler.application.settings[\"cookie_secret\"],\n                              'foo', '1234', b'5678' + timestamp),\n            sig)\n        # tamper with the cookie\n        handler._cookies['foo'] = utf8('1234|5678%s|%s' % (\n            to_basestring(timestamp), to_basestring(sig)))\n        # it gets rejected\n        with ExpectLog(gen_log, \"Cookie timestamp in future\"):\n            self.assertTrue(\n                handler.get_secure_cookie('foo', min_version=1) is None)\n\n    def test_arbitrary_bytes(self):\n        # Secure cookies accept arbitrary data (which is base64 encoded).\n        # Note that normal cookies accept only a subset of ascii.\n        handler = CookieTestRequestHandler()\n        handler.set_secure_cookie('foo', b'\\xe9', version=1)\n        self.assertEqual(handler.get_secure_cookie('foo', min_version=1), b'\\xe9')\n\n\nclass CookieTest(WebTestCase):\n    def get_handlers(self):\n        class SetCookieHandler(RequestHandler):\n            def get(self):\n                # Try setting cookies with different argument types\n                # to ensure that everything gets encoded correctly\n                self.set_cookie(\"str\", \"asdf\")\n                self.set_cookie(\"unicode\", u(\"qwer\"))\n                self.set_cookie(\"bytes\", b\"zxcv\")\n\n        class GetCookieHandler(RequestHandler):\n            def get(self):\n                self.write(self.get_cookie(\"foo\", \"default\"))\n\n        class SetCookieDomainHandler(RequestHandler):\n            def get(self):\n                # unicode domain and path arguments shouldn't break things\n                # either (see bug #285)\n                self.set_cookie(\"unicode_args\", \"blah\", domain=u(\"foo.com\"),\n                                path=u(\"/foo\"))\n\n        class SetCookieSpecialCharHandler(RequestHandler):\n            def get(self):\n                self.set_cookie(\"equals\", \"a=b\")\n                self.set_cookie(\"semicolon\", \"a;b\")\n                self.set_cookie(\"quote\", 'a\"b')\n\n        class SetCookieOverwriteHandler(RequestHandler):\n            def get(self):\n                self.set_cookie(\"a\", \"b\", domain=\"example.com\")\n                self.set_cookie(\"c\", \"d\", domain=\"example.com\")\n                # A second call with the same name clobbers the first.\n                # Attributes from the first call are not carried over.\n                self.set_cookie(\"a\", \"e\")\n\n        return [(\"/set\", SetCookieHandler),\n                (\"/get\", GetCookieHandler),\n                (\"/set_domain\", SetCookieDomainHandler),\n                (\"/special_char\", SetCookieSpecialCharHandler),\n                (\"/set_overwrite\", SetCookieOverwriteHandler),\n                ]\n\n    def test_set_cookie(self):\n        response = self.fetch(\"/set\")\n        self.assertEqual(sorted(response.headers.get_list(\"Set-Cookie\")),\n                         [\"bytes=zxcv; Path=/\",\n                          \"str=asdf; Path=/\",\n                          \"unicode=qwer; Path=/\",\n                          ])\n\n    def test_get_cookie(self):\n        response = self.fetch(\"/get\", headers={\"Cookie\": \"foo=bar\"})\n        self.assertEqual(response.body, b\"bar\")\n\n        response = self.fetch(\"/get\", headers={\"Cookie\": 'foo=\"bar\"'})\n        self.assertEqual(response.body, b\"bar\")\n\n        response = self.fetch(\"/get\", headers={\"Cookie\": \"/=exception;\"})\n        self.assertEqual(response.body, b\"default\")\n\n    def test_set_cookie_domain(self):\n        response = self.fetch(\"/set_domain\")\n        self.assertEqual(response.headers.get_list(\"Set-Cookie\"),\n                         [\"unicode_args=blah; Domain=foo.com; Path=/foo\"])\n\n    def test_cookie_special_char(self):\n        response = self.fetch(\"/special_char\")\n        headers = sorted(response.headers.get_list(\"Set-Cookie\"))\n        self.assertEqual(len(headers), 3)\n        self.assertEqual(headers[0], 'equals=\"a=b\"; Path=/')\n        self.assertEqual(headers[1], 'quote=\"a\\\\\"b\"; Path=/')\n        # python 2.7 octal-escapes the semicolon; older versions leave it alone\n        self.assertTrue(headers[2] in ('semicolon=\"a;b\"; Path=/',\n                                       'semicolon=\"a\\\\073b\"; Path=/'),\n                        headers[2])\n\n        data = [('foo=a=b', 'a=b'),\n                ('foo=\"a=b\"', 'a=b'),\n                ('foo=\"a;b\"', 'a;b'),\n                # ('foo=a\\\\073b', 'a;b'),  # even encoded, \";\" is a delimiter\n                ('foo=\"a\\\\073b\"', 'a;b'),\n                ('foo=\"a\\\\\"b\"', 'a\"b'),\n                ]\n        for header, expected in data:\n            logging.debug(\"trying %r\", header)\n            response = self.fetch(\"/get\", headers={\"Cookie\": header})\n            self.assertEqual(response.body, utf8(expected))\n\n    def test_set_cookie_overwrite(self):\n        response = self.fetch(\"/set_overwrite\")\n        headers = response.headers.get_list(\"Set-Cookie\")\n        self.assertEqual(sorted(headers),\n                         [\"a=e; Path=/\", \"c=d; Domain=example.com; Path=/\"])\n\n\nclass AuthRedirectRequestHandler(RequestHandler):\n    def initialize(self, login_url):\n        self.login_url = login_url\n\n    def get_login_url(self):\n        return self.login_url\n\n    @authenticated\n    def get(self):\n        # we'll never actually get here because the test doesn't follow redirects\n        self.send_error(500)\n\n\nclass AuthRedirectTest(WebTestCase):\n    def get_handlers(self):\n        return [('/relative', AuthRedirectRequestHandler,\n                 dict(login_url='/login')),\n                ('/absolute', AuthRedirectRequestHandler,\n                 dict(login_url='http://example.com/login'))]\n\n    def test_relative_auth_redirect(self):\n        self.http_client.fetch(self.get_url('/relative'), self.stop,\n                               follow_redirects=False)\n        response = self.wait()\n        self.assertEqual(response.code, 302)\n        self.assertEqual(response.headers['Location'], '/login?next=%2Frelative')\n\n    def test_absolute_auth_redirect(self):\n        self.http_client.fetch(self.get_url('/absolute'), self.stop,\n                               follow_redirects=False)\n        response = self.wait()\n        self.assertEqual(response.code, 302)\n        self.assertTrue(re.match(\n            'http://example.com/login\\?next=http%3A%2F%2Flocalhost%3A[0-9]+%2Fabsolute',\n            response.headers['Location']), response.headers['Location'])\n\n\nclass ConnectionCloseHandler(RequestHandler):\n    def initialize(self, test):\n        self.test = test\n\n    @asynchronous\n    def get(self):\n        self.test.on_handler_waiting()\n\n    def on_connection_close(self):\n        self.test.on_connection_close()\n\n\nclass ConnectionCloseTest(WebTestCase):\n    def get_handlers(self):\n        return [('/', ConnectionCloseHandler, dict(test=self))]\n\n    def test_connection_close(self):\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)\n        s.connect((\"localhost\", self.get_http_port()))\n        self.stream = IOStream(s, io_loop=self.io_loop)\n        self.stream.write(b\"GET / HTTP/1.0\\r\\n\\r\\n\")\n        self.wait()\n\n    def on_handler_waiting(self):\n        logging.debug('handler waiting')\n        self.stream.close()\n\n    def on_connection_close(self):\n        logging.debug('connection closed')\n        self.stop()\n\n\nclass EchoHandler(RequestHandler):\n    def get(self, *path_args):\n        # Type checks: web.py interfaces convert argument values to\n        # unicode strings (by default, but see also decode_argument).\n        # In httpserver.py (i.e. self.request.arguments), they're left\n        # as bytes.  Keys are always native strings.\n        for key in self.request.arguments:\n            if type(key) != str:\n                raise Exception(\"incorrect type for key: %r\" % type(key))\n            for value in self.request.arguments[key]:\n                if type(value) != bytes_type:\n                    raise Exception(\"incorrect type for value: %r\" %\n                                    type(value))\n            for value in self.get_arguments(key):\n                if type(value) != unicode_type:\n                    raise Exception(\"incorrect type for value: %r\" %\n                                    type(value))\n        for arg in path_args:\n            if type(arg) != unicode_type:\n                raise Exception(\"incorrect type for path arg: %r\" % type(arg))\n        self.write(dict(path=self.request.path,\n                        path_args=path_args,\n                        args=recursive_unicode(self.request.arguments)))\n\n\nclass RequestEncodingTest(WebTestCase):\n    def get_handlers(self):\n        return [(\"/group/(.*)\", EchoHandler),\n                (\"/slashes/([^/]*)/([^/]*)\", EchoHandler),\n                ]\n\n    def fetch_json(self, path):\n        return json_decode(self.fetch(path).body)\n\n    def test_group_question_mark(self):\n        # Ensure that url-encoded question marks are handled properly\n        self.assertEqual(self.fetch_json('/group/%3F'),\n                         dict(path='/group/%3F', path_args=['?'], args={}))\n        self.assertEqual(self.fetch_json('/group/%3F?%3F=%3F'),\n                         dict(path='/group/%3F', path_args=['?'], args={'?': ['?']}))\n\n    def test_group_encoding(self):\n        # Path components and query arguments should be decoded the same way\n        self.assertEqual(self.fetch_json('/group/%C3%A9?arg=%C3%A9'),\n                         {u(\"path\"): u(\"/group/%C3%A9\"),\n                          u(\"path_args\"): [u(\"\\u00e9\")],\n                          u(\"args\"): {u(\"arg\"): [u(\"\\u00e9\")]}})\n\n    def test_slashes(self):\n        # Slashes may be escaped to appear as a single \"directory\" in the path,\n        # but they are then unescaped when passed to the get() method.\n        self.assertEqual(self.fetch_json('/slashes/foo/bar'),\n                         dict(path=\"/slashes/foo/bar\",\n                              path_args=[\"foo\", \"bar\"],\n                              args={}))\n        self.assertEqual(self.fetch_json('/slashes/a%2Fb/c%2Fd'),\n                         dict(path=\"/slashes/a%2Fb/c%2Fd\",\n                              path_args=[\"a/b\", \"c/d\"],\n                              args={}))\n\n\nclass TypeCheckHandler(RequestHandler):\n    def prepare(self):\n        self.errors = {}\n\n        self.check_type('status', self.get_status(), int)\n\n        # get_argument is an exception from the general rule of using\n        # type str for non-body data mainly for historical reasons.\n        self.check_type('argument', self.get_argument('foo'), unicode_type)\n        self.check_type('cookie_key', list(self.cookies.keys())[0], str)\n        self.check_type('cookie_value', list(self.cookies.values())[0].value, str)\n\n        # Secure cookies return bytes because they can contain arbitrary\n        # data, but regular cookies are native strings.\n        if list(self.cookies.keys()) != ['asdf']:\n            raise Exception(\"unexpected values for cookie keys: %r\" %\n                            self.cookies.keys())\n        self.check_type('get_secure_cookie', self.get_secure_cookie('asdf'), bytes_type)\n        self.check_type('get_cookie', self.get_cookie('asdf'), str)\n\n        self.check_type('xsrf_token', self.xsrf_token, bytes_type)\n        self.check_type('xsrf_form_html', self.xsrf_form_html(), str)\n\n        self.check_type('reverse_url', self.reverse_url('typecheck', 'foo'), str)\n\n        self.check_type('request_summary', self._request_summary(), str)\n\n    def get(self, path_component):\n        # path_component uses type unicode instead of str for consistency\n        # with get_argument()\n        self.check_type('path_component', path_component, unicode_type)\n        self.write(self.errors)\n\n    def post(self, path_component):\n        self.check_type('path_component', path_component, unicode_type)\n        self.write(self.errors)\n\n    def check_type(self, name, obj, expected_type):\n        actual_type = type(obj)\n        if expected_type != actual_type:\n            self.errors[name] = \"expected %s, got %s\" % (expected_type,\n                                                         actual_type)\n\n\nclass DecodeArgHandler(RequestHandler):\n    def decode_argument(self, value, name=None):\n        if type(value) != bytes_type:\n            raise Exception(\"unexpected type for value: %r\" % type(value))\n        # use self.request.arguments directly to avoid recursion\n        if 'encoding' in self.request.arguments:\n            return value.decode(to_unicode(self.request.arguments['encoding'][0]))\n        else:\n            return value\n\n    def get(self, arg):\n        def describe(s):\n            if type(s) == bytes_type:\n                return [\"bytes\", native_str(binascii.b2a_hex(s))]\n            elif type(s) == unicode_type:\n                return [\"unicode\", s]\n            raise Exception(\"unknown type\")\n        self.write({'path': describe(arg),\n                    'query': describe(self.get_argument(\"foo\")),\n                    })\n\n\nclass LinkifyHandler(RequestHandler):\n    def get(self):\n        self.render(\"linkify.html\", message=\"http://example.com\")\n\n\nclass UIModuleResourceHandler(RequestHandler):\n    def get(self):\n        self.render(\"page.html\", entries=[1, 2])\n\n\nclass OptionalPathHandler(RequestHandler):\n    def get(self, path):\n        self.write({\"path\": path})\n\n\nclass FlowControlHandler(RequestHandler):\n    # These writes are too small to demonstrate real flow control,\n    # but at least it shows that the callbacks get run.\n    @asynchronous\n    def get(self):\n        self.write(\"1\")\n        self.flush(callback=self.step2)\n\n    def step2(self):\n        self.write(\"2\")\n        self.flush(callback=self.step3)\n\n    def step3(self):\n        self.write(\"3\")\n        self.finish()\n\n\nclass MultiHeaderHandler(RequestHandler):\n    def get(self):\n        self.set_header(\"x-overwrite\", \"1\")\n        self.set_header(\"X-Overwrite\", 2)\n        self.add_header(\"x-multi\", 3)\n        self.add_header(\"X-Multi\", \"4\")\n\n\nclass RedirectHandler(RequestHandler):\n    def get(self):\n        if self.get_argument('permanent', None) is not None:\n            self.redirect('/', permanent=int(self.get_argument('permanent')))\n        elif self.get_argument('status', None) is not None:\n            self.redirect('/', status=int(self.get_argument('status')))\n        else:\n            raise Exception(\"didn't get permanent or status arguments\")\n\n\nclass EmptyFlushCallbackHandler(RequestHandler):\n    @gen.engine\n    @asynchronous\n    def get(self):\n        # Ensure that the flush callback is run whether or not there\n        # was any output.\n        yield gen.Task(self.flush)  # \"empty\" flush, but writes headers\n        yield gen.Task(self.flush)  # empty flush\n        self.write(\"o\")\n        yield gen.Task(self.flush)  # flushes the \"o\"\n        yield gen.Task(self.flush)  # empty flush\n        self.finish(\"k\")\n\n\nclass HeaderInjectionHandler(RequestHandler):\n    def get(self):\n        try:\n            self.set_header(\"X-Foo\", \"foo\\r\\nX-Bar: baz\")\n            raise Exception(\"Didn't get expected exception\")\n        except ValueError as e:\n            if \"Unsafe header value\" in str(e):\n                self.finish(b\"ok\")\n            else:\n                raise\n\n\nclass GetArgumentHandler(RequestHandler):\n    def prepare(self):\n        if self.get_argument('source', None) == 'query':\n            method = self.get_query_argument\n        elif self.get_argument('source', None) == 'body':\n            method = self.get_body_argument\n        else:\n            method = self.get_argument\n        self.finish(method(\"foo\", \"default\"))\n\n\nclass GetArgumentsHandler(RequestHandler):\n    def prepare(self):\n        self.finish(dict(default=self.get_arguments(\"foo\"),\n                         query=self.get_query_arguments(\"foo\"),\n                         body=self.get_body_arguments(\"foo\")))\n\n\n# This test is shared with wsgi_test.py\n@wsgi_safe\nclass WSGISafeWebTest(WebTestCase):\n    COOKIE_SECRET = \"WebTest.COOKIE_SECRET\"\n\n    def get_app_kwargs(self):\n        loader = DictLoader({\n            \"linkify.html\": \"{% module linkify(message) %}\",\n            \"page.html\": \"\"\"\\\n<html><head></head><body>\n{% for e in entries %}\n{% module Template(\"entry.html\", entry=e) %}\n{% end %}\n</body></html>\"\"\",\n            \"entry.html\": \"\"\"\\\n{{ set_resources(embedded_css=\".entry { margin-bottom: 1em; }\", embedded_javascript=\"js_embed()\", css_files=[\"/base.css\", \"/foo.css\"], javascript_files=\"/common.js\", html_head=\"<meta>\", html_body='<script src=\"/analytics.js\"/>') }}\n<div class=\"entry\">...</div>\"\"\",\n        })\n        return dict(template_loader=loader,\n                    autoescape=\"xhtml_escape\",\n                    cookie_secret=self.COOKIE_SECRET)\n\n    def tearDown(self):\n        super(WSGISafeWebTest, self).tearDown()\n        RequestHandler._template_loaders.clear()\n\n    def get_handlers(self):\n        urls = [\n            url(\"/typecheck/(.*)\", TypeCheckHandler, name='typecheck'),\n            url(\"/decode_arg/(.*)\", DecodeArgHandler, name='decode_arg'),\n            url(\"/decode_arg_kw/(?P<arg>.*)\", DecodeArgHandler),\n            url(\"/linkify\", LinkifyHandler),\n            url(\"/uimodule_resources\", UIModuleResourceHandler),\n            url(\"/optional_path/(.+)?\", OptionalPathHandler),\n            url(\"/multi_header\", MultiHeaderHandler),\n            url(\"/redirect\", RedirectHandler),\n            url(\"/header_injection\", HeaderInjectionHandler),\n            url(\"/get_argument\", GetArgumentHandler),\n            url(\"/get_arguments\", GetArgumentsHandler),\n        ]\n        return urls\n\n    def fetch_json(self, *args, **kwargs):\n        response = self.fetch(*args, **kwargs)\n        response.rethrow()\n        return json_decode(response.body)\n\n    def test_types(self):\n        cookie_value = to_unicode(create_signed_value(self.COOKIE_SECRET,\n                                                      \"asdf\", \"qwer\"))\n        response = self.fetch(\"/typecheck/asdf?foo=bar\",\n                              headers={\"Cookie\": \"asdf=\" + cookie_value})\n        data = json_decode(response.body)\n        self.assertEqual(data, {})\n\n        response = self.fetch(\"/typecheck/asdf?foo=bar\", method=\"POST\",\n                              headers={\"Cookie\": \"asdf=\" + cookie_value},\n                              body=\"foo=bar\")\n\n    def test_decode_argument(self):\n        # These urls all decode to the same thing\n        urls = [\"/decode_arg/%C3%A9?foo=%C3%A9&encoding=utf-8\",\n                \"/decode_arg/%E9?foo=%E9&encoding=latin1\",\n                \"/decode_arg_kw/%E9?foo=%E9&encoding=latin1\",\n                ]\n        for url in urls:\n            response = self.fetch(url)\n            response.rethrow()\n            data = json_decode(response.body)\n            self.assertEqual(data, {u('path'): [u('unicode'), u('\\u00e9')],\n                                    u('query'): [u('unicode'), u('\\u00e9')],\n                                    })\n\n        response = self.fetch(\"/decode_arg/%C3%A9?foo=%C3%A9\")\n        response.rethrow()\n        data = json_decode(response.body)\n        self.assertEqual(data, {u('path'): [u('bytes'), u('c3a9')],\n                                u('query'): [u('bytes'), u('c3a9')],\n                                })\n\n    def test_decode_argument_invalid_unicode(self):\n        # test that invalid unicode in URLs causes 400, not 500\n        with ExpectLog(gen_log, \".*Invalid unicode.*\"):\n            response = self.fetch(\"/typecheck/invalid%FF\")\n            self.assertEqual(response.code, 400)\n            response = self.fetch(\"/typecheck/invalid?foo=%FF\")\n            self.assertEqual(response.code, 400)\n\n    def test_decode_argument_plus(self):\n        # These urls are all equivalent.\n        urls = [\"/decode_arg/1%20%2B%201?foo=1%20%2B%201&encoding=utf-8\",\n                \"/decode_arg/1%20+%201?foo=1+%2B+1&encoding=utf-8\"]\n        for url in urls:\n            response = self.fetch(url)\n            response.rethrow()\n            data = json_decode(response.body)\n            self.assertEqual(data, {u('path'): [u('unicode'), u('1 + 1')],\n                                    u('query'): [u('unicode'), u('1 + 1')],\n                                    })\n\n    def test_reverse_url(self):\n        self.assertEqual(self.app.reverse_url('decode_arg', 'foo'),\n                         '/decode_arg/foo')\n        self.assertEqual(self.app.reverse_url('decode_arg', 42),\n                         '/decode_arg/42')\n        self.assertEqual(self.app.reverse_url('decode_arg', b'\\xe9'),\n                         '/decode_arg/%E9')\n        self.assertEqual(self.app.reverse_url('decode_arg', u('\\u00e9')),\n                         '/decode_arg/%C3%A9')\n        self.assertEqual(self.app.reverse_url('decode_arg', '1 + 1'),\n                         '/decode_arg/1%20%2B%201')\n\n    def test_uimodule_unescaped(self):\n        response = self.fetch(\"/linkify\")\n        self.assertEqual(response.body,\n                         b\"<a href=\\\"http://example.com\\\">http://example.com</a>\")\n\n    def test_uimodule_resources(self):\n        response = self.fetch(\"/uimodule_resources\")\n        self.assertEqual(response.body, b\"\"\"\\\n<html><head><link href=\"/base.css\" type=\"text/css\" rel=\"stylesheet\"/><link href=\"/foo.css\" type=\"text/css\" rel=\"stylesheet\"/>\n<style type=\"text/css\">\n.entry { margin-bottom: 1em; }\n</style>\n<meta>\n</head><body>\n\n\n<div class=\"entry\">...</div>\n\n\n<div class=\"entry\">...</div>\n\n<script src=\"/common.js\" type=\"text/javascript\"></script>\n<script type=\"text/javascript\">\n//<![CDATA[\njs_embed()\n//]]>\n</script>\n<script src=\"/analytics.js\"/>\n</body></html>\"\"\")\n\n    def test_optional_path(self):\n        self.assertEqual(self.fetch_json(\"/optional_path/foo\"),\n                         {u(\"path\"): u(\"foo\")})\n        self.assertEqual(self.fetch_json(\"/optional_path/\"),\n                         {u(\"path\"): None})\n\n    def test_multi_header(self):\n        response = self.fetch(\"/multi_header\")\n        self.assertEqual(response.headers[\"x-overwrite\"], \"2\")\n        self.assertEqual(response.headers.get_list(\"x-multi\"), [\"3\", \"4\"])\n\n    def test_redirect(self):\n        response = self.fetch(\"/redirect?permanent=1\", follow_redirects=False)\n        self.assertEqual(response.code, 301)\n        response = self.fetch(\"/redirect?permanent=0\", follow_redirects=False)\n        self.assertEqual(response.code, 302)\n        response = self.fetch(\"/redirect?status=307\", follow_redirects=False)\n        self.assertEqual(response.code, 307)\n\n    def test_header_injection(self):\n        response = self.fetch(\"/header_injection\")\n        self.assertEqual(response.body, b\"ok\")\n\n    def test_get_argument(self):\n        response = self.fetch(\"/get_argument?foo=bar\")\n        self.assertEqual(response.body, b\"bar\")\n        response = self.fetch(\"/get_argument?foo=\")\n        self.assertEqual(response.body, b\"\")\n        response = self.fetch(\"/get_argument\")\n        self.assertEqual(response.body, b\"default\")\n\n        # Test merging of query and body arguments.\n        # In singular form, body arguments take precedence over query arguments.\n        body = urllib_parse.urlencode(dict(foo=\"hello\"))\n        response = self.fetch(\"/get_argument?foo=bar\", method=\"POST\", body=body)\n        self.assertEqual(response.body, b\"hello\")\n        # In plural methods they are merged.\n        response = self.fetch(\"/get_arguments?foo=bar\",\n                              method=\"POST\", body=body)\n        self.assertEqual(json_decode(response.body),\n                         dict(default=['bar', 'hello'],\n                              query=['bar'],\n                              body=['hello']))\n\n    def test_get_query_arguments(self):\n        # send as a post so we can ensure the separation between query\n        # string and body arguments.\n        body = urllib_parse.urlencode(dict(foo=\"hello\"))\n        response = self.fetch(\"/get_argument?source=query&foo=bar\",\n                              method=\"POST\", body=body)\n        self.assertEqual(response.body, b\"bar\")\n        response = self.fetch(\"/get_argument?source=query&foo=\",\n                              method=\"POST\", body=body)\n        self.assertEqual(response.body, b\"\")\n        response = self.fetch(\"/get_argument?source=query\",\n                              method=\"POST\", body=body)\n        self.assertEqual(response.body, b\"default\")\n\n    def test_get_body_arguments(self):\n        body = urllib_parse.urlencode(dict(foo=\"bar\"))\n        response = self.fetch(\"/get_argument?source=body&foo=hello\",\n                              method=\"POST\", body=body)\n        self.assertEqual(response.body, b\"bar\")\n\n        body = urllib_parse.urlencode(dict(foo=\"\"))\n        response = self.fetch(\"/get_argument?source=body&foo=hello\",\n                              method=\"POST\", body=body)\n        self.assertEqual(response.body, b\"\")\n\n        body = urllib_parse.urlencode(dict())\n        response = self.fetch(\"/get_argument?source=body&foo=hello\",\n                              method=\"POST\", body=body)\n        self.assertEqual(response.body, b\"default\")\n\n    def test_no_gzip(self):\n        response = self.fetch('/get_argument')\n        self.assertNotIn('Accept-Encoding', response.headers.get('Vary', ''))\n        self.assertNotIn('gzip', response.headers.get('Content-Encoding', ''))\n\n\nclass NonWSGIWebTests(WebTestCase):\n    def get_handlers(self):\n        return [(\"/flow_control\", FlowControlHandler),\n                (\"/empty_flush\", EmptyFlushCallbackHandler),\n                ]\n\n    def test_flow_control(self):\n        self.assertEqual(self.fetch(\"/flow_control\").body, b\"123\")\n\n    def test_empty_flush(self):\n        response = self.fetch(\"/empty_flush\")\n        self.assertEqual(response.body, b\"ok\")\n\n\n@wsgi_safe\nclass ErrorResponseTest(WebTestCase):\n    def get_handlers(self):\n        class DefaultHandler(RequestHandler):\n            def get(self):\n                if self.get_argument(\"status\", None):\n                    raise HTTPError(int(self.get_argument(\"status\")))\n                1 / 0\n\n        class WriteErrorHandler(RequestHandler):\n            def get(self):\n                if self.get_argument(\"status\", None):\n                    self.send_error(int(self.get_argument(\"status\")))\n                else:\n                    1 / 0\n\n            def write_error(self, status_code, **kwargs):\n                self.set_header(\"Content-Type\", \"text/plain\")\n                if \"exc_info\" in kwargs:\n                    self.write(\"Exception: %s\" % kwargs[\"exc_info\"][0].__name__)\n                else:\n                    self.write(\"Status: %d\" % status_code)\n\n        class GetErrorHtmlHandler(RequestHandler):\n            def get(self):\n                if self.get_argument(\"status\", None):\n                    self.send_error(int(self.get_argument(\"status\")))\n                else:\n                    1 / 0\n\n            def get_error_html(self, status_code, **kwargs):\n                self.set_header(\"Content-Type\", \"text/plain\")\n                if \"exception\" in kwargs:\n                    self.write(\"Exception: %s\" % sys.exc_info()[0].__name__)\n                else:\n                    self.write(\"Status: %d\" % status_code)\n\n        class FailedWriteErrorHandler(RequestHandler):\n            def get(self):\n                1 / 0\n\n            def write_error(self, status_code, **kwargs):\n                raise Exception(\"exception in write_error\")\n\n        return [url(\"/default\", DefaultHandler),\n                url(\"/write_error\", WriteErrorHandler),\n                url(\"/get_error_html\", GetErrorHtmlHandler),\n                url(\"/failed_write_error\", FailedWriteErrorHandler),\n                ]\n\n    def test_default(self):\n        with ExpectLog(app_log, \"Uncaught exception\"):\n            response = self.fetch(\"/default\")\n            self.assertEqual(response.code, 500)\n            self.assertTrue(b\"500: Internal Server Error\" in response.body)\n\n            response = self.fetch(\"/default?status=503\")\n            self.assertEqual(response.code, 503)\n            self.assertTrue(b\"503: Service Unavailable\" in response.body)\n\n    def test_write_error(self):\n        with ExpectLog(app_log, \"Uncaught exception\"):\n            response = self.fetch(\"/write_error\")\n            self.assertEqual(response.code, 500)\n            self.assertEqual(b\"Exception: ZeroDivisionError\", response.body)\n\n            response = self.fetch(\"/write_error?status=503\")\n            self.assertEqual(response.code, 503)\n            self.assertEqual(b\"Status: 503\", response.body)\n\n    def test_get_error_html(self):\n        with ExpectLog(app_log, \"Uncaught exception\"):\n            response = self.fetch(\"/get_error_html\")\n            self.assertEqual(response.code, 500)\n            self.assertEqual(b\"Exception: ZeroDivisionError\", response.body)\n\n            response = self.fetch(\"/get_error_html?status=503\")\n            self.assertEqual(response.code, 503)\n            self.assertEqual(b\"Status: 503\", response.body)\n\n    def test_failed_write_error(self):\n        with ExpectLog(app_log, \"Uncaught exception\"):\n            response = self.fetch(\"/failed_write_error\")\n            self.assertEqual(response.code, 500)\n            self.assertEqual(b\"\", response.body)\n\n\n@wsgi_safe\nclass StaticFileTest(WebTestCase):\n    # The expected MD5 hash of robots.txt, used in tests that call\n    # StaticFileHandler.get_version\n    robots_txt_hash = b\"f71d20196d4caf35b6a670db8c70b03d\"\n    static_dir = os.path.join(os.path.dirname(__file__), 'static')\n\n    def get_handlers(self):\n        class StaticUrlHandler(RequestHandler):\n            def get(self, path):\n                with_v = int(self.get_argument('include_version', 1))\n                self.write(self.static_url(path, include_version=with_v))\n\n        class AbsoluteStaticUrlHandler(StaticUrlHandler):\n            include_host = True\n\n        class OverrideStaticUrlHandler(RequestHandler):\n            def get(self, path):\n                do_include = bool(self.get_argument(\"include_host\"))\n                self.include_host = not do_include\n\n                regular_url = self.static_url(path)\n                override_url = self.static_url(path, include_host=do_include)\n                if override_url == regular_url:\n                    return self.write(str(False))\n\n                protocol = self.request.protocol + \"://\"\n                protocol_length = len(protocol)\n                check_regular = regular_url.find(protocol, 0, protocol_length)\n                check_override = override_url.find(protocol, 0, protocol_length)\n\n                if do_include:\n                    result = (check_override == 0 and check_regular == -1)\n                else:\n                    result = (check_override == -1 and check_regular == 0)\n                self.write(str(result))\n\n        return [('/static_url/(.*)', StaticUrlHandler),\n                ('/abs_static_url/(.*)', AbsoluteStaticUrlHandler),\n                ('/override_static_url/(.*)', OverrideStaticUrlHandler)]\n\n    def get_app_kwargs(self):\n        return dict(static_path=relpath('static'))\n\n    def test_static_files(self):\n        response = self.fetch('/robots.txt')\n        self.assertTrue(b\"Disallow: /\" in response.body)\n\n        response = self.fetch('/static/robots.txt')\n        self.assertTrue(b\"Disallow: /\" in response.body)\n\n    def test_static_url(self):\n        response = self.fetch(\"/static_url/robots.txt\")\n        self.assertEqual(response.body,\n                         b\"/static/robots.txt?v=\" + self.robots_txt_hash)\n\n    def test_absolute_static_url(self):\n        response = self.fetch(\"/abs_static_url/robots.txt\")\n        self.assertEqual(response.body, (\n            utf8(self.get_url(\"/\")) +\n            b\"static/robots.txt?v=\" +\n            self.robots_txt_hash\n        ))\n\n    def test_relative_version_exclusion(self):\n        response = self.fetch(\"/static_url/robots.txt?include_version=0\")\n        self.assertEqual(response.body, b\"/static/robots.txt\")\n\n    def test_absolute_version_exclusion(self):\n        response = self.fetch(\"/abs_static_url/robots.txt?include_version=0\")\n        self.assertEqual(response.body,\n                         utf8(self.get_url(\"/\") + \"static/robots.txt\"))\n\n    def test_include_host_override(self):\n        self._trigger_include_host_check(False)\n        self._trigger_include_host_check(True)\n\n    def _trigger_include_host_check(self, include_host):\n        path = \"/override_static_url/robots.txt?include_host=%s\"\n        response = self.fetch(path % int(include_host))\n        self.assertEqual(response.body, utf8(str(True)))\n\n    def test_static_304_if_modified_since(self):\n        response1 = self.fetch(\"/static/robots.txt\")\n        response2 = self.fetch(\"/static/robots.txt\", headers={\n            'If-Modified-Since': response1.headers['Last-Modified']})\n        self.assertEqual(response2.code, 304)\n        self.assertTrue('Content-Length' not in response2.headers)\n        self.assertTrue('Last-Modified' not in response2.headers)\n\n    def test_static_304_if_none_match(self):\n        response1 = self.fetch(\"/static/robots.txt\")\n        response2 = self.fetch(\"/static/robots.txt\", headers={\n            'If-None-Match': response1.headers['Etag']})\n        self.assertEqual(response2.code, 304)\n\n    def test_static_if_modified_since_pre_epoch(self):\n        # On windows, the functions that work with time_t do not accept\n        # negative values, and at least one client (processing.js) seems\n        # to use if-modified-since 1/1/1960 as a cache-busting technique.\n        response = self.fetch(\"/static/robots.txt\", headers={\n            'If-Modified-Since': 'Fri, 01 Jan 1960 00:00:00 GMT'})\n        self.assertEqual(response.code, 200)\n\n    def test_static_if_modified_since_time_zone(self):\n        # Instead of the value from Last-Modified, make requests with times\n        # chosen just before and after the known modification time\n        # of the file to ensure that the right time zone is being used\n        # when parsing If-Modified-Since.\n        stat = os.stat(relpath('static/robots.txt'))\n\n        response = self.fetch('/static/robots.txt', headers={\n            'If-Modified-Since': format_timestamp(stat.st_mtime - 1)})\n        self.assertEqual(response.code, 200)\n        response = self.fetch('/static/robots.txt', headers={\n            'If-Modified-Since': format_timestamp(stat.st_mtime + 1)})\n        self.assertEqual(response.code, 304)\n\n    def test_static_etag(self):\n        response = self.fetch('/static/robots.txt')\n        self.assertEqual(utf8(response.headers.get(\"Etag\")),\n                         b'\"' + self.robots_txt_hash + b'\"')\n\n    def test_static_with_range(self):\n        response = self.fetch('/static/robots.txt', headers={\n            'Range': 'bytes=0-9'})\n        self.assertEqual(response.code, 206)\n        self.assertEqual(response.body, b\"User-agent\")\n        self.assertEqual(utf8(response.headers.get(\"Etag\")),\n                         b'\"' + self.robots_txt_hash + b'\"')\n        self.assertEqual(response.headers.get(\"Content-Length\"), \"10\")\n        self.assertEqual(response.headers.get(\"Content-Range\"),\n                         \"bytes 0-9/26\")\n\n    def test_static_with_range_full_file(self):\n        response = self.fetch('/static/robots.txt', headers={\n            'Range': 'bytes=0-'})\n        # Note: Chrome refuses to play audio if it gets an HTTP 206 in response\n        # to ``Range: bytes=0-`` :(\n        self.assertEqual(response.code, 200)\n        robots_file_path = os.path.join(self.static_dir, \"robots.txt\")\n        with open(robots_file_path) as f:\n            self.assertEqual(response.body, utf8(f.read()))\n        self.assertEqual(response.headers.get(\"Content-Length\"), \"26\")\n        self.assertEqual(response.headers.get(\"Content-Range\"), None)\n\n    def test_static_with_range_full_past_end(self):\n        response = self.fetch('/static/robots.txt', headers={\n            'Range': 'bytes=0-10000000'})\n        self.assertEqual(response.code, 200)\n        robots_file_path = os.path.join(self.static_dir, \"robots.txt\")\n        with open(robots_file_path) as f:\n            self.assertEqual(response.body, utf8(f.read()))\n        self.assertEqual(response.headers.get(\"Content-Length\"), \"26\")\n        self.assertEqual(response.headers.get(\"Content-Range\"), None)\n\n    def test_static_with_range_partial_past_end(self):\n        response = self.fetch('/static/robots.txt', headers={\n            'Range': 'bytes=1-10000000'})\n        self.assertEqual(response.code, 206)\n        robots_file_path = os.path.join(self.static_dir, \"robots.txt\")\n        with open(robots_file_path) as f:\n            self.assertEqual(response.body, utf8(f.read()[1:]))\n        self.assertEqual(response.headers.get(\"Content-Length\"), \"25\")\n        self.assertEqual(response.headers.get(\"Content-Range\"), \"bytes 1-25/26\")\n\n    def test_static_with_range_end_edge(self):\n        response = self.fetch('/static/robots.txt', headers={\n            'Range': 'bytes=22-'})\n        self.assertEqual(response.body, b\": /\\n\")\n        self.assertEqual(response.headers.get(\"Content-Length\"), \"4\")\n        self.assertEqual(response.headers.get(\"Content-Range\"),\n                         \"bytes 22-25/26\")\n\n    def test_static_with_range_neg_end(self):\n        response = self.fetch('/static/robots.txt', headers={\n            'Range': 'bytes=-4'})\n        self.assertEqual(response.body, b\": /\\n\")\n        self.assertEqual(response.headers.get(\"Content-Length\"), \"4\")\n        self.assertEqual(response.headers.get(\"Content-Range\"),\n                         \"bytes 22-25/26\")\n\n    def test_static_invalid_range(self):\n        response = self.fetch('/static/robots.txt', headers={\n            'Range': 'asdf'})\n        self.assertEqual(response.code, 200)\n\n    def test_static_unsatisfiable_range_zero_suffix(self):\n        response = self.fetch('/static/robots.txt', headers={\n            'Range': 'bytes=-0'})\n        self.assertEqual(response.headers.get(\"Content-Range\"),\n                         \"bytes */26\")\n        self.assertEqual(response.code, 416)\n\n    def test_static_unsatisfiable_range_invalid_start(self):\n        response = self.fetch('/static/robots.txt', headers={\n            'Range': 'bytes=26'})\n        self.assertEqual(response.code, 416)\n        self.assertEqual(response.headers.get(\"Content-Range\"),\n                         \"bytes */26\")\n\n    def test_static_head(self):\n        response = self.fetch('/static/robots.txt', method='HEAD')\n        self.assertEqual(response.code, 200)\n        # No body was returned, but we did get the right content length.\n        self.assertEqual(response.body, b'')\n        self.assertEqual(response.headers['Content-Length'], '26')\n        self.assertEqual(utf8(response.headers['Etag']),\n                         b'\"' + self.robots_txt_hash + b'\"')\n\n    def test_static_head_range(self):\n        response = self.fetch('/static/robots.txt', method='HEAD',\n                              headers={'Range': 'bytes=1-4'})\n        self.assertEqual(response.code, 206)\n        self.assertEqual(response.body, b'')\n        self.assertEqual(response.headers['Content-Length'], '4')\n        self.assertEqual(utf8(response.headers['Etag']),\n                         b'\"' + self.robots_txt_hash + b'\"')\n\n    def test_static_range_if_none_match(self):\n        response = self.fetch('/static/robots.txt', headers={\n            'Range': 'bytes=1-4',\n            'If-None-Match': b'\"' + self.robots_txt_hash + b'\"'})\n        self.assertEqual(response.code, 304)\n        self.assertEqual(response.body, b'')\n        self.assertTrue('Content-Length' not in response.headers)\n        self.assertEqual(utf8(response.headers['Etag']),\n                         b'\"' + self.robots_txt_hash + b'\"')\n\n    def test_static_404(self):\n        response = self.fetch('/static/blarg')\n        self.assertEqual(response.code, 404)\n\n\n@wsgi_safe\nclass StaticDefaultFilenameTest(WebTestCase):\n    def get_app_kwargs(self):\n        return dict(static_path=relpath('static'),\n                    static_handler_args=dict(default_filename='index.html'))\n\n    def get_handlers(self):\n        return []\n\n    def test_static_default_filename(self):\n        response = self.fetch('/static/dir/', follow_redirects=False)\n        self.assertEqual(response.code, 200)\n        self.assertEqual(b'this is the index\\n', response.body)\n\n    def test_static_default_redirect(self):\n        response = self.fetch('/static/dir', follow_redirects=False)\n        self.assertEqual(response.code, 301)\n        self.assertTrue(response.headers['Location'].endswith('/static/dir/'))\n\n\n@wsgi_safe\nclass StaticFileWithPathTest(WebTestCase):\n    def get_app_kwargs(self):\n        return dict(static_path=relpath('static'),\n                    static_handler_args=dict(default_filename='index.html'))\n\n    def get_handlers(self):\n        return [(\"/foo/(.*)\", StaticFileHandler, {\n            \"path\": relpath(\"templates/\"),\n        })]\n\n    def test_serve(self):\n        response = self.fetch(\"/foo/utf8.html\")\n        self.assertEqual(response.body, b\"H\\xc3\\xa9llo\\n\")\n\n\n@wsgi_safe\nclass CustomStaticFileTest(WebTestCase):\n    def get_handlers(self):\n        class MyStaticFileHandler(StaticFileHandler):\n            @classmethod\n            def make_static_url(cls, settings, path):\n                version_hash = cls.get_version(settings, path)\n                extension_index = path.rindex('.')\n                before_version = path[:extension_index]\n                after_version = path[(extension_index + 1):]\n                return '/static/%s.%s.%s' % (before_version, version_hash,\n                                             after_version)\n\n            def parse_url_path(self, url_path):\n                extension_index = url_path.rindex('.')\n                version_index = url_path.rindex('.', 0, extension_index)\n                return '%s%s' % (url_path[:version_index],\n                                 url_path[extension_index:])\n\n            @classmethod\n            def get_absolute_path(cls, settings, path):\n                return 'CustomStaticFileTest:' + path\n\n            def validate_absolute_path(self, root, absolute_path):\n                return absolute_path\n\n            @classmethod\n            def get_content(self, path, start=None, end=None):\n                assert start is None and end is None\n                if path == 'CustomStaticFileTest:foo.txt':\n                    return b'bar'\n                raise Exception(\"unexpected path %r\" % path)\n\n            def get_modified_time(self):\n                return None\n\n            @classmethod\n            def get_version(cls, settings, path):\n                return \"42\"\n\n        class StaticUrlHandler(RequestHandler):\n            def get(self, path):\n                self.write(self.static_url(path))\n\n        self.static_handler_class = MyStaticFileHandler\n\n        return [(\"/static_url/(.*)\", StaticUrlHandler)]\n\n    def get_app_kwargs(self):\n        return dict(static_path=\"dummy\",\n                    static_handler_class=self.static_handler_class)\n\n    def test_serve(self):\n        response = self.fetch(\"/static/foo.42.txt\")\n        self.assertEqual(response.body, b\"bar\")\n\n    def test_static_url(self):\n        with ExpectLog(gen_log, \"Could not open static file\", required=False):\n            response = self.fetch(\"/static_url/foo.txt\")\n            self.assertEqual(response.body, b\"/static/foo.42.txt\")\n\n\n@wsgi_safe\nclass HostMatchingTest(WebTestCase):\n    class Handler(RequestHandler):\n        def initialize(self, reply):\n            self.reply = reply\n\n        def get(self):\n            self.write(self.reply)\n\n    def get_handlers(self):\n        return [(\"/foo\", HostMatchingTest.Handler, {\"reply\": \"wildcard\"})]\n\n    def test_host_matching(self):\n        self.app.add_handlers(\"www.example.com\",\n                              [(\"/foo\", HostMatchingTest.Handler, {\"reply\": \"[0]\"})])\n        self.app.add_handlers(r\"www\\.example\\.com\",\n                              [(\"/bar\", HostMatchingTest.Handler, {\"reply\": \"[1]\"})])\n        self.app.add_handlers(\"www.example.com\",\n                              [(\"/baz\", HostMatchingTest.Handler, {\"reply\": \"[2]\"})])\n\n        response = self.fetch(\"/foo\")\n        self.assertEqual(response.body, b\"wildcard\")\n        response = self.fetch(\"/bar\")\n        self.assertEqual(response.code, 404)\n        response = self.fetch(\"/baz\")\n        self.assertEqual(response.code, 404)\n\n        response = self.fetch(\"/foo\", headers={'Host': 'www.example.com'})\n        self.assertEqual(response.body, b\"[0]\")\n        response = self.fetch(\"/bar\", headers={'Host': 'www.example.com'})\n        self.assertEqual(response.body, b\"[1]\")\n        response = self.fetch(\"/baz\", headers={'Host': 'www.example.com'})\n        self.assertEqual(response.body, b\"[2]\")\n\n\n@wsgi_safe\nclass NamedURLSpecGroupsTest(WebTestCase):\n    def get_handlers(self):\n        class EchoHandler(RequestHandler):\n            def get(self, path):\n                self.write(path)\n\n        return [(\"/str/(?P<path>.*)\", EchoHandler),\n                (u(\"/unicode/(?P<path>.*)\"), EchoHandler)]\n\n    def test_named_urlspec_groups(self):\n        response = self.fetch(\"/str/foo\")\n        self.assertEqual(response.body, b\"foo\")\n\n        response = self.fetch(\"/unicode/bar\")\n        self.assertEqual(response.body, b\"bar\")\n\n\n@wsgi_safe\nclass ClearHeaderTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def get(self):\n            self.set_header(\"h1\", \"foo\")\n            self.set_header(\"h2\", \"bar\")\n            self.clear_header(\"h1\")\n            self.clear_header(\"nonexistent\")\n\n    def test_clear_header(self):\n        response = self.fetch(\"/\")\n        self.assertTrue(\"h1\" not in response.headers)\n        self.assertEqual(response.headers[\"h2\"], \"bar\")\n\n\n@wsgi_safe\nclass Header304Test(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def get(self):\n            self.set_header(\"Content-Language\", \"en_US\")\n            self.write(\"hello\")\n\n    def test_304_headers(self):\n        response1 = self.fetch('/')\n        self.assertEqual(response1.headers[\"Content-Length\"], \"5\")\n        self.assertEqual(response1.headers[\"Content-Language\"], \"en_US\")\n\n        response2 = self.fetch('/', headers={\n            'If-None-Match': response1.headers[\"Etag\"]})\n        self.assertEqual(response2.code, 304)\n        self.assertTrue(\"Content-Length\" not in response2.headers)\n        self.assertTrue(\"Content-Language\" not in response2.headers)\n        # Not an entity header, but should not be added to 304s by chunking\n        self.assertTrue(\"Transfer-Encoding\" not in response2.headers)\n\n\n@wsgi_safe\nclass StatusReasonTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def get(self):\n            reason = self.request.arguments.get('reason', [])\n            self.set_status(int(self.get_argument('code')),\n                            reason=reason[0] if reason else None)\n\n    def get_http_client(self):\n        # simple_httpclient only: curl doesn't expose the reason string\n        return SimpleAsyncHTTPClient(io_loop=self.io_loop)\n\n    def test_status(self):\n        response = self.fetch(\"/?code=304\")\n        self.assertEqual(response.code, 304)\n        self.assertEqual(response.reason, \"Not Modified\")\n        response = self.fetch(\"/?code=304&reason=Foo\")\n        self.assertEqual(response.code, 304)\n        self.assertEqual(response.reason, \"Foo\")\n        response = self.fetch(\"/?code=682&reason=Bar\")\n        self.assertEqual(response.code, 682)\n        self.assertEqual(response.reason, \"Bar\")\n        with ExpectLog(app_log, 'Uncaught exception'):\n            response = self.fetch(\"/?code=682\")\n        self.assertEqual(response.code, 500)\n\n\n@wsgi_safe\nclass DateHeaderTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def get(self):\n            self.write(\"hello\")\n\n    def test_date_header(self):\n        response = self.fetch('/')\n        header_date = datetime.datetime(\n            *email.utils.parsedate(response.headers['Date'])[:6])\n        self.assertTrue(header_date - datetime.datetime.utcnow() <\n                        datetime.timedelta(seconds=2))\n\n\n@wsgi_safe\nclass RaiseWithReasonTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def get(self):\n            raise HTTPError(682, reason=\"Foo\")\n\n    def get_http_client(self):\n        # simple_httpclient only: curl doesn't expose the reason string\n        return SimpleAsyncHTTPClient(io_loop=self.io_loop)\n\n    def test_raise_with_reason(self):\n        response = self.fetch(\"/\")\n        self.assertEqual(response.code, 682)\n        self.assertEqual(response.reason, \"Foo\")\n        self.assertIn(b'682: Foo', response.body)\n\n    def test_httperror_str(self):\n        self.assertEqual(str(HTTPError(682, reason=\"Foo\")), \"HTTP 682: Foo\")\n\n\n@wsgi_safe\nclass ErrorHandlerXSRFTest(WebTestCase):\n    def get_handlers(self):\n        # note that if the handlers list is empty we get the default_host\n        # redirect fallback instead of a 404, so test with both an\n        # explicitly defined error handler and an implicit 404.\n        return [('/error', ErrorHandler, dict(status_code=417))]\n\n    def get_app_kwargs(self):\n        return dict(xsrf_cookies=True)\n\n    def test_error_xsrf(self):\n        response = self.fetch('/error', method='POST', body='')\n        self.assertEqual(response.code, 417)\n\n    def test_404_xsrf(self):\n        response = self.fetch('/404', method='POST', body='')\n        self.assertEqual(response.code, 404)\n\n\nclass GzipTestCase(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def get(self):\n            if self.get_argument('vary', None):\n                self.set_header('Vary', self.get_argument('vary'))\n            self.write('hello world')\n\n    def get_app_kwargs(self):\n        return dict(gzip=True)\n\n    def test_gzip(self):\n        response = self.fetch('/')\n        self.assertEqual(response.headers['Content-Encoding'], 'gzip')\n        self.assertEqual(response.headers['Vary'], 'Accept-Encoding')\n\n    def test_gzip_not_requested(self):\n        response = self.fetch('/', use_gzip=False)\n        self.assertNotIn('Content-Encoding', response.headers)\n        self.assertEqual(response.headers['Vary'], 'Accept-Encoding')\n\n    def test_vary_already_present(self):\n        response = self.fetch('/?vary=Accept-Language')\n        self.assertEqual(response.headers['Vary'],\n                         'Accept-Language, Accept-Encoding')\n\n\n@wsgi_safe\nclass PathArgsInPrepareTest(WebTestCase):\n    class Handler(RequestHandler):\n        def prepare(self):\n            self.write(dict(args=self.path_args, kwargs=self.path_kwargs))\n\n        def get(self, path):\n            assert path == 'foo'\n            self.finish()\n\n    def get_handlers(self):\n        return [('/pos/(.*)', self.Handler),\n                ('/kw/(?P<path>.*)', self.Handler)]\n\n    def test_pos(self):\n        response = self.fetch('/pos/foo')\n        response.rethrow()\n        data = json_decode(response.body)\n        self.assertEqual(data, {'args': ['foo'], 'kwargs': {}})\n\n    def test_kw(self):\n        response = self.fetch('/kw/foo')\n        response.rethrow()\n        data = json_decode(response.body)\n        self.assertEqual(data, {'args': [], 'kwargs': {'path': 'foo'}})\n\n\n@wsgi_safe\nclass ClearAllCookiesTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def get(self):\n            self.clear_all_cookies()\n            self.write('ok')\n\n    def test_clear_all_cookies(self):\n        response = self.fetch('/', headers={'Cookie': 'foo=bar; baz=xyzzy'})\n        set_cookies = sorted(response.headers.get_list('Set-Cookie'))\n        self.assertTrue(set_cookies[0].startswith('baz=;'))\n        self.assertTrue(set_cookies[1].startswith('foo=;'))\n\n\nclass PermissionError(Exception):\n    pass\n\n\n@wsgi_safe\nclass ExceptionHandlerTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def get(self):\n            exc = self.get_argument('exc')\n            if exc == 'http':\n                raise HTTPError(410, \"no longer here\")\n            elif exc == 'zero':\n                1 / 0\n            elif exc == 'permission':\n                raise PermissionError('not allowed')\n\n        def write_error(self, status_code, **kwargs):\n            if 'exc_info' in kwargs:\n                typ, value, tb = kwargs['exc_info']\n                if isinstance(value, PermissionError):\n                    self.set_status(403)\n                    self.write('PermissionError')\n                    return\n            RequestHandler.write_error(self, status_code, **kwargs)\n\n        def log_exception(self, typ, value, tb):\n            if isinstance(value, PermissionError):\n                app_log.warning('custom logging for PermissionError: %s',\n                                value.args[0])\n            else:\n                RequestHandler.log_exception(self, typ, value, tb)\n\n    def test_http_error(self):\n        # HTTPErrors are logged as warnings with no stack trace.\n        # TODO: extend ExpectLog to test this more precisely\n        with ExpectLog(gen_log, '.*no longer here'):\n            response = self.fetch('/?exc=http')\n            self.assertEqual(response.code, 410)\n\n    def test_unknown_error(self):\n        # Unknown errors are logged as errors with a stack trace.\n        with ExpectLog(app_log, 'Uncaught exception'):\n            response = self.fetch('/?exc=zero')\n            self.assertEqual(response.code, 500)\n\n    def test_known_error(self):\n        # log_exception can override logging behavior, and write_error\n        # can override the response.\n        with ExpectLog(app_log,\n                       'custom logging for PermissionError: not allowed'):\n            response = self.fetch('/?exc=permission')\n            self.assertEqual(response.code, 403)\n\n\n@wsgi_safe\nclass UIMethodUIModuleTest(SimpleHandlerTestCase):\n    \"\"\"Test that UI methods and modules are created correctly and\n    associated with the handler.\n    \"\"\"\n    class Handler(RequestHandler):\n        def get(self):\n            self.render('foo.html')\n\n        def value(self):\n            return self.get_argument(\"value\")\n\n    def get_app_kwargs(self):\n        def my_ui_method(handler, x):\n            return \"In my_ui_method(%s) with handler value %s.\" % (\n                x, handler.value())\n        class MyModule(UIModule):\n            def render(self, x):\n                return \"In MyModule(%s) with handler value %s.\" % (\n                    x, self.handler.value())\n\n        loader = DictLoader({\n            'foo.html': '{{ my_ui_method(42) }} {% module MyModule(123) %}',\n        })\n        return dict(template_loader=loader,\n                    ui_methods={'my_ui_method': my_ui_method},\n                    ui_modules={'MyModule': MyModule})\n\n    def tearDown(self):\n        super(UIMethodUIModuleTest, self).tearDown()\n        # TODO: fix template loader caching so this isn't necessary.\n        RequestHandler._template_loaders.clear()\n\n    def test_ui_method(self):\n        response = self.fetch('/?value=asdf')\n        self.assertEqual(response.body,\n                         b'In my_ui_method(42) with handler value asdf. '\n                         b'In MyModule(123) with handler value asdf.')\n\n\n@wsgi_safe\nclass GetArgumentErrorTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def get(self):\n            try:\n                self.get_argument('foo')\n                self.write({})\n            except MissingArgumentError as e:\n                self.write({'arg_name': e.arg_name,\n                            'log_message': e.log_message})\n\n    def test_catch_error(self):\n        response = self.fetch('/')\n        self.assertEqual(json_decode(response.body),\n                         {'arg_name': 'foo',\n                          'log_message': 'Missing argument foo'})\n\n\nclass MultipleExceptionTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        exc_count = 0\n\n        @asynchronous\n        def get(self):\n            from tornado.ioloop import IOLoop\n            IOLoop.current().add_callback(lambda: 1 / 0)\n            IOLoop.current().add_callback(lambda: 1 / 0)\n\n        def log_exception(self, typ, value, tb):\n            MultipleExceptionTest.Handler.exc_count += 1\n\n    def test_multi_exception(self):\n        # This test verifies that multiple exceptions raised into the same\n        # ExceptionStackContext do not generate extraneous log entries\n        # due to \"Cannot send error response after headers written\".\n        # log_exception is called, but it does not proceed to send_error.\n        response = self.fetch('/')\n        self.assertEqual(response.code, 500)\n        response = self.fetch('/')\n        self.assertEqual(response.code, 500)\n        # Each of our two requests generated two exceptions, we should have\n        # seen at least three of them by now (the fourth may still be\n        # in the queue).\n        self.assertGreater(MultipleExceptionTest.Handler.exc_count, 2)\n\n\n@wsgi_safe\nclass SetCurrentUserTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def prepare(self):\n            self.current_user = 'Ben'\n\n        def get(self):\n            self.write('Hello %s' % self.current_user)\n\n    def test_set_current_user(self):\n        # Ensure that current_user can be assigned to normally for apps\n        # that want to forgo the lazy get_current_user property\n        response = self.fetch('/')\n        self.assertEqual(response.body, b'Hello Ben')\n\n\n@wsgi_safe\nclass GetCurrentUserTest(WebTestCase):\n    def get_app_kwargs(self):\n        class WithoutUserModule(UIModule):\n            def render(self):\n                return ''\n\n        class WithUserModule(UIModule):\n            def render(self):\n                return str(self.current_user)\n\n        loader = DictLoader({\n            'without_user.html': '',\n            'with_user.html': '{{ current_user }}',\n            'without_user_module.html': '{% module WithoutUserModule() %}',\n            'with_user_module.html': '{% module WithUserModule() %}',\n        })\n        return dict(template_loader=loader,\n                    ui_modules={'WithUserModule': WithUserModule,\n                                'WithoutUserModule': WithoutUserModule})\n\n    def tearDown(self):\n        super(GetCurrentUserTest, self).tearDown()\n        RequestHandler._template_loaders.clear()\n\n    def get_handlers(self):\n        class CurrentUserHandler(RequestHandler):\n            def prepare(self):\n                self.has_loaded_current_user = False\n\n            def get_current_user(self):\n                self.has_loaded_current_user = True\n                return ''\n\n        class WithoutUserHandler(CurrentUserHandler):\n            def get(self):\n                self.render_string('without_user.html')\n                self.finish(str(self.has_loaded_current_user))\n\n        class WithUserHandler(CurrentUserHandler):\n            def get(self):\n                self.render_string('with_user.html')\n                self.finish(str(self.has_loaded_current_user))\n\n        class CurrentUserModuleHandler(CurrentUserHandler):\n            def get_template_namespace(self):\n                # If RequestHandler.get_template_namespace is called, then\n                # get_current_user is evaluated. Until #820 is fixed, this\n                # is a small hack to circumvent the issue.\n                return self.ui\n\n        class WithoutUserModuleHandler(CurrentUserModuleHandler):\n            def get(self):\n                self.render_string('without_user_module.html')\n                self.finish(str(self.has_loaded_current_user))\n\n        class WithUserModuleHandler(CurrentUserModuleHandler):\n            def get(self):\n                self.render_string('with_user_module.html')\n                self.finish(str(self.has_loaded_current_user))\n\n        return [('/without_user', WithoutUserHandler),\n                ('/with_user', WithUserHandler),\n                ('/without_user_module', WithoutUserModuleHandler),\n                ('/with_user_module', WithUserModuleHandler)]\n\n    @unittest.skip('needs fix')\n    def test_get_current_user_is_lazy(self):\n        # TODO: Make this test pass. See #820.\n        response = self.fetch('/without_user')\n        self.assertEqual(response.body, b'False')\n\n    def test_get_current_user_works(self):\n        response = self.fetch('/with_user')\n        self.assertEqual(response.body, b'True')\n\n    def test_get_current_user_from_ui_module_is_lazy(self):\n        response = self.fetch('/without_user_module')\n        self.assertEqual(response.body, b'False')\n\n    def test_get_current_user_from_ui_module_works(self):\n        response = self.fetch('/with_user_module')\n        self.assertEqual(response.body, b'True')\n\n\n@wsgi_safe\nclass UnimplementedHTTPMethodsTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        pass\n\n    def test_unimplemented_standard_methods(self):\n        for method in ['HEAD', 'GET', 'DELETE', 'OPTIONS']:\n            response = self.fetch('/', method=method)\n            self.assertEqual(response.code, 405)\n        for method in ['POST', 'PUT']:\n            response = self.fetch('/', method=method, body=b'')\n            self.assertEqual(response.code, 405)\n\n\nclass UnimplementedNonStandardMethodsTest(SimpleHandlerTestCase):\n    # wsgiref.validate complains about unknown methods in a way that makes\n    # this test not wsgi_safe.\n    class Handler(RequestHandler):\n        def other(self):\n            # Even though this method exists, it won't get called automatically\n            # because it is not in SUPPORTED_METHODS.\n            self.write('other')\n\n    def test_unimplemented_patch(self):\n        # PATCH is recently standardized; Tornado supports it by default\n        # but wsgiref.validate doesn't like it.\n        response = self.fetch('/', method='PATCH', body=b'')\n        self.assertEqual(response.code, 405)\n\n    def test_unimplemented_other(self):\n        response = self.fetch('/', method='OTHER',\n                              allow_nonstandard_methods=True)\n        self.assertEqual(response.code, 405)\n\n\n@wsgi_safe\nclass AllHTTPMethodsTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def method(self):\n            self.write(self.request.method)\n\n        get = delete = options = post = put = method\n\n    def test_standard_methods(self):\n        response = self.fetch('/', method='HEAD')\n        self.assertEqual(response.body, b'')\n        for method in ['GET', 'DELETE', 'OPTIONS']:\n            response = self.fetch('/', method=method)\n            self.assertEqual(response.body, utf8(method))\n        for method in ['POST', 'PUT']:\n            response = self.fetch('/', method=method, body=b'')\n            self.assertEqual(response.body, utf8(method))\n\n\nclass PatchMethodTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        SUPPORTED_METHODS = RequestHandler.SUPPORTED_METHODS + ('OTHER',)\n\n        def patch(self):\n            self.write('patch')\n\n        def other(self):\n            self.write('other')\n\n    def test_patch(self):\n        response = self.fetch('/', method='PATCH', body=b'')\n        self.assertEqual(response.body, b'patch')\n\n    def test_other(self):\n        response = self.fetch('/', method='OTHER',\n                              allow_nonstandard_methods=True)\n        self.assertEqual(response.body, b'other')\n\n\n@wsgi_safe\nclass FinishInPrepareTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def prepare(self):\n            self.finish('done')\n\n        def get(self):\n            # It's difficult to assert for certain that a method did not\n            # or will not be called in an asynchronous context, but this\n            # will be logged noisily if it is reached.\n            raise Exception('should not reach this method')\n\n    def test_finish_in_prepare(self):\n        response = self.fetch('/')\n        self.assertEqual(response.body, b'done')\n\n\n@wsgi_safe\nclass Default404Test(WebTestCase):\n    def get_handlers(self):\n        # If there are no handlers at all a default redirect handler gets added.\n        return [('/foo', RequestHandler)]\n\n    def test_404(self):\n        response = self.fetch('/')\n        self.assertEqual(response.code, 404)\n        self.assertEqual(response.body,\n                         b'<html><title>404: Not Found</title>'\n                         b'<body>404: Not Found</body></html>')\n\n\n@wsgi_safe\nclass Custom404Test(WebTestCase):\n    def get_handlers(self):\n        return [('/foo', RequestHandler)]\n\n    def get_app_kwargs(self):\n        class Custom404Handler(RequestHandler):\n            def get(self):\n                self.set_status(404)\n                self.write('custom 404 response')\n\n        return dict(default_handler_class=Custom404Handler)\n\n    def test_404(self):\n        response = self.fetch('/')\n        self.assertEqual(response.code, 404)\n        self.assertEqual(response.body, b'custom 404 response')\n\n\n@wsgi_safe\nclass DefaultHandlerArgumentsTest(WebTestCase):\n    def get_handlers(self):\n        return [('/foo', RequestHandler)]\n\n    def get_app_kwargs(self):\n        return dict(default_handler_class=ErrorHandler,\n                    default_handler_args=dict(status_code=403))\n\n    def test_403(self):\n        response = self.fetch('/')\n        self.assertEqual(response.code, 403)\n\n\n@wsgi_safe\nclass HandlerByNameTest(WebTestCase):\n    def get_handlers(self):\n        # All three are equivalent.\n        return [('/hello1', HelloHandler),\n                ('/hello2', 'tornado.test.web_test.HelloHandler'),\n                url('/hello3', 'tornado.test.web_test.HelloHandler'),\n                ]\n\n    def test_handler_by_name(self):\n        resp = self.fetch('/hello1')\n        self.assertEqual(resp.body, b'hello')\n        resp = self.fetch('/hello2')\n        self.assertEqual(resp.body, b'hello')\n        resp = self.fetch('/hello3')\n        self.assertEqual(resp.body, b'hello')\n\n\nclass SignedValueTest(unittest.TestCase):\n    SECRET = \"It's a secret to everybody\"\n\n    def past(self):\n        return self.present() - 86400 * 32\n\n    def present(self):\n        return 1300000000\n\n    def test_known_values(self):\n        signed_v1 = create_signed_value(SignedValueTest.SECRET, \"key\", \"value\",\n                                        version=1, clock=self.present)\n        self.assertEqual(\n            signed_v1,\n            b\"dmFsdWU=|1300000000|31c934969f53e48164c50768b40cbd7e2daaaa4f\")\n\n        signed_v2 = create_signed_value(SignedValueTest.SECRET, \"key\", \"value\",\n                                        version=2, clock=self.present)\n        self.assertEqual(\n            signed_v2,\n            b\"2|1:0|10:1300000000|3:key|8:dmFsdWU=|\"\n            b\"3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e152\")\n\n        signed_default = create_signed_value(SignedValueTest.SECRET,\n                                             \"key\", \"value\", clock=self.present)\n        self.assertEqual(signed_default, signed_v2)\n\n        decoded_v1 = decode_signed_value(SignedValueTest.SECRET, \"key\",\n                                         signed_v1, min_version=1,\n                                         clock=self.present)\n        self.assertEqual(decoded_v1, b\"value\")\n\n        decoded_v2 = decode_signed_value(SignedValueTest.SECRET, \"key\",\n                                         signed_v2, min_version=2,\n                                         clock=self.present)\n        self.assertEqual(decoded_v2, b\"value\")\n\n    def test_name_swap(self):\n        signed1 = create_signed_value(SignedValueTest.SECRET, \"key1\", \"value\",\n                                      clock=self.present)\n        signed2 = create_signed_value(SignedValueTest.SECRET, \"key2\", \"value\",\n                                      clock=self.present)\n        # Try decoding each string with the other's \"name\"\n        decoded1 = decode_signed_value(SignedValueTest.SECRET, \"key2\", signed1,\n                                       clock=self.present)\n        self.assertIs(decoded1, None)\n        decoded2 = decode_signed_value(SignedValueTest.SECRET, \"key1\", signed2,\n                                       clock=self.present)\n        self.assertIs(decoded2, None)\n\n    def test_expired(self):\n        signed = create_signed_value(SignedValueTest.SECRET, \"key1\", \"value\",\n                                     clock=self.past)\n        decoded_past = decode_signed_value(SignedValueTest.SECRET, \"key1\",\n                                           signed, clock=self.past)\n        self.assertEqual(decoded_past, b\"value\")\n        decoded_present = decode_signed_value(SignedValueTest.SECRET, \"key1\",\n                                              signed, clock=self.present)\n        self.assertIs(decoded_present, None)\n\n    def test_payload_tampering(self):\n        # These cookies are variants of the one in test_known_values.\n        sig = \"3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e152\"\n        def validate(prefix):\n            return (b'value' ==\n                    decode_signed_value(SignedValueTest.SECRET, \"key\",\n                                        prefix + sig, clock=self.present))\n        self.assertTrue(validate(\"2|1:0|10:1300000000|3:key|8:dmFsdWU=|\"))\n        # Change key version\n        self.assertFalse(validate(\"2|1:1|10:1300000000|3:key|8:dmFsdWU=|\"))\n        # length mismatch (field too short)\n        self.assertFalse(validate(\"2|1:0|10:130000000|3:key|8:dmFsdWU=|\"))\n        # length mismatch (field too long)\n        self.assertFalse(validate(\"2|1:0|10:1300000000|3:keey|8:dmFsdWU=|\"))\n\n    def test_signature_tampering(self):\n        prefix = \"2|1:0|10:1300000000|3:key|8:dmFsdWU=|\"\n        def validate(sig):\n            return (b'value' ==\n                    decode_signed_value(SignedValueTest.SECRET, \"key\",\n                                        prefix + sig, clock=self.present))\n        self.assertTrue(validate(\n            \"3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e152\"))\n        # All zeros\n        self.assertFalse(validate(\"0\" * 32))\n        # Change one character\n        self.assertFalse(validate(\n            \"4d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e152\"))\n        # Change another character\n        self.assertFalse(validate(\n            \"3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e153\"))\n        # Truncate\n        self.assertFalse(validate(\n            \"3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e15\"))\n        # Lengthen\n        self.assertFalse(validate(\n            \"3d4e60b996ff9c5d5788e333a0cba6f238a22c6c0f94788870e1a9ecd482e1538\"))\n\n    def test_non_ascii(self):\n        value = b\"\\xe9\"\n        signed = create_signed_value(SignedValueTest.SECRET, \"key\", value,\n                                     clock=self.present)\n        decoded = decode_signed_value(SignedValueTest.SECRET, \"key\", signed,\n                                      clock=self.present)\n        self.assertEqual(value, decoded)\n\n\n@wsgi_safe\nclass XSRFTest(SimpleHandlerTestCase):\n    class Handler(RequestHandler):\n        def get(self):\n            self.write(self.xsrf_token)\n\n        def post(self):\n            self.write(\"ok\")\n\n    def get_app_kwargs(self):\n        return dict(xsrf_cookies=True)\n\n    def setUp(self):\n        super(XSRFTest, self).setUp()\n        self.xsrf_token = self.get_token()\n\n    def get_token(self, old_token=None):\n        if old_token is not None:\n            headers = self.cookie_headers(old_token)\n        else:\n            headers = None\n        response = self.fetch(\"/\", headers=headers)\n        response.rethrow()\n        return native_str(response.body)\n\n    def cookie_headers(self, token=None):\n        if token is None:\n            token = self.xsrf_token\n        return {\"Cookie\": \"_xsrf=\" + token}\n\n    def test_xsrf_fail_no_token(self):\n        with ExpectLog(gen_log, \".*'_xsrf' argument missing\"):\n            response = self.fetch(\"/\", method=\"POST\", body=b\"\")\n        self.assertEqual(response.code, 403)\n\n    def test_xsrf_fail_body_no_cookie(self):\n        with ExpectLog(gen_log, \".*XSRF cookie does not match POST\"):\n            response = self.fetch(\n                \"/\", method=\"POST\",\n                body=urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)))\n        self.assertEqual(response.code, 403)\n\n    def test_xsrf_fail_cookie_no_body(self):\n        with ExpectLog(gen_log, \".*'_xsrf' argument missing\"):\n            response = self.fetch(\n                \"/\", method=\"POST\", body=b\"\",\n                headers=self.cookie_headers())\n        self.assertEqual(response.code, 403)\n\n    def test_xsrf_success_post_body(self):\n        response = self.fetch(\n            \"/\", method=\"POST\",\n            body=urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)),\n            headers=self.cookie_headers())\n        self.assertEqual(response.code, 200)\n\n    def test_xsrf_success_query_string(self):\n        response = self.fetch(\n            \"/?\" + urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)),\n            method=\"POST\", body=b\"\",\n            headers=self.cookie_headers())\n        self.assertEqual(response.code, 200)\n\n    def test_xsrf_success_header(self):\n        response = self.fetch(\"/\", method=\"POST\", body=b\"\",\n                              headers=dict({\"X-Xsrftoken\": self.xsrf_token},\n                                           **self.cookie_headers()))\n        self.assertEqual(response.code, 200)\n\n    def test_distinct_tokens(self):\n        # Every request gets a distinct token.\n        NUM_TOKENS = 10\n        tokens = set()\n        for i in range(NUM_TOKENS):\n            tokens.add(self.get_token())\n        self.assertEqual(len(tokens), NUM_TOKENS)\n\n    def test_cross_user(self):\n        token2 = self.get_token()\n        # Each token can be used to authenticate its own request.\n        for token in (self.xsrf_token, token2):\n            response  = self.fetch(\n                \"/\", method=\"POST\",\n                body=urllib_parse.urlencode(dict(_xsrf=token)),\n                headers=self.cookie_headers(token))\n            self.assertEqual(response.code, 200)\n        # Sending one in the cookie and the other in the body is not allowed.\n        for cookie_token, body_token in ((self.xsrf_token, token2),\n                                         (token2, self.xsrf_token)):\n            with ExpectLog(gen_log, '.*XSRF cookie does not match POST'):\n                response = self.fetch(\n                    \"/\", method=\"POST\",\n                    body=urllib_parse.urlencode(dict(_xsrf=body_token)),\n                    headers=self.cookie_headers(cookie_token))\n            self.assertEqual(response.code, 403)\n\n    def test_refresh_token(self):\n        token = self.xsrf_token\n        tokens_seen = set([token])\n        # A user's token is stable over time.  Refreshing the page in one tab\n        # might update the cookie while an older tab still has the old cookie\n        # in its DOM.  Simulate this scenario by passing a constant token\n        # in the body and re-querying for the token.\n        for i in range(5):\n            token = self.get_token(token)\n            # Tokens are encoded uniquely each time\n            tokens_seen.add(token)\n            response = self.fetch(\n                \"/\", method=\"POST\",\n                body=urllib_parse.urlencode(dict(_xsrf=self.xsrf_token)),\n                headers=self.cookie_headers(token))\n            self.assertEqual(response.code, 200)\n        self.assertEqual(len(tokens_seen), 6)\n", "from __future__ import absolute_import, division, print_function, with_statement\n\nimport traceback\n\nfrom tornado.concurrent import Future\nfrom tornado.httpclient import HTTPError, HTTPRequest\nfrom tornado.log import gen_log\nfrom tornado.testing import AsyncHTTPTestCase, gen_test, bind_unused_port, ExpectLog\nfrom tornado.test.util import unittest, skipOnTravis\nfrom tornado.web import Application, RequestHandler\n\ntry:\n    import tornado.websocket\n    from tornado.util import _websocket_mask_python\nexcept ImportError:\n    # The unittest module presents misleading errors on ImportError\n    # (it acts as if websocket_test could not be found, hiding the underlying\n    # error).  If we get an ImportError here (which could happen due to\n    # TORNADO_EXTENSION=1), print some extra information before failing.\n    traceback.print_exc()\n    raise\n\nfrom tornado.websocket import WebSocketHandler, websocket_connect, WebSocketError\n\ntry:\n    from tornado import speedups\nexcept ImportError:\n    speedups = None\n\n\nclass TestWebSocketHandler(WebSocketHandler):\n    \"\"\"Base class for testing handlers that exposes the on_close event.\n\n    This allows for deterministic cleanup of the associated socket.\n    \"\"\"\n    def initialize(self, close_future):\n        self.close_future = close_future\n\n    def on_close(self):\n        self.close_future.set_result(None)\n\n\nclass EchoHandler(TestWebSocketHandler):\n    def on_message(self, message):\n        self.write_message(message, isinstance(message, bytes))\n\n\nclass HeaderHandler(TestWebSocketHandler):\n    def open(self):\n        self.write_message(self.request.headers.get('X-Test', ''))\n\n\nclass NonWebSocketHandler(RequestHandler):\n    def get(self):\n        self.write('ok')\n\n\nclass WebSocketTest(AsyncHTTPTestCase):\n    def get_app(self):\n        self.close_future = Future()\n        return Application([\n            ('/echo', EchoHandler, dict(close_future=self.close_future)),\n            ('/non_ws', NonWebSocketHandler),\n            ('/header', HeaderHandler, dict(close_future=self.close_future)),\n        ])\n\n    @gen_test\n    def test_websocket_gen(self):\n        ws = yield websocket_connect(\n            'ws://localhost:%d/echo' % self.get_http_port(),\n            io_loop=self.io_loop)\n        ws.write_message('hello')\n        response = yield ws.read_message()\n        self.assertEqual(response, 'hello')\n        ws.close()\n        yield self.close_future\n\n    def test_websocket_callbacks(self):\n        websocket_connect(\n            'ws://localhost:%d/echo' % self.get_http_port(),\n            io_loop=self.io_loop, callback=self.stop)\n        ws = self.wait().result()\n        ws.write_message('hello')\n        ws.read_message(self.stop)\n        response = self.wait().result()\n        self.assertEqual(response, 'hello')\n        ws.close()\n        yield self.close_future\n\n    @gen_test\n    def test_websocket_http_fail(self):\n        with self.assertRaises(HTTPError) as cm:\n            yield websocket_connect(\n                'ws://localhost:%d/notfound' % self.get_http_port(),\n                io_loop=self.io_loop)\n        self.assertEqual(cm.exception.code, 404)\n\n    @gen_test\n    def test_websocket_http_success(self):\n        with self.assertRaises(WebSocketError):\n            yield websocket_connect(\n                'ws://localhost:%d/non_ws' % self.get_http_port(),\n                io_loop=self.io_loop)\n\n    @skipOnTravis\n    @gen_test\n    def test_websocket_network_timeout(self):\n        sock, port = bind_unused_port()\n        sock.close()\n        with self.assertRaises(HTTPError) as cm:\n            with ExpectLog(gen_log, \".*\"):\n                yield websocket_connect(\n                    'ws://localhost:%d/' % port,\n                    io_loop=self.io_loop,\n                    connect_timeout=0.01)\n        self.assertEqual(cm.exception.code, 599)\n\n    @gen_test\n    def test_websocket_network_fail(self):\n        sock, port = bind_unused_port()\n        sock.close()\n        with self.assertRaises(HTTPError) as cm:\n            with ExpectLog(gen_log, \".*\"):\n                yield websocket_connect(\n                    'ws://localhost:%d/' % port,\n                    io_loop=self.io_loop,\n                    connect_timeout=3600)\n        self.assertEqual(cm.exception.code, 599)\n\n    @gen_test\n    def test_websocket_close_buffered_data(self):\n        ws = yield websocket_connect(\n            'ws://localhost:%d/echo' % self.get_http_port())\n        ws.write_message('hello')\n        ws.write_message('world')\n        ws.stream.close()\n        yield self.close_future\n\n    @gen_test\n    def test_websocket_headers(self):\n        # Ensure that arbitrary headers can be passed through websocket_connect.\n        ws = yield websocket_connect(\n            HTTPRequest('ws://localhost:%d/header' % self.get_http_port(),\n                        headers={'X-Test': 'hello'}))\n        response = yield ws.read_message()\n        self.assertEqual(response, 'hello')\n        ws.close()\n        yield self.close_future\n\n\nclass MaskFunctionMixin(object):\n    # Subclasses should define self.mask(mask, data)\n    def test_mask(self):\n        self.assertEqual(self.mask(b'abcd', b''), b'')\n        self.assertEqual(self.mask(b'abcd', b'b'), b'\\x03')\n        self.assertEqual(self.mask(b'abcd', b'54321'), b'TVPVP')\n        self.assertEqual(self.mask(b'ZXCV', b'98765432'), b'c`t`olpd')\n        # Include test cases with \\x00 bytes (to ensure that the C\n        # extension isn't depending on null-terminated strings) and\n        # bytes with the high bit set (to smoke out signedness issues).\n        self.assertEqual(self.mask(b'\\x00\\x01\\x02\\x03',\n                                   b'\\xff\\xfb\\xfd\\xfc\\xfe\\xfa'),\n                         b'\\xff\\xfa\\xff\\xff\\xfe\\xfb')\n        self.assertEqual(self.mask(b'\\xff\\xfb\\xfd\\xfc',\n                                   b'\\x00\\x01\\x02\\x03\\x04\\x05'),\n                         b'\\xff\\xfa\\xff\\xff\\xfb\\xfe')\n\n\nclass PythonMaskFunctionTest(MaskFunctionMixin, unittest.TestCase):\n    def mask(self, mask, data):\n        return _websocket_mask_python(mask, data)\n\n\n@unittest.skipIf(speedups is None, \"tornado.speedups module not present\")\nclass CythonMaskFunctionTest(MaskFunctionMixin, unittest.TestCase):\n    def mask(self, mask, data):\n        return speedups.websocket_mask(mask, data)\n", "\"\"\"Miscellaneous utility functions and classes.\n\nThis module is used internally by Tornado.  It is not necessarily expected\nthat the functions and classes defined here will be useful to other\napplications, but they are documented here in case they are.\n\nThe one public-facing part of this module is the `Configurable` class\nand its `~Configurable.configure` method, which becomes a part of the\ninterface of its subclasses, including `.AsyncHTTPClient`, `.IOLoop`,\nand `.Resolver`.\n\"\"\"\n\nfrom __future__ import absolute_import, division, print_function, with_statement\n\nimport array\nimport inspect\nimport os\nimport sys\nimport zlib\n\n\ntry:\n    xrange  # py2\nexcept NameError:\n    xrange = range  # py3\n\n\nclass ObjectDict(dict):\n    \"\"\"Makes a dictionary behave like an object, with attribute-style access.\n    \"\"\"\n    def __getattr__(self, name):\n        try:\n            return self[name]\n        except KeyError:\n            raise AttributeError(name)\n\n    def __setattr__(self, name, value):\n        self[name] = value\n\n\nclass GzipDecompressor(object):\n    \"\"\"Streaming gzip decompressor.\n\n    The interface is like that of `zlib.decompressobj` (without the\n    optional arguments, but it understands gzip headers and checksums.\n    \"\"\"\n    def __init__(self):\n        # Magic parameter makes zlib module understand gzip header\n        # http://stackoverflow.com/questions/1838699/how-can-i-decompress-a-gzip-stream-with-zlib\n        # This works on cpython and pypy, but not jython.\n        self.decompressobj = zlib.decompressobj(16 + zlib.MAX_WBITS)\n\n    def decompress(self, value):\n        \"\"\"Decompress a chunk, returning newly-available data.\n\n        Some data may be buffered for later processing; `flush` must\n        be called when there is no more input data to ensure that\n        all data was processed.\n        \"\"\"\n        return self.decompressobj.decompress(value)\n\n    def flush(self):\n        \"\"\"Return any remaining buffered data not yet returned by decompress.\n\n        Also checks for errors such as truncated input.\n        No other methods may be called on this object after `flush`.\n        \"\"\"\n        return self.decompressobj.flush()\n\n\ndef import_object(name):\n    \"\"\"Imports an object by name.\n\n    import_object('x') is equivalent to 'import x'.\n    import_object('x.y.z') is equivalent to 'from x.y import z'.\n\n    >>> import tornado.escape\n    >>> import_object('tornado.escape') is tornado.escape\n    True\n    >>> import_object('tornado.escape.utf8') is tornado.escape.utf8\n    True\n    >>> import_object('tornado') is tornado\n    True\n    >>> import_object('tornado.missing_module')\n    Traceback (most recent call last):\n        ...\n    ImportError: No module named missing_module\n    \"\"\"\n    if name.count('.') == 0:\n        return __import__(name, None, None)\n\n    parts = name.split('.')\n    obj = __import__('.'.join(parts[:-1]), None, None, [parts[-1]], 0)\n    try:\n        return getattr(obj, parts[-1])\n    except AttributeError:\n        raise ImportError(\"No module named %s\" % parts[-1])\n\n\n# Fake unicode literal support:  Python 3.2 doesn't have the u'' marker for\n# literal strings, and alternative solutions like \"from __future__ import\n# unicode_literals\" have other problems (see PEP 414).  u() can be applied\n# to ascii strings that include \\u escapes (but they must not contain\n# literal non-ascii characters).\nif type('') is not type(b''):\n    def u(s):\n        return s\n    bytes_type = bytes\n    unicode_type = str\n    basestring_type = str\nelse:\n    def u(s):\n        return s.decode('unicode_escape')\n    bytes_type = str\n    unicode_type = unicode\n    basestring_type = basestring\n\n\nif sys.version_info > (3,):\n    exec(\"\"\"\ndef raise_exc_info(exc_info):\n    raise exc_info[1].with_traceback(exc_info[2])\n\ndef exec_in(code, glob, loc=None):\n    if isinstance(code, str):\n        code = compile(code, '<string>', 'exec', dont_inherit=True)\n    exec(code, glob, loc)\n\"\"\")\nelse:\n    exec(\"\"\"\ndef raise_exc_info(exc_info):\n    raise exc_info[0], exc_info[1], exc_info[2]\n\ndef exec_in(code, glob, loc=None):\n    if isinstance(code, basestring):\n        # exec(string) inherits the caller's future imports; compile\n        # the string first to prevent that.\n        code = compile(code, '<string>', 'exec', dont_inherit=True)\n    exec code in glob, loc\n\"\"\")\n\n\nclass Configurable(object):\n    \"\"\"Base class for configurable interfaces.\n\n    A configurable interface is an (abstract) class whose constructor\n    acts as a factory function for one of its implementation subclasses.\n    The implementation subclass as well as optional keyword arguments to\n    its initializer can be set globally at runtime with `configure`.\n\n    By using the constructor as the factory method, the interface\n    looks like a normal class, `isinstance` works as usual, etc.  This\n    pattern is most useful when the choice of implementation is likely\n    to be a global decision (e.g. when `~select.epoll` is available,\n    always use it instead of `~select.select`), or when a\n    previously-monolithic class has been split into specialized\n    subclasses.\n\n    Configurable subclasses must define the class methods\n    `configurable_base` and `configurable_default`, and use the instance\n    method `initialize` instead of ``__init__``.\n    \"\"\"\n    __impl_class = None\n    __impl_kwargs = None\n\n    def __new__(cls, **kwargs):\n        base = cls.configurable_base()\n        args = {}\n        if cls is base:\n            impl = cls.configured_class()\n            if base.__impl_kwargs:\n                args.update(base.__impl_kwargs)\n        else:\n            impl = cls\n        args.update(kwargs)\n        instance = super(Configurable, cls).__new__(impl)\n        # initialize vs __init__ chosen for compatiblity with AsyncHTTPClient\n        # singleton magic.  If we get rid of that we can switch to __init__\n        # here too.\n        instance.initialize(**args)\n        return instance\n\n    @classmethod\n    def configurable_base(cls):\n        \"\"\"Returns the base class of a configurable hierarchy.\n\n        This will normally return the class in which it is defined.\n        (which is *not* necessarily the same as the cls classmethod parameter).\n        \"\"\"\n        raise NotImplementedError()\n\n    @classmethod\n    def configurable_default(cls):\n        \"\"\"Returns the implementation class to be used if none is configured.\"\"\"\n        raise NotImplementedError()\n\n    def initialize(self):\n        \"\"\"Initialize a `Configurable` subclass instance.\n\n        Configurable classes should use `initialize` instead of ``__init__``.\n        \"\"\"\n\n    @classmethod\n    def configure(cls, impl, **kwargs):\n        \"\"\"Sets the class to use when the base class is instantiated.\n\n        Keyword arguments will be saved and added to the arguments passed\n        to the constructor.  This can be used to set global defaults for\n        some parameters.\n        \"\"\"\n        base = cls.configurable_base()\n        if isinstance(impl, (unicode_type, bytes_type)):\n            impl = import_object(impl)\n        if impl is not None and not issubclass(impl, cls):\n            raise ValueError(\"Invalid subclass of %s\" % cls)\n        base.__impl_class = impl\n        base.__impl_kwargs = kwargs\n\n    @classmethod\n    def configured_class(cls):\n        \"\"\"Returns the currently configured class.\"\"\"\n        base = cls.configurable_base()\n        if cls.__impl_class is None:\n            base.__impl_class = cls.configurable_default()\n        return base.__impl_class\n\n    @classmethod\n    def _save_configuration(cls):\n        base = cls.configurable_base()\n        return (base.__impl_class, base.__impl_kwargs)\n\n    @classmethod\n    def _restore_configuration(cls, saved):\n        base = cls.configurable_base()\n        base.__impl_class = saved[0]\n        base.__impl_kwargs = saved[1]\n\n\nclass ArgReplacer(object):\n    \"\"\"Replaces one value in an ``args, kwargs`` pair.\n\n    Inspects the function signature to find an argument by name\n    whether it is passed by position or keyword.  For use in decorators\n    and similar wrappers.\n    \"\"\"\n    def __init__(self, func, name):\n        self.name = name\n        try:\n            self.arg_pos = inspect.getargspec(func).args.index(self.name)\n        except ValueError:\n            # Not a positional parameter\n            self.arg_pos = None\n\n    def replace(self, new_value, args, kwargs):\n        \"\"\"Replace the named argument in ``args, kwargs`` with ``new_value``.\n\n        Returns ``(old_value, args, kwargs)``.  The returned ``args`` and\n        ``kwargs`` objects may not be the same as the input objects, or\n        the input objects may be mutated.\n\n        If the named argument was not found, ``new_value`` will be added\n        to ``kwargs`` and None will be returned as ``old_value``.\n        \"\"\"\n        if self.arg_pos is not None and len(args) > self.arg_pos:\n            # The arg to replace is passed positionally\n            old_value = args[self.arg_pos]\n            args = list(args)  # *args is normally a tuple\n            args[self.arg_pos] = new_value\n        else:\n            # The arg to replace is either omitted or passed by keyword.\n            old_value = kwargs.get(self.name)\n            kwargs[self.name] = new_value\n        return old_value, args, kwargs\n\n\ndef _websocket_mask_python(mask, data):\n    \"\"\"Websocket masking function.\n\n    `mask` is a `bytes` object of length 4; `data` is a `bytes` object of any length.\n    Returns a `bytes` object of the same length as `data` with the mask applied\n    as specified in section 5.3 of RFC 6455.\n\n    This pure-python implementation may be replaced by an optimized version when available.\n    \"\"\"\n    mask = array.array(\"B\", mask)\n    unmasked = array.array(\"B\", data)\n    for i in xrange(len(data)):\n        unmasked[i] = unmasked[i] ^ mask[i % 4]\n    if hasattr(unmasked, 'tobytes'):\n        # tostring was deprecated in py32.  It hasn't been removed,\n        # but since we turn on deprecation warnings in our tests\n        # we need to use the right one.\n        return unmasked.tobytes()\n    else:\n        return unmasked.tostring()\n\nif (os.environ.get('TORNADO_NO_EXTENSION') or\n    os.environ.get('TORNADO_EXTENSION') == '0'):\n    # These environment variables exist to make it easier to do performance\n    # comparisons; they are not guaranteed to remain supported in the future.\n    _websocket_mask = _websocket_mask_python\nelse:\n    try:\n        from tornado.speedups import websocket_mask as _websocket_mask\n    except ImportError:\n        if os.environ.get('TORNADO_EXTENSION') == '1':\n            raise\n        _websocket_mask = _websocket_mask_python\n\n\ndef doctests():\n    import doctest\n    return doctest.DocTestSuite()\n", "#!/usr/bin/env python\n#\n# Copyright 2009 Facebook\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\n\"\"\"``tornado.web`` provides a simple web framework with asynchronous\nfeatures that allow it to scale to large numbers of open connections,\nmaking it ideal for `long polling\n<http://en.wikipedia.org/wiki/Push_technology#Long_polling>`_.\n\nHere is a simple \"Hello, world\" example app::\n\n    import tornado.ioloop\n    import tornado.web\n\n    class MainHandler(tornado.web.RequestHandler):\n        def get(self):\n            self.write(\"Hello, world\")\n\n    if __name__ == \"__main__\":\n        application = tornado.web.Application([\n            (r\"/\", MainHandler),\n        ])\n        application.listen(8888)\n        tornado.ioloop.IOLoop.instance().start()\n\nSee the :doc:`Tornado overview <overview>` for more details and a good getting\nstarted guide.\n\nThread-safety notes\n-------------------\n\nIn general, methods on `RequestHandler` and elsewhere in Tornado are\nnot thread-safe.  In particular, methods such as\n`~RequestHandler.write()`, `~RequestHandler.finish()`, and\n`~RequestHandler.flush()` must only be called from the main thread.  If\nyou use multiple threads it is important to use `.IOLoop.add_callback`\nto transfer control back to the main thread before finishing the\nrequest.\n\"\"\"\n\nfrom __future__ import absolute_import, division, print_function, with_statement\n\n\nimport base64\nimport binascii\nimport datetime\nimport email.utils\nimport functools\nimport gzip\nimport hashlib\nimport hmac\nimport mimetypes\nimport numbers\nimport os.path\nimport re\nimport stat\nimport sys\nimport threading\nimport time\nimport tornado\nimport traceback\nimport types\n\nfrom tornado.concurrent import Future\nfrom tornado import escape\nfrom tornado import httputil\nfrom tornado import locale\nfrom tornado.log import access_log, app_log, gen_log\nfrom tornado import stack_context\nfrom tornado import template\nfrom tornado.escape import utf8, _unicode\nfrom tornado.util import bytes_type, import_object, ObjectDict, raise_exc_info, unicode_type, _websocket_mask\n\ntry:\n    from io import BytesIO  # python 3\nexcept ImportError:\n    from cStringIO import StringIO as BytesIO  # python 2\n\ntry:\n    import Cookie  # py2\nexcept ImportError:\n    import http.cookies as Cookie  # py3\n\ntry:\n    import urlparse  # py2\nexcept ImportError:\n    import urllib.parse as urlparse  # py3\n\ntry:\n    from urllib import urlencode  # py2\nexcept ImportError:\n    from urllib.parse import urlencode  # py3\n\n\nMIN_SUPPORTED_SIGNED_VALUE_VERSION = 1\n\"\"\"The oldest signed value version supported by this version of Tornado.\n\nSigned values older than this version cannot be decoded.\n\n.. versionadded:: 3.2.1\n\"\"\"\n\nMAX_SUPPORTED_SIGNED_VALUE_VERSION = 2\n\"\"\"The newest signed value version supported by this version of Tornado.\n\nSigned values newer than this version cannot be decoded.\n\n.. versionadded:: 3.2.1\n\"\"\"\n\nDEFAULT_SIGNED_VALUE_VERSION = 2\n\"\"\"The signed value version produced by `.RequestHandler.create_signed_value`.\n\nMay be overridden by passing a ``version`` keyword argument.\n\n.. versionadded:: 3.2.1\n\"\"\"\n\nDEFAULT_SIGNED_VALUE_MIN_VERSION = 1\n\"\"\"The oldest signed value accepted by `.RequestHandler.get_secure_cookie`.\n\nMay be overrided by passing a ``min_version`` keyword argument.\n\n.. versionadded:: 3.2.1\n\"\"\"\n\n\nclass RequestHandler(object):\n    \"\"\"Subclass this class and define `get()` or `post()` to make a handler.\n\n    If you want to support more methods than the standard GET/HEAD/POST, you\n    should override the class variable ``SUPPORTED_METHODS`` in your\n    `RequestHandler` subclass.\n    \"\"\"\n    SUPPORTED_METHODS = (\"GET\", \"HEAD\", \"POST\", \"DELETE\", \"PATCH\", \"PUT\",\n                         \"OPTIONS\")\n\n    _template_loaders = {}  # {path: template.BaseLoader}\n    _template_loader_lock = threading.Lock()\n    _remove_control_chars_regex = re.compile(r\"[\\x00-\\x08\\x0e-\\x1f]\")\n\n    def __init__(self, application, request, **kwargs):\n        super(RequestHandler, self).__init__()\n\n        self.application = application\n        self.request = request\n        self._headers_written = False\n        self._finished = False\n        self._auto_finish = True\n        self._transforms = None  # will be set in _execute\n        self.path_args = None\n        self.path_kwargs = None\n        self.ui = ObjectDict((n, self._ui_method(m)) for n, m in\n                             application.ui_methods.items())\n        # UIModules are available as both `modules` and `_tt_modules` in the\n        # template namespace.  Historically only `modules` was available\n        # but could be clobbered by user additions to the namespace.\n        # The template {% module %} directive looks in `_tt_modules` to avoid\n        # possible conflicts.\n        self.ui[\"_tt_modules\"] = _UIModuleNamespace(self,\n                                                    application.ui_modules)\n        self.ui[\"modules\"] = self.ui[\"_tt_modules\"]\n        self.clear()\n        # Check since connection is not available in WSGI\n        if getattr(self.request, \"connection\", None):\n            self.request.connection.set_close_callback(\n                self.on_connection_close)\n        self.initialize(**kwargs)\n\n    def initialize(self):\n        \"\"\"Hook for subclass initialization.\n\n        A dictionary passed as the third argument of a url spec will be\n        supplied as keyword arguments to initialize().\n\n        Example::\n\n            class ProfileHandler(RequestHandler):\n                def initialize(self, database):\n                    self.database = database\n\n                def get(self, username):\n                    ...\n\n            app = Application([\n                (r'/user/(.*)', ProfileHandler, dict(database=database)),\n                ])\n        \"\"\"\n        pass\n\n    @property\n    def settings(self):\n        \"\"\"An alias for `self.application.settings <Application.settings>`.\"\"\"\n        return self.application.settings\n\n    def head(self, *args, **kwargs):\n        raise HTTPError(405)\n\n    def get(self, *args, **kwargs):\n        raise HTTPError(405)\n\n    def post(self, *args, **kwargs):\n        raise HTTPError(405)\n\n    def delete(self, *args, **kwargs):\n        raise HTTPError(405)\n\n    def patch(self, *args, **kwargs):\n        raise HTTPError(405)\n\n    def put(self, *args, **kwargs):\n        raise HTTPError(405)\n\n    def options(self, *args, **kwargs):\n        raise HTTPError(405)\n\n    def prepare(self):\n        \"\"\"Called at the beginning of a request before  `get`/`post`/etc.\n\n        Override this method to perform common initialization regardless\n        of the request method.\n\n        Asynchronous support: Decorate this method with `.gen.coroutine`\n        or `.return_future` to make it asynchronous (the\n        `asynchronous` decorator cannot be used on `prepare`).\n        If this method returns a `.Future` execution will not proceed\n        until the `.Future` is done.\n\n        .. versionadded:: 3.1\n           Asynchronous support.\n        \"\"\"\n        pass\n\n    def on_finish(self):\n        \"\"\"Called after the end of a request.\n\n        Override this method to perform cleanup, logging, etc.\n        This method is a counterpart to `prepare`.  ``on_finish`` may\n        not produce any output, as it is called after the response\n        has been sent to the client.\n        \"\"\"\n        pass\n\n    def on_connection_close(self):\n        \"\"\"Called in async handlers if the client closed the connection.\n\n        Override this to clean up resources associated with\n        long-lived connections.  Note that this method is called only if\n        the connection was closed during asynchronous processing; if you\n        need to do cleanup after every request override `on_finish`\n        instead.\n\n        Proxies may keep a connection open for a time (perhaps\n        indefinitely) after the client has gone away, so this method\n        may not be called promptly after the end user closes their\n        connection.\n        \"\"\"\n        pass\n\n    def clear(self):\n        \"\"\"Resets all headers and content for this response.\"\"\"\n        self._headers = httputil.HTTPHeaders({\n            \"Server\": \"TornadoServer/%s\" % tornado.version,\n            \"Content-Type\": \"text/html; charset=UTF-8\",\n            \"Date\": httputil.format_timestamp(time.time()),\n        })\n        self.set_default_headers()\n        if (not self.request.supports_http_1_1() and\n            getattr(self.request, 'connection', None) and\n                not self.request.connection.no_keep_alive):\n            conn_header = self.request.headers.get(\"Connection\")\n            if conn_header and (conn_header.lower() == \"keep-alive\"):\n                self._headers[\"Connection\"] = \"Keep-Alive\"\n        self._write_buffer = []\n        self._status_code = 200\n        self._reason = httputil.responses[200]\n\n    def set_default_headers(self):\n        \"\"\"Override this to set HTTP headers at the beginning of the request.\n\n        For example, this is the place to set a custom ``Server`` header.\n        Note that setting such headers in the normal flow of request\n        processing may not do what you want, since headers may be reset\n        during error handling.\n        \"\"\"\n        pass\n\n    def set_status(self, status_code, reason=None):\n        \"\"\"Sets the status code for our response.\n\n        :arg int status_code: Response status code. If ``reason`` is ``None``,\n            it must be present in `httplib.responses <http.client.responses>`.\n        :arg string reason: Human-readable reason phrase describing the status\n            code. If ``None``, it will be filled in from\n            `httplib.responses <http.client.responses>`.\n        \"\"\"\n        self._status_code = status_code\n        if reason is not None:\n            self._reason = escape.native_str(reason)\n        else:\n            try:\n                self._reason = httputil.responses[status_code]\n            except KeyError:\n                raise ValueError(\"unknown status code %d\", status_code)\n\n    def get_status(self):\n        \"\"\"Returns the status code for our response.\"\"\"\n        return self._status_code\n\n    def set_header(self, name, value):\n        \"\"\"Sets the given response header name and value.\n\n        If a datetime is given, we automatically format it according to the\n        HTTP specification. If the value is not a string, we convert it to\n        a string. All header values are then encoded as UTF-8.\n        \"\"\"\n        self._headers[name] = self._convert_header_value(value)\n\n    def add_header(self, name, value):\n        \"\"\"Adds the given response header and value.\n\n        Unlike `set_header`, `add_header` may be called multiple times\n        to return multiple values for the same header.\n        \"\"\"\n        self._headers.add(name, self._convert_header_value(value))\n\n    def clear_header(self, name):\n        \"\"\"Clears an outgoing header, undoing a previous `set_header` call.\n\n        Note that this method does not apply to multi-valued headers\n        set by `add_header`.\n        \"\"\"\n        if name in self._headers:\n            del self._headers[name]\n\n    _INVALID_HEADER_CHAR_RE = re.compile(br\"[\\x00-\\x1f]\")\n\n    def _convert_header_value(self, value):\n        if isinstance(value, bytes_type):\n            pass\n        elif isinstance(value, unicode_type):\n            value = value.encode('utf-8')\n        elif isinstance(value, numbers.Integral):\n            # return immediately since we know the converted value will be safe\n            return str(value)\n        elif isinstance(value, datetime.datetime):\n            return httputil.format_timestamp(value)\n        else:\n            raise TypeError(\"Unsupported header value %r\" % value)\n        # If \\n is allowed into the header, it is possible to inject\n        # additional headers or split the request. Also cap length to\n        # prevent obviously erroneous values.\n        if (len(value) > 4000 or\n                RequestHandler._INVALID_HEADER_CHAR_RE.search(value)):\n            raise ValueError(\"Unsafe header value %r\", value)\n        return value\n\n    _ARG_DEFAULT = []\n\n    def get_argument(self, name, default=_ARG_DEFAULT, strip=True):\n        \"\"\"Returns the value of the argument with the given name.\n\n        If default is not provided, the argument is considered to be\n        required, and we raise a `MissingArgumentError` if it is missing.\n\n        If the argument appears in the url more than once, we return the\n        last value.\n\n        The returned value is always unicode.\n        \"\"\"\n        return self._get_argument(name, default, self.request.arguments, strip)\n\n    def get_arguments(self, name, strip=True):\n        \"\"\"Returns a list of the arguments with the given name.\n\n        If the argument is not present, returns an empty list.\n\n        The returned values are always unicode.\n        \"\"\"\n        return self._get_arguments(name, self.request.arguments, strip)\n\n    def get_body_argument(self, name, default=_ARG_DEFAULT, strip=True):\n        \"\"\"Returns the value of the argument with the given name\n        from the request body.\n\n        If default is not provided, the argument is considered to be\n        required, and we raise a `MissingArgumentError` if it is missing.\n\n        If the argument appears in the url more than once, we return the\n        last value.\n\n        The returned value is always unicode.\n\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_argument(name, default, self.request.body_arguments, strip)\n\n    def get_body_arguments(self, name, strip=True):\n        \"\"\"Returns a list of the body arguments with the given name.\n\n        If the argument is not present, returns an empty list.\n\n        The returned values are always unicode.\n\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_arguments(name, self.request.body_arguments, strip)\n\n    def get_query_argument(self, name, default=_ARG_DEFAULT, strip=True):\n        \"\"\"Returns the value of the argument with the given name\n        from the request query string.\n\n        If default is not provided, the argument is considered to be\n        required, and we raise a `MissingArgumentError` if it is missing.\n\n        If the argument appears in the url more than once, we return the\n        last value.\n\n        The returned value is always unicode.\n\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_argument(name, default, self.request.query_arguments, strip)\n\n    def get_query_arguments(self, name, strip=True):\n        \"\"\"Returns a list of the query arguments with the given name.\n\n        If the argument is not present, returns an empty list.\n\n        The returned values are always unicode.\n\n        .. versionadded:: 3.2\n        \"\"\"\n        return self._get_arguments(name, self.request.query_arguments, strip)\n\n    def _get_argument(self, name, default, source, strip=True):\n        args = self._get_arguments(name, source, strip=strip)\n        if not args:\n            if default is self._ARG_DEFAULT:\n                raise MissingArgumentError(name)\n            return default\n        return args[-1]\n\n    def _get_arguments(self, name, source, strip=True):\n        values = []\n        for v in source.get(name, []):\n            v = self.decode_argument(v, name=name)\n            if isinstance(v, unicode_type):\n                # Get rid of any weird control chars (unless decoding gave\n                # us bytes, in which case leave it alone)\n                v = RequestHandler._remove_control_chars_regex.sub(\" \", v)\n            if strip:\n                v = v.strip()\n            values.append(v)\n        return values\n\n    def decode_argument(self, value, name=None):\n        \"\"\"Decodes an argument from the request.\n\n        The argument has been percent-decoded and is now a byte string.\n        By default, this method decodes the argument as utf-8 and returns\n        a unicode string, but this may be overridden in subclasses.\n\n        This method is used as a filter for both `get_argument()` and for\n        values extracted from the url and passed to `get()`/`post()`/etc.\n\n        The name of the argument is provided if known, but may be None\n        (e.g. for unnamed groups in the url regex).\n        \"\"\"\n        try:\n            return _unicode(value)\n        except UnicodeDecodeError:\n            raise HTTPError(400, \"Invalid unicode in %s: %r\" %\n                            (name or \"url\", value[:40]))\n\n    @property\n    def cookies(self):\n        \"\"\"An alias for `self.request.cookies <.httpserver.HTTPRequest.cookies>`.\"\"\"\n        return self.request.cookies\n\n    def get_cookie(self, name, default=None):\n        \"\"\"Gets the value of the cookie with the given name, else default.\"\"\"\n        if self.request.cookies is not None and name in self.request.cookies:\n            return self.request.cookies[name].value\n        return default\n\n    def set_cookie(self, name, value, domain=None, expires=None, path=\"/\",\n                   expires_days=None, **kwargs):\n        \"\"\"Sets the given cookie name/value with the given options.\n\n        Additional keyword arguments are set on the Cookie.Morsel\n        directly.\n        See http://docs.python.org/library/cookie.html#morsel-objects\n        for available attributes.\n        \"\"\"\n        # The cookie library only accepts type str, in both python 2 and 3\n        name = escape.native_str(name)\n        value = escape.native_str(value)\n        if re.search(r\"[\\x00-\\x20]\", name + value):\n            # Don't let us accidentally inject bad stuff\n            raise ValueError(\"Invalid cookie %r: %r\" % (name, value))\n        if not hasattr(self, \"_new_cookie\"):\n            self._new_cookie = Cookie.SimpleCookie()\n        if name in self._new_cookie:\n            del self._new_cookie[name]\n        self._new_cookie[name] = value\n        morsel = self._new_cookie[name]\n        if domain:\n            morsel[\"domain\"] = domain\n        if expires_days is not None and not expires:\n            expires = datetime.datetime.utcnow() + datetime.timedelta(\n                days=expires_days)\n        if expires:\n            morsel[\"expires\"] = httputil.format_timestamp(expires)\n        if path:\n            morsel[\"path\"] = path\n        for k, v in kwargs.items():\n            if k == 'max_age':\n                k = 'max-age'\n            morsel[k] = v\n\n    def clear_cookie(self, name, path=\"/\", domain=None):\n        \"\"\"Deletes the cookie with the given name.\n\n        Due to limitations of the cookie protocol, you must pass the same\n        path and domain to clear a cookie as were used when that cookie\n        was set (but there is no way to find out on the server side\n        which values were used for a given cookie).\n        \"\"\"\n        expires = datetime.datetime.utcnow() - datetime.timedelta(days=365)\n        self.set_cookie(name, value=\"\", path=path, expires=expires,\n                        domain=domain)\n\n    def clear_all_cookies(self, path=\"/\", domain=None):\n        \"\"\"Deletes all the cookies the user sent with this request.\n\n        See `clear_cookie` for more information on the path and domain\n        parameters.\n\n        .. versionchanged:: 3.2\n\n           Added the ``path`` and ``domain`` parameters.\n        \"\"\"\n        for name in self.request.cookies:\n            self.clear_cookie(name, path=path, domain=domain)\n\n    def set_secure_cookie(self, name, value, expires_days=30, version=None,\n                          **kwargs):\n        \"\"\"Signs and timestamps a cookie so it cannot be forged.\n\n        You must specify the ``cookie_secret`` setting in your Application\n        to use this method. It should be a long, random sequence of bytes\n        to be used as the HMAC secret for the signature.\n\n        To read a cookie set with this method, use `get_secure_cookie()`.\n\n        Note that the ``expires_days`` parameter sets the lifetime of the\n        cookie in the browser, but is independent of the ``max_age_days``\n        parameter to `get_secure_cookie`.\n\n        Secure cookies may contain arbitrary byte values, not just unicode\n        strings (unlike regular cookies)\n\n        .. versionchanged:: 3.2.1\n\n           Added the ``version`` argument.  Introduced cookie version 2\n           and made it the default.\n        \"\"\"\n        self.set_cookie(name, self.create_signed_value(name, value,\n                                                       version=version),\n                        expires_days=expires_days, **kwargs)\n\n    def create_signed_value(self, name, value, version=None):\n        \"\"\"Signs and timestamps a string so it cannot be forged.\n\n        Normally used via set_secure_cookie, but provided as a separate\n        method for non-cookie uses.  To decode a value not stored\n        as a cookie use the optional value argument to get_secure_cookie.\n\n        .. versionchanged:: 3.2.1\n\n           Added the ``version`` argument.  Introduced cookie version 2\n           and made it the default.\n        \"\"\"\n        self.require_setting(\"cookie_secret\", \"secure cookies\")\n        return create_signed_value(self.application.settings[\"cookie_secret\"],\n                                   name, value, version=version)\n\n    def get_secure_cookie(self, name, value=None, max_age_days=31,\n                          min_version=None):\n        \"\"\"Returns the given signed cookie if it validates, or None.\n\n        The decoded cookie value is returned as a byte string (unlike\n        `get_cookie`).\n\n        .. versionchanged:: 3.2.1\n\n           Added the ``min_version`` argument.  Introduced cookie version 2;\n           both versions 1 and 2 are accepted by default.\n        \"\"\"\n        self.require_setting(\"cookie_secret\", \"secure cookies\")\n        if value is None:\n            value = self.get_cookie(name)\n        return decode_signed_value(self.application.settings[\"cookie_secret\"],\n                                   name, value, max_age_days=max_age_days,\n                                   min_version=min_version)\n\n    def redirect(self, url, permanent=False, status=None):\n        \"\"\"Sends a redirect to the given (optionally relative) URL.\n\n        If the ``status`` argument is specified, that value is used as the\n        HTTP status code; otherwise either 301 (permanent) or 302\n        (temporary) is chosen based on the ``permanent`` argument.\n        The default is 302 (temporary).\n        \"\"\"\n        if self._headers_written:\n            raise Exception(\"Cannot redirect after headers have been written\")\n        if status is None:\n            status = 301 if permanent else 302\n        else:\n            assert isinstance(status, int) and 300 <= status <= 399\n        self.set_status(status)\n        self.set_header(\"Location\", urlparse.urljoin(utf8(self.request.uri),\n                                                     utf8(url)))\n        self.finish()\n\n    def write(self, chunk):\n        \"\"\"Writes the given chunk to the output buffer.\n\n        To write the output to the network, use the flush() method below.\n\n        If the given chunk is a dictionary, we write it as JSON and set\n        the Content-Type of the response to be ``application/json``.\n        (if you want to send JSON as a different ``Content-Type``, call\n        set_header *after* calling write()).\n\n        Note that lists are not converted to JSON because of a potential\n        cross-site security vulnerability.  All JSON output should be\n        wrapped in a dictionary.  More details at\n        http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx\n        \"\"\"\n        if self._finished:\n            raise RuntimeError(\"Cannot write() after finish().  May be caused \"\n                               \"by using async operations without the \"\n                               \"@asynchronous decorator.\")\n        if isinstance(chunk, dict):\n            chunk = escape.json_encode(chunk)\n            self.set_header(\"Content-Type\", \"application/json; charset=UTF-8\")\n        chunk = utf8(chunk)\n        self._write_buffer.append(chunk)\n\n    def render(self, template_name, **kwargs):\n        \"\"\"Renders the template with the given arguments as the response.\"\"\"\n        html = self.render_string(template_name, **kwargs)\n\n        # Insert the additional JS and CSS added by the modules on the page\n        js_embed = []\n        js_files = []\n        css_embed = []\n        css_files = []\n        html_heads = []\n        html_bodies = []\n        for module in getattr(self, \"_active_modules\", {}).values():\n            embed_part = module.embedded_javascript()\n            if embed_part:\n                js_embed.append(utf8(embed_part))\n            file_part = module.javascript_files()\n            if file_part:\n                if isinstance(file_part, (unicode_type, bytes_type)):\n                    js_files.append(file_part)\n                else:\n                    js_files.extend(file_part)\n            embed_part = module.embedded_css()\n            if embed_part:\n                css_embed.append(utf8(embed_part))\n            file_part = module.css_files()\n            if file_part:\n                if isinstance(file_part, (unicode_type, bytes_type)):\n                    css_files.append(file_part)\n                else:\n                    css_files.extend(file_part)\n            head_part = module.html_head()\n            if head_part:\n                html_heads.append(utf8(head_part))\n            body_part = module.html_body()\n            if body_part:\n                html_bodies.append(utf8(body_part))\n\n        def is_absolute(path):\n            return any(path.startswith(x) for x in [\"/\", \"http:\", \"https:\"])\n        if js_files:\n            # Maintain order of JavaScript files given by modules\n            paths = []\n            unique_paths = set()\n            for path in js_files:\n                if not is_absolute(path):\n                    path = self.static_url(path)\n                if path not in unique_paths:\n                    paths.append(path)\n                    unique_paths.add(path)\n            js = ''.join('<script src=\"' + escape.xhtml_escape(p) +\n                         '\" type=\"text/javascript\"></script>'\n                         for p in paths)\n            sloc = html.rindex(b'</body>')\n            html = html[:sloc] + utf8(js) + b'\\n' + html[sloc:]\n        if js_embed:\n            js = b'<script type=\"text/javascript\">\\n//<![CDATA[\\n' + \\\n                b'\\n'.join(js_embed) + b'\\n//]]>\\n</script>'\n            sloc = html.rindex(b'</body>')\n            html = html[:sloc] + js + b'\\n' + html[sloc:]\n        if css_files:\n            paths = []\n            unique_paths = set()\n            for path in css_files:\n                if not is_absolute(path):\n                    path = self.static_url(path)\n                if path not in unique_paths:\n                    paths.append(path)\n                    unique_paths.add(path)\n            css = ''.join('<link href=\"' + escape.xhtml_escape(p) + '\" '\n                          'type=\"text/css\" rel=\"stylesheet\"/>'\n                          for p in paths)\n            hloc = html.index(b'</head>')\n            html = html[:hloc] + utf8(css) + b'\\n' + html[hloc:]\n        if css_embed:\n            css = b'<style type=\"text/css\">\\n' + b'\\n'.join(css_embed) + \\\n                b'\\n</style>'\n            hloc = html.index(b'</head>')\n            html = html[:hloc] + css + b'\\n' + html[hloc:]\n        if html_heads:\n            hloc = html.index(b'</head>')\n            html = html[:hloc] + b''.join(html_heads) + b'\\n' + html[hloc:]\n        if html_bodies:\n            hloc = html.index(b'</body>')\n            html = html[:hloc] + b''.join(html_bodies) + b'\\n' + html[hloc:]\n        self.finish(html)\n\n    def render_string(self, template_name, **kwargs):\n        \"\"\"Generate the given template with the given arguments.\n\n        We return the generated byte string (in utf8). To generate and\n        write a template as a response, use render() above.\n        \"\"\"\n        # If no template_path is specified, use the path of the calling file\n        template_path = self.get_template_path()\n        if not template_path:\n            frame = sys._getframe(0)\n            web_file = frame.f_code.co_filename\n            while frame.f_code.co_filename == web_file:\n                frame = frame.f_back\n            template_path = os.path.dirname(frame.f_code.co_filename)\n        with RequestHandler._template_loader_lock:\n            if template_path not in RequestHandler._template_loaders:\n                loader = self.create_template_loader(template_path)\n                RequestHandler._template_loaders[template_path] = loader\n            else:\n                loader = RequestHandler._template_loaders[template_path]\n        t = loader.load(template_name)\n        namespace = self.get_template_namespace()\n        namespace.update(kwargs)\n        return t.generate(**namespace)\n\n    def get_template_namespace(self):\n        \"\"\"Returns a dictionary to be used as the default template namespace.\n\n        May be overridden by subclasses to add or modify values.\n\n        The results of this method will be combined with additional\n        defaults in the `tornado.template` module and keyword arguments\n        to `render` or `render_string`.\n        \"\"\"\n        namespace = dict(\n            handler=self,\n            request=self.request,\n            current_user=self.current_user,\n            locale=self.locale,\n            _=self.locale.translate,\n            static_url=self.static_url,\n            xsrf_form_html=self.xsrf_form_html,\n            reverse_url=self.reverse_url\n        )\n        namespace.update(self.ui)\n        return namespace\n\n    def create_template_loader(self, template_path):\n        \"\"\"Returns a new template loader for the given path.\n\n        May be overridden by subclasses.  By default returns a\n        directory-based loader on the given path, using the\n        ``autoescape`` application setting.  If a ``template_loader``\n        application setting is supplied, uses that instead.\n        \"\"\"\n        settings = self.application.settings\n        if \"template_loader\" in settings:\n            return settings[\"template_loader\"]\n        kwargs = {}\n        if \"autoescape\" in settings:\n            # autoescape=None means \"no escaping\", so we have to be sure\n            # to only pass this kwarg if the user asked for it.\n            kwargs[\"autoescape\"] = settings[\"autoescape\"]\n        return template.Loader(template_path, **kwargs)\n\n    def flush(self, include_footers=False, callback=None):\n        \"\"\"Flushes the current output buffer to the network.\n\n        The ``callback`` argument, if given, can be used for flow control:\n        it will be run when all flushed data has been written to the socket.\n        Note that only one flush callback can be outstanding at a time;\n        if another flush occurs before the previous flush's callback\n        has been run, the previous callback will be discarded.\n        \"\"\"\n        if self.application._wsgi:\n            # WSGI applications cannot usefully support flush, so just make\n            # it a no-op (and run the callback immediately).\n            if callback is not None:\n                callback()\n            return\n\n        chunk = b\"\".join(self._write_buffer)\n        self._write_buffer = []\n        if not self._headers_written:\n            self._headers_written = True\n            for transform in self._transforms:\n                self._status_code, self._headers, chunk = \\\n                    transform.transform_first_chunk(\n                        self._status_code, self._headers, chunk, include_footers)\n            headers = self._generate_headers()\n        else:\n            for transform in self._transforms:\n                chunk = transform.transform_chunk(chunk, include_footers)\n            headers = b\"\"\n\n        # Ignore the chunk and only write the headers for HEAD requests\n        if self.request.method == \"HEAD\":\n            if headers:\n                self.request.write(headers, callback=callback)\n            return\n\n        self.request.write(headers + chunk, callback=callback)\n\n    def finish(self, chunk=None):\n        \"\"\"Finishes this response, ending the HTTP request.\"\"\"\n        if self._finished:\n            raise RuntimeError(\"finish() called twice.  May be caused \"\n                               \"by using async operations without the \"\n                               \"@asynchronous decorator.\")\n\n        if chunk is not None:\n            self.write(chunk)\n\n        # Automatically support ETags and add the Content-Length header if\n        # we have not flushed any content yet.\n        if not self._headers_written:\n            if (self._status_code == 200 and\n                self.request.method in (\"GET\", \"HEAD\") and\n                    \"Etag\" not in self._headers):\n                self.set_etag_header()\n                if self.check_etag_header():\n                    self._write_buffer = []\n                    self.set_status(304)\n            if self._status_code == 304:\n                assert not self._write_buffer, \"Cannot send body with 304\"\n                self._clear_headers_for_304()\n            elif \"Content-Length\" not in self._headers:\n                content_length = sum(len(part) for part in self._write_buffer)\n                self.set_header(\"Content-Length\", content_length)\n\n        if hasattr(self.request, \"connection\"):\n            # Now that the request is finished, clear the callback we\n            # set on the HTTPConnection (which would otherwise prevent the\n            # garbage collection of the RequestHandler when there\n            # are keepalive connections)\n            self.request.connection.set_close_callback(None)\n\n        if not self.application._wsgi:\n            self.flush(include_footers=True)\n            self.request.finish()\n            self._log()\n        self._finished = True\n        self.on_finish()\n        # Break up a reference cycle between this handler and the\n        # _ui_module closures to allow for faster GC on CPython.\n        self.ui = None\n\n    def send_error(self, status_code=500, **kwargs):\n        \"\"\"Sends the given HTTP error code to the browser.\n\n        If `flush()` has already been called, it is not possible to send\n        an error, so this method will simply terminate the response.\n        If output has been written but not yet flushed, it will be discarded\n        and replaced with the error page.\n\n        Override `write_error()` to customize the error page that is returned.\n        Additional keyword arguments are passed through to `write_error`.\n        \"\"\"\n        if self._headers_written:\n            gen_log.error(\"Cannot send error response after headers written\")\n            if not self._finished:\n                self.finish()\n            return\n        self.clear()\n\n        reason = None\n        if 'exc_info' in kwargs:\n            exception = kwargs['exc_info'][1]\n            if isinstance(exception, HTTPError) and exception.reason:\n                reason = exception.reason\n        self.set_status(status_code, reason=reason)\n        try:\n            self.write_error(status_code, **kwargs)\n        except Exception:\n            app_log.error(\"Uncaught exception in write_error\", exc_info=True)\n        if not self._finished:\n            self.finish()\n\n    def write_error(self, status_code, **kwargs):\n        \"\"\"Override to implement custom error pages.\n\n        ``write_error`` may call `write`, `render`, `set_header`, etc\n        to produce output as usual.\n\n        If this error was caused by an uncaught exception (including\n        HTTPError), an ``exc_info`` triple will be available as\n        ``kwargs[\"exc_info\"]``.  Note that this exception may not be\n        the \"current\" exception for purposes of methods like\n        ``sys.exc_info()`` or ``traceback.format_exc``.\n\n        For historical reasons, if a method ``get_error_html`` exists,\n        it will be used instead of the default ``write_error`` implementation.\n        ``get_error_html`` returned a string instead of producing output\n        normally, and had different semantics for exception handling.\n        Users of ``get_error_html`` are encouraged to convert their code\n        to override ``write_error`` instead.\n        \"\"\"\n        if hasattr(self, 'get_error_html'):\n            if 'exc_info' in kwargs:\n                exc_info = kwargs.pop('exc_info')\n                kwargs['exception'] = exc_info[1]\n                try:\n                    # Put the traceback into sys.exc_info()\n                    raise_exc_info(exc_info)\n                except Exception:\n                    self.finish(self.get_error_html(status_code, **kwargs))\n            else:\n                self.finish(self.get_error_html(status_code, **kwargs))\n            return\n        if self.settings.get(\"serve_traceback\") and \"exc_info\" in kwargs:\n            # in debug mode, try to send a traceback\n            self.set_header('Content-Type', 'text/plain')\n            for line in traceback.format_exception(*kwargs[\"exc_info\"]):\n                self.write(line)\n            self.finish()\n        else:\n            self.finish(\"<html><title>%(code)d: %(message)s</title>\"\n                        \"<body>%(code)d: %(message)s</body></html>\" % {\n                            \"code\": status_code,\n                            \"message\": self._reason,\n                        })\n\n    @property\n    def locale(self):\n        \"\"\"The local for the current session.\n\n        Determined by either `get_user_locale`, which you can override to\n        set the locale based on, e.g., a user preference stored in a\n        database, or `get_browser_locale`, which uses the ``Accept-Language``\n        header.\n        \"\"\"\n        if not hasattr(self, \"_locale\"):\n            self._locale = self.get_user_locale()\n            if not self._locale:\n                self._locale = self.get_browser_locale()\n                assert self._locale\n        return self._locale\n\n    def get_user_locale(self):\n        \"\"\"Override to determine the locale from the authenticated user.\n\n        If None is returned, we fall back to `get_browser_locale()`.\n\n        This method should return a `tornado.locale.Locale` object,\n        most likely obtained via a call like ``tornado.locale.get(\"en\")``\n        \"\"\"\n        return None\n\n    def get_browser_locale(self, default=\"en_US\"):\n        \"\"\"Determines the user's locale from ``Accept-Language`` header.\n\n        See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4\n        \"\"\"\n        if \"Accept-Language\" in self.request.headers:\n            languages = self.request.headers[\"Accept-Language\"].split(\",\")\n            locales = []\n            for language in languages:\n                parts = language.strip().split(\";\")\n                if len(parts) > 1 and parts[1].startswith(\"q=\"):\n                    try:\n                        score = float(parts[1][2:])\n                    except (ValueError, TypeError):\n                        score = 0.0\n                else:\n                    score = 1.0\n                locales.append((parts[0], score))\n            if locales:\n                locales.sort(key=lambda pair: pair[1], reverse=True)\n                codes = [l[0] for l in locales]\n                return locale.get(*codes)\n        return locale.get(default)\n\n    @property\n    def current_user(self):\n        \"\"\"The authenticated user for this request.\n\n        This is a cached version of `get_current_user`, which you can\n        override to set the user based on, e.g., a cookie. If that\n        method is not overridden, this method always returns None.\n\n        We lazy-load the current user the first time this method is called\n        and cache the result after that.\n        \"\"\"\n        if not hasattr(self, \"_current_user\"):\n            self._current_user = self.get_current_user()\n        return self._current_user\n\n    @current_user.setter\n    def current_user(self, value):\n        self._current_user = value\n\n    def get_current_user(self):\n        \"\"\"Override to determine the current user from, e.g., a cookie.\"\"\"\n        return None\n\n    def get_login_url(self):\n        \"\"\"Override to customize the login URL based on the request.\n\n        By default, we use the ``login_url`` application setting.\n        \"\"\"\n        self.require_setting(\"login_url\", \"@tornado.web.authenticated\")\n        return self.application.settings[\"login_url\"]\n\n    def get_template_path(self):\n        \"\"\"Override to customize template path for each handler.\n\n        By default, we use the ``template_path`` application setting.\n        Return None to load templates relative to the calling file.\n        \"\"\"\n        return self.application.settings.get(\"template_path\")\n\n    @property\n    def xsrf_token(self):\n        \"\"\"The XSRF-prevention token for the current user/session.\n\n        To prevent cross-site request forgery, we set an '_xsrf' cookie\n        and include the same '_xsrf' value as an argument with all POST\n        requests. If the two do not match, we reject the form submission\n        as a potential forgery.\n\n        See http://en.wikipedia.org/wiki/Cross-site_request_forgery\n        \"\"\"\n        if not hasattr(self, \"_xsrf_token\"):\n            version, token, timestamp = self._get_raw_xsrf_token()\n            mask = os.urandom(4)\n            self._xsrf_token = b\"|\".join([\n                b\"2\",\n                binascii.b2a_hex(mask),\n                binascii.b2a_hex(_websocket_mask(mask, token)),\n                utf8(str(int(timestamp)))])\n            if version is None or version != 2:\n                expires_days = 30 if self.current_user else None\n                self.set_cookie(\"_xsrf\", self._xsrf_token,\n                                expires_days=expires_days)\n        return self._xsrf_token\n\n    def _get_raw_xsrf_token(self):\n        if not hasattr(self, '_raw_xsrf_token'):\n            cookie = self.get_cookie(\"_xsrf\")\n            if cookie:\n                version, token, timestamp = self._decode_xsrf_token(cookie)\n            else:\n                version, token, timestamp = None, None, None\n            if token is None:\n                version = None\n                token = os.urandom(16)\n                timestamp = time.time()\n            self._raw_xsrf_token = (version, token, timestamp)\n        return self._raw_xsrf_token\n\n    def _decode_xsrf_token(self, cookie):\n        m = _signed_value_version_re.match(utf8(cookie))\n        if m:\n            version = int(m.group(1))\n            if version == 2:\n                _, mask, masked_token, timestamp = cookie.split(\"|\")\n                mask = binascii.a2b_hex(utf8(mask))\n                token = _websocket_mask(\n                    mask, binascii.a2b_hex(utf8(masked_token)))\n                timestamp = int(timestamp)\n                return version, token, timestamp\n            else:\n                # Treat unknown versions as not present instead of failing.\n                return None, None, None\n        elif len(cookie) == 32:\n            version = 1\n            token = binascii.a2b_hex(cookie)\n            # We don't have a usable timestamp in older versions.\n            timestamp = int(time.time())\n            return (version, token, timestamp)\n        else:\n            return None, None, None\n\n    def check_xsrf_cookie(self):\n        \"\"\"Verifies that the ``_xsrf`` cookie matches the ``_xsrf`` argument.\n\n        To prevent cross-site request forgery, we set an ``_xsrf``\n        cookie and include the same value as a non-cookie\n        field with all ``POST`` requests. If the two do not match, we\n        reject the form submission as a potential forgery.\n\n        The ``_xsrf`` value may be set as either a form field named ``_xsrf``\n        or in a custom HTTP header named ``X-XSRFToken`` or ``X-CSRFToken``\n        (the latter is accepted for compatibility with Django).\n\n        See http://en.wikipedia.org/wiki/Cross-site_request_forgery\n\n        Prior to release 1.1.1, this check was ignored if the HTTP header\n        ``X-Requested-With: XMLHTTPRequest`` was present.  This exception\n        has been shown to be insecure and has been removed.  For more\n        information please see\n        http://www.djangoproject.com/weblog/2011/feb/08/security/\n        http://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails\n        \"\"\"\n        token = (self.get_argument(\"_xsrf\", None) or\n                 self.request.headers.get(\"X-Xsrftoken\") or\n                 self.request.headers.get(\"X-Csrftoken\"))\n        if not token:\n            raise HTTPError(403, \"'_xsrf' argument missing from POST\")\n        _, token, _ = self._decode_xsrf_token(token)\n        _, expected_token, _ = self._get_raw_xsrf_token()\n        if not _time_independent_equals(utf8(token), utf8(expected_token)):\n            raise HTTPError(403, \"XSRF cookie does not match POST argument\")\n\n    def xsrf_form_html(self):\n        \"\"\"An HTML ``<input/>`` element to be included with all POST forms.\n\n        It defines the ``_xsrf`` input value, which we check on all POST\n        requests to prevent cross-site request forgery. If you have set\n        the ``xsrf_cookies`` application setting, you must include this\n        HTML within all of your HTML forms.\n\n        In a template, this method should be called with ``{% module\n        xsrf_form_html() %}``\n\n        See `check_xsrf_cookie()` above for more information.\n        \"\"\"\n        return '<input type=\"hidden\" name=\"_xsrf\" value=\"' + \\\n            escape.xhtml_escape(self.xsrf_token) + '\"/>'\n\n    def static_url(self, path, include_host=None, **kwargs):\n        \"\"\"Returns a static URL for the given relative static file path.\n\n        This method requires you set the ``static_path`` setting in your\n        application (which specifies the root directory of your static\n        files).\n\n        This method returns a versioned url (by default appending\n        ``?v=<signature>``), which allows the static files to be\n        cached indefinitely.  This can be disabled by passing\n        ``include_version=False`` (in the default implementation;\n        other static file implementations are not required to support\n        this, but they may support other options).\n\n        By default this method returns URLs relative to the current\n        host, but if ``include_host`` is true the URL returned will be\n        absolute.  If this handler has an ``include_host`` attribute,\n        that value will be used as the default for all `static_url`\n        calls that do not pass ``include_host`` as a keyword argument.\n\n        \"\"\"\n        self.require_setting(\"static_path\", \"static_url\")\n        get_url = self.settings.get(\"static_handler_class\",\n                                    StaticFileHandler).make_static_url\n\n        if include_host is None:\n            include_host = getattr(self, \"include_host\", False)\n\n        if include_host:\n            base = self.request.protocol + \"://\" + self.request.host\n        else:\n            base = \"\"\n\n        return base + get_url(self.settings, path, **kwargs)\n\n    def async_callback(self, callback, *args, **kwargs):\n        \"\"\"Obsolete - catches exceptions from the wrapped function.\n\n        This function is unnecessary since Tornado 1.1.\n        \"\"\"\n        if callback is None:\n            return None\n        if args or kwargs:\n            callback = functools.partial(callback, *args, **kwargs)\n\n        def wrapper(*args, **kwargs):\n            try:\n                return callback(*args, **kwargs)\n            except Exception as e:\n                if self._headers_written:\n                    app_log.error(\"Exception after headers written\",\n                                  exc_info=True)\n                else:\n                    self._handle_request_exception(e)\n        return wrapper\n\n    def require_setting(self, name, feature=\"this feature\"):\n        \"\"\"Raises an exception if the given app setting is not defined.\"\"\"\n        if not self.application.settings.get(name):\n            raise Exception(\"You must define the '%s' setting in your \"\n                            \"application to use %s\" % (name, feature))\n\n    def reverse_url(self, name, *args):\n        \"\"\"Alias for `Application.reverse_url`.\"\"\"\n        return self.application.reverse_url(name, *args)\n\n    def compute_etag(self):\n        \"\"\"Computes the etag header to be used for this request.\n\n        By default uses a hash of the content written so far.\n\n        May be overridden to provide custom etag implementations,\n        or may return None to disable tornado's default etag support.\n        \"\"\"\n        hasher = hashlib.sha1()\n        for part in self._write_buffer:\n            hasher.update(part)\n        return '\"%s\"' % hasher.hexdigest()\n\n    def set_etag_header(self):\n        \"\"\"Sets the response's Etag header using ``self.compute_etag()``.\n\n        Note: no header will be set if ``compute_etag()`` returns ``None``.\n\n        This method is called automatically when the request is finished.\n        \"\"\"\n        etag = self.compute_etag()\n        if etag is not None:\n            self.set_header(\"Etag\", etag)\n\n    def check_etag_header(self):\n        \"\"\"Checks the ``Etag`` header against requests's ``If-None-Match``.\n\n        Returns ``True`` if the request's Etag matches and a 304 should be\n        returned. For example::\n\n            self.set_etag_header()\n            if self.check_etag_header():\n                self.set_status(304)\n                return\n\n        This method is called automatically when the request is finished,\n        but may be called earlier for applications that override\n        `compute_etag` and want to do an early check for ``If-None-Match``\n        before completing the request.  The ``Etag`` header should be set\n        (perhaps with `set_etag_header`) before calling this method.\n        \"\"\"\n        etag = self._headers.get(\"Etag\")\n        inm = utf8(self.request.headers.get(\"If-None-Match\", \"\"))\n        return bool(etag and inm and inm.find(etag) >= 0)\n\n    def _stack_context_handle_exception(self, type, value, traceback):\n        try:\n            # For historical reasons _handle_request_exception only takes\n            # the exception value instead of the full triple,\n            # so re-raise the exception to ensure that it's in\n            # sys.exc_info()\n            raise_exc_info((type, value, traceback))\n        except Exception:\n            self._handle_request_exception(value)\n        return True\n\n    def _execute(self, transforms, *args, **kwargs):\n        \"\"\"Executes this request with the given output transforms.\"\"\"\n        self._transforms = transforms\n        try:\n            if self.request.method not in self.SUPPORTED_METHODS:\n                raise HTTPError(405)\n            self.path_args = [self.decode_argument(arg) for arg in args]\n            self.path_kwargs = dict((k, self.decode_argument(v, name=k))\n                                    for (k, v) in kwargs.items())\n            # If XSRF cookies are turned on, reject form submissions without\n            # the proper cookie\n            if self.request.method not in (\"GET\", \"HEAD\", \"OPTIONS\") and \\\n                    self.application.settings.get(\"xsrf_cookies\"):\n                self.check_xsrf_cookie()\n            self._when_complete(self.prepare(), self._execute_method)\n        except Exception as e:\n            self._handle_request_exception(e)\n\n    def _when_complete(self, result, callback):\n        try:\n            if result is None:\n                callback()\n            elif isinstance(result, Future):\n                if result.done():\n                    if result.result() is not None:\n                        raise ValueError('Expected None, got %r' % result.result())\n                    callback()\n                else:\n                    # Delayed import of IOLoop because it's not available\n                    # on app engine\n                    from tornado.ioloop import IOLoop\n                    IOLoop.current().add_future(\n                        result, functools.partial(self._when_complete,\n                                                  callback=callback))\n            else:\n                raise ValueError(\"Expected Future or None, got %r\" % result)\n        except Exception as e:\n            self._handle_request_exception(e)\n\n    def _execute_method(self):\n        if not self._finished:\n            method = getattr(self, self.request.method.lower())\n            self._when_complete(method(*self.path_args, **self.path_kwargs),\n                                self._execute_finish)\n\n    def _execute_finish(self):\n        if self._auto_finish and not self._finished:\n            self.finish()\n\n    def _generate_headers(self):\n        reason = self._reason\n        lines = [utf8(self.request.version + \" \" +\n                      str(self._status_code) +\n                      \" \" + reason)]\n        lines.extend([utf8(n) + b\": \" + utf8(v) for n, v in self._headers.get_all()])\n\n        if hasattr(self, \"_new_cookie\"):\n            for cookie in self._new_cookie.values():\n                lines.append(utf8(\"Set-Cookie: \" + cookie.OutputString(None)))\n        return b\"\\r\\n\".join(lines) + b\"\\r\\n\\r\\n\"\n\n    def _log(self):\n        \"\"\"Logs the current request.\n\n        Sort of deprecated since this functionality was moved to the\n        Application, but left in place for the benefit of existing apps\n        that have overridden this method.\n        \"\"\"\n        self.application.log_request(self)\n\n    def _request_summary(self):\n        return self.request.method + \" \" + self.request.uri + \\\n            \" (\" + self.request.remote_ip + \")\"\n\n    def _handle_request_exception(self, e):\n        self.log_exception(*sys.exc_info())\n        if self._finished:\n            # Extra errors after the request has been finished should\n            # be logged, but there is no reason to continue to try and\n            # send a response.\n            return\n        if isinstance(e, HTTPError):\n            if e.status_code not in httputil.responses and not e.reason:\n                gen_log.error(\"Bad HTTP status code: %d\", e.status_code)\n                self.send_error(500, exc_info=sys.exc_info())\n            else:\n                self.send_error(e.status_code, exc_info=sys.exc_info())\n        else:\n            self.send_error(500, exc_info=sys.exc_info())\n\n    def log_exception(self, typ, value, tb):\n        \"\"\"Override to customize logging of uncaught exceptions.\n\n        By default logs instances of `HTTPError` as warnings without\n        stack traces (on the ``tornado.general`` logger), and all\n        other exceptions as errors with stack traces (on the\n        ``tornado.application`` logger).\n\n        .. versionadded:: 3.1\n        \"\"\"\n        if isinstance(value, HTTPError):\n            if value.log_message:\n                format = \"%d %s: \" + value.log_message\n                args = ([value.status_code, self._request_summary()] +\n                        list(value.args))\n                gen_log.warning(format, *args)\n        else:\n            app_log.error(\"Uncaught exception %s\\n%r\", self._request_summary(),\n                          self.request, exc_info=(typ, value, tb))\n\n    def _ui_module(self, name, module):\n        def render(*args, **kwargs):\n            if not hasattr(self, \"_active_modules\"):\n                self._active_modules = {}\n            if name not in self._active_modules:\n                self._active_modules[name] = module(self)\n            rendered = self._active_modules[name].render(*args, **kwargs)\n            return rendered\n        return render\n\n    def _ui_method(self, method):\n        return lambda *args, **kwargs: method(self, *args, **kwargs)\n\n    def _clear_headers_for_304(self):\n        # 304 responses should not contain entity headers (defined in\n        # http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.1)\n        # not explicitly allowed by\n        # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5\n        headers = [\"Allow\", \"Content-Encoding\", \"Content-Language\",\n                   \"Content-Length\", \"Content-MD5\", \"Content-Range\",\n                   \"Content-Type\", \"Last-Modified\"]\n        for h in headers:\n            self.clear_header(h)\n\n\ndef asynchronous(method):\n    \"\"\"Wrap request handler methods with this if they are asynchronous.\n\n    This decorator is unnecessary if the method is also decorated with\n    ``@gen.coroutine`` (it is legal but unnecessary to use the two\n    decorators together, in which case ``@asynchronous`` must be\n    first).\n\n    This decorator should only be applied to the :ref:`HTTP verb\n    methods <verbs>`; its behavior is undefined for any other method.\n    This decorator does not *make* a method asynchronous; it tells\n    the framework that the method *is* asynchronous.  For this decorator\n    to be useful the method must (at least sometimes) do something\n    asynchronous.\n\n    If this decorator is given, the response is not finished when the\n    method returns. It is up to the request handler to call\n    `self.finish() <RequestHandler.finish>` to finish the HTTP\n    request. Without this decorator, the request is automatically\n    finished when the ``get()`` or ``post()`` method returns. Example::\n\n       class MyRequestHandler(web.RequestHandler):\n           @web.asynchronous\n           def get(self):\n              http = httpclient.AsyncHTTPClient()\n              http.fetch(\"http://friendfeed.com/\", self._on_download)\n\n           def _on_download(self, response):\n              self.write(\"Downloaded!\")\n              self.finish()\n\n    .. versionadded:: 3.1\n       The ability to use ``@gen.coroutine`` without ``@asynchronous``.\n    \"\"\"\n    # Delay the IOLoop import because it's not available on app engine.\n    from tornado.ioloop import IOLoop\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        if self.application._wsgi:\n            raise Exception(\"@asynchronous is not supported for WSGI apps\")\n        self._auto_finish = False\n        with stack_context.ExceptionStackContext(\n                self._stack_context_handle_exception):\n            result = method(self, *args, **kwargs)\n            if isinstance(result, Future):\n                # If @asynchronous is used with @gen.coroutine, (but\n                # not @gen.engine), we can automatically finish the\n                # request when the future resolves.  Additionally,\n                # the Future will swallow any exceptions so we need\n                # to throw them back out to the stack context to finish\n                # the request.\n                def future_complete(f):\n                    f.result()\n                    if not self._finished:\n                        self.finish()\n                IOLoop.current().add_future(result, future_complete)\n                # Once we have done this, hide the Future from our\n                # caller (i.e. RequestHandler._when_complete), which\n                # would otherwise set up its own callback and\n                # exception handler (resulting in exceptions being\n                # logged twice).\n                return None\n            return result\n    return wrapper\n\n\ndef removeslash(method):\n    \"\"\"Use this decorator to remove trailing slashes from the request path.\n\n    For example, a request to ``/foo/`` would redirect to ``/foo`` with this\n    decorator. Your request handler mapping should use a regular expression\n    like ``r'/foo/*'`` in conjunction with using the decorator.\n    \"\"\"\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        if self.request.path.endswith(\"/\"):\n            if self.request.method in (\"GET\", \"HEAD\"):\n                uri = self.request.path.rstrip(\"/\")\n                if uri:  # don't try to redirect '/' to ''\n                    if self.request.query:\n                        uri += \"?\" + self.request.query\n                    self.redirect(uri, permanent=True)\n                    return\n            else:\n                raise HTTPError(404)\n        return method(self, *args, **kwargs)\n    return wrapper\n\n\ndef addslash(method):\n    \"\"\"Use this decorator to add a missing trailing slash to the request path.\n\n    For example, a request to ``/foo`` would redirect to ``/foo/`` with this\n    decorator. Your request handler mapping should use a regular expression\n    like ``r'/foo/?'`` in conjunction with using the decorator.\n    \"\"\"\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        if not self.request.path.endswith(\"/\"):\n            if self.request.method in (\"GET\", \"HEAD\"):\n                uri = self.request.path + \"/\"\n                if self.request.query:\n                    uri += \"?\" + self.request.query\n                self.redirect(uri, permanent=True)\n                return\n            raise HTTPError(404)\n        return method(self, *args, **kwargs)\n    return wrapper\n\n\nclass Application(object):\n    \"\"\"A collection of request handlers that make up a web application.\n\n    Instances of this class are callable and can be passed directly to\n    HTTPServer to serve the application::\n\n        application = web.Application([\n            (r\"/\", MainPageHandler),\n        ])\n        http_server = httpserver.HTTPServer(application)\n        http_server.listen(8080)\n        ioloop.IOLoop.instance().start()\n\n    The constructor for this class takes in a list of `URLSpec` objects\n    or (regexp, request_class) tuples. When we receive requests, we\n    iterate over the list in order and instantiate an instance of the\n    first request class whose regexp matches the request path.\n    The request class can be specified as either a class object or a\n    (fully-qualified) name.\n\n    Each tuple can contain additional elements, which correspond to the\n    arguments to the `URLSpec` constructor.  (Prior to Tornado 3.2, this\n    only tuples of two or three elements were allowed).\n\n    A dictionary may be passed as the third element of the tuple,\n    which will be used as keyword arguments to the handler's\n    constructor and `~RequestHandler.initialize` method.  This pattern\n    is used for the `StaticFileHandler` in this example (note that a\n    `StaticFileHandler` can be installed automatically with the\n    static_path setting described below)::\n\n        application = web.Application([\n            (r\"/static/(.*)\", web.StaticFileHandler, {\"path\": \"/var/www\"}),\n        ])\n\n    We support virtual hosts with the `add_handlers` method, which takes in\n    a host regular expression as the first argument::\n\n        application.add_handlers(r\"www\\.myhost\\.com\", [\n            (r\"/article/([0-9]+)\", ArticleHandler),\n        ])\n\n    You can serve static files by sending the ``static_path`` setting\n    as a keyword argument. We will serve those files from the\n    ``/static/`` URI (this is configurable with the\n    ``static_url_prefix`` setting), and we will serve ``/favicon.ico``\n    and ``/robots.txt`` from the same directory.  A custom subclass of\n    `StaticFileHandler` can be specified with the\n    ``static_handler_class`` setting.\n\n    \"\"\"\n    def __init__(self, handlers=None, default_host=\"\", transforms=None,\n                 wsgi=False, **settings):\n        if transforms is None:\n            self.transforms = []\n            if settings.get(\"gzip\"):\n                self.transforms.append(GZipContentEncoding)\n            self.transforms.append(ChunkedTransferEncoding)\n        else:\n            self.transforms = transforms\n        self.handlers = []\n        self.named_handlers = {}\n        self.default_host = default_host\n        self.settings = settings\n        self.ui_modules = {'linkify': _linkify,\n                           'xsrf_form_html': _xsrf_form_html,\n                           'Template': TemplateModule,\n                           }\n        self.ui_methods = {}\n        self._wsgi = wsgi\n        self._load_ui_modules(settings.get(\"ui_modules\", {}))\n        self._load_ui_methods(settings.get(\"ui_methods\", {}))\n        if self.settings.get(\"static_path\"):\n            path = self.settings[\"static_path\"]\n            handlers = list(handlers or [])\n            static_url_prefix = settings.get(\"static_url_prefix\",\n                                             \"/static/\")\n            static_handler_class = settings.get(\"static_handler_class\",\n                                                StaticFileHandler)\n            static_handler_args = settings.get(\"static_handler_args\", {})\n            static_handler_args['path'] = path\n            for pattern in [re.escape(static_url_prefix) + r\"(.*)\",\n                            r\"/(favicon\\.ico)\", r\"/(robots\\.txt)\"]:\n                handlers.insert(0, (pattern, static_handler_class,\n                                    static_handler_args))\n        if handlers:\n            self.add_handlers(\".*$\", handlers)\n\n        if self.settings.get('debug'):\n            self.settings.setdefault('autoreload', True)\n            self.settings.setdefault('compiled_template_cache', False)\n            self.settings.setdefault('static_hash_cache', False)\n            self.settings.setdefault('serve_traceback', True)\n\n        # Automatically reload modified modules\n        if self.settings.get('autoreload') and not wsgi:\n            from tornado import autoreload\n            autoreload.start()\n\n    def listen(self, port, address=\"\", **kwargs):\n        \"\"\"Starts an HTTP server for this application on the given port.\n\n        This is a convenience alias for creating an `.HTTPServer`\n        object and calling its listen method.  Keyword arguments not\n        supported by `HTTPServer.listen <.TCPServer.listen>` are passed to the\n        `.HTTPServer` constructor.  For advanced uses\n        (e.g. multi-process mode), do not use this method; create an\n        `.HTTPServer` and call its\n        `.TCPServer.bind`/`.TCPServer.start` methods directly.\n\n        Note that after calling this method you still need to call\n        ``IOLoop.instance().start()`` to start the server.\n        \"\"\"\n        # import is here rather than top level because HTTPServer\n        # is not importable on appengine\n        from tornado.httpserver import HTTPServer\n        server = HTTPServer(self, **kwargs)\n        server.listen(port, address)\n\n    def add_handlers(self, host_pattern, host_handlers):\n        \"\"\"Appends the given handlers to our handler list.\n\n        Host patterns are processed sequentially in the order they were\n        added. All matching patterns will be considered.\n        \"\"\"\n        if not host_pattern.endswith(\"$\"):\n            host_pattern += \"$\"\n        handlers = []\n        # The handlers with the wildcard host_pattern are a special\n        # case - they're added in the constructor but should have lower\n        # precedence than the more-precise handlers added later.\n        # If a wildcard handler group exists, it should always be last\n        # in the list, so insert new groups just before it.\n        if self.handlers and self.handlers[-1][0].pattern == '.*$':\n            self.handlers.insert(-1, (re.compile(host_pattern), handlers))\n        else:\n            self.handlers.append((re.compile(host_pattern), handlers))\n\n        for spec in host_handlers:\n            if isinstance(spec, (tuple, list)):\n                assert len(spec) in (2, 3, 4)\n                spec = URLSpec(*spec)\n            handlers.append(spec)\n            if spec.name:\n                if spec.name in self.named_handlers:\n                    app_log.warning(\n                        \"Multiple handlers named %s; replacing previous value\",\n                        spec.name)\n                self.named_handlers[spec.name] = spec\n\n    def add_transform(self, transform_class):\n        self.transforms.append(transform_class)\n\n    def _get_host_handlers(self, request):\n        host = request.host.lower().split(':')[0]\n        matches = []\n        for pattern, handlers in self.handlers:\n            if pattern.match(host):\n                matches.extend(handlers)\n        # Look for default host if not behind load balancer (for debugging)\n        if not matches and \"X-Real-Ip\" not in request.headers:\n            for pattern, handlers in self.handlers:\n                if pattern.match(self.default_host):\n                    matches.extend(handlers)\n        return matches or None\n\n    def _load_ui_methods(self, methods):\n        if isinstance(methods, types.ModuleType):\n            self._load_ui_methods(dict((n, getattr(methods, n))\n                                       for n in dir(methods)))\n        elif isinstance(methods, list):\n            for m in methods:\n                self._load_ui_methods(m)\n        else:\n            for name, fn in methods.items():\n                if not name.startswith(\"_\") and hasattr(fn, \"__call__\") \\\n                        and name[0].lower() == name[0]:\n                    self.ui_methods[name] = fn\n\n    def _load_ui_modules(self, modules):\n        if isinstance(modules, types.ModuleType):\n            self._load_ui_modules(dict((n, getattr(modules, n))\n                                       for n in dir(modules)))\n        elif isinstance(modules, list):\n            for m in modules:\n                self._load_ui_modules(m)\n        else:\n            assert isinstance(modules, dict)\n            for name, cls in modules.items():\n                try:\n                    if issubclass(cls, UIModule):\n                        self.ui_modules[name] = cls\n                except TypeError:\n                    pass\n\n    def __call__(self, request):\n        \"\"\"Called by HTTPServer to execute the request.\"\"\"\n        transforms = [t(request) for t in self.transforms]\n        handler = None\n        args = []\n        kwargs = {}\n        handlers = self._get_host_handlers(request)\n        if not handlers:\n            handler = RedirectHandler(\n                self, request, url=\"http://\" + self.default_host + \"/\")\n        else:\n            for spec in handlers:\n                match = spec.regex.match(request.path)\n                if match:\n                    handler = spec.handler_class(self, request, **spec.kwargs)\n                    if spec.regex.groups:\n                        # None-safe wrapper around url_unescape to handle\n                        # unmatched optional groups correctly\n                        def unquote(s):\n                            if s is None:\n                                return s\n                            return escape.url_unescape(s, encoding=None,\n                                                       plus=False)\n                        # Pass matched groups to the handler.  Since\n                        # match.groups() includes both named and unnamed groups,\n                        # we want to use either groups or groupdict but not both.\n                        # Note that args are passed as bytes so the handler can\n                        # decide what encoding to use.\n\n                        if spec.regex.groupindex:\n                            kwargs = dict(\n                                (str(k), unquote(v))\n                                for (k, v) in match.groupdict().items())\n                        else:\n                            args = [unquote(s) for s in match.groups()]\n                    break\n            if not handler:\n                if self.settings.get('default_handler_class'):\n                    handler_class = self.settings['default_handler_class']\n                    handler_args = self.settings.get(\n                        'default_handler_args', {})\n                else:\n                    handler_class = ErrorHandler\n                    handler_args = dict(status_code=404)\n                handler = handler_class(self, request, **handler_args)\n\n        # If template cache is disabled (usually in the debug mode),\n        # re-compile templates and reload static files on every\n        # request so you don't need to restart to see changes\n        if not self.settings.get(\"compiled_template_cache\", True):\n            with RequestHandler._template_loader_lock:\n                for loader in RequestHandler._template_loaders.values():\n                    loader.reset()\n        if not self.settings.get('static_hash_cache', True):\n            StaticFileHandler.reset()\n\n        handler._execute(transforms, *args, **kwargs)\n        return handler\n\n    def reverse_url(self, name, *args):\n        \"\"\"Returns a URL path for handler named ``name``\n\n        The handler must be added to the application as a named `URLSpec`.\n\n        Args will be substituted for capturing groups in the `URLSpec` regex.\n        They will be converted to strings if necessary, encoded as utf8,\n        and url-escaped.\n        \"\"\"\n        if name in self.named_handlers:\n            return self.named_handlers[name].reverse(*args)\n        raise KeyError(\"%s not found in named urls\" % name)\n\n    def log_request(self, handler):\n        \"\"\"Writes a completed HTTP request to the logs.\n\n        By default writes to the python root logger.  To change\n        this behavior either subclass Application and override this method,\n        or pass a function in the application settings dictionary as\n        ``log_function``.\n        \"\"\"\n        if \"log_function\" in self.settings:\n            self.settings[\"log_function\"](handler)\n            return\n        if handler.get_status() < 400:\n            log_method = access_log.info\n        elif handler.get_status() < 500:\n            log_method = access_log.warning\n        else:\n            log_method = access_log.error\n        request_time = 1000.0 * handler.request.request_time()\n        log_method(\"%d %s %.2fms\", handler.get_status(),\n                   handler._request_summary(), request_time)\n\n\nclass HTTPError(Exception):\n    \"\"\"An exception that will turn into an HTTP error response.\n\n    Raising an `HTTPError` is a convenient alternative to calling\n    `RequestHandler.send_error` since it automatically ends the\n    current function.\n\n    :arg int status_code: HTTP status code.  Must be listed in\n        `httplib.responses <http.client.responses>` unless the ``reason``\n        keyword argument is given.\n    :arg string log_message: Message to be written to the log for this error\n        (will not be shown to the user unless the `Application` is in debug\n        mode).  May contain ``%s``-style placeholders, which will be filled\n        in with remaining positional parameters.\n    :arg string reason: Keyword-only argument.  The HTTP \"reason\" phrase\n        to pass in the status line along with ``status_code``.  Normally\n        determined automatically from ``status_code``, but can be used\n        to use a non-standard numeric code.\n    \"\"\"\n    def __init__(self, status_code, log_message=None, *args, **kwargs):\n        self.status_code = status_code\n        self.log_message = log_message\n        self.args = args\n        self.reason = kwargs.get('reason', None)\n\n    def __str__(self):\n        message = \"HTTP %d: %s\" % (\n            self.status_code,\n            self.reason or httputil.responses.get(self.status_code, 'Unknown'))\n        if self.log_message:\n            return message + \" (\" + (self.log_message % self.args) + \")\"\n        else:\n            return message\n\n\nclass MissingArgumentError(HTTPError):\n    \"\"\"Exception raised by `RequestHandler.get_argument`.\n\n    This is a subclass of `HTTPError`, so if it is uncaught a 400 response\n    code will be used instead of 500 (and a stack trace will not be logged).\n\n    .. versionadded:: 3.1\n    \"\"\"\n    def __init__(self, arg_name):\n        super(MissingArgumentError, self).__init__(\n            400, 'Missing argument %s' % arg_name)\n        self.arg_name = arg_name\n\n\nclass ErrorHandler(RequestHandler):\n    \"\"\"Generates an error response with ``status_code`` for all requests.\"\"\"\n    def initialize(self, status_code):\n        self.set_status(status_code)\n\n    def prepare(self):\n        raise HTTPError(self._status_code)\n\n    def check_xsrf_cookie(self):\n        # POSTs to an ErrorHandler don't actually have side effects,\n        # so we don't need to check the xsrf token.  This allows POSTs\n        # to the wrong url to return a 404 instead of 403.\n        pass\n\n\nclass RedirectHandler(RequestHandler):\n    \"\"\"Redirects the client to the given URL for all GET requests.\n\n    You should provide the keyword argument ``url`` to the handler, e.g.::\n\n        application = web.Application([\n            (r\"/oldpath\", web.RedirectHandler, {\"url\": \"/newpath\"}),\n        ])\n    \"\"\"\n    def initialize(self, url, permanent=True):\n        self._url = url\n        self._permanent = permanent\n\n    def get(self):\n        self.redirect(self._url, permanent=self._permanent)\n\n\nclass StaticFileHandler(RequestHandler):\n    \"\"\"A simple handler that can serve static content from a directory.\n\n    A `StaticFileHandler` is configured automatically if you pass the\n    ``static_path`` keyword argument to `Application`.  This handler\n    can be customized with the ``static_url_prefix``, ``static_handler_class``,\n    and ``static_handler_args`` settings.\n\n    To map an additional path to this handler for a static data directory\n    you would add a line to your application like::\n\n        application = web.Application([\n            (r\"/content/(.*)\", web.StaticFileHandler, {\"path\": \"/var/www\"}),\n        ])\n\n    The handler constructor requires a ``path`` argument, which specifies the\n    local root directory of the content to be served.\n\n    Note that a capture group in the regex is required to parse the value for\n    the ``path`` argument to the get() method (different than the constructor\n    argument above); see `URLSpec` for details.\n\n    To maximize the effectiveness of browser caching, this class supports\n    versioned urls (by default using the argument ``?v=``).  If a version\n    is given, we instruct the browser to cache this file indefinitely.\n    `make_static_url` (also available as `RequestHandler.static_url`) can\n    be used to construct a versioned url.\n\n    This handler is intended primarily for use in development and light-duty\n    file serving; for heavy traffic it will be more efficient to use\n    a dedicated static file server (such as nginx or Apache).  We support\n    the HTTP ``Accept-Ranges`` mechanism to return partial content (because\n    some browsers require this functionality to be present to seek in\n    HTML5 audio or video), but this handler should not be used with\n    files that are too large to fit comfortably in memory.\n\n    **Subclassing notes**\n\n    This class is designed to be extensible by subclassing, but because\n    of the way static urls are generated with class methods rather than\n    instance methods, the inheritance patterns are somewhat unusual.\n    Be sure to use the ``@classmethod`` decorator when overriding a\n    class method.  Instance methods may use the attributes ``self.path``\n    ``self.absolute_path``, and ``self.modified``.\n\n    Subclasses should only override methods discussed in this section;\n    overriding other methods is error-prone.  Overriding\n    ``StaticFileHandler.get`` is particularly problematic due to the\n    tight coupling with ``compute_etag`` and other methods.\n\n    To change the way static urls are generated (e.g. to match the behavior\n    of another server or CDN), override `make_static_url`, `parse_url_path`,\n    `get_cache_time`, and/or `get_version`.\n\n    To replace all interaction with the filesystem (e.g. to serve\n    static content from a database), override `get_content`,\n    `get_content_size`, `get_modified_time`, `get_absolute_path`, and\n    `validate_absolute_path`.\n\n    .. versionchanged:: 3.1\n       Many of the methods for subclasses were added in Tornado 3.1.\n    \"\"\"\n    CACHE_MAX_AGE = 86400 * 365 * 10  # 10 years\n\n    _static_hashes = {}\n    _lock = threading.Lock()  # protects _static_hashes\n\n    def initialize(self, path, default_filename=None):\n        self.root = path\n        self.default_filename = default_filename\n\n    @classmethod\n    def reset(cls):\n        with cls._lock:\n            cls._static_hashes = {}\n\n    def head(self, path):\n        self.get(path, include_body=False)\n\n    def get(self, path, include_body=True):\n        # Set up our path instance variables.\n        self.path = self.parse_url_path(path)\n        del path  # make sure we don't refer to path instead of self.path again\n        absolute_path = self.get_absolute_path(self.root, self.path)\n        self.absolute_path = self.validate_absolute_path(\n            self.root, absolute_path)\n        if self.absolute_path is None:\n            return\n\n        self.modified = self.get_modified_time()\n        self.set_headers()\n\n        if self.should_return_304():\n            self.set_status(304)\n            return\n\n        request_range = None\n        range_header = self.request.headers.get(\"Range\")\n        if range_header:\n            # As per RFC 2616 14.16, if an invalid Range header is specified,\n            # the request will be treated as if the header didn't exist.\n            request_range = httputil._parse_request_range(range_header)\n\n        if request_range:\n            start, end = request_range\n            size = self.get_content_size()\n            if (start is not None and start >= size) or end == 0:\n                # As per RFC 2616 14.35.1, a range is not satisfiable only: if\n                # the first requested byte is equal to or greater than the\n                # content, or when a suffix with length 0 is specified\n                self.set_status(416)  # Range Not Satisfiable\n                self.set_header(\"Content-Type\", \"text/plain\")\n                self.set_header(\"Content-Range\", \"bytes */%s\" % (size, ))\n                return\n            if start is not None and start < 0:\n                start += size\n            if end is not None and end > size:\n                # Clients sometimes blindly use a large range to limit their\n                # download size; cap the endpoint at the actual file size.\n                end = size\n            # Note: only return HTTP 206 if less than the entire range has been\n            # requested. Not only is this semantically correct, but Chrome\n            # refuses to play audio if it gets an HTTP 206 in response to\n            # ``Range: bytes=0-``.\n            if size != (end or size) - (start or 0):\n                self.set_status(206)  # Partial Content\n                self.set_header(\"Content-Range\",\n                                httputil._get_content_range(start, end, size))\n        else:\n            start = end = None\n        content = self.get_content(self.absolute_path, start, end)\n        if isinstance(content, bytes_type):\n            content = [content]\n        content_length = 0\n        for chunk in content:\n            if include_body:\n                self.write(chunk)\n            else:\n                content_length += len(chunk)\n        if not include_body:\n            assert self.request.method == \"HEAD\"\n            self.set_header(\"Content-Length\", content_length)\n\n    def compute_etag(self):\n        \"\"\"Sets the ``Etag`` header based on static url version.\n\n        This allows efficient ``If-None-Match`` checks against cached\n        versions, and sends the correct ``Etag`` for a partial response\n        (i.e. the same ``Etag`` as the full file).\n\n        .. versionadded:: 3.1\n        \"\"\"\n        version_hash = self._get_cached_version(self.absolute_path)\n        if not version_hash:\n            return None\n        return '\"%s\"' % (version_hash, )\n\n    def set_headers(self):\n        \"\"\"Sets the content and caching headers on the response.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        self.set_header(\"Accept-Ranges\", \"bytes\")\n        self.set_etag_header()\n\n        if self.modified is not None:\n            self.set_header(\"Last-Modified\", self.modified)\n\n        content_type = self.get_content_type()\n        if content_type:\n            self.set_header(\"Content-Type\", content_type)\n\n        cache_time = self.get_cache_time(self.path, self.modified, content_type)\n        if cache_time > 0:\n            self.set_header(\"Expires\", datetime.datetime.utcnow() +\n                            datetime.timedelta(seconds=cache_time))\n            self.set_header(\"Cache-Control\", \"max-age=\" + str(cache_time))\n\n        self.set_extra_headers(self.path)\n\n    def should_return_304(self):\n        \"\"\"Returns True if the headers indicate that we should return 304.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        if self.check_etag_header():\n            return True\n\n        # Check the If-Modified-Since, and don't send the result if the\n        # content has not been modified\n        ims_value = self.request.headers.get(\"If-Modified-Since\")\n        if ims_value is not None:\n            date_tuple = email.utils.parsedate(ims_value)\n            if date_tuple is not None:\n                if_since = datetime.datetime(*date_tuple[:6])\n                if if_since >= self.modified:\n                    return True\n\n        return False\n\n    @classmethod\n    def get_absolute_path(cls, root, path):\n        \"\"\"Returns the absolute location of ``path`` relative to ``root``.\n\n        ``root`` is the path configured for this `StaticFileHandler`\n        (in most cases the ``static_path`` `Application` setting).\n\n        This class method may be overridden in subclasses.  By default\n        it returns a filesystem path, but other strings may be used\n        as long as they are unique and understood by the subclass's\n        overridden `get_content`.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        abspath = os.path.abspath(os.path.join(root, path))\n        return abspath\n\n    def validate_absolute_path(self, root, absolute_path):\n        \"\"\"Validate and return the absolute path.\n\n        ``root`` is the configured path for the `StaticFileHandler`,\n        and ``path`` is the result of `get_absolute_path`\n\n        This is an instance method called during request processing,\n        so it may raise `HTTPError` or use methods like\n        `RequestHandler.redirect` (return None after redirecting to\n        halt further processing).  This is where 404 errors for missing files\n        are generated.\n\n        This method may modify the path before returning it, but note that\n        any such modifications will not be understood by `make_static_url`.\n\n        In instance methods, this method's result is available as\n        ``self.absolute_path``.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        root = os.path.abspath(root)\n        # os.path.abspath strips a trailing /\n        # it needs to be temporarily added back for requests to root/\n        if not (absolute_path + os.path.sep).startswith(root):\n            raise HTTPError(403, \"%s is not in root static directory\",\n                            self.path)\n        if (os.path.isdir(absolute_path) and\n                self.default_filename is not None):\n            # need to look at the request.path here for when path is empty\n            # but there is some prefix to the path that was already\n            # trimmed by the routing\n            if not self.request.path.endswith(\"/\"):\n                self.redirect(self.request.path + \"/\", permanent=True)\n                return\n            absolute_path = os.path.join(absolute_path, self.default_filename)\n        if not os.path.exists(absolute_path):\n            raise HTTPError(404)\n        if not os.path.isfile(absolute_path):\n            raise HTTPError(403, \"%s is not a file\", self.path)\n        return absolute_path\n\n    @classmethod\n    def get_content(cls, abspath, start=None, end=None):\n        \"\"\"Retrieve the content of the requested resource which is located\n        at the given absolute path.\n\n        This class method may be overridden by subclasses.  Note that its\n        signature is different from other overridable class methods\n        (no ``settings`` argument); this is deliberate to ensure that\n        ``abspath`` is able to stand on its own as a cache key.\n\n        This method should either return a byte string or an iterator\n        of byte strings.  The latter is preferred for large files\n        as it helps reduce memory fragmentation.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        with open(abspath, \"rb\") as file:\n            if start is not None:\n                file.seek(start)\n            if end is not None:\n                remaining = end - (start or 0)\n            else:\n                remaining = None\n            while True:\n                chunk_size = 64 * 1024\n                if remaining is not None and remaining < chunk_size:\n                    chunk_size = remaining\n                chunk = file.read(chunk_size)\n                if chunk:\n                    if remaining is not None:\n                        remaining -= len(chunk)\n                    yield chunk\n                else:\n                    if remaining is not None:\n                        assert remaining == 0\n                    return\n\n    @classmethod\n    def get_content_version(cls, abspath):\n        \"\"\"Returns a version string for the resource at the given path.\n\n        This class method may be overridden by subclasses.  The\n        default implementation is a hash of the file's contents.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        data = cls.get_content(abspath)\n        hasher = hashlib.md5()\n        if isinstance(data, bytes_type):\n            hasher.update(data)\n        else:\n            for chunk in data:\n                hasher.update(chunk)\n        return hasher.hexdigest()\n\n    def _stat(self):\n        if not hasattr(self, '_stat_result'):\n            self._stat_result = os.stat(self.absolute_path)\n        return self._stat_result\n\n    def get_content_size(self):\n        \"\"\"Retrieve the total size of the resource at the given path.\n\n        This method may be overridden by subclasses. It will only\n        be called if a partial result is requested from `get_content`\n\n        .. versionadded:: 3.1\n        \"\"\"\n        stat_result = self._stat()\n        return stat_result[stat.ST_SIZE]\n\n    def get_modified_time(self):\n        \"\"\"Returns the time that ``self.absolute_path`` was last modified.\n\n        May be overridden in subclasses.  Should return a `~datetime.datetime`\n        object or None.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        stat_result = self._stat()\n        modified = datetime.datetime.utcfromtimestamp(stat_result[stat.ST_MTIME])\n        return modified\n\n    def get_content_type(self):\n        \"\"\"Returns the ``Content-Type`` header to be used for this request.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        mime_type, encoding = mimetypes.guess_type(self.absolute_path)\n        return mime_type\n\n    def set_extra_headers(self, path):\n        \"\"\"For subclass to add extra headers to the response\"\"\"\n        pass\n\n    def get_cache_time(self, path, modified, mime_type):\n        \"\"\"Override to customize cache control behavior.\n\n        Return a positive number of seconds to make the result\n        cacheable for that amount of time or 0 to mark resource as\n        cacheable for an unspecified amount of time (subject to\n        browser heuristics).\n\n        By default returns cache expiry of 10 years for resources requested\n        with ``v`` argument.\n        \"\"\"\n        return self.CACHE_MAX_AGE if \"v\" in self.request.arguments else 0\n\n    @classmethod\n    def make_static_url(cls, settings, path, include_version=True):\n        \"\"\"Constructs a versioned url for the given path.\n\n        This method may be overridden in subclasses (but note that it\n        is a class method rather than an instance method).  Subclasses\n        are only required to implement the signature\n        ``make_static_url(cls, settings, path)``; other keyword\n        arguments may be passed through `~RequestHandler.static_url`\n        but are not standard.\n\n        ``settings`` is the `Application.settings` dictionary.  ``path``\n        is the static path being requested.  The url returned should be\n        relative to the current host.\n\n        ``include_version`` determines whether the generated URL should\n        include the query string containing the version hash of the\n        file corresponding to the given ``path``.\n\n        \"\"\"\n        url = settings.get('static_url_prefix', '/static/') + path\n        if not include_version:\n            return url\n\n        version_hash = cls.get_version(settings, path)\n        if not version_hash:\n            return url\n\n        return '%s?v=%s' % (url, version_hash)\n\n    def parse_url_path(self, url_path):\n        \"\"\"Converts a static URL path into a filesystem path.\n\n        ``url_path`` is the path component of the URL with\n        ``static_url_prefix`` removed.  The return value should be\n        filesystem path relative to ``static_path``.\n\n        This is the inverse of `make_static_url`.\n        \"\"\"\n        if os.path.sep != \"/\":\n            url_path = url_path.replace(\"/\", os.path.sep)\n        return url_path\n\n    @classmethod\n    def get_version(cls, settings, path):\n        \"\"\"Generate the version string to be used in static URLs.\n\n        ``settings`` is the `Application.settings` dictionary and ``path``\n        is the relative location of the requested asset on the filesystem.\n        The returned value should be a string, or ``None`` if no version\n        could be determined.\n\n        .. versionchanged:: 3.1\n           This method was previously recommended for subclasses to override;\n           `get_content_version` is now preferred as it allows the base\n           class to handle caching of the result.\n        \"\"\"\n        abs_path = cls.get_absolute_path(settings['static_path'], path)\n        return cls._get_cached_version(abs_path)\n\n    @classmethod\n    def _get_cached_version(cls, abs_path):\n        with cls._lock:\n            hashes = cls._static_hashes\n            if abs_path not in hashes:\n                try:\n                    hashes[abs_path] = cls.get_content_version(abs_path)\n                except Exception:\n                    gen_log.error(\"Could not open static file %r\", abs_path)\n                    hashes[abs_path] = None\n            hsh = hashes.get(abs_path)\n            if hsh:\n                return hsh\n        return None\n\n\nclass FallbackHandler(RequestHandler):\n    \"\"\"A `RequestHandler` that wraps another HTTP server callback.\n\n    The fallback is a callable object that accepts an\n    `~.httpserver.HTTPRequest`, such as an `Application` or\n    `tornado.wsgi.WSGIContainer`.  This is most useful to use both\n    Tornado ``RequestHandlers`` and WSGI in the same server.  Typical\n    usage::\n\n        wsgi_app = tornado.wsgi.WSGIContainer(\n            django.core.handlers.wsgi.WSGIHandler())\n        application = tornado.web.Application([\n            (r\"/foo\", FooHandler),\n            (r\".*\", FallbackHandler, dict(fallback=wsgi_app),\n        ])\n    \"\"\"\n    def initialize(self, fallback):\n        self.fallback = fallback\n\n    def prepare(self):\n        self.fallback(self.request)\n        self._finished = True\n\n\nclass OutputTransform(object):\n    \"\"\"A transform modifies the result of an HTTP request (e.g., GZip encoding)\n\n    A new transform instance is created for every request. See the\n    ChunkedTransferEncoding example below if you want to implement a\n    new Transform.\n    \"\"\"\n    def __init__(self, request):\n        pass\n\n    def transform_first_chunk(self, status_code, headers, chunk, finishing):\n        return status_code, headers, chunk\n\n    def transform_chunk(self, chunk, finishing):\n        return chunk\n\n\nclass GZipContentEncoding(OutputTransform):\n    \"\"\"Applies the gzip content encoding to the response.\n\n    See http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11\n    \"\"\"\n    CONTENT_TYPES = set([\n        \"text/plain\", \"text/html\", \"text/css\", \"text/xml\", \"application/javascript\",\n        \"application/x-javascript\", \"application/xml\", \"application/atom+xml\",\n        \"text/javascript\", \"application/json\", \"application/xhtml+xml\"])\n    MIN_LENGTH = 5\n\n    def __init__(self, request):\n        self._gzipping = request.supports_http_1_1() and \\\n            \"gzip\" in request.headers.get(\"Accept-Encoding\", \"\")\n\n    def transform_first_chunk(self, status_code, headers, chunk, finishing):\n        if 'Vary' in headers:\n            headers['Vary'] += b', Accept-Encoding'\n        else:\n            headers['Vary'] = b'Accept-Encoding'\n        if self._gzipping:\n            ctype = _unicode(headers.get(\"Content-Type\", \"\")).split(\";\")[0]\n            self._gzipping = (ctype in self.CONTENT_TYPES) and \\\n                (not finishing or len(chunk) >= self.MIN_LENGTH) and \\\n                (finishing or \"Content-Length\" not in headers) and \\\n                (\"Content-Encoding\" not in headers)\n        if self._gzipping:\n            headers[\"Content-Encoding\"] = \"gzip\"\n            self._gzip_value = BytesIO()\n            self._gzip_file = gzip.GzipFile(mode=\"w\", fileobj=self._gzip_value)\n            chunk = self.transform_chunk(chunk, finishing)\n            if \"Content-Length\" in headers:\n                headers[\"Content-Length\"] = str(len(chunk))\n        return status_code, headers, chunk\n\n    def transform_chunk(self, chunk, finishing):\n        if self._gzipping:\n            self._gzip_file.write(chunk)\n            if finishing:\n                self._gzip_file.close()\n            else:\n                self._gzip_file.flush()\n            chunk = self._gzip_value.getvalue()\n            self._gzip_value.truncate(0)\n            self._gzip_value.seek(0)\n        return chunk\n\n\nclass ChunkedTransferEncoding(OutputTransform):\n    \"\"\"Applies the chunked transfer encoding to the response.\n\n    See http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6.1\n    \"\"\"\n    def __init__(self, request):\n        self._chunking = request.supports_http_1_1()\n\n    def transform_first_chunk(self, status_code, headers, chunk, finishing):\n        # 304 responses have no body (not even a zero-length body), and so\n        # should not have either Content-Length or Transfer-Encoding headers.\n        if self._chunking and status_code != 304:\n            # No need to chunk the output if a Content-Length is specified\n            if \"Content-Length\" in headers or \"Transfer-Encoding\" in headers:\n                self._chunking = False\n            else:\n                headers[\"Transfer-Encoding\"] = \"chunked\"\n                chunk = self.transform_chunk(chunk, finishing)\n        return status_code, headers, chunk\n\n    def transform_chunk(self, block, finishing):\n        if self._chunking:\n            # Don't write out empty chunks because that means END-OF-STREAM\n            # with chunked encoding\n            if block:\n                block = utf8(\"%x\" % len(block)) + b\"\\r\\n\" + block + b\"\\r\\n\"\n            if finishing:\n                block += b\"0\\r\\n\\r\\n\"\n        return block\n\n\ndef authenticated(method):\n    \"\"\"Decorate methods with this to require that the user be logged in.\n\n    If the user is not logged in, they will be redirected to the configured\n    `login url <RequestHandler.get_login_url>`.\n    \"\"\"\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        if not self.current_user:\n            if self.request.method in (\"GET\", \"HEAD\"):\n                url = self.get_login_url()\n                if \"?\" not in url:\n                    if urlparse.urlsplit(url).scheme:\n                        # if login url is absolute, make next absolute too\n                        next_url = self.request.full_url()\n                    else:\n                        next_url = self.request.uri\n                    url += \"?\" + urlencode(dict(next=next_url))\n                self.redirect(url)\n                return\n            raise HTTPError(403)\n        return method(self, *args, **kwargs)\n    return wrapper\n\n\nclass UIModule(object):\n    \"\"\"A re-usable, modular UI unit on a page.\n\n    UI modules often execute additional queries, and they can include\n    additional CSS and JavaScript that will be included in the output\n    page, which is automatically inserted on page render.\n    \"\"\"\n    def __init__(self, handler):\n        self.handler = handler\n        self.request = handler.request\n        self.ui = handler.ui\n        self.locale = handler.locale\n\n    @property\n    def current_user(self):\n        return self.handler.current_user\n\n    def render(self, *args, **kwargs):\n        \"\"\"Overridden in subclasses to return this module's output.\"\"\"\n        raise NotImplementedError()\n\n    def embedded_javascript(self):\n        \"\"\"Returns a JavaScript string that will be embedded in the page.\"\"\"\n        return None\n\n    def javascript_files(self):\n        \"\"\"Returns a list of JavaScript files required by this module.\"\"\"\n        return None\n\n    def embedded_css(self):\n        \"\"\"Returns a CSS string that will be embedded in the page.\"\"\"\n        return None\n\n    def css_files(self):\n        \"\"\"Returns a list of CSS files required by this module.\"\"\"\n        return None\n\n    def html_head(self):\n        \"\"\"Returns a CSS string that will be put in the <head/> element\"\"\"\n        return None\n\n    def html_body(self):\n        \"\"\"Returns an HTML string that will be put in the <body/> element\"\"\"\n        return None\n\n    def render_string(self, path, **kwargs):\n        \"\"\"Renders a template and returns it as a string.\"\"\"\n        return self.handler.render_string(path, **kwargs)\n\n\nclass _linkify(UIModule):\n    def render(self, text, **kwargs):\n        return escape.linkify(text, **kwargs)\n\n\nclass _xsrf_form_html(UIModule):\n    def render(self):\n        return self.handler.xsrf_form_html()\n\n\nclass TemplateModule(UIModule):\n    \"\"\"UIModule that simply renders the given template.\n\n    {% module Template(\"foo.html\") %} is similar to {% include \"foo.html\" %},\n    but the module version gets its own namespace (with kwargs passed to\n    Template()) instead of inheriting the outer template's namespace.\n\n    Templates rendered through this module also get access to UIModule's\n    automatic javascript/css features.  Simply call set_resources\n    inside the template and give it keyword arguments corresponding to\n    the methods on UIModule: {{ set_resources(js_files=static_url(\"my.js\")) }}\n    Note that these resources are output once per template file, not once\n    per instantiation of the template, so they must not depend on\n    any arguments to the template.\n    \"\"\"\n    def __init__(self, handler):\n        super(TemplateModule, self).__init__(handler)\n        # keep resources in both a list and a dict to preserve order\n        self._resource_list = []\n        self._resource_dict = {}\n\n    def render(self, path, **kwargs):\n        def set_resources(**kwargs):\n            if path not in self._resource_dict:\n                self._resource_list.append(kwargs)\n                self._resource_dict[path] = kwargs\n            else:\n                if self._resource_dict[path] != kwargs:\n                    raise ValueError(\"set_resources called with different \"\n                                     \"resources for the same template\")\n            return \"\"\n        return self.render_string(path, set_resources=set_resources,\n                                  **kwargs)\n\n    def _get_resources(self, key):\n        return (r[key] for r in self._resource_list if key in r)\n\n    def embedded_javascript(self):\n        return \"\\n\".join(self._get_resources(\"embedded_javascript\"))\n\n    def javascript_files(self):\n        result = []\n        for f in self._get_resources(\"javascript_files\"):\n            if isinstance(f, (unicode_type, bytes_type)):\n                result.append(f)\n            else:\n                result.extend(f)\n        return result\n\n    def embedded_css(self):\n        return \"\\n\".join(self._get_resources(\"embedded_css\"))\n\n    def css_files(self):\n        result = []\n        for f in self._get_resources(\"css_files\"):\n            if isinstance(f, (unicode_type, bytes_type)):\n                result.append(f)\n            else:\n                result.extend(f)\n        return result\n\n    def html_head(self):\n        return \"\".join(self._get_resources(\"html_head\"))\n\n    def html_body(self):\n        return \"\".join(self._get_resources(\"html_body\"))\n\n\nclass _UIModuleNamespace(object):\n    \"\"\"Lazy namespace which creates UIModule proxies bound to a handler.\"\"\"\n    def __init__(self, handler, ui_modules):\n        self.handler = handler\n        self.ui_modules = ui_modules\n\n    def __getitem__(self, key):\n        return self.handler._ui_module(key, self.ui_modules[key])\n\n    def __getattr__(self, key):\n        try:\n            return self[key]\n        except KeyError as e:\n            raise AttributeError(str(e))\n\n\nclass URLSpec(object):\n    \"\"\"Specifies mappings between URLs and handlers.\"\"\"\n    def __init__(self, pattern, handler, kwargs=None, name=None):\n        \"\"\"Parameters:\n\n        * ``pattern``: Regular expression to be matched.  Any groups\n          in the regex will be passed in to the handler's get/post/etc\n          methods as arguments.\n\n        * ``handler_class``: `RequestHandler` subclass to be invoked.\n\n        * ``kwargs`` (optional): A dictionary of additional arguments\n          to be passed to the handler's constructor.\n\n        * ``name`` (optional): A name for this handler.  Used by\n          `Application.reverse_url`.\n        \"\"\"\n        if not pattern.endswith('$'):\n            pattern += '$'\n        self.regex = re.compile(pattern)\n        assert len(self.regex.groupindex) in (0, self.regex.groups), \\\n            (\"groups in url regexes must either be all named or all \"\n             \"positional: %r\" % self.regex.pattern)\n\n        if isinstance(handler, str):\n            # import the Module and instantiate the class\n            # Must be a fully qualified name (module.ClassName)\n            handler = import_object(handler)\n\n        self.handler_class = handler\n        self.kwargs = kwargs or {}\n        self.name = name\n        self._path, self._group_count = self._find_groups()\n\n    def __repr__(self):\n        return '%s(%r, %s, kwargs=%r, name=%r)' % \\\n            (self.__class__.__name__, self.regex.pattern,\n             self.handler_class, self.kwargs, self.name)\n\n    def _find_groups(self):\n        \"\"\"Returns a tuple (reverse string, group count) for a url.\n\n        For example: Given the url pattern /([0-9]{4})/([a-z-]+)/, this method\n        would return ('/%s/%s/', 2).\n        \"\"\"\n        pattern = self.regex.pattern\n        if pattern.startswith('^'):\n            pattern = pattern[1:]\n        if pattern.endswith('$'):\n            pattern = pattern[:-1]\n\n        if self.regex.groups != pattern.count('('):\n            # The pattern is too complicated for our simplistic matching,\n            # so we can't support reversing it.\n            return (None, None)\n\n        pieces = []\n        for fragment in pattern.split('('):\n            if ')' in fragment:\n                paren_loc = fragment.index(')')\n                if paren_loc >= 0:\n                    pieces.append('%s' + fragment[paren_loc + 1:])\n            else:\n                pieces.append(fragment)\n\n        return (''.join(pieces), self.regex.groups)\n\n    def reverse(self, *args):\n        assert self._path is not None, \\\n            \"Cannot reverse url regex \" + self.regex.pattern\n        assert len(args) == self._group_count, \"required number of arguments \"\\\n            \"not found\"\n        if not len(args):\n            return self._path\n        converted_args = []\n        for a in args:\n            if not isinstance(a, (unicode_type, bytes_type)):\n                a = str(a)\n            converted_args.append(escape.url_escape(utf8(a), plus=False))\n        return self._path % tuple(converted_args)\n\nurl = URLSpec\n\n\nif hasattr(hmac, 'compare_digest'):  # python 3.3\n    _time_independent_equals = hmac.compare_digest\nelse:\n    def _time_independent_equals(a, b):\n        if len(a) != len(b):\n            return False\n        result = 0\n        if isinstance(a[0], int):  # python3 byte strings\n            for x, y in zip(a, b):\n                result |= x ^ y\n        else:  # python2\n            for x, y in zip(a, b):\n                result |= ord(x) ^ ord(y)\n        return result == 0\n\n\ndef create_signed_value(secret, name, value, version=None, clock=None):\n    if version is None:\n        version = DEFAULT_SIGNED_VALUE_VERSION\n    if clock is None:\n        clock = time.time\n    timestamp = utf8(str(int(clock())))\n    value = base64.b64encode(utf8(value))\n    if version == 1:\n        signature = _create_signature_v1(secret, name, value, timestamp)\n        value = b\"|\".join([value, timestamp, signature])\n        return value\n    elif version == 2:\n        # The v2 format consists of a version number and a series of\n        # length-prefixed fields \"%d:%s\", the last of which is a\n        # signature, all separated by pipes.  All numbers are in\n        # decimal format with no leading zeros.  The signature is an\n        # HMAC-SHA256 of the whole string up to that point, including\n        # the final pipe.\n        #\n        # The fields are:\n        # - format version (i.e. 2; no length prefix)\n        # - key version (currently 0; reserved for future key rotation features)\n        # - timestamp (integer seconds since epoch)\n        # - name (not encoded; assumed to be ~alphanumeric)\n        # - value (base64-encoded)\n        # - signature (hex-encoded; no length prefix)\n        def format_field(s):\n            return utf8(\"%d:\" % len(s)) + utf8(s)\n        to_sign = b\"|\".join([\n            b\"2|1:0\",\n            format_field(timestamp),\n            format_field(name),\n            format_field(value),\n            b''])\n        signature = _create_signature_v2(secret, to_sign)\n        return to_sign + signature\n    else:\n        raise ValueError(\"Unsupported version %d\" % version)\n\n# A leading version number in decimal with no leading zeros, followed by a pipe.\n_signed_value_version_re = re.compile(br\"^([1-9][0-9]*)\\|(.*)$\")\n\ndef decode_signed_value(secret, name, value, max_age_days=31, clock=None,min_version=None):\n    if clock is None:\n        clock = time.time\n    if min_version is None:\n        min_version = DEFAULT_SIGNED_VALUE_MIN_VERSION\n    if min_version > 2:\n        raise ValueError(\"Unsupported min_version %d\" % min_version)\n    if not value:\n        return None\n\n    # Figure out what version this is.  Version 1 did not include an\n    # explicit version field and started with arbitrary base64 data,\n    # which makes this tricky.\n    value = utf8(value)\n    m = _signed_value_version_re.match(value)\n    if m is None:\n        version = 1\n    else:\n        try:\n            version = int(m.group(1))\n            if version > 999:\n                # Certain payloads from the version-less v1 format may\n                # be parsed as valid integers.  Due to base64 padding\n                # restrictions, this can only happen for numbers whose\n                # length is a multiple of 4, so we can treat all\n                # numbers up to 999 as versions, and for the rest we\n                # fall back to v1 format.\n                version = 1\n        except ValueError:\n            version = 1\n\n    if version < min_version:\n        return None\n    if version == 1:\n        return _decode_signed_value_v1(secret, name, value, max_age_days, clock)\n    elif version == 2:\n        return _decode_signed_value_v2(secret, name, value, max_age_days, clock)\n    else:\n        return None\n\ndef _decode_signed_value_v1(secret, name, value, max_age_days, clock):\n    parts = utf8(value).split(b\"|\")\n    if len(parts) != 3:\n        return None\n    signature = _create_signature_v1(secret, name, parts[0], parts[1])\n    if not _time_independent_equals(parts[2], signature):\n        gen_log.warning(\"Invalid cookie signature %r\", value)\n        return None\n    timestamp = int(parts[1])\n    if timestamp < clock() - max_age_days * 86400:\n        gen_log.warning(\"Expired cookie %r\", value)\n        return None\n    if timestamp > clock() + 31 * 86400:\n        # _cookie_signature does not hash a delimiter between the\n        # parts of the cookie, so an attacker could transfer trailing\n        # digits from the payload to the timestamp without altering the\n        # signature.  For backwards compatibility, sanity-check timestamp\n        # here instead of modifying _cookie_signature.\n        gen_log.warning(\"Cookie timestamp in future; possible tampering %r\", value)\n        return None\n    if parts[1].startswith(b\"0\"):\n        gen_log.warning(\"Tampered cookie %r\", value)\n        return None\n    try:\n        return base64.b64decode(parts[0])\n    except Exception:\n        return None\n\n\ndef _decode_signed_value_v2(secret, name, value, max_age_days, clock):\n    def _consume_field(s):\n        length, _, rest = s.partition(b':')\n        n = int(length)\n        field_value = rest[:n]\n        # In python 3, indexing bytes returns small integers; we must\n        # use a slice to get a byte string as in python 2.\n        if rest[n:n+1] != b'|':\n            raise ValueError(\"malformed v2 signed value field\")\n        rest = rest[n+1:]\n        return field_value, rest\n    rest = value[2:]  # remove version number\n    try:\n        key_version, rest = _consume_field(rest)\n        timestamp, rest = _consume_field(rest)\n        name_field, rest = _consume_field(rest)\n        value_field, rest = _consume_field(rest)\n    except ValueError:\n        return None\n    passed_sig = rest\n    signed_string = value[:-len(passed_sig)]\n    expected_sig = _create_signature_v2(secret, signed_string)\n    if not _time_independent_equals(passed_sig, expected_sig):\n        return None\n    if name_field != utf8(name):\n        return None\n    timestamp = int(timestamp)\n    if timestamp < clock() - max_age_days * 86400:\n        # The signature has expired.\n        return None\n    try:\n        return base64.b64decode(value_field)\n    except Exception:\n        return None\n\n\ndef _create_signature_v1(secret, *parts):\n    hash = hmac.new(utf8(secret), digestmod=hashlib.sha1)\n    for part in parts:\n        hash.update(utf8(part))\n    return utf8(hash.hexdigest())\n\ndef _create_signature_v2(secret, s):\n    hash = hmac.new(utf8(secret), digestmod=hashlib.sha256)\n    hash.update(utf8(s))\n    return utf8(hash.hexdigest())\n", "\"\"\"Implementation of the WebSocket protocol.\n\n`WebSockets <http://dev.w3.org/html5/websockets/>`_ allow for bidirectional\ncommunication between the browser and server.\n\n.. warning::\n\n   The WebSocket protocol was recently finalized as `RFC 6455\n   <http://tools.ietf.org/html/rfc6455>`_ and is not yet supported in\n   all browsers.  Refer to http://caniuse.com/websockets for details\n   on compatibility.  In addition, during development the protocol\n   went through several incompatible versions, and some browsers only\n   support older versions.  By default this module only supports the\n   latest version of the protocol, but optional support for an older\n   version (known as \"draft 76\" or \"hixie-76\") can be enabled by\n   overriding `WebSocketHandler.allow_draft76` (see that method's\n   documentation for caveats).\n\"\"\"\n\nfrom __future__ import absolute_import, division, print_function, with_statement\n# Author: Jacob Kristhammar, 2010\n\nimport base64\nimport collections\nimport functools\nimport hashlib\nimport os\nimport struct\nimport time\nimport tornado.escape\nimport tornado.web\n\nfrom tornado.concurrent import TracebackFuture\nfrom tornado.escape import utf8, native_str\nfrom tornado import httpclient, httputil\nfrom tornado.ioloop import IOLoop\nfrom tornado.iostream import StreamClosedError\nfrom tornado.log import gen_log, app_log\nfrom tornado.netutil import Resolver\nfrom tornado import simple_httpclient\nfrom tornado.util import bytes_type, unicode_type, _websocket_mask\n\n\nclass WebSocketError(Exception):\n    pass\n\n\nclass WebSocketClosedError(WebSocketError):\n    \"\"\"Raised by operations on a closed connection.\n\n    .. versionadded:: 3.2\n    \"\"\"\n    pass\n\n\nclass WebSocketHandler(tornado.web.RequestHandler):\n    \"\"\"Subclass this class to create a basic WebSocket handler.\n\n    Override `on_message` to handle incoming messages, and use\n    `write_message` to send messages to the client. You can also\n    override `open` and `on_close` to handle opened and closed\n    connections.\n\n    See http://dev.w3.org/html5/websockets/ for details on the\n    JavaScript interface.  The protocol is specified at\n    http://tools.ietf.org/html/rfc6455.\n\n    Here is an example WebSocket handler that echos back all received messages\n    back to the client::\n\n      class EchoWebSocket(websocket.WebSocketHandler):\n          def open(self):\n              print \"WebSocket opened\"\n\n          def on_message(self, message):\n              self.write_message(u\"You said: \" + message)\n\n          def on_close(self):\n              print \"WebSocket closed\"\n\n    WebSockets are not standard HTTP connections. The \"handshake\" is\n    HTTP, but after the handshake, the protocol is\n    message-based. Consequently, most of the Tornado HTTP facilities\n    are not available in handlers of this type. The only communication\n    methods available to you are `write_message()`, `ping()`, and\n    `close()`. Likewise, your request handler class should implement\n    `open()` method rather than ``get()`` or ``post()``.\n\n    If you map the handler above to ``/websocket`` in your application, you can\n    invoke it in JavaScript with::\n\n      var ws = new WebSocket(\"ws://localhost:8888/websocket\");\n      ws.onopen = function() {\n         ws.send(\"Hello, world\");\n      };\n      ws.onmessage = function (evt) {\n         alert(evt.data);\n      };\n\n    This script pops up an alert box that says \"You said: Hello, world\".\n    \"\"\"\n    def __init__(self, application, request, **kwargs):\n        tornado.web.RequestHandler.__init__(self, application, request,\n                                            **kwargs)\n        self.stream = request.connection.stream\n        self.ws_connection = None\n\n    def _execute(self, transforms, *args, **kwargs):\n        self.open_args = args\n        self.open_kwargs = kwargs\n\n        # Websocket only supports GET method\n        if self.request.method != 'GET':\n            self.stream.write(tornado.escape.utf8(\n                \"HTTP/1.1 405 Method Not Allowed\\r\\n\\r\\n\"\n            ))\n            self.stream.close()\n            return\n\n        # Upgrade header should be present and should be equal to WebSocket\n        if self.request.headers.get(\"Upgrade\", \"\").lower() != 'websocket':\n            self.stream.write(tornado.escape.utf8(\n                \"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\"\n                \"Can \\\"Upgrade\\\" only to \\\"WebSocket\\\".\"\n            ))\n            self.stream.close()\n            return\n\n        # Connection header should be upgrade. Some proxy servers/load balancers\n        # might mess with it.\n        headers = self.request.headers\n        connection = map(lambda s: s.strip().lower(), headers.get(\"Connection\", \"\").split(\",\"))\n        if 'upgrade' not in connection:\n            self.stream.write(tornado.escape.utf8(\n                \"HTTP/1.1 400 Bad Request\\r\\n\\r\\n\"\n                \"\\\"Connection\\\" must be \\\"Upgrade\\\".\"\n            ))\n            self.stream.close()\n            return\n\n        # The difference between version 8 and 13 is that in 8 the\n        # client sends a \"Sec-Websocket-Origin\" header and in 13 it's\n        # simply \"Origin\".\n        if self.request.headers.get(\"Sec-WebSocket-Version\") in (\"7\", \"8\", \"13\"):\n            self.ws_connection = WebSocketProtocol13(self)\n            self.ws_connection.accept_connection()\n        elif (self.allow_draft76() and\n              \"Sec-WebSocket-Version\" not in self.request.headers):\n            self.ws_connection = WebSocketProtocol76(self)\n            self.ws_connection.accept_connection()\n        else:\n            self.stream.write(tornado.escape.utf8(\n                \"HTTP/1.1 426 Upgrade Required\\r\\n\"\n                \"Sec-WebSocket-Version: 8\\r\\n\\r\\n\"))\n            self.stream.close()\n\n    def write_message(self, message, binary=False):\n        \"\"\"Sends the given message to the client of this Web Socket.\n\n        The message may be either a string or a dict (which will be\n        encoded as json).  If the ``binary`` argument is false, the\n        message will be sent as utf8; in binary mode any byte string\n        is allowed.\n\n        If the connection is already closed, raises `WebSocketClosedError`.\n\n        .. versionchanged:: 3.2\n           `WebSocketClosedError` was added (previously a closed connection\n           would raise an `AttributeError`)\n        \"\"\"\n        if self.ws_connection is None:\n            raise WebSocketClosedError()\n        if isinstance(message, dict):\n            message = tornado.escape.json_encode(message)\n        self.ws_connection.write_message(message, binary=binary)\n\n    def select_subprotocol(self, subprotocols):\n        \"\"\"Invoked when a new WebSocket requests specific subprotocols.\n\n        ``subprotocols`` is a list of strings identifying the\n        subprotocols proposed by the client.  This method may be\n        overridden to return one of those strings to select it, or\n        ``None`` to not select a subprotocol.  Failure to select a\n        subprotocol does not automatically abort the connection,\n        although clients may close the connection if none of their\n        proposed subprotocols was selected.\n        \"\"\"\n        return None\n\n    def open(self):\n        \"\"\"Invoked when a new WebSocket is opened.\n\n        The arguments to `open` are extracted from the `tornado.web.URLSpec`\n        regular expression, just like the arguments to\n        `tornado.web.RequestHandler.get`.\n        \"\"\"\n        pass\n\n    def on_message(self, message):\n        \"\"\"Handle incoming messages on the WebSocket\n\n        This method must be overridden.\n        \"\"\"\n        raise NotImplementedError\n\n    def ping(self, data):\n        \"\"\"Send ping frame to the remote end.\"\"\"\n        if self.ws_connection is None:\n            raise WebSocketClosedError()\n        self.ws_connection.write_ping(data)\n\n    def on_pong(self, data):\n        \"\"\"Invoked when the response to a ping frame is received.\"\"\"\n        pass\n\n    def on_close(self):\n        \"\"\"Invoked when the WebSocket is closed.\"\"\"\n        pass\n\n    def close(self):\n        \"\"\"Closes this Web Socket.\n\n        Once the close handshake is successful the socket will be closed.\n        \"\"\"\n        if self.ws_connection:\n            self.ws_connection.close()\n            self.ws_connection = None\n\n    def allow_draft76(self):\n        \"\"\"Override to enable support for the older \"draft76\" protocol.\n\n        The draft76 version of the websocket protocol is disabled by\n        default due to security concerns, but it can be enabled by\n        overriding this method to return True.\n\n        Connections using the draft76 protocol do not support the\n        ``binary=True`` flag to `write_message`.\n\n        Support for the draft76 protocol is deprecated and will be\n        removed in a future version of Tornado.\n        \"\"\"\n        return False\n\n    def set_nodelay(self, value):\n        \"\"\"Set the no-delay flag for this stream.\n\n        By default, small messages may be delayed and/or combined to minimize\n        the number of packets sent.  This can sometimes cause 200-500ms delays\n        due to the interaction between Nagle's algorithm and TCP delayed\n        ACKs.  To reduce this delay (at the expense of possibly increasing\n        bandwidth usage), call ``self.set_nodelay(True)`` once the websocket\n        connection is established.\n\n        See `.BaseIOStream.set_nodelay` for additional details.\n\n        .. versionadded:: 3.1\n        \"\"\"\n        self.stream.set_nodelay(value)\n\n    def get_websocket_scheme(self):\n        \"\"\"Return the url scheme used for this request, either \"ws\" or \"wss\".\n\n        This is normally decided by HTTPServer, but applications\n        may wish to override this if they are using an SSL proxy\n        that does not provide the X-Scheme header as understood\n        by HTTPServer.\n\n        Note that this is only used by the draft76 protocol.\n        \"\"\"\n        return \"wss\" if self.request.protocol == \"https\" else \"ws\"\n\n    def async_callback(self, callback, *args, **kwargs):\n        \"\"\"Obsolete - catches exceptions from the wrapped function.\n\n        This function is normally unncecessary thanks to\n        `tornado.stack_context`.\n        \"\"\"\n        return self.ws_connection.async_callback(callback, *args, **kwargs)\n\n    def _not_supported(self, *args, **kwargs):\n        raise Exception(\"Method not supported for Web Sockets\")\n\n    def on_connection_close(self):\n        if self.ws_connection:\n            self.ws_connection.on_connection_close()\n            self.ws_connection = None\n            self.on_close()\n\n\nfor method in [\"write\", \"redirect\", \"set_header\", \"send_error\", \"set_cookie\",\n               \"set_status\", \"flush\", \"finish\"]:\n    setattr(WebSocketHandler, method, WebSocketHandler._not_supported)\n\n\nclass WebSocketProtocol(object):\n    \"\"\"Base class for WebSocket protocol versions.\n    \"\"\"\n    def __init__(self, handler):\n        self.handler = handler\n        self.request = handler.request\n        self.stream = handler.stream\n        self.client_terminated = False\n        self.server_terminated = False\n\n    def async_callback(self, callback, *args, **kwargs):\n        \"\"\"Wrap callbacks with this if they are used on asynchronous requests.\n\n        Catches exceptions properly and closes this WebSocket if an exception\n        is uncaught.\n        \"\"\"\n        if args or kwargs:\n            callback = functools.partial(callback, *args, **kwargs)\n\n        def wrapper(*args, **kwargs):\n            try:\n                return callback(*args, **kwargs)\n            except Exception:\n                app_log.error(\"Uncaught exception in %s\",\n                              self.request.path, exc_info=True)\n                self._abort()\n        return wrapper\n\n    def on_connection_close(self):\n        self._abort()\n\n    def _abort(self):\n        \"\"\"Instantly aborts the WebSocket connection by closing the socket\"\"\"\n        self.client_terminated = True\n        self.server_terminated = True\n        self.stream.close()  # forcibly tear down the connection\n        self.close()  # let the subclass cleanup\n\n\nclass WebSocketProtocol76(WebSocketProtocol):\n    \"\"\"Implementation of the WebSockets protocol, version hixie-76.\n\n    This class provides basic functionality to process WebSockets requests as\n    specified in\n    http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-76\n    \"\"\"\n    def __init__(self, handler):\n        WebSocketProtocol.__init__(self, handler)\n        self.challenge = None\n        self._waiting = None\n\n    def accept_connection(self):\n        try:\n            self._handle_websocket_headers()\n        except ValueError:\n            gen_log.debug(\"Malformed WebSocket request received\")\n            self._abort()\n            return\n\n        scheme = self.handler.get_websocket_scheme()\n\n        # draft76 only allows a single subprotocol\n        subprotocol_header = ''\n        subprotocol = self.request.headers.get(\"Sec-WebSocket-Protocol\", None)\n        if subprotocol:\n            selected = self.handler.select_subprotocol([subprotocol])\n            if selected:\n                assert selected == subprotocol\n                subprotocol_header = \"Sec-WebSocket-Protocol: %s\\r\\n\" % selected\n\n        # Write the initial headers before attempting to read the challenge.\n        # This is necessary when using proxies (such as HAProxy), which\n        # need to see the Upgrade headers before passing through the\n        # non-HTTP traffic that follows.\n        self.stream.write(tornado.escape.utf8(\n            \"HTTP/1.1 101 WebSocket Protocol Handshake\\r\\n\"\n            \"Upgrade: WebSocket\\r\\n\"\n            \"Connection: Upgrade\\r\\n\"\n            \"Server: TornadoServer/%(version)s\\r\\n\"\n            \"Sec-WebSocket-Origin: %(origin)s\\r\\n\"\n            \"Sec-WebSocket-Location: %(scheme)s://%(host)s%(uri)s\\r\\n\"\n            \"%(subprotocol)s\"\n            \"\\r\\n\" % (dict(\n                version=tornado.version,\n                origin=self.request.headers[\"Origin\"],\n                scheme=scheme,\n                host=self.request.host,\n                uri=self.request.uri,\n                subprotocol=subprotocol_header))))\n        self.stream.read_bytes(8, self._handle_challenge)\n\n    def challenge_response(self, challenge):\n        \"\"\"Generates the challenge response that's needed in the handshake\n\n        The challenge parameter should be the raw bytes as sent from the\n        client.\n        \"\"\"\n        key_1 = self.request.headers.get(\"Sec-Websocket-Key1\")\n        key_2 = self.request.headers.get(\"Sec-Websocket-Key2\")\n        try:\n            part_1 = self._calculate_part(key_1)\n            part_2 = self._calculate_part(key_2)\n        except ValueError:\n            raise ValueError(\"Invalid Keys/Challenge\")\n        return self._generate_challenge_response(part_1, part_2, challenge)\n\n    def _handle_challenge(self, challenge):\n        try:\n            challenge_response = self.challenge_response(challenge)\n        except ValueError:\n            gen_log.debug(\"Malformed key data in WebSocket request\")\n            self._abort()\n            return\n        self._write_response(challenge_response)\n\n    def _write_response(self, challenge):\n        self.stream.write(challenge)\n        self.async_callback(self.handler.open)(*self.handler.open_args, **self.handler.open_kwargs)\n        self._receive_message()\n\n    def _handle_websocket_headers(self):\n        \"\"\"Verifies all invariant- and required headers\n\n        If a header is missing or have an incorrect value ValueError will be\n        raised\n        \"\"\"\n        fields = (\"Origin\", \"Host\", \"Sec-Websocket-Key1\",\n                  \"Sec-Websocket-Key2\")\n        if not all(map(lambda f: self.request.headers.get(f), fields)):\n            raise ValueError(\"Missing/Invalid WebSocket headers\")\n\n    def _calculate_part(self, key):\n        \"\"\"Processes the key headers and calculates their key value.\n\n        Raises ValueError when feed invalid key.\"\"\"\n        # pyflakes complains about variable reuse if both of these lines use 'c'\n        number = int(''.join(c for c in key if c.isdigit()))\n        spaces = len([c2 for c2 in key if c2.isspace()])\n        try:\n            key_number = number // spaces\n        except (ValueError, ZeroDivisionError):\n            raise ValueError\n        return struct.pack(\">I\", key_number)\n\n    def _generate_challenge_response(self, part_1, part_2, part_3):\n        m = hashlib.md5()\n        m.update(part_1)\n        m.update(part_2)\n        m.update(part_3)\n        return m.digest()\n\n    def _receive_message(self):\n        self.stream.read_bytes(1, self._on_frame_type)\n\n    def _on_frame_type(self, byte):\n        frame_type = ord(byte)\n        if frame_type == 0x00:\n            self.stream.read_until(b\"\\xff\", self._on_end_delimiter)\n        elif frame_type == 0xff:\n            self.stream.read_bytes(1, self._on_length_indicator)\n        else:\n            self._abort()\n\n    def _on_end_delimiter(self, frame):\n        if not self.client_terminated:\n            self.async_callback(self.handler.on_message)(\n                frame[:-1].decode(\"utf-8\", \"replace\"))\n        if not self.client_terminated:\n            self._receive_message()\n\n    def _on_length_indicator(self, byte):\n        if ord(byte) != 0x00:\n            self._abort()\n            return\n        self.client_terminated = True\n        self.close()\n\n    def write_message(self, message, binary=False):\n        \"\"\"Sends the given message to the client of this Web Socket.\"\"\"\n        if binary:\n            raise ValueError(\n                \"Binary messages not supported by this version of websockets\")\n        if isinstance(message, unicode_type):\n            message = message.encode(\"utf-8\")\n        assert isinstance(message, bytes_type)\n        self.stream.write(b\"\\x00\" + message + b\"\\xff\")\n\n    def write_ping(self, data):\n        \"\"\"Send ping frame.\"\"\"\n        raise ValueError(\"Ping messages not supported by this version of websockets\")\n\n    def close(self):\n        \"\"\"Closes the WebSocket connection.\"\"\"\n        if not self.server_terminated:\n            if not self.stream.closed():\n                self.stream.write(\"\\xff\\x00\")\n            self.server_terminated = True\n        if self.client_terminated:\n            if self._waiting is not None:\n                self.stream.io_loop.remove_timeout(self._waiting)\n            self._waiting = None\n            self.stream.close()\n        elif self._waiting is None:\n            self._waiting = self.stream.io_loop.add_timeout(\n                time.time() + 5, self._abort)\n\n\nclass WebSocketProtocol13(WebSocketProtocol):\n    \"\"\"Implementation of the WebSocket protocol from RFC 6455.\n\n    This class supports versions 7 and 8 of the protocol in addition to the\n    final version 13.\n    \"\"\"\n    def __init__(self, handler, mask_outgoing=False):\n        WebSocketProtocol.__init__(self, handler)\n        self.mask_outgoing = mask_outgoing\n        self._final_frame = False\n        self._frame_opcode = None\n        self._masked_frame = None\n        self._frame_mask = None\n        self._frame_length = None\n        self._fragmented_message_buffer = None\n        self._fragmented_message_opcode = None\n        self._waiting = None\n\n    def accept_connection(self):\n        try:\n            self._handle_websocket_headers()\n            self._accept_connection()\n        except ValueError:\n            gen_log.debug(\"Malformed WebSocket request received\", exc_info=True)\n            self._abort()\n            return\n\n    def _handle_websocket_headers(self):\n        \"\"\"Verifies all invariant- and required headers\n\n        If a header is missing or have an incorrect value ValueError will be\n        raised\n        \"\"\"\n        fields = (\"Host\", \"Sec-Websocket-Key\", \"Sec-Websocket-Version\")\n        if not all(map(lambda f: self.request.headers.get(f), fields)):\n            raise ValueError(\"Missing/Invalid WebSocket headers\")\n\n    @staticmethod\n    def compute_accept_value(key):\n        \"\"\"Computes the value for the Sec-WebSocket-Accept header,\n        given the value for Sec-WebSocket-Key.\n        \"\"\"\n        sha1 = hashlib.sha1()\n        sha1.update(utf8(key))\n        sha1.update(b\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\")  # Magic value\n        return native_str(base64.b64encode(sha1.digest()))\n\n    def _challenge_response(self):\n        return WebSocketProtocol13.compute_accept_value(\n            self.request.headers.get(\"Sec-Websocket-Key\"))\n\n    def _accept_connection(self):\n        subprotocol_header = ''\n        subprotocols = self.request.headers.get(\"Sec-WebSocket-Protocol\", '')\n        subprotocols = [s.strip() for s in subprotocols.split(',')]\n        if subprotocols:\n            selected = self.handler.select_subprotocol(subprotocols)\n            if selected:\n                assert selected in subprotocols\n                subprotocol_header = \"Sec-WebSocket-Protocol: %s\\r\\n\" % selected\n\n        self.stream.write(tornado.escape.utf8(\n            \"HTTP/1.1 101 Switching Protocols\\r\\n\"\n            \"Upgrade: websocket\\r\\n\"\n            \"Connection: Upgrade\\r\\n\"\n            \"Sec-WebSocket-Accept: %s\\r\\n\"\n            \"%s\"\n            \"\\r\\n\" % (self._challenge_response(), subprotocol_header)))\n\n        self.async_callback(self.handler.open)(*self.handler.open_args, **self.handler.open_kwargs)\n        self._receive_frame()\n\n    def _write_frame(self, fin, opcode, data):\n        if fin:\n            finbit = 0x80\n        else:\n            finbit = 0\n        frame = struct.pack(\"B\", finbit | opcode)\n        l = len(data)\n        if self.mask_outgoing:\n            mask_bit = 0x80\n        else:\n            mask_bit = 0\n        if l < 126:\n            frame += struct.pack(\"B\", l | mask_bit)\n        elif l <= 0xFFFF:\n            frame += struct.pack(\"!BH\", 126 | mask_bit, l)\n        else:\n            frame += struct.pack(\"!BQ\", 127 | mask_bit, l)\n        if self.mask_outgoing:\n            mask = os.urandom(4)\n            data = mask + _websocket_mask(mask, data)\n        frame += data\n        self.stream.write(frame)\n\n    def write_message(self, message, binary=False):\n        \"\"\"Sends the given message to the client of this Web Socket.\"\"\"\n        if binary:\n            opcode = 0x2\n        else:\n            opcode = 0x1\n        message = tornado.escape.utf8(message)\n        assert isinstance(message, bytes_type)\n        try:\n            self._write_frame(True, opcode, message)\n        except StreamClosedError:\n            self._abort()\n\n    def write_ping(self, data):\n        \"\"\"Send ping frame.\"\"\"\n        assert isinstance(data, bytes_type)\n        self._write_frame(True, 0x9, data)\n\n    def _receive_frame(self):\n        try:\n            self.stream.read_bytes(2, self._on_frame_start)\n        except StreamClosedError:\n            self._abort()\n\n    def _on_frame_start(self, data):\n        header, payloadlen = struct.unpack(\"BB\", data)\n        self._final_frame = header & 0x80\n        reserved_bits = header & 0x70\n        self._frame_opcode = header & 0xf\n        self._frame_opcode_is_control = self._frame_opcode & 0x8\n        if reserved_bits:\n            # client is using as-yet-undefined extensions; abort\n            self._abort()\n            return\n        self._masked_frame = bool(payloadlen & 0x80)\n        payloadlen = payloadlen & 0x7f\n        if self._frame_opcode_is_control and payloadlen >= 126:\n            # control frames must have payload < 126\n            self._abort()\n            return\n        try:\n            if payloadlen < 126:\n                self._frame_length = payloadlen\n                if self._masked_frame:\n                    self.stream.read_bytes(4, self._on_masking_key)\n                else:\n                    self.stream.read_bytes(self._frame_length, self._on_frame_data)\n            elif payloadlen == 126:\n                self.stream.read_bytes(2, self._on_frame_length_16)\n            elif payloadlen == 127:\n                self.stream.read_bytes(8, self._on_frame_length_64)\n        except StreamClosedError:\n            self._abort()\n\n    def _on_frame_length_16(self, data):\n        self._frame_length = struct.unpack(\"!H\", data)[0]\n        try:\n            if self._masked_frame:\n                self.stream.read_bytes(4, self._on_masking_key)\n            else:\n                self.stream.read_bytes(self._frame_length, self._on_frame_data)\n        except StreamClosedError:\n            self._abort()\n\n    def _on_frame_length_64(self, data):\n        self._frame_length = struct.unpack(\"!Q\", data)[0]\n        try:\n            if self._masked_frame:\n                self.stream.read_bytes(4, self._on_masking_key)\n            else:\n                self.stream.read_bytes(self._frame_length, self._on_frame_data)\n        except StreamClosedError:\n            self._abort()\n\n    def _on_masking_key(self, data):\n        self._frame_mask = data\n        try:\n            self.stream.read_bytes(self._frame_length, self._on_masked_frame_data)\n        except StreamClosedError:\n            self._abort()\n\n    def _on_masked_frame_data(self, data):\n        self._on_frame_data(_websocket_mask(self._frame_mask, data))\n\n    def _on_frame_data(self, data):\n        if self._frame_opcode_is_control:\n            # control frames may be interleaved with a series of fragmented\n            # data frames, so control frames must not interact with\n            # self._fragmented_*\n            if not self._final_frame:\n                # control frames must not be fragmented\n                self._abort()\n                return\n            opcode = self._frame_opcode\n        elif self._frame_opcode == 0:  # continuation frame\n            if self._fragmented_message_buffer is None:\n                # nothing to continue\n                self._abort()\n                return\n            self._fragmented_message_buffer += data\n            if self._final_frame:\n                opcode = self._fragmented_message_opcode\n                data = self._fragmented_message_buffer\n                self._fragmented_message_buffer = None\n        else:  # start of new data message\n            if self._fragmented_message_buffer is not None:\n                # can't start new message until the old one is finished\n                self._abort()\n                return\n            if self._final_frame:\n                opcode = self._frame_opcode\n            else:\n                self._fragmented_message_opcode = self._frame_opcode\n                self._fragmented_message_buffer = data\n\n        if self._final_frame:\n            self._handle_message(opcode, data)\n\n        if not self.client_terminated:\n            self._receive_frame()\n\n    def _handle_message(self, opcode, data):\n        if self.client_terminated:\n            return\n\n        if opcode == 0x1:\n            # UTF-8 data\n            try:\n                decoded = data.decode(\"utf-8\")\n            except UnicodeDecodeError:\n                self._abort()\n                return\n            self.async_callback(self.handler.on_message)(decoded)\n        elif opcode == 0x2:\n            # Binary data\n            self.async_callback(self.handler.on_message)(data)\n        elif opcode == 0x8:\n            # Close\n            self.client_terminated = True\n            self.close()\n        elif opcode == 0x9:\n            # Ping\n            self._write_frame(True, 0xA, data)\n        elif opcode == 0xA:\n            # Pong\n            self.async_callback(self.handler.on_pong)(data)\n        else:\n            self._abort()\n\n    def close(self):\n        \"\"\"Closes the WebSocket connection.\"\"\"\n        if not self.server_terminated:\n            if not self.stream.closed():\n                self._write_frame(True, 0x8, b\"\")\n            self.server_terminated = True\n        if self.client_terminated:\n            if self._waiting is not None:\n                self.stream.io_loop.remove_timeout(self._waiting)\n                self._waiting = None\n            self.stream.close()\n        elif self._waiting is None:\n            # Give the client a few seconds to complete a clean shutdown,\n            # otherwise just close the connection.\n            self._waiting = self.stream.io_loop.add_timeout(\n                self.stream.io_loop.time() + 5, self._abort)\n\n\nclass WebSocketClientConnection(simple_httpclient._HTTPConnection):\n    \"\"\"WebSocket client connection.\n\n    This class should not be instantiated directly; use the\n    `websocket_connect` function instead.\n    \"\"\"\n    def __init__(self, io_loop, request):\n        self.connect_future = TracebackFuture()\n        self.read_future = None\n        self.read_queue = collections.deque()\n        self.key = base64.b64encode(os.urandom(16))\n\n        scheme, sep, rest = request.url.partition(':')\n        scheme = {'ws': 'http', 'wss': 'https'}[scheme]\n        request.url = scheme + sep + rest\n        request.headers.update({\n            'Upgrade': 'websocket',\n            'Connection': 'Upgrade',\n            'Sec-WebSocket-Key': self.key,\n            'Sec-WebSocket-Version': '13',\n        })\n\n        self.resolver = Resolver(io_loop=io_loop)\n        super(WebSocketClientConnection, self).__init__(\n            io_loop, None, request, lambda: None, self._on_http_response,\n            104857600, self.resolver)\n\n    def close(self):\n        \"\"\"Closes the websocket connection.\n\n        .. versionadded:: 3.2\n        \"\"\"\n        if self.protocol is not None:\n            self.protocol.close()\n            self.protocol = None\n\n    def _on_close(self):\n        self.on_message(None)\n        self.resolver.close()\n        super(WebSocketClientConnection, self)._on_close()\n\n    def _on_http_response(self, response):\n        if not self.connect_future.done():\n            if response.error:\n                self.connect_future.set_exception(response.error)\n            else:\n                self.connect_future.set_exception(WebSocketError(\n                    \"Non-websocket response\"))\n\n    def _handle_1xx(self, code):\n        assert code == 101\n        assert self.headers['Upgrade'].lower() == 'websocket'\n        assert self.headers['Connection'].lower() == 'upgrade'\n        accept = WebSocketProtocol13.compute_accept_value(self.key)\n        assert self.headers['Sec-Websocket-Accept'] == accept\n\n        self.protocol = WebSocketProtocol13(self, mask_outgoing=True)\n        self.protocol._receive_frame()\n\n        if self._timeout is not None:\n            self.io_loop.remove_timeout(self._timeout)\n            self._timeout = None\n\n        self.connect_future.set_result(self)\n\n    def write_message(self, message, binary=False):\n        \"\"\"Sends a message to the WebSocket server.\"\"\"\n        self.protocol.write_message(message, binary)\n\n    def read_message(self, callback=None):\n        \"\"\"Reads a message from the WebSocket server.\n\n        Returns a future whose result is the message, or None\n        if the connection is closed.  If a callback argument\n        is given it will be called with the future when it is\n        ready.\n        \"\"\"\n        assert self.read_future is None\n        future = TracebackFuture()\n        if self.read_queue:\n            future.set_result(self.read_queue.popleft())\n        else:\n            self.read_future = future\n        if callback is not None:\n            self.io_loop.add_future(future, callback)\n        return future\n\n    def on_message(self, message):\n        if self.read_future is not None:\n            self.read_future.set_result(message)\n            self.read_future = None\n        else:\n            self.read_queue.append(message)\n\n    def on_pong(self, data):\n        pass\n\n\ndef websocket_connect(url, io_loop=None, callback=None, connect_timeout=None):\n    \"\"\"Client-side websocket support.\n\n    Takes a url and returns a Future whose result is a\n    `WebSocketClientConnection`.\n\n    .. versionchanged:: 3.2\n       Also accepts ``HTTPRequest`` objects in place of urls.\n    \"\"\"\n    if io_loop is None:\n        io_loop = IOLoop.current()\n    if isinstance(url, httpclient.HTTPRequest):\n        assert connect_timeout is None\n        request = url\n        # Copy and convert the headers dict/object (see comments in\n        # AsyncHTTPClient.fetch)\n        request.headers = httputil.HTTPHeaders(request.headers)\n    else:\n        request = httpclient.HTTPRequest(url, connect_timeout=connect_timeout)\n    request = httpclient._RequestProxy(\n        request, httpclient.HTTPRequest._DEFAULTS)\n    conn = WebSocketClientConnection(io_loop, request)\n    if callback is not None:\n        io_loop.add_future(conn.connect_future, callback)\n    return conn.connect_future\n"], "filenames": ["tornado/test/web_test.py", "tornado/test/websocket_test.py", "tornado/util.py", "tornado/web.py", "tornado/websocket.py"], "buggy_code_start_loc": [2006, 13, 14, 75, 23], "buggy_code_end_loc": [2019, 23, 267, 1109, 928], "fixing_code_start_loc": [2007, 14, 15, 74, 22], "fixing_code_end_loc": [2022, 24, 311, 1152, 886], "type": "CWE-203", "message": "Tornado before 3.2.2 sends arbitrary responses that contain a fixed CSRF token and may be sent with HTTP compression, which makes it easier for remote attackers to conduct a BREACH attack and determine this token via a series of crafted requests.", "other": {"cve": {"id": "CVE-2014-9720", "sourceIdentifier": "cve@mitre.org", "published": "2020-01-24T18:15:12.053", "lastModified": "2020-01-28T16:42:34.383", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Tornado before 3.2.2 sends arbitrary responses that contain a fixed CSRF token and may be sent with HTTP compression, which makes it easier for remote attackers to conduct a BREACH attack and determine this token via a series of crafted requests."}, {"lang": "es", "value": "Tornado versiones anteriores a 3.2.2, env\u00eda respuestas arbitrarias que contienen un token de tipo CSRF fijo y pueden ser enviadas con compresi\u00f3n HTTP, lo que facilita a atacantes remotos conducir un ataque de tipo BREACH y determinar este token por medio de una serie de peticiones dise\u00f1adas."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tornadoweb:tornado:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.2", "matchCriteriaId": "E20BDD81-6AC3-41B3-80E5-1BFE2E7B895A"}]}]}], "references": [{"url": "http://openwall.com/lists/oss-security/2015/05/19/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.tornadoweb.org/en/stable/releases/v3.2.2.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://bugzilla.novell.com/show_bug.cgi?id=930362", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1222816", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/tornadoweb/tornado/commit/1c36307463b1e8affae100bf9386948e6c1b2308", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/tornadoweb/tornado/commit/1c36307463b1e8affae100bf9386948e6c1b2308"}}