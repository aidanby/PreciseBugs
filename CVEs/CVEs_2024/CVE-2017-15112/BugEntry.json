{"buggy_code": ["#!/usr/bin/python\n\nfrom __future__ import print_function\n\nimport argparse\nimport base64\nimport copy\nfrom lxml import etree\nimport getpass\nimport grp\nimport jinja2\nfrom keycloak_httpd_client import keycloak_cli\nimport logging\nimport logging.handlers\nfrom collections import namedtuple\nimport os\nimport pwd\nimport re\nfrom keycloak_httpd_client.keycloak_cli import RESTError\nimport requests\nimport shutil\nimport six\nimport socket\nimport subprocess\nimport sys\nimport tempfile\nimport traceback\n\n\nfrom six.moves.urllib.parse import quote as urlquote\nfrom six.moves.urllib.parse import urlsplit, urlunsplit\n\n# ----------------------------- Global Variables ------------------------------\n\nlogger = None\ntemplate_env = None\nprog_name = os.path.basename(sys.argv[0])\nLOG_FILE_ROTATION_COUNT = 3\nBIN_TIMEOUT = \"/usr/bin/timeout\"\n\n# -------------------------------- Constants ----------------------------------\n\nDEV_NULL = '/dev/null'\nBIN_TIMEOUT = '/usr/bin/timeout'\n\nHTTPD_SAML_DIR = 'saml2'\nHTTPD_CONF_DIR = 'conf.d'\n\nMELLON_METADATA_TEMPLATE = 'sp_metadata.tpl'\nMELLON_METADATA = 'sp_metadata.xml'\n\nMELLON_HTTPD_CONFIG_TEMPLATE = 'mellon_httpd.conf'\n\nSTATUS_SUCCESS = 0\nSTATUS_OPERATION_ERROR = 1\nSTATUS_CONFIGURATION_ERROR = 2  # Must be 2 to match argparse exit status\nSTATUS_INSUFFICIENT_PRIVILEGE = 3\nSTATUS_COMMUNICATION_ERROR = 4\nSTATUS_ALREADY_EXISTS_ERROR = 5\n\nSAML_PAOS_BINDING='urn:oasis:names:tc:SAML:2.0:bindings:PAOS'\n\n# --------------------------- Exception Definitions ---------------------------\n\n\nclass AlreadyExistsError(ValueError):\n    pass\n\n# --------------------------- Logging Configuration ---------------------------\n\n\ndef configure_logging(options):\n    global logger  # pylint: disable=W0603\n\n    STEP = logging.INFO + 1\n\n    class StepLogger(logging.Logger):\n\n        def __init__(self, name):\n            self.step_number = 1\n            super(StepLogger, self).__init__(name)\n\n        def step(self, msg, *args, **kwargs):\n            if self.isEnabledFor(STEP):\n                self._log(STEP, ('[Step %2d] ' % self.step_number) + msg,\n                          args, **kwargs)\n                self.step_number += 1\n\n    logging.addLevelName(STEP, 'STEP')\n    logging.setLoggerClass(StepLogger)\n\n    log_dir = os.path.dirname(options.log_file)\n    if os.path.exists(log_dir):\n        if not os.path.isdir(log_dir):\n            raise ValueError('logging directory \"{log_dir}\" exists but is not '\n                             'directory'.format(log_dir=log_dir))\n    else:\n        os.makedirs(log_dir)\n\n    # Check if log exists and should therefore be rolled\n    need_roll = os.path.isfile(options.log_file)\n\n    log_level = STEP\n    if options.verbose:\n        log_level = logging.INFO\n    if options.debug:\n        log_level = logging.DEBUG\n\n        # These two lines enable debugging at httplib level\n        # (requests->urllib3->http.client) You will see the REQUEST,\n        # including HEADERS and DATA, and RESPONSE with HEADERS but\n        # without DATA.  The only thing missing will be the\n        # response.body which is not logged.\n        try:\n            import http.client as http_client  # Python 3\n        except ImportError:\n            import httplib as http_client      # Python 2\n\n        http_client.HTTPConnection.debuglevel = 1\n\n        # Turn on cookielib debugging\n        if False:\n            try:\n                import http.cookiejar as cookiejar\n            except ImportError:\n                import cookielib as cookiejar  # Python 2\n            cookiejar.debug = True\n\n    root_logger = logging.getLogger()\n    logger = logging.getLogger(prog_name)\n\n    try:\n        file_handler = logging.handlers.RotatingFileHandler(\n            options.log_file, mode='w', backupCount=LOG_FILE_ROTATION_COUNT)\n    except IOError as e:\n        print('Unable to open log file %s (%s)' % (options.log_file, e),\n              file=sys.stderr)\n\n    else:\n        formatter = logging.Formatter(\n            '%(asctime)s %(name)s %(levelname)s: %(message)s')\n        file_handler.setFormatter(formatter)\n        file_handler.setLevel(logging.DEBUG)\n        root_logger.addHandler(file_handler)\n\n        if need_roll:\n            file_handler.doRollover()\n\n    console_handler = logging.StreamHandler(sys.stdout)\n    formatter = logging.Formatter('%(message)s')\n    console_handler.setFormatter(formatter)\n    console_handler.setLevel(log_level)\n    root_logger.addHandler(console_handler)\n\n    # Set the log level on the logger to the lowest level\n    # possible. This allows the message to be emitted from the logger\n    # to it's handlers where the level will be filtered on a per\n    # handler basis.\n    root_logger.setLevel(1)\n\n# ----------------------------- General Utilities -----------------------------\n\ndef join_path(*args):\n    '''Join each argument into a final path assuring there is\n    exactly one slash separating all components in the final path\n    and there are no leading or trailing spaces between path components.\n    Initial or final slashes are preserved but are collapsed into a\n    single slash.\n\n    Why not use posixpath.join and posixpath.normpath? Because they do not\n    handle multiple slashes, leading and trailing slashes the way we want'''\n\n    if not args:\n        return ''\n\n    components = []\n\n    for item in args:\n        components.extend(item.split('/'))\n        \n    if components[0]:\n        leading_slash = False\n    else:\n        leading_slash = True \n\n    if components[-1]:\n        trailing_slash = False\n    else:\n        trailing_slash = True\n\n    components = [x.strip() for x in components if x]\n\n    path = '/'.join(components)\n\n    if leading_slash:\n        path = '/' + path\n\n    if trailing_slash and components:\n        path = path + '/'\n\n    return path\n\n# -------------------------- Shell Command Utilities --------------------------\n\n\ndef nolog_replace(string, nolog):\n    \"\"\"Replace occurences of strings given in `nolog` with XXXXXXXX\"\"\"\n    for value in nolog:\n        if not isinstance(value, six.string_types):\n            continue\n\n        quoted = urlquote(value)\n        shquoted = shell_quote(value)\n        for nolog_value in (shquoted, value, quoted):\n            string = string.replace(nolog_value, 'XXXXXXXX')\n    return string\n\n\ndef shell_quote(string):\n    return \"'\" + string.replace(\"'\", \"'\\\\''\") + \"'\"\n\n\ndef run_cmd(args, stdin=None, raiseonerr=True,\n            nolog=(), env=None, capture_output=True, skip_output=False,\n            cwd=None, runas=None, timeout=None, suplementary_groups=[]):\n    \"\"\"\n    Execute a command and return stdin, stdout and the process return code.\n\n    :param args: List of arguments for the command\n    :param stdin: Optional input to the command\n    :param raiseonerr: If True, raises an exception if the return code is\n        not zero\n    :param nolog: Tuple of strings that shouldn't be logged, like passwords.\n        Each tuple consists of a string to be replaced by XXXXXXXX.\n\n        Example:\n        We have a command\n            [paths.SETPASSWD, '--password', 'Secret123', 'someuser']\n        and we don't want to log the password so nolog would be set to:\n        ('Secret123',)\n        The resulting log output would be:\n\n        /usr/bin/setpasswd --password XXXXXXXX someuser\n\n        If a value isn't found in the list it is silently ignored.\n    :param env: Dictionary of environment variables passed to the command.\n        When None, current environment is copied\n    :param capture_output: Capture stderr and stdout\n    :param skip_output: Redirect the output to /dev/null and do not capture it\n    :param cwd: Current working directory\n    :param runas: Name of a user that the command should be run as. The spawned\n        process will have both real and effective UID and GID set.\n    :param timeout: Timeout if the command hasn't returned within the specified\n        number of seconds.\n    :param suplementary_groups: List of group names that will be used as\n        suplementary groups for subporcess.\n        The option runas must be specified together with this option.\n    \"\"\"\n    assert isinstance(suplementary_groups, list)\n    p_in = None\n    p_out = None\n    p_err = None\n\n    if isinstance(nolog, six.string_types):\n        # We expect a tuple (or list, or other iterable) of nolog strings.\n        # Passing just a single string is bad: strings are also, so this\n        # would result in every individual character of that string being\n        # replaced by XXXXXXXX.\n        # This is a sanity check to prevent that.\n        raise ValueError('nolog must be a tuple of strings.')\n\n    if env is None:\n        # copy default env\n        env = copy.deepcopy(os.environ)\n        env[\"PATH\"] = (\n            \"/bin:/sbin:/usr/kerberos/bin:\"\n            \"/usr/kerberos/sbin:/usr/bin:/usr/sbin\")\n    if stdin:\n        p_in = subprocess.PIPE\n    if skip_output:\n        p_out = p_err = open(DEV_NULL, 'w')\n    elif capture_output:\n        p_out = subprocess.PIPE\n        p_err = subprocess.PIPE\n\n    if timeout:\n        # If a timeout was provided, use the timeout command\n        # to execute the requested command.\n        args[0:0] = [BIN_TIMEOUT, str(timeout)]\n\n    arg_string = nolog_replace(' '.join(shell_quote(a) for a in args), nolog)\n    logger.debug('Starting external process')\n    logger.debug('args=%s' % arg_string)\n\n    preexec_fn = None\n    if runas is not None:\n        pent = pwd.getpwnam(runas)\n\n        suplementary_gids = [\n            grp.getgrnam(group).gr_gid for group in suplementary_groups\n        ]\n\n        logger.debug('runas=%s (UID %d, GID %s)', runas,\n                     pent.pw_uid, pent.pw_gid)\n        if suplementary_groups:\n            for group, gid in zip(suplementary_groups, suplementary_gids):\n                logger.debug('suplementary_group=%s (GID %d)', group, gid)\n\n        preexec_fn = lambda: (\n            os.setgroups(suplementary_gids),\n            os.setregid(pent.pw_gid, pent.pw_gid),\n            os.setreuid(pent.pw_uid, pent.pw_uid),\n        )\n\n    try:\n        p = subprocess.Popen(args, stdin=p_in, stdout=p_out, stderr=p_err,\n                             close_fds=True, env=env, cwd=cwd,\n                             preexec_fn=preexec_fn)\n        stdout, stderr = p.communicate(stdin)\n        stdout, stderr = str(stdout), str(stderr)    # Make pylint happy\n    except KeyboardInterrupt:\n        logger.debug('Process interrupted')\n        p.wait()\n        raise\n    except:\n        logger.debug('Process execution failed')\n        raise\n    finally:\n        if skip_output:\n            p_out.close()   # pylint: disable=E1103\n\n    if timeout and p.returncode == 124:\n        logger.debug('Process did not complete before timeout')\n\n    logger.debug('Process finished, return code=%s', p.returncode)\n\n    # The command and its output may include passwords that we don't want\n    # to log. Replace those.\n    if capture_output and not skip_output:\n        stdout = nolog_replace(stdout, nolog)\n        stderr = nolog_replace(stderr, nolog)\n        logger.debug('stdout=%s' % stdout)\n        logger.debug('stderr=%s' % stderr)\n\n    if p.returncode != 0 and raiseonerr:\n        raise subprocess.CalledProcessError(p.returncode, arg_string, stdout)\n\n    return (stdout, stderr, p.returncode)\n\n\ndef install_file(src_file, dst_file):\n    logger.debug('install_file dst_file=\"%s\"', dst_file)\n    if os.path.exists(dst_file):\n        if not os.path.isfile(dst_file):\n            raise ValueError('install file \"{dst_file}\" exists but is not '\n                             'plain file'.format(dst_file=dst_file))\n        dst_backup_file = dst_file + \".orig\"\n        if not os.path.exists(dst_backup_file):\n            os.rename(dst_file, dst_backup_file)\n    shutil.copy(src_file, dst_file)\n\n\ndef install_file_from_data(data, dst_file):\n    logger.debug('install_file_from_data dst_file=\"%s\"', dst_file)\n    if os.path.exists(dst_file):\n        if not os.path.isfile(dst_file):\n            raise ValueError('install file \"{dst_file}\" exists but is not '\n                             'plain file'.format(dst_file=dst_file))\n        dst_backup_file = dst_file + \".orig\"\n        if not os.path.exists(dst_backup_file):\n            os.rename(dst_file, dst_backup_file)\n    with open(dst_file, 'w') as f:\n        f.write(data)\n\n\ndef mkdir(pathname, mode=0o775):\n    logger.debug('mkdir pathname=\"%s\" mode=%#o', pathname, mode)\n    if os.path.exists(pathname):\n        if not os.path.isdir(pathname):\n            raise ValueError('mkdir \"{pathname}\" exists but is not '\n                             'directory'.format(pathname=pathname))\n    else:\n        os.makedirs(pathname, mode)\n\n\ndef httpd_restart():\n    cmd = ['/usr/bin/systemctl', 'restart', 'httpd.service']\n    run_cmd(cmd)\n\n# ----------------------------- HTTP Utilities --------------------------------\n\ndef normalize_url(url, default_scheme='https'):\n    '''Assure scheme and port are canonical.\n\n    SAML requires a scheme for URL's, if a scheme is not present add a\n    default scheme.\n\n    Strip the port from the URL if it matches the scheme (e.g. 80 for\n    http and 443 for https)\n\n    Explicitly specifying a default port (e.g. http://example.com:80\n    or https://example.com:443) will cause Mellon to fail. This occurs\n    because the port gets embedded into the location URL for each\n    endpoint in the SP metadata (e.g the Assertion Consumer\n    Service). The IdP sets the Destination attribute in the SAML\n    response by looking it up in the SP metadata, thus the Destination\n    will have the default port in it (e.g. 443). Upon receiving the\n    SAML response the SP compares the URL of the request to the\n    Destination attribute in the SAML response, they must match for\n    the response to be considered valid. However when Mellon asks\n    Apache what the request URL was it won't have the port in it thus\n    the URL comparison fails. So why is the port absent? It turns out\n    that most (all?) browsers will strip the port from a URL if it\n    matches the port for the scheme (e.g. 80 for http and 443 for\n    https). Thus even if you include the port in the URL it will never\n    be included in the URL the browser emits. This also includes\n    stripping the port from the HTTP host header (which Apache uses to\n    reconstruct the URL).\n    '''\n\n    s = urlsplit(url)\n    scheme = s.scheme\n    netloc = s.netloc\n    path = s.path\n    query = s.query\n    fragment = s.fragment\n    hostname = s.hostname\n    port = s.port\n    \n    if not scheme:\n        scheme = default_scheme\n\n    if port is not None:\n        if scheme == 'http' and port == 80:\n            port = None\n        elif scheme == 'https' and port == 443:\n            port = None\n\n    if port is None:\n        netloc = hostname\n    else:\n        netloc = \"%s:%d\" % (hostname, port)\n\n    return urlunsplit((scheme, netloc, path, query, fragment))\n\n# ------------------------------ PEM Utilities --------------------------------\n\n\nclass InvalidBase64Error(ValueError):\n    pass\n\npem_headers = {\n    'csr': 'NEW CERTIFICATE REQUEST',\n    'cert': 'CERTIFICATE',\n    'crl': 'CRL',\n    'cms': 'CMS',\n    'key': 'PRIVATE KEY',\n}\n\nPEMParseResult = namedtuple('PEMParseResult',\n                            ['pem_type',\n                             'pem_start', 'pem_end',\n                             'base64_start', 'base64_end', 'base64_text',\n                             'binary_data'])\n\npem_begin_re = re.compile(r'^-{5}BEGIN\\s+([^-]+)-{5}\\s*$', re.MULTILINE)\npem_end_re = re.compile(r'^-{5}END\\s+([^-]+)-{5}\\s*$', re.MULTILINE)\n\n\ndef pem_search(text, start=0):\n    '''Search for a block of PEM formatted data\n\n    Search for a PEM block in a text string. The search begins at\n    start. If a PEM block is found a PEMParseResult named tuple is\n    returned, otherwise if no PEM block is found None is returned.\n\n    The PEMParseResult named tuple is:\n    (pem_type, pem_start, pem_end, base64_start, base64_end)\n\n    pem_type\n        The text following '-----BEGIN ' in the PEM header.\n        Common examples are 'CERTIFICATE', 'CRL', 'CMS'.\n    pem_start, pem_end\n        The beginning and ending positions of the PEM block\n        including the PEM header and footer.\n    base64_start, base64_end\n        The beginning and ending positions of the base64 text\n        contained inside the PEM header and footer.\n    base64_text\n        The base64 text (e.g. text[b.base64_start : b.base64_end])\n    binary_data\n        The decoded base64 text. None if not decoded.\n\n    If the pem_type is not the same in both the header and footer\n    a ValueError is raised.\n\n    The start and end positions are suitable for use as slices into\n    the text. To search for multiple PEM blocks pass pem_end as the\n    start position for the next iteration. Terminate the iteration\n    when None is returned. Example:\n\n        start = 0\n        while True:\n            b = pem_search(text, start)\n            if b is None:\n                break\n            start = b.pem_end\n\n    :param string text: the text to search for PEM blocks\n    :param int start: the position in text to start searching from\n    :returns: PEMParseResult named tuple or None if not found\n    '''\n\n    match = pem_begin_re.search(text, pos=start)\n    if match:\n        pem_start = match.start()\n        begin_text = match.group(0)\n        base64_start = min(len(text), match.end() + 1)\n        begin_pem_type = match.group(1).strip()\n\n        match = pem_end_re.search(text, pos=base64_start)\n        if match:\n            pem_end = min(len(text), match.end() + 1)\n            base64_end = match.start() - 1\n            end_pem_type = match.group(1).strip()\n        else:\n            raise ValueError(\"failed to find end matching '%s'\" % begin_text)\n\n        if begin_pem_type != end_pem_type:\n            raise ValueError(\"beginning & end PEM types do not match \"\n                             \"(%s != %s)\",\n                             begin_pem_type, end_pem_type)\n    else:\n        return None\n\n    pem_type = begin_pem_type\n    base64_text = text[base64_start:base64_end]\n    try:\n        binary_data = base64.b64decode(base64_text)\n    except Exception as e:\n        binary_data = None\n        raise InvalidBase64Error('failed to base64 decode %s PEM '\n                                 'at position %d: %s' %\n                                 (pem_type, pem_start, e))\n\n    result = PEMParseResult(pem_type=pem_type,\n                            pem_start=pem_start, pem_end=pem_end,\n                            base64_start=base64_start, base64_end=base64_end,\n                            base64_text=base64_text,\n                            binary_data=binary_data)\n    return result\n\n\ndef parse_pem(text, pem_type=None, max_items=None):\n    '''Scan text for PEM data, return list of PEMParseResult\n\n    pem_type operates as a filter on the type of PEM desired. If\n    pem_type is specified only those PEM blocks which match will be\n    included. The pem_type is a logical name, not the actual text in\n    the pem header (e.g. 'cert'). If the pem_type is None all PEM\n    blocks are returned.\n\n    If max_items is specified the result is limited to that number of\n    items.\n\n    The return value is a list of PEMParseResult named tuples.  The\n    PEMParseResult provides complete information about the PEM block\n    including the decoded binary data for the PEM block.  The list is\n    ordered in the same order as found in the text.\n\n    Examples:\n\n        # Get all certs\n        certs = parse_pem(text, 'cert')\n\n        # Get the first cert\n        try:\n            binary_cert = parse_pem(text, 'cert', 1)[0].binary_data\n        except IndexError:\n            raise ValueError('no cert found')\n\n    :param string text: The text to search for PEM blocks\n    :param string pem_type: Only return data for this pem_type.\n                            Valid types are: csr, cert, crl, cms, key.\n                            If pem_type is None no filtering is performed.\n    :param int max_items: Limit the number of blocks returned.\n    :returns: List of PEMParseResult, one for each PEM block found\n    '''\n\n    pem_blocks = []\n    result = []\n    start = 0\n\n    while True:\n        b = pem_search(text, start)\n        if b is None:\n            break\n        start = b.pem_end\n        if pem_type is None:\n            pem_blocks.append(b)\n        else:\n            try:\n                if pem_headers[pem_type] == b.pem_type:\n                    pem_blocks.append(b)\n            except KeyError:\n                raise ValueError('unknown pem_type: %s' % (pem_type))\n\n        if max_items is not None and len(pem_blocks) >= max_items:\n            break\n\n    return pem_blocks\n\n# ------------------------- SAML Metadata Utilities ---------------------------\n\ndef get_sp_assertion_consumer_url(metadata_file, entity_id=None,\n                                  binding=None):\n    '''Retrieve AssertionConsumerURL(s) from SP metadata\n\n    Read and parse the SAML metadata contained in metadata_file.\n\n    If the entity_id is supplied then select the SP matching it,\n    this is useful when the metadata contains multiple SP's. If the\n    entity_id is not supplied then there must be exactly 1 SP in the\n    metadata, that one will be selected.\n\n    If the SAML endpoint binding is supplied then only\n    AssertionConsumerServiceURL's matching that binding will be returned,\n    otherwise all AssertionConsumerURL's will be returned.\n\n    The return value is a list of AssertionConsumerServiceURL's in the order\n    found in the metadata.\n\n    :param metadata_file:        Pathname of SAML Metadata file\n    :param entity_id (optional): EntityID of SP\n    :param binding (optional):   Filter matching this binding\n    :return:                     List of AssertionConsumerServiceURL's\n    '''\n\n    namespaces = dict(md='urn:oasis:names:tc:SAML:2.0:metadata',\n                      saml='urn:oasis:names:tc:SAML:2.0:assertion',\n                      ds='http://www.w3.org/2000/09/xmldsig#')\n\n    root = etree.parse(metadata_file).getroot()\n\n    if True or not entity_id:\n        # If entity_id was not supplied locate a unique SPSSODescriptor\n        xpath = ('//md:EntityDescriptor/md:SPSSODescriptor')\n        sp = root.xpath(xpath, namespaces=namespaces)\n        if len(sp) == 0:\n            raise ValueError('entity_id not supplied and no '\n                             'SPSSODescriptor was found')\n        elif len(sp) > 1:\n            raise ValueError('entity_id not supplied and multiple '\n                             'SPSSODescriptor elements were found')\n\n        xpath = ('ancestor::md:EntityDescriptor')\n        ed = sp[0].xpath(xpath, namespaces=namespaces)\n\n        entity_id =  ed[0].attrib['entityID']\n\n    else:\n        xpath = ('//md:EntityDescriptor[@entityID=\"{entity_id}\"]'\n                 '/md:SPSSODescriptor'.format(entity_id=entity_id))\n\n        sp = root.xpath(xpath, namespaces=namespaces)\n        if len(sp) == 0:\n            raise IndexError('SPSSODescriptor with EntityID=\"{entity_id}\" '\n                             'not found'.format(entity_id=entity_id))\n        elif len(sp) > 1:\n            raise ValueError('multiple SPSSODescriptor with '\n                             'EntityID=\"{entity_id}\" found'.format(\n                                 entity_id=entity_id))\n    sp = sp[0]\n\n    if not binding:\n        xpath = 'md:AssertionConsumerService'\n        acs = sp.xpath(xpath, namespaces=namespaces)\n        urls = [x.attrib['Location'] for x in acs]\n    else:\n        xpath = 'md:AssertionConsumerService[@Binding=\"{binding}\"]'.format(\n            binding=SAML_PAOS_BINDING)\n        acs = sp.xpath(xpath, namespaces=namespaces)\n        urls = [x.attrib['Location'] for x in acs]\n\n    return urls\n\n\ndef get_entity_id_from_metadata(metadata_file, role):\n    '''Retrieve entityID from metadata\n\n    Read and parse the SAML metadata contained in metadata_file,\n    search for one of the following roles and return the entityID\n    associated with that role.\n\n    SSO Identity Provider (role='idp')\n    SSO Service Provider (role='sp')\n    Authentication Authority (role='authn_authority')\n    Attribute Authority (role='attr_authority)\n    Policy Decision Point (role='pdp')\n\n    :param metadata_file:        Pathname of SAML Metadata file\n    :param role:                 one of: idp, sp, authn_authority,\n                                 attr_authority, pdp\n    :return:                     entityID\n    '''\n\n    roles = {'idp':             'IDPSSODescriptor',\n             'sp':              'SPSSODescriptor',\n             'authn_authority': 'AuthnAuthorityDescriptor',\n             'attr_authority':  'AttributeAuthorityDescriptor',\n             'pdp':             'PDPDescriptor'}\n\n\n    role_descriptor = roles.get(role)\n    if role_descriptor is None:\n        raise ValueError(\"invalid role '%s', must be one of: %s\" %\n                         (role, ', '.join(sorted(roles.keys()))))\n\n    namespaces = dict(md='urn:oasis:names:tc:SAML:2.0:metadata',\n                      saml='urn:oasis:names:tc:SAML:2.0:assertion',\n                      ds='http://www.w3.org/2000/09/xmldsig#')\n\n    root = etree.parse(metadata_file).getroot()\n    \n    xpath = '//md:EntityDescriptor/md:%s' % role_descriptor\n    entity = root.xpath(xpath, namespaces=namespaces)\n    if len(entity) == 0:\n        raise ValueError('no %s found' % role_descriptor)\n    elif len(entity) > 1:\n        raise ValueError('multiple EntityDescriptor elements found')\n\n    xpath = ('ancestor::md:EntityDescriptor')\n    ed = entity[0].xpath(xpath, namespaces=namespaces)\n\n    entity_id =  ed[0].attrib['entityID']\n    return entity_id\n\n# -------------------- Certificate Creation & Installation --------------------\n\n\ndef load_cert_from_file(filename, format='base64_text'):\n    '''Load a cert from a file, return as either base64 text or binary.\n\n    :param string filename: The input file to read the cert from.\n    :param string format: One of: 'base64_text', 'binary'\n    :returns: cert in requested format\n    '''\n    with open(filename, 'r') as f:\n        data = f.read()\n\n    certs = parse_pem(data, 'cert')\n\n    if len(certs) == 0:\n        raise ValueError('No cert found in {filename}'.format(\n            filename=filename))\n\n    if len(certs) > 1:\n        raise ValueError('Multiple certs ({num_certs}) '\n                         'found in {filename}'.format(\n                             num_certs=len(certs),\n                             filename=filename))\n\n    if format == 'base64_text':\n        return certs[0].base64_text\n    if format == 'binary':\n        return certs[0].binary\n    else:\n        raise ValueError('Uknown format \"{format}\"'.format(\n            format=format))\n\n\ndef generate_cert(subject):\n    '''Generate self-signed cert and key.\n\n    A new self-signed cert and key is generated.\n    The key and cert are returned as strings in PEM format.\n\n    :param string subject: Certificate subject.\n    :returns: key, cert as 2-tuple of PEM formatted strings\n    '''\n\n    tmpdir = tempfile.mkdtemp()\n    key_file = os.path.join(tmpdir, 'key.pem')\n    cert_file = os.path.join(tmpdir, 'cert.pem')\n    try:\n        openssl_subject = '/CN=%s' % subject\n        cmd = ['openssl',\n               'req', '-x509', '-batch', '-days', '1825',\n               '-newkey', 'rsa:2048', '-nodes', '-subj', openssl_subject,\n               '-keyout', key_file, '-out', cert_file]\n\n        run_cmd(cmd)\n\n        with open(key_file, 'r') as f:\n            key = f.read()\n\n        with open(cert_file, 'r') as f:\n            cert = f.read()\n\n    except Exception:\n        raise\n    finally:\n        shutil.rmtree(tmpdir)\n\n    return key, cert\n\n\ndef install_mellon_cert(options):\n    if options.mellon_key_file or options.mellon_cert_file:\n        if not (options.mellon_key_file and options.mellon_cert_file):\n            raise ValueError('You must specify both a cert and key file, '\n                             'not just one.')\n        install_file(options.mellon_key_file, options.mellon_dst_key_file)\n        install_file(options.mellon_cert_file, options.mellon_dst_cert_file)\n    else:\n        subject = options.mellon_hostname\n        key, cert = generate_cert(subject)\n        install_file_from_data(key, options.mellon_dst_key_file)\n        install_file_from_data(cert, options.mellon_dst_cert_file)\n\n# ---------------------------- Template Builders ------------------------------\n\n\ndef build_template_params(options):\n    params = dict([(x, getattr(options, x)) for x in dir(options)\n                   if not x.startswith('_')])\n    return params\n\n\ndef build_mellon_httpd_config_file(options):\n    template_params = build_template_params(options)\n    template = template_env.get_template(MELLON_HTTPD_CONFIG_TEMPLATE)\n    return template.render(template_params)\n\n\ndef build_mellon_sp_metadata_file(options):\n    template_params = build_template_params(options)\n    template = template_env.get_template(MELLON_METADATA_TEMPLATE)\n    return template.render(template_params)\n\n# ------------ Argparse Argument Conversion/Validation Functions --------------\n\n\ndef arg_type_mellon_endpoint(value):\n    value = value.strip(' /')\n    return value\n\n\ndef arg_type_mellon_protected_location(value):\n    if not value.startswith('/'):\n        raise argparse.ArgumentTypeError('Location must be absolute '\n                                         '(arg=\"%s\")' % value)\n    return value.rstrip(\" /\")\n\n# -----------------------------------------------------------------------------\n\n\ndef main():\n    global logger, template_env\n\n    # ===== Command Line Arguments =====\n    parser = argparse.ArgumentParser(\n            description='Configure mod_auth_mellon as Keycloak client',\n            prog=prog_name,\n            formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n\n    # ---- Common Arguments ----\n\n    parser.add_argument('--no-root-check', dest='root_check',\n                        action='store_false',\n                        help='permit running by non-root')\n\n    parser.add_argument('-v', '--verbose', action='store_true',\n                        help='be chatty')\n\n    parser.add_argument('-d', '--debug', action='store_true',\n                        help='turn on debug info')\n\n    parser.add_argument('--show-traceback', action='store_true',\n                        help='exceptions print traceback in addition to '\n                             'error message')\n\n    parser.add_argument('--log-file',\n                        default=('/var/log/python-keycloak-httpd-client/'\n                                 '{prog_name}.log'.\n                                 format(prog_name=prog_name)),\n                        help='log file pathname')\n\n    parser.add_argument('--app-name',\n                        required=True,\n                        help='name of the web app being protected by mellon')\n\n    parser.add_argument('--force', action='store_true',\n                        help='forcefully override safety checks')\n\n    parser.add_argument('--permit-insecure-transport',  action='store_true',\n                        help='Normally secure transport such as TLS '\n                        'is required, defeat this check')\n\n    parser.add_argument('--tls-verify', action=keycloak_cli.TlsVerifyAction,\n                        default=True,\n                        help='TLS certificate verification for requests to'\n                        ' the server. May be one of case insenstive '\n                        '[true, yes, on] to enable,'\n                        '[false, no, off] to disable.'\n                        'Or the pathname to a OpenSSL CA bundle to use.'\n                        ' Default is True.')\n\n    # ---- Argument Group \"Program Configuration\"  ----\n\n    group = parser.add_argument_group('Program Configuration')\n\n    group.add_argument('--template-dir',\n                       default=('/usr/share/'\n                                'keycloak-httpd-client-install/templates'.\n                                format(prog_name=prog_name)),\n                       help='Template location')\n\n    group.add_argument('--httpd-dir',\n                       default='/etc/httpd',\n                       help='Template location')\n\n    # ---- Argument Group \"Keycloak IdP\"  ----\n\n    group = parser.add_argument_group('Keycloak IdP')\n\n    group.add_argument('-r', '--keycloak-realm',\n                       required=True,\n                       help='realm name')\n\n    group.add_argument('-s', '--keycloak-server-url',\n                       required=True,\n                       help='Keycloak server URL')\n\n    group.add_argument('-a', '--keycloak-auth-role',\n                       choices=keycloak_cli.AUTH_ROLES,\n                       default='root-admin',\n                       help='authenticating as what type of user '\n                       '(default: root-admin)')\n\n    group.add_argument('-u', '--keycloak-admin-username', default='admin',\n                       help='admin user name (default: admin)')\n\n    group.add_argument('-p', '--keycloak-admin-password',\n                       help='admin password (use - to read from stdin)')\n\n    group.add_argument('--keycloak-admin-realm',\n                       default='master',\n                       help='realm admin belongs to')\n\n    group.add_argument('--initial-access-token',\n                       help='realm initial access token for '\n                       'client registeration')\n\n    group.add_argument('--client-originate-method',\n                       choices=['descriptor', 'registration'],\n                       default='descriptor',\n                       help='select Keycloak method for creating SAML client')\n\n    # ---- Argument Group \"Mellon SP\"  ----\n\n    group = parser.add_argument_group('Mellon SP')\n\n    group.add_argument('--mellon-key-file',\n                       help='certficate key file')\n\n    group.add_argument('--mellon-cert-file',\n                       help='certficate file')\n\n    group.add_argument('--mellon-hostname', default=socket.getfqdn(),\n                       help=\"Machine's fully qualified host name\")\n\n    group.add_argument('--mellon-https-port', default=443, type=int,\n                       help=\"SSL/TLS port on mellon-hostname\")\n\n    group.add_argument('--mellon-root', default='/',\n                       help='common root ancestor for all mellon endpoints')\n\n    group.add_argument('--mellon-endpoint', default='mellon',\n                       type=arg_type_mellon_endpoint,\n                       help='Used to form the MellonEndpointPath, e.g. '\n                       '{mellon_root}/{mellon_endpoint}.')\n\n    group.add_argument('--mellon-entity-id',\n                       help='SP SAML Entity ID, '\n                       'defaults to {mellon_http_url}/{mellon_endpoint_path}/metadata')\n\n    group.add_argument('--mellon-idp-attr-name', default='IDP',\n                       help='name of the attribute Mellon adds which will '\n                       'contain the IdP entity id')\n\n    group.add_argument('--mellon-organization-name',\n                       help='Add SAML OrganizationName to SP metadata')\n\n    group.add_argument('--mellon-organization-display-name',\n                       help='Add SAML OrganizationDisplayName to SP metadata')\n\n    group.add_argument('--mellon-organization-url',\n                       help='Add SAML OrganizationURL to SP metadata')\n\n    group.add_argument('-l', '--mellon-protected-locations', action='append',\n                       type=arg_type_mellon_protected_location, default=[],\n                       help='Web location to protect with Mellon. '\n                            'May be specified multiple times')\n\n    # ===== Process command line arguments =====\n\n    options = parser.parse_args()\n\n    # ===== Verify process permission =====\n\n    if options.root_check and os.getuid() != 0:\n        print(\"You must be root to run this program\",\n              file=sys.stderr)\n        return STATUS_INSUFFICIENT_PRIVILEGE\n\n    # ===== Configure Logging =====\n\n    configure_logging(options)\n\n    # ===== Options requiring special handling =====\n\n    if options.keycloak_auth_role in ['root-admin', 'realm-admin']:\n        if options.keycloak_admin_password is None:\n            if (('KEYCLOAK_ADMIN_PASSWORD' in os.environ) and\n                (os.environ['KEYCLOAK_ADMIN_PASSWORD'])):\n                options.keycloak_admin_password = (\n                    os.environ['KEYCLOAK_ADMIN_PASSWORD'])\n            else:\n                options.keycloak_admin_password = getpass.getpass(\n                    '%s password: ' % (options.keycloak_admin_username))\n        elif options.keycloak_admin_password == '-':\n            options.keycloak_admin_password = sys.stdin.readline().rstrip('\\n')\n\n        if not options.keycloak_admin_password:\n            parser.error('argument %s is required '\n                         'unless passed in the environment '\n                         'variable KEYCLOAK_ADMIN_PASSWORD' %\n                         ('keycloak-admin-password'))\n\n    # ===== Normalize Options =====\n\n    options.mellon_root = '/' + options.mellon_root.strip(' /')\n    options.mellon_endpoint = options.mellon_endpoint.strip(' /')\n\n    # ===== Synthesize Derived Options =====\n\n    options.httpd_saml_dir = os.path.join(options.httpd_dir, HTTPD_SAML_DIR)\n    options.httpd_conf_dir = os.path.join(options.httpd_dir, HTTPD_CONF_DIR)\n    options.mellon_httpd_config_filename = \\\n        os.path.join(options.httpd_conf_dir,\n                     '{app_name}_mellon_keycloak_{realm}.conf'.format(\n                         app_name=options.app_name,\n                         realm=options.keycloak_realm))\n    options.mellon_sp_metadata_filename = \\\n        os.path.join(options.httpd_saml_dir,\n                     '{app_name}_{mellon_metadata}').format(\n                         app_name=options.app_name,\n                         mellon_metadata=MELLON_METADATA)\n    options.mellon_dst_key_file = \\\n        os.path.join(options.httpd_saml_dir,\n                     '{app_name}.key'.format(\n                         app_name=options.app_name))\n    options.mellon_dst_cert_file = \\\n        os.path.join(options.httpd_saml_dir, '{app_name}.cert'.format(\n            app_name=options.app_name))\n    options.mellon_dst_idp_metadata_file = \\\n        os.path.join(options.httpd_saml_dir,\n                     '{app_name}_keycloak_{realm}_idp_metadata.xml'.format(\n                         app_name=options.app_name,\n                         realm=options.keycloak_realm))\n    options.mellon_http_url = \\\n        normalize_url('https://{mellon_hostname}:{mellon_https_port}'.format(\n            mellon_hostname=options.mellon_hostname,\n            mellon_https_port=options.mellon_https_port))\n    options.mellon_endpoint_path = join_path(options.mellon_root, options.mellon_endpoint)\n\n    if not options.mellon_entity_id:\n        url = urlsplit(options.mellon_http_url)\n        options.mellon_entity_id = urlunsplit((url.scheme, url.netloc,\n                                               join_path(options.mellon_endpoint_path, 'metadata'),\n                                               '', ''))\n\n    # ===== Validate Options =====\n\n    try:\n        if options.keycloak_auth_role == 'anonymous':\n            if options.client_originate_method == 'registration':\n                logger.warn(\"Using client originate method 'registration' with the 'anonymous'\\n\"\n                            \"authentication role disables updating the client configuration after\\n\"\n                            \"registration. You may need to adjust the client configuration manually\\n\"\n                            \"in the Keycloak admin console. Use one of the admin authentication\\n\"\n                            \"roles to permit automated client configuration.\\n\")\n\n            if not options.initial_access_token:\n                raise ValueError(\"You must supply an initial access token \"\n                                 \"with anonymous authentication\")\n\n\n        root = join_path(options.mellon_root, '/')\n        for location in options.mellon_protected_locations:\n            location = join_path(location, '/')\n            if not location.startswith(root):\n                raise ValueError('Invalid protected location \"%s\" '\n                                 'must be equal to or ancestor of the mellon '\n                                 'root \"%s\"' % (\n                                     location, root))\n\n    except Exception as e:\n        if options.show_traceback:\n            traceback.print_exc()\n        print('%s: %s' % (e.__class__.__name__, six.text_type(e)),\n              file=sys.stderr)\n        return STATUS_CONFIGURATION_ERROR\n\n    # ===== Establish Keycloak Server Communication =====\n\n    try:\n        logger.step('Connect to Keycloak Server')\n        logger.info('Connecting to Keycloak server \"%s\"',\n                    options.keycloak_server_url)\n        if options.permit_insecure_transport:\n            os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = '1'\n\n        anonymous_conn = keycloak_cli.KeycloakAnonymousConnection(\n            options.keycloak_server_url,\n            options.tls_verify)\n\n        if options.keycloak_auth_role in ['root-admin', 'realm-admin']:\n            admin_conn = keycloak_cli.KeycloakAdminConnection(\n                options.keycloak_server_url,\n                options.keycloak_auth_role,\n                options.keycloak_admin_realm,\n                keycloak_cli.ADMIN_CLIENT_ID,\n                options.keycloak_admin_username,\n                options.keycloak_admin_password,\n                options.tls_verify)\n        else:\n            admin_conn = None\n\n    except Exception as e:\n        if options.show_traceback:\n            traceback.print_exc()\n        print('%s: %s' % (e.__class__.__name__, six.text_type(e)),\n              file=sys.stderr)\n        return STATUS_COMMUNICATION_ERROR\n\n    # ===== Assure required directories are present =====\n\n    try:\n        logger.step('Create Directories')\n        mkdir(options.httpd_saml_dir)\n        mkdir(options.httpd_conf_dir)\n    except Exception as e:\n        if options.show_traceback:\n            traceback.print_exc()\n        print('%s: %s' % (e.__class__.__name__, six.text_type(e)),\n              file=sys.stderr)\n        return STATUS_OPERATION_ERROR\n\n    # ===== Create jinja2 Template Environment =====\n\n    try:\n        logger.step('Set up template environment')\n        template_env = jinja2.Environment(trim_blocks=True,\n                                          lstrip_blocks=True,\n                                          keep_trailing_newline=True,\n                                          undefined=jinja2.StrictUndefined,\n                                          loader=jinja2.FileSystemLoader(\n                                              options.template_dir))\n    except Exception as e:\n        if options.show_traceback:\n            traceback.print_exc()\n        print('%s: %s' % (e.__class__.__name__, six.text_type(e)),\n              file=sys.stderr)\n        return STATUS_CONFIGURATION_ERROR\n\n    # ===== Congfigure Mellon  =====\n\n    try:\n        logger.step('Set up Service Provider X509 Certificiates')\n        install_mellon_cert(options)\n\n        cert_base64 = load_cert_from_file(options.mellon_dst_cert_file)\n        options.sp_signing_cert = cert_base64\n        options.sp_encryption_cert = cert_base64\n\n        logger.step('Build Mellon httpd config file')\n        mellon_httpd_config = build_mellon_httpd_config_file(options)\n        install_file_from_data(mellon_httpd_config,\n                               options.mellon_httpd_config_filename)\n\n        logger.step('Build Mellon SP metadata file')\n        mellon_sp_metadata = build_mellon_sp_metadata_file(options)\n        install_file_from_data(mellon_sp_metadata,\n                               options.mellon_sp_metadata_filename)\n    except Exception as e:\n        if options.show_traceback:\n            traceback.print_exc()\n        print('%s: %s' % (e.__class__.__name__, six.text_type(e)),\n              file=sys.stderr)\n        return STATUS_OPERATION_ERROR\n\n    # ===== Configure Keycloak  =====\n\n    try:\n        if options.keycloak_auth_role == 'root-admin':\n            logger.step('Query realms from Keycloak server')\n            realms = admin_conn.get_realms()\n            realm_names = keycloak_cli.get_realm_names_from_realms(realms)\n            logger.info('existing realms [%s]', ', '.join(realm_names))\n\n            if options.keycloak_realm not in realm_names:\n                logger.step('Create realm on Keycloak server')\n                logger.info('Create realm \"%s\"', options.keycloak_realm)\n                admin_conn.create_realm(options.keycloak_realm)\n            else:\n                logger.step('Use existing realm on Keycloak server')\n\n        if options.keycloak_auth_role in ['root-admin', 'realm-admin']:\n            logger.step('Query realm clients from Keycloak server')\n            clients = admin_conn.get_clients(options.keycloak_realm)\n            client_ids = keycloak_cli.get_client_client_ids_from_clients(clients)\n            logger.info('existing clients in realm %s = [%s]',\n                        options.keycloak_realm, ', '.join(client_ids))\n\n            if options.mellon_entity_id in client_ids:\n                if options.force:\n                    logger.step('Force delete client on Keycloak server')\n                    logger.info('Delete client \"%s\"', options.mellon_entity_id)\n                    admin_conn.delete_client_by_name(options.keycloak_realm,\n                                                     options.mellon_entity_id)\n\n                else:\n                    raise AlreadyExistsError('client \"{client_id}\" '\n                                             'already exists in realm \"{realm}\". '\n                                             'Use --force to replace it.'.format(\n                                                 client_id=options.mellon_entity_id,\n                                                 realm=options.keycloak_realm))\n\n        if options.client_originate_method == 'descriptor':\n            logger.step('Creating new client from descriptor')\n            logger.info('Create new client \"%s\"', options.mellon_entity_id)\n            admin_conn.create_client(options.keycloak_realm,\n                                     mellon_sp_metadata)\n        elif options.client_originate_method == 'registration':\n\n            if options.initial_access_token:\n                logger.step('Use provided initial access token')\n                initial_access_token = options.initial_access_token\n            else:\n                if options.keycloak_auth_role in ['root-admin', 'realm-admin']:\n                    logger.step('Get new initial access token')\n                    client_initial_access = admin_conn.get_initial_access_token(\n                        options.keycloak_realm)\n                    initial_access_token = client_initial_access['token']\n                else:\n                    raise ValueError(\"You must root or realm admin privileges \"\n                                     \"to acquire an initial access token\")\n\n            logger.step('Creating new client using registration service')\n            logger.info('Register new client \"%s\"', options.mellon_entity_id)\n\n            try:\n                anonymous_conn.register_client(initial_access_token,\n                                               options.keycloak_realm,\n                                               mellon_sp_metadata)\n            except RESTError as e:\n                if e.error_description == \"Client Identifier in use\":\n                    raise AlreadyExistsError('client \"{client_id}\" '\n                                             'already exists in realm \"{realm}\"'.format(\n                                                 client_id=options.mellon_entity_id,\n                                                 realm=options.keycloak_realm))\n                else:\n                    raise\n        else:\n            raise ValueError(\"Unknown client-originate-method = '%s'\" %\n                             options.client_originate_method)\n\n\n        if options.keycloak_auth_role in ['root-admin', 'realm-admin']:\n            # Enable Force Post Binding, registration service fails to\n            # to enable it (however creation with client descriptor does)\n            logger.step('Enable saml.force.post.binding')\n            update_attrs = {'saml.force.post.binding': True}\n            admin_conn.update_client_by_name_attributes(options.keycloak_realm,\n                                                        options.mellon_entity_id,\n                                                        update_attrs)\n\n            logger.step('Add group attribute mapper to client')\n            mapper = admin_conn.new_saml_group_protocol_mapper(\n                'group list', 'groups',\n                friendly_name='List of groups user is a member of')\n            admin_conn.create_client_by_name_protocol_mapper(options.keycloak_realm,\n                                                             options.mellon_entity_id,\n                                                             mapper)\n\n            logger.step('Add Redirect URIs to client')\n            urls = get_sp_assertion_consumer_url(options.mellon_sp_metadata_filename,\n                                                 entity_id=options.mellon_entity_id)\n            admin_conn.add_client_by_name_redirect_uris(options.keycloak_realm,\n                                                        options.mellon_entity_id,\n                                                        urls)\n\n        logger.step('Retrieve IdP metadata from Keycloak server')\n        idp_metadata = anonymous_conn.get_realm_metadata(options.keycloak_realm)\n        install_file_from_data(idp_metadata,\n                               options.mellon_dst_idp_metadata_file)\n\n    except AlreadyExistsError as e:\n        if options.show_traceback:\n            traceback.print_exc()\n        print(six.text_type(e), file=sys.stderr)\n        return STATUS_ALREADY_EXISTS_ERROR\n    except Exception as e:\n        if options.show_traceback:\n            traceback.print_exc()\n        print('%s: %s' % (e.__class__.__name__, six.text_type(e)),\n              file=sys.stderr)\n        return STATUS_OPERATION_ERROR\n\n    # ===== Wrap Up =====\n\n    logger.step('Completed Successfully')\n    logger.info('mellon entityID=\"%s\"' % options.mellon_entity_id)\n    return STATUS_SUCCESS\n\n# -----------------------------------------------------------------------------\n\nif __name__ == '__main__':\n    sys.exit(main())\n", ".TH keycloak-httpd-client-install 1\n\n.SH NAME\nkeycloak-httpd-client-install \\-\nTools to configure Apache HTTPD as Keycloak client\n\n.SH SYNOPSIS\n.B keycloak-httpd-client-install\n[\\fB\\-h\\fR]\n[\\fB\\-\\-no\\-root\\-check\\fR]\n[\\fB\\-v\\fR]\n[\\fB\\-d\\fR]\n[\\fB\\-\\-show\\-traceback\\fR]\n[\\fB\\-\\-log\\-file\\fR \\fILOG_FILE\\fR]\n\\fB\\-\\-app\\-name\\fR \\fIAPP_NAME\\fR\n[\\fB\\-\\-force\\fR]\n[\\fB\\-\\-permit\\-insecure\\-transport\\fR]\n[\\fB\\-\\-tls\\-verify\\fR]\n[\\fB\\-\\-template\\-dir\\fR \\fITEMPLATE_DIR\\fR]\n[\\fB\\-\\-httpd\\-dir\\fR \\fIHTTPD_DIR\\fR] \\-r KEYCLOAK_REALM\n\\fB\\-s\\fR \\fIKEYCLOAK_SERVER_URL\\fR\n[\\fB\\-a\\fR \\fIroot\\-admin|realm\\-admin|anonymous\\fR]\n[\\fB\\-u\\fR \\fIKEYCLOAK_ADMIN_USERNAME\\fR]\n\\fB\\-p\\fR \\fIKEYCLOAK_ADMIN_PASSWORD\\fR\n[\\fB\\-\\-keycloak\\-admin\\-realm\\fR \\fIKEYCLOAK_ADMIN_REALM\\fR]\n[\\fB\\-\\-initial\\-access\\-token\\fR \\fIINITIAL_ACCESS_TOKEN\\fR]\n[\\fB\\-\\-client\\-originate\\-method\\fR \\fIdescriptor|registration\\fR]\n[\\fB\\-\\-mellon\\-key\\-file\\fR \\fIMELLON_KEY_FILE\\fR]\n[\\fB\\-\\-mellon\\-cert\\-file\\fR \\fIMELLON_CERT_FILE\\fR]\n[\\fB\\-\\-mellon\\-hostname\\fR \\fIMELLON_HOSTNAME\\fR]\n[\\fB\\-\\-mellon\\-https-port\\fR \\fIMELLON_HTTPS_PORT\\fR]\n[\\fB\\-\\-mellon\\-root\\fR \\fIMELLON_ROOT\\fR]\n[\\fB\\-\\-mellon\\-endpoint\\fR \\fIMELLON_ENDPOINT\\fR]\n[\\fB\\-\\-mellon\\-entity\\-id\\fR \\fIMELLON_ENTITY_ID\\fR]\n[\\fB\\-\\-mellon\\-idp\\-attr\\-name\\fR \\fIMELLON_IDP_ATTR_NAME\\fR]\n[\\fB\\-\\-mellon\\-organization\\-name\\fR \\fIMELLON_ORGANIZATION_NAME\\fR]\n[\\fB\\-\\-mellon\\-organization\\-display\\-name\\fR \\fIMELLON_ORGANIZATION_DISPLAY_NAME\\fR]\n[\\fB\\-\\-mellon\\-organization\\-url\\fR \\fIMELLON_ORGANIZATION_URL\\fR]\n[\\fB\\-l\\fR \\fIMELLON_PROTECTED_LOCATIONS\\fR]\n\nConfigure mod_auth_mellon as Keycloak client\n\n.SH OPTIONS\n.TP\n.BR \\-h \", \" \\-\\-help\nshow this help message and exit\n.TP\n.BR \\-\\-no\\-root\\-check\npermit running by non\\-root\n(default: False)\n.TP\n.BR \\-v \", \" \\-\\-verbose\nbe chatty\n(default: False)\n.TP\n.BR \\-d \", \" \\-\\-debug\nturn on debug info\n(default: False)\n.TP\n.BR \\-\\-show\\-traceback\nexceptions print traceback in addition to error message\n(default: False)\n.TP\n.BR \\-\\-log\\-file \" \" \\fILOG_FILE\\fR\nlog file pathname\n(default: /var/log/python\\-keycloak\\-httpd\\-client/keycloak\\-httpd\\-client\\-install.log)\n.TP\n.BR \\-\\-app\\-name \" \" \\fIAPP_NAME\\fR\nname of the web app being protected by mellon\n(default: None)\n.TP\n.BR  \\-\\-force\nforcefully override safety checks\n(default: False)\n.TP\n.BR \\-\\-permit\\-insecure\\-transport\nNormally secure transport such as TLS is required,\ndefeat this check\n(default: False)\n.TP\n.BR \\-\\-tls\\-verify\nTLS certificate verification for requests to the server. May be one of\ncase insenstive [true, yes, on] to enable, [false, no, off] to\ndisable. Or the pathname to a OpenSSL CA bundle to use.\n(default: True)\n\n.PP\nProgram Configuration:\n\n.TP\n.BR \\-\\-template\\-dir \" \" \\fITEMPLATE_DIR\\fR\nTemplate location\n(default: /usr/share/keycloak\\-httpd\\-client/templates)\n.TP\n.BR \\-\\-httpd\\-dir \" \" \\fIHTTPD_DIR\\fR\nTemplate location\n(default: /etc/httpd)\n\n.PP\nKeycloak IdP:\n\n.TP\n.BR \\-r \", \" \\-\\-keycloak\\-realm \" \" \\fIKEYCLOAK_REALM\\fR\nrealm name\n(default: None)\n.TP\n.BR \\-s \", \" \\-\\-keycloak\\-server\\-url \" \" \\fIKEYCLOAK_SERVER_URL\\fR\nKeycloak server URL\n(default: None)\n.TP\n.BR \\-a \", \" \\-\\-keycloak\\-auth\\-role \" \" \\fIroot\\-admin|realm\\-admin|anonymous\\fR\nauthenticating as what type of user\n(default: root\\-admin)\n.TP\n.BR \\-u \", \" \\-\\-keycloak\\-admin\\-username \" \" \\fIKEYCLOAK_ADMIN_USERNAME\\fR\nadmin user name\n(default: admin)\n.TP\n.BR \\-p \", \" \\-\\-keycloak\\-admin\\-password \" \" \\fIKEYCLOAK_ADMIN_PASSWORD\\fR\nadmin password (use - to read from stdin)\n(default: None)\n.TP\n.BR \\-\\-keycloak\\-admin\\-realm \" \" \\fIKEYCLOAK_ADMIN_REALM\\fR\nrealm admin belongs to\n(default: master)\n.TP\n.BR \\-\\-initial\\-access\\-token \" \" \\fIINITIAL_ACCESS_TOKEN\\fR\nrealm initial access token for client registeration\n(default: None)\n.TP\n.BR \\-\\-client\\-originate\\-method \" \" \\fIdescriptor|registration\\fR\nselect Keycloak method for creating SAML client\n(default: descriptor)\n\n.PP\nMellon SP:\n\n.TP\n.BR \\-\\-mellon\\-key\\-file \" \" \\fIMELLON_KEY_FILE\\fR\ncertficate key file\n(default: None)\n.TP\n.BR \\-\\-mellon\\-cert\\-file \" \" \\fIMELLON_CERT_FILE\\fR\ncertficate file\n(default: None)\n.TP\n.BR \\-\\-mellon\\-hostname \" \" \\fIMELLON_HOSTNAME\\fR\nMachine's fully qualified host name\n.TP\n.BR \\-\\-mellon\\-https\\-port \" \" \\fIMELLON_HTTPS_PORT\\fR\nSSL/TLS port on mellon-hostname\n.TP\n.BR \\-\\-mellon\\-root \" \" \\fIMELLON_ROOT\\fR\nCommon root ancestor for all mellon endpoints\n.TP\n.BR \\-\\-mellon\\-endpoint \" \" \\fIMELLON_ENDPOINT\\fR\nUsed to form the MellonEndpointPath, e.g. \n{mellon_root}/{mellon_endpoint}\n(default: mellon)\n.TP\n.BR \\-\\-mellon\\-entity\\-id \" \" \\fIMELLON_ENTITY_ID\\fR\nSP SAML Entity ID\n(default: {mellon_http_url}/{mellon_root}/{mellon_endpoint_path}/metadata)\n.TP\n.BR \\-\\-mellon\\-idp\\-attr\\-name \" \" \\fIMELLON_IDP_ATTR_NAME\\fR\nName of the attribute Mellon adds which will contain the IdP entity id\n(default: {mellon_http_url}/{mellon_root}/{mellon_endpoint_path}/metadata)\n.TP\n.BR \\-\\-mellon\\-organization\\-name \" \" \\fIMELLON_ORGANIZATION_NAME\\fR\nAdd SAML OrganizationName to SP metadata\n(default: None)\n.TP\n.BR \\-\\-mellon\\-organization\\-display\\-name \" \" \\fIMELLON_ORGANIZATION_DISPLAY_NAME\\fR\nAdd SAML OrganizationDisplayName to SP metadata\n(default: None)\n.TP\n.BR \\-\\-mellon\\-organization\\-url \" \" \\fIMELLON_ORGANIZATION_URL\\fR\nAdd SAML OrganizationURL to SP metadata\n(default: None)\n.TP\n.BR \\-l \", \" \\-\\-mellon\\-protected\\-locations \" \" \\fIMELLON_PROTECTED_LOCATIONS\\fR\nWeb location to protect with Mellon. May be specified multiple times\n(default: [])\n\n.SH DESCRIPTION\n\n\\fBkeycloak\\-httpd\\-client\\-install\\fR will configure a node running Apache with mod_auth_mellon as SAML Service Provider (\\fBSP\\fR) utilizing a \\fBKeycloak\\fR server as an Identity Provider(\\fBIdP\\fR).\n\n.PP\n.B Authentication Levels and Permissions\n\n.PP\nThe tool is capable of range of configuration steps. But the extent of those operations may be circumscribed by the privilege level (authorization) the tool is run with. The privilege level is determined by the \\fB\\-\\-keycloak\\-auth\\-role\\fR command line option which may be one of:\n\n.PP\n\\fBroot\\-admin\\fR: The Keycloak installation has a super realm normally called \\fImaster\\fR which is the container for all realms hosted by the Keycloak instance. A user with administration priviliges in the \\fImaster\\fR realm can perform all operations on all realms hosted by the instance. Think of such a user as a root user or root admin.\n.PP\n\\fBrealm\\-admin\\fR: Each subordinate realm in the Keycloak instance may have it's own administrator(s) whose privileges are restricted exclusively to that realm.\n.PP\n\\fBanonymous\\fR: The tool does not authenticate as a user and hence no priviliges are granted. Any privilege is granted by virtue of an \\fIinitial access token\\fR passed in via the \\fB\\-initial\\-access\\-token\\fR command line option. Think of an initial access token as a one time password scoped to a specific realm. The initial access token must be generated by an administrator with sufficient priviliges on the realm and given to the user of the tool. The priviliges conferred by the initial access token are limited to registering the client in the realm utilizing the Keycloak client registration service.\n.PP\nSelecting which authencation role will be used is determined by a combination of the \\fB\\-\\-keycloak\\-auth\\-role\\fR option and the \\fB\\-\\-keycloak\\-admin\\-realm\\fR option. When the authentication role is one of \\fIroot\\-admin\\fR or \\fIrealm\\-admin\\fR the tool will authenticate as a user in a specific realm, the \\fB\\-\\-keycloak\\-admin\\-realm\\fR option declares the realm the administrator will authenticate to. For the \\fIroot\\-admin\\fR role this is typically the \\fImaster\\fR realm. For the \\fIrealm\\-admin\\fR role this would be realm the tool is registrating the client in.\n\n.PP\n.B Determining which authentication role to use\n\nIn general the principle of \\fIleast privilige\\fR should apply. Grant to the tool the least privilige necessary to perform the required action. In oder of least privilige to greatest privilige the following operations are possible under the defined authentication roles:\n\n.PP\n.B anonymous\n.RS\n.PP\n\\fB*\\fR Can register the client using only the Keycloak client registration service. The tool cannot determine a prori if the client already exists in the realm nor can it adjust any configuration options on the client.\n.PP\n\\fB*\\fR The realm must pre\\-exist.\n.RE\n.PP\n.B realm\\-admin\n.RS\n.PP\n\\fB*\\fR Can enumerate the existing clients in the realm to determine if a conflict would occur.\n.PP\n\\fB*\\fR Can delete a pre\\-existing client and replace it with the new client definition if the \\fB\\-\\-force\\fR option is supplied.\n.PP\n\\fB*\\fR Can modify the clients configuration.\n.PP\n\\fB*\\fR Can use either the client registration service or the REST API to create the client.\n.PP\n\\fB*\\fR The realm must pre\\-exist and contain the realm admin user.\n.RE\n.PP\n.B root\\-admin\n.RS\n.PP\n\\fB*\\fR Includes all of the priviliged operation conferred by the \\fIrealm\\-admin\\fR.\n.PP\n\\fB*\\fR Can enumerate existing realms on the Keycloak instance to verify the existence of the target realm the client is to be installed in.\n.PP\n\\fB*\\fR Can create the target realm if it does not exist.\n.RE\n\n.PP\n.B Client creation methods\n\nKeycloak offers two methods to add a client to a realm\n.PP\n.RS\n\\fB*\\fR The OpenID Connect client registration service. Note even though we are registering a SAML Service Provider (SP) which is not part of OAuth2 nor OpenID Connect the client registration service is still capable of registering a SAML SP client. Selected with \\fB\\-\\-client\\-originate\\-method register\\fR.\n.PP\n\\fB*\\fR Utilizing the Keycloak REST API to create and configure the SAML SP client. The Keycloak REST API utilizes a 2\\-step process whereby the SP metadata is sent to the the Keycloak instance and it returns a client descriptor which is then used to create the client. Selected with \\fB\\-\\-client\\-originate\\-method descriptor\\fR.\n.RE\n.PP\nAt the time of this writing the client registration service behaves differently than the REST API. Advice on which to use is likely to be dependent upone the Keycloak version. Note, if anonymous authentication is used in conjunction with a initial access token then the client registration service \\fImust\\fR be used.\n.PP\nThe client registration service requies the use of an initial access token. For all authentiction roles an initial access token can be provided on the command line via the \\fBinitial\\-access\\-token\\fR option. The initial access token will have to have been provided by a Keycloak administrator who pre\\-creates it. If the authencation role is either \\fIroot\\-admin\\fR or \\fIrealm\\-admin\\fR the tool has sufficient privilige to obtain an initial access token on it's behalf negating the need for a Keycloak admin to supply one externally.\n.PP\nThe client registration service may be used by the following authentication roles:\n.RS\n.PP\n\\fB*\\fR root\\-admin\n.PP\n\\fB*\\fR realm\\-admin\n.PP\n\\fB*\\fR anonymous (requires use of \\fB\\-\\-initial\\-access\\-token\\fR)\n.RE\n.PP\nThe REST API may be used by the following authentication roles:\n.RS\n.PP\n\\fB*\\fR root\\-admin\n.PP\n\\fB*\\fR realm\\-admin\n.RE\n\n.SH OPERATION\n\n.PP\n\\fBkeycloak\\-httpd\\-client\\-install\\fR performs the following operational steps:\n\n.PP\n\\fB*\\fR Connect to Keycloak Server.\n.RS\n.PP\nA session is established with the Keycloak server. OAuth2 is used to log in as the admin user using the \\fB\\-\\-keycloak\\-admin\\-username\\fR and \\fB\\-\\-keycloak\\-admin\\-password\\fR options. The Keycloak server is identified by the \\fB\\-keycloak\\-server\\-url\\fR option. This step is performed first to assure the remaining steps can complete successfully. A session is maintained for efficiency reasons. You may also need to specify \\fB\\-\\-keycloak\\-admin\\-role\\fR and \\fB\\-\\-keycloak\\-admin\\-realm\\fR to indicate the privilege level you are authenticating with. An anonymous auth role connects to the Keycloak service without any authentication.\n.RE\n\n.PP\n\\fB*\\fR Create directories.\n.RS\n.PP\nFiles written by \\fBkeycloak\\-httpd\\-client\\-install\\fR need a destination directory (see \\fBFILES\\fR). If the necessary directories are not present they are created.\n.RE\n.PP\n\\fB*\\fR Set up template environment\n.RS\n.PP\nMany of the files written by \\fBkeycloak\\-httpd\\-client\\-install\\fR are based on \\fIjinga2\\fR templates. The default template file location can be overridden with the \\fB\\-\\-template\\-dir\\fR option.\n.RE\n.PP\n\\fB*\\fR Set up Service Provider X509 Certificiates.\n.RS\n.PP\nA SAML SP must have a X509 certificate and key used to sign and optionally encrypt it's SAML messages sent to the SAML IdP. \\fBkeycloak\\-httpd\\-client\\-install\\fR can generate a self\\-signed certificate for you or you may supply your own key and certificate via the \\fB\\-\\-mellon\\-key\\-file\\fR and \\fB\\-\\-mellon\\-cert\\-file\\fR options. The files must be in PEM format.\n.RE\n.PP\n\\fB*\\fR Build Mellon httpd config file.\n.RS\n.PP\nThe Mellon HTTPD configuration file tells \\fImod_auth_mellon\\fR where to find things such as certificates and metadata files as well as what web resources to protect. It is generated from the \\fImellon_httpd.conf\\fR template file. (see \\fBFILES\\fR). There is one mellon httpd conf file per application.\n.RE\n.PP\n\\fB*\\fR Build Mellon SP metadata file.\n.RS\n.PP\nThe Mellon SP needs to be registered with the Keycloak IdP. This forms a trust relationship and provides infomation to the IdP about the Mellon SP. Registering an SP with an IdP is done via a SP metadata file. The Mellon SP metadata also instructs \\fImod_auth_mellon\\fR how to operate. The Mellon SP is generated from the \\fIsp_metadata.tpl\\fR template file.\n.RE\n.PP\n\\fB*\\fR Query realms from Keycloak server, optionally create new realm.\n.RS\n.PP\nKeycloak supports multi\\-tenancy, it may serve many IdP's each one specified by a Keycloak realm. The \\fB\\-\\-keycloak\\-realm\\fR option identifies which Keycloak realm we will bind to. The Keycloak realm may already exist on the Keycloak server, if it does \\fBkeycloak\\-httpd\\-client\\-install\\fR will use it. If the Keycloak realm does not exist yet it will be created for you.\n.PP\nRequires the \\fIroot\\-admin\\fR auth role.\n.RE\n.PP\n\\fB*\\fR Query realm clients from Keycloak server, optionally delete existing.\n.RS\n.PP\nSAML SP's are one type of Keycloak client that can be serviced by the Keycloak realm IdP. The Mellon SP is a new Keycloak client which needs to be added to the Keycloak realm. However we must assure the new client does not conflict with an existing client on the Keycloak realm. If the Mellon SP is already registered on the Keycloak realm \\fBkeycloak\\-httpd\\-client\\-install\\fR will stop processing and exit with an error unless the \\fB\\-\\-force\\fR option is used. \\fB\\-\\-force\\fR will cause the existing client on the Keycloak realm to be deleted first so that it can be replaced in the next step.\n.PP\nRequires either the \\fIroot\\-admin\\fR or \\fIrealm\\-admin\\fR auth role.\n.RE\n.PP\n\\fB*\\fR Create new SP client in Keycloak realm.\n.RS\n.PP\nThe Mellon SP is registered with the Keycloak realm on the Keycloak server by sending the Keycloak server the Mellon SP metadata to the Keycloak server.\n.PP\nWhen the client\\-originate\\-method is \\fIdescriptor\\fR either the \\fIroot\\-admin\\fR or \\fIrealm\\-admin\\fR auth role is required. When the \\fIclient\\-originate\\-method\\fR is \\fIregistration\\fR the initial access token is mandatory for the \\fIanonymous\\fR auth role and optional for the \\fIroot\\-admin\\fR or \\fIrealm\\-admin\\fR roles.\n.RE\n\n.PP\n\\fB*\\fR Adjust client configuration\n.RS\n.PP\nOverride default Keycloak client values. This varies by Keycloak release.\n.PP\nRequires either the \\fIroot\\-admin\\fR or \\fIrealm\\-admin\\fR auth role.\n.RE\n\n.PP\n\\fB*\\fR Add attributes to be returned in assertion\n.RS\n.PP\nThe client is configured to return necessary attributes. The added attributes are:\n.RS\n.PP\n\\fB*\\fR Groups user is a member of.\n.RE\n.PP\nRequires either the \\fIroot\\-admin\\fR or \\fIrealm\\-admin\\fR auth role.\n.RE\n\n.PP\n\\fB*\\fR Retrieve IdP metadata from Keycloak server.\n.RS\n.PP\nThe Mellon SP needs SAML metadata that describes the Keycloak IdP. The metadata for the Keycloak IdP is fetched from the Keycloak server and stored in a location referenced in the Mellon SP httpd configuration file. (see \\fBFILES\\fR)\n.RE\n\n.PP\n.B STRUCTURE\n.PP\nThe overarching organization is the web application. An independent set of Mellon files are created per application and registered with the Keycloak server. This permits multiple indpendent SAML Service Providers and/or protected web resources to be handled by one Apache instance. When you run \\fBkeycloak\\-httpd\\-client\\-install\\fR you must supply an application name via the \\fB\\-\\-app\\-name\\fR option.\n.PP\nWithin the web application you may protect via SAML multiple independent web resources specified via the \\fB\\-\\-mellon\\-protected\\-locations\\fR /xxx option. This will cause a:\n.PP\n.nf\n.RS\n<Location>\n    AuthType Mellon\n    MellonEnable auth\n    Require valid-user\n</Location>\n.RE\n.fi\n\n.PP\ndirective to be added to the Mellon HTTPD configuration file. The Mellon SP parameters are located at the root of the web application root, each protected location inherits from that.\n\n.SH FILES\n\nFiles created by running \\fBkeycloak\\-httpd\\-client\\-install\\fR:\n.TP\n.B {httpd\\-dir}/conf.d/{app\\-name}_mellon_keycloak_{realm}.conf\nThis is the primary Mellon configuration file for the application. It\nbinds to the Keycloak realm IdP. It is generated from the\n\\fImellon_httpd.conf\\fR template file.\n\n.TP\n.B {httpd\\-dir}/saml2/{app\\-name}.cert\nThe Mellon SP X509 certficate file in PEM format.\n\n.TP\n.B {httpd\\-dir}/saml2/{app\\-name}.key\nThe Mellon SP X509 key file in PEM format.\n\n.TP\n.B {httpd\\-dir}/saml2/{app\\-name}_keycloak_{realm}_idp_metadata.xml\nThe Keycloak SAML2 IdP metadata file. It is fetched from the Keycloak server.\n\n.TP\n.B {httpd\\-dir}/saml2/{app\\-name}_sp_metadata.xml\nThe Mellon SAML2 SP metadata file. It is generated from the\n\\fIsp_metadata.xml\\fR template file.\n\n.PP\n.B Files referenced by \\fBkeycloak\\-httpd\\-client\\-install\\fR when it runs:\n\n.TP\n.B /usr/share/python\\-keycloak\\-httpd\\-client/templates/*\njinja2 templates\n\n.PP\n.B Log files:\n.TP\n.B /var/log/python\\-keycloak\\-httpd\\-client/keycloak\\-httpd\\-client\\-install.log\nInstallation log file\n\n.PP\n.B DEBUGGING\n.PP\nThe \\fB\\-\\-verbose\\fR and \\fB\\-\\-debug\\fR options can be used to increase the level of detail emitted on the console. However, note the log file logs everything at the \\fIDEBUG\\fR level so it is usually easier to consult the log file when debugging (see \\fBLOGGING\\fR)\n\n.PP\n.B LOGGING\n.PP\n\\fBkeycloak\\-httpd\\-client\\-install\\fR logs all it's operations to a rotated log file. The default log file can be overridden with the \\fB\\-\\-log\\-file\\fR option. Each run of \\fBkeycloak\\-httpd\\-client\\-install\\fR will create a new log file. Any previous log file will be rotated as a numbered verson keeping a maximum of 3 previous log files. Logging to the log file occurs at the \\fIDEBUG\\fR level that includes all HTTP requests and responses, this is useful for debugging.\n\n.PP\n.B TEMPLATES\n.PP\nMany of the files generated by \\fBkeycloak\\-httpd\\-client\\-install\\fR are produced via jinja2 templates substituting values determined by \\fBkeycloak\\-httpd\\-client\\-install\\fR when it runs. The default template file location can be overridden with the \\fB\\-\\-template\\-dir\\fR option.\n\n.PP\n.SH EXIT STATUS\n.RS\n.PP\n\\fB0\\fR: SUCCESS\n.PP\n\\fB1\\fR: OPERATION_ERROR\n.PP\n\\fB2\\fR: CONFIGURATION_ERROR\n.PP\n\\fB3\\fR: INSUFFICIENT_PRIVILEGE\n.PP\n\\fB4\\fR: COMMUNICATION_ERROR\n.PP\n\\fB5\\fR: ALREADY_EXISTS_ERROR\n.RE\n\n.SH AUTHOR\nJohn Dennis <jdennis@redhat.com>\n", "from __future__ import print_function\n\nimport argparse\nimport json\nfrom oauthlib.oauth2 import LegacyApplicationClient\nimport logging\nimport logging.handlers\nfrom requests_oauthlib import OAuth2Session\nimport os\nimport requests\nimport six\nimport sys\nimport traceback\n\nfrom six.moves.urllib.parse import quote as urlquote\nfrom six.moves.urllib.parse import urlparse\n\n\n# ------------------------------------------------------------------------------\n\nlogger = None\nprog_name = os.path.basename(sys.argv[0])\nAUTH_ROLES = ['root-admin', 'realm-admin', 'anonymous']\n\nLOG_FILE_ROTATION_COUNT = 3\n\nTOKEN_URL_TEMPLATE = (\n    '{server}/auth/realms/{realm}/protocol/openid-connect/token')\nGET_SERVER_INFO_TEMPLATE = (\n    '{server}/auth/admin/serverinfo/')\nGET_REALMS_URL_TEMPLATE = (\n    '{server}/auth/admin/realms')\nCREATE_REALM_URL_TEMPLATE = (\n    '{server}/auth/admin/realms')\nDELETE_REALM_URL_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}')\nGET_REALM_METADATA_TEMPLATE = (\n    '{server}/auth/realms/{realm}/protocol/saml/descriptor')\n\nCLIENT_REPRESENTATION_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients/{id}')\nGET_CLIENTS_URL_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients')\nCLIENT_DESCRIPTOR_URL_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/client-description-converter')\nCREATE_CLIENT_URL_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients')\n\nGET_INITIAL_ACCESS_TOKEN_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients-initial-access')\nSAML2_CLIENT_REGISTRATION_TEMPLATE = (\n  '{server}/auth/realms/{realm}/clients-registrations/saml2-entity-descriptor')\n\nGET_CLIENT_PROTOCOL_MAPPERS_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients/{id}/protocol-mappers/models')\nGET_CLIENT_PROTOCOL_MAPPERS_BY_PROTOCOL_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients/{id}/protocol-mappers/protocol/{protocol}')\n\nPOST_CLIENT_PROTOCOL_MAPPER_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients/{id}/protocol-mappers/models')\n\n\nADMIN_CLIENT_ID = 'admin-cli'\n\n# ------------------------------------------------------------------------------\n\n\nclass RESTError(Exception):\n    def __init__(self, status_code, status_reason,\n                 response_json, response_text, cmd):\n        self.status_code = status_code\n        self.status_reason = status_reason\n        self.error_description = None\n        self.error = None\n        self.response_json = response_json\n        self.response_text = response_text\n        self.cmd = cmd\n\n        self.message = '{status_reason}({status_code}): '.format(\n            status_reason=self.status_reason,\n            status_code=self.status_code)\n\n        if response_json:\n            self.error_description = response_json.get('error_description')\n            if self.error_description is None:\n                self.error_description = response_json.get('errorMessage')\n            self.error = response_json.get('error')\n            self.message += '\"{error_description}\" [{error}]'.format(\n                error_description=self.error_description,\n                error=self.error)\n        else:\n            self.message += '\"{response_text}\"'.format(\n                response_text=self.response_text)\n\n        self.args = (self.message,)\n\n    def __str__(self):\n        return self.message\n\n# ------------------------------------------------------------------------------\n\n\ndef configure_logging(options):\n    global logger  # pylint: disable=W0603\n\n    log_dir = os.path.dirname(options.log_file)\n    if os.path.exists(log_dir):\n        if not os.path.isdir(log_dir):\n            raise ValueError('logging directory \"{log_dir}\" exists but is not '\n                             'directory'.format(log_dir=log_dir))\n    else:\n        os.makedirs(log_dir)\n\n    log_level = logging.ERROR\n    if options.verbose:\n        log_level = logging.INFO\n    if options.debug:\n        log_level = logging.DEBUG\n\n        # These two lines enable debugging at httplib level\n        # (requests->urllib3->http.client) You will see the REQUEST,\n        # including HEADERS and DATA, and RESPONSE with HEADERS but\n        # without DATA.  The only thing missing will be the\n        # response.body which is not logged.\n        try:\n            import http.client as http_client  # Python 3\n        except ImportError:\n            import httplib as http_client      # Python 2\n\n        http_client.HTTPConnection.debuglevel = 1\n\n        # Turn on cookielib debugging\n        if False:\n            try:\n                import http.cookiejar as cookiejar\n            except ImportError:\n                import cookielib as cookiejar  # Python 2\n            cookiejar.debug = True\n\n    logger = logging.getLogger(prog_name)\n\n    try:\n        file_handler = logging.handlers.RotatingFileHandler(\n            options.log_file, backupCount=LOG_FILE_ROTATION_COUNT)\n    except IOError as e:\n        print('Unable to open log file %s (%s)' % (options.log_file, e),\n              file=sys.stderr)\n\n    else:\n        formatter = logging.Formatter(\n            '%(asctime)s %(name)s %(levelname)s: %(message)s')\n        file_handler.setFormatter(formatter)\n        file_handler.setLevel(logging.DEBUG)\n        logger.addHandler(file_handler)\n\n    console_handler = logging.StreamHandler(sys.stdout)\n    formatter = logging.Formatter('%(message)s')\n    console_handler.setFormatter(formatter)\n    console_handler.setLevel(log_level)\n    logger.addHandler(console_handler)\n\n    # Set the log level on the logger to the lowest level\n    # possible. This allows the message to be emitted from the logger\n    # to it's handlers where the level will be filtered on a per\n    # handler basis.\n    logger.setLevel(1)\n\n# ------------------------------------------------------------------------------\n\n\ndef json_pretty(text):\n    return json.dumps(json.loads(text),\n                      indent=4, sort_keys=True)\n\n\ndef py_json_pretty(py_json):\n    return json_pretty(json.dumps(py_json))\n\n\ndef server_name_from_url(url):\n    return urlparse(url).netloc\n\n\ndef get_realm_names_from_realms(realms):\n    return [x['realm'] for x in realms]\n\n\ndef get_client_client_ids_from_clients(clients):\n    return [x['clientId'] for x in clients]\n\n\ndef find_client_by_name(clients, client_id):\n    for client in clients:\n        if client.get('clientId') == client_id:\n            return client\n    raise KeyError('{item} not found'.format(item=client_id))\n\n\n# ------------------------------------------------------------------------------\n\nclass KeycloakREST(object):\n\n    def __init__(self, server, auth_role=None, session=None):\n        self.server = server\n        self.auth_role = auth_role\n        self.session = session\n\n    def get_initial_access_token(self, realm_name):\n        cmd_name = \"get initial access token for realm '{realm}'\".format(\n            realm=realm_name)\n        url = GET_INITIAL_ACCESS_TOKEN_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        params = {\"expiration\": 60,  # seconds\n                  \"count\": 1}\n\n        response = self.session.post(url, json=params)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json    # ClientInitialAccessPresentation\n\n    def get_server_info(self):\n        cmd_name = \"get server info\"\n        url = GET_SERVER_INFO_TEMPLATE.format(server=self.server)\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.get(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json\n\n    def get_realms(self):\n        cmd_name = \"get realms\"\n        url = GET_REALMS_URL_TEMPLATE.format(server=self.server)\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.get(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json\n\n    def create_realm(self, realm_name):\n        cmd_name = \"create realm '{realm}'\".format(realm=realm_name)\n        url = CREATE_REALM_URL_TEMPLATE.format(server=self.server)\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        params = {\"enabled\": True,\n                  \"id\": realm_name,\n                  \"realm\": realm_name,\n                  }\n\n        response = self.session.post(url, json=params)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.created:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n    def delete_realm(self, realm_name):\n        cmd_name = \"delete realm '{realm}'\".format(realm=realm_name)\n        url = DELETE_REALM_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.delete(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.no_content:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n    def get_realm_metadata(self, realm_name):\n        cmd_name = \"get metadata for realm '{realm}'\".format(realm=realm_name)\n        url = GET_REALM_METADATA_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.get(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.ok:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n        return response.text\n\n    def get_clients(self, realm_name):\n        cmd_name = \"get clients in realm '{realm}'\".format(realm=realm_name)\n        url = GET_CLIENTS_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.get(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json\n\n\n    def get_client_by_id(self, realm_name, id):\n        cmd_name = \"get client id {id} in realm '{realm}'\".format(\n            id=id, realm=realm_name)\n        url = GET_CLIENTS_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        params = {'clientID': id}\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.get(url, params=params)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json\n\n\n    def get_client_by_name(self, realm_name, client_name):\n        clients = self.get_clients(realm_name)\n        client = find_client_by_name(clients, client_name)\n        id = client.get('id')\n        logger.debug(\"client name '%s' mapped to id '%s'\",\n                     client_name, id)\n        logger.debug(\"client %s\\n%s\", client_name, py_json_pretty(client))\n        return client\n\n    def get_client_id_by_name(self, realm_name, client_name):\n        client = self.get_client_by_name(realm_name, client_name)\n        id = client.get('id')\n        return id\n\n    def get_client_descriptor(self, realm_name, metadata):\n        cmd_name = \"get client descriptor realm '{realm}'\".format(\n            realm=realm_name)\n        url = CLIENT_DESCRIPTOR_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        headers = {'Content-Type': 'application/xml;charset=utf-8'}\n\n        response = self.session.post(url, headers=headers, data=metadata)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json\n\n    def create_client_from_descriptor(self, realm_name, descriptor):\n        cmd_name = \"create client from descriptor \"\n        \"'{client_id}'in realm '{realm}'\".format(\n            client_id=descriptor['clientId'], realm=realm_name)\n        url = CREATE_CLIENT_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        response = self.session.post(url, json=descriptor)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.created:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n    def create_client(self, realm_name, metadata):\n        logger.debug(\"create client in realm %s on server %s\",\n                     realm_name, self.server)\n        descriptor = self.get_client_descriptor(realm_name, metadata)\n        self.create_client_from_descriptor(realm_name, descriptor)\n        return descriptor\n\n    def register_client(self, initial_access_token, realm_name, metadata):\n        cmd_name = \"register_client realm '{realm}'\".format(\n            realm=realm_name)\n        url = SAML2_CLIENT_REGISTRATION_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        headers = {'Content-Type': 'application/xml;charset=utf-8'}\n\n        if initial_access_token:\n            headers['Authorization'] = 'Bearer {token}'.format(\n                token=initial_access_token)\n\n        response = self.session.post(url, headers=headers, data=metadata)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.created):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json    # ClientRepresentation\n\n    def delete_client_by_name(self, realm_name, client_name):\n        id = self.get_client_id_by_name(realm_name, client_name)\n        self.delete_client_by_id(realm_name, id)\n\n\n    def delete_client_by_id(self, realm_name, id):\n        cmd_name = \"delete client id '{id}'in realm '{realm}'\".format(\n            id=id, realm=realm_name)\n        url = CLIENT_REPRESENTATION_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name),\n            id=urlquote(id))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.delete(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.no_content:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n    def update_client(self, realm_name, client):\n        id = client['id']\n        cmd_name = \"update client {id} in realm '{realm}'\".format(\n            id=client['clientId'], realm=realm_name)\n        url = CLIENT_REPRESENTATION_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name),\n            id=urlquote(id))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        response = self.session.put(url, json=client)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.no_content:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n\n    def update_client_attributes(self, realm_name, client, update_attrs):\n        client_id = client['clientId']\n        logger.debug(\"update client attrs: client_id=%s \"\n        \"current attrs=%s update=%s\" % (client_id, client['attributes'],\n                                update_attrs))\n        client['attributes'].update(update_attrs)\n        logger.debug(\"update client attrs: client_id=%s \"\n        \"new attrs=%s\" % (client_id, client['attributes']))\n        self.update_client(realm_name, client);\n\n\n    def update_client_by_name_attributes(self, realm_name, client_name,\n                                         update_attrs):\n        client = self.get_client_by_name(realm_name, client_name)\n        self.update_client_attributes(realm_name, client, update_attrs)\n\n    def new_saml_group_protocol_mapper(self, mapper_name, attribute_name,\n                                       friendly_name=None,\n                                       single_attribute=True):\n        mapper = {\n            'protocol': 'saml',\n            'name': mapper_name,\n            'protocolMapper': 'saml-group-membership-mapper',\n            'config': {\n                'attribute.name': attribute_name,\n                'attribute.nameformat': 'Basic',\n                'single': single_attribute,\n                'full.path': False,\n            },\n        }\n\n        if friendly_name:\n            mapper['config']['friendly.name'] = friendly_name\n\n        return mapper\n\n    def create_client_protocol_mapper(self, realm_name, client, mapper):\n        id = client['id']\n        cmd_name = (\"create protocol-mapper '{mapper_name}' for client {id} \"\n                    \"in realm '{realm}'\".format(\n                        mapper_name=mapper['name'],id=client['clientId'], realm=realm_name))\n        url = POST_CLIENT_PROTOCOL_MAPPER_TEMPLATE.format(\n            server=self.server,\n            realm=urlquote(realm_name),\n            id=urlquote(id))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        response = self.session.post(url, json=mapper)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.created:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n\n    def create_client_by_name_protocol_mapper(self, realm_name, client_name,\n                                              mapper):\n        client = self.get_client_by_name(realm_name, client_name)\n        self.create_client_protocol_mapper(realm_name, client, mapper)\n\n\n\n    def add_client_by_name_redirect_uris(self, realm_name, client_name, uris):\n        client = self.get_client_by_name(realm_name, client_name)\n\n        uris = set(uris)\n        redirect_uris = set(client['redirectUris'])\n        redirect_uris |= uris\n        client['redirectUris'] = list(redirect_uris)\n        self.update_client(realm_name, client);\n\n    def remove_client_by_name_redirect_uris(self, realm_name, client_name, uris):\n        client = self.get_client_by_name(realm_name, client_name)\n\n        uris = set(uris)\n        redirect_uris = set(client['redirectUris'])\n        redirect_uris -= uris\n        client['redirectUris'] = list(redirect_uris)\n\n        self.update_client(realm_name, client);\n\n\n# ------------------------------------------------------------------------------\n\n\nclass KeycloakAdminConnection(KeycloakREST):\n\n    def __init__(self, server, auth_role, realm, client_id,\n                 username, password, tls_verify):\n        super(KeycloakAdminConnection, self).__init__(server, auth_role)\n\n        self.realm = realm\n        self.client_id = client_id\n        self.username = username\n        self.password = password\n\n        self.session = self._create_session(tls_verify)\n\n    def _create_session(self, tls_verify):\n        token_url = TOKEN_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(self.realm))\n        refresh_url = token_url\n\n        client = LegacyApplicationClient(client_id=self.client_id)\n        session = OAuth2Session(client=client,\n                                auto_refresh_url=refresh_url,\n                                auto_refresh_kwargs={\n                                    'client_id': self.client_id})\n\n        session.verify = tls_verify\n        token = session.fetch_token(token_url=token_url,\n                                    username=self.username,\n                                    password=self.password,\n                                    client_id=self.client_id,\n                                    verify=session.verify)\n\n        return session\n\n\nclass KeycloakAnonymousConnection(KeycloakREST):\n\n    def __init__(self, server, tls_verify):\n        super(KeycloakAnonymousConnection, self).__init__(server, 'anonymous')\n        self.session = self._create_session(tls_verify)\n\n\n    def _create_session(self, tls_verify):\n        session = requests.Session()\n        session.verify = tls_verify\n\n        return session\n\n# ------------------------------------------------------------------------------\n\n\ndef do_server_info(options, conn):\n    server_info = conn.get_server_info()\n    print(json_pretty(server_info))\n\n\ndef do_list_realms(options, conn):\n    realms = conn.get_realms()\n    realm_names = get_realm_names_from_realms(realms)\n    print('\\n'.join(sorted(realm_names)))\n\n\ndef do_create_realm(options, conn):\n    conn.create_realm(options.realm_name)\n\n\ndef do_delete_realm(options, conn):\n    conn.delete_realm(options.realm_name)\n\n\ndef do_get_realm_metadata(options, conn):\n    metadata = conn.get_realm_metadata(options.realm_name)\n    print(metadata)\n\n\ndef do_list_clients(options, conn):\n    clients = conn.get_clients(options.realm_name)\n    client_ids = get_client_client_ids_from_clients(clients)\n    print('\\n'.join(sorted(client_ids)))\n\n\ndef do_create_client(options, conn):\n    metadata = options.metadata.read()\n    descriptor = conn.create_client(options.realm_name, metadata)\n\n\ndef do_register_client(options, conn):\n    metadata = options.metadata.read()\n    client_representation = conn.register_client(\n        options.initial_access_token,\n        options.realm_name, metadata)\n\n\ndef do_delete_client(options, conn):\n    conn.delete_client_by_name(options.realm_name, options.client_name)\n\ndef do_client_test(options, conn):\n    'experimental test code used during development'\n\n    uri = 'https://openstack.jdennis.oslab.test:5000/v3/mellon/fooResponse'\n\n    conn.remove_client_by_name_redirect_uri(options.realm_name,\n                                            options.client_name,\n                                            uri)\n\n# ------------------------------------------------------------------------------\n\nverbose_help = '''\n\nThe structure of the command line arguments is \"noun verb\" where noun\nis one of Keycloak's data items (e.g. realm, client, etc.) and the\nverb is an action to perform on the item. Each of the nouns and verbs\nmay have their own set of arguments which must follow the noun or\nverb.\n\nFor example to delete the client XYZ in the realm ABC:\n\n{prog_name} -s http://example.com:8080 -p password client delete -r ABC -c XYZ\n\nwhere 'client' is the noun, 'delete' is the verb and -r ABC -c XYZ are\narguments to the delete action.\n\nIf the command completes successfully the exit status is 0. The exit\nstatus is 1 if an authenticated connection with the server cannont be\nsuccessfully established. The exit status is 2 if the REST operation\nfails.\n\nThe server should be a scheme://hostname:port URL.\n'''\n\n\nclass TlsVerifyAction(argparse.Action):\n    def __init__(self, option_strings, dest, nargs=None, **kwargs):\n        if nargs is not None:\n            raise ValueError(\"nargs not allowed\")\n        super(TlsVerifyAction, self).__init__(option_strings, dest, **kwargs)\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        if values.lower() in ['true', 'yes', 'on']:\n            verify = True\n        elif values.lower() in ['false', 'no', 'off']:\n            verify = False\n        else:\n            verify = values\n            \n        setattr(namespace, self.dest, verify)\n\ndef main():\n    global logger\n    result = 0\n\n    parser = argparse.ArgumentParser(description='Keycloak REST client',\n                    prog=prog_name,\n                    epilog=verbose_help.format(prog_name=prog_name),\n                    formatter_class=argparse.RawDescriptionHelpFormatter)\n\n    parser.add_argument('-v', '--verbose', action='store_true',\n                        help='be chatty')\n\n    parser.add_argument('-d', '--debug', action='store_true',\n                        help='turn on debug info')\n\n    parser.add_argument('--show-traceback', action='store_true',\n                        help='exceptions print traceback in addition to '\n                             'error message')\n\n    parser.add_argument('--log-file',\n                        default='/tmp/{prog_name}.log'.format(\n                            prog_name=prog_name),\n                        help='log file pathname')\n\n    parser.add_argument('--permit-insecure-transport',  action='store_true',\n                        help='Normally secure transport such as TLS '\n                        'is required, defeat this check')\n\n    parser.add_argument('--tls-verify', action=TlsVerifyAction,\n                        default=True,\n                        help='TLS certificate verification for requests to'\n                        ' the server. May be one of case insenstive '\n                        '[true, yes, on] to enable,'\n                        '[false, no, off] to disable.'\n                        'Or the pathname to a OpenSSL CA bundle to use.'\n                        ' Default is True.')\n\n    group = parser.add_argument_group('Server')\n\n    group.add_argument('-s', '--server',\n                       required=True,\n                       help='DNS name or IP address of Keycloak server')\n\n    group.add_argument('-a', '--auth-role',\n                       choices=AUTH_ROLES,\n                       default='root-admin',\n                       help='authenticating as what type of user (default: root-admin)')\n\n    group.add_argument('-u', '--admin-username',\n                       default='admin',\n                       help='admin user name (default: admin)')\n\n    group.add_argument('-p', '--admin-password',\n                       required=True,\n                       help='admin password')\n\n    group.add_argument('--admin-realm',\n                       default='master',\n                       help='realm admin belongs to')\n\n    cmd_parsers = parser.add_subparsers(help='available commands')\n\n    # --- realm commands ---\n    realm_parser = cmd_parsers.add_parser('realm',\n                                          help='realm operations')\n\n    sub_parser = realm_parser.add_subparsers(help='realm commands')\n\n    cmd_parser = sub_parser.add_parser('server_info',\n                                       help='dump server info')\n    cmd_parser.set_defaults(func=do_server_info)\n\n    cmd_parser = sub_parser.add_parser('list',\n                                       help='list realm names')\n    cmd_parser.set_defaults(func=do_list_realms)\n\n    cmd_parser = sub_parser.add_parser('create',\n                                       help='create new realm')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.set_defaults(func=do_create_realm)\n\n    cmd_parser = sub_parser.add_parser('delete',\n                                       help='delete existing realm')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.set_defaults(func=do_delete_realm)\n\n    cmd_parser = sub_parser.add_parser('metadata',\n                                       help='retrieve realm metadata')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.set_defaults(func=do_get_realm_metadata)\n\n    # --- client commands ---\n    client_parser = cmd_parsers.add_parser('client',\n                                           help='client operations')\n\n    sub_parser = client_parser.add_subparsers(help='client commands')\n\n    cmd_parser = sub_parser.add_parser('list',\n                                       help='list client names')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n\n    cmd_parser.set_defaults(func=do_list_clients)\n\n    cmd_parser = sub_parser.add_parser('create',\n                                       help='create new client')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.add_argument('-m', '--metadata', type=argparse.FileType('rb'),\n                            required=True,\n                            help='SP metadata file or stdin')\n    cmd_parser.set_defaults(func=do_create_client)\n\n    cmd_parser = sub_parser.add_parser('register',\n                                       help='register new client')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.add_argument('-m', '--metadata', type=argparse.FileType('rb'),\n                            required=True,\n                            help='SP metadata file or stdin')\n    cmd_parser.add_argument('--initial-access-token', required=True,\n                            help='realm initial access token for '\n                            'client registeration')\n    cmd_parser.set_defaults(func=do_register_client)\n\n    cmd_parser = sub_parser.add_parser('delete',\n                                       help='delete existing client')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.add_argument('-c', '--client-name', required=True,\n                            help='client name')\n    cmd_parser.set_defaults(func=do_delete_client)\n\n    cmd_parser = sub_parser.add_parser('test',\n                                       help='experimental test used during '\n                                       'development')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.add_argument('-c', '--client-name', required=True,\n                            help='client name')\n    cmd_parser.set_defaults(func=do_client_test)\n\n    # Process command line arguments\n    options = parser.parse_args()\n    configure_logging(options)\n\n    if options.permit_insecure_transport:\n        os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = '1'\n\n    try:\n        anonymous_conn = KeycloakAnonymousConnection(options.server,\n                                                     options.tls_verify)\n\n        admin_conn = KeycloakAdminConnection(options.server,\n                                             options.auth_role,\n                                             options.admin_realm,\n                                             ADMIN_CLIENT_ID,\n                                             options.admin_username,\n                                             options.admin_password,\n                                             options.tls_verify)\n    except Exception as e:\n        if options.show_traceback:\n            traceback.print_exc()\n        print(six.text_type(e), file=sys.stderr)\n        result = 1\n        return result\n\n    try:\n        if options.func == do_register_client:\n            conn = admin_conn\n        else:\n            conn = admin_conn\n        result = options.func(options, conn)\n    except Exception as e:\n        if options.show_traceback:\n            traceback.print_exc()\n        print(six.text_type(e), file=sys.stderr)\n        result = 2\n        return result\n\n    return result\n\n# ------------------------------------------------------------------------------\n\nif __name__ == '__main__':\n    sys.exit(main())\nelse:\n    logger = logging.getLogger('keycloak-cli')\n"], "fixing_code": ["#!/usr/bin/python\n\nfrom __future__ import print_function\n\nimport argparse\nimport base64\nimport copy\nfrom lxml import etree\nimport getpass\nimport grp\nimport jinja2\nfrom keycloak_httpd_client import keycloak_cli\nimport logging\nimport logging.handlers\nfrom collections import namedtuple\nimport os\nimport pwd\nimport re\nfrom keycloak_httpd_client.keycloak_cli import RESTError\nimport requests\nimport shutil\nimport six\nimport socket\nimport subprocess\nimport sys\nimport tempfile\nimport traceback\n\n\nfrom six.moves.urllib.parse import quote as urlquote\nfrom six.moves.urllib.parse import urlsplit, urlunsplit\n\n# ----------------------------- Global Variables ------------------------------\n\nlogger = None\ntemplate_env = None\nprog_name = os.path.basename(sys.argv[0])\nLOG_FILE_ROTATION_COUNT = 3\nBIN_TIMEOUT = \"/usr/bin/timeout\"\n\n# -------------------------------- Constants ----------------------------------\n\nDEV_NULL = '/dev/null'\nBIN_TIMEOUT = '/usr/bin/timeout'\n\nHTTPD_SAML_DIR = 'saml2'\nHTTPD_CONF_DIR = 'conf.d'\n\nMELLON_METADATA_TEMPLATE = 'sp_metadata.tpl'\nMELLON_METADATA = 'sp_metadata.xml'\n\nMELLON_HTTPD_CONFIG_TEMPLATE = 'mellon_httpd.conf'\n\nSTATUS_SUCCESS = 0\nSTATUS_OPERATION_ERROR = 1\nSTATUS_CONFIGURATION_ERROR = 2  # Must be 2 to match argparse exit status\nSTATUS_INSUFFICIENT_PRIVILEGE = 3\nSTATUS_COMMUNICATION_ERROR = 4\nSTATUS_ALREADY_EXISTS_ERROR = 5\n\nSAML_PAOS_BINDING='urn:oasis:names:tc:SAML:2.0:bindings:PAOS'\n\n# --------------------------- Exception Definitions ---------------------------\n\n\nclass AlreadyExistsError(ValueError):\n    pass\n\n# --------------------------- Logging Configuration ---------------------------\n\n\ndef configure_logging(options):\n    global logger  # pylint: disable=W0603\n\n    STEP = logging.INFO + 1\n\n    class StepLogger(logging.Logger):\n\n        def __init__(self, name):\n            self.step_number = 1\n            super(StepLogger, self).__init__(name)\n\n        def step(self, msg, *args, **kwargs):\n            if self.isEnabledFor(STEP):\n                self._log(STEP, ('[Step %2d] ' % self.step_number) + msg,\n                          args, **kwargs)\n                self.step_number += 1\n\n    logging.addLevelName(STEP, 'STEP')\n    logging.setLoggerClass(StepLogger)\n\n    log_dir = os.path.dirname(options.log_file)\n    if os.path.exists(log_dir):\n        if not os.path.isdir(log_dir):\n            raise ValueError('logging directory \"{log_dir}\" exists but is not '\n                             'directory'.format(log_dir=log_dir))\n    else:\n        os.makedirs(log_dir)\n\n    # Check if log exists and should therefore be rolled\n    need_roll = os.path.isfile(options.log_file)\n\n    log_level = STEP\n    if options.verbose:\n        log_level = logging.INFO\n    if options.debug:\n        log_level = logging.DEBUG\n\n        # These two lines enable debugging at httplib level\n        # (requests->urllib3->http.client) You will see the REQUEST,\n        # including HEADERS and DATA, and RESPONSE with HEADERS but\n        # without DATA.  The only thing missing will be the\n        # response.body which is not logged.\n        try:\n            import http.client as http_client  # Python 3\n        except ImportError:\n            import httplib as http_client      # Python 2\n\n        http_client.HTTPConnection.debuglevel = 1\n\n        # Turn on cookielib debugging\n        if False:\n            try:\n                import http.cookiejar as cookiejar\n            except ImportError:\n                import cookielib as cookiejar  # Python 2\n            cookiejar.debug = True\n\n    root_logger = logging.getLogger()\n    logger = logging.getLogger(prog_name)\n\n    try:\n        file_handler = logging.handlers.RotatingFileHandler(\n            options.log_file, mode='w', backupCount=LOG_FILE_ROTATION_COUNT)\n    except IOError as e:\n        print('Unable to open log file %s (%s)' % (options.log_file, e),\n              file=sys.stderr)\n\n    else:\n        formatter = logging.Formatter(\n            '%(asctime)s %(name)s %(levelname)s: %(message)s')\n        file_handler.setFormatter(formatter)\n        file_handler.setLevel(logging.DEBUG)\n        root_logger.addHandler(file_handler)\n\n        if need_roll:\n            file_handler.doRollover()\n\n    console_handler = logging.StreamHandler(sys.stdout)\n    formatter = logging.Formatter('%(message)s')\n    console_handler.setFormatter(formatter)\n    console_handler.setLevel(log_level)\n    root_logger.addHandler(console_handler)\n\n    # Set the log level on the logger to the lowest level\n    # possible. This allows the message to be emitted from the logger\n    # to it's handlers where the level will be filtered on a per\n    # handler basis.\n    root_logger.setLevel(1)\n\n# ----------------------------- General Utilities -----------------------------\n\ndef join_path(*args):\n    '''Join each argument into a final path assuring there is\n    exactly one slash separating all components in the final path\n    and there are no leading or trailing spaces between path components.\n    Initial or final slashes are preserved but are collapsed into a\n    single slash.\n\n    Why not use posixpath.join and posixpath.normpath? Because they do not\n    handle multiple slashes, leading and trailing slashes the way we want'''\n\n    if not args:\n        return ''\n\n    components = []\n\n    for item in args:\n        components.extend(item.split('/'))\n        \n    if components[0]:\n        leading_slash = False\n    else:\n        leading_slash = True \n\n    if components[-1]:\n        trailing_slash = False\n    else:\n        trailing_slash = True\n\n    components = [x.strip() for x in components if x]\n\n    path = '/'.join(components)\n\n    if leading_slash:\n        path = '/' + path\n\n    if trailing_slash and components:\n        path = path + '/'\n\n    return path\n\n# -------------------------- Shell Command Utilities --------------------------\n\n\ndef nolog_replace(string, nolog):\n    \"\"\"Replace occurences of strings given in `nolog` with XXXXXXXX\"\"\"\n    for value in nolog:\n        if not isinstance(value, six.string_types):\n            continue\n\n        quoted = urlquote(value)\n        shquoted = shell_quote(value)\n        for nolog_value in (shquoted, value, quoted):\n            string = string.replace(nolog_value, 'XXXXXXXX')\n    return string\n\n\ndef shell_quote(string):\n    return \"'\" + string.replace(\"'\", \"'\\\\''\") + \"'\"\n\n\ndef run_cmd(args, stdin=None, raiseonerr=True,\n            nolog=(), env=None, capture_output=True, skip_output=False,\n            cwd=None, runas=None, timeout=None, suplementary_groups=[]):\n    \"\"\"\n    Execute a command and return stdin, stdout and the process return code.\n\n    :param args: List of arguments for the command\n    :param stdin: Optional input to the command\n    :param raiseonerr: If True, raises an exception if the return code is\n        not zero\n    :param nolog: Tuple of strings that shouldn't be logged, like passwords.\n        Each tuple consists of a string to be replaced by XXXXXXXX.\n\n        Example:\n        We have a command\n            [paths.SETPASSWD, '--password', 'Secret123', 'someuser']\n        and we don't want to log the password so nolog would be set to:\n        ('Secret123',)\n        The resulting log output would be:\n\n        /usr/bin/setpasswd --password XXXXXXXX someuser\n\n        If a value isn't found in the list it is silently ignored.\n    :param env: Dictionary of environment variables passed to the command.\n        When None, current environment is copied\n    :param capture_output: Capture stderr and stdout\n    :param skip_output: Redirect the output to /dev/null and do not capture it\n    :param cwd: Current working directory\n    :param runas: Name of a user that the command should be run as. The spawned\n        process will have both real and effective UID and GID set.\n    :param timeout: Timeout if the command hasn't returned within the specified\n        number of seconds.\n    :param suplementary_groups: List of group names that will be used as\n        suplementary groups for subporcess.\n        The option runas must be specified together with this option.\n    \"\"\"\n    assert isinstance(suplementary_groups, list)\n    p_in = None\n    p_out = None\n    p_err = None\n\n    if isinstance(nolog, six.string_types):\n        # We expect a tuple (or list, or other iterable) of nolog strings.\n        # Passing just a single string is bad: strings are also, so this\n        # would result in every individual character of that string being\n        # replaced by XXXXXXXX.\n        # This is a sanity check to prevent that.\n        raise ValueError('nolog must be a tuple of strings.')\n\n    if env is None:\n        # copy default env\n        env = copy.deepcopy(os.environ)\n        env[\"PATH\"] = (\n            \"/bin:/sbin:/usr/kerberos/bin:\"\n            \"/usr/kerberos/sbin:/usr/bin:/usr/sbin\")\n    if stdin:\n        p_in = subprocess.PIPE\n    if skip_output:\n        p_out = p_err = open(DEV_NULL, 'w')\n    elif capture_output:\n        p_out = subprocess.PIPE\n        p_err = subprocess.PIPE\n\n    if timeout:\n        # If a timeout was provided, use the timeout command\n        # to execute the requested command.\n        args[0:0] = [BIN_TIMEOUT, str(timeout)]\n\n    arg_string = nolog_replace(' '.join(shell_quote(a) for a in args), nolog)\n    logger.debug('Starting external process')\n    logger.debug('args=%s' % arg_string)\n\n    preexec_fn = None\n    if runas is not None:\n        pent = pwd.getpwnam(runas)\n\n        suplementary_gids = [\n            grp.getgrnam(group).gr_gid for group in suplementary_groups\n        ]\n\n        logger.debug('runas=%s (UID %d, GID %s)', runas,\n                     pent.pw_uid, pent.pw_gid)\n        if suplementary_groups:\n            for group, gid in zip(suplementary_groups, suplementary_gids):\n                logger.debug('suplementary_group=%s (GID %d)', group, gid)\n\n        preexec_fn = lambda: (\n            os.setgroups(suplementary_gids),\n            os.setregid(pent.pw_gid, pent.pw_gid),\n            os.setreuid(pent.pw_uid, pent.pw_uid),\n        )\n\n    try:\n        p = subprocess.Popen(args, stdin=p_in, stdout=p_out, stderr=p_err,\n                             close_fds=True, env=env, cwd=cwd,\n                             preexec_fn=preexec_fn)\n        stdout, stderr = p.communicate(stdin)\n        stdout, stderr = str(stdout), str(stderr)    # Make pylint happy\n    except KeyboardInterrupt:\n        logger.debug('Process interrupted')\n        p.wait()\n        raise\n    except:\n        logger.debug('Process execution failed')\n        raise\n    finally:\n        if skip_output:\n            p_out.close()   # pylint: disable=E1103\n\n    if timeout and p.returncode == 124:\n        logger.debug('Process did not complete before timeout')\n\n    logger.debug('Process finished, return code=%s', p.returncode)\n\n    # The command and its output may include passwords that we don't want\n    # to log. Replace those.\n    if capture_output and not skip_output:\n        stdout = nolog_replace(stdout, nolog)\n        stderr = nolog_replace(stderr, nolog)\n        logger.debug('stdout=%s' % stdout)\n        logger.debug('stderr=%s' % stderr)\n\n    if p.returncode != 0 and raiseonerr:\n        raise subprocess.CalledProcessError(p.returncode, arg_string, stdout)\n\n    return (stdout, stderr, p.returncode)\n\n\ndef install_file(src_file, dst_file):\n    logger.debug('install_file dst_file=\"%s\"', dst_file)\n    if os.path.exists(dst_file):\n        if not os.path.isfile(dst_file):\n            raise ValueError('install file \"{dst_file}\" exists but is not '\n                             'plain file'.format(dst_file=dst_file))\n        dst_backup_file = dst_file + \".orig\"\n        if not os.path.exists(dst_backup_file):\n            os.rename(dst_file, dst_backup_file)\n    shutil.copy(src_file, dst_file)\n\n\ndef install_file_from_data(data, dst_file):\n    logger.debug('install_file_from_data dst_file=\"%s\"', dst_file)\n    if os.path.exists(dst_file):\n        if not os.path.isfile(dst_file):\n            raise ValueError('install file \"{dst_file}\" exists but is not '\n                             'plain file'.format(dst_file=dst_file))\n        dst_backup_file = dst_file + \".orig\"\n        if not os.path.exists(dst_backup_file):\n            os.rename(dst_file, dst_backup_file)\n    with open(dst_file, 'w') as f:\n        f.write(data)\n\n\ndef mkdir(pathname, mode=0o775):\n    logger.debug('mkdir pathname=\"%s\" mode=%#o', pathname, mode)\n    if os.path.exists(pathname):\n        if not os.path.isdir(pathname):\n            raise ValueError('mkdir \"{pathname}\" exists but is not '\n                             'directory'.format(pathname=pathname))\n    else:\n        os.makedirs(pathname, mode)\n\n\ndef httpd_restart():\n    cmd = ['/usr/bin/systemctl', 'restart', 'httpd.service']\n    run_cmd(cmd)\n\n# ----------------------------- HTTP Utilities --------------------------------\n\ndef normalize_url(url, default_scheme='https'):\n    '''Assure scheme and port are canonical.\n\n    SAML requires a scheme for URL's, if a scheme is not present add a\n    default scheme.\n\n    Strip the port from the URL if it matches the scheme (e.g. 80 for\n    http and 443 for https)\n\n    Explicitly specifying a default port (e.g. http://example.com:80\n    or https://example.com:443) will cause Mellon to fail. This occurs\n    because the port gets embedded into the location URL for each\n    endpoint in the SP metadata (e.g the Assertion Consumer\n    Service). The IdP sets the Destination attribute in the SAML\n    response by looking it up in the SP metadata, thus the Destination\n    will have the default port in it (e.g. 443). Upon receiving the\n    SAML response the SP compares the URL of the request to the\n    Destination attribute in the SAML response, they must match for\n    the response to be considered valid. However when Mellon asks\n    Apache what the request URL was it won't have the port in it thus\n    the URL comparison fails. So why is the port absent? It turns out\n    that most (all?) browsers will strip the port from a URL if it\n    matches the port for the scheme (e.g. 80 for http and 443 for\n    https). Thus even if you include the port in the URL it will never\n    be included in the URL the browser emits. This also includes\n    stripping the port from the HTTP host header (which Apache uses to\n    reconstruct the URL).\n    '''\n\n    s = urlsplit(url)\n    scheme = s.scheme\n    netloc = s.netloc\n    path = s.path\n    query = s.query\n    fragment = s.fragment\n    hostname = s.hostname\n    port = s.port\n    \n    if not scheme:\n        scheme = default_scheme\n\n    if port is not None:\n        if scheme == 'http' and port == 80:\n            port = None\n        elif scheme == 'https' and port == 443:\n            port = None\n\n    if port is None:\n        netloc = hostname\n    else:\n        netloc = \"%s:%d\" % (hostname, port)\n\n    return urlunsplit((scheme, netloc, path, query, fragment))\n\n# ------------------------------ PEM Utilities --------------------------------\n\n\nclass InvalidBase64Error(ValueError):\n    pass\n\npem_headers = {\n    'csr': 'NEW CERTIFICATE REQUEST',\n    'cert': 'CERTIFICATE',\n    'crl': 'CRL',\n    'cms': 'CMS',\n    'key': 'PRIVATE KEY',\n}\n\nPEMParseResult = namedtuple('PEMParseResult',\n                            ['pem_type',\n                             'pem_start', 'pem_end',\n                             'base64_start', 'base64_end', 'base64_text',\n                             'binary_data'])\n\npem_begin_re = re.compile(r'^-{5}BEGIN\\s+([^-]+)-{5}\\s*$', re.MULTILINE)\npem_end_re = re.compile(r'^-{5}END\\s+([^-]+)-{5}\\s*$', re.MULTILINE)\n\n\ndef pem_search(text, start=0):\n    '''Search for a block of PEM formatted data\n\n    Search for a PEM block in a text string. The search begins at\n    start. If a PEM block is found a PEMParseResult named tuple is\n    returned, otherwise if no PEM block is found None is returned.\n\n    The PEMParseResult named tuple is:\n    (pem_type, pem_start, pem_end, base64_start, base64_end)\n\n    pem_type\n        The text following '-----BEGIN ' in the PEM header.\n        Common examples are 'CERTIFICATE', 'CRL', 'CMS'.\n    pem_start, pem_end\n        The beginning and ending positions of the PEM block\n        including the PEM header and footer.\n    base64_start, base64_end\n        The beginning and ending positions of the base64 text\n        contained inside the PEM header and footer.\n    base64_text\n        The base64 text (e.g. text[b.base64_start : b.base64_end])\n    binary_data\n        The decoded base64 text. None if not decoded.\n\n    If the pem_type is not the same in both the header and footer\n    a ValueError is raised.\n\n    The start and end positions are suitable for use as slices into\n    the text. To search for multiple PEM blocks pass pem_end as the\n    start position for the next iteration. Terminate the iteration\n    when None is returned. Example:\n\n        start = 0\n        while True:\n            b = pem_search(text, start)\n            if b is None:\n                break\n            start = b.pem_end\n\n    :param string text: the text to search for PEM blocks\n    :param int start: the position in text to start searching from\n    :returns: PEMParseResult named tuple or None if not found\n    '''\n\n    match = pem_begin_re.search(text, pos=start)\n    if match:\n        pem_start = match.start()\n        begin_text = match.group(0)\n        base64_start = min(len(text), match.end() + 1)\n        begin_pem_type = match.group(1).strip()\n\n        match = pem_end_re.search(text, pos=base64_start)\n        if match:\n            pem_end = min(len(text), match.end() + 1)\n            base64_end = match.start() - 1\n            end_pem_type = match.group(1).strip()\n        else:\n            raise ValueError(\"failed to find end matching '%s'\" % begin_text)\n\n        if begin_pem_type != end_pem_type:\n            raise ValueError(\"beginning & end PEM types do not match \"\n                             \"(%s != %s)\",\n                             begin_pem_type, end_pem_type)\n    else:\n        return None\n\n    pem_type = begin_pem_type\n    base64_text = text[base64_start:base64_end]\n    try:\n        binary_data = base64.b64decode(base64_text)\n    except Exception as e:\n        binary_data = None\n        raise InvalidBase64Error('failed to base64 decode %s PEM '\n                                 'at position %d: %s' %\n                                 (pem_type, pem_start, e))\n\n    result = PEMParseResult(pem_type=pem_type,\n                            pem_start=pem_start, pem_end=pem_end,\n                            base64_start=base64_start, base64_end=base64_end,\n                            base64_text=base64_text,\n                            binary_data=binary_data)\n    return result\n\n\ndef parse_pem(text, pem_type=None, max_items=None):\n    '''Scan text for PEM data, return list of PEMParseResult\n\n    pem_type operates as a filter on the type of PEM desired. If\n    pem_type is specified only those PEM blocks which match will be\n    included. The pem_type is a logical name, not the actual text in\n    the pem header (e.g. 'cert'). If the pem_type is None all PEM\n    blocks are returned.\n\n    If max_items is specified the result is limited to that number of\n    items.\n\n    The return value is a list of PEMParseResult named tuples.  The\n    PEMParseResult provides complete information about the PEM block\n    including the decoded binary data for the PEM block.  The list is\n    ordered in the same order as found in the text.\n\n    Examples:\n\n        # Get all certs\n        certs = parse_pem(text, 'cert')\n\n        # Get the first cert\n        try:\n            binary_cert = parse_pem(text, 'cert', 1)[0].binary_data\n        except IndexError:\n            raise ValueError('no cert found')\n\n    :param string text: The text to search for PEM blocks\n    :param string pem_type: Only return data for this pem_type.\n                            Valid types are: csr, cert, crl, cms, key.\n                            If pem_type is None no filtering is performed.\n    :param int max_items: Limit the number of blocks returned.\n    :returns: List of PEMParseResult, one for each PEM block found\n    '''\n\n    pem_blocks = []\n    result = []\n    start = 0\n\n    while True:\n        b = pem_search(text, start)\n        if b is None:\n            break\n        start = b.pem_end\n        if pem_type is None:\n            pem_blocks.append(b)\n        else:\n            try:\n                if pem_headers[pem_type] == b.pem_type:\n                    pem_blocks.append(b)\n            except KeyError:\n                raise ValueError('unknown pem_type: %s' % (pem_type))\n\n        if max_items is not None and len(pem_blocks) >= max_items:\n            break\n\n    return pem_blocks\n\n# ------------------------- SAML Metadata Utilities ---------------------------\n\ndef get_sp_assertion_consumer_url(metadata_file, entity_id=None,\n                                  binding=None):\n    '''Retrieve AssertionConsumerURL(s) from SP metadata\n\n    Read and parse the SAML metadata contained in metadata_file.\n\n    If the entity_id is supplied then select the SP matching it,\n    this is useful when the metadata contains multiple SP's. If the\n    entity_id is not supplied then there must be exactly 1 SP in the\n    metadata, that one will be selected.\n\n    If the SAML endpoint binding is supplied then only\n    AssertionConsumerServiceURL's matching that binding will be returned,\n    otherwise all AssertionConsumerURL's will be returned.\n\n    The return value is a list of AssertionConsumerServiceURL's in the order\n    found in the metadata.\n\n    :param metadata_file:        Pathname of SAML Metadata file\n    :param entity_id (optional): EntityID of SP\n    :param binding (optional):   Filter matching this binding\n    :return:                     List of AssertionConsumerServiceURL's\n    '''\n\n    namespaces = dict(md='urn:oasis:names:tc:SAML:2.0:metadata',\n                      saml='urn:oasis:names:tc:SAML:2.0:assertion',\n                      ds='http://www.w3.org/2000/09/xmldsig#')\n\n    root = etree.parse(metadata_file).getroot()\n\n    if True or not entity_id:\n        # If entity_id was not supplied locate a unique SPSSODescriptor\n        xpath = ('//md:EntityDescriptor/md:SPSSODescriptor')\n        sp = root.xpath(xpath, namespaces=namespaces)\n        if len(sp) == 0:\n            raise ValueError('entity_id not supplied and no '\n                             'SPSSODescriptor was found')\n        elif len(sp) > 1:\n            raise ValueError('entity_id not supplied and multiple '\n                             'SPSSODescriptor elements were found')\n\n        xpath = ('ancestor::md:EntityDescriptor')\n        ed = sp[0].xpath(xpath, namespaces=namespaces)\n\n        entity_id =  ed[0].attrib['entityID']\n\n    else:\n        xpath = ('//md:EntityDescriptor[@entityID=\"{entity_id}\"]'\n                 '/md:SPSSODescriptor'.format(entity_id=entity_id))\n\n        sp = root.xpath(xpath, namespaces=namespaces)\n        if len(sp) == 0:\n            raise IndexError('SPSSODescriptor with EntityID=\"{entity_id}\" '\n                             'not found'.format(entity_id=entity_id))\n        elif len(sp) > 1:\n            raise ValueError('multiple SPSSODescriptor with '\n                             'EntityID=\"{entity_id}\" found'.format(\n                                 entity_id=entity_id))\n    sp = sp[0]\n\n    if not binding:\n        xpath = 'md:AssertionConsumerService'\n        acs = sp.xpath(xpath, namespaces=namespaces)\n        urls = [x.attrib['Location'] for x in acs]\n    else:\n        xpath = 'md:AssertionConsumerService[@Binding=\"{binding}\"]'.format(\n            binding=SAML_PAOS_BINDING)\n        acs = sp.xpath(xpath, namespaces=namespaces)\n        urls = [x.attrib['Location'] for x in acs]\n\n    return urls\n\n\ndef get_entity_id_from_metadata(metadata_file, role):\n    '''Retrieve entityID from metadata\n\n    Read and parse the SAML metadata contained in metadata_file,\n    search for one of the following roles and return the entityID\n    associated with that role.\n\n    SSO Identity Provider (role='idp')\n    SSO Service Provider (role='sp')\n    Authentication Authority (role='authn_authority')\n    Attribute Authority (role='attr_authority)\n    Policy Decision Point (role='pdp')\n\n    :param metadata_file:        Pathname of SAML Metadata file\n    :param role:                 one of: idp, sp, authn_authority,\n                                 attr_authority, pdp\n    :return:                     entityID\n    '''\n\n    roles = {'idp':             'IDPSSODescriptor',\n             'sp':              'SPSSODescriptor',\n             'authn_authority': 'AuthnAuthorityDescriptor',\n             'attr_authority':  'AttributeAuthorityDescriptor',\n             'pdp':             'PDPDescriptor'}\n\n\n    role_descriptor = roles.get(role)\n    if role_descriptor is None:\n        raise ValueError(\"invalid role '%s', must be one of: %s\" %\n                         (role, ', '.join(sorted(roles.keys()))))\n\n    namespaces = dict(md='urn:oasis:names:tc:SAML:2.0:metadata',\n                      saml='urn:oasis:names:tc:SAML:2.0:assertion',\n                      ds='http://www.w3.org/2000/09/xmldsig#')\n\n    root = etree.parse(metadata_file).getroot()\n    \n    xpath = '//md:EntityDescriptor/md:%s' % role_descriptor\n    entity = root.xpath(xpath, namespaces=namespaces)\n    if len(entity) == 0:\n        raise ValueError('no %s found' % role_descriptor)\n    elif len(entity) > 1:\n        raise ValueError('multiple EntityDescriptor elements found')\n\n    xpath = ('ancestor::md:EntityDescriptor')\n    ed = entity[0].xpath(xpath, namespaces=namespaces)\n\n    entity_id =  ed[0].attrib['entityID']\n    return entity_id\n\n# -------------------- Certificate Creation & Installation --------------------\n\n\ndef load_cert_from_file(filename, format='base64_text'):\n    '''Load a cert from a file, return as either base64 text or binary.\n\n    :param string filename: The input file to read the cert from.\n    :param string format: One of: 'base64_text', 'binary'\n    :returns: cert in requested format\n    '''\n    with open(filename, 'r') as f:\n        data = f.read()\n\n    certs = parse_pem(data, 'cert')\n\n    if len(certs) == 0:\n        raise ValueError('No cert found in {filename}'.format(\n            filename=filename))\n\n    if len(certs) > 1:\n        raise ValueError('Multiple certs ({num_certs}) '\n                         'found in {filename}'.format(\n                             num_certs=len(certs),\n                             filename=filename))\n\n    if format == 'base64_text':\n        return certs[0].base64_text\n    if format == 'binary':\n        return certs[0].binary\n    else:\n        raise ValueError('Uknown format \"{format}\"'.format(\n            format=format))\n\n\ndef generate_cert(subject):\n    '''Generate self-signed cert and key.\n\n    A new self-signed cert and key is generated.\n    The key and cert are returned as strings in PEM format.\n\n    :param string subject: Certificate subject.\n    :returns: key, cert as 2-tuple of PEM formatted strings\n    '''\n\n    tmpdir = tempfile.mkdtemp()\n    key_file = os.path.join(tmpdir, 'key.pem')\n    cert_file = os.path.join(tmpdir, 'cert.pem')\n    try:\n        openssl_subject = '/CN=%s' % subject\n        cmd = ['openssl',\n               'req', '-x509', '-batch', '-days', '1825',\n               '-newkey', 'rsa:2048', '-nodes', '-subj', openssl_subject,\n               '-keyout', key_file, '-out', cert_file]\n\n        run_cmd(cmd)\n\n        with open(key_file, 'r') as f:\n            key = f.read()\n\n        with open(cert_file, 'r') as f:\n            cert = f.read()\n\n    except Exception:\n        raise\n    finally:\n        shutil.rmtree(tmpdir)\n\n    return key, cert\n\n\ndef install_mellon_cert(options):\n    if options.mellon_key_file or options.mellon_cert_file:\n        if not (options.mellon_key_file and options.mellon_cert_file):\n            raise ValueError('You must specify both a cert and key file, '\n                             'not just one.')\n        install_file(options.mellon_key_file, options.mellon_dst_key_file)\n        install_file(options.mellon_cert_file, options.mellon_dst_cert_file)\n    else:\n        subject = options.mellon_hostname\n        key, cert = generate_cert(subject)\n        install_file_from_data(key, options.mellon_dst_key_file)\n        install_file_from_data(cert, options.mellon_dst_cert_file)\n\n# ---------------------------- Template Builders ------------------------------\n\n\ndef build_template_params(options):\n    params = dict([(x, getattr(options, x)) for x in dir(options)\n                   if not x.startswith('_')])\n    return params\n\n\ndef build_mellon_httpd_config_file(options):\n    template_params = build_template_params(options)\n    template = template_env.get_template(MELLON_HTTPD_CONFIG_TEMPLATE)\n    return template.render(template_params)\n\n\ndef build_mellon_sp_metadata_file(options):\n    template_params = build_template_params(options)\n    template = template_env.get_template(MELLON_METADATA_TEMPLATE)\n    return template.render(template_params)\n\n# ------------ Argparse Argument Conversion/Validation Functions --------------\n\n\ndef arg_type_mellon_endpoint(value):\n    value = value.strip(' /')\n    return value\n\n\ndef arg_type_mellon_protected_location(value):\n    if not value.startswith('/'):\n        raise argparse.ArgumentTypeError('Location must be absolute '\n                                         '(arg=\"%s\")' % value)\n    return value.rstrip(\" /\")\n\nclass DeprecatedPasswordAction(argparse.Action):\n    def __init__(self, option_strings, dest, nargs=None, **kwargs):\n        super(DeprecatedPasswordAction, self).__init__(option_strings, dest,\n                                                       **kwargs)\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        msg1 = ('%s Deprecated. Use --keycloak-admin-password-file instead '\n                '(which also accepts - to read from stdin) '\n                'or the KEYCLOAK_ADMIN_PASSWORD environment variable. '\n                'Using \"-\" to read the password from stdin '\n                'will continue to work for the new few releases for backward '\n                'compatibility, then will be removed. '\n                'See the man page.' % self.option_strings)\n        msg2 = ('Deprecated. It is insecure to pass a password on the '\n                'command line. Use --keycloak-admin-password-file or the '\n                'KEYCLOAK_ADMIN_PASSWORD environment variable instead. '\n                'See the man page.')\n        if values == '-':\n            print(msg1, file=sys.stderr)\n            setattr(namespace, self.dest, values)\n        else:\n            raise argparse.ArgumentError(self, msg2)\n\n# -----------------------------------------------------------------------------\n\n\ndef main():\n    global logger, template_env\n\n    # ===== Command Line Arguments =====\n    parser = argparse.ArgumentParser(\n            description='Configure mod_auth_mellon as Keycloak client',\n            prog=prog_name,\n            formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n\n    # ---- Common Arguments ----\n\n    parser.add_argument('--no-root-check', dest='root_check',\n                        action='store_false',\n                        help='permit running by non-root')\n\n    parser.add_argument('-v', '--verbose', action='store_true',\n                        help='be chatty')\n\n    parser.add_argument('-d', '--debug', action='store_true',\n                        help='turn on debug info')\n\n    parser.add_argument('--show-traceback', action='store_true',\n                        help='exceptions print traceback in addition to '\n                             'error message')\n\n    parser.add_argument('--log-file',\n                        default=('/var/log/python-keycloak-httpd-client/'\n                                 '{prog_name}.log'.\n                                 format(prog_name=prog_name)),\n                        help='log file pathname')\n\n    parser.add_argument('--app-name',\n                        required=True,\n                        help='name of the web app being protected by mellon')\n\n    parser.add_argument('--force', action='store_true',\n                        help='forcefully override safety checks')\n\n    parser.add_argument('--permit-insecure-transport',  action='store_true',\n                        help='Normally secure transport such as TLS '\n                        'is required, defeat this check')\n\n    parser.add_argument('--tls-verify', action=keycloak_cli.TlsVerifyAction,\n                        default=True,\n                        help='TLS certificate verification for requests to'\n                        ' the server. May be one of case insenstive '\n                        '[true, yes, on] to enable,'\n                        '[false, no, off] to disable.'\n                        'Or the pathname to a OpenSSL CA bundle to use.'\n                        ' Default is True.')\n\n    # ---- Argument Group \"Program Configuration\"  ----\n\n    group = parser.add_argument_group('Program Configuration')\n\n    group.add_argument('--template-dir',\n                       default=('/usr/share/'\n                                'keycloak-httpd-client-install/templates'.\n                                format(prog_name=prog_name)),\n                       help='Template location')\n\n    group.add_argument('--httpd-dir',\n                       default='/etc/httpd',\n                       help='Template location')\n\n    # ---- Argument Group \"Keycloak IdP\"  ----\n\n    group = parser.add_argument_group('Keycloak IdP')\n\n    group.add_argument('-r', '--keycloak-realm',\n                       required=True,\n                       help='realm name')\n\n    group.add_argument('-s', '--keycloak-server-url',\n                       required=True,\n                       help='Keycloak server URL')\n\n    group.add_argument('-a', '--keycloak-auth-role',\n                       choices=keycloak_cli.AUTH_ROLES,\n                       default='root-admin',\n                       help='authenticating as what type of user '\n                       '(default: root-admin)')\n\n    group.add_argument('-u', '--keycloak-admin-username', default='admin',\n                       help='admin user name (default: admin)')\n\n    group.add_argument('-P', '--keycloak-admin-password-file',\n                       type=argparse.FileType('rb'),\n                       help=('file containing admin password '\n                             '(or use a hyphen \"-\" to read the password '\n                             'from stdin)'))\n\n    group.add_argument('-p', '--keycloak-admin-password',\n                       action=DeprecatedPasswordAction,\n                       dest='deprecated_keycloak_admin_password',\n                       help=('Deprecated. Use  --keycloak-admin-password-file '\n                             'instead. During transition perion this argument '\n                             'will continue to accept a hyphen to indicate '\n                             'the password will be read read from stdin)'))\n\n    group.add_argument('--keycloak-admin-realm',\n                       default='master',\n                       help='realm admin belongs to')\n\n    group.add_argument('--initial-access-token',\n                       help='realm initial access token for '\n                       'client registeration')\n\n    group.add_argument('--client-originate-method',\n                       choices=['descriptor', 'registration'],\n                       default='descriptor',\n                       help='select Keycloak method for creating SAML client')\n\n    # ---- Argument Group \"Mellon SP\"  ----\n\n    group = parser.add_argument_group('Mellon SP')\n\n    group.add_argument('--mellon-key-file',\n                       help='certficate key file')\n\n    group.add_argument('--mellon-cert-file',\n                       help='certficate file')\n\n    group.add_argument('--mellon-hostname', default=socket.getfqdn(),\n                       help=\"Machine's fully qualified host name\")\n\n    group.add_argument('--mellon-https-port', default=443, type=int,\n                       help=\"SSL/TLS port on mellon-hostname\")\n\n    group.add_argument('--mellon-root', default='/',\n                       help='common root ancestor for all mellon endpoints')\n\n    group.add_argument('--mellon-endpoint', default='mellon',\n                       type=arg_type_mellon_endpoint,\n                       help='Used to form the MellonEndpointPath, e.g. '\n                       '{mellon_root}/{mellon_endpoint}.')\n\n    group.add_argument('--mellon-entity-id',\n                       help='SP SAML Entity ID, '\n                       'defaults to {mellon_http_url}/{mellon_endpoint_path}/metadata')\n\n    group.add_argument('--mellon-idp-attr-name', default='IDP',\n                       help='name of the attribute Mellon adds which will '\n                       'contain the IdP entity id')\n\n    group.add_argument('--mellon-organization-name',\n                       help='Add SAML OrganizationName to SP metadata')\n\n    group.add_argument('--mellon-organization-display-name',\n                       help='Add SAML OrganizationDisplayName to SP metadata')\n\n    group.add_argument('--mellon-organization-url',\n                       help='Add SAML OrganizationURL to SP metadata')\n\n    group.add_argument('-l', '--mellon-protected-locations', action='append',\n                       type=arg_type_mellon_protected_location, default=[],\n                       help='Web location to protect with Mellon. '\n                            'May be specified multiple times')\n\n    # ===== Process command line arguments =====\n\n    options = parser.parse_args()\n\n    # ===== Verify process permission =====\n\n    if options.root_check and os.getuid() != 0:\n        print(\"You must be root to run this program\",\n              file=sys.stderr)\n        return STATUS_INSUFFICIENT_PRIVILEGE\n\n    # ===== Configure Logging =====\n\n    configure_logging(options)\n\n    # ===== Options requiring special handling =====\n\n    options.keycloak_admin_password = None\n    if options.keycloak_auth_role in ['root-admin', 'realm-admin']:\n\n        # We need the admin password for this role\n\n        # 1. Try password file\n        if options.keycloak_admin_password_file is not None:\n            options.keycloak_admin_password = options.keycloak_admin_password_file.readline().strip()\n            options.keycloak_admin_password_file.close()\n\n        # 2. Try KEYCLOAK_ADMIN_PASSWORD environment variable\n        if options.keycloak_admin_password is None:\n            if (('KEYCLOAK_ADMIN_PASSWORD' in os.environ) and\n                (os.environ['KEYCLOAK_ADMIN_PASSWORD'])):\n                options.keycloak_admin_password = (\n                    os.environ['KEYCLOAK_ADMIN_PASSWORD'])\n\n        # 3. Try deprecated keycloak-admin-password, accept only hyphen for stdin\n        try:\n            if options.deprecated_keycloak_admin_password == '-':\n                options.keycloak_admin_password = sys.stdin.readline().strip()\n        except AttributeError:\n            pass\n\n        # 4. Try prompting for the password from the terminal\n        if options.keycloak_admin_password is None:\n            options.keycloak_admin_password = getpass.getpass(\n                'enter %s password: ' % (options.keycloak_admin_username))\n\n        if not options.keycloak_admin_password:\n            parser.error('argument %s is required '\n                         'unless passed in the environment '\n                         'variable KEYCLOAK_ADMIN_PASSWORD' %\n                         ('keycloak-admin-password'))\n\n    # ===== Normalize Options =====\n\n    options.mellon_root = '/' + options.mellon_root.strip(' /')\n    options.mellon_endpoint = options.mellon_endpoint.strip(' /')\n\n    # ===== Synthesize Derived Options =====\n\n    options.httpd_saml_dir = os.path.join(options.httpd_dir, HTTPD_SAML_DIR)\n    options.httpd_conf_dir = os.path.join(options.httpd_dir, HTTPD_CONF_DIR)\n    options.mellon_httpd_config_filename = \\\n        os.path.join(options.httpd_conf_dir,\n                     '{app_name}_mellon_keycloak_{realm}.conf'.format(\n                         app_name=options.app_name,\n                         realm=options.keycloak_realm))\n    options.mellon_sp_metadata_filename = \\\n        os.path.join(options.httpd_saml_dir,\n                     '{app_name}_{mellon_metadata}').format(\n                         app_name=options.app_name,\n                         mellon_metadata=MELLON_METADATA)\n    options.mellon_dst_key_file = \\\n        os.path.join(options.httpd_saml_dir,\n                     '{app_name}.key'.format(\n                         app_name=options.app_name))\n    options.mellon_dst_cert_file = \\\n        os.path.join(options.httpd_saml_dir, '{app_name}.cert'.format(\n            app_name=options.app_name))\n    options.mellon_dst_idp_metadata_file = \\\n        os.path.join(options.httpd_saml_dir,\n                     '{app_name}_keycloak_{realm}_idp_metadata.xml'.format(\n                         app_name=options.app_name,\n                         realm=options.keycloak_realm))\n    options.mellon_http_url = \\\n        normalize_url('https://{mellon_hostname}:{mellon_https_port}'.format(\n            mellon_hostname=options.mellon_hostname,\n            mellon_https_port=options.mellon_https_port))\n    options.mellon_endpoint_path = join_path(options.mellon_root, options.mellon_endpoint)\n\n    if not options.mellon_entity_id:\n        url = urlsplit(options.mellon_http_url)\n        options.mellon_entity_id = urlunsplit((url.scheme, url.netloc,\n                                               join_path(options.mellon_endpoint_path, 'metadata'),\n                                               '', ''))\n\n    # ===== Validate Options =====\n\n    try:\n        if options.keycloak_auth_role == 'anonymous':\n            if options.client_originate_method == 'registration':\n                logger.warn(\"Using client originate method 'registration' with the 'anonymous'\\n\"\n                            \"authentication role disables updating the client configuration after\\n\"\n                            \"registration. You may need to adjust the client configuration manually\\n\"\n                            \"in the Keycloak admin console. Use one of the admin authentication\\n\"\n                            \"roles to permit automated client configuration.\\n\")\n\n            if not options.initial_access_token:\n                raise ValueError(\"You must supply an initial access token \"\n                                 \"with anonymous authentication\")\n\n\n        root = join_path(options.mellon_root, '/')\n        for location in options.mellon_protected_locations:\n            location = join_path(location, '/')\n            if not location.startswith(root):\n                raise ValueError('Invalid protected location \"%s\" '\n                                 'must be equal to or ancestor of the mellon '\n                                 'root \"%s\"' % (\n                                     location, root))\n\n    except Exception as e:\n        if options.show_traceback:\n            traceback.print_exc()\n        print('%s: %s' % (e.__class__.__name__, six.text_type(e)),\n              file=sys.stderr)\n        return STATUS_CONFIGURATION_ERROR\n\n    # ===== Establish Keycloak Server Communication =====\n\n    try:\n        logger.step('Connect to Keycloak Server')\n        logger.info('Connecting to Keycloak server \"%s\"',\n                    options.keycloak_server_url)\n        if options.permit_insecure_transport:\n            os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = '1'\n\n        anonymous_conn = keycloak_cli.KeycloakAnonymousConnection(\n            options.keycloak_server_url,\n            options.tls_verify)\n\n        if options.keycloak_auth_role in ['root-admin', 'realm-admin']:\n            admin_conn = keycloak_cli.KeycloakAdminConnection(\n                options.keycloak_server_url,\n                options.keycloak_auth_role,\n                options.keycloak_admin_realm,\n                keycloak_cli.ADMIN_CLIENT_ID,\n                options.keycloak_admin_username,\n                options.keycloak_admin_password,\n                options.tls_verify)\n        else:\n            admin_conn = None\n\n    except Exception as e:\n        if options.show_traceback:\n            traceback.print_exc()\n        print('%s: %s' % (e.__class__.__name__, six.text_type(e)),\n              file=sys.stderr)\n        return STATUS_COMMUNICATION_ERROR\n\n    # ===== Assure required directories are present =====\n\n    try:\n        logger.step('Create Directories')\n        mkdir(options.httpd_saml_dir)\n        mkdir(options.httpd_conf_dir)\n    except Exception as e:\n        if options.show_traceback:\n            traceback.print_exc()\n        print('%s: %s' % (e.__class__.__name__, six.text_type(e)),\n              file=sys.stderr)\n        return STATUS_OPERATION_ERROR\n\n    # ===== Create jinja2 Template Environment =====\n\n    try:\n        logger.step('Set up template environment')\n        template_env = jinja2.Environment(trim_blocks=True,\n                                          lstrip_blocks=True,\n                                          keep_trailing_newline=True,\n                                          undefined=jinja2.StrictUndefined,\n                                          loader=jinja2.FileSystemLoader(\n                                              options.template_dir))\n    except Exception as e:\n        if options.show_traceback:\n            traceback.print_exc()\n        print('%s: %s' % (e.__class__.__name__, six.text_type(e)),\n              file=sys.stderr)\n        return STATUS_CONFIGURATION_ERROR\n\n    # ===== Congfigure Mellon  =====\n\n    try:\n        logger.step('Set up Service Provider X509 Certificiates')\n        install_mellon_cert(options)\n\n        cert_base64 = load_cert_from_file(options.mellon_dst_cert_file)\n        options.sp_signing_cert = cert_base64\n        options.sp_encryption_cert = cert_base64\n\n        logger.step('Build Mellon httpd config file')\n        mellon_httpd_config = build_mellon_httpd_config_file(options)\n        install_file_from_data(mellon_httpd_config,\n                               options.mellon_httpd_config_filename)\n\n        logger.step('Build Mellon SP metadata file')\n        mellon_sp_metadata = build_mellon_sp_metadata_file(options)\n        install_file_from_data(mellon_sp_metadata,\n                               options.mellon_sp_metadata_filename)\n    except Exception as e:\n        if options.show_traceback:\n            traceback.print_exc()\n        print('%s: %s' % (e.__class__.__name__, six.text_type(e)),\n              file=sys.stderr)\n        return STATUS_OPERATION_ERROR\n\n    # ===== Configure Keycloak  =====\n\n    try:\n        if options.keycloak_auth_role == 'root-admin':\n            logger.step('Query realms from Keycloak server')\n            realms = admin_conn.get_realms()\n            realm_names = keycloak_cli.get_realm_names_from_realms(realms)\n            logger.info('existing realms [%s]', ', '.join(realm_names))\n\n            if options.keycloak_realm not in realm_names:\n                logger.step('Create realm on Keycloak server')\n                logger.info('Create realm \"%s\"', options.keycloak_realm)\n                admin_conn.create_realm(options.keycloak_realm)\n            else:\n                logger.step('Use existing realm on Keycloak server')\n\n        if options.keycloak_auth_role in ['root-admin', 'realm-admin']:\n            logger.step('Query realm clients from Keycloak server')\n            clients = admin_conn.get_clients(options.keycloak_realm)\n            client_ids = keycloak_cli.get_client_client_ids_from_clients(clients)\n            logger.info('existing clients in realm %s = [%s]',\n                        options.keycloak_realm, ', '.join(client_ids))\n\n            if options.mellon_entity_id in client_ids:\n                if options.force:\n                    logger.step('Force delete client on Keycloak server')\n                    logger.info('Delete client \"%s\"', options.mellon_entity_id)\n                    admin_conn.delete_client_by_name(options.keycloak_realm,\n                                                     options.mellon_entity_id)\n\n                else:\n                    raise AlreadyExistsError('client \"{client_id}\" '\n                                             'already exists in realm \"{realm}\". '\n                                             'Use --force to replace it.'.format(\n                                                 client_id=options.mellon_entity_id,\n                                                 realm=options.keycloak_realm))\n\n        if options.client_originate_method == 'descriptor':\n            logger.step('Creating new client from descriptor')\n            logger.info('Create new client \"%s\"', options.mellon_entity_id)\n            admin_conn.create_client(options.keycloak_realm,\n                                     mellon_sp_metadata)\n        elif options.client_originate_method == 'registration':\n\n            if options.initial_access_token:\n                logger.step('Use provided initial access token')\n                initial_access_token = options.initial_access_token\n            else:\n                if options.keycloak_auth_role in ['root-admin', 'realm-admin']:\n                    logger.step('Get new initial access token')\n                    client_initial_access = admin_conn.get_initial_access_token(\n                        options.keycloak_realm)\n                    initial_access_token = client_initial_access['token']\n                else:\n                    raise ValueError(\"You must root or realm admin privileges \"\n                                     \"to acquire an initial access token\")\n\n            logger.step('Creating new client using registration service')\n            logger.info('Register new client \"%s\"', options.mellon_entity_id)\n\n            try:\n                anonymous_conn.register_client(initial_access_token,\n                                               options.keycloak_realm,\n                                               mellon_sp_metadata)\n            except RESTError as e:\n                if e.error_description == \"Client Identifier in use\":\n                    raise AlreadyExistsError('client \"{client_id}\" '\n                                             'already exists in realm \"{realm}\"'.format(\n                                                 client_id=options.mellon_entity_id,\n                                                 realm=options.keycloak_realm))\n                else:\n                    raise\n        else:\n            raise ValueError(\"Unknown client-originate-method = '%s'\" %\n                             options.client_originate_method)\n\n\n        if options.keycloak_auth_role in ['root-admin', 'realm-admin']:\n            # Enable Force Post Binding, registration service fails to\n            # to enable it (however creation with client descriptor does)\n            logger.step('Enable saml.force.post.binding')\n            update_attrs = {'saml.force.post.binding': True}\n            admin_conn.update_client_by_name_attributes(options.keycloak_realm,\n                                                        options.mellon_entity_id,\n                                                        update_attrs)\n\n            logger.step('Add group attribute mapper to client')\n            mapper = admin_conn.new_saml_group_protocol_mapper(\n                'group list', 'groups',\n                friendly_name='List of groups user is a member of')\n            admin_conn.create_client_by_name_protocol_mapper(options.keycloak_realm,\n                                                             options.mellon_entity_id,\n                                                             mapper)\n\n            logger.step('Add Redirect URIs to client')\n            urls = get_sp_assertion_consumer_url(options.mellon_sp_metadata_filename,\n                                                 entity_id=options.mellon_entity_id)\n            admin_conn.add_client_by_name_redirect_uris(options.keycloak_realm,\n                                                        options.mellon_entity_id,\n                                                        urls)\n\n        logger.step('Retrieve IdP metadata from Keycloak server')\n        idp_metadata = anonymous_conn.get_realm_metadata(options.keycloak_realm)\n        install_file_from_data(idp_metadata,\n                               options.mellon_dst_idp_metadata_file)\n\n    except AlreadyExistsError as e:\n        if options.show_traceback:\n            traceback.print_exc()\n        print(six.text_type(e), file=sys.stderr)\n        return STATUS_ALREADY_EXISTS_ERROR\n    except Exception as e:\n        if options.show_traceback:\n            traceback.print_exc()\n        print('%s: %s' % (e.__class__.__name__, six.text_type(e)),\n              file=sys.stderr)\n        return STATUS_OPERATION_ERROR\n\n    # ===== Wrap Up =====\n\n    logger.step('Completed Successfully')\n    logger.info('mellon entityID=\"%s\"' % options.mellon_entity_id)\n    return STATUS_SUCCESS\n\n# -----------------------------------------------------------------------------\n\nif __name__ == '__main__':\n    sys.exit(main())\n", ".TH keycloak-httpd-client-install 1\n\n.SH NAME\nkeycloak-httpd-client-install \\-\nTools to configure Apache HTTPD as Keycloak client\n\n.SH SYNOPSIS\n.B keycloak-httpd-client-install\n[\\fB\\-h\\fR]\n[\\fB\\-\\-no\\-root\\-check\\fR]\n[\\fB\\-v\\fR]\n[\\fB\\-d\\fR]\n[\\fB\\-\\-show\\-traceback\\fR]\n[\\fB\\-\\-log\\-file\\fR \\fILOG_FILE\\fR]\n\\fB\\-\\-app\\-name\\fR \\fIAPP_NAME\\fR\n[\\fB\\-\\-force\\fR]\n[\\fB\\-\\-permit\\-insecure\\-transport\\fR]\n[\\fB\\-\\-tls\\-verify\\fR]\n[\\fB\\-\\-template\\-dir\\fR \\fITEMPLATE_DIR\\fR]\n[\\fB\\-\\-httpd\\-dir\\fR \\fIHTTPD_DIR\\fR] \\-r KEYCLOAK_REALM\n\\fB\\-s\\fR \\fIKEYCLOAK_SERVER_URL\\fR\n[\\fB\\-a\\fR \\fIroot\\-admin|realm\\-admin|anonymous\\fR]\n[\\fB\\-u\\fR \\fIKEYCLOAK_ADMIN_USERNAME\\fR]\n\\fB\\-P\\fR \\fIKEYCLOAK_ADMIN_PASSWORD_FILE\\fR\n\\fB\\-p\\fR \\fIKEYCLOAK_ADMIN_PASSWORD\\fR\n[\\fB\\-\\-keycloak\\-admin\\-realm\\fR \\fIKEYCLOAK_ADMIN_REALM\\fR]\n[\\fB\\-\\-initial\\-access\\-token\\fR \\fIINITIAL_ACCESS_TOKEN\\fR]\n[\\fB\\-\\-client\\-originate\\-method\\fR \\fIdescriptor|registration\\fR]\n[\\fB\\-\\-mellon\\-key\\-file\\fR \\fIMELLON_KEY_FILE\\fR]\n[\\fB\\-\\-mellon\\-cert\\-file\\fR \\fIMELLON_CERT_FILE\\fR]\n[\\fB\\-\\-mellon\\-hostname\\fR \\fIMELLON_HOSTNAME\\fR]\n[\\fB\\-\\-mellon\\-https-port\\fR \\fIMELLON_HTTPS_PORT\\fR]\n[\\fB\\-\\-mellon\\-root\\fR \\fIMELLON_ROOT\\fR]\n[\\fB\\-\\-mellon\\-endpoint\\fR \\fIMELLON_ENDPOINT\\fR]\n[\\fB\\-\\-mellon\\-entity\\-id\\fR \\fIMELLON_ENTITY_ID\\fR]\n[\\fB\\-\\-mellon\\-idp\\-attr\\-name\\fR \\fIMELLON_IDP_ATTR_NAME\\fR]\n[\\fB\\-\\-mellon\\-organization\\-name\\fR \\fIMELLON_ORGANIZATION_NAME\\fR]\n[\\fB\\-\\-mellon\\-organization\\-display\\-name\\fR \\fIMELLON_ORGANIZATION_DISPLAY_NAME\\fR]\n[\\fB\\-\\-mellon\\-organization\\-url\\fR \\fIMELLON_ORGANIZATION_URL\\fR]\n[\\fB\\-l\\fR \\fIMELLON_PROTECTED_LOCATIONS\\fR]\n\nConfigure mod_auth_mellon as Keycloak client\n\n.SH OPTIONS\n.TP\n.BR \\-h \", \" \\-\\-help\nshow this help message and exit\n.TP\n.BR \\-\\-no\\-root\\-check\npermit running by non\\-root\n(default: False)\n.TP\n.BR \\-v \", \" \\-\\-verbose\nbe chatty\n(default: False)\n.TP\n.BR \\-d \", \" \\-\\-debug\nturn on debug info\n(default: False)\n.TP\n.BR \\-\\-show\\-traceback\nexceptions print traceback in addition to error message\n(default: False)\n.TP\n.BR \\-\\-log\\-file \" \" \\fILOG_FILE\\fR\nlog file pathname\n(default: /var/log/python\\-keycloak\\-httpd\\-client/keycloak\\-httpd\\-client\\-install.log)\n.TP\n.BR \\-\\-app\\-name \" \" \\fIAPP_NAME\\fR\nname of the web app being protected by mellon\n(default: None)\n.TP\n.BR  \\-\\-force\nforcefully override safety checks\n(default: False)\n.TP\n.BR \\-\\-permit\\-insecure\\-transport\nNormally secure transport such as TLS is required,\ndefeat this check\n(default: False)\n.TP\n.BR \\-\\-tls\\-verify\nTLS certificate verification for requests to the server. May be one of\ncase insenstive [true, yes, on] to enable, [false, no, off] to\ndisable. Or the pathname to a OpenSSL CA bundle to use.\n(default: True)\n\n.PP\nProgram Configuration:\n\n.TP\n.BR \\-\\-template\\-dir \" \" \\fITEMPLATE_DIR\\fR\nTemplate location\n(default: /usr/share/keycloak\\-httpd\\-client/templates)\n.TP\n.BR \\-\\-httpd\\-dir \" \" \\fIHTTPD_DIR\\fR\nTemplate location\n(default: /etc/httpd)\n\n.PP\nKeycloak IdP:\n\n.TP\n.BR \\-r \", \" \\-\\-keycloak\\-realm \" \" \\fIKEYCLOAK_REALM\\fR\nrealm name\n(default: None)\n.TP\n.BR \\-s \", \" \\-\\-keycloak\\-server\\-url \" \" \\fIKEYCLOAK_SERVER_URL\\fR\nKeycloak server URL\n(default: None)\n.TP\n.BR \\-a \", \" \\-\\-keycloak\\-auth\\-role \" \" \\fIroot\\-admin|realm\\-admin|anonymous\\fR\nauthenticating as what type of user\n(default: root\\-admin)\n.TP\n.BR \\-u \", \" \\-\\-keycloak\\-admin\\-username \" \" \\fIKEYCLOAK_ADMIN_USERNAME\\fR\nadmin user name\n(default: admin)\n.TP\n.BR \\-P \", \" \\-\\-keycloak\\-admin\\-password\\-file \" \" \\fIKEYCLOAK_ADMIN_PASSWORD_FILE\\fR\nfile containing the admin password (or use a hyphen \"-\" to indicate the\npassword will be read from stdin)\n(default: None)\n.TP\n.BR \\-p \", \" \\-\\-keycloak\\-admin\\-password \" \" \\fIKEYCLOAK_ADMIN_PASSWORD\\fR\nadmin password (or use a hyphen \"-\" to to indicate the password will read\nfrom stdin)\n(default: None)\n\\fB Deprecated.\\fR It is insecure to pass a password on the command line.\nUse \\fI\\-\\-keycloak\\-admin\\-password\\-file\\fR instead. \\fBIt is no longer\npossible to use this argument to pass a password.\\fR During a transition\nperiod this argument will continue to accept a hyphen to indicate the\npassword should be read from stdin in a manner identical to\n\\fI\\-\\-keycloak\\-admin\\-password\\-file\\fR.\n.TP\n.BR \\-\\-keycloak\\-admin\\-realm \" \" \\fIKEYCLOAK_ADMIN_REALM\\fR\nrealm admin belongs to\n(default: master)\n.TP\n.BR \\-\\-initial\\-access\\-token \" \" \\fIINITIAL_ACCESS_TOKEN\\fR\nrealm initial access token for client registeration\n(default: None)\n.TP\n.BR \\-\\-client\\-originate\\-method \" \" \\fIdescriptor|registration\\fR\nselect Keycloak method for creating SAML client\n(default: descriptor)\n\n.PP\nMellon SP:\n\n.TP\n.BR \\-\\-mellon\\-key\\-file \" \" \\fIMELLON_KEY_FILE\\fR\ncertficate key file\n(default: None)\n.TP\n.BR \\-\\-mellon\\-cert\\-file \" \" \\fIMELLON_CERT_FILE\\fR\ncertficate file\n(default: None)\n.TP\n.BR \\-\\-mellon\\-hostname \" \" \\fIMELLON_HOSTNAME\\fR\nMachine's fully qualified host name\n.TP\n.BR \\-\\-mellon\\-https\\-port \" \" \\fIMELLON_HTTPS_PORT\\fR\nSSL/TLS port on mellon-hostname\n.TP\n.BR \\-\\-mellon\\-root \" \" \\fIMELLON_ROOT\\fR\nCommon root ancestor for all mellon endpoints\n.TP\n.BR \\-\\-mellon\\-endpoint \" \" \\fIMELLON_ENDPOINT\\fR\nUsed to form the MellonEndpointPath, e.g. \n{mellon_root}/{mellon_endpoint}\n(default: mellon)\n.TP\n.BR \\-\\-mellon\\-entity\\-id \" \" \\fIMELLON_ENTITY_ID\\fR\nSP SAML Entity ID\n(default: {mellon_http_url}/{mellon_root}/{mellon_endpoint_path}/metadata)\n.TP\n.BR \\-\\-mellon\\-idp\\-attr\\-name \" \" \\fIMELLON_IDP_ATTR_NAME\\fR\nName of the attribute Mellon adds which will contain the IdP entity id\n(default: {mellon_http_url}/{mellon_root}/{mellon_endpoint_path}/metadata)\n.TP\n.BR \\-\\-mellon\\-organization\\-name \" \" \\fIMELLON_ORGANIZATION_NAME\\fR\nAdd SAML OrganizationName to SP metadata\n(default: None)\n.TP\n.BR \\-\\-mellon\\-organization\\-display\\-name \" \" \\fIMELLON_ORGANIZATION_DISPLAY_NAME\\fR\nAdd SAML OrganizationDisplayName to SP metadata\n(default: None)\n.TP\n.BR \\-\\-mellon\\-organization\\-url \" \" \\fIMELLON_ORGANIZATION_URL\\fR\nAdd SAML OrganizationURL to SP metadata\n(default: None)\n.TP\n.BR \\-l \", \" \\-\\-mellon\\-protected\\-locations \" \" \\fIMELLON_PROTECTED_LOCATIONS\\fR\nWeb location to protect with Mellon. May be specified multiple times\n(default: [])\n\n.SH DESCRIPTION\n\n\\fBkeycloak\\-httpd\\-client\\-install\\fR will configure a node running Apache with mod_auth_mellon as SAML Service Provider (\\fBSP\\fR) utilizing a \\fBKeycloak\\fR server as an Identity Provider(\\fBIdP\\fR).\n\n.PP\n.B How to pass the Keycloak admin password\n\n.PP\nThe Keycloak admin password may be passed via one of the possible ways listed\nhere in the order the tool looks for the password.\n\n.PP\n\\fB1.\\fR Try the \\fI\\-\\-keycloak\\-admin\\-password\\-file\\fR argument.\nIf it's a hyphen read the password from stdin, otherwise treat the argument\nas the name of a file, open the file and read the password from the file.\n\n.PP\n\\fB2.\\fR Test for the existence of the \\fBKEYCLOAK_ADMIN_PASSWORD\\fR\nenvironment variable. If the \\fBKEYCLOAK_ADMIN_PASSWORD\\fR is defined\nread the password from it.\n\n.PP\n\\fB3.\\fR Try the \\fBdeprecated\\fR \\fI\\-\\-keycloak\\-admin\\-password\\fR argument.\nIf it's a hyphen read the password from stdin, otherwise return an error\nbecause passwords should never be passed on the command line.\n\n.PP\n\\fB4.\\fR Prompt for the password from the terminal.\n\n.PP\n.B Authentication Levels and Permissions\n\n.PP\nThe tool is capable of range of configuration steps. But the extent of those operations may be circumscribed by the privilege level (authorization) the tool is run with. The privilege level is determined by the \\fB\\-\\-keycloak\\-auth\\-role\\fR command line option which may be one of:\n\n.PP\n\\fBroot\\-admin\\fR: The Keycloak installation has a super realm normally called \\fImaster\\fR which is the container for all realms hosted by the Keycloak instance. A user with administration priviliges in the \\fImaster\\fR realm can perform all operations on all realms hosted by the instance. Think of such a user as a root user or root admin.\n.PP\n\\fBrealm\\-admin\\fR: Each subordinate realm in the Keycloak instance may have it's own administrator(s) whose privileges are restricted exclusively to that realm.\n.PP\n\\fBanonymous\\fR: The tool does not authenticate as a user and hence no priviliges are granted. Any privilege is granted by virtue of an \\fIinitial access token\\fR passed in via the \\fB\\-initial\\-access\\-token\\fR command line option. Think of an initial access token as a one time password scoped to a specific realm. The initial access token must be generated by an administrator with sufficient priviliges on the realm and given to the user of the tool. The priviliges conferred by the initial access token are limited to registering the client in the realm utilizing the Keycloak client registration service.\n.PP\nSelecting which authencation role will be used is determined by a combination of the \\fB\\-\\-keycloak\\-auth\\-role\\fR option and the \\fB\\-\\-keycloak\\-admin\\-realm\\fR option. When the authentication role is one of \\fIroot\\-admin\\fR or \\fIrealm\\-admin\\fR the tool will authenticate as a user in a specific realm, the \\fB\\-\\-keycloak\\-admin\\-realm\\fR option declares the realm the administrator will authenticate to. For the \\fIroot\\-admin\\fR role this is typically the \\fImaster\\fR realm. For the \\fIrealm\\-admin\\fR role this would be realm the tool is registrating the client in.\n\n.PP\n.B Determining which authentication role to use\n\nIn general the principle of \\fIleast privilige\\fR should apply. Grant to the tool the least privilige necessary to perform the required action. In oder of least privilige to greatest privilige the following operations are possible under the defined authentication roles:\n\n.PP\n.B anonymous\n.RS\n.PP\n\\fB*\\fR Can register the client using only the Keycloak client registration service. The tool cannot determine a prori if the client already exists in the realm nor can it adjust any configuration options on the client.\n.PP\n\\fB*\\fR The realm must pre\\-exist.\n.RE\n.PP\n.B realm\\-admin\n.RS\n.PP\n\\fB*\\fR Can enumerate the existing clients in the realm to determine if a conflict would occur.\n.PP\n\\fB*\\fR Can delete a pre\\-existing client and replace it with the new client definition if the \\fB\\-\\-force\\fR option is supplied.\n.PP\n\\fB*\\fR Can modify the clients configuration.\n.PP\n\\fB*\\fR Can use either the client registration service or the REST API to create the client.\n.PP\n\\fB*\\fR The realm must pre\\-exist and contain the realm admin user.\n.RE\n.PP\n.B root\\-admin\n.RS\n.PP\n\\fB*\\fR Includes all of the priviliged operation conferred by the \\fIrealm\\-admin\\fR.\n.PP\n\\fB*\\fR Can enumerate existing realms on the Keycloak instance to verify the existence of the target realm the client is to be installed in.\n.PP\n\\fB*\\fR Can create the target realm if it does not exist.\n.RE\n\n.PP\n.B Client creation methods\n\nKeycloak offers two methods to add a client to a realm\n.PP\n.RS\n\\fB*\\fR The OpenID Connect client registration service. Note even though we are registering a SAML Service Provider (SP) which is not part of OAuth2 nor OpenID Connect the client registration service is still capable of registering a SAML SP client. Selected with \\fB\\-\\-client\\-originate\\-method register\\fR.\n.PP\n\\fB*\\fR Utilizing the Keycloak REST API to create and configure the SAML SP client. The Keycloak REST API utilizes a 2\\-step process whereby the SP metadata is sent to the the Keycloak instance and it returns a client descriptor which is then used to create the client. Selected with \\fB\\-\\-client\\-originate\\-method descriptor\\fR.\n.RE\n.PP\nAt the time of this writing the client registration service behaves differently than the REST API. Advice on which to use is likely to be dependent upone the Keycloak version. Note, if anonymous authentication is used in conjunction with a initial access token then the client registration service \\fImust\\fR be used.\n.PP\nThe client registration service requies the use of an initial access token. For all authentiction roles an initial access token can be provided on the command line via the \\fBinitial\\-access\\-token\\fR option. The initial access token will have to have been provided by a Keycloak administrator who pre\\-creates it. If the authencation role is either \\fIroot\\-admin\\fR or \\fIrealm\\-admin\\fR the tool has sufficient privilige to obtain an initial access token on it's behalf negating the need for a Keycloak admin to supply one externally.\n.PP\nThe client registration service may be used by the following authentication roles:\n.RS\n.PP\n\\fB*\\fR root\\-admin\n.PP\n\\fB*\\fR realm\\-admin\n.PP\n\\fB*\\fR anonymous (requires use of \\fB\\-\\-initial\\-access\\-token\\fR)\n.RE\n.PP\nThe REST API may be used by the following authentication roles:\n.RS\n.PP\n\\fB*\\fR root\\-admin\n.PP\n\\fB*\\fR realm\\-admin\n.RE\n\n.SH OPERATION\n\n.PP\n\\fBkeycloak\\-httpd\\-client\\-install\\fR performs the following operational steps:\n\n.PP\n\\fB*\\fR Connect to Keycloak Server.\n.RS\n.PP\nA session is established with the Keycloak server. OAuth2 is used to log in as the admin user using the \\fB\\-\\-keycloak\\-admin\\-username\\fR and \\fB\\-\\-keycloak\\-admin\\-password\\-file\\fR options. The Keycloak server is identified by the \\fB\\-keycloak\\-server\\-url\\fR option. This step is performed first to assure the remaining steps can complete successfully. A session is maintained for efficiency reasons. You may also need to specify \\fB\\-\\-keycloak\\-admin\\-role\\fR and \\fB\\-\\-keycloak\\-admin\\-realm\\fR to indicate the privilege level you are authenticating with. An anonymous auth role connects to the Keycloak service without any authentication.\n.RE\n\n.PP\n\\fB*\\fR Create directories.\n.RS\n.PP\nFiles written by \\fBkeycloak\\-httpd\\-client\\-install\\fR need a destination directory (see \\fBFILES\\fR). If the necessary directories are not present they are created.\n.RE\n.PP\n\\fB*\\fR Set up template environment\n.RS\n.PP\nMany of the files written by \\fBkeycloak\\-httpd\\-client\\-install\\fR are based on \\fIjinga2\\fR templates. The default template file location can be overridden with the \\fB\\-\\-template\\-dir\\fR option.\n.RE\n.PP\n\\fB*\\fR Set up Service Provider X509 Certificiates.\n.RS\n.PP\nA SAML SP must have a X509 certificate and key used to sign and optionally encrypt it's SAML messages sent to the SAML IdP. \\fBkeycloak\\-httpd\\-client\\-install\\fR can generate a self\\-signed certificate for you or you may supply your own key and certificate via the \\fB\\-\\-mellon\\-key\\-file\\fR and \\fB\\-\\-mellon\\-cert\\-file\\fR options. The files must be in PEM format.\n.RE\n.PP\n\\fB*\\fR Build Mellon httpd config file.\n.RS\n.PP\nThe Mellon HTTPD configuration file tells \\fImod_auth_mellon\\fR where to find things such as certificates and metadata files as well as what web resources to protect. It is generated from the \\fImellon_httpd.conf\\fR template file. (see \\fBFILES\\fR). There is one mellon httpd conf file per application.\n.RE\n.PP\n\\fB*\\fR Build Mellon SP metadata file.\n.RS\n.PP\nThe Mellon SP needs to be registered with the Keycloak IdP. This forms a trust relationship and provides infomation to the IdP about the Mellon SP. Registering an SP with an IdP is done via a SP metadata file. The Mellon SP metadata also instructs \\fImod_auth_mellon\\fR how to operate. The Mellon SP is generated from the \\fIsp_metadata.tpl\\fR template file.\n.RE\n.PP\n\\fB*\\fR Query realms from Keycloak server, optionally create new realm.\n.RS\n.PP\nKeycloak supports multi\\-tenancy, it may serve many IdP's each one specified by a Keycloak realm. The \\fB\\-\\-keycloak\\-realm\\fR option identifies which Keycloak realm we will bind to. The Keycloak realm may already exist on the Keycloak server, if it does \\fBkeycloak\\-httpd\\-client\\-install\\fR will use it. If the Keycloak realm does not exist yet it will be created for you.\n.PP\nRequires the \\fIroot\\-admin\\fR auth role.\n.RE\n.PP\n\\fB*\\fR Query realm clients from Keycloak server, optionally delete existing.\n.RS\n.PP\nSAML SP's are one type of Keycloak client that can be serviced by the Keycloak realm IdP. The Mellon SP is a new Keycloak client which needs to be added to the Keycloak realm. However we must assure the new client does not conflict with an existing client on the Keycloak realm. If the Mellon SP is already registered on the Keycloak realm \\fBkeycloak\\-httpd\\-client\\-install\\fR will stop processing and exit with an error unless the \\fB\\-\\-force\\fR option is used. \\fB\\-\\-force\\fR will cause the existing client on the Keycloak realm to be deleted first so that it can be replaced in the next step.\n.PP\nRequires either the \\fIroot\\-admin\\fR or \\fIrealm\\-admin\\fR auth role.\n.RE\n.PP\n\\fB*\\fR Create new SP client in Keycloak realm.\n.RS\n.PP\nThe Mellon SP is registered with the Keycloak realm on the Keycloak server by sending the Keycloak server the Mellon SP metadata to the Keycloak server.\n.PP\nWhen the client\\-originate\\-method is \\fIdescriptor\\fR either the \\fIroot\\-admin\\fR or \\fIrealm\\-admin\\fR auth role is required. When the \\fIclient\\-originate\\-method\\fR is \\fIregistration\\fR the initial access token is mandatory for the \\fIanonymous\\fR auth role and optional for the \\fIroot\\-admin\\fR or \\fIrealm\\-admin\\fR roles.\n.RE\n\n.PP\n\\fB*\\fR Adjust client configuration\n.RS\n.PP\nOverride default Keycloak client values. This varies by Keycloak release.\n.PP\nRequires either the \\fIroot\\-admin\\fR or \\fIrealm\\-admin\\fR auth role.\n.RE\n\n.PP\n\\fB*\\fR Add attributes to be returned in assertion\n.RS\n.PP\nThe client is configured to return necessary attributes. The added attributes are:\n.RS\n.PP\n\\fB*\\fR Groups user is a member of.\n.RE\n.PP\nRequires either the \\fIroot\\-admin\\fR or \\fIrealm\\-admin\\fR auth role.\n.RE\n\n.PP\n\\fB*\\fR Retrieve IdP metadata from Keycloak server.\n.RS\n.PP\nThe Mellon SP needs SAML metadata that describes the Keycloak IdP. The metadata for the Keycloak IdP is fetched from the Keycloak server and stored in a location referenced in the Mellon SP httpd configuration file. (see \\fBFILES\\fR)\n.RE\n\n.PP\n.B STRUCTURE\n.PP\nThe overarching organization is the web application. An independent set of Mellon files are created per application and registered with the Keycloak server. This permits multiple indpendent SAML Service Providers and/or protected web resources to be handled by one Apache instance. When you run \\fBkeycloak\\-httpd\\-client\\-install\\fR you must supply an application name via the \\fB\\-\\-app\\-name\\fR option.\n.PP\nWithin the web application you may protect via SAML multiple independent web resources specified via the \\fB\\-\\-mellon\\-protected\\-locations\\fR /xxx option. This will cause a:\n.PP\n.nf\n.RS\n<Location>\n    AuthType Mellon\n    MellonEnable auth\n    Require valid-user\n</Location>\n.RE\n.fi\n\n.PP\ndirective to be added to the Mellon HTTPD configuration file. The Mellon SP parameters are located at the root of the web application root, each protected location inherits from that.\n\n.SH FILES\n\nFiles created by running \\fBkeycloak\\-httpd\\-client\\-install\\fR:\n.TP\n.B {httpd\\-dir}/conf.d/{app\\-name}_mellon_keycloak_{realm}.conf\nThis is the primary Mellon configuration file for the application. It\nbinds to the Keycloak realm IdP. It is generated from the\n\\fImellon_httpd.conf\\fR template file.\n\n.TP\n.B {httpd\\-dir}/saml2/{app\\-name}.cert\nThe Mellon SP X509 certficate file in PEM format.\n\n.TP\n.B {httpd\\-dir}/saml2/{app\\-name}.key\nThe Mellon SP X509 key file in PEM format.\n\n.TP\n.B {httpd\\-dir}/saml2/{app\\-name}_keycloak_{realm}_idp_metadata.xml\nThe Keycloak SAML2 IdP metadata file. It is fetched from the Keycloak server.\n\n.TP\n.B {httpd\\-dir}/saml2/{app\\-name}_sp_metadata.xml\nThe Mellon SAML2 SP metadata file. It is generated from the\n\\fIsp_metadata.xml\\fR template file.\n\n.PP\n.B Files referenced by \\fBkeycloak\\-httpd\\-client\\-install\\fR when it runs:\n\n.TP\n.B /usr/share/python\\-keycloak\\-httpd\\-client/templates/*\njinja2 templates\n\n.PP\n.B Log files:\n.TP\n.B /var/log/python\\-keycloak\\-httpd\\-client/keycloak\\-httpd\\-client\\-install.log\nInstallation log file\n\n.PP\n.B DEBUGGING\n.PP\nThe \\fB\\-\\-verbose\\fR and \\fB\\-\\-debug\\fR options can be used to increase the level of detail emitted on the console. However, note the log file logs everything at the \\fIDEBUG\\fR level so it is usually easier to consult the log file when debugging (see \\fBLOGGING\\fR)\n\n.PP\n.B LOGGING\n.PP\n\\fBkeycloak\\-httpd\\-client\\-install\\fR logs all it's operations to a rotated log file. The default log file can be overridden with the \\fB\\-\\-log\\-file\\fR option. Each run of \\fBkeycloak\\-httpd\\-client\\-install\\fR will create a new log file. Any previous log file will be rotated as a numbered verson keeping a maximum of 3 previous log files. Logging to the log file occurs at the \\fIDEBUG\\fR level that includes all HTTP requests and responses, this is useful for debugging.\n\n.PP\n.B TEMPLATES\n.PP\nMany of the files generated by \\fBkeycloak\\-httpd\\-client\\-install\\fR are produced via jinja2 templates substituting values determined by \\fBkeycloak\\-httpd\\-client\\-install\\fR when it runs. The default template file location can be overridden with the \\fB\\-\\-template\\-dir\\fR option.\n\n.PP\n.SH EXIT STATUS\n.RS\n.PP\n\\fB0\\fR: SUCCESS\n.PP\n\\fB1\\fR: OPERATION_ERROR\n.PP\n\\fB2\\fR: CONFIGURATION_ERROR\n.PP\n\\fB3\\fR: INSUFFICIENT_PRIVILEGE\n.PP\n\\fB4\\fR: COMMUNICATION_ERROR\n.PP\n\\fB5\\fR: ALREADY_EXISTS_ERROR\n.RE\n\n.SH AUTHOR\nJohn Dennis <jdennis@redhat.com>\n", "from __future__ import print_function\n\nimport argparse\nimport json\nfrom oauthlib.oauth2 import LegacyApplicationClient\nimport logging\nimport logging.handlers\nfrom requests_oauthlib import OAuth2Session\nimport os\nimport requests\nimport six\nimport sys\nimport traceback\n\nfrom six.moves.urllib.parse import quote as urlquote\nfrom six.moves.urllib.parse import urlparse\n\n\n# ------------------------------------------------------------------------------\n\nlogger = None\nprog_name = os.path.basename(sys.argv[0])\nAUTH_ROLES = ['root-admin', 'realm-admin', 'anonymous']\n\nLOG_FILE_ROTATION_COUNT = 3\n\nTOKEN_URL_TEMPLATE = (\n    '{server}/auth/realms/{realm}/protocol/openid-connect/token')\nGET_SERVER_INFO_TEMPLATE = (\n    '{server}/auth/admin/serverinfo/')\nGET_REALMS_URL_TEMPLATE = (\n    '{server}/auth/admin/realms')\nCREATE_REALM_URL_TEMPLATE = (\n    '{server}/auth/admin/realms')\nDELETE_REALM_URL_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}')\nGET_REALM_METADATA_TEMPLATE = (\n    '{server}/auth/realms/{realm}/protocol/saml/descriptor')\n\nCLIENT_REPRESENTATION_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients/{id}')\nGET_CLIENTS_URL_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients')\nCLIENT_DESCRIPTOR_URL_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/client-description-converter')\nCREATE_CLIENT_URL_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients')\n\nGET_INITIAL_ACCESS_TOKEN_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients-initial-access')\nSAML2_CLIENT_REGISTRATION_TEMPLATE = (\n  '{server}/auth/realms/{realm}/clients-registrations/saml2-entity-descriptor')\n\nGET_CLIENT_PROTOCOL_MAPPERS_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients/{id}/protocol-mappers/models')\nGET_CLIENT_PROTOCOL_MAPPERS_BY_PROTOCOL_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients/{id}/protocol-mappers/protocol/{protocol}')\n\nPOST_CLIENT_PROTOCOL_MAPPER_TEMPLATE = (\n    '{server}/auth/admin/realms/{realm}/clients/{id}/protocol-mappers/models')\n\n\nADMIN_CLIENT_ID = 'admin-cli'\n\n# ------------------------------------------------------------------------------\n\n\nclass RESTError(Exception):\n    def __init__(self, status_code, status_reason,\n                 response_json, response_text, cmd):\n        self.status_code = status_code\n        self.status_reason = status_reason\n        self.error_description = None\n        self.error = None\n        self.response_json = response_json\n        self.response_text = response_text\n        self.cmd = cmd\n\n        self.message = '{status_reason}({status_code}): '.format(\n            status_reason=self.status_reason,\n            status_code=self.status_code)\n\n        if response_json:\n            self.error_description = response_json.get('error_description')\n            if self.error_description is None:\n                self.error_description = response_json.get('errorMessage')\n            self.error = response_json.get('error')\n            self.message += '\"{error_description}\" [{error}]'.format(\n                error_description=self.error_description,\n                error=self.error)\n        else:\n            self.message += '\"{response_text}\"'.format(\n                response_text=self.response_text)\n\n        self.args = (self.message,)\n\n    def __str__(self):\n        return self.message\n\n# ------------------------------------------------------------------------------\n\n\ndef configure_logging(options):\n    global logger  # pylint: disable=W0603\n\n    log_dir = os.path.dirname(options.log_file)\n    if os.path.exists(log_dir):\n        if not os.path.isdir(log_dir):\n            raise ValueError('logging directory \"{log_dir}\" exists but is not '\n                             'directory'.format(log_dir=log_dir))\n    else:\n        os.makedirs(log_dir)\n\n    log_level = logging.ERROR\n    if options.verbose:\n        log_level = logging.INFO\n    if options.debug:\n        log_level = logging.DEBUG\n\n        # These two lines enable debugging at httplib level\n        # (requests->urllib3->http.client) You will see the REQUEST,\n        # including HEADERS and DATA, and RESPONSE with HEADERS but\n        # without DATA.  The only thing missing will be the\n        # response.body which is not logged.\n        try:\n            import http.client as http_client  # Python 3\n        except ImportError:\n            import httplib as http_client      # Python 2\n\n        http_client.HTTPConnection.debuglevel = 1\n\n        # Turn on cookielib debugging\n        if False:\n            try:\n                import http.cookiejar as cookiejar\n            except ImportError:\n                import cookielib as cookiejar  # Python 2\n            cookiejar.debug = True\n\n    logger = logging.getLogger(prog_name)\n\n    try:\n        file_handler = logging.handlers.RotatingFileHandler(\n            options.log_file, backupCount=LOG_FILE_ROTATION_COUNT)\n    except IOError as e:\n        print('Unable to open log file %s (%s)' % (options.log_file, e),\n              file=sys.stderr)\n\n    else:\n        formatter = logging.Formatter(\n            '%(asctime)s %(name)s %(levelname)s: %(message)s')\n        file_handler.setFormatter(formatter)\n        file_handler.setLevel(logging.DEBUG)\n        logger.addHandler(file_handler)\n\n    console_handler = logging.StreamHandler(sys.stdout)\n    formatter = logging.Formatter('%(message)s')\n    console_handler.setFormatter(formatter)\n    console_handler.setLevel(log_level)\n    logger.addHandler(console_handler)\n\n    # Set the log level on the logger to the lowest level\n    # possible. This allows the message to be emitted from the logger\n    # to it's handlers where the level will be filtered on a per\n    # handler basis.\n    logger.setLevel(1)\n\n# ------------------------------------------------------------------------------\n\n\ndef json_pretty(text):\n    return json.dumps(json.loads(text),\n                      indent=4, sort_keys=True)\n\n\ndef py_json_pretty(py_json):\n    return json_pretty(json.dumps(py_json))\n\n\ndef server_name_from_url(url):\n    return urlparse(url).netloc\n\n\ndef get_realm_names_from_realms(realms):\n    return [x['realm'] for x in realms]\n\n\ndef get_client_client_ids_from_clients(clients):\n    return [x['clientId'] for x in clients]\n\n\ndef find_client_by_name(clients, client_id):\n    for client in clients:\n        if client.get('clientId') == client_id:\n            return client\n    raise KeyError('{item} not found'.format(item=client_id))\n\n\n# ------------------------------------------------------------------------------\n\nclass KeycloakREST(object):\n\n    def __init__(self, server, auth_role=None, session=None):\n        self.server = server\n        self.auth_role = auth_role\n        self.session = session\n\n    def get_initial_access_token(self, realm_name):\n        cmd_name = \"get initial access token for realm '{realm}'\".format(\n            realm=realm_name)\n        url = GET_INITIAL_ACCESS_TOKEN_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        params = {\"expiration\": 60,  # seconds\n                  \"count\": 1}\n\n        response = self.session.post(url, json=params)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json    # ClientInitialAccessPresentation\n\n    def get_server_info(self):\n        cmd_name = \"get server info\"\n        url = GET_SERVER_INFO_TEMPLATE.format(server=self.server)\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.get(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json\n\n    def get_realms(self):\n        cmd_name = \"get realms\"\n        url = GET_REALMS_URL_TEMPLATE.format(server=self.server)\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.get(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json\n\n    def create_realm(self, realm_name):\n        cmd_name = \"create realm '{realm}'\".format(realm=realm_name)\n        url = CREATE_REALM_URL_TEMPLATE.format(server=self.server)\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        params = {\"enabled\": True,\n                  \"id\": realm_name,\n                  \"realm\": realm_name,\n                  }\n\n        response = self.session.post(url, json=params)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.created:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n    def delete_realm(self, realm_name):\n        cmd_name = \"delete realm '{realm}'\".format(realm=realm_name)\n        url = DELETE_REALM_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.delete(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.no_content:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n    def get_realm_metadata(self, realm_name):\n        cmd_name = \"get metadata for realm '{realm}'\".format(realm=realm_name)\n        url = GET_REALM_METADATA_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.get(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.ok:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n        return response.text\n\n    def get_clients(self, realm_name):\n        cmd_name = \"get clients in realm '{realm}'\".format(realm=realm_name)\n        url = GET_CLIENTS_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.get(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json\n\n\n    def get_client_by_id(self, realm_name, id):\n        cmd_name = \"get client id {id} in realm '{realm}'\".format(\n            id=id, realm=realm_name)\n        url = GET_CLIENTS_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        params = {'clientID': id}\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.get(url, params=params)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json\n\n\n    def get_client_by_name(self, realm_name, client_name):\n        clients = self.get_clients(realm_name)\n        client = find_client_by_name(clients, client_name)\n        id = client.get('id')\n        logger.debug(\"client name '%s' mapped to id '%s'\",\n                     client_name, id)\n        logger.debug(\"client %s\\n%s\", client_name, py_json_pretty(client))\n        return client\n\n    def get_client_id_by_name(self, realm_name, client_name):\n        client = self.get_client_by_name(realm_name, client_name)\n        id = client.get('id')\n        return id\n\n    def get_client_descriptor(self, realm_name, metadata):\n        cmd_name = \"get client descriptor realm '{realm}'\".format(\n            realm=realm_name)\n        url = CLIENT_DESCRIPTOR_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        headers = {'Content-Type': 'application/xml;charset=utf-8'}\n\n        response = self.session.post(url, headers=headers, data=metadata)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.ok):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json\n\n    def create_client_from_descriptor(self, realm_name, descriptor):\n        cmd_name = \"create client from descriptor \"\n        \"'{client_id}'in realm '{realm}'\".format(\n            client_id=descriptor['clientId'], realm=realm_name)\n        url = CREATE_CLIENT_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        response = self.session.post(url, json=descriptor)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.created:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n    def create_client(self, realm_name, metadata):\n        logger.debug(\"create client in realm %s on server %s\",\n                     realm_name, self.server)\n        descriptor = self.get_client_descriptor(realm_name, metadata)\n        self.create_client_from_descriptor(realm_name, descriptor)\n        return descriptor\n\n    def register_client(self, initial_access_token, realm_name, metadata):\n        cmd_name = \"register_client realm '{realm}'\".format(\n            realm=realm_name)\n        url = SAML2_CLIENT_REGISTRATION_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        headers = {'Content-Type': 'application/xml;charset=utf-8'}\n\n        if initial_access_token:\n            headers['Authorization'] = 'Bearer {token}'.format(\n                token=initial_access_token)\n\n        response = self.session.post(url, headers=headers, data=metadata)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if (not response_json or\n            response.status_code != requests.codes.created):\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, json_pretty(response.text))\n\n        return response_json    # ClientRepresentation\n\n    def delete_client_by_name(self, realm_name, client_name):\n        id = self.get_client_id_by_name(realm_name, client_name)\n        self.delete_client_by_id(realm_name, id)\n\n\n    def delete_client_by_id(self, realm_name, id):\n        cmd_name = \"delete client id '{id}'in realm '{realm}'\".format(\n            id=id, realm=realm_name)\n        url = CLIENT_REPRESENTATION_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name),\n            id=urlquote(id))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n        response = self.session.delete(url)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.no_content:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n    def update_client(self, realm_name, client):\n        id = client['id']\n        cmd_name = \"update client {id} in realm '{realm}'\".format(\n            id=client['clientId'], realm=realm_name)\n        url = CLIENT_REPRESENTATION_TEMPLATE.format(\n            server=self.server, realm=urlquote(realm_name),\n            id=urlquote(id))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        response = self.session.put(url, json=client)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.no_content:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n\n    def update_client_attributes(self, realm_name, client, update_attrs):\n        client_id = client['clientId']\n        logger.debug(\"update client attrs: client_id=%s \"\n        \"current attrs=%s update=%s\" % (client_id, client['attributes'],\n                                update_attrs))\n        client['attributes'].update(update_attrs)\n        logger.debug(\"update client attrs: client_id=%s \"\n        \"new attrs=%s\" % (client_id, client['attributes']))\n        self.update_client(realm_name, client);\n\n\n    def update_client_by_name_attributes(self, realm_name, client_name,\n                                         update_attrs):\n        client = self.get_client_by_name(realm_name, client_name)\n        self.update_client_attributes(realm_name, client, update_attrs)\n\n    def new_saml_group_protocol_mapper(self, mapper_name, attribute_name,\n                                       friendly_name=None,\n                                       single_attribute=True):\n        mapper = {\n            'protocol': 'saml',\n            'name': mapper_name,\n            'protocolMapper': 'saml-group-membership-mapper',\n            'config': {\n                'attribute.name': attribute_name,\n                'attribute.nameformat': 'Basic',\n                'single': single_attribute,\n                'full.path': False,\n            },\n        }\n\n        if friendly_name:\n            mapper['config']['friendly.name'] = friendly_name\n\n        return mapper\n\n    def create_client_protocol_mapper(self, realm_name, client, mapper):\n        id = client['id']\n        cmd_name = (\"create protocol-mapper '{mapper_name}' for client {id} \"\n                    \"in realm '{realm}'\".format(\n                        mapper_name=mapper['name'],id=client['clientId'], realm=realm_name))\n        url = POST_CLIENT_PROTOCOL_MAPPER_TEMPLATE.format(\n            server=self.server,\n            realm=urlquote(realm_name),\n            id=urlquote(id))\n\n        logger.debug(\"%s on server %s\", cmd_name, self.server)\n\n        response = self.session.post(url, json=mapper)\n        logger.debug(\"%s response code: %s %s\",\n                     cmd_name, response.status_code, response.reason)\n\n        try:\n            response_json = response.json()\n        except ValueError as e:\n            response_json = None\n\n        if response.status_code != requests.codes.created:\n            logger.error(\"%s error: status=%s (%s) text=%s\",\n                         cmd_name, response.status_code, response.reason,\n                         response.text)\n            raise RESTError(response.status_code, response.reason,\n                            response_json, response.text, cmd_name)\n\n        logger.debug(\"%s response = %s\", cmd_name, response.text)\n\n\n    def create_client_by_name_protocol_mapper(self, realm_name, client_name,\n                                              mapper):\n        client = self.get_client_by_name(realm_name, client_name)\n        self.create_client_protocol_mapper(realm_name, client, mapper)\n\n\n\n    def add_client_by_name_redirect_uris(self, realm_name, client_name, uris):\n        client = self.get_client_by_name(realm_name, client_name)\n\n        uris = set(uris)\n        redirect_uris = set(client['redirectUris'])\n        redirect_uris |= uris\n        client['redirectUris'] = list(redirect_uris)\n        self.update_client(realm_name, client);\n\n    def remove_client_by_name_redirect_uris(self, realm_name, client_name, uris):\n        client = self.get_client_by_name(realm_name, client_name)\n\n        uris = set(uris)\n        redirect_uris = set(client['redirectUris'])\n        redirect_uris -= uris\n        client['redirectUris'] = list(redirect_uris)\n\n        self.update_client(realm_name, client);\n\n\n# ------------------------------------------------------------------------------\n\n\nclass KeycloakAdminConnection(KeycloakREST):\n\n    def __init__(self, server, auth_role, realm, client_id,\n                 username, password, tls_verify):\n        super(KeycloakAdminConnection, self).__init__(server, auth_role)\n\n        self.realm = realm\n        self.client_id = client_id\n        self.username = username\n        self.password = password\n\n        self.session = self._create_session(tls_verify)\n\n    def _create_session(self, tls_verify):\n        token_url = TOKEN_URL_TEMPLATE.format(\n            server=self.server, realm=urlquote(self.realm))\n        refresh_url = token_url\n\n        client = LegacyApplicationClient(client_id=self.client_id)\n        session = OAuth2Session(client=client,\n                                auto_refresh_url=refresh_url,\n                                auto_refresh_kwargs={\n                                    'client_id': self.client_id})\n\n        session.verify = tls_verify\n        token = session.fetch_token(token_url=token_url,\n                                    username=self.username,\n                                    password=self.password,\n                                    client_id=self.client_id,\n                                    verify=session.verify)\n\n        return session\n\n\nclass KeycloakAnonymousConnection(KeycloakREST):\n\n    def __init__(self, server, tls_verify):\n        super(KeycloakAnonymousConnection, self).__init__(server, 'anonymous')\n        self.session = self._create_session(tls_verify)\n\n\n    def _create_session(self, tls_verify):\n        session = requests.Session()\n        session.verify = tls_verify\n\n        return session\n\n# ------------------------------------------------------------------------------\n\n\ndef do_server_info(options, conn):\n    server_info = conn.get_server_info()\n    print(json_pretty(server_info))\n\n\ndef do_list_realms(options, conn):\n    realms = conn.get_realms()\n    realm_names = get_realm_names_from_realms(realms)\n    print('\\n'.join(sorted(realm_names)))\n\n\ndef do_create_realm(options, conn):\n    conn.create_realm(options.realm_name)\n\n\ndef do_delete_realm(options, conn):\n    conn.delete_realm(options.realm_name)\n\n\ndef do_get_realm_metadata(options, conn):\n    metadata = conn.get_realm_metadata(options.realm_name)\n    print(metadata)\n\n\ndef do_list_clients(options, conn):\n    clients = conn.get_clients(options.realm_name)\n    client_ids = get_client_client_ids_from_clients(clients)\n    print('\\n'.join(sorted(client_ids)))\n\n\ndef do_create_client(options, conn):\n    metadata = options.metadata.read()\n    descriptor = conn.create_client(options.realm_name, metadata)\n\n\ndef do_register_client(options, conn):\n    metadata = options.metadata.read()\n    client_representation = conn.register_client(\n        options.initial_access_token,\n        options.realm_name, metadata)\n\n\ndef do_delete_client(options, conn):\n    conn.delete_client_by_name(options.realm_name, options.client_name)\n\ndef do_client_test(options, conn):\n    'experimental test code used during development'\n\n    uri = 'https://openstack.jdennis.oslab.test:5000/v3/mellon/fooResponse'\n\n    conn.remove_client_by_name_redirect_uri(options.realm_name,\n                                            options.client_name,\n                                            uri)\n\n# ------------------------------------------------------------------------------\n\nverbose_help = '''\n\nThe structure of the command line arguments is \"noun verb\" where noun\nis one of Keycloak's data items (e.g. realm, client, etc.) and the\nverb is an action to perform on the item. Each of the nouns and verbs\nmay have their own set of arguments which must follow the noun or\nverb.\n\nFor example to delete the client XYZ in the realm ABC:\n\necho password | {prog_name} -s http://example.com:8080 -P - client delete -r ABC -c XYZ\n\nwhere 'client' is the noun, 'delete' is the verb and -r ABC -c XYZ are\narguments to the delete action.\n\nIf the command completes successfully the exit status is 0. The exit\nstatus is 1 if an authenticated connection with the server cannont be\nsuccessfully established. The exit status is 2 if the REST operation\nfails.\n\nThe server should be a scheme://hostname:port URL.\n'''\n\n\nclass TlsVerifyAction(argparse.Action):\n    def __init__(self, option_strings, dest, nargs=None, **kwargs):\n        if nargs is not None:\n            raise ValueError(\"nargs not allowed\")\n        super(TlsVerifyAction, self).__init__(option_strings, dest, **kwargs)\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        if values.lower() in ['true', 'yes', 'on']:\n            verify = True\n        elif values.lower() in ['false', 'no', 'off']:\n            verify = False\n        else:\n            verify = values\n            \n        setattr(namespace, self.dest, verify)\n\ndef main():\n    global logger\n    result = 0\n\n    parser = argparse.ArgumentParser(description='Keycloak REST client',\n                    prog=prog_name,\n                    epilog=verbose_help.format(prog_name=prog_name),\n                    formatter_class=argparse.RawDescriptionHelpFormatter)\n\n    parser.add_argument('-v', '--verbose', action='store_true',\n                        help='be chatty')\n\n    parser.add_argument('-d', '--debug', action='store_true',\n                        help='turn on debug info')\n\n    parser.add_argument('--show-traceback', action='store_true',\n                        help='exceptions print traceback in addition to '\n                             'error message')\n\n    parser.add_argument('--log-file',\n                        default='/tmp/{prog_name}.log'.format(\n                            prog_name=prog_name),\n                        help='log file pathname')\n\n    parser.add_argument('--permit-insecure-transport',  action='store_true',\n                        help='Normally secure transport such as TLS '\n                        'is required, defeat this check')\n\n    parser.add_argument('--tls-verify', action=TlsVerifyAction,\n                        default=True,\n                        help='TLS certificate verification for requests to'\n                        ' the server. May be one of case insenstive '\n                        '[true, yes, on] to enable,'\n                        '[false, no, off] to disable.'\n                        'Or the pathname to a OpenSSL CA bundle to use.'\n                        ' Default is True.')\n\n    group = parser.add_argument_group('Server')\n\n    group.add_argument('-s', '--server',\n                       required=True,\n                       help='DNS name or IP address of Keycloak server')\n\n    group.add_argument('-a', '--auth-role',\n                       choices=AUTH_ROLES,\n                       default='root-admin',\n                       help='authenticating as what type of user (default: root-admin)')\n\n    group.add_argument('-u', '--admin-username',\n                       default='admin',\n                       help='admin user name (default: admin)')\n\n    group.add_argument('-P', '--admin-password-file',\n                       type=argparse.FileType('rb'),\n                       help=('file containing admin password '\n                             '(or use a hyphen \"-\" to read the password '\n                             'from stdin)'))\n\n    group.add_argument('--admin-realm',\n                       default='master',\n                       help='realm admin belongs to')\n\n    cmd_parsers = parser.add_subparsers(help='available commands')\n\n    # --- realm commands ---\n    realm_parser = cmd_parsers.add_parser('realm',\n                                          help='realm operations')\n\n    sub_parser = realm_parser.add_subparsers(help='realm commands')\n\n    cmd_parser = sub_parser.add_parser('server_info',\n                                       help='dump server info')\n    cmd_parser.set_defaults(func=do_server_info)\n\n    cmd_parser = sub_parser.add_parser('list',\n                                       help='list realm names')\n    cmd_parser.set_defaults(func=do_list_realms)\n\n    cmd_parser = sub_parser.add_parser('create',\n                                       help='create new realm')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.set_defaults(func=do_create_realm)\n\n    cmd_parser = sub_parser.add_parser('delete',\n                                       help='delete existing realm')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.set_defaults(func=do_delete_realm)\n\n    cmd_parser = sub_parser.add_parser('metadata',\n                                       help='retrieve realm metadata')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.set_defaults(func=do_get_realm_metadata)\n\n    # --- client commands ---\n    client_parser = cmd_parsers.add_parser('client',\n                                           help='client operations')\n\n    sub_parser = client_parser.add_subparsers(help='client commands')\n\n    cmd_parser = sub_parser.add_parser('list',\n                                       help='list client names')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n\n    cmd_parser.set_defaults(func=do_list_clients)\n\n    cmd_parser = sub_parser.add_parser('create',\n                                       help='create new client')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.add_argument('-m', '--metadata', type=argparse.FileType('rb'),\n                            required=True,\n                            help='SP metadata file or stdin')\n    cmd_parser.set_defaults(func=do_create_client)\n\n    cmd_parser = sub_parser.add_parser('register',\n                                       help='register new client')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.add_argument('-m', '--metadata', type=argparse.FileType('rb'),\n                            required=True,\n                            help='SP metadata file or stdin')\n    cmd_parser.add_argument('--initial-access-token', required=True,\n                            help='realm initial access token for '\n                            'client registeration')\n    cmd_parser.set_defaults(func=do_register_client)\n\n    cmd_parser = sub_parser.add_parser('delete',\n                                       help='delete existing client')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.add_argument('-c', '--client-name', required=True,\n                            help='client name')\n    cmd_parser.set_defaults(func=do_delete_client)\n\n    cmd_parser = sub_parser.add_parser('test',\n                                       help='experimental test used during '\n                                       'development')\n    cmd_parser.add_argument('-r', '--realm-name', required=True,\n                            help='realm name')\n    cmd_parser.add_argument('-c', '--client-name', required=True,\n                            help='client name')\n    cmd_parser.set_defaults(func=do_client_test)\n\n    # Process command line arguments\n    options = parser.parse_args()\n    configure_logging(options)\n\n    if options.permit_insecure_transport:\n        os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = '1'\n\n    # Get admin password\n    options.admin_password = None\n\n    # 1. Try password file\n    if options.admin_password_file is not None:\n        options.admin_password = options.keycloak_admin_password_file.readline().strip()\n        options.keycloak_admin_password_file.close()\n\n    # 2. Try KEYCLOAK_ADMIN_PASSWORD environment variable\n    if options.admin_password is None:\n        if (('KEYCLOAK_ADMIN_PASSWORD' in os.environ) and\n            (os.environ['KEYCLOAK_ADMIN_PASSWORD'])):\n            options.admin_password = os.environ['KEYCLOAK_ADMIN_PASSWORD']\n\n    try:\n        anonymous_conn = KeycloakAnonymousConnection(options.server,\n                                                     options.tls_verify)\n\n        admin_conn = KeycloakAdminConnection(options.server,\n                                             options.auth_role,\n                                             options.admin_realm,\n                                             ADMIN_CLIENT_ID,\n                                             options.admin_username,\n                                             options.admin_password,\n                                             options.tls_verify)\n    except Exception as e:\n        if options.show_traceback:\n            traceback.print_exc()\n        print(six.text_type(e), file=sys.stderr)\n        result = 1\n        return result\n\n    try:\n        if options.func == do_register_client:\n            conn = admin_conn\n        else:\n            conn = admin_conn\n        result = options.func(options, conn)\n    except Exception as e:\n        if options.show_traceback:\n            traceback.print_exc()\n        print(six.text_type(e), file=sys.stderr)\n        result = 2\n        return result\n\n    return result\n\n# ------------------------------------------------------------------------------\n\nif __name__ == '__main__':\n    sys.exit(main())\nelse:\n    logger = logging.getLogger('keycloak-cli')\n"], "filenames": ["bin/keycloak-httpd-client-install", "doc/keycloak-httpd-client-install.8", "keycloak_httpd_client/keycloak_cli.py"], "buggy_code_start_loc": [854, 23, 816], "buggy_code_end_loc": [1034, 285, 996], "fixing_code_start_loc": [855, 24, 816], "fixing_code_end_loc": [1085, 323, 1013], "type": "CWE-200", "message": "keycloak-httpd-client-install versions before 0.8 allow users to insecurely pass password through command line, leaking it via command history and process info to other local users.", "other": {"cve": {"id": "CVE-2017-15112", "sourceIdentifier": "secalert@redhat.com", "published": "2018-01-20T00:29:00.517", "lastModified": "2019-08-06T17:15:15.303", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "keycloak-httpd-client-install versions before 0.8 allow users to insecurely pass password through command line, leaking it via command history and process info to other local users."}, {"lang": "es", "value": "keycloak-httpd-client-install, en versiones anteriores a la 0.8, permite que los usuarios pasen la contrase\u00f1a de forma no segura a trav\u00e9s de la l\u00ednea de comandos, filtr\u00e1ndola mediante el historial de comandos y procesen la informaci\u00f3n a otros usuarios locales."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:keycloak-httpd-client-install_project:keycloak-httpd-client-install:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8", "matchCriteriaId": "AD338DCE-487F-49A6-B72F-90037280ACAA"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:2137", "source": "secalert@redhat.com"}, {"url": "https://github.com/jdennis/keycloak-httpd-client-install/commit/c3121b271abaaa1a76de2b9ae89dacde0105cd75", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/jdennis/keycloak-httpd-client-install/commit/c3121b271abaaa1a76de2b9ae89dacde0105cd75"}}