{"buggy_code": ["/* Userspace key control operations\n *\n * Copyright (C) 2004-5 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/key.h>\n#include <linux/keyctl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\n#define KEY_MAX_DESC_SIZE 4096\n\nstatic int key_get_type_from_user(char *type,\n\t\t\t\t  const char __user *_type,\n\t\t\t\t  unsigned len)\n{\n\tint ret;\n\n\tret = strncpy_from_user(type, _type, len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0 || ret >= len)\n\t\treturn -EINVAL;\n\tif (type[0] == '.')\n\t\treturn -EPERM;\n\ttype[len - 1] = '\\0';\n\treturn 0;\n}\n\n/*\n * Extract the description of a new key from userspace and either add it as a\n * new key to the specified keyring or update a matching key in that keyring.\n *\n * If the description is NULL or an empty string, the key type is asked to\n * generate one from the payload.\n *\n * The keyring must be writable so that we can attach the key to it.\n *\n * If successful, the new key's serial number is returned, otherwise an error\n * code is returned.\n */\nSYSCALL_DEFINE5(add_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst void __user *, _payload,\n\t\tsize_t, plen,\n\t\tkey_serial_t, ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tchar type[32], *description;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* draw all the data into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = NULL;\n\tif (_description) {\n\t\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(description)) {\n\t\t\tret = PTR_ERR(description);\n\t\t\tgoto error;\n\t\t}\n\t\tif (!*description) {\n\t\t\tkfree(description);\n\t\t\tdescription = NULL;\n\t\t} else if ((description[0] == '.') &&\n\t\t\t   (strncmp(type, \"keyring\", 7) == 0)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto error2;\n\t\t}\n\t}\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (plen) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error2;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error3;\n\t}\n\n\t/* find the target keyring (which must be writable) */\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error3;\n\t}\n\n\t/* create or update the requested key and add it to the target\n\t * keyring */\n\tkey_ref = key_create_or_update(keyring_ref, type, description,\n\t\t\t\t       payload, plen, KEY_PERM_UNDEF,\n\t\t\t\t       KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key_ref)) {\n\t\tret = key_ref_to_ptr(key_ref)->serial;\n\t\tkey_ref_put(key_ref);\n\t}\n\telse {\n\t\tret = PTR_ERR(key_ref);\n\t}\n\n\tkey_ref_put(keyring_ref);\n error3:\n\tif (payload) {\n\t\tmemzero_explicit(payload, plen);\n\t\tkvfree(payload);\n\t}\n error2:\n\tkfree(description);\n error:\n\treturn ret;\n}\n\n/*\n * Search the process keyrings and keyring trees linked from those for a\n * matching key.  Keyrings must have appropriate Search permission to be\n * searched.\n *\n * If a key is found, it will be attached to the destination keyring if there's\n * one specified and the serial number of the key will be returned.\n *\n * If no key is found, /sbin/request-key will be invoked if _callout_info is\n * non-NULL in an attempt to create a key.  The _callout_info string will be\n * passed to /sbin/request-key to aid with completing the request.  If the\n * _callout_info string is \"\" then it will be changed to \"-\".\n */\nSYSCALL_DEFINE4(request_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst char __user *, _callout_info,\n\t\tkey_serial_t, destringid)\n{\n\tstruct key_type *ktype;\n\tstruct key *key;\n\tkey_ref_t dest_ref;\n\tsize_t callout_len;\n\tchar type[32], *description, *callout_info;\n\tlong ret;\n\n\t/* pull the type into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* pull the description into kernel space */\n\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\tif (IS_ERR(description)) {\n\t\tret = PTR_ERR(description);\n\t\tgoto error;\n\t}\n\n\t/* pull the callout info into kernel space */\n\tcallout_info = NULL;\n\tcallout_len = 0;\n\tif (_callout_info) {\n\t\tcallout_info = strndup_user(_callout_info, PAGE_SIZE);\n\t\tif (IS_ERR(callout_info)) {\n\t\t\tret = PTR_ERR(callout_info);\n\t\t\tgoto error2;\n\t\t}\n\t\tcallout_len = strlen(callout_info);\n\t}\n\n\t/* get the destination keyring if specified */\n\tdest_ref = NULL;\n\tif (destringid) {\n\t\tdest_ref = lookup_user_key(destringid, KEY_LOOKUP_CREATE,\n\t\t\t\t\t   KEY_NEED_WRITE);\n\t\tif (IS_ERR(dest_ref)) {\n\t\t\tret = PTR_ERR(dest_ref);\n\t\t\tgoto error3;\n\t\t}\n\t}\n\n\t/* find the key type */\n\tktype = key_type_lookup(type);\n\tif (IS_ERR(ktype)) {\n\t\tret = PTR_ERR(ktype);\n\t\tgoto error4;\n\t}\n\n\t/* do the search */\n\tkey = request_key_and_link(ktype, description, callout_info,\n\t\t\t\t   callout_len, NULL, key_ref_to_ptr(dest_ref),\n\t\t\t\t   KEY_ALLOC_IN_QUOTA);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error5;\n\t}\n\n\t/* wait for the key to finish being constructed */\n\tret = wait_for_key_construction(key, 1);\n\tif (ret < 0)\n\t\tgoto error6;\n\n\tret = key->serial;\n\nerror6:\n \tkey_put(key);\nerror5:\n\tkey_type_put(ktype);\nerror4:\n\tkey_ref_put(dest_ref);\nerror3:\n\tkfree(callout_info);\nerror2:\n\tkfree(description);\nerror:\n\treturn ret;\n}\n\n/*\n * Get the ID of the specified process keyring.\n *\n * The requested keyring must have search permission to be found.\n *\n * If successful, the ID of the requested keyring will be returned.\n */\nlong keyctl_get_keyring_ID(key_serial_t id, int create)\n{\n\tkey_ref_t key_ref;\n\tunsigned long lflags;\n\tlong ret;\n\n\tlflags = create ? KEY_LOOKUP_CREATE : 0;\n\tkey_ref = lookup_user_key(id, lflags, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tret = key_ref_to_ptr(key_ref)->serial;\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Join a (named) session keyring.\n *\n * Create and join an anonymous session keyring or join a named session\n * keyring, creating it if necessary.  A named session keyring must have Search\n * permission for it to be joined.  Session keyrings without this permit will\n * be skipped over.  It is not permitted for userspace to create or join\n * keyrings whose name begin with a dot.\n *\n * If successful, the ID of the joined session keyring will be returned.\n */\nlong keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\n\t/* fetch the name from userspace */\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = -EPERM;\n\t\tif (name[0] == '.')\n\t\t\tgoto error_name;\n\t}\n\n\t/* join the session */\n\tret = join_session_keyring(name);\nerror_name:\n\tkfree(name);\nerror:\n\treturn ret;\n}\n\n/*\n * Update a key's data payload from the given data.\n *\n * The key must grant the caller Write permission and the key type must support\n * updating for this to work.  A negative key can be positively instantiated\n * with this call.\n *\n * If successful, 0 will be returned.  If the key type does not support\n * updating, then -EOPNOTSUPP will be returned.\n */\nlong keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\tif (plen) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\n\t/* find the target key (which must be writable) */\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\t/* update the key */\n\tret = key_update(key_ref, payload, plen);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkzfree(payload);\nerror:\n\treturn ret;\n}\n\n/*\n * Revoke a key.\n *\n * The key must be grant the caller Write or Setattr permission for this to\n * work.  The key type should give up its quota claim when revoked.  The key\n * and any links to the key will be automatically garbage collected after a\n * certain amount of time (/proc/sys/kernel/keys/gc_delay).\n *\n * Keys with KEY_FLAG_KEEP set should not be revoked.\n *\n * If successful, 0 is returned.\n */\nlong keyctl_revoke_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tstruct key *key;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tif (ret != -EACCES)\n\t\t\tgoto error;\n\t\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SETATTR);\n\t\tif (IS_ERR(key_ref)) {\n\t\t\tret = PTR_ERR(key_ref);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_revoke(key);\n\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Invalidate a key.\n *\n * The key must be grant the caller Invalidate permission for this to work.\n * The key and any links to the key will be automatically garbage collected\n * immediately.\n *\n * Keys with KEY_FLAG_KEEP set should not be invalidated.\n *\n * If successful, 0 is returned.\n */\nlong keyctl_invalidate_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tstruct key *key;\n\tlong ret;\n\n\tkenter(\"%d\", id);\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\n\t\t/* Root is permitted to invalidate certain special keys */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tkey_ref = lookup_user_key(id, 0, 0);\n\t\t\tif (IS_ERR(key_ref))\n\t\t\t\tgoto error;\n\t\t\tif (test_bit(KEY_FLAG_ROOT_CAN_INVAL,\n\t\t\t\t     &key_ref_to_ptr(key_ref)->flags))\n\t\t\t\tgoto invalidate;\n\t\t\tgoto error_put;\n\t\t}\n\n\t\tgoto error;\n\t}\n\ninvalidate:\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_invalidate(key);\nerror_put:\n\tkey_ref_put(key_ref);\nerror:\n\tkleave(\" = %ld\", ret);\n\treturn ret;\n}\n\n/*\n * Clear the specified keyring, creating an empty process keyring if one of the\n * special keyring IDs is used.\n *\n * The keyring must grant the caller Write permission and not have\n * KEY_FLAG_KEEP set for this to work.  If successful, 0 will be returned.\n */\nlong keyctl_keyring_clear(key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref;\n\tstruct key *keyring;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\n\t\t/* Root is permitted to invalidate certain special keyrings */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tkeyring_ref = lookup_user_key(ringid, 0, 0);\n\t\t\tif (IS_ERR(keyring_ref))\n\t\t\t\tgoto error;\n\t\t\tif (test_bit(KEY_FLAG_ROOT_CAN_CLEAR,\n\t\t\t\t     &key_ref_to_ptr(keyring_ref)->flags))\n\t\t\t\tgoto clear;\n\t\t\tgoto error_put;\n\t\t}\n\n\t\tgoto error;\n\t}\n\nclear:\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\tret = -EPERM;\n\telse\n\t\tret = keyring_clear(keyring);\nerror_put:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Create a link from a keyring to a key if there's no matching key in the\n * keyring, otherwise replace the link to the matching key with a link to the\n * new key.\n *\n * The key must grant the caller Link permission and the the keyring must grant\n * the caller Write permission.  Furthermore, if an additional link is created,\n * the keyring's quota will be extended.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_keyring_link(key_serial_t id, key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE, KEY_NEED_LINK);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tret = key_link(key_ref_to_ptr(keyring_ref), key_ref_to_ptr(key_ref));\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Unlink a key from a keyring.\n *\n * The keyring must grant the caller Write permission for this to work; the key\n * itself need not grant the caller anything.  If the last link to a key is\n * removed then that key will be scheduled for destruction.\n *\n * Keys or keyrings with KEY_FLAG_KEEP set should not be unlinked.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_keyring_unlink(key_serial_t id, key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tstruct key *keyring, *key;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_FOR_UNLINK, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey = key_ref_to_ptr(key_ref);\n\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags) &&\n\t    test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tret = key_unlink(keyring, key);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Return a description of a key to userspace.\n *\n * The key must grant the caller View permission for this to work.\n *\n * If there's a buffer, we place up to buflen bytes of data into it formatted\n * in the following way:\n *\n *\ttype;uid;gid;perm;description<NUL>\n *\n * If successful, we return the amount of description available, irrespective\n * of how much we may have copied into the buffer.\n */\nlong keyctl_describe_key(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *infobuf;\n\tlong ret;\n\tint desclen, infolen;\n\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\t/* viewing a key under construction is permitted if we have the\n\t\t * authorisation token handy */\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(keyid,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tdesclen = strlen(key->description);\n\n\t/* calculate how much information we're going to return */\n\tret = -ENOMEM;\n\tinfobuf = kasprintf(GFP_KERNEL,\n\t\t\t    \"%s;%d;%d;%08x;\",\n\t\t\t    key->type->name,\n\t\t\t    from_kuid_munged(current_user_ns(), key->uid),\n\t\t\t    from_kgid_munged(current_user_ns(), key->gid),\n\t\t\t    key->perm);\n\tif (!infobuf)\n\t\tgoto error2;\n\tinfolen = strlen(infobuf);\n\tret = infolen + desclen + 1;\n\n\t/* consider returning the data */\n\tif (buffer && buflen >= ret) {\n\t\tif (copy_to_user(buffer, infobuf, infolen) != 0 ||\n\t\t    copy_to_user(buffer + infolen, key->description,\n\t\t\t\t desclen + 1) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\tkfree(infobuf);\nerror2:\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Search the specified keyring and any keyrings it links to for a matching\n * key.  Only keyrings that grant the caller Search permission will be searched\n * (this includes the starting keyring).  Only keys with Search permission can\n * be found.\n *\n * If successful, the found key will be linked to the destination keyring if\n * supplied and the key has Link permission, and the found key ID will be\n * returned.\n */\nlong keyctl_keyring_search(key_serial_t ringid,\n\t\t\t   const char __user *_type,\n\t\t\t   const char __user *_description,\n\t\t\t   key_serial_t destringid)\n{\n\tstruct key_type *ktype;\n\tkey_ref_t keyring_ref, key_ref, dest_ref;\n\tchar type[32], *description;\n\tlong ret;\n\n\t/* pull the type and description into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\tif (IS_ERR(description)) {\n\t\tret = PTR_ERR(description);\n\t\tgoto error;\n\t}\n\n\t/* get the keyring at which to begin the search */\n\tkeyring_ref = lookup_user_key(ringid, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error2;\n\t}\n\n\t/* get the destination keyring if specified */\n\tdest_ref = NULL;\n\tif (destringid) {\n\t\tdest_ref = lookup_user_key(destringid, KEY_LOOKUP_CREATE,\n\t\t\t\t\t   KEY_NEED_WRITE);\n\t\tif (IS_ERR(dest_ref)) {\n\t\t\tret = PTR_ERR(dest_ref);\n\t\t\tgoto error3;\n\t\t}\n\t}\n\n\t/* find the key type */\n\tktype = key_type_lookup(type);\n\tif (IS_ERR(ktype)) {\n\t\tret = PTR_ERR(ktype);\n\t\tgoto error4;\n\t}\n\n\t/* do the search */\n\tkey_ref = keyring_search(keyring_ref, ktype, description);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\n\t\t/* treat lack or presence of a negative key the same */\n\t\tif (ret == -EAGAIN)\n\t\t\tret = -ENOKEY;\n\t\tgoto error5;\n\t}\n\n\t/* link the resulting key to the destination keyring if we can */\n\tif (dest_ref) {\n\t\tret = key_permission(key_ref, KEY_NEED_LINK);\n\t\tif (ret < 0)\n\t\t\tgoto error6;\n\n\t\tret = key_link(key_ref_to_ptr(dest_ref), key_ref_to_ptr(key_ref));\n\t\tif (ret < 0)\n\t\t\tgoto error6;\n\t}\n\n\tret = key_ref_to_ptr(key_ref)->serial;\n\nerror6:\n\tkey_ref_put(key_ref);\nerror5:\n\tkey_type_put(ktype);\nerror4:\n\tkey_ref_put(dest_ref);\nerror3:\n\tkey_ref_put(keyring_ref);\nerror2:\n\tkfree(description);\nerror:\n\treturn ret;\n}\n\n/*\n * Read a key's payload.\n *\n * The key must either grant the caller Read permission, or it must grant the\n * caller Search permission when searched for from the process keyrings.\n *\n * If successful, we place up to buflen bytes of data into the buffer, if one\n * is provided, and return the amount of data that is available in the key,\n * irrespective of how much we copied into the buffer.\n */\nlong keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\t/* find the key first */\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* see if we can read it directly */\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error2;\n\n\t/* we can't; see if it's searchable from this process's keyrings\n\t * - we automatically take account of the fact that it may be\n\t *   dangling off an instantiation key\n\t */\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n\n\t/* the key is probably readable - now try to read it */\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\t/* Read the data with the semaphore held (since we might sleep)\n\t\t * to protect against the key being updated or revoked.\n\t\t */\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\n\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}\n\n/*\n * Change the ownership of a key\n *\n * The key must grant the caller Setattr permission for this to work, though\n * the key need not be fully instantiated yet.  For the UID to be changed, or\n * for the GID to be changed to a group the caller is not a member of, the\n * caller must have sysadmin capability.  If either uid or gid is -1 then that\n * attribute is not changed.\n *\n * If the UID is to be changed, the new user must have sufficient quota to\n * accept the key.  The quota deduction will be removed from the old user to\n * the new user should the attribute be changed.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_chown_key(key_serial_t id, uid_t user, gid_t group)\n{\n\tstruct key_user *newowner, *zapowner = NULL;\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tuid = make_kuid(current_user_ns(), user);\n\tgid = make_kgid(current_user_ns(), group);\n\tret = -EINVAL;\n\tif ((user != (uid_t) -1) && !uid_valid(uid))\n\t\tgoto error;\n\tif ((group != (gid_t) -1) && !gid_valid(gid))\n\t\tgoto error;\n\n\tret = 0;\n\tif (user == (uid_t) -1 && group == (gid_t) -1)\n\t\tgoto error;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* make the changes with the locks held to prevent chown/chown races */\n\tret = -EACCES;\n\tdown_write(&key->sem);\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t/* only the sysadmin can chown a key to some other UID */\n\t\tif (user != (uid_t) -1 && !uid_eq(key->uid, uid))\n\t\t\tgoto error_put;\n\n\t\t/* only the sysadmin can set the key's GID to a group other\n\t\t * than one of those that the current process subscribes to */\n\t\tif (group != (gid_t) -1 && !gid_eq(gid, key->gid) && !in_group_p(gid))\n\t\t\tgoto error_put;\n\t}\n\n\t/* change the UID */\n\tif (user != (uid_t) -1 && !uid_eq(uid, key->uid)) {\n\t\tret = -ENOMEM;\n\t\tnewowner = key_user_lookup(uid);\n\t\tif (!newowner)\n\t\t\tgoto error_put;\n\n\t\t/* transfer the quota burden to the new user */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\t\t\tunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\t\tspin_lock(&newowner->lock);\n\t\t\tif (newowner->qnkeys + 1 >= maxkeys ||\n\t\t\t    newowner->qnbytes + key->quotalen >= maxbytes ||\n\t\t\t    newowner->qnbytes + key->quotalen <\n\t\t\t    newowner->qnbytes)\n\t\t\t\tgoto quota_overrun;\n\n\t\t\tnewowner->qnkeys++;\n\t\t\tnewowner->qnbytes += key->quotalen;\n\t\t\tspin_unlock(&newowner->lock);\n\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tatomic_inc(&newowner->nkeys);\n\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\t\tatomic_inc(&newowner->nikeys);\n\t\t}\n\n\t\tzapowner = key->user;\n\t\tkey->user = newowner;\n\t\tkey->uid = uid;\n\t}\n\n\t/* change the GID */\n\tif (group != (gid_t) -1)\n\t\tkey->gid = gid;\n\n\tret = 0;\n\nerror_put:\n\tup_write(&key->sem);\n\tkey_put(key);\n\tif (zapowner)\n\t\tkey_user_put(zapowner);\nerror:\n\treturn ret;\n\nquota_overrun:\n\tspin_unlock(&newowner->lock);\n\tzapowner = newowner;\n\tret = -EDQUOT;\n\tgoto error_put;\n}\n\n/*\n * Change the permission mask on a key.\n *\n * The key must grant the caller Setattr permission for this to work, though\n * the key need not be fully instantiated yet.  If the caller does not have\n * sysadmin capability, it may only change the permission on keys that it owns.\n */\nlong keyctl_setperm_key(key_serial_t id, key_perm_t perm)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (perm & ~(KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL))\n\t\tgoto error;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* make the changes with the locks held to prevent chown/chmod races */\n\tret = -EACCES;\n\tdown_write(&key->sem);\n\n\t/* if we're not the sysadmin, we can only change a key that we own */\n\tif (capable(CAP_SYS_ADMIN) || uid_eq(key->uid, current_fsuid())) {\n\t\tkey->perm = perm;\n\t\tret = 0;\n\t}\n\n\tup_write(&key->sem);\n\tkey_put(key);\nerror:\n\treturn ret;\n}\n\n/*\n * Get the destination keyring for instantiation and check that the caller has\n * Write permission on it.\n */\nstatic long get_instantiation_keyring(key_serial_t ringid,\n\t\t\t\t      struct request_key_auth *rka,\n\t\t\t\t      struct key **_dest_keyring)\n{\n\tkey_ref_t dkref;\n\n\t*_dest_keyring = NULL;\n\n\t/* just return a NULL pointer if we weren't asked to make a link */\n\tif (ringid == 0)\n\t\treturn 0;\n\n\t/* if a specific keyring is nominated by ID, then use that */\n\tif (ringid > 0) {\n\t\tdkref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\t\tif (IS_ERR(dkref))\n\t\t\treturn PTR_ERR(dkref);\n\t\t*_dest_keyring = key_ref_to_ptr(dkref);\n\t\treturn 0;\n\t}\n\n\tif (ringid == KEY_SPEC_REQKEY_AUTH_KEY)\n\t\treturn -EINVAL;\n\n\t/* otherwise specify the destination keyring recorded in the\n\t * authorisation key (any KEY_SPEC_*_KEYRING) */\n\tif (ringid >= KEY_SPEC_REQUESTOR_KEYRING) {\n\t\t*_dest_keyring = key_get(rka->dest_keyring);\n\t\treturn 0;\n\t}\n\n\treturn -ENOKEY;\n}\n\n/*\n * Change the request_key authorisation key on the current process.\n */\nstatic int keyctl_change_reqkey_auth(struct key *key)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tkey_put(new->request_key_auth);\n\tnew->request_key_auth = key_get(key);\n\n\treturn commit_creds(new);\n}\n\n/*\n * Instantiate a key with the specified payload and link the key into the\n * destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_instantiate_key_common(key_serial_t id,\n\t\t\t\t   struct iov_iter *from,\n\t\t\t\t   key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tsize_t plen = from ? iov_iter_count(from) : 0;\n\tvoid *payload;\n\tlong ret;\n\n\tkenter(\"%d,,%zu,%d\", id, plen, ringid);\n\n\tif (!plen)\n\t\tfrom = NULL;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (from) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (!copy_from_iter_full(payload, plen, from))\n\t\t\tgoto error2;\n\t}\n\n\t/* find the destination keyring amongst those belonging to the\n\t * requesting task */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_instantiate_and_link(rka->target_key, payload, plen,\n\t\t\t\t       dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror2:\n\tif (payload) {\n\t\tmemzero_explicit(payload, plen);\n\t\tkvfree(payload);\n\t}\nerror:\n\treturn ret;\n}\n\n/*\n * Instantiate a key with the specified payload and link the key into the\n * destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_instantiate_key(key_serial_t id,\n\t\t\t    const void __user *_payload,\n\t\t\t    size_t plen,\n\t\t\t    key_serial_t ringid)\n{\n\tif (_payload && plen) {\n\t\tstruct iovec iov;\n\t\tstruct iov_iter from;\n\t\tint ret;\n\n\t\tret = import_single_range(WRITE, (void __user *)_payload, plen,\n\t\t\t\t\t  &iov, &from);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\n\t\treturn keyctl_instantiate_key_common(id, &from, ringid);\n\t}\n\n\treturn keyctl_instantiate_key_common(id, NULL, ringid);\n}\n\n/*\n * Instantiate a key with the specified multipart payload and link the key into\n * the destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_instantiate_key_iov(key_serial_t id,\n\t\t\t\tconst struct iovec __user *_payload_iov,\n\t\t\t\tunsigned ioc,\n\t\t\t\tkey_serial_t ringid)\n{\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\tstruct iov_iter from;\n\tlong ret;\n\n\tif (!_payload_iov)\n\t\tioc = 0;\n\n\tret = import_iovec(WRITE, _payload_iov, ioc,\n\t\t\t\t    ARRAY_SIZE(iovstack), &iov, &from);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = keyctl_instantiate_key_common(id, &from, ringid);\n\tkfree(iov);\n\treturn ret;\n}\n\n/*\n * Negatively instantiate the key with the given timeout (in seconds) and link\n * the key into the destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * The key and any links to the key will be automatically garbage collected\n * after the timeout expires.\n *\n * Negative keys are used to rate limit repeated request_key() calls by causing\n * them to return -ENOKEY until the negative key expires.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_negate_key(key_serial_t id, unsigned timeout, key_serial_t ringid)\n{\n\treturn keyctl_reject_key(id, timeout, ENOKEY, ringid);\n}\n\n/*\n * Negatively instantiate the key with the given timeout (in seconds) and error\n * code and link the key into the destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * The key and any links to the key will be automatically garbage collected\n * after the timeout expires.\n *\n * Negative keys are used to rate limit repeated request_key() calls by causing\n * them to return the specified error code until the negative key expires.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_reject_key(key_serial_t id, unsigned timeout, unsigned error,\n\t\t       key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tlong ret;\n\n\tkenter(\"%d,%u,%u,%d\", id, timeout, error, ringid);\n\n\t/* must be a valid error code and mustn't be a kernel special */\n\tif (error <= 0 ||\n\t    error >= MAX_ERRNO ||\n\t    error == ERESTARTSYS ||\n\t    error == ERESTARTNOINTR ||\n\t    error == ERESTARTNOHAND ||\n\t    error == ERESTART_RESTARTBLOCK)\n\t\treturn -EINVAL;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* find the destination keyring if present (which must also be\n\t * writable) */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_reject_and_link(rka->target_key, timeout, error,\n\t\t\t\t  dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror:\n\treturn ret;\n}\n\n/*\n * Read or set the default keyring in which request_key() will cache keys and\n * return the old setting.\n *\n * If a thread or process keyring is specified then it will be created if it\n * doesn't yet exist.  The old setting will be returned if successful.\n */\nlong keyctl_set_reqkey_keyring(int reqkey_defl)\n{\n\tstruct cred *new;\n\tint ret, old_setting;\n\n\told_setting = current_cred_xxx(jit_keyring);\n\n\tif (reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE)\n\t\treturn old_setting;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tswitch (reqkey_defl) {\n\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\tret = install_thread_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\tret = install_process_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_DEFAULT:\n\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_NO_CHANGE:\n\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\nset:\n\tnew->jit_keyring = reqkey_defl;\n\tcommit_creds(new);\n\treturn old_setting;\nerror:\n\tabort_creds(new);\n\treturn ret;\n}\n\n/*\n * Set or clear the timeout on a key.\n *\n * Either the key must grant the caller Setattr permission or else the caller\n * must hold an instantiation authorisation token for the key.\n *\n * The timeout is either 0 to clear the timeout, or a number of seconds from\n * the current time.  The key and any links to the key will be automatically\n * garbage collected after the timeout expires.\n *\n * Keys with KEY_FLAG_KEEP set should not be timed out.\n *\n * If successful, 0 is returned.\n */\nlong keyctl_set_timeout(key_serial_t id, unsigned timeout)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\t/* setting the timeout on a key under construction is permitted\n\t\t * if we have the authorisation token handy */\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(id);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(id,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_set_timeout(key, timeout);\n\tkey_put(key);\n\nerror:\n\treturn ret;\n}\n\n/*\n * Assume (or clear) the authority to instantiate the specified key.\n *\n * This sets the authoritative token currently in force for key instantiation.\n * This must be done for a key to be instantiated.  It has the effect of making\n * available all the keys from the caller of the request_key() that created a\n * key to request_key() calls made by the caller of this function.\n *\n * The caller must have the instantiation key in their process keyrings with a\n * Search permission grant available to the caller.\n *\n * If the ID given is 0, then the setting will be cleared and 0 returned.\n *\n * If the ID given has a matching an authorisation key, then that key will be\n * set and its ID will be returned.  The authorisation key can be read to get\n * the callout information passed to request_key().\n */\nlong keyctl_assume_authority(key_serial_t id)\n{\n\tstruct key *authkey;\n\tlong ret;\n\n\t/* special key IDs aren't permitted */\n\tret = -EINVAL;\n\tif (id < 0)\n\t\tgoto error;\n\n\t/* we divest ourselves of authority if given an ID of 0 */\n\tif (id == 0) {\n\t\tret = keyctl_change_reqkey_auth(NULL);\n\t\tgoto error;\n\t}\n\n\t/* attempt to assume the authority temporarily granted to us whilst we\n\t * instantiate the specified key\n\t * - the authorisation key must be in the current task's keyrings\n\t *   somewhere\n\t */\n\tauthkey = key_get_instantiation_authkey(id);\n\tif (IS_ERR(authkey)) {\n\t\tret = PTR_ERR(authkey);\n\t\tgoto error;\n\t}\n\n\tret = keyctl_change_reqkey_auth(authkey);\n\tif (ret == 0)\n\t\tret = authkey->serial;\n\tkey_put(authkey);\nerror:\n\treturn ret;\n}\n\n/*\n * Get a key's the LSM security label.\n *\n * The key must grant the caller View permission for this to work.\n *\n * If there's a buffer, then up to buflen bytes of data will be placed into it.\n *\n * If successful, the amount of information available will be returned,\n * irrespective of how much was copied (including the terminal NUL).\n */\nlong keyctl_get_security(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *context;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\tif (PTR_ERR(key_ref) != -EACCES)\n\t\t\treturn PTR_ERR(key_ref);\n\n\t\t/* viewing a key under construction is also permitted if we\n\t\t * have the authorisation token handy */\n\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\tif (IS_ERR(instkey))\n\t\t\treturn PTR_ERR(instkey);\n\t\tkey_put(instkey);\n\n\t\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, 0);\n\t\tif (IS_ERR(key_ref))\n\t\t\treturn PTR_ERR(key_ref);\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\tret = security_key_getsecurity(key, &context);\n\tif (ret == 0) {\n\t\t/* if no information was returned, give userspace an empty\n\t\t * string */\n\t\tret = 1;\n\t\tif (buffer && buflen > 0 &&\n\t\t    copy_to_user(buffer, \"\", 1) != 0)\n\t\t\tret = -EFAULT;\n\t} else if (ret > 0) {\n\t\t/* return as much data as there's room for */\n\t\tif (buffer && buflen > 0) {\n\t\t\tif (buflen > ret)\n\t\t\t\tbuflen = ret;\n\n\t\t\tif (copy_to_user(buffer, context, buflen) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(context);\n\t}\n\n\tkey_ref_put(key_ref);\n\treturn ret;\n}\n\n/*\n * Attempt to install the calling process's session keyring on the process's\n * parent process.\n *\n * The keyring must exist and must grant the caller LINK permission, and the\n * parent process must be single-threaded and must have the same effective\n * ownership as this process and mustn't be SUID/SGID.\n *\n * The keyring will be emplaced on the parent when it next resumes userspace.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_session_to_parent(void)\n{\n\tstruct task_struct *me, *parent;\n\tconst struct cred *mycred, *pcred;\n\tstruct callback_head *newwork, *oldwork;\n\tkey_ref_t keyring_r;\n\tstruct cred *cred;\n\tint ret;\n\n\tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_NEED_LINK);\n\tif (IS_ERR(keyring_r))\n\t\treturn PTR_ERR(keyring_r);\n\n\tret = -ENOMEM;\n\n\t/* our parent is going to need a new cred struct, a new tgcred struct\n\t * and new security data, so we allocate them here to prevent ENOMEM in\n\t * our parent */\n\tcred = cred_alloc_blank();\n\tif (!cred)\n\t\tgoto error_keyring;\n\tnewwork = &cred->rcu;\n\n\tcred->session_keyring = key_ref_to_ptr(keyring_r);\n\tkeyring_r = NULL;\n\tinit_task_work(newwork, key_change_session_keyring);\n\n\tme = current;\n\trcu_read_lock();\n\twrite_lock_irq(&tasklist_lock);\n\n\tret = -EPERM;\n\toldwork = NULL;\n\tparent = me->real_parent;\n\n\t/* the parent mustn't be init and mustn't be a kernel thread */\n\tif (parent->pid <= 1 || !parent->mm)\n\t\tgoto unlock;\n\n\t/* the parent must be single threaded */\n\tif (!thread_group_empty(parent))\n\t\tgoto unlock;\n\n\t/* the parent and the child must have different session keyrings or\n\t * there's no point */\n\tmycred = current_cred();\n\tpcred = __task_cred(parent);\n\tif (mycred == pcred ||\n\t    mycred->session_keyring == pcred->session_keyring) {\n\t\tret = 0;\n\t\tgoto unlock;\n\t}\n\n\t/* the parent must have the same effective ownership and mustn't be\n\t * SUID/SGID */\n\tif (!uid_eq(pcred->uid,\t mycred->euid) ||\n\t    !uid_eq(pcred->euid, mycred->euid) ||\n\t    !uid_eq(pcred->suid, mycred->euid) ||\n\t    !gid_eq(pcred->gid,\t mycred->egid) ||\n\t    !gid_eq(pcred->egid, mycred->egid) ||\n\t    !gid_eq(pcred->sgid, mycred->egid))\n\t\tgoto unlock;\n\n\t/* the keyrings must have the same UID */\n\tif ((pcred->session_keyring &&\n\t     !uid_eq(pcred->session_keyring->uid, mycred->euid)) ||\n\t    !uid_eq(mycred->session_keyring->uid, mycred->euid))\n\t\tgoto unlock;\n\n\t/* cancel an already pending keyring replacement */\n\toldwork = task_work_cancel(parent, key_change_session_keyring);\n\n\t/* the replacement session keyring is applied just prior to userspace\n\t * restarting */\n\tret = task_work_add(parent, newwork, true);\n\tif (!ret)\n\t\tnewwork = NULL;\nunlock:\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tif (oldwork)\n\t\tput_cred(container_of(oldwork, struct cred, rcu));\n\tif (newwork)\n\t\tput_cred(cred);\n\treturn ret;\n\nerror_keyring:\n\tkey_ref_put(keyring_r);\n\treturn ret;\n}\n\n/*\n * Apply a restriction to a given keyring.\n *\n * The caller must have Setattr permission to change keyring restrictions.\n *\n * The requested type name may be a NULL pointer to reject all attempts\n * to link to the keyring. If _type is non-NULL, _restriction can be\n * NULL or a pointer to a string describing the restriction. If _type is\n * NULL, _restriction must also be NULL.\n *\n * Returns 0 if successful.\n */\nlong keyctl_restrict_keyring(key_serial_t id, const char __user *_type,\n\t\t\t     const char __user *_restriction)\n{\n\tkey_ref_t key_ref;\n\tbool link_reject = !_type;\n\tchar type[32];\n\tchar *restriction = NULL;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref))\n\t\treturn PTR_ERR(key_ref);\n\n\tif (_type) {\n\t\tret = key_get_type_from_user(type, _type, sizeof(type));\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (_restriction) {\n\t\tif (!_type) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\trestriction = strndup_user(_restriction, PAGE_SIZE);\n\t\tif (IS_ERR(restriction)) {\n\t\t\tret = PTR_ERR(restriction);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tret = keyring_restrict(key_ref, link_reject ? NULL : type, restriction);\n\tkfree(restriction);\n\nerror:\n\tkey_ref_put(key_ref);\n\n\treturn ret;\n}\n\n/*\n * The key control system call\n */\nSYSCALL_DEFINE5(keyctl, int, option, unsigned long, arg2, unsigned long, arg3,\n\t\tunsigned long, arg4, unsigned long, arg5)\n{\n\tswitch (option) {\n\tcase KEYCTL_GET_KEYRING_ID:\n\t\treturn keyctl_get_keyring_ID((key_serial_t) arg2,\n\t\t\t\t\t     (int) arg3);\n\n\tcase KEYCTL_JOIN_SESSION_KEYRING:\n\t\treturn keyctl_join_session_keyring((const char __user *) arg2);\n\n\tcase KEYCTL_UPDATE:\n\t\treturn keyctl_update_key((key_serial_t) arg2,\n\t\t\t\t\t (const void __user *) arg3,\n\t\t\t\t\t (size_t) arg4);\n\n\tcase KEYCTL_REVOKE:\n\t\treturn keyctl_revoke_key((key_serial_t) arg2);\n\n\tcase KEYCTL_DESCRIBE:\n\t\treturn keyctl_describe_key((key_serial_t) arg2,\n\t\t\t\t\t   (char __user *) arg3,\n\t\t\t\t\t   (unsigned) arg4);\n\n\tcase KEYCTL_CLEAR:\n\t\treturn keyctl_keyring_clear((key_serial_t) arg2);\n\n\tcase KEYCTL_LINK:\n\t\treturn keyctl_keyring_link((key_serial_t) arg2,\n\t\t\t\t\t   (key_serial_t) arg3);\n\n\tcase KEYCTL_UNLINK:\n\t\treturn keyctl_keyring_unlink((key_serial_t) arg2,\n\t\t\t\t\t     (key_serial_t) arg3);\n\n\tcase KEYCTL_SEARCH:\n\t\treturn keyctl_keyring_search((key_serial_t) arg2,\n\t\t\t\t\t     (const char __user *) arg3,\n\t\t\t\t\t     (const char __user *) arg4,\n\t\t\t\t\t     (key_serial_t) arg5);\n\n\tcase KEYCTL_READ:\n\t\treturn keyctl_read_key((key_serial_t) arg2,\n\t\t\t\t       (char __user *) arg3,\n\t\t\t\t       (size_t) arg4);\n\n\tcase KEYCTL_CHOWN:\n\t\treturn keyctl_chown_key((key_serial_t) arg2,\n\t\t\t\t\t(uid_t) arg3,\n\t\t\t\t\t(gid_t) arg4);\n\n\tcase KEYCTL_SETPERM:\n\t\treturn keyctl_setperm_key((key_serial_t) arg2,\n\t\t\t\t\t  (key_perm_t) arg3);\n\n\tcase KEYCTL_INSTANTIATE:\n\t\treturn keyctl_instantiate_key((key_serial_t) arg2,\n\t\t\t\t\t      (const void __user *) arg3,\n\t\t\t\t\t      (size_t) arg4,\n\t\t\t\t\t      (key_serial_t) arg5);\n\n\tcase KEYCTL_NEGATE:\n\t\treturn keyctl_negate_key((key_serial_t) arg2,\n\t\t\t\t\t (unsigned) arg3,\n\t\t\t\t\t (key_serial_t) arg4);\n\n\tcase KEYCTL_SET_REQKEY_KEYRING:\n\t\treturn keyctl_set_reqkey_keyring(arg2);\n\n\tcase KEYCTL_SET_TIMEOUT:\n\t\treturn keyctl_set_timeout((key_serial_t) arg2,\n\t\t\t\t\t  (unsigned) arg3);\n\n\tcase KEYCTL_ASSUME_AUTHORITY:\n\t\treturn keyctl_assume_authority((key_serial_t) arg2);\n\n\tcase KEYCTL_GET_SECURITY:\n\t\treturn keyctl_get_security((key_serial_t) arg2,\n\t\t\t\t\t   (char __user *) arg3,\n\t\t\t\t\t   (size_t) arg4);\n\n\tcase KEYCTL_SESSION_TO_PARENT:\n\t\treturn keyctl_session_to_parent();\n\n\tcase KEYCTL_REJECT:\n\t\treturn keyctl_reject_key((key_serial_t) arg2,\n\t\t\t\t\t (unsigned) arg3,\n\t\t\t\t\t (unsigned) arg4,\n\t\t\t\t\t (key_serial_t) arg5);\n\n\tcase KEYCTL_INSTANTIATE_IOV:\n\t\treturn keyctl_instantiate_key_iov(\n\t\t\t(key_serial_t) arg2,\n\t\t\t(const struct iovec __user *) arg3,\n\t\t\t(unsigned) arg4,\n\t\t\t(key_serial_t) arg5);\n\n\tcase KEYCTL_INVALIDATE:\n\t\treturn keyctl_invalidate_key((key_serial_t) arg2);\n\n\tcase KEYCTL_GET_PERSISTENT:\n\t\treturn keyctl_get_persistent((uid_t)arg2, (key_serial_t)arg3);\n\n\tcase KEYCTL_DH_COMPUTE:\n\t\treturn keyctl_dh_compute((struct keyctl_dh_params __user *) arg2,\n\t\t\t\t\t (char __user *) arg3, (size_t) arg4,\n\t\t\t\t\t (struct keyctl_kdf_params __user *) arg5);\n\n\tcase KEYCTL_RESTRICT_KEYRING:\n\t\treturn keyctl_restrict_keyring((key_serial_t) arg2,\n\t\t\t\t\t       (const char __user *) arg3,\n\t\t\t\t\t       (const char __user *) arg4);\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n"], "fixing_code": ["/* Userspace key control operations\n *\n * Copyright (C) 2004-5 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/key.h>\n#include <linux/keyctl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\n#define KEY_MAX_DESC_SIZE 4096\n\nstatic int key_get_type_from_user(char *type,\n\t\t\t\t  const char __user *_type,\n\t\t\t\t  unsigned len)\n{\n\tint ret;\n\n\tret = strncpy_from_user(type, _type, len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0 || ret >= len)\n\t\treturn -EINVAL;\n\tif (type[0] == '.')\n\t\treturn -EPERM;\n\ttype[len - 1] = '\\0';\n\treturn 0;\n}\n\n/*\n * Extract the description of a new key from userspace and either add it as a\n * new key to the specified keyring or update a matching key in that keyring.\n *\n * If the description is NULL or an empty string, the key type is asked to\n * generate one from the payload.\n *\n * The keyring must be writable so that we can attach the key to it.\n *\n * If successful, the new key's serial number is returned, otherwise an error\n * code is returned.\n */\nSYSCALL_DEFINE5(add_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst void __user *, _payload,\n\t\tsize_t, plen,\n\t\tkey_serial_t, ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tchar type[32], *description;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* draw all the data into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = NULL;\n\tif (_description) {\n\t\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(description)) {\n\t\t\tret = PTR_ERR(description);\n\t\t\tgoto error;\n\t\t}\n\t\tif (!*description) {\n\t\t\tkfree(description);\n\t\t\tdescription = NULL;\n\t\t} else if ((description[0] == '.') &&\n\t\t\t   (strncmp(type, \"keyring\", 7) == 0)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto error2;\n\t\t}\n\t}\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (plen) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error2;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error3;\n\t}\n\n\t/* find the target keyring (which must be writable) */\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error3;\n\t}\n\n\t/* create or update the requested key and add it to the target\n\t * keyring */\n\tkey_ref = key_create_or_update(keyring_ref, type, description,\n\t\t\t\t       payload, plen, KEY_PERM_UNDEF,\n\t\t\t\t       KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key_ref)) {\n\t\tret = key_ref_to_ptr(key_ref)->serial;\n\t\tkey_ref_put(key_ref);\n\t}\n\telse {\n\t\tret = PTR_ERR(key_ref);\n\t}\n\n\tkey_ref_put(keyring_ref);\n error3:\n\tif (payload) {\n\t\tmemzero_explicit(payload, plen);\n\t\tkvfree(payload);\n\t}\n error2:\n\tkfree(description);\n error:\n\treturn ret;\n}\n\n/*\n * Search the process keyrings and keyring trees linked from those for a\n * matching key.  Keyrings must have appropriate Search permission to be\n * searched.\n *\n * If a key is found, it will be attached to the destination keyring if there's\n * one specified and the serial number of the key will be returned.\n *\n * If no key is found, /sbin/request-key will be invoked if _callout_info is\n * non-NULL in an attempt to create a key.  The _callout_info string will be\n * passed to /sbin/request-key to aid with completing the request.  If the\n * _callout_info string is \"\" then it will be changed to \"-\".\n */\nSYSCALL_DEFINE4(request_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst char __user *, _callout_info,\n\t\tkey_serial_t, destringid)\n{\n\tstruct key_type *ktype;\n\tstruct key *key;\n\tkey_ref_t dest_ref;\n\tsize_t callout_len;\n\tchar type[32], *description, *callout_info;\n\tlong ret;\n\n\t/* pull the type into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* pull the description into kernel space */\n\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\tif (IS_ERR(description)) {\n\t\tret = PTR_ERR(description);\n\t\tgoto error;\n\t}\n\n\t/* pull the callout info into kernel space */\n\tcallout_info = NULL;\n\tcallout_len = 0;\n\tif (_callout_info) {\n\t\tcallout_info = strndup_user(_callout_info, PAGE_SIZE);\n\t\tif (IS_ERR(callout_info)) {\n\t\t\tret = PTR_ERR(callout_info);\n\t\t\tgoto error2;\n\t\t}\n\t\tcallout_len = strlen(callout_info);\n\t}\n\n\t/* get the destination keyring if specified */\n\tdest_ref = NULL;\n\tif (destringid) {\n\t\tdest_ref = lookup_user_key(destringid, KEY_LOOKUP_CREATE,\n\t\t\t\t\t   KEY_NEED_WRITE);\n\t\tif (IS_ERR(dest_ref)) {\n\t\t\tret = PTR_ERR(dest_ref);\n\t\t\tgoto error3;\n\t\t}\n\t}\n\n\t/* find the key type */\n\tktype = key_type_lookup(type);\n\tif (IS_ERR(ktype)) {\n\t\tret = PTR_ERR(ktype);\n\t\tgoto error4;\n\t}\n\n\t/* do the search */\n\tkey = request_key_and_link(ktype, description, callout_info,\n\t\t\t\t   callout_len, NULL, key_ref_to_ptr(dest_ref),\n\t\t\t\t   KEY_ALLOC_IN_QUOTA);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error5;\n\t}\n\n\t/* wait for the key to finish being constructed */\n\tret = wait_for_key_construction(key, 1);\n\tif (ret < 0)\n\t\tgoto error6;\n\n\tret = key->serial;\n\nerror6:\n \tkey_put(key);\nerror5:\n\tkey_type_put(ktype);\nerror4:\n\tkey_ref_put(dest_ref);\nerror3:\n\tkfree(callout_info);\nerror2:\n\tkfree(description);\nerror:\n\treturn ret;\n}\n\n/*\n * Get the ID of the specified process keyring.\n *\n * The requested keyring must have search permission to be found.\n *\n * If successful, the ID of the requested keyring will be returned.\n */\nlong keyctl_get_keyring_ID(key_serial_t id, int create)\n{\n\tkey_ref_t key_ref;\n\tunsigned long lflags;\n\tlong ret;\n\n\tlflags = create ? KEY_LOOKUP_CREATE : 0;\n\tkey_ref = lookup_user_key(id, lflags, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tret = key_ref_to_ptr(key_ref)->serial;\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Join a (named) session keyring.\n *\n * Create and join an anonymous session keyring or join a named session\n * keyring, creating it if necessary.  A named session keyring must have Search\n * permission for it to be joined.  Session keyrings without this permit will\n * be skipped over.  It is not permitted for userspace to create or join\n * keyrings whose name begin with a dot.\n *\n * If successful, the ID of the joined session keyring will be returned.\n */\nlong keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\n\t/* fetch the name from userspace */\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = -EPERM;\n\t\tif (name[0] == '.')\n\t\t\tgoto error_name;\n\t}\n\n\t/* join the session */\n\tret = join_session_keyring(name);\nerror_name:\n\tkfree(name);\nerror:\n\treturn ret;\n}\n\n/*\n * Update a key's data payload from the given data.\n *\n * The key must grant the caller Write permission and the key type must support\n * updating for this to work.  A negative key can be positively instantiated\n * with this call.\n *\n * If successful, 0 will be returned.  If the key type does not support\n * updating, then -EOPNOTSUPP will be returned.\n */\nlong keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\tif (plen) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\n\t/* find the target key (which must be writable) */\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\t/* update the key */\n\tret = key_update(key_ref, payload, plen);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkzfree(payload);\nerror:\n\treturn ret;\n}\n\n/*\n * Revoke a key.\n *\n * The key must be grant the caller Write or Setattr permission for this to\n * work.  The key type should give up its quota claim when revoked.  The key\n * and any links to the key will be automatically garbage collected after a\n * certain amount of time (/proc/sys/kernel/keys/gc_delay).\n *\n * Keys with KEY_FLAG_KEEP set should not be revoked.\n *\n * If successful, 0 is returned.\n */\nlong keyctl_revoke_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tstruct key *key;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tif (ret != -EACCES)\n\t\t\tgoto error;\n\t\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SETATTR);\n\t\tif (IS_ERR(key_ref)) {\n\t\t\tret = PTR_ERR(key_ref);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_revoke(key);\n\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Invalidate a key.\n *\n * The key must be grant the caller Invalidate permission for this to work.\n * The key and any links to the key will be automatically garbage collected\n * immediately.\n *\n * Keys with KEY_FLAG_KEEP set should not be invalidated.\n *\n * If successful, 0 is returned.\n */\nlong keyctl_invalidate_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tstruct key *key;\n\tlong ret;\n\n\tkenter(\"%d\", id);\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\n\t\t/* Root is permitted to invalidate certain special keys */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tkey_ref = lookup_user_key(id, 0, 0);\n\t\t\tif (IS_ERR(key_ref))\n\t\t\t\tgoto error;\n\t\t\tif (test_bit(KEY_FLAG_ROOT_CAN_INVAL,\n\t\t\t\t     &key_ref_to_ptr(key_ref)->flags))\n\t\t\t\tgoto invalidate;\n\t\t\tgoto error_put;\n\t\t}\n\n\t\tgoto error;\n\t}\n\ninvalidate:\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_invalidate(key);\nerror_put:\n\tkey_ref_put(key_ref);\nerror:\n\tkleave(\" = %ld\", ret);\n\treturn ret;\n}\n\n/*\n * Clear the specified keyring, creating an empty process keyring if one of the\n * special keyring IDs is used.\n *\n * The keyring must grant the caller Write permission and not have\n * KEY_FLAG_KEEP set for this to work.  If successful, 0 will be returned.\n */\nlong keyctl_keyring_clear(key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref;\n\tstruct key *keyring;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\n\t\t/* Root is permitted to invalidate certain special keyrings */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tkeyring_ref = lookup_user_key(ringid, 0, 0);\n\t\t\tif (IS_ERR(keyring_ref))\n\t\t\t\tgoto error;\n\t\t\tif (test_bit(KEY_FLAG_ROOT_CAN_CLEAR,\n\t\t\t\t     &key_ref_to_ptr(keyring_ref)->flags))\n\t\t\t\tgoto clear;\n\t\t\tgoto error_put;\n\t\t}\n\n\t\tgoto error;\n\t}\n\nclear:\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\tret = -EPERM;\n\telse\n\t\tret = keyring_clear(keyring);\nerror_put:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Create a link from a keyring to a key if there's no matching key in the\n * keyring, otherwise replace the link to the matching key with a link to the\n * new key.\n *\n * The key must grant the caller Link permission and the the keyring must grant\n * the caller Write permission.  Furthermore, if an additional link is created,\n * the keyring's quota will be extended.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_keyring_link(key_serial_t id, key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE, KEY_NEED_LINK);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tret = key_link(key_ref_to_ptr(keyring_ref), key_ref_to_ptr(key_ref));\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Unlink a key from a keyring.\n *\n * The keyring must grant the caller Write permission for this to work; the key\n * itself need not grant the caller anything.  If the last link to a key is\n * removed then that key will be scheduled for destruction.\n *\n * Keys or keyrings with KEY_FLAG_KEEP set should not be unlinked.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_keyring_unlink(key_serial_t id, key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tstruct key *keyring, *key;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_FOR_UNLINK, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey = key_ref_to_ptr(key_ref);\n\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags) &&\n\t    test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tret = key_unlink(keyring, key);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Return a description of a key to userspace.\n *\n * The key must grant the caller View permission for this to work.\n *\n * If there's a buffer, we place up to buflen bytes of data into it formatted\n * in the following way:\n *\n *\ttype;uid;gid;perm;description<NUL>\n *\n * If successful, we return the amount of description available, irrespective\n * of how much we may have copied into the buffer.\n */\nlong keyctl_describe_key(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *infobuf;\n\tlong ret;\n\tint desclen, infolen;\n\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\t/* viewing a key under construction is permitted if we have the\n\t\t * authorisation token handy */\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(keyid,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tdesclen = strlen(key->description);\n\n\t/* calculate how much information we're going to return */\n\tret = -ENOMEM;\n\tinfobuf = kasprintf(GFP_KERNEL,\n\t\t\t    \"%s;%d;%d;%08x;\",\n\t\t\t    key->type->name,\n\t\t\t    from_kuid_munged(current_user_ns(), key->uid),\n\t\t\t    from_kgid_munged(current_user_ns(), key->gid),\n\t\t\t    key->perm);\n\tif (!infobuf)\n\t\tgoto error2;\n\tinfolen = strlen(infobuf);\n\tret = infolen + desclen + 1;\n\n\t/* consider returning the data */\n\tif (buffer && buflen >= ret) {\n\t\tif (copy_to_user(buffer, infobuf, infolen) != 0 ||\n\t\t    copy_to_user(buffer + infolen, key->description,\n\t\t\t\t desclen + 1) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\tkfree(infobuf);\nerror2:\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Search the specified keyring and any keyrings it links to for a matching\n * key.  Only keyrings that grant the caller Search permission will be searched\n * (this includes the starting keyring).  Only keys with Search permission can\n * be found.\n *\n * If successful, the found key will be linked to the destination keyring if\n * supplied and the key has Link permission, and the found key ID will be\n * returned.\n */\nlong keyctl_keyring_search(key_serial_t ringid,\n\t\t\t   const char __user *_type,\n\t\t\t   const char __user *_description,\n\t\t\t   key_serial_t destringid)\n{\n\tstruct key_type *ktype;\n\tkey_ref_t keyring_ref, key_ref, dest_ref;\n\tchar type[32], *description;\n\tlong ret;\n\n\t/* pull the type and description into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\tif (IS_ERR(description)) {\n\t\tret = PTR_ERR(description);\n\t\tgoto error;\n\t}\n\n\t/* get the keyring at which to begin the search */\n\tkeyring_ref = lookup_user_key(ringid, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error2;\n\t}\n\n\t/* get the destination keyring if specified */\n\tdest_ref = NULL;\n\tif (destringid) {\n\t\tdest_ref = lookup_user_key(destringid, KEY_LOOKUP_CREATE,\n\t\t\t\t\t   KEY_NEED_WRITE);\n\t\tif (IS_ERR(dest_ref)) {\n\t\t\tret = PTR_ERR(dest_ref);\n\t\t\tgoto error3;\n\t\t}\n\t}\n\n\t/* find the key type */\n\tktype = key_type_lookup(type);\n\tif (IS_ERR(ktype)) {\n\t\tret = PTR_ERR(ktype);\n\t\tgoto error4;\n\t}\n\n\t/* do the search */\n\tkey_ref = keyring_search(keyring_ref, ktype, description);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\n\t\t/* treat lack or presence of a negative key the same */\n\t\tif (ret == -EAGAIN)\n\t\t\tret = -ENOKEY;\n\t\tgoto error5;\n\t}\n\n\t/* link the resulting key to the destination keyring if we can */\n\tif (dest_ref) {\n\t\tret = key_permission(key_ref, KEY_NEED_LINK);\n\t\tif (ret < 0)\n\t\t\tgoto error6;\n\n\t\tret = key_link(key_ref_to_ptr(dest_ref), key_ref_to_ptr(key_ref));\n\t\tif (ret < 0)\n\t\t\tgoto error6;\n\t}\n\n\tret = key_ref_to_ptr(key_ref)->serial;\n\nerror6:\n\tkey_ref_put(key_ref);\nerror5:\n\tkey_type_put(ktype);\nerror4:\n\tkey_ref_put(dest_ref);\nerror3:\n\tkey_ref_put(keyring_ref);\nerror2:\n\tkfree(description);\nerror:\n\treturn ret;\n}\n\n/*\n * Read a key's payload.\n *\n * The key must either grant the caller Read permission, or it must grant the\n * caller Search permission when searched for from the process keyrings.\n *\n * If successful, we place up to buflen bytes of data into the buffer, if one\n * is provided, and return the amount of data that is available in the key,\n * irrespective of how much we copied into the buffer.\n */\nlong keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\t/* find the key first */\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n\t\tret = -ENOKEY;\n\t\tgoto error2;\n\t}\n\n\t/* see if we can read it directly */\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error2;\n\n\t/* we can't; see if it's searchable from this process's keyrings\n\t * - we automatically take account of the fact that it may be\n\t *   dangling off an instantiation key\n\t */\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n\n\t/* the key is probably readable - now try to read it */\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\t/* Read the data with the semaphore held (since we might sleep)\n\t\t * to protect against the key being updated or revoked.\n\t\t */\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\n\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}\n\n/*\n * Change the ownership of a key\n *\n * The key must grant the caller Setattr permission for this to work, though\n * the key need not be fully instantiated yet.  For the UID to be changed, or\n * for the GID to be changed to a group the caller is not a member of, the\n * caller must have sysadmin capability.  If either uid or gid is -1 then that\n * attribute is not changed.\n *\n * If the UID is to be changed, the new user must have sufficient quota to\n * accept the key.  The quota deduction will be removed from the old user to\n * the new user should the attribute be changed.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_chown_key(key_serial_t id, uid_t user, gid_t group)\n{\n\tstruct key_user *newowner, *zapowner = NULL;\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tuid = make_kuid(current_user_ns(), user);\n\tgid = make_kgid(current_user_ns(), group);\n\tret = -EINVAL;\n\tif ((user != (uid_t) -1) && !uid_valid(uid))\n\t\tgoto error;\n\tif ((group != (gid_t) -1) && !gid_valid(gid))\n\t\tgoto error;\n\n\tret = 0;\n\tif (user == (uid_t) -1 && group == (gid_t) -1)\n\t\tgoto error;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* make the changes with the locks held to prevent chown/chown races */\n\tret = -EACCES;\n\tdown_write(&key->sem);\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t/* only the sysadmin can chown a key to some other UID */\n\t\tif (user != (uid_t) -1 && !uid_eq(key->uid, uid))\n\t\t\tgoto error_put;\n\n\t\t/* only the sysadmin can set the key's GID to a group other\n\t\t * than one of those that the current process subscribes to */\n\t\tif (group != (gid_t) -1 && !gid_eq(gid, key->gid) && !in_group_p(gid))\n\t\t\tgoto error_put;\n\t}\n\n\t/* change the UID */\n\tif (user != (uid_t) -1 && !uid_eq(uid, key->uid)) {\n\t\tret = -ENOMEM;\n\t\tnewowner = key_user_lookup(uid);\n\t\tif (!newowner)\n\t\t\tgoto error_put;\n\n\t\t/* transfer the quota burden to the new user */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\t\t\tunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\t\tspin_lock(&newowner->lock);\n\t\t\tif (newowner->qnkeys + 1 >= maxkeys ||\n\t\t\t    newowner->qnbytes + key->quotalen >= maxbytes ||\n\t\t\t    newowner->qnbytes + key->quotalen <\n\t\t\t    newowner->qnbytes)\n\t\t\t\tgoto quota_overrun;\n\n\t\t\tnewowner->qnkeys++;\n\t\t\tnewowner->qnbytes += key->quotalen;\n\t\t\tspin_unlock(&newowner->lock);\n\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tatomic_inc(&newowner->nkeys);\n\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\t\tatomic_inc(&newowner->nikeys);\n\t\t}\n\n\t\tzapowner = key->user;\n\t\tkey->user = newowner;\n\t\tkey->uid = uid;\n\t}\n\n\t/* change the GID */\n\tif (group != (gid_t) -1)\n\t\tkey->gid = gid;\n\n\tret = 0;\n\nerror_put:\n\tup_write(&key->sem);\n\tkey_put(key);\n\tif (zapowner)\n\t\tkey_user_put(zapowner);\nerror:\n\treturn ret;\n\nquota_overrun:\n\tspin_unlock(&newowner->lock);\n\tzapowner = newowner;\n\tret = -EDQUOT;\n\tgoto error_put;\n}\n\n/*\n * Change the permission mask on a key.\n *\n * The key must grant the caller Setattr permission for this to work, though\n * the key need not be fully instantiated yet.  If the caller does not have\n * sysadmin capability, it may only change the permission on keys that it owns.\n */\nlong keyctl_setperm_key(key_serial_t id, key_perm_t perm)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (perm & ~(KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL))\n\t\tgoto error;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* make the changes with the locks held to prevent chown/chmod races */\n\tret = -EACCES;\n\tdown_write(&key->sem);\n\n\t/* if we're not the sysadmin, we can only change a key that we own */\n\tif (capable(CAP_SYS_ADMIN) || uid_eq(key->uid, current_fsuid())) {\n\t\tkey->perm = perm;\n\t\tret = 0;\n\t}\n\n\tup_write(&key->sem);\n\tkey_put(key);\nerror:\n\treturn ret;\n}\n\n/*\n * Get the destination keyring for instantiation and check that the caller has\n * Write permission on it.\n */\nstatic long get_instantiation_keyring(key_serial_t ringid,\n\t\t\t\t      struct request_key_auth *rka,\n\t\t\t\t      struct key **_dest_keyring)\n{\n\tkey_ref_t dkref;\n\n\t*_dest_keyring = NULL;\n\n\t/* just return a NULL pointer if we weren't asked to make a link */\n\tif (ringid == 0)\n\t\treturn 0;\n\n\t/* if a specific keyring is nominated by ID, then use that */\n\tif (ringid > 0) {\n\t\tdkref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\t\tif (IS_ERR(dkref))\n\t\t\treturn PTR_ERR(dkref);\n\t\t*_dest_keyring = key_ref_to_ptr(dkref);\n\t\treturn 0;\n\t}\n\n\tif (ringid == KEY_SPEC_REQKEY_AUTH_KEY)\n\t\treturn -EINVAL;\n\n\t/* otherwise specify the destination keyring recorded in the\n\t * authorisation key (any KEY_SPEC_*_KEYRING) */\n\tif (ringid >= KEY_SPEC_REQUESTOR_KEYRING) {\n\t\t*_dest_keyring = key_get(rka->dest_keyring);\n\t\treturn 0;\n\t}\n\n\treturn -ENOKEY;\n}\n\n/*\n * Change the request_key authorisation key on the current process.\n */\nstatic int keyctl_change_reqkey_auth(struct key *key)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tkey_put(new->request_key_auth);\n\tnew->request_key_auth = key_get(key);\n\n\treturn commit_creds(new);\n}\n\n/*\n * Instantiate a key with the specified payload and link the key into the\n * destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_instantiate_key_common(key_serial_t id,\n\t\t\t\t   struct iov_iter *from,\n\t\t\t\t   key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tsize_t plen = from ? iov_iter_count(from) : 0;\n\tvoid *payload;\n\tlong ret;\n\n\tkenter(\"%d,,%zu,%d\", id, plen, ringid);\n\n\tif (!plen)\n\t\tfrom = NULL;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (from) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (!copy_from_iter_full(payload, plen, from))\n\t\t\tgoto error2;\n\t}\n\n\t/* find the destination keyring amongst those belonging to the\n\t * requesting task */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_instantiate_and_link(rka->target_key, payload, plen,\n\t\t\t\t       dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror2:\n\tif (payload) {\n\t\tmemzero_explicit(payload, plen);\n\t\tkvfree(payload);\n\t}\nerror:\n\treturn ret;\n}\n\n/*\n * Instantiate a key with the specified payload and link the key into the\n * destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_instantiate_key(key_serial_t id,\n\t\t\t    const void __user *_payload,\n\t\t\t    size_t plen,\n\t\t\t    key_serial_t ringid)\n{\n\tif (_payload && plen) {\n\t\tstruct iovec iov;\n\t\tstruct iov_iter from;\n\t\tint ret;\n\n\t\tret = import_single_range(WRITE, (void __user *)_payload, plen,\n\t\t\t\t\t  &iov, &from);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\n\t\treturn keyctl_instantiate_key_common(id, &from, ringid);\n\t}\n\n\treturn keyctl_instantiate_key_common(id, NULL, ringid);\n}\n\n/*\n * Instantiate a key with the specified multipart payload and link the key into\n * the destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_instantiate_key_iov(key_serial_t id,\n\t\t\t\tconst struct iovec __user *_payload_iov,\n\t\t\t\tunsigned ioc,\n\t\t\t\tkey_serial_t ringid)\n{\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\tstruct iov_iter from;\n\tlong ret;\n\n\tif (!_payload_iov)\n\t\tioc = 0;\n\n\tret = import_iovec(WRITE, _payload_iov, ioc,\n\t\t\t\t    ARRAY_SIZE(iovstack), &iov, &from);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = keyctl_instantiate_key_common(id, &from, ringid);\n\tkfree(iov);\n\treturn ret;\n}\n\n/*\n * Negatively instantiate the key with the given timeout (in seconds) and link\n * the key into the destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * The key and any links to the key will be automatically garbage collected\n * after the timeout expires.\n *\n * Negative keys are used to rate limit repeated request_key() calls by causing\n * them to return -ENOKEY until the negative key expires.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_negate_key(key_serial_t id, unsigned timeout, key_serial_t ringid)\n{\n\treturn keyctl_reject_key(id, timeout, ENOKEY, ringid);\n}\n\n/*\n * Negatively instantiate the key with the given timeout (in seconds) and error\n * code and link the key into the destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * The key and any links to the key will be automatically garbage collected\n * after the timeout expires.\n *\n * Negative keys are used to rate limit repeated request_key() calls by causing\n * them to return the specified error code until the negative key expires.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_reject_key(key_serial_t id, unsigned timeout, unsigned error,\n\t\t       key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tlong ret;\n\n\tkenter(\"%d,%u,%u,%d\", id, timeout, error, ringid);\n\n\t/* must be a valid error code and mustn't be a kernel special */\n\tif (error <= 0 ||\n\t    error >= MAX_ERRNO ||\n\t    error == ERESTARTSYS ||\n\t    error == ERESTARTNOINTR ||\n\t    error == ERESTARTNOHAND ||\n\t    error == ERESTART_RESTARTBLOCK)\n\t\treturn -EINVAL;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* find the destination keyring if present (which must also be\n\t * writable) */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_reject_and_link(rka->target_key, timeout, error,\n\t\t\t\t  dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror:\n\treturn ret;\n}\n\n/*\n * Read or set the default keyring in which request_key() will cache keys and\n * return the old setting.\n *\n * If a thread or process keyring is specified then it will be created if it\n * doesn't yet exist.  The old setting will be returned if successful.\n */\nlong keyctl_set_reqkey_keyring(int reqkey_defl)\n{\n\tstruct cred *new;\n\tint ret, old_setting;\n\n\told_setting = current_cred_xxx(jit_keyring);\n\n\tif (reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE)\n\t\treturn old_setting;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tswitch (reqkey_defl) {\n\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\tret = install_thread_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\tret = install_process_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_DEFAULT:\n\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_NO_CHANGE:\n\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\nset:\n\tnew->jit_keyring = reqkey_defl;\n\tcommit_creds(new);\n\treturn old_setting;\nerror:\n\tabort_creds(new);\n\treturn ret;\n}\n\n/*\n * Set or clear the timeout on a key.\n *\n * Either the key must grant the caller Setattr permission or else the caller\n * must hold an instantiation authorisation token for the key.\n *\n * The timeout is either 0 to clear the timeout, or a number of seconds from\n * the current time.  The key and any links to the key will be automatically\n * garbage collected after the timeout expires.\n *\n * Keys with KEY_FLAG_KEEP set should not be timed out.\n *\n * If successful, 0 is returned.\n */\nlong keyctl_set_timeout(key_serial_t id, unsigned timeout)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\t/* setting the timeout on a key under construction is permitted\n\t\t * if we have the authorisation token handy */\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(id);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(id,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_set_timeout(key, timeout);\n\tkey_put(key);\n\nerror:\n\treturn ret;\n}\n\n/*\n * Assume (or clear) the authority to instantiate the specified key.\n *\n * This sets the authoritative token currently in force for key instantiation.\n * This must be done for a key to be instantiated.  It has the effect of making\n * available all the keys from the caller of the request_key() that created a\n * key to request_key() calls made by the caller of this function.\n *\n * The caller must have the instantiation key in their process keyrings with a\n * Search permission grant available to the caller.\n *\n * If the ID given is 0, then the setting will be cleared and 0 returned.\n *\n * If the ID given has a matching an authorisation key, then that key will be\n * set and its ID will be returned.  The authorisation key can be read to get\n * the callout information passed to request_key().\n */\nlong keyctl_assume_authority(key_serial_t id)\n{\n\tstruct key *authkey;\n\tlong ret;\n\n\t/* special key IDs aren't permitted */\n\tret = -EINVAL;\n\tif (id < 0)\n\t\tgoto error;\n\n\t/* we divest ourselves of authority if given an ID of 0 */\n\tif (id == 0) {\n\t\tret = keyctl_change_reqkey_auth(NULL);\n\t\tgoto error;\n\t}\n\n\t/* attempt to assume the authority temporarily granted to us whilst we\n\t * instantiate the specified key\n\t * - the authorisation key must be in the current task's keyrings\n\t *   somewhere\n\t */\n\tauthkey = key_get_instantiation_authkey(id);\n\tif (IS_ERR(authkey)) {\n\t\tret = PTR_ERR(authkey);\n\t\tgoto error;\n\t}\n\n\tret = keyctl_change_reqkey_auth(authkey);\n\tif (ret == 0)\n\t\tret = authkey->serial;\n\tkey_put(authkey);\nerror:\n\treturn ret;\n}\n\n/*\n * Get a key's the LSM security label.\n *\n * The key must grant the caller View permission for this to work.\n *\n * If there's a buffer, then up to buflen bytes of data will be placed into it.\n *\n * If successful, the amount of information available will be returned,\n * irrespective of how much was copied (including the terminal NUL).\n */\nlong keyctl_get_security(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *context;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\tif (PTR_ERR(key_ref) != -EACCES)\n\t\t\treturn PTR_ERR(key_ref);\n\n\t\t/* viewing a key under construction is also permitted if we\n\t\t * have the authorisation token handy */\n\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\tif (IS_ERR(instkey))\n\t\t\treturn PTR_ERR(instkey);\n\t\tkey_put(instkey);\n\n\t\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, 0);\n\t\tif (IS_ERR(key_ref))\n\t\t\treturn PTR_ERR(key_ref);\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\tret = security_key_getsecurity(key, &context);\n\tif (ret == 0) {\n\t\t/* if no information was returned, give userspace an empty\n\t\t * string */\n\t\tret = 1;\n\t\tif (buffer && buflen > 0 &&\n\t\t    copy_to_user(buffer, \"\", 1) != 0)\n\t\t\tret = -EFAULT;\n\t} else if (ret > 0) {\n\t\t/* return as much data as there's room for */\n\t\tif (buffer && buflen > 0) {\n\t\t\tif (buflen > ret)\n\t\t\t\tbuflen = ret;\n\n\t\t\tif (copy_to_user(buffer, context, buflen) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(context);\n\t}\n\n\tkey_ref_put(key_ref);\n\treturn ret;\n}\n\n/*\n * Attempt to install the calling process's session keyring on the process's\n * parent process.\n *\n * The keyring must exist and must grant the caller LINK permission, and the\n * parent process must be single-threaded and must have the same effective\n * ownership as this process and mustn't be SUID/SGID.\n *\n * The keyring will be emplaced on the parent when it next resumes userspace.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_session_to_parent(void)\n{\n\tstruct task_struct *me, *parent;\n\tconst struct cred *mycred, *pcred;\n\tstruct callback_head *newwork, *oldwork;\n\tkey_ref_t keyring_r;\n\tstruct cred *cred;\n\tint ret;\n\n\tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_NEED_LINK);\n\tif (IS_ERR(keyring_r))\n\t\treturn PTR_ERR(keyring_r);\n\n\tret = -ENOMEM;\n\n\t/* our parent is going to need a new cred struct, a new tgcred struct\n\t * and new security data, so we allocate them here to prevent ENOMEM in\n\t * our parent */\n\tcred = cred_alloc_blank();\n\tif (!cred)\n\t\tgoto error_keyring;\n\tnewwork = &cred->rcu;\n\n\tcred->session_keyring = key_ref_to_ptr(keyring_r);\n\tkeyring_r = NULL;\n\tinit_task_work(newwork, key_change_session_keyring);\n\n\tme = current;\n\trcu_read_lock();\n\twrite_lock_irq(&tasklist_lock);\n\n\tret = -EPERM;\n\toldwork = NULL;\n\tparent = me->real_parent;\n\n\t/* the parent mustn't be init and mustn't be a kernel thread */\n\tif (parent->pid <= 1 || !parent->mm)\n\t\tgoto unlock;\n\n\t/* the parent must be single threaded */\n\tif (!thread_group_empty(parent))\n\t\tgoto unlock;\n\n\t/* the parent and the child must have different session keyrings or\n\t * there's no point */\n\tmycred = current_cred();\n\tpcred = __task_cred(parent);\n\tif (mycred == pcred ||\n\t    mycred->session_keyring == pcred->session_keyring) {\n\t\tret = 0;\n\t\tgoto unlock;\n\t}\n\n\t/* the parent must have the same effective ownership and mustn't be\n\t * SUID/SGID */\n\tif (!uid_eq(pcred->uid,\t mycred->euid) ||\n\t    !uid_eq(pcred->euid, mycred->euid) ||\n\t    !uid_eq(pcred->suid, mycred->euid) ||\n\t    !gid_eq(pcred->gid,\t mycred->egid) ||\n\t    !gid_eq(pcred->egid, mycred->egid) ||\n\t    !gid_eq(pcred->sgid, mycred->egid))\n\t\tgoto unlock;\n\n\t/* the keyrings must have the same UID */\n\tif ((pcred->session_keyring &&\n\t     !uid_eq(pcred->session_keyring->uid, mycred->euid)) ||\n\t    !uid_eq(mycred->session_keyring->uid, mycred->euid))\n\t\tgoto unlock;\n\n\t/* cancel an already pending keyring replacement */\n\toldwork = task_work_cancel(parent, key_change_session_keyring);\n\n\t/* the replacement session keyring is applied just prior to userspace\n\t * restarting */\n\tret = task_work_add(parent, newwork, true);\n\tif (!ret)\n\t\tnewwork = NULL;\nunlock:\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tif (oldwork)\n\t\tput_cred(container_of(oldwork, struct cred, rcu));\n\tif (newwork)\n\t\tput_cred(cred);\n\treturn ret;\n\nerror_keyring:\n\tkey_ref_put(keyring_r);\n\treturn ret;\n}\n\n/*\n * Apply a restriction to a given keyring.\n *\n * The caller must have Setattr permission to change keyring restrictions.\n *\n * The requested type name may be a NULL pointer to reject all attempts\n * to link to the keyring. If _type is non-NULL, _restriction can be\n * NULL or a pointer to a string describing the restriction. If _type is\n * NULL, _restriction must also be NULL.\n *\n * Returns 0 if successful.\n */\nlong keyctl_restrict_keyring(key_serial_t id, const char __user *_type,\n\t\t\t     const char __user *_restriction)\n{\n\tkey_ref_t key_ref;\n\tbool link_reject = !_type;\n\tchar type[32];\n\tchar *restriction = NULL;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref))\n\t\treturn PTR_ERR(key_ref);\n\n\tif (_type) {\n\t\tret = key_get_type_from_user(type, _type, sizeof(type));\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (_restriction) {\n\t\tif (!_type) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\trestriction = strndup_user(_restriction, PAGE_SIZE);\n\t\tif (IS_ERR(restriction)) {\n\t\t\tret = PTR_ERR(restriction);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tret = keyring_restrict(key_ref, link_reject ? NULL : type, restriction);\n\tkfree(restriction);\n\nerror:\n\tkey_ref_put(key_ref);\n\n\treturn ret;\n}\n\n/*\n * The key control system call\n */\nSYSCALL_DEFINE5(keyctl, int, option, unsigned long, arg2, unsigned long, arg3,\n\t\tunsigned long, arg4, unsigned long, arg5)\n{\n\tswitch (option) {\n\tcase KEYCTL_GET_KEYRING_ID:\n\t\treturn keyctl_get_keyring_ID((key_serial_t) arg2,\n\t\t\t\t\t     (int) arg3);\n\n\tcase KEYCTL_JOIN_SESSION_KEYRING:\n\t\treturn keyctl_join_session_keyring((const char __user *) arg2);\n\n\tcase KEYCTL_UPDATE:\n\t\treturn keyctl_update_key((key_serial_t) arg2,\n\t\t\t\t\t (const void __user *) arg3,\n\t\t\t\t\t (size_t) arg4);\n\n\tcase KEYCTL_REVOKE:\n\t\treturn keyctl_revoke_key((key_serial_t) arg2);\n\n\tcase KEYCTL_DESCRIBE:\n\t\treturn keyctl_describe_key((key_serial_t) arg2,\n\t\t\t\t\t   (char __user *) arg3,\n\t\t\t\t\t   (unsigned) arg4);\n\n\tcase KEYCTL_CLEAR:\n\t\treturn keyctl_keyring_clear((key_serial_t) arg2);\n\n\tcase KEYCTL_LINK:\n\t\treturn keyctl_keyring_link((key_serial_t) arg2,\n\t\t\t\t\t   (key_serial_t) arg3);\n\n\tcase KEYCTL_UNLINK:\n\t\treturn keyctl_keyring_unlink((key_serial_t) arg2,\n\t\t\t\t\t     (key_serial_t) arg3);\n\n\tcase KEYCTL_SEARCH:\n\t\treturn keyctl_keyring_search((key_serial_t) arg2,\n\t\t\t\t\t     (const char __user *) arg3,\n\t\t\t\t\t     (const char __user *) arg4,\n\t\t\t\t\t     (key_serial_t) arg5);\n\n\tcase KEYCTL_READ:\n\t\treturn keyctl_read_key((key_serial_t) arg2,\n\t\t\t\t       (char __user *) arg3,\n\t\t\t\t       (size_t) arg4);\n\n\tcase KEYCTL_CHOWN:\n\t\treturn keyctl_chown_key((key_serial_t) arg2,\n\t\t\t\t\t(uid_t) arg3,\n\t\t\t\t\t(gid_t) arg4);\n\n\tcase KEYCTL_SETPERM:\n\t\treturn keyctl_setperm_key((key_serial_t) arg2,\n\t\t\t\t\t  (key_perm_t) arg3);\n\n\tcase KEYCTL_INSTANTIATE:\n\t\treturn keyctl_instantiate_key((key_serial_t) arg2,\n\t\t\t\t\t      (const void __user *) arg3,\n\t\t\t\t\t      (size_t) arg4,\n\t\t\t\t\t      (key_serial_t) arg5);\n\n\tcase KEYCTL_NEGATE:\n\t\treturn keyctl_negate_key((key_serial_t) arg2,\n\t\t\t\t\t (unsigned) arg3,\n\t\t\t\t\t (key_serial_t) arg4);\n\n\tcase KEYCTL_SET_REQKEY_KEYRING:\n\t\treturn keyctl_set_reqkey_keyring(arg2);\n\n\tcase KEYCTL_SET_TIMEOUT:\n\t\treturn keyctl_set_timeout((key_serial_t) arg2,\n\t\t\t\t\t  (unsigned) arg3);\n\n\tcase KEYCTL_ASSUME_AUTHORITY:\n\t\treturn keyctl_assume_authority((key_serial_t) arg2);\n\n\tcase KEYCTL_GET_SECURITY:\n\t\treturn keyctl_get_security((key_serial_t) arg2,\n\t\t\t\t\t   (char __user *) arg3,\n\t\t\t\t\t   (size_t) arg4);\n\n\tcase KEYCTL_SESSION_TO_PARENT:\n\t\treturn keyctl_session_to_parent();\n\n\tcase KEYCTL_REJECT:\n\t\treturn keyctl_reject_key((key_serial_t) arg2,\n\t\t\t\t\t (unsigned) arg3,\n\t\t\t\t\t (unsigned) arg4,\n\t\t\t\t\t (key_serial_t) arg5);\n\n\tcase KEYCTL_INSTANTIATE_IOV:\n\t\treturn keyctl_instantiate_key_iov(\n\t\t\t(key_serial_t) arg2,\n\t\t\t(const struct iovec __user *) arg3,\n\t\t\t(unsigned) arg4,\n\t\t\t(key_serial_t) arg5);\n\n\tcase KEYCTL_INVALIDATE:\n\t\treturn keyctl_invalidate_key((key_serial_t) arg2);\n\n\tcase KEYCTL_GET_PERSISTENT:\n\t\treturn keyctl_get_persistent((uid_t)arg2, (key_serial_t)arg3);\n\n\tcase KEYCTL_DH_COMPUTE:\n\t\treturn keyctl_dh_compute((struct keyctl_dh_params __user *) arg2,\n\t\t\t\t\t (char __user *) arg3, (size_t) arg4,\n\t\t\t\t\t (struct keyctl_kdf_params __user *) arg5);\n\n\tcase KEYCTL_RESTRICT_KEYRING:\n\t\treturn keyctl_restrict_keyring((key_serial_t) arg2,\n\t\t\t\t\t       (const char __user *) arg3,\n\t\t\t\t\t       (const char __user *) arg4);\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n"], "filenames": ["security/keys/keyctl.c"], "buggy_code_start_loc": [768], "buggy_code_end_loc": [768], "fixing_code_start_loc": [769], "fixing_code_end_loc": [774], "type": "CWE-476", "message": "The keyctl_read_key function in security/keys/keyctl.c in the Key Management subcomponent in the Linux kernel before 4.13.5 does not properly consider that a key may be possessed but negatively instantiated, which allows local users to cause a denial of service (OOPS and system crash) via a crafted KEYCTL_READ operation.", "other": {"cve": {"id": "CVE-2017-12192", "sourceIdentifier": "secalert@redhat.com", "published": "2017-10-12T00:29:00.207", "lastModified": "2023-02-12T23:28:04.000", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The keyctl_read_key function in security/keys/keyctl.c in the Key Management subcomponent in the Linux kernel before 4.13.5 does not properly consider that a key may be possessed but negatively instantiated, which allows local users to cause a denial of service (OOPS and system crash) via a crafted KEYCTL_READ operation."}, {"lang": "es", "value": "La funci\u00f3n keyctl_read_key en security/keys/keyctl.c en el subcomponente Key Management en el kernel de Linux en versiones anteriores a la 4.13.5 no considera correctamente que se puede tener una clave instanciada negativamente, lo que permite que los usuarios locales provoquen una denegaci\u00f3n de servicio (OOPS y cierre inesperado del sistema) mediante una operaci\u00f3n KEYCTL_READ manipulada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.13.4", "matchCriteriaId": "928AB8DD-8573-4425-803D-1B164491BF77"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=37863c43b2c6464f252862bf2e9768264e961678", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.13.5", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0151", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1493435", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/37863c43b2c6464f252862bf2e9768264e961678", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://lkml.org/lkml/2017/9/18/764", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3583-1/", "source": "secalert@redhat.com"}, {"url": "https://usn.ubuntu.com/3583-2/", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/37863c43b2c6464f252862bf2e9768264e961678"}}