{"buggy_code": ["samba.tests.ldap_spn.+LdapSpnTest.test_spn_dodgy_spns\nsamba.tests.ldap_spn.+LdapSpnSambaOnlyTest.test_spn_add_a_conflict_along_with_a_re_added_SPN\n", "/*\n   SAM ldb module\n\n   Copyright (C) Andrew Bartlett <abartlet@samba.org> 2005-2014\n   Copyright (C) Simo Sorce  2004-2008\n   Copyright (C) Matthias Dieter Walln\u00f6fer 2009-2011\n   Copyright (C) Matthieu Patou 2012\n   Copyright (C) Catalyst.Net Ltd 2017\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\n *  Name: ldb\n *\n *  Component: ldb samldb module\n *\n *  Description: various internal DSDB triggers - most for SAM specific objects\n *\n *  Author: Simo Sorce\n */\n\n#include \"includes.h\"\n#include \"libcli/ldap/ldap_ndr.h\"\n#include \"ldb_module.h\"\n#include \"auth/auth.h\"\n#include \"dsdb/samdb/samdb.h\"\n#include \"dsdb/samdb/ldb_modules/util.h\"\n#include \"dsdb/samdb/ldb_modules/ridalloc.h\"\n#include \"libcli/security/security.h\"\n#include \"librpc/gen_ndr/ndr_security.h\"\n#include \"ldb_wrap.h\"\n#include \"param/param.h\"\n#include \"libds/common/flag_mapping.h\"\n#include \"system/network.h\"\n#include \"librpc/gen_ndr/irpc.h\"\n#include \"lib/util/smb_strtox.h\"\n\n#undef strcasecmp\n\nstruct samldb_ctx;\nenum samldb_add_type {\n\tSAMLDB_TYPE_USER,\n\tSAMLDB_TYPE_GROUP,\n\tSAMLDB_TYPE_CLASS,\n\tSAMLDB_TYPE_ATTRIBUTE\n};\n\ntypedef int (*samldb_step_fn_t)(struct samldb_ctx *);\n\nstruct samldb_step {\n\tstruct samldb_step *next;\n\tsamldb_step_fn_t fn;\n};\n\nstruct samldb_ctx {\n\tstruct ldb_module *module;\n\tstruct ldb_request *req;\n\n\t/* used for add operations */\n\tenum samldb_add_type type;\n\n\t/*\n\t * should we apply the need_trailing_dollar restriction to\n\t * samAccountName\n\t */\n\n\tbool need_trailing_dollar;\n\n\t/* the resulting message */\n\tstruct ldb_message *msg;\n\n\t/* used in \"samldb_find_for_defaultObjectCategory\" */\n\tstruct ldb_dn *dn, *res_dn;\n\n\t/* all the async steps necessary to complete the operation */\n\tstruct samldb_step *steps;\n\tstruct samldb_step *curstep;\n\n\t/* If someone set an ares to forward controls and response back to the caller */\n\tstruct ldb_reply *ares;\n};\n\nstatic struct samldb_ctx *samldb_ctx_init(struct ldb_module *module,\n\t\t\t\t\t  struct ldb_request *req)\n{\n\tstruct ldb_context *ldb;\n\tstruct samldb_ctx *ac;\n\n\tldb = ldb_module_get_ctx(module);\n\n\tac = talloc_zero(req, struct samldb_ctx);\n\tif (ac == NULL) {\n\t\tldb_oom(ldb);\n\t\treturn NULL;\n\t}\n\n\tac->module = module;\n\tac->req = req;\n\n\treturn ac;\n}\n\nstatic int samldb_add_step(struct samldb_ctx *ac, samldb_step_fn_t fn)\n{\n\tstruct samldb_step *step, *stepper;\n\n\tstep = talloc_zero(ac, struct samldb_step);\n\tif (step == NULL) {\n\t\treturn ldb_oom(ldb_module_get_ctx(ac->module));\n\t}\n\n\tstep->fn = fn;\n\n\tif (ac->steps == NULL) {\n\t\tac->steps = step;\n\t\tac->curstep = step;\n\t} else {\n\t\tif (ac->curstep == NULL)\n\t\t\treturn ldb_operr(ldb_module_get_ctx(ac->module));\n\t\tfor (stepper = ac->curstep; stepper->next != NULL;\n\t\t\tstepper = stepper->next);\n\t\tstepper->next = step;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_first_step(struct samldb_ctx *ac)\n{\n\tif (ac->steps == NULL) {\n\t\treturn ldb_operr(ldb_module_get_ctx(ac->module));\n\t}\n\n\tac->curstep = ac->steps;\n\treturn ac->curstep->fn(ac);\n}\n\nstatic int samldb_next_step(struct samldb_ctx *ac)\n{\n\tif (ac->curstep->next) {\n\t\tac->curstep = ac->curstep->next;\n\t\treturn ac->curstep->fn(ac);\n\t}\n\n\t/* We exit the samldb module here. If someone set an \"ares\" to forward\n\t * controls and response back to the caller, use them. */\n\tif (ac->ares) {\n\t\treturn ldb_module_done(ac->req, ac->ares->controls,\n\t\t\t\t       ac->ares->response, LDB_SUCCESS);\n\t} else {\n\t\treturn ldb_module_done(ac->req, NULL, NULL, LDB_SUCCESS);\n\t}\n}\n\nstatic int samldb_get_single_valued_attr(struct ldb_context *ldb,\n\t\t\t\t\t struct samldb_ctx *ac,\n\t\t\t\t\t const char *attr,\n\t\t\t\t\t const char **value)\n{\n\t/*\n\t * The steps we end up going through to get and check a single valued\n\t * attribute.\n\t */\n\tstruct ldb_message_element *el = NULL;\n\tint ret;\n\n\t*value = NULL;\n\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   attr,\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (el == NULL) {\n\t\t/* we are not affected */\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tif (el->num_values > 1) {\n\t\tldb_asprintf_errstring(\n\t\t\tldb,\n\t\t        \"samldb: %s has %u values, should be single-valued!\",\n\t\t\tattr, el->num_values);\n\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t} else if (el->num_values == 0) {\n\t\tldb_asprintf_errstring(\n\t\t\tldb,\n\t\t\t\"samldb: new value for %s \"\n\t\t\t\"not provided for mandatory, single-valued attribute!\",\n\t\t\tattr);\n\t\treturn LDB_ERR_OBJECT_CLASS_VIOLATION;\n\t}\n\n\n\tif (el->values[0].length == 0) {\n\t\tldb_asprintf_errstring(\n\t\t\tldb,\n\t\t\t\"samldb: %s is of zero length, should have a value!\",\n\t\t\tattr);\n\t\treturn LDB_ERR_OBJECT_CLASS_VIOLATION;\n\t}\n\n\t*value = (char *)el->values[0].data;\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_unique_attr_check(struct samldb_ctx *ac, const char *attr,\n\t\t\t\t    const char *attr_conflict,\n\t\t\t\t    struct ldb_dn *base_dn)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tconst char * const no_attrs[] = { NULL };\n\tstruct ldb_result *res = NULL;\n\tconst char *str = NULL;\n\tconst char *enc_str = NULL;\n\tint ret;\n\n\tret = samldb_get_single_valued_attr(ldb, ac, attr, &str);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (str == NULL) {\n\t\t/* the attribute wasn't found */\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tenc_str = ldb_binary_encode_string(ac, str);\n\tif (enc_str == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\n\t/*\n\t * No other object should have the attribute with this value.\n\t */\n\tif (attr_conflict != NULL) {\n\t\tret = dsdb_module_search(ac->module, ac, &res,\n\t\t\t\t\t base_dn,\n\t\t\t\t\t LDB_SCOPE_SUBTREE, no_attrs,\n\t\t\t\t\t DSDB_FLAG_NEXT_MODULE, ac->req,\n\t\t\t\t\t \"(|(%s=%s)(%s=%s))\",\n\t\t\t\t\t attr, enc_str,\n\t\t\t\t\t attr_conflict, enc_str);\n\t} else {\n\t\tret = dsdb_module_search(ac->module, ac, &res,\n\t\t\t\t\t base_dn,\n\t\t\t\t\t LDB_SCOPE_SUBTREE, no_attrs,\n\t\t\t\t\t DSDB_FLAG_NEXT_MODULE, ac->req,\n\t\t\t\t\t \"(%s=%s)\", attr, enc_str);\n\t}\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (res->count > 1) {\n\t\treturn ldb_operr(ldb);\n\t} else if (res->count == 1) {\n\t\tif (ldb_dn_compare(res->msgs[0]->dn, ac->msg->dn) != 0) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"samldb: %s '%s' already in use!\",\n\t\t\t\t\t       attr, enc_str);\n\t\t\treturn LDB_ERR_ENTRY_ALREADY_EXISTS;\n\t\t}\n\t}\n\ttalloc_free(res);\n\n\treturn LDB_SUCCESS;\n}\n\n\n\nstatic inline int samldb_sam_account_upn_clash_sub_search(\n\tstruct samldb_ctx *ac,\n\tTALLOC_CTX *mem_ctx,\n\tstruct ldb_dn *base_dn,\n\tconst char *attr,\n\tconst char *value,\n\tconst char *err_msg\n\t)\n{\n\t/*\n\t * A very specific helper function for samldb_sam_account_upn_clash(),\n\t * where we end up doing this same thing several times in a row.\n\t */\n\tconst char * const no_attrs[] = { NULL };\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tstruct ldb_result *res = NULL;\n\tint ret;\n\tchar *enc_value = ldb_binary_encode_string(ac, value);\n\tif (enc_value == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tret = dsdb_module_search(ac->module, mem_ctx, &res,\n\t\t\t\t base_dn,\n\t\t\t\t LDB_SCOPE_SUBTREE, no_attrs,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE, ac->req,\n\t\t\t\t \"(%s=%s)\",\n\t\t\t\t attr, enc_value);\n\ttalloc_free(enc_value);\n\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t} else if (res->count > 1) {\n\t\treturn ldb_operr(ldb);\n\t} else if (res->count == 1) {\n\t\tif (ldb_dn_compare(res->msgs[0]->dn, ac->msg->dn) != 0){\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"samldb: %s '%s' \"\n\t\t\t\t\t       \"is already in use %s\",\n\t\t\t\t\t       attr, value, err_msg);\n\t\t\t/* different errors for different attrs */\n\t\t\tif (strcasecmp(\"userPrincipalName\", attr) == 0) {\n\t\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t\t}\n\t\t\treturn LDB_ERR_ENTRY_ALREADY_EXISTS;\n\t\t}\n\t}\n\treturn LDB_SUCCESS;\n}\n\nstatic int samaccountname_bad_chars_check(struct samldb_ctx *ac,\n\t\t\t\t\t  const char *name)\n{\n\t/*\n\t * The rules here are based on\n\t *\n\t * https://social.technet.microsoft.com/wiki/contents/articles/11216.active-directory-requirements-for-creating-objects.aspx\n\t *\n\t * Windows considers UTF-8 sequences that map to \"similar\" characters\n\t * (e.g. 'a', '\u0101') to be the same sAMAccountName, and we don't. Names\n\t * that are not valid UTF-8 *are* allowed.\n\t *\n\t * Additionally, Samba collapses multiple spaces, and Windows doesn't.\n\t */\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tsize_t i;\n\n\tfor (i = 0; name[i] != '\\0'; i++) {\n\t\tuint8_t c = name[i];\n\t\tchar *p = NULL;\n\t\tif (c < 32 || c == 127) {\n\t\t\tldb_asprintf_errstring(\n\t\t\t\tldb,\n\t\t\t\t\"samldb: sAMAccountName contains invalid \"\n\t\t\t\t\"0x%.2x character\\n\", c);\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t\tp = strchr(\"\\\"[]:;|=+*?<>/\\\\,\", c);\n\t\tif (p != NULL) {\n\t\t\tldb_asprintf_errstring(\n\t\t\t\tldb,\n\t\t\t\t\"samldb: sAMAccountName contains invalid \"\n\t\t\t\t\"'%c' character\\n\", c);\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t}\n\n\tif (i == 0) {\n\t\tldb_asprintf_errstring(\n\t\t\tldb,\n\t\t\t\"samldb: sAMAccountName is empty\\n\");\n\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t}\n\n\tif (name[i - 1] == '.') {\n\t\tldb_asprintf_errstring(\n\t\t\tldb,\n\t\t\t\"samldb: sAMAccountName ends with '.'\");\n\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t}\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_sam_account_upn_clash(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\tstruct ldb_dn *base_dn = ldb_get_default_basedn(ldb);\n\tTALLOC_CTX *tmp_ctx = NULL;\n\tconst char *real_sam = NULL;\n\tconst char *real_upn = NULL;\n\tchar *implied_sam = NULL;\n\tchar *implied_upn = NULL;\n\tconst char *realm = NULL;\n\n\tret = samldb_get_single_valued_attr(ldb, ac,\n\t\t\t\t\t    \"sAMAccountName\",\n\t\t\t\t\t    &real_sam);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tret = samldb_get_single_valued_attr(ldb, ac,\n\t\t\t\t\t    \"userPrincipalName\",\n\t\t\t\t\t    &real_upn);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (real_upn == NULL && real_sam == NULL) {\n\t\t/* Not changing these things, so we're done */\n\t\treturn LDB_SUCCESS;\n\t}\n\n\ttmp_ctx = talloc_new(ac);\n\trealm = samdb_dn_to_dns_domain(tmp_ctx, base_dn);\n\tif (realm == NULL) {\n\t\ttalloc_free(tmp_ctx);\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tif (real_upn != NULL) {\n\t\t/*\n\t\t * note we take the last @ in the upn because the first (i.e.\n\t\t * sAMAccountName equivalent) part can contain @.\n\t\t *\n\t\t * It is also OK (per Windows) for a UPN to have zero @s.\n\t\t */\n\t\tchar *at = NULL;\n\t\tchar *upn_realm = NULL;\n\t\timplied_sam = talloc_strdup(tmp_ctx, real_upn);\n\t\tif (implied_sam == NULL) {\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ldb_module_oom(ac->module);\n\t\t}\n\n\t\tat = strrchr(implied_sam, '@');\n\t\tif (at == NULL) {\n\t\t\t/*\n\t\t\t * there is no @ in this UPN, so we treat the whole\n\t\t\t * thing as a sAMAccountName for the purposes of a\n\t\t\t * clash.\n\t\t\t */\n\t\t\tDBG_INFO(\"samldb: userPrincipalName '%s' contains \"\n\t\t\t\t \"no '@' character\\n\", implied_sam);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Now, this upn only implies a sAMAccountName if the\n\t\t\t * realm is our realm. So we need to compare the tail\n\t\t\t * of the upn to the realm.\n\t\t\t */\n\t\t\t*at = '\\0';\n\t\t\tupn_realm = at + 1;\n\t\t\tif (strcasecmp(upn_realm, realm) != 0) {\n\t\t\t\t/* implied_sam is not the implied\n\t\t\t\t * sAMAccountName after all, because it is\n\t\t\t\t * from a different realm. */\n\t\t\t\tTALLOC_FREE(implied_sam);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (real_sam != NULL) {\n\t\timplied_upn = talloc_asprintf(tmp_ctx, \"%s@%s\",\n\t\t\t\t\t      real_sam, realm);\n\t\tif (implied_upn == NULL) {\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ldb_module_oom(ac->module);\n\t\t}\n\t}\n\n\t/*\n\t * Now we have all of the actual and implied names, in which to search\n\t * for conflicts.\n\t */\n\tif (real_sam != NULL) {\n\t\tret = samldb_sam_account_upn_clash_sub_search(\n\t\t\tac, tmp_ctx, base_dn, \"sAMAccountName\",\n\t\t\treal_sam, \"\");\n\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t\tret = samaccountname_bad_chars_check(ac, real_sam);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (implied_upn != NULL) {\n\t\tret = samldb_sam_account_upn_clash_sub_search(\n\t\t\tac, tmp_ctx, base_dn, \"userPrincipalName\", implied_upn,\n\t\t\t\"(implied by sAMAccountName)\");\n\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (real_upn != NULL) {\n\t\tret = samldb_sam_account_upn_clash_sub_search(\n\t\t\tac, tmp_ctx, base_dn, \"userPrincipalName\",\n\t\t\treal_upn, \"\");\n\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (implied_sam != NULL) {\n\t\tret = samldb_sam_account_upn_clash_sub_search(\n\t\t\tac, tmp_ctx, base_dn, \"sAMAccountName\", implied_sam,\n\t\t\t\"(implied by userPrincipalName)\");\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\ttalloc_free(tmp_ctx);\n\treturn LDB_SUCCESS;\n}\n\n\n/* This is run during an add or modify */\nstatic int samldb_sam_accountname_valid_check(struct samldb_ctx *ac)\n{\n\tint ret = 0;\n\tbool is_admin;\n\tstruct security_token *user_token = NULL;\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tstruct ldb_message_element *el = NULL;\n\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"samAccountName\",\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (el == NULL || el->num_values == 0) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\"%08X: samldb: 'samAccountName' can't be deleted/empty!\",\n\t\t\tW_ERROR_V(WERR_DS_ILLEGAL_MOD_OPERATION));\n\t\tif (ac->req->operation == LDB_ADD) {\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t} else {\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\t}\n\n\tret = samldb_unique_attr_check(ac, \"samAccountName\", NULL,\n\t\t\t\t       ldb_get_default_basedn(\n\t\t\t\t\t       ldb_module_get_ctx(ac->module)));\n\n\t/*\n\t * Error code munging to try and match what must be some quite\n\t * strange code-paths in Windows\n\t */\n\tif (ret == LDB_ERR_CONSTRAINT_VIOLATION\n\t    && ac->req->operation == LDB_MODIFY) {\n\t\tret = LDB_ERR_ATTRIBUTE_OR_VALUE_EXISTS;\n\t} else if (ret == LDB_ERR_OBJECT_CLASS_VIOLATION) {\n\t\tret = LDB_ERR_CONSTRAINT_VIOLATION;\n\t}\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = samldb_sam_account_upn_clash(ac);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (!ac->need_trailing_dollar) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* This does not permit a single $ */\n\tif (el->values[0].length < 2) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"%08X: samldb: 'samAccountName' \"\n\t\t\t\t       \"can't just be one character!\",\n\t\t\tW_ERROR_V(WERR_DS_ILLEGAL_MOD_OPERATION));\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\tuser_token = acl_user_token(ac->module);\n\tif (user_token == NULL) {\n\t\treturn LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n\t}\n\n\tis_admin\n\t\t= security_token_has_builtin_administrators(user_token);\n\n\tif (is_admin) {\n\t\t/*\n\t\t * Administrators are allowed to select strange names.\n\t\t * This is poor practice but not prevented.\n\t\t */\n\t\treturn false;\n\t}\n\n\tif (el->values[0].data[el->values[0].length - 1] != '$') {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"%08X: samldb: 'samAccountName' \"\n\t\t\t\t       \"must have a trailing $!\",\n\t\t\tW_ERROR_V(WERR_DS_ILLEGAL_MOD_OPERATION));\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\tif (el->values[0].data[el->values[0].length - 2] == '$') {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"%08X: samldb: 'samAccountName' \"\n\t\t\t\t       \"must not have a double trailing $!\",\n\t\t\tW_ERROR_V(WERR_DS_ILLEGAL_MOD_OPERATION));\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\treturn ret;\n}\n\nstatic int samldb_schema_attributeid_valid_check(struct samldb_ctx *ac)\n{\n\tint ret = samldb_unique_attr_check(ac, \"attributeID\", \"governsID\",\n\t\t\t\t\t   ldb_get_schema_basedn(\n\t\t\t\t\t\t   ldb_module_get_ctx(ac->module)));\n\tif (ret == LDB_ERR_ENTRY_ALREADY_EXISTS) {\n\t\tret = LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\treturn ret;\n}\n\nstatic int samldb_schema_governsid_valid_check(struct samldb_ctx *ac)\n{\n\tint ret = samldb_unique_attr_check(ac, \"governsID\", \"attributeID\",\n\t\t\t\t\t   ldb_get_schema_basedn(\n\t\t\t\t\t\t   ldb_module_get_ctx(ac->module)));\n\tif (ret == LDB_ERR_ENTRY_ALREADY_EXISTS) {\n\t\tret = LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\treturn ret;\n}\n\nstatic int samldb_schema_ldapdisplayname_valid_check(struct samldb_ctx *ac)\n{\n\tint ret = samldb_unique_attr_check(ac, \"lDAPDisplayName\", NULL,\n\t\t\t\t\t   ldb_get_schema_basedn(\n\t\t\t\t\t\t   ldb_module_get_ctx(ac->module)));\n\tif (ret == LDB_ERR_ENTRY_ALREADY_EXISTS) {\n\t\tret = LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\treturn ret;\n}\n\nstatic int samldb_check_linkid_used(struct samldb_ctx *ac,\n\t\t\t\t    struct dsdb_schema *schema,\n\t\t\t\t    struct ldb_dn *schema_dn,\n\t\t\t\t    struct ldb_context *ldb,\n\t\t\t\t    int32_t linkID,\n\t\t\t\t    bool *found)\n{\n\tint ret;\n\tstruct ldb_result *ldb_res;\n\n\tif (dsdb_attribute_by_linkID(schema, linkID)) {\n\t\t*found = true;\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tret = dsdb_module_search(ac->module, ac,\n\t\t\t\t &ldb_res,\n\t\t\t\t schema_dn, LDB_SCOPE_ONELEVEL, NULL,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(linkID=%d)\", linkID);\n\tif (ret != LDB_SUCCESS) {\n\t\tldb_debug_set(ldb, LDB_DEBUG_ERROR,\n\t\t\t      __location__\": Searching for linkID=%d failed - %s\\n\",\n\t\t\t      linkID,\n\t\t\t      ldb_errstring(ldb));\n\t\treturn ldb_operr(ldb);\n\t}\n\n\t*found = (ldb_res->count != 0);\n\ttalloc_free(ldb_res);\n\n\treturn LDB_SUCCESS;\n}\n\n/* Find the next open forward linkID in the schema. */\nstatic int samldb_generate_next_linkid(struct samldb_ctx *ac,\n\t\t\t\t       struct dsdb_schema *schema,\n\t\t\t\t       int32_t *next_linkID)\n{\n\tint ret;\n\tstruct ldb_context *ldb;\n\tstruct ldb_dn *schema_dn;\n\tbool linkID_used = true;\n\n\t/*\n\t * Windows starts at about 0xB0000000 in order to stop potential\n\t * collisions with future additions to the schema. We pass this\n\t * around as a signed int sometimes, but this should be sufficient.\n\t */\n\t*next_linkID = 0x40000000;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\tschema_dn = ldb_get_schema_basedn(ldb);\n\n\twhile (linkID_used) {\n\t\t*next_linkID += 2;\n\t\tret = samldb_check_linkid_used(ac, schema,\n\t\t\t\t\t       schema_dn, ldb,\n\t\t\t\t\t       *next_linkID, &linkID_used);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_schema_add_handle_linkid(struct samldb_ctx *ac)\n{\n\tint ret;\n\tbool ok, found = false;\n\tstruct ldb_message_element *el;\n\tconst char *enc_str;\n\tconst struct dsdb_attribute *attr;\n\tstruct ldb_context *ldb;\n\tstruct ldb_dn *schema_dn;\n\tstruct dsdb_schema *schema;\n\tint32_t new_linkID = 0;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\tschema = dsdb_get_schema(ldb, ac);\n\tschema_dn = ldb_get_schema_basedn(ldb);\n\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"linkID\",\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (el == NULL) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tenc_str = ldb_binary_encode(ac, el->values[0]);\n\tif (enc_str == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\n\tok = (strcmp(enc_str, \"0\") == 0);\n\tif (ok) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/*\n\t * This OID indicates that the caller wants the linkID\n\t * to be automatically generated. We therefore assign\n\t * it the next open linkID.\n\t */\n\tok = (strcmp(enc_str, \"1.2.840.113556.1.2.50\") == 0);\n\tif (ok) {\n\t\tret = samldb_generate_next_linkid(ac, schema, &new_linkID);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tldb_msg_remove_element(ac->msg, el);\n\t\tret = samdb_msg_add_int(ldb, ac->msg, ac->msg, \"linkID\",\n\t\t\t\t\tnew_linkID);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Using either the attributeID or lDAPDisplayName of\n\t * another attribute in the linkID field indicates that\n\t * we should make this the backlink of that attribute.\n\t */\n\tattr = dsdb_attribute_by_attributeID_oid(schema, enc_str);\n\tif (attr == NULL) {\n\t\tattr = dsdb_attribute_by_lDAPDisplayName(schema, enc_str);\n\t}\n\n\tif (attr != NULL) {\n\t\t/*\n\t\t * The attribute we're adding this as a backlink of must\n\t\t * be a forward link.\n\t\t */\n\t\tif (attr->linkID % 2 != 0) {\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\n\t\tnew_linkID = attr->linkID + 1;\n\n\t\t/* Make sure that this backlink doesn't already exist. */\n\t\tret = samldb_check_linkid_used(ac, schema,\n\t\t\t\t\t       schema_dn, ldb,\n\t\t\t\t\t       new_linkID, &found);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (found) {\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\n\t\tldb_msg_remove_element(ac->msg, el);\n\t\tret = samdb_msg_add_int(ldb, ac->msg, ac->msg, \"linkID\",\n\t\t\t\t\tnew_linkID);\n\t\treturn ret;\n\t}\n\n\tschema_dn = ldb_get_schema_basedn(ldb_module_get_ctx(ac->module));\n\tret = samldb_unique_attr_check(ac, \"linkID\", NULL, schema_dn);\n\tif (ret == LDB_ERR_ENTRY_ALREADY_EXISTS) {\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t} else {\n\t\treturn ret;\n\t}\n}\n\nstatic int samldb_check_mapiid_used(struct samldb_ctx *ac,\n\t\t\t\t    struct dsdb_schema *schema,\n\t\t\t\t    struct ldb_dn *schema_dn,\n\t\t\t\t    struct ldb_context *ldb,\n\t\t\t\t    int32_t mapiid,\n\t\t\t\t    bool *found)\n{\n\tint ret;\n\tstruct ldb_result *ldb_res;\n\n\tret = dsdb_module_search(ac->module, ac,\n\t\t\t\t &ldb_res,\n\t\t\t\t schema_dn, LDB_SCOPE_ONELEVEL, NULL,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(mAPIID=%d)\", mapiid);\n\tif (ret != LDB_SUCCESS) {\n\t\tldb_debug_set(ldb, LDB_DEBUG_ERROR,\n\t\t\t      __location__\": Searching for mAPIID=%d failed - %s\\n\",\n\t\t\t      mapiid,\n\t\t\t      ldb_errstring(ldb));\n\t\treturn ldb_operr(ldb);\n\t}\n\n\t*found = (ldb_res->count != 0);\n\ttalloc_free(ldb_res);\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_generate_next_mapiid(struct samldb_ctx *ac,\n\t\t\t\t       struct dsdb_schema *schema,\n\t\t\t\t       int32_t *next_mapiid)\n{\n\tint ret;\n\tstruct ldb_context *ldb;\n\tstruct ldb_dn *schema_dn;\n\tbool mapiid_used = true;\n\n\t/* Windows' generation seems to start about here */\n\t*next_mapiid = 60000;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\tschema_dn = ldb_get_schema_basedn(ldb);\n\n\twhile (mapiid_used) {\n\t\t*next_mapiid += 1;\n\t\tret = samldb_check_mapiid_used(ac, schema,\n\t\t\t\t\t       schema_dn, ldb,\n\t\t\t\t\t       *next_mapiid, &mapiid_used);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_schema_add_handle_mapiid(struct samldb_ctx *ac)\n{\n\tint ret;\n\tbool ok;\n\tstruct ldb_message_element *el;\n\tconst char *enc_str;\n\tstruct ldb_context *ldb;\n\tstruct ldb_dn *schema_dn;\n\tstruct dsdb_schema *schema;\n\tint32_t new_mapiid = 0;\n\n\t/*\n\t * The mAPIID of a new attribute should be automatically generated\n\t * if a specific OID is put as the mAPIID, as according to\n\t * [MS-ADTS] 3.1.1.2.3.2.\n\t */\n\n\tldb = ldb_module_get_ctx(ac->module);\n\tschema = dsdb_get_schema(ldb, ac);\n\tschema_dn = ldb_get_schema_basedn(ldb);\n\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"mAPIID\",\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (el == NULL) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tenc_str = ldb_binary_encode(ac, el->values[0]);\n\tif (enc_str == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\n\tok = (strcmp(enc_str, \"1.2.840.113556.1.2.49\") == 0);\n\tif (ok) {\n\t\tret = samldb_generate_next_mapiid(ac, schema,\n\t\t\t\t\t\t  &new_mapiid);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tldb_msg_remove_element(ac->msg, el);\n\t\tret = samdb_msg_add_int(ldb, ac->msg, ac->msg,\n\t\t\t\t\t\"mAPIID\", new_mapiid);\n\t\treturn ret;\n\t}\n\n\tschema_dn = ldb_get_schema_basedn(ldb_module_get_ctx(ac->module));\n\tret = samldb_unique_attr_check(ac, \"mAPIID\", NULL, schema_dn);\n\tif (ret == LDB_ERR_ENTRY_ALREADY_EXISTS) {\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t} else {\n\t\treturn ret;\n\t}\n}\n\n/* sAMAccountName handling */\nstatic int samldb_generate_sAMAccountName(struct samldb_ctx *ac,\n\t\t\t\t\t  struct ldb_message *msg)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tchar *name;\n\n\t/*\n\t * This is currently a Samba-only behaviour, to add a trailing\n\t * $ even for the generated accounts.\n\t */\n\n\tif (ac->need_trailing_dollar) {\n\t\t/* Format: $000000-00000000000$ */\n\t\tname = talloc_asprintf(msg, \"$%.6X-%.6X%.5X$\",\n\t\t\t\t       (unsigned int)generate_random(),\n\t\t\t\t       (unsigned int)generate_random(),\n\t\t\t\t       (unsigned int)generate_random());\n\t} else {\n\t\t/* Format: $000000-000000000000 */\n\n\t\tname = talloc_asprintf(msg, \"$%.6X-%.6X%.6X\",\n\t\t\t\t       (unsigned int)generate_random(),\n\t\t\t\t       (unsigned int)generate_random(),\n\t\t\t\t       (unsigned int)generate_random());\n\t}\n\tif (name == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\treturn ldb_msg_add_steal_string(msg, \"sAMAccountName\", name);\n}\n\nstatic int samldb_check_sAMAccountName(struct samldb_ctx *ac)\n{\n\tint ret;\n\n\tif (ldb_msg_find_element(ac->msg, \"sAMAccountName\") == NULL) {\n\t\tret = samldb_generate_sAMAccountName(ac, ac->msg);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = samldb_sam_accountname_valid_check(ac);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn samldb_next_step(ac);\n}\n\n\nstatic bool samldb_msg_add_sid(struct ldb_message *msg,\n\t\t\t\tconst char *name,\n\t\t\t\tconst struct dom_sid *sid)\n{\n\tstruct ldb_val v;\n\tenum ndr_err_code ndr_err;\n\n\tndr_err = ndr_push_struct_blob(&v, msg, sid,\n\t\t\t\t       (ndr_push_flags_fn_t)ndr_push_dom_sid);\n\tif (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {\n\t\treturn false;\n\t}\n\treturn (ldb_msg_add_value(msg, name, &v, NULL) == 0);\n}\n\n\n/* allocate a SID using our RID Set */\nstatic int samldb_allocate_sid(struct samldb_ctx *ac)\n{\n\tuint32_t rid;\n\tstruct dom_sid *sid;\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\n\tret = ridalloc_allocate_rid(ac->module, &rid, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tsid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), rid);\n\tif (sid == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\n\tif ( ! samldb_msg_add_sid(ac->msg, \"objectSid\", sid)) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\treturn samldb_next_step(ac);\n}\n\n/*\n  see if a krbtgt_number is available\n */\nstatic bool samldb_krbtgtnumber_available(struct samldb_ctx *ac,\n\t\t\t\t\t  uint32_t krbtgt_number)\n{\n\tTALLOC_CTX *tmp_ctx = talloc_new(ac);\n\tstruct ldb_result *res;\n\tconst char * const no_attrs[] = { NULL };\n\tint ret;\n\n\tret = dsdb_module_search(ac->module, tmp_ctx, &res,\n\t\t\t\t ldb_get_default_basedn(ldb_module_get_ctx(ac->module)),\n\t\t\t\t LDB_SCOPE_SUBTREE, no_attrs,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(msDS-SecondaryKrbTgtNumber=%u)\",\n\t\t\t\t krbtgt_number);\n\tif (ret == LDB_SUCCESS && res->count == 0) {\n\t\ttalloc_free(tmp_ctx);\n\t\treturn true;\n\t}\n\ttalloc_free(tmp_ctx);\n\treturn false;\n}\n\n/* special handling for add in RODC join */\nstatic int samldb_rodc_add(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tuint32_t krbtgt_number, i_start, i;\n\tint ret;\n\tstruct ldb_val newpass_utf16;\n\n\t/* find a unused msDS-SecondaryKrbTgtNumber */\n\ti_start = generate_random() & 0xFFFF;\n\tif (i_start == 0) {\n\t\ti_start = 1;\n\t}\n\n\tfor (i=i_start; i<=0xFFFF; i++) {\n\t\tif (samldb_krbtgtnumber_available(ac, i)) {\n\t\t\tkrbtgt_number = i;\n\t\t\tgoto found;\n\t\t}\n\t}\n\tfor (i=1; i<i_start; i++) {\n\t\tif (samldb_krbtgtnumber_available(ac, i)) {\n\t\t\tkrbtgt_number = i;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tldb_asprintf_errstring(ldb,\n\t\t\t       \"%08X: Unable to find available msDS-SecondaryKrbTgtNumber\",\n\t\t\t       W_ERROR_V(WERR_NO_SYSTEM_RESOURCES));\n\treturn LDB_ERR_OTHER;\n\nfound:\n\tret = ldb_msg_add_empty(ac->msg, \"msDS-SecondaryKrbTgtNumber\",\n\t\t\t\tLDB_FLAG_INTERNAL_DISABLE_VALIDATION, NULL);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg,\n\t\t\t\t \"msDS-SecondaryKrbTgtNumber\", krbtgt_number);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = ldb_msg_add_fmt(ac->msg, \"sAMAccountName\", \"krbtgt_%u\",\n\t\t\t      krbtgt_number);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tnewpass_utf16 = data_blob_talloc_zero(ac->module, 256);\n\tif (newpass_utf16.data == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\t/*\n\t * Note that the password_hash module will ignore\n\t * this value and use it's own generate_secret_buffer()\n\t * that's why we can just use generate_random_buffer()\n\t * here.\n\t */\n\tgenerate_random_buffer(newpass_utf16.data, newpass_utf16.length);\n\tret = ldb_msg_add_steal_value(ac->msg, \"clearTextPassword\", &newpass_utf16);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\treturn samldb_next_step(ac);\n}\n\nstatic int samldb_find_for_defaultObjectCategory(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tstruct ldb_result *res;\n\tconst char * const no_attrs[] = { NULL };\n\tint ret;\n\n\tac->res_dn = NULL;\n\n\tret = dsdb_module_search(ac->module, ac, &res,\n\t\t\t\t ac->dn, LDB_SCOPE_BASE, no_attrs,\n\t\t\t\t DSDB_SEARCH_SHOW_DN_IN_STORAGE_FORMAT\n\t\t\t\t | DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(objectClass=classSchema)\");\n\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\t/* Don't be pricky when the DN doesn't exist if we have the */\n\t\t/* RELAX control specified */\n\t\tif (ldb_request_get_control(ac->req,\n\t\t\t\t\t    LDB_CONTROL_RELAX_OID) == NULL) {\n\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t  \"samldb_find_defaultObjectCategory: \"\n\t\t\t\t\t  \"Invalid DN for 'defaultObjectCategory'!\");\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t}\n\tif ((ret != LDB_ERR_NO_SUCH_OBJECT) && (ret != LDB_SUCCESS)) {\n\t\treturn ret;\n\t}\n\n\tif (ret == LDB_SUCCESS) {\n\t\t/* ensure the defaultObjectCategory has a full GUID */\n\t\tstruct ldb_message *m;\n\t\tm = ldb_msg_new(ac->msg);\n\t\tif (m == NULL) {\n\t\t\treturn ldb_oom(ldb);\n\t\t}\n\t\tm->dn = ac->msg->dn;\n\t\tif (ldb_msg_add_string(m, \"defaultObjectCategory\",\n\t\t\t\t       ldb_dn_get_extended_linearized(m, res->msgs[0]->dn, 1)) !=\n\t\t    LDB_SUCCESS) {\n\t\t\treturn ldb_oom(ldb);\n\t\t}\n\t\tm->elements[0].flags = LDB_FLAG_MOD_REPLACE;\n\n\t\tret = dsdb_module_modify(ac->module, m,\n\t\t\t\t\t DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t\t ac->req);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\n\tac->res_dn = ac->dn;\n\n\treturn samldb_next_step(ac);\n}\n\n/**\n * msDS-IntId attributeSchema attribute handling\n * during LDB_ADD request processing\n */\nstatic int samldb_add_handle_msDS_IntId(struct samldb_ctx *ac)\n{\n\tint ret;\n\tbool id_exists;\n\tuint32_t msds_intid;\n\tint32_t system_flags;\n\tstruct ldb_context *ldb;\n\tstruct ldb_result *ldb_res;\n\tstruct ldb_dn *schema_dn;\n\tstruct samldb_msds_intid_persistant *msds_intid_struct;\n\tstruct dsdb_schema *schema;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\tschema_dn = ldb_get_schema_basedn(ldb);\n\n\t/* replicated update should always go through */\n\tif (ldb_request_get_control(ac->req,\n\t\t\t\t    DSDB_CONTROL_REPLICATED_UPDATE_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* msDS-IntId is handled by system and should never be\n\t * passed by clients */\n\tif (ldb_msg_find_element(ac->msg, \"msDS-IntId\")) {\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t/* do not generate msDS-IntId if Relax control is passed */\n\tif (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* check Functional Level */\n\tif (dsdb_functional_level(ldb) < DS_DOMAIN_FUNCTION_2003) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* check systemFlags for SCHEMA_BASE_OBJECT flag */\n\tsystem_flags = ldb_msg_find_attr_as_int(ac->msg, \"systemFlags\", 0);\n\tif (system_flags & SYSTEM_FLAG_SCHEMA_BASE_OBJECT) {\n\t\treturn LDB_SUCCESS;\n\t}\n\tschema = dsdb_get_schema(ldb, NULL);\n\tif (!schema) {\n\t\tldb_debug_set(ldb, LDB_DEBUG_FATAL,\n\t\t\t      \"samldb_schema_info_update: no dsdb_schema loaded\");\n\t\tDEBUG(0,(__location__ \": %s\\n\", ldb_errstring(ldb)));\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tmsds_intid_struct = (struct samldb_msds_intid_persistant*) ldb_get_opaque(ldb, SAMLDB_MSDS_INTID_OPAQUE);\n\tif (!msds_intid_struct) {\n\t\tmsds_intid_struct = talloc(ldb, struct samldb_msds_intid_persistant);\n\t\t/* Generate new value for msDs-IntId\n\t\t* Value should be in 0x80000000..0xBFFFFFFF range */\n\t\tmsds_intid = generate_random() % 0X3FFFFFFF;\n\t\tmsds_intid += 0x80000000;\n\t\tmsds_intid_struct->msds_intid = msds_intid;\n\t\tDEBUG(2, (\"No samldb_msds_intid_persistant struct, allocating a new one\\n\"));\n\t} else {\n\t\tmsds_intid = msds_intid_struct->msds_intid;\n\t}\n\n\t/* probe id values until unique one is found */\n\tdo {\n\t\tmsds_intid++;\n\t\tif (msds_intid > 0xBFFFFFFF) {\n\t\t\tmsds_intid = 0x80000001;\n\t\t}\n\t\t/*\n\t\t * We search in the schema if we have already this\n\t\t * intid (using dsdb_attribute_by_attributeID_id\n\t\t * because in the range 0x80000000 0xBFFFFFFFF,\n\t\t * attributeID is a DSDB_ATTID_TYPE_INTID).\n\t\t *\n\t\t * If so generate another random value.\n\t\t *\n\t\t * We have to check the DB in case someone else has\n\t\t * modified the database while we are doing our\n\t\t * changes too (this case should be very bery rare) in\n\t\t * order to be sure.\n\t\t */\n\t\tif (dsdb_attribute_by_attributeID_id(schema, msds_intid)) {\n\t\t\tid_exists = true;\n\t\t\tmsds_intid = generate_random() % 0X3FFFFFFF;\n\t\t\tmsds_intid += 0x80000000;\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tret = dsdb_module_search(ac->module, ac,\n\t\t\t\t\t &ldb_res,\n\t\t\t\t\t schema_dn, LDB_SCOPE_ONELEVEL, NULL,\n\t\t\t\t\t DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t\t ac->req,\n\t\t\t\t\t \"(msDS-IntId=%d)\", msds_intid);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tldb_debug_set(ldb, LDB_DEBUG_ERROR,\n\t\t\t\t      __location__\": Searching for msDS-IntId=%d failed - %s\\n\",\n\t\t\t\t      msds_intid,\n\t\t\t\t      ldb_errstring(ldb));\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\t\tid_exists = (ldb_res->count > 0);\n\t\ttalloc_free(ldb_res);\n\n\t} while(id_exists);\n\tmsds_intid_struct->msds_intid = msds_intid;\n\tldb_set_opaque(ldb, SAMLDB_MSDS_INTID_OPAQUE, msds_intid_struct);\n\n\treturn samdb_msg_add_int(ldb, ac->msg, ac->msg, \"msDS-IntId\",\n\t\t\t\t msds_intid);\n}\n\n\n/*\n * samldb_add_entry (async)\n */\n\nstatic int samldb_add_entry_callback(struct ldb_request *req,\n\t\t\t\t\tstruct ldb_reply *ares)\n{\n\tstruct ldb_context *ldb;\n\tstruct samldb_ctx *ac;\n\tint ret;\n\n\tac = talloc_get_type(req->context, struct samldb_ctx);\n\tldb = ldb_module_get_ctx(ac->module);\n\n\tif (!ares) {\n\t\treturn ldb_module_done(ac->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\n\tif (ares->type == LDB_REPLY_REFERRAL) {\n\t\treturn ldb_module_send_referral(ac->req, ares->referral);\n\t}\n\n\tif (ares->error != LDB_SUCCESS) {\n\t\treturn ldb_module_done(ac->req, ares->controls,\n\t\t\t\t\tares->response, ares->error);\n\t}\n\tif (ares->type != LDB_REPLY_DONE) {\n\t\tldb_asprintf_errstring(ldb, \"Invalid LDB reply type %d\", ares->type);\n\t\treturn ldb_module_done(ac->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\n\t/* The caller may wish to get controls back from the add */\n\tac->ares = talloc_steal(ac, ares);\n\n\tret = samldb_next_step(ac);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_module_done(ac->req, NULL, NULL, ret);\n\t}\n\treturn ret;\n}\n\nstatic int samldb_add_entry(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb;\n\tstruct ldb_request *req;\n\tint ret;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\n\tret = ldb_build_add_req(&req, ldb, ac,\n\t\t\t\tac->msg,\n\t\t\t\tac->req->controls,\n\t\t\t\tac, samldb_add_entry_callback,\n\t\t\t\tac->req);\n\tLDB_REQ_SET_LOCATION(req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ldb_next_request(ac->module, req);\n}\n\n/*\n * return true if msg carries an attributeSchema that is intended to be RODC\n * filtered but is also a system-critical attribute.\n */\nstatic bool check_rodc_critical_attribute(struct ldb_message *msg)\n{\n\tuint32_t schemaFlagsEx, searchFlags, rodc_filtered_flags;\n\n\tschemaFlagsEx = ldb_msg_find_attr_as_uint(msg, \"schemaFlagsEx\", 0);\n\tsearchFlags = ldb_msg_find_attr_as_uint(msg, \"searchFlags\", 0);\n\trodc_filtered_flags = (SEARCH_FLAG_RODC_ATTRIBUTE\n\t\t\t      | SEARCH_FLAG_CONFIDENTIAL);\n\n\tif ((schemaFlagsEx & SCHEMA_FLAG_ATTR_IS_CRITICAL) &&\n\t\t((searchFlags & rodc_filtered_flags) == rodc_filtered_flags)) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n\nstatic int samldb_fill_object(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\n\t/* Add information for the different account types */\n\tswitch(ac->type) {\n\tcase SAMLDB_TYPE_USER: {\n\t\tstruct ldb_control *rodc_control = ldb_request_get_control(ac->req,\n\t\t\t\t\t\t\t\t\t   LDB_CONTROL_RODC_DCPROMO_OID);\n\t\tif (rodc_control != NULL) {\n\t\t\t/* see [MS-ADTS] 3.1.1.3.4.1.23 LDAP_SERVER_RODC_DCPROMO_OID */\n\t\t\trodc_control->critical = false;\n\t\t\tret = samldb_add_step(ac, samldb_rodc_add);\n\t\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t}\n\n\t\t/* check if we have a valid sAMAccountName */\n\t\tret = samldb_add_step(ac, samldb_check_sAMAccountName);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\tret = samldb_add_step(ac, samldb_add_entry);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\t\tbreak;\n\t}\n\n\tcase SAMLDB_TYPE_GROUP: {\n\t\t/* check if we have a valid sAMAccountName */\n\t\tret = samldb_add_step(ac, samldb_check_sAMAccountName);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\tret = samldb_add_step(ac, samldb_add_entry);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\t\tbreak;\n\t}\n\n\tcase SAMLDB_TYPE_CLASS: {\n\t\tconst char *lDAPDisplayName = NULL;\n\t\tconst struct ldb_val *rdn_value, *def_obj_cat_val;\n\t\tunsigned int v = ldb_msg_find_attr_as_uint(ac->msg, \"objectClassCategory\", -2);\n\n\t\t/* As discussed with Microsoft through dochelp in April 2012 this is the behavior of windows*/\n\t\tif (!ldb_msg_find_element(ac->msg, \"subClassOf\")) {\n\t\t\tret = ldb_msg_add_string(ac->msg, \"subClassOf\", \"top\");\n\t\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t}\n\n\t\tret = samdb_find_or_add_attribute(ldb, ac->msg,\n\t\t\t\t\t\t  \"rdnAttId\", \"cn\");\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\t/* do not allow one to mark an attributeSchema as RODC filtered if it\n\t\t * is system-critical */\n\t\tif (check_rodc_critical_attribute(ac->msg)) {\n\t\t\tldb_asprintf_errstring(ldb, \"Refusing schema add of %s - cannot combine critical class with RODC filtering\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn));\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\n\t\trdn_value = ldb_dn_get_rdn_val(ac->msg->dn);\n\t\tif (rdn_value == NULL) {\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\t\tif (!ldb_msg_find_element(ac->msg, \"lDAPDisplayName\")) {\n\t\t\t/* the RDN has prefix \"CN\" */\n\t\t\tret = ldb_msg_add_string(ac->msg, \"lDAPDisplayName\",\n\t\t\t\tsamdb_cn_to_lDAPDisplayName(ac->msg,\n\t\t\t\t\t\t\t    (const char *) rdn_value->data));\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_oom(ldb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tlDAPDisplayName = ldb_msg_find_attr_as_string(ac->msg,\n\t\t\t\t\t\t\t      \"lDAPDisplayName\",\n\t\t\t\t\t\t\t      NULL);\n\t\tret = ldb_valid_attr_name(lDAPDisplayName);\n\t\tif (ret != 1 ||\n\t\t    lDAPDisplayName[0] == '*' ||\n\t\t    lDAPDisplayName[0] == '@')\n\t\t{\n\t\t\treturn dsdb_module_werror(ac->module,\n\t\t\t\t\t\t  LDB_ERR_UNWILLING_TO_PERFORM,\n\t\t\t\t\t\t  WERR_DS_INVALID_LDAP_DISPLAY_NAME,\n\t\t\t\t\t\t  \"lDAPDisplayName is invalid\");\n\t\t}\n\n\t\tif (!ldb_msg_find_element(ac->msg, \"schemaIDGUID\")) {\n\t\t\tstruct GUID guid;\n\t\t\t/* a new GUID */\n\t\t\tguid = GUID_random();\n\t\t\tret = dsdb_msg_add_guid(ac->msg, &guid, \"schemaIDGUID\");\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_oom(ldb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tdef_obj_cat_val = ldb_msg_find_ldb_val(ac->msg,\n\t\t\t\t\t\t       \"defaultObjectCategory\");\n\t\tif (def_obj_cat_val != NULL) {\n\t\t\t/* \"defaultObjectCategory\" has been set by the caller.\n\t\t\t * Do some checks for consistency.\n\t\t\t * NOTE: The real constraint check (that\n\t\t\t * 'defaultObjectCategory' is the DN of the new\n\t\t\t * objectclass or any parent of it) is still incomplete.\n\t\t\t * For now we say that 'defaultObjectCategory' is valid\n\t\t\t * if it exists and it is of objectclass \"classSchema\".\n\t\t\t */\n\t\t\tac->dn = ldb_dn_from_ldb_val(ac, ldb, def_obj_cat_val);\n\t\t\tif (ac->dn == NULL) {\n\t\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t\t  \"Invalid DN for 'defaultObjectCategory'!\");\n\t\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t\t}\n\t\t} else {\n\t\t\t/* \"defaultObjectCategory\" has not been set by the\n\t\t\t * caller. Use the entry DN for it. */\n\t\t\tac->dn = ac->msg->dn;\n\n\t\t\tret = ldb_msg_add_string(ac->msg, \"defaultObjectCategory\",\n\t\t\t\t\t\t ldb_dn_alloc_linearized(ac->msg, ac->dn));\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_oom(ldb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = samldb_add_step(ac, samldb_add_entry);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\t/* Now perform the checks for the 'defaultObjectCategory'. The\n\t\t * lookup DN was already saved in \"ac->dn\" */\n\t\tret = samldb_add_step(ac, samldb_find_for_defaultObjectCategory);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\t/* -2 is not a valid objectClassCategory so it means the attribute wasn't present */\n\t\tif (v == -2) {\n\t\t\t/* Windows 2003 does this*/\n\t\t\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg, \"objectClassCategory\", 0);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase SAMLDB_TYPE_ATTRIBUTE: {\n\t\tconst char *lDAPDisplayName = NULL;\n\t\tconst struct ldb_val *rdn_value;\n\t\tstruct ldb_message_element *el;\n\t\trdn_value = ldb_dn_get_rdn_val(ac->msg->dn);\n\t\tif (rdn_value == NULL) {\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\t\tif (!ldb_msg_find_element(ac->msg, \"lDAPDisplayName\")) {\n\t\t\t/* the RDN has prefix \"CN\" */\n\t\t\tret = ldb_msg_add_string(ac->msg, \"lDAPDisplayName\",\n\t\t\t\tsamdb_cn_to_lDAPDisplayName(ac->msg,\n\t\t\t\t\t\t\t    (const char *) rdn_value->data));\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_oom(ldb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tlDAPDisplayName = ldb_msg_find_attr_as_string(ac->msg,\n\t\t\t\t\t\t\t      \"lDAPDisplayName\",\n\t\t\t\t\t\t\t      NULL);\n\t\tret = ldb_valid_attr_name(lDAPDisplayName);\n\t\tif (ret != 1 ||\n\t\t    lDAPDisplayName[0] == '*' ||\n\t\t    lDAPDisplayName[0] == '@')\n\t\t{\n\t\t\treturn dsdb_module_werror(ac->module,\n\t\t\t\t\t\t  LDB_ERR_UNWILLING_TO_PERFORM,\n\t\t\t\t\t\t  WERR_DS_INVALID_LDAP_DISPLAY_NAME,\n\t\t\t\t\t\t  \"lDAPDisplayName is invalid\");\n\t\t}\n\n\t\t/* do not allow one to mark an attributeSchema as RODC filtered if it\n\t\t * is system-critical */\n\t\tif (check_rodc_critical_attribute(ac->msg)) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"samldb: refusing schema add of %s - cannot combine critical attribute with RODC filtering\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn));\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\n\t\tret = samdb_find_or_add_attribute(ldb, ac->msg,\n\t\t\t\t\t\t  \"isSingleValued\", \"FALSE\");\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\tif (!ldb_msg_find_element(ac->msg, \"schemaIDGUID\")) {\n\t\t\tstruct GUID guid;\n\t\t\t/* a new GUID */\n\t\t\tguid = GUID_random();\n\t\t\tret = dsdb_msg_add_guid(ac->msg, &guid, \"schemaIDGUID\");\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_oom(ldb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tel = ldb_msg_find_element(ac->msg, \"attributeSyntax\");\n\t\tif (el) {\n\t\t\t/*\n\t\t\t * No need to scream if there isn't as we have code later on\n\t\t\t * that will take care of it.\n\t\t\t */\n\t\t\tconst struct dsdb_syntax *syntax = find_syntax_map_by_ad_oid((const char *)el->values[0].data);\n\t\t\tif (!syntax) {\n\t\t\t\tDEBUG(9, (\"Can't find dsdb_syntax object for attributeSyntax %s\\n\",\n\t\t\t\t\t\t(const char *)el->values[0].data));\n\t\t\t} else {\n\t\t\t\tunsigned int v = ldb_msg_find_attr_as_uint(ac->msg, \"oMSyntax\", 0);\n\t\t\t\tconst struct ldb_val *val = ldb_msg_find_ldb_val(ac->msg, \"oMObjectClass\");\n\n\t\t\t\tif (v == 0) {\n\t\t\t\t\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg, \"oMSyntax\", syntax->oMSyntax);\n\t\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!val) {\n\t\t\t\t\tstruct ldb_val val2 = ldb_val_dup(ldb, &syntax->oMObjectClass);\n\t\t\t\t\tif (val2.length > 0) {\n\t\t\t\t\t\tret = ldb_msg_add_value(ac->msg, \"oMObjectClass\", &val2, NULL);\n\t\t\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* handle msDS-IntID attribute */\n\t\tret = samldb_add_handle_msDS_IntId(ac);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\tret = samldb_add_step(ac, samldb_add_entry);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tldb_asprintf_errstring(ldb, \"Invalid entry type!\");\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t\tbreak;\n\t}\n\n\treturn samldb_first_step(ac);\n}\n\nstatic int samldb_fill_foreignSecurityPrincipal_object(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = NULL;\n\tconst struct ldb_val *rdn_value = NULL;\n\tstruct ldb_message_element *sid_el = NULL;\n\tstruct dom_sid *sid = NULL;\n\tstruct ldb_control *as_system = NULL;\n\tstruct ldb_control *provision = NULL;\n\tbool allowed = false;\n\tint ret;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\n\tas_system = ldb_request_get_control(ac->req, LDB_CONTROL_AS_SYSTEM_OID);\n\tif (as_system != NULL) {\n\t\tallowed = true;\n\t}\n\n\tprovision = ldb_request_get_control(ac->req, LDB_CONTROL_PROVISION_OID);\n\tif (provision != NULL) {\n\t\tallowed = true;\n\t}\n\n\tsid_el = ldb_msg_find_element(ac->msg, \"objectSid\");\n\n\tif (!allowed && sid_el == NULL) {\n\t\treturn dsdb_module_werror(ac->module,\n\t\t\t\tLDB_ERR_OBJECT_CLASS_VIOLATION,\n\t\t\t\tWERR_DS_MISSING_REQUIRED_ATT,\n\t\t\t\t\"objectSid missing on foreignSecurityPrincipal\");\n\t}\n\n\tif (!allowed) {\n\t\treturn dsdb_module_werror(ac->module,\n\t\t\t\tLDB_ERR_UNWILLING_TO_PERFORM,\n\t\t\t\tWERR_DS_ILLEGAL_MOD_OPERATION,\n\t\t\t\t\"foreignSecurityPrincipal object not allowed\");\n\t}\n\n\tif (sid_el != NULL) {\n\t\tsid = samdb_result_dom_sid(ac->msg, ac->msg, \"objectSid\");\n\t\tif (sid == NULL) {\n\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t  \"samldb: invalid objectSid!\");\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t}\n\n\tif (sid == NULL) {\n\t\trdn_value = ldb_dn_get_rdn_val(ac->msg->dn);\n\t\tif (rdn_value == NULL) {\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\t\tsid = dom_sid_parse_talloc(ac->msg,\n\t\t\t\t\t   (const char *)rdn_value->data);\n\t\tif (sid == NULL) {\n\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t  \"samldb: No valid SID found in ForeignSecurityPrincipal CN!\");\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t\tif (! samldb_msg_add_sid(ac->msg, \"objectSid\", sid)) {\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\t}\n\n\t/* finally proceed with adding the entry */\n\tret = samldb_add_step(ac, samldb_add_entry);\n\tif (ret != LDB_SUCCESS) return ret;\n\n\treturn samldb_first_step(ac);\n}\n\nstatic int samldb_schema_info_update(struct samldb_ctx *ac)\n{\n\tint ret;\n\tstruct ldb_context *ldb;\n\tstruct dsdb_schema *schema;\n\n\t/* replicated update should always go through */\n\tif (ldb_request_get_control(ac->req,\n\t\t\t\t    DSDB_CONTROL_REPLICATED_UPDATE_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* do not update schemaInfo during provisioning */\n\tif (ldb_request_get_control(ac->req, LDB_CONTROL_PROVISION_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tldb = ldb_module_get_ctx(ac->module);\n\tschema = dsdb_get_schema(ldb, NULL);\n\tif (!schema) {\n\t\tldb_debug_set(ldb, LDB_DEBUG_FATAL,\n\t\t\t      \"samldb_schema_info_update: no dsdb_schema loaded\");\n\t\tDEBUG(0,(__location__ \": %s\\n\", ldb_errstring(ldb)));\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = dsdb_module_schema_info_update(ac->module, schema,\n\t\t\t\t\t     DSDB_FLAG_NEXT_MODULE|\n\t\t\t\t\t     DSDB_FLAG_AS_SYSTEM,\n\t\t\t\t\t     ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"samldb_schema_info_update: dsdb_module_schema_info_update failed with %s\",\n\t\t\t\t       ldb_errstring(ldb));\n\t\treturn ret;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_prim_group_tester(struct samldb_ctx *ac, uint32_t rid);\nstatic int samldb_check_user_account_control_rules(struct samldb_ctx *ac,\n\t\t\t\t\t\t   struct dom_sid *sid,\n\t\t\t\t\t\t   uint32_t req_uac,\n\t\t\t\t\t\t   uint32_t user_account_control,\n\t\t\t\t\t\t   uint32_t user_account_control_old,\n\t\t\t\t\t\t   bool is_computer_objectclass);\n\n/*\n * \"Objectclass\" trigger (MS-SAMR 3.1.1.8.1)\n *\n * Has to be invoked on \"add\" operations on \"user\", \"computer\" and\n * \"group\" objects.\n * ac->msg contains the \"add\"\n * ac->type contains the object type (main objectclass)\n */\nstatic int samldb_objectclass_trigger(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tvoid *skip_allocate_sids = ldb_get_opaque(ldb,\n\t\t\t\t\t\t  \"skip_allocate_sids\");\n\tstruct ldb_message_element *el, *el2;\n\tstruct dom_sid *sid;\n\tint ret;\n\n\t/* make sure that \"sAMAccountType\" is not specified */\n\tel = ldb_msg_find_element(ac->msg, \"sAMAccountType\");\n\tif (el != NULL) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb: sAMAccountType must not be specified!\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t/* Step 1: objectSid assignment */\n\n\t/* Don't allow the objectSid to be changed. But beside the RELAX\n\t * control we have also to guarantee that it can always be set with\n\t * SYSTEM permissions. This is needed for the \"samba3sam\" backend. */\n\tsid = samdb_result_dom_sid(ac, ac->msg, \"objectSid\");\n\tif ((sid != NULL) && (!dsdb_module_am_system(ac->module)) &&\n\t    (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID) == NULL)) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb: objectSid must not be specified!\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t/* but generate a new SID when we do have an add operations */\n\tif ((sid == NULL) && (ac->req->operation == LDB_ADD) && !skip_allocate_sids) {\n\t\tret = samldb_add_step(ac, samldb_allocate_sid);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\t}\n\n\tswitch(ac->type) {\n\tcase SAMLDB_TYPE_USER: {\n\t\tuint32_t raw_uac;\n\t\tuint32_t user_account_control;\n\t\tbool is_computer_objectclass;\n\t\tbool uac_generated = false, uac_add_flags = false;\n\t\tuint32_t default_user_account_control = UF_NORMAL_ACCOUNT;\n\t\t/* Step 1.2: Default values */\n\t\tret = dsdb_user_obj_set_defaults(ldb, ac->msg, ac->req);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\tis_computer_objectclass\n\t\t\t= (samdb_find_attribute(ldb,\n\t\t\t\t\t\t ac->msg,\n\t\t\t\t\t\t\"objectclass\",\n\t\t\t\t\t\t\"computer\")\n\t\t\t   != NULL);\n\n\t\tif (is_computer_objectclass) {\n\t\t\tdefault_user_account_control\n\t\t\t\t= UF_WORKSTATION_TRUST_ACCOUNT;\n\t\t}\n\n\n\t\t/* On add operations we might need to generate a\n\t\t * \"userAccountControl\" (if it isn't specified). */\n\t\tel = ldb_msg_find_element(ac->msg, \"userAccountControl\");\n\t\tif (el == NULL) {\n\t\t\tret = samdb_msg_set_uint(ldb, ac->msg, ac->msg,\n\t\t\t\t\t\t \"userAccountControl\",\n\t\t\t\t\t\t default_user_account_control);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tuac_generated = true;\n\t\t\tuac_add_flags = true;\n\t\t}\n\n\t\tel = ldb_msg_find_element(ac->msg, \"userAccountControl\");\n\t\tSMB_ASSERT(el != NULL);\n\n\t\t/* Step 1.3: \"userAccountControl\" -> \"sAMAccountType\" mapping */\n\t\tuser_account_control = ldb_msg_find_attr_as_uint(ac->msg,\n\t\t\t\t\t\t\t\t \"userAccountControl\",\n\t\t\t\t\t\t\t\t 0);\n\t\traw_uac = user_account_control;\n\t\t/*\n\t\t * \"userAccountControl\" = 0 or missing one of\n\t\t * the types means \"UF_NORMAL_ACCOUNT\"\n\t\t * or \"UF_WORKSTATION_TRUST_ACCOUNT\" (if a computer).\n\t\t * See MS-SAMR 3.1.1.8.10 point 8\n\t\t */\n\t\tif ((user_account_control & UF_ACCOUNT_TYPE_MASK) == 0) {\n\t\t\tuser_account_control\n\t\t\t\t= default_user_account_control\n\t\t\t\t| user_account_control;\n\t\t\tuac_generated = true;\n\t\t}\n\n\t\t/*\n\t\t * As per MS-SAMR 3.1.1.8.10 these flags have not to be set\n\t\t */\n\t\tif ((user_account_control & UF_LOCKOUT) != 0) {\n\t\t\tuser_account_control &= ~UF_LOCKOUT;\n\t\t\tuac_generated = true;\n\t\t}\n\t\tif ((user_account_control & UF_PASSWORD_EXPIRED) != 0) {\n\t\t\tuser_account_control &= ~UF_PASSWORD_EXPIRED;\n\t\t\tuac_generated = true;\n\t\t}\n\n\t\tret = samldb_check_user_account_control_rules(ac, NULL,\n\t\t\t\t\t\t\t      raw_uac,\n\t\t\t\t\t\t\t      user_account_control,\n\t\t\t\t\t\t\t      0,\n\t\t\t\t\t\t\t      is_computer_objectclass);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\t/*\n\t\t * Require, for non-admin modifications, a trailing $\n\t\t * for either objectclass=computer or a trust account\n\t\t * type in userAccountControl\n\t\t */\n\t\tif ((user_account_control\n\t\t     & UF_TRUST_ACCOUNT_MASK) != 0) {\n\t\t\tac->need_trailing_dollar = true;\n\t\t}\n\n\t\tif (is_computer_objectclass) {\n\t\t\tac->need_trailing_dollar = true;\n\t\t}\n\n\t\t/* add \"sAMAccountType\" attribute */\n\t\tret = dsdb_user_obj_set_account_type(ldb, ac->msg, user_account_control, NULL);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* \"isCriticalSystemObject\" might be set */\n\t\tif (user_account_control &\n\t\t    (UF_SERVER_TRUST_ACCOUNT | UF_PARTIAL_SECRETS_ACCOUNT)) {\n\t\t\tret = ldb_msg_add_string(ac->msg, \"isCriticalSystemObject\",\n\t\t\t\t\t\t \"TRUE\");\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tel2 = ldb_msg_find_element(ac->msg,\n\t\t\t\t\t\t   \"isCriticalSystemObject\");\n\t\t\tel2->flags = LDB_FLAG_MOD_REPLACE;\n\t\t} else if (user_account_control & UF_WORKSTATION_TRUST_ACCOUNT) {\n\t\t\tret = ldb_msg_add_string(ac->msg, \"isCriticalSystemObject\",\n\t\t\t\t\t\t \"FALSE\");\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tel2 = ldb_msg_find_element(ac->msg,\n\t\t\t\t\t\t   \"isCriticalSystemObject\");\n\t\t\tel2->flags = LDB_FLAG_MOD_REPLACE;\n\t\t}\n\n\t\t/* Step 1.4: \"userAccountControl\" -> \"primaryGroupID\" mapping */\n\t\tif (!ldb_msg_find_element(ac->msg, \"primaryGroupID\")) {\n\t\t\tuint32_t rid;\n\n\t\t\tret = dsdb_user_obj_set_primary_group_id(ldb, ac->msg, user_account_control, &rid);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Older AD deployments don't know about the\n\t\t\t * RODC group\n\t\t\t */\n\t\t\tif (rid == DOMAIN_RID_READONLY_DCS) {\n\t\t\t\tret = samldb_prim_group_tester(ac, rid);\n\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Step 1.5: Add additional flags when needed */\n\t\t/* Obviously this is done when the \"userAccountControl\"\n\t\t * has been generated here (tested against Windows\n\t\t * Server) */\n\t\tif (uac_generated) {\n\t\t\tif (uac_add_flags) {\n\t\t\t\tuser_account_control |= UF_ACCOUNTDISABLE;\n\t\t\t\tuser_account_control |= UF_PASSWD_NOTREQD;\n\t\t\t}\n\n\t\t\tret = samdb_msg_set_uint(ldb, ac->msg, ac->msg,\n\t\t\t\t\t\t \"userAccountControl\",\n\t\t\t\t\t\t user_account_control);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase SAMLDB_TYPE_GROUP: {\n\t\tconst char *tempstr;\n\n\t\t/* Step 2.2: Default values */\n\t\ttempstr = talloc_asprintf(ac->msg, \"%d\",\n\t\t\t\t\t  GTYPE_SECURITY_GLOBAL_GROUP);\n\t\tif (tempstr == NULL) return ldb_operr(ldb);\n\t\tret = samdb_find_or_add_attribute(ldb, ac->msg,\n\t\t\t\"groupType\", tempstr);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\t/* Step 2.3: \"groupType\" -> \"sAMAccountType\" */\n\t\tel = ldb_msg_find_element(ac->msg, \"groupType\");\n\t\tif (el != NULL) {\n\t\t\tuint32_t group_type, account_type;\n\n\t\t\tgroup_type = ldb_msg_find_attr_as_uint(ac->msg,\n\t\t\t\t\t\t\t       \"groupType\", 0);\n\n\t\t\t/* The creation of builtin groups requires the\n\t\t\t * RELAX control */\n\t\t\tif (group_type == GTYPE_SECURITY_BUILTIN_LOCAL_GROUP) {\n\t\t\t\tif (ldb_request_get_control(ac->req,\n\t\t\t\t\t\t\t    LDB_CONTROL_RELAX_OID) == NULL) {\n\t\t\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\taccount_type = ds_gtype2atype(group_type);\n\t\t\tif (account_type == 0) {\n\t\t\t\tldb_set_errstring(ldb, \"samldb: Unrecognized account type!\");\n\t\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t\t}\n\t\t\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg,\n\t\t\t\t\t\t \"sAMAccountType\",\n\t\t\t\t\t\t account_type);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tel2 = ldb_msg_find_element(ac->msg, \"sAMAccountType\");\n\t\t\tel2->flags = LDB_FLAG_MOD_REPLACE;\n\t\t}\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\"Invalid entry type!\");\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t\tbreak;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n\n/*\n * \"Primary group ID\" trigger (MS-SAMR 3.1.1.8.2)\n *\n * Has to be invoked on \"add\" and \"modify\" operations on \"user\" and \"computer\"\n * objects.\n * ac->msg contains the \"add\"/\"modify\" message\n */\n\nstatic int samldb_prim_group_tester(struct samldb_ctx *ac, uint32_t rid)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tstruct dom_sid *sid;\n\tstruct ldb_result *res;\n\tint ret;\n\tconst char * const noattrs[] = { NULL };\n\n\tsid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), rid);\n\tif (sid == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = dsdb_module_search(ac->module, ac, &res,\n\t\t\t\t ldb_get_default_basedn(ldb),\n\t\t\t\t LDB_SCOPE_SUBTREE,\n\t\t\t\t noattrs, DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(objectSid=%s)\",\n\t\t\t\t ldap_encode_ndr_dom_sid(ac, sid));\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (res->count != 1) {\n\t\ttalloc_free(res);\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"Failed to find primary group with RID %u!\",\n\t\t\t\t       rid);\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\ttalloc_free(res);\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_prim_group_set(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tuint32_t rid;\n\n\trid = ldb_msg_find_attr_as_uint(ac->msg, \"primaryGroupID\", (uint32_t) -1);\n\tif (rid == (uint32_t) -1) {\n\t\t/* we aren't affected of any primary group set */\n\t\treturn LDB_SUCCESS;\n\n\t} else if (!ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"The primary group isn't settable on add operations!\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\treturn samldb_prim_group_tester(ac, rid);\n}\n\nstatic int samldb_prim_group_change(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tconst char * const attrs[] = {\n\t\t\"primaryGroupID\",\n\t\t\"memberOf\",\n\t\t\"userAccountControl\",\n\t\tNULL };\n\tstruct ldb_result *res, *group_res;\n\tstruct ldb_message_element *el;\n\tstruct ldb_message *msg;\n\tuint32_t search_flags =\n\t\tDSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_EXTENDED_DN;\n\tuint32_t prev_rid, new_rid, uac;\n\tstruct dom_sid *prev_sid, *new_sid;\n\tstruct ldb_dn *prev_prim_group_dn, *new_prim_group_dn;\n\tconst char *new_prim_group_dn_ext_str = NULL;\n\tstruct ldb_dn *user_dn = NULL;\n\tconst char *user_dn_ext_str = NULL;\n\tint ret;\n\tconst char * const noattrs[] = { NULL };\n\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"primaryGroupID\",\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (el == NULL) {\n\t\t/* we are not affected */\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* Fetch information from the existing object */\n\n\tret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn, attrs,\n\t\t\t\t    search_flags, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tuser_dn = res->msgs[0]->dn;\n\tuser_dn_ext_str = ldb_dn_get_extended_linearized(ac, user_dn, 1);\n\tif (user_dn_ext_str == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tuac = ldb_msg_find_attr_as_uint(res->msgs[0], \"userAccountControl\", 0);\n\n\t/* Finds out the DN of the old primary group */\n\n\tprev_rid = ldb_msg_find_attr_as_uint(res->msgs[0], \"primaryGroupID\",\n\t\t\t\t\t     (uint32_t) -1);\n\tif (prev_rid == (uint32_t) -1) {\n\t\t/* User objects do always have a mandatory \"primaryGroupID\"\n\t\t * attribute. If this doesn't exist then the object is of the\n\t\t * wrong type. This is the exact Windows error code */\n\t\treturn LDB_ERR_OBJECT_CLASS_VIOLATION;\n\t}\n\n\tprev_sid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), prev_rid);\n\tif (prev_sid == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\t/* Finds out the DN of the new primary group\n\t * Notice: in order to parse the primary group ID correctly we create\n\t * a temporary message here. */\n\n\tmsg = ldb_msg_new(ac->msg);\n\tif (msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tret = ldb_msg_add(msg, el, 0);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tnew_rid = ldb_msg_find_attr_as_uint(msg, \"primaryGroupID\", (uint32_t) -1);\n\ttalloc_free(msg);\n\tif (new_rid == (uint32_t) -1) {\n\t\t/* we aren't affected of any primary group change */\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tif (prev_rid == new_rid) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tif ((uac & UF_SERVER_TRUST_ACCOUNT) && new_rid != DOMAIN_RID_DCS) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\"%08X: samldb: UF_SERVER_TRUST_ACCOUNT requires \"\n\t\t\t\"primaryGroupID=%u!\",\n\t\t\tW_ERROR_V(WERR_DS_CANT_MOD_PRIMARYGROUPID),\n\t\t\tDOMAIN_RID_DCS);\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\tif ((uac & UF_PARTIAL_SECRETS_ACCOUNT) && new_rid != DOMAIN_RID_READONLY_DCS) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\"%08X: samldb: UF_PARTIAL_SECRETS_ACCOUNT requires \"\n\t\t\t\"primaryGroupID=%u!\",\n\t\t\tW_ERROR_V(WERR_DS_CANT_MOD_PRIMARYGROUPID),\n\t\t\tDOMAIN_RID_READONLY_DCS);\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\tret = dsdb_module_search(ac->module, ac, &group_res,\n\t\t\t\t ldb_get_default_basedn(ldb),\n\t\t\t\t LDB_SCOPE_SUBTREE,\n\t\t\t\t noattrs, search_flags,\n\t\t\t\t ac->req,\n\t\t\t\t \"(objectSid=%s)\",\n\t\t\t\t ldap_encode_ndr_dom_sid(ac, prev_sid));\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (group_res->count != 1) {\n\t\treturn ldb_operr(ldb);\n\t}\n\tprev_prim_group_dn = group_res->msgs[0]->dn;\n\n\tnew_sid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), new_rid);\n\tif (new_sid == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = dsdb_module_search(ac->module, ac, &group_res,\n\t\t\t\t ldb_get_default_basedn(ldb),\n\t\t\t\t LDB_SCOPE_SUBTREE,\n\t\t\t\t noattrs, search_flags,\n\t\t\t\t ac->req,\n\t\t\t\t \"(objectSid=%s)\",\n\t\t\t\t ldap_encode_ndr_dom_sid(ac, new_sid));\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (group_res->count != 1) {\n\t\t/* Here we know if the specified new primary group candidate is\n\t\t * valid or not. */\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\tnew_prim_group_dn = group_res->msgs[0]->dn;\n\tnew_prim_group_dn_ext_str = ldb_dn_get_extended_linearized(ac,\n\t\t\t\t\t\t\tnew_prim_group_dn, 1);\n\tif (new_prim_group_dn_ext_str == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\t/* We need to be already a normal member of the new primary\n\t * group in order to be successful. */\n\tel = samdb_find_attribute(ldb, res->msgs[0], \"memberOf\",\n\t\t\t\t  new_prim_group_dn_ext_str);\n\tif (el == NULL) {\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t/* Remove the \"member\" attribute on the new primary group */\n\tmsg = ldb_msg_new(ac->msg);\n\tif (msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tmsg->dn = new_prim_group_dn;\n\n\tret = samdb_msg_add_delval(ldb, msg, msg, \"member\", user_dn_ext_str);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = dsdb_module_modify(ac->module, msg, DSDB_FLAG_NEXT_MODULE, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\ttalloc_free(msg);\n\n\t/* Add a \"member\" attribute for the previous primary group */\n\tmsg = ldb_msg_new(ac->msg);\n\tif (msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tmsg->dn = prev_prim_group_dn;\n\n\tret = samdb_msg_add_addval(ldb, msg, msg, \"member\", user_dn_ext_str);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = dsdb_module_modify(ac->module, msg, DSDB_FLAG_NEXT_MODULE, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\ttalloc_free(msg);\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_prim_group_trigger(struct samldb_ctx *ac)\n{\n\tint ret;\n\n\tif (ac->req->operation == LDB_ADD) {\n\t\tret = samldb_prim_group_set(ac);\n\t} else {\n\t\tret = samldb_prim_group_change(ac);\n\t}\n\n\treturn ret;\n}\n\nstatic int samldb_check_user_account_control_invariants(struct samldb_ctx *ac,\n\t\t\t\t\t\t    uint32_t user_account_control)\n{\n\tsize_t i;\n\tint ret = 0;\n\tbool need_check = false;\n\tconst struct uac_to_guid {\n\t\tuint32_t uac;\n\t\tbool never;\n\t\tuint32_t needs;\n\t\tuint32_t not_with;\n\t\tconst char *error_string;\n\t} map[] = {\n\t\t{\n\t\t\t.uac = UF_TEMP_DUPLICATE_ACCOUNT,\n\t\t\t.never = true,\n\t\t\t.error_string = \"Updating the UF_TEMP_DUPLICATE_ACCOUNT flag is never allowed\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_PARTIAL_SECRETS_ACCOUNT,\n\t\t\t.needs = UF_WORKSTATION_TRUST_ACCOUNT,\n\t\t\t.error_string = \"Setting UF_PARTIAL_SECRETS_ACCOUNT only permitted with UF_WORKSTATION_TRUST_ACCOUNT\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_TRUSTED_FOR_DELEGATION,\n\t\t\t.not_with = UF_PARTIAL_SECRETS_ACCOUNT,\n\t\t\t.error_string = \"Setting UF_TRUSTED_FOR_DELEGATION not allowed with UF_PARTIAL_SECRETS_ACCOUNT\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_NORMAL_ACCOUNT,\n\t\t\t.not_with = UF_ACCOUNT_TYPE_MASK & ~UF_NORMAL_ACCOUNT,\n\t\t\t.error_string = \"Setting more than one account type not permitted\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_WORKSTATION_TRUST_ACCOUNT,\n\t\t\t.not_with = UF_ACCOUNT_TYPE_MASK & ~UF_WORKSTATION_TRUST_ACCOUNT,\n\t\t\t.error_string = \"Setting more than one account type not permitted\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_INTERDOMAIN_TRUST_ACCOUNT,\n\t\t\t.not_with = UF_ACCOUNT_TYPE_MASK & ~UF_INTERDOMAIN_TRUST_ACCOUNT,\n\t\t\t.error_string = \"Setting more than one account type not permitted\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_SERVER_TRUST_ACCOUNT,\n\t\t\t.not_with = UF_ACCOUNT_TYPE_MASK & ~UF_SERVER_TRUST_ACCOUNT,\n\t\t\t.error_string = \"Setting more than one account type not permitted\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_TRUSTED_FOR_DELEGATION,\n\t\t\t.not_with = UF_PARTIAL_SECRETS_ACCOUNT,\n\t\t\t.error_string = \"Setting UF_TRUSTED_FOR_DELEGATION not allowed with UF_PARTIAL_SECRETS_ACCOUNT\"\n\t\t}\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(map); i++) {\n\t\tif (user_account_control & map[i].uac) {\n\t\t\tneed_check = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (need_check == false) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(map); i++) {\n\t\tuint32_t this_uac = user_account_control & map[i].uac;\n\t\tif (this_uac != 0) {\n\t\t\tif (map[i].never) {\n\t\t\t\tret = LDB_ERR_OTHER;\n\t\t\t\tbreak;\n\t\t\t} else if (map[i].needs != 0) {\n\t\t\t\tif ((map[i].needs & user_account_control) == 0) {\n\t\t\t\t\tret = LDB_ERR_OTHER;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (map[i].not_with != 0) {\n\t\t\t\tif ((map[i].not_with & user_account_control) != 0) {\n\t\t\t\t\tret = LDB_ERR_OTHER;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (ret != LDB_SUCCESS) {\n\t\tswitch (ac->req->operation) {\n\t\tcase LDB_ADD:\n\t\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t\t       \"Failed to add %s: %s\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn),\n\t\t\t\t\t       map[i].error_string);\n\t\t\tbreak;\n\t\tcase LDB_MODIFY:\n\t\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t\t       \"Failed to modify %s: %s\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn),\n\t\t\t\t\t       map[i].error_string);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn ldb_module_operr(ac->module);\n\t\t}\n\t}\n\treturn ret;\n}\n\n/*\n * It would be best if these rules apply, always, but for now they\n * apply only to non-admins\n */\nstatic int samldb_check_user_account_control_objectclass_invariants(\n\tstruct samldb_ctx *ac,\n\tuint32_t user_account_control,\n\tuint32_t user_account_control_old,\n\tbool is_computer_objectclass)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\n\tuint32_t old_ufa = user_account_control_old & UF_ACCOUNT_TYPE_MASK;\n\tuint32_t new_ufa = user_account_control & UF_ACCOUNT_TYPE_MASK;\n\n\tuint32_t old_rodc = user_account_control_old & UF_PARTIAL_SECRETS_ACCOUNT;\n\tuint32_t new_rodc = user_account_control & UF_PARTIAL_SECRETS_ACCOUNT;\n\n\tbool is_admin;\n\tstruct security_token *user_token\n\t\t= acl_user_token(ac->module);\n\tif (user_token == NULL) {\n\t\treturn LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n\t}\n\n\tis_admin\n\t\t= security_token_has_builtin_administrators(user_token);\n\n\n\t/*\n\t * We want to allow changes to (eg) disable an account\n\t * that was created wrong, only checking the\n\t * objectclass if the account type changes.\n\t */\n\tif (old_ufa == new_ufa && old_rodc == new_rodc) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tswitch (new_ufa) {\n\tcase UF_NORMAL_ACCOUNT:\n\t\tif (is_computer_objectclass && !is_admin) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\"%08X: samldb: UF_NORMAL_ACCOUNT \"\n\t\t\t\t\"requires objectclass 'user' not 'computer'!\",\n\t\t\t\tW_ERROR_V(WERR_DS_MACHINE_ACCOUNT_CREATED_PRENT4));\n\t\t\treturn LDB_ERR_OBJECT_CLASS_VIOLATION;\n\t\t}\n\t\tbreak;\n\n\tcase UF_INTERDOMAIN_TRUST_ACCOUNT:\n\t\tif (is_computer_objectclass) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\"%08X: samldb: UF_INTERDOMAIN_TRUST_ACCOUNT \"\n\t\t\t\t\"requires objectclass 'user' not 'computer'!\",\n\t\t\t\tW_ERROR_V(WERR_DS_MACHINE_ACCOUNT_CREATED_PRENT4));\n\t\t\treturn LDB_ERR_OBJECT_CLASS_VIOLATION;\n\t\t}\n\t\tbreak;\n\n\tcase UF_WORKSTATION_TRUST_ACCOUNT:\n\t\tif (!is_computer_objectclass) {\n\t\t\t/*\n\t\t\t * Modify of a user account account into a\n\t\t\t * workstation without objectclass computer\n\t\t\t * as an admin is still permitted, but not\n\t\t\t * to make an RODC\n\t\t\t */\n\t\t\tif (is_admin\n\t\t\t    && ac->req->operation == LDB_MODIFY\n\t\t\t    && new_rodc == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\"%08X: samldb: UF_WORKSTATION_TRUST_ACCOUNT \"\n\t\t\t\t\"requires objectclass 'computer'!\",\n\t\t\t\tW_ERROR_V(WERR_DS_MACHINE_ACCOUNT_CREATED_PRENT4));\n\t\t\treturn LDB_ERR_OBJECT_CLASS_VIOLATION;\n\t\t}\n\t\tbreak;\n\n\tcase UF_SERVER_TRUST_ACCOUNT:\n\t\tif (!is_computer_objectclass) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\"%08X: samldb: UF_SERVER_TRUST_ACCOUNT \"\n\t\t\t\t\"requires objectclass 'computer'!\",\n\t\t\t\tW_ERROR_V(WERR_DS_MACHINE_ACCOUNT_CREATED_PRENT4));\n\t\t\treturn LDB_ERR_OBJECT_CLASS_VIOLATION;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\"%08X: samldb: invalid userAccountControl[0x%08X]\",\n\t\t\tW_ERROR_V(WERR_INVALID_PARAMETER),\n\t\t\t\t       user_account_control);\n\t\treturn LDB_ERR_OTHER;\n\t}\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_get_domain_secdesc_and_oc(struct samldb_ctx *ac,\n\t\t\t\t\t    struct security_descriptor **domain_sd,\n\t\t\t\t\t    const struct dsdb_class **objectclass)\n{\n\tconst char * const sd_attrs[] = {\"ntSecurityDescriptor\", \"objectClass\", NULL};\n\tstruct ldb_result *res;\n\tstruct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));\n\tconst struct dsdb_schema *schema = NULL;\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret = dsdb_module_search_dn(ac->module, ac, &res,\n\t\t\t\t\tdomain_dn,\n\t\t\t\t\tsd_attrs,\n\t\t\t\t\tDSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED,\n\t\t\t\t\tac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (res->count != 1) {\n\t\treturn ldb_module_operr(ac->module);\n\t}\n\n\tschema = dsdb_get_schema(ldb, ac->req);\n\tif (!schema) {\n\t\treturn ldb_module_operr(ac->module);;\n\t}\n\t*objectclass = dsdb_get_structural_oc_from_msg(schema, res->msgs[0]);\n\treturn dsdb_get_sd_from_ldb_message(ldb_module_get_ctx(ac->module),\n\t\t\t\t\t    ac, res->msgs[0], domain_sd);\n\n}\n\n/**\n * Validate that the restriction in point 5 of MS-SAMR 3.1.1.8.10 userAccountControl is honoured\n *\n */\nstatic int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n\t\t\t\t\t\t struct dom_sid *sid,\n\t\t\t\t\t\t uint32_t user_account_control,\n\t\t\t\t\t\t uint32_t user_account_control_old)\n{\n\tsize_t i;\n\tint ret = 0;\n\tbool need_acl_check = false;\n\tstruct security_token *user_token;\n\tstruct security_descriptor *domain_sd;\n\tconst struct dsdb_class *objectclass = NULL;\n\tconst struct uac_to_guid {\n\t\tuint32_t uac;\n\t\tuint32_t priv_to_change_from;\n\t\tconst char *oid;\n\t\tconst char *guid;\n\t\tenum sec_privilege privilege;\n\t\tbool delete_is_privileged;\n\t\tbool admin_required;\n\t\tconst char *error_string;\n\t} map[] = {\n\t\t{\n\t\t\t.uac = UF_PASSWD_NOTREQD,\n\t\t\t.guid = GUID_DRS_UPDATE_PASSWORD_NOT_REQUIRED_BIT,\n\t\t\t.error_string = \"Adding the UF_PASSWD_NOTREQD bit in userAccountControl requires the Update-Password-Not-Required-Bit right that was not given on the Domain object\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_DONT_EXPIRE_PASSWD,\n\t\t\t.guid = GUID_DRS_UNEXPIRE_PASSWORD,\n\t\t\t.error_string = \"Adding the UF_DONT_EXPIRE_PASSWD bit in userAccountControl requires the Unexpire-Password right that was not given on the Domain object\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,\n\t\t\t.guid = GUID_DRS_ENABLE_PER_USER_REVERSIBLY_ENCRYPTED_PASSWORD,\n\t\t\t.error_string = \"Adding the UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED bit in userAccountControl requires the Enable-Per-User-Reversibly-Encrypted-Password right that was not given on the Domain object\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_SERVER_TRUST_ACCOUNT,\n\t\t\t.guid = GUID_DRS_DS_INSTALL_REPLICA,\n\t\t\t.error_string = \"Adding the UF_SERVER_TRUST_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_PARTIAL_SECRETS_ACCOUNT,\n\t\t\t.guid = GUID_DRS_DS_INSTALL_REPLICA,\n\t\t\t.error_string = \"Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_WORKSTATION_TRUST_ACCOUNT,\n\t\t\t.priv_to_change_from = UF_NORMAL_ACCOUNT,\n\t\t\t.error_string = \"Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_NORMAL_ACCOUNT,\n\t\t\t.priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,\n\t\t\t.error_string = \"Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_INTERDOMAIN_TRUST_ACCOUNT,\n\t\t\t.oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,\n\t\t\t.error_string = \"Updating the UF_INTERDOMAIN_TRUST_ACCOUNT bit in userAccountControl is not permitted over LDAP.  This bit is restricted to the LSA CreateTrustedDomain interface\",\n\t\t\t.delete_is_privileged = true\n\t\t},\n\t\t{\n\t\t\t.uac = UF_TRUSTED_FOR_DELEGATION,\n\t\t\t.privilege = SEC_PRIV_ENABLE_DELEGATION,\n\t\t\t.delete_is_privileged = true,\n\t\t\t.error_string = \"Updating the UF_TRUSTED_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION,\n\t\t\t.privilege = SEC_PRIV_ENABLE_DELEGATION,\n\t\t\t.delete_is_privileged = true,\n\t\t\t.error_string = \"Updating the UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege\"\n\t\t}\n\n\t};\n\n\tif (dsdb_module_am_system(ac->module)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(map); i++) {\n\t\tif (user_account_control & map[i].uac) {\n\t\t\tneed_acl_check = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (need_acl_check == false) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tuser_token = acl_user_token(ac->module);\n\tif (user_token == NULL) {\n\t\treturn LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n\t}\n\n\tret = samldb_get_domain_secdesc_and_oc(ac, &domain_sd, &objectclass);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(map); i++) {\n\t\tuint32_t this_uac_new = user_account_control & map[i].uac;\n\t\tuint32_t this_uac_old = user_account_control_old & map[i].uac;\n\t\tif (this_uac_new != this_uac_old) {\n\t\t\tif (this_uac_old != 0) {\n\t\t\t\tif (map[i].delete_is_privileged == false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (map[i].oid) {\n\t\t\t\tstruct ldb_control *control = ldb_request_get_control(ac->req, map[i].oid);\n\t\t\t\tif (control == NULL) {\n\t\t\t\t\tret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n\t\t\t\t}\n\t\t\t} else if (map[i].privilege != SEC_PRIV_INVALID) {\n\t\t\t\tbool have_priv = security_token_has_privilege(user_token,\n\t\t\t\t\t\t\t\t\t      map[i].privilege);\n\t\t\t\tif (have_priv == false) {\n\t\t\t\t\tret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n\t\t\t\t}\n\t\t\t} else if (map[i].priv_to_change_from & user_account_control_old) {\n\t\t\t\tbool is_admin = security_token_has_builtin_administrators(user_token);\n\t\t\t\tif (is_admin == false) {\n\t\t\t\t\tret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n\t\t\t\t}\n\t\t\t} else if (map[i].guid) {\n\t\t\t\tret = acl_check_extended_right(ac,\n\t\t\t\t\t\t\t       ac->module,\n\t\t\t\t\t\t\t       ac->req,\n\t\t\t\t\t\t\t       objectclass,\n\t\t\t\t\t\t\t       domain_sd,\n\t\t\t\t\t\t\t       user_token,\n\t\t\t\t\t\t\t       map[i].guid,\n\t\t\t\t\t\t\t       SEC_ADS_CONTROL_ACCESS,\n\t\t\t\t\t\t\t       sid);\n\t\t\t} else {\n\t\t\t\tret = LDB_SUCCESS;\n\t\t\t}\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (ret == LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS) {\n\t\tswitch (ac->req->operation) {\n\t\tcase LDB_ADD:\n\t\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t\t       \"Failed to add %s: %s\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn),\n\t\t\t\t\t       map[i].error_string);\n\t\t\tbreak;\n\t\tcase LDB_MODIFY:\n\t\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t\t       \"Failed to modify %s: %s\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn),\n\t\t\t\t\t       map[i].error_string);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn ldb_module_operr(ac->module);\n\t\t}\n\t\tif (map[i].guid) {\n\t\t\tstruct ldb_dn *domain_dn\n\t\t\t\t= ldb_get_default_basedn(ldb_module_get_ctx(ac->module));\n\t\t\tdsdb_acl_debug(domain_sd, acl_user_token(ac->module),\n\t\t\t\t       domain_dn,\n\t\t\t\t       true,\n\t\t\t\t       10);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int samldb_check_user_account_control_rules(struct samldb_ctx *ac,\n\t\t\t\t\t\t   struct dom_sid *sid,\n\t\t\t\t\t\t   uint32_t req_uac,\n\t\t\t\t\t\t   uint32_t user_account_control,\n\t\t\t\t\t\t   uint32_t user_account_control_old,\n\t\t\t\t\t\t   bool is_computer_objectclass)\n{\n\tint ret;\n\tstruct dsdb_control_password_user_account_control *uac = NULL;\n\n\tret = samldb_check_user_account_control_invariants(ac, user_account_control);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tret = samldb_check_user_account_control_objectclass_invariants(ac,\n\t\t\t\t\t\t\t\t       user_account_control,\n\t\t\t\t\t\t\t\t       user_account_control_old,\n\t\t\t\t\t\t\t\t       is_computer_objectclass);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = samldb_check_user_account_control_acl(ac, sid, user_account_control, user_account_control_old);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tuac = talloc_zero(ac->req,\n\t\t\t  struct dsdb_control_password_user_account_control);\n\tif (uac == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\n\tuac->req_flags = req_uac;\n\tuac->old_flags = user_account_control_old;\n\tuac->new_flags = user_account_control;\n\n\tret = ldb_request_add_control(ac->req,\n\t\t\t\tDSDB_CONTROL_PASSWORD_USER_ACCOUNT_CONTROL_OID,\n\t\t\t\tfalse, uac);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\n\n/**\n * This function is called on LDB modify operations. It performs some additions/\n * replaces on the current LDB message when \"userAccountControl\" changes.\n */\nstatic int samldb_user_account_control_change(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tuint32_t old_uac;\n\tuint32_t new_uac;\n\tuint32_t raw_uac;\n\tuint32_t old_ufa;\n\tuint32_t new_ufa;\n\tuint32_t old_uac_computed;\n\tuint32_t clear_uac;\n\tuint32_t old_atype;\n\tuint32_t new_atype;\n\tuint32_t old_pgrid;\n\tuint32_t new_pgrid;\n\tNTTIME old_lockoutTime;\n\tstruct ldb_message_element *el;\n\tstruct ldb_val *val;\n\tstruct ldb_val computer_val;\n\tstruct ldb_message *tmp_msg;\n\tstruct dom_sid *sid;\n\tint ret;\n\tstruct ldb_result *res;\n\tconst char * const attrs[] = {\n\t\t\"objectClass\",\n\t\t\"isCriticalSystemObject\",\n\t\t\"userAccountControl\",\n\t\t\"msDS-User-Account-Control-Computed\",\n\t\t\"lockoutTime\",\n\t\t\"objectSid\",\n\t\tNULL\n\t};\n\tbool is_computer_objectclass = false;\n\tbool old_is_critical = false;\n\tbool new_is_critical = false;\n\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"userAccountControl\",\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (el == NULL || el->num_values == 0) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\"%08X: samldb: 'userAccountControl' can't be deleted!\",\n\t\t\tW_ERROR_V(WERR_DS_ILLEGAL_MOD_OPERATION));\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t/* Create a temporary message for fetching the \"userAccountControl\" */\n\ttmp_msg = ldb_msg_new(ac->msg);\n\tif (tmp_msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tret = ldb_msg_add(tmp_msg, el, 0);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\traw_uac = ldb_msg_find_attr_as_uint(tmp_msg,\n\t\t\t\t\t    \"userAccountControl\",\n\t\t\t\t\t    0);\n\ttalloc_free(tmp_msg);\n\t/*\n\t * UF_LOCKOUT, UF_PASSWD_CANT_CHANGE and UF_PASSWORD_EXPIRED\n\t * are only generated and not stored. We ignore them almost\n\t * completely, along with unknown bits and UF_SCRIPT.\n\t *\n\t * The only exception is ACB_AUTOLOCK, which features in\n\t * clear_acb when the bit is cleared in this modify operation.\n\t *\n\t * MS-SAMR 2.2.1.13 UF_FLAG Codes states that some bits are\n\t * ignored by clients and servers\n\t */\n\tnew_uac = raw_uac & UF_SETTABLE_BITS;\n\n\t/* Fetch the old \"userAccountControl\" and \"objectClass\" */\n\tret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn, attrs,\n\t\t\t\t    DSDB_FLAG_NEXT_MODULE, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\told_uac = ldb_msg_find_attr_as_uint(res->msgs[0], \"userAccountControl\", 0);\n\tif (old_uac == 0) {\n\t\treturn ldb_operr(ldb);\n\t}\n\told_uac_computed = ldb_msg_find_attr_as_uint(res->msgs[0],\n\t\t\t\t\t\t     \"msDS-User-Account-Control-Computed\", 0);\n\told_lockoutTime = ldb_msg_find_attr_as_int64(res->msgs[0],\n\t\t\t\t\t\t     \"lockoutTime\", 0);\n\told_is_critical = ldb_msg_find_attr_as_bool(res->msgs[0],\n\t\t\t\t\t\t    \"isCriticalSystemObject\", 0);\n\t/*\n\t * When we do not have objectclass \"computer\" we cannot\n\t * switch to a workstation or (RO)DC\n\t */\n\tel = ldb_msg_find_element(res->msgs[0], \"objectClass\");\n\tif (el == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\tcomputer_val = data_blob_string_const(\"computer\");\n\tval = ldb_msg_find_val(el, &computer_val);\n\tif (val != NULL) {\n\t\tis_computer_objectclass = true;\n\t}\n\n\told_ufa = old_uac & UF_ACCOUNT_TYPE_MASK;\n\told_atype = ds_uf2atype(old_ufa);\n\told_pgrid = ds_uf2prim_group_rid(old_uac);\n\n\tnew_ufa = new_uac & UF_ACCOUNT_TYPE_MASK;\n\tif (new_ufa == 0) {\n\t\t/*\n\t\t * \"userAccountControl\" = 0 or missing one of the\n\t\t * types means \"UF_NORMAL_ACCOUNT\".  See MS-SAMR\n\t\t * 3.1.1.8.10 point 8\n\t\t */\n\t\tnew_ufa = UF_NORMAL_ACCOUNT;\n\t\tnew_uac |= new_ufa;\n\t}\n\tsid = samdb_result_dom_sid(res, res->msgs[0], \"objectSid\");\n\tif (sid == NULL) {\n\t\treturn ldb_module_operr(ac->module);\n\t}\n\n\tret = samldb_check_user_account_control_rules(ac, sid,\n\t\t\t\t\t\t      raw_uac,\n\t\t\t\t\t\t      new_uac,\n\t\t\t\t\t\t      old_uac,\n\t\t\t\t\t\t      is_computer_objectclass);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tnew_atype = ds_uf2atype(new_ufa);\n\tnew_pgrid = ds_uf2prim_group_rid(new_uac);\n\n\tclear_uac = (old_uac | old_uac_computed) & ~raw_uac;\n\n\tswitch (new_ufa) {\n\tcase UF_NORMAL_ACCOUNT:\n\t\tnew_is_critical = old_is_critical;\n\t\tbreak;\n\n\tcase UF_INTERDOMAIN_TRUST_ACCOUNT:\n\t\tnew_is_critical = true;\n\t\tbreak;\n\n\tcase UF_WORKSTATION_TRUST_ACCOUNT:\n\t\tnew_is_critical = false;\n\t\tif (new_uac & UF_PARTIAL_SECRETS_ACCOUNT) {\n\t\t\tnew_is_critical = true;\n\t\t}\n\t\tbreak;\n\n\tcase UF_SERVER_TRUST_ACCOUNT:\n\t\tnew_is_critical = true;\n\t\tbreak;\n\n\tdefault:\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\"%08X: samldb: invalid userAccountControl[0x%08X]\",\n\t\t\tW_ERROR_V(WERR_INVALID_PARAMETER), raw_uac);\n\t\treturn LDB_ERR_OTHER;\n\t}\n\n\tif (old_atype != new_atype) {\n\t\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg,\n\t\t\t\t\t \"sAMAccountType\", new_atype);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t\tel = ldb_msg_find_element(ac->msg, \"sAMAccountType\");\n\t\tel->flags = LDB_FLAG_MOD_REPLACE;\n\t}\n\n\t/* As per MS-SAMR 3.1.1.8.10 these flags have not to be set */\n\tif ((clear_uac & UF_LOCKOUT) && (old_lockoutTime != 0)) {\n\t\t/* \"lockoutTime\" reset as per MS-SAMR 3.1.1.8.10 */\n\t\tldb_msg_remove_attr(ac->msg, \"lockoutTime\");\n\t\tret = samdb_msg_add_uint64(ldb, ac->msg, ac->msg, \"lockoutTime\",\n\t\t\t\t\t   (NTTIME)0);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t\tel = ldb_msg_find_element(ac->msg, \"lockoutTime\");\n\t\tel->flags = LDB_FLAG_MOD_REPLACE;\n\t}\n\n\t/*\n\t * \"isCriticalSystemObject\" might be set/changed\n\t *\n\t * Even a change from UF_NORMAL_ACCOUNT (implicitly FALSE) to\n\t * UF_WORKSTATION_TRUST_ACCOUNT (actually FALSE) triggers\n\t * creating the attribute.\n\t */\n\tif (old_is_critical != new_is_critical || old_atype != new_atype) {\n\t\tret = ldb_msg_add_string(ac->msg, \"isCriticalSystemObject\",\n\t\t\t\t\t new_is_critical ? \"TRUE\": \"FALSE\");\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t\tel = ldb_msg_find_element(ac->msg,\n\t\t\t\t\t   \"isCriticalSystemObject\");\n\t\tel->flags = LDB_FLAG_MOD_REPLACE;\n\t}\n\n\tif (!ldb_msg_find_element(ac->msg, \"primaryGroupID\") &&\n\t    (old_pgrid != new_pgrid)) {\n\t\t/* Older AD deployments don't know about the RODC group */\n\t\tif (new_pgrid == DOMAIN_RID_READONLY_DCS) {\n\t\t\tret = samldb_prim_group_tester(ac, new_pgrid);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg,\n\t\t\t\t\t \"primaryGroupID\", new_pgrid);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t\tel = ldb_msg_find_element(ac->msg,\n\t\t\t\t\t   \"primaryGroupID\");\n\t\tel->flags = LDB_FLAG_MOD_REPLACE;\n\t}\n\n\t/* Propagate eventual \"userAccountControl\" attribute changes */\n\tif (old_uac != new_uac) {\n\t\tchar *tempstr = talloc_asprintf(ac->msg, \"%d\",\n\t\t\t\t\t\tnew_uac);\n\t\tif (tempstr == NULL) {\n\t\t\treturn ldb_module_oom(ac->module);\n\t\t}\n\n\t\tret = ldb_msg_add_empty(ac->msg,\n\t\t\t\t\t\"userAccountControl\",\n\t\t\t\t\tLDB_FLAG_MOD_REPLACE,\n\t\t\t\t\t&el);\n\t\tel->values = talloc(ac->msg, struct ldb_val);\n\t\tel->num_values = 1;\n\t\tel->values[0].data = (uint8_t *) tempstr;\n\t\tel->values[0].length = strlen(tempstr);\n\t} else {\n\t\tldb_msg_remove_attr(ac->msg, \"userAccountControl\");\n\t}\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_check_pwd_last_set_acl(struct samldb_ctx *ac,\n\t\t\t\t\t struct dom_sid *sid)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret = 0;\n\tstruct security_token *user_token = NULL;\n\tstruct security_descriptor *domain_sd = NULL;\n\tstruct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));\n\tconst char *operation = \"\";\n\tconst struct dsdb_class *objectclass = NULL;\n\n\tif (dsdb_module_am_system(ac->module)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tswitch (ac->req->operation) {\n\tcase LDB_ADD:\n\t\toperation = \"add\";\n\t\tbreak;\n\tcase LDB_MODIFY:\n\t\toperation = \"modify\";\n\t\tbreak;\n\tdefault:\n\t\treturn ldb_module_operr(ac->module);\n\t}\n\n\tuser_token = acl_user_token(ac->module);\n\tif (user_token == NULL) {\n\t\treturn LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n\t}\n\n\tret = samldb_get_domain_secdesc_and_oc(ac, &domain_sd, &objectclass);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tret = acl_check_extended_right(ac,\n\t\t\t\t       ac->module,\n\t\t\t\t       ac->req,\n\t\t\t\t       objectclass,\n\t\t\t\t       domain_sd,\n\t\t\t\t       user_token,\n\t\t\t\t       GUID_DRS_UNEXPIRE_PASSWORD,\n\t\t\t\t       SEC_ADS_CONTROL_ACCESS,\n\t\t\t\t       sid);\n\tif (ret != LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS) {\n\t\treturn ret;\n\t}\n\n\tldb_debug_set(ldb, LDB_DEBUG_WARNING,\n\t\t      \"Failed to %s %s: \"\n\t\t      \"Setting pwdLastSet to -1 requires the \"\n\t\t      \"Unexpire-Password right that was not given \"\n\t\t      \"on the Domain object\",\n\t\t      operation,\n\t\t      ldb_dn_get_linearized(ac->msg->dn));\n\tdsdb_acl_debug(domain_sd, user_token,\n\t\t       domain_dn, true, 10);\n\n\treturn ret;\n}\n\n/**\n * This function is called on LDB modify operations. It performs some additions/\n * replaces on the current LDB message when \"pwdLastSet\" changes.\n */\nstatic int samldb_pwd_last_set_change(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tNTTIME last_set = 0;\n\tstruct ldb_message_element *el = NULL;\n\tstruct ldb_message *tmp_msg = NULL;\n\tstruct dom_sid *self_sid = NULL;\n\tint ret;\n\tstruct ldb_result *res = NULL;\n\tconst char * const attrs[] = {\n\t\t\"objectSid\",\n\t\tNULL\n\t};\n\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"pwdLastSet\",\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (el == NULL || el->num_values == 0) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\"%08X: samldb: 'pwdLastSet' can't be deleted!\",\n\t\t\tW_ERROR_V(WERR_DS_ILLEGAL_MOD_OPERATION));\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t/* Create a temporary message for fetching the \"userAccountControl\" */\n\ttmp_msg = ldb_msg_new(ac->msg);\n\tif (tmp_msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tret = ldb_msg_add(tmp_msg, el, 0);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tlast_set = samdb_result_nttime(tmp_msg, \"pwdLastSet\", 0);\n\ttalloc_free(tmp_msg);\n\n\t/*\n\t * Setting -1 (0xFFFFFFFFFFFFFFFF) requires the Unexpire-Password right\n\t */\n\tif (last_set != UINT64_MAX) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* Fetch the \"objectSid\" */\n\tret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn, attrs,\n\t\t\t\t    DSDB_FLAG_NEXT_MODULE, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tself_sid = samdb_result_dom_sid(res, res->msgs[0], \"objectSid\");\n\tif (self_sid == NULL) {\n\t\treturn ldb_module_operr(ac->module);\n\t}\n\n\tret = samldb_check_pwd_last_set_acl(ac, self_sid);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_lockout_time(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tNTTIME lockoutTime;\n\tstruct ldb_message_element *el;\n\tstruct ldb_message *tmp_msg;\n\tint ret;\n\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"lockoutTime\",\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (el == NULL || el->num_values == 0) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\"%08X: samldb: 'lockoutTime' can't be deleted!\",\n\t\t\tW_ERROR_V(WERR_DS_ILLEGAL_MOD_OPERATION));\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t/* Create a temporary message for fetching the \"lockoutTime\" */\n\ttmp_msg = ldb_msg_new(ac->msg);\n\tif (tmp_msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tret = ldb_msg_add(tmp_msg, el, 0);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tlockoutTime = ldb_msg_find_attr_as_int64(tmp_msg,\n\t\t\t\t\t\t \"lockoutTime\",\n\t\t\t\t\t\t 0);\n\ttalloc_free(tmp_msg);\n\n\tif (lockoutTime != 0) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* lockoutTime == 0 resets badPwdCount */\n\tldb_msg_remove_attr(ac->msg, \"badPwdCount\");\n\tret = samdb_msg_add_int(ldb, ac->msg, ac->msg,\n\t\t\t\t\"badPwdCount\", 0);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tel = ldb_msg_find_element(ac->msg, \"badPwdCount\");\n\tel->flags = LDB_FLAG_MOD_REPLACE;\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_group_type_change(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tuint32_t group_type, old_group_type, account_type;\n\tstruct ldb_message_element *el;\n\tstruct ldb_message *tmp_msg;\n\tint ret;\n\tstruct ldb_result *res;\n\tconst char * const attrs[] = { \"groupType\", NULL };\n\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"groupType\",\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (el == NULL) {\n\t\t/* we are not affected */\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* Create a temporary message for fetching the \"groupType\" */\n\ttmp_msg = ldb_msg_new(ac->msg);\n\tif (tmp_msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tret = ldb_msg_add(tmp_msg, el, 0);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tgroup_type = ldb_msg_find_attr_as_uint(tmp_msg, \"groupType\", 0);\n\ttalloc_free(tmp_msg);\n\n\tret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn, attrs,\n\t\t\t\t    DSDB_FLAG_NEXT_MODULE |\n\t\t\t\t    DSDB_SEARCH_SHOW_DELETED, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\told_group_type = ldb_msg_find_attr_as_uint(res->msgs[0], \"groupType\", 0);\n\tif (old_group_type == 0) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\t/* Group type switching isn't so easy as it seems: We can only\n\t * change in this directions: global <-> universal <-> local\n\t * On each step also the group type itself\n\t * (security/distribution) is variable. */\n\n\tif (ldb_request_get_control(ac->req, LDB_CONTROL_PROVISION_OID) == NULL) {\n\t\tswitch (group_type) {\n\t\tcase GTYPE_SECURITY_GLOBAL_GROUP:\n\t\tcase GTYPE_DISTRIBUTION_GLOBAL_GROUP:\n\t\t\t/* change to \"universal\" allowed */\n\t\t\tif ((old_group_type == GTYPE_SECURITY_DOMAIN_LOCAL_GROUP) ||\n\t\t\t(old_group_type == GTYPE_DISTRIBUTION_DOMAIN_LOCAL_GROUP)) {\n\t\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t\"samldb: Change from security/distribution local group forbidden!\");\n\t\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t\t}\n\t\tbreak;\n\n\t\tcase GTYPE_SECURITY_UNIVERSAL_GROUP:\n\t\tcase GTYPE_DISTRIBUTION_UNIVERSAL_GROUP:\n\t\t\t/* each change allowed */\n\t\tbreak;\n\t\tcase GTYPE_SECURITY_DOMAIN_LOCAL_GROUP:\n\t\tcase GTYPE_DISTRIBUTION_DOMAIN_LOCAL_GROUP:\n\t\t\t/* change to \"universal\" allowed */\n\t\t\tif ((old_group_type == GTYPE_SECURITY_GLOBAL_GROUP) ||\n\t\t\t(old_group_type == GTYPE_DISTRIBUTION_GLOBAL_GROUP)) {\n\t\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t\"samldb: Change from security/distribution global group forbidden!\");\n\t\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t\t}\n\t\tbreak;\n\n\t\tcase GTYPE_SECURITY_BUILTIN_LOCAL_GROUP:\n\t\tdefault:\n\t\t\t/* we don't allow this \"groupType\" values */\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\tbreak;\n\t\t}\n\t}\n\n\taccount_type =  ds_gtype2atype(group_type);\n\tif (account_type == 0) {\n\t\tldb_set_errstring(ldb, \"samldb: Unrecognized account type!\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg, \"sAMAccountType\",\n\t\t\t\t account_type);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tel = ldb_msg_find_element(ac->msg, \"sAMAccountType\");\n\tel->flags = LDB_FLAG_MOD_REPLACE;\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_member_check(struct samldb_ctx *ac)\n{\n\tconst char * const attrs[] = { \"objectSid\", NULL };\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tstruct ldb_message_element *el;\n\tstruct ldb_dn *member_dn;\n\tstruct dom_sid *sid;\n\tstruct ldb_result *res;\n\tstruct dom_sid *group_sid;\n\tunsigned int i, j;\n\tint ret;\n\n\t/* Fetch information from the existing object */\n\n\tret = dsdb_module_search(ac->module, ac, &res, ac->msg->dn, LDB_SCOPE_BASE, attrs,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED, ac->req, NULL);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (res->count != 1) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tgroup_sid = samdb_result_dom_sid(res, res->msgs[0], \"objectSid\");\n\tif (group_sid == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\t/* We've to walk over all modification entries and consider the \"member\"\n\t * ones. */\n\tfor (i = 0; i < ac->msg->num_elements; i++) {\n\t\tif (ldb_attr_cmp(ac->msg->elements[i].name, \"member\") != 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tel = &ac->msg->elements[i];\n\t\tfor (j = 0; j < el->num_values; j++) {\n\t\t\tstruct ldb_result *group_res;\n\t\t\tconst char *group_attrs[] = { \"primaryGroupID\" , NULL };\n\t\t\tuint32_t prim_group_rid;\n\n\t\t\tif (LDB_FLAG_MOD_TYPE(el->flags) == LDB_FLAG_MOD_DELETE) {\n\t\t\t\t/* Deletes will be handled in\n\t\t\t\t * repl_meta_data, and deletes not\n\t\t\t\t * matching a member will return\n\t\t\t\t * LDB_ERR_UNWILLING_TO_PERFORM\n\t\t\t\t * there */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmember_dn = ldb_dn_from_ldb_val(ac, ldb,\n\t\t\t\t\t\t\t&el->values[j]);\n\t\t\tif (!ldb_dn_validate(member_dn)) {\n\t\t\t\treturn ldb_operr(ldb);\n\t\t\t}\n\n\t\t\t/* Denies to add \"member\"s to groups which are primary\n\t\t\t * ones for them - in this case return\n\t\t\t * ERR_ENTRY_ALREADY_EXISTS. */\n\n\t\t\tret = dsdb_module_search_dn(ac->module, ac, &group_res,\n\t\t\t\t\t\t    member_dn, group_attrs,\n\t\t\t\t\t\t    DSDB_FLAG_NEXT_MODULE, ac->req);\n\t\t\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\t\t\t/* member DN doesn't exist yet */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tprim_group_rid = ldb_msg_find_attr_as_uint(group_res->msgs[0], \"primaryGroupID\", (uint32_t)-1);\n\t\t\tif (prim_group_rid == (uint32_t) -1) {\n\t\t\t\t/* the member hasn't to be a user account ->\n\t\t\t\t * therefore no check needed in this case. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsid = dom_sid_add_rid(ac, samdb_domain_sid(ldb),\n\t\t\t\t\t      prim_group_rid);\n\t\t\tif (sid == NULL) {\n\t\t\t\treturn ldb_operr(ldb);\n\t\t\t}\n\n\t\t\tif (dom_sid_equal(group_sid, sid)) {\n\t\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t\t       \"samldb: member %s already set via primaryGroupID %u\",\n\t\t\t\t\t\t       ldb_dn_get_linearized(member_dn), prim_group_rid);\n\t\t\t\treturn LDB_ERR_ENTRY_ALREADY_EXISTS;\n\t\t\t}\n\t\t}\n\t}\n\n\ttalloc_free(res);\n\n\treturn LDB_SUCCESS;\n}\n\n/* SAM objects have special rules regarding the \"description\" attribute on\n * modify operations. */\nstatic int samldb_description_check(struct samldb_ctx *ac, bool *modified)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tconst char * const attrs[] = { \"objectClass\", \"description\", NULL };\n\tstruct ldb_result *res;\n\tunsigned int i;\n\tint ret;\n\n\t/* Fetch information from the existing object */\n\tret = dsdb_module_search(ac->module, ac, &res, ac->msg->dn, LDB_SCOPE_BASE, attrs,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED, ac->req,\n\t\t\t\t \"(|(objectclass=user)(objectclass=group)(objectclass=samDomain)(objectclass=samServer))\");\n\tif (ret != LDB_SUCCESS) {\n\t\t/* don't treat it specially ... let normal error codes\n\t\t   happen from other places */\n\t\tldb_reset_err_string(ldb);\n\t\treturn LDB_SUCCESS;\n\t}\n\tif (res->count == 0) {\n\t\t/* we didn't match the filter */\n\t\ttalloc_free(res);\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* We've to walk over all modification entries and consider the\n\t * \"description\" ones. */\n\tfor (i = 0; i < ac->msg->num_elements; i++) {\n\t\tif (ldb_attr_cmp(ac->msg->elements[i].name, \"description\") == 0) {\n\t\t\tac->msg->elements[i].flags |= LDB_FLAG_INTERNAL_FORCE_SINGLE_VALUE_CHECK;\n\t\t\t*modified = true;\n\t\t}\n\t}\n\n\ttalloc_free(res);\n\n\treturn LDB_SUCCESS;\n}\n\n#define SPN_ALIAS_NONE 0\n#define SPN_ALIAS_LINK 1\n#define SPN_ALIAS_TARGET 2\n\nstatic int find_spn_aliases(struct ldb_context *ldb,\n\t\t\t    TALLOC_CTX *mem_ctx,\n\t\t\t    const char *service_class,\n\t\t\t    char ***aliases,\n\t\t\t    size_t *n_aliases,\n\t\t\t    int *direction)\n{\n\t/*\n\t * If you change the way this works, you should also look at changing\n\t * LDB_lookup_spn_alias() in source4/dsdb/samdb/cracknames.c, which\n\t * does some of the same work.\n\t *\n\t * In particular, note that sPNMappings are resolved on a first come,\n\t * first served basis. For example, if we have\n\t *\n\t *  host=ldap,cifs\n\t *  foo=ldap\n\t *  cifs=host,alerter\n\t *\n\t * then 'ldap', 'cifs', and 'host' will resolve to 'host', and\n\t * 'alerter' will resolve to 'cifs'.\n\t *\n\t * If this resolution method is made more complicated, then the\n\t * cracknames function should also be changed.\n\t */\n\tsize_t i, j;\n\tint ret;\n\tbool ok;\n\tstruct ldb_result *res = NULL;\n\tstruct ldb_message_element *spnmappings = NULL;\n\tTALLOC_CTX *tmp_ctx = NULL;\n\tstruct ldb_dn *service_dn = NULL;\n\n\tconst char *attrs[] = {\n\t\t\"sPNMappings\",\n\t\tNULL\n\t};\n\n\t*direction = SPN_ALIAS_NONE;\n\n\ttmp_ctx = talloc_new(mem_ctx);\n\tif (tmp_ctx == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\n\tservice_dn = ldb_dn_new(\n\t\ttmp_ctx, ldb,\n\t\t\"CN=Directory Service,CN=Windows NT,CN=Services\");\n\tif (service_dn == NULL) {\n\t\ttalloc_free(tmp_ctx);\n\t\treturn ldb_oom(ldb);\n\t}\n\n\tok = ldb_dn_add_base(service_dn, ldb_get_config_basedn(ldb));\n\tif (! ok) {\n\t\ttalloc_free(tmp_ctx);\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n\n\tret = ldb_search(ldb, tmp_ctx, &res, service_dn, LDB_SCOPE_BASE,\n\t\t\t attrs, \"(objectClass=nTDSService)\");\n\n\tif (ret != LDB_SUCCESS || res->count != 1) {\n\t\tDBG_WARNING(\"sPNMappings not found.\\n\");\n\t\ttalloc_free(tmp_ctx);\n\t\treturn ret;\n\t}\n\n\tspnmappings = ldb_msg_find_element(res->msgs[0], \"sPNMappings\");\n\tif (spnmappings == NULL || spnmappings->num_values == 0) {\n\t\tDBG_WARNING(\"no sPNMappings attribute\\n\");\n\t\ttalloc_free(tmp_ctx);\n\t\treturn LDB_ERR_NO_SUCH_OBJECT;\n\t}\n\t*n_aliases = 0;\n\n\tfor (i = 0; i < spnmappings->num_values; i++) {\n\t\tchar *p = NULL;\n\t\tchar *mapping = talloc_strndup(\n\t\t\ttmp_ctx,\n\t\t\t(char *)spnmappings->values[i].data,\n\t\t\tspnmappings->values[i].length);\n\t\tif (mapping == NULL) {\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ldb_oom(ldb);\n\t\t}\n\n\t\tp = strchr(mapping, '=');\n\t\tif (p == NULL) {\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_ERR_ALIAS_PROBLEM;\n\t\t}\n\t\tp[0] = '\\0';\n\t\tp++;\n\n\t\tif (strcasecmp(mapping, service_class) == 0) {\n\t\t\t/*\n\t\t\t * We need to return the reverse aliases for this one.\n\t\t\t *\n\t\t\t * typically, this means the service_class is \"host\"\n\t\t\t * and the mapping is \"host=alerter,appmgmt,cisvc,..\",\n\t\t\t * so we get \"alerter\", \"appmgmt\", etc in the list of\n\t\t\t * aliases.\n\t\t\t */\n\n\t\t\t/* There is one more field than there are commas */\n\t\t\tsize_t n = 1;\n\n\t\t\tfor (j = 0; p[j] != '\\0'; j++) {\n\t\t\t\tif (p[j] == ',') {\n\t\t\t\t\tn++;\n\t\t\t\t\tp[j] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t*aliases = talloc_array(mem_ctx, char*, n);\n\t\t\tif (*aliases == NULL) {\n\t\t\t\ttalloc_free(tmp_ctx);\n\t\t\t\treturn ldb_oom(ldb);\n\t\t\t}\n\t\t\t*n_aliases = n;\n\t\t\ttalloc_steal(mem_ctx, mapping);\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t(*aliases)[j] = p;\n\t\t\t\tp += strlen(p) + 1;\n\t\t\t}\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\t*direction = SPN_ALIAS_LINK;\n\t\t\treturn LDB_SUCCESS;\n\t\t}\n\t\t/*\n\t\t * We need to look along the list to see if service_class is\n\t\t * there; if so, we return a list of one item (probably \"host\").\n\t\t */\n\t\tdo {\n\t\t\tchar *str = p;\n\t\t\tp = strchr(p, ',');\n\t\t\tif (p != NULL) {\n\t\t\t\tp[0] = '\\0';\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (strcasecmp(str, service_class) == 0) {\n\t\t\t\t*aliases = talloc_array(mem_ctx, char*, 1);\n\t\t\t\tif (*aliases == NULL) {\n\t\t\t\t\ttalloc_free(tmp_ctx);\n\t\t\t\t\treturn ldb_oom(ldb);\n\t\t\t\t}\n\t\t\t\t*n_aliases = 1;\n\t\t\t\t(*aliases)[0] = mapping;\n\t\t\t\ttalloc_steal(mem_ctx, mapping);\n\t\t\t\ttalloc_free(tmp_ctx);\n\t\t\t\t*direction = SPN_ALIAS_TARGET;\n\t\t\t\treturn LDB_SUCCESS;\n\t\t\t}\n\t\t} while (p != NULL);\n\t}\n\tDBG_INFO(\"no sPNMappings alias for '%s'\\n\", service_class);\n\ttalloc_free(tmp_ctx);\n\t*aliases = NULL;\n\t*n_aliases = 0;\n\treturn LDB_SUCCESS;\n}\n\n\nstatic int get_spn_dn(struct ldb_context *ldb,\n\t\t      TALLOC_CTX *tmp_ctx,\n\t\t      const char *candidate,\n\t\t      struct ldb_dn **dn)\n{\n\tint ret;\n\tconst char *empty_attrs[] = { NULL };\n\tstruct ldb_message *msg = NULL;\n\tstruct ldb_dn *base_dn = ldb_get_default_basedn(ldb);\n\n\tconst char *enc_candidate = NULL;\n\n\t*dn = NULL;\n\n\tenc_candidate = ldb_binary_encode_string(tmp_ctx, candidate);\n\tif (enc_candidate == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = dsdb_search_one(ldb,\n\t\t\t      tmp_ctx,\n\t\t\t      &msg,\n\t\t\t      base_dn,\n\t\t\t      LDB_SCOPE_SUBTREE,\n\t\t\t      empty_attrs,\n\t\t\t      0,\n\t\t\t      \"(servicePrincipalName=%s)\",\n\t\t\t      enc_candidate);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\t*dn = msg->dn;\n\treturn LDB_SUCCESS;\n}\n\n\nstatic int check_spn_write_rights(struct ldb_context *ldb,\n\t\t\t\t  TALLOC_CTX *mem_ctx,\n\t\t\t\t  const char *spn,\n\t\t\t\t  struct ldb_dn *dn)\n{\n\tint ret;\n\tstruct ldb_message *msg = NULL;\n\tstruct ldb_message_element *del_el = NULL;\n\tstruct ldb_message_element *add_el = NULL;\n\tstruct ldb_val val = {\n\t\t.data = discard_const_p(uint8_t, spn),\n\t\t.length = strlen(spn)\n\t};\n\n\tmsg = ldb_msg_new(mem_ctx);\n\tif (msg == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\tmsg->dn = dn;\n\n\tret = ldb_msg_add_empty(msg,\n\t\t\t\t\"servicePrincipalName\",\n\t\t\t\tLDB_FLAG_MOD_DELETE,\n\t\t\t\t&del_el);\n\tif (ret != LDB_SUCCESS) {\n\t\ttalloc_free(msg);\n\t\treturn ret;\n\t}\n\n\tdel_el->values = talloc_array(msg->elements, struct ldb_val, 1);\n\tif (del_el->values == NULL) {\n\t\ttalloc_free(msg);\n\t\treturn ret;\n\t}\n\n\tdel_el->values[0] = val;\n\tdel_el->num_values = 1;\n\n\tret = ldb_msg_add_empty(msg,\n\t\t\t\t\"servicePrincipalName\",\n\t\t\t\tLDB_FLAG_MOD_ADD,\n\t\t\t\t&add_el);\n\tif (ret != LDB_SUCCESS) {\n\t\ttalloc_free(msg);\n\t\treturn ret;\n\t}\n\n\tadd_el->values = talloc_array(msg->elements, struct ldb_val, 1);\n\tif (add_el->values == NULL) {\n\t\ttalloc_free(msg);\n\t\treturn ret;\n\t}\n\n\tadd_el->values[0] = val;\n\tadd_el->num_values = 1;\n\n\tret = ldb_modify(ldb, msg);\n\tif (ret == LDB_ERR_NO_SUCH_ATTRIBUTE) {\n\t\tDBG_ERR(\"hmm I think we're OK, but not sure\\n\");\n\t} else if (ret != LDB_SUCCESS) {\n\t\tDBG_ERR(\"SPN write rights check failed with %d\\n\", ret);\n\t\ttalloc_free(msg);\n\t\treturn ret;\n\t}\n\ttalloc_free(msg);\n\treturn LDB_SUCCESS;\n}\n\n\nstatic int check_spn_alias_collision(struct ldb_context *ldb,\n\t\t\t\t     TALLOC_CTX *mem_ctx,\n\t\t\t\t     const char *spn,\n\t\t\t\t     struct ldb_dn *target_dn)\n{\n\tint ret;\n\tchar *service_class = NULL;\n\tchar *spn_tail = NULL;\n\tchar *p = NULL;\n\tchar **aliases = NULL;\n\tsize_t n_aliases = 0;\n\tsize_t i, len;\n\tTALLOC_CTX *tmp_ctx = NULL;\n\tconst char *target_dnstr = ldb_dn_get_linearized(target_dn);\n\tint link_direction;\n\n\ttmp_ctx = talloc_new(mem_ctx);\n\tif (tmp_ctx == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\n\t/*\n\t * \"dns/example.com/xxx\"  gives\n\t *    service_class = \"dns\"\n\t *    spn_tail      = \"example.com/xxx\"\n\t */\n\tp = strchr(spn, '/');\n\tif (p == NULL) {\n\t\t/* bad SPN */\n\t\ttalloc_free(tmp_ctx);\n\t\treturn ldb_error(ldb,\n\t\t\t\t LDB_ERR_OPERATIONS_ERROR,\n\t\t\t\t \"malformed servicePrincipalName\");\n\t}\n\tlen = p - spn;\n\n\tservice_class = talloc_strndup(tmp_ctx, spn, len);\n\tif (service_class == NULL) {\n\t\ttalloc_free(tmp_ctx);\n\t\treturn ldb_oom(ldb);\n\t}\n\tspn_tail = p + 1;\n\n\tret = find_spn_aliases(ldb,\n\t\t\t       tmp_ctx,\n\t\t\t       service_class,\n\t\t\t       &aliases,\n\t\t\t       &n_aliases,\n\t\t\t       &link_direction);\n\tif (ret != LDB_SUCCESS) {\n\t\ttalloc_free(tmp_ctx);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * we have the list of aliases, and now we need to combined them with\n\t * spn_tail and see if we can find the SPN.\n\t */\n\tfor (i = 0; i < n_aliases; i++) {\n\t\tstruct ldb_dn *colliding_dn = NULL;\n\t\tconst char *colliding_dnstr = NULL;\n\n\t\tchar *candidate = talloc_asprintf(tmp_ctx,\n\t\t\t\t\t\t  \"%s/%s\",\n\t\t\t\t\t\t  aliases[i],\n\t\t\t\t\t\t  spn_tail);\n\t\tif (candidate == NULL) {\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ldb_oom(ldb);\n\t\t}\n\n\t\tret = get_spn_dn(ldb, tmp_ctx, candidate, &colliding_dn);\n\t\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\t\tDBG_DEBUG(\"SPN alias '%s' not found (good)\\n\",\n\t\t\t\t  candidate);\n\t\t\ttalloc_free(candidate);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\"SPN '%s' search error %d\\n\", candidate, ret);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\n\t\ttarget_dnstr = ldb_dn_get_linearized(target_dn);\n\t\t/*\n\t\t * We have found an existing SPN that matches the alias. That\n\t\t * is OK only if it is on the object we are trying to add to,\n\t\t * or if the SPN on the other side is a more generic alias for\n\t\t * this one and we also have rights to modify it.\n\t\t *\n\t\t * That is, we can put \"host/X\" and \"cifs/X\" on the same\n\t\t * object, but not on different objects, unless we put the\n\t\t * host/X on first, and could also change that object when we\n\t\t * add cifs/X. It is forbidden to add the objects in the other\n\t\t * order.\n\t\t *\n\t\t * The rationale for this is that adding \"cifs/X\" effectively\n\t\t * changes \"host/X\" by diverting traffic. If \"host/X\" can be\n\t\t * added after \"cifs/X\", a sneaky person could get \"cifs/X\" in\n\t\t * first, making \"host/X\" have less effect than intended.\n\t\t *\n\t\t * Note: we also can't have \"host/X\" and \"Host/X\" on the same\n\t\t * object, but that is not relevant here.\n\t\t */\n\n\t\tret = ldb_dn_compare(colliding_dn, target_dn);\n\t\tif (ret != 0) {\n\t\t\tcolliding_dnstr = ldb_dn_get_linearized(colliding_dn);\n\t\t\tDBG_ERR(\"trying to add SPN '%s' on '%s' when '%s' is \"\n\t\t\t\t\"on '%s'\\n\",\n\t\t\t\tspn,\n\t\t\t\ttarget_dnstr,\n\t\t\t\tcandidate,\n\t\t\t\tcolliding_dnstr);\n\n\t\t\tif (link_direction == SPN_ALIAS_LINK) {\n\t\t\t\t/* we don't allow host/X if there is a\n\t\t\t\t * cifs/X */\n\t\t\t\ttalloc_free(tmp_ctx);\n\t\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t\t}\n\t\t\tret = check_spn_write_rights(ldb,\n\t\t\t\t\t\t     tmp_ctx,\n\t\t\t\t\t\t     candidate,\n\t\t\t\t\t\t     colliding_dn);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tDBG_ERR(\"SPN '%s' is on '%s' so '%s' can't be \"\n\t\t\t\t\t\"added to '%s'\\n\",\n\t\t\t\t\tcandidate,\n\t\t\t\t\tcolliding_dnstr,\n\t\t\t\t\tspn,\n\t\t\t\t\ttarget_dnstr);\n\t\t\t\ttalloc_free(tmp_ctx);\n\t\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t\t       \"samldb: spn[%s] would cause a conflict\",\n\t\t\t\t\t\t       spn);\n\t\t\t\treturn LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_INFO(\"SPNs '%s' and '%s' alias both on '%s'\\n\",\n\t\t\t\t candidate, spn, target_dnstr);\n\t\t}\n\t\ttalloc_free(candidate);\n\t}\n\n\ttalloc_free(tmp_ctx);\n\treturn LDB_SUCCESS;\n}\n\nstatic int check_spn_direct_collision(struct ldb_context *ldb,\n\t\t\t\t      TALLOC_CTX *mem_ctx,\n\t\t\t\t      const char *spn,\n\t\t\t\t      struct ldb_dn *target_dn)\n{\n\tint ret;\n\tTALLOC_CTX *tmp_ctx = NULL;\n\tstruct ldb_dn *colliding_dn = NULL;\n\tconst char *target_dnstr = NULL;\n\tconst char *colliding_dnstr = NULL;\n\n\ttmp_ctx = talloc_new(mem_ctx);\n\tif (tmp_ctx == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\n\tret = get_spn_dn(ldb, tmp_ctx, spn, &colliding_dn);\n\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\tDBG_DEBUG(\"SPN '%s' not found (good)\\n\", spn);\n\t\ttalloc_free(tmp_ctx);\n\t\treturn LDB_SUCCESS;\n\t}\n\tif (ret != LDB_SUCCESS) {\n\t\tDBG_ERR(\"SPN '%s' search error %d\\n\", spn, ret);\n\t\ttalloc_free(tmp_ctx);\n\t\tif (ret == LDB_ERR_COMPARE_TRUE) {\n\t\t\t/*\n\t\t\t * COMPARE_TRUE has special meaning here and we don't\n\t\t\t * want to return it by mistake.\n\t\t\t */\n\t\t\tret = LDB_ERR_OPERATIONS_ERROR;\n\t\t}\n\t\treturn ret;\n\t}\n\t/*\n\t * We have found this exact SPN. This is mostly harmless (depend on\n\t * ADD vs REPLACE) when the spn is being put on the object that\n\t * already has, so we let it through to succeed or fail as some other\n\t * module sees fit.\n\t */\n\ttarget_dnstr = ldb_dn_get_linearized(target_dn);\n\tret = ldb_dn_compare(colliding_dn, target_dn);\n\tif (ret != 0) {\n\t\tcolliding_dnstr = ldb_dn_get_linearized(colliding_dn);\n\t\tDBG_ERR(\"SPN '%s' is on '%s' so it can't be \"\n\t\t\t\"added to '%s'\\n\",\n\t\t\tspn,\n\t\t\tcolliding_dnstr,\n\t\t\ttarget_dnstr);\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"samldb: spn[%s] would cause a conflict\",\n\t\t\t\t       spn);\n\t\ttalloc_free(tmp_ctx);\n\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t}\n\n\tDBG_INFO(\"SPN '%s' is already on '%s'\\n\",\n\t\t spn, target_dnstr);\n\ttalloc_free(tmp_ctx);\n\treturn LDB_ERR_COMPARE_TRUE;\n}\n\n\nstatic int count_spn_components(struct ldb_val val)\n{\n\t/*\n\t * a 3 part servicePrincipalName has two slashes, like\n\t * ldap/example.com/DomainDNSZones.example.com.\n\t *\n\t * In krb5_parse_name_flags() we don't count \"\\/\" as a slash (i.e.\n\t * escaped by a backslash), but this is not the behaviour of Windows\n\t * on setting a servicePrincipalName -- slashes are counted regardless\n\t * of backslashes.\n\t *\n\t * Accordingly, here we ignore backslashes. This will reject\n\t * multi-slash SPNs that krb5_parse_name_flags() would accept, and\n\t * allow ones in the form \"a\\/b\" that it won't parse.\n\t */\n\tsize_t i;\n\tint slashes = 0;\n\tfor (i = 0; i < val.length; i++) {\n\t\tchar c = val.data[i];\n\t\tif (c == '/') {\n\t\t\tslashes++;\n\t\t\tif (slashes == 3) {\n\t\t\t\t/* at this point we don't care */\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t}\n\t}\n\treturn slashes + 1;\n}\n\n\n/* Check that \"servicePrincipalName\" changes do not introduce a collision\n * globally. */\nstatic int samldb_spn_uniqueness_check(struct samldb_ctx *ac,\n\t\t\t\t       struct ldb_message_element *spn_el)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\tconst char *spn = NULL;\n\tsize_t i;\n\tTALLOC_CTX *tmp_ctx = talloc_new(ac->msg);\n\tif (tmp_ctx == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\n\tfor (i = 0; i < spn_el->num_values; i++) {\n\t\tint n_components;\n\t\tspn = (char *)spn_el->values[i].data;\n\n\t\tn_components = count_spn_components(spn_el->values[i]);\n\t\tif (n_components > 3 || n_components < 2) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"samldb: spn[%s] invalid with %u components\",\n\t\t\t\t\t       spn, n_components);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\n\t\tret = check_spn_direct_collision(ldb,\n\t\t\t\t\t\t tmp_ctx,\n\t\t\t\t\t\t spn,\n\t\t\t\t\t\t ac->msg->dn);\n\t\tif (ret == LDB_ERR_COMPARE_TRUE) {\n\t\t\tDBG_INFO(\"SPN %s re-added to the same object\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_SUCCESS;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\"SPN %s failed direct uniqueness check\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = check_spn_alias_collision(ldb,\n\t\t\t\t\t\ttmp_ctx,\n\t\t\t\t\t\tspn,\n\t\t\t\t\t\tac->msg->dn);\n\n\t\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\t\t/* we have no sPNMappings, hence no aliases */\n\t\t\tbreak;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\"SPN %s failed alias uniqueness check\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t\tDBG_INFO(\"SPN %s seems to be unique\\n\", spn);\n\t}\n\n\ttalloc_free(tmp_ctx);\n\treturn LDB_SUCCESS;\n}\n\n\n\n/* This trigger adapts the \"servicePrincipalName\" attributes if the\n * \"dNSHostName\" and/or \"sAMAccountName\" attribute change(s) */\nstatic int samldb_service_principal_names_change(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tstruct ldb_message_element *el = NULL, *el2 = NULL;\n\tstruct ldb_message *msg;\n\tconst char * const attrs[] = { \"servicePrincipalName\", NULL };\n\tstruct ldb_result *res;\n\tconst char *dns_hostname = NULL, *old_dns_hostname = NULL,\n\t\t   *sam_accountname = NULL, *old_sam_accountname = NULL;\n\tunsigned int i, j;\n\tint ret;\n\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"dNSHostName\",\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"sAMAccountName\",\n\t\t\t\t\t   &el2,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif ((el == NULL) && (el2 == NULL)) {\n\t\t/* we are not affected */\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* Create a temporary message for fetching the \"dNSHostName\" */\n\tif (el != NULL) {\n\t\tconst char *dns_attrs[] = { \"dNSHostName\", NULL };\n\t\tmsg = ldb_msg_new(ac->msg);\n\t\tif (msg == NULL) {\n\t\t\treturn ldb_module_oom(ac->module);\n\t\t}\n\t\tret = ldb_msg_add(msg, el, 0);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t\tdns_hostname = talloc_strdup(ac,\n\t\t\t\t\t     ldb_msg_find_attr_as_string(msg, \"dNSHostName\", NULL));\n\t\tif (dns_hostname == NULL) {\n\t\t\treturn ldb_module_oom(ac->module);\n\t\t}\n\n\t\ttalloc_free(msg);\n\n\t\tret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn,\n\t\t\t\t\t    dns_attrs, DSDB_FLAG_NEXT_MODULE, ac->req);\n\t\tif (ret == LDB_SUCCESS) {\n\t\t\told_dns_hostname = ldb_msg_find_attr_as_string(res->msgs[0], \"dNSHostName\", NULL);\n\t\t}\n\t}\n\n\t/* Create a temporary message for fetching the \"sAMAccountName\" */\n\tif (el2 != NULL) {\n\t\tchar *tempstr, *tempstr2 = NULL;\n\t\tconst char *acct_attrs[] = { \"sAMAccountName\", NULL };\n\n\t\tmsg = ldb_msg_new(ac->msg);\n\t\tif (msg == NULL) {\n\t\t\treturn ldb_module_oom(ac->module);\n\t\t}\n\t\tret = ldb_msg_add(msg, el2, 0);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t\ttempstr = talloc_strdup(ac,\n\t\t\t\t\tldb_msg_find_attr_as_string(msg, \"sAMAccountName\", NULL));\n\t\ttalloc_free(msg);\n\n\t\tret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn, acct_attrs,\n\t\t\t\t\t    DSDB_FLAG_NEXT_MODULE, ac->req);\n\t\tif (ret == LDB_SUCCESS) {\n\t\t\ttempstr2 = talloc_strdup(ac,\n\t\t\t\t\t\t ldb_msg_find_attr_as_string(res->msgs[0],\n\t\t\t\t\t\t\t\t\t     \"sAMAccountName\", NULL));\n\t\t}\n\n\n\t\t/* The \"sAMAccountName\" needs some additional trimming: we need\n\t\t * to remove the trailing \"$\"s if they exist. */\n\t\tif ((tempstr != NULL) && (tempstr[0] != '\\0') &&\n\t\t    (tempstr[strlen(tempstr) - 1] == '$')) {\n\t\t\ttempstr[strlen(tempstr) - 1] = '\\0';\n\t\t}\n\t\tif ((tempstr2 != NULL) && (tempstr2[0] != '\\0') &&\n\t\t    (tempstr2[strlen(tempstr2) - 1] == '$')) {\n\t\t\ttempstr2[strlen(tempstr2) - 1] = '\\0';\n\t\t}\n\t\tsam_accountname = tempstr;\n\t\told_sam_accountname = tempstr2;\n\t}\n\n\tif (old_dns_hostname == NULL) {\n\t\t/* we cannot change when the old name is unknown */\n\t\tdns_hostname = NULL;\n\t}\n\tif ((old_dns_hostname != NULL) && (dns_hostname != NULL) &&\n\t    (strcasecmp_m(old_dns_hostname, dns_hostname) == 0)) {\n\t\t/* The \"dNSHostName\" didn't change */\n\t\tdns_hostname = NULL;\n\t}\n\n\tif (old_sam_accountname == NULL) {\n\t\t/* we cannot change when the old name is unknown */\n\t\tsam_accountname = NULL;\n\t}\n\tif ((old_sam_accountname != NULL) && (sam_accountname != NULL) &&\n\t    (strcasecmp_m(old_sam_accountname, sam_accountname) == 0)) {\n\t\t/* The \"sAMAccountName\" didn't change */\n\t\tsam_accountname = NULL;\n\t}\n\n\tif ((dns_hostname == NULL) && (sam_accountname == NULL)) {\n\t\t/* Well, there are information missing (old name(s)) or the\n\t\t * names didn't change. We've nothing to do and can exit here */\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/*\n\t * Potential \"servicePrincipalName\" changes in the same request have\n\t * to be handled before the update (Windows behaviour).\n\t *\n\t * We extract the SPN changes into a new message and run it through\n\t * the stack from this module, so that it subjects them to the SPN\n\t * checks we have here.\n\t */\n\tel = ldb_msg_find_element(ac->msg, \"servicePrincipalName\");\n\tif (el != NULL) {\n\t\tmsg = ldb_msg_new(ac->msg);\n\t\tif (msg == NULL) {\n\t\t\treturn ldb_module_oom(ac->module);\n\t\t}\n\t\tmsg->dn = ac->msg->dn;\n\n\t\tdo {\n\t\t\tret = ldb_msg_add(msg, el, el->flags);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tldb_msg_remove_element(ac->msg, el);\n\n\t\t\tel = ldb_msg_find_element(ac->msg,\n\t\t\t\t\t\t  \"servicePrincipalName\");\n\t\t} while (el != NULL);\n\n\t\tret = dsdb_module_modify(ac->module, msg,\n\t\t\t\t\t DSDB_FLAG_OWN_MODULE, ac->req);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t\ttalloc_free(msg);\n\t}\n\n\t/* Fetch the \"servicePrincipalName\"s if any */\n\tret = dsdb_module_search(ac->module, ac, &res, ac->msg->dn, LDB_SCOPE_BASE, attrs,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE, ac->req, NULL);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif ((res->count != 1) || (res->msgs[0]->num_elements > 1)) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tif (res->msgs[0]->num_elements == 1) {\n\t\t/*\n\t\t * Yes, we do have \"servicePrincipalName\"s. First we update them\n\t\t * locally, that means we do always substitute the current\n\t\t * \"dNSHostName\" with the new one and/or \"sAMAccountName\"\n\t\t * without \"$\" with the new one and then we append the\n\t\t * modified \"servicePrincipalName\"s as a message element\n\t\t * replace to the modification request (Windows behaviour). We\n\t\t * need also to make sure that the values remain case-\n\t\t * insensitively unique.\n\t\t */\n\n\t\tret = ldb_msg_add_empty(ac->msg, \"servicePrincipalName\",\n\t\t\t\t\tLDB_FLAG_MOD_REPLACE, &el);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (i = 0; i < res->msgs[0]->elements[0].num_values; i++) {\n\t\t\tchar *old_str, *new_str;\n\t\t\tchar *pos = NULL;\n\t\t\tconst char *tok;\n\t\t\tstruct ldb_val *vals;\n\t\t\tbool found = false;\n\n\t\t\told_str = (char *)\n\t\t\t\tres->msgs[0]->elements[0].values[i].data;\n\n\t\t\tnew_str = talloc_strdup(ac->msg,\n\t\t\t\t\t\tstrtok_r(old_str, \"/\", &pos));\n\t\t\tif (new_str == NULL) {\n\t\t\t\treturn ldb_module_oom(ac->module);\n\t\t\t}\n\n\t\t\twhile ((tok = strtok_r(NULL, \"/\", &pos)) != NULL) {\n\t\t\t\tif ((dns_hostname != NULL) &&\n\t\t\t\t    (strcasecmp_m(tok, old_dns_hostname) == 0)) {\n\t\t\t\t\ttok = dns_hostname;\n\t\t\t\t}\n\t\t\t\tif ((sam_accountname != NULL) &&\n\t\t\t\t    (strcasecmp_m(tok, old_sam_accountname) == 0)) {\n\t\t\t\t\ttok = sam_accountname;\n\t\t\t\t}\n\n\t\t\t\tnew_str = talloc_asprintf(ac->msg, \"%s/%s\",\n\t\t\t\t\t\t\t  new_str, tok);\n\t\t\t\tif (new_str == NULL) {\n\t\t\t\t\treturn ldb_module_oom(ac->module);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Uniqueness check */\n\t\t\tfor (j = 0; (!found) && (j < el->num_values); j++) {\n\t\t\t\tif (strcasecmp_m((char *)el->values[j].data,\n\t\t\t\t\t       new_str) == 0) {\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * append the new \"servicePrincipalName\" -\n\t\t\t * code derived from ldb_msg_add_value().\n\t\t\t *\n\t\t\t * Open coded to make it clear that we must\n\t\t\t * append to the MOD_REPLACE el created above.\n\t\t\t */\n\t\t\tvals = talloc_realloc(ac->msg, el->values,\n\t\t\t\t\t      struct ldb_val,\n\t\t\t\t\t      el->num_values + 1);\n\t\t\tif (vals == NULL) {\n\t\t\t\treturn ldb_module_oom(ac->module);\n\t\t\t}\n\t\t\tel->values = vals;\n\t\t\tel->values[el->num_values] = data_blob_string_const(new_str);\n\t\t\t++(el->num_values);\n\t\t}\n\t}\n\n\ttalloc_free(res);\n\n\treturn LDB_SUCCESS;\n}\n\n/* This checks the \"fSMORoleOwner\" attributes */\nstatic int samldb_fsmo_role_owner_check(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tconst char * const no_attrs[] = { NULL };\n\tstruct ldb_message_element *el;\n\tstruct ldb_message *tmp_msg;\n\tstruct ldb_dn *res_dn;\n\tstruct ldb_result *res;\n\tint ret;\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"fSMORoleOwner\",\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (el == NULL) {\n\t\t/* we are not affected */\n\t\treturn LDB_SUCCESS;\n\t}\n\tif (el->num_values != 1) {\n\t\tgoto choose_error_code;\n\t}\n\n\t/* Create a temporary message for fetching the \"fSMORoleOwner\" */\n\ttmp_msg = ldb_msg_new(ac->msg);\n\tif (tmp_msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tret = ldb_msg_add(tmp_msg, el, 0);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tres_dn = ldb_msg_find_attr_as_dn(ldb, ac, tmp_msg, \"fSMORoleOwner\");\n\ttalloc_free(tmp_msg);\n\n\tif (res_dn == NULL) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb: 'fSMORoleOwner' attributes have to reference 'nTDSDSA' entries!\");\n\t\tgoto choose_error_code;\n\t}\n\n\t/* Fetched DN has to reference a \"nTDSDSA\" entry */\n\tret = dsdb_module_search(ac->module, ac, &res, res_dn, LDB_SCOPE_BASE,\n\t\t\t\t no_attrs,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED,\n\t\t\t\t ac->req, \"(objectClass=nTDSDSA)\");\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (res->count != 1) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb: 'fSMORoleOwner' attributes have to reference 'nTDSDSA' entries!\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\ttalloc_free(res);\n\n\treturn LDB_SUCCESS;\n\nchoose_error_code:\n\t/* this is just how it is */\n\tif (ac->req->operation == LDB_ADD) {\n\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t} else {\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n}\n\n/*\n * Return zero if the number of zero bits in the address (looking from low to\n * high) is equal to or greater than the length minus the mask. Otherwise it\n * returns -1.\n */\nstatic int check_cidr_zero_bits(uint8_t *address, unsigned int len,\n\t\t\t\tunsigned int mask)\n{\n\t/* <address> is an integer in big-endian form, <len> bits long. All\n\t   bits between <mask> and <len> must be zero. */\n\tint i;\n\tunsigned int byte_len;\n\tunsigned int byte_mask;\n\tunsigned int bit_mask;\n\tif (len == 32) {\n\t\tDBG_INFO(\"Looking at address %02x%02x%02x%02x, mask %u\\n\",\n\t\t\t address[0], address[1], address[2], address[3],\n\t\t\t  mask);\n\t} else if (len == 128){\n\t\tDBG_INFO(\"Looking at address \"\n\t\t\t \"%02x%02x-%02x%02x-%02x%02x-%02x%02x-\"\n\t\t\t \"%02x%02x-%02x%02x-%02x%02x-%02x%02x, mask %u\\n\",\n\t\t\t address[0], address[1], address[2], address[3],\n\t\t\t address[4], address[5], address[6], address[7],\n\t\t\t address[8], address[9], address[10], address[11],\n\t\t\t address[12], address[13], address[14], address[15],\n\t\t\t mask);\n\t}\n\n\tif (mask > len){\n\t\tDBG_INFO(\"mask %u is too big (> %u)\\n\", mask, len);\n\t\treturn -1;\n\t}\n\tif (mask == len){\n\t\t/* single address subnet.\n\t\t * In IPv4 all 255s is invalid by the bitmask != address rule\n\t\t * in MS-ADTS. IPv6 does not suffer.\n\t\t */\n\t\tif (len == 32){\n\t\t\tif (address[0] == 255 &&\n\t\t\t    address[1] == 255 &&\n\t\t\t    address[2] == 255 &&\n\t\t\t    address[3] == 255){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tbyte_len = len / 8;\n\tbyte_mask = mask / 8;\n\n\tfor (i = byte_len - 1; i > byte_mask; i--){\n\t\tDBG_DEBUG(\"checking byte %d %02x\\n\", i, address[i]);\n\t\tif (address[i] != 0){\n\t\t\treturn -1;\n\t\t}\n\t}\n\tbit_mask = (1 << (8 - (mask & 7))) - 1;\n\tDBG_DEBUG(\"checking bitmask %02x & %02x overlap %02x\\n\", bit_mask, address[byte_mask],\n\t\t  bit_mask & address[byte_mask]);\n\tif (address[byte_mask] & bit_mask){\n\t\treturn -1;\n\t}\n\n\t/* According to MS-ADTS, the mask can't exactly equal the bitmask for\n\t * IPv4 (but this is fine for v6). That is 255.255.80.0/17 is bad,\n\t * because the bitmask implied by \"/17\" is 255.255.80.0.\n\t *\n\t * The bit_mask used in the previous check is the complement of what\n\t * we want here.\n\t */\n\tif (len == 32 && address[byte_mask] == (uint8_t)~bit_mask){\n\t\tbool ok = false;\n\t\tfor (i = 0; i < byte_mask; i++){\n\t\t\tif (address[i] != 255){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok == false){\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\nstatic int check_address_roundtrip(const char *address, int family,\n\t\t\t\t   const uint8_t *address_bytes,\n\t\t\t\t   char *buffer, int buffer_len)\n{\n\t/*\n\t * Check that the address is in the canonical RFC5952 format for IPv6,\n\t * and lacks extra leading zeros for each dotted decimal for IPv4.\n\t * Handily this is what inet_ntop() gives you.\n\t */\n\tconst char *address_redux = inet_ntop(family, address_bytes,\n\t\t\t\t\t      buffer, buffer_len);\n\tif (address_redux == NULL){\n\t\tDBG_INFO(\"Address round trip %s failed unexpectedly\"\n\t\t\t \" with errno %d\\n\", address, errno);\n\t\treturn -1;\n\t}\n\tif (strcasecmp(address, address_redux) != 0){\n\t\tDBG_INFO(\"Address %s round trips to %s; fail!\\n\",\n\t\t\t address, address_redux);\n\t\t/* If the address family is IPv6, and the address is in a\n\t\t   certain range\n\n\t\t */\n\t\tif (strchr(address_redux, '.') != NULL){\n\t\t\tDEBUG(0, (\"The IPv6 address '%s' has the misfortune of \"\n\t\t\t\t  \"lying in a range that was once used for \"\n\t\t\t\t  \"IPv4 embedding (that is, it might also be \"\n\t\t\t\t  \"represented as '%s').\\n\", address,\n\t\t\t\t  address_redux));\n\t\t}\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n\n\n/*\n * MS-ADTS v20150630 6.1.1.2.2.2.1 Subnet Object, refers to RFC1166 and\n * RFC2373. It specifies something seemingly indistinguishable from an RFC4632\n * CIDR address range without saying so explicitly. Here we follow the CIDR\n * spec.\n *\n * Return 0 on success, -1 on error.\n */\nstatic int verify_cidr(const char *cidr)\n{\n\tchar *address = NULL, *slash = NULL;\n\tbool has_colon, has_dot;\n\tint res, ret;\n\tunsigned long mask;\n\tuint8_t *address_bytes = NULL;\n\tchar *address_redux = NULL;\n\tunsigned int address_len;\n\tTALLOC_CTX *frame = NULL;\n\tint error = 0;\n\n\tDBG_DEBUG(\"CIDR is %s\\n\", cidr);\n\tframe = talloc_stackframe();\n\taddress = talloc_strdup(frame, cidr);\n\tif (address == NULL){\n\t\tgoto error;\n\t}\n\n\t/* there must be a '/' */\n\tslash = strchr(address, '/');\n\tif (slash == NULL){\n\t\tgoto error;\n\t}\n\t/* terminate the address for strchr, inet_pton */\n\t*slash = '\\0';\n\n\tmask = smb_strtoul(slash + 1, NULL, 10, &error, SMB_STR_FULL_STR_CONV);\n\tif (mask == 0){\n\t\tDBG_INFO(\"Windows does not like the zero mask, \"\n\t\t\t \"so nor do we: %s\\n\", cidr);\n\t\tgoto error;\n\t}\n\n\tif (error != 0){\n\t\tDBG_INFO(\"CIDR mask is not a proper integer: %s\\n\", cidr);\n\t\tgoto error;\n\t}\n\n\taddress_bytes = talloc_size(frame, sizeof(struct in6_addr));\n\tif (address_bytes == NULL){\n\t\tgoto error;\n\t}\n\n\taddress_redux = talloc_size(frame, INET6_ADDRSTRLEN);\n\tif (address_redux == NULL){\n\t\tgoto error;\n\t}\n\n\tDBG_INFO(\"found address %s, mask %lu\\n\", address, mask);\n\thas_colon = (strchr(address, ':') == NULL) ? false : true;\n\thas_dot = (strchr(address, '.') == NULL) ? false : true;\n\tif (has_dot && has_colon){\n\t\t/* This seems to be an IPv4 address embedded in IPv6, which is\n\t\t   icky. We don't support it. */\n\t\tDBG_INFO(\"Refusing to consider cidr '%s' with dots and colons\\n\",\n\t\t\t  cidr);\n\t\tgoto error;\n\t} else if (has_colon){\t/* looks like IPv6 */\n\t\tres = inet_pton(AF_INET6, address, address_bytes);\n\t\tif (res != 1) {\n\t\t\tDBG_INFO(\"Address in %s fails to parse as IPv6\\n\", cidr);\n\t\t\tgoto error;\n\t\t}\n\t\taddress_len = 128;\n\t\tif (check_address_roundtrip(address, AF_INET6, address_bytes,\n\t\t\t\t\t    address_redux, INET6_ADDRSTRLEN)){\n\t\t\tgoto error;\n\t\t}\n\t} else if (has_dot) {\n\t\t/* looks like IPv4 */\n\t\tif (strcmp(address, \"0.0.0.0\") == 0){\n\t\t\tDBG_INFO(\"Windows does not like the zero IPv4 address, \"\n\t\t\t\t \"so nor do we.\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tres = inet_pton(AF_INET, address, address_bytes);\n\t\tif (res != 1) {\n\t\t\tDBG_INFO(\"Address in %s fails to parse as IPv4\\n\", cidr);\n\t\t\tgoto error;\n\t\t}\n\t\taddress_len = 32;\n\n\t\tif (check_address_roundtrip(address, AF_INET, address_bytes,\n\t\t\t\t\t    address_redux, INET_ADDRSTRLEN)){\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\t/* This doesn't look like an IP address at all. */\n\t\tgoto error;\n\t}\n\n\tret = check_cidr_zero_bits(address_bytes, address_len, mask);\n\ttalloc_free(frame);\n\treturn ret;\n  error:\n\ttalloc_free(frame);\n\treturn -1;\n}\n\n\nstatic int samldb_verify_subnet(struct samldb_ctx *ac, struct ldb_dn *dn)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tconst char *cidr = NULL;\n\tconst struct ldb_val *rdn_value = NULL;\n\n\trdn_value = ldb_dn_get_rdn_val(dn);\n\tif (rdn_value == NULL) {\n\t\tldb_set_errstring(ldb, \"samldb: ldb_dn_get_rdn_val \"\n\t\t\t\t  \"failed\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\tcidr = ldb_dn_escape_value(ac, *rdn_value);\n\tDBG_INFO(\"looking at cidr '%s'\\n\", cidr);\n\tif (cidr == NULL) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb: adding an empty subnet cidr seems wrong\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\tif (verify_cidr(cidr)){\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb: subnet value is invalid\");\n\t\treturn LDB_ERR_INVALID_DN_SYNTAX;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n\nstatic char *refer_if_rodc(struct ldb_context *ldb, struct ldb_request *req,\n\t\t\t   struct ldb_dn *dn)\n{\n\tbool rodc = false;\n\tstruct loadparm_context *lp_ctx;\n\tchar *referral;\n\tint ret;\n\tWERROR err;\n\n\tif (ldb_request_get_control(req, DSDB_CONTROL_REPLICATED_UPDATE_OID) ||\n\t    ldb_request_get_control(req, DSDB_CONTROL_DBCHECK_MODIFY_RO_REPLICA)) {\n\t\treturn NULL;\n\t}\n\n\tret = samdb_rodc(ldb, &rodc);\n\tif (ret != LDB_SUCCESS) {\n\t\tDEBUG(4, (__location__ \": unable to tell if we are an RODC\\n\"));\n\t\treturn NULL;\n\t}\n\n\tif (rodc) {\n\t\tconst char *domain = NULL;\n\t\tstruct ldb_dn *fsmo_role_dn;\n\t\tstruct ldb_dn *role_owner_dn;\n\t\tldb_set_errstring(ldb, \"RODC modify is forbidden!\");\n\t\tlp_ctx = talloc_get_type(ldb_get_opaque(ldb, \"loadparm\"),\n\t\t\t\t\t struct loadparm_context);\n\n\t\terr = dsdb_get_fsmo_role_info(req, ldb, DREPL_PDC_MASTER,\n\t\t\t\t\t      &fsmo_role_dn, &role_owner_dn);\n\t\tif (W_ERROR_IS_OK(err)) {\n\t\t\tstruct ldb_dn *server_dn = ldb_dn_copy(req, role_owner_dn);\n\t\t\tif (server_dn != NULL) {\n\t\t\t\tldb_dn_remove_child_components(server_dn, 1);\n\n\t\t\t\tdomain = samdb_dn_to_dnshostname(ldb, req,\n\t\t\t\t\t\t\t\t server_dn);\n\t\t\t}\n\t\t}\n\t\tif (domain == NULL) {\n\t\t\tdomain = lpcfg_dnsdomain(lp_ctx);\n\t\t}\n\t\treferral = talloc_asprintf(req,\n\t\t\t\t\t   \"ldap://%s/%s\",\n\t\t\t\t\t   domain,\n\t\t\t\t\t   ldb_dn_get_linearized(dn));\n\t\treturn referral;\n\t}\n\n\treturn NULL;\n}\n\n/*\n * Restrict all access to sensitive attributes.\n *\n * We don't want to even inspect the values, so we can use the same\n * routine for ADD and MODIFY.\n *\n */\n\nstatic int samldb_check_sensitive_attributes(struct samldb_ctx *ac)\n{\n\tstruct ldb_message_element *el = NULL;\n\tstruct security_token *user_token = NULL;\n\tint ret;\n\n\tif (dsdb_module_am_system(ac->module)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tuser_token = acl_user_token(ac->module);\n\tif (user_token == NULL) {\n\t\treturn LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"sidHistory\");\n\tif (el) {\n               /*\n                * sidHistory is restricted to the (not implemented\n                * yet in Samba) DsAddSidHistory call (direct LDB access is\n                * as SYSTEM so will bypass this).\n\t\t*\n\t\t* If you want to modify this, say to merge domains,\n\t\t* directly modify the sam.ldb as root.\n                */\n\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t       \"sidHistory \"\n\t\t\t\t       \"(entry %s) cannot be created \"\n\t\t\t\t       \"or changed over LDAP!\",\n\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn));\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"msDS-SecondaryKrbTgtNumber\");\n\tif (el) {\n\t\tstruct security_descriptor *domain_sd;\n\t\tconst struct dsdb_class *objectclass = NULL;\n\t\t/*\n\t\t * msDS-SecondaryKrbTgtNumber allows the creator to\n\t\t * become an RODC, this is trusted as an RODC\n\t\t * account\n\t\t */\n\t\tret = samldb_get_domain_secdesc_and_oc(ac, &domain_sd, &objectclass);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t\tret = acl_check_extended_right(ac,\n\t\t\t\t\t       ac->module,\n\t\t\t\t\t       ac->req,\n\t\t\t\t\t       objectclass,\n\t\t\t\t\t       domain_sd,\n\t\t\t\t\t       user_token,\n\t\t\t\t\t       GUID_DRS_DS_INSTALL_REPLICA,\n\t\t\t\t\t       SEC_ADS_CONTROL_ACCESS,\n\t\t\t\t\t       NULL);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t\t       \"msDS-SecondaryKrbTgtNumber \"\n\t\t\t\t\t       \"(entry %s) cannot be created \"\n\t\t\t\t\t       \"or changed without \"\n\t\t\t\t\t       \"DS-Install-Replica extended right!\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"msDS-AllowedToDelegateTo\");\n\tif (el) {\n\t\t/*\n\t\t * msDS-AllowedToDelegateTo is incredibly powerful,\n\t\t * given that it allows a server to become ANY USER on\n\t\t * the target server only listed by SPN so needs to be\n\t\t * protected just as the userAccountControl\n\t\t * UF_TRUSTED_FOR_DELEGATION is.\n\t\t */\n\n\t\tbool have_priv = security_token_has_privilege(user_token,\n\t\t\t\t\t\t\t      SEC_PRIV_ENABLE_DELEGATION);\n\t\tif (have_priv == false) {\n\t\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t\t       \"msDS-AllowedToDelegateTo \"\n\t\t\t\t\t       \"(entry %s) cannot be created \"\n\t\t\t\t\t       \"or changed without SePrivEnableDelegation!\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn));\n\t\t\treturn LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n\t\t}\n\t}\n\treturn LDB_SUCCESS;\n}\n/* add */\nstatic int samldb_add(struct ldb_module *module, struct ldb_request *req)\n{\n\tstruct ldb_context *ldb;\n\tstruct samldb_ctx *ac;\n\tstruct ldb_message_element *el;\n\tint ret;\n\tchar *referral = NULL;\n\n\tldb = ldb_module_get_ctx(module);\n\tldb_debug(ldb, LDB_DEBUG_TRACE, \"samldb_add\\n\");\n\n\t/* do not manipulate our control entries */\n\tif (ldb_dn_is_special(req->op.add.message->dn)) {\n\t\treturn ldb_next_request(module, req);\n\t}\n\n\treferral = refer_if_rodc(ldb, req, req->op.add.message->dn);\n\tif (referral != NULL) {\n\t\tret = ldb_module_send_referral(req, referral);\n\t\treturn ret;\n\t}\n\n\tel = ldb_msg_find_element(req->op.add.message, \"userParameters\");\n\tif (el != NULL && ldb_req_is_untrusted(req)) {\n\t\tconst char *reason = \"samldb_add: \"\n\t\t\t\"setting userParameters is not supported over LDAP, \"\n\t\t\t\"see https://bugzilla.samba.org/show_bug.cgi?id=8077\";\n\t\tldb_debug(ldb, LDB_DEBUG_WARNING, \"%s\", reason);\n\t\treturn ldb_error(ldb, LDB_ERR_CONSTRAINT_VIOLATION, reason);\n\t}\n\n\tac = samldb_ctx_init(module, req);\n\tif (ac == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\t/* build the new msg */\n\tac->msg = ldb_msg_copy_shallow(ac, req->op.add.message);\n\tif (ac->msg == NULL) {\n\t\ttalloc_free(ac);\n\t\tldb_debug(ldb, LDB_DEBUG_FATAL,\n\t\t\t  \"samldb_add: ldb_msg_copy_shallow failed!\\n\");\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = samldb_check_sensitive_attributes(ac);\n\tif (ret != LDB_SUCCESS) {\n\t\ttalloc_free(ac);\n\t\treturn ret;\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"fSMORoleOwner\");\n\tif (el != NULL) {\n\t\tret = samldb_fsmo_role_owner_check(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"servicePrincipalName\");\n\tif ((el != NULL)) {\n\t\t/*\n\t\t * We need to check whether the SPN collides with an existing\n\t\t * one (anywhere) including via aliases.\n\t\t */\n\t\tret = samldb_spn_uniqueness_check(ac, el);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (samdb_find_attribute(ldb, ac->msg,\n\t\t\t\t \"objectclass\", \"user\") != NULL) {\n\t\tac->type = SAMLDB_TYPE_USER;\n\n\t\tret = samldb_prim_group_trigger(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = samldb_objectclass_trigger(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn samldb_fill_object(ac);\n\t}\n\n\tif (samdb_find_attribute(ldb, ac->msg,\n\t\t\t\t \"objectclass\", \"group\") != NULL) {\n\t\tac->type = SAMLDB_TYPE_GROUP;\n\n\t\tret = samldb_objectclass_trigger(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn samldb_fill_object(ac);\n\t}\n\n\t/* perhaps a foreignSecurityPrincipal? */\n\tif (samdb_find_attribute(ldb, ac->msg,\n\t\t\t\t \"objectclass\",\n\t\t\t\t \"foreignSecurityPrincipal\") != NULL) {\n\t\treturn samldb_fill_foreignSecurityPrincipal_object(ac);\n\t}\n\n\tif (samdb_find_attribute(ldb, ac->msg,\n\t\t\t\t \"objectclass\", \"classSchema\") != NULL) {\n\t\tac->type = SAMLDB_TYPE_CLASS;\n\n\t\t/* If in provision, these checks are too slow to do */\n\t\tif (!ldb_request_get_control(req, DSDB_CONTROL_SKIP_DUPLICATES_CHECK_OID)) {\n\t\t\tret = samldb_schema_governsid_valid_check(ac);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = samldb_schema_ldapdisplayname_valid_check(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = samldb_schema_info_update(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\ttalloc_free(ac);\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn samldb_fill_object(ac);\n\t}\n\n\tif (samdb_find_attribute(ldb, ac->msg,\n\t\t\t\t \"objectclass\", \"attributeSchema\") != NULL) {\n\t\tac->type = SAMLDB_TYPE_ATTRIBUTE;\n\n\t\t/* If in provision, these checks are too slow to do */\n\t\tif (!ldb_request_get_control(req, DSDB_CONTROL_SKIP_DUPLICATES_CHECK_OID)) {\n\t\t\tret = samldb_schema_attributeid_valid_check(ac);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = samldb_schema_add_handle_linkid(ac);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = samldb_schema_add_handle_mapiid(ac);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = samldb_schema_ldapdisplayname_valid_check(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = samldb_schema_info_update(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\ttalloc_free(ac);\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn samldb_fill_object(ac);\n\t}\n\n\tif (samdb_find_attribute(ldb, ac->msg,\n\t\t\t\t \"objectclass\", \"subnet\") != NULL) {\n\t\tret = samldb_verify_subnet(ac, ac->msg->dn);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\ttalloc_free(ac);\n\t\t\treturn ret;\n\t\t}\n\t\t/* We are just checking the value is valid, and there are no\n\t\t   values to fill in. */\n\t}\n\n\ttalloc_free(ac);\n\n\t/* nothing matched, go on */\n\treturn ldb_next_request(module, req);\n}\n\n/* modify */\nstatic int samldb_modify(struct ldb_module *module, struct ldb_request *req)\n{\n\tstruct ldb_context *ldb;\n\tstruct samldb_ctx *ac;\n\tstruct ldb_message_element *el, *el2;\n\tstruct ldb_control *is_undelete;\n\tbool modified = false;\n\tint ret;\n\n\tif (ldb_dn_is_special(req->op.mod.message->dn)) {\n\t\t/* do not manipulate our control entries */\n\t\treturn ldb_next_request(module, req);\n\t}\n\n\tldb = ldb_module_get_ctx(module);\n\n\t/*\n\t * we are going to need some special handling if in Undelete call.\n\t * Since tombstone_reanimate module will restore certain attributes,\n\t * we need to relax checks for: sAMAccountType, primaryGroupID\n\t */\n\tis_undelete = ldb_request_get_control(req, DSDB_CONTROL_RESTORE_TOMBSTONE_OID);\n\n\t/* make sure that \"objectSid\" is not specified */\n\tel = ldb_msg_find_element(req->op.mod.message, \"objectSid\");\n\tif (el != NULL) {\n\t\tif (ldb_request_get_control(req, LDB_CONTROL_PROVISION_OID) == NULL) {\n\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t  \"samldb: objectSid must not be specified!\");\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\t}\n\tif (is_undelete == NULL) {\n\t\t/* make sure that \"sAMAccountType\" is not specified */\n\t\tel = ldb_msg_find_element(req->op.mod.message, \"sAMAccountType\");\n\t\tif (el != NULL) {\n\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t  \"samldb: sAMAccountType must not be specified!\");\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\t}\n\t/* make sure that \"isCriticalSystemObject\" is not specified */\n\tel = ldb_msg_find_element(req->op.mod.message, \"isCriticalSystemObject\");\n\tif (el != NULL) {\n\t\tif (ldb_request_get_control(req, LDB_CONTROL_RELAX_OID) == NULL) {\n\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t  \"samldb: isCriticalSystemObject must not be specified!\");\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\t}\n\n\t/* msDS-IntId is not allowed to be modified\n\t * except when modification comes from replication */\n\tif (ldb_msg_find_element(req->op.mod.message, \"msDS-IntId\")) {\n\t\tif (!ldb_request_get_control(req,\n\t\t\t\t\t     DSDB_CONTROL_REPLICATED_UPDATE_OID)) {\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(req->op.mod.message, \"userParameters\");\n\tif (el != NULL && ldb_req_is_untrusted(req)) {\n\t\tconst char *reason = \"samldb: \"\n\t\t\t\"setting userParameters is not supported over LDAP, \"\n\t\t\t\"see https://bugzilla.samba.org/show_bug.cgi?id=8077\";\n\t\tldb_debug(ldb, LDB_DEBUG_WARNING, \"%s\", reason);\n\t\treturn ldb_error(ldb, LDB_ERR_CONSTRAINT_VIOLATION, reason);\n\t}\n\n\tac = samldb_ctx_init(module, req);\n\tif (ac == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\t/* build the new msg */\n\tac->msg = ldb_msg_copy_shallow(ac, req->op.mod.message);\n\tif (ac->msg == NULL) {\n\t\ttalloc_free(ac);\n\t\tldb_debug(ldb, LDB_DEBUG_FATAL,\n\t\t\t  \"samldb_modify: ldb_msg_copy_shallow failed!\\n\");\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = samldb_check_sensitive_attributes(ac);\n\tif (ret != LDB_SUCCESS) {\n\t\ttalloc_free(ac);\n\t\treturn ret;\n\t}\n\n\tif (is_undelete == NULL) {\n\t\tel = ldb_msg_find_element(ac->msg, \"primaryGroupID\");\n\t\tif (el != NULL) {\n\t\t\tret = samldb_prim_group_trigger(ac);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"userAccountControl\");\n\tif (el != NULL) {\n\t\tmodified = true;\n\t\tret = samldb_user_account_control_change(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"pwdLastSet\");\n\tif (el != NULL) {\n\t\tmodified = true;\n\t\tret = samldb_pwd_last_set_change(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"lockoutTime\");\n\tif (el != NULL) {\n\t\tmodified = true;\n\t\tret = samldb_lockout_time(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"groupType\");\n\tif (el != NULL) {\n\t\tmodified = true;\n\t\tret = samldb_group_type_change(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"sAMAccountName\");\n\tif (el != NULL) {\n\t\tuint32_t user_account_control;\n\t\tstruct ldb_result *res = NULL;\n\t\tconst char * const attrs[] = { \"userAccountControl\",\n\t\t\t\t\t       \"objectclass\",\n\t\t\t\t\t       NULL };\n\t\tret = dsdb_module_search_dn(ac->module,\n\t\t\t\t\t    ac,\n\t\t\t\t\t    &res,\n\t\t\t\t\t    ac->msg->dn,\n\t\t\t\t\t    attrs,\n\t\t\t\t\t    DSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED,\n\t\t\t\t\t    ac->req);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t\tuser_account_control\n\t\t\t= ldb_msg_find_attr_as_uint(res->msgs[0],\n\t\t\t\t\t\t    \"userAccountControl\",\n\t\t\t\t\t\t    0);\n\n\t\tif ((user_account_control\n\t\t     & UF_TRUST_ACCOUNT_MASK) != 0) {\n\t\t\tac->need_trailing_dollar = true;\n\n\t\t} else if (samdb_find_attribute(ldb,\n\t\t\t\t\t\tres->msgs[0],\n\t\t\t\t\t\t\"objectclass\",\n\t\t\t\t\t\t\"computer\")\n\t\t\t   != NULL) {\n\t\t\tac->need_trailing_dollar = true;\n\t\t}\n\n\t\tret = samldb_sam_accountname_valid_check(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"userPrincipalName\");\n\tif (el != NULL) {\n\t\tret = samldb_sam_account_upn_clash(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\ttalloc_free(ac);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"ldapDisplayName\");\n\tif (el != NULL) {\n\t\tret = samldb_schema_ldapdisplayname_valid_check(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"attributeID\");\n\tif (el != NULL) {\n\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t       \"Once set, attributeID values may not be modified\");\n\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"governsID\");\n\tif (el != NULL) {\n\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t       \"Once set, governsID values may not be modified\");\n\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"member\");\n\tif (el != NULL) {\n\t\tstruct ldb_control *fix_link_sid_ctrl = NULL;\n\n\t\tfix_link_sid_ctrl = ldb_request_get_control(ac->req,\n\t\t\t\t\tDSDB_CONTROL_DBCHECK_FIX_LINK_DN_SID);\n\t\tif (fix_link_sid_ctrl == NULL) {\n\t\t\tret = samldb_member_check(ac);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"description\");\n\tif (el != NULL) {\n\t\tret = samldb_description_check(ac, &modified);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"dNSHostName\");\n\tel2 = ldb_msg_find_element(ac->msg, \"sAMAccountName\");\n\tif ((el != NULL) || (el2 != NULL)) {\n\t\tmodified = true;\n\t\t/*\n\t\t * samldb_service_principal_names_change() might add SPN\n\t\t * changes to the request, so this must come before the SPN\n\t\t * uniqueness check below.\n\t\t *\n\t\t * Note we ALSO have to do the SPN uniqueness check inside\n\t\t * samldb_service_principal_names_change(), because it does a\n\t\t * subrequest to do requested SPN modifications *before* its\n\t\t * automatic ones are added.\n\t\t */\n\t\tret = samldb_service_principal_names_change(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"servicePrincipalName\");\n\tif ((el != NULL)) {\n\t\t/*\n\t\t * We need to check whether the SPN collides with an existing\n\t\t * one (anywhere) including via aliases.\n\t\t */\n\t\tmodified = true;\n\t\tret = samldb_spn_uniqueness_check(ac, el);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"fSMORoleOwner\");\n\tif (el != NULL) {\n\t\tret = samldb_fsmo_role_owner_check(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (modified) {\n\t\tstruct ldb_request *child_req;\n\n\t\t/* Now perform the real modifications as a child request */\n\t\tret = ldb_build_mod_req(&child_req, ldb, ac,\n\t\t\t\t\tac->msg,\n\t\t\t\t\treq->controls,\n\t\t\t\t\treq, dsdb_next_callback,\n\t\t\t\t\treq);\n\t\tLDB_REQ_SET_LOCATION(child_req);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn ldb_next_request(module, child_req);\n\t}\n\n\ttalloc_free(ac);\n\n\t/* no change which interests us, go on */\n\treturn ldb_next_request(module, req);\n}\n\n/* delete */\n\nstatic int samldb_prim_group_users_check(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb;\n\tstruct dom_sid *sid;\n\tuint32_t rid;\n\tNTSTATUS status;\n\tint ret;\n\tstruct ldb_result *res = NULL;\n\tstruct ldb_result *res_users = NULL;\n\tconst char * const attrs[] = { \"objectSid\", \"isDeleted\", NULL };\n\tconst char * const noattrs[] = { NULL };\n\n\tldb = ldb_module_get_ctx(ac->module);\n\n\t/* Finds out the SID/RID of the SAM object */\n\tret = dsdb_module_search_dn(ac->module, ac, &res, ac->req->op.del.dn,\n\t\t\t\t\tattrs,\n\t\t\t\t\tDSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED,\n\t\t\t\t\tac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (ldb_msg_check_string_attribute(res->msgs[0], \"isDeleted\", \"TRUE\")) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tsid = samdb_result_dom_sid(ac, res->msgs[0], \"objectSid\");\n\tif (sid == NULL) {\n\t\t/* No SID - it might not be a SAM object - therefore ok */\n\t\treturn LDB_SUCCESS;\n\t}\n\tstatus = dom_sid_split_rid(ac, sid, NULL, &rid);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\treturn ldb_operr(ldb);\n\t}\n\tif (rid == 0) {\n\t\t/* Special object (security principal?) */\n\t\treturn LDB_SUCCESS;\n\t}\n\t/* do not allow deletion of well-known sids */\n\tif (rid < DSDB_SAMDB_MINIMUM_ALLOWED_RID &&\n\t    (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID) == NULL)) {\n\t\treturn LDB_ERR_OTHER;\n\t}\n\n\t/* Deny delete requests from groups which are primary ones */\n\tret = dsdb_module_search(ac->module, ac, &res_users,\n\t\t\t\t ldb_get_default_basedn(ldb),\n\t\t\t\t LDB_SCOPE_SUBTREE, noattrs,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(&(primaryGroupID=%u)(objectClass=user))\", rid);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (res_users->count > 0) {\n\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t       \"Refusing to delete %s, as it \"\n\t\t\t\t       \"is still the primaryGroupID \"\n\t\t\t\t       \"for %u users\",\n\t\t\t\t       ldb_dn_get_linearized(res->msgs[0]->dn),\n\t\t\t\t       res_users->count);\n\n\t\t/*\n\t\t * Yes, this seems very wrong, but we have a test\n\t\t * for this exact error code in sam.py\n\t\t */\n\t\treturn LDB_ERR_ENTRY_ALREADY_EXISTS;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_delete(struct ldb_module *module, struct ldb_request *req)\n{\n\tstruct samldb_ctx *ac;\n\tchar *referral = NULL;\n\tint ret;\n\tstruct ldb_context *ldb;\n\n\tif (ldb_dn_is_special(req->op.del.dn)) {\n\t\t/* do not manipulate our control entries */\n\t\treturn ldb_next_request(module, req);\n\t}\n\n\tldb = ldb_module_get_ctx(module);\n\n\treferral = refer_if_rodc(ldb, req, req->op.del.dn);\n\tif (referral != NULL) {\n\t\tret = ldb_module_send_referral(req, referral);\n\t\treturn ret;\n\t}\n\n\tac = samldb_ctx_init(module, req);\n\tif (ac == NULL) {\n\t\treturn ldb_operr(ldb_module_get_ctx(module));\n\t}\n\n\tret = samldb_prim_group_users_check(ac);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\ttalloc_free(ac);\n\n\treturn ldb_next_request(module, req);\n}\n\n/* rename */\n\nstatic int check_rename_constraints(struct ldb_message *msg,\n\t\t\t\t    struct samldb_ctx *ac,\n\t\t\t\t    struct ldb_dn *olddn, struct ldb_dn *newdn)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tstruct ldb_dn *dn1, *dn2, *nc_root;\n\tint32_t systemFlags;\n\tbool move_op = false;\n\tbool rename_op = false;\n\tint ret;\n\n\t/* Skip the checks if old and new DN are the same, or if we have the\n\t * relax control specified or if the returned objects is already\n\t * deleted and needs only to be moved for consistency. */\n\n\tif (ldb_dn_compare(olddn, newdn) == 0) {\n\t\treturn LDB_SUCCESS;\n\t}\n\tif (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID) != NULL) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tif (ldb_msg_find_attr_as_bool(msg, \"isDeleted\", false)) {\n\t\t/*\n\t\t * check originating request if we are supposed\n\t\t * to \"see\" this record in first place.\n\t\t */\n\t\tif (ldb_request_get_control(ac->req, LDB_CONTROL_SHOW_DELETED_OID) == NULL) {\n\t\t\treturn LDB_ERR_NO_SUCH_OBJECT;\n\t\t}\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t/* Objects under CN=System */\n\n\tdn1 = ldb_dn_copy(ac, ldb_get_default_basedn(ldb));\n\tif (dn1 == NULL) return ldb_oom(ldb);\n\n\tif ( ! ldb_dn_add_child_fmt(dn1, \"CN=System\")) {\n\t\ttalloc_free(dn1);\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n\n\tif ((ldb_dn_compare_base(dn1, olddn) == 0) &&\n\t    (ldb_dn_compare_base(dn1, newdn) != 0)) {\n\t\ttalloc_free(dn1);\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"subtree_rename: Cannot move/rename %s. Objects under CN=System have to stay under it!\",\n\t\t\t\t       ldb_dn_get_linearized(olddn));\n\t\treturn LDB_ERR_OTHER;\n\t}\n\n\ttalloc_free(dn1);\n\n\t/* LSA objects */\n\n\tif ((samdb_find_attribute(ldb, msg, \"objectClass\", \"secret\") != NULL) ||\n\t    (samdb_find_attribute(ldb, msg, \"objectClass\", \"trustedDomain\") != NULL)) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"subtree_rename: Cannot move/rename %s. It's an LSA-specific object!\",\n\t\t\t\t       ldb_dn_get_linearized(olddn));\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t/* subnet objects */\n\tif (samdb_find_attribute(ldb, msg, \"objectclass\", \"subnet\") != NULL) {\n\t\tret = samldb_verify_subnet(ac, newdn);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* systemFlags */\n\n\tdn1 = ldb_dn_get_parent(ac, olddn);\n\tif (dn1 == NULL) return ldb_oom(ldb);\n\tdn2 = ldb_dn_get_parent(ac, newdn);\n\tif (dn2 == NULL) return ldb_oom(ldb);\n\n\tif (ldb_dn_compare(dn1, dn2) == 0) {\n\t\trename_op = true;\n\t} else {\n\t\tmove_op = true;\n\t}\n\n\ttalloc_free(dn1);\n\ttalloc_free(dn2);\n\n\tsystemFlags = ldb_msg_find_attr_as_int(msg, \"systemFlags\", 0);\n\n\t/* Fetch name context */\n\n\tret = dsdb_find_nc_root(ldb, ac, olddn, &nc_root);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (ldb_dn_compare(nc_root, ldb_get_schema_basedn(ldb)) == 0) {\n\t\tif (move_op) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"subtree_rename: Cannot move %s within schema partition\",\n\t\t\t\t\t       ldb_dn_get_linearized(olddn));\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\t\tif (rename_op &&\n\t\t    (systemFlags & SYSTEM_FLAG_SCHEMA_BASE_OBJECT) != 0) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"subtree_rename: Cannot rename %s within schema partition\",\n\t\t\t\t\t       ldb_dn_get_linearized(olddn));\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\t} else if (ldb_dn_compare(nc_root, ldb_get_config_basedn(ldb)) == 0) {\n\t\tif (move_op &&\n\t\t    (systemFlags & SYSTEM_FLAG_CONFIG_ALLOW_MOVE) == 0) {\n\t\t\t/* Here we have to do more: control the\n\t\t\t * \"ALLOW_LIMITED_MOVE\" flag. This means that the\n\t\t\t * grand-grand-parents of two objects have to be equal\n\t\t\t * in order to perform the move (this is used for\n\t\t\t * moving \"server\" objects in the \"sites\" container). */\n\t\t\tbool limited_move =\n\t\t\t\tsystemFlags & SYSTEM_FLAG_CONFIG_ALLOW_LIMITED_MOVE;\n\n\t\t\tif (limited_move) {\n\t\t\t\tdn1 = ldb_dn_copy(ac, olddn);\n\t\t\t\tif (dn1 == NULL) return ldb_oom(ldb);\n\t\t\t\tdn2 = ldb_dn_copy(ac, newdn);\n\t\t\t\tif (dn2 == NULL) return ldb_oom(ldb);\n\n\t\t\t\tlimited_move &= ldb_dn_remove_child_components(dn1, 3);\n\t\t\t\tlimited_move &= ldb_dn_remove_child_components(dn2, 3);\n\t\t\t\tlimited_move &= ldb_dn_compare(dn1, dn2) == 0;\n\n\t\t\t\ttalloc_free(dn1);\n\t\t\t\ttalloc_free(dn2);\n\t\t\t}\n\n\t\t\tif (!limited_move\n\t\t\t    && ldb_request_get_control(ac->req, DSDB_CONTROL_RESTORE_TOMBSTONE_OID) == NULL) {\n\t\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t\t       \"subtree_rename: Cannot move %s to %s in config partition\",\n\t\t\t\t\t\t       ldb_dn_get_linearized(olddn), ldb_dn_get_linearized(newdn));\n\t\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t\t}\n\t\t}\n\t\tif (rename_op &&\n\t\t    (systemFlags & SYSTEM_FLAG_CONFIG_ALLOW_RENAME) == 0) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"subtree_rename: Cannot rename %s to %s within config partition\",\n\t\t\t\t\t       ldb_dn_get_linearized(olddn), ldb_dn_get_linearized(newdn));\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\t} else if (ldb_dn_compare(nc_root, ldb_get_default_basedn(ldb)) == 0) {\n\t\tif (move_op &&\n\t\t    (systemFlags & SYSTEM_FLAG_DOMAIN_DISALLOW_MOVE) != 0) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"subtree_rename: Cannot move %s to %s - DISALLOW_MOVE set\",\n\t\t\t\t\t       ldb_dn_get_linearized(olddn), ldb_dn_get_linearized(newdn));\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\t\tif (rename_op &&\n\t\t    (systemFlags & SYSTEM_FLAG_DOMAIN_DISALLOW_RENAME) != 0) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t\t       \"subtree_rename: Cannot rename %s to %s - DISALLOW_RENAME set\",\n\t\t\t\t\t       ldb_dn_get_linearized(olddn), ldb_dn_get_linearized(newdn));\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\t}\n\n\ttalloc_free(nc_root);\n\n\treturn LDB_SUCCESS;\n}\n\n\nstatic int samldb_rename_search_base_callback(struct ldb_request *req,\n\t\t\t\t\t       struct ldb_reply *ares)\n{\n\tstruct samldb_ctx *ac;\n\tint ret;\n\n\tac = talloc_get_type(req->context, struct samldb_ctx);\n\n\tif (!ares) {\n\t\treturn ldb_module_done(ac->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\tif (ares->error != LDB_SUCCESS) {\n\t\treturn ldb_module_done(ac->req, ares->controls,\n\t\t\t\t\tares->response, ares->error);\n\t}\n\n\tswitch (ares->type) {\n\tcase LDB_REPLY_ENTRY:\n\t\t/*\n\t\t * This is the root entry of the originating move\n\t\t * respectively rename request. It has been already\n\t\t * stored in the list using \"subtree_rename_search()\".\n\t\t * Only this one is subject to constraint checking.\n\t\t */\n\t\tret = check_rename_constraints(ares->message, ac,\n\t\t\t\t\t       ac->req->op.rename.olddn,\n\t\t\t\t\t       ac->req->op.rename.newdn);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ldb_module_done(ac->req, NULL, NULL,\n\t\t\t\t\t       ret);\n\t\t}\n\t\tbreak;\n\n\tcase LDB_REPLY_REFERRAL:\n\t\t/* ignore */\n\t\tbreak;\n\n\tcase LDB_REPLY_DONE:\n\n\t\t/*\n\t\t * Great, no problem with the rename, so go ahead as\n\t\t * if we never were here\n\t\t */\n\t\tret = ldb_next_request(ac->module, ac->req);\n\t\ttalloc_free(ares);\n\t\treturn ret;\n\t}\n\n\ttalloc_free(ares);\n\treturn LDB_SUCCESS;\n}\n\n\n/* rename */\nstatic int samldb_rename(struct ldb_module *module, struct ldb_request *req)\n{\n\tstruct ldb_context *ldb;\n\tstatic const char * const attrs[] = { \"objectClass\", \"systemFlags\",\n\t\t\t\t\t      \"isDeleted\", NULL };\n\tstruct ldb_request *search_req;\n\tstruct samldb_ctx *ac;\n\tint ret;\n\n\tif (ldb_dn_is_special(req->op.rename.olddn)) { /* do not manipulate our control entries */\n\t\treturn ldb_next_request(module, req);\n\t}\n\n\tldb = ldb_module_get_ctx(module);\n\n\tac = samldb_ctx_init(module, req);\n\tif (!ac) {\n\t\treturn ldb_oom(ldb);\n\t}\n\n\tret = ldb_build_search_req(&search_req, ldb, ac,\n\t\t\t\t   req->op.rename.olddn,\n\t\t\t\t   LDB_SCOPE_BASE,\n\t\t\t\t   \"(objectClass=*)\",\n\t\t\t\t   attrs,\n\t\t\t\t   NULL,\n\t\t\t\t   ac,\n\t\t\t\t   samldb_rename_search_base_callback,\n\t\t\t\t   req);\n\tLDB_REQ_SET_LOCATION(search_req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = ldb_request_add_control(search_req, LDB_CONTROL_SHOW_RECYCLED_OID,\n\t\t\t\t      true, NULL);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ldb_next_request(ac->module, search_req);\n}\n\n/* extended */\n\nstatic int samldb_extended_allocate_rid_pool(struct ldb_module *module, struct ldb_request *req)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(module);\n\tstruct dsdb_fsmo_extended_op *exop;\n\tint ret;\n\n\texop = talloc_get_type(req->op.extended.data,\n\t\t\t       struct dsdb_fsmo_extended_op);\n\tif (!exop) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb_extended_allocate_rid_pool: invalid extended data\");\n\t\treturn LDB_ERR_PROTOCOL_ERROR;\n\t}\n\n\tret = ridalloc_allocate_rid_pool_fsmo(module, exop, req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ldb_module_done(req, NULL, NULL, LDB_SUCCESS);\n}\n\nstatic int samldb_extended_allocate_rid(struct ldb_module *module, struct ldb_request *req)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(module);\n\tstruct dsdb_extended_allocate_rid *exop;\n\tint ret;\n\n\texop = talloc_get_type(req->op.extended.data,\n\t\t\t       struct dsdb_extended_allocate_rid);\n\tif (!exop) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb_extended_allocate_rid: invalid extended data\");\n\t\treturn LDB_ERR_PROTOCOL_ERROR;\n\t}\n\n\tret = ridalloc_allocate_rid(module, &exop->rid, req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ldb_module_done(req, NULL, NULL, LDB_SUCCESS);\n}\n\nstatic int samldb_extended_create_own_rid_set(struct ldb_module *module, struct ldb_request *req)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(module);\n\tint ret;\n\tstruct ldb_dn *dn;\n\n\tif (req->op.extended.data != NULL) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb_extended_create_own_rid_set: invalid extended data (should be NULL)\");\n\t\treturn LDB_ERR_PROTOCOL_ERROR;\n\t}\n\n\tret = ridalloc_create_own_rid_set(module, req,\n\t\t\t\t\t  &dn, req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ldb_module_done(req, NULL, NULL, LDB_SUCCESS);\n}\n\nstatic int samldb_extended(struct ldb_module *module, struct ldb_request *req)\n{\n\tif (strcmp(req->op.extended.oid, DSDB_EXTENDED_ALLOCATE_RID_POOL) == 0) {\n\t\treturn samldb_extended_allocate_rid_pool(module, req);\n\t}\n\n\tif (strcmp(req->op.extended.oid, DSDB_EXTENDED_ALLOCATE_RID) == 0) {\n\t\treturn samldb_extended_allocate_rid(module, req);\n\t}\n\n\tif (strcmp(req->op.extended.oid, DSDB_EXTENDED_CREATE_OWN_RID_SET) == 0) {\n\t\treturn samldb_extended_create_own_rid_set(module, req);\n\t}\n\n\treturn ldb_next_request(module, req);\n}\n\n\nstatic const struct ldb_module_ops ldb_samldb_module_ops = {\n\t.name          = \"samldb\",\n\t.add           = samldb_add,\n\t.modify        = samldb_modify,\n\t.del           = samldb_delete,\n\t.rename        = samldb_rename,\n\t.extended      = samldb_extended\n};\n\n\nint ldb_samldb_module_init(const char *version)\n{\n\tLDB_MODULE_CHECK_VERSION(version);\n\treturn ldb_register_module(&ldb_samldb_module_ops);\n}\n"], "fixing_code": ["samba.tests.ldap_spn.+LdapSpnTest.test_spn_dodgy_spns\n", "/*\n   SAM ldb module\n\n   Copyright (C) Andrew Bartlett <abartlet@samba.org> 2005-2014\n   Copyright (C) Simo Sorce  2004-2008\n   Copyright (C) Matthias Dieter Walln\u00f6fer 2009-2011\n   Copyright (C) Matthieu Patou 2012\n   Copyright (C) Catalyst.Net Ltd 2017\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\n *  Name: ldb\n *\n *  Component: ldb samldb module\n *\n *  Description: various internal DSDB triggers - most for SAM specific objects\n *\n *  Author: Simo Sorce\n */\n\n#include \"includes.h\"\n#include \"libcli/ldap/ldap_ndr.h\"\n#include \"ldb_module.h\"\n#include \"auth/auth.h\"\n#include \"dsdb/samdb/samdb.h\"\n#include \"dsdb/samdb/ldb_modules/util.h\"\n#include \"dsdb/samdb/ldb_modules/ridalloc.h\"\n#include \"libcli/security/security.h\"\n#include \"librpc/gen_ndr/ndr_security.h\"\n#include \"ldb_wrap.h\"\n#include \"param/param.h\"\n#include \"libds/common/flag_mapping.h\"\n#include \"system/network.h\"\n#include \"librpc/gen_ndr/irpc.h\"\n#include \"lib/util/smb_strtox.h\"\n\n#undef strcasecmp\n\nstruct samldb_ctx;\nenum samldb_add_type {\n\tSAMLDB_TYPE_USER,\n\tSAMLDB_TYPE_GROUP,\n\tSAMLDB_TYPE_CLASS,\n\tSAMLDB_TYPE_ATTRIBUTE\n};\n\ntypedef int (*samldb_step_fn_t)(struct samldb_ctx *);\n\nstruct samldb_step {\n\tstruct samldb_step *next;\n\tsamldb_step_fn_t fn;\n};\n\nstruct samldb_ctx {\n\tstruct ldb_module *module;\n\tstruct ldb_request *req;\n\n\t/* used for add operations */\n\tenum samldb_add_type type;\n\n\t/*\n\t * should we apply the need_trailing_dollar restriction to\n\t * samAccountName\n\t */\n\n\tbool need_trailing_dollar;\n\n\t/* the resulting message */\n\tstruct ldb_message *msg;\n\n\t/* used in \"samldb_find_for_defaultObjectCategory\" */\n\tstruct ldb_dn *dn, *res_dn;\n\n\t/* all the async steps necessary to complete the operation */\n\tstruct samldb_step *steps;\n\tstruct samldb_step *curstep;\n\n\t/* If someone set an ares to forward controls and response back to the caller */\n\tstruct ldb_reply *ares;\n};\n\nstatic struct samldb_ctx *samldb_ctx_init(struct ldb_module *module,\n\t\t\t\t\t  struct ldb_request *req)\n{\n\tstruct ldb_context *ldb;\n\tstruct samldb_ctx *ac;\n\n\tldb = ldb_module_get_ctx(module);\n\n\tac = talloc_zero(req, struct samldb_ctx);\n\tif (ac == NULL) {\n\t\tldb_oom(ldb);\n\t\treturn NULL;\n\t}\n\n\tac->module = module;\n\tac->req = req;\n\n\treturn ac;\n}\n\nstatic int samldb_add_step(struct samldb_ctx *ac, samldb_step_fn_t fn)\n{\n\tstruct samldb_step *step, *stepper;\n\n\tstep = talloc_zero(ac, struct samldb_step);\n\tif (step == NULL) {\n\t\treturn ldb_oom(ldb_module_get_ctx(ac->module));\n\t}\n\n\tstep->fn = fn;\n\n\tif (ac->steps == NULL) {\n\t\tac->steps = step;\n\t\tac->curstep = step;\n\t} else {\n\t\tif (ac->curstep == NULL)\n\t\t\treturn ldb_operr(ldb_module_get_ctx(ac->module));\n\t\tfor (stepper = ac->curstep; stepper->next != NULL;\n\t\t\tstepper = stepper->next);\n\t\tstepper->next = step;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_first_step(struct samldb_ctx *ac)\n{\n\tif (ac->steps == NULL) {\n\t\treturn ldb_operr(ldb_module_get_ctx(ac->module));\n\t}\n\n\tac->curstep = ac->steps;\n\treturn ac->curstep->fn(ac);\n}\n\nstatic int samldb_next_step(struct samldb_ctx *ac)\n{\n\tif (ac->curstep->next) {\n\t\tac->curstep = ac->curstep->next;\n\t\treturn ac->curstep->fn(ac);\n\t}\n\n\t/* We exit the samldb module here. If someone set an \"ares\" to forward\n\t * controls and response back to the caller, use them. */\n\tif (ac->ares) {\n\t\treturn ldb_module_done(ac->req, ac->ares->controls,\n\t\t\t\t       ac->ares->response, LDB_SUCCESS);\n\t} else {\n\t\treturn ldb_module_done(ac->req, NULL, NULL, LDB_SUCCESS);\n\t}\n}\n\nstatic int samldb_get_single_valued_attr(struct ldb_context *ldb,\n\t\t\t\t\t struct samldb_ctx *ac,\n\t\t\t\t\t const char *attr,\n\t\t\t\t\t const char **value)\n{\n\t/*\n\t * The steps we end up going through to get and check a single valued\n\t * attribute.\n\t */\n\tstruct ldb_message_element *el = NULL;\n\tint ret;\n\n\t*value = NULL;\n\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   attr,\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (el == NULL) {\n\t\t/* we are not affected */\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tif (el->num_values > 1) {\n\t\tldb_asprintf_errstring(\n\t\t\tldb,\n\t\t        \"samldb: %s has %u values, should be single-valued!\",\n\t\t\tattr, el->num_values);\n\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t} else if (el->num_values == 0) {\n\t\tldb_asprintf_errstring(\n\t\t\tldb,\n\t\t\t\"samldb: new value for %s \"\n\t\t\t\"not provided for mandatory, single-valued attribute!\",\n\t\t\tattr);\n\t\treturn LDB_ERR_OBJECT_CLASS_VIOLATION;\n\t}\n\n\n\tif (el->values[0].length == 0) {\n\t\tldb_asprintf_errstring(\n\t\t\tldb,\n\t\t\t\"samldb: %s is of zero length, should have a value!\",\n\t\t\tattr);\n\t\treturn LDB_ERR_OBJECT_CLASS_VIOLATION;\n\t}\n\n\t*value = (char *)el->values[0].data;\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_unique_attr_check(struct samldb_ctx *ac, const char *attr,\n\t\t\t\t    const char *attr_conflict,\n\t\t\t\t    struct ldb_dn *base_dn)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tconst char * const no_attrs[] = { NULL };\n\tstruct ldb_result *res = NULL;\n\tconst char *str = NULL;\n\tconst char *enc_str = NULL;\n\tint ret;\n\n\tret = samldb_get_single_valued_attr(ldb, ac, attr, &str);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (str == NULL) {\n\t\t/* the attribute wasn't found */\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tenc_str = ldb_binary_encode_string(ac, str);\n\tif (enc_str == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\n\t/*\n\t * No other object should have the attribute with this value.\n\t */\n\tif (attr_conflict != NULL) {\n\t\tret = dsdb_module_search(ac->module, ac, &res,\n\t\t\t\t\t base_dn,\n\t\t\t\t\t LDB_SCOPE_SUBTREE, no_attrs,\n\t\t\t\t\t DSDB_FLAG_NEXT_MODULE, ac->req,\n\t\t\t\t\t \"(|(%s=%s)(%s=%s))\",\n\t\t\t\t\t attr, enc_str,\n\t\t\t\t\t attr_conflict, enc_str);\n\t} else {\n\t\tret = dsdb_module_search(ac->module, ac, &res,\n\t\t\t\t\t base_dn,\n\t\t\t\t\t LDB_SCOPE_SUBTREE, no_attrs,\n\t\t\t\t\t DSDB_FLAG_NEXT_MODULE, ac->req,\n\t\t\t\t\t \"(%s=%s)\", attr, enc_str);\n\t}\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (res->count > 1) {\n\t\treturn ldb_operr(ldb);\n\t} else if (res->count == 1) {\n\t\tif (ldb_dn_compare(res->msgs[0]->dn, ac->msg->dn) != 0) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"samldb: %s '%s' already in use!\",\n\t\t\t\t\t       attr, enc_str);\n\t\t\treturn LDB_ERR_ENTRY_ALREADY_EXISTS;\n\t\t}\n\t}\n\ttalloc_free(res);\n\n\treturn LDB_SUCCESS;\n}\n\n\n\nstatic inline int samldb_sam_account_upn_clash_sub_search(\n\tstruct samldb_ctx *ac,\n\tTALLOC_CTX *mem_ctx,\n\tstruct ldb_dn *base_dn,\n\tconst char *attr,\n\tconst char *value,\n\tconst char *err_msg\n\t)\n{\n\t/*\n\t * A very specific helper function for samldb_sam_account_upn_clash(),\n\t * where we end up doing this same thing several times in a row.\n\t */\n\tconst char * const no_attrs[] = { NULL };\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tstruct ldb_result *res = NULL;\n\tint ret;\n\tchar *enc_value = ldb_binary_encode_string(ac, value);\n\tif (enc_value == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tret = dsdb_module_search(ac->module, mem_ctx, &res,\n\t\t\t\t base_dn,\n\t\t\t\t LDB_SCOPE_SUBTREE, no_attrs,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE, ac->req,\n\t\t\t\t \"(%s=%s)\",\n\t\t\t\t attr, enc_value);\n\ttalloc_free(enc_value);\n\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t} else if (res->count > 1) {\n\t\treturn ldb_operr(ldb);\n\t} else if (res->count == 1) {\n\t\tif (ldb_dn_compare(res->msgs[0]->dn, ac->msg->dn) != 0){\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"samldb: %s '%s' \"\n\t\t\t\t\t       \"is already in use %s\",\n\t\t\t\t\t       attr, value, err_msg);\n\t\t\t/* different errors for different attrs */\n\t\t\tif (strcasecmp(\"userPrincipalName\", attr) == 0) {\n\t\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t\t}\n\t\t\treturn LDB_ERR_ENTRY_ALREADY_EXISTS;\n\t\t}\n\t}\n\treturn LDB_SUCCESS;\n}\n\nstatic int samaccountname_bad_chars_check(struct samldb_ctx *ac,\n\t\t\t\t\t  const char *name)\n{\n\t/*\n\t * The rules here are based on\n\t *\n\t * https://social.technet.microsoft.com/wiki/contents/articles/11216.active-directory-requirements-for-creating-objects.aspx\n\t *\n\t * Windows considers UTF-8 sequences that map to \"similar\" characters\n\t * (e.g. 'a', '\u0101') to be the same sAMAccountName, and we don't. Names\n\t * that are not valid UTF-8 *are* allowed.\n\t *\n\t * Additionally, Samba collapses multiple spaces, and Windows doesn't.\n\t */\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tsize_t i;\n\n\tfor (i = 0; name[i] != '\\0'; i++) {\n\t\tuint8_t c = name[i];\n\t\tchar *p = NULL;\n\t\tif (c < 32 || c == 127) {\n\t\t\tldb_asprintf_errstring(\n\t\t\t\tldb,\n\t\t\t\t\"samldb: sAMAccountName contains invalid \"\n\t\t\t\t\"0x%.2x character\\n\", c);\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t\tp = strchr(\"\\\"[]:;|=+*?<>/\\\\,\", c);\n\t\tif (p != NULL) {\n\t\t\tldb_asprintf_errstring(\n\t\t\t\tldb,\n\t\t\t\t\"samldb: sAMAccountName contains invalid \"\n\t\t\t\t\"'%c' character\\n\", c);\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t}\n\n\tif (i == 0) {\n\t\tldb_asprintf_errstring(\n\t\t\tldb,\n\t\t\t\"samldb: sAMAccountName is empty\\n\");\n\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t}\n\n\tif (name[i - 1] == '.') {\n\t\tldb_asprintf_errstring(\n\t\t\tldb,\n\t\t\t\"samldb: sAMAccountName ends with '.'\");\n\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t}\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_sam_account_upn_clash(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\tstruct ldb_dn *base_dn = ldb_get_default_basedn(ldb);\n\tTALLOC_CTX *tmp_ctx = NULL;\n\tconst char *real_sam = NULL;\n\tconst char *real_upn = NULL;\n\tchar *implied_sam = NULL;\n\tchar *implied_upn = NULL;\n\tconst char *realm = NULL;\n\n\tret = samldb_get_single_valued_attr(ldb, ac,\n\t\t\t\t\t    \"sAMAccountName\",\n\t\t\t\t\t    &real_sam);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tret = samldb_get_single_valued_attr(ldb, ac,\n\t\t\t\t\t    \"userPrincipalName\",\n\t\t\t\t\t    &real_upn);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (real_upn == NULL && real_sam == NULL) {\n\t\t/* Not changing these things, so we're done */\n\t\treturn LDB_SUCCESS;\n\t}\n\n\ttmp_ctx = talloc_new(ac);\n\trealm = samdb_dn_to_dns_domain(tmp_ctx, base_dn);\n\tif (realm == NULL) {\n\t\ttalloc_free(tmp_ctx);\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tif (real_upn != NULL) {\n\t\t/*\n\t\t * note we take the last @ in the upn because the first (i.e.\n\t\t * sAMAccountName equivalent) part can contain @.\n\t\t *\n\t\t * It is also OK (per Windows) for a UPN to have zero @s.\n\t\t */\n\t\tchar *at = NULL;\n\t\tchar *upn_realm = NULL;\n\t\timplied_sam = talloc_strdup(tmp_ctx, real_upn);\n\t\tif (implied_sam == NULL) {\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ldb_module_oom(ac->module);\n\t\t}\n\n\t\tat = strrchr(implied_sam, '@');\n\t\tif (at == NULL) {\n\t\t\t/*\n\t\t\t * there is no @ in this UPN, so we treat the whole\n\t\t\t * thing as a sAMAccountName for the purposes of a\n\t\t\t * clash.\n\t\t\t */\n\t\t\tDBG_INFO(\"samldb: userPrincipalName '%s' contains \"\n\t\t\t\t \"no '@' character\\n\", implied_sam);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Now, this upn only implies a sAMAccountName if the\n\t\t\t * realm is our realm. So we need to compare the tail\n\t\t\t * of the upn to the realm.\n\t\t\t */\n\t\t\t*at = '\\0';\n\t\t\tupn_realm = at + 1;\n\t\t\tif (strcasecmp(upn_realm, realm) != 0) {\n\t\t\t\t/* implied_sam is not the implied\n\t\t\t\t * sAMAccountName after all, because it is\n\t\t\t\t * from a different realm. */\n\t\t\t\tTALLOC_FREE(implied_sam);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (real_sam != NULL) {\n\t\timplied_upn = talloc_asprintf(tmp_ctx, \"%s@%s\",\n\t\t\t\t\t      real_sam, realm);\n\t\tif (implied_upn == NULL) {\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ldb_module_oom(ac->module);\n\t\t}\n\t}\n\n\t/*\n\t * Now we have all of the actual and implied names, in which to search\n\t * for conflicts.\n\t */\n\tif (real_sam != NULL) {\n\t\tret = samldb_sam_account_upn_clash_sub_search(\n\t\t\tac, tmp_ctx, base_dn, \"sAMAccountName\",\n\t\t\treal_sam, \"\");\n\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t\tret = samaccountname_bad_chars_check(ac, real_sam);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (implied_upn != NULL) {\n\t\tret = samldb_sam_account_upn_clash_sub_search(\n\t\t\tac, tmp_ctx, base_dn, \"userPrincipalName\", implied_upn,\n\t\t\t\"(implied by sAMAccountName)\");\n\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (real_upn != NULL) {\n\t\tret = samldb_sam_account_upn_clash_sub_search(\n\t\t\tac, tmp_ctx, base_dn, \"userPrincipalName\",\n\t\t\treal_upn, \"\");\n\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (implied_sam != NULL) {\n\t\tret = samldb_sam_account_upn_clash_sub_search(\n\t\t\tac, tmp_ctx, base_dn, \"sAMAccountName\", implied_sam,\n\t\t\t\"(implied by userPrincipalName)\");\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\ttalloc_free(tmp_ctx);\n\treturn LDB_SUCCESS;\n}\n\n\n/* This is run during an add or modify */\nstatic int samldb_sam_accountname_valid_check(struct samldb_ctx *ac)\n{\n\tint ret = 0;\n\tbool is_admin;\n\tstruct security_token *user_token = NULL;\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tstruct ldb_message_element *el = NULL;\n\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"samAccountName\",\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (el == NULL || el->num_values == 0) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\"%08X: samldb: 'samAccountName' can't be deleted/empty!\",\n\t\t\tW_ERROR_V(WERR_DS_ILLEGAL_MOD_OPERATION));\n\t\tif (ac->req->operation == LDB_ADD) {\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t} else {\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\t}\n\n\tret = samldb_unique_attr_check(ac, \"samAccountName\", NULL,\n\t\t\t\t       ldb_get_default_basedn(\n\t\t\t\t\t       ldb_module_get_ctx(ac->module)));\n\n\t/*\n\t * Error code munging to try and match what must be some quite\n\t * strange code-paths in Windows\n\t */\n\tif (ret == LDB_ERR_CONSTRAINT_VIOLATION\n\t    && ac->req->operation == LDB_MODIFY) {\n\t\tret = LDB_ERR_ATTRIBUTE_OR_VALUE_EXISTS;\n\t} else if (ret == LDB_ERR_OBJECT_CLASS_VIOLATION) {\n\t\tret = LDB_ERR_CONSTRAINT_VIOLATION;\n\t}\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = samldb_sam_account_upn_clash(ac);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (!ac->need_trailing_dollar) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* This does not permit a single $ */\n\tif (el->values[0].length < 2) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"%08X: samldb: 'samAccountName' \"\n\t\t\t\t       \"can't just be one character!\",\n\t\t\tW_ERROR_V(WERR_DS_ILLEGAL_MOD_OPERATION));\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\tuser_token = acl_user_token(ac->module);\n\tif (user_token == NULL) {\n\t\treturn LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n\t}\n\n\tis_admin\n\t\t= security_token_has_builtin_administrators(user_token);\n\n\tif (is_admin) {\n\t\t/*\n\t\t * Administrators are allowed to select strange names.\n\t\t * This is poor practice but not prevented.\n\t\t */\n\t\treturn false;\n\t}\n\n\tif (el->values[0].data[el->values[0].length - 1] != '$') {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"%08X: samldb: 'samAccountName' \"\n\t\t\t\t       \"must have a trailing $!\",\n\t\t\tW_ERROR_V(WERR_DS_ILLEGAL_MOD_OPERATION));\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\tif (el->values[0].data[el->values[0].length - 2] == '$') {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"%08X: samldb: 'samAccountName' \"\n\t\t\t\t       \"must not have a double trailing $!\",\n\t\t\tW_ERROR_V(WERR_DS_ILLEGAL_MOD_OPERATION));\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\treturn ret;\n}\n\nstatic int samldb_schema_attributeid_valid_check(struct samldb_ctx *ac)\n{\n\tint ret = samldb_unique_attr_check(ac, \"attributeID\", \"governsID\",\n\t\t\t\t\t   ldb_get_schema_basedn(\n\t\t\t\t\t\t   ldb_module_get_ctx(ac->module)));\n\tif (ret == LDB_ERR_ENTRY_ALREADY_EXISTS) {\n\t\tret = LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\treturn ret;\n}\n\nstatic int samldb_schema_governsid_valid_check(struct samldb_ctx *ac)\n{\n\tint ret = samldb_unique_attr_check(ac, \"governsID\", \"attributeID\",\n\t\t\t\t\t   ldb_get_schema_basedn(\n\t\t\t\t\t\t   ldb_module_get_ctx(ac->module)));\n\tif (ret == LDB_ERR_ENTRY_ALREADY_EXISTS) {\n\t\tret = LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\treturn ret;\n}\n\nstatic int samldb_schema_ldapdisplayname_valid_check(struct samldb_ctx *ac)\n{\n\tint ret = samldb_unique_attr_check(ac, \"lDAPDisplayName\", NULL,\n\t\t\t\t\t   ldb_get_schema_basedn(\n\t\t\t\t\t\t   ldb_module_get_ctx(ac->module)));\n\tif (ret == LDB_ERR_ENTRY_ALREADY_EXISTS) {\n\t\tret = LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\treturn ret;\n}\n\nstatic int samldb_check_linkid_used(struct samldb_ctx *ac,\n\t\t\t\t    struct dsdb_schema *schema,\n\t\t\t\t    struct ldb_dn *schema_dn,\n\t\t\t\t    struct ldb_context *ldb,\n\t\t\t\t    int32_t linkID,\n\t\t\t\t    bool *found)\n{\n\tint ret;\n\tstruct ldb_result *ldb_res;\n\n\tif (dsdb_attribute_by_linkID(schema, linkID)) {\n\t\t*found = true;\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tret = dsdb_module_search(ac->module, ac,\n\t\t\t\t &ldb_res,\n\t\t\t\t schema_dn, LDB_SCOPE_ONELEVEL, NULL,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(linkID=%d)\", linkID);\n\tif (ret != LDB_SUCCESS) {\n\t\tldb_debug_set(ldb, LDB_DEBUG_ERROR,\n\t\t\t      __location__\": Searching for linkID=%d failed - %s\\n\",\n\t\t\t      linkID,\n\t\t\t      ldb_errstring(ldb));\n\t\treturn ldb_operr(ldb);\n\t}\n\n\t*found = (ldb_res->count != 0);\n\ttalloc_free(ldb_res);\n\n\treturn LDB_SUCCESS;\n}\n\n/* Find the next open forward linkID in the schema. */\nstatic int samldb_generate_next_linkid(struct samldb_ctx *ac,\n\t\t\t\t       struct dsdb_schema *schema,\n\t\t\t\t       int32_t *next_linkID)\n{\n\tint ret;\n\tstruct ldb_context *ldb;\n\tstruct ldb_dn *schema_dn;\n\tbool linkID_used = true;\n\n\t/*\n\t * Windows starts at about 0xB0000000 in order to stop potential\n\t * collisions with future additions to the schema. We pass this\n\t * around as a signed int sometimes, but this should be sufficient.\n\t */\n\t*next_linkID = 0x40000000;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\tschema_dn = ldb_get_schema_basedn(ldb);\n\n\twhile (linkID_used) {\n\t\t*next_linkID += 2;\n\t\tret = samldb_check_linkid_used(ac, schema,\n\t\t\t\t\t       schema_dn, ldb,\n\t\t\t\t\t       *next_linkID, &linkID_used);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_schema_add_handle_linkid(struct samldb_ctx *ac)\n{\n\tint ret;\n\tbool ok, found = false;\n\tstruct ldb_message_element *el;\n\tconst char *enc_str;\n\tconst struct dsdb_attribute *attr;\n\tstruct ldb_context *ldb;\n\tstruct ldb_dn *schema_dn;\n\tstruct dsdb_schema *schema;\n\tint32_t new_linkID = 0;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\tschema = dsdb_get_schema(ldb, ac);\n\tschema_dn = ldb_get_schema_basedn(ldb);\n\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"linkID\",\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (el == NULL) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tenc_str = ldb_binary_encode(ac, el->values[0]);\n\tif (enc_str == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\n\tok = (strcmp(enc_str, \"0\") == 0);\n\tif (ok) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/*\n\t * This OID indicates that the caller wants the linkID\n\t * to be automatically generated. We therefore assign\n\t * it the next open linkID.\n\t */\n\tok = (strcmp(enc_str, \"1.2.840.113556.1.2.50\") == 0);\n\tif (ok) {\n\t\tret = samldb_generate_next_linkid(ac, schema, &new_linkID);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tldb_msg_remove_element(ac->msg, el);\n\t\tret = samdb_msg_add_int(ldb, ac->msg, ac->msg, \"linkID\",\n\t\t\t\t\tnew_linkID);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Using either the attributeID or lDAPDisplayName of\n\t * another attribute in the linkID field indicates that\n\t * we should make this the backlink of that attribute.\n\t */\n\tattr = dsdb_attribute_by_attributeID_oid(schema, enc_str);\n\tif (attr == NULL) {\n\t\tattr = dsdb_attribute_by_lDAPDisplayName(schema, enc_str);\n\t}\n\n\tif (attr != NULL) {\n\t\t/*\n\t\t * The attribute we're adding this as a backlink of must\n\t\t * be a forward link.\n\t\t */\n\t\tif (attr->linkID % 2 != 0) {\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\n\t\tnew_linkID = attr->linkID + 1;\n\n\t\t/* Make sure that this backlink doesn't already exist. */\n\t\tret = samldb_check_linkid_used(ac, schema,\n\t\t\t\t\t       schema_dn, ldb,\n\t\t\t\t\t       new_linkID, &found);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (found) {\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\n\t\tldb_msg_remove_element(ac->msg, el);\n\t\tret = samdb_msg_add_int(ldb, ac->msg, ac->msg, \"linkID\",\n\t\t\t\t\tnew_linkID);\n\t\treturn ret;\n\t}\n\n\tschema_dn = ldb_get_schema_basedn(ldb_module_get_ctx(ac->module));\n\tret = samldb_unique_attr_check(ac, \"linkID\", NULL, schema_dn);\n\tif (ret == LDB_ERR_ENTRY_ALREADY_EXISTS) {\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t} else {\n\t\treturn ret;\n\t}\n}\n\nstatic int samldb_check_mapiid_used(struct samldb_ctx *ac,\n\t\t\t\t    struct dsdb_schema *schema,\n\t\t\t\t    struct ldb_dn *schema_dn,\n\t\t\t\t    struct ldb_context *ldb,\n\t\t\t\t    int32_t mapiid,\n\t\t\t\t    bool *found)\n{\n\tint ret;\n\tstruct ldb_result *ldb_res;\n\n\tret = dsdb_module_search(ac->module, ac,\n\t\t\t\t &ldb_res,\n\t\t\t\t schema_dn, LDB_SCOPE_ONELEVEL, NULL,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(mAPIID=%d)\", mapiid);\n\tif (ret != LDB_SUCCESS) {\n\t\tldb_debug_set(ldb, LDB_DEBUG_ERROR,\n\t\t\t      __location__\": Searching for mAPIID=%d failed - %s\\n\",\n\t\t\t      mapiid,\n\t\t\t      ldb_errstring(ldb));\n\t\treturn ldb_operr(ldb);\n\t}\n\n\t*found = (ldb_res->count != 0);\n\ttalloc_free(ldb_res);\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_generate_next_mapiid(struct samldb_ctx *ac,\n\t\t\t\t       struct dsdb_schema *schema,\n\t\t\t\t       int32_t *next_mapiid)\n{\n\tint ret;\n\tstruct ldb_context *ldb;\n\tstruct ldb_dn *schema_dn;\n\tbool mapiid_used = true;\n\n\t/* Windows' generation seems to start about here */\n\t*next_mapiid = 60000;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\tschema_dn = ldb_get_schema_basedn(ldb);\n\n\twhile (mapiid_used) {\n\t\t*next_mapiid += 1;\n\t\tret = samldb_check_mapiid_used(ac, schema,\n\t\t\t\t\t       schema_dn, ldb,\n\t\t\t\t\t       *next_mapiid, &mapiid_used);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_schema_add_handle_mapiid(struct samldb_ctx *ac)\n{\n\tint ret;\n\tbool ok;\n\tstruct ldb_message_element *el;\n\tconst char *enc_str;\n\tstruct ldb_context *ldb;\n\tstruct ldb_dn *schema_dn;\n\tstruct dsdb_schema *schema;\n\tint32_t new_mapiid = 0;\n\n\t/*\n\t * The mAPIID of a new attribute should be automatically generated\n\t * if a specific OID is put as the mAPIID, as according to\n\t * [MS-ADTS] 3.1.1.2.3.2.\n\t */\n\n\tldb = ldb_module_get_ctx(ac->module);\n\tschema = dsdb_get_schema(ldb, ac);\n\tschema_dn = ldb_get_schema_basedn(ldb);\n\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"mAPIID\",\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (el == NULL) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tenc_str = ldb_binary_encode(ac, el->values[0]);\n\tif (enc_str == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\n\tok = (strcmp(enc_str, \"1.2.840.113556.1.2.49\") == 0);\n\tif (ok) {\n\t\tret = samldb_generate_next_mapiid(ac, schema,\n\t\t\t\t\t\t  &new_mapiid);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tldb_msg_remove_element(ac->msg, el);\n\t\tret = samdb_msg_add_int(ldb, ac->msg, ac->msg,\n\t\t\t\t\t\"mAPIID\", new_mapiid);\n\t\treturn ret;\n\t}\n\n\tschema_dn = ldb_get_schema_basedn(ldb_module_get_ctx(ac->module));\n\tret = samldb_unique_attr_check(ac, \"mAPIID\", NULL, schema_dn);\n\tif (ret == LDB_ERR_ENTRY_ALREADY_EXISTS) {\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t} else {\n\t\treturn ret;\n\t}\n}\n\n/* sAMAccountName handling */\nstatic int samldb_generate_sAMAccountName(struct samldb_ctx *ac,\n\t\t\t\t\t  struct ldb_message *msg)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tchar *name;\n\n\t/*\n\t * This is currently a Samba-only behaviour, to add a trailing\n\t * $ even for the generated accounts.\n\t */\n\n\tif (ac->need_trailing_dollar) {\n\t\t/* Format: $000000-00000000000$ */\n\t\tname = talloc_asprintf(msg, \"$%.6X-%.6X%.5X$\",\n\t\t\t\t       (unsigned int)generate_random(),\n\t\t\t\t       (unsigned int)generate_random(),\n\t\t\t\t       (unsigned int)generate_random());\n\t} else {\n\t\t/* Format: $000000-000000000000 */\n\n\t\tname = talloc_asprintf(msg, \"$%.6X-%.6X%.6X\",\n\t\t\t\t       (unsigned int)generate_random(),\n\t\t\t\t       (unsigned int)generate_random(),\n\t\t\t\t       (unsigned int)generate_random());\n\t}\n\tif (name == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\treturn ldb_msg_add_steal_string(msg, \"sAMAccountName\", name);\n}\n\nstatic int samldb_check_sAMAccountName(struct samldb_ctx *ac)\n{\n\tint ret;\n\n\tif (ldb_msg_find_element(ac->msg, \"sAMAccountName\") == NULL) {\n\t\tret = samldb_generate_sAMAccountName(ac, ac->msg);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = samldb_sam_accountname_valid_check(ac);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn samldb_next_step(ac);\n}\n\n\nstatic bool samldb_msg_add_sid(struct ldb_message *msg,\n\t\t\t\tconst char *name,\n\t\t\t\tconst struct dom_sid *sid)\n{\n\tstruct ldb_val v;\n\tenum ndr_err_code ndr_err;\n\n\tndr_err = ndr_push_struct_blob(&v, msg, sid,\n\t\t\t\t       (ndr_push_flags_fn_t)ndr_push_dom_sid);\n\tif (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {\n\t\treturn false;\n\t}\n\treturn (ldb_msg_add_value(msg, name, &v, NULL) == 0);\n}\n\n\n/* allocate a SID using our RID Set */\nstatic int samldb_allocate_sid(struct samldb_ctx *ac)\n{\n\tuint32_t rid;\n\tstruct dom_sid *sid;\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\n\tret = ridalloc_allocate_rid(ac->module, &rid, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tsid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), rid);\n\tif (sid == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\n\tif ( ! samldb_msg_add_sid(ac->msg, \"objectSid\", sid)) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\treturn samldb_next_step(ac);\n}\n\n/*\n  see if a krbtgt_number is available\n */\nstatic bool samldb_krbtgtnumber_available(struct samldb_ctx *ac,\n\t\t\t\t\t  uint32_t krbtgt_number)\n{\n\tTALLOC_CTX *tmp_ctx = talloc_new(ac);\n\tstruct ldb_result *res;\n\tconst char * const no_attrs[] = { NULL };\n\tint ret;\n\n\tret = dsdb_module_search(ac->module, tmp_ctx, &res,\n\t\t\t\t ldb_get_default_basedn(ldb_module_get_ctx(ac->module)),\n\t\t\t\t LDB_SCOPE_SUBTREE, no_attrs,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(msDS-SecondaryKrbTgtNumber=%u)\",\n\t\t\t\t krbtgt_number);\n\tif (ret == LDB_SUCCESS && res->count == 0) {\n\t\ttalloc_free(tmp_ctx);\n\t\treturn true;\n\t}\n\ttalloc_free(tmp_ctx);\n\treturn false;\n}\n\n/* special handling for add in RODC join */\nstatic int samldb_rodc_add(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tuint32_t krbtgt_number, i_start, i;\n\tint ret;\n\tstruct ldb_val newpass_utf16;\n\n\t/* find a unused msDS-SecondaryKrbTgtNumber */\n\ti_start = generate_random() & 0xFFFF;\n\tif (i_start == 0) {\n\t\ti_start = 1;\n\t}\n\n\tfor (i=i_start; i<=0xFFFF; i++) {\n\t\tif (samldb_krbtgtnumber_available(ac, i)) {\n\t\t\tkrbtgt_number = i;\n\t\t\tgoto found;\n\t\t}\n\t}\n\tfor (i=1; i<i_start; i++) {\n\t\tif (samldb_krbtgtnumber_available(ac, i)) {\n\t\t\tkrbtgt_number = i;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tldb_asprintf_errstring(ldb,\n\t\t\t       \"%08X: Unable to find available msDS-SecondaryKrbTgtNumber\",\n\t\t\t       W_ERROR_V(WERR_NO_SYSTEM_RESOURCES));\n\treturn LDB_ERR_OTHER;\n\nfound:\n\tret = ldb_msg_add_empty(ac->msg, \"msDS-SecondaryKrbTgtNumber\",\n\t\t\t\tLDB_FLAG_INTERNAL_DISABLE_VALIDATION, NULL);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg,\n\t\t\t\t \"msDS-SecondaryKrbTgtNumber\", krbtgt_number);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = ldb_msg_add_fmt(ac->msg, \"sAMAccountName\", \"krbtgt_%u\",\n\t\t\t      krbtgt_number);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tnewpass_utf16 = data_blob_talloc_zero(ac->module, 256);\n\tif (newpass_utf16.data == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\t/*\n\t * Note that the password_hash module will ignore\n\t * this value and use it's own generate_secret_buffer()\n\t * that's why we can just use generate_random_buffer()\n\t * here.\n\t */\n\tgenerate_random_buffer(newpass_utf16.data, newpass_utf16.length);\n\tret = ldb_msg_add_steal_value(ac->msg, \"clearTextPassword\", &newpass_utf16);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\treturn samldb_next_step(ac);\n}\n\nstatic int samldb_find_for_defaultObjectCategory(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tstruct ldb_result *res;\n\tconst char * const no_attrs[] = { NULL };\n\tint ret;\n\n\tac->res_dn = NULL;\n\n\tret = dsdb_module_search(ac->module, ac, &res,\n\t\t\t\t ac->dn, LDB_SCOPE_BASE, no_attrs,\n\t\t\t\t DSDB_SEARCH_SHOW_DN_IN_STORAGE_FORMAT\n\t\t\t\t | DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(objectClass=classSchema)\");\n\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\t/* Don't be pricky when the DN doesn't exist if we have the */\n\t\t/* RELAX control specified */\n\t\tif (ldb_request_get_control(ac->req,\n\t\t\t\t\t    LDB_CONTROL_RELAX_OID) == NULL) {\n\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t  \"samldb_find_defaultObjectCategory: \"\n\t\t\t\t\t  \"Invalid DN for 'defaultObjectCategory'!\");\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t}\n\tif ((ret != LDB_ERR_NO_SUCH_OBJECT) && (ret != LDB_SUCCESS)) {\n\t\treturn ret;\n\t}\n\n\tif (ret == LDB_SUCCESS) {\n\t\t/* ensure the defaultObjectCategory has a full GUID */\n\t\tstruct ldb_message *m;\n\t\tm = ldb_msg_new(ac->msg);\n\t\tif (m == NULL) {\n\t\t\treturn ldb_oom(ldb);\n\t\t}\n\t\tm->dn = ac->msg->dn;\n\t\tif (ldb_msg_add_string(m, \"defaultObjectCategory\",\n\t\t\t\t       ldb_dn_get_extended_linearized(m, res->msgs[0]->dn, 1)) !=\n\t\t    LDB_SUCCESS) {\n\t\t\treturn ldb_oom(ldb);\n\t\t}\n\t\tm->elements[0].flags = LDB_FLAG_MOD_REPLACE;\n\n\t\tret = dsdb_module_modify(ac->module, m,\n\t\t\t\t\t DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t\t ac->req);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\n\tac->res_dn = ac->dn;\n\n\treturn samldb_next_step(ac);\n}\n\n/**\n * msDS-IntId attributeSchema attribute handling\n * during LDB_ADD request processing\n */\nstatic int samldb_add_handle_msDS_IntId(struct samldb_ctx *ac)\n{\n\tint ret;\n\tbool id_exists;\n\tuint32_t msds_intid;\n\tint32_t system_flags;\n\tstruct ldb_context *ldb;\n\tstruct ldb_result *ldb_res;\n\tstruct ldb_dn *schema_dn;\n\tstruct samldb_msds_intid_persistant *msds_intid_struct;\n\tstruct dsdb_schema *schema;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\tschema_dn = ldb_get_schema_basedn(ldb);\n\n\t/* replicated update should always go through */\n\tif (ldb_request_get_control(ac->req,\n\t\t\t\t    DSDB_CONTROL_REPLICATED_UPDATE_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* msDS-IntId is handled by system and should never be\n\t * passed by clients */\n\tif (ldb_msg_find_element(ac->msg, \"msDS-IntId\")) {\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t/* do not generate msDS-IntId if Relax control is passed */\n\tif (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* check Functional Level */\n\tif (dsdb_functional_level(ldb) < DS_DOMAIN_FUNCTION_2003) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* check systemFlags for SCHEMA_BASE_OBJECT flag */\n\tsystem_flags = ldb_msg_find_attr_as_int(ac->msg, \"systemFlags\", 0);\n\tif (system_flags & SYSTEM_FLAG_SCHEMA_BASE_OBJECT) {\n\t\treturn LDB_SUCCESS;\n\t}\n\tschema = dsdb_get_schema(ldb, NULL);\n\tif (!schema) {\n\t\tldb_debug_set(ldb, LDB_DEBUG_FATAL,\n\t\t\t      \"samldb_schema_info_update: no dsdb_schema loaded\");\n\t\tDEBUG(0,(__location__ \": %s\\n\", ldb_errstring(ldb)));\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tmsds_intid_struct = (struct samldb_msds_intid_persistant*) ldb_get_opaque(ldb, SAMLDB_MSDS_INTID_OPAQUE);\n\tif (!msds_intid_struct) {\n\t\tmsds_intid_struct = talloc(ldb, struct samldb_msds_intid_persistant);\n\t\t/* Generate new value for msDs-IntId\n\t\t* Value should be in 0x80000000..0xBFFFFFFF range */\n\t\tmsds_intid = generate_random() % 0X3FFFFFFF;\n\t\tmsds_intid += 0x80000000;\n\t\tmsds_intid_struct->msds_intid = msds_intid;\n\t\tDEBUG(2, (\"No samldb_msds_intid_persistant struct, allocating a new one\\n\"));\n\t} else {\n\t\tmsds_intid = msds_intid_struct->msds_intid;\n\t}\n\n\t/* probe id values until unique one is found */\n\tdo {\n\t\tmsds_intid++;\n\t\tif (msds_intid > 0xBFFFFFFF) {\n\t\t\tmsds_intid = 0x80000001;\n\t\t}\n\t\t/*\n\t\t * We search in the schema if we have already this\n\t\t * intid (using dsdb_attribute_by_attributeID_id\n\t\t * because in the range 0x80000000 0xBFFFFFFFF,\n\t\t * attributeID is a DSDB_ATTID_TYPE_INTID).\n\t\t *\n\t\t * If so generate another random value.\n\t\t *\n\t\t * We have to check the DB in case someone else has\n\t\t * modified the database while we are doing our\n\t\t * changes too (this case should be very bery rare) in\n\t\t * order to be sure.\n\t\t */\n\t\tif (dsdb_attribute_by_attributeID_id(schema, msds_intid)) {\n\t\t\tid_exists = true;\n\t\t\tmsds_intid = generate_random() % 0X3FFFFFFF;\n\t\t\tmsds_intid += 0x80000000;\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tret = dsdb_module_search(ac->module, ac,\n\t\t\t\t\t &ldb_res,\n\t\t\t\t\t schema_dn, LDB_SCOPE_ONELEVEL, NULL,\n\t\t\t\t\t DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t\t ac->req,\n\t\t\t\t\t \"(msDS-IntId=%d)\", msds_intid);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tldb_debug_set(ldb, LDB_DEBUG_ERROR,\n\t\t\t\t      __location__\": Searching for msDS-IntId=%d failed - %s\\n\",\n\t\t\t\t      msds_intid,\n\t\t\t\t      ldb_errstring(ldb));\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\t\tid_exists = (ldb_res->count > 0);\n\t\ttalloc_free(ldb_res);\n\n\t} while(id_exists);\n\tmsds_intid_struct->msds_intid = msds_intid;\n\tldb_set_opaque(ldb, SAMLDB_MSDS_INTID_OPAQUE, msds_intid_struct);\n\n\treturn samdb_msg_add_int(ldb, ac->msg, ac->msg, \"msDS-IntId\",\n\t\t\t\t msds_intid);\n}\n\n\n/*\n * samldb_add_entry (async)\n */\n\nstatic int samldb_add_entry_callback(struct ldb_request *req,\n\t\t\t\t\tstruct ldb_reply *ares)\n{\n\tstruct ldb_context *ldb;\n\tstruct samldb_ctx *ac;\n\tint ret;\n\n\tac = talloc_get_type(req->context, struct samldb_ctx);\n\tldb = ldb_module_get_ctx(ac->module);\n\n\tif (!ares) {\n\t\treturn ldb_module_done(ac->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\n\tif (ares->type == LDB_REPLY_REFERRAL) {\n\t\treturn ldb_module_send_referral(ac->req, ares->referral);\n\t}\n\n\tif (ares->error != LDB_SUCCESS) {\n\t\treturn ldb_module_done(ac->req, ares->controls,\n\t\t\t\t\tares->response, ares->error);\n\t}\n\tif (ares->type != LDB_REPLY_DONE) {\n\t\tldb_asprintf_errstring(ldb, \"Invalid LDB reply type %d\", ares->type);\n\t\treturn ldb_module_done(ac->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\n\t/* The caller may wish to get controls back from the add */\n\tac->ares = talloc_steal(ac, ares);\n\n\tret = samldb_next_step(ac);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ldb_module_done(ac->req, NULL, NULL, ret);\n\t}\n\treturn ret;\n}\n\nstatic int samldb_add_entry(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb;\n\tstruct ldb_request *req;\n\tint ret;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\n\tret = ldb_build_add_req(&req, ldb, ac,\n\t\t\t\tac->msg,\n\t\t\t\tac->req->controls,\n\t\t\t\tac, samldb_add_entry_callback,\n\t\t\t\tac->req);\n\tLDB_REQ_SET_LOCATION(req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ldb_next_request(ac->module, req);\n}\n\n/*\n * return true if msg carries an attributeSchema that is intended to be RODC\n * filtered but is also a system-critical attribute.\n */\nstatic bool check_rodc_critical_attribute(struct ldb_message *msg)\n{\n\tuint32_t schemaFlagsEx, searchFlags, rodc_filtered_flags;\n\n\tschemaFlagsEx = ldb_msg_find_attr_as_uint(msg, \"schemaFlagsEx\", 0);\n\tsearchFlags = ldb_msg_find_attr_as_uint(msg, \"searchFlags\", 0);\n\trodc_filtered_flags = (SEARCH_FLAG_RODC_ATTRIBUTE\n\t\t\t      | SEARCH_FLAG_CONFIDENTIAL);\n\n\tif ((schemaFlagsEx & SCHEMA_FLAG_ATTR_IS_CRITICAL) &&\n\t\t((searchFlags & rodc_filtered_flags) == rodc_filtered_flags)) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\n\nstatic int samldb_fill_object(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\n\t/* Add information for the different account types */\n\tswitch(ac->type) {\n\tcase SAMLDB_TYPE_USER: {\n\t\tstruct ldb_control *rodc_control = ldb_request_get_control(ac->req,\n\t\t\t\t\t\t\t\t\t   LDB_CONTROL_RODC_DCPROMO_OID);\n\t\tif (rodc_control != NULL) {\n\t\t\t/* see [MS-ADTS] 3.1.1.3.4.1.23 LDAP_SERVER_RODC_DCPROMO_OID */\n\t\t\trodc_control->critical = false;\n\t\t\tret = samldb_add_step(ac, samldb_rodc_add);\n\t\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t}\n\n\t\t/* check if we have a valid sAMAccountName */\n\t\tret = samldb_add_step(ac, samldb_check_sAMAccountName);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\tret = samldb_add_step(ac, samldb_add_entry);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\t\tbreak;\n\t}\n\n\tcase SAMLDB_TYPE_GROUP: {\n\t\t/* check if we have a valid sAMAccountName */\n\t\tret = samldb_add_step(ac, samldb_check_sAMAccountName);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\tret = samldb_add_step(ac, samldb_add_entry);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\t\tbreak;\n\t}\n\n\tcase SAMLDB_TYPE_CLASS: {\n\t\tconst char *lDAPDisplayName = NULL;\n\t\tconst struct ldb_val *rdn_value, *def_obj_cat_val;\n\t\tunsigned int v = ldb_msg_find_attr_as_uint(ac->msg, \"objectClassCategory\", -2);\n\n\t\t/* As discussed with Microsoft through dochelp in April 2012 this is the behavior of windows*/\n\t\tif (!ldb_msg_find_element(ac->msg, \"subClassOf\")) {\n\t\t\tret = ldb_msg_add_string(ac->msg, \"subClassOf\", \"top\");\n\t\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t}\n\n\t\tret = samdb_find_or_add_attribute(ldb, ac->msg,\n\t\t\t\t\t\t  \"rdnAttId\", \"cn\");\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\t/* do not allow one to mark an attributeSchema as RODC filtered if it\n\t\t * is system-critical */\n\t\tif (check_rodc_critical_attribute(ac->msg)) {\n\t\t\tldb_asprintf_errstring(ldb, \"Refusing schema add of %s - cannot combine critical class with RODC filtering\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn));\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\n\t\trdn_value = ldb_dn_get_rdn_val(ac->msg->dn);\n\t\tif (rdn_value == NULL) {\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\t\tif (!ldb_msg_find_element(ac->msg, \"lDAPDisplayName\")) {\n\t\t\t/* the RDN has prefix \"CN\" */\n\t\t\tret = ldb_msg_add_string(ac->msg, \"lDAPDisplayName\",\n\t\t\t\tsamdb_cn_to_lDAPDisplayName(ac->msg,\n\t\t\t\t\t\t\t    (const char *) rdn_value->data));\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_oom(ldb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tlDAPDisplayName = ldb_msg_find_attr_as_string(ac->msg,\n\t\t\t\t\t\t\t      \"lDAPDisplayName\",\n\t\t\t\t\t\t\t      NULL);\n\t\tret = ldb_valid_attr_name(lDAPDisplayName);\n\t\tif (ret != 1 ||\n\t\t    lDAPDisplayName[0] == '*' ||\n\t\t    lDAPDisplayName[0] == '@')\n\t\t{\n\t\t\treturn dsdb_module_werror(ac->module,\n\t\t\t\t\t\t  LDB_ERR_UNWILLING_TO_PERFORM,\n\t\t\t\t\t\t  WERR_DS_INVALID_LDAP_DISPLAY_NAME,\n\t\t\t\t\t\t  \"lDAPDisplayName is invalid\");\n\t\t}\n\n\t\tif (!ldb_msg_find_element(ac->msg, \"schemaIDGUID\")) {\n\t\t\tstruct GUID guid;\n\t\t\t/* a new GUID */\n\t\t\tguid = GUID_random();\n\t\t\tret = dsdb_msg_add_guid(ac->msg, &guid, \"schemaIDGUID\");\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_oom(ldb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tdef_obj_cat_val = ldb_msg_find_ldb_val(ac->msg,\n\t\t\t\t\t\t       \"defaultObjectCategory\");\n\t\tif (def_obj_cat_val != NULL) {\n\t\t\t/* \"defaultObjectCategory\" has been set by the caller.\n\t\t\t * Do some checks for consistency.\n\t\t\t * NOTE: The real constraint check (that\n\t\t\t * 'defaultObjectCategory' is the DN of the new\n\t\t\t * objectclass or any parent of it) is still incomplete.\n\t\t\t * For now we say that 'defaultObjectCategory' is valid\n\t\t\t * if it exists and it is of objectclass \"classSchema\".\n\t\t\t */\n\t\t\tac->dn = ldb_dn_from_ldb_val(ac, ldb, def_obj_cat_val);\n\t\t\tif (ac->dn == NULL) {\n\t\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t\t  \"Invalid DN for 'defaultObjectCategory'!\");\n\t\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t\t}\n\t\t} else {\n\t\t\t/* \"defaultObjectCategory\" has not been set by the\n\t\t\t * caller. Use the entry DN for it. */\n\t\t\tac->dn = ac->msg->dn;\n\n\t\t\tret = ldb_msg_add_string(ac->msg, \"defaultObjectCategory\",\n\t\t\t\t\t\t ldb_dn_alloc_linearized(ac->msg, ac->dn));\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_oom(ldb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = samldb_add_step(ac, samldb_add_entry);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\t/* Now perform the checks for the 'defaultObjectCategory'. The\n\t\t * lookup DN was already saved in \"ac->dn\" */\n\t\tret = samldb_add_step(ac, samldb_find_for_defaultObjectCategory);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\t/* -2 is not a valid objectClassCategory so it means the attribute wasn't present */\n\t\tif (v == -2) {\n\t\t\t/* Windows 2003 does this*/\n\t\t\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg, \"objectClassCategory\", 0);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase SAMLDB_TYPE_ATTRIBUTE: {\n\t\tconst char *lDAPDisplayName = NULL;\n\t\tconst struct ldb_val *rdn_value;\n\t\tstruct ldb_message_element *el;\n\t\trdn_value = ldb_dn_get_rdn_val(ac->msg->dn);\n\t\tif (rdn_value == NULL) {\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\t\tif (!ldb_msg_find_element(ac->msg, \"lDAPDisplayName\")) {\n\t\t\t/* the RDN has prefix \"CN\" */\n\t\t\tret = ldb_msg_add_string(ac->msg, \"lDAPDisplayName\",\n\t\t\t\tsamdb_cn_to_lDAPDisplayName(ac->msg,\n\t\t\t\t\t\t\t    (const char *) rdn_value->data));\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_oom(ldb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tlDAPDisplayName = ldb_msg_find_attr_as_string(ac->msg,\n\t\t\t\t\t\t\t      \"lDAPDisplayName\",\n\t\t\t\t\t\t\t      NULL);\n\t\tret = ldb_valid_attr_name(lDAPDisplayName);\n\t\tif (ret != 1 ||\n\t\t    lDAPDisplayName[0] == '*' ||\n\t\t    lDAPDisplayName[0] == '@')\n\t\t{\n\t\t\treturn dsdb_module_werror(ac->module,\n\t\t\t\t\t\t  LDB_ERR_UNWILLING_TO_PERFORM,\n\t\t\t\t\t\t  WERR_DS_INVALID_LDAP_DISPLAY_NAME,\n\t\t\t\t\t\t  \"lDAPDisplayName is invalid\");\n\t\t}\n\n\t\t/* do not allow one to mark an attributeSchema as RODC filtered if it\n\t\t * is system-critical */\n\t\tif (check_rodc_critical_attribute(ac->msg)) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"samldb: refusing schema add of %s - cannot combine critical attribute with RODC filtering\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn));\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\n\t\tret = samdb_find_or_add_attribute(ldb, ac->msg,\n\t\t\t\t\t\t  \"isSingleValued\", \"FALSE\");\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\tif (!ldb_msg_find_element(ac->msg, \"schemaIDGUID\")) {\n\t\t\tstruct GUID guid;\n\t\t\t/* a new GUID */\n\t\t\tguid = GUID_random();\n\t\t\tret = dsdb_msg_add_guid(ac->msg, &guid, \"schemaIDGUID\");\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tldb_oom(ldb);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tel = ldb_msg_find_element(ac->msg, \"attributeSyntax\");\n\t\tif (el) {\n\t\t\t/*\n\t\t\t * No need to scream if there isn't as we have code later on\n\t\t\t * that will take care of it.\n\t\t\t */\n\t\t\tconst struct dsdb_syntax *syntax = find_syntax_map_by_ad_oid((const char *)el->values[0].data);\n\t\t\tif (!syntax) {\n\t\t\t\tDEBUG(9, (\"Can't find dsdb_syntax object for attributeSyntax %s\\n\",\n\t\t\t\t\t\t(const char *)el->values[0].data));\n\t\t\t} else {\n\t\t\t\tunsigned int v = ldb_msg_find_attr_as_uint(ac->msg, \"oMSyntax\", 0);\n\t\t\t\tconst struct ldb_val *val = ldb_msg_find_ldb_val(ac->msg, \"oMObjectClass\");\n\n\t\t\t\tif (v == 0) {\n\t\t\t\t\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg, \"oMSyntax\", syntax->oMSyntax);\n\t\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!val) {\n\t\t\t\t\tstruct ldb_val val2 = ldb_val_dup(ldb, &syntax->oMObjectClass);\n\t\t\t\t\tif (val2.length > 0) {\n\t\t\t\t\t\tret = ldb_msg_add_value(ac->msg, \"oMObjectClass\", &val2, NULL);\n\t\t\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* handle msDS-IntID attribute */\n\t\tret = samldb_add_handle_msDS_IntId(ac);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\tret = samldb_add_step(ac, samldb_add_entry);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tldb_asprintf_errstring(ldb, \"Invalid entry type!\");\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t\tbreak;\n\t}\n\n\treturn samldb_first_step(ac);\n}\n\nstatic int samldb_fill_foreignSecurityPrincipal_object(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = NULL;\n\tconst struct ldb_val *rdn_value = NULL;\n\tstruct ldb_message_element *sid_el = NULL;\n\tstruct dom_sid *sid = NULL;\n\tstruct ldb_control *as_system = NULL;\n\tstruct ldb_control *provision = NULL;\n\tbool allowed = false;\n\tint ret;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\n\tas_system = ldb_request_get_control(ac->req, LDB_CONTROL_AS_SYSTEM_OID);\n\tif (as_system != NULL) {\n\t\tallowed = true;\n\t}\n\n\tprovision = ldb_request_get_control(ac->req, LDB_CONTROL_PROVISION_OID);\n\tif (provision != NULL) {\n\t\tallowed = true;\n\t}\n\n\tsid_el = ldb_msg_find_element(ac->msg, \"objectSid\");\n\n\tif (!allowed && sid_el == NULL) {\n\t\treturn dsdb_module_werror(ac->module,\n\t\t\t\tLDB_ERR_OBJECT_CLASS_VIOLATION,\n\t\t\t\tWERR_DS_MISSING_REQUIRED_ATT,\n\t\t\t\t\"objectSid missing on foreignSecurityPrincipal\");\n\t}\n\n\tif (!allowed) {\n\t\treturn dsdb_module_werror(ac->module,\n\t\t\t\tLDB_ERR_UNWILLING_TO_PERFORM,\n\t\t\t\tWERR_DS_ILLEGAL_MOD_OPERATION,\n\t\t\t\t\"foreignSecurityPrincipal object not allowed\");\n\t}\n\n\tif (sid_el != NULL) {\n\t\tsid = samdb_result_dom_sid(ac->msg, ac->msg, \"objectSid\");\n\t\tif (sid == NULL) {\n\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t  \"samldb: invalid objectSid!\");\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t}\n\n\tif (sid == NULL) {\n\t\trdn_value = ldb_dn_get_rdn_val(ac->msg->dn);\n\t\tif (rdn_value == NULL) {\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\t\tsid = dom_sid_parse_talloc(ac->msg,\n\t\t\t\t\t   (const char *)rdn_value->data);\n\t\tif (sid == NULL) {\n\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t  \"samldb: No valid SID found in ForeignSecurityPrincipal CN!\");\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t\tif (! samldb_msg_add_sid(ac->msg, \"objectSid\", sid)) {\n\t\t\treturn ldb_operr(ldb);\n\t\t}\n\t}\n\n\t/* finally proceed with adding the entry */\n\tret = samldb_add_step(ac, samldb_add_entry);\n\tif (ret != LDB_SUCCESS) return ret;\n\n\treturn samldb_first_step(ac);\n}\n\nstatic int samldb_schema_info_update(struct samldb_ctx *ac)\n{\n\tint ret;\n\tstruct ldb_context *ldb;\n\tstruct dsdb_schema *schema;\n\n\t/* replicated update should always go through */\n\tif (ldb_request_get_control(ac->req,\n\t\t\t\t    DSDB_CONTROL_REPLICATED_UPDATE_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* do not update schemaInfo during provisioning */\n\tif (ldb_request_get_control(ac->req, LDB_CONTROL_PROVISION_OID)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tldb = ldb_module_get_ctx(ac->module);\n\tschema = dsdb_get_schema(ldb, NULL);\n\tif (!schema) {\n\t\tldb_debug_set(ldb, LDB_DEBUG_FATAL,\n\t\t\t      \"samldb_schema_info_update: no dsdb_schema loaded\");\n\t\tDEBUG(0,(__location__ \": %s\\n\", ldb_errstring(ldb)));\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = dsdb_module_schema_info_update(ac->module, schema,\n\t\t\t\t\t     DSDB_FLAG_NEXT_MODULE|\n\t\t\t\t\t     DSDB_FLAG_AS_SYSTEM,\n\t\t\t\t\t     ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"samldb_schema_info_update: dsdb_module_schema_info_update failed with %s\",\n\t\t\t\t       ldb_errstring(ldb));\n\t\treturn ret;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_prim_group_tester(struct samldb_ctx *ac, uint32_t rid);\nstatic int samldb_check_user_account_control_rules(struct samldb_ctx *ac,\n\t\t\t\t\t\t   struct dom_sid *sid,\n\t\t\t\t\t\t   uint32_t req_uac,\n\t\t\t\t\t\t   uint32_t user_account_control,\n\t\t\t\t\t\t   uint32_t user_account_control_old,\n\t\t\t\t\t\t   bool is_computer_objectclass);\n\n/*\n * \"Objectclass\" trigger (MS-SAMR 3.1.1.8.1)\n *\n * Has to be invoked on \"add\" operations on \"user\", \"computer\" and\n * \"group\" objects.\n * ac->msg contains the \"add\"\n * ac->type contains the object type (main objectclass)\n */\nstatic int samldb_objectclass_trigger(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tvoid *skip_allocate_sids = ldb_get_opaque(ldb,\n\t\t\t\t\t\t  \"skip_allocate_sids\");\n\tstruct ldb_message_element *el, *el2;\n\tstruct dom_sid *sid;\n\tint ret;\n\n\t/* make sure that \"sAMAccountType\" is not specified */\n\tel = ldb_msg_find_element(ac->msg, \"sAMAccountType\");\n\tif (el != NULL) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb: sAMAccountType must not be specified!\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t/* Step 1: objectSid assignment */\n\n\t/* Don't allow the objectSid to be changed. But beside the RELAX\n\t * control we have also to guarantee that it can always be set with\n\t * SYSTEM permissions. This is needed for the \"samba3sam\" backend. */\n\tsid = samdb_result_dom_sid(ac, ac->msg, \"objectSid\");\n\tif ((sid != NULL) && (!dsdb_module_am_system(ac->module)) &&\n\t    (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID) == NULL)) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb: objectSid must not be specified!\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t/* but generate a new SID when we do have an add operations */\n\tif ((sid == NULL) && (ac->req->operation == LDB_ADD) && !skip_allocate_sids) {\n\t\tret = samldb_add_step(ac, samldb_allocate_sid);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\t}\n\n\tswitch(ac->type) {\n\tcase SAMLDB_TYPE_USER: {\n\t\tuint32_t raw_uac;\n\t\tuint32_t user_account_control;\n\t\tbool is_computer_objectclass;\n\t\tbool uac_generated = false, uac_add_flags = false;\n\t\tuint32_t default_user_account_control = UF_NORMAL_ACCOUNT;\n\t\t/* Step 1.2: Default values */\n\t\tret = dsdb_user_obj_set_defaults(ldb, ac->msg, ac->req);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\tis_computer_objectclass\n\t\t\t= (samdb_find_attribute(ldb,\n\t\t\t\t\t\t ac->msg,\n\t\t\t\t\t\t\"objectclass\",\n\t\t\t\t\t\t\"computer\")\n\t\t\t   != NULL);\n\n\t\tif (is_computer_objectclass) {\n\t\t\tdefault_user_account_control\n\t\t\t\t= UF_WORKSTATION_TRUST_ACCOUNT;\n\t\t}\n\n\n\t\t/* On add operations we might need to generate a\n\t\t * \"userAccountControl\" (if it isn't specified). */\n\t\tel = ldb_msg_find_element(ac->msg, \"userAccountControl\");\n\t\tif (el == NULL) {\n\t\t\tret = samdb_msg_set_uint(ldb, ac->msg, ac->msg,\n\t\t\t\t\t\t \"userAccountControl\",\n\t\t\t\t\t\t default_user_account_control);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tuac_generated = true;\n\t\t\tuac_add_flags = true;\n\t\t}\n\n\t\tel = ldb_msg_find_element(ac->msg, \"userAccountControl\");\n\t\tSMB_ASSERT(el != NULL);\n\n\t\t/* Step 1.3: \"userAccountControl\" -> \"sAMAccountType\" mapping */\n\t\tuser_account_control = ldb_msg_find_attr_as_uint(ac->msg,\n\t\t\t\t\t\t\t\t \"userAccountControl\",\n\t\t\t\t\t\t\t\t 0);\n\t\traw_uac = user_account_control;\n\t\t/*\n\t\t * \"userAccountControl\" = 0 or missing one of\n\t\t * the types means \"UF_NORMAL_ACCOUNT\"\n\t\t * or \"UF_WORKSTATION_TRUST_ACCOUNT\" (if a computer).\n\t\t * See MS-SAMR 3.1.1.8.10 point 8\n\t\t */\n\t\tif ((user_account_control & UF_ACCOUNT_TYPE_MASK) == 0) {\n\t\t\tuser_account_control\n\t\t\t\t= default_user_account_control\n\t\t\t\t| user_account_control;\n\t\t\tuac_generated = true;\n\t\t}\n\n\t\t/*\n\t\t * As per MS-SAMR 3.1.1.8.10 these flags have not to be set\n\t\t */\n\t\tif ((user_account_control & UF_LOCKOUT) != 0) {\n\t\t\tuser_account_control &= ~UF_LOCKOUT;\n\t\t\tuac_generated = true;\n\t\t}\n\t\tif ((user_account_control & UF_PASSWORD_EXPIRED) != 0) {\n\t\t\tuser_account_control &= ~UF_PASSWORD_EXPIRED;\n\t\t\tuac_generated = true;\n\t\t}\n\n\t\tret = samldb_check_user_account_control_rules(ac, NULL,\n\t\t\t\t\t\t\t      raw_uac,\n\t\t\t\t\t\t\t      user_account_control,\n\t\t\t\t\t\t\t      0,\n\t\t\t\t\t\t\t      is_computer_objectclass);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\t/*\n\t\t * Require, for non-admin modifications, a trailing $\n\t\t * for either objectclass=computer or a trust account\n\t\t * type in userAccountControl\n\t\t */\n\t\tif ((user_account_control\n\t\t     & UF_TRUST_ACCOUNT_MASK) != 0) {\n\t\t\tac->need_trailing_dollar = true;\n\t\t}\n\n\t\tif (is_computer_objectclass) {\n\t\t\tac->need_trailing_dollar = true;\n\t\t}\n\n\t\t/* add \"sAMAccountType\" attribute */\n\t\tret = dsdb_user_obj_set_account_type(ldb, ac->msg, user_account_control, NULL);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* \"isCriticalSystemObject\" might be set */\n\t\tif (user_account_control &\n\t\t    (UF_SERVER_TRUST_ACCOUNT | UF_PARTIAL_SECRETS_ACCOUNT)) {\n\t\t\tret = ldb_msg_add_string(ac->msg, \"isCriticalSystemObject\",\n\t\t\t\t\t\t \"TRUE\");\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tel2 = ldb_msg_find_element(ac->msg,\n\t\t\t\t\t\t   \"isCriticalSystemObject\");\n\t\t\tel2->flags = LDB_FLAG_MOD_REPLACE;\n\t\t} else if (user_account_control & UF_WORKSTATION_TRUST_ACCOUNT) {\n\t\t\tret = ldb_msg_add_string(ac->msg, \"isCriticalSystemObject\",\n\t\t\t\t\t\t \"FALSE\");\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tel2 = ldb_msg_find_element(ac->msg,\n\t\t\t\t\t\t   \"isCriticalSystemObject\");\n\t\t\tel2->flags = LDB_FLAG_MOD_REPLACE;\n\t\t}\n\n\t\t/* Step 1.4: \"userAccountControl\" -> \"primaryGroupID\" mapping */\n\t\tif (!ldb_msg_find_element(ac->msg, \"primaryGroupID\")) {\n\t\t\tuint32_t rid;\n\n\t\t\tret = dsdb_user_obj_set_primary_group_id(ldb, ac->msg, user_account_control, &rid);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Older AD deployments don't know about the\n\t\t\t * RODC group\n\t\t\t */\n\t\t\tif (rid == DOMAIN_RID_READONLY_DCS) {\n\t\t\t\tret = samldb_prim_group_tester(ac, rid);\n\t\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Step 1.5: Add additional flags when needed */\n\t\t/* Obviously this is done when the \"userAccountControl\"\n\t\t * has been generated here (tested against Windows\n\t\t * Server) */\n\t\tif (uac_generated) {\n\t\t\tif (uac_add_flags) {\n\t\t\t\tuser_account_control |= UF_ACCOUNTDISABLE;\n\t\t\t\tuser_account_control |= UF_PASSWD_NOTREQD;\n\t\t\t}\n\n\t\t\tret = samdb_msg_set_uint(ldb, ac->msg, ac->msg,\n\t\t\t\t\t\t \"userAccountControl\",\n\t\t\t\t\t\t user_account_control);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase SAMLDB_TYPE_GROUP: {\n\t\tconst char *tempstr;\n\n\t\t/* Step 2.2: Default values */\n\t\ttempstr = talloc_asprintf(ac->msg, \"%d\",\n\t\t\t\t\t  GTYPE_SECURITY_GLOBAL_GROUP);\n\t\tif (tempstr == NULL) return ldb_operr(ldb);\n\t\tret = samdb_find_or_add_attribute(ldb, ac->msg,\n\t\t\t\"groupType\", tempstr);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\n\t\t/* Step 2.3: \"groupType\" -> \"sAMAccountType\" */\n\t\tel = ldb_msg_find_element(ac->msg, \"groupType\");\n\t\tif (el != NULL) {\n\t\t\tuint32_t group_type, account_type;\n\n\t\t\tgroup_type = ldb_msg_find_attr_as_uint(ac->msg,\n\t\t\t\t\t\t\t       \"groupType\", 0);\n\n\t\t\t/* The creation of builtin groups requires the\n\t\t\t * RELAX control */\n\t\t\tif (group_type == GTYPE_SECURITY_BUILTIN_LOCAL_GROUP) {\n\t\t\t\tif (ldb_request_get_control(ac->req,\n\t\t\t\t\t\t\t    LDB_CONTROL_RELAX_OID) == NULL) {\n\t\t\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\taccount_type = ds_gtype2atype(group_type);\n\t\t\tif (account_type == 0) {\n\t\t\t\tldb_set_errstring(ldb, \"samldb: Unrecognized account type!\");\n\t\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t\t}\n\t\t\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg,\n\t\t\t\t\t\t \"sAMAccountType\",\n\t\t\t\t\t\t account_type);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tel2 = ldb_msg_find_element(ac->msg, \"sAMAccountType\");\n\t\t\tel2->flags = LDB_FLAG_MOD_REPLACE;\n\t\t}\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\"Invalid entry type!\");\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t\tbreak;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n\n/*\n * \"Primary group ID\" trigger (MS-SAMR 3.1.1.8.2)\n *\n * Has to be invoked on \"add\" and \"modify\" operations on \"user\" and \"computer\"\n * objects.\n * ac->msg contains the \"add\"/\"modify\" message\n */\n\nstatic int samldb_prim_group_tester(struct samldb_ctx *ac, uint32_t rid)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tstruct dom_sid *sid;\n\tstruct ldb_result *res;\n\tint ret;\n\tconst char * const noattrs[] = { NULL };\n\n\tsid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), rid);\n\tif (sid == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = dsdb_module_search(ac->module, ac, &res,\n\t\t\t\t ldb_get_default_basedn(ldb),\n\t\t\t\t LDB_SCOPE_SUBTREE,\n\t\t\t\t noattrs, DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(objectSid=%s)\",\n\t\t\t\t ldap_encode_ndr_dom_sid(ac, sid));\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (res->count != 1) {\n\t\ttalloc_free(res);\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"Failed to find primary group with RID %u!\",\n\t\t\t\t       rid);\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\ttalloc_free(res);\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_prim_group_set(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tuint32_t rid;\n\n\trid = ldb_msg_find_attr_as_uint(ac->msg, \"primaryGroupID\", (uint32_t) -1);\n\tif (rid == (uint32_t) -1) {\n\t\t/* we aren't affected of any primary group set */\n\t\treturn LDB_SUCCESS;\n\n\t} else if (!ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID)) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"The primary group isn't settable on add operations!\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\treturn samldb_prim_group_tester(ac, rid);\n}\n\nstatic int samldb_prim_group_change(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tconst char * const attrs[] = {\n\t\t\"primaryGroupID\",\n\t\t\"memberOf\",\n\t\t\"userAccountControl\",\n\t\tNULL };\n\tstruct ldb_result *res, *group_res;\n\tstruct ldb_message_element *el;\n\tstruct ldb_message *msg;\n\tuint32_t search_flags =\n\t\tDSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_EXTENDED_DN;\n\tuint32_t prev_rid, new_rid, uac;\n\tstruct dom_sid *prev_sid, *new_sid;\n\tstruct ldb_dn *prev_prim_group_dn, *new_prim_group_dn;\n\tconst char *new_prim_group_dn_ext_str = NULL;\n\tstruct ldb_dn *user_dn = NULL;\n\tconst char *user_dn_ext_str = NULL;\n\tint ret;\n\tconst char * const noattrs[] = { NULL };\n\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"primaryGroupID\",\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (el == NULL) {\n\t\t/* we are not affected */\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* Fetch information from the existing object */\n\n\tret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn, attrs,\n\t\t\t\t    search_flags, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tuser_dn = res->msgs[0]->dn;\n\tuser_dn_ext_str = ldb_dn_get_extended_linearized(ac, user_dn, 1);\n\tif (user_dn_ext_str == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tuac = ldb_msg_find_attr_as_uint(res->msgs[0], \"userAccountControl\", 0);\n\n\t/* Finds out the DN of the old primary group */\n\n\tprev_rid = ldb_msg_find_attr_as_uint(res->msgs[0], \"primaryGroupID\",\n\t\t\t\t\t     (uint32_t) -1);\n\tif (prev_rid == (uint32_t) -1) {\n\t\t/* User objects do always have a mandatory \"primaryGroupID\"\n\t\t * attribute. If this doesn't exist then the object is of the\n\t\t * wrong type. This is the exact Windows error code */\n\t\treturn LDB_ERR_OBJECT_CLASS_VIOLATION;\n\t}\n\n\tprev_sid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), prev_rid);\n\tif (prev_sid == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\t/* Finds out the DN of the new primary group\n\t * Notice: in order to parse the primary group ID correctly we create\n\t * a temporary message here. */\n\n\tmsg = ldb_msg_new(ac->msg);\n\tif (msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tret = ldb_msg_add(msg, el, 0);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tnew_rid = ldb_msg_find_attr_as_uint(msg, \"primaryGroupID\", (uint32_t) -1);\n\ttalloc_free(msg);\n\tif (new_rid == (uint32_t) -1) {\n\t\t/* we aren't affected of any primary group change */\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tif (prev_rid == new_rid) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tif ((uac & UF_SERVER_TRUST_ACCOUNT) && new_rid != DOMAIN_RID_DCS) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\"%08X: samldb: UF_SERVER_TRUST_ACCOUNT requires \"\n\t\t\t\"primaryGroupID=%u!\",\n\t\t\tW_ERROR_V(WERR_DS_CANT_MOD_PRIMARYGROUPID),\n\t\t\tDOMAIN_RID_DCS);\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\tif ((uac & UF_PARTIAL_SECRETS_ACCOUNT) && new_rid != DOMAIN_RID_READONLY_DCS) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\"%08X: samldb: UF_PARTIAL_SECRETS_ACCOUNT requires \"\n\t\t\t\"primaryGroupID=%u!\",\n\t\t\tW_ERROR_V(WERR_DS_CANT_MOD_PRIMARYGROUPID),\n\t\t\tDOMAIN_RID_READONLY_DCS);\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\tret = dsdb_module_search(ac->module, ac, &group_res,\n\t\t\t\t ldb_get_default_basedn(ldb),\n\t\t\t\t LDB_SCOPE_SUBTREE,\n\t\t\t\t noattrs, search_flags,\n\t\t\t\t ac->req,\n\t\t\t\t \"(objectSid=%s)\",\n\t\t\t\t ldap_encode_ndr_dom_sid(ac, prev_sid));\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (group_res->count != 1) {\n\t\treturn ldb_operr(ldb);\n\t}\n\tprev_prim_group_dn = group_res->msgs[0]->dn;\n\n\tnew_sid = dom_sid_add_rid(ac, samdb_domain_sid(ldb), new_rid);\n\tif (new_sid == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = dsdb_module_search(ac->module, ac, &group_res,\n\t\t\t\t ldb_get_default_basedn(ldb),\n\t\t\t\t LDB_SCOPE_SUBTREE,\n\t\t\t\t noattrs, search_flags,\n\t\t\t\t ac->req,\n\t\t\t\t \"(objectSid=%s)\",\n\t\t\t\t ldap_encode_ndr_dom_sid(ac, new_sid));\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (group_res->count != 1) {\n\t\t/* Here we know if the specified new primary group candidate is\n\t\t * valid or not. */\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\tnew_prim_group_dn = group_res->msgs[0]->dn;\n\tnew_prim_group_dn_ext_str = ldb_dn_get_extended_linearized(ac,\n\t\t\t\t\t\t\tnew_prim_group_dn, 1);\n\tif (new_prim_group_dn_ext_str == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\t/* We need to be already a normal member of the new primary\n\t * group in order to be successful. */\n\tel = samdb_find_attribute(ldb, res->msgs[0], \"memberOf\",\n\t\t\t\t  new_prim_group_dn_ext_str);\n\tif (el == NULL) {\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t/* Remove the \"member\" attribute on the new primary group */\n\tmsg = ldb_msg_new(ac->msg);\n\tif (msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tmsg->dn = new_prim_group_dn;\n\n\tret = samdb_msg_add_delval(ldb, msg, msg, \"member\", user_dn_ext_str);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = dsdb_module_modify(ac->module, msg, DSDB_FLAG_NEXT_MODULE, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\ttalloc_free(msg);\n\n\t/* Add a \"member\" attribute for the previous primary group */\n\tmsg = ldb_msg_new(ac->msg);\n\tif (msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tmsg->dn = prev_prim_group_dn;\n\n\tret = samdb_msg_add_addval(ldb, msg, msg, \"member\", user_dn_ext_str);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = dsdb_module_modify(ac->module, msg, DSDB_FLAG_NEXT_MODULE, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\ttalloc_free(msg);\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_prim_group_trigger(struct samldb_ctx *ac)\n{\n\tint ret;\n\n\tif (ac->req->operation == LDB_ADD) {\n\t\tret = samldb_prim_group_set(ac);\n\t} else {\n\t\tret = samldb_prim_group_change(ac);\n\t}\n\n\treturn ret;\n}\n\nstatic int samldb_check_user_account_control_invariants(struct samldb_ctx *ac,\n\t\t\t\t\t\t    uint32_t user_account_control)\n{\n\tsize_t i;\n\tint ret = 0;\n\tbool need_check = false;\n\tconst struct uac_to_guid {\n\t\tuint32_t uac;\n\t\tbool never;\n\t\tuint32_t needs;\n\t\tuint32_t not_with;\n\t\tconst char *error_string;\n\t} map[] = {\n\t\t{\n\t\t\t.uac = UF_TEMP_DUPLICATE_ACCOUNT,\n\t\t\t.never = true,\n\t\t\t.error_string = \"Updating the UF_TEMP_DUPLICATE_ACCOUNT flag is never allowed\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_PARTIAL_SECRETS_ACCOUNT,\n\t\t\t.needs = UF_WORKSTATION_TRUST_ACCOUNT,\n\t\t\t.error_string = \"Setting UF_PARTIAL_SECRETS_ACCOUNT only permitted with UF_WORKSTATION_TRUST_ACCOUNT\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_TRUSTED_FOR_DELEGATION,\n\t\t\t.not_with = UF_PARTIAL_SECRETS_ACCOUNT,\n\t\t\t.error_string = \"Setting UF_TRUSTED_FOR_DELEGATION not allowed with UF_PARTIAL_SECRETS_ACCOUNT\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_NORMAL_ACCOUNT,\n\t\t\t.not_with = UF_ACCOUNT_TYPE_MASK & ~UF_NORMAL_ACCOUNT,\n\t\t\t.error_string = \"Setting more than one account type not permitted\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_WORKSTATION_TRUST_ACCOUNT,\n\t\t\t.not_with = UF_ACCOUNT_TYPE_MASK & ~UF_WORKSTATION_TRUST_ACCOUNT,\n\t\t\t.error_string = \"Setting more than one account type not permitted\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_INTERDOMAIN_TRUST_ACCOUNT,\n\t\t\t.not_with = UF_ACCOUNT_TYPE_MASK & ~UF_INTERDOMAIN_TRUST_ACCOUNT,\n\t\t\t.error_string = \"Setting more than one account type not permitted\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_SERVER_TRUST_ACCOUNT,\n\t\t\t.not_with = UF_ACCOUNT_TYPE_MASK & ~UF_SERVER_TRUST_ACCOUNT,\n\t\t\t.error_string = \"Setting more than one account type not permitted\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_TRUSTED_FOR_DELEGATION,\n\t\t\t.not_with = UF_PARTIAL_SECRETS_ACCOUNT,\n\t\t\t.error_string = \"Setting UF_TRUSTED_FOR_DELEGATION not allowed with UF_PARTIAL_SECRETS_ACCOUNT\"\n\t\t}\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(map); i++) {\n\t\tif (user_account_control & map[i].uac) {\n\t\t\tneed_check = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (need_check == false) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(map); i++) {\n\t\tuint32_t this_uac = user_account_control & map[i].uac;\n\t\tif (this_uac != 0) {\n\t\t\tif (map[i].never) {\n\t\t\t\tret = LDB_ERR_OTHER;\n\t\t\t\tbreak;\n\t\t\t} else if (map[i].needs != 0) {\n\t\t\t\tif ((map[i].needs & user_account_control) == 0) {\n\t\t\t\t\tret = LDB_ERR_OTHER;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (map[i].not_with != 0) {\n\t\t\t\tif ((map[i].not_with & user_account_control) != 0) {\n\t\t\t\t\tret = LDB_ERR_OTHER;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (ret != LDB_SUCCESS) {\n\t\tswitch (ac->req->operation) {\n\t\tcase LDB_ADD:\n\t\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t\t       \"Failed to add %s: %s\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn),\n\t\t\t\t\t       map[i].error_string);\n\t\t\tbreak;\n\t\tcase LDB_MODIFY:\n\t\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t\t       \"Failed to modify %s: %s\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn),\n\t\t\t\t\t       map[i].error_string);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn ldb_module_operr(ac->module);\n\t\t}\n\t}\n\treturn ret;\n}\n\n/*\n * It would be best if these rules apply, always, but for now they\n * apply only to non-admins\n */\nstatic int samldb_check_user_account_control_objectclass_invariants(\n\tstruct samldb_ctx *ac,\n\tuint32_t user_account_control,\n\tuint32_t user_account_control_old,\n\tbool is_computer_objectclass)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\n\tuint32_t old_ufa = user_account_control_old & UF_ACCOUNT_TYPE_MASK;\n\tuint32_t new_ufa = user_account_control & UF_ACCOUNT_TYPE_MASK;\n\n\tuint32_t old_rodc = user_account_control_old & UF_PARTIAL_SECRETS_ACCOUNT;\n\tuint32_t new_rodc = user_account_control & UF_PARTIAL_SECRETS_ACCOUNT;\n\n\tbool is_admin;\n\tstruct security_token *user_token\n\t\t= acl_user_token(ac->module);\n\tif (user_token == NULL) {\n\t\treturn LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n\t}\n\n\tis_admin\n\t\t= security_token_has_builtin_administrators(user_token);\n\n\n\t/*\n\t * We want to allow changes to (eg) disable an account\n\t * that was created wrong, only checking the\n\t * objectclass if the account type changes.\n\t */\n\tif (old_ufa == new_ufa && old_rodc == new_rodc) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tswitch (new_ufa) {\n\tcase UF_NORMAL_ACCOUNT:\n\t\tif (is_computer_objectclass && !is_admin) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\"%08X: samldb: UF_NORMAL_ACCOUNT \"\n\t\t\t\t\"requires objectclass 'user' not 'computer'!\",\n\t\t\t\tW_ERROR_V(WERR_DS_MACHINE_ACCOUNT_CREATED_PRENT4));\n\t\t\treturn LDB_ERR_OBJECT_CLASS_VIOLATION;\n\t\t}\n\t\tbreak;\n\n\tcase UF_INTERDOMAIN_TRUST_ACCOUNT:\n\t\tif (is_computer_objectclass) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\"%08X: samldb: UF_INTERDOMAIN_TRUST_ACCOUNT \"\n\t\t\t\t\"requires objectclass 'user' not 'computer'!\",\n\t\t\t\tW_ERROR_V(WERR_DS_MACHINE_ACCOUNT_CREATED_PRENT4));\n\t\t\treturn LDB_ERR_OBJECT_CLASS_VIOLATION;\n\t\t}\n\t\tbreak;\n\n\tcase UF_WORKSTATION_TRUST_ACCOUNT:\n\t\tif (!is_computer_objectclass) {\n\t\t\t/*\n\t\t\t * Modify of a user account account into a\n\t\t\t * workstation without objectclass computer\n\t\t\t * as an admin is still permitted, but not\n\t\t\t * to make an RODC\n\t\t\t */\n\t\t\tif (is_admin\n\t\t\t    && ac->req->operation == LDB_MODIFY\n\t\t\t    && new_rodc == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\"%08X: samldb: UF_WORKSTATION_TRUST_ACCOUNT \"\n\t\t\t\t\"requires objectclass 'computer'!\",\n\t\t\t\tW_ERROR_V(WERR_DS_MACHINE_ACCOUNT_CREATED_PRENT4));\n\t\t\treturn LDB_ERR_OBJECT_CLASS_VIOLATION;\n\t\t}\n\t\tbreak;\n\n\tcase UF_SERVER_TRUST_ACCOUNT:\n\t\tif (!is_computer_objectclass) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\"%08X: samldb: UF_SERVER_TRUST_ACCOUNT \"\n\t\t\t\t\"requires objectclass 'computer'!\",\n\t\t\t\tW_ERROR_V(WERR_DS_MACHINE_ACCOUNT_CREATED_PRENT4));\n\t\t\treturn LDB_ERR_OBJECT_CLASS_VIOLATION;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\"%08X: samldb: invalid userAccountControl[0x%08X]\",\n\t\t\tW_ERROR_V(WERR_INVALID_PARAMETER),\n\t\t\t\t       user_account_control);\n\t\treturn LDB_ERR_OTHER;\n\t}\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_get_domain_secdesc_and_oc(struct samldb_ctx *ac,\n\t\t\t\t\t    struct security_descriptor **domain_sd,\n\t\t\t\t\t    const struct dsdb_class **objectclass)\n{\n\tconst char * const sd_attrs[] = {\"ntSecurityDescriptor\", \"objectClass\", NULL};\n\tstruct ldb_result *res;\n\tstruct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));\n\tconst struct dsdb_schema *schema = NULL;\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret = dsdb_module_search_dn(ac->module, ac, &res,\n\t\t\t\t\tdomain_dn,\n\t\t\t\t\tsd_attrs,\n\t\t\t\t\tDSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED,\n\t\t\t\t\tac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (res->count != 1) {\n\t\treturn ldb_module_operr(ac->module);\n\t}\n\n\tschema = dsdb_get_schema(ldb, ac->req);\n\tif (!schema) {\n\t\treturn ldb_module_operr(ac->module);;\n\t}\n\t*objectclass = dsdb_get_structural_oc_from_msg(schema, res->msgs[0]);\n\treturn dsdb_get_sd_from_ldb_message(ldb_module_get_ctx(ac->module),\n\t\t\t\t\t    ac, res->msgs[0], domain_sd);\n\n}\n\n/**\n * Validate that the restriction in point 5 of MS-SAMR 3.1.1.8.10 userAccountControl is honoured\n *\n */\nstatic int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n\t\t\t\t\t\t struct dom_sid *sid,\n\t\t\t\t\t\t uint32_t user_account_control,\n\t\t\t\t\t\t uint32_t user_account_control_old)\n{\n\tsize_t i;\n\tint ret = 0;\n\tbool need_acl_check = false;\n\tstruct security_token *user_token;\n\tstruct security_descriptor *domain_sd;\n\tconst struct dsdb_class *objectclass = NULL;\n\tconst struct uac_to_guid {\n\t\tuint32_t uac;\n\t\tuint32_t priv_to_change_from;\n\t\tconst char *oid;\n\t\tconst char *guid;\n\t\tenum sec_privilege privilege;\n\t\tbool delete_is_privileged;\n\t\tbool admin_required;\n\t\tconst char *error_string;\n\t} map[] = {\n\t\t{\n\t\t\t.uac = UF_PASSWD_NOTREQD,\n\t\t\t.guid = GUID_DRS_UPDATE_PASSWORD_NOT_REQUIRED_BIT,\n\t\t\t.error_string = \"Adding the UF_PASSWD_NOTREQD bit in userAccountControl requires the Update-Password-Not-Required-Bit right that was not given on the Domain object\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_DONT_EXPIRE_PASSWD,\n\t\t\t.guid = GUID_DRS_UNEXPIRE_PASSWORD,\n\t\t\t.error_string = \"Adding the UF_DONT_EXPIRE_PASSWD bit in userAccountControl requires the Unexpire-Password right that was not given on the Domain object\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,\n\t\t\t.guid = GUID_DRS_ENABLE_PER_USER_REVERSIBLY_ENCRYPTED_PASSWORD,\n\t\t\t.error_string = \"Adding the UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED bit in userAccountControl requires the Enable-Per-User-Reversibly-Encrypted-Password right that was not given on the Domain object\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_SERVER_TRUST_ACCOUNT,\n\t\t\t.guid = GUID_DRS_DS_INSTALL_REPLICA,\n\t\t\t.error_string = \"Adding the UF_SERVER_TRUST_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_PARTIAL_SECRETS_ACCOUNT,\n\t\t\t.guid = GUID_DRS_DS_INSTALL_REPLICA,\n\t\t\t.error_string = \"Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_WORKSTATION_TRUST_ACCOUNT,\n\t\t\t.priv_to_change_from = UF_NORMAL_ACCOUNT,\n\t\t\t.error_string = \"Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_NORMAL_ACCOUNT,\n\t\t\t.priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,\n\t\t\t.error_string = \"Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_INTERDOMAIN_TRUST_ACCOUNT,\n\t\t\t.oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,\n\t\t\t.error_string = \"Updating the UF_INTERDOMAIN_TRUST_ACCOUNT bit in userAccountControl is not permitted over LDAP.  This bit is restricted to the LSA CreateTrustedDomain interface\",\n\t\t\t.delete_is_privileged = true\n\t\t},\n\t\t{\n\t\t\t.uac = UF_TRUSTED_FOR_DELEGATION,\n\t\t\t.privilege = SEC_PRIV_ENABLE_DELEGATION,\n\t\t\t.delete_is_privileged = true,\n\t\t\t.error_string = \"Updating the UF_TRUSTED_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege\"\n\t\t},\n\t\t{\n\t\t\t.uac = UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION,\n\t\t\t.privilege = SEC_PRIV_ENABLE_DELEGATION,\n\t\t\t.delete_is_privileged = true,\n\t\t\t.error_string = \"Updating the UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION bit in userAccountControl is not permitted without the SeEnableDelegationPrivilege\"\n\t\t}\n\n\t};\n\n\tif (dsdb_module_am_system(ac->module)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(map); i++) {\n\t\tif (user_account_control & map[i].uac) {\n\t\t\tneed_acl_check = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (need_acl_check == false) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tuser_token = acl_user_token(ac->module);\n\tif (user_token == NULL) {\n\t\treturn LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n\t}\n\n\tret = samldb_get_domain_secdesc_and_oc(ac, &domain_sd, &objectclass);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(map); i++) {\n\t\tuint32_t this_uac_new = user_account_control & map[i].uac;\n\t\tuint32_t this_uac_old = user_account_control_old & map[i].uac;\n\t\tif (this_uac_new != this_uac_old) {\n\t\t\tif (this_uac_old != 0) {\n\t\t\t\tif (map[i].delete_is_privileged == false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (map[i].oid) {\n\t\t\t\tstruct ldb_control *control = ldb_request_get_control(ac->req, map[i].oid);\n\t\t\t\tif (control == NULL) {\n\t\t\t\t\tret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n\t\t\t\t}\n\t\t\t} else if (map[i].privilege != SEC_PRIV_INVALID) {\n\t\t\t\tbool have_priv = security_token_has_privilege(user_token,\n\t\t\t\t\t\t\t\t\t      map[i].privilege);\n\t\t\t\tif (have_priv == false) {\n\t\t\t\t\tret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n\t\t\t\t}\n\t\t\t} else if (map[i].priv_to_change_from & user_account_control_old) {\n\t\t\t\tbool is_admin = security_token_has_builtin_administrators(user_token);\n\t\t\t\tif (is_admin == false) {\n\t\t\t\t\tret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n\t\t\t\t}\n\t\t\t} else if (map[i].guid) {\n\t\t\t\tret = acl_check_extended_right(ac,\n\t\t\t\t\t\t\t       ac->module,\n\t\t\t\t\t\t\t       ac->req,\n\t\t\t\t\t\t\t       objectclass,\n\t\t\t\t\t\t\t       domain_sd,\n\t\t\t\t\t\t\t       user_token,\n\t\t\t\t\t\t\t       map[i].guid,\n\t\t\t\t\t\t\t       SEC_ADS_CONTROL_ACCESS,\n\t\t\t\t\t\t\t       sid);\n\t\t\t} else {\n\t\t\t\tret = LDB_SUCCESS;\n\t\t\t}\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (ret == LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS) {\n\t\tswitch (ac->req->operation) {\n\t\tcase LDB_ADD:\n\t\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t\t       \"Failed to add %s: %s\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn),\n\t\t\t\t\t       map[i].error_string);\n\t\t\tbreak;\n\t\tcase LDB_MODIFY:\n\t\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t\t       \"Failed to modify %s: %s\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn),\n\t\t\t\t\t       map[i].error_string);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn ldb_module_operr(ac->module);\n\t\t}\n\t\tif (map[i].guid) {\n\t\t\tstruct ldb_dn *domain_dn\n\t\t\t\t= ldb_get_default_basedn(ldb_module_get_ctx(ac->module));\n\t\t\tdsdb_acl_debug(domain_sd, acl_user_token(ac->module),\n\t\t\t\t       domain_dn,\n\t\t\t\t       true,\n\t\t\t\t       10);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int samldb_check_user_account_control_rules(struct samldb_ctx *ac,\n\t\t\t\t\t\t   struct dom_sid *sid,\n\t\t\t\t\t\t   uint32_t req_uac,\n\t\t\t\t\t\t   uint32_t user_account_control,\n\t\t\t\t\t\t   uint32_t user_account_control_old,\n\t\t\t\t\t\t   bool is_computer_objectclass)\n{\n\tint ret;\n\tstruct dsdb_control_password_user_account_control *uac = NULL;\n\n\tret = samldb_check_user_account_control_invariants(ac, user_account_control);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tret = samldb_check_user_account_control_objectclass_invariants(ac,\n\t\t\t\t\t\t\t\t       user_account_control,\n\t\t\t\t\t\t\t\t       user_account_control_old,\n\t\t\t\t\t\t\t\t       is_computer_objectclass);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = samldb_check_user_account_control_acl(ac, sid, user_account_control, user_account_control_old);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tuac = talloc_zero(ac->req,\n\t\t\t  struct dsdb_control_password_user_account_control);\n\tif (uac == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\n\tuac->req_flags = req_uac;\n\tuac->old_flags = user_account_control_old;\n\tuac->new_flags = user_account_control;\n\n\tret = ldb_request_add_control(ac->req,\n\t\t\t\tDSDB_CONTROL_PASSWORD_USER_ACCOUNT_CONTROL_OID,\n\t\t\t\tfalse, uac);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\n\n/**\n * This function is called on LDB modify operations. It performs some additions/\n * replaces on the current LDB message when \"userAccountControl\" changes.\n */\nstatic int samldb_user_account_control_change(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tuint32_t old_uac;\n\tuint32_t new_uac;\n\tuint32_t raw_uac;\n\tuint32_t old_ufa;\n\tuint32_t new_ufa;\n\tuint32_t old_uac_computed;\n\tuint32_t clear_uac;\n\tuint32_t old_atype;\n\tuint32_t new_atype;\n\tuint32_t old_pgrid;\n\tuint32_t new_pgrid;\n\tNTTIME old_lockoutTime;\n\tstruct ldb_message_element *el;\n\tstruct ldb_val *val;\n\tstruct ldb_val computer_val;\n\tstruct ldb_message *tmp_msg;\n\tstruct dom_sid *sid;\n\tint ret;\n\tstruct ldb_result *res;\n\tconst char * const attrs[] = {\n\t\t\"objectClass\",\n\t\t\"isCriticalSystemObject\",\n\t\t\"userAccountControl\",\n\t\t\"msDS-User-Account-Control-Computed\",\n\t\t\"lockoutTime\",\n\t\t\"objectSid\",\n\t\tNULL\n\t};\n\tbool is_computer_objectclass = false;\n\tbool old_is_critical = false;\n\tbool new_is_critical = false;\n\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"userAccountControl\",\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (el == NULL || el->num_values == 0) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\"%08X: samldb: 'userAccountControl' can't be deleted!\",\n\t\t\tW_ERROR_V(WERR_DS_ILLEGAL_MOD_OPERATION));\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t/* Create a temporary message for fetching the \"userAccountControl\" */\n\ttmp_msg = ldb_msg_new(ac->msg);\n\tif (tmp_msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tret = ldb_msg_add(tmp_msg, el, 0);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\traw_uac = ldb_msg_find_attr_as_uint(tmp_msg,\n\t\t\t\t\t    \"userAccountControl\",\n\t\t\t\t\t    0);\n\ttalloc_free(tmp_msg);\n\t/*\n\t * UF_LOCKOUT, UF_PASSWD_CANT_CHANGE and UF_PASSWORD_EXPIRED\n\t * are only generated and not stored. We ignore them almost\n\t * completely, along with unknown bits and UF_SCRIPT.\n\t *\n\t * The only exception is ACB_AUTOLOCK, which features in\n\t * clear_acb when the bit is cleared in this modify operation.\n\t *\n\t * MS-SAMR 2.2.1.13 UF_FLAG Codes states that some bits are\n\t * ignored by clients and servers\n\t */\n\tnew_uac = raw_uac & UF_SETTABLE_BITS;\n\n\t/* Fetch the old \"userAccountControl\" and \"objectClass\" */\n\tret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn, attrs,\n\t\t\t\t    DSDB_FLAG_NEXT_MODULE, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\told_uac = ldb_msg_find_attr_as_uint(res->msgs[0], \"userAccountControl\", 0);\n\tif (old_uac == 0) {\n\t\treturn ldb_operr(ldb);\n\t}\n\told_uac_computed = ldb_msg_find_attr_as_uint(res->msgs[0],\n\t\t\t\t\t\t     \"msDS-User-Account-Control-Computed\", 0);\n\told_lockoutTime = ldb_msg_find_attr_as_int64(res->msgs[0],\n\t\t\t\t\t\t     \"lockoutTime\", 0);\n\told_is_critical = ldb_msg_find_attr_as_bool(res->msgs[0],\n\t\t\t\t\t\t    \"isCriticalSystemObject\", 0);\n\t/*\n\t * When we do not have objectclass \"computer\" we cannot\n\t * switch to a workstation or (RO)DC\n\t */\n\tel = ldb_msg_find_element(res->msgs[0], \"objectClass\");\n\tif (el == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\tcomputer_val = data_blob_string_const(\"computer\");\n\tval = ldb_msg_find_val(el, &computer_val);\n\tif (val != NULL) {\n\t\tis_computer_objectclass = true;\n\t}\n\n\told_ufa = old_uac & UF_ACCOUNT_TYPE_MASK;\n\told_atype = ds_uf2atype(old_ufa);\n\told_pgrid = ds_uf2prim_group_rid(old_uac);\n\n\tnew_ufa = new_uac & UF_ACCOUNT_TYPE_MASK;\n\tif (new_ufa == 0) {\n\t\t/*\n\t\t * \"userAccountControl\" = 0 or missing one of the\n\t\t * types means \"UF_NORMAL_ACCOUNT\".  See MS-SAMR\n\t\t * 3.1.1.8.10 point 8\n\t\t */\n\t\tnew_ufa = UF_NORMAL_ACCOUNT;\n\t\tnew_uac |= new_ufa;\n\t}\n\tsid = samdb_result_dom_sid(res, res->msgs[0], \"objectSid\");\n\tif (sid == NULL) {\n\t\treturn ldb_module_operr(ac->module);\n\t}\n\n\tret = samldb_check_user_account_control_rules(ac, sid,\n\t\t\t\t\t\t      raw_uac,\n\t\t\t\t\t\t      new_uac,\n\t\t\t\t\t\t      old_uac,\n\t\t\t\t\t\t      is_computer_objectclass);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tnew_atype = ds_uf2atype(new_ufa);\n\tnew_pgrid = ds_uf2prim_group_rid(new_uac);\n\n\tclear_uac = (old_uac | old_uac_computed) & ~raw_uac;\n\n\tswitch (new_ufa) {\n\tcase UF_NORMAL_ACCOUNT:\n\t\tnew_is_critical = old_is_critical;\n\t\tbreak;\n\n\tcase UF_INTERDOMAIN_TRUST_ACCOUNT:\n\t\tnew_is_critical = true;\n\t\tbreak;\n\n\tcase UF_WORKSTATION_TRUST_ACCOUNT:\n\t\tnew_is_critical = false;\n\t\tif (new_uac & UF_PARTIAL_SECRETS_ACCOUNT) {\n\t\t\tnew_is_critical = true;\n\t\t}\n\t\tbreak;\n\n\tcase UF_SERVER_TRUST_ACCOUNT:\n\t\tnew_is_critical = true;\n\t\tbreak;\n\n\tdefault:\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\"%08X: samldb: invalid userAccountControl[0x%08X]\",\n\t\t\tW_ERROR_V(WERR_INVALID_PARAMETER), raw_uac);\n\t\treturn LDB_ERR_OTHER;\n\t}\n\n\tif (old_atype != new_atype) {\n\t\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg,\n\t\t\t\t\t \"sAMAccountType\", new_atype);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t\tel = ldb_msg_find_element(ac->msg, \"sAMAccountType\");\n\t\tel->flags = LDB_FLAG_MOD_REPLACE;\n\t}\n\n\t/* As per MS-SAMR 3.1.1.8.10 these flags have not to be set */\n\tif ((clear_uac & UF_LOCKOUT) && (old_lockoutTime != 0)) {\n\t\t/* \"lockoutTime\" reset as per MS-SAMR 3.1.1.8.10 */\n\t\tldb_msg_remove_attr(ac->msg, \"lockoutTime\");\n\t\tret = samdb_msg_add_uint64(ldb, ac->msg, ac->msg, \"lockoutTime\",\n\t\t\t\t\t   (NTTIME)0);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t\tel = ldb_msg_find_element(ac->msg, \"lockoutTime\");\n\t\tel->flags = LDB_FLAG_MOD_REPLACE;\n\t}\n\n\t/*\n\t * \"isCriticalSystemObject\" might be set/changed\n\t *\n\t * Even a change from UF_NORMAL_ACCOUNT (implicitly FALSE) to\n\t * UF_WORKSTATION_TRUST_ACCOUNT (actually FALSE) triggers\n\t * creating the attribute.\n\t */\n\tif (old_is_critical != new_is_critical || old_atype != new_atype) {\n\t\tret = ldb_msg_add_string(ac->msg, \"isCriticalSystemObject\",\n\t\t\t\t\t new_is_critical ? \"TRUE\": \"FALSE\");\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t\tel = ldb_msg_find_element(ac->msg,\n\t\t\t\t\t   \"isCriticalSystemObject\");\n\t\tel->flags = LDB_FLAG_MOD_REPLACE;\n\t}\n\n\tif (!ldb_msg_find_element(ac->msg, \"primaryGroupID\") &&\n\t    (old_pgrid != new_pgrid)) {\n\t\t/* Older AD deployments don't know about the RODC group */\n\t\tif (new_pgrid == DOMAIN_RID_READONLY_DCS) {\n\t\t\tret = samldb_prim_group_tester(ac, new_pgrid);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg,\n\t\t\t\t\t \"primaryGroupID\", new_pgrid);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t\tel = ldb_msg_find_element(ac->msg,\n\t\t\t\t\t   \"primaryGroupID\");\n\t\tel->flags = LDB_FLAG_MOD_REPLACE;\n\t}\n\n\t/* Propagate eventual \"userAccountControl\" attribute changes */\n\tif (old_uac != new_uac) {\n\t\tchar *tempstr = talloc_asprintf(ac->msg, \"%d\",\n\t\t\t\t\t\tnew_uac);\n\t\tif (tempstr == NULL) {\n\t\t\treturn ldb_module_oom(ac->module);\n\t\t}\n\n\t\tret = ldb_msg_add_empty(ac->msg,\n\t\t\t\t\t\"userAccountControl\",\n\t\t\t\t\tLDB_FLAG_MOD_REPLACE,\n\t\t\t\t\t&el);\n\t\tel->values = talloc(ac->msg, struct ldb_val);\n\t\tel->num_values = 1;\n\t\tel->values[0].data = (uint8_t *) tempstr;\n\t\tel->values[0].length = strlen(tempstr);\n\t} else {\n\t\tldb_msg_remove_attr(ac->msg, \"userAccountControl\");\n\t}\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_check_pwd_last_set_acl(struct samldb_ctx *ac,\n\t\t\t\t\t struct dom_sid *sid)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret = 0;\n\tstruct security_token *user_token = NULL;\n\tstruct security_descriptor *domain_sd = NULL;\n\tstruct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));\n\tconst char *operation = \"\";\n\tconst struct dsdb_class *objectclass = NULL;\n\n\tif (dsdb_module_am_system(ac->module)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tswitch (ac->req->operation) {\n\tcase LDB_ADD:\n\t\toperation = \"add\";\n\t\tbreak;\n\tcase LDB_MODIFY:\n\t\toperation = \"modify\";\n\t\tbreak;\n\tdefault:\n\t\treturn ldb_module_operr(ac->module);\n\t}\n\n\tuser_token = acl_user_token(ac->module);\n\tif (user_token == NULL) {\n\t\treturn LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n\t}\n\n\tret = samldb_get_domain_secdesc_and_oc(ac, &domain_sd, &objectclass);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tret = acl_check_extended_right(ac,\n\t\t\t\t       ac->module,\n\t\t\t\t       ac->req,\n\t\t\t\t       objectclass,\n\t\t\t\t       domain_sd,\n\t\t\t\t       user_token,\n\t\t\t\t       GUID_DRS_UNEXPIRE_PASSWORD,\n\t\t\t\t       SEC_ADS_CONTROL_ACCESS,\n\t\t\t\t       sid);\n\tif (ret != LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS) {\n\t\treturn ret;\n\t}\n\n\tldb_debug_set(ldb, LDB_DEBUG_WARNING,\n\t\t      \"Failed to %s %s: \"\n\t\t      \"Setting pwdLastSet to -1 requires the \"\n\t\t      \"Unexpire-Password right that was not given \"\n\t\t      \"on the Domain object\",\n\t\t      operation,\n\t\t      ldb_dn_get_linearized(ac->msg->dn));\n\tdsdb_acl_debug(domain_sd, user_token,\n\t\t       domain_dn, true, 10);\n\n\treturn ret;\n}\n\n/**\n * This function is called on LDB modify operations. It performs some additions/\n * replaces on the current LDB message when \"pwdLastSet\" changes.\n */\nstatic int samldb_pwd_last_set_change(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tNTTIME last_set = 0;\n\tstruct ldb_message_element *el = NULL;\n\tstruct ldb_message *tmp_msg = NULL;\n\tstruct dom_sid *self_sid = NULL;\n\tint ret;\n\tstruct ldb_result *res = NULL;\n\tconst char * const attrs[] = {\n\t\t\"objectSid\",\n\t\tNULL\n\t};\n\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"pwdLastSet\",\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (el == NULL || el->num_values == 0) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\"%08X: samldb: 'pwdLastSet' can't be deleted!\",\n\t\t\tW_ERROR_V(WERR_DS_ILLEGAL_MOD_OPERATION));\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t/* Create a temporary message for fetching the \"userAccountControl\" */\n\ttmp_msg = ldb_msg_new(ac->msg);\n\tif (tmp_msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tret = ldb_msg_add(tmp_msg, el, 0);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tlast_set = samdb_result_nttime(tmp_msg, \"pwdLastSet\", 0);\n\ttalloc_free(tmp_msg);\n\n\t/*\n\t * Setting -1 (0xFFFFFFFFFFFFFFFF) requires the Unexpire-Password right\n\t */\n\tif (last_set != UINT64_MAX) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* Fetch the \"objectSid\" */\n\tret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn, attrs,\n\t\t\t\t    DSDB_FLAG_NEXT_MODULE, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tself_sid = samdb_result_dom_sid(res, res->msgs[0], \"objectSid\");\n\tif (self_sid == NULL) {\n\t\treturn ldb_module_operr(ac->module);\n\t}\n\n\tret = samldb_check_pwd_last_set_acl(ac, self_sid);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_lockout_time(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tNTTIME lockoutTime;\n\tstruct ldb_message_element *el;\n\tstruct ldb_message *tmp_msg;\n\tint ret;\n\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"lockoutTime\",\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (el == NULL || el->num_values == 0) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\"%08X: samldb: 'lockoutTime' can't be deleted!\",\n\t\t\tW_ERROR_V(WERR_DS_ILLEGAL_MOD_OPERATION));\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t/* Create a temporary message for fetching the \"lockoutTime\" */\n\ttmp_msg = ldb_msg_new(ac->msg);\n\tif (tmp_msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tret = ldb_msg_add(tmp_msg, el, 0);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tlockoutTime = ldb_msg_find_attr_as_int64(tmp_msg,\n\t\t\t\t\t\t \"lockoutTime\",\n\t\t\t\t\t\t 0);\n\ttalloc_free(tmp_msg);\n\n\tif (lockoutTime != 0) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* lockoutTime == 0 resets badPwdCount */\n\tldb_msg_remove_attr(ac->msg, \"badPwdCount\");\n\tret = samdb_msg_add_int(ldb, ac->msg, ac->msg,\n\t\t\t\t\"badPwdCount\", 0);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tel = ldb_msg_find_element(ac->msg, \"badPwdCount\");\n\tel->flags = LDB_FLAG_MOD_REPLACE;\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_group_type_change(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tuint32_t group_type, old_group_type, account_type;\n\tstruct ldb_message_element *el;\n\tstruct ldb_message *tmp_msg;\n\tint ret;\n\tstruct ldb_result *res;\n\tconst char * const attrs[] = { \"groupType\", NULL };\n\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"groupType\",\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (el == NULL) {\n\t\t/* we are not affected */\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* Create a temporary message for fetching the \"groupType\" */\n\ttmp_msg = ldb_msg_new(ac->msg);\n\tif (tmp_msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tret = ldb_msg_add(tmp_msg, el, 0);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tgroup_type = ldb_msg_find_attr_as_uint(tmp_msg, \"groupType\", 0);\n\ttalloc_free(tmp_msg);\n\n\tret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn, attrs,\n\t\t\t\t    DSDB_FLAG_NEXT_MODULE |\n\t\t\t\t    DSDB_SEARCH_SHOW_DELETED, ac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\told_group_type = ldb_msg_find_attr_as_uint(res->msgs[0], \"groupType\", 0);\n\tif (old_group_type == 0) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\t/* Group type switching isn't so easy as it seems: We can only\n\t * change in this directions: global <-> universal <-> local\n\t * On each step also the group type itself\n\t * (security/distribution) is variable. */\n\n\tif (ldb_request_get_control(ac->req, LDB_CONTROL_PROVISION_OID) == NULL) {\n\t\tswitch (group_type) {\n\t\tcase GTYPE_SECURITY_GLOBAL_GROUP:\n\t\tcase GTYPE_DISTRIBUTION_GLOBAL_GROUP:\n\t\t\t/* change to \"universal\" allowed */\n\t\t\tif ((old_group_type == GTYPE_SECURITY_DOMAIN_LOCAL_GROUP) ||\n\t\t\t(old_group_type == GTYPE_DISTRIBUTION_DOMAIN_LOCAL_GROUP)) {\n\t\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t\"samldb: Change from security/distribution local group forbidden!\");\n\t\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t\t}\n\t\tbreak;\n\n\t\tcase GTYPE_SECURITY_UNIVERSAL_GROUP:\n\t\tcase GTYPE_DISTRIBUTION_UNIVERSAL_GROUP:\n\t\t\t/* each change allowed */\n\t\tbreak;\n\t\tcase GTYPE_SECURITY_DOMAIN_LOCAL_GROUP:\n\t\tcase GTYPE_DISTRIBUTION_DOMAIN_LOCAL_GROUP:\n\t\t\t/* change to \"universal\" allowed */\n\t\t\tif ((old_group_type == GTYPE_SECURITY_GLOBAL_GROUP) ||\n\t\t\t(old_group_type == GTYPE_DISTRIBUTION_GLOBAL_GROUP)) {\n\t\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t\"samldb: Change from security/distribution global group forbidden!\");\n\t\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t\t}\n\t\tbreak;\n\n\t\tcase GTYPE_SECURITY_BUILTIN_LOCAL_GROUP:\n\t\tdefault:\n\t\t\t/* we don't allow this \"groupType\" values */\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\tbreak;\n\t\t}\n\t}\n\n\taccount_type =  ds_gtype2atype(group_type);\n\tif (account_type == 0) {\n\t\tldb_set_errstring(ldb, \"samldb: Unrecognized account type!\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\tret = samdb_msg_add_uint(ldb, ac->msg, ac->msg, \"sAMAccountType\",\n\t\t\t\t account_type);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tel = ldb_msg_find_element(ac->msg, \"sAMAccountType\");\n\tel->flags = LDB_FLAG_MOD_REPLACE;\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_member_check(struct samldb_ctx *ac)\n{\n\tconst char * const attrs[] = { \"objectSid\", NULL };\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tstruct ldb_message_element *el;\n\tstruct ldb_dn *member_dn;\n\tstruct dom_sid *sid;\n\tstruct ldb_result *res;\n\tstruct dom_sid *group_sid;\n\tunsigned int i, j;\n\tint ret;\n\n\t/* Fetch information from the existing object */\n\n\tret = dsdb_module_search(ac->module, ac, &res, ac->msg->dn, LDB_SCOPE_BASE, attrs,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED, ac->req, NULL);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (res->count != 1) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tgroup_sid = samdb_result_dom_sid(res, res->msgs[0], \"objectSid\");\n\tif (group_sid == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\t/* We've to walk over all modification entries and consider the \"member\"\n\t * ones. */\n\tfor (i = 0; i < ac->msg->num_elements; i++) {\n\t\tif (ldb_attr_cmp(ac->msg->elements[i].name, \"member\") != 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tel = &ac->msg->elements[i];\n\t\tfor (j = 0; j < el->num_values; j++) {\n\t\t\tstruct ldb_result *group_res;\n\t\t\tconst char *group_attrs[] = { \"primaryGroupID\" , NULL };\n\t\t\tuint32_t prim_group_rid;\n\n\t\t\tif (LDB_FLAG_MOD_TYPE(el->flags) == LDB_FLAG_MOD_DELETE) {\n\t\t\t\t/* Deletes will be handled in\n\t\t\t\t * repl_meta_data, and deletes not\n\t\t\t\t * matching a member will return\n\t\t\t\t * LDB_ERR_UNWILLING_TO_PERFORM\n\t\t\t\t * there */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmember_dn = ldb_dn_from_ldb_val(ac, ldb,\n\t\t\t\t\t\t\t&el->values[j]);\n\t\t\tif (!ldb_dn_validate(member_dn)) {\n\t\t\t\treturn ldb_operr(ldb);\n\t\t\t}\n\n\t\t\t/* Denies to add \"member\"s to groups which are primary\n\t\t\t * ones for them - in this case return\n\t\t\t * ERR_ENTRY_ALREADY_EXISTS. */\n\n\t\t\tret = dsdb_module_search_dn(ac->module, ac, &group_res,\n\t\t\t\t\t\t    member_dn, group_attrs,\n\t\t\t\t\t\t    DSDB_FLAG_NEXT_MODULE, ac->req);\n\t\t\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\t\t\t/* member DN doesn't exist yet */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tprim_group_rid = ldb_msg_find_attr_as_uint(group_res->msgs[0], \"primaryGroupID\", (uint32_t)-1);\n\t\t\tif (prim_group_rid == (uint32_t) -1) {\n\t\t\t\t/* the member hasn't to be a user account ->\n\t\t\t\t * therefore no check needed in this case. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsid = dom_sid_add_rid(ac, samdb_domain_sid(ldb),\n\t\t\t\t\t      prim_group_rid);\n\t\t\tif (sid == NULL) {\n\t\t\t\treturn ldb_operr(ldb);\n\t\t\t}\n\n\t\t\tif (dom_sid_equal(group_sid, sid)) {\n\t\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t\t       \"samldb: member %s already set via primaryGroupID %u\",\n\t\t\t\t\t\t       ldb_dn_get_linearized(member_dn), prim_group_rid);\n\t\t\t\treturn LDB_ERR_ENTRY_ALREADY_EXISTS;\n\t\t\t}\n\t\t}\n\t}\n\n\ttalloc_free(res);\n\n\treturn LDB_SUCCESS;\n}\n\n/* SAM objects have special rules regarding the \"description\" attribute on\n * modify operations. */\nstatic int samldb_description_check(struct samldb_ctx *ac, bool *modified)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tconst char * const attrs[] = { \"objectClass\", \"description\", NULL };\n\tstruct ldb_result *res;\n\tunsigned int i;\n\tint ret;\n\n\t/* Fetch information from the existing object */\n\tret = dsdb_module_search(ac->module, ac, &res, ac->msg->dn, LDB_SCOPE_BASE, attrs,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED, ac->req,\n\t\t\t\t \"(|(objectclass=user)(objectclass=group)(objectclass=samDomain)(objectclass=samServer))\");\n\tif (ret != LDB_SUCCESS) {\n\t\t/* don't treat it specially ... let normal error codes\n\t\t   happen from other places */\n\t\tldb_reset_err_string(ldb);\n\t\treturn LDB_SUCCESS;\n\t}\n\tif (res->count == 0) {\n\t\t/* we didn't match the filter */\n\t\ttalloc_free(res);\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* We've to walk over all modification entries and consider the\n\t * \"description\" ones. */\n\tfor (i = 0; i < ac->msg->num_elements; i++) {\n\t\tif (ldb_attr_cmp(ac->msg->elements[i].name, \"description\") == 0) {\n\t\t\tac->msg->elements[i].flags |= LDB_FLAG_INTERNAL_FORCE_SINGLE_VALUE_CHECK;\n\t\t\t*modified = true;\n\t\t}\n\t}\n\n\ttalloc_free(res);\n\n\treturn LDB_SUCCESS;\n}\n\n#define SPN_ALIAS_NONE 0\n#define SPN_ALIAS_LINK 1\n#define SPN_ALIAS_TARGET 2\n\nstatic int find_spn_aliases(struct ldb_context *ldb,\n\t\t\t    TALLOC_CTX *mem_ctx,\n\t\t\t    const char *service_class,\n\t\t\t    char ***aliases,\n\t\t\t    size_t *n_aliases,\n\t\t\t    int *direction)\n{\n\t/*\n\t * If you change the way this works, you should also look at changing\n\t * LDB_lookup_spn_alias() in source4/dsdb/samdb/cracknames.c, which\n\t * does some of the same work.\n\t *\n\t * In particular, note that sPNMappings are resolved on a first come,\n\t * first served basis. For example, if we have\n\t *\n\t *  host=ldap,cifs\n\t *  foo=ldap\n\t *  cifs=host,alerter\n\t *\n\t * then 'ldap', 'cifs', and 'host' will resolve to 'host', and\n\t * 'alerter' will resolve to 'cifs'.\n\t *\n\t * If this resolution method is made more complicated, then the\n\t * cracknames function should also be changed.\n\t */\n\tsize_t i, j;\n\tint ret;\n\tbool ok;\n\tstruct ldb_result *res = NULL;\n\tstruct ldb_message_element *spnmappings = NULL;\n\tTALLOC_CTX *tmp_ctx = NULL;\n\tstruct ldb_dn *service_dn = NULL;\n\n\tconst char *attrs[] = {\n\t\t\"sPNMappings\",\n\t\tNULL\n\t};\n\n\t*direction = SPN_ALIAS_NONE;\n\n\ttmp_ctx = talloc_new(mem_ctx);\n\tif (tmp_ctx == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\n\tservice_dn = ldb_dn_new(\n\t\ttmp_ctx, ldb,\n\t\t\"CN=Directory Service,CN=Windows NT,CN=Services\");\n\tif (service_dn == NULL) {\n\t\ttalloc_free(tmp_ctx);\n\t\treturn ldb_oom(ldb);\n\t}\n\n\tok = ldb_dn_add_base(service_dn, ldb_get_config_basedn(ldb));\n\tif (! ok) {\n\t\ttalloc_free(tmp_ctx);\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n\n\tret = ldb_search(ldb, tmp_ctx, &res, service_dn, LDB_SCOPE_BASE,\n\t\t\t attrs, \"(objectClass=nTDSService)\");\n\n\tif (ret != LDB_SUCCESS || res->count != 1) {\n\t\tDBG_WARNING(\"sPNMappings not found.\\n\");\n\t\ttalloc_free(tmp_ctx);\n\t\treturn ret;\n\t}\n\n\tspnmappings = ldb_msg_find_element(res->msgs[0], \"sPNMappings\");\n\tif (spnmappings == NULL || spnmappings->num_values == 0) {\n\t\tDBG_WARNING(\"no sPNMappings attribute\\n\");\n\t\ttalloc_free(tmp_ctx);\n\t\treturn LDB_ERR_NO_SUCH_OBJECT;\n\t}\n\t*n_aliases = 0;\n\n\tfor (i = 0; i < spnmappings->num_values; i++) {\n\t\tchar *p = NULL;\n\t\tchar *mapping = talloc_strndup(\n\t\t\ttmp_ctx,\n\t\t\t(char *)spnmappings->values[i].data,\n\t\t\tspnmappings->values[i].length);\n\t\tif (mapping == NULL) {\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ldb_oom(ldb);\n\t\t}\n\n\t\tp = strchr(mapping, '=');\n\t\tif (p == NULL) {\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_ERR_ALIAS_PROBLEM;\n\t\t}\n\t\tp[0] = '\\0';\n\t\tp++;\n\n\t\tif (strcasecmp(mapping, service_class) == 0) {\n\t\t\t/*\n\t\t\t * We need to return the reverse aliases for this one.\n\t\t\t *\n\t\t\t * typically, this means the service_class is \"host\"\n\t\t\t * and the mapping is \"host=alerter,appmgmt,cisvc,..\",\n\t\t\t * so we get \"alerter\", \"appmgmt\", etc in the list of\n\t\t\t * aliases.\n\t\t\t */\n\n\t\t\t/* There is one more field than there are commas */\n\t\t\tsize_t n = 1;\n\n\t\t\tfor (j = 0; p[j] != '\\0'; j++) {\n\t\t\t\tif (p[j] == ',') {\n\t\t\t\t\tn++;\n\t\t\t\t\tp[j] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t*aliases = talloc_array(mem_ctx, char*, n);\n\t\t\tif (*aliases == NULL) {\n\t\t\t\ttalloc_free(tmp_ctx);\n\t\t\t\treturn ldb_oom(ldb);\n\t\t\t}\n\t\t\t*n_aliases = n;\n\t\t\ttalloc_steal(mem_ctx, mapping);\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t(*aliases)[j] = p;\n\t\t\t\tp += strlen(p) + 1;\n\t\t\t}\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\t*direction = SPN_ALIAS_LINK;\n\t\t\treturn LDB_SUCCESS;\n\t\t}\n\t\t/*\n\t\t * We need to look along the list to see if service_class is\n\t\t * there; if so, we return a list of one item (probably \"host\").\n\t\t */\n\t\tdo {\n\t\t\tchar *str = p;\n\t\t\tp = strchr(p, ',');\n\t\t\tif (p != NULL) {\n\t\t\t\tp[0] = '\\0';\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (strcasecmp(str, service_class) == 0) {\n\t\t\t\t*aliases = talloc_array(mem_ctx, char*, 1);\n\t\t\t\tif (*aliases == NULL) {\n\t\t\t\t\ttalloc_free(tmp_ctx);\n\t\t\t\t\treturn ldb_oom(ldb);\n\t\t\t\t}\n\t\t\t\t*n_aliases = 1;\n\t\t\t\t(*aliases)[0] = mapping;\n\t\t\t\ttalloc_steal(mem_ctx, mapping);\n\t\t\t\ttalloc_free(tmp_ctx);\n\t\t\t\t*direction = SPN_ALIAS_TARGET;\n\t\t\t\treturn LDB_SUCCESS;\n\t\t\t}\n\t\t} while (p != NULL);\n\t}\n\tDBG_INFO(\"no sPNMappings alias for '%s'\\n\", service_class);\n\ttalloc_free(tmp_ctx);\n\t*aliases = NULL;\n\t*n_aliases = 0;\n\treturn LDB_SUCCESS;\n}\n\n\nstatic int get_spn_dn(struct ldb_context *ldb,\n\t\t      TALLOC_CTX *tmp_ctx,\n\t\t      const char *candidate,\n\t\t      struct ldb_dn **dn)\n{\n\tint ret;\n\tconst char *empty_attrs[] = { NULL };\n\tstruct ldb_message *msg = NULL;\n\tstruct ldb_dn *base_dn = ldb_get_default_basedn(ldb);\n\n\tconst char *enc_candidate = NULL;\n\n\t*dn = NULL;\n\n\tenc_candidate = ldb_binary_encode_string(tmp_ctx, candidate);\n\tif (enc_candidate == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = dsdb_search_one(ldb,\n\t\t\t      tmp_ctx,\n\t\t\t      &msg,\n\t\t\t      base_dn,\n\t\t\t      LDB_SCOPE_SUBTREE,\n\t\t\t      empty_attrs,\n\t\t\t      0,\n\t\t\t      \"(servicePrincipalName=%s)\",\n\t\t\t      enc_candidate);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\t*dn = msg->dn;\n\treturn LDB_SUCCESS;\n}\n\n\nstatic int check_spn_write_rights(struct ldb_context *ldb,\n\t\t\t\t  TALLOC_CTX *mem_ctx,\n\t\t\t\t  const char *spn,\n\t\t\t\t  struct ldb_dn *dn)\n{\n\tint ret;\n\tstruct ldb_message *msg = NULL;\n\tstruct ldb_message_element *del_el = NULL;\n\tstruct ldb_message_element *add_el = NULL;\n\tstruct ldb_val val = {\n\t\t.data = discard_const_p(uint8_t, spn),\n\t\t.length = strlen(spn)\n\t};\n\n\tmsg = ldb_msg_new(mem_ctx);\n\tif (msg == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\tmsg->dn = dn;\n\n\tret = ldb_msg_add_empty(msg,\n\t\t\t\t\"servicePrincipalName\",\n\t\t\t\tLDB_FLAG_MOD_DELETE,\n\t\t\t\t&del_el);\n\tif (ret != LDB_SUCCESS) {\n\t\ttalloc_free(msg);\n\t\treturn ret;\n\t}\n\n\tdel_el->values = talloc_array(msg->elements, struct ldb_val, 1);\n\tif (del_el->values == NULL) {\n\t\ttalloc_free(msg);\n\t\treturn ret;\n\t}\n\n\tdel_el->values[0] = val;\n\tdel_el->num_values = 1;\n\n\tret = ldb_msg_add_empty(msg,\n\t\t\t\t\"servicePrincipalName\",\n\t\t\t\tLDB_FLAG_MOD_ADD,\n\t\t\t\t&add_el);\n\tif (ret != LDB_SUCCESS) {\n\t\ttalloc_free(msg);\n\t\treturn ret;\n\t}\n\n\tadd_el->values = talloc_array(msg->elements, struct ldb_val, 1);\n\tif (add_el->values == NULL) {\n\t\ttalloc_free(msg);\n\t\treturn ret;\n\t}\n\n\tadd_el->values[0] = val;\n\tadd_el->num_values = 1;\n\n\tret = ldb_modify(ldb, msg);\n\tif (ret == LDB_ERR_NO_SUCH_ATTRIBUTE) {\n\t\tDBG_ERR(\"hmm I think we're OK, but not sure\\n\");\n\t} else if (ret != LDB_SUCCESS) {\n\t\tDBG_ERR(\"SPN write rights check failed with %d\\n\", ret);\n\t\ttalloc_free(msg);\n\t\treturn ret;\n\t}\n\ttalloc_free(msg);\n\treturn LDB_SUCCESS;\n}\n\n\nstatic int check_spn_alias_collision(struct ldb_context *ldb,\n\t\t\t\t     TALLOC_CTX *mem_ctx,\n\t\t\t\t     const char *spn,\n\t\t\t\t     struct ldb_dn *target_dn)\n{\n\tint ret;\n\tchar *service_class = NULL;\n\tchar *spn_tail = NULL;\n\tchar *p = NULL;\n\tchar **aliases = NULL;\n\tsize_t n_aliases = 0;\n\tsize_t i, len;\n\tTALLOC_CTX *tmp_ctx = NULL;\n\tconst char *target_dnstr = ldb_dn_get_linearized(target_dn);\n\tint link_direction;\n\n\ttmp_ctx = talloc_new(mem_ctx);\n\tif (tmp_ctx == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\n\t/*\n\t * \"dns/example.com/xxx\"  gives\n\t *    service_class = \"dns\"\n\t *    spn_tail      = \"example.com/xxx\"\n\t */\n\tp = strchr(spn, '/');\n\tif (p == NULL) {\n\t\t/* bad SPN */\n\t\ttalloc_free(tmp_ctx);\n\t\treturn ldb_error(ldb,\n\t\t\t\t LDB_ERR_OPERATIONS_ERROR,\n\t\t\t\t \"malformed servicePrincipalName\");\n\t}\n\tlen = p - spn;\n\n\tservice_class = talloc_strndup(tmp_ctx, spn, len);\n\tif (service_class == NULL) {\n\t\ttalloc_free(tmp_ctx);\n\t\treturn ldb_oom(ldb);\n\t}\n\tspn_tail = p + 1;\n\n\tret = find_spn_aliases(ldb,\n\t\t\t       tmp_ctx,\n\t\t\t       service_class,\n\t\t\t       &aliases,\n\t\t\t       &n_aliases,\n\t\t\t       &link_direction);\n\tif (ret != LDB_SUCCESS) {\n\t\ttalloc_free(tmp_ctx);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * we have the list of aliases, and now we need to combined them with\n\t * spn_tail and see if we can find the SPN.\n\t */\n\tfor (i = 0; i < n_aliases; i++) {\n\t\tstruct ldb_dn *colliding_dn = NULL;\n\t\tconst char *colliding_dnstr = NULL;\n\n\t\tchar *candidate = talloc_asprintf(tmp_ctx,\n\t\t\t\t\t\t  \"%s/%s\",\n\t\t\t\t\t\t  aliases[i],\n\t\t\t\t\t\t  spn_tail);\n\t\tif (candidate == NULL) {\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ldb_oom(ldb);\n\t\t}\n\n\t\tret = get_spn_dn(ldb, tmp_ctx, candidate, &colliding_dn);\n\t\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\t\tDBG_DEBUG(\"SPN alias '%s' not found (good)\\n\",\n\t\t\t\t  candidate);\n\t\t\ttalloc_free(candidate);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\"SPN '%s' search error %d\\n\", candidate, ret);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\n\t\ttarget_dnstr = ldb_dn_get_linearized(target_dn);\n\t\t/*\n\t\t * We have found an existing SPN that matches the alias. That\n\t\t * is OK only if it is on the object we are trying to add to,\n\t\t * or if the SPN on the other side is a more generic alias for\n\t\t * this one and we also have rights to modify it.\n\t\t *\n\t\t * That is, we can put \"host/X\" and \"cifs/X\" on the same\n\t\t * object, but not on different objects, unless we put the\n\t\t * host/X on first, and could also change that object when we\n\t\t * add cifs/X. It is forbidden to add the objects in the other\n\t\t * order.\n\t\t *\n\t\t * The rationale for this is that adding \"cifs/X\" effectively\n\t\t * changes \"host/X\" by diverting traffic. If \"host/X\" can be\n\t\t * added after \"cifs/X\", a sneaky person could get \"cifs/X\" in\n\t\t * first, making \"host/X\" have less effect than intended.\n\t\t *\n\t\t * Note: we also can't have \"host/X\" and \"Host/X\" on the same\n\t\t * object, but that is not relevant here.\n\t\t */\n\n\t\tret = ldb_dn_compare(colliding_dn, target_dn);\n\t\tif (ret != 0) {\n\t\t\tcolliding_dnstr = ldb_dn_get_linearized(colliding_dn);\n\t\t\tDBG_ERR(\"trying to add SPN '%s' on '%s' when '%s' is \"\n\t\t\t\t\"on '%s'\\n\",\n\t\t\t\tspn,\n\t\t\t\ttarget_dnstr,\n\t\t\t\tcandidate,\n\t\t\t\tcolliding_dnstr);\n\n\t\t\tif (link_direction == SPN_ALIAS_LINK) {\n\t\t\t\t/* we don't allow host/X if there is a\n\t\t\t\t * cifs/X */\n\t\t\t\ttalloc_free(tmp_ctx);\n\t\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t\t}\n\t\t\tret = check_spn_write_rights(ldb,\n\t\t\t\t\t\t     tmp_ctx,\n\t\t\t\t\t\t     candidate,\n\t\t\t\t\t\t     colliding_dn);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tDBG_ERR(\"SPN '%s' is on '%s' so '%s' can't be \"\n\t\t\t\t\t\"added to '%s'\\n\",\n\t\t\t\t\tcandidate,\n\t\t\t\t\tcolliding_dnstr,\n\t\t\t\t\tspn,\n\t\t\t\t\ttarget_dnstr);\n\t\t\t\ttalloc_free(tmp_ctx);\n\t\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t\t       \"samldb: spn[%s] would cause a conflict\",\n\t\t\t\t\t\t       spn);\n\t\t\t\treturn LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n\t\t\t}\n\t\t} else {\n\t\t\tDBG_INFO(\"SPNs '%s' and '%s' alias both on '%s'\\n\",\n\t\t\t\t candidate, spn, target_dnstr);\n\t\t}\n\t\ttalloc_free(candidate);\n\t}\n\n\ttalloc_free(tmp_ctx);\n\treturn LDB_SUCCESS;\n}\n\nstatic int check_spn_direct_collision(struct ldb_context *ldb,\n\t\t\t\t      TALLOC_CTX *mem_ctx,\n\t\t\t\t      const char *spn,\n\t\t\t\t      struct ldb_dn *target_dn)\n{\n\tint ret;\n\tTALLOC_CTX *tmp_ctx = NULL;\n\tstruct ldb_dn *colliding_dn = NULL;\n\tconst char *target_dnstr = NULL;\n\tconst char *colliding_dnstr = NULL;\n\n\ttmp_ctx = talloc_new(mem_ctx);\n\tif (tmp_ctx == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\n\tret = get_spn_dn(ldb, tmp_ctx, spn, &colliding_dn);\n\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\tDBG_DEBUG(\"SPN '%s' not found (good)\\n\", spn);\n\t\ttalloc_free(tmp_ctx);\n\t\treturn LDB_SUCCESS;\n\t}\n\tif (ret != LDB_SUCCESS) {\n\t\tDBG_ERR(\"SPN '%s' search error %d\\n\", spn, ret);\n\t\ttalloc_free(tmp_ctx);\n\t\tif (ret == LDB_ERR_COMPARE_TRUE) {\n\t\t\t/*\n\t\t\t * COMPARE_TRUE has special meaning here and we don't\n\t\t\t * want to return it by mistake.\n\t\t\t */\n\t\t\tret = LDB_ERR_OPERATIONS_ERROR;\n\t\t}\n\t\treturn ret;\n\t}\n\t/*\n\t * We have found this exact SPN. This is mostly harmless (depend on\n\t * ADD vs REPLACE) when the spn is being put on the object that\n\t * already has, so we let it through to succeed or fail as some other\n\t * module sees fit.\n\t */\n\ttarget_dnstr = ldb_dn_get_linearized(target_dn);\n\tret = ldb_dn_compare(colliding_dn, target_dn);\n\tif (ret != 0) {\n\t\tcolliding_dnstr = ldb_dn_get_linearized(colliding_dn);\n\t\tDBG_ERR(\"SPN '%s' is on '%s' so it can't be \"\n\t\t\t\"added to '%s'\\n\",\n\t\t\tspn,\n\t\t\tcolliding_dnstr,\n\t\t\ttarget_dnstr);\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"samldb: spn[%s] would cause a conflict\",\n\t\t\t\t       spn);\n\t\ttalloc_free(tmp_ctx);\n\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t}\n\n\tDBG_INFO(\"SPN '%s' is already on '%s'\\n\",\n\t\t spn, target_dnstr);\n\ttalloc_free(tmp_ctx);\n\treturn LDB_ERR_COMPARE_TRUE;\n}\n\n\nstatic int count_spn_components(struct ldb_val val)\n{\n\t/*\n\t * a 3 part servicePrincipalName has two slashes, like\n\t * ldap/example.com/DomainDNSZones.example.com.\n\t *\n\t * In krb5_parse_name_flags() we don't count \"\\/\" as a slash (i.e.\n\t * escaped by a backslash), but this is not the behaviour of Windows\n\t * on setting a servicePrincipalName -- slashes are counted regardless\n\t * of backslashes.\n\t *\n\t * Accordingly, here we ignore backslashes. This will reject\n\t * multi-slash SPNs that krb5_parse_name_flags() would accept, and\n\t * allow ones in the form \"a\\/b\" that it won't parse.\n\t */\n\tsize_t i;\n\tint slashes = 0;\n\tfor (i = 0; i < val.length; i++) {\n\t\tchar c = val.data[i];\n\t\tif (c == '/') {\n\t\t\tslashes++;\n\t\t\tif (slashes == 3) {\n\t\t\t\t/* at this point we don't care */\n\t\t\t\treturn 4;\n\t\t\t}\n\t\t}\n\t}\n\treturn slashes + 1;\n}\n\n\n/* Check that \"servicePrincipalName\" changes do not introduce a collision\n * globally. */\nstatic int samldb_spn_uniqueness_check(struct samldb_ctx *ac,\n\t\t\t\t       struct ldb_message_element *spn_el)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\tconst char *spn = NULL;\n\tsize_t i;\n\tTALLOC_CTX *tmp_ctx = talloc_new(ac->msg);\n\tif (tmp_ctx == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\n\tfor (i = 0; i < spn_el->num_values; i++) {\n\t\tint n_components;\n\t\tspn = (char *)spn_el->values[i].data;\n\n\t\tn_components = count_spn_components(spn_el->values[i]);\n\t\tif (n_components > 3 || n_components < 2) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"samldb: spn[%s] invalid with %u components\",\n\t\t\t\t\t       spn, n_components);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\n\t\tret = check_spn_direct_collision(ldb,\n\t\t\t\t\t\t tmp_ctx,\n\t\t\t\t\t\t spn,\n\t\t\t\t\t\t ac->msg->dn);\n\t\tif (ret == LDB_ERR_COMPARE_TRUE) {\n\t\t\tDBG_INFO(\"SPN %s re-added to the same object\\n\", spn);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\"SPN %s failed direct uniqueness check\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = check_spn_alias_collision(ldb,\n\t\t\t\t\t\ttmp_ctx,\n\t\t\t\t\t\tspn,\n\t\t\t\t\t\tac->msg->dn);\n\n\t\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\t\t/* we have no sPNMappings, hence no aliases */\n\t\t\tbreak;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\"SPN %s failed alias uniqueness check\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t\tDBG_INFO(\"SPN %s seems to be unique\\n\", spn);\n\t}\n\n\ttalloc_free(tmp_ctx);\n\treturn LDB_SUCCESS;\n}\n\n\n\n/* This trigger adapts the \"servicePrincipalName\" attributes if the\n * \"dNSHostName\" and/or \"sAMAccountName\" attribute change(s) */\nstatic int samldb_service_principal_names_change(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tstruct ldb_message_element *el = NULL, *el2 = NULL;\n\tstruct ldb_message *msg;\n\tconst char * const attrs[] = { \"servicePrincipalName\", NULL };\n\tstruct ldb_result *res;\n\tconst char *dns_hostname = NULL, *old_dns_hostname = NULL,\n\t\t   *sam_accountname = NULL, *old_sam_accountname = NULL;\n\tunsigned int i, j;\n\tint ret;\n\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"dNSHostName\",\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"sAMAccountName\",\n\t\t\t\t\t   &el2,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif ((el == NULL) && (el2 == NULL)) {\n\t\t/* we are not affected */\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/* Create a temporary message for fetching the \"dNSHostName\" */\n\tif (el != NULL) {\n\t\tconst char *dns_attrs[] = { \"dNSHostName\", NULL };\n\t\tmsg = ldb_msg_new(ac->msg);\n\t\tif (msg == NULL) {\n\t\t\treturn ldb_module_oom(ac->module);\n\t\t}\n\t\tret = ldb_msg_add(msg, el, 0);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t\tdns_hostname = talloc_strdup(ac,\n\t\t\t\t\t     ldb_msg_find_attr_as_string(msg, \"dNSHostName\", NULL));\n\t\tif (dns_hostname == NULL) {\n\t\t\treturn ldb_module_oom(ac->module);\n\t\t}\n\n\t\ttalloc_free(msg);\n\n\t\tret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn,\n\t\t\t\t\t    dns_attrs, DSDB_FLAG_NEXT_MODULE, ac->req);\n\t\tif (ret == LDB_SUCCESS) {\n\t\t\told_dns_hostname = ldb_msg_find_attr_as_string(res->msgs[0], \"dNSHostName\", NULL);\n\t\t}\n\t}\n\n\t/* Create a temporary message for fetching the \"sAMAccountName\" */\n\tif (el2 != NULL) {\n\t\tchar *tempstr, *tempstr2 = NULL;\n\t\tconst char *acct_attrs[] = { \"sAMAccountName\", NULL };\n\n\t\tmsg = ldb_msg_new(ac->msg);\n\t\tif (msg == NULL) {\n\t\t\treturn ldb_module_oom(ac->module);\n\t\t}\n\t\tret = ldb_msg_add(msg, el2, 0);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t\ttempstr = talloc_strdup(ac,\n\t\t\t\t\tldb_msg_find_attr_as_string(msg, \"sAMAccountName\", NULL));\n\t\ttalloc_free(msg);\n\n\t\tret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn, acct_attrs,\n\t\t\t\t\t    DSDB_FLAG_NEXT_MODULE, ac->req);\n\t\tif (ret == LDB_SUCCESS) {\n\t\t\ttempstr2 = talloc_strdup(ac,\n\t\t\t\t\t\t ldb_msg_find_attr_as_string(res->msgs[0],\n\t\t\t\t\t\t\t\t\t     \"sAMAccountName\", NULL));\n\t\t}\n\n\n\t\t/* The \"sAMAccountName\" needs some additional trimming: we need\n\t\t * to remove the trailing \"$\"s if they exist. */\n\t\tif ((tempstr != NULL) && (tempstr[0] != '\\0') &&\n\t\t    (tempstr[strlen(tempstr) - 1] == '$')) {\n\t\t\ttempstr[strlen(tempstr) - 1] = '\\0';\n\t\t}\n\t\tif ((tempstr2 != NULL) && (tempstr2[0] != '\\0') &&\n\t\t    (tempstr2[strlen(tempstr2) - 1] == '$')) {\n\t\t\ttempstr2[strlen(tempstr2) - 1] = '\\0';\n\t\t}\n\t\tsam_accountname = tempstr;\n\t\told_sam_accountname = tempstr2;\n\t}\n\n\tif (old_dns_hostname == NULL) {\n\t\t/* we cannot change when the old name is unknown */\n\t\tdns_hostname = NULL;\n\t}\n\tif ((old_dns_hostname != NULL) && (dns_hostname != NULL) &&\n\t    (strcasecmp_m(old_dns_hostname, dns_hostname) == 0)) {\n\t\t/* The \"dNSHostName\" didn't change */\n\t\tdns_hostname = NULL;\n\t}\n\n\tif (old_sam_accountname == NULL) {\n\t\t/* we cannot change when the old name is unknown */\n\t\tsam_accountname = NULL;\n\t}\n\tif ((old_sam_accountname != NULL) && (sam_accountname != NULL) &&\n\t    (strcasecmp_m(old_sam_accountname, sam_accountname) == 0)) {\n\t\t/* The \"sAMAccountName\" didn't change */\n\t\tsam_accountname = NULL;\n\t}\n\n\tif ((dns_hostname == NULL) && (sam_accountname == NULL)) {\n\t\t/* Well, there are information missing (old name(s)) or the\n\t\t * names didn't change. We've nothing to do and can exit here */\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t/*\n\t * Potential \"servicePrincipalName\" changes in the same request have\n\t * to be handled before the update (Windows behaviour).\n\t *\n\t * We extract the SPN changes into a new message and run it through\n\t * the stack from this module, so that it subjects them to the SPN\n\t * checks we have here.\n\t */\n\tel = ldb_msg_find_element(ac->msg, \"servicePrincipalName\");\n\tif (el != NULL) {\n\t\tmsg = ldb_msg_new(ac->msg);\n\t\tif (msg == NULL) {\n\t\t\treturn ldb_module_oom(ac->module);\n\t\t}\n\t\tmsg->dn = ac->msg->dn;\n\n\t\tdo {\n\t\t\tret = ldb_msg_add(msg, el, el->flags);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tldb_msg_remove_element(ac->msg, el);\n\n\t\t\tel = ldb_msg_find_element(ac->msg,\n\t\t\t\t\t\t  \"servicePrincipalName\");\n\t\t} while (el != NULL);\n\n\t\tret = dsdb_module_modify(ac->module, msg,\n\t\t\t\t\t DSDB_FLAG_OWN_MODULE, ac->req);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t\ttalloc_free(msg);\n\t}\n\n\t/* Fetch the \"servicePrincipalName\"s if any */\n\tret = dsdb_module_search(ac->module, ac, &res, ac->msg->dn, LDB_SCOPE_BASE, attrs,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE, ac->req, NULL);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif ((res->count != 1) || (res->msgs[0]->num_elements > 1)) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tif (res->msgs[0]->num_elements == 1) {\n\t\t/*\n\t\t * Yes, we do have \"servicePrincipalName\"s. First we update them\n\t\t * locally, that means we do always substitute the current\n\t\t * \"dNSHostName\" with the new one and/or \"sAMAccountName\"\n\t\t * without \"$\" with the new one and then we append the\n\t\t * modified \"servicePrincipalName\"s as a message element\n\t\t * replace to the modification request (Windows behaviour). We\n\t\t * need also to make sure that the values remain case-\n\t\t * insensitively unique.\n\t\t */\n\n\t\tret = ldb_msg_add_empty(ac->msg, \"servicePrincipalName\",\n\t\t\t\t\tLDB_FLAG_MOD_REPLACE, &el);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (i = 0; i < res->msgs[0]->elements[0].num_values; i++) {\n\t\t\tchar *old_str, *new_str;\n\t\t\tchar *pos = NULL;\n\t\t\tconst char *tok;\n\t\t\tstruct ldb_val *vals;\n\t\t\tbool found = false;\n\n\t\t\told_str = (char *)\n\t\t\t\tres->msgs[0]->elements[0].values[i].data;\n\n\t\t\tnew_str = talloc_strdup(ac->msg,\n\t\t\t\t\t\tstrtok_r(old_str, \"/\", &pos));\n\t\t\tif (new_str == NULL) {\n\t\t\t\treturn ldb_module_oom(ac->module);\n\t\t\t}\n\n\t\t\twhile ((tok = strtok_r(NULL, \"/\", &pos)) != NULL) {\n\t\t\t\tif ((dns_hostname != NULL) &&\n\t\t\t\t    (strcasecmp_m(tok, old_dns_hostname) == 0)) {\n\t\t\t\t\ttok = dns_hostname;\n\t\t\t\t}\n\t\t\t\tif ((sam_accountname != NULL) &&\n\t\t\t\t    (strcasecmp_m(tok, old_sam_accountname) == 0)) {\n\t\t\t\t\ttok = sam_accountname;\n\t\t\t\t}\n\n\t\t\t\tnew_str = talloc_asprintf(ac->msg, \"%s/%s\",\n\t\t\t\t\t\t\t  new_str, tok);\n\t\t\t\tif (new_str == NULL) {\n\t\t\t\t\treturn ldb_module_oom(ac->module);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Uniqueness check */\n\t\t\tfor (j = 0; (!found) && (j < el->num_values); j++) {\n\t\t\t\tif (strcasecmp_m((char *)el->values[j].data,\n\t\t\t\t\t       new_str) == 0) {\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * append the new \"servicePrincipalName\" -\n\t\t\t * code derived from ldb_msg_add_value().\n\t\t\t *\n\t\t\t * Open coded to make it clear that we must\n\t\t\t * append to the MOD_REPLACE el created above.\n\t\t\t */\n\t\t\tvals = talloc_realloc(ac->msg, el->values,\n\t\t\t\t\t      struct ldb_val,\n\t\t\t\t\t      el->num_values + 1);\n\t\t\tif (vals == NULL) {\n\t\t\t\treturn ldb_module_oom(ac->module);\n\t\t\t}\n\t\t\tel->values = vals;\n\t\t\tel->values[el->num_values] = data_blob_string_const(new_str);\n\t\t\t++(el->num_values);\n\t\t}\n\t}\n\n\ttalloc_free(res);\n\n\treturn LDB_SUCCESS;\n}\n\n/* This checks the \"fSMORoleOwner\" attributes */\nstatic int samldb_fsmo_role_owner_check(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tconst char * const no_attrs[] = { NULL };\n\tstruct ldb_message_element *el;\n\tstruct ldb_message *tmp_msg;\n\tstruct ldb_dn *res_dn;\n\tstruct ldb_result *res;\n\tint ret;\n\tret = dsdb_get_expected_new_values(ac,\n\t\t\t\t\t   ac->msg,\n\t\t\t\t\t   \"fSMORoleOwner\",\n\t\t\t\t\t   &el,\n\t\t\t\t\t   ac->req->operation);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (el == NULL) {\n\t\t/* we are not affected */\n\t\treturn LDB_SUCCESS;\n\t}\n\tif (el->num_values != 1) {\n\t\tgoto choose_error_code;\n\t}\n\n\t/* Create a temporary message for fetching the \"fSMORoleOwner\" */\n\ttmp_msg = ldb_msg_new(ac->msg);\n\tif (tmp_msg == NULL) {\n\t\treturn ldb_module_oom(ac->module);\n\t}\n\tret = ldb_msg_add(tmp_msg, el, 0);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tres_dn = ldb_msg_find_attr_as_dn(ldb, ac, tmp_msg, \"fSMORoleOwner\");\n\ttalloc_free(tmp_msg);\n\n\tif (res_dn == NULL) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb: 'fSMORoleOwner' attributes have to reference 'nTDSDSA' entries!\");\n\t\tgoto choose_error_code;\n\t}\n\n\t/* Fetched DN has to reference a \"nTDSDSA\" entry */\n\tret = dsdb_module_search(ac->module, ac, &res, res_dn, LDB_SCOPE_BASE,\n\t\t\t\t no_attrs,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED,\n\t\t\t\t ac->req, \"(objectClass=nTDSDSA)\");\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (res->count != 1) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb: 'fSMORoleOwner' attributes have to reference 'nTDSDSA' entries!\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\ttalloc_free(res);\n\n\treturn LDB_SUCCESS;\n\nchoose_error_code:\n\t/* this is just how it is */\n\tif (ac->req->operation == LDB_ADD) {\n\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t} else {\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n}\n\n/*\n * Return zero if the number of zero bits in the address (looking from low to\n * high) is equal to or greater than the length minus the mask. Otherwise it\n * returns -1.\n */\nstatic int check_cidr_zero_bits(uint8_t *address, unsigned int len,\n\t\t\t\tunsigned int mask)\n{\n\t/* <address> is an integer in big-endian form, <len> bits long. All\n\t   bits between <mask> and <len> must be zero. */\n\tint i;\n\tunsigned int byte_len;\n\tunsigned int byte_mask;\n\tunsigned int bit_mask;\n\tif (len == 32) {\n\t\tDBG_INFO(\"Looking at address %02x%02x%02x%02x, mask %u\\n\",\n\t\t\t address[0], address[1], address[2], address[3],\n\t\t\t  mask);\n\t} else if (len == 128){\n\t\tDBG_INFO(\"Looking at address \"\n\t\t\t \"%02x%02x-%02x%02x-%02x%02x-%02x%02x-\"\n\t\t\t \"%02x%02x-%02x%02x-%02x%02x-%02x%02x, mask %u\\n\",\n\t\t\t address[0], address[1], address[2], address[3],\n\t\t\t address[4], address[5], address[6], address[7],\n\t\t\t address[8], address[9], address[10], address[11],\n\t\t\t address[12], address[13], address[14], address[15],\n\t\t\t mask);\n\t}\n\n\tif (mask > len){\n\t\tDBG_INFO(\"mask %u is too big (> %u)\\n\", mask, len);\n\t\treturn -1;\n\t}\n\tif (mask == len){\n\t\t/* single address subnet.\n\t\t * In IPv4 all 255s is invalid by the bitmask != address rule\n\t\t * in MS-ADTS. IPv6 does not suffer.\n\t\t */\n\t\tif (len == 32){\n\t\t\tif (address[0] == 255 &&\n\t\t\t    address[1] == 255 &&\n\t\t\t    address[2] == 255 &&\n\t\t\t    address[3] == 255){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tbyte_len = len / 8;\n\tbyte_mask = mask / 8;\n\n\tfor (i = byte_len - 1; i > byte_mask; i--){\n\t\tDBG_DEBUG(\"checking byte %d %02x\\n\", i, address[i]);\n\t\tif (address[i] != 0){\n\t\t\treturn -1;\n\t\t}\n\t}\n\tbit_mask = (1 << (8 - (mask & 7))) - 1;\n\tDBG_DEBUG(\"checking bitmask %02x & %02x overlap %02x\\n\", bit_mask, address[byte_mask],\n\t\t  bit_mask & address[byte_mask]);\n\tif (address[byte_mask] & bit_mask){\n\t\treturn -1;\n\t}\n\n\t/* According to MS-ADTS, the mask can't exactly equal the bitmask for\n\t * IPv4 (but this is fine for v6). That is 255.255.80.0/17 is bad,\n\t * because the bitmask implied by \"/17\" is 255.255.80.0.\n\t *\n\t * The bit_mask used in the previous check is the complement of what\n\t * we want here.\n\t */\n\tif (len == 32 && address[byte_mask] == (uint8_t)~bit_mask){\n\t\tbool ok = false;\n\t\tfor (i = 0; i < byte_mask; i++){\n\t\t\tif (address[i] != 255){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ok == false){\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\nstatic int check_address_roundtrip(const char *address, int family,\n\t\t\t\t   const uint8_t *address_bytes,\n\t\t\t\t   char *buffer, int buffer_len)\n{\n\t/*\n\t * Check that the address is in the canonical RFC5952 format for IPv6,\n\t * and lacks extra leading zeros for each dotted decimal for IPv4.\n\t * Handily this is what inet_ntop() gives you.\n\t */\n\tconst char *address_redux = inet_ntop(family, address_bytes,\n\t\t\t\t\t      buffer, buffer_len);\n\tif (address_redux == NULL){\n\t\tDBG_INFO(\"Address round trip %s failed unexpectedly\"\n\t\t\t \" with errno %d\\n\", address, errno);\n\t\treturn -1;\n\t}\n\tif (strcasecmp(address, address_redux) != 0){\n\t\tDBG_INFO(\"Address %s round trips to %s; fail!\\n\",\n\t\t\t address, address_redux);\n\t\t/* If the address family is IPv6, and the address is in a\n\t\t   certain range\n\n\t\t */\n\t\tif (strchr(address_redux, '.') != NULL){\n\t\t\tDEBUG(0, (\"The IPv6 address '%s' has the misfortune of \"\n\t\t\t\t  \"lying in a range that was once used for \"\n\t\t\t\t  \"IPv4 embedding (that is, it might also be \"\n\t\t\t\t  \"represented as '%s').\\n\", address,\n\t\t\t\t  address_redux));\n\t\t}\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n\n\n/*\n * MS-ADTS v20150630 6.1.1.2.2.2.1 Subnet Object, refers to RFC1166 and\n * RFC2373. It specifies something seemingly indistinguishable from an RFC4632\n * CIDR address range without saying so explicitly. Here we follow the CIDR\n * spec.\n *\n * Return 0 on success, -1 on error.\n */\nstatic int verify_cidr(const char *cidr)\n{\n\tchar *address = NULL, *slash = NULL;\n\tbool has_colon, has_dot;\n\tint res, ret;\n\tunsigned long mask;\n\tuint8_t *address_bytes = NULL;\n\tchar *address_redux = NULL;\n\tunsigned int address_len;\n\tTALLOC_CTX *frame = NULL;\n\tint error = 0;\n\n\tDBG_DEBUG(\"CIDR is %s\\n\", cidr);\n\tframe = talloc_stackframe();\n\taddress = talloc_strdup(frame, cidr);\n\tif (address == NULL){\n\t\tgoto error;\n\t}\n\n\t/* there must be a '/' */\n\tslash = strchr(address, '/');\n\tif (slash == NULL){\n\t\tgoto error;\n\t}\n\t/* terminate the address for strchr, inet_pton */\n\t*slash = '\\0';\n\n\tmask = smb_strtoul(slash + 1, NULL, 10, &error, SMB_STR_FULL_STR_CONV);\n\tif (mask == 0){\n\t\tDBG_INFO(\"Windows does not like the zero mask, \"\n\t\t\t \"so nor do we: %s\\n\", cidr);\n\t\tgoto error;\n\t}\n\n\tif (error != 0){\n\t\tDBG_INFO(\"CIDR mask is not a proper integer: %s\\n\", cidr);\n\t\tgoto error;\n\t}\n\n\taddress_bytes = talloc_size(frame, sizeof(struct in6_addr));\n\tif (address_bytes == NULL){\n\t\tgoto error;\n\t}\n\n\taddress_redux = talloc_size(frame, INET6_ADDRSTRLEN);\n\tif (address_redux == NULL){\n\t\tgoto error;\n\t}\n\n\tDBG_INFO(\"found address %s, mask %lu\\n\", address, mask);\n\thas_colon = (strchr(address, ':') == NULL) ? false : true;\n\thas_dot = (strchr(address, '.') == NULL) ? false : true;\n\tif (has_dot && has_colon){\n\t\t/* This seems to be an IPv4 address embedded in IPv6, which is\n\t\t   icky. We don't support it. */\n\t\tDBG_INFO(\"Refusing to consider cidr '%s' with dots and colons\\n\",\n\t\t\t  cidr);\n\t\tgoto error;\n\t} else if (has_colon){\t/* looks like IPv6 */\n\t\tres = inet_pton(AF_INET6, address, address_bytes);\n\t\tif (res != 1) {\n\t\t\tDBG_INFO(\"Address in %s fails to parse as IPv6\\n\", cidr);\n\t\t\tgoto error;\n\t\t}\n\t\taddress_len = 128;\n\t\tif (check_address_roundtrip(address, AF_INET6, address_bytes,\n\t\t\t\t\t    address_redux, INET6_ADDRSTRLEN)){\n\t\t\tgoto error;\n\t\t}\n\t} else if (has_dot) {\n\t\t/* looks like IPv4 */\n\t\tif (strcmp(address, \"0.0.0.0\") == 0){\n\t\t\tDBG_INFO(\"Windows does not like the zero IPv4 address, \"\n\t\t\t\t \"so nor do we.\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tres = inet_pton(AF_INET, address, address_bytes);\n\t\tif (res != 1) {\n\t\t\tDBG_INFO(\"Address in %s fails to parse as IPv4\\n\", cidr);\n\t\t\tgoto error;\n\t\t}\n\t\taddress_len = 32;\n\n\t\tif (check_address_roundtrip(address, AF_INET, address_bytes,\n\t\t\t\t\t    address_redux, INET_ADDRSTRLEN)){\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\t/* This doesn't look like an IP address at all. */\n\t\tgoto error;\n\t}\n\n\tret = check_cidr_zero_bits(address_bytes, address_len, mask);\n\ttalloc_free(frame);\n\treturn ret;\n  error:\n\ttalloc_free(frame);\n\treturn -1;\n}\n\n\nstatic int samldb_verify_subnet(struct samldb_ctx *ac, struct ldb_dn *dn)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tconst char *cidr = NULL;\n\tconst struct ldb_val *rdn_value = NULL;\n\n\trdn_value = ldb_dn_get_rdn_val(dn);\n\tif (rdn_value == NULL) {\n\t\tldb_set_errstring(ldb, \"samldb: ldb_dn_get_rdn_val \"\n\t\t\t\t  \"failed\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\tcidr = ldb_dn_escape_value(ac, *rdn_value);\n\tDBG_INFO(\"looking at cidr '%s'\\n\", cidr);\n\tif (cidr == NULL) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb: adding an empty subnet cidr seems wrong\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\tif (verify_cidr(cidr)){\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb: subnet value is invalid\");\n\t\treturn LDB_ERR_INVALID_DN_SYNTAX;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n\nstatic char *refer_if_rodc(struct ldb_context *ldb, struct ldb_request *req,\n\t\t\t   struct ldb_dn *dn)\n{\n\tbool rodc = false;\n\tstruct loadparm_context *lp_ctx;\n\tchar *referral;\n\tint ret;\n\tWERROR err;\n\n\tif (ldb_request_get_control(req, DSDB_CONTROL_REPLICATED_UPDATE_OID) ||\n\t    ldb_request_get_control(req, DSDB_CONTROL_DBCHECK_MODIFY_RO_REPLICA)) {\n\t\treturn NULL;\n\t}\n\n\tret = samdb_rodc(ldb, &rodc);\n\tif (ret != LDB_SUCCESS) {\n\t\tDEBUG(4, (__location__ \": unable to tell if we are an RODC\\n\"));\n\t\treturn NULL;\n\t}\n\n\tif (rodc) {\n\t\tconst char *domain = NULL;\n\t\tstruct ldb_dn *fsmo_role_dn;\n\t\tstruct ldb_dn *role_owner_dn;\n\t\tldb_set_errstring(ldb, \"RODC modify is forbidden!\");\n\t\tlp_ctx = talloc_get_type(ldb_get_opaque(ldb, \"loadparm\"),\n\t\t\t\t\t struct loadparm_context);\n\n\t\terr = dsdb_get_fsmo_role_info(req, ldb, DREPL_PDC_MASTER,\n\t\t\t\t\t      &fsmo_role_dn, &role_owner_dn);\n\t\tif (W_ERROR_IS_OK(err)) {\n\t\t\tstruct ldb_dn *server_dn = ldb_dn_copy(req, role_owner_dn);\n\t\t\tif (server_dn != NULL) {\n\t\t\t\tldb_dn_remove_child_components(server_dn, 1);\n\n\t\t\t\tdomain = samdb_dn_to_dnshostname(ldb, req,\n\t\t\t\t\t\t\t\t server_dn);\n\t\t\t}\n\t\t}\n\t\tif (domain == NULL) {\n\t\t\tdomain = lpcfg_dnsdomain(lp_ctx);\n\t\t}\n\t\treferral = talloc_asprintf(req,\n\t\t\t\t\t   \"ldap://%s/%s\",\n\t\t\t\t\t   domain,\n\t\t\t\t\t   ldb_dn_get_linearized(dn));\n\t\treturn referral;\n\t}\n\n\treturn NULL;\n}\n\n/*\n * Restrict all access to sensitive attributes.\n *\n * We don't want to even inspect the values, so we can use the same\n * routine for ADD and MODIFY.\n *\n */\n\nstatic int samldb_check_sensitive_attributes(struct samldb_ctx *ac)\n{\n\tstruct ldb_message_element *el = NULL;\n\tstruct security_token *user_token = NULL;\n\tint ret;\n\n\tif (dsdb_module_am_system(ac->module)) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tuser_token = acl_user_token(ac->module);\n\tif (user_token == NULL) {\n\t\treturn LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"sidHistory\");\n\tif (el) {\n               /*\n                * sidHistory is restricted to the (not implemented\n                * yet in Samba) DsAddSidHistory call (direct LDB access is\n                * as SYSTEM so will bypass this).\n\t\t*\n\t\t* If you want to modify this, say to merge domains,\n\t\t* directly modify the sam.ldb as root.\n                */\n\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t       \"sidHistory \"\n\t\t\t\t       \"(entry %s) cannot be created \"\n\t\t\t\t       \"or changed over LDAP!\",\n\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn));\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"msDS-SecondaryKrbTgtNumber\");\n\tif (el) {\n\t\tstruct security_descriptor *domain_sd;\n\t\tconst struct dsdb_class *objectclass = NULL;\n\t\t/*\n\t\t * msDS-SecondaryKrbTgtNumber allows the creator to\n\t\t * become an RODC, this is trusted as an RODC\n\t\t * account\n\t\t */\n\t\tret = samldb_get_domain_secdesc_and_oc(ac, &domain_sd, &objectclass);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t\tret = acl_check_extended_right(ac,\n\t\t\t\t\t       ac->module,\n\t\t\t\t\t       ac->req,\n\t\t\t\t\t       objectclass,\n\t\t\t\t\t       domain_sd,\n\t\t\t\t\t       user_token,\n\t\t\t\t\t       GUID_DRS_DS_INSTALL_REPLICA,\n\t\t\t\t\t       SEC_ADS_CONTROL_ACCESS,\n\t\t\t\t\t       NULL);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t\t       \"msDS-SecondaryKrbTgtNumber \"\n\t\t\t\t\t       \"(entry %s) cannot be created \"\n\t\t\t\t\t       \"or changed without \"\n\t\t\t\t\t       \"DS-Install-Replica extended right!\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"msDS-AllowedToDelegateTo\");\n\tif (el) {\n\t\t/*\n\t\t * msDS-AllowedToDelegateTo is incredibly powerful,\n\t\t * given that it allows a server to become ANY USER on\n\t\t * the target server only listed by SPN so needs to be\n\t\t * protected just as the userAccountControl\n\t\t * UF_TRUSTED_FOR_DELEGATION is.\n\t\t */\n\n\t\tbool have_priv = security_token_has_privilege(user_token,\n\t\t\t\t\t\t\t      SEC_PRIV_ENABLE_DELEGATION);\n\t\tif (have_priv == false) {\n\t\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t\t       \"msDS-AllowedToDelegateTo \"\n\t\t\t\t\t       \"(entry %s) cannot be created \"\n\t\t\t\t\t       \"or changed without SePrivEnableDelegation!\",\n\t\t\t\t\t       ldb_dn_get_linearized(ac->msg->dn));\n\t\t\treturn LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n\t\t}\n\t}\n\treturn LDB_SUCCESS;\n}\n/* add */\nstatic int samldb_add(struct ldb_module *module, struct ldb_request *req)\n{\n\tstruct ldb_context *ldb;\n\tstruct samldb_ctx *ac;\n\tstruct ldb_message_element *el;\n\tint ret;\n\tchar *referral = NULL;\n\n\tldb = ldb_module_get_ctx(module);\n\tldb_debug(ldb, LDB_DEBUG_TRACE, \"samldb_add\\n\");\n\n\t/* do not manipulate our control entries */\n\tif (ldb_dn_is_special(req->op.add.message->dn)) {\n\t\treturn ldb_next_request(module, req);\n\t}\n\n\treferral = refer_if_rodc(ldb, req, req->op.add.message->dn);\n\tif (referral != NULL) {\n\t\tret = ldb_module_send_referral(req, referral);\n\t\treturn ret;\n\t}\n\n\tel = ldb_msg_find_element(req->op.add.message, \"userParameters\");\n\tif (el != NULL && ldb_req_is_untrusted(req)) {\n\t\tconst char *reason = \"samldb_add: \"\n\t\t\t\"setting userParameters is not supported over LDAP, \"\n\t\t\t\"see https://bugzilla.samba.org/show_bug.cgi?id=8077\";\n\t\tldb_debug(ldb, LDB_DEBUG_WARNING, \"%s\", reason);\n\t\treturn ldb_error(ldb, LDB_ERR_CONSTRAINT_VIOLATION, reason);\n\t}\n\n\tac = samldb_ctx_init(module, req);\n\tif (ac == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\t/* build the new msg */\n\tac->msg = ldb_msg_copy_shallow(ac, req->op.add.message);\n\tif (ac->msg == NULL) {\n\t\ttalloc_free(ac);\n\t\tldb_debug(ldb, LDB_DEBUG_FATAL,\n\t\t\t  \"samldb_add: ldb_msg_copy_shallow failed!\\n\");\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = samldb_check_sensitive_attributes(ac);\n\tif (ret != LDB_SUCCESS) {\n\t\ttalloc_free(ac);\n\t\treturn ret;\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"fSMORoleOwner\");\n\tif (el != NULL) {\n\t\tret = samldb_fsmo_role_owner_check(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"servicePrincipalName\");\n\tif ((el != NULL)) {\n\t\t/*\n\t\t * We need to check whether the SPN collides with an existing\n\t\t * one (anywhere) including via aliases.\n\t\t */\n\t\tret = samldb_spn_uniqueness_check(ac, el);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (samdb_find_attribute(ldb, ac->msg,\n\t\t\t\t \"objectclass\", \"user\") != NULL) {\n\t\tac->type = SAMLDB_TYPE_USER;\n\n\t\tret = samldb_prim_group_trigger(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = samldb_objectclass_trigger(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn samldb_fill_object(ac);\n\t}\n\n\tif (samdb_find_attribute(ldb, ac->msg,\n\t\t\t\t \"objectclass\", \"group\") != NULL) {\n\t\tac->type = SAMLDB_TYPE_GROUP;\n\n\t\tret = samldb_objectclass_trigger(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn samldb_fill_object(ac);\n\t}\n\n\t/* perhaps a foreignSecurityPrincipal? */\n\tif (samdb_find_attribute(ldb, ac->msg,\n\t\t\t\t \"objectclass\",\n\t\t\t\t \"foreignSecurityPrincipal\") != NULL) {\n\t\treturn samldb_fill_foreignSecurityPrincipal_object(ac);\n\t}\n\n\tif (samdb_find_attribute(ldb, ac->msg,\n\t\t\t\t \"objectclass\", \"classSchema\") != NULL) {\n\t\tac->type = SAMLDB_TYPE_CLASS;\n\n\t\t/* If in provision, these checks are too slow to do */\n\t\tif (!ldb_request_get_control(req, DSDB_CONTROL_SKIP_DUPLICATES_CHECK_OID)) {\n\t\t\tret = samldb_schema_governsid_valid_check(ac);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = samldb_schema_ldapdisplayname_valid_check(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = samldb_schema_info_update(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\ttalloc_free(ac);\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn samldb_fill_object(ac);\n\t}\n\n\tif (samdb_find_attribute(ldb, ac->msg,\n\t\t\t\t \"objectclass\", \"attributeSchema\") != NULL) {\n\t\tac->type = SAMLDB_TYPE_ATTRIBUTE;\n\n\t\t/* If in provision, these checks are too slow to do */\n\t\tif (!ldb_request_get_control(req, DSDB_CONTROL_SKIP_DUPLICATES_CHECK_OID)) {\n\t\t\tret = samldb_schema_attributeid_valid_check(ac);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = samldb_schema_add_handle_linkid(ac);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = samldb_schema_add_handle_mapiid(ac);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = samldb_schema_ldapdisplayname_valid_check(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = samldb_schema_info_update(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\ttalloc_free(ac);\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn samldb_fill_object(ac);\n\t}\n\n\tif (samdb_find_attribute(ldb, ac->msg,\n\t\t\t\t \"objectclass\", \"subnet\") != NULL) {\n\t\tret = samldb_verify_subnet(ac, ac->msg->dn);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\ttalloc_free(ac);\n\t\t\treturn ret;\n\t\t}\n\t\t/* We are just checking the value is valid, and there are no\n\t\t   values to fill in. */\n\t}\n\n\ttalloc_free(ac);\n\n\t/* nothing matched, go on */\n\treturn ldb_next_request(module, req);\n}\n\n/* modify */\nstatic int samldb_modify(struct ldb_module *module, struct ldb_request *req)\n{\n\tstruct ldb_context *ldb;\n\tstruct samldb_ctx *ac;\n\tstruct ldb_message_element *el, *el2;\n\tstruct ldb_control *is_undelete;\n\tbool modified = false;\n\tint ret;\n\n\tif (ldb_dn_is_special(req->op.mod.message->dn)) {\n\t\t/* do not manipulate our control entries */\n\t\treturn ldb_next_request(module, req);\n\t}\n\n\tldb = ldb_module_get_ctx(module);\n\n\t/*\n\t * we are going to need some special handling if in Undelete call.\n\t * Since tombstone_reanimate module will restore certain attributes,\n\t * we need to relax checks for: sAMAccountType, primaryGroupID\n\t */\n\tis_undelete = ldb_request_get_control(req, DSDB_CONTROL_RESTORE_TOMBSTONE_OID);\n\n\t/* make sure that \"objectSid\" is not specified */\n\tel = ldb_msg_find_element(req->op.mod.message, \"objectSid\");\n\tif (el != NULL) {\n\t\tif (ldb_request_get_control(req, LDB_CONTROL_PROVISION_OID) == NULL) {\n\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t  \"samldb: objectSid must not be specified!\");\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\t}\n\tif (is_undelete == NULL) {\n\t\t/* make sure that \"sAMAccountType\" is not specified */\n\t\tel = ldb_msg_find_element(req->op.mod.message, \"sAMAccountType\");\n\t\tif (el != NULL) {\n\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t  \"samldb: sAMAccountType must not be specified!\");\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\t}\n\t/* make sure that \"isCriticalSystemObject\" is not specified */\n\tel = ldb_msg_find_element(req->op.mod.message, \"isCriticalSystemObject\");\n\tif (el != NULL) {\n\t\tif (ldb_request_get_control(req, LDB_CONTROL_RELAX_OID) == NULL) {\n\t\t\tldb_set_errstring(ldb,\n\t\t\t\t\t  \"samldb: isCriticalSystemObject must not be specified!\");\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\t}\n\n\t/* msDS-IntId is not allowed to be modified\n\t * except when modification comes from replication */\n\tif (ldb_msg_find_element(req->op.mod.message, \"msDS-IntId\")) {\n\t\tif (!ldb_request_get_control(req,\n\t\t\t\t\t     DSDB_CONTROL_REPLICATED_UPDATE_OID)) {\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(req->op.mod.message, \"userParameters\");\n\tif (el != NULL && ldb_req_is_untrusted(req)) {\n\t\tconst char *reason = \"samldb: \"\n\t\t\t\"setting userParameters is not supported over LDAP, \"\n\t\t\t\"see https://bugzilla.samba.org/show_bug.cgi?id=8077\";\n\t\tldb_debug(ldb, LDB_DEBUG_WARNING, \"%s\", reason);\n\t\treturn ldb_error(ldb, LDB_ERR_CONSTRAINT_VIOLATION, reason);\n\t}\n\n\tac = samldb_ctx_init(module, req);\n\tif (ac == NULL) {\n\t\treturn ldb_operr(ldb);\n\t}\n\n\t/* build the new msg */\n\tac->msg = ldb_msg_copy_shallow(ac, req->op.mod.message);\n\tif (ac->msg == NULL) {\n\t\ttalloc_free(ac);\n\t\tldb_debug(ldb, LDB_DEBUG_FATAL,\n\t\t\t  \"samldb_modify: ldb_msg_copy_shallow failed!\\n\");\n\t\treturn ldb_operr(ldb);\n\t}\n\n\tret = samldb_check_sensitive_attributes(ac);\n\tif (ret != LDB_SUCCESS) {\n\t\ttalloc_free(ac);\n\t\treturn ret;\n\t}\n\n\tif (is_undelete == NULL) {\n\t\tel = ldb_msg_find_element(ac->msg, \"primaryGroupID\");\n\t\tif (el != NULL) {\n\t\t\tret = samldb_prim_group_trigger(ac);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"userAccountControl\");\n\tif (el != NULL) {\n\t\tmodified = true;\n\t\tret = samldb_user_account_control_change(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"pwdLastSet\");\n\tif (el != NULL) {\n\t\tmodified = true;\n\t\tret = samldb_pwd_last_set_change(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"lockoutTime\");\n\tif (el != NULL) {\n\t\tmodified = true;\n\t\tret = samldb_lockout_time(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"groupType\");\n\tif (el != NULL) {\n\t\tmodified = true;\n\t\tret = samldb_group_type_change(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"sAMAccountName\");\n\tif (el != NULL) {\n\t\tuint32_t user_account_control;\n\t\tstruct ldb_result *res = NULL;\n\t\tconst char * const attrs[] = { \"userAccountControl\",\n\t\t\t\t\t       \"objectclass\",\n\t\t\t\t\t       NULL };\n\t\tret = dsdb_module_search_dn(ac->module,\n\t\t\t\t\t    ac,\n\t\t\t\t\t    &res,\n\t\t\t\t\t    ac->msg->dn,\n\t\t\t\t\t    attrs,\n\t\t\t\t\t    DSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED,\n\t\t\t\t\t    ac->req);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t\tuser_account_control\n\t\t\t= ldb_msg_find_attr_as_uint(res->msgs[0],\n\t\t\t\t\t\t    \"userAccountControl\",\n\t\t\t\t\t\t    0);\n\n\t\tif ((user_account_control\n\t\t     & UF_TRUST_ACCOUNT_MASK) != 0) {\n\t\t\tac->need_trailing_dollar = true;\n\n\t\t} else if (samdb_find_attribute(ldb,\n\t\t\t\t\t\tres->msgs[0],\n\t\t\t\t\t\t\"objectclass\",\n\t\t\t\t\t\t\"computer\")\n\t\t\t   != NULL) {\n\t\t\tac->need_trailing_dollar = true;\n\t\t}\n\n\t\tret = samldb_sam_accountname_valid_check(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"userPrincipalName\");\n\tif (el != NULL) {\n\t\tret = samldb_sam_account_upn_clash(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\ttalloc_free(ac);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"ldapDisplayName\");\n\tif (el != NULL) {\n\t\tret = samldb_schema_ldapdisplayname_valid_check(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"attributeID\");\n\tif (el != NULL) {\n\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t       \"Once set, attributeID values may not be modified\");\n\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"governsID\");\n\tif (el != NULL) {\n\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t       \"Once set, governsID values may not be modified\");\n\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"member\");\n\tif (el != NULL) {\n\t\tstruct ldb_control *fix_link_sid_ctrl = NULL;\n\n\t\tfix_link_sid_ctrl = ldb_request_get_control(ac->req,\n\t\t\t\t\tDSDB_CONTROL_DBCHECK_FIX_LINK_DN_SID);\n\t\tif (fix_link_sid_ctrl == NULL) {\n\t\t\tret = samldb_member_check(ac);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"description\");\n\tif (el != NULL) {\n\t\tret = samldb_description_check(ac, &modified);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"dNSHostName\");\n\tel2 = ldb_msg_find_element(ac->msg, \"sAMAccountName\");\n\tif ((el != NULL) || (el2 != NULL)) {\n\t\tmodified = true;\n\t\t/*\n\t\t * samldb_service_principal_names_change() might add SPN\n\t\t * changes to the request, so this must come before the SPN\n\t\t * uniqueness check below.\n\t\t *\n\t\t * Note we ALSO have to do the SPN uniqueness check inside\n\t\t * samldb_service_principal_names_change(), because it does a\n\t\t * subrequest to do requested SPN modifications *before* its\n\t\t * automatic ones are added.\n\t\t */\n\t\tret = samldb_service_principal_names_change(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"servicePrincipalName\");\n\tif ((el != NULL)) {\n\t\t/*\n\t\t * We need to check whether the SPN collides with an existing\n\t\t * one (anywhere) including via aliases.\n\t\t */\n\t\tmodified = true;\n\t\tret = samldb_spn_uniqueness_check(ac, el);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tel = ldb_msg_find_element(ac->msg, \"fSMORoleOwner\");\n\tif (el != NULL) {\n\t\tret = samldb_fsmo_role_owner_check(ac);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (modified) {\n\t\tstruct ldb_request *child_req;\n\n\t\t/* Now perform the real modifications as a child request */\n\t\tret = ldb_build_mod_req(&child_req, ldb, ac,\n\t\t\t\t\tac->msg,\n\t\t\t\t\treq->controls,\n\t\t\t\t\treq, dsdb_next_callback,\n\t\t\t\t\treq);\n\t\tLDB_REQ_SET_LOCATION(child_req);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn ldb_next_request(module, child_req);\n\t}\n\n\ttalloc_free(ac);\n\n\t/* no change which interests us, go on */\n\treturn ldb_next_request(module, req);\n}\n\n/* delete */\n\nstatic int samldb_prim_group_users_check(struct samldb_ctx *ac)\n{\n\tstruct ldb_context *ldb;\n\tstruct dom_sid *sid;\n\tuint32_t rid;\n\tNTSTATUS status;\n\tint ret;\n\tstruct ldb_result *res = NULL;\n\tstruct ldb_result *res_users = NULL;\n\tconst char * const attrs[] = { \"objectSid\", \"isDeleted\", NULL };\n\tconst char * const noattrs[] = { NULL };\n\n\tldb = ldb_module_get_ctx(ac->module);\n\n\t/* Finds out the SID/RID of the SAM object */\n\tret = dsdb_module_search_dn(ac->module, ac, &res, ac->req->op.del.dn,\n\t\t\t\t\tattrs,\n\t\t\t\t\tDSDB_FLAG_NEXT_MODULE | DSDB_SEARCH_SHOW_DELETED,\n\t\t\t\t\tac->req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (ldb_msg_check_string_attribute(res->msgs[0], \"isDeleted\", \"TRUE\")) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tsid = samdb_result_dom_sid(ac, res->msgs[0], \"objectSid\");\n\tif (sid == NULL) {\n\t\t/* No SID - it might not be a SAM object - therefore ok */\n\t\treturn LDB_SUCCESS;\n\t}\n\tstatus = dom_sid_split_rid(ac, sid, NULL, &rid);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\treturn ldb_operr(ldb);\n\t}\n\tif (rid == 0) {\n\t\t/* Special object (security principal?) */\n\t\treturn LDB_SUCCESS;\n\t}\n\t/* do not allow deletion of well-known sids */\n\tif (rid < DSDB_SAMDB_MINIMUM_ALLOWED_RID &&\n\t    (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID) == NULL)) {\n\t\treturn LDB_ERR_OTHER;\n\t}\n\n\t/* Deny delete requests from groups which are primary ones */\n\tret = dsdb_module_search(ac->module, ac, &res_users,\n\t\t\t\t ldb_get_default_basedn(ldb),\n\t\t\t\t LDB_SCOPE_SUBTREE, noattrs,\n\t\t\t\t DSDB_FLAG_NEXT_MODULE,\n\t\t\t\t ac->req,\n\t\t\t\t \"(&(primaryGroupID=%u)(objectClass=user))\", rid);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (res_users->count > 0) {\n\t\tldb_asprintf_errstring(ldb_module_get_ctx(ac->module),\n\t\t\t\t       \"Refusing to delete %s, as it \"\n\t\t\t\t       \"is still the primaryGroupID \"\n\t\t\t\t       \"for %u users\",\n\t\t\t\t       ldb_dn_get_linearized(res->msgs[0]->dn),\n\t\t\t\t       res_users->count);\n\n\t\t/*\n\t\t * Yes, this seems very wrong, but we have a test\n\t\t * for this exact error code in sam.py\n\t\t */\n\t\treturn LDB_ERR_ENTRY_ALREADY_EXISTS;\n\t}\n\n\treturn LDB_SUCCESS;\n}\n\nstatic int samldb_delete(struct ldb_module *module, struct ldb_request *req)\n{\n\tstruct samldb_ctx *ac;\n\tchar *referral = NULL;\n\tint ret;\n\tstruct ldb_context *ldb;\n\n\tif (ldb_dn_is_special(req->op.del.dn)) {\n\t\t/* do not manipulate our control entries */\n\t\treturn ldb_next_request(module, req);\n\t}\n\n\tldb = ldb_module_get_ctx(module);\n\n\treferral = refer_if_rodc(ldb, req, req->op.del.dn);\n\tif (referral != NULL) {\n\t\tret = ldb_module_send_referral(req, referral);\n\t\treturn ret;\n\t}\n\n\tac = samldb_ctx_init(module, req);\n\tif (ac == NULL) {\n\t\treturn ldb_operr(ldb_module_get_ctx(module));\n\t}\n\n\tret = samldb_prim_group_users_check(ac);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\ttalloc_free(ac);\n\n\treturn ldb_next_request(module, req);\n}\n\n/* rename */\n\nstatic int check_rename_constraints(struct ldb_message *msg,\n\t\t\t\t    struct samldb_ctx *ac,\n\t\t\t\t    struct ldb_dn *olddn, struct ldb_dn *newdn)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tstruct ldb_dn *dn1, *dn2, *nc_root;\n\tint32_t systemFlags;\n\tbool move_op = false;\n\tbool rename_op = false;\n\tint ret;\n\n\t/* Skip the checks if old and new DN are the same, or if we have the\n\t * relax control specified or if the returned objects is already\n\t * deleted and needs only to be moved for consistency. */\n\n\tif (ldb_dn_compare(olddn, newdn) == 0) {\n\t\treturn LDB_SUCCESS;\n\t}\n\tif (ldb_request_get_control(ac->req, LDB_CONTROL_RELAX_OID) != NULL) {\n\t\treturn LDB_SUCCESS;\n\t}\n\n\tif (ldb_msg_find_attr_as_bool(msg, \"isDeleted\", false)) {\n\t\t/*\n\t\t * check originating request if we are supposed\n\t\t * to \"see\" this record in first place.\n\t\t */\n\t\tif (ldb_request_get_control(ac->req, LDB_CONTROL_SHOW_DELETED_OID) == NULL) {\n\t\t\treturn LDB_ERR_NO_SUCH_OBJECT;\n\t\t}\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t/* Objects under CN=System */\n\n\tdn1 = ldb_dn_copy(ac, ldb_get_default_basedn(ldb));\n\tif (dn1 == NULL) return ldb_oom(ldb);\n\n\tif ( ! ldb_dn_add_child_fmt(dn1, \"CN=System\")) {\n\t\ttalloc_free(dn1);\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n\n\tif ((ldb_dn_compare_base(dn1, olddn) == 0) &&\n\t    (ldb_dn_compare_base(dn1, newdn) != 0)) {\n\t\ttalloc_free(dn1);\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"subtree_rename: Cannot move/rename %s. Objects under CN=System have to stay under it!\",\n\t\t\t\t       ldb_dn_get_linearized(olddn));\n\t\treturn LDB_ERR_OTHER;\n\t}\n\n\ttalloc_free(dn1);\n\n\t/* LSA objects */\n\n\tif ((samdb_find_attribute(ldb, msg, \"objectClass\", \"secret\") != NULL) ||\n\t    (samdb_find_attribute(ldb, msg, \"objectClass\", \"trustedDomain\") != NULL)) {\n\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t       \"subtree_rename: Cannot move/rename %s. It's an LSA-specific object!\",\n\t\t\t\t       ldb_dn_get_linearized(olddn));\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\n\t/* subnet objects */\n\tif (samdb_find_attribute(ldb, msg, \"objectclass\", \"subnet\") != NULL) {\n\t\tret = samldb_verify_subnet(ac, newdn);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* systemFlags */\n\n\tdn1 = ldb_dn_get_parent(ac, olddn);\n\tif (dn1 == NULL) return ldb_oom(ldb);\n\tdn2 = ldb_dn_get_parent(ac, newdn);\n\tif (dn2 == NULL) return ldb_oom(ldb);\n\n\tif (ldb_dn_compare(dn1, dn2) == 0) {\n\t\trename_op = true;\n\t} else {\n\t\tmove_op = true;\n\t}\n\n\ttalloc_free(dn1);\n\ttalloc_free(dn2);\n\n\tsystemFlags = ldb_msg_find_attr_as_int(msg, \"systemFlags\", 0);\n\n\t/* Fetch name context */\n\n\tret = dsdb_find_nc_root(ldb, ac, olddn, &nc_root);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif (ldb_dn_compare(nc_root, ldb_get_schema_basedn(ldb)) == 0) {\n\t\tif (move_op) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"subtree_rename: Cannot move %s within schema partition\",\n\t\t\t\t\t       ldb_dn_get_linearized(olddn));\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\t\tif (rename_op &&\n\t\t    (systemFlags & SYSTEM_FLAG_SCHEMA_BASE_OBJECT) != 0) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"subtree_rename: Cannot rename %s within schema partition\",\n\t\t\t\t\t       ldb_dn_get_linearized(olddn));\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\t} else if (ldb_dn_compare(nc_root, ldb_get_config_basedn(ldb)) == 0) {\n\t\tif (move_op &&\n\t\t    (systemFlags & SYSTEM_FLAG_CONFIG_ALLOW_MOVE) == 0) {\n\t\t\t/* Here we have to do more: control the\n\t\t\t * \"ALLOW_LIMITED_MOVE\" flag. This means that the\n\t\t\t * grand-grand-parents of two objects have to be equal\n\t\t\t * in order to perform the move (this is used for\n\t\t\t * moving \"server\" objects in the \"sites\" container). */\n\t\t\tbool limited_move =\n\t\t\t\tsystemFlags & SYSTEM_FLAG_CONFIG_ALLOW_LIMITED_MOVE;\n\n\t\t\tif (limited_move) {\n\t\t\t\tdn1 = ldb_dn_copy(ac, olddn);\n\t\t\t\tif (dn1 == NULL) return ldb_oom(ldb);\n\t\t\t\tdn2 = ldb_dn_copy(ac, newdn);\n\t\t\t\tif (dn2 == NULL) return ldb_oom(ldb);\n\n\t\t\t\tlimited_move &= ldb_dn_remove_child_components(dn1, 3);\n\t\t\t\tlimited_move &= ldb_dn_remove_child_components(dn2, 3);\n\t\t\t\tlimited_move &= ldb_dn_compare(dn1, dn2) == 0;\n\n\t\t\t\ttalloc_free(dn1);\n\t\t\t\ttalloc_free(dn2);\n\t\t\t}\n\n\t\t\tif (!limited_move\n\t\t\t    && ldb_request_get_control(ac->req, DSDB_CONTROL_RESTORE_TOMBSTONE_OID) == NULL) {\n\t\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t\t       \"subtree_rename: Cannot move %s to %s in config partition\",\n\t\t\t\t\t\t       ldb_dn_get_linearized(olddn), ldb_dn_get_linearized(newdn));\n\t\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t\t}\n\t\t}\n\t\tif (rename_op &&\n\t\t    (systemFlags & SYSTEM_FLAG_CONFIG_ALLOW_RENAME) == 0) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"subtree_rename: Cannot rename %s to %s within config partition\",\n\t\t\t\t\t       ldb_dn_get_linearized(olddn), ldb_dn_get_linearized(newdn));\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\t} else if (ldb_dn_compare(nc_root, ldb_get_default_basedn(ldb)) == 0) {\n\t\tif (move_op &&\n\t\t    (systemFlags & SYSTEM_FLAG_DOMAIN_DISALLOW_MOVE) != 0) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"subtree_rename: Cannot move %s to %s - DISALLOW_MOVE set\",\n\t\t\t\t\t       ldb_dn_get_linearized(olddn), ldb_dn_get_linearized(newdn));\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\t\tif (rename_op &&\n\t\t    (systemFlags & SYSTEM_FLAG_DOMAIN_DISALLOW_RENAME) != 0) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t\t       \"subtree_rename: Cannot rename %s to %s - DISALLOW_RENAME set\",\n\t\t\t\t\t       ldb_dn_get_linearized(olddn), ldb_dn_get_linearized(newdn));\n\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t}\n\t}\n\n\ttalloc_free(nc_root);\n\n\treturn LDB_SUCCESS;\n}\n\n\nstatic int samldb_rename_search_base_callback(struct ldb_request *req,\n\t\t\t\t\t       struct ldb_reply *ares)\n{\n\tstruct samldb_ctx *ac;\n\tint ret;\n\n\tac = talloc_get_type(req->context, struct samldb_ctx);\n\n\tif (!ares) {\n\t\treturn ldb_module_done(ac->req, NULL, NULL,\n\t\t\t\t\tLDB_ERR_OPERATIONS_ERROR);\n\t}\n\tif (ares->error != LDB_SUCCESS) {\n\t\treturn ldb_module_done(ac->req, ares->controls,\n\t\t\t\t\tares->response, ares->error);\n\t}\n\n\tswitch (ares->type) {\n\tcase LDB_REPLY_ENTRY:\n\t\t/*\n\t\t * This is the root entry of the originating move\n\t\t * respectively rename request. It has been already\n\t\t * stored in the list using \"subtree_rename_search()\".\n\t\t * Only this one is subject to constraint checking.\n\t\t */\n\t\tret = check_rename_constraints(ares->message, ac,\n\t\t\t\t\t       ac->req->op.rename.olddn,\n\t\t\t\t\t       ac->req->op.rename.newdn);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ldb_module_done(ac->req, NULL, NULL,\n\t\t\t\t\t       ret);\n\t\t}\n\t\tbreak;\n\n\tcase LDB_REPLY_REFERRAL:\n\t\t/* ignore */\n\t\tbreak;\n\n\tcase LDB_REPLY_DONE:\n\n\t\t/*\n\t\t * Great, no problem with the rename, so go ahead as\n\t\t * if we never were here\n\t\t */\n\t\tret = ldb_next_request(ac->module, ac->req);\n\t\ttalloc_free(ares);\n\t\treturn ret;\n\t}\n\n\ttalloc_free(ares);\n\treturn LDB_SUCCESS;\n}\n\n\n/* rename */\nstatic int samldb_rename(struct ldb_module *module, struct ldb_request *req)\n{\n\tstruct ldb_context *ldb;\n\tstatic const char * const attrs[] = { \"objectClass\", \"systemFlags\",\n\t\t\t\t\t      \"isDeleted\", NULL };\n\tstruct ldb_request *search_req;\n\tstruct samldb_ctx *ac;\n\tint ret;\n\n\tif (ldb_dn_is_special(req->op.rename.olddn)) { /* do not manipulate our control entries */\n\t\treturn ldb_next_request(module, req);\n\t}\n\n\tldb = ldb_module_get_ctx(module);\n\n\tac = samldb_ctx_init(module, req);\n\tif (!ac) {\n\t\treturn ldb_oom(ldb);\n\t}\n\n\tret = ldb_build_search_req(&search_req, ldb, ac,\n\t\t\t\t   req->op.rename.olddn,\n\t\t\t\t   LDB_SCOPE_BASE,\n\t\t\t\t   \"(objectClass=*)\",\n\t\t\t\t   attrs,\n\t\t\t\t   NULL,\n\t\t\t\t   ac,\n\t\t\t\t   samldb_rename_search_base_callback,\n\t\t\t\t   req);\n\tLDB_REQ_SET_LOCATION(search_req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tret = ldb_request_add_control(search_req, LDB_CONTROL_SHOW_RECYCLED_OID,\n\t\t\t\t      true, NULL);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ldb_next_request(ac->module, search_req);\n}\n\n/* extended */\n\nstatic int samldb_extended_allocate_rid_pool(struct ldb_module *module, struct ldb_request *req)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(module);\n\tstruct dsdb_fsmo_extended_op *exop;\n\tint ret;\n\n\texop = talloc_get_type(req->op.extended.data,\n\t\t\t       struct dsdb_fsmo_extended_op);\n\tif (!exop) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb_extended_allocate_rid_pool: invalid extended data\");\n\t\treturn LDB_ERR_PROTOCOL_ERROR;\n\t}\n\n\tret = ridalloc_allocate_rid_pool_fsmo(module, exop, req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ldb_module_done(req, NULL, NULL, LDB_SUCCESS);\n}\n\nstatic int samldb_extended_allocate_rid(struct ldb_module *module, struct ldb_request *req)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(module);\n\tstruct dsdb_extended_allocate_rid *exop;\n\tint ret;\n\n\texop = talloc_get_type(req->op.extended.data,\n\t\t\t       struct dsdb_extended_allocate_rid);\n\tif (!exop) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb_extended_allocate_rid: invalid extended data\");\n\t\treturn LDB_ERR_PROTOCOL_ERROR;\n\t}\n\n\tret = ridalloc_allocate_rid(module, &exop->rid, req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ldb_module_done(req, NULL, NULL, LDB_SUCCESS);\n}\n\nstatic int samldb_extended_create_own_rid_set(struct ldb_module *module, struct ldb_request *req)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(module);\n\tint ret;\n\tstruct ldb_dn *dn;\n\n\tif (req->op.extended.data != NULL) {\n\t\tldb_set_errstring(ldb,\n\t\t\t\t  \"samldb_extended_create_own_rid_set: invalid extended data (should be NULL)\");\n\t\treturn LDB_ERR_PROTOCOL_ERROR;\n\t}\n\n\tret = ridalloc_create_own_rid_set(module, req,\n\t\t\t\t\t  &dn, req);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\treturn ldb_module_done(req, NULL, NULL, LDB_SUCCESS);\n}\n\nstatic int samldb_extended(struct ldb_module *module, struct ldb_request *req)\n{\n\tif (strcmp(req->op.extended.oid, DSDB_EXTENDED_ALLOCATE_RID_POOL) == 0) {\n\t\treturn samldb_extended_allocate_rid_pool(module, req);\n\t}\n\n\tif (strcmp(req->op.extended.oid, DSDB_EXTENDED_ALLOCATE_RID) == 0) {\n\t\treturn samldb_extended_allocate_rid(module, req);\n\t}\n\n\tif (strcmp(req->op.extended.oid, DSDB_EXTENDED_CREATE_OWN_RID_SET) == 0) {\n\t\treturn samldb_extended_create_own_rid_set(module, req);\n\t}\n\n\treturn ldb_next_request(module, req);\n}\n\n\nstatic const struct ldb_module_ops ldb_samldb_module_ops = {\n\t.name          = \"samldb\",\n\t.add           = samldb_add,\n\t.modify        = samldb_modify,\n\t.del           = samldb_delete,\n\t.rename        = samldb_rename,\n\t.extended      = samldb_extended\n};\n\n\nint ldb_samldb_module_init(const char *version)\n{\n\tLDB_MODULE_CHECK_VERSION(version);\n\treturn ldb_register_module(&ldb_samldb_module_ops);\n}\n"], "filenames": ["selftest/knownfail.d/ldap_spn", "source4/dsdb/samdb/ldb_modules/samldb.c"], "buggy_code_start_loc": [2, 4009], "buggy_code_end_loc": [3, 4011], "fixing_code_start_loc": [1, 4009], "fixing_code_end_loc": [1, 4010], "type": "CWE-276", "message": "The Samba AD DC includes checks when adding service principals names (SPNs) to an account to ensure that SPNs do not alias with those already in the database. Some of these checks are able to be bypassed if an account modification re-adds an SPN that was previously present on that account, such as one added when a computer is joined to a domain. An attacker who has the ability to write to an account can exploit this to perform a denial-of-service attack by adding an SPN that matches an existing service. Additionally, an attacker who can intercept traffic can impersonate existing services, resulting in a loss of confidentiality and integrity.", "other": {"cve": {"id": "CVE-2022-0336", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-29T15:15:09.250", "lastModified": "2022-09-01T20:05:40.300", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Samba AD DC includes checks when adding service principals names (SPNs) to an account to ensure that SPNs do not alias with those already in the database. Some of these checks are able to be bypassed if an account modification re-adds an SPN that was previously present on that account, such as one added when a computer is joined to a domain. An attacker who has the ability to write to an account can exploit this to perform a denial-of-service attack by adding an SPN that matches an existing service. Additionally, an attacker who can intercept traffic can impersonate existing services, resulting in a loss of confidentiality and integrity."}, {"lang": "es", "value": "El DC de Samba AD incluye comprobaciones cuando son a\u00f1adidos nombres de directores de servicio (SPN) a una cuenta para asegurar que los SPN no presentan alias con los que ya est\u00e1n en la base de datos. Algunas de estas comprobaciones pueden omitirse si una modificaci\u00f3n de la cuenta vuelve a a\u00f1adir un SPN que ya estaba presente en esa cuenta, como uno a\u00f1adido cuando un equipo es unido a un dominio. Un atacante que tenga la capacidad de escribir en una cuenta puede aprovechar esto para llevar a cabo un ataque de denegaci\u00f3n de servicio al a\u00f1adir un SPN que coincida con un servicio existente. Adem\u00e1s, un atacante que pueda interceptar el tr\u00e1fico puede hacerse pasar por los servicios existentes, resultando en una p\u00e9rdida de confidencialidad e integridad"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-276"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-276"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:samba:samba:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.13.17", "matchCriteriaId": "3EEB3465-0B2F-481E-B839-3ABCE85E2299"}, {"vulnerable": true, "criteria": "cpe:2.3:a:samba:samba:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.14.0", "versionEndExcluding": "4.14.12", "matchCriteriaId": "4E57F9C0-2EA0-4485-B018-665139BA3F42"}, {"vulnerable": true, "criteria": "cpe:2.3:a:samba:samba:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.15.0", "versionEndExcluding": "4.15.4", "matchCriteriaId": "713AE88D-3F5B-4E80-8E10-692B4925F76B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2022-0336", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2046134", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugzilla.samba.org/show_bug.cgi?id=14950", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/samba-team/samba/commit/1a5dc817c0c9379bbaab14c676681b42b0039a3c", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/samba-team/samba/commit/c58ede44f382bd0125f761f0479c8d48156be400", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.samba.org/samba/security/CVE-2022-0336.html", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/samba-team/samba/commit/1a5dc817c0c9379bbaab14c676681b42b0039a3c"}}