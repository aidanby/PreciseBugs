{"buggy_code": ["# ~*~ encoding: utf-8 ~*~\n\nrequire 'grit'\nrequire 'ostruct'\n\nmodule Gollum\n\n  def self.set_git_timeout(time)\n    Grit::Git.git_timeout = time\n  end\n\n  def self.set_git_max_filesize(size)\n    Grit::Git.git_max_size = size\n  end\n\n  module Git\n    \n    class Actor\n      \n      attr_accessor :name, :email\n      \n      def initialize(name, email)\n        @name = name\n        @email = email\n        @actor = Grit::Actor.new(name, email)\n      end\n      \n      def output(time)\n        @actor.output(time)\n      end\n      \n    end\n    \n    class Blob\n      def self.create(repo, options)\n        #Grit::Blob.create(repo, :id => @sha, :name => name, :size => @size, :mode => @mode)\n        blob = Grit::Blob.create(repo, options)\n        self.new(blob)\n      end\n      \n      def initialize(blob)\n        @blob = blob\n      end\n      \n      def id\n        @blob.id\n      end\n      \n      def mode\n        @blob.mode\n      end\n      \n      def size\n        @blob.size\n      end\n      \n      def data\n        @blob.data\n      end\n      \n      def name\n        @blob.name\n      end\n      \n      def mime_type\n        @blob.mime_type\n      end\n      \n      def is_symlink\n        @blob.is_symlink\n      end\n\n      def symlink_target(base_path = nil)\n        @blob.symlink_target(base_path)\n      end\n    end\n    \n    class Commit\n      \n      def initialize(commit)\n        @commit = commit\n      end\n      \n      def id\n        @commit.id\n      end\n      alias_method :sha, :id\n      \n      def to_s\n        @commit.id\n      end\n\n      def stats\n        @stats ||= begin\n          grit_stats = @commit.stats\n          OpenStruct.new(:additions => grit_stats.additions, :deletions => grit_stats.deletions, :files => grit_stats.files, :id => id, :total => grit_stats.total)\n        end\n      end\n      \n      def author\n        author = @commit.author\n        Gollum::Git::Actor.new(author.name, author.email)\n      end\n      \n      def authored_date\n        @commit.authored_date\n      end\n      \n      def message\n        @commit.message\n      end\n      \n      def tree\n        Gollum::Git::Tree.new(@commit.tree)\n      end\n      \n      # Grit::Commit.list_from_string(@wiki.repo, log)\n      def self.list_from_string(repo, log)\n        Grit::Commit.list_from_string(repo, log)\n      end\n      \n    end\n    \n    # Note that in Grit, the methods grep, rm, checkout, ls_files\n    # are all passed to native via method_missing. Hence the uniform\n    # method signatures.\n    class Git\n    \n      def initialize(git)\n        @git = git\n      end\n      \n      def exist?\n        @git.exist?\n      end\n      \n      def grep(query, options={})\n        ref = options[:ref] ? options[:ref] : \"HEAD\"\n        args = [{}, '-I', '-i', '-c', query, ref, '--']\n        args << options[:path] if options[:path]\n        result = @git.grep(*args).split(\"\\n\")\n        result.map do |line|\n          branch_and_name, _, count = line.rpartition(\":\")\n          branch, _, name = branch_and_name.partition(':')\n          {:name => name, :count => count}\n        end\n      end\n      \n      # git.rm({'f' => true}, '--', path)\n      def rm(path, options = {}, &block)\n        options['f'] = true if options[:force]\n        @git.rm(options, '--', path, &block)\n      end\n      \n      # git.checkout({}, 'HEAD', '--', path)\n      def checkout(path, ref, options = {}, &block)\n        @git.checkout(options, ref, '--', path, &block)\n      end\n      \n      def rev_list(options, *refs)\n        @git.rev_list(options, *refs)\n      rescue Grit::GitRuby::Repository::NoSuchShaFound\n        raise Gollum::Git::NoSuchShaFound\n      end\n      \n      def ls_files(query, options = {})\n        options[:ref] = options[:ref] ? options[:ref] : \"HEAD\"\n        @git.ls_files({}, \"*#{query}*\").split(\"\\n\")\n      end\n      \n      def ls_tree(options={}, *args, &block)\n        @git.native(:ls_tree, options, *args, &block)\n        #         {:r => true, :l => true, :z => true}, sha)\n      end\n      \n      def apply_patch(head_sha=nil, patch=nil)\n        @git.apply_patch({}, head_sha, patch)\n      end\n      \n      # @repo.git.cat_file({:p => true}, sha)\n      def cat_file(options, sha)\n        @git.cat_file(options, sha)\n      end\n      \n      def versions_for_path(path = nil, ref = nil, options = nil)\n        if options[:follow]\n          options[:pretty] = 'raw'\n          options.delete :max_count\n          options.delete :skip\n          logstr = log(path, ref, options)\n          Gollum::Git::Commit.list_from_string(repo, logstr)\n        else\n          repo.log(ref, path, options).map {|grit_commit| Gollum::Git::Commit.new(grit_commit)}\n        end\n      end\n\n      private\n\n      def log(path = nil, ref = nil, options = nil, *args)\n        @git.native(:log, options, \"--\", path)\n      end\n      \n      def refs(options, prefix)\n        @git.refs(options, prefix)\n      end\n\n      def repo\n        @repo ||= Grit::Repo.new(@git.git_dir)\n      end\n      \n    end\n    \n    class Index\n      \n      def initialize(index)\n        @index = index\n        @tree = Gollum::Git::Tree.new(@index.tree)\n        @current_tree = nil\n      end\n      \n      def delete(path)\n        @index.delete(path)\n      end\n      \n      def add(path, data)\n        @index.add(path, data)\n      end\n      \n      # index.commit(@options[:message], parents, actor, nil, @wiki.ref)\n      def commit(message, parents = nil, actor = nil, last_tree = nil, head = 'master')\n        @index.commit(message, parents, actor, last_tree, head)\n      end\n      \n      def tree\n        @index.tree\n      end\n      \n      def read_tree(id)\n        @index.read_tree(id)\n        @current_tree = Gollum::Git::Tree.new(@index.current_tree)\n      end\n      \n      def current_tree\n        @current_tree\n      end\n      \n    end\n    \n    class Ref\n      def initialize(ref)\n        @ref = ref\n      end\n      \n      def name\n        @ref.name\n      end\n      \n      def commit\n        Gollum::Git::Commit.new(@ref.commit)\n      end\n            \n    end\n    \n    class Repo\n      \n      def initialize(path, options)\n        begin\n          @repo = Grit::Repo.new(path, options)\n        rescue Grit::InvalidGitRepositoryError\n          raise Gollum::InvalidGitRepositoryError\n        rescue Grit::NoSuchPathError\n          raise Gollum::NoSuchPathError\n        end\n      end\n      \n      def self.init(path, git_options = {}, repo_options = {})\n        Grit::Repo.init(path, git_options, repo_options)\n        self.new(path, {:is_bare => false})\n      end\n      \n      def self.init_bare(path, git_options = {}, repo_options = {})\n        Grit::Repo.init_bare(path, git_options, repo_options)\n        self.new(path, {:is_bare => true})\n      end\n      \n      def bare\n        @repo.bare\n      end\n      \n      def config\n        @repo.config\n      end\n      \n      def git\n        @git ||= Gollum::Git::Git.new(@repo.git)\n      end\n      \n      def commit(id)\n        commit = @repo.commit(id)\n        return nil if commit.nil?\n        Gollum::Git::Commit.new(@repo.commit(id))\n      end\n      \n      def commits(start = 'master', max_count = 10, skip = 0)\n        @repo.commits(start, max_count, skip).map{|commit| Gollum::Git::Commit.new(commit)}\n      end\n      \n      # @wiki.repo.head.commit.sha\n      def head\n        Gollum::Git::Ref.new(@repo.head)\n      end\n      \n      def index\n        @index ||= Gollum::Git::Index.new(@repo.index)\n      end\n\n      def diff(sha1, sha2, path = nil)\n        @repo.diff(sha1, sha2, path)\n      end\n      \n      def log(commit = 'master', path = nil, options = {})\n        @repo.log(commit, path, options).map {|grit_commit| Gollum::Git::Commit.new(grit_commit)}\n      end\n      \n      def lstree(sha, options = {})\n        @repo.lstree(sha, options)\n      end\n      \n      def path\n        @repo.path\n      end\n      \n      def update_ref(head, commit_sha)\n        @repo.update_ref(head, commit_sha)\n      end\n     \n    end\n    \n    class Tree\n      \n      def initialize(tree)\n        @tree = tree\n      end\n      \n      def keys\n        @tree.keys\n      end\n      \n      def [](i)\n        @tree[i]\n      end\n      \n      def id\n        @tree.id\n      end\n      \n      # if index.current_tree && tree = index.current_tree / (@wiki.page_file_dir || '/')\n      def /(file)\n        @tree.send(:/, file) \n      end\n      \n      def blobs\n        return Array.new if @tree == {}\n        @tree.blobs.map{|blob| Gollum::Git::Blob.new(blob) }\n      end\n    end\n    \n    class NoSuchShaFound < StandardError\n    end\n    \n  end\nend\n\n# Monkey patching Grit's Blob class (taken from grit_ext.rb)\nmodule Grit\n  class Blob\n    def is_symlink\n      self.mode == 0120000\n    end\n\n    def symlink_target(base_path = nil)\n      target = self.data\n      new_path = File.expand_path(File.join('..', target), base_path)\n\n      if File.file? new_path\n        return new_path\n      end\n    end\n\n    nil\n  end\nend"], "fixing_code": ["# ~*~ encoding: utf-8 ~*~\n\nrequire 'grit'\nrequire 'ostruct'\n\nmodule Gollum\n\n  def self.set_git_timeout(time)\n    Grit::Git.git_timeout = time\n  end\n\n  def self.set_git_max_filesize(size)\n    Grit::Git.git_max_size = size\n  end\n\n  module Git\n    \n    class Actor\n      \n      attr_accessor :name, :email\n      \n      def initialize(name, email)\n        @name = name\n        @email = email\n        @actor = Grit::Actor.new(name, email)\n      end\n      \n      def output(time)\n        @actor.output(time)\n      end\n      \n    end\n    \n    class Blob\n      def self.create(repo, options)\n        #Grit::Blob.create(repo, :id => @sha, :name => name, :size => @size, :mode => @mode)\n        blob = Grit::Blob.create(repo, options)\n        self.new(blob)\n      end\n      \n      def initialize(blob)\n        @blob = blob\n      end\n      \n      def id\n        @blob.id\n      end\n      \n      def mode\n        @blob.mode\n      end\n      \n      def size\n        @blob.size\n      end\n      \n      def data\n        @blob.data\n      end\n      \n      def name\n        @blob.name\n      end\n      \n      def mime_type\n        @blob.mime_type\n      end\n      \n      def is_symlink\n        @blob.is_symlink\n      end\n\n      def symlink_target(base_path = nil)\n        @blob.symlink_target(base_path)\n      end\n    end\n    \n    class Commit\n      \n      def initialize(commit)\n        @commit = commit\n      end\n      \n      def id\n        @commit.id\n      end\n      alias_method :sha, :id\n      \n      def to_s\n        @commit.id\n      end\n\n      def stats\n        @stats ||= begin\n          grit_stats = @commit.stats\n          OpenStruct.new(:additions => grit_stats.additions, :deletions => grit_stats.deletions, :files => grit_stats.files, :id => id, :total => grit_stats.total)\n        end\n      end\n      \n      def author\n        author = @commit.author\n        Gollum::Git::Actor.new(author.name, author.email)\n      end\n      \n      def authored_date\n        @commit.authored_date\n      end\n      \n      def message\n        @commit.message\n      end\n      \n      def tree\n        Gollum::Git::Tree.new(@commit.tree)\n      end\n      \n      # Grit::Commit.list_from_string(@wiki.repo, log)\n      def self.list_from_string(repo, log)\n        Grit::Commit.list_from_string(repo, log)\n      end\n      \n    end\n    \n    # Note that in Grit, the methods grep, rm, checkout, ls_files\n    # are all passed to native via method_missing. Hence the uniform\n    # method signatures.\n    class Git\n    \n      def initialize(git)\n        @git = git\n      end\n      \n      def exist?\n        @git.exist?\n      end\n      \n      def grep(query, options={})\n        ref = options[:ref] ? options[:ref] : \"HEAD\"\n        query = Shellwords.split(query).select {|q| !(q =~ /^(-O)|(--open-files-in-pager)/) }\n        query = Shellwords.join(query)\n        args = [{}, '-I', '-i', '-c', query, ref, '--']\n        args << options[:path] if options[:path]\n        result = @git.grep(*args).split(\"\\n\")\n        result.map do |line|\n          branch_and_name, _, count = line.rpartition(\":\")\n          branch, _, name = branch_and_name.partition(':')\n          {:name => name, :count => count}\n        end\n      end\n      \n      # git.rm({'f' => true}, '--', path)\n      def rm(path, options = {}, &block)\n        options['f'] = true if options[:force]\n        @git.rm(options, '--', path, &block)\n      end\n      \n      # git.checkout({}, 'HEAD', '--', path)\n      def checkout(path, ref, options = {}, &block)\n        @git.checkout(options, ref, '--', path, &block)\n      end\n      \n      def rev_list(options, *refs)\n        @git.rev_list(options, *refs)\n      rescue Grit::GitRuby::Repository::NoSuchShaFound\n        raise Gollum::Git::NoSuchShaFound\n      end\n      \n      def ls_files(query, options = {})\n        options[:ref] = options[:ref] ? options[:ref] : \"HEAD\"\n        query = Shellwords.shellescape(query)\n        @git.ls_files({}, \"*#{query}*\").split(\"\\n\")\n      end\n      \n      def ls_tree(options={}, *args, &block)\n        @git.native(:ls_tree, options, *args, &block)\n        #         {:r => true, :l => true, :z => true}, sha)\n      end\n      \n      def apply_patch(head_sha=nil, patch=nil)\n        @git.apply_patch({}, head_sha, patch)\n      end\n      \n      # @repo.git.cat_file({:p => true}, sha)\n      def cat_file(options, sha)\n        @git.cat_file(options, sha)\n      end\n      \n      def versions_for_path(path = nil, ref = nil, options = nil)\n        if options[:follow]\n          options[:pretty] = 'raw'\n          options.delete :max_count\n          options.delete :skip\n          logstr = log(path, ref, options)\n          Gollum::Git::Commit.list_from_string(repo, logstr)\n        else\n          repo.log(ref, path, options).map {|grit_commit| Gollum::Git::Commit.new(grit_commit)}\n        end\n      end\n\n      private\n\n      def log(path = nil, ref = nil, options = nil, *args)\n        @git.native(:log, options, \"--\", path)\n      end\n      \n      def refs(options, prefix)\n        @git.refs(options, prefix)\n      end\n\n      def repo\n        @repo ||= Grit::Repo.new(@git.git_dir)\n      end\n      \n    end\n    \n    class Index\n      \n      def initialize(index)\n        @index = index\n        @tree = Gollum::Git::Tree.new(@index.tree)\n        @current_tree = nil\n      end\n      \n      def delete(path)\n        @index.delete(path)\n      end\n      \n      def add(path, data)\n        @index.add(path, data)\n      end\n      \n      # index.commit(@options[:message], parents, actor, nil, @wiki.ref)\n      def commit(message, parents = nil, actor = nil, last_tree = nil, head = 'master')\n        @index.commit(message, parents, actor, last_tree, head)\n      end\n      \n      def tree\n        @index.tree\n      end\n      \n      def read_tree(id)\n        @index.read_tree(id)\n        @current_tree = Gollum::Git::Tree.new(@index.current_tree)\n      end\n      \n      def current_tree\n        @current_tree\n      end\n      \n    end\n    \n    class Ref\n      def initialize(ref)\n        @ref = ref\n      end\n      \n      def name\n        @ref.name\n      end\n      \n      def commit\n        Gollum::Git::Commit.new(@ref.commit)\n      end\n            \n    end\n    \n    class Repo\n      \n      def initialize(path, options)\n        begin\n          @repo = Grit::Repo.new(path, options)\n        rescue Grit::InvalidGitRepositoryError\n          raise Gollum::InvalidGitRepositoryError\n        rescue Grit::NoSuchPathError\n          raise Gollum::NoSuchPathError\n        end\n      end\n      \n      def self.init(path, git_options = {}, repo_options = {})\n        Grit::Repo.init(path, git_options, repo_options)\n        self.new(path, {:is_bare => false})\n      end\n      \n      def self.init_bare(path, git_options = {}, repo_options = {})\n        Grit::Repo.init_bare(path, git_options, repo_options)\n        self.new(path, {:is_bare => true})\n      end\n      \n      def bare\n        @repo.bare\n      end\n      \n      def config\n        @repo.config\n      end\n      \n      def git\n        @git ||= Gollum::Git::Git.new(@repo.git)\n      end\n      \n      def commit(id)\n        commit = @repo.commit(id)\n        return nil if commit.nil?\n        Gollum::Git::Commit.new(@repo.commit(id))\n      end\n      \n      def commits(start = 'master', max_count = 10, skip = 0)\n        @repo.commits(start, max_count, skip).map{|commit| Gollum::Git::Commit.new(commit)}\n      end\n      \n      # @wiki.repo.head.commit.sha\n      def head\n        Gollum::Git::Ref.new(@repo.head)\n      end\n      \n      def index\n        @index ||= Gollum::Git::Index.new(@repo.index)\n      end\n\n      def diff(sha1, sha2, path = nil)\n        @repo.diff(sha1, sha2, path)\n      end\n      \n      def log(commit = 'master', path = nil, options = {})\n        @repo.log(commit, path, options).map {|grit_commit| Gollum::Git::Commit.new(grit_commit)}\n      end\n      \n      def lstree(sha, options = {})\n        @repo.lstree(sha, options)\n      end\n      \n      def path\n        @repo.path\n      end\n      \n      def update_ref(head, commit_sha)\n        @repo.update_ref(head, commit_sha)\n      end\n     \n    end\n    \n    class Tree\n      \n      def initialize(tree)\n        @tree = tree\n      end\n      \n      def keys\n        @tree.keys\n      end\n      \n      def [](i)\n        @tree[i]\n      end\n      \n      def id\n        @tree.id\n      end\n      \n      # if index.current_tree && tree = index.current_tree / (@wiki.page_file_dir || '/')\n      def /(file)\n        @tree.send(:/, file) \n      end\n      \n      def blobs\n        return Array.new if @tree == {}\n        @tree.blobs.map{|blob| Gollum::Git::Blob.new(blob) }\n      end\n    end\n    \n    class NoSuchShaFound < StandardError\n    end\n    \n  end\nend\n\n# Monkey patching Grit's Blob class (taken from grit_ext.rb)\nmodule Grit\n  class Blob\n    def is_symlink\n      self.mode == 0120000\n    end\n\n    def symlink_target(base_path = nil)\n      target = self.data\n      new_path = File.expand_path(File.join('..', target), base_path)\n\n      if File.file? new_path\n        return new_path\n      end\n    end\n\n    nil\n  end\nend"], "filenames": ["lib/grit_adapter/git_layer_grit.rb"], "buggy_code_start_loc": [138], "buggy_code_end_loc": [167], "fixing_code_start_loc": [139], "fixing_code_end_loc": [171], "type": "CWE-284", "message": "The gollum-grit_adapter Ruby gem dependency in gollum before 3.1.1 and the gollum-lib gem dependency in gollum-lib before 4.0.1 when the string \"master\" is in any of the wiki documents, allows remote authenticated users to execute arbitrary code via the -O or --open-files-in-pager flags.", "other": {"cve": {"id": "CVE-2014-9489", "sourceIdentifier": "cve@mitre.org", "published": "2017-10-17T14:29:00.383", "lastModified": "2017-11-08T16:20:11.777", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The gollum-grit_adapter Ruby gem dependency in gollum before 3.1.1 and the gollum-lib gem dependency in gollum-lib before 4.0.1 when the string \"master\" is in any of the wiki documents, allows remote authenticated users to execute arbitrary code via the -O or --open-files-in-pager flags."}, {"lang": "es", "value": "La dependencia en Ruby gollum-grit_adapter en gollum en versiones anteriores a la 3.1.1 y la dependencia de la gema gollum-lib en las versiones anteriores a la 4.0.1 de gollum-lib, cuando la cadena \"master\" est\u00e1 en alguno de los documentos wiki, permite que usuarios autenticados remotos ejecuten c\u00f3digo arbitrario mediante las marcas -O u --open-files-in-pager."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gollum_project:gollum:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.1.0", "matchCriteriaId": "FDE42401-5796-4344-8F36-6ADAF3F9BCC3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gollum_project:gollum-lib:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.0.0", "matchCriteriaId": "60C6C351-422D-4BA5-8A6E-AE83D7333C9F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gollum_project:grit_adapter:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.1.0", "matchCriteriaId": "D163A425-67EC-4F51-8CD9-151DB5A5272D"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2015/01/03/19", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/71499", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/gollum/gollum/issues/913", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/gollum/grit_adapter/commit/4520d973c81fecfebbeacd2ef2f1849d763951c7", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gollum/grit_adapter/commit/4520d973c81fecfebbeacd2ef2f1849d763951c7"}}