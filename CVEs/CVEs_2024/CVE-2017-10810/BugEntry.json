{"buggy_code": ["/*\n * Copyright (C) 2015 Red Hat, Inc.\n * All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice (including the\n * next paragraph) shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include \"virtgpu_drv.h\"\n\nstatic void virtio_gpu_ttm_bo_destroy(struct ttm_buffer_object *tbo)\n{\n\tstruct virtio_gpu_object *bo;\n\tstruct virtio_gpu_device *vgdev;\n\n\tbo = container_of(tbo, struct virtio_gpu_object, tbo);\n\tvgdev = (struct virtio_gpu_device *)bo->gem_base.dev->dev_private;\n\n\tif (bo->hw_res_handle)\n\t\tvirtio_gpu_cmd_unref_resource(vgdev, bo->hw_res_handle);\n\tif (bo->pages)\n\t\tvirtio_gpu_object_free_sg_table(bo);\n\tdrm_gem_object_release(&bo->gem_base);\n\tkfree(bo);\n}\n\nstatic void virtio_gpu_init_ttm_placement(struct virtio_gpu_object *vgbo,\n\t\t\t\t\t  bool pinned)\n{\n\tu32 c = 1;\n\tu32 pflag = pinned ? TTM_PL_FLAG_NO_EVICT : 0;\n\n\tvgbo->placement.placement = &vgbo->placement_code;\n\tvgbo->placement.busy_placement = &vgbo->placement_code;\n\tvgbo->placement_code.fpfn = 0;\n\tvgbo->placement_code.lpfn = 0;\n\tvgbo->placement_code.flags =\n\t\tTTM_PL_MASK_CACHING | TTM_PL_FLAG_TT | pflag;\n\tvgbo->placement.num_placement = c;\n\tvgbo->placement.num_busy_placement = c;\n\n}\n\nint virtio_gpu_object_create(struct virtio_gpu_device *vgdev,\n\t\t\t     unsigned long size, bool kernel, bool pinned,\n\t\t\t     struct virtio_gpu_object **bo_ptr)\n{\n\tstruct virtio_gpu_object *bo;\n\tenum ttm_bo_type type;\n\tsize_t acc_size;\n\tint ret;\n\n\tif (kernel)\n\t\ttype = ttm_bo_type_kernel;\n\telse\n\t\ttype = ttm_bo_type_device;\n\t*bo_ptr = NULL;\n\n\tacc_size = ttm_bo_dma_acc_size(&vgdev->mman.bdev, size,\n\t\t\t\t       sizeof(struct virtio_gpu_object));\n\n\tbo = kzalloc(sizeof(struct virtio_gpu_object), GFP_KERNEL);\n\tif (bo == NULL)\n\t\treturn -ENOMEM;\n\tsize = roundup(size, PAGE_SIZE);\n\tret = drm_gem_object_init(vgdev->ddev, &bo->gem_base, size);\n\tif (ret != 0)\n\t\treturn ret;\n\tbo->dumb = false;\n\tvirtio_gpu_init_ttm_placement(bo, pinned);\n\n\tret = ttm_bo_init(&vgdev->mman.bdev, &bo->tbo, size, type,\n\t\t\t  &bo->placement, 0, !kernel, NULL, acc_size,\n\t\t\t  NULL, NULL, &virtio_gpu_ttm_bo_destroy);\n\t/* ttm_bo_init failure will call the destroy */\n\tif (ret != 0)\n\t\treturn ret;\n\n\t*bo_ptr = bo;\n\treturn 0;\n}\n\nint virtio_gpu_object_kmap(struct virtio_gpu_object *bo, void **ptr)\n{\n\tbool is_iomem;\n\tint r;\n\n\tif (bo->vmap) {\n\t\tif (ptr)\n\t\t\t*ptr = bo->vmap;\n\t\treturn 0;\n\t}\n\tr = ttm_bo_kmap(&bo->tbo, 0, bo->tbo.num_pages, &bo->kmap);\n\tif (r)\n\t\treturn r;\n\tbo->vmap = ttm_kmap_obj_virtual(&bo->kmap, &is_iomem);\n\tif (ptr)\n\t\t*ptr = bo->vmap;\n\treturn 0;\n}\n\nint virtio_gpu_object_get_sg_table(struct virtio_gpu_device *qdev,\n\t\t\t\t   struct virtio_gpu_object *bo)\n{\n\tint ret;\n\tstruct page **pages = bo->tbo.ttm->pages;\n\tint nr_pages = bo->tbo.num_pages;\n\n\t/* wtf swapping */\n\tif (bo->pages)\n\t\treturn 0;\n\n\tif (bo->tbo.ttm->state == tt_unpopulated)\n\t\tbo->tbo.ttm->bdev->driver->ttm_tt_populate(bo->tbo.ttm);\n\tbo->pages = kmalloc(sizeof(struct sg_table), GFP_KERNEL);\n\tif (!bo->pages)\n\t\tgoto out;\n\n\tret = sg_alloc_table_from_pages(bo->pages, pages, nr_pages, 0,\n\t\t\t\t\tnr_pages << PAGE_SHIFT, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out;\n\treturn 0;\nout:\n\tkfree(bo->pages);\n\tbo->pages = NULL;\n\treturn -ENOMEM;\n}\n\nvoid virtio_gpu_object_free_sg_table(struct virtio_gpu_object *bo)\n{\n\tsg_free_table(bo->pages);\n\tkfree(bo->pages);\n\tbo->pages = NULL;\n}\n\nint virtio_gpu_object_wait(struct virtio_gpu_object *bo, bool no_wait)\n{\n\tint r;\n\n\tr = ttm_bo_reserve(&bo->tbo, true, no_wait, NULL);\n\tif (unlikely(r != 0))\n\t\treturn r;\n\tr = ttm_bo_wait(&bo->tbo, true, no_wait);\n\tttm_bo_unreserve(&bo->tbo);\n\treturn r;\n}\n\n"], "fixing_code": ["/*\n * Copyright (C) 2015 Red Hat, Inc.\n * All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice (including the\n * next paragraph) shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n#include \"virtgpu_drv.h\"\n\nstatic void virtio_gpu_ttm_bo_destroy(struct ttm_buffer_object *tbo)\n{\n\tstruct virtio_gpu_object *bo;\n\tstruct virtio_gpu_device *vgdev;\n\n\tbo = container_of(tbo, struct virtio_gpu_object, tbo);\n\tvgdev = (struct virtio_gpu_device *)bo->gem_base.dev->dev_private;\n\n\tif (bo->hw_res_handle)\n\t\tvirtio_gpu_cmd_unref_resource(vgdev, bo->hw_res_handle);\n\tif (bo->pages)\n\t\tvirtio_gpu_object_free_sg_table(bo);\n\tdrm_gem_object_release(&bo->gem_base);\n\tkfree(bo);\n}\n\nstatic void virtio_gpu_init_ttm_placement(struct virtio_gpu_object *vgbo,\n\t\t\t\t\t  bool pinned)\n{\n\tu32 c = 1;\n\tu32 pflag = pinned ? TTM_PL_FLAG_NO_EVICT : 0;\n\n\tvgbo->placement.placement = &vgbo->placement_code;\n\tvgbo->placement.busy_placement = &vgbo->placement_code;\n\tvgbo->placement_code.fpfn = 0;\n\tvgbo->placement_code.lpfn = 0;\n\tvgbo->placement_code.flags =\n\t\tTTM_PL_MASK_CACHING | TTM_PL_FLAG_TT | pflag;\n\tvgbo->placement.num_placement = c;\n\tvgbo->placement.num_busy_placement = c;\n\n}\n\nint virtio_gpu_object_create(struct virtio_gpu_device *vgdev,\n\t\t\t     unsigned long size, bool kernel, bool pinned,\n\t\t\t     struct virtio_gpu_object **bo_ptr)\n{\n\tstruct virtio_gpu_object *bo;\n\tenum ttm_bo_type type;\n\tsize_t acc_size;\n\tint ret;\n\n\tif (kernel)\n\t\ttype = ttm_bo_type_kernel;\n\telse\n\t\ttype = ttm_bo_type_device;\n\t*bo_ptr = NULL;\n\n\tacc_size = ttm_bo_dma_acc_size(&vgdev->mman.bdev, size,\n\t\t\t\t       sizeof(struct virtio_gpu_object));\n\n\tbo = kzalloc(sizeof(struct virtio_gpu_object), GFP_KERNEL);\n\tif (bo == NULL)\n\t\treturn -ENOMEM;\n\tsize = roundup(size, PAGE_SIZE);\n\tret = drm_gem_object_init(vgdev->ddev, &bo->gem_base, size);\n\tif (ret != 0) {\n\t\tkfree(bo);\n\t\treturn ret;\n\t}\n\tbo->dumb = false;\n\tvirtio_gpu_init_ttm_placement(bo, pinned);\n\n\tret = ttm_bo_init(&vgdev->mman.bdev, &bo->tbo, size, type,\n\t\t\t  &bo->placement, 0, !kernel, NULL, acc_size,\n\t\t\t  NULL, NULL, &virtio_gpu_ttm_bo_destroy);\n\t/* ttm_bo_init failure will call the destroy */\n\tif (ret != 0)\n\t\treturn ret;\n\n\t*bo_ptr = bo;\n\treturn 0;\n}\n\nint virtio_gpu_object_kmap(struct virtio_gpu_object *bo, void **ptr)\n{\n\tbool is_iomem;\n\tint r;\n\n\tif (bo->vmap) {\n\t\tif (ptr)\n\t\t\t*ptr = bo->vmap;\n\t\treturn 0;\n\t}\n\tr = ttm_bo_kmap(&bo->tbo, 0, bo->tbo.num_pages, &bo->kmap);\n\tif (r)\n\t\treturn r;\n\tbo->vmap = ttm_kmap_obj_virtual(&bo->kmap, &is_iomem);\n\tif (ptr)\n\t\t*ptr = bo->vmap;\n\treturn 0;\n}\n\nint virtio_gpu_object_get_sg_table(struct virtio_gpu_device *qdev,\n\t\t\t\t   struct virtio_gpu_object *bo)\n{\n\tint ret;\n\tstruct page **pages = bo->tbo.ttm->pages;\n\tint nr_pages = bo->tbo.num_pages;\n\n\t/* wtf swapping */\n\tif (bo->pages)\n\t\treturn 0;\n\n\tif (bo->tbo.ttm->state == tt_unpopulated)\n\t\tbo->tbo.ttm->bdev->driver->ttm_tt_populate(bo->tbo.ttm);\n\tbo->pages = kmalloc(sizeof(struct sg_table), GFP_KERNEL);\n\tif (!bo->pages)\n\t\tgoto out;\n\n\tret = sg_alloc_table_from_pages(bo->pages, pages, nr_pages, 0,\n\t\t\t\t\tnr_pages << PAGE_SHIFT, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out;\n\treturn 0;\nout:\n\tkfree(bo->pages);\n\tbo->pages = NULL;\n\treturn -ENOMEM;\n}\n\nvoid virtio_gpu_object_free_sg_table(struct virtio_gpu_object *bo)\n{\n\tsg_free_table(bo->pages);\n\tkfree(bo->pages);\n\tbo->pages = NULL;\n}\n\nint virtio_gpu_object_wait(struct virtio_gpu_object *bo, bool no_wait)\n{\n\tint r;\n\n\tr = ttm_bo_reserve(&bo->tbo, true, no_wait, NULL);\n\tif (unlikely(r != 0))\n\t\treturn r;\n\tr = ttm_bo_wait(&bo->tbo, true, no_wait);\n\tttm_bo_unreserve(&bo->tbo);\n\treturn r;\n}\n\n"], "filenames": ["drivers/gpu/drm/virtio/virtgpu_object.c"], "buggy_code_start_loc": [84], "buggy_code_end_loc": [85], "fixing_code_start_loc": [84], "fixing_code_end_loc": [88], "type": "CWE-772", "message": "Memory leak in the virtio_gpu_object_create function in drivers/gpu/drm/virtio/virtgpu_object.c in the Linux kernel through 4.11.8 allows attackers to cause a denial of service (memory consumption) by triggering object-initialization failures.", "other": {"cve": {"id": "CVE-2017-10810", "sourceIdentifier": "cve@mitre.org", "published": "2017-07-04T20:29:00.197", "lastModified": "2023-01-17T21:35:14.247", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Memory leak in the virtio_gpu_object_create function in drivers/gpu/drm/virtio/virtgpu_object.c in the Linux kernel through 4.11.8 allows attackers to cause a denial of service (memory consumption) by triggering object-initialization failures."}, {"lang": "es", "value": "Una fuga de memoria en la funci\u00f3n virtio_gpu_object_create en drivers/gpu/drm/virtio/virtgpu_object.c en el kernel de Linux hasta la versi\u00f3n 4.11.8 permite que atacantes provoquen una denegaci\u00f3n de servicio (consumo de memoria) desencadenando fallos de inicializaci\u00f3n de objetos."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-772"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2", "versionEndExcluding": "4.4.77", "matchCriteriaId": "F09881FD-5BBD-4E0F-88C0-C795EE420DC5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.37", "matchCriteriaId": "86853D2B-E143-47D3-9419-39AB1F0960D8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.11.10", "matchCriteriaId": "EE4EAA36-3647-4C48-8C52-857C95CAD243"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=385aee965b4e4c36551c362a334378d2985b722a", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.debian.org/security/2017/dsa-3927", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/99433", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/385aee965b4e4c36551c362a334378d2985b722a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lkml.org/lkml/2017/4/6/668", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/385aee965b4e4c36551c362a334378d2985b722a"}}