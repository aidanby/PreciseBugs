{"buggy_code": ["// Copyright (c) 2004-2013 Sergey Lyubka\n// Copyright (c) 2013-2022 Cesanta Software Limited\n// All rights reserved\n//\n// This software is dual-licensed: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License version 2 as\n// published by the Free Software Foundation. For the terms of this\n// license, see http://www.gnu.org/licenses/\n//\n// You are free to use this software under the terms of the GNU General\n// Public License, but WITHOUT ANY WARRANTY; without even the implied\n// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n// See the GNU General Public License for more details.\n//\n// Alternatively, you can license this software under a commercial\n// license, as set out in https://www.mongoose.ws/licensing/\n//\n// SPDX-License-Identifier: GPL-2.0-only or commercial\n\n#include \"mongoose.h\"\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/base64.c\"\n#endif\n\n\n\nstatic int mg_b64idx(int c) {\n  if (c < 26) {\n    return c + 'A';\n  } else if (c < 52) {\n    return c - 26 + 'a';\n  } else if (c < 62) {\n    return c - 52 + '0';\n  } else {\n    return c == 62 ? '+' : '/';\n  }\n}\n\nstatic int mg_b64rev(int c) {\n  if (c >= 'A' && c <= 'Z') {\n    return c - 'A';\n  } else if (c >= 'a' && c <= 'z') {\n    return c + 26 - 'a';\n  } else if (c >= '0' && c <= '9') {\n    return c + 52 - '0';\n  } else if (c == '+') {\n    return 62;\n  } else if (c == '/') {\n    return 63;\n  } else if (c == '=') {\n    return 64;\n  } else {\n    return -1;\n  }\n}\n\nint mg_base64_update(unsigned char ch, char *to, int n) {\n  int rem = (n & 3) % 3;\n  if (rem == 0) {\n    to[n] = (char) mg_b64idx(ch >> 2);\n    to[++n] = (char) ((ch & 3) << 4);\n  } else if (rem == 1) {\n    to[n] = (char) mg_b64idx(to[n] | (ch >> 4));\n    to[++n] = (char) ((ch & 15) << 2);\n  } else {\n    to[n] = (char) mg_b64idx(to[n] | (ch >> 6));\n    to[++n] = (char) mg_b64idx(ch & 63);\n    n++;\n  }\n  return n;\n}\n\nint mg_base64_final(char *to, int n) {\n  int saved = n;\n  // printf(\"---[%.*s]\\n\", n, to);\n  if (n & 3) n = mg_base64_update(0, to, n);\n  if ((saved & 3) == 2) n--;\n  // printf(\"    %d[%.*s]\\n\", n, n, to);\n  while (n & 3) to[n++] = '=';\n  to[n] = '\\0';\n  return n;\n}\n\nint mg_base64_encode(const unsigned char *p, int n, char *to) {\n  int i, len = 0;\n  for (i = 0; i < n; i++) len = mg_base64_update(p[i], to, len);\n  len = mg_base64_final(to, len);\n  return len;\n}\n\nint mg_base64_decode(const char *src, int n, char *dst) {\n  const char *end = src == NULL ? NULL : src + n;  // Cannot add to NULL\n  int len = 0;\n  while (src != NULL && src + 3 < end) {\n    int a = mg_b64rev(src[0]), b = mg_b64rev(src[1]), c = mg_b64rev(src[2]),\n        d = mg_b64rev(src[3]);\n    if (a == 64 || a < 0 || b == 64 || b < 0 || c < 0 || d < 0) return 0;\n    dst[len++] = (char) ((a << 2) | (b >> 4));\n    if (src[2] != '=') {\n      dst[len++] = (char) ((b << 4) | (c >> 2));\n      if (src[3] != '=') dst[len++] = (char) ((c << 6) | d);\n    }\n    src += 4;\n  }\n  dst[len] = '\\0';\n  return len;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/dns.c\"\n#endif\n\n\n\n\n\n\n\n\nstruct dns_data {\n  struct dns_data *next;\n  struct mg_connection *c;\n  uint64_t expire;\n  uint16_t txnid;\n};\n\nstatic void mg_sendnsreq(struct mg_connection *, struct mg_str *, int,\n                         struct mg_dns *, bool);\n\nstatic void mg_dns_free(struct mg_connection *c, struct dns_data *d) {\n  LIST_DELETE(struct dns_data,\n              (struct dns_data **) &c->mgr->active_dns_requests, d);\n  free(d);\n}\n\nvoid mg_resolve_cancel(struct mg_connection *c) {\n  struct dns_data *tmp, *d = (struct dns_data *) c->mgr->active_dns_requests;\n  for (; d != NULL; d = tmp) {\n    tmp = d->next;\n    if (d->c == c) mg_dns_free(c, d);\n  }\n}\n\nstatic size_t mg_dns_parse_name_depth(const uint8_t *s, size_t len, size_t ofs,\n                                      char *to, size_t tolen, size_t j,\n                                      int depth) {\n  size_t i = 0;\n  if (tolen > 0 && depth == 0) to[0] = '\\0';\n  if (depth > 5) return 0;\n  // MG_INFO((\"ofs %lx %x %x\", (unsigned long) ofs, s[ofs], s[ofs + 1]));\n  while (ofs + i + 1 < len) {\n    size_t n = s[ofs + i];\n    if (n == 0) {\n      i++;\n      break;\n    }\n    if (n & 0xc0) {\n      size_t ptr = (((n & 0x3f) << 8) | s[ofs + i + 1]);  // 12 is hdr len\n      // MG_INFO((\"PTR %lx\", (unsigned long) ptr));\n      if (ptr + 1 < len && (s[ptr] & 0xc0) == 0 &&\n          mg_dns_parse_name_depth(s, len, ptr, to, tolen, j, depth + 1) == 0)\n        return 0;\n      i += 2;\n      break;\n    }\n    if (ofs + i + n + 1 >= len) return 0;\n    if (j > 0) {\n      if (j < tolen) to[j] = '.';\n      j++;\n    }\n    if (j + n < tolen) memcpy(&to[j], &s[ofs + i + 1], n);\n    j += n;\n    i += n + 1;\n    if (j < tolen) to[j] = '\\0';  // Zero-terminate this chunk\n    // MG_INFO((\"--> [%s]\", to));\n  }\n  if (tolen > 0) to[tolen - 1] = '\\0';  // Make sure make sure it is nul-term\n  return i;\n}\n\nstatic size_t mg_dns_parse_name(const uint8_t *s, size_t n, size_t ofs,\n                                char *dst, size_t dstlen) {\n  return mg_dns_parse_name_depth(s, n, ofs, dst, dstlen, 0, 0);\n}\n\nsize_t mg_dns_parse_rr(const uint8_t *buf, size_t len, size_t ofs,\n                       bool is_question, struct mg_dns_rr *rr) {\n  const uint8_t *s = buf + ofs, *e = &buf[len];\n\n  memset(rr, 0, sizeof(*rr));\n  if (len < sizeof(struct mg_dns_header)) return 0;  // Too small\n  if (len > 512) return 0;  //  Too large, we don't expect that\n  if (s >= e) return 0;     //  Overflow\n\n  if ((rr->nlen = (uint16_t) mg_dns_parse_name(buf, len, ofs, NULL, 0)) == 0)\n    return 0;\n  s += rr->nlen + 4;\n  if (s > e) return 0;\n  rr->atype = (uint16_t) (((uint16_t) s[-4] << 8) | s[-3]);\n  rr->aclass = (uint16_t) (((uint16_t) s[-2] << 8) | s[-1]);\n  if (is_question) return (size_t) (rr->nlen + 4);\n\n  s += 6;\n  if (s > e) return 0;\n  rr->alen = (uint16_t) (((uint16_t) s[-2] << 8) | s[-1]);\n  if (s + rr->alen > e) return 0;\n  return (size_t) (rr->nlen + rr->alen + 10);\n}\n\nbool mg_dns_parse(const uint8_t *buf, size_t len, struct mg_dns_message *dm) {\n  const struct mg_dns_header *h = (struct mg_dns_header *) buf;\n  struct mg_dns_rr rr;\n  size_t i, n, ofs = sizeof(*h);\n  memset(dm, 0, sizeof(*dm));\n\n  if (len < sizeof(*h)) return 0;                // Too small, headers dont fit\n  if (mg_ntohs(h->num_questions) > 1) return 0;  // Sanity\n  if (mg_ntohs(h->num_answers) > 10) return 0;   // Sanity\n  dm->txnid = mg_ntohs(h->txnid);\n\n  for (i = 0; i < mg_ntohs(h->num_questions); i++) {\n    if ((n = mg_dns_parse_rr(buf, len, ofs, true, &rr)) == 0) return false;\n    // MG_INFO((\"Q %lu %lu %hu/%hu\", ofs, n, rr.atype, rr.aclass));\n    ofs += n;\n  }\n  for (i = 0; i < mg_ntohs(h->num_answers); i++) {\n    if ((n = mg_dns_parse_rr(buf, len, ofs, false, &rr)) == 0) return false;\n    // MG_INFO((\"A -- %lu %lu %hu/%hu %s\", ofs, n, rr.atype, rr.aclass,\n    // dm->name));\n    mg_dns_parse_name(buf, len, ofs, dm->name, sizeof(dm->name));\n    ofs += n;\n\n    if (rr.alen == 4 && rr.atype == 1 && rr.aclass == 1) {\n      dm->addr.is_ip6 = false;\n      memcpy(&dm->addr.ip, &buf[ofs - 4], 4);\n      dm->resolved = true;\n      break;  // Return success\n    } else if (rr.alen == 16 && rr.atype == 28 && rr.aclass == 1) {\n      dm->addr.is_ip6 = true;\n      memcpy(&dm->addr.ip6, &buf[ofs - 16], 16);\n      dm->resolved = true;\n      break;  // Return success\n    }\n  }\n  return true;\n}\n\nstatic void dns_cb(struct mg_connection *c, int ev, void *ev_data,\n                   void *fn_data) {\n  struct dns_data *d, *tmp;\n  if (ev == MG_EV_POLL) {\n    uint64_t now = *(uint64_t *) ev_data;\n    for (d = (struct dns_data *) c->mgr->active_dns_requests; d != NULL;\n         d = tmp) {\n      tmp = d->next;\n      // MG_DEBUG (\"%lu %lu dns poll\", d->expire, now));\n      if (now > d->expire) mg_error(d->c, \"DNS timeout\");\n    }\n  } else if (ev == MG_EV_READ) {\n    struct mg_dns_message dm;\n    int resolved = 0;\n    if (mg_dns_parse(c->recv.buf, c->recv.len, &dm) == false) {\n      MG_ERROR((\"Unexpected DNS response:\"));\n      mg_hexdump(c->recv.buf, c->recv.len);\n    } else {\n      // MG_VERBOSE((\"%s %d\", dm.name, dm.resolved));\n      for (d = (struct dns_data *) c->mgr->active_dns_requests; d != NULL;\n           d = tmp) {\n        tmp = d->next;\n        // MG_INFO((\"d %p %hu %hu\", d, d->txnid, dm.txnid));\n        if (dm.txnid != d->txnid) continue;\n        if (d->c->is_resolving) {\n          if (dm.resolved) {\n            dm.addr.port = d->c->rem.port;  // Save port\n            d->c->rem = dm.addr;            // Copy resolved address\n            MG_DEBUG(\n                (\"%lu %s is %M\", d->c->id, dm.name, mg_print_ip, &d->c->rem));\n            mg_connect_resolved(d->c);\n#if MG_ENABLE_IPV6\n          } else if (dm.addr.is_ip6 == false && dm.name[0] != '\\0' &&\n                     c->mgr->use_dns6 == false) {\n            struct mg_str x = mg_str(dm.name);\n            mg_sendnsreq(d->c, &x, c->mgr->dnstimeout, &c->mgr->dns6, true);\n#endif\n          } else {\n            mg_error(d->c, \"%s DNS lookup failed\", dm.name);\n          }\n        } else {\n          MG_ERROR((\"%lu already resolved\", d->c->id));\n        }\n        mg_dns_free(c, d);\n        resolved = 1;\n      }\n    }\n    if (!resolved) MG_ERROR((\"stray DNS reply\"));\n    c->recv.len = 0;\n  } else if (ev == MG_EV_CLOSE) {\n    for (d = (struct dns_data *) c->mgr->active_dns_requests; d != NULL;\n         d = tmp) {\n      tmp = d->next;\n      mg_error(d->c, \"DNS error\");\n      mg_dns_free(c, d);\n    }\n  }\n  (void) fn_data;\n}\n\nstatic bool mg_dns_send(struct mg_connection *c, const struct mg_str *name,\n                        uint16_t txnid, bool ipv6) {\n  struct {\n    struct mg_dns_header header;\n    uint8_t data[256];\n  } pkt;\n  size_t i, n;\n  memset(&pkt, 0, sizeof(pkt));\n  pkt.header.txnid = mg_htons(txnid);\n  pkt.header.flags = mg_htons(0x100);\n  pkt.header.num_questions = mg_htons(1);\n  for (i = n = 0; i < sizeof(pkt.data) - 5; i++) {\n    if (name->ptr[i] == '.' || i >= name->len) {\n      pkt.data[n] = (uint8_t) (i - n);\n      memcpy(&pkt.data[n + 1], name->ptr + n, i - n);\n      n = i + 1;\n    }\n    if (i >= name->len) break;\n  }\n  memcpy(&pkt.data[n], \"\\x00\\x00\\x01\\x00\\x01\", 5);  // A query\n  n += 5;\n  if (ipv6) pkt.data[n - 3] = 0x1c;  // AAAA query\n  // memcpy(&pkt.data[n], \"\\xc0\\x0c\\x00\\x1c\\x00\\x01\", 6);  // AAAA query\n  // n += 6;\n  return mg_send(c, &pkt, sizeof(pkt.header) + n);\n}\n\nstatic void mg_sendnsreq(struct mg_connection *c, struct mg_str *name, int ms,\n                         struct mg_dns *dnsc, bool ipv6) {\n  struct dns_data *d = NULL;\n  if (dnsc->url == NULL) {\n    mg_error(c, \"DNS server URL is NULL. Call mg_mgr_init()\");\n  } else if (dnsc->c == NULL) {\n    dnsc->c = mg_connect(c->mgr, dnsc->url, NULL, NULL);\n    if (dnsc->c != NULL) {\n      dnsc->c->pfn = dns_cb;\n      // dnsc->c->is_hexdumping = 1;\n    }\n  }\n  if (dnsc->c == NULL) {\n    mg_error(c, \"resolver\");\n  } else if ((d = (struct dns_data *) calloc(1, sizeof(*d))) == NULL) {\n    mg_error(c, \"resolve OOM\");\n  } else {\n    struct dns_data *reqs = (struct dns_data *) c->mgr->active_dns_requests;\n    d->txnid = reqs ? (uint16_t) (reqs->txnid + 1) : 1;\n    d->next = (struct dns_data *) c->mgr->active_dns_requests;\n    c->mgr->active_dns_requests = d;\n    d->expire = mg_millis() + (uint64_t) ms;\n    d->c = c;\n    c->is_resolving = 1;\n    MG_VERBOSE((\"%lu resolving %.*s @ %s, txnid %hu\", c->id, (int) name->len,\n                name->ptr, dnsc->url, d->txnid));\n    if (!mg_dns_send(dnsc->c, name, d->txnid, ipv6)) {\n      mg_error(dnsc->c, \"DNS send\");\n    }\n  }\n}\n\nvoid mg_resolve(struct mg_connection *c, const char *url) {\n  struct mg_str host = mg_url_host(url);\n  c->rem.port = mg_htons(mg_url_port(url));\n  if (mg_aton(host, &c->rem)) {\n    // host is an IP address, do not fire name resolution\n    mg_connect_resolved(c);\n  } else {\n    // host is not an IP, send DNS resolution request\n    struct mg_dns *dns = c->mgr->use_dns6 ? &c->mgr->dns6 : &c->mgr->dns4;\n    mg_sendnsreq(c, &host, c->mgr->dnstimeout, dns, c->mgr->use_dns6);\n  }\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/event.c\"\n#endif\n\n\n\n\n\nvoid mg_call(struct mg_connection *c, int ev, void *ev_data) {\n  // Run user-defined handler first, in order to give it an ability\n  // to intercept processing (e.g. clean input buffer) before the\n  // protocol handler kicks in\n  if (c->fn != NULL) c->fn(c, ev, ev_data, c->fn_data);\n  if (c->pfn != NULL) c->pfn(c, ev, ev_data, c->pfn_data);\n}\n\nvoid mg_error(struct mg_connection *c, const char *fmt, ...) {\n  char buf[64];\n  va_list ap;\n  va_start(ap, fmt);\n  mg_vsnprintf(buf, sizeof(buf), fmt, &ap);\n  va_end(ap);\n  MG_ERROR((\"%lu %p %s\", c->id, c->fd, buf));\n  c->is_closing = 1;             // Set is_closing before sending MG_EV_CALL\n  mg_call(c, MG_EV_ERROR, buf);  // Let user handler to override it\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/fmt.c\"\n#endif\n\n\n\n\nstatic bool is_digit(int c) {\n  return c >= '0' && c <= '9';\n}\n\nstatic int addexp(char *buf, int e, int sign) {\n  int n = 0;\n  buf[n++] = 'e';\n  buf[n++] = (char) sign;\n  if (e > 400) return 0;\n  if (e < 10) buf[n++] = '0';\n  if (e >= 100) buf[n++] = (char) (e / 100 + '0'), e -= 100 * (e / 100);\n  if (e >= 10) buf[n++] = (char) (e / 10 + '0'), e -= 10 * (e / 10);\n  buf[n++] = (char) (e + '0');\n  return n;\n}\n\nstatic int xisinf(double x) {\n  union {\n    double f;\n    uint64_t u;\n  } ieee754 = {x};\n  return ((unsigned) (ieee754.u >> 32) & 0x7fffffff) == 0x7ff00000 &&\n         ((unsigned) ieee754.u == 0);\n}\n\nstatic int xisnan(double x) {\n  union {\n    double f;\n    uint64_t u;\n  } ieee754 = {x};\n  return ((unsigned) (ieee754.u >> 32) & 0x7fffffff) +\n             ((unsigned) ieee754.u != 0) >\n         0x7ff00000;\n}\n\nstatic size_t mg_dtoa(char *dst, size_t dstlen, double d, int width, bool tz) {\n  char buf[40];\n  int i, s = 0, n = 0, e = 0;\n  double t, mul, saved;\n  if (d == 0.0) return mg_snprintf(dst, dstlen, \"%s\", \"0\");\n  if (xisinf(d)) return mg_snprintf(dst, dstlen, \"%s\", d > 0 ? \"inf\" : \"-inf\");\n  if (xisnan(d)) return mg_snprintf(dst, dstlen, \"%s\", \"nan\");\n  if (d < 0.0) d = -d, buf[s++] = '-';\n\n  // Round\n  saved = d;\n  mul = 1.0;\n  while (d >= 10.0 && d / mul >= 10.0) mul *= 10.0;\n  while (d <= 1.0 && d / mul <= 1.0) mul /= 10.0;\n  for (i = 0, t = mul * 5; i < width; i++) t /= 10.0;\n  d += t;\n  // Calculate exponent, and 'mul' for scientific representation\n  mul = 1.0;\n  while (d >= 10.0 && d / mul >= 10.0) mul *= 10.0, e++;\n  while (d < 1.0 && d / mul < 1.0) mul /= 10.0, e--;\n  // printf(\" --> %g %d %g %g\\n\", saved, e, t, mul);\n\n  if (e >= width && width > 1) {\n    n = (int) mg_dtoa(buf, sizeof(buf), saved / mul, width, tz);\n    // printf(\" --> %.*g %d [%.*s]\\n\", 10, d / t, e, n, buf);\n    n += addexp(buf + s + n, e, '+');\n    return mg_snprintf(dst, dstlen, \"%.*s\", n, buf);\n  } else if (e <= -width && width > 1) {\n    n = (int) mg_dtoa(buf, sizeof(buf), saved / mul, width, tz);\n    // printf(\" --> %.*g %d [%.*s]\\n\", 10, d / mul, e, n, buf);\n    n += addexp(buf + s + n, -e, '-');\n    return mg_snprintf(dst, dstlen, \"%.*s\", n, buf);\n  } else {\n    for (i = 0, t = mul; t >= 1.0 && s + n < (int) sizeof(buf); i++) {\n      int ch = (int) (d / t);\n      if (n > 0 || ch > 0) buf[s + n++] = (char) (ch + '0');\n      d -= ch * t;\n      t /= 10.0;\n    }\n    // printf(\" --> [%g] -> %g %g (%d) [%.*s]\\n\", saved, d, t, n, s + n, buf);\n    if (n == 0) buf[s++] = '0';\n    while (t >= 1.0 && n + s < (int) sizeof(buf)) buf[n++] = '0', t /= 10.0;\n    if (s + n < (int) sizeof(buf)) buf[n + s++] = '.';\n    // printf(\" 1--> [%g] -> [%.*s]\\n\", saved, s + n, buf);\n    for (i = 0, t = 0.1; s + n < (int) sizeof(buf) && n < width; i++) {\n      int ch = (int) (d / t);\n      buf[s + n++] = (char) (ch + '0');\n      d -= ch * t;\n      t /= 10.0;\n    }\n  }\n  while (tz && n > 0 && buf[s + n - 1] == '0') n--;  // Trim trailing zeroes\n  if (n > 0 && buf[s + n - 1] == '.') n--;           // Trim trailing dot\n  n += s;\n  if (n >= (int) sizeof(buf)) n = (int) sizeof(buf) - 1;\n  buf[n] = '\\0';\n  return mg_snprintf(dst, dstlen, \"%s\", buf);\n}\n\nstatic size_t mg_lld(char *buf, int64_t val, bool is_signed, bool is_hex) {\n  const char *letters = \"0123456789abcdef\";\n  uint64_t v = (uint64_t) val;\n  size_t s = 0, n, i;\n  if (is_signed && val < 0) buf[s++] = '-', v = (uint64_t) (-val);\n  // This loop prints a number in reverse order. I guess this is because we\n  // write numbers from right to left: least significant digit comes last.\n  // Maybe because we use Arabic numbers, and Arabs write RTL?\n  if (is_hex) {\n    for (n = 0; v; v >>= 4) buf[s + n++] = letters[v & 15];\n  } else {\n    for (n = 0; v; v /= 10) buf[s + n++] = letters[v % 10];\n  }\n  // Reverse a string\n  for (i = 0; i < n / 2; i++) {\n    char t = buf[s + i];\n    buf[s + i] = buf[s + n - i - 1], buf[s + n - i - 1] = t;\n  }\n  if (val == 0) buf[n++] = '0';  // Handle special case\n  return n + s;\n}\n\nstatic size_t scpy(void (*out)(char, void *), void *ptr, char *buf,\n                          size_t len) {\n  size_t i = 0;\n  while (i < len && buf[i] != '\\0') out(buf[i++], ptr);\n  return i;\n}\n\nsize_t mg_xprintf(void (*out)(char, void *), void *ptr, const char *fmt, ...) {\n  size_t len = 0;\n  va_list ap;\n  va_start(ap, fmt);\n  len = mg_vxprintf(out, ptr, fmt, &ap);\n  va_end(ap);\n  return len;\n}\n\nsize_t mg_vxprintf(void (*out)(char, void *), void *param, const char *fmt,\n                   va_list *ap) {\n  size_t i = 0, n = 0;\n  while (fmt[i] != '\\0') {\n    if (fmt[i] == '%') {\n      size_t j, k, x = 0, is_long = 0, w = 0 /* width */, pr = ~0U /* prec */;\n      char pad = ' ', minus = 0, c = fmt[++i];\n      if (c == '#') x++, c = fmt[++i];\n      if (c == '-') minus++, c = fmt[++i];\n      if (c == '0') pad = '0', c = fmt[++i];\n      while (is_digit(c)) w *= 10, w += (size_t) (c - '0'), c = fmt[++i];\n      if (c == '.') {\n        c = fmt[++i];\n        if (c == '*') {\n          pr = (size_t) va_arg(*ap, int);\n          c = fmt[++i];\n        } else {\n          pr = 0;\n          while (is_digit(c)) pr *= 10, pr += (size_t) (c - '0'), c = fmt[++i];\n        }\n      }\n      while (c == 'h') c = fmt[++i];  // Treat h and hh as int\n      if (c == 'l') {\n        is_long++, c = fmt[++i];\n        if (c == 'l') is_long++, c = fmt[++i];\n      }\n      if (c == 'p') x = 1, is_long = 1;\n      if (c == 'd' || c == 'u' || c == 'x' || c == 'X' || c == 'p' ||\n          c == 'g' || c == 'f') {\n        bool s = (c == 'd'), h = (c == 'x' || c == 'X' || c == 'p');\n        char tmp[40];\n        size_t xl = x ? 2 : 0;\n        if (c == 'g' || c == 'f') {\n          double v = va_arg(*ap, double);\n          if (pr == ~0U) pr = 6;\n          k = mg_dtoa(tmp, sizeof(tmp), v, (int) pr, c == 'g');\n        } else if (is_long == 2) {\n          int64_t v = va_arg(*ap, int64_t);\n          k = mg_lld(tmp, v, s, h);\n        } else if (is_long == 1) {\n          long v = va_arg(*ap, long);\n          k = mg_lld(tmp, s ? (int64_t) v : (int64_t) (unsigned long) v, s, h);\n        } else {\n          int v = va_arg(*ap, int);\n          k = mg_lld(tmp, s ? (int64_t) v : (int64_t) (unsigned) v, s, h);\n        }\n        for (j = 0; j < xl && w > 0; j++) w--;\n        for (j = 0; pad == ' ' && !minus && k < w && j + k < w; j++)\n          n += scpy(out, param, &pad, 1);\n        n += scpy(out, param, (char *) \"0x\", xl);\n        for (j = 0; pad == '0' && k < w && j + k < w; j++)\n          n += scpy(out, param, &pad, 1);\n        n += scpy(out, param, tmp, k);\n        for (j = 0; pad == ' ' && minus && k < w && j + k < w; j++)\n          n += scpy(out, param, &pad, 1);\n      } else if (c == 'm' || c == 'M') {\n        mg_pm_t f = va_arg(*ap, mg_pm_t);\n        if (c == 'm') out('\"', param);\n        n += f(out, param, ap);\n        if (c == 'm') n += 2, out('\"', param);\n      } else if (c == 'c') {\n        int ch = va_arg(*ap, int);\n        out((char) ch, param);\n        n++;\n      } else if (c == 's') {\n        char *p = va_arg(*ap, char *);\n        if (pr == ~0U) pr = p == NULL ? 0 : strlen(p);\n        for (j = 0; !minus && pr < w && j + pr < w; j++)\n          n += scpy(out, param, &pad, 1);\n        n += scpy(out, param, p, pr);\n        for (j = 0; minus && pr < w && j + pr < w; j++)\n          n += scpy(out, param, &pad, 1);\n      } else if (c == '%') {\n        out('%', param);\n        n++;\n      } else {\n        out('%', param);\n        out(c, param);\n        n += 2;\n      }\n      i++;\n    } else {\n      out(fmt[i], param), n++, i++;\n    }\n  }\n  return n;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/fs.c\"\n#endif\n\n\n\nstruct mg_fd *mg_fs_open(struct mg_fs *fs, const char *path, int flags) {\n  struct mg_fd *fd = (struct mg_fd *) calloc(1, sizeof(*fd));\n  if (fd != NULL) {\n    fd->fd = fs->op(path, flags);\n    fd->fs = fs;\n    if (fd->fd == NULL) {\n      free(fd);\n      fd = NULL;\n    }\n  }\n  return fd;\n}\n\nvoid mg_fs_close(struct mg_fd *fd) {\n  if (fd != NULL) {\n    fd->fs->cl(fd->fd);\n    free(fd);\n  }\n}\n\nchar *mg_file_read(struct mg_fs *fs, const char *path, size_t *sizep) {\n  struct mg_fd *fd;\n  char *data = NULL;\n  size_t size = 0;\n  fs->st(path, &size, NULL);\n  if ((fd = mg_fs_open(fs, path, MG_FS_READ)) != NULL) {\n    data = (char *) calloc(1, size + 1);\n    if (data != NULL) {\n      if (fs->rd(fd->fd, data, size) != size) {\n        free(data);\n        data = NULL;\n      } else {\n        data[size] = '\\0';\n        if (sizep != NULL) *sizep = size;\n      }\n    }\n    mg_fs_close(fd);\n  }\n  return data;\n}\n\nbool mg_file_write(struct mg_fs *fs, const char *path, const void *buf,\n                   size_t len) {\n  bool result = false;\n  struct mg_fd *fd;\n  char tmp[MG_PATH_MAX];\n  mg_snprintf(tmp, sizeof(tmp), \"%s..%d\", path, rand());\n  if ((fd = mg_fs_open(fs, tmp, MG_FS_WRITE)) != NULL) {\n    result = fs->wr(fd->fd, buf, len) == len;\n    mg_fs_close(fd);\n    if (result) {\n      fs->rm(path);\n      fs->mv(tmp, path);\n    } else {\n      fs->rm(tmp);\n    }\n  }\n  return result;\n}\n\nbool mg_file_printf(struct mg_fs *fs, const char *path, const char *fmt, ...) {\n  va_list ap;\n  char *data;\n  bool result = false;\n  va_start(ap, fmt);\n  data = mg_vmprintf(fmt, &ap);\n  va_end(ap);\n  result = mg_file_write(fs, path, data, strlen(data));\n  free(data);\n  return result;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/fs_fat.c\"\n#endif\n\n\n\n#if MG_ENABLE_FATFS\n#include <ff.h>\n\nstatic int mg_days_from_epoch(int y, int m, int d) {\n  y -= m <= 2;\n  int era = y / 400;\n  int yoe = y - era * 400;\n  int doy = (153 * (m + (m > 2 ? -3 : 9)) + 2) / 5 + d - 1;\n  int doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;\n  return era * 146097 + doe - 719468;\n}\n\nstatic time_t mg_timegm(const struct tm *t) {\n  int year = t->tm_year + 1900;\n  int month = t->tm_mon;  // 0-11\n  if (month > 11) {\n    year += month / 12;\n    month %= 12;\n  } else if (month < 0) {\n    int years_diff = (11 - month) / 12;\n    year -= years_diff;\n    month += 12 * years_diff;\n  }\n  int x = mg_days_from_epoch(year, month + 1, t->tm_mday);\n  return 60 * (60 * (24L * x + t->tm_hour) + t->tm_min) + t->tm_sec;\n}\n\nstatic time_t ff_time_to_epoch(uint16_t fdate, uint16_t ftime) {\n  struct tm tm;\n  memset(&tm, 0, sizeof(struct tm));\n  tm.tm_sec = (ftime << 1) & 0x3e;\n  tm.tm_min = ((ftime >> 5) & 0x3f);\n  tm.tm_hour = ((ftime >> 11) & 0x1f);\n  tm.tm_mday = (fdate & 0x1f);\n  tm.tm_mon = ((fdate >> 5) & 0x0f) - 1;\n  tm.tm_year = ((fdate >> 9) & 0x7f) + 80;\n  return mg_timegm(&tm);\n}\n\nstatic int ff_stat(const char *path, size_t *size, time_t *mtime) {\n  FILINFO fi;\n  if (path[0] == '\\0') {\n    if (size) *size = 0;\n    if (mtime) *mtime = 0;\n    return MG_FS_DIR;\n  } else if (f_stat(path, &fi) == 0) {\n    if (size) *size = (size_t) fi.fsize;\n    if (mtime) *mtime = ff_time_to_epoch(fi.fdate, fi.ftime);\n    return MG_FS_READ | MG_FS_WRITE | ((fi.fattrib & AM_DIR) ? MG_FS_DIR : 0);\n  } else {\n    return 0;\n  }\n}\n\nstatic void ff_list(const char *dir, void (*fn)(const char *, void *),\n                    void *userdata) {\n  DIR d;\n  FILINFO fi;\n  if (f_opendir(&d, dir) == FR_OK) {\n    while (f_readdir(&d, &fi) == FR_OK && fi.fname[0] != '\\0') {\n      if (!strcmp(fi.fname, \".\") || !strcmp(fi.fname, \"..\")) continue;\n      fn(fi.fname, userdata);\n    }\n    f_closedir(&d);\n  }\n}\n\nstatic void *ff_open(const char *path, int flags) {\n  FIL f;\n  unsigned char mode = FA_READ;\n  if (flags & MG_FS_WRITE) mode |= FA_WRITE | FA_OPEN_ALWAYS | FA_OPEN_APPEND;\n  if (f_open(&f, path, mode) == 0) {\n    FIL *fp;\n    if ((fp = calloc(1, sizeof(*fp))) != NULL) {\n      memcpy(fp, &f, sizeof(*fp));\n      return fp;\n    }\n  }\n  return NULL;\n}\n\nstatic void ff_close(void *fp) {\n  if (fp != NULL) {\n    f_close((FIL *) fp);\n    free(fp);\n  }\n}\n\nstatic size_t ff_read(void *fp, void *buf, size_t len) {\n  UINT n = 0, misalign = ((size_t) buf) & 3;\n  if (misalign) {\n    char aligned[4];\n    f_read((FIL *) fp, aligned, len > misalign ? misalign : len, &n);\n    memcpy(buf, aligned, n);\n  } else {\n    f_read((FIL *) fp, buf, len, &n);\n  }\n  return n;\n}\n\nstatic size_t ff_write(void *fp, const void *buf, size_t len) {\n  UINT n = 0;\n  return f_write((FIL *) fp, (char *) buf, len, &n) == FR_OK ? n : 0;\n}\n\nstatic size_t ff_seek(void *fp, size_t offset) {\n  f_lseek((FIL *) fp, offset);\n  return offset;\n}\n\nstatic bool ff_rename(const char *from, const char *to) {\n  return f_rename(from, to) == FR_OK;\n}\n\nstatic bool ff_remove(const char *path) {\n  return f_unlink(path) == FR_OK;\n}\n\nstatic bool ff_mkdir(const char *path) {\n  return f_mkdir(path) == FR_OK;\n}\n\nstruct mg_fs mg_fs_fat = {ff_stat,  ff_list, ff_open,   ff_close,  ff_read,\n                          ff_write, ff_seek, ff_rename, ff_remove, ff_mkdir};\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/fs_packed.c\"\n#endif\n\n\n\n\nstruct packed_file {\n  const char *data;\n  size_t size;\n  size_t pos;\n};\n\nconst char *mg_unpack(const char *path, size_t *size, time_t *mtime);\nconst char *mg_unlist(size_t no);\n\n#if MG_ENABLE_PACKED_FS\n#else\nconst char *mg_unpack(const char *path, size_t *size, time_t *mtime) {\n  (void) path, (void) size, (void) mtime;\n  return NULL;\n}\nconst char *mg_unlist(size_t no) {\n  (void) no;\n  return NULL;\n}\n#endif\n\nstatic int is_dir_prefix(const char *prefix, size_t n, const char *path) {\n  // MG_INFO((\"[%.*s] [%s] %c\", (int) n, prefix, path, path[n]));\n  return n < strlen(path) && strncmp(prefix, path, n) == 0 &&\n         (n == 0 || path[n] == '/' || path[n - 1] == '/');\n}\n\nstatic int packed_stat(const char *path, size_t *size, time_t *mtime) {\n  const char *p;\n  size_t i, n = strlen(path);\n  if (mg_unpack(path, size, mtime)) return MG_FS_READ;  // Regular file\n  // Scan all files. If `path` is a dir prefix for any of them, it's a dir\n  for (i = 0; (p = mg_unlist(i)) != NULL; i++) {\n    if (is_dir_prefix(path, n, p)) return MG_FS_DIR;\n  }\n  return 0;\n}\n\nstatic void packed_list(const char *dir, void (*fn)(const char *, void *),\n                        void *userdata) {\n  char buf[MG_PATH_MAX], tmp[sizeof(buf)];\n  const char *path, *begin, *end;\n  size_t i, n = strlen(dir);\n  tmp[0] = '\\0';  // Previously listed entry\n  for (i = 0; (path = mg_unlist(i)) != NULL; i++) {\n    if (!is_dir_prefix(dir, n, path)) continue;\n    begin = &path[n + 1];\n    end = strchr(begin, '/');\n    if (end == NULL) end = begin + strlen(begin);\n    mg_snprintf(buf, sizeof(buf), \"%.*s\", (int) (end - begin), begin);\n    buf[sizeof(buf) - 1] = '\\0';\n    // If this entry has been already listed, skip\n    // NOTE: we're assuming that file list is sorted alphabetically\n    if (strcmp(buf, tmp) == 0) continue;\n    fn(buf, userdata);  // Not yet listed, call user function\n    strcpy(tmp, buf);   // And save this entry as listed\n  }\n}\n\nstatic void *packed_open(const char *path, int flags) {\n  size_t size = 0;\n  const char *data = mg_unpack(path, &size, NULL);\n  struct packed_file *fp = NULL;\n  if (data == NULL) return NULL;\n  if (flags & MG_FS_WRITE) return NULL;\n  if ((fp = (struct packed_file *) calloc(1, sizeof(*fp))) != NULL) {\n    fp->size = size;\n    fp->data = data;\n  }\n  return (void *) fp;\n}\n\nstatic void packed_close(void *fp) {\n  if (fp != NULL) free(fp);\n}\n\nstatic size_t packed_read(void *fd, void *buf, size_t len) {\n  struct packed_file *fp = (struct packed_file *) fd;\n  if (fp->pos + len > fp->size) len = fp->size - fp->pos;\n  memcpy(buf, &fp->data[fp->pos], len);\n  fp->pos += len;\n  return len;\n}\n\nstatic size_t packed_write(void *fd, const void *buf, size_t len) {\n  (void) fd, (void) buf, (void) len;\n  return 0;\n}\n\nstatic size_t packed_seek(void *fd, size_t offset) {\n  struct packed_file *fp = (struct packed_file *) fd;\n  fp->pos = offset;\n  if (fp->pos > fp->size) fp->pos = fp->size;\n  return fp->pos;\n}\n\nstatic bool packed_rename(const char *from, const char *to) {\n  (void) from, (void) to;\n  return false;\n}\n\nstatic bool packed_remove(const char *path) {\n  (void) path;\n  return false;\n}\n\nstatic bool packed_mkdir(const char *path) {\n  (void) path;\n  return false;\n}\n\nstruct mg_fs mg_fs_packed = {\n    packed_stat,  packed_list, packed_open,   packed_close,  packed_read,\n    packed_write, packed_seek, packed_rename, packed_remove, packed_mkdir};\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/fs_posix.c\"\n#endif\n\n\n#if MG_ENABLE_FILE\n\n#ifndef MG_STAT_STRUCT\n#define MG_STAT_STRUCT stat\n#endif\n\n#ifndef MG_STAT_FUNC\n#define MG_STAT_FUNC stat\n#endif\n\nstatic int p_stat(const char *path, size_t *size, time_t *mtime) {\n#if !defined(S_ISDIR)\n  MG_ERROR((\"stat() API is not supported. %p %p %p\", path, size, mtime));\n  return 0;\n#else\n#if MG_ARCH == MG_ARCH_WIN32\n  struct _stati64 st;\n  wchar_t tmp[MG_PATH_MAX];\n  MultiByteToWideChar(CP_UTF8, 0, path, -1, tmp, sizeof(tmp) / sizeof(tmp[0]));\n  if (_wstati64(tmp, &st) != 0) return 0;\n  // If path is a symlink, windows reports 0 in st.st_size.\n  // Get a real file size by opening it and jumping to the end\n  if (st.st_size == 0 && (st.st_mode & _S_IFREG)) {\n    FILE *fp = _wfopen(tmp, L\"rb\");\n    if (fp != NULL) {\n      fseek(fp, 0, SEEK_END);\n      if (ftell(fp) > 0) st.st_size = ftell(fp); // Use _ftelli64 on win10+\n      fclose(fp);\n    }\n  }\n#else\n  struct MG_STAT_STRUCT st;\n  if (MG_STAT_FUNC(path, &st) != 0) return 0;\n#endif\n  if (size) *size = (size_t) st.st_size;\n  if (mtime) *mtime = st.st_mtime;\n  return MG_FS_READ | MG_FS_WRITE | (S_ISDIR(st.st_mode) ? MG_FS_DIR : 0);\n#endif\n}\n\n#if MG_ARCH == MG_ARCH_WIN32\nstruct dirent {\n  char d_name[MAX_PATH];\n};\n\ntypedef struct win32_dir {\n  HANDLE handle;\n  WIN32_FIND_DATAW info;\n  struct dirent result;\n} DIR;\n\nint gettimeofday(struct timeval *tv, void *tz) {\n  FILETIME ft;\n  unsigned __int64 tmpres = 0;\n\n  if (tv != NULL) {\n    GetSystemTimeAsFileTime(&ft);\n    tmpres |= ft.dwHighDateTime;\n    tmpres <<= 32;\n    tmpres |= ft.dwLowDateTime;\n    tmpres /= 10;  // convert into microseconds\n    tmpres -= (int64_t) 11644473600000000;\n    tv->tv_sec = (long) (tmpres / 1000000UL);\n    tv->tv_usec = (long) (tmpres % 1000000UL);\n  }\n  (void) tz;\n  return 0;\n}\n\nstatic int to_wchar(const char *path, wchar_t *wbuf, size_t wbuf_len) {\n  int ret;\n  char buf[MAX_PATH * 2], buf2[MAX_PATH * 2], *p;\n  strncpy(buf, path, sizeof(buf));\n  buf[sizeof(buf) - 1] = '\\0';\n  // Trim trailing slashes. Leave backslash for paths like \"X:\\\"\n  p = buf + strlen(buf) - 1;\n  while (p > buf && p[-1] != ':' && (p[0] == '\\\\' || p[0] == '/')) *p-- = '\\0';\n  memset(wbuf, 0, wbuf_len * sizeof(wchar_t));\n  ret = MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int) wbuf_len);\n  // Convert back to Unicode. If doubly-converted string does not match the\n  // original, something is fishy, reject.\n  WideCharToMultiByte(CP_UTF8, 0, wbuf, (int) wbuf_len, buf2, sizeof(buf2),\n                      NULL, NULL);\n  if (strcmp(buf, buf2) != 0) {\n    wbuf[0] = L'\\0';\n    ret = 0;\n  }\n  return ret;\n}\n\nDIR *opendir(const char *name) {\n  DIR *d = NULL;\n  wchar_t wpath[MAX_PATH];\n  DWORD attrs;\n\n  if (name == NULL) {\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  } else if ((d = (DIR *) calloc(1, sizeof(*d))) == NULL) {\n    SetLastError(ERROR_NOT_ENOUGH_MEMORY);\n  } else {\n    to_wchar(name, wpath, sizeof(wpath) / sizeof(wpath[0]));\n    attrs = GetFileAttributesW(wpath);\n    if (attrs != 0Xffffffff && (attrs & FILE_ATTRIBUTE_DIRECTORY)) {\n      (void) wcscat(wpath, L\"\\\\*\");\n      d->handle = FindFirstFileW(wpath, &d->info);\n      d->result.d_name[0] = '\\0';\n    } else {\n      free(d);\n      d = NULL;\n    }\n  }\n  return d;\n}\n\nint closedir(DIR *d) {\n  int result = 0;\n  if (d != NULL) {\n    if (d->handle != INVALID_HANDLE_VALUE)\n      result = FindClose(d->handle) ? 0 : -1;\n    free(d);\n  } else {\n    result = -1;\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  }\n  return result;\n}\n\nstruct dirent *readdir(DIR *d) {\n  struct dirent *result = NULL;\n  if (d != NULL) {\n    memset(&d->result, 0, sizeof(d->result));\n    if (d->handle != INVALID_HANDLE_VALUE) {\n      result = &d->result;\n      WideCharToMultiByte(CP_UTF8, 0, d->info.cFileName, -1, result->d_name,\n                          sizeof(result->d_name), NULL, NULL);\n      if (!FindNextFileW(d->handle, &d->info)) {\n        FindClose(d->handle);\n        d->handle = INVALID_HANDLE_VALUE;\n      }\n    } else {\n      SetLastError(ERROR_FILE_NOT_FOUND);\n    }\n  } else {\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  }\n  return result;\n}\n#endif\n\nstatic void p_list(const char *dir, void (*fn)(const char *, void *),\n                   void *userdata) {\n#if MG_ENABLE_DIRLIST\n  struct dirent *dp;\n  DIR *dirp;\n  if ((dirp = (opendir(dir))) == NULL) return;\n  while ((dp = readdir(dirp)) != NULL) {\n    if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) continue;\n    fn(dp->d_name, userdata);\n  }\n  closedir(dirp);\n#else\n  (void) dir, (void) fn, (void) userdata;\n#endif\n}\n\nstatic void *p_open(const char *path, int flags) {\n  const char *mode = flags == MG_FS_READ ? \"rb\" : \"a+b\";\n#if MG_ARCH == MG_ARCH_WIN32\n  wchar_t b1[MG_PATH_MAX], b2[10];\n  MultiByteToWideChar(CP_UTF8, 0, path, -1, b1, sizeof(b1) / sizeof(b1[0]));\n  MultiByteToWideChar(CP_UTF8, 0, mode, -1, b2, sizeof(b2) / sizeof(b2[0]));\n  return (void *) _wfopen(b1, b2);\n#else\n  return (void *) fopen(path, mode);\n#endif\n}\n\nstatic void p_close(void *fp) {\n  fclose((FILE *) fp);\n}\n\nstatic size_t p_read(void *fp, void *buf, size_t len) {\n  return fread(buf, 1, len, (FILE *) fp);\n}\n\nstatic size_t p_write(void *fp, const void *buf, size_t len) {\n  return fwrite(buf, 1, len, (FILE *) fp);\n}\n\nstatic size_t p_seek(void *fp, size_t offset) {\n#if (defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS == 64) ||  \\\n    (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 200112L) || \\\n    (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE >= 600)\n  if (fseeko((FILE *) fp, (off_t) offset, SEEK_SET) != 0) (void) 0;\n#else\n  if (fseek((FILE *) fp, (long) offset, SEEK_SET) != 0) (void) 0;\n#endif\n  return (size_t) ftell((FILE *) fp);\n}\n\nstatic bool p_rename(const char *from, const char *to) {\n  return rename(from, to) == 0;\n}\n\nstatic bool p_remove(const char *path) {\n  return remove(path) == 0;\n}\n\nstatic bool p_mkdir(const char *path) {\n  return mkdir(path, 0775) == 0;\n}\n\n#else\n\nstatic int p_stat(const char *path, size_t *size, time_t *mtime) {\n  (void) path, (void) size, (void) mtime;\n  return 0;\n}\nstatic void p_list(const char *path, void (*fn)(const char *, void *),\n                   void *userdata) {\n  (void) path, (void) fn, (void) userdata;\n}\nstatic void *p_open(const char *path, int flags) {\n  (void) path, (void) flags;\n  return NULL;\n}\nstatic void p_close(void *fp) {\n  (void) fp;\n}\nstatic size_t p_read(void *fd, void *buf, size_t len) {\n  (void) fd, (void) buf, (void) len;\n  return 0;\n}\nstatic size_t p_write(void *fd, const void *buf, size_t len) {\n  (void) fd, (void) buf, (void) len;\n  return 0;\n}\nstatic size_t p_seek(void *fd, size_t offset) {\n  (void) fd, (void) offset;\n  return (size_t) ~0;\n}\nstatic bool p_rename(const char *from, const char *to) {\n  (void) from, (void) to;\n  return false;\n}\nstatic bool p_remove(const char *path) {\n  (void) path;\n  return false;\n}\nstatic bool p_mkdir(const char *path) {\n  (void) path;\n  return false;\n}\n#endif\n\nstruct mg_fs mg_fs_posix = {p_stat,  p_list, p_open,   p_close,  p_read,\n                            p_write, p_seek, p_rename, p_remove, p_mkdir};\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/http.c\"\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Chunk deletion marker is the MSB in the \"processed\" counter\n#define MG_DMARK ((size_t) 1 << (sizeof(size_t) * 8 - 1))\n\n// Multipart POST example:\n// --xyz\n// Content-Disposition: form-data; name=\"val\"\n//\n// abcdef\n// --xyz\n// Content-Disposition: form-data; name=\"foo\"; filename=\"a.txt\"\n// Content-Type: text/plain\n//\n// hello world\n//\n// --xyz--\nsize_t mg_http_next_multipart(struct mg_str body, size_t ofs,\n                              struct mg_http_part *part) {\n  struct mg_str cd = mg_str_n(\"Content-Disposition\", 19);\n  const char *s = body.ptr;\n  size_t b = ofs, h1, h2, b1, b2, max = body.len;\n\n  // Init part params\n  if (part != NULL) part->name = part->filename = part->body = mg_str_n(0, 0);\n\n  // Skip boundary\n  while (b + 2 < max && s[b] != '\\r' && s[b + 1] != '\\n') b++;\n  if (b <= ofs || b + 2 >= max) return 0;\n  // MG_INFO((\"B: %zu %zu [%.*s]\", ofs, b - ofs, (int) (b - ofs), s));\n\n  // Skip headers\n  h1 = h2 = b + 2;\n  for (;;) {\n    while (h2 + 2 < max && s[h2] != '\\r' && s[h2 + 1] != '\\n') h2++;\n    if (h2 == h1) break;\n    if (h2 + 2 >= max) return 0;\n    // MG_INFO((\"Header: [%.*s]\", (int) (h2 - h1), &s[h1]));\n    if (part != NULL && h1 + cd.len + 2 < h2 && s[h1 + cd.len] == ':' &&\n        mg_ncasecmp(&s[h1], cd.ptr, cd.len) == 0) {\n      struct mg_str v = mg_str_n(&s[h1 + cd.len + 2], h2 - (h1 + cd.len + 2));\n      part->name = mg_http_get_header_var(v, mg_str_n(\"name\", 4));\n      part->filename = mg_http_get_header_var(v, mg_str_n(\"filename\", 8));\n    }\n    h1 = h2 = h2 + 2;\n  }\n  b1 = b2 = h2 + 2;\n  while (b2 + 2 + (b - ofs) + 2 < max && !(s[b2] == '\\r' && s[b2 + 1] == '\\n' &&\n                                           memcmp(&s[b2 + 2], s, b - ofs) == 0))\n    b2++;\n\n  if (b2 + 2 >= max) return 0;\n  if (part != NULL) part->body = mg_str_n(&s[b1], b2 - b1);\n  // MG_INFO((\"Body: [%.*s]\", (int) (b2 - b1), &s[b1]));\n  return b2 + 2;\n}\n\nvoid mg_http_bauth(struct mg_connection *c, const char *user,\n                   const char *pass) {\n  struct mg_str u = mg_str(user), p = mg_str(pass);\n  size_t need = c->send.len + 36 + (u.len + p.len) * 2;\n  if (c->send.size < need) mg_iobuf_resize(&c->send, need);\n  if (c->send.size >= need) {\n    int i, n = 0;\n    char *buf = (char *) &c->send.buf[c->send.len];\n    memcpy(buf, \"Authorization: Basic \", 21);  // DON'T use mg_send!\n    for (i = 0; i < (int) u.len; i++) {\n      n = mg_base64_update(((unsigned char *) u.ptr)[i], buf + 21, n);\n    }\n    if (p.len > 0) {\n      n = mg_base64_update(':', buf + 21, n);\n      for (i = 0; i < (int) p.len; i++) {\n        n = mg_base64_update(((unsigned char *) p.ptr)[i], buf + 21, n);\n      }\n    }\n    n = mg_base64_final(buf + 21, n);\n    c->send.len += 21 + (size_t) n + 2;\n    memcpy(&c->send.buf[c->send.len - 2], \"\\r\\n\", 2);\n  } else {\n    MG_ERROR((\"%lu oom %d->%d \", c->id, (int) c->send.size, (int) need));\n  }\n}\n\nstruct mg_str mg_http_var(struct mg_str buf, struct mg_str name) {\n  struct mg_str k, v, result = mg_str_n(NULL, 0);\n  while (mg_split(&buf, &k, &v, '&')) {\n    if (name.len == k.len && mg_ncasecmp(name.ptr, k.ptr, k.len) == 0) {\n      result = v;\n      break;\n    }\n  }\n  return result;\n}\n\nint mg_http_get_var(const struct mg_str *buf, const char *name, char *dst,\n                    size_t dst_len) {\n  int len;\n  if (dst == NULL || dst_len == 0) {\n    len = -2;  // Bad destination\n  } else if (buf->ptr == NULL || name == NULL || buf->len == 0) {\n    len = -1;  // Bad source\n    dst[0] = '\\0';\n  } else {\n    struct mg_str v = mg_http_var(*buf, mg_str(name));\n    if (v.ptr == NULL) {\n      len = -4;  // Name does not exist\n    } else {\n      len = mg_url_decode(v.ptr, v.len, dst, dst_len, 1);\n      if (len < 0) len = -3;  // Failed to decode\n    }\n  }\n  return len;\n}\n\nstatic bool isx(int c) {\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||\n         (c >= 'A' && c <= 'F');\n}\n\nint mg_url_decode(const char *src, size_t src_len, char *dst, size_t dst_len,\n                  int is_form_url_encoded) {\n  size_t i, j;\n  for (i = j = 0; i < src_len && j + 1 < dst_len; i++, j++) {\n    if (src[i] == '%') {\n      // Use `i + 2 < src_len`, not `i < src_len - 2`, note small src_len\n      if (i + 2 < src_len && isx(src[i + 1]) && isx(src[i + 2])) {\n        mg_unhex(src + i + 1, 2, (uint8_t *) &dst[j]);\n        i += 2;\n      } else {\n        return -1;\n      }\n    } else if (is_form_url_encoded && src[i] == '+') {\n      dst[j] = ' ';\n    } else {\n      dst[j] = src[i];\n    }\n  }\n  if (j < dst_len) dst[j] = '\\0';  // Null-terminate the destination\n  return i >= src_len && j < dst_len ? (int) j : -1;\n}\n\nstatic bool isok(uint8_t c) { return c == '\\n' || c == '\\r' || c >= ' '; }\n\nint mg_http_get_request_len(const unsigned char *buf, size_t buf_len) {\n  size_t i;\n  for (i = 0; i < buf_len; i++) {\n    if (!isok(buf[i])) return -1;\n    if ((i > 0 && buf[i] == '\\n' && buf[i - 1] == '\\n') ||\n        (i > 3 && buf[i] == '\\n' && buf[i - 1] == '\\r' && buf[i - 2] == '\\n'))\n      return (int) i + 1;\n  }\n  return 0;\n}\n\nstatic const char *skip(const char *s, const char *e, const char *d,\n                        struct mg_str *v) {\n  v->ptr = s;\n  while (s < e && *s != '\\n' && strchr(d, *s) == NULL) s++;\n  v->len = (size_t) (s - v->ptr);\n  while (s < e && strchr(d, *s) != NULL) s++;\n  return s;\n}\n\nstruct mg_str *mg_http_get_header(struct mg_http_message *h, const char *name) {\n  size_t i, n = strlen(name), max = sizeof(h->headers) / sizeof(h->headers[0]);\n  for (i = 0; i < max && h->headers[i].name.len > 0; i++) {\n    struct mg_str *k = &h->headers[i].name, *v = &h->headers[i].value;\n    if (n == k->len && mg_ncasecmp(k->ptr, name, n) == 0) return v;\n  }\n  return NULL;\n}\n\nstatic void mg_http_parse_headers(const char *s, const char *end,\n                                  struct mg_http_header *h, int max_headers) {\n  int i;\n  for (i = 0; i < max_headers; i++) {\n    struct mg_str k, v, tmp;\n    const char *he = skip(s, end, \"\\n\", &tmp);\n    s = skip(s, he, \": \\r\\n\", &k);\n    s = skip(s, he, \"\\r\\n\", &v);\n    if (k.len == tmp.len) continue;\n    while (v.len > 0 && v.ptr[v.len - 1] == ' ') v.len--;  // Trim spaces\n    if (k.len == 0) break;\n    // MG_INFO((\"--HH [%.*s] [%.*s] [%.*s]\", (int) tmp.len - 1, tmp.ptr,\n    //(int) k.len, k.ptr, (int) v.len, v.ptr));\n    h[i].name = k;\n    h[i].value = v;\n  }\n}\n\nint mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {\n  int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);\n  const char *end = s == NULL ? NULL : s + req_len, *qs;  // Cannot add to NULL\n  struct mg_str *cl;\n\n  memset(hm, 0, sizeof(*hm));\n  if (req_len <= 0) return req_len;\n\n  hm->message.ptr = hm->head.ptr = s;\n  hm->body.ptr = end;\n  hm->head.len = (size_t) req_len;\n  hm->chunk.ptr = end;\n  hm->message.len = hm->body.len = (size_t) ~0;  // Set body length to infinite\n\n  // Parse request line\n  s = skip(s, end, \" \", &hm->method);\n  s = skip(s, end, \" \", &hm->uri);\n  s = skip(s, end, \"\\r\\n\", &hm->proto);\n\n  // Sanity check. Allow protocol/reason to be empty\n  if (hm->method.len == 0 || hm->uri.len == 0) return -1;\n\n  // If URI contains '?' character, setup query string\n  if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {\n    hm->query.ptr = qs + 1;\n    hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));\n    hm->uri.len = (size_t) (qs - hm->uri.ptr);\n  }\n\n  mg_http_parse_headers(s, end, hm->headers,\n                        sizeof(hm->headers) / sizeof(hm->headers[0]));\n  if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {\n    hm->body.len = (size_t) mg_to64(*cl);\n    hm->message.len = (size_t) req_len + hm->body.len;\n  }\n\n  // mg_http_parse() is used to parse both HTTP requests and HTTP\n  // responses. If HTTP response does not have Content-Length set, then\n  // body is read until socket is closed, i.e. body.len is infinite (~0).\n  //\n  // For HTTP requests though, according to\n  // http://tools.ietf.org/html/rfc7231#section-8.1.3,\n  // only POST and PUT methods have defined body semantics.\n  // Therefore, if Content-Length is not specified and methods are\n  // not one of PUT or POST, set body length to 0.\n  //\n  // So, if it is HTTP request, and Content-Length is not set,\n  // and method is not (PUT or POST) then reset body length to zero.\n  is_response = mg_ncasecmp(hm->method.ptr, \"HTTP/\", 5) == 0;\n  if (hm->body.len == (size_t) ~0 && !is_response &&\n      mg_vcasecmp(&hm->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&hm->method, \"POST\") != 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  // The 204 (No content) responses also have 0 body length\n  if (hm->body.len == (size_t) ~0 && is_response &&\n      mg_vcasecmp(&hm->uri, \"204\") == 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  return req_len;\n}\n\nstatic void mg_http_vprintf_chunk(struct mg_connection *c, const char *fmt,\n                                  va_list *ap) {\n  size_t len = c->send.len;\n  mg_send(c, \"        \\r\\n\", 10);\n  mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, ap);\n  if (c->send.len >= len + 10) {\n    mg_snprintf((char *) c->send.buf + len, 9, \"%08lx\", c->send.len - len - 10);\n    c->send.buf[len + 8] = '\\r';\n    if (c->send.len == len + 10) c->is_resp = 0;  // Last chunk, reset marker\n  }\n  mg_send(c, \"\\r\\n\", 2);\n}\n\nvoid mg_http_printf_chunk(struct mg_connection *c, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  mg_http_vprintf_chunk(c, fmt, &ap);\n  va_end(ap);\n}\n\nvoid mg_http_write_chunk(struct mg_connection *c, const char *buf, size_t len) {\n  mg_printf(c, \"%lx\\r\\n\", (unsigned long) len);\n  mg_send(c, buf, len);\n  mg_send(c, \"\\r\\n\", 2);\n  if (len == 0) c->is_resp = 0;\n}\n\n// clang-format off\nstatic const char *mg_http_status_code_str(int status_code) {\n  switch (status_code) {\n    case 100: return \"Continue\";\n    case 201: return \"Created\";\n    case 202: return \"Accepted\";\n    case 204: return \"No Content\";\n    case 206: return \"Partial Content\";\n    case 301: return \"Moved Permanently\";\n    case 302: return \"Found\";\n    case 304: return \"Not Modified\";\n    case 400: return \"Bad Request\";\n    case 401: return \"Unauthorized\";\n    case 403: return \"Forbidden\";\n    case 404: return \"Not Found\";\n    case 418: return \"I'm a teapot\";\n    case 500: return \"Internal Server Error\";\n    case 501: return \"Not Implemented\";\n    default: return \"OK\";\n  }\n}\n// clang-format on\n\nvoid mg_http_reply(struct mg_connection *c, int code, const char *headers,\n                   const char *fmt, ...) {\n  va_list ap;\n  size_t len;\n  mg_printf(c, \"HTTP/1.1 %d %s\\r\\n%sContent-Length:            \\r\\n\\r\\n\", code,\n            mg_http_status_code_str(code), headers == NULL ? \"\" : headers);\n  len = c->send.len;\n  va_start(ap, fmt);\n  mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, &ap);\n  va_end(ap);\n  if (c->send.len > 16) {\n    size_t n = mg_snprintf((char *) &c->send.buf[len - 15], 11, \"%-10lu\",\n                           (unsigned long) (c->send.len - len));\n    c->send.buf[len - 15 + n] = ' ';  // Change ending 0 to space\n  }\n  c->is_resp = 0;\n}\n\nstatic void http_cb(struct mg_connection *, int, void *, void *);\nstatic void restore_http_cb(struct mg_connection *c) {\n  mg_fs_close((struct mg_fd *) c->pfn_data);\n  c->pfn_data = NULL;\n  c->pfn = http_cb;\n  c->is_resp = 0;\n}\n\nchar *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime);\nchar *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime) {\n  mg_snprintf(buf, len, \"\\\"%lld.%lld\\\"\", (int64_t) mtime, (int64_t) size);\n  return buf;\n}\n\nstatic void static_cb(struct mg_connection *c, int ev, void *ev_data,\n                      void *fn_data) {\n  if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {\n    struct mg_fd *fd = (struct mg_fd *) fn_data;\n    // Read to send IO buffer directly, avoid extra on-stack buffer\n    size_t n, max = MG_IO_SIZE, space;\n    size_t *cl = (size_t *) &c->data[(sizeof(c->data) - sizeof(size_t)) /\n                                     sizeof(size_t) * sizeof(size_t)];\n    if (c->send.size < max) mg_iobuf_resize(&c->send, max);\n    if (c->send.len >= c->send.size) return;  // Rate limit\n    if ((space = c->send.size - c->send.len) > *cl) space = *cl;\n    n = fd->fs->rd(fd->fd, c->send.buf + c->send.len, space);\n    c->send.len += n;\n    *cl -= n;\n    if (n == 0) restore_http_cb(c);\n  } else if (ev == MG_EV_CLOSE) {\n    restore_http_cb(c);\n  }\n  (void) ev_data;\n}\n\n// Known mime types. Keep it outside guess_content_type() function, since\n// some environments don't like it defined there.\n// clang-format off\nstatic struct mg_str s_known_types[] = {\n    MG_C_STR(\"html\"), MG_C_STR(\"text/html; charset=utf-8\"),\n    MG_C_STR(\"htm\"), MG_C_STR(\"text/html; charset=utf-8\"),\n    MG_C_STR(\"css\"), MG_C_STR(\"text/css; charset=utf-8\"),\n    MG_C_STR(\"js\"), MG_C_STR(\"text/javascript; charset=utf-8\"),\n    MG_C_STR(\"gif\"), MG_C_STR(\"image/gif\"),\n    MG_C_STR(\"png\"), MG_C_STR(\"image/png\"),\n    MG_C_STR(\"jpg\"), MG_C_STR(\"image/jpeg\"),\n    MG_C_STR(\"jpeg\"), MG_C_STR(\"image/jpeg\"),\n    MG_C_STR(\"woff\"), MG_C_STR(\"font/woff\"),\n    MG_C_STR(\"ttf\"), MG_C_STR(\"font/ttf\"),\n    MG_C_STR(\"svg\"), MG_C_STR(\"image/svg+xml\"),\n    MG_C_STR(\"txt\"), MG_C_STR(\"text/plain; charset=utf-8\"),\n    MG_C_STR(\"avi\"), MG_C_STR(\"video/x-msvideo\"),\n    MG_C_STR(\"csv\"), MG_C_STR(\"text/csv\"),\n    MG_C_STR(\"doc\"), MG_C_STR(\"application/msword\"),\n    MG_C_STR(\"exe\"), MG_C_STR(\"application/octet-stream\"),\n    MG_C_STR(\"gz\"), MG_C_STR(\"application/gzip\"),\n    MG_C_STR(\"ico\"), MG_C_STR(\"image/x-icon\"),\n    MG_C_STR(\"json\"), MG_C_STR(\"application/json\"),\n    MG_C_STR(\"mov\"), MG_C_STR(\"video/quicktime\"),\n    MG_C_STR(\"mp3\"), MG_C_STR(\"audio/mpeg\"),\n    MG_C_STR(\"mp4\"), MG_C_STR(\"video/mp4\"),\n    MG_C_STR(\"mpeg\"), MG_C_STR(\"video/mpeg\"),\n    MG_C_STR(\"pdf\"), MG_C_STR(\"application/pdf\"),\n    MG_C_STR(\"shtml\"), MG_C_STR(\"text/html; charset=utf-8\"),\n    MG_C_STR(\"tgz\"), MG_C_STR(\"application/tar-gz\"),\n    MG_C_STR(\"wav\"), MG_C_STR(\"audio/wav\"),\n    MG_C_STR(\"webp\"), MG_C_STR(\"image/webp\"),\n    MG_C_STR(\"zip\"), MG_C_STR(\"application/zip\"),\n    MG_C_STR(\"3gp\"), MG_C_STR(\"video/3gpp\"),\n    {0, 0},\n};\n// clang-format on\n\nstatic struct mg_str guess_content_type(struct mg_str path, const char *extra) {\n  struct mg_str k, v, s = mg_str(extra);\n  size_t i = 0;\n\n  // Shrink path to its extension only\n  while (i < path.len && path.ptr[path.len - i - 1] != '.') i++;\n  path.ptr += path.len - i;\n  path.len = i;\n\n  // Process user-provided mime type overrides, if any\n  while (mg_commalist(&s, &k, &v)) {\n    if (mg_strcmp(path, k) == 0) return v;\n  }\n\n  // Process built-in mime types\n  for (i = 0; s_known_types[i].ptr != NULL; i += 2) {\n    if (mg_strcmp(path, s_known_types[i]) == 0) return s_known_types[i + 1];\n  }\n\n  return mg_str(\"text/plain; charset=utf-8\");\n}\n\nstatic int getrange(struct mg_str *s, int64_t *a, int64_t *b) {\n  size_t i, numparsed = 0;\n  // MG_INFO((\"%.*s\", (int) s->len, s->ptr));\n  for (i = 0; i + 6 < s->len; i++) {\n    if (memcmp(&s->ptr[i], \"bytes=\", 6) == 0) {\n      struct mg_str p = mg_str_n(s->ptr + i + 6, s->len - i - 6);\n      if (p.len > 0 && p.ptr[0] >= '0' && p.ptr[0] <= '9') numparsed++;\n      *a = mg_to64(p);\n      // MG_INFO((\"PPP [%.*s] %d\", (int) p.len, p.ptr, numparsed));\n      while (p.len && p.ptr[0] >= '0' && p.ptr[0] <= '9') p.ptr++, p.len--;\n      if (p.len && p.ptr[0] == '-') p.ptr++, p.len--;\n      *b = mg_to64(p);\n      if (p.len > 0 && p.ptr[0] >= '0' && p.ptr[0] <= '9') numparsed++;\n      // MG_INFO((\"PPP [%.*s] %d\", (int) p.len, p.ptr, numparsed));\n      break;\n    }\n  }\n  return (int) numparsed;\n}\n\nvoid mg_http_serve_file(struct mg_connection *c, struct mg_http_message *hm,\n                        const char *path,\n                        const struct mg_http_serve_opts *opts) {\n  char etag[64], tmp[MG_PATH_MAX];\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct mg_fd *fd = NULL;\n  size_t size = 0;\n  time_t mtime = 0;\n  struct mg_str *inm = NULL;\n  struct mg_str mime = guess_content_type(mg_str(path), opts->mime_types);\n  bool gzip = false;\n\n  if (path != NULL) {\n    // If a browser sends us \"Accept-Encoding: gzip\", try to open .gz first\n    struct mg_str *ae = mg_http_get_header(hm, \"Accept-Encoding\");\n    if (ae != NULL && mg_strstr(*ae, mg_str(\"gzip\")) != NULL) {\n      mg_snprintf(tmp, sizeof(tmp), \"%s.gz\", path);\n      fd = mg_fs_open(fs, tmp, MG_FS_READ);\n      if (fd != NULL) gzip = true, path = tmp;\n    }\n    // No luck opening .gz? Open what we've told to open\n    if (fd == NULL) fd = mg_fs_open(fs, path, MG_FS_READ);\n  }\n\n  // Failed to open, and page404 is configured? Open it, then\n  if (fd == NULL && opts->page404 != NULL) {\n    fd = mg_fs_open(fs, opts->page404, MG_FS_READ);\n    mime = guess_content_type(mg_str(path), opts->mime_types);\n    path = opts->page404;\n  }\n\n  if (fd == NULL || fs->st(path, &size, &mtime) == 0) {\n    mg_http_reply(c, 404, opts->extra_headers, \"Not found\\n\");\n    mg_fs_close(fd);\n    // NOTE: mg_http_etag() call should go first!\n  } else if (mg_http_etag(etag, sizeof(etag), size, mtime) != NULL &&\n             (inm = mg_http_get_header(hm, \"If-None-Match\")) != NULL &&\n             mg_vcasecmp(inm, etag) == 0) {\n    mg_fs_close(fd);\n    mg_http_reply(c, 304, opts->extra_headers, \"\");\n  } else {\n    int n, status = 200;\n    char range[100];\n    int64_t r1 = 0, r2 = 0, cl = (int64_t) size;\n\n    // Handle Range header\n    struct mg_str *rh = mg_http_get_header(hm, \"Range\");\n    range[0] = '\\0';\n    if (rh != NULL && (n = getrange(rh, &r1, &r2)) > 0 && r1 >= 0 && r2 >= 0) {\n      // If range is specified like \"400-\", set second limit to content len\n      if (n == 1) r2 = cl - 1;\n      if (r1 > r2 || r2 >= cl) {\n        status = 416;\n        cl = 0;\n        mg_snprintf(range, sizeof(range), \"Content-Range: bytes */%lld\\r\\n\",\n                    (int64_t) size);\n      } else {\n        status = 206;\n        cl = r2 - r1 + 1;\n        mg_snprintf(range, sizeof(range),\n                    \"Content-Range: bytes %lld-%lld/%lld\\r\\n\", r1, r1 + cl - 1,\n                    (int64_t) size);\n        fs->sk(fd->fd, (size_t) r1);\n      }\n    }\n    mg_printf(c,\n              \"HTTP/1.1 %d %s\\r\\n\"\n              \"Content-Type: %.*s\\r\\n\"\n              \"Etag: %s\\r\\n\"\n              \"Content-Length: %llu\\r\\n\"\n              \"%s%s%s\\r\\n\",\n              status, mg_http_status_code_str(status), (int) mime.len, mime.ptr,\n              etag, cl, gzip ? \"Content-Encoding: gzip\\r\\n\" : \"\", range,\n              opts->extra_headers ? opts->extra_headers : \"\");\n    if (mg_vcasecmp(&hm->method, \"HEAD\") == 0) {\n      c->is_draining = 1;\n      c->is_resp = 0;\n      mg_fs_close(fd);\n    } else {\n      // Track to-be-sent content length at the end of c->data, aligned\n      size_t *clp = (size_t *) &c->data[(sizeof(c->data) - sizeof(size_t)) /\n                                        sizeof(size_t) * sizeof(size_t)];\n      c->pfn = static_cb;\n      c->pfn_data = fd;\n      *clp = (size_t) cl;\n    }\n  }\n}\n\nstruct printdirentrydata {\n  struct mg_connection *c;\n  struct mg_http_message *hm;\n  const struct mg_http_serve_opts *opts;\n  const char *dir;\n};\n\nstatic void printdirentry(const char *name, void *userdata) {\n  struct printdirentrydata *d = (struct printdirentrydata *) userdata;\n  struct mg_fs *fs = d->opts->fs == NULL ? &mg_fs_posix : d->opts->fs;\n  size_t size = 0;\n  time_t t = 0;\n  char path[MG_PATH_MAX], sz[40], mod[40];\n  int flags, n = 0;\n\n  // MG_DEBUG((\"[%s] [%s]\", d->dir, name));\n  if (mg_snprintf(path, sizeof(path), \"%s%c%s\", d->dir, '/', name) >\n      sizeof(path)) {\n    MG_ERROR((\"%s truncated\", name));\n  } else if ((flags = fs->st(path, &size, &t)) == 0) {\n    MG_ERROR((\"%lu stat(%s): %d\", d->c->id, path, errno));\n  } else {\n    const char *slash = flags & MG_FS_DIR ? \"/\" : \"\";\n    if (flags & MG_FS_DIR) {\n      mg_snprintf(sz, sizeof(sz), \"%s\", \"[DIR]\");\n    } else {\n      mg_snprintf(sz, sizeof(sz), \"%lld\", (uint64_t) size);\n    }\n#if defined(MG_HTTP_DIRLIST_TIME_FMT)\n    {\n      char time_str[40];\n      struct tm *time_info = localtime(&t);\n      strftime(time_str, sizeof time_str, \"%Y/%m/%d %H:%M:%S\", time_info);\n      mg_snprintf(mod, sizeof(mod), \"%s\", time_str);\n    }\n#else\n    mg_snprintf(mod, sizeof(mod), \"%lu\", (unsigned long) t);\n#endif\n    n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));\n    mg_printf(d->c,\n              \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"\n              \"<td name=%lu>%s</td><td name=%lld>%s</td></tr>\\n\",\n              n, path, slash, name, slash, (unsigned long) t, mod,\n              flags & MG_FS_DIR ? (int64_t) -1 : (int64_t) size, sz);\n  }\n}\n\nstatic void listdir(struct mg_connection *c, struct mg_http_message *hm,\n                    const struct mg_http_serve_opts *opts, char *dir) {\n  const char *sort_js_code =\n      \"<script>function srt(tb, sc, so, d) {\"\n      \"var tr = Array.prototype.slice.call(tb.rows, 0),\"\n      \"tr = tr.sort(function (a, b) { var c1 = a.cells[sc], c2 = b.cells[sc],\"\n      \"n1 = c1.getAttribute('name'), n2 = c2.getAttribute('name'), \"\n      \"t1 = a.cells[2].getAttribute('name'), \"\n      \"t2 = b.cells[2].getAttribute('name'); \"\n      \"return so * (t1 < 0 && t2 >= 0 ? -1 : t2 < 0 && t1 >= 0 ? 1 : \"\n      \"n1 ? parseInt(n2) - parseInt(n1) : \"\n      \"c1.textContent.trim().localeCompare(c2.textContent.trim())); });\";\n  const char *sort_js_code2 =\n      \"for (var i = 0; i < tr.length; i++) tb.appendChild(tr[i]); \"\n      \"if (!d) window.location.hash = ('sc=' + sc + '&so=' + so); \"\n      \"};\"\n      \"window.onload = function() {\"\n      \"var tb = document.getElementById('tb');\"\n      \"var m = /sc=([012]).so=(1|-1)/.exec(window.location.hash) || [0, 2, 1];\"\n      \"var sc = m[1], so = m[2]; document.onclick = function(ev) { \"\n      \"var c = ev.target.rel; if (c) {if (c == sc) so *= -1; srt(tb, c, so); \"\n      \"sc = c; ev.preventDefault();}};\"\n      \"srt(tb, sc, so, true);\"\n      \"}\"\n      \"</script>\";\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct printdirentrydata d = {c, hm, opts, dir};\n  char tmp[10], buf[MG_PATH_MAX];\n  size_t off, n;\n  int len = mg_url_decode(hm->uri.ptr, hm->uri.len, buf, sizeof(buf), 0);\n  struct mg_str uri = len > 0 ? mg_str_n(buf, (size_t) len) : hm->uri;\n\n  mg_printf(c,\n            \"HTTP/1.1 200 OK\\r\\n\"\n            \"Content-Type: text/html; charset=utf-8\\r\\n\"\n            \"%s\"\n            \"Content-Length:         \\r\\n\\r\\n\",\n            opts->extra_headers == NULL ? \"\" : opts->extra_headers);\n  off = c->send.len;  // Start of body\n  mg_printf(c,\n            \"<!DOCTYPE html><html><head><title>Index of %.*s</title>%s%s\"\n            \"<style>th,td {text-align: left; padding-right: 1em; \"\n            \"font-family: monospace; }</style></head>\"\n            \"<body><h1>Index of %.*s</h1><table cellpadding=\\\"0\\\"><thead>\"\n            \"<tr><th><a href=\\\"#\\\" rel=\\\"0\\\">Name</a></th><th>\"\n            \"<a href=\\\"#\\\" rel=\\\"1\\\">Modified</a></th>\"\n            \"<th><a href=\\\"#\\\" rel=\\\"2\\\">Size</a></th></tr>\"\n            \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\"\n            \"</thead>\"\n            \"<tbody id=\\\"tb\\\">\\n\",\n            (int) uri.len, uri.ptr, sort_js_code, sort_js_code2, (int) uri.len,\n            uri.ptr);\n  mg_printf(c, \"%s\",\n            \"  <tr><td><a href=\\\"..\\\">..</a></td>\"\n            \"<td name=-1></td><td name=-1>[DIR]</td></tr>\\n\");\n\n  fs->ls(dir, printdirentry, &d);\n  mg_printf(c,\n            \"</tbody><tfoot><tr><td colspan=\\\"3\\\"><hr></td></tr></tfoot>\"\n            \"</table><address>Mongoose v.%s</address></body></html>\\n\",\n            MG_VERSION);\n  n = mg_snprintf(tmp, sizeof(tmp), \"%lu\", (unsigned long) (c->send.len - off));\n  if (n > sizeof(tmp)) n = 0;\n  memcpy(c->send.buf + off - 12, tmp, n);  // Set content length\n  c->is_resp = 0;                          // Mark response end\n}\n\n// Resolve requested file into `path` and return its fs->st() result\nstatic int uri_to_path2(struct mg_connection *c, struct mg_http_message *hm,\n                        struct mg_fs *fs, struct mg_str url, struct mg_str dir,\n                        char *path, size_t path_size) {\n  int flags, tmp;\n  // Append URI to the root_dir, and sanitize it\n  size_t n = mg_snprintf(path, path_size, \"%.*s\", (int) dir.len, dir.ptr);\n  if (n > path_size) n = path_size;\n  path[path_size - 1] = '\\0';\n  if (n + 2 < path_size) path[n++] = '/', path[n] = '\\0';\n  mg_url_decode(hm->uri.ptr + url.len, hm->uri.len - url.len, path + n,\n                path_size - n, 0);\n  path[path_size - 1] = '\\0';  // Double-check\n  mg_remove_double_dots(path);\n  n = strlen(path);\n  while (n > 1 && path[n - 1] == '/') path[--n] = 0;  // Trim trailing slashes\n  flags = mg_vcmp(&hm->uri, \"/\") == 0 ? MG_FS_DIR : fs->st(path, NULL, NULL);\n  MG_VERBOSE((\"%lu %.*s -> %s %d\", c->id, (int) hm->uri.len, hm->uri.ptr, path,\n              flags));\n  if (flags == 0) {\n    // Do nothing - let's caller decide\n  } else if ((flags & MG_FS_DIR) && hm->uri.len > 0 &&\n             hm->uri.ptr[hm->uri.len - 1] != '/') {\n    mg_printf(c,\n              \"HTTP/1.1 301 Moved\\r\\n\"\n              \"Location: %.*s/\\r\\n\"\n              \"Content-Length: 0\\r\\n\"\n              \"\\r\\n\",\n              (int) hm->uri.len, hm->uri.ptr);\n    c->is_resp = 0;\n    flags = -1;\n  } else if (flags & MG_FS_DIR) {\n    if (((mg_snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX) > 0 &&\n          (tmp = fs->st(path, NULL, NULL)) != 0) ||\n         (mg_snprintf(path + n, path_size - n, \"/index.shtml\") > 0 &&\n          (tmp = fs->st(path, NULL, NULL)) != 0))) {\n      flags = tmp;\n    } else if ((mg_snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX \".gz\") >\n                    0 &&\n                (tmp = fs->st(path, NULL, NULL)) !=\n                    0)) {  // check for gzipped index\n      flags = tmp;\n      path[n + 1 + strlen(MG_HTTP_INDEX)] =\n          '\\0';  // Remove appended .gz in index file name\n    } else {\n      path[n] = '\\0';  // Remove appended index file name\n    }\n  }\n  return flags;\n}\n\nstatic int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,\n                       const struct mg_http_serve_opts *opts, char *path,\n                       size_t path_size) {\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};\n  while (mg_commalist(&s, &k, &v)) {\n    if (v.len == 0) v = k, k = mg_str(\"/\");\n    if (hm->uri.len < k.len) continue;\n    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;\n    u = k, p = v;\n  }\n  return uri_to_path2(c, hm, fs, u, p, path, path_size);\n}\n\nvoid mg_http_serve_dir(struct mg_connection *c, struct mg_http_message *hm,\n                       const struct mg_http_serve_opts *opts) {\n  char path[MG_PATH_MAX];\n  const char *sp = opts->ssi_pattern;\n  int flags = uri_to_path(c, hm, opts, path, sizeof(path));\n  if (flags < 0) {\n    // Do nothing: the response has already been sent by uri_to_path()\n  } else if (flags & MG_FS_DIR) {\n    listdir(c, hm, opts, path);\n  } else if (flags && sp != NULL &&\n             mg_globmatch(sp, strlen(sp), path, strlen(path))) {\n    mg_http_serve_ssi(c, opts->root_dir, path);\n  } else {\n    mg_http_serve_file(c, hm, path, opts);\n  }\n}\n\nstatic bool mg_is_url_safe(int c) {\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') ||\n         (c >= 'A' && c <= 'Z') || c == '.' || c == '_' || c == '-' || c == '~';\n}\n\nsize_t mg_url_encode(const char *s, size_t sl, char *buf, size_t len) {\n  size_t i, n = 0;\n  for (i = 0; i < sl; i++) {\n    int c = *(unsigned char *) &s[i];\n    if (n + 4 >= len) return 0;\n    if (mg_is_url_safe(c)) {\n      buf[n++] = s[i];\n    } else {\n      buf[n++] = '%';\n      mg_hex(&s[i], 1, &buf[n]);\n      n += 2;\n    }\n  }\n  if (len > 0 && n < len - 1) buf[n] = '\\0';  // Null-terminate the destination\n  if (len > 0) buf[len - 1] = '\\0';           // Always.\n  return n;\n}\n\nvoid mg_http_creds(struct mg_http_message *hm, char *user, size_t userlen,\n                   char *pass, size_t passlen) {\n  struct mg_str *v = mg_http_get_header(hm, \"Authorization\");\n  user[0] = pass[0] = '\\0';\n  if (v != NULL && v->len > 6 && memcmp(v->ptr, \"Basic \", 6) == 0) {\n    char buf[256];\n    int n = mg_base64_decode(v->ptr + 6, (int) v->len - 6, buf);\n    const char *p = (const char *) memchr(buf, ':', n > 0 ? (size_t) n : 0);\n    if (p != NULL) {\n      mg_snprintf(user, userlen, \"%.*s\", (int) (p - buf), buf);\n      mg_snprintf(pass, passlen, \"%.*s\", n - (int) (p - buf) - 1, p + 1);\n    }\n  } else if (v != NULL && v->len > 7 && memcmp(v->ptr, \"Bearer \", 7) == 0) {\n    mg_snprintf(pass, passlen, \"%.*s\", (int) v->len - 7, v->ptr + 7);\n  } else if ((v = mg_http_get_header(hm, \"Cookie\")) != NULL) {\n    struct mg_str t = mg_http_get_header_var(*v, mg_str_n(\"access_token\", 12));\n    if (t.len > 0) mg_snprintf(pass, passlen, \"%.*s\", (int) t.len, t.ptr);\n  } else {\n    mg_http_get_var(&hm->query, \"access_token\", pass, passlen);\n  }\n}\n\nstatic struct mg_str stripquotes(struct mg_str s) {\n  return s.len > 1 && s.ptr[0] == '\"' && s.ptr[s.len - 1] == '\"'\n             ? mg_str_n(s.ptr + 1, s.len - 2)\n             : s;\n}\n\nstruct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v) {\n  size_t i;\n  for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {\n    if (s.ptr[i + v.len] == '=' && memcmp(&s.ptr[i], v.ptr, v.len) == 0) {\n      const char *p = &s.ptr[i + v.len + 1], *b = p, *x = &s.ptr[s.len];\n      int q = p < x && *p == '\"' ? 1 : 0;\n      while (p < x &&\n             (q ? p == b || *p != '\"' : *p != ';' && *p != ' ' && *p != ','))\n        p++;\n      // MG_INFO((\"[%.*s] [%.*s] [%.*s]\", (int) s.len, s.ptr, (int) v.len,\n      // v.ptr, (int) (p - b), b));\n      return stripquotes(mg_str_n(b, (size_t) (p - b + q)));\n    }\n  }\n  return mg_str_n(NULL, 0);\n}\n\nbool mg_http_match_uri(const struct mg_http_message *hm, const char *glob) {\n  return mg_match(hm->uri, mg_str(glob), NULL);\n}\n\nlong mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                    struct mg_fs *fs, const char *path, size_t max_size) {\n  char buf[20] = \"0\";\n  long res = 0, offset;\n  mg_http_get_var(&hm->query, \"offset\", buf, sizeof(buf));\n  offset = strtol(buf, NULL, 0);\n  if (hm->body.len == 0) {\n    mg_http_reply(c, 200, \"\", \"%ld\", res);  // Nothing to write\n  } else {\n    struct mg_fd *fd;\n    size_t current_size = 0;\n    MG_DEBUG((\"%s -> %d bytes @ %ld\", path, (int) hm->body.len, offset));\n    if (offset == 0) fs->rm(path);  // If offset if 0, truncate file\n    fs->st(path, &current_size, NULL);\n    if (offset < 0) {\n      mg_http_reply(c, 400, \"\", \"offset required\");\n      res = -1;\n    } else if (offset > 0 && current_size != (size_t) offset) {\n      mg_http_reply(c, 400, \"\", \"%s: offset mismatch\", path);\n      res = -2;\n    } else if ((size_t) offset + hm->body.len > max_size) {\n      mg_http_reply(c, 400, \"\", \"%s: over max size of %lu\", path,\n                    (unsigned long) max_size);\n      res = -3;\n    } else if ((fd = mg_fs_open(fs, path, MG_FS_WRITE)) == NULL) {\n      mg_http_reply(c, 400, \"\", \"open(%s): %d\", path, errno);\n      res = -4;\n    } else {\n      res = offset + (long) fs->wr(fd->fd, hm->body.ptr, hm->body.len);\n      mg_fs_close(fd);\n      mg_http_reply(c, 200, \"\", \"%ld\", res);\n    }\n  }\n  return res;\n}\n\nint mg_http_status(const struct mg_http_message *hm) {\n  return atoi(hm->uri.ptr);\n}\n\n// If a server sends data to the client using chunked encoding, Mongoose strips\n// off the chunking prefix (hex length and \\r\\n) and suffix (\\r\\n), appends the\n// stripped data to the body, and fires the MG_EV_HTTP_CHUNK event.  When zero\n// chunk is received, we fire MG_EV_HTTP_MSG, and the body already has all\n// chunking prefixes/suffixes stripped.\n//\n// If a server sends data without chunked encoding, we also fire a series of\n// MG_EV_HTTP_CHUNK events for every received piece of data, and then we fire\n// MG_EV_HTTP_MSG event in the end.\n//\n// We track total processed length in the c->pfn_data, which is a void *\n// pointer: we store a size_t value there.\nstatic bool getchunk(struct mg_str s, size_t *prefixlen, size_t *datalen) {\n  size_t i = 0, n;\n  while (i < s.len && s.ptr[i] != '\\r' && s.ptr[i] != '\\n') i++;\n  n = mg_unhexn(s.ptr, i);\n  // MG_INFO((\"%d %d\", (int) (i + n + 4), (int) s.len));\n  if (s.len < i + n + 4) return false;  // Chunk not yet fully buffered\n  if (s.ptr[i] != '\\r' || s.ptr[i + 1] != '\\n') return false;\n  if (s.ptr[i + n + 2] != '\\r' || s.ptr[i + n + 3] != '\\n') return false;\n  *prefixlen = i + 2;\n  *datalen = n;\n  return true;\n}\n\nstatic bool mg_is_chunked(struct mg_http_message *hm) {\n  const char *needle = \"chunked\";\n  struct mg_str *te = mg_http_get_header(hm, \"Transfer-Encoding\");\n  return te != NULL && mg_vcasecmp(te, needle) == 0;\n}\n\nvoid mg_http_delete_chunk(struct mg_connection *c, struct mg_http_message *hm) {\n  size_t ofs = (size_t) (hm->chunk.ptr - (char *) c->recv.buf);\n  mg_iobuf_del(&c->recv, ofs, hm->chunk.len);\n  c->pfn_data = (void *) ((size_t) c->pfn_data | MG_DMARK);\n}\n\nstatic void deliver_chunked_chunks(struct mg_connection *c, size_t hlen,\n                                   struct mg_http_message *hm, bool *next) {\n  //  |  ... headers ... | HEXNUM\\r\\n ..data.. \\r\\n | ......\n  //  +------------------+--------------------------+----\n  //  |      hlen        |           chunk1         | ......\n  char *buf = (char *) &c->recv.buf[hlen], *p = buf;\n  size_t len = c->recv.len - hlen;\n  size_t processed = ((size_t) c->pfn_data) & ~MG_DMARK;\n  size_t mark, pl, dl, del = 0, ofs = 0;\n  bool last = false;\n  if (processed <= len) len -= processed, buf += processed;\n  while (!last && getchunk(mg_str_n(buf + ofs, len - ofs), &pl, &dl)) {\n    size_t saved = c->recv.len;\n    memmove(p + processed, buf + ofs + pl, dl);\n    // MG_INFO((\"P2 [%.*s]\", (int) (processed + dl), p));\n    hm->chunk = mg_str_n(p + processed, dl);\n    mg_call(c, MG_EV_HTTP_CHUNK, hm);\n    ofs += pl + dl + 2, del += pl + 2;  // 2 is for \\r\\n suffix\n    processed += dl;\n    if (c->recv.len != saved) processed -= dl, buf -= dl;\n    // mg_hexdump(c->recv.buf, hlen + processed);\n    last = (dl == 0);\n  }\n  mg_iobuf_del(&c->recv, hlen + processed, del);\n  mark = ((size_t) c->pfn_data) & MG_DMARK;\n  c->pfn_data = (void *) (processed | mark);\n  if (last) {\n    hm->body.len = processed;\n    hm->message.len = hlen + processed;\n    c->pfn_data = NULL;\n    if (mark) mg_iobuf_del(&c->recv, 0, hlen), *next = true;\n    // MG_INFO((\"LAST, mark: %lx\", mark));\n    // mg_hexdump(c->recv.buf, c->recv.len);\n  }\n}\n\nstatic void deliver_normal_chunks(struct mg_connection *c, size_t hlen,\n                                  struct mg_http_message *hm, bool *next) {\n  size_t left, processed = ((size_t) c->pfn_data) & ~MG_DMARK;\n  size_t deleted = ((size_t) c->pfn_data) & MG_DMARK;\n  hm->chunk = mg_str_n((char *) &c->recv.buf[hlen], c->recv.len - hlen);\n  if (processed <= hm->chunk.len && !deleted) {\n    hm->chunk.len -= processed;\n    hm->chunk.ptr += processed;\n  }\n  left = hm->body.len < processed ? 0 : hm->body.len - processed;\n  if (hm->chunk.len > left) hm->chunk.len = left;\n  if (hm->chunk.len > 0) mg_call(c, MG_EV_HTTP_CHUNK, hm);\n  processed += hm->chunk.len;\n  deleted = ((size_t) c->pfn_data) & MG_DMARK;  // Re-evaluate after user call\n  if (processed >= hm->body.len) {              // Last, 0-len chunk\n    hm->chunk.len = 0;                          // Reset length\n    mg_call(c, MG_EV_HTTP_CHUNK, hm);           // Call user handler\n    c->pfn_data = NULL;                         // Reset processed counter\n    if (processed && deleted) mg_iobuf_del(&c->recv, 0, hlen), *next = true;\n  } else {\n    c->pfn_data = (void *) (processed | deleted);  // if it is set\n  }\n}\n\nstatic void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n  if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {\n    struct mg_http_message hm;\n    // mg_hexdump(c->recv.buf, c->recv.len);\n    while (c->recv.buf != NULL && c->recv.len > 0) {\n      bool next = false;\n      int hlen = mg_http_parse((char *) c->recv.buf, c->recv.len, &hm);\n      if (hlen < 0) {\n        mg_error(c, \"HTTP parse:\\n%.*s\", (int) c->recv.len, c->recv.buf);\n        break;\n      }\n      if (c->is_resp) break;           // Response is still generated\n      if (hlen == 0) break;            // Request is not buffered yet\n      if (ev == MG_EV_CLOSE) {         // If client did not set Content-Length\n        hm.message.len = c->recv.len;  // and closes now, deliver a MSG\n        hm.body.len = hm.message.len - (size_t) (hm.body.ptr - hm.message.ptr);\n      }\n      if (mg_is_chunked(&hm)) {\n        deliver_chunked_chunks(c, (size_t) hlen, &hm, &next);\n      } else {\n        deliver_normal_chunks(c, (size_t) hlen, &hm, &next);\n      }\n      if (next) continue;  // Chunks & request were deleted\n      //  Chunk events are delivered. If we have full body, deliver MSG\n      if (c->recv.len < hm.message.len) break;\n      if (c->is_accepted) c->is_resp = 1;  // Start generating response\n      mg_call(c, MG_EV_HTTP_MSG, &hm);     // User handler can clear is_resp\n      mg_iobuf_del(&c->recv, 0, hm.message.len);\n    }\n  }\n  (void) evd, (void) fnd;\n}\n\nstatic void mg_hfn(struct mg_connection *c, int ev, void *ev_data, void *fnd) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    if (mg_http_match_uri(hm, \"/quit\")) {\n      mg_http_reply(c, 200, \"\", \"ok\\n\");\n      c->is_draining = 1;\n      c->data[0] = 'X';\n    } else if (mg_http_match_uri(hm, \"/debug\")) {\n      int level = (int) mg_json_get_long(hm->body, \"$.level\", MG_LL_DEBUG);\n      mg_log_set(level);\n      mg_http_reply(c, 200, \"\", \"Debug level set to %d\\n\", level);\n    } else {\n      mg_http_reply(c, 200, \"\", \"hi\\n\");\n    }\n  } else if (ev == MG_EV_CLOSE) {\n    if (c->data[0] == 'X') *(bool *) fnd = true;\n  }\n}\n\nvoid mg_hello(const char *url) {\n  struct mg_mgr mgr;\n  bool done = false;\n  mg_mgr_init(&mgr);\n  if (mg_http_listen(&mgr, url, mg_hfn, &done) == NULL) done = true;\n  while (done == false) mg_mgr_poll(&mgr, 100);\n  mg_mgr_free(&mgr);\n}\n\nstruct mg_connection *mg_http_connect(struct mg_mgr *mgr, const char *url,\n                                      mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = http_cb;\n  return c;\n}\n\nstruct mg_connection *mg_http_listen(struct mg_mgr *mgr, const char *url,\n                                     mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = http_cb;\n  return c;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/iobuf.c\"\n#endif\n\n\n\n\n// Not using memset for zeroing memory, cause it can be dropped by compiler\n// See https://github.com/cesanta/mongoose/pull/1265\nstatic void zeromem(volatile unsigned char *buf, size_t len) {\n  if (buf != NULL) {\n    while (len--) *buf++ = 0;\n  }\n}\n\nstatic size_t roundup(size_t size, size_t align) {\n  return align == 0 ? size : (size + align - 1) / align * align;\n}\n\nint mg_iobuf_resize(struct mg_iobuf *io, size_t new_size) {\n  int ok = 1;\n  new_size = roundup(new_size, io->align);\n  if (new_size == 0) {\n    zeromem(io->buf, io->size);\n    free(io->buf);\n    io->buf = NULL;\n    io->len = io->size = 0;\n  } else if (new_size != io->size) {\n    // NOTE(lsm): do not use realloc here. Use calloc/free only, to ease the\n    // porting to some obscure platforms like FreeRTOS\n    void *p = calloc(1, new_size);\n    if (p != NULL) {\n      size_t len = new_size < io->len ? new_size : io->len;\n      if (len > 0 && io->buf != NULL) memmove(p, io->buf, len);\n      zeromem(io->buf, io->size);\n      free(io->buf);\n      io->buf = (unsigned char *) p;\n      io->size = new_size;\n    } else {\n      ok = 0;\n      MG_ERROR((\"%lld->%lld\", (uint64_t) io->size, (uint64_t) new_size));\n    }\n  }\n  return ok;\n}\n\nint mg_iobuf_init(struct mg_iobuf *io, size_t size, size_t align) {\n  io->buf = NULL;\n  io->align = align;\n  io->size = io->len = 0;\n  return mg_iobuf_resize(io, size);\n}\n\nsize_t mg_iobuf_add(struct mg_iobuf *io, size_t ofs, const void *buf,\n                    size_t len) {\n  size_t new_size = roundup(io->len + len, io->align);\n  mg_iobuf_resize(io, new_size);      // Attempt to resize\n  if (new_size != io->size) len = 0;  // Resize failure, append nothing\n  if (ofs < io->len) memmove(io->buf + ofs + len, io->buf + ofs, io->len - ofs);\n  if (buf != NULL) memmove(io->buf + ofs, buf, len);\n  if (ofs > io->len) io->len += ofs - io->len;\n  io->len += len;\n  return len;\n}\n\nsize_t mg_iobuf_del(struct mg_iobuf *io, size_t ofs, size_t len) {\n  if (ofs > io->len) ofs = io->len;\n  if (ofs + len > io->len) len = io->len - ofs;\n  if (io->buf) memmove(io->buf + ofs, io->buf + ofs + len, io->len - ofs - len);\n  if (io->buf) zeromem(io->buf + io->len - len, len);\n  io->len -= len;\n  return len;\n}\n\nvoid mg_iobuf_free(struct mg_iobuf *io) {\n  mg_iobuf_resize(io, 0);\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/json.c\"\n#endif\n\n\n\n\nstatic const char *escapeseq(int esc) {\n  return esc ? \"\\b\\f\\n\\r\\t\\\\\\\"\" : \"bfnrt\\\\\\\"\";\n}\n\nstatic char json_esc(int c, int esc) {\n  const char *p, *esc1 = escapeseq(esc), *esc2 = escapeseq(!esc);\n  for (p = esc1; *p != '\\0'; p++) {\n    if (*p == c) return esc2[p - esc1];\n  }\n  return 0;\n}\n\nstatic int mg_pass_string(const char *s, int len) {\n  int i;\n  for (i = 0; i < len; i++) {\n    if (s[i] == '\\\\' && i + 1 < len && json_esc(s[i + 1], 1)) {\n      i++;\n    } else if (s[i] == '\\0') {\n      return MG_JSON_INVALID;\n    } else if (s[i] == '\"') {\n      return i;\n    }\n  }\n  return MG_JSON_INVALID;\n}\n\nstatic double mg_atod(const char *p, int len, int *numlen) {\n  double d = 0.0;\n  int i = 0, sign = 1;\n\n  // Sign\n  if (i < len && *p == '-') {\n    sign = -1, i++;\n  } else if (i < len && *p == '+') {\n    i++;\n  }\n\n  // Decimal\n  for (; i < len && p[i] >= '0' && p[i] <= '9'; i++) {\n    d *= 10.0;\n    d += p[i] - '0';\n  }\n  d *= sign;\n\n  // Fractional\n  if (i < len && p[i] == '.') {\n    double frac = 0.0, base = 0.1;\n    i++;\n    for (; i < len && p[i] >= '0' && p[i] <= '9'; i++) {\n      frac += base * (p[i] - '0');\n      base /= 10.0;\n    }\n    d += frac * sign;\n  }\n\n  // Exponential\n  if (i < len && (p[i] == 'e' || p[i] == 'E')) {\n    int j, exp = 0, minus = 0;\n    i++;\n    if (i < len && p[i] == '-') minus = 1, i++;\n    if (i < len && p[i] == '+') i++;\n    while (i < len && p[i] >= '0' && p[i] <= '9' && exp < 308)\n      exp = exp * 10 + (p[i++] - '0');\n    if (minus) exp = -exp;\n    for (j = 0; j < exp; j++) d *= 10.0;\n    for (j = 0; j < -exp; j++) d /= 10.0;\n  }\n\n  if (numlen != NULL) *numlen = i;\n  return d;\n}\n\nint mg_json_get(struct mg_str json, const char *path, int *toklen) {\n  const char *s = json.ptr;\n  int len = (int) json.len;\n  enum { S_VALUE, S_KEY, S_COLON, S_COMMA_OR_EOO } expecting = S_VALUE;\n  unsigned char nesting[MG_JSON_MAX_DEPTH];\n  int i = 0;             // Current offset in `s`\n  int j = 0;             // Offset in `s` we're looking for (return value)\n  int depth = 0;         // Current depth (nesting level)\n  int ed = 0;            // Expected depth\n  int pos = 1;           // Current position in `path`\n  int ci = -1, ei = -1;  // Current and expected index in array\n\n  if (toklen) *toklen = 0;\n  if (path[0] != '$') return MG_JSON_INVALID;\n\n#define MG_CHECKRET(x)                                  \\\n  do {                                                  \\\n    if (depth == ed && path[pos] == '\\0' && ci == ei) { \\\n      if (toklen) *toklen = i - j + 1;                  \\\n      return j;                                         \\\n    }                                                   \\\n  } while (0)\n\n// In the ascii table, the distance between `[` and `]` is 2.\n// Ditto for `{` and `}`. Hence +2 in the code below.\n#define MG_EOO(x)                                            \\\n  do {                                                       \\\n    if (depth == ed && ci != ei) return MG_JSON_NOT_FOUND;   \\\n    if (c != nesting[depth - 1] + 2) return MG_JSON_INVALID; \\\n    depth--;                                                 \\\n    MG_CHECKRET(x);                                          \\\n  } while (0)\n\n  for (i = 0; i < len; i++) {\n    unsigned char c = ((unsigned char *) s)[i];\n    if (c == ' ' || c == '\\t' || c == '\\n' || c == '\\r') continue;\n    switch (expecting) {\n      case S_VALUE:\n        // p(\"V %s [%.*s] %d %d %d %d\\n\", path, pos, path, depth, ed, ci, ei);\n        if (depth == ed) j = i;\n        if (c == '{') {\n          if (depth >= (int) sizeof(nesting)) return MG_JSON_TOO_DEEP;\n          if (depth == ed && path[pos] == '.' && ci == ei) {\n            // If we start the object, reset array indices\n            ed++, pos++, ci = ei = -1;\n          }\n          nesting[depth++] = c;\n          expecting = S_KEY;\n          break;\n        } else if (c == '[') {\n          if (depth >= (int) sizeof(nesting)) return MG_JSON_TOO_DEEP;\n          if (depth == ed && path[pos] == '[' && ei == ci) {\n            ed++, pos++, ci = 0;\n            for (ei = 0; path[pos] != ']' && path[pos] != '\\0'; pos++) {\n              ei *= 10;\n              ei += path[pos] - '0';\n            }\n            if (path[pos] != 0) pos++;\n          }\n          nesting[depth++] = c;\n          break;\n        } else if (c == ']' && depth > 0) {  // Empty array\n          MG_EOO(']');\n        } else if (c == 't' && i + 3 < len && memcmp(&s[i], \"true\", 4) == 0) {\n          i += 3;\n        } else if (c == 'n' && i + 3 < len && memcmp(&s[i], \"null\", 4) == 0) {\n          i += 3;\n        } else if (c == 'f' && i + 4 < len && memcmp(&s[i], \"false\", 5) == 0) {\n          i += 4;\n        } else if (c == '-' || ((c >= '0' && c <= '9'))) {\n          int numlen = 0;\n          mg_atod(&s[i], len - i, &numlen);\n          i += numlen - 1;\n        } else if (c == '\"') {\n          int n = mg_pass_string(&s[i + 1], len - i - 1);\n          if (n < 0) return n;\n          i += n + 1;\n        } else {\n          return MG_JSON_INVALID;\n        }\n        MG_CHECKRET('V');\n        if (depth == ed && ei >= 0) ci++;\n        expecting = S_COMMA_OR_EOO;\n        break;\n\n      case S_KEY:\n        if (c == '\"') {\n          int n = mg_pass_string(&s[i + 1], len - i - 1);\n          if (n < 0) return n;\n          if (i + 1 + n >= len) return MG_JSON_NOT_FOUND;\n          if (depth < ed) return MG_JSON_NOT_FOUND;\n          if (depth == ed && path[pos - 1] != '.') return MG_JSON_NOT_FOUND;\n          // printf(\"K %s [%.*s] [%.*s] %d %d %d\\n\", path, pos, path, n,\n          //  &s[i + 1], n, depth, ed);\n          // NOTE(cpq): in the check sequence below is important.\n          // strncmp() must go first: it fails fast if the remaining length of\n          // the path is smaller than `n`.\n          if (depth == ed && path[pos - 1] == '.' &&\n              strncmp(&s[i + 1], &path[pos], (size_t) n) == 0 &&\n              (path[pos + n] == '\\0' || path[pos + n] == '.' ||\n               path[pos + n] == '[')) {\n            pos += n;\n          }\n          i += n + 1;\n          expecting = S_COLON;\n        } else if (c == '}') {  // Empty object\n          MG_EOO('}');\n          expecting = S_COMMA_OR_EOO;\n        } else {\n          return MG_JSON_INVALID;\n        }\n        break;\n\n      case S_COLON:\n        if (c == ':') {\n          expecting = S_VALUE;\n        } else {\n          return MG_JSON_INVALID;\n        }\n        break;\n\n      case S_COMMA_OR_EOO:\n        if (depth <= 0) {\n          return MG_JSON_INVALID;\n        } else if (c == ',') {\n          expecting = (nesting[depth - 1] == '{') ? S_KEY : S_VALUE;\n        } else if (c == ']' || c == '}') {\n          MG_EOO('O');\n          if (depth == ed && ei >= 0) ci++;\n        } else {\n          return MG_JSON_INVALID;\n        }\n        break;\n    }\n  }\n  return MG_JSON_NOT_FOUND;\n}\n\nbool mg_json_get_num(struct mg_str json, const char *path, double *v) {\n  int n, toklen, found = 0;\n  if ((n = mg_json_get(json, path, &toklen)) >= 0 &&\n      (json.ptr[n] == '-' || (json.ptr[n] >= '0' && json.ptr[n] <= '9'))) {\n    if (v != NULL) *v = mg_atod(json.ptr + n, toklen, NULL);\n    found = 1;\n  }\n  return found;\n}\n\nbool mg_json_get_bool(struct mg_str json, const char *path, bool *v) {\n  int found = 0, off = mg_json_get(json, path, NULL);\n  if (off >= 0 && (json.ptr[off] == 't' || json.ptr[off] == 'f')) {\n    if (v != NULL) *v = json.ptr[off] == 't';\n    found = 1;\n  }\n  return found;\n}\n\nstatic bool json_unescape(const char *s, size_t len, char *to, size_t n) {\n  size_t i, j;\n  for (i = 0, j = 0; i < len && j < n; i++, j++) {\n    if (s[i] == '\\\\' && i + 5 < len && s[i + 1] == 'u') {\n      //  \\uXXXX escape. We could process a simple one-byte chars\n      // \\u00xx from the ASCII range. More complex chars would require\n      // dragging in a UTF8 library, which is too much for us\n      if (s[i + 2] != '0' || s[i + 3] != '0') return false;  // Give up\n      ((unsigned char *) to)[j] = (unsigned char) mg_unhexn(s + i + 4, 2);\n\n      i += 5;\n    } else if (s[i] == '\\\\' && i + 1 < len) {\n      char c = json_esc(s[i + 1], 0);\n      if (c == 0) return false;\n      to[j] = c;\n      i++;\n    } else {\n      to[j] = s[i];\n    }\n  }\n  if (j >= n) return false;\n  if (n > 0) to[j] = '\\0';\n  return true;\n}\n\nchar *mg_json_get_str(struct mg_str json, const char *path) {\n  char *result = NULL;\n  int len = 0, off = mg_json_get(json, path, &len);\n  if (off >= 0 && len > 1 && json.ptr[off] == '\"') {\n    if ((result = (char *) calloc(1, (size_t) len)) != NULL &&\n        !json_unescape(json.ptr + off + 1, (size_t) (len - 2), result,\n                       (size_t) len)) {\n      free(result);\n      result = NULL;\n    }\n  }\n  return result;\n}\n\nchar *mg_json_get_b64(struct mg_str json, const char *path, int *slen) {\n  char *result = NULL;\n  int len = 0, off = mg_json_get(json, path, &len);\n  if (off >= 0 && json.ptr[off] == '\"' && len > 1 &&\n      (result = (char *) calloc(1, (size_t) len)) != NULL) {\n    int k = mg_base64_decode(json.ptr + off + 1, len - 2, result);\n    if (slen != NULL) *slen = k;\n  }\n  return result;\n}\n\nchar *mg_json_get_hex(struct mg_str json, const char *path, int *slen) {\n  char *result = NULL;\n  int len = 0, off = mg_json_get(json, path, &len);\n  if (off >= 0 && json.ptr[off] == '\"' && len > 1 &&\n      (result = (char *) calloc(1, (size_t) len / 2)) != NULL) {\n    mg_unhex(json.ptr + off + 1, (size_t) (len - 2), (uint8_t *) result);\n    result[len / 2 - 1] = '\\0';\n    if (slen != NULL) *slen = len / 2 - 1;\n  }\n  return result;\n}\n\nlong mg_json_get_long(struct mg_str json, const char *path, long dflt) {\n  double dv;\n  long result = dflt;\n  if (mg_json_get_num(json, path, &dv)) result = (long) dv;\n  return result;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/log.c\"\n#endif\n\n\n\n\n\nstatic int s_level = MG_LL_INFO;\nstatic mg_pfn_t s_log_func = mg_pfn_stdout;\nstatic void *s_log_func_param = NULL;\n\nvoid mg_log_set_fn(mg_pfn_t fn, void *param) {\n  s_log_func = fn;\n  s_log_func_param = param;\n}\n\nstatic void logc(unsigned char c) {\n  s_log_func((char) c, s_log_func_param);\n}\n\nstatic void logs(const char *buf, size_t len) {\n  size_t i;\n  for (i = 0; i < len; i++) logc(((unsigned char *) buf)[i]);\n}\n\nvoid mg_log_set(int log_level) {\n  MG_DEBUG((\"Setting log level to %d\", log_level));\n  s_level = log_level;\n}\n\nbool mg_log_prefix(int level, const char *file, int line, const char *fname) {\n  if (level <= s_level) {\n    const char *p = strrchr(file, '/');\n    char buf[41];\n    size_t n;\n    if (p == NULL) p = strrchr(file, '\\\\');\n    n = mg_snprintf(buf, sizeof(buf), \"%-6llx %d %s:%d:%s\", mg_millis(), level,\n                    p == NULL ? file : p + 1, line, fname);\n    if (n > sizeof(buf) - 2) n = sizeof(buf) - 2;\n    while (n < sizeof(buf)) buf[n++] = ' ';\n    logs(buf, n - 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid mg_log(const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  mg_vxprintf(s_log_func, s_log_func_param, fmt, &ap);\n  va_end(ap);\n  logc((unsigned char) '\\n');\n}\n\nstatic unsigned char nibble(unsigned c) {\n  return (unsigned char) (c < 10 ? c + '0' : c + 'W');\n}\n\n#define ISPRINT(x) ((x) >= ' ' && (x) <= '~')\nvoid mg_hexdump(const void *buf, size_t len) {\n  const unsigned char *p = (const unsigned char *) buf;\n  unsigned char ascii[16], alen = 0;\n  size_t i;\n  for (i = 0; i < len; i++) {\n    if ((i % 16) == 0) {\n      // Print buffered ascii chars\n      if (i > 0) logs(\"  \", 2), logs((char *) ascii, 16), logc('\\n'), alen = 0;\n      // Print hex address, then \\t\n      logc(nibble((i >> 12) & 15)), logc(nibble((i >> 8) & 15)),\n          logc(nibble((i >> 4) & 15)), logc('0'), logs(\"   \", 3);\n    }\n    logc(nibble(p[i] >> 4)), logc(nibble(p[i] & 15));  // Two nibbles, e.g. c5\n    logc(' ');                                         // Space after hex number\n    ascii[alen++] = ISPRINT(p[i]) ? p[i] : '.';        // Add to the ascii buf\n  }\n  while (alen < 16) logs(\"   \", 3), ascii[alen++] = ' ';\n  logs(\"  \", 2), logs((char *) ascii, 16), logc('\\n');\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/md5.c\"\n#endif\n\n\n\n#if defined(MG_ENABLE_MD5) && MG_ENABLE_MD5\n\nstatic void mg_byte_reverse(unsigned char *buf, unsigned longs) {\n  if (MG_BIG_ENDIAN) {\n    do {\n      uint32_t t = (uint32_t) ((unsigned) buf[3] << 8 | buf[2]) << 16 |\n                   ((unsigned) buf[1] << 8 | buf[0]);\n      *(uint32_t *) buf = t;\n      buf += 4;\n    } while (--longs);\n  } else {\n    (void) buf, (void) longs;  // Little endian. Do nothing\n  }\n}\n\n#define F1(x, y, z) (z ^ (x & (y ^ z)))\n#define F2(x, y, z) F1(z, x, y)\n#define F3(x, y, z) (x ^ y ^ z)\n#define F4(x, y, z) (y ^ (x | ~z))\n\n#define MD5STEP(f, w, x, y, z, data, s) \\\n  (w += f(x, y, z) + data, w = w << s | w >> (32 - s), w += x)\n\n/*\n * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious\n * initialization constants.\n */\nvoid mg_md5_init(mg_md5_ctx *ctx) {\n  ctx->buf[0] = 0x67452301;\n  ctx->buf[1] = 0xefcdab89;\n  ctx->buf[2] = 0x98badcfe;\n  ctx->buf[3] = 0x10325476;\n\n  ctx->bits[0] = 0;\n  ctx->bits[1] = 0;\n}\n\nstatic void mg_md5_transform(uint32_t buf[4], uint32_t const in[16]) {\n  uint32_t a, b, c, d;\n\n  a = buf[0];\n  b = buf[1];\n  c = buf[2];\n  d = buf[3];\n\n  MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);\n  MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);\n  MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);\n  MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);\n  MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);\n  MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);\n  MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);\n  MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);\n  MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);\n  MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);\n  MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);\n  MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);\n  MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);\n  MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);\n  MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);\n  MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);\n\n  MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);\n  MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);\n  MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);\n  MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);\n  MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);\n  MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);\n  MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);\n  MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);\n  MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);\n  MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);\n  MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);\n  MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);\n  MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);\n  MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);\n  MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);\n  MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);\n\n  MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);\n  MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);\n  MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);\n  MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);\n  MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);\n  MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);\n  MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);\n  MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);\n  MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);\n  MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);\n  MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);\n  MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);\n  MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);\n  MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);\n  MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);\n  MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);\n\n  MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);\n  MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);\n  MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);\n  MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);\n  MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);\n  MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);\n  MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);\n  MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);\n  MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);\n  MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);\n  MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);\n  MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);\n  MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);\n  MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);\n  MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);\n  MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);\n\n  buf[0] += a;\n  buf[1] += b;\n  buf[2] += c;\n  buf[3] += d;\n}\n\nvoid mg_md5_update(mg_md5_ctx *ctx, const unsigned char *buf, size_t len) {\n  uint32_t t;\n\n  t = ctx->bits[0];\n  if ((ctx->bits[0] = t + ((uint32_t) len << 3)) < t) ctx->bits[1]++;\n  ctx->bits[1] += (uint32_t) len >> 29;\n\n  t = (t >> 3) & 0x3f;\n\n  if (t) {\n    unsigned char *p = (unsigned char *) ctx->in + t;\n\n    t = 64 - t;\n    if (len < t) {\n      memcpy(p, buf, len);\n      return;\n    }\n    memcpy(p, buf, t);\n    mg_byte_reverse(ctx->in, 16);\n    mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);\n    buf += t;\n    len -= t;\n  }\n\n  while (len >= 64) {\n    memcpy(ctx->in, buf, 64);\n    mg_byte_reverse(ctx->in, 16);\n    mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);\n    buf += 64;\n    len -= 64;\n  }\n\n  memcpy(ctx->in, buf, len);\n}\n\nvoid mg_md5_final(mg_md5_ctx *ctx, unsigned char digest[16]) {\n  unsigned count;\n  unsigned char *p;\n  uint32_t *a;\n\n  count = (ctx->bits[0] >> 3) & 0x3F;\n\n  p = ctx->in + count;\n  *p++ = 0x80;\n  count = 64 - 1 - count;\n  if (count < 8) {\n    memset(p, 0, count);\n    mg_byte_reverse(ctx->in, 16);\n    mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);\n    memset(ctx->in, 0, 56);\n  } else {\n    memset(p, 0, count - 8);\n  }\n  mg_byte_reverse(ctx->in, 14);\n\n  a = (uint32_t *) ctx->in;\n  a[14] = ctx->bits[0];\n  a[15] = ctx->bits[1];\n\n  mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);\n  mg_byte_reverse((unsigned char *) ctx->buf, 4);\n  memcpy(digest, ctx->buf, 16);\n  memset((char *) ctx, 0, sizeof(*ctx));\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/mqtt.c\"\n#endif\n\n\n\n\n\n\n\n\n#define MQTT_CLEAN_SESSION 0x02\n#define MQTT_HAS_WILL 0x04\n#define MQTT_WILL_RETAIN 0x20\n#define MQTT_HAS_PASSWORD 0x40\n#define MQTT_HAS_USER_NAME 0x80\n\nstruct mg_mqtt_pmap {\n  uint8_t id;\n  uint8_t type;\n};\n\nstatic const struct mg_mqtt_pmap s_prop_map[] = {\n    {MQTT_PROP_PAYLOAD_FORMAT_INDICATOR, MQTT_PROP_TYPE_BYTE},\n    {MQTT_PROP_MESSAGE_EXPIRY_INTERVAL, MQTT_PROP_TYPE_INT},\n    {MQTT_PROP_CONTENT_TYPE, MQTT_PROP_TYPE_STRING},\n    {MQTT_PROP_RESPONSE_TOPIC, MQTT_PROP_TYPE_STRING},\n    {MQTT_PROP_CORRELATION_DATA, MQTT_PROP_TYPE_BINARY_DATA},\n    {MQTT_PROP_SUBSCRIPTION_IDENTIFIER, MQTT_PROP_TYPE_VARIABLE_INT},\n    {MQTT_PROP_SESSION_EXPIRY_INTERVAL, MQTT_PROP_TYPE_INT},\n    {MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, MQTT_PROP_TYPE_STRING},\n    {MQTT_PROP_SERVER_KEEP_ALIVE, MQTT_PROP_TYPE_SHORT},\n    {MQTT_PROP_AUTHENTICATION_METHOD, MQTT_PROP_TYPE_STRING},\n    {MQTT_PROP_AUTHENTICATION_DATA, MQTT_PROP_TYPE_BINARY_DATA},\n    {MQTT_PROP_REQUEST_PROBLEM_INFORMATION, MQTT_PROP_TYPE_BYTE},\n    {MQTT_PROP_WILL_DELAY_INTERVAL, MQTT_PROP_TYPE_INT},\n    {MQTT_PROP_REQUEST_RESPONSE_INFORMATION, MQTT_PROP_TYPE_BYTE},\n    {MQTT_PROP_RESPONSE_INFORMATION, MQTT_PROP_TYPE_STRING},\n    {MQTT_PROP_SERVER_REFERENCE, MQTT_PROP_TYPE_STRING},\n    {MQTT_PROP_REASON_STRING, MQTT_PROP_TYPE_STRING},\n    {MQTT_PROP_RECEIVE_MAXIMUM, MQTT_PROP_TYPE_SHORT},\n    {MQTT_PROP_TOPIC_ALIAS_MAXIMUM, MQTT_PROP_TYPE_SHORT},\n    {MQTT_PROP_TOPIC_ALIAS, MQTT_PROP_TYPE_SHORT},\n    {MQTT_PROP_MAXIMUM_QOS, MQTT_PROP_TYPE_BYTE},\n    {MQTT_PROP_RETAIN_AVAILABLE, MQTT_PROP_TYPE_BYTE},\n    {MQTT_PROP_USER_PROPERTY, MQTT_PROP_TYPE_STRING_PAIR},\n    {MQTT_PROP_MAXIMUM_PACKET_SIZE, MQTT_PROP_TYPE_INT},\n    {MQTT_PROP_WILDCARD_SUBSCRIPTION_AVAILABLE, MQTT_PROP_TYPE_BYTE},\n    {MQTT_PROP_SUBSCRIPTION_IDENTIFIER_AVAILABLE, MQTT_PROP_TYPE_BYTE},\n    {MQTT_PROP_SHARED_SUBSCRIPTION_AVAILABLE, MQTT_PROP_TYPE_BYTE}};\n\nvoid mg_mqtt_send_header(struct mg_connection *c, uint8_t cmd, uint8_t flags,\n                         uint32_t len) {\n  uint8_t buf[1 + sizeof(len)], *vlen = &buf[1];\n  buf[0] = (uint8_t) ((cmd << 4) | flags);\n  do {\n    *vlen = len % 0x80;\n    len /= 0x80;\n    if (len > 0) *vlen |= 0x80;\n    vlen++;\n  } while (len > 0 && vlen < &buf[sizeof(buf)]);\n  mg_send(c, buf, (size_t) (vlen - buf));\n}\n\nstatic void mg_send_u16(struct mg_connection *c, uint16_t value) {\n  mg_send(c, &value, sizeof(value));\n}\n\nstatic void mg_send_u32(struct mg_connection *c, uint32_t value) {\n  mg_send(c, &value, sizeof(value));\n}\n\nstatic uint8_t compute_variable_length_size(size_t length) {\n  uint8_t bytes_needed = 0;\n  do {\n    bytes_needed++;\n    length /= 0x80;\n  } while (length > 0);\n  return bytes_needed;\n}\n\nstatic int encode_variable_length(uint8_t *buf, size_t value) {\n  int len = 0;\n\n  do {\n    uint8_t byte = (uint8_t) (value % 128);\n    value /= 128;\n    if (value > 0) byte |= 0x80;\n    buf[len++] = byte;\n  } while (value > 0);\n\n  return len;\n}\n\nstatic uint32_t decode_variable_length(const char *buf,\n                                       uint32_t *bytes_consumed) {\n  uint32_t value = 0, multiplier = 1, offset;\n\n  for (offset = 0; offset < 4; offset++) {\n    uint8_t encoded_byte = ((uint8_t *) buf)[offset];\n    value += (encoded_byte & 0x7F) * multiplier;\n    multiplier *= 128;\n\n    if (!(encoded_byte & 0x80)) break;\n  }\n\n  if (bytes_consumed != NULL) *bytes_consumed = offset + 1;\n\n  return value;\n}\n\nstatic int mqtt_prop_type_by_id(uint8_t prop_id) {\n  size_t i, num_properties = sizeof(s_prop_map) / sizeof(s_prop_map[0]);\n  for (i = 0; i < num_properties; ++i) {\n    if (s_prop_map[i].id == prop_id) return s_prop_map[i].type;\n  }\n  return -1;  // Property ID not found\n}\n\n// Returns the size of the properties section, without the\n// size of the content's length\nstatic size_t get_properties_length(struct mg_mqtt_prop *props, size_t count) {\n  size_t i, size = 0;\n  for (i = 0; i < count; i++) {\n    size++;  // identifier\n    switch (mqtt_prop_type_by_id(props[i].id)) {\n      case MQTT_PROP_TYPE_STRING_PAIR:\n        size += (uint32_t) (props[i].val.len + props[i].key.len +\n                            2 * sizeof(uint16_t));\n        break;\n      case MQTT_PROP_TYPE_STRING:\n        size += (uint32_t) (props[i].val.len + sizeof(uint16_t));\n        break;\n      case MQTT_PROP_TYPE_BINARY_DATA:\n        size += (uint32_t) (props[i].val.len + sizeof(uint16_t));\n        break;\n      case MQTT_PROP_TYPE_VARIABLE_INT:\n        size += compute_variable_length_size((uint32_t) props[i].iv);\n        break;\n      case MQTT_PROP_TYPE_INT: size += (uint32_t) sizeof(uint32_t); break;\n      case MQTT_PROP_TYPE_SHORT: size += (uint32_t) sizeof(uint16_t); break;\n      default: return size;  // cannot parse further down\n    }\n  }\n\n  return size;\n}\n\n// returns the entire size of the properties section, including the\n// size of the variable length of the content\nstatic size_t get_props_size(struct mg_mqtt_prop *props, size_t count) {\n  size_t size = get_properties_length(props, count);\n  size += compute_variable_length_size(size);\n  return size;\n}\n\nstatic void mg_send_mqtt_properties(struct mg_connection *c,\n                                    struct mg_mqtt_prop *props, size_t nprops) {\n  size_t total_size = get_properties_length(props, nprops);\n  uint8_t buf_v[4] = {0, 0, 0, 0};\n  uint8_t buf[4] = {0, 0, 0, 0};\n  int i, len = encode_variable_length(buf, total_size);\n\n  mg_send(c, buf, (size_t) len);\n  for (i = 0; i < (int) nprops; i++) {\n    mg_send(c, &props[i].id, sizeof(props[i].id));\n    switch (mqtt_prop_type_by_id(props[i].id)) {\n      case MQTT_PROP_TYPE_STRING_PAIR:\n        mg_send_u16(c, mg_htons((uint16_t) props[i].key.len));\n        mg_send(c, props[i].key.ptr, props[i].key.len);\n        mg_send_u16(c, mg_htons((uint16_t) props[i].val.len));\n        mg_send(c, props[i].val.ptr, props[i].val.len);\n        break;\n      case MQTT_PROP_TYPE_BYTE:\n        mg_send(c, &props[i].iv, sizeof(uint8_t));\n        break;\n      case MQTT_PROP_TYPE_SHORT:\n        mg_send_u16(c, mg_htons((uint16_t) props[i].iv));\n        break;\n      case MQTT_PROP_TYPE_INT:\n        mg_send_u32(c, mg_htonl((uint32_t) props[i].iv));\n        break;\n      case MQTT_PROP_TYPE_STRING:\n        mg_send_u16(c, mg_htons((uint16_t) props[i].val.len));\n        mg_send(c, props[i].val.ptr, props[i].val.len);\n        break;\n      case MQTT_PROP_TYPE_BINARY_DATA:\n        mg_send_u16(c, mg_htons((uint16_t) props[i].val.len));\n        mg_send(c, props[i].val.ptr, props[i].val.len);\n        break;\n      case MQTT_PROP_TYPE_VARIABLE_INT:\n        len = encode_variable_length(buf_v, props[i].iv);\n        mg_send(c, buf_v, (size_t) len);\n        break;\n    }\n  }\n}\n\nsize_t mg_mqtt_next_prop(struct mg_mqtt_message *msg, struct mg_mqtt_prop *prop,\n                         size_t ofs) {\n  uint8_t *i = (uint8_t *) msg->dgram.ptr + msg->props_start + ofs;\n  size_t new_pos = ofs;\n  uint32_t bytes_consumed;\n  prop->id = i[0];\n\n  if (ofs >= msg->dgram.len || ofs >= msg->props_start + msg->props_size)\n    return 0;\n  i++, new_pos++;\n\n  switch (mqtt_prop_type_by_id(prop->id)) {\n    case MQTT_PROP_TYPE_STRING_PAIR:\n      prop->key.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);\n      prop->key.ptr = (char *) i + 2;\n      i += 2 + prop->key.len;\n      prop->val.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);\n      prop->val.ptr = (char *) i + 2;\n      new_pos += 2 * sizeof(uint16_t) + prop->val.len + prop->key.len;\n      break;\n    case MQTT_PROP_TYPE_BYTE:\n      prop->iv = (uint8_t) i[0];\n      new_pos++;\n      break;\n    case MQTT_PROP_TYPE_SHORT:\n      prop->iv = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);\n      new_pos += sizeof(uint16_t);\n      break;\n    case MQTT_PROP_TYPE_INT:\n      prop->iv = ((uint32_t) i[0] << 24) | ((uint32_t) i[1] << 16) |\n                 ((uint32_t) i[2] << 8) | i[3];\n      new_pos += sizeof(uint32_t);\n      break;\n    case MQTT_PROP_TYPE_STRING:\n      prop->val.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);\n      prop->val.ptr = (char *) i + 2;\n      new_pos += 2 + prop->val.len;\n      break;\n    case MQTT_PROP_TYPE_BINARY_DATA:\n      prop->val.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);\n      prop->val.ptr = (char *) i + 2;\n      new_pos += 2 + prop->val.len;\n      break;\n    case MQTT_PROP_TYPE_VARIABLE_INT:\n      prop->iv = decode_variable_length((char *) i, &bytes_consumed);\n      new_pos += bytes_consumed;\n      break;\n    default: new_pos = 0;\n  }\n\n  return new_pos;\n}\n\nvoid mg_mqtt_login(struct mg_connection *c, const struct mg_mqtt_opts *opts) {\n  char rnd[10], client_id[21];\n  struct mg_str cid = opts->client_id;\n  size_t total_len = 7 + 1 + 2 + 2;\n  uint8_t hdr[8] = {0, 4, 'M', 'Q', 'T', 'T', opts->version, 0};\n\n  if (cid.len == 0) {\n    mg_random(rnd, sizeof(rnd));\n    mg_hex(rnd, sizeof(rnd), client_id);\n    client_id[sizeof(client_id) - 1] = '\\0';\n    cid = mg_str(client_id);\n  }\n\n  if (hdr[6] == 0) hdr[6] = 4;  // If version is not set, use 4 (3.1.1)\n  c->is_mqtt5 = hdr[6] == 5;    // Set version 5 flag\n  hdr[7] = (uint8_t) ((opts->qos & 3) << 3);  // Connection flags\n  if (opts->user.len > 0) {\n    total_len += 2 + (uint32_t) opts->user.len;\n    hdr[7] |= MQTT_HAS_USER_NAME;\n  }\n  if (opts->pass.len > 0) {\n    total_len += 2 + (uint32_t) opts->pass.len;\n    hdr[7] |= MQTT_HAS_PASSWORD;\n  }\n  if (opts->topic.len > 0 && opts->message.len > 0) {\n    total_len += 4 + (uint32_t) opts->topic.len + (uint32_t) opts->message.len;\n    hdr[7] |= MQTT_HAS_WILL;\n  }\n  if (opts->clean || cid.len == 0) hdr[7] |= MQTT_CLEAN_SESSION;\n  if (opts->retain) hdr[7] |= MQTT_WILL_RETAIN;\n  total_len += (uint32_t) cid.len;\n  if (c->is_mqtt5) {\n    total_len += get_props_size(opts->props, opts->num_props);\n    if (hdr[7] & MQTT_HAS_WILL)\n      total_len += get_props_size(opts->will_props, opts->num_will_props);\n  }\n\n  mg_mqtt_send_header(c, MQTT_CMD_CONNECT, 0, (uint32_t) total_len);\n  mg_send(c, hdr, sizeof(hdr));\n  // keepalive == 0 means \"do not disconnect us!\"\n  mg_send_u16(c, mg_htons((uint16_t) opts->keepalive));\n\n  if (c->is_mqtt5) mg_send_mqtt_properties(c, opts->props, opts->num_props);\n\n  mg_send_u16(c, mg_htons((uint16_t) cid.len));\n  mg_send(c, cid.ptr, cid.len);\n\n  if (hdr[7] & MQTT_HAS_WILL) {\n    if (c->is_mqtt5)\n      mg_send_mqtt_properties(c, opts->will_props, opts->num_will_props);\n\n    mg_send_u16(c, mg_htons((uint16_t) opts->topic.len));\n    mg_send(c, opts->topic.ptr, opts->topic.len);\n    mg_send_u16(c, mg_htons((uint16_t) opts->message.len));\n    mg_send(c, opts->message.ptr, opts->message.len);\n  }\n  if (opts->user.len > 0) {\n    mg_send_u16(c, mg_htons((uint16_t) opts->user.len));\n    mg_send(c, opts->user.ptr, opts->user.len);\n  }\n  if (opts->pass.len > 0) {\n    mg_send_u16(c, mg_htons((uint16_t) opts->pass.len));\n    mg_send(c, opts->pass.ptr, opts->pass.len);\n  }\n}\n\nvoid mg_mqtt_pub(struct mg_connection *c, const struct mg_mqtt_opts *opts) {\n  uint8_t flags = (uint8_t) (((opts->qos & 3) << 1) | (opts->retain ? 1 : 0));\n  size_t len = 2 + opts->topic.len + opts->message.len;\n  MG_DEBUG((\"%lu [%.*s] -> [%.*s]\", c->id, (int) opts->topic.len,\n            (char *) opts->topic.ptr, (int) opts->message.len,\n            (char *) opts->message.ptr));\n  if (opts->qos > 0) len += 2;\n  if (c->is_mqtt5) len += get_props_size(opts->props, opts->num_props);\n\n  mg_mqtt_send_header(c, MQTT_CMD_PUBLISH, flags, (uint32_t) len);\n  mg_send_u16(c, mg_htons((uint16_t) opts->topic.len));\n  mg_send(c, opts->topic.ptr, opts->topic.len);\n  if (opts->qos > 0) {\n    if (++c->mgr->mqtt_id == 0) ++c->mgr->mqtt_id;\n    mg_send_u16(c, mg_htons(c->mgr->mqtt_id));\n  }\n\n  if (c->is_mqtt5) mg_send_mqtt_properties(c, opts->props, opts->num_props);\n\n  mg_send(c, opts->message.ptr, opts->message.len);\n}\n\nvoid mg_mqtt_sub(struct mg_connection *c, const struct mg_mqtt_opts *opts) {\n  uint8_t qos_ = opts->qos & 3;\n  size_t plen = c->is_mqtt5 ? get_props_size(opts->props, opts->num_props) : 0;\n  size_t len = 2 + opts->topic.len + 2 + 1 + plen;\n\n  mg_mqtt_send_header(c, MQTT_CMD_SUBSCRIBE, 2, (uint32_t) len);\n  if (++c->mgr->mqtt_id == 0) ++c->mgr->mqtt_id;\n  mg_send_u16(c, mg_htons(c->mgr->mqtt_id));\n  if (c->is_mqtt5) mg_send_mqtt_properties(c, opts->props, opts->num_props);\n\n  mg_send_u16(c, mg_htons((uint16_t) opts->topic.len));\n  mg_send(c, opts->topic.ptr, opts->topic.len);\n  mg_send(c, &qos_, sizeof(qos_));\n}\n\nint mg_mqtt_parse(const uint8_t *buf, size_t len, uint8_t version,\n                  struct mg_mqtt_message *m) {\n  uint8_t lc = 0, *p, *end;\n  uint32_t n = 0, len_len = 0;\n\n  memset(m, 0, sizeof(*m));\n  m->dgram.ptr = (char *) buf;\n  if (len < 2) return MQTT_INCOMPLETE;\n  m->cmd = (uint8_t) (buf[0] >> 4);\n  m->qos = (buf[0] >> 1) & 3;\n\n  n = len_len = 0;\n  p = (uint8_t *) buf + 1;\n  while ((size_t) (p - buf) < len) {\n    lc = *((uint8_t *) p++);\n    n += (uint32_t) ((lc & 0x7f) << 7 * len_len);\n    len_len++;\n    if (!(lc & 0x80)) break;\n    if (len_len >= 4) return MQTT_MALFORMED;\n  }\n  end = p + n;\n  if ((lc & 0x80) || (end > buf + len)) return MQTT_INCOMPLETE;\n  m->dgram.len = (size_t) (end - buf);\n\n  switch (m->cmd) {\n    case MQTT_CMD_CONNACK:\n      if (end - p < 2) return MQTT_MALFORMED;\n      m->ack = p[1];\n      break;\n    case MQTT_CMD_PUBACK:\n    case MQTT_CMD_PUBREC:\n    case MQTT_CMD_PUBREL:\n    case MQTT_CMD_PUBCOMP:\n    case MQTT_CMD_SUBSCRIBE:\n    case MQTT_CMD_SUBACK:\n    case MQTT_CMD_UNSUBSCRIBE:\n    case MQTT_CMD_UNSUBACK:\n      if (p + 2 > end) return MQTT_MALFORMED;\n      m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);\n      p += 2;\n      break;\n    case MQTT_CMD_PUBLISH: {\n      if (p + 2 > end) return MQTT_MALFORMED;\n      m->topic.len = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);\n      m->topic.ptr = (char *) p + 2;\n      p += 2 + m->topic.len;\n      if (p > end) return MQTT_MALFORMED;\n      if (m->qos > 0) {\n        if (p + 2 > end) return MQTT_MALFORMED;\n        m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);\n        p += 2;\n      }\n      if (p > end) return MQTT_MALFORMED;\n      if (version == 5 && p + 2 < end) {\n        m->props_size = decode_variable_length((char *) p, &len_len);\n        m->props_start = (size_t) (p + len_len - buf);\n        p += len_len + m->props_size;\n      }\n      if (p > end) return MQTT_MALFORMED;\n      m->data.ptr = (char *) p;\n      m->data.len = (size_t) (end - p);\n      break;\n    }\n    default: break;\n  }\n  return MQTT_OK;\n}\n\nstatic void mqtt_cb(struct mg_connection *c, int ev, void *ev_data,\n                    void *fn_data) {\n  if (ev == MG_EV_READ) {\n    for (;;) {\n      uint8_t version = c->is_mqtt5 ? 5 : 4;\n      struct mg_mqtt_message mm;\n      int rc = mg_mqtt_parse(c->recv.buf, c->recv.len, version, &mm);\n      if (rc == MQTT_MALFORMED) {\n        MG_ERROR((\"%lu MQTT malformed message\", c->id));\n        c->is_closing = 1;\n        break;\n      } else if (rc == MQTT_OK) {\n        MG_VERBOSE((\"%lu MQTT CMD %d len %d [%.*s]\", c->id, mm.cmd,\n                    (int) mm.dgram.len, (int) mm.data.len, mm.data.ptr));\n        switch (mm.cmd) {\n          case MQTT_CMD_CONNACK:\n            mg_call(c, MG_EV_MQTT_OPEN, &mm.ack);\n            if (mm.ack == 0) {\n              MG_DEBUG((\"%lu Connected\", c->id));\n            } else {\n              MG_ERROR((\"%lu MQTT auth failed, code %d\", c->id, mm.ack));\n              c->is_closing = 1;\n            }\n            break;\n          case MQTT_CMD_PUBLISH: {\n            MG_DEBUG((\"%lu [%.*s] -> [%.*s]\", c->id, (int) mm.topic.len,\n                      mm.topic.ptr, (int) mm.data.len, mm.data.ptr));\n            if (mm.qos > 0) {\n              uint16_t id = mg_htons(mm.id);\n              uint32_t remaining_len = sizeof(id);\n              if (c->is_mqtt5) remaining_len += 1;\n\n              mg_mqtt_send_header(c, MQTT_CMD_PUBACK, 0, remaining_len);\n              mg_send(c, &id, sizeof(id));\n\n              if (c->is_mqtt5) {\n                uint16_t zero = 0;\n                mg_send(c, &zero, sizeof(zero));\n              }\n            }\n            mg_call(c, MG_EV_MQTT_MSG, &mm);\n            break;\n          }\n        }\n        mg_call(c, MG_EV_MQTT_CMD, &mm);\n        mg_iobuf_del(&c->recv, 0, mm.dgram.len);\n      } else {\n        break;\n      }\n    }\n  }\n  (void) ev_data;\n  (void) fn_data;\n}\n\nvoid mg_mqtt_ping(struct mg_connection *nc) {\n  mg_mqtt_send_header(nc, MQTT_CMD_PINGREQ, 0, 0);\n}\n\nvoid mg_mqtt_pong(struct mg_connection *nc) {\n  mg_mqtt_send_header(nc, MQTT_CMD_PINGRESP, 0, 0);\n}\n\nvoid mg_mqtt_disconnect(struct mg_connection *c,\n                        const struct mg_mqtt_opts *opts) {\n  size_t len = 0;\n  if (c->is_mqtt5) len = 1 + get_props_size(opts->props, opts->num_props);\n  mg_mqtt_send_header(c, MQTT_CMD_DISCONNECT, 0, (uint32_t) len);\n\n  if (c->is_mqtt5) {\n    uint8_t zero = 0;\n    mg_send(c, &zero, sizeof(zero));  // reason code\n    mg_send_mqtt_properties(c, opts->props, opts->num_props);\n  }\n}\n\nstruct mg_connection *mg_mqtt_connect(struct mg_mgr *mgr, const char *url,\n                                      const struct mg_mqtt_opts *opts,\n                                      mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);\n  if (c != NULL) {\n    struct mg_mqtt_opts empty;\n    memset(&empty, 0, sizeof(empty));\n    mg_mqtt_login(c, opts == NULL ? &empty : opts);\n    c->pfn = mqtt_cb;\n  }\n  return c;\n}\n\nstruct mg_connection *mg_mqtt_listen(struct mg_mgr *mgr, const char *url,\n                                     mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = mqtt_cb, c->pfn_data = mgr;\n  return c;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/net.c\"\n#endif\n\n\n\n\n\n\n\n\nsize_t mg_vprintf(struct mg_connection *c, const char *fmt, va_list *ap) {\n  size_t old = c->send.len;\n  mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, ap);\n  return c->send.len - old;\n}\n\nsize_t mg_printf(struct mg_connection *c, const char *fmt, ...) {\n  size_t len = 0;\n  va_list ap;\n  va_start(ap, fmt);\n  len = mg_vprintf(c, fmt, &ap);\n  va_end(ap);\n  return len;\n}\n\nstatic bool mg_atonl(struct mg_str str, struct mg_addr *addr) {\n  if (mg_vcasecmp(&str, \"localhost\") != 0) return false;\n  addr->ip = mg_htonl(0x7f000001);\n  addr->is_ip6 = false;\n  return true;\n}\n\nstatic bool mg_atone(struct mg_str str, struct mg_addr *addr) {\n  if (str.len > 0) return false;\n  addr->ip = 0;\n  addr->is_ip6 = false;\n  return true;\n}\n\nstatic bool mg_aton4(struct mg_str str, struct mg_addr *addr) {\n  uint8_t data[4] = {0, 0, 0, 0};\n  size_t i, num_dots = 0;\n  for (i = 0; i < str.len; i++) {\n    if (str.ptr[i] >= '0' && str.ptr[i] <= '9') {\n      int octet = data[num_dots] * 10 + (str.ptr[i] - '0');\n      if (octet > 255) return false;\n      data[num_dots] = (uint8_t) octet;\n    } else if (str.ptr[i] == '.') {\n      if (num_dots >= 3 || i == 0 || str.ptr[i - 1] == '.') return false;\n      num_dots++;\n    } else {\n      return false;\n    }\n  }\n  if (num_dots != 3 || str.ptr[i - 1] == '.') return false;\n  memcpy(&addr->ip, data, sizeof(data));\n  addr->is_ip6 = false;\n  return true;\n}\n\nstatic bool mg_v4mapped(struct mg_str str, struct mg_addr *addr) {\n  int i;\n  if (str.len < 14) return false;\n  if (str.ptr[0] != ':' || str.ptr[1] != ':' || str.ptr[6] != ':') return false;\n  for (i = 2; i < 6; i++) {\n    if (str.ptr[i] != 'f' && str.ptr[i] != 'F') return false;\n  }\n  if (!mg_aton4(mg_str_n(&str.ptr[7], str.len - 7), addr)) return false;\n  memset(addr->ip6, 0, sizeof(addr->ip6));\n  addr->ip6[10] = addr->ip6[11] = 255;\n  memcpy(&addr->ip6[12], &addr->ip, 4);\n  addr->is_ip6 = true;\n  return true;\n}\n\nstatic bool mg_aton6(struct mg_str str, struct mg_addr *addr) {\n  size_t i, j = 0, n = 0, dc = 42;\n  if (str.len > 2 && str.ptr[0] == '[') str.ptr++, str.len -= 2;\n  if (mg_v4mapped(str, addr)) return true;\n  for (i = 0; i < str.len; i++) {\n    if ((str.ptr[i] >= '0' && str.ptr[i] <= '9') ||\n        (str.ptr[i] >= 'a' && str.ptr[i] <= 'f') ||\n        (str.ptr[i] >= 'A' && str.ptr[i] <= 'F')) {\n      unsigned long val;\n      if (i > j + 3) return false;\n      // MG_DEBUG((\"%zu %zu [%.*s]\", i, j, (int) (i - j + 1), &str.ptr[j]));\n      val = mg_unhexn(&str.ptr[j], i - j + 1);\n      addr->ip6[n] = (uint8_t) ((val >> 8) & 255);\n      addr->ip6[n + 1] = (uint8_t) (val & 255);\n    } else if (str.ptr[i] == ':') {\n      j = i + 1;\n      if (i > 0 && str.ptr[i - 1] == ':') {\n        dc = n;  // Double colon\n        if (i > 1 && str.ptr[i - 2] == ':') return false;\n      } else if (i > 0) {\n        n += 2;\n      }\n      if (n > 14) return false;\n      addr->ip6[n] = addr->ip6[n + 1] = 0;  // For trailing ::\n    } else {\n      return false;\n    }\n  }\n  if (n < 14 && dc == 42) return false;\n  if (n < 14) {\n    memmove(&addr->ip6[dc + (14 - n)], &addr->ip6[dc], n - dc + 2);\n    memset(&addr->ip6[dc], 0, 14 - n);\n  }\n  addr->is_ip6 = true;\n  return true;\n}\n\nbool mg_aton(struct mg_str str, struct mg_addr *addr) {\n  // MG_INFO((\"[%.*s]\", (int) str.len, str.ptr));\n  return mg_atone(str, addr) || mg_atonl(str, addr) || mg_aton4(str, addr) ||\n         mg_aton6(str, addr);\n}\n\nstruct mg_connection *mg_alloc_conn(struct mg_mgr *mgr) {\n  struct mg_connection *c =\n      (struct mg_connection *) calloc(1, sizeof(*c) + mgr->extraconnsize);\n  if (c != NULL) {\n    c->mgr = mgr;\n    c->send.align = c->recv.align = MG_IO_SIZE;\n    c->id = ++mgr->nextid;\n  }\n  return c;\n}\n\nvoid mg_close_conn(struct mg_connection *c) {\n  mg_resolve_cancel(c);  // Close any pending DNS query\n  LIST_DELETE(struct mg_connection, &c->mgr->conns, c);\n  if (c == c->mgr->dns4.c) c->mgr->dns4.c = NULL;\n  if (c == c->mgr->dns6.c) c->mgr->dns6.c = NULL;\n  // Order of operations is important. `MG_EV_CLOSE` event must be fired\n  // before we deallocate received data, see #1331\n  mg_call(c, MG_EV_CLOSE, NULL);\n  MG_DEBUG((\"%lu %p closed\", c->id, c->fd));\n\n  mg_tls_free(c);\n  mg_iobuf_free(&c->recv);\n  mg_iobuf_free(&c->send);\n  memset(c, 0, sizeof(*c));\n  free(c);\n}\n\nstruct mg_connection *mg_connect(struct mg_mgr *mgr, const char *url,\n                                 mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = NULL;\n  if (url == NULL || url[0] == '\\0') {\n    MG_ERROR((\"null url\"));\n  } else if ((c = mg_alloc_conn(mgr)) == NULL) {\n    MG_ERROR((\"OOM\"));\n  } else {\n    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);\n    c->is_udp = (strncmp(url, \"udp:\", 4) == 0);\n    c->fd = (void *) (size_t) MG_INVALID_SOCKET;\n    c->fn = fn;\n    c->is_client = true;\n    c->fn_data = fn_data;\n    MG_DEBUG((\"%lu %p %s\", c->id, c->fd, url));\n    mg_call(c, MG_EV_OPEN, NULL);\n    mg_resolve(c, url);\n  }\n  return c;\n}\n\nstruct mg_connection *mg_listen(struct mg_mgr *mgr, const char *url,\n                                mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = NULL;\n  if ((c = mg_alloc_conn(mgr)) == NULL) {\n    MG_ERROR((\"OOM %s\", url));\n  } else if (!mg_open_listener(c, url)) {\n    MG_ERROR((\"Failed: %s, errno %d\", url, errno));\n    free(c);\n    c = NULL;\n  } else {\n    c->is_listening = 1;\n    c->is_udp = strncmp(url, \"udp:\", 4) == 0;\n    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);\n    c->fn = fn;\n    c->fn_data = fn_data;\n    mg_call(c, MG_EV_OPEN, NULL);\n    MG_DEBUG((\"%lu %p %s\", c->id, c->fd, url));\n  }\n  return c;\n}\n\nstruct mg_connection *mg_wrapfd(struct mg_mgr *mgr, int fd,\n                                mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_alloc_conn(mgr);\n  if (c != NULL) {\n    c->fd = (void *) (size_t) fd;\n    c->fn = fn;\n    c->fn_data = fn_data;\n    MG_EPOLL_ADD(c);\n    mg_call(c, MG_EV_OPEN, NULL);\n    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);\n  }\n  return c;\n}\n\nstruct mg_timer *mg_timer_add(struct mg_mgr *mgr, uint64_t milliseconds,\n                              unsigned flags, void (*fn)(void *), void *arg) {\n  struct mg_timer *t = (struct mg_timer *) calloc(1, sizeof(*t));\n  if (t != NULL) {\n    mg_timer_init(&mgr->timers, t, milliseconds, flags, fn, arg);\n    t->id = mgr->timerid++;\n  }\n  return t;\n}\n\nvoid mg_mgr_free(struct mg_mgr *mgr) {\n  struct mg_connection *c;\n  struct mg_timer *tmp, *t = mgr->timers;\n  while (t != NULL) tmp = t->next, free(t), t = tmp;\n  mgr->timers = NULL;  // Important. Next call to poll won't touch timers\n  for (c = mgr->conns; c != NULL; c = c->next) c->is_closing = 1;\n  mg_mgr_poll(mgr, 0);\n#if MG_ENABLE_FREERTOS_TCP\n  FreeRTOS_DeleteSocketSet(mgr->ss);\n#endif\n  MG_DEBUG((\"All connections closed\"));\n#if MG_ENABLE_EPOLL\n  if (mgr->epoll_fd >= 0) close(mgr->epoll_fd), mgr->epoll_fd = -1;\n#endif\n}\n\nvoid mg_mgr_init(struct mg_mgr *mgr) {\n  memset(mgr, 0, sizeof(*mgr));\n#if MG_ENABLE_EPOLL\n  if ((mgr->epoll_fd = epoll_create1(0)) < 0) MG_ERROR((\"epoll: %d\", errno));\n#else\n  mgr->epoll_fd = -1;\n#endif\n#if MG_ARCH == MG_ARCH_WIN32 && MG_ENABLE_WINSOCK\n  // clang-format off\n  { WSADATA data; WSAStartup(MAKEWORD(2, 2), &data); }\n  // clang-format on\n#elif MG_ENABLE_FREERTOS_TCP\n  mgr->ss = FreeRTOS_CreateSocketSet();\n#elif defined(__unix) || defined(__unix__) || defined(__APPLE__)\n  // Ignore SIGPIPE signal, so if client cancels the request, it\n  // won't kill the whole process.\n  signal(SIGPIPE, SIG_IGN);\n#endif\n  mgr->dnstimeout = 3000;\n  mgr->dns4.url = \"udp://8.8.8.8:53\";\n  mgr->dns6.url = \"udp://[2001:4860:4860::8888]:53\";\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/printf.c\"\n#endif\n\n\n\n\nsize_t mg_queue_vprintf(struct mg_queue *q, const char *fmt, va_list *ap) {\n  size_t len = mg_snprintf(NULL, 0, fmt, ap);\n  char *buf;\n  if (len == 0 || mg_queue_book(q, &buf, len + 1) < len + 1) {\n    len = 0;  // Nah. Not enough space\n  } else {\n    len = mg_vsnprintf((char *) buf, len + 1, fmt, ap);\n    mg_queue_add(q, len);\n  }\n  return len;\n}\n\nsize_t mg_queue_printf(struct mg_queue *q, const char *fmt, ...) {\n  va_list ap;\n  size_t len;\n  va_start(ap, fmt);\n  len = mg_queue_vprintf(q, fmt, &ap);\n  va_end(ap);\n  return len;\n}\n\nstatic void mg_pfn_iobuf_private(char ch, void *param, bool expand) {\n  struct mg_iobuf *io = (struct mg_iobuf *) param;\n  if (expand && io->len + 2 > io->size) mg_iobuf_resize(io, io->len + 2);\n  if (io->len + 2 <= io->size) {\n    io->buf[io->len++] = (uint8_t) ch;\n    io->buf[io->len] = 0;\n  } else if (io->len < io->size) {\n    io->buf[io->len++] = 0;  // Guarantee to 0-terminate\n  }\n}\n\nstatic void mg_putchar_iobuf_static(char ch, void *param) {\n  mg_pfn_iobuf_private(ch, param, false);\n}\n\nvoid mg_pfn_iobuf(char ch, void *param) {\n  mg_pfn_iobuf_private(ch, param, true);\n}\n\nsize_t mg_vsnprintf(char *buf, size_t len, const char *fmt, va_list *ap) {\n  struct mg_iobuf io = {(uint8_t *) buf, len, 0, 0};\n  size_t n = mg_vxprintf(mg_putchar_iobuf_static, &io, fmt, ap);\n  if (n < len) buf[n] = '\\0';\n  return n;\n}\n\nsize_t mg_snprintf(char *buf, size_t len, const char *fmt, ...) {\n  va_list ap;\n  size_t n;\n  va_start(ap, fmt);\n  n = mg_vsnprintf(buf, len, fmt, &ap);\n  va_end(ap);\n  return n;\n}\n\nchar *mg_vmprintf(const char *fmt, va_list *ap) {\n  struct mg_iobuf io = {0, 0, 0, 256};\n  mg_vxprintf(mg_pfn_iobuf, &io, fmt, ap);\n  return (char *) io.buf;\n}\n\nchar *mg_mprintf(const char *fmt, ...) {\n  char *s;\n  va_list ap;\n  va_start(ap, fmt);\n  s = mg_vmprintf(fmt, &ap);\n  va_end(ap);\n  return s;\n}\n\nvoid mg_pfn_stdout(char c, void *param) {\n  putchar(c);\n  (void) param;\n}\n\nstatic size_t print_ip4(void (*out)(char, void *), void *arg, uint8_t *p) {\n  return mg_xprintf(out, arg, \"%d.%d.%d.%d\", p[0], p[1], p[2], p[3]);\n}\n\nstatic size_t print_ip6(void (*out)(char, void *), void *arg, uint16_t *p) {\n  return mg_xprintf(out, arg, \"[%x:%x:%x:%x:%x:%x:%x:%x]\", mg_ntohs(p[0]),\n                    mg_ntohs(p[1]), mg_ntohs(p[2]), mg_ntohs(p[3]),\n                    mg_ntohs(p[4]), mg_ntohs(p[5]), mg_ntohs(p[6]),\n                    mg_ntohs(p[7]));\n}\n\nsize_t mg_print_ip4(void (*out)(char, void *), void *arg, va_list *ap) {\n  uint8_t *p = va_arg(*ap, uint8_t *);\n  return print_ip4(out, arg, p);\n}\n\nsize_t mg_print_ip6(void (*out)(char, void *), void *arg, va_list *ap) {\n  uint16_t *p = va_arg(*ap, uint16_t *);\n  return print_ip6(out, arg, p);\n}\n\nsize_t mg_print_ip(void (*out)(char, void *), void *arg, va_list *ap) {\n  struct mg_addr *addr = va_arg(*ap, struct mg_addr *);\n  if (addr->is_ip6) return print_ip6(out, arg, (uint16_t *) addr->ip6);\n  return print_ip4(out, arg, (uint8_t *) &addr->ip);\n}\n\nsize_t mg_print_ip_port(void (*out)(char, void *), void *arg, va_list *ap) {\n  struct mg_addr *a = va_arg(*ap, struct mg_addr *);\n  return mg_xprintf(out, arg, \"%M:%hu\", mg_print_ip, a, mg_ntohs(a->port));\n}\n\nsize_t mg_print_mac(void (*out)(char, void *), void *arg, va_list *ap) {\n  uint8_t *p = va_arg(*ap, uint8_t *);\n  return mg_xprintf(out, arg, \"%02x:%02x:%02x:%02x:%02x:%02x\", p[0], p[1], p[2],\n                    p[3], p[4], p[5]);\n}\n\nstatic char mg_esc(int c, bool esc) {\n  const char *p, *esc1 = \"\\b\\f\\n\\r\\t\\\\\\\"\", *esc2 = \"bfnrt\\\\\\\"\";\n  for (p = esc ? esc1 : esc2; *p != '\\0'; p++) {\n    if (*p == c) return esc ? esc2[p - esc1] : esc1[p - esc2];\n  }\n  return 0;\n}\n\nstatic char mg_escape(int c) {\n  return mg_esc(c, true);\n}\n\nstatic size_t qcpy(void (*out)(char, void *), void *ptr, char *buf,\n                   size_t len) {\n  size_t i = 0, extra = 0;\n  for (i = 0; i < len && buf[i] != '\\0'; i++) {\n    char c = mg_escape(buf[i]);\n    if (c) {\n      out('\\\\', ptr), out(c, ptr), extra++;\n    } else {\n      out(buf[i], ptr);\n    }\n  }\n  return i + extra;\n}\n\nstatic size_t bcpy(void (*out)(char, void *), void *arg, uint8_t *buf,\n                   size_t len) {\n  size_t i, j, n = 0;\n  const char *t =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  for (i = 0; i < len; i += 3) {\n    uint8_t c1 = buf[i], c2 = i + 1 < len ? buf[i + 1] : 0,\n            c3 = i + 2 < len ? buf[i + 2] : 0;\n    char tmp[4] = {t[c1 >> 2], t[(c1 & 3) << 4 | (c2 >> 4)], '=', '='};\n    if (i + 1 < len) tmp[2] = t[(c2 & 15) << 2 | (c3 >> 6)];\n    if (i + 2 < len) tmp[3] = t[c3 & 63];\n    for (j = 0; j < sizeof(tmp) && tmp[j] != '\\0'; j++) out(tmp[j], arg);\n    n += j;\n  }\n  return n;\n}\n\nsize_t mg_print_hex(void (*out)(char, void *), void *arg, va_list *ap) {\n  size_t bl = (size_t) va_arg(*ap, int);\n  uint8_t *p = va_arg(*ap, uint8_t *);\n  const char *hex = \"0123456789abcdef\";\n  size_t j;\n  for (j = 0; j < bl; j++) {\n    out(hex[(p[j] >> 4) & 0x0F], arg);\n    out(hex[p[j] & 0x0F], arg);\n  }\n  return 2 * bl;\n}\nsize_t mg_print_base64(void (*out)(char, void *), void *arg, va_list *ap) {\n  size_t len = (size_t) va_arg(*ap, int);\n  uint8_t *buf = va_arg(*ap, uint8_t *);\n  return bcpy(out, arg, buf, len);\n}\n\nsize_t mg_print_esc(void (*out)(char, void *), void *arg, va_list *ap) {\n  size_t len = (size_t) va_arg(*ap, int);\n  char *p = va_arg(*ap, char *);\n  if (len == 0) len = p == NULL ? 0 : strlen(p);\n  return qcpy(out, arg, p, len);\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/queue.c\"\n#endif\n\n\n\n#if defined(__GNUC__) || defined(__clang__)\n#define MG_MEMORY_BARRIER() __sync_synchronize()\n#elif defined(_MSC_VER) && _MSC_VER >= 1700\n#define MG_MEMORY_BARRIER() MemoryBarrier()\n#elif !defined(MG_MEMORY_BARRIER)\n#define MG_MEMORY_BARRIER()\n#endif\n\n// Every message in a queue is prepended by a 32-bit message length (ML).\n// If ML is 0, then it is the end, and reader must wrap to the beginning.\n//\n//  Queue when q->tail <= q->head:\n//  |----- free -----| ML | message1 | ML | message2 |  ----- free ------|\n//  ^                ^                               ^                   ^\n// buf              tail                            head                len\n//\n//  Queue when q->tail > q->head:\n//  | ML | message2 |----- free ------| ML | message1 | 0 |---- free ----|\n//  ^               ^                 ^                                  ^\n// buf             head              tail                               len\n\nvoid mg_queue_init(struct mg_queue *q, char *buf, size_t size) {\n  q->size = size;\n  q->buf = buf;\n  q->head = q->tail = 0;\n}\n\nstatic size_t mg_queue_read_len(struct mg_queue *q) {\n  uint32_t n = 0;\n  MG_MEMORY_BARRIER();\n  memcpy(&n, q->buf + q->tail, sizeof(n));\n  assert(q->tail + n + sizeof(n) <= q->size);\n  return n;\n}\n\nstatic void mg_queue_write_len(struct mg_queue *q, size_t len) {\n  uint32_t n = (uint32_t) len;\n  memcpy(q->buf + q->head, &n, sizeof(n));\n  MG_MEMORY_BARRIER();\n}\n\nsize_t mg_queue_book(struct mg_queue *q, char **buf, size_t len) {\n  size_t space = 0, hs = sizeof(uint32_t) * 2;  // *2 is for the 0 marker\n  if (q->head >= q->tail && q->head + len + hs <= q->size) {\n    space = q->size - q->head - hs;  // There is enough space\n  } else if (q->head >= q->tail && q->tail > hs) {\n    mg_queue_write_len(q, 0);  // Not enough space ahead\n    q->head = 0;               // Wrap head to the beginning\n  }\n  if (q->head + hs + len < q->tail) space = q->tail - q->head - hs;\n  if (buf != NULL) *buf = q->buf + q->head + sizeof(uint32_t);\n  return space;\n}\n\nsize_t mg_queue_next(struct mg_queue *q, char **buf) {\n  size_t len = 0;\n  if (q->tail != q->head) {\n    len = mg_queue_read_len(q);\n    if (len == 0) {  // Zero (head wrapped) ?\n      q->tail = 0;   // Reset tail to the start\n      if (q->head > q->tail) len = mg_queue_read_len(q);  // Read again\n    }\n  }\n  if (buf != NULL) *buf = q->buf + q->tail + sizeof(uint32_t);\n  assert(q->tail + len <= q->size);\n  return len;\n}\n\nvoid mg_queue_add(struct mg_queue *q, size_t len) {\n  assert(len > 0);\n  mg_queue_write_len(q, len);\n  assert(q->head + sizeof(uint32_t) * 2 + len <= q->size);\n  q->head += len + sizeof(uint32_t);\n}\n\nvoid mg_queue_del(struct mg_queue *q, size_t len) {\n  q->tail += len + sizeof(uint32_t);\n  assert(q->tail + sizeof(uint32_t) <= q->size);\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/rpc.c\"\n#endif\n\n\n\nvoid mg_rpc_add(struct mg_rpc **head, struct mg_str method,\n                void (*fn)(struct mg_rpc_req *), void *fn_data) {\n  struct mg_rpc *rpc = (struct mg_rpc *) calloc(1, sizeof(*rpc));\n  if (rpc != NULL) {\n    rpc->method = mg_strdup(method), rpc->fn = fn, rpc->fn_data = fn_data;\n    rpc->next = *head, *head = rpc;\n  }\n}\n\nvoid mg_rpc_del(struct mg_rpc **head, void (*fn)(struct mg_rpc_req *)) {\n  struct mg_rpc *r;\n  while ((r = *head) != NULL) {\n    if (r->fn == fn || fn == NULL) {\n      *head = r->next;\n      free((void *) r->method.ptr);\n      free(r);\n    } else {\n      head = &(*head)->next;\n    }\n  }\n}\n\nstatic void mg_rpc_call(struct mg_rpc_req *r, struct mg_str method) {\n  struct mg_rpc *h = r->head == NULL ? NULL : *r->head;\n  while (h != NULL && !mg_match(method, h->method, NULL)) h = h->next;\n  if (h != NULL) {\n    r->rpc = h;\n    h->fn(r);\n  } else {\n    mg_rpc_err(r, -32601, \"\\\"%.*s not found\\\"\", (int) method.len, method.ptr);\n  }\n}\n\nvoid mg_rpc_process(struct mg_rpc_req *r) {\n  int len, off = mg_json_get(r->frame, \"$.method\", &len);\n  if (off > 0 && r->frame.ptr[off] == '\"') {\n    struct mg_str method = mg_str_n(&r->frame.ptr[off + 1], (size_t) len - 2);\n    mg_rpc_call(r, method);\n  } else if ((off = mg_json_get(r->frame, \"$.result\", &len)) > 0 ||\n             (off = mg_json_get(r->frame, \"$.error\", &len)) > 0) {\n    mg_rpc_call(r, mg_str(\"\"));  // JSON response! call \"\" method handler\n  } else {\n    mg_rpc_err(r, -32700, \"%m\", mg_print_esc, (int) r->frame.len,\n               r->frame.ptr);  // Invalid\n  }\n}\n\nvoid mg_rpc_vok(struct mg_rpc_req *r, const char *fmt, va_list *ap) {\n  int len, off = mg_json_get(r->frame, \"$.id\", &len);\n  if (off > 0) {\n    mg_xprintf(r->pfn, r->pfn_data, \"{%m:%.*s,%m:\", mg_print_esc, 0, \"id\", len,\n               &r->frame.ptr[off], mg_print_esc, 0, \"result\");\n    mg_vxprintf(r->pfn, r->pfn_data, fmt == NULL ? \"null\" : fmt, ap);\n    mg_xprintf(r->pfn, r->pfn_data, \"}\");\n  }\n}\n\nvoid mg_rpc_ok(struct mg_rpc_req *r, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  mg_rpc_vok(r, fmt, &ap);\n  va_end(ap);\n}\n\nvoid mg_rpc_verr(struct mg_rpc_req *r, int code, const char *fmt, va_list *ap) {\n  int len, off = mg_json_get(r->frame, \"$.id\", &len);\n  mg_xprintf(r->pfn, r->pfn_data, \"{\");\n  if (off > 0) {\n    mg_xprintf(r->pfn, r->pfn_data, \"%m:%.*s,\", mg_print_esc, 0, \"id\", len,\n               &r->frame.ptr[off]);\n  }\n  mg_xprintf(r->pfn, r->pfn_data, \"%m:{%m:%d,%m:\", mg_print_esc, 0, \"error\",\n             mg_print_esc, 0, \"code\", code, mg_print_esc, 0, \"message\");\n  mg_vxprintf(r->pfn, r->pfn_data, fmt == NULL ? \"null\" : fmt, ap);\n  mg_xprintf(r->pfn, r->pfn_data, \"}}\");\n}\n\nvoid mg_rpc_err(struct mg_rpc_req *r, int code, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  mg_rpc_verr(r, code, fmt, &ap);\n  va_end(ap);\n}\n\nstatic size_t print_methods(mg_pfn_t pfn, void *pfn_data, va_list *ap) {\n  struct mg_rpc *h, **head = (struct mg_rpc **) va_arg(*ap, void **);\n  size_t len = 0;\n  for (h = *head; h != NULL; h = h->next) {\n    if (h->method.len == 0) continue;  // Ignore response handler\n    len += mg_xprintf(pfn, pfn_data, \"%s%m\", h == *head ? \"\" : \",\",\n                      mg_print_esc, (int) h->method.len, h->method.ptr);\n  }\n  return len;\n}\n\nvoid mg_rpc_list(struct mg_rpc_req *r) {\n  mg_rpc_ok(r, \"[%M]\", print_methods, r->head);\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/sha1.c\"\n#endif\n/* Copyright(c) By Steve Reid <steve@edmweb.com> */\n/* 100% Public Domain */\n\n\n\nunion char64long16 {\n  unsigned char c[64];\n  uint32_t l[16];\n};\n\n#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))\n\nstatic uint32_t blk0(union char64long16 *block, int i) {\n  if (MG_BIG_ENDIAN) {\n  } else {\n    block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |\n                  (rol(block->l[i], 8) & 0x00FF00FF);\n  }\n  return block->l[i];\n}\n\n/* Avoid redefine warning (ARM /usr/include/sys/ucontext.h define R0~R4) */\n#undef blk\n#undef R0\n#undef R1\n#undef R2\n#undef R3\n#undef R4\n\n#define blk(i)                                                               \\\n  (block->l[i & 15] = rol(block->l[(i + 13) & 15] ^ block->l[(i + 8) & 15] ^ \\\n                              block->l[(i + 2) & 15] ^ block->l[i & 15],     \\\n                          1))\n#define R0(v, w, x, y, z, i)                                          \\\n  z += ((w & (x ^ y)) ^ y) + blk0(block, i) + 0x5A827999 + rol(v, 5); \\\n  w = rol(w, 30);\n#define R1(v, w, x, y, z, i)                                  \\\n  z += ((w & (x ^ y)) ^ y) + blk(i) + 0x5A827999 + rol(v, 5); \\\n  w = rol(w, 30);\n#define R2(v, w, x, y, z, i)                          \\\n  z += (w ^ x ^ y) + blk(i) + 0x6ED9EBA1 + rol(v, 5); \\\n  w = rol(w, 30);\n#define R3(v, w, x, y, z, i)                                        \\\n  z += (((w | x) & y) | (w & x)) + blk(i) + 0x8F1BBCDC + rol(v, 5); \\\n  w = rol(w, 30);\n#define R4(v, w, x, y, z, i)                          \\\n  z += (w ^ x ^ y) + blk(i) + 0xCA62C1D6 + rol(v, 5); \\\n  w = rol(w, 30);\n\nstatic void mg_sha1_transform(uint32_t state[5],\n                              const unsigned char *buffer) {\n  uint32_t a, b, c, d, e;\n  union char64long16 block[1];\n\n  memcpy(block, buffer, 64);\n  a = state[0];\n  b = state[1];\n  c = state[2];\n  d = state[3];\n  e = state[4];\n  R0(a, b, c, d, e, 0);\n  R0(e, a, b, c, d, 1);\n  R0(d, e, a, b, c, 2);\n  R0(c, d, e, a, b, 3);\n  R0(b, c, d, e, a, 4);\n  R0(a, b, c, d, e, 5);\n  R0(e, a, b, c, d, 6);\n  R0(d, e, a, b, c, 7);\n  R0(c, d, e, a, b, 8);\n  R0(b, c, d, e, a, 9);\n  R0(a, b, c, d, e, 10);\n  R0(e, a, b, c, d, 11);\n  R0(d, e, a, b, c, 12);\n  R0(c, d, e, a, b, 13);\n  R0(b, c, d, e, a, 14);\n  R0(a, b, c, d, e, 15);\n  R1(e, a, b, c, d, 16);\n  R1(d, e, a, b, c, 17);\n  R1(c, d, e, a, b, 18);\n  R1(b, c, d, e, a, 19);\n  R2(a, b, c, d, e, 20);\n  R2(e, a, b, c, d, 21);\n  R2(d, e, a, b, c, 22);\n  R2(c, d, e, a, b, 23);\n  R2(b, c, d, e, a, 24);\n  R2(a, b, c, d, e, 25);\n  R2(e, a, b, c, d, 26);\n  R2(d, e, a, b, c, 27);\n  R2(c, d, e, a, b, 28);\n  R2(b, c, d, e, a, 29);\n  R2(a, b, c, d, e, 30);\n  R2(e, a, b, c, d, 31);\n  R2(d, e, a, b, c, 32);\n  R2(c, d, e, a, b, 33);\n  R2(b, c, d, e, a, 34);\n  R2(a, b, c, d, e, 35);\n  R2(e, a, b, c, d, 36);\n  R2(d, e, a, b, c, 37);\n  R2(c, d, e, a, b, 38);\n  R2(b, c, d, e, a, 39);\n  R3(a, b, c, d, e, 40);\n  R3(e, a, b, c, d, 41);\n  R3(d, e, a, b, c, 42);\n  R3(c, d, e, a, b, 43);\n  R3(b, c, d, e, a, 44);\n  R3(a, b, c, d, e, 45);\n  R3(e, a, b, c, d, 46);\n  R3(d, e, a, b, c, 47);\n  R3(c, d, e, a, b, 48);\n  R3(b, c, d, e, a, 49);\n  R3(a, b, c, d, e, 50);\n  R3(e, a, b, c, d, 51);\n  R3(d, e, a, b, c, 52);\n  R3(c, d, e, a, b, 53);\n  R3(b, c, d, e, a, 54);\n  R3(a, b, c, d, e, 55);\n  R3(e, a, b, c, d, 56);\n  R3(d, e, a, b, c, 57);\n  R3(c, d, e, a, b, 58);\n  R3(b, c, d, e, a, 59);\n  R4(a, b, c, d, e, 60);\n  R4(e, a, b, c, d, 61);\n  R4(d, e, a, b, c, 62);\n  R4(c, d, e, a, b, 63);\n  R4(b, c, d, e, a, 64);\n  R4(a, b, c, d, e, 65);\n  R4(e, a, b, c, d, 66);\n  R4(d, e, a, b, c, 67);\n  R4(c, d, e, a, b, 68);\n  R4(b, c, d, e, a, 69);\n  R4(a, b, c, d, e, 70);\n  R4(e, a, b, c, d, 71);\n  R4(d, e, a, b, c, 72);\n  R4(c, d, e, a, b, 73);\n  R4(b, c, d, e, a, 74);\n  R4(a, b, c, d, e, 75);\n  R4(e, a, b, c, d, 76);\n  R4(d, e, a, b, c, 77);\n  R4(c, d, e, a, b, 78);\n  R4(b, c, d, e, a, 79);\n  state[0] += a;\n  state[1] += b;\n  state[2] += c;\n  state[3] += d;\n  state[4] += e;\n  /* Erase working structures. The order of operations is important,\n   * used to ensure that compiler doesn't optimize those out. */\n  memset(block, 0, sizeof(block));\n  a = b = c = d = e = 0;\n  (void) a;\n  (void) b;\n  (void) c;\n  (void) d;\n  (void) e;\n}\n\nvoid mg_sha1_init(mg_sha1_ctx *context) {\n  context->state[0] = 0x67452301;\n  context->state[1] = 0xEFCDAB89;\n  context->state[2] = 0x98BADCFE;\n  context->state[3] = 0x10325476;\n  context->state[4] = 0xC3D2E1F0;\n  context->count[0] = context->count[1] = 0;\n}\n\nvoid mg_sha1_update(mg_sha1_ctx *context, const unsigned char *data,\n                    size_t len) {\n  size_t i, j;\n\n  j = context->count[0];\n  if ((context->count[0] += (uint32_t) len << 3) < j) context->count[1]++;\n  context->count[1] += (uint32_t) (len >> 29);\n  j = (j >> 3) & 63;\n  if ((j + len) > 63) {\n    memcpy(&context->buffer[j], data, (i = 64 - j));\n    mg_sha1_transform(context->state, context->buffer);\n    for (; i + 63 < len; i += 64) {\n      mg_sha1_transform(context->state, &data[i]);\n    }\n    j = 0;\n  } else\n    i = 0;\n  memcpy(&context->buffer[j], &data[i], len - i);\n}\n\nvoid mg_sha1_final(unsigned char digest[20], mg_sha1_ctx *context) {\n  unsigned i;\n  unsigned char finalcount[8], c;\n\n  for (i = 0; i < 8; i++) {\n    finalcount[i] = (unsigned char) ((context->count[(i >= 4 ? 0 : 1)] >>\n                                      ((3 - (i & 3)) * 8)) &\n                                     255);\n  }\n  c = 0200;\n  mg_sha1_update(context, &c, 1);\n  while ((context->count[0] & 504) != 448) {\n    c = 0000;\n    mg_sha1_update(context, &c, 1);\n  }\n  mg_sha1_update(context, finalcount, 8);\n  for (i = 0; i < 20; i++) {\n    digest[i] =\n        (unsigned char) ((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);\n  }\n  memset(context, '\\0', sizeof(*context));\n  memset(&finalcount, '\\0', sizeof(finalcount));\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/sntp.c\"\n#endif\n\n\n\n\n\n\n#define SNTP_TIME_OFFSET 2208988800U  // (1970 - 1900) in seconds\n#define SNTP_MAX_FRAC 4294967295.0    // 2 ** 32 - 1\n\nstatic int64_t gettimestamp(const uint32_t *data) {\n  uint32_t sec = mg_ntohl(data[0]), frac = mg_ntohl(data[1]);\n  if (sec) sec -= SNTP_TIME_OFFSET;\n  return ((int64_t) sec) * 1000 + (int64_t) (frac / SNTP_MAX_FRAC * 1000.0);\n}\n\nint64_t mg_sntp_parse(const unsigned char *buf, size_t len) {\n  int64_t res = -1;\n  int mode = len > 0 ? buf[0] & 7 : 0;\n  int version = len > 0 ? (buf[0] >> 3) & 7 : 0;\n  if (len < 48) {\n    MG_ERROR((\"%s\", \"corrupt packet\"));\n  } else if (mode != 4 && mode != 5) {\n    MG_ERROR((\"%s\", \"not a server reply\"));\n  } else if (buf[1] == 0) {\n    MG_ERROR((\"%s\", \"server sent a kiss of death\"));\n  } else if (version == 4 || version == 3) {\n    // int64_t ref = gettimestamp((uint32_t *) &buf[16]);\n    int64_t t0 = gettimestamp((uint32_t *) &buf[24]);\n    int64_t t1 = gettimestamp((uint32_t *) &buf[32]);\n    int64_t t2 = gettimestamp((uint32_t *) &buf[40]);\n    int64_t t3 = (int64_t) mg_millis();\n    int64_t delta = (t3 - t0) - (t2 - t1);\n    MG_VERBOSE((\"%lld %lld %lld %lld delta:%lld\", t0, t1, t2, t3, delta));\n    res = t2 + delta / 2;\n  } else {\n    MG_ERROR((\"unexpected version: %d\", version));\n  }\n  return res;\n}\n\nstatic void sntp_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n  if (ev == MG_EV_READ) {\n    int64_t milliseconds = mg_sntp_parse(c->recv.buf, c->recv.len);\n    if (milliseconds > 0) {\n      MG_INFO((\"%lu got time: %lld ms from epoch\", c->id, milliseconds));\n      mg_call(c, MG_EV_SNTP_TIME, (uint64_t *) &milliseconds);\n      MG_VERBOSE((\"%u.%u\", (unsigned) (milliseconds / 1000),\n                  (unsigned) (milliseconds % 1000)));\n    }\n    mg_iobuf_del(&c->recv, 0, c->recv.len);  // Free receive buffer\n  } else if (ev == MG_EV_CONNECT) {\n    mg_sntp_request(c);\n  } else if (ev == MG_EV_CLOSE) {\n  }\n  (void) fnd;\n  (void) evd;\n}\n\nvoid mg_sntp_request(struct mg_connection *c) {\n  if (c->is_resolving) {\n    MG_ERROR((\"%lu wait until resolved\", c->id));\n  } else {\n    int64_t now = (int64_t) mg_millis();  // Use int64_t, for vc98\n    uint8_t buf[48] = {0};\n    uint32_t *t = (uint32_t *) &buf[40];\n    double frac = ((double) (now % 1000)) / 1000.0 * SNTP_MAX_FRAC;\n    buf[0] = (0 << 6) | (4 << 3) | 3;\n    t[0] = mg_htonl((uint32_t) (now / 1000) + SNTP_TIME_OFFSET);\n    t[1] = mg_htonl((uint32_t) frac);\n    mg_send(c, buf, sizeof(buf));\n  }\n}\n\nstruct mg_connection *mg_sntp_connect(struct mg_mgr *mgr, const char *url,\n                                      mg_event_handler_t fn, void *fnd) {\n  struct mg_connection *c = NULL;\n  if (url == NULL) url = \"udp://time.google.com:123\";\n  if ((c = mg_connect(mgr, url, fn, fnd)) != NULL) c->pfn = sntp_cb;\n  return c;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/sock.c\"\n#endif\n\n\n\n\n\n\n\n\n\n\n\n#if MG_ENABLE_SOCKET\n\n#ifndef closesocket\n#define closesocket(x) close(x)\n#endif\n\n#define FD(c_) ((MG_SOCKET_TYPE) (size_t) (c_)->fd)\n#define S2PTR(s_) ((void *) (size_t) (s_))\n\n#ifndef MSG_NONBLOCKING\n#define MSG_NONBLOCKING 0\n#endif\n\n#ifndef AF_INET6\n#define AF_INET6 10\n#endif\n\n#ifndef MG_SOCK_ERR\n#define MG_SOCK_ERR(errcode) ((errcode) < 0 ? errno : 0)\n#endif\n\n#ifndef MG_SOCK_INTR\n#define MG_SOCK_INTR(fd) (fd == MG_INVALID_SOCKET && MG_SOCK_ERR(-1) == EINTR)\n#endif\n\n#ifndef MG_SOCK_PENDING\n#define MG_SOCK_PENDING(errcode) \\\n  (((errcode) < 0) && (errno == EINPROGRESS || errno == EWOULDBLOCK))\n#endif\n\n#ifndef MG_SOCK_RESET\n#define MG_SOCK_RESET(errcode) \\\n  (((errcode) < 0) && (errno == EPIPE || errno == ECONNRESET))\n#endif\n\nunion usa {\n  struct sockaddr sa;\n  struct sockaddr_in sin;\n#if MG_ENABLE_IPV6\n  struct sockaddr_in6 sin6;\n#endif\n};\n\nstatic socklen_t tousa(struct mg_addr *a, union usa *usa) {\n  socklen_t len = sizeof(usa->sin);\n  memset(usa, 0, sizeof(*usa));\n  usa->sin.sin_family = AF_INET;\n  usa->sin.sin_port = a->port;\n  *(uint32_t *) &usa->sin.sin_addr = a->ip;\n#if MG_ENABLE_IPV6\n  if (a->is_ip6) {\n    usa->sin.sin_family = AF_INET6;\n    usa->sin6.sin6_port = a->port;\n    memcpy(&usa->sin6.sin6_addr, a->ip6, sizeof(a->ip6));\n    len = sizeof(usa->sin6);\n  }\n#endif\n  return len;\n}\n\nstatic void tomgaddr(union usa *usa, struct mg_addr *a, bool is_ip6) {\n  a->is_ip6 = is_ip6;\n  a->port = usa->sin.sin_port;\n  memcpy(&a->ip, &usa->sin.sin_addr, sizeof(a->ip));\n#if MG_ENABLE_IPV6\n  if (is_ip6) {\n    memcpy(a->ip6, &usa->sin6.sin6_addr, sizeof(a->ip6));\n    a->port = usa->sin6.sin6_port;\n  }\n#endif\n}\n\nstatic void setlocaddr(MG_SOCKET_TYPE fd, struct mg_addr *addr) {\n  union usa usa;\n  socklen_t n = sizeof(usa);\n  if (getsockname(fd, &usa.sa, &n) == 0) {\n    tomgaddr(&usa, addr, n != sizeof(usa.sin));\n  }\n}\n\nstatic void iolog(struct mg_connection *c, char *buf, long n, bool r) {\n  if (n == MG_IO_WAIT) {\n    // Do nothing\n  } else if (n <= 0) {\n    c->is_closing = 1;  // Termination. Don't call mg_error(): #1529\n  } else if (n > 0) {\n    if (c->is_hexdumping) {\n      union usa usa;\n      socklen_t slen = sizeof(usa.sin);\n      if (getsockname(FD(c), &usa.sa, &slen) < 0) (void) 0;  // Ignore result\n      MG_INFO((\"\\n-- %lu %M %s %M %ld\", c->id, mg_print_ip_port, &c->loc,\n               r ? \"<-\" : \"->\", mg_print_ip_port, &c->rem, n));\n\n      mg_hexdump(buf, (size_t) n);\n    }\n    if (r) {\n      c->recv.len += (size_t) n;\n      mg_call(c, MG_EV_READ, &n);\n    } else {\n      mg_iobuf_del(&c->send, 0, (size_t) n);\n      // if (c->send.len == 0) mg_iobuf_resize(&c->send, 0);\n      if (c->send.len == 0) {\n        MG_EPOLL_MOD(c, 0);\n      }\n      mg_call(c, MG_EV_WRITE, &n);\n    }\n  }\n}\n\nlong mg_io_send(struct mg_connection *c, const void *buf, size_t len) {\n  long n;\n  if (c->is_udp) {\n    union usa usa;\n    socklen_t slen = tousa(&c->rem, &usa);\n    n = sendto(FD(c), (char *) buf, len, 0, &usa.sa, slen);\n    if (n > 0) setlocaddr(FD(c), &c->loc);\n  } else {\n    n = send(FD(c), (char *) buf, len, MSG_NONBLOCKING);\n  }\n  if (MG_SOCK_PENDING(n)) return MG_IO_WAIT;\n  if (MG_SOCK_RESET(n)) return MG_IO_RESET;\n  if (n <= 0) return MG_IO_ERR;\n  return n;\n}\n\nbool mg_send(struct mg_connection *c, const void *buf, size_t len) {\n  if (c->is_udp) {\n    long n = mg_io_send(c, buf, len);\n    MG_DEBUG((\"%lu %p %d:%d %ld err %d\", c->id, c->fd, (int) c->send.len,\n              (int) c->recv.len, n, MG_SOCK_ERR(n)));\n    iolog(c, (char *) buf, n, false);\n    return n > 0;\n  } else {\n    return mg_iobuf_add(&c->send, c->send.len, buf, len);\n  }\n}\n\nstatic void mg_set_non_blocking_mode(MG_SOCKET_TYPE fd) {\n#if defined(MG_CUSTOM_NONBLOCK)\n  MG_CUSTOM_NONBLOCK(fd);\n#elif MG_ARCH == MG_ARCH_WIN32 && MG_ENABLE_WINSOCK\n  unsigned long on = 1;\n  ioctlsocket(fd, FIONBIO, &on);\n#elif MG_ENABLE_RL\n  unsigned long on = 1;\n  ioctlsocket(fd, FIONBIO, &on);\n#elif MG_ENABLE_FREERTOS_TCP\n  const BaseType_t off = 0;\n  if (setsockopt(fd, 0, FREERTOS_SO_RCVTIMEO, &off, sizeof(off)) != 0) (void) 0;\n  if (setsockopt(fd, 0, FREERTOS_SO_SNDTIMEO, &off, sizeof(off)) != 0) (void) 0;\n#elif MG_ENABLE_LWIP\n  lwip_fcntl(fd, F_SETFL, O_NONBLOCK);\n#elif MG_ARCH == MG_ARCH_AZURERTOS\n  fcntl(fd, F_SETFL, O_NONBLOCK);\n#elif MG_ARCH == MG_ARCH_TIRTOS\n  int val = 0;\n  setsockopt(fd, SOL_SOCKET, SO_BLOCKING, &val, sizeof(val));\n  // SPRU524J section 3.3.3 page 63, SO_SNDLOWAT\n  int sz = sizeof(val);\n  getsockopt(fd, SOL_SOCKET, SO_SNDBUF, &val, &sz);\n  val /= 2;  // set send low-water mark at half send buffer size\n  setsockopt(fd, SOL_SOCKET, SO_SNDLOWAT, &val, sizeof(val));\n#else\n  fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);  // Non-blocking mode\n  fcntl(fd, F_SETFD, FD_CLOEXEC);                          // Set close-on-exec\n#endif\n}\n\nbool mg_open_listener(struct mg_connection *c, const char *url) {\n  MG_SOCKET_TYPE fd = MG_INVALID_SOCKET;\n  bool success = false;\n  c->loc.port = mg_htons(mg_url_port(url));\n  if (!mg_aton(mg_url_host(url), &c->loc)) {\n    MG_ERROR((\"invalid listening URL: %s\", url));\n  } else {\n    union usa usa;\n    socklen_t slen = tousa(&c->loc, &usa);\n    int rc, on = 1, af = c->loc.is_ip6 ? AF_INET6 : AF_INET;\n    int type = strncmp(url, \"udp:\", 4) == 0 ? SOCK_DGRAM : SOCK_STREAM;\n    int proto = type == SOCK_DGRAM ? IPPROTO_UDP : IPPROTO_TCP;\n    (void) on;\n\n    if ((fd = socket(af, type, proto)) == MG_INVALID_SOCKET) {\n      MG_ERROR((\"socket: %d\", MG_SOCK_ERR(-1)));\n#if defined(SO_EXCLUSIVEADDRUSE)\n    } else if ((rc = setsockopt(fd, SOL_SOCKET, SO_EXCLUSIVEADDRUSE,\n                                (char *) &on, sizeof(on))) != 0) {\n      // \"Using SO_REUSEADDR and SO_EXCLUSIVEADDRUSE\"\n      MG_ERROR((\"setsockopt(SO_EXCLUSIVEADDRUSE): %d %d\", on, MG_SOCK_ERR(rc)));\n#endif\n#if defined(SO_REUSEADDR) && (!defined(LWIP_SOCKET) || SO_REUSE)\n    } else if ((rc = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *) &on,\n                                sizeof(on))) != 0) {\n      // 1. SO_REUSEADDR semantics on UNIX and Windows is different.  On\n      // Windows, SO_REUSEADDR allows to bind a socket to a port without error\n      // even if the port is already open by another program. This is not the\n      // behavior SO_REUSEADDR was designed for, and leads to hard-to-track\n      // failure scenarios.\n      //\n      // 2. For LWIP, SO_REUSEADDR should be explicitly enabled by defining\n      // SO_REUSE = 1 in lwipopts.h, otherwise the code below will compile but\n      // won't work! (setsockopt will return EINVAL)\n      MG_ERROR((\"setsockopt(SO_REUSEADDR): %d\", MG_SOCK_ERR(rc)));\n#endif\n#if defined(IPV6_V6ONLY)\n    } else if (c->loc.is_ip6 &&\n               (rc = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &on,\n                                sizeof(on))) != 0) {\n      // See #2089. Allow to bind v4 and v6 sockets on the same port\n      MG_ERROR((\"setsockopt(IPV6_V6ONLY): %d\", MG_SOCK_ERR(rc)));\n#endif\n    } else if ((rc = bind(fd, &usa.sa, slen)) != 0) {\n      MG_ERROR((\"bind: %d\", MG_SOCK_ERR(rc)));\n    } else if ((type == SOCK_STREAM &&\n                (rc = listen(fd, MG_SOCK_LISTEN_BACKLOG_SIZE)) != 0)) {\n      // NOTE(lsm): FreeRTOS uses backlog value as a connection limit\n      // In case port was set to 0, get the real port number\n      MG_ERROR((\"listen: %d\", MG_SOCK_ERR(rc)));\n    } else {\n      setlocaddr(fd, &c->loc);\n      mg_set_non_blocking_mode(fd);\n      c->fd = S2PTR(fd);\n      MG_EPOLL_ADD(c);\n      success = true;\n    }\n  }\n  if (success == false && fd != MG_INVALID_SOCKET) closesocket(fd);\n  return success;\n}\n\nlong mg_io_recv(struct mg_connection *c, void *buf, size_t len) {\n  long n = 0;\n  if (c->is_udp) {\n    union usa usa;\n    socklen_t slen = tousa(&c->rem, &usa);\n    n = recvfrom(FD(c), (char *) buf, len, 0, &usa.sa, &slen);\n    if (n > 0) tomgaddr(&usa, &c->rem, slen != sizeof(usa.sin));\n  } else {\n    n = recv(FD(c), (char *) buf, len, MSG_NONBLOCKING);\n  }\n  if (MG_SOCK_PENDING(n)) return MG_IO_WAIT;\n  if (MG_SOCK_RESET(n)) return MG_IO_RESET;\n  if (n <= 0) return MG_IO_ERR;\n  return n;\n}\n\n// NOTE(lsm): do only one iteration of reads, cause some systems\n// (e.g. FreeRTOS stack) return 0 instead of -1/EWOULDBLOCK when no data\nstatic void read_conn(struct mg_connection *c) {\n  long n = -1;\n  if (c->recv.len >= MG_MAX_RECV_SIZE) {\n    mg_error(c, \"max_recv_buf_size reached\");\n  } else if (c->recv.size <= c->recv.len &&\n             !mg_iobuf_resize(&c->recv, c->recv.size + MG_IO_SIZE)) {\n    mg_error(c, \"oom\");\n  } else {\n    char *buf = (char *) &c->recv.buf[c->recv.len];\n    size_t len = c->recv.size - c->recv.len;\n    n = c->is_tls ? mg_tls_recv(c, buf, len) : mg_io_recv(c, buf, len);\n    MG_DEBUG((\"%lu %p snd %ld/%ld rcv %ld/%ld n=%ld err=%d\", c->id, c->fd,\n              (long) c->send.len, (long) c->send.size, (long) c->recv.len,\n              (long) c->recv.size, n, MG_SOCK_ERR(n)));\n    iolog(c, buf, n, true);\n  }\n}\n\nstatic void write_conn(struct mg_connection *c) {\n  char *buf = (char *) c->send.buf;\n  size_t len = c->send.len;\n  long n = c->is_tls ? mg_tls_send(c, buf, len) : mg_io_send(c, buf, len);\n  MG_DEBUG((\"%lu %p snd %ld/%ld rcv %ld/%ld n=%ld err=%d\", c->id, c->fd,\n            (long) c->send.len, (long) c->send.size, (long) c->recv.len,\n            (long) c->recv.size, n, MG_SOCK_ERR(n)));\n  iolog(c, buf, n, false);\n}\n\nstatic void close_conn(struct mg_connection *c) {\n  if (FD(c) != MG_INVALID_SOCKET) {\n#if MG_ENABLE_EPOLL\n    epoll_ctl(c->mgr->epoll_fd, EPOLL_CTL_DEL, FD(c), NULL);\n#endif\n    closesocket(FD(c));\n#if MG_ENABLE_FREERTOS_TCP\n    FreeRTOS_FD_CLR(c->fd, c->mgr->ss, eSELECT_ALL);\n#endif\n  }\n  mg_close_conn(c);\n}\n\nstatic void connect_conn(struct mg_connection *c) {\n  union usa usa;\n  socklen_t n = sizeof(usa);\n  // Use getpeername() to test whether we have connected\n  if (getpeername(FD(c), &usa.sa, &n) == 0) {\n    c->is_connecting = 0;\n    mg_call(c, MG_EV_CONNECT, NULL);\n    MG_EPOLL_MOD(c, 0);\n    if (c->is_tls_hs) mg_tls_handshake(c);\n  } else {\n    mg_error(c, \"socket error\");\n  }\n}\n\nstatic void setsockopts(struct mg_connection *c) {\n#if MG_ENABLE_FREERTOS_TCP || MG_ARCH == MG_ARCH_AZURERTOS || \\\n    MG_ARCH == MG_ARCH_TIRTOS\n  (void) c;\n#else\n  int on = 1;\n#if !defined(SOL_TCP)\n#define SOL_TCP IPPROTO_TCP\n#endif\n  if (setsockopt(FD(c), SOL_TCP, TCP_NODELAY, (char *) &on, sizeof(on)) != 0)\n    (void) 0;\n  if (setsockopt(FD(c), SOL_SOCKET, SO_KEEPALIVE, (char *) &on, sizeof(on)) !=\n      0)\n    (void) 0;\n#endif\n}\n\nvoid mg_connect_resolved(struct mg_connection *c) {\n  int type = c->is_udp ? SOCK_DGRAM : SOCK_STREAM;\n  int rc, af = c->rem.is_ip6 ? AF_INET6 : AF_INET;  // c->rem has resolved IP\n  c->fd = S2PTR(socket(af, type, 0));               // Create outbound socket\n  c->is_resolving = 0;                              // Clear resolving flag\n  if (FD(c) == MG_INVALID_SOCKET) {\n    mg_error(c, \"socket(): %d\", MG_SOCK_ERR(-1));\n  } else if (c->is_udp) {\n    MG_EPOLL_ADD(c);\n#if MG_ARCH == MG_ARCH_TIRTOS\n    union usa usa;  // TI-RTOS NDK requires binding to receive on UDP sockets\n    socklen_t slen = tousa(&c->loc, &usa);\n    if ((rc = bind(c->fd, &usa.sa, slen)) != 0)\n      MG_ERROR((\"bind: %d\", MG_SOCK_ERR(rc)));\n#endif\n    mg_call(c, MG_EV_RESOLVE, NULL);\n    mg_call(c, MG_EV_CONNECT, NULL);\n  } else {\n    union usa usa;\n    socklen_t slen = tousa(&c->rem, &usa);\n    mg_set_non_blocking_mode(FD(c));\n    setsockopts(c);\n    MG_EPOLL_ADD(c);\n    mg_call(c, MG_EV_RESOLVE, NULL);\n    rc = connect(FD(c), &usa.sa, slen);  // Attempt to connect\n    if (rc == 0) {                       // Success\n      mg_call(c, MG_EV_CONNECT, NULL);   // Send MG_EV_CONNECT to the user\n    } else if (MG_SOCK_PENDING(rc)) {    // Need to wait for TCP handshake\n      MG_DEBUG((\"%lu %p -> %M pend\", c->id, c->fd, mg_print_ip_port, &c->rem));\n      c->is_connecting = 1;\n    } else {\n      mg_error(c, \"connect: %d\", MG_SOCK_ERR(rc));\n    }\n  }\n}\n\nstatic MG_SOCKET_TYPE raccept(MG_SOCKET_TYPE sock, union usa *usa,\n                              socklen_t *len) {\n  MG_SOCKET_TYPE fd = MG_INVALID_SOCKET;\n  do {\n    memset(usa, 0, sizeof(*usa));\n    fd = accept(sock, &usa->sa, len);\n  } while (MG_SOCK_INTR(fd));\n  return fd;\n}\n\nstatic void accept_conn(struct mg_mgr *mgr, struct mg_connection *lsn) {\n  struct mg_connection *c = NULL;\n  union usa usa;\n  socklen_t sa_len = sizeof(usa);\n  MG_SOCKET_TYPE fd = raccept(FD(lsn), &usa, &sa_len);\n  if (fd == MG_INVALID_SOCKET) {\n#if MG_ARCH == MG_ARCH_AZURERTOS\n    // AzureRTOS, in non-block socket mode can mark listening socket readable\n    // even it is not. See comment for 'select' func implementation in\n    // nx_bsd.c That's not an error, just should try later\n    if (errno != EAGAIN)\n#endif\n      MG_ERROR((\"%lu accept failed, errno %d\", lsn->id, MG_SOCK_ERR(-1)));\n#if (MG_ARCH != MG_ARCH_WIN32) && !MG_ENABLE_FREERTOS_TCP && \\\n    (MG_ARCH != MG_ARCH_TIRTOS) && !MG_ENABLE_POLL\n  } else if ((long) fd >= FD_SETSIZE) {\n    MG_ERROR((\"%ld > %ld\", (long) fd, (long) FD_SETSIZE));\n    closesocket(fd);\n#endif\n  } else if ((c = mg_alloc_conn(mgr)) == NULL) {\n    MG_ERROR((\"%lu OOM\", lsn->id));\n    closesocket(fd);\n  } else {\n    tomgaddr(&usa, &c->rem, sa_len != sizeof(usa.sin));\n    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);\n    c->fd = S2PTR(fd);\n    MG_EPOLL_ADD(c);\n    mg_set_non_blocking_mode(FD(c));\n    setsockopts(c);\n    c->is_accepted = 1;\n    c->is_hexdumping = lsn->is_hexdumping;\n    c->loc = lsn->loc;\n    c->pfn = lsn->pfn;\n    c->pfn_data = lsn->pfn_data;\n    c->fn = lsn->fn;\n    c->fn_data = lsn->fn_data;\n    MG_DEBUG((\"%lu %p accepted %M -> %M\", c->id, c->fd, mg_print_ip_port,\n              &c->rem, mg_print_ip_port, &c->loc));\n    mg_call(c, MG_EV_OPEN, NULL);\n    mg_call(c, MG_EV_ACCEPT, NULL);\n  }\n}\n\nstatic bool mg_socketpair(MG_SOCKET_TYPE sp[2], union usa usa[2], bool udp) {\n  MG_SOCKET_TYPE sock;\n  socklen_t n = sizeof(usa[0].sin);\n  bool success = false;\n\n  sock = sp[0] = sp[1] = MG_INVALID_SOCKET;\n  (void) memset(&usa[0], 0, sizeof(usa[0]));\n  usa[0].sin.sin_family = AF_INET;\n  *(uint32_t *) &usa->sin.sin_addr = mg_htonl(0x7f000001U);  // 127.0.0.1\n  usa[1] = usa[0];\n\n  if (udp && (sp[0] = socket(AF_INET, SOCK_DGRAM, 0)) != MG_INVALID_SOCKET &&\n      (sp[1] = socket(AF_INET, SOCK_DGRAM, 0)) != MG_INVALID_SOCKET &&\n      bind(sp[0], &usa[0].sa, n) == 0 && bind(sp[1], &usa[1].sa, n) == 0 &&\n      getsockname(sp[0], &usa[0].sa, &n) == 0 &&\n      getsockname(sp[1], &usa[1].sa, &n) == 0 &&\n      connect(sp[0], &usa[1].sa, n) == 0 &&\n      connect(sp[1], &usa[0].sa, n) == 0) {\n    success = true;\n  } else if (!udp &&\n             (sock = socket(AF_INET, SOCK_STREAM, 0)) != MG_INVALID_SOCKET &&\n             bind(sock, &usa[0].sa, n) == 0 &&\n             listen(sock, MG_SOCK_LISTEN_BACKLOG_SIZE) == 0 &&\n             getsockname(sock, &usa[0].sa, &n) == 0 &&\n             (sp[0] = socket(AF_INET, SOCK_STREAM, 0)) != MG_INVALID_SOCKET &&\n             connect(sp[0], &usa[0].sa, n) == 0 &&\n             (sp[1] = raccept(sock, &usa[1], &n)) != MG_INVALID_SOCKET) {\n    success = true;\n  }\n  if (success) {\n    mg_set_non_blocking_mode(sp[1]);\n  } else {\n    if (sp[0] != MG_INVALID_SOCKET) closesocket(sp[0]);\n    if (sp[1] != MG_INVALID_SOCKET) closesocket(sp[1]);\n    sp[0] = sp[1] = MG_INVALID_SOCKET;\n  }\n  if (sock != MG_INVALID_SOCKET) closesocket(sock);\n  return success;\n}\n\nint mg_mkpipe(struct mg_mgr *mgr, mg_event_handler_t fn, void *fn_data,\n              bool udp) {\n  union usa usa[2];\n  MG_SOCKET_TYPE sp[2] = {MG_INVALID_SOCKET, MG_INVALID_SOCKET};\n  struct mg_connection *c = NULL;\n  if (!mg_socketpair(sp, usa, udp)) {\n    MG_ERROR((\"Cannot create socket pair\"));\n  } else if ((c = mg_wrapfd(mgr, (int) sp[1], fn, fn_data)) == NULL) {\n    closesocket(sp[0]);\n    closesocket(sp[1]);\n    sp[0] = sp[1] = MG_INVALID_SOCKET;\n  } else {\n    tomgaddr(&usa[0], &c->rem, false);\n    MG_DEBUG((\"%lu %p pipe %lu\", c->id, c->fd, (unsigned long) sp[0]));\n  }\n  return (int) sp[0];\n}\n\nstatic bool can_read(const struct mg_connection *c) {\n  return c->is_full == false;\n}\n\nstatic bool can_write(const struct mg_connection *c) {\n  return c->is_connecting || (c->send.len > 0 && c->is_tls_hs == 0);\n}\n\nstatic bool skip_iotest(const struct mg_connection *c) {\n  return (c->is_closing || c->is_resolving || FD(c) == MG_INVALID_SOCKET) ||\n         (can_read(c) == false && can_write(c) == false);\n}\n\nstatic void mg_iotest(struct mg_mgr *mgr, int ms) {\n#if MG_ENABLE_FREERTOS_TCP\n  struct mg_connection *c;\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    c->is_readable = c->is_writable = 0;\n    if (skip_iotest(c)) continue;\n    if (can_read(c))\n      FreeRTOS_FD_SET(c->fd, mgr->ss, eSELECT_READ | eSELECT_EXCEPT);\n    if (can_write(c)) FreeRTOS_FD_SET(c->fd, mgr->ss, eSELECT_WRITE);\n  }\n  FreeRTOS_select(mgr->ss, pdMS_TO_TICKS(ms));\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    EventBits_t bits = FreeRTOS_FD_ISSET(c->fd, mgr->ss);\n    c->is_readable = bits & (eSELECT_READ | eSELECT_EXCEPT) ? 1U : 0;\n    c->is_writable = bits & eSELECT_WRITE ? 1U : 0;\n    if (c->fd != MG_INVALID_SOCKET)\n      FreeRTOS_FD_CLR(c->fd, mgr->ss,\n                      eSELECT_READ | eSELECT_EXCEPT | eSELECT_WRITE);\n  }\n#elif MG_ENABLE_EPOLL\n  size_t max = 1;\n  for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) {\n    c->is_readable = c->is_writable = 0;\n    if (mg_tls_pending(c) > 0) ms = 1, c->is_readable = 1;\n    if (can_write(c)) MG_EPOLL_MOD(c, 1);\n    max++;\n  }\n  struct epoll_event *evs = (struct epoll_event *) alloca(max * sizeof(evs[0]));\n  int n = epoll_wait(mgr->epoll_fd, evs, (int) max, ms);\n  for (int i = 0; i < n; i++) {\n    struct mg_connection *c = (struct mg_connection *) evs[i].data.ptr;\n    if (evs[i].events & EPOLLERR) {\n      mg_error(c, \"socket error\");\n    } else if (c->is_readable == 0) {\n      bool rd = evs[i].events & (EPOLLIN | EPOLLHUP);\n      bool wr = evs[i].events & EPOLLOUT;\n      c->is_readable = can_read(c) && rd ? 1U : 0;\n      c->is_writable = can_write(c) && wr ? 1U : 0;\n    }\n  }\n  (void) skip_iotest;\n#elif MG_ENABLE_POLL\n  nfds_t n = 0;\n  for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) n++;\n  struct pollfd *fds = (struct pollfd *) alloca(n * sizeof(fds[0]));\n  memset(fds, 0, n * sizeof(fds[0]));\n  n = 0;\n  for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) {\n    c->is_readable = c->is_writable = 0;\n    if (skip_iotest(c)) {\n      // Socket not valid, ignore\n    } else if (mg_tls_pending(c) > 0) {\n      ms = 1;  // Don't wait if TLS is ready\n    } else {\n      fds[n].fd = FD(c);\n      if (can_read(c)) fds[n].events |= POLLIN;\n      if (can_write(c)) fds[n].events |= POLLOUT;\n      n++;\n    }\n  }\n\n  // MG_INFO((\"poll n=%d ms=%d\", (int) n, ms));\n  if (poll(fds, n, ms) < 0) {\n#if MG_ARCH == MG_ARCH_WIN32\n    if (n == 0) Sleep(ms);  // On Windows, poll fails if no sockets\n#endif\n    memset(fds, 0, n * sizeof(fds[0]));\n  }\n  n = 0;\n  for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) {\n    if (skip_iotest(c)) {\n      // Socket not valid, ignore\n    } else if (mg_tls_pending(c) > 0) {\n      c->is_readable = 1;\n    } else {\n      if (fds[n].revents & POLLERR) {\n        mg_error(c, \"socket error\");\n      } else {\n        c->is_readable =\n            (unsigned) (fds[n].revents & (POLLIN | POLLHUP) ? 1 : 0);\n        c->is_writable = (unsigned) (fds[n].revents & POLLOUT ? 1 : 0);\n      }\n      n++;\n    }\n  }\n#else\n  struct timeval tv = {ms / 1000, (ms % 1000) * 1000}, tv_zero = {0, 0}, *tvp;\n  struct mg_connection *c;\n  fd_set rset, wset, eset;\n  MG_SOCKET_TYPE maxfd = 0;\n  int rc;\n\n  FD_ZERO(&rset);\n  FD_ZERO(&wset);\n  FD_ZERO(&eset);\n  tvp = ms < 0 ? NULL : &tv;\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    c->is_readable = c->is_writable = 0;\n    if (skip_iotest(c)) continue;\n    FD_SET(FD(c), &eset);\n    if (can_read(c)) FD_SET(FD(c), &rset);\n    if (can_write(c)) FD_SET(FD(c), &wset);\n    if (mg_tls_pending(c) > 0) tvp = &tv_zero;\n    if (FD(c) > maxfd) maxfd = FD(c);\n  }\n\n  if ((rc = select((int) maxfd + 1, &rset, &wset, &eset, tvp)) < 0) {\n#if MG_ARCH == MG_ARCH_WIN32\n    if (maxfd == 0) Sleep(ms);  // On Windows, select fails if no sockets\n#else\n    MG_ERROR((\"select: %d %d\", rc, MG_SOCK_ERR(rc)));\n#endif\n    FD_ZERO(&rset);\n    FD_ZERO(&wset);\n    FD_ZERO(&eset);\n  }\n\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    if (FD(c) != MG_INVALID_SOCKET && FD_ISSET(FD(c), &eset)) {\n      mg_error(c, \"socket error\");\n    } else {\n      c->is_readable = FD(c) != MG_INVALID_SOCKET && FD_ISSET(FD(c), &rset);\n      c->is_writable = FD(c) != MG_INVALID_SOCKET && FD_ISSET(FD(c), &wset);\n      if (mg_tls_pending(c) > 0) c->is_readable = 1;\n    }\n  }\n#endif\n}\n\nvoid mg_mgr_poll(struct mg_mgr *mgr, int ms) {\n  struct mg_connection *c, *tmp;\n  uint64_t now;\n\n  mg_iotest(mgr, ms);\n  now = mg_millis();\n  mg_timer_poll(&mgr->timers, now);\n\n  for (c = mgr->conns; c != NULL; c = tmp) {\n    bool is_resp = c->is_resp;\n    tmp = c->next;\n    mg_call(c, MG_EV_POLL, &now);\n    if (is_resp && !c->is_resp) {\n      long n = 0;\n      mg_call(c, MG_EV_READ, &n);\n    }\n    MG_VERBOSE((\"%lu %c%c %c%c%c%c%c\", c->id, c->is_readable ? 'r' : '-',\n                c->is_writable ? 'w' : '-', c->is_tls ? 'T' : 't',\n                c->is_connecting ? 'C' : 'c', c->is_tls_hs ? 'H' : 'h',\n                c->is_resolving ? 'R' : 'r', c->is_closing ? 'C' : 'c'));\n    if (c->is_resolving || c->is_closing) {\n      // Do nothing\n    } else if (c->is_listening && c->is_udp == 0) {\n      if (c->is_readable) accept_conn(mgr, c);\n    } else if (c->is_connecting) {\n      if (c->is_readable || c->is_writable) connect_conn(c);\n    } else if (c->is_tls_hs) {\n      if ((c->is_readable || c->is_writable)) mg_tls_handshake(c);\n    } else {\n      if (c->is_readable) read_conn(c);\n      if (c->is_writable) write_conn(c);\n    }\n\n    if (c->is_draining && c->send.len == 0) c->is_closing = 1;\n    if (c->is_closing) close_conn(c);\n  }\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/ssi.c\"\n#endif\n\n\n\n\n#ifndef MG_MAX_SSI_DEPTH\n#define MG_MAX_SSI_DEPTH 5\n#endif\n\n#ifndef MG_SSI_BUFSIZ\n#define MG_SSI_BUFSIZ 1024\n#endif\n\n#if MG_ENABLE_SSI\nstatic char *mg_ssi(const char *path, const char *root, int depth) {\n  struct mg_iobuf b = {NULL, 0, 0, MG_IO_SIZE};\n  FILE *fp = fopen(path, \"rb\");\n  if (fp != NULL) {\n    char buf[MG_SSI_BUFSIZ], arg[sizeof(buf)];\n    int ch, intag = 0;\n    size_t len = 0;\n    buf[0] = arg[0] = '\\0';\n    while ((ch = fgetc(fp)) != EOF) {\n      if (intag && ch == '>' && buf[len - 1] == '-' && buf[len - 2] == '-') {\n        buf[len++] = (char) (ch & 0xff);\n        buf[len] = '\\0';\n        if (sscanf(buf, \"<!--#include file=\\\"%[^\\\"]\", arg)) {\n          char tmp[MG_PATH_MAX + MG_SSI_BUFSIZ + 10],\n              *p = (char *) path + strlen(path), *data;\n          while (p > path && p[-1] != MG_DIRSEP && p[-1] != '/') p--;\n          mg_snprintf(tmp, sizeof(tmp), \"%.*s%s\", (int) (p - path), path, arg);\n          if (depth < MG_MAX_SSI_DEPTH &&\n              (data = mg_ssi(tmp, root, depth + 1)) != NULL) {\n            mg_iobuf_add(&b, b.len, data, strlen(data));\n            free(data);\n          } else {\n            MG_ERROR((\"%s: file=%s error or too deep\", path, arg));\n          }\n        } else if (sscanf(buf, \"<!--#include virtual=\\\"%[^\\\"]\", arg)) {\n          char tmp[MG_PATH_MAX + MG_SSI_BUFSIZ + 10], *data;\n          mg_snprintf(tmp, sizeof(tmp), \"%s%s\", root, arg);\n          if (depth < MG_MAX_SSI_DEPTH &&\n              (data = mg_ssi(tmp, root, depth + 1)) != NULL) {\n            mg_iobuf_add(&b, b.len, data, strlen(data));\n            free(data);\n          } else {\n            MG_ERROR((\"%s: virtual=%s error or too deep\", path, arg));\n          }\n        } else {\n          // Unknown SSI tag\n          MG_ERROR((\"Unknown SSI tag: %.*s\", (int) len, buf));\n          mg_iobuf_add(&b, b.len, buf, len);\n        }\n        intag = 0;\n        len = 0;\n      } else if (ch == '<') {\n        intag = 1;\n        if (len > 0) mg_iobuf_add(&b, b.len, buf, len);\n        len = 0;\n        buf[len++] = (char) (ch & 0xff);\n      } else if (intag) {\n        if (len == 5 && strncmp(buf, \"<!--#\", 5) != 0) {\n          intag = 0;\n        } else if (len >= sizeof(buf) - 2) {\n          MG_ERROR((\"%s: SSI tag is too large\", path));\n          len = 0;\n        }\n        buf[len++] = (char) (ch & 0xff);\n      } else {\n        buf[len++] = (char) (ch & 0xff);\n        if (len >= sizeof(buf)) {\n          mg_iobuf_add(&b, b.len, buf, len);\n          len = 0;\n        }\n      }\n    }\n    if (len > 0) mg_iobuf_add(&b, b.len, buf, len);\n    if (b.len > 0) mg_iobuf_add(&b, b.len, \"\", 1);  // nul-terminate\n    fclose(fp);\n  }\n  (void) depth;\n  (void) root;\n  return (char *) b.buf;\n}\n\nvoid mg_http_serve_ssi(struct mg_connection *c, const char *root,\n                       const char *fullpath) {\n  const char *headers = \"Content-Type: text/html; charset=utf-8\\r\\n\";\n  char *data = mg_ssi(fullpath, root, 0);\n  mg_http_reply(c, 200, headers, \"%s\", data == NULL ? \"\" : data);\n  free(data);\n}\n#else\nvoid mg_http_serve_ssi(struct mg_connection *c, const char *root,\n                       const char *fullpath) {\n  mg_http_reply(c, 501, NULL, \"SSI not enabled\");\n  (void) root, (void) fullpath;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/str.c\"\n#endif\n\n\nstruct mg_str mg_str_s(const char *s) {\n  struct mg_str str = {s, s == NULL ? 0 : strlen(s)};\n  return str;\n}\n\nstruct mg_str mg_str_n(const char *s, size_t n) {\n  struct mg_str str = {s, n};\n  return str;\n}\n\nint mg_lower(const char *s) {\n  int c = *s;\n  if (c >= 'A' && c <= 'Z') c += 'a' - 'A';\n  return c;\n}\n\nint mg_ncasecmp(const char *s1, const char *s2, size_t len) {\n  int diff = 0;\n  if (len > 0) do {\n      diff = mg_lower(s1++) - mg_lower(s2++);\n    } while (diff == 0 && s1[-1] != '\\0' && --len > 0);\n  return diff;\n}\n\nint mg_casecmp(const char *s1, const char *s2) {\n  return mg_ncasecmp(s1, s2, (size_t) ~0);\n}\n\nint mg_vcmp(const struct mg_str *s1, const char *s2) {\n  size_t n2 = strlen(s2), n1 = s1->len;\n  int r = strncmp(s1->ptr, s2, (n1 < n2) ? n1 : n2);\n  if (r == 0) return (int) (n1 - n2);\n  return r;\n}\n\nint mg_vcasecmp(const struct mg_str *str1, const char *str2) {\n  size_t n2 = strlen(str2), n1 = str1->len;\n  int r = mg_ncasecmp(str1->ptr, str2, (n1 < n2) ? n1 : n2);\n  if (r == 0) return (int) (n1 - n2);\n  return r;\n}\n\nstruct mg_str mg_strdup(const struct mg_str s) {\n  struct mg_str r = {NULL, 0};\n  if (s.len > 0 && s.ptr != NULL) {\n    char *sc = (char *) calloc(1, s.len + 1);\n    if (sc != NULL) {\n      memcpy(sc, s.ptr, s.len);\n      sc[s.len] = '\\0';\n      r.ptr = sc;\n      r.len = s.len;\n    }\n  }\n  return r;\n}\n\nint mg_strcmp(const struct mg_str str1, const struct mg_str str2) {\n  size_t i = 0;\n  while (i < str1.len && i < str2.len) {\n    int c1 = str1.ptr[i];\n    int c2 = str2.ptr[i];\n    if (c1 < c2) return -1;\n    if (c1 > c2) return 1;\n    i++;\n  }\n  if (i < str1.len) return 1;\n  if (i < str2.len) return -1;\n  return 0;\n}\n\nconst char *mg_strstr(const struct mg_str haystack,\n                      const struct mg_str needle) {\n  size_t i;\n  if (needle.len > haystack.len) return NULL;\n  if (needle.len == 0) return haystack.ptr;\n  for (i = 0; i <= haystack.len - needle.len; i++) {\n    if (memcmp(haystack.ptr + i, needle.ptr, needle.len) == 0) {\n      return haystack.ptr + i;\n    }\n  }\n  return NULL;\n}\n\nstatic bool is_space(int c) {\n  return c == ' ' || c == '\\r' || c == '\\n' || c == '\\t';\n}\n\nstruct mg_str mg_strstrip(struct mg_str s) {\n  while (s.len > 0 && is_space((int) *s.ptr)) s.ptr++, s.len--;\n  while (s.len > 0 && is_space((int) *(s.ptr + s.len - 1))) s.len--;\n  return s;\n}\n\nbool mg_match(struct mg_str s, struct mg_str p, struct mg_str *caps) {\n  size_t i = 0, j = 0, ni = 0, nj = 0;\n  if (caps) caps->ptr = NULL, caps->len = 0;\n  while (i < p.len || j < s.len) {\n    if (i < p.len && j < s.len && (p.ptr[i] == '?' || s.ptr[j] == p.ptr[i])) {\n      if (caps == NULL) {\n      } else if (p.ptr[i] == '?') {\n        caps->ptr = &s.ptr[j], caps->len = 1;     // Finalize `?` cap\n        caps++, caps->ptr = NULL, caps->len = 0;  // Init next cap\n      } else if (caps->ptr != NULL && caps->len == 0) {\n        caps->len = (size_t) (&s.ptr[j] - caps->ptr);  // Finalize current cap\n        caps++, caps->len = 0, caps->ptr = NULL;       // Init next cap\n      }\n      i++, j++;\n    } else if (i < p.len && (p.ptr[i] == '*' || p.ptr[i] == '#')) {\n      if (caps && !caps->ptr) caps->len = 0, caps->ptr = &s.ptr[j];  // Init cap\n      ni = i++, nj = j + 1;\n    } else if (nj > 0 && nj <= s.len && (p.ptr[ni] == '#' || s.ptr[j] != '/')) {\n      i = ni, j = nj;\n      if (caps && caps->ptr == NULL && caps->len == 0) {\n        caps--, caps->len = 0;  // Restart previous cap\n      }\n    } else {\n      return false;\n    }\n  }\n  if (caps && caps->ptr && caps->len == 0) {\n    caps->len = (size_t) (&s.ptr[j] - caps->ptr);\n  }\n  return true;\n}\n\nbool mg_globmatch(const char *s1, size_t n1, const char *s2, size_t n2) {\n  return mg_match(mg_str_n(s2, n2), mg_str_n(s1, n1), NULL);\n}\n\nstatic size_t mg_nce(const char *s, size_t n, size_t ofs, size_t *koff,\n                     size_t *klen, size_t *voff, size_t *vlen, char delim) {\n  size_t kvlen, kl;\n  for (kvlen = 0; ofs + kvlen < n && s[ofs + kvlen] != delim;) kvlen++;\n  for (kl = 0; kl < kvlen && s[ofs + kl] != '=';) kl++;\n  if (koff != NULL) *koff = ofs;\n  if (klen != NULL) *klen = kl;\n  if (voff != NULL) *voff = kl < kvlen ? ofs + kl + 1 : 0;\n  if (vlen != NULL) *vlen = kl < kvlen ? kvlen - kl - 1 : 0;\n  ofs += kvlen + 1;\n  return ofs > n ? n : ofs;\n}\n\nbool mg_split(struct mg_str *s, struct mg_str *k, struct mg_str *v, char sep) {\n  size_t koff = 0, klen = 0, voff = 0, vlen = 0, off = 0;\n  if (s->ptr == NULL || s->len == 0) return 0;\n  off = mg_nce(s->ptr, s->len, 0, &koff, &klen, &voff, &vlen, sep);\n  if (k != NULL) *k = mg_str_n(s->ptr + koff, klen);\n  if (v != NULL) *v = mg_str_n(s->ptr + voff, vlen);\n  *s = mg_str_n(s->ptr + off, s->len - off);\n  return off > 0;\n}\n\nbool mg_commalist(struct mg_str *s, struct mg_str *k, struct mg_str *v) {\n  return mg_split(s, k, v, ',');\n}\n\nchar *mg_hex(const void *buf, size_t len, char *to) {\n  const unsigned char *p = (const unsigned char *) buf;\n  const char *hex = \"0123456789abcdef\";\n  size_t i = 0;\n  for (; len--; p++) {\n    to[i++] = hex[p[0] >> 4];\n    to[i++] = hex[p[0] & 0x0f];\n  }\n  to[i] = '\\0';\n  return to;\n}\n\nstatic unsigned char mg_unhex_nimble(unsigned char c) {\n  return (c >= '0' && c <= '9')   ? (unsigned char) (c - '0')\n         : (c >= 'A' && c <= 'F') ? (unsigned char) (c - '7')\n                                  : (unsigned char) (c - 'W');\n}\n\nunsigned long mg_unhexn(const char *s, size_t len) {\n  unsigned long i = 0, v = 0;\n  for (i = 0; i < len; i++) v <<= 4, v |= mg_unhex_nimble(((uint8_t *) s)[i]);\n  return v;\n}\n\nvoid mg_unhex(const char *buf, size_t len, unsigned char *to) {\n  size_t i;\n  for (i = 0; i < len; i += 2) {\n    to[i >> 1] = (unsigned char) mg_unhexn(&buf[i], 2);\n  }\n}\n\nuint64_t mg_tou64(struct mg_str str) {\n  uint64_t result = 0;\n  size_t i = 0;\n  while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\\t')) i++;\n  while (i < str.len && str.ptr[i] >= '0' && str.ptr[i] <= '9') {\n    result *= 10;\n    result += (unsigned) (str.ptr[i] - '0');\n    i++;\n  }\n  return result;\n}\n\nint64_t mg_to64(struct mg_str str) {\n  int64_t result = 0, neg = 1, max = 922337203685477570 /* INT64_MAX/10-10 */;\n  size_t i = 0;\n  while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\\t')) i++;\n  if (i < str.len && str.ptr[i] == '-') neg = -1, i++;\n  while (i < str.len && str.ptr[i] >= '0' && str.ptr[i] <= '9') {\n    if (result > max) return 0;\n    result *= 10;\n    result += (str.ptr[i] - '0');\n    i++;\n  }\n  return result * neg;\n}\n\nchar *mg_remove_double_dots(char *s) {\n  char *saved = s, *p = s;\n  while (*s != '\\0') {\n    *p++ = *s++;\n    if (s[-1] == '/' || s[-1] == '\\\\') {\n      while (s[0] != '\\0') {\n        if (s[0] == '/' || s[0] == '\\\\') {\n          s++;\n        } else if (s[0] == '.' && s[1] == '.' &&\n                   (s[2] == '/' || s[2] == '\\\\')) {\n          s += 2;\n        } else {\n          break;\n        }\n      }\n    }\n  }\n  *p = '\\0';\n  return saved;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/timer.c\"\n#endif\n\n\n\n#define MG_TIMER_CALLED 4\n\nvoid mg_timer_init(struct mg_timer **head, struct mg_timer *t, uint64_t ms,\n                   unsigned flags, void (*fn)(void *), void *arg) {\n  t->id = 0, t->period_ms = ms, t->expire = 0;\n  t->flags = flags, t->fn = fn, t->arg = arg, t->next = *head;\n  *head = t;\n}\n\nvoid mg_timer_free(struct mg_timer **head, struct mg_timer *t) {\n  while (*head && *head != t) head = &(*head)->next;\n  if (*head) *head = t->next;\n}\n\n// t: expiration time, prd: period, now: current time. Return true if expired\nbool mg_timer_expired(uint64_t *t, uint64_t prd, uint64_t now) {\n  if (now + prd < *t) *t = 0;                    // Time wrapped? Reset timer\n  if (*t == 0) *t = now + prd;                   // Firt poll? Set expiration\n  if (*t > now) return false;                    // Not expired yet, return\n  *t = (now - *t) > prd ? now + prd : *t + prd;  // Next expiration time\n  return true;                                   // Expired, return true\n}\n\nvoid mg_timer_poll(struct mg_timer **head, uint64_t now_ms) {\n  struct mg_timer *t, *tmp;\n  for (t = *head; t != NULL; t = tmp) {\n    bool once = t->expire == 0 && (t->flags & MG_TIMER_RUN_NOW) &&\n                !(t->flags & MG_TIMER_CALLED);  // Handle MG_TIMER_NOW only once\n    bool expired = mg_timer_expired(&t->expire, t->period_ms, now_ms);\n    tmp = t->next;\n    if (!once && !expired) continue;\n    if ((t->flags & MG_TIMER_REPEAT) || !(t->flags & MG_TIMER_CALLED)) {\n      t->fn(t->arg);\n    }\n    t->flags |= MG_TIMER_CALLED;\n  }\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tls_dummy.c\"\n#endif\n\n\n#if !MG_ENABLE_MBEDTLS && !MG_ENABLE_OPENSSL && !MG_ENABLE_CUSTOM_TLS\nvoid mg_tls_init(struct mg_connection *c, const struct mg_tls_opts *opts) {\n  (void) opts;\n  mg_error(c, \"TLS is not enabled\");\n}\nvoid mg_tls_handshake(struct mg_connection *c) {\n  (void) c;\n}\nvoid mg_tls_free(struct mg_connection *c) {\n  (void) c;\n}\nlong mg_tls_recv(struct mg_connection *c, void *buf, size_t len) {\n  return c == NULL || buf == NULL || len == 0 ? 0 : -1;\n}\nlong mg_tls_send(struct mg_connection *c, const void *buf, size_t len) {\n  return c == NULL || buf == NULL || len == 0 ? 0 : -1;\n}\nsize_t mg_tls_pending(struct mg_connection *c) {\n  (void) c;\n  return 0;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tls_mbed.c\"\n#endif\n\n\n\n\n#if MG_ENABLE_MBEDTLS\n\n#if defined(MBEDTLS_VERSION_NUMBER) && MBEDTLS_VERSION_NUMBER >= 0x03000000\n#define MGRNG , rng_get, NULL\n#else\n#define MGRNG\n#endif\n\nvoid mg_tls_free(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  if (tls != NULL) {\n    free(tls->cafile);\n    mbedtls_ssl_free(&tls->ssl);\n    mbedtls_pk_free(&tls->pk);\n    mbedtls_x509_crt_free(&tls->ca);\n    mbedtls_x509_crt_free(&tls->cert);\n    mbedtls_ssl_config_free(&tls->conf);\n    free(tls);\n    c->tls = NULL;\n  }\n}\n\nstatic int mg_net_send(void *ctx, const unsigned char *buf, size_t len) {\n  long n = mg_io_send((struct mg_connection *) ctx, buf, len);\n  MG_VERBOSE((\"%lu n=%ld e=%d\", ((struct mg_connection *) ctx)->id, n, errno));\n  if (n == MG_IO_WAIT) return MBEDTLS_ERR_SSL_WANT_WRITE;\n  if (n == MG_IO_RESET) return MBEDTLS_ERR_NET_CONN_RESET;\n  if (n == MG_IO_ERR) return MBEDTLS_ERR_NET_SEND_FAILED;\n  return (int) n;\n}\n\nstatic int mg_net_recv(void *ctx, unsigned char *buf, size_t len) {\n  long n = mg_io_recv((struct mg_connection *) ctx, buf, len);\n  MG_VERBOSE((\"%lu n=%ld\", ((struct mg_connection *) ctx)->id, n));\n  if (n == MG_IO_WAIT) return MBEDTLS_ERR_SSL_WANT_WRITE;\n  if (n == MG_IO_RESET) return MBEDTLS_ERR_NET_CONN_RESET;\n  if (n == MG_IO_ERR) return MBEDTLS_ERR_NET_RECV_FAILED;\n  return (int) n;\n}\n\nvoid mg_tls_handshake(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  int rc = mbedtls_ssl_handshake(&tls->ssl);\n  if (rc == 0) {  // Success\n    MG_DEBUG((\"%lu success\", c->id));\n    c->is_tls_hs = 0;\n    mg_call(c, MG_EV_TLS_HS, NULL);\n  } else if (rc == MBEDTLS_ERR_SSL_WANT_READ ||\n             rc == MBEDTLS_ERR_SSL_WANT_WRITE) {  // Still pending\n    MG_VERBOSE((\"%lu pending, %d%d %d (-%#x)\", c->id, c->is_connecting,\n                c->is_tls_hs, rc, -rc));\n  } else {\n    mg_error(c, \"TLS handshake: -%#x\", -rc);  // Error\n  }\n}\n\nstatic int mbed_rng(void *ctx, unsigned char *buf, size_t len) {\n  mg_random(buf, len);\n  (void) ctx;\n  return 0;\n}\n\nstatic void debug_cb(void *c, int lev, const char *s, int n, const char *s2) {\n  n = (int) strlen(s2) - 1;\n  MG_INFO((\"%lu %d %.*s\", ((struct mg_connection *) c)->id, lev, n, s2));\n  (void) s;\n}\n\n#if defined(MBEDTLS_VERSION_NUMBER) && MBEDTLS_VERSION_NUMBER >= 0x03000000\nstatic int rng_get(void *p_rng, unsigned char *buf, size_t len) {\n  (void) p_rng;\n  mg_random(buf, len);\n  return 0;\n}\n#endif\n\nstatic struct mg_str mg_loadfile(struct mg_fs *fs, const char *path) {\n  size_t n = 0;\n  if (path[0] == '-') return mg_str(path);\n  char *p = mg_file_read(fs, path, &n);\n  return mg_str_n(p, n);\n}\n\nvoid mg_tls_init(struct mg_connection *c, const struct mg_tls_opts *opts) {\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct mg_tls *tls = (struct mg_tls *) calloc(1, sizeof(*tls));\n  int rc = 0;\n  c->tls = tls;\n  if (c->tls == NULL) {\n    mg_error(c, \"TLS OOM\");\n    goto fail;\n  }\n  MG_DEBUG((\"%lu Setting TLS\", c->id));\n  mbedtls_ssl_init(&tls->ssl);\n  mbedtls_ssl_config_init(&tls->conf);\n  mbedtls_x509_crt_init(&tls->ca);\n  mbedtls_x509_crt_init(&tls->cert);\n  mbedtls_pk_init(&tls->pk);\n  mbedtls_ssl_conf_dbg(&tls->conf, debug_cb, c);\n#if defined(MG_MBEDTLS_DEBUG_LEVEL)\n  mbedtls_debug_set_threshold(MG_MBEDTLS_DEBUG_LEVEL);\n#endif\n  if ((rc = mbedtls_ssl_config_defaults(\n           &tls->conf,\n           c->is_client ? MBEDTLS_SSL_IS_CLIENT : MBEDTLS_SSL_IS_SERVER,\n           MBEDTLS_SSL_TRANSPORT_STREAM, MBEDTLS_SSL_PRESET_DEFAULT)) != 0) {\n    mg_error(c, \"tls defaults %#x\", -rc);\n    goto fail;\n  }\n  mbedtls_ssl_conf_rng(&tls->conf, mbed_rng, c);\n  if (opts->ca == NULL || strcmp(opts->ca, \"*\") == 0) {\n    mbedtls_ssl_conf_authmode(&tls->conf, MBEDTLS_SSL_VERIFY_NONE);\n  } else if (opts->ca != NULL && opts->ca[0] != '\\0') {\n#if defined(MBEDTLS_X509_CA_CHAIN_ON_DISK)\n    tls->cafile = strdup(opts->ca);\n    rc = mbedtls_ssl_conf_ca_chain_file(&tls->conf, tls->cafile, NULL);\n    if (rc != 0) {\n      mg_error(c, \"parse on-disk chain(%s) err %#x\", tls->cafile, -rc);\n      goto fail;\n    }\n#else\n    struct mg_str s = mg_loadfile(fs, opts->ca);\n    rc = mbedtls_x509_crt_parse(&tls->ca, (uint8_t *) s.ptr, s.len + 1);\n    if (opts->ca[0] != '-') free((char *) s.ptr);\n    if (rc != 0) {\n      mg_error(c, \"parse(%s) err %#x\", opts->ca, -rc);\n      goto fail;\n    }\n    mbedtls_ssl_conf_ca_chain(&tls->conf, &tls->ca, NULL);\n#endif\n    if (opts->srvname.len > 0) {\n      char *x = mg_mprintf(\"%.*s\", (int) opts->srvname.len, opts->srvname.ptr);\n      mbedtls_ssl_set_hostname(&tls->ssl, x);\n      free(x);\n    }\n    mbedtls_ssl_conf_authmode(&tls->conf, MBEDTLS_SSL_VERIFY_REQUIRED);\n  }\n  if (opts->cert != NULL && opts->cert[0] != '\\0') {\n    struct mg_str s = mg_loadfile(fs, opts->cert);\n    const char *key = opts->certkey == NULL ? opts->cert : opts->certkey;\n    rc = mbedtls_x509_crt_parse(&tls->cert, (uint8_t *) s.ptr, s.len + 1);\n    if (opts->cert[0] != '-') free((char *) s.ptr);\n    if (rc != 0) {\n      mg_error(c, \"parse(%s) err %#x\", opts->cert, -rc);\n      goto fail;\n    }\n    s = mg_loadfile(fs, key);\n    rc = mbedtls_pk_parse_key(&tls->pk, (uint8_t *) s.ptr, s.len + 1, NULL,\n                              0 MGRNG);\n    if (key[0] != '-') free((char *) s.ptr);\n    if (rc != 0) {\n      mg_error(c, \"tls key(%s) %#x\", key, -rc);\n      goto fail;\n    }\n    rc = mbedtls_ssl_conf_own_cert(&tls->conf, &tls->cert, &tls->pk);\n    if (rc != 0) {\n      mg_error(c, \"own cert %#x\", -rc);\n      goto fail;\n    }\n  }\n  if ((rc = mbedtls_ssl_setup(&tls->ssl, &tls->conf)) != 0) {\n    mg_error(c, \"setup err %#x\", -rc);\n    goto fail;\n  }\n  c->tls = tls;\n  c->is_tls = 1;\n  c->is_tls_hs = 1;\n  mbedtls_ssl_set_bio(&tls->ssl, c, mg_net_send, mg_net_recv, 0);\n  if (c->is_client && c->is_resolving == 0 && c->is_connecting == 0) {\n    mg_tls_handshake(c);\n  }\n  return;\nfail:\n  mg_tls_free(c);\n}\n\nsize_t mg_tls_pending(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  return tls == NULL ? 0 : mbedtls_ssl_get_bytes_avail(&tls->ssl);\n}\n\nlong mg_tls_recv(struct mg_connection *c, void *buf, size_t len) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  long n = mbedtls_ssl_read(&tls->ssl, (unsigned char *) buf, len);\n  if (n == MBEDTLS_ERR_SSL_WANT_READ || n == MBEDTLS_ERR_SSL_WANT_WRITE)\n    return MG_IO_WAIT;\n  if (n <= 0) return MG_IO_ERR;\n  return n;\n}\n\nlong mg_tls_send(struct mg_connection *c, const void *buf, size_t len) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  long n = mbedtls_ssl_write(&tls->ssl, (unsigned char *) buf, len);\n  if (n == MBEDTLS_ERR_SSL_WANT_READ || n == MBEDTLS_ERR_SSL_WANT_WRITE)\n    return MG_IO_WAIT;\n  if (n <= 0) return MG_IO_ERR;\n  return n;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tls_openssl.c\"\n#endif\n\n\n\n#if MG_ENABLE_OPENSSL\nstatic int mg_tls_err(struct mg_tls *tls, int res) {\n  int err = SSL_get_error(tls->ssl, res);\n  // We've just fetched the last error from the queue.\n  // Now we need to clear the error queue. If we do not, then the following\n  // can happen (actually reported):\n  //  - A new connection is accept()-ed with cert error (e.g. self-signed cert)\n  //  - Since all accept()-ed connections share listener's context,\n  //  - *ALL* SSL accepted connection report read error on the next poll cycle.\n  //    Thus a single errored connection can close all the rest, unrelated ones.\n  // Clearing the error keeps the shared SSL_CTX in an OK state.\n\n  if (err != 0) ERR_print_errors_fp(stderr);\n  ERR_clear_error();\n  if (err == SSL_ERROR_WANT_READ) return 0;\n  if (err == SSL_ERROR_WANT_WRITE) return 0;\n  return err;\n}\n\nvoid mg_tls_init(struct mg_connection *c, const struct mg_tls_opts *opts) {\n  struct mg_tls *tls = (struct mg_tls *) calloc(1, sizeof(*tls));\n  const char *id = \"mongoose\";\n  static unsigned char s_initialised = 0;\n  int rc;\n\n  if (tls == NULL) {\n    mg_error(c, \"TLS OOM\");\n    goto fail;\n  }\n\n  if (!s_initialised) {\n    SSL_library_init();\n    s_initialised++;\n  }\n  MG_DEBUG((\"%lu Setting TLS, CA: %s, cert: %s, key: %s\", c->id,\n            opts->ca == NULL ? \"null\" : opts->ca,\n            opts->cert == NULL ? \"null\" : opts->cert,\n            opts->certkey == NULL ? \"null\" : opts->certkey));\n  tls->ctx = c->is_client ? SSL_CTX_new(SSLv23_client_method())\n                          : SSL_CTX_new(SSLv23_server_method());\n  if ((tls->ssl = SSL_new(tls->ctx)) == NULL) {\n    mg_error(c, \"SSL_new\");\n    goto fail;\n  }\n  SSL_set_session_id_context(tls->ssl, (const uint8_t *) id,\n                             (unsigned) strlen(id));\n  // Disable deprecated protocols\n  SSL_set_options(tls->ssl, SSL_OP_NO_SSLv2);\n  SSL_set_options(tls->ssl, SSL_OP_NO_SSLv3);\n  SSL_set_options(tls->ssl, SSL_OP_NO_TLSv1);\n  SSL_set_options(tls->ssl, SSL_OP_NO_TLSv1_1);\n#ifdef MG_ENABLE_OPENSSL_NO_COMPRESSION\n  SSL_set_options(tls->ssl, SSL_OP_NO_COMPRESSION);\n#endif\n#ifdef MG_ENABLE_OPENSSL_CIPHER_SERVER_PREFERENCE\n  SSL_set_options(tls->ssl, SSL_OP_CIPHER_SERVER_PREFERENCE);\n#endif\n\n  if (opts->ca != NULL && opts->ca[0] != '\\0') {\n    SSL_set_verify(tls->ssl, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,\n                   NULL);\n    if ((rc = SSL_CTX_load_verify_locations(tls->ctx, opts->ca, NULL)) != 1) {\n      mg_error(c, \"load('%s') %d err %d\", opts->ca, rc, mg_tls_err(tls, rc));\n      goto fail;\n    }\n  }\n  if (opts->cert != NULL && opts->cert[0] != '\\0') {\n    const char *key = opts->certkey;\n    if (key == NULL) key = opts->cert;\n    if ((rc = SSL_use_certificate_file(tls->ssl, opts->cert, 1)) != 1) {\n      mg_error(c, \"Invalid SSL cert, err %d\", mg_tls_err(tls, rc));\n      goto fail;\n    } else if ((rc = SSL_use_PrivateKey_file(tls->ssl, key, 1)) != 1) {\n      mg_error(c, \"Invalid SSL key, err %d\", mg_tls_err(tls, rc));\n      goto fail;\n#if OPENSSL_VERSION_NUMBER > 0x10100000L\n    } else if ((rc = SSL_use_certificate_chain_file(tls->ssl, opts->cert)) !=\n               1) {\n      mg_error(c, \"Invalid chain, err %d\", mg_tls_err(tls, rc));\n      goto fail;\n#endif\n    } else {\n      SSL_set_mode(tls->ssl, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);\n#if OPENSSL_VERSION_NUMBER > 0x10002000L\n      SSL_set_ecdh_auto(tls->ssl, 1);\n#endif\n    }\n  }\n  if (opts->ciphers != NULL) SSL_set_cipher_list(tls->ssl, opts->ciphers);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n  if (opts->srvname.len > 0) {\n    char *s = mg_mprintf(\"%.*s\", (int) opts->srvname.len, opts->srvname.ptr);\n    SSL_set1_host(tls->ssl, s);\n    SSL_set_tlsext_host_name(tls->ssl, s);\n    free(s);\n  }\n#endif\n  c->tls = tls;\n  c->is_tls = 1;\n  c->is_tls_hs = 1;\n  if (c->is_client && c->is_resolving == 0 && c->is_connecting == 0) {\n    mg_tls_handshake(c);\n  }\n  MG_DEBUG((\"%lu SSL %s OK\", c->id, c->is_accepted ? \"accept\" : \"client\"));\n  return;\nfail:\n  c->is_closing = 1;\n  free(tls);\n}\n\nvoid mg_tls_handshake(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  int rc;\n  SSL_set_fd(tls->ssl, (int) (size_t) c->fd);\n  rc = c->is_client ? SSL_connect(tls->ssl) : SSL_accept(tls->ssl);\n  if (rc == 1) {\n    MG_DEBUG((\"%lu success\", c->id));\n    c->is_tls_hs = 0;\n    mg_call(c, MG_EV_TLS_HS, NULL);\n  } else {\n    int code = mg_tls_err(tls, rc);\n    if (code != 0) mg_error(c, \"tls hs: rc %d, err %d\", rc, code);\n  }\n}\n\nvoid mg_tls_free(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  if (tls == NULL) return;\n  SSL_free(tls->ssl);\n  SSL_CTX_free(tls->ctx);\n  free(tls);\n  c->tls = NULL;\n}\n\nsize_t mg_tls_pending(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  return tls == NULL ? 0 : (size_t) SSL_pending(tls->ssl);\n}\n\nlong mg_tls_recv(struct mg_connection *c, void *buf, size_t len) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  int n = SSL_read(tls->ssl, buf, (int) len);\n  if (n < 0 && mg_tls_err(tls, n) == 0) return MG_IO_WAIT;\n  if (n <= 0) return MG_IO_ERR;\n  return n;\n}\n\nlong mg_tls_send(struct mg_connection *c, const void *buf, size_t len) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  int n = SSL_write(tls->ssl, buf, (int) len);\n  if (n < 0 && mg_tls_err(tls, n) == 0) return MG_IO_WAIT;\n  if (n <= 0) return MG_IO_ERR;\n  return n;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/url.c\"\n#endif\n\n\nstruct url {\n  size_t key, user, pass, host, port, uri, end;\n};\n\nint mg_url_is_ssl(const char *url) {\n  return strncmp(url, \"wss:\", 4) == 0 || strncmp(url, \"https:\", 6) == 0 ||\n         strncmp(url, \"mqtts:\", 6) == 0 || strncmp(url, \"ssl:\", 4) == 0 ||\n         strncmp(url, \"tls:\", 4) == 0;\n}\n\nstatic struct url urlparse(const char *url) {\n  size_t i;\n  struct url u;\n  memset(&u, 0, sizeof(u));\n  for (i = 0; url[i] != '\\0'; i++) {\n    if (url[i] == '/' && i > 0 && u.host == 0 && url[i - 1] == '/') {\n      u.host = i + 1;\n      u.port = 0;\n    } else if (url[i] == ']') {\n      u.port = 0;  // IPv6 URLs, like http://[::1]/bar\n    } else if (url[i] == ':' && u.port == 0 && u.uri == 0) {\n      u.port = i + 1;\n    } else if (url[i] == '@' && u.user == 0 && u.pass == 0 && u.uri == 0) {\n      u.user = u.host;\n      u.pass = u.port;\n      u.host = i + 1;\n      u.port = 0;\n    } else if (url[i] == '/' && u.host && u.uri == 0) {\n      u.uri = i;\n    }\n  }\n  u.end = i;\n#if 0\n  printf(\"[%s] %d %d %d %d %d\\n\", url, u.user, u.pass, u.host, u.port, u.uri);\n#endif\n  return u;\n}\n\nstruct mg_str mg_url_host(const char *url) {\n  struct url u = urlparse(url);\n  size_t n = u.port  ? u.port - u.host - 1\n             : u.uri ? u.uri - u.host\n                     : u.end - u.host;\n  struct mg_str s = mg_str_n(url + u.host, n);\n  return s;\n}\n\nconst char *mg_url_uri(const char *url) {\n  struct url u = urlparse(url);\n  return u.uri ? url + u.uri : \"/\";\n}\n\nunsigned short mg_url_port(const char *url) {\n  struct url u = urlparse(url);\n  unsigned short port = 0;\n  if (strncmp(url, \"http:\", 5) == 0 || strncmp(url, \"ws:\", 3) == 0) port = 80;\n  if (strncmp(url, \"wss:\", 4) == 0 || strncmp(url, \"https:\", 6) == 0)\n    port = 443;\n  if (strncmp(url, \"mqtt:\", 5) == 0) port = 1883;\n  if (strncmp(url, \"mqtts:\", 6) == 0) port = 8883;\n  if (u.port) port = (unsigned short) atoi(url + u.port);\n  return port;\n}\n\nstruct mg_str mg_url_user(const char *url) {\n  struct url u = urlparse(url);\n  struct mg_str s = mg_str(\"\");\n  if (u.user && (u.pass || u.host)) {\n    size_t n = u.pass ? u.pass - u.user - 1 : u.host - u.user - 1;\n    s = mg_str_n(url + u.user, n);\n  }\n  return s;\n}\n\nstruct mg_str mg_url_pass(const char *url) {\n  struct url u = urlparse(url);\n  struct mg_str s = mg_str_n(\"\", 0UL);\n  if (u.pass && u.host) {\n    size_t n = u.host - u.pass - 1;\n    s = mg_str_n(url + u.pass, n);\n  }\n  return s;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/util.c\"\n#endif\n\n\n#if MG_ENABLE_CUSTOM_RANDOM\n#else\nvoid mg_random(void *buf, size_t len) {\n  bool done = false;\n  unsigned char *p = (unsigned char *) buf;\n#if MG_ARCH == MG_ARCH_ESP32\n  while (len--) *p++ = (unsigned char) (esp_random() & 255);\n  done = true;\n#elif MG_ARCH == MG_ARCH_WIN32\n#elif MG_ARCH == MG_ARCH_UNIX\n  FILE *fp = fopen(\"/dev/urandom\", \"rb\");\n  if (fp != NULL) {\n    if (fread(buf, 1, len, fp) == len) done = true;\n    fclose(fp);\n  }\n#endif\n  // If everything above did not work, fallback to a pseudo random generator\n  while (!done && len--) *p++ = (unsigned char) (rand() & 255);\n}\n#endif\n\nchar *mg_random_str(char *buf, size_t len) {\n  size_t i;\n  mg_random(buf, len);\n  for (i = 0; i < len; i++) {\n    uint8_t c = ((uint8_t *) buf)[i] % 62U;\n    buf[i] = i == len - 1 ? (char) '\\0'            // 0-terminate last byte\n             : c < 26     ? (char) ('a' + c)       // lowercase\n             : c < 52     ? (char) ('A' + c - 26)  // uppercase\n                          : (char) ('0' + c - 52);     // numeric\n  }\n  return buf;\n}\n\nuint32_t mg_ntohl(uint32_t net) {\n  uint8_t data[4] = {0, 0, 0, 0};\n  memcpy(&data, &net, sizeof(data));\n  return (((uint32_t) data[3]) << 0) | (((uint32_t) data[2]) << 8) |\n         (((uint32_t) data[1]) << 16) | (((uint32_t) data[0]) << 24);\n}\n\nuint16_t mg_ntohs(uint16_t net) {\n  uint8_t data[2] = {0, 0};\n  memcpy(&data, &net, sizeof(data));\n  return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));\n}\n\nuint32_t mg_crc32(uint32_t crc, const char *buf, size_t len) {\n  static const uint32_t crclut[16] = {\n      // table for polynomial 0xEDB88320 (reflected)\n      0x00000000, 0x1DB71064, 0x3B6E20C8, 0x26D930AC, 0x76DC4190, 0x6B6B51F4,\n      0x4DB26158, 0x5005713C, 0xEDB88320, 0xF00F9344, 0xD6D6A3E8, 0xCB61B38C,\n      0x9B64C2B0, 0x86D3D2D4, 0xA00AE278, 0xBDBDF21C};\n  crc = ~crc;\n  while (len--) {\n    uint8_t byte = *(uint8_t *)buf++;\n    crc = crclut[(crc ^ byte) & 0x0F] ^ (crc >> 4);\n    crc = crclut[(crc ^ (byte >> 4)) & 0x0F] ^ (crc >> 4);\n  }\n  return ~crc;\n}\n\nstatic int isbyte(int n) {\n  return n >= 0 && n <= 255;\n}\n\nstatic int parse_net(const char *spec, uint32_t *net, uint32_t *mask) {\n  int n, a, b, c, d, slash = 32, len = 0;\n  if ((sscanf(spec, \"%d.%d.%d.%d/%d%n\", &a, &b, &c, &d, &slash, &n) == 5 ||\n       sscanf(spec, \"%d.%d.%d.%d%n\", &a, &b, &c, &d, &n) == 4) &&\n      isbyte(a) && isbyte(b) && isbyte(c) && isbyte(d) && slash >= 0 &&\n      slash < 33) {\n    len = n;\n    *net = ((uint32_t) a << 24) | ((uint32_t) b << 16) | ((uint32_t) c << 8) |\n           (uint32_t) d;\n    *mask = slash ? (uint32_t) (0xffffffffU << (32 - slash)) : (uint32_t) 0;\n  }\n  return len;\n}\n\nint mg_check_ip_acl(struct mg_str acl, uint32_t remote_ip) {\n  struct mg_str k, v;\n  int allowed = acl.len == 0 ? '+' : '-';  // If any ACL is set, deny by default\n  while (mg_commalist(&acl, &k, &v)) {\n    uint32_t net, mask;\n    if (k.ptr[0] != '+' && k.ptr[0] != '-') return -1;\n    if (parse_net(&k.ptr[1], &net, &mask) == 0) return -2;\n    if ((mg_ntohl(remote_ip) & mask) == net) allowed = k.ptr[0];\n  }\n  return allowed == '+';\n}\n\n#if MG_ENABLE_CUSTOM_MILLIS\n#else\nuint64_t mg_millis(void) {\n#if MG_ARCH == MG_ARCH_WIN32\n  return GetTickCount();\n#elif MG_ARCH == MG_ARCH_RP2040\n  return time_us_64() / 1000;\n#elif MG_ARCH == MG_ARCH_ESP32\n  return esp_timer_get_time() / 1000;\n#elif MG_ARCH == MG_ARCH_ESP8266 || MG_ARCH == MG_ARCH_FREERTOS\n  return xTaskGetTickCount() * portTICK_PERIOD_MS;\n#elif MG_ARCH == MG_ARCH_AZURERTOS\n  return tx_time_get() * (1000 /* MS per SEC */ / TX_TIMER_TICKS_PER_SECOND);\n#elif MG_ARCH == MG_ARCH_TIRTOS\n  return (uint64_t) Clock_getTicks();\n#elif MG_ARCH == MG_ARCH_ZEPHYR\n  return (uint64_t) k_uptime_get();\n#elif MG_ARCH == MG_ARCH_CMSIS_RTOS1\n  return (uint64_t)rt_time_get();\n#elif MG_ARCH == MG_ARCH_CMSIS_RTOS2\n  return (uint64_t)((osKernelGetTickCount() * 1000) / osKernelGetTickFreq());\n#elif MG_ARCH == MG_ARCH_UNIX && defined(__APPLE__)\n  // Apple CLOCK_MONOTONIC_RAW is equivalent to CLOCK_BOOTTIME on linux\n  // Apple CLOCK_UPTIME_RAW is equivalent to CLOCK_MONOTONIC_RAW on linux\n  return clock_gettime_nsec_np(CLOCK_UPTIME_RAW) / 1000000;\n#elif MG_ARCH == MG_ARCH_UNIX\n  struct timespec ts = {0, 0};\n  // See #1615 - prefer monotonic clock\n#if defined(CLOCK_MONOTONIC_RAW)\n  // Raw hardware-based time that is not subject to NTP adjustment\n  clock_gettime(CLOCK_MONOTONIC_RAW, &ts);\n#elif defined(CLOCK_MONOTONIC)\n  // Affected by the incremental adjustments performed by adjtime and NTP\n  clock_gettime(CLOCK_MONOTONIC, &ts);\n#else\n  // Affected by discontinuous jumps in the system time and by the incremental\n  // adjustments performed by adjtime and NTP\n  clock_gettime(CLOCK_REALTIME, &ts);\n#endif\n  return ((uint64_t) ts.tv_sec * 1000 + (uint64_t) ts.tv_nsec / 1000000);\n#elif defined(ARDUINO)\n  return (uint64_t) millis();\n#else\n  return (uint64_t) (time(NULL) * 1000);\n#endif\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/ws.c\"\n#endif\n\n\n\n\n\n\n\n\n\n\n\nstruct ws_msg {\n  uint8_t flags;\n  size_t header_len;\n  size_t data_len;\n};\n\nsize_t mg_ws_vprintf(struct mg_connection *c, int op, const char *fmt,\n                     va_list *ap) {\n  size_t len = c->send.len;\n  size_t n = mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, ap);\n  mg_ws_wrap(c, c->send.len - len, op);\n  return n;\n}\n\nsize_t mg_ws_printf(struct mg_connection *c, int op, const char *fmt, ...) {\n  size_t len = 0;\n  va_list ap;\n  va_start(ap, fmt);\n  len = mg_ws_vprintf(c, op, fmt, &ap);\n  va_end(ap);\n  return len;\n}\n\nstatic void ws_handshake(struct mg_connection *c, const struct mg_str *wskey,\n                         const struct mg_str *wsproto, const char *fmt,\n                         va_list *ap) {\n  const char *magic = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n  unsigned char sha[20], b64_sha[30];\n\n  mg_sha1_ctx sha_ctx;\n  mg_sha1_init(&sha_ctx);\n  mg_sha1_update(&sha_ctx, (unsigned char *) wskey->ptr, wskey->len);\n  mg_sha1_update(&sha_ctx, (unsigned char *) magic, 36);\n  mg_sha1_final(sha, &sha_ctx);\n  mg_base64_encode(sha, sizeof(sha), (char *) b64_sha);\n  mg_xprintf(mg_pfn_iobuf, &c->send,\n             \"HTTP/1.1 101 Switching Protocols\\r\\n\"\n             \"Upgrade: websocket\\r\\n\"\n             \"Connection: Upgrade\\r\\n\"\n             \"Sec-WebSocket-Accept: %s\\r\\n\",\n             b64_sha);\n  if (fmt != NULL) mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, ap);\n  if (wsproto != NULL) {\n    mg_printf(c, \"Sec-WebSocket-Protocol: %.*s\\r\\n\", (int) wsproto->len,\n              wsproto->ptr);\n  }\n  mg_send(c, \"\\r\\n\", 2);\n}\n\nstatic uint32_t be32(const uint8_t *p) {\n  return (((uint32_t) p[3]) << 0) | (((uint32_t) p[2]) << 8) |\n         (((uint32_t) p[1]) << 16) | (((uint32_t) p[0]) << 24);\n}\n\nstatic size_t ws_process(uint8_t *buf, size_t len, struct ws_msg *msg) {\n  size_t i, n = 0, mask_len = 0;\n  memset(msg, 0, sizeof(*msg));\n  if (len >= 2) {\n    n = buf[1] & 0x7f;                // Frame length\n    mask_len = buf[1] & 128 ? 4 : 0;  // last bit is a mask bit\n    msg->flags = buf[0];\n    if (n < 126 && len >= mask_len) {\n      msg->data_len = n;\n      msg->header_len = 2 + mask_len;\n    } else if (n == 126 && len >= 4 + mask_len) {\n      msg->header_len = 4 + mask_len;\n      msg->data_len = (((size_t) buf[2]) << 8) | buf[3];\n    } else if (len >= 10 + mask_len) {\n      msg->header_len = 10 + mask_len;\n      msg->data_len =\n          (size_t) (((uint64_t) be32(buf + 2) << 32) + be32(buf + 6));\n    }\n  }\n  // Sanity check, and integer overflow protection for the boundary check below\n  // data_len should not be larger than 1 Gb\n  if (msg->data_len > 1024 * 1024 * 1024) return 0;\n  if (msg->header_len + msg->data_len > len) return 0;\n  if (mask_len > 0) {\n    uint8_t *p = buf + msg->header_len, *m = p - mask_len;\n    for (i = 0; i < msg->data_len; i++) p[i] ^= m[i & 3];\n  }\n  return msg->header_len + msg->data_len;\n}\n\nstatic size_t mkhdr(size_t len, int op, bool is_client, uint8_t *buf) {\n  size_t n = 0;\n  buf[0] = (uint8_t) (op | 128);\n  if (len < 126) {\n    buf[1] = (unsigned char) len;\n    n = 2;\n  } else if (len < 65536) {\n    uint16_t tmp = mg_htons((uint16_t) len);\n    buf[1] = 126;\n    memcpy(&buf[2], &tmp, sizeof(tmp));\n    n = 4;\n  } else {\n    uint32_t tmp;\n    buf[1] = 127;\n    tmp = mg_htonl((uint32_t) (((uint64_t) len) >> 32));\n    memcpy(&buf[2], &tmp, sizeof(tmp));\n    tmp = mg_htonl((uint32_t) (len & 0xffffffffU));\n    memcpy(&buf[6], &tmp, sizeof(tmp));\n    n = 10;\n  }\n  if (is_client) {\n    buf[1] |= 1 << 7;  // Set masking flag\n    mg_random(&buf[n], 4);\n    n += 4;\n  }\n  return n;\n}\n\nstatic void mg_ws_mask(struct mg_connection *c, size_t len) {\n  if (c->is_client && c->send.buf != NULL) {\n    size_t i;\n    uint8_t *p = c->send.buf + c->send.len - len, *mask = p - 4;\n    for (i = 0; i < len; i++) p[i] ^= mask[i & 3];\n  }\n}\n\nsize_t mg_ws_send(struct mg_connection *c, const void *buf, size_t len,\n                  int op) {\n  uint8_t header[14];\n  size_t header_len = mkhdr(len, op, c->is_client, header);\n  mg_send(c, header, header_len);\n  MG_VERBOSE((\"WS out: %d [%.*s]\", (int) len, (int) len, buf));\n  mg_send(c, buf, len);\n  mg_ws_mask(c, len);\n  return header_len + len;\n}\n\nstatic bool mg_ws_client_handshake(struct mg_connection *c) {\n  int n = mg_http_get_request_len(c->recv.buf, c->recv.len);\n  if (n < 0) {\n    mg_error(c, \"not http\");  // Some just, not an HTTP request\n  } else if (n > 0) {\n    if (n < 15 || memcmp(c->recv.buf + 9, \"101\", 3) != 0) {\n      mg_error(c, \"handshake error\");\n    } else {\n      struct mg_http_message hm;\n      mg_http_parse((char *) c->recv.buf, c->recv.len, &hm);\n      c->is_websocket = 1;\n      mg_call(c, MG_EV_WS_OPEN, &hm);\n    }\n    mg_iobuf_del(&c->recv, 0, (size_t) n);\n  } else {\n    return true;  // Request is not yet received, quit event handler\n  }\n  return false;  // Continue event handler\n}\n\nstatic void mg_ws_cb(struct mg_connection *c, int ev, void *ev_data,\n                     void *fn_data) {\n  struct ws_msg msg;\n  size_t ofs = (size_t) c->pfn_data;\n\n  // assert(ofs < c->recv.len);\n  if (ev == MG_EV_READ) {\n    if (c->is_client && !c->is_websocket && mg_ws_client_handshake(c)) return;\n\n    while (ws_process(c->recv.buf + ofs, c->recv.len - ofs, &msg) > 0) {\n      char *s = (char *) c->recv.buf + ofs + msg.header_len;\n      struct mg_ws_message m = {{s, msg.data_len}, msg.flags};\n      size_t len = msg.header_len + msg.data_len;\n      uint8_t final = msg.flags & 128, op = msg.flags & 15;\n      // MG_VERBOSE (\"fin %d op %d len %d [%.*s]\", final, op,\n      //                       (int) m.data.len, (int) m.data.len, m.data.ptr));\n      switch (op) {\n        case WEBSOCKET_OP_CONTINUE:\n          mg_call(c, MG_EV_WS_CTL, &m);\n          break;\n        case WEBSOCKET_OP_PING:\n          MG_DEBUG((\"%s\", \"WS PONG\"));\n          mg_ws_send(c, s, msg.data_len, WEBSOCKET_OP_PONG);\n          mg_call(c, MG_EV_WS_CTL, &m);\n          break;\n        case WEBSOCKET_OP_PONG:\n          mg_call(c, MG_EV_WS_CTL, &m);\n          break;\n        case WEBSOCKET_OP_TEXT:\n        case WEBSOCKET_OP_BINARY:\n          if (final) mg_call(c, MG_EV_WS_MSG, &m);\n          break;\n        case WEBSOCKET_OP_CLOSE:\n          MG_DEBUG((\"%lu WS CLOSE\", c->id));\n          mg_call(c, MG_EV_WS_CTL, &m);\n          // Echo the payload of the received CLOSE message back to the sender\n          mg_ws_send(c, m.data.ptr, m.data.len, WEBSOCKET_OP_CLOSE);\n          c->is_draining = 1;\n          break;\n        default:\n          // Per RFC6455, close conn when an unknown op is recvd\n          mg_error(c, \"unknown WS op %d\", op);\n          break;\n      }\n\n      // Handle fragmented frames: strip header, keep in c->recv\n      if (final == 0 || op == 0) {\n        if (op) ofs++, len--, msg.header_len--;       // First frame\n        mg_iobuf_del(&c->recv, ofs, msg.header_len);  // Strip header\n        len -= msg.header_len;\n        ofs += len;\n        c->pfn_data = (void *) ofs;\n        // MG_INFO((\"FRAG %d [%.*s]\", (int) ofs, (int) ofs, c->recv.buf));\n      }\n      // Remove non-fragmented frame\n      if (final && op) mg_iobuf_del(&c->recv, ofs, len);\n      // Last chunk of the fragmented frame\n      if (final && !op) {\n        m.flags = c->recv.buf[0];\n        m.data = mg_str_n((char *) &c->recv.buf[1], (size_t) (ofs - 1));\n        mg_call(c, MG_EV_WS_MSG, &m);\n        mg_iobuf_del(&c->recv, 0, ofs);\n        ofs = 0;\n        c->pfn_data = NULL;\n      }\n    }\n  }\n  (void) fn_data;\n  (void) ev_data;\n}\n\nstruct mg_connection *mg_ws_connect(struct mg_mgr *mgr, const char *url,\n                                    mg_event_handler_t fn, void *fn_data,\n                                    const char *fmt, ...) {\n  struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);\n  if (c != NULL) {\n    char nonce[16], key[30];\n    struct mg_str host = mg_url_host(url);\n    mg_random(nonce, sizeof(nonce));\n    mg_base64_encode((unsigned char *) nonce, sizeof(nonce), key);\n    mg_xprintf(mg_pfn_iobuf, &c->send,\n               \"GET %s HTTP/1.1\\r\\n\"\n               \"Upgrade: websocket\\r\\n\"\n               \"Host: %.*s\\r\\n\"\n               \"Connection: Upgrade\\r\\n\"\n               \"Sec-WebSocket-Version: 13\\r\\n\"\n               \"Sec-WebSocket-Key: %s\\r\\n\",\n               mg_url_uri(url), (int) host.len, host.ptr, key);\n    if (fmt != NULL) {\n      va_list ap;\n      va_start(ap, fmt);\n      mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, &ap);\n      va_end(ap);\n    }\n    mg_xprintf(mg_pfn_iobuf, &c->send, \"\\r\\n\");\n    c->pfn = mg_ws_cb;\n    c->pfn_data = NULL;\n  }\n  return c;\n}\n\nvoid mg_ws_upgrade(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *fmt, ...) {\n  struct mg_str *wskey = mg_http_get_header(hm, \"Sec-WebSocket-Key\");\n  c->pfn = mg_ws_cb;\n  c->pfn_data = NULL;\n  if (wskey == NULL) {\n    mg_http_reply(c, 426, \"\", \"WS upgrade expected\\n\");\n    c->is_draining = 1;\n  } else {\n    struct mg_str *wsproto = mg_http_get_header(hm, \"Sec-WebSocket-Protocol\");\n    va_list ap;\n    va_start(ap, fmt);\n    ws_handshake(c, wskey, wsproto, fmt, &ap);\n    va_end(ap);\n    c->is_websocket = 1;\n    c->is_resp = 0;\n    mg_call(c, MG_EV_WS_OPEN, hm);\n  }\n}\n\nsize_t mg_ws_wrap(struct mg_connection *c, size_t len, int op) {\n  uint8_t header[14], *p;\n  size_t header_len = mkhdr(len, op, c->is_client, header);\n\n  // NOTE: order of operations is important!\n  mg_iobuf_add(&c->send, c->send.len, NULL, header_len);\n  p = &c->send.buf[c->send.len - len];         // p points to data\n  memmove(p, p - header_len, len);             // Shift data\n  memcpy(p - header_len, header, header_len);  // Prepend header\n  mg_ws_mask(c, len);                          // Mask data\n\n  return c->send.len;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tcpip/driver_nxpimxrt1020.c\"\n#endif\n\n\n/*\n * Todo\n * This driver doesn't support 10M line autoconfiguration yet.\n * Packets aren't sent if the link negociated 10M line.\n * todo: MAC back auto reconfiguration.\n */\n\n#if MG_ENABLE_TCPIP && defined(MG_ENABLE_DRIVER_IMXRT1020)\nstruct imx_rt1020_enet {\nvolatile uint32_t RESERVED0, EIR, EIMR, RESERVED1, RDAR, TDAR, RESERVED2[3], ECR, RESERVED3[6], MMFR, MSCR, RESERVED4[7], MIBC, RESERVED5[7], RCR, RESERVED6[15], TCR, RESERVED7[7], PALR, PAUR, OPD, TXIC0, TXIC1, TXIC2, RESERVED8, RXIC0, RXIC1, RXIC2, RESERVED9[3], IAUR, IALR, GAUR, GALR, RESERVED10[7], TFWR, RESERVED11[14], RDSR, TDSR, MRBR[2], RSFL, RSEM, RAEM, RAFL, TSEM, TAEM, TAFL, TIPG, FTRL, RESERVED12[3], TACC, RACC, RESERVED13[15], RMON_T_PACKETS, RMON_T_BC_PKT, RMON_T_MC_PKT, RMON_T_CRC_ALIGN, RMON_T_UNDERSIZE, RMON_T_OVERSIZE, RMON_T_FRAG, RMON_T_JAB, RMON_T_COL, RMON_T_P64, RMON_T_P65TO127, RMON_T_P128TO255, RMON_T_P256TO511, RMON_T_P512TO1023, RMON_T_P1024TO2048, RMON_T_GTE2048, RMON_T_OCTETS, IEEE_T_DROP, IEEE_T_FRAME_OK, IEEE_T_1COL, IEEE_T_MCOL, IEEE_T_DEF, IEEE_T_LCOL, IEEE_T_EXCOL, IEEE_T_MACERR, IEEE_T_CSERR, IEEE_T_SQE, IEEE_T_FDXFC, IEEE_T_OCTETS_OK, RESERVED14[3], RMON_R_PACKETS, RMON_R_BC_PKT, RMON_R_MC_PKT, RMON_R_CRC_ALIGN, RMON_R_UNDERSIZE, RMON_R_OVERSIZE, RMON_R_FRAG, RMON_R_JAB, RESERVED15, RMON_R_P64, RMON_R_P65TO127, RMON_R_P128TO255, RMON_R_P256TO511, RMON_R_P512TO1023, RMON_R_P1024TO2047, RMON_R_GTE2048, RMON_R_OCTETS, IEEE_R_DROP, IEEE_R_FRAME_OK, IEEE_R_CRC, IEEE_R_ALIGN, IEEE_R_MACERR, IEEE_R_FDXFC, IEEE_R_OCTETS_OK, RESERVED16[71], ATCR, ATVR, ATOFF, ATPER, ATCOR, ATINC, ATSTMP, RESERVED17[122], TGSR, TCSR0, TCCR0, TCSR1, TCCR1, TCSR2, TCCR2, TCSR3;\n};\n\n#undef ENET\n#define ENET ((struct imx_rt1020_enet *) (uintptr_t) 0x402D8000u)\n\n#undef BIT\n#define BIT(x) ((uint32_t) 1 << (x))\n\n#define ENET_RXBUFF_SIZE 1536 // 1522 Buffer must be 64bits aligned\n#define ENET_TXBUFF_SIZE 1536 // 1522 hence set to 0x600 (1536)\n#define ENET_RXBD_NUM          (4)\n#define ENET_TXBD_NUM          (4)\n\nconst uint32_t EIMR_RX_ERR = 0x2400000;              // Intr mask RXF+EBERR\n\nvoid ETH_IRQHandler(void);\nstatic bool mg_tcpip_driver_imxrt1020_init(struct mg_tcpip_if *ifp);\nstatic void wait_phy_complete(void);\nstatic struct mg_tcpip_if *s_ifp;                         // MIP interface\n\nstatic size_t mg_tcpip_driver_imxrt1020_tx(const void *, size_t , struct mg_tcpip_if *);\nstatic bool mg_tcpip_driver_imxrt1020_up(struct mg_tcpip_if *ifp);\n\nenum { IMXRT1020_PHY_ADDR = 0x02, IMXRT1020_PHY_BCR = 0, IMXRT1020_PHY_BSR = 1 };     // PHY constants\n\nvoid delay(uint32_t);\nvoid delay (uint32_t di) {\n  volatile int dno = 0; // Prevent optimization\n  for (uint32_t i = 0; i < di; i++)\n    for (int j=0; j<20; j++) // PLLx20 (500 MHz/24MHz)\n      dno++;\n}\n\nstatic void wait_phy_complete(void) {\n  delay(0x00010000);\n  const uint32_t delay_max = 0x00100000;\n  uint32_t delay_cnt = 0;\n  while (!(ENET->EIR & BIT(23)) && (delay_cnt < delay_max))\n  {delay_cnt++;}\n  ENET->EIR |= BIT(23); // MII interrupt clear\n}\n\nstatic uint32_t imxrt1020_eth_read_phy(uint8_t addr, uint8_t reg) {\n  ENET->EIR |= BIT(23); // MII interrupt clear\n  uint32_t mask_phy_adr_reg = 0x1f; // 0b00011111: Ensure we write 5 bits (Phy address & register)\n  uint32_t phy_transaction = 0x00;\n  phy_transaction = (0x1 << 30) \\\n                  | (0x2 << 28) \\\n                  | ((uint32_t)(addr & mask_phy_adr_reg) << 23) \\\n                  | ((uint32_t)(reg & mask_phy_adr_reg)  << 18) \\\n                  | (0x2 << 16);\n\n  ENET->MMFR = phy_transaction;\n  wait_phy_complete();\n\n  return (ENET->MMFR & 0x0000ffff);\n}\n\nstatic void imxrt1020_eth_write_phy(uint8_t addr, uint8_t reg, uint32_t val) {\n  ENET->EIR |= BIT(23); // MII interrupt clear\n  uint8_t mask_phy_adr_reg = 0x1f; // 0b00011111: Ensure we write 5 bits (Phy address & register)\n  uint32_t mask_phy_data = 0x0000ffff; // Ensure we write 16 bits (data)\n  addr &= mask_phy_adr_reg;\n  reg &= mask_phy_adr_reg;\n  val &= mask_phy_data;\n  uint32_t phy_transaction = 0x00;\n  phy_transaction = (uint32_t)(0x1 << 30) \\\n                  | (uint32_t)(0x1 << 28) \\\n                  | (uint32_t)(addr << 23) \\\n                  | (uint32_t)(reg  << 18) \\\n                  | (uint32_t)(0x2 << 16) \\\n                  | (uint32_t)(val);\n  ENET->MMFR = phy_transaction;\n  wait_phy_complete();\n}\n\n// FEC RX/TX descriptors (Enhanced descriptor not enabled)\n// Descriptor buffer structure, little endian\n\ntypedef struct enet_bd_struct_def\n{\n    uint16_t length;  // Data length\n    uint16_t control; // Control and status\n    uint32_t *buffer; // Data ptr\n} enet_bd_struct_t;\n\n// Descriptor and buffer globals, in non-cached area, 64 bits aligned.\n\n__attribute__((section(\"NonCacheable,\\\"aw\\\",%nobits @\"))) enet_bd_struct_t rx_buffer_descriptor[(ENET_RXBD_NUM)] __attribute__((aligned((64U))));\n__attribute__((section(\"NonCacheable,\\\"aw\\\",%nobits @\"))) enet_bd_struct_t tx_buffer_descriptor[(ENET_TXBD_NUM)] __attribute__((aligned((64U))));\n\nuint8_t rx_data_buffer[(ENET_RXBD_NUM)][((unsigned int)(((ENET_RXBUFF_SIZE)) + (((64U))-1U)) & (unsigned int)(~(unsigned int)(((64U))-1U)))] __attribute__((aligned((64U))));\nuint8_t tx_data_buffer[(ENET_TXBD_NUM)][((unsigned int)(((ENET_TXBUFF_SIZE)) + (((64U))-1U)) & (unsigned int)(~(unsigned int)(((64U))-1U)))] __attribute__((aligned((64U))));\n\n// Initialise driver imx_rt1020\n\n// static bool mg_tcpip_driver_imxrt1020_init(uint8_t *mac, void *data) { // VO\nstatic bool mg_tcpip_driver_imxrt1020_init(struct mg_tcpip_if *ifp) {\n\n  struct mg_tcpip_driver_imxrt1020_data *d = (struct mg_tcpip_driver_imxrt1020_data *) ifp->driver_data;\n  s_ifp = ifp;\n\n  // ENET Reset, wait complete\n  ENET->ECR |= BIT(0);\n  while((ENET->ECR & BIT(0)) != 0) {}\n\n  // Re-latches the pin strapping pin values\n  ENET->ECR |= BIT(0);\n  while((ENET->ECR & BIT(0)) != 0) {}\n\n  // Setup MII/RMII MDC clock divider (<= 2.5MHz).\n  ENET->MSCR = 0x130; // HOLDTIME 2 clk, Preamble enable, MDC MII_Speed Div 0x30\n  imxrt1020_eth_write_phy(IMXRT1020_PHY_ADDR, IMXRT1020_PHY_BCR, 0x8000); // PHY W @0x00 D=0x8000 Soft reset\n  while (imxrt1020_eth_read_phy(IMXRT1020_PHY_ADDR, IMXRT1020_PHY_BSR) & BIT(15)) {delay(0x5000);} // Wait finished poll 10ms\n\n  // PHY: Start Link\n  {\n    imxrt1020_eth_write_phy(IMXRT1020_PHY_ADDR, IMXRT1020_PHY_BCR, 0x1200); // PHY W @0x00 D=0x1200 Autonego enable + start\n    imxrt1020_eth_write_phy(IMXRT1020_PHY_ADDR, 0x1f, 0x8180);    // PHY W @0x1f D=0x8180 Ref clock 50 MHz at XI input\n\n    uint32_t bcr = imxrt1020_eth_read_phy(IMXRT1020_PHY_ADDR, IMXRT1020_PHY_BCR);\n    bcr &= ~BIT(10); // Isolation -> Normal\n    imxrt1020_eth_write_phy(IMXRT1020_PHY_ADDR, IMXRT1020_PHY_BCR, bcr);\n  }\n\n  // Disable ENET\n  ENET->ECR = 0x0; //  Disable before configuration\n\n  // Configure ENET\n  ENET->RCR = 0x05ee0104; // #CRCFWD=0 (CRC kept in frame) + RMII + MII Enable\n  \n  ENET->TCR = BIT(8) | BIT(2); // Addins (MAC address from PAUR+PALR) + Full duplex enable\n  //ENET->TFWR = BIT(8); // Store And Forward Enable, 64 bytes (minimize tx latency)\n\n  // Configure descriptors and buffers\n  // RX\n  for (int i = 0; i < ENET_RXBD_NUM; i++) {\n    // Wrap last descriptor buffer ptr\n    rx_buffer_descriptor[i].control = (BIT(15) | ((i<(ENET_RXBD_NUM-1))?0:BIT(13))); // E+(W*)\n    rx_buffer_descriptor[i].buffer = (uint32_t *)rx_data_buffer[i];\n  }\n\n  // TX\n  for (int i = 0; i < ENET_TXBD_NUM; i++) {\n    // Wrap last descriptor buffer ptr\n    tx_buffer_descriptor[i].control = ((i<(ENET_RXBD_NUM-1))?0:BIT(13)) | BIT(10); // (W*)+TC\n    tx_buffer_descriptor[i].buffer = (uint32_t *)tx_data_buffer[i];\n  }\n\n  // Continue ENET configuration\n  ENET->RDSR = (uint32_t)(uintptr_t)rx_buffer_descriptor;\n  ENET->TDSR = (uint32_t)(uintptr_t)tx_buffer_descriptor;\n  ENET->MRBR[0] = ENET_RXBUFF_SIZE; // Same size for RX/TX buffers\n\n  // MAC address filtering (bytes in reversed order)\n  ENET->PAUR = ((uint32_t) ifp->mac[4] << 24U) | (uint32_t) ifp->mac[5] << 16U;\n  ENET->PALR = (uint32_t) (ifp->mac[0] << 24U) | ((uint32_t) ifp->mac[1] << 16U) |\n                 ((uint32_t) ifp->mac[2] << 8U) | ifp->mac[3];\n\n  // Init Hash tables (mac filtering)\n  ENET->IAUR = 0; // Unicast\n  ENET->IALR = 0;\n  ENET->GAUR = 0; // Multicast\n  ENET->GALR = 0;\n\n  // Set ENET Online\n  ENET->ECR |= BIT(8); // ENET Set Little-endian + (FEC buffer desc.)\n  ENET->ECR |= BIT(1); // Enable\n\n  // Set interrupt mask\n  ENET->EIMR = EIMR_RX_ERR;\n\n  // RX Descriptor activation\n  ENET->RDAR = BIT(24); // Activate Receive Descriptor\n  return true;\n}\n\n// Transmit frame\nstatic uint32_t s_rt1020_txno;\n\nstatic size_t mg_tcpip_driver_imxrt1020_tx(const void *buf, size_t len, struct mg_tcpip_if *ifp) {\n\n  if (len > sizeof(tx_data_buffer[ENET_TXBD_NUM])) {\n  //  MG_ERROR((\"Frame too big, %ld\", (long) len));\n    len = 0;  // Frame is too big\n  } else if ((tx_buffer_descriptor[s_rt1020_txno].control & BIT(15))) {\n  MG_ERROR((\"No free descriptors\"));\n    // printf(\"D0 %lx SR %lx\\n\", (long) s_txdesc[0][0], (long) ETH->DMASR);\n    len = 0;  // All descriptors are busy, fail\n  } else {\n    memcpy(tx_data_buffer[s_rt1020_txno], buf, len);     // Copy data\n    tx_buffer_descriptor[s_rt1020_txno].length = (uint16_t) len;  // Set data len\n    tx_buffer_descriptor[s_rt1020_txno].control |= (uint16_t)(BIT(10)); // TC (transmit CRC)\n    //  tx_buffer_descriptor[s_rt1020_txno].control &= (uint16_t)(BIT(14) | BIT(12)); // Own doesn't affect HW\n    tx_buffer_descriptor[s_rt1020_txno].control |= (uint16_t)(BIT(15) | BIT(11)); // R+L (ready+last)\n    ENET->TDAR = BIT(24); // Descriptor updated. Hand over to DMA.\n    // INFO\n    // Relevant Descriptor bits: 15(R)  Ready\n    //                           11(L)  last in frame\n    //                           10(TC) transmis CRC\n    // __DSB(); // ARM errata 838869 Cortex-M4, M4F, M7, M7F: \"store immediate overlapping\n                // exception\" return might vector to incorrect interrupt.\n    if (++s_rt1020_txno >= ENET_TXBD_NUM) s_rt1020_txno = 0;\n  }\n  (void) ifp;\n  return len;\n}\n\n// IRQ (RX)\nstatic uint32_t s_rt1020_rxno;\n\nvoid ENET_IRQHandler(void) {\n  ENET->EIMR = 0;           // Mask interrupts.\n  uint32_t eir = ENET->EIR; // Read EIR\n  ENET->EIR = 0xffffffff;   // Clear interrupts\n\n  if (eir & EIMR_RX_ERR) // Global mask used\n  {\n    if (rx_buffer_descriptor[s_rt1020_rxno].control & BIT(15)) {\n      ENET->EIMR = EIMR_RX_ERR; // Enable interrupts\n      return;  // Empty? -> exit.\n    }\n    // Read inframes\n    else { // Frame received, loop\n      for (uint32_t i = 0; i < 10; i++) {  // read as they arrive but not forever\n        if (rx_buffer_descriptor[s_rt1020_rxno].control & BIT(15)) break;  // exit when done\n        // Process if CRC OK and frame not truncated\n        if (!(rx_buffer_descriptor[s_rt1020_rxno].control & (BIT(2) | BIT(0)))) {\n          uint32_t len = (rx_buffer_descriptor[s_rt1020_rxno].length);\n          mg_tcpip_qwrite(rx_buffer_descriptor[s_rt1020_rxno].buffer, len > 4 ? len - 4 : len, s_ifp);\n        }\n        rx_buffer_descriptor[s_rt1020_rxno].control |= BIT(15); // Inform DMA RX is empty\n        if (++s_rt1020_rxno >= ENET_RXBD_NUM) s_rt1020_rxno = 0;\n      }\n    }\n  }\n  ENET->EIMR = EIMR_RX_ERR; // Enable interrupts\n}\n\n// Up/down status\nstatic bool mg_tcpip_driver_imxrt1020_up(struct mg_tcpip_if *ifp) {\n  uint32_t bsr = imxrt1020_eth_read_phy(IMXRT1020_PHY_ADDR, IMXRT1020_PHY_BSR);\n  (void) ifp;\n  return bsr & BIT(2) ? 1 : 0;\n}\n\n// API\nstruct mg_tcpip_driver mg_tcpip_driver_imxrt1020 = {\n  mg_tcpip_driver_imxrt1020_init, mg_tcpip_driver_imxrt1020_tx, NULL,\n  mg_tcpip_driver_imxrt1020_up};\n\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tcpip/driver_stm32.c\"\n#endif\n\n\n#if MG_ENABLE_TCPIP && MG_ENABLE_DRIVER_STM32\nstruct stm32_eth {\n  volatile uint32_t MACCR, MACFFR, MACHTHR, MACHTLR, MACMIIAR, MACMIIDR, MACFCR,\n      MACVLANTR, RESERVED0[2], MACRWUFFR, MACPMTCSR, RESERVED1, MACDBGR, MACSR,\n      MACIMR, MACA0HR, MACA0LR, MACA1HR, MACA1LR, MACA2HR, MACA2LR, MACA3HR,\n      MACA3LR, RESERVED2[40], MMCCR, MMCRIR, MMCTIR, MMCRIMR, MMCTIMR,\n      RESERVED3[14], MMCTGFSCCR, MMCTGFMSCCR, RESERVED4[5], MMCTGFCR,\n      RESERVED5[10], MMCRFCECR, MMCRFAECR, RESERVED6[10], MMCRGUFCR,\n      RESERVED7[334], PTPTSCR, PTPSSIR, PTPTSHR, PTPTSLR, PTPTSHUR, PTPTSLUR,\n      PTPTSAR, PTPTTHR, PTPTTLR, RESERVED8, PTPTSSR, PTPPPSCR, RESERVED9[564],\n      DMABMR, DMATPDR, DMARPDR, DMARDLAR, DMATDLAR, DMASR, DMAOMR, DMAIER,\n      DMAMFBOCR, DMARSWTR, RESERVED10[8], DMACHTDR, DMACHRDR, DMACHTBAR,\n      DMACHRBAR;\n};\n#undef ETH\n#define ETH ((struct stm32_eth *) (uintptr_t) 0x40028000)\n\n#undef BIT\n#define BIT(x) ((uint32_t) 1 << (x))\n#define ETH_PKT_SIZE 1540  // Max frame size\n#define ETH_DESC_CNT 4     // Descriptors count\n#define ETH_DS 4           // Descriptor size (words)\n\nstatic uint32_t s_rxdesc[ETH_DESC_CNT][ETH_DS];      // RX descriptors\nstatic uint32_t s_txdesc[ETH_DESC_CNT][ETH_DS];      // TX descriptors\nstatic uint8_t s_rxbuf[ETH_DESC_CNT][ETH_PKT_SIZE];  // RX ethernet buffers\nstatic uint8_t s_txbuf[ETH_DESC_CNT][ETH_PKT_SIZE];  // TX ethernet buffers\nstatic uint8_t s_txno;                               // Current TX descriptor\nstatic uint8_t s_rxno;                               // Current RX descriptor\n\nstatic struct mg_tcpip_if *s_ifp;  // MIP interface\nenum { PHY_ADDR = 0, PHY_BCR = 0, PHY_BSR = 1, PHY_CSCR = 31 };\n\nstatic uint32_t eth_read_phy(uint8_t addr, uint8_t reg) {\n  ETH->MACMIIAR &= (7 << 2);\n  ETH->MACMIIAR |= ((uint32_t) addr << 11) | ((uint32_t) reg << 6);\n  ETH->MACMIIAR |= BIT(0);\n  while (ETH->MACMIIAR & BIT(0)) (void) 0;\n  return ETH->MACMIIDR;\n}\n\nstatic void eth_write_phy(uint8_t addr, uint8_t reg, uint32_t val) {\n  ETH->MACMIIDR = val;\n  ETH->MACMIIAR &= (7 << 2);\n  ETH->MACMIIAR |= ((uint32_t) addr << 11) | ((uint32_t) reg << 6) | BIT(1);\n  ETH->MACMIIAR |= BIT(0);\n  while (ETH->MACMIIAR & BIT(0)) (void) 0;\n}\n\nstatic uint32_t get_hclk(void) {\n  struct rcc {\n    volatile uint32_t CR, PLLCFGR, CFGR;\n  } *rcc = (struct rcc *) 0x40023800;\n  uint32_t clk = 0, hsi = 16000000 /* 16 MHz */, hse = 8000000 /* 8MHz */;\n\n  if (rcc->CFGR & (1 << 2)) {\n    clk = hse;\n  } else if (rcc->CFGR & (1 << 3)) {\n    uint32_t vco, m, n, p;\n    m = (rcc->PLLCFGR & (0x3f << 0)) >> 0;\n    n = (rcc->PLLCFGR & (0x1ff << 6)) >> 6;\n    p = (((rcc->PLLCFGR & (3 << 16)) >> 16) + 1) * 2;\n    clk = (rcc->PLLCFGR & (1 << 22)) ? hse : hsi;\n    vco = (uint32_t) ((uint64_t) clk * n / m);\n    clk = vco / p;\n  } else {\n    clk = hsi;\n  }\n  uint32_t hpre = (rcc->CFGR & (15 << 4)) >> 4;\n  if (hpre < 8) return clk;\n\n  uint8_t ahbptab[8] = {1, 2, 3, 4, 6, 7, 8, 9};  // log2(div)\n  return ((uint32_t) clk) >> ahbptab[hpre - 8];\n}\n\n//  Guess CR from HCLK. MDC clock is generated from HCLK (AHB); as per 802.3,\n//  it must not exceed 2.5MHz As the AHB clock can be (and usually is) derived\n//  from the HSI (internal RC), and it can go above specs, the datasheets\n//  specify a range of frequencies and activate one of a series of dividers to\n//  keep the MDC clock safely below 2.5MHz. We guess a divider setting based on\n//  HCLK with a +5% drift. If the user uses a different clock from our\n//  defaults, needs to set the macros on top Valid for STM32F74xxx/75xxx\n//  (38.8.1) and STM32F42xxx/43xxx (33.8.1) (both 4.5% worst case drift)\nstatic int guess_mdc_cr(void) {\n  uint8_t crs[] = {2, 3, 0, 1, 4, 5};          // ETH->MACMIIAR::CR values\n  uint8_t div[] = {16, 26, 42, 62, 102, 124};  // Respective HCLK dividers\n  uint32_t hclk = get_hclk();                  // Guess system HCLK\n  int result = -1;                             // Invalid CR value\n  if (hclk < 25000000) {\n    MG_ERROR((\"HCLK too low\"));\n  } else {\n    for (int i = 0; i < 6; i++) {\n      if (hclk / div[i] <= 2375000UL /* 2.5MHz - 5% */) {\n        result = crs[i];\n        break;\n      }\n    }\n    if (result < 0) MG_ERROR((\"HCLK too high\"));\n  }\n  MG_DEBUG((\"HCLK: %u, CR: %d\", hclk, result));\n  return result;\n}\n\nstatic bool mg_tcpip_driver_stm32_init(struct mg_tcpip_if *ifp) {\n  struct mg_tcpip_driver_stm32_data *d =\n      (struct mg_tcpip_driver_stm32_data *) ifp->driver_data;\n  s_ifp = ifp;\n\n  // Init RX descriptors\n  for (int i = 0; i < ETH_DESC_CNT; i++) {\n    s_rxdesc[i][0] = BIT(31);                            // Own\n    s_rxdesc[i][1] = sizeof(s_rxbuf[i]) | BIT(14);       // 2nd address chained\n    s_rxdesc[i][2] = (uint32_t) (uintptr_t) s_rxbuf[i];  // Point to data buffer\n    s_rxdesc[i][3] =\n        (uint32_t) (uintptr_t) s_rxdesc[(i + 1) % ETH_DESC_CNT];  // Chain\n  }\n\n  // Init TX descriptors\n  for (int i = 0; i < ETH_DESC_CNT; i++) {\n    s_txdesc[i][2] = (uint32_t) (uintptr_t) s_txbuf[i];  // Buf pointer\n    s_txdesc[i][3] =\n        (uint32_t) (uintptr_t) s_txdesc[(i + 1) % ETH_DESC_CNT];  // Chain\n  }\n\n  ETH->DMABMR |= BIT(0);                         // Software reset\n  while ((ETH->DMABMR & BIT(0)) != 0) (void) 0;  // Wait until done\n\n  // Set MDC clock divider. If user told us the value, use it. Otherwise, guess\n  int cr = (d == NULL || d->mdc_cr < 0) ? guess_mdc_cr() : d->mdc_cr;\n  ETH->MACMIIAR = ((uint32_t) cr & 7) << 2;\n\n  // NOTE(cpq): we do not use extended descriptor bit 7, and do not use\n  // hardware checksum. Therefore, descriptor size is 4, not 8\n  // ETH->DMABMR = BIT(13) | BIT(16) | BIT(22) | BIT(23) | BIT(25);\n  ETH->MACIMR = BIT(3) | BIT(9);  // Mask timestamp & PMT IT\n  ETH->MACFCR = BIT(7);           // Disable zero quarta pause\n  // ETH->MACFFR = BIT(31);                            // Receive all\n  eth_write_phy(PHY_ADDR, PHY_BCR, BIT(15));           // Reset PHY\n  eth_write_phy(PHY_ADDR, PHY_BCR, BIT(12));           // Set autonegotiation\n  ETH->DMARDLAR = (uint32_t) (uintptr_t) s_rxdesc;     // RX descriptors\n  ETH->DMATDLAR = (uint32_t) (uintptr_t) s_txdesc;     // RX descriptors\n  ETH->DMAIER = BIT(6) | BIT(16);                      // RIE, NISE\n  ETH->MACCR = BIT(2) | BIT(3) | BIT(11) | BIT(14);    // RE, TE, Duplex, Fast\n  ETH->DMAOMR = BIT(1) | BIT(13) | BIT(21) | BIT(25);  // SR, ST, TSF, RSF\n\n  // MAC address filtering\n  ETH->MACA0HR = ((uint32_t) ifp->mac[5] << 8U) | ifp->mac[4];\n  ETH->MACA0LR = (uint32_t) (ifp->mac[3] << 24) |\n                 ((uint32_t) ifp->mac[2] << 16) |\n                 ((uint32_t) ifp->mac[1] << 8) | ifp->mac[0];\n  return true;\n}\n\nstatic size_t mg_tcpip_driver_stm32_tx(const void *buf, size_t len,\n                                       struct mg_tcpip_if *ifp) {\n  if (len > sizeof(s_txbuf[s_txno])) {\n    MG_ERROR((\"Frame too big, %ld\", (long) len));\n    len = 0;  // Frame is too big\n  } else if ((s_txdesc[s_txno][0] & BIT(31))) {\n    ifp->nerr++;\n    MG_ERROR((\"No free descriptors\"));\n    // printf(\"D0 %lx SR %lx\\n\", (long) s_txdesc[0][0], (long) ETH->DMASR);\n    len = 0;  // All descriptors are busy, fail\n  } else {\n    memcpy(s_txbuf[s_txno], buf, len);     // Copy data\n    s_txdesc[s_txno][1] = (uint32_t) len;  // Set data len\n    s_txdesc[s_txno][0] = BIT(20) | BIT(28) | BIT(29) | BIT(30);  // Chain,FS,LS\n    s_txdesc[s_txno][0] |= BIT(31);  // Set OWN bit - let DMA take over\n    if (++s_txno >= ETH_DESC_CNT) s_txno = 0;\n  }\n  ETH->DMASR = BIT(2) | BIT(5);  // Clear any prior TBUS/TUS\n  ETH->DMATPDR = 0;              // and resume\n  return len;\n}\n\nstatic bool mg_tcpip_driver_stm32_up(struct mg_tcpip_if *ifp) {\n  uint32_t bsr = eth_read_phy(PHY_ADDR, PHY_BSR);\n  bool up = bsr & BIT(2) ? 1 : 0;\n  if ((ifp->state == MG_TCPIP_STATE_DOWN) && up) {  // link state just went up\n    uint32_t scsr = eth_read_phy(PHY_ADDR, PHY_CSCR);\n    uint32_t maccr = ETH->MACCR | BIT(14) | BIT(11);  // 100M, Full-duplex\n    if ((scsr & BIT(3)) == 0) maccr &= ~BIT(14);      // 10M\n    if ((scsr & BIT(4)) == 0) maccr &= ~BIT(11);      // Half-duplex\n    ETH->MACCR = maccr;  // IRQ handler does not fiddle with this register\n    MG_DEBUG((\"Link is %uM %s-duplex\", maccr & BIT(14) ? 100 : 10,\n              maccr & BIT(11) ? \"full\" : \"half\"));\n  }\n  return up;\n}\n\nvoid ETH_IRQHandler(void);\nvoid ETH_IRQHandler(void) {\n  if (ETH->DMASR & BIT(6)) {             // Frame received, loop\n    ETH->DMASR = BIT(16) | BIT(6);       // Clear flag\n    for (uint32_t i = 0; i < 10; i++) {  // read as they arrive but not forever\n      if (s_rxdesc[s_rxno][0] & BIT(31)) break;  // exit when done\n      if (((s_rxdesc[s_rxno][0] & (BIT(8) | BIT(9))) == (BIT(8) | BIT(9))) &&\n          !(s_rxdesc[s_rxno][0] & BIT(15))) {  // skip partial/errored frames\n        uint32_t len = ((s_rxdesc[s_rxno][0] >> 16) & (BIT(14) - 1));\n        //  printf(\"%lx %lu %lx %.8lx\\n\", s_rxno, len, s_rxdesc[s_rxno][0],\n        //  ETH->DMASR);\n        mg_tcpip_qwrite(s_rxbuf[s_rxno], len > 4 ? len - 4 : len, s_ifp);\n      }\n      s_rxdesc[s_rxno][0] = BIT(31);\n      if (++s_rxno >= ETH_DESC_CNT) s_rxno = 0;\n    }\n  }\n  ETH->DMASR = BIT(7);  // Clear possible RBUS while processing\n  ETH->DMARPDR = 0;     // and resume RX\n}\n\nstruct mg_tcpip_driver mg_tcpip_driver_stm32 = {mg_tcpip_driver_stm32_init,\n                                                mg_tcpip_driver_stm32_tx, NULL,\n                                                mg_tcpip_driver_stm32_up};\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tcpip/driver_stm32h.c\"\n#endif\n\n\n#if MG_ENABLE_TCPIP && defined(MG_ENABLE_DRIVER_STM32H) && \\\n    MG_ENABLE_DRIVER_STM32H\nstruct stm32h_eth {\n  volatile uint32_t MACCR, MACECR, MACPFR, MACWTR, MACHT0R, MACHT1R,\n      RESERVED1[14], MACVTR, RESERVED2, MACVHTR, RESERVED3, MACVIR, MACIVIR,\n      RESERVED4[2], MACTFCR, RESERVED5[7], MACRFCR, RESERVED6[7], MACISR,\n      MACIER, MACRXTXSR, RESERVED7, MACPCSR, MACRWKPFR, RESERVED8[2], MACLCSR,\n      MACLTCR, MACLETR, MAC1USTCR, RESERVED9[12], MACVR, MACDR, RESERVED10,\n      MACHWF0R, MACHWF1R, MACHWF2R, RESERVED11[54], MACMDIOAR, MACMDIODR,\n      RESERVED12[2], MACARPAR, RESERVED13[59], MACA0HR, MACA0LR, MACA1HR,\n      MACA1LR, MACA2HR, MACA2LR, MACA3HR, MACA3LR, RESERVED14[248], MMCCR,\n      MMCRIR, MMCTIR, MMCRIMR, MMCTIMR, RESERVED15[14], MMCTSCGPR, MMCTMCGPR,\n      RESERVED16[5], MMCTPCGR, RESERVED17[10], MMCRCRCEPR, MMCRAEPR,\n      RESERVED18[10], MMCRUPGR, RESERVED19[9], MMCTLPIMSTR, MMCTLPITCR,\n      MMCRLPIMSTR, MMCRLPITCR, RESERVED20[65], MACL3L4C0R, MACL4A0R,\n      RESERVED21[2], MACL3A0R0R, MACL3A1R0R, MACL3A2R0R, MACL3A3R0R,\n      RESERVED22[4], MACL3L4C1R, MACL4A1R, RESERVED23[2], MACL3A0R1R,\n      MACL3A1R1R, MACL3A2R1R, MACL3A3R1R, RESERVED24[108], MACTSCR, MACSSIR,\n      MACSTSR, MACSTNR, MACSTSUR, MACSTNUR, MACTSAR, RESERVED25, MACTSSR,\n      RESERVED26[3], MACTTSSNR, MACTTSSSR, RESERVED27[2], MACACR, RESERVED28,\n      MACATSNR, MACATSSR, MACTSIACR, MACTSEACR, MACTSICNR, MACTSECNR,\n      RESERVED29[4], MACPPSCR, RESERVED30[3], MACPPSTTSR, MACPPSTTNR, MACPPSIR,\n      MACPPSWR, RESERVED31[12], MACPOCR, MACSPI0R, MACSPI1R, MACSPI2R, MACLMIR,\n      RESERVED32[11], MTLOMR, RESERVED33[7], MTLISR, RESERVED34[55], MTLTQOMR,\n      MTLTQUR, MTLTQDR, RESERVED35[8], MTLQICSR, MTLRQOMR, MTLRQMPOCR, MTLRQDR,\n      RESERVED36[177], DMAMR, DMASBMR, DMAISR, DMADSR, RESERVED37[60], DMACCR,\n      DMACTCR, DMACRCR, RESERVED38[2], DMACTDLAR, RESERVED39, DMACRDLAR,\n      DMACTDTPR, RESERVED40, DMACRDTPR, DMACTDRLR, DMACRDRLR, DMACIER,\n      DMACRIWTR, DMACSFCSR, RESERVED41, DMACCATDR, RESERVED42, DMACCARDR,\n      RESERVED43, DMACCATBR, RESERVED44, DMACCARBR, DMACSR, RESERVED45[2],\n      DMACMFCR;\n};\n#undef ETH\n#define ETH \\\n  ((struct stm32h_eth *) (uintptr_t) (0x40000000UL + 0x00020000UL + 0x8000UL))\n\n#undef BIT\n#define BIT(x) ((uint32_t) 1 << (x))\n#define ETH_PKT_SIZE 1540  // Max frame size\n#define ETH_DESC_CNT 4     // Descriptors count\n#define ETH_DS 4           // Descriptor size (words)\n\nstatic volatile uint32_t s_rxdesc[ETH_DESC_CNT][ETH_DS];  // RX descriptors\nstatic volatile uint32_t s_txdesc[ETH_DESC_CNT][ETH_DS];  // TX descriptors\nstatic uint8_t s_rxbuf[ETH_DESC_CNT][ETH_PKT_SIZE];       // RX ethernet buffers\nstatic uint8_t s_txbuf[ETH_DESC_CNT][ETH_PKT_SIZE];       // TX ethernet buffers\nstatic struct mg_tcpip_if *s_ifp;                         // MIP interface\nenum {\n  PHY_ADDR = 0,\n  PHY_BCR = 0,\n  PHY_BSR = 1,\n  PHY_CSCR = 31\n};  // PHY constants\n\nstatic uint32_t eth_read_phy(uint8_t addr, uint8_t reg) {\n  ETH->MACMDIOAR &= (0xF << 8);\n  ETH->MACMDIOAR |= ((uint32_t) addr << 21) | ((uint32_t) reg << 16) | 3 << 2;\n  ETH->MACMDIOAR |= BIT(0);\n  while (ETH->MACMDIOAR & BIT(0)) (void) 0;\n  return ETH->MACMDIODR;\n}\n\nstatic void eth_write_phy(uint8_t addr, uint8_t reg, uint32_t val) {\n  ETH->MACMDIODR = val;\n  ETH->MACMDIOAR &= (0xF << 8);\n  ETH->MACMDIOAR |= ((uint32_t) addr << 21) | ((uint32_t) reg << 16) | 1 << 2;\n  ETH->MACMDIOAR |= BIT(0);\n  while (ETH->MACMDIOAR & BIT(0)) (void) 0;\n}\n\nstatic uint32_t get_hclk(void) {\n  struct rcc {\n    volatile uint32_t CR, HSICFGR, CRRCR, CSICFGR, CFGR, RESERVED1, D1CFGR,\n        D2CFGR, D3CFGR, RESERVED2, PLLCKSELR, PLLCFGR, PLL1DIVR, PLL1FRACR,\n        PLL2DIVR, PLL2FRACR, PLL3DIVR, PLL3FRACR, RESERVED3, D1CCIPR, D2CCIP1R,\n        D2CCIP2R, D3CCIPR, RESERVED4, CIER, CIFR, CICR, RESERVED5, BDCR, CSR,\n        RESERVED6, AHB3RSTR, AHB1RSTR, AHB2RSTR, AHB4RSTR, APB3RSTR, APB1LRSTR,\n        APB1HRSTR, APB2RSTR, APB4RSTR, GCR, RESERVED8, D3AMR, RESERVED11[9],\n        RSR, AHB3ENR, AHB1ENR, AHB2ENR, AHB4ENR, APB3ENR, APB1LENR, APB1HENR,\n        APB2ENR, APB4ENR, RESERVED12, AHB3LPENR, AHB1LPENR, AHB2LPENR,\n        AHB4LPENR, APB3LPENR, APB1LLPENR, APB1HLPENR, APB2LPENR, APB4LPENR,\n        RESERVED13[4];\n  } *rcc = ((struct rcc *) (0x40000000 + 0x18020000 + 0x4400));\n  uint32_t clk = 0, hsi = 64000000 /* 64 MHz */, hse = 8000000 /* 8MHz */,\n           csi = 4000000 /* 4MHz */;\n  unsigned int sel = (rcc->CFGR & (7 << 3)) >> 3;\n\n  if (sel == 1) {\n    clk = csi;\n  } else if (sel == 2) {\n    clk = hse;\n  } else if (sel == 3) {\n    uint32_t vco, m, n, p;\n    unsigned int src = (rcc->PLLCKSELR & (3 << 0)) >> 0;\n    m = ((rcc->PLLCKSELR & (0x3F << 4)) >> 4);\n    n = ((rcc->PLL1DIVR & (0x1FF << 0)) >> 0) + 1 +\n        ((rcc->PLLCFGR & BIT(0)) ? 1 : 0);  // round-up in fractional mode\n    p = ((rcc->PLL1DIVR & (0x7F << 9)) >> 9) + 1;\n    if (src == 1) {\n      clk = csi;\n    } else if (src == 2) {\n      clk = hse;\n    } else {\n      clk = hsi;\n      clk >>= ((rcc->CR & 3) >> 3);\n    }\n    vco = (uint32_t) ((uint64_t) clk * n / m);\n    clk = vco / p;\n  } else {\n    clk = hsi;\n    clk >>= ((rcc->CR & 3) >> 3);\n  }\n  const uint8_t cptab[12] = {1, 2, 3, 4, 6, 7, 8, 9};  // log2(div)\n  uint32_t d1cpre = (rcc->D1CFGR & (0x0F << 8)) >> 8;\n  if (d1cpre >= 8) clk >>= cptab[d1cpre - 8];\n  MG_DEBUG((\"D1 CLK: %u\", clk));\n  uint32_t hpre = (rcc->D1CFGR & (0x0F << 0)) >> 0;\n  if (hpre < 8) return clk;\n  return ((uint32_t) clk) >> cptab[hpre - 8];\n}\n\n//  Guess CR from AHB1 clock. MDC clock is generated from the ETH peripheral\n//  clock (AHB1); as per 802.3, it must not exceed 2. As the AHB clock can\n//  be derived from HSI or CSI (internal RC) clocks, and those can go above\n//  specs, the datasheets specify a range of frequencies and activate one of a\n//  series of dividers to keep the MDC clock safely below 2.5MHz. We guess a\n//  divider setting based on HCLK with some drift. If the user uses a different\n//  clock from our defaults, needs to set the macros on top. Valid for\n//  STM32H74xxx/75xxx (58.11.4)(4.5% worst case drift)(CSI clock has a 7.5 %\n//  worst case drift @ max temp)\nstatic int guess_mdc_cr(void) {\n  const uint8_t crs[] = {2, 3, 0, 1, 4, 5};  // ETH->MACMDIOAR::CR values\n  const uint8_t div[] = {16, 26, 42, 62, 102, 124};  // Respective HCLK dividers\n  uint32_t hclk = get_hclk();                        // Guess system HCLK\n  int result = -1;                                   // Invalid CR value\n  for (int i = 0; i < 6; i++) {\n    if (hclk / div[i] <= 2375000UL /* 2.5MHz - 5% */) {\n      result = crs[i];\n      break;\n    }\n  }\n  if (result < 0) MG_ERROR((\"HCLK too high\"));\n  MG_DEBUG((\"HCLK: %u, CR: %d\", hclk, result));\n  return result;\n}\n\nstatic bool mg_tcpip_driver_stm32h_init(struct mg_tcpip_if *ifp) {\n  struct mg_tcpip_driver_stm32h_data *d =\n      (struct mg_tcpip_driver_stm32h_data *) ifp->driver_data;\n  s_ifp = ifp;\n\n  // Init RX descriptors\n  for (int i = 0; i < ETH_DESC_CNT; i++) {\n    s_rxdesc[i][0] = (uint32_t) (uintptr_t) s_rxbuf[i];  // Point to data buffer\n    s_rxdesc[i][3] = BIT(31) | BIT(30) | BIT(24);        // OWN, IOC, BUF1V\n  }\n\n  // Init TX descriptors\n  for (int i = 0; i < ETH_DESC_CNT; i++) {\n    s_txdesc[i][0] = (uint32_t) (uintptr_t) s_txbuf[i];  // Buf pointer\n  }\n\n  ETH->DMAMR |= BIT(0);                         // Software reset\n  while ((ETH->DMAMR & BIT(0)) != 0) (void) 0;  // Wait until done\n\n  // Set MDC clock divider. If user told us the value, use it. Otherwise, guess\n  int cr = (d == NULL || d->mdc_cr < 0) ? guess_mdc_cr() : d->mdc_cr;\n  ETH->MACMDIOAR = ((uint32_t) cr & 0xF) << 8;\n\n  // NOTE(scaprile): We do not use timing facilities so the DMA engine does not\n  // re-write buffer address\n  ETH->DMAMR = 0 << 16;     // use interrupt mode 0 (58.8.1) (reset value)\n  ETH->DMASBMR |= BIT(12);  // AAL NOTE(scaprile): is this actually needed\n  ETH->MACIER = 0;        // Do not enable additional irq sources (reset value)\n  ETH->MACTFCR = BIT(7);  // Disable zero-quanta pause\n  // ETH->MACPFR = BIT(31);  // Receive all\n  eth_write_phy(PHY_ADDR, PHY_BCR, BIT(15));  // Reset PHY\n  eth_write_phy(PHY_ADDR, PHY_BCR, BIT(12));  // Set autonegotiation\n  ETH->DMACRDLAR =\n      (uint32_t) (uintptr_t) s_rxdesc;  // RX descriptors start address\n  ETH->DMACRDRLR = ETH_DESC_CNT - 1;    // ring length\n  ETH->DMACRDTPR =\n      (uint32_t) (uintptr_t) &s_rxdesc[ETH_DESC_CNT -\n                                       1];  // last valid descriptor address\n  ETH->DMACTDLAR =\n      (uint32_t) (uintptr_t) s_txdesc;  // TX descriptors start address\n  ETH->DMACTDRLR = ETH_DESC_CNT - 1;    // ring length\n  ETH->DMACTDTPR =\n      (uint32_t) (uintptr_t) s_txdesc;  // first available descriptor address\n  ETH->DMACCR = 0;  // DSL = 0 (contiguous descriptor table) (reset value)\n  ETH->DMACIER = BIT(6) | BIT(15);  // RIE, NIE\n  ETH->MACCR = BIT(0) | BIT(1) | BIT(13) | BIT(14) |\n               BIT(15);     // RE, TE, Duplex, Fast, Reserved\n  ETH->MTLTQOMR |= BIT(1);  // TSF\n  ETH->MTLRQOMR |= BIT(5);  // RSF\n  ETH->DMACTCR |= BIT(0);   // ST\n  ETH->DMACRCR |= BIT(0);   // SR\n\n  // MAC address filtering\n  ETH->MACA0HR = ((uint32_t) ifp->mac[5] << 8U) | ifp->mac[4];\n  ETH->MACA0LR = (uint32_t) (ifp->mac[3] << 24) |\n                 ((uint32_t) ifp->mac[2] << 16) |\n                 ((uint32_t) ifp->mac[1] << 8) | ifp->mac[0];\n  return true;\n}\n\nstatic uint32_t s_txno;\nstatic size_t mg_tcpip_driver_stm32h_tx(const void *buf, size_t len,\n                                        struct mg_tcpip_if *ifp) {\n  if (len > sizeof(s_txbuf[s_txno])) {\n    MG_ERROR((\"Frame too big, %ld\", (long) len));\n    len = 0;  // Frame is too big\n  } else if ((s_txdesc[s_txno][3] & BIT(31))) {\n    MG_ERROR((\"No free descriptors: %u %08X %08X %08X\", s_txno,\n              s_txdesc[s_txno][3], ETH->DMACSR, ETH->DMACTCR));\n    for (int i = 0; i < ETH_DESC_CNT; i++) MG_ERROR((\"%08X\", s_txdesc[i][3]));\n    len = 0;  // All descriptors are busy, fail\n  } else {\n    memcpy(s_txbuf[s_txno], buf, len);        // Copy data\n    s_txdesc[s_txno][2] = (uint32_t) len;     // Set data len\n    s_txdesc[s_txno][3] = BIT(28) | BIT(29);  // FD, LD\n    s_txdesc[s_txno][3] |= BIT(31);           // Set OWN bit - let DMA take over\n    if (++s_txno >= ETH_DESC_CNT) s_txno = 0;\n  }\n  ETH->DMACSR |= BIT(2) | BIT(1);  // Clear any prior TBU, TPS\n  ETH->DMACTDTPR = (uint32_t) (uintptr_t) &s_txdesc[s_txno];  // and resume\n  return len;\n  (void) ifp;\n}\n\nstatic bool mg_tcpip_driver_stm32h_up(struct mg_tcpip_if *ifp) {\n  uint32_t bsr = eth_read_phy(PHY_ADDR, PHY_BSR);\n  bool up = bsr & BIT(2) ? 1 : 0;\n  if ((ifp->state == MG_TCPIP_STATE_DOWN) && up) {  // link state just went up\n    uint32_t scsr = eth_read_phy(PHY_ADDR, PHY_CSCR);\n    uint32_t maccr = ETH->MACCR | BIT(14) | BIT(13);  // 100M, Full-duplex\n    if ((scsr & BIT(3)) == 0) maccr &= ~BIT(14);      // 10M\n    if ((scsr & BIT(4)) == 0) maccr &= ~BIT(13);      // Half-duplex\n    ETH->MACCR = maccr;  // IRQ handler does not fiddle with this register\n    MG_DEBUG((\"Link is %uM %s-duplex\", maccr & BIT(14) ? 100 : 10,\n              maccr & BIT(13) ? \"full\" : \"half\"));\n  }\n  return up;\n}\n\nvoid ETH_IRQHandler(void);\nstatic uint32_t s_rxno;\nvoid ETH_IRQHandler(void) {\n  if (ETH->DMACSR & BIT(6)) {            // Frame received, loop\n    ETH->DMACSR = BIT(15) | BIT(6);      // Clear flag\n    for (uint32_t i = 0; i < 10; i++) {  // read as they arrive but not forever\n      if (s_rxdesc[s_rxno][3] & BIT(31)) break;  // exit when done\n      if (((s_rxdesc[s_rxno][3] & (BIT(28) | BIT(29))) ==\n           (BIT(28) | BIT(29))) &&\n          !(s_rxdesc[s_rxno][3] & BIT(15))) {  // skip partial/errored frames\n        uint32_t len = s_rxdesc[s_rxno][3] & (BIT(15) - 1);\n        // MG_DEBUG((\"%lx %lu %lx %08lx\", s_rxno, len, s_rxdesc[s_rxno][3],\n        // ETH->DMACSR));\n        mg_tcpip_qwrite(s_rxbuf[s_rxno], len > 4 ? len - 4 : len, s_ifp);\n      }\n      s_rxdesc[s_rxno][3] = BIT(31) | BIT(30) | BIT(24);  // OWN, IOC, BUF1V\n      if (++s_rxno >= ETH_DESC_CNT) s_rxno = 0;\n    }\n  }\n  ETH->DMACSR = BIT(7) | BIT(8);  // Clear possible RBU RPS while processing\n  ETH->DMACRDTPR =\n      (uint32_t) (uintptr_t) &s_rxdesc[ETH_DESC_CNT - 1];  // and resume RX\n}\n\nstruct mg_tcpip_driver mg_tcpip_driver_stm32h = {\n    mg_tcpip_driver_stm32h_init, mg_tcpip_driver_stm32h_tx, NULL,\n    mg_tcpip_driver_stm32h_up};\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tcpip/driver_tm4c.c\"\n#endif\n\n\n#if MG_ENABLE_TCPIP && defined(MG_ENABLE_DRIVER_TM4C) && MG_ENABLE_DRIVER_TM4C\nstruct tm4c_emac {\n  volatile uint32_t EMACCFG, EMACFRAMEFLTR, EMACHASHTBLH, EMACHASHTBLL,\n      EMACMIIADDR, EMACMIIDATA, EMACFLOWCTL, EMACVLANTG, RESERVED0, EMACSTATUS,\n      EMACRWUFF, EMACPMTCTLSTAT, RESERVED1[2], EMACRIS, EMACIM, EMACADDR0H,\n      EMACADDR0L, EMACADDR1H, EMACADDR1L, EMACADDR2H, EMACADDR2L, EMACADDR3H,\n      EMACADDR3L, RESERVED2[31], EMACWDOGTO, RESERVED3[8], EMACMMCCTRL,\n      EMACMMCRXRIS, EMACMMCTXRIS, EMACMMCRXIM, EMACMMCTXIM, RESERVED4,\n      EMACTXCNTGB, RESERVED5[12], EMACTXCNTSCOL, EMACTXCNTMCOL, RESERVED6[4],\n      EMACTXOCTCNTG, RESERVED7[6], EMACRXCNTGB, RESERVED8[4], EMACRXCNTCRCERR,\n      EMACRXCNTALGNERR, RESERVED9[10], EMACRXCNTGUNI, RESERVED10[239],\n      EMACVLNINCREP, EMACVLANHASH, RESERVED11[93], EMACTIMSTCTRL, EMACSUBSECINC,\n      EMACTIMSEC, EMACTIMNANO, EMACTIMSECU, EMACTIMNANOU, EMACTIMADD,\n      EMACTARGSEC, EMACTARGNANO, EMACHWORDSEC, EMACTIMSTAT, EMACPPSCTRL,\n      RESERVED12[12], EMACPPS0INTVL, EMACPPS0WIDTH, RESERVED13[294],\n      EMACDMABUSMOD, EMACTXPOLLD, EMACRXPOLLD, EMACRXDLADDR, EMACTXDLADDR,\n      EMACDMARIS, EMACDMAOPMODE, EMACDMAIM, EMACMFBOC, EMACRXINTWDT,\n      RESERVED14[8], EMACHOSTXDESC, EMACHOSRXDESC, EMACHOSTXBA, EMACHOSRXBA,\n      RESERVED15[218], EMACPP, EMACPC, EMACCC, RESERVED16, EMACEPHYRIS,\n      EMACEPHYIM, EMACEPHYIMSC;\n};\n#undef EMAC\n#define EMAC ((struct tm4c_emac *) (uintptr_t) 0x400EC000)\n\n#undef BIT\n#define BIT(x) ((uint32_t) 1 << (x))\n#define ETH_PKT_SIZE 1540  // Max frame size\n#define ETH_DESC_CNT 4     // Descriptors count\n#define ETH_DS 4           // Descriptor size (words)\n\nstatic uint32_t s_rxdesc[ETH_DESC_CNT][ETH_DS];      // RX descriptors\nstatic uint32_t s_txdesc[ETH_DESC_CNT][ETH_DS];      // TX descriptors\nstatic uint8_t s_rxbuf[ETH_DESC_CNT][ETH_PKT_SIZE];  // RX ethernet buffers\nstatic uint8_t s_txbuf[ETH_DESC_CNT][ETH_PKT_SIZE];  // TX ethernet buffers\nstatic struct mg_tcpip_if *s_ifp;                    // MIP interface\nenum {\n  EPHY_ADDR = 0,\n  EPHYBMCR = 0,\n  EPHYBMSR = 1,\n  EPHYSTS = 16\n};  // PHY constants\n\nstatic inline void tm4cspin(volatile uint32_t count) {\n  while (count--) (void) 0;\n}\n\nstatic uint32_t emac_read_phy(uint8_t addr, uint8_t reg) {\n  EMAC->EMACMIIADDR &= (0xf << 2);\n  EMAC->EMACMIIADDR |= ((uint32_t) addr << 11) | ((uint32_t) reg << 6);\n  EMAC->EMACMIIADDR |= BIT(0);\n  while (EMAC->EMACMIIADDR & BIT(0)) tm4cspin(1);\n  return EMAC->EMACMIIDATA;\n}\n\nstatic void emac_write_phy(uint8_t addr, uint8_t reg, uint32_t val) {\n  EMAC->EMACMIIDATA = val;\n  EMAC->EMACMIIADDR &= (0xf << 2);\n  EMAC->EMACMIIADDR |= ((uint32_t) addr << 11) | ((uint32_t) reg << 6) | BIT(1);\n  EMAC->EMACMIIADDR |= BIT(0);\n  while (EMAC->EMACMIIADDR & BIT(0)) tm4cspin(1);\n}\n\nstatic uint32_t get_sysclk(void) {\n  struct sysctl {\n    volatile uint32_t DONTCARE0[44], RSCLKCFG, DONTCARE1[43], PLLFREQ0,\n        PLLFREQ1;\n  } *sysctl = (struct sysctl *) 0x400FE000;\n  uint32_t clk = 0, piosc = 16000000 /* 16 MHz */, mosc = 25000000 /* 25MHz */;\n  if (sysctl->RSCLKCFG & (1 << 28)) {  // USEPLL\n    uint32_t fin, vco, mdiv, n, q, psysdiv;\n    uint32_t pllsrc = (sysctl->RSCLKCFG & (0xf << 24)) >> 24;\n    if (pllsrc == 0) {\n      clk = piosc;\n    } else if (pllsrc == 3) {\n      clk = mosc;\n    } else {\n      MG_ERROR((\"Unsupported clock source\"));\n    }\n    q = (sysctl->PLLFREQ1 & (0x1f << 8)) >> 8;\n    n = (sysctl->PLLFREQ1 & (0x1f << 0)) >> 0;\n    fin = clk / ((q + 1) * (n + 1));\n    mdiv = (sysctl->PLLFREQ0 & (0x3ff << 0)) >>\n           0;  // mint + (mfrac / 1024); MFRAC not supported\n    psysdiv = (sysctl->RSCLKCFG & (0x3f << 0)) >> 0;\n    vco = (uint32_t) ((uint64_t) fin * mdiv);\n    return vco / (psysdiv + 1);\n  }\n  uint32_t oscsrc = (sysctl->RSCLKCFG & (0xf << 20)) >> 20;\n  if (oscsrc == 0) {\n    clk = piosc;\n  } else if (oscsrc == 3) {\n    clk = mosc;\n  } else {\n    MG_ERROR((\"Unsupported clock source\"));\n  }\n  uint32_t osysdiv = (sysctl->RSCLKCFG & (0xf << 16)) >> 16;\n  return clk / (osysdiv + 1);\n}\n\n//  Guess CR from SYSCLK. MDC clock is generated from SYSCLK (AHB); as per\n//  802.3, it must not exceed 2.5MHz (also 20.4.2.6) As the AHB clock can be\n//  derived from the PIOSC (internal RC), and it can go above  specs, the\n//  datasheets specify a range of frequencies and activate one of a series of\n//  dividers to keep the MDC clock safely below 2.5MHz. We guess a divider\n//  setting based on SYSCLK with a +5% drift. If the user uses a different clock\n//  from our defaults, needs to set the macros on top Valid for TM4C129x (20.7)\n//  (4.5% worst case drift)\n// The PHY receives the main oscillator (MOSC) (20.3.1)\nstatic int guess_mdc_cr(void) {\n  uint8_t crs[] = {2, 3, 0, 1};      // EMAC->MACMIIAR::CR values\n  uint8_t div[] = {16, 26, 42, 62};  // Respective HCLK dividers\n  uint32_t sysclk = get_sysclk();    // Guess system SYSCLK\n  int result = -1;                   // Invalid CR value\n  if (sysclk < 25000000) {\n    MG_ERROR((\"SYSCLK too low\"));\n  } else {\n    for (int i = 0; i < 4; i++) {\n      if (sysclk / div[i] <= 2375000UL /* 2.5MHz - 5% */) {\n        result = crs[i];\n        break;\n      }\n    }\n    if (result < 0) MG_ERROR((\"SYSCLK too high\"));\n  }\n  MG_DEBUG((\"SYSCLK: %u, CR: %d\", sysclk, result));\n  return result;\n}\n\nstatic bool mg_tcpip_driver_tm4c_init(struct mg_tcpip_if *ifp) {\n  struct mg_tcpip_driver_tm4c_data *d =\n      (struct mg_tcpip_driver_tm4c_data *) ifp->driver_data;\n  s_ifp = ifp;\n\n  // Init RX descriptors\n  for (int i = 0; i < ETH_DESC_CNT; i++) {\n    s_rxdesc[i][0] = BIT(31);                            // Own\n    s_rxdesc[i][1] = sizeof(s_rxbuf[i]) | BIT(14);       // 2nd address chained\n    s_rxdesc[i][2] = (uint32_t) (uintptr_t) s_rxbuf[i];  // Point to data buffer\n    s_rxdesc[i][3] =\n        (uint32_t) (uintptr_t) s_rxdesc[(i + 1) % ETH_DESC_CNT];  // Chain\n    // MG_DEBUG((\"%d %p\", i, s_rxdesc[i]));\n  }\n\n  // Init TX descriptors\n  for (int i = 0; i < ETH_DESC_CNT; i++) {\n    s_txdesc[i][2] = (uint32_t) (uintptr_t) s_txbuf[i];  // Buf pointer\n    s_txdesc[i][3] =\n        (uint32_t) (uintptr_t) s_txdesc[(i + 1) % ETH_DESC_CNT];  // Chain\n  }\n\n  EMAC->EMACDMABUSMOD |= BIT(0);                            // Software reset\n  while ((EMAC->EMACDMABUSMOD & BIT(0)) != 0) tm4cspin(1);  // Wait until done\n\n  // Set MDC clock divider. If user told us the value, use it. Otherwise, guess\n  int cr = (d == NULL || d->mdc_cr < 0) ? guess_mdc_cr() : d->mdc_cr;\n  EMAC->EMACMIIADDR = ((uint32_t) cr & 0xf) << 2;\n\n  // NOTE(cpq): we do not use extended descriptor bit 7, and do not use\n  // hardware checksum. Therefore, descriptor size is 4, not 8\n  // EMAC->EMACDMABUSMOD = BIT(13) | BIT(16) | BIT(22) | BIT(23) | BIT(25);\n  EMAC->EMACIM = BIT(3) | BIT(9);  // Mask timestamp & PMT IT\n  EMAC->EMACFLOWCTL = BIT(7);      // Disable zero-quanta pause\n  // EMAC->EMACFRAMEFLTR = BIT(31);   // Receive all\n  // EMAC->EMACPC defaults to internal PHY (EPHY) in MMI mode\n  emac_write_phy(EPHY_ADDR, EPHYBMCR, BIT(15));  // Reset internal PHY (EPHY)\n  emac_write_phy(EPHY_ADDR, EPHYBMCR, BIT(12));  // Set autonegotiation\n  EMAC->EMACRXDLADDR = (uint32_t) (uintptr_t) s_rxdesc;  // RX descriptors\n  EMAC->EMACTXDLADDR = (uint32_t) (uintptr_t) s_txdesc;  // TX descriptors\n  EMAC->EMACDMAIM = BIT(6) | BIT(16);                    // RIE, NIE\n  EMAC->EMACCFG = BIT(2) | BIT(3) | BIT(11) | BIT(14);   // RE, TE, Duplex, Fast\n  EMAC->EMACDMAOPMODE =\n      BIT(1) | BIT(13) | BIT(21) | BIT(25);  // SR, ST, TSF, RSF\n  EMAC->EMACADDR0H = ((uint32_t) ifp->mac[5] << 8U) | ifp->mac[4];\n  EMAC->EMACADDR0L = (uint32_t) (ifp->mac[3] << 24) |\n                     ((uint32_t) ifp->mac[2] << 16) |\n                     ((uint32_t) ifp->mac[1] << 8) | ifp->mac[0];\n  // NOTE(scaprile) There are 3 additional slots for filtering, disabled by\n  // default. This also applies to the STM32 driver (at least for F7)\n  return true;\n}\n\nstatic uint32_t s_txno;\nstatic size_t mg_tcpip_driver_tm4c_tx(const void *buf, size_t len,\n                                      struct mg_tcpip_if *ifp) {\n  if (len > sizeof(s_txbuf[s_txno])) {\n    MG_ERROR((\"Frame too big, %ld\", (long) len));\n    len = 0;  // fail\n  } else if ((s_txdesc[s_txno][0] & BIT(31))) {\n    MG_ERROR((\"No descriptors available\"));\n    // printf(\"D0 %lx SR %lx\\n\", (long) s_txdesc[0][0], (long)\n    // EMAC->EMACDMARIS);\n    len = 0;  // fail\n  } else {\n    memcpy(s_txbuf[s_txno], buf, len);     // Copy data\n    s_txdesc[s_txno][1] = (uint32_t) len;  // Set data len\n    s_txdesc[s_txno][0] =\n        BIT(20) | BIT(28) | BIT(29) | BIT(30);  // Chain,FS,LS,IC\n    s_txdesc[s_txno][0] |= BIT(31);  // Set OWN bit - let DMA take over\n    if (++s_txno >= ETH_DESC_CNT) s_txno = 0;\n  }\n  EMAC->EMACDMARIS = BIT(2) | BIT(5);  // Clear any prior TU/UNF\n  EMAC->EMACTXPOLLD = 0;               // and resume\n  return len;\n  (void) ifp;\n}\n\nstatic bool mg_tcpip_driver_tm4c_up(struct mg_tcpip_if *ifp) {\n  uint32_t bmsr = emac_read_phy(EPHY_ADDR, EPHYBMSR);\n  bool up = (bmsr & BIT(2)) ? 1 : 0;\n  if ((ifp->state == MG_TCPIP_STATE_DOWN) && up) {  // link state just went up\n    uint32_t sts = emac_read_phy(EPHY_ADDR, EPHYSTS);\n    uint32_t emaccfg = EMAC->EMACCFG | BIT(14) | BIT(11);  // 100M, Full-duplex\n    if (sts & BIT(1)) emaccfg &= ~BIT(14);                 // 10M\n    if ((sts & BIT(2)) == 0) emaccfg &= ~BIT(11);          // Half-duplex\n    EMAC->EMACCFG = emaccfg;  // IRQ handler does not fiddle with this register\n    MG_DEBUG((\"Link is %uM %s-duplex\", emaccfg & BIT(14) ? 100 : 10,\n              emaccfg & BIT(11) ? \"full\" : \"half\"));\n  }\n  return up;\n}\n\nvoid EMAC0_IRQHandler(void);\nstatic uint32_t s_rxno;\nvoid EMAC0_IRQHandler(void) {\n  if (EMAC->EMACDMARIS & BIT(6)) {        // Frame received, loop\n    EMAC->EMACDMARIS = BIT(16) | BIT(6);  // Clear flag\n    for (uint32_t i = 0; i < 10; i++) {   // read as they arrive but not forever\n      if (s_rxdesc[s_rxno][0] & BIT(31)) break;  // exit when done\n      if (((s_rxdesc[s_rxno][0] & (BIT(8) | BIT(9))) == (BIT(8) | BIT(9))) &&\n          !(s_rxdesc[s_rxno][0] & BIT(15))) {  // skip partial/errored frames\n        uint32_t len = ((s_rxdesc[s_rxno][0] >> 16) & (BIT(14) - 1));\n        //  printf(\"%lx %lu %lx %.8lx\\n\", s_rxno, len, s_rxdesc[s_rxno][0],\n        //  EMAC->EMACDMARIS);\n        mg_tcpip_qwrite(s_rxbuf[s_rxno], len > 4 ? len - 4 : len, s_ifp);\n      }\n      s_rxdesc[s_rxno][0] = BIT(31);\n      if (++s_rxno >= ETH_DESC_CNT) s_rxno = 0;\n    }\n  }\n  EMAC->EMACDMARIS = BIT(7);  // Clear possible RU while processing\n  EMAC->EMACRXPOLLD = 0;      // and resume RX\n}\n\nstruct mg_tcpip_driver mg_tcpip_driver_tm4c = {mg_tcpip_driver_tm4c_init,\n                                               mg_tcpip_driver_tm4c_tx, NULL,\n                                               mg_tcpip_driver_tm4c_up};\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tcpip/driver_w5500.c\"\n#endif\n\n\n#if MG_ENABLE_TCPIP\n\nenum { W5500_CR = 0, W5500_S0 = 1, W5500_TX0 = 2, W5500_RX0 = 3 };\n\nstatic void w5500_txn(struct mg_tcpip_spi *s, uint8_t block, uint16_t addr, bool wr,\n                      void *buf, size_t len) {\n  uint8_t *p = (uint8_t *) buf;\n  uint8_t cmd[] = {(uint8_t) (addr >> 8), (uint8_t) (addr & 255),\n                   (uint8_t) ((block << 3) | (wr ? 4 : 0))};\n  s->begin(s->spi);\n  for (size_t i = 0; i < sizeof(cmd); i++) s->txn(s->spi, cmd[i]);\n  for (size_t i = 0; i < len; i++) {\n    uint8_t r = s->txn(s->spi, p[i]);\n    if (!wr) p[i] = r;\n  }\n  s->end(s->spi);\n}\n\n// clang-format off\nstatic  void w5500_wn(struct mg_tcpip_spi *s, uint8_t block, uint16_t addr, void *buf, size_t len) { w5500_txn(s, block, addr, true, buf, len); }\nstatic  void w5500_w1(struct mg_tcpip_spi *s, uint8_t block, uint16_t addr, uint8_t val) { w5500_wn(s, block, addr, &val, 1); }\nstatic  void w5500_w2(struct mg_tcpip_spi *s, uint8_t block, uint16_t addr, uint16_t val) { uint8_t buf[2] = {(uint8_t) (val >> 8), (uint8_t) (val & 255)}; w5500_wn(s, block, addr, buf, sizeof(buf)); }\nstatic  void w5500_rn(struct mg_tcpip_spi *s, uint8_t block, uint16_t addr, void *buf, size_t len) { w5500_txn(s, block, addr, false, buf, len); }\nstatic  uint8_t w5500_r1(struct mg_tcpip_spi *s, uint8_t block, uint16_t addr) { uint8_t r = 0; w5500_rn(s, block, addr, &r, 1); return r; }\nstatic  uint16_t w5500_r2(struct mg_tcpip_spi *s, uint8_t block, uint16_t addr) { uint8_t buf[2] = {0, 0}; w5500_rn(s, block, addr, buf, sizeof(buf)); return (uint16_t) ((buf[0] << 8) | buf[1]); }\n// clang-format on\n\nstatic size_t w5500_rx(void *buf, size_t buflen, struct mg_tcpip_if *ifp) {\n  struct mg_tcpip_spi *s = (struct mg_tcpip_spi *) ifp->driver_data;\n  uint16_t r = 0, n = 0, len = (uint16_t) buflen, n2;     // Read recv len\n  while ((n2 = w5500_r2(s, W5500_S0, 0x26)) > n) n = n2;  // Until it is stable\n  // printf(\"RSR: %d\\n\", (int) n);\n  if (n > 0) {\n    uint16_t ptr = w5500_r2(s, W5500_S0, 0x28);  // Get read pointer\n    n = w5500_r2(s, W5500_RX0, ptr);             // Read frame length\n    if (n <= len + 2 && n > 1) {\n      r = (uint16_t) (n - 2);\n      w5500_rn(s, W5500_RX0, (uint16_t) (ptr + 2), buf, r);\n    }\n    w5500_w2(s, W5500_S0, 0x28, (uint16_t) (ptr + n));  // Advance read pointer\n    w5500_w1(s, W5500_S0, 1, 0x40);                     // Sock0 CR -> RECV\n    // printf(\"  RX_RD: tot=%u n=%u r=%u\\n\", n2, n, r);\n  }\n  return r;\n}\n\nstatic size_t w5500_tx(const void *buf, size_t buflen, struct mg_tcpip_if *ifp) {\n  struct mg_tcpip_spi *s = (struct mg_tcpip_spi *) ifp->driver_data;\n  uint16_t n = 0, len = (uint16_t) buflen;\n  while (n < len) n = w5500_r2(s, W5500_S0, 0x20);      // Wait for space\n  uint16_t ptr = w5500_r2(s, W5500_S0, 0x24);           // Get write pointer\n  w5500_wn(s, W5500_TX0, ptr, (void *) buf, len);       // Write data\n  w5500_w2(s, W5500_S0, 0x24, (uint16_t) (ptr + len));  // Advance write pointer\n  w5500_w1(s, W5500_S0, 1, 0x20);                       // Sock0 CR -> SEND\n  for (int i = 0; i < 40; i++) {\n    uint8_t ir = w5500_r1(s, W5500_S0, 2);  // Read S0 IR\n    if (ir == 0) continue;\n    // printf(\"IR %d, len=%d, free=%d, ptr %d\\n\", ir, (int) len, (int) n, ptr);\n    w5500_w1(s, W5500_S0, 2, ir);  // Write S0 IR: clear it!\n    if (ir & 8) len = 0;           // Timeout. Report error\n    if (ir & (16 | 8)) break;      // Stop on SEND_OK or timeout\n  }\n  return len;\n}\n\nstatic bool w5500_init(struct mg_tcpip_if *ifp) {\n  struct mg_tcpip_spi *s = (struct mg_tcpip_spi *) ifp->driver_data;\n  s->end(s->spi);\n  w5500_w1(s, W5500_CR, 0, 0x80);     // Reset chip: CR -> 0x80\n  w5500_w1(s, W5500_CR, 0x2e, 0);     // CR PHYCFGR -> reset\n  w5500_w1(s, W5500_CR, 0x2e, 0xf8);  // CR PHYCFGR -> set\n  // w5500_wn(s, W5500_CR, 9, s->mac, 6);      // Set source MAC\n  w5500_w1(s, W5500_S0, 0x1e, 16);          // Sock0 RX buf size\n  w5500_w1(s, W5500_S0, 0x1f, 16);          // Sock0 TX buf size\n  w5500_w1(s, W5500_S0, 0, 4);              // Sock0 MR -> MACRAW\n  w5500_w1(s, W5500_S0, 1, 1);              // Sock0 CR -> OPEN\n  return w5500_r1(s, W5500_S0, 3) == 0x42;  // Sock0 SR == MACRAW\n}\n\nstatic bool w5500_up(struct mg_tcpip_if *ifp) {\n  struct mg_tcpip_spi *spi = (struct mg_tcpip_spi *) ifp->driver_data;\n  uint8_t phycfgr = w5500_r1(spi, W5500_CR, 0x2e);\n  return phycfgr & 1;  // Bit 0 of PHYCFGR is LNK (0 - down, 1 - up)\n}\n\nstruct mg_tcpip_driver mg_tcpip_driver_w5500 = {w5500_init, w5500_tx, w5500_rx, w5500_up};\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tcpip/tcpip.c\"\n#endif\n\n\n#if MG_ENABLE_TCPIP\n\n#define MG_EPHEMERAL_PORT_BASE 32768\n#define PDIFF(a, b) ((size_t) (((char *) (b)) - ((char *) (a))))\n\n#ifndef MIP_TCP_KEEPALIVE_MS\n#define MIP_TCP_KEEPALIVE_MS 45000  // TCP keep-alive period, ms\n#endif\n\n#define MIP_TCP_ACK_MS 150  // Timeout for ACKing\n\nstruct connstate {\n  uint32_t seq, ack;           // TCP seq/ack counters\n  uint64_t timer;              // TCP keep-alive / ACK timer\n  uint8_t mac[6];              // Peer MAC address\n  uint8_t ttype;               // Timer type. 0: ack, 1: keep-alive\n#define MIP_TTYPE_KEEPALIVE 0  // Connection is idle for long, send keepalive\n#define MIP_TTYPE_ACK 1        // Peer sent us data, we have to ack it soon\n  uint8_t tmiss;               // Number of keep-alive misses\n  struct mg_iobuf raw;         // For TLS only. Incoming raw data\n};\n\n#pragma pack(push, 1)\n\nstruct lcp {\n  uint8_t addr, ctrl, proto[2], code, id, len[2];\n};\n\nstruct eth {\n  uint8_t dst[6];  // Destination MAC address\n  uint8_t src[6];  // Source MAC address\n  uint16_t type;   // Ethernet type\n};\n\nstruct ip {\n  uint8_t ver;    // Version\n  uint8_t tos;    // Unused\n  uint16_t len;   // Length\n  uint16_t id;    // Unused\n  uint16_t frag;  // Fragmentation\n  uint8_t ttl;    // Time to live\n  uint8_t proto;  // Upper level protocol\n  uint16_t csum;  // Checksum\n  uint32_t src;   // Source IP\n  uint32_t dst;   // Destination IP\n};\n\nstruct ip6 {\n  uint8_t ver;      // Version\n  uint8_t opts[3];  // Options\n  uint16_t len;     // Length\n  uint8_t proto;    // Upper level protocol\n  uint8_t ttl;      // Time to live\n  uint8_t src[16];  // Source IP\n  uint8_t dst[16];  // Destination IP\n};\n\nstruct icmp {\n  uint8_t type;\n  uint8_t code;\n  uint16_t csum;\n};\n\nstruct arp {\n  uint16_t fmt;    // Format of hardware address\n  uint16_t pro;    // Format of protocol address\n  uint8_t hlen;    // Length of hardware address\n  uint8_t plen;    // Length of protocol address\n  uint16_t op;     // Operation\n  uint8_t sha[6];  // Sender hardware address\n  uint32_t spa;    // Sender protocol address\n  uint8_t tha[6];  // Target hardware address\n  uint32_t tpa;    // Target protocol address\n};\n\nstruct tcp {\n  uint16_t sport;  // Source port\n  uint16_t dport;  // Destination port\n  uint32_t seq;    // Sequence number\n  uint32_t ack;    // Acknowledgement number\n  uint8_t off;     // Data offset\n  uint8_t flags;   // TCP flags\n#define TH_FIN 0x01\n#define TH_SYN 0x02\n#define TH_RST 0x04\n#define TH_PUSH 0x08\n#define TH_ACK 0x10\n#define TH_URG 0x20\n#define TH_ECE 0x40\n#define TH_CWR 0x80\n  uint16_t win;   // Window\n  uint16_t csum;  // Checksum\n  uint16_t urp;   // Urgent pointer\n};\n\nstruct udp {\n  uint16_t sport;  // Source port\n  uint16_t dport;  // Destination port\n  uint16_t len;    // UDP length\n  uint16_t csum;   // UDP checksum\n};\n\nstruct dhcp {\n  uint8_t op, htype, hlen, hops;\n  uint32_t xid;\n  uint16_t secs, flags;\n  uint32_t ciaddr, yiaddr, siaddr, giaddr;\n  uint8_t hwaddr[208];\n  uint32_t magic;\n  uint8_t options[32];\n};\n\n#pragma pack(pop)\n\nstruct pkt {\n  struct mg_str raw;  // Raw packet data\n  struct mg_str pay;  // Payload data\n  struct eth *eth;\n  struct llc *llc;\n  struct arp *arp;\n  struct ip *ip;\n  struct ip6 *ip6;\n  struct icmp *icmp;\n  struct tcp *tcp;\n  struct udp *udp;\n  struct dhcp *dhcp;\n};\n\nstatic void mkpay(struct pkt *pkt, void *p) {\n  pkt->pay =\n      mg_str_n((char *) p, (size_t) (&pkt->raw.ptr[pkt->raw.len] - (char *) p));\n}\n\nstatic uint32_t csumup(uint32_t sum, const void *buf, size_t len) {\n  const uint8_t *p = (const uint8_t *) buf;\n  for (size_t i = 0; i < len; i++) sum += i & 1 ? p[i] : (uint32_t) (p[i] << 8);\n  return sum;\n}\n\nstatic uint16_t csumfin(uint32_t sum) {\n  while (sum >> 16) sum = (sum & 0xffff) + (sum >> 16);\n  return mg_htons(~sum & 0xffff);\n}\n\nstatic uint16_t ipcsum(const void *buf, size_t len) {\n  uint32_t sum = csumup(0, buf, len);\n  return csumfin(sum);\n}\n\nstatic size_t ether_output(struct mg_tcpip_if *ifp, size_t len) {\n  // size_t min = 64;  // Pad short frames to 64 bytes (minimum Ethernet size)\n  // if (len < min) memset(ifp->tx.ptr + len, 0, min - len), len = min;\n  // mg_hexdump(ifp->tx.ptr, len);\n  size_t n = ifp->driver->tx(ifp->tx.ptr, len, ifp);\n  if (n == len) ifp->nsent++;\n  return n;\n}\n\nstatic void arp_ask(struct mg_tcpip_if *ifp, uint32_t ip) {\n  struct eth *eth = (struct eth *) ifp->tx.ptr;\n  struct arp *arp = (struct arp *) (eth + 1);\n  memset(eth->dst, 255, sizeof(eth->dst));\n  memcpy(eth->src, ifp->mac, sizeof(eth->src));\n  eth->type = mg_htons(0x806);\n  memset(arp, 0, sizeof(*arp));\n  arp->fmt = mg_htons(1), arp->pro = mg_htons(0x800), arp->hlen = 6,\n  arp->plen = 4;\n  arp->op = mg_htons(1), arp->tpa = ip, arp->spa = ifp->ip;\n  memcpy(arp->sha, ifp->mac, sizeof(arp->sha));\n  ether_output(ifp, PDIFF(eth, arp + 1));\n}\n\nstatic void onstatechange(struct mg_tcpip_if *ifp) {\n  if (ifp->state == MG_TCPIP_STATE_READY) {\n    MG_INFO((\"READY, IP: %M\", mg_print_ip4, &ifp->ip));\n    MG_INFO((\"       GW: %M\", mg_print_ip4, &ifp->gw));\n    if (ifp->lease_expire > ifp->now) {\n      MG_INFO(\n          (\"       Lease: %lld sec\", (ifp->lease_expire - ifp->now) / 1000));\n    }\n    arp_ask(ifp, ifp->gw);\n  } else if (ifp->state == MG_TCPIP_STATE_UP) {\n    MG_ERROR((\"Link up\"));\n    srand((unsigned int) mg_millis());\n  } else if (ifp->state == MG_TCPIP_STATE_DOWN) {\n    MG_ERROR((\"Link down\"));\n  }\n}\n\nstatic struct ip *tx_ip(struct mg_tcpip_if *ifp, uint8_t *mac_dst,\n                        uint8_t proto, uint32_t ip_src, uint32_t ip_dst,\n                        size_t plen) {\n  struct eth *eth = (struct eth *) ifp->tx.ptr;\n  struct ip *ip = (struct ip *) (eth + 1);\n  memcpy(eth->dst, mac_dst, sizeof(eth->dst));\n  memcpy(eth->src, ifp->mac, sizeof(eth->src));  // Use our MAC\n  eth->type = mg_htons(0x800);\n  memset(ip, 0, sizeof(*ip));\n  ip->ver = 0x45;   // Version 4, header length 5 words\n  ip->frag = 0x40;  // Don't fragment\n  ip->len = mg_htons((uint16_t) (sizeof(*ip) + plen));\n  ip->ttl = 64;\n  ip->proto = proto;\n  ip->src = ip_src;\n  ip->dst = ip_dst;\n  ip->csum = ipcsum(ip, sizeof(*ip));\n  return ip;\n}\n\nstatic void tx_udp(struct mg_tcpip_if *ifp, uint8_t *mac_dst, uint32_t ip_src,\n                   uint16_t sport, uint32_t ip_dst, uint16_t dport,\n                   const void *buf, size_t len) {\n  struct ip *ip =\n      tx_ip(ifp, mac_dst, 17, ip_src, ip_dst, len + sizeof(struct udp));\n  struct udp *udp = (struct udp *) (ip + 1);\n  // MG_DEBUG((\"UDP XX LEN %d %d\", (int) len, (int) ifp->tx.len));\n  udp->sport = sport;\n  udp->dport = dport;\n  udp->len = mg_htons((uint16_t) (sizeof(*udp) + len));\n  udp->csum = 0;\n  uint32_t cs = csumup(0, udp, sizeof(*udp));\n  cs = csumup(cs, buf, len);\n  cs = csumup(cs, &ip->src, sizeof(ip->src));\n  cs = csumup(cs, &ip->dst, sizeof(ip->dst));\n  cs += (uint32_t) (ip->proto + sizeof(*udp) + len);\n  udp->csum = csumfin(cs);\n  memmove(udp + 1, buf, len);\n  // MG_DEBUG((\"UDP LEN %d %d\", (int) len, (int) ifp->frame_len));\n  ether_output(ifp, sizeof(struct eth) + sizeof(*ip) + sizeof(*udp) + len);\n}\n\nstatic void tx_dhcp(struct mg_tcpip_if *ifp, uint8_t *mac_dst, uint32_t ip_src,\n                    uint32_t ip_dst, uint8_t *opts, size_t optslen) {\n  struct dhcp dhcp = {1, 1, 6, 0, 0, 0, 0, 0, 0, 0, 0, {0}, 0, {0}};\n  dhcp.magic = mg_htonl(0x63825363);\n  memcpy(&dhcp.hwaddr, ifp->mac, sizeof(ifp->mac));\n  memcpy(&dhcp.xid, ifp->mac + 2, sizeof(dhcp.xid));\n  memcpy(&dhcp.options, opts, optslen);\n  tx_udp(ifp, mac_dst, ip_src, mg_htons(68), ip_dst, mg_htons(67), &dhcp,\n         sizeof(dhcp));\n}\n\nstatic void tx_dhcp_request(struct mg_tcpip_if *ifp, uint8_t *mac_dst,\n                            uint32_t ip_src, uint32_t ip_dst) {\n  uint8_t opts[] = {\n      53, 1, 3,                 // Type: DHCP request\n      55, 2, 1,   3,            // GW and mask\n      12, 3, 'm', 'i', 'p',     // Host name: \"mip\"\n      54, 4, 0,   0,   0,   0,  // DHCP server ID\n      50, 4, 0,   0,   0,   0,  // Requested IP\n      255                       // End of options\n  };\n  memcpy(opts + 14, &ip_dst, sizeof(ip_dst));\n  memcpy(opts + 20, &ip_src, sizeof(ip_src));\n  tx_dhcp(ifp, mac_dst, ip_src, ip_dst, opts, sizeof(opts));\n}\n\nstatic void tx_dhcp_discover(struct mg_tcpip_if *ifp) {\n  uint8_t mac[6] = {255, 255, 255, 255, 255, 255};\n  uint8_t opts[] = {\n      53, 1, 1,     // Type: DHCP discover\n      55, 2, 1, 3,  // Parameters: ip, mask\n      255           // End of options\n  };\n  tx_dhcp(ifp, mac, 0, 0xffffffff, opts, sizeof(opts));\n  MG_DEBUG((\"DHCP discover sent\"));\n}\n\nstatic struct mg_connection *getpeer(struct mg_mgr *mgr, struct pkt *pkt,\n                                     bool lsn) {\n  struct mg_connection *c = NULL;\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    if (c->is_udp && pkt->udp && c->loc.port == pkt->udp->dport) break;\n    if (!c->is_udp && pkt->tcp && c->loc.port == pkt->tcp->dport &&\n        lsn == c->is_listening && (lsn || c->rem.port == pkt->tcp->sport))\n      break;\n  }\n  return c;\n}\n\nstatic void rx_arp(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  if (pkt->arp->op == mg_htons(1) && pkt->arp->tpa == ifp->ip) {\n    // ARP request. Make a response, then send\n    // MG_DEBUG((\"ARP op %d %M: %M\", mg_ntohs(pkt->arp->op), mg_print_ip4,\n    //          &pkt->arp->spa, mg_print_ip4, &pkt->arp->tpa));\n    struct eth *eth = (struct eth *) ifp->tx.ptr;\n    struct arp *arp = (struct arp *) (eth + 1);\n    memcpy(eth->dst, pkt->eth->src, sizeof(eth->dst));\n    memcpy(eth->src, ifp->mac, sizeof(eth->src));\n    eth->type = mg_htons(0x806);\n    *arp = *pkt->arp;\n    arp->op = mg_htons(2);\n    memcpy(arp->tha, pkt->arp->sha, sizeof(pkt->arp->tha));\n    memcpy(arp->sha, ifp->mac, sizeof(pkt->arp->sha));\n    arp->tpa = pkt->arp->spa;\n    arp->spa = ifp->ip;\n    MG_DEBUG((\"ARP: tell %M we're %M\", mg_print_ip4, &arp->tpa, mg_print_ip4,\n              &ifp->ip));\n    ether_output(ifp, PDIFF(eth, arp + 1));\n  } else if (pkt->arp->op == mg_htons(2)) {\n    if (memcmp(pkt->arp->tha, ifp->mac, sizeof(pkt->arp->tha)) != 0) return;\n    if (pkt->arp->spa == ifp->gw) {\n      // Got response for the GW ARP request. Set ifp->gwmac\n      memcpy(ifp->gwmac, pkt->arp->sha, sizeof(ifp->gwmac));\n    } else {\n      struct mg_connection *c = getpeer(ifp->mgr, pkt, false);\n      if (c != NULL && c->is_arplooking) {\n        struct connstate *s = (struct connstate *) (c + 1);\n        memcpy(s->mac, pkt->arp->sha, sizeof(s->mac));\n        MG_DEBUG((\"%lu ARP resolved %M -> %M\", c->id, mg_print_ip4, &c->rem.ip,\n                  mg_print_mac, s->mac));\n        c->is_arplooking = 0;\n      }\n    }\n  }\n}\n\nstatic void rx_icmp(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  // MG_DEBUG((\"ICMP %d\", (int) len));\n  if (pkt->icmp->type == 8 && pkt->ip != NULL && pkt->ip->dst == ifp->ip) {\n    size_t hlen = sizeof(struct eth) + sizeof(struct ip) + sizeof(struct icmp);\n    size_t space = ifp->tx.len - hlen, plen = pkt->pay.len;\n    if (plen > space) plen = space;\n    struct ip *ip = tx_ip(ifp, pkt->eth->src, 1, ifp->ip, pkt->ip->src,\n                          sizeof(struct icmp) + plen);\n    struct icmp *icmp = (struct icmp *) (ip + 1);\n    memset(icmp, 0, sizeof(*icmp));        // Set csum to 0\n    memcpy(icmp + 1, pkt->pay.ptr, plen);  // Copy RX payload to TX\n    icmp->csum = ipcsum(icmp, sizeof(*icmp) + plen);\n    ether_output(ifp, hlen + plen);\n  }\n}\n\nstatic void rx_dhcp_client(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  uint32_t ip = 0, gw = 0, mask = 0;\n  uint8_t *p = pkt->dhcp->options,\n          *end = (uint8_t *) &pkt->raw.ptr[pkt->raw.len];\n  if (end < (uint8_t *) (pkt->dhcp + 1)) return;\n  while (p + 1 < end && p[0] != 255) {  // Parse options\n    if (p[0] == 1 && p[1] == sizeof(ifp->mask) && p + 6 < end) {  // Mask\n      memcpy(&mask, p + 2, sizeof(mask));\n    } else if (p[0] == 3 && p[1] == sizeof(ifp->gw) && p + 6 < end) {  // GW\n      memcpy(&gw, p + 2, sizeof(gw));\n      ip = pkt->dhcp->yiaddr;\n    } else if (p[0] == 51 && p[1] == 4 && p + 6 < end) {  // Lease\n      uint32_t lease = 0;\n      memcpy(&lease, p + 2, sizeof(lease));\n      ifp->lease_expire = ifp->now + mg_ntohl(lease) * 1000;\n    }\n    p += p[1] + 2;\n  }\n  if (ip && mask && gw && ifp->ip == 0) {\n    memcpy(ifp->gwmac, pkt->eth->src, sizeof(ifp->gwmac));\n    ifp->ip = ip, ifp->gw = gw, ifp->mask = mask;\n    ifp->state = MG_TCPIP_STATE_READY;\n    onstatechange(ifp);\n    tx_dhcp_request(ifp, pkt->eth->src, ip, pkt->dhcp->siaddr);\n    uint64_t rand;\n    mg_random(&rand, sizeof(rand));\n    srand((unsigned int) (rand + mg_millis()));\n  }\n}\n\n// Simple DHCP server that assigns a next IP address: ifp->ip + 1\nstatic void rx_dhcp_server(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  uint8_t op = 0, *p = pkt->dhcp->options,\n          *end = (uint8_t *) &pkt->raw.ptr[pkt->raw.len];\n  if (end < (uint8_t *) (pkt->dhcp + 1)) return;\n  // struct dhcp *req = pkt->dhcp;\n  struct dhcp res = {2, 1, 6, 0, 0, 0, 0, 0, 0, 0, 0, {0}, 0, {0}};\n  res.yiaddr = ifp->ip;\n  ((uint8_t *) (&res.yiaddr))[3]++;                // Offer our IP + 1\n  while (p + 1 < end && p[0] != 255) {             // Parse options\n    if (p[0] == 53 && p[1] == 1 && p + 2 < end) {  // Message type\n      op = p[2];\n    }\n    p += p[1] + 2;\n  }\n  if (op == 1 || op == 3) {         // DHCP Discover or DHCP Request\n    uint8_t msg = op == 1 ? 2 : 5;  // Message type: DHCP OFFER or DHCP ACK\n    uint8_t opts[] = {\n        53, 1, msg,                 // Message type\n        1,  4, 0,   0,   0,   0,    // Subnet mask\n        54, 4, 0,   0,   0,   0,    // Server ID\n        12, 3, 'm', 'i', 'p',       // Host name: \"mip\"\n        51, 4, 255, 255, 255, 255,  // Lease time\n        255                         // End of options\n    };\n    memcpy(&res.hwaddr, pkt->dhcp->hwaddr, 6);\n    memcpy(opts + 5, &ifp->mask, sizeof(ifp->mask));\n    memcpy(opts + 11, &ifp->ip, sizeof(ifp->ip));\n    memcpy(&res.options, opts, sizeof(opts));\n    res.magic = pkt->dhcp->magic;\n    res.xid = pkt->dhcp->xid;\n    // memcpy(ifp->gwmac, pkt->eth->src, sizeof(ifp->gwmac));\n    tx_udp(ifp, pkt->eth->src, ifp->ip, mg_htons(67),\n           op == 1 ? ~0U : res.yiaddr, mg_htons(68), &res, sizeof(res));\n  }\n}\n\nstatic void rx_udp(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  struct mg_connection *c = getpeer(ifp->mgr, pkt, true);\n  if (c == NULL) {\n    // No UDP listener on this port. Should send ICMP, but keep silent.\n  } else {\n    c->rem.port = pkt->udp->sport;\n    c->rem.ip = pkt->ip->src;\n    struct connstate *s = (struct connstate *) (c + 1);\n    memcpy(s->mac, pkt->eth->src, sizeof(s->mac));\n    if (c->recv.len >= MG_MAX_RECV_SIZE) {\n      mg_error(c, \"max_recv_buf_size reached\");\n    } else if (c->recv.size - c->recv.len < pkt->pay.len &&\n               !mg_iobuf_resize(&c->recv, c->recv.len + pkt->pay.len)) {\n      mg_error(c, \"oom\");\n    } else {\n      memcpy(&c->recv.buf[c->recv.len], pkt->pay.ptr, pkt->pay.len);\n      c->recv.len += pkt->pay.len;\n      mg_call(c, MG_EV_READ, &pkt->pay.len);\n    }\n  }\n}\n\nstatic size_t tx_tcp(struct mg_tcpip_if *ifp, uint8_t *dst_mac, uint32_t dst_ip,\n                     uint8_t flags, uint16_t sport, uint16_t dport,\n                     uint32_t seq, uint32_t ack, const void *buf, size_t len) {\n  struct ip *ip =\n      tx_ip(ifp, dst_mac, 6, ifp->ip, dst_ip, sizeof(struct tcp) + len);\n  struct tcp *tcp = (struct tcp *) (ip + 1);\n  memset(tcp, 0, sizeof(*tcp));\n  if (buf != NULL && len) memmove(tcp + 1, buf, len);\n  tcp->sport = sport;\n  tcp->dport = dport;\n  tcp->seq = seq;\n  tcp->ack = ack;\n  tcp->flags = flags;\n  tcp->win = mg_htons(8192);\n  tcp->off = (uint8_t) (sizeof(*tcp) / 4 << 4);\n  uint32_t cs = 0;\n  uint16_t n = (uint16_t) (sizeof(*tcp) + len);\n  uint8_t pseudo[] = {0, ip->proto, (uint8_t) (n >> 8), (uint8_t) (n & 255)};\n  cs = csumup(cs, tcp, n);\n  cs = csumup(cs, &ip->src, sizeof(ip->src));\n  cs = csumup(cs, &ip->dst, sizeof(ip->dst));\n  cs = csumup(cs, pseudo, sizeof(pseudo));\n  tcp->csum = csumfin(cs);\n  MG_DEBUG((\"TCP %M:%hu -> %M:%hu fl %x len %u\", mg_print_ip4, &ip->src,\n            mg_ntohs(tcp->sport), mg_print_ip4, &ip->dst, mg_ntohs(tcp->dport),\n            tcp->flags, (int) len));\n  return ether_output(ifp, PDIFF(ifp->tx.ptr, tcp + 1) + len);\n}\n\nstatic size_t tx_tcp_pkt(struct mg_tcpip_if *ifp, struct pkt *pkt,\n                         uint8_t flags, uint32_t seq, const void *buf,\n                         size_t len) {\n  uint32_t delta = (pkt->tcp->flags & (TH_SYN | TH_FIN)) ? 1 : 0;\n  return tx_tcp(ifp, pkt->eth->src, pkt->ip->src, flags, pkt->tcp->dport,\n                pkt->tcp->sport, seq, mg_htonl(mg_ntohl(pkt->tcp->seq) + delta),\n                buf, len);\n}\n\nstatic void settmout(struct mg_connection *c, uint8_t type) {\n  struct mg_tcpip_if *ifp = (struct mg_tcpip_if *) c->mgr->priv;\n  struct connstate *s = (struct connstate *) (c + 1);\n  unsigned n = type == MIP_TTYPE_ACK ? MIP_TCP_ACK_MS : MIP_TCP_KEEPALIVE_MS;\n  s->timer = ifp->now + n;\n  s->ttype = type;\n  MG_VERBOSE((\"%lu %d -> %llx\", c->id, type, s->timer));\n}\n\nstatic struct mg_connection *accept_conn(struct mg_connection *lsn,\n                                         struct pkt *pkt) {\n  struct mg_connection *c = mg_alloc_conn(lsn->mgr);\n  if (c == NULL) {\n    MG_ERROR((\"OOM\"));\n    return NULL;\n  }\n  struct connstate *s = (struct connstate *) (c + 1);\n  s->seq = mg_ntohl(pkt->tcp->ack), s->ack = mg_ntohl(pkt->tcp->seq);\n  memcpy(s->mac, pkt->eth->src, sizeof(s->mac));\n  settmout(c, MIP_TTYPE_KEEPALIVE);\n  c->rem.ip = pkt->ip->src;\n  c->rem.port = pkt->tcp->sport;\n  MG_DEBUG((\"%lu accepted %M\", c->id, mg_print_ip_port, &c->rem));\n  LIST_ADD_HEAD(struct mg_connection, &lsn->mgr->conns, c);\n  c->is_accepted = 1;\n  c->is_hexdumping = lsn->is_hexdumping;\n  c->pfn = lsn->pfn;\n  c->loc = lsn->loc;\n  c->pfn_data = lsn->pfn_data;\n  c->fn = lsn->fn;\n  c->fn_data = lsn->fn_data;\n  mg_call(c, MG_EV_OPEN, NULL);\n  mg_call(c, MG_EV_ACCEPT, NULL);\n  return c;\n}\n\nlong mg_io_send(struct mg_connection *c, const void *buf, size_t len) {\n  struct mg_tcpip_if *ifp = (struct mg_tcpip_if *) c->mgr->priv;\n  struct connstate *s = (struct connstate *) (c + 1);\n  if (c->is_udp) {\n    size_t max_headers_len = 14 + 24 /* max IP */ + 8 /* UDP */;\n    if (len + max_headers_len > ifp->tx.len) len = ifp->tx.len - max_headers_len;\n    tx_udp(ifp, s->mac, ifp->ip, c->loc.port, c->rem.ip, c->rem.port, buf, len);\n  } else {\n    size_t max_headers_len = 14 + 24 /* max IP */ + 60 /* max TCP */;\n    if (len + max_headers_len > ifp->tx.len) len = ifp->tx.len - max_headers_len;\n    if (tx_tcp(ifp, s->mac, c->rem.ip, TH_PUSH | TH_ACK, c->loc.port, c->rem.port,\n               mg_htonl(s->seq), mg_htonl(s->ack), buf, len) > 0) {\n      s->seq += (uint32_t) len;\n      if (s->ttype == MIP_TTYPE_ACK) settmout(c, MIP_TTYPE_KEEPALIVE);\n    } else {\n      return MG_IO_ERR;\n    }\n  }\n  return (long) len;\n}\n\nlong mg_io_recv(struct mg_connection *c, void *buf, size_t len) {\n  struct connstate *s = (struct connstate *) (c + 1);\n  if (s->raw.len == 0) return MG_IO_WAIT;\n  if (len > s->raw.len) len = s->raw.len;\n  memcpy(buf, s->raw.buf, len);\n  mg_iobuf_del(&s->raw, 0, len);\n  MG_DEBUG((\"%lu\", len));\n  return (long) len;\n}\n\nstatic void read_conn(struct mg_connection *c, struct pkt *pkt) {\n  struct connstate *s = (struct connstate *) (c + 1);\n  struct mg_iobuf *io = c->is_tls ? &s->raw : &c->recv;\n  uint32_t seq = mg_ntohl(pkt->tcp->seq);\n  s->raw.align = c->recv.align;\n  if (pkt->tcp->flags & TH_FIN) {\n    s->ack = mg_htonl(pkt->tcp->seq) + 1, s->seq = mg_htonl(pkt->tcp->ack);\n    c->is_closing = 1;\n  } else if (pkt->pay.len == 0) {\n    // TODO(cpq): handle this peer's ACK\n  } else if (seq != s->ack) {\n    uint32_t ack = (uint32_t) (mg_htonl(pkt->tcp->seq) + pkt->pay.len);\n    if (s->ack == ack) {\n      MG_VERBOSE((\"ignoring duplicate pkt\"));\n    } else {\n      // TODO(cpq): peer sent us SEQ which we don't expect. Retransmit rather\n      // than close this connection\n      mg_error(c, \"SEQ != ACK: %x %x %x\", seq, s->ack, ack);\n    }\n  } else if (io->size - io->len < pkt->pay.len &&\n             !mg_iobuf_resize(io, io->len + pkt->pay.len)) {\n    mg_error(c, \"oom\");\n  } else {\n    // Copy TCP payload into the IO buffer. If the connection is plain text, we\n    // copy to c->recv. If the connection is TLS, this data is encrypted,\n    // therefore we copy that encrypted data to the s->raw iobuffer instead,\n    // and then call mg_tls_recv() to decrypt it. NOTE: mg_tls_recv() will\n    // call back mg_io_recv() which grabs raw data from s->raw\n    memcpy(&io->buf[io->len], pkt->pay.ptr, pkt->pay.len);\n    io->len += pkt->pay.len;\n\n    MG_DEBUG((\"%lu SEQ %x -> %x\", c->id, mg_htonl(pkt->tcp->seq), s->ack));\n    // Advance ACK counter\n    s->ack = (uint32_t) (mg_htonl(pkt->tcp->seq) + pkt->pay.len);\n#if 0\n    // Send ACK immediately\n    MG_DEBUG((\"  imm ACK\", c->id, mg_htonl(pkt->tcp->seq), s->ack));\n    tx_tcp((struct mg_tcpip_if *) c->mgr->priv, c->rem.ip, TH_ACK, c->loc.port,\n           c->rem.port, mg_htonl(s->seq), mg_htonl(s->ack), \"\", 0);\n#else\n    // if not already running, setup a timer to send an ACK later\n    if (s->ttype != MIP_TTYPE_ACK) settmout(c, MIP_TTYPE_ACK);\n#endif\n\n    if (c->is_tls) {\n      // TLS connection. Make room for decrypted data in c->recv\n      io = &c->recv;\n      if (io->size - io->len < pkt->pay.len &&\n          !mg_iobuf_resize(io, io->len + pkt->pay.len)) {\n        mg_error(c, \"oom\");\n      } else {\n        // Decrypt data directly into c->recv\n        long n = mg_tls_recv(c, &io->buf[io->len], io->size - io->len);\n        if (n == MG_IO_ERR) {\n          mg_error(c, \"TLS recv error\");\n        } else if (n > 0) {\n          // Decrypted successfully - trigger MG_EV_READ\n          io->len += (size_t) n;\n          mg_call(c, MG_EV_READ, &n);\n        }\n      }\n    } else {\n      // Plain text connection, data is already in c->recv, trigger MG_EV_READ\n      mg_call(c, MG_EV_READ, &pkt->pay.len);\n    }\n  }\n}\n\nstatic void rx_tcp(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  struct mg_connection *c = getpeer(ifp->mgr, pkt, false);\n  struct connstate *s = c == NULL ? NULL : (struct connstate *) (c + 1);\n#if 0\n  MG_INFO((\"%lu %hhu %d\", c ? c->id : 0, pkt->tcp->flags, (int) pkt->pay.len));\n#endif\n  if (c != NULL && c->is_connecting && pkt->tcp->flags & (TH_SYN | TH_ACK)) {\n    s->seq = mg_ntohl(pkt->tcp->ack), s->ack = mg_ntohl(pkt->tcp->seq) + 1;\n    tx_tcp_pkt(ifp, pkt, TH_ACK, pkt->tcp->ack, NULL, 0);\n    c->is_connecting = 0;  // Client connected\n    settmout(c, MIP_TTYPE_KEEPALIVE);\n    mg_call(c, MG_EV_CONNECT, NULL);  // Let user know\n  } else if (c != NULL && c->is_connecting) {\n    tx_tcp_pkt(ifp, pkt, TH_RST | TH_ACK, pkt->tcp->ack, NULL, 0);\n  } else if (c != NULL && pkt->tcp->flags & TH_RST) {\n    mg_error(c, \"peer RST\");  // RFC-1122 4.2.2.13\n  } else if (c != NULL) {\n#if 0\n    MG_DEBUG((\"%lu %d %M:%hu -> %M:%hu\", c->id, (int) pkt->raw.len,\n              mg_print_ip4, &pkt->ip->src, mg_ntohs(pkt->tcp->sport),\n              mg_print_ip4, &pkt->ip->dst, mg_ntohs(pkt->tcp->dport)));\n    mg_hexdump(pkt->pay.buf, pkt->pay.len);\n#endif\n    s->tmiss = 0;                         // Reset missed keep-alive counter\n    if (s->ttype == MIP_TTYPE_KEEPALIVE)  // Advance keep-alive timer\n      settmout(c,\n               MIP_TTYPE_KEEPALIVE);  // unless a former ACK timeout is pending\n    read_conn(c, pkt);  // Override timer with ACK timeout if needed\n  } else if ((c = getpeer(ifp->mgr, pkt, true)) == NULL) {\n    tx_tcp_pkt(ifp, pkt, TH_RST | TH_ACK, pkt->tcp->ack, NULL, 0);\n  } else if (pkt->tcp->flags & TH_RST) {\n    if (c->is_accepted) mg_error(c, \"peer RST\");  // RFC-1122 4.2.2.13\n    // ignore RST if not connected\n  } else if (pkt->tcp->flags & TH_SYN) {\n    // Use peer's source port as ISN, in order to recognise the handshake\n    uint32_t isn = mg_htonl((uint32_t) mg_ntohs(pkt->tcp->sport));\n    tx_tcp_pkt(ifp, pkt, TH_SYN | TH_ACK, isn, NULL, 0);\n  } else if (pkt->tcp->flags & TH_FIN) {\n    tx_tcp_pkt(ifp, pkt, TH_FIN | TH_ACK, pkt->tcp->ack, NULL, 0);\n  } else if (mg_htonl(pkt->tcp->ack) == mg_htons(pkt->tcp->sport) + 1U) {\n    accept_conn(c, pkt);\n  } else if (!c->is_accepted) {  // no peer\n    tx_tcp_pkt(ifp, pkt, TH_RST | TH_ACK, pkt->tcp->ack, NULL, 0);\n  } else {\n    // MG_DEBUG((\"dropped silently..\"));\n  }\n}\n\nstatic void rx_ip(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  if (pkt->ip->proto == 1) {\n    pkt->icmp = (struct icmp *) (pkt->ip + 1);\n    if (pkt->pay.len < sizeof(*pkt->icmp)) return;\n    mkpay(pkt, pkt->icmp + 1);\n    rx_icmp(ifp, pkt);\n  } else if (pkt->ip->proto == 17) {\n    pkt->udp = (struct udp *) (pkt->ip + 1);\n    if (pkt->pay.len < sizeof(*pkt->udp)) return;\n    mkpay(pkt, pkt->udp + 1);\n    MG_DEBUG((\"UDP %M:%hu -> %M:%hu len %u\", mg_print_ip4, &pkt->ip->src,\n              mg_ntohs(pkt->udp->sport), mg_print_ip4, &pkt->ip->dst,\n              mg_ntohs(pkt->udp->dport), (int) pkt->pay.len));\n    if (pkt->udp->dport == mg_htons(68)) {\n      pkt->dhcp = (struct dhcp *) (pkt->udp + 1);\n      mkpay(pkt, pkt->dhcp + 1);\n      rx_dhcp_client(ifp, pkt);\n    } else if (ifp->enable_dhcp_server && pkt->udp->dport == mg_htons(67)) {\n      pkt->dhcp = (struct dhcp *) (pkt->udp + 1);\n      mkpay(pkt, pkt->dhcp + 1);\n      rx_dhcp_server(ifp, pkt);\n    } else {\n      rx_udp(ifp, pkt);\n    }\n  } else if (pkt->ip->proto == 6) {\n    pkt->tcp = (struct tcp *) (pkt->ip + 1);\n    if (pkt->pay.len < sizeof(*pkt->tcp)) return;\n    mkpay(pkt, pkt->tcp + 1);\n    uint16_t iplen = mg_ntohs(pkt->ip->len);\n    uint16_t off = (uint16_t) (sizeof(*pkt->ip) + ((pkt->tcp->off >> 4) * 4U));\n    if (iplen >= off) pkt->pay.len = (size_t) (iplen - off);\n    MG_DEBUG((\"TCP %M:%hu -> %M:%hu len %u\", mg_print_ip4, &pkt->ip->src,\n              mg_ntohs(pkt->tcp->sport), mg_print_ip4, &pkt->ip->dst,\n              mg_ntohs(pkt->tcp->dport), (int) pkt->pay.len));\n    rx_tcp(ifp, pkt);\n  }\n}\n\nstatic void rx_ip6(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  // MG_DEBUG((\"IP %d\", (int) len));\n  if (pkt->ip6->proto == 1 || pkt->ip6->proto == 58) {\n    pkt->icmp = (struct icmp *) (pkt->ip6 + 1);\n    if (pkt->pay.len < sizeof(*pkt->icmp)) return;\n    mkpay(pkt, pkt->icmp + 1);\n    rx_icmp(ifp, pkt);\n  } else if (pkt->ip6->proto == 17) {\n    pkt->udp = (struct udp *) (pkt->ip6 + 1);\n    if (pkt->pay.len < sizeof(*pkt->udp)) return;\n    // MG_DEBUG((\"  UDP %u %u -> %u\", len, mg_htons(udp->sport),\n    // mg_htons(udp->dport)));\n    mkpay(pkt, pkt->udp + 1);\n  }\n}\n\nstatic void mg_tcpip_rx(struct mg_tcpip_if *ifp, void *buf, size_t len) {\n  const uint8_t broadcast[] = {255, 255, 255, 255, 255, 255};\n  struct pkt pkt;\n  memset(&pkt, 0, sizeof(pkt));\n  pkt.raw.ptr = (char *) buf;\n  pkt.raw.len = len;\n  pkt.eth = (struct eth *) buf;\n  if (pkt.raw.len < sizeof(*pkt.eth)) return;  // Truncated - runt?\n  if (ifp->enable_mac_check &&\n      memcmp(pkt.eth->dst, ifp->mac, sizeof(pkt.eth->dst)) != 0 &&\n      memcmp(pkt.eth->dst, broadcast, sizeof(pkt.eth->dst)) != 0)\n    return;\n  if (ifp->enable_crc32_check && len > 4) {\n    len -= 4;  // TODO(scaprile): check on bigendian\n    uint32_t crc = mg_crc32(0, (const char *) buf, len);\n    if (memcmp((void *) ((size_t) buf + len), &crc, sizeof(crc))) return;\n  }\n  if (pkt.eth->type == mg_htons(0x806)) {\n    pkt.arp = (struct arp *) (pkt.eth + 1);\n    if (sizeof(*pkt.eth) + sizeof(*pkt.arp) > pkt.raw.len) return;  // Truncated\n    rx_arp(ifp, &pkt);\n  } else if (pkt.eth->type == mg_htons(0x86dd)) {\n    pkt.ip6 = (struct ip6 *) (pkt.eth + 1);\n    if (pkt.raw.len < sizeof(*pkt.eth) + sizeof(*pkt.ip6)) return;  // Truncated\n    if ((pkt.ip6->ver >> 4) != 0x6) return;                         // Not IP\n    mkpay(&pkt, pkt.ip6 + 1);\n    rx_ip6(ifp, &pkt);\n  } else if (pkt.eth->type == mg_htons(0x800)) {\n    pkt.ip = (struct ip *) (pkt.eth + 1);\n    if (pkt.raw.len < sizeof(*pkt.eth) + sizeof(*pkt.ip)) return;  // Truncated\n    // Truncate frame to what IP header tells us\n    if ((size_t) mg_ntohs(pkt.ip->len) + sizeof(struct eth) < pkt.raw.len) {\n      pkt.raw.len = (size_t) mg_ntohs(pkt.ip->len) + sizeof(struct eth);\n    }\n    if (pkt.raw.len < sizeof(*pkt.eth) + sizeof(*pkt.ip)) return;  // Truncated\n    if ((pkt.ip->ver >> 4) != 4) return;                           // Not IP\n    mkpay(&pkt, pkt.ip + 1);\n    rx_ip(ifp, &pkt);\n  } else {\n    MG_DEBUG((\"  Unknown eth type %x\", mg_htons(pkt.eth->type)));\n    mg_hexdump(buf, len >= 16 ? 16 : len);\n  }\n}\n\nstatic void mg_tcpip_poll(struct mg_tcpip_if *ifp, uint64_t uptime_ms) {\n  if (ifp == NULL || ifp->driver == NULL) return;\n  bool expired_1000ms = mg_timer_expired(&ifp->timer_1000ms, 1000, uptime_ms);\n  ifp->now = uptime_ms;\n\n  // Handle physical interface up/down status\n  if (expired_1000ms && ifp->driver->up) {\n    bool up = ifp->driver->up(ifp);\n    bool current = ifp->state != MG_TCPIP_STATE_DOWN;\n    if (up != current) {\n      ifp->state = up == false               ? MG_TCPIP_STATE_DOWN\n                   : ifp->enable_dhcp_client ? MG_TCPIP_STATE_UP\n                                             : MG_TCPIP_STATE_READY;\n      if (!up && ifp->enable_dhcp_client) ifp->ip = 0;\n      onstatechange(ifp);\n    }\n  }\n  if (ifp->state == MG_TCPIP_STATE_DOWN) return;\n\n  // If IP not configured, send DHCP\n  if (ifp->ip == 0 && expired_1000ms) tx_dhcp_discover(ifp);\n\n  // Read data from the network\n  if (ifp->driver->rx != NULL) {  // Polling driver. We must call it\n    size_t len =\n        ifp->driver->rx(ifp->recv_queue.buf, ifp->recv_queue.size, ifp);\n    if (len > 0) mg_tcpip_rx(ifp, ifp->recv_queue.buf, len);\n  } else {  // Interrupt-based driver. Fills recv queue itself\n    char *buf;\n    size_t len = mg_queue_next(&ifp->recv_queue, &buf);\n    if (len > 0) {\n      mg_tcpip_rx(ifp, buf, len);\n      mg_queue_del(&ifp->recv_queue, len);\n    }\n  }\n\n  // Process timeouts\n  for (struct mg_connection *c = ifp->mgr->conns; c != NULL; c = c->next) {\n    if (c->is_udp || c->is_listening) continue;\n    if (c->is_connecting || c->is_resolving) continue;\n    struct connstate *s = (struct connstate *) (c + 1);\n    if (uptime_ms > s->timer) {\n      if (s->ttype == MIP_TTYPE_ACK) {\n        MG_DEBUG((\"%lu ack %x %x\", c->id, s->seq, s->ack));\n        tx_tcp(ifp, s->mac, c->rem.ip, TH_ACK, c->loc.port, c->rem.port,\n               mg_htonl(s->seq), mg_htonl(s->ack), \"\", 0);\n      } else {\n        if (s->tmiss++ > 2) {\n          mg_error(c, \"keepalive\");\n        } else {\n          MG_DEBUG((\"%lu keepalive\", c->id));\n          tx_tcp(ifp, s->mac, c->rem.ip, TH_ACK, c->loc.port, c->rem.port,\n                 mg_htonl(s->seq - 1), mg_htonl(s->ack), \"\", 0);\n        }\n      }\n      settmout(c, MIP_TTYPE_KEEPALIVE);\n    }\n  }\n}\n\n// This function executes in interrupt context, thus it should copy data\n// somewhere fast. Note that newlib's malloc is not thread safe, thus use\n// our lock-free queue with preallocated buffer to copy data and return asap\nvoid mg_tcpip_qwrite(void *buf, size_t len, struct mg_tcpip_if *ifp) {\n  char *p;\n  if (mg_queue_book(&ifp->recv_queue, &p, len) >= len) {\n    memcpy(p, buf, len);\n    mg_queue_add(&ifp->recv_queue, len);\n    ifp->nrecv++;\n  } else {\n    ifp->ndrop++;\n  }\n}\n\nvoid mg_tcpip_init(struct mg_mgr *mgr, struct mg_tcpip_if *ifp) {\n  // If MAC address is not set, make a random one\n  if (ifp->mac[0] == 0 && ifp->mac[1] == 0 && ifp->mac[2] == 0 &&\n      ifp->mac[3] == 0 && ifp->mac[4] == 0 && ifp->mac[5] == 0) {\n    ifp->mac[0] = 0x02;  // Locally administered, unicast\n    mg_random(&ifp->mac[1], sizeof(ifp->mac) - 1);\n    MG_INFO((\"MAC not set. Generated random: %M\", mg_print_mac, ifp->mac));\n  }\n\n  if (ifp->driver->init && !ifp->driver->init(ifp)) {\n    MG_ERROR((\"driver init failed\"));\n  } else {\n    size_t framesize = 1540;\n    ifp->tx.ptr = (char *) calloc(1, framesize), ifp->tx.len = framesize;\n    if (ifp->recv_queue.size == 0)\n      ifp->recv_queue.size = ifp->driver->rx ? framesize : 8192;\n    ifp->recv_queue.buf = (char *) calloc(1, ifp->recv_queue.size);\n    ifp->timer_1000ms = mg_millis();\n    mgr->priv = ifp;\n    ifp->mgr = mgr;\n    mgr->extraconnsize = sizeof(struct connstate);\n    if (ifp->ip == 0) ifp->enable_dhcp_client = true;\n    memset(ifp->gwmac, 255, sizeof(ifp->gwmac));  // Set to broadcast\n    mg_random(&ifp->eport, sizeof(ifp->eport));   // Random from 0 to 65535\n    ifp->eport |=\n        MG_EPHEMERAL_PORT_BASE;  // Random from MG_EPHEMERAL_PORT_BASE to 65535\n    if (ifp->tx.ptr == NULL || ifp->recv_queue.buf == NULL) MG_ERROR((\"OOM\"));\n  }\n}\n\nvoid mg_tcpip_free(struct mg_tcpip_if *ifp) {\n  free(ifp->recv_queue.buf);\n  free((char *) ifp->tx.ptr);\n}\n\nint mg_mkpipe(struct mg_mgr *m, mg_event_handler_t fn, void *d, bool udp) {\n  (void) m, (void) fn, (void) d, (void) udp;\n  MG_ERROR((\"Not implemented\"));\n  return -1;\n}\n\nstatic void send_syn(struct mg_connection *c) {\n  struct connstate *s = (struct connstate *) (c + 1);\n  uint32_t isn = mg_htonl((uint32_t) mg_ntohs(c->loc.port));\n  struct mg_tcpip_if *ifp = (struct mg_tcpip_if *) c->mgr->priv;\n  tx_tcp(ifp, s->mac, c->rem.ip, TH_SYN, c->loc.port, c->rem.port, isn, 0, NULL,\n         0);\n}\n\nvoid mg_connect_resolved(struct mg_connection *c) {\n  struct mg_tcpip_if *ifp = (struct mg_tcpip_if *) c->mgr->priv;\n  c->is_resolving = 0;\n  if (ifp->eport < MG_EPHEMERAL_PORT_BASE) ifp->eport = MG_EPHEMERAL_PORT_BASE;\n  c->loc.ip = ifp->ip;\n  c->loc.port = mg_htons(ifp->eport++);\n  MG_DEBUG((\"%lu %M -> %M\", c->id, mg_print_ip_port, &c->loc, mg_print_ip_port,\n            &c->rem));\n  mg_call(c, MG_EV_RESOLVE, NULL);\n  if (((c->rem.ip & ifp->mask) == (ifp->ip & ifp->mask))) {\n    // If we're in the same LAN, fire an ARP lookup. TODO(cpq): handle this!\n    MG_DEBUG((\"%lu ARP lookup...\", c->id));\n    arp_ask(ifp, c->rem.ip);\n    c->is_arplooking = 1;\n  } else if (c->rem.ip == (ifp->ip | ~ifp->mask)) {\n    struct connstate *s = (struct connstate *) (c + 1);\n    memset(s->mac, 0xFF, sizeof(s->mac));  // local broadcast\n  } else if ((*((uint8_t *) &c->rem.ip) & 0xE0) == 0xE0) {\n    struct connstate *s = (struct connstate *) (c + 1);  // 224 to 239, E0 to EF\n    uint8_t mcastp[3] = {0x01, 0x00, 0x5E};              // multicast group\n    memcpy(s->mac, mcastp, 3);\n    memcpy(s->mac + 3, ((uint8_t *) &c->rem.ip) + 1, 3);  // 23 LSb\n    s->mac[3] &= 0x7F;\n  } else {\n    struct connstate *s = (struct connstate *) (c + 1);\n    memcpy(s->mac, ifp->gwmac, sizeof(ifp->gwmac));\n    if (c->is_udp) {\n      mg_call(c, MG_EV_CONNECT, NULL);\n    } else {\n      send_syn(c);\n      c->is_connecting = 1;\n    }\n  }\n}\n\nbool mg_open_listener(struct mg_connection *c, const char *url) {\n  c->loc.port = mg_htons(mg_url_port(url));\n  return true;\n}\n\nstatic void write_conn(struct mg_connection *c) {\n  long len = c->is_tls ? mg_tls_send(c, c->send.buf, c->send.len)\n                       : mg_io_send(c, c->send.buf, c->send.len);\n  if (len > 0) {\n    mg_iobuf_del(&c->send, 0, (size_t) len);\n    mg_call(c, MG_EV_WRITE, &len);\n  }\n}\n\nstatic void close_conn(struct mg_connection *c) {\n  struct connstate *s = (struct connstate *) (c + 1);\n  mg_iobuf_free(&s->raw);  // For TLS connections, release raw data\n  if (c->is_udp == false && c->is_listening == false) {  // For TCP conns,\n    struct mg_tcpip_if *ifp =\n        (struct mg_tcpip_if *) c->mgr->priv;  // send TCP FIN\n    tx_tcp(ifp, s->mac, c->rem.ip, TH_FIN | TH_ACK, c->loc.port, c->rem.port,\n           mg_htonl(s->seq), mg_htonl(s->ack), NULL, 0);\n  }\n  mg_close_conn(c);\n}\n\nstatic bool can_write(struct mg_connection *c) {\n  return c->is_connecting == 0 && c->is_resolving == 0 && c->send.len > 0 &&\n         c->is_tls_hs == 0 && c->is_arplooking == 0;\n}\n\nvoid mg_mgr_poll(struct mg_mgr *mgr, int ms) {\n  struct mg_connection *c, *tmp;\n  uint64_t now = mg_millis();\n  mg_tcpip_poll((struct mg_tcpip_if *) mgr->priv, now);\n  mg_timer_poll(&mgr->timers, now);\n  for (c = mgr->conns; c != NULL; c = tmp) {\n    tmp = c->next;\n    mg_call(c, MG_EV_POLL, &now);\n    MG_VERBOSE((\"%lu .. %c%c%c%c%c\", c->id, c->is_tls ? 'T' : 't',\n                c->is_connecting ? 'C' : 'c', c->is_tls_hs ? 'H' : 'h',\n                c->is_resolving ? 'R' : 'r', c->is_closing ? 'C' : 'c'));\n    if (c->is_tls_hs) mg_tls_handshake(c);\n    if (can_write(c)) write_conn(c);\n    if (c->is_draining && c->send.len == 0) c->is_closing = 1;\n    if (c->is_closing) close_conn(c);\n  }\n  (void) ms;\n}\n\nbool mg_send(struct mg_connection *c, const void *buf, size_t len) {\n  struct mg_tcpip_if *ifp = (struct mg_tcpip_if *) c->mgr->priv;\n  bool res = false;\n  if (ifp->ip == 0 || ifp->state != MG_TCPIP_STATE_READY) {\n    mg_error(c, \"net down\");\n  } else if (c->is_udp) {\n    struct connstate *s = (struct connstate *) (c + 1);\n    tx_udp(ifp, s->mac, ifp->ip, c->loc.port, c->rem.ip, c->rem.port, buf, len);\n    res = true;\n  } else {\n    res = mg_iobuf_add(&c->send, c->send.len, buf, len);\n  }\n  return res;\n}\n#endif  // MG_ENABLE_TCPIP\n", "#include \"arch.h\"\n#include \"base64.h\"\n#include \"fmt.h\"\n#include \"http.h\"\n#include \"json.h\"\n#include \"log.h\"\n#include \"net.h\"\n#include \"printf.h\"\n#include \"ssi.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include \"ws.h\"\n\n// Chunk deletion marker is the MSB in the \"processed\" counter\n#define MG_DMARK ((size_t) 1 << (sizeof(size_t) * 8 - 1))\n\n// Multipart POST example:\n// --xyz\n// Content-Disposition: form-data; name=\"val\"\n//\n// abcdef\n// --xyz\n// Content-Disposition: form-data; name=\"foo\"; filename=\"a.txt\"\n// Content-Type: text/plain\n//\n// hello world\n//\n// --xyz--\nsize_t mg_http_next_multipart(struct mg_str body, size_t ofs,\n                              struct mg_http_part *part) {\n  struct mg_str cd = mg_str_n(\"Content-Disposition\", 19);\n  const char *s = body.ptr;\n  size_t b = ofs, h1, h2, b1, b2, max = body.len;\n\n  // Init part params\n  if (part != NULL) part->name = part->filename = part->body = mg_str_n(0, 0);\n\n  // Skip boundary\n  while (b + 2 < max && s[b] != '\\r' && s[b + 1] != '\\n') b++;\n  if (b <= ofs || b + 2 >= max) return 0;\n  // MG_INFO((\"B: %zu %zu [%.*s]\", ofs, b - ofs, (int) (b - ofs), s));\n\n  // Skip headers\n  h1 = h2 = b + 2;\n  for (;;) {\n    while (h2 + 2 < max && s[h2] != '\\r' && s[h2 + 1] != '\\n') h2++;\n    if (h2 == h1) break;\n    if (h2 + 2 >= max) return 0;\n    // MG_INFO((\"Header: [%.*s]\", (int) (h2 - h1), &s[h1]));\n    if (part != NULL && h1 + cd.len + 2 < h2 && s[h1 + cd.len] == ':' &&\n        mg_ncasecmp(&s[h1], cd.ptr, cd.len) == 0) {\n      struct mg_str v = mg_str_n(&s[h1 + cd.len + 2], h2 - (h1 + cd.len + 2));\n      part->name = mg_http_get_header_var(v, mg_str_n(\"name\", 4));\n      part->filename = mg_http_get_header_var(v, mg_str_n(\"filename\", 8));\n    }\n    h1 = h2 = h2 + 2;\n  }\n  b1 = b2 = h2 + 2;\n  while (b2 + 2 + (b - ofs) + 2 < max && !(s[b2] == '\\r' && s[b2 + 1] == '\\n' &&\n                                           memcmp(&s[b2 + 2], s, b - ofs) == 0))\n    b2++;\n\n  if (b2 + 2 >= max) return 0;\n  if (part != NULL) part->body = mg_str_n(&s[b1], b2 - b1);\n  // MG_INFO((\"Body: [%.*s]\", (int) (b2 - b1), &s[b1]));\n  return b2 + 2;\n}\n\nvoid mg_http_bauth(struct mg_connection *c, const char *user,\n                   const char *pass) {\n  struct mg_str u = mg_str(user), p = mg_str(pass);\n  size_t need = c->send.len + 36 + (u.len + p.len) * 2;\n  if (c->send.size < need) mg_iobuf_resize(&c->send, need);\n  if (c->send.size >= need) {\n    int i, n = 0;\n    char *buf = (char *) &c->send.buf[c->send.len];\n    memcpy(buf, \"Authorization: Basic \", 21);  // DON'T use mg_send!\n    for (i = 0; i < (int) u.len; i++) {\n      n = mg_base64_update(((unsigned char *) u.ptr)[i], buf + 21, n);\n    }\n    if (p.len > 0) {\n      n = mg_base64_update(':', buf + 21, n);\n      for (i = 0; i < (int) p.len; i++) {\n        n = mg_base64_update(((unsigned char *) p.ptr)[i], buf + 21, n);\n      }\n    }\n    n = mg_base64_final(buf + 21, n);\n    c->send.len += 21 + (size_t) n + 2;\n    memcpy(&c->send.buf[c->send.len - 2], \"\\r\\n\", 2);\n  } else {\n    MG_ERROR((\"%lu oom %d->%d \", c->id, (int) c->send.size, (int) need));\n  }\n}\n\nstruct mg_str mg_http_var(struct mg_str buf, struct mg_str name) {\n  struct mg_str k, v, result = mg_str_n(NULL, 0);\n  while (mg_split(&buf, &k, &v, '&')) {\n    if (name.len == k.len && mg_ncasecmp(name.ptr, k.ptr, k.len) == 0) {\n      result = v;\n      break;\n    }\n  }\n  return result;\n}\n\nint mg_http_get_var(const struct mg_str *buf, const char *name, char *dst,\n                    size_t dst_len) {\n  int len;\n  if (dst == NULL || dst_len == 0) {\n    len = -2;  // Bad destination\n  } else if (buf->ptr == NULL || name == NULL || buf->len == 0) {\n    len = -1;  // Bad source\n    dst[0] = '\\0';\n  } else {\n    struct mg_str v = mg_http_var(*buf, mg_str(name));\n    if (v.ptr == NULL) {\n      len = -4;  // Name does not exist\n    } else {\n      len = mg_url_decode(v.ptr, v.len, dst, dst_len, 1);\n      if (len < 0) len = -3;  // Failed to decode\n    }\n  }\n  return len;\n}\n\nstatic bool isx(int c) {\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||\n         (c >= 'A' && c <= 'F');\n}\n\nint mg_url_decode(const char *src, size_t src_len, char *dst, size_t dst_len,\n                  int is_form_url_encoded) {\n  size_t i, j;\n  for (i = j = 0; i < src_len && j + 1 < dst_len; i++, j++) {\n    if (src[i] == '%') {\n      // Use `i + 2 < src_len`, not `i < src_len - 2`, note small src_len\n      if (i + 2 < src_len && isx(src[i + 1]) && isx(src[i + 2])) {\n        mg_unhex(src + i + 1, 2, (uint8_t *) &dst[j]);\n        i += 2;\n      } else {\n        return -1;\n      }\n    } else if (is_form_url_encoded && src[i] == '+') {\n      dst[j] = ' ';\n    } else {\n      dst[j] = src[i];\n    }\n  }\n  if (j < dst_len) dst[j] = '\\0';  // Null-terminate the destination\n  return i >= src_len && j < dst_len ? (int) j : -1;\n}\n\nstatic bool isok(uint8_t c) { return c == '\\n' || c == '\\r' || c >= ' '; }\n\nint mg_http_get_request_len(const unsigned char *buf, size_t buf_len) {\n  size_t i;\n  for (i = 0; i < buf_len; i++) {\n    if (!isok(buf[i])) return -1;\n    if ((i > 0 && buf[i] == '\\n' && buf[i - 1] == '\\n') ||\n        (i > 3 && buf[i] == '\\n' && buf[i - 1] == '\\r' && buf[i - 2] == '\\n'))\n      return (int) i + 1;\n  }\n  return 0;\n}\n\nstatic const char *skip(const char *s, const char *e, const char *d,\n                        struct mg_str *v) {\n  v->ptr = s;\n  while (s < e && *s != '\\n' && strchr(d, *s) == NULL) s++;\n  v->len = (size_t) (s - v->ptr);\n  while (s < e && strchr(d, *s) != NULL) s++;\n  return s;\n}\n\nstruct mg_str *mg_http_get_header(struct mg_http_message *h, const char *name) {\n  size_t i, n = strlen(name), max = sizeof(h->headers) / sizeof(h->headers[0]);\n  for (i = 0; i < max && h->headers[i].name.len > 0; i++) {\n    struct mg_str *k = &h->headers[i].name, *v = &h->headers[i].value;\n    if (n == k->len && mg_ncasecmp(k->ptr, name, n) == 0) return v;\n  }\n  return NULL;\n}\n\nstatic void mg_http_parse_headers(const char *s, const char *end,\n                                  struct mg_http_header *h, int max_headers) {\n  int i;\n  for (i = 0; i < max_headers; i++) {\n    struct mg_str k, v, tmp;\n    const char *he = skip(s, end, \"\\n\", &tmp);\n    s = skip(s, he, \": \\r\\n\", &k);\n    s = skip(s, he, \"\\r\\n\", &v);\n    if (k.len == tmp.len) continue;\n    while (v.len > 0 && v.ptr[v.len - 1] == ' ') v.len--;  // Trim spaces\n    if (k.len == 0) break;\n    // MG_INFO((\"--HH [%.*s] [%.*s] [%.*s]\", (int) tmp.len - 1, tmp.ptr,\n    //(int) k.len, k.ptr, (int) v.len, v.ptr));\n    h[i].name = k;\n    h[i].value = v;\n  }\n}\n\nint mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {\n  int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);\n  const char *end = s == NULL ? NULL : s + req_len, *qs;  // Cannot add to NULL\n  struct mg_str *cl;\n\n  memset(hm, 0, sizeof(*hm));\n  if (req_len <= 0) return req_len;\n\n  hm->message.ptr = hm->head.ptr = s;\n  hm->body.ptr = end;\n  hm->head.len = (size_t) req_len;\n  hm->chunk.ptr = end;\n  hm->message.len = hm->body.len = (size_t) ~0;  // Set body length to infinite\n\n  // Parse request line\n  s = skip(s, end, \" \", &hm->method);\n  s = skip(s, end, \" \", &hm->uri);\n  s = skip(s, end, \"\\r\\n\", &hm->proto);\n\n  // Sanity check. Allow protocol/reason to be empty\n  if (hm->method.len == 0 || hm->uri.len == 0) return -1;\n\n  // If URI contains '?' character, setup query string\n  if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {\n    hm->query.ptr = qs + 1;\n    hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));\n    hm->uri.len = (size_t) (qs - hm->uri.ptr);\n  }\n\n  mg_http_parse_headers(s, end, hm->headers,\n                        sizeof(hm->headers) / sizeof(hm->headers[0]));\n  if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {\n    hm->body.len = (size_t) mg_to64(*cl);\n    hm->message.len = (size_t) req_len + hm->body.len;\n  }\n\n  // mg_http_parse() is used to parse both HTTP requests and HTTP\n  // responses. If HTTP response does not have Content-Length set, then\n  // body is read until socket is closed, i.e. body.len is infinite (~0).\n  //\n  // For HTTP requests though, according to\n  // http://tools.ietf.org/html/rfc7231#section-8.1.3,\n  // only POST and PUT methods have defined body semantics.\n  // Therefore, if Content-Length is not specified and methods are\n  // not one of PUT or POST, set body length to 0.\n  //\n  // So, if it is HTTP request, and Content-Length is not set,\n  // and method is not (PUT or POST) then reset body length to zero.\n  is_response = mg_ncasecmp(hm->method.ptr, \"HTTP/\", 5) == 0;\n  if (hm->body.len == (size_t) ~0 && !is_response &&\n      mg_vcasecmp(&hm->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&hm->method, \"POST\") != 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  // The 204 (No content) responses also have 0 body length\n  if (hm->body.len == (size_t) ~0 && is_response &&\n      mg_vcasecmp(&hm->uri, \"204\") == 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  return req_len;\n}\n\nstatic void mg_http_vprintf_chunk(struct mg_connection *c, const char *fmt,\n                                  va_list *ap) {\n  size_t len = c->send.len;\n  mg_send(c, \"        \\r\\n\", 10);\n  mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, ap);\n  if (c->send.len >= len + 10) {\n    mg_snprintf((char *) c->send.buf + len, 9, \"%08lx\", c->send.len - len - 10);\n    c->send.buf[len + 8] = '\\r';\n    if (c->send.len == len + 10) c->is_resp = 0;  // Last chunk, reset marker\n  }\n  mg_send(c, \"\\r\\n\", 2);\n}\n\nvoid mg_http_printf_chunk(struct mg_connection *c, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  mg_http_vprintf_chunk(c, fmt, &ap);\n  va_end(ap);\n}\n\nvoid mg_http_write_chunk(struct mg_connection *c, const char *buf, size_t len) {\n  mg_printf(c, \"%lx\\r\\n\", (unsigned long) len);\n  mg_send(c, buf, len);\n  mg_send(c, \"\\r\\n\", 2);\n  if (len == 0) c->is_resp = 0;\n}\n\n// clang-format off\nstatic const char *mg_http_status_code_str(int status_code) {\n  switch (status_code) {\n    case 100: return \"Continue\";\n    case 201: return \"Created\";\n    case 202: return \"Accepted\";\n    case 204: return \"No Content\";\n    case 206: return \"Partial Content\";\n    case 301: return \"Moved Permanently\";\n    case 302: return \"Found\";\n    case 304: return \"Not Modified\";\n    case 400: return \"Bad Request\";\n    case 401: return \"Unauthorized\";\n    case 403: return \"Forbidden\";\n    case 404: return \"Not Found\";\n    case 418: return \"I'm a teapot\";\n    case 500: return \"Internal Server Error\";\n    case 501: return \"Not Implemented\";\n    default: return \"OK\";\n  }\n}\n// clang-format on\n\nvoid mg_http_reply(struct mg_connection *c, int code, const char *headers,\n                   const char *fmt, ...) {\n  va_list ap;\n  size_t len;\n  mg_printf(c, \"HTTP/1.1 %d %s\\r\\n%sContent-Length:            \\r\\n\\r\\n\", code,\n            mg_http_status_code_str(code), headers == NULL ? \"\" : headers);\n  len = c->send.len;\n  va_start(ap, fmt);\n  mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, &ap);\n  va_end(ap);\n  if (c->send.len > 16) {\n    size_t n = mg_snprintf((char *) &c->send.buf[len - 15], 11, \"%-10lu\",\n                           (unsigned long) (c->send.len - len));\n    c->send.buf[len - 15 + n] = ' ';  // Change ending 0 to space\n  }\n  c->is_resp = 0;\n}\n\nstatic void http_cb(struct mg_connection *, int, void *, void *);\nstatic void restore_http_cb(struct mg_connection *c) {\n  mg_fs_close((struct mg_fd *) c->pfn_data);\n  c->pfn_data = NULL;\n  c->pfn = http_cb;\n  c->is_resp = 0;\n}\n\nchar *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime);\nchar *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime) {\n  mg_snprintf(buf, len, \"\\\"%lld.%lld\\\"\", (int64_t) mtime, (int64_t) size);\n  return buf;\n}\n\nstatic void static_cb(struct mg_connection *c, int ev, void *ev_data,\n                      void *fn_data) {\n  if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {\n    struct mg_fd *fd = (struct mg_fd *) fn_data;\n    // Read to send IO buffer directly, avoid extra on-stack buffer\n    size_t n, max = MG_IO_SIZE, space;\n    size_t *cl = (size_t *) &c->data[(sizeof(c->data) - sizeof(size_t)) /\n                                     sizeof(size_t) * sizeof(size_t)];\n    if (c->send.size < max) mg_iobuf_resize(&c->send, max);\n    if (c->send.len >= c->send.size) return;  // Rate limit\n    if ((space = c->send.size - c->send.len) > *cl) space = *cl;\n    n = fd->fs->rd(fd->fd, c->send.buf + c->send.len, space);\n    c->send.len += n;\n    *cl -= n;\n    if (n == 0) restore_http_cb(c);\n  } else if (ev == MG_EV_CLOSE) {\n    restore_http_cb(c);\n  }\n  (void) ev_data;\n}\n\n// Known mime types. Keep it outside guess_content_type() function, since\n// some environments don't like it defined there.\n// clang-format off\nstatic struct mg_str s_known_types[] = {\n    MG_C_STR(\"html\"), MG_C_STR(\"text/html; charset=utf-8\"),\n    MG_C_STR(\"htm\"), MG_C_STR(\"text/html; charset=utf-8\"),\n    MG_C_STR(\"css\"), MG_C_STR(\"text/css; charset=utf-8\"),\n    MG_C_STR(\"js\"), MG_C_STR(\"text/javascript; charset=utf-8\"),\n    MG_C_STR(\"gif\"), MG_C_STR(\"image/gif\"),\n    MG_C_STR(\"png\"), MG_C_STR(\"image/png\"),\n    MG_C_STR(\"jpg\"), MG_C_STR(\"image/jpeg\"),\n    MG_C_STR(\"jpeg\"), MG_C_STR(\"image/jpeg\"),\n    MG_C_STR(\"woff\"), MG_C_STR(\"font/woff\"),\n    MG_C_STR(\"ttf\"), MG_C_STR(\"font/ttf\"),\n    MG_C_STR(\"svg\"), MG_C_STR(\"image/svg+xml\"),\n    MG_C_STR(\"txt\"), MG_C_STR(\"text/plain; charset=utf-8\"),\n    MG_C_STR(\"avi\"), MG_C_STR(\"video/x-msvideo\"),\n    MG_C_STR(\"csv\"), MG_C_STR(\"text/csv\"),\n    MG_C_STR(\"doc\"), MG_C_STR(\"application/msword\"),\n    MG_C_STR(\"exe\"), MG_C_STR(\"application/octet-stream\"),\n    MG_C_STR(\"gz\"), MG_C_STR(\"application/gzip\"),\n    MG_C_STR(\"ico\"), MG_C_STR(\"image/x-icon\"),\n    MG_C_STR(\"json\"), MG_C_STR(\"application/json\"),\n    MG_C_STR(\"mov\"), MG_C_STR(\"video/quicktime\"),\n    MG_C_STR(\"mp3\"), MG_C_STR(\"audio/mpeg\"),\n    MG_C_STR(\"mp4\"), MG_C_STR(\"video/mp4\"),\n    MG_C_STR(\"mpeg\"), MG_C_STR(\"video/mpeg\"),\n    MG_C_STR(\"pdf\"), MG_C_STR(\"application/pdf\"),\n    MG_C_STR(\"shtml\"), MG_C_STR(\"text/html; charset=utf-8\"),\n    MG_C_STR(\"tgz\"), MG_C_STR(\"application/tar-gz\"),\n    MG_C_STR(\"wav\"), MG_C_STR(\"audio/wav\"),\n    MG_C_STR(\"webp\"), MG_C_STR(\"image/webp\"),\n    MG_C_STR(\"zip\"), MG_C_STR(\"application/zip\"),\n    MG_C_STR(\"3gp\"), MG_C_STR(\"video/3gpp\"),\n    {0, 0},\n};\n// clang-format on\n\nstatic struct mg_str guess_content_type(struct mg_str path, const char *extra) {\n  struct mg_str k, v, s = mg_str(extra);\n  size_t i = 0;\n\n  // Shrink path to its extension only\n  while (i < path.len && path.ptr[path.len - i - 1] != '.') i++;\n  path.ptr += path.len - i;\n  path.len = i;\n\n  // Process user-provided mime type overrides, if any\n  while (mg_commalist(&s, &k, &v)) {\n    if (mg_strcmp(path, k) == 0) return v;\n  }\n\n  // Process built-in mime types\n  for (i = 0; s_known_types[i].ptr != NULL; i += 2) {\n    if (mg_strcmp(path, s_known_types[i]) == 0) return s_known_types[i + 1];\n  }\n\n  return mg_str(\"text/plain; charset=utf-8\");\n}\n\nstatic int getrange(struct mg_str *s, int64_t *a, int64_t *b) {\n  size_t i, numparsed = 0;\n  // MG_INFO((\"%.*s\", (int) s->len, s->ptr));\n  for (i = 0; i + 6 < s->len; i++) {\n    if (memcmp(&s->ptr[i], \"bytes=\", 6) == 0) {\n      struct mg_str p = mg_str_n(s->ptr + i + 6, s->len - i - 6);\n      if (p.len > 0 && p.ptr[0] >= '0' && p.ptr[0] <= '9') numparsed++;\n      *a = mg_to64(p);\n      // MG_INFO((\"PPP [%.*s] %d\", (int) p.len, p.ptr, numparsed));\n      while (p.len && p.ptr[0] >= '0' && p.ptr[0] <= '9') p.ptr++, p.len--;\n      if (p.len && p.ptr[0] == '-') p.ptr++, p.len--;\n      *b = mg_to64(p);\n      if (p.len > 0 && p.ptr[0] >= '0' && p.ptr[0] <= '9') numparsed++;\n      // MG_INFO((\"PPP [%.*s] %d\", (int) p.len, p.ptr, numparsed));\n      break;\n    }\n  }\n  return (int) numparsed;\n}\n\nvoid mg_http_serve_file(struct mg_connection *c, struct mg_http_message *hm,\n                        const char *path,\n                        const struct mg_http_serve_opts *opts) {\n  char etag[64], tmp[MG_PATH_MAX];\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct mg_fd *fd = NULL;\n  size_t size = 0;\n  time_t mtime = 0;\n  struct mg_str *inm = NULL;\n  struct mg_str mime = guess_content_type(mg_str(path), opts->mime_types);\n  bool gzip = false;\n\n  if (path != NULL) {\n    // If a browser sends us \"Accept-Encoding: gzip\", try to open .gz first\n    struct mg_str *ae = mg_http_get_header(hm, \"Accept-Encoding\");\n    if (ae != NULL && mg_strstr(*ae, mg_str(\"gzip\")) != NULL) {\n      mg_snprintf(tmp, sizeof(tmp), \"%s.gz\", path);\n      fd = mg_fs_open(fs, tmp, MG_FS_READ);\n      if (fd != NULL) gzip = true, path = tmp;\n    }\n    // No luck opening .gz? Open what we've told to open\n    if (fd == NULL) fd = mg_fs_open(fs, path, MG_FS_READ);\n  }\n\n  // Failed to open, and page404 is configured? Open it, then\n  if (fd == NULL && opts->page404 != NULL) {\n    fd = mg_fs_open(fs, opts->page404, MG_FS_READ);\n    mime = guess_content_type(mg_str(path), opts->mime_types);\n    path = opts->page404;\n  }\n\n  if (fd == NULL || fs->st(path, &size, &mtime) == 0) {\n    mg_http_reply(c, 404, opts->extra_headers, \"Not found\\n\");\n    mg_fs_close(fd);\n    // NOTE: mg_http_etag() call should go first!\n  } else if (mg_http_etag(etag, sizeof(etag), size, mtime) != NULL &&\n             (inm = mg_http_get_header(hm, \"If-None-Match\")) != NULL &&\n             mg_vcasecmp(inm, etag) == 0) {\n    mg_fs_close(fd);\n    mg_http_reply(c, 304, opts->extra_headers, \"\");\n  } else {\n    int n, status = 200;\n    char range[100];\n    int64_t r1 = 0, r2 = 0, cl = (int64_t) size;\n\n    // Handle Range header\n    struct mg_str *rh = mg_http_get_header(hm, \"Range\");\n    range[0] = '\\0';\n    if (rh != NULL && (n = getrange(rh, &r1, &r2)) > 0 && r1 >= 0 && r2 >= 0) {\n      // If range is specified like \"400-\", set second limit to content len\n      if (n == 1) r2 = cl - 1;\n      if (r1 > r2 || r2 >= cl) {\n        status = 416;\n        cl = 0;\n        mg_snprintf(range, sizeof(range), \"Content-Range: bytes */%lld\\r\\n\",\n                    (int64_t) size);\n      } else {\n        status = 206;\n        cl = r2 - r1 + 1;\n        mg_snprintf(range, sizeof(range),\n                    \"Content-Range: bytes %lld-%lld/%lld\\r\\n\", r1, r1 + cl - 1,\n                    (int64_t) size);\n        fs->sk(fd->fd, (size_t) r1);\n      }\n    }\n    mg_printf(c,\n              \"HTTP/1.1 %d %s\\r\\n\"\n              \"Content-Type: %.*s\\r\\n\"\n              \"Etag: %s\\r\\n\"\n              \"Content-Length: %llu\\r\\n\"\n              \"%s%s%s\\r\\n\",\n              status, mg_http_status_code_str(status), (int) mime.len, mime.ptr,\n              etag, cl, gzip ? \"Content-Encoding: gzip\\r\\n\" : \"\", range,\n              opts->extra_headers ? opts->extra_headers : \"\");\n    if (mg_vcasecmp(&hm->method, \"HEAD\") == 0) {\n      c->is_draining = 1;\n      c->is_resp = 0;\n      mg_fs_close(fd);\n    } else {\n      // Track to-be-sent content length at the end of c->data, aligned\n      size_t *clp = (size_t *) &c->data[(sizeof(c->data) - sizeof(size_t)) /\n                                        sizeof(size_t) * sizeof(size_t)];\n      c->pfn = static_cb;\n      c->pfn_data = fd;\n      *clp = (size_t) cl;\n    }\n  }\n}\n\nstruct printdirentrydata {\n  struct mg_connection *c;\n  struct mg_http_message *hm;\n  const struct mg_http_serve_opts *opts;\n  const char *dir;\n};\n\nstatic void printdirentry(const char *name, void *userdata) {\n  struct printdirentrydata *d = (struct printdirentrydata *) userdata;\n  struct mg_fs *fs = d->opts->fs == NULL ? &mg_fs_posix : d->opts->fs;\n  size_t size = 0;\n  time_t t = 0;\n  char path[MG_PATH_MAX], sz[40], mod[40];\n  int flags, n = 0;\n\n  // MG_DEBUG((\"[%s] [%s]\", d->dir, name));\n  if (mg_snprintf(path, sizeof(path), \"%s%c%s\", d->dir, '/', name) >\n      sizeof(path)) {\n    MG_ERROR((\"%s truncated\", name));\n  } else if ((flags = fs->st(path, &size, &t)) == 0) {\n    MG_ERROR((\"%lu stat(%s): %d\", d->c->id, path, errno));\n  } else {\n    const char *slash = flags & MG_FS_DIR ? \"/\" : \"\";\n    if (flags & MG_FS_DIR) {\n      mg_snprintf(sz, sizeof(sz), \"%s\", \"[DIR]\");\n    } else {\n      mg_snprintf(sz, sizeof(sz), \"%lld\", (uint64_t) size);\n    }\n#if defined(MG_HTTP_DIRLIST_TIME_FMT)\n    {\n      char time_str[40];\n      struct tm *time_info = localtime(&t);\n      strftime(time_str, sizeof time_str, \"%Y/%m/%d %H:%M:%S\", time_info);\n      mg_snprintf(mod, sizeof(mod), \"%s\", time_str);\n    }\n#else\n    mg_snprintf(mod, sizeof(mod), \"%lu\", (unsigned long) t);\n#endif\n    n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));\n    mg_printf(d->c,\n              \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"\n              \"<td name=%lu>%s</td><td name=%lld>%s</td></tr>\\n\",\n              n, path, slash, name, slash, (unsigned long) t, mod,\n              flags & MG_FS_DIR ? (int64_t) -1 : (int64_t) size, sz);\n  }\n}\n\nstatic void listdir(struct mg_connection *c, struct mg_http_message *hm,\n                    const struct mg_http_serve_opts *opts, char *dir) {\n  const char *sort_js_code =\n      \"<script>function srt(tb, sc, so, d) {\"\n      \"var tr = Array.prototype.slice.call(tb.rows, 0),\"\n      \"tr = tr.sort(function (a, b) { var c1 = a.cells[sc], c2 = b.cells[sc],\"\n      \"n1 = c1.getAttribute('name'), n2 = c2.getAttribute('name'), \"\n      \"t1 = a.cells[2].getAttribute('name'), \"\n      \"t2 = b.cells[2].getAttribute('name'); \"\n      \"return so * (t1 < 0 && t2 >= 0 ? -1 : t2 < 0 && t1 >= 0 ? 1 : \"\n      \"n1 ? parseInt(n2) - parseInt(n1) : \"\n      \"c1.textContent.trim().localeCompare(c2.textContent.trim())); });\";\n  const char *sort_js_code2 =\n      \"for (var i = 0; i < tr.length; i++) tb.appendChild(tr[i]); \"\n      \"if (!d) window.location.hash = ('sc=' + sc + '&so=' + so); \"\n      \"};\"\n      \"window.onload = function() {\"\n      \"var tb = document.getElementById('tb');\"\n      \"var m = /sc=([012]).so=(1|-1)/.exec(window.location.hash) || [0, 2, 1];\"\n      \"var sc = m[1], so = m[2]; document.onclick = function(ev) { \"\n      \"var c = ev.target.rel; if (c) {if (c == sc) so *= -1; srt(tb, c, so); \"\n      \"sc = c; ev.preventDefault();}};\"\n      \"srt(tb, sc, so, true);\"\n      \"}\"\n      \"</script>\";\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct printdirentrydata d = {c, hm, opts, dir};\n  char tmp[10], buf[MG_PATH_MAX];\n  size_t off, n;\n  int len = mg_url_decode(hm->uri.ptr, hm->uri.len, buf, sizeof(buf), 0);\n  struct mg_str uri = len > 0 ? mg_str_n(buf, (size_t) len) : hm->uri;\n\n  mg_printf(c,\n            \"HTTP/1.1 200 OK\\r\\n\"\n            \"Content-Type: text/html; charset=utf-8\\r\\n\"\n            \"%s\"\n            \"Content-Length:         \\r\\n\\r\\n\",\n            opts->extra_headers == NULL ? \"\" : opts->extra_headers);\n  off = c->send.len;  // Start of body\n  mg_printf(c,\n            \"<!DOCTYPE html><html><head><title>Index of %.*s</title>%s%s\"\n            \"<style>th,td {text-align: left; padding-right: 1em; \"\n            \"font-family: monospace; }</style></head>\"\n            \"<body><h1>Index of %.*s</h1><table cellpadding=\\\"0\\\"><thead>\"\n            \"<tr><th><a href=\\\"#\\\" rel=\\\"0\\\">Name</a></th><th>\"\n            \"<a href=\\\"#\\\" rel=\\\"1\\\">Modified</a></th>\"\n            \"<th><a href=\\\"#\\\" rel=\\\"2\\\">Size</a></th></tr>\"\n            \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\"\n            \"</thead>\"\n            \"<tbody id=\\\"tb\\\">\\n\",\n            (int) uri.len, uri.ptr, sort_js_code, sort_js_code2, (int) uri.len,\n            uri.ptr);\n  mg_printf(c, \"%s\",\n            \"  <tr><td><a href=\\\"..\\\">..</a></td>\"\n            \"<td name=-1></td><td name=-1>[DIR]</td></tr>\\n\");\n\n  fs->ls(dir, printdirentry, &d);\n  mg_printf(c,\n            \"</tbody><tfoot><tr><td colspan=\\\"3\\\"><hr></td></tr></tfoot>\"\n            \"</table><address>Mongoose v.%s</address></body></html>\\n\",\n            MG_VERSION);\n  n = mg_snprintf(tmp, sizeof(tmp), \"%lu\", (unsigned long) (c->send.len - off));\n  if (n > sizeof(tmp)) n = 0;\n  memcpy(c->send.buf + off - 12, tmp, n);  // Set content length\n  c->is_resp = 0;                          // Mark response end\n}\n\n// Resolve requested file into `path` and return its fs->st() result\nstatic int uri_to_path2(struct mg_connection *c, struct mg_http_message *hm,\n                        struct mg_fs *fs, struct mg_str url, struct mg_str dir,\n                        char *path, size_t path_size) {\n  int flags, tmp;\n  // Append URI to the root_dir, and sanitize it\n  size_t n = mg_snprintf(path, path_size, \"%.*s\", (int) dir.len, dir.ptr);\n  if (n > path_size) n = path_size;\n  path[path_size - 1] = '\\0';\n  if (n + 2 < path_size) path[n++] = '/', path[n] = '\\0';\n  mg_url_decode(hm->uri.ptr + url.len, hm->uri.len - url.len, path + n,\n                path_size - n, 0);\n  path[path_size - 1] = '\\0';  // Double-check\n  mg_remove_double_dots(path);\n  n = strlen(path);\n  while (n > 1 && path[n - 1] == '/') path[--n] = 0;  // Trim trailing slashes\n  flags = mg_vcmp(&hm->uri, \"/\") == 0 ? MG_FS_DIR : fs->st(path, NULL, NULL);\n  MG_VERBOSE((\"%lu %.*s -> %s %d\", c->id, (int) hm->uri.len, hm->uri.ptr, path,\n              flags));\n  if (flags == 0) {\n    // Do nothing - let's caller decide\n  } else if ((flags & MG_FS_DIR) && hm->uri.len > 0 &&\n             hm->uri.ptr[hm->uri.len - 1] != '/') {\n    mg_printf(c,\n              \"HTTP/1.1 301 Moved\\r\\n\"\n              \"Location: %.*s/\\r\\n\"\n              \"Content-Length: 0\\r\\n\"\n              \"\\r\\n\",\n              (int) hm->uri.len, hm->uri.ptr);\n    c->is_resp = 0;\n    flags = -1;\n  } else if (flags & MG_FS_DIR) {\n    if (((mg_snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX) > 0 &&\n          (tmp = fs->st(path, NULL, NULL)) != 0) ||\n         (mg_snprintf(path + n, path_size - n, \"/index.shtml\") > 0 &&\n          (tmp = fs->st(path, NULL, NULL)) != 0))) {\n      flags = tmp;\n    } else if ((mg_snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX \".gz\") >\n                    0 &&\n                (tmp = fs->st(path, NULL, NULL)) !=\n                    0)) {  // check for gzipped index\n      flags = tmp;\n      path[n + 1 + strlen(MG_HTTP_INDEX)] =\n          '\\0';  // Remove appended .gz in index file name\n    } else {\n      path[n] = '\\0';  // Remove appended index file name\n    }\n  }\n  return flags;\n}\n\nstatic int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,\n                       const struct mg_http_serve_opts *opts, char *path,\n                       size_t path_size) {\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};\n  while (mg_commalist(&s, &k, &v)) {\n    if (v.len == 0) v = k, k = mg_str(\"/\");\n    if (hm->uri.len < k.len) continue;\n    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;\n    u = k, p = v;\n  }\n  return uri_to_path2(c, hm, fs, u, p, path, path_size);\n}\n\nvoid mg_http_serve_dir(struct mg_connection *c, struct mg_http_message *hm,\n                       const struct mg_http_serve_opts *opts) {\n  char path[MG_PATH_MAX];\n  const char *sp = opts->ssi_pattern;\n  int flags = uri_to_path(c, hm, opts, path, sizeof(path));\n  if (flags < 0) {\n    // Do nothing: the response has already been sent by uri_to_path()\n  } else if (flags & MG_FS_DIR) {\n    listdir(c, hm, opts, path);\n  } else if (flags && sp != NULL &&\n             mg_globmatch(sp, strlen(sp), path, strlen(path))) {\n    mg_http_serve_ssi(c, opts->root_dir, path);\n  } else {\n    mg_http_serve_file(c, hm, path, opts);\n  }\n}\n\nstatic bool mg_is_url_safe(int c) {\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') ||\n         (c >= 'A' && c <= 'Z') || c == '.' || c == '_' || c == '-' || c == '~';\n}\n\nsize_t mg_url_encode(const char *s, size_t sl, char *buf, size_t len) {\n  size_t i, n = 0;\n  for (i = 0; i < sl; i++) {\n    int c = *(unsigned char *) &s[i];\n    if (n + 4 >= len) return 0;\n    if (mg_is_url_safe(c)) {\n      buf[n++] = s[i];\n    } else {\n      buf[n++] = '%';\n      mg_hex(&s[i], 1, &buf[n]);\n      n += 2;\n    }\n  }\n  if (len > 0 && n < len - 1) buf[n] = '\\0';  // Null-terminate the destination\n  if (len > 0) buf[len - 1] = '\\0';           // Always.\n  return n;\n}\n\nvoid mg_http_creds(struct mg_http_message *hm, char *user, size_t userlen,\n                   char *pass, size_t passlen) {\n  struct mg_str *v = mg_http_get_header(hm, \"Authorization\");\n  user[0] = pass[0] = '\\0';\n  if (v != NULL && v->len > 6 && memcmp(v->ptr, \"Basic \", 6) == 0) {\n    char buf[256];\n    int n = mg_base64_decode(v->ptr + 6, (int) v->len - 6, buf);\n    const char *p = (const char *) memchr(buf, ':', n > 0 ? (size_t) n : 0);\n    if (p != NULL) {\n      mg_snprintf(user, userlen, \"%.*s\", (int) (p - buf), buf);\n      mg_snprintf(pass, passlen, \"%.*s\", n - (int) (p - buf) - 1, p + 1);\n    }\n  } else if (v != NULL && v->len > 7 && memcmp(v->ptr, \"Bearer \", 7) == 0) {\n    mg_snprintf(pass, passlen, \"%.*s\", (int) v->len - 7, v->ptr + 7);\n  } else if ((v = mg_http_get_header(hm, \"Cookie\")) != NULL) {\n    struct mg_str t = mg_http_get_header_var(*v, mg_str_n(\"access_token\", 12));\n    if (t.len > 0) mg_snprintf(pass, passlen, \"%.*s\", (int) t.len, t.ptr);\n  } else {\n    mg_http_get_var(&hm->query, \"access_token\", pass, passlen);\n  }\n}\n\nstatic struct mg_str stripquotes(struct mg_str s) {\n  return s.len > 1 && s.ptr[0] == '\"' && s.ptr[s.len - 1] == '\"'\n             ? mg_str_n(s.ptr + 1, s.len - 2)\n             : s;\n}\n\nstruct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v) {\n  size_t i;\n  for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {\n    if (s.ptr[i + v.len] == '=' && memcmp(&s.ptr[i], v.ptr, v.len) == 0) {\n      const char *p = &s.ptr[i + v.len + 1], *b = p, *x = &s.ptr[s.len];\n      int q = p < x && *p == '\"' ? 1 : 0;\n      while (p < x &&\n             (q ? p == b || *p != '\"' : *p != ';' && *p != ' ' && *p != ','))\n        p++;\n      // MG_INFO((\"[%.*s] [%.*s] [%.*s]\", (int) s.len, s.ptr, (int) v.len,\n      // v.ptr, (int) (p - b), b));\n      return stripquotes(mg_str_n(b, (size_t) (p - b + q)));\n    }\n  }\n  return mg_str_n(NULL, 0);\n}\n\nbool mg_http_match_uri(const struct mg_http_message *hm, const char *glob) {\n  return mg_match(hm->uri, mg_str(glob), NULL);\n}\n\nlong mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                    struct mg_fs *fs, const char *path, size_t max_size) {\n  char buf[20] = \"0\";\n  long res = 0, offset;\n  mg_http_get_var(&hm->query, \"offset\", buf, sizeof(buf));\n  offset = strtol(buf, NULL, 0);\n  if (hm->body.len == 0) {\n    mg_http_reply(c, 200, \"\", \"%ld\", res);  // Nothing to write\n  } else {\n    struct mg_fd *fd;\n    size_t current_size = 0;\n    MG_DEBUG((\"%s -> %d bytes @ %ld\", path, (int) hm->body.len, offset));\n    if (offset == 0) fs->rm(path);  // If offset if 0, truncate file\n    fs->st(path, &current_size, NULL);\n    if (offset < 0) {\n      mg_http_reply(c, 400, \"\", \"offset required\");\n      res = -1;\n    } else if (offset > 0 && current_size != (size_t) offset) {\n      mg_http_reply(c, 400, \"\", \"%s: offset mismatch\", path);\n      res = -2;\n    } else if ((size_t) offset + hm->body.len > max_size) {\n      mg_http_reply(c, 400, \"\", \"%s: over max size of %lu\", path,\n                    (unsigned long) max_size);\n      res = -3;\n    } else if ((fd = mg_fs_open(fs, path, MG_FS_WRITE)) == NULL) {\n      mg_http_reply(c, 400, \"\", \"open(%s): %d\", path, errno);\n      res = -4;\n    } else {\n      res = offset + (long) fs->wr(fd->fd, hm->body.ptr, hm->body.len);\n      mg_fs_close(fd);\n      mg_http_reply(c, 200, \"\", \"%ld\", res);\n    }\n  }\n  return res;\n}\n\nint mg_http_status(const struct mg_http_message *hm) {\n  return atoi(hm->uri.ptr);\n}\n\n// If a server sends data to the client using chunked encoding, Mongoose strips\n// off the chunking prefix (hex length and \\r\\n) and suffix (\\r\\n), appends the\n// stripped data to the body, and fires the MG_EV_HTTP_CHUNK event.  When zero\n// chunk is received, we fire MG_EV_HTTP_MSG, and the body already has all\n// chunking prefixes/suffixes stripped.\n//\n// If a server sends data without chunked encoding, we also fire a series of\n// MG_EV_HTTP_CHUNK events for every received piece of data, and then we fire\n// MG_EV_HTTP_MSG event in the end.\n//\n// We track total processed length in the c->pfn_data, which is a void *\n// pointer: we store a size_t value there.\nstatic bool getchunk(struct mg_str s, size_t *prefixlen, size_t *datalen) {\n  size_t i = 0, n;\n  while (i < s.len && s.ptr[i] != '\\r' && s.ptr[i] != '\\n') i++;\n  n = mg_unhexn(s.ptr, i);\n  // MG_INFO((\"%d %d\", (int) (i + n + 4), (int) s.len));\n  if (s.len < i + n + 4) return false;  // Chunk not yet fully buffered\n  if (s.ptr[i] != '\\r' || s.ptr[i + 1] != '\\n') return false;\n  if (s.ptr[i + n + 2] != '\\r' || s.ptr[i + n + 3] != '\\n') return false;\n  *prefixlen = i + 2;\n  *datalen = n;\n  return true;\n}\n\nstatic bool mg_is_chunked(struct mg_http_message *hm) {\n  const char *needle = \"chunked\";\n  struct mg_str *te = mg_http_get_header(hm, \"Transfer-Encoding\");\n  return te != NULL && mg_vcasecmp(te, needle) == 0;\n}\n\nvoid mg_http_delete_chunk(struct mg_connection *c, struct mg_http_message *hm) {\n  size_t ofs = (size_t) (hm->chunk.ptr - (char *) c->recv.buf);\n  mg_iobuf_del(&c->recv, ofs, hm->chunk.len);\n  c->pfn_data = (void *) ((size_t) c->pfn_data | MG_DMARK);\n}\n\nstatic void deliver_chunked_chunks(struct mg_connection *c, size_t hlen,\n                                   struct mg_http_message *hm, bool *next) {\n  //  |  ... headers ... | HEXNUM\\r\\n ..data.. \\r\\n | ......\n  //  +------------------+--------------------------+----\n  //  |      hlen        |           chunk1         | ......\n  char *buf = (char *) &c->recv.buf[hlen], *p = buf;\n  size_t len = c->recv.len - hlen;\n  size_t processed = ((size_t) c->pfn_data) & ~MG_DMARK;\n  size_t mark, pl, dl, del = 0, ofs = 0;\n  bool last = false;\n  if (processed <= len) len -= processed, buf += processed;\n  while (!last && getchunk(mg_str_n(buf + ofs, len - ofs), &pl, &dl)) {\n    size_t saved = c->recv.len;\n    memmove(p + processed, buf + ofs + pl, dl);\n    // MG_INFO((\"P2 [%.*s]\", (int) (processed + dl), p));\n    hm->chunk = mg_str_n(p + processed, dl);\n    mg_call(c, MG_EV_HTTP_CHUNK, hm);\n    ofs += pl + dl + 2, del += pl + 2;  // 2 is for \\r\\n suffix\n    processed += dl;\n    if (c->recv.len != saved) processed -= dl, buf -= dl;\n    // mg_hexdump(c->recv.buf, hlen + processed);\n    last = (dl == 0);\n  }\n  mg_iobuf_del(&c->recv, hlen + processed, del);\n  mark = ((size_t) c->pfn_data) & MG_DMARK;\n  c->pfn_data = (void *) (processed | mark);\n  if (last) {\n    hm->body.len = processed;\n    hm->message.len = hlen + processed;\n    c->pfn_data = NULL;\n    if (mark) mg_iobuf_del(&c->recv, 0, hlen), *next = true;\n    // MG_INFO((\"LAST, mark: %lx\", mark));\n    // mg_hexdump(c->recv.buf, c->recv.len);\n  }\n}\n\nstatic void deliver_normal_chunks(struct mg_connection *c, size_t hlen,\n                                  struct mg_http_message *hm, bool *next) {\n  size_t left, processed = ((size_t) c->pfn_data) & ~MG_DMARK;\n  size_t deleted = ((size_t) c->pfn_data) & MG_DMARK;\n  hm->chunk = mg_str_n((char *) &c->recv.buf[hlen], c->recv.len - hlen);\n  if (processed <= hm->chunk.len && !deleted) {\n    hm->chunk.len -= processed;\n    hm->chunk.ptr += processed;\n  }\n  left = hm->body.len < processed ? 0 : hm->body.len - processed;\n  if (hm->chunk.len > left) hm->chunk.len = left;\n  if (hm->chunk.len > 0) mg_call(c, MG_EV_HTTP_CHUNK, hm);\n  processed += hm->chunk.len;\n  deleted = ((size_t) c->pfn_data) & MG_DMARK;  // Re-evaluate after user call\n  if (processed >= hm->body.len) {              // Last, 0-len chunk\n    hm->chunk.len = 0;                          // Reset length\n    mg_call(c, MG_EV_HTTP_CHUNK, hm);           // Call user handler\n    c->pfn_data = NULL;                         // Reset processed counter\n    if (processed && deleted) mg_iobuf_del(&c->recv, 0, hlen), *next = true;\n  } else {\n    c->pfn_data = (void *) (processed | deleted);  // if it is set\n  }\n}\n\nstatic void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n  if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {\n    struct mg_http_message hm;\n    // mg_hexdump(c->recv.buf, c->recv.len);\n    while (c->recv.buf != NULL && c->recv.len > 0) {\n      bool next = false;\n      int hlen = mg_http_parse((char *) c->recv.buf, c->recv.len, &hm);\n      if (hlen < 0) {\n        mg_error(c, \"HTTP parse:\\n%.*s\", (int) c->recv.len, c->recv.buf);\n        break;\n      }\n      if (c->is_resp) break;           // Response is still generated\n      if (hlen == 0) break;            // Request is not buffered yet\n      if (ev == MG_EV_CLOSE) {         // If client did not set Content-Length\n        hm.message.len = c->recv.len;  // and closes now, deliver a MSG\n        hm.body.len = hm.message.len - (size_t) (hm.body.ptr - hm.message.ptr);\n      }\n      if (mg_is_chunked(&hm)) {\n        deliver_chunked_chunks(c, (size_t) hlen, &hm, &next);\n      } else {\n        deliver_normal_chunks(c, (size_t) hlen, &hm, &next);\n      }\n      if (next) continue;  // Chunks & request were deleted\n      //  Chunk events are delivered. If we have full body, deliver MSG\n      if (c->recv.len < hm.message.len) break;\n      if (c->is_accepted) c->is_resp = 1;  // Start generating response\n      mg_call(c, MG_EV_HTTP_MSG, &hm);     // User handler can clear is_resp\n      mg_iobuf_del(&c->recv, 0, hm.message.len);\n    }\n  }\n  (void) evd, (void) fnd;\n}\n\nstatic void mg_hfn(struct mg_connection *c, int ev, void *ev_data, void *fnd) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    if (mg_http_match_uri(hm, \"/quit\")) {\n      mg_http_reply(c, 200, \"\", \"ok\\n\");\n      c->is_draining = 1;\n      c->data[0] = 'X';\n    } else if (mg_http_match_uri(hm, \"/debug\")) {\n      int level = (int) mg_json_get_long(hm->body, \"$.level\", MG_LL_DEBUG);\n      mg_log_set(level);\n      mg_http_reply(c, 200, \"\", \"Debug level set to %d\\n\", level);\n    } else {\n      mg_http_reply(c, 200, \"\", \"hi\\n\");\n    }\n  } else if (ev == MG_EV_CLOSE) {\n    if (c->data[0] == 'X') *(bool *) fnd = true;\n  }\n}\n\nvoid mg_hello(const char *url) {\n  struct mg_mgr mgr;\n  bool done = false;\n  mg_mgr_init(&mgr);\n  if (mg_http_listen(&mgr, url, mg_hfn, &done) == NULL) done = true;\n  while (done == false) mg_mgr_poll(&mgr, 100);\n  mg_mgr_free(&mgr);\n}\n\nstruct mg_connection *mg_http_connect(struct mg_mgr *mgr, const char *url,\n                                      mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = http_cb;\n  return c;\n}\n\nstruct mg_connection *mg_http_listen(struct mg_mgr *mgr, const char *url,\n                                     mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = http_cb;\n  return c;\n}\n", "#include \"mongoose.h\"\n\n#include \"float.h\"  // For DBL_EPSILON and HUGE_VAL\n#include \"math.h\"\n\nstatic int s_num_tests = 0;\n\n#define ASSERT(expr)                                            \\\n  do {                                                          \\\n    s_num_tests++;                                              \\\n    if (!(expr)) {                                              \\\n      printf(\"FAILURE %s:%d: %s\\n\", __FILE__, __LINE__, #expr); \\\n      abort();                                                  \\\n    }                                                           \\\n  } while (0)\n\n#define FETCH_BUF_SIZE (256 * 1024)\n\n// Important: we use different port numbers for the Windows bug workaround. See\n// https://support.microsoft.com/en-ae/help/3039044/error-10013-wsaeacces-is-returned-when-a-second-bind-to-a-excluded-por\n\nstatic void test_globmatch(void) {\n  ASSERT(mg_globmatch(\"\", 0, \"\", 0) == 1);\n  ASSERT(mg_globmatch(\"*\", 1, \"a\", 1) == 1);\n  ASSERT(mg_globmatch(\"*\", 1, \"ab\", 2) == 1);\n  ASSERT(mg_globmatch(\"\", 0, \"a\", 1) == 0);\n  ASSERT(mg_globmatch(\"/\", 1, \"/foo\", 4) == 0);\n  ASSERT(mg_globmatch(\"/*/foo\", 6, \"/x/bar\", 6) == 0);\n  ASSERT(mg_globmatch(\"/*/foo\", 6, \"/x/foo\", 6) == 1);\n  ASSERT(mg_globmatch(\"/*/foo\", 6, \"/x/foox\", 7) == 0);\n  ASSERT(mg_globmatch(\"/*/foo*\", 7, \"/x/foox\", 7) == 1);\n  ASSERT(mg_globmatch(\"/*\", 2, \"/abc\", 4) == 1);\n  ASSERT(mg_globmatch(\"/*\", 2, \"/ab/\", 4) == 0);\n  ASSERT(mg_globmatch(\"/*\", 2, \"/\", 1) == 1);\n  ASSERT(mg_globmatch(\"/x/*\", 4, \"/x/2\", 4) == 1);\n  ASSERT(mg_globmatch(\"/x/*\", 4, \"/x/2/foo\", 8) == 0);\n  ASSERT(mg_globmatch(\"/x/*/*\", 6, \"/x/2/foo\", 8) == 1);\n  ASSERT(mg_globmatch(\"#\", 1, \"///\", 3) == 1);\n  ASSERT(mg_globmatch(\"/api/*\", 6, \"/api/foo\", 8) == 1);\n  ASSERT(mg_globmatch(\"/api/*\", 6, \"/api/log/static\", 15) == 0);\n  ASSERT(mg_globmatch(\"/api/#\", 6, \"/api/log/static\", 15) == 1);\n  ASSERT(mg_globmatch(\"#.shtml\", 7, \"/ssi/index.shtml\", 16) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \".c\", 2) == 1);\n  ASSERT(mg_globmatch(\"abc\", 3, \"ab\", 2) == 0);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"a.c\", 3) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"..c\", 3) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"/.c\", 3) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"//a.c\", 5) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"x/a.c\", 5) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"./a.c\", 5) == 1);\n  ASSERT(mg_globmatch(\"#.shtml\", 7, \"./ssi/index.shtml\", 17) == 1);\n  ASSERT(mg_globmatch(\"#aa#bb#\", 7, \"caabba\", 6) == 1);\n  ASSERT(mg_globmatch(\"#aa#bb#\", 7, \"caabxa\", 6) == 0);\n  ASSERT(mg_globmatch(\"a*b*c\", 5, \"a__b_c\", 6) == 1);\n\n  {\n    struct mg_str caps[3];\n    ASSERT(mg_match(mg_str(\"//a.c\"), mg_str(\"#.c\"), NULL) == true);\n    ASSERT(mg_match(mg_str(\"a\"), mg_str(\"#\"), caps) == true);\n    ASSERT(mg_strcmp(caps[0], mg_str(\"a\")) == 0);\n    ASSERT(mg_match(mg_str(\"//a.c\"), mg_str(\"#.c\"), caps) == true);\n    ASSERT(mg_match(mg_str(\"a_b_c_\"), mg_str(\"a*b*c\"), caps) == false);\n    ASSERT(mg_match(mg_str(\"a__b_c\"), mg_str(\"a*b*c\"), caps) == true);\n    ASSERT(mg_strcmp(caps[0], mg_str(\"__\")) == 0);\n    ASSERT(mg_strcmp(caps[1], mg_str(\"_\")) == 0);\n    ASSERT(mg_match(mg_str(\"a_b_c__c\"), mg_str(\"a*b*c\"), caps) == true);\n    ASSERT(mg_strcmp(caps[0], mg_str(\"_\")) == 0);\n    ASSERT(mg_strcmp(caps[1], mg_str(\"_c__\")) == 0);\n    ASSERT(mg_match(mg_str(\"a_xb_.c__c\"), mg_str(\"a*b*c\"), caps) == true);\n    ASSERT(mg_strcmp(caps[0], mg_str(\"_x\")) == 0);\n    ASSERT(mg_strcmp(caps[1], mg_str(\"_.c__\")) == 0);\n    ASSERT(mg_match(mg_str(\"a\"), mg_str(\"#a\"), caps) == true);\n    ASSERT(mg_strcmp(caps[0], mg_str(\"\")) == 0);\n\n    ASSERT(mg_match(mg_str(\".aa..b...b\"), mg_str(\"#a#b\"), caps) == true);\n    ASSERT(mg_strcmp(caps[0], mg_str(\".\")) == 0);\n    ASSERT(mg_strcmp(caps[1], mg_str(\"a..b...\")) == 0);\n    ASSERT(mg_strcmp(caps[2], mg_str(\"\")) == 0);\n\n    ASSERT(mg_match(mg_str(\"/foo/bar\"), mg_str(\"/*/*\"), caps) == true);\n    ASSERT(mg_strcmp(caps[0], mg_str(\"foo\")) == 0);\n    ASSERT(mg_strcmp(caps[1], mg_str(\"bar\")) == 0);\n    ASSERT(mg_strcmp(caps[2], mg_str(\"\")) == 0);\n\n    ASSERT(mg_match(mg_str(\"/foo/\"), mg_str(\"/*/*\"), caps) == true);\n    ASSERT(mg_strcmp(caps[0], mg_str(\"foo\")) == 0);\n    ASSERT(mg_strcmp(caps[1], mg_str(\"\")) == 0);\n    ASSERT(mg_strcmp(caps[2], mg_str(\"\")) == 0);\n\n    ASSERT(mg_match(mg_str(\"abc\"), mg_str(\"?#\"), caps) == true);\n    ASSERT(mg_strcmp(caps[0], mg_str(\"a\")) == 0);\n    ASSERT(mg_strcmp(caps[1], mg_str(\"bc\")) == 0);\n    ASSERT(mg_strcmp(caps[2], mg_str(\"\")) == 0);\n  }\n}\n\nstatic void test_commalist(void) {\n  struct mg_str k, v, s1 = mg_str(\"\"), s2 = mg_str(\"a\"), s3 = mg_str(\"a,b\");\n  struct mg_str s4 = mg_str(\"a=123\"), s5 = mg_str(\"a,b=123\");\n  ASSERT(mg_commalist(&s1, &k, &v) == false);\n\n  ASSERT(mg_commalist(&s2, &k, &v) == true);\n  ASSERT(v.len == 0 && mg_vcmp(&k, \"a\") == 0);\n  ASSERT(mg_commalist(&s2, &k, &v) == false);\n\n  ASSERT(mg_commalist(&s3, &k, &v) == true);\n  ASSERT(v.len == 0 && mg_vcmp(&k, \"a\") == 0);\n  ASSERT(mg_commalist(&s3, &k, &v) == true);\n  ASSERT(v.len == 0 && mg_vcmp(&k, \"b\") == 0);\n  ASSERT(mg_commalist(&s3, &k, &v) == false);\n\n  ASSERT(mg_commalist(&s4, &k, &v) == true);\n  ASSERT(mg_vcmp(&k, \"a\") == 0 && mg_vcmp(&v, \"123\") == 0);\n  ASSERT(mg_commalist(&s4, &k, &v) == false);\n  ASSERT(mg_commalist(&s4, &k, &v) == false);\n\n  ASSERT(mg_commalist(&s5, &k, &v) == true);\n  ASSERT(v.len == 0 && mg_vcmp(&k, \"a\") == 0);\n  ASSERT(mg_commalist(&s5, &k, &v) == true);\n  ASSERT(mg_vcmp(&k, \"b\") == 0 && mg_vcmp(&v, \"123\") == 0);\n  ASSERT(mg_commalist(&s4, &k, &v) == false);\n}\n\nstatic void test_http_get_var(void) {\n  char buf[256];\n  struct mg_str body;\n  body = mg_str(\"key1=value1&key2=value2&key3=value%203&key4=value+4\");\n  ASSERT(mg_http_get_var(&body, \"key1\", buf, sizeof(buf)) == 6);\n  ASSERT(strcmp(buf, \"value1\") == 0);\n  ASSERT(mg_http_get_var(&body, \"KEY1\", buf, sizeof(buf)) == 6);\n  ASSERT(strcmp(buf, \"value1\") == 0);\n  ASSERT(mg_http_get_var(&body, \"key2\", buf, sizeof(buf)) == 6);\n  ASSERT(strcmp(buf, \"value2\") == 0);\n  ASSERT(mg_http_get_var(&body, \"key3\", buf, sizeof(buf)) == 7);\n  ASSERT(strcmp(buf, \"value 3\") == 0);\n  ASSERT(mg_http_get_var(&body, \"key4\", buf, sizeof(buf)) == 7);\n  ASSERT(strcmp(buf, \"value 4\") == 0);\n\n  ASSERT(mg_http_get_var(&body, \"key\", buf, sizeof(buf)) == -4);\n  ASSERT(mg_http_get_var(&body, \"key1\", NULL, sizeof(buf)) == -2);\n  ASSERT(mg_http_get_var(&body, \"key1\", buf, 0) == -2);\n  ASSERT(mg_http_get_var(&body, NULL, buf, sizeof(buf)) == -1);\n  ASSERT(mg_http_get_var(&body, \"key1\", buf, 1) == -3);\n\n  body = mg_str(\"key=broken%2\");\n  ASSERT(mg_http_get_var(&body, \"key\", buf, sizeof(buf)) == -3);\n\n  body = mg_str(\"key=broken%2x\");\n  ASSERT(mg_http_get_var(&body, \"key\", buf, sizeof(buf)) == -3);\n  ASSERT(mg_http_get_var(&body, \"inexistent\", buf, sizeof(buf)) == -4);\n  body = mg_str(\"key=%\");\n  ASSERT(mg_http_get_var(&body, \"key\", buf, sizeof(buf)) == -3);\n  body = mg_str(\"&&&kEy=%\");\n  ASSERT(mg_http_get_var(&body, \"kEy\", buf, sizeof(buf)) == -3);\n}\n\nstatic int vcmp(struct mg_str s1, const char *s2) {\n  // MG_INFO((\"->%.*s<->%s<- %d %d %d\", (int) s1.len, s1.ptr, s2,\n  //(int) s1.len, strncmp(s1.ptr, s2, s1.len), mg_vcmp(&s1, s2)));\n  return mg_vcmp(&s1, s2) == 0;\n}\n\nstatic void test_url(void) {\n  // Host\n  ASSERT(vcmp(mg_url_host(\"foo\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"//foo\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"foo:1234\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\":1234\"), \"\"));\n  ASSERT(vcmp(mg_url_host(\"//foo:1234\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo/\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo/x\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo/x/\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo/x//\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo//x\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo///x\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo///x//\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://bar:1234\"), \"bar\"));\n  ASSERT(vcmp(mg_url_host(\"p://bar:1234/\"), \"bar\"));\n  ASSERT(vcmp(mg_url_host(\"p://bar:1234/a\"), \"bar\"));\n  ASSERT(vcmp(mg_url_host(\"p://u@bar:1234/a\"), \"bar\"));\n  ASSERT(vcmp(mg_url_host(\"p://u:p@bar:1234/a\"), \"bar\"));\n  ASSERT(vcmp(mg_url_host(\"p://u:p@[::1]:1234/a\"), \"[::1]\"));\n  ASSERT(vcmp(mg_url_host(\"p://u:p@[1:2::3]:1234/a\"), \"[1:2::3]\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo/x:y/z\"), \"foo\"));\n\n  // Port\n  ASSERT(mg_url_port(\"foo:1234\") == 1234);\n  ASSERT(mg_url_port(\":1234\") == 1234);\n  ASSERT(mg_url_port(\"x://foo:1234\") == 1234);\n  ASSERT(mg_url_port(\"x://foo:1234/\") == 1234);\n  ASSERT(mg_url_port(\"x://foo:1234/xx\") == 1234);\n  ASSERT(mg_url_port(\"x://foo:1234\") == 1234);\n  ASSERT(mg_url_port(\"p://bar:1234/a\") == 1234);\n  ASSERT(mg_url_port(\"p://bar:1234/a:b\") == 1234);\n  ASSERT(mg_url_port(\"http://bar\") == 80);\n  ASSERT(mg_url_port(\"http://localhost:1234\") == 1234);\n  ASSERT(mg_url_port(\"https://bar\") == 443);\n  ASSERT(mg_url_port(\"wss://bar\") == 443);\n  ASSERT(mg_url_port(\"wss://u:p@bar\") == 443);\n  ASSERT(mg_url_port(\"wss://u:p@bar:123\") == 123);\n  ASSERT(mg_url_port(\"wss://u:p@bar:123/\") == 123);\n  ASSERT(mg_url_port(\"wss://u:p@bar:123/abc\") == 123);\n  ASSERT(mg_url_port(\"http://u:p@[::1]/abc\") == 80);\n  ASSERT(mg_url_port(\"http://u:p@[::1]:2121/abc\") == 2121);\n  ASSERT(mg_url_port(\"http://u:p@[::1]:2121/abc/cd:ef\") == 2121);\n\n  // User / pass\n  ASSERT(vcmp(mg_url_user(\"p://foo\"), \"\"));\n  ASSERT(vcmp(mg_url_pass(\"p://foo\"), \"\"));\n  ASSERT(vcmp(mg_url_user(\"p://:@foo\"), \"\"));\n  ASSERT(vcmp(mg_url_pass(\"p://:@foo\"), \"\"));\n  ASSERT(vcmp(mg_url_user(\"p://u@foo\"), \"u\"));\n  ASSERT(vcmp(mg_url_pass(\"p://u@foo\"), \"\"));\n  ASSERT(vcmp(mg_url_user(\"p://u:@foo\"), \"u\"));\n  ASSERT(vcmp(mg_url_pass(\"p://u:@foo\"), \"\"));\n  ASSERT(vcmp(mg_url_user(\"p://:p@foo\"), \"\"));\n  ASSERT(vcmp(mg_url_pass(\"p://:p@foo\"), \"p\"));\n  ASSERT(vcmp(mg_url_user(\"p://u:p@foo\"), \"u\"));\n  ASSERT(vcmp(mg_url_pass(\"p://u:p@foo\"), \"p\"));\n  ASSERT(vcmp(mg_url_pass(\"p://u:p@foo//a@b\"), \"p\"));\n  ASSERT(vcmp(mg_url_user(\"p://foo/q?mail=a@b.c\"), \"\"));\n  ASSERT(vcmp(mg_url_pass(\"p://foo/q?mail=a@b.c\"), \"\"));\n\n  // URI\n  ASSERT(strcmp(mg_url_uri(\"p://foo\"), \"/\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://foo/\"), \"/\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://foo:12/\"), \"/\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://foo:12/abc\"), \"/abc\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://foo:12/a/b/c\"), \"/a/b/c\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://[::1]:12/a/b/c\"), \"/a/b/c\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://[ab::1]:12/a/b/c\"), \"/a/b/c\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://foo/q?mail=a@b.c\"), \"/q?mail=a@b.c\") == 0);\n}\n\nstatic void test_base64(void) {\n  char buf[128];\n\n  ASSERT(mg_base64_encode((uint8_t *) \"\", 0, buf) == 0);\n  ASSERT(strcmp(buf, \"\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"x\", 1, buf) == 4);\n  ASSERT(strcmp(buf, \"eA==\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"xyz\", 3, buf) == 4);\n  ASSERT(strcmp(buf, \"eHl6\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"abcdef\", 6, buf) == 8);\n  ASSERT(strcmp(buf, \"YWJjZGVm\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"\u044b\", 2, buf) == 4);\n  ASSERT(strcmp(buf, \"0Ys=\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"xy\", 3, buf) == 4);\n  ASSERT(strcmp(buf, \"eHkA\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"test\", 4, buf) == 8);\n  ASSERT(strcmp(buf, \"dGVzdA==\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"abcde\", 5, buf) == 8);\n  ASSERT(strcmp(buf, \"YWJjZGU=\") == 0);\n\n  ASSERT(mg_base64_decode(\"\u043a\u044e\", 4, buf) == 0);\n  ASSERT(mg_base64_decode(\"A\", 1, buf) == 0);\n  ASSERT(mg_base64_decode(\"A=\", 2, buf) == 0);\n  ASSERT(mg_base64_decode(\"AA=\", 3, buf) == 0);\n  ASSERT(mg_base64_decode(\"AAA=\", 4, buf) == 2);\n  ASSERT(mg_base64_decode(\"AAAA====\", 8, buf) == 0);\n  ASSERT(mg_base64_decode(\"AAAA----\", 8, buf) == 0);\n  ASSERT(mg_base64_decode(\"Q2VzYW50YQ==\", 12, buf) == 7);\n  ASSERT(strcmp(buf, \"Cesanta\") == 0);\n}\n\nstatic void test_iobuf(void) {\n  struct mg_iobuf io = {0, 0, 0, 10};\n  ASSERT(io.buf == NULL && io.size == 0 && io.len == 0);\n  mg_iobuf_resize(&io, 1);\n  ASSERT(io.buf != NULL && io.size == 10 && io.len == 0);\n  ASSERT(memcmp(io.buf, \"\\x00\", 1) == 0);\n  mg_iobuf_add(&io, 3, \"hi\", 2);\n  ASSERT(io.buf != NULL && io.size == 10 && io.len == 5);\n  ASSERT(memcmp(io.buf, \"\\x00\\x00\\x00hi\", 5) == 0);\n  mg_iobuf_add(&io, io.len, \"!\", 1);\n  ASSERT(io.buf != NULL && io.size == 10 && io.len == 6);\n  ASSERT(memcmp(io.buf, \"\\x00\\x00\\x00hi!\", 6) == 0);\n  mg_iobuf_add(&io, 0, \"x\", 1);\n  ASSERT(memcmp(io.buf, \"x\\x00\\x00\\x00hi!\", 7) == 0);\n  ASSERT(io.buf != NULL && io.size == 10 && io.len == 7);\n  mg_iobuf_del(&io, 1, 3);\n  ASSERT(io.buf != NULL && io.size == 10 && io.len == 4);\n  ASSERT(memcmp(io.buf, \"xhi!\", 3) == 0);\n  mg_iobuf_del(&io, 10, 100);\n  ASSERT(io.buf != NULL && io.size == 10 && io.len == 4);\n  ASSERT(memcmp(io.buf, \"xhi!\", 3) == 0);\n  free(io.buf);\n}\n\nstatic void sntp_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n  if (ev == MG_EV_SNTP_TIME) {\n    int64_t received = *(int64_t *) evd;\n    *(int64_t *) fnd = received;\n    MG_DEBUG((\"got time: %lld\", received));\n#if MG_ARCH == MG_ARCH_UNIX\n    struct timeval tv = {0, 0};\n    gettimeofday(&tv, 0);\n    int64_t ms = (int64_t) tv.tv_sec * 1000 + tv.tv_usec / 1000;\n    int64_t diff = ms > received ? ms - received : received - ms;\n    MG_DEBUG((\"diff: %lld\", diff));\n    // ASSERT(diff < 100);\n#endif\n  } else if (ev == MG_EV_OPEN) {\n    c->is_hexdumping = 1;\n  }\n  (void) c;\n}\n\nstatic void test_sntp_server(const char *url) {\n  int64_t ms = 0;\n  struct mg_mgr mgr;\n  struct mg_connection *c = NULL;\n  int i;\n\n  mg_mgr_init(&mgr);\n  c = mg_sntp_connect(&mgr, url, sntp_cb, &ms);\n  ASSERT(c != NULL);\n  ASSERT(c->is_udp == 1);\n  for (i = 0; i < 60 && ms == 0; i++) mg_mgr_poll(&mgr, 50);\n  MG_DEBUG((\"server: %s, ms: %lld\", url ? url : \"(default)\", ms));\n#if !defined(NO_SNTP_CHECK)\n  ASSERT(ms > 0);\n#endif\n  mg_mgr_free(&mgr);\n}\n\nstatic void test_sntp(void) {\n  const unsigned char bad[] =\n      \"\\x55\\x02\\x00\\xeb\\x00\\x00\\x00\\x1e\\x00\\x00\\x07\\xb6\\x3e\\xc9\\xd6\\xa2\"\n      \"\\xdb\\xde\\xea\\x30\\x91\\x86\\xb7\\x10\\xdb\\xde\\xed\\x98\\x00\\x00\\x00\\xde\"\n      \"\\xdb\\xde\\xed\\x99\\x0a\\xe2\\xc7\\x96\\xdb\\xde\\xed\\x99\\x0a\\xe4\\x6b\\xda\";\n\n  ASSERT(mg_sntp_parse(bad, sizeof(bad)) < 0);\n  ASSERT(mg_sntp_parse(NULL, 0) == -1);\n  // NOTE(cpq): temporarily disabled until Github Actions fix their NTP\n  // port blockage issue, https://github.com/actions/runner-images/issues/5615\n  // test_sntp_server(\"udp://time.apple.com:123\");\n  test_sntp_server(\"udp://time.windows.com:123\");\n  test_sntp_server(NULL);\n}\n\nstruct mqtt_data {\n  char *buf;\n  size_t bufsize;\n  int subscribed;\n  int published;\n};\n\nstatic void mqtt_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n  struct mqtt_data *test_data = (struct mqtt_data *) fnd;\n  char *buf = test_data->buf;\n\n  if (ev == MG_EV_MQTT_OPEN) {\n    buf[0] = *(int *) evd == 0 ? 'X' : 'Y';\n  } else if (ev == MG_EV_MQTT_CMD) {\n    struct mg_mqtt_message *mm = (struct mg_mqtt_message *) evd;\n    if (mm->cmd == MQTT_CMD_SUBACK) {\n      test_data->subscribed = 1;\n    }\n    if (mm->cmd == MQTT_CMD_PUBACK) {\n      test_data->published = 1;\n    }\n  } else if (ev == MG_EV_MQTT_MSG) {\n    struct mg_mqtt_message *mm = (struct mg_mqtt_message *) evd;\n    snprintf(buf + 1, test_data->bufsize, \"%.*s/%.*s\", (int) mm->topic.len,\n             mm->topic.ptr, (int) mm->data.len, mm->data.ptr);\n\n    if (mm->cmd == MQTT_CMD_PUBLISH && c->is_mqtt5) {\n      size_t pos = 0;\n      struct mg_mqtt_prop prop;\n\n      // note: the server will send the properties sorted by their ID\n      ASSERT((pos = mg_mqtt_next_prop(mm, &prop, pos)) > 0);\n      ASSERT(prop.iv == 10 && prop.id == MQTT_PROP_MESSAGE_EXPIRY_INTERVAL);\n\n      ASSERT((pos = mg_mqtt_next_prop(mm, &prop, pos)) > 0);\n      ASSERT(prop.id == MQTT_PROP_CONTENT_TYPE);\n      ASSERT(strncmp(prop.val.ptr, \"test_content_val_2\", prop.val.len) == 0 &&\n             prop.val.len == strlen(\"test_content_val_2\"));\n\n      ASSERT((pos = mg_mqtt_next_prop(mm, &prop, pos)) > 0);\n      ASSERT(prop.id == MQTT_PROP_USER_PROPERTY);\n      ASSERT(strncmp(prop.key.ptr, \"test_key_1\", prop.key.len) == 0 &&\n             prop.key.len == strlen(\"test_key_1\"));\n      ASSERT(strncmp(prop.val.ptr, \"test_value_1\", prop.val.len) == 0 &&\n             prop.val.len == strlen(\"test_value_1\"));\n\n      ASSERT((pos = mg_mqtt_next_prop(mm, &prop, pos)) > 0);\n      ASSERT(prop.id == MQTT_PROP_USER_PROPERTY);\n      ASSERT(strncmp(prop.key.ptr, \"test_key_2\", prop.key.len) == 0 &&\n             prop.key.len == strlen(\"test_key_2\"));\n      ASSERT(strncmp(prop.val.ptr, \"test_value_2\", prop.val.len) == 0 &&\n             prop.val.len == strlen(\"test_value_2\"));\n\n      ASSERT((pos = mg_mqtt_next_prop(mm, &prop, pos)) == 0);\n    }\n  }\n  (void) c;\n}\n\nstatic void construct_props(struct mg_mqtt_prop *props) {\n  props[0].id = MQTT_PROP_MESSAGE_EXPIRY_INTERVAL;\n  props[0].iv = 10;\n\n  props[1].id = MQTT_PROP_USER_PROPERTY;\n  props[1].key = mg_str(\"test_key_1\");\n  props[1].val = mg_str(\"test_value_1\");\n\n  props[2].id = MQTT_PROP_USER_PROPERTY;\n  props[2].key = mg_str(\"test_key_2\");\n  props[2].val = mg_str(\"test_value_2\");\n\n  props[3].id = MQTT_PROP_CONTENT_TYPE;\n  props[3].val = mg_str(\"test_content_val_2\");\n}\n\nstatic void test_mqtt_base(void);\nstatic void test_mqtt_base(void) {\n  char buf[50] = {0};\n  struct mqtt_data test_data = {buf, 50, 0, 0};\n  struct mg_mgr mgr;\n  struct mg_connection *c;\n  const char *url = \"mqtt://broker.hivemq.com:1883\";\n  int i;\n  mg_mgr_init(&mgr);\n\n  // Ping the client\n  c = mg_mqtt_connect(&mgr, url, NULL, mqtt_cb, &test_data);\n  mg_mqtt_ping(c);\n  for (i = 0; i < 300 && !(c->is_client && !c->is_connecting); i++)\n    mg_mgr_poll(&mgr, 10);\n  ASSERT(c->is_client && !c->is_connecting);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_mqtt_ver(uint8_t mqtt_version) {\n  char buf[50] = {0}, client_id[16], will_topic[16];\n  struct mqtt_data test_data = {buf, 50, 0, 0};\n  struct mg_mgr mgr;\n  struct mg_str topic = mg_str(\"x/f12\"), data = mg_str(\"hi\");\n  struct mg_connection *c;\n  struct mg_mqtt_opts opts;\n  struct mg_mqtt_prop properties[4];\n  const char *url = \"mqtt://broker.hivemq.com:1883\";\n  int i;\n  mg_mgr_init(&mgr);\n\n  // Connect with empty client ID\n  c = mg_mqtt_connect(&mgr, url, NULL, mqtt_cb, &test_data);\n  for (i = 0; i < 300 && buf[0] == 0; i++) mg_mgr_poll(&mgr, 10);\n  if (buf[0] != 'X') MG_INFO((\"[%s]\", buf));\n  ASSERT(buf[0] == 'X');\n  ASSERT(test_data.subscribed == 0);\n\n  opts.topic = topic, opts.qos = 1;\n  mg_mqtt_sub(c, &opts);\n  for (i = 0; i < 500 && test_data.subscribed == 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(test_data.subscribed == 1);\n  ASSERT(test_data.published == 0);\n\n  opts.topic = topic, opts.message = data, opts.qos = 1, opts.retain = false;\n  mg_mqtt_pub(c, &opts);\n  for (i = 0; i < 500 && test_data.published == 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(test_data.published == 1);\n  for (i = 0; i < 500 && buf[1] == 0; i++) mg_mgr_poll(&mgr, 10);\n  if (strcmp(buf, \"Xx/f12/hi\") != 0) MG_INFO((\"[%s]\", buf));\n  ASSERT(strcmp(buf, \"Xx/f12/hi\") == 0);\n\n  // Set params\n  test_data.subscribed = 0;\n  test_data.published = 0;\n  memset(buf, 0, sizeof(buf));\n  memset(&opts, 0, sizeof(opts));\n\n  opts.clean = true, opts.qos = 1, opts.retain = true, opts.keepalive = 20;\n  opts.version = mqtt_version;\n  opts.topic = mg_str(mg_random_str(will_topic, sizeof(will_topic)));\n  opts.message = mg_str(\"mg_will_messsage\");\n  opts.client_id = mg_str(mg_random_str(client_id, sizeof(client_id)));\n  c = mg_mqtt_connect(&mgr, url, &opts, mqtt_cb, &test_data);\n  for (i = 0; i < 300 && buf[0] == 0; i++) mg_mgr_poll(&mgr, 10);\n  if (buf[0] != 'X') MG_INFO((\"[%s]\", buf));\n  ASSERT(buf[0] == 'X');\n  ASSERT(test_data.subscribed == 0);\n\n  opts.topic = topic, opts.qos = 1;\n  mg_mqtt_sub(c, &opts);\n  for (i = 0; i < 500 && test_data.subscribed == 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(test_data.subscribed == 1);\n  ASSERT(test_data.published == 0);\n\n  opts.topic = topic, opts.message = data, opts.qos = 1, opts.retain = false;\n  if (mqtt_version == 5) {\n    opts.props = properties;\n    opts.num_props = 4;\n    construct_props(properties);\n  }\n\n  mg_mqtt_pub(c, &opts);\n  for (i = 0; i < 500 && test_data.published == 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(test_data.published == 1);\n  for (i = 0; i < 500 && buf[1] == 0; i++) mg_mgr_poll(&mgr, 10);\n  if (strcmp(buf, \"Xx/f12/hi\") != 0) MG_INFO((\"[%s]\", buf));\n  ASSERT(strcmp(buf, \"Xx/f12/hi\") == 0);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_mqtt(void) {\n  test_mqtt_base();\n  test_mqtt_ver(4);\n  test_mqtt_ver(5);\n  test_mqtt_base();\n}\n\nstatic void eh1(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  struct mg_tls_opts *topts = (struct mg_tls_opts *) fn_data;\n  if (ev == MG_EV_ACCEPT && topts != NULL) mg_tls_init(c, topts);\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    MG_INFO((\"[%.*s %.*s] message len %d\", (int) hm->method.len, hm->method.ptr,\n             (int) hm->uri.len, hm->uri.ptr, (int) hm->message.len));\n    if (mg_http_match_uri(hm, \"/foo/*\")) {\n      mg_http_reply(c, 200, \"\", \"uri: %.*s\", hm->uri.len - 5, hm->uri.ptr + 5);\n    } else if (mg_http_match_uri(hm, \"/ws\")) {\n      mg_ws_upgrade(c, hm, NULL);\n    } else if (mg_http_match_uri(hm, \"/body\")) {\n      mg_http_reply(c, 200, \"\", \"%.*s\", (int) hm->body.len, hm->body.ptr);\n    } else if (mg_http_match_uri(hm, \"/bar\")) {\n      mg_http_reply(c, 404, \"\", \"not found\");\n    } else if (mg_http_match_uri(hm, \"/no_reason\")) {\n      mg_printf(c, \"%s\", \"HTTP/1.0 200\\r\\nContent-Length: 2\\r\\n\\r\\nok\");\n    } else if (mg_http_match_uri(hm, \"/badroot\")) {\n      struct mg_http_serve_opts sopts;\n      memset(&sopts, 0, sizeof(sopts));\n      sopts.root_dir = \"/BAAADDD!\";\n      mg_http_serve_dir(c, hm, &sopts);\n    } else if (mg_http_match_uri(hm, \"/creds\")) {\n      char user[100], pass[100];\n      mg_http_creds(hm, user, sizeof(user), pass, sizeof(pass));\n      mg_http_reply(c, 200, \"\", \"[%s]:[%s]\", user, pass);\n    } else if (mg_http_match_uri(hm, \"/upload\")) {\n      char path[80], name[64];\n      mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n      if (name[0] == '\\0') {\n        mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n      } else {\n        mg_snprintf(path, sizeof(path), \"./%s\", name);\n        mg_http_upload(c, hm, &mg_fs_posix, mg_remove_double_dots(path), 99999);\n        c->is_hexdumping = 1;\n      }\n    } else if (mg_http_match_uri(hm, \"/test/\")) {\n      struct mg_http_serve_opts sopts;\n      memset(&sopts, 0, sizeof(sopts));\n      sopts.root_dir = \".\";\n      sopts.extra_headers = \"A: B\\r\\nC: D\\r\\n\";\n      mg_http_serve_dir(c, hm, &sopts);\n    } else if (mg_http_match_uri(hm, \"/servefile\")) {\n      struct mg_http_serve_opts sopts;\n      memset(&sopts, 0, sizeof(sopts));\n      sopts.mime_types = \"foo=a/b,txt=c/d\";\n      mg_http_serve_file(c, hm, \"test/data/a.txt\", &sopts);\n    } else {\n      struct mg_http_serve_opts sopts;\n      memset(&sopts, 0, sizeof(sopts));\n      sopts.root_dir = \"./test/data\";\n      sopts.ssi_pattern = \"#.shtml\";\n      sopts.extra_headers = \"C: D\\r\\n\";\n      mg_http_serve_dir(c, hm, &sopts);\n    }\n  } else if (ev == MG_EV_WS_OPEN) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    ASSERT(mg_strcmp(hm->uri, mg_str(\"/ws\")) == 0);\n    mg_ws_send(c, \"opened\", 6, WEBSOCKET_OP_BINARY);\n  } else if (ev == MG_EV_WS_MSG) {\n    struct mg_ws_message *wm = (struct mg_ws_message *) ev_data;\n    mg_ws_send(c, wm->data.ptr, wm->data.len, WEBSOCKET_OP_BINARY);\n  }\n}\n\nstruct fetch_data {\n  char *buf;\n  int code, closed;\n};\n\nstatic void fcb(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  struct fetch_data *fd = (struct fetch_data *) fn_data;\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    snprintf(fd->buf, FETCH_BUF_SIZE, \"%.*s\", (int) hm->message.len,\n             hm->message.ptr);\n    fd->code = atoi(hm->uri.ptr);\n    fd->closed = 1;\n    c->is_closing = 1;\n    (void) c;\n  } else if (ev == MG_EV_CLOSE) {\n    fd->closed = 1;\n  }\n}\n\nstatic int fetch(struct mg_mgr *mgr, char *buf, const char *url,\n                 const char *fmt, ...) {\n  struct fetch_data fd = {buf, 0, 0};\n  int i;\n  struct mg_connection *c = mg_http_connect(mgr, url, fcb, &fd);\n  va_list ap;\n  ASSERT(c != NULL);\n  if (mg_url_is_ssl(url)) {\n    struct mg_tls_opts opts;\n    struct mg_str host = mg_url_host(url);\n    memset(&opts, 0, sizeof(opts));\n    opts.ca = \"./test/data/ca.pem\";\n    if (strstr(url, \"127.0.0.1\") != NULL) {\n      // Local connection, use self-signed certificates\n      opts.ca = \"./test/data/ss_ca.pem\";\n      opts.cert = \"./test/data/ss_client.pem\";\n    } else {\n      opts.srvname = host;\n    }\n    mg_tls_init(c, &opts);\n    if (c->tls == NULL) fd.closed = 1;\n  }\n  // c->is_hexdumping = 1;\n  va_start(ap, fmt);\n  mg_vprintf(c, fmt, &ap);\n  va_end(ap);\n  buf[0] = '\\0';\n  for (i = 0; i < 50 && buf[0] == '\\0'; i++) mg_mgr_poll(mgr, 1);\n  if (!fd.closed) c->is_closing = 1;\n  mg_mgr_poll(mgr, 1);\n  return fd.code;\n}\n\nstatic struct mg_http_message gethm(const char *buf) {\n  struct mg_http_message hm;\n  memset(&hm, 0, sizeof(hm));\n  mg_http_parse(buf, strlen(buf), &hm);\n  return hm;\n}\n\nstatic int cmpbody(const char *buf, const char *str) {\n  struct mg_str s = mg_str(str);\n  struct mg_http_message hm = gethm(buf);\n  size_t len = strlen(buf);\n  mg_http_parse(buf, len, &hm);\n  if (hm.body.len > len) hm.body.len = len - (size_t) (hm.body.ptr - buf);\n  return mg_strcmp(hm.body, s);\n}\n\nstatic bool cmpheader(const char *buf, const char *name, const char *value) {\n  struct mg_http_message hm = gethm(buf);\n  struct mg_str *h = mg_http_get_header(&hm, name);\n  return h != NULL && mg_strcmp(*h, mg_str(value)) == 0;\n}\n\nstatic void wcb(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  int *p = (int *) fn_data;\n  if (ev == MG_EV_WS_OPEN) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    struct mg_str *wsproto = mg_http_get_header(hm, \"Sec-WebSocket-Protocol\");\n    ASSERT(wsproto != NULL);\n    mg_ws_printf(c, WEBSOCKET_OP_BINARY, \"%.3s\", \"boo!!!!\");\n    mg_ws_printf(c, WEBSOCKET_OP_BINARY, \"%s\", \"foobar\");\n    mg_ws_send(c, \"\", 0, WEBSOCKET_OP_PING);\n    p[0] += 100;\n  } else if (ev == MG_EV_WS_MSG) {\n    struct mg_ws_message *wm = (struct mg_ws_message *) ev_data;\n    if (mg_strstr(wm->data, mg_str(\"foobar\")))\n      mg_ws_send(c, \"\", 0, WEBSOCKET_OP_CLOSE);\n    if (mg_strstr(wm->data, mg_str(\"boo\"))) p[0] += 2;\n    if (mg_strstr(wm->data, mg_str(\"foobar\"))) p[0] += 3;\n  } else if (ev == MG_EV_CLOSE) {\n    p[0] += 10;\n  }\n}\n\nstatic void ew2(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  size_t size = 65 * 1024 + 737;\n  if (ev == MG_EV_WS_OPEN) {\n    char *msg = (char *) calloc(1, size + 1);\n    memset(msg, 'A', size);\n    mg_ws_printf(c, WEBSOCKET_OP_TEXT, \"%s\", msg);\n    free(msg);\n  } else if (ev == MG_EV_WS_MSG) {\n    struct mg_ws_message *wm = (struct mg_ws_message *) ev_data;\n    if (wm->data.len == 6) {\n      // Ignore the \"opened\" message from server\n    } else {\n      size_t ok = 1, i;\n      ASSERT(wm->data.len == size);\n      for (i = 0; i < size; i++) {\n        if (wm->data.ptr[i] != 'A') ok = 0;\n      }\n      ASSERT(ok == 1);\n      *(int *) fn_data = 1;\n    }\n  }\n}\n\nstatic void test_ws(void) {\n  char buf[FETCH_BUF_SIZE];\n  const char *url = \"ws://LOCALHOST:12343/ws\";\n  struct mg_mgr mgr;\n  int i, done = 0;\n\n  mg_mgr_init(&mgr);\n  ASSERT(mg_http_listen(&mgr, url, eh1, NULL) != NULL);\n  mg_ws_connect(&mgr, url, wcb, &done, \"%s\", \"Sec-WebSocket-Protocol: meh\\r\\n\");\n  for (i = 0; i < 30; i++) mg_mgr_poll(&mgr, 1);\n  // MG_INFO((\"--> %d\", done));\n  ASSERT(done == 115);\n\n  // Test that non-WS requests fail\n  ASSERT(fetch(&mgr, buf, url, \"GET /ws HTTP/1.0\\r\\n\\n\") == 426);\n\n  // Test large WS frames, over 64k\n  done = 0;\n  mg_ws_connect(&mgr, url, ew2, &done, NULL);\n  for (i = 0; i < 1000 && done == 0; i++) mg_mgr_poll(&mgr, 1);\n  ASSERT(done == 1);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void eh9(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_ERROR) {\n    ASSERT(!strcmp((char *) ev_data, \"socket error\"));\n    *(int *) fn_data = 7;\n  }\n  (void) c;\n}\n\nstatic void test_http_server(void) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12346\";\n  char buf[FETCH_BUF_SIZE];\n\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, eh1, NULL);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /%%61.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n\n  // Responses with missing reason phrase must also work\n  ASSERT(fetch(&mgr, buf, url, \"GET /no_reason HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"ok\") == 0);\n\n  // Fetch file with unicode chars in filename\n  ASSERT(fetch(&mgr, buf, url, \"GET /\u043a\u0438\u0457\u0432.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"\u0454\\n\") == 0);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /../fuzz.c HTTP/1.0\\n\\n\") == 404);\n  ASSERT(fetch(&mgr, buf, url, \"GET /.%%2e/fuzz.c HTTP/1.0\\n\\n\") == 404);\n  ASSERT(fetch(&mgr, buf, url, \"GET /.%%2e%%2ffuzz.c HTTP/1.0\\n\\n\") == 404);\n  ASSERT(fetch(&mgr, buf, url, \"GET /..%%2f%%20fuzz.c HTTP/1.0\\n\\n\") == 404);\n  ASSERT(fetch(&mgr, buf, url, \"GET /..%%2ffuzz.c%%20 HTTP/1.0\\n\\n\") == 404);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /dredir HTTP/1.0\\n\\n\") == 301);\n  ASSERT(cmpheader(buf, \"Location\", \"/dredir/\"));\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /dredir/ HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hi\\n\") == 0);\n\n  ASSERT(fetch(&mgr, buf, url,\n               \"GET /dredirgz/ HTTP/1.0\\n\"\n               \"Accept-Encoding: gzip\\n\\n\") == 200);\n  ASSERT(cmpheader(buf, \"Content-Type\", \"text/html; charset=utf-8\"));\n  ASSERT(cmpheader(buf, \"Content-Encoding\", \"gzip\"));\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /gzip.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hi\\n\") == 0);\n  ASSERT(gethm(buf).body.len == 3);\n  ASSERT(cmpheader(buf, \"Content-Encoding\", \"gzip\") == false);\n\n  ASSERT(fetch(&mgr, buf, url,\n               \"GET /gzip.txt HTTP/1.0\\n\"\n               \"Accept-Encoding: foo,gzip\\n\\n\") == 200);\n  mg_hexdump(buf, strlen(buf));\n  ASSERT(cmpheader(buf, \"Content-Encoding\", \"gzip\") == true);\n  ASSERT(gethm(buf).body.len == 23);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /..ddot HTTP/1.0\\n\\n\") == 301);\n  ASSERT(fetch(&mgr, buf, url, \"GET /..ddot/ HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hi\\n\") == 0);\n\n  {\n    extern char *mg_http_etag(char *, size_t, size_t, time_t);\n    struct mg_http_message hm;\n    char etag[100];\n    size_t size = 0;\n    time_t mtime = 0;\n    ASSERT(mg_fs_posix.st(\"./test/data/a.txt\", &size, &mtime) != 0);\n    ASSERT(mg_http_etag(etag, sizeof(etag), size, mtime) == etag);\n    ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\nIf-None-Match: %s\\n\\n\",\n                 etag) == 304);\n    ASSERT(mg_http_parse(buf, strlen(buf), &hm) > 0);\n    MG_INFO((\"%s\", buf));\n    ASSERT(mg_http_get_header(&hm, \"C\") != NULL);\n    ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"C\"), mg_str(\"D\")) == 0);\n  }\n\n  // Text mime type override\n  ASSERT(fetch(&mgr, buf, url, \"GET /servefile HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n  {\n    struct mg_http_message hm;\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_http_get_header(&hm, \"Content-Type\") != NULL);\n    ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Type\"), mg_str(\"c/d\")) ==\n           0);\n  }\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /foo/1 HTTP/1.0\\r\\n\\n\") == 200);\n  // MG_INFO((\"%d %.*s\", (int) hm.len, (int) hm.len, hm.buf));\n  ASSERT(cmpbody(buf, \"uri: 1\") == 0);\n\n  ASSERT(fetch(&mgr, buf, url, \"%s\",\n               \"POST /body HTTP/1.1\\r\\n\"\n               \"Content-Length: 4\\r\\n\\r\\nkuku\") == 200);\n  ASSERT(cmpbody(buf, \"kuku\") == 0);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /ssi HTTP/1.1\\r\\n\\r\\n\") == 301);\n  ASSERT(fetch(&mgr, buf, url, \"GET /ssi/ HTTP/1.1\\r\\n\\r\\n\") == 200);\n  ASSERT(cmpbody(buf,\n                 \"this is index\\n\"\n                 \"this is nested\\n\\n\"\n                 \"this is f1\\n\\n\\n\\n\"\n                 \"recurse\\n\\n\"\n                 \"recurse\\n\\n\"\n                 \"recurse\\n\\n\"\n                 \"recurse\\n\\n\"\n                 \"recurse\\n\\n\") == 0);\n  {\n    struct mg_http_message hm;\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_http_get_header(&hm, \"Content-Length\") != NULL);\n    ASSERT(mg_http_get_header(&hm, \"Content-Type\") != NULL);\n    ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Type\"),\n                     mg_str(\"text/html; charset=utf-8\")) == 0);\n  }\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /badroot HTTP/1.0\\r\\n\\n\") == 404);\n  // ASSERT(cmpbody(buf, \"Invalid web root [/BAAADDD!]\\n\") == 0);\n\n  {\n    char *data = mg_file_read(&mg_fs_posix, \"./test/data/ca.pem\", NULL);\n    ASSERT(fetch(&mgr, buf, url, \"GET /ca.pem HTTP/1.0\\r\\n\\n\") == 200);\n    ASSERT(cmpbody(buf, data) == 0);\n    free(data);\n  }\n\n  {\n    // Test mime type\n    struct mg_http_message hm;\n    ASSERT(fetch(&mgr, buf, url, \"GET /empty.js HTTP/1.0\\r\\n\\n\") == 200);\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_http_get_header(&hm, \"Content-Type\") != NULL);\n    ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Type\"),\n                     mg_str(\"text/javascript; charset=utf-8\")) == 0);\n  }\n\n  {\n    // Test connection refused\n    int i, errored = 0;\n    mg_connect(&mgr, \"tcp://127.0.0.1:55117\", eh9, &errored);\n    // Give it a couple of seconds, see #1605\n    for (i = 0; i < 200 && errored == 0; i++) mg_mgr_poll(&mgr, 10);\n    MG_INFO((\"errored: %d, expected: 7\", errored));\n    ASSERT(errored == 7);\n  }\n\n  // Directory listing\n  fetch(&mgr, buf, url, \"GET /test/ HTTP/1.0\\n\\n\");\n  ASSERT(fetch(&mgr, buf, url, \"GET /test/ HTTP/1.0\\n\\n\") == 200);\n  ASSERT(mg_strstr(mg_str(buf), mg_str(\">Index of /test/<\")) != NULL);\n  ASSERT(mg_strstr(mg_str(buf), mg_str(\">fuzz.c<\")) != NULL);\n\n  {\n    // Credentials\n    struct mg_http_message hm;\n    ASSERT(fetch(&mgr, buf, url, \"%s\",\n                 \"GET /creds?access_token=x HTTP/1.0\\r\\n\\r\\n\") == 200);\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_strcmp(hm.body, mg_str(\"[]:[x]\")) == 0);\n\n    ASSERT(fetch(&mgr, buf, url, \"%s\",\n                 \"GET /creds HTTP/1.0\\r\\n\"\n                 \"Authorization: Bearer x\\r\\n\\r\\n\") == 200);\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_strcmp(hm.body, mg_str(\"[]:[x]\")) == 0);\n\n    ASSERT(fetch(&mgr, buf, url, \"%s\",\n                 \"GET /creds HTTP/1.0\\r\\n\"\n                 \"Authorization: Basic Zm9vOmJhcg==\\r\\n\\r\\n\") == 200);\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_strcmp(hm.body, mg_str(\"[foo]:[bar]\")) == 0);\n\n    ASSERT(fetch(&mgr, buf, url, \"%s\",\n                 \"GET /creds HTTP/1.0\\r\\n\"\n                 \"Cookie: blah; access_token=hello\\r\\n\\r\\n\") == 200);\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_strcmp(hm.body, mg_str(\"[]:[hello]\")) == 0);\n  }\n\n  {\n    // Test upload\n    char *p;\n    remove(\"uploaded.txt\");\n    ASSERT((p = mg_file_read(&mg_fs_posix, \"uploaded.txt\", NULL)) == NULL);\n    ASSERT(fetch(&mgr, buf, url,\n                 \"POST /upload HTTP/1.0\\n\"\n                 \"Content-Length: 1\\n\\nx\") == 400);\n\n    ASSERT(fetch(&mgr, buf, url,\n                 \"POST /upload?name=uploaded.txt HTTP/1.0\\r\\n\"\n                 \"Content-Length: 5\\r\\n\"\n                 \"\\r\\nhello\") == 200);\n    ASSERT(fetch(&mgr, buf, url,\n                 \"POST /upload?name=uploaded.txt&offset=5 HTTP/1.0\\r\\n\"\n                 \"Content-Length: 6\\r\\n\"\n                 \"\\r\\n\\nworld\") == 200);\n    ASSERT((p = mg_file_read(&mg_fs_posix, \"uploaded.txt\", NULL)) != NULL);\n    ASSERT(strcmp(p, \"hello\\nworld\") == 0);\n    free(p);\n    remove(\"uploaded.txt\");\n  }\n\n  {\n    // Test upload directory traversal\n    char *p;\n    remove(\"uploaded.txt\");\n    ASSERT((p = mg_file_read(&mg_fs_posix, \"uploaded.txt\", NULL)) == NULL);\n    ASSERT(fetch(&mgr, buf, url,\n                 \"POST /upload?name=../uploaded.txt HTTP/1.0\\r\\n\"\n                 \"Content-Length: 5\\r\\n\"\n                 \"\\r\\nhello\") == 200);\n    ASSERT((p = mg_file_read(&mg_fs_posix, \"uploaded.txt\", NULL)) != NULL);\n    ASSERT(strcmp(p, \"hello\") == 0);\n    free(p);\n    remove(\"uploaded.txt\");\n  }\n\n  // HEAD request\n  ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(fetch(&mgr, buf, url, \"HEAD /a.txt HTTP/1.0\\n\\n\") == 200);\n\n  // Pre-compressed files\n  {\n    struct mg_http_message hm;\n    ASSERT(fetch(&mgr, buf, url,\n                 \"HEAD /hello.txt HTTP/1.0\\n\"\n                 \"Accept-Encoding: gzip\\n\\n\") == 200);\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_http_get_header(&hm, \"Content-Encoding\") != NULL);\n    ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Encoding\"),\n                     mg_str(\"gzip\")) == 0);\n  }\n\n#if MG_ENABLE_IPV6\n  {\n    const char *url6 = \"http://[::1]:12366\";\n    ASSERT(mg_http_listen(&mgr, url6, eh1, NULL) != NULL);\n    ASSERT(fetch(&mgr, buf, url6, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n    ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n  }\n#endif\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void h4(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    MG_INFO((\"[%.*s %.*s] message len %d\", (int) hm->method.len, hm->method.ptr,\n             (int) hm->uri.len, hm->uri.ptr, (int) hm->message.len));\n    if (mg_http_match_uri(hm, \"/a/#\")) {\n      struct mg_http_serve_opts opts;\n      memset(&opts, 0, sizeof(opts));\n      opts.root_dir = \"/a=./test/data\";\n      opts.page404 = \"./test/data/404.html\";  // existing 404 page\n      mg_http_serve_dir(c, hm, &opts);\n    } else if (mg_http_match_uri(hm, \"/b/#\")) {\n      struct mg_http_serve_opts opts;\n      memset(&opts, 0, sizeof(opts));\n      opts.root_dir = \"/b=./test/data\";\n      opts.page404 = \"./test/data/nooooo.html\";  // non-existing 404 page\n      mg_http_serve_dir(c, hm, &opts);\n    } else {  // null 404 page\n      struct mg_http_serve_opts opts;\n      memset(&opts, 0, sizeof(opts));\n      opts.root_dir = \"./test/data\";\n      mg_http_serve_dir(c, hm, &opts);\n    }\n  }\n  (void) fn_data;\n}\n\nstatic void test_http_404(void) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:22343\";\n  char buf[FETCH_BUF_SIZE];\n\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, h4, NULL);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n  ASSERT(fetch(&mgr, buf, url, \"GET /a/a.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n  ASSERT(fetch(&mgr, buf, url, \"GET /b/a.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /xx.txt HTTP/1.0\\n\\n\") == 404);\n  ASSERT(cmpbody(buf, \"Not found\\n\") == 0);\n  ASSERT(fetch(&mgr, buf, url, \"GET /a/xx.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"boo\\n\") == 0);\n  ASSERT(fetch(&mgr, buf, url, \"GET /b/xx.txt HTTP/1.0\\n\\n\") == 404);\n  ASSERT(cmpbody(buf, \"Not found\\n\") == 0);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_tls(void) {\n#if MG_ENABLE_MBEDTLS || MG_ENABLE_OPENSSL\n  struct mg_tls_opts opts = {\"./test/data/ss_ca.pem\",\n                             NULL,\n                             \"./test/data/ss_server.pem\",\n                             \"./test/data/ss_server.pem\",\n                             NULL,\n                             {0, 0},\n                             NULL};\n  struct mg_mgr mgr;\n  struct mg_connection *c;\n  const char *url = \"https://127.0.0.1:12347\";\n  char buf[FETCH_BUF_SIZE];\n  mg_mgr_init(&mgr);\n  c = mg_http_listen(&mgr, url, eh1, (void *) &opts);\n  ASSERT(c != NULL);\n  ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n  // MG_INFO((\"%s\", buf));\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n#endif\n}\n\nstatic void f3(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  int *ok = (int *) fn_data;\n  // MG_INFO((\"%d\", ev));\n  if (ev == MG_EV_CONNECT) {\n    // c->is_hexdumping = 1;\n    mg_printf(c, \"GET /%s HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n\",\n              c->rem.is_ip6 ? \"\" : \"/robots.txt\",\n              c->rem.is_ip6 ? \"ipv6.google.com\" : \"cesanta.com\");\n  } else if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    // MG_INFO((\"-->[%.*s]\", (int) hm->message.len, hm->message.ptr));\n    // ASSERT(mg_vcmp(&hm->method, \"HTTP/1.1\") == 0);\n    // ASSERT(mg_vcmp(&hm->uri, \"301\") == 0);\n    *ok = mg_http_status(hm);\n  } else if (ev == MG_EV_CLOSE) {\n    if (*ok == 0) *ok = 888;\n  } else if (ev == MG_EV_ERROR) {\n    if (*ok == 0) *ok = 777;\n  }\n}\n\nstatic void test_http_client(void) {\n  struct mg_mgr mgr;\n  struct mg_connection *c;\n  int i, ok = 0;\n  mg_mgr_init(&mgr);\n  c = mg_http_connect(&mgr, \"http://cesanta.com\", f3, &ok);\n  ASSERT(c != NULL);\n  for (i = 0; i < 500 && ok <= 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(ok == 301);\n  c->is_closing = 1;\n  mg_mgr_poll(&mgr, 0);\n  ok = 0;\n#if MG_ENABLE_MBEDTLS || MG_ENABLE_OPENSSL\n  {\n    const char *url = \"https://cesanta.com\";\n    struct mg_str host = mg_url_host(url);\n    struct mg_tls_opts opts = {\n        \"./test/data/ca.pem\", NULL, NULL, NULL, NULL, host, NULL};\n    c = mg_http_connect(&mgr, url, f3, &ok);\n    ASSERT(c != NULL);\n    mg_tls_init(c, &opts);\n    for (i = 0; i < 1500 && ok <= 0; i++) mg_mgr_poll(&mgr, 1000);\n    ASSERT(ok == 200);\n    c->is_closing = 1;\n    mg_mgr_poll(&mgr, 1);\n\n    // Test failed host validation\n    ok = 0;\n    opts.srvname = mg_str(\"dummy\");\n    c = mg_http_connect(&mgr, url, f3, &ok);\n    ASSERT(c != NULL);\n    mg_tls_init(c, &opts);\n    for (i = 0; i < 500 && ok <= 0; i++) mg_mgr_poll(&mgr, 10);\n    ASSERT(ok == 777);\n    mg_mgr_poll(&mgr, 1);\n\n    // Test host validation only (no CA, no cert)\n    ok = 0;\n    opts.srvname = host;\n    opts.ca = NULL;\n    c = mg_http_connect(&mgr, url, f3, &ok);\n    ASSERT(c != NULL);\n    mg_tls_init(c, &opts);\n    for (i = 0; i < 1500 && ok <= 0; i++) mg_mgr_poll(&mgr, 10);\n    ASSERT(ok == 200);\n    c->is_closing = 1;\n    mg_mgr_poll(&mgr, 1);\n  }\n#endif\n\n#if MG_ENABLE_IPV6\n  ok = 0;\n  // ipv6.google.com does not have IPv4 address, only IPv6, therefore\n  // it is guaranteed to hit IPv6 resolution path.\n  c = mg_http_connect(&mgr, \"http://ipv6.google.com\", f3, &ok);\n  for (i = 0; i < 500 && ok <= 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(ok == 200);\n#endif\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void f4(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    mg_printf(c, \"HTTP/1.0 200 OK\\n\\n%.*s/%s\", (int) hm->uri.len, hm->uri.ptr,\n              \"abcdef\");\n    strcat((char *) fn_data, \"m\");\n    c->is_draining = 1;\n  } else if (ev == MG_EV_HTTP_CHUNK) {\n    strcat((char *) fn_data, \"f\");\n  } else if (ev == MG_EV_CLOSE) {\n    strcat((char *) fn_data, \"c\");\n  }\n}\n\nstatic void f4c(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_CONNECT) {\n    mg_printf(c, \"GET /foo/bar HTTP/1.0\\n\\n\");\n  } else if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    ASSERT(mg_strcmp(hm->body, mg_str(\"/foo/bar/abcdef\")) == 0);\n    strcat((char *) fn_data, \"m\");\n  } else if (ev == MG_EV_HTTP_CHUNK) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    MG_INFO((\"FS [%.*s]\", (int) hm->chunk.len, hm->chunk.ptr));\n    strcat((char *) fn_data, \"f\");\n  } else if (ev == MG_EV_CLOSE) {\n    strcat((char *) fn_data, \"c\");\n  }\n}\n\nstatic void test_http_no_content_length(void) {\n  char buf1[10] = {0}, buf2[10] = {0};\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12348\";\n  int i;\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, f4, (void *) buf1);\n  mg_http_connect(&mgr, url, f4c, (void *) buf2);\n  for (i = 0; i < 1000 && strchr(buf2, 'c') == NULL; i++) mg_mgr_poll(&mgr, 10);\n  MG_INFO((\"[%s] [%s]\", buf1, buf2));\n  ASSERT(strcmp(buf1, \"fmc\") == 0);\n  ASSERT(strcmp(buf2, \"fcfm\") == 0);  // See #1475\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void f5(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    mg_http_reply(c, 200, \"\", \"%.*s\", (int) hm->uri.len, hm->uri.ptr);\n    (*(int *) fn_data)++;\n  }\n}\n\nstatic void test_http_pipeline(void) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12377\";\n  struct mg_connection *c;\n  int i, ok = 0;\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, f5, (void *) &ok);\n  c = mg_http_connect(&mgr, url, NULL, NULL);\n  mg_printf(c, \"POST / HTTP/1.0\\nContent-Length: 5\\n\\n12345GET / HTTP/1.0\\n\\n\");\n  for (i = 0; i < 20; i++) mg_mgr_poll(&mgr, 1);\n  // MG_INFO((\"-----> [%d]\", ok));\n  ASSERT(ok == 2);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_http_parse(void) {\n  struct mg_str *v;\n  struct mg_http_message req;\n\n  {\n    const char *s = \"GET / HTTP/1.0\\n\\n\";\n    ASSERT(mg_http_parse(\"\\b23\", 3, &req) == -1);\n    ASSERT(mg_http_parse(\"get\\n\\n\", 5, &req) == -1);\n    ASSERT(mg_http_parse(s, strlen(s) - 1, &req) == 0);\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT(req.message.len == strlen(s));\n    ASSERT(req.body.len == 0);\n  }\n\n  {\n    const char *s = \"GET /blah HTTP/1.0\\r\\nFoo:  bar  \\r\\n\\r\\n\";\n    size_t idx, len = strlen(s);\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) len);\n    ASSERT(mg_vcmp(&req.headers[0].name, \"Foo\") == 0);\n    ASSERT(mg_vcmp(&req.headers[0].value, \"bar\") == 0);\n    ASSERT(req.headers[1].name.len == 0);\n    ASSERT(req.headers[1].name.ptr == NULL);\n    ASSERT(req.query.len == 0);\n    ASSERT(req.message.len == len);\n    ASSERT(req.body.len == 0);\n    for (idx = 0; idx < len; idx++) ASSERT(mg_http_parse(s, idx, &req) == 0);\n  }\n\n  {\n    static const char *s = \"get b c\\nz :  k \\nb: t\\nvvv\\n\\n xx\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s) - 3);\n    ASSERT(req.headers[2].name.len == 0);\n    ASSERT(mg_vcmp(&req.headers[0].value, \"k\") == 0);\n    ASSERT(mg_vcmp(&req.headers[1].value, \"t\") == 0);\n    ASSERT(req.body.len == 0);\n  }\n\n  {\n    const char *s = \"a b c\\r\\nContent-Length: 21 \\r\\nb: t\\r\\nvvv\\r\\n\\r\\nabc\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s) - 3);\n    ASSERT(req.body.len == 21);\n    ASSERT(req.message.len == 21 - 3 + strlen(s));\n    ASSERT(mg_http_get_header(&req, \"foo\") == NULL);\n    ASSERT((v = mg_http_get_header(&req, \"contENT-Length\")) != NULL);\n    ASSERT(mg_vcmp(v, \"21\") == 0);\n    ASSERT((v = mg_http_get_header(&req, \"B\")) != NULL);\n    ASSERT(mg_vcmp(v, \"t\") == 0);\n  }\n\n  {\n    const char *s = \"GET /foo?a=b&c=d HTTP/1.0\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT(mg_vcmp(&req.uri, \"/foo\") == 0);\n    ASSERT(mg_vcmp(&req.query, \"a=b&c=d\") == 0);\n  }\n\n  {\n    const char *s = \"POST /x HTTP/1.0\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT(req.body.len == (size_t) ~0);\n  }\n\n  {\n    const char *s = \"WOHOO /x HTTP/1.0\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT(req.body.len == 0);\n  }\n\n  {\n    const char *s = \"HTTP/1.0 200 OK\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT(mg_vcmp(&req.method, \"HTTP/1.0\") == 0);\n    ASSERT(mg_vcmp(&req.uri, \"200\") == 0);\n    ASSERT(mg_vcmp(&req.proto, \"OK\") == 0);\n    ASSERT(req.body.len == (size_t) ~0);\n  }\n\n  {\n    static const char *s = \"HTTP/1.0 999 OMGWTFBBQ\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n  }\n\n  {\n    const char *s =\n        \"GET / HTTP/1.0\\r\\nhost:127.0.0.1:18888\\r\\nCookie:\\r\\nX-PlayID: \"\n        \"45455\\r\\nRange:  0-1 \\r\\n\\r\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT((v = mg_http_get_header(&req, \"Host\")) != NULL);\n    ASSERT(mg_vcmp(v, \"127.0.0.1:18888\") == 0);\n    ASSERT((v = mg_http_get_header(&req, \"Cookie\")) != NULL);\n    ASSERT(v->len == 0);\n    ASSERT((v = mg_http_get_header(&req, \"X-PlayID\")) != NULL);\n    ASSERT(mg_vcmp(v, \"45455\") == 0);\n    ASSERT((v = mg_http_get_header(&req, \"Range\")) != NULL);\n    ASSERT(mg_vcmp(v, \"0-1\") == 0);\n  }\n\n  {\n    static const char *s = \"a b c\\na:1\\nb:2\\nc:3\\nd:4\\ne:5\\nf:6\\ng:7\\nh:8\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT((v = mg_http_get_header(&req, \"e\")) != NULL);\n    ASSERT(mg_vcmp(v, \"5\") == 0);\n    ASSERT((v = mg_http_get_header(&req, \"h\")) == NULL);\n  }\n\n  {\n    struct mg_connection c;\n    struct mg_str s,\n        res = mg_str(\"GET /\\r\\nAuthorization: Basic Zm9vOmJhcg==\\r\\n\\r\\n\");\n    memset(&c, 0, sizeof(c));\n    mg_printf(&c, \"%s\", \"GET /\\r\\n\");\n    mg_http_bauth(&c, \"foo\", \"bar\");\n    mg_printf(&c, \"%s\", \"\\r\\n\");\n    s = mg_str_n((char *) c.send.buf, c.send.len);\n    ASSERT(mg_strcmp(s, res) == 0);\n    mg_iobuf_free(&c.send);\n  }\n\n  {\n    struct mg_http_message hm;\n    const char *s = \"GET /foo?bar=baz HTTP/1.0\\n\\n \";\n    ASSERT(mg_http_parse(s, strlen(s), &hm) == (int) strlen(s) - 1);\n    ASSERT(mg_strcmp(hm.uri, mg_str(\"/foo\")) == 0);\n    ASSERT(mg_strcmp(hm.query, mg_str(\"bar=baz\")) == 0);\n  }\n\n  {\n    struct mg_http_message hm;\n    const char *s = \"a b c\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &hm) == (int) strlen(s));\n    s = \"a b\\nc\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &hm) == (int) strlen(s));\n    s = \"a\\nb\\nc\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &hm) < 0);\n  }\n}\n\nstatic void ehr(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    struct mg_http_serve_opts opts;\n    memset(&opts, 0, sizeof(opts));\n    opts.root_dir = \"./test/data\";\n    mg_http_serve_dir(c, hm, &opts);\n  }\n  (void) fn_data;\n}\n\nstatic void test_http_range(void) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12349\";\n  struct mg_http_message hm;\n  char buf[FETCH_BUF_SIZE];\n\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, ehr, NULL);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /range.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(mg_http_parse(buf, strlen(buf), &hm) > 0);\n  ASSERT(hm.body.len == 312);\n\n  fetch(&mgr, buf, url, \"%s\", \"GET /range.txt HTTP/1.0\\nRange: bytes=5-10\\n\\n\");\n  ASSERT(mg_http_parse(buf, strlen(buf), &hm) > 0);\n  ASSERT(mg_strcmp(hm.uri, mg_str(\"206\")) == 0);\n  ASSERT(mg_strcmp(hm.proto, mg_str(\"Partial Content\")) == 0);\n  ASSERT(mg_strcmp(hm.body, mg_str(\" of co\")) == 0);\n  ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Range\"),\n                   mg_str(\"bytes 5-10/312\")) == 0);\n\n  // Fetch till EOF\n  fetch(&mgr, buf, url, \"%s\", \"GET /range.txt HTTP/1.0\\nRange: bytes=300-\\n\\n\");\n  ASSERT(mg_http_parse(buf, strlen(buf), &hm) > 0);\n  ASSERT(mg_strcmp(hm.uri, mg_str(\"206\")) == 0);\n  ASSERT(mg_strcmp(hm.body, mg_str(\"is disease.\\n\")) == 0);\n  // MG_INFO((\"----%d\\n[%s]\", (int) hm.body.len, buf));\n\n  // Fetch past EOF, must trigger 416 response\n  fetch(&mgr, buf, url, \"%s\", \"GET /range.txt HTTP/1.0\\nRange: bytes=999-\\n\\n\");\n  ASSERT(mg_http_parse(buf, strlen(buf), &hm) > 0);\n  ASSERT(mg_strcmp(hm.uri, mg_str(\"416\")) == 0);\n  ASSERT(hm.body.len == 0);\n  ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Range\"),\n                   mg_str(\"bytes */312\")) == 0);\n\n  fetch(&mgr, buf, url, \"%s\",\n        \"GET /range.txt HTTP/1.0\\nRange: bytes=0-312\\n\\n\");\n  ASSERT(mg_http_parse(buf, strlen(buf), &hm) > 0);\n  ASSERT(mg_strcmp(hm.uri, mg_str(\"416\")) == 0);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void f1(void *arg) { (*(int *) arg)++; }\n\nstatic void test_timer(void) {\n  int v1 = 0, v2 = 0, v3 = 0;\n  struct mg_timer t1, t2, t3, *head = NULL;\n\n  mg_timer_init(&head, &t1, 5, MG_TIMER_REPEAT, f1, &v1);\n  mg_timer_init(&head, &t2, 15, MG_TIMER_ONCE, f1, &v2);\n  mg_timer_init(&head, &t3, 10, MG_TIMER_REPEAT | MG_TIMER_RUN_NOW, f1, &v3);\n\n  ASSERT(head == &t3);\n  ASSERT(head->next == &t2);\n\n  mg_timer_poll(&head, 0);\n  ASSERT(v1 == 0);\n  ASSERT(v2 == 0);\n  ASSERT(v3 == 1);\n\n  mg_timer_poll(&head, 1);\n  ASSERT(v1 == 0);\n  ASSERT(v2 == 0);\n  ASSERT(v3 == 1);\n\n  mg_timer_poll(&head, 5);\n  ASSERT(v1 == 1);\n  ASSERT(v2 == 0);\n  ASSERT(v3 == 1);\n\n  // Simulate long delay - timers must invalidate expiration times\n  mg_timer_poll(&head, 100);\n  ASSERT(v1 == 2);\n  ASSERT(v2 == 1);\n  ASSERT(v3 == 2);\n\n  mg_timer_poll(&head, 107);\n  ASSERT(v1 == 3);\n  ASSERT(v2 == 1);\n  ASSERT(v3 == 2);\n\n  mg_timer_poll(&head, 114);\n  ASSERT(v1 == 4);\n  ASSERT(v2 == 1);\n  ASSERT(v3 == 3);\n\n  mg_timer_poll(&head, 115);\n  ASSERT(v1 == 5);\n  ASSERT(v2 == 1);\n  ASSERT(v3 == 3);\n\n  mg_timer_free(&head, &t2);\n  mg_timer_init(&head, &t2, 3, 0, f1, &v2);\n  ASSERT(head == &t2);\n  ASSERT(head->next == &t3);\n  ASSERT(head->next->next == &t1);\n  ASSERT(head->next->next->next == NULL);\n\n  mg_timer_poll(&head, 120);\n  ASSERT(v1 == 6);\n  ASSERT(v2 == 1);\n  ASSERT(v3 == 4);\n\n  mg_timer_poll(&head, 125);\n  ASSERT(v1 == 7);\n  ASSERT(v2 == 2);\n  ASSERT(v3 == 4);\n\n  // Test millisecond counter wrap - when time goes back.\n  mg_timer_poll(&head, 0);\n  ASSERT(v1 == 7);\n  ASSERT(v2 == 2);\n  ASSERT(v3 == 4);\n\n  mg_timer_poll(&head, 7);\n  ASSERT(v1 == 8);\n  ASSERT(v2 == 2);\n  ASSERT(v3 == 4);\n\n  mg_timer_poll(&head, 11);\n  ASSERT(v1 == 9);\n  ASSERT(v2 == 2);\n  ASSERT(v3 == 5);\n\n  mg_timer_free(&head, &t1);\n  ASSERT(head == &t2);\n  ASSERT(head->next == &t3);\n  ASSERT(head->next->next == NULL);\n\n  mg_timer_free(&head, &t2);\n  ASSERT(head == &t3);\n  ASSERT(head->next == NULL);\n\n  mg_timer_free(&head, &t3);\n  ASSERT(head == NULL);\n\n  // Test proper timer deallocation, see #1539\n  {\n    struct mg_mgr mgr;\n    mg_mgr_init(&mgr);\n    mg_timer_add(&mgr, 1, MG_TIMER_REPEAT, f1, NULL);\n    mg_mgr_free(&mgr);\n    ASSERT(mgr.conns == NULL);\n  }\n}\n\nstatic bool sn(const char *fmt, ...) {\n  char buf[100], tmp[1] = {0}, buf2[sizeof(buf)];\n  size_t n, n2, n1;\n  va_list ap;\n  bool result;\n  va_start(ap, fmt);\n  n = (size_t) vsnprintf(buf2, sizeof(buf2), fmt, ap);\n  va_end(ap);\n  va_start(ap, fmt);\n  n1 = mg_vsnprintf(buf, sizeof(buf), fmt, &ap);\n  va_end(ap);\n  va_start(ap, fmt);\n  n2 = mg_vsnprintf(tmp, 0, fmt, &ap);\n  va_end(ap);\n  result = n1 == n2 && n1 == n && strcmp(buf, buf2) == 0;\n  if (!result)\n    MG_ERROR((\"[%s] -> [%s] != [%s] %d %d %d\\n\", fmt, buf, buf2, (int) n1,\n              (int) n2, (int) n));\n  return result;\n}\n\nstatic bool sccmp(const char *s1, const char *s2, int expected) {\n  int n1 = mg_casecmp(s1, s2);\n  // MG_INFO((\"[%s] [%s] %d %d\", s1, s2, n1, expected));\n  return n1 == expected;\n}\n\nstatic size_t pf1(void (*out)(char, void *), void *ptr, va_list *ap) {\n  int a = va_arg(*ap, int);\n  int b = va_arg(*ap, int);\n  return mg_xprintf(out, ptr, \"%d\", a + b);\n}\n\nstatic size_t pf2(void (*out)(char, void *), void *ptr, va_list *ap) {\n  int cnt = va_arg(*ap, int);\n  size_t n = 0;\n  while (cnt-- > 0) n += mg_xprintf(out, ptr, \"%d\", cnt);\n  return n;\n}\n\nstatic bool chkdbl(struct mg_str s, double val) {\n  double d, tolerance = 1e-14;\n  return mg_json_get_num(s, \"$\", &d) && fabs(val - d) < tolerance;\n}\n\nstatic void test_str(void) {\n  {\n    struct mg_str s = mg_strdup(mg_str(\"a\"));\n    ASSERT(mg_strcmp(s, mg_str(\"a\")) == 0);\n    free((void *) s.ptr);\n  }\n\n  {\n    const char *s;\n    struct mg_str a = mg_str(\"hello\"), b = mg_str(\"a\"), c = mg_str(NULL);\n    ASSERT((s = mg_strstr(a, b)) == NULL);\n    ASSERT((s = mg_strstr(a, c)) != NULL);\n    ASSERT(s == a.ptr);\n  }\n\n  ASSERT(mg_strcmp(mg_str(\"\"), mg_str(NULL)) == 0);\n  ASSERT(mg_strcmp(mg_str(\"a\"), mg_str(\"b\")) < 0);\n  ASSERT(mg_strcmp(mg_str(\"b\"), mg_str(\"a\")) > 0);\n  ASSERT(mg_strstr(mg_str(\"abc\"), mg_str(\"d\")) == NULL);\n  ASSERT(mg_strstr(mg_str(\"abc\"), mg_str(\"b\")) != NULL);\n  ASSERT(mg_strcmp(mg_str(\"hi\"), mg_strstrip(mg_str(\" \\thi\\r\\n\"))) == 0);\n\n  ASSERT(sccmp(\"\", \"\", 0));\n  ASSERT(sccmp(\"\", \"1\", -49));\n  ASSERT(sccmp(\"a\", \"A\", 0));\n  ASSERT(sccmp(\"a1\", \"A\", 49));\n  ASSERT(sccmp(\"a\", \"A1\", -49));\n\n  {\n    ASSERT(chkdbl(mg_str_n(\"1.23\", 3), 1.2));\n    ASSERT(chkdbl(mg_str(\"1.23 \"), 1.23));\n    ASSERT(chkdbl(mg_str(\"-0.01 \"), -0.01));\n    ASSERT(chkdbl(mg_str(\"-0.5e2\"), -50.0));\n    ASSERT(chkdbl(mg_str(\"123e-3\"), 0.123));\n  }\n\n  ASSERT(sn(\"%d\", 0));\n  ASSERT(sn(\"%d\", 1));\n  ASSERT(sn(\"%d\", -1));\n  ASSERT(sn(\"%.*s\", 0, \"ab\"));\n  ASSERT(sn(\"%.*s\", 1, \"ab\"));\n  ASSERT(sn(\"%.1s\", \"ab\"));\n  ASSERT(sn(\"%.99s\", \"a\"));\n  ASSERT(sn(\"%11s\", \"a\"));\n  ASSERT(sn(\"%s\", \"a\\0b\"));\n  ASSERT(sn(\"%2s\", \"a\"));\n  ASSERT(sn(\"%.*s\", 3, \"a\\0b\"));\n  ASSERT(sn(\"%d\", 7));\n  ASSERT(sn(\"%d\", 123));\n#if MG_ARCH == MG_ARCH_UNIX\n  ASSERT(sn(\"%lld\", (uint64_t) 0xffffffffff));\n  ASSERT(sn(\"%lld\", (uint64_t) -1));\n  ASSERT(sn(\"%llu\", (uint64_t) -1));\n  ASSERT(sn(\"%llx\", (uint64_t) 0xffffffffff));\n  ASSERT(sn(\"%p\", (void *) (size_t) 7));\n#endif\n  ASSERT(sn(\"%lx\", (unsigned long) 0x6204d754));\n  ASSERT(sn(\"ab\"));\n  ASSERT(sn(\"%dx\", 1));\n  ASSERT(sn(\"%sx\", \"a\"));\n  ASSERT(sn(\"%cx\", 32));\n  ASSERT(sn(\"%x\", 15));\n  ASSERT(sn(\"%2x\", 15));\n  ASSERT(sn(\"%02x\", 15));\n  ASSERT(sn(\"%hx:%hhx\", (short) 1, (char) 2));\n  ASSERT(sn(\"%hx:%hhx\", (short) 1, (char) 2));\n  ASSERT(sn(\"%%\"));\n  ASSERT(sn(\"%x\", 15));\n  ASSERT(sn(\"%#x\", 15));\n  ASSERT(sn(\"%#6x\", 15));\n  ASSERT(sn(\"%#06x\", 15));\n  ASSERT(sn(\"%#-6x\", 15));\n  ASSERT(sn(\"%-2s!\", \"a\"));\n  ASSERT(sn(\"%s %s\", \"a\", \"b\"));\n  ASSERT(sn(\"%s %s\", \"a\", \"b\"));\n  ASSERT(sn(\"ab%dc\", 123));\n  ASSERT(sn(\"%s \", \"a\"));\n  ASSERT(sn(\"%s %s\", \"a\", \"b\"));\n  ASSERT(sn(\"%2s %s\", \"a\", \"b\"));\n\n  // Non-standard formatting\n  {\n    char buf[100], *p = NULL;\n    struct mg_iobuf io = {0, 0, 0, 16};\n    const char *expected;\n\n    expected = \"\\\"\\\"\";\n    mg_snprintf(buf, sizeof(buf), \"%m\", mg_print_esc, 0, \"\");\n    ASSERT(strcmp(buf, expected) == 0);\n\n    expected = \"\";\n    mg_snprintf(buf, 1, \"%s\", \"abc\");\n    ASSERT(strcmp(buf, expected) == 0);\n\n    expected = \"a\";\n    mg_snprintf(buf, 2, \"%s\", \"abc\");\n    ASSERT(strcmp(buf, expected) == 0);\n\n    expected = \"\\\"hi, \\\\\\\"\\\"\";\n    mg_snprintf(buf, sizeof(buf), \"\\\"hi, %M\\\"\", mg_print_esc, 0, \"\\\"\");\n    MG_INFO((\"[%s] [%s]\", buf, expected));\n    ASSERT(strcmp(buf, expected) == 0);\n\n    expected = \"\\\"a'b\\\"\";\n    mg_snprintf(buf, sizeof(buf), \"%m\", mg_print_esc, 0, \"a'b\");\n    ASSERT(strcmp(buf, expected) == 0);\n\n    expected = \"\\\"a\\\\b\\\\n\\\\f\\\\r\\\\t\\\\\\\"\\\"\";\n    mg_snprintf(buf, sizeof(buf), \"%m\", mg_print_esc, 0, \"a\\b\\n\\f\\r\\t\\\"\");\n    ASSERT(strcmp(buf, expected) == 0);\n\n    expected = \"\\\"abc\\\"\";\n    mg_snprintf(buf, sizeof(buf), \"%m\", mg_print_esc, 3, \"abcdef\");\n    ASSERT(strcmp(buf, expected) == 0);\n\n    p = mg_mprintf(\"[%s,%M,%s]\", \"null\", pf1, 2, 3, \"hi\");\n    ASSERT(strcmp(p, \"[null,5,hi]\") == 0);\n    free(p);\n\n    p = mg_mprintf(\"[%M,%d]\", pf2, 10, 7);\n    ASSERT(strcmp(p, \"[9876543210,7]\") == 0);\n    free(p);\n\n    mg_xprintf(mg_pfn_iobuf, &io, \"[%M\", pf2, 10);\n    mg_xprintf(mg_pfn_iobuf, &io, \",\");\n    mg_xprintf(mg_pfn_iobuf, &io, \"%d]\", 7);\n    ASSERT(strcmp((char *) io.buf, \"[9876543210,7]\") == 0);\n    mg_iobuf_free(&io);\n  }\n\n  {\n#if MG_ARCH == MG_ARCH_WIN32\n    bool is_windows = true;\n#else\n    bool is_windows = false;\n#endif\n\n#define DBLWIDTH(a, b) a, b\n#define TESTDOUBLE(fmt_, num_, res_)                             \\\n  do {                                                           \\\n    char t1[40] = \"\", t2[40] = \"\";                               \\\n    const char *N = #num_;                                       \\\n    mg_snprintf(t1, sizeof(t1), fmt_, num_);                     \\\n    snprintf(t2, sizeof(t2), fmt_, num_);                        \\\n    printf(\"[%s,%s] : [%s] [%s] [%s]\\n\", fmt_, N, res_, t2, t1); \\\n    ASSERT(strcmp(t1, res_) == 0);                               \\\n    if (!is_windows) ASSERT(strcmp(t1, t2) == 0);                \\\n  } while (0)\n\n    TESTDOUBLE(\"%g\", 0.0, \"0\");\n    TESTDOUBLE(\"%g\", 0.123, \"0.123\");\n    TESTDOUBLE(\"%g\", 0.00123, \"0.00123\");\n    TESTDOUBLE(\"%g\", 0.123456333, \"0.123456\");\n    TESTDOUBLE(\"%g\", 123.0, \"123\");\n    TESTDOUBLE(\"%g\", 11.5454, \"11.5454\");\n    TESTDOUBLE(\"%g\", 11.0001, \"11.0001\");\n    TESTDOUBLE(\"%g\", 0.999, \"0.999\");\n    TESTDOUBLE(\"%g\", 0.999999, \"0.999999\");\n    TESTDOUBLE(\"%g\", 0.9999999, \"1\");\n    TESTDOUBLE(\"%g\", 10.9, \"10.9\");\n    TESTDOUBLE(\"%g\", 10.01, \"10.01\");\n    TESTDOUBLE(\"%g\", 1.0, \"1\");\n    TESTDOUBLE(\"%g\", 10.0, \"10\");\n    TESTDOUBLE(\"%g\", 100.0, \"100\");\n    TESTDOUBLE(\"%g\", 1000.0, \"1000\");\n    TESTDOUBLE(\"%g\", 10000.0, \"10000\");\n    TESTDOUBLE(\"%g\", 100000.0, \"100000\");\n    TESTDOUBLE(\"%g\", 1000000.0, \"1e+06\");\n    TESTDOUBLE(\"%g\", 10000000.0, \"1e+07\");\n    TESTDOUBLE(\"%g\", 100000001.0, \"1e+08\");\n    TESTDOUBLE(\"%g\", 10.5454, \"10.5454\");\n    TESTDOUBLE(\"%g\", 999999.0, \"999999\");\n    TESTDOUBLE(\"%g\", 9999999.0, \"1e+07\");\n    TESTDOUBLE(\"%g\", 44556677.0, \"4.45567e+07\");\n    TESTDOUBLE(\"%g\", 1234567.2, \"1.23457e+06\");\n    TESTDOUBLE(\"%g\", -987.65432, \"-987.654\");\n    TESTDOUBLE(\"%g\", 0.0000000001, \"1e-10\");\n    TESTDOUBLE(\"%g\", 2.34567e-57, \"2.34567e-57\");\n    TESTDOUBLE(\"%.*g\", DBLWIDTH(7, 9999999.0), \"9999999\");\n    TESTDOUBLE(\"%.*g\", DBLWIDTH(10, 0.123456333), \"0.123456333\");\n    TESTDOUBLE(\"%g\", 123.456222, \"123.456\");\n    TESTDOUBLE(\"%.*g\", DBLWIDTH(10, 123.456222), \"123.456222\");\n    TESTDOUBLE(\"%g\", 600.1234, \"600.123\");\n    TESTDOUBLE(\"%g\", -600.1234, \"-600.123\");\n    TESTDOUBLE(\"%g\", 599.1234, \"599.123\");\n    TESTDOUBLE(\"%g\", -599.1234, \"-599.123\");\n    TESTDOUBLE(\"%g\", 0.14, \"0.14\");\n    TESTDOUBLE(\"%f\", 0.14, \"0.140000\");\n    TESTDOUBLE(\"%.*f\", DBLWIDTH(4, 0.14), \"0.1400\");\n    TESTDOUBLE(\"%.*f\", DBLWIDTH(3, 0.14), \"0.140\");\n    TESTDOUBLE(\"%.*f\", DBLWIDTH(2, 0.14), \"0.14\");\n    TESTDOUBLE(\"%.*f\", DBLWIDTH(1, 0.14), \"0.1\");\n    TESTDOUBLE(\"%.*f\", DBLWIDTH(1, 0.19), \"0.2\");\n    TESTDOUBLE(\"%.*f\", DBLWIDTH(1, 0.16), \"0.2\");\n    // TESTDOUBLE(\"%.*f\", DBLWIDTH(1, 0.15), \"0.1\");\n\n#ifndef _WIN32\n    TESTDOUBLE(\"%g\", (double) INFINITY, \"inf\");\n    TESTDOUBLE(\"%g\", (double) -INFINITY, \"-inf\");\n    TESTDOUBLE(\"%g\", (double) NAN, \"nan\");\n#else\n    TESTDOUBLE(\"%g\", HUGE_VAL, \"inf\");\n    TESTDOUBLE(\"%g\", -HUGE_VAL, \"-inf\");\n#endif\n  }\n\n  {\n    const char *expected = \"[\\\"MA==\\\",\\\"MAo=\\\",\\\"MAr+\\\",\\\"MAr+Zw==\\\"]\";\n    char tmp[100], s[] = \"0\\n\\xfeg\";\n    ASSERT(mg_snprintf(tmp, sizeof(tmp), \"[%m,%m,%m,%m]\", mg_print_base64, 1, s,\n                       mg_print_base64, 2, s, mg_print_base64, 3, s,\n                       mg_print_base64, 4, s) == 33);\n    ASSERT(strcmp(tmp, expected) == 0);\n  }\n\n  {\n    const char *expected = \"\\\"002001200220616263\\\"\";\n    char tmp[100], s[] = \"\\x00 \\x01 \\x02 abc\";\n    ASSERT(mg_snprintf(tmp, sizeof(tmp), \"%m\", mg_print_hex, 9, s) == 20);\n    ASSERT(strcmp(tmp, expected) == 0);\n  }\n\n  {\n    char tmp[3];\n    ASSERT(mg_snprintf(tmp, sizeof(tmp), \"%s\", \"0123456789\") == 10);\n    ASSERT(strcmp(tmp, \"01\") == 0);\n    ASSERT(tmp[2] == '\\0');\n  }\n\n  {\n    char buf[100];\n    struct mg_addr a = {mg_htons(3), mg_htonl(0x2000001), {1, 100, 33}, false};\n    ASSERT(mg_snprintf(buf, sizeof(buf), \"%M %d\", mg_print_ip, &a, 7) == 9);\n    ASSERT(strcmp(buf, \"2.0.0.1 7\") == 0);\n    ASSERT(mg_snprintf(buf, sizeof(buf), \"%M %d\", mg_print_ip_port, &a, 7) ==\n           11);\n    ASSERT(strcmp(buf, \"2.0.0.1:3 7\") == 0);\n    a.is_ip6 = true;\n    ASSERT(mg_snprintf(buf, sizeof(buf), \"%M %d\", mg_print_ip, &a, 7) == 24);\n    ASSERT(strcmp(buf, \"[164:2100:0:0:0:0:0:0] 7\") == 0);\n    ASSERT(mg_snprintf(buf, sizeof(buf), \"%M %d\", mg_print_ip_port, &a, 7) ==\n           26);\n    ASSERT(strcmp(buf, \"[164:2100:0:0:0:0:0:0]:3 7\") == 0);\n  }\n}\n\nstatic void fn1(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_ERROR)\n    *(char **) fn_data = mg_mprintf(\"%s\", (char *) ev_data);\n  (void) c;\n}\n\nstatic void test_dns_error(const char *dns_server_url, const char *errstr) {\n  // Test timeout\n  struct mg_mgr mgr;\n  char *buf = NULL;\n  int i;\n  mg_mgr_init(&mgr);\n  mgr.dns4.url = dns_server_url;\n  mgr.dnstimeout = 10;\n  MG_DEBUG((\"opening dummy DNS listener @ [%s]...\", dns_server_url));\n  mg_listen(&mgr, mgr.dns4.url, NULL, NULL);  // Just discard our queries\n  mg_http_connect(&mgr, \"http://google.com\", fn1, &buf);\n  for (i = 0; i < 50 && buf == NULL; i++) mg_mgr_poll(&mgr, 1);\n  mg_mgr_free(&mgr);\n  // MG_DEBUG((\"buf: [%s] [%s]\", buf, errstr));\n  ASSERT(buf != NULL && strcmp(buf, errstr) == 0);\n  free(buf);\n}\n\nstatic void test_dns(void) {\n  struct mg_dns_message dm;\n  //       txid  flags numQ  numA  numAP numOP\n  // 0000  00 01 81 80 00 01 00 01 00 00 00 00 07 63 65 73  .............ces\n  // 0010  61 6e 74 61 03 63 6f 6d 00 00 01 00 01 c0 0c 00  anta.com........\n  // 0020  01 00 01 00 00 02 57 00 04 94 fb 36 ec           ......W....6.\n  uint8_t data[] = {0,    1,    0x81, 0x80, 0,    1,    0,    1,    0,\n                    0,    0,    0,    7,    0x63, 0x65, 0x73, 0x61, 0x6e,\n                    0x74, 0x61, 0x03, 0x63, 0x6f, 0x6d, 0,    0,    1,\n                    0,    1,    0xc0, 0x0c, 0,    1,    0,    1,    0,\n                    0,    2,    0x57, 0,    4,    0x94, 0xfb, 0x36, 0xec};\n  ASSERT(mg_dns_parse(NULL, 0, &dm) == 0);\n  ASSERT(mg_dns_parse(data, sizeof(data), &dm) == 1);\n  ASSERT(strcmp(dm.name, \"cesanta.com\") == 0);\n  data[30] = 29;  // Point a pointer to itself\n  memset(&dm, 0, sizeof(dm));\n  ASSERT(mg_dns_parse(data, sizeof(data), &dm) == 1);\n  ASSERT(strcmp(dm.name, \"\") == 0);\n\n  {\n    // 0000  00 01 81 80 00 01 00 04 00 00 00 00 05 79 61 68  .............yah\n    // 0010  6f 6f 05 63 31 31 32 36 03 63 6f 6d 00 00 01 00  oo.c1126.com....\n    // 0020  01 c0 0c 00 05 00 01 00 00 0d 34 00 0c 03 77 77  ..........4...ww\n    // 0030  77 05 79 61 68 6f 6f c0 18 c0 2d 00 05 00 01 00  w.yahoo...-.....\n    // 0040  00 00 01 00 14 0b 6e 65 77 2d 66 70 2d 73 68 65  ......new-fp-she\n    // 0050  64 03 77 67 31 01 62 c0 31 c0 45 00 01 00 01 00  d.wg1.b.1.E.....\n    // 0060  00 00 0a 00 04 57 f8 64 d8 c0 45 00 01 00 01 00  .....W.d..E.....\n    // 0070  00 00 0a 00 04 57 f8 64 d7                       .....W.d.\n    uint8_t d[] = {\n        0x00, 0x01, 0x81, 0x80, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,\n        0x00, 0x05, 0x79, 0x61, 0x68, 0x6f, 0x6f, 0x05, 0x63, 0x31, 0x31,\n        0x32, 0x36, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01,\n        0xc0, 0x0c, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x0d, 0x34, 0x00,\n        0x0c, 0x03, 0x77, 0x77, 0x77, 0x05, 0x79, 0x61, 0x68, 0x6f, 0x6f,\n        0xc0, 0x18, 0xc0, 0x2d, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x00,\n        0x01, 0x00, 0x14, 0x0b, 0x6e, 0x65, 0x77, 0x2d, 0x66, 0x70, 0x2d,\n        0x73, 0x68, 0x65, 0x64, 0x03, 0x77, 0x67, 0x31, 0x01, 0x62, 0xc0,\n        0x31, 0xc0, 0x45, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0a,\n        0x00, 0x04, 0x57, 0xf8, 0x64, 0xd8, 0xc0, 0x45, 0x00, 0x01, 0x00,\n        0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x04, 0x57, 0xf8, 0x64, 0xd7,\n    };\n    ASSERT(mg_dns_parse(d, sizeof(d), &dm) == 1);\n    // MG_INFO((\"[%s]\", dm.name));\n    ASSERT(strcmp(dm.name, \"new-fp-shed.wg1.b.yahoo.com\") == 0);\n  }\n\n  test_dns_error(\"udp://127.0.0.1:12345\", \"DNS timeout\");\n  test_dns_error(\"\", \"resolver\");\n  test_dns_error(\"tcp://0.0.0.0:0\", \"DNS error\");\n}\n\nstatic void test_util(void) {\n  char buf[100], *p, *s;\n  struct mg_addr a;\n  memset(&a, 0, sizeof(a));\n  ASSERT(mg_file_printf(&mg_fs_posix, \"data.txt\", \"%s\", \"hi\") == true);\n  // if (system(\"ls -l\") != 0) (void) 0;\n  ASSERT((p = mg_file_read(&mg_fs_posix, \"data.txt\", NULL)) != NULL);\n  ASSERT(strcmp(p, \"hi\") == 0);\n  free(p);\n  remove(\"data.txt\");\n  ASSERT(mg_aton(mg_str(\"0\"), &a) == false);\n  ASSERT(mg_aton(mg_str(\"0.0.0.\"), &a) == false);\n  ASSERT(mg_aton(mg_str(\"0.0.0.256\"), &a) == false);\n  ASSERT(mg_aton(mg_str(\"0.0.0.-1\"), &a) == false);\n  ASSERT(mg_aton(mg_str(\"127.0.0.1\"), &a) == true);\n  ASSERT(a.is_ip6 == false);\n  ASSERT(a.ip == mg_htonl(0x7f000001));\n\n  ASSERT(mg_aton(mg_str(\"1:2:3:4:5:6:7:8\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(\n      memcmp(a.ip6,\n             \"\\x00\\x01\\x00\\x02\\x00\\x03\\x00\\x04\\x00\\x05\\x00\\x06\\x00\\x07\\x00\\x08\",\n             sizeof(a.ip6)) == 0);\n\n  memset(a.ip6, 0xaa, sizeof(a.ip6));\n  ASSERT(mg_aton(mg_str(\"1::1\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(\n      memcmp(a.ip6,\n             \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\",\n             sizeof(a.ip6)) == 0);\n\n  memset(a.ip6, 0xaa, sizeof(a.ip6));\n  ASSERT(mg_aton(mg_str(\"::fFff:1.2.3.4\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(memcmp(a.ip6,\n                \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n                \"\\x00\\x00\\xff\\xff\\x01\\x02\\x03\\x04\",\n                sizeof(a.ip6)) == 0);\n\n  memset(a.ip6, 0xaa, sizeof(a.ip6));\n  ASSERT(mg_aton(mg_str(\"::1\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(\n      memcmp(a.ip6,\n             \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\",\n             sizeof(a.ip6)) == 0);\n\n  memset(a.ip6, 0xaa, sizeof(a.ip6));\n  ASSERT(mg_aton(mg_str(\"1::\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(\n      memcmp(a.ip6,\n             \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n             sizeof(a.ip6)) == 0);\n\n  memset(a.ip6, 0xaa, sizeof(a.ip6));\n  ASSERT(mg_aton(mg_str(\"2001:4860:4860::8888\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(\n      memcmp(a.ip6,\n             \"\\x20\\x01\\x48\\x60\\x48\\x60\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x88\\x88\",\n             sizeof(a.ip6)) == 0);\n\n  ASSERT(strcmp(mg_hex(\"abc\", 3, buf), \"616263\") == 0);\n  ASSERT(mg_url_decode(\"a=%\", 3, buf, sizeof(buf), 0) < 0);\n  ASSERT(mg_url_decode(\"&&&a=%\", 6, buf, sizeof(buf), 0) < 0);\n\n  {\n    size_t n;\n    ASSERT((n = mg_url_encode(\"\", 0, buf, sizeof(buf))) == 0);\n    ASSERT((n = mg_url_encode(\"a\", 1, buf, 0)) == 0);\n    ASSERT((n = mg_url_encode(\"a\", 1, buf, sizeof(buf))) == 1);\n    ASSERT(strncmp(buf, \"a\", n) == 0);\n    ASSERT((n = mg_url_encode(\"._-~\", 4, buf, sizeof(buf))) == 4);\n    ASSERT(strncmp(buf, \"._-~\", n) == 0);\n    ASSERT((n = mg_url_encode(\"a@%>\", 4, buf, sizeof(buf))) == 10);\n    ASSERT(strncmp(buf, \"a%40%25%3e\", n) == 0);\n    ASSERT((n = mg_url_encode(\"a@b.c\", 5, buf, sizeof(buf))) == 7);\n    ASSERT(strncmp(buf, \"a%40b.c\", n) == 0);\n  }\n\n  {\n    s = mg_mprintf(\"%3d\", 123);\n    ASSERT(strcmp(s, \"123\") == 0);\n    free(s);\n  }\n\n  ASSERT(mg_to64(mg_str(\"-9223372036854775809\")) == 0);\n  ASSERT(mg_to64(mg_str(\"9223372036854775800\")) == 0);\n  ASSERT(mg_to64(mg_str(\"9223372036854775700\")) > 0);\n  ASSERT(mg_tou64(mg_str(\"0\")) == 0);\n  ASSERT(mg_tou64(mg_str(\"123\")) == 123);\n  ASSERT(mg_tou64(mg_str(\"\")) == 0);\n  ASSERT(mg_tou64(mg_str(\"-\")) == 0);\n  ASSERT(mg_tou64(mg_str(\"18446744073709551615\")) == 18446744073709551615U);\n\n  {\n    size_t i;\n    memset(buf, ' ', sizeof(buf));\n    mg_random_str(buf, 0);\n    ASSERT(buf[0] == ' ');\n    mg_random_str(buf, 1);\n    ASSERT(buf[0] == '\\0');\n    ASSERT(buf[1] == ' ');\n    mg_random_str(buf, sizeof(buf));\n    ASSERT(buf[sizeof(buf) - 1] == '\\0');\n    for (i = 0; i < sizeof(buf) - 1; i++) ASSERT(isalnum((uint8_t) buf[i]));\n  }\n}\n\nstatic void test_crc32(void) {\n  //  echo -n aaa | cksum -o3\n  ASSERT(mg_crc32(0, 0, 0) == 0);\n  ASSERT(mg_crc32(0, \"a\", 1) == 3904355907);\n  ASSERT(mg_crc32(0, \"abc\", 3) == 891568578);\n  ASSERT(mg_crc32(mg_crc32(0, \"ab\", 2), \"c\", 1) == 891568578);\n}\n\nstatic void us(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  int del = *(int *) fn_data;\n  struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n  if (ev == MG_EV_HTTP_CHUNK && mg_http_match_uri(hm, \"/upload\")) {\n    MG_DEBUG((\"Got chunk len %lu\", (unsigned long) hm->chunk.len));\n    MG_DEBUG((\"Query string: [%.*s]\", (int) hm->query.len, hm->query.ptr));\n    // MG_DEBUG((\"Chunk data:\\n%.*s\", (int) hm->chunk.len, hm->chunk.ptr));\n    if (del) {\n      mg_http_delete_chunk(c, hm);\n      if (hm->chunk.len == 0) {\n        MG_DEBUG((\"Last chunk received, sending response\"));\n        mg_http_reply(c, 200, \"\", \"ok (chunked)\\n\");\n      }\n    }\n  } else if (ev == MG_EV_HTTP_MSG && mg_http_match_uri(hm, \"/upload\")) {\n    MG_DEBUG((\"Got all %lu bytes!\", (unsigned long) hm->body.len));\n    MG_DEBUG((\"Query string: [%.*s]\", (int) hm->query.len, hm->query.ptr));\n    // MG_DEBUG((\"Body:\\n%.*s\", (int) hm->body.len, hm->body.ptr));\n    mg_http_reply(c, 200, \"\", \"ok (%d %.*s)\\n\", (int) hm->body.len,\n                  (int) hm->body.len, hm->body.ptr);\n  } else if (ev == MG_EV_HTTP_MSG) {\n    mg_http_reply(c, 200, \"\", \"ok\\n\");\n  }\n  (void) fn_data;\n}\n\nstatic void uc(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  const char **s = (const char **) fn_data;\n  if (ev == MG_EV_OPEN) {\n    c->is_hexdumping = 1;\n  } else if (ev == MG_EV_CONNECT) {\n    mg_printf(c,\n              \"POST /upload HTTP/1.0\\r\\n\"\n              \"Transfer-Encoding: chunked\\r\\n\\r\\n\");\n    mg_http_printf_chunk(c, \"%s\", \"foo\\n\");\n    mg_http_printf_chunk(c, \"%s\", \"bar\\n\");\n    mg_http_printf_chunk(c, \"\");\n  } else if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    ASSERT(mg_strcmp(hm->body, mg_str(*s)) == 0);\n    *s = NULL;\n  }\n  (void) fn_data;\n}\n\nstatic void test_http_upload(void) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12352\";\n  int i, del = 1;\n  const char *s1 = \"ok (chunked)\\n\";\n  const char *s2 = \"ok (8 foo\\nbar\\n)\\n\";\n\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, us, (void *) &del);\n\n  mg_http_connect(&mgr, url, uc, (void *) &s1);\n  for (i = 0; i < 20; i++) mg_mgr_poll(&mgr, 5);\n  ASSERT(s1 == NULL);\n\n  del = 0;\n  mg_http_connect(&mgr, url, uc, (void *) &s2);\n  for (i = 0; i < 20; i++) mg_mgr_poll(&mgr, 5);\n  ASSERT(s2 == NULL);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\n#define LONG_CHUNK \"chunk with length taking up more than two hex digits\"\n\nstatic void eX(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    mg_printf(c, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\");\n    c->data[0] = 1;\n    c->is_hexdumping = 1;\n  } else if (ev == MG_EV_POLL && c->data[0] != 0) {\n    c->data[0]++;\n    if (c->data[0] == 10) mg_http_printf_chunk(c, \"a\");\n    if (c->data[0] == 20) {\n      mg_http_printf_chunk(c, \"b\");\n      mg_http_printf_chunk(c, \"c\");\n    }\n    if (c->data[0] == 30) {\n      mg_http_printf_chunk(c, \"d\");\n      mg_http_printf_chunk(c, \"\");\n      c->data[0] = 0;\n    }\n  }\n  (void) ev_data, (void) fn_data;\n}\n\nstatic void eY(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    mg_printf(c, \"HTTP/1.1 200 OK\\r\\nContent-Length: 4\\r\\n\\r\\n\");\n    c->data[0] = 1;\n  } else if (ev == MG_EV_POLL && c->data[0] != 0) {\n    c->data[0]++;\n    if (c->data[0] == 10) mg_send(c, \"a\", 1);\n    if (c->data[0] == 12) mg_send(c, \"bc\", 2);\n    if (c->data[0] == 30) mg_send(c, \"d\", 1), c->is_resp = 0, c->data[0] = 0;\n  }\n  (void) ev_data, (void) fn_data;\n}\n\nstatic void eZ(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    mg_http_reply(c, 200, \"\", \"abcd\");\n  }\n  (void) ev_data, (void) fn_data;\n}\n\n// Do not delete chunks as they arrive\nstatic void eh4(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  uint32_t *crc = (uint32_t *) fn_data;\n  if (ev == MG_EV_HTTP_CHUNK) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    *crc = mg_crc32(*crc, hm->chunk.ptr, hm->chunk.len);\n    *crc = mg_crc32(*crc, \"x\", 1);\n    MG_INFO((\"%lu C [%.*s]\", c->id, (int) hm->chunk.len, hm->chunk.ptr));\n  } else if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    *crc = mg_crc32(*crc, hm->body.ptr, hm->body.len);\n    MG_INFO((\"%lu M [%.*s]\", c->id, (int) hm->body.len, hm->body.ptr));\n  }\n}\n\n// Streaming client event handler. Delete chunks as they arrive\nstatic void eh5(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  uint32_t *crc = (uint32_t *) fn_data;\n  if (ev == MG_EV_HTTP_CHUNK) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    *crc = mg_crc32(*crc, hm->chunk.ptr, hm->chunk.len);\n    *crc = mg_crc32(*crc, \"x\", 1);\n    MG_INFO((\"%lu DELC [%.*s]\", c->id, (int) hm->chunk.len, hm->chunk.ptr));\n    mg_http_delete_chunk(c, hm);\n  } else if (ev == MG_EV_HTTP_MSG) {\n    ASSERT(0);  // Must not be here, MSG must not be fired: chunks deleted!\n  }\n}\n\nstatic void test_http_chunked_case(mg_event_handler_t s, mg_event_handler_t c,\n                                   int req_count, const char *expected) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12344\";\n  uint32_t i, crc = 0, expected_crc = mg_crc32(0, expected, strlen(expected));\n  struct mg_connection *conn;\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, s, NULL);\n  conn = mg_http_connect(&mgr, url, c, &crc);\n  while (conn != NULL && req_count-- > 0) {\n    mg_printf(conn, \"GET / HTTP/1.0\\n\\n\");\n  }\n  for (i = 0; i < 100 && crc != expected_crc; i++) {\n    mg_mgr_poll(&mgr, 1);\n  }\n  ASSERT(i < 100);\n  ASSERT(crc == expected_crc);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_http_chunked(void) {\n  // Non-chunked encoding\n  test_http_chunked_case(eY, eh4, 1, \"axbcxdxxabcd\");  // Chunks not deleted\n  test_http_chunked_case(eY, eh4, 2, \"axbcxdxxabcdaxbcxdxxabcd\");\n  test_http_chunked_case(eY, eh5, 1, \"axbcxdxx\");  // Chunks deleted\n  test_http_chunked_case(eY, eh5, 2, \"axbcxdxxaxbcxdxx\");\n  test_http_chunked_case(eZ, eh4, 1, \"abcdxxabcd\");  // Not deleted\n  test_http_chunked_case(eZ, eh4, 2, \"abcdxxabcdabcdxxabcd\");\n  test_http_chunked_case(eZ, eh5, 1, \"abcdxx\");  // Deleted\n  test_http_chunked_case(eZ, eh5, 2, \"abcdxxabcdxx\");\n\n  // Chunked encoding\n  test_http_chunked_case(eX, eh4, 1, \"axbxcxdxxabcd\");  // Chunks not deleted\n  test_http_chunked_case(eX, eh5, 1, \"axbxcxdxx\");      // Chunks deleted\n  test_http_chunked_case(eX, eh4, 2, \"axbxcxdxxabcdaxbxcxdxxabcd\");\n  test_http_chunked_case(eX, eh5, 2, \"axbxcxdxxaxbxcxdxx\");\n}\n\nstatic void test_invalid_listen_addr(void) {\n  struct mg_mgr mgr;\n  struct mg_connection *c;\n  mg_mgr_init(&mgr);\n  c = mg_http_listen(&mgr, \"invalid:31:14\", eh1, NULL);\n  ASSERT(c == NULL);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstruct stream_status {\n  uint32_t polls;\n  size_t sent;\n  size_t received;\n  uint32_t send_crc;\n  uint32_t recv_crc;\n};\n\n// Consume recv buffer after letting it reach MG_MAX_RECV_SIZE\nstatic void eh8(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  struct stream_status *status = (struct stream_status *) fn_data;\n  if (c->is_listening) return;\n\n  ASSERT(c->recv.len <= MG_MAX_RECV_SIZE);\n\n  if (ev == MG_EV_ACCEPT) {\n    // Optimize recv buffer size near max to speed up test\n    mg_iobuf_resize(&c->recv, MG_MAX_RECV_SIZE - MG_IO_SIZE);\n    status->received = 0;\n    status->recv_crc = 0;\n  }\n\n  if (ev == MG_EV_CLOSE) {\n    ASSERT(status->received == status->sent);\n  }\n\n  // Let buffer fill up and start consuming after 10 full buffer poll events\n  if (status->polls >= 10 && ev == MG_EV_POLL) {\n    // consume at most a third of MG_MAX_RECV_SIZE on each poll\n    size_t consume;\n    if (MG_MAX_RECV_SIZE / 3 >= c->recv.len)\n      consume = c->recv.len;\n    else\n      consume = MG_MAX_RECV_SIZE / 3;\n    status->received += consume;\n    status->recv_crc =\n        mg_crc32(status->recv_crc, (const char *) c->recv.buf, consume);\n    mg_iobuf_del(&c->recv, 0, consume);\n  }\n\n  // count polls with full buffer to ensure c->is_full prevents reads\n  if (ev == MG_EV_POLL && c->recv.len == MG_MAX_RECV_SIZE) status->polls += 1;\n  (void) ev_data;\n}\n\n// Toggle c->is_full to prevent max_recv_buf_size reached read errors\nstatic void eh10(struct mg_connection *c, int ev, void *ev_data,\n                 void *fn_data) {\n  if (c->recv.len >= MG_MAX_RECV_SIZE && ev == MG_EV_READ) c->is_full = true;\n\n  eh8(c, ev, ev_data, fn_data);\n\n  if (c->recv.len < MG_MAX_RECV_SIZE && ev == MG_EV_POLL) c->is_full = false;\n}\n\n// Send buffer larger than MG_MAX_RECV_SIZE to server\nstatic void eh11(struct mg_connection *c, int ev, void *ev_data,\n                 void *fn_data) {\n  struct stream_status *status = (struct stream_status *) fn_data;\n  if (ev == MG_EV_CONNECT) {\n    size_t len = MG_MAX_RECV_SIZE * 2;\n    struct mg_iobuf buf = {NULL, 0, 0, 0};\n    mg_iobuf_init(&buf, len, 0);\n    mg_random(buf.buf, buf.size);\n    buf.len = buf.size;\n    mg_send(c, buf.buf, buf.len);\n    status->sent = buf.len;\n    status->send_crc = mg_crc32(0, (const char *) buf.buf, buf.len);\n    mg_iobuf_free(&buf);\n  }\n  (void) ev_data;\n  (void) fn_data;\n}\n\nstatic void test_http_stream_buffer(void) {\n  struct mg_mgr mgr;\n  const char *url = \"tcp://127.0.0.1:12344\";\n  uint32_t i;\n  struct stream_status status;\n  mg_mgr_init(&mgr);\n  mg_listen(&mgr, url, eh10, &status);\n\n  status.polls = 0;\n  mg_connect(&mgr, url, eh11, &status);\n  for (i = 0; i < (MG_MAX_RECV_SIZE / MG_IO_SIZE) * 50; i++) {\n    mg_mgr_poll(&mgr, 1);\n    if (status.polls >= 10 && status.sent == status.received) break;\n  }\n  ASSERT(status.sent == status.received);\n  ASSERT(status.send_crc == status.recv_crc);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_multipart(void) {\n  struct mg_http_part part;\n  size_t ofs;\n  const char *s =\n      \"--xyz\\r\\n\"\n      \"Content-Disposition: form-data; name=\\\"val\\\"\\r\\n\"\n      \"\\r\\n\"\n      \"abc\\r\\ndef\\r\\n\"\n      \"--xyz\\r\\n\"\n      \"Content-Disposition: form-data; name=\\\"foo\\\"; filename=\\\"a b.txt\\\"\\r\\n\"\n      \"Content-Type: text/plain\\r\\n\"\n      \"\\r\\n\"\n      \"hello world\\r\\n\"\n      \"\\r\\n\"\n      \"--xyz--\\r\\n\";\n  ASSERT(mg_http_next_multipart(mg_str(\"\"), 0, NULL) == 0);\n  ASSERT((ofs = mg_http_next_multipart(mg_str(s), 0, &part)) > 0);\n  ASSERT(mg_strcmp(part.name, mg_str(\"val\")) == 0);\n  // MG_INFO((\"--> [%.*s]\", (int) part.body.len, part.body.ptr));\n  ASSERT(mg_strcmp(part.body, mg_str(\"abc\\r\\ndef\")) == 0);\n  ASSERT(part.filename.len == 0);\n  ASSERT((ofs = mg_http_next_multipart(mg_str(s), ofs, &part)) > 0);\n  ASSERT(mg_strcmp(part.name, mg_str(\"foo\")) == 0);\n  // MG_INFO((\"--> [%.*s]\", (int) part.filename.len, part.filename.ptr));\n  ASSERT(mg_strcmp(part.filename, mg_str(\"a b.txt\")) == 0);\n  ASSERT(mg_strcmp(part.body, mg_str(\"hello world\\r\\n\")) == 0);\n  ASSERT(mg_http_next_multipart(mg_str(s), ofs, &part) == 0);\n}\n\nstatic void eh7(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    struct mg_http_serve_opts sopts;\n    memset(&sopts, 0, sizeof(sopts));\n    sopts.root_dir = \"/\";\n    sopts.fs = &mg_fs_packed;\n    mg_http_serve_dir(c, hm, &sopts);\n  }\n  (void) fn_data;\n}\n\nstatic void test_packed(void) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12351\";\n  char buf[FETCH_BUF_SIZE],\n      *data = mg_file_read(&mg_fs_posix, \"Makefile\", NULL);\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, eh7, NULL);\n\n  // Load top level file directly\n  // fetch(&mgr, buf, url, \"GET /Makefile HTTP/1.0\\n\\n\");\n  // printf(\"---> %s\\n\", buf);\n  ASSERT(fetch(&mgr, buf, url, \"GET /Makefile HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, data) == 0);\n  free(data);\n\n  // Load file deeper in the FS tree directly\n  data = mg_file_read(&mg_fs_posix, \"src/ssi.h\", NULL);\n  ASSERT(fetch(&mgr, buf, url, \"GET /src/ssi.h HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, data) == 0);\n  free(data);\n\n  // List root dir\n  ASSERT(fetch(&mgr, buf, url, \"GET / HTTP/1.0\\n\\n\") == 200);\n  // printf(\"--------\\n%s\\n\", buf);\n\n  // List nested dir\n  ASSERT(fetch(&mgr, buf, url, \"GET /test HTTP/1.0\\n\\n\") == 301);\n  ASSERT(fetch(&mgr, buf, url, \"GET /test/ HTTP/1.0\\n\\n\") == 200);\n  // printf(\"--------\\n%s\\n\", buf);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void eh6(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_READ) *(int *) fn_data = 1;\n  (void) c, (void) ev_data;\n}\n\n#if (MG_ENABLE_SOCKET == 0)\nint send(int sock, const void *buf, size_t len, int flags);\nint send(int sock, const void *buf, size_t len, int flags) {\n  (void) sock, (void) buf, (void) len, (void) flags;\n  return -1;\n}\n#endif\n\nstatic void test_pipe_proto(bool is_udp) {\n  struct mg_mgr mgr;\n  int i, sock, done = 0;\n  mg_mgr_init(&mgr);\n  ASSERT((sock = mg_mkpipe(&mgr, eh6, (void *) &done, is_udp)) >= 0);\n  ASSERT(send(sock, \"hi\", 2, 0) == 2);\n  for (i = 0; i < 10 && done == 0; i++) mg_mgr_poll(&mgr, 1);\n  ASSERT(done == 1);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_pipe(void) {\n  test_pipe_proto(true);\n  test_pipe_proto(false);\n}\n\nstatic void u1(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_CONNECT) {\n    ((int *) fn_data)[0] += 1;\n    mg_send(c, \"hi\", 2);\n  } else if (ev == MG_EV_WRITE) {\n    ((int *) fn_data)[0] += 100;\n  } else if (ev == MG_EV_READ) {\n    ((int *) fn_data)[0] += 10;\n    mg_iobuf_free(&c->recv);\n  }\n  (void) ev_data;\n}\n\nstatic void test_udp(void) {\n  struct mg_mgr mgr;\n  const char *url = \"udp://127.0.0.1:12353\";\n  int i, done = 0;\n  mg_mgr_init(&mgr);\n  mg_listen(&mgr, url, u1, (void *) &done);\n  mg_connect(&mgr, url, u1, (void *) &done);\n  for (i = 0; i < 5; i++) mg_mgr_poll(&mgr, 1);\n  // MG_INFO((\"%d\", done));\n  ASSERT(done == 111);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_check_ip_acl(void) {\n  uint32_t ip = mg_htonl(0x01020304);\n  ASSERT(mg_check_ip_acl(mg_str(NULL), ip) == 1);\n  ASSERT(mg_check_ip_acl(mg_str(\"\"), ip) == 1);\n  ASSERT(mg_check_ip_acl(mg_str(\"invalid\"), ip) == -1);\n  ASSERT(mg_check_ip_acl(mg_str(\"+hi\"), ip) == -2);\n  ASSERT(mg_check_ip_acl(mg_str(\"+//\"), ip) == -2);\n  ASSERT(mg_check_ip_acl(mg_str(\"-0.0.0.0/0\"), ip) == 0);\n  ASSERT(mg_check_ip_acl(mg_str(\"-0.0.0.0/0,+1.0.0.0/8\"), ip) == 1);\n  ASSERT(mg_check_ip_acl(mg_str(\"-0.0.0.0/0,+1.2.3.4\"), ip) == 1);\n  ASSERT(mg_check_ip_acl(mg_str(\"-0.0.0.0/0,+1.0.0.0/16\"), ip) == 0);\n}\n\nstatic void w3(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  // MG_INFO((\"ev %d\", ev));\n  if (ev == MG_EV_WS_OPEN) {\n    char buf[8192];\n    memset(buf, 'A', sizeof(buf));\n    mg_ws_send(c, \"hi there!\", 9, WEBSOCKET_OP_TEXT);\n    mg_ws_printf(c, WEBSOCKET_OP_TEXT, \"%s\", \"hi there2!\");\n    mg_printf(c, \"%s\", \"boo\");\n    mg_ws_wrap(c, 3, WEBSOCKET_OP_TEXT);\n    mg_ws_send(c, buf, sizeof(buf), WEBSOCKET_OP_TEXT);\n  } else if (ev == MG_EV_WS_MSG) {\n    struct mg_ws_message *wm = (struct mg_ws_message *) ev_data;\n    ASSERT(mg_strcmp(wm->data, mg_str(\"lebowski\")) == 0);\n    ((int *) fn_data)[0]++;\n  } else if (ev == MG_EV_CLOSE) {\n    ((int *) fn_data)[0] += 10;\n  }\n}\n\nstatic void w2(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  struct mg_str msg = mg_str_n(\"lebowski\", 8);\n  if (ev == MG_EV_HTTP_MSG) {\n    mg_ws_upgrade(c, (struct mg_http_message *) ev_data, NULL);\n  } else if (ev == MG_EV_WS_OPEN) {\n    mg_ws_send(c, \"x\", 1, WEBSOCKET_OP_PONG);\n  } else if (ev == MG_EV_POLL && c->is_websocket) {\n    size_t ofs, n = (size_t) fn_data;\n    if (n < msg.len) {\n      // Send \"msg\" char by char using fragmented frames\n      // mg_ws_send() sets the FIN flag in the WS header. Clean it\n      // to send fragmented packet. Insert PONG messages between frames\n      uint8_t op = n == 0 ? WEBSOCKET_OP_TEXT : WEBSOCKET_OP_CONTINUE;\n      mg_ws_send(c, \":->\", 3, WEBSOCKET_OP_PING);\n      ofs = c->send.len;\n      mg_ws_send(c, &msg.ptr[n], 1, op);\n      if (n < msg.len - 1) c->send.buf[ofs] = op;  // Clear FIN flag\n      c->fn_data = (void *) (n + 1);               // Point to the next char\n    } else {\n      mg_ws_send(c, \"\", 0, WEBSOCKET_OP_CLOSE);\n    }\n  } else if (ev == MG_EV_WS_MSG) {\n    struct mg_ws_message *wm = (struct mg_ws_message *) ev_data;\n    MG_INFO((\"Got WS, %lu\", wm->data.len));\n    // mg_hexdump(wm->data.ptr, wm->data.len);\n    if (wm->data.len == 9) {\n      ASSERT(mg_strcmp(wm->data, mg_str(\"hi there!\")) == 0);\n    } else if (wm->data.len == 10) {\n      ASSERT(mg_strcmp(wm->data, mg_str(\"hi there2!\")) == 0);\n    } else if (wm->data.len == 3) {\n      ASSERT(mg_strcmp(wm->data, mg_str(\"boo\")) == 0);\n    } else {\n      MG_INFO((\"%lu\", wm->data.len));\n      ASSERT(wm->data.len == 8192);\n    }\n  }\n}\n\nstatic void test_ws_fragmentation(void) {\n  const char *url = \"ws://localhost:12357/ws\";\n  struct mg_mgr mgr;\n  int i, done = 0;\n\n  mg_mgr_init(&mgr);\n  ASSERT(mg_http_listen(&mgr, url, w2, NULL) != NULL);\n  mg_ws_connect(&mgr, url, w3, &done, \"%s\", \"Sec-WebSocket-Protocol: echo\\r\\n\");\n  for (i = 0; i < 25; i++) mg_mgr_poll(&mgr, 1);\n  // MG_INFO((\"--> %d\", done));\n  ASSERT(done == 11);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void h7(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    struct mg_http_serve_opts opts;\n    memset(&opts, 0, sizeof(opts));\n    opts.root_dir = \"./test/data,/foo=./src\";\n    mg_http_serve_dir(c, hm, &opts);\n  }\n  (void) fn_data;\n}\n\nstatic void test_rewrites(void) {\n  char buf[FETCH_BUF_SIZE];\n  const char *url = \"http://LOCALHOST:12358\";\n  const char *expected = \"#define MG_VERSION \\\"\" MG_VERSION \"\\\"\\n\";\n  struct mg_mgr mgr;\n  mg_mgr_init(&mgr);\n  ASSERT(mg_http_listen(&mgr, url, h7, NULL) != NULL);\n  ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n  ASSERT(fetch(&mgr, buf, url, \"GET /foo/version.h HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, expected) == 0);\n  ASSERT(fetch(&mgr, buf, url, \"GET /foo HTTP/1.0\\n\\n\") == 301);\n  ASSERT(fetch(&mgr, buf, url, \"GET /foo/ HTTP/1.0\\n\\n\") == 200);\n  // printf(\"-->[%s]\\n\", buf);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_get_header_var(void) {\n  struct mg_str empty = mg_str(\"\"), bar = mg_str(\"bar\"), baz = mg_str(\"baz\");\n  struct mg_str header = mg_str(\"Digest foo=\\\"bar\\\", blah,boo=baz, x=\\\"yy\\\"\");\n  struct mg_str yy = mg_str(\"yy\");\n  // struct mg_str x = mg_http_get_header_var(header, mg_str(\"x\"));\n  // MG_INFO((\"--> [%d] [%d]\", (int) x.len, yy.len));\n  ASSERT(mg_strcmp(empty, mg_http_get_header_var(empty, empty)) == 0);\n  ASSERT(mg_strcmp(empty, mg_http_get_header_var(header, empty)) == 0);\n  ASSERT(mg_strcmp(empty, mg_http_get_header_var(header, mg_str(\"fooo\"))) == 0);\n  ASSERT(mg_strcmp(empty, mg_http_get_header_var(header, mg_str(\"fo\"))) == 0);\n  ASSERT(mg_strcmp(empty, mg_http_get_header_var(header, mg_str(\"blah\"))) == 0);\n  ASSERT(mg_strcmp(bar, mg_http_get_header_var(header, mg_str(\"foo\"))) == 0);\n  ASSERT(mg_strcmp(baz, mg_http_get_header_var(header, mg_str(\"boo\"))) == 0);\n  ASSERT(mg_strcmp(yy, mg_http_get_header_var(header, mg_str(\"x\"))) == 0);\n}\n\nstatic void test_json(void) {\n  const char *s1 = \"{\\\"a\\\":{},\\\"b\\\":7,\\\"c\\\":[[],2]}\";\n  const char *s2 = \"{\\\"a\\\":{\\\"b1\\\":{}},\\\"c\\\":7,\\\"d\\\":{\\\"b2\\\":{}}}\";\n  int n;\n  struct mg_str json;\n\n  ASSERT(mg_json_get(mg_str_n(\" true \", 6), \"\", &n) == MG_JSON_INVALID);\n  ASSERT(mg_json_get(mg_str_n(\" true \", 6), \"$\", &n) == 1 && n == 4);\n  ASSERT(mg_json_get(mg_str_n(\"null \", 5), \"$\", &n) == 0 && n == 4);\n  json = mg_str(\"  \\\"hi\\\\nthere\\\"\");\n  ASSERT(mg_json_get(json, \"$\", &n) == 2 && n == 11);\n  ASSERT(mg_json_get(mg_str_n(\" { } \", 5), \"$\", &n) == 1);\n  ASSERT(mg_json_get(mg_str_n(\" [[]]\", 5), \"$\", &n) == 1);\n  ASSERT(mg_json_get(mg_str_n(\" [ ]  \", 5), \"$\", &n) == 1);\n\n  ASSERT(mg_json_get(mg_str_n(\"[1,2]\", 5), \"$\", &n) == 0 && n == 5);\n  ASSERT(mg_json_get(mg_str_n(\"[1,2]\", 5), \"$[0]\", &n) == 1 && n == 1);\n  ASSERT(mg_json_get(mg_str_n(\"[1,2]\", 5), \"$[1]\", &n) == 3 && n == 1);\n  ASSERT(mg_json_get(mg_str_n(\"[1,2]\", 5), \"$[3]\", &n) == MG_JSON_NOT_FOUND);\n\n  json = mg_str(\"{\\\"a\\\":[]}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 2);\n  json = mg_str(\"{\\\"a\\\":[1,2]}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 5);\n  json = mg_str(\"{\\\"a\\\":[1,[1]]}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 7);\n  json = mg_str(\"{\\\"a\\\":[[]]}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 4);\n  json = mg_str(\"{\\\"a\\\":[[1,2]]}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 7);\n  json = mg_str(\"{\\\"a\\\":{}}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 2);\n  json = mg_str(\"{\\\"a\\\":{\\\"a\\\":{}}}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 8);\n  json = mg_str(\"{\\\"a\\\":{\\\"a\\\":[]}}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 8);\n\n  json = mg_str(\"[[1,[2,3]],4]\");\n  ASSERT(mg_json_get(json, \"$\", &n) == 0 && n == 13);\n  ASSERT(mg_json_get(json, \"$[0]\", &n) == 1 && n == 9);\n  ASSERT(mg_json_get(json, \"$[1]\", &n) == 11);\n  ASSERT(mg_json_get(json, \"$[1]\", &n) == 11 && n == 1);\n  ASSERT(mg_json_get(json, \"$[2]\", &n) == MG_JSON_NOT_FOUND);\n  ASSERT(mg_json_get(json, \"$[0][0]\", &n) == 2 && n == 1);\n  ASSERT(mg_json_get(json, \"$[0][1]\", &n) == 4 && n == 5);\n  ASSERT(mg_json_get(json, \"$[0][2]\", &n) == MG_JSON_NOT_FOUND);\n  ASSERT(mg_json_get(json, \"$[0][1][0]\", &n) == 5 && n == 1);\n  ASSERT(mg_json_get(json, \"$[0][1][1]\", &n) == 7 && n == 1);\n\n  json = mg_str(\"[[1,2],3]\");\n  ASSERT(mg_json_get(json, \"$\", &n) == 0 && n == 9);\n  ASSERT(mg_json_get(json, \"$[0][0]\", &n) == 2 && n == 1);\n  ASSERT(mg_json_get(json, \"$[0][1]\", &n) == 4 && n == 1);\n  ASSERT(mg_json_get(json, \"$[0][2]\", &n) == MG_JSON_NOT_FOUND);\n  ASSERT(mg_json_get(json, \"$[1][0]\", &n) == MG_JSON_NOT_FOUND);\n  ASSERT(mg_json_get(json, \"$[1]\", &n) == 7 && n == 1);\n  ASSERT(mg_json_get(json, \"$[1][0]\", &n) == MG_JSON_NOT_FOUND);\n\n  ASSERT(mg_json_get(json, \"$\", &n) == 0 && n == 9);\n  ASSERT(mg_json_get(json, \"$[1][0]\", &n) == MG_JSON_NOT_FOUND);\n  ASSERT(mg_json_get(json, \"$[0][1]\", &n) == 4 && n == 1);\n\n  json = mg_str(s1);\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 2);\n  ASSERT(mg_json_get(json, \"$.b\", &n) == 12 && n == 1);\n  ASSERT(mg_json_get(json, \"$.c\", &n) == 18 && n == 6);\n  ASSERT(mg_json_get(json, \"$.c[0]\", &n) == 19 && n == 2);\n  ASSERT(mg_json_get(json, \"$.c[1]\", &n) == 22 && n == 1);\n  ASSERT(mg_json_get(json, \"$.c[3]\", &n) == MG_JSON_NOT_FOUND);\n\n  json = mg_str(s2);\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 9);\n  ASSERT(mg_json_get(json, \"$.a.b1\", &n) == 11 && n == 2);\n  ASSERT(mg_json_get(json, \"$.a.b2\", &n) == MG_JSON_NOT_FOUND);\n  ASSERT(mg_json_get(json, \"$.a.b\", &n) == MG_JSON_NOT_FOUND);\n  ASSERT(mg_json_get(json, \"$.a1\", &n) == MG_JSON_NOT_FOUND);\n  ASSERT(mg_json_get(json, \"$.c\", &n) == 19 && n == 1);\n\n  {\n    double d = 0;\n    bool b = false;\n    int len;\n    char *str = NULL;\n\n    json = mg_str(\"{\\\"a\\\":\\\"b\\\"}\");\n    str = mg_json_get_str(json, \"$.a\");\n    ASSERT(str != NULL);\n    // printf(\"---> [%s]\\n\", str);\n    ASSERT(strcmp(str, \"b\") == 0);\n    free(str);\n\n    json = mg_str(\"{\\\"a\\\": \\\"hi\\\\nthere\\\",\\\"b\\\": [12345, true]}\");\n    str = mg_json_get_str(json, \"$.a\");\n\n    ASSERT(str != NULL);\n    ASSERT(strcmp(str, \"hi\\nthere\") == 0);\n    free(str);\n\n    ASSERT(mg_json_get_long(json, \"$.foo\", -42) == -42);\n    ASSERT(mg_json_get_long(json, \"$.b[0]\", -42) == 12345);\n\n    ASSERT(mg_json_get_num(json, \"$.a\", &d) == false);\n    ASSERT(mg_json_get_num(json, \"$.c\", &d) == false);\n    ASSERT(mg_json_get_num(json, \"$.b[0]\", &d) == true);\n    ASSERT(d == 12345);\n\n    ASSERT(mg_json_get_bool(json, \"$.b\", &b) == false);\n    ASSERT(mg_json_get_bool(json, \"$.b[0]\", &b) == false);\n    ASSERT(mg_json_get_bool(json, \"$.b[1]\", &b) == true);\n    ASSERT(b == true);\n    ASSERT(mg_json_get(json, \"$.b[2]\", &len) < 0);\n\n    json = mg_str(\"[\\\"YWJj\\\", \\\"0100026869\\\"]\");\n    ASSERT((str = mg_json_get_b64(json, \"$[0]\", &len)) != NULL);\n    ASSERT(len == 3 && memcmp(str, \"abc\", (size_t) len) == 0);\n    free(str);\n    ASSERT((str = mg_json_get_hex(json, \"$[1]\", &len)) != NULL);\n    ASSERT(len == 5 && memcmp(str, \"\\x01\\x00\\x02hi\", (size_t) len) == 0);\n    free(str);\n\n    json = mg_str(\"{\\\"a\\\":[1,2,3], \\\"ab\\\": 2}\");\n    ASSERT(mg_json_get_long(json, \"$.a[0]\", -42) == 1);\n    ASSERT(mg_json_get_long(json, \"$.ab\", -42) == 2);\n    ASSERT(mg_json_get_long(json, \"$.ac\", -42) == -42);\n\n    json = mg_str(\"{\\\"a\\\":[],\\\"b\\\":[1,2]}\");\n    ASSERT(mg_json_get_long(json, \"$.a[0]\", -42) == -42);\n    ASSERT(mg_json_get_long(json, \"$.b[0]\", -42) == 1);\n    ASSERT(mg_json_get_long(json, \"$.b[1]\", -42) == 2);\n    ASSERT(mg_json_get_long(json, \"$.b[2]\", -42) == -42);\n    json = mg_str(\"[{\\\"a\\\":1,\\\"b\\\":2},{\\\"a\\\":3, \\\"b\\\":4}]\");\n    ASSERT(mg_json_get_long(json, \"$[0].a\", -42) == 1);\n    ASSERT(mg_json_get_long(json, \"$[0].b\", -42) == 2);\n    ASSERT(mg_json_get_long(json, \"$[1].a\", -42) == 3);\n    ASSERT(mg_json_get_long(json, \"$[1].b\", -42) == 4);\n    ASSERT(mg_json_get_long(json, \"$[2].a\", -42) == -42);\n\n    json = mg_str(\"{\\\"a\\\":[1],\\\"b\\\":[2,3]}\");\n    ASSERT(mg_json_get_long(json, \"$.a[0]\", -42) == 1);\n    ASSERT(mg_json_get_long(json, \"$.a[1]\", -42) == -42);\n\n    json = mg_str(\"{\\\"a\\\":[1,[2,3], 4]}\");\n    ASSERT(mg_json_get_long(json, \"$.a[0]\", -42) == 1);\n    ASSERT(mg_json_get_long(json, \"$.a[1][0]\", -42) == 2);\n    ASSERT(mg_json_get_long(json, \"$.a[1][1]\", -42) == 3);\n    ASSERT(mg_json_get_long(json, \"$.a[1][2]\", -42) == -42);\n    ASSERT(mg_json_get_long(json, \"$.a[2]\", -42) == 4);\n    ASSERT(mg_json_get_long(json, \"$.a[3]\", -42) == -42);\n  }\n\n  json = mg_str(\"{\\\"a\\\":[],\\\"b\\\":[1,2]}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 2);\n  ASSERT(mg_json_get(json, \"$.a[0]\", &n) < 0 && n == 0);\n\n  json = mg_str(\"{\\\"a\\\":{},\\\"b\\\":[1,2]}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 2);\n  ASSERT(mg_json_get(json, \"$.a[0]\", &n) < 0 && n == 0);\n\n  json = mg_str(\"{\\\"a\\\":true,\\\"b\\\":[1,2]}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 4);\n  ASSERT(mg_json_get(json, \"$.a[0]\", &n) < 0 && n == 0);\n\n  json = mg_str(\"{\\\"a\\\":1,\\\"b\\\":[1,2]}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 1);\n  ASSERT(mg_json_get(json, \"$.a[0]\", &n) < 0 && n == 0);\n}\n\nstatic void resp_rpc(struct mg_rpc_req *r) {\n  int len = 0, off = mg_json_get(r->frame, \"$.result\", &len);\n  mg_xprintf(r->pfn, r->pfn_data, \"%.*s\", len, &r->frame.ptr[off]);\n}\n\nstatic void test_rpc(void) {\n  struct mg_rpc *head = NULL;\n  struct mg_iobuf io = {0, 0, 0, 256};\n  struct mg_rpc_req req = {&head, 0, mg_pfn_iobuf, &io, 0, {0, 0}};\n  mg_rpc_add(&head, mg_str(\"rpc.list\"), mg_rpc_list, NULL);\n\n  {\n    req.frame = mg_str(\"{\\\"method\\\":\\\"rpc.list\\\"}\");\n    mg_rpc_process(&req);\n    ASSERT(io.buf == NULL);\n  }\n\n  {\n    const char *resp = \"{\\\"id\\\":1,\\\"result\\\":[\\\"rpc.list\\\"]}\";\n    req.frame = mg_str(\"{\\\"id\\\": 1,\\\"method\\\":\\\"rpc.list\\\"}\");\n    mg_rpc_process(&req);\n    ASSERT(strcmp((char *) io.buf, resp) == 0);\n    mg_iobuf_free(&io);\n  }\n\n  {\n    const char *resp =\n        \"{\\\"id\\\":true,\\\"error\\\":{\\\"code\\\":-32601,\\\"message\\\":\\\"foo not \"\n        \"found\\\"}}\";\n    req.frame = mg_str(\"{\\\"id\\\": true,\\\"method\\\":\\\"foo\\\"}\");\n    mg_rpc_process(&req);\n    // MG_INFO((\"-> %s\", io.buf));\n    ASSERT(strcmp((char *) io.buf, resp) == 0);\n    mg_iobuf_free(&io);\n  }\n\n  {\n    const char *resp =\n        \"{\\\"id\\\":true,\\\"error\\\":{\\\"code\\\":-32601,\\\"message\\\":\\\"foo not \"\n        \"found\\\"}}\";\n    req.frame = mg_str(\"{\\\"id\\\": true,\\\"method\\\":\\\"foo\\\"}\");\n    req.head = NULL;\n    mg_rpc_process(&req);\n    // MG_INFO((\"-> %s\", io.buf));\n    ASSERT(strcmp((char *) io.buf, resp) == 0);\n    mg_iobuf_free(&io);\n    req.head = &head;\n  }\n\n  {\n    const char *resp = \"{\\\"error\\\":{\\\"code\\\":-32700,\\\"message\\\":\\\"haha\\\"}}\";\n    req.frame = mg_str(\"haha\");\n    mg_rpc_process(&req);\n    // MG_INFO((\"-> %s\", io.buf));\n    ASSERT(strcmp((char *) io.buf, resp) == 0);\n    mg_iobuf_free(&io);\n  }\n\n  {\n    const char *resp =\n        \"{\\\"id\\\":1,\\\"error\\\":{\\\"code\\\":-32601,\\\"message\\\":\\\" not found\\\"}}\";\n    req.frame = mg_str(\"{\\\"id\\\":1,\\\"result\\\":123}\");\n    mg_rpc_process(&req);\n    // MG_INFO((\"-> %s\", io.buf));\n    ASSERT(strcmp((char *) io.buf, resp) == 0);\n    mg_iobuf_free(&io);\n  }\n\n  {\n    req.frame = mg_str(\"{\\\"id\\\":1,\\\"result\\\":123}\");\n    mg_rpc_add(&head, mg_str(\"\"), resp_rpc, NULL);\n    mg_rpc_process(&req);\n    MG_INFO((\"-> %s\", io.buf));\n    ASSERT(strcmp((char *) io.buf, \"123\") == 0);\n    mg_iobuf_free(&io);\n  }\n\n  mg_rpc_del(&head, NULL);\n  ASSERT(head == NULL);\n}\n\nstatic void ph(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_POLL) ++(*(int *) fn_data);\n  (void) c, (void) ev_data;\n}\n\nstatic void test_poll(void) {\n  int count = 0, i;\n  struct mg_mgr mgr;\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, \"http://127.0.0.1:12346\", ph, &count);\n  for (i = 0; i < 10; i++) mg_mgr_poll(&mgr, 0);\n  ASSERT(count == 10);\n  mg_mgr_free(&mgr);\n}\n\n#define NMESSAGES 99999\nstatic uint32_t s_qcrc = 0;\nstatic int s_out, s_in;\nstatic void producer(void *param) {\n  struct mg_queue *q = (struct mg_queue *) param;\n  char tmp[64 * 1024], *buf;\n  size_t len, ofs = sizeof(tmp);\n  for (s_out = 0; s_out < NMESSAGES; s_out++) {\n    if (ofs >= sizeof(tmp)) mg_random(tmp, sizeof(tmp)), ofs = 0;\n    len = ((uint8_t *) tmp)[ofs] % 55 + 1;\n    if (ofs + len > sizeof(tmp)) len = sizeof(tmp) - ofs;\n    while ((mg_queue_book(q, &buf, len)) < len) (void) 0;\n    memcpy(buf, &tmp[ofs], len);\n    s_qcrc = mg_crc32(s_qcrc, buf, len);\n    ofs += len;\n#if 0\n    fprintf(stderr, \"-->prod %3d  %8x  %-3lu %zu/%zu/%lu\\n\", s_out, s_qcrc, len, q->tail,\n           q->head, buf - q->buf);\n#endif\n    mg_queue_add(q, len);\n  }\n}\n\nstatic uint32_t consumer(struct mg_queue *q) {\n  uint32_t crc = 0;\n  for (s_in = 0; s_in < NMESSAGES; s_in++) {\n    char *buf;\n    size_t len;\n    while ((len = mg_queue_next(q, &buf)) == 0) (void) 0;\n    crc = mg_crc32(crc, buf, len);\n#if 0\n    fprintf(stderr, \"-->cons %3u  %8x  %-3lu %zu/%zu/%lu\\n\", s_in, crc, len, q->tail,\n           q->head, buf - q->buf);\n#endif\n    mg_queue_del(q, len);\n  }\n  return crc;\n}\n\n#if MG_ARCH == MG_ARCH_WIN32\nstatic void start_thread(void (*f)(void *), void *p) {\n  _beginthread((void(__cdecl *)(void *)) f, 0, p);\n}\n#elif MG_ARCH == MG_ARCH_UNIX\n#include <pthread.h>\nstatic void start_thread(void (*f)(void *), void *p) {\n  union {\n    void (*f1)(void *);\n    void *(*f2)(void *);\n  } u = {f};\n  pthread_t thread_id = (pthread_t) 0;\n  pthread_attr_t attr;\n  (void) pthread_attr_init(&attr);\n  (void) pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n  pthread_create(&thread_id, &attr, u.f2, p);\n  pthread_attr_destroy(&attr);\n}\n#else\nstatic void start_thread(void (*f)(void *), void *p) { (void) f, (void) p; }\n#endif\n\nstatic void test_queue(void) {\n  char buf[512];\n  struct mg_queue queue;\n  uint32_t crc;\n  memset(buf, 0x55, sizeof(buf));\n  mg_queue_init(&queue, buf, sizeof(buf));\n  start_thread(producer, &queue);  // Start producer in a separate thread\n  crc = consumer(&queue);          // Consumer eats data in this thread\n  MG_INFO((\"CRC1 %8x\", s_qcrc));   // Show CRCs\n  MG_INFO((\"CRC2 %8x\", crc));\n  ASSERT(s_qcrc == crc);\n}\n\nint main(void) {\n  const char *debug_level = getenv(\"V\");\n  if (debug_level == NULL) debug_level = \"3\";\n  mg_log_set(atoi(debug_level));\n\n  test_json();\n  test_queue();\n  test_rpc();\n  test_str();\n  test_globmatch();\n  test_get_header_var();\n  test_rewrites();\n  test_check_ip_acl();\n  test_udp();\n  test_pipe();\n  test_packed();\n  test_crc32();\n  test_multipart();\n  test_invalid_listen_addr();\n  test_http_chunked();\n  test_http_upload();\n  test_http_stream_buffer();\n  test_http_parse();\n  test_util();\n  test_dns();\n  test_timer();\n  test_url();\n  test_iobuf();\n  test_commalist();\n  test_base64();\n  test_http_get_var();\n  test_tls();\n  test_ws();\n  test_ws_fragmentation();\n  test_http_client();\n  test_http_server();\n  test_http_404();\n  test_http_no_content_length();\n  test_http_pipeline();\n  test_http_range();\n  test_sntp();\n  test_mqtt();\n  test_poll();\n  printf(\"SUCCESS. Total tests: %d\\n\", s_num_tests);\n\n  return EXIT_SUCCESS;\n}\n"], "fixing_code": ["// Copyright (c) 2004-2013 Sergey Lyubka\n// Copyright (c) 2013-2022 Cesanta Software Limited\n// All rights reserved\n//\n// This software is dual-licensed: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License version 2 as\n// published by the Free Software Foundation. For the terms of this\n// license, see http://www.gnu.org/licenses/\n//\n// You are free to use this software under the terms of the GNU General\n// Public License, but WITHOUT ANY WARRANTY; without even the implied\n// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n// See the GNU General Public License for more details.\n//\n// Alternatively, you can license this software under a commercial\n// license, as set out in https://www.mongoose.ws/licensing/\n//\n// SPDX-License-Identifier: GPL-2.0-only or commercial\n\n#include \"mongoose.h\"\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/base64.c\"\n#endif\n\n\n\nstatic int mg_b64idx(int c) {\n  if (c < 26) {\n    return c + 'A';\n  } else if (c < 52) {\n    return c - 26 + 'a';\n  } else if (c < 62) {\n    return c - 52 + '0';\n  } else {\n    return c == 62 ? '+' : '/';\n  }\n}\n\nstatic int mg_b64rev(int c) {\n  if (c >= 'A' && c <= 'Z') {\n    return c - 'A';\n  } else if (c >= 'a' && c <= 'z') {\n    return c + 26 - 'a';\n  } else if (c >= '0' && c <= '9') {\n    return c + 52 - '0';\n  } else if (c == '+') {\n    return 62;\n  } else if (c == '/') {\n    return 63;\n  } else if (c == '=') {\n    return 64;\n  } else {\n    return -1;\n  }\n}\n\nint mg_base64_update(unsigned char ch, char *to, int n) {\n  int rem = (n & 3) % 3;\n  if (rem == 0) {\n    to[n] = (char) mg_b64idx(ch >> 2);\n    to[++n] = (char) ((ch & 3) << 4);\n  } else if (rem == 1) {\n    to[n] = (char) mg_b64idx(to[n] | (ch >> 4));\n    to[++n] = (char) ((ch & 15) << 2);\n  } else {\n    to[n] = (char) mg_b64idx(to[n] | (ch >> 6));\n    to[++n] = (char) mg_b64idx(ch & 63);\n    n++;\n  }\n  return n;\n}\n\nint mg_base64_final(char *to, int n) {\n  int saved = n;\n  // printf(\"---[%.*s]\\n\", n, to);\n  if (n & 3) n = mg_base64_update(0, to, n);\n  if ((saved & 3) == 2) n--;\n  // printf(\"    %d[%.*s]\\n\", n, n, to);\n  while (n & 3) to[n++] = '=';\n  to[n] = '\\0';\n  return n;\n}\n\nint mg_base64_encode(const unsigned char *p, int n, char *to) {\n  int i, len = 0;\n  for (i = 0; i < n; i++) len = mg_base64_update(p[i], to, len);\n  len = mg_base64_final(to, len);\n  return len;\n}\n\nint mg_base64_decode(const char *src, int n, char *dst) {\n  const char *end = src == NULL ? NULL : src + n;  // Cannot add to NULL\n  int len = 0;\n  while (src != NULL && src + 3 < end) {\n    int a = mg_b64rev(src[0]), b = mg_b64rev(src[1]), c = mg_b64rev(src[2]),\n        d = mg_b64rev(src[3]);\n    if (a == 64 || a < 0 || b == 64 || b < 0 || c < 0 || d < 0) return 0;\n    dst[len++] = (char) ((a << 2) | (b >> 4));\n    if (src[2] != '=') {\n      dst[len++] = (char) ((b << 4) | (c >> 2));\n      if (src[3] != '=') dst[len++] = (char) ((c << 6) | d);\n    }\n    src += 4;\n  }\n  dst[len] = '\\0';\n  return len;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/dns.c\"\n#endif\n\n\n\n\n\n\n\n\nstruct dns_data {\n  struct dns_data *next;\n  struct mg_connection *c;\n  uint64_t expire;\n  uint16_t txnid;\n};\n\nstatic void mg_sendnsreq(struct mg_connection *, struct mg_str *, int,\n                         struct mg_dns *, bool);\n\nstatic void mg_dns_free(struct mg_connection *c, struct dns_data *d) {\n  LIST_DELETE(struct dns_data,\n              (struct dns_data **) &c->mgr->active_dns_requests, d);\n  free(d);\n}\n\nvoid mg_resolve_cancel(struct mg_connection *c) {\n  struct dns_data *tmp, *d = (struct dns_data *) c->mgr->active_dns_requests;\n  for (; d != NULL; d = tmp) {\n    tmp = d->next;\n    if (d->c == c) mg_dns_free(c, d);\n  }\n}\n\nstatic size_t mg_dns_parse_name_depth(const uint8_t *s, size_t len, size_t ofs,\n                                      char *to, size_t tolen, size_t j,\n                                      int depth) {\n  size_t i = 0;\n  if (tolen > 0 && depth == 0) to[0] = '\\0';\n  if (depth > 5) return 0;\n  // MG_INFO((\"ofs %lx %x %x\", (unsigned long) ofs, s[ofs], s[ofs + 1]));\n  while (ofs + i + 1 < len) {\n    size_t n = s[ofs + i];\n    if (n == 0) {\n      i++;\n      break;\n    }\n    if (n & 0xc0) {\n      size_t ptr = (((n & 0x3f) << 8) | s[ofs + i + 1]);  // 12 is hdr len\n      // MG_INFO((\"PTR %lx\", (unsigned long) ptr));\n      if (ptr + 1 < len && (s[ptr] & 0xc0) == 0 &&\n          mg_dns_parse_name_depth(s, len, ptr, to, tolen, j, depth + 1) == 0)\n        return 0;\n      i += 2;\n      break;\n    }\n    if (ofs + i + n + 1 >= len) return 0;\n    if (j > 0) {\n      if (j < tolen) to[j] = '.';\n      j++;\n    }\n    if (j + n < tolen) memcpy(&to[j], &s[ofs + i + 1], n);\n    j += n;\n    i += n + 1;\n    if (j < tolen) to[j] = '\\0';  // Zero-terminate this chunk\n    // MG_INFO((\"--> [%s]\", to));\n  }\n  if (tolen > 0) to[tolen - 1] = '\\0';  // Make sure make sure it is nul-term\n  return i;\n}\n\nstatic size_t mg_dns_parse_name(const uint8_t *s, size_t n, size_t ofs,\n                                char *dst, size_t dstlen) {\n  return mg_dns_parse_name_depth(s, n, ofs, dst, dstlen, 0, 0);\n}\n\nsize_t mg_dns_parse_rr(const uint8_t *buf, size_t len, size_t ofs,\n                       bool is_question, struct mg_dns_rr *rr) {\n  const uint8_t *s = buf + ofs, *e = &buf[len];\n\n  memset(rr, 0, sizeof(*rr));\n  if (len < sizeof(struct mg_dns_header)) return 0;  // Too small\n  if (len > 512) return 0;  //  Too large, we don't expect that\n  if (s >= e) return 0;     //  Overflow\n\n  if ((rr->nlen = (uint16_t) mg_dns_parse_name(buf, len, ofs, NULL, 0)) == 0)\n    return 0;\n  s += rr->nlen + 4;\n  if (s > e) return 0;\n  rr->atype = (uint16_t) (((uint16_t) s[-4] << 8) | s[-3]);\n  rr->aclass = (uint16_t) (((uint16_t) s[-2] << 8) | s[-1]);\n  if (is_question) return (size_t) (rr->nlen + 4);\n\n  s += 6;\n  if (s > e) return 0;\n  rr->alen = (uint16_t) (((uint16_t) s[-2] << 8) | s[-1]);\n  if (s + rr->alen > e) return 0;\n  return (size_t) (rr->nlen + rr->alen + 10);\n}\n\nbool mg_dns_parse(const uint8_t *buf, size_t len, struct mg_dns_message *dm) {\n  const struct mg_dns_header *h = (struct mg_dns_header *) buf;\n  struct mg_dns_rr rr;\n  size_t i, n, ofs = sizeof(*h);\n  memset(dm, 0, sizeof(*dm));\n\n  if (len < sizeof(*h)) return 0;                // Too small, headers dont fit\n  if (mg_ntohs(h->num_questions) > 1) return 0;  // Sanity\n  if (mg_ntohs(h->num_answers) > 10) return 0;   // Sanity\n  dm->txnid = mg_ntohs(h->txnid);\n\n  for (i = 0; i < mg_ntohs(h->num_questions); i++) {\n    if ((n = mg_dns_parse_rr(buf, len, ofs, true, &rr)) == 0) return false;\n    // MG_INFO((\"Q %lu %lu %hu/%hu\", ofs, n, rr.atype, rr.aclass));\n    ofs += n;\n  }\n  for (i = 0; i < mg_ntohs(h->num_answers); i++) {\n    if ((n = mg_dns_parse_rr(buf, len, ofs, false, &rr)) == 0) return false;\n    // MG_INFO((\"A -- %lu %lu %hu/%hu %s\", ofs, n, rr.atype, rr.aclass,\n    // dm->name));\n    mg_dns_parse_name(buf, len, ofs, dm->name, sizeof(dm->name));\n    ofs += n;\n\n    if (rr.alen == 4 && rr.atype == 1 && rr.aclass == 1) {\n      dm->addr.is_ip6 = false;\n      memcpy(&dm->addr.ip, &buf[ofs - 4], 4);\n      dm->resolved = true;\n      break;  // Return success\n    } else if (rr.alen == 16 && rr.atype == 28 && rr.aclass == 1) {\n      dm->addr.is_ip6 = true;\n      memcpy(&dm->addr.ip6, &buf[ofs - 16], 16);\n      dm->resolved = true;\n      break;  // Return success\n    }\n  }\n  return true;\n}\n\nstatic void dns_cb(struct mg_connection *c, int ev, void *ev_data,\n                   void *fn_data) {\n  struct dns_data *d, *tmp;\n  if (ev == MG_EV_POLL) {\n    uint64_t now = *(uint64_t *) ev_data;\n    for (d = (struct dns_data *) c->mgr->active_dns_requests; d != NULL;\n         d = tmp) {\n      tmp = d->next;\n      // MG_DEBUG (\"%lu %lu dns poll\", d->expire, now));\n      if (now > d->expire) mg_error(d->c, \"DNS timeout\");\n    }\n  } else if (ev == MG_EV_READ) {\n    struct mg_dns_message dm;\n    int resolved = 0;\n    if (mg_dns_parse(c->recv.buf, c->recv.len, &dm) == false) {\n      MG_ERROR((\"Unexpected DNS response:\"));\n      mg_hexdump(c->recv.buf, c->recv.len);\n    } else {\n      // MG_VERBOSE((\"%s %d\", dm.name, dm.resolved));\n      for (d = (struct dns_data *) c->mgr->active_dns_requests; d != NULL;\n           d = tmp) {\n        tmp = d->next;\n        // MG_INFO((\"d %p %hu %hu\", d, d->txnid, dm.txnid));\n        if (dm.txnid != d->txnid) continue;\n        if (d->c->is_resolving) {\n          if (dm.resolved) {\n            dm.addr.port = d->c->rem.port;  // Save port\n            d->c->rem = dm.addr;            // Copy resolved address\n            MG_DEBUG(\n                (\"%lu %s is %M\", d->c->id, dm.name, mg_print_ip, &d->c->rem));\n            mg_connect_resolved(d->c);\n#if MG_ENABLE_IPV6\n          } else if (dm.addr.is_ip6 == false && dm.name[0] != '\\0' &&\n                     c->mgr->use_dns6 == false) {\n            struct mg_str x = mg_str(dm.name);\n            mg_sendnsreq(d->c, &x, c->mgr->dnstimeout, &c->mgr->dns6, true);\n#endif\n          } else {\n            mg_error(d->c, \"%s DNS lookup failed\", dm.name);\n          }\n        } else {\n          MG_ERROR((\"%lu already resolved\", d->c->id));\n        }\n        mg_dns_free(c, d);\n        resolved = 1;\n      }\n    }\n    if (!resolved) MG_ERROR((\"stray DNS reply\"));\n    c->recv.len = 0;\n  } else if (ev == MG_EV_CLOSE) {\n    for (d = (struct dns_data *) c->mgr->active_dns_requests; d != NULL;\n         d = tmp) {\n      tmp = d->next;\n      mg_error(d->c, \"DNS error\");\n      mg_dns_free(c, d);\n    }\n  }\n  (void) fn_data;\n}\n\nstatic bool mg_dns_send(struct mg_connection *c, const struct mg_str *name,\n                        uint16_t txnid, bool ipv6) {\n  struct {\n    struct mg_dns_header header;\n    uint8_t data[256];\n  } pkt;\n  size_t i, n;\n  memset(&pkt, 0, sizeof(pkt));\n  pkt.header.txnid = mg_htons(txnid);\n  pkt.header.flags = mg_htons(0x100);\n  pkt.header.num_questions = mg_htons(1);\n  for (i = n = 0; i < sizeof(pkt.data) - 5; i++) {\n    if (name->ptr[i] == '.' || i >= name->len) {\n      pkt.data[n] = (uint8_t) (i - n);\n      memcpy(&pkt.data[n + 1], name->ptr + n, i - n);\n      n = i + 1;\n    }\n    if (i >= name->len) break;\n  }\n  memcpy(&pkt.data[n], \"\\x00\\x00\\x01\\x00\\x01\", 5);  // A query\n  n += 5;\n  if (ipv6) pkt.data[n - 3] = 0x1c;  // AAAA query\n  // memcpy(&pkt.data[n], \"\\xc0\\x0c\\x00\\x1c\\x00\\x01\", 6);  // AAAA query\n  // n += 6;\n  return mg_send(c, &pkt, sizeof(pkt.header) + n);\n}\n\nstatic void mg_sendnsreq(struct mg_connection *c, struct mg_str *name, int ms,\n                         struct mg_dns *dnsc, bool ipv6) {\n  struct dns_data *d = NULL;\n  if (dnsc->url == NULL) {\n    mg_error(c, \"DNS server URL is NULL. Call mg_mgr_init()\");\n  } else if (dnsc->c == NULL) {\n    dnsc->c = mg_connect(c->mgr, dnsc->url, NULL, NULL);\n    if (dnsc->c != NULL) {\n      dnsc->c->pfn = dns_cb;\n      // dnsc->c->is_hexdumping = 1;\n    }\n  }\n  if (dnsc->c == NULL) {\n    mg_error(c, \"resolver\");\n  } else if ((d = (struct dns_data *) calloc(1, sizeof(*d))) == NULL) {\n    mg_error(c, \"resolve OOM\");\n  } else {\n    struct dns_data *reqs = (struct dns_data *) c->mgr->active_dns_requests;\n    d->txnid = reqs ? (uint16_t) (reqs->txnid + 1) : 1;\n    d->next = (struct dns_data *) c->mgr->active_dns_requests;\n    c->mgr->active_dns_requests = d;\n    d->expire = mg_millis() + (uint64_t) ms;\n    d->c = c;\n    c->is_resolving = 1;\n    MG_VERBOSE((\"%lu resolving %.*s @ %s, txnid %hu\", c->id, (int) name->len,\n                name->ptr, dnsc->url, d->txnid));\n    if (!mg_dns_send(dnsc->c, name, d->txnid, ipv6)) {\n      mg_error(dnsc->c, \"DNS send\");\n    }\n  }\n}\n\nvoid mg_resolve(struct mg_connection *c, const char *url) {\n  struct mg_str host = mg_url_host(url);\n  c->rem.port = mg_htons(mg_url_port(url));\n  if (mg_aton(host, &c->rem)) {\n    // host is an IP address, do not fire name resolution\n    mg_connect_resolved(c);\n  } else {\n    // host is not an IP, send DNS resolution request\n    struct mg_dns *dns = c->mgr->use_dns6 ? &c->mgr->dns6 : &c->mgr->dns4;\n    mg_sendnsreq(c, &host, c->mgr->dnstimeout, dns, c->mgr->use_dns6);\n  }\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/event.c\"\n#endif\n\n\n\n\n\nvoid mg_call(struct mg_connection *c, int ev, void *ev_data) {\n  // Run user-defined handler first, in order to give it an ability\n  // to intercept processing (e.g. clean input buffer) before the\n  // protocol handler kicks in\n  if (c->fn != NULL) c->fn(c, ev, ev_data, c->fn_data);\n  if (c->pfn != NULL) c->pfn(c, ev, ev_data, c->pfn_data);\n}\n\nvoid mg_error(struct mg_connection *c, const char *fmt, ...) {\n  char buf[64];\n  va_list ap;\n  va_start(ap, fmt);\n  mg_vsnprintf(buf, sizeof(buf), fmt, &ap);\n  va_end(ap);\n  MG_ERROR((\"%lu %p %s\", c->id, c->fd, buf));\n  c->is_closing = 1;             // Set is_closing before sending MG_EV_CALL\n  mg_call(c, MG_EV_ERROR, buf);  // Let user handler to override it\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/fmt.c\"\n#endif\n\n\n\n\nstatic bool is_digit(int c) {\n  return c >= '0' && c <= '9';\n}\n\nstatic int addexp(char *buf, int e, int sign) {\n  int n = 0;\n  buf[n++] = 'e';\n  buf[n++] = (char) sign;\n  if (e > 400) return 0;\n  if (e < 10) buf[n++] = '0';\n  if (e >= 100) buf[n++] = (char) (e / 100 + '0'), e -= 100 * (e / 100);\n  if (e >= 10) buf[n++] = (char) (e / 10 + '0'), e -= 10 * (e / 10);\n  buf[n++] = (char) (e + '0');\n  return n;\n}\n\nstatic int xisinf(double x) {\n  union {\n    double f;\n    uint64_t u;\n  } ieee754 = {x};\n  return ((unsigned) (ieee754.u >> 32) & 0x7fffffff) == 0x7ff00000 &&\n         ((unsigned) ieee754.u == 0);\n}\n\nstatic int xisnan(double x) {\n  union {\n    double f;\n    uint64_t u;\n  } ieee754 = {x};\n  return ((unsigned) (ieee754.u >> 32) & 0x7fffffff) +\n             ((unsigned) ieee754.u != 0) >\n         0x7ff00000;\n}\n\nstatic size_t mg_dtoa(char *dst, size_t dstlen, double d, int width, bool tz) {\n  char buf[40];\n  int i, s = 0, n = 0, e = 0;\n  double t, mul, saved;\n  if (d == 0.0) return mg_snprintf(dst, dstlen, \"%s\", \"0\");\n  if (xisinf(d)) return mg_snprintf(dst, dstlen, \"%s\", d > 0 ? \"inf\" : \"-inf\");\n  if (xisnan(d)) return mg_snprintf(dst, dstlen, \"%s\", \"nan\");\n  if (d < 0.0) d = -d, buf[s++] = '-';\n\n  // Round\n  saved = d;\n  mul = 1.0;\n  while (d >= 10.0 && d / mul >= 10.0) mul *= 10.0;\n  while (d <= 1.0 && d / mul <= 1.0) mul /= 10.0;\n  for (i = 0, t = mul * 5; i < width; i++) t /= 10.0;\n  d += t;\n  // Calculate exponent, and 'mul' for scientific representation\n  mul = 1.0;\n  while (d >= 10.0 && d / mul >= 10.0) mul *= 10.0, e++;\n  while (d < 1.0 && d / mul < 1.0) mul /= 10.0, e--;\n  // printf(\" --> %g %d %g %g\\n\", saved, e, t, mul);\n\n  if (e >= width && width > 1) {\n    n = (int) mg_dtoa(buf, sizeof(buf), saved / mul, width, tz);\n    // printf(\" --> %.*g %d [%.*s]\\n\", 10, d / t, e, n, buf);\n    n += addexp(buf + s + n, e, '+');\n    return mg_snprintf(dst, dstlen, \"%.*s\", n, buf);\n  } else if (e <= -width && width > 1) {\n    n = (int) mg_dtoa(buf, sizeof(buf), saved / mul, width, tz);\n    // printf(\" --> %.*g %d [%.*s]\\n\", 10, d / mul, e, n, buf);\n    n += addexp(buf + s + n, -e, '-');\n    return mg_snprintf(dst, dstlen, \"%.*s\", n, buf);\n  } else {\n    for (i = 0, t = mul; t >= 1.0 && s + n < (int) sizeof(buf); i++) {\n      int ch = (int) (d / t);\n      if (n > 0 || ch > 0) buf[s + n++] = (char) (ch + '0');\n      d -= ch * t;\n      t /= 10.0;\n    }\n    // printf(\" --> [%g] -> %g %g (%d) [%.*s]\\n\", saved, d, t, n, s + n, buf);\n    if (n == 0) buf[s++] = '0';\n    while (t >= 1.0 && n + s < (int) sizeof(buf)) buf[n++] = '0', t /= 10.0;\n    if (s + n < (int) sizeof(buf)) buf[n + s++] = '.';\n    // printf(\" 1--> [%g] -> [%.*s]\\n\", saved, s + n, buf);\n    for (i = 0, t = 0.1; s + n < (int) sizeof(buf) && n < width; i++) {\n      int ch = (int) (d / t);\n      buf[s + n++] = (char) (ch + '0');\n      d -= ch * t;\n      t /= 10.0;\n    }\n  }\n  while (tz && n > 0 && buf[s + n - 1] == '0') n--;  // Trim trailing zeroes\n  if (n > 0 && buf[s + n - 1] == '.') n--;           // Trim trailing dot\n  n += s;\n  if (n >= (int) sizeof(buf)) n = (int) sizeof(buf) - 1;\n  buf[n] = '\\0';\n  return mg_snprintf(dst, dstlen, \"%s\", buf);\n}\n\nstatic size_t mg_lld(char *buf, int64_t val, bool is_signed, bool is_hex) {\n  const char *letters = \"0123456789abcdef\";\n  uint64_t v = (uint64_t) val;\n  size_t s = 0, n, i;\n  if (is_signed && val < 0) buf[s++] = '-', v = (uint64_t) (-val);\n  // This loop prints a number in reverse order. I guess this is because we\n  // write numbers from right to left: least significant digit comes last.\n  // Maybe because we use Arabic numbers, and Arabs write RTL?\n  if (is_hex) {\n    for (n = 0; v; v >>= 4) buf[s + n++] = letters[v & 15];\n  } else {\n    for (n = 0; v; v /= 10) buf[s + n++] = letters[v % 10];\n  }\n  // Reverse a string\n  for (i = 0; i < n / 2; i++) {\n    char t = buf[s + i];\n    buf[s + i] = buf[s + n - i - 1], buf[s + n - i - 1] = t;\n  }\n  if (val == 0) buf[n++] = '0';  // Handle special case\n  return n + s;\n}\n\nstatic size_t scpy(void (*out)(char, void *), void *ptr, char *buf,\n                          size_t len) {\n  size_t i = 0;\n  while (i < len && buf[i] != '\\0') out(buf[i++], ptr);\n  return i;\n}\n\nsize_t mg_xprintf(void (*out)(char, void *), void *ptr, const char *fmt, ...) {\n  size_t len = 0;\n  va_list ap;\n  va_start(ap, fmt);\n  len = mg_vxprintf(out, ptr, fmt, &ap);\n  va_end(ap);\n  return len;\n}\n\nsize_t mg_vxprintf(void (*out)(char, void *), void *param, const char *fmt,\n                   va_list *ap) {\n  size_t i = 0, n = 0;\n  while (fmt[i] != '\\0') {\n    if (fmt[i] == '%') {\n      size_t j, k, x = 0, is_long = 0, w = 0 /* width */, pr = ~0U /* prec */;\n      char pad = ' ', minus = 0, c = fmt[++i];\n      if (c == '#') x++, c = fmt[++i];\n      if (c == '-') minus++, c = fmt[++i];\n      if (c == '0') pad = '0', c = fmt[++i];\n      while (is_digit(c)) w *= 10, w += (size_t) (c - '0'), c = fmt[++i];\n      if (c == '.') {\n        c = fmt[++i];\n        if (c == '*') {\n          pr = (size_t) va_arg(*ap, int);\n          c = fmt[++i];\n        } else {\n          pr = 0;\n          while (is_digit(c)) pr *= 10, pr += (size_t) (c - '0'), c = fmt[++i];\n        }\n      }\n      while (c == 'h') c = fmt[++i];  // Treat h and hh as int\n      if (c == 'l') {\n        is_long++, c = fmt[++i];\n        if (c == 'l') is_long++, c = fmt[++i];\n      }\n      if (c == 'p') x = 1, is_long = 1;\n      if (c == 'd' || c == 'u' || c == 'x' || c == 'X' || c == 'p' ||\n          c == 'g' || c == 'f') {\n        bool s = (c == 'd'), h = (c == 'x' || c == 'X' || c == 'p');\n        char tmp[40];\n        size_t xl = x ? 2 : 0;\n        if (c == 'g' || c == 'f') {\n          double v = va_arg(*ap, double);\n          if (pr == ~0U) pr = 6;\n          k = mg_dtoa(tmp, sizeof(tmp), v, (int) pr, c == 'g');\n        } else if (is_long == 2) {\n          int64_t v = va_arg(*ap, int64_t);\n          k = mg_lld(tmp, v, s, h);\n        } else if (is_long == 1) {\n          long v = va_arg(*ap, long);\n          k = mg_lld(tmp, s ? (int64_t) v : (int64_t) (unsigned long) v, s, h);\n        } else {\n          int v = va_arg(*ap, int);\n          k = mg_lld(tmp, s ? (int64_t) v : (int64_t) (unsigned) v, s, h);\n        }\n        for (j = 0; j < xl && w > 0; j++) w--;\n        for (j = 0; pad == ' ' && !minus && k < w && j + k < w; j++)\n          n += scpy(out, param, &pad, 1);\n        n += scpy(out, param, (char *) \"0x\", xl);\n        for (j = 0; pad == '0' && k < w && j + k < w; j++)\n          n += scpy(out, param, &pad, 1);\n        n += scpy(out, param, tmp, k);\n        for (j = 0; pad == ' ' && minus && k < w && j + k < w; j++)\n          n += scpy(out, param, &pad, 1);\n      } else if (c == 'm' || c == 'M') {\n        mg_pm_t f = va_arg(*ap, mg_pm_t);\n        if (c == 'm') out('\"', param);\n        n += f(out, param, ap);\n        if (c == 'm') n += 2, out('\"', param);\n      } else if (c == 'c') {\n        int ch = va_arg(*ap, int);\n        out((char) ch, param);\n        n++;\n      } else if (c == 's') {\n        char *p = va_arg(*ap, char *);\n        if (pr == ~0U) pr = p == NULL ? 0 : strlen(p);\n        for (j = 0; !minus && pr < w && j + pr < w; j++)\n          n += scpy(out, param, &pad, 1);\n        n += scpy(out, param, p, pr);\n        for (j = 0; minus && pr < w && j + pr < w; j++)\n          n += scpy(out, param, &pad, 1);\n      } else if (c == '%') {\n        out('%', param);\n        n++;\n      } else {\n        out('%', param);\n        out(c, param);\n        n += 2;\n      }\n      i++;\n    } else {\n      out(fmt[i], param), n++, i++;\n    }\n  }\n  return n;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/fs.c\"\n#endif\n\n\n\nstruct mg_fd *mg_fs_open(struct mg_fs *fs, const char *path, int flags) {\n  struct mg_fd *fd = (struct mg_fd *) calloc(1, sizeof(*fd));\n  if (fd != NULL) {\n    fd->fd = fs->op(path, flags);\n    fd->fs = fs;\n    if (fd->fd == NULL) {\n      free(fd);\n      fd = NULL;\n    }\n  }\n  return fd;\n}\n\nvoid mg_fs_close(struct mg_fd *fd) {\n  if (fd != NULL) {\n    fd->fs->cl(fd->fd);\n    free(fd);\n  }\n}\n\nchar *mg_file_read(struct mg_fs *fs, const char *path, size_t *sizep) {\n  struct mg_fd *fd;\n  char *data = NULL;\n  size_t size = 0;\n  fs->st(path, &size, NULL);\n  if ((fd = mg_fs_open(fs, path, MG_FS_READ)) != NULL) {\n    data = (char *) calloc(1, size + 1);\n    if (data != NULL) {\n      if (fs->rd(fd->fd, data, size) != size) {\n        free(data);\n        data = NULL;\n      } else {\n        data[size] = '\\0';\n        if (sizep != NULL) *sizep = size;\n      }\n    }\n    mg_fs_close(fd);\n  }\n  return data;\n}\n\nbool mg_file_write(struct mg_fs *fs, const char *path, const void *buf,\n                   size_t len) {\n  bool result = false;\n  struct mg_fd *fd;\n  char tmp[MG_PATH_MAX];\n  mg_snprintf(tmp, sizeof(tmp), \"%s..%d\", path, rand());\n  if ((fd = mg_fs_open(fs, tmp, MG_FS_WRITE)) != NULL) {\n    result = fs->wr(fd->fd, buf, len) == len;\n    mg_fs_close(fd);\n    if (result) {\n      fs->rm(path);\n      fs->mv(tmp, path);\n    } else {\n      fs->rm(tmp);\n    }\n  }\n  return result;\n}\n\nbool mg_file_printf(struct mg_fs *fs, const char *path, const char *fmt, ...) {\n  va_list ap;\n  char *data;\n  bool result = false;\n  va_start(ap, fmt);\n  data = mg_vmprintf(fmt, &ap);\n  va_end(ap);\n  result = mg_file_write(fs, path, data, strlen(data));\n  free(data);\n  return result;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/fs_fat.c\"\n#endif\n\n\n\n#if MG_ENABLE_FATFS\n#include <ff.h>\n\nstatic int mg_days_from_epoch(int y, int m, int d) {\n  y -= m <= 2;\n  int era = y / 400;\n  int yoe = y - era * 400;\n  int doy = (153 * (m + (m > 2 ? -3 : 9)) + 2) / 5 + d - 1;\n  int doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;\n  return era * 146097 + doe - 719468;\n}\n\nstatic time_t mg_timegm(const struct tm *t) {\n  int year = t->tm_year + 1900;\n  int month = t->tm_mon;  // 0-11\n  if (month > 11) {\n    year += month / 12;\n    month %= 12;\n  } else if (month < 0) {\n    int years_diff = (11 - month) / 12;\n    year -= years_diff;\n    month += 12 * years_diff;\n  }\n  int x = mg_days_from_epoch(year, month + 1, t->tm_mday);\n  return 60 * (60 * (24L * x + t->tm_hour) + t->tm_min) + t->tm_sec;\n}\n\nstatic time_t ff_time_to_epoch(uint16_t fdate, uint16_t ftime) {\n  struct tm tm;\n  memset(&tm, 0, sizeof(struct tm));\n  tm.tm_sec = (ftime << 1) & 0x3e;\n  tm.tm_min = ((ftime >> 5) & 0x3f);\n  tm.tm_hour = ((ftime >> 11) & 0x1f);\n  tm.tm_mday = (fdate & 0x1f);\n  tm.tm_mon = ((fdate >> 5) & 0x0f) - 1;\n  tm.tm_year = ((fdate >> 9) & 0x7f) + 80;\n  return mg_timegm(&tm);\n}\n\nstatic int ff_stat(const char *path, size_t *size, time_t *mtime) {\n  FILINFO fi;\n  if (path[0] == '\\0') {\n    if (size) *size = 0;\n    if (mtime) *mtime = 0;\n    return MG_FS_DIR;\n  } else if (f_stat(path, &fi) == 0) {\n    if (size) *size = (size_t) fi.fsize;\n    if (mtime) *mtime = ff_time_to_epoch(fi.fdate, fi.ftime);\n    return MG_FS_READ | MG_FS_WRITE | ((fi.fattrib & AM_DIR) ? MG_FS_DIR : 0);\n  } else {\n    return 0;\n  }\n}\n\nstatic void ff_list(const char *dir, void (*fn)(const char *, void *),\n                    void *userdata) {\n  DIR d;\n  FILINFO fi;\n  if (f_opendir(&d, dir) == FR_OK) {\n    while (f_readdir(&d, &fi) == FR_OK && fi.fname[0] != '\\0') {\n      if (!strcmp(fi.fname, \".\") || !strcmp(fi.fname, \"..\")) continue;\n      fn(fi.fname, userdata);\n    }\n    f_closedir(&d);\n  }\n}\n\nstatic void *ff_open(const char *path, int flags) {\n  FIL f;\n  unsigned char mode = FA_READ;\n  if (flags & MG_FS_WRITE) mode |= FA_WRITE | FA_OPEN_ALWAYS | FA_OPEN_APPEND;\n  if (f_open(&f, path, mode) == 0) {\n    FIL *fp;\n    if ((fp = calloc(1, sizeof(*fp))) != NULL) {\n      memcpy(fp, &f, sizeof(*fp));\n      return fp;\n    }\n  }\n  return NULL;\n}\n\nstatic void ff_close(void *fp) {\n  if (fp != NULL) {\n    f_close((FIL *) fp);\n    free(fp);\n  }\n}\n\nstatic size_t ff_read(void *fp, void *buf, size_t len) {\n  UINT n = 0, misalign = ((size_t) buf) & 3;\n  if (misalign) {\n    char aligned[4];\n    f_read((FIL *) fp, aligned, len > misalign ? misalign : len, &n);\n    memcpy(buf, aligned, n);\n  } else {\n    f_read((FIL *) fp, buf, len, &n);\n  }\n  return n;\n}\n\nstatic size_t ff_write(void *fp, const void *buf, size_t len) {\n  UINT n = 0;\n  return f_write((FIL *) fp, (char *) buf, len, &n) == FR_OK ? n : 0;\n}\n\nstatic size_t ff_seek(void *fp, size_t offset) {\n  f_lseek((FIL *) fp, offset);\n  return offset;\n}\n\nstatic bool ff_rename(const char *from, const char *to) {\n  return f_rename(from, to) == FR_OK;\n}\n\nstatic bool ff_remove(const char *path) {\n  return f_unlink(path) == FR_OK;\n}\n\nstatic bool ff_mkdir(const char *path) {\n  return f_mkdir(path) == FR_OK;\n}\n\nstruct mg_fs mg_fs_fat = {ff_stat,  ff_list, ff_open,   ff_close,  ff_read,\n                          ff_write, ff_seek, ff_rename, ff_remove, ff_mkdir};\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/fs_packed.c\"\n#endif\n\n\n\n\nstruct packed_file {\n  const char *data;\n  size_t size;\n  size_t pos;\n};\n\nconst char *mg_unpack(const char *path, size_t *size, time_t *mtime);\nconst char *mg_unlist(size_t no);\n\n#if MG_ENABLE_PACKED_FS\n#else\nconst char *mg_unpack(const char *path, size_t *size, time_t *mtime) {\n  (void) path, (void) size, (void) mtime;\n  return NULL;\n}\nconst char *mg_unlist(size_t no) {\n  (void) no;\n  return NULL;\n}\n#endif\n\nstatic int is_dir_prefix(const char *prefix, size_t n, const char *path) {\n  // MG_INFO((\"[%.*s] [%s] %c\", (int) n, prefix, path, path[n]));\n  return n < strlen(path) && strncmp(prefix, path, n) == 0 &&\n         (n == 0 || path[n] == '/' || path[n - 1] == '/');\n}\n\nstatic int packed_stat(const char *path, size_t *size, time_t *mtime) {\n  const char *p;\n  size_t i, n = strlen(path);\n  if (mg_unpack(path, size, mtime)) return MG_FS_READ;  // Regular file\n  // Scan all files. If `path` is a dir prefix for any of them, it's a dir\n  for (i = 0; (p = mg_unlist(i)) != NULL; i++) {\n    if (is_dir_prefix(path, n, p)) return MG_FS_DIR;\n  }\n  return 0;\n}\n\nstatic void packed_list(const char *dir, void (*fn)(const char *, void *),\n                        void *userdata) {\n  char buf[MG_PATH_MAX], tmp[sizeof(buf)];\n  const char *path, *begin, *end;\n  size_t i, n = strlen(dir);\n  tmp[0] = '\\0';  // Previously listed entry\n  for (i = 0; (path = mg_unlist(i)) != NULL; i++) {\n    if (!is_dir_prefix(dir, n, path)) continue;\n    begin = &path[n + 1];\n    end = strchr(begin, '/');\n    if (end == NULL) end = begin + strlen(begin);\n    mg_snprintf(buf, sizeof(buf), \"%.*s\", (int) (end - begin), begin);\n    buf[sizeof(buf) - 1] = '\\0';\n    // If this entry has been already listed, skip\n    // NOTE: we're assuming that file list is sorted alphabetically\n    if (strcmp(buf, tmp) == 0) continue;\n    fn(buf, userdata);  // Not yet listed, call user function\n    strcpy(tmp, buf);   // And save this entry as listed\n  }\n}\n\nstatic void *packed_open(const char *path, int flags) {\n  size_t size = 0;\n  const char *data = mg_unpack(path, &size, NULL);\n  struct packed_file *fp = NULL;\n  if (data == NULL) return NULL;\n  if (flags & MG_FS_WRITE) return NULL;\n  if ((fp = (struct packed_file *) calloc(1, sizeof(*fp))) != NULL) {\n    fp->size = size;\n    fp->data = data;\n  }\n  return (void *) fp;\n}\n\nstatic void packed_close(void *fp) {\n  if (fp != NULL) free(fp);\n}\n\nstatic size_t packed_read(void *fd, void *buf, size_t len) {\n  struct packed_file *fp = (struct packed_file *) fd;\n  if (fp->pos + len > fp->size) len = fp->size - fp->pos;\n  memcpy(buf, &fp->data[fp->pos], len);\n  fp->pos += len;\n  return len;\n}\n\nstatic size_t packed_write(void *fd, const void *buf, size_t len) {\n  (void) fd, (void) buf, (void) len;\n  return 0;\n}\n\nstatic size_t packed_seek(void *fd, size_t offset) {\n  struct packed_file *fp = (struct packed_file *) fd;\n  fp->pos = offset;\n  if (fp->pos > fp->size) fp->pos = fp->size;\n  return fp->pos;\n}\n\nstatic bool packed_rename(const char *from, const char *to) {\n  (void) from, (void) to;\n  return false;\n}\n\nstatic bool packed_remove(const char *path) {\n  (void) path;\n  return false;\n}\n\nstatic bool packed_mkdir(const char *path) {\n  (void) path;\n  return false;\n}\n\nstruct mg_fs mg_fs_packed = {\n    packed_stat,  packed_list, packed_open,   packed_close,  packed_read,\n    packed_write, packed_seek, packed_rename, packed_remove, packed_mkdir};\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/fs_posix.c\"\n#endif\n\n\n#if MG_ENABLE_FILE\n\n#ifndef MG_STAT_STRUCT\n#define MG_STAT_STRUCT stat\n#endif\n\n#ifndef MG_STAT_FUNC\n#define MG_STAT_FUNC stat\n#endif\n\nstatic int p_stat(const char *path, size_t *size, time_t *mtime) {\n#if !defined(S_ISDIR)\n  MG_ERROR((\"stat() API is not supported. %p %p %p\", path, size, mtime));\n  return 0;\n#else\n#if MG_ARCH == MG_ARCH_WIN32\n  struct _stati64 st;\n  wchar_t tmp[MG_PATH_MAX];\n  MultiByteToWideChar(CP_UTF8, 0, path, -1, tmp, sizeof(tmp) / sizeof(tmp[0]));\n  if (_wstati64(tmp, &st) != 0) return 0;\n  // If path is a symlink, windows reports 0 in st.st_size.\n  // Get a real file size by opening it and jumping to the end\n  if (st.st_size == 0 && (st.st_mode & _S_IFREG)) {\n    FILE *fp = _wfopen(tmp, L\"rb\");\n    if (fp != NULL) {\n      fseek(fp, 0, SEEK_END);\n      if (ftell(fp) > 0) st.st_size = ftell(fp); // Use _ftelli64 on win10+\n      fclose(fp);\n    }\n  }\n#else\n  struct MG_STAT_STRUCT st;\n  if (MG_STAT_FUNC(path, &st) != 0) return 0;\n#endif\n  if (size) *size = (size_t) st.st_size;\n  if (mtime) *mtime = st.st_mtime;\n  return MG_FS_READ | MG_FS_WRITE | (S_ISDIR(st.st_mode) ? MG_FS_DIR : 0);\n#endif\n}\n\n#if MG_ARCH == MG_ARCH_WIN32\nstruct dirent {\n  char d_name[MAX_PATH];\n};\n\ntypedef struct win32_dir {\n  HANDLE handle;\n  WIN32_FIND_DATAW info;\n  struct dirent result;\n} DIR;\n\nint gettimeofday(struct timeval *tv, void *tz) {\n  FILETIME ft;\n  unsigned __int64 tmpres = 0;\n\n  if (tv != NULL) {\n    GetSystemTimeAsFileTime(&ft);\n    tmpres |= ft.dwHighDateTime;\n    tmpres <<= 32;\n    tmpres |= ft.dwLowDateTime;\n    tmpres /= 10;  // convert into microseconds\n    tmpres -= (int64_t) 11644473600000000;\n    tv->tv_sec = (long) (tmpres / 1000000UL);\n    tv->tv_usec = (long) (tmpres % 1000000UL);\n  }\n  (void) tz;\n  return 0;\n}\n\nstatic int to_wchar(const char *path, wchar_t *wbuf, size_t wbuf_len) {\n  int ret;\n  char buf[MAX_PATH * 2], buf2[MAX_PATH * 2], *p;\n  strncpy(buf, path, sizeof(buf));\n  buf[sizeof(buf) - 1] = '\\0';\n  // Trim trailing slashes. Leave backslash for paths like \"X:\\\"\n  p = buf + strlen(buf) - 1;\n  while (p > buf && p[-1] != ':' && (p[0] == '\\\\' || p[0] == '/')) *p-- = '\\0';\n  memset(wbuf, 0, wbuf_len * sizeof(wchar_t));\n  ret = MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int) wbuf_len);\n  // Convert back to Unicode. If doubly-converted string does not match the\n  // original, something is fishy, reject.\n  WideCharToMultiByte(CP_UTF8, 0, wbuf, (int) wbuf_len, buf2, sizeof(buf2),\n                      NULL, NULL);\n  if (strcmp(buf, buf2) != 0) {\n    wbuf[0] = L'\\0';\n    ret = 0;\n  }\n  return ret;\n}\n\nDIR *opendir(const char *name) {\n  DIR *d = NULL;\n  wchar_t wpath[MAX_PATH];\n  DWORD attrs;\n\n  if (name == NULL) {\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  } else if ((d = (DIR *) calloc(1, sizeof(*d))) == NULL) {\n    SetLastError(ERROR_NOT_ENOUGH_MEMORY);\n  } else {\n    to_wchar(name, wpath, sizeof(wpath) / sizeof(wpath[0]));\n    attrs = GetFileAttributesW(wpath);\n    if (attrs != 0Xffffffff && (attrs & FILE_ATTRIBUTE_DIRECTORY)) {\n      (void) wcscat(wpath, L\"\\\\*\");\n      d->handle = FindFirstFileW(wpath, &d->info);\n      d->result.d_name[0] = '\\0';\n    } else {\n      free(d);\n      d = NULL;\n    }\n  }\n  return d;\n}\n\nint closedir(DIR *d) {\n  int result = 0;\n  if (d != NULL) {\n    if (d->handle != INVALID_HANDLE_VALUE)\n      result = FindClose(d->handle) ? 0 : -1;\n    free(d);\n  } else {\n    result = -1;\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  }\n  return result;\n}\n\nstruct dirent *readdir(DIR *d) {\n  struct dirent *result = NULL;\n  if (d != NULL) {\n    memset(&d->result, 0, sizeof(d->result));\n    if (d->handle != INVALID_HANDLE_VALUE) {\n      result = &d->result;\n      WideCharToMultiByte(CP_UTF8, 0, d->info.cFileName, -1, result->d_name,\n                          sizeof(result->d_name), NULL, NULL);\n      if (!FindNextFileW(d->handle, &d->info)) {\n        FindClose(d->handle);\n        d->handle = INVALID_HANDLE_VALUE;\n      }\n    } else {\n      SetLastError(ERROR_FILE_NOT_FOUND);\n    }\n  } else {\n    SetLastError(ERROR_BAD_ARGUMENTS);\n  }\n  return result;\n}\n#endif\n\nstatic void p_list(const char *dir, void (*fn)(const char *, void *),\n                   void *userdata) {\n#if MG_ENABLE_DIRLIST\n  struct dirent *dp;\n  DIR *dirp;\n  if ((dirp = (opendir(dir))) == NULL) return;\n  while ((dp = readdir(dirp)) != NULL) {\n    if (!strcmp(dp->d_name, \".\") || !strcmp(dp->d_name, \"..\")) continue;\n    fn(dp->d_name, userdata);\n  }\n  closedir(dirp);\n#else\n  (void) dir, (void) fn, (void) userdata;\n#endif\n}\n\nstatic void *p_open(const char *path, int flags) {\n  const char *mode = flags == MG_FS_READ ? \"rb\" : \"a+b\";\n#if MG_ARCH == MG_ARCH_WIN32\n  wchar_t b1[MG_PATH_MAX], b2[10];\n  MultiByteToWideChar(CP_UTF8, 0, path, -1, b1, sizeof(b1) / sizeof(b1[0]));\n  MultiByteToWideChar(CP_UTF8, 0, mode, -1, b2, sizeof(b2) / sizeof(b2[0]));\n  return (void *) _wfopen(b1, b2);\n#else\n  return (void *) fopen(path, mode);\n#endif\n}\n\nstatic void p_close(void *fp) {\n  fclose((FILE *) fp);\n}\n\nstatic size_t p_read(void *fp, void *buf, size_t len) {\n  return fread(buf, 1, len, (FILE *) fp);\n}\n\nstatic size_t p_write(void *fp, const void *buf, size_t len) {\n  return fwrite(buf, 1, len, (FILE *) fp);\n}\n\nstatic size_t p_seek(void *fp, size_t offset) {\n#if (defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS == 64) ||  \\\n    (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 200112L) || \\\n    (defined(_XOPEN_SOURCE) && _XOPEN_SOURCE >= 600)\n  if (fseeko((FILE *) fp, (off_t) offset, SEEK_SET) != 0) (void) 0;\n#else\n  if (fseek((FILE *) fp, (long) offset, SEEK_SET) != 0) (void) 0;\n#endif\n  return (size_t) ftell((FILE *) fp);\n}\n\nstatic bool p_rename(const char *from, const char *to) {\n  return rename(from, to) == 0;\n}\n\nstatic bool p_remove(const char *path) {\n  return remove(path) == 0;\n}\n\nstatic bool p_mkdir(const char *path) {\n  return mkdir(path, 0775) == 0;\n}\n\n#else\n\nstatic int p_stat(const char *path, size_t *size, time_t *mtime) {\n  (void) path, (void) size, (void) mtime;\n  return 0;\n}\nstatic void p_list(const char *path, void (*fn)(const char *, void *),\n                   void *userdata) {\n  (void) path, (void) fn, (void) userdata;\n}\nstatic void *p_open(const char *path, int flags) {\n  (void) path, (void) flags;\n  return NULL;\n}\nstatic void p_close(void *fp) {\n  (void) fp;\n}\nstatic size_t p_read(void *fd, void *buf, size_t len) {\n  (void) fd, (void) buf, (void) len;\n  return 0;\n}\nstatic size_t p_write(void *fd, const void *buf, size_t len) {\n  (void) fd, (void) buf, (void) len;\n  return 0;\n}\nstatic size_t p_seek(void *fd, size_t offset) {\n  (void) fd, (void) offset;\n  return (size_t) ~0;\n}\nstatic bool p_rename(const char *from, const char *to) {\n  (void) from, (void) to;\n  return false;\n}\nstatic bool p_remove(const char *path) {\n  (void) path;\n  return false;\n}\nstatic bool p_mkdir(const char *path) {\n  (void) path;\n  return false;\n}\n#endif\n\nstruct mg_fs mg_fs_posix = {p_stat,  p_list, p_open,   p_close,  p_read,\n                            p_write, p_seek, p_rename, p_remove, p_mkdir};\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/http.c\"\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Chunk deletion marker is the MSB in the \"processed\" counter\n#define MG_DMARK ((size_t) 1 << (sizeof(size_t) * 8 - 1))\n\n// Multipart POST example:\n// --xyz\n// Content-Disposition: form-data; name=\"val\"\n//\n// abcdef\n// --xyz\n// Content-Disposition: form-data; name=\"foo\"; filename=\"a.txt\"\n// Content-Type: text/plain\n//\n// hello world\n//\n// --xyz--\nsize_t mg_http_next_multipart(struct mg_str body, size_t ofs,\n                              struct mg_http_part *part) {\n  struct mg_str cd = mg_str_n(\"Content-Disposition\", 19);\n  const char *s = body.ptr;\n  size_t b = ofs, h1, h2, b1, b2, max = body.len;\n\n  // Init part params\n  if (part != NULL) part->name = part->filename = part->body = mg_str_n(0, 0);\n\n  // Skip boundary\n  while (b + 2 < max && s[b] != '\\r' && s[b + 1] != '\\n') b++;\n  if (b <= ofs || b + 2 >= max) return 0;\n  // MG_INFO((\"B: %zu %zu [%.*s]\", ofs, b - ofs, (int) (b - ofs), s));\n\n  // Skip headers\n  h1 = h2 = b + 2;\n  for (;;) {\n    while (h2 + 2 < max && s[h2] != '\\r' && s[h2 + 1] != '\\n') h2++;\n    if (h2 == h1) break;\n    if (h2 + 2 >= max) return 0;\n    // MG_INFO((\"Header: [%.*s]\", (int) (h2 - h1), &s[h1]));\n    if (part != NULL && h1 + cd.len + 2 < h2 && s[h1 + cd.len] == ':' &&\n        mg_ncasecmp(&s[h1], cd.ptr, cd.len) == 0) {\n      struct mg_str v = mg_str_n(&s[h1 + cd.len + 2], h2 - (h1 + cd.len + 2));\n      part->name = mg_http_get_header_var(v, mg_str_n(\"name\", 4));\n      part->filename = mg_http_get_header_var(v, mg_str_n(\"filename\", 8));\n    }\n    h1 = h2 = h2 + 2;\n  }\n  b1 = b2 = h2 + 2;\n  while (b2 + 2 + (b - ofs) + 2 < max && !(s[b2] == '\\r' && s[b2 + 1] == '\\n' &&\n                                           memcmp(&s[b2 + 2], s, b - ofs) == 0))\n    b2++;\n\n  if (b2 + 2 >= max) return 0;\n  if (part != NULL) part->body = mg_str_n(&s[b1], b2 - b1);\n  // MG_INFO((\"Body: [%.*s]\", (int) (b2 - b1), &s[b1]));\n  return b2 + 2;\n}\n\nvoid mg_http_bauth(struct mg_connection *c, const char *user,\n                   const char *pass) {\n  struct mg_str u = mg_str(user), p = mg_str(pass);\n  size_t need = c->send.len + 36 + (u.len + p.len) * 2;\n  if (c->send.size < need) mg_iobuf_resize(&c->send, need);\n  if (c->send.size >= need) {\n    int i, n = 0;\n    char *buf = (char *) &c->send.buf[c->send.len];\n    memcpy(buf, \"Authorization: Basic \", 21);  // DON'T use mg_send!\n    for (i = 0; i < (int) u.len; i++) {\n      n = mg_base64_update(((unsigned char *) u.ptr)[i], buf + 21, n);\n    }\n    if (p.len > 0) {\n      n = mg_base64_update(':', buf + 21, n);\n      for (i = 0; i < (int) p.len; i++) {\n        n = mg_base64_update(((unsigned char *) p.ptr)[i], buf + 21, n);\n      }\n    }\n    n = mg_base64_final(buf + 21, n);\n    c->send.len += 21 + (size_t) n + 2;\n    memcpy(&c->send.buf[c->send.len - 2], \"\\r\\n\", 2);\n  } else {\n    MG_ERROR((\"%lu oom %d->%d \", c->id, (int) c->send.size, (int) need));\n  }\n}\n\nstruct mg_str mg_http_var(struct mg_str buf, struct mg_str name) {\n  struct mg_str k, v, result = mg_str_n(NULL, 0);\n  while (mg_split(&buf, &k, &v, '&')) {\n    if (name.len == k.len && mg_ncasecmp(name.ptr, k.ptr, k.len) == 0) {\n      result = v;\n      break;\n    }\n  }\n  return result;\n}\n\nint mg_http_get_var(const struct mg_str *buf, const char *name, char *dst,\n                    size_t dst_len) {\n  int len;\n  if (dst == NULL || dst_len == 0) {\n    len = -2;  // Bad destination\n  } else if (buf->ptr == NULL || name == NULL || buf->len == 0) {\n    len = -1;  // Bad source\n    dst[0] = '\\0';\n  } else {\n    struct mg_str v = mg_http_var(*buf, mg_str(name));\n    if (v.ptr == NULL) {\n      len = -4;  // Name does not exist\n    } else {\n      len = mg_url_decode(v.ptr, v.len, dst, dst_len, 1);\n      if (len < 0) len = -3;  // Failed to decode\n    }\n  }\n  return len;\n}\n\nstatic bool isx(int c) {\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||\n         (c >= 'A' && c <= 'F');\n}\n\nint mg_url_decode(const char *src, size_t src_len, char *dst, size_t dst_len,\n                  int is_form_url_encoded) {\n  size_t i, j;\n  for (i = j = 0; i < src_len && j + 1 < dst_len; i++, j++) {\n    if (src[i] == '%') {\n      // Use `i + 2 < src_len`, not `i < src_len - 2`, note small src_len\n      if (i + 2 < src_len && isx(src[i + 1]) && isx(src[i + 2])) {\n        mg_unhex(src + i + 1, 2, (uint8_t *) &dst[j]);\n        i += 2;\n      } else {\n        return -1;\n      }\n    } else if (is_form_url_encoded && src[i] == '+') {\n      dst[j] = ' ';\n    } else {\n      dst[j] = src[i];\n    }\n  }\n  if (j < dst_len) dst[j] = '\\0';  // Null-terminate the destination\n  return i >= src_len && j < dst_len ? (int) j : -1;\n}\n\nstatic bool isok(uint8_t c) { return c == '\\n' || c == '\\r' || c >= ' '; }\n\nint mg_http_get_request_len(const unsigned char *buf, size_t buf_len) {\n  size_t i;\n  for (i = 0; i < buf_len; i++) {\n    if (!isok(buf[i])) return -1;\n    if ((i > 0 && buf[i] == '\\n' && buf[i - 1] == '\\n') ||\n        (i > 3 && buf[i] == '\\n' && buf[i - 1] == '\\r' && buf[i - 2] == '\\n'))\n      return (int) i + 1;\n  }\n  return 0;\n}\n\nstatic const char *skip(const char *s, const char *e, const char *d,\n                        struct mg_str *v) {\n  v->ptr = s;\n  while (s < e && *s != '\\n' && strchr(d, *s) == NULL) s++;\n  v->len = (size_t) (s - v->ptr);\n  while (s < e && strchr(d, *s) != NULL) s++;\n  return s;\n}\n\nstruct mg_str *mg_http_get_header(struct mg_http_message *h, const char *name) {\n  size_t i, n = strlen(name), max = sizeof(h->headers) / sizeof(h->headers[0]);\n  for (i = 0; i < max && h->headers[i].name.len > 0; i++) {\n    struct mg_str *k = &h->headers[i].name, *v = &h->headers[i].value;\n    if (n == k->len && mg_ncasecmp(k->ptr, name, n) == 0) return v;\n  }\n  return NULL;\n}\n\nstatic void mg_http_parse_headers(const char *s, const char *end,\n                                  struct mg_http_header *h, int max_headers) {\n  int i;\n  for (i = 0; i < max_headers; i++) {\n    struct mg_str k, v, tmp;\n    const char *he = skip(s, end, \"\\n\", &tmp);\n    s = skip(s, he, \": \\r\\n\", &k);\n    s = skip(s, he, \"\\r\\n\", &v);\n    if (k.len == tmp.len) continue;\n    while (v.len > 0 && v.ptr[v.len - 1] == ' ') v.len--;  // Trim spaces\n    if (k.len == 0) break;\n    // MG_INFO((\"--HH [%.*s] [%.*s] [%.*s]\", (int) tmp.len - 1, tmp.ptr,\n    //(int) k.len, k.ptr, (int) v.len, v.ptr));\n    h[i].name = k;\n    h[i].value = v;\n  }\n}\n\nint mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {\n  int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);\n  const char *end = s == NULL ? NULL : s + req_len, *qs;  // Cannot add to NULL\n  struct mg_str *cl;\n\n  memset(hm, 0, sizeof(*hm));\n  if (req_len <= 0) return req_len;\n\n  hm->message.ptr = hm->head.ptr = s;\n  hm->body.ptr = end;\n  hm->head.len = (size_t) req_len;\n  hm->chunk.ptr = end;\n  hm->message.len = hm->body.len = (size_t) ~0;  // Set body length to infinite\n\n  // Parse request line\n  s = skip(s, end, \" \", &hm->method);\n  s = skip(s, end, \" \", &hm->uri);\n  s = skip(s, end, \"\\r\\n\", &hm->proto);\n\n  // Sanity check. Allow protocol/reason to be empty\n  if (hm->method.len == 0 || hm->uri.len == 0) return -1;\n\n  // If URI contains '?' character, setup query string\n  if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {\n    hm->query.ptr = qs + 1;\n    hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));\n    hm->uri.len = (size_t) (qs - hm->uri.ptr);\n  }\n\n  mg_http_parse_headers(s, end, hm->headers,\n                        sizeof(hm->headers) / sizeof(hm->headers[0]));\n  if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {\n    int64_t content_len = mg_to64(*cl);\n    if(content_len < 0) return -1;\n    hm->body.len = (size_t) content_len;\n    hm->message.len = (size_t) req_len + hm->body.len;\n  }\n\n  // mg_http_parse() is used to parse both HTTP requests and HTTP\n  // responses. If HTTP response does not have Content-Length set, then\n  // body is read until socket is closed, i.e. body.len is infinite (~0).\n  //\n  // For HTTP requests though, according to\n  // http://tools.ietf.org/html/rfc7231#section-8.1.3,\n  // only POST and PUT methods have defined body semantics.\n  // Therefore, if Content-Length is not specified and methods are\n  // not one of PUT or POST, set body length to 0.\n  //\n  // So, if it is HTTP request, and Content-Length is not set,\n  // and method is not (PUT or POST) then reset body length to zero.\n  is_response = mg_ncasecmp(hm->method.ptr, \"HTTP/\", 5) == 0;\n  if (hm->body.len == (size_t) ~0 && !is_response &&\n      mg_vcasecmp(&hm->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&hm->method, \"POST\") != 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  // The 204 (No content) responses also have 0 body length\n  if (hm->body.len == (size_t) ~0 && is_response &&\n      mg_vcasecmp(&hm->uri, \"204\") == 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  return req_len;\n}\n\nstatic void mg_http_vprintf_chunk(struct mg_connection *c, const char *fmt,\n                                  va_list *ap) {\n  size_t len = c->send.len;\n  mg_send(c, \"        \\r\\n\", 10);\n  mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, ap);\n  if (c->send.len >= len + 10) {\n    mg_snprintf((char *) c->send.buf + len, 9, \"%08lx\", c->send.len - len - 10);\n    c->send.buf[len + 8] = '\\r';\n    if (c->send.len == len + 10) c->is_resp = 0;  // Last chunk, reset marker\n  }\n  mg_send(c, \"\\r\\n\", 2);\n}\n\nvoid mg_http_printf_chunk(struct mg_connection *c, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  mg_http_vprintf_chunk(c, fmt, &ap);\n  va_end(ap);\n}\n\nvoid mg_http_write_chunk(struct mg_connection *c, const char *buf, size_t len) {\n  mg_printf(c, \"%lx\\r\\n\", (unsigned long) len);\n  mg_send(c, buf, len);\n  mg_send(c, \"\\r\\n\", 2);\n  if (len == 0) c->is_resp = 0;\n}\n\n// clang-format off\nstatic const char *mg_http_status_code_str(int status_code) {\n  switch (status_code) {\n    case 100: return \"Continue\";\n    case 201: return \"Created\";\n    case 202: return \"Accepted\";\n    case 204: return \"No Content\";\n    case 206: return \"Partial Content\";\n    case 301: return \"Moved Permanently\";\n    case 302: return \"Found\";\n    case 304: return \"Not Modified\";\n    case 400: return \"Bad Request\";\n    case 401: return \"Unauthorized\";\n    case 403: return \"Forbidden\";\n    case 404: return \"Not Found\";\n    case 418: return \"I'm a teapot\";\n    case 500: return \"Internal Server Error\";\n    case 501: return \"Not Implemented\";\n    default: return \"OK\";\n  }\n}\n// clang-format on\n\nvoid mg_http_reply(struct mg_connection *c, int code, const char *headers,\n                   const char *fmt, ...) {\n  va_list ap;\n  size_t len;\n  mg_printf(c, \"HTTP/1.1 %d %s\\r\\n%sContent-Length:            \\r\\n\\r\\n\", code,\n            mg_http_status_code_str(code), headers == NULL ? \"\" : headers);\n  len = c->send.len;\n  va_start(ap, fmt);\n  mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, &ap);\n  va_end(ap);\n  if (c->send.len > 16) {\n    size_t n = mg_snprintf((char *) &c->send.buf[len - 15], 11, \"%-10lu\",\n                           (unsigned long) (c->send.len - len));\n    c->send.buf[len - 15 + n] = ' ';  // Change ending 0 to space\n  }\n  c->is_resp = 0;\n}\n\nstatic void http_cb(struct mg_connection *, int, void *, void *);\nstatic void restore_http_cb(struct mg_connection *c) {\n  mg_fs_close((struct mg_fd *) c->pfn_data);\n  c->pfn_data = NULL;\n  c->pfn = http_cb;\n  c->is_resp = 0;\n}\n\nchar *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime);\nchar *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime) {\n  mg_snprintf(buf, len, \"\\\"%lld.%lld\\\"\", (int64_t) mtime, (int64_t) size);\n  return buf;\n}\n\nstatic void static_cb(struct mg_connection *c, int ev, void *ev_data,\n                      void *fn_data) {\n  if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {\n    struct mg_fd *fd = (struct mg_fd *) fn_data;\n    // Read to send IO buffer directly, avoid extra on-stack buffer\n    size_t n, max = MG_IO_SIZE, space;\n    size_t *cl = (size_t *) &c->data[(sizeof(c->data) - sizeof(size_t)) /\n                                     sizeof(size_t) * sizeof(size_t)];\n    if (c->send.size < max) mg_iobuf_resize(&c->send, max);\n    if (c->send.len >= c->send.size) return;  // Rate limit\n    if ((space = c->send.size - c->send.len) > *cl) space = *cl;\n    n = fd->fs->rd(fd->fd, c->send.buf + c->send.len, space);\n    c->send.len += n;\n    *cl -= n;\n    if (n == 0) restore_http_cb(c);\n  } else if (ev == MG_EV_CLOSE) {\n    restore_http_cb(c);\n  }\n  (void) ev_data;\n}\n\n// Known mime types. Keep it outside guess_content_type() function, since\n// some environments don't like it defined there.\n// clang-format off\nstatic struct mg_str s_known_types[] = {\n    MG_C_STR(\"html\"), MG_C_STR(\"text/html; charset=utf-8\"),\n    MG_C_STR(\"htm\"), MG_C_STR(\"text/html; charset=utf-8\"),\n    MG_C_STR(\"css\"), MG_C_STR(\"text/css; charset=utf-8\"),\n    MG_C_STR(\"js\"), MG_C_STR(\"text/javascript; charset=utf-8\"),\n    MG_C_STR(\"gif\"), MG_C_STR(\"image/gif\"),\n    MG_C_STR(\"png\"), MG_C_STR(\"image/png\"),\n    MG_C_STR(\"jpg\"), MG_C_STR(\"image/jpeg\"),\n    MG_C_STR(\"jpeg\"), MG_C_STR(\"image/jpeg\"),\n    MG_C_STR(\"woff\"), MG_C_STR(\"font/woff\"),\n    MG_C_STR(\"ttf\"), MG_C_STR(\"font/ttf\"),\n    MG_C_STR(\"svg\"), MG_C_STR(\"image/svg+xml\"),\n    MG_C_STR(\"txt\"), MG_C_STR(\"text/plain; charset=utf-8\"),\n    MG_C_STR(\"avi\"), MG_C_STR(\"video/x-msvideo\"),\n    MG_C_STR(\"csv\"), MG_C_STR(\"text/csv\"),\n    MG_C_STR(\"doc\"), MG_C_STR(\"application/msword\"),\n    MG_C_STR(\"exe\"), MG_C_STR(\"application/octet-stream\"),\n    MG_C_STR(\"gz\"), MG_C_STR(\"application/gzip\"),\n    MG_C_STR(\"ico\"), MG_C_STR(\"image/x-icon\"),\n    MG_C_STR(\"json\"), MG_C_STR(\"application/json\"),\n    MG_C_STR(\"mov\"), MG_C_STR(\"video/quicktime\"),\n    MG_C_STR(\"mp3\"), MG_C_STR(\"audio/mpeg\"),\n    MG_C_STR(\"mp4\"), MG_C_STR(\"video/mp4\"),\n    MG_C_STR(\"mpeg\"), MG_C_STR(\"video/mpeg\"),\n    MG_C_STR(\"pdf\"), MG_C_STR(\"application/pdf\"),\n    MG_C_STR(\"shtml\"), MG_C_STR(\"text/html; charset=utf-8\"),\n    MG_C_STR(\"tgz\"), MG_C_STR(\"application/tar-gz\"),\n    MG_C_STR(\"wav\"), MG_C_STR(\"audio/wav\"),\n    MG_C_STR(\"webp\"), MG_C_STR(\"image/webp\"),\n    MG_C_STR(\"zip\"), MG_C_STR(\"application/zip\"),\n    MG_C_STR(\"3gp\"), MG_C_STR(\"video/3gpp\"),\n    {0, 0},\n};\n// clang-format on\n\nstatic struct mg_str guess_content_type(struct mg_str path, const char *extra) {\n  struct mg_str k, v, s = mg_str(extra);\n  size_t i = 0;\n\n  // Shrink path to its extension only\n  while (i < path.len && path.ptr[path.len - i - 1] != '.') i++;\n  path.ptr += path.len - i;\n  path.len = i;\n\n  // Process user-provided mime type overrides, if any\n  while (mg_commalist(&s, &k, &v)) {\n    if (mg_strcmp(path, k) == 0) return v;\n  }\n\n  // Process built-in mime types\n  for (i = 0; s_known_types[i].ptr != NULL; i += 2) {\n    if (mg_strcmp(path, s_known_types[i]) == 0) return s_known_types[i + 1];\n  }\n\n  return mg_str(\"text/plain; charset=utf-8\");\n}\n\nstatic int getrange(struct mg_str *s, int64_t *a, int64_t *b) {\n  size_t i, numparsed = 0;\n  // MG_INFO((\"%.*s\", (int) s->len, s->ptr));\n  for (i = 0; i + 6 < s->len; i++) {\n    if (memcmp(&s->ptr[i], \"bytes=\", 6) == 0) {\n      struct mg_str p = mg_str_n(s->ptr + i + 6, s->len - i - 6);\n      if (p.len > 0 && p.ptr[0] >= '0' && p.ptr[0] <= '9') numparsed++;\n      *a = mg_to64(p);\n      // MG_INFO((\"PPP [%.*s] %d\", (int) p.len, p.ptr, numparsed));\n      while (p.len && p.ptr[0] >= '0' && p.ptr[0] <= '9') p.ptr++, p.len--;\n      if (p.len && p.ptr[0] == '-') p.ptr++, p.len--;\n      *b = mg_to64(p);\n      if (p.len > 0 && p.ptr[0] >= '0' && p.ptr[0] <= '9') numparsed++;\n      // MG_INFO((\"PPP [%.*s] %d\", (int) p.len, p.ptr, numparsed));\n      break;\n    }\n  }\n  return (int) numparsed;\n}\n\nvoid mg_http_serve_file(struct mg_connection *c, struct mg_http_message *hm,\n                        const char *path,\n                        const struct mg_http_serve_opts *opts) {\n  char etag[64], tmp[MG_PATH_MAX];\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct mg_fd *fd = NULL;\n  size_t size = 0;\n  time_t mtime = 0;\n  struct mg_str *inm = NULL;\n  struct mg_str mime = guess_content_type(mg_str(path), opts->mime_types);\n  bool gzip = false;\n\n  if (path != NULL) {\n    // If a browser sends us \"Accept-Encoding: gzip\", try to open .gz first\n    struct mg_str *ae = mg_http_get_header(hm, \"Accept-Encoding\");\n    if (ae != NULL && mg_strstr(*ae, mg_str(\"gzip\")) != NULL) {\n      mg_snprintf(tmp, sizeof(tmp), \"%s.gz\", path);\n      fd = mg_fs_open(fs, tmp, MG_FS_READ);\n      if (fd != NULL) gzip = true, path = tmp;\n    }\n    // No luck opening .gz? Open what we've told to open\n    if (fd == NULL) fd = mg_fs_open(fs, path, MG_FS_READ);\n  }\n\n  // Failed to open, and page404 is configured? Open it, then\n  if (fd == NULL && opts->page404 != NULL) {\n    fd = mg_fs_open(fs, opts->page404, MG_FS_READ);\n    mime = guess_content_type(mg_str(path), opts->mime_types);\n    path = opts->page404;\n  }\n\n  if (fd == NULL || fs->st(path, &size, &mtime) == 0) {\n    mg_http_reply(c, 404, opts->extra_headers, \"Not found\\n\");\n    mg_fs_close(fd);\n    // NOTE: mg_http_etag() call should go first!\n  } else if (mg_http_etag(etag, sizeof(etag), size, mtime) != NULL &&\n             (inm = mg_http_get_header(hm, \"If-None-Match\")) != NULL &&\n             mg_vcasecmp(inm, etag) == 0) {\n    mg_fs_close(fd);\n    mg_http_reply(c, 304, opts->extra_headers, \"\");\n  } else {\n    int n, status = 200;\n    char range[100];\n    int64_t r1 = 0, r2 = 0, cl = (int64_t) size;\n\n    // Handle Range header\n    struct mg_str *rh = mg_http_get_header(hm, \"Range\");\n    range[0] = '\\0';\n    if (rh != NULL && (n = getrange(rh, &r1, &r2)) > 0 && r1 >= 0 && r2 >= 0) {\n      // If range is specified like \"400-\", set second limit to content len\n      if (n == 1) r2 = cl - 1;\n      if (r1 > r2 || r2 >= cl) {\n        status = 416;\n        cl = 0;\n        mg_snprintf(range, sizeof(range), \"Content-Range: bytes */%lld\\r\\n\",\n                    (int64_t) size);\n      } else {\n        status = 206;\n        cl = r2 - r1 + 1;\n        mg_snprintf(range, sizeof(range),\n                    \"Content-Range: bytes %lld-%lld/%lld\\r\\n\", r1, r1 + cl - 1,\n                    (int64_t) size);\n        fs->sk(fd->fd, (size_t) r1);\n      }\n    }\n    mg_printf(c,\n              \"HTTP/1.1 %d %s\\r\\n\"\n              \"Content-Type: %.*s\\r\\n\"\n              \"Etag: %s\\r\\n\"\n              \"Content-Length: %llu\\r\\n\"\n              \"%s%s%s\\r\\n\",\n              status, mg_http_status_code_str(status), (int) mime.len, mime.ptr,\n              etag, cl, gzip ? \"Content-Encoding: gzip\\r\\n\" : \"\", range,\n              opts->extra_headers ? opts->extra_headers : \"\");\n    if (mg_vcasecmp(&hm->method, \"HEAD\") == 0) {\n      c->is_draining = 1;\n      c->is_resp = 0;\n      mg_fs_close(fd);\n    } else {\n      // Track to-be-sent content length at the end of c->data, aligned\n      size_t *clp = (size_t *) &c->data[(sizeof(c->data) - sizeof(size_t)) /\n                                        sizeof(size_t) * sizeof(size_t)];\n      c->pfn = static_cb;\n      c->pfn_data = fd;\n      *clp = (size_t) cl;\n    }\n  }\n}\n\nstruct printdirentrydata {\n  struct mg_connection *c;\n  struct mg_http_message *hm;\n  const struct mg_http_serve_opts *opts;\n  const char *dir;\n};\n\nstatic void printdirentry(const char *name, void *userdata) {\n  struct printdirentrydata *d = (struct printdirentrydata *) userdata;\n  struct mg_fs *fs = d->opts->fs == NULL ? &mg_fs_posix : d->opts->fs;\n  size_t size = 0;\n  time_t t = 0;\n  char path[MG_PATH_MAX], sz[40], mod[40];\n  int flags, n = 0;\n\n  // MG_DEBUG((\"[%s] [%s]\", d->dir, name));\n  if (mg_snprintf(path, sizeof(path), \"%s%c%s\", d->dir, '/', name) >\n      sizeof(path)) {\n    MG_ERROR((\"%s truncated\", name));\n  } else if ((flags = fs->st(path, &size, &t)) == 0) {\n    MG_ERROR((\"%lu stat(%s): %d\", d->c->id, path, errno));\n  } else {\n    const char *slash = flags & MG_FS_DIR ? \"/\" : \"\";\n    if (flags & MG_FS_DIR) {\n      mg_snprintf(sz, sizeof(sz), \"%s\", \"[DIR]\");\n    } else {\n      mg_snprintf(sz, sizeof(sz), \"%lld\", (uint64_t) size);\n    }\n#if defined(MG_HTTP_DIRLIST_TIME_FMT)\n    {\n      char time_str[40];\n      struct tm *time_info = localtime(&t);\n      strftime(time_str, sizeof time_str, \"%Y/%m/%d %H:%M:%S\", time_info);\n      mg_snprintf(mod, sizeof(mod), \"%s\", time_str);\n    }\n#else\n    mg_snprintf(mod, sizeof(mod), \"%lu\", (unsigned long) t);\n#endif\n    n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));\n    mg_printf(d->c,\n              \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"\n              \"<td name=%lu>%s</td><td name=%lld>%s</td></tr>\\n\",\n              n, path, slash, name, slash, (unsigned long) t, mod,\n              flags & MG_FS_DIR ? (int64_t) -1 : (int64_t) size, sz);\n  }\n}\n\nstatic void listdir(struct mg_connection *c, struct mg_http_message *hm,\n                    const struct mg_http_serve_opts *opts, char *dir) {\n  const char *sort_js_code =\n      \"<script>function srt(tb, sc, so, d) {\"\n      \"var tr = Array.prototype.slice.call(tb.rows, 0),\"\n      \"tr = tr.sort(function (a, b) { var c1 = a.cells[sc], c2 = b.cells[sc],\"\n      \"n1 = c1.getAttribute('name'), n2 = c2.getAttribute('name'), \"\n      \"t1 = a.cells[2].getAttribute('name'), \"\n      \"t2 = b.cells[2].getAttribute('name'); \"\n      \"return so * (t1 < 0 && t2 >= 0 ? -1 : t2 < 0 && t1 >= 0 ? 1 : \"\n      \"n1 ? parseInt(n2) - parseInt(n1) : \"\n      \"c1.textContent.trim().localeCompare(c2.textContent.trim())); });\";\n  const char *sort_js_code2 =\n      \"for (var i = 0; i < tr.length; i++) tb.appendChild(tr[i]); \"\n      \"if (!d) window.location.hash = ('sc=' + sc + '&so=' + so); \"\n      \"};\"\n      \"window.onload = function() {\"\n      \"var tb = document.getElementById('tb');\"\n      \"var m = /sc=([012]).so=(1|-1)/.exec(window.location.hash) || [0, 2, 1];\"\n      \"var sc = m[1], so = m[2]; document.onclick = function(ev) { \"\n      \"var c = ev.target.rel; if (c) {if (c == sc) so *= -1; srt(tb, c, so); \"\n      \"sc = c; ev.preventDefault();}};\"\n      \"srt(tb, sc, so, true);\"\n      \"}\"\n      \"</script>\";\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct printdirentrydata d = {c, hm, opts, dir};\n  char tmp[10], buf[MG_PATH_MAX];\n  size_t off, n;\n  int len = mg_url_decode(hm->uri.ptr, hm->uri.len, buf, sizeof(buf), 0);\n  struct mg_str uri = len > 0 ? mg_str_n(buf, (size_t) len) : hm->uri;\n\n  mg_printf(c,\n            \"HTTP/1.1 200 OK\\r\\n\"\n            \"Content-Type: text/html; charset=utf-8\\r\\n\"\n            \"%s\"\n            \"Content-Length:         \\r\\n\\r\\n\",\n            opts->extra_headers == NULL ? \"\" : opts->extra_headers);\n  off = c->send.len;  // Start of body\n  mg_printf(c,\n            \"<!DOCTYPE html><html><head><title>Index of %.*s</title>%s%s\"\n            \"<style>th,td {text-align: left; padding-right: 1em; \"\n            \"font-family: monospace; }</style></head>\"\n            \"<body><h1>Index of %.*s</h1><table cellpadding=\\\"0\\\"><thead>\"\n            \"<tr><th><a href=\\\"#\\\" rel=\\\"0\\\">Name</a></th><th>\"\n            \"<a href=\\\"#\\\" rel=\\\"1\\\">Modified</a></th>\"\n            \"<th><a href=\\\"#\\\" rel=\\\"2\\\">Size</a></th></tr>\"\n            \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\"\n            \"</thead>\"\n            \"<tbody id=\\\"tb\\\">\\n\",\n            (int) uri.len, uri.ptr, sort_js_code, sort_js_code2, (int) uri.len,\n            uri.ptr);\n  mg_printf(c, \"%s\",\n            \"  <tr><td><a href=\\\"..\\\">..</a></td>\"\n            \"<td name=-1></td><td name=-1>[DIR]</td></tr>\\n\");\n\n  fs->ls(dir, printdirentry, &d);\n  mg_printf(c,\n            \"</tbody><tfoot><tr><td colspan=\\\"3\\\"><hr></td></tr></tfoot>\"\n            \"</table><address>Mongoose v.%s</address></body></html>\\n\",\n            MG_VERSION);\n  n = mg_snprintf(tmp, sizeof(tmp), \"%lu\", (unsigned long) (c->send.len - off));\n  if (n > sizeof(tmp)) n = 0;\n  memcpy(c->send.buf + off - 12, tmp, n);  // Set content length\n  c->is_resp = 0;                          // Mark response end\n}\n\n// Resolve requested file into `path` and return its fs->st() result\nstatic int uri_to_path2(struct mg_connection *c, struct mg_http_message *hm,\n                        struct mg_fs *fs, struct mg_str url, struct mg_str dir,\n                        char *path, size_t path_size) {\n  int flags, tmp;\n  // Append URI to the root_dir, and sanitize it\n  size_t n = mg_snprintf(path, path_size, \"%.*s\", (int) dir.len, dir.ptr);\n  if (n > path_size) n = path_size;\n  path[path_size - 1] = '\\0';\n  if (n + 2 < path_size) path[n++] = '/', path[n] = '\\0';\n  mg_url_decode(hm->uri.ptr + url.len, hm->uri.len - url.len, path + n,\n                path_size - n, 0);\n  path[path_size - 1] = '\\0';  // Double-check\n  mg_remove_double_dots(path);\n  n = strlen(path);\n  while (n > 1 && path[n - 1] == '/') path[--n] = 0;  // Trim trailing slashes\n  flags = mg_vcmp(&hm->uri, \"/\") == 0 ? MG_FS_DIR : fs->st(path, NULL, NULL);\n  MG_VERBOSE((\"%lu %.*s -> %s %d\", c->id, (int) hm->uri.len, hm->uri.ptr, path,\n              flags));\n  if (flags == 0) {\n    // Do nothing - let's caller decide\n  } else if ((flags & MG_FS_DIR) && hm->uri.len > 0 &&\n             hm->uri.ptr[hm->uri.len - 1] != '/') {\n    mg_printf(c,\n              \"HTTP/1.1 301 Moved\\r\\n\"\n              \"Location: %.*s/\\r\\n\"\n              \"Content-Length: 0\\r\\n\"\n              \"\\r\\n\",\n              (int) hm->uri.len, hm->uri.ptr);\n    c->is_resp = 0;\n    flags = -1;\n  } else if (flags & MG_FS_DIR) {\n    if (((mg_snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX) > 0 &&\n          (tmp = fs->st(path, NULL, NULL)) != 0) ||\n         (mg_snprintf(path + n, path_size - n, \"/index.shtml\") > 0 &&\n          (tmp = fs->st(path, NULL, NULL)) != 0))) {\n      flags = tmp;\n    } else if ((mg_snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX \".gz\") >\n                    0 &&\n                (tmp = fs->st(path, NULL, NULL)) !=\n                    0)) {  // check for gzipped index\n      flags = tmp;\n      path[n + 1 + strlen(MG_HTTP_INDEX)] =\n          '\\0';  // Remove appended .gz in index file name\n    } else {\n      path[n] = '\\0';  // Remove appended index file name\n    }\n  }\n  return flags;\n}\n\nstatic int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,\n                       const struct mg_http_serve_opts *opts, char *path,\n                       size_t path_size) {\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};\n  while (mg_commalist(&s, &k, &v)) {\n    if (v.len == 0) v = k, k = mg_str(\"/\");\n    if (hm->uri.len < k.len) continue;\n    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;\n    u = k, p = v;\n  }\n  return uri_to_path2(c, hm, fs, u, p, path, path_size);\n}\n\nvoid mg_http_serve_dir(struct mg_connection *c, struct mg_http_message *hm,\n                       const struct mg_http_serve_opts *opts) {\n  char path[MG_PATH_MAX];\n  const char *sp = opts->ssi_pattern;\n  int flags = uri_to_path(c, hm, opts, path, sizeof(path));\n  if (flags < 0) {\n    // Do nothing: the response has already been sent by uri_to_path()\n  } else if (flags & MG_FS_DIR) {\n    listdir(c, hm, opts, path);\n  } else if (flags && sp != NULL &&\n             mg_globmatch(sp, strlen(sp), path, strlen(path))) {\n    mg_http_serve_ssi(c, opts->root_dir, path);\n  } else {\n    mg_http_serve_file(c, hm, path, opts);\n  }\n}\n\nstatic bool mg_is_url_safe(int c) {\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') ||\n         (c >= 'A' && c <= 'Z') || c == '.' || c == '_' || c == '-' || c == '~';\n}\n\nsize_t mg_url_encode(const char *s, size_t sl, char *buf, size_t len) {\n  size_t i, n = 0;\n  for (i = 0; i < sl; i++) {\n    int c = *(unsigned char *) &s[i];\n    if (n + 4 >= len) return 0;\n    if (mg_is_url_safe(c)) {\n      buf[n++] = s[i];\n    } else {\n      buf[n++] = '%';\n      mg_hex(&s[i], 1, &buf[n]);\n      n += 2;\n    }\n  }\n  if (len > 0 && n < len - 1) buf[n] = '\\0';  // Null-terminate the destination\n  if (len > 0) buf[len - 1] = '\\0';           // Always.\n  return n;\n}\n\nvoid mg_http_creds(struct mg_http_message *hm, char *user, size_t userlen,\n                   char *pass, size_t passlen) {\n  struct mg_str *v = mg_http_get_header(hm, \"Authorization\");\n  user[0] = pass[0] = '\\0';\n  if (v != NULL && v->len > 6 && memcmp(v->ptr, \"Basic \", 6) == 0) {\n    char buf[256];\n    int n = mg_base64_decode(v->ptr + 6, (int) v->len - 6, buf);\n    const char *p = (const char *) memchr(buf, ':', n > 0 ? (size_t) n : 0);\n    if (p != NULL) {\n      mg_snprintf(user, userlen, \"%.*s\", (int) (p - buf), buf);\n      mg_snprintf(pass, passlen, \"%.*s\", n - (int) (p - buf) - 1, p + 1);\n    }\n  } else if (v != NULL && v->len > 7 && memcmp(v->ptr, \"Bearer \", 7) == 0) {\n    mg_snprintf(pass, passlen, \"%.*s\", (int) v->len - 7, v->ptr + 7);\n  } else if ((v = mg_http_get_header(hm, \"Cookie\")) != NULL) {\n    struct mg_str t = mg_http_get_header_var(*v, mg_str_n(\"access_token\", 12));\n    if (t.len > 0) mg_snprintf(pass, passlen, \"%.*s\", (int) t.len, t.ptr);\n  } else {\n    mg_http_get_var(&hm->query, \"access_token\", pass, passlen);\n  }\n}\n\nstatic struct mg_str stripquotes(struct mg_str s) {\n  return s.len > 1 && s.ptr[0] == '\"' && s.ptr[s.len - 1] == '\"'\n             ? mg_str_n(s.ptr + 1, s.len - 2)\n             : s;\n}\n\nstruct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v) {\n  size_t i;\n  for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {\n    if (s.ptr[i + v.len] == '=' && memcmp(&s.ptr[i], v.ptr, v.len) == 0) {\n      const char *p = &s.ptr[i + v.len + 1], *b = p, *x = &s.ptr[s.len];\n      int q = p < x && *p == '\"' ? 1 : 0;\n      while (p < x &&\n             (q ? p == b || *p != '\"' : *p != ';' && *p != ' ' && *p != ','))\n        p++;\n      // MG_INFO((\"[%.*s] [%.*s] [%.*s]\", (int) s.len, s.ptr, (int) v.len,\n      // v.ptr, (int) (p - b), b));\n      return stripquotes(mg_str_n(b, (size_t) (p - b + q)));\n    }\n  }\n  return mg_str_n(NULL, 0);\n}\n\nbool mg_http_match_uri(const struct mg_http_message *hm, const char *glob) {\n  return mg_match(hm->uri, mg_str(glob), NULL);\n}\n\nlong mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                    struct mg_fs *fs, const char *path, size_t max_size) {\n  char buf[20] = \"0\";\n  long res = 0, offset;\n  mg_http_get_var(&hm->query, \"offset\", buf, sizeof(buf));\n  offset = strtol(buf, NULL, 0);\n  if (hm->body.len == 0) {\n    mg_http_reply(c, 200, \"\", \"%ld\", res);  // Nothing to write\n  } else {\n    struct mg_fd *fd;\n    size_t current_size = 0;\n    MG_DEBUG((\"%s -> %d bytes @ %ld\", path, (int) hm->body.len, offset));\n    if (offset == 0) fs->rm(path);  // If offset if 0, truncate file\n    fs->st(path, &current_size, NULL);\n    if (offset < 0) {\n      mg_http_reply(c, 400, \"\", \"offset required\");\n      res = -1;\n    } else if (offset > 0 && current_size != (size_t) offset) {\n      mg_http_reply(c, 400, \"\", \"%s: offset mismatch\", path);\n      res = -2;\n    } else if ((size_t) offset + hm->body.len > max_size) {\n      mg_http_reply(c, 400, \"\", \"%s: over max size of %lu\", path,\n                    (unsigned long) max_size);\n      res = -3;\n    } else if ((fd = mg_fs_open(fs, path, MG_FS_WRITE)) == NULL) {\n      mg_http_reply(c, 400, \"\", \"open(%s): %d\", path, errno);\n      res = -4;\n    } else {\n      res = offset + (long) fs->wr(fd->fd, hm->body.ptr, hm->body.len);\n      mg_fs_close(fd);\n      mg_http_reply(c, 200, \"\", \"%ld\", res);\n    }\n  }\n  return res;\n}\n\nint mg_http_status(const struct mg_http_message *hm) {\n  return atoi(hm->uri.ptr);\n}\n\n// If a server sends data to the client using chunked encoding, Mongoose strips\n// off the chunking prefix (hex length and \\r\\n) and suffix (\\r\\n), appends the\n// stripped data to the body, and fires the MG_EV_HTTP_CHUNK event.  When zero\n// chunk is received, we fire MG_EV_HTTP_MSG, and the body already has all\n// chunking prefixes/suffixes stripped.\n//\n// If a server sends data without chunked encoding, we also fire a series of\n// MG_EV_HTTP_CHUNK events for every received piece of data, and then we fire\n// MG_EV_HTTP_MSG event in the end.\n//\n// We track total processed length in the c->pfn_data, which is a void *\n// pointer: we store a size_t value there.\nstatic bool getchunk(struct mg_str s, size_t *prefixlen, size_t *datalen) {\n  size_t i = 0, n;\n  while (i < s.len && s.ptr[i] != '\\r' && s.ptr[i] != '\\n') i++;\n  n = mg_unhexn(s.ptr, i);\n  // MG_INFO((\"%d %d\", (int) (i + n + 4), (int) s.len));\n  if (s.len < i + n + 4) return false;  // Chunk not yet fully buffered\n  if (s.ptr[i] != '\\r' || s.ptr[i + 1] != '\\n') return false;\n  if (s.ptr[i + n + 2] != '\\r' || s.ptr[i + n + 3] != '\\n') return false;\n  *prefixlen = i + 2;\n  *datalen = n;\n  return true;\n}\n\nstatic bool mg_is_chunked(struct mg_http_message *hm) {\n  const char *needle = \"chunked\";\n  struct mg_str *te = mg_http_get_header(hm, \"Transfer-Encoding\");\n  return te != NULL && mg_vcasecmp(te, needle) == 0;\n}\n\nvoid mg_http_delete_chunk(struct mg_connection *c, struct mg_http_message *hm) {\n  size_t ofs = (size_t) (hm->chunk.ptr - (char *) c->recv.buf);\n  mg_iobuf_del(&c->recv, ofs, hm->chunk.len);\n  c->pfn_data = (void *) ((size_t) c->pfn_data | MG_DMARK);\n}\n\nstatic void deliver_chunked_chunks(struct mg_connection *c, size_t hlen,\n                                   struct mg_http_message *hm, bool *next) {\n  //  |  ... headers ... | HEXNUM\\r\\n ..data.. \\r\\n | ......\n  //  +------------------+--------------------------+----\n  //  |      hlen        |           chunk1         | ......\n  char *buf = (char *) &c->recv.buf[hlen], *p = buf;\n  size_t len = c->recv.len - hlen;\n  size_t processed = ((size_t) c->pfn_data) & ~MG_DMARK;\n  size_t mark, pl, dl, del = 0, ofs = 0;\n  bool last = false;\n  if (processed <= len) len -= processed, buf += processed;\n  while (!last && getchunk(mg_str_n(buf + ofs, len - ofs), &pl, &dl)) {\n    size_t saved = c->recv.len;\n    memmove(p + processed, buf + ofs + pl, dl);\n    // MG_INFO((\"P2 [%.*s]\", (int) (processed + dl), p));\n    hm->chunk = mg_str_n(p + processed, dl);\n    mg_call(c, MG_EV_HTTP_CHUNK, hm);\n    ofs += pl + dl + 2, del += pl + 2;  // 2 is for \\r\\n suffix\n    processed += dl;\n    if (c->recv.len != saved) processed -= dl, buf -= dl;\n    // mg_hexdump(c->recv.buf, hlen + processed);\n    last = (dl == 0);\n  }\n  mg_iobuf_del(&c->recv, hlen + processed, del);\n  mark = ((size_t) c->pfn_data) & MG_DMARK;\n  c->pfn_data = (void *) (processed | mark);\n  if (last) {\n    hm->body.len = processed;\n    hm->message.len = hlen + processed;\n    c->pfn_data = NULL;\n    if (mark) mg_iobuf_del(&c->recv, 0, hlen), *next = true;\n    // MG_INFO((\"LAST, mark: %lx\", mark));\n    // mg_hexdump(c->recv.buf, c->recv.len);\n  }\n}\n\nstatic void deliver_normal_chunks(struct mg_connection *c, size_t hlen,\n                                  struct mg_http_message *hm, bool *next) {\n  size_t left, processed = ((size_t) c->pfn_data) & ~MG_DMARK;\n  size_t deleted = ((size_t) c->pfn_data) & MG_DMARK;\n  hm->chunk = mg_str_n((char *) &c->recv.buf[hlen], c->recv.len - hlen);\n  if (processed <= hm->chunk.len && !deleted) {\n    hm->chunk.len -= processed;\n    hm->chunk.ptr += processed;\n  }\n  left = hm->body.len < processed ? 0 : hm->body.len - processed;\n  if (hm->chunk.len > left) hm->chunk.len = left;\n  if (hm->chunk.len > 0) mg_call(c, MG_EV_HTTP_CHUNK, hm);\n  processed += hm->chunk.len;\n  deleted = ((size_t) c->pfn_data) & MG_DMARK;  // Re-evaluate after user call\n  if (processed >= hm->body.len) {              // Last, 0-len chunk\n    hm->chunk.len = 0;                          // Reset length\n    mg_call(c, MG_EV_HTTP_CHUNK, hm);           // Call user handler\n    c->pfn_data = NULL;                         // Reset processed counter\n    if (processed && deleted) mg_iobuf_del(&c->recv, 0, hlen), *next = true;\n  } else {\n    c->pfn_data = (void *) (processed | deleted);  // if it is set\n  }\n}\n\nstatic void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n  if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {\n    struct mg_http_message hm;\n    // mg_hexdump(c->recv.buf, c->recv.len);\n    while (c->recv.buf != NULL && c->recv.len > 0) {\n      bool next = false;\n      int hlen = mg_http_parse((char *) c->recv.buf, c->recv.len, &hm);\n      if (hlen < 0) {\n        mg_error(c, \"HTTP parse:\\n%.*s\", (int) c->recv.len, c->recv.buf);\n        break;\n      }\n      if (c->is_resp) break;           // Response is still generated\n      if (hlen == 0) break;            // Request is not buffered yet\n      if (ev == MG_EV_CLOSE) {         // If client did not set Content-Length\n        hm.message.len = c->recv.len;  // and closes now, deliver a MSG\n        hm.body.len = hm.message.len - (size_t) (hm.body.ptr - hm.message.ptr);\n      }\n      if (mg_is_chunked(&hm)) {\n        deliver_chunked_chunks(c, (size_t) hlen, &hm, &next);\n      } else {\n        deliver_normal_chunks(c, (size_t) hlen, &hm, &next);\n      }\n      if (next) continue;  // Chunks & request were deleted\n      //  Chunk events are delivered. If we have full body, deliver MSG\n      if (c->recv.len < hm.message.len) break;\n      if (c->is_accepted) c->is_resp = 1;  // Start generating response\n      mg_call(c, MG_EV_HTTP_MSG, &hm);     // User handler can clear is_resp\n      mg_iobuf_del(&c->recv, 0, hm.message.len);\n    }\n  }\n  (void) evd, (void) fnd;\n}\n\nstatic void mg_hfn(struct mg_connection *c, int ev, void *ev_data, void *fnd) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    if (mg_http_match_uri(hm, \"/quit\")) {\n      mg_http_reply(c, 200, \"\", \"ok\\n\");\n      c->is_draining = 1;\n      c->data[0] = 'X';\n    } else if (mg_http_match_uri(hm, \"/debug\")) {\n      int level = (int) mg_json_get_long(hm->body, \"$.level\", MG_LL_DEBUG);\n      mg_log_set(level);\n      mg_http_reply(c, 200, \"\", \"Debug level set to %d\\n\", level);\n    } else {\n      mg_http_reply(c, 200, \"\", \"hi\\n\");\n    }\n  } else if (ev == MG_EV_CLOSE) {\n    if (c->data[0] == 'X') *(bool *) fnd = true;\n  }\n}\n\nvoid mg_hello(const char *url) {\n  struct mg_mgr mgr;\n  bool done = false;\n  mg_mgr_init(&mgr);\n  if (mg_http_listen(&mgr, url, mg_hfn, &done) == NULL) done = true;\n  while (done == false) mg_mgr_poll(&mgr, 100);\n  mg_mgr_free(&mgr);\n}\n\nstruct mg_connection *mg_http_connect(struct mg_mgr *mgr, const char *url,\n                                      mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = http_cb;\n  return c;\n}\n\nstruct mg_connection *mg_http_listen(struct mg_mgr *mgr, const char *url,\n                                     mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = http_cb;\n  return c;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/iobuf.c\"\n#endif\n\n\n\n\n// Not using memset for zeroing memory, cause it can be dropped by compiler\n// See https://github.com/cesanta/mongoose/pull/1265\nstatic void zeromem(volatile unsigned char *buf, size_t len) {\n  if (buf != NULL) {\n    while (len--) *buf++ = 0;\n  }\n}\n\nstatic size_t roundup(size_t size, size_t align) {\n  return align == 0 ? size : (size + align - 1) / align * align;\n}\n\nint mg_iobuf_resize(struct mg_iobuf *io, size_t new_size) {\n  int ok = 1;\n  new_size = roundup(new_size, io->align);\n  if (new_size == 0) {\n    zeromem(io->buf, io->size);\n    free(io->buf);\n    io->buf = NULL;\n    io->len = io->size = 0;\n  } else if (new_size != io->size) {\n    // NOTE(lsm): do not use realloc here. Use calloc/free only, to ease the\n    // porting to some obscure platforms like FreeRTOS\n    void *p = calloc(1, new_size);\n    if (p != NULL) {\n      size_t len = new_size < io->len ? new_size : io->len;\n      if (len > 0 && io->buf != NULL) memmove(p, io->buf, len);\n      zeromem(io->buf, io->size);\n      free(io->buf);\n      io->buf = (unsigned char *) p;\n      io->size = new_size;\n    } else {\n      ok = 0;\n      MG_ERROR((\"%lld->%lld\", (uint64_t) io->size, (uint64_t) new_size));\n    }\n  }\n  return ok;\n}\n\nint mg_iobuf_init(struct mg_iobuf *io, size_t size, size_t align) {\n  io->buf = NULL;\n  io->align = align;\n  io->size = io->len = 0;\n  return mg_iobuf_resize(io, size);\n}\n\nsize_t mg_iobuf_add(struct mg_iobuf *io, size_t ofs, const void *buf,\n                    size_t len) {\n  size_t new_size = roundup(io->len + len, io->align);\n  mg_iobuf_resize(io, new_size);      // Attempt to resize\n  if (new_size != io->size) len = 0;  // Resize failure, append nothing\n  if (ofs < io->len) memmove(io->buf + ofs + len, io->buf + ofs, io->len - ofs);\n  if (buf != NULL) memmove(io->buf + ofs, buf, len);\n  if (ofs > io->len) io->len += ofs - io->len;\n  io->len += len;\n  return len;\n}\n\nsize_t mg_iobuf_del(struct mg_iobuf *io, size_t ofs, size_t len) {\n  if (ofs > io->len) ofs = io->len;\n  if (ofs + len > io->len) len = io->len - ofs;\n  if (io->buf) memmove(io->buf + ofs, io->buf + ofs + len, io->len - ofs - len);\n  if (io->buf) zeromem(io->buf + io->len - len, len);\n  io->len -= len;\n  return len;\n}\n\nvoid mg_iobuf_free(struct mg_iobuf *io) {\n  mg_iobuf_resize(io, 0);\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/json.c\"\n#endif\n\n\n\n\nstatic const char *escapeseq(int esc) {\n  return esc ? \"\\b\\f\\n\\r\\t\\\\\\\"\" : \"bfnrt\\\\\\\"\";\n}\n\nstatic char json_esc(int c, int esc) {\n  const char *p, *esc1 = escapeseq(esc), *esc2 = escapeseq(!esc);\n  for (p = esc1; *p != '\\0'; p++) {\n    if (*p == c) return esc2[p - esc1];\n  }\n  return 0;\n}\n\nstatic int mg_pass_string(const char *s, int len) {\n  int i;\n  for (i = 0; i < len; i++) {\n    if (s[i] == '\\\\' && i + 1 < len && json_esc(s[i + 1], 1)) {\n      i++;\n    } else if (s[i] == '\\0') {\n      return MG_JSON_INVALID;\n    } else if (s[i] == '\"') {\n      return i;\n    }\n  }\n  return MG_JSON_INVALID;\n}\n\nstatic double mg_atod(const char *p, int len, int *numlen) {\n  double d = 0.0;\n  int i = 0, sign = 1;\n\n  // Sign\n  if (i < len && *p == '-') {\n    sign = -1, i++;\n  } else if (i < len && *p == '+') {\n    i++;\n  }\n\n  // Decimal\n  for (; i < len && p[i] >= '0' && p[i] <= '9'; i++) {\n    d *= 10.0;\n    d += p[i] - '0';\n  }\n  d *= sign;\n\n  // Fractional\n  if (i < len && p[i] == '.') {\n    double frac = 0.0, base = 0.1;\n    i++;\n    for (; i < len && p[i] >= '0' && p[i] <= '9'; i++) {\n      frac += base * (p[i] - '0');\n      base /= 10.0;\n    }\n    d += frac * sign;\n  }\n\n  // Exponential\n  if (i < len && (p[i] == 'e' || p[i] == 'E')) {\n    int j, exp = 0, minus = 0;\n    i++;\n    if (i < len && p[i] == '-') minus = 1, i++;\n    if (i < len && p[i] == '+') i++;\n    while (i < len && p[i] >= '0' && p[i] <= '9' && exp < 308)\n      exp = exp * 10 + (p[i++] - '0');\n    if (minus) exp = -exp;\n    for (j = 0; j < exp; j++) d *= 10.0;\n    for (j = 0; j < -exp; j++) d /= 10.0;\n  }\n\n  if (numlen != NULL) *numlen = i;\n  return d;\n}\n\nint mg_json_get(struct mg_str json, const char *path, int *toklen) {\n  const char *s = json.ptr;\n  int len = (int) json.len;\n  enum { S_VALUE, S_KEY, S_COLON, S_COMMA_OR_EOO } expecting = S_VALUE;\n  unsigned char nesting[MG_JSON_MAX_DEPTH];\n  int i = 0;             // Current offset in `s`\n  int j = 0;             // Offset in `s` we're looking for (return value)\n  int depth = 0;         // Current depth (nesting level)\n  int ed = 0;            // Expected depth\n  int pos = 1;           // Current position in `path`\n  int ci = -1, ei = -1;  // Current and expected index in array\n\n  if (toklen) *toklen = 0;\n  if (path[0] != '$') return MG_JSON_INVALID;\n\n#define MG_CHECKRET(x)                                  \\\n  do {                                                  \\\n    if (depth == ed && path[pos] == '\\0' && ci == ei) { \\\n      if (toklen) *toklen = i - j + 1;                  \\\n      return j;                                         \\\n    }                                                   \\\n  } while (0)\n\n// In the ascii table, the distance between `[` and `]` is 2.\n// Ditto for `{` and `}`. Hence +2 in the code below.\n#define MG_EOO(x)                                            \\\n  do {                                                       \\\n    if (depth == ed && ci != ei) return MG_JSON_NOT_FOUND;   \\\n    if (c != nesting[depth - 1] + 2) return MG_JSON_INVALID; \\\n    depth--;                                                 \\\n    MG_CHECKRET(x);                                          \\\n  } while (0)\n\n  for (i = 0; i < len; i++) {\n    unsigned char c = ((unsigned char *) s)[i];\n    if (c == ' ' || c == '\\t' || c == '\\n' || c == '\\r') continue;\n    switch (expecting) {\n      case S_VALUE:\n        // p(\"V %s [%.*s] %d %d %d %d\\n\", path, pos, path, depth, ed, ci, ei);\n        if (depth == ed) j = i;\n        if (c == '{') {\n          if (depth >= (int) sizeof(nesting)) return MG_JSON_TOO_DEEP;\n          if (depth == ed && path[pos] == '.' && ci == ei) {\n            // If we start the object, reset array indices\n            ed++, pos++, ci = ei = -1;\n          }\n          nesting[depth++] = c;\n          expecting = S_KEY;\n          break;\n        } else if (c == '[') {\n          if (depth >= (int) sizeof(nesting)) return MG_JSON_TOO_DEEP;\n          if (depth == ed && path[pos] == '[' && ei == ci) {\n            ed++, pos++, ci = 0;\n            for (ei = 0; path[pos] != ']' && path[pos] != '\\0'; pos++) {\n              ei *= 10;\n              ei += path[pos] - '0';\n            }\n            if (path[pos] != 0) pos++;\n          }\n          nesting[depth++] = c;\n          break;\n        } else if (c == ']' && depth > 0) {  // Empty array\n          MG_EOO(']');\n        } else if (c == 't' && i + 3 < len && memcmp(&s[i], \"true\", 4) == 0) {\n          i += 3;\n        } else if (c == 'n' && i + 3 < len && memcmp(&s[i], \"null\", 4) == 0) {\n          i += 3;\n        } else if (c == 'f' && i + 4 < len && memcmp(&s[i], \"false\", 5) == 0) {\n          i += 4;\n        } else if (c == '-' || ((c >= '0' && c <= '9'))) {\n          int numlen = 0;\n          mg_atod(&s[i], len - i, &numlen);\n          i += numlen - 1;\n        } else if (c == '\"') {\n          int n = mg_pass_string(&s[i + 1], len - i - 1);\n          if (n < 0) return n;\n          i += n + 1;\n        } else {\n          return MG_JSON_INVALID;\n        }\n        MG_CHECKRET('V');\n        if (depth == ed && ei >= 0) ci++;\n        expecting = S_COMMA_OR_EOO;\n        break;\n\n      case S_KEY:\n        if (c == '\"') {\n          int n = mg_pass_string(&s[i + 1], len - i - 1);\n          if (n < 0) return n;\n          if (i + 1 + n >= len) return MG_JSON_NOT_FOUND;\n          if (depth < ed) return MG_JSON_NOT_FOUND;\n          if (depth == ed && path[pos - 1] != '.') return MG_JSON_NOT_FOUND;\n          // printf(\"K %s [%.*s] [%.*s] %d %d %d\\n\", path, pos, path, n,\n          //  &s[i + 1], n, depth, ed);\n          // NOTE(cpq): in the check sequence below is important.\n          // strncmp() must go first: it fails fast if the remaining length of\n          // the path is smaller than `n`.\n          if (depth == ed && path[pos - 1] == '.' &&\n              strncmp(&s[i + 1], &path[pos], (size_t) n) == 0 &&\n              (path[pos + n] == '\\0' || path[pos + n] == '.' ||\n               path[pos + n] == '[')) {\n            pos += n;\n          }\n          i += n + 1;\n          expecting = S_COLON;\n        } else if (c == '}') {  // Empty object\n          MG_EOO('}');\n          expecting = S_COMMA_OR_EOO;\n        } else {\n          return MG_JSON_INVALID;\n        }\n        break;\n\n      case S_COLON:\n        if (c == ':') {\n          expecting = S_VALUE;\n        } else {\n          return MG_JSON_INVALID;\n        }\n        break;\n\n      case S_COMMA_OR_EOO:\n        if (depth <= 0) {\n          return MG_JSON_INVALID;\n        } else if (c == ',') {\n          expecting = (nesting[depth - 1] == '{') ? S_KEY : S_VALUE;\n        } else if (c == ']' || c == '}') {\n          MG_EOO('O');\n          if (depth == ed && ei >= 0) ci++;\n        } else {\n          return MG_JSON_INVALID;\n        }\n        break;\n    }\n  }\n  return MG_JSON_NOT_FOUND;\n}\n\nbool mg_json_get_num(struct mg_str json, const char *path, double *v) {\n  int n, toklen, found = 0;\n  if ((n = mg_json_get(json, path, &toklen)) >= 0 &&\n      (json.ptr[n] == '-' || (json.ptr[n] >= '0' && json.ptr[n] <= '9'))) {\n    if (v != NULL) *v = mg_atod(json.ptr + n, toklen, NULL);\n    found = 1;\n  }\n  return found;\n}\n\nbool mg_json_get_bool(struct mg_str json, const char *path, bool *v) {\n  int found = 0, off = mg_json_get(json, path, NULL);\n  if (off >= 0 && (json.ptr[off] == 't' || json.ptr[off] == 'f')) {\n    if (v != NULL) *v = json.ptr[off] == 't';\n    found = 1;\n  }\n  return found;\n}\n\nstatic bool json_unescape(const char *s, size_t len, char *to, size_t n) {\n  size_t i, j;\n  for (i = 0, j = 0; i < len && j < n; i++, j++) {\n    if (s[i] == '\\\\' && i + 5 < len && s[i + 1] == 'u') {\n      //  \\uXXXX escape. We could process a simple one-byte chars\n      // \\u00xx from the ASCII range. More complex chars would require\n      // dragging in a UTF8 library, which is too much for us\n      if (s[i + 2] != '0' || s[i + 3] != '0') return false;  // Give up\n      ((unsigned char *) to)[j] = (unsigned char) mg_unhexn(s + i + 4, 2);\n\n      i += 5;\n    } else if (s[i] == '\\\\' && i + 1 < len) {\n      char c = json_esc(s[i + 1], 0);\n      if (c == 0) return false;\n      to[j] = c;\n      i++;\n    } else {\n      to[j] = s[i];\n    }\n  }\n  if (j >= n) return false;\n  if (n > 0) to[j] = '\\0';\n  return true;\n}\n\nchar *mg_json_get_str(struct mg_str json, const char *path) {\n  char *result = NULL;\n  int len = 0, off = mg_json_get(json, path, &len);\n  if (off >= 0 && len > 1 && json.ptr[off] == '\"') {\n    if ((result = (char *) calloc(1, (size_t) len)) != NULL &&\n        !json_unescape(json.ptr + off + 1, (size_t) (len - 2), result,\n                       (size_t) len)) {\n      free(result);\n      result = NULL;\n    }\n  }\n  return result;\n}\n\nchar *mg_json_get_b64(struct mg_str json, const char *path, int *slen) {\n  char *result = NULL;\n  int len = 0, off = mg_json_get(json, path, &len);\n  if (off >= 0 && json.ptr[off] == '\"' && len > 1 &&\n      (result = (char *) calloc(1, (size_t) len)) != NULL) {\n    int k = mg_base64_decode(json.ptr + off + 1, len - 2, result);\n    if (slen != NULL) *slen = k;\n  }\n  return result;\n}\n\nchar *mg_json_get_hex(struct mg_str json, const char *path, int *slen) {\n  char *result = NULL;\n  int len = 0, off = mg_json_get(json, path, &len);\n  if (off >= 0 && json.ptr[off] == '\"' && len > 1 &&\n      (result = (char *) calloc(1, (size_t) len / 2)) != NULL) {\n    mg_unhex(json.ptr + off + 1, (size_t) (len - 2), (uint8_t *) result);\n    result[len / 2 - 1] = '\\0';\n    if (slen != NULL) *slen = len / 2 - 1;\n  }\n  return result;\n}\n\nlong mg_json_get_long(struct mg_str json, const char *path, long dflt) {\n  double dv;\n  long result = dflt;\n  if (mg_json_get_num(json, path, &dv)) result = (long) dv;\n  return result;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/log.c\"\n#endif\n\n\n\n\n\nstatic int s_level = MG_LL_INFO;\nstatic mg_pfn_t s_log_func = mg_pfn_stdout;\nstatic void *s_log_func_param = NULL;\n\nvoid mg_log_set_fn(mg_pfn_t fn, void *param) {\n  s_log_func = fn;\n  s_log_func_param = param;\n}\n\nstatic void logc(unsigned char c) {\n  s_log_func((char) c, s_log_func_param);\n}\n\nstatic void logs(const char *buf, size_t len) {\n  size_t i;\n  for (i = 0; i < len; i++) logc(((unsigned char *) buf)[i]);\n}\n\nvoid mg_log_set(int log_level) {\n  MG_DEBUG((\"Setting log level to %d\", log_level));\n  s_level = log_level;\n}\n\nbool mg_log_prefix(int level, const char *file, int line, const char *fname) {\n  if (level <= s_level) {\n    const char *p = strrchr(file, '/');\n    char buf[41];\n    size_t n;\n    if (p == NULL) p = strrchr(file, '\\\\');\n    n = mg_snprintf(buf, sizeof(buf), \"%-6llx %d %s:%d:%s\", mg_millis(), level,\n                    p == NULL ? file : p + 1, line, fname);\n    if (n > sizeof(buf) - 2) n = sizeof(buf) - 2;\n    while (n < sizeof(buf)) buf[n++] = ' ';\n    logs(buf, n - 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid mg_log(const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  mg_vxprintf(s_log_func, s_log_func_param, fmt, &ap);\n  va_end(ap);\n  logc((unsigned char) '\\n');\n}\n\nstatic unsigned char nibble(unsigned c) {\n  return (unsigned char) (c < 10 ? c + '0' : c + 'W');\n}\n\n#define ISPRINT(x) ((x) >= ' ' && (x) <= '~')\nvoid mg_hexdump(const void *buf, size_t len) {\n  const unsigned char *p = (const unsigned char *) buf;\n  unsigned char ascii[16], alen = 0;\n  size_t i;\n  for (i = 0; i < len; i++) {\n    if ((i % 16) == 0) {\n      // Print buffered ascii chars\n      if (i > 0) logs(\"  \", 2), logs((char *) ascii, 16), logc('\\n'), alen = 0;\n      // Print hex address, then \\t\n      logc(nibble((i >> 12) & 15)), logc(nibble((i >> 8) & 15)),\n          logc(nibble((i >> 4) & 15)), logc('0'), logs(\"   \", 3);\n    }\n    logc(nibble(p[i] >> 4)), logc(nibble(p[i] & 15));  // Two nibbles, e.g. c5\n    logc(' ');                                         // Space after hex number\n    ascii[alen++] = ISPRINT(p[i]) ? p[i] : '.';        // Add to the ascii buf\n  }\n  while (alen < 16) logs(\"   \", 3), ascii[alen++] = ' ';\n  logs(\"  \", 2), logs((char *) ascii, 16), logc('\\n');\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/md5.c\"\n#endif\n\n\n\n#if defined(MG_ENABLE_MD5) && MG_ENABLE_MD5\n\nstatic void mg_byte_reverse(unsigned char *buf, unsigned longs) {\n  if (MG_BIG_ENDIAN) {\n    do {\n      uint32_t t = (uint32_t) ((unsigned) buf[3] << 8 | buf[2]) << 16 |\n                   ((unsigned) buf[1] << 8 | buf[0]);\n      *(uint32_t *) buf = t;\n      buf += 4;\n    } while (--longs);\n  } else {\n    (void) buf, (void) longs;  // Little endian. Do nothing\n  }\n}\n\n#define F1(x, y, z) (z ^ (x & (y ^ z)))\n#define F2(x, y, z) F1(z, x, y)\n#define F3(x, y, z) (x ^ y ^ z)\n#define F4(x, y, z) (y ^ (x | ~z))\n\n#define MD5STEP(f, w, x, y, z, data, s) \\\n  (w += f(x, y, z) + data, w = w << s | w >> (32 - s), w += x)\n\n/*\n * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious\n * initialization constants.\n */\nvoid mg_md5_init(mg_md5_ctx *ctx) {\n  ctx->buf[0] = 0x67452301;\n  ctx->buf[1] = 0xefcdab89;\n  ctx->buf[2] = 0x98badcfe;\n  ctx->buf[3] = 0x10325476;\n\n  ctx->bits[0] = 0;\n  ctx->bits[1] = 0;\n}\n\nstatic void mg_md5_transform(uint32_t buf[4], uint32_t const in[16]) {\n  uint32_t a, b, c, d;\n\n  a = buf[0];\n  b = buf[1];\n  c = buf[2];\n  d = buf[3];\n\n  MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);\n  MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);\n  MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);\n  MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);\n  MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);\n  MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);\n  MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);\n  MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);\n  MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);\n  MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);\n  MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);\n  MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);\n  MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);\n  MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);\n  MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);\n  MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);\n\n  MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);\n  MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);\n  MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);\n  MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);\n  MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);\n  MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);\n  MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);\n  MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);\n  MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);\n  MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);\n  MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);\n  MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);\n  MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);\n  MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);\n  MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);\n  MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);\n\n  MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);\n  MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);\n  MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);\n  MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);\n  MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);\n  MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);\n  MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);\n  MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);\n  MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);\n  MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);\n  MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);\n  MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);\n  MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);\n  MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);\n  MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);\n  MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);\n\n  MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);\n  MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);\n  MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);\n  MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);\n  MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);\n  MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);\n  MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);\n  MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);\n  MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);\n  MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);\n  MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);\n  MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);\n  MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);\n  MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);\n  MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);\n  MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);\n\n  buf[0] += a;\n  buf[1] += b;\n  buf[2] += c;\n  buf[3] += d;\n}\n\nvoid mg_md5_update(mg_md5_ctx *ctx, const unsigned char *buf, size_t len) {\n  uint32_t t;\n\n  t = ctx->bits[0];\n  if ((ctx->bits[0] = t + ((uint32_t) len << 3)) < t) ctx->bits[1]++;\n  ctx->bits[1] += (uint32_t) len >> 29;\n\n  t = (t >> 3) & 0x3f;\n\n  if (t) {\n    unsigned char *p = (unsigned char *) ctx->in + t;\n\n    t = 64 - t;\n    if (len < t) {\n      memcpy(p, buf, len);\n      return;\n    }\n    memcpy(p, buf, t);\n    mg_byte_reverse(ctx->in, 16);\n    mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);\n    buf += t;\n    len -= t;\n  }\n\n  while (len >= 64) {\n    memcpy(ctx->in, buf, 64);\n    mg_byte_reverse(ctx->in, 16);\n    mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);\n    buf += 64;\n    len -= 64;\n  }\n\n  memcpy(ctx->in, buf, len);\n}\n\nvoid mg_md5_final(mg_md5_ctx *ctx, unsigned char digest[16]) {\n  unsigned count;\n  unsigned char *p;\n  uint32_t *a;\n\n  count = (ctx->bits[0] >> 3) & 0x3F;\n\n  p = ctx->in + count;\n  *p++ = 0x80;\n  count = 64 - 1 - count;\n  if (count < 8) {\n    memset(p, 0, count);\n    mg_byte_reverse(ctx->in, 16);\n    mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);\n    memset(ctx->in, 0, 56);\n  } else {\n    memset(p, 0, count - 8);\n  }\n  mg_byte_reverse(ctx->in, 14);\n\n  a = (uint32_t *) ctx->in;\n  a[14] = ctx->bits[0];\n  a[15] = ctx->bits[1];\n\n  mg_md5_transform(ctx->buf, (uint32_t *) ctx->in);\n  mg_byte_reverse((unsigned char *) ctx->buf, 4);\n  memcpy(digest, ctx->buf, 16);\n  memset((char *) ctx, 0, sizeof(*ctx));\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/mqtt.c\"\n#endif\n\n\n\n\n\n\n\n\n#define MQTT_CLEAN_SESSION 0x02\n#define MQTT_HAS_WILL 0x04\n#define MQTT_WILL_RETAIN 0x20\n#define MQTT_HAS_PASSWORD 0x40\n#define MQTT_HAS_USER_NAME 0x80\n\nstruct mg_mqtt_pmap {\n  uint8_t id;\n  uint8_t type;\n};\n\nstatic const struct mg_mqtt_pmap s_prop_map[] = {\n    {MQTT_PROP_PAYLOAD_FORMAT_INDICATOR, MQTT_PROP_TYPE_BYTE},\n    {MQTT_PROP_MESSAGE_EXPIRY_INTERVAL, MQTT_PROP_TYPE_INT},\n    {MQTT_PROP_CONTENT_TYPE, MQTT_PROP_TYPE_STRING},\n    {MQTT_PROP_RESPONSE_TOPIC, MQTT_PROP_TYPE_STRING},\n    {MQTT_PROP_CORRELATION_DATA, MQTT_PROP_TYPE_BINARY_DATA},\n    {MQTT_PROP_SUBSCRIPTION_IDENTIFIER, MQTT_PROP_TYPE_VARIABLE_INT},\n    {MQTT_PROP_SESSION_EXPIRY_INTERVAL, MQTT_PROP_TYPE_INT},\n    {MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, MQTT_PROP_TYPE_STRING},\n    {MQTT_PROP_SERVER_KEEP_ALIVE, MQTT_PROP_TYPE_SHORT},\n    {MQTT_PROP_AUTHENTICATION_METHOD, MQTT_PROP_TYPE_STRING},\n    {MQTT_PROP_AUTHENTICATION_DATA, MQTT_PROP_TYPE_BINARY_DATA},\n    {MQTT_PROP_REQUEST_PROBLEM_INFORMATION, MQTT_PROP_TYPE_BYTE},\n    {MQTT_PROP_WILL_DELAY_INTERVAL, MQTT_PROP_TYPE_INT},\n    {MQTT_PROP_REQUEST_RESPONSE_INFORMATION, MQTT_PROP_TYPE_BYTE},\n    {MQTT_PROP_RESPONSE_INFORMATION, MQTT_PROP_TYPE_STRING},\n    {MQTT_PROP_SERVER_REFERENCE, MQTT_PROP_TYPE_STRING},\n    {MQTT_PROP_REASON_STRING, MQTT_PROP_TYPE_STRING},\n    {MQTT_PROP_RECEIVE_MAXIMUM, MQTT_PROP_TYPE_SHORT},\n    {MQTT_PROP_TOPIC_ALIAS_MAXIMUM, MQTT_PROP_TYPE_SHORT},\n    {MQTT_PROP_TOPIC_ALIAS, MQTT_PROP_TYPE_SHORT},\n    {MQTT_PROP_MAXIMUM_QOS, MQTT_PROP_TYPE_BYTE},\n    {MQTT_PROP_RETAIN_AVAILABLE, MQTT_PROP_TYPE_BYTE},\n    {MQTT_PROP_USER_PROPERTY, MQTT_PROP_TYPE_STRING_PAIR},\n    {MQTT_PROP_MAXIMUM_PACKET_SIZE, MQTT_PROP_TYPE_INT},\n    {MQTT_PROP_WILDCARD_SUBSCRIPTION_AVAILABLE, MQTT_PROP_TYPE_BYTE},\n    {MQTT_PROP_SUBSCRIPTION_IDENTIFIER_AVAILABLE, MQTT_PROP_TYPE_BYTE},\n    {MQTT_PROP_SHARED_SUBSCRIPTION_AVAILABLE, MQTT_PROP_TYPE_BYTE}};\n\nvoid mg_mqtt_send_header(struct mg_connection *c, uint8_t cmd, uint8_t flags,\n                         uint32_t len) {\n  uint8_t buf[1 + sizeof(len)], *vlen = &buf[1];\n  buf[0] = (uint8_t) ((cmd << 4) | flags);\n  do {\n    *vlen = len % 0x80;\n    len /= 0x80;\n    if (len > 0) *vlen |= 0x80;\n    vlen++;\n  } while (len > 0 && vlen < &buf[sizeof(buf)]);\n  mg_send(c, buf, (size_t) (vlen - buf));\n}\n\nstatic void mg_send_u16(struct mg_connection *c, uint16_t value) {\n  mg_send(c, &value, sizeof(value));\n}\n\nstatic void mg_send_u32(struct mg_connection *c, uint32_t value) {\n  mg_send(c, &value, sizeof(value));\n}\n\nstatic uint8_t compute_variable_length_size(size_t length) {\n  uint8_t bytes_needed = 0;\n  do {\n    bytes_needed++;\n    length /= 0x80;\n  } while (length > 0);\n  return bytes_needed;\n}\n\nstatic int encode_variable_length(uint8_t *buf, size_t value) {\n  int len = 0;\n\n  do {\n    uint8_t byte = (uint8_t) (value % 128);\n    value /= 128;\n    if (value > 0) byte |= 0x80;\n    buf[len++] = byte;\n  } while (value > 0);\n\n  return len;\n}\n\nstatic uint32_t decode_variable_length(const char *buf,\n                                       uint32_t *bytes_consumed) {\n  uint32_t value = 0, multiplier = 1, offset;\n\n  for (offset = 0; offset < 4; offset++) {\n    uint8_t encoded_byte = ((uint8_t *) buf)[offset];\n    value += (encoded_byte & 0x7F) * multiplier;\n    multiplier *= 128;\n\n    if (!(encoded_byte & 0x80)) break;\n  }\n\n  if (bytes_consumed != NULL) *bytes_consumed = offset + 1;\n\n  return value;\n}\n\nstatic int mqtt_prop_type_by_id(uint8_t prop_id) {\n  size_t i, num_properties = sizeof(s_prop_map) / sizeof(s_prop_map[0]);\n  for (i = 0; i < num_properties; ++i) {\n    if (s_prop_map[i].id == prop_id) return s_prop_map[i].type;\n  }\n  return -1;  // Property ID not found\n}\n\n// Returns the size of the properties section, without the\n// size of the content's length\nstatic size_t get_properties_length(struct mg_mqtt_prop *props, size_t count) {\n  size_t i, size = 0;\n  for (i = 0; i < count; i++) {\n    size++;  // identifier\n    switch (mqtt_prop_type_by_id(props[i].id)) {\n      case MQTT_PROP_TYPE_STRING_PAIR:\n        size += (uint32_t) (props[i].val.len + props[i].key.len +\n                            2 * sizeof(uint16_t));\n        break;\n      case MQTT_PROP_TYPE_STRING:\n        size += (uint32_t) (props[i].val.len + sizeof(uint16_t));\n        break;\n      case MQTT_PROP_TYPE_BINARY_DATA:\n        size += (uint32_t) (props[i].val.len + sizeof(uint16_t));\n        break;\n      case MQTT_PROP_TYPE_VARIABLE_INT:\n        size += compute_variable_length_size((uint32_t) props[i].iv);\n        break;\n      case MQTT_PROP_TYPE_INT: size += (uint32_t) sizeof(uint32_t); break;\n      case MQTT_PROP_TYPE_SHORT: size += (uint32_t) sizeof(uint16_t); break;\n      default: return size;  // cannot parse further down\n    }\n  }\n\n  return size;\n}\n\n// returns the entire size of the properties section, including the\n// size of the variable length of the content\nstatic size_t get_props_size(struct mg_mqtt_prop *props, size_t count) {\n  size_t size = get_properties_length(props, count);\n  size += compute_variable_length_size(size);\n  return size;\n}\n\nstatic void mg_send_mqtt_properties(struct mg_connection *c,\n                                    struct mg_mqtt_prop *props, size_t nprops) {\n  size_t total_size = get_properties_length(props, nprops);\n  uint8_t buf_v[4] = {0, 0, 0, 0};\n  uint8_t buf[4] = {0, 0, 0, 0};\n  int i, len = encode_variable_length(buf, total_size);\n\n  mg_send(c, buf, (size_t) len);\n  for (i = 0; i < (int) nprops; i++) {\n    mg_send(c, &props[i].id, sizeof(props[i].id));\n    switch (mqtt_prop_type_by_id(props[i].id)) {\n      case MQTT_PROP_TYPE_STRING_PAIR:\n        mg_send_u16(c, mg_htons((uint16_t) props[i].key.len));\n        mg_send(c, props[i].key.ptr, props[i].key.len);\n        mg_send_u16(c, mg_htons((uint16_t) props[i].val.len));\n        mg_send(c, props[i].val.ptr, props[i].val.len);\n        break;\n      case MQTT_PROP_TYPE_BYTE:\n        mg_send(c, &props[i].iv, sizeof(uint8_t));\n        break;\n      case MQTT_PROP_TYPE_SHORT:\n        mg_send_u16(c, mg_htons((uint16_t) props[i].iv));\n        break;\n      case MQTT_PROP_TYPE_INT:\n        mg_send_u32(c, mg_htonl((uint32_t) props[i].iv));\n        break;\n      case MQTT_PROP_TYPE_STRING:\n        mg_send_u16(c, mg_htons((uint16_t) props[i].val.len));\n        mg_send(c, props[i].val.ptr, props[i].val.len);\n        break;\n      case MQTT_PROP_TYPE_BINARY_DATA:\n        mg_send_u16(c, mg_htons((uint16_t) props[i].val.len));\n        mg_send(c, props[i].val.ptr, props[i].val.len);\n        break;\n      case MQTT_PROP_TYPE_VARIABLE_INT:\n        len = encode_variable_length(buf_v, props[i].iv);\n        mg_send(c, buf_v, (size_t) len);\n        break;\n    }\n  }\n}\n\nsize_t mg_mqtt_next_prop(struct mg_mqtt_message *msg, struct mg_mqtt_prop *prop,\n                         size_t ofs) {\n  uint8_t *i = (uint8_t *) msg->dgram.ptr + msg->props_start + ofs;\n  size_t new_pos = ofs;\n  uint32_t bytes_consumed;\n  prop->id = i[0];\n\n  if (ofs >= msg->dgram.len || ofs >= msg->props_start + msg->props_size)\n    return 0;\n  i++, new_pos++;\n\n  switch (mqtt_prop_type_by_id(prop->id)) {\n    case MQTT_PROP_TYPE_STRING_PAIR:\n      prop->key.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);\n      prop->key.ptr = (char *) i + 2;\n      i += 2 + prop->key.len;\n      prop->val.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);\n      prop->val.ptr = (char *) i + 2;\n      new_pos += 2 * sizeof(uint16_t) + prop->val.len + prop->key.len;\n      break;\n    case MQTT_PROP_TYPE_BYTE:\n      prop->iv = (uint8_t) i[0];\n      new_pos++;\n      break;\n    case MQTT_PROP_TYPE_SHORT:\n      prop->iv = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);\n      new_pos += sizeof(uint16_t);\n      break;\n    case MQTT_PROP_TYPE_INT:\n      prop->iv = ((uint32_t) i[0] << 24) | ((uint32_t) i[1] << 16) |\n                 ((uint32_t) i[2] << 8) | i[3];\n      new_pos += sizeof(uint32_t);\n      break;\n    case MQTT_PROP_TYPE_STRING:\n      prop->val.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);\n      prop->val.ptr = (char *) i + 2;\n      new_pos += 2 + prop->val.len;\n      break;\n    case MQTT_PROP_TYPE_BINARY_DATA:\n      prop->val.len = (uint16_t) ((((uint16_t) i[0]) << 8) | i[1]);\n      prop->val.ptr = (char *) i + 2;\n      new_pos += 2 + prop->val.len;\n      break;\n    case MQTT_PROP_TYPE_VARIABLE_INT:\n      prop->iv = decode_variable_length((char *) i, &bytes_consumed);\n      new_pos += bytes_consumed;\n      break;\n    default: new_pos = 0;\n  }\n\n  return new_pos;\n}\n\nvoid mg_mqtt_login(struct mg_connection *c, const struct mg_mqtt_opts *opts) {\n  char rnd[10], client_id[21];\n  struct mg_str cid = opts->client_id;\n  size_t total_len = 7 + 1 + 2 + 2;\n  uint8_t hdr[8] = {0, 4, 'M', 'Q', 'T', 'T', opts->version, 0};\n\n  if (cid.len == 0) {\n    mg_random(rnd, sizeof(rnd));\n    mg_hex(rnd, sizeof(rnd), client_id);\n    client_id[sizeof(client_id) - 1] = '\\0';\n    cid = mg_str(client_id);\n  }\n\n  if (hdr[6] == 0) hdr[6] = 4;  // If version is not set, use 4 (3.1.1)\n  c->is_mqtt5 = hdr[6] == 5;    // Set version 5 flag\n  hdr[7] = (uint8_t) ((opts->qos & 3) << 3);  // Connection flags\n  if (opts->user.len > 0) {\n    total_len += 2 + (uint32_t) opts->user.len;\n    hdr[7] |= MQTT_HAS_USER_NAME;\n  }\n  if (opts->pass.len > 0) {\n    total_len += 2 + (uint32_t) opts->pass.len;\n    hdr[7] |= MQTT_HAS_PASSWORD;\n  }\n  if (opts->topic.len > 0 && opts->message.len > 0) {\n    total_len += 4 + (uint32_t) opts->topic.len + (uint32_t) opts->message.len;\n    hdr[7] |= MQTT_HAS_WILL;\n  }\n  if (opts->clean || cid.len == 0) hdr[7] |= MQTT_CLEAN_SESSION;\n  if (opts->retain) hdr[7] |= MQTT_WILL_RETAIN;\n  total_len += (uint32_t) cid.len;\n  if (c->is_mqtt5) {\n    total_len += get_props_size(opts->props, opts->num_props);\n    if (hdr[7] & MQTT_HAS_WILL)\n      total_len += get_props_size(opts->will_props, opts->num_will_props);\n  }\n\n  mg_mqtt_send_header(c, MQTT_CMD_CONNECT, 0, (uint32_t) total_len);\n  mg_send(c, hdr, sizeof(hdr));\n  // keepalive == 0 means \"do not disconnect us!\"\n  mg_send_u16(c, mg_htons((uint16_t) opts->keepalive));\n\n  if (c->is_mqtt5) mg_send_mqtt_properties(c, opts->props, opts->num_props);\n\n  mg_send_u16(c, mg_htons((uint16_t) cid.len));\n  mg_send(c, cid.ptr, cid.len);\n\n  if (hdr[7] & MQTT_HAS_WILL) {\n    if (c->is_mqtt5)\n      mg_send_mqtt_properties(c, opts->will_props, opts->num_will_props);\n\n    mg_send_u16(c, mg_htons((uint16_t) opts->topic.len));\n    mg_send(c, opts->topic.ptr, opts->topic.len);\n    mg_send_u16(c, mg_htons((uint16_t) opts->message.len));\n    mg_send(c, opts->message.ptr, opts->message.len);\n  }\n  if (opts->user.len > 0) {\n    mg_send_u16(c, mg_htons((uint16_t) opts->user.len));\n    mg_send(c, opts->user.ptr, opts->user.len);\n  }\n  if (opts->pass.len > 0) {\n    mg_send_u16(c, mg_htons((uint16_t) opts->pass.len));\n    mg_send(c, opts->pass.ptr, opts->pass.len);\n  }\n}\n\nvoid mg_mqtt_pub(struct mg_connection *c, const struct mg_mqtt_opts *opts) {\n  uint8_t flags = (uint8_t) (((opts->qos & 3) << 1) | (opts->retain ? 1 : 0));\n  size_t len = 2 + opts->topic.len + opts->message.len;\n  MG_DEBUG((\"%lu [%.*s] -> [%.*s]\", c->id, (int) opts->topic.len,\n            (char *) opts->topic.ptr, (int) opts->message.len,\n            (char *) opts->message.ptr));\n  if (opts->qos > 0) len += 2;\n  if (c->is_mqtt5) len += get_props_size(opts->props, opts->num_props);\n\n  mg_mqtt_send_header(c, MQTT_CMD_PUBLISH, flags, (uint32_t) len);\n  mg_send_u16(c, mg_htons((uint16_t) opts->topic.len));\n  mg_send(c, opts->topic.ptr, opts->topic.len);\n  if (opts->qos > 0) {\n    if (++c->mgr->mqtt_id == 0) ++c->mgr->mqtt_id;\n    mg_send_u16(c, mg_htons(c->mgr->mqtt_id));\n  }\n\n  if (c->is_mqtt5) mg_send_mqtt_properties(c, opts->props, opts->num_props);\n\n  mg_send(c, opts->message.ptr, opts->message.len);\n}\n\nvoid mg_mqtt_sub(struct mg_connection *c, const struct mg_mqtt_opts *opts) {\n  uint8_t qos_ = opts->qos & 3;\n  size_t plen = c->is_mqtt5 ? get_props_size(opts->props, opts->num_props) : 0;\n  size_t len = 2 + opts->topic.len + 2 + 1 + plen;\n\n  mg_mqtt_send_header(c, MQTT_CMD_SUBSCRIBE, 2, (uint32_t) len);\n  if (++c->mgr->mqtt_id == 0) ++c->mgr->mqtt_id;\n  mg_send_u16(c, mg_htons(c->mgr->mqtt_id));\n  if (c->is_mqtt5) mg_send_mqtt_properties(c, opts->props, opts->num_props);\n\n  mg_send_u16(c, mg_htons((uint16_t) opts->topic.len));\n  mg_send(c, opts->topic.ptr, opts->topic.len);\n  mg_send(c, &qos_, sizeof(qos_));\n}\n\nint mg_mqtt_parse(const uint8_t *buf, size_t len, uint8_t version,\n                  struct mg_mqtt_message *m) {\n  uint8_t lc = 0, *p, *end;\n  uint32_t n = 0, len_len = 0;\n\n  memset(m, 0, sizeof(*m));\n  m->dgram.ptr = (char *) buf;\n  if (len < 2) return MQTT_INCOMPLETE;\n  m->cmd = (uint8_t) (buf[0] >> 4);\n  m->qos = (buf[0] >> 1) & 3;\n\n  n = len_len = 0;\n  p = (uint8_t *) buf + 1;\n  while ((size_t) (p - buf) < len) {\n    lc = *((uint8_t *) p++);\n    n += (uint32_t) ((lc & 0x7f) << 7 * len_len);\n    len_len++;\n    if (!(lc & 0x80)) break;\n    if (len_len >= 4) return MQTT_MALFORMED;\n  }\n  end = p + n;\n  if ((lc & 0x80) || (end > buf + len)) return MQTT_INCOMPLETE;\n  m->dgram.len = (size_t) (end - buf);\n\n  switch (m->cmd) {\n    case MQTT_CMD_CONNACK:\n      if (end - p < 2) return MQTT_MALFORMED;\n      m->ack = p[1];\n      break;\n    case MQTT_CMD_PUBACK:\n    case MQTT_CMD_PUBREC:\n    case MQTT_CMD_PUBREL:\n    case MQTT_CMD_PUBCOMP:\n    case MQTT_CMD_SUBSCRIBE:\n    case MQTT_CMD_SUBACK:\n    case MQTT_CMD_UNSUBSCRIBE:\n    case MQTT_CMD_UNSUBACK:\n      if (p + 2 > end) return MQTT_MALFORMED;\n      m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);\n      p += 2;\n      break;\n    case MQTT_CMD_PUBLISH: {\n      if (p + 2 > end) return MQTT_MALFORMED;\n      m->topic.len = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);\n      m->topic.ptr = (char *) p + 2;\n      p += 2 + m->topic.len;\n      if (p > end) return MQTT_MALFORMED;\n      if (m->qos > 0) {\n        if (p + 2 > end) return MQTT_MALFORMED;\n        m->id = (uint16_t) ((((uint16_t) p[0]) << 8) | p[1]);\n        p += 2;\n      }\n      if (p > end) return MQTT_MALFORMED;\n      if (version == 5 && p + 2 < end) {\n        m->props_size = decode_variable_length((char *) p, &len_len);\n        m->props_start = (size_t) (p + len_len - buf);\n        p += len_len + m->props_size;\n      }\n      if (p > end) return MQTT_MALFORMED;\n      m->data.ptr = (char *) p;\n      m->data.len = (size_t) (end - p);\n      break;\n    }\n    default: break;\n  }\n  return MQTT_OK;\n}\n\nstatic void mqtt_cb(struct mg_connection *c, int ev, void *ev_data,\n                    void *fn_data) {\n  if (ev == MG_EV_READ) {\n    for (;;) {\n      uint8_t version = c->is_mqtt5 ? 5 : 4;\n      struct mg_mqtt_message mm;\n      int rc = mg_mqtt_parse(c->recv.buf, c->recv.len, version, &mm);\n      if (rc == MQTT_MALFORMED) {\n        MG_ERROR((\"%lu MQTT malformed message\", c->id));\n        c->is_closing = 1;\n        break;\n      } else if (rc == MQTT_OK) {\n        MG_VERBOSE((\"%lu MQTT CMD %d len %d [%.*s]\", c->id, mm.cmd,\n                    (int) mm.dgram.len, (int) mm.data.len, mm.data.ptr));\n        switch (mm.cmd) {\n          case MQTT_CMD_CONNACK:\n            mg_call(c, MG_EV_MQTT_OPEN, &mm.ack);\n            if (mm.ack == 0) {\n              MG_DEBUG((\"%lu Connected\", c->id));\n            } else {\n              MG_ERROR((\"%lu MQTT auth failed, code %d\", c->id, mm.ack));\n              c->is_closing = 1;\n            }\n            break;\n          case MQTT_CMD_PUBLISH: {\n            MG_DEBUG((\"%lu [%.*s] -> [%.*s]\", c->id, (int) mm.topic.len,\n                      mm.topic.ptr, (int) mm.data.len, mm.data.ptr));\n            if (mm.qos > 0) {\n              uint16_t id = mg_htons(mm.id);\n              uint32_t remaining_len = sizeof(id);\n              if (c->is_mqtt5) remaining_len += 1;\n\n              mg_mqtt_send_header(c, MQTT_CMD_PUBACK, 0, remaining_len);\n              mg_send(c, &id, sizeof(id));\n\n              if (c->is_mqtt5) {\n                uint16_t zero = 0;\n                mg_send(c, &zero, sizeof(zero));\n              }\n            }\n            mg_call(c, MG_EV_MQTT_MSG, &mm);\n            break;\n          }\n        }\n        mg_call(c, MG_EV_MQTT_CMD, &mm);\n        mg_iobuf_del(&c->recv, 0, mm.dgram.len);\n      } else {\n        break;\n      }\n    }\n  }\n  (void) ev_data;\n  (void) fn_data;\n}\n\nvoid mg_mqtt_ping(struct mg_connection *nc) {\n  mg_mqtt_send_header(nc, MQTT_CMD_PINGREQ, 0, 0);\n}\n\nvoid mg_mqtt_pong(struct mg_connection *nc) {\n  mg_mqtt_send_header(nc, MQTT_CMD_PINGRESP, 0, 0);\n}\n\nvoid mg_mqtt_disconnect(struct mg_connection *c,\n                        const struct mg_mqtt_opts *opts) {\n  size_t len = 0;\n  if (c->is_mqtt5) len = 1 + get_props_size(opts->props, opts->num_props);\n  mg_mqtt_send_header(c, MQTT_CMD_DISCONNECT, 0, (uint32_t) len);\n\n  if (c->is_mqtt5) {\n    uint8_t zero = 0;\n    mg_send(c, &zero, sizeof(zero));  // reason code\n    mg_send_mqtt_properties(c, opts->props, opts->num_props);\n  }\n}\n\nstruct mg_connection *mg_mqtt_connect(struct mg_mgr *mgr, const char *url,\n                                      const struct mg_mqtt_opts *opts,\n                                      mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);\n  if (c != NULL) {\n    struct mg_mqtt_opts empty;\n    memset(&empty, 0, sizeof(empty));\n    mg_mqtt_login(c, opts == NULL ? &empty : opts);\n    c->pfn = mqtt_cb;\n  }\n  return c;\n}\n\nstruct mg_connection *mg_mqtt_listen(struct mg_mgr *mgr, const char *url,\n                                     mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = mqtt_cb, c->pfn_data = mgr;\n  return c;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/net.c\"\n#endif\n\n\n\n\n\n\n\n\nsize_t mg_vprintf(struct mg_connection *c, const char *fmt, va_list *ap) {\n  size_t old = c->send.len;\n  mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, ap);\n  return c->send.len - old;\n}\n\nsize_t mg_printf(struct mg_connection *c, const char *fmt, ...) {\n  size_t len = 0;\n  va_list ap;\n  va_start(ap, fmt);\n  len = mg_vprintf(c, fmt, &ap);\n  va_end(ap);\n  return len;\n}\n\nstatic bool mg_atonl(struct mg_str str, struct mg_addr *addr) {\n  if (mg_vcasecmp(&str, \"localhost\") != 0) return false;\n  addr->ip = mg_htonl(0x7f000001);\n  addr->is_ip6 = false;\n  return true;\n}\n\nstatic bool mg_atone(struct mg_str str, struct mg_addr *addr) {\n  if (str.len > 0) return false;\n  addr->ip = 0;\n  addr->is_ip6 = false;\n  return true;\n}\n\nstatic bool mg_aton4(struct mg_str str, struct mg_addr *addr) {\n  uint8_t data[4] = {0, 0, 0, 0};\n  size_t i, num_dots = 0;\n  for (i = 0; i < str.len; i++) {\n    if (str.ptr[i] >= '0' && str.ptr[i] <= '9') {\n      int octet = data[num_dots] * 10 + (str.ptr[i] - '0');\n      if (octet > 255) return false;\n      data[num_dots] = (uint8_t) octet;\n    } else if (str.ptr[i] == '.') {\n      if (num_dots >= 3 || i == 0 || str.ptr[i - 1] == '.') return false;\n      num_dots++;\n    } else {\n      return false;\n    }\n  }\n  if (num_dots != 3 || str.ptr[i - 1] == '.') return false;\n  memcpy(&addr->ip, data, sizeof(data));\n  addr->is_ip6 = false;\n  return true;\n}\n\nstatic bool mg_v4mapped(struct mg_str str, struct mg_addr *addr) {\n  int i;\n  if (str.len < 14) return false;\n  if (str.ptr[0] != ':' || str.ptr[1] != ':' || str.ptr[6] != ':') return false;\n  for (i = 2; i < 6; i++) {\n    if (str.ptr[i] != 'f' && str.ptr[i] != 'F') return false;\n  }\n  if (!mg_aton4(mg_str_n(&str.ptr[7], str.len - 7), addr)) return false;\n  memset(addr->ip6, 0, sizeof(addr->ip6));\n  addr->ip6[10] = addr->ip6[11] = 255;\n  memcpy(&addr->ip6[12], &addr->ip, 4);\n  addr->is_ip6 = true;\n  return true;\n}\n\nstatic bool mg_aton6(struct mg_str str, struct mg_addr *addr) {\n  size_t i, j = 0, n = 0, dc = 42;\n  if (str.len > 2 && str.ptr[0] == '[') str.ptr++, str.len -= 2;\n  if (mg_v4mapped(str, addr)) return true;\n  for (i = 0; i < str.len; i++) {\n    if ((str.ptr[i] >= '0' && str.ptr[i] <= '9') ||\n        (str.ptr[i] >= 'a' && str.ptr[i] <= 'f') ||\n        (str.ptr[i] >= 'A' && str.ptr[i] <= 'F')) {\n      unsigned long val;\n      if (i > j + 3) return false;\n      // MG_DEBUG((\"%zu %zu [%.*s]\", i, j, (int) (i - j + 1), &str.ptr[j]));\n      val = mg_unhexn(&str.ptr[j], i - j + 1);\n      addr->ip6[n] = (uint8_t) ((val >> 8) & 255);\n      addr->ip6[n + 1] = (uint8_t) (val & 255);\n    } else if (str.ptr[i] == ':') {\n      j = i + 1;\n      if (i > 0 && str.ptr[i - 1] == ':') {\n        dc = n;  // Double colon\n        if (i > 1 && str.ptr[i - 2] == ':') return false;\n      } else if (i > 0) {\n        n += 2;\n      }\n      if (n > 14) return false;\n      addr->ip6[n] = addr->ip6[n + 1] = 0;  // For trailing ::\n    } else {\n      return false;\n    }\n  }\n  if (n < 14 && dc == 42) return false;\n  if (n < 14) {\n    memmove(&addr->ip6[dc + (14 - n)], &addr->ip6[dc], n - dc + 2);\n    memset(&addr->ip6[dc], 0, 14 - n);\n  }\n  addr->is_ip6 = true;\n  return true;\n}\n\nbool mg_aton(struct mg_str str, struct mg_addr *addr) {\n  // MG_INFO((\"[%.*s]\", (int) str.len, str.ptr));\n  return mg_atone(str, addr) || mg_atonl(str, addr) || mg_aton4(str, addr) ||\n         mg_aton6(str, addr);\n}\n\nstruct mg_connection *mg_alloc_conn(struct mg_mgr *mgr) {\n  struct mg_connection *c =\n      (struct mg_connection *) calloc(1, sizeof(*c) + mgr->extraconnsize);\n  if (c != NULL) {\n    c->mgr = mgr;\n    c->send.align = c->recv.align = MG_IO_SIZE;\n    c->id = ++mgr->nextid;\n  }\n  return c;\n}\n\nvoid mg_close_conn(struct mg_connection *c) {\n  mg_resolve_cancel(c);  // Close any pending DNS query\n  LIST_DELETE(struct mg_connection, &c->mgr->conns, c);\n  if (c == c->mgr->dns4.c) c->mgr->dns4.c = NULL;\n  if (c == c->mgr->dns6.c) c->mgr->dns6.c = NULL;\n  // Order of operations is important. `MG_EV_CLOSE` event must be fired\n  // before we deallocate received data, see #1331\n  mg_call(c, MG_EV_CLOSE, NULL);\n  MG_DEBUG((\"%lu %p closed\", c->id, c->fd));\n\n  mg_tls_free(c);\n  mg_iobuf_free(&c->recv);\n  mg_iobuf_free(&c->send);\n  memset(c, 0, sizeof(*c));\n  free(c);\n}\n\nstruct mg_connection *mg_connect(struct mg_mgr *mgr, const char *url,\n                                 mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = NULL;\n  if (url == NULL || url[0] == '\\0') {\n    MG_ERROR((\"null url\"));\n  } else if ((c = mg_alloc_conn(mgr)) == NULL) {\n    MG_ERROR((\"OOM\"));\n  } else {\n    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);\n    c->is_udp = (strncmp(url, \"udp:\", 4) == 0);\n    c->fd = (void *) (size_t) MG_INVALID_SOCKET;\n    c->fn = fn;\n    c->is_client = true;\n    c->fn_data = fn_data;\n    MG_DEBUG((\"%lu %p %s\", c->id, c->fd, url));\n    mg_call(c, MG_EV_OPEN, NULL);\n    mg_resolve(c, url);\n  }\n  return c;\n}\n\nstruct mg_connection *mg_listen(struct mg_mgr *mgr, const char *url,\n                                mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = NULL;\n  if ((c = mg_alloc_conn(mgr)) == NULL) {\n    MG_ERROR((\"OOM %s\", url));\n  } else if (!mg_open_listener(c, url)) {\n    MG_ERROR((\"Failed: %s, errno %d\", url, errno));\n    free(c);\n    c = NULL;\n  } else {\n    c->is_listening = 1;\n    c->is_udp = strncmp(url, \"udp:\", 4) == 0;\n    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);\n    c->fn = fn;\n    c->fn_data = fn_data;\n    mg_call(c, MG_EV_OPEN, NULL);\n    MG_DEBUG((\"%lu %p %s\", c->id, c->fd, url));\n  }\n  return c;\n}\n\nstruct mg_connection *mg_wrapfd(struct mg_mgr *mgr, int fd,\n                                mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_alloc_conn(mgr);\n  if (c != NULL) {\n    c->fd = (void *) (size_t) fd;\n    c->fn = fn;\n    c->fn_data = fn_data;\n    MG_EPOLL_ADD(c);\n    mg_call(c, MG_EV_OPEN, NULL);\n    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);\n  }\n  return c;\n}\n\nstruct mg_timer *mg_timer_add(struct mg_mgr *mgr, uint64_t milliseconds,\n                              unsigned flags, void (*fn)(void *), void *arg) {\n  struct mg_timer *t = (struct mg_timer *) calloc(1, sizeof(*t));\n  if (t != NULL) {\n    mg_timer_init(&mgr->timers, t, milliseconds, flags, fn, arg);\n    t->id = mgr->timerid++;\n  }\n  return t;\n}\n\nvoid mg_mgr_free(struct mg_mgr *mgr) {\n  struct mg_connection *c;\n  struct mg_timer *tmp, *t = mgr->timers;\n  while (t != NULL) tmp = t->next, free(t), t = tmp;\n  mgr->timers = NULL;  // Important. Next call to poll won't touch timers\n  for (c = mgr->conns; c != NULL; c = c->next) c->is_closing = 1;\n  mg_mgr_poll(mgr, 0);\n#if MG_ENABLE_FREERTOS_TCP\n  FreeRTOS_DeleteSocketSet(mgr->ss);\n#endif\n  MG_DEBUG((\"All connections closed\"));\n#if MG_ENABLE_EPOLL\n  if (mgr->epoll_fd >= 0) close(mgr->epoll_fd), mgr->epoll_fd = -1;\n#endif\n}\n\nvoid mg_mgr_init(struct mg_mgr *mgr) {\n  memset(mgr, 0, sizeof(*mgr));\n#if MG_ENABLE_EPOLL\n  if ((mgr->epoll_fd = epoll_create1(0)) < 0) MG_ERROR((\"epoll: %d\", errno));\n#else\n  mgr->epoll_fd = -1;\n#endif\n#if MG_ARCH == MG_ARCH_WIN32 && MG_ENABLE_WINSOCK\n  // clang-format off\n  { WSADATA data; WSAStartup(MAKEWORD(2, 2), &data); }\n  // clang-format on\n#elif MG_ENABLE_FREERTOS_TCP\n  mgr->ss = FreeRTOS_CreateSocketSet();\n#elif defined(__unix) || defined(__unix__) || defined(__APPLE__)\n  // Ignore SIGPIPE signal, so if client cancels the request, it\n  // won't kill the whole process.\n  signal(SIGPIPE, SIG_IGN);\n#endif\n  mgr->dnstimeout = 3000;\n  mgr->dns4.url = \"udp://8.8.8.8:53\";\n  mgr->dns6.url = \"udp://[2001:4860:4860::8888]:53\";\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/printf.c\"\n#endif\n\n\n\n\nsize_t mg_queue_vprintf(struct mg_queue *q, const char *fmt, va_list *ap) {\n  size_t len = mg_snprintf(NULL, 0, fmt, ap);\n  char *buf;\n  if (len == 0 || mg_queue_book(q, &buf, len + 1) < len + 1) {\n    len = 0;  // Nah. Not enough space\n  } else {\n    len = mg_vsnprintf((char *) buf, len + 1, fmt, ap);\n    mg_queue_add(q, len);\n  }\n  return len;\n}\n\nsize_t mg_queue_printf(struct mg_queue *q, const char *fmt, ...) {\n  va_list ap;\n  size_t len;\n  va_start(ap, fmt);\n  len = mg_queue_vprintf(q, fmt, &ap);\n  va_end(ap);\n  return len;\n}\n\nstatic void mg_pfn_iobuf_private(char ch, void *param, bool expand) {\n  struct mg_iobuf *io = (struct mg_iobuf *) param;\n  if (expand && io->len + 2 > io->size) mg_iobuf_resize(io, io->len + 2);\n  if (io->len + 2 <= io->size) {\n    io->buf[io->len++] = (uint8_t) ch;\n    io->buf[io->len] = 0;\n  } else if (io->len < io->size) {\n    io->buf[io->len++] = 0;  // Guarantee to 0-terminate\n  }\n}\n\nstatic void mg_putchar_iobuf_static(char ch, void *param) {\n  mg_pfn_iobuf_private(ch, param, false);\n}\n\nvoid mg_pfn_iobuf(char ch, void *param) {\n  mg_pfn_iobuf_private(ch, param, true);\n}\n\nsize_t mg_vsnprintf(char *buf, size_t len, const char *fmt, va_list *ap) {\n  struct mg_iobuf io = {(uint8_t *) buf, len, 0, 0};\n  size_t n = mg_vxprintf(mg_putchar_iobuf_static, &io, fmt, ap);\n  if (n < len) buf[n] = '\\0';\n  return n;\n}\n\nsize_t mg_snprintf(char *buf, size_t len, const char *fmt, ...) {\n  va_list ap;\n  size_t n;\n  va_start(ap, fmt);\n  n = mg_vsnprintf(buf, len, fmt, &ap);\n  va_end(ap);\n  return n;\n}\n\nchar *mg_vmprintf(const char *fmt, va_list *ap) {\n  struct mg_iobuf io = {0, 0, 0, 256};\n  mg_vxprintf(mg_pfn_iobuf, &io, fmt, ap);\n  return (char *) io.buf;\n}\n\nchar *mg_mprintf(const char *fmt, ...) {\n  char *s;\n  va_list ap;\n  va_start(ap, fmt);\n  s = mg_vmprintf(fmt, &ap);\n  va_end(ap);\n  return s;\n}\n\nvoid mg_pfn_stdout(char c, void *param) {\n  putchar(c);\n  (void) param;\n}\n\nstatic size_t print_ip4(void (*out)(char, void *), void *arg, uint8_t *p) {\n  return mg_xprintf(out, arg, \"%d.%d.%d.%d\", p[0], p[1], p[2], p[3]);\n}\n\nstatic size_t print_ip6(void (*out)(char, void *), void *arg, uint16_t *p) {\n  return mg_xprintf(out, arg, \"[%x:%x:%x:%x:%x:%x:%x:%x]\", mg_ntohs(p[0]),\n                    mg_ntohs(p[1]), mg_ntohs(p[2]), mg_ntohs(p[3]),\n                    mg_ntohs(p[4]), mg_ntohs(p[5]), mg_ntohs(p[6]),\n                    mg_ntohs(p[7]));\n}\n\nsize_t mg_print_ip4(void (*out)(char, void *), void *arg, va_list *ap) {\n  uint8_t *p = va_arg(*ap, uint8_t *);\n  return print_ip4(out, arg, p);\n}\n\nsize_t mg_print_ip6(void (*out)(char, void *), void *arg, va_list *ap) {\n  uint16_t *p = va_arg(*ap, uint16_t *);\n  return print_ip6(out, arg, p);\n}\n\nsize_t mg_print_ip(void (*out)(char, void *), void *arg, va_list *ap) {\n  struct mg_addr *addr = va_arg(*ap, struct mg_addr *);\n  if (addr->is_ip6) return print_ip6(out, arg, (uint16_t *) addr->ip6);\n  return print_ip4(out, arg, (uint8_t *) &addr->ip);\n}\n\nsize_t mg_print_ip_port(void (*out)(char, void *), void *arg, va_list *ap) {\n  struct mg_addr *a = va_arg(*ap, struct mg_addr *);\n  return mg_xprintf(out, arg, \"%M:%hu\", mg_print_ip, a, mg_ntohs(a->port));\n}\n\nsize_t mg_print_mac(void (*out)(char, void *), void *arg, va_list *ap) {\n  uint8_t *p = va_arg(*ap, uint8_t *);\n  return mg_xprintf(out, arg, \"%02x:%02x:%02x:%02x:%02x:%02x\", p[0], p[1], p[2],\n                    p[3], p[4], p[5]);\n}\n\nstatic char mg_esc(int c, bool esc) {\n  const char *p, *esc1 = \"\\b\\f\\n\\r\\t\\\\\\\"\", *esc2 = \"bfnrt\\\\\\\"\";\n  for (p = esc ? esc1 : esc2; *p != '\\0'; p++) {\n    if (*p == c) return esc ? esc2[p - esc1] : esc1[p - esc2];\n  }\n  return 0;\n}\n\nstatic char mg_escape(int c) {\n  return mg_esc(c, true);\n}\n\nstatic size_t qcpy(void (*out)(char, void *), void *ptr, char *buf,\n                   size_t len) {\n  size_t i = 0, extra = 0;\n  for (i = 0; i < len && buf[i] != '\\0'; i++) {\n    char c = mg_escape(buf[i]);\n    if (c) {\n      out('\\\\', ptr), out(c, ptr), extra++;\n    } else {\n      out(buf[i], ptr);\n    }\n  }\n  return i + extra;\n}\n\nstatic size_t bcpy(void (*out)(char, void *), void *arg, uint8_t *buf,\n                   size_t len) {\n  size_t i, j, n = 0;\n  const char *t =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  for (i = 0; i < len; i += 3) {\n    uint8_t c1 = buf[i], c2 = i + 1 < len ? buf[i + 1] : 0,\n            c3 = i + 2 < len ? buf[i + 2] : 0;\n    char tmp[4] = {t[c1 >> 2], t[(c1 & 3) << 4 | (c2 >> 4)], '=', '='};\n    if (i + 1 < len) tmp[2] = t[(c2 & 15) << 2 | (c3 >> 6)];\n    if (i + 2 < len) tmp[3] = t[c3 & 63];\n    for (j = 0; j < sizeof(tmp) && tmp[j] != '\\0'; j++) out(tmp[j], arg);\n    n += j;\n  }\n  return n;\n}\n\nsize_t mg_print_hex(void (*out)(char, void *), void *arg, va_list *ap) {\n  size_t bl = (size_t) va_arg(*ap, int);\n  uint8_t *p = va_arg(*ap, uint8_t *);\n  const char *hex = \"0123456789abcdef\";\n  size_t j;\n  for (j = 0; j < bl; j++) {\n    out(hex[(p[j] >> 4) & 0x0F], arg);\n    out(hex[p[j] & 0x0F], arg);\n  }\n  return 2 * bl;\n}\nsize_t mg_print_base64(void (*out)(char, void *), void *arg, va_list *ap) {\n  size_t len = (size_t) va_arg(*ap, int);\n  uint8_t *buf = va_arg(*ap, uint8_t *);\n  return bcpy(out, arg, buf, len);\n}\n\nsize_t mg_print_esc(void (*out)(char, void *), void *arg, va_list *ap) {\n  size_t len = (size_t) va_arg(*ap, int);\n  char *p = va_arg(*ap, char *);\n  if (len == 0) len = p == NULL ? 0 : strlen(p);\n  return qcpy(out, arg, p, len);\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/queue.c\"\n#endif\n\n\n\n#if defined(__GNUC__) || defined(__clang__)\n#define MG_MEMORY_BARRIER() __sync_synchronize()\n#elif defined(_MSC_VER) && _MSC_VER >= 1700\n#define MG_MEMORY_BARRIER() MemoryBarrier()\n#elif !defined(MG_MEMORY_BARRIER)\n#define MG_MEMORY_BARRIER()\n#endif\n\n// Every message in a queue is prepended by a 32-bit message length (ML).\n// If ML is 0, then it is the end, and reader must wrap to the beginning.\n//\n//  Queue when q->tail <= q->head:\n//  |----- free -----| ML | message1 | ML | message2 |  ----- free ------|\n//  ^                ^                               ^                   ^\n// buf              tail                            head                len\n//\n//  Queue when q->tail > q->head:\n//  | ML | message2 |----- free ------| ML | message1 | 0 |---- free ----|\n//  ^               ^                 ^                                  ^\n// buf             head              tail                               len\n\nvoid mg_queue_init(struct mg_queue *q, char *buf, size_t size) {\n  q->size = size;\n  q->buf = buf;\n  q->head = q->tail = 0;\n}\n\nstatic size_t mg_queue_read_len(struct mg_queue *q) {\n  uint32_t n = 0;\n  MG_MEMORY_BARRIER();\n  memcpy(&n, q->buf + q->tail, sizeof(n));\n  assert(q->tail + n + sizeof(n) <= q->size);\n  return n;\n}\n\nstatic void mg_queue_write_len(struct mg_queue *q, size_t len) {\n  uint32_t n = (uint32_t) len;\n  memcpy(q->buf + q->head, &n, sizeof(n));\n  MG_MEMORY_BARRIER();\n}\n\nsize_t mg_queue_book(struct mg_queue *q, char **buf, size_t len) {\n  size_t space = 0, hs = sizeof(uint32_t) * 2;  // *2 is for the 0 marker\n  if (q->head >= q->tail && q->head + len + hs <= q->size) {\n    space = q->size - q->head - hs;  // There is enough space\n  } else if (q->head >= q->tail && q->tail > hs) {\n    mg_queue_write_len(q, 0);  // Not enough space ahead\n    q->head = 0;               // Wrap head to the beginning\n  }\n  if (q->head + hs + len < q->tail) space = q->tail - q->head - hs;\n  if (buf != NULL) *buf = q->buf + q->head + sizeof(uint32_t);\n  return space;\n}\n\nsize_t mg_queue_next(struct mg_queue *q, char **buf) {\n  size_t len = 0;\n  if (q->tail != q->head) {\n    len = mg_queue_read_len(q);\n    if (len == 0) {  // Zero (head wrapped) ?\n      q->tail = 0;   // Reset tail to the start\n      if (q->head > q->tail) len = mg_queue_read_len(q);  // Read again\n    }\n  }\n  if (buf != NULL) *buf = q->buf + q->tail + sizeof(uint32_t);\n  assert(q->tail + len <= q->size);\n  return len;\n}\n\nvoid mg_queue_add(struct mg_queue *q, size_t len) {\n  assert(len > 0);\n  mg_queue_write_len(q, len);\n  assert(q->head + sizeof(uint32_t) * 2 + len <= q->size);\n  q->head += len + sizeof(uint32_t);\n}\n\nvoid mg_queue_del(struct mg_queue *q, size_t len) {\n  q->tail += len + sizeof(uint32_t);\n  assert(q->tail + sizeof(uint32_t) <= q->size);\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/rpc.c\"\n#endif\n\n\n\nvoid mg_rpc_add(struct mg_rpc **head, struct mg_str method,\n                void (*fn)(struct mg_rpc_req *), void *fn_data) {\n  struct mg_rpc *rpc = (struct mg_rpc *) calloc(1, sizeof(*rpc));\n  if (rpc != NULL) {\n    rpc->method = mg_strdup(method), rpc->fn = fn, rpc->fn_data = fn_data;\n    rpc->next = *head, *head = rpc;\n  }\n}\n\nvoid mg_rpc_del(struct mg_rpc **head, void (*fn)(struct mg_rpc_req *)) {\n  struct mg_rpc *r;\n  while ((r = *head) != NULL) {\n    if (r->fn == fn || fn == NULL) {\n      *head = r->next;\n      free((void *) r->method.ptr);\n      free(r);\n    } else {\n      head = &(*head)->next;\n    }\n  }\n}\n\nstatic void mg_rpc_call(struct mg_rpc_req *r, struct mg_str method) {\n  struct mg_rpc *h = r->head == NULL ? NULL : *r->head;\n  while (h != NULL && !mg_match(method, h->method, NULL)) h = h->next;\n  if (h != NULL) {\n    r->rpc = h;\n    h->fn(r);\n  } else {\n    mg_rpc_err(r, -32601, \"\\\"%.*s not found\\\"\", (int) method.len, method.ptr);\n  }\n}\n\nvoid mg_rpc_process(struct mg_rpc_req *r) {\n  int len, off = mg_json_get(r->frame, \"$.method\", &len);\n  if (off > 0 && r->frame.ptr[off] == '\"') {\n    struct mg_str method = mg_str_n(&r->frame.ptr[off + 1], (size_t) len - 2);\n    mg_rpc_call(r, method);\n  } else if ((off = mg_json_get(r->frame, \"$.result\", &len)) > 0 ||\n             (off = mg_json_get(r->frame, \"$.error\", &len)) > 0) {\n    mg_rpc_call(r, mg_str(\"\"));  // JSON response! call \"\" method handler\n  } else {\n    mg_rpc_err(r, -32700, \"%m\", mg_print_esc, (int) r->frame.len,\n               r->frame.ptr);  // Invalid\n  }\n}\n\nvoid mg_rpc_vok(struct mg_rpc_req *r, const char *fmt, va_list *ap) {\n  int len, off = mg_json_get(r->frame, \"$.id\", &len);\n  if (off > 0) {\n    mg_xprintf(r->pfn, r->pfn_data, \"{%m:%.*s,%m:\", mg_print_esc, 0, \"id\", len,\n               &r->frame.ptr[off], mg_print_esc, 0, \"result\");\n    mg_vxprintf(r->pfn, r->pfn_data, fmt == NULL ? \"null\" : fmt, ap);\n    mg_xprintf(r->pfn, r->pfn_data, \"}\");\n  }\n}\n\nvoid mg_rpc_ok(struct mg_rpc_req *r, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  mg_rpc_vok(r, fmt, &ap);\n  va_end(ap);\n}\n\nvoid mg_rpc_verr(struct mg_rpc_req *r, int code, const char *fmt, va_list *ap) {\n  int len, off = mg_json_get(r->frame, \"$.id\", &len);\n  mg_xprintf(r->pfn, r->pfn_data, \"{\");\n  if (off > 0) {\n    mg_xprintf(r->pfn, r->pfn_data, \"%m:%.*s,\", mg_print_esc, 0, \"id\", len,\n               &r->frame.ptr[off]);\n  }\n  mg_xprintf(r->pfn, r->pfn_data, \"%m:{%m:%d,%m:\", mg_print_esc, 0, \"error\",\n             mg_print_esc, 0, \"code\", code, mg_print_esc, 0, \"message\");\n  mg_vxprintf(r->pfn, r->pfn_data, fmt == NULL ? \"null\" : fmt, ap);\n  mg_xprintf(r->pfn, r->pfn_data, \"}}\");\n}\n\nvoid mg_rpc_err(struct mg_rpc_req *r, int code, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  mg_rpc_verr(r, code, fmt, &ap);\n  va_end(ap);\n}\n\nstatic size_t print_methods(mg_pfn_t pfn, void *pfn_data, va_list *ap) {\n  struct mg_rpc *h, **head = (struct mg_rpc **) va_arg(*ap, void **);\n  size_t len = 0;\n  for (h = *head; h != NULL; h = h->next) {\n    if (h->method.len == 0) continue;  // Ignore response handler\n    len += mg_xprintf(pfn, pfn_data, \"%s%m\", h == *head ? \"\" : \",\",\n                      mg_print_esc, (int) h->method.len, h->method.ptr);\n  }\n  return len;\n}\n\nvoid mg_rpc_list(struct mg_rpc_req *r) {\n  mg_rpc_ok(r, \"[%M]\", print_methods, r->head);\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/sha1.c\"\n#endif\n/* Copyright(c) By Steve Reid <steve@edmweb.com> */\n/* 100% Public Domain */\n\n\n\nunion char64long16 {\n  unsigned char c[64];\n  uint32_t l[16];\n};\n\n#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))\n\nstatic uint32_t blk0(union char64long16 *block, int i) {\n  if (MG_BIG_ENDIAN) {\n  } else {\n    block->l[i] = (rol(block->l[i], 24) & 0xFF00FF00) |\n                  (rol(block->l[i], 8) & 0x00FF00FF);\n  }\n  return block->l[i];\n}\n\n/* Avoid redefine warning (ARM /usr/include/sys/ucontext.h define R0~R4) */\n#undef blk\n#undef R0\n#undef R1\n#undef R2\n#undef R3\n#undef R4\n\n#define blk(i)                                                               \\\n  (block->l[i & 15] = rol(block->l[(i + 13) & 15] ^ block->l[(i + 8) & 15] ^ \\\n                              block->l[(i + 2) & 15] ^ block->l[i & 15],     \\\n                          1))\n#define R0(v, w, x, y, z, i)                                          \\\n  z += ((w & (x ^ y)) ^ y) + blk0(block, i) + 0x5A827999 + rol(v, 5); \\\n  w = rol(w, 30);\n#define R1(v, w, x, y, z, i)                                  \\\n  z += ((w & (x ^ y)) ^ y) + blk(i) + 0x5A827999 + rol(v, 5); \\\n  w = rol(w, 30);\n#define R2(v, w, x, y, z, i)                          \\\n  z += (w ^ x ^ y) + blk(i) + 0x6ED9EBA1 + rol(v, 5); \\\n  w = rol(w, 30);\n#define R3(v, w, x, y, z, i)                                        \\\n  z += (((w | x) & y) | (w & x)) + blk(i) + 0x8F1BBCDC + rol(v, 5); \\\n  w = rol(w, 30);\n#define R4(v, w, x, y, z, i)                          \\\n  z += (w ^ x ^ y) + blk(i) + 0xCA62C1D6 + rol(v, 5); \\\n  w = rol(w, 30);\n\nstatic void mg_sha1_transform(uint32_t state[5],\n                              const unsigned char *buffer) {\n  uint32_t a, b, c, d, e;\n  union char64long16 block[1];\n\n  memcpy(block, buffer, 64);\n  a = state[0];\n  b = state[1];\n  c = state[2];\n  d = state[3];\n  e = state[4];\n  R0(a, b, c, d, e, 0);\n  R0(e, a, b, c, d, 1);\n  R0(d, e, a, b, c, 2);\n  R0(c, d, e, a, b, 3);\n  R0(b, c, d, e, a, 4);\n  R0(a, b, c, d, e, 5);\n  R0(e, a, b, c, d, 6);\n  R0(d, e, a, b, c, 7);\n  R0(c, d, e, a, b, 8);\n  R0(b, c, d, e, a, 9);\n  R0(a, b, c, d, e, 10);\n  R0(e, a, b, c, d, 11);\n  R0(d, e, a, b, c, 12);\n  R0(c, d, e, a, b, 13);\n  R0(b, c, d, e, a, 14);\n  R0(a, b, c, d, e, 15);\n  R1(e, a, b, c, d, 16);\n  R1(d, e, a, b, c, 17);\n  R1(c, d, e, a, b, 18);\n  R1(b, c, d, e, a, 19);\n  R2(a, b, c, d, e, 20);\n  R2(e, a, b, c, d, 21);\n  R2(d, e, a, b, c, 22);\n  R2(c, d, e, a, b, 23);\n  R2(b, c, d, e, a, 24);\n  R2(a, b, c, d, e, 25);\n  R2(e, a, b, c, d, 26);\n  R2(d, e, a, b, c, 27);\n  R2(c, d, e, a, b, 28);\n  R2(b, c, d, e, a, 29);\n  R2(a, b, c, d, e, 30);\n  R2(e, a, b, c, d, 31);\n  R2(d, e, a, b, c, 32);\n  R2(c, d, e, a, b, 33);\n  R2(b, c, d, e, a, 34);\n  R2(a, b, c, d, e, 35);\n  R2(e, a, b, c, d, 36);\n  R2(d, e, a, b, c, 37);\n  R2(c, d, e, a, b, 38);\n  R2(b, c, d, e, a, 39);\n  R3(a, b, c, d, e, 40);\n  R3(e, a, b, c, d, 41);\n  R3(d, e, a, b, c, 42);\n  R3(c, d, e, a, b, 43);\n  R3(b, c, d, e, a, 44);\n  R3(a, b, c, d, e, 45);\n  R3(e, a, b, c, d, 46);\n  R3(d, e, a, b, c, 47);\n  R3(c, d, e, a, b, 48);\n  R3(b, c, d, e, a, 49);\n  R3(a, b, c, d, e, 50);\n  R3(e, a, b, c, d, 51);\n  R3(d, e, a, b, c, 52);\n  R3(c, d, e, a, b, 53);\n  R3(b, c, d, e, a, 54);\n  R3(a, b, c, d, e, 55);\n  R3(e, a, b, c, d, 56);\n  R3(d, e, a, b, c, 57);\n  R3(c, d, e, a, b, 58);\n  R3(b, c, d, e, a, 59);\n  R4(a, b, c, d, e, 60);\n  R4(e, a, b, c, d, 61);\n  R4(d, e, a, b, c, 62);\n  R4(c, d, e, a, b, 63);\n  R4(b, c, d, e, a, 64);\n  R4(a, b, c, d, e, 65);\n  R4(e, a, b, c, d, 66);\n  R4(d, e, a, b, c, 67);\n  R4(c, d, e, a, b, 68);\n  R4(b, c, d, e, a, 69);\n  R4(a, b, c, d, e, 70);\n  R4(e, a, b, c, d, 71);\n  R4(d, e, a, b, c, 72);\n  R4(c, d, e, a, b, 73);\n  R4(b, c, d, e, a, 74);\n  R4(a, b, c, d, e, 75);\n  R4(e, a, b, c, d, 76);\n  R4(d, e, a, b, c, 77);\n  R4(c, d, e, a, b, 78);\n  R4(b, c, d, e, a, 79);\n  state[0] += a;\n  state[1] += b;\n  state[2] += c;\n  state[3] += d;\n  state[4] += e;\n  /* Erase working structures. The order of operations is important,\n   * used to ensure that compiler doesn't optimize those out. */\n  memset(block, 0, sizeof(block));\n  a = b = c = d = e = 0;\n  (void) a;\n  (void) b;\n  (void) c;\n  (void) d;\n  (void) e;\n}\n\nvoid mg_sha1_init(mg_sha1_ctx *context) {\n  context->state[0] = 0x67452301;\n  context->state[1] = 0xEFCDAB89;\n  context->state[2] = 0x98BADCFE;\n  context->state[3] = 0x10325476;\n  context->state[4] = 0xC3D2E1F0;\n  context->count[0] = context->count[1] = 0;\n}\n\nvoid mg_sha1_update(mg_sha1_ctx *context, const unsigned char *data,\n                    size_t len) {\n  size_t i, j;\n\n  j = context->count[0];\n  if ((context->count[0] += (uint32_t) len << 3) < j) context->count[1]++;\n  context->count[1] += (uint32_t) (len >> 29);\n  j = (j >> 3) & 63;\n  if ((j + len) > 63) {\n    memcpy(&context->buffer[j], data, (i = 64 - j));\n    mg_sha1_transform(context->state, context->buffer);\n    for (; i + 63 < len; i += 64) {\n      mg_sha1_transform(context->state, &data[i]);\n    }\n    j = 0;\n  } else\n    i = 0;\n  memcpy(&context->buffer[j], &data[i], len - i);\n}\n\nvoid mg_sha1_final(unsigned char digest[20], mg_sha1_ctx *context) {\n  unsigned i;\n  unsigned char finalcount[8], c;\n\n  for (i = 0; i < 8; i++) {\n    finalcount[i] = (unsigned char) ((context->count[(i >= 4 ? 0 : 1)] >>\n                                      ((3 - (i & 3)) * 8)) &\n                                     255);\n  }\n  c = 0200;\n  mg_sha1_update(context, &c, 1);\n  while ((context->count[0] & 504) != 448) {\n    c = 0000;\n    mg_sha1_update(context, &c, 1);\n  }\n  mg_sha1_update(context, finalcount, 8);\n  for (i = 0; i < 20; i++) {\n    digest[i] =\n        (unsigned char) ((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);\n  }\n  memset(context, '\\0', sizeof(*context));\n  memset(&finalcount, '\\0', sizeof(finalcount));\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/sntp.c\"\n#endif\n\n\n\n\n\n\n#define SNTP_TIME_OFFSET 2208988800U  // (1970 - 1900) in seconds\n#define SNTP_MAX_FRAC 4294967295.0    // 2 ** 32 - 1\n\nstatic int64_t gettimestamp(const uint32_t *data) {\n  uint32_t sec = mg_ntohl(data[0]), frac = mg_ntohl(data[1]);\n  if (sec) sec -= SNTP_TIME_OFFSET;\n  return ((int64_t) sec) * 1000 + (int64_t) (frac / SNTP_MAX_FRAC * 1000.0);\n}\n\nint64_t mg_sntp_parse(const unsigned char *buf, size_t len) {\n  int64_t res = -1;\n  int mode = len > 0 ? buf[0] & 7 : 0;\n  int version = len > 0 ? (buf[0] >> 3) & 7 : 0;\n  if (len < 48) {\n    MG_ERROR((\"%s\", \"corrupt packet\"));\n  } else if (mode != 4 && mode != 5) {\n    MG_ERROR((\"%s\", \"not a server reply\"));\n  } else if (buf[1] == 0) {\n    MG_ERROR((\"%s\", \"server sent a kiss of death\"));\n  } else if (version == 4 || version == 3) {\n    // int64_t ref = gettimestamp((uint32_t *) &buf[16]);\n    int64_t t0 = gettimestamp((uint32_t *) &buf[24]);\n    int64_t t1 = gettimestamp((uint32_t *) &buf[32]);\n    int64_t t2 = gettimestamp((uint32_t *) &buf[40]);\n    int64_t t3 = (int64_t) mg_millis();\n    int64_t delta = (t3 - t0) - (t2 - t1);\n    MG_VERBOSE((\"%lld %lld %lld %lld delta:%lld\", t0, t1, t2, t3, delta));\n    res = t2 + delta / 2;\n  } else {\n    MG_ERROR((\"unexpected version: %d\", version));\n  }\n  return res;\n}\n\nstatic void sntp_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n  if (ev == MG_EV_READ) {\n    int64_t milliseconds = mg_sntp_parse(c->recv.buf, c->recv.len);\n    if (milliseconds > 0) {\n      MG_INFO((\"%lu got time: %lld ms from epoch\", c->id, milliseconds));\n      mg_call(c, MG_EV_SNTP_TIME, (uint64_t *) &milliseconds);\n      MG_VERBOSE((\"%u.%u\", (unsigned) (milliseconds / 1000),\n                  (unsigned) (milliseconds % 1000)));\n    }\n    mg_iobuf_del(&c->recv, 0, c->recv.len);  // Free receive buffer\n  } else if (ev == MG_EV_CONNECT) {\n    mg_sntp_request(c);\n  } else if (ev == MG_EV_CLOSE) {\n  }\n  (void) fnd;\n  (void) evd;\n}\n\nvoid mg_sntp_request(struct mg_connection *c) {\n  if (c->is_resolving) {\n    MG_ERROR((\"%lu wait until resolved\", c->id));\n  } else {\n    int64_t now = (int64_t) mg_millis();  // Use int64_t, for vc98\n    uint8_t buf[48] = {0};\n    uint32_t *t = (uint32_t *) &buf[40];\n    double frac = ((double) (now % 1000)) / 1000.0 * SNTP_MAX_FRAC;\n    buf[0] = (0 << 6) | (4 << 3) | 3;\n    t[0] = mg_htonl((uint32_t) (now / 1000) + SNTP_TIME_OFFSET);\n    t[1] = mg_htonl((uint32_t) frac);\n    mg_send(c, buf, sizeof(buf));\n  }\n}\n\nstruct mg_connection *mg_sntp_connect(struct mg_mgr *mgr, const char *url,\n                                      mg_event_handler_t fn, void *fnd) {\n  struct mg_connection *c = NULL;\n  if (url == NULL) url = \"udp://time.google.com:123\";\n  if ((c = mg_connect(mgr, url, fn, fnd)) != NULL) c->pfn = sntp_cb;\n  return c;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/sock.c\"\n#endif\n\n\n\n\n\n\n\n\n\n\n\n#if MG_ENABLE_SOCKET\n\n#ifndef closesocket\n#define closesocket(x) close(x)\n#endif\n\n#define FD(c_) ((MG_SOCKET_TYPE) (size_t) (c_)->fd)\n#define S2PTR(s_) ((void *) (size_t) (s_))\n\n#ifndef MSG_NONBLOCKING\n#define MSG_NONBLOCKING 0\n#endif\n\n#ifndef AF_INET6\n#define AF_INET6 10\n#endif\n\n#ifndef MG_SOCK_ERR\n#define MG_SOCK_ERR(errcode) ((errcode) < 0 ? errno : 0)\n#endif\n\n#ifndef MG_SOCK_INTR\n#define MG_SOCK_INTR(fd) (fd == MG_INVALID_SOCKET && MG_SOCK_ERR(-1) == EINTR)\n#endif\n\n#ifndef MG_SOCK_PENDING\n#define MG_SOCK_PENDING(errcode) \\\n  (((errcode) < 0) && (errno == EINPROGRESS || errno == EWOULDBLOCK))\n#endif\n\n#ifndef MG_SOCK_RESET\n#define MG_SOCK_RESET(errcode) \\\n  (((errcode) < 0) && (errno == EPIPE || errno == ECONNRESET))\n#endif\n\nunion usa {\n  struct sockaddr sa;\n  struct sockaddr_in sin;\n#if MG_ENABLE_IPV6\n  struct sockaddr_in6 sin6;\n#endif\n};\n\nstatic socklen_t tousa(struct mg_addr *a, union usa *usa) {\n  socklen_t len = sizeof(usa->sin);\n  memset(usa, 0, sizeof(*usa));\n  usa->sin.sin_family = AF_INET;\n  usa->sin.sin_port = a->port;\n  *(uint32_t *) &usa->sin.sin_addr = a->ip;\n#if MG_ENABLE_IPV6\n  if (a->is_ip6) {\n    usa->sin.sin_family = AF_INET6;\n    usa->sin6.sin6_port = a->port;\n    memcpy(&usa->sin6.sin6_addr, a->ip6, sizeof(a->ip6));\n    len = sizeof(usa->sin6);\n  }\n#endif\n  return len;\n}\n\nstatic void tomgaddr(union usa *usa, struct mg_addr *a, bool is_ip6) {\n  a->is_ip6 = is_ip6;\n  a->port = usa->sin.sin_port;\n  memcpy(&a->ip, &usa->sin.sin_addr, sizeof(a->ip));\n#if MG_ENABLE_IPV6\n  if (is_ip6) {\n    memcpy(a->ip6, &usa->sin6.sin6_addr, sizeof(a->ip6));\n    a->port = usa->sin6.sin6_port;\n  }\n#endif\n}\n\nstatic void setlocaddr(MG_SOCKET_TYPE fd, struct mg_addr *addr) {\n  union usa usa;\n  socklen_t n = sizeof(usa);\n  if (getsockname(fd, &usa.sa, &n) == 0) {\n    tomgaddr(&usa, addr, n != sizeof(usa.sin));\n  }\n}\n\nstatic void iolog(struct mg_connection *c, char *buf, long n, bool r) {\n  if (n == MG_IO_WAIT) {\n    // Do nothing\n  } else if (n <= 0) {\n    c->is_closing = 1;  // Termination. Don't call mg_error(): #1529\n  } else if (n > 0) {\n    if (c->is_hexdumping) {\n      union usa usa;\n      socklen_t slen = sizeof(usa.sin);\n      if (getsockname(FD(c), &usa.sa, &slen) < 0) (void) 0;  // Ignore result\n      MG_INFO((\"\\n-- %lu %M %s %M %ld\", c->id, mg_print_ip_port, &c->loc,\n               r ? \"<-\" : \"->\", mg_print_ip_port, &c->rem, n));\n\n      mg_hexdump(buf, (size_t) n);\n    }\n    if (r) {\n      c->recv.len += (size_t) n;\n      mg_call(c, MG_EV_READ, &n);\n    } else {\n      mg_iobuf_del(&c->send, 0, (size_t) n);\n      // if (c->send.len == 0) mg_iobuf_resize(&c->send, 0);\n      if (c->send.len == 0) {\n        MG_EPOLL_MOD(c, 0);\n      }\n      mg_call(c, MG_EV_WRITE, &n);\n    }\n  }\n}\n\nlong mg_io_send(struct mg_connection *c, const void *buf, size_t len) {\n  long n;\n  if (c->is_udp) {\n    union usa usa;\n    socklen_t slen = tousa(&c->rem, &usa);\n    n = sendto(FD(c), (char *) buf, len, 0, &usa.sa, slen);\n    if (n > 0) setlocaddr(FD(c), &c->loc);\n  } else {\n    n = send(FD(c), (char *) buf, len, MSG_NONBLOCKING);\n  }\n  if (MG_SOCK_PENDING(n)) return MG_IO_WAIT;\n  if (MG_SOCK_RESET(n)) return MG_IO_RESET;\n  if (n <= 0) return MG_IO_ERR;\n  return n;\n}\n\nbool mg_send(struct mg_connection *c, const void *buf, size_t len) {\n  if (c->is_udp) {\n    long n = mg_io_send(c, buf, len);\n    MG_DEBUG((\"%lu %p %d:%d %ld err %d\", c->id, c->fd, (int) c->send.len,\n              (int) c->recv.len, n, MG_SOCK_ERR(n)));\n    iolog(c, (char *) buf, n, false);\n    return n > 0;\n  } else {\n    return mg_iobuf_add(&c->send, c->send.len, buf, len);\n  }\n}\n\nstatic void mg_set_non_blocking_mode(MG_SOCKET_TYPE fd) {\n#if defined(MG_CUSTOM_NONBLOCK)\n  MG_CUSTOM_NONBLOCK(fd);\n#elif MG_ARCH == MG_ARCH_WIN32 && MG_ENABLE_WINSOCK\n  unsigned long on = 1;\n  ioctlsocket(fd, FIONBIO, &on);\n#elif MG_ENABLE_RL\n  unsigned long on = 1;\n  ioctlsocket(fd, FIONBIO, &on);\n#elif MG_ENABLE_FREERTOS_TCP\n  const BaseType_t off = 0;\n  if (setsockopt(fd, 0, FREERTOS_SO_RCVTIMEO, &off, sizeof(off)) != 0) (void) 0;\n  if (setsockopt(fd, 0, FREERTOS_SO_SNDTIMEO, &off, sizeof(off)) != 0) (void) 0;\n#elif MG_ENABLE_LWIP\n  lwip_fcntl(fd, F_SETFL, O_NONBLOCK);\n#elif MG_ARCH == MG_ARCH_AZURERTOS\n  fcntl(fd, F_SETFL, O_NONBLOCK);\n#elif MG_ARCH == MG_ARCH_TIRTOS\n  int val = 0;\n  setsockopt(fd, SOL_SOCKET, SO_BLOCKING, &val, sizeof(val));\n  // SPRU524J section 3.3.3 page 63, SO_SNDLOWAT\n  int sz = sizeof(val);\n  getsockopt(fd, SOL_SOCKET, SO_SNDBUF, &val, &sz);\n  val /= 2;  // set send low-water mark at half send buffer size\n  setsockopt(fd, SOL_SOCKET, SO_SNDLOWAT, &val, sizeof(val));\n#else\n  fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);  // Non-blocking mode\n  fcntl(fd, F_SETFD, FD_CLOEXEC);                          // Set close-on-exec\n#endif\n}\n\nbool mg_open_listener(struct mg_connection *c, const char *url) {\n  MG_SOCKET_TYPE fd = MG_INVALID_SOCKET;\n  bool success = false;\n  c->loc.port = mg_htons(mg_url_port(url));\n  if (!mg_aton(mg_url_host(url), &c->loc)) {\n    MG_ERROR((\"invalid listening URL: %s\", url));\n  } else {\n    union usa usa;\n    socklen_t slen = tousa(&c->loc, &usa);\n    int rc, on = 1, af = c->loc.is_ip6 ? AF_INET6 : AF_INET;\n    int type = strncmp(url, \"udp:\", 4) == 0 ? SOCK_DGRAM : SOCK_STREAM;\n    int proto = type == SOCK_DGRAM ? IPPROTO_UDP : IPPROTO_TCP;\n    (void) on;\n\n    if ((fd = socket(af, type, proto)) == MG_INVALID_SOCKET) {\n      MG_ERROR((\"socket: %d\", MG_SOCK_ERR(-1)));\n#if defined(SO_EXCLUSIVEADDRUSE)\n    } else if ((rc = setsockopt(fd, SOL_SOCKET, SO_EXCLUSIVEADDRUSE,\n                                (char *) &on, sizeof(on))) != 0) {\n      // \"Using SO_REUSEADDR and SO_EXCLUSIVEADDRUSE\"\n      MG_ERROR((\"setsockopt(SO_EXCLUSIVEADDRUSE): %d %d\", on, MG_SOCK_ERR(rc)));\n#endif\n#if defined(SO_REUSEADDR) && (!defined(LWIP_SOCKET) || SO_REUSE)\n    } else if ((rc = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *) &on,\n                                sizeof(on))) != 0) {\n      // 1. SO_REUSEADDR semantics on UNIX and Windows is different.  On\n      // Windows, SO_REUSEADDR allows to bind a socket to a port without error\n      // even if the port is already open by another program. This is not the\n      // behavior SO_REUSEADDR was designed for, and leads to hard-to-track\n      // failure scenarios.\n      //\n      // 2. For LWIP, SO_REUSEADDR should be explicitly enabled by defining\n      // SO_REUSE = 1 in lwipopts.h, otherwise the code below will compile but\n      // won't work! (setsockopt will return EINVAL)\n      MG_ERROR((\"setsockopt(SO_REUSEADDR): %d\", MG_SOCK_ERR(rc)));\n#endif\n#if defined(IPV6_V6ONLY)\n    } else if (c->loc.is_ip6 &&\n               (rc = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &on,\n                                sizeof(on))) != 0) {\n      // See #2089. Allow to bind v4 and v6 sockets on the same port\n      MG_ERROR((\"setsockopt(IPV6_V6ONLY): %d\", MG_SOCK_ERR(rc)));\n#endif\n    } else if ((rc = bind(fd, &usa.sa, slen)) != 0) {\n      MG_ERROR((\"bind: %d\", MG_SOCK_ERR(rc)));\n    } else if ((type == SOCK_STREAM &&\n                (rc = listen(fd, MG_SOCK_LISTEN_BACKLOG_SIZE)) != 0)) {\n      // NOTE(lsm): FreeRTOS uses backlog value as a connection limit\n      // In case port was set to 0, get the real port number\n      MG_ERROR((\"listen: %d\", MG_SOCK_ERR(rc)));\n    } else {\n      setlocaddr(fd, &c->loc);\n      mg_set_non_blocking_mode(fd);\n      c->fd = S2PTR(fd);\n      MG_EPOLL_ADD(c);\n      success = true;\n    }\n  }\n  if (success == false && fd != MG_INVALID_SOCKET) closesocket(fd);\n  return success;\n}\n\nlong mg_io_recv(struct mg_connection *c, void *buf, size_t len) {\n  long n = 0;\n  if (c->is_udp) {\n    union usa usa;\n    socklen_t slen = tousa(&c->rem, &usa);\n    n = recvfrom(FD(c), (char *) buf, len, 0, &usa.sa, &slen);\n    if (n > 0) tomgaddr(&usa, &c->rem, slen != sizeof(usa.sin));\n  } else {\n    n = recv(FD(c), (char *) buf, len, MSG_NONBLOCKING);\n  }\n  if (MG_SOCK_PENDING(n)) return MG_IO_WAIT;\n  if (MG_SOCK_RESET(n)) return MG_IO_RESET;\n  if (n <= 0) return MG_IO_ERR;\n  return n;\n}\n\n// NOTE(lsm): do only one iteration of reads, cause some systems\n// (e.g. FreeRTOS stack) return 0 instead of -1/EWOULDBLOCK when no data\nstatic void read_conn(struct mg_connection *c) {\n  long n = -1;\n  if (c->recv.len >= MG_MAX_RECV_SIZE) {\n    mg_error(c, \"max_recv_buf_size reached\");\n  } else if (c->recv.size <= c->recv.len &&\n             !mg_iobuf_resize(&c->recv, c->recv.size + MG_IO_SIZE)) {\n    mg_error(c, \"oom\");\n  } else {\n    char *buf = (char *) &c->recv.buf[c->recv.len];\n    size_t len = c->recv.size - c->recv.len;\n    n = c->is_tls ? mg_tls_recv(c, buf, len) : mg_io_recv(c, buf, len);\n    MG_DEBUG((\"%lu %p snd %ld/%ld rcv %ld/%ld n=%ld err=%d\", c->id, c->fd,\n              (long) c->send.len, (long) c->send.size, (long) c->recv.len,\n              (long) c->recv.size, n, MG_SOCK_ERR(n)));\n    iolog(c, buf, n, true);\n  }\n}\n\nstatic void write_conn(struct mg_connection *c) {\n  char *buf = (char *) c->send.buf;\n  size_t len = c->send.len;\n  long n = c->is_tls ? mg_tls_send(c, buf, len) : mg_io_send(c, buf, len);\n  MG_DEBUG((\"%lu %p snd %ld/%ld rcv %ld/%ld n=%ld err=%d\", c->id, c->fd,\n            (long) c->send.len, (long) c->send.size, (long) c->recv.len,\n            (long) c->recv.size, n, MG_SOCK_ERR(n)));\n  iolog(c, buf, n, false);\n}\n\nstatic void close_conn(struct mg_connection *c) {\n  if (FD(c) != MG_INVALID_SOCKET) {\n#if MG_ENABLE_EPOLL\n    epoll_ctl(c->mgr->epoll_fd, EPOLL_CTL_DEL, FD(c), NULL);\n#endif\n    closesocket(FD(c));\n#if MG_ENABLE_FREERTOS_TCP\n    FreeRTOS_FD_CLR(c->fd, c->mgr->ss, eSELECT_ALL);\n#endif\n  }\n  mg_close_conn(c);\n}\n\nstatic void connect_conn(struct mg_connection *c) {\n  union usa usa;\n  socklen_t n = sizeof(usa);\n  // Use getpeername() to test whether we have connected\n  if (getpeername(FD(c), &usa.sa, &n) == 0) {\n    c->is_connecting = 0;\n    mg_call(c, MG_EV_CONNECT, NULL);\n    MG_EPOLL_MOD(c, 0);\n    if (c->is_tls_hs) mg_tls_handshake(c);\n  } else {\n    mg_error(c, \"socket error\");\n  }\n}\n\nstatic void setsockopts(struct mg_connection *c) {\n#if MG_ENABLE_FREERTOS_TCP || MG_ARCH == MG_ARCH_AZURERTOS || \\\n    MG_ARCH == MG_ARCH_TIRTOS\n  (void) c;\n#else\n  int on = 1;\n#if !defined(SOL_TCP)\n#define SOL_TCP IPPROTO_TCP\n#endif\n  if (setsockopt(FD(c), SOL_TCP, TCP_NODELAY, (char *) &on, sizeof(on)) != 0)\n    (void) 0;\n  if (setsockopt(FD(c), SOL_SOCKET, SO_KEEPALIVE, (char *) &on, sizeof(on)) !=\n      0)\n    (void) 0;\n#endif\n}\n\nvoid mg_connect_resolved(struct mg_connection *c) {\n  int type = c->is_udp ? SOCK_DGRAM : SOCK_STREAM;\n  int rc, af = c->rem.is_ip6 ? AF_INET6 : AF_INET;  // c->rem has resolved IP\n  c->fd = S2PTR(socket(af, type, 0));               // Create outbound socket\n  c->is_resolving = 0;                              // Clear resolving flag\n  if (FD(c) == MG_INVALID_SOCKET) {\n    mg_error(c, \"socket(): %d\", MG_SOCK_ERR(-1));\n  } else if (c->is_udp) {\n    MG_EPOLL_ADD(c);\n#if MG_ARCH == MG_ARCH_TIRTOS\n    union usa usa;  // TI-RTOS NDK requires binding to receive on UDP sockets\n    socklen_t slen = tousa(&c->loc, &usa);\n    if ((rc = bind(c->fd, &usa.sa, slen)) != 0)\n      MG_ERROR((\"bind: %d\", MG_SOCK_ERR(rc)));\n#endif\n    mg_call(c, MG_EV_RESOLVE, NULL);\n    mg_call(c, MG_EV_CONNECT, NULL);\n  } else {\n    union usa usa;\n    socklen_t slen = tousa(&c->rem, &usa);\n    mg_set_non_blocking_mode(FD(c));\n    setsockopts(c);\n    MG_EPOLL_ADD(c);\n    mg_call(c, MG_EV_RESOLVE, NULL);\n    rc = connect(FD(c), &usa.sa, slen);  // Attempt to connect\n    if (rc == 0) {                       // Success\n      mg_call(c, MG_EV_CONNECT, NULL);   // Send MG_EV_CONNECT to the user\n    } else if (MG_SOCK_PENDING(rc)) {    // Need to wait for TCP handshake\n      MG_DEBUG((\"%lu %p -> %M pend\", c->id, c->fd, mg_print_ip_port, &c->rem));\n      c->is_connecting = 1;\n    } else {\n      mg_error(c, \"connect: %d\", MG_SOCK_ERR(rc));\n    }\n  }\n}\n\nstatic MG_SOCKET_TYPE raccept(MG_SOCKET_TYPE sock, union usa *usa,\n                              socklen_t *len) {\n  MG_SOCKET_TYPE fd = MG_INVALID_SOCKET;\n  do {\n    memset(usa, 0, sizeof(*usa));\n    fd = accept(sock, &usa->sa, len);\n  } while (MG_SOCK_INTR(fd));\n  return fd;\n}\n\nstatic void accept_conn(struct mg_mgr *mgr, struct mg_connection *lsn) {\n  struct mg_connection *c = NULL;\n  union usa usa;\n  socklen_t sa_len = sizeof(usa);\n  MG_SOCKET_TYPE fd = raccept(FD(lsn), &usa, &sa_len);\n  if (fd == MG_INVALID_SOCKET) {\n#if MG_ARCH == MG_ARCH_AZURERTOS\n    // AzureRTOS, in non-block socket mode can mark listening socket readable\n    // even it is not. See comment for 'select' func implementation in\n    // nx_bsd.c That's not an error, just should try later\n    if (errno != EAGAIN)\n#endif\n      MG_ERROR((\"%lu accept failed, errno %d\", lsn->id, MG_SOCK_ERR(-1)));\n#if (MG_ARCH != MG_ARCH_WIN32) && !MG_ENABLE_FREERTOS_TCP && \\\n    (MG_ARCH != MG_ARCH_TIRTOS) && !MG_ENABLE_POLL\n  } else if ((long) fd >= FD_SETSIZE) {\n    MG_ERROR((\"%ld > %ld\", (long) fd, (long) FD_SETSIZE));\n    closesocket(fd);\n#endif\n  } else if ((c = mg_alloc_conn(mgr)) == NULL) {\n    MG_ERROR((\"%lu OOM\", lsn->id));\n    closesocket(fd);\n  } else {\n    tomgaddr(&usa, &c->rem, sa_len != sizeof(usa.sin));\n    LIST_ADD_HEAD(struct mg_connection, &mgr->conns, c);\n    c->fd = S2PTR(fd);\n    MG_EPOLL_ADD(c);\n    mg_set_non_blocking_mode(FD(c));\n    setsockopts(c);\n    c->is_accepted = 1;\n    c->is_hexdumping = lsn->is_hexdumping;\n    c->loc = lsn->loc;\n    c->pfn = lsn->pfn;\n    c->pfn_data = lsn->pfn_data;\n    c->fn = lsn->fn;\n    c->fn_data = lsn->fn_data;\n    MG_DEBUG((\"%lu %p accepted %M -> %M\", c->id, c->fd, mg_print_ip_port,\n              &c->rem, mg_print_ip_port, &c->loc));\n    mg_call(c, MG_EV_OPEN, NULL);\n    mg_call(c, MG_EV_ACCEPT, NULL);\n  }\n}\n\nstatic bool mg_socketpair(MG_SOCKET_TYPE sp[2], union usa usa[2], bool udp) {\n  MG_SOCKET_TYPE sock;\n  socklen_t n = sizeof(usa[0].sin);\n  bool success = false;\n\n  sock = sp[0] = sp[1] = MG_INVALID_SOCKET;\n  (void) memset(&usa[0], 0, sizeof(usa[0]));\n  usa[0].sin.sin_family = AF_INET;\n  *(uint32_t *) &usa->sin.sin_addr = mg_htonl(0x7f000001U);  // 127.0.0.1\n  usa[1] = usa[0];\n\n  if (udp && (sp[0] = socket(AF_INET, SOCK_DGRAM, 0)) != MG_INVALID_SOCKET &&\n      (sp[1] = socket(AF_INET, SOCK_DGRAM, 0)) != MG_INVALID_SOCKET &&\n      bind(sp[0], &usa[0].sa, n) == 0 && bind(sp[1], &usa[1].sa, n) == 0 &&\n      getsockname(sp[0], &usa[0].sa, &n) == 0 &&\n      getsockname(sp[1], &usa[1].sa, &n) == 0 &&\n      connect(sp[0], &usa[1].sa, n) == 0 &&\n      connect(sp[1], &usa[0].sa, n) == 0) {\n    success = true;\n  } else if (!udp &&\n             (sock = socket(AF_INET, SOCK_STREAM, 0)) != MG_INVALID_SOCKET &&\n             bind(sock, &usa[0].sa, n) == 0 &&\n             listen(sock, MG_SOCK_LISTEN_BACKLOG_SIZE) == 0 &&\n             getsockname(sock, &usa[0].sa, &n) == 0 &&\n             (sp[0] = socket(AF_INET, SOCK_STREAM, 0)) != MG_INVALID_SOCKET &&\n             connect(sp[0], &usa[0].sa, n) == 0 &&\n             (sp[1] = raccept(sock, &usa[1], &n)) != MG_INVALID_SOCKET) {\n    success = true;\n  }\n  if (success) {\n    mg_set_non_blocking_mode(sp[1]);\n  } else {\n    if (sp[0] != MG_INVALID_SOCKET) closesocket(sp[0]);\n    if (sp[1] != MG_INVALID_SOCKET) closesocket(sp[1]);\n    sp[0] = sp[1] = MG_INVALID_SOCKET;\n  }\n  if (sock != MG_INVALID_SOCKET) closesocket(sock);\n  return success;\n}\n\nint mg_mkpipe(struct mg_mgr *mgr, mg_event_handler_t fn, void *fn_data,\n              bool udp) {\n  union usa usa[2];\n  MG_SOCKET_TYPE sp[2] = {MG_INVALID_SOCKET, MG_INVALID_SOCKET};\n  struct mg_connection *c = NULL;\n  if (!mg_socketpair(sp, usa, udp)) {\n    MG_ERROR((\"Cannot create socket pair\"));\n  } else if ((c = mg_wrapfd(mgr, (int) sp[1], fn, fn_data)) == NULL) {\n    closesocket(sp[0]);\n    closesocket(sp[1]);\n    sp[0] = sp[1] = MG_INVALID_SOCKET;\n  } else {\n    tomgaddr(&usa[0], &c->rem, false);\n    MG_DEBUG((\"%lu %p pipe %lu\", c->id, c->fd, (unsigned long) sp[0]));\n  }\n  return (int) sp[0];\n}\n\nstatic bool can_read(const struct mg_connection *c) {\n  return c->is_full == false;\n}\n\nstatic bool can_write(const struct mg_connection *c) {\n  return c->is_connecting || (c->send.len > 0 && c->is_tls_hs == 0);\n}\n\nstatic bool skip_iotest(const struct mg_connection *c) {\n  return (c->is_closing || c->is_resolving || FD(c) == MG_INVALID_SOCKET) ||\n         (can_read(c) == false && can_write(c) == false);\n}\n\nstatic void mg_iotest(struct mg_mgr *mgr, int ms) {\n#if MG_ENABLE_FREERTOS_TCP\n  struct mg_connection *c;\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    c->is_readable = c->is_writable = 0;\n    if (skip_iotest(c)) continue;\n    if (can_read(c))\n      FreeRTOS_FD_SET(c->fd, mgr->ss, eSELECT_READ | eSELECT_EXCEPT);\n    if (can_write(c)) FreeRTOS_FD_SET(c->fd, mgr->ss, eSELECT_WRITE);\n  }\n  FreeRTOS_select(mgr->ss, pdMS_TO_TICKS(ms));\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    EventBits_t bits = FreeRTOS_FD_ISSET(c->fd, mgr->ss);\n    c->is_readable = bits & (eSELECT_READ | eSELECT_EXCEPT) ? 1U : 0;\n    c->is_writable = bits & eSELECT_WRITE ? 1U : 0;\n    if (c->fd != MG_INVALID_SOCKET)\n      FreeRTOS_FD_CLR(c->fd, mgr->ss,\n                      eSELECT_READ | eSELECT_EXCEPT | eSELECT_WRITE);\n  }\n#elif MG_ENABLE_EPOLL\n  size_t max = 1;\n  for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) {\n    c->is_readable = c->is_writable = 0;\n    if (mg_tls_pending(c) > 0) ms = 1, c->is_readable = 1;\n    if (can_write(c)) MG_EPOLL_MOD(c, 1);\n    max++;\n  }\n  struct epoll_event *evs = (struct epoll_event *) alloca(max * sizeof(evs[0]));\n  int n = epoll_wait(mgr->epoll_fd, evs, (int) max, ms);\n  for (int i = 0; i < n; i++) {\n    struct mg_connection *c = (struct mg_connection *) evs[i].data.ptr;\n    if (evs[i].events & EPOLLERR) {\n      mg_error(c, \"socket error\");\n    } else if (c->is_readable == 0) {\n      bool rd = evs[i].events & (EPOLLIN | EPOLLHUP);\n      bool wr = evs[i].events & EPOLLOUT;\n      c->is_readable = can_read(c) && rd ? 1U : 0;\n      c->is_writable = can_write(c) && wr ? 1U : 0;\n    }\n  }\n  (void) skip_iotest;\n#elif MG_ENABLE_POLL\n  nfds_t n = 0;\n  for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) n++;\n  struct pollfd *fds = (struct pollfd *) alloca(n * sizeof(fds[0]));\n  memset(fds, 0, n * sizeof(fds[0]));\n  n = 0;\n  for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) {\n    c->is_readable = c->is_writable = 0;\n    if (skip_iotest(c)) {\n      // Socket not valid, ignore\n    } else if (mg_tls_pending(c) > 0) {\n      ms = 1;  // Don't wait if TLS is ready\n    } else {\n      fds[n].fd = FD(c);\n      if (can_read(c)) fds[n].events |= POLLIN;\n      if (can_write(c)) fds[n].events |= POLLOUT;\n      n++;\n    }\n  }\n\n  // MG_INFO((\"poll n=%d ms=%d\", (int) n, ms));\n  if (poll(fds, n, ms) < 0) {\n#if MG_ARCH == MG_ARCH_WIN32\n    if (n == 0) Sleep(ms);  // On Windows, poll fails if no sockets\n#endif\n    memset(fds, 0, n * sizeof(fds[0]));\n  }\n  n = 0;\n  for (struct mg_connection *c = mgr->conns; c != NULL; c = c->next) {\n    if (skip_iotest(c)) {\n      // Socket not valid, ignore\n    } else if (mg_tls_pending(c) > 0) {\n      c->is_readable = 1;\n    } else {\n      if (fds[n].revents & POLLERR) {\n        mg_error(c, \"socket error\");\n      } else {\n        c->is_readable =\n            (unsigned) (fds[n].revents & (POLLIN | POLLHUP) ? 1 : 0);\n        c->is_writable = (unsigned) (fds[n].revents & POLLOUT ? 1 : 0);\n      }\n      n++;\n    }\n  }\n#else\n  struct timeval tv = {ms / 1000, (ms % 1000) * 1000}, tv_zero = {0, 0}, *tvp;\n  struct mg_connection *c;\n  fd_set rset, wset, eset;\n  MG_SOCKET_TYPE maxfd = 0;\n  int rc;\n\n  FD_ZERO(&rset);\n  FD_ZERO(&wset);\n  FD_ZERO(&eset);\n  tvp = ms < 0 ? NULL : &tv;\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    c->is_readable = c->is_writable = 0;\n    if (skip_iotest(c)) continue;\n    FD_SET(FD(c), &eset);\n    if (can_read(c)) FD_SET(FD(c), &rset);\n    if (can_write(c)) FD_SET(FD(c), &wset);\n    if (mg_tls_pending(c) > 0) tvp = &tv_zero;\n    if (FD(c) > maxfd) maxfd = FD(c);\n  }\n\n  if ((rc = select((int) maxfd + 1, &rset, &wset, &eset, tvp)) < 0) {\n#if MG_ARCH == MG_ARCH_WIN32\n    if (maxfd == 0) Sleep(ms);  // On Windows, select fails if no sockets\n#else\n    MG_ERROR((\"select: %d %d\", rc, MG_SOCK_ERR(rc)));\n#endif\n    FD_ZERO(&rset);\n    FD_ZERO(&wset);\n    FD_ZERO(&eset);\n  }\n\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    if (FD(c) != MG_INVALID_SOCKET && FD_ISSET(FD(c), &eset)) {\n      mg_error(c, \"socket error\");\n    } else {\n      c->is_readable = FD(c) != MG_INVALID_SOCKET && FD_ISSET(FD(c), &rset);\n      c->is_writable = FD(c) != MG_INVALID_SOCKET && FD_ISSET(FD(c), &wset);\n      if (mg_tls_pending(c) > 0) c->is_readable = 1;\n    }\n  }\n#endif\n}\n\nvoid mg_mgr_poll(struct mg_mgr *mgr, int ms) {\n  struct mg_connection *c, *tmp;\n  uint64_t now;\n\n  mg_iotest(mgr, ms);\n  now = mg_millis();\n  mg_timer_poll(&mgr->timers, now);\n\n  for (c = mgr->conns; c != NULL; c = tmp) {\n    bool is_resp = c->is_resp;\n    tmp = c->next;\n    mg_call(c, MG_EV_POLL, &now);\n    if (is_resp && !c->is_resp) {\n      long n = 0;\n      mg_call(c, MG_EV_READ, &n);\n    }\n    MG_VERBOSE((\"%lu %c%c %c%c%c%c%c\", c->id, c->is_readable ? 'r' : '-',\n                c->is_writable ? 'w' : '-', c->is_tls ? 'T' : 't',\n                c->is_connecting ? 'C' : 'c', c->is_tls_hs ? 'H' : 'h',\n                c->is_resolving ? 'R' : 'r', c->is_closing ? 'C' : 'c'));\n    if (c->is_resolving || c->is_closing) {\n      // Do nothing\n    } else if (c->is_listening && c->is_udp == 0) {\n      if (c->is_readable) accept_conn(mgr, c);\n    } else if (c->is_connecting) {\n      if (c->is_readable || c->is_writable) connect_conn(c);\n    } else if (c->is_tls_hs) {\n      if ((c->is_readable || c->is_writable)) mg_tls_handshake(c);\n    } else {\n      if (c->is_readable) read_conn(c);\n      if (c->is_writable) write_conn(c);\n    }\n\n    if (c->is_draining && c->send.len == 0) c->is_closing = 1;\n    if (c->is_closing) close_conn(c);\n  }\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/ssi.c\"\n#endif\n\n\n\n\n#ifndef MG_MAX_SSI_DEPTH\n#define MG_MAX_SSI_DEPTH 5\n#endif\n\n#ifndef MG_SSI_BUFSIZ\n#define MG_SSI_BUFSIZ 1024\n#endif\n\n#if MG_ENABLE_SSI\nstatic char *mg_ssi(const char *path, const char *root, int depth) {\n  struct mg_iobuf b = {NULL, 0, 0, MG_IO_SIZE};\n  FILE *fp = fopen(path, \"rb\");\n  if (fp != NULL) {\n    char buf[MG_SSI_BUFSIZ], arg[sizeof(buf)];\n    int ch, intag = 0;\n    size_t len = 0;\n    buf[0] = arg[0] = '\\0';\n    while ((ch = fgetc(fp)) != EOF) {\n      if (intag && ch == '>' && buf[len - 1] == '-' && buf[len - 2] == '-') {\n        buf[len++] = (char) (ch & 0xff);\n        buf[len] = '\\0';\n        if (sscanf(buf, \"<!--#include file=\\\"%[^\\\"]\", arg)) {\n          char tmp[MG_PATH_MAX + MG_SSI_BUFSIZ + 10],\n              *p = (char *) path + strlen(path), *data;\n          while (p > path && p[-1] != MG_DIRSEP && p[-1] != '/') p--;\n          mg_snprintf(tmp, sizeof(tmp), \"%.*s%s\", (int) (p - path), path, arg);\n          if (depth < MG_MAX_SSI_DEPTH &&\n              (data = mg_ssi(tmp, root, depth + 1)) != NULL) {\n            mg_iobuf_add(&b, b.len, data, strlen(data));\n            free(data);\n          } else {\n            MG_ERROR((\"%s: file=%s error or too deep\", path, arg));\n          }\n        } else if (sscanf(buf, \"<!--#include virtual=\\\"%[^\\\"]\", arg)) {\n          char tmp[MG_PATH_MAX + MG_SSI_BUFSIZ + 10], *data;\n          mg_snprintf(tmp, sizeof(tmp), \"%s%s\", root, arg);\n          if (depth < MG_MAX_SSI_DEPTH &&\n              (data = mg_ssi(tmp, root, depth + 1)) != NULL) {\n            mg_iobuf_add(&b, b.len, data, strlen(data));\n            free(data);\n          } else {\n            MG_ERROR((\"%s: virtual=%s error or too deep\", path, arg));\n          }\n        } else {\n          // Unknown SSI tag\n          MG_ERROR((\"Unknown SSI tag: %.*s\", (int) len, buf));\n          mg_iobuf_add(&b, b.len, buf, len);\n        }\n        intag = 0;\n        len = 0;\n      } else if (ch == '<') {\n        intag = 1;\n        if (len > 0) mg_iobuf_add(&b, b.len, buf, len);\n        len = 0;\n        buf[len++] = (char) (ch & 0xff);\n      } else if (intag) {\n        if (len == 5 && strncmp(buf, \"<!--#\", 5) != 0) {\n          intag = 0;\n        } else if (len >= sizeof(buf) - 2) {\n          MG_ERROR((\"%s: SSI tag is too large\", path));\n          len = 0;\n        }\n        buf[len++] = (char) (ch & 0xff);\n      } else {\n        buf[len++] = (char) (ch & 0xff);\n        if (len >= sizeof(buf)) {\n          mg_iobuf_add(&b, b.len, buf, len);\n          len = 0;\n        }\n      }\n    }\n    if (len > 0) mg_iobuf_add(&b, b.len, buf, len);\n    if (b.len > 0) mg_iobuf_add(&b, b.len, \"\", 1);  // nul-terminate\n    fclose(fp);\n  }\n  (void) depth;\n  (void) root;\n  return (char *) b.buf;\n}\n\nvoid mg_http_serve_ssi(struct mg_connection *c, const char *root,\n                       const char *fullpath) {\n  const char *headers = \"Content-Type: text/html; charset=utf-8\\r\\n\";\n  char *data = mg_ssi(fullpath, root, 0);\n  mg_http_reply(c, 200, headers, \"%s\", data == NULL ? \"\" : data);\n  free(data);\n}\n#else\nvoid mg_http_serve_ssi(struct mg_connection *c, const char *root,\n                       const char *fullpath) {\n  mg_http_reply(c, 501, NULL, \"SSI not enabled\");\n  (void) root, (void) fullpath;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/str.c\"\n#endif\n\n\nstruct mg_str mg_str_s(const char *s) {\n  struct mg_str str = {s, s == NULL ? 0 : strlen(s)};\n  return str;\n}\n\nstruct mg_str mg_str_n(const char *s, size_t n) {\n  struct mg_str str = {s, n};\n  return str;\n}\n\nint mg_lower(const char *s) {\n  int c = *s;\n  if (c >= 'A' && c <= 'Z') c += 'a' - 'A';\n  return c;\n}\n\nint mg_ncasecmp(const char *s1, const char *s2, size_t len) {\n  int diff = 0;\n  if (len > 0) do {\n      diff = mg_lower(s1++) - mg_lower(s2++);\n    } while (diff == 0 && s1[-1] != '\\0' && --len > 0);\n  return diff;\n}\n\nint mg_casecmp(const char *s1, const char *s2) {\n  return mg_ncasecmp(s1, s2, (size_t) ~0);\n}\n\nint mg_vcmp(const struct mg_str *s1, const char *s2) {\n  size_t n2 = strlen(s2), n1 = s1->len;\n  int r = strncmp(s1->ptr, s2, (n1 < n2) ? n1 : n2);\n  if (r == 0) return (int) (n1 - n2);\n  return r;\n}\n\nint mg_vcasecmp(const struct mg_str *str1, const char *str2) {\n  size_t n2 = strlen(str2), n1 = str1->len;\n  int r = mg_ncasecmp(str1->ptr, str2, (n1 < n2) ? n1 : n2);\n  if (r == 0) return (int) (n1 - n2);\n  return r;\n}\n\nstruct mg_str mg_strdup(const struct mg_str s) {\n  struct mg_str r = {NULL, 0};\n  if (s.len > 0 && s.ptr != NULL) {\n    char *sc = (char *) calloc(1, s.len + 1);\n    if (sc != NULL) {\n      memcpy(sc, s.ptr, s.len);\n      sc[s.len] = '\\0';\n      r.ptr = sc;\n      r.len = s.len;\n    }\n  }\n  return r;\n}\n\nint mg_strcmp(const struct mg_str str1, const struct mg_str str2) {\n  size_t i = 0;\n  while (i < str1.len && i < str2.len) {\n    int c1 = str1.ptr[i];\n    int c2 = str2.ptr[i];\n    if (c1 < c2) return -1;\n    if (c1 > c2) return 1;\n    i++;\n  }\n  if (i < str1.len) return 1;\n  if (i < str2.len) return -1;\n  return 0;\n}\n\nconst char *mg_strstr(const struct mg_str haystack,\n                      const struct mg_str needle) {\n  size_t i;\n  if (needle.len > haystack.len) return NULL;\n  if (needle.len == 0) return haystack.ptr;\n  for (i = 0; i <= haystack.len - needle.len; i++) {\n    if (memcmp(haystack.ptr + i, needle.ptr, needle.len) == 0) {\n      return haystack.ptr + i;\n    }\n  }\n  return NULL;\n}\n\nstatic bool is_space(int c) {\n  return c == ' ' || c == '\\r' || c == '\\n' || c == '\\t';\n}\n\nstruct mg_str mg_strstrip(struct mg_str s) {\n  while (s.len > 0 && is_space((int) *s.ptr)) s.ptr++, s.len--;\n  while (s.len > 0 && is_space((int) *(s.ptr + s.len - 1))) s.len--;\n  return s;\n}\n\nbool mg_match(struct mg_str s, struct mg_str p, struct mg_str *caps) {\n  size_t i = 0, j = 0, ni = 0, nj = 0;\n  if (caps) caps->ptr = NULL, caps->len = 0;\n  while (i < p.len || j < s.len) {\n    if (i < p.len && j < s.len && (p.ptr[i] == '?' || s.ptr[j] == p.ptr[i])) {\n      if (caps == NULL) {\n      } else if (p.ptr[i] == '?') {\n        caps->ptr = &s.ptr[j], caps->len = 1;     // Finalize `?` cap\n        caps++, caps->ptr = NULL, caps->len = 0;  // Init next cap\n      } else if (caps->ptr != NULL && caps->len == 0) {\n        caps->len = (size_t) (&s.ptr[j] - caps->ptr);  // Finalize current cap\n        caps++, caps->len = 0, caps->ptr = NULL;       // Init next cap\n      }\n      i++, j++;\n    } else if (i < p.len && (p.ptr[i] == '*' || p.ptr[i] == '#')) {\n      if (caps && !caps->ptr) caps->len = 0, caps->ptr = &s.ptr[j];  // Init cap\n      ni = i++, nj = j + 1;\n    } else if (nj > 0 && nj <= s.len && (p.ptr[ni] == '#' || s.ptr[j] != '/')) {\n      i = ni, j = nj;\n      if (caps && caps->ptr == NULL && caps->len == 0) {\n        caps--, caps->len = 0;  // Restart previous cap\n      }\n    } else {\n      return false;\n    }\n  }\n  if (caps && caps->ptr && caps->len == 0) {\n    caps->len = (size_t) (&s.ptr[j] - caps->ptr);\n  }\n  return true;\n}\n\nbool mg_globmatch(const char *s1, size_t n1, const char *s2, size_t n2) {\n  return mg_match(mg_str_n(s2, n2), mg_str_n(s1, n1), NULL);\n}\n\nstatic size_t mg_nce(const char *s, size_t n, size_t ofs, size_t *koff,\n                     size_t *klen, size_t *voff, size_t *vlen, char delim) {\n  size_t kvlen, kl;\n  for (kvlen = 0; ofs + kvlen < n && s[ofs + kvlen] != delim;) kvlen++;\n  for (kl = 0; kl < kvlen && s[ofs + kl] != '=';) kl++;\n  if (koff != NULL) *koff = ofs;\n  if (klen != NULL) *klen = kl;\n  if (voff != NULL) *voff = kl < kvlen ? ofs + kl + 1 : 0;\n  if (vlen != NULL) *vlen = kl < kvlen ? kvlen - kl - 1 : 0;\n  ofs += kvlen + 1;\n  return ofs > n ? n : ofs;\n}\n\nbool mg_split(struct mg_str *s, struct mg_str *k, struct mg_str *v, char sep) {\n  size_t koff = 0, klen = 0, voff = 0, vlen = 0, off = 0;\n  if (s->ptr == NULL || s->len == 0) return 0;\n  off = mg_nce(s->ptr, s->len, 0, &koff, &klen, &voff, &vlen, sep);\n  if (k != NULL) *k = mg_str_n(s->ptr + koff, klen);\n  if (v != NULL) *v = mg_str_n(s->ptr + voff, vlen);\n  *s = mg_str_n(s->ptr + off, s->len - off);\n  return off > 0;\n}\n\nbool mg_commalist(struct mg_str *s, struct mg_str *k, struct mg_str *v) {\n  return mg_split(s, k, v, ',');\n}\n\nchar *mg_hex(const void *buf, size_t len, char *to) {\n  const unsigned char *p = (const unsigned char *) buf;\n  const char *hex = \"0123456789abcdef\";\n  size_t i = 0;\n  for (; len--; p++) {\n    to[i++] = hex[p[0] >> 4];\n    to[i++] = hex[p[0] & 0x0f];\n  }\n  to[i] = '\\0';\n  return to;\n}\n\nstatic unsigned char mg_unhex_nimble(unsigned char c) {\n  return (c >= '0' && c <= '9')   ? (unsigned char) (c - '0')\n         : (c >= 'A' && c <= 'F') ? (unsigned char) (c - '7')\n                                  : (unsigned char) (c - 'W');\n}\n\nunsigned long mg_unhexn(const char *s, size_t len) {\n  unsigned long i = 0, v = 0;\n  for (i = 0; i < len; i++) v <<= 4, v |= mg_unhex_nimble(((uint8_t *) s)[i]);\n  return v;\n}\n\nvoid mg_unhex(const char *buf, size_t len, unsigned char *to) {\n  size_t i;\n  for (i = 0; i < len; i += 2) {\n    to[i >> 1] = (unsigned char) mg_unhexn(&buf[i], 2);\n  }\n}\n\nuint64_t mg_tou64(struct mg_str str) {\n  uint64_t result = 0;\n  size_t i = 0;\n  while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\\t')) i++;\n  while (i < str.len && str.ptr[i] >= '0' && str.ptr[i] <= '9') {\n    result *= 10;\n    result += (unsigned) (str.ptr[i] - '0');\n    i++;\n  }\n  return result;\n}\n\nint64_t mg_to64(struct mg_str str) {\n  int64_t result = 0, neg = 1, max = 922337203685477570 /* INT64_MAX/10-10 */;\n  size_t i = 0;\n  while (i < str.len && (str.ptr[i] == ' ' || str.ptr[i] == '\\t')) i++;\n  if (i < str.len && str.ptr[i] == '-') neg = -1, i++;\n  while (i < str.len && str.ptr[i] >= '0' && str.ptr[i] <= '9') {\n    if (result > max) return 0;\n    result *= 10;\n    result += (str.ptr[i] - '0');\n    i++;\n  }\n  return result * neg;\n}\n\nchar *mg_remove_double_dots(char *s) {\n  char *saved = s, *p = s;\n  while (*s != '\\0') {\n    *p++ = *s++;\n    if (s[-1] == '/' || s[-1] == '\\\\') {\n      while (s[0] != '\\0') {\n        if (s[0] == '/' || s[0] == '\\\\') {\n          s++;\n        } else if (s[0] == '.' && s[1] == '.' &&\n                   (s[2] == '/' || s[2] == '\\\\')) {\n          s += 2;\n        } else {\n          break;\n        }\n      }\n    }\n  }\n  *p = '\\0';\n  return saved;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/timer.c\"\n#endif\n\n\n\n#define MG_TIMER_CALLED 4\n\nvoid mg_timer_init(struct mg_timer **head, struct mg_timer *t, uint64_t ms,\n                   unsigned flags, void (*fn)(void *), void *arg) {\n  t->id = 0, t->period_ms = ms, t->expire = 0;\n  t->flags = flags, t->fn = fn, t->arg = arg, t->next = *head;\n  *head = t;\n}\n\nvoid mg_timer_free(struct mg_timer **head, struct mg_timer *t) {\n  while (*head && *head != t) head = &(*head)->next;\n  if (*head) *head = t->next;\n}\n\n// t: expiration time, prd: period, now: current time. Return true if expired\nbool mg_timer_expired(uint64_t *t, uint64_t prd, uint64_t now) {\n  if (now + prd < *t) *t = 0;                    // Time wrapped? Reset timer\n  if (*t == 0) *t = now + prd;                   // Firt poll? Set expiration\n  if (*t > now) return false;                    // Not expired yet, return\n  *t = (now - *t) > prd ? now + prd : *t + prd;  // Next expiration time\n  return true;                                   // Expired, return true\n}\n\nvoid mg_timer_poll(struct mg_timer **head, uint64_t now_ms) {\n  struct mg_timer *t, *tmp;\n  for (t = *head; t != NULL; t = tmp) {\n    bool once = t->expire == 0 && (t->flags & MG_TIMER_RUN_NOW) &&\n                !(t->flags & MG_TIMER_CALLED);  // Handle MG_TIMER_NOW only once\n    bool expired = mg_timer_expired(&t->expire, t->period_ms, now_ms);\n    tmp = t->next;\n    if (!once && !expired) continue;\n    if ((t->flags & MG_TIMER_REPEAT) || !(t->flags & MG_TIMER_CALLED)) {\n      t->fn(t->arg);\n    }\n    t->flags |= MG_TIMER_CALLED;\n  }\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tls_dummy.c\"\n#endif\n\n\n#if !MG_ENABLE_MBEDTLS && !MG_ENABLE_OPENSSL && !MG_ENABLE_CUSTOM_TLS\nvoid mg_tls_init(struct mg_connection *c, const struct mg_tls_opts *opts) {\n  (void) opts;\n  mg_error(c, \"TLS is not enabled\");\n}\nvoid mg_tls_handshake(struct mg_connection *c) {\n  (void) c;\n}\nvoid mg_tls_free(struct mg_connection *c) {\n  (void) c;\n}\nlong mg_tls_recv(struct mg_connection *c, void *buf, size_t len) {\n  return c == NULL || buf == NULL || len == 0 ? 0 : -1;\n}\nlong mg_tls_send(struct mg_connection *c, const void *buf, size_t len) {\n  return c == NULL || buf == NULL || len == 0 ? 0 : -1;\n}\nsize_t mg_tls_pending(struct mg_connection *c) {\n  (void) c;\n  return 0;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tls_mbed.c\"\n#endif\n\n\n\n\n#if MG_ENABLE_MBEDTLS\n\n#if defined(MBEDTLS_VERSION_NUMBER) && MBEDTLS_VERSION_NUMBER >= 0x03000000\n#define MGRNG , rng_get, NULL\n#else\n#define MGRNG\n#endif\n\nvoid mg_tls_free(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  if (tls != NULL) {\n    free(tls->cafile);\n    mbedtls_ssl_free(&tls->ssl);\n    mbedtls_pk_free(&tls->pk);\n    mbedtls_x509_crt_free(&tls->ca);\n    mbedtls_x509_crt_free(&tls->cert);\n    mbedtls_ssl_config_free(&tls->conf);\n    free(tls);\n    c->tls = NULL;\n  }\n}\n\nstatic int mg_net_send(void *ctx, const unsigned char *buf, size_t len) {\n  long n = mg_io_send((struct mg_connection *) ctx, buf, len);\n  MG_VERBOSE((\"%lu n=%ld e=%d\", ((struct mg_connection *) ctx)->id, n, errno));\n  if (n == MG_IO_WAIT) return MBEDTLS_ERR_SSL_WANT_WRITE;\n  if (n == MG_IO_RESET) return MBEDTLS_ERR_NET_CONN_RESET;\n  if (n == MG_IO_ERR) return MBEDTLS_ERR_NET_SEND_FAILED;\n  return (int) n;\n}\n\nstatic int mg_net_recv(void *ctx, unsigned char *buf, size_t len) {\n  long n = mg_io_recv((struct mg_connection *) ctx, buf, len);\n  MG_VERBOSE((\"%lu n=%ld\", ((struct mg_connection *) ctx)->id, n));\n  if (n == MG_IO_WAIT) return MBEDTLS_ERR_SSL_WANT_WRITE;\n  if (n == MG_IO_RESET) return MBEDTLS_ERR_NET_CONN_RESET;\n  if (n == MG_IO_ERR) return MBEDTLS_ERR_NET_RECV_FAILED;\n  return (int) n;\n}\n\nvoid mg_tls_handshake(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  int rc = mbedtls_ssl_handshake(&tls->ssl);\n  if (rc == 0) {  // Success\n    MG_DEBUG((\"%lu success\", c->id));\n    c->is_tls_hs = 0;\n    mg_call(c, MG_EV_TLS_HS, NULL);\n  } else if (rc == MBEDTLS_ERR_SSL_WANT_READ ||\n             rc == MBEDTLS_ERR_SSL_WANT_WRITE) {  // Still pending\n    MG_VERBOSE((\"%lu pending, %d%d %d (-%#x)\", c->id, c->is_connecting,\n                c->is_tls_hs, rc, -rc));\n  } else {\n    mg_error(c, \"TLS handshake: -%#x\", -rc);  // Error\n  }\n}\n\nstatic int mbed_rng(void *ctx, unsigned char *buf, size_t len) {\n  mg_random(buf, len);\n  (void) ctx;\n  return 0;\n}\n\nstatic void debug_cb(void *c, int lev, const char *s, int n, const char *s2) {\n  n = (int) strlen(s2) - 1;\n  MG_INFO((\"%lu %d %.*s\", ((struct mg_connection *) c)->id, lev, n, s2));\n  (void) s;\n}\n\n#if defined(MBEDTLS_VERSION_NUMBER) && MBEDTLS_VERSION_NUMBER >= 0x03000000\nstatic int rng_get(void *p_rng, unsigned char *buf, size_t len) {\n  (void) p_rng;\n  mg_random(buf, len);\n  return 0;\n}\n#endif\n\nstatic struct mg_str mg_loadfile(struct mg_fs *fs, const char *path) {\n  size_t n = 0;\n  if (path[0] == '-') return mg_str(path);\n  char *p = mg_file_read(fs, path, &n);\n  return mg_str_n(p, n);\n}\n\nvoid mg_tls_init(struct mg_connection *c, const struct mg_tls_opts *opts) {\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct mg_tls *tls = (struct mg_tls *) calloc(1, sizeof(*tls));\n  int rc = 0;\n  c->tls = tls;\n  if (c->tls == NULL) {\n    mg_error(c, \"TLS OOM\");\n    goto fail;\n  }\n  MG_DEBUG((\"%lu Setting TLS\", c->id));\n  mbedtls_ssl_init(&tls->ssl);\n  mbedtls_ssl_config_init(&tls->conf);\n  mbedtls_x509_crt_init(&tls->ca);\n  mbedtls_x509_crt_init(&tls->cert);\n  mbedtls_pk_init(&tls->pk);\n  mbedtls_ssl_conf_dbg(&tls->conf, debug_cb, c);\n#if defined(MG_MBEDTLS_DEBUG_LEVEL)\n  mbedtls_debug_set_threshold(MG_MBEDTLS_DEBUG_LEVEL);\n#endif\n  if ((rc = mbedtls_ssl_config_defaults(\n           &tls->conf,\n           c->is_client ? MBEDTLS_SSL_IS_CLIENT : MBEDTLS_SSL_IS_SERVER,\n           MBEDTLS_SSL_TRANSPORT_STREAM, MBEDTLS_SSL_PRESET_DEFAULT)) != 0) {\n    mg_error(c, \"tls defaults %#x\", -rc);\n    goto fail;\n  }\n  mbedtls_ssl_conf_rng(&tls->conf, mbed_rng, c);\n  if (opts->ca == NULL || strcmp(opts->ca, \"*\") == 0) {\n    mbedtls_ssl_conf_authmode(&tls->conf, MBEDTLS_SSL_VERIFY_NONE);\n  } else if (opts->ca != NULL && opts->ca[0] != '\\0') {\n#if defined(MBEDTLS_X509_CA_CHAIN_ON_DISK)\n    tls->cafile = strdup(opts->ca);\n    rc = mbedtls_ssl_conf_ca_chain_file(&tls->conf, tls->cafile, NULL);\n    if (rc != 0) {\n      mg_error(c, \"parse on-disk chain(%s) err %#x\", tls->cafile, -rc);\n      goto fail;\n    }\n#else\n    struct mg_str s = mg_loadfile(fs, opts->ca);\n    rc = mbedtls_x509_crt_parse(&tls->ca, (uint8_t *) s.ptr, s.len + 1);\n    if (opts->ca[0] != '-') free((char *) s.ptr);\n    if (rc != 0) {\n      mg_error(c, \"parse(%s) err %#x\", opts->ca, -rc);\n      goto fail;\n    }\n    mbedtls_ssl_conf_ca_chain(&tls->conf, &tls->ca, NULL);\n#endif\n    if (opts->srvname.len > 0) {\n      char *x = mg_mprintf(\"%.*s\", (int) opts->srvname.len, opts->srvname.ptr);\n      mbedtls_ssl_set_hostname(&tls->ssl, x);\n      free(x);\n    }\n    mbedtls_ssl_conf_authmode(&tls->conf, MBEDTLS_SSL_VERIFY_REQUIRED);\n  }\n  if (opts->cert != NULL && opts->cert[0] != '\\0') {\n    struct mg_str s = mg_loadfile(fs, opts->cert);\n    const char *key = opts->certkey == NULL ? opts->cert : opts->certkey;\n    rc = mbedtls_x509_crt_parse(&tls->cert, (uint8_t *) s.ptr, s.len + 1);\n    if (opts->cert[0] != '-') free((char *) s.ptr);\n    if (rc != 0) {\n      mg_error(c, \"parse(%s) err %#x\", opts->cert, -rc);\n      goto fail;\n    }\n    s = mg_loadfile(fs, key);\n    rc = mbedtls_pk_parse_key(&tls->pk, (uint8_t *) s.ptr, s.len + 1, NULL,\n                              0 MGRNG);\n    if (key[0] != '-') free((char *) s.ptr);\n    if (rc != 0) {\n      mg_error(c, \"tls key(%s) %#x\", key, -rc);\n      goto fail;\n    }\n    rc = mbedtls_ssl_conf_own_cert(&tls->conf, &tls->cert, &tls->pk);\n    if (rc != 0) {\n      mg_error(c, \"own cert %#x\", -rc);\n      goto fail;\n    }\n  }\n  if ((rc = mbedtls_ssl_setup(&tls->ssl, &tls->conf)) != 0) {\n    mg_error(c, \"setup err %#x\", -rc);\n    goto fail;\n  }\n  c->tls = tls;\n  c->is_tls = 1;\n  c->is_tls_hs = 1;\n  mbedtls_ssl_set_bio(&tls->ssl, c, mg_net_send, mg_net_recv, 0);\n  if (c->is_client && c->is_resolving == 0 && c->is_connecting == 0) {\n    mg_tls_handshake(c);\n  }\n  return;\nfail:\n  mg_tls_free(c);\n}\n\nsize_t mg_tls_pending(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  return tls == NULL ? 0 : mbedtls_ssl_get_bytes_avail(&tls->ssl);\n}\n\nlong mg_tls_recv(struct mg_connection *c, void *buf, size_t len) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  long n = mbedtls_ssl_read(&tls->ssl, (unsigned char *) buf, len);\n  if (n == MBEDTLS_ERR_SSL_WANT_READ || n == MBEDTLS_ERR_SSL_WANT_WRITE)\n    return MG_IO_WAIT;\n  if (n <= 0) return MG_IO_ERR;\n  return n;\n}\n\nlong mg_tls_send(struct mg_connection *c, const void *buf, size_t len) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  long n = mbedtls_ssl_write(&tls->ssl, (unsigned char *) buf, len);\n  if (n == MBEDTLS_ERR_SSL_WANT_READ || n == MBEDTLS_ERR_SSL_WANT_WRITE)\n    return MG_IO_WAIT;\n  if (n <= 0) return MG_IO_ERR;\n  return n;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tls_openssl.c\"\n#endif\n\n\n\n#if MG_ENABLE_OPENSSL\nstatic int mg_tls_err(struct mg_tls *tls, int res) {\n  int err = SSL_get_error(tls->ssl, res);\n  // We've just fetched the last error from the queue.\n  // Now we need to clear the error queue. If we do not, then the following\n  // can happen (actually reported):\n  //  - A new connection is accept()-ed with cert error (e.g. self-signed cert)\n  //  - Since all accept()-ed connections share listener's context,\n  //  - *ALL* SSL accepted connection report read error on the next poll cycle.\n  //    Thus a single errored connection can close all the rest, unrelated ones.\n  // Clearing the error keeps the shared SSL_CTX in an OK state.\n\n  if (err != 0) ERR_print_errors_fp(stderr);\n  ERR_clear_error();\n  if (err == SSL_ERROR_WANT_READ) return 0;\n  if (err == SSL_ERROR_WANT_WRITE) return 0;\n  return err;\n}\n\nvoid mg_tls_init(struct mg_connection *c, const struct mg_tls_opts *opts) {\n  struct mg_tls *tls = (struct mg_tls *) calloc(1, sizeof(*tls));\n  const char *id = \"mongoose\";\n  static unsigned char s_initialised = 0;\n  int rc;\n\n  if (tls == NULL) {\n    mg_error(c, \"TLS OOM\");\n    goto fail;\n  }\n\n  if (!s_initialised) {\n    SSL_library_init();\n    s_initialised++;\n  }\n  MG_DEBUG((\"%lu Setting TLS, CA: %s, cert: %s, key: %s\", c->id,\n            opts->ca == NULL ? \"null\" : opts->ca,\n            opts->cert == NULL ? \"null\" : opts->cert,\n            opts->certkey == NULL ? \"null\" : opts->certkey));\n  tls->ctx = c->is_client ? SSL_CTX_new(SSLv23_client_method())\n                          : SSL_CTX_new(SSLv23_server_method());\n  if ((tls->ssl = SSL_new(tls->ctx)) == NULL) {\n    mg_error(c, \"SSL_new\");\n    goto fail;\n  }\n  SSL_set_session_id_context(tls->ssl, (const uint8_t *) id,\n                             (unsigned) strlen(id));\n  // Disable deprecated protocols\n  SSL_set_options(tls->ssl, SSL_OP_NO_SSLv2);\n  SSL_set_options(tls->ssl, SSL_OP_NO_SSLv3);\n  SSL_set_options(tls->ssl, SSL_OP_NO_TLSv1);\n  SSL_set_options(tls->ssl, SSL_OP_NO_TLSv1_1);\n#ifdef MG_ENABLE_OPENSSL_NO_COMPRESSION\n  SSL_set_options(tls->ssl, SSL_OP_NO_COMPRESSION);\n#endif\n#ifdef MG_ENABLE_OPENSSL_CIPHER_SERVER_PREFERENCE\n  SSL_set_options(tls->ssl, SSL_OP_CIPHER_SERVER_PREFERENCE);\n#endif\n\n  if (opts->ca != NULL && opts->ca[0] != '\\0') {\n    SSL_set_verify(tls->ssl, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,\n                   NULL);\n    if ((rc = SSL_CTX_load_verify_locations(tls->ctx, opts->ca, NULL)) != 1) {\n      mg_error(c, \"load('%s') %d err %d\", opts->ca, rc, mg_tls_err(tls, rc));\n      goto fail;\n    }\n  }\n  if (opts->cert != NULL && opts->cert[0] != '\\0') {\n    const char *key = opts->certkey;\n    if (key == NULL) key = opts->cert;\n    if ((rc = SSL_use_certificate_file(tls->ssl, opts->cert, 1)) != 1) {\n      mg_error(c, \"Invalid SSL cert, err %d\", mg_tls_err(tls, rc));\n      goto fail;\n    } else if ((rc = SSL_use_PrivateKey_file(tls->ssl, key, 1)) != 1) {\n      mg_error(c, \"Invalid SSL key, err %d\", mg_tls_err(tls, rc));\n      goto fail;\n#if OPENSSL_VERSION_NUMBER > 0x10100000L\n    } else if ((rc = SSL_use_certificate_chain_file(tls->ssl, opts->cert)) !=\n               1) {\n      mg_error(c, \"Invalid chain, err %d\", mg_tls_err(tls, rc));\n      goto fail;\n#endif\n    } else {\n      SSL_set_mode(tls->ssl, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);\n#if OPENSSL_VERSION_NUMBER > 0x10002000L\n      SSL_set_ecdh_auto(tls->ssl, 1);\n#endif\n    }\n  }\n  if (opts->ciphers != NULL) SSL_set_cipher_list(tls->ssl, opts->ciphers);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n  if (opts->srvname.len > 0) {\n    char *s = mg_mprintf(\"%.*s\", (int) opts->srvname.len, opts->srvname.ptr);\n    SSL_set1_host(tls->ssl, s);\n    SSL_set_tlsext_host_name(tls->ssl, s);\n    free(s);\n  }\n#endif\n  c->tls = tls;\n  c->is_tls = 1;\n  c->is_tls_hs = 1;\n  if (c->is_client && c->is_resolving == 0 && c->is_connecting == 0) {\n    mg_tls_handshake(c);\n  }\n  MG_DEBUG((\"%lu SSL %s OK\", c->id, c->is_accepted ? \"accept\" : \"client\"));\n  return;\nfail:\n  c->is_closing = 1;\n  free(tls);\n}\n\nvoid mg_tls_handshake(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  int rc;\n  SSL_set_fd(tls->ssl, (int) (size_t) c->fd);\n  rc = c->is_client ? SSL_connect(tls->ssl) : SSL_accept(tls->ssl);\n  if (rc == 1) {\n    MG_DEBUG((\"%lu success\", c->id));\n    c->is_tls_hs = 0;\n    mg_call(c, MG_EV_TLS_HS, NULL);\n  } else {\n    int code = mg_tls_err(tls, rc);\n    if (code != 0) mg_error(c, \"tls hs: rc %d, err %d\", rc, code);\n  }\n}\n\nvoid mg_tls_free(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  if (tls == NULL) return;\n  SSL_free(tls->ssl);\n  SSL_CTX_free(tls->ctx);\n  free(tls);\n  c->tls = NULL;\n}\n\nsize_t mg_tls_pending(struct mg_connection *c) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  return tls == NULL ? 0 : (size_t) SSL_pending(tls->ssl);\n}\n\nlong mg_tls_recv(struct mg_connection *c, void *buf, size_t len) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  int n = SSL_read(tls->ssl, buf, (int) len);\n  if (n < 0 && mg_tls_err(tls, n) == 0) return MG_IO_WAIT;\n  if (n <= 0) return MG_IO_ERR;\n  return n;\n}\n\nlong mg_tls_send(struct mg_connection *c, const void *buf, size_t len) {\n  struct mg_tls *tls = (struct mg_tls *) c->tls;\n  int n = SSL_write(tls->ssl, buf, (int) len);\n  if (n < 0 && mg_tls_err(tls, n) == 0) return MG_IO_WAIT;\n  if (n <= 0) return MG_IO_ERR;\n  return n;\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/url.c\"\n#endif\n\n\nstruct url {\n  size_t key, user, pass, host, port, uri, end;\n};\n\nint mg_url_is_ssl(const char *url) {\n  return strncmp(url, \"wss:\", 4) == 0 || strncmp(url, \"https:\", 6) == 0 ||\n         strncmp(url, \"mqtts:\", 6) == 0 || strncmp(url, \"ssl:\", 4) == 0 ||\n         strncmp(url, \"tls:\", 4) == 0;\n}\n\nstatic struct url urlparse(const char *url) {\n  size_t i;\n  struct url u;\n  memset(&u, 0, sizeof(u));\n  for (i = 0; url[i] != '\\0'; i++) {\n    if (url[i] == '/' && i > 0 && u.host == 0 && url[i - 1] == '/') {\n      u.host = i + 1;\n      u.port = 0;\n    } else if (url[i] == ']') {\n      u.port = 0;  // IPv6 URLs, like http://[::1]/bar\n    } else if (url[i] == ':' && u.port == 0 && u.uri == 0) {\n      u.port = i + 1;\n    } else if (url[i] == '@' && u.user == 0 && u.pass == 0 && u.uri == 0) {\n      u.user = u.host;\n      u.pass = u.port;\n      u.host = i + 1;\n      u.port = 0;\n    } else if (url[i] == '/' && u.host && u.uri == 0) {\n      u.uri = i;\n    }\n  }\n  u.end = i;\n#if 0\n  printf(\"[%s] %d %d %d %d %d\\n\", url, u.user, u.pass, u.host, u.port, u.uri);\n#endif\n  return u;\n}\n\nstruct mg_str mg_url_host(const char *url) {\n  struct url u = urlparse(url);\n  size_t n = u.port  ? u.port - u.host - 1\n             : u.uri ? u.uri - u.host\n                     : u.end - u.host;\n  struct mg_str s = mg_str_n(url + u.host, n);\n  return s;\n}\n\nconst char *mg_url_uri(const char *url) {\n  struct url u = urlparse(url);\n  return u.uri ? url + u.uri : \"/\";\n}\n\nunsigned short mg_url_port(const char *url) {\n  struct url u = urlparse(url);\n  unsigned short port = 0;\n  if (strncmp(url, \"http:\", 5) == 0 || strncmp(url, \"ws:\", 3) == 0) port = 80;\n  if (strncmp(url, \"wss:\", 4) == 0 || strncmp(url, \"https:\", 6) == 0)\n    port = 443;\n  if (strncmp(url, \"mqtt:\", 5) == 0) port = 1883;\n  if (strncmp(url, \"mqtts:\", 6) == 0) port = 8883;\n  if (u.port) port = (unsigned short) atoi(url + u.port);\n  return port;\n}\n\nstruct mg_str mg_url_user(const char *url) {\n  struct url u = urlparse(url);\n  struct mg_str s = mg_str(\"\");\n  if (u.user && (u.pass || u.host)) {\n    size_t n = u.pass ? u.pass - u.user - 1 : u.host - u.user - 1;\n    s = mg_str_n(url + u.user, n);\n  }\n  return s;\n}\n\nstruct mg_str mg_url_pass(const char *url) {\n  struct url u = urlparse(url);\n  struct mg_str s = mg_str_n(\"\", 0UL);\n  if (u.pass && u.host) {\n    size_t n = u.host - u.pass - 1;\n    s = mg_str_n(url + u.pass, n);\n  }\n  return s;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/util.c\"\n#endif\n\n\n#if MG_ENABLE_CUSTOM_RANDOM\n#else\nvoid mg_random(void *buf, size_t len) {\n  bool done = false;\n  unsigned char *p = (unsigned char *) buf;\n#if MG_ARCH == MG_ARCH_ESP32\n  while (len--) *p++ = (unsigned char) (esp_random() & 255);\n  done = true;\n#elif MG_ARCH == MG_ARCH_WIN32\n#elif MG_ARCH == MG_ARCH_UNIX\n  FILE *fp = fopen(\"/dev/urandom\", \"rb\");\n  if (fp != NULL) {\n    if (fread(buf, 1, len, fp) == len) done = true;\n    fclose(fp);\n  }\n#endif\n  // If everything above did not work, fallback to a pseudo random generator\n  while (!done && len--) *p++ = (unsigned char) (rand() & 255);\n}\n#endif\n\nchar *mg_random_str(char *buf, size_t len) {\n  size_t i;\n  mg_random(buf, len);\n  for (i = 0; i < len; i++) {\n    uint8_t c = ((uint8_t *) buf)[i] % 62U;\n    buf[i] = i == len - 1 ? (char) '\\0'            // 0-terminate last byte\n             : c < 26     ? (char) ('a' + c)       // lowercase\n             : c < 52     ? (char) ('A' + c - 26)  // uppercase\n                          : (char) ('0' + c - 52);     // numeric\n  }\n  return buf;\n}\n\nuint32_t mg_ntohl(uint32_t net) {\n  uint8_t data[4] = {0, 0, 0, 0};\n  memcpy(&data, &net, sizeof(data));\n  return (((uint32_t) data[3]) << 0) | (((uint32_t) data[2]) << 8) |\n         (((uint32_t) data[1]) << 16) | (((uint32_t) data[0]) << 24);\n}\n\nuint16_t mg_ntohs(uint16_t net) {\n  uint8_t data[2] = {0, 0};\n  memcpy(&data, &net, sizeof(data));\n  return (uint16_t) ((uint16_t) data[1] | (((uint16_t) data[0]) << 8));\n}\n\nuint32_t mg_crc32(uint32_t crc, const char *buf, size_t len) {\n  static const uint32_t crclut[16] = {\n      // table for polynomial 0xEDB88320 (reflected)\n      0x00000000, 0x1DB71064, 0x3B6E20C8, 0x26D930AC, 0x76DC4190, 0x6B6B51F4,\n      0x4DB26158, 0x5005713C, 0xEDB88320, 0xF00F9344, 0xD6D6A3E8, 0xCB61B38C,\n      0x9B64C2B0, 0x86D3D2D4, 0xA00AE278, 0xBDBDF21C};\n  crc = ~crc;\n  while (len--) {\n    uint8_t byte = *(uint8_t *)buf++;\n    crc = crclut[(crc ^ byte) & 0x0F] ^ (crc >> 4);\n    crc = crclut[(crc ^ (byte >> 4)) & 0x0F] ^ (crc >> 4);\n  }\n  return ~crc;\n}\n\nstatic int isbyte(int n) {\n  return n >= 0 && n <= 255;\n}\n\nstatic int parse_net(const char *spec, uint32_t *net, uint32_t *mask) {\n  int n, a, b, c, d, slash = 32, len = 0;\n  if ((sscanf(spec, \"%d.%d.%d.%d/%d%n\", &a, &b, &c, &d, &slash, &n) == 5 ||\n       sscanf(spec, \"%d.%d.%d.%d%n\", &a, &b, &c, &d, &n) == 4) &&\n      isbyte(a) && isbyte(b) && isbyte(c) && isbyte(d) && slash >= 0 &&\n      slash < 33) {\n    len = n;\n    *net = ((uint32_t) a << 24) | ((uint32_t) b << 16) | ((uint32_t) c << 8) |\n           (uint32_t) d;\n    *mask = slash ? (uint32_t) (0xffffffffU << (32 - slash)) : (uint32_t) 0;\n  }\n  return len;\n}\n\nint mg_check_ip_acl(struct mg_str acl, uint32_t remote_ip) {\n  struct mg_str k, v;\n  int allowed = acl.len == 0 ? '+' : '-';  // If any ACL is set, deny by default\n  while (mg_commalist(&acl, &k, &v)) {\n    uint32_t net, mask;\n    if (k.ptr[0] != '+' && k.ptr[0] != '-') return -1;\n    if (parse_net(&k.ptr[1], &net, &mask) == 0) return -2;\n    if ((mg_ntohl(remote_ip) & mask) == net) allowed = k.ptr[0];\n  }\n  return allowed == '+';\n}\n\n#if MG_ENABLE_CUSTOM_MILLIS\n#else\nuint64_t mg_millis(void) {\n#if MG_ARCH == MG_ARCH_WIN32\n  return GetTickCount();\n#elif MG_ARCH == MG_ARCH_RP2040\n  return time_us_64() / 1000;\n#elif MG_ARCH == MG_ARCH_ESP32\n  return esp_timer_get_time() / 1000;\n#elif MG_ARCH == MG_ARCH_ESP8266 || MG_ARCH == MG_ARCH_FREERTOS\n  return xTaskGetTickCount() * portTICK_PERIOD_MS;\n#elif MG_ARCH == MG_ARCH_AZURERTOS\n  return tx_time_get() * (1000 /* MS per SEC */ / TX_TIMER_TICKS_PER_SECOND);\n#elif MG_ARCH == MG_ARCH_TIRTOS\n  return (uint64_t) Clock_getTicks();\n#elif MG_ARCH == MG_ARCH_ZEPHYR\n  return (uint64_t) k_uptime_get();\n#elif MG_ARCH == MG_ARCH_CMSIS_RTOS1\n  return (uint64_t)rt_time_get();\n#elif MG_ARCH == MG_ARCH_CMSIS_RTOS2\n  return (uint64_t)((osKernelGetTickCount() * 1000) / osKernelGetTickFreq());\n#elif MG_ARCH == MG_ARCH_UNIX && defined(__APPLE__)\n  // Apple CLOCK_MONOTONIC_RAW is equivalent to CLOCK_BOOTTIME on linux\n  // Apple CLOCK_UPTIME_RAW is equivalent to CLOCK_MONOTONIC_RAW on linux\n  return clock_gettime_nsec_np(CLOCK_UPTIME_RAW) / 1000000;\n#elif MG_ARCH == MG_ARCH_UNIX\n  struct timespec ts = {0, 0};\n  // See #1615 - prefer monotonic clock\n#if defined(CLOCK_MONOTONIC_RAW)\n  // Raw hardware-based time that is not subject to NTP adjustment\n  clock_gettime(CLOCK_MONOTONIC_RAW, &ts);\n#elif defined(CLOCK_MONOTONIC)\n  // Affected by the incremental adjustments performed by adjtime and NTP\n  clock_gettime(CLOCK_MONOTONIC, &ts);\n#else\n  // Affected by discontinuous jumps in the system time and by the incremental\n  // adjustments performed by adjtime and NTP\n  clock_gettime(CLOCK_REALTIME, &ts);\n#endif\n  return ((uint64_t) ts.tv_sec * 1000 + (uint64_t) ts.tv_nsec / 1000000);\n#elif defined(ARDUINO)\n  return (uint64_t) millis();\n#else\n  return (uint64_t) (time(NULL) * 1000);\n#endif\n}\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/ws.c\"\n#endif\n\n\n\n\n\n\n\n\n\n\n\nstruct ws_msg {\n  uint8_t flags;\n  size_t header_len;\n  size_t data_len;\n};\n\nsize_t mg_ws_vprintf(struct mg_connection *c, int op, const char *fmt,\n                     va_list *ap) {\n  size_t len = c->send.len;\n  size_t n = mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, ap);\n  mg_ws_wrap(c, c->send.len - len, op);\n  return n;\n}\n\nsize_t mg_ws_printf(struct mg_connection *c, int op, const char *fmt, ...) {\n  size_t len = 0;\n  va_list ap;\n  va_start(ap, fmt);\n  len = mg_ws_vprintf(c, op, fmt, &ap);\n  va_end(ap);\n  return len;\n}\n\nstatic void ws_handshake(struct mg_connection *c, const struct mg_str *wskey,\n                         const struct mg_str *wsproto, const char *fmt,\n                         va_list *ap) {\n  const char *magic = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n  unsigned char sha[20], b64_sha[30];\n\n  mg_sha1_ctx sha_ctx;\n  mg_sha1_init(&sha_ctx);\n  mg_sha1_update(&sha_ctx, (unsigned char *) wskey->ptr, wskey->len);\n  mg_sha1_update(&sha_ctx, (unsigned char *) magic, 36);\n  mg_sha1_final(sha, &sha_ctx);\n  mg_base64_encode(sha, sizeof(sha), (char *) b64_sha);\n  mg_xprintf(mg_pfn_iobuf, &c->send,\n             \"HTTP/1.1 101 Switching Protocols\\r\\n\"\n             \"Upgrade: websocket\\r\\n\"\n             \"Connection: Upgrade\\r\\n\"\n             \"Sec-WebSocket-Accept: %s\\r\\n\",\n             b64_sha);\n  if (fmt != NULL) mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, ap);\n  if (wsproto != NULL) {\n    mg_printf(c, \"Sec-WebSocket-Protocol: %.*s\\r\\n\", (int) wsproto->len,\n              wsproto->ptr);\n  }\n  mg_send(c, \"\\r\\n\", 2);\n}\n\nstatic uint32_t be32(const uint8_t *p) {\n  return (((uint32_t) p[3]) << 0) | (((uint32_t) p[2]) << 8) |\n         (((uint32_t) p[1]) << 16) | (((uint32_t) p[0]) << 24);\n}\n\nstatic size_t ws_process(uint8_t *buf, size_t len, struct ws_msg *msg) {\n  size_t i, n = 0, mask_len = 0;\n  memset(msg, 0, sizeof(*msg));\n  if (len >= 2) {\n    n = buf[1] & 0x7f;                // Frame length\n    mask_len = buf[1] & 128 ? 4 : 0;  // last bit is a mask bit\n    msg->flags = buf[0];\n    if (n < 126 && len >= mask_len) {\n      msg->data_len = n;\n      msg->header_len = 2 + mask_len;\n    } else if (n == 126 && len >= 4 + mask_len) {\n      msg->header_len = 4 + mask_len;\n      msg->data_len = (((size_t) buf[2]) << 8) | buf[3];\n    } else if (len >= 10 + mask_len) {\n      msg->header_len = 10 + mask_len;\n      msg->data_len =\n          (size_t) (((uint64_t) be32(buf + 2) << 32) + be32(buf + 6));\n    }\n  }\n  // Sanity check, and integer overflow protection for the boundary check below\n  // data_len should not be larger than 1 Gb\n  if (msg->data_len > 1024 * 1024 * 1024) return 0;\n  if (msg->header_len + msg->data_len > len) return 0;\n  if (mask_len > 0) {\n    uint8_t *p = buf + msg->header_len, *m = p - mask_len;\n    for (i = 0; i < msg->data_len; i++) p[i] ^= m[i & 3];\n  }\n  return msg->header_len + msg->data_len;\n}\n\nstatic size_t mkhdr(size_t len, int op, bool is_client, uint8_t *buf) {\n  size_t n = 0;\n  buf[0] = (uint8_t) (op | 128);\n  if (len < 126) {\n    buf[1] = (unsigned char) len;\n    n = 2;\n  } else if (len < 65536) {\n    uint16_t tmp = mg_htons((uint16_t) len);\n    buf[1] = 126;\n    memcpy(&buf[2], &tmp, sizeof(tmp));\n    n = 4;\n  } else {\n    uint32_t tmp;\n    buf[1] = 127;\n    tmp = mg_htonl((uint32_t) (((uint64_t) len) >> 32));\n    memcpy(&buf[2], &tmp, sizeof(tmp));\n    tmp = mg_htonl((uint32_t) (len & 0xffffffffU));\n    memcpy(&buf[6], &tmp, sizeof(tmp));\n    n = 10;\n  }\n  if (is_client) {\n    buf[1] |= 1 << 7;  // Set masking flag\n    mg_random(&buf[n], 4);\n    n += 4;\n  }\n  return n;\n}\n\nstatic void mg_ws_mask(struct mg_connection *c, size_t len) {\n  if (c->is_client && c->send.buf != NULL) {\n    size_t i;\n    uint8_t *p = c->send.buf + c->send.len - len, *mask = p - 4;\n    for (i = 0; i < len; i++) p[i] ^= mask[i & 3];\n  }\n}\n\nsize_t mg_ws_send(struct mg_connection *c, const void *buf, size_t len,\n                  int op) {\n  uint8_t header[14];\n  size_t header_len = mkhdr(len, op, c->is_client, header);\n  mg_send(c, header, header_len);\n  MG_VERBOSE((\"WS out: %d [%.*s]\", (int) len, (int) len, buf));\n  mg_send(c, buf, len);\n  mg_ws_mask(c, len);\n  return header_len + len;\n}\n\nstatic bool mg_ws_client_handshake(struct mg_connection *c) {\n  int n = mg_http_get_request_len(c->recv.buf, c->recv.len);\n  if (n < 0) {\n    mg_error(c, \"not http\");  // Some just, not an HTTP request\n  } else if (n > 0) {\n    if (n < 15 || memcmp(c->recv.buf + 9, \"101\", 3) != 0) {\n      mg_error(c, \"handshake error\");\n    } else {\n      struct mg_http_message hm;\n      mg_http_parse((char *) c->recv.buf, c->recv.len, &hm);\n      c->is_websocket = 1;\n      mg_call(c, MG_EV_WS_OPEN, &hm);\n    }\n    mg_iobuf_del(&c->recv, 0, (size_t) n);\n  } else {\n    return true;  // Request is not yet received, quit event handler\n  }\n  return false;  // Continue event handler\n}\n\nstatic void mg_ws_cb(struct mg_connection *c, int ev, void *ev_data,\n                     void *fn_data) {\n  struct ws_msg msg;\n  size_t ofs = (size_t) c->pfn_data;\n\n  // assert(ofs < c->recv.len);\n  if (ev == MG_EV_READ) {\n    if (c->is_client && !c->is_websocket && mg_ws_client_handshake(c)) return;\n\n    while (ws_process(c->recv.buf + ofs, c->recv.len - ofs, &msg) > 0) {\n      char *s = (char *) c->recv.buf + ofs + msg.header_len;\n      struct mg_ws_message m = {{s, msg.data_len}, msg.flags};\n      size_t len = msg.header_len + msg.data_len;\n      uint8_t final = msg.flags & 128, op = msg.flags & 15;\n      // MG_VERBOSE (\"fin %d op %d len %d [%.*s]\", final, op,\n      //                       (int) m.data.len, (int) m.data.len, m.data.ptr));\n      switch (op) {\n        case WEBSOCKET_OP_CONTINUE:\n          mg_call(c, MG_EV_WS_CTL, &m);\n          break;\n        case WEBSOCKET_OP_PING:\n          MG_DEBUG((\"%s\", \"WS PONG\"));\n          mg_ws_send(c, s, msg.data_len, WEBSOCKET_OP_PONG);\n          mg_call(c, MG_EV_WS_CTL, &m);\n          break;\n        case WEBSOCKET_OP_PONG:\n          mg_call(c, MG_EV_WS_CTL, &m);\n          break;\n        case WEBSOCKET_OP_TEXT:\n        case WEBSOCKET_OP_BINARY:\n          if (final) mg_call(c, MG_EV_WS_MSG, &m);\n          break;\n        case WEBSOCKET_OP_CLOSE:\n          MG_DEBUG((\"%lu WS CLOSE\", c->id));\n          mg_call(c, MG_EV_WS_CTL, &m);\n          // Echo the payload of the received CLOSE message back to the sender\n          mg_ws_send(c, m.data.ptr, m.data.len, WEBSOCKET_OP_CLOSE);\n          c->is_draining = 1;\n          break;\n        default:\n          // Per RFC6455, close conn when an unknown op is recvd\n          mg_error(c, \"unknown WS op %d\", op);\n          break;\n      }\n\n      // Handle fragmented frames: strip header, keep in c->recv\n      if (final == 0 || op == 0) {\n        if (op) ofs++, len--, msg.header_len--;       // First frame\n        mg_iobuf_del(&c->recv, ofs, msg.header_len);  // Strip header\n        len -= msg.header_len;\n        ofs += len;\n        c->pfn_data = (void *) ofs;\n        // MG_INFO((\"FRAG %d [%.*s]\", (int) ofs, (int) ofs, c->recv.buf));\n      }\n      // Remove non-fragmented frame\n      if (final && op) mg_iobuf_del(&c->recv, ofs, len);\n      // Last chunk of the fragmented frame\n      if (final && !op) {\n        m.flags = c->recv.buf[0];\n        m.data = mg_str_n((char *) &c->recv.buf[1], (size_t) (ofs - 1));\n        mg_call(c, MG_EV_WS_MSG, &m);\n        mg_iobuf_del(&c->recv, 0, ofs);\n        ofs = 0;\n        c->pfn_data = NULL;\n      }\n    }\n  }\n  (void) fn_data;\n  (void) ev_data;\n}\n\nstruct mg_connection *mg_ws_connect(struct mg_mgr *mgr, const char *url,\n                                    mg_event_handler_t fn, void *fn_data,\n                                    const char *fmt, ...) {\n  struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);\n  if (c != NULL) {\n    char nonce[16], key[30];\n    struct mg_str host = mg_url_host(url);\n    mg_random(nonce, sizeof(nonce));\n    mg_base64_encode((unsigned char *) nonce, sizeof(nonce), key);\n    mg_xprintf(mg_pfn_iobuf, &c->send,\n               \"GET %s HTTP/1.1\\r\\n\"\n               \"Upgrade: websocket\\r\\n\"\n               \"Host: %.*s\\r\\n\"\n               \"Connection: Upgrade\\r\\n\"\n               \"Sec-WebSocket-Version: 13\\r\\n\"\n               \"Sec-WebSocket-Key: %s\\r\\n\",\n               mg_url_uri(url), (int) host.len, host.ptr, key);\n    if (fmt != NULL) {\n      va_list ap;\n      va_start(ap, fmt);\n      mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, &ap);\n      va_end(ap);\n    }\n    mg_xprintf(mg_pfn_iobuf, &c->send, \"\\r\\n\");\n    c->pfn = mg_ws_cb;\n    c->pfn_data = NULL;\n  }\n  return c;\n}\n\nvoid mg_ws_upgrade(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *fmt, ...) {\n  struct mg_str *wskey = mg_http_get_header(hm, \"Sec-WebSocket-Key\");\n  c->pfn = mg_ws_cb;\n  c->pfn_data = NULL;\n  if (wskey == NULL) {\n    mg_http_reply(c, 426, \"\", \"WS upgrade expected\\n\");\n    c->is_draining = 1;\n  } else {\n    struct mg_str *wsproto = mg_http_get_header(hm, \"Sec-WebSocket-Protocol\");\n    va_list ap;\n    va_start(ap, fmt);\n    ws_handshake(c, wskey, wsproto, fmt, &ap);\n    va_end(ap);\n    c->is_websocket = 1;\n    c->is_resp = 0;\n    mg_call(c, MG_EV_WS_OPEN, hm);\n  }\n}\n\nsize_t mg_ws_wrap(struct mg_connection *c, size_t len, int op) {\n  uint8_t header[14], *p;\n  size_t header_len = mkhdr(len, op, c->is_client, header);\n\n  // NOTE: order of operations is important!\n  mg_iobuf_add(&c->send, c->send.len, NULL, header_len);\n  p = &c->send.buf[c->send.len - len];         // p points to data\n  memmove(p, p - header_len, len);             // Shift data\n  memcpy(p - header_len, header, header_len);  // Prepend header\n  mg_ws_mask(c, len);                          // Mask data\n\n  return c->send.len;\n}\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tcpip/driver_nxpimxrt1020.c\"\n#endif\n\n\n/*\n * Todo\n * This driver doesn't support 10M line autoconfiguration yet.\n * Packets aren't sent if the link negociated 10M line.\n * todo: MAC back auto reconfiguration.\n */\n\n#if MG_ENABLE_TCPIP && defined(MG_ENABLE_DRIVER_IMXRT1020)\nstruct imx_rt1020_enet {\nvolatile uint32_t RESERVED0, EIR, EIMR, RESERVED1, RDAR, TDAR, RESERVED2[3], ECR, RESERVED3[6], MMFR, MSCR, RESERVED4[7], MIBC, RESERVED5[7], RCR, RESERVED6[15], TCR, RESERVED7[7], PALR, PAUR, OPD, TXIC0, TXIC1, TXIC2, RESERVED8, RXIC0, RXIC1, RXIC2, RESERVED9[3], IAUR, IALR, GAUR, GALR, RESERVED10[7], TFWR, RESERVED11[14], RDSR, TDSR, MRBR[2], RSFL, RSEM, RAEM, RAFL, TSEM, TAEM, TAFL, TIPG, FTRL, RESERVED12[3], TACC, RACC, RESERVED13[15], RMON_T_PACKETS, RMON_T_BC_PKT, RMON_T_MC_PKT, RMON_T_CRC_ALIGN, RMON_T_UNDERSIZE, RMON_T_OVERSIZE, RMON_T_FRAG, RMON_T_JAB, RMON_T_COL, RMON_T_P64, RMON_T_P65TO127, RMON_T_P128TO255, RMON_T_P256TO511, RMON_T_P512TO1023, RMON_T_P1024TO2048, RMON_T_GTE2048, RMON_T_OCTETS, IEEE_T_DROP, IEEE_T_FRAME_OK, IEEE_T_1COL, IEEE_T_MCOL, IEEE_T_DEF, IEEE_T_LCOL, IEEE_T_EXCOL, IEEE_T_MACERR, IEEE_T_CSERR, IEEE_T_SQE, IEEE_T_FDXFC, IEEE_T_OCTETS_OK, RESERVED14[3], RMON_R_PACKETS, RMON_R_BC_PKT, RMON_R_MC_PKT, RMON_R_CRC_ALIGN, RMON_R_UNDERSIZE, RMON_R_OVERSIZE, RMON_R_FRAG, RMON_R_JAB, RESERVED15, RMON_R_P64, RMON_R_P65TO127, RMON_R_P128TO255, RMON_R_P256TO511, RMON_R_P512TO1023, RMON_R_P1024TO2047, RMON_R_GTE2048, RMON_R_OCTETS, IEEE_R_DROP, IEEE_R_FRAME_OK, IEEE_R_CRC, IEEE_R_ALIGN, IEEE_R_MACERR, IEEE_R_FDXFC, IEEE_R_OCTETS_OK, RESERVED16[71], ATCR, ATVR, ATOFF, ATPER, ATCOR, ATINC, ATSTMP, RESERVED17[122], TGSR, TCSR0, TCCR0, TCSR1, TCCR1, TCSR2, TCCR2, TCSR3;\n};\n\n#undef ENET\n#define ENET ((struct imx_rt1020_enet *) (uintptr_t) 0x402D8000u)\n\n#undef BIT\n#define BIT(x) ((uint32_t) 1 << (x))\n\n#define ENET_RXBUFF_SIZE 1536 // 1522 Buffer must be 64bits aligned\n#define ENET_TXBUFF_SIZE 1536 // 1522 hence set to 0x600 (1536)\n#define ENET_RXBD_NUM          (4)\n#define ENET_TXBD_NUM          (4)\n\nconst uint32_t EIMR_RX_ERR = 0x2400000;              // Intr mask RXF+EBERR\n\nvoid ETH_IRQHandler(void);\nstatic bool mg_tcpip_driver_imxrt1020_init(struct mg_tcpip_if *ifp);\nstatic void wait_phy_complete(void);\nstatic struct mg_tcpip_if *s_ifp;                         // MIP interface\n\nstatic size_t mg_tcpip_driver_imxrt1020_tx(const void *, size_t , struct mg_tcpip_if *);\nstatic bool mg_tcpip_driver_imxrt1020_up(struct mg_tcpip_if *ifp);\n\nenum { IMXRT1020_PHY_ADDR = 0x02, IMXRT1020_PHY_BCR = 0, IMXRT1020_PHY_BSR = 1 };     // PHY constants\n\nvoid delay(uint32_t);\nvoid delay (uint32_t di) {\n  volatile int dno = 0; // Prevent optimization\n  for (uint32_t i = 0; i < di; i++)\n    for (int j=0; j<20; j++) // PLLx20 (500 MHz/24MHz)\n      dno++;\n}\n\nstatic void wait_phy_complete(void) {\n  delay(0x00010000);\n  const uint32_t delay_max = 0x00100000;\n  uint32_t delay_cnt = 0;\n  while (!(ENET->EIR & BIT(23)) && (delay_cnt < delay_max))\n  {delay_cnt++;}\n  ENET->EIR |= BIT(23); // MII interrupt clear\n}\n\nstatic uint32_t imxrt1020_eth_read_phy(uint8_t addr, uint8_t reg) {\n  ENET->EIR |= BIT(23); // MII interrupt clear\n  uint32_t mask_phy_adr_reg = 0x1f; // 0b00011111: Ensure we write 5 bits (Phy address & register)\n  uint32_t phy_transaction = 0x00;\n  phy_transaction = (0x1 << 30) \\\n                  | (0x2 << 28) \\\n                  | ((uint32_t)(addr & mask_phy_adr_reg) << 23) \\\n                  | ((uint32_t)(reg & mask_phy_adr_reg)  << 18) \\\n                  | (0x2 << 16);\n\n  ENET->MMFR = phy_transaction;\n  wait_phy_complete();\n\n  return (ENET->MMFR & 0x0000ffff);\n}\n\nstatic void imxrt1020_eth_write_phy(uint8_t addr, uint8_t reg, uint32_t val) {\n  ENET->EIR |= BIT(23); // MII interrupt clear\n  uint8_t mask_phy_adr_reg = 0x1f; // 0b00011111: Ensure we write 5 bits (Phy address & register)\n  uint32_t mask_phy_data = 0x0000ffff; // Ensure we write 16 bits (data)\n  addr &= mask_phy_adr_reg;\n  reg &= mask_phy_adr_reg;\n  val &= mask_phy_data;\n  uint32_t phy_transaction = 0x00;\n  phy_transaction = (uint32_t)(0x1 << 30) \\\n                  | (uint32_t)(0x1 << 28) \\\n                  | (uint32_t)(addr << 23) \\\n                  | (uint32_t)(reg  << 18) \\\n                  | (uint32_t)(0x2 << 16) \\\n                  | (uint32_t)(val);\n  ENET->MMFR = phy_transaction;\n  wait_phy_complete();\n}\n\n// FEC RX/TX descriptors (Enhanced descriptor not enabled)\n// Descriptor buffer structure, little endian\n\ntypedef struct enet_bd_struct_def\n{\n    uint16_t length;  // Data length\n    uint16_t control; // Control and status\n    uint32_t *buffer; // Data ptr\n} enet_bd_struct_t;\n\n// Descriptor and buffer globals, in non-cached area, 64 bits aligned.\n\n__attribute__((section(\"NonCacheable,\\\"aw\\\",%nobits @\"))) enet_bd_struct_t rx_buffer_descriptor[(ENET_RXBD_NUM)] __attribute__((aligned((64U))));\n__attribute__((section(\"NonCacheable,\\\"aw\\\",%nobits @\"))) enet_bd_struct_t tx_buffer_descriptor[(ENET_TXBD_NUM)] __attribute__((aligned((64U))));\n\nuint8_t rx_data_buffer[(ENET_RXBD_NUM)][((unsigned int)(((ENET_RXBUFF_SIZE)) + (((64U))-1U)) & (unsigned int)(~(unsigned int)(((64U))-1U)))] __attribute__((aligned((64U))));\nuint8_t tx_data_buffer[(ENET_TXBD_NUM)][((unsigned int)(((ENET_TXBUFF_SIZE)) + (((64U))-1U)) & (unsigned int)(~(unsigned int)(((64U))-1U)))] __attribute__((aligned((64U))));\n\n// Initialise driver imx_rt1020\n\n// static bool mg_tcpip_driver_imxrt1020_init(uint8_t *mac, void *data) { // VO\nstatic bool mg_tcpip_driver_imxrt1020_init(struct mg_tcpip_if *ifp) {\n\n  struct mg_tcpip_driver_imxrt1020_data *d = (struct mg_tcpip_driver_imxrt1020_data *) ifp->driver_data;\n  s_ifp = ifp;\n\n  // ENET Reset, wait complete\n  ENET->ECR |= BIT(0);\n  while((ENET->ECR & BIT(0)) != 0) {}\n\n  // Re-latches the pin strapping pin values\n  ENET->ECR |= BIT(0);\n  while((ENET->ECR & BIT(0)) != 0) {}\n\n  // Setup MII/RMII MDC clock divider (<= 2.5MHz).\n  ENET->MSCR = 0x130; // HOLDTIME 2 clk, Preamble enable, MDC MII_Speed Div 0x30\n  imxrt1020_eth_write_phy(IMXRT1020_PHY_ADDR, IMXRT1020_PHY_BCR, 0x8000); // PHY W @0x00 D=0x8000 Soft reset\n  while (imxrt1020_eth_read_phy(IMXRT1020_PHY_ADDR, IMXRT1020_PHY_BSR) & BIT(15)) {delay(0x5000);} // Wait finished poll 10ms\n\n  // PHY: Start Link\n  {\n    imxrt1020_eth_write_phy(IMXRT1020_PHY_ADDR, IMXRT1020_PHY_BCR, 0x1200); // PHY W @0x00 D=0x1200 Autonego enable + start\n    imxrt1020_eth_write_phy(IMXRT1020_PHY_ADDR, 0x1f, 0x8180);    // PHY W @0x1f D=0x8180 Ref clock 50 MHz at XI input\n\n    uint32_t bcr = imxrt1020_eth_read_phy(IMXRT1020_PHY_ADDR, IMXRT1020_PHY_BCR);\n    bcr &= ~BIT(10); // Isolation -> Normal\n    imxrt1020_eth_write_phy(IMXRT1020_PHY_ADDR, IMXRT1020_PHY_BCR, bcr);\n  }\n\n  // Disable ENET\n  ENET->ECR = 0x0; //  Disable before configuration\n\n  // Configure ENET\n  ENET->RCR = 0x05ee0104; // #CRCFWD=0 (CRC kept in frame) + RMII + MII Enable\n  \n  ENET->TCR = BIT(8) | BIT(2); // Addins (MAC address from PAUR+PALR) + Full duplex enable\n  //ENET->TFWR = BIT(8); // Store And Forward Enable, 64 bytes (minimize tx latency)\n\n  // Configure descriptors and buffers\n  // RX\n  for (int i = 0; i < ENET_RXBD_NUM; i++) {\n    // Wrap last descriptor buffer ptr\n    rx_buffer_descriptor[i].control = (BIT(15) | ((i<(ENET_RXBD_NUM-1))?0:BIT(13))); // E+(W*)\n    rx_buffer_descriptor[i].buffer = (uint32_t *)rx_data_buffer[i];\n  }\n\n  // TX\n  for (int i = 0; i < ENET_TXBD_NUM; i++) {\n    // Wrap last descriptor buffer ptr\n    tx_buffer_descriptor[i].control = ((i<(ENET_RXBD_NUM-1))?0:BIT(13)) | BIT(10); // (W*)+TC\n    tx_buffer_descriptor[i].buffer = (uint32_t *)tx_data_buffer[i];\n  }\n\n  // Continue ENET configuration\n  ENET->RDSR = (uint32_t)(uintptr_t)rx_buffer_descriptor;\n  ENET->TDSR = (uint32_t)(uintptr_t)tx_buffer_descriptor;\n  ENET->MRBR[0] = ENET_RXBUFF_SIZE; // Same size for RX/TX buffers\n\n  // MAC address filtering (bytes in reversed order)\n  ENET->PAUR = ((uint32_t) ifp->mac[4] << 24U) | (uint32_t) ifp->mac[5] << 16U;\n  ENET->PALR = (uint32_t) (ifp->mac[0] << 24U) | ((uint32_t) ifp->mac[1] << 16U) |\n                 ((uint32_t) ifp->mac[2] << 8U) | ifp->mac[3];\n\n  // Init Hash tables (mac filtering)\n  ENET->IAUR = 0; // Unicast\n  ENET->IALR = 0;\n  ENET->GAUR = 0; // Multicast\n  ENET->GALR = 0;\n\n  // Set ENET Online\n  ENET->ECR |= BIT(8); // ENET Set Little-endian + (FEC buffer desc.)\n  ENET->ECR |= BIT(1); // Enable\n\n  // Set interrupt mask\n  ENET->EIMR = EIMR_RX_ERR;\n\n  // RX Descriptor activation\n  ENET->RDAR = BIT(24); // Activate Receive Descriptor\n  return true;\n}\n\n// Transmit frame\nstatic uint32_t s_rt1020_txno;\n\nstatic size_t mg_tcpip_driver_imxrt1020_tx(const void *buf, size_t len, struct mg_tcpip_if *ifp) {\n\n  if (len > sizeof(tx_data_buffer[ENET_TXBD_NUM])) {\n  //  MG_ERROR((\"Frame too big, %ld\", (long) len));\n    len = 0;  // Frame is too big\n  } else if ((tx_buffer_descriptor[s_rt1020_txno].control & BIT(15))) {\n  MG_ERROR((\"No free descriptors\"));\n    // printf(\"D0 %lx SR %lx\\n\", (long) s_txdesc[0][0], (long) ETH->DMASR);\n    len = 0;  // All descriptors are busy, fail\n  } else {\n    memcpy(tx_data_buffer[s_rt1020_txno], buf, len);     // Copy data\n    tx_buffer_descriptor[s_rt1020_txno].length = (uint16_t) len;  // Set data len\n    tx_buffer_descriptor[s_rt1020_txno].control |= (uint16_t)(BIT(10)); // TC (transmit CRC)\n    //  tx_buffer_descriptor[s_rt1020_txno].control &= (uint16_t)(BIT(14) | BIT(12)); // Own doesn't affect HW\n    tx_buffer_descriptor[s_rt1020_txno].control |= (uint16_t)(BIT(15) | BIT(11)); // R+L (ready+last)\n    ENET->TDAR = BIT(24); // Descriptor updated. Hand over to DMA.\n    // INFO\n    // Relevant Descriptor bits: 15(R)  Ready\n    //                           11(L)  last in frame\n    //                           10(TC) transmis CRC\n    // __DSB(); // ARM errata 838869 Cortex-M4, M4F, M7, M7F: \"store immediate overlapping\n                // exception\" return might vector to incorrect interrupt.\n    if (++s_rt1020_txno >= ENET_TXBD_NUM) s_rt1020_txno = 0;\n  }\n  (void) ifp;\n  return len;\n}\n\n// IRQ (RX)\nstatic uint32_t s_rt1020_rxno;\n\nvoid ENET_IRQHandler(void) {\n  ENET->EIMR = 0;           // Mask interrupts.\n  uint32_t eir = ENET->EIR; // Read EIR\n  ENET->EIR = 0xffffffff;   // Clear interrupts\n\n  if (eir & EIMR_RX_ERR) // Global mask used\n  {\n    if (rx_buffer_descriptor[s_rt1020_rxno].control & BIT(15)) {\n      ENET->EIMR = EIMR_RX_ERR; // Enable interrupts\n      return;  // Empty? -> exit.\n    }\n    // Read inframes\n    else { // Frame received, loop\n      for (uint32_t i = 0; i < 10; i++) {  // read as they arrive but not forever\n        if (rx_buffer_descriptor[s_rt1020_rxno].control & BIT(15)) break;  // exit when done\n        // Process if CRC OK and frame not truncated\n        if (!(rx_buffer_descriptor[s_rt1020_rxno].control & (BIT(2) | BIT(0)))) {\n          uint32_t len = (rx_buffer_descriptor[s_rt1020_rxno].length);\n          mg_tcpip_qwrite(rx_buffer_descriptor[s_rt1020_rxno].buffer, len > 4 ? len - 4 : len, s_ifp);\n        }\n        rx_buffer_descriptor[s_rt1020_rxno].control |= BIT(15); // Inform DMA RX is empty\n        if (++s_rt1020_rxno >= ENET_RXBD_NUM) s_rt1020_rxno = 0;\n      }\n    }\n  }\n  ENET->EIMR = EIMR_RX_ERR; // Enable interrupts\n}\n\n// Up/down status\nstatic bool mg_tcpip_driver_imxrt1020_up(struct mg_tcpip_if *ifp) {\n  uint32_t bsr = imxrt1020_eth_read_phy(IMXRT1020_PHY_ADDR, IMXRT1020_PHY_BSR);\n  (void) ifp;\n  return bsr & BIT(2) ? 1 : 0;\n}\n\n// API\nstruct mg_tcpip_driver mg_tcpip_driver_imxrt1020 = {\n  mg_tcpip_driver_imxrt1020_init, mg_tcpip_driver_imxrt1020_tx, NULL,\n  mg_tcpip_driver_imxrt1020_up};\n\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tcpip/driver_stm32.c\"\n#endif\n\n\n#if MG_ENABLE_TCPIP && MG_ENABLE_DRIVER_STM32\nstruct stm32_eth {\n  volatile uint32_t MACCR, MACFFR, MACHTHR, MACHTLR, MACMIIAR, MACMIIDR, MACFCR,\n      MACVLANTR, RESERVED0[2], MACRWUFFR, MACPMTCSR, RESERVED1, MACDBGR, MACSR,\n      MACIMR, MACA0HR, MACA0LR, MACA1HR, MACA1LR, MACA2HR, MACA2LR, MACA3HR,\n      MACA3LR, RESERVED2[40], MMCCR, MMCRIR, MMCTIR, MMCRIMR, MMCTIMR,\n      RESERVED3[14], MMCTGFSCCR, MMCTGFMSCCR, RESERVED4[5], MMCTGFCR,\n      RESERVED5[10], MMCRFCECR, MMCRFAECR, RESERVED6[10], MMCRGUFCR,\n      RESERVED7[334], PTPTSCR, PTPSSIR, PTPTSHR, PTPTSLR, PTPTSHUR, PTPTSLUR,\n      PTPTSAR, PTPTTHR, PTPTTLR, RESERVED8, PTPTSSR, PTPPPSCR, RESERVED9[564],\n      DMABMR, DMATPDR, DMARPDR, DMARDLAR, DMATDLAR, DMASR, DMAOMR, DMAIER,\n      DMAMFBOCR, DMARSWTR, RESERVED10[8], DMACHTDR, DMACHRDR, DMACHTBAR,\n      DMACHRBAR;\n};\n#undef ETH\n#define ETH ((struct stm32_eth *) (uintptr_t) 0x40028000)\n\n#undef BIT\n#define BIT(x) ((uint32_t) 1 << (x))\n#define ETH_PKT_SIZE 1540  // Max frame size\n#define ETH_DESC_CNT 4     // Descriptors count\n#define ETH_DS 4           // Descriptor size (words)\n\nstatic uint32_t s_rxdesc[ETH_DESC_CNT][ETH_DS];      // RX descriptors\nstatic uint32_t s_txdesc[ETH_DESC_CNT][ETH_DS];      // TX descriptors\nstatic uint8_t s_rxbuf[ETH_DESC_CNT][ETH_PKT_SIZE];  // RX ethernet buffers\nstatic uint8_t s_txbuf[ETH_DESC_CNT][ETH_PKT_SIZE];  // TX ethernet buffers\nstatic uint8_t s_txno;                               // Current TX descriptor\nstatic uint8_t s_rxno;                               // Current RX descriptor\n\nstatic struct mg_tcpip_if *s_ifp;  // MIP interface\nenum { PHY_ADDR = 0, PHY_BCR = 0, PHY_BSR = 1, PHY_CSCR = 31 };\n\nstatic uint32_t eth_read_phy(uint8_t addr, uint8_t reg) {\n  ETH->MACMIIAR &= (7 << 2);\n  ETH->MACMIIAR |= ((uint32_t) addr << 11) | ((uint32_t) reg << 6);\n  ETH->MACMIIAR |= BIT(0);\n  while (ETH->MACMIIAR & BIT(0)) (void) 0;\n  return ETH->MACMIIDR;\n}\n\nstatic void eth_write_phy(uint8_t addr, uint8_t reg, uint32_t val) {\n  ETH->MACMIIDR = val;\n  ETH->MACMIIAR &= (7 << 2);\n  ETH->MACMIIAR |= ((uint32_t) addr << 11) | ((uint32_t) reg << 6) | BIT(1);\n  ETH->MACMIIAR |= BIT(0);\n  while (ETH->MACMIIAR & BIT(0)) (void) 0;\n}\n\nstatic uint32_t get_hclk(void) {\n  struct rcc {\n    volatile uint32_t CR, PLLCFGR, CFGR;\n  } *rcc = (struct rcc *) 0x40023800;\n  uint32_t clk = 0, hsi = 16000000 /* 16 MHz */, hse = 8000000 /* 8MHz */;\n\n  if (rcc->CFGR & (1 << 2)) {\n    clk = hse;\n  } else if (rcc->CFGR & (1 << 3)) {\n    uint32_t vco, m, n, p;\n    m = (rcc->PLLCFGR & (0x3f << 0)) >> 0;\n    n = (rcc->PLLCFGR & (0x1ff << 6)) >> 6;\n    p = (((rcc->PLLCFGR & (3 << 16)) >> 16) + 1) * 2;\n    clk = (rcc->PLLCFGR & (1 << 22)) ? hse : hsi;\n    vco = (uint32_t) ((uint64_t) clk * n / m);\n    clk = vco / p;\n  } else {\n    clk = hsi;\n  }\n  uint32_t hpre = (rcc->CFGR & (15 << 4)) >> 4;\n  if (hpre < 8) return clk;\n\n  uint8_t ahbptab[8] = {1, 2, 3, 4, 6, 7, 8, 9};  // log2(div)\n  return ((uint32_t) clk) >> ahbptab[hpre - 8];\n}\n\n//  Guess CR from HCLK. MDC clock is generated from HCLK (AHB); as per 802.3,\n//  it must not exceed 2.5MHz As the AHB clock can be (and usually is) derived\n//  from the HSI (internal RC), and it can go above specs, the datasheets\n//  specify a range of frequencies and activate one of a series of dividers to\n//  keep the MDC clock safely below 2.5MHz. We guess a divider setting based on\n//  HCLK with a +5% drift. If the user uses a different clock from our\n//  defaults, needs to set the macros on top Valid for STM32F74xxx/75xxx\n//  (38.8.1) and STM32F42xxx/43xxx (33.8.1) (both 4.5% worst case drift)\nstatic int guess_mdc_cr(void) {\n  uint8_t crs[] = {2, 3, 0, 1, 4, 5};          // ETH->MACMIIAR::CR values\n  uint8_t div[] = {16, 26, 42, 62, 102, 124};  // Respective HCLK dividers\n  uint32_t hclk = get_hclk();                  // Guess system HCLK\n  int result = -1;                             // Invalid CR value\n  if (hclk < 25000000) {\n    MG_ERROR((\"HCLK too low\"));\n  } else {\n    for (int i = 0; i < 6; i++) {\n      if (hclk / div[i] <= 2375000UL /* 2.5MHz - 5% */) {\n        result = crs[i];\n        break;\n      }\n    }\n    if (result < 0) MG_ERROR((\"HCLK too high\"));\n  }\n  MG_DEBUG((\"HCLK: %u, CR: %d\", hclk, result));\n  return result;\n}\n\nstatic bool mg_tcpip_driver_stm32_init(struct mg_tcpip_if *ifp) {\n  struct mg_tcpip_driver_stm32_data *d =\n      (struct mg_tcpip_driver_stm32_data *) ifp->driver_data;\n  s_ifp = ifp;\n\n  // Init RX descriptors\n  for (int i = 0; i < ETH_DESC_CNT; i++) {\n    s_rxdesc[i][0] = BIT(31);                            // Own\n    s_rxdesc[i][1] = sizeof(s_rxbuf[i]) | BIT(14);       // 2nd address chained\n    s_rxdesc[i][2] = (uint32_t) (uintptr_t) s_rxbuf[i];  // Point to data buffer\n    s_rxdesc[i][3] =\n        (uint32_t) (uintptr_t) s_rxdesc[(i + 1) % ETH_DESC_CNT];  // Chain\n  }\n\n  // Init TX descriptors\n  for (int i = 0; i < ETH_DESC_CNT; i++) {\n    s_txdesc[i][2] = (uint32_t) (uintptr_t) s_txbuf[i];  // Buf pointer\n    s_txdesc[i][3] =\n        (uint32_t) (uintptr_t) s_txdesc[(i + 1) % ETH_DESC_CNT];  // Chain\n  }\n\n  ETH->DMABMR |= BIT(0);                         // Software reset\n  while ((ETH->DMABMR & BIT(0)) != 0) (void) 0;  // Wait until done\n\n  // Set MDC clock divider. If user told us the value, use it. Otherwise, guess\n  int cr = (d == NULL || d->mdc_cr < 0) ? guess_mdc_cr() : d->mdc_cr;\n  ETH->MACMIIAR = ((uint32_t) cr & 7) << 2;\n\n  // NOTE(cpq): we do not use extended descriptor bit 7, and do not use\n  // hardware checksum. Therefore, descriptor size is 4, not 8\n  // ETH->DMABMR = BIT(13) | BIT(16) | BIT(22) | BIT(23) | BIT(25);\n  ETH->MACIMR = BIT(3) | BIT(9);  // Mask timestamp & PMT IT\n  ETH->MACFCR = BIT(7);           // Disable zero quarta pause\n  // ETH->MACFFR = BIT(31);                            // Receive all\n  eth_write_phy(PHY_ADDR, PHY_BCR, BIT(15));           // Reset PHY\n  eth_write_phy(PHY_ADDR, PHY_BCR, BIT(12));           // Set autonegotiation\n  ETH->DMARDLAR = (uint32_t) (uintptr_t) s_rxdesc;     // RX descriptors\n  ETH->DMATDLAR = (uint32_t) (uintptr_t) s_txdesc;     // RX descriptors\n  ETH->DMAIER = BIT(6) | BIT(16);                      // RIE, NISE\n  ETH->MACCR = BIT(2) | BIT(3) | BIT(11) | BIT(14);    // RE, TE, Duplex, Fast\n  ETH->DMAOMR = BIT(1) | BIT(13) | BIT(21) | BIT(25);  // SR, ST, TSF, RSF\n\n  // MAC address filtering\n  ETH->MACA0HR = ((uint32_t) ifp->mac[5] << 8U) | ifp->mac[4];\n  ETH->MACA0LR = (uint32_t) (ifp->mac[3] << 24) |\n                 ((uint32_t) ifp->mac[2] << 16) |\n                 ((uint32_t) ifp->mac[1] << 8) | ifp->mac[0];\n  return true;\n}\n\nstatic size_t mg_tcpip_driver_stm32_tx(const void *buf, size_t len,\n                                       struct mg_tcpip_if *ifp) {\n  if (len > sizeof(s_txbuf[s_txno])) {\n    MG_ERROR((\"Frame too big, %ld\", (long) len));\n    len = 0;  // Frame is too big\n  } else if ((s_txdesc[s_txno][0] & BIT(31))) {\n    ifp->nerr++;\n    MG_ERROR((\"No free descriptors\"));\n    // printf(\"D0 %lx SR %lx\\n\", (long) s_txdesc[0][0], (long) ETH->DMASR);\n    len = 0;  // All descriptors are busy, fail\n  } else {\n    memcpy(s_txbuf[s_txno], buf, len);     // Copy data\n    s_txdesc[s_txno][1] = (uint32_t) len;  // Set data len\n    s_txdesc[s_txno][0] = BIT(20) | BIT(28) | BIT(29) | BIT(30);  // Chain,FS,LS\n    s_txdesc[s_txno][0] |= BIT(31);  // Set OWN bit - let DMA take over\n    if (++s_txno >= ETH_DESC_CNT) s_txno = 0;\n  }\n  ETH->DMASR = BIT(2) | BIT(5);  // Clear any prior TBUS/TUS\n  ETH->DMATPDR = 0;              // and resume\n  return len;\n}\n\nstatic bool mg_tcpip_driver_stm32_up(struct mg_tcpip_if *ifp) {\n  uint32_t bsr = eth_read_phy(PHY_ADDR, PHY_BSR);\n  bool up = bsr & BIT(2) ? 1 : 0;\n  if ((ifp->state == MG_TCPIP_STATE_DOWN) && up) {  // link state just went up\n    uint32_t scsr = eth_read_phy(PHY_ADDR, PHY_CSCR);\n    uint32_t maccr = ETH->MACCR | BIT(14) | BIT(11);  // 100M, Full-duplex\n    if ((scsr & BIT(3)) == 0) maccr &= ~BIT(14);      // 10M\n    if ((scsr & BIT(4)) == 0) maccr &= ~BIT(11);      // Half-duplex\n    ETH->MACCR = maccr;  // IRQ handler does not fiddle with this register\n    MG_DEBUG((\"Link is %uM %s-duplex\", maccr & BIT(14) ? 100 : 10,\n              maccr & BIT(11) ? \"full\" : \"half\"));\n  }\n  return up;\n}\n\nvoid ETH_IRQHandler(void);\nvoid ETH_IRQHandler(void) {\n  if (ETH->DMASR & BIT(6)) {             // Frame received, loop\n    ETH->DMASR = BIT(16) | BIT(6);       // Clear flag\n    for (uint32_t i = 0; i < 10; i++) {  // read as they arrive but not forever\n      if (s_rxdesc[s_rxno][0] & BIT(31)) break;  // exit when done\n      if (((s_rxdesc[s_rxno][0] & (BIT(8) | BIT(9))) == (BIT(8) | BIT(9))) &&\n          !(s_rxdesc[s_rxno][0] & BIT(15))) {  // skip partial/errored frames\n        uint32_t len = ((s_rxdesc[s_rxno][0] >> 16) & (BIT(14) - 1));\n        //  printf(\"%lx %lu %lx %.8lx\\n\", s_rxno, len, s_rxdesc[s_rxno][0],\n        //  ETH->DMASR);\n        mg_tcpip_qwrite(s_rxbuf[s_rxno], len > 4 ? len - 4 : len, s_ifp);\n      }\n      s_rxdesc[s_rxno][0] = BIT(31);\n      if (++s_rxno >= ETH_DESC_CNT) s_rxno = 0;\n    }\n  }\n  ETH->DMASR = BIT(7);  // Clear possible RBUS while processing\n  ETH->DMARPDR = 0;     // and resume RX\n}\n\nstruct mg_tcpip_driver mg_tcpip_driver_stm32 = {mg_tcpip_driver_stm32_init,\n                                                mg_tcpip_driver_stm32_tx, NULL,\n                                                mg_tcpip_driver_stm32_up};\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tcpip/driver_stm32h.c\"\n#endif\n\n\n#if MG_ENABLE_TCPIP && defined(MG_ENABLE_DRIVER_STM32H) && \\\n    MG_ENABLE_DRIVER_STM32H\nstruct stm32h_eth {\n  volatile uint32_t MACCR, MACECR, MACPFR, MACWTR, MACHT0R, MACHT1R,\n      RESERVED1[14], MACVTR, RESERVED2, MACVHTR, RESERVED3, MACVIR, MACIVIR,\n      RESERVED4[2], MACTFCR, RESERVED5[7], MACRFCR, RESERVED6[7], MACISR,\n      MACIER, MACRXTXSR, RESERVED7, MACPCSR, MACRWKPFR, RESERVED8[2], MACLCSR,\n      MACLTCR, MACLETR, MAC1USTCR, RESERVED9[12], MACVR, MACDR, RESERVED10,\n      MACHWF0R, MACHWF1R, MACHWF2R, RESERVED11[54], MACMDIOAR, MACMDIODR,\n      RESERVED12[2], MACARPAR, RESERVED13[59], MACA0HR, MACA0LR, MACA1HR,\n      MACA1LR, MACA2HR, MACA2LR, MACA3HR, MACA3LR, RESERVED14[248], MMCCR,\n      MMCRIR, MMCTIR, MMCRIMR, MMCTIMR, RESERVED15[14], MMCTSCGPR, MMCTMCGPR,\n      RESERVED16[5], MMCTPCGR, RESERVED17[10], MMCRCRCEPR, MMCRAEPR,\n      RESERVED18[10], MMCRUPGR, RESERVED19[9], MMCTLPIMSTR, MMCTLPITCR,\n      MMCRLPIMSTR, MMCRLPITCR, RESERVED20[65], MACL3L4C0R, MACL4A0R,\n      RESERVED21[2], MACL3A0R0R, MACL3A1R0R, MACL3A2R0R, MACL3A3R0R,\n      RESERVED22[4], MACL3L4C1R, MACL4A1R, RESERVED23[2], MACL3A0R1R,\n      MACL3A1R1R, MACL3A2R1R, MACL3A3R1R, RESERVED24[108], MACTSCR, MACSSIR,\n      MACSTSR, MACSTNR, MACSTSUR, MACSTNUR, MACTSAR, RESERVED25, MACTSSR,\n      RESERVED26[3], MACTTSSNR, MACTTSSSR, RESERVED27[2], MACACR, RESERVED28,\n      MACATSNR, MACATSSR, MACTSIACR, MACTSEACR, MACTSICNR, MACTSECNR,\n      RESERVED29[4], MACPPSCR, RESERVED30[3], MACPPSTTSR, MACPPSTTNR, MACPPSIR,\n      MACPPSWR, RESERVED31[12], MACPOCR, MACSPI0R, MACSPI1R, MACSPI2R, MACLMIR,\n      RESERVED32[11], MTLOMR, RESERVED33[7], MTLISR, RESERVED34[55], MTLTQOMR,\n      MTLTQUR, MTLTQDR, RESERVED35[8], MTLQICSR, MTLRQOMR, MTLRQMPOCR, MTLRQDR,\n      RESERVED36[177], DMAMR, DMASBMR, DMAISR, DMADSR, RESERVED37[60], DMACCR,\n      DMACTCR, DMACRCR, RESERVED38[2], DMACTDLAR, RESERVED39, DMACRDLAR,\n      DMACTDTPR, RESERVED40, DMACRDTPR, DMACTDRLR, DMACRDRLR, DMACIER,\n      DMACRIWTR, DMACSFCSR, RESERVED41, DMACCATDR, RESERVED42, DMACCARDR,\n      RESERVED43, DMACCATBR, RESERVED44, DMACCARBR, DMACSR, RESERVED45[2],\n      DMACMFCR;\n};\n#undef ETH\n#define ETH \\\n  ((struct stm32h_eth *) (uintptr_t) (0x40000000UL + 0x00020000UL + 0x8000UL))\n\n#undef BIT\n#define BIT(x) ((uint32_t) 1 << (x))\n#define ETH_PKT_SIZE 1540  // Max frame size\n#define ETH_DESC_CNT 4     // Descriptors count\n#define ETH_DS 4           // Descriptor size (words)\n\nstatic volatile uint32_t s_rxdesc[ETH_DESC_CNT][ETH_DS];  // RX descriptors\nstatic volatile uint32_t s_txdesc[ETH_DESC_CNT][ETH_DS];  // TX descriptors\nstatic uint8_t s_rxbuf[ETH_DESC_CNT][ETH_PKT_SIZE];       // RX ethernet buffers\nstatic uint8_t s_txbuf[ETH_DESC_CNT][ETH_PKT_SIZE];       // TX ethernet buffers\nstatic struct mg_tcpip_if *s_ifp;                         // MIP interface\nenum {\n  PHY_ADDR = 0,\n  PHY_BCR = 0,\n  PHY_BSR = 1,\n  PHY_CSCR = 31\n};  // PHY constants\n\nstatic uint32_t eth_read_phy(uint8_t addr, uint8_t reg) {\n  ETH->MACMDIOAR &= (0xF << 8);\n  ETH->MACMDIOAR |= ((uint32_t) addr << 21) | ((uint32_t) reg << 16) | 3 << 2;\n  ETH->MACMDIOAR |= BIT(0);\n  while (ETH->MACMDIOAR & BIT(0)) (void) 0;\n  return ETH->MACMDIODR;\n}\n\nstatic void eth_write_phy(uint8_t addr, uint8_t reg, uint32_t val) {\n  ETH->MACMDIODR = val;\n  ETH->MACMDIOAR &= (0xF << 8);\n  ETH->MACMDIOAR |= ((uint32_t) addr << 21) | ((uint32_t) reg << 16) | 1 << 2;\n  ETH->MACMDIOAR |= BIT(0);\n  while (ETH->MACMDIOAR & BIT(0)) (void) 0;\n}\n\nstatic uint32_t get_hclk(void) {\n  struct rcc {\n    volatile uint32_t CR, HSICFGR, CRRCR, CSICFGR, CFGR, RESERVED1, D1CFGR,\n        D2CFGR, D3CFGR, RESERVED2, PLLCKSELR, PLLCFGR, PLL1DIVR, PLL1FRACR,\n        PLL2DIVR, PLL2FRACR, PLL3DIVR, PLL3FRACR, RESERVED3, D1CCIPR, D2CCIP1R,\n        D2CCIP2R, D3CCIPR, RESERVED4, CIER, CIFR, CICR, RESERVED5, BDCR, CSR,\n        RESERVED6, AHB3RSTR, AHB1RSTR, AHB2RSTR, AHB4RSTR, APB3RSTR, APB1LRSTR,\n        APB1HRSTR, APB2RSTR, APB4RSTR, GCR, RESERVED8, D3AMR, RESERVED11[9],\n        RSR, AHB3ENR, AHB1ENR, AHB2ENR, AHB4ENR, APB3ENR, APB1LENR, APB1HENR,\n        APB2ENR, APB4ENR, RESERVED12, AHB3LPENR, AHB1LPENR, AHB2LPENR,\n        AHB4LPENR, APB3LPENR, APB1LLPENR, APB1HLPENR, APB2LPENR, APB4LPENR,\n        RESERVED13[4];\n  } *rcc = ((struct rcc *) (0x40000000 + 0x18020000 + 0x4400));\n  uint32_t clk = 0, hsi = 64000000 /* 64 MHz */, hse = 8000000 /* 8MHz */,\n           csi = 4000000 /* 4MHz */;\n  unsigned int sel = (rcc->CFGR & (7 << 3)) >> 3;\n\n  if (sel == 1) {\n    clk = csi;\n  } else if (sel == 2) {\n    clk = hse;\n  } else if (sel == 3) {\n    uint32_t vco, m, n, p;\n    unsigned int src = (rcc->PLLCKSELR & (3 << 0)) >> 0;\n    m = ((rcc->PLLCKSELR & (0x3F << 4)) >> 4);\n    n = ((rcc->PLL1DIVR & (0x1FF << 0)) >> 0) + 1 +\n        ((rcc->PLLCFGR & BIT(0)) ? 1 : 0);  // round-up in fractional mode\n    p = ((rcc->PLL1DIVR & (0x7F << 9)) >> 9) + 1;\n    if (src == 1) {\n      clk = csi;\n    } else if (src == 2) {\n      clk = hse;\n    } else {\n      clk = hsi;\n      clk >>= ((rcc->CR & 3) >> 3);\n    }\n    vco = (uint32_t) ((uint64_t) clk * n / m);\n    clk = vco / p;\n  } else {\n    clk = hsi;\n    clk >>= ((rcc->CR & 3) >> 3);\n  }\n  const uint8_t cptab[12] = {1, 2, 3, 4, 6, 7, 8, 9};  // log2(div)\n  uint32_t d1cpre = (rcc->D1CFGR & (0x0F << 8)) >> 8;\n  if (d1cpre >= 8) clk >>= cptab[d1cpre - 8];\n  MG_DEBUG((\"D1 CLK: %u\", clk));\n  uint32_t hpre = (rcc->D1CFGR & (0x0F << 0)) >> 0;\n  if (hpre < 8) return clk;\n  return ((uint32_t) clk) >> cptab[hpre - 8];\n}\n\n//  Guess CR from AHB1 clock. MDC clock is generated from the ETH peripheral\n//  clock (AHB1); as per 802.3, it must not exceed 2. As the AHB clock can\n//  be derived from HSI or CSI (internal RC) clocks, and those can go above\n//  specs, the datasheets specify a range of frequencies and activate one of a\n//  series of dividers to keep the MDC clock safely below 2.5MHz. We guess a\n//  divider setting based on HCLK with some drift. If the user uses a different\n//  clock from our defaults, needs to set the macros on top. Valid for\n//  STM32H74xxx/75xxx (58.11.4)(4.5% worst case drift)(CSI clock has a 7.5 %\n//  worst case drift @ max temp)\nstatic int guess_mdc_cr(void) {\n  const uint8_t crs[] = {2, 3, 0, 1, 4, 5};  // ETH->MACMDIOAR::CR values\n  const uint8_t div[] = {16, 26, 42, 62, 102, 124};  // Respective HCLK dividers\n  uint32_t hclk = get_hclk();                        // Guess system HCLK\n  int result = -1;                                   // Invalid CR value\n  for (int i = 0; i < 6; i++) {\n    if (hclk / div[i] <= 2375000UL /* 2.5MHz - 5% */) {\n      result = crs[i];\n      break;\n    }\n  }\n  if (result < 0) MG_ERROR((\"HCLK too high\"));\n  MG_DEBUG((\"HCLK: %u, CR: %d\", hclk, result));\n  return result;\n}\n\nstatic bool mg_tcpip_driver_stm32h_init(struct mg_tcpip_if *ifp) {\n  struct mg_tcpip_driver_stm32h_data *d =\n      (struct mg_tcpip_driver_stm32h_data *) ifp->driver_data;\n  s_ifp = ifp;\n\n  // Init RX descriptors\n  for (int i = 0; i < ETH_DESC_CNT; i++) {\n    s_rxdesc[i][0] = (uint32_t) (uintptr_t) s_rxbuf[i];  // Point to data buffer\n    s_rxdesc[i][3] = BIT(31) | BIT(30) | BIT(24);        // OWN, IOC, BUF1V\n  }\n\n  // Init TX descriptors\n  for (int i = 0; i < ETH_DESC_CNT; i++) {\n    s_txdesc[i][0] = (uint32_t) (uintptr_t) s_txbuf[i];  // Buf pointer\n  }\n\n  ETH->DMAMR |= BIT(0);                         // Software reset\n  while ((ETH->DMAMR & BIT(0)) != 0) (void) 0;  // Wait until done\n\n  // Set MDC clock divider. If user told us the value, use it. Otherwise, guess\n  int cr = (d == NULL || d->mdc_cr < 0) ? guess_mdc_cr() : d->mdc_cr;\n  ETH->MACMDIOAR = ((uint32_t) cr & 0xF) << 8;\n\n  // NOTE(scaprile): We do not use timing facilities so the DMA engine does not\n  // re-write buffer address\n  ETH->DMAMR = 0 << 16;     // use interrupt mode 0 (58.8.1) (reset value)\n  ETH->DMASBMR |= BIT(12);  // AAL NOTE(scaprile): is this actually needed\n  ETH->MACIER = 0;        // Do not enable additional irq sources (reset value)\n  ETH->MACTFCR = BIT(7);  // Disable zero-quanta pause\n  // ETH->MACPFR = BIT(31);  // Receive all\n  eth_write_phy(PHY_ADDR, PHY_BCR, BIT(15));  // Reset PHY\n  eth_write_phy(PHY_ADDR, PHY_BCR, BIT(12));  // Set autonegotiation\n  ETH->DMACRDLAR =\n      (uint32_t) (uintptr_t) s_rxdesc;  // RX descriptors start address\n  ETH->DMACRDRLR = ETH_DESC_CNT - 1;    // ring length\n  ETH->DMACRDTPR =\n      (uint32_t) (uintptr_t) &s_rxdesc[ETH_DESC_CNT -\n                                       1];  // last valid descriptor address\n  ETH->DMACTDLAR =\n      (uint32_t) (uintptr_t) s_txdesc;  // TX descriptors start address\n  ETH->DMACTDRLR = ETH_DESC_CNT - 1;    // ring length\n  ETH->DMACTDTPR =\n      (uint32_t) (uintptr_t) s_txdesc;  // first available descriptor address\n  ETH->DMACCR = 0;  // DSL = 0 (contiguous descriptor table) (reset value)\n  ETH->DMACIER = BIT(6) | BIT(15);  // RIE, NIE\n  ETH->MACCR = BIT(0) | BIT(1) | BIT(13) | BIT(14) |\n               BIT(15);     // RE, TE, Duplex, Fast, Reserved\n  ETH->MTLTQOMR |= BIT(1);  // TSF\n  ETH->MTLRQOMR |= BIT(5);  // RSF\n  ETH->DMACTCR |= BIT(0);   // ST\n  ETH->DMACRCR |= BIT(0);   // SR\n\n  // MAC address filtering\n  ETH->MACA0HR = ((uint32_t) ifp->mac[5] << 8U) | ifp->mac[4];\n  ETH->MACA0LR = (uint32_t) (ifp->mac[3] << 24) |\n                 ((uint32_t) ifp->mac[2] << 16) |\n                 ((uint32_t) ifp->mac[1] << 8) | ifp->mac[0];\n  return true;\n}\n\nstatic uint32_t s_txno;\nstatic size_t mg_tcpip_driver_stm32h_tx(const void *buf, size_t len,\n                                        struct mg_tcpip_if *ifp) {\n  if (len > sizeof(s_txbuf[s_txno])) {\n    MG_ERROR((\"Frame too big, %ld\", (long) len));\n    len = 0;  // Frame is too big\n  } else if ((s_txdesc[s_txno][3] & BIT(31))) {\n    MG_ERROR((\"No free descriptors: %u %08X %08X %08X\", s_txno,\n              s_txdesc[s_txno][3], ETH->DMACSR, ETH->DMACTCR));\n    for (int i = 0; i < ETH_DESC_CNT; i++) MG_ERROR((\"%08X\", s_txdesc[i][3]));\n    len = 0;  // All descriptors are busy, fail\n  } else {\n    memcpy(s_txbuf[s_txno], buf, len);        // Copy data\n    s_txdesc[s_txno][2] = (uint32_t) len;     // Set data len\n    s_txdesc[s_txno][3] = BIT(28) | BIT(29);  // FD, LD\n    s_txdesc[s_txno][3] |= BIT(31);           // Set OWN bit - let DMA take over\n    if (++s_txno >= ETH_DESC_CNT) s_txno = 0;\n  }\n  ETH->DMACSR |= BIT(2) | BIT(1);  // Clear any prior TBU, TPS\n  ETH->DMACTDTPR = (uint32_t) (uintptr_t) &s_txdesc[s_txno];  // and resume\n  return len;\n  (void) ifp;\n}\n\nstatic bool mg_tcpip_driver_stm32h_up(struct mg_tcpip_if *ifp) {\n  uint32_t bsr = eth_read_phy(PHY_ADDR, PHY_BSR);\n  bool up = bsr & BIT(2) ? 1 : 0;\n  if ((ifp->state == MG_TCPIP_STATE_DOWN) && up) {  // link state just went up\n    uint32_t scsr = eth_read_phy(PHY_ADDR, PHY_CSCR);\n    uint32_t maccr = ETH->MACCR | BIT(14) | BIT(13);  // 100M, Full-duplex\n    if ((scsr & BIT(3)) == 0) maccr &= ~BIT(14);      // 10M\n    if ((scsr & BIT(4)) == 0) maccr &= ~BIT(13);      // Half-duplex\n    ETH->MACCR = maccr;  // IRQ handler does not fiddle with this register\n    MG_DEBUG((\"Link is %uM %s-duplex\", maccr & BIT(14) ? 100 : 10,\n              maccr & BIT(13) ? \"full\" : \"half\"));\n  }\n  return up;\n}\n\nvoid ETH_IRQHandler(void);\nstatic uint32_t s_rxno;\nvoid ETH_IRQHandler(void) {\n  if (ETH->DMACSR & BIT(6)) {            // Frame received, loop\n    ETH->DMACSR = BIT(15) | BIT(6);      // Clear flag\n    for (uint32_t i = 0; i < 10; i++) {  // read as they arrive but not forever\n      if (s_rxdesc[s_rxno][3] & BIT(31)) break;  // exit when done\n      if (((s_rxdesc[s_rxno][3] & (BIT(28) | BIT(29))) ==\n           (BIT(28) | BIT(29))) &&\n          !(s_rxdesc[s_rxno][3] & BIT(15))) {  // skip partial/errored frames\n        uint32_t len = s_rxdesc[s_rxno][3] & (BIT(15) - 1);\n        // MG_DEBUG((\"%lx %lu %lx %08lx\", s_rxno, len, s_rxdesc[s_rxno][3],\n        // ETH->DMACSR));\n        mg_tcpip_qwrite(s_rxbuf[s_rxno], len > 4 ? len - 4 : len, s_ifp);\n      }\n      s_rxdesc[s_rxno][3] = BIT(31) | BIT(30) | BIT(24);  // OWN, IOC, BUF1V\n      if (++s_rxno >= ETH_DESC_CNT) s_rxno = 0;\n    }\n  }\n  ETH->DMACSR = BIT(7) | BIT(8);  // Clear possible RBU RPS while processing\n  ETH->DMACRDTPR =\n      (uint32_t) (uintptr_t) &s_rxdesc[ETH_DESC_CNT - 1];  // and resume RX\n}\n\nstruct mg_tcpip_driver mg_tcpip_driver_stm32h = {\n    mg_tcpip_driver_stm32h_init, mg_tcpip_driver_stm32h_tx, NULL,\n    mg_tcpip_driver_stm32h_up};\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tcpip/driver_tm4c.c\"\n#endif\n\n\n#if MG_ENABLE_TCPIP && defined(MG_ENABLE_DRIVER_TM4C) && MG_ENABLE_DRIVER_TM4C\nstruct tm4c_emac {\n  volatile uint32_t EMACCFG, EMACFRAMEFLTR, EMACHASHTBLH, EMACHASHTBLL,\n      EMACMIIADDR, EMACMIIDATA, EMACFLOWCTL, EMACVLANTG, RESERVED0, EMACSTATUS,\n      EMACRWUFF, EMACPMTCTLSTAT, RESERVED1[2], EMACRIS, EMACIM, EMACADDR0H,\n      EMACADDR0L, EMACADDR1H, EMACADDR1L, EMACADDR2H, EMACADDR2L, EMACADDR3H,\n      EMACADDR3L, RESERVED2[31], EMACWDOGTO, RESERVED3[8], EMACMMCCTRL,\n      EMACMMCRXRIS, EMACMMCTXRIS, EMACMMCRXIM, EMACMMCTXIM, RESERVED4,\n      EMACTXCNTGB, RESERVED5[12], EMACTXCNTSCOL, EMACTXCNTMCOL, RESERVED6[4],\n      EMACTXOCTCNTG, RESERVED7[6], EMACRXCNTGB, RESERVED8[4], EMACRXCNTCRCERR,\n      EMACRXCNTALGNERR, RESERVED9[10], EMACRXCNTGUNI, RESERVED10[239],\n      EMACVLNINCREP, EMACVLANHASH, RESERVED11[93], EMACTIMSTCTRL, EMACSUBSECINC,\n      EMACTIMSEC, EMACTIMNANO, EMACTIMSECU, EMACTIMNANOU, EMACTIMADD,\n      EMACTARGSEC, EMACTARGNANO, EMACHWORDSEC, EMACTIMSTAT, EMACPPSCTRL,\n      RESERVED12[12], EMACPPS0INTVL, EMACPPS0WIDTH, RESERVED13[294],\n      EMACDMABUSMOD, EMACTXPOLLD, EMACRXPOLLD, EMACRXDLADDR, EMACTXDLADDR,\n      EMACDMARIS, EMACDMAOPMODE, EMACDMAIM, EMACMFBOC, EMACRXINTWDT,\n      RESERVED14[8], EMACHOSTXDESC, EMACHOSRXDESC, EMACHOSTXBA, EMACHOSRXBA,\n      RESERVED15[218], EMACPP, EMACPC, EMACCC, RESERVED16, EMACEPHYRIS,\n      EMACEPHYIM, EMACEPHYIMSC;\n};\n#undef EMAC\n#define EMAC ((struct tm4c_emac *) (uintptr_t) 0x400EC000)\n\n#undef BIT\n#define BIT(x) ((uint32_t) 1 << (x))\n#define ETH_PKT_SIZE 1540  // Max frame size\n#define ETH_DESC_CNT 4     // Descriptors count\n#define ETH_DS 4           // Descriptor size (words)\n\nstatic uint32_t s_rxdesc[ETH_DESC_CNT][ETH_DS];      // RX descriptors\nstatic uint32_t s_txdesc[ETH_DESC_CNT][ETH_DS];      // TX descriptors\nstatic uint8_t s_rxbuf[ETH_DESC_CNT][ETH_PKT_SIZE];  // RX ethernet buffers\nstatic uint8_t s_txbuf[ETH_DESC_CNT][ETH_PKT_SIZE];  // TX ethernet buffers\nstatic struct mg_tcpip_if *s_ifp;                    // MIP interface\nenum {\n  EPHY_ADDR = 0,\n  EPHYBMCR = 0,\n  EPHYBMSR = 1,\n  EPHYSTS = 16\n};  // PHY constants\n\nstatic inline void tm4cspin(volatile uint32_t count) {\n  while (count--) (void) 0;\n}\n\nstatic uint32_t emac_read_phy(uint8_t addr, uint8_t reg) {\n  EMAC->EMACMIIADDR &= (0xf << 2);\n  EMAC->EMACMIIADDR |= ((uint32_t) addr << 11) | ((uint32_t) reg << 6);\n  EMAC->EMACMIIADDR |= BIT(0);\n  while (EMAC->EMACMIIADDR & BIT(0)) tm4cspin(1);\n  return EMAC->EMACMIIDATA;\n}\n\nstatic void emac_write_phy(uint8_t addr, uint8_t reg, uint32_t val) {\n  EMAC->EMACMIIDATA = val;\n  EMAC->EMACMIIADDR &= (0xf << 2);\n  EMAC->EMACMIIADDR |= ((uint32_t) addr << 11) | ((uint32_t) reg << 6) | BIT(1);\n  EMAC->EMACMIIADDR |= BIT(0);\n  while (EMAC->EMACMIIADDR & BIT(0)) tm4cspin(1);\n}\n\nstatic uint32_t get_sysclk(void) {\n  struct sysctl {\n    volatile uint32_t DONTCARE0[44], RSCLKCFG, DONTCARE1[43], PLLFREQ0,\n        PLLFREQ1;\n  } *sysctl = (struct sysctl *) 0x400FE000;\n  uint32_t clk = 0, piosc = 16000000 /* 16 MHz */, mosc = 25000000 /* 25MHz */;\n  if (sysctl->RSCLKCFG & (1 << 28)) {  // USEPLL\n    uint32_t fin, vco, mdiv, n, q, psysdiv;\n    uint32_t pllsrc = (sysctl->RSCLKCFG & (0xf << 24)) >> 24;\n    if (pllsrc == 0) {\n      clk = piosc;\n    } else if (pllsrc == 3) {\n      clk = mosc;\n    } else {\n      MG_ERROR((\"Unsupported clock source\"));\n    }\n    q = (sysctl->PLLFREQ1 & (0x1f << 8)) >> 8;\n    n = (sysctl->PLLFREQ1 & (0x1f << 0)) >> 0;\n    fin = clk / ((q + 1) * (n + 1));\n    mdiv = (sysctl->PLLFREQ0 & (0x3ff << 0)) >>\n           0;  // mint + (mfrac / 1024); MFRAC not supported\n    psysdiv = (sysctl->RSCLKCFG & (0x3f << 0)) >> 0;\n    vco = (uint32_t) ((uint64_t) fin * mdiv);\n    return vco / (psysdiv + 1);\n  }\n  uint32_t oscsrc = (sysctl->RSCLKCFG & (0xf << 20)) >> 20;\n  if (oscsrc == 0) {\n    clk = piosc;\n  } else if (oscsrc == 3) {\n    clk = mosc;\n  } else {\n    MG_ERROR((\"Unsupported clock source\"));\n  }\n  uint32_t osysdiv = (sysctl->RSCLKCFG & (0xf << 16)) >> 16;\n  return clk / (osysdiv + 1);\n}\n\n//  Guess CR from SYSCLK. MDC clock is generated from SYSCLK (AHB); as per\n//  802.3, it must not exceed 2.5MHz (also 20.4.2.6) As the AHB clock can be\n//  derived from the PIOSC (internal RC), and it can go above  specs, the\n//  datasheets specify a range of frequencies and activate one of a series of\n//  dividers to keep the MDC clock safely below 2.5MHz. We guess a divider\n//  setting based on SYSCLK with a +5% drift. If the user uses a different clock\n//  from our defaults, needs to set the macros on top Valid for TM4C129x (20.7)\n//  (4.5% worst case drift)\n// The PHY receives the main oscillator (MOSC) (20.3.1)\nstatic int guess_mdc_cr(void) {\n  uint8_t crs[] = {2, 3, 0, 1};      // EMAC->MACMIIAR::CR values\n  uint8_t div[] = {16, 26, 42, 62};  // Respective HCLK dividers\n  uint32_t sysclk = get_sysclk();    // Guess system SYSCLK\n  int result = -1;                   // Invalid CR value\n  if (sysclk < 25000000) {\n    MG_ERROR((\"SYSCLK too low\"));\n  } else {\n    for (int i = 0; i < 4; i++) {\n      if (sysclk / div[i] <= 2375000UL /* 2.5MHz - 5% */) {\n        result = crs[i];\n        break;\n      }\n    }\n    if (result < 0) MG_ERROR((\"SYSCLK too high\"));\n  }\n  MG_DEBUG((\"SYSCLK: %u, CR: %d\", sysclk, result));\n  return result;\n}\n\nstatic bool mg_tcpip_driver_tm4c_init(struct mg_tcpip_if *ifp) {\n  struct mg_tcpip_driver_tm4c_data *d =\n      (struct mg_tcpip_driver_tm4c_data *) ifp->driver_data;\n  s_ifp = ifp;\n\n  // Init RX descriptors\n  for (int i = 0; i < ETH_DESC_CNT; i++) {\n    s_rxdesc[i][0] = BIT(31);                            // Own\n    s_rxdesc[i][1] = sizeof(s_rxbuf[i]) | BIT(14);       // 2nd address chained\n    s_rxdesc[i][2] = (uint32_t) (uintptr_t) s_rxbuf[i];  // Point to data buffer\n    s_rxdesc[i][3] =\n        (uint32_t) (uintptr_t) s_rxdesc[(i + 1) % ETH_DESC_CNT];  // Chain\n    // MG_DEBUG((\"%d %p\", i, s_rxdesc[i]));\n  }\n\n  // Init TX descriptors\n  for (int i = 0; i < ETH_DESC_CNT; i++) {\n    s_txdesc[i][2] = (uint32_t) (uintptr_t) s_txbuf[i];  // Buf pointer\n    s_txdesc[i][3] =\n        (uint32_t) (uintptr_t) s_txdesc[(i + 1) % ETH_DESC_CNT];  // Chain\n  }\n\n  EMAC->EMACDMABUSMOD |= BIT(0);                            // Software reset\n  while ((EMAC->EMACDMABUSMOD & BIT(0)) != 0) tm4cspin(1);  // Wait until done\n\n  // Set MDC clock divider. If user told us the value, use it. Otherwise, guess\n  int cr = (d == NULL || d->mdc_cr < 0) ? guess_mdc_cr() : d->mdc_cr;\n  EMAC->EMACMIIADDR = ((uint32_t) cr & 0xf) << 2;\n\n  // NOTE(cpq): we do not use extended descriptor bit 7, and do not use\n  // hardware checksum. Therefore, descriptor size is 4, not 8\n  // EMAC->EMACDMABUSMOD = BIT(13) | BIT(16) | BIT(22) | BIT(23) | BIT(25);\n  EMAC->EMACIM = BIT(3) | BIT(9);  // Mask timestamp & PMT IT\n  EMAC->EMACFLOWCTL = BIT(7);      // Disable zero-quanta pause\n  // EMAC->EMACFRAMEFLTR = BIT(31);   // Receive all\n  // EMAC->EMACPC defaults to internal PHY (EPHY) in MMI mode\n  emac_write_phy(EPHY_ADDR, EPHYBMCR, BIT(15));  // Reset internal PHY (EPHY)\n  emac_write_phy(EPHY_ADDR, EPHYBMCR, BIT(12));  // Set autonegotiation\n  EMAC->EMACRXDLADDR = (uint32_t) (uintptr_t) s_rxdesc;  // RX descriptors\n  EMAC->EMACTXDLADDR = (uint32_t) (uintptr_t) s_txdesc;  // TX descriptors\n  EMAC->EMACDMAIM = BIT(6) | BIT(16);                    // RIE, NIE\n  EMAC->EMACCFG = BIT(2) | BIT(3) | BIT(11) | BIT(14);   // RE, TE, Duplex, Fast\n  EMAC->EMACDMAOPMODE =\n      BIT(1) | BIT(13) | BIT(21) | BIT(25);  // SR, ST, TSF, RSF\n  EMAC->EMACADDR0H = ((uint32_t) ifp->mac[5] << 8U) | ifp->mac[4];\n  EMAC->EMACADDR0L = (uint32_t) (ifp->mac[3] << 24) |\n                     ((uint32_t) ifp->mac[2] << 16) |\n                     ((uint32_t) ifp->mac[1] << 8) | ifp->mac[0];\n  // NOTE(scaprile) There are 3 additional slots for filtering, disabled by\n  // default. This also applies to the STM32 driver (at least for F7)\n  return true;\n}\n\nstatic uint32_t s_txno;\nstatic size_t mg_tcpip_driver_tm4c_tx(const void *buf, size_t len,\n                                      struct mg_tcpip_if *ifp) {\n  if (len > sizeof(s_txbuf[s_txno])) {\n    MG_ERROR((\"Frame too big, %ld\", (long) len));\n    len = 0;  // fail\n  } else if ((s_txdesc[s_txno][0] & BIT(31))) {\n    MG_ERROR((\"No descriptors available\"));\n    // printf(\"D0 %lx SR %lx\\n\", (long) s_txdesc[0][0], (long)\n    // EMAC->EMACDMARIS);\n    len = 0;  // fail\n  } else {\n    memcpy(s_txbuf[s_txno], buf, len);     // Copy data\n    s_txdesc[s_txno][1] = (uint32_t) len;  // Set data len\n    s_txdesc[s_txno][0] =\n        BIT(20) | BIT(28) | BIT(29) | BIT(30);  // Chain,FS,LS,IC\n    s_txdesc[s_txno][0] |= BIT(31);  // Set OWN bit - let DMA take over\n    if (++s_txno >= ETH_DESC_CNT) s_txno = 0;\n  }\n  EMAC->EMACDMARIS = BIT(2) | BIT(5);  // Clear any prior TU/UNF\n  EMAC->EMACTXPOLLD = 0;               // and resume\n  return len;\n  (void) ifp;\n}\n\nstatic bool mg_tcpip_driver_tm4c_up(struct mg_tcpip_if *ifp) {\n  uint32_t bmsr = emac_read_phy(EPHY_ADDR, EPHYBMSR);\n  bool up = (bmsr & BIT(2)) ? 1 : 0;\n  if ((ifp->state == MG_TCPIP_STATE_DOWN) && up) {  // link state just went up\n    uint32_t sts = emac_read_phy(EPHY_ADDR, EPHYSTS);\n    uint32_t emaccfg = EMAC->EMACCFG | BIT(14) | BIT(11);  // 100M, Full-duplex\n    if (sts & BIT(1)) emaccfg &= ~BIT(14);                 // 10M\n    if ((sts & BIT(2)) == 0) emaccfg &= ~BIT(11);          // Half-duplex\n    EMAC->EMACCFG = emaccfg;  // IRQ handler does not fiddle with this register\n    MG_DEBUG((\"Link is %uM %s-duplex\", emaccfg & BIT(14) ? 100 : 10,\n              emaccfg & BIT(11) ? \"full\" : \"half\"));\n  }\n  return up;\n}\n\nvoid EMAC0_IRQHandler(void);\nstatic uint32_t s_rxno;\nvoid EMAC0_IRQHandler(void) {\n  if (EMAC->EMACDMARIS & BIT(6)) {        // Frame received, loop\n    EMAC->EMACDMARIS = BIT(16) | BIT(6);  // Clear flag\n    for (uint32_t i = 0; i < 10; i++) {   // read as they arrive but not forever\n      if (s_rxdesc[s_rxno][0] & BIT(31)) break;  // exit when done\n      if (((s_rxdesc[s_rxno][0] & (BIT(8) | BIT(9))) == (BIT(8) | BIT(9))) &&\n          !(s_rxdesc[s_rxno][0] & BIT(15))) {  // skip partial/errored frames\n        uint32_t len = ((s_rxdesc[s_rxno][0] >> 16) & (BIT(14) - 1));\n        //  printf(\"%lx %lu %lx %.8lx\\n\", s_rxno, len, s_rxdesc[s_rxno][0],\n        //  EMAC->EMACDMARIS);\n        mg_tcpip_qwrite(s_rxbuf[s_rxno], len > 4 ? len - 4 : len, s_ifp);\n      }\n      s_rxdesc[s_rxno][0] = BIT(31);\n      if (++s_rxno >= ETH_DESC_CNT) s_rxno = 0;\n    }\n  }\n  EMAC->EMACDMARIS = BIT(7);  // Clear possible RU while processing\n  EMAC->EMACRXPOLLD = 0;      // and resume RX\n}\n\nstruct mg_tcpip_driver mg_tcpip_driver_tm4c = {mg_tcpip_driver_tm4c_init,\n                                               mg_tcpip_driver_tm4c_tx, NULL,\n                                               mg_tcpip_driver_tm4c_up};\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tcpip/driver_w5500.c\"\n#endif\n\n\n#if MG_ENABLE_TCPIP\n\nenum { W5500_CR = 0, W5500_S0 = 1, W5500_TX0 = 2, W5500_RX0 = 3 };\n\nstatic void w5500_txn(struct mg_tcpip_spi *s, uint8_t block, uint16_t addr, bool wr,\n                      void *buf, size_t len) {\n  uint8_t *p = (uint8_t *) buf;\n  uint8_t cmd[] = {(uint8_t) (addr >> 8), (uint8_t) (addr & 255),\n                   (uint8_t) ((block << 3) | (wr ? 4 : 0))};\n  s->begin(s->spi);\n  for (size_t i = 0; i < sizeof(cmd); i++) s->txn(s->spi, cmd[i]);\n  for (size_t i = 0; i < len; i++) {\n    uint8_t r = s->txn(s->spi, p[i]);\n    if (!wr) p[i] = r;\n  }\n  s->end(s->spi);\n}\n\n// clang-format off\nstatic  void w5500_wn(struct mg_tcpip_spi *s, uint8_t block, uint16_t addr, void *buf, size_t len) { w5500_txn(s, block, addr, true, buf, len); }\nstatic  void w5500_w1(struct mg_tcpip_spi *s, uint8_t block, uint16_t addr, uint8_t val) { w5500_wn(s, block, addr, &val, 1); }\nstatic  void w5500_w2(struct mg_tcpip_spi *s, uint8_t block, uint16_t addr, uint16_t val) { uint8_t buf[2] = {(uint8_t) (val >> 8), (uint8_t) (val & 255)}; w5500_wn(s, block, addr, buf, sizeof(buf)); }\nstatic  void w5500_rn(struct mg_tcpip_spi *s, uint8_t block, uint16_t addr, void *buf, size_t len) { w5500_txn(s, block, addr, false, buf, len); }\nstatic  uint8_t w5500_r1(struct mg_tcpip_spi *s, uint8_t block, uint16_t addr) { uint8_t r = 0; w5500_rn(s, block, addr, &r, 1); return r; }\nstatic  uint16_t w5500_r2(struct mg_tcpip_spi *s, uint8_t block, uint16_t addr) { uint8_t buf[2] = {0, 0}; w5500_rn(s, block, addr, buf, sizeof(buf)); return (uint16_t) ((buf[0] << 8) | buf[1]); }\n// clang-format on\n\nstatic size_t w5500_rx(void *buf, size_t buflen, struct mg_tcpip_if *ifp) {\n  struct mg_tcpip_spi *s = (struct mg_tcpip_spi *) ifp->driver_data;\n  uint16_t r = 0, n = 0, len = (uint16_t) buflen, n2;     // Read recv len\n  while ((n2 = w5500_r2(s, W5500_S0, 0x26)) > n) n = n2;  // Until it is stable\n  // printf(\"RSR: %d\\n\", (int) n);\n  if (n > 0) {\n    uint16_t ptr = w5500_r2(s, W5500_S0, 0x28);  // Get read pointer\n    n = w5500_r2(s, W5500_RX0, ptr);             // Read frame length\n    if (n <= len + 2 && n > 1) {\n      r = (uint16_t) (n - 2);\n      w5500_rn(s, W5500_RX0, (uint16_t) (ptr + 2), buf, r);\n    }\n    w5500_w2(s, W5500_S0, 0x28, (uint16_t) (ptr + n));  // Advance read pointer\n    w5500_w1(s, W5500_S0, 1, 0x40);                     // Sock0 CR -> RECV\n    // printf(\"  RX_RD: tot=%u n=%u r=%u\\n\", n2, n, r);\n  }\n  return r;\n}\n\nstatic size_t w5500_tx(const void *buf, size_t buflen, struct mg_tcpip_if *ifp) {\n  struct mg_tcpip_spi *s = (struct mg_tcpip_spi *) ifp->driver_data;\n  uint16_t n = 0, len = (uint16_t) buflen;\n  while (n < len) n = w5500_r2(s, W5500_S0, 0x20);      // Wait for space\n  uint16_t ptr = w5500_r2(s, W5500_S0, 0x24);           // Get write pointer\n  w5500_wn(s, W5500_TX0, ptr, (void *) buf, len);       // Write data\n  w5500_w2(s, W5500_S0, 0x24, (uint16_t) (ptr + len));  // Advance write pointer\n  w5500_w1(s, W5500_S0, 1, 0x20);                       // Sock0 CR -> SEND\n  for (int i = 0; i < 40; i++) {\n    uint8_t ir = w5500_r1(s, W5500_S0, 2);  // Read S0 IR\n    if (ir == 0) continue;\n    // printf(\"IR %d, len=%d, free=%d, ptr %d\\n\", ir, (int) len, (int) n, ptr);\n    w5500_w1(s, W5500_S0, 2, ir);  // Write S0 IR: clear it!\n    if (ir & 8) len = 0;           // Timeout. Report error\n    if (ir & (16 | 8)) break;      // Stop on SEND_OK or timeout\n  }\n  return len;\n}\n\nstatic bool w5500_init(struct mg_tcpip_if *ifp) {\n  struct mg_tcpip_spi *s = (struct mg_tcpip_spi *) ifp->driver_data;\n  s->end(s->spi);\n  w5500_w1(s, W5500_CR, 0, 0x80);     // Reset chip: CR -> 0x80\n  w5500_w1(s, W5500_CR, 0x2e, 0);     // CR PHYCFGR -> reset\n  w5500_w1(s, W5500_CR, 0x2e, 0xf8);  // CR PHYCFGR -> set\n  // w5500_wn(s, W5500_CR, 9, s->mac, 6);      // Set source MAC\n  w5500_w1(s, W5500_S0, 0x1e, 16);          // Sock0 RX buf size\n  w5500_w1(s, W5500_S0, 0x1f, 16);          // Sock0 TX buf size\n  w5500_w1(s, W5500_S0, 0, 4);              // Sock0 MR -> MACRAW\n  w5500_w1(s, W5500_S0, 1, 1);              // Sock0 CR -> OPEN\n  return w5500_r1(s, W5500_S0, 3) == 0x42;  // Sock0 SR == MACRAW\n}\n\nstatic bool w5500_up(struct mg_tcpip_if *ifp) {\n  struct mg_tcpip_spi *spi = (struct mg_tcpip_spi *) ifp->driver_data;\n  uint8_t phycfgr = w5500_r1(spi, W5500_CR, 0x2e);\n  return phycfgr & 1;  // Bit 0 of PHYCFGR is LNK (0 - down, 1 - up)\n}\n\nstruct mg_tcpip_driver mg_tcpip_driver_w5500 = {w5500_init, w5500_tx, w5500_rx, w5500_up};\n#endif\n\n#ifdef MG_ENABLE_LINES\n#line 1 \"src/tcpip/tcpip.c\"\n#endif\n\n\n#if MG_ENABLE_TCPIP\n\n#define MG_EPHEMERAL_PORT_BASE 32768\n#define PDIFF(a, b) ((size_t) (((char *) (b)) - ((char *) (a))))\n\n#ifndef MIP_TCP_KEEPALIVE_MS\n#define MIP_TCP_KEEPALIVE_MS 45000  // TCP keep-alive period, ms\n#endif\n\n#define MIP_TCP_ACK_MS 150  // Timeout for ACKing\n\nstruct connstate {\n  uint32_t seq, ack;           // TCP seq/ack counters\n  uint64_t timer;              // TCP keep-alive / ACK timer\n  uint8_t mac[6];              // Peer MAC address\n  uint8_t ttype;               // Timer type. 0: ack, 1: keep-alive\n#define MIP_TTYPE_KEEPALIVE 0  // Connection is idle for long, send keepalive\n#define MIP_TTYPE_ACK 1        // Peer sent us data, we have to ack it soon\n  uint8_t tmiss;               // Number of keep-alive misses\n  struct mg_iobuf raw;         // For TLS only. Incoming raw data\n};\n\n#pragma pack(push, 1)\n\nstruct lcp {\n  uint8_t addr, ctrl, proto[2], code, id, len[2];\n};\n\nstruct eth {\n  uint8_t dst[6];  // Destination MAC address\n  uint8_t src[6];  // Source MAC address\n  uint16_t type;   // Ethernet type\n};\n\nstruct ip {\n  uint8_t ver;    // Version\n  uint8_t tos;    // Unused\n  uint16_t len;   // Length\n  uint16_t id;    // Unused\n  uint16_t frag;  // Fragmentation\n  uint8_t ttl;    // Time to live\n  uint8_t proto;  // Upper level protocol\n  uint16_t csum;  // Checksum\n  uint32_t src;   // Source IP\n  uint32_t dst;   // Destination IP\n};\n\nstruct ip6 {\n  uint8_t ver;      // Version\n  uint8_t opts[3];  // Options\n  uint16_t len;     // Length\n  uint8_t proto;    // Upper level protocol\n  uint8_t ttl;      // Time to live\n  uint8_t src[16];  // Source IP\n  uint8_t dst[16];  // Destination IP\n};\n\nstruct icmp {\n  uint8_t type;\n  uint8_t code;\n  uint16_t csum;\n};\n\nstruct arp {\n  uint16_t fmt;    // Format of hardware address\n  uint16_t pro;    // Format of protocol address\n  uint8_t hlen;    // Length of hardware address\n  uint8_t plen;    // Length of protocol address\n  uint16_t op;     // Operation\n  uint8_t sha[6];  // Sender hardware address\n  uint32_t spa;    // Sender protocol address\n  uint8_t tha[6];  // Target hardware address\n  uint32_t tpa;    // Target protocol address\n};\n\nstruct tcp {\n  uint16_t sport;  // Source port\n  uint16_t dport;  // Destination port\n  uint32_t seq;    // Sequence number\n  uint32_t ack;    // Acknowledgement number\n  uint8_t off;     // Data offset\n  uint8_t flags;   // TCP flags\n#define TH_FIN 0x01\n#define TH_SYN 0x02\n#define TH_RST 0x04\n#define TH_PUSH 0x08\n#define TH_ACK 0x10\n#define TH_URG 0x20\n#define TH_ECE 0x40\n#define TH_CWR 0x80\n  uint16_t win;   // Window\n  uint16_t csum;  // Checksum\n  uint16_t urp;   // Urgent pointer\n};\n\nstruct udp {\n  uint16_t sport;  // Source port\n  uint16_t dport;  // Destination port\n  uint16_t len;    // UDP length\n  uint16_t csum;   // UDP checksum\n};\n\nstruct dhcp {\n  uint8_t op, htype, hlen, hops;\n  uint32_t xid;\n  uint16_t secs, flags;\n  uint32_t ciaddr, yiaddr, siaddr, giaddr;\n  uint8_t hwaddr[208];\n  uint32_t magic;\n  uint8_t options[32];\n};\n\n#pragma pack(pop)\n\nstruct pkt {\n  struct mg_str raw;  // Raw packet data\n  struct mg_str pay;  // Payload data\n  struct eth *eth;\n  struct llc *llc;\n  struct arp *arp;\n  struct ip *ip;\n  struct ip6 *ip6;\n  struct icmp *icmp;\n  struct tcp *tcp;\n  struct udp *udp;\n  struct dhcp *dhcp;\n};\n\nstatic void mkpay(struct pkt *pkt, void *p) {\n  pkt->pay =\n      mg_str_n((char *) p, (size_t) (&pkt->raw.ptr[pkt->raw.len] - (char *) p));\n}\n\nstatic uint32_t csumup(uint32_t sum, const void *buf, size_t len) {\n  const uint8_t *p = (const uint8_t *) buf;\n  for (size_t i = 0; i < len; i++) sum += i & 1 ? p[i] : (uint32_t) (p[i] << 8);\n  return sum;\n}\n\nstatic uint16_t csumfin(uint32_t sum) {\n  while (sum >> 16) sum = (sum & 0xffff) + (sum >> 16);\n  return mg_htons(~sum & 0xffff);\n}\n\nstatic uint16_t ipcsum(const void *buf, size_t len) {\n  uint32_t sum = csumup(0, buf, len);\n  return csumfin(sum);\n}\n\nstatic size_t ether_output(struct mg_tcpip_if *ifp, size_t len) {\n  // size_t min = 64;  // Pad short frames to 64 bytes (minimum Ethernet size)\n  // if (len < min) memset(ifp->tx.ptr + len, 0, min - len), len = min;\n  // mg_hexdump(ifp->tx.ptr, len);\n  size_t n = ifp->driver->tx(ifp->tx.ptr, len, ifp);\n  if (n == len) ifp->nsent++;\n  return n;\n}\n\nstatic void arp_ask(struct mg_tcpip_if *ifp, uint32_t ip) {\n  struct eth *eth = (struct eth *) ifp->tx.ptr;\n  struct arp *arp = (struct arp *) (eth + 1);\n  memset(eth->dst, 255, sizeof(eth->dst));\n  memcpy(eth->src, ifp->mac, sizeof(eth->src));\n  eth->type = mg_htons(0x806);\n  memset(arp, 0, sizeof(*arp));\n  arp->fmt = mg_htons(1), arp->pro = mg_htons(0x800), arp->hlen = 6,\n  arp->plen = 4;\n  arp->op = mg_htons(1), arp->tpa = ip, arp->spa = ifp->ip;\n  memcpy(arp->sha, ifp->mac, sizeof(arp->sha));\n  ether_output(ifp, PDIFF(eth, arp + 1));\n}\n\nstatic void onstatechange(struct mg_tcpip_if *ifp) {\n  if (ifp->state == MG_TCPIP_STATE_READY) {\n    MG_INFO((\"READY, IP: %M\", mg_print_ip4, &ifp->ip));\n    MG_INFO((\"       GW: %M\", mg_print_ip4, &ifp->gw));\n    if (ifp->lease_expire > ifp->now) {\n      MG_INFO(\n          (\"       Lease: %lld sec\", (ifp->lease_expire - ifp->now) / 1000));\n    }\n    arp_ask(ifp, ifp->gw);\n  } else if (ifp->state == MG_TCPIP_STATE_UP) {\n    MG_ERROR((\"Link up\"));\n    srand((unsigned int) mg_millis());\n  } else if (ifp->state == MG_TCPIP_STATE_DOWN) {\n    MG_ERROR((\"Link down\"));\n  }\n}\n\nstatic struct ip *tx_ip(struct mg_tcpip_if *ifp, uint8_t *mac_dst,\n                        uint8_t proto, uint32_t ip_src, uint32_t ip_dst,\n                        size_t plen) {\n  struct eth *eth = (struct eth *) ifp->tx.ptr;\n  struct ip *ip = (struct ip *) (eth + 1);\n  memcpy(eth->dst, mac_dst, sizeof(eth->dst));\n  memcpy(eth->src, ifp->mac, sizeof(eth->src));  // Use our MAC\n  eth->type = mg_htons(0x800);\n  memset(ip, 0, sizeof(*ip));\n  ip->ver = 0x45;   // Version 4, header length 5 words\n  ip->frag = 0x40;  // Don't fragment\n  ip->len = mg_htons((uint16_t) (sizeof(*ip) + plen));\n  ip->ttl = 64;\n  ip->proto = proto;\n  ip->src = ip_src;\n  ip->dst = ip_dst;\n  ip->csum = ipcsum(ip, sizeof(*ip));\n  return ip;\n}\n\nstatic void tx_udp(struct mg_tcpip_if *ifp, uint8_t *mac_dst, uint32_t ip_src,\n                   uint16_t sport, uint32_t ip_dst, uint16_t dport,\n                   const void *buf, size_t len) {\n  struct ip *ip =\n      tx_ip(ifp, mac_dst, 17, ip_src, ip_dst, len + sizeof(struct udp));\n  struct udp *udp = (struct udp *) (ip + 1);\n  // MG_DEBUG((\"UDP XX LEN %d %d\", (int) len, (int) ifp->tx.len));\n  udp->sport = sport;\n  udp->dport = dport;\n  udp->len = mg_htons((uint16_t) (sizeof(*udp) + len));\n  udp->csum = 0;\n  uint32_t cs = csumup(0, udp, sizeof(*udp));\n  cs = csumup(cs, buf, len);\n  cs = csumup(cs, &ip->src, sizeof(ip->src));\n  cs = csumup(cs, &ip->dst, sizeof(ip->dst));\n  cs += (uint32_t) (ip->proto + sizeof(*udp) + len);\n  udp->csum = csumfin(cs);\n  memmove(udp + 1, buf, len);\n  // MG_DEBUG((\"UDP LEN %d %d\", (int) len, (int) ifp->frame_len));\n  ether_output(ifp, sizeof(struct eth) + sizeof(*ip) + sizeof(*udp) + len);\n}\n\nstatic void tx_dhcp(struct mg_tcpip_if *ifp, uint8_t *mac_dst, uint32_t ip_src,\n                    uint32_t ip_dst, uint8_t *opts, size_t optslen) {\n  struct dhcp dhcp = {1, 1, 6, 0, 0, 0, 0, 0, 0, 0, 0, {0}, 0, {0}};\n  dhcp.magic = mg_htonl(0x63825363);\n  memcpy(&dhcp.hwaddr, ifp->mac, sizeof(ifp->mac));\n  memcpy(&dhcp.xid, ifp->mac + 2, sizeof(dhcp.xid));\n  memcpy(&dhcp.options, opts, optslen);\n  tx_udp(ifp, mac_dst, ip_src, mg_htons(68), ip_dst, mg_htons(67), &dhcp,\n         sizeof(dhcp));\n}\n\nstatic void tx_dhcp_request(struct mg_tcpip_if *ifp, uint8_t *mac_dst,\n                            uint32_t ip_src, uint32_t ip_dst) {\n  uint8_t opts[] = {\n      53, 1, 3,                 // Type: DHCP request\n      55, 2, 1,   3,            // GW and mask\n      12, 3, 'm', 'i', 'p',     // Host name: \"mip\"\n      54, 4, 0,   0,   0,   0,  // DHCP server ID\n      50, 4, 0,   0,   0,   0,  // Requested IP\n      255                       // End of options\n  };\n  memcpy(opts + 14, &ip_dst, sizeof(ip_dst));\n  memcpy(opts + 20, &ip_src, sizeof(ip_src));\n  tx_dhcp(ifp, mac_dst, ip_src, ip_dst, opts, sizeof(opts));\n}\n\nstatic void tx_dhcp_discover(struct mg_tcpip_if *ifp) {\n  uint8_t mac[6] = {255, 255, 255, 255, 255, 255};\n  uint8_t opts[] = {\n      53, 1, 1,     // Type: DHCP discover\n      55, 2, 1, 3,  // Parameters: ip, mask\n      255           // End of options\n  };\n  tx_dhcp(ifp, mac, 0, 0xffffffff, opts, sizeof(opts));\n  MG_DEBUG((\"DHCP discover sent\"));\n}\n\nstatic struct mg_connection *getpeer(struct mg_mgr *mgr, struct pkt *pkt,\n                                     bool lsn) {\n  struct mg_connection *c = NULL;\n  for (c = mgr->conns; c != NULL; c = c->next) {\n    if (c->is_udp && pkt->udp && c->loc.port == pkt->udp->dport) break;\n    if (!c->is_udp && pkt->tcp && c->loc.port == pkt->tcp->dport &&\n        lsn == c->is_listening && (lsn || c->rem.port == pkt->tcp->sport))\n      break;\n  }\n  return c;\n}\n\nstatic void rx_arp(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  if (pkt->arp->op == mg_htons(1) && pkt->arp->tpa == ifp->ip) {\n    // ARP request. Make a response, then send\n    // MG_DEBUG((\"ARP op %d %M: %M\", mg_ntohs(pkt->arp->op), mg_print_ip4,\n    //          &pkt->arp->spa, mg_print_ip4, &pkt->arp->tpa));\n    struct eth *eth = (struct eth *) ifp->tx.ptr;\n    struct arp *arp = (struct arp *) (eth + 1);\n    memcpy(eth->dst, pkt->eth->src, sizeof(eth->dst));\n    memcpy(eth->src, ifp->mac, sizeof(eth->src));\n    eth->type = mg_htons(0x806);\n    *arp = *pkt->arp;\n    arp->op = mg_htons(2);\n    memcpy(arp->tha, pkt->arp->sha, sizeof(pkt->arp->tha));\n    memcpy(arp->sha, ifp->mac, sizeof(pkt->arp->sha));\n    arp->tpa = pkt->arp->spa;\n    arp->spa = ifp->ip;\n    MG_DEBUG((\"ARP: tell %M we're %M\", mg_print_ip4, &arp->tpa, mg_print_ip4,\n              &ifp->ip));\n    ether_output(ifp, PDIFF(eth, arp + 1));\n  } else if (pkt->arp->op == mg_htons(2)) {\n    if (memcmp(pkt->arp->tha, ifp->mac, sizeof(pkt->arp->tha)) != 0) return;\n    if (pkt->arp->spa == ifp->gw) {\n      // Got response for the GW ARP request. Set ifp->gwmac\n      memcpy(ifp->gwmac, pkt->arp->sha, sizeof(ifp->gwmac));\n    } else {\n      struct mg_connection *c = getpeer(ifp->mgr, pkt, false);\n      if (c != NULL && c->is_arplooking) {\n        struct connstate *s = (struct connstate *) (c + 1);\n        memcpy(s->mac, pkt->arp->sha, sizeof(s->mac));\n        MG_DEBUG((\"%lu ARP resolved %M -> %M\", c->id, mg_print_ip4, &c->rem.ip,\n                  mg_print_mac, s->mac));\n        c->is_arplooking = 0;\n      }\n    }\n  }\n}\n\nstatic void rx_icmp(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  // MG_DEBUG((\"ICMP %d\", (int) len));\n  if (pkt->icmp->type == 8 && pkt->ip != NULL && pkt->ip->dst == ifp->ip) {\n    size_t hlen = sizeof(struct eth) + sizeof(struct ip) + sizeof(struct icmp);\n    size_t space = ifp->tx.len - hlen, plen = pkt->pay.len;\n    if (plen > space) plen = space;\n    struct ip *ip = tx_ip(ifp, pkt->eth->src, 1, ifp->ip, pkt->ip->src,\n                          sizeof(struct icmp) + plen);\n    struct icmp *icmp = (struct icmp *) (ip + 1);\n    memset(icmp, 0, sizeof(*icmp));        // Set csum to 0\n    memcpy(icmp + 1, pkt->pay.ptr, plen);  // Copy RX payload to TX\n    icmp->csum = ipcsum(icmp, sizeof(*icmp) + plen);\n    ether_output(ifp, hlen + plen);\n  }\n}\n\nstatic void rx_dhcp_client(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  uint32_t ip = 0, gw = 0, mask = 0;\n  uint8_t *p = pkt->dhcp->options,\n          *end = (uint8_t *) &pkt->raw.ptr[pkt->raw.len];\n  if (end < (uint8_t *) (pkt->dhcp + 1)) return;\n  while (p + 1 < end && p[0] != 255) {  // Parse options\n    if (p[0] == 1 && p[1] == sizeof(ifp->mask) && p + 6 < end) {  // Mask\n      memcpy(&mask, p + 2, sizeof(mask));\n    } else if (p[0] == 3 && p[1] == sizeof(ifp->gw) && p + 6 < end) {  // GW\n      memcpy(&gw, p + 2, sizeof(gw));\n      ip = pkt->dhcp->yiaddr;\n    } else if (p[0] == 51 && p[1] == 4 && p + 6 < end) {  // Lease\n      uint32_t lease = 0;\n      memcpy(&lease, p + 2, sizeof(lease));\n      ifp->lease_expire = ifp->now + mg_ntohl(lease) * 1000;\n    }\n    p += p[1] + 2;\n  }\n  if (ip && mask && gw && ifp->ip == 0) {\n    memcpy(ifp->gwmac, pkt->eth->src, sizeof(ifp->gwmac));\n    ifp->ip = ip, ifp->gw = gw, ifp->mask = mask;\n    ifp->state = MG_TCPIP_STATE_READY;\n    onstatechange(ifp);\n    tx_dhcp_request(ifp, pkt->eth->src, ip, pkt->dhcp->siaddr);\n    uint64_t rand;\n    mg_random(&rand, sizeof(rand));\n    srand((unsigned int) (rand + mg_millis()));\n  }\n}\n\n// Simple DHCP server that assigns a next IP address: ifp->ip + 1\nstatic void rx_dhcp_server(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  uint8_t op = 0, *p = pkt->dhcp->options,\n          *end = (uint8_t *) &pkt->raw.ptr[pkt->raw.len];\n  if (end < (uint8_t *) (pkt->dhcp + 1)) return;\n  // struct dhcp *req = pkt->dhcp;\n  struct dhcp res = {2, 1, 6, 0, 0, 0, 0, 0, 0, 0, 0, {0}, 0, {0}};\n  res.yiaddr = ifp->ip;\n  ((uint8_t *) (&res.yiaddr))[3]++;                // Offer our IP + 1\n  while (p + 1 < end && p[0] != 255) {             // Parse options\n    if (p[0] == 53 && p[1] == 1 && p + 2 < end) {  // Message type\n      op = p[2];\n    }\n    p += p[1] + 2;\n  }\n  if (op == 1 || op == 3) {         // DHCP Discover or DHCP Request\n    uint8_t msg = op == 1 ? 2 : 5;  // Message type: DHCP OFFER or DHCP ACK\n    uint8_t opts[] = {\n        53, 1, msg,                 // Message type\n        1,  4, 0,   0,   0,   0,    // Subnet mask\n        54, 4, 0,   0,   0,   0,    // Server ID\n        12, 3, 'm', 'i', 'p',       // Host name: \"mip\"\n        51, 4, 255, 255, 255, 255,  // Lease time\n        255                         // End of options\n    };\n    memcpy(&res.hwaddr, pkt->dhcp->hwaddr, 6);\n    memcpy(opts + 5, &ifp->mask, sizeof(ifp->mask));\n    memcpy(opts + 11, &ifp->ip, sizeof(ifp->ip));\n    memcpy(&res.options, opts, sizeof(opts));\n    res.magic = pkt->dhcp->magic;\n    res.xid = pkt->dhcp->xid;\n    // memcpy(ifp->gwmac, pkt->eth->src, sizeof(ifp->gwmac));\n    tx_udp(ifp, pkt->eth->src, ifp->ip, mg_htons(67),\n           op == 1 ? ~0U : res.yiaddr, mg_htons(68), &res, sizeof(res));\n  }\n}\n\nstatic void rx_udp(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  struct mg_connection *c = getpeer(ifp->mgr, pkt, true);\n  if (c == NULL) {\n    // No UDP listener on this port. Should send ICMP, but keep silent.\n  } else {\n    c->rem.port = pkt->udp->sport;\n    c->rem.ip = pkt->ip->src;\n    struct connstate *s = (struct connstate *) (c + 1);\n    memcpy(s->mac, pkt->eth->src, sizeof(s->mac));\n    if (c->recv.len >= MG_MAX_RECV_SIZE) {\n      mg_error(c, \"max_recv_buf_size reached\");\n    } else if (c->recv.size - c->recv.len < pkt->pay.len &&\n               !mg_iobuf_resize(&c->recv, c->recv.len + pkt->pay.len)) {\n      mg_error(c, \"oom\");\n    } else {\n      memcpy(&c->recv.buf[c->recv.len], pkt->pay.ptr, pkt->pay.len);\n      c->recv.len += pkt->pay.len;\n      mg_call(c, MG_EV_READ, &pkt->pay.len);\n    }\n  }\n}\n\nstatic size_t tx_tcp(struct mg_tcpip_if *ifp, uint8_t *dst_mac, uint32_t dst_ip,\n                     uint8_t flags, uint16_t sport, uint16_t dport,\n                     uint32_t seq, uint32_t ack, const void *buf, size_t len) {\n  struct ip *ip =\n      tx_ip(ifp, dst_mac, 6, ifp->ip, dst_ip, sizeof(struct tcp) + len);\n  struct tcp *tcp = (struct tcp *) (ip + 1);\n  memset(tcp, 0, sizeof(*tcp));\n  if (buf != NULL && len) memmove(tcp + 1, buf, len);\n  tcp->sport = sport;\n  tcp->dport = dport;\n  tcp->seq = seq;\n  tcp->ack = ack;\n  tcp->flags = flags;\n  tcp->win = mg_htons(8192);\n  tcp->off = (uint8_t) (sizeof(*tcp) / 4 << 4);\n  uint32_t cs = 0;\n  uint16_t n = (uint16_t) (sizeof(*tcp) + len);\n  uint8_t pseudo[] = {0, ip->proto, (uint8_t) (n >> 8), (uint8_t) (n & 255)};\n  cs = csumup(cs, tcp, n);\n  cs = csumup(cs, &ip->src, sizeof(ip->src));\n  cs = csumup(cs, &ip->dst, sizeof(ip->dst));\n  cs = csumup(cs, pseudo, sizeof(pseudo));\n  tcp->csum = csumfin(cs);\n  MG_DEBUG((\"TCP %M:%hu -> %M:%hu fl %x len %u\", mg_print_ip4, &ip->src,\n            mg_ntohs(tcp->sport), mg_print_ip4, &ip->dst, mg_ntohs(tcp->dport),\n            tcp->flags, (int) len));\n  return ether_output(ifp, PDIFF(ifp->tx.ptr, tcp + 1) + len);\n}\n\nstatic size_t tx_tcp_pkt(struct mg_tcpip_if *ifp, struct pkt *pkt,\n                         uint8_t flags, uint32_t seq, const void *buf,\n                         size_t len) {\n  uint32_t delta = (pkt->tcp->flags & (TH_SYN | TH_FIN)) ? 1 : 0;\n  return tx_tcp(ifp, pkt->eth->src, pkt->ip->src, flags, pkt->tcp->dport,\n                pkt->tcp->sport, seq, mg_htonl(mg_ntohl(pkt->tcp->seq) + delta),\n                buf, len);\n}\n\nstatic void settmout(struct mg_connection *c, uint8_t type) {\n  struct mg_tcpip_if *ifp = (struct mg_tcpip_if *) c->mgr->priv;\n  struct connstate *s = (struct connstate *) (c + 1);\n  unsigned n = type == MIP_TTYPE_ACK ? MIP_TCP_ACK_MS : MIP_TCP_KEEPALIVE_MS;\n  s->timer = ifp->now + n;\n  s->ttype = type;\n  MG_VERBOSE((\"%lu %d -> %llx\", c->id, type, s->timer));\n}\n\nstatic struct mg_connection *accept_conn(struct mg_connection *lsn,\n                                         struct pkt *pkt) {\n  struct mg_connection *c = mg_alloc_conn(lsn->mgr);\n  if (c == NULL) {\n    MG_ERROR((\"OOM\"));\n    return NULL;\n  }\n  struct connstate *s = (struct connstate *) (c + 1);\n  s->seq = mg_ntohl(pkt->tcp->ack), s->ack = mg_ntohl(pkt->tcp->seq);\n  memcpy(s->mac, pkt->eth->src, sizeof(s->mac));\n  settmout(c, MIP_TTYPE_KEEPALIVE);\n  c->rem.ip = pkt->ip->src;\n  c->rem.port = pkt->tcp->sport;\n  MG_DEBUG((\"%lu accepted %M\", c->id, mg_print_ip_port, &c->rem));\n  LIST_ADD_HEAD(struct mg_connection, &lsn->mgr->conns, c);\n  c->is_accepted = 1;\n  c->is_hexdumping = lsn->is_hexdumping;\n  c->pfn = lsn->pfn;\n  c->loc = lsn->loc;\n  c->pfn_data = lsn->pfn_data;\n  c->fn = lsn->fn;\n  c->fn_data = lsn->fn_data;\n  mg_call(c, MG_EV_OPEN, NULL);\n  mg_call(c, MG_EV_ACCEPT, NULL);\n  return c;\n}\n\nlong mg_io_send(struct mg_connection *c, const void *buf, size_t len) {\n  struct mg_tcpip_if *ifp = (struct mg_tcpip_if *) c->mgr->priv;\n  struct connstate *s = (struct connstate *) (c + 1);\n  if (c->is_udp) {\n    size_t max_headers_len = 14 + 24 /* max IP */ + 8 /* UDP */;\n    if (len + max_headers_len > ifp->tx.len) len = ifp->tx.len - max_headers_len;\n    tx_udp(ifp, s->mac, ifp->ip, c->loc.port, c->rem.ip, c->rem.port, buf, len);\n  } else {\n    size_t max_headers_len = 14 + 24 /* max IP */ + 60 /* max TCP */;\n    if (len + max_headers_len > ifp->tx.len) len = ifp->tx.len - max_headers_len;\n    if (tx_tcp(ifp, s->mac, c->rem.ip, TH_PUSH | TH_ACK, c->loc.port, c->rem.port,\n               mg_htonl(s->seq), mg_htonl(s->ack), buf, len) > 0) {\n      s->seq += (uint32_t) len;\n      if (s->ttype == MIP_TTYPE_ACK) settmout(c, MIP_TTYPE_KEEPALIVE);\n    } else {\n      return MG_IO_ERR;\n    }\n  }\n  return (long) len;\n}\n\nlong mg_io_recv(struct mg_connection *c, void *buf, size_t len) {\n  struct connstate *s = (struct connstate *) (c + 1);\n  if (s->raw.len == 0) return MG_IO_WAIT;\n  if (len > s->raw.len) len = s->raw.len;\n  memcpy(buf, s->raw.buf, len);\n  mg_iobuf_del(&s->raw, 0, len);\n  MG_DEBUG((\"%lu\", len));\n  return (long) len;\n}\n\nstatic void read_conn(struct mg_connection *c, struct pkt *pkt) {\n  struct connstate *s = (struct connstate *) (c + 1);\n  struct mg_iobuf *io = c->is_tls ? &s->raw : &c->recv;\n  uint32_t seq = mg_ntohl(pkt->tcp->seq);\n  s->raw.align = c->recv.align;\n  if (pkt->tcp->flags & TH_FIN) {\n    s->ack = mg_htonl(pkt->tcp->seq) + 1, s->seq = mg_htonl(pkt->tcp->ack);\n    c->is_closing = 1;\n  } else if (pkt->pay.len == 0) {\n    // TODO(cpq): handle this peer's ACK\n  } else if (seq != s->ack) {\n    uint32_t ack = (uint32_t) (mg_htonl(pkt->tcp->seq) + pkt->pay.len);\n    if (s->ack == ack) {\n      MG_VERBOSE((\"ignoring duplicate pkt\"));\n    } else {\n      // TODO(cpq): peer sent us SEQ which we don't expect. Retransmit rather\n      // than close this connection\n      mg_error(c, \"SEQ != ACK: %x %x %x\", seq, s->ack, ack);\n    }\n  } else if (io->size - io->len < pkt->pay.len &&\n             !mg_iobuf_resize(io, io->len + pkt->pay.len)) {\n    mg_error(c, \"oom\");\n  } else {\n    // Copy TCP payload into the IO buffer. If the connection is plain text, we\n    // copy to c->recv. If the connection is TLS, this data is encrypted,\n    // therefore we copy that encrypted data to the s->raw iobuffer instead,\n    // and then call mg_tls_recv() to decrypt it. NOTE: mg_tls_recv() will\n    // call back mg_io_recv() which grabs raw data from s->raw\n    memcpy(&io->buf[io->len], pkt->pay.ptr, pkt->pay.len);\n    io->len += pkt->pay.len;\n\n    MG_DEBUG((\"%lu SEQ %x -> %x\", c->id, mg_htonl(pkt->tcp->seq), s->ack));\n    // Advance ACK counter\n    s->ack = (uint32_t) (mg_htonl(pkt->tcp->seq) + pkt->pay.len);\n#if 0\n    // Send ACK immediately\n    MG_DEBUG((\"  imm ACK\", c->id, mg_htonl(pkt->tcp->seq), s->ack));\n    tx_tcp((struct mg_tcpip_if *) c->mgr->priv, c->rem.ip, TH_ACK, c->loc.port,\n           c->rem.port, mg_htonl(s->seq), mg_htonl(s->ack), \"\", 0);\n#else\n    // if not already running, setup a timer to send an ACK later\n    if (s->ttype != MIP_TTYPE_ACK) settmout(c, MIP_TTYPE_ACK);\n#endif\n\n    if (c->is_tls) {\n      // TLS connection. Make room for decrypted data in c->recv\n      io = &c->recv;\n      if (io->size - io->len < pkt->pay.len &&\n          !mg_iobuf_resize(io, io->len + pkt->pay.len)) {\n        mg_error(c, \"oom\");\n      } else {\n        // Decrypt data directly into c->recv\n        long n = mg_tls_recv(c, &io->buf[io->len], io->size - io->len);\n        if (n == MG_IO_ERR) {\n          mg_error(c, \"TLS recv error\");\n        } else if (n > 0) {\n          // Decrypted successfully - trigger MG_EV_READ\n          io->len += (size_t) n;\n          mg_call(c, MG_EV_READ, &n);\n        }\n      }\n    } else {\n      // Plain text connection, data is already in c->recv, trigger MG_EV_READ\n      mg_call(c, MG_EV_READ, &pkt->pay.len);\n    }\n  }\n}\n\nstatic void rx_tcp(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  struct mg_connection *c = getpeer(ifp->mgr, pkt, false);\n  struct connstate *s = c == NULL ? NULL : (struct connstate *) (c + 1);\n#if 0\n  MG_INFO((\"%lu %hhu %d\", c ? c->id : 0, pkt->tcp->flags, (int) pkt->pay.len));\n#endif\n  if (c != NULL && c->is_connecting && pkt->tcp->flags & (TH_SYN | TH_ACK)) {\n    s->seq = mg_ntohl(pkt->tcp->ack), s->ack = mg_ntohl(pkt->tcp->seq) + 1;\n    tx_tcp_pkt(ifp, pkt, TH_ACK, pkt->tcp->ack, NULL, 0);\n    c->is_connecting = 0;  // Client connected\n    settmout(c, MIP_TTYPE_KEEPALIVE);\n    mg_call(c, MG_EV_CONNECT, NULL);  // Let user know\n  } else if (c != NULL && c->is_connecting) {\n    tx_tcp_pkt(ifp, pkt, TH_RST | TH_ACK, pkt->tcp->ack, NULL, 0);\n  } else if (c != NULL && pkt->tcp->flags & TH_RST) {\n    mg_error(c, \"peer RST\");  // RFC-1122 4.2.2.13\n  } else if (c != NULL) {\n#if 0\n    MG_DEBUG((\"%lu %d %M:%hu -> %M:%hu\", c->id, (int) pkt->raw.len,\n              mg_print_ip4, &pkt->ip->src, mg_ntohs(pkt->tcp->sport),\n              mg_print_ip4, &pkt->ip->dst, mg_ntohs(pkt->tcp->dport)));\n    mg_hexdump(pkt->pay.buf, pkt->pay.len);\n#endif\n    s->tmiss = 0;                         // Reset missed keep-alive counter\n    if (s->ttype == MIP_TTYPE_KEEPALIVE)  // Advance keep-alive timer\n      settmout(c,\n               MIP_TTYPE_KEEPALIVE);  // unless a former ACK timeout is pending\n    read_conn(c, pkt);  // Override timer with ACK timeout if needed\n  } else if ((c = getpeer(ifp->mgr, pkt, true)) == NULL) {\n    tx_tcp_pkt(ifp, pkt, TH_RST | TH_ACK, pkt->tcp->ack, NULL, 0);\n  } else if (pkt->tcp->flags & TH_RST) {\n    if (c->is_accepted) mg_error(c, \"peer RST\");  // RFC-1122 4.2.2.13\n    // ignore RST if not connected\n  } else if (pkt->tcp->flags & TH_SYN) {\n    // Use peer's source port as ISN, in order to recognise the handshake\n    uint32_t isn = mg_htonl((uint32_t) mg_ntohs(pkt->tcp->sport));\n    tx_tcp_pkt(ifp, pkt, TH_SYN | TH_ACK, isn, NULL, 0);\n  } else if (pkt->tcp->flags & TH_FIN) {\n    tx_tcp_pkt(ifp, pkt, TH_FIN | TH_ACK, pkt->tcp->ack, NULL, 0);\n  } else if (mg_htonl(pkt->tcp->ack) == mg_htons(pkt->tcp->sport) + 1U) {\n    accept_conn(c, pkt);\n  } else if (!c->is_accepted) {  // no peer\n    tx_tcp_pkt(ifp, pkt, TH_RST | TH_ACK, pkt->tcp->ack, NULL, 0);\n  } else {\n    // MG_DEBUG((\"dropped silently..\"));\n  }\n}\n\nstatic void rx_ip(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  if (pkt->ip->proto == 1) {\n    pkt->icmp = (struct icmp *) (pkt->ip + 1);\n    if (pkt->pay.len < sizeof(*pkt->icmp)) return;\n    mkpay(pkt, pkt->icmp + 1);\n    rx_icmp(ifp, pkt);\n  } else if (pkt->ip->proto == 17) {\n    pkt->udp = (struct udp *) (pkt->ip + 1);\n    if (pkt->pay.len < sizeof(*pkt->udp)) return;\n    mkpay(pkt, pkt->udp + 1);\n    MG_DEBUG((\"UDP %M:%hu -> %M:%hu len %u\", mg_print_ip4, &pkt->ip->src,\n              mg_ntohs(pkt->udp->sport), mg_print_ip4, &pkt->ip->dst,\n              mg_ntohs(pkt->udp->dport), (int) pkt->pay.len));\n    if (pkt->udp->dport == mg_htons(68)) {\n      pkt->dhcp = (struct dhcp *) (pkt->udp + 1);\n      mkpay(pkt, pkt->dhcp + 1);\n      rx_dhcp_client(ifp, pkt);\n    } else if (ifp->enable_dhcp_server && pkt->udp->dport == mg_htons(67)) {\n      pkt->dhcp = (struct dhcp *) (pkt->udp + 1);\n      mkpay(pkt, pkt->dhcp + 1);\n      rx_dhcp_server(ifp, pkt);\n    } else {\n      rx_udp(ifp, pkt);\n    }\n  } else if (pkt->ip->proto == 6) {\n    pkt->tcp = (struct tcp *) (pkt->ip + 1);\n    if (pkt->pay.len < sizeof(*pkt->tcp)) return;\n    mkpay(pkt, pkt->tcp + 1);\n    uint16_t iplen = mg_ntohs(pkt->ip->len);\n    uint16_t off = (uint16_t) (sizeof(*pkt->ip) + ((pkt->tcp->off >> 4) * 4U));\n    if (iplen >= off) pkt->pay.len = (size_t) (iplen - off);\n    MG_DEBUG((\"TCP %M:%hu -> %M:%hu len %u\", mg_print_ip4, &pkt->ip->src,\n              mg_ntohs(pkt->tcp->sport), mg_print_ip4, &pkt->ip->dst,\n              mg_ntohs(pkt->tcp->dport), (int) pkt->pay.len));\n    rx_tcp(ifp, pkt);\n  }\n}\n\nstatic void rx_ip6(struct mg_tcpip_if *ifp, struct pkt *pkt) {\n  // MG_DEBUG((\"IP %d\", (int) len));\n  if (pkt->ip6->proto == 1 || pkt->ip6->proto == 58) {\n    pkt->icmp = (struct icmp *) (pkt->ip6 + 1);\n    if (pkt->pay.len < sizeof(*pkt->icmp)) return;\n    mkpay(pkt, pkt->icmp + 1);\n    rx_icmp(ifp, pkt);\n  } else if (pkt->ip6->proto == 17) {\n    pkt->udp = (struct udp *) (pkt->ip6 + 1);\n    if (pkt->pay.len < sizeof(*pkt->udp)) return;\n    // MG_DEBUG((\"  UDP %u %u -> %u\", len, mg_htons(udp->sport),\n    // mg_htons(udp->dport)));\n    mkpay(pkt, pkt->udp + 1);\n  }\n}\n\nstatic void mg_tcpip_rx(struct mg_tcpip_if *ifp, void *buf, size_t len) {\n  const uint8_t broadcast[] = {255, 255, 255, 255, 255, 255};\n  struct pkt pkt;\n  memset(&pkt, 0, sizeof(pkt));\n  pkt.raw.ptr = (char *) buf;\n  pkt.raw.len = len;\n  pkt.eth = (struct eth *) buf;\n  if (pkt.raw.len < sizeof(*pkt.eth)) return;  // Truncated - runt?\n  if (ifp->enable_mac_check &&\n      memcmp(pkt.eth->dst, ifp->mac, sizeof(pkt.eth->dst)) != 0 &&\n      memcmp(pkt.eth->dst, broadcast, sizeof(pkt.eth->dst)) != 0)\n    return;\n  if (ifp->enable_crc32_check && len > 4) {\n    len -= 4;  // TODO(scaprile): check on bigendian\n    uint32_t crc = mg_crc32(0, (const char *) buf, len);\n    if (memcmp((void *) ((size_t) buf + len), &crc, sizeof(crc))) return;\n  }\n  if (pkt.eth->type == mg_htons(0x806)) {\n    pkt.arp = (struct arp *) (pkt.eth + 1);\n    if (sizeof(*pkt.eth) + sizeof(*pkt.arp) > pkt.raw.len) return;  // Truncated\n    rx_arp(ifp, &pkt);\n  } else if (pkt.eth->type == mg_htons(0x86dd)) {\n    pkt.ip6 = (struct ip6 *) (pkt.eth + 1);\n    if (pkt.raw.len < sizeof(*pkt.eth) + sizeof(*pkt.ip6)) return;  // Truncated\n    if ((pkt.ip6->ver >> 4) != 0x6) return;                         // Not IP\n    mkpay(&pkt, pkt.ip6 + 1);\n    rx_ip6(ifp, &pkt);\n  } else if (pkt.eth->type == mg_htons(0x800)) {\n    pkt.ip = (struct ip *) (pkt.eth + 1);\n    if (pkt.raw.len < sizeof(*pkt.eth) + sizeof(*pkt.ip)) return;  // Truncated\n    // Truncate frame to what IP header tells us\n    if ((size_t) mg_ntohs(pkt.ip->len) + sizeof(struct eth) < pkt.raw.len) {\n      pkt.raw.len = (size_t) mg_ntohs(pkt.ip->len) + sizeof(struct eth);\n    }\n    if (pkt.raw.len < sizeof(*pkt.eth) + sizeof(*pkt.ip)) return;  // Truncated\n    if ((pkt.ip->ver >> 4) != 4) return;                           // Not IP\n    mkpay(&pkt, pkt.ip + 1);\n    rx_ip(ifp, &pkt);\n  } else {\n    MG_DEBUG((\"  Unknown eth type %x\", mg_htons(pkt.eth->type)));\n    mg_hexdump(buf, len >= 16 ? 16 : len);\n  }\n}\n\nstatic void mg_tcpip_poll(struct mg_tcpip_if *ifp, uint64_t uptime_ms) {\n  if (ifp == NULL || ifp->driver == NULL) return;\n  bool expired_1000ms = mg_timer_expired(&ifp->timer_1000ms, 1000, uptime_ms);\n  ifp->now = uptime_ms;\n\n  // Handle physical interface up/down status\n  if (expired_1000ms && ifp->driver->up) {\n    bool up = ifp->driver->up(ifp);\n    bool current = ifp->state != MG_TCPIP_STATE_DOWN;\n    if (up != current) {\n      ifp->state = up == false               ? MG_TCPIP_STATE_DOWN\n                   : ifp->enable_dhcp_client ? MG_TCPIP_STATE_UP\n                                             : MG_TCPIP_STATE_READY;\n      if (!up && ifp->enable_dhcp_client) ifp->ip = 0;\n      onstatechange(ifp);\n    }\n  }\n  if (ifp->state == MG_TCPIP_STATE_DOWN) return;\n\n  // If IP not configured, send DHCP\n  if (ifp->ip == 0 && expired_1000ms) tx_dhcp_discover(ifp);\n\n  // Read data from the network\n  if (ifp->driver->rx != NULL) {  // Polling driver. We must call it\n    size_t len =\n        ifp->driver->rx(ifp->recv_queue.buf, ifp->recv_queue.size, ifp);\n    if (len > 0) mg_tcpip_rx(ifp, ifp->recv_queue.buf, len);\n  } else {  // Interrupt-based driver. Fills recv queue itself\n    char *buf;\n    size_t len = mg_queue_next(&ifp->recv_queue, &buf);\n    if (len > 0) {\n      mg_tcpip_rx(ifp, buf, len);\n      mg_queue_del(&ifp->recv_queue, len);\n    }\n  }\n\n  // Process timeouts\n  for (struct mg_connection *c = ifp->mgr->conns; c != NULL; c = c->next) {\n    if (c->is_udp || c->is_listening) continue;\n    if (c->is_connecting || c->is_resolving) continue;\n    struct connstate *s = (struct connstate *) (c + 1);\n    if (uptime_ms > s->timer) {\n      if (s->ttype == MIP_TTYPE_ACK) {\n        MG_DEBUG((\"%lu ack %x %x\", c->id, s->seq, s->ack));\n        tx_tcp(ifp, s->mac, c->rem.ip, TH_ACK, c->loc.port, c->rem.port,\n               mg_htonl(s->seq), mg_htonl(s->ack), \"\", 0);\n      } else {\n        if (s->tmiss++ > 2) {\n          mg_error(c, \"keepalive\");\n        } else {\n          MG_DEBUG((\"%lu keepalive\", c->id));\n          tx_tcp(ifp, s->mac, c->rem.ip, TH_ACK, c->loc.port, c->rem.port,\n                 mg_htonl(s->seq - 1), mg_htonl(s->ack), \"\", 0);\n        }\n      }\n      settmout(c, MIP_TTYPE_KEEPALIVE);\n    }\n  }\n}\n\n// This function executes in interrupt context, thus it should copy data\n// somewhere fast. Note that newlib's malloc is not thread safe, thus use\n// our lock-free queue with preallocated buffer to copy data and return asap\nvoid mg_tcpip_qwrite(void *buf, size_t len, struct mg_tcpip_if *ifp) {\n  char *p;\n  if (mg_queue_book(&ifp->recv_queue, &p, len) >= len) {\n    memcpy(p, buf, len);\n    mg_queue_add(&ifp->recv_queue, len);\n    ifp->nrecv++;\n  } else {\n    ifp->ndrop++;\n  }\n}\n\nvoid mg_tcpip_init(struct mg_mgr *mgr, struct mg_tcpip_if *ifp) {\n  // If MAC address is not set, make a random one\n  if (ifp->mac[0] == 0 && ifp->mac[1] == 0 && ifp->mac[2] == 0 &&\n      ifp->mac[3] == 0 && ifp->mac[4] == 0 && ifp->mac[5] == 0) {\n    ifp->mac[0] = 0x02;  // Locally administered, unicast\n    mg_random(&ifp->mac[1], sizeof(ifp->mac) - 1);\n    MG_INFO((\"MAC not set. Generated random: %M\", mg_print_mac, ifp->mac));\n  }\n\n  if (ifp->driver->init && !ifp->driver->init(ifp)) {\n    MG_ERROR((\"driver init failed\"));\n  } else {\n    size_t framesize = 1540;\n    ifp->tx.ptr = (char *) calloc(1, framesize), ifp->tx.len = framesize;\n    if (ifp->recv_queue.size == 0)\n      ifp->recv_queue.size = ifp->driver->rx ? framesize : 8192;\n    ifp->recv_queue.buf = (char *) calloc(1, ifp->recv_queue.size);\n    ifp->timer_1000ms = mg_millis();\n    mgr->priv = ifp;\n    ifp->mgr = mgr;\n    mgr->extraconnsize = sizeof(struct connstate);\n    if (ifp->ip == 0) ifp->enable_dhcp_client = true;\n    memset(ifp->gwmac, 255, sizeof(ifp->gwmac));  // Set to broadcast\n    mg_random(&ifp->eport, sizeof(ifp->eport));   // Random from 0 to 65535\n    ifp->eport |=\n        MG_EPHEMERAL_PORT_BASE;  // Random from MG_EPHEMERAL_PORT_BASE to 65535\n    if (ifp->tx.ptr == NULL || ifp->recv_queue.buf == NULL) MG_ERROR((\"OOM\"));\n  }\n}\n\nvoid mg_tcpip_free(struct mg_tcpip_if *ifp) {\n  free(ifp->recv_queue.buf);\n  free((char *) ifp->tx.ptr);\n}\n\nint mg_mkpipe(struct mg_mgr *m, mg_event_handler_t fn, void *d, bool udp) {\n  (void) m, (void) fn, (void) d, (void) udp;\n  MG_ERROR((\"Not implemented\"));\n  return -1;\n}\n\nstatic void send_syn(struct mg_connection *c) {\n  struct connstate *s = (struct connstate *) (c + 1);\n  uint32_t isn = mg_htonl((uint32_t) mg_ntohs(c->loc.port));\n  struct mg_tcpip_if *ifp = (struct mg_tcpip_if *) c->mgr->priv;\n  tx_tcp(ifp, s->mac, c->rem.ip, TH_SYN, c->loc.port, c->rem.port, isn, 0, NULL,\n         0);\n}\n\nvoid mg_connect_resolved(struct mg_connection *c) {\n  struct mg_tcpip_if *ifp = (struct mg_tcpip_if *) c->mgr->priv;\n  c->is_resolving = 0;\n  if (ifp->eport < MG_EPHEMERAL_PORT_BASE) ifp->eport = MG_EPHEMERAL_PORT_BASE;\n  c->loc.ip = ifp->ip;\n  c->loc.port = mg_htons(ifp->eport++);\n  MG_DEBUG((\"%lu %M -> %M\", c->id, mg_print_ip_port, &c->loc, mg_print_ip_port,\n            &c->rem));\n  mg_call(c, MG_EV_RESOLVE, NULL);\n  if (((c->rem.ip & ifp->mask) == (ifp->ip & ifp->mask))) {\n    // If we're in the same LAN, fire an ARP lookup. TODO(cpq): handle this!\n    MG_DEBUG((\"%lu ARP lookup...\", c->id));\n    arp_ask(ifp, c->rem.ip);\n    c->is_arplooking = 1;\n  } else if (c->rem.ip == (ifp->ip | ~ifp->mask)) {\n    struct connstate *s = (struct connstate *) (c + 1);\n    memset(s->mac, 0xFF, sizeof(s->mac));  // local broadcast\n  } else if ((*((uint8_t *) &c->rem.ip) & 0xE0) == 0xE0) {\n    struct connstate *s = (struct connstate *) (c + 1);  // 224 to 239, E0 to EF\n    uint8_t mcastp[3] = {0x01, 0x00, 0x5E};              // multicast group\n    memcpy(s->mac, mcastp, 3);\n    memcpy(s->mac + 3, ((uint8_t *) &c->rem.ip) + 1, 3);  // 23 LSb\n    s->mac[3] &= 0x7F;\n  } else {\n    struct connstate *s = (struct connstate *) (c + 1);\n    memcpy(s->mac, ifp->gwmac, sizeof(ifp->gwmac));\n    if (c->is_udp) {\n      mg_call(c, MG_EV_CONNECT, NULL);\n    } else {\n      send_syn(c);\n      c->is_connecting = 1;\n    }\n  }\n}\n\nbool mg_open_listener(struct mg_connection *c, const char *url) {\n  c->loc.port = mg_htons(mg_url_port(url));\n  return true;\n}\n\nstatic void write_conn(struct mg_connection *c) {\n  long len = c->is_tls ? mg_tls_send(c, c->send.buf, c->send.len)\n                       : mg_io_send(c, c->send.buf, c->send.len);\n  if (len > 0) {\n    mg_iobuf_del(&c->send, 0, (size_t) len);\n    mg_call(c, MG_EV_WRITE, &len);\n  }\n}\n\nstatic void close_conn(struct mg_connection *c) {\n  struct connstate *s = (struct connstate *) (c + 1);\n  mg_iobuf_free(&s->raw);  // For TLS connections, release raw data\n  if (c->is_udp == false && c->is_listening == false) {  // For TCP conns,\n    struct mg_tcpip_if *ifp =\n        (struct mg_tcpip_if *) c->mgr->priv;  // send TCP FIN\n    tx_tcp(ifp, s->mac, c->rem.ip, TH_FIN | TH_ACK, c->loc.port, c->rem.port,\n           mg_htonl(s->seq), mg_htonl(s->ack), NULL, 0);\n  }\n  mg_close_conn(c);\n}\n\nstatic bool can_write(struct mg_connection *c) {\n  return c->is_connecting == 0 && c->is_resolving == 0 && c->send.len > 0 &&\n         c->is_tls_hs == 0 && c->is_arplooking == 0;\n}\n\nvoid mg_mgr_poll(struct mg_mgr *mgr, int ms) {\n  struct mg_connection *c, *tmp;\n  uint64_t now = mg_millis();\n  mg_tcpip_poll((struct mg_tcpip_if *) mgr->priv, now);\n  mg_timer_poll(&mgr->timers, now);\n  for (c = mgr->conns; c != NULL; c = tmp) {\n    tmp = c->next;\n    mg_call(c, MG_EV_POLL, &now);\n    MG_VERBOSE((\"%lu .. %c%c%c%c%c\", c->id, c->is_tls ? 'T' : 't',\n                c->is_connecting ? 'C' : 'c', c->is_tls_hs ? 'H' : 'h',\n                c->is_resolving ? 'R' : 'r', c->is_closing ? 'C' : 'c'));\n    if (c->is_tls_hs) mg_tls_handshake(c);\n    if (can_write(c)) write_conn(c);\n    if (c->is_draining && c->send.len == 0) c->is_closing = 1;\n    if (c->is_closing) close_conn(c);\n  }\n  (void) ms;\n}\n\nbool mg_send(struct mg_connection *c, const void *buf, size_t len) {\n  struct mg_tcpip_if *ifp = (struct mg_tcpip_if *) c->mgr->priv;\n  bool res = false;\n  if (ifp->ip == 0 || ifp->state != MG_TCPIP_STATE_READY) {\n    mg_error(c, \"net down\");\n  } else if (c->is_udp) {\n    struct connstate *s = (struct connstate *) (c + 1);\n    tx_udp(ifp, s->mac, ifp->ip, c->loc.port, c->rem.ip, c->rem.port, buf, len);\n    res = true;\n  } else {\n    res = mg_iobuf_add(&c->send, c->send.len, buf, len);\n  }\n  return res;\n}\n#endif  // MG_ENABLE_TCPIP\n", "#include \"arch.h\"\n#include \"base64.h\"\n#include \"fmt.h\"\n#include \"http.h\"\n#include \"json.h\"\n#include \"log.h\"\n#include \"net.h\"\n#include \"printf.h\"\n#include \"ssi.h\"\n#include \"util.h\"\n#include \"version.h\"\n#include \"ws.h\"\n\n// Chunk deletion marker is the MSB in the \"processed\" counter\n#define MG_DMARK ((size_t) 1 << (sizeof(size_t) * 8 - 1))\n\n// Multipart POST example:\n// --xyz\n// Content-Disposition: form-data; name=\"val\"\n//\n// abcdef\n// --xyz\n// Content-Disposition: form-data; name=\"foo\"; filename=\"a.txt\"\n// Content-Type: text/plain\n//\n// hello world\n//\n// --xyz--\nsize_t mg_http_next_multipart(struct mg_str body, size_t ofs,\n                              struct mg_http_part *part) {\n  struct mg_str cd = mg_str_n(\"Content-Disposition\", 19);\n  const char *s = body.ptr;\n  size_t b = ofs, h1, h2, b1, b2, max = body.len;\n\n  // Init part params\n  if (part != NULL) part->name = part->filename = part->body = mg_str_n(0, 0);\n\n  // Skip boundary\n  while (b + 2 < max && s[b] != '\\r' && s[b + 1] != '\\n') b++;\n  if (b <= ofs || b + 2 >= max) return 0;\n  // MG_INFO((\"B: %zu %zu [%.*s]\", ofs, b - ofs, (int) (b - ofs), s));\n\n  // Skip headers\n  h1 = h2 = b + 2;\n  for (;;) {\n    while (h2 + 2 < max && s[h2] != '\\r' && s[h2 + 1] != '\\n') h2++;\n    if (h2 == h1) break;\n    if (h2 + 2 >= max) return 0;\n    // MG_INFO((\"Header: [%.*s]\", (int) (h2 - h1), &s[h1]));\n    if (part != NULL && h1 + cd.len + 2 < h2 && s[h1 + cd.len] == ':' &&\n        mg_ncasecmp(&s[h1], cd.ptr, cd.len) == 0) {\n      struct mg_str v = mg_str_n(&s[h1 + cd.len + 2], h2 - (h1 + cd.len + 2));\n      part->name = mg_http_get_header_var(v, mg_str_n(\"name\", 4));\n      part->filename = mg_http_get_header_var(v, mg_str_n(\"filename\", 8));\n    }\n    h1 = h2 = h2 + 2;\n  }\n  b1 = b2 = h2 + 2;\n  while (b2 + 2 + (b - ofs) + 2 < max && !(s[b2] == '\\r' && s[b2 + 1] == '\\n' &&\n                                           memcmp(&s[b2 + 2], s, b - ofs) == 0))\n    b2++;\n\n  if (b2 + 2 >= max) return 0;\n  if (part != NULL) part->body = mg_str_n(&s[b1], b2 - b1);\n  // MG_INFO((\"Body: [%.*s]\", (int) (b2 - b1), &s[b1]));\n  return b2 + 2;\n}\n\nvoid mg_http_bauth(struct mg_connection *c, const char *user,\n                   const char *pass) {\n  struct mg_str u = mg_str(user), p = mg_str(pass);\n  size_t need = c->send.len + 36 + (u.len + p.len) * 2;\n  if (c->send.size < need) mg_iobuf_resize(&c->send, need);\n  if (c->send.size >= need) {\n    int i, n = 0;\n    char *buf = (char *) &c->send.buf[c->send.len];\n    memcpy(buf, \"Authorization: Basic \", 21);  // DON'T use mg_send!\n    for (i = 0; i < (int) u.len; i++) {\n      n = mg_base64_update(((unsigned char *) u.ptr)[i], buf + 21, n);\n    }\n    if (p.len > 0) {\n      n = mg_base64_update(':', buf + 21, n);\n      for (i = 0; i < (int) p.len; i++) {\n        n = mg_base64_update(((unsigned char *) p.ptr)[i], buf + 21, n);\n      }\n    }\n    n = mg_base64_final(buf + 21, n);\n    c->send.len += 21 + (size_t) n + 2;\n    memcpy(&c->send.buf[c->send.len - 2], \"\\r\\n\", 2);\n  } else {\n    MG_ERROR((\"%lu oom %d->%d \", c->id, (int) c->send.size, (int) need));\n  }\n}\n\nstruct mg_str mg_http_var(struct mg_str buf, struct mg_str name) {\n  struct mg_str k, v, result = mg_str_n(NULL, 0);\n  while (mg_split(&buf, &k, &v, '&')) {\n    if (name.len == k.len && mg_ncasecmp(name.ptr, k.ptr, k.len) == 0) {\n      result = v;\n      break;\n    }\n  }\n  return result;\n}\n\nint mg_http_get_var(const struct mg_str *buf, const char *name, char *dst,\n                    size_t dst_len) {\n  int len;\n  if (dst == NULL || dst_len == 0) {\n    len = -2;  // Bad destination\n  } else if (buf->ptr == NULL || name == NULL || buf->len == 0) {\n    len = -1;  // Bad source\n    dst[0] = '\\0';\n  } else {\n    struct mg_str v = mg_http_var(*buf, mg_str(name));\n    if (v.ptr == NULL) {\n      len = -4;  // Name does not exist\n    } else {\n      len = mg_url_decode(v.ptr, v.len, dst, dst_len, 1);\n      if (len < 0) len = -3;  // Failed to decode\n    }\n  }\n  return len;\n}\n\nstatic bool isx(int c) {\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||\n         (c >= 'A' && c <= 'F');\n}\n\nint mg_url_decode(const char *src, size_t src_len, char *dst, size_t dst_len,\n                  int is_form_url_encoded) {\n  size_t i, j;\n  for (i = j = 0; i < src_len && j + 1 < dst_len; i++, j++) {\n    if (src[i] == '%') {\n      // Use `i + 2 < src_len`, not `i < src_len - 2`, note small src_len\n      if (i + 2 < src_len && isx(src[i + 1]) && isx(src[i + 2])) {\n        mg_unhex(src + i + 1, 2, (uint8_t *) &dst[j]);\n        i += 2;\n      } else {\n        return -1;\n      }\n    } else if (is_form_url_encoded && src[i] == '+') {\n      dst[j] = ' ';\n    } else {\n      dst[j] = src[i];\n    }\n  }\n  if (j < dst_len) dst[j] = '\\0';  // Null-terminate the destination\n  return i >= src_len && j < dst_len ? (int) j : -1;\n}\n\nstatic bool isok(uint8_t c) { return c == '\\n' || c == '\\r' || c >= ' '; }\n\nint mg_http_get_request_len(const unsigned char *buf, size_t buf_len) {\n  size_t i;\n  for (i = 0; i < buf_len; i++) {\n    if (!isok(buf[i])) return -1;\n    if ((i > 0 && buf[i] == '\\n' && buf[i - 1] == '\\n') ||\n        (i > 3 && buf[i] == '\\n' && buf[i - 1] == '\\r' && buf[i - 2] == '\\n'))\n      return (int) i + 1;\n  }\n  return 0;\n}\n\nstatic const char *skip(const char *s, const char *e, const char *d,\n                        struct mg_str *v) {\n  v->ptr = s;\n  while (s < e && *s != '\\n' && strchr(d, *s) == NULL) s++;\n  v->len = (size_t) (s - v->ptr);\n  while (s < e && strchr(d, *s) != NULL) s++;\n  return s;\n}\n\nstruct mg_str *mg_http_get_header(struct mg_http_message *h, const char *name) {\n  size_t i, n = strlen(name), max = sizeof(h->headers) / sizeof(h->headers[0]);\n  for (i = 0; i < max && h->headers[i].name.len > 0; i++) {\n    struct mg_str *k = &h->headers[i].name, *v = &h->headers[i].value;\n    if (n == k->len && mg_ncasecmp(k->ptr, name, n) == 0) return v;\n  }\n  return NULL;\n}\n\nstatic void mg_http_parse_headers(const char *s, const char *end,\n                                  struct mg_http_header *h, int max_headers) {\n  int i;\n  for (i = 0; i < max_headers; i++) {\n    struct mg_str k, v, tmp;\n    const char *he = skip(s, end, \"\\n\", &tmp);\n    s = skip(s, he, \": \\r\\n\", &k);\n    s = skip(s, he, \"\\r\\n\", &v);\n    if (k.len == tmp.len) continue;\n    while (v.len > 0 && v.ptr[v.len - 1] == ' ') v.len--;  // Trim spaces\n    if (k.len == 0) break;\n    // MG_INFO((\"--HH [%.*s] [%.*s] [%.*s]\", (int) tmp.len - 1, tmp.ptr,\n    //(int) k.len, k.ptr, (int) v.len, v.ptr));\n    h[i].name = k;\n    h[i].value = v;\n  }\n}\n\nint mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {\n  int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);\n  const char *end = s == NULL ? NULL : s + req_len, *qs;  // Cannot add to NULL\n  struct mg_str *cl;\n\n  memset(hm, 0, sizeof(*hm));\n  if (req_len <= 0) return req_len;\n\n  hm->message.ptr = hm->head.ptr = s;\n  hm->body.ptr = end;\n  hm->head.len = (size_t) req_len;\n  hm->chunk.ptr = end;\n  hm->message.len = hm->body.len = (size_t) ~0;  // Set body length to infinite\n\n  // Parse request line\n  s = skip(s, end, \" \", &hm->method);\n  s = skip(s, end, \" \", &hm->uri);\n  s = skip(s, end, \"\\r\\n\", &hm->proto);\n\n  // Sanity check. Allow protocol/reason to be empty\n  if (hm->method.len == 0 || hm->uri.len == 0) return -1;\n\n  // If URI contains '?' character, setup query string\n  if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {\n    hm->query.ptr = qs + 1;\n    hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));\n    hm->uri.len = (size_t) (qs - hm->uri.ptr);\n  }\n\n  mg_http_parse_headers(s, end, hm->headers,\n                        sizeof(hm->headers) / sizeof(hm->headers[0]));\n  if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {\n    int64_t content_len = mg_to64(*cl);\n    if(content_len < 0) return -1;\n    hm->body.len = (size_t) content_len;\n    hm->message.len = (size_t) req_len + hm->body.len;\n  }\n\n  // mg_http_parse() is used to parse both HTTP requests and HTTP\n  // responses. If HTTP response does not have Content-Length set, then\n  // body is read until socket is closed, i.e. body.len is infinite (~0).\n  //\n  // For HTTP requests though, according to\n  // http://tools.ietf.org/html/rfc7231#section-8.1.3,\n  // only POST and PUT methods have defined body semantics.\n  // Therefore, if Content-Length is not specified and methods are\n  // not one of PUT or POST, set body length to 0.\n  //\n  // So, if it is HTTP request, and Content-Length is not set,\n  // and method is not (PUT or POST) then reset body length to zero.\n  is_response = mg_ncasecmp(hm->method.ptr, \"HTTP/\", 5) == 0;\n  if (hm->body.len == (size_t) ~0 && !is_response &&\n      mg_vcasecmp(&hm->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&hm->method, \"POST\") != 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  // The 204 (No content) responses also have 0 body length\n  if (hm->body.len == (size_t) ~0 && is_response &&\n      mg_vcasecmp(&hm->uri, \"204\") == 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n\n  return req_len;\n}\n\nstatic void mg_http_vprintf_chunk(struct mg_connection *c, const char *fmt,\n                                  va_list *ap) {\n  size_t len = c->send.len;\n  mg_send(c, \"        \\r\\n\", 10);\n  mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, ap);\n  if (c->send.len >= len + 10) {\n    mg_snprintf((char *) c->send.buf + len, 9, \"%08lx\", c->send.len - len - 10);\n    c->send.buf[len + 8] = '\\r';\n    if (c->send.len == len + 10) c->is_resp = 0;  // Last chunk, reset marker\n  }\n  mg_send(c, \"\\r\\n\", 2);\n}\n\nvoid mg_http_printf_chunk(struct mg_connection *c, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  mg_http_vprintf_chunk(c, fmt, &ap);\n  va_end(ap);\n}\n\nvoid mg_http_write_chunk(struct mg_connection *c, const char *buf, size_t len) {\n  mg_printf(c, \"%lx\\r\\n\", (unsigned long) len);\n  mg_send(c, buf, len);\n  mg_send(c, \"\\r\\n\", 2);\n  if (len == 0) c->is_resp = 0;\n}\n\n// clang-format off\nstatic const char *mg_http_status_code_str(int status_code) {\n  switch (status_code) {\n    case 100: return \"Continue\";\n    case 201: return \"Created\";\n    case 202: return \"Accepted\";\n    case 204: return \"No Content\";\n    case 206: return \"Partial Content\";\n    case 301: return \"Moved Permanently\";\n    case 302: return \"Found\";\n    case 304: return \"Not Modified\";\n    case 400: return \"Bad Request\";\n    case 401: return \"Unauthorized\";\n    case 403: return \"Forbidden\";\n    case 404: return \"Not Found\";\n    case 418: return \"I'm a teapot\";\n    case 500: return \"Internal Server Error\";\n    case 501: return \"Not Implemented\";\n    default: return \"OK\";\n  }\n}\n// clang-format on\n\nvoid mg_http_reply(struct mg_connection *c, int code, const char *headers,\n                   const char *fmt, ...) {\n  va_list ap;\n  size_t len;\n  mg_printf(c, \"HTTP/1.1 %d %s\\r\\n%sContent-Length:            \\r\\n\\r\\n\", code,\n            mg_http_status_code_str(code), headers == NULL ? \"\" : headers);\n  len = c->send.len;\n  va_start(ap, fmt);\n  mg_vxprintf(mg_pfn_iobuf, &c->send, fmt, &ap);\n  va_end(ap);\n  if (c->send.len > 16) {\n    size_t n = mg_snprintf((char *) &c->send.buf[len - 15], 11, \"%-10lu\",\n                           (unsigned long) (c->send.len - len));\n    c->send.buf[len - 15 + n] = ' ';  // Change ending 0 to space\n  }\n  c->is_resp = 0;\n}\n\nstatic void http_cb(struct mg_connection *, int, void *, void *);\nstatic void restore_http_cb(struct mg_connection *c) {\n  mg_fs_close((struct mg_fd *) c->pfn_data);\n  c->pfn_data = NULL;\n  c->pfn = http_cb;\n  c->is_resp = 0;\n}\n\nchar *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime);\nchar *mg_http_etag(char *buf, size_t len, size_t size, time_t mtime) {\n  mg_snprintf(buf, len, \"\\\"%lld.%lld\\\"\", (int64_t) mtime, (int64_t) size);\n  return buf;\n}\n\nstatic void static_cb(struct mg_connection *c, int ev, void *ev_data,\n                      void *fn_data) {\n  if (ev == MG_EV_WRITE || ev == MG_EV_POLL) {\n    struct mg_fd *fd = (struct mg_fd *) fn_data;\n    // Read to send IO buffer directly, avoid extra on-stack buffer\n    size_t n, max = MG_IO_SIZE, space;\n    size_t *cl = (size_t *) &c->data[(sizeof(c->data) - sizeof(size_t)) /\n                                     sizeof(size_t) * sizeof(size_t)];\n    if (c->send.size < max) mg_iobuf_resize(&c->send, max);\n    if (c->send.len >= c->send.size) return;  // Rate limit\n    if ((space = c->send.size - c->send.len) > *cl) space = *cl;\n    n = fd->fs->rd(fd->fd, c->send.buf + c->send.len, space);\n    c->send.len += n;\n    *cl -= n;\n    if (n == 0) restore_http_cb(c);\n  } else if (ev == MG_EV_CLOSE) {\n    restore_http_cb(c);\n  }\n  (void) ev_data;\n}\n\n// Known mime types. Keep it outside guess_content_type() function, since\n// some environments don't like it defined there.\n// clang-format off\nstatic struct mg_str s_known_types[] = {\n    MG_C_STR(\"html\"), MG_C_STR(\"text/html; charset=utf-8\"),\n    MG_C_STR(\"htm\"), MG_C_STR(\"text/html; charset=utf-8\"),\n    MG_C_STR(\"css\"), MG_C_STR(\"text/css; charset=utf-8\"),\n    MG_C_STR(\"js\"), MG_C_STR(\"text/javascript; charset=utf-8\"),\n    MG_C_STR(\"gif\"), MG_C_STR(\"image/gif\"),\n    MG_C_STR(\"png\"), MG_C_STR(\"image/png\"),\n    MG_C_STR(\"jpg\"), MG_C_STR(\"image/jpeg\"),\n    MG_C_STR(\"jpeg\"), MG_C_STR(\"image/jpeg\"),\n    MG_C_STR(\"woff\"), MG_C_STR(\"font/woff\"),\n    MG_C_STR(\"ttf\"), MG_C_STR(\"font/ttf\"),\n    MG_C_STR(\"svg\"), MG_C_STR(\"image/svg+xml\"),\n    MG_C_STR(\"txt\"), MG_C_STR(\"text/plain; charset=utf-8\"),\n    MG_C_STR(\"avi\"), MG_C_STR(\"video/x-msvideo\"),\n    MG_C_STR(\"csv\"), MG_C_STR(\"text/csv\"),\n    MG_C_STR(\"doc\"), MG_C_STR(\"application/msword\"),\n    MG_C_STR(\"exe\"), MG_C_STR(\"application/octet-stream\"),\n    MG_C_STR(\"gz\"), MG_C_STR(\"application/gzip\"),\n    MG_C_STR(\"ico\"), MG_C_STR(\"image/x-icon\"),\n    MG_C_STR(\"json\"), MG_C_STR(\"application/json\"),\n    MG_C_STR(\"mov\"), MG_C_STR(\"video/quicktime\"),\n    MG_C_STR(\"mp3\"), MG_C_STR(\"audio/mpeg\"),\n    MG_C_STR(\"mp4\"), MG_C_STR(\"video/mp4\"),\n    MG_C_STR(\"mpeg\"), MG_C_STR(\"video/mpeg\"),\n    MG_C_STR(\"pdf\"), MG_C_STR(\"application/pdf\"),\n    MG_C_STR(\"shtml\"), MG_C_STR(\"text/html; charset=utf-8\"),\n    MG_C_STR(\"tgz\"), MG_C_STR(\"application/tar-gz\"),\n    MG_C_STR(\"wav\"), MG_C_STR(\"audio/wav\"),\n    MG_C_STR(\"webp\"), MG_C_STR(\"image/webp\"),\n    MG_C_STR(\"zip\"), MG_C_STR(\"application/zip\"),\n    MG_C_STR(\"3gp\"), MG_C_STR(\"video/3gpp\"),\n    {0, 0},\n};\n// clang-format on\n\nstatic struct mg_str guess_content_type(struct mg_str path, const char *extra) {\n  struct mg_str k, v, s = mg_str(extra);\n  size_t i = 0;\n\n  // Shrink path to its extension only\n  while (i < path.len && path.ptr[path.len - i - 1] != '.') i++;\n  path.ptr += path.len - i;\n  path.len = i;\n\n  // Process user-provided mime type overrides, if any\n  while (mg_commalist(&s, &k, &v)) {\n    if (mg_strcmp(path, k) == 0) return v;\n  }\n\n  // Process built-in mime types\n  for (i = 0; s_known_types[i].ptr != NULL; i += 2) {\n    if (mg_strcmp(path, s_known_types[i]) == 0) return s_known_types[i + 1];\n  }\n\n  return mg_str(\"text/plain; charset=utf-8\");\n}\n\nstatic int getrange(struct mg_str *s, int64_t *a, int64_t *b) {\n  size_t i, numparsed = 0;\n  // MG_INFO((\"%.*s\", (int) s->len, s->ptr));\n  for (i = 0; i + 6 < s->len; i++) {\n    if (memcmp(&s->ptr[i], \"bytes=\", 6) == 0) {\n      struct mg_str p = mg_str_n(s->ptr + i + 6, s->len - i - 6);\n      if (p.len > 0 && p.ptr[0] >= '0' && p.ptr[0] <= '9') numparsed++;\n      *a = mg_to64(p);\n      // MG_INFO((\"PPP [%.*s] %d\", (int) p.len, p.ptr, numparsed));\n      while (p.len && p.ptr[0] >= '0' && p.ptr[0] <= '9') p.ptr++, p.len--;\n      if (p.len && p.ptr[0] == '-') p.ptr++, p.len--;\n      *b = mg_to64(p);\n      if (p.len > 0 && p.ptr[0] >= '0' && p.ptr[0] <= '9') numparsed++;\n      // MG_INFO((\"PPP [%.*s] %d\", (int) p.len, p.ptr, numparsed));\n      break;\n    }\n  }\n  return (int) numparsed;\n}\n\nvoid mg_http_serve_file(struct mg_connection *c, struct mg_http_message *hm,\n                        const char *path,\n                        const struct mg_http_serve_opts *opts) {\n  char etag[64], tmp[MG_PATH_MAX];\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct mg_fd *fd = NULL;\n  size_t size = 0;\n  time_t mtime = 0;\n  struct mg_str *inm = NULL;\n  struct mg_str mime = guess_content_type(mg_str(path), opts->mime_types);\n  bool gzip = false;\n\n  if (path != NULL) {\n    // If a browser sends us \"Accept-Encoding: gzip\", try to open .gz first\n    struct mg_str *ae = mg_http_get_header(hm, \"Accept-Encoding\");\n    if (ae != NULL && mg_strstr(*ae, mg_str(\"gzip\")) != NULL) {\n      mg_snprintf(tmp, sizeof(tmp), \"%s.gz\", path);\n      fd = mg_fs_open(fs, tmp, MG_FS_READ);\n      if (fd != NULL) gzip = true, path = tmp;\n    }\n    // No luck opening .gz? Open what we've told to open\n    if (fd == NULL) fd = mg_fs_open(fs, path, MG_FS_READ);\n  }\n\n  // Failed to open, and page404 is configured? Open it, then\n  if (fd == NULL && opts->page404 != NULL) {\n    fd = mg_fs_open(fs, opts->page404, MG_FS_READ);\n    mime = guess_content_type(mg_str(path), opts->mime_types);\n    path = opts->page404;\n  }\n\n  if (fd == NULL || fs->st(path, &size, &mtime) == 0) {\n    mg_http_reply(c, 404, opts->extra_headers, \"Not found\\n\");\n    mg_fs_close(fd);\n    // NOTE: mg_http_etag() call should go first!\n  } else if (mg_http_etag(etag, sizeof(etag), size, mtime) != NULL &&\n             (inm = mg_http_get_header(hm, \"If-None-Match\")) != NULL &&\n             mg_vcasecmp(inm, etag) == 0) {\n    mg_fs_close(fd);\n    mg_http_reply(c, 304, opts->extra_headers, \"\");\n  } else {\n    int n, status = 200;\n    char range[100];\n    int64_t r1 = 0, r2 = 0, cl = (int64_t) size;\n\n    // Handle Range header\n    struct mg_str *rh = mg_http_get_header(hm, \"Range\");\n    range[0] = '\\0';\n    if (rh != NULL && (n = getrange(rh, &r1, &r2)) > 0 && r1 >= 0 && r2 >= 0) {\n      // If range is specified like \"400-\", set second limit to content len\n      if (n == 1) r2 = cl - 1;\n      if (r1 > r2 || r2 >= cl) {\n        status = 416;\n        cl = 0;\n        mg_snprintf(range, sizeof(range), \"Content-Range: bytes */%lld\\r\\n\",\n                    (int64_t) size);\n      } else {\n        status = 206;\n        cl = r2 - r1 + 1;\n        mg_snprintf(range, sizeof(range),\n                    \"Content-Range: bytes %lld-%lld/%lld\\r\\n\", r1, r1 + cl - 1,\n                    (int64_t) size);\n        fs->sk(fd->fd, (size_t) r1);\n      }\n    }\n    mg_printf(c,\n              \"HTTP/1.1 %d %s\\r\\n\"\n              \"Content-Type: %.*s\\r\\n\"\n              \"Etag: %s\\r\\n\"\n              \"Content-Length: %llu\\r\\n\"\n              \"%s%s%s\\r\\n\",\n              status, mg_http_status_code_str(status), (int) mime.len, mime.ptr,\n              etag, cl, gzip ? \"Content-Encoding: gzip\\r\\n\" : \"\", range,\n              opts->extra_headers ? opts->extra_headers : \"\");\n    if (mg_vcasecmp(&hm->method, \"HEAD\") == 0) {\n      c->is_draining = 1;\n      c->is_resp = 0;\n      mg_fs_close(fd);\n    } else {\n      // Track to-be-sent content length at the end of c->data, aligned\n      size_t *clp = (size_t *) &c->data[(sizeof(c->data) - sizeof(size_t)) /\n                                        sizeof(size_t) * sizeof(size_t)];\n      c->pfn = static_cb;\n      c->pfn_data = fd;\n      *clp = (size_t) cl;\n    }\n  }\n}\n\nstruct printdirentrydata {\n  struct mg_connection *c;\n  struct mg_http_message *hm;\n  const struct mg_http_serve_opts *opts;\n  const char *dir;\n};\n\nstatic void printdirentry(const char *name, void *userdata) {\n  struct printdirentrydata *d = (struct printdirentrydata *) userdata;\n  struct mg_fs *fs = d->opts->fs == NULL ? &mg_fs_posix : d->opts->fs;\n  size_t size = 0;\n  time_t t = 0;\n  char path[MG_PATH_MAX], sz[40], mod[40];\n  int flags, n = 0;\n\n  // MG_DEBUG((\"[%s] [%s]\", d->dir, name));\n  if (mg_snprintf(path, sizeof(path), \"%s%c%s\", d->dir, '/', name) >\n      sizeof(path)) {\n    MG_ERROR((\"%s truncated\", name));\n  } else if ((flags = fs->st(path, &size, &t)) == 0) {\n    MG_ERROR((\"%lu stat(%s): %d\", d->c->id, path, errno));\n  } else {\n    const char *slash = flags & MG_FS_DIR ? \"/\" : \"\";\n    if (flags & MG_FS_DIR) {\n      mg_snprintf(sz, sizeof(sz), \"%s\", \"[DIR]\");\n    } else {\n      mg_snprintf(sz, sizeof(sz), \"%lld\", (uint64_t) size);\n    }\n#if defined(MG_HTTP_DIRLIST_TIME_FMT)\n    {\n      char time_str[40];\n      struct tm *time_info = localtime(&t);\n      strftime(time_str, sizeof time_str, \"%Y/%m/%d %H:%M:%S\", time_info);\n      mg_snprintf(mod, sizeof(mod), \"%s\", time_str);\n    }\n#else\n    mg_snprintf(mod, sizeof(mod), \"%lu\", (unsigned long) t);\n#endif\n    n = (int) mg_url_encode(name, strlen(name), path, sizeof(path));\n    mg_printf(d->c,\n              \"  <tr><td><a href=\\\"%.*s%s\\\">%s%s</a></td>\"\n              \"<td name=%lu>%s</td><td name=%lld>%s</td></tr>\\n\",\n              n, path, slash, name, slash, (unsigned long) t, mod,\n              flags & MG_FS_DIR ? (int64_t) -1 : (int64_t) size, sz);\n  }\n}\n\nstatic void listdir(struct mg_connection *c, struct mg_http_message *hm,\n                    const struct mg_http_serve_opts *opts, char *dir) {\n  const char *sort_js_code =\n      \"<script>function srt(tb, sc, so, d) {\"\n      \"var tr = Array.prototype.slice.call(tb.rows, 0),\"\n      \"tr = tr.sort(function (a, b) { var c1 = a.cells[sc], c2 = b.cells[sc],\"\n      \"n1 = c1.getAttribute('name'), n2 = c2.getAttribute('name'), \"\n      \"t1 = a.cells[2].getAttribute('name'), \"\n      \"t2 = b.cells[2].getAttribute('name'); \"\n      \"return so * (t1 < 0 && t2 >= 0 ? -1 : t2 < 0 && t1 >= 0 ? 1 : \"\n      \"n1 ? parseInt(n2) - parseInt(n1) : \"\n      \"c1.textContent.trim().localeCompare(c2.textContent.trim())); });\";\n  const char *sort_js_code2 =\n      \"for (var i = 0; i < tr.length; i++) tb.appendChild(tr[i]); \"\n      \"if (!d) window.location.hash = ('sc=' + sc + '&so=' + so); \"\n      \"};\"\n      \"window.onload = function() {\"\n      \"var tb = document.getElementById('tb');\"\n      \"var m = /sc=([012]).so=(1|-1)/.exec(window.location.hash) || [0, 2, 1];\"\n      \"var sc = m[1], so = m[2]; document.onclick = function(ev) { \"\n      \"var c = ev.target.rel; if (c) {if (c == sc) so *= -1; srt(tb, c, so); \"\n      \"sc = c; ev.preventDefault();}};\"\n      \"srt(tb, sc, so, true);\"\n      \"}\"\n      \"</script>\";\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct printdirentrydata d = {c, hm, opts, dir};\n  char tmp[10], buf[MG_PATH_MAX];\n  size_t off, n;\n  int len = mg_url_decode(hm->uri.ptr, hm->uri.len, buf, sizeof(buf), 0);\n  struct mg_str uri = len > 0 ? mg_str_n(buf, (size_t) len) : hm->uri;\n\n  mg_printf(c,\n            \"HTTP/1.1 200 OK\\r\\n\"\n            \"Content-Type: text/html; charset=utf-8\\r\\n\"\n            \"%s\"\n            \"Content-Length:         \\r\\n\\r\\n\",\n            opts->extra_headers == NULL ? \"\" : opts->extra_headers);\n  off = c->send.len;  // Start of body\n  mg_printf(c,\n            \"<!DOCTYPE html><html><head><title>Index of %.*s</title>%s%s\"\n            \"<style>th,td {text-align: left; padding-right: 1em; \"\n            \"font-family: monospace; }</style></head>\"\n            \"<body><h1>Index of %.*s</h1><table cellpadding=\\\"0\\\"><thead>\"\n            \"<tr><th><a href=\\\"#\\\" rel=\\\"0\\\">Name</a></th><th>\"\n            \"<a href=\\\"#\\\" rel=\\\"1\\\">Modified</a></th>\"\n            \"<th><a href=\\\"#\\\" rel=\\\"2\\\">Size</a></th></tr>\"\n            \"<tr><td colspan=\\\"3\\\"><hr></td></tr>\"\n            \"</thead>\"\n            \"<tbody id=\\\"tb\\\">\\n\",\n            (int) uri.len, uri.ptr, sort_js_code, sort_js_code2, (int) uri.len,\n            uri.ptr);\n  mg_printf(c, \"%s\",\n            \"  <tr><td><a href=\\\"..\\\">..</a></td>\"\n            \"<td name=-1></td><td name=-1>[DIR]</td></tr>\\n\");\n\n  fs->ls(dir, printdirentry, &d);\n  mg_printf(c,\n            \"</tbody><tfoot><tr><td colspan=\\\"3\\\"><hr></td></tr></tfoot>\"\n            \"</table><address>Mongoose v.%s</address></body></html>\\n\",\n            MG_VERSION);\n  n = mg_snprintf(tmp, sizeof(tmp), \"%lu\", (unsigned long) (c->send.len - off));\n  if (n > sizeof(tmp)) n = 0;\n  memcpy(c->send.buf + off - 12, tmp, n);  // Set content length\n  c->is_resp = 0;                          // Mark response end\n}\n\n// Resolve requested file into `path` and return its fs->st() result\nstatic int uri_to_path2(struct mg_connection *c, struct mg_http_message *hm,\n                        struct mg_fs *fs, struct mg_str url, struct mg_str dir,\n                        char *path, size_t path_size) {\n  int flags, tmp;\n  // Append URI to the root_dir, and sanitize it\n  size_t n = mg_snprintf(path, path_size, \"%.*s\", (int) dir.len, dir.ptr);\n  if (n > path_size) n = path_size;\n  path[path_size - 1] = '\\0';\n  if (n + 2 < path_size) path[n++] = '/', path[n] = '\\0';\n  mg_url_decode(hm->uri.ptr + url.len, hm->uri.len - url.len, path + n,\n                path_size - n, 0);\n  path[path_size - 1] = '\\0';  // Double-check\n  mg_remove_double_dots(path);\n  n = strlen(path);\n  while (n > 1 && path[n - 1] == '/') path[--n] = 0;  // Trim trailing slashes\n  flags = mg_vcmp(&hm->uri, \"/\") == 0 ? MG_FS_DIR : fs->st(path, NULL, NULL);\n  MG_VERBOSE((\"%lu %.*s -> %s %d\", c->id, (int) hm->uri.len, hm->uri.ptr, path,\n              flags));\n  if (flags == 0) {\n    // Do nothing - let's caller decide\n  } else if ((flags & MG_FS_DIR) && hm->uri.len > 0 &&\n             hm->uri.ptr[hm->uri.len - 1] != '/') {\n    mg_printf(c,\n              \"HTTP/1.1 301 Moved\\r\\n\"\n              \"Location: %.*s/\\r\\n\"\n              \"Content-Length: 0\\r\\n\"\n              \"\\r\\n\",\n              (int) hm->uri.len, hm->uri.ptr);\n    c->is_resp = 0;\n    flags = -1;\n  } else if (flags & MG_FS_DIR) {\n    if (((mg_snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX) > 0 &&\n          (tmp = fs->st(path, NULL, NULL)) != 0) ||\n         (mg_snprintf(path + n, path_size - n, \"/index.shtml\") > 0 &&\n          (tmp = fs->st(path, NULL, NULL)) != 0))) {\n      flags = tmp;\n    } else if ((mg_snprintf(path + n, path_size - n, \"/\" MG_HTTP_INDEX \".gz\") >\n                    0 &&\n                (tmp = fs->st(path, NULL, NULL)) !=\n                    0)) {  // check for gzipped index\n      flags = tmp;\n      path[n + 1 + strlen(MG_HTTP_INDEX)] =\n          '\\0';  // Remove appended .gz in index file name\n    } else {\n      path[n] = '\\0';  // Remove appended index file name\n    }\n  }\n  return flags;\n}\n\nstatic int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,\n                       const struct mg_http_serve_opts *opts, char *path,\n                       size_t path_size) {\n  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;\n  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};\n  while (mg_commalist(&s, &k, &v)) {\n    if (v.len == 0) v = k, k = mg_str(\"/\");\n    if (hm->uri.len < k.len) continue;\n    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;\n    u = k, p = v;\n  }\n  return uri_to_path2(c, hm, fs, u, p, path, path_size);\n}\n\nvoid mg_http_serve_dir(struct mg_connection *c, struct mg_http_message *hm,\n                       const struct mg_http_serve_opts *opts) {\n  char path[MG_PATH_MAX];\n  const char *sp = opts->ssi_pattern;\n  int flags = uri_to_path(c, hm, opts, path, sizeof(path));\n  if (flags < 0) {\n    // Do nothing: the response has already been sent by uri_to_path()\n  } else if (flags & MG_FS_DIR) {\n    listdir(c, hm, opts, path);\n  } else if (flags && sp != NULL &&\n             mg_globmatch(sp, strlen(sp), path, strlen(path))) {\n    mg_http_serve_ssi(c, opts->root_dir, path);\n  } else {\n    mg_http_serve_file(c, hm, path, opts);\n  }\n}\n\nstatic bool mg_is_url_safe(int c) {\n  return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') ||\n         (c >= 'A' && c <= 'Z') || c == '.' || c == '_' || c == '-' || c == '~';\n}\n\nsize_t mg_url_encode(const char *s, size_t sl, char *buf, size_t len) {\n  size_t i, n = 0;\n  for (i = 0; i < sl; i++) {\n    int c = *(unsigned char *) &s[i];\n    if (n + 4 >= len) return 0;\n    if (mg_is_url_safe(c)) {\n      buf[n++] = s[i];\n    } else {\n      buf[n++] = '%';\n      mg_hex(&s[i], 1, &buf[n]);\n      n += 2;\n    }\n  }\n  if (len > 0 && n < len - 1) buf[n] = '\\0';  // Null-terminate the destination\n  if (len > 0) buf[len - 1] = '\\0';           // Always.\n  return n;\n}\n\nvoid mg_http_creds(struct mg_http_message *hm, char *user, size_t userlen,\n                   char *pass, size_t passlen) {\n  struct mg_str *v = mg_http_get_header(hm, \"Authorization\");\n  user[0] = pass[0] = '\\0';\n  if (v != NULL && v->len > 6 && memcmp(v->ptr, \"Basic \", 6) == 0) {\n    char buf[256];\n    int n = mg_base64_decode(v->ptr + 6, (int) v->len - 6, buf);\n    const char *p = (const char *) memchr(buf, ':', n > 0 ? (size_t) n : 0);\n    if (p != NULL) {\n      mg_snprintf(user, userlen, \"%.*s\", (int) (p - buf), buf);\n      mg_snprintf(pass, passlen, \"%.*s\", n - (int) (p - buf) - 1, p + 1);\n    }\n  } else if (v != NULL && v->len > 7 && memcmp(v->ptr, \"Bearer \", 7) == 0) {\n    mg_snprintf(pass, passlen, \"%.*s\", (int) v->len - 7, v->ptr + 7);\n  } else if ((v = mg_http_get_header(hm, \"Cookie\")) != NULL) {\n    struct mg_str t = mg_http_get_header_var(*v, mg_str_n(\"access_token\", 12));\n    if (t.len > 0) mg_snprintf(pass, passlen, \"%.*s\", (int) t.len, t.ptr);\n  } else {\n    mg_http_get_var(&hm->query, \"access_token\", pass, passlen);\n  }\n}\n\nstatic struct mg_str stripquotes(struct mg_str s) {\n  return s.len > 1 && s.ptr[0] == '\"' && s.ptr[s.len - 1] == '\"'\n             ? mg_str_n(s.ptr + 1, s.len - 2)\n             : s;\n}\n\nstruct mg_str mg_http_get_header_var(struct mg_str s, struct mg_str v) {\n  size_t i;\n  for (i = 0; v.len > 0 && i + v.len + 2 < s.len; i++) {\n    if (s.ptr[i + v.len] == '=' && memcmp(&s.ptr[i], v.ptr, v.len) == 0) {\n      const char *p = &s.ptr[i + v.len + 1], *b = p, *x = &s.ptr[s.len];\n      int q = p < x && *p == '\"' ? 1 : 0;\n      while (p < x &&\n             (q ? p == b || *p != '\"' : *p != ';' && *p != ' ' && *p != ','))\n        p++;\n      // MG_INFO((\"[%.*s] [%.*s] [%.*s]\", (int) s.len, s.ptr, (int) v.len,\n      // v.ptr, (int) (p - b), b));\n      return stripquotes(mg_str_n(b, (size_t) (p - b + q)));\n    }\n  }\n  return mg_str_n(NULL, 0);\n}\n\nbool mg_http_match_uri(const struct mg_http_message *hm, const char *glob) {\n  return mg_match(hm->uri, mg_str(glob), NULL);\n}\n\nlong mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                    struct mg_fs *fs, const char *path, size_t max_size) {\n  char buf[20] = \"0\";\n  long res = 0, offset;\n  mg_http_get_var(&hm->query, \"offset\", buf, sizeof(buf));\n  offset = strtol(buf, NULL, 0);\n  if (hm->body.len == 0) {\n    mg_http_reply(c, 200, \"\", \"%ld\", res);  // Nothing to write\n  } else {\n    struct mg_fd *fd;\n    size_t current_size = 0;\n    MG_DEBUG((\"%s -> %d bytes @ %ld\", path, (int) hm->body.len, offset));\n    if (offset == 0) fs->rm(path);  // If offset if 0, truncate file\n    fs->st(path, &current_size, NULL);\n    if (offset < 0) {\n      mg_http_reply(c, 400, \"\", \"offset required\");\n      res = -1;\n    } else if (offset > 0 && current_size != (size_t) offset) {\n      mg_http_reply(c, 400, \"\", \"%s: offset mismatch\", path);\n      res = -2;\n    } else if ((size_t) offset + hm->body.len > max_size) {\n      mg_http_reply(c, 400, \"\", \"%s: over max size of %lu\", path,\n                    (unsigned long) max_size);\n      res = -3;\n    } else if ((fd = mg_fs_open(fs, path, MG_FS_WRITE)) == NULL) {\n      mg_http_reply(c, 400, \"\", \"open(%s): %d\", path, errno);\n      res = -4;\n    } else {\n      res = offset + (long) fs->wr(fd->fd, hm->body.ptr, hm->body.len);\n      mg_fs_close(fd);\n      mg_http_reply(c, 200, \"\", \"%ld\", res);\n    }\n  }\n  return res;\n}\n\nint mg_http_status(const struct mg_http_message *hm) {\n  return atoi(hm->uri.ptr);\n}\n\n// If a server sends data to the client using chunked encoding, Mongoose strips\n// off the chunking prefix (hex length and \\r\\n) and suffix (\\r\\n), appends the\n// stripped data to the body, and fires the MG_EV_HTTP_CHUNK event.  When zero\n// chunk is received, we fire MG_EV_HTTP_MSG, and the body already has all\n// chunking prefixes/suffixes stripped.\n//\n// If a server sends data without chunked encoding, we also fire a series of\n// MG_EV_HTTP_CHUNK events for every received piece of data, and then we fire\n// MG_EV_HTTP_MSG event in the end.\n//\n// We track total processed length in the c->pfn_data, which is a void *\n// pointer: we store a size_t value there.\nstatic bool getchunk(struct mg_str s, size_t *prefixlen, size_t *datalen) {\n  size_t i = 0, n;\n  while (i < s.len && s.ptr[i] != '\\r' && s.ptr[i] != '\\n') i++;\n  n = mg_unhexn(s.ptr, i);\n  // MG_INFO((\"%d %d\", (int) (i + n + 4), (int) s.len));\n  if (s.len < i + n + 4) return false;  // Chunk not yet fully buffered\n  if (s.ptr[i] != '\\r' || s.ptr[i + 1] != '\\n') return false;\n  if (s.ptr[i + n + 2] != '\\r' || s.ptr[i + n + 3] != '\\n') return false;\n  *prefixlen = i + 2;\n  *datalen = n;\n  return true;\n}\n\nstatic bool mg_is_chunked(struct mg_http_message *hm) {\n  const char *needle = \"chunked\";\n  struct mg_str *te = mg_http_get_header(hm, \"Transfer-Encoding\");\n  return te != NULL && mg_vcasecmp(te, needle) == 0;\n}\n\nvoid mg_http_delete_chunk(struct mg_connection *c, struct mg_http_message *hm) {\n  size_t ofs = (size_t) (hm->chunk.ptr - (char *) c->recv.buf);\n  mg_iobuf_del(&c->recv, ofs, hm->chunk.len);\n  c->pfn_data = (void *) ((size_t) c->pfn_data | MG_DMARK);\n}\n\nstatic void deliver_chunked_chunks(struct mg_connection *c, size_t hlen,\n                                   struct mg_http_message *hm, bool *next) {\n  //  |  ... headers ... | HEXNUM\\r\\n ..data.. \\r\\n | ......\n  //  +------------------+--------------------------+----\n  //  |      hlen        |           chunk1         | ......\n  char *buf = (char *) &c->recv.buf[hlen], *p = buf;\n  size_t len = c->recv.len - hlen;\n  size_t processed = ((size_t) c->pfn_data) & ~MG_DMARK;\n  size_t mark, pl, dl, del = 0, ofs = 0;\n  bool last = false;\n  if (processed <= len) len -= processed, buf += processed;\n  while (!last && getchunk(mg_str_n(buf + ofs, len - ofs), &pl, &dl)) {\n    size_t saved = c->recv.len;\n    memmove(p + processed, buf + ofs + pl, dl);\n    // MG_INFO((\"P2 [%.*s]\", (int) (processed + dl), p));\n    hm->chunk = mg_str_n(p + processed, dl);\n    mg_call(c, MG_EV_HTTP_CHUNK, hm);\n    ofs += pl + dl + 2, del += pl + 2;  // 2 is for \\r\\n suffix\n    processed += dl;\n    if (c->recv.len != saved) processed -= dl, buf -= dl;\n    // mg_hexdump(c->recv.buf, hlen + processed);\n    last = (dl == 0);\n  }\n  mg_iobuf_del(&c->recv, hlen + processed, del);\n  mark = ((size_t) c->pfn_data) & MG_DMARK;\n  c->pfn_data = (void *) (processed | mark);\n  if (last) {\n    hm->body.len = processed;\n    hm->message.len = hlen + processed;\n    c->pfn_data = NULL;\n    if (mark) mg_iobuf_del(&c->recv, 0, hlen), *next = true;\n    // MG_INFO((\"LAST, mark: %lx\", mark));\n    // mg_hexdump(c->recv.buf, c->recv.len);\n  }\n}\n\nstatic void deliver_normal_chunks(struct mg_connection *c, size_t hlen,\n                                  struct mg_http_message *hm, bool *next) {\n  size_t left, processed = ((size_t) c->pfn_data) & ~MG_DMARK;\n  size_t deleted = ((size_t) c->pfn_data) & MG_DMARK;\n  hm->chunk = mg_str_n((char *) &c->recv.buf[hlen], c->recv.len - hlen);\n  if (processed <= hm->chunk.len && !deleted) {\n    hm->chunk.len -= processed;\n    hm->chunk.ptr += processed;\n  }\n  left = hm->body.len < processed ? 0 : hm->body.len - processed;\n  if (hm->chunk.len > left) hm->chunk.len = left;\n  if (hm->chunk.len > 0) mg_call(c, MG_EV_HTTP_CHUNK, hm);\n  processed += hm->chunk.len;\n  deleted = ((size_t) c->pfn_data) & MG_DMARK;  // Re-evaluate after user call\n  if (processed >= hm->body.len) {              // Last, 0-len chunk\n    hm->chunk.len = 0;                          // Reset length\n    mg_call(c, MG_EV_HTTP_CHUNK, hm);           // Call user handler\n    c->pfn_data = NULL;                         // Reset processed counter\n    if (processed && deleted) mg_iobuf_del(&c->recv, 0, hlen), *next = true;\n  } else {\n    c->pfn_data = (void *) (processed | deleted);  // if it is set\n  }\n}\n\nstatic void http_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n  if (ev == MG_EV_READ || ev == MG_EV_CLOSE) {\n    struct mg_http_message hm;\n    // mg_hexdump(c->recv.buf, c->recv.len);\n    while (c->recv.buf != NULL && c->recv.len > 0) {\n      bool next = false;\n      int hlen = mg_http_parse((char *) c->recv.buf, c->recv.len, &hm);\n      if (hlen < 0) {\n        mg_error(c, \"HTTP parse:\\n%.*s\", (int) c->recv.len, c->recv.buf);\n        break;\n      }\n      if (c->is_resp) break;           // Response is still generated\n      if (hlen == 0) break;            // Request is not buffered yet\n      if (ev == MG_EV_CLOSE) {         // If client did not set Content-Length\n        hm.message.len = c->recv.len;  // and closes now, deliver a MSG\n        hm.body.len = hm.message.len - (size_t) (hm.body.ptr - hm.message.ptr);\n      }\n      if (mg_is_chunked(&hm)) {\n        deliver_chunked_chunks(c, (size_t) hlen, &hm, &next);\n      } else {\n        deliver_normal_chunks(c, (size_t) hlen, &hm, &next);\n      }\n      if (next) continue;  // Chunks & request were deleted\n      //  Chunk events are delivered. If we have full body, deliver MSG\n      if (c->recv.len < hm.message.len) break;\n      if (c->is_accepted) c->is_resp = 1;  // Start generating response\n      mg_call(c, MG_EV_HTTP_MSG, &hm);     // User handler can clear is_resp\n      mg_iobuf_del(&c->recv, 0, hm.message.len);\n    }\n  }\n  (void) evd, (void) fnd;\n}\n\nstatic void mg_hfn(struct mg_connection *c, int ev, void *ev_data, void *fnd) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    if (mg_http_match_uri(hm, \"/quit\")) {\n      mg_http_reply(c, 200, \"\", \"ok\\n\");\n      c->is_draining = 1;\n      c->data[0] = 'X';\n    } else if (mg_http_match_uri(hm, \"/debug\")) {\n      int level = (int) mg_json_get_long(hm->body, \"$.level\", MG_LL_DEBUG);\n      mg_log_set(level);\n      mg_http_reply(c, 200, \"\", \"Debug level set to %d\\n\", level);\n    } else {\n      mg_http_reply(c, 200, \"\", \"hi\\n\");\n    }\n  } else if (ev == MG_EV_CLOSE) {\n    if (c->data[0] == 'X') *(bool *) fnd = true;\n  }\n}\n\nvoid mg_hello(const char *url) {\n  struct mg_mgr mgr;\n  bool done = false;\n  mg_mgr_init(&mgr);\n  if (mg_http_listen(&mgr, url, mg_hfn, &done) == NULL) done = true;\n  while (done == false) mg_mgr_poll(&mgr, 100);\n  mg_mgr_free(&mgr);\n}\n\nstruct mg_connection *mg_http_connect(struct mg_mgr *mgr, const char *url,\n                                      mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_connect(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = http_cb;\n  return c;\n}\n\nstruct mg_connection *mg_http_listen(struct mg_mgr *mgr, const char *url,\n                                     mg_event_handler_t fn, void *fn_data) {\n  struct mg_connection *c = mg_listen(mgr, url, fn, fn_data);\n  if (c != NULL) c->pfn = http_cb;\n  return c;\n}\n", "#include \"mongoose.h\"\n\n#include \"float.h\"  // For DBL_EPSILON and HUGE_VAL\n#include \"math.h\"\n\nstatic int s_num_tests = 0;\n\n#define ASSERT(expr)                                            \\\n  do {                                                          \\\n    s_num_tests++;                                              \\\n    if (!(expr)) {                                              \\\n      printf(\"FAILURE %s:%d: %s\\n\", __FILE__, __LINE__, #expr); \\\n      abort();                                                  \\\n    }                                                           \\\n  } while (0)\n\n#define FETCH_BUF_SIZE (256 * 1024)\n\n// Important: we use different port numbers for the Windows bug workaround. See\n// https://support.microsoft.com/en-ae/help/3039044/error-10013-wsaeacces-is-returned-when-a-second-bind-to-a-excluded-por\n\nstatic void test_globmatch(void) {\n  ASSERT(mg_globmatch(\"\", 0, \"\", 0) == 1);\n  ASSERT(mg_globmatch(\"*\", 1, \"a\", 1) == 1);\n  ASSERT(mg_globmatch(\"*\", 1, \"ab\", 2) == 1);\n  ASSERT(mg_globmatch(\"\", 0, \"a\", 1) == 0);\n  ASSERT(mg_globmatch(\"/\", 1, \"/foo\", 4) == 0);\n  ASSERT(mg_globmatch(\"/*/foo\", 6, \"/x/bar\", 6) == 0);\n  ASSERT(mg_globmatch(\"/*/foo\", 6, \"/x/foo\", 6) == 1);\n  ASSERT(mg_globmatch(\"/*/foo\", 6, \"/x/foox\", 7) == 0);\n  ASSERT(mg_globmatch(\"/*/foo*\", 7, \"/x/foox\", 7) == 1);\n  ASSERT(mg_globmatch(\"/*\", 2, \"/abc\", 4) == 1);\n  ASSERT(mg_globmatch(\"/*\", 2, \"/ab/\", 4) == 0);\n  ASSERT(mg_globmatch(\"/*\", 2, \"/\", 1) == 1);\n  ASSERT(mg_globmatch(\"/x/*\", 4, \"/x/2\", 4) == 1);\n  ASSERT(mg_globmatch(\"/x/*\", 4, \"/x/2/foo\", 8) == 0);\n  ASSERT(mg_globmatch(\"/x/*/*\", 6, \"/x/2/foo\", 8) == 1);\n  ASSERT(mg_globmatch(\"#\", 1, \"///\", 3) == 1);\n  ASSERT(mg_globmatch(\"/api/*\", 6, \"/api/foo\", 8) == 1);\n  ASSERT(mg_globmatch(\"/api/*\", 6, \"/api/log/static\", 15) == 0);\n  ASSERT(mg_globmatch(\"/api/#\", 6, \"/api/log/static\", 15) == 1);\n  ASSERT(mg_globmatch(\"#.shtml\", 7, \"/ssi/index.shtml\", 16) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \".c\", 2) == 1);\n  ASSERT(mg_globmatch(\"abc\", 3, \"ab\", 2) == 0);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"a.c\", 3) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"..c\", 3) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"/.c\", 3) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"//a.c\", 5) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"x/a.c\", 5) == 1);\n  ASSERT(mg_globmatch(\"#.c\", 3, \"./a.c\", 5) == 1);\n  ASSERT(mg_globmatch(\"#.shtml\", 7, \"./ssi/index.shtml\", 17) == 1);\n  ASSERT(mg_globmatch(\"#aa#bb#\", 7, \"caabba\", 6) == 1);\n  ASSERT(mg_globmatch(\"#aa#bb#\", 7, \"caabxa\", 6) == 0);\n  ASSERT(mg_globmatch(\"a*b*c\", 5, \"a__b_c\", 6) == 1);\n\n  {\n    struct mg_str caps[3];\n    ASSERT(mg_match(mg_str(\"//a.c\"), mg_str(\"#.c\"), NULL) == true);\n    ASSERT(mg_match(mg_str(\"a\"), mg_str(\"#\"), caps) == true);\n    ASSERT(mg_strcmp(caps[0], mg_str(\"a\")) == 0);\n    ASSERT(mg_match(mg_str(\"//a.c\"), mg_str(\"#.c\"), caps) == true);\n    ASSERT(mg_match(mg_str(\"a_b_c_\"), mg_str(\"a*b*c\"), caps) == false);\n    ASSERT(mg_match(mg_str(\"a__b_c\"), mg_str(\"a*b*c\"), caps) == true);\n    ASSERT(mg_strcmp(caps[0], mg_str(\"__\")) == 0);\n    ASSERT(mg_strcmp(caps[1], mg_str(\"_\")) == 0);\n    ASSERT(mg_match(mg_str(\"a_b_c__c\"), mg_str(\"a*b*c\"), caps) == true);\n    ASSERT(mg_strcmp(caps[0], mg_str(\"_\")) == 0);\n    ASSERT(mg_strcmp(caps[1], mg_str(\"_c__\")) == 0);\n    ASSERT(mg_match(mg_str(\"a_xb_.c__c\"), mg_str(\"a*b*c\"), caps) == true);\n    ASSERT(mg_strcmp(caps[0], mg_str(\"_x\")) == 0);\n    ASSERT(mg_strcmp(caps[1], mg_str(\"_.c__\")) == 0);\n    ASSERT(mg_match(mg_str(\"a\"), mg_str(\"#a\"), caps) == true);\n    ASSERT(mg_strcmp(caps[0], mg_str(\"\")) == 0);\n\n    ASSERT(mg_match(mg_str(\".aa..b...b\"), mg_str(\"#a#b\"), caps) == true);\n    ASSERT(mg_strcmp(caps[0], mg_str(\".\")) == 0);\n    ASSERT(mg_strcmp(caps[1], mg_str(\"a..b...\")) == 0);\n    ASSERT(mg_strcmp(caps[2], mg_str(\"\")) == 0);\n\n    ASSERT(mg_match(mg_str(\"/foo/bar\"), mg_str(\"/*/*\"), caps) == true);\n    ASSERT(mg_strcmp(caps[0], mg_str(\"foo\")) == 0);\n    ASSERT(mg_strcmp(caps[1], mg_str(\"bar\")) == 0);\n    ASSERT(mg_strcmp(caps[2], mg_str(\"\")) == 0);\n\n    ASSERT(mg_match(mg_str(\"/foo/\"), mg_str(\"/*/*\"), caps) == true);\n    ASSERT(mg_strcmp(caps[0], mg_str(\"foo\")) == 0);\n    ASSERT(mg_strcmp(caps[1], mg_str(\"\")) == 0);\n    ASSERT(mg_strcmp(caps[2], mg_str(\"\")) == 0);\n\n    ASSERT(mg_match(mg_str(\"abc\"), mg_str(\"?#\"), caps) == true);\n    ASSERT(mg_strcmp(caps[0], mg_str(\"a\")) == 0);\n    ASSERT(mg_strcmp(caps[1], mg_str(\"bc\")) == 0);\n    ASSERT(mg_strcmp(caps[2], mg_str(\"\")) == 0);\n  }\n}\n\nstatic void test_commalist(void) {\n  struct mg_str k, v, s1 = mg_str(\"\"), s2 = mg_str(\"a\"), s3 = mg_str(\"a,b\");\n  struct mg_str s4 = mg_str(\"a=123\"), s5 = mg_str(\"a,b=123\");\n  ASSERT(mg_commalist(&s1, &k, &v) == false);\n\n  ASSERT(mg_commalist(&s2, &k, &v) == true);\n  ASSERT(v.len == 0 && mg_vcmp(&k, \"a\") == 0);\n  ASSERT(mg_commalist(&s2, &k, &v) == false);\n\n  ASSERT(mg_commalist(&s3, &k, &v) == true);\n  ASSERT(v.len == 0 && mg_vcmp(&k, \"a\") == 0);\n  ASSERT(mg_commalist(&s3, &k, &v) == true);\n  ASSERT(v.len == 0 && mg_vcmp(&k, \"b\") == 0);\n  ASSERT(mg_commalist(&s3, &k, &v) == false);\n\n  ASSERT(mg_commalist(&s4, &k, &v) == true);\n  ASSERT(mg_vcmp(&k, \"a\") == 0 && mg_vcmp(&v, \"123\") == 0);\n  ASSERT(mg_commalist(&s4, &k, &v) == false);\n  ASSERT(mg_commalist(&s4, &k, &v) == false);\n\n  ASSERT(mg_commalist(&s5, &k, &v) == true);\n  ASSERT(v.len == 0 && mg_vcmp(&k, \"a\") == 0);\n  ASSERT(mg_commalist(&s5, &k, &v) == true);\n  ASSERT(mg_vcmp(&k, \"b\") == 0 && mg_vcmp(&v, \"123\") == 0);\n  ASSERT(mg_commalist(&s4, &k, &v) == false);\n}\n\nstatic void test_http_get_var(void) {\n  char buf[256];\n  struct mg_str body;\n  body = mg_str(\"key1=value1&key2=value2&key3=value%203&key4=value+4\");\n  ASSERT(mg_http_get_var(&body, \"key1\", buf, sizeof(buf)) == 6);\n  ASSERT(strcmp(buf, \"value1\") == 0);\n  ASSERT(mg_http_get_var(&body, \"KEY1\", buf, sizeof(buf)) == 6);\n  ASSERT(strcmp(buf, \"value1\") == 0);\n  ASSERT(mg_http_get_var(&body, \"key2\", buf, sizeof(buf)) == 6);\n  ASSERT(strcmp(buf, \"value2\") == 0);\n  ASSERT(mg_http_get_var(&body, \"key3\", buf, sizeof(buf)) == 7);\n  ASSERT(strcmp(buf, \"value 3\") == 0);\n  ASSERT(mg_http_get_var(&body, \"key4\", buf, sizeof(buf)) == 7);\n  ASSERT(strcmp(buf, \"value 4\") == 0);\n\n  ASSERT(mg_http_get_var(&body, \"key\", buf, sizeof(buf)) == -4);\n  ASSERT(mg_http_get_var(&body, \"key1\", NULL, sizeof(buf)) == -2);\n  ASSERT(mg_http_get_var(&body, \"key1\", buf, 0) == -2);\n  ASSERT(mg_http_get_var(&body, NULL, buf, sizeof(buf)) == -1);\n  ASSERT(mg_http_get_var(&body, \"key1\", buf, 1) == -3);\n\n  body = mg_str(\"key=broken%2\");\n  ASSERT(mg_http_get_var(&body, \"key\", buf, sizeof(buf)) == -3);\n\n  body = mg_str(\"key=broken%2x\");\n  ASSERT(mg_http_get_var(&body, \"key\", buf, sizeof(buf)) == -3);\n  ASSERT(mg_http_get_var(&body, \"inexistent\", buf, sizeof(buf)) == -4);\n  body = mg_str(\"key=%\");\n  ASSERT(mg_http_get_var(&body, \"key\", buf, sizeof(buf)) == -3);\n  body = mg_str(\"&&&kEy=%\");\n  ASSERT(mg_http_get_var(&body, \"kEy\", buf, sizeof(buf)) == -3);\n}\n\nstatic int vcmp(struct mg_str s1, const char *s2) {\n  // MG_INFO((\"->%.*s<->%s<- %d %d %d\", (int) s1.len, s1.ptr, s2,\n  //(int) s1.len, strncmp(s1.ptr, s2, s1.len), mg_vcmp(&s1, s2)));\n  return mg_vcmp(&s1, s2) == 0;\n}\n\nstatic void test_url(void) {\n  // Host\n  ASSERT(vcmp(mg_url_host(\"foo\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"//foo\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"foo:1234\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\":1234\"), \"\"));\n  ASSERT(vcmp(mg_url_host(\"//foo:1234\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo/\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo/x\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo/x/\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo/x//\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo//x\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo///x\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo///x//\"), \"foo\"));\n  ASSERT(vcmp(mg_url_host(\"p://bar:1234\"), \"bar\"));\n  ASSERT(vcmp(mg_url_host(\"p://bar:1234/\"), \"bar\"));\n  ASSERT(vcmp(mg_url_host(\"p://bar:1234/a\"), \"bar\"));\n  ASSERT(vcmp(mg_url_host(\"p://u@bar:1234/a\"), \"bar\"));\n  ASSERT(vcmp(mg_url_host(\"p://u:p@bar:1234/a\"), \"bar\"));\n  ASSERT(vcmp(mg_url_host(\"p://u:p@[::1]:1234/a\"), \"[::1]\"));\n  ASSERT(vcmp(mg_url_host(\"p://u:p@[1:2::3]:1234/a\"), \"[1:2::3]\"));\n  ASSERT(vcmp(mg_url_host(\"p://foo/x:y/z\"), \"foo\"));\n\n  // Port\n  ASSERT(mg_url_port(\"foo:1234\") == 1234);\n  ASSERT(mg_url_port(\":1234\") == 1234);\n  ASSERT(mg_url_port(\"x://foo:1234\") == 1234);\n  ASSERT(mg_url_port(\"x://foo:1234/\") == 1234);\n  ASSERT(mg_url_port(\"x://foo:1234/xx\") == 1234);\n  ASSERT(mg_url_port(\"x://foo:1234\") == 1234);\n  ASSERT(mg_url_port(\"p://bar:1234/a\") == 1234);\n  ASSERT(mg_url_port(\"p://bar:1234/a:b\") == 1234);\n  ASSERT(mg_url_port(\"http://bar\") == 80);\n  ASSERT(mg_url_port(\"http://localhost:1234\") == 1234);\n  ASSERT(mg_url_port(\"https://bar\") == 443);\n  ASSERT(mg_url_port(\"wss://bar\") == 443);\n  ASSERT(mg_url_port(\"wss://u:p@bar\") == 443);\n  ASSERT(mg_url_port(\"wss://u:p@bar:123\") == 123);\n  ASSERT(mg_url_port(\"wss://u:p@bar:123/\") == 123);\n  ASSERT(mg_url_port(\"wss://u:p@bar:123/abc\") == 123);\n  ASSERT(mg_url_port(\"http://u:p@[::1]/abc\") == 80);\n  ASSERT(mg_url_port(\"http://u:p@[::1]:2121/abc\") == 2121);\n  ASSERT(mg_url_port(\"http://u:p@[::1]:2121/abc/cd:ef\") == 2121);\n\n  // User / pass\n  ASSERT(vcmp(mg_url_user(\"p://foo\"), \"\"));\n  ASSERT(vcmp(mg_url_pass(\"p://foo\"), \"\"));\n  ASSERT(vcmp(mg_url_user(\"p://:@foo\"), \"\"));\n  ASSERT(vcmp(mg_url_pass(\"p://:@foo\"), \"\"));\n  ASSERT(vcmp(mg_url_user(\"p://u@foo\"), \"u\"));\n  ASSERT(vcmp(mg_url_pass(\"p://u@foo\"), \"\"));\n  ASSERT(vcmp(mg_url_user(\"p://u:@foo\"), \"u\"));\n  ASSERT(vcmp(mg_url_pass(\"p://u:@foo\"), \"\"));\n  ASSERT(vcmp(mg_url_user(\"p://:p@foo\"), \"\"));\n  ASSERT(vcmp(mg_url_pass(\"p://:p@foo\"), \"p\"));\n  ASSERT(vcmp(mg_url_user(\"p://u:p@foo\"), \"u\"));\n  ASSERT(vcmp(mg_url_pass(\"p://u:p@foo\"), \"p\"));\n  ASSERT(vcmp(mg_url_pass(\"p://u:p@foo//a@b\"), \"p\"));\n  ASSERT(vcmp(mg_url_user(\"p://foo/q?mail=a@b.c\"), \"\"));\n  ASSERT(vcmp(mg_url_pass(\"p://foo/q?mail=a@b.c\"), \"\"));\n\n  // URI\n  ASSERT(strcmp(mg_url_uri(\"p://foo\"), \"/\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://foo/\"), \"/\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://foo:12/\"), \"/\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://foo:12/abc\"), \"/abc\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://foo:12/a/b/c\"), \"/a/b/c\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://[::1]:12/a/b/c\"), \"/a/b/c\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://[ab::1]:12/a/b/c\"), \"/a/b/c\") == 0);\n  ASSERT(strcmp(mg_url_uri(\"p://foo/q?mail=a@b.c\"), \"/q?mail=a@b.c\") == 0);\n}\n\nstatic void test_base64(void) {\n  char buf[128];\n\n  ASSERT(mg_base64_encode((uint8_t *) \"\", 0, buf) == 0);\n  ASSERT(strcmp(buf, \"\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"x\", 1, buf) == 4);\n  ASSERT(strcmp(buf, \"eA==\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"xyz\", 3, buf) == 4);\n  ASSERT(strcmp(buf, \"eHl6\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"abcdef\", 6, buf) == 8);\n  ASSERT(strcmp(buf, \"YWJjZGVm\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"\u044b\", 2, buf) == 4);\n  ASSERT(strcmp(buf, \"0Ys=\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"xy\", 3, buf) == 4);\n  ASSERT(strcmp(buf, \"eHkA\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"test\", 4, buf) == 8);\n  ASSERT(strcmp(buf, \"dGVzdA==\") == 0);\n  ASSERT(mg_base64_encode((uint8_t *) \"abcde\", 5, buf) == 8);\n  ASSERT(strcmp(buf, \"YWJjZGU=\") == 0);\n\n  ASSERT(mg_base64_decode(\"\u043a\u044e\", 4, buf) == 0);\n  ASSERT(mg_base64_decode(\"A\", 1, buf) == 0);\n  ASSERT(mg_base64_decode(\"A=\", 2, buf) == 0);\n  ASSERT(mg_base64_decode(\"AA=\", 3, buf) == 0);\n  ASSERT(mg_base64_decode(\"AAA=\", 4, buf) == 2);\n  ASSERT(mg_base64_decode(\"AAAA====\", 8, buf) == 0);\n  ASSERT(mg_base64_decode(\"AAAA----\", 8, buf) == 0);\n  ASSERT(mg_base64_decode(\"Q2VzYW50YQ==\", 12, buf) == 7);\n  ASSERT(strcmp(buf, \"Cesanta\") == 0);\n}\n\nstatic void test_iobuf(void) {\n  struct mg_iobuf io = {0, 0, 0, 10};\n  ASSERT(io.buf == NULL && io.size == 0 && io.len == 0);\n  mg_iobuf_resize(&io, 1);\n  ASSERT(io.buf != NULL && io.size == 10 && io.len == 0);\n  ASSERT(memcmp(io.buf, \"\\x00\", 1) == 0);\n  mg_iobuf_add(&io, 3, \"hi\", 2);\n  ASSERT(io.buf != NULL && io.size == 10 && io.len == 5);\n  ASSERT(memcmp(io.buf, \"\\x00\\x00\\x00hi\", 5) == 0);\n  mg_iobuf_add(&io, io.len, \"!\", 1);\n  ASSERT(io.buf != NULL && io.size == 10 && io.len == 6);\n  ASSERT(memcmp(io.buf, \"\\x00\\x00\\x00hi!\", 6) == 0);\n  mg_iobuf_add(&io, 0, \"x\", 1);\n  ASSERT(memcmp(io.buf, \"x\\x00\\x00\\x00hi!\", 7) == 0);\n  ASSERT(io.buf != NULL && io.size == 10 && io.len == 7);\n  mg_iobuf_del(&io, 1, 3);\n  ASSERT(io.buf != NULL && io.size == 10 && io.len == 4);\n  ASSERT(memcmp(io.buf, \"xhi!\", 3) == 0);\n  mg_iobuf_del(&io, 10, 100);\n  ASSERT(io.buf != NULL && io.size == 10 && io.len == 4);\n  ASSERT(memcmp(io.buf, \"xhi!\", 3) == 0);\n  free(io.buf);\n}\n\nstatic void sntp_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n  if (ev == MG_EV_SNTP_TIME) {\n    int64_t received = *(int64_t *) evd;\n    *(int64_t *) fnd = received;\n    MG_DEBUG((\"got time: %lld\", received));\n#if MG_ARCH == MG_ARCH_UNIX\n    struct timeval tv = {0, 0};\n    gettimeofday(&tv, 0);\n    int64_t ms = (int64_t) tv.tv_sec * 1000 + tv.tv_usec / 1000;\n    int64_t diff = ms > received ? ms - received : received - ms;\n    MG_DEBUG((\"diff: %lld\", diff));\n    // ASSERT(diff < 100);\n#endif\n  } else if (ev == MG_EV_OPEN) {\n    c->is_hexdumping = 1;\n  }\n  (void) c;\n}\n\nstatic void test_sntp_server(const char *url) {\n  int64_t ms = 0;\n  struct mg_mgr mgr;\n  struct mg_connection *c = NULL;\n  int i;\n\n  mg_mgr_init(&mgr);\n  c = mg_sntp_connect(&mgr, url, sntp_cb, &ms);\n  ASSERT(c != NULL);\n  ASSERT(c->is_udp == 1);\n  for (i = 0; i < 60 && ms == 0; i++) mg_mgr_poll(&mgr, 50);\n  MG_DEBUG((\"server: %s, ms: %lld\", url ? url : \"(default)\", ms));\n#if !defined(NO_SNTP_CHECK)\n  ASSERT(ms > 0);\n#endif\n  mg_mgr_free(&mgr);\n}\n\nstatic void test_sntp(void) {\n  const unsigned char bad[] =\n      \"\\x55\\x02\\x00\\xeb\\x00\\x00\\x00\\x1e\\x00\\x00\\x07\\xb6\\x3e\\xc9\\xd6\\xa2\"\n      \"\\xdb\\xde\\xea\\x30\\x91\\x86\\xb7\\x10\\xdb\\xde\\xed\\x98\\x00\\x00\\x00\\xde\"\n      \"\\xdb\\xde\\xed\\x99\\x0a\\xe2\\xc7\\x96\\xdb\\xde\\xed\\x99\\x0a\\xe4\\x6b\\xda\";\n\n  ASSERT(mg_sntp_parse(bad, sizeof(bad)) < 0);\n  ASSERT(mg_sntp_parse(NULL, 0) == -1);\n  // NOTE(cpq): temporarily disabled until Github Actions fix their NTP\n  // port blockage issue, https://github.com/actions/runner-images/issues/5615\n  // test_sntp_server(\"udp://time.apple.com:123\");\n  test_sntp_server(\"udp://time.windows.com:123\");\n  test_sntp_server(NULL);\n}\n\nstruct mqtt_data {\n  char *buf;\n  size_t bufsize;\n  int subscribed;\n  int published;\n};\n\nstatic void mqtt_cb(struct mg_connection *c, int ev, void *evd, void *fnd) {\n  struct mqtt_data *test_data = (struct mqtt_data *) fnd;\n  char *buf = test_data->buf;\n\n  if (ev == MG_EV_MQTT_OPEN) {\n    buf[0] = *(int *) evd == 0 ? 'X' : 'Y';\n  } else if (ev == MG_EV_MQTT_CMD) {\n    struct mg_mqtt_message *mm = (struct mg_mqtt_message *) evd;\n    if (mm->cmd == MQTT_CMD_SUBACK) {\n      test_data->subscribed = 1;\n    }\n    if (mm->cmd == MQTT_CMD_PUBACK) {\n      test_data->published = 1;\n    }\n  } else if (ev == MG_EV_MQTT_MSG) {\n    struct mg_mqtt_message *mm = (struct mg_mqtt_message *) evd;\n    snprintf(buf + 1, test_data->bufsize, \"%.*s/%.*s\", (int) mm->topic.len,\n             mm->topic.ptr, (int) mm->data.len, mm->data.ptr);\n\n    if (mm->cmd == MQTT_CMD_PUBLISH && c->is_mqtt5) {\n      size_t pos = 0;\n      struct mg_mqtt_prop prop;\n\n      // note: the server will send the properties sorted by their ID\n      ASSERT((pos = mg_mqtt_next_prop(mm, &prop, pos)) > 0);\n      ASSERT(prop.iv == 10 && prop.id == MQTT_PROP_MESSAGE_EXPIRY_INTERVAL);\n\n      ASSERT((pos = mg_mqtt_next_prop(mm, &prop, pos)) > 0);\n      ASSERT(prop.id == MQTT_PROP_CONTENT_TYPE);\n      ASSERT(strncmp(prop.val.ptr, \"test_content_val_2\", prop.val.len) == 0 &&\n             prop.val.len == strlen(\"test_content_val_2\"));\n\n      ASSERT((pos = mg_mqtt_next_prop(mm, &prop, pos)) > 0);\n      ASSERT(prop.id == MQTT_PROP_USER_PROPERTY);\n      ASSERT(strncmp(prop.key.ptr, \"test_key_1\", prop.key.len) == 0 &&\n             prop.key.len == strlen(\"test_key_1\"));\n      ASSERT(strncmp(prop.val.ptr, \"test_value_1\", prop.val.len) == 0 &&\n             prop.val.len == strlen(\"test_value_1\"));\n\n      ASSERT((pos = mg_mqtt_next_prop(mm, &prop, pos)) > 0);\n      ASSERT(prop.id == MQTT_PROP_USER_PROPERTY);\n      ASSERT(strncmp(prop.key.ptr, \"test_key_2\", prop.key.len) == 0 &&\n             prop.key.len == strlen(\"test_key_2\"));\n      ASSERT(strncmp(prop.val.ptr, \"test_value_2\", prop.val.len) == 0 &&\n             prop.val.len == strlen(\"test_value_2\"));\n\n      ASSERT((pos = mg_mqtt_next_prop(mm, &prop, pos)) == 0);\n    }\n  }\n  (void) c;\n}\n\nstatic void construct_props(struct mg_mqtt_prop *props) {\n  props[0].id = MQTT_PROP_MESSAGE_EXPIRY_INTERVAL;\n  props[0].iv = 10;\n\n  props[1].id = MQTT_PROP_USER_PROPERTY;\n  props[1].key = mg_str(\"test_key_1\");\n  props[1].val = mg_str(\"test_value_1\");\n\n  props[2].id = MQTT_PROP_USER_PROPERTY;\n  props[2].key = mg_str(\"test_key_2\");\n  props[2].val = mg_str(\"test_value_2\");\n\n  props[3].id = MQTT_PROP_CONTENT_TYPE;\n  props[3].val = mg_str(\"test_content_val_2\");\n}\n\nstatic void test_mqtt_base(void);\nstatic void test_mqtt_base(void) {\n  char buf[50] = {0};\n  struct mqtt_data test_data = {buf, 50, 0, 0};\n  struct mg_mgr mgr;\n  struct mg_connection *c;\n  const char *url = \"mqtt://broker.hivemq.com:1883\";\n  int i;\n  mg_mgr_init(&mgr);\n\n  // Ping the client\n  c = mg_mqtt_connect(&mgr, url, NULL, mqtt_cb, &test_data);\n  mg_mqtt_ping(c);\n  for (i = 0; i < 300 && !(c->is_client && !c->is_connecting); i++)\n    mg_mgr_poll(&mgr, 10);\n  ASSERT(c->is_client && !c->is_connecting);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_mqtt_ver(uint8_t mqtt_version) {\n  char buf[50] = {0}, client_id[16], will_topic[16];\n  struct mqtt_data test_data = {buf, 50, 0, 0};\n  struct mg_mgr mgr;\n  struct mg_str topic = mg_str(\"x/f12\"), data = mg_str(\"hi\");\n  struct mg_connection *c;\n  struct mg_mqtt_opts opts;\n  struct mg_mqtt_prop properties[4];\n  const char *url = \"mqtt://broker.hivemq.com:1883\";\n  int i;\n  mg_mgr_init(&mgr);\n\n  // Connect with empty client ID\n  c = mg_mqtt_connect(&mgr, url, NULL, mqtt_cb, &test_data);\n  for (i = 0; i < 300 && buf[0] == 0; i++) mg_mgr_poll(&mgr, 10);\n  if (buf[0] != 'X') MG_INFO((\"[%s]\", buf));\n  ASSERT(buf[0] == 'X');\n  ASSERT(test_data.subscribed == 0);\n\n  opts.topic = topic, opts.qos = 1;\n  mg_mqtt_sub(c, &opts);\n  for (i = 0; i < 500 && test_data.subscribed == 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(test_data.subscribed == 1);\n  ASSERT(test_data.published == 0);\n\n  opts.topic = topic, opts.message = data, opts.qos = 1, opts.retain = false;\n  mg_mqtt_pub(c, &opts);\n  for (i = 0; i < 500 && test_data.published == 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(test_data.published == 1);\n  for (i = 0; i < 500 && buf[1] == 0; i++) mg_mgr_poll(&mgr, 10);\n  if (strcmp(buf, \"Xx/f12/hi\") != 0) MG_INFO((\"[%s]\", buf));\n  ASSERT(strcmp(buf, \"Xx/f12/hi\") == 0);\n\n  // Set params\n  test_data.subscribed = 0;\n  test_data.published = 0;\n  memset(buf, 0, sizeof(buf));\n  memset(&opts, 0, sizeof(opts));\n\n  opts.clean = true, opts.qos = 1, opts.retain = true, opts.keepalive = 20;\n  opts.version = mqtt_version;\n  opts.topic = mg_str(mg_random_str(will_topic, sizeof(will_topic)));\n  opts.message = mg_str(\"mg_will_messsage\");\n  opts.client_id = mg_str(mg_random_str(client_id, sizeof(client_id)));\n  c = mg_mqtt_connect(&mgr, url, &opts, mqtt_cb, &test_data);\n  for (i = 0; i < 300 && buf[0] == 0; i++) mg_mgr_poll(&mgr, 10);\n  if (buf[0] != 'X') MG_INFO((\"[%s]\", buf));\n  ASSERT(buf[0] == 'X');\n  ASSERT(test_data.subscribed == 0);\n\n  opts.topic = topic, opts.qos = 1;\n  mg_mqtt_sub(c, &opts);\n  for (i = 0; i < 500 && test_data.subscribed == 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(test_data.subscribed == 1);\n  ASSERT(test_data.published == 0);\n\n  opts.topic = topic, opts.message = data, opts.qos = 1, opts.retain = false;\n  if (mqtt_version == 5) {\n    opts.props = properties;\n    opts.num_props = 4;\n    construct_props(properties);\n  }\n\n  mg_mqtt_pub(c, &opts);\n  for (i = 0; i < 500 && test_data.published == 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(test_data.published == 1);\n  for (i = 0; i < 500 && buf[1] == 0; i++) mg_mgr_poll(&mgr, 10);\n  if (strcmp(buf, \"Xx/f12/hi\") != 0) MG_INFO((\"[%s]\", buf));\n  ASSERT(strcmp(buf, \"Xx/f12/hi\") == 0);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_mqtt(void) {\n  test_mqtt_base();\n  test_mqtt_ver(4);\n  test_mqtt_ver(5);\n  test_mqtt_base();\n}\n\nstatic void eh1(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  struct mg_tls_opts *topts = (struct mg_tls_opts *) fn_data;\n  if (ev == MG_EV_ACCEPT && topts != NULL) mg_tls_init(c, topts);\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    MG_INFO((\"[%.*s %.*s] message len %d\", (int) hm->method.len, hm->method.ptr,\n             (int) hm->uri.len, hm->uri.ptr, (int) hm->message.len));\n    if (mg_http_match_uri(hm, \"/foo/*\")) {\n      mg_http_reply(c, 200, \"\", \"uri: %.*s\", hm->uri.len - 5, hm->uri.ptr + 5);\n    } else if (mg_http_match_uri(hm, \"/ws\")) {\n      mg_ws_upgrade(c, hm, NULL);\n    } else if (mg_http_match_uri(hm, \"/body\")) {\n      mg_http_reply(c, 200, \"\", \"%.*s\", (int) hm->body.len, hm->body.ptr);\n    } else if (mg_http_match_uri(hm, \"/bar\")) {\n      mg_http_reply(c, 404, \"\", \"not found\");\n    } else if (mg_http_match_uri(hm, \"/no_reason\")) {\n      mg_printf(c, \"%s\", \"HTTP/1.0 200\\r\\nContent-Length: 2\\r\\n\\r\\nok\");\n    } else if (mg_http_match_uri(hm, \"/badroot\")) {\n      struct mg_http_serve_opts sopts;\n      memset(&sopts, 0, sizeof(sopts));\n      sopts.root_dir = \"/BAAADDD!\";\n      mg_http_serve_dir(c, hm, &sopts);\n    } else if (mg_http_match_uri(hm, \"/creds\")) {\n      char user[100], pass[100];\n      mg_http_creds(hm, user, sizeof(user), pass, sizeof(pass));\n      mg_http_reply(c, 200, \"\", \"[%s]:[%s]\", user, pass);\n    } else if (mg_http_match_uri(hm, \"/upload\")) {\n      char path[80], name[64];\n      mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n      if (name[0] == '\\0') {\n        mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n      } else {\n        mg_snprintf(path, sizeof(path), \"./%s\", name);\n        mg_http_upload(c, hm, &mg_fs_posix, mg_remove_double_dots(path), 99999);\n        c->is_hexdumping = 1;\n      }\n    } else if (mg_http_match_uri(hm, \"/test/\")) {\n      struct mg_http_serve_opts sopts;\n      memset(&sopts, 0, sizeof(sopts));\n      sopts.root_dir = \".\";\n      sopts.extra_headers = \"A: B\\r\\nC: D\\r\\n\";\n      mg_http_serve_dir(c, hm, &sopts);\n    } else if (mg_http_match_uri(hm, \"/servefile\")) {\n      struct mg_http_serve_opts sopts;\n      memset(&sopts, 0, sizeof(sopts));\n      sopts.mime_types = \"foo=a/b,txt=c/d\";\n      mg_http_serve_file(c, hm, \"test/data/a.txt\", &sopts);\n    } else {\n      struct mg_http_serve_opts sopts;\n      memset(&sopts, 0, sizeof(sopts));\n      sopts.root_dir = \"./test/data\";\n      sopts.ssi_pattern = \"#.shtml\";\n      sopts.extra_headers = \"C: D\\r\\n\";\n      mg_http_serve_dir(c, hm, &sopts);\n    }\n  } else if (ev == MG_EV_WS_OPEN) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    ASSERT(mg_strcmp(hm->uri, mg_str(\"/ws\")) == 0);\n    mg_ws_send(c, \"opened\", 6, WEBSOCKET_OP_BINARY);\n  } else if (ev == MG_EV_WS_MSG) {\n    struct mg_ws_message *wm = (struct mg_ws_message *) ev_data;\n    mg_ws_send(c, wm->data.ptr, wm->data.len, WEBSOCKET_OP_BINARY);\n  }\n}\n\nstruct fetch_data {\n  char *buf;\n  int code, closed;\n};\n\nstatic void fcb(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  struct fetch_data *fd = (struct fetch_data *) fn_data;\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    snprintf(fd->buf, FETCH_BUF_SIZE, \"%.*s\", (int) hm->message.len,\n             hm->message.ptr);\n    fd->code = atoi(hm->uri.ptr);\n    fd->closed = 1;\n    c->is_closing = 1;\n    (void) c;\n  } else if (ev == MG_EV_CLOSE) {\n    fd->closed = 1;\n  }\n}\n\nstatic int fetch(struct mg_mgr *mgr, char *buf, const char *url,\n                 const char *fmt, ...) {\n  struct fetch_data fd = {buf, 0, 0};\n  int i;\n  struct mg_connection *c = mg_http_connect(mgr, url, fcb, &fd);\n  va_list ap;\n  ASSERT(c != NULL);\n  if (mg_url_is_ssl(url)) {\n    struct mg_tls_opts opts;\n    struct mg_str host = mg_url_host(url);\n    memset(&opts, 0, sizeof(opts));\n    opts.ca = \"./test/data/ca.pem\";\n    if (strstr(url, \"127.0.0.1\") != NULL) {\n      // Local connection, use self-signed certificates\n      opts.ca = \"./test/data/ss_ca.pem\";\n      opts.cert = \"./test/data/ss_client.pem\";\n    } else {\n      opts.srvname = host;\n    }\n    mg_tls_init(c, &opts);\n    if (c->tls == NULL) fd.closed = 1;\n  }\n  // c->is_hexdumping = 1;\n  va_start(ap, fmt);\n  mg_vprintf(c, fmt, &ap);\n  va_end(ap);\n  buf[0] = '\\0';\n  for (i = 0; i < 50 && buf[0] == '\\0'; i++) mg_mgr_poll(mgr, 1);\n  if (!fd.closed) c->is_closing = 1;\n  mg_mgr_poll(mgr, 1);\n  return fd.code;\n}\n\nstatic struct mg_http_message gethm(const char *buf) {\n  struct mg_http_message hm;\n  memset(&hm, 0, sizeof(hm));\n  mg_http_parse(buf, strlen(buf), &hm);\n  return hm;\n}\n\nstatic int cmpbody(const char *buf, const char *str) {\n  struct mg_str s = mg_str(str);\n  struct mg_http_message hm = gethm(buf);\n  size_t len = strlen(buf);\n  mg_http_parse(buf, len, &hm);\n  if (hm.body.len > len) hm.body.len = len - (size_t) (hm.body.ptr - buf);\n  return mg_strcmp(hm.body, s);\n}\n\nstatic bool cmpheader(const char *buf, const char *name, const char *value) {\n  struct mg_http_message hm = gethm(buf);\n  struct mg_str *h = mg_http_get_header(&hm, name);\n  return h != NULL && mg_strcmp(*h, mg_str(value)) == 0;\n}\n\nstatic void wcb(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  int *p = (int *) fn_data;\n  if (ev == MG_EV_WS_OPEN) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    struct mg_str *wsproto = mg_http_get_header(hm, \"Sec-WebSocket-Protocol\");\n    ASSERT(wsproto != NULL);\n    mg_ws_printf(c, WEBSOCKET_OP_BINARY, \"%.3s\", \"boo!!!!\");\n    mg_ws_printf(c, WEBSOCKET_OP_BINARY, \"%s\", \"foobar\");\n    mg_ws_send(c, \"\", 0, WEBSOCKET_OP_PING);\n    p[0] += 100;\n  } else if (ev == MG_EV_WS_MSG) {\n    struct mg_ws_message *wm = (struct mg_ws_message *) ev_data;\n    if (mg_strstr(wm->data, mg_str(\"foobar\")))\n      mg_ws_send(c, \"\", 0, WEBSOCKET_OP_CLOSE);\n    if (mg_strstr(wm->data, mg_str(\"boo\"))) p[0] += 2;\n    if (mg_strstr(wm->data, mg_str(\"foobar\"))) p[0] += 3;\n  } else if (ev == MG_EV_CLOSE) {\n    p[0] += 10;\n  }\n}\n\nstatic void ew2(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  size_t size = 65 * 1024 + 737;\n  if (ev == MG_EV_WS_OPEN) {\n    char *msg = (char *) calloc(1, size + 1);\n    memset(msg, 'A', size);\n    mg_ws_printf(c, WEBSOCKET_OP_TEXT, \"%s\", msg);\n    free(msg);\n  } else if (ev == MG_EV_WS_MSG) {\n    struct mg_ws_message *wm = (struct mg_ws_message *) ev_data;\n    if (wm->data.len == 6) {\n      // Ignore the \"opened\" message from server\n    } else {\n      size_t ok = 1, i;\n      ASSERT(wm->data.len == size);\n      for (i = 0; i < size; i++) {\n        if (wm->data.ptr[i] != 'A') ok = 0;\n      }\n      ASSERT(ok == 1);\n      *(int *) fn_data = 1;\n    }\n  }\n}\n\nstatic void test_ws(void) {\n  char buf[FETCH_BUF_SIZE];\n  const char *url = \"ws://LOCALHOST:12343/ws\";\n  struct mg_mgr mgr;\n  int i, done = 0;\n\n  mg_mgr_init(&mgr);\n  ASSERT(mg_http_listen(&mgr, url, eh1, NULL) != NULL);\n  mg_ws_connect(&mgr, url, wcb, &done, \"%s\", \"Sec-WebSocket-Protocol: meh\\r\\n\");\n  for (i = 0; i < 30; i++) mg_mgr_poll(&mgr, 1);\n  // MG_INFO((\"--> %d\", done));\n  ASSERT(done == 115);\n\n  // Test that non-WS requests fail\n  ASSERT(fetch(&mgr, buf, url, \"GET /ws HTTP/1.0\\r\\n\\n\") == 426);\n\n  // Test large WS frames, over 64k\n  done = 0;\n  mg_ws_connect(&mgr, url, ew2, &done, NULL);\n  for (i = 0; i < 1000 && done == 0; i++) mg_mgr_poll(&mgr, 1);\n  ASSERT(done == 1);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void eh9(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_ERROR) {\n    ASSERT(!strcmp((char *) ev_data, \"socket error\"));\n    *(int *) fn_data = 7;\n  }\n  (void) c;\n}\n\nstatic void test_http_server(void) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12346\";\n  char buf[FETCH_BUF_SIZE];\n\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, eh1, NULL);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /%%61.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n\n  // Responses with missing reason phrase must also work\n  ASSERT(fetch(&mgr, buf, url, \"GET /no_reason HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"ok\") == 0);\n\n  // Fetch file with unicode chars in filename\n  ASSERT(fetch(&mgr, buf, url, \"GET /\u043a\u0438\u0457\u0432.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"\u0454\\n\") == 0);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /../fuzz.c HTTP/1.0\\n\\n\") == 404);\n  ASSERT(fetch(&mgr, buf, url, \"GET /.%%2e/fuzz.c HTTP/1.0\\n\\n\") == 404);\n  ASSERT(fetch(&mgr, buf, url, \"GET /.%%2e%%2ffuzz.c HTTP/1.0\\n\\n\") == 404);\n  ASSERT(fetch(&mgr, buf, url, \"GET /..%%2f%%20fuzz.c HTTP/1.0\\n\\n\") == 404);\n  ASSERT(fetch(&mgr, buf, url, \"GET /..%%2ffuzz.c%%20 HTTP/1.0\\n\\n\") == 404);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /dredir HTTP/1.0\\n\\n\") == 301);\n  ASSERT(cmpheader(buf, \"Location\", \"/dredir/\"));\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /dredir/ HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hi\\n\") == 0);\n\n  ASSERT(fetch(&mgr, buf, url,\n               \"GET /dredirgz/ HTTP/1.0\\n\"\n               \"Accept-Encoding: gzip\\n\\n\") == 200);\n  ASSERT(cmpheader(buf, \"Content-Type\", \"text/html; charset=utf-8\"));\n  ASSERT(cmpheader(buf, \"Content-Encoding\", \"gzip\"));\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /gzip.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hi\\n\") == 0);\n  ASSERT(gethm(buf).body.len == 3);\n  ASSERT(cmpheader(buf, \"Content-Encoding\", \"gzip\") == false);\n\n  ASSERT(fetch(&mgr, buf, url,\n               \"GET /gzip.txt HTTP/1.0\\n\"\n               \"Accept-Encoding: foo,gzip\\n\\n\") == 200);\n  mg_hexdump(buf, strlen(buf));\n  ASSERT(cmpheader(buf, \"Content-Encoding\", \"gzip\") == true);\n  ASSERT(gethm(buf).body.len == 23);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /..ddot HTTP/1.0\\n\\n\") == 301);\n  ASSERT(fetch(&mgr, buf, url, \"GET /..ddot/ HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hi\\n\") == 0);\n  ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\"\n        \"Content-Length: -123\\n\\n\") == 0);\n  ASSERT(fetch(&mgr, buf, url, \"POST /a.txt HTTP/1.0\\n\"\n               \"Content-Length: -123\\n\\n\") == 0);\n\n  {\n    extern char *mg_http_etag(char *, size_t, size_t, time_t);\n    struct mg_http_message hm;\n    char etag[100];\n    size_t size = 0;\n    time_t mtime = 0;\n    ASSERT(mg_fs_posix.st(\"./test/data/a.txt\", &size, &mtime) != 0);\n    ASSERT(mg_http_etag(etag, sizeof(etag), size, mtime) == etag);\n    ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\nIf-None-Match: %s\\n\\n\",\n                 etag) == 304);\n    ASSERT(mg_http_parse(buf, strlen(buf), &hm) > 0);\n    MG_INFO((\"%s\", buf));\n    ASSERT(mg_http_get_header(&hm, \"C\") != NULL);\n    ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"C\"), mg_str(\"D\")) == 0);\n  }\n\n  // Text mime type override\n  ASSERT(fetch(&mgr, buf, url, \"GET /servefile HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n  {\n    struct mg_http_message hm;\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_http_get_header(&hm, \"Content-Type\") != NULL);\n    ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Type\"), mg_str(\"c/d\")) ==\n           0);\n  }\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /foo/1 HTTP/1.0\\r\\n\\n\") == 200);\n  // MG_INFO((\"%d %.*s\", (int) hm.len, (int) hm.len, hm.buf));\n  ASSERT(cmpbody(buf, \"uri: 1\") == 0);\n\n  ASSERT(fetch(&mgr, buf, url, \"%s\",\n               \"POST /body HTTP/1.1\\r\\n\"\n               \"Content-Length: 4\\r\\n\\r\\nkuku\") == 200);\n  ASSERT(cmpbody(buf, \"kuku\") == 0);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /ssi HTTP/1.1\\r\\n\\r\\n\") == 301);\n  ASSERT(fetch(&mgr, buf, url, \"GET /ssi/ HTTP/1.1\\r\\n\\r\\n\") == 200);\n  ASSERT(cmpbody(buf,\n                 \"this is index\\n\"\n                 \"this is nested\\n\\n\"\n                 \"this is f1\\n\\n\\n\\n\"\n                 \"recurse\\n\\n\"\n                 \"recurse\\n\\n\"\n                 \"recurse\\n\\n\"\n                 \"recurse\\n\\n\"\n                 \"recurse\\n\\n\") == 0);\n  {\n    struct mg_http_message hm;\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_http_get_header(&hm, \"Content-Length\") != NULL);\n    ASSERT(mg_http_get_header(&hm, \"Content-Type\") != NULL);\n    ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Type\"),\n                     mg_str(\"text/html; charset=utf-8\")) == 0);\n  }\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /badroot HTTP/1.0\\r\\n\\n\") == 404);\n  // ASSERT(cmpbody(buf, \"Invalid web root [/BAAADDD!]\\n\") == 0);\n\n  {\n    char *data = mg_file_read(&mg_fs_posix, \"./test/data/ca.pem\", NULL);\n    ASSERT(fetch(&mgr, buf, url, \"GET /ca.pem HTTP/1.0\\r\\n\\n\") == 200);\n    ASSERT(cmpbody(buf, data) == 0);\n    free(data);\n  }\n\n  {\n    // Test mime type\n    struct mg_http_message hm;\n    ASSERT(fetch(&mgr, buf, url, \"GET /empty.js HTTP/1.0\\r\\n\\n\") == 200);\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_http_get_header(&hm, \"Content-Type\") != NULL);\n    ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Type\"),\n                     mg_str(\"text/javascript; charset=utf-8\")) == 0);\n  }\n\n  {\n    // Test connection refused\n    int i, errored = 0;\n    mg_connect(&mgr, \"tcp://127.0.0.1:55117\", eh9, &errored);\n    // Give it a couple of seconds, see #1605\n    for (i = 0; i < 200 && errored == 0; i++) mg_mgr_poll(&mgr, 10);\n    MG_INFO((\"errored: %d, expected: 7\", errored));\n    ASSERT(errored == 7);\n  }\n\n  // Directory listing\n  fetch(&mgr, buf, url, \"GET /test/ HTTP/1.0\\n\\n\");\n  ASSERT(fetch(&mgr, buf, url, \"GET /test/ HTTP/1.0\\n\\n\") == 200);\n  ASSERT(mg_strstr(mg_str(buf), mg_str(\">Index of /test/<\")) != NULL);\n  ASSERT(mg_strstr(mg_str(buf), mg_str(\">fuzz.c<\")) != NULL);\n\n  {\n    // Credentials\n    struct mg_http_message hm;\n    ASSERT(fetch(&mgr, buf, url, \"%s\",\n                 \"GET /creds?access_token=x HTTP/1.0\\r\\n\\r\\n\") == 200);\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_strcmp(hm.body, mg_str(\"[]:[x]\")) == 0);\n\n    ASSERT(fetch(&mgr, buf, url, \"%s\",\n                 \"GET /creds HTTP/1.0\\r\\n\"\n                 \"Authorization: Bearer x\\r\\n\\r\\n\") == 200);\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_strcmp(hm.body, mg_str(\"[]:[x]\")) == 0);\n\n    ASSERT(fetch(&mgr, buf, url, \"%s\",\n                 \"GET /creds HTTP/1.0\\r\\n\"\n                 \"Authorization: Basic Zm9vOmJhcg==\\r\\n\\r\\n\") == 200);\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_strcmp(hm.body, mg_str(\"[foo]:[bar]\")) == 0);\n\n    ASSERT(fetch(&mgr, buf, url, \"%s\",\n                 \"GET /creds HTTP/1.0\\r\\n\"\n                 \"Cookie: blah; access_token=hello\\r\\n\\r\\n\") == 200);\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_strcmp(hm.body, mg_str(\"[]:[hello]\")) == 0);\n  }\n\n  {\n    // Test upload\n    char *p;\n    remove(\"uploaded.txt\");\n    ASSERT((p = mg_file_read(&mg_fs_posix, \"uploaded.txt\", NULL)) == NULL);\n    ASSERT(fetch(&mgr, buf, url,\n                 \"POST /upload HTTP/1.0\\n\"\n                 \"Content-Length: 1\\n\\nx\") == 400);\n\n    ASSERT(fetch(&mgr, buf, url,\n                 \"POST /upload?name=uploaded.txt HTTP/1.0\\r\\n\"\n                 \"Content-Length: 5\\r\\n\"\n                 \"\\r\\nhello\") == 200);\n    ASSERT(fetch(&mgr, buf, url,\n                 \"POST /upload?name=uploaded.txt&offset=5 HTTP/1.0\\r\\n\"\n                 \"Content-Length: 6\\r\\n\"\n                 \"\\r\\n\\nworld\") == 200);\n    ASSERT((p = mg_file_read(&mg_fs_posix, \"uploaded.txt\", NULL)) != NULL);\n    ASSERT(strcmp(p, \"hello\\nworld\") == 0);\n    free(p);\n    remove(\"uploaded.txt\");\n  }\n\n  {\n    // Test upload directory traversal\n    char *p;\n    remove(\"uploaded.txt\");\n    ASSERT((p = mg_file_read(&mg_fs_posix, \"uploaded.txt\", NULL)) == NULL);\n    ASSERT(fetch(&mgr, buf, url,\n                 \"POST /upload?name=../uploaded.txt HTTP/1.0\\r\\n\"\n                 \"Content-Length: 5\\r\\n\"\n                 \"\\r\\nhello\") == 200);\n    ASSERT((p = mg_file_read(&mg_fs_posix, \"uploaded.txt\", NULL)) != NULL);\n    ASSERT(strcmp(p, \"hello\") == 0);\n    free(p);\n    remove(\"uploaded.txt\");\n  }\n\n  // HEAD request\n  ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(fetch(&mgr, buf, url, \"HEAD /a.txt HTTP/1.0\\n\\n\") == 200);\n\n  // Pre-compressed files\n  {\n    struct mg_http_message hm;\n    ASSERT(fetch(&mgr, buf, url,\n                 \"HEAD /hello.txt HTTP/1.0\\n\"\n                 \"Accept-Encoding: gzip\\n\\n\") == 200);\n    mg_http_parse(buf, strlen(buf), &hm);\n    ASSERT(mg_http_get_header(&hm, \"Content-Encoding\") != NULL);\n    ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Encoding\"),\n                     mg_str(\"gzip\")) == 0);\n  }\n\n#if MG_ENABLE_IPV6\n  {\n    const char *url6 = \"http://[::1]:12366\";\n    ASSERT(mg_http_listen(&mgr, url6, eh1, NULL) != NULL);\n    ASSERT(fetch(&mgr, buf, url6, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n    ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n  }\n#endif\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void h4(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    MG_INFO((\"[%.*s %.*s] message len %d\", (int) hm->method.len, hm->method.ptr,\n             (int) hm->uri.len, hm->uri.ptr, (int) hm->message.len));\n    if (mg_http_match_uri(hm, \"/a/#\")) {\n      struct mg_http_serve_opts opts;\n      memset(&opts, 0, sizeof(opts));\n      opts.root_dir = \"/a=./test/data\";\n      opts.page404 = \"./test/data/404.html\";  // existing 404 page\n      mg_http_serve_dir(c, hm, &opts);\n    } else if (mg_http_match_uri(hm, \"/b/#\")) {\n      struct mg_http_serve_opts opts;\n      memset(&opts, 0, sizeof(opts));\n      opts.root_dir = \"/b=./test/data\";\n      opts.page404 = \"./test/data/nooooo.html\";  // non-existing 404 page\n      mg_http_serve_dir(c, hm, &opts);\n    } else {  // null 404 page\n      struct mg_http_serve_opts opts;\n      memset(&opts, 0, sizeof(opts));\n      opts.root_dir = \"./test/data\";\n      mg_http_serve_dir(c, hm, &opts);\n    }\n  }\n  (void) fn_data;\n}\n\nstatic void test_http_404(void) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:22343\";\n  char buf[FETCH_BUF_SIZE];\n\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, h4, NULL);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n  ASSERT(fetch(&mgr, buf, url, \"GET /a/a.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n  ASSERT(fetch(&mgr, buf, url, \"GET /b/a.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /xx.txt HTTP/1.0\\n\\n\") == 404);\n  ASSERT(cmpbody(buf, \"Not found\\n\") == 0);\n  ASSERT(fetch(&mgr, buf, url, \"GET /a/xx.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"boo\\n\") == 0);\n  ASSERT(fetch(&mgr, buf, url, \"GET /b/xx.txt HTTP/1.0\\n\\n\") == 404);\n  ASSERT(cmpbody(buf, \"Not found\\n\") == 0);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_tls(void) {\n#if MG_ENABLE_MBEDTLS || MG_ENABLE_OPENSSL\n  struct mg_tls_opts opts = {\"./test/data/ss_ca.pem\",\n                             NULL,\n                             \"./test/data/ss_server.pem\",\n                             \"./test/data/ss_server.pem\",\n                             NULL,\n                             {0, 0},\n                             NULL};\n  struct mg_mgr mgr;\n  struct mg_connection *c;\n  const char *url = \"https://127.0.0.1:12347\";\n  char buf[FETCH_BUF_SIZE];\n  mg_mgr_init(&mgr);\n  c = mg_http_listen(&mgr, url, eh1, (void *) &opts);\n  ASSERT(c != NULL);\n  ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n  // MG_INFO((\"%s\", buf));\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n#endif\n}\n\nstatic void f3(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  int *ok = (int *) fn_data;\n  // MG_INFO((\"%d\", ev));\n  if (ev == MG_EV_CONNECT) {\n    // c->is_hexdumping = 1;\n    mg_printf(c, \"GET /%s HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n\",\n              c->rem.is_ip6 ? \"\" : \"/robots.txt\",\n              c->rem.is_ip6 ? \"ipv6.google.com\" : \"cesanta.com\");\n  } else if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    // MG_INFO((\"-->[%.*s]\", (int) hm->message.len, hm->message.ptr));\n    // ASSERT(mg_vcmp(&hm->method, \"HTTP/1.1\") == 0);\n    // ASSERT(mg_vcmp(&hm->uri, \"301\") == 0);\n    *ok = mg_http_status(hm);\n  } else if (ev == MG_EV_CLOSE) {\n    if (*ok == 0) *ok = 888;\n  } else if (ev == MG_EV_ERROR) {\n    if (*ok == 0) *ok = 777;\n  }\n}\n\nstatic void test_http_client(void) {\n  struct mg_mgr mgr;\n  struct mg_connection *c;\n  int i, ok = 0;\n  mg_mgr_init(&mgr);\n  c = mg_http_connect(&mgr, \"http://cesanta.com\", f3, &ok);\n  ASSERT(c != NULL);\n  for (i = 0; i < 500 && ok <= 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(ok == 301);\n  c->is_closing = 1;\n  mg_mgr_poll(&mgr, 0);\n  ok = 0;\n#if MG_ENABLE_MBEDTLS || MG_ENABLE_OPENSSL\n  {\n    const char *url = \"https://cesanta.com\";\n    struct mg_str host = mg_url_host(url);\n    struct mg_tls_opts opts = {\n        \"./test/data/ca.pem\", NULL, NULL, NULL, NULL, host, NULL};\n    c = mg_http_connect(&mgr, url, f3, &ok);\n    ASSERT(c != NULL);\n    mg_tls_init(c, &opts);\n    for (i = 0; i < 1500 && ok <= 0; i++) mg_mgr_poll(&mgr, 1000);\n    ASSERT(ok == 200);\n    c->is_closing = 1;\n    mg_mgr_poll(&mgr, 1);\n\n    // Test failed host validation\n    ok = 0;\n    opts.srvname = mg_str(\"dummy\");\n    c = mg_http_connect(&mgr, url, f3, &ok);\n    ASSERT(c != NULL);\n    mg_tls_init(c, &opts);\n    for (i = 0; i < 500 && ok <= 0; i++) mg_mgr_poll(&mgr, 10);\n    ASSERT(ok == 777);\n    mg_mgr_poll(&mgr, 1);\n\n    // Test host validation only (no CA, no cert)\n    ok = 0;\n    opts.srvname = host;\n    opts.ca = NULL;\n    c = mg_http_connect(&mgr, url, f3, &ok);\n    ASSERT(c != NULL);\n    mg_tls_init(c, &opts);\n    for (i = 0; i < 1500 && ok <= 0; i++) mg_mgr_poll(&mgr, 10);\n    ASSERT(ok == 200);\n    c->is_closing = 1;\n    mg_mgr_poll(&mgr, 1);\n  }\n#endif\n\n#if MG_ENABLE_IPV6\n  ok = 0;\n  // ipv6.google.com does not have IPv4 address, only IPv6, therefore\n  // it is guaranteed to hit IPv6 resolution path.\n  c = mg_http_connect(&mgr, \"http://ipv6.google.com\", f3, &ok);\n  for (i = 0; i < 500 && ok <= 0; i++) mg_mgr_poll(&mgr, 10);\n  ASSERT(ok == 200);\n#endif\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void f4(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    mg_printf(c, \"HTTP/1.0 200 OK\\n\\n%.*s/%s\", (int) hm->uri.len, hm->uri.ptr,\n              \"abcdef\");\n    strcat((char *) fn_data, \"m\");\n    c->is_draining = 1;\n  } else if (ev == MG_EV_HTTP_CHUNK) {\n    strcat((char *) fn_data, \"f\");\n  } else if (ev == MG_EV_CLOSE) {\n    strcat((char *) fn_data, \"c\");\n  }\n}\n\nstatic void f4c(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_CONNECT) {\n    mg_printf(c, \"GET /foo/bar HTTP/1.0\\n\\n\");\n  } else if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    ASSERT(mg_strcmp(hm->body, mg_str(\"/foo/bar/abcdef\")) == 0);\n    strcat((char *) fn_data, \"m\");\n  } else if (ev == MG_EV_HTTP_CHUNK) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    MG_INFO((\"FS [%.*s]\", (int) hm->chunk.len, hm->chunk.ptr));\n    strcat((char *) fn_data, \"f\");\n  } else if (ev == MG_EV_CLOSE) {\n    strcat((char *) fn_data, \"c\");\n  }\n}\n\nstatic void test_http_no_content_length(void) {\n  char buf1[10] = {0}, buf2[10] = {0};\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12348\";\n  int i;\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, f4, (void *) buf1);\n  mg_http_connect(&mgr, url, f4c, (void *) buf2);\n  for (i = 0; i < 1000 && strchr(buf2, 'c') == NULL; i++) mg_mgr_poll(&mgr, 10);\n  MG_INFO((\"[%s] [%s]\", buf1, buf2));\n  ASSERT(strcmp(buf1, \"fmc\") == 0);\n  ASSERT(strcmp(buf2, \"fcfm\") == 0);  // See #1475\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void f5(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    mg_http_reply(c, 200, \"\", \"%.*s\", (int) hm->uri.len, hm->uri.ptr);\n    (*(int *) fn_data)++;\n  }\n}\n\nstatic void test_http_pipeline(void) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12377\";\n  struct mg_connection *c;\n  int i, ok = 0;\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, f5, (void *) &ok);\n  c = mg_http_connect(&mgr, url, NULL, NULL);\n  mg_printf(c, \"POST / HTTP/1.0\\nContent-Length: 5\\n\\n12345GET / HTTP/1.0\\n\\n\");\n  for (i = 0; i < 20; i++) mg_mgr_poll(&mgr, 1);\n  // MG_INFO((\"-----> [%d]\", ok));\n  ASSERT(ok == 2);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_http_parse(void) {\n  struct mg_str *v;\n  struct mg_http_message req;\n\n  {\n    const char *s = \"GET / HTTP/1.0\\n\\n\";\n    ASSERT(mg_http_parse(\"\\b23\", 3, &req) == -1);\n    ASSERT(mg_http_parse(\"get\\n\\n\", 5, &req) == -1);\n    ASSERT(mg_http_parse(s, strlen(s) - 1, &req) == 0);\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT(req.message.len == strlen(s));\n    ASSERT(req.body.len == 0);\n  }\n\n  {\n    const char *s = \"GET /blah HTTP/1.0\\r\\nFoo:  bar  \\r\\n\\r\\n\";\n    size_t idx, len = strlen(s);\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) len);\n    ASSERT(mg_vcmp(&req.headers[0].name, \"Foo\") == 0);\n    ASSERT(mg_vcmp(&req.headers[0].value, \"bar\") == 0);\n    ASSERT(req.headers[1].name.len == 0);\n    ASSERT(req.headers[1].name.ptr == NULL);\n    ASSERT(req.query.len == 0);\n    ASSERT(req.message.len == len);\n    ASSERT(req.body.len == 0);\n    for (idx = 0; idx < len; idx++) ASSERT(mg_http_parse(s, idx, &req) == 0);\n  }\n\n  {\n    static const char *s = \"get b c\\nz :  k \\nb: t\\nvvv\\n\\n xx\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s) - 3);\n    ASSERT(req.headers[2].name.len == 0);\n    ASSERT(mg_vcmp(&req.headers[0].value, \"k\") == 0);\n    ASSERT(mg_vcmp(&req.headers[1].value, \"t\") == 0);\n    ASSERT(req.body.len == 0);\n  }\n\n  {\n    const char *s = \"a b c\\r\\nContent-Length: 21 \\r\\nb: t\\r\\nvvv\\r\\n\\r\\nabc\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s) - 3);\n    ASSERT(req.body.len == 21);\n    ASSERT(req.message.len == 21 - 3 + strlen(s));\n    ASSERT(mg_http_get_header(&req, \"foo\") == NULL);\n    ASSERT((v = mg_http_get_header(&req, \"contENT-Length\")) != NULL);\n    ASSERT(mg_vcmp(v, \"21\") == 0);\n    ASSERT((v = mg_http_get_header(&req, \"B\")) != NULL);\n    ASSERT(mg_vcmp(v, \"t\") == 0);\n  }\n\n  {\n    const char *s = \"GET /foo?a=b&c=d HTTP/1.0\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT(mg_vcmp(&req.uri, \"/foo\") == 0);\n    ASSERT(mg_vcmp(&req.query, \"a=b&c=d\") == 0);\n  }\n\n  {\n    const char *s = \"POST /x HTTP/1.0\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT(req.body.len == (size_t) ~0);\n  }\n\n  {\n    const char *s = \"WOHOO /x HTTP/1.0\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT(req.body.len == 0);\n  }\n\n  {\n    const char *s = \"HTTP/1.0 200 OK\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT(mg_vcmp(&req.method, \"HTTP/1.0\") == 0);\n    ASSERT(mg_vcmp(&req.uri, \"200\") == 0);\n    ASSERT(mg_vcmp(&req.proto, \"OK\") == 0);\n    ASSERT(req.body.len == (size_t) ~0);\n  }\n\n  {\n    static const char *s = \"HTTP/1.0 999 OMGWTFBBQ\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n  }\n\n  {\n    const char *s =\n        \"GET / HTTP/1.0\\r\\nhost:127.0.0.1:18888\\r\\nCookie:\\r\\nX-PlayID: \"\n        \"45455\\r\\nRange:  0-1 \\r\\n\\r\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT((v = mg_http_get_header(&req, \"Host\")) != NULL);\n    ASSERT(mg_vcmp(v, \"127.0.0.1:18888\") == 0);\n    ASSERT((v = mg_http_get_header(&req, \"Cookie\")) != NULL);\n    ASSERT(v->len == 0);\n    ASSERT((v = mg_http_get_header(&req, \"X-PlayID\")) != NULL);\n    ASSERT(mg_vcmp(v, \"45455\") == 0);\n    ASSERT((v = mg_http_get_header(&req, \"Range\")) != NULL);\n    ASSERT(mg_vcmp(v, \"0-1\") == 0);\n  }\n\n  {\n    static const char *s = \"a b c\\na:1\\nb:2\\nc:3\\nd:4\\ne:5\\nf:6\\ng:7\\nh:8\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &req) == (int) strlen(s));\n    ASSERT((v = mg_http_get_header(&req, \"e\")) != NULL);\n    ASSERT(mg_vcmp(v, \"5\") == 0);\n    ASSERT((v = mg_http_get_header(&req, \"h\")) == NULL);\n  }\n\n  {\n    struct mg_connection c;\n    struct mg_str s,\n        res = mg_str(\"GET /\\r\\nAuthorization: Basic Zm9vOmJhcg==\\r\\n\\r\\n\");\n    memset(&c, 0, sizeof(c));\n    mg_printf(&c, \"%s\", \"GET /\\r\\n\");\n    mg_http_bauth(&c, \"foo\", \"bar\");\n    mg_printf(&c, \"%s\", \"\\r\\n\");\n    s = mg_str_n((char *) c.send.buf, c.send.len);\n    ASSERT(mg_strcmp(s, res) == 0);\n    mg_iobuf_free(&c.send);\n  }\n\n  {\n    struct mg_http_message hm;\n    const char *s = \"GET /foo?bar=baz HTTP/1.0\\n\\n \";\n    ASSERT(mg_http_parse(s, strlen(s), &hm) == (int) strlen(s) - 1);\n    ASSERT(mg_strcmp(hm.uri, mg_str(\"/foo\")) == 0);\n    ASSERT(mg_strcmp(hm.query, mg_str(\"bar=baz\")) == 0);\n  }\n\n  {\n    struct mg_http_message hm;\n    const char *s = \"a b c\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &hm) == (int) strlen(s));\n    s = \"a b\\nc\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &hm) == (int) strlen(s));\n    s = \"a\\nb\\nc\\n\\n\";\n    ASSERT(mg_http_parse(s, strlen(s), &hm) < 0);\n  }\n}\n\nstatic void ehr(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    struct mg_http_serve_opts opts;\n    memset(&opts, 0, sizeof(opts));\n    opts.root_dir = \"./test/data\";\n    mg_http_serve_dir(c, hm, &opts);\n  }\n  (void) fn_data;\n}\n\nstatic void test_http_range(void) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12349\";\n  struct mg_http_message hm;\n  char buf[FETCH_BUF_SIZE];\n\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, ehr, NULL);\n\n  ASSERT(fetch(&mgr, buf, url, \"GET /range.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(mg_http_parse(buf, strlen(buf), &hm) > 0);\n  ASSERT(hm.body.len == 312);\n\n  fetch(&mgr, buf, url, \"%s\", \"GET /range.txt HTTP/1.0\\nRange: bytes=5-10\\n\\n\");\n  ASSERT(mg_http_parse(buf, strlen(buf), &hm) > 0);\n  ASSERT(mg_strcmp(hm.uri, mg_str(\"206\")) == 0);\n  ASSERT(mg_strcmp(hm.proto, mg_str(\"Partial Content\")) == 0);\n  ASSERT(mg_strcmp(hm.body, mg_str(\" of co\")) == 0);\n  ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Range\"),\n                   mg_str(\"bytes 5-10/312\")) == 0);\n\n  // Fetch till EOF\n  fetch(&mgr, buf, url, \"%s\", \"GET /range.txt HTTP/1.0\\nRange: bytes=300-\\n\\n\");\n  ASSERT(mg_http_parse(buf, strlen(buf), &hm) > 0);\n  ASSERT(mg_strcmp(hm.uri, mg_str(\"206\")) == 0);\n  ASSERT(mg_strcmp(hm.body, mg_str(\"is disease.\\n\")) == 0);\n  // MG_INFO((\"----%d\\n[%s]\", (int) hm.body.len, buf));\n\n  // Fetch past EOF, must trigger 416 response\n  fetch(&mgr, buf, url, \"%s\", \"GET /range.txt HTTP/1.0\\nRange: bytes=999-\\n\\n\");\n  ASSERT(mg_http_parse(buf, strlen(buf), &hm) > 0);\n  ASSERT(mg_strcmp(hm.uri, mg_str(\"416\")) == 0);\n  ASSERT(hm.body.len == 0);\n  ASSERT(mg_strcmp(*mg_http_get_header(&hm, \"Content-Range\"),\n                   mg_str(\"bytes */312\")) == 0);\n\n  fetch(&mgr, buf, url, \"%s\",\n        \"GET /range.txt HTTP/1.0\\nRange: bytes=0-312\\n\\n\");\n  ASSERT(mg_http_parse(buf, strlen(buf), &hm) > 0);\n  ASSERT(mg_strcmp(hm.uri, mg_str(\"416\")) == 0);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void f1(void *arg) { (*(int *) arg)++; }\n\nstatic void test_timer(void) {\n  int v1 = 0, v2 = 0, v3 = 0;\n  struct mg_timer t1, t2, t3, *head = NULL;\n\n  mg_timer_init(&head, &t1, 5, MG_TIMER_REPEAT, f1, &v1);\n  mg_timer_init(&head, &t2, 15, MG_TIMER_ONCE, f1, &v2);\n  mg_timer_init(&head, &t3, 10, MG_TIMER_REPEAT | MG_TIMER_RUN_NOW, f1, &v3);\n\n  ASSERT(head == &t3);\n  ASSERT(head->next == &t2);\n\n  mg_timer_poll(&head, 0);\n  ASSERT(v1 == 0);\n  ASSERT(v2 == 0);\n  ASSERT(v3 == 1);\n\n  mg_timer_poll(&head, 1);\n  ASSERT(v1 == 0);\n  ASSERT(v2 == 0);\n  ASSERT(v3 == 1);\n\n  mg_timer_poll(&head, 5);\n  ASSERT(v1 == 1);\n  ASSERT(v2 == 0);\n  ASSERT(v3 == 1);\n\n  // Simulate long delay - timers must invalidate expiration times\n  mg_timer_poll(&head, 100);\n  ASSERT(v1 == 2);\n  ASSERT(v2 == 1);\n  ASSERT(v3 == 2);\n\n  mg_timer_poll(&head, 107);\n  ASSERT(v1 == 3);\n  ASSERT(v2 == 1);\n  ASSERT(v3 == 2);\n\n  mg_timer_poll(&head, 114);\n  ASSERT(v1 == 4);\n  ASSERT(v2 == 1);\n  ASSERT(v3 == 3);\n\n  mg_timer_poll(&head, 115);\n  ASSERT(v1 == 5);\n  ASSERT(v2 == 1);\n  ASSERT(v3 == 3);\n\n  mg_timer_free(&head, &t2);\n  mg_timer_init(&head, &t2, 3, 0, f1, &v2);\n  ASSERT(head == &t2);\n  ASSERT(head->next == &t3);\n  ASSERT(head->next->next == &t1);\n  ASSERT(head->next->next->next == NULL);\n\n  mg_timer_poll(&head, 120);\n  ASSERT(v1 == 6);\n  ASSERT(v2 == 1);\n  ASSERT(v3 == 4);\n\n  mg_timer_poll(&head, 125);\n  ASSERT(v1 == 7);\n  ASSERT(v2 == 2);\n  ASSERT(v3 == 4);\n\n  // Test millisecond counter wrap - when time goes back.\n  mg_timer_poll(&head, 0);\n  ASSERT(v1 == 7);\n  ASSERT(v2 == 2);\n  ASSERT(v3 == 4);\n\n  mg_timer_poll(&head, 7);\n  ASSERT(v1 == 8);\n  ASSERT(v2 == 2);\n  ASSERT(v3 == 4);\n\n  mg_timer_poll(&head, 11);\n  ASSERT(v1 == 9);\n  ASSERT(v2 == 2);\n  ASSERT(v3 == 5);\n\n  mg_timer_free(&head, &t1);\n  ASSERT(head == &t2);\n  ASSERT(head->next == &t3);\n  ASSERT(head->next->next == NULL);\n\n  mg_timer_free(&head, &t2);\n  ASSERT(head == &t3);\n  ASSERT(head->next == NULL);\n\n  mg_timer_free(&head, &t3);\n  ASSERT(head == NULL);\n\n  // Test proper timer deallocation, see #1539\n  {\n    struct mg_mgr mgr;\n    mg_mgr_init(&mgr);\n    mg_timer_add(&mgr, 1, MG_TIMER_REPEAT, f1, NULL);\n    mg_mgr_free(&mgr);\n    ASSERT(mgr.conns == NULL);\n  }\n}\n\nstatic bool sn(const char *fmt, ...) {\n  char buf[100], tmp[1] = {0}, buf2[sizeof(buf)];\n  size_t n, n2, n1;\n  va_list ap;\n  bool result;\n  va_start(ap, fmt);\n  n = (size_t) vsnprintf(buf2, sizeof(buf2), fmt, ap);\n  va_end(ap);\n  va_start(ap, fmt);\n  n1 = mg_vsnprintf(buf, sizeof(buf), fmt, &ap);\n  va_end(ap);\n  va_start(ap, fmt);\n  n2 = mg_vsnprintf(tmp, 0, fmt, &ap);\n  va_end(ap);\n  result = n1 == n2 && n1 == n && strcmp(buf, buf2) == 0;\n  if (!result)\n    MG_ERROR((\"[%s] -> [%s] != [%s] %d %d %d\\n\", fmt, buf, buf2, (int) n1,\n              (int) n2, (int) n));\n  return result;\n}\n\nstatic bool sccmp(const char *s1, const char *s2, int expected) {\n  int n1 = mg_casecmp(s1, s2);\n  // MG_INFO((\"[%s] [%s] %d %d\", s1, s2, n1, expected));\n  return n1 == expected;\n}\n\nstatic size_t pf1(void (*out)(char, void *), void *ptr, va_list *ap) {\n  int a = va_arg(*ap, int);\n  int b = va_arg(*ap, int);\n  return mg_xprintf(out, ptr, \"%d\", a + b);\n}\n\nstatic size_t pf2(void (*out)(char, void *), void *ptr, va_list *ap) {\n  int cnt = va_arg(*ap, int);\n  size_t n = 0;\n  while (cnt-- > 0) n += mg_xprintf(out, ptr, \"%d\", cnt);\n  return n;\n}\n\nstatic bool chkdbl(struct mg_str s, double val) {\n  double d, tolerance = 1e-14;\n  return mg_json_get_num(s, \"$\", &d) && fabs(val - d) < tolerance;\n}\n\nstatic void test_str(void) {\n  {\n    struct mg_str s = mg_strdup(mg_str(\"a\"));\n    ASSERT(mg_strcmp(s, mg_str(\"a\")) == 0);\n    free((void *) s.ptr);\n  }\n\n  {\n    const char *s;\n    struct mg_str a = mg_str(\"hello\"), b = mg_str(\"a\"), c = mg_str(NULL);\n    ASSERT((s = mg_strstr(a, b)) == NULL);\n    ASSERT((s = mg_strstr(a, c)) != NULL);\n    ASSERT(s == a.ptr);\n  }\n\n  ASSERT(mg_strcmp(mg_str(\"\"), mg_str(NULL)) == 0);\n  ASSERT(mg_strcmp(mg_str(\"a\"), mg_str(\"b\")) < 0);\n  ASSERT(mg_strcmp(mg_str(\"b\"), mg_str(\"a\")) > 0);\n  ASSERT(mg_strstr(mg_str(\"abc\"), mg_str(\"d\")) == NULL);\n  ASSERT(mg_strstr(mg_str(\"abc\"), mg_str(\"b\")) != NULL);\n  ASSERT(mg_strcmp(mg_str(\"hi\"), mg_strstrip(mg_str(\" \\thi\\r\\n\"))) == 0);\n\n  ASSERT(sccmp(\"\", \"\", 0));\n  ASSERT(sccmp(\"\", \"1\", -49));\n  ASSERT(sccmp(\"a\", \"A\", 0));\n  ASSERT(sccmp(\"a1\", \"A\", 49));\n  ASSERT(sccmp(\"a\", \"A1\", -49));\n\n  {\n    ASSERT(chkdbl(mg_str_n(\"1.23\", 3), 1.2));\n    ASSERT(chkdbl(mg_str(\"1.23 \"), 1.23));\n    ASSERT(chkdbl(mg_str(\"-0.01 \"), -0.01));\n    ASSERT(chkdbl(mg_str(\"-0.5e2\"), -50.0));\n    ASSERT(chkdbl(mg_str(\"123e-3\"), 0.123));\n  }\n\n  ASSERT(sn(\"%d\", 0));\n  ASSERT(sn(\"%d\", 1));\n  ASSERT(sn(\"%d\", -1));\n  ASSERT(sn(\"%.*s\", 0, \"ab\"));\n  ASSERT(sn(\"%.*s\", 1, \"ab\"));\n  ASSERT(sn(\"%.1s\", \"ab\"));\n  ASSERT(sn(\"%.99s\", \"a\"));\n  ASSERT(sn(\"%11s\", \"a\"));\n  ASSERT(sn(\"%s\", \"a\\0b\"));\n  ASSERT(sn(\"%2s\", \"a\"));\n  ASSERT(sn(\"%.*s\", 3, \"a\\0b\"));\n  ASSERT(sn(\"%d\", 7));\n  ASSERT(sn(\"%d\", 123));\n#if MG_ARCH == MG_ARCH_UNIX\n  ASSERT(sn(\"%lld\", (uint64_t) 0xffffffffff));\n  ASSERT(sn(\"%lld\", (uint64_t) -1));\n  ASSERT(sn(\"%llu\", (uint64_t) -1));\n  ASSERT(sn(\"%llx\", (uint64_t) 0xffffffffff));\n  ASSERT(sn(\"%p\", (void *) (size_t) 7));\n#endif\n  ASSERT(sn(\"%lx\", (unsigned long) 0x6204d754));\n  ASSERT(sn(\"ab\"));\n  ASSERT(sn(\"%dx\", 1));\n  ASSERT(sn(\"%sx\", \"a\"));\n  ASSERT(sn(\"%cx\", 32));\n  ASSERT(sn(\"%x\", 15));\n  ASSERT(sn(\"%2x\", 15));\n  ASSERT(sn(\"%02x\", 15));\n  ASSERT(sn(\"%hx:%hhx\", (short) 1, (char) 2));\n  ASSERT(sn(\"%hx:%hhx\", (short) 1, (char) 2));\n  ASSERT(sn(\"%%\"));\n  ASSERT(sn(\"%x\", 15));\n  ASSERT(sn(\"%#x\", 15));\n  ASSERT(sn(\"%#6x\", 15));\n  ASSERT(sn(\"%#06x\", 15));\n  ASSERT(sn(\"%#-6x\", 15));\n  ASSERT(sn(\"%-2s!\", \"a\"));\n  ASSERT(sn(\"%s %s\", \"a\", \"b\"));\n  ASSERT(sn(\"%s %s\", \"a\", \"b\"));\n  ASSERT(sn(\"ab%dc\", 123));\n  ASSERT(sn(\"%s \", \"a\"));\n  ASSERT(sn(\"%s %s\", \"a\", \"b\"));\n  ASSERT(sn(\"%2s %s\", \"a\", \"b\"));\n\n  // Non-standard formatting\n  {\n    char buf[100], *p = NULL;\n    struct mg_iobuf io = {0, 0, 0, 16};\n    const char *expected;\n\n    expected = \"\\\"\\\"\";\n    mg_snprintf(buf, sizeof(buf), \"%m\", mg_print_esc, 0, \"\");\n    ASSERT(strcmp(buf, expected) == 0);\n\n    expected = \"\";\n    mg_snprintf(buf, 1, \"%s\", \"abc\");\n    ASSERT(strcmp(buf, expected) == 0);\n\n    expected = \"a\";\n    mg_snprintf(buf, 2, \"%s\", \"abc\");\n    ASSERT(strcmp(buf, expected) == 0);\n\n    expected = \"\\\"hi, \\\\\\\"\\\"\";\n    mg_snprintf(buf, sizeof(buf), \"\\\"hi, %M\\\"\", mg_print_esc, 0, \"\\\"\");\n    MG_INFO((\"[%s] [%s]\", buf, expected));\n    ASSERT(strcmp(buf, expected) == 0);\n\n    expected = \"\\\"a'b\\\"\";\n    mg_snprintf(buf, sizeof(buf), \"%m\", mg_print_esc, 0, \"a'b\");\n    ASSERT(strcmp(buf, expected) == 0);\n\n    expected = \"\\\"a\\\\b\\\\n\\\\f\\\\r\\\\t\\\\\\\"\\\"\";\n    mg_snprintf(buf, sizeof(buf), \"%m\", mg_print_esc, 0, \"a\\b\\n\\f\\r\\t\\\"\");\n    ASSERT(strcmp(buf, expected) == 0);\n\n    expected = \"\\\"abc\\\"\";\n    mg_snprintf(buf, sizeof(buf), \"%m\", mg_print_esc, 3, \"abcdef\");\n    ASSERT(strcmp(buf, expected) == 0);\n\n    p = mg_mprintf(\"[%s,%M,%s]\", \"null\", pf1, 2, 3, \"hi\");\n    ASSERT(strcmp(p, \"[null,5,hi]\") == 0);\n    free(p);\n\n    p = mg_mprintf(\"[%M,%d]\", pf2, 10, 7);\n    ASSERT(strcmp(p, \"[9876543210,7]\") == 0);\n    free(p);\n\n    mg_xprintf(mg_pfn_iobuf, &io, \"[%M\", pf2, 10);\n    mg_xprintf(mg_pfn_iobuf, &io, \",\");\n    mg_xprintf(mg_pfn_iobuf, &io, \"%d]\", 7);\n    ASSERT(strcmp((char *) io.buf, \"[9876543210,7]\") == 0);\n    mg_iobuf_free(&io);\n  }\n\n  {\n#if MG_ARCH == MG_ARCH_WIN32\n    bool is_windows = true;\n#else\n    bool is_windows = false;\n#endif\n\n#define DBLWIDTH(a, b) a, b\n#define TESTDOUBLE(fmt_, num_, res_)                             \\\n  do {                                                           \\\n    char t1[40] = \"\", t2[40] = \"\";                               \\\n    const char *N = #num_;                                       \\\n    mg_snprintf(t1, sizeof(t1), fmt_, num_);                     \\\n    snprintf(t2, sizeof(t2), fmt_, num_);                        \\\n    printf(\"[%s,%s] : [%s] [%s] [%s]\\n\", fmt_, N, res_, t2, t1); \\\n    ASSERT(strcmp(t1, res_) == 0);                               \\\n    if (!is_windows) ASSERT(strcmp(t1, t2) == 0);                \\\n  } while (0)\n\n    TESTDOUBLE(\"%g\", 0.0, \"0\");\n    TESTDOUBLE(\"%g\", 0.123, \"0.123\");\n    TESTDOUBLE(\"%g\", 0.00123, \"0.00123\");\n    TESTDOUBLE(\"%g\", 0.123456333, \"0.123456\");\n    TESTDOUBLE(\"%g\", 123.0, \"123\");\n    TESTDOUBLE(\"%g\", 11.5454, \"11.5454\");\n    TESTDOUBLE(\"%g\", 11.0001, \"11.0001\");\n    TESTDOUBLE(\"%g\", 0.999, \"0.999\");\n    TESTDOUBLE(\"%g\", 0.999999, \"0.999999\");\n    TESTDOUBLE(\"%g\", 0.9999999, \"1\");\n    TESTDOUBLE(\"%g\", 10.9, \"10.9\");\n    TESTDOUBLE(\"%g\", 10.01, \"10.01\");\n    TESTDOUBLE(\"%g\", 1.0, \"1\");\n    TESTDOUBLE(\"%g\", 10.0, \"10\");\n    TESTDOUBLE(\"%g\", 100.0, \"100\");\n    TESTDOUBLE(\"%g\", 1000.0, \"1000\");\n    TESTDOUBLE(\"%g\", 10000.0, \"10000\");\n    TESTDOUBLE(\"%g\", 100000.0, \"100000\");\n    TESTDOUBLE(\"%g\", 1000000.0, \"1e+06\");\n    TESTDOUBLE(\"%g\", 10000000.0, \"1e+07\");\n    TESTDOUBLE(\"%g\", 100000001.0, \"1e+08\");\n    TESTDOUBLE(\"%g\", 10.5454, \"10.5454\");\n    TESTDOUBLE(\"%g\", 999999.0, \"999999\");\n    TESTDOUBLE(\"%g\", 9999999.0, \"1e+07\");\n    TESTDOUBLE(\"%g\", 44556677.0, \"4.45567e+07\");\n    TESTDOUBLE(\"%g\", 1234567.2, \"1.23457e+06\");\n    TESTDOUBLE(\"%g\", -987.65432, \"-987.654\");\n    TESTDOUBLE(\"%g\", 0.0000000001, \"1e-10\");\n    TESTDOUBLE(\"%g\", 2.34567e-57, \"2.34567e-57\");\n    TESTDOUBLE(\"%.*g\", DBLWIDTH(7, 9999999.0), \"9999999\");\n    TESTDOUBLE(\"%.*g\", DBLWIDTH(10, 0.123456333), \"0.123456333\");\n    TESTDOUBLE(\"%g\", 123.456222, \"123.456\");\n    TESTDOUBLE(\"%.*g\", DBLWIDTH(10, 123.456222), \"123.456222\");\n    TESTDOUBLE(\"%g\", 600.1234, \"600.123\");\n    TESTDOUBLE(\"%g\", -600.1234, \"-600.123\");\n    TESTDOUBLE(\"%g\", 599.1234, \"599.123\");\n    TESTDOUBLE(\"%g\", -599.1234, \"-599.123\");\n    TESTDOUBLE(\"%g\", 0.14, \"0.14\");\n    TESTDOUBLE(\"%f\", 0.14, \"0.140000\");\n    TESTDOUBLE(\"%.*f\", DBLWIDTH(4, 0.14), \"0.1400\");\n    TESTDOUBLE(\"%.*f\", DBLWIDTH(3, 0.14), \"0.140\");\n    TESTDOUBLE(\"%.*f\", DBLWIDTH(2, 0.14), \"0.14\");\n    TESTDOUBLE(\"%.*f\", DBLWIDTH(1, 0.14), \"0.1\");\n    TESTDOUBLE(\"%.*f\", DBLWIDTH(1, 0.19), \"0.2\");\n    TESTDOUBLE(\"%.*f\", DBLWIDTH(1, 0.16), \"0.2\");\n    // TESTDOUBLE(\"%.*f\", DBLWIDTH(1, 0.15), \"0.1\");\n\n#ifndef _WIN32\n    TESTDOUBLE(\"%g\", (double) INFINITY, \"inf\");\n    TESTDOUBLE(\"%g\", (double) -INFINITY, \"-inf\");\n    TESTDOUBLE(\"%g\", (double) NAN, \"nan\");\n#else\n    TESTDOUBLE(\"%g\", HUGE_VAL, \"inf\");\n    TESTDOUBLE(\"%g\", -HUGE_VAL, \"-inf\");\n#endif\n  }\n\n  {\n    const char *expected = \"[\\\"MA==\\\",\\\"MAo=\\\",\\\"MAr+\\\",\\\"MAr+Zw==\\\"]\";\n    char tmp[100], s[] = \"0\\n\\xfeg\";\n    ASSERT(mg_snprintf(tmp, sizeof(tmp), \"[%m,%m,%m,%m]\", mg_print_base64, 1, s,\n                       mg_print_base64, 2, s, mg_print_base64, 3, s,\n                       mg_print_base64, 4, s) == 33);\n    ASSERT(strcmp(tmp, expected) == 0);\n  }\n\n  {\n    const char *expected = \"\\\"002001200220616263\\\"\";\n    char tmp[100], s[] = \"\\x00 \\x01 \\x02 abc\";\n    ASSERT(mg_snprintf(tmp, sizeof(tmp), \"%m\", mg_print_hex, 9, s) == 20);\n    ASSERT(strcmp(tmp, expected) == 0);\n  }\n\n  {\n    char tmp[3];\n    ASSERT(mg_snprintf(tmp, sizeof(tmp), \"%s\", \"0123456789\") == 10);\n    ASSERT(strcmp(tmp, \"01\") == 0);\n    ASSERT(tmp[2] == '\\0');\n  }\n\n  {\n    char buf[100];\n    struct mg_addr a = {mg_htons(3), mg_htonl(0x2000001), {1, 100, 33}, false};\n    ASSERT(mg_snprintf(buf, sizeof(buf), \"%M %d\", mg_print_ip, &a, 7) == 9);\n    ASSERT(strcmp(buf, \"2.0.0.1 7\") == 0);\n    ASSERT(mg_snprintf(buf, sizeof(buf), \"%M %d\", mg_print_ip_port, &a, 7) ==\n           11);\n    ASSERT(strcmp(buf, \"2.0.0.1:3 7\") == 0);\n    a.is_ip6 = true;\n    ASSERT(mg_snprintf(buf, sizeof(buf), \"%M %d\", mg_print_ip, &a, 7) == 24);\n    ASSERT(strcmp(buf, \"[164:2100:0:0:0:0:0:0] 7\") == 0);\n    ASSERT(mg_snprintf(buf, sizeof(buf), \"%M %d\", mg_print_ip_port, &a, 7) ==\n           26);\n    ASSERT(strcmp(buf, \"[164:2100:0:0:0:0:0:0]:3 7\") == 0);\n  }\n}\n\nstatic void fn1(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_ERROR)\n    *(char **) fn_data = mg_mprintf(\"%s\", (char *) ev_data);\n  (void) c;\n}\n\nstatic void test_dns_error(const char *dns_server_url, const char *errstr) {\n  // Test timeout\n  struct mg_mgr mgr;\n  char *buf = NULL;\n  int i;\n  mg_mgr_init(&mgr);\n  mgr.dns4.url = dns_server_url;\n  mgr.dnstimeout = 10;\n  MG_DEBUG((\"opening dummy DNS listener @ [%s]...\", dns_server_url));\n  mg_listen(&mgr, mgr.dns4.url, NULL, NULL);  // Just discard our queries\n  mg_http_connect(&mgr, \"http://google.com\", fn1, &buf);\n  for (i = 0; i < 50 && buf == NULL; i++) mg_mgr_poll(&mgr, 1);\n  mg_mgr_free(&mgr);\n  // MG_DEBUG((\"buf: [%s] [%s]\", buf, errstr));\n  ASSERT(buf != NULL && strcmp(buf, errstr) == 0);\n  free(buf);\n}\n\nstatic void test_dns(void) {\n  struct mg_dns_message dm;\n  //       txid  flags numQ  numA  numAP numOP\n  // 0000  00 01 81 80 00 01 00 01 00 00 00 00 07 63 65 73  .............ces\n  // 0010  61 6e 74 61 03 63 6f 6d 00 00 01 00 01 c0 0c 00  anta.com........\n  // 0020  01 00 01 00 00 02 57 00 04 94 fb 36 ec           ......W....6.\n  uint8_t data[] = {0,    1,    0x81, 0x80, 0,    1,    0,    1,    0,\n                    0,    0,    0,    7,    0x63, 0x65, 0x73, 0x61, 0x6e,\n                    0x74, 0x61, 0x03, 0x63, 0x6f, 0x6d, 0,    0,    1,\n                    0,    1,    0xc0, 0x0c, 0,    1,    0,    1,    0,\n                    0,    2,    0x57, 0,    4,    0x94, 0xfb, 0x36, 0xec};\n  ASSERT(mg_dns_parse(NULL, 0, &dm) == 0);\n  ASSERT(mg_dns_parse(data, sizeof(data), &dm) == 1);\n  ASSERT(strcmp(dm.name, \"cesanta.com\") == 0);\n  data[30] = 29;  // Point a pointer to itself\n  memset(&dm, 0, sizeof(dm));\n  ASSERT(mg_dns_parse(data, sizeof(data), &dm) == 1);\n  ASSERT(strcmp(dm.name, \"\") == 0);\n\n  {\n    // 0000  00 01 81 80 00 01 00 04 00 00 00 00 05 79 61 68  .............yah\n    // 0010  6f 6f 05 63 31 31 32 36 03 63 6f 6d 00 00 01 00  oo.c1126.com....\n    // 0020  01 c0 0c 00 05 00 01 00 00 0d 34 00 0c 03 77 77  ..........4...ww\n    // 0030  77 05 79 61 68 6f 6f c0 18 c0 2d 00 05 00 01 00  w.yahoo...-.....\n    // 0040  00 00 01 00 14 0b 6e 65 77 2d 66 70 2d 73 68 65  ......new-fp-she\n    // 0050  64 03 77 67 31 01 62 c0 31 c0 45 00 01 00 01 00  d.wg1.b.1.E.....\n    // 0060  00 00 0a 00 04 57 f8 64 d8 c0 45 00 01 00 01 00  .....W.d..E.....\n    // 0070  00 00 0a 00 04 57 f8 64 d7                       .....W.d.\n    uint8_t d[] = {\n        0x00, 0x01, 0x81, 0x80, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,\n        0x00, 0x05, 0x79, 0x61, 0x68, 0x6f, 0x6f, 0x05, 0x63, 0x31, 0x31,\n        0x32, 0x36, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01,\n        0xc0, 0x0c, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x0d, 0x34, 0x00,\n        0x0c, 0x03, 0x77, 0x77, 0x77, 0x05, 0x79, 0x61, 0x68, 0x6f, 0x6f,\n        0xc0, 0x18, 0xc0, 0x2d, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x00,\n        0x01, 0x00, 0x14, 0x0b, 0x6e, 0x65, 0x77, 0x2d, 0x66, 0x70, 0x2d,\n        0x73, 0x68, 0x65, 0x64, 0x03, 0x77, 0x67, 0x31, 0x01, 0x62, 0xc0,\n        0x31, 0xc0, 0x45, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0a,\n        0x00, 0x04, 0x57, 0xf8, 0x64, 0xd8, 0xc0, 0x45, 0x00, 0x01, 0x00,\n        0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x04, 0x57, 0xf8, 0x64, 0xd7,\n    };\n    ASSERT(mg_dns_parse(d, sizeof(d), &dm) == 1);\n    // MG_INFO((\"[%s]\", dm.name));\n    ASSERT(strcmp(dm.name, \"new-fp-shed.wg1.b.yahoo.com\") == 0);\n  }\n\n  test_dns_error(\"udp://127.0.0.1:12345\", \"DNS timeout\");\n  test_dns_error(\"\", \"resolver\");\n  test_dns_error(\"tcp://0.0.0.0:0\", \"DNS error\");\n}\n\nstatic void test_util(void) {\n  char buf[100], *p, *s;\n  struct mg_addr a;\n  memset(&a, 0, sizeof(a));\n  ASSERT(mg_file_printf(&mg_fs_posix, \"data.txt\", \"%s\", \"hi\") == true);\n  // if (system(\"ls -l\") != 0) (void) 0;\n  ASSERT((p = mg_file_read(&mg_fs_posix, \"data.txt\", NULL)) != NULL);\n  ASSERT(strcmp(p, \"hi\") == 0);\n  free(p);\n  remove(\"data.txt\");\n  ASSERT(mg_aton(mg_str(\"0\"), &a) == false);\n  ASSERT(mg_aton(mg_str(\"0.0.0.\"), &a) == false);\n  ASSERT(mg_aton(mg_str(\"0.0.0.256\"), &a) == false);\n  ASSERT(mg_aton(mg_str(\"0.0.0.-1\"), &a) == false);\n  ASSERT(mg_aton(mg_str(\"127.0.0.1\"), &a) == true);\n  ASSERT(a.is_ip6 == false);\n  ASSERT(a.ip == mg_htonl(0x7f000001));\n\n  ASSERT(mg_aton(mg_str(\"1:2:3:4:5:6:7:8\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(\n      memcmp(a.ip6,\n             \"\\x00\\x01\\x00\\x02\\x00\\x03\\x00\\x04\\x00\\x05\\x00\\x06\\x00\\x07\\x00\\x08\",\n             sizeof(a.ip6)) == 0);\n\n  memset(a.ip6, 0xaa, sizeof(a.ip6));\n  ASSERT(mg_aton(mg_str(\"1::1\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(\n      memcmp(a.ip6,\n             \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\",\n             sizeof(a.ip6)) == 0);\n\n  memset(a.ip6, 0xaa, sizeof(a.ip6));\n  ASSERT(mg_aton(mg_str(\"::fFff:1.2.3.4\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(memcmp(a.ip6,\n                \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n                \"\\x00\\x00\\xff\\xff\\x01\\x02\\x03\\x04\",\n                sizeof(a.ip6)) == 0);\n\n  memset(a.ip6, 0xaa, sizeof(a.ip6));\n  ASSERT(mg_aton(mg_str(\"::1\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(\n      memcmp(a.ip6,\n             \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\",\n             sizeof(a.ip6)) == 0);\n\n  memset(a.ip6, 0xaa, sizeof(a.ip6));\n  ASSERT(mg_aton(mg_str(\"1::\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(\n      memcmp(a.ip6,\n             \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n             sizeof(a.ip6)) == 0);\n\n  memset(a.ip6, 0xaa, sizeof(a.ip6));\n  ASSERT(mg_aton(mg_str(\"2001:4860:4860::8888\"), &a) == true);\n  ASSERT(a.is_ip6 == true);\n  ASSERT(\n      memcmp(a.ip6,\n             \"\\x20\\x01\\x48\\x60\\x48\\x60\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x88\\x88\",\n             sizeof(a.ip6)) == 0);\n\n  ASSERT(strcmp(mg_hex(\"abc\", 3, buf), \"616263\") == 0);\n  ASSERT(mg_url_decode(\"a=%\", 3, buf, sizeof(buf), 0) < 0);\n  ASSERT(mg_url_decode(\"&&&a=%\", 6, buf, sizeof(buf), 0) < 0);\n\n  {\n    size_t n;\n    ASSERT((n = mg_url_encode(\"\", 0, buf, sizeof(buf))) == 0);\n    ASSERT((n = mg_url_encode(\"a\", 1, buf, 0)) == 0);\n    ASSERT((n = mg_url_encode(\"a\", 1, buf, sizeof(buf))) == 1);\n    ASSERT(strncmp(buf, \"a\", n) == 0);\n    ASSERT((n = mg_url_encode(\"._-~\", 4, buf, sizeof(buf))) == 4);\n    ASSERT(strncmp(buf, \"._-~\", n) == 0);\n    ASSERT((n = mg_url_encode(\"a@%>\", 4, buf, sizeof(buf))) == 10);\n    ASSERT(strncmp(buf, \"a%40%25%3e\", n) == 0);\n    ASSERT((n = mg_url_encode(\"a@b.c\", 5, buf, sizeof(buf))) == 7);\n    ASSERT(strncmp(buf, \"a%40b.c\", n) == 0);\n  }\n\n  {\n    s = mg_mprintf(\"%3d\", 123);\n    ASSERT(strcmp(s, \"123\") == 0);\n    free(s);\n  }\n\n  ASSERT(mg_to64(mg_str(\"-9223372036854775809\")) == 0);\n  ASSERT(mg_to64(mg_str(\"9223372036854775800\")) == 0);\n  ASSERT(mg_to64(mg_str(\"9223372036854775700\")) > 0);\n  ASSERT(mg_tou64(mg_str(\"0\")) == 0);\n  ASSERT(mg_tou64(mg_str(\"123\")) == 123);\n  ASSERT(mg_tou64(mg_str(\"\")) == 0);\n  ASSERT(mg_tou64(mg_str(\"-\")) == 0);\n  ASSERT(mg_tou64(mg_str(\"18446744073709551615\")) == 18446744073709551615U);\n\n  {\n    size_t i;\n    memset(buf, ' ', sizeof(buf));\n    mg_random_str(buf, 0);\n    ASSERT(buf[0] == ' ');\n    mg_random_str(buf, 1);\n    ASSERT(buf[0] == '\\0');\n    ASSERT(buf[1] == ' ');\n    mg_random_str(buf, sizeof(buf));\n    ASSERT(buf[sizeof(buf) - 1] == '\\0');\n    for (i = 0; i < sizeof(buf) - 1; i++) ASSERT(isalnum((uint8_t) buf[i]));\n  }\n}\n\nstatic void test_crc32(void) {\n  //  echo -n aaa | cksum -o3\n  ASSERT(mg_crc32(0, 0, 0) == 0);\n  ASSERT(mg_crc32(0, \"a\", 1) == 3904355907);\n  ASSERT(mg_crc32(0, \"abc\", 3) == 891568578);\n  ASSERT(mg_crc32(mg_crc32(0, \"ab\", 2), \"c\", 1) == 891568578);\n}\n\nstatic void us(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  int del = *(int *) fn_data;\n  struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n  if (ev == MG_EV_HTTP_CHUNK && mg_http_match_uri(hm, \"/upload\")) {\n    MG_DEBUG((\"Got chunk len %lu\", (unsigned long) hm->chunk.len));\n    MG_DEBUG((\"Query string: [%.*s]\", (int) hm->query.len, hm->query.ptr));\n    // MG_DEBUG((\"Chunk data:\\n%.*s\", (int) hm->chunk.len, hm->chunk.ptr));\n    if (del) {\n      mg_http_delete_chunk(c, hm);\n      if (hm->chunk.len == 0) {\n        MG_DEBUG((\"Last chunk received, sending response\"));\n        mg_http_reply(c, 200, \"\", \"ok (chunked)\\n\");\n      }\n    }\n  } else if (ev == MG_EV_HTTP_MSG && mg_http_match_uri(hm, \"/upload\")) {\n    MG_DEBUG((\"Got all %lu bytes!\", (unsigned long) hm->body.len));\n    MG_DEBUG((\"Query string: [%.*s]\", (int) hm->query.len, hm->query.ptr));\n    // MG_DEBUG((\"Body:\\n%.*s\", (int) hm->body.len, hm->body.ptr));\n    mg_http_reply(c, 200, \"\", \"ok (%d %.*s)\\n\", (int) hm->body.len,\n                  (int) hm->body.len, hm->body.ptr);\n  } else if (ev == MG_EV_HTTP_MSG) {\n    mg_http_reply(c, 200, \"\", \"ok\\n\");\n  }\n  (void) fn_data;\n}\n\nstatic void uc(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  const char **s = (const char **) fn_data;\n  if (ev == MG_EV_OPEN) {\n    c->is_hexdumping = 1;\n  } else if (ev == MG_EV_CONNECT) {\n    mg_printf(c,\n              \"POST /upload HTTP/1.0\\r\\n\"\n              \"Transfer-Encoding: chunked\\r\\n\\r\\n\");\n    mg_http_printf_chunk(c, \"%s\", \"foo\\n\");\n    mg_http_printf_chunk(c, \"%s\", \"bar\\n\");\n    mg_http_printf_chunk(c, \"\");\n  } else if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    ASSERT(mg_strcmp(hm->body, mg_str(*s)) == 0);\n    *s = NULL;\n  }\n  (void) fn_data;\n}\n\nstatic void test_http_upload(void) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12352\";\n  int i, del = 1;\n  const char *s1 = \"ok (chunked)\\n\";\n  const char *s2 = \"ok (8 foo\\nbar\\n)\\n\";\n\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, us, (void *) &del);\n\n  mg_http_connect(&mgr, url, uc, (void *) &s1);\n  for (i = 0; i < 20; i++) mg_mgr_poll(&mgr, 5);\n  ASSERT(s1 == NULL);\n\n  del = 0;\n  mg_http_connect(&mgr, url, uc, (void *) &s2);\n  for (i = 0; i < 20; i++) mg_mgr_poll(&mgr, 5);\n  ASSERT(s2 == NULL);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\n#define LONG_CHUNK \"chunk with length taking up more than two hex digits\"\n\nstatic void eX(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    mg_printf(c, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\");\n    c->data[0] = 1;\n    c->is_hexdumping = 1;\n  } else if (ev == MG_EV_POLL && c->data[0] != 0) {\n    c->data[0]++;\n    if (c->data[0] == 10) mg_http_printf_chunk(c, \"a\");\n    if (c->data[0] == 20) {\n      mg_http_printf_chunk(c, \"b\");\n      mg_http_printf_chunk(c, \"c\");\n    }\n    if (c->data[0] == 30) {\n      mg_http_printf_chunk(c, \"d\");\n      mg_http_printf_chunk(c, \"\");\n      c->data[0] = 0;\n    }\n  }\n  (void) ev_data, (void) fn_data;\n}\n\nstatic void eY(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    mg_printf(c, \"HTTP/1.1 200 OK\\r\\nContent-Length: 4\\r\\n\\r\\n\");\n    c->data[0] = 1;\n  } else if (ev == MG_EV_POLL && c->data[0] != 0) {\n    c->data[0]++;\n    if (c->data[0] == 10) mg_send(c, \"a\", 1);\n    if (c->data[0] == 12) mg_send(c, \"bc\", 2);\n    if (c->data[0] == 30) mg_send(c, \"d\", 1), c->is_resp = 0, c->data[0] = 0;\n  }\n  (void) ev_data, (void) fn_data;\n}\n\nstatic void eZ(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    mg_http_reply(c, 200, \"\", \"abcd\");\n  }\n  (void) ev_data, (void) fn_data;\n}\n\n// Do not delete chunks as they arrive\nstatic void eh4(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  uint32_t *crc = (uint32_t *) fn_data;\n  if (ev == MG_EV_HTTP_CHUNK) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    *crc = mg_crc32(*crc, hm->chunk.ptr, hm->chunk.len);\n    *crc = mg_crc32(*crc, \"x\", 1);\n    MG_INFO((\"%lu C [%.*s]\", c->id, (int) hm->chunk.len, hm->chunk.ptr));\n  } else if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    *crc = mg_crc32(*crc, hm->body.ptr, hm->body.len);\n    MG_INFO((\"%lu M [%.*s]\", c->id, (int) hm->body.len, hm->body.ptr));\n  }\n}\n\n// Streaming client event handler. Delete chunks as they arrive\nstatic void eh5(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  uint32_t *crc = (uint32_t *) fn_data;\n  if (ev == MG_EV_HTTP_CHUNK) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    *crc = mg_crc32(*crc, hm->chunk.ptr, hm->chunk.len);\n    *crc = mg_crc32(*crc, \"x\", 1);\n    MG_INFO((\"%lu DELC [%.*s]\", c->id, (int) hm->chunk.len, hm->chunk.ptr));\n    mg_http_delete_chunk(c, hm);\n  } else if (ev == MG_EV_HTTP_MSG) {\n    ASSERT(0);  // Must not be here, MSG must not be fired: chunks deleted!\n  }\n}\n\nstatic void test_http_chunked_case(mg_event_handler_t s, mg_event_handler_t c,\n                                   int req_count, const char *expected) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12344\";\n  uint32_t i, crc = 0, expected_crc = mg_crc32(0, expected, strlen(expected));\n  struct mg_connection *conn;\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, s, NULL);\n  conn = mg_http_connect(&mgr, url, c, &crc);\n  while (conn != NULL && req_count-- > 0) {\n    mg_printf(conn, \"GET / HTTP/1.0\\n\\n\");\n  }\n  for (i = 0; i < 100 && crc != expected_crc; i++) {\n    mg_mgr_poll(&mgr, 1);\n  }\n  ASSERT(i < 100);\n  ASSERT(crc == expected_crc);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_http_chunked(void) {\n  // Non-chunked encoding\n  test_http_chunked_case(eY, eh4, 1, \"axbcxdxxabcd\");  // Chunks not deleted\n  test_http_chunked_case(eY, eh4, 2, \"axbcxdxxabcdaxbcxdxxabcd\");\n  test_http_chunked_case(eY, eh5, 1, \"axbcxdxx\");  // Chunks deleted\n  test_http_chunked_case(eY, eh5, 2, \"axbcxdxxaxbcxdxx\");\n  test_http_chunked_case(eZ, eh4, 1, \"abcdxxabcd\");  // Not deleted\n  test_http_chunked_case(eZ, eh4, 2, \"abcdxxabcdabcdxxabcd\");\n  test_http_chunked_case(eZ, eh5, 1, \"abcdxx\");  // Deleted\n  test_http_chunked_case(eZ, eh5, 2, \"abcdxxabcdxx\");\n\n  // Chunked encoding\n  test_http_chunked_case(eX, eh4, 1, \"axbxcxdxxabcd\");  // Chunks not deleted\n  test_http_chunked_case(eX, eh5, 1, \"axbxcxdxx\");      // Chunks deleted\n  test_http_chunked_case(eX, eh4, 2, \"axbxcxdxxabcdaxbxcxdxxabcd\");\n  test_http_chunked_case(eX, eh5, 2, \"axbxcxdxxaxbxcxdxx\");\n}\n\nstatic void test_invalid_listen_addr(void) {\n  struct mg_mgr mgr;\n  struct mg_connection *c;\n  mg_mgr_init(&mgr);\n  c = mg_http_listen(&mgr, \"invalid:31:14\", eh1, NULL);\n  ASSERT(c == NULL);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstruct stream_status {\n  uint32_t polls;\n  size_t sent;\n  size_t received;\n  uint32_t send_crc;\n  uint32_t recv_crc;\n};\n\n// Consume recv buffer after letting it reach MG_MAX_RECV_SIZE\nstatic void eh8(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  struct stream_status *status = (struct stream_status *) fn_data;\n  if (c->is_listening) return;\n\n  ASSERT(c->recv.len <= MG_MAX_RECV_SIZE);\n\n  if (ev == MG_EV_ACCEPT) {\n    // Optimize recv buffer size near max to speed up test\n    mg_iobuf_resize(&c->recv, MG_MAX_RECV_SIZE - MG_IO_SIZE);\n    status->received = 0;\n    status->recv_crc = 0;\n  }\n\n  if (ev == MG_EV_CLOSE) {\n    ASSERT(status->received == status->sent);\n  }\n\n  // Let buffer fill up and start consuming after 10 full buffer poll events\n  if (status->polls >= 10 && ev == MG_EV_POLL) {\n    // consume at most a third of MG_MAX_RECV_SIZE on each poll\n    size_t consume;\n    if (MG_MAX_RECV_SIZE / 3 >= c->recv.len)\n      consume = c->recv.len;\n    else\n      consume = MG_MAX_RECV_SIZE / 3;\n    status->received += consume;\n    status->recv_crc =\n        mg_crc32(status->recv_crc, (const char *) c->recv.buf, consume);\n    mg_iobuf_del(&c->recv, 0, consume);\n  }\n\n  // count polls with full buffer to ensure c->is_full prevents reads\n  if (ev == MG_EV_POLL && c->recv.len == MG_MAX_RECV_SIZE) status->polls += 1;\n  (void) ev_data;\n}\n\n// Toggle c->is_full to prevent max_recv_buf_size reached read errors\nstatic void eh10(struct mg_connection *c, int ev, void *ev_data,\n                 void *fn_data) {\n  if (c->recv.len >= MG_MAX_RECV_SIZE && ev == MG_EV_READ) c->is_full = true;\n\n  eh8(c, ev, ev_data, fn_data);\n\n  if (c->recv.len < MG_MAX_RECV_SIZE && ev == MG_EV_POLL) c->is_full = false;\n}\n\n// Send buffer larger than MG_MAX_RECV_SIZE to server\nstatic void eh11(struct mg_connection *c, int ev, void *ev_data,\n                 void *fn_data) {\n  struct stream_status *status = (struct stream_status *) fn_data;\n  if (ev == MG_EV_CONNECT) {\n    size_t len = MG_MAX_RECV_SIZE * 2;\n    struct mg_iobuf buf = {NULL, 0, 0, 0};\n    mg_iobuf_init(&buf, len, 0);\n    mg_random(buf.buf, buf.size);\n    buf.len = buf.size;\n    mg_send(c, buf.buf, buf.len);\n    status->sent = buf.len;\n    status->send_crc = mg_crc32(0, (const char *) buf.buf, buf.len);\n    mg_iobuf_free(&buf);\n  }\n  (void) ev_data;\n  (void) fn_data;\n}\n\nstatic void test_http_stream_buffer(void) {\n  struct mg_mgr mgr;\n  const char *url = \"tcp://127.0.0.1:12344\";\n  uint32_t i;\n  struct stream_status status;\n  mg_mgr_init(&mgr);\n  mg_listen(&mgr, url, eh10, &status);\n\n  status.polls = 0;\n  mg_connect(&mgr, url, eh11, &status);\n  for (i = 0; i < (MG_MAX_RECV_SIZE / MG_IO_SIZE) * 50; i++) {\n    mg_mgr_poll(&mgr, 1);\n    if (status.polls >= 10 && status.sent == status.received) break;\n  }\n  ASSERT(status.sent == status.received);\n  ASSERT(status.send_crc == status.recv_crc);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_multipart(void) {\n  struct mg_http_part part;\n  size_t ofs;\n  const char *s =\n      \"--xyz\\r\\n\"\n      \"Content-Disposition: form-data; name=\\\"val\\\"\\r\\n\"\n      \"\\r\\n\"\n      \"abc\\r\\ndef\\r\\n\"\n      \"--xyz\\r\\n\"\n      \"Content-Disposition: form-data; name=\\\"foo\\\"; filename=\\\"a b.txt\\\"\\r\\n\"\n      \"Content-Type: text/plain\\r\\n\"\n      \"\\r\\n\"\n      \"hello world\\r\\n\"\n      \"\\r\\n\"\n      \"--xyz--\\r\\n\";\n  ASSERT(mg_http_next_multipart(mg_str(\"\"), 0, NULL) == 0);\n  ASSERT((ofs = mg_http_next_multipart(mg_str(s), 0, &part)) > 0);\n  ASSERT(mg_strcmp(part.name, mg_str(\"val\")) == 0);\n  // MG_INFO((\"--> [%.*s]\", (int) part.body.len, part.body.ptr));\n  ASSERT(mg_strcmp(part.body, mg_str(\"abc\\r\\ndef\")) == 0);\n  ASSERT(part.filename.len == 0);\n  ASSERT((ofs = mg_http_next_multipart(mg_str(s), ofs, &part)) > 0);\n  ASSERT(mg_strcmp(part.name, mg_str(\"foo\")) == 0);\n  // MG_INFO((\"--> [%.*s]\", (int) part.filename.len, part.filename.ptr));\n  ASSERT(mg_strcmp(part.filename, mg_str(\"a b.txt\")) == 0);\n  ASSERT(mg_strcmp(part.body, mg_str(\"hello world\\r\\n\")) == 0);\n  ASSERT(mg_http_next_multipart(mg_str(s), ofs, &part) == 0);\n}\n\nstatic void eh7(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    struct mg_http_serve_opts sopts;\n    memset(&sopts, 0, sizeof(sopts));\n    sopts.root_dir = \"/\";\n    sopts.fs = &mg_fs_packed;\n    mg_http_serve_dir(c, hm, &sopts);\n  }\n  (void) fn_data;\n}\n\nstatic void test_packed(void) {\n  struct mg_mgr mgr;\n  const char *url = \"http://127.0.0.1:12351\";\n  char buf[FETCH_BUF_SIZE],\n      *data = mg_file_read(&mg_fs_posix, \"Makefile\", NULL);\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, url, eh7, NULL);\n\n  // Load top level file directly\n  // fetch(&mgr, buf, url, \"GET /Makefile HTTP/1.0\\n\\n\");\n  // printf(\"---> %s\\n\", buf);\n  ASSERT(fetch(&mgr, buf, url, \"GET /Makefile HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, data) == 0);\n  free(data);\n\n  // Load file deeper in the FS tree directly\n  data = mg_file_read(&mg_fs_posix, \"src/ssi.h\", NULL);\n  ASSERT(fetch(&mgr, buf, url, \"GET /src/ssi.h HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, data) == 0);\n  free(data);\n\n  // List root dir\n  ASSERT(fetch(&mgr, buf, url, \"GET / HTTP/1.0\\n\\n\") == 200);\n  // printf(\"--------\\n%s\\n\", buf);\n\n  // List nested dir\n  ASSERT(fetch(&mgr, buf, url, \"GET /test HTTP/1.0\\n\\n\") == 301);\n  ASSERT(fetch(&mgr, buf, url, \"GET /test/ HTTP/1.0\\n\\n\") == 200);\n  // printf(\"--------\\n%s\\n\", buf);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void eh6(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_READ) *(int *) fn_data = 1;\n  (void) c, (void) ev_data;\n}\n\n#if (MG_ENABLE_SOCKET == 0)\nint send(int sock, const void *buf, size_t len, int flags);\nint send(int sock, const void *buf, size_t len, int flags) {\n  (void) sock, (void) buf, (void) len, (void) flags;\n  return -1;\n}\n#endif\n\nstatic void test_pipe_proto(bool is_udp) {\n  struct mg_mgr mgr;\n  int i, sock, done = 0;\n  mg_mgr_init(&mgr);\n  ASSERT((sock = mg_mkpipe(&mgr, eh6, (void *) &done, is_udp)) >= 0);\n  ASSERT(send(sock, \"hi\", 2, 0) == 2);\n  for (i = 0; i < 10 && done == 0; i++) mg_mgr_poll(&mgr, 1);\n  ASSERT(done == 1);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_pipe(void) {\n  test_pipe_proto(true);\n  test_pipe_proto(false);\n}\n\nstatic void u1(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_CONNECT) {\n    ((int *) fn_data)[0] += 1;\n    mg_send(c, \"hi\", 2);\n  } else if (ev == MG_EV_WRITE) {\n    ((int *) fn_data)[0] += 100;\n  } else if (ev == MG_EV_READ) {\n    ((int *) fn_data)[0] += 10;\n    mg_iobuf_free(&c->recv);\n  }\n  (void) ev_data;\n}\n\nstatic void test_udp(void) {\n  struct mg_mgr mgr;\n  const char *url = \"udp://127.0.0.1:12353\";\n  int i, done = 0;\n  mg_mgr_init(&mgr);\n  mg_listen(&mgr, url, u1, (void *) &done);\n  mg_connect(&mgr, url, u1, (void *) &done);\n  for (i = 0; i < 5; i++) mg_mgr_poll(&mgr, 1);\n  // MG_INFO((\"%d\", done));\n  ASSERT(done == 111);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_check_ip_acl(void) {\n  uint32_t ip = mg_htonl(0x01020304);\n  ASSERT(mg_check_ip_acl(mg_str(NULL), ip) == 1);\n  ASSERT(mg_check_ip_acl(mg_str(\"\"), ip) == 1);\n  ASSERT(mg_check_ip_acl(mg_str(\"invalid\"), ip) == -1);\n  ASSERT(mg_check_ip_acl(mg_str(\"+hi\"), ip) == -2);\n  ASSERT(mg_check_ip_acl(mg_str(\"+//\"), ip) == -2);\n  ASSERT(mg_check_ip_acl(mg_str(\"-0.0.0.0/0\"), ip) == 0);\n  ASSERT(mg_check_ip_acl(mg_str(\"-0.0.0.0/0,+1.0.0.0/8\"), ip) == 1);\n  ASSERT(mg_check_ip_acl(mg_str(\"-0.0.0.0/0,+1.2.3.4\"), ip) == 1);\n  ASSERT(mg_check_ip_acl(mg_str(\"-0.0.0.0/0,+1.0.0.0/16\"), ip) == 0);\n}\n\nstatic void w3(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  // MG_INFO((\"ev %d\", ev));\n  if (ev == MG_EV_WS_OPEN) {\n    char buf[8192];\n    memset(buf, 'A', sizeof(buf));\n    mg_ws_send(c, \"hi there!\", 9, WEBSOCKET_OP_TEXT);\n    mg_ws_printf(c, WEBSOCKET_OP_TEXT, \"%s\", \"hi there2!\");\n    mg_printf(c, \"%s\", \"boo\");\n    mg_ws_wrap(c, 3, WEBSOCKET_OP_TEXT);\n    mg_ws_send(c, buf, sizeof(buf), WEBSOCKET_OP_TEXT);\n  } else if (ev == MG_EV_WS_MSG) {\n    struct mg_ws_message *wm = (struct mg_ws_message *) ev_data;\n    ASSERT(mg_strcmp(wm->data, mg_str(\"lebowski\")) == 0);\n    ((int *) fn_data)[0]++;\n  } else if (ev == MG_EV_CLOSE) {\n    ((int *) fn_data)[0] += 10;\n  }\n}\n\nstatic void w2(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  struct mg_str msg = mg_str_n(\"lebowski\", 8);\n  if (ev == MG_EV_HTTP_MSG) {\n    mg_ws_upgrade(c, (struct mg_http_message *) ev_data, NULL);\n  } else if (ev == MG_EV_WS_OPEN) {\n    mg_ws_send(c, \"x\", 1, WEBSOCKET_OP_PONG);\n  } else if (ev == MG_EV_POLL && c->is_websocket) {\n    size_t ofs, n = (size_t) fn_data;\n    if (n < msg.len) {\n      // Send \"msg\" char by char using fragmented frames\n      // mg_ws_send() sets the FIN flag in the WS header. Clean it\n      // to send fragmented packet. Insert PONG messages between frames\n      uint8_t op = n == 0 ? WEBSOCKET_OP_TEXT : WEBSOCKET_OP_CONTINUE;\n      mg_ws_send(c, \":->\", 3, WEBSOCKET_OP_PING);\n      ofs = c->send.len;\n      mg_ws_send(c, &msg.ptr[n], 1, op);\n      if (n < msg.len - 1) c->send.buf[ofs] = op;  // Clear FIN flag\n      c->fn_data = (void *) (n + 1);               // Point to the next char\n    } else {\n      mg_ws_send(c, \"\", 0, WEBSOCKET_OP_CLOSE);\n    }\n  } else if (ev == MG_EV_WS_MSG) {\n    struct mg_ws_message *wm = (struct mg_ws_message *) ev_data;\n    MG_INFO((\"Got WS, %lu\", wm->data.len));\n    // mg_hexdump(wm->data.ptr, wm->data.len);\n    if (wm->data.len == 9) {\n      ASSERT(mg_strcmp(wm->data, mg_str(\"hi there!\")) == 0);\n    } else if (wm->data.len == 10) {\n      ASSERT(mg_strcmp(wm->data, mg_str(\"hi there2!\")) == 0);\n    } else if (wm->data.len == 3) {\n      ASSERT(mg_strcmp(wm->data, mg_str(\"boo\")) == 0);\n    } else {\n      MG_INFO((\"%lu\", wm->data.len));\n      ASSERT(wm->data.len == 8192);\n    }\n  }\n}\n\nstatic void test_ws_fragmentation(void) {\n  const char *url = \"ws://localhost:12357/ws\";\n  struct mg_mgr mgr;\n  int i, done = 0;\n\n  mg_mgr_init(&mgr);\n  ASSERT(mg_http_listen(&mgr, url, w2, NULL) != NULL);\n  mg_ws_connect(&mgr, url, w3, &done, \"%s\", \"Sec-WebSocket-Protocol: echo\\r\\n\");\n  for (i = 0; i < 25; i++) mg_mgr_poll(&mgr, 1);\n  // MG_INFO((\"--> %d\", done));\n  ASSERT(done == 11);\n\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void h7(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_HTTP_MSG) {\n    struct mg_http_message *hm = (struct mg_http_message *) ev_data;\n    struct mg_http_serve_opts opts;\n    memset(&opts, 0, sizeof(opts));\n    opts.root_dir = \"./test/data,/foo=./src\";\n    mg_http_serve_dir(c, hm, &opts);\n  }\n  (void) fn_data;\n}\n\nstatic void test_rewrites(void) {\n  char buf[FETCH_BUF_SIZE];\n  const char *url = \"http://LOCALHOST:12358\";\n  const char *expected = \"#define MG_VERSION \\\"\" MG_VERSION \"\\\"\\n\";\n  struct mg_mgr mgr;\n  mg_mgr_init(&mgr);\n  ASSERT(mg_http_listen(&mgr, url, h7, NULL) != NULL);\n  ASSERT(fetch(&mgr, buf, url, \"GET /a.txt HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, \"hello\\n\") == 0);\n  ASSERT(fetch(&mgr, buf, url, \"GET /foo/version.h HTTP/1.0\\n\\n\") == 200);\n  ASSERT(cmpbody(buf, expected) == 0);\n  ASSERT(fetch(&mgr, buf, url, \"GET /foo HTTP/1.0\\n\\n\") == 301);\n  ASSERT(fetch(&mgr, buf, url, \"GET /foo/ HTTP/1.0\\n\\n\") == 200);\n  // printf(\"-->[%s]\\n\", buf);\n  mg_mgr_free(&mgr);\n  ASSERT(mgr.conns == NULL);\n}\n\nstatic void test_get_header_var(void) {\n  struct mg_str empty = mg_str(\"\"), bar = mg_str(\"bar\"), baz = mg_str(\"baz\");\n  struct mg_str header = mg_str(\"Digest foo=\\\"bar\\\", blah,boo=baz, x=\\\"yy\\\"\");\n  struct mg_str yy = mg_str(\"yy\");\n  // struct mg_str x = mg_http_get_header_var(header, mg_str(\"x\"));\n  // MG_INFO((\"--> [%d] [%d]\", (int) x.len, yy.len));\n  ASSERT(mg_strcmp(empty, mg_http_get_header_var(empty, empty)) == 0);\n  ASSERT(mg_strcmp(empty, mg_http_get_header_var(header, empty)) == 0);\n  ASSERT(mg_strcmp(empty, mg_http_get_header_var(header, mg_str(\"fooo\"))) == 0);\n  ASSERT(mg_strcmp(empty, mg_http_get_header_var(header, mg_str(\"fo\"))) == 0);\n  ASSERT(mg_strcmp(empty, mg_http_get_header_var(header, mg_str(\"blah\"))) == 0);\n  ASSERT(mg_strcmp(bar, mg_http_get_header_var(header, mg_str(\"foo\"))) == 0);\n  ASSERT(mg_strcmp(baz, mg_http_get_header_var(header, mg_str(\"boo\"))) == 0);\n  ASSERT(mg_strcmp(yy, mg_http_get_header_var(header, mg_str(\"x\"))) == 0);\n}\n\nstatic void test_json(void) {\n  const char *s1 = \"{\\\"a\\\":{},\\\"b\\\":7,\\\"c\\\":[[],2]}\";\n  const char *s2 = \"{\\\"a\\\":{\\\"b1\\\":{}},\\\"c\\\":7,\\\"d\\\":{\\\"b2\\\":{}}}\";\n  int n;\n  struct mg_str json;\n\n  ASSERT(mg_json_get(mg_str_n(\" true \", 6), \"\", &n) == MG_JSON_INVALID);\n  ASSERT(mg_json_get(mg_str_n(\" true \", 6), \"$\", &n) == 1 && n == 4);\n  ASSERT(mg_json_get(mg_str_n(\"null \", 5), \"$\", &n) == 0 && n == 4);\n  json = mg_str(\"  \\\"hi\\\\nthere\\\"\");\n  ASSERT(mg_json_get(json, \"$\", &n) == 2 && n == 11);\n  ASSERT(mg_json_get(mg_str_n(\" { } \", 5), \"$\", &n) == 1);\n  ASSERT(mg_json_get(mg_str_n(\" [[]]\", 5), \"$\", &n) == 1);\n  ASSERT(mg_json_get(mg_str_n(\" [ ]  \", 5), \"$\", &n) == 1);\n\n  ASSERT(mg_json_get(mg_str_n(\"[1,2]\", 5), \"$\", &n) == 0 && n == 5);\n  ASSERT(mg_json_get(mg_str_n(\"[1,2]\", 5), \"$[0]\", &n) == 1 && n == 1);\n  ASSERT(mg_json_get(mg_str_n(\"[1,2]\", 5), \"$[1]\", &n) == 3 && n == 1);\n  ASSERT(mg_json_get(mg_str_n(\"[1,2]\", 5), \"$[3]\", &n) == MG_JSON_NOT_FOUND);\n\n  json = mg_str(\"{\\\"a\\\":[]}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 2);\n  json = mg_str(\"{\\\"a\\\":[1,2]}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 5);\n  json = mg_str(\"{\\\"a\\\":[1,[1]]}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 7);\n  json = mg_str(\"{\\\"a\\\":[[]]}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 4);\n  json = mg_str(\"{\\\"a\\\":[[1,2]]}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 7);\n  json = mg_str(\"{\\\"a\\\":{}}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 2);\n  json = mg_str(\"{\\\"a\\\":{\\\"a\\\":{}}}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 8);\n  json = mg_str(\"{\\\"a\\\":{\\\"a\\\":[]}}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 8);\n\n  json = mg_str(\"[[1,[2,3]],4]\");\n  ASSERT(mg_json_get(json, \"$\", &n) == 0 && n == 13);\n  ASSERT(mg_json_get(json, \"$[0]\", &n) == 1 && n == 9);\n  ASSERT(mg_json_get(json, \"$[1]\", &n) == 11);\n  ASSERT(mg_json_get(json, \"$[1]\", &n) == 11 && n == 1);\n  ASSERT(mg_json_get(json, \"$[2]\", &n) == MG_JSON_NOT_FOUND);\n  ASSERT(mg_json_get(json, \"$[0][0]\", &n) == 2 && n == 1);\n  ASSERT(mg_json_get(json, \"$[0][1]\", &n) == 4 && n == 5);\n  ASSERT(mg_json_get(json, \"$[0][2]\", &n) == MG_JSON_NOT_FOUND);\n  ASSERT(mg_json_get(json, \"$[0][1][0]\", &n) == 5 && n == 1);\n  ASSERT(mg_json_get(json, \"$[0][1][1]\", &n) == 7 && n == 1);\n\n  json = mg_str(\"[[1,2],3]\");\n  ASSERT(mg_json_get(json, \"$\", &n) == 0 && n == 9);\n  ASSERT(mg_json_get(json, \"$[0][0]\", &n) == 2 && n == 1);\n  ASSERT(mg_json_get(json, \"$[0][1]\", &n) == 4 && n == 1);\n  ASSERT(mg_json_get(json, \"$[0][2]\", &n) == MG_JSON_NOT_FOUND);\n  ASSERT(mg_json_get(json, \"$[1][0]\", &n) == MG_JSON_NOT_FOUND);\n  ASSERT(mg_json_get(json, \"$[1]\", &n) == 7 && n == 1);\n  ASSERT(mg_json_get(json, \"$[1][0]\", &n) == MG_JSON_NOT_FOUND);\n\n  ASSERT(mg_json_get(json, \"$\", &n) == 0 && n == 9);\n  ASSERT(mg_json_get(json, \"$[1][0]\", &n) == MG_JSON_NOT_FOUND);\n  ASSERT(mg_json_get(json, \"$[0][1]\", &n) == 4 && n == 1);\n\n  json = mg_str(s1);\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 2);\n  ASSERT(mg_json_get(json, \"$.b\", &n) == 12 && n == 1);\n  ASSERT(mg_json_get(json, \"$.c\", &n) == 18 && n == 6);\n  ASSERT(mg_json_get(json, \"$.c[0]\", &n) == 19 && n == 2);\n  ASSERT(mg_json_get(json, \"$.c[1]\", &n) == 22 && n == 1);\n  ASSERT(mg_json_get(json, \"$.c[3]\", &n) == MG_JSON_NOT_FOUND);\n\n  json = mg_str(s2);\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 9);\n  ASSERT(mg_json_get(json, \"$.a.b1\", &n) == 11 && n == 2);\n  ASSERT(mg_json_get(json, \"$.a.b2\", &n) == MG_JSON_NOT_FOUND);\n  ASSERT(mg_json_get(json, \"$.a.b\", &n) == MG_JSON_NOT_FOUND);\n  ASSERT(mg_json_get(json, \"$.a1\", &n) == MG_JSON_NOT_FOUND);\n  ASSERT(mg_json_get(json, \"$.c\", &n) == 19 && n == 1);\n\n  {\n    double d = 0;\n    bool b = false;\n    int len;\n    char *str = NULL;\n\n    json = mg_str(\"{\\\"a\\\":\\\"b\\\"}\");\n    str = mg_json_get_str(json, \"$.a\");\n    ASSERT(str != NULL);\n    // printf(\"---> [%s]\\n\", str);\n    ASSERT(strcmp(str, \"b\") == 0);\n    free(str);\n\n    json = mg_str(\"{\\\"a\\\": \\\"hi\\\\nthere\\\",\\\"b\\\": [12345, true]}\");\n    str = mg_json_get_str(json, \"$.a\");\n\n    ASSERT(str != NULL);\n    ASSERT(strcmp(str, \"hi\\nthere\") == 0);\n    free(str);\n\n    ASSERT(mg_json_get_long(json, \"$.foo\", -42) == -42);\n    ASSERT(mg_json_get_long(json, \"$.b[0]\", -42) == 12345);\n\n    ASSERT(mg_json_get_num(json, \"$.a\", &d) == false);\n    ASSERT(mg_json_get_num(json, \"$.c\", &d) == false);\n    ASSERT(mg_json_get_num(json, \"$.b[0]\", &d) == true);\n    ASSERT(d == 12345);\n\n    ASSERT(mg_json_get_bool(json, \"$.b\", &b) == false);\n    ASSERT(mg_json_get_bool(json, \"$.b[0]\", &b) == false);\n    ASSERT(mg_json_get_bool(json, \"$.b[1]\", &b) == true);\n    ASSERT(b == true);\n    ASSERT(mg_json_get(json, \"$.b[2]\", &len) < 0);\n\n    json = mg_str(\"[\\\"YWJj\\\", \\\"0100026869\\\"]\");\n    ASSERT((str = mg_json_get_b64(json, \"$[0]\", &len)) != NULL);\n    ASSERT(len == 3 && memcmp(str, \"abc\", (size_t) len) == 0);\n    free(str);\n    ASSERT((str = mg_json_get_hex(json, \"$[1]\", &len)) != NULL);\n    ASSERT(len == 5 && memcmp(str, \"\\x01\\x00\\x02hi\", (size_t) len) == 0);\n    free(str);\n\n    json = mg_str(\"{\\\"a\\\":[1,2,3], \\\"ab\\\": 2}\");\n    ASSERT(mg_json_get_long(json, \"$.a[0]\", -42) == 1);\n    ASSERT(mg_json_get_long(json, \"$.ab\", -42) == 2);\n    ASSERT(mg_json_get_long(json, \"$.ac\", -42) == -42);\n\n    json = mg_str(\"{\\\"a\\\":[],\\\"b\\\":[1,2]}\");\n    ASSERT(mg_json_get_long(json, \"$.a[0]\", -42) == -42);\n    ASSERT(mg_json_get_long(json, \"$.b[0]\", -42) == 1);\n    ASSERT(mg_json_get_long(json, \"$.b[1]\", -42) == 2);\n    ASSERT(mg_json_get_long(json, \"$.b[2]\", -42) == -42);\n    json = mg_str(\"[{\\\"a\\\":1,\\\"b\\\":2},{\\\"a\\\":3, \\\"b\\\":4}]\");\n    ASSERT(mg_json_get_long(json, \"$[0].a\", -42) == 1);\n    ASSERT(mg_json_get_long(json, \"$[0].b\", -42) == 2);\n    ASSERT(mg_json_get_long(json, \"$[1].a\", -42) == 3);\n    ASSERT(mg_json_get_long(json, \"$[1].b\", -42) == 4);\n    ASSERT(mg_json_get_long(json, \"$[2].a\", -42) == -42);\n\n    json = mg_str(\"{\\\"a\\\":[1],\\\"b\\\":[2,3]}\");\n    ASSERT(mg_json_get_long(json, \"$.a[0]\", -42) == 1);\n    ASSERT(mg_json_get_long(json, \"$.a[1]\", -42) == -42);\n\n    json = mg_str(\"{\\\"a\\\":[1,[2,3], 4]}\");\n    ASSERT(mg_json_get_long(json, \"$.a[0]\", -42) == 1);\n    ASSERT(mg_json_get_long(json, \"$.a[1][0]\", -42) == 2);\n    ASSERT(mg_json_get_long(json, \"$.a[1][1]\", -42) == 3);\n    ASSERT(mg_json_get_long(json, \"$.a[1][2]\", -42) == -42);\n    ASSERT(mg_json_get_long(json, \"$.a[2]\", -42) == 4);\n    ASSERT(mg_json_get_long(json, \"$.a[3]\", -42) == -42);\n  }\n\n  json = mg_str(\"{\\\"a\\\":[],\\\"b\\\":[1,2]}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 2);\n  ASSERT(mg_json_get(json, \"$.a[0]\", &n) < 0 && n == 0);\n\n  json = mg_str(\"{\\\"a\\\":{},\\\"b\\\":[1,2]}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 2);\n  ASSERT(mg_json_get(json, \"$.a[0]\", &n) < 0 && n == 0);\n\n  json = mg_str(\"{\\\"a\\\":true,\\\"b\\\":[1,2]}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 4);\n  ASSERT(mg_json_get(json, \"$.a[0]\", &n) < 0 && n == 0);\n\n  json = mg_str(\"{\\\"a\\\":1,\\\"b\\\":[1,2]}\");\n  ASSERT(mg_json_get(json, \"$.a\", &n) == 5 && n == 1);\n  ASSERT(mg_json_get(json, \"$.a[0]\", &n) < 0 && n == 0);\n}\n\nstatic void resp_rpc(struct mg_rpc_req *r) {\n  int len = 0, off = mg_json_get(r->frame, \"$.result\", &len);\n  mg_xprintf(r->pfn, r->pfn_data, \"%.*s\", len, &r->frame.ptr[off]);\n}\n\nstatic void test_rpc(void) {\n  struct mg_rpc *head = NULL;\n  struct mg_iobuf io = {0, 0, 0, 256};\n  struct mg_rpc_req req = {&head, 0, mg_pfn_iobuf, &io, 0, {0, 0}};\n  mg_rpc_add(&head, mg_str(\"rpc.list\"), mg_rpc_list, NULL);\n\n  {\n    req.frame = mg_str(\"{\\\"method\\\":\\\"rpc.list\\\"}\");\n    mg_rpc_process(&req);\n    ASSERT(io.buf == NULL);\n  }\n\n  {\n    const char *resp = \"{\\\"id\\\":1,\\\"result\\\":[\\\"rpc.list\\\"]}\";\n    req.frame = mg_str(\"{\\\"id\\\": 1,\\\"method\\\":\\\"rpc.list\\\"}\");\n    mg_rpc_process(&req);\n    ASSERT(strcmp((char *) io.buf, resp) == 0);\n    mg_iobuf_free(&io);\n  }\n\n  {\n    const char *resp =\n        \"{\\\"id\\\":true,\\\"error\\\":{\\\"code\\\":-32601,\\\"message\\\":\\\"foo not \"\n        \"found\\\"}}\";\n    req.frame = mg_str(\"{\\\"id\\\": true,\\\"method\\\":\\\"foo\\\"}\");\n    mg_rpc_process(&req);\n    // MG_INFO((\"-> %s\", io.buf));\n    ASSERT(strcmp((char *) io.buf, resp) == 0);\n    mg_iobuf_free(&io);\n  }\n\n  {\n    const char *resp =\n        \"{\\\"id\\\":true,\\\"error\\\":{\\\"code\\\":-32601,\\\"message\\\":\\\"foo not \"\n        \"found\\\"}}\";\n    req.frame = mg_str(\"{\\\"id\\\": true,\\\"method\\\":\\\"foo\\\"}\");\n    req.head = NULL;\n    mg_rpc_process(&req);\n    // MG_INFO((\"-> %s\", io.buf));\n    ASSERT(strcmp((char *) io.buf, resp) == 0);\n    mg_iobuf_free(&io);\n    req.head = &head;\n  }\n\n  {\n    const char *resp = \"{\\\"error\\\":{\\\"code\\\":-32700,\\\"message\\\":\\\"haha\\\"}}\";\n    req.frame = mg_str(\"haha\");\n    mg_rpc_process(&req);\n    // MG_INFO((\"-> %s\", io.buf));\n    ASSERT(strcmp((char *) io.buf, resp) == 0);\n    mg_iobuf_free(&io);\n  }\n\n  {\n    const char *resp =\n        \"{\\\"id\\\":1,\\\"error\\\":{\\\"code\\\":-32601,\\\"message\\\":\\\" not found\\\"}}\";\n    req.frame = mg_str(\"{\\\"id\\\":1,\\\"result\\\":123}\");\n    mg_rpc_process(&req);\n    // MG_INFO((\"-> %s\", io.buf));\n    ASSERT(strcmp((char *) io.buf, resp) == 0);\n    mg_iobuf_free(&io);\n  }\n\n  {\n    req.frame = mg_str(\"{\\\"id\\\":1,\\\"result\\\":123}\");\n    mg_rpc_add(&head, mg_str(\"\"), resp_rpc, NULL);\n    mg_rpc_process(&req);\n    MG_INFO((\"-> %s\", io.buf));\n    ASSERT(strcmp((char *) io.buf, \"123\") == 0);\n    mg_iobuf_free(&io);\n  }\n\n  mg_rpc_del(&head, NULL);\n  ASSERT(head == NULL);\n}\n\nstatic void ph(struct mg_connection *c, int ev, void *ev_data, void *fn_data) {\n  if (ev == MG_EV_POLL) ++(*(int *) fn_data);\n  (void) c, (void) ev_data;\n}\n\nstatic void test_poll(void) {\n  int count = 0, i;\n  struct mg_mgr mgr;\n  mg_mgr_init(&mgr);\n  mg_http_listen(&mgr, \"http://127.0.0.1:12346\", ph, &count);\n  for (i = 0; i < 10; i++) mg_mgr_poll(&mgr, 0);\n  ASSERT(count == 10);\n  mg_mgr_free(&mgr);\n}\n\n#define NMESSAGES 99999\nstatic uint32_t s_qcrc = 0;\nstatic int s_out, s_in;\nstatic void producer(void *param) {\n  struct mg_queue *q = (struct mg_queue *) param;\n  char tmp[64 * 1024], *buf;\n  size_t len, ofs = sizeof(tmp);\n  for (s_out = 0; s_out < NMESSAGES; s_out++) {\n    if (ofs >= sizeof(tmp)) mg_random(tmp, sizeof(tmp)), ofs = 0;\n    len = ((uint8_t *) tmp)[ofs] % 55 + 1;\n    if (ofs + len > sizeof(tmp)) len = sizeof(tmp) - ofs;\n    while ((mg_queue_book(q, &buf, len)) < len) (void) 0;\n    memcpy(buf, &tmp[ofs], len);\n    s_qcrc = mg_crc32(s_qcrc, buf, len);\n    ofs += len;\n#if 0\n    fprintf(stderr, \"-->prod %3d  %8x  %-3lu %zu/%zu/%lu\\n\", s_out, s_qcrc, len, q->tail,\n           q->head, buf - q->buf);\n#endif\n    mg_queue_add(q, len);\n  }\n}\n\nstatic uint32_t consumer(struct mg_queue *q) {\n  uint32_t crc = 0;\n  for (s_in = 0; s_in < NMESSAGES; s_in++) {\n    char *buf;\n    size_t len;\n    while ((len = mg_queue_next(q, &buf)) == 0) (void) 0;\n    crc = mg_crc32(crc, buf, len);\n#if 0\n    fprintf(stderr, \"-->cons %3u  %8x  %-3lu %zu/%zu/%lu\\n\", s_in, crc, len, q->tail,\n           q->head, buf - q->buf);\n#endif\n    mg_queue_del(q, len);\n  }\n  return crc;\n}\n\n#if MG_ARCH == MG_ARCH_WIN32\nstatic void start_thread(void (*f)(void *), void *p) {\n  _beginthread((void(__cdecl *)(void *)) f, 0, p);\n}\n#elif MG_ARCH == MG_ARCH_UNIX\n#include <pthread.h>\nstatic void start_thread(void (*f)(void *), void *p) {\n  union {\n    void (*f1)(void *);\n    void *(*f2)(void *);\n  } u = {f};\n  pthread_t thread_id = (pthread_t) 0;\n  pthread_attr_t attr;\n  (void) pthread_attr_init(&attr);\n  (void) pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n  pthread_create(&thread_id, &attr, u.f2, p);\n  pthread_attr_destroy(&attr);\n}\n#else\nstatic void start_thread(void (*f)(void *), void *p) { (void) f, (void) p; }\n#endif\n\nstatic void test_queue(void) {\n  char buf[512];\n  struct mg_queue queue;\n  uint32_t crc;\n  memset(buf, 0x55, sizeof(buf));\n  mg_queue_init(&queue, buf, sizeof(buf));\n  start_thread(producer, &queue);  // Start producer in a separate thread\n  crc = consumer(&queue);          // Consumer eats data in this thread\n  MG_INFO((\"CRC1 %8x\", s_qcrc));   // Show CRCs\n  MG_INFO((\"CRC2 %8x\", crc));\n  ASSERT(s_qcrc == crc);\n}\n\nint main(void) {\n  const char *debug_level = getenv(\"V\");\n  if (debug_level == NULL) debug_level = \"3\";\n  mg_log_set(atoi(debug_level));\n\n  test_json();\n  test_queue();\n  test_rpc();\n  test_str();\n  test_globmatch();\n  test_get_header_var();\n  test_rewrites();\n  test_check_ip_acl();\n  test_udp();\n  test_pipe();\n  test_packed();\n  test_crc32();\n  test_multipart();\n  test_invalid_listen_addr();\n  test_http_chunked();\n  test_http_upload();\n  test_http_stream_buffer();\n  test_http_parse();\n  test_util();\n  test_dns();\n  test_timer();\n  test_url();\n  test_iobuf();\n  test_commalist();\n  test_base64();\n  test_http_get_var();\n  test_tls();\n  test_ws();\n  test_ws_fragmentation();\n  test_http_client();\n  test_http_server();\n  test_http_404();\n  test_http_no_content_length();\n  test_http_pipeline();\n  test_http_range();\n  test_sntp();\n  test_mqtt();\n  test_poll();\n  printf(\"SUCCESS. Total tests: %d\\n\", s_num_tests);\n\n  return EXIT_SUCCESS;\n}\n"], "filenames": ["mongoose.c", "src/http.c", "test/unit_test.c"], "buggy_code_start_loc": [1466, 234, 792], "buggy_code_end_loc": [1467, 235, 792], "fixing_code_start_loc": [1466, 234, 793], "fixing_code_end_loc": [1469, 237, 797], "type": "NVD-CWE-Other", "message": "The HTTP server in Mongoose before 7.10 accepts requests containing negative Content-Length headers. By sending a single attack payload over TCP, an attacker can cause an infinite loop in which the server continuously reparses that payload, and does not respond to any other requests.", "other": {"cve": {"id": "CVE-2023-34188", "sourceIdentifier": "cve@mitre.org", "published": "2023-06-23T20:15:09.053", "lastModified": "2023-09-06T17:15:50.190", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The HTTP server in Mongoose before 7.10 accepts requests containing negative Content-Length headers. By sending a single attack payload over TCP, an attacker can cause an infinite loop in which the server continuously reparses that payload, and does not respond to any other requests."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cesanta:mongoose:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.10", "matchCriteriaId": "D772458E-F58A-4241-B9DC-E5DBDE529957"}]}]}], "references": [{"url": "https://blog.narfindustries.com/blog/narf-discovers-critical-vulnerabilities-in-cesanta-mongoose-http-server", "source": "cve@mitre.org"}, {"url": "https://github.com/cesanta/mongoose/commit/4663090a8fb036146dfe77718cff612b0101cb0f", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/cesanta/mongoose/compare/7.9...7.10", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/cesanta/mongoose/pull/2197", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/cesanta/mongoose/commit/4663090a8fb036146dfe77718cff612b0101cb0f"}}