{"buggy_code": ["/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.java.sip.communicator.impl.protocol.jabber;\n\nimport java.util.*;\n\nimport net.java.sip.communicator.impl.protocol.jabber.extensions.carbon.*;\nimport net.java.sip.communicator.impl.protocol.jabber.extensions.mailnotification.*;\nimport net.java.sip.communicator.impl.protocol.jabber.extensions.messagecorrection.*;\nimport net.java.sip.communicator.service.protocol.*;\nimport net.java.sip.communicator.service.protocol.Message;\nimport net.java.sip.communicator.service.protocol.event.*;\nimport net.java.sip.communicator.service.protocol.jabberconstants.*;\nimport net.java.sip.communicator.util.*;\n\nimport org.jivesoftware.smack.*;\nimport org.jivesoftware.smack.filter.*;\nimport org.jivesoftware.smack.packet.*;\nimport org.jivesoftware.smack.provider.*;\nimport org.jivesoftware.smack.util.*;\nimport org.jivesoftware.smackx.*;\nimport org.jivesoftware.smackx.packet.*;\n\n/**\n * A straightforward implementation of the basic instant messaging operation\n * set.\n *\n * @author Damian Minkov\n * @author Matthieu Helleringer\n * @author Alain Knaebel\n * @author Emil Ivov\n * @author Hristo Terezov\n */\npublic class OperationSetBasicInstantMessagingJabberImpl\n    extends AbstractOperationSetBasicInstantMessaging\n    implements OperationSetMessageCorrection\n{\n    /**\n     * Our class logger\n     */\n    private static final Logger logger =\n        Logger.getLogger(OperationSetBasicInstantMessagingJabberImpl.class);\n\n    /**\n     * The maximum number of unread threads that we'd be notifying the user of.\n     */\n    private static final String PNAME_MAX_GMAIL_THREADS_PER_NOTIFICATION\n        = \"net.java.sip.communicator.impl.protocol.jabber.\"\n            +\"MAX_GMAIL_THREADS_PER_NOTIFICATION\";\n\n    /**\n     * A table mapping contact addresses to full jids that can be used to\n     * target a specific resource (rather than sending a message to all logged\n     * instances of a user).\n     */\n    private Map<String, StoredThreadID> jids\n        = new Hashtable<String, StoredThreadID>();\n\n    /**\n     * The most recent full JID used for the contact address.\n     */\n    private Map<String, String> recentJIDForAddress\n        = new Hashtable<String, String>();\n    /**\n     * The smackMessageListener instance listens for incoming messages.\n     * Keep a reference of it so if anything goes wrong we don't add\n     * two different instances.\n     */\n    private SmackMessageListener smackMessageListener = null;\n\n    /**\n     * Contains the complete jid of a specific user and the time that it was\n     * last used so that we could remove it after a certain point.\n     */\n    public static class StoredThreadID\n    {\n        /** The time that we last sent or received a message from this jid */\n        long lastUpdatedTime;\n\n        /** The last chat used, this way we will reuse the thread-id */\n        String threadID;\n    }\n\n    /**\n     * A prefix helps to make sure that thread ID's are unique across mutliple\n     * instances.\n     */\n    private static String prefix = StringUtils.randomString(5);\n\n    /**\n     * Keeps track of the current increment, which is appended to the prefix to\n     * forum a unique thread ID.\n     */\n    private static long id = 0;\n\n    /**\n     * The number of milliseconds that we preserve threads with no traffic\n     * before considering them dead.\n     */\n    private static final long JID_INACTIVITY_TIMEOUT = 10*60*1000;//10 min.\n\n    /**\n     * Indicates the time of the last Mailbox report that we received from\n     * Google (if this is a Google server we are talking to). Should be included\n     * in all following mailbox queries\n     */\n    private long lastReceivedMailboxResultTime = -1;\n\n    /**\n     * The provider that created us.\n     */\n    private final ProtocolProviderServiceJabberImpl jabberProvider;\n\n    /**\n     * A reference to the persistent presence operation set that we use\n     * to match incoming messages to <tt>Contact</tt>s and vice versa.\n     */\n    private OperationSetPersistentPresenceJabberImpl opSetPersPresence = null;\n\n    /**\n     * The opening BODY HTML TAG: &ltbody&gt\n     */\n    private static final String OPEN_BODY_TAG = \"<body>\";\n\n    /**\n     * The closing BODY HTML TAG: &ltbody&gt\n     */\n    private static final String CLOSE_BODY_TAG = \"</body>\";\n\n    /**\n     * The html namespace used as feature\n     * XHTMLManager.namespace\n     */\n    private final static String HTML_NAMESPACE =\n        \"http://jabber.org/protocol/xhtml-im\";\n\n    /**\n     * List of filters to be used to filter which messages to handle\n     * current Operation Set.\n     */\n    private List<PacketFilter> packetFilters = new ArrayList<PacketFilter>();\n\n    /**\n     * Whether carbon is enabled or not.\n     */\n    private boolean isCarbonEnabled = false;\n\n    /**\n     * Creates an instance of this operation set.\n     * @param provider a reference to the <tt>ProtocolProviderServiceImpl</tt>\n     * that created us and that we'll use for retrieving the underlying aim\n     * connection.\n     */\n    OperationSetBasicInstantMessagingJabberImpl(\n        ProtocolProviderServiceJabberImpl provider)\n    {\n        this.jabberProvider = provider;\n\n        packetFilters.add(new GroupMessagePacketFilter());\n        packetFilters.add(\n            new PacketTypeFilter(org.jivesoftware.smack.packet.Message.class));\n\n        provider.addRegistrationStateChangeListener(\n                        new RegistrationStateListener());\n\n        ProviderManager man = ProviderManager.getInstance();\n        MessageCorrectionExtensionProvider extProvider =\n                new MessageCorrectionExtensionProvider();\n        man.addExtensionProvider(MessageCorrectionExtension.ELEMENT_NAME,\n                MessageCorrectionExtension.NAMESPACE,\n                extProvider);\n    }\n\n    /**\n     * Create a Message instance with the specified UID, content type\n     * and a default encoding.\n     * This method can be useful when message correction is required. One can\n     * construct the corrected message to have the same UID as the message\n     * before correction.\n     *\n     * @param messageText the string content of the message.\n     * @param contentType the MIME-type for <tt>content</tt>\n     * @param messageUID the unique identifier of this message.\n     * @return Message the newly created message\n     */\n    public Message createMessageWithUID(\n        String messageText, String contentType, String messageUID)\n    {\n        return new MessageJabberImpl(messageText, contentType,\n            DEFAULT_MIME_ENCODING, null, messageUID);\n    }\n\n    /**\n     * Create a Message instance for sending arbitrary MIME-encoding content.\n     *\n     * @param content content value\n     * @param contentType the MIME-type for <tt>content</tt>\n     * @return the newly created message.\n     */\n    public Message createMessage(String content, String contentType)\n    {\n        return createMessage(content, contentType, DEFAULT_MIME_ENCODING, null);\n    }\n\n    /**\n     * Create a Message instance for sending arbitrary MIME-encoding content.\n     *\n     * @param content content value\n     * @param contentType the MIME-type for <tt>content</tt>\n     * @param subject the Subject of the message that we'd like to create.\n     * @param encoding the enconding of the message that we will be sending.\n     *\n     * @return the newly created message.\n     */\n    @Override\n    public Message createMessage(String content, String contentType,\n        String encoding, String subject)\n    {\n        return new MessageJabberImpl(content, contentType, encoding, subject);\n    }\n\n    Message createMessage(String content, String contentType,\n            String messageUID)\n    {\n        return new MessageJabberImpl(content, contentType,\n                DEFAULT_MIME_ENCODING, null, messageUID);\n    }\n\n    /**\n     * Determines wheter the protocol provider (or the protocol itself) support\n     * sending and receiving offline messages. Most often this method would\n     * return true for protocols that support offline messages and false for\n     * those that don't. It is however possible for a protocol to support these\n     * messages and yet have a particular account that does not (i.e. feature\n     * not enabled on the protocol server). In cases like this it is possible\n     * for this method to return true even when offline messaging is not\n     * supported, and then have the sendMessage method throw an\n     * OperationFailedException with code - OFFLINE_MESSAGES_NOT_SUPPORTED.\n     *\n     * @return <tt>true</tt> if the protocol supports offline messages and\n     * <tt>false</tt> otherwise.\n     */\n    public boolean isOfflineMessagingSupported()\n    {\n        return true;\n    }\n\n    /**\n     * Determines wheter the protocol supports the supplied content type\n     *\n     * @param contentType the type we want to check\n     * @return <tt>true</tt> if the protocol supports it and\n     * <tt>false</tt> otherwise.\n     */\n    public boolean isContentTypeSupported(String contentType)\n    {\n        return\n            (contentType.equals(DEFAULT_MIME_TYPE)\n                || contentType.equals(HTML_MIME_TYPE));\n    }\n\n    /**\n     * Determines whether the protocol supports the supplied content type\n     * for the given contact.\n     *\n     * @param contentType the type we want to check\n     * @param contact contact which is checked for supported contentType\n     * @return <tt>true</tt> if the contact supports it and\n     * <tt>false</tt> otherwise.\n     */\n    @Override\n    public boolean isContentTypeSupported(String contentType, Contact contact)\n    {\n        // by default we support default mime type, for other mimetypes\n        // method must be overriden\n        if(contentType.equals(DEFAULT_MIME_TYPE))\n            return true;\n        else if(contentType.equals(HTML_MIME_TYPE))\n        {\n            String toJID = recentJIDForAddress.get(contact.getAddress());\n\n            if (toJID == null)\n                toJID = contact.getAddress();\n\n            return jabberProvider.isFeatureListSupported(\n                        toJID,\n                        HTML_NAMESPACE);\n        }\n\n        return false;\n    }\n\n    /**\n     * Remove from our <tt>jids</tt> map all entries that have not seen any\n     * activity (i.e. neither outgoing nor incoming messags) for more than\n     * JID_INACTIVITY_TIMEOUT. Note that this method is not synchronous and that\n     * it is only meant for use by the {@link #getThreadIDForAddress(String)} and\n     * {@link #putJidForAddress(String, String)}\n     */\n    private void purgeOldJids()\n    {\n        long currentTime = System.currentTimeMillis();\n\n        Iterator<Map.Entry<String, StoredThreadID>> entries\n            = jids.entrySet().iterator();\n\n\n        while( entries.hasNext() )\n        {\n            Map.Entry<String, StoredThreadID> entry = entries.next();\n            StoredThreadID target = entry.getValue();\n\n            if (currentTime - target.lastUpdatedTime\n                            > JID_INACTIVITY_TIMEOUT)\n                entries.remove();\n        }\n    }\n\n    /**\n     * Returns the last jid that the party with the specified <tt>address</tt>\n     * contacted us from or <tt>null</tt>(or bare jid) if we don't have a jid\n     * for the specified <tt>address</tt> yet. The method would also purge all\n     * entries that haven't seen any activity (i.e. no one has tried to get or\n     * remap it) for a delay longer than <tt>JID_INACTIVITY_TIMEOUT</tt>.\n     *\n     * @param jid the <tt>jid</tt> that we'd like to obtain a threadID for.\n     *\n     * @return the last jid that the party with the specified <tt>address</tt>\n     * contacted us from or <tt>null</tt> if we don't have a jid for the\n     * specified <tt>address</tt> yet.\n     */\n    String getThreadIDForAddress(String jid)\n    {\n        synchronized(jids)\n        {\n            purgeOldJids();\n            StoredThreadID ta = jids.get(jid);\n\n            if (ta == null)\n                return null;\n\n            ta.lastUpdatedTime = System.currentTimeMillis();\n\n            return ta.threadID;\n        }\n    }\n\n    /**\n     * Maps the specified <tt>address</tt> to <tt>jid</tt>. The point of this\n     * method is to allow us to send all messages destined to the contact with\n     * the specified <tt>address</tt> to the <tt>jid</tt> that they last\n     * contacted us from.\n     *\n     * @param threadID the threadID of conversation.\n     * @param jid the jid (i.e. address/resource) that the contact with the\n     * specified <tt>address</tt> last contacted us from.\n     */\n    private void putJidForAddress(String jid, String threadID)\n    {\n        synchronized(jids)\n        {\n            purgeOldJids();\n\n            StoredThreadID ta = jids.get(jid);\n\n            if (ta == null)\n            {\n                ta = new StoredThreadID();\n                jids.put(jid, ta);\n            }\n\n            recentJIDForAddress.put(StringUtils.parseBareAddress(jid), jid);\n\n            ta.lastUpdatedTime = System.currentTimeMillis();\n            ta.threadID = threadID;\n        }\n    }\n\n    /**\n     * Helper function used to send a message to a contact, with the given\n     * extensions attached.\n     *\n     * @param to The contact to send the message to.\n     * @param toResource The resource to send the message to or null if no\n     * resource has been specified\n     * @param message The message to send.\n     * @param extensions The XMPP extensions that should be attached to the\n     * message before sending.\n     * @return The MessageDeliveryEvent that resulted after attempting to\n     * send this message, so the calling function can modify it if needed.\n     */\n    private MessageDeliveredEvent sendMessage(  Contact to,\n                                                ContactResource toResource,\n                                                Message message,\n                                                PacketExtension[] extensions)\n    {\n        if( !(to instanceof ContactJabberImpl) )\n           throw new IllegalArgumentException(\n               \"The specified contact is not a Jabber contact.\"\n               + to);\n\n        assertConnected();\n\n        org.jivesoftware.smack.packet.Message msg =\n            new org.jivesoftware.smack.packet.Message();\n\n        String toJID = null;\n\n        if (toResource != null)\n        {\n            if(toResource.equals(ContactResource.BASE_RESOURCE))\n            {\n                toJID = to.getAddress();\n            }\n            else\n                toJID =\n                    ((ContactResourceJabberImpl) toResource).getFullJid();\n        }\n\n        if (toJID == null)\n        {\n            toJID = to.getAddress();\n        }\n\n        msg.setPacketID(message.getMessageUID());\n        msg.setTo(toJID);\n\n        for (PacketExtension ext : extensions)\n        {\n            msg.addExtension(ext);\n        }\n\n        if (logger.isTraceEnabled())\n            logger.trace(\"Will send a message to:\" + toJID\n                        + \" chat.jid=\" + toJID);\n\n        MessageDeliveredEvent msgDeliveryPendingEvt\n            = new MessageDeliveredEvent(message, to, toResource);\n\n        MessageDeliveredEvent[] transformedEvents = messageDeliveryPendingTransform(msgDeliveryPendingEvt);\n\n        if (transformedEvents == null || transformedEvents.length == 0)\n            return null;\n\n        for (MessageDeliveredEvent event : transformedEvents)\n        {\n            String content = event.getSourceMessage().getContent();\n\n            if (message.getContentType().equals(HTML_MIME_TYPE))\n            {\n                msg.setBody(Html2Text.extractText(content));\n\n                // Check if the other user supports XHTML messages\n                // make sure we use our discovery manager as it caches calls\n                if (jabberProvider\n                    .isFeatureListSupported(toJID, HTML_NAMESPACE))\n                {\n                    // Add the XHTML text to the message\n                    XHTMLManager.addBody(msg, OPEN_BODY_TAG + content\n                        + CLOSE_BODY_TAG);\n                }\n            }\n            else\n            {\n                // this is plain text so keep it as it is.\n                msg.setBody(content);\n            }\n\n            // msg.addExtension(new Version());\n\n            if (event.isMessageEncrypted() && isCarbonEnabled)\n            {\n                msg.addExtension(new CarbonPacketExtension.PrivateExtension());\n            }\n\n            MessageEventManager.addNotificationsRequests(msg, true, false,\n                false, true);\n\n            String threadID = getThreadIDForAddress(toJID);\n            if (threadID == null)\n                threadID = nextThreadID();\n\n            msg.setThread(threadID);\n            msg.setType(org.jivesoftware.smack.packet.Message.Type.chat);\n            msg.setFrom(jabberProvider.getConnection().getUser());\n\n            jabberProvider.getConnection().sendPacket(msg);\n\n            putJidForAddress(toJID, threadID);\n        }\n\n        return new MessageDeliveredEvent(message, to, toResource);\n    }\n\n    /**\n     * Sends the <tt>message</tt> to the destination indicated by the\n     * <tt>to</tt> contact.\n     *\n     * @param to the <tt>Contact</tt> to send <tt>message</tt> to\n     * @param message the <tt>Message</tt> to send.\n     * @throws java.lang.IllegalStateException if the underlying stack is\n     * not registered and initialized.\n     * @throws java.lang.IllegalArgumentException if <tt>to</tt> is not an\n     * instance of ContactImpl.\n     */\n    public void sendInstantMessage(Contact to, Message message)\n        throws IllegalStateException, IllegalArgumentException\n    {\n        sendInstantMessage(to, null, message);\n    }\n\n    /**\n     * Sends the <tt>message</tt> to the destination indicated by the\n     * <tt>to</tt>. Provides a default implementation of this method.\n     *\n     * @param to the <tt>Contact</tt> to send <tt>message</tt> to\n     * @param toResource the resource to which the message should be send\n     * @param message the <tt>Message</tt> to send.\n     * @throws java.lang.IllegalStateException if the underlying ICQ stack is\n     * not registered and initialized.\n     * @throws java.lang.IllegalArgumentException if <tt>to</tt> is not an\n     * instance belonging to the underlying implementation.\n     */\n    @Override\n    public void sendInstantMessage( Contact to,\n                                    ContactResource toResource,\n                                    Message message)\n        throws  IllegalStateException,\n                IllegalArgumentException\n    {\n        MessageDeliveredEvent msgDelivered =\n            sendMessage(to, toResource, message, new PacketExtension[0]);\n\n        fireMessageEvent(msgDelivered);\n    }\n\n    /**\n     * Replaces the message with ID <tt>correctedMessageUID</tt> sent to\n     * the contact <tt>to</tt> with the message <tt>message</tt>\n     *\n     * @param to The contact to send the message to.\n     * @param message The new message.\n     * @param correctedMessageUID The ID of the message being replaced.\n     */\n    public void correctMessage(\n        Contact to, ContactResource resource,\n        Message message, String correctedMessageUID)\n    {\n        PacketExtension[] exts = new PacketExtension[1];\n        exts[0] = new MessageCorrectionExtension(correctedMessageUID);\n        MessageDeliveredEvent msgDelivered\n            = sendMessage(to, resource, message, exts);\n        msgDelivered.setCorrectedMessageUID(correctedMessageUID);\n        fireMessageEvent(msgDelivered);\n    }\n\n    /**\n     * Utility method throwing an exception if the stack is not properly\n     * initialized.\n     *\n     * @throws java.lang.IllegalStateException if the underlying stack is\n     * not registered and initialized.\n     */\n    private void assertConnected()\n        throws IllegalStateException\n    {\n        if (opSetPersPresence == null)\n        {\n            throw\n                new IllegalStateException(\n                        \"The provider must be signed on the service before\"\n                            + \" being able to communicate.\");\n        }\n        else\n            opSetPersPresence.assertConnected();\n    }\n\n    /**\n     * Our listener that will tell us when we're registered to\n     */\n    private class RegistrationStateListener\n        implements RegistrationStateChangeListener\n    {\n        /**\n         * The method is called by a ProtocolProvider implementation whenever\n         * a change in the registration state of the corresponding provider had\n         * occurred.\n         * @param evt ProviderStatusChangeEvent the event describing the status\n         * change.\n         */\n        public void registrationStateChanged(RegistrationStateChangeEvent evt)\n        {\n            if (logger.isDebugEnabled())\n                logger.debug(\"The provider changed state from: \"\n                         + evt.getOldState()\n                         + \" to: \" + evt.getNewState());\n\n            if (evt.getNewState() == RegistrationState.REGISTERING)\n            {\n                opSetPersPresence\n                    = (OperationSetPersistentPresenceJabberImpl)\n                        jabberProvider.getOperationSet(\n                                OperationSetPersistentPresence.class);\n\n                if(smackMessageListener == null)\n                {\n                    smackMessageListener = new SmackMessageListener();\n                }\n                else\n                {\n                    // make sure this listener is not already installed in this\n                    // connection\n                    jabberProvider.getConnection()\n                        .removePacketListener(smackMessageListener);\n                }\n\n                jabberProvider.getConnection().addPacketListener(\n                        smackMessageListener,\n                        new AndFilter(\n                            packetFilters.toArray(\n                                new PacketFilter[packetFilters.size()])));\n            }\n            else if (evt.getNewState() == RegistrationState.REGISTERED)\n            {\n                new Thread(new Runnable()\n                {\n                    @Override\n                    public void run()\n                    {\n                        initAdditionalServices();\n                    }\n                }).start();\n            }\n            else if(evt.getNewState() == RegistrationState.UNREGISTERED\n                || evt.getNewState() == RegistrationState.CONNECTION_FAILED\n                || evt.getNewState() == RegistrationState.AUTHENTICATION_FAILED)\n            {\n                if(jabberProvider.getConnection() != null)\n                {\n                    if(smackMessageListener != null)\n                        jabberProvider.getConnection().removePacketListener(\n                            smackMessageListener);\n                }\n\n                smackMessageListener = null;\n            }\n        }\n    }\n\n    /**\n     * Initialize additional services, like gmail notifications and message\n     * carbons.\n     */\n    private void initAdditionalServices()\n    {\n        //subscribe for Google (Gmail or Google Apps) notifications\n        //for new mail messages.\n        boolean enableGmailNotifications\n            = jabberProvider\n            .getAccountID()\n            .getAccountPropertyBoolean(\n                \"GMAIL_NOTIFICATIONS_ENABLED\",\n                false);\n\n        if (enableGmailNotifications)\n            subscribeForGmailNotifications();\n\n        boolean enableCarbon\n            = isCarbonSupported() && !jabberProvider.getAccountID()\n            .getAccountPropertyBoolean(\n                ProtocolProviderFactory.IS_CARBON_DISABLED,\n                false);\n        if(enableCarbon)\n        {\n            enableDisableCarbon(true);\n        }\n        else\n        {\n            isCarbonEnabled = false;\n        }\n    }\n\n    /**\n     * Sends enable or disable carbon packet to the server.\n     * @param enable if <tt>true</tt> sends enable packet otherwise sends\n     * disable packet.\n     */\n    private void enableDisableCarbon(final boolean enable)\n    {\n        IQ iq = new IQ(){\n\n            @Override\n            public String getChildElementXML()\n            {\n                return \"<\" + (enable? \"enable\" : \"disable\") + \" xmlns='urn:xmpp:carbons:2' />\";\n            }\n\n        };\n\n        Packet response = null;\n        try\n        {\n            PacketCollector packetCollector\n                = jabberProvider.getConnection().createPacketCollector(\n                        new PacketIDFilter(iq.getPacketID()));\n            iq.setFrom(jabberProvider.getOurJID());\n            iq.setType(IQ.Type.SET);\n            jabberProvider.getConnection().sendPacket(iq);\n            response\n                = packetCollector.nextResult(\n                        SmackConfiguration.getPacketReplyTimeout());\n\n            packetCollector.cancel();\n        }\n        catch(Exception e)\n        {\n            logger.error(\"Failed to enable carbon.\", e);\n        }\n\n        isCarbonEnabled = false;\n\n        if (response == null)\n        {\n            logger.error(\n                    \"Failed to enable carbon. No response is received.\");\n        }\n        else if (response.getError() != null)\n        {\n            logger.error(\n                    \"Failed to enable carbon: \"\n                        + response.getError());\n        }\n        else if (!(response instanceof IQ)\n            || !((IQ) response).getType().equals(IQ.Type.RESULT))\n        {\n            logger.error(\n                    \"Failed to enable carbon. The response is not correct.\");\n        }\n        else\n        {\n            isCarbonEnabled = true;\n        }\n    }\n\n    /**\n     * Checks whether the carbon is supported by the server or not.\n     * @return <tt>true</tt> if carbon is supported by the server and\n     * <tt>false</tt> if not.\n     */\n    private boolean isCarbonSupported()\n    {\n        try\n        {\n            return jabberProvider.getDiscoveryManager().discoverInfo(\n                jabberProvider.getAccountID().getService())\n                .containsFeature(CarbonPacketExtension.NAMESPACE);\n        }\n        catch (XMPPException e)\n        {\n           logger.warn(\"Failed to retrieve carbon support.\" + e.getMessage());\n        }\n        return false;\n    }\n\n    /**\n     * The listener that we use in order to handle incoming messages.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private class SmackMessageListener\n        implements PacketListener\n    {\n        /**\n         * Handles incoming messages and dispatches whatever events are\n         * necessary.\n         * @param packet the packet that we need to handle (if it is a message).\n         */\n        public void processPacket(Packet packet)\n        {\n            if(!(packet instanceof org.jivesoftware.smack.packet.Message))\n                return;\n\n            org.jivesoftware.smack.packet.Message msg =\n                (org.jivesoftware.smack.packet.Message)packet;\n\n            boolean isForwardedSentMessage = false;\n            if(msg.getBody() == null)\n            {\n\n                CarbonPacketExtension carbonExt\n                    = (CarbonPacketExtension) msg.getExtension(\n                        CarbonPacketExtension.NAMESPACE);\n                if(carbonExt == null)\n                    return;\n\n                isForwardedSentMessage\n                    = (carbonExt.getElementName()\n                        == CarbonPacketExtension.SENT_ELEMENT_NAME);\n                List<ForwardedPacketExtension> extensions\n                    = carbonExt.getChildExtensionsOfType(\n                        ForwardedPacketExtension.class);\n                if(extensions.isEmpty())\n                    return;\n                ForwardedPacketExtension forwardedExt = extensions.get(0);\n                msg = forwardedExt.getMessage();\n                if(msg == null || msg.getBody() == null)\n                    return;\n\n            }\n\n            Object multiChatExtension =\n                msg.getExtension(\"x\", \"http://jabber.org/protocol/muc#user\");\n\n            // its not for us\n            if(multiChatExtension != null)\n                return;\n\n            String userFullId\n                = isForwardedSentMessage? msg.getTo() : msg.getFrom();\n\n            String userBareID = StringUtils.parseBareAddress(userFullId);\n\n            boolean isPrivateMessaging = false;\n            ChatRoom privateContactRoom = null;\n            OperationSetMultiUserChatJabberImpl mucOpSet =\n                (OperationSetMultiUserChatJabberImpl)jabberProvider\n                    .getOperationSet(OperationSetMultiUserChat.class);\n            if(mucOpSet != null)\n                privateContactRoom = mucOpSet.getChatRoom(userBareID);\n\n            if(privateContactRoom != null)\n            {\n                isPrivateMessaging = true;\n            }\n\n            if(logger.isDebugEnabled())\n            {\n                if (logger.isDebugEnabled())\n                    logger.debug(\"Received from \"\n                             + userBareID\n                             + \" the message \"\n                             + msg.toXML());\n            }\n\n            Message newMessage = createMessage(msg.getBody(),\n                    DEFAULT_MIME_TYPE, msg.getPacketID());\n\n            //check if the message is available in xhtml\n            PacketExtension ext = msg.getExtension(\n                            \"http://jabber.org/protocol/xhtml-im\");\n\n            if(ext != null)\n            {\n                XHTMLExtension xhtmlExt\n                    = (XHTMLExtension)ext;\n\n                //parse all bodies\n                Iterator<String> bodies = xhtmlExt.getBodies();\n                StringBuffer messageBuff = new StringBuffer();\n                while (bodies.hasNext())\n                {\n                    String body = bodies.next();\n                    messageBuff.append(body);\n                }\n\n                if (messageBuff.length() > 0)\n                {\n                    // we remove body tags around message cause their\n                    // end body tag is breaking\n                    // the visualization as html in the UI\n                    String receivedMessage =\n                        messageBuff.toString()\n                        // removes body start tag\n                        .replaceAll(\"\\\\<[bB][oO][dD][yY].*?>\",\"\")\n                        // removes body end tag\n                        .replaceAll(\"\\\\</[bB][oO][dD][yY].*?>\",\"\");\n\n                    // for some reason &apos; is not rendered correctly\n                    // from our ui, lets use its equivalent. Other\n                    // similar chars(< > & \") seem ok.\n                    receivedMessage =\n                            receivedMessage.replaceAll(\"&apos;\", \"&#39;\");\n\n                    newMessage = createMessage(receivedMessage,\n                            HTML_MIME_TYPE, msg.getPacketID());\n                }\n            }\n\n            PacketExtension correctionExtension =\n                    msg.getExtension(MessageCorrectionExtension.NAMESPACE);\n            String correctedMessageUID = null;\n            if (correctionExtension != null)\n            {\n                correctedMessageUID = ((MessageCorrectionExtension)\n                        correctionExtension).getCorrectedMessageUID();\n            }\n\n            Contact sourceContact\n                = opSetPersPresence.findContactByID(\n                    (isPrivateMessaging? userFullId : userBareID));\n            if(msg.getType()\n                            == org.jivesoftware.smack.packet.Message.Type.error)\n            {\n                // error which is multichat and we don't know about the contact\n                // is a muc message error which is missing muc extension\n                // and is coming from the room, when we try to send message to\n                // room which was deleted or offline on the server\n                if(isPrivateMessaging && sourceContact == null)\n                {\n                    if(privateContactRoom != null)\n                    {\n                        XMPPError error = packet.getError();\n                        int errorResultCode\n                            = ChatRoomMessageDeliveryFailedEvent.UNKNOWN_ERROR;\n\n                        if(error != null && error.getCode() == 403)\n                        {\n                            errorResultCode\n                                = ChatRoomMessageDeliveryFailedEvent.FORBIDDEN;\n                        }\n\n                        String errorReason = error.getMessage();\n\n                        ChatRoomMessageDeliveryFailedEvent evt =\n                            new ChatRoomMessageDeliveryFailedEvent(\n                                privateContactRoom,\n                                null,\n                                errorResultCode,\n                                errorReason,\n                                new Date(),\n                                newMessage);\n                        ((ChatRoomJabberImpl)privateContactRoom)\n                            .fireMessageEvent(evt);\n                    }\n\n                    return;\n                }\n\n                if (logger.isInfoEnabled())\n                    logger.info(\"Message error received from \" + userBareID);\n\n                int errorResultCode = MessageDeliveryFailedEvent.UNKNOWN_ERROR;\n                if (packet.getError() != null)\n                {\n                    int errorCode = packet.getError().getCode();\n    \n                    if(errorCode == 503)\n                    {\n                        org.jivesoftware.smackx.packet.MessageEvent msgEvent =\n                            (org.jivesoftware.smackx.packet.MessageEvent)\n                                packet.getExtension(\"x\", \"jabber:x:event\");\n                        if(msgEvent != null && msgEvent.isOffline())\n                        {\n                            errorResultCode =\n                                MessageDeliveryFailedEvent\n                                    .OFFLINE_MESSAGES_NOT_SUPPORTED;\n                        }\n                    }\n                }\n\n                if (sourceContact == null)\n                {\n                    sourceContact = opSetPersPresence.createVolatileContact(\n                        userFullId, isPrivateMessaging);\n                }\n\n                MessageDeliveryFailedEvent ev\n                    = new MessageDeliveryFailedEvent(newMessage,\n                                                     sourceContact,\n                                                     correctedMessageUID,\n                                                     errorResultCode);\n\n                // ev = messageDeliveryFailedTransform(ev);\n\n                if (ev != null)\n                    fireMessageEvent(ev);\n                return;\n            }\n            putJidForAddress(userFullId, msg.getThread());\n\n            // In the second condition we filter all group chat messages,\n            // because they are managed by the multi user chat operation set.\n            if(sourceContact == null)\n            {\n                if (logger.isDebugEnabled())\n                    logger.debug(\"received a message from an unknown contact: \"\n                                   + userBareID);\n                //create the volatile contact\n                sourceContact = opSetPersPresence\n                    .createVolatileContact(\n                        userFullId,\n                        isPrivateMessaging);\n            }\n\n            Date timestamp = new Date();\n            //Check for XEP-0091 timestamp (deprecated)\n            PacketExtension delay = msg.getExtension(\"x\", \"jabber:x:delay\");\n            if(delay != null && delay instanceof DelayInformation)\n            {\n                timestamp = ((DelayInformation)delay).getStamp();\n            }\n            //check for XEP-0203 timestamp\n            delay = msg.getExtension(\"delay\", \"urn:xmpp:delay\");\n            if(delay != null && delay instanceof DelayInfo)\n            {\n                timestamp = ((DelayInfo)delay).getStamp();\n            }\n\n            ContactResource resource = ((ContactJabberImpl) sourceContact)\n                    .getResourceFromJid(userFullId);\n\n            EventObject msgEvt = null;\n            if(!isForwardedSentMessage)\n                msgEvt\n                    = new MessageReceivedEvent( newMessage,\n                                                sourceContact,\n                                                resource,\n                                                timestamp,\n                                                correctedMessageUID,\n                                                isPrivateMessaging,\n                                                privateContactRoom);\n            else\n                msgEvt = new MessageDeliveredEvent(newMessage, sourceContact, timestamp);\n            // msgReceivedEvt = messageReceivedTransform(msgReceivedEvt);\n            if (msgEvt != null)\n                fireMessageEvent(msgEvt);\n        }\n    }\n\n\n    /**\n     * A filter that prevents this operation set from handling multi user chat\n     * messages.\n     */\n    private static class GroupMessagePacketFilter implements PacketFilter\n    {\n        /**\n         * Returns <tt>true</tt> if <tt>packet</tt> is a <tt>Message</tt> and\n         * false otherwise.\n         *\n         * @param packet the packet that we need to check.\n         *\n         * @return  <tt>true</tt> if <tt>packet</tt> is a <tt>Message</tt> and\n         * false otherwise.\n         */\n        public boolean accept(Packet packet)\n        {\n            if(!(packet instanceof org.jivesoftware.smack.packet.Message))\n                return false;\n\n            org.jivesoftware.smack.packet.Message msg\n                = (org.jivesoftware.smack.packet.Message) packet;\n\n            return\n                !msg.getType().equals(\n                        org.jivesoftware.smack.packet.Message.Type.groupchat);\n        }\n    }\n\n    /**\n     * Subscribes this provider as interested in receiving notifications for\n     * new mail messages from Google mail services such as Gmail or Google Apps.\n     */\n    private void subscribeForGmailNotifications()\n    {\n        // first check support for the notification service\n        String accountIDService = jabberProvider.getAccountID().getService();\n        boolean notificationsAreSupported\n            = jabberProvider.isFeatureSupported(\n                    accountIDService,\n                    NewMailNotificationIQ.NAMESPACE);\n\n        if (!notificationsAreSupported)\n        {\n            if (logger.isDebugEnabled())\n                logger.debug(accountIDService\n                        +\" does not seem to provide a Gmail notification \"\n                        +\" service so we won't be trying to subscribe for it\");\n            return;\n        }\n\n        if (logger.isDebugEnabled())\n            logger.debug(accountIDService\n                        +\" seems to provide a Gmail notification \"\n                        +\" service so we will try to subscribe for it\");\n\n        ProviderManager providerManager = ProviderManager.getInstance();\n\n        providerManager.addIQProvider(\n                MailboxIQ.ELEMENT_NAME,\n                MailboxIQ.NAMESPACE,\n                new MailboxIQProvider());\n        providerManager.addIQProvider(\n                NewMailNotificationIQ.ELEMENT_NAME,\n                NewMailNotificationIQ.NAMESPACE,\n                new NewMailNotificationProvider());\n\n        Connection connection = jabberProvider.getConnection();\n\n        connection.addPacketListener(\n                new MailboxIQListener(), new PacketTypeFilter(MailboxIQ.class));\n        connection.addPacketListener(\n                new NewMailNotificationListener(),\n                new PacketTypeFilter(NewMailNotificationIQ.class));\n\n        if(opSetPersPresence.getCurrentStatusMessage().equals(\n                JabberStatusEnum.OFFLINE))\n           return;\n\n        //create a query with -1 values for newer-than-tid and\n        //newer-than-time attributes\n        MailboxQueryIQ mailboxQuery = new MailboxQueryIQ();\n\n        if (logger.isTraceEnabled())\n            logger.trace(\"sending mailNotification for acc: \"\n                    + jabberProvider.getAccountID().getAccountUniqueID());\n        jabberProvider.getConnection().sendPacket(mailboxQuery);\n    }\n\n    /**\n     * Creates an html description of the specified mailbox.\n     *\n     * @param mailboxIQ the mailboxIQ that we are to describe.\n     *\n     * @return an html description of <tt>mailboxIQ</tt>\n     */\n    private String createMailboxDescription(MailboxIQ mailboxIQ)\n    {\n        int threadCount = mailboxIQ.getThreadCount();\n\n        String resourceHeaderKey = threadCount > 1\n            ? \"service.gui.NEW_GMAIL_MANY_HEADER\"\n            : \"service.gui.NEW_GMAIL_HEADER\";\n\n        String resourceFooterKey = threadCount > 1\n            ? \"service.gui.NEW_GMAIL_MANY_FOOTER\"\n            : \"service.gui.NEW_GMAIL_FOOTER\";\n\n        // FIXME Escape HTML!\n        String newMailHeader = JabberActivator.getResources().getI18NString(\n            resourceHeaderKey,\n            new String[]\n                {\n                    jabberProvider.getAccountID()\n                                .getService(),     //{0} - service name\n                    mailboxIQ.getUrl(),            //{1} - inbox URI\n                    Integer.toString( threadCount )//{2} - thread count\n                });\n\n        StringBuilder message = new StringBuilder(newMailHeader);\n\n        //we now start an html table for the threads.\n        message.append(\"<table width=100% cellpadding=2 cellspacing=0 \");\n        message.append(\"border=0 bgcolor=#e8eef7>\");\n\n        Iterator<MailThreadInfo> threads = mailboxIQ.threads();\n\n        String maxThreadsStr = (String)JabberActivator.getConfigurationService()\n            .getProperty(PNAME_MAX_GMAIL_THREADS_PER_NOTIFICATION);\n\n        int maxThreads = 5;\n\n        try\n        {\n            if(maxThreadsStr != null)\n                maxThreads = Integer.parseInt(maxThreadsStr);\n        }\n        catch (NumberFormatException e)\n        {\n            if (logger.isDebugEnabled())\n                logger.debug(\"Failed to parse max threads count: \"+maxThreads\n                            +\". Going for default.\");\n        }\n\n        //print a maximum of MAX_THREADS\n        for (int i = 0; i < maxThreads && threads.hasNext(); i++)\n        {\n            message.append(threads.next().createHtmlDescription());\n        }\n        message.append(\"</table><br/>\");\n\n        if(threadCount > maxThreads)\n        {\n            String messageFooter = JabberActivator.getResources().getI18NString(\n                resourceFooterKey,\n                new String[]\n                {\n                    mailboxIQ.getUrl(),            //{0} - inbox URI\n                    Integer.toString(\n                        threadCount - maxThreads )//{1} - thread count\n                });\n            message.append(messageFooter);\n        }\n\n        return message.toString();\n    }\n\n    public String getRecentJIDForAddress(String address)\n    {\n        return recentJIDForAddress.get(address);\n    }\n\n    /**\n     * Receives incoming MailNotification Packets\n     */\n    private class MailboxIQListener\n        implements PacketListener\n    {\n        /**\n         * Handles incoming <tt>MailboxIQ</tt> packets.\n         *\n         * @param packet the IQ that we need to handle in case it is a\n         * <tt>MailboxIQ</tt>.\n         */\n        public void processPacket(Packet packet)\n        {\n            if(packet != null && !(packet instanceof MailboxIQ))\n                return;\n\n            MailboxIQ mailboxIQ = (MailboxIQ) packet;\n\n            if(mailboxIQ.getTotalMatched() < 1)\n                return;\n\n            //Get a reference to a dummy volatile contact\n            Contact sourceContact = opSetPersPresence\n                .findContactByID(jabberProvider.getAccountID().getService());\n\n            if(sourceContact == null)\n                sourceContact = opSetPersPresence.createVolatileContact(\n                                jabberProvider.getAccountID().getService());\n\n            lastReceivedMailboxResultTime = mailboxIQ.getResultTime();\n\n            String newMail = createMailboxDescription(mailboxIQ);\n\n            Message newMailMessage = new MessageJabberImpl(\n                newMail, HTML_MIME_TYPE, DEFAULT_MIME_ENCODING, null);\n\n            MessageReceivedEvent msgReceivedEvt = new MessageReceivedEvent(\n                newMailMessage, sourceContact, new Date(),\n                MessageReceivedEvent.SYSTEM_MESSAGE_RECEIVED);\n\n            fireMessageEvent(msgReceivedEvt);\n        }\n    }\n\n    /**\n     * Receives incoming NewMailNotification Packets.\n     */\n    private class NewMailNotificationListener\n        implements PacketListener\n    {\n        /**\n         * Handles incoming <tt>NewMailNotificationIQ</tt> packets.\n         *\n         * @param packet the IQ that we need to handle in case it is a\n         * <tt>NewMailNotificationIQ</tt>.\n         */\n        public void processPacket(Packet packet)\n        {\n            if(packet != null &&  !(packet instanceof NewMailNotificationIQ))\n                return;\n\n            //check whether we are still enabled.\n            boolean enableGmailNotifications\n                = jabberProvider\n                    .getAccountID()\n                        .getAccountPropertyBoolean(\n                            \"GMAIL_NOTIFICATIONS_ENABLED\",\n                            false);\n\n            if (!enableGmailNotifications)\n                return;\n\n            if(opSetPersPresence.getCurrentStatusMessage()\n                    .equals(JabberStatusEnum.OFFLINE))\n                return;\n\n            MailboxQueryIQ mailboxQueryIQ = new MailboxQueryIQ();\n\n            if(lastReceivedMailboxResultTime != -1)\n                mailboxQueryIQ.setNewerThanTime(\n                                lastReceivedMailboxResultTime);\n\n            if (logger.isTraceEnabled())\n                logger.trace(\n                \"send mailNotification for acc: \"\n                + jabberProvider.getAccountID().getAccountUniqueID());\n\n            jabberProvider.getConnection().sendPacket(mailboxQueryIQ);\n        }\n    }\n\n    /**\n     * Returns the inactivity timeout in milliseconds.\n     *\n     * @return The inactivity timeout in milliseconds. Or -1 if undefined\n     */\n    public long getInactivityTimeout()\n    {\n        return JID_INACTIVITY_TIMEOUT;\n    }\n\n    /**\n     * Adds additional filters for incoming messages. To be able to skip some\n     * messages.\n     * @param filter to add\n     */\n    public void addMessageFilters(PacketFilter filter)\n    {\n        this.packetFilters.add(filter);\n    }\n\n    /**\n     * Returns the next unique thread id. Each thread id made up of a short\n     * alphanumeric prefix along with a unique numeric value.\n     *\n     * @return the next thread id.\n     */\n    public static synchronized String nextThreadID() {\n        return prefix + Long.toString(id++);\n    }\n\n\n}\n"], "fixing_code": ["/*\n * Jitsi, the OpenSource Java VoIP and Instant Messaging client.\n *\n * Copyright @ 2015 Atlassian Pty Ltd\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.java.sip.communicator.impl.protocol.jabber;\n\nimport java.util.*;\n\nimport net.java.sip.communicator.impl.protocol.jabber.extensions.carbon.*;\nimport net.java.sip.communicator.impl.protocol.jabber.extensions.mailnotification.*;\nimport net.java.sip.communicator.impl.protocol.jabber.extensions.messagecorrection.*;\nimport net.java.sip.communicator.service.protocol.*;\nimport net.java.sip.communicator.service.protocol.Message;\nimport net.java.sip.communicator.service.protocol.event.*;\nimport net.java.sip.communicator.service.protocol.jabberconstants.*;\nimport net.java.sip.communicator.util.*;\n\nimport org.jivesoftware.smack.*;\nimport org.jivesoftware.smack.filter.*;\nimport org.jivesoftware.smack.packet.*;\nimport org.jivesoftware.smack.provider.*;\nimport org.jivesoftware.smack.util.*;\nimport org.jivesoftware.smackx.*;\nimport org.jivesoftware.smackx.packet.*;\n\n/**\n * A straightforward implementation of the basic instant messaging operation\n * set.\n *\n * @author Damian Minkov\n * @author Matthieu Helleringer\n * @author Alain Knaebel\n * @author Emil Ivov\n * @author Hristo Terezov\n */\npublic class OperationSetBasicInstantMessagingJabberImpl\n    extends AbstractOperationSetBasicInstantMessaging\n    implements OperationSetMessageCorrection\n{\n    /**\n     * Our class logger\n     */\n    private static final Logger logger =\n        Logger.getLogger(OperationSetBasicInstantMessagingJabberImpl.class);\n\n    /**\n     * The maximum number of unread threads that we'd be notifying the user of.\n     */\n    private static final String PNAME_MAX_GMAIL_THREADS_PER_NOTIFICATION\n        = \"net.java.sip.communicator.impl.protocol.jabber.\"\n            +\"MAX_GMAIL_THREADS_PER_NOTIFICATION\";\n\n    /**\n     * A table mapping contact addresses to full jids that can be used to\n     * target a specific resource (rather than sending a message to all logged\n     * instances of a user).\n     */\n    private Map<String, StoredThreadID> jids\n        = new Hashtable<String, StoredThreadID>();\n\n    /**\n     * The most recent full JID used for the contact address.\n     */\n    private Map<String, String> recentJIDForAddress\n        = new Hashtable<String, String>();\n    /**\n     * The smackMessageListener instance listens for incoming messages.\n     * Keep a reference of it so if anything goes wrong we don't add\n     * two different instances.\n     */\n    private SmackMessageListener smackMessageListener = null;\n\n    /**\n     * Contains the complete jid of a specific user and the time that it was\n     * last used so that we could remove it after a certain point.\n     */\n    public static class StoredThreadID\n    {\n        /** The time that we last sent or received a message from this jid */\n        long lastUpdatedTime;\n\n        /** The last chat used, this way we will reuse the thread-id */\n        String threadID;\n    }\n\n    /**\n     * A prefix helps to make sure that thread ID's are unique across mutliple\n     * instances.\n     */\n    private static String prefix = StringUtils.randomString(5);\n\n    /**\n     * Keeps track of the current increment, which is appended to the prefix to\n     * forum a unique thread ID.\n     */\n    private static long id = 0;\n\n    /**\n     * The number of milliseconds that we preserve threads with no traffic\n     * before considering them dead.\n     */\n    private static final long JID_INACTIVITY_TIMEOUT = 10*60*1000;//10 min.\n\n    /**\n     * Indicates the time of the last Mailbox report that we received from\n     * Google (if this is a Google server we are talking to). Should be included\n     * in all following mailbox queries\n     */\n    private long lastReceivedMailboxResultTime = -1;\n\n    /**\n     * The provider that created us.\n     */\n    private final ProtocolProviderServiceJabberImpl jabberProvider;\n\n    /**\n     * A reference to the persistent presence operation set that we use\n     * to match incoming messages to <tt>Contact</tt>s and vice versa.\n     */\n    private OperationSetPersistentPresenceJabberImpl opSetPersPresence = null;\n\n    /**\n     * The opening BODY HTML TAG: &ltbody&gt\n     */\n    private static final String OPEN_BODY_TAG = \"<body>\";\n\n    /**\n     * The closing BODY HTML TAG: &ltbody&gt\n     */\n    private static final String CLOSE_BODY_TAG = \"</body>\";\n\n    /**\n     * The html namespace used as feature\n     * XHTMLManager.namespace\n     */\n    private final static String HTML_NAMESPACE =\n        \"http://jabber.org/protocol/xhtml-im\";\n\n    /**\n     * List of filters to be used to filter which messages to handle\n     * current Operation Set.\n     */\n    private List<PacketFilter> packetFilters = new ArrayList<PacketFilter>();\n\n    /**\n     * Whether carbon is enabled or not.\n     */\n    private boolean isCarbonEnabled = false;\n\n    /**\n     * Creates an instance of this operation set.\n     * @param provider a reference to the <tt>ProtocolProviderServiceImpl</tt>\n     * that created us and that we'll use for retrieving the underlying aim\n     * connection.\n     */\n    OperationSetBasicInstantMessagingJabberImpl(\n        ProtocolProviderServiceJabberImpl provider)\n    {\n        this.jabberProvider = provider;\n\n        packetFilters.add(new GroupMessagePacketFilter());\n        packetFilters.add(\n            new PacketTypeFilter(org.jivesoftware.smack.packet.Message.class));\n\n        provider.addRegistrationStateChangeListener(\n                        new RegistrationStateListener());\n\n        ProviderManager man = ProviderManager.getInstance();\n        MessageCorrectionExtensionProvider extProvider =\n                new MessageCorrectionExtensionProvider();\n        man.addExtensionProvider(MessageCorrectionExtension.ELEMENT_NAME,\n                MessageCorrectionExtension.NAMESPACE,\n                extProvider);\n    }\n\n    /**\n     * Create a Message instance with the specified UID, content type\n     * and a default encoding.\n     * This method can be useful when message correction is required. One can\n     * construct the corrected message to have the same UID as the message\n     * before correction.\n     *\n     * @param messageText the string content of the message.\n     * @param contentType the MIME-type for <tt>content</tt>\n     * @param messageUID the unique identifier of this message.\n     * @return Message the newly created message\n     */\n    public Message createMessageWithUID(\n        String messageText, String contentType, String messageUID)\n    {\n        return new MessageJabberImpl(messageText, contentType,\n            DEFAULT_MIME_ENCODING, null, messageUID);\n    }\n\n    /**\n     * Create a Message instance for sending arbitrary MIME-encoding content.\n     *\n     * @param content content value\n     * @param contentType the MIME-type for <tt>content</tt>\n     * @return the newly created message.\n     */\n    public Message createMessage(String content, String contentType)\n    {\n        return createMessage(content, contentType, DEFAULT_MIME_ENCODING, null);\n    }\n\n    /**\n     * Create a Message instance for sending arbitrary MIME-encoding content.\n     *\n     * @param content content value\n     * @param contentType the MIME-type for <tt>content</tt>\n     * @param subject the Subject of the message that we'd like to create.\n     * @param encoding the enconding of the message that we will be sending.\n     *\n     * @return the newly created message.\n     */\n    @Override\n    public Message createMessage(String content, String contentType,\n        String encoding, String subject)\n    {\n        return new MessageJabberImpl(content, contentType, encoding, subject);\n    }\n\n    Message createMessage(String content, String contentType,\n            String messageUID)\n    {\n        return new MessageJabberImpl(content, contentType,\n                DEFAULT_MIME_ENCODING, null, messageUID);\n    }\n\n    /**\n     * Determines wheter the protocol provider (or the protocol itself) support\n     * sending and receiving offline messages. Most often this method would\n     * return true for protocols that support offline messages and false for\n     * those that don't. It is however possible for a protocol to support these\n     * messages and yet have a particular account that does not (i.e. feature\n     * not enabled on the protocol server). In cases like this it is possible\n     * for this method to return true even when offline messaging is not\n     * supported, and then have the sendMessage method throw an\n     * OperationFailedException with code - OFFLINE_MESSAGES_NOT_SUPPORTED.\n     *\n     * @return <tt>true</tt> if the protocol supports offline messages and\n     * <tt>false</tt> otherwise.\n     */\n    public boolean isOfflineMessagingSupported()\n    {\n        return true;\n    }\n\n    /**\n     * Determines wheter the protocol supports the supplied content type\n     *\n     * @param contentType the type we want to check\n     * @return <tt>true</tt> if the protocol supports it and\n     * <tt>false</tt> otherwise.\n     */\n    public boolean isContentTypeSupported(String contentType)\n    {\n        return\n            (contentType.equals(DEFAULT_MIME_TYPE)\n                || contentType.equals(HTML_MIME_TYPE));\n    }\n\n    /**\n     * Determines whether the protocol supports the supplied content type\n     * for the given contact.\n     *\n     * @param contentType the type we want to check\n     * @param contact contact which is checked for supported contentType\n     * @return <tt>true</tt> if the contact supports it and\n     * <tt>false</tt> otherwise.\n     */\n    @Override\n    public boolean isContentTypeSupported(String contentType, Contact contact)\n    {\n        // by default we support default mime type, for other mimetypes\n        // method must be overriden\n        if(contentType.equals(DEFAULT_MIME_TYPE))\n            return true;\n        else if(contentType.equals(HTML_MIME_TYPE))\n        {\n            String toJID = recentJIDForAddress.get(contact.getAddress());\n\n            if (toJID == null)\n                toJID = contact.getAddress();\n\n            return jabberProvider.isFeatureListSupported(\n                        toJID,\n                        HTML_NAMESPACE);\n        }\n\n        return false;\n    }\n\n    /**\n     * Remove from our <tt>jids</tt> map all entries that have not seen any\n     * activity (i.e. neither outgoing nor incoming messags) for more than\n     * JID_INACTIVITY_TIMEOUT. Note that this method is not synchronous and that\n     * it is only meant for use by the {@link #getThreadIDForAddress(String)} and\n     * {@link #putJidForAddress(String, String)}\n     */\n    private void purgeOldJids()\n    {\n        long currentTime = System.currentTimeMillis();\n\n        Iterator<Map.Entry<String, StoredThreadID>> entries\n            = jids.entrySet().iterator();\n\n\n        while( entries.hasNext() )\n        {\n            Map.Entry<String, StoredThreadID> entry = entries.next();\n            StoredThreadID target = entry.getValue();\n\n            if (currentTime - target.lastUpdatedTime\n                            > JID_INACTIVITY_TIMEOUT)\n                entries.remove();\n        }\n    }\n\n    /**\n     * Returns the last jid that the party with the specified <tt>address</tt>\n     * contacted us from or <tt>null</tt>(or bare jid) if we don't have a jid\n     * for the specified <tt>address</tt> yet. The method would also purge all\n     * entries that haven't seen any activity (i.e. no one has tried to get or\n     * remap it) for a delay longer than <tt>JID_INACTIVITY_TIMEOUT</tt>.\n     *\n     * @param jid the <tt>jid</tt> that we'd like to obtain a threadID for.\n     *\n     * @return the last jid that the party with the specified <tt>address</tt>\n     * contacted us from or <tt>null</tt> if we don't have a jid for the\n     * specified <tt>address</tt> yet.\n     */\n    String getThreadIDForAddress(String jid)\n    {\n        synchronized(jids)\n        {\n            purgeOldJids();\n            StoredThreadID ta = jids.get(jid);\n\n            if (ta == null)\n                return null;\n\n            ta.lastUpdatedTime = System.currentTimeMillis();\n\n            return ta.threadID;\n        }\n    }\n\n    /**\n     * Maps the specified <tt>address</tt> to <tt>jid</tt>. The point of this\n     * method is to allow us to send all messages destined to the contact with\n     * the specified <tt>address</tt> to the <tt>jid</tt> that they last\n     * contacted us from.\n     *\n     * @param threadID the threadID of conversation.\n     * @param jid the jid (i.e. address/resource) that the contact with the\n     * specified <tt>address</tt> last contacted us from.\n     */\n    private void putJidForAddress(String jid, String threadID)\n    {\n        synchronized(jids)\n        {\n            purgeOldJids();\n\n            StoredThreadID ta = jids.get(jid);\n\n            if (ta == null)\n            {\n                ta = new StoredThreadID();\n                jids.put(jid, ta);\n            }\n\n            recentJIDForAddress.put(StringUtils.parseBareAddress(jid), jid);\n\n            ta.lastUpdatedTime = System.currentTimeMillis();\n            ta.threadID = threadID;\n        }\n    }\n\n    /**\n     * Helper function used to send a message to a contact, with the given\n     * extensions attached.\n     *\n     * @param to The contact to send the message to.\n     * @param toResource The resource to send the message to or null if no\n     * resource has been specified\n     * @param message The message to send.\n     * @param extensions The XMPP extensions that should be attached to the\n     * message before sending.\n     * @return The MessageDeliveryEvent that resulted after attempting to\n     * send this message, so the calling function can modify it if needed.\n     */\n    private MessageDeliveredEvent sendMessage(  Contact to,\n                                                ContactResource toResource,\n                                                Message message,\n                                                PacketExtension[] extensions)\n    {\n        if( !(to instanceof ContactJabberImpl) )\n           throw new IllegalArgumentException(\n               \"The specified contact is not a Jabber contact.\"\n               + to);\n\n        assertConnected();\n\n        org.jivesoftware.smack.packet.Message msg =\n            new org.jivesoftware.smack.packet.Message();\n\n        String toJID = null;\n\n        if (toResource != null)\n        {\n            if(toResource.equals(ContactResource.BASE_RESOURCE))\n            {\n                toJID = to.getAddress();\n            }\n            else\n                toJID =\n                    ((ContactResourceJabberImpl) toResource).getFullJid();\n        }\n\n        if (toJID == null)\n        {\n            toJID = to.getAddress();\n        }\n\n        msg.setPacketID(message.getMessageUID());\n        msg.setTo(toJID);\n\n        for (PacketExtension ext : extensions)\n        {\n            msg.addExtension(ext);\n        }\n\n        if (logger.isTraceEnabled())\n            logger.trace(\"Will send a message to:\" + toJID\n                        + \" chat.jid=\" + toJID);\n\n        MessageDeliveredEvent msgDeliveryPendingEvt\n            = new MessageDeliveredEvent(message, to, toResource);\n\n        MessageDeliveredEvent[] transformedEvents = messageDeliveryPendingTransform(msgDeliveryPendingEvt);\n\n        if (transformedEvents == null || transformedEvents.length == 0)\n            return null;\n\n        for (MessageDeliveredEvent event : transformedEvents)\n        {\n            String content = event.getSourceMessage().getContent();\n\n            if (message.getContentType().equals(HTML_MIME_TYPE))\n            {\n                msg.setBody(Html2Text.extractText(content));\n\n                // Check if the other user supports XHTML messages\n                // make sure we use our discovery manager as it caches calls\n                if (jabberProvider\n                    .isFeatureListSupported(toJID, HTML_NAMESPACE))\n                {\n                    // Add the XHTML text to the message\n                    XHTMLManager.addBody(msg, OPEN_BODY_TAG + content\n                        + CLOSE_BODY_TAG);\n                }\n            }\n            else\n            {\n                // this is plain text so keep it as it is.\n                msg.setBody(content);\n            }\n\n            // msg.addExtension(new Version());\n\n            if (event.isMessageEncrypted() && isCarbonEnabled)\n            {\n                msg.addExtension(new CarbonPacketExtension.PrivateExtension());\n            }\n\n            MessageEventManager.addNotificationsRequests(msg, true, false,\n                false, true);\n\n            String threadID = getThreadIDForAddress(toJID);\n            if (threadID == null)\n                threadID = nextThreadID();\n\n            msg.setThread(threadID);\n            msg.setType(org.jivesoftware.smack.packet.Message.Type.chat);\n            msg.setFrom(jabberProvider.getConnection().getUser());\n\n            jabberProvider.getConnection().sendPacket(msg);\n\n            putJidForAddress(toJID, threadID);\n        }\n\n        return new MessageDeliveredEvent(message, to, toResource);\n    }\n\n    /**\n     * Sends the <tt>message</tt> to the destination indicated by the\n     * <tt>to</tt> contact.\n     *\n     * @param to the <tt>Contact</tt> to send <tt>message</tt> to\n     * @param message the <tt>Message</tt> to send.\n     * @throws java.lang.IllegalStateException if the underlying stack is\n     * not registered and initialized.\n     * @throws java.lang.IllegalArgumentException if <tt>to</tt> is not an\n     * instance of ContactImpl.\n     */\n    public void sendInstantMessage(Contact to, Message message)\n        throws IllegalStateException, IllegalArgumentException\n    {\n        sendInstantMessage(to, null, message);\n    }\n\n    /**\n     * Sends the <tt>message</tt> to the destination indicated by the\n     * <tt>to</tt>. Provides a default implementation of this method.\n     *\n     * @param to the <tt>Contact</tt> to send <tt>message</tt> to\n     * @param toResource the resource to which the message should be send\n     * @param message the <tt>Message</tt> to send.\n     * @throws java.lang.IllegalStateException if the underlying ICQ stack is\n     * not registered and initialized.\n     * @throws java.lang.IllegalArgumentException if <tt>to</tt> is not an\n     * instance belonging to the underlying implementation.\n     */\n    @Override\n    public void sendInstantMessage( Contact to,\n                                    ContactResource toResource,\n                                    Message message)\n        throws  IllegalStateException,\n                IllegalArgumentException\n    {\n        MessageDeliveredEvent msgDelivered =\n            sendMessage(to, toResource, message, new PacketExtension[0]);\n\n        fireMessageEvent(msgDelivered);\n    }\n\n    /**\n     * Replaces the message with ID <tt>correctedMessageUID</tt> sent to\n     * the contact <tt>to</tt> with the message <tt>message</tt>\n     *\n     * @param to The contact to send the message to.\n     * @param message The new message.\n     * @param correctedMessageUID The ID of the message being replaced.\n     */\n    public void correctMessage(\n        Contact to, ContactResource resource,\n        Message message, String correctedMessageUID)\n    {\n        PacketExtension[] exts = new PacketExtension[1];\n        exts[0] = new MessageCorrectionExtension(correctedMessageUID);\n        MessageDeliveredEvent msgDelivered\n            = sendMessage(to, resource, message, exts);\n        msgDelivered.setCorrectedMessageUID(correctedMessageUID);\n        fireMessageEvent(msgDelivered);\n    }\n\n    /**\n     * Utility method throwing an exception if the stack is not properly\n     * initialized.\n     *\n     * @throws java.lang.IllegalStateException if the underlying stack is\n     * not registered and initialized.\n     */\n    private void assertConnected()\n        throws IllegalStateException\n    {\n        if (opSetPersPresence == null)\n        {\n            throw\n                new IllegalStateException(\n                        \"The provider must be signed on the service before\"\n                            + \" being able to communicate.\");\n        }\n        else\n            opSetPersPresence.assertConnected();\n    }\n\n    /**\n     * Our listener that will tell us when we're registered to\n     */\n    private class RegistrationStateListener\n        implements RegistrationStateChangeListener\n    {\n        /**\n         * The method is called by a ProtocolProvider implementation whenever\n         * a change in the registration state of the corresponding provider had\n         * occurred.\n         * @param evt ProviderStatusChangeEvent the event describing the status\n         * change.\n         */\n        public void registrationStateChanged(RegistrationStateChangeEvent evt)\n        {\n            if (logger.isDebugEnabled())\n                logger.debug(\"The provider changed state from: \"\n                         + evt.getOldState()\n                         + \" to: \" + evt.getNewState());\n\n            if (evt.getNewState() == RegistrationState.REGISTERING)\n            {\n                opSetPersPresence\n                    = (OperationSetPersistentPresenceJabberImpl)\n                        jabberProvider.getOperationSet(\n                                OperationSetPersistentPresence.class);\n\n                if(smackMessageListener == null)\n                {\n                    smackMessageListener = new SmackMessageListener();\n                }\n                else\n                {\n                    // make sure this listener is not already installed in this\n                    // connection\n                    jabberProvider.getConnection()\n                        .removePacketListener(smackMessageListener);\n                }\n\n                jabberProvider.getConnection().addPacketListener(\n                        smackMessageListener,\n                        new AndFilter(\n                            packetFilters.toArray(\n                                new PacketFilter[packetFilters.size()])));\n            }\n            else if (evt.getNewState() == RegistrationState.REGISTERED)\n            {\n                new Thread(new Runnable()\n                {\n                    @Override\n                    public void run()\n                    {\n                        initAdditionalServices();\n                    }\n                }).start();\n            }\n            else if(evt.getNewState() == RegistrationState.UNREGISTERED\n                || evt.getNewState() == RegistrationState.CONNECTION_FAILED\n                || evt.getNewState() == RegistrationState.AUTHENTICATION_FAILED)\n            {\n                if(jabberProvider.getConnection() != null)\n                {\n                    if(smackMessageListener != null)\n                        jabberProvider.getConnection().removePacketListener(\n                            smackMessageListener);\n                }\n\n                smackMessageListener = null;\n            }\n        }\n    }\n\n    /**\n     * Initialize additional services, like gmail notifications and message\n     * carbons.\n     */\n    private void initAdditionalServices()\n    {\n        //subscribe for Google (Gmail or Google Apps) notifications\n        //for new mail messages.\n        boolean enableGmailNotifications\n            = jabberProvider\n            .getAccountID()\n            .getAccountPropertyBoolean(\n                \"GMAIL_NOTIFICATIONS_ENABLED\",\n                false);\n\n        if (enableGmailNotifications)\n            subscribeForGmailNotifications();\n\n        boolean enableCarbon\n            = isCarbonSupported() && !jabberProvider.getAccountID()\n            .getAccountPropertyBoolean(\n                ProtocolProviderFactory.IS_CARBON_DISABLED,\n                false);\n        if(enableCarbon)\n        {\n            enableDisableCarbon(true);\n        }\n        else\n        {\n            isCarbonEnabled = false;\n        }\n    }\n\n    /**\n     * Sends enable or disable carbon packet to the server.\n     * @param enable if <tt>true</tt> sends enable packet otherwise sends\n     * disable packet.\n     */\n    private void enableDisableCarbon(final boolean enable)\n    {\n        IQ iq = new IQ(){\n\n            @Override\n            public String getChildElementXML()\n            {\n                return \"<\" + (enable? \"enable\" : \"disable\") + \" xmlns='urn:xmpp:carbons:2' />\";\n            }\n\n        };\n\n        Packet response = null;\n        try\n        {\n            PacketCollector packetCollector\n                = jabberProvider.getConnection().createPacketCollector(\n                        new PacketIDFilter(iq.getPacketID()));\n            iq.setFrom(jabberProvider.getOurJID());\n            iq.setType(IQ.Type.SET);\n            jabberProvider.getConnection().sendPacket(iq);\n            response\n                = packetCollector.nextResult(\n                        SmackConfiguration.getPacketReplyTimeout());\n\n            packetCollector.cancel();\n        }\n        catch(Exception e)\n        {\n            logger.error(\"Failed to enable carbon.\", e);\n        }\n\n        isCarbonEnabled = false;\n\n        if (response == null)\n        {\n            logger.error(\n                    \"Failed to enable carbon. No response is received.\");\n        }\n        else if (response.getError() != null)\n        {\n            logger.error(\n                    \"Failed to enable carbon: \"\n                        + response.getError());\n        }\n        else if (!(response instanceof IQ)\n            || !((IQ) response).getType().equals(IQ.Type.RESULT))\n        {\n            logger.error(\n                    \"Failed to enable carbon. The response is not correct.\");\n        }\n        else\n        {\n            isCarbonEnabled = true;\n        }\n    }\n\n    /**\n     * Checks whether the carbon is supported by the server or not.\n     * @return <tt>true</tt> if carbon is supported by the server and\n     * <tt>false</tt> if not.\n     */\n    private boolean isCarbonSupported()\n    {\n        try\n        {\n            return jabberProvider.getDiscoveryManager().discoverInfo(\n                jabberProvider.getAccountID().getService())\n                .containsFeature(CarbonPacketExtension.NAMESPACE);\n        }\n        catch (XMPPException e)\n        {\n           logger.warn(\"Failed to retrieve carbon support.\" + e.getMessage());\n        }\n        return false;\n    }\n\n    /**\n     * The listener that we use in order to handle incoming messages.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private class SmackMessageListener\n        implements PacketListener\n    {\n        /**\n         * Handles incoming messages and dispatches whatever events are\n         * necessary.\n         * @param packet the packet that we need to handle (if it is a message).\n         */\n        public void processPacket(Packet packet)\n        {\n            if(!(packet instanceof org.jivesoftware.smack.packet.Message))\n                return;\n\n            org.jivesoftware.smack.packet.Message msg =\n                (org.jivesoftware.smack.packet.Message)packet;\n\n            boolean isForwardedSentMessage = false;\n            if(msg.getBody() == null)\n            {\n\n                CarbonPacketExtension carbonExt\n                    = (CarbonPacketExtension) msg.getExtension(\n                        CarbonPacketExtension.NAMESPACE);\n                if(carbonExt == null)\n                    return;\n\n                isForwardedSentMessage\n                    = (carbonExt.getElementName()\n                        == CarbonPacketExtension.SENT_ELEMENT_NAME);\n                List<ForwardedPacketExtension> extensions\n                    = carbonExt.getChildExtensionsOfType(\n                        ForwardedPacketExtension.class);\n                if(extensions.isEmpty())\n                    return;\n\n                // according to xep-0280 all carbons should come from\n                // our bare jid\n                if (!msg.getFrom().equals(\n                        StringUtils.parseBareAddress(\n                            jabberProvider.getOurJID())))\n                {\n                    logger.info(\"Received a carbon copy with wrong from!\");\n                    return;\n                }\n\n                ForwardedPacketExtension forwardedExt = extensions.get(0);\n                msg = forwardedExt.getMessage();\n                if(msg == null || msg.getBody() == null)\n                    return;\n\n            }\n\n            Object multiChatExtension =\n                msg.getExtension(\"x\", \"http://jabber.org/protocol/muc#user\");\n\n            // its not for us\n            if(multiChatExtension != null)\n                return;\n\n            String userFullId\n                = isForwardedSentMessage? msg.getTo() : msg.getFrom();\n\n            String userBareID = StringUtils.parseBareAddress(userFullId);\n\n            boolean isPrivateMessaging = false;\n            ChatRoom privateContactRoom = null;\n            OperationSetMultiUserChatJabberImpl mucOpSet =\n                (OperationSetMultiUserChatJabberImpl)jabberProvider\n                    .getOperationSet(OperationSetMultiUserChat.class);\n            if(mucOpSet != null)\n                privateContactRoom = mucOpSet.getChatRoom(userBareID);\n\n            if(privateContactRoom != null)\n            {\n                isPrivateMessaging = true;\n            }\n\n            if(logger.isDebugEnabled())\n            {\n                if (logger.isDebugEnabled())\n                    logger.debug(\"Received from \"\n                             + userBareID\n                             + \" the message \"\n                             + msg.toXML());\n            }\n\n            Message newMessage = createMessage(msg.getBody(),\n                    DEFAULT_MIME_TYPE, msg.getPacketID());\n\n            //check if the message is available in xhtml\n            PacketExtension ext = msg.getExtension(\n                            \"http://jabber.org/protocol/xhtml-im\");\n\n            if(ext != null)\n            {\n                XHTMLExtension xhtmlExt\n                    = (XHTMLExtension)ext;\n\n                //parse all bodies\n                Iterator<String> bodies = xhtmlExt.getBodies();\n                StringBuffer messageBuff = new StringBuffer();\n                while (bodies.hasNext())\n                {\n                    String body = bodies.next();\n                    messageBuff.append(body);\n                }\n\n                if (messageBuff.length() > 0)\n                {\n                    // we remove body tags around message cause their\n                    // end body tag is breaking\n                    // the visualization as html in the UI\n                    String receivedMessage =\n                        messageBuff.toString()\n                        // removes body start tag\n                        .replaceAll(\"\\\\<[bB][oO][dD][yY].*?>\",\"\")\n                        // removes body end tag\n                        .replaceAll(\"\\\\</[bB][oO][dD][yY].*?>\",\"\");\n\n                    // for some reason &apos; is not rendered correctly\n                    // from our ui, lets use its equivalent. Other\n                    // similar chars(< > & \") seem ok.\n                    receivedMessage =\n                            receivedMessage.replaceAll(\"&apos;\", \"&#39;\");\n\n                    newMessage = createMessage(receivedMessage,\n                            HTML_MIME_TYPE, msg.getPacketID());\n                }\n            }\n\n            PacketExtension correctionExtension =\n                    msg.getExtension(MessageCorrectionExtension.NAMESPACE);\n            String correctedMessageUID = null;\n            if (correctionExtension != null)\n            {\n                correctedMessageUID = ((MessageCorrectionExtension)\n                        correctionExtension).getCorrectedMessageUID();\n            }\n\n            Contact sourceContact\n                = opSetPersPresence.findContactByID(\n                    (isPrivateMessaging? userFullId : userBareID));\n            if(msg.getType()\n                            == org.jivesoftware.smack.packet.Message.Type.error)\n            {\n                // error which is multichat and we don't know about the contact\n                // is a muc message error which is missing muc extension\n                // and is coming from the room, when we try to send message to\n                // room which was deleted or offline on the server\n                if(isPrivateMessaging && sourceContact == null)\n                {\n                    if(privateContactRoom != null)\n                    {\n                        XMPPError error = packet.getError();\n                        int errorResultCode\n                            = ChatRoomMessageDeliveryFailedEvent.UNKNOWN_ERROR;\n\n                        if(error != null && error.getCode() == 403)\n                        {\n                            errorResultCode\n                                = ChatRoomMessageDeliveryFailedEvent.FORBIDDEN;\n                        }\n\n                        String errorReason = error.getMessage();\n\n                        ChatRoomMessageDeliveryFailedEvent evt =\n                            new ChatRoomMessageDeliveryFailedEvent(\n                                privateContactRoom,\n                                null,\n                                errorResultCode,\n                                errorReason,\n                                new Date(),\n                                newMessage);\n                        ((ChatRoomJabberImpl)privateContactRoom)\n                            .fireMessageEvent(evt);\n                    }\n\n                    return;\n                }\n\n                if (logger.isInfoEnabled())\n                    logger.info(\"Message error received from \" + userBareID);\n\n                int errorResultCode = MessageDeliveryFailedEvent.UNKNOWN_ERROR;\n                if (packet.getError() != null)\n                {\n                    int errorCode = packet.getError().getCode();\n    \n                    if(errorCode == 503)\n                    {\n                        org.jivesoftware.smackx.packet.MessageEvent msgEvent =\n                            (org.jivesoftware.smackx.packet.MessageEvent)\n                                packet.getExtension(\"x\", \"jabber:x:event\");\n                        if(msgEvent != null && msgEvent.isOffline())\n                        {\n                            errorResultCode =\n                                MessageDeliveryFailedEvent\n                                    .OFFLINE_MESSAGES_NOT_SUPPORTED;\n                        }\n                    }\n                }\n\n                if (sourceContact == null)\n                {\n                    sourceContact = opSetPersPresence.createVolatileContact(\n                        userFullId, isPrivateMessaging);\n                }\n\n                MessageDeliveryFailedEvent ev\n                    = new MessageDeliveryFailedEvent(newMessage,\n                                                     sourceContact,\n                                                     correctedMessageUID,\n                                                     errorResultCode);\n\n                // ev = messageDeliveryFailedTransform(ev);\n\n                if (ev != null)\n                    fireMessageEvent(ev);\n                return;\n            }\n            putJidForAddress(userFullId, msg.getThread());\n\n            // In the second condition we filter all group chat messages,\n            // because they are managed by the multi user chat operation set.\n            if(sourceContact == null)\n            {\n                if (logger.isDebugEnabled())\n                    logger.debug(\"received a message from an unknown contact: \"\n                                   + userBareID);\n                //create the volatile contact\n                sourceContact = opSetPersPresence\n                    .createVolatileContact(\n                        userFullId,\n                        isPrivateMessaging);\n            }\n\n            Date timestamp = new Date();\n            //Check for XEP-0091 timestamp (deprecated)\n            PacketExtension delay = msg.getExtension(\"x\", \"jabber:x:delay\");\n            if(delay != null && delay instanceof DelayInformation)\n            {\n                timestamp = ((DelayInformation)delay).getStamp();\n            }\n            //check for XEP-0203 timestamp\n            delay = msg.getExtension(\"delay\", \"urn:xmpp:delay\");\n            if(delay != null && delay instanceof DelayInfo)\n            {\n                timestamp = ((DelayInfo)delay).getStamp();\n            }\n\n            ContactResource resource = ((ContactJabberImpl) sourceContact)\n                    .getResourceFromJid(userFullId);\n\n            EventObject msgEvt = null;\n            if(!isForwardedSentMessage)\n                msgEvt\n                    = new MessageReceivedEvent( newMessage,\n                                                sourceContact,\n                                                resource,\n                                                timestamp,\n                                                correctedMessageUID,\n                                                isPrivateMessaging,\n                                                privateContactRoom);\n            else\n                msgEvt = new MessageDeliveredEvent(newMessage, sourceContact, timestamp);\n            // msgReceivedEvt = messageReceivedTransform(msgReceivedEvt);\n            if (msgEvt != null)\n                fireMessageEvent(msgEvt);\n        }\n    }\n\n\n    /**\n     * A filter that prevents this operation set from handling multi user chat\n     * messages.\n     */\n    private static class GroupMessagePacketFilter implements PacketFilter\n    {\n        /**\n         * Returns <tt>true</tt> if <tt>packet</tt> is a <tt>Message</tt> and\n         * false otherwise.\n         *\n         * @param packet the packet that we need to check.\n         *\n         * @return  <tt>true</tt> if <tt>packet</tt> is a <tt>Message</tt> and\n         * false otherwise.\n         */\n        public boolean accept(Packet packet)\n        {\n            if(!(packet instanceof org.jivesoftware.smack.packet.Message))\n                return false;\n\n            org.jivesoftware.smack.packet.Message msg\n                = (org.jivesoftware.smack.packet.Message) packet;\n\n            return\n                !msg.getType().equals(\n                        org.jivesoftware.smack.packet.Message.Type.groupchat);\n        }\n    }\n\n    /**\n     * Subscribes this provider as interested in receiving notifications for\n     * new mail messages from Google mail services such as Gmail or Google Apps.\n     */\n    private void subscribeForGmailNotifications()\n    {\n        // first check support for the notification service\n        String accountIDService = jabberProvider.getAccountID().getService();\n        boolean notificationsAreSupported\n            = jabberProvider.isFeatureSupported(\n                    accountIDService,\n                    NewMailNotificationIQ.NAMESPACE);\n\n        if (!notificationsAreSupported)\n        {\n            if (logger.isDebugEnabled())\n                logger.debug(accountIDService\n                        +\" does not seem to provide a Gmail notification \"\n                        +\" service so we won't be trying to subscribe for it\");\n            return;\n        }\n\n        if (logger.isDebugEnabled())\n            logger.debug(accountIDService\n                        +\" seems to provide a Gmail notification \"\n                        +\" service so we will try to subscribe for it\");\n\n        ProviderManager providerManager = ProviderManager.getInstance();\n\n        providerManager.addIQProvider(\n                MailboxIQ.ELEMENT_NAME,\n                MailboxIQ.NAMESPACE,\n                new MailboxIQProvider());\n        providerManager.addIQProvider(\n                NewMailNotificationIQ.ELEMENT_NAME,\n                NewMailNotificationIQ.NAMESPACE,\n                new NewMailNotificationProvider());\n\n        Connection connection = jabberProvider.getConnection();\n\n        connection.addPacketListener(\n                new MailboxIQListener(), new PacketTypeFilter(MailboxIQ.class));\n        connection.addPacketListener(\n                new NewMailNotificationListener(),\n                new PacketTypeFilter(NewMailNotificationIQ.class));\n\n        if(opSetPersPresence.getCurrentStatusMessage().equals(\n                JabberStatusEnum.OFFLINE))\n           return;\n\n        //create a query with -1 values for newer-than-tid and\n        //newer-than-time attributes\n        MailboxQueryIQ mailboxQuery = new MailboxQueryIQ();\n\n        if (logger.isTraceEnabled())\n            logger.trace(\"sending mailNotification for acc: \"\n                    + jabberProvider.getAccountID().getAccountUniqueID());\n        jabberProvider.getConnection().sendPacket(mailboxQuery);\n    }\n\n    /**\n     * Creates an html description of the specified mailbox.\n     *\n     * @param mailboxIQ the mailboxIQ that we are to describe.\n     *\n     * @return an html description of <tt>mailboxIQ</tt>\n     */\n    private String createMailboxDescription(MailboxIQ mailboxIQ)\n    {\n        int threadCount = mailboxIQ.getThreadCount();\n\n        String resourceHeaderKey = threadCount > 1\n            ? \"service.gui.NEW_GMAIL_MANY_HEADER\"\n            : \"service.gui.NEW_GMAIL_HEADER\";\n\n        String resourceFooterKey = threadCount > 1\n            ? \"service.gui.NEW_GMAIL_MANY_FOOTER\"\n            : \"service.gui.NEW_GMAIL_FOOTER\";\n\n        // FIXME Escape HTML!\n        String newMailHeader = JabberActivator.getResources().getI18NString(\n            resourceHeaderKey,\n            new String[]\n                {\n                    jabberProvider.getAccountID()\n                                .getService(),     //{0} - service name\n                    mailboxIQ.getUrl(),            //{1} - inbox URI\n                    Integer.toString( threadCount )//{2} - thread count\n                });\n\n        StringBuilder message = new StringBuilder(newMailHeader);\n\n        //we now start an html table for the threads.\n        message.append(\"<table width=100% cellpadding=2 cellspacing=0 \");\n        message.append(\"border=0 bgcolor=#e8eef7>\");\n\n        Iterator<MailThreadInfo> threads = mailboxIQ.threads();\n\n        String maxThreadsStr = (String)JabberActivator.getConfigurationService()\n            .getProperty(PNAME_MAX_GMAIL_THREADS_PER_NOTIFICATION);\n\n        int maxThreads = 5;\n\n        try\n        {\n            if(maxThreadsStr != null)\n                maxThreads = Integer.parseInt(maxThreadsStr);\n        }\n        catch (NumberFormatException e)\n        {\n            if (logger.isDebugEnabled())\n                logger.debug(\"Failed to parse max threads count: \"+maxThreads\n                            +\". Going for default.\");\n        }\n\n        //print a maximum of MAX_THREADS\n        for (int i = 0; i < maxThreads && threads.hasNext(); i++)\n        {\n            message.append(threads.next().createHtmlDescription());\n        }\n        message.append(\"</table><br/>\");\n\n        if(threadCount > maxThreads)\n        {\n            String messageFooter = JabberActivator.getResources().getI18NString(\n                resourceFooterKey,\n                new String[]\n                {\n                    mailboxIQ.getUrl(),            //{0} - inbox URI\n                    Integer.toString(\n                        threadCount - maxThreads )//{1} - thread count\n                });\n            message.append(messageFooter);\n        }\n\n        return message.toString();\n    }\n\n    public String getRecentJIDForAddress(String address)\n    {\n        return recentJIDForAddress.get(address);\n    }\n\n    /**\n     * Receives incoming MailNotification Packets\n     */\n    private class MailboxIQListener\n        implements PacketListener\n    {\n        /**\n         * Handles incoming <tt>MailboxIQ</tt> packets.\n         *\n         * @param packet the IQ that we need to handle in case it is a\n         * <tt>MailboxIQ</tt>.\n         */\n        public void processPacket(Packet packet)\n        {\n            if(packet != null && !(packet instanceof MailboxIQ))\n                return;\n\n            MailboxIQ mailboxIQ = (MailboxIQ) packet;\n\n            if(mailboxIQ.getTotalMatched() < 1)\n                return;\n\n            //Get a reference to a dummy volatile contact\n            Contact sourceContact = opSetPersPresence\n                .findContactByID(jabberProvider.getAccountID().getService());\n\n            if(sourceContact == null)\n                sourceContact = opSetPersPresence.createVolatileContact(\n                                jabberProvider.getAccountID().getService());\n\n            lastReceivedMailboxResultTime = mailboxIQ.getResultTime();\n\n            String newMail = createMailboxDescription(mailboxIQ);\n\n            Message newMailMessage = new MessageJabberImpl(\n                newMail, HTML_MIME_TYPE, DEFAULT_MIME_ENCODING, null);\n\n            MessageReceivedEvent msgReceivedEvt = new MessageReceivedEvent(\n                newMailMessage, sourceContact, new Date(),\n                MessageReceivedEvent.SYSTEM_MESSAGE_RECEIVED);\n\n            fireMessageEvent(msgReceivedEvt);\n        }\n    }\n\n    /**\n     * Receives incoming NewMailNotification Packets.\n     */\n    private class NewMailNotificationListener\n        implements PacketListener\n    {\n        /**\n         * Handles incoming <tt>NewMailNotificationIQ</tt> packets.\n         *\n         * @param packet the IQ that we need to handle in case it is a\n         * <tt>NewMailNotificationIQ</tt>.\n         */\n        public void processPacket(Packet packet)\n        {\n            if(packet != null &&  !(packet instanceof NewMailNotificationIQ))\n                return;\n\n            //check whether we are still enabled.\n            boolean enableGmailNotifications\n                = jabberProvider\n                    .getAccountID()\n                        .getAccountPropertyBoolean(\n                            \"GMAIL_NOTIFICATIONS_ENABLED\",\n                            false);\n\n            if (!enableGmailNotifications)\n                return;\n\n            if(opSetPersPresence.getCurrentStatusMessage()\n                    .equals(JabberStatusEnum.OFFLINE))\n                return;\n\n            MailboxQueryIQ mailboxQueryIQ = new MailboxQueryIQ();\n\n            if(lastReceivedMailboxResultTime != -1)\n                mailboxQueryIQ.setNewerThanTime(\n                                lastReceivedMailboxResultTime);\n\n            if (logger.isTraceEnabled())\n                logger.trace(\n                \"send mailNotification for acc: \"\n                + jabberProvider.getAccountID().getAccountUniqueID());\n\n            jabberProvider.getConnection().sendPacket(mailboxQueryIQ);\n        }\n    }\n\n    /**\n     * Returns the inactivity timeout in milliseconds.\n     *\n     * @return The inactivity timeout in milliseconds. Or -1 if undefined\n     */\n    public long getInactivityTimeout()\n    {\n        return JID_INACTIVITY_TIMEOUT;\n    }\n\n    /**\n     * Adds additional filters for incoming messages. To be able to skip some\n     * messages.\n     * @param filter to add\n     */\n    public void addMessageFilters(PacketFilter filter)\n    {\n        this.packetFilters.add(filter);\n    }\n\n    /**\n     * Returns the next unique thread id. Each thread id made up of a short\n     * alphanumeric prefix along with a unique numeric value.\n     *\n     * @return the next thread id.\n     */\n    public static synchronized String nextThreadID() {\n        return prefix + Long.toString(id++);\n    }\n\n\n}\n"], "filenames": ["src/net/java/sip/communicator/impl/protocol/jabber/OperationSetBasicInstantMessagingJabberImpl.java"], "buggy_code_start_loc": [817], "buggy_code_end_loc": [817], "fixing_code_start_loc": [818], "fixing_code_end_loc": [829], "type": "CWE-20", "message": "An incorrect implementation of \"XEP-0280: Message Carbons\" in multiple XMPP clients allows a remote attacker to impersonate any user, including contacts, in the vulnerable application's display. This allows for various kinds of social engineering attacks. This CVE is for Jitsi 2.5.5061 - 2.9.5544.", "other": {"cve": {"id": "CVE-2017-5603", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-09T20:59:00.420", "lastModified": "2017-03-01T02:59:05.793", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An incorrect implementation of \"XEP-0280: Message Carbons\" in multiple XMPP clients allows a remote attacker to impersonate any user, including contacts, in the vulnerable application's display. This allows for various kinds of social engineering attacks. This CVE is for Jitsi 2.5.5061 - 2.9.5544."}, {"lang": "es", "value": "Una implementaci\u00f3n incorrecta de \"XEP-0280: Message Carbons\" en m\u00faltiples clientes XMPP permite a un atacante remoto personificar cualquier usuario, incluidos los contactos, en la pantalla de la aplicaci\u00f3n vulnerable. Esto permite varios tipos de ataques de ingenier\u00eda social. Esta CVE es para Jitsi 2.5.5061 - 2.9.5544."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-346"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jitsi:jitsi:2.5.5061:*:*:*:*:*:*:*", "matchCriteriaId": "B82E6947-285D-4B91-9375-5EB7517AA48D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jitsi:jitsi:2.9.5544:*:*:*:*:*:*:*", "matchCriteriaId": "2ACB92B0-9A84-447D-80A0-4FD7108CB0EC"}]}]}], "references": [{"url": "http://openwall.com/lists/oss-security/2017/02/09/29", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96174", "source": "cve@mitre.org"}, {"url": "https://github.com/jitsi/jitsi/commit/7d66da61b316c9480b63000f831b6de723b87315", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://rt-solutions.de/en/2017/02/CVE-2017-5589_xmpp_carbons/", "source": "cve@mitre.org", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}, {"url": "https://rt-solutions.de/wp-content/uploads/2017/02/CVE-2017-5589_xmpp_carbons.pdf", "source": "cve@mitre.org", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jitsi/jitsi/commit/7d66da61b316c9480b63000f831b6de723b87315"}}