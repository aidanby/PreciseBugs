{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ex_getln.c: Functions for entering and editing an Ex command line.\n */\n\n#include \"vim.h\"\n\n#ifndef MAX\n# define MAX(x,y) ((x) > (y) ? (x) : (y))\n#endif\n\n// Return value when handling keys in command-line mode.\n#define CMDLINE_NOT_CHANGED\t1\n#define CMDLINE_CHANGED\t\t2\n#define GOTO_NORMAL_MODE\t3\n#define PROCESS_NEXT_KEY\t4\n\n// The current cmdline_info.  It is initialized in getcmdline() and after that\n// used by other functions.  When invoking getcmdline() recursively it needs\n// to be saved with save_cmdline() and restored with restore_cmdline().\nstatic cmdline_info_T ccline;\n\n#ifdef FEAT_EVAL\nstatic int\tnew_cmdpos;\t// position set by set_cmdline_pos()\n#endif\n\nstatic int\textra_char = NUL;  // extra character to display when redrawing\n\t\t\t\t   // the command line\nstatic int\textra_char_shift;\n\n#ifdef FEAT_RIGHTLEFT\nstatic int\tcmd_hkmap = 0;\t// Hebrew mapping during command line\n#endif\n\nstatic char_u\t*getcmdline_int(int firstc, long count, int indent, int clear_ccline);\nstatic int\tcmdline_charsize(int idx);\nstatic void\tset_cmdspos(void);\nstatic void\tset_cmdspos_cursor(void);\nstatic void\tcorrect_cmdspos(int idx, int cells);\nstatic void\talloc_cmdbuff(int len);\nstatic void\tdraw_cmdline(int start, int len);\nstatic void\tsave_cmdline(cmdline_info_T *ccp);\nstatic void\trestore_cmdline(cmdline_info_T *ccp);\nstatic int\tcmdline_paste(int regname, int literally, int remcr);\nstatic void\tredrawcmdprompt(void);\nstatic int\tccheck_abbr(int);\n#ifdef FEAT_SEARCH_EXTRA\nstatic int\tempty_pattern_magic(char_u *pat, size_t len, magic_T magic_val);\n#endif\n\n#ifdef FEAT_CMDWIN\nstatic int\topen_cmdwin(void);\n\nstatic int\tcedit_key = -1;\t// key value of 'cedit' option\n#endif\n\n\n    static void\ntrigger_cmd_autocmd(int typechar, int evt)\n{\n    char_u\ttypestr[2];\n\n    typestr[0] = typechar;\n    typestr[1] = NUL;\n    apply_autocmds(evt, typestr, typestr, FALSE, curbuf);\n}\n\n/*\n * Abandon the command line.\n */\n    static void\nabandon_cmdline(void)\n{\n    VIM_CLEAR(ccline.cmdbuff);\n    if (msg_scrolled == 0)\n\tcompute_cmdrow();\n    msg(\"\");\n    redraw_cmdline = TRUE;\n}\n\n#ifdef FEAT_SEARCH_EXTRA\n/*\n * Guess that the pattern matches everything.  Only finds specific cases, such\n * as a trailing \\|, which can happen while typing a pattern.\n */\n    static int\nempty_pattern(char_u *p, int delim)\n{\n    size_t\tn = STRLEN(p);\n    magic_T\tmagic_val = MAGIC_ON;\n\n    if (n > 0)\n\t(void) skip_regexp_ex(p, delim, magic_isset(), NULL, NULL, &magic_val);\n    else\n\treturn TRUE;\n\n    return empty_pattern_magic(p, n, magic_val);\n}\n\n    static int\nempty_pattern_magic(char_u *p, size_t len, magic_T magic_val)\n{\n    // remove trailing \\v and the like\n    while (len >= 2 && p[len - 2] == '\\\\'\n\t\t\t&& vim_strchr((char_u *)\"mMvVcCZ\", p[len - 1]) != NULL)\n       len -= 2;\n\n    // true, if the pattern is empty, or the pattern ends with \\| and magic is\n    // set (or it ends with '|' and very magic is set)\n    return len == 0 || (len > 1\n\t    && ((p[len - 2] == '\\\\'\n\t\t\t\t && p[len - 1] == '|' && magic_val == MAGIC_ON)\n\t\t|| (p[len - 2] != '\\\\'\n\t\t\t     && p[len - 1] == '|' && magic_val == MAGIC_ALL)));\n}\n\n// Struct to store the viewstate during 'incsearch' highlighting.\ntypedef struct {\n    colnr_T\tvs_curswant;\n    colnr_T\tvs_leftcol;\n    linenr_T\tvs_topline;\n# ifdef FEAT_DIFF\n    int\t\tvs_topfill;\n# endif\n    linenr_T\tvs_botline;\n    linenr_T\tvs_empty_rows;\n} viewstate_T;\n\n    static void\nsave_viewstate(viewstate_T *vs)\n{\n    vs->vs_curswant = curwin->w_curswant;\n    vs->vs_leftcol = curwin->w_leftcol;\n    vs->vs_topline = curwin->w_topline;\n# ifdef FEAT_DIFF\n    vs->vs_topfill = curwin->w_topfill;\n# endif\n    vs->vs_botline = curwin->w_botline;\n    vs->vs_empty_rows = curwin->w_empty_rows;\n}\n\n    static void\nrestore_viewstate(viewstate_T *vs)\n{\n    curwin->w_curswant = vs->vs_curswant;\n    curwin->w_leftcol = vs->vs_leftcol;\n    curwin->w_topline = vs->vs_topline;\n# ifdef FEAT_DIFF\n    curwin->w_topfill = vs->vs_topfill;\n# endif\n    curwin->w_botline = vs->vs_botline;\n    curwin->w_empty_rows = vs->vs_empty_rows;\n}\n\n// Struct to store the state of 'incsearch' highlighting.\ntypedef struct {\n    pos_T\tsearch_start;\t// where 'incsearch' starts searching\n    pos_T\tsave_cursor;\n    int\t\twinid;\t\t// window where this state is valid\n    viewstate_T\tinit_viewstate;\n    viewstate_T\told_viewstate;\n    pos_T\tmatch_start;\n    pos_T\tmatch_end;\n    int\t\tdid_incsearch;\n    int\t\tincsearch_postponed;\n    optmagic_T\tmagic_overruled_save;\n} incsearch_state_T;\n\n    static void\ninit_incsearch_state(incsearch_state_T *is_state)\n{\n    is_state->winid = curwin->w_id;\n    is_state->match_start = curwin->w_cursor;\n    is_state->did_incsearch = FALSE;\n    is_state->incsearch_postponed = FALSE;\n    is_state->magic_overruled_save = magic_overruled;\n    CLEAR_POS(&is_state->match_end);\n    is_state->save_cursor = curwin->w_cursor;  // may be restored later\n    is_state->search_start = curwin->w_cursor;\n    save_viewstate(&is_state->init_viewstate);\n    save_viewstate(&is_state->old_viewstate);\n}\n\n/*\n * First move cursor to end of match, then to the start.  This\n * moves the whole match onto the screen when 'nowrap' is set.\n */\n    static void\nset_search_match(pos_T *t)\n{\n    t->lnum += search_match_lines;\n    t->col = search_match_endcol;\n    if (t->lnum > curbuf->b_ml.ml_line_count)\n    {\n\tt->lnum = curbuf->b_ml.ml_line_count;\n\tcoladvance((colnr_T)MAXCOL);\n    }\n}\n\n/*\n * Return TRUE when 'incsearch' highlighting is to be done.\n * Sets search_first_line and search_last_line to the address range.\n * May change the last search pattern.\n */\n    static int\ndo_incsearch_highlighting(\n\tint\t\t    firstc,\n\tint\t\t    *search_delim,\n\tincsearch_state_T   *is_state,\n\tint\t\t    *skiplen,\n\tint\t\t    *patlen)\n{\n    char_u\t*cmd;\n    cmdmod_T\tdummy_cmdmod;\n    char_u\t*p;\n    int\t\tdelim_optional = FALSE;\n    int\t\tdelim;\n    char_u\t*end;\n    char\t*dummy;\n    exarg_T\tea;\n    pos_T\tsave_cursor;\n    int\t\tuse_last_pat;\n    int\t\tretval = FALSE;\n    magic_T     magic = 0;\n\n    *skiplen = 0;\n    *patlen = ccline.cmdlen;\n\n    if (!p_is || cmd_silent)\n\treturn FALSE;\n\n    // by default search all lines\n    search_first_line = 0;\n    search_last_line = MAXLNUM;\n\n    if (firstc == '/' || firstc == '?')\n    {\n\t*search_delim = firstc;\n\treturn TRUE;\n    }\n    if (firstc != ':')\n\treturn FALSE;\n\n    ++emsg_off;\n    CLEAR_FIELD(ea);\n    ea.line1 = 1;\n    ea.line2 = 1;\n    ea.cmd = ccline.cmdbuff;\n    ea.addr_type = ADDR_LINES;\n\n    parse_command_modifiers(&ea, &dummy, &dummy_cmdmod, TRUE);\n\n    cmd = skip_range(ea.cmd, TRUE, NULL);\n    if (vim_strchr((char_u *)\"sgvl\", *cmd) == NULL)\n\tgoto theend;\n\n    // Skip over \"substitute\" to find the pattern separator.\n    for (p = cmd; ASCII_ISALPHA(*p); ++p)\n\t;\n    if (*skipwhite(p) == NUL)\n\tgoto theend;\n\n    if (STRNCMP(cmd, \"substitute\", p - cmd) == 0\n\t    || STRNCMP(cmd, \"smagic\", p - cmd) == 0\n\t    || STRNCMP(cmd, \"snomagic\", MAX(p - cmd, 3)) == 0\n\t    || STRNCMP(cmd, \"vglobal\", p - cmd) == 0)\n    {\n\tif (*cmd == 's' && cmd[1] == 'm')\n\t    magic_overruled = OPTION_MAGIC_ON;\n\telse if (*cmd == 's' && cmd[1] == 'n')\n\t    magic_overruled = OPTION_MAGIC_OFF;\n    }\n    else if (STRNCMP(cmd, \"sort\", MAX(p - cmd, 3)) == 0)\n    {\n\t// skip over ! and flags\n\tif (*p == '!')\n\t    p = skipwhite(p + 1);\n\twhile (ASCII_ISALPHA(*(p = skipwhite(p))))\n\t    ++p;\n\tif (*p == NUL)\n\t    goto theend;\n    }\n    else if (STRNCMP(cmd, \"vimgrep\", MAX(p - cmd, 3)) == 0\n\t|| STRNCMP(cmd, \"vimgrepadd\", MAX(p - cmd, 8)) == 0\n\t|| STRNCMP(cmd, \"lvimgrep\", MAX(p - cmd, 2)) == 0\n\t|| STRNCMP(cmd, \"lvimgrepadd\", MAX(p - cmd, 9)) == 0\n\t|| STRNCMP(cmd, \"global\", p - cmd) == 0)\n    {\n\t// skip over \"!\"\n\tif (*p == '!')\n\t{\n\t    p++;\n\t    if (*skipwhite(p) == NUL)\n\t\tgoto theend;\n\t}\n\tif (*cmd != 'g')\n\t    delim_optional = TRUE;\n    }\n    else\n\tgoto theend;\n\n    p = skipwhite(p);\n    delim = (delim_optional && vim_isIDc(*p)) ? ' ' : *p++;\n    *search_delim = delim;\n    end = skip_regexp_ex(p, delim, magic_isset(), NULL, NULL, &magic);\n\n    use_last_pat = end == p && *end == delim;\n\n    if (end == p && !use_last_pat)\n\tgoto theend;\n\n    // Don't do 'hlsearch' highlighting if the pattern matches everything.\n    if (!use_last_pat)\n    {\n\tchar c = *end;\n\tint  empty;\n\n\t*end = NUL;\n\tempty = empty_pattern_magic(p, STRLEN(p), magic);\n\t*end = c;\n\tif (empty)\n\t    goto theend;\n    }\n\n    // found a non-empty pattern or //\n    *skiplen = (int)(p - ccline.cmdbuff);\n    *patlen = (int)(end - p);\n\n    // parse the address range\n    save_cursor = curwin->w_cursor;\n    curwin->w_cursor = is_state->search_start;\n    parse_cmd_address(&ea, &dummy, TRUE);\n    if (ea.addr_count > 0)\n    {\n\t// Allow for reverse match.\n\tif (ea.line2 < ea.line1)\n\t{\n\t    search_first_line = ea.line2;\n\t    search_last_line = ea.line1;\n\t}\n\telse\n\t{\n\t    search_first_line = ea.line1;\n\t    search_last_line = ea.line2;\n\t}\n    }\n    else if (cmd[0] == 's' && cmd[1] != 'o')\n    {\n\t// :s defaults to the current line\n\tsearch_first_line = curwin->w_cursor.lnum;\n\tsearch_last_line = curwin->w_cursor.lnum;\n    }\n\n    curwin->w_cursor = save_cursor;\n    retval = TRUE;\ntheend:\n    --emsg_off;\n    return retval;\n}\n\n    static void\nfinish_incsearch_highlighting(\n\tint gotesc,\n\tincsearch_state_T *is_state,\n\tint call_update_screen)\n{\n    if (is_state->did_incsearch)\n    {\n\tis_state->did_incsearch = FALSE;\n\tif (gotesc)\n\t    curwin->w_cursor = is_state->save_cursor;\n\telse\n\t{\n\t    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))\n\t    {\n\t\t// put the '\" mark at the original position\n\t\tcurwin->w_cursor = is_state->save_cursor;\n\t\tsetpcmark();\n\t    }\n\t    curwin->w_cursor = is_state->search_start;\n\t}\n\trestore_viewstate(&is_state->old_viewstate);\n\thighlight_match = FALSE;\n\n\t// by default search all lines\n\tsearch_first_line = 0;\n\tsearch_last_line = MAXLNUM;\n\n\tmagic_overruled = is_state->magic_overruled_save;\n\n\tvalidate_cursor();\t// needed for TAB\n\tredraw_all_later(UPD_SOME_VALID);\n\tif (call_update_screen)\n\t    update_screen(UPD_SOME_VALID);\n    }\n}\n\n/*\n * Do 'incsearch' highlighting if desired.\n */\n    static void\nmay_do_incsearch_highlighting(\n\tint\t\t    firstc,\n\tlong\t\t    count,\n\tincsearch_state_T   *is_state)\n{\n    int\t\tskiplen, patlen;\n    int\t\tfound;  // do_search() result\n    pos_T\tend_pos;\n#ifdef FEAT_RELTIME\n    searchit_arg_T sia;\n#endif\n    int\t\tnext_char;\n    int\t\tuse_last_pat;\n    int\t\tdid_do_incsearch = is_state->did_incsearch;\n    int\t\tsearch_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\tfinish_incsearch_highlighting(FALSE, is_state, TRUE);\n\tif (did_do_incsearch && vpeekc() == NUL)\n\t    // may have skipped a redraw, do it now\n\t    redrawcmd();\n\treturn;\n    }\n\n    // If there is a character waiting, search and redraw later.\n    if (char_avail())\n    {\n\trestore_last_search_pattern();\n\tis_state->incsearch_postponed = TRUE;\n\treturn;\n    }\n    is_state->incsearch_postponed = FALSE;\n\n    if (search_first_line == 0)\n\t// start at the original cursor position\n\tcurwin->w_cursor = is_state->search_start;\n    else if (search_first_line > curbuf->b_ml.ml_line_count)\n    {\n\t// start after the last line\n\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\tcurwin->w_cursor.col = MAXCOL;\n    }\n    else\n    {\n\t// start at the first line in the range\n\tcurwin->w_cursor.lnum = search_first_line;\n\tcurwin->w_cursor.col = 0;\n    }\n\n    // Use the previous pattern for \":s//\".\n    next_char = ccline.cmdbuff[skiplen + patlen];\n    use_last_pat = patlen == 0 && skiplen > 0\n\t\t\t\t   && ccline.cmdbuff[skiplen - 1] == next_char;\n\n    // If there is no pattern, don't do anything.\n    if (patlen == 0 && !use_last_pat)\n    {\n\tfound = 0;\n\tset_no_hlsearch(TRUE); // turn off previous highlight\n\tredraw_all_later(UPD_SOME_VALID);\n    }\n    else\n    {\n\tint search_flags = SEARCH_OPT + SEARCH_NOOF + SEARCH_PEEK;\n\n\tcursor_off();\t// so the user knows we're busy\n\tout_flush();\n\t++emsg_off;\t// so it doesn't beep if bad expr\n\tif (!p_hls)\n\t    search_flags += SEARCH_KEEP;\n\tif (search_first_line != 0)\n\t    search_flags += SEARCH_START;\n\tccline.cmdbuff[skiplen + patlen] = NUL;\n#ifdef FEAT_RELTIME\n\tCLEAR_FIELD(sia);\n\t// Set the time limit to half a second.\n\tsia.sa_tm = 500;\n#endif\n\tfound = do_search(NULL, firstc == ':' ? '/' : firstc, search_delim,\n\t\t\t\t ccline.cmdbuff + skiplen, count, search_flags,\n#ifdef FEAT_RELTIME\n\t\t&sia\n#else\n\t\tNULL\n#endif\n\t\t);\n\tccline.cmdbuff[skiplen + patlen] = next_char;\n\t--emsg_off;\n\n\tif (curwin->w_cursor.lnum < search_first_line\n\t\t|| curwin->w_cursor.lnum > search_last_line)\n\t{\n\t    // match outside of address range\n\t    found = 0;\n\t    curwin->w_cursor = is_state->search_start;\n\t}\n\n\t// if interrupted while searching, behave like it failed\n\tif (got_int)\n\t{\n\t    (void)vpeekc();\t// remove <C-C> from input stream\n\t    got_int = FALSE;\t// don't abandon the command line\n\t    found = 0;\n\t}\n\telse if (char_avail())\n\t    // cancelled searching because a char was typed\n\t    is_state->incsearch_postponed = TRUE;\n    }\n    if (found != 0)\n\thighlight_match = TRUE;\t\t// highlight position\n    else\n\thighlight_match = FALSE;\t// remove highlight\n\n    // First restore the old curwin values, so the screen is positioned in the\n    // same way as the actual search command.\n    restore_viewstate(&is_state->old_viewstate);\n    changed_cline_bef_curs();\n    update_topline();\n\n    if (found != 0)\n    {\n\tpos_T\t    save_pos = curwin->w_cursor;\n\n\tis_state->match_start = curwin->w_cursor;\n\tset_search_match(&curwin->w_cursor);\n\tvalidate_cursor();\n\tend_pos = curwin->w_cursor;\n\tis_state->match_end = end_pos;\n\tcurwin->w_cursor = save_pos;\n    }\n    else\n\tend_pos = curwin->w_cursor; // shutup gcc 4\n\n    // Disable 'hlsearch' highlighting if the pattern matches everything.\n    // Avoids a flash when typing \"foo\\|\".\n    if (!use_last_pat)\n    {\n\tnext_char = ccline.cmdbuff[skiplen + patlen];\n\tccline.cmdbuff[skiplen + patlen] = NUL;\n\tif (empty_pattern(ccline.cmdbuff + skiplen, search_delim)\n\t\t\t\t\t\t\t       && !no_hlsearch)\n\t{\n\t    redraw_all_later(UPD_SOME_VALID);\n\t    set_no_hlsearch(TRUE);\n\t}\n\tccline.cmdbuff[skiplen + patlen] = next_char;\n    }\n\n    validate_cursor();\n    // May redraw the status line to show the cursor position.\n    if (p_ru && curwin->w_status_height > 0)\n\tcurwin->w_redr_status = TRUE;\n\n    update_screen(UPD_SOME_VALID);\n    highlight_match = FALSE;\n    restore_last_search_pattern();\n\n    // Leave it at the end to make CTRL-R CTRL-W work.  But not when beyond the\n    // end of the pattern, e.g. for \":s/pat/\".\n    if (ccline.cmdbuff[skiplen + patlen] != NUL)\n\tcurwin->w_cursor = is_state->search_start;\n    else if (found != 0)\n\tcurwin->w_cursor = end_pos;\n\n    msg_starthere();\n    redrawcmdline();\n    is_state->did_incsearch = TRUE;\n}\n\n/*\n * May adjust 'incsearch' highlighting for typing CTRL-G and CTRL-T, go to next\n * or previous match.\n * Returns FAIL when jumping to cmdline_not_changed;\n */\n    static int\nmay_adjust_incsearch_highlighting(\n\tint\t\t\tfirstc,\n\tlong\t\t\tcount,\n\tincsearch_state_T\t*is_state,\n\tint\t\t\tc)\n{\n    int\t    skiplen, patlen;\n    pos_T   t;\n    char_u  *pat;\n    int\t    search_flags = SEARCH_NOOF;\n    int\t    i;\n    int\t    save;\n    int\t    search_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\treturn OK;\n    }\n    if (patlen == 0 && ccline.cmdbuff[skiplen] == NUL)\n    {\n\trestore_last_search_pattern();\n\treturn FAIL;\n    }\n\n    if (search_delim == ccline.cmdbuff[skiplen])\n    {\n\tpat = last_search_pattern();\n\tif (pat == NULL)\n\t{\n\t    restore_last_search_pattern();\n\t    return FAIL;\n\t}\n\tskiplen = 0;\n\tpatlen = (int)STRLEN(pat);\n    }\n    else\n\tpat = ccline.cmdbuff + skiplen;\n\n    cursor_off();\n    out_flush();\n    if (c == Ctrl_G)\n    {\n\tt = is_state->match_end;\n\tif (LT_POS(is_state->match_start, is_state->match_end))\n\t    // Start searching at the end of the match not at the beginning of\n\t    // the next column.\n\t    (void)decl(&t);\n\tsearch_flags += SEARCH_COL;\n    }\n    else\n\tt = is_state->match_start;\n    if (!p_hls)\n\tsearch_flags += SEARCH_KEEP;\n    ++emsg_off;\n    save = pat[patlen];\n    pat[patlen] = NUL;\n    i = searchit(curwin, curbuf, &t, NULL,\n\t\t c == Ctrl_G ? FORWARD : BACKWARD,\n\t\t pat, count, search_flags, RE_SEARCH, NULL);\n    --emsg_off;\n    pat[patlen] = save;\n    if (i)\n    {\n\tis_state->search_start = is_state->match_start;\n\tis_state->match_end = t;\n\tis_state->match_start = t;\n\tif (c == Ctrl_T && firstc != '?')\n\t{\n\t    // Move just before the current match, so that when nv_search\n\t    // finishes the cursor will be put back on the match.\n\t    is_state->search_start = t;\n\t    (void)decl(&is_state->search_start);\n\t}\n\telse if (c == Ctrl_G && firstc == '?')\n\t{\n\t    // Move just after the current match, so that when nv_search\n\t    // finishes the cursor will be put back on the match.\n\t    is_state->search_start = t;\n\t    (void)incl(&is_state->search_start);\n\t}\n\tif (LT_POS(t, is_state->search_start) && c == Ctrl_G)\n\t{\n\t    // wrap around\n\t    is_state->search_start = t;\n\t    if (firstc == '?')\n\t\t(void)incl(&is_state->search_start);\n\t    else\n\t\t(void)decl(&is_state->search_start);\n\t}\n\n\tset_search_match(&is_state->match_end);\n\tcurwin->w_cursor = is_state->match_start;\n\tchanged_cline_bef_curs();\n\tupdate_topline();\n\tvalidate_cursor();\n\thighlight_match = TRUE;\n\tsave_viewstate(&is_state->old_viewstate);\n\tupdate_screen(UPD_NOT_VALID);\n\thighlight_match = FALSE;\n\tredrawcmdline();\n\tcurwin->w_cursor = is_state->match_end;\n    }\n    else\n\tvim_beep(BO_ERROR);\n    restore_last_search_pattern();\n    return FAIL;\n}\n\n/*\n * When CTRL-L typed: add character from the match to the pattern.\n * May set \"*c\" to the added character.\n * Return OK when jumping to cmdline_not_changed.\n */\n    static int\nmay_add_char_to_search(int firstc, int *c, incsearch_state_T *is_state)\n{\n    int\t\tskiplen, patlen, search_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\treturn FAIL;\n    }\n    restore_last_search_pattern();\n\n    // Add a character from under the cursor for 'incsearch'.\n    if (is_state->did_incsearch)\n    {\n\tcurwin->w_cursor = is_state->match_end;\n\t*c = gchar_cursor();\n\tif (*c != NUL)\n\t{\n\t    // If 'ignorecase' and 'smartcase' are set and the\n\t    // command line has no uppercase characters, convert\n\t    // the character to lowercase.\n\t    if (p_ic && p_scs && !pat_has_uppercase(ccline.cmdbuff + skiplen))\n\t\t*c = MB_TOLOWER(*c);\n\t    if (*c == search_delim || vim_strchr((char_u *)(\n\t\t\t     magic_isset() ? \"\\\\~^$.*[\" : \"\\\\^$\"), *c) != NULL)\n\t    {\n\t\t// put a backslash before special characters\n\t\tstuffcharReadbuff(*c);\n\t\t*c = '\\\\';\n\t    }\n\t    // add any composing characters\n\t    if (mb_char2len(*c) != mb_ptr2len(ml_get_cursor()))\n\t    {\n\t\tint save_c = *c;\n\n\t\twhile (mb_char2len(*c) != mb_ptr2len(ml_get_cursor()))\n\t\t{\n\t\t    curwin->w_cursor.col += mb_char2len(*c);\n\t\t    *c = gchar_cursor();\n\t\t    stuffcharReadbuff(*c);\n\t\t}\n\t\t*c = save_c;\n\t    }\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n#endif\n\n#ifdef FEAT_ARABIC\n/*\n * Return TRUE if the command line has an Arabic character at or after \"start\"\n * for \"len\" bytes.\n */\n    static int\ncmdline_has_arabic(int start, int len)\n{\n    int\t    j;\n    int\t    mb_l;\n    int\t    u8c;\n    char_u  *p;\n    int\t    u8cc[MAX_MCO];\n\n    if (!enc_utf8)\n\treturn FALSE;\n\n    for (j = start; j < start + len; j += mb_l)\n    {\n\tp = ccline.cmdbuff + j;\n\tu8c = utfc_ptr2char_len(p, u8cc, start + len - j);\n\tmb_l = utfc_ptr2len_len(p, start + len - j);\n\tif (ARABIC_CHAR(u8c))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n    void\ncmdline_init(void)\n{\n    CLEAR_FIELD(ccline);\n}\n\n/*\n * Handle the backslash key pressed in the command-line mode.  CTRL-\\ CTRL-N\n * goes to Normal mode, CTRL-\\ CTRL-G goes to Insert mode when 'insertmode' is\n * set, CTRL-\\ e prompts for an expression.\n */\n    static int\ncmdline_handle_backslash_key(int c, int *gotesc)\n{\n    ++no_mapping;\n    ++allow_keys;\n    c = plain_vgetc();\n    --no_mapping;\n    --allow_keys;\n\n    // CTRL-\\ e doesn't work when obtaining an expression, unless it\n    // is in a mapping.\n    if (c != Ctrl_N && c != Ctrl_G && (c != 'e'\n\t\t|| (ccline.cmdfirstc == '=' && KeyTyped)\n#ifdef FEAT_EVAL\n\t\t|| cmdline_star > 0\n#endif\n\t\t))\n    {\n\tvungetc(c);\n\treturn PROCESS_NEXT_KEY;\n    }\n\n#ifdef FEAT_EVAL\n    if (c == 'e')\n    {\n\tchar_u\t*p = NULL;\n\tint\tlen;\n\n\t/*\n\t * Replace the command line with the result of an expression.\n\t * Need to save and restore the current command line, to be\n\t * able to enter a new one...\n\t */\n\tif (ccline.cmdpos == ccline.cmdlen)\n\t    new_cmdpos = 99999;\t// keep it at the end\n\telse\n\t    new_cmdpos = ccline.cmdpos;\n\n\tc = get_expr_register();\n\tif (c == '=')\n\t{\n\t    // Need to save and restore ccline.  And set \"textlock\"\n\t    // to avoid nasty things like going to another buffer when\n\t    // evaluating an expression.\n\t    ++textlock;\n\t    p = get_expr_line();\n\t    --textlock;\n\n\t    if (p != NULL)\n\t    {\n\t\tlen = (int)STRLEN(p);\n\t\tif (realloc_cmdbuff(len + 1) == OK)\n\t\t{\n\t\t    ccline.cmdlen = len;\n\t\t    STRCPY(ccline.cmdbuff, p);\n\t\t    vim_free(p);\n\n\t\t    // Restore the cursor or use the position set with\n\t\t    // set_cmdline_pos().\n\t\t    if (new_cmdpos > ccline.cmdlen)\n\t\t\tccline.cmdpos = ccline.cmdlen;\n\t\t    else\n\t\t\tccline.cmdpos = new_cmdpos;\n\n\t\t    KeyTyped = FALSE;\t// Don't do p_wc completion.\n\t\t    redrawcmd();\n\t\t    return CMDLINE_CHANGED;\n\t\t}\n\t\tvim_free(p);\n\t    }\n\t}\n\tbeep_flush();\n\tgot_int = FALSE;\t// don't abandon the command line\n\tdid_emsg = FALSE;\n\temsg_on_display = FALSE;\n\tredrawcmd();\n\treturn CMDLINE_NOT_CHANGED;\n    }\n#endif\n\n    if (c == Ctrl_G && p_im && restart_edit == 0)\n\trestart_edit = 'a';\n    *gotesc = TRUE;\t// will free ccline.cmdbuff after putting it\n\t\t\t// in history\n    return GOTO_NORMAL_MODE;\n}\n\n/*\n * Completion for 'wildchar' or 'wildcharm' key.\n * - hitting <ESC> twice means: abandon command line.\n * - wildcard expansion is only done when the 'wildchar' key is really\n *   typed, not when it comes from a macro\n * Returns CMDLINE_CHANGED if command line is changed or CMDLINE_NOT_CHANGED.\n */\n    static int\ncmdline_wildchar_complete(\n\tint\t\tc,\n\tint\t\tescape,\n\tint\t\t*did_wild_list,\n\tint\t\t*wim_index_p,\n\texpand_T\t*xp,\n\tint\t\t*gotesc)\n{\n    int\t\twim_index = *wim_index_p;\n    int\t\tres;\n    int\t\tj;\n    int\t\toptions = WILD_NO_BEEP;\n\n    if (wim_flags[wim_index] & WIM_BUFLASTUSED)\n\toptions |= WILD_BUFLASTUSED;\n    if (xp->xp_numfiles > 0)   // typed p_wc at least twice\n    {\n\t// if 'wildmode' contains \"list\" may still need to list\n\tif (xp->xp_numfiles > 1\n\t\t&& !*did_wild_list\n\t\t&& ((wim_flags[wim_index] & WIM_LIST)\n\t\t    || (p_wmnu && (wim_flags[wim_index] & WIM_FULL) != 0)))\n\t{\n\t    (void)showmatches(xp,\n\t\t    p_wmnu && ((wim_flags[wim_index] & WIM_LIST) == 0));\n\t    redrawcmd();\n\t    *did_wild_list = TRUE;\n\t}\n\tif (wim_flags[wim_index] & WIM_LONGEST)\n\t    res = nextwild(xp, WILD_LONGEST, options, escape);\n\telse if (wim_flags[wim_index] & WIM_FULL)\n\t    res = nextwild(xp, WILD_NEXT, options, escape);\n\telse\n\t    res = OK;\t    // don't insert 'wildchar' now\n    }\n    else\t\t    // typed p_wc first time\n    {\n\twim_index = 0;\n\tj = ccline.cmdpos;\n\t// if 'wildmode' first contains \"longest\", get longest\n\t// common part\n\tif (wim_flags[0] & WIM_LONGEST)\n\t    res = nextwild(xp, WILD_LONGEST, options, escape);\n\telse\n\t    res = nextwild(xp, WILD_EXPAND_KEEP, options, escape);\n\n\t// if interrupted while completing, behave like it failed\n\tif (got_int)\n\t{\n\t    (void)vpeekc();\t// remove <C-C> from input stream\n\t    got_int = FALSE;\t// don't abandon the command line\n\t    (void)ExpandOne(xp, NULL, NULL, 0, WILD_FREE);\n\t    xp->xp_context = EXPAND_NOTHING;\n\t    *wim_index_p = wim_index;\n\t    return CMDLINE_CHANGED;\n\t}\n\n\t// when more than one match, and 'wildmode' first contains\n\t// \"list\", or no change and 'wildmode' contains \"longest,list\",\n\t// list all matches\n\tif (res == OK && xp->xp_numfiles > 1)\n\t{\n\t    // a \"longest\" that didn't do anything is skipped (but not\n\t    // \"list:longest\")\n\t    if (wim_flags[0] == WIM_LONGEST && ccline.cmdpos == j)\n\t\twim_index = 1;\n\t    if ((wim_flags[wim_index] & WIM_LIST)\n\t\t    || (p_wmnu && (wim_flags[wim_index] & WIM_FULL) != 0))\n\t    {\n\t\tif (!(wim_flags[0] & WIM_LONGEST))\n\t\t{\n\t\t    int p_wmnu_save = p_wmnu;\n\n\t\t    p_wmnu = 0;\n\n\t\t    // remove match\n\t\t    nextwild(xp, WILD_PREV, 0, escape);\n\t\t    p_wmnu = p_wmnu_save;\n\t\t}\n\t\t(void)showmatches(xp, p_wmnu\n\t\t\t&& ((wim_flags[wim_index] & WIM_LIST) == 0));\n\t\tredrawcmd();\n\t\t*did_wild_list = TRUE;\n\t\tif (wim_flags[wim_index] & WIM_LONGEST)\n\t\t    nextwild(xp, WILD_LONGEST, options, escape);\n\t\telse if (wim_flags[wim_index] & WIM_FULL)\n\t\t    nextwild(xp, WILD_NEXT, options, escape);\n\t    }\n\t    else\n\t\tvim_beep(BO_WILD);\n\t}\n\telse if (xp->xp_numfiles == -1)\n\t    xp->xp_context = EXPAND_NOTHING;\n    }\n    if (wim_index < 3)\n\t++wim_index;\n    if (c == ESC)\n\t*gotesc = TRUE;\n\n    *wim_index_p = wim_index;\n    return (res == OK) ? CMDLINE_CHANGED : CMDLINE_NOT_CHANGED;\n}\n\n/*\n * Handle backspace, delete and CTRL-W keys in the command-line mode.\n * Returns:\n *  CMDLINE_NOT_CHANGED - if the command line is not changed\n *  CMDLINE_CHANGED - if the command line is changed\n *  GOTO_NORMAL_MODE - go back to normal mode\n */\n    static int\ncmdline_erase_chars(\n\tint c,\n\tint indent\n#ifdef FEAT_SEARCH_EXTRA\n\t, incsearch_state_T *isp\n#endif\n\t)\n{\n    int\t\ti;\n    int\t\tj;\n\n    if (c == K_KDEL)\n\tc = K_DEL;\n\n    /*\n     * Delete current character is the same as backspace on next\n     * character, except at end of line.\n     */\n    if (c == K_DEL && ccline.cmdpos != ccline.cmdlen)\n\t++ccline.cmdpos;\n    if (has_mbyte && c == K_DEL)\n\tccline.cmdpos += mb_off_next(ccline.cmdbuff,\n\t\tccline.cmdbuff + ccline.cmdpos);\n    if (ccline.cmdpos > 0)\n    {\n\tchar_u *p;\n\n\tj = ccline.cmdpos;\n\tp = ccline.cmdbuff + j;\n\tif (has_mbyte)\n\t{\n\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t    if (c == Ctrl_W)\n\t    {\n\t\twhile (p > ccline.cmdbuff && vim_isspace(*p))\n\t\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t\ti = mb_get_class(p);\n\t\twhile (p > ccline.cmdbuff && mb_get_class(p) == i)\n\t\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t\tif (mb_get_class(p) != i)\n\t\t    p += (*mb_ptr2len)(p);\n\t    }\n\t}\n\telse if (c == Ctrl_W)\n\t{\n\t    while (p > ccline.cmdbuff && vim_isspace(p[-1]))\n\t\t--p;\n\t    if (p > ccline.cmdbuff)\n\t    {\n\t\ti = vim_iswordc(p[-1]);\n\t\twhile (p > ccline.cmdbuff && !vim_isspace(p[-1])\n\t\t\t&& vim_iswordc(p[-1]) == i)\n\t\t    --p;\n\t    }\n\t}\n\telse\n\t    --p;\n\tccline.cmdpos = (int)(p - ccline.cmdbuff);\n\tccline.cmdlen -= j - ccline.cmdpos;\n\ti = ccline.cmdpos;\n\twhile (i < ccline.cmdlen)\n\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n\n\t// Truncate at the end, required for multi-byte chars.\n\tccline.cmdbuff[ccline.cmdlen] = NUL;\n#ifdef FEAT_SEARCH_EXTRA\n\tif (ccline.cmdlen == 0)\n\t{\n\t    isp->search_start = isp->save_cursor;\n\t    // save view settings, so that the screen\n\t    // won't be restored at the wrong position\n\t    isp->old_viewstate = isp->init_viewstate;\n\t}\n#endif\n\tredrawcmd();\n    }\n    else if (ccline.cmdlen == 0 && c != Ctrl_W\n\t    && ccline.cmdprompt == NULL && indent == 0)\n    {\n\t// In ex and debug mode it doesn't make sense to return.\n\tif (exmode_active\n#ifdef FEAT_EVAL\n\t\t|| ccline.cmdfirstc == '>'\n#endif\n\t   )\n\t    return CMDLINE_NOT_CHANGED;\n\n\tVIM_CLEAR(ccline.cmdbuff);\t// no commandline to return\n\tif (!cmd_silent)\n\t{\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\tmsg_col = Columns;\n\t    else\n#endif\n\t\tmsg_col = 0;\n\t    msg_putchar(' ');\t\t// delete ':'\n\t}\n#ifdef FEAT_SEARCH_EXTRA\n\tif (ccline.cmdlen == 0)\n\t    isp->search_start = isp->save_cursor;\n#endif\n\tredraw_cmdline = TRUE;\n\treturn GOTO_NORMAL_MODE;\n    }\n    return CMDLINE_CHANGED;\n}\n\n/*\n * Handle the CTRL-^ key in the command-line mode and toggle the use of the\n * language :lmap mappings and/or Input Method.\n */\n    static void\ncmdline_toggle_langmap(long *b_im_ptr)\n{\n    if (map_to_exists_mode((char_u *)\"\", MODE_LANGMAP, FALSE))\n    {\n\t// \":lmap\" mappings exists, toggle use of mappings.\n\tState ^= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(FALSE);\t// Disable input method\n#endif\n\tif (b_im_ptr != NULL)\n\t{\n\t    if (State & MODE_LANGMAP)\n\t\t*b_im_ptr = B_IMODE_LMAP;\n\t    else\n\t\t*b_im_ptr = B_IMODE_NONE;\n\t}\n    }\n#ifdef HAVE_INPUT_METHOD\n    else\n    {\n\t// There are no \":lmap\" mappings, toggle IM.  When\n\t// 'imdisable' is set don't try getting the status, it's\n\t// always off.\n\tif ((p_imdisable && b_im_ptr != NULL)\n\t\t? *b_im_ptr == B_IMODE_IM : im_get_status())\n\t{\n\t    im_set_active(FALSE);\t// Disable input method\n\t    if (b_im_ptr != NULL)\n\t\t*b_im_ptr = B_IMODE_NONE;\n\t}\n\telse\n\t{\n\t    im_set_active(TRUE);\t// Enable input method\n\t    if (b_im_ptr != NULL)\n\t\t*b_im_ptr = B_IMODE_IM;\n\t}\n    }\n#endif\n    if (b_im_ptr != NULL)\n    {\n\tif (b_im_ptr == &curbuf->b_p_iminsert)\n\t    set_iminsert_global();\n\telse\n\t    set_imsearch_global();\n    }\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t// may show different cursor shape\n#endif\n#if defined(FEAT_KEYMAP)\n    // Show/unshow value of 'keymap' in status lines later.\n    status_redraw_curbuf();\n#endif\n}\n\n/*\n * Handle the CTRL-R key in the command-line mode and insert the contents of a\n * numbered or named register.\n */\n    static int\ncmdline_insert_reg(int *gotesc UNUSED)\n{\n    int\t\ti;\n    int\t\tc;\n#ifdef FEAT_EVAL\n    int\t\tsave_new_cmdpos = new_cmdpos;\n#endif\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t// disallow scrolling here\n#endif\n    putcmdline('\"', TRUE);\n    ++no_mapping;\n    ++allow_keys;\n    i = c = plain_vgetc();\t// CTRL-R <char>\n    if (i == Ctrl_O)\n\ti = Ctrl_R;\t\t// CTRL-R CTRL-O == CTRL-R CTRL-R\n    if (i == Ctrl_R)\n\tc = plain_vgetc();\t// CTRL-R CTRL-R <char>\n    extra_char = NUL;\n    --no_mapping;\n    --allow_keys;\n#ifdef FEAT_EVAL\n    /*\n     * Insert the result of an expression.\n     */\n    new_cmdpos = -1;\n    if (c == '=')\n    {\n\tif (ccline.cmdfirstc == '='  // can't do this recursively\n\t\t|| cmdline_star > 0) // or when typing a password\n\t{\n\t    beep_flush();\n\t    c = ESC;\n\t}\n\telse\n\t    c = get_expr_register();\n    }\n#endif\n    if (c != ESC)\t    // use ESC to cancel inserting register\n    {\n\tcmdline_paste(c, i == Ctrl_R, FALSE);\n\n#ifdef FEAT_EVAL\n\t// When there was a serious error abort getting the\n\t// command line.\n\tif (aborting())\n\t{\n\t    *gotesc = TRUE;  // will free ccline.cmdbuff after\n\t    // putting it in history\n\t    return GOTO_NORMAL_MODE;\n\t}\n#endif\n\tKeyTyped = FALSE;\t// Don't do p_wc completion.\n#ifdef FEAT_EVAL\n\tif (new_cmdpos >= 0)\n\t{\n\t    // set_cmdline_pos() was used\n\t    if (new_cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    else\n\t\tccline.cmdpos = new_cmdpos;\n\t}\n#endif\n    }\n#ifdef FEAT_EVAL\n    new_cmdpos = save_new_cmdpos;\n#endif\n\n    // remove the double quote\n    redrawcmd();\n\n    // The text has been stuffed, the command line didn't change yet.\n    return CMDLINE_NOT_CHANGED;\n}\n\n/*\n * Handle the Left and Right mouse clicks in the command-line mode.\n */\n    static void\ncmdline_left_right_mouse(int c, int *ignore_drag_release)\n{\n    if (c == K_LEFTRELEASE || c == K_RIGHTRELEASE)\n\t*ignore_drag_release = TRUE;\n    else\n\t*ignore_drag_release = FALSE;\n# ifdef FEAT_GUI\n    // When GUI is active, also move when 'mouse' is empty\n    if (!gui.in_use)\n# endif\n\tif (!mouse_has(MOUSE_COMMAND))\n\t    return;\n# ifdef FEAT_CLIPBOARD\n    if (mouse_row < cmdline_row && clip_star.available)\n    {\n\tint\t    button, is_click, is_drag;\n\n\t/*\n\t * Handle modeless selection.\n\t */\n\tbutton = get_mouse_button(KEY2TERMCAP1(c),\n\t\t&is_click, &is_drag);\n\tif (mouse_model_popup() && button == MOUSE_LEFT\n\t\t&& (mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    // Translate shift-left to right button.\n\t    button = MOUSE_RIGHT;\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n\tclip_modeless(button, is_click, is_drag);\n\treturn;\n    }\n# endif\n\n    set_cmdspos();\n    for (ccline.cmdpos = 0; ccline.cmdpos < ccline.cmdlen;\n\t    ++ccline.cmdpos)\n    {\n\tint\ti;\n\n\ti = cmdline_charsize(ccline.cmdpos);\n\tif (mouse_row <= cmdline_row + ccline.cmdspos / Columns\n\t\t&& mouse_col < ccline.cmdspos % Columns + i)\n\t    break;\n\tif (has_mbyte)\n\t{\n\t    // Count \">\" for double-wide char that doesn't fit.\n\t    correct_cmdspos(ccline.cmdpos, i);\n\t    ccline.cmdpos += (*mb_ptr2len)(ccline.cmdbuff\n\t\t    + ccline.cmdpos) - 1;\n\t}\n\tccline.cmdspos += i;\n    }\n}\n\n/*\n * Handle the Up, Down, Page Up, Page down, CTRL-N and CTRL-P key in the\n * command-line mode. The pressed key is in 'c'.\n * Returns:\n *  CMDLINE_NOT_CHANGED - if the command line is not changed\n *  CMDLINE_CHANGED - if the command line is changed\n *  GOTO_NORMAL_MODE - go back to normal mode\n */\n    static int\ncmdline_browse_history(\n\tint\tc,\n\tint\tfirstc,\n\tchar_u\t**curcmdstr,\n\tint\thistype,\n\tint\t*hiscnt_p,\n\texpand_T *xp)\n{\n    int\t\ti;\n    int\t\tj;\n    char_u\t*lookfor = *curcmdstr;\n    int\t\thiscnt = *hiscnt_p;\n    int\t\tres;\n\n    if (get_hislen() == 0 || firstc == NUL)\t// no history\n\treturn CMDLINE_NOT_CHANGED;\n\n    i = hiscnt;\n\n    // save current command string so it can be restored later\n    if (lookfor == NULL)\n    {\n\tif ((lookfor = vim_strsave(ccline.cmdbuff)) == NULL)\n\t    return CMDLINE_NOT_CHANGED;\n\tlookfor[ccline.cmdpos] = NUL;\n    }\n\n    j = (int)STRLEN(lookfor);\n    for (;;)\n    {\n\t// one step backwards\n\tif (c == K_UP|| c == K_S_UP || c == Ctrl_P\n\t\t|| c == K_PAGEUP || c == K_KPAGEUP)\n\t{\n\t    if (hiscnt == get_hislen())\t// first time\n\t\thiscnt = *get_hisidx(histype);\n\t    else if (hiscnt == 0 && *get_hisidx(histype)\n\t\t    != get_hislen() - 1)\n\t\thiscnt = get_hislen() - 1;\n\t    else if (hiscnt != *get_hisidx(histype) + 1)\n\t\t--hiscnt;\n\t    else\t\t\t// at top of list\n\t    {\n\t\thiscnt = i;\n\t\tbreak;\n\t    }\n\t}\n\telse    // one step forwards\n\t{\n\t    // on last entry, clear the line\n\t    if (hiscnt == *get_hisidx(histype))\n\t    {\n\t\thiscnt = get_hislen();\n\t\tbreak;\n\t    }\n\n\t    // not on a history line, nothing to do\n\t    if (hiscnt == get_hislen())\n\t\tbreak;\n\t    if (hiscnt == get_hislen() - 1)   // wrap around\n\t\thiscnt = 0;\n\t    else\n\t\t++hiscnt;\n\t}\n\tif (hiscnt < 0 || get_histentry(histype)[hiscnt].hisstr\n\t\t== NULL)\n\t{\n\t    hiscnt = i;\n\t    break;\n\t}\n\tif ((c != K_UP && c != K_DOWN)\n\t\t|| hiscnt == i\n\t\t|| STRNCMP(get_histentry(histype)[hiscnt].hisstr,\n\t\t    lookfor, (size_t)j) == 0)\n\t    break;\n    }\n\n    if (hiscnt != i)\t// jumped to other entry\n    {\n\tchar_u\t*p;\n\tint\t\tlen;\n\tint\t\told_firstc;\n\n\tVIM_CLEAR(ccline.cmdbuff);\n\txp->xp_context = EXPAND_NOTHING;\n\tif (hiscnt == get_hislen())\n\t    p = lookfor;\t// back to the old one\n\telse\n\t    p = get_histentry(histype)[hiscnt].hisstr;\n\n\tif (histype == HIST_SEARCH\n\t\t&& p != lookfor\n\t\t&& (old_firstc = p[STRLEN(p) + 1]) != firstc)\n\t{\n\t    // Correct for the separator character used when\n\t    // adding the history entry vs the one used now.\n\t    // First loop: count length.\n\t    // Second loop: copy the characters.\n\t    for (i = 0; i <= 1; ++i)\n\t    {\n\t\tlen = 0;\n\t\tfor (j = 0; p[j] != NUL; ++j)\n\t\t{\n\t\t    // Replace old sep with new sep, unless it is\n\t\t    // escaped.\n\t\t    if (p[j] == old_firstc\n\t\t\t    && (j == 0 || p[j - 1] != '\\\\'))\n\t\t    {\n\t\t\tif (i > 0)\n\t\t\t    ccline.cmdbuff[len] = firstc;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Escape new sep, unless it is already\n\t\t\t// escaped.\n\t\t\tif (p[j] == firstc\n\t\t\t\t&& (j == 0 || p[j - 1] != '\\\\'))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\t\tccline.cmdbuff[len] = '\\\\';\n\t\t\t    ++len;\n\t\t\t}\n\t\t\tif (i > 0)\n\t\t\t    ccline.cmdbuff[len] = p[j];\n\t\t    }\n\t\t    ++len;\n\t\t}\n\t\tif (i == 0)\n\t\t{\n\t\t    alloc_cmdbuff(len);\n\t\t    if (ccline.cmdbuff == NULL)\n\t\t    {\n\t\t\tres = GOTO_NORMAL_MODE;\n\t\t\tgoto done;\n\t\t    }\n\t\t}\n\t    }\n\t    ccline.cmdbuff[len] = NUL;\n\t}\n\telse\n\t{\n\t    alloc_cmdbuff((int)STRLEN(p));\n\t    if (ccline.cmdbuff == NULL)\n\t    {\n\t\tres = GOTO_NORMAL_MODE;\n\t\tgoto done;\n\t    }\n\t    STRCPY(ccline.cmdbuff, p);\n\t}\n\n\tccline.cmdpos = ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);\n\tredrawcmd();\n\tres = CMDLINE_CHANGED;\n\tgoto done;\n    }\n    beep_flush();\n    res = CMDLINE_NOT_CHANGED;\n\ndone:\n    *curcmdstr = lookfor;\n    *hiscnt_p = hiscnt;\n    return res;\n}\n\n/*\n * Initialize the current command-line info.\n */\n    static int\ninit_ccline(int firstc, int indent)\n{\n    ccline.overstrike = FALSE;\t\t    // always start in insert mode\n\n    /*\n     * set some variables for redrawcmd()\n     */\n    ccline.cmdfirstc = (firstc == '@' ? 0 : firstc);\n    ccline.cmdindent = (firstc > 0 ? indent : 0);\n\n    // alloc initial ccline.cmdbuff\n    alloc_cmdbuff(indent + 50);\n    if (ccline.cmdbuff == NULL)\n\treturn FAIL;\n    ccline.cmdlen = ccline.cmdpos = 0;\n    ccline.cmdbuff[0] = NUL;\n    sb_text_start_cmdline();\n\n    // autoindent for :insert and :append\n    if (firstc <= 0)\n    {\n\tvim_memset(ccline.cmdbuff, ' ', indent);\n\tccline.cmdbuff[indent] = NUL;\n\tccline.cmdpos = indent;\n\tccline.cmdspos = indent;\n\tccline.cmdlen = indent;\n    }\n\n    return OK;\n}\n\n/*\n * getcmdline() - accept a command line starting with firstc.\n *\n * firstc == ':'\t    get \":\" command line.\n * firstc == '/' or '?'\t    get search pattern\n * firstc == '='\t    get expression\n * firstc == '@'\t    get text for input() function\n * firstc == '>'\t    get text for debug mode\n * firstc == NUL\t    get text for :insert command\n * firstc == -1\t\t    like NUL, and break on CTRL-C\n *\n * The line is collected in ccline.cmdbuff, which is reallocated to fit the\n * command line.\n *\n * Careful: getcmdline() can be called recursively!\n *\n * Return pointer to allocated string if there is a commandline, NULL\n * otherwise.\n */\n    char_u *\ngetcmdline(\n    int\t\t  firstc,\n    long\t  count,\t// only used for incremental search\n    int\t\t  indent,\t// indent for inside conditionals\n    getline_opt_T do_concat UNUSED)\n{\n    return getcmdline_int(firstc, count, indent, TRUE);\n}\n\n    static char_u *\ngetcmdline_int(\n    int\t\tfirstc,\n    long\tcount UNUSED,\t// only used for incremental search\n    int\t\tindent,\t\t// indent for inside conditionals\n    int\t\tclear_ccline)\t// clear ccline first\n{\n    static int\tdepth = 0;\t    // call depth\n    int\t\tc;\n    int\t\ti;\n    int\t\tj;\n    int\t\tgotesc = FALSE;\t\t// TRUE when <ESC> just typed\n    int\t\tdo_abbr;\t\t// when TRUE check for abbr.\n    char_u\t*lookfor = NULL;\t// string to match\n    int\t\thiscnt;\t\t\t// current history line in use\n    int\t\thistype;\t\t// history type to be used\n#ifdef FEAT_SEARCH_EXTRA\n    incsearch_state_T\tis_state;\n#endif\n    int\t\tdid_wild_list = FALSE;\t// did wild_list() recently\n    int\t\twim_index = 0;\t\t// index in wim_flags[]\n    int\t\tres;\n    int\t\tsave_msg_scroll = msg_scroll;\n    int\t\tsave_State = State;\t// remember State when called\n    int\t\tsome_key_typed = FALSE;\t// one of the keys was typed\n    // mouse drag and release events are ignored, unless they are\n    // preceded with a mouse down event\n    int\t\tignore_drag_release = TRUE;\n#ifdef FEAT_EVAL\n    int\t\tbreak_ctrl_c = FALSE;\n#endif\n    expand_T\txpc;\n    long\t*b_im_ptr = NULL;\n    cmdline_info_T save_ccline;\n    int\t\tdid_save_ccline = FALSE;\n    int\t\tcmdline_type;\n    int\t\twild_type;\n\n    // one recursion level deeper\n    ++depth;\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t// Being called recursively.  Since ccline is global, we need to save\n\t// the current buffer and restore it when returning.\n\tsave_cmdline(&save_ccline);\n\tdid_save_ccline = TRUE;\n    }\n    if (clear_ccline)\n\tCLEAR_FIELD(ccline);\n\n#ifdef FEAT_EVAL\n    if (firstc == -1)\n    {\n\tfirstc = NUL;\n\tbreak_ctrl_c = TRUE;\n    }\n#endif\n#ifdef FEAT_RIGHTLEFT\n    // start without Hebrew mapping for a command line\n    if (firstc == ':' || firstc == '=' || firstc == '>')\n\tcmd_hkmap = 0;\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n    init_incsearch_state(&is_state);\n#endif\n\n    if (init_ccline(firstc, indent) != OK)\n\tgoto theend;\t// out of memory\n\n    if (depth == 50)\n    {\n\t// Somehow got into a loop recursively calling getcmdline(), bail out.\n\temsg(_(e_command_too_recursive));\n\tgoto theend;\n    }\n\n    ExpandInit(&xpc);\n    ccline.xpc = &xpc;\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && *curwin->w_p_rlc == 's'\n\t\t\t\t\t  && (firstc == '/' || firstc == '?'))\n\tcmdmsg_rl = TRUE;\n    else\n\tcmdmsg_rl = FALSE;\n#endif\n\n    redir_off = TRUE;\t\t// don't redirect the typed command\n    if (!cmd_silent)\n    {\n\ti = msg_scrolled;\n\tmsg_scrolled = 0;\t\t// avoid wait_return() message\n\tgotocmdline(TRUE);\n\tmsg_scrolled += i;\n\tredrawcmdprompt();\t\t// draw prompt or indent\n\tset_cmdspos();\n    }\n    xpc.xp_context = EXPAND_NOTHING;\n    xpc.xp_backslash = XP_BS_NONE;\n#ifndef BACKSLASH_IN_FILENAME\n    xpc.xp_shell = FALSE;\n#endif\n\n#if defined(FEAT_EVAL)\n    if (ccline.input_fn)\n    {\n\txpc.xp_context = ccline.xp_context;\n\txpc.xp_pattern = ccline.cmdbuff;\n\txpc.xp_arg = ccline.xp_arg;\n    }\n#endif\n\n    /*\n     * Avoid scrolling when called by a recursive do_cmdline(), e.g. when\n     * doing \":@0\" when register 0 doesn't contain a CR.\n     */\n    msg_scroll = FALSE;\n\n    State = MODE_CMDLINE;\n\n    if (firstc == '/' || firstc == '?' || firstc == '@')\n    {\n\t// Use \":lmap\" mappings for search pattern and input().\n\tif (curbuf->b_p_imsearch == B_IMODE_USE_INSERT)\n\t    b_im_ptr = &curbuf->b_p_iminsert;\n\telse\n\t    b_im_ptr = &curbuf->b_p_imsearch;\n\tif (*b_im_ptr == B_IMODE_LMAP)\n\t    State |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(*b_im_ptr == B_IMODE_IM);\n#endif\n    }\n#ifdef HAVE_INPUT_METHOD\n    else if (p_imcmdline)\n\tim_set_active(TRUE);\n#endif\n\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\n    // When inside an autocommand for writing \"exiting\" may be set and\n    // terminal mode set to cooked.  Need to set raw mode here then.\n    settmode(TMODE_RAW);\n\n    // Trigger CmdlineEnter autocommands.\n    cmdline_type = firstc == NUL ? '-' : firstc;\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINEENTER);\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n    init_history();\n    hiscnt = get_hislen();\t// set hiscnt to impossible history value\n    histype = hist_char2type(firstc);\n\n#ifdef FEAT_DIGRAPHS\n    do_digraph(-1);\t\t// init digraph typeahead\n#endif\n\n    // If something above caused an error, reset the flags, we do want to type\n    // and execute commands. Display may be messed up a bit.\n    if (did_emsg)\n\tredrawcmd();\n\n#ifdef FEAT_STL_OPT\n    // Redraw the statusline in case it uses the current mode using the mode()\n    // function.\n    if (!cmd_silent && msg_scrolled == 0)\n    {\n\tint\tfound_one = FALSE;\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (*p_stl != NUL || *wp->w_p_stl != NUL)\n\t    {\n\t\twp->w_redr_status = TRUE;\n\t\tfound_one = TRUE;\n\t    }\n\n\tif (*p_tal != NUL)\n\t{\n\t    redraw_tabline = TRUE;\n\t    found_one = TRUE;\n\t}\n\n\tif (found_one)\n\t    redraw_statuslines();\n    }\n#endif\n\n    did_emsg = FALSE;\n    got_int = FALSE;\n\n    /*\n     * Collect the command string, handling editing keys.\n     */\n    for (;;)\n    {\n\tint trigger_cmdlinechanged = TRUE;\n\tint end_wildmenu;\n\n\tredir_off = TRUE;\t// Don't redirect the typed command.\n\t\t\t\t// Repeated, because a \":redir\" inside\n\t\t\t\t// completion may switch it on.\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = FALSE;\t// allow scrolling here\n#endif\n\tquit_more = FALSE;\t// reset after CTRL-D which had a more-prompt\n\n\tdid_emsg = FALSE;\t// There can't really be a reason why an error\n\t\t\t\t// that occurs while typing a command should\n\t\t\t\t// cause the command not to be executed.\n\n\t// Trigger SafeState if nothing is pending.\n\tmay_trigger_safestate(xpc.xp_numfiles <= 0);\n\n\t// Get a character.  Ignore K_IGNORE and K_NOP, they should not do\n\t// anything, such as stop completion.\n\tdo\n\t{\n\t    cursorcmd();\t\t// set the cursor on the right spot\n\t    c = safe_vgetc();\n\t} while (c == K_IGNORE || c == K_NOP);\n\n\tif (c == K_COMMAND || c == K_SCRIPT_COMMAND)\n\t{\n\t    int\t    clen = ccline.cmdlen;\n\n\t    if (do_cmdkey_command(c, DOCMD_NOWAIT) == OK)\n\t    {\n\t\tif (clen == ccline.cmdlen)\n\t\t    trigger_cmdlinechanged = FALSE;\n\t\tgoto cmdline_changed;\n\t    }\n\t}\n\n\tif (KeyTyped)\n\t{\n\t    some_key_typed = TRUE;\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmd_hkmap)\n\t\tc = hkmap(c);\n\t    if (cmdmsg_rl && !KeyStuffed)\n\t    {\n\t\t// Invert horizontal movements and operations.  Only when\n\t\t// typed by the user directly, not when the result of a\n\t\t// mapping.\n\t\tswitch (c)\n\t\t{\n\t\t    case K_RIGHT:   c = K_LEFT; break;\n\t\t    case K_S_RIGHT: c = K_S_LEFT; break;\n\t\t    case K_C_RIGHT: c = K_C_LEFT; break;\n\t\t    case K_LEFT:    c = K_RIGHT; break;\n\t\t    case K_S_LEFT:  c = K_S_RIGHT; break;\n\t\t    case K_C_LEFT:  c = K_C_RIGHT; break;\n\t\t}\n\t    }\n#endif\n\t}\n\n\t/*\n\t * Ignore got_int when CTRL-C was typed here.\n\t * Don't ignore it in :global, we really need to break then, e.g., for\n\t * \":g/pat/normal /pat\" (without the <CR>).\n\t * Don't ignore it for the input() function.\n\t */\n\tif ((c == Ctrl_C\n#ifdef UNIX\n\t\t|| c == intr_char\n#endif\n\t\t\t\t)\n#if defined(FEAT_EVAL) || defined(FEAT_CRYPT)\n\t\t&& firstc != '@'\n#endif\n#ifdef FEAT_EVAL\n\t\t// do clear got_int in Ex mode to avoid infinite Ctrl-C loop\n\t\t&& (!break_ctrl_c || exmode_active)\n#endif\n\t\t&& !global_busy)\n\t    got_int = FALSE;\n\n\t// free old command line when finished moving around in the history\n\t// list\n\tif (lookfor != NULL\n\t\t&& c != K_S_DOWN && c != K_S_UP\n\t\t&& c != K_DOWN && c != K_UP\n\t\t&& c != K_PAGEDOWN && c != K_PAGEUP\n\t\t&& c != K_KPAGEDOWN && c != K_KPAGEUP\n\t\t&& c != K_LEFT && c != K_RIGHT\n\t\t&& (xpc.xp_numfiles > 0 || (c != Ctrl_P && c != Ctrl_N)))\n\t    VIM_CLEAR(lookfor);\n\n\t/*\n\t * When there are matching completions to select <S-Tab> works like\n\t * CTRL-P (unless 'wc' is <S-Tab>).\n\t */\n\tif (c != p_wc && c == K_S_TAB && xpc.xp_numfiles > 0)\n\t    c = Ctrl_P;\n\n\tif (p_wmnu)\n\t    c = wildmenu_translate_key(&ccline, c, &xpc, did_wild_list);\n\n\tif (cmdline_pum_active())\n\t{\n\t    // Ctrl-Y: Accept the current selection and close the popup menu.\n\t    // Ctrl-E: cancel the cmdline popup menu and return the original\n\t    // text.\n\t    if (c == Ctrl_E || c == Ctrl_Y)\n\t    {\n\t\twild_type = (c == Ctrl_E) ? WILD_CANCEL : WILD_APPLY;\n\t\tif (nextwild(&xpc, wild_type, WILD_NO_BEEP,\n\t\t\t\t\t\t\tfirstc != '@') == FAIL)\n\t\t    break;\n\t\tc = Ctrl_E;\n\t    }\n\t}\n\n\t// The wildmenu is cleared if the pressed key is not used for\n\t// navigating the wild menu (i.e. the key is not 'wildchar' or\n\t// 'wildcharm' or Ctrl-N or Ctrl-P or Ctrl-A or Ctrl-L).\n\t// If the popup menu is displayed, then PageDown and PageUp keys are\n\t// also used to navigate the menu.\n\tend_wildmenu = (!(c == p_wc && KeyTyped) && c != p_wcm\n\t\t&& c != Ctrl_N && c != Ctrl_P && c != Ctrl_A && c != Ctrl_L);\n\tend_wildmenu = end_wildmenu && (!cmdline_pum_active() ||\n\t\t\t    (c != K_PAGEDOWN && c != K_PAGEUP\n\t\t\t     && c != K_KPAGEDOWN && c != K_KPAGEUP));\n\n\t// free expanded names when finished walking through matches\n\tif (end_wildmenu)\n\t{\n\t    if (cmdline_pum_active())\n\t\tcmdline_pum_remove();\n\t    if (xpc.xp_numfiles != -1)\n\t\t(void)ExpandOne(&xpc, NULL, NULL, 0, WILD_FREE);\n\t    did_wild_list = FALSE;\n\t    if (!p_wmnu || (c != K_UP && c != K_DOWN))\n\t\txpc.xp_context = EXPAND_NOTHING;\n\t    wim_index = 0;\n\t    wildmenu_cleanup(&ccline);\n\t}\n\n\tif (p_wmnu)\n\t    c = wildmenu_process_key(&ccline, c, &xpc);\n\n\t// CTRL-\\ CTRL-N goes to Normal mode, CTRL-\\ CTRL-G goes to Insert\n\t// mode when 'insertmode' is set, CTRL-\\ e prompts for an expression.\n\tif (c == Ctrl_BSL)\n\t{\n\t    res = cmdline_handle_backslash_key(c, &gotesc);\n\t    if (res == CMDLINE_CHANGED)\n\t\tgoto cmdline_changed;\n\t    else if (res == CMDLINE_NOT_CHANGED)\n\t\tgoto cmdline_not_changed;\n\t    else if (res == GOTO_NORMAL_MODE)\n\t\tgoto returncmd;\t\t// back to cmd mode\n\t    c = Ctrl_BSL;\t\t// backslash key not processed by\n\t\t\t\t\t// cmdline_handle_backslash_key()\n\t}\n\n#ifdef FEAT_CMDWIN\n\tif (c == cedit_key || c == K_CMDWIN)\n\t{\n\t    // TODO: why is ex_normal_busy checked here?\n\t    if ((c == K_CMDWIN || ex_normal_busy == 0) && got_int == FALSE)\n\t    {\n\t\t/*\n\t\t * Open a window to edit the command line (and history).\n\t\t */\n\t\tc = open_cmdwin();\n\t\tsome_key_typed = TRUE;\n\t    }\n\t}\n# ifdef FEAT_DIGRAPHS\n\telse\n# endif\n#endif\n#ifdef FEAT_DIGRAPHS\n\t    c = do_digraph(c);\n#endif\n\n\tif (c == '\\n' || c == '\\r' || c == K_KENTER || (c == ESC\n\t\t\t&& (!KeyTyped || vim_strchr(p_cpo, CPO_ESC) != NULL)))\n\t{\n\t    // In Ex mode a backslash escapes a newline.\n\t    if (exmode_active\n\t\t    && c != ESC\n\t\t    && ccline.cmdpos == ccline.cmdlen\n\t\t    && ccline.cmdpos > 0\n\t\t    && ccline.cmdbuff[ccline.cmdpos - 1] == '\\\\')\n\t    {\n\t\tif (c == K_KENTER)\n\t\t    c = '\\n';\n\t    }\n\t    else\n\t    {\n\t\tgotesc = FALSE;\t// Might have typed ESC previously, don't\n\t\t\t\t// truncate the cmdline now.\n\t\tif (ccheck_abbr(c + ABBR_OFF))\n\t\t    goto cmdline_changed;\n\t\tif (!cmd_silent)\n\t\t{\n\t\t    windgoto(msg_row, 0);\n\t\t    out_flush();\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\n\t// Completion for 'wildchar' or 'wildcharm' key.\n\tif ((c == p_wc && !gotesc && KeyTyped) || c == p_wcm)\n\t{\n\t    res = cmdline_wildchar_complete(c, firstc != '@', &did_wild_list,\n\t\t    &wim_index, &xpc, &gotesc);\n\t    if (res == CMDLINE_CHANGED)\n\t\tgoto cmdline_changed;\n\t}\n\n\tgotesc = FALSE;\n\n\t// <S-Tab> goes to last match, in a clumsy way\n\tif (c == K_S_TAB && KeyTyped)\n\t{\n\t    if (nextwild(&xpc, WILD_EXPAND_KEEP, 0, firstc != '@') == OK)\n\t    {\n\t\tif (xpc.xp_numfiles > 1\n\t\t    && ((!did_wild_list && (wim_flags[wim_index] & WIM_LIST))\n\t\t\t    || p_wmnu))\n\t\t{\n\t\t    // Trigger the popup menu when wildoptions=pum\n\t\t    showmatches(&xpc, p_wmnu\n\t\t\t    && ((wim_flags[wim_index] & WIM_LIST) == 0));\n\t\t}\n\t\tif (nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK\n\t\t\t&& nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK)\n\t\t    goto cmdline_changed;\n\t    }\n\t}\n\n\tif (c == NUL || c == K_ZERO)\t    // NUL is stored as NL\n\t    c = NL;\n\n\tdo_abbr = TRUE;\t\t// default: check for abbreviation\n\n\t/*\n\t * Big switch for a typed command line character.\n\t */\n\tswitch (c)\n\t{\n\tcase K_BS:\n\tcase Ctrl_H:\n\tcase K_DEL:\n\tcase K_KDEL:\n\tcase Ctrl_W:\n\t    res = cmdline_erase_chars(c, indent\n#ifdef FEAT_SEARCH_EXTRA\n\t\t    , &is_state\n#endif\n\t\t    );\n\t    if (res == CMDLINE_NOT_CHANGED)\n\t\tgoto cmdline_not_changed;\n\t    else if (res == GOTO_NORMAL_MODE)\n\t\tgoto returncmd;\t\t// back to cmd mode\n\t    goto cmdline_changed;\n\n\tcase K_INS:\n\tcase K_KINS:\n\t\tccline.overstrike = !ccline.overstrike;\n#ifdef CURSOR_SHAPE\n\t\tui_cursor_shape();\t// may show different cursor shape\n#endif\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_HAT:\n\t\tcmdline_toggle_langmap(b_im_ptr);\n\t\tgoto cmdline_not_changed;\n\n//\tcase '@':   only in very old vi\n\tcase Ctrl_U:\n\t\t// delete all characters left of the cursor\n\t\tj = ccline.cmdpos;\n\t\tccline.cmdlen -= j;\n\t\ti = ccline.cmdpos = 0;\n\t\twhile (i < ccline.cmdlen)\n\t\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n\t\t// Truncate at the end, required for multi-byte chars.\n\t\tccline.cmdbuff[ccline.cmdlen] = NUL;\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (ccline.cmdlen == 0)\n\t\t    is_state.search_start = is_state.save_cursor;\n#endif\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n\n#ifdef FEAT_CLIPBOARD\n\tcase Ctrl_Y:\n\t\t// Copy the modeless selection, if there is one.\n\t\tif (clip_star.state != SELECT_CLEARED)\n\t\t{\n\t\t    if (clip_star.state == SELECT_DONE)\n\t\t\tclip_copy_modeless_selection(TRUE);\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase ESC:\t// get here if p_wc != ESC or when ESC typed twice\n\tcase Ctrl_C:\n\t\t// In exmode it doesn't make sense to return.  Except when\n\t\t// \":normal\" runs out of characters.\n\t\tif (exmode_active\n\t\t\t       && (ex_normal_busy == 0 || typebuf.tb_len > 0))\n\t\t    goto cmdline_not_changed;\n\n\t\tgotesc = TRUE;\t\t// will free ccline.cmdbuff after\n\t\t\t\t\t// putting it in history\n\t\tgoto returncmd;\t\t// back to cmd mode\n\n\tcase Ctrl_R:\t\t\t// insert register\n\t\tres = cmdline_insert_reg(&gotesc);\n\t\tif (res == CMDLINE_NOT_CHANGED)\n\t\t    goto cmdline_not_changed;\n\t\telse if (res == GOTO_NORMAL_MODE)\n\t\t    goto returncmd;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_D:\n\t\tif (showmatches(&xpc, FALSE) == EXPAND_NOTHING)\n\t\t    break;\t// Use ^D as normal char instead\n\n\t\tredrawcmd();\n\t\tcontinue;\t// don't do incremental search now\n\n\tcase K_RIGHT:\n\tcase K_S_RIGHT:\n\tcase K_C_RIGHT:\n\t\tdo\n\t\t{\n\t\t    if (ccline.cmdpos >= ccline.cmdlen)\n\t\t\tbreak;\n\t\t    i = cmdline_charsize(ccline.cmdpos);\n\t\t    if (KeyTyped && ccline.cmdspos + i >= Columns * Rows)\n\t\t\tbreak;\n\t\t    ccline.cmdspos += i;\n\t\t    if (has_mbyte)\n\t\t\tccline.cmdpos += (*mb_ptr2len)(ccline.cmdbuff\n\t\t\t\t\t\t\t     + ccline.cmdpos);\n\t\t    else\n\t\t\t++ccline.cmdpos;\n\t\t}\n\t\twhile ((c == K_S_RIGHT || c == K_C_RIGHT\n\t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n\t\t\t&& ccline.cmdbuff[ccline.cmdpos] != ' ');\n\t\tif (has_mbyte)\n\t\t    set_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase K_LEFT:\n\tcase K_S_LEFT:\n\tcase K_C_LEFT:\n\t\tif (ccline.cmdpos == 0)\n\t\t    goto cmdline_not_changed;\n\t\tdo\n\t\t{\n\t\t    --ccline.cmdpos;\n\t\t    if (has_mbyte)\t// move to first byte of char\n\t\t\tccline.cmdpos -= (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t\t      ccline.cmdbuff + ccline.cmdpos);\n\t\t    ccline.cmdspos -= cmdline_charsize(ccline.cmdpos);\n\t\t}\n\t\twhile (ccline.cmdpos > 0\n\t\t\t&& (c == K_S_LEFT || c == K_C_LEFT\n\t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n\t\t\t&& ccline.cmdbuff[ccline.cmdpos - 1] != ' ');\n\t\tif (has_mbyte)\n\t\t    set_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase K_IGNORE:\n\t\t// Ignore mouse event or open_cmdwin() result.\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_GUI_MSWIN\n\t    // On MS-Windows ignore <M-F4>, we get it when closing the window\n\t    // was cancelled.\n\tcase K_F4:\n\t    if (mod_mask == MOD_MASK_ALT)\n\t    {\n\t\tredrawcmd();\t    // somehow the cmdline is cleared\n\t\tgoto cmdline_not_changed;\n\t    }\n\t    break;\n#endif\n\n\tcase K_MIDDLEDRAG:\n\tcase K_MIDDLERELEASE:\n\t\tgoto cmdline_not_changed;\t// Ignore mouse\n\n\tcase K_MIDDLEMOUSE:\n# ifdef FEAT_GUI\n\t\t// When GUI is active, also paste when 'mouse' is empty\n\t\tif (!gui.in_use)\n# endif\n\t\t    if (!mouse_has(MOUSE_COMMAND))\n\t\t\tgoto cmdline_not_changed;   // Ignore mouse\n# ifdef FEAT_CLIPBOARD\n\t\tif (clip_star.available)\n\t\t    cmdline_paste('*', TRUE, TRUE);\n\t\telse\n# endif\n\t\t    cmdline_paste(0, TRUE, TRUE);\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n\n# ifdef FEAT_DND\n\tcase K_DROP:\n\t\tcmdline_paste('~', TRUE, FALSE);\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n# endif\n\n\tcase K_LEFTDRAG:\n\tcase K_LEFTRELEASE:\n\tcase K_RIGHTDRAG:\n\tcase K_RIGHTRELEASE:\n\t\t// Ignore drag and release events when the button-down wasn't\n\t\t// seen before.\n\t\tif (ignore_drag_release)\n\t\t    goto cmdline_not_changed;\n\t\t// FALLTHROUGH\n\tcase K_LEFTMOUSE:\n\tcase K_RIGHTMOUSE:\n\t\tcmdline_left_right_mouse(c, &ignore_drag_release);\n\t\tgoto cmdline_not_changed;\n\n\t// Mouse scroll wheel: ignored here\n\tcase K_MOUSEDOWN:\n\tcase K_MOUSEUP:\n\tcase K_MOUSELEFT:\n\tcase K_MOUSERIGHT:\n\t// Alternate buttons ignored here\n\tcase K_X1MOUSE:\n\tcase K_X1DRAG:\n\tcase K_X1RELEASE:\n\tcase K_X2MOUSE:\n\tcase K_X2DRAG:\n\tcase K_X2RELEASE:\n\tcase K_MOUSEMOVE:\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_GUI\n\tcase K_LEFTMOUSE_NM:\t// mousefocus click, ignored\n\tcase K_LEFTRELEASE_NM:\n\t\tgoto cmdline_not_changed;\n\n\tcase K_VER_SCROLLBAR:\n\t\tif (msg_scrolled == 0)\n\t\t{\n\t\t    gui_do_scroll();\n\t\t    redrawcmd();\n\t\t}\n\t\tgoto cmdline_not_changed;\n\n\tcase K_HOR_SCROLLBAR:\n\t\tif (msg_scrolled == 0)\n\t\t{\n\t\t    gui_do_horiz_scroll(scrollbar_value, FALSE);\n\t\t    redrawcmd();\n\t\t}\n\t\tgoto cmdline_not_changed;\n#endif\n#ifdef FEAT_GUI_TABLINE\n\tcase K_TABLINE:\n\tcase K_TABMENU:\n\t\t// Don't want to change any tabs here.  Make sure the same tab\n\t\t// is still selected.\n\t\tif (gui_use_tabline())\n\t\t    gui_mch_set_curtab(tabpage_index(curtab));\n\t\tgoto cmdline_not_changed;\n#endif\n\n\tcase K_SELECT:\t    // end of Select mode mapping - ignore\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_B:\t    // begin of command line\n\tcase K_HOME:\n\tcase K_KHOME:\n\tcase K_S_HOME:\n\tcase K_C_HOME:\n\t\tccline.cmdpos = 0;\n\t\tset_cmdspos();\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_E:\t    // end of command line\n\tcase K_END:\n\tcase K_KEND:\n\tcase K_S_END:\n\tcase K_C_END:\n\t\tccline.cmdpos = ccline.cmdlen;\n\t\tset_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_A:\t    // all matches\n\t\tif (cmdline_pum_active())\n\t\t    // As Ctrl-A completes all the matches, close the popup\n\t\t    // menu (if present)\n\t\t    cmdline_pum_cleanup(&ccline);\n\n\t\tif (nextwild(&xpc, WILD_ALL, 0, firstc != '@') == FAIL)\n\t\t    break;\n\t\txpc.xp_context = EXPAND_NOTHING;\n\t\tdid_wild_list = FALSE;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_L:\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (may_add_char_to_search(firstc, &c, &is_state) == OK)\n\t\t    goto cmdline_not_changed;\n#endif\n\n\t\t// completion: longest common part\n\t\tif (nextwild(&xpc, WILD_LONGEST, 0, firstc != '@') == FAIL)\n\t\t    break;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_N:\t    // next match\n\tcase Ctrl_P:\t    // previous match\n\t\tif (xpc.xp_numfiles > 0)\n\t\t{\n\t\t    wild_type = (c == Ctrl_P) ? WILD_PREV : WILD_NEXT;\n\t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n\t\t\tbreak;\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\t// FALLTHROUGH\n\tcase K_UP:\n\tcase K_DOWN:\n\tcase K_S_UP:\n\tcase K_S_DOWN:\n\tcase K_PAGEUP:\n\tcase K_KPAGEUP:\n\tcase K_PAGEDOWN:\n\tcase K_KPAGEDOWN:\n\t\tif (cmdline_pum_active()\n\t\t\t&& (c == K_PAGEUP || c == K_PAGEDOWN ||\n\t\t\t    c == K_KPAGEUP || c == K_KPAGEDOWN))\n\t\t{\n\t\t    // If the popup menu is displayed, then PageUp and PageDown\n\t\t    // are used to scroll the menu.\n\t\t    wild_type = WILD_PAGEUP;\n\t\t    if (c == K_PAGEDOWN || c == K_KPAGEDOWN)\n\t\t\twild_type = WILD_PAGEDOWN;\n\t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n\t\t\tbreak;\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\telse\n\t\t{\n\t\t    res = cmdline_browse_history(c, firstc, &lookfor, histype,\n\t\t\t    &hiscnt, &xpc);\n\t\t    if (res == CMDLINE_CHANGED)\n\t\t\tgoto cmdline_changed;\n\t\t    else if (res == GOTO_NORMAL_MODE)\n\t\t\tgoto returncmd;\n\t\t}\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_SEARCH_EXTRA\n\tcase Ctrl_G:\t    // next match\n\tcase Ctrl_T:\t    // previous match\n\t\tif (may_adjust_incsearch_highlighting(\n\t\t\t\t\t  firstc, count, &is_state, c) == FAIL)\n\t\t    goto cmdline_not_changed;\n\t\tbreak;\n#endif\n\n\tcase Ctrl_V:\n\tcase Ctrl_Q:\n\t\t{\n\t\t    ignore_drag_release = TRUE;\n\t\t    putcmdline('^', TRUE);\n\n\t\t    // Get next (two) character(s).  Do not change any\n\t\t    // modifyOtherKeys ESC sequence to a normal key for\n\t\t    // CTRL-SHIFT-V.\n\t\t    c = get_literal(mod_mask & MOD_MASK_SHIFT);\n\n\t\t    do_abbr = FALSE;\t    // don't do abbreviation now\n\t\t    extra_char = NUL;\n\t\t    // may need to remove ^ when composing char was typed\n\t\t    if (enc_utf8 && utf_iscomposing(c) && !cmd_silent)\n\t\t    {\n\t\t\tdraw_cmdline(ccline.cmdpos,\n\t\t\t\t\t\tccline.cmdlen - ccline.cmdpos);\n\t\t\tmsg_putchar(' ');\n\t\t\tcursorcmd();\n\t\t    }\n\t\t}\n\n\t\tbreak;\n\n#ifdef FEAT_DIGRAPHS\n\tcase Ctrl_K:\n\t\tignore_drag_release = TRUE;\n\t\tputcmdline('?', TRUE);\n# ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t    // disallow scrolling here\n# endif\n\t\tc = get_digraph(TRUE);\n\t\textra_char = NUL;\n\t\tif (c != NUL)\n\t\t    break;\n\n\t\tredrawcmd();\n\t\tgoto cmdline_not_changed;\n#endif // FEAT_DIGRAPHS\n\n#ifdef FEAT_RIGHTLEFT\n\tcase Ctrl__:\t    // CTRL-_: switch language mode\n\t\tif (!p_ari)\n\t\t    break;\n\t\tcmd_hkmap = !cmd_hkmap;\n\t\tgoto cmdline_not_changed;\n#endif\n\n\tcase K_PS:\n\t\tbracketed_paste(PASTE_CMDLINE, FALSE, NULL);\n\t\tgoto cmdline_changed;\n\n\tdefault:\n#ifdef UNIX\n\t\tif (c == intr_char)\n\t\t{\n\t\t    gotesc = TRUE;\t// will free ccline.cmdbuff after\n\t\t\t\t\t// putting it in history\n\t\t    goto returncmd;\t// back to Normal mode\n\t\t}\n#endif\n\t\t/*\n\t\t * Normal character with no special meaning.  Just set mod_mask\n\t\t * to 0x0 so that typing Shift-Space in the GUI doesn't enter\n\t\t * the string <S-Space>.  This should only happen after ^V.\n\t\t */\n\t\tif (!IS_SPECIAL(c))\n\t\t    mod_mask = 0x0;\n\t\tbreak;\n\t}\n\t/*\n\t * End of switch on command line character.\n\t * We come here if we have a normal character.\n\t */\n\n\tif (do_abbr && (IS_SPECIAL(c) || !vim_iswordc(c))\n\t\t&& (ccheck_abbr(\n\t\t\t// Add ABBR_OFF for characters above 0x100, this is\n\t\t\t// what check_abbr() expects.\n\t\t\t\t(has_mbyte && c >= 0x100) ? (c + ABBR_OFF) : c)\n\t\t    || c == Ctrl_RSB))\n\t    goto cmdline_changed;\n\n\t/*\n\t * put the character in the command line\n\t */\n\tif (IS_SPECIAL(c) || mod_mask != 0)\n\t    put_on_cmdline(get_special_key_name(c, mod_mask), -1, TRUE);\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tj = (*mb_char2bytes)(c, IObuff);\n\t\tIObuff[j] = NUL;\t// exclude composing chars\n\t\tput_on_cmdline(IObuff, j, TRUE);\n\t    }\n\t    else\n\t    {\n\t\tIObuff[0] = c;\n\t\tput_on_cmdline(IObuff, 1, TRUE);\n\t    }\n\t}\n\tgoto cmdline_changed;\n\n/*\n * This part implements incremental searches for \"/\" and \"?\"\n * Jump to cmdline_not_changed when a character has been read but the command\n * line did not change. Then we only search and redraw if something changed in\n * the past.\n * Jump to cmdline_changed when the command line did change.\n * (Sorry for the goto's, I know it is ugly).\n */\ncmdline_not_changed:\n#ifdef FEAT_SEARCH_EXTRA\n\tif (!is_state.incsearch_postponed)\n\t    continue;\n#endif\n\ncmdline_changed:\n#ifdef FEAT_SEARCH_EXTRA\n\t// If the window changed incremental search state is not valid.\n\tif (is_state.winid != curwin->w_id)\n\t    init_incsearch_state(&is_state);\n#endif\n\tif (trigger_cmdlinechanged)\n\t    // Trigger CmdlineChanged autocommands.\n\t    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINECHANGED);\n\n#ifdef FEAT_SEARCH_EXTRA\n\tif (xpc.xp_context == EXPAND_NOTHING && (KeyTyped || vpeekc() == NUL))\n\t    may_do_incsearch_highlighting(firstc, count, &is_state);\n#endif\n\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl\n# ifdef FEAT_ARABIC\n\t\t|| (p_arshape && !p_tbidi\n\t\t\t\t       && cmdline_has_arabic(0, ccline.cmdlen))\n# endif\n\t\t)\n\t    // Always redraw the whole command line to fix shaping and\n\t    // right-left typing.  Not efficient, but it works.\n\t    // Do it only when there are no characters left to read\n\t    // to avoid useless intermediate redraws.\n\t    if (vpeekc() == NUL)\n\t\tredrawcmd();\n#endif\n    }\n\nreturncmd:\n\n#ifdef FEAT_RIGHTLEFT\n    cmdmsg_rl = FALSE;\n#endif\n\n    ExpandCleanup(&xpc);\n    ccline.xpc = NULL;\n\n#ifdef FEAT_SEARCH_EXTRA\n    finish_incsearch_highlighting(gotesc, &is_state, FALSE);\n#endif\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t/*\n\t * Put line in history buffer (\":\" and \"=\" only when it was typed).\n\t */\n\tif (ccline.cmdlen && firstc != NUL\n\t\t&& (some_key_typed || histype == HIST_SEARCH))\n\t{\n\t    add_to_history(histype, ccline.cmdbuff, TRUE,\n\t\t\t\t       histype == HIST_SEARCH ? firstc : NUL);\n\t    if (firstc == ':')\n\t    {\n\t\tvim_free(new_last_cmdline);\n\t\tnew_last_cmdline = vim_strsave(ccline.cmdbuff);\n\t    }\n\t}\n\n\tif (gotesc)\n\t    abandon_cmdline();\n    }\n\n    /*\n     * If the screen was shifted up, redraw the whole screen (later).\n     * If the line is too long, clear it, so ruler and shown command do\n     * not get printed in the middle of it.\n     */\n    msg_check();\n    msg_scroll = save_msg_scroll;\n    redir_off = FALSE;\n\n    // When the command line was typed, no need for a wait-return prompt.\n    if (some_key_typed)\n\tneed_wait_return = FALSE;\n\n    // Trigger CmdlineLeave autocommands.\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINELEAVE);\n\n    State = save_State;\n\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n#ifdef HAVE_INPUT_METHOD\n    if (b_im_ptr != NULL && *b_im_ptr != B_IMODE_LMAP)\n\tim_save_status(b_im_ptr);\n    im_set_active(FALSE);\n#endif\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    sb_text_end_cmdline();\n\ntheend:\n    {\n\tchar_u *p = ccline.cmdbuff;\n\n\t--depth;\n\tif (did_save_ccline)\n\t    restore_cmdline(&save_ccline);\n\telse\n\t    ccline.cmdbuff = NULL;\n\treturn p;\n    }\n}\n\n#if (defined(FEAT_CRYPT) || defined(FEAT_EVAL)) || defined(PROTO)\n/*\n * Get a command line with a prompt.\n * This is prepared to be called recursively from getcmdline() (e.g. by\n * f_input() when evaluating an expression from CTRL-R =).\n * Returns the command line in allocated memory, or NULL.\n */\n    char_u *\ngetcmdline_prompt(\n    int\t\tfirstc,\n    char_u\t*prompt,\t// command line prompt\n    int\t\tattr,\t\t// attributes for prompt\n    int\t\txp_context,\t// type of expansion\n    char_u\t*xp_arg)\t// user-defined expansion argument\n{\n    char_u\t\t*s;\n    cmdline_info_T\tsave_ccline;\n    int\t\t\tdid_save_ccline = FALSE;\n    int\t\t\tmsg_col_save = msg_col;\n    int\t\t\tmsg_silent_save = msg_silent;\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t// Save the values of the current cmdline and restore them below.\n\tsave_cmdline(&save_ccline);\n\tdid_save_ccline = TRUE;\n    }\n\n    CLEAR_FIELD(ccline);\n    ccline.cmdprompt = prompt;\n    ccline.cmdattr = attr;\n# ifdef FEAT_EVAL\n    ccline.xp_context = xp_context;\n    ccline.xp_arg = xp_arg;\n    ccline.input_fn = (firstc == '@');\n# endif\n    msg_silent = 0;\n    s = getcmdline_int(firstc, 1L, 0, FALSE);\n\n    if (did_save_ccline)\n\trestore_cmdline(&save_ccline);\n\n    msg_silent = msg_silent_save;\n    // Restore msg_col, the prompt from input() may have changed it.\n    // But only if called recursively and the commandline is therefore being\n    // restored to an old one; if not, the input() prompt stays on the screen,\n    // so we need its modified msg_col left intact.\n    if (ccline.cmdbuff != NULL)\n\tmsg_col = msg_col_save;\n\n    return s;\n}\n#endif\n\n/*\n * Read the 'wildmode' option, fill wim_flags[].\n */\n    int\ncheck_opt_wim(void)\n{\n    char_u\tnew_wim_flags[4];\n    char_u\t*p;\n    int\t\ti;\n    int\t\tidx = 0;\n\n    for (i = 0; i < 4; ++i)\n\tnew_wim_flags[i] = 0;\n\n    for (p = p_wim; *p; ++p)\n    {\n\tfor (i = 0; ASCII_ISALPHA(p[i]); ++i)\n\t    ;\n\tif (p[i] != NUL && p[i] != ',' && p[i] != ':')\n\t    return FAIL;\n\tif (i == 7 && STRNCMP(p, \"longest\", 7) == 0)\n\t    new_wim_flags[idx] |= WIM_LONGEST;\n\telse if (i == 4 && STRNCMP(p, \"full\", 4) == 0)\n\t    new_wim_flags[idx] |= WIM_FULL;\n\telse if (i == 4 && STRNCMP(p, \"list\", 4) == 0)\n\t    new_wim_flags[idx] |= WIM_LIST;\n\telse if (i == 8 && STRNCMP(p, \"lastused\", 8) == 0)\n\t    new_wim_flags[idx] |= WIM_BUFLASTUSED;\n\telse\n\t    return FAIL;\n\tp += i;\n\tif (*p == NUL)\n\t    break;\n\tif (*p == ',')\n\t{\n\t    if (idx == 3)\n\t\treturn FAIL;\n\t    ++idx;\n\t}\n    }\n\n    // fill remaining entries with last flag\n    while (idx < 3)\n    {\n\tnew_wim_flags[idx + 1] = new_wim_flags[idx];\n\t++idx;\n    }\n\n    // only when there are no errors, wim_flags[] is changed\n    for (i = 0; i < 4; ++i)\n\twim_flags[i] = new_wim_flags[i];\n    return OK;\n}\n\n/*\n * Return TRUE when the text must not be changed and we can't switch to\n * another window or buffer.  TRUE when editing the command line, evaluating\n * 'balloonexpr', etc.\n */\n    int\ntext_locked(void)\n{\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\treturn TRUE;\n#endif\n    return textlock != 0;\n}\n\n/*\n * Give an error message for a command that isn't allowed while the cmdline\n * window is open or editing the cmdline in another way.\n */\n    void\ntext_locked_msg(void)\n{\n    emsg(_(get_text_locked_msg()));\n}\n\n    char *\nget_text_locked_msg(void)\n{\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\treturn e_invalid_in_cmdline_window;\n#endif\n    return e_not_allowed_to_change_text_or_change_window;\n}\n\n/*\n * Check for text, window or buffer locked.\n * Give an error message and return TRUE if something is locked.\n */\n    int\ntext_or_buf_locked(void)\n{\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn TRUE;\n    }\n    return curbuf_locked();\n}\n\n/*\n * Check if \"curbuf_lock\" or \"allbuf_lock\" is set and return TRUE when it is\n * and give an error message.\n */\n    int\ncurbuf_locked(void)\n{\n    if (curbuf_lock > 0)\n    {\n\temsg(_(e_not_allowed_to_edit_another_buffer_now));\n\treturn TRUE;\n    }\n    return allbuf_locked();\n}\n\n/*\n * Check if \"allbuf_lock\" is set and return TRUE when it is and give an error\n * message.\n */\n    int\nallbuf_locked(void)\n{\n    if (allbuf_lock > 0)\n    {\n\temsg(_(e_not_allowed_to_change_buffer_information_now));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n    static int\ncmdline_charsize(int idx)\n{\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n    if (cmdline_star > 0)\t    // showing '*', always 1 position\n\treturn 1;\n#endif\n    return ptr2cells(ccline.cmdbuff + idx);\n}\n\n/*\n * Compute the offset of the cursor on the command line for the prompt and\n * indent.\n */\n    static void\nset_cmdspos(void)\n{\n    if (ccline.cmdfirstc != NUL)\n\tccline.cmdspos = 1 + ccline.cmdindent;\n    else\n\tccline.cmdspos = 0 + ccline.cmdindent;\n}\n\n/*\n * Compute the screen position for the cursor on the command line.\n */\n    static void\nset_cmdspos_cursor(void)\n{\n    int\t\ti, m, c;\n\n    set_cmdspos();\n    if (KeyTyped)\n    {\n\tm = Columns * Rows;\n\tif (m < 0)\t// overflow, Columns or Rows at weird value\n\t    m = MAXCOL;\n    }\n    else\n\tm = MAXCOL;\n    for (i = 0; i < ccline.cmdlen && i < ccline.cmdpos; ++i)\n    {\n\tc = cmdline_charsize(i);\n\t// Count \">\" for double-wide multi-byte char that doesn't fit.\n\tif (has_mbyte)\n\t    correct_cmdspos(i, c);\n\t// If the cmdline doesn't fit, show cursor on last visible char.\n\t// Don't move the cursor itself, so we can still append.\n\tif ((ccline.cmdspos += c) >= m)\n\t{\n\t    ccline.cmdspos -= c;\n\t    break;\n\t}\n\tif (has_mbyte)\n\t    i += (*mb_ptr2len)(ccline.cmdbuff + i) - 1;\n    }\n}\n\n/*\n * Check if the character at \"idx\", which is \"cells\" wide, is a multi-byte\n * character that doesn't fit, so that a \">\" must be displayed.\n */\n    static void\ncorrect_cmdspos(int idx, int cells)\n{\n    if ((*mb_ptr2len)(ccline.cmdbuff + idx) > 1\n\t\t&& (*mb_ptr2cells)(ccline.cmdbuff + idx) > 1\n\t\t&& ccline.cmdspos % Columns + cells > Columns)\n\tccline.cmdspos++;\n}\n\n/*\n * Get an Ex command line for the \":\" command.\n */\n    char_u *\ngetexline(\n    int\t\tc,\t\t// normally ':', NUL for \":append\"\n    void\t*cookie UNUSED,\n    int\t\tindent,\t\t// indent for inside conditionals\n    getline_opt_T options)\n{\n    // When executing a register, remove ':' that's in front of each line.\n    if (exec_from_reg && vpeekc() == ':')\n\t(void)vgetc();\n    return getcmdline(c, 1L, indent, options);\n}\n\n/*\n * Get an Ex command line for Ex mode.\n * In Ex mode we only use the OS supplied line editing features and no\n * mappings or abbreviations.\n * Returns a string in allocated memory or NULL.\n */\n    char_u *\ngetexmodeline(\n    int\t\tpromptc,\t// normally ':', NUL for \":append\" and '?' for\n\t\t\t\t// :s prompt\n    void\t*cookie UNUSED,\n    int\t\tindent,\t\t// indent for inside conditionals\n    getline_opt_T options UNUSED)\n{\n    garray_T\tline_ga;\n    char_u\t*pend;\n    int\t\tstartcol = 0;\n    int\t\tc1 = 0;\n    int\t\tescaped = FALSE;\t// CTRL-V typed\n    int\t\tvcol = 0;\n    char_u\t*p;\n    int\t\tprev_char;\n    int\t\tlen;\n\n    // Switch cursor on now.  This avoids that it happens after the \"\\n\", which\n    // confuses the system function that computes tabstops.\n    cursor_on();\n\n    // always start in column 0; write a newline if necessary\n    compute_cmdrow();\n    if ((msg_col || msg_didout) && promptc != '?')\n\tmsg_putchar('\\n');\n    if (promptc == ':')\n    {\n\t// indent that is only displayed, not in the line itself\n\tif (p_prompt)\n\t    msg_putchar(':');\n\twhile (indent-- > 0)\n\t    msg_putchar(' ');\n\tstartcol = msg_col;\n    }\n\n    ga_init2(&line_ga, 1, 30);\n\n    // autoindent for :insert and :append is in the line itself\n    if (promptc <= 0)\n    {\n\tvcol = indent;\n\twhile (indent >= 8)\n\t{\n\t    ga_append(&line_ga, TAB);\n\t    msg_puts(\"        \");\n\t    indent -= 8;\n\t}\n\twhile (indent-- > 0)\n\t{\n\t    ga_append(&line_ga, ' ');\n\t    msg_putchar(' ');\n\t}\n    }\n    ++no_mapping;\n    ++allow_keys;\n\n    /*\n     * Get the line, one character at a time.\n     */\n    got_int = FALSE;\n    while (!got_int)\n    {\n\tlong    sw;\n\tchar_u *s;\n\n\tif (ga_grow(&line_ga, 40) == FAIL)\n\t    break;\n\n\t/*\n\t * Get one character at a time.\n\t */\n\tprev_char = c1;\n\n\t// Check for a \":normal\" command and no more characters left.\n\tif (ex_normal_busy > 0 && typebuf.tb_len == 0)\n\t    c1 = '\\n';\n\telse\n\t    c1 = vgetc();\n\n\t/*\n\t * Handle line editing.\n\t * Previously this was left to the system, putting the terminal in\n\t * cooked mode, but then CTRL-D and CTRL-T can't be used properly.\n\t */\n\tif (got_int)\n\t{\n\t    msg_putchar('\\n');\n\t    break;\n\t}\n\n\tif (c1 == K_PS)\n\t{\n\t    bracketed_paste(PASTE_EX, FALSE, &line_ga);\n\t    goto redraw;\n\t}\n\n\tif (!escaped)\n\t{\n\t    // CR typed means \"enter\", which is NL\n\t    if (c1 == '\\r')\n\t\tc1 = '\\n';\n\n\t    if (c1 == BS || c1 == K_BS\n\t\t\t  || c1 == DEL || c1 == K_DEL || c1 == K_KDEL)\n\t    {\n\t\tif (line_ga.ga_len > 0)\n\t\t{\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tp = (char_u *)line_ga.ga_data;\n\t\t\tp[line_ga.ga_len] = NUL;\n\t\t\tlen = (*mb_head_off)(p, p + line_ga.ga_len - 1) + 1;\n\t\t\tline_ga.ga_len -= len;\n\t\t    }\n\t\t    else\n\t\t\t--line_ga.ga_len;\n\t\t    goto redraw;\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    if (c1 == Ctrl_U)\n\t    {\n\t\tmsg_col = startcol;\n\t\tmsg_clr_eos();\n\t\tline_ga.ga_len = 0;\n\t\tgoto redraw;\n\t    }\n\n\t    if (c1 == Ctrl_T)\n\t    {\n\t\tsw = get_sw_value(curbuf);\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tp[line_ga.ga_len] = NUL;\n\t\tindent = get_indent_str(p, 8, FALSE);\n\t\tindent += sw - indent % sw;\nadd_indent:\n\t\twhile (get_indent_str(p, 8, FALSE) < indent)\n\t\t{\n\t\t    (void)ga_grow(&line_ga, 2);  // one more for the NUL\n\t\t    p = (char_u *)line_ga.ga_data;\n\t\t    s = skipwhite(p);\n\t\t    mch_memmove(s + 1, s, line_ga.ga_len - (s - p) + 1);\n\t\t    *s = ' ';\n\t\t    ++line_ga.ga_len;\n\t\t}\nredraw:\n\t\t// redraw the line\n\t\tmsg_col = startcol;\n\t\tvcol = 0;\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tp[line_ga.ga_len] = NUL;\n\t\twhile (p < (char_u *)line_ga.ga_data + line_ga.ga_len)\n\t\t{\n\t\t    if (*p == TAB)\n\t\t    {\n\t\t\tdo\n\t\t\t    msg_putchar(' ');\n\t\t\twhile (++vcol % 8);\n\t\t\t++p;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tlen = mb_ptr2len(p);\n\t\t\tmsg_outtrans_len(p, len);\n\t\t\tvcol += ptr2cells(p);\n\t\t\tp += len;\n\t\t    }\n\t\t}\n\t\tmsg_clr_eos();\n\t\twindgoto(msg_row, msg_col);\n\t\tcontinue;\n\t    }\n\n\t    if (c1 == Ctrl_D)\n\t    {\n\t\t// Delete one shiftwidth.\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tif (prev_char == '0' || prev_char == '^')\n\t\t{\n\t\t    if (prev_char == '^')\n\t\t\tex_keep_indent = TRUE;\n\t\t    indent = 0;\n\t\t    p[--line_ga.ga_len] = NUL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[line_ga.ga_len] = NUL;\n\t\t    indent = get_indent_str(p, 8, FALSE);\n\t\t    if (indent > 0)\n\t\t    {\n\t\t\t--indent;\n\t\t\tindent -= indent % get_sw_value(curbuf);\n\t\t    }\n\t\t}\n\t\twhile (get_indent_str(p, 8, FALSE) > indent)\n\t\t{\n\t\t    s = skipwhite(p);\n\t\t    mch_memmove(s - 1, s, line_ga.ga_len - (s - p) + 1);\n\t\t    --line_ga.ga_len;\n\t\t}\n\t\tgoto add_indent;\n\t    }\n\n\t    if (c1 == Ctrl_V || c1 == Ctrl_Q)\n\t    {\n\t\tescaped = TRUE;\n\t\tcontinue;\n\t    }\n\n\t    // Ignore special key codes: mouse movement, K_IGNORE, etc.\n\t    if (IS_SPECIAL(c1))\n\t\tcontinue;\n\t}\n\n\tif (IS_SPECIAL(c1))\n\t    c1 = '?';\n\tif (has_mbyte)\n\t    len = (*mb_char2bytes)(c1,\n\t\t\t\t  (char_u *)line_ga.ga_data + line_ga.ga_len);\n\telse\n\t{\n\t    len = 1;\n\t    ((char_u *)line_ga.ga_data)[line_ga.ga_len] = c1;\n\t}\n\tif (c1 == '\\n')\n\t    msg_putchar('\\n');\n\telse if (c1 == TAB)\n\t{\n\t    // Don't use chartabsize(), 'ts' can be different\n\t    do\n\t\tmsg_putchar(' ');\n\t    while (++vcol % 8);\n\t}\n\telse\n\t{\n\t    msg_outtrans_len(\n\t\t     ((char_u *)line_ga.ga_data) + line_ga.ga_len, len);\n\t    vcol += char2cells(c1);\n\t}\n\tline_ga.ga_len += len;\n\tescaped = FALSE;\n\n\twindgoto(msg_row, msg_col);\n\tpend = (char_u *)(line_ga.ga_data) + line_ga.ga_len;\n\n\t// We are done when a NL is entered, but not when it comes after an\n\t// odd number of backslashes, that results in a NUL.\n\tif (line_ga.ga_len > 0 && pend[-1] == '\\n')\n\t{\n\t    int bcount = 0;\n\n\t    while (line_ga.ga_len - 2 >= bcount && pend[-2 - bcount] == '\\\\')\n\t\t++bcount;\n\n\t    if (bcount > 0)\n\t    {\n\t\t// Halve the number of backslashes: \"\\NL\" -> \"NUL\", \"\\\\NL\" ->\n\t\t// \"\\NL\", etc.\n\t\tline_ga.ga_len -= (bcount + 1) / 2;\n\t\tpend -= (bcount + 1) / 2;\n\t\tpend[-1] = '\\n';\n\t    }\n\n\t    if ((bcount & 1) == 0)\n\t    {\n\t\t--line_ga.ga_len;\n\t\t--pend;\n\t\t*pend = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    --no_mapping;\n    --allow_keys;\n\n    // make following messages go to the next line\n    msg_didout = FALSE;\n    msg_col = 0;\n    if (msg_row < Rows - 1)\n\t++msg_row;\n    emsg_on_display = FALSE;\t\t// don't want ui_delay()\n\n    if (got_int)\n\tga_clear(&line_ga);\n\n    return (char_u *)line_ga.ga_data;\n}\n\n# if defined(MCH_CURSOR_SHAPE) || defined(FEAT_GUI) \\\n\t|| defined(FEAT_MOUSESHAPE) || defined(PROTO)\n/*\n * Return TRUE if ccline.overstrike is on.\n */\n    int\ncmdline_overstrike(void)\n{\n    return ccline.overstrike;\n}\n\n/*\n * Return TRUE if the cursor is at the end of the cmdline.\n */\n    int\ncmdline_at_end(void)\n{\n    return (ccline.cmdpos >= ccline.cmdlen);\n}\n#endif\n\n#if (defined(FEAT_XIM) && (defined(FEAT_GUI_GTK))) || defined(PROTO)\n/*\n * Return the virtual column number at the current cursor position.\n * This is used by the IM code to obtain the start of the preedit string.\n */\n    colnr_T\ncmdline_getvcol_cursor(void)\n{\n    if (ccline.cmdbuff == NULL || ccline.cmdpos > ccline.cmdlen)\n\treturn MAXCOL;\n\n    if (has_mbyte)\n    {\n\tcolnr_T\tcol;\n\tint\ti = 0;\n\n\tfor (col = 0; i < ccline.cmdpos; ++col)\n\t    i += (*mb_ptr2len)(ccline.cmdbuff + i);\n\n\treturn col;\n    }\n    else\n\treturn ccline.cmdpos;\n}\n#endif\n\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n/*\n * If part of the command line is an IM preedit string, redraw it with\n * IM feedback attributes.  The cursor position is restored after drawing.\n */\n    static void\nredrawcmd_preedit(void)\n{\n    if ((State & MODE_CMDLINE)\n\t    && xic != NULL\n\t    // && im_get_status()  doesn't work when using SCIM\n\t    && !p_imdisable\n\t    && im_is_preediting())\n    {\n\tint\tcmdpos = 0;\n\tint\tcmdspos;\n\tint\told_row;\n\tint\told_col;\n\tcolnr_T\tcol;\n\n\told_row = msg_row;\n\told_col = msg_col;\n\tcmdspos = ((ccline.cmdfirstc != NUL) ? 1 : 0) + ccline.cmdindent;\n\n\tif (has_mbyte)\n\t{\n\t    for (col = 0; col < preedit_start_col\n\t\t\t  && cmdpos < ccline.cmdlen; ++col)\n\t    {\n\t\tcmdspos += (*mb_ptr2cells)(ccline.cmdbuff + cmdpos);\n\t\tcmdpos  += (*mb_ptr2len)(ccline.cmdbuff + cmdpos);\n\t    }\n\t}\n\telse\n\t{\n\t    cmdspos += preedit_start_col;\n\t    cmdpos  += preedit_start_col;\n\t}\n\n\tmsg_row = cmdline_row + (cmdspos / (int)Columns);\n\tmsg_col = cmdspos % (int)Columns;\n\tif (msg_row >= Rows)\n\t    msg_row = Rows - 1;\n\n\tfor (col = 0; cmdpos < ccline.cmdlen; ++col)\n\t{\n\t    int char_len;\n\t    int char_attr;\n\n\t    char_attr = im_get_feedback_attr(col);\n\t    if (char_attr < 0)\n\t\tbreak; // end of preedit string\n\n\t    if (has_mbyte)\n\t\tchar_len = (*mb_ptr2len)(ccline.cmdbuff + cmdpos);\n\t    else\n\t\tchar_len = 1;\n\n\t    msg_outtrans_len_attr(ccline.cmdbuff + cmdpos, char_len, char_attr);\n\t    cmdpos += char_len;\n\t}\n\n\tmsg_row = old_row;\n\tmsg_col = old_col;\n    }\n}\n#endif // FEAT_XIM && FEAT_GUI_GTK\n\n/*\n * Allocate a new command line buffer.\n * Assigns the new buffer to ccline.cmdbuff and ccline.cmdbufflen.\n */\n    static void\nalloc_cmdbuff(int len)\n{\n    /*\n     * give some extra space to avoid having to allocate all the time\n     */\n    if (len < 80)\n\tlen = 100;\n    else\n\tlen += 20;\n\n    ccline.cmdbuff = alloc(len);    // caller should check for out-of-memory\n    ccline.cmdbufflen = len;\n}\n\n/*\n * Re-allocate the command line to length len + something extra.\n * return FAIL for failure, OK otherwise\n */\n    int\nrealloc_cmdbuff(int len)\n{\n    char_u\t*p;\n\n    if (len < ccline.cmdbufflen)\n\treturn OK;\t\t\t// no need to resize\n\n    p = ccline.cmdbuff;\n    alloc_cmdbuff(len);\t\t\t// will get some more\n    if (ccline.cmdbuff == NULL)\t\t// out of memory\n    {\n\tccline.cmdbuff = p;\t\t// keep the old one\n\treturn FAIL;\n    }\n    // There isn't always a NUL after the command, but it may need to be\n    // there, thus copy up to the NUL and add a NUL.\n    mch_memmove(ccline.cmdbuff, p, (size_t)ccline.cmdlen);\n    ccline.cmdbuff[ccline.cmdlen] = NUL;\n    vim_free(p);\n\n    if (ccline.xpc != NULL\n\t    && ccline.xpc->xp_pattern != NULL\n\t    && ccline.xpc->xp_context != EXPAND_NOTHING\n\t    && ccline.xpc->xp_context != EXPAND_UNSUCCESSFUL)\n    {\n\tint i = (int)(ccline.xpc->xp_pattern - p);\n\n\t// If xp_pattern points inside the old cmdbuff it needs to be adjusted\n\t// to point into the newly allocated memory.\n\tif (i >= 0 && i <= ccline.cmdlen)\n\t    ccline.xpc->xp_pattern = ccline.cmdbuff + i;\n    }\n\n    return OK;\n}\n\n#if defined(FEAT_ARABIC) || defined(PROTO)\nstatic char_u\t*arshape_buf = NULL;\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_arshape_buf(void)\n{\n    vim_free(arshape_buf);\n}\n# endif\n#endif\n\n/*\n * Draw part of the cmdline at the current cursor position.  But draw stars\n * when cmdline_star is TRUE.\n */\n    static void\ndraw_cmdline(int start, int len)\n{\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n    int\t\ti;\n\n    if (cmdline_star > 0)\n\tfor (i = 0; i < len; ++i)\n\t{\n\t    msg_putchar('*');\n\t    if (has_mbyte)\n\t\ti += (*mb_ptr2len)(ccline.cmdbuff + start + i) - 1;\n\t}\n    else\n#endif\n#ifdef FEAT_ARABIC\n\tif (p_arshape && !p_tbidi && cmdline_has_arabic(start, len))\n    {\n\tstatic int\tbuflen = 0;\n\tchar_u\t\t*p;\n\tint\t\tj;\n\tint\t\tnewlen = 0;\n\tint\t\tmb_l;\n\tint\t\tpc, pc1 = 0;\n\tint\t\tprev_c = 0;\n\tint\t\tprev_c1 = 0;\n\tint\t\tu8c;\n\tint\t\tu8cc[MAX_MCO];\n\tint\t\tnc = 0;\n\n\t/*\n\t * Do arabic shaping into a temporary buffer.  This is very\n\t * inefficient!\n\t */\n\tif (len * 2 + 2 > buflen)\n\t{\n\t    // Re-allocate the buffer.  We keep it around to avoid a lot of\n\t    // alloc()/free() calls.\n\t    vim_free(arshape_buf);\n\t    buflen = len * 2 + 2;\n\t    arshape_buf = alloc(buflen);\n\t    if (arshape_buf == NULL)\n\t\treturn;\t// out of memory\n\t}\n\n\tif (utf_iscomposing(utf_ptr2char(ccline.cmdbuff + start)))\n\t{\n\t    // Prepend a space to draw the leading composing char on.\n\t    arshape_buf[0] = ' ';\n\t    newlen = 1;\n\t}\n\n\tfor (j = start; j < start + len; j += mb_l)\n\t{\n\t    p = ccline.cmdbuff + j;\n\t    u8c = utfc_ptr2char_len(p, u8cc, start + len - j);\n\t    mb_l = utfc_ptr2len_len(p, start + len - j);\n\t    if (ARABIC_CHAR(u8c))\n\t    {\n\t\t// Do Arabic shaping.\n\t\tif (cmdmsg_rl)\n\t\t{\n\t\t    // displaying from right to left\n\t\t    pc = prev_c;\n\t\t    pc1 = prev_c1;\n\t\t    prev_c1 = u8cc[0];\n\t\t    if (j + mb_l >= start + len)\n\t\t\tnc = NUL;\n\t\t    else\n\t\t\tnc = utf_ptr2char(p + mb_l);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // displaying from left to right\n\t\t    if (j + mb_l >= start + len)\n\t\t\tpc = NUL;\n\t\t    else\n\t\t    {\n\t\t\tint\tpcc[MAX_MCO];\n\n\t\t\tpc = utfc_ptr2char_len(p + mb_l, pcc,\n\t\t\t\t\t\t      start + len - j - mb_l);\n\t\t\tpc1 = pcc[0];\n\t\t    }\n\t\t    nc = prev_c;\n\t\t}\n\t\tprev_c = u8c;\n\n\t\tu8c = arabic_shape(u8c, NULL, &u8cc[0], pc, pc1, nc);\n\n\t\tnewlen += (*mb_char2bytes)(u8c, arshape_buf + newlen);\n\t\tif (u8cc[0] != 0)\n\t\t{\n\t\t    newlen += (*mb_char2bytes)(u8cc[0], arshape_buf + newlen);\n\t\t    if (u8cc[1] != 0)\n\t\t\tnewlen += (*mb_char2bytes)(u8cc[1],\n\t\t\t\t\t\t\tarshape_buf + newlen);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tprev_c = u8c;\n\t\tmch_memmove(arshape_buf + newlen, p, mb_l);\n\t\tnewlen += mb_l;\n\t    }\n\t}\n\n\tmsg_outtrans_len(arshape_buf, newlen);\n    }\n    else\n#endif\n\tmsg_outtrans_len(ccline.cmdbuff + start, len);\n}\n\n/*\n * Put a character on the command line.  Shifts the following text to the\n * right when \"shift\" is TRUE.  Used for CTRL-V, CTRL-K, etc.\n * \"c\" must be printable (fit in one display cell)!\n */\n    void\nputcmdline(int c, int shift)\n{\n    if (cmd_silent)\n\treturn;\n    msg_no_more = TRUE;\n    msg_putchar(c);\n    if (shift)\n\tdraw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);\n    msg_no_more = FALSE;\n    cursorcmd();\n    extra_char = c;\n    extra_char_shift = shift;\n}\n\n/*\n * Undo a putcmdline(c, FALSE).\n */\n    void\nunputcmdline(void)\n{\n    if (cmd_silent)\n\treturn;\n    msg_no_more = TRUE;\n    if (ccline.cmdlen == ccline.cmdpos)\n\tmsg_putchar(' ');\n    else if (has_mbyte)\n\tdraw_cmdline(ccline.cmdpos,\n\t\t\t       (*mb_ptr2len)(ccline.cmdbuff + ccline.cmdpos));\n    else\n\tdraw_cmdline(ccline.cmdpos, 1);\n    msg_no_more = FALSE;\n    cursorcmd();\n    extra_char = NUL;\n}\n\n/*\n * Put the given string, of the given length, onto the command line.\n * If len is -1, then STRLEN() is used to calculate the length.\n * If 'redraw' is TRUE then the new part of the command line, and the remaining\n * part will be redrawn, otherwise it will not.  If this function is called\n * twice in a row, then 'redraw' should be FALSE and redrawcmd() should be\n * called afterwards.\n */\n    int\nput_on_cmdline(char_u *str, int len, int redraw)\n{\n    int\t\tretval;\n    int\t\ti;\n    int\t\tm;\n    int\t\tc;\n\n    if (len < 0)\n\tlen = (int)STRLEN(str);\n\n    // Check if ccline.cmdbuff needs to be longer\n    if (ccline.cmdlen + len + 1 >= ccline.cmdbufflen)\n\tretval = realloc_cmdbuff(ccline.cmdlen + len + 1);\n    else\n\tretval = OK;\n    if (retval == OK)\n    {\n\tif (!ccline.overstrike)\n\t{\n\t    mch_memmove(ccline.cmdbuff + ccline.cmdpos + len,\n\t\t\t\t\t       ccline.cmdbuff + ccline.cmdpos,\n\t\t\t\t     (size_t)(ccline.cmdlen - ccline.cmdpos));\n\t    ccline.cmdlen += len;\n\t}\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\t// Count nr of characters in the new string.\n\t\tm = 0;\n\t\tfor (i = 0; i < len; i += (*mb_ptr2len)(str + i))\n\t\t    ++m;\n\t\t// Count nr of bytes in cmdline that are overwritten by these\n\t\t// characters.\n\t\tfor (i = ccline.cmdpos; i < ccline.cmdlen && m > 0;\n\t\t\t\t i += (*mb_ptr2len)(ccline.cmdbuff + i))\n\t\t    --m;\n\t\tif (i < ccline.cmdlen)\n\t\t{\n\t\t    mch_memmove(ccline.cmdbuff + ccline.cmdpos + len,\n\t\t\t    ccline.cmdbuff + i, (size_t)(ccline.cmdlen - i));\n\t\t    ccline.cmdlen += ccline.cmdpos + len - i;\n\t\t}\n\t\telse\n\t\t    ccline.cmdlen = ccline.cmdpos + len;\n\t    }\n\t    else if (ccline.cmdpos + len > ccline.cmdlen)\n\t\tccline.cmdlen = ccline.cmdpos + len;\n\t}\n\tmch_memmove(ccline.cmdbuff + ccline.cmdpos, str, (size_t)len);\n\tccline.cmdbuff[ccline.cmdlen] = NUL;\n\n\tif (enc_utf8)\n\t{\n\t    // When the inserted text starts with a composing character,\n\t    // backup to the character before it.  There could be two of them.\n\t    i = 0;\n\t    c = utf_ptr2char(ccline.cmdbuff + ccline.cmdpos);\n\t    while (ccline.cmdpos > 0 && utf_iscomposing(c))\n\t    {\n\t\ti = (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t      ccline.cmdbuff + ccline.cmdpos - 1) + 1;\n\t\tccline.cmdpos -= i;\n\t\tlen += i;\n\t\tc = utf_ptr2char(ccline.cmdbuff + ccline.cmdpos);\n\t    }\n#ifdef FEAT_ARABIC\n\t    if (i == 0 && ccline.cmdpos > 0 && arabic_maycombine(c))\n\t    {\n\t\t// Check the previous character for Arabic combining pair.\n\t\ti = (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t      ccline.cmdbuff + ccline.cmdpos - 1) + 1;\n\t\tif (arabic_combine(utf_ptr2char(ccline.cmdbuff\n\t\t\t\t\t\t     + ccline.cmdpos - i), c))\n\t\t{\n\t\t    ccline.cmdpos -= i;\n\t\t    len += i;\n\t\t}\n\t\telse\n\t\t    i = 0;\n\t    }\n#endif\n\t    if (i != 0)\n\t    {\n\t\t// Also backup the cursor position.\n\t\ti = ptr2cells(ccline.cmdbuff + ccline.cmdpos);\n\t\tccline.cmdspos -= i;\n\t\tmsg_col -= i;\n\t\tif (msg_col < 0)\n\t\t{\n\t\t    msg_col += Columns;\n\t\t    --msg_row;\n\t\t}\n\t    }\n\t}\n\n\tif (redraw && !cmd_silent)\n\t{\n\t    msg_no_more = TRUE;\n\t    i = cmdline_row;\n\t    cursorcmd();\n\t    draw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);\n\t    // Avoid clearing the rest of the line too often.\n\t    if (cmdline_row != i || ccline.overstrike)\n\t\tmsg_clr_eos();\n\t    msg_no_more = FALSE;\n\t}\n\tif (KeyTyped)\n\t{\n\t    m = Columns * Rows;\n\t    if (m < 0)\t// overflow, Columns or Rows at weird value\n\t\tm = MAXCOL;\n\t}\n\telse\n\t    m = MAXCOL;\n\tfor (i = 0; i < len; ++i)\n\t{\n\t    c = cmdline_charsize(ccline.cmdpos);\n\t    // count \">\" for a double-wide char that doesn't fit.\n\t    if (has_mbyte)\n\t\tcorrect_cmdspos(ccline.cmdpos, c);\n\t    // Stop cursor at the end of the screen, but do increment the\n\t    // insert position, so that entering a very long command\n\t    // works, even though you can't see it.\n\t    if (ccline.cmdspos + c < m)\n\t\tccline.cmdspos += c;\n\n\t    if (has_mbyte)\n\t    {\n\t\tc = (*mb_ptr2len)(ccline.cmdbuff + ccline.cmdpos) - 1;\n\t\tif (c > len - i - 1)\n\t\t    c = len - i - 1;\n\t\tccline.cmdpos += c;\n\t\ti += c;\n\t    }\n\t    ++ccline.cmdpos;\n\t}\n    }\n    if (redraw)\n\tmsg_check();\n    return retval;\n}\n\nstatic cmdline_info_T\tprev_ccline;\nstatic int\t\tprev_ccline_used = FALSE;\n\n/*\n * Save ccline, because obtaining the \"=\" register may execute \"normal :cmd\"\n * and overwrite it.  But get_cmdline_str() may need it, thus make it\n * available globally in prev_ccline.\n */\n    static void\nsave_cmdline(cmdline_info_T *ccp)\n{\n    if (!prev_ccline_used)\n    {\n\tCLEAR_FIELD(prev_ccline);\n\tprev_ccline_used = TRUE;\n    }\n    *ccp = prev_ccline;\n    prev_ccline = ccline;\n    ccline.cmdbuff = NULL;  // signal that ccline is not in use\n}\n\n/*\n * Restore ccline after it has been saved with save_cmdline().\n */\n    static void\nrestore_cmdline(cmdline_info_T *ccp)\n{\n    ccline = prev_ccline;\n    prev_ccline = *ccp;\n}\n\n/*\n * Paste a yank register into the command line.\n * Used by CTRL-R command in command-line mode.\n * insert_reg() can't be used here, because special characters from the\n * register contents will be interpreted as commands.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    static int\ncmdline_paste(\n    int regname,\n    int literally,\t// Insert text literally instead of \"as typed\"\n    int remcr)\t\t// remove trailing CR\n{\n    long\t\ti;\n    char_u\t\t*arg;\n    char_u\t\t*p;\n    int\t\t\tallocated;\n\n    // check for valid regname; also accept special characters for CTRL-R in\n    // the command line\n    if (regname != Ctrl_F && regname != Ctrl_P && regname != Ctrl_W\n\t    && regname != Ctrl_A && regname != Ctrl_L\n\t    && !valid_yank_reg(regname, FALSE))\n\treturn FAIL;\n\n    // A register containing CTRL-R can cause an endless loop.  Allow using\n    // CTRL-C to break the loop.\n    line_breakcheck();\n    if (got_int)\n\treturn FAIL;\n\n#ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n#endif\n\n    // Need to set \"textlock\" to avoid nasty things like going to another\n    // buffer when evaluating an expression.\n    ++textlock;\n    i = get_spec_reg(regname, &arg, &allocated, TRUE);\n    --textlock;\n\n    if (i)\n    {\n\t// Got the value of a special register in \"arg\".\n\tif (arg == NULL)\n\t    return FAIL;\n\n\t// When 'incsearch' is set and CTRL-R CTRL-W used: skip the duplicate\n\t// part of the word.\n\tp = arg;\n\tif (p_is && regname == Ctrl_W)\n\t{\n\t    char_u  *w;\n\t    int\t    len;\n\n\t    // Locate start of last word in the cmd buffer.\n\t    for (w = ccline.cmdbuff + ccline.cmdpos; w > ccline.cmdbuff; )\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    len = (*mb_head_off)(ccline.cmdbuff, w - 1) + 1;\n\t\t    if (!vim_iswordc(mb_ptr2char(w - len)))\n\t\t\tbreak;\n\t\t    w -= len;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (!vim_iswordc(w[-1]))\n\t\t\tbreak;\n\t\t    --w;\n\t\t}\n\t    }\n\t    len = (int)((ccline.cmdbuff + ccline.cmdpos) - w);\n\t    if (p_ic ? STRNICMP(w, arg, len) == 0 : STRNCMP(w, arg, len) == 0)\n\t\tp += len;\n\t}\n\n\tcmdline_paste_str(p, literally);\n\tif (allocated)\n\t    vim_free(arg);\n\treturn OK;\n    }\n\n    return cmdline_paste_reg(regname, literally, remcr);\n}\n\n/*\n * Put a string on the command line.\n * When \"literally\" is TRUE, insert literally.\n * When \"literally\" is FALSE, insert as typed, but don't leave the command\n * line.\n */\n    void\ncmdline_paste_str(char_u *s, int literally)\n{\n    int\t\tc, cv;\n\n    if (literally)\n\tput_on_cmdline(s, -1, TRUE);\n    else\n\twhile (*s != NUL)\n\t{\n\t    cv = *s;\n\t    if (cv == Ctrl_V && s[1])\n\t\t++s;\n\t    if (has_mbyte)\n\t\tc = mb_cptr2char_adv(&s);\n\t    else\n\t\tc = *s++;\n\t    if (cv == Ctrl_V || c == ESC || c == Ctrl_C\n\t\t    || c == CAR || c == NL || c == Ctrl_L\n#ifdef UNIX\n\t\t    || c == intr_char\n#endif\n\t\t    || (c == Ctrl_BSL && *s == Ctrl_N))\n\t\tstuffcharReadbuff(Ctrl_V);\n\t    stuffcharReadbuff(c);\n\t}\n}\n\n/*\n * This function is called when the screen size changes and with incremental\n * search and in other situations where the command line may have been\n * overwritten.\n */\n    void\nredrawcmdline(void)\n{\n    redrawcmdline_ex(TRUE);\n}\n\n/*\n * When \"do_compute_cmdrow\" is TRUE the command line is redrawn at the bottom.\n * If FALSE cmdline_row is used, which should redraw in the same place.\n */\n    void\nredrawcmdline_ex(int do_compute_cmdrow)\n{\n    if (cmd_silent)\n\treturn;\n    need_wait_return = FALSE;\n    if (do_compute_cmdrow)\n\tcompute_cmdrow();\n    redrawcmd();\n    cursorcmd();\n}\n\n    static void\nredrawcmdprompt(void)\n{\n    int\t\ti;\n\n    if (cmd_silent)\n\treturn;\n    if (ccline.cmdfirstc != NUL)\n\tmsg_putchar(ccline.cmdfirstc);\n    if (ccline.cmdprompt != NULL)\n    {\n\tmsg_puts_attr((char *)ccline.cmdprompt, ccline.cmdattr);\n\tccline.cmdindent = msg_col + (msg_row - cmdline_row) * Columns;\n\t// do the reverse of set_cmdspos()\n\tif (ccline.cmdfirstc != NUL)\n\t    --ccline.cmdindent;\n    }\n    else\n\tfor (i = ccline.cmdindent; i > 0; --i)\n\t    msg_putchar(' ');\n}\n\n/*\n * Redraw what is currently on the command line.\n */\n    void\nredrawcmd(void)\n{\n    int save_in_echowindow = in_echowindow;\n\n    if (cmd_silent)\n\treturn;\n\n    // when 'incsearch' is set there may be no command line while redrawing\n    if (ccline.cmdbuff == NULL)\n    {\n\twindgoto(cmdline_row, 0);\n\tmsg_clr_eos();\n\treturn;\n    }\n\n    // Do not put this in the message window.\n    in_echowindow = FALSE;\n\n    sb_text_restart_cmdline();\n    msg_start();\n    redrawcmdprompt();\n\n    // Don't use more prompt, truncate the cmdline if it doesn't fit.\n    msg_no_more = TRUE;\n    draw_cmdline(0, ccline.cmdlen);\n    msg_clr_eos();\n    msg_no_more = FALSE;\n\n    set_cmdspos_cursor();\n    if (extra_char != NUL)\n\tputcmdline(extra_char, extra_char_shift);\n\n    /*\n     * An emsg() before may have set msg_scroll. This is used in normal mode,\n     * in cmdline mode we can reset them now.\n     */\n    msg_scroll = FALSE;\t\t// next message overwrites cmdline\n\n    // Typing ':' at the more prompt may set skip_redraw.  We don't want this\n    // in cmdline mode\n    skip_redraw = FALSE;\n\n    in_echowindow = save_in_echowindow;\n}\n\n    void\ncompute_cmdrow(void)\n{\n    // ignore \"msg_scrolled\" in update_screen(), it will be reset soon.\n    if (exmode_active || (msg_scrolled != 0 && !updating_screen))\n\tcmdline_row = Rows - 1;\n    else\n\tcmdline_row = W_WINROW(lastwin) + lastwin->w_height\n\t\t\t\t\t\t    + lastwin->w_status_height;\n}\n\n    void\ncursorcmd(void)\n{\n    if (cmd_silent)\n\treturn;\n\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n    {\n\tmsg_row = cmdline_row  + (ccline.cmdspos / (int)(Columns - 1));\n\tmsg_col = (int)Columns - (ccline.cmdspos % (int)(Columns - 1)) - 1;\n\tif (msg_row <= 0)\n\t    msg_row = Rows - 1;\n    }\n    else\n#endif\n    {\n\tmsg_row = cmdline_row + (ccline.cmdspos / (int)Columns);\n\tmsg_col = ccline.cmdspos % (int)Columns;\n\tif (msg_row >= Rows)\n\t    msg_row = Rows - 1;\n    }\n\n    windgoto(msg_row, msg_col);\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    if (p_imst == IM_ON_THE_SPOT)\n\tredrawcmd_preedit();\n#endif\n#ifdef MCH_CURSOR_SHAPE\n    mch_update_cursor();\n#endif\n}\n\n    void\ngotocmdline(int clr)\n{\n    msg_start();\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n\tmsg_col = Columns - 1;\n    else\n#endif\n\tmsg_col = 0;\t    // always start in column 0\n    if (clr)\t\t    // clear the bottom line(s)\n\tmsg_clr_eos();\t    // will reset clear_cmdline\n    windgoto(cmdline_row, 0);\n}\n\n/*\n * Check the word in front of the cursor for an abbreviation.\n * Called when the non-id character \"c\" has been entered.\n * When an abbreviation is recognized it is removed from the text with\n * backspaces and the replacement string is inserted, followed by \"c\".\n */\n    static int\nccheck_abbr(int c)\n{\n    int spos = 0;\n\n    if (p_paste || no_abbr)\t    // no abbreviations or in paste mode\n\treturn FALSE;\n\n    // Do not consider '<,'> be part of the mapping, skip leading whitespace.\n    // Actually accepts any mark.\n    while (VIM_ISWHITE(ccline.cmdbuff[spos]) && spos < ccline.cmdlen)\n\tspos++;\n    if (ccline.cmdlen - spos > 5\n\t    && ccline.cmdbuff[spos] == '\\''\n\t    && ccline.cmdbuff[spos + 2] == ','\n\t    && ccline.cmdbuff[spos + 3] == '\\'')\n\tspos += 5;\n    else\n\t// check abbreviation from the beginning of the commandline\n\tspos = 0;\n\n    return check_abbr(c, ccline.cmdbuff, ccline.cmdpos, spos);\n}\n\n/*\n * Escape special characters in \"fname\", depending on \"what\":\n * VSE_NONE: for when used as a file name argument after a Vim command.\n * VSE_SHELL: for a shell command.\n * VSE_BUFFER: for the \":buffer\" command.\n * Returns the result in allocated memory.\n */\n    char_u *\nvim_strsave_fnameescape(char_u *fname, int what)\n{\n    char_u\t*p;\n#ifdef BACKSLASH_IN_FILENAME\n    char_u\tbuf[20];\n    int\t\tj = 0;\n\n    // Don't escape '[', '{' and '!' if they are in 'isfname' and for the\n    // \":buffer\" command.\n    for (p = what == VSE_BUFFER ? BUFFER_ESC_CHARS : PATH_ESC_CHARS;\n\t\t\t\t\t\t\t\t*p != NUL; ++p)\n\tif ((*p != '[' && *p != '{' && *p != '!') || !vim_isfilec(*p))\n\t    buf[j++] = *p;\n    buf[j] = NUL;\n    p = vim_strsave_escaped(fname, buf);\n#else\n    p = vim_strsave_escaped(fname, what == VSE_SHELL ? SHELL_ESC_CHARS\n\t\t    : what == VSE_BUFFER ? BUFFER_ESC_CHARS : PATH_ESC_CHARS);\n    if (what == VSE_SHELL && csh_like_shell() && p != NULL)\n    {\n\tchar_u\t    *s;\n\n\t// For csh and similar shells need to put two backslashes before '!'.\n\t// One is taken by Vim, one by the shell.\n\ts = vim_strsave_escaped(p, (char_u *)\"!\");\n\tvim_free(p);\n\tp = s;\n    }\n#endif\n\n    // '>' and '+' are special at the start of some commands, e.g. \":edit\" and\n    // \":write\".  \"cd -\" has a special meaning.\n    if (p != NULL && (*p == '>' || *p == '+' || (*p == '-' && p[1] == NUL)))\n\tescape_fname(&p);\n\n    return p;\n}\n\n/*\n * Put a backslash before the file name in \"pp\", which is in allocated memory.\n */\n    void\nescape_fname(char_u **pp)\n{\n    char_u\t*p;\n\n    p = alloc(STRLEN(*pp) + 2);\n    if (p != NULL)\n    {\n\tp[0] = '\\\\';\n\tSTRCPY(p + 1, *pp);\n\tvim_free(*pp);\n\t*pp = p;\n    }\n}\n\n/*\n * For each file name in files[num_files]:\n * If 'orig_pat' starts with \"~/\", replace the home directory with \"~\".\n */\n    void\ntilde_replace(\n    char_u  *orig_pat,\n    int\t    num_files,\n    char_u  **files)\n{\n    int\t    i;\n    char_u  *p;\n\n    if (orig_pat[0] == '~' && vim_ispathsep(orig_pat[1]))\n    {\n\tfor (i = 0; i < num_files; ++i)\n\t{\n\t    p = home_replace_save(NULL, files[i]);\n\t    if (p != NULL)\n\t    {\n\t\tvim_free(files[i]);\n\t\tfiles[i] = p;\n\t    }\n\t}\n    }\n}\n\n/*\n * Get a pointer to the current command line info.\n */\n    cmdline_info_T *\nget_cmdline_info(void)\n{\n    return &ccline;\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_CMDWIN) || defined(PROTO)\n/*\n * Get pointer to the command line info to use. save_cmdline() may clear\n * ccline and put the previous value in prev_ccline.\n */\n    static cmdline_info_T *\nget_ccline_ptr(void)\n{\n    if ((State & MODE_CMDLINE) == 0)\n\treturn NULL;\n    if (ccline.cmdbuff != NULL)\n\treturn &ccline;\n    if (prev_ccline_used && prev_ccline.cmdbuff != NULL)\n\treturn &prev_ccline;\n    return NULL;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(FEAT_CMDWIN)\n/*\n * Get the current command-line type.\n * Returns ':' or '/' or '?' or '@' or '>' or '-'\n * Only works when the command line is being edited.\n * Returns NUL when something is wrong.\n */\n    static int\nget_cmdline_type(void)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    if (p == NULL)\n\treturn NUL;\n    if (p->cmdfirstc == NUL)\n\treturn\n# ifdef FEAT_EVAL\n\t    (p->input_fn) ? '@' :\n# endif\n\t    '-';\n    return p->cmdfirstc;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Get the current command line in allocated memory.\n * Only works when the command line is being edited.\n * Returns NULL when something is wrong.\n */\n    static char_u *\nget_cmdline_str(void)\n{\n    cmdline_info_T *p;\n\n    if (cmdline_star > 0)\n\treturn NULL;\n    p = get_ccline_ptr();\n    if (p == NULL)\n\treturn NULL;\n    return vim_strnsave(p->cmdbuff, p->cmdlen);\n}\n\n/*\n * Get the current command-line completion type.\n */\n    static char_u *\nget_cmdline_completion(void)\n{\n    cmdline_info_T *p;\n\n    if (cmdline_star > 0)\n\treturn NULL;\n\n    p = get_ccline_ptr();\n    if (p != NULL && p->xpc != NULL)\n    {\n\tchar_u *cmd_compl;\n\n\tset_expand_context(p->xpc);\n\n\tcmd_compl = cmdcomplete_type_to_str(p->xpc->xp_context);\n\tif (cmd_compl != NULL)\n\t    return vim_strsave(cmd_compl);\n    }\n\n    return NULL;\n}\n\n/*\n * \"getcmdcompltype()\" function\n */\n    void\nf_getcmdcompltype(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = get_cmdline_completion();\n}\n\n/*\n * \"getcmdline()\" function\n */\n    void\nf_getcmdline(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = get_cmdline_str();\n}\n\n/*\n * \"getcmdpos()\" function\n */\n    void\nf_getcmdpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    rettv->vval.v_number = p != NULL ? p->cmdpos + 1 : 0;\n}\n\n/*\n * \"getcmdscreenpos()\" function\n */\n    void\nf_getcmdscreenpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    rettv->vval.v_number = p != NULL ? p->cmdspos + 1 : 0;\n}\n\n/*\n * \"getcmdtype()\" function\n */\n    void\nf_getcmdtype(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = alloc(2);\n    if (rettv->vval.v_string != NULL)\n    {\n\trettv->vval.v_string[0] = get_cmdline_type();\n\trettv->vval.v_string[1] = NUL;\n    }\n}\n\n// Set the command line str to \"str\".\n// Returns 1 when failed, 0 when OK.\n    static int\nset_cmdline_str(char_u *str, int pos)\n{\n    cmdline_info_T  *p = get_ccline_ptr();\n    int\t\t    len;\n\n    if (p == NULL)\n\treturn 1;\n\n    len = (int)STRLEN(str);\n    realloc_cmdbuff(len + 1);\n    p->cmdlen = len;\n    STRCPY(p->cmdbuff, str);\n\n    p->cmdpos = pos < 0 || pos > p->cmdlen ? p->cmdlen : pos;\n    new_cmdpos = p->cmdpos;\n\n    redrawcmd();\n\n    // Trigger CmdlineChanged autocommands.\n    trigger_cmd_autocmd(get_cmdline_type(), EVENT_CMDLINECHANGED);\n\n    return 0;\n}\n\n/*\n * Set the command line byte position to \"pos\".  Zero is the first position.\n * Only works when the command line is being edited.\n * Returns 1 when failed, 0 when OK.\n */\n    static int\nset_cmdline_pos(\n    int\t\tpos)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    if (p == NULL)\n\treturn 1;\n\n    // The position is not set directly but after CTRL-\\ e or CTRL-R = has\n    // changed the command line.\n    if (pos < 0)\n\tnew_cmdpos = 0;\n    else\n\tnew_cmdpos = pos;\n    return 0;\n}\n\n// \"setcmdline()\" function\n    void\nf_setcmdline(typval_T *argvars, typval_T *rettv)\n{\n    int pos = -1;\n\n    if (check_for_string_arg(argvars, 0) == FAIL\n\t    || check_for_opt_number_arg(argvars, 1) == FAIL)\n\treturn;\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tint error = FALSE;\n\n\tpos = (int)tv_get_number_chk(&argvars[1], &error) - 1;\n\tif (error)\n\t    return;\n\tif (pos < 0)\n\t{\n\t    emsg(_(e_argument_must_be_positive));\n\t    return;\n\t}\n    }\n\n    rettv->vval.v_number = set_cmdline_str(argvars[0].vval.v_string, pos);\n}\n\n/*\n * \"setcmdpos()\" function\n */\n    void\nf_setcmdpos(typval_T *argvars, typval_T *rettv)\n{\n    int\t\tpos;\n\n    if (in_vim9script() && check_for_number_arg(argvars, 0) == FAIL)\n\treturn;\n\n    pos = (int)tv_get_number(&argvars[0]) - 1;\n    if (pos >= 0)\n\trettv->vval.v_number = set_cmdline_pos(pos);\n}\n#endif\n\n/*\n * Return the first character of the current command line.\n */\n    int\nget_cmdline_firstc(void)\n{\n    return ccline.cmdfirstc;\n}\n\n/*\n * Get indices \"num1,num2\" that specify a range within a list (not a range of\n * text lines in a buffer!) from a string.  Used for \":history\" and \":clist\".\n * Returns OK if parsed successfully, otherwise FAIL.\n */\n    int\nget_list_range(char_u **str, int *num1, int *num2)\n{\n    int\t\tlen;\n    int\t\tfirst = FALSE;\n    varnumber_T\tnum;\n\n    *str = skipwhite(*str);\n    if (**str == '-' || vim_isdigit(**str))  // parse \"from\" part of range\n    {\n\tvim_str2nr(*str, NULL, &len, 0, &num, NULL, 0, FALSE);\n\t*str += len;\n\t*num1 = (int)num;\n\tfirst = TRUE;\n    }\n    *str = skipwhite(*str);\n    if (**str == ',')\t\t\t// parse \"to\" part of range\n    {\n\t*str = skipwhite(*str + 1);\n\tvim_str2nr(*str, NULL, &len, 0, &num, NULL, 0, FALSE);\n\tif (len > 0)\n\t{\n\t    *num2 = (int)num;\n\t    *str = skipwhite(*str + len);\n\t}\n\telse if (!first)\t\t// no number given at all\n\t    return FAIL;\n    }\n    else if (first)\t\t\t// only one number given\n\t*num2 = *num1;\n    return OK;\n}\n\n#if defined(FEAT_CMDWIN) || defined(PROTO)\n/*\n * Check value of 'cedit' and set cedit_key.\n * Returns NULL if value is OK, error message otherwise.\n */\n    char *\ncheck_cedit(void)\n{\n    int n;\n\n    if (*p_cedit == NUL)\n\tcedit_key = -1;\n    else\n    {\n\tn = string_to_key(p_cedit, FALSE);\n\tif (vim_isprintc(n))\n\t    return e_invalid_argument;\n\tcedit_key = n;\n    }\n    return NULL;\n}\n\n/*\n * Open a window on the current command line and history.  Allow editing in\n * the window.  Returns when the window is closed.\n * Returns:\n *\tCR\t if the command is to be executed\n *\tCtrl_C\t if it is to be abandoned\n *\tK_IGNORE if editing continues\n */\n    static int\nopen_cmdwin(void)\n{\n    bufref_T\t\told_curbuf;\n    win_T\t\t*old_curwin = curwin;\n    bufref_T\t\tbufref;\n    win_T\t\t*wp;\n    int\t\t\ti;\n    linenr_T\t\tlnum;\n    int\t\t\thisttype;\n    garray_T\t\twinsizes;\n    int\t\t\tsave_restart_edit = restart_edit;\n    int\t\t\tsave_State = State;\n    int\t\t\tsave_exmode = exmode_active;\n#ifdef FEAT_RIGHTLEFT\n    int\t\t\tsave_cmdmsg_rl = cmdmsg_rl;\n#endif\n#ifdef FEAT_FOLDING\n    int\t\t\tsave_KeyTyped;\n#endif\n\n    // Can't do this when text or buffer is locked.\n    // Can't do this recursively.  Can't do it when typing a password.\n    if (text_or_buf_locked()\n\t    || cmdwin_type != 0\n# if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n\t    || cmdline_star > 0\n# endif\n\t    )\n    {\n\tbeep_flush();\n\treturn K_IGNORE;\n    }\n    set_bufref(&old_curbuf, curbuf);\n\n    // Save current window sizes.\n    win_size_save(&winsizes);\n\n    // When using completion in Insert mode with <C-R>=<C-F> one can open the\n    // command line window, but we don't want the popup menu then.\n    pum_undisplay();\n\n    // don't use a new tab page\n    cmdmod.cmod_tab = 0;\n    cmdmod.cmod_flags |= CMOD_NOSWAPFILE;\n\n    // Create a window for the command-line buffer.\n    if (win_split((int)p_cwh, WSP_BOT) == FAIL)\n    {\n\tbeep_flush();\n\tga_clear(&winsizes);\n\treturn K_IGNORE;\n    }\n    // Don't let quitting the More prompt make this fail.\n    got_int = FALSE;\n\n    // Set \"cmdwin_type\" before any autocommands may mess things up.\n    cmdwin_type = get_cmdline_type();\n\n    // Create the command-line buffer empty.\n    if (do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL) == FAIL)\n    {\n\t// Some autocommand messed it up?\n\twin_close(curwin, TRUE);\n\tga_clear(&winsizes);\n\tcmdwin_type = 0;\n\treturn Ctrl_C;\n    }\n\n    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);\n    (void)setfname(curbuf, (char_u *)_(\"[Command Line]\"), NULL, TRUE);\n    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);\n    set_option_value_give_err((char_u *)\"bt\",\n\t\t\t\t\t    0L, (char_u *)\"nofile\", OPT_LOCAL);\n    curbuf->b_p_ma = TRUE;\n#ifdef FEAT_FOLDING\n    curwin->w_p_fen = FALSE;\n#endif\n# ifdef FEAT_RIGHTLEFT\n    curwin->w_p_rl = cmdmsg_rl;\n    cmdmsg_rl = FALSE;\n# endif\n    RESET_BINDING(curwin);\n\n    // Don't allow switching to another buffer.\n    ++curbuf_lock;\n\n    // Showing the prompt may have set need_wait_return, reset it.\n    need_wait_return = FALSE;\n\n    histtype = hist_char2type(cmdwin_type);\n    if (histtype == HIST_CMD || histtype == HIST_DEBUG)\n    {\n\tif (p_wc == TAB)\n\t{\n\t    add_map((char_u *)\"<buffer> <Tab> <C-X><C-V>\", MODE_INSERT, TRUE);\n\t    add_map((char_u *)\"<buffer> <Tab> a<C-X><C-V>\", MODE_NORMAL, TRUE);\n\t}\n\tset_option_value_give_err((char_u *)\"ft\",\n\t\t\t\t\t       0L, (char_u *)\"vim\", OPT_LOCAL);\n    }\n    --curbuf_lock;\n\n    // Reset 'textwidth' after setting 'filetype' (the Vim filetype plugin\n    // sets 'textwidth' to 78).\n    curbuf->b_p_tw = 0;\n\n    // Fill the buffer with the history.\n    init_history();\n    if (get_hislen() > 0)\n    {\n\ti = *get_hisidx(histtype);\n\tif (i >= 0)\n\t{\n\t    lnum = 0;\n\t    do\n\t    {\n\t\tif (++i == get_hislen())\n\t\t    i = 0;\n\t\tif (get_histentry(histtype)[i].hisstr != NULL)\n\t\t    ml_append(lnum++, get_histentry(histtype)[i].hisstr,\n\t\t\t\t\t\t\t   (colnr_T)0, FALSE);\n\t    }\n\t    while (i != *get_hisidx(histtype));\n\t}\n    }\n\n    // Replace the empty last line with the current command-line and put the\n    // cursor there.\n    ml_replace(curbuf->b_ml.ml_line_count, ccline.cmdbuff, TRUE);\n    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor.col = ccline.cmdpos;\n    changed_line_abv_curs();\n    invalidate_botline();\n    redraw_later(UPD_SOME_VALID);\n\n    // No Ex mode here!\n    exmode_active = 0;\n\n    State = MODE_NORMAL;\n    setmouse();\n\n    // Reset here so it can be set by a CmdWinEnter autocommand.\n    cmdwin_result = 0;\n\n    // Trigger CmdwinEnter autocommands.\n    trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINENTER);\n    if (restart_edit != 0)\t// autocmd with \":startinsert\"\n\tstuffcharReadbuff(K_NOP);\n\n    i = RedrawingDisabled;\n    RedrawingDisabled = 0;\n\n    /*\n     * Call the main loop until <CR> or CTRL-C is typed.\n     */\n    main_loop(TRUE, FALSE);\n\n    RedrawingDisabled = i;\n\n# ifdef FEAT_FOLDING\n    save_KeyTyped = KeyTyped;\n# endif\n\n    // Trigger CmdwinLeave autocommands.\n    trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINLEAVE);\n\n# ifdef FEAT_FOLDING\n    // Restore KeyTyped in case it is modified by autocommands\n    KeyTyped = save_KeyTyped;\n# endif\n\n    cmdwin_type = 0;\n    exmode_active = save_exmode;\n\n    // Safety check: The old window or buffer was deleted: It's a bug when\n    // this happens!\n    if (!win_valid(old_curwin) || !bufref_valid(&old_curbuf))\n    {\n\tcmdwin_result = Ctrl_C;\n\temsg(_(e_active_window_or_buffer_deleted));\n    }\n    else\n    {\n# if defined(FEAT_EVAL)\n\t// autocmds may abort script processing\n\tif (aborting() && cmdwin_result != K_IGNORE)\n\t    cmdwin_result = Ctrl_C;\n# endif\n\t// Set the new command line from the cmdline buffer.\n\tvim_free(ccline.cmdbuff);\n\tif (cmdwin_result == K_XF1 || cmdwin_result == K_XF2) // :qa[!] typed\n\t{\n\t    char *p = (cmdwin_result == K_XF2) ? \"qa\" : \"qa!\";\n\n\t    if (histtype == HIST_CMD)\n\t    {\n\t\t// Execute the command directly.\n\t\tccline.cmdbuff = vim_strsave((char_u *)p);\n\t\tcmdwin_result = CAR;\n\t    }\n\t    else\n\t    {\n\t\t// First need to cancel what we were doing.\n\t\tccline.cmdbuff = NULL;\n\t\tstuffcharReadbuff(':');\n\t\tstuffReadbuff((char_u *)p);\n\t\tstuffcharReadbuff(CAR);\n\t    }\n\t}\n\telse if (cmdwin_result == K_XF2)\t// :qa typed\n\t{\n\t    ccline.cmdbuff = vim_strsave((char_u *)\"qa\");\n\t    cmdwin_result = CAR;\n\t}\n\telse if (cmdwin_result == Ctrl_C)\n\t{\n\t    // :q or :close, don't execute any command\n\t    // and don't modify the cmd window.\n\t    ccline.cmdbuff = NULL;\n\t}\n\telse\n\t    ccline.cmdbuff = vim_strsave(ml_get_curline());\n\tif (ccline.cmdbuff == NULL)\n\t{\n\t    ccline.cmdbuff = vim_strsave((char_u *)\"\");\n\t    ccline.cmdlen = 0;\n\t    ccline.cmdbufflen = 1;\n\t    ccline.cmdpos = 0;\n\t    cmdwin_result = Ctrl_C;\n\t}\n\telse\n\t{\n\t    ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);\n\t    ccline.cmdbufflen = ccline.cmdlen + 1;\n\t    ccline.cmdpos = curwin->w_cursor.col;\n\t    if (ccline.cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    if (cmdwin_result == K_IGNORE)\n\t    {\n\t\tset_cmdspos_cursor();\n\t\tredrawcmd();\n\t    }\n\t}\n\n# ifdef FEAT_CONCEAL\n\t// Avoid command-line window first character being concealed.\n\tcurwin->w_p_cole = 0;\n# endif\n\t// First go back to the original window.\n\twp = curwin;\n\tset_bufref(&bufref, curbuf);\n\n\tskip_win_fix_cursor = TRUE;\n\twin_goto(old_curwin);\n\n\t// win_goto() may trigger an autocommand that already closes the\n\t// cmdline window.\n\tif (win_valid(wp) && wp != curwin)\n\t    win_close(wp, TRUE);\n\n\t// win_close() may have already wiped the buffer when 'bh' is\n\t// set to 'wipe', autocommands may have closed other windows\n\tif (bufref_valid(&bufref) && bufref.br_buf != curbuf)\n\t    close_buffer(NULL, bufref.br_buf, DOBUF_WIPE, FALSE, FALSE);\n\n\t// Restore window sizes.\n\twin_size_restore(&winsizes);\n\tskip_win_fix_cursor = FALSE;\n    }\n\n    ga_clear(&winsizes);\n    restart_edit = save_restart_edit;\n# ifdef FEAT_RIGHTLEFT\n    cmdmsg_rl = save_cmdmsg_rl;\n# endif\n\n    State = save_State;\n    may_trigger_modechanged();\n    setmouse();\n\n    return cmdwin_result;\n}\n\n/*\n * Return TRUE if in the cmdwin, not editing the command line.\n */\n    int\nis_in_cmdwin(void)\n{\n    return cmdwin_type != 0 && get_cmdline_type() == NUL;\n}\n#endif // FEAT_CMDWIN\n\n/*\n * Used for commands that either take a simple command string argument, or:\n *\tcmd << endmarker\n *\t  {script}\n *\tendmarker\n * Returns a pointer to allocated memory with {script} or NULL.\n */\n    char_u *\nscript_get(exarg_T *eap UNUSED, char_u *cmd UNUSED)\n{\n#ifdef FEAT_EVAL\n    list_T\t*l;\n    listitem_T\t*li;\n    char_u\t*s;\n    garray_T\tga;\n\n    if (cmd[0] != '<' || cmd[1] != '<' || eap->getline == NULL)\n\treturn NULL;\n    cmd += 2;\n\n    l = heredoc_get(eap, cmd, TRUE, FALSE);\n    if (l == NULL)\n\treturn NULL;\n\n    ga_init2(&ga, 1, 0x400);\n\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\ts = tv_get_string(&li->li_tv);\n\tga_concat(&ga, s);\n\tga_append(&ga, '\\n');\n    }\n    ga_append(&ga, NUL);\n\n    list_free(l);\n    return (char_u *)ga.ga_data;\n#else\n    return NULL;\n#endif\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * This function is used by f_input() and f_inputdialog() functions. The third\n * argument to f_input() specifies the type of completion to use at the\n * prompt. The third argument to f_inputdialog() specifies the value to return\n * when the user cancels the prompt.\n */\n    void\nget_user_input(\n    typval_T\t*argvars,\n    typval_T\t*rettv,\n    int\t\tinputdialog,\n    int\t\tsecret)\n{\n    char_u\t*prompt;\n    char_u\t*p = NULL;\n    int\t\tc;\n    char_u\tbuf[NUMBUFLEN];\n    int\t\tcmd_silent_save = cmd_silent;\n    char_u\t*defstr = (char_u *)\"\";\n    int\t\txp_type = EXPAND_NOTHING;\n    char_u\t*xp_arg = NULL;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n    if (input_busy)\n\treturn;  // this doesn't work recursively.\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_string_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    prompt = tv_get_string_chk(&argvars[0]);\n\n#ifdef NO_CONSOLE_INPUT\n    // While starting up, there is no place to enter text. When running tests\n    // with --not-a-term we assume feedkeys() will be used.\n    if (no_console_input() && !is_not_a_term())\n\treturn;\n#endif\n\n    cmd_silent = FALSE;\t\t// Want to see the prompt.\n    if (prompt != NULL)\n    {\n\t// Only the part of the message after the last NL is considered as\n\t// prompt for the command line\n\tp = vim_strrchr(prompt, '\\n');\n\tif (p == NULL)\n\t    p = prompt;\n\telse\n\t{\n\t    ++p;\n\t    c = *p;\n\t    *p = NUL;\n\t    msg_start();\n\t    msg_clr_eos();\n\t    msg_puts_attr((char *)prompt, get_echo_attr());\n\t    msg_didout = FALSE;\n\t    msg_starthere();\n\t    *p = c;\n\t}\n\tcmdline_row = msg_row;\n\n\tif (argvars[1].v_type != VAR_UNKNOWN)\n\t{\n\t    defstr = tv_get_string_buf_chk(&argvars[1], buf);\n\t    if (defstr != NULL)\n\t\tstuffReadbuffSpec(defstr);\n\n\t    if (!inputdialog && argvars[2].v_type != VAR_UNKNOWN)\n\t    {\n\t\tchar_u\t*xp_name;\n\t\tint\txp_namelen;\n\t\tlong\targt = 0;\n\n\t\t// input() with a third argument: completion\n\t\trettv->vval.v_string = NULL;\n\n\t\txp_name = tv_get_string_buf_chk(&argvars[2], buf);\n\t\tif (xp_name == NULL)\n\t\t    return;\n\n\t\txp_namelen = (int)STRLEN(xp_name);\n\n\t\tif (parse_compl_arg(xp_name, xp_namelen, &xp_type, &argt,\n\t\t\t\t\t\t\t     &xp_arg) == FAIL)\n\t\t    return;\n\t    }\n\t}\n\n\tif (defstr != NULL)\n\t{\n\t    int save_ex_normal_busy = ex_normal_busy;\n\t    int save_vgetc_busy = vgetc_busy;\n\t    int save_input_busy = input_busy;\n\n\t    input_busy |= vgetc_busy;\n\t    ex_normal_busy = 0;\n\t    vgetc_busy = 0;\n\t    rettv->vval.v_string =\n\t\tgetcmdline_prompt(secret ? NUL : '@', p, get_echo_attr(),\n\t\t\t\t\t\t\t      xp_type, xp_arg);\n\t    ex_normal_busy = save_ex_normal_busy;\n\t    vgetc_busy = save_vgetc_busy;\n\t    input_busy = save_input_busy;\n\t}\n\tif (inputdialog && rettv->vval.v_string == NULL\n\t\t&& argvars[1].v_type != VAR_UNKNOWN\n\t\t&& argvars[2].v_type != VAR_UNKNOWN)\n\t    rettv->vval.v_string = vim_strsave(tv_get_string_buf(\n\t\t\t\t\t\t\t   &argvars[2], buf));\n\n\tvim_free(xp_arg);\n\n\t// since the user typed this, no need to wait for return\n\tneed_wait_return = FALSE;\n\tmsg_didout = FALSE;\n    }\n    cmd_silent = cmd_silent_save;\n}\n#endif\n", "\" Tests for editing the command line.\n\nsource check.vim\nCheckFeature cmdwin\n\nsource screendump.vim\n\nfunc Test_getcmdwintype()\n  call feedkeys(\"q/:let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal('/', a)\n\n  call feedkeys(\"q?:let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal('?', a)\n\n  call feedkeys(\"q::let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal(':', a)\n\n  call feedkeys(\":\\<C-F>:let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal(':', a)\n\n  call assert_equal('', getcmdwintype())\nendfunc\n\nfunc Test_getcmdwin_autocmd()\n  let s:seq = []\n  augroup CmdWin\n  au WinEnter * call add(s:seq, 'WinEnter ' .. win_getid())\n  au WinLeave * call add(s:seq, 'WinLeave ' .. win_getid())\n  au BufEnter * call add(s:seq, 'BufEnter ' .. bufnr())\n  au BufLeave * call add(s:seq, 'BufLeave ' .. bufnr())\n  au CmdWinEnter * call add(s:seq, 'CmdWinEnter ' .. win_getid())\n  au CmdWinLeave * call add(s:seq, 'CmdWinLeave ' .. win_getid())\n\n  let org_winid = win_getid()\n  let org_bufnr = bufnr()\n  call feedkeys(\"q::let a = getcmdwintype()\\<CR>:let s:cmd_winid = win_getid()\\<CR>:let s:cmd_bufnr = bufnr()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal(':', a)\n  call assert_equal([\n\t\\ 'WinLeave ' .. org_winid,\n\t\\ 'WinEnter ' .. s:cmd_winid,\n\t\\ 'BufLeave ' .. org_bufnr,\n\t\\ 'BufEnter ' .. s:cmd_bufnr,\n\t\\ 'CmdWinEnter ' .. s:cmd_winid,\n\t\\ 'CmdWinLeave ' .. s:cmd_winid,\n\t\\ 'BufLeave ' .. s:cmd_bufnr,\n\t\\ 'WinLeave ' .. s:cmd_winid,\n\t\\ 'WinEnter ' .. org_winid,\n\t\\ 'BufEnter ' .. org_bufnr,\n\t\\ ], s:seq)\n\n  au!\n  augroup END\nendfunc\n\nfunc Test_cmdwin_bug()\n  let winid = win_getid()\n  sp\n  try\n    call feedkeys(\"q::call win_gotoid(\" .. winid .. \")\\<CR>:q\\<CR>\", 'x!')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E11/\n  endtry\n  bw!\nendfunc\n\nfunc Test_cmdwin_restore()\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    augroup vimHints | au! | augroup END\n    call setline(1, range(30))\n    2split\n  [SCRIPT]\n  call writefile(lines, 'XTest_restore', 'D')\n\n  let buf = RunVimInTerminal('-S XTest_restore', {'rows': 12})\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \"q:\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_restore_1', {})\n\n  \" normal restore\n  call term_sendkeys(buf, \":q\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_restore_2', {})\n\n  \" restore after setting 'lines' with one window\n  call term_sendkeys(buf, \":close\\<CR>\")\n  call term_sendkeys(buf, \"q:\")\n  call term_sendkeys(buf, \":set lines=18\\<CR>\")\n  call term_sendkeys(buf, \":q\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_restore_3', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_cmdwin_no_terminal()\n  CheckFeature terminal\n  CheckNotMSWindows\n\n  let buf = RunVimInTerminal('', {'rows': 12})\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":set cmdheight=2\\<CR>\")\n  call term_sendkeys(buf, \"q:\")\n  call term_sendkeys(buf, \":let buf = term_start(['/bin/echo'], #{hidden: 1})\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_no_terminal', {})\n  call term_sendkeys(buf, \":q\\<CR>\")\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_cmdwin_feedkeys()\n  \" This should not generate E488\n  call feedkeys(\"q:\\<CR>\", 'x')\n  \" Using feedkeys with q: only should automatically close the cmd window\n  call feedkeys('q:', 'xt')\n  call assert_equal(1, winnr('$'))\n  call assert_equal('', getcmdwintype())\nendfunc\n\n\" Tests for the issues fixed in 7.4.441.\n\" When 'cedit' is set to Ctrl-C, opening the command window hangs Vim\nfunc Test_cmdwin_cedit()\n  exe \"set cedit=\\<C-c>\"\n  normal! :\n  call assert_equal(1, winnr('$'))\n\n  let g:cmd_wintype = ''\n  func CmdWinType()\n      let g:cmd_wintype = getcmdwintype()\n      let g:wintype = win_gettype()\n      return ''\n  endfunc\n\n  call feedkeys(\"\\<C-c>a\\<C-R>=CmdWinType()\\<CR>\\<CR>\")\n  echo input('')\n  call assert_equal('@', g:cmd_wintype)\n  call assert_equal('command', g:wintype)\n\n  set cedit&vim\n  delfunc CmdWinType\nendfunc\n\n\" Test for CmdwinEnter autocmd\nfunc Test_cmdwin_autocmd()\n  augroup CmdWin\n    au!\n    autocmd BufLeave * if &buftype == '' | update | endif\n    autocmd CmdwinEnter * startinsert\n  augroup END\n\n  call assert_fails('call feedkeys(\"q:xyz\\<CR>\", \"xt\")', 'E492:')\n  call assert_equal('xyz', @:)\n\n  augroup CmdWin\n    au!\n  augroup END\n  augroup! CmdWin\nendfunc\n\nfunc Test_cmdwin_jump_to_win()\n  call assert_fails('call feedkeys(\"q:\\<C-W>\\<C-W>\\<CR>\", \"xt\")', 'E11:')\n  new\n  set modified\n  call assert_fails('call feedkeys(\"q/:qall\\<CR>\", \"xt\")', ['E37:', 'E162:'])\n  close!\n  call feedkeys(\"q/:close\\<CR>\", \"xt\")\n  call assert_equal(1, winnr('$'))\n  call feedkeys(\"q/:exit\\<CR>\", \"xt\")\n  call assert_equal(1, winnr('$'))\n\n  \" opening command window twice should fail\n  call assert_beeps('call feedkeys(\"q:q:\\<CR>\\<CR>\", \"xt\")')\n  call assert_equal(1, winnr('$'))\nendfunc\n\nfunc Test_cmdwin_tabpage()\n  tabedit\n  call assert_fails(\"silent norm q/g\t:I\\<Esc>\", 'E11:')\n  tabclose!\nendfunc\n\nfunc Test_cmdwin_interrupted()\n  CheckScreendump\n\n  \" aborting the :smile output caused the cmdline window to use the current\n  \" buffer.\n  let lines =<< trim [SCRIPT]\n    au WinNew * smile\n  [SCRIPT]\n  call writefile(lines, 'XTest_cmdwin', 'D')\n\n  let buf = RunVimInTerminal('-S XTest_cmdwin', {'rows': 18})\n  \" open cmdwin\n  call term_sendkeys(buf, \"q:\")\n  call WaitForAssert({-> assert_match('-- More --', term_getline(buf, 18))})\n  \" quit more prompt for :smile command\n  call term_sendkeys(buf, \"q\")\n  call WaitForAssert({-> assert_match('^$', term_getline(buf, 18))})\n  \" execute a simple command\n  call term_sendkeys(buf, \"aecho 'done'\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_interrupted', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Test for recursively getting multiple command line inputs\nfunc Test_cmdwin_multi_input()\n  call feedkeys(\":\\<C-R>=input('P: ')\\<CR>\\\"cyan\\<CR>\\<CR>\", 'xt')\n  call assert_equal('\"cyan', @:)\nendfunc\n\n\" Test for normal mode commands not supported in the cmd window\nfunc Test_cmdwin_blocked_commands()\n  call assert_fails('call feedkeys(\"q:\\<C-T>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-]>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-^>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:Q\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:Z\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<F1>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>s\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>v\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>^\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>n\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>z\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>o\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>w\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>j\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>k\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>h\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>l\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>T\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>x\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>r\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>R\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>K\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>}\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>]\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>f\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>d\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>g\\<CR>\", \"xt\")', 'E11:')\nendfunc\n\n\" Close the Cmd-line window in insert mode using CTRL-C\nfunc Test_cmdwin_insert_mode_close()\n  %bw!\n  let s = ''\n  exe \"normal q:a\\<C-C>let s='Hello'\\<CR>\"\n  call assert_equal('Hello', s)\n  call assert_equal(1, winnr('$'))\nendfunc\n\nfunc Test_cmdwin_ex_mode_with_modifier()\n  \" this was accessing memory after allocated text in Ex mode\n  new\n  call setline(1, ['some', 'text', 'lines'])\n  silent! call feedkeys(\"gQnormal vq:atopleft\\<C-V>\\<CR>\\<CR>\", 'xt')\n  bwipe!\nendfunc\n\nfunc s:ComplInCmdwin_GlobalCompletion(a, l, p)\n  return 'global'\nendfunc\n\nfunc s:ComplInCmdwin_LocalCompletion(a, l, p)\n  return 'local'\nendfunc\n\nfunc Test_compl_in_cmdwin()\n  set wildmenu wildchar=<Tab>\n  com! -nargs=1 -complete=command GetInput let input = <q-args>\n  com! -buffer TestCommand echo 'TestCommand'\n  let w:test_winvar = 'winvar'\n  let b:test_bufvar = 'bufvar'\n\n  \" User-defined commands\n  let input = ''\n  call feedkeys(\"q:iGetInput T\\<C-x>\\<C-v>\\<CR>\", 'tx!')\n  call assert_equal('TestCommand', input)\n\n  let input = ''\n  call feedkeys(\"q::GetInput T\\<Tab>\\<CR>:q\\<CR>\", 'tx!')\n  call assert_equal('T', input)\n\n\n  com! -nargs=1 -complete=var GetInput let input = <q-args>\n  \" Window-local variables\n  let input = ''\n  call feedkeys(\"q:iGetInput w:test_\\<C-x>\\<C-v>\\<CR>\", 'tx!')\n  call assert_equal('w:test_winvar', input)\n\n  let input = ''\n  call feedkeys(\"q::GetInput w:test_\\<Tab>\\<CR>:q\\<CR>\", 'tx!')\n  call assert_equal('w:test_', input)\n\n  \" Buffer-local variables\n  let input = ''\n  call feedkeys(\"q:iGetInput b:test_\\<C-x>\\<C-v>\\<CR>\", 'tx!')\n  call assert_equal('b:test_bufvar', input)\n\n  let input = ''\n  call feedkeys(\"q::GetInput b:test_\\<Tab>\\<CR>:q\\<CR>\", 'tx!')\n  call assert_equal('b:test_', input)\n\n\n  \" Argument completion of buffer-local command\n  func s:ComplInCmdwin_GlobalCompletionList(a, l, p)\n    return ['global']\n  endfunc\n\n  func s:ComplInCmdwin_LocalCompletionList(a, l, p)\n    return ['local']\n  endfunc\n\n  func s:ComplInCmdwin_CheckCompletion(arg)\n    call assert_equal('local', a:arg)\n  endfunc\n\n  com! -nargs=1 -complete=custom,<SID>ComplInCmdwin_GlobalCompletion\n       \\ TestCommand call s:ComplInCmdwin_CheckCompletion(<q-args>)\n  com! -buffer -nargs=1 -complete=custom,<SID>ComplInCmdwin_LocalCompletion\n       \\ TestCommand call s:ComplInCmdwin_CheckCompletion(<q-args>)\n  call feedkeys(\"q:iTestCommand \\<Tab>\\<CR>\", 'tx!')\n\n  com! -nargs=1 -complete=customlist,<SID>ComplInCmdwin_GlobalCompletionList\n       \\ TestCommand call s:ComplInCmdwin_CheckCompletion(<q-args>)\n  com! -buffer -nargs=1 -complete=customlist,<SID>ComplInCmdwin_LocalCompletionList\n       \\ TestCommand call s:ComplInCmdwin_CheckCompletion(<q-args>)\n\n  call feedkeys(\"q:iTestCommand \\<Tab>\\<CR>\", 'tx!')\n\n  func! s:ComplInCmdwin_CheckCompletion(arg)\n    call assert_equal('global', a:arg)\n  endfunc\n  new\n  call feedkeys(\"q:iTestCommand \\<Tab>\\<CR>\", 'tx!')\n  quit\n\n  delfunc s:ComplInCmdwin_GlobalCompletion\n  delfunc s:ComplInCmdwin_LocalCompletion\n  delfunc s:ComplInCmdwin_GlobalCompletionList\n  delfunc s:ComplInCmdwin_LocalCompletionList\n  delfunc s:ComplInCmdwin_CheckCompletion\n\n  delcom -buffer TestCommand\n  delcom TestCommand\n  delcom GetInput\n  unlet w:test_winvar\n  unlet b:test_bufvar\n  set wildmenu& wildchar&\nendfunc\n\nfunc Test_cmdwin_ctrl_bsl()\n  \" Using CTRL-\\ CTRL-N in cmd window should close the window\n  call feedkeys(\"q:\\<C-\\>\\<C-N>\", 'xt')\n  call assert_equal('', getcmdwintype())\nendfunc\n\nfunc Test_cant_open_cmdwin_in_cmdwin()\n  try\n    call feedkeys(\"q:q::q\\<CR>\", \"x!\")\n  catch\n    let caught = v:exception\n  endtry\n  call assert_match('E1292:', caught)\nendfunc\n\nfunc Test_cmdwin_virtual_edit()\n  enew!\n  set ve=all cpo+=$\n  silent normal q/s\n\n  set ve= cpo-=$\nendfunc\n\n\" Check that a :normal command can be used to stop Visual mode without side\n\" effects.\nfunc Test_normal_escape()\n  call feedkeys(\"q:i\\\" foo\\<Esc>:normal! \\<C-V>\\<Esc>\\<CR>:\\\" bar\\<CR>\", 'ntx')\n  call assert_equal('\" bar', @:)\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * ex_getln.c: Functions for entering and editing an Ex command line.\n */\n\n#include \"vim.h\"\n\n#ifndef MAX\n# define MAX(x,y) ((x) > (y) ? (x) : (y))\n#endif\n\n// Return value when handling keys in command-line mode.\n#define CMDLINE_NOT_CHANGED\t1\n#define CMDLINE_CHANGED\t\t2\n#define GOTO_NORMAL_MODE\t3\n#define PROCESS_NEXT_KEY\t4\n\n// The current cmdline_info.  It is initialized in getcmdline() and after that\n// used by other functions.  When invoking getcmdline() recursively it needs\n// to be saved with save_cmdline() and restored with restore_cmdline().\nstatic cmdline_info_T ccline;\n\n#ifdef FEAT_EVAL\nstatic int\tnew_cmdpos;\t// position set by set_cmdline_pos()\n#endif\n\nstatic int\textra_char = NUL;  // extra character to display when redrawing\n\t\t\t\t   // the command line\nstatic int\textra_char_shift;\n\n#ifdef FEAT_RIGHTLEFT\nstatic int\tcmd_hkmap = 0;\t// Hebrew mapping during command line\n#endif\n\nstatic char_u\t*getcmdline_int(int firstc, long count, int indent, int clear_ccline);\nstatic int\tcmdline_charsize(int idx);\nstatic void\tset_cmdspos(void);\nstatic void\tset_cmdspos_cursor(void);\nstatic void\tcorrect_cmdspos(int idx, int cells);\nstatic void\talloc_cmdbuff(int len);\nstatic void\tdraw_cmdline(int start, int len);\nstatic void\tsave_cmdline(cmdline_info_T *ccp);\nstatic void\trestore_cmdline(cmdline_info_T *ccp);\nstatic int\tcmdline_paste(int regname, int literally, int remcr);\nstatic void\tredrawcmdprompt(void);\nstatic int\tccheck_abbr(int);\n#ifdef FEAT_SEARCH_EXTRA\nstatic int\tempty_pattern_magic(char_u *pat, size_t len, magic_T magic_val);\n#endif\n\n#ifdef FEAT_CMDWIN\nstatic int\topen_cmdwin(void);\n\nstatic int\tcedit_key = -1;\t// key value of 'cedit' option\n#endif\n\n\n    static void\ntrigger_cmd_autocmd(int typechar, int evt)\n{\n    char_u\ttypestr[2];\n\n    typestr[0] = typechar;\n    typestr[1] = NUL;\n    apply_autocmds(evt, typestr, typestr, FALSE, curbuf);\n}\n\n/*\n * Abandon the command line.\n */\n    static void\nabandon_cmdline(void)\n{\n    VIM_CLEAR(ccline.cmdbuff);\n    if (msg_scrolled == 0)\n\tcompute_cmdrow();\n    msg(\"\");\n    redraw_cmdline = TRUE;\n}\n\n#ifdef FEAT_SEARCH_EXTRA\n/*\n * Guess that the pattern matches everything.  Only finds specific cases, such\n * as a trailing \\|, which can happen while typing a pattern.\n */\n    static int\nempty_pattern(char_u *p, int delim)\n{\n    size_t\tn = STRLEN(p);\n    magic_T\tmagic_val = MAGIC_ON;\n\n    if (n > 0)\n\t(void) skip_regexp_ex(p, delim, magic_isset(), NULL, NULL, &magic_val);\n    else\n\treturn TRUE;\n\n    return empty_pattern_magic(p, n, magic_val);\n}\n\n    static int\nempty_pattern_magic(char_u *p, size_t len, magic_T magic_val)\n{\n    // remove trailing \\v and the like\n    while (len >= 2 && p[len - 2] == '\\\\'\n\t\t\t&& vim_strchr((char_u *)\"mMvVcCZ\", p[len - 1]) != NULL)\n       len -= 2;\n\n    // true, if the pattern is empty, or the pattern ends with \\| and magic is\n    // set (or it ends with '|' and very magic is set)\n    return len == 0 || (len > 1\n\t    && ((p[len - 2] == '\\\\'\n\t\t\t\t && p[len - 1] == '|' && magic_val == MAGIC_ON)\n\t\t|| (p[len - 2] != '\\\\'\n\t\t\t     && p[len - 1] == '|' && magic_val == MAGIC_ALL)));\n}\n\n// Struct to store the viewstate during 'incsearch' highlighting.\ntypedef struct {\n    colnr_T\tvs_curswant;\n    colnr_T\tvs_leftcol;\n    linenr_T\tvs_topline;\n# ifdef FEAT_DIFF\n    int\t\tvs_topfill;\n# endif\n    linenr_T\tvs_botline;\n    linenr_T\tvs_empty_rows;\n} viewstate_T;\n\n    static void\nsave_viewstate(viewstate_T *vs)\n{\n    vs->vs_curswant = curwin->w_curswant;\n    vs->vs_leftcol = curwin->w_leftcol;\n    vs->vs_topline = curwin->w_topline;\n# ifdef FEAT_DIFF\n    vs->vs_topfill = curwin->w_topfill;\n# endif\n    vs->vs_botline = curwin->w_botline;\n    vs->vs_empty_rows = curwin->w_empty_rows;\n}\n\n    static void\nrestore_viewstate(viewstate_T *vs)\n{\n    curwin->w_curswant = vs->vs_curswant;\n    curwin->w_leftcol = vs->vs_leftcol;\n    curwin->w_topline = vs->vs_topline;\n# ifdef FEAT_DIFF\n    curwin->w_topfill = vs->vs_topfill;\n# endif\n    curwin->w_botline = vs->vs_botline;\n    curwin->w_empty_rows = vs->vs_empty_rows;\n}\n\n// Struct to store the state of 'incsearch' highlighting.\ntypedef struct {\n    pos_T\tsearch_start;\t// where 'incsearch' starts searching\n    pos_T\tsave_cursor;\n    int\t\twinid;\t\t// window where this state is valid\n    viewstate_T\tinit_viewstate;\n    viewstate_T\told_viewstate;\n    pos_T\tmatch_start;\n    pos_T\tmatch_end;\n    int\t\tdid_incsearch;\n    int\t\tincsearch_postponed;\n    optmagic_T\tmagic_overruled_save;\n} incsearch_state_T;\n\n    static void\ninit_incsearch_state(incsearch_state_T *is_state)\n{\n    is_state->winid = curwin->w_id;\n    is_state->match_start = curwin->w_cursor;\n    is_state->did_incsearch = FALSE;\n    is_state->incsearch_postponed = FALSE;\n    is_state->magic_overruled_save = magic_overruled;\n    CLEAR_POS(&is_state->match_end);\n    is_state->save_cursor = curwin->w_cursor;  // may be restored later\n    is_state->search_start = curwin->w_cursor;\n    save_viewstate(&is_state->init_viewstate);\n    save_viewstate(&is_state->old_viewstate);\n}\n\n/*\n * First move cursor to end of match, then to the start.  This\n * moves the whole match onto the screen when 'nowrap' is set.\n */\n    static void\nset_search_match(pos_T *t)\n{\n    t->lnum += search_match_lines;\n    t->col = search_match_endcol;\n    if (t->lnum > curbuf->b_ml.ml_line_count)\n    {\n\tt->lnum = curbuf->b_ml.ml_line_count;\n\tcoladvance((colnr_T)MAXCOL);\n    }\n}\n\n/*\n * Return TRUE when 'incsearch' highlighting is to be done.\n * Sets search_first_line and search_last_line to the address range.\n * May change the last search pattern.\n */\n    static int\ndo_incsearch_highlighting(\n\tint\t\t    firstc,\n\tint\t\t    *search_delim,\n\tincsearch_state_T   *is_state,\n\tint\t\t    *skiplen,\n\tint\t\t    *patlen)\n{\n    char_u\t*cmd;\n    cmdmod_T\tdummy_cmdmod;\n    char_u\t*p;\n    int\t\tdelim_optional = FALSE;\n    int\t\tdelim;\n    char_u\t*end;\n    char\t*dummy;\n    exarg_T\tea;\n    pos_T\tsave_cursor;\n    int\t\tuse_last_pat;\n    int\t\tretval = FALSE;\n    magic_T     magic = 0;\n\n    *skiplen = 0;\n    *patlen = ccline.cmdlen;\n\n    if (!p_is || cmd_silent)\n\treturn FALSE;\n\n    // by default search all lines\n    search_first_line = 0;\n    search_last_line = MAXLNUM;\n\n    if (firstc == '/' || firstc == '?')\n    {\n\t*search_delim = firstc;\n\treturn TRUE;\n    }\n    if (firstc != ':')\n\treturn FALSE;\n\n    ++emsg_off;\n    CLEAR_FIELD(ea);\n    ea.line1 = 1;\n    ea.line2 = 1;\n    ea.cmd = ccline.cmdbuff;\n    ea.addr_type = ADDR_LINES;\n\n    parse_command_modifiers(&ea, &dummy, &dummy_cmdmod, TRUE);\n\n    cmd = skip_range(ea.cmd, TRUE, NULL);\n    if (vim_strchr((char_u *)\"sgvl\", *cmd) == NULL)\n\tgoto theend;\n\n    // Skip over \"substitute\" to find the pattern separator.\n    for (p = cmd; ASCII_ISALPHA(*p); ++p)\n\t;\n    if (*skipwhite(p) == NUL)\n\tgoto theend;\n\n    if (STRNCMP(cmd, \"substitute\", p - cmd) == 0\n\t    || STRNCMP(cmd, \"smagic\", p - cmd) == 0\n\t    || STRNCMP(cmd, \"snomagic\", MAX(p - cmd, 3)) == 0\n\t    || STRNCMP(cmd, \"vglobal\", p - cmd) == 0)\n    {\n\tif (*cmd == 's' && cmd[1] == 'm')\n\t    magic_overruled = OPTION_MAGIC_ON;\n\telse if (*cmd == 's' && cmd[1] == 'n')\n\t    magic_overruled = OPTION_MAGIC_OFF;\n    }\n    else if (STRNCMP(cmd, \"sort\", MAX(p - cmd, 3)) == 0)\n    {\n\t// skip over ! and flags\n\tif (*p == '!')\n\t    p = skipwhite(p + 1);\n\twhile (ASCII_ISALPHA(*(p = skipwhite(p))))\n\t    ++p;\n\tif (*p == NUL)\n\t    goto theend;\n    }\n    else if (STRNCMP(cmd, \"vimgrep\", MAX(p - cmd, 3)) == 0\n\t|| STRNCMP(cmd, \"vimgrepadd\", MAX(p - cmd, 8)) == 0\n\t|| STRNCMP(cmd, \"lvimgrep\", MAX(p - cmd, 2)) == 0\n\t|| STRNCMP(cmd, \"lvimgrepadd\", MAX(p - cmd, 9)) == 0\n\t|| STRNCMP(cmd, \"global\", p - cmd) == 0)\n    {\n\t// skip over \"!\"\n\tif (*p == '!')\n\t{\n\t    p++;\n\t    if (*skipwhite(p) == NUL)\n\t\tgoto theend;\n\t}\n\tif (*cmd != 'g')\n\t    delim_optional = TRUE;\n    }\n    else\n\tgoto theend;\n\n    p = skipwhite(p);\n    delim = (delim_optional && vim_isIDc(*p)) ? ' ' : *p++;\n    *search_delim = delim;\n    end = skip_regexp_ex(p, delim, magic_isset(), NULL, NULL, &magic);\n\n    use_last_pat = end == p && *end == delim;\n\n    if (end == p && !use_last_pat)\n\tgoto theend;\n\n    // Don't do 'hlsearch' highlighting if the pattern matches everything.\n    if (!use_last_pat)\n    {\n\tchar c = *end;\n\tint  empty;\n\n\t*end = NUL;\n\tempty = empty_pattern_magic(p, STRLEN(p), magic);\n\t*end = c;\n\tif (empty)\n\t    goto theend;\n    }\n\n    // found a non-empty pattern or //\n    *skiplen = (int)(p - ccline.cmdbuff);\n    *patlen = (int)(end - p);\n\n    // parse the address range\n    save_cursor = curwin->w_cursor;\n    curwin->w_cursor = is_state->search_start;\n    parse_cmd_address(&ea, &dummy, TRUE);\n    if (ea.addr_count > 0)\n    {\n\t// Allow for reverse match.\n\tif (ea.line2 < ea.line1)\n\t{\n\t    search_first_line = ea.line2;\n\t    search_last_line = ea.line1;\n\t}\n\telse\n\t{\n\t    search_first_line = ea.line1;\n\t    search_last_line = ea.line2;\n\t}\n    }\n    else if (cmd[0] == 's' && cmd[1] != 'o')\n    {\n\t// :s defaults to the current line\n\tsearch_first_line = curwin->w_cursor.lnum;\n\tsearch_last_line = curwin->w_cursor.lnum;\n    }\n\n    curwin->w_cursor = save_cursor;\n    retval = TRUE;\ntheend:\n    --emsg_off;\n    return retval;\n}\n\n    static void\nfinish_incsearch_highlighting(\n\tint gotesc,\n\tincsearch_state_T *is_state,\n\tint call_update_screen)\n{\n    if (is_state->did_incsearch)\n    {\n\tis_state->did_incsearch = FALSE;\n\tif (gotesc)\n\t    curwin->w_cursor = is_state->save_cursor;\n\telse\n\t{\n\t    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))\n\t    {\n\t\t// put the '\" mark at the original position\n\t\tcurwin->w_cursor = is_state->save_cursor;\n\t\tsetpcmark();\n\t    }\n\t    curwin->w_cursor = is_state->search_start;\n\t}\n\trestore_viewstate(&is_state->old_viewstate);\n\thighlight_match = FALSE;\n\n\t// by default search all lines\n\tsearch_first_line = 0;\n\tsearch_last_line = MAXLNUM;\n\n\tmagic_overruled = is_state->magic_overruled_save;\n\n\tvalidate_cursor();\t// needed for TAB\n\tredraw_all_later(UPD_SOME_VALID);\n\tif (call_update_screen)\n\t    update_screen(UPD_SOME_VALID);\n    }\n}\n\n/*\n * Do 'incsearch' highlighting if desired.\n */\n    static void\nmay_do_incsearch_highlighting(\n\tint\t\t    firstc,\n\tlong\t\t    count,\n\tincsearch_state_T   *is_state)\n{\n    int\t\tskiplen, patlen;\n    int\t\tfound;  // do_search() result\n    pos_T\tend_pos;\n#ifdef FEAT_RELTIME\n    searchit_arg_T sia;\n#endif\n    int\t\tnext_char;\n    int\t\tuse_last_pat;\n    int\t\tdid_do_incsearch = is_state->did_incsearch;\n    int\t\tsearch_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\tfinish_incsearch_highlighting(FALSE, is_state, TRUE);\n\tif (did_do_incsearch && vpeekc() == NUL)\n\t    // may have skipped a redraw, do it now\n\t    redrawcmd();\n\treturn;\n    }\n\n    // If there is a character waiting, search and redraw later.\n    if (char_avail())\n    {\n\trestore_last_search_pattern();\n\tis_state->incsearch_postponed = TRUE;\n\treturn;\n    }\n    is_state->incsearch_postponed = FALSE;\n\n    if (search_first_line == 0)\n\t// start at the original cursor position\n\tcurwin->w_cursor = is_state->search_start;\n    else if (search_first_line > curbuf->b_ml.ml_line_count)\n    {\n\t// start after the last line\n\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\tcurwin->w_cursor.col = MAXCOL;\n    }\n    else\n    {\n\t// start at the first line in the range\n\tcurwin->w_cursor.lnum = search_first_line;\n\tcurwin->w_cursor.col = 0;\n    }\n\n    // Use the previous pattern for \":s//\".\n    next_char = ccline.cmdbuff[skiplen + patlen];\n    use_last_pat = patlen == 0 && skiplen > 0\n\t\t\t\t   && ccline.cmdbuff[skiplen - 1] == next_char;\n\n    // If there is no pattern, don't do anything.\n    if (patlen == 0 && !use_last_pat)\n    {\n\tfound = 0;\n\tset_no_hlsearch(TRUE); // turn off previous highlight\n\tredraw_all_later(UPD_SOME_VALID);\n    }\n    else\n    {\n\tint search_flags = SEARCH_OPT + SEARCH_NOOF + SEARCH_PEEK;\n\n\tcursor_off();\t// so the user knows we're busy\n\tout_flush();\n\t++emsg_off;\t// so it doesn't beep if bad expr\n\tif (!p_hls)\n\t    search_flags += SEARCH_KEEP;\n\tif (search_first_line != 0)\n\t    search_flags += SEARCH_START;\n\tccline.cmdbuff[skiplen + patlen] = NUL;\n#ifdef FEAT_RELTIME\n\tCLEAR_FIELD(sia);\n\t// Set the time limit to half a second.\n\tsia.sa_tm = 500;\n#endif\n\tfound = do_search(NULL, firstc == ':' ? '/' : firstc, search_delim,\n\t\t\t\t ccline.cmdbuff + skiplen, count, search_flags,\n#ifdef FEAT_RELTIME\n\t\t&sia\n#else\n\t\tNULL\n#endif\n\t\t);\n\tccline.cmdbuff[skiplen + patlen] = next_char;\n\t--emsg_off;\n\n\tif (curwin->w_cursor.lnum < search_first_line\n\t\t|| curwin->w_cursor.lnum > search_last_line)\n\t{\n\t    // match outside of address range\n\t    found = 0;\n\t    curwin->w_cursor = is_state->search_start;\n\t}\n\n\t// if interrupted while searching, behave like it failed\n\tif (got_int)\n\t{\n\t    (void)vpeekc();\t// remove <C-C> from input stream\n\t    got_int = FALSE;\t// don't abandon the command line\n\t    found = 0;\n\t}\n\telse if (char_avail())\n\t    // cancelled searching because a char was typed\n\t    is_state->incsearch_postponed = TRUE;\n    }\n    if (found != 0)\n\thighlight_match = TRUE;\t\t// highlight position\n    else\n\thighlight_match = FALSE;\t// remove highlight\n\n    // First restore the old curwin values, so the screen is positioned in the\n    // same way as the actual search command.\n    restore_viewstate(&is_state->old_viewstate);\n    changed_cline_bef_curs();\n    update_topline();\n\n    if (found != 0)\n    {\n\tpos_T\t    save_pos = curwin->w_cursor;\n\n\tis_state->match_start = curwin->w_cursor;\n\tset_search_match(&curwin->w_cursor);\n\tvalidate_cursor();\n\tend_pos = curwin->w_cursor;\n\tis_state->match_end = end_pos;\n\tcurwin->w_cursor = save_pos;\n    }\n    else\n\tend_pos = curwin->w_cursor; // shutup gcc 4\n\n    // Disable 'hlsearch' highlighting if the pattern matches everything.\n    // Avoids a flash when typing \"foo\\|\".\n    if (!use_last_pat)\n    {\n\tnext_char = ccline.cmdbuff[skiplen + patlen];\n\tccline.cmdbuff[skiplen + patlen] = NUL;\n\tif (empty_pattern(ccline.cmdbuff + skiplen, search_delim)\n\t\t\t\t\t\t\t       && !no_hlsearch)\n\t{\n\t    redraw_all_later(UPD_SOME_VALID);\n\t    set_no_hlsearch(TRUE);\n\t}\n\tccline.cmdbuff[skiplen + patlen] = next_char;\n    }\n\n    validate_cursor();\n    // May redraw the status line to show the cursor position.\n    if (p_ru && curwin->w_status_height > 0)\n\tcurwin->w_redr_status = TRUE;\n\n    update_screen(UPD_SOME_VALID);\n    highlight_match = FALSE;\n    restore_last_search_pattern();\n\n    // Leave it at the end to make CTRL-R CTRL-W work.  But not when beyond the\n    // end of the pattern, e.g. for \":s/pat/\".\n    if (ccline.cmdbuff[skiplen + patlen] != NUL)\n\tcurwin->w_cursor = is_state->search_start;\n    else if (found != 0)\n\tcurwin->w_cursor = end_pos;\n\n    msg_starthere();\n    redrawcmdline();\n    is_state->did_incsearch = TRUE;\n}\n\n/*\n * May adjust 'incsearch' highlighting for typing CTRL-G and CTRL-T, go to next\n * or previous match.\n * Returns FAIL when jumping to cmdline_not_changed;\n */\n    static int\nmay_adjust_incsearch_highlighting(\n\tint\t\t\tfirstc,\n\tlong\t\t\tcount,\n\tincsearch_state_T\t*is_state,\n\tint\t\t\tc)\n{\n    int\t    skiplen, patlen;\n    pos_T   t;\n    char_u  *pat;\n    int\t    search_flags = SEARCH_NOOF;\n    int\t    i;\n    int\t    save;\n    int\t    search_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\treturn OK;\n    }\n    if (patlen == 0 && ccline.cmdbuff[skiplen] == NUL)\n    {\n\trestore_last_search_pattern();\n\treturn FAIL;\n    }\n\n    if (search_delim == ccline.cmdbuff[skiplen])\n    {\n\tpat = last_search_pattern();\n\tif (pat == NULL)\n\t{\n\t    restore_last_search_pattern();\n\t    return FAIL;\n\t}\n\tskiplen = 0;\n\tpatlen = (int)STRLEN(pat);\n    }\n    else\n\tpat = ccline.cmdbuff + skiplen;\n\n    cursor_off();\n    out_flush();\n    if (c == Ctrl_G)\n    {\n\tt = is_state->match_end;\n\tif (LT_POS(is_state->match_start, is_state->match_end))\n\t    // Start searching at the end of the match not at the beginning of\n\t    // the next column.\n\t    (void)decl(&t);\n\tsearch_flags += SEARCH_COL;\n    }\n    else\n\tt = is_state->match_start;\n    if (!p_hls)\n\tsearch_flags += SEARCH_KEEP;\n    ++emsg_off;\n    save = pat[patlen];\n    pat[patlen] = NUL;\n    i = searchit(curwin, curbuf, &t, NULL,\n\t\t c == Ctrl_G ? FORWARD : BACKWARD,\n\t\t pat, count, search_flags, RE_SEARCH, NULL);\n    --emsg_off;\n    pat[patlen] = save;\n    if (i)\n    {\n\tis_state->search_start = is_state->match_start;\n\tis_state->match_end = t;\n\tis_state->match_start = t;\n\tif (c == Ctrl_T && firstc != '?')\n\t{\n\t    // Move just before the current match, so that when nv_search\n\t    // finishes the cursor will be put back on the match.\n\t    is_state->search_start = t;\n\t    (void)decl(&is_state->search_start);\n\t}\n\telse if (c == Ctrl_G && firstc == '?')\n\t{\n\t    // Move just after the current match, so that when nv_search\n\t    // finishes the cursor will be put back on the match.\n\t    is_state->search_start = t;\n\t    (void)incl(&is_state->search_start);\n\t}\n\tif (LT_POS(t, is_state->search_start) && c == Ctrl_G)\n\t{\n\t    // wrap around\n\t    is_state->search_start = t;\n\t    if (firstc == '?')\n\t\t(void)incl(&is_state->search_start);\n\t    else\n\t\t(void)decl(&is_state->search_start);\n\t}\n\n\tset_search_match(&is_state->match_end);\n\tcurwin->w_cursor = is_state->match_start;\n\tchanged_cline_bef_curs();\n\tupdate_topline();\n\tvalidate_cursor();\n\thighlight_match = TRUE;\n\tsave_viewstate(&is_state->old_viewstate);\n\tupdate_screen(UPD_NOT_VALID);\n\thighlight_match = FALSE;\n\tredrawcmdline();\n\tcurwin->w_cursor = is_state->match_end;\n    }\n    else\n\tvim_beep(BO_ERROR);\n    restore_last_search_pattern();\n    return FAIL;\n}\n\n/*\n * When CTRL-L typed: add character from the match to the pattern.\n * May set \"*c\" to the added character.\n * Return OK when jumping to cmdline_not_changed.\n */\n    static int\nmay_add_char_to_search(int firstc, int *c, incsearch_state_T *is_state)\n{\n    int\t\tskiplen, patlen, search_delim;\n\n    // Parsing range may already set the last search pattern.\n    // NOTE: must call restore_last_search_pattern() before returning!\n    save_last_search_pattern();\n\n    if (!do_incsearch_highlighting(firstc, &search_delim, is_state,\n\t\t\t\t\t\t\t    &skiplen, &patlen))\n    {\n\trestore_last_search_pattern();\n\treturn FAIL;\n    }\n    restore_last_search_pattern();\n\n    // Add a character from under the cursor for 'incsearch'.\n    if (is_state->did_incsearch)\n    {\n\tcurwin->w_cursor = is_state->match_end;\n\t*c = gchar_cursor();\n\tif (*c != NUL)\n\t{\n\t    // If 'ignorecase' and 'smartcase' are set and the\n\t    // command line has no uppercase characters, convert\n\t    // the character to lowercase.\n\t    if (p_ic && p_scs && !pat_has_uppercase(ccline.cmdbuff + skiplen))\n\t\t*c = MB_TOLOWER(*c);\n\t    if (*c == search_delim || vim_strchr((char_u *)(\n\t\t\t     magic_isset() ? \"\\\\~^$.*[\" : \"\\\\^$\"), *c) != NULL)\n\t    {\n\t\t// put a backslash before special characters\n\t\tstuffcharReadbuff(*c);\n\t\t*c = '\\\\';\n\t    }\n\t    // add any composing characters\n\t    if (mb_char2len(*c) != mb_ptr2len(ml_get_cursor()))\n\t    {\n\t\tint save_c = *c;\n\n\t\twhile (mb_char2len(*c) != mb_ptr2len(ml_get_cursor()))\n\t\t{\n\t\t    curwin->w_cursor.col += mb_char2len(*c);\n\t\t    *c = gchar_cursor();\n\t\t    stuffcharReadbuff(*c);\n\t\t}\n\t\t*c = save_c;\n\t    }\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n#endif\n\n#ifdef FEAT_ARABIC\n/*\n * Return TRUE if the command line has an Arabic character at or after \"start\"\n * for \"len\" bytes.\n */\n    static int\ncmdline_has_arabic(int start, int len)\n{\n    int\t    j;\n    int\t    mb_l;\n    int\t    u8c;\n    char_u  *p;\n    int\t    u8cc[MAX_MCO];\n\n    if (!enc_utf8)\n\treturn FALSE;\n\n    for (j = start; j < start + len; j += mb_l)\n    {\n\tp = ccline.cmdbuff + j;\n\tu8c = utfc_ptr2char_len(p, u8cc, start + len - j);\n\tmb_l = utfc_ptr2len_len(p, start + len - j);\n\tif (ARABIC_CHAR(u8c))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n    void\ncmdline_init(void)\n{\n    CLEAR_FIELD(ccline);\n}\n\n/*\n * Handle the backslash key pressed in the command-line mode.  CTRL-\\ CTRL-N\n * goes to Normal mode, CTRL-\\ CTRL-G goes to Insert mode when 'insertmode' is\n * set, CTRL-\\ e prompts for an expression.\n */\n    static int\ncmdline_handle_backslash_key(int c, int *gotesc)\n{\n    ++no_mapping;\n    ++allow_keys;\n    c = plain_vgetc();\n    --no_mapping;\n    --allow_keys;\n\n    // CTRL-\\ e doesn't work when obtaining an expression, unless it\n    // is in a mapping.\n    if (c != Ctrl_N && c != Ctrl_G && (c != 'e'\n\t\t|| (ccline.cmdfirstc == '=' && KeyTyped)\n#ifdef FEAT_EVAL\n\t\t|| cmdline_star > 0\n#endif\n\t\t))\n    {\n\tvungetc(c);\n\treturn PROCESS_NEXT_KEY;\n    }\n\n#ifdef FEAT_EVAL\n    if (c == 'e')\n    {\n\tchar_u\t*p = NULL;\n\tint\tlen;\n\n\t/*\n\t * Replace the command line with the result of an expression.\n\t * Need to save and restore the current command line, to be\n\t * able to enter a new one...\n\t */\n\tif (ccline.cmdpos == ccline.cmdlen)\n\t    new_cmdpos = 99999;\t// keep it at the end\n\telse\n\t    new_cmdpos = ccline.cmdpos;\n\n\tc = get_expr_register();\n\tif (c == '=')\n\t{\n\t    // Need to save and restore ccline.  And set \"textlock\"\n\t    // to avoid nasty things like going to another buffer when\n\t    // evaluating an expression.\n\t    ++textlock;\n\t    p = get_expr_line();\n\t    --textlock;\n\n\t    if (p != NULL)\n\t    {\n\t\tlen = (int)STRLEN(p);\n\t\tif (realloc_cmdbuff(len + 1) == OK)\n\t\t{\n\t\t    ccline.cmdlen = len;\n\t\t    STRCPY(ccline.cmdbuff, p);\n\t\t    vim_free(p);\n\n\t\t    // Restore the cursor or use the position set with\n\t\t    // set_cmdline_pos().\n\t\t    if (new_cmdpos > ccline.cmdlen)\n\t\t\tccline.cmdpos = ccline.cmdlen;\n\t\t    else\n\t\t\tccline.cmdpos = new_cmdpos;\n\n\t\t    KeyTyped = FALSE;\t// Don't do p_wc completion.\n\t\t    redrawcmd();\n\t\t    return CMDLINE_CHANGED;\n\t\t}\n\t\tvim_free(p);\n\t    }\n\t}\n\tbeep_flush();\n\tgot_int = FALSE;\t// don't abandon the command line\n\tdid_emsg = FALSE;\n\temsg_on_display = FALSE;\n\tredrawcmd();\n\treturn CMDLINE_NOT_CHANGED;\n    }\n#endif\n\n    if (c == Ctrl_G && p_im && restart_edit == 0)\n\trestart_edit = 'a';\n    *gotesc = TRUE;\t// will free ccline.cmdbuff after putting it\n\t\t\t// in history\n    return GOTO_NORMAL_MODE;\n}\n\n/*\n * Completion for 'wildchar' or 'wildcharm' key.\n * - hitting <ESC> twice means: abandon command line.\n * - wildcard expansion is only done when the 'wildchar' key is really\n *   typed, not when it comes from a macro\n * Returns CMDLINE_CHANGED if command line is changed or CMDLINE_NOT_CHANGED.\n */\n    static int\ncmdline_wildchar_complete(\n\tint\t\tc,\n\tint\t\tescape,\n\tint\t\t*did_wild_list,\n\tint\t\t*wim_index_p,\n\texpand_T\t*xp,\n\tint\t\t*gotesc)\n{\n    int\t\twim_index = *wim_index_p;\n    int\t\tres;\n    int\t\tj;\n    int\t\toptions = WILD_NO_BEEP;\n\n    if (wim_flags[wim_index] & WIM_BUFLASTUSED)\n\toptions |= WILD_BUFLASTUSED;\n    if (xp->xp_numfiles > 0)   // typed p_wc at least twice\n    {\n\t// if 'wildmode' contains \"list\" may still need to list\n\tif (xp->xp_numfiles > 1\n\t\t&& !*did_wild_list\n\t\t&& ((wim_flags[wim_index] & WIM_LIST)\n\t\t    || (p_wmnu && (wim_flags[wim_index] & WIM_FULL) != 0)))\n\t{\n\t    (void)showmatches(xp,\n\t\t    p_wmnu && ((wim_flags[wim_index] & WIM_LIST) == 0));\n\t    redrawcmd();\n\t    *did_wild_list = TRUE;\n\t}\n\tif (wim_flags[wim_index] & WIM_LONGEST)\n\t    res = nextwild(xp, WILD_LONGEST, options, escape);\n\telse if (wim_flags[wim_index] & WIM_FULL)\n\t    res = nextwild(xp, WILD_NEXT, options, escape);\n\telse\n\t    res = OK;\t    // don't insert 'wildchar' now\n    }\n    else\t\t    // typed p_wc first time\n    {\n\twim_index = 0;\n\tj = ccline.cmdpos;\n\t// if 'wildmode' first contains \"longest\", get longest\n\t// common part\n\tif (wim_flags[0] & WIM_LONGEST)\n\t    res = nextwild(xp, WILD_LONGEST, options, escape);\n\telse\n\t    res = nextwild(xp, WILD_EXPAND_KEEP, options, escape);\n\n\t// if interrupted while completing, behave like it failed\n\tif (got_int)\n\t{\n\t    (void)vpeekc();\t// remove <C-C> from input stream\n\t    got_int = FALSE;\t// don't abandon the command line\n\t    (void)ExpandOne(xp, NULL, NULL, 0, WILD_FREE);\n\t    xp->xp_context = EXPAND_NOTHING;\n\t    *wim_index_p = wim_index;\n\t    return CMDLINE_CHANGED;\n\t}\n\n\t// when more than one match, and 'wildmode' first contains\n\t// \"list\", or no change and 'wildmode' contains \"longest,list\",\n\t// list all matches\n\tif (res == OK && xp->xp_numfiles > 1)\n\t{\n\t    // a \"longest\" that didn't do anything is skipped (but not\n\t    // \"list:longest\")\n\t    if (wim_flags[0] == WIM_LONGEST && ccline.cmdpos == j)\n\t\twim_index = 1;\n\t    if ((wim_flags[wim_index] & WIM_LIST)\n\t\t    || (p_wmnu && (wim_flags[wim_index] & WIM_FULL) != 0))\n\t    {\n\t\tif (!(wim_flags[0] & WIM_LONGEST))\n\t\t{\n\t\t    int p_wmnu_save = p_wmnu;\n\n\t\t    p_wmnu = 0;\n\n\t\t    // remove match\n\t\t    nextwild(xp, WILD_PREV, 0, escape);\n\t\t    p_wmnu = p_wmnu_save;\n\t\t}\n\t\t(void)showmatches(xp, p_wmnu\n\t\t\t&& ((wim_flags[wim_index] & WIM_LIST) == 0));\n\t\tredrawcmd();\n\t\t*did_wild_list = TRUE;\n\t\tif (wim_flags[wim_index] & WIM_LONGEST)\n\t\t    nextwild(xp, WILD_LONGEST, options, escape);\n\t\telse if (wim_flags[wim_index] & WIM_FULL)\n\t\t    nextwild(xp, WILD_NEXT, options, escape);\n\t    }\n\t    else\n\t\tvim_beep(BO_WILD);\n\t}\n\telse if (xp->xp_numfiles == -1)\n\t    xp->xp_context = EXPAND_NOTHING;\n    }\n    if (wim_index < 3)\n\t++wim_index;\n    if (c == ESC)\n\t*gotesc = TRUE;\n\n    *wim_index_p = wim_index;\n    return (res == OK) ? CMDLINE_CHANGED : CMDLINE_NOT_CHANGED;\n}\n\n/*\n * Handle backspace, delete and CTRL-W keys in the command-line mode.\n * Returns:\n *  CMDLINE_NOT_CHANGED - if the command line is not changed\n *  CMDLINE_CHANGED - if the command line is changed\n *  GOTO_NORMAL_MODE - go back to normal mode\n */\n    static int\ncmdline_erase_chars(\n\tint c,\n\tint indent\n#ifdef FEAT_SEARCH_EXTRA\n\t, incsearch_state_T *isp\n#endif\n\t)\n{\n    int\t\ti;\n    int\t\tj;\n\n    if (c == K_KDEL)\n\tc = K_DEL;\n\n    /*\n     * Delete current character is the same as backspace on next\n     * character, except at end of line.\n     */\n    if (c == K_DEL && ccline.cmdpos != ccline.cmdlen)\n\t++ccline.cmdpos;\n    if (has_mbyte && c == K_DEL)\n\tccline.cmdpos += mb_off_next(ccline.cmdbuff,\n\t\tccline.cmdbuff + ccline.cmdpos);\n    if (ccline.cmdpos > 0)\n    {\n\tchar_u *p;\n\n\tj = ccline.cmdpos;\n\tp = ccline.cmdbuff + j;\n\tif (has_mbyte)\n\t{\n\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t    if (c == Ctrl_W)\n\t    {\n\t\twhile (p > ccline.cmdbuff && vim_isspace(*p))\n\t\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t\ti = mb_get_class(p);\n\t\twhile (p > ccline.cmdbuff && mb_get_class(p) == i)\n\t\t    p = mb_prevptr(ccline.cmdbuff, p);\n\t\tif (mb_get_class(p) != i)\n\t\t    p += (*mb_ptr2len)(p);\n\t    }\n\t}\n\telse if (c == Ctrl_W)\n\t{\n\t    while (p > ccline.cmdbuff && vim_isspace(p[-1]))\n\t\t--p;\n\t    if (p > ccline.cmdbuff)\n\t    {\n\t\ti = vim_iswordc(p[-1]);\n\t\twhile (p > ccline.cmdbuff && !vim_isspace(p[-1])\n\t\t\t&& vim_iswordc(p[-1]) == i)\n\t\t    --p;\n\t    }\n\t}\n\telse\n\t    --p;\n\tccline.cmdpos = (int)(p - ccline.cmdbuff);\n\tccline.cmdlen -= j - ccline.cmdpos;\n\ti = ccline.cmdpos;\n\twhile (i < ccline.cmdlen)\n\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n\n\t// Truncate at the end, required for multi-byte chars.\n\tccline.cmdbuff[ccline.cmdlen] = NUL;\n#ifdef FEAT_SEARCH_EXTRA\n\tif (ccline.cmdlen == 0)\n\t{\n\t    isp->search_start = isp->save_cursor;\n\t    // save view settings, so that the screen\n\t    // won't be restored at the wrong position\n\t    isp->old_viewstate = isp->init_viewstate;\n\t}\n#endif\n\tredrawcmd();\n    }\n    else if (ccline.cmdlen == 0 && c != Ctrl_W\n\t    && ccline.cmdprompt == NULL && indent == 0)\n    {\n\t// In ex and debug mode it doesn't make sense to return.\n\tif (exmode_active\n#ifdef FEAT_EVAL\n\t\t|| ccline.cmdfirstc == '>'\n#endif\n\t   )\n\t    return CMDLINE_NOT_CHANGED;\n\n\tVIM_CLEAR(ccline.cmdbuff);\t// no commandline to return\n\tif (!cmd_silent)\n\t{\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\tmsg_col = Columns;\n\t    else\n#endif\n\t\tmsg_col = 0;\n\t    msg_putchar(' ');\t\t// delete ':'\n\t}\n#ifdef FEAT_SEARCH_EXTRA\n\tif (ccline.cmdlen == 0)\n\t    isp->search_start = isp->save_cursor;\n#endif\n\tredraw_cmdline = TRUE;\n\treturn GOTO_NORMAL_MODE;\n    }\n    return CMDLINE_CHANGED;\n}\n\n/*\n * Handle the CTRL-^ key in the command-line mode and toggle the use of the\n * language :lmap mappings and/or Input Method.\n */\n    static void\ncmdline_toggle_langmap(long *b_im_ptr)\n{\n    if (map_to_exists_mode((char_u *)\"\", MODE_LANGMAP, FALSE))\n    {\n\t// \":lmap\" mappings exists, toggle use of mappings.\n\tState ^= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(FALSE);\t// Disable input method\n#endif\n\tif (b_im_ptr != NULL)\n\t{\n\t    if (State & MODE_LANGMAP)\n\t\t*b_im_ptr = B_IMODE_LMAP;\n\t    else\n\t\t*b_im_ptr = B_IMODE_NONE;\n\t}\n    }\n#ifdef HAVE_INPUT_METHOD\n    else\n    {\n\t// There are no \":lmap\" mappings, toggle IM.  When\n\t// 'imdisable' is set don't try getting the status, it's\n\t// always off.\n\tif ((p_imdisable && b_im_ptr != NULL)\n\t\t? *b_im_ptr == B_IMODE_IM : im_get_status())\n\t{\n\t    im_set_active(FALSE);\t// Disable input method\n\t    if (b_im_ptr != NULL)\n\t\t*b_im_ptr = B_IMODE_NONE;\n\t}\n\telse\n\t{\n\t    im_set_active(TRUE);\t// Enable input method\n\t    if (b_im_ptr != NULL)\n\t\t*b_im_ptr = B_IMODE_IM;\n\t}\n    }\n#endif\n    if (b_im_ptr != NULL)\n    {\n\tif (b_im_ptr == &curbuf->b_p_iminsert)\n\t    set_iminsert_global();\n\telse\n\t    set_imsearch_global();\n    }\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t// may show different cursor shape\n#endif\n#if defined(FEAT_KEYMAP)\n    // Show/unshow value of 'keymap' in status lines later.\n    status_redraw_curbuf();\n#endif\n}\n\n/*\n * Handle the CTRL-R key in the command-line mode and insert the contents of a\n * numbered or named register.\n */\n    static int\ncmdline_insert_reg(int *gotesc UNUSED)\n{\n    int\t\ti;\n    int\t\tc;\n#ifdef FEAT_EVAL\n    int\t\tsave_new_cmdpos = new_cmdpos;\n#endif\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t// disallow scrolling here\n#endif\n    putcmdline('\"', TRUE);\n    ++no_mapping;\n    ++allow_keys;\n    i = c = plain_vgetc();\t// CTRL-R <char>\n    if (i == Ctrl_O)\n\ti = Ctrl_R;\t\t// CTRL-R CTRL-O == CTRL-R CTRL-R\n    if (i == Ctrl_R)\n\tc = plain_vgetc();\t// CTRL-R CTRL-R <char>\n    extra_char = NUL;\n    --no_mapping;\n    --allow_keys;\n#ifdef FEAT_EVAL\n    /*\n     * Insert the result of an expression.\n     */\n    new_cmdpos = -1;\n    if (c == '=')\n    {\n\tif (ccline.cmdfirstc == '='  // can't do this recursively\n\t\t|| cmdline_star > 0) // or when typing a password\n\t{\n\t    beep_flush();\n\t    c = ESC;\n\t}\n\telse\n\t    c = get_expr_register();\n    }\n#endif\n    if (c != ESC)\t    // use ESC to cancel inserting register\n    {\n\tcmdline_paste(c, i == Ctrl_R, FALSE);\n\n#ifdef FEAT_EVAL\n\t// When there was a serious error abort getting the\n\t// command line.\n\tif (aborting())\n\t{\n\t    *gotesc = TRUE;  // will free ccline.cmdbuff after\n\t    // putting it in history\n\t    return GOTO_NORMAL_MODE;\n\t}\n#endif\n\tKeyTyped = FALSE;\t// Don't do p_wc completion.\n#ifdef FEAT_EVAL\n\tif (new_cmdpos >= 0)\n\t{\n\t    // set_cmdline_pos() was used\n\t    if (new_cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    else\n\t\tccline.cmdpos = new_cmdpos;\n\t}\n#endif\n    }\n#ifdef FEAT_EVAL\n    new_cmdpos = save_new_cmdpos;\n#endif\n\n    // remove the double quote\n    redrawcmd();\n\n    // The text has been stuffed, the command line didn't change yet.\n    return CMDLINE_NOT_CHANGED;\n}\n\n/*\n * Handle the Left and Right mouse clicks in the command-line mode.\n */\n    static void\ncmdline_left_right_mouse(int c, int *ignore_drag_release)\n{\n    if (c == K_LEFTRELEASE || c == K_RIGHTRELEASE)\n\t*ignore_drag_release = TRUE;\n    else\n\t*ignore_drag_release = FALSE;\n# ifdef FEAT_GUI\n    // When GUI is active, also move when 'mouse' is empty\n    if (!gui.in_use)\n# endif\n\tif (!mouse_has(MOUSE_COMMAND))\n\t    return;\n# ifdef FEAT_CLIPBOARD\n    if (mouse_row < cmdline_row && clip_star.available)\n    {\n\tint\t    button, is_click, is_drag;\n\n\t/*\n\t * Handle modeless selection.\n\t */\n\tbutton = get_mouse_button(KEY2TERMCAP1(c),\n\t\t&is_click, &is_drag);\n\tif (mouse_model_popup() && button == MOUSE_LEFT\n\t\t&& (mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    // Translate shift-left to right button.\n\t    button = MOUSE_RIGHT;\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n\tclip_modeless(button, is_click, is_drag);\n\treturn;\n    }\n# endif\n\n    set_cmdspos();\n    for (ccline.cmdpos = 0; ccline.cmdpos < ccline.cmdlen;\n\t    ++ccline.cmdpos)\n    {\n\tint\ti;\n\n\ti = cmdline_charsize(ccline.cmdpos);\n\tif (mouse_row <= cmdline_row + ccline.cmdspos / Columns\n\t\t&& mouse_col < ccline.cmdspos % Columns + i)\n\t    break;\n\tif (has_mbyte)\n\t{\n\t    // Count \">\" for double-wide char that doesn't fit.\n\t    correct_cmdspos(ccline.cmdpos, i);\n\t    ccline.cmdpos += (*mb_ptr2len)(ccline.cmdbuff\n\t\t    + ccline.cmdpos) - 1;\n\t}\n\tccline.cmdspos += i;\n    }\n}\n\n/*\n * Handle the Up, Down, Page Up, Page down, CTRL-N and CTRL-P key in the\n * command-line mode. The pressed key is in 'c'.\n * Returns:\n *  CMDLINE_NOT_CHANGED - if the command line is not changed\n *  CMDLINE_CHANGED - if the command line is changed\n *  GOTO_NORMAL_MODE - go back to normal mode\n */\n    static int\ncmdline_browse_history(\n\tint\tc,\n\tint\tfirstc,\n\tchar_u\t**curcmdstr,\n\tint\thistype,\n\tint\t*hiscnt_p,\n\texpand_T *xp)\n{\n    int\t\ti;\n    int\t\tj;\n    char_u\t*lookfor = *curcmdstr;\n    int\t\thiscnt = *hiscnt_p;\n    int\t\tres;\n\n    if (get_hislen() == 0 || firstc == NUL)\t// no history\n\treturn CMDLINE_NOT_CHANGED;\n\n    i = hiscnt;\n\n    // save current command string so it can be restored later\n    if (lookfor == NULL)\n    {\n\tif ((lookfor = vim_strsave(ccline.cmdbuff)) == NULL)\n\t    return CMDLINE_NOT_CHANGED;\n\tlookfor[ccline.cmdpos] = NUL;\n    }\n\n    j = (int)STRLEN(lookfor);\n    for (;;)\n    {\n\t// one step backwards\n\tif (c == K_UP|| c == K_S_UP || c == Ctrl_P\n\t\t|| c == K_PAGEUP || c == K_KPAGEUP)\n\t{\n\t    if (hiscnt == get_hislen())\t// first time\n\t\thiscnt = *get_hisidx(histype);\n\t    else if (hiscnt == 0 && *get_hisidx(histype)\n\t\t    != get_hislen() - 1)\n\t\thiscnt = get_hislen() - 1;\n\t    else if (hiscnt != *get_hisidx(histype) + 1)\n\t\t--hiscnt;\n\t    else\t\t\t// at top of list\n\t    {\n\t\thiscnt = i;\n\t\tbreak;\n\t    }\n\t}\n\telse    // one step forwards\n\t{\n\t    // on last entry, clear the line\n\t    if (hiscnt == *get_hisidx(histype))\n\t    {\n\t\thiscnt = get_hislen();\n\t\tbreak;\n\t    }\n\n\t    // not on a history line, nothing to do\n\t    if (hiscnt == get_hislen())\n\t\tbreak;\n\t    if (hiscnt == get_hislen() - 1)   // wrap around\n\t\thiscnt = 0;\n\t    else\n\t\t++hiscnt;\n\t}\n\tif (hiscnt < 0 || get_histentry(histype)[hiscnt].hisstr\n\t\t== NULL)\n\t{\n\t    hiscnt = i;\n\t    break;\n\t}\n\tif ((c != K_UP && c != K_DOWN)\n\t\t|| hiscnt == i\n\t\t|| STRNCMP(get_histentry(histype)[hiscnt].hisstr,\n\t\t    lookfor, (size_t)j) == 0)\n\t    break;\n    }\n\n    if (hiscnt != i)\t// jumped to other entry\n    {\n\tchar_u\t*p;\n\tint\t\tlen;\n\tint\t\told_firstc;\n\n\tVIM_CLEAR(ccline.cmdbuff);\n\txp->xp_context = EXPAND_NOTHING;\n\tif (hiscnt == get_hislen())\n\t    p = lookfor;\t// back to the old one\n\telse\n\t    p = get_histentry(histype)[hiscnt].hisstr;\n\n\tif (histype == HIST_SEARCH\n\t\t&& p != lookfor\n\t\t&& (old_firstc = p[STRLEN(p) + 1]) != firstc)\n\t{\n\t    // Correct for the separator character used when\n\t    // adding the history entry vs the one used now.\n\t    // First loop: count length.\n\t    // Second loop: copy the characters.\n\t    for (i = 0; i <= 1; ++i)\n\t    {\n\t\tlen = 0;\n\t\tfor (j = 0; p[j] != NUL; ++j)\n\t\t{\n\t\t    // Replace old sep with new sep, unless it is\n\t\t    // escaped.\n\t\t    if (p[j] == old_firstc\n\t\t\t    && (j == 0 || p[j - 1] != '\\\\'))\n\t\t    {\n\t\t\tif (i > 0)\n\t\t\t    ccline.cmdbuff[len] = firstc;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Escape new sep, unless it is already\n\t\t\t// escaped.\n\t\t\tif (p[j] == firstc\n\t\t\t\t&& (j == 0 || p[j - 1] != '\\\\'))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\t\tccline.cmdbuff[len] = '\\\\';\n\t\t\t    ++len;\n\t\t\t}\n\t\t\tif (i > 0)\n\t\t\t    ccline.cmdbuff[len] = p[j];\n\t\t    }\n\t\t    ++len;\n\t\t}\n\t\tif (i == 0)\n\t\t{\n\t\t    alloc_cmdbuff(len);\n\t\t    if (ccline.cmdbuff == NULL)\n\t\t    {\n\t\t\tres = GOTO_NORMAL_MODE;\n\t\t\tgoto done;\n\t\t    }\n\t\t}\n\t    }\n\t    ccline.cmdbuff[len] = NUL;\n\t}\n\telse\n\t{\n\t    alloc_cmdbuff((int)STRLEN(p));\n\t    if (ccline.cmdbuff == NULL)\n\t    {\n\t\tres = GOTO_NORMAL_MODE;\n\t\tgoto done;\n\t    }\n\t    STRCPY(ccline.cmdbuff, p);\n\t}\n\n\tccline.cmdpos = ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);\n\tredrawcmd();\n\tres = CMDLINE_CHANGED;\n\tgoto done;\n    }\n    beep_flush();\n    res = CMDLINE_NOT_CHANGED;\n\ndone:\n    *curcmdstr = lookfor;\n    *hiscnt_p = hiscnt;\n    return res;\n}\n\n/*\n * Initialize the current command-line info.\n */\n    static int\ninit_ccline(int firstc, int indent)\n{\n    ccline.overstrike = FALSE;\t\t    // always start in insert mode\n\n    /*\n     * set some variables for redrawcmd()\n     */\n    ccline.cmdfirstc = (firstc == '@' ? 0 : firstc);\n    ccline.cmdindent = (firstc > 0 ? indent : 0);\n\n    // alloc initial ccline.cmdbuff\n    alloc_cmdbuff(indent + 50);\n    if (ccline.cmdbuff == NULL)\n\treturn FAIL;\n    ccline.cmdlen = ccline.cmdpos = 0;\n    ccline.cmdbuff[0] = NUL;\n    sb_text_start_cmdline();\n\n    // autoindent for :insert and :append\n    if (firstc <= 0)\n    {\n\tvim_memset(ccline.cmdbuff, ' ', indent);\n\tccline.cmdbuff[indent] = NUL;\n\tccline.cmdpos = indent;\n\tccline.cmdspos = indent;\n\tccline.cmdlen = indent;\n    }\n\n    return OK;\n}\n\n/*\n * getcmdline() - accept a command line starting with firstc.\n *\n * firstc == ':'\t    get \":\" command line.\n * firstc == '/' or '?'\t    get search pattern\n * firstc == '='\t    get expression\n * firstc == '@'\t    get text for input() function\n * firstc == '>'\t    get text for debug mode\n * firstc == NUL\t    get text for :insert command\n * firstc == -1\t\t    like NUL, and break on CTRL-C\n *\n * The line is collected in ccline.cmdbuff, which is reallocated to fit the\n * command line.\n *\n * Careful: getcmdline() can be called recursively!\n *\n * Return pointer to allocated string if there is a commandline, NULL\n * otherwise.\n */\n    char_u *\ngetcmdline(\n    int\t\t  firstc,\n    long\t  count,\t// only used for incremental search\n    int\t\t  indent,\t// indent for inside conditionals\n    getline_opt_T do_concat UNUSED)\n{\n    return getcmdline_int(firstc, count, indent, TRUE);\n}\n\n    static char_u *\ngetcmdline_int(\n    int\t\tfirstc,\n    long\tcount UNUSED,\t// only used for incremental search\n    int\t\tindent,\t\t// indent for inside conditionals\n    int\t\tclear_ccline)\t// clear ccline first\n{\n    static int\tdepth = 0;\t    // call depth\n    int\t\tc;\n    int\t\ti;\n    int\t\tj;\n    int\t\tgotesc = FALSE;\t\t// TRUE when <ESC> just typed\n    int\t\tdo_abbr;\t\t// when TRUE check for abbr.\n    char_u\t*lookfor = NULL;\t// string to match\n    int\t\thiscnt;\t\t\t// current history line in use\n    int\t\thistype;\t\t// history type to be used\n#ifdef FEAT_SEARCH_EXTRA\n    incsearch_state_T\tis_state;\n#endif\n    int\t\tdid_wild_list = FALSE;\t// did wild_list() recently\n    int\t\twim_index = 0;\t\t// index in wim_flags[]\n    int\t\tres;\n    int\t\tsave_msg_scroll = msg_scroll;\n    int\t\tsave_State = State;\t// remember State when called\n    int\t\tsome_key_typed = FALSE;\t// one of the keys was typed\n    // mouse drag and release events are ignored, unless they are\n    // preceded with a mouse down event\n    int\t\tignore_drag_release = TRUE;\n#ifdef FEAT_EVAL\n    int\t\tbreak_ctrl_c = FALSE;\n#endif\n    expand_T\txpc;\n    long\t*b_im_ptr = NULL;\n    buf_T\t*b_im_ptr_buf = NULL;\t// buffer where b_im_ptr is valid\n    cmdline_info_T save_ccline;\n    int\t\tdid_save_ccline = FALSE;\n    int\t\tcmdline_type;\n    int\t\twild_type;\n\n    // one recursion level deeper\n    ++depth;\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t// Being called recursively.  Since ccline is global, we need to save\n\t// the current buffer and restore it when returning.\n\tsave_cmdline(&save_ccline);\n\tdid_save_ccline = TRUE;\n    }\n    if (clear_ccline)\n\tCLEAR_FIELD(ccline);\n\n#ifdef FEAT_EVAL\n    if (firstc == -1)\n    {\n\tfirstc = NUL;\n\tbreak_ctrl_c = TRUE;\n    }\n#endif\n#ifdef FEAT_RIGHTLEFT\n    // start without Hebrew mapping for a command line\n    if (firstc == ':' || firstc == '=' || firstc == '>')\n\tcmd_hkmap = 0;\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n    init_incsearch_state(&is_state);\n#endif\n\n    if (init_ccline(firstc, indent) != OK)\n\tgoto theend;\t// out of memory\n\n    if (depth == 50)\n    {\n\t// Somehow got into a loop recursively calling getcmdline(), bail out.\n\temsg(_(e_command_too_recursive));\n\tgoto theend;\n    }\n\n    ExpandInit(&xpc);\n    ccline.xpc = &xpc;\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && *curwin->w_p_rlc == 's'\n\t\t\t\t\t  && (firstc == '/' || firstc == '?'))\n\tcmdmsg_rl = TRUE;\n    else\n\tcmdmsg_rl = FALSE;\n#endif\n\n    redir_off = TRUE;\t\t// don't redirect the typed command\n    if (!cmd_silent)\n    {\n\ti = msg_scrolled;\n\tmsg_scrolled = 0;\t\t// avoid wait_return() message\n\tgotocmdline(TRUE);\n\tmsg_scrolled += i;\n\tredrawcmdprompt();\t\t// draw prompt or indent\n\tset_cmdspos();\n    }\n    xpc.xp_context = EXPAND_NOTHING;\n    xpc.xp_backslash = XP_BS_NONE;\n#ifndef BACKSLASH_IN_FILENAME\n    xpc.xp_shell = FALSE;\n#endif\n\n#if defined(FEAT_EVAL)\n    if (ccline.input_fn)\n    {\n\txpc.xp_context = ccline.xp_context;\n\txpc.xp_pattern = ccline.cmdbuff;\n\txpc.xp_arg = ccline.xp_arg;\n    }\n#endif\n\n    /*\n     * Avoid scrolling when called by a recursive do_cmdline(), e.g. when\n     * doing \":@0\" when register 0 doesn't contain a CR.\n     */\n    msg_scroll = FALSE;\n\n    State = MODE_CMDLINE;\n\n    if (firstc == '/' || firstc == '?' || firstc == '@')\n    {\n\t// Use \":lmap\" mappings for search pattern and input().\n\tif (curbuf->b_p_imsearch == B_IMODE_USE_INSERT)\n\t    b_im_ptr = &curbuf->b_p_iminsert;\n\telse\n\t    b_im_ptr = &curbuf->b_p_imsearch;\n\tb_im_ptr_buf = curbuf;\n\tif (*b_im_ptr == B_IMODE_LMAP)\n\t    State |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(*b_im_ptr == B_IMODE_IM);\n#endif\n    }\n#ifdef HAVE_INPUT_METHOD\n    else if (p_imcmdline)\n\tim_set_active(TRUE);\n#endif\n\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\n    // When inside an autocommand for writing \"exiting\" may be set and\n    // terminal mode set to cooked.  Need to set raw mode here then.\n    settmode(TMODE_RAW);\n\n    // Trigger CmdlineEnter autocommands.\n    cmdline_type = firstc == NUL ? '-' : firstc;\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINEENTER);\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n    init_history();\n    hiscnt = get_hislen();\t// set hiscnt to impossible history value\n    histype = hist_char2type(firstc);\n\n#ifdef FEAT_DIGRAPHS\n    do_digraph(-1);\t\t// init digraph typeahead\n#endif\n\n    // If something above caused an error, reset the flags, we do want to type\n    // and execute commands. Display may be messed up a bit.\n    if (did_emsg)\n\tredrawcmd();\n\n#ifdef FEAT_STL_OPT\n    // Redraw the statusline in case it uses the current mode using the mode()\n    // function.\n    if (!cmd_silent && msg_scrolled == 0)\n    {\n\tint\tfound_one = FALSE;\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (*p_stl != NUL || *wp->w_p_stl != NUL)\n\t    {\n\t\twp->w_redr_status = TRUE;\n\t\tfound_one = TRUE;\n\t    }\n\n\tif (*p_tal != NUL)\n\t{\n\t    redraw_tabline = TRUE;\n\t    found_one = TRUE;\n\t}\n\n\tif (found_one)\n\t    redraw_statuslines();\n    }\n#endif\n\n    did_emsg = FALSE;\n    got_int = FALSE;\n\n    /*\n     * Collect the command string, handling editing keys.\n     */\n    for (;;)\n    {\n\tint trigger_cmdlinechanged = TRUE;\n\tint end_wildmenu;\n\n\tredir_off = TRUE;\t// Don't redirect the typed command.\n\t\t\t\t// Repeated, because a \":redir\" inside\n\t\t\t\t// completion may switch it on.\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = FALSE;\t// allow scrolling here\n#endif\n\tquit_more = FALSE;\t// reset after CTRL-D which had a more-prompt\n\n\tdid_emsg = FALSE;\t// There can't really be a reason why an error\n\t\t\t\t// that occurs while typing a command should\n\t\t\t\t// cause the command not to be executed.\n\n\t// Trigger SafeState if nothing is pending.\n\tmay_trigger_safestate(xpc.xp_numfiles <= 0);\n\n\t// Get a character.  Ignore K_IGNORE and K_NOP, they should not do\n\t// anything, such as stop completion.\n\tdo\n\t{\n\t    cursorcmd();\t\t// set the cursor on the right spot\n\t    c = safe_vgetc();\n\t} while (c == K_IGNORE || c == K_NOP);\n\n\tif (c == K_COMMAND || c == K_SCRIPT_COMMAND)\n\t{\n\t    int\t    clen = ccline.cmdlen;\n\n\t    if (do_cmdkey_command(c, DOCMD_NOWAIT) == OK)\n\t    {\n\t\tif (clen == ccline.cmdlen)\n\t\t    trigger_cmdlinechanged = FALSE;\n\t\tgoto cmdline_changed;\n\t    }\n\t}\n\n\tif (KeyTyped)\n\t{\n\t    some_key_typed = TRUE;\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmd_hkmap)\n\t\tc = hkmap(c);\n\t    if (cmdmsg_rl && !KeyStuffed)\n\t    {\n\t\t// Invert horizontal movements and operations.  Only when\n\t\t// typed by the user directly, not when the result of a\n\t\t// mapping.\n\t\tswitch (c)\n\t\t{\n\t\t    case K_RIGHT:   c = K_LEFT; break;\n\t\t    case K_S_RIGHT: c = K_S_LEFT; break;\n\t\t    case K_C_RIGHT: c = K_C_LEFT; break;\n\t\t    case K_LEFT:    c = K_RIGHT; break;\n\t\t    case K_S_LEFT:  c = K_S_RIGHT; break;\n\t\t    case K_C_LEFT:  c = K_C_RIGHT; break;\n\t\t}\n\t    }\n#endif\n\t}\n\n\t/*\n\t * Ignore got_int when CTRL-C was typed here.\n\t * Don't ignore it in :global, we really need to break then, e.g., for\n\t * \":g/pat/normal /pat\" (without the <CR>).\n\t * Don't ignore it for the input() function.\n\t */\n\tif ((c == Ctrl_C\n#ifdef UNIX\n\t\t|| c == intr_char\n#endif\n\t\t\t\t)\n#if defined(FEAT_EVAL) || defined(FEAT_CRYPT)\n\t\t&& firstc != '@'\n#endif\n#ifdef FEAT_EVAL\n\t\t// do clear got_int in Ex mode to avoid infinite Ctrl-C loop\n\t\t&& (!break_ctrl_c || exmode_active)\n#endif\n\t\t&& !global_busy)\n\t    got_int = FALSE;\n\n\t// free old command line when finished moving around in the history\n\t// list\n\tif (lookfor != NULL\n\t\t&& c != K_S_DOWN && c != K_S_UP\n\t\t&& c != K_DOWN && c != K_UP\n\t\t&& c != K_PAGEDOWN && c != K_PAGEUP\n\t\t&& c != K_KPAGEDOWN && c != K_KPAGEUP\n\t\t&& c != K_LEFT && c != K_RIGHT\n\t\t&& (xpc.xp_numfiles > 0 || (c != Ctrl_P && c != Ctrl_N)))\n\t    VIM_CLEAR(lookfor);\n\n\t/*\n\t * When there are matching completions to select <S-Tab> works like\n\t * CTRL-P (unless 'wc' is <S-Tab>).\n\t */\n\tif (c != p_wc && c == K_S_TAB && xpc.xp_numfiles > 0)\n\t    c = Ctrl_P;\n\n\tif (p_wmnu)\n\t    c = wildmenu_translate_key(&ccline, c, &xpc, did_wild_list);\n\n\tif (cmdline_pum_active())\n\t{\n\t    // Ctrl-Y: Accept the current selection and close the popup menu.\n\t    // Ctrl-E: cancel the cmdline popup menu and return the original\n\t    // text.\n\t    if (c == Ctrl_E || c == Ctrl_Y)\n\t    {\n\t\twild_type = (c == Ctrl_E) ? WILD_CANCEL : WILD_APPLY;\n\t\tif (nextwild(&xpc, wild_type, WILD_NO_BEEP,\n\t\t\t\t\t\t\tfirstc != '@') == FAIL)\n\t\t    break;\n\t\tc = Ctrl_E;\n\t    }\n\t}\n\n\t// The wildmenu is cleared if the pressed key is not used for\n\t// navigating the wild menu (i.e. the key is not 'wildchar' or\n\t// 'wildcharm' or Ctrl-N or Ctrl-P or Ctrl-A or Ctrl-L).\n\t// If the popup menu is displayed, then PageDown and PageUp keys are\n\t// also used to navigate the menu.\n\tend_wildmenu = (!(c == p_wc && KeyTyped) && c != p_wcm\n\t\t&& c != Ctrl_N && c != Ctrl_P && c != Ctrl_A && c != Ctrl_L);\n\tend_wildmenu = end_wildmenu && (!cmdline_pum_active() ||\n\t\t\t    (c != K_PAGEDOWN && c != K_PAGEUP\n\t\t\t     && c != K_KPAGEDOWN && c != K_KPAGEUP));\n\n\t// free expanded names when finished walking through matches\n\tif (end_wildmenu)\n\t{\n\t    if (cmdline_pum_active())\n\t\tcmdline_pum_remove();\n\t    if (xpc.xp_numfiles != -1)\n\t\t(void)ExpandOne(&xpc, NULL, NULL, 0, WILD_FREE);\n\t    did_wild_list = FALSE;\n\t    if (!p_wmnu || (c != K_UP && c != K_DOWN))\n\t\txpc.xp_context = EXPAND_NOTHING;\n\t    wim_index = 0;\n\t    wildmenu_cleanup(&ccline);\n\t}\n\n\tif (p_wmnu)\n\t    c = wildmenu_process_key(&ccline, c, &xpc);\n\n\t// CTRL-\\ CTRL-N goes to Normal mode, CTRL-\\ CTRL-G goes to Insert\n\t// mode when 'insertmode' is set, CTRL-\\ e prompts for an expression.\n\tif (c == Ctrl_BSL)\n\t{\n\t    res = cmdline_handle_backslash_key(c, &gotesc);\n\t    if (res == CMDLINE_CHANGED)\n\t\tgoto cmdline_changed;\n\t    else if (res == CMDLINE_NOT_CHANGED)\n\t\tgoto cmdline_not_changed;\n\t    else if (res == GOTO_NORMAL_MODE)\n\t\tgoto returncmd;\t\t// back to cmd mode\n\t    c = Ctrl_BSL;\t\t// backslash key not processed by\n\t\t\t\t\t// cmdline_handle_backslash_key()\n\t}\n\n#ifdef FEAT_CMDWIN\n\tif (c == cedit_key || c == K_CMDWIN)\n\t{\n\t    // TODO: why is ex_normal_busy checked here?\n\t    if ((c == K_CMDWIN || ex_normal_busy == 0) && got_int == FALSE)\n\t    {\n\t\t/*\n\t\t * Open a window to edit the command line (and history).\n\t\t */\n\t\tc = open_cmdwin();\n\t\tsome_key_typed = TRUE;\n\t    }\n\t}\n# ifdef FEAT_DIGRAPHS\n\telse\n# endif\n#endif\n#ifdef FEAT_DIGRAPHS\n\t    c = do_digraph(c);\n#endif\n\n\tif (c == '\\n' || c == '\\r' || c == K_KENTER || (c == ESC\n\t\t\t&& (!KeyTyped || vim_strchr(p_cpo, CPO_ESC) != NULL)))\n\t{\n\t    // In Ex mode a backslash escapes a newline.\n\t    if (exmode_active\n\t\t    && c != ESC\n\t\t    && ccline.cmdpos == ccline.cmdlen\n\t\t    && ccline.cmdpos > 0\n\t\t    && ccline.cmdbuff[ccline.cmdpos - 1] == '\\\\')\n\t    {\n\t\tif (c == K_KENTER)\n\t\t    c = '\\n';\n\t    }\n\t    else\n\t    {\n\t\tgotesc = FALSE;\t// Might have typed ESC previously, don't\n\t\t\t\t// truncate the cmdline now.\n\t\tif (ccheck_abbr(c + ABBR_OFF))\n\t\t    goto cmdline_changed;\n\t\tif (!cmd_silent)\n\t\t{\n\t\t    windgoto(msg_row, 0);\n\t\t    out_flush();\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\n\t// Completion for 'wildchar' or 'wildcharm' key.\n\tif ((c == p_wc && !gotesc && KeyTyped) || c == p_wcm)\n\t{\n\t    res = cmdline_wildchar_complete(c, firstc != '@', &did_wild_list,\n\t\t    &wim_index, &xpc, &gotesc);\n\t    if (res == CMDLINE_CHANGED)\n\t\tgoto cmdline_changed;\n\t}\n\n\tgotesc = FALSE;\n\n\t// <S-Tab> goes to last match, in a clumsy way\n\tif (c == K_S_TAB && KeyTyped)\n\t{\n\t    if (nextwild(&xpc, WILD_EXPAND_KEEP, 0, firstc != '@') == OK)\n\t    {\n\t\tif (xpc.xp_numfiles > 1\n\t\t    && ((!did_wild_list && (wim_flags[wim_index] & WIM_LIST))\n\t\t\t    || p_wmnu))\n\t\t{\n\t\t    // Trigger the popup menu when wildoptions=pum\n\t\t    showmatches(&xpc, p_wmnu\n\t\t\t    && ((wim_flags[wim_index] & WIM_LIST) == 0));\n\t\t}\n\t\tif (nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK\n\t\t\t&& nextwild(&xpc, WILD_PREV, 0, firstc != '@') == OK)\n\t\t    goto cmdline_changed;\n\t    }\n\t}\n\n\tif (c == NUL || c == K_ZERO)\t    // NUL is stored as NL\n\t    c = NL;\n\n\tdo_abbr = TRUE;\t\t// default: check for abbreviation\n\n\t/*\n\t * Big switch for a typed command line character.\n\t */\n\tswitch (c)\n\t{\n\tcase K_BS:\n\tcase Ctrl_H:\n\tcase K_DEL:\n\tcase K_KDEL:\n\tcase Ctrl_W:\n\t    res = cmdline_erase_chars(c, indent\n#ifdef FEAT_SEARCH_EXTRA\n\t\t    , &is_state\n#endif\n\t\t    );\n\t    if (res == CMDLINE_NOT_CHANGED)\n\t\tgoto cmdline_not_changed;\n\t    else if (res == GOTO_NORMAL_MODE)\n\t\tgoto returncmd;\t\t// back to cmd mode\n\t    goto cmdline_changed;\n\n\tcase K_INS:\n\tcase K_KINS:\n\t\tccline.overstrike = !ccline.overstrike;\n#ifdef CURSOR_SHAPE\n\t\tui_cursor_shape();\t// may show different cursor shape\n#endif\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_HAT:\n\t\tcmdline_toggle_langmap(\n\t\t\t\t    buf_valid(b_im_ptr_buf) ? b_im_ptr : NULL);\n\t\tgoto cmdline_not_changed;\n\n//\tcase '@':   only in very old vi\n\tcase Ctrl_U:\n\t\t// delete all characters left of the cursor\n\t\tj = ccline.cmdpos;\n\t\tccline.cmdlen -= j;\n\t\ti = ccline.cmdpos = 0;\n\t\twhile (i < ccline.cmdlen)\n\t\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n\t\t// Truncate at the end, required for multi-byte chars.\n\t\tccline.cmdbuff[ccline.cmdlen] = NUL;\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (ccline.cmdlen == 0)\n\t\t    is_state.search_start = is_state.save_cursor;\n#endif\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n\n#ifdef FEAT_CLIPBOARD\n\tcase Ctrl_Y:\n\t\t// Copy the modeless selection, if there is one.\n\t\tif (clip_star.state != SELECT_CLEARED)\n\t\t{\n\t\t    if (clip_star.state == SELECT_DONE)\n\t\t\tclip_copy_modeless_selection(TRUE);\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase ESC:\t// get here if p_wc != ESC or when ESC typed twice\n\tcase Ctrl_C:\n\t\t// In exmode it doesn't make sense to return.  Except when\n\t\t// \":normal\" runs out of characters.\n\t\tif (exmode_active\n\t\t\t       && (ex_normal_busy == 0 || typebuf.tb_len > 0))\n\t\t    goto cmdline_not_changed;\n\n\t\tgotesc = TRUE;\t\t// will free ccline.cmdbuff after\n\t\t\t\t\t// putting it in history\n\t\tgoto returncmd;\t\t// back to cmd mode\n\n\tcase Ctrl_R:\t\t\t// insert register\n\t\tres = cmdline_insert_reg(&gotesc);\n\t\tif (res == CMDLINE_NOT_CHANGED)\n\t\t    goto cmdline_not_changed;\n\t\telse if (res == GOTO_NORMAL_MODE)\n\t\t    goto returncmd;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_D:\n\t\tif (showmatches(&xpc, FALSE) == EXPAND_NOTHING)\n\t\t    break;\t// Use ^D as normal char instead\n\n\t\tredrawcmd();\n\t\tcontinue;\t// don't do incremental search now\n\n\tcase K_RIGHT:\n\tcase K_S_RIGHT:\n\tcase K_C_RIGHT:\n\t\tdo\n\t\t{\n\t\t    if (ccline.cmdpos >= ccline.cmdlen)\n\t\t\tbreak;\n\t\t    i = cmdline_charsize(ccline.cmdpos);\n\t\t    if (KeyTyped && ccline.cmdspos + i >= Columns * Rows)\n\t\t\tbreak;\n\t\t    ccline.cmdspos += i;\n\t\t    if (has_mbyte)\n\t\t\tccline.cmdpos += (*mb_ptr2len)(ccline.cmdbuff\n\t\t\t\t\t\t\t     + ccline.cmdpos);\n\t\t    else\n\t\t\t++ccline.cmdpos;\n\t\t}\n\t\twhile ((c == K_S_RIGHT || c == K_C_RIGHT\n\t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n\t\t\t&& ccline.cmdbuff[ccline.cmdpos] != ' ');\n\t\tif (has_mbyte)\n\t\t    set_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase K_LEFT:\n\tcase K_S_LEFT:\n\tcase K_C_LEFT:\n\t\tif (ccline.cmdpos == 0)\n\t\t    goto cmdline_not_changed;\n\t\tdo\n\t\t{\n\t\t    --ccline.cmdpos;\n\t\t    if (has_mbyte)\t// move to first byte of char\n\t\t\tccline.cmdpos -= (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t\t      ccline.cmdbuff + ccline.cmdpos);\n\t\t    ccline.cmdspos -= cmdline_charsize(ccline.cmdpos);\n\t\t}\n\t\twhile (ccline.cmdpos > 0\n\t\t\t&& (c == K_S_LEFT || c == K_C_LEFT\n\t\t\t       || (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))\n\t\t\t&& ccline.cmdbuff[ccline.cmdpos - 1] != ' ');\n\t\tif (has_mbyte)\n\t\t    set_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase K_IGNORE:\n\t\t// Ignore mouse event or open_cmdwin() result.\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_GUI_MSWIN\n\t    // On MS-Windows ignore <M-F4>, we get it when closing the window\n\t    // was cancelled.\n\tcase K_F4:\n\t    if (mod_mask == MOD_MASK_ALT)\n\t    {\n\t\tredrawcmd();\t    // somehow the cmdline is cleared\n\t\tgoto cmdline_not_changed;\n\t    }\n\t    break;\n#endif\n\n\tcase K_MIDDLEDRAG:\n\tcase K_MIDDLERELEASE:\n\t\tgoto cmdline_not_changed;\t// Ignore mouse\n\n\tcase K_MIDDLEMOUSE:\n# ifdef FEAT_GUI\n\t\t// When GUI is active, also paste when 'mouse' is empty\n\t\tif (!gui.in_use)\n# endif\n\t\t    if (!mouse_has(MOUSE_COMMAND))\n\t\t\tgoto cmdline_not_changed;   // Ignore mouse\n# ifdef FEAT_CLIPBOARD\n\t\tif (clip_star.available)\n\t\t    cmdline_paste('*', TRUE, TRUE);\n\t\telse\n# endif\n\t\t    cmdline_paste(0, TRUE, TRUE);\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n\n# ifdef FEAT_DND\n\tcase K_DROP:\n\t\tcmdline_paste('~', TRUE, FALSE);\n\t\tredrawcmd();\n\t\tgoto cmdline_changed;\n# endif\n\n\tcase K_LEFTDRAG:\n\tcase K_LEFTRELEASE:\n\tcase K_RIGHTDRAG:\n\tcase K_RIGHTRELEASE:\n\t\t// Ignore drag and release events when the button-down wasn't\n\t\t// seen before.\n\t\tif (ignore_drag_release)\n\t\t    goto cmdline_not_changed;\n\t\t// FALLTHROUGH\n\tcase K_LEFTMOUSE:\n\tcase K_RIGHTMOUSE:\n\t\tcmdline_left_right_mouse(c, &ignore_drag_release);\n\t\tgoto cmdline_not_changed;\n\n\t// Mouse scroll wheel: ignored here\n\tcase K_MOUSEDOWN:\n\tcase K_MOUSEUP:\n\tcase K_MOUSELEFT:\n\tcase K_MOUSERIGHT:\n\t// Alternate buttons ignored here\n\tcase K_X1MOUSE:\n\tcase K_X1DRAG:\n\tcase K_X1RELEASE:\n\tcase K_X2MOUSE:\n\tcase K_X2DRAG:\n\tcase K_X2RELEASE:\n\tcase K_MOUSEMOVE:\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_GUI\n\tcase K_LEFTMOUSE_NM:\t// mousefocus click, ignored\n\tcase K_LEFTRELEASE_NM:\n\t\tgoto cmdline_not_changed;\n\n\tcase K_VER_SCROLLBAR:\n\t\tif (msg_scrolled == 0)\n\t\t{\n\t\t    gui_do_scroll();\n\t\t    redrawcmd();\n\t\t}\n\t\tgoto cmdline_not_changed;\n\n\tcase K_HOR_SCROLLBAR:\n\t\tif (msg_scrolled == 0)\n\t\t{\n\t\t    gui_do_horiz_scroll(scrollbar_value, FALSE);\n\t\t    redrawcmd();\n\t\t}\n\t\tgoto cmdline_not_changed;\n#endif\n#ifdef FEAT_GUI_TABLINE\n\tcase K_TABLINE:\n\tcase K_TABMENU:\n\t\t// Don't want to change any tabs here.  Make sure the same tab\n\t\t// is still selected.\n\t\tif (gui_use_tabline())\n\t\t    gui_mch_set_curtab(tabpage_index(curtab));\n\t\tgoto cmdline_not_changed;\n#endif\n\n\tcase K_SELECT:\t    // end of Select mode mapping - ignore\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_B:\t    // begin of command line\n\tcase K_HOME:\n\tcase K_KHOME:\n\tcase K_S_HOME:\n\tcase K_C_HOME:\n\t\tccline.cmdpos = 0;\n\t\tset_cmdspos();\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_E:\t    // end of command line\n\tcase K_END:\n\tcase K_KEND:\n\tcase K_S_END:\n\tcase K_C_END:\n\t\tccline.cmdpos = ccline.cmdlen;\n\t\tset_cmdspos_cursor();\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_A:\t    // all matches\n\t\tif (cmdline_pum_active())\n\t\t    // As Ctrl-A completes all the matches, close the popup\n\t\t    // menu (if present)\n\t\t    cmdline_pum_cleanup(&ccline);\n\n\t\tif (nextwild(&xpc, WILD_ALL, 0, firstc != '@') == FAIL)\n\t\t    break;\n\t\txpc.xp_context = EXPAND_NOTHING;\n\t\tdid_wild_list = FALSE;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_L:\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (may_add_char_to_search(firstc, &c, &is_state) == OK)\n\t\t    goto cmdline_not_changed;\n#endif\n\n\t\t// completion: longest common part\n\t\tif (nextwild(&xpc, WILD_LONGEST, 0, firstc != '@') == FAIL)\n\t\t    break;\n\t\tgoto cmdline_changed;\n\n\tcase Ctrl_N:\t    // next match\n\tcase Ctrl_P:\t    // previous match\n\t\tif (xpc.xp_numfiles > 0)\n\t\t{\n\t\t    wild_type = (c == Ctrl_P) ? WILD_PREV : WILD_NEXT;\n\t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n\t\t\tbreak;\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\t// FALLTHROUGH\n\tcase K_UP:\n\tcase K_DOWN:\n\tcase K_S_UP:\n\tcase K_S_DOWN:\n\tcase K_PAGEUP:\n\tcase K_KPAGEUP:\n\tcase K_PAGEDOWN:\n\tcase K_KPAGEDOWN:\n\t\tif (cmdline_pum_active()\n\t\t\t&& (c == K_PAGEUP || c == K_PAGEDOWN ||\n\t\t\t    c == K_KPAGEUP || c == K_KPAGEDOWN))\n\t\t{\n\t\t    // If the popup menu is displayed, then PageUp and PageDown\n\t\t    // are used to scroll the menu.\n\t\t    wild_type = WILD_PAGEUP;\n\t\t    if (c == K_PAGEDOWN || c == K_KPAGEDOWN)\n\t\t\twild_type = WILD_PAGEDOWN;\n\t\t    if (nextwild(&xpc, wild_type, 0, firstc != '@') == FAIL)\n\t\t\tbreak;\n\t\t    goto cmdline_not_changed;\n\t\t}\n\t\telse\n\t\t{\n\t\t    res = cmdline_browse_history(c, firstc, &lookfor, histype,\n\t\t\t    &hiscnt, &xpc);\n\t\t    if (res == CMDLINE_CHANGED)\n\t\t\tgoto cmdline_changed;\n\t\t    else if (res == GOTO_NORMAL_MODE)\n\t\t\tgoto returncmd;\n\t\t}\n\t\tgoto cmdline_not_changed;\n\n#ifdef FEAT_SEARCH_EXTRA\n\tcase Ctrl_G:\t    // next match\n\tcase Ctrl_T:\t    // previous match\n\t\tif (may_adjust_incsearch_highlighting(\n\t\t\t\t\t  firstc, count, &is_state, c) == FAIL)\n\t\t    goto cmdline_not_changed;\n\t\tbreak;\n#endif\n\n\tcase Ctrl_V:\n\tcase Ctrl_Q:\n\t\t{\n\t\t    ignore_drag_release = TRUE;\n\t\t    putcmdline('^', TRUE);\n\n\t\t    // Get next (two) character(s).  Do not change any\n\t\t    // modifyOtherKeys ESC sequence to a normal key for\n\t\t    // CTRL-SHIFT-V.\n\t\t    c = get_literal(mod_mask & MOD_MASK_SHIFT);\n\n\t\t    do_abbr = FALSE;\t    // don't do abbreviation now\n\t\t    extra_char = NUL;\n\t\t    // may need to remove ^ when composing char was typed\n\t\t    if (enc_utf8 && utf_iscomposing(c) && !cmd_silent)\n\t\t    {\n\t\t\tdraw_cmdline(ccline.cmdpos,\n\t\t\t\t\t\tccline.cmdlen - ccline.cmdpos);\n\t\t\tmsg_putchar(' ');\n\t\t\tcursorcmd();\n\t\t    }\n\t\t}\n\n\t\tbreak;\n\n#ifdef FEAT_DIGRAPHS\n\tcase Ctrl_K:\n\t\tignore_drag_release = TRUE;\n\t\tputcmdline('?', TRUE);\n# ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t    // disallow scrolling here\n# endif\n\t\tc = get_digraph(TRUE);\n\t\textra_char = NUL;\n\t\tif (c != NUL)\n\t\t    break;\n\n\t\tredrawcmd();\n\t\tgoto cmdline_not_changed;\n#endif // FEAT_DIGRAPHS\n\n#ifdef FEAT_RIGHTLEFT\n\tcase Ctrl__:\t    // CTRL-_: switch language mode\n\t\tif (!p_ari)\n\t\t    break;\n\t\tcmd_hkmap = !cmd_hkmap;\n\t\tgoto cmdline_not_changed;\n#endif\n\n\tcase K_PS:\n\t\tbracketed_paste(PASTE_CMDLINE, FALSE, NULL);\n\t\tgoto cmdline_changed;\n\n\tdefault:\n#ifdef UNIX\n\t\tif (c == intr_char)\n\t\t{\n\t\t    gotesc = TRUE;\t// will free ccline.cmdbuff after\n\t\t\t\t\t// putting it in history\n\t\t    goto returncmd;\t// back to Normal mode\n\t\t}\n#endif\n\t\t/*\n\t\t * Normal character with no special meaning.  Just set mod_mask\n\t\t * to 0x0 so that typing Shift-Space in the GUI doesn't enter\n\t\t * the string <S-Space>.  This should only happen after ^V.\n\t\t */\n\t\tif (!IS_SPECIAL(c))\n\t\t    mod_mask = 0x0;\n\t\tbreak;\n\t}\n\t/*\n\t * End of switch on command line character.\n\t * We come here if we have a normal character.\n\t */\n\n\tif (do_abbr && (IS_SPECIAL(c) || !vim_iswordc(c))\n\t\t&& (ccheck_abbr(\n\t\t\t// Add ABBR_OFF for characters above 0x100, this is\n\t\t\t// what check_abbr() expects.\n\t\t\t\t(has_mbyte && c >= 0x100) ? (c + ABBR_OFF) : c)\n\t\t    || c == Ctrl_RSB))\n\t    goto cmdline_changed;\n\n\t/*\n\t * put the character in the command line\n\t */\n\tif (IS_SPECIAL(c) || mod_mask != 0)\n\t    put_on_cmdline(get_special_key_name(c, mod_mask), -1, TRUE);\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tj = (*mb_char2bytes)(c, IObuff);\n\t\tIObuff[j] = NUL;\t// exclude composing chars\n\t\tput_on_cmdline(IObuff, j, TRUE);\n\t    }\n\t    else\n\t    {\n\t\tIObuff[0] = c;\n\t\tput_on_cmdline(IObuff, 1, TRUE);\n\t    }\n\t}\n\tgoto cmdline_changed;\n\n/*\n * This part implements incremental searches for \"/\" and \"?\"\n * Jump to cmdline_not_changed when a character has been read but the command\n * line did not change. Then we only search and redraw if something changed in\n * the past.\n * Jump to cmdline_changed when the command line did change.\n * (Sorry for the goto's, I know it is ugly).\n */\ncmdline_not_changed:\n#ifdef FEAT_SEARCH_EXTRA\n\tif (!is_state.incsearch_postponed)\n\t    continue;\n#endif\n\ncmdline_changed:\n#ifdef FEAT_SEARCH_EXTRA\n\t// If the window changed incremental search state is not valid.\n\tif (is_state.winid != curwin->w_id)\n\t    init_incsearch_state(&is_state);\n#endif\n\tif (trigger_cmdlinechanged)\n\t    // Trigger CmdlineChanged autocommands.\n\t    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINECHANGED);\n\n#ifdef FEAT_SEARCH_EXTRA\n\tif (xpc.xp_context == EXPAND_NOTHING && (KeyTyped || vpeekc() == NUL))\n\t    may_do_incsearch_highlighting(firstc, count, &is_state);\n#endif\n\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl\n# ifdef FEAT_ARABIC\n\t\t|| (p_arshape && !p_tbidi\n\t\t\t\t       && cmdline_has_arabic(0, ccline.cmdlen))\n# endif\n\t\t)\n\t    // Always redraw the whole command line to fix shaping and\n\t    // right-left typing.  Not efficient, but it works.\n\t    // Do it only when there are no characters left to read\n\t    // to avoid useless intermediate redraws.\n\t    if (vpeekc() == NUL)\n\t\tredrawcmd();\n#endif\n    }\n\nreturncmd:\n\n#ifdef FEAT_RIGHTLEFT\n    cmdmsg_rl = FALSE;\n#endif\n\n    ExpandCleanup(&xpc);\n    ccline.xpc = NULL;\n\n#ifdef FEAT_SEARCH_EXTRA\n    finish_incsearch_highlighting(gotesc, &is_state, FALSE);\n#endif\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t/*\n\t * Put line in history buffer (\":\" and \"=\" only when it was typed).\n\t */\n\tif (ccline.cmdlen && firstc != NUL\n\t\t&& (some_key_typed || histype == HIST_SEARCH))\n\t{\n\t    add_to_history(histype, ccline.cmdbuff, TRUE,\n\t\t\t\t       histype == HIST_SEARCH ? firstc : NUL);\n\t    if (firstc == ':')\n\t    {\n\t\tvim_free(new_last_cmdline);\n\t\tnew_last_cmdline = vim_strsave(ccline.cmdbuff);\n\t    }\n\t}\n\n\tif (gotesc)\n\t    abandon_cmdline();\n    }\n\n    /*\n     * If the screen was shifted up, redraw the whole screen (later).\n     * If the line is too long, clear it, so ruler and shown command do\n     * not get printed in the middle of it.\n     */\n    msg_check();\n    msg_scroll = save_msg_scroll;\n    redir_off = FALSE;\n\n    // When the command line was typed, no need for a wait-return prompt.\n    if (some_key_typed)\n\tneed_wait_return = FALSE;\n\n    // Trigger CmdlineLeave autocommands.\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINELEAVE);\n\n    State = save_State;\n\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n#ifdef HAVE_INPUT_METHOD\n    if (b_im_ptr != NULL && buf_valid(b_im_ptr_buf)\n\t\t\t\t\t\t  && *b_im_ptr != B_IMODE_LMAP)\n\tim_save_status(b_im_ptr);\n    im_set_active(FALSE);\n#endif\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    sb_text_end_cmdline();\n\ntheend:\n    {\n\tchar_u *p = ccline.cmdbuff;\n\n\t--depth;\n\tif (did_save_ccline)\n\t    restore_cmdline(&save_ccline);\n\telse\n\t    ccline.cmdbuff = NULL;\n\treturn p;\n    }\n}\n\n#if (defined(FEAT_CRYPT) || defined(FEAT_EVAL)) || defined(PROTO)\n/*\n * Get a command line with a prompt.\n * This is prepared to be called recursively from getcmdline() (e.g. by\n * f_input() when evaluating an expression from CTRL-R =).\n * Returns the command line in allocated memory, or NULL.\n */\n    char_u *\ngetcmdline_prompt(\n    int\t\tfirstc,\n    char_u\t*prompt,\t// command line prompt\n    int\t\tattr,\t\t// attributes for prompt\n    int\t\txp_context,\t// type of expansion\n    char_u\t*xp_arg)\t// user-defined expansion argument\n{\n    char_u\t\t*s;\n    cmdline_info_T\tsave_ccline;\n    int\t\t\tdid_save_ccline = FALSE;\n    int\t\t\tmsg_col_save = msg_col;\n    int\t\t\tmsg_silent_save = msg_silent;\n\n    if (ccline.cmdbuff != NULL)\n    {\n\t// Save the values of the current cmdline and restore them below.\n\tsave_cmdline(&save_ccline);\n\tdid_save_ccline = TRUE;\n    }\n\n    CLEAR_FIELD(ccline);\n    ccline.cmdprompt = prompt;\n    ccline.cmdattr = attr;\n# ifdef FEAT_EVAL\n    ccline.xp_context = xp_context;\n    ccline.xp_arg = xp_arg;\n    ccline.input_fn = (firstc == '@');\n# endif\n    msg_silent = 0;\n    s = getcmdline_int(firstc, 1L, 0, FALSE);\n\n    if (did_save_ccline)\n\trestore_cmdline(&save_ccline);\n\n    msg_silent = msg_silent_save;\n    // Restore msg_col, the prompt from input() may have changed it.\n    // But only if called recursively and the commandline is therefore being\n    // restored to an old one; if not, the input() prompt stays on the screen,\n    // so we need its modified msg_col left intact.\n    if (ccline.cmdbuff != NULL)\n\tmsg_col = msg_col_save;\n\n    return s;\n}\n#endif\n\n/*\n * Read the 'wildmode' option, fill wim_flags[].\n */\n    int\ncheck_opt_wim(void)\n{\n    char_u\tnew_wim_flags[4];\n    char_u\t*p;\n    int\t\ti;\n    int\t\tidx = 0;\n\n    for (i = 0; i < 4; ++i)\n\tnew_wim_flags[i] = 0;\n\n    for (p = p_wim; *p; ++p)\n    {\n\tfor (i = 0; ASCII_ISALPHA(p[i]); ++i)\n\t    ;\n\tif (p[i] != NUL && p[i] != ',' && p[i] != ':')\n\t    return FAIL;\n\tif (i == 7 && STRNCMP(p, \"longest\", 7) == 0)\n\t    new_wim_flags[idx] |= WIM_LONGEST;\n\telse if (i == 4 && STRNCMP(p, \"full\", 4) == 0)\n\t    new_wim_flags[idx] |= WIM_FULL;\n\telse if (i == 4 && STRNCMP(p, \"list\", 4) == 0)\n\t    new_wim_flags[idx] |= WIM_LIST;\n\telse if (i == 8 && STRNCMP(p, \"lastused\", 8) == 0)\n\t    new_wim_flags[idx] |= WIM_BUFLASTUSED;\n\telse\n\t    return FAIL;\n\tp += i;\n\tif (*p == NUL)\n\t    break;\n\tif (*p == ',')\n\t{\n\t    if (idx == 3)\n\t\treturn FAIL;\n\t    ++idx;\n\t}\n    }\n\n    // fill remaining entries with last flag\n    while (idx < 3)\n    {\n\tnew_wim_flags[idx + 1] = new_wim_flags[idx];\n\t++idx;\n    }\n\n    // only when there are no errors, wim_flags[] is changed\n    for (i = 0; i < 4; ++i)\n\twim_flags[i] = new_wim_flags[i];\n    return OK;\n}\n\n/*\n * Return TRUE when the text must not be changed and we can't switch to\n * another window or buffer.  TRUE when editing the command line, evaluating\n * 'balloonexpr', etc.\n */\n    int\ntext_locked(void)\n{\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\treturn TRUE;\n#endif\n    return textlock != 0;\n}\n\n/*\n * Give an error message for a command that isn't allowed while the cmdline\n * window is open or editing the cmdline in another way.\n */\n    void\ntext_locked_msg(void)\n{\n    emsg(_(get_text_locked_msg()));\n}\n\n    char *\nget_text_locked_msg(void)\n{\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n\treturn e_invalid_in_cmdline_window;\n#endif\n    return e_not_allowed_to_change_text_or_change_window;\n}\n\n/*\n * Check for text, window or buffer locked.\n * Give an error message and return TRUE if something is locked.\n */\n    int\ntext_or_buf_locked(void)\n{\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn TRUE;\n    }\n    return curbuf_locked();\n}\n\n/*\n * Check if \"curbuf_lock\" or \"allbuf_lock\" is set and return TRUE when it is\n * and give an error message.\n */\n    int\ncurbuf_locked(void)\n{\n    if (curbuf_lock > 0)\n    {\n\temsg(_(e_not_allowed_to_edit_another_buffer_now));\n\treturn TRUE;\n    }\n    return allbuf_locked();\n}\n\n/*\n * Check if \"allbuf_lock\" is set and return TRUE when it is and give an error\n * message.\n */\n    int\nallbuf_locked(void)\n{\n    if (allbuf_lock > 0)\n    {\n\temsg(_(e_not_allowed_to_change_buffer_information_now));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n    static int\ncmdline_charsize(int idx)\n{\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n    if (cmdline_star > 0)\t    // showing '*', always 1 position\n\treturn 1;\n#endif\n    return ptr2cells(ccline.cmdbuff + idx);\n}\n\n/*\n * Compute the offset of the cursor on the command line for the prompt and\n * indent.\n */\n    static void\nset_cmdspos(void)\n{\n    if (ccline.cmdfirstc != NUL)\n\tccline.cmdspos = 1 + ccline.cmdindent;\n    else\n\tccline.cmdspos = 0 + ccline.cmdindent;\n}\n\n/*\n * Compute the screen position for the cursor on the command line.\n */\n    static void\nset_cmdspos_cursor(void)\n{\n    int\t\ti, m, c;\n\n    set_cmdspos();\n    if (KeyTyped)\n    {\n\tm = Columns * Rows;\n\tif (m < 0)\t// overflow, Columns or Rows at weird value\n\t    m = MAXCOL;\n    }\n    else\n\tm = MAXCOL;\n    for (i = 0; i < ccline.cmdlen && i < ccline.cmdpos; ++i)\n    {\n\tc = cmdline_charsize(i);\n\t// Count \">\" for double-wide multi-byte char that doesn't fit.\n\tif (has_mbyte)\n\t    correct_cmdspos(i, c);\n\t// If the cmdline doesn't fit, show cursor on last visible char.\n\t// Don't move the cursor itself, so we can still append.\n\tif ((ccline.cmdspos += c) >= m)\n\t{\n\t    ccline.cmdspos -= c;\n\t    break;\n\t}\n\tif (has_mbyte)\n\t    i += (*mb_ptr2len)(ccline.cmdbuff + i) - 1;\n    }\n}\n\n/*\n * Check if the character at \"idx\", which is \"cells\" wide, is a multi-byte\n * character that doesn't fit, so that a \">\" must be displayed.\n */\n    static void\ncorrect_cmdspos(int idx, int cells)\n{\n    if ((*mb_ptr2len)(ccline.cmdbuff + idx) > 1\n\t\t&& (*mb_ptr2cells)(ccline.cmdbuff + idx) > 1\n\t\t&& ccline.cmdspos % Columns + cells > Columns)\n\tccline.cmdspos++;\n}\n\n/*\n * Get an Ex command line for the \":\" command.\n */\n    char_u *\ngetexline(\n    int\t\tc,\t\t// normally ':', NUL for \":append\"\n    void\t*cookie UNUSED,\n    int\t\tindent,\t\t// indent for inside conditionals\n    getline_opt_T options)\n{\n    // When executing a register, remove ':' that's in front of each line.\n    if (exec_from_reg && vpeekc() == ':')\n\t(void)vgetc();\n    return getcmdline(c, 1L, indent, options);\n}\n\n/*\n * Get an Ex command line for Ex mode.\n * In Ex mode we only use the OS supplied line editing features and no\n * mappings or abbreviations.\n * Returns a string in allocated memory or NULL.\n */\n    char_u *\ngetexmodeline(\n    int\t\tpromptc,\t// normally ':', NUL for \":append\" and '?' for\n\t\t\t\t// :s prompt\n    void\t*cookie UNUSED,\n    int\t\tindent,\t\t// indent for inside conditionals\n    getline_opt_T options UNUSED)\n{\n    garray_T\tline_ga;\n    char_u\t*pend;\n    int\t\tstartcol = 0;\n    int\t\tc1 = 0;\n    int\t\tescaped = FALSE;\t// CTRL-V typed\n    int\t\tvcol = 0;\n    char_u\t*p;\n    int\t\tprev_char;\n    int\t\tlen;\n\n    // Switch cursor on now.  This avoids that it happens after the \"\\n\", which\n    // confuses the system function that computes tabstops.\n    cursor_on();\n\n    // always start in column 0; write a newline if necessary\n    compute_cmdrow();\n    if ((msg_col || msg_didout) && promptc != '?')\n\tmsg_putchar('\\n');\n    if (promptc == ':')\n    {\n\t// indent that is only displayed, not in the line itself\n\tif (p_prompt)\n\t    msg_putchar(':');\n\twhile (indent-- > 0)\n\t    msg_putchar(' ');\n\tstartcol = msg_col;\n    }\n\n    ga_init2(&line_ga, 1, 30);\n\n    // autoindent for :insert and :append is in the line itself\n    if (promptc <= 0)\n    {\n\tvcol = indent;\n\twhile (indent >= 8)\n\t{\n\t    ga_append(&line_ga, TAB);\n\t    msg_puts(\"        \");\n\t    indent -= 8;\n\t}\n\twhile (indent-- > 0)\n\t{\n\t    ga_append(&line_ga, ' ');\n\t    msg_putchar(' ');\n\t}\n    }\n    ++no_mapping;\n    ++allow_keys;\n\n    /*\n     * Get the line, one character at a time.\n     */\n    got_int = FALSE;\n    while (!got_int)\n    {\n\tlong    sw;\n\tchar_u *s;\n\n\tif (ga_grow(&line_ga, 40) == FAIL)\n\t    break;\n\n\t/*\n\t * Get one character at a time.\n\t */\n\tprev_char = c1;\n\n\t// Check for a \":normal\" command and no more characters left.\n\tif (ex_normal_busy > 0 && typebuf.tb_len == 0)\n\t    c1 = '\\n';\n\telse\n\t    c1 = vgetc();\n\n\t/*\n\t * Handle line editing.\n\t * Previously this was left to the system, putting the terminal in\n\t * cooked mode, but then CTRL-D and CTRL-T can't be used properly.\n\t */\n\tif (got_int)\n\t{\n\t    msg_putchar('\\n');\n\t    break;\n\t}\n\n\tif (c1 == K_PS)\n\t{\n\t    bracketed_paste(PASTE_EX, FALSE, &line_ga);\n\t    goto redraw;\n\t}\n\n\tif (!escaped)\n\t{\n\t    // CR typed means \"enter\", which is NL\n\t    if (c1 == '\\r')\n\t\tc1 = '\\n';\n\n\t    if (c1 == BS || c1 == K_BS\n\t\t\t  || c1 == DEL || c1 == K_DEL || c1 == K_KDEL)\n\t    {\n\t\tif (line_ga.ga_len > 0)\n\t\t{\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tp = (char_u *)line_ga.ga_data;\n\t\t\tp[line_ga.ga_len] = NUL;\n\t\t\tlen = (*mb_head_off)(p, p + line_ga.ga_len - 1) + 1;\n\t\t\tline_ga.ga_len -= len;\n\t\t    }\n\t\t    else\n\t\t\t--line_ga.ga_len;\n\t\t    goto redraw;\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    if (c1 == Ctrl_U)\n\t    {\n\t\tmsg_col = startcol;\n\t\tmsg_clr_eos();\n\t\tline_ga.ga_len = 0;\n\t\tgoto redraw;\n\t    }\n\n\t    if (c1 == Ctrl_T)\n\t    {\n\t\tsw = get_sw_value(curbuf);\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tp[line_ga.ga_len] = NUL;\n\t\tindent = get_indent_str(p, 8, FALSE);\n\t\tindent += sw - indent % sw;\nadd_indent:\n\t\twhile (get_indent_str(p, 8, FALSE) < indent)\n\t\t{\n\t\t    (void)ga_grow(&line_ga, 2);  // one more for the NUL\n\t\t    p = (char_u *)line_ga.ga_data;\n\t\t    s = skipwhite(p);\n\t\t    mch_memmove(s + 1, s, line_ga.ga_len - (s - p) + 1);\n\t\t    *s = ' ';\n\t\t    ++line_ga.ga_len;\n\t\t}\nredraw:\n\t\t// redraw the line\n\t\tmsg_col = startcol;\n\t\tvcol = 0;\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tp[line_ga.ga_len] = NUL;\n\t\twhile (p < (char_u *)line_ga.ga_data + line_ga.ga_len)\n\t\t{\n\t\t    if (*p == TAB)\n\t\t    {\n\t\t\tdo\n\t\t\t    msg_putchar(' ');\n\t\t\twhile (++vcol % 8);\n\t\t\t++p;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tlen = mb_ptr2len(p);\n\t\t\tmsg_outtrans_len(p, len);\n\t\t\tvcol += ptr2cells(p);\n\t\t\tp += len;\n\t\t    }\n\t\t}\n\t\tmsg_clr_eos();\n\t\twindgoto(msg_row, msg_col);\n\t\tcontinue;\n\t    }\n\n\t    if (c1 == Ctrl_D)\n\t    {\n\t\t// Delete one shiftwidth.\n\t\tp = (char_u *)line_ga.ga_data;\n\t\tif (prev_char == '0' || prev_char == '^')\n\t\t{\n\t\t    if (prev_char == '^')\n\t\t\tex_keep_indent = TRUE;\n\t\t    indent = 0;\n\t\t    p[--line_ga.ga_len] = NUL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[line_ga.ga_len] = NUL;\n\t\t    indent = get_indent_str(p, 8, FALSE);\n\t\t    if (indent > 0)\n\t\t    {\n\t\t\t--indent;\n\t\t\tindent -= indent % get_sw_value(curbuf);\n\t\t    }\n\t\t}\n\t\twhile (get_indent_str(p, 8, FALSE) > indent)\n\t\t{\n\t\t    s = skipwhite(p);\n\t\t    mch_memmove(s - 1, s, line_ga.ga_len - (s - p) + 1);\n\t\t    --line_ga.ga_len;\n\t\t}\n\t\tgoto add_indent;\n\t    }\n\n\t    if (c1 == Ctrl_V || c1 == Ctrl_Q)\n\t    {\n\t\tescaped = TRUE;\n\t\tcontinue;\n\t    }\n\n\t    // Ignore special key codes: mouse movement, K_IGNORE, etc.\n\t    if (IS_SPECIAL(c1))\n\t\tcontinue;\n\t}\n\n\tif (IS_SPECIAL(c1))\n\t    c1 = '?';\n\tif (has_mbyte)\n\t    len = (*mb_char2bytes)(c1,\n\t\t\t\t  (char_u *)line_ga.ga_data + line_ga.ga_len);\n\telse\n\t{\n\t    len = 1;\n\t    ((char_u *)line_ga.ga_data)[line_ga.ga_len] = c1;\n\t}\n\tif (c1 == '\\n')\n\t    msg_putchar('\\n');\n\telse if (c1 == TAB)\n\t{\n\t    // Don't use chartabsize(), 'ts' can be different\n\t    do\n\t\tmsg_putchar(' ');\n\t    while (++vcol % 8);\n\t}\n\telse\n\t{\n\t    msg_outtrans_len(\n\t\t     ((char_u *)line_ga.ga_data) + line_ga.ga_len, len);\n\t    vcol += char2cells(c1);\n\t}\n\tline_ga.ga_len += len;\n\tescaped = FALSE;\n\n\twindgoto(msg_row, msg_col);\n\tpend = (char_u *)(line_ga.ga_data) + line_ga.ga_len;\n\n\t// We are done when a NL is entered, but not when it comes after an\n\t// odd number of backslashes, that results in a NUL.\n\tif (line_ga.ga_len > 0 && pend[-1] == '\\n')\n\t{\n\t    int bcount = 0;\n\n\t    while (line_ga.ga_len - 2 >= bcount && pend[-2 - bcount] == '\\\\')\n\t\t++bcount;\n\n\t    if (bcount > 0)\n\t    {\n\t\t// Halve the number of backslashes: \"\\NL\" -> \"NUL\", \"\\\\NL\" ->\n\t\t// \"\\NL\", etc.\n\t\tline_ga.ga_len -= (bcount + 1) / 2;\n\t\tpend -= (bcount + 1) / 2;\n\t\tpend[-1] = '\\n';\n\t    }\n\n\t    if ((bcount & 1) == 0)\n\t    {\n\t\t--line_ga.ga_len;\n\t\t--pend;\n\t\t*pend = NUL;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    --no_mapping;\n    --allow_keys;\n\n    // make following messages go to the next line\n    msg_didout = FALSE;\n    msg_col = 0;\n    if (msg_row < Rows - 1)\n\t++msg_row;\n    emsg_on_display = FALSE;\t\t// don't want ui_delay()\n\n    if (got_int)\n\tga_clear(&line_ga);\n\n    return (char_u *)line_ga.ga_data;\n}\n\n# if defined(MCH_CURSOR_SHAPE) || defined(FEAT_GUI) \\\n\t|| defined(FEAT_MOUSESHAPE) || defined(PROTO)\n/*\n * Return TRUE if ccline.overstrike is on.\n */\n    int\ncmdline_overstrike(void)\n{\n    return ccline.overstrike;\n}\n\n/*\n * Return TRUE if the cursor is at the end of the cmdline.\n */\n    int\ncmdline_at_end(void)\n{\n    return (ccline.cmdpos >= ccline.cmdlen);\n}\n#endif\n\n#if (defined(FEAT_XIM) && (defined(FEAT_GUI_GTK))) || defined(PROTO)\n/*\n * Return the virtual column number at the current cursor position.\n * This is used by the IM code to obtain the start of the preedit string.\n */\n    colnr_T\ncmdline_getvcol_cursor(void)\n{\n    if (ccline.cmdbuff == NULL || ccline.cmdpos > ccline.cmdlen)\n\treturn MAXCOL;\n\n    if (has_mbyte)\n    {\n\tcolnr_T\tcol;\n\tint\ti = 0;\n\n\tfor (col = 0; i < ccline.cmdpos; ++col)\n\t    i += (*mb_ptr2len)(ccline.cmdbuff + i);\n\n\treturn col;\n    }\n    else\n\treturn ccline.cmdpos;\n}\n#endif\n\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n/*\n * If part of the command line is an IM preedit string, redraw it with\n * IM feedback attributes.  The cursor position is restored after drawing.\n */\n    static void\nredrawcmd_preedit(void)\n{\n    if ((State & MODE_CMDLINE)\n\t    && xic != NULL\n\t    // && im_get_status()  doesn't work when using SCIM\n\t    && !p_imdisable\n\t    && im_is_preediting())\n    {\n\tint\tcmdpos = 0;\n\tint\tcmdspos;\n\tint\told_row;\n\tint\told_col;\n\tcolnr_T\tcol;\n\n\told_row = msg_row;\n\told_col = msg_col;\n\tcmdspos = ((ccline.cmdfirstc != NUL) ? 1 : 0) + ccline.cmdindent;\n\n\tif (has_mbyte)\n\t{\n\t    for (col = 0; col < preedit_start_col\n\t\t\t  && cmdpos < ccline.cmdlen; ++col)\n\t    {\n\t\tcmdspos += (*mb_ptr2cells)(ccline.cmdbuff + cmdpos);\n\t\tcmdpos  += (*mb_ptr2len)(ccline.cmdbuff + cmdpos);\n\t    }\n\t}\n\telse\n\t{\n\t    cmdspos += preedit_start_col;\n\t    cmdpos  += preedit_start_col;\n\t}\n\n\tmsg_row = cmdline_row + (cmdspos / (int)Columns);\n\tmsg_col = cmdspos % (int)Columns;\n\tif (msg_row >= Rows)\n\t    msg_row = Rows - 1;\n\n\tfor (col = 0; cmdpos < ccline.cmdlen; ++col)\n\t{\n\t    int char_len;\n\t    int char_attr;\n\n\t    char_attr = im_get_feedback_attr(col);\n\t    if (char_attr < 0)\n\t\tbreak; // end of preedit string\n\n\t    if (has_mbyte)\n\t\tchar_len = (*mb_ptr2len)(ccline.cmdbuff + cmdpos);\n\t    else\n\t\tchar_len = 1;\n\n\t    msg_outtrans_len_attr(ccline.cmdbuff + cmdpos, char_len, char_attr);\n\t    cmdpos += char_len;\n\t}\n\n\tmsg_row = old_row;\n\tmsg_col = old_col;\n    }\n}\n#endif // FEAT_XIM && FEAT_GUI_GTK\n\n/*\n * Allocate a new command line buffer.\n * Assigns the new buffer to ccline.cmdbuff and ccline.cmdbufflen.\n */\n    static void\nalloc_cmdbuff(int len)\n{\n    /*\n     * give some extra space to avoid having to allocate all the time\n     */\n    if (len < 80)\n\tlen = 100;\n    else\n\tlen += 20;\n\n    ccline.cmdbuff = alloc(len);    // caller should check for out-of-memory\n    ccline.cmdbufflen = len;\n}\n\n/*\n * Re-allocate the command line to length len + something extra.\n * return FAIL for failure, OK otherwise\n */\n    int\nrealloc_cmdbuff(int len)\n{\n    char_u\t*p;\n\n    if (len < ccline.cmdbufflen)\n\treturn OK;\t\t\t// no need to resize\n\n    p = ccline.cmdbuff;\n    alloc_cmdbuff(len);\t\t\t// will get some more\n    if (ccline.cmdbuff == NULL)\t\t// out of memory\n    {\n\tccline.cmdbuff = p;\t\t// keep the old one\n\treturn FAIL;\n    }\n    // There isn't always a NUL after the command, but it may need to be\n    // there, thus copy up to the NUL and add a NUL.\n    mch_memmove(ccline.cmdbuff, p, (size_t)ccline.cmdlen);\n    ccline.cmdbuff[ccline.cmdlen] = NUL;\n    vim_free(p);\n\n    if (ccline.xpc != NULL\n\t    && ccline.xpc->xp_pattern != NULL\n\t    && ccline.xpc->xp_context != EXPAND_NOTHING\n\t    && ccline.xpc->xp_context != EXPAND_UNSUCCESSFUL)\n    {\n\tint i = (int)(ccline.xpc->xp_pattern - p);\n\n\t// If xp_pattern points inside the old cmdbuff it needs to be adjusted\n\t// to point into the newly allocated memory.\n\tif (i >= 0 && i <= ccline.cmdlen)\n\t    ccline.xpc->xp_pattern = ccline.cmdbuff + i;\n    }\n\n    return OK;\n}\n\n#if defined(FEAT_ARABIC) || defined(PROTO)\nstatic char_u\t*arshape_buf = NULL;\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_arshape_buf(void)\n{\n    vim_free(arshape_buf);\n}\n# endif\n#endif\n\n/*\n * Draw part of the cmdline at the current cursor position.  But draw stars\n * when cmdline_star is TRUE.\n */\n    static void\ndraw_cmdline(int start, int len)\n{\n#if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n    int\t\ti;\n\n    if (cmdline_star > 0)\n\tfor (i = 0; i < len; ++i)\n\t{\n\t    msg_putchar('*');\n\t    if (has_mbyte)\n\t\ti += (*mb_ptr2len)(ccline.cmdbuff + start + i) - 1;\n\t}\n    else\n#endif\n#ifdef FEAT_ARABIC\n\tif (p_arshape && !p_tbidi && cmdline_has_arabic(start, len))\n    {\n\tstatic int\tbuflen = 0;\n\tchar_u\t\t*p;\n\tint\t\tj;\n\tint\t\tnewlen = 0;\n\tint\t\tmb_l;\n\tint\t\tpc, pc1 = 0;\n\tint\t\tprev_c = 0;\n\tint\t\tprev_c1 = 0;\n\tint\t\tu8c;\n\tint\t\tu8cc[MAX_MCO];\n\tint\t\tnc = 0;\n\n\t/*\n\t * Do arabic shaping into a temporary buffer.  This is very\n\t * inefficient!\n\t */\n\tif (len * 2 + 2 > buflen)\n\t{\n\t    // Re-allocate the buffer.  We keep it around to avoid a lot of\n\t    // alloc()/free() calls.\n\t    vim_free(arshape_buf);\n\t    buflen = len * 2 + 2;\n\t    arshape_buf = alloc(buflen);\n\t    if (arshape_buf == NULL)\n\t\treturn;\t// out of memory\n\t}\n\n\tif (utf_iscomposing(utf_ptr2char(ccline.cmdbuff + start)))\n\t{\n\t    // Prepend a space to draw the leading composing char on.\n\t    arshape_buf[0] = ' ';\n\t    newlen = 1;\n\t}\n\n\tfor (j = start; j < start + len; j += mb_l)\n\t{\n\t    p = ccline.cmdbuff + j;\n\t    u8c = utfc_ptr2char_len(p, u8cc, start + len - j);\n\t    mb_l = utfc_ptr2len_len(p, start + len - j);\n\t    if (ARABIC_CHAR(u8c))\n\t    {\n\t\t// Do Arabic shaping.\n\t\tif (cmdmsg_rl)\n\t\t{\n\t\t    // displaying from right to left\n\t\t    pc = prev_c;\n\t\t    pc1 = prev_c1;\n\t\t    prev_c1 = u8cc[0];\n\t\t    if (j + mb_l >= start + len)\n\t\t\tnc = NUL;\n\t\t    else\n\t\t\tnc = utf_ptr2char(p + mb_l);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // displaying from left to right\n\t\t    if (j + mb_l >= start + len)\n\t\t\tpc = NUL;\n\t\t    else\n\t\t    {\n\t\t\tint\tpcc[MAX_MCO];\n\n\t\t\tpc = utfc_ptr2char_len(p + mb_l, pcc,\n\t\t\t\t\t\t      start + len - j - mb_l);\n\t\t\tpc1 = pcc[0];\n\t\t    }\n\t\t    nc = prev_c;\n\t\t}\n\t\tprev_c = u8c;\n\n\t\tu8c = arabic_shape(u8c, NULL, &u8cc[0], pc, pc1, nc);\n\n\t\tnewlen += (*mb_char2bytes)(u8c, arshape_buf + newlen);\n\t\tif (u8cc[0] != 0)\n\t\t{\n\t\t    newlen += (*mb_char2bytes)(u8cc[0], arshape_buf + newlen);\n\t\t    if (u8cc[1] != 0)\n\t\t\tnewlen += (*mb_char2bytes)(u8cc[1],\n\t\t\t\t\t\t\tarshape_buf + newlen);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tprev_c = u8c;\n\t\tmch_memmove(arshape_buf + newlen, p, mb_l);\n\t\tnewlen += mb_l;\n\t    }\n\t}\n\n\tmsg_outtrans_len(arshape_buf, newlen);\n    }\n    else\n#endif\n\tmsg_outtrans_len(ccline.cmdbuff + start, len);\n}\n\n/*\n * Put a character on the command line.  Shifts the following text to the\n * right when \"shift\" is TRUE.  Used for CTRL-V, CTRL-K, etc.\n * \"c\" must be printable (fit in one display cell)!\n */\n    void\nputcmdline(int c, int shift)\n{\n    if (cmd_silent)\n\treturn;\n    msg_no_more = TRUE;\n    msg_putchar(c);\n    if (shift)\n\tdraw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);\n    msg_no_more = FALSE;\n    cursorcmd();\n    extra_char = c;\n    extra_char_shift = shift;\n}\n\n/*\n * Undo a putcmdline(c, FALSE).\n */\n    void\nunputcmdline(void)\n{\n    if (cmd_silent)\n\treturn;\n    msg_no_more = TRUE;\n    if (ccline.cmdlen == ccline.cmdpos)\n\tmsg_putchar(' ');\n    else if (has_mbyte)\n\tdraw_cmdline(ccline.cmdpos,\n\t\t\t       (*mb_ptr2len)(ccline.cmdbuff + ccline.cmdpos));\n    else\n\tdraw_cmdline(ccline.cmdpos, 1);\n    msg_no_more = FALSE;\n    cursorcmd();\n    extra_char = NUL;\n}\n\n/*\n * Put the given string, of the given length, onto the command line.\n * If len is -1, then STRLEN() is used to calculate the length.\n * If 'redraw' is TRUE then the new part of the command line, and the remaining\n * part will be redrawn, otherwise it will not.  If this function is called\n * twice in a row, then 'redraw' should be FALSE and redrawcmd() should be\n * called afterwards.\n */\n    int\nput_on_cmdline(char_u *str, int len, int redraw)\n{\n    int\t\tretval;\n    int\t\ti;\n    int\t\tm;\n    int\t\tc;\n\n    if (len < 0)\n\tlen = (int)STRLEN(str);\n\n    // Check if ccline.cmdbuff needs to be longer\n    if (ccline.cmdlen + len + 1 >= ccline.cmdbufflen)\n\tretval = realloc_cmdbuff(ccline.cmdlen + len + 1);\n    else\n\tretval = OK;\n    if (retval == OK)\n    {\n\tif (!ccline.overstrike)\n\t{\n\t    mch_memmove(ccline.cmdbuff + ccline.cmdpos + len,\n\t\t\t\t\t       ccline.cmdbuff + ccline.cmdpos,\n\t\t\t\t     (size_t)(ccline.cmdlen - ccline.cmdpos));\n\t    ccline.cmdlen += len;\n\t}\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\t// Count nr of characters in the new string.\n\t\tm = 0;\n\t\tfor (i = 0; i < len; i += (*mb_ptr2len)(str + i))\n\t\t    ++m;\n\t\t// Count nr of bytes in cmdline that are overwritten by these\n\t\t// characters.\n\t\tfor (i = ccline.cmdpos; i < ccline.cmdlen && m > 0;\n\t\t\t\t i += (*mb_ptr2len)(ccline.cmdbuff + i))\n\t\t    --m;\n\t\tif (i < ccline.cmdlen)\n\t\t{\n\t\t    mch_memmove(ccline.cmdbuff + ccline.cmdpos + len,\n\t\t\t    ccline.cmdbuff + i, (size_t)(ccline.cmdlen - i));\n\t\t    ccline.cmdlen += ccline.cmdpos + len - i;\n\t\t}\n\t\telse\n\t\t    ccline.cmdlen = ccline.cmdpos + len;\n\t    }\n\t    else if (ccline.cmdpos + len > ccline.cmdlen)\n\t\tccline.cmdlen = ccline.cmdpos + len;\n\t}\n\tmch_memmove(ccline.cmdbuff + ccline.cmdpos, str, (size_t)len);\n\tccline.cmdbuff[ccline.cmdlen] = NUL;\n\n\tif (enc_utf8)\n\t{\n\t    // When the inserted text starts with a composing character,\n\t    // backup to the character before it.  There could be two of them.\n\t    i = 0;\n\t    c = utf_ptr2char(ccline.cmdbuff + ccline.cmdpos);\n\t    while (ccline.cmdpos > 0 && utf_iscomposing(c))\n\t    {\n\t\ti = (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t      ccline.cmdbuff + ccline.cmdpos - 1) + 1;\n\t\tccline.cmdpos -= i;\n\t\tlen += i;\n\t\tc = utf_ptr2char(ccline.cmdbuff + ccline.cmdpos);\n\t    }\n#ifdef FEAT_ARABIC\n\t    if (i == 0 && ccline.cmdpos > 0 && arabic_maycombine(c))\n\t    {\n\t\t// Check the previous character for Arabic combining pair.\n\t\ti = (*mb_head_off)(ccline.cmdbuff,\n\t\t\t\t      ccline.cmdbuff + ccline.cmdpos - 1) + 1;\n\t\tif (arabic_combine(utf_ptr2char(ccline.cmdbuff\n\t\t\t\t\t\t     + ccline.cmdpos - i), c))\n\t\t{\n\t\t    ccline.cmdpos -= i;\n\t\t    len += i;\n\t\t}\n\t\telse\n\t\t    i = 0;\n\t    }\n#endif\n\t    if (i != 0)\n\t    {\n\t\t// Also backup the cursor position.\n\t\ti = ptr2cells(ccline.cmdbuff + ccline.cmdpos);\n\t\tccline.cmdspos -= i;\n\t\tmsg_col -= i;\n\t\tif (msg_col < 0)\n\t\t{\n\t\t    msg_col += Columns;\n\t\t    --msg_row;\n\t\t}\n\t    }\n\t}\n\n\tif (redraw && !cmd_silent)\n\t{\n\t    msg_no_more = TRUE;\n\t    i = cmdline_row;\n\t    cursorcmd();\n\t    draw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);\n\t    // Avoid clearing the rest of the line too often.\n\t    if (cmdline_row != i || ccline.overstrike)\n\t\tmsg_clr_eos();\n\t    msg_no_more = FALSE;\n\t}\n\tif (KeyTyped)\n\t{\n\t    m = Columns * Rows;\n\t    if (m < 0)\t// overflow, Columns or Rows at weird value\n\t\tm = MAXCOL;\n\t}\n\telse\n\t    m = MAXCOL;\n\tfor (i = 0; i < len; ++i)\n\t{\n\t    c = cmdline_charsize(ccline.cmdpos);\n\t    // count \">\" for a double-wide char that doesn't fit.\n\t    if (has_mbyte)\n\t\tcorrect_cmdspos(ccline.cmdpos, c);\n\t    // Stop cursor at the end of the screen, but do increment the\n\t    // insert position, so that entering a very long command\n\t    // works, even though you can't see it.\n\t    if (ccline.cmdspos + c < m)\n\t\tccline.cmdspos += c;\n\n\t    if (has_mbyte)\n\t    {\n\t\tc = (*mb_ptr2len)(ccline.cmdbuff + ccline.cmdpos) - 1;\n\t\tif (c > len - i - 1)\n\t\t    c = len - i - 1;\n\t\tccline.cmdpos += c;\n\t\ti += c;\n\t    }\n\t    ++ccline.cmdpos;\n\t}\n    }\n    if (redraw)\n\tmsg_check();\n    return retval;\n}\n\nstatic cmdline_info_T\tprev_ccline;\nstatic int\t\tprev_ccline_used = FALSE;\n\n/*\n * Save ccline, because obtaining the \"=\" register may execute \"normal :cmd\"\n * and overwrite it.  But get_cmdline_str() may need it, thus make it\n * available globally in prev_ccline.\n */\n    static void\nsave_cmdline(cmdline_info_T *ccp)\n{\n    if (!prev_ccline_used)\n    {\n\tCLEAR_FIELD(prev_ccline);\n\tprev_ccline_used = TRUE;\n    }\n    *ccp = prev_ccline;\n    prev_ccline = ccline;\n    ccline.cmdbuff = NULL;  // signal that ccline is not in use\n}\n\n/*\n * Restore ccline after it has been saved with save_cmdline().\n */\n    static void\nrestore_cmdline(cmdline_info_T *ccp)\n{\n    ccline = prev_ccline;\n    prev_ccline = *ccp;\n}\n\n/*\n * Paste a yank register into the command line.\n * Used by CTRL-R command in command-line mode.\n * insert_reg() can't be used here, because special characters from the\n * register contents will be interpreted as commands.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    static int\ncmdline_paste(\n    int regname,\n    int literally,\t// Insert text literally instead of \"as typed\"\n    int remcr)\t\t// remove trailing CR\n{\n    long\t\ti;\n    char_u\t\t*arg;\n    char_u\t\t*p;\n    int\t\t\tallocated;\n\n    // check for valid regname; also accept special characters for CTRL-R in\n    // the command line\n    if (regname != Ctrl_F && regname != Ctrl_P && regname != Ctrl_W\n\t    && regname != Ctrl_A && regname != Ctrl_L\n\t    && !valid_yank_reg(regname, FALSE))\n\treturn FAIL;\n\n    // A register containing CTRL-R can cause an endless loop.  Allow using\n    // CTRL-C to break the loop.\n    line_breakcheck();\n    if (got_int)\n\treturn FAIL;\n\n#ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n#endif\n\n    // Need to set \"textlock\" to avoid nasty things like going to another\n    // buffer when evaluating an expression.\n    ++textlock;\n    i = get_spec_reg(regname, &arg, &allocated, TRUE);\n    --textlock;\n\n    if (i)\n    {\n\t// Got the value of a special register in \"arg\".\n\tif (arg == NULL)\n\t    return FAIL;\n\n\t// When 'incsearch' is set and CTRL-R CTRL-W used: skip the duplicate\n\t// part of the word.\n\tp = arg;\n\tif (p_is && regname == Ctrl_W)\n\t{\n\t    char_u  *w;\n\t    int\t    len;\n\n\t    // Locate start of last word in the cmd buffer.\n\t    for (w = ccline.cmdbuff + ccline.cmdpos; w > ccline.cmdbuff; )\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    len = (*mb_head_off)(ccline.cmdbuff, w - 1) + 1;\n\t\t    if (!vim_iswordc(mb_ptr2char(w - len)))\n\t\t\tbreak;\n\t\t    w -= len;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (!vim_iswordc(w[-1]))\n\t\t\tbreak;\n\t\t    --w;\n\t\t}\n\t    }\n\t    len = (int)((ccline.cmdbuff + ccline.cmdpos) - w);\n\t    if (p_ic ? STRNICMP(w, arg, len) == 0 : STRNCMP(w, arg, len) == 0)\n\t\tp += len;\n\t}\n\n\tcmdline_paste_str(p, literally);\n\tif (allocated)\n\t    vim_free(arg);\n\treturn OK;\n    }\n\n    return cmdline_paste_reg(regname, literally, remcr);\n}\n\n/*\n * Put a string on the command line.\n * When \"literally\" is TRUE, insert literally.\n * When \"literally\" is FALSE, insert as typed, but don't leave the command\n * line.\n */\n    void\ncmdline_paste_str(char_u *s, int literally)\n{\n    int\t\tc, cv;\n\n    if (literally)\n\tput_on_cmdline(s, -1, TRUE);\n    else\n\twhile (*s != NUL)\n\t{\n\t    cv = *s;\n\t    if (cv == Ctrl_V && s[1])\n\t\t++s;\n\t    if (has_mbyte)\n\t\tc = mb_cptr2char_adv(&s);\n\t    else\n\t\tc = *s++;\n\t    if (cv == Ctrl_V || c == ESC || c == Ctrl_C\n\t\t    || c == CAR || c == NL || c == Ctrl_L\n#ifdef UNIX\n\t\t    || c == intr_char\n#endif\n\t\t    || (c == Ctrl_BSL && *s == Ctrl_N))\n\t\tstuffcharReadbuff(Ctrl_V);\n\t    stuffcharReadbuff(c);\n\t}\n}\n\n/*\n * This function is called when the screen size changes and with incremental\n * search and in other situations where the command line may have been\n * overwritten.\n */\n    void\nredrawcmdline(void)\n{\n    redrawcmdline_ex(TRUE);\n}\n\n/*\n * When \"do_compute_cmdrow\" is TRUE the command line is redrawn at the bottom.\n * If FALSE cmdline_row is used, which should redraw in the same place.\n */\n    void\nredrawcmdline_ex(int do_compute_cmdrow)\n{\n    if (cmd_silent)\n\treturn;\n    need_wait_return = FALSE;\n    if (do_compute_cmdrow)\n\tcompute_cmdrow();\n    redrawcmd();\n    cursorcmd();\n}\n\n    static void\nredrawcmdprompt(void)\n{\n    int\t\ti;\n\n    if (cmd_silent)\n\treturn;\n    if (ccline.cmdfirstc != NUL)\n\tmsg_putchar(ccline.cmdfirstc);\n    if (ccline.cmdprompt != NULL)\n    {\n\tmsg_puts_attr((char *)ccline.cmdprompt, ccline.cmdattr);\n\tccline.cmdindent = msg_col + (msg_row - cmdline_row) * Columns;\n\t// do the reverse of set_cmdspos()\n\tif (ccline.cmdfirstc != NUL)\n\t    --ccline.cmdindent;\n    }\n    else\n\tfor (i = ccline.cmdindent; i > 0; --i)\n\t    msg_putchar(' ');\n}\n\n/*\n * Redraw what is currently on the command line.\n */\n    void\nredrawcmd(void)\n{\n    int save_in_echowindow = in_echowindow;\n\n    if (cmd_silent)\n\treturn;\n\n    // when 'incsearch' is set there may be no command line while redrawing\n    if (ccline.cmdbuff == NULL)\n    {\n\twindgoto(cmdline_row, 0);\n\tmsg_clr_eos();\n\treturn;\n    }\n\n    // Do not put this in the message window.\n    in_echowindow = FALSE;\n\n    sb_text_restart_cmdline();\n    msg_start();\n    redrawcmdprompt();\n\n    // Don't use more prompt, truncate the cmdline if it doesn't fit.\n    msg_no_more = TRUE;\n    draw_cmdline(0, ccline.cmdlen);\n    msg_clr_eos();\n    msg_no_more = FALSE;\n\n    set_cmdspos_cursor();\n    if (extra_char != NUL)\n\tputcmdline(extra_char, extra_char_shift);\n\n    /*\n     * An emsg() before may have set msg_scroll. This is used in normal mode,\n     * in cmdline mode we can reset them now.\n     */\n    msg_scroll = FALSE;\t\t// next message overwrites cmdline\n\n    // Typing ':' at the more prompt may set skip_redraw.  We don't want this\n    // in cmdline mode\n    skip_redraw = FALSE;\n\n    in_echowindow = save_in_echowindow;\n}\n\n    void\ncompute_cmdrow(void)\n{\n    // ignore \"msg_scrolled\" in update_screen(), it will be reset soon.\n    if (exmode_active || (msg_scrolled != 0 && !updating_screen))\n\tcmdline_row = Rows - 1;\n    else\n\tcmdline_row = W_WINROW(lastwin) + lastwin->w_height\n\t\t\t\t\t\t    + lastwin->w_status_height;\n}\n\n    void\ncursorcmd(void)\n{\n    if (cmd_silent)\n\treturn;\n\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n    {\n\tmsg_row = cmdline_row  + (ccline.cmdspos / (int)(Columns - 1));\n\tmsg_col = (int)Columns - (ccline.cmdspos % (int)(Columns - 1)) - 1;\n\tif (msg_row <= 0)\n\t    msg_row = Rows - 1;\n    }\n    else\n#endif\n    {\n\tmsg_row = cmdline_row + (ccline.cmdspos / (int)Columns);\n\tmsg_col = ccline.cmdspos % (int)Columns;\n\tif (msg_row >= Rows)\n\t    msg_row = Rows - 1;\n    }\n\n    windgoto(msg_row, msg_col);\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    if (p_imst == IM_ON_THE_SPOT)\n\tredrawcmd_preedit();\n#endif\n#ifdef MCH_CURSOR_SHAPE\n    mch_update_cursor();\n#endif\n}\n\n    void\ngotocmdline(int clr)\n{\n    msg_start();\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n\tmsg_col = Columns - 1;\n    else\n#endif\n\tmsg_col = 0;\t    // always start in column 0\n    if (clr)\t\t    // clear the bottom line(s)\n\tmsg_clr_eos();\t    // will reset clear_cmdline\n    windgoto(cmdline_row, 0);\n}\n\n/*\n * Check the word in front of the cursor for an abbreviation.\n * Called when the non-id character \"c\" has been entered.\n * When an abbreviation is recognized it is removed from the text with\n * backspaces and the replacement string is inserted, followed by \"c\".\n */\n    static int\nccheck_abbr(int c)\n{\n    int spos = 0;\n\n    if (p_paste || no_abbr)\t    // no abbreviations or in paste mode\n\treturn FALSE;\n\n    // Do not consider '<,'> be part of the mapping, skip leading whitespace.\n    // Actually accepts any mark.\n    while (VIM_ISWHITE(ccline.cmdbuff[spos]) && spos < ccline.cmdlen)\n\tspos++;\n    if (ccline.cmdlen - spos > 5\n\t    && ccline.cmdbuff[spos] == '\\''\n\t    && ccline.cmdbuff[spos + 2] == ','\n\t    && ccline.cmdbuff[spos + 3] == '\\'')\n\tspos += 5;\n    else\n\t// check abbreviation from the beginning of the commandline\n\tspos = 0;\n\n    return check_abbr(c, ccline.cmdbuff, ccline.cmdpos, spos);\n}\n\n/*\n * Escape special characters in \"fname\", depending on \"what\":\n * VSE_NONE: for when used as a file name argument after a Vim command.\n * VSE_SHELL: for a shell command.\n * VSE_BUFFER: for the \":buffer\" command.\n * Returns the result in allocated memory.\n */\n    char_u *\nvim_strsave_fnameescape(char_u *fname, int what)\n{\n    char_u\t*p;\n#ifdef BACKSLASH_IN_FILENAME\n    char_u\tbuf[20];\n    int\t\tj = 0;\n\n    // Don't escape '[', '{' and '!' if they are in 'isfname' and for the\n    // \":buffer\" command.\n    for (p = what == VSE_BUFFER ? BUFFER_ESC_CHARS : PATH_ESC_CHARS;\n\t\t\t\t\t\t\t\t*p != NUL; ++p)\n\tif ((*p != '[' && *p != '{' && *p != '!') || !vim_isfilec(*p))\n\t    buf[j++] = *p;\n    buf[j] = NUL;\n    p = vim_strsave_escaped(fname, buf);\n#else\n    p = vim_strsave_escaped(fname, what == VSE_SHELL ? SHELL_ESC_CHARS\n\t\t    : what == VSE_BUFFER ? BUFFER_ESC_CHARS : PATH_ESC_CHARS);\n    if (what == VSE_SHELL && csh_like_shell() && p != NULL)\n    {\n\tchar_u\t    *s;\n\n\t// For csh and similar shells need to put two backslashes before '!'.\n\t// One is taken by Vim, one by the shell.\n\ts = vim_strsave_escaped(p, (char_u *)\"!\");\n\tvim_free(p);\n\tp = s;\n    }\n#endif\n\n    // '>' and '+' are special at the start of some commands, e.g. \":edit\" and\n    // \":write\".  \"cd -\" has a special meaning.\n    if (p != NULL && (*p == '>' || *p == '+' || (*p == '-' && p[1] == NUL)))\n\tescape_fname(&p);\n\n    return p;\n}\n\n/*\n * Put a backslash before the file name in \"pp\", which is in allocated memory.\n */\n    void\nescape_fname(char_u **pp)\n{\n    char_u\t*p;\n\n    p = alloc(STRLEN(*pp) + 2);\n    if (p != NULL)\n    {\n\tp[0] = '\\\\';\n\tSTRCPY(p + 1, *pp);\n\tvim_free(*pp);\n\t*pp = p;\n    }\n}\n\n/*\n * For each file name in files[num_files]:\n * If 'orig_pat' starts with \"~/\", replace the home directory with \"~\".\n */\n    void\ntilde_replace(\n    char_u  *orig_pat,\n    int\t    num_files,\n    char_u  **files)\n{\n    int\t    i;\n    char_u  *p;\n\n    if (orig_pat[0] == '~' && vim_ispathsep(orig_pat[1]))\n    {\n\tfor (i = 0; i < num_files; ++i)\n\t{\n\t    p = home_replace_save(NULL, files[i]);\n\t    if (p != NULL)\n\t    {\n\t\tvim_free(files[i]);\n\t\tfiles[i] = p;\n\t    }\n\t}\n    }\n}\n\n/*\n * Get a pointer to the current command line info.\n */\n    cmdline_info_T *\nget_cmdline_info(void)\n{\n    return &ccline;\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_CMDWIN) || defined(PROTO)\n/*\n * Get pointer to the command line info to use. save_cmdline() may clear\n * ccline and put the previous value in prev_ccline.\n */\n    static cmdline_info_T *\nget_ccline_ptr(void)\n{\n    if ((State & MODE_CMDLINE) == 0)\n\treturn NULL;\n    if (ccline.cmdbuff != NULL)\n\treturn &ccline;\n    if (prev_ccline_used && prev_ccline.cmdbuff != NULL)\n\treturn &prev_ccline;\n    return NULL;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(FEAT_CMDWIN)\n/*\n * Get the current command-line type.\n * Returns ':' or '/' or '?' or '@' or '>' or '-'\n * Only works when the command line is being edited.\n * Returns NUL when something is wrong.\n */\n    static int\nget_cmdline_type(void)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    if (p == NULL)\n\treturn NUL;\n    if (p->cmdfirstc == NUL)\n\treturn\n# ifdef FEAT_EVAL\n\t    (p->input_fn) ? '@' :\n# endif\n\t    '-';\n    return p->cmdfirstc;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Get the current command line in allocated memory.\n * Only works when the command line is being edited.\n * Returns NULL when something is wrong.\n */\n    static char_u *\nget_cmdline_str(void)\n{\n    cmdline_info_T *p;\n\n    if (cmdline_star > 0)\n\treturn NULL;\n    p = get_ccline_ptr();\n    if (p == NULL)\n\treturn NULL;\n    return vim_strnsave(p->cmdbuff, p->cmdlen);\n}\n\n/*\n * Get the current command-line completion type.\n */\n    static char_u *\nget_cmdline_completion(void)\n{\n    cmdline_info_T *p;\n\n    if (cmdline_star > 0)\n\treturn NULL;\n\n    p = get_ccline_ptr();\n    if (p != NULL && p->xpc != NULL)\n    {\n\tchar_u *cmd_compl;\n\n\tset_expand_context(p->xpc);\n\n\tcmd_compl = cmdcomplete_type_to_str(p->xpc->xp_context);\n\tif (cmd_compl != NULL)\n\t    return vim_strsave(cmd_compl);\n    }\n\n    return NULL;\n}\n\n/*\n * \"getcmdcompltype()\" function\n */\n    void\nf_getcmdcompltype(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = get_cmdline_completion();\n}\n\n/*\n * \"getcmdline()\" function\n */\n    void\nf_getcmdline(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = get_cmdline_str();\n}\n\n/*\n * \"getcmdpos()\" function\n */\n    void\nf_getcmdpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    rettv->vval.v_number = p != NULL ? p->cmdpos + 1 : 0;\n}\n\n/*\n * \"getcmdscreenpos()\" function\n */\n    void\nf_getcmdscreenpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    rettv->vval.v_number = p != NULL ? p->cmdspos + 1 : 0;\n}\n\n/*\n * \"getcmdtype()\" function\n */\n    void\nf_getcmdtype(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = alloc(2);\n    if (rettv->vval.v_string != NULL)\n    {\n\trettv->vval.v_string[0] = get_cmdline_type();\n\trettv->vval.v_string[1] = NUL;\n    }\n}\n\n// Set the command line str to \"str\".\n// Returns 1 when failed, 0 when OK.\n    static int\nset_cmdline_str(char_u *str, int pos)\n{\n    cmdline_info_T  *p = get_ccline_ptr();\n    int\t\t    len;\n\n    if (p == NULL)\n\treturn 1;\n\n    len = (int)STRLEN(str);\n    realloc_cmdbuff(len + 1);\n    p->cmdlen = len;\n    STRCPY(p->cmdbuff, str);\n\n    p->cmdpos = pos < 0 || pos > p->cmdlen ? p->cmdlen : pos;\n    new_cmdpos = p->cmdpos;\n\n    redrawcmd();\n\n    // Trigger CmdlineChanged autocommands.\n    trigger_cmd_autocmd(get_cmdline_type(), EVENT_CMDLINECHANGED);\n\n    return 0;\n}\n\n/*\n * Set the command line byte position to \"pos\".  Zero is the first position.\n * Only works when the command line is being edited.\n * Returns 1 when failed, 0 when OK.\n */\n    static int\nset_cmdline_pos(\n    int\t\tpos)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    if (p == NULL)\n\treturn 1;\n\n    // The position is not set directly but after CTRL-\\ e or CTRL-R = has\n    // changed the command line.\n    if (pos < 0)\n\tnew_cmdpos = 0;\n    else\n\tnew_cmdpos = pos;\n    return 0;\n}\n\n// \"setcmdline()\" function\n    void\nf_setcmdline(typval_T *argvars, typval_T *rettv)\n{\n    int pos = -1;\n\n    if (check_for_string_arg(argvars, 0) == FAIL\n\t    || check_for_opt_number_arg(argvars, 1) == FAIL)\n\treturn;\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tint error = FALSE;\n\n\tpos = (int)tv_get_number_chk(&argvars[1], &error) - 1;\n\tif (error)\n\t    return;\n\tif (pos < 0)\n\t{\n\t    emsg(_(e_argument_must_be_positive));\n\t    return;\n\t}\n    }\n\n    rettv->vval.v_number = set_cmdline_str(argvars[0].vval.v_string, pos);\n}\n\n/*\n * \"setcmdpos()\" function\n */\n    void\nf_setcmdpos(typval_T *argvars, typval_T *rettv)\n{\n    int\t\tpos;\n\n    if (in_vim9script() && check_for_number_arg(argvars, 0) == FAIL)\n\treturn;\n\n    pos = (int)tv_get_number(&argvars[0]) - 1;\n    if (pos >= 0)\n\trettv->vval.v_number = set_cmdline_pos(pos);\n}\n#endif\n\n/*\n * Return the first character of the current command line.\n */\n    int\nget_cmdline_firstc(void)\n{\n    return ccline.cmdfirstc;\n}\n\n/*\n * Get indices \"num1,num2\" that specify a range within a list (not a range of\n * text lines in a buffer!) from a string.  Used for \":history\" and \":clist\".\n * Returns OK if parsed successfully, otherwise FAIL.\n */\n    int\nget_list_range(char_u **str, int *num1, int *num2)\n{\n    int\t\tlen;\n    int\t\tfirst = FALSE;\n    varnumber_T\tnum;\n\n    *str = skipwhite(*str);\n    if (**str == '-' || vim_isdigit(**str))  // parse \"from\" part of range\n    {\n\tvim_str2nr(*str, NULL, &len, 0, &num, NULL, 0, FALSE);\n\t*str += len;\n\t*num1 = (int)num;\n\tfirst = TRUE;\n    }\n    *str = skipwhite(*str);\n    if (**str == ',')\t\t\t// parse \"to\" part of range\n    {\n\t*str = skipwhite(*str + 1);\n\tvim_str2nr(*str, NULL, &len, 0, &num, NULL, 0, FALSE);\n\tif (len > 0)\n\t{\n\t    *num2 = (int)num;\n\t    *str = skipwhite(*str + len);\n\t}\n\telse if (!first)\t\t// no number given at all\n\t    return FAIL;\n    }\n    else if (first)\t\t\t// only one number given\n\t*num2 = *num1;\n    return OK;\n}\n\n#if defined(FEAT_CMDWIN) || defined(PROTO)\n/*\n * Check value of 'cedit' and set cedit_key.\n * Returns NULL if value is OK, error message otherwise.\n */\n    char *\ncheck_cedit(void)\n{\n    int n;\n\n    if (*p_cedit == NUL)\n\tcedit_key = -1;\n    else\n    {\n\tn = string_to_key(p_cedit, FALSE);\n\tif (vim_isprintc(n))\n\t    return e_invalid_argument;\n\tcedit_key = n;\n    }\n    return NULL;\n}\n\n/*\n * Open a window on the current command line and history.  Allow editing in\n * the window.  Returns when the window is closed.\n * Returns:\n *\tCR\t if the command is to be executed\n *\tCtrl_C\t if it is to be abandoned\n *\tK_IGNORE if editing continues\n */\n    static int\nopen_cmdwin(void)\n{\n    bufref_T\t\told_curbuf;\n    win_T\t\t*old_curwin = curwin;\n    bufref_T\t\tbufref;\n    win_T\t\t*wp;\n    int\t\t\ti;\n    linenr_T\t\tlnum;\n    int\t\t\thisttype;\n    garray_T\t\twinsizes;\n    int\t\t\tsave_restart_edit = restart_edit;\n    int\t\t\tsave_State = State;\n    int\t\t\tsave_exmode = exmode_active;\n#ifdef FEAT_RIGHTLEFT\n    int\t\t\tsave_cmdmsg_rl = cmdmsg_rl;\n#endif\n#ifdef FEAT_FOLDING\n    int\t\t\tsave_KeyTyped;\n#endif\n\n    // Can't do this when text or buffer is locked.\n    // Can't do this recursively.  Can't do it when typing a password.\n    if (text_or_buf_locked()\n\t    || cmdwin_type != 0\n# if defined(FEAT_CRYPT) || defined(FEAT_EVAL)\n\t    || cmdline_star > 0\n# endif\n\t    )\n    {\n\tbeep_flush();\n\treturn K_IGNORE;\n    }\n    set_bufref(&old_curbuf, curbuf);\n\n    // Save current window sizes.\n    win_size_save(&winsizes);\n\n    // When using completion in Insert mode with <C-R>=<C-F> one can open the\n    // command line window, but we don't want the popup menu then.\n    pum_undisplay();\n\n    // don't use a new tab page\n    cmdmod.cmod_tab = 0;\n    cmdmod.cmod_flags |= CMOD_NOSWAPFILE;\n\n    // Create a window for the command-line buffer.\n    if (win_split((int)p_cwh, WSP_BOT) == FAIL)\n    {\n\tbeep_flush();\n\tga_clear(&winsizes);\n\treturn K_IGNORE;\n    }\n    // Don't let quitting the More prompt make this fail.\n    got_int = FALSE;\n\n    // Set \"cmdwin_type\" before any autocommands may mess things up.\n    cmdwin_type = get_cmdline_type();\n\n    // Create the command-line buffer empty.\n    if (do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL) == FAIL)\n    {\n\t// Some autocommand messed it up?\n\twin_close(curwin, TRUE);\n\tga_clear(&winsizes);\n\tcmdwin_type = 0;\n\treturn Ctrl_C;\n    }\n\n    apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, FALSE, curbuf);\n    (void)setfname(curbuf, (char_u *)_(\"[Command Line]\"), NULL, TRUE);\n    apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, FALSE, curbuf);\n    set_option_value_give_err((char_u *)\"bt\",\n\t\t\t\t\t    0L, (char_u *)\"nofile\", OPT_LOCAL);\n    curbuf->b_p_ma = TRUE;\n#ifdef FEAT_FOLDING\n    curwin->w_p_fen = FALSE;\n#endif\n# ifdef FEAT_RIGHTLEFT\n    curwin->w_p_rl = cmdmsg_rl;\n    cmdmsg_rl = FALSE;\n# endif\n    RESET_BINDING(curwin);\n\n    // Don't allow switching to another buffer.\n    ++curbuf_lock;\n\n    // Showing the prompt may have set need_wait_return, reset it.\n    need_wait_return = FALSE;\n\n    histtype = hist_char2type(cmdwin_type);\n    if (histtype == HIST_CMD || histtype == HIST_DEBUG)\n    {\n\tif (p_wc == TAB)\n\t{\n\t    add_map((char_u *)\"<buffer> <Tab> <C-X><C-V>\", MODE_INSERT, TRUE);\n\t    add_map((char_u *)\"<buffer> <Tab> a<C-X><C-V>\", MODE_NORMAL, TRUE);\n\t}\n\tset_option_value_give_err((char_u *)\"ft\",\n\t\t\t\t\t       0L, (char_u *)\"vim\", OPT_LOCAL);\n    }\n    --curbuf_lock;\n\n    // Reset 'textwidth' after setting 'filetype' (the Vim filetype plugin\n    // sets 'textwidth' to 78).\n    curbuf->b_p_tw = 0;\n\n    // Fill the buffer with the history.\n    init_history();\n    if (get_hislen() > 0)\n    {\n\ti = *get_hisidx(histtype);\n\tif (i >= 0)\n\t{\n\t    lnum = 0;\n\t    do\n\t    {\n\t\tif (++i == get_hislen())\n\t\t    i = 0;\n\t\tif (get_histentry(histtype)[i].hisstr != NULL)\n\t\t    ml_append(lnum++, get_histentry(histtype)[i].hisstr,\n\t\t\t\t\t\t\t   (colnr_T)0, FALSE);\n\t    }\n\t    while (i != *get_hisidx(histtype));\n\t}\n    }\n\n    // Replace the empty last line with the current command-line and put the\n    // cursor there.\n    ml_replace(curbuf->b_ml.ml_line_count, ccline.cmdbuff, TRUE);\n    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor.col = ccline.cmdpos;\n    changed_line_abv_curs();\n    invalidate_botline();\n    redraw_later(UPD_SOME_VALID);\n\n    // No Ex mode here!\n    exmode_active = 0;\n\n    State = MODE_NORMAL;\n    setmouse();\n\n    // Reset here so it can be set by a CmdWinEnter autocommand.\n    cmdwin_result = 0;\n\n    // Trigger CmdwinEnter autocommands.\n    trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINENTER);\n    if (restart_edit != 0)\t// autocmd with \":startinsert\"\n\tstuffcharReadbuff(K_NOP);\n\n    i = RedrawingDisabled;\n    RedrawingDisabled = 0;\n\n    /*\n     * Call the main loop until <CR> or CTRL-C is typed.\n     */\n    main_loop(TRUE, FALSE);\n\n    RedrawingDisabled = i;\n\n# ifdef FEAT_FOLDING\n    save_KeyTyped = KeyTyped;\n# endif\n\n    // Trigger CmdwinLeave autocommands.\n    trigger_cmd_autocmd(cmdwin_type, EVENT_CMDWINLEAVE);\n\n# ifdef FEAT_FOLDING\n    // Restore KeyTyped in case it is modified by autocommands\n    KeyTyped = save_KeyTyped;\n# endif\n\n    cmdwin_type = 0;\n    exmode_active = save_exmode;\n\n    // Safety check: The old window or buffer was deleted: It's a bug when\n    // this happens!\n    if (!win_valid(old_curwin) || !bufref_valid(&old_curbuf))\n    {\n\tcmdwin_result = Ctrl_C;\n\temsg(_(e_active_window_or_buffer_deleted));\n    }\n    else\n    {\n# if defined(FEAT_EVAL)\n\t// autocmds may abort script processing\n\tif (aborting() && cmdwin_result != K_IGNORE)\n\t    cmdwin_result = Ctrl_C;\n# endif\n\t// Set the new command line from the cmdline buffer.\n\tvim_free(ccline.cmdbuff);\n\tif (cmdwin_result == K_XF1 || cmdwin_result == K_XF2) // :qa[!] typed\n\t{\n\t    char *p = (cmdwin_result == K_XF2) ? \"qa\" : \"qa!\";\n\n\t    if (histtype == HIST_CMD)\n\t    {\n\t\t// Execute the command directly.\n\t\tccline.cmdbuff = vim_strsave((char_u *)p);\n\t\tcmdwin_result = CAR;\n\t    }\n\t    else\n\t    {\n\t\t// First need to cancel what we were doing.\n\t\tccline.cmdbuff = NULL;\n\t\tstuffcharReadbuff(':');\n\t\tstuffReadbuff((char_u *)p);\n\t\tstuffcharReadbuff(CAR);\n\t    }\n\t}\n\telse if (cmdwin_result == K_XF2)\t// :qa typed\n\t{\n\t    ccline.cmdbuff = vim_strsave((char_u *)\"qa\");\n\t    cmdwin_result = CAR;\n\t}\n\telse if (cmdwin_result == Ctrl_C)\n\t{\n\t    // :q or :close, don't execute any command\n\t    // and don't modify the cmd window.\n\t    ccline.cmdbuff = NULL;\n\t}\n\telse\n\t    ccline.cmdbuff = vim_strsave(ml_get_curline());\n\tif (ccline.cmdbuff == NULL)\n\t{\n\t    ccline.cmdbuff = vim_strsave((char_u *)\"\");\n\t    ccline.cmdlen = 0;\n\t    ccline.cmdbufflen = 1;\n\t    ccline.cmdpos = 0;\n\t    cmdwin_result = Ctrl_C;\n\t}\n\telse\n\t{\n\t    ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);\n\t    ccline.cmdbufflen = ccline.cmdlen + 1;\n\t    ccline.cmdpos = curwin->w_cursor.col;\n\t    if (ccline.cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    if (cmdwin_result == K_IGNORE)\n\t    {\n\t\tset_cmdspos_cursor();\n\t\tredrawcmd();\n\t    }\n\t}\n\n# ifdef FEAT_CONCEAL\n\t// Avoid command-line window first character being concealed.\n\tcurwin->w_p_cole = 0;\n# endif\n\t// First go back to the original window.\n\twp = curwin;\n\tset_bufref(&bufref, curbuf);\n\n\tskip_win_fix_cursor = TRUE;\n\twin_goto(old_curwin);\n\n\t// win_goto() may trigger an autocommand that already closes the\n\t// cmdline window.\n\tif (win_valid(wp) && wp != curwin)\n\t    win_close(wp, TRUE);\n\n\t// win_close() may have already wiped the buffer when 'bh' is\n\t// set to 'wipe', autocommands may have closed other windows\n\tif (bufref_valid(&bufref) && bufref.br_buf != curbuf)\n\t    close_buffer(NULL, bufref.br_buf, DOBUF_WIPE, FALSE, FALSE);\n\n\t// Restore window sizes.\n\twin_size_restore(&winsizes);\n\tskip_win_fix_cursor = FALSE;\n    }\n\n    ga_clear(&winsizes);\n    restart_edit = save_restart_edit;\n# ifdef FEAT_RIGHTLEFT\n    cmdmsg_rl = save_cmdmsg_rl;\n# endif\n\n    State = save_State;\n    may_trigger_modechanged();\n    setmouse();\n\n    return cmdwin_result;\n}\n\n/*\n * Return TRUE if in the cmdwin, not editing the command line.\n */\n    int\nis_in_cmdwin(void)\n{\n    return cmdwin_type != 0 && get_cmdline_type() == NUL;\n}\n#endif // FEAT_CMDWIN\n\n/*\n * Used for commands that either take a simple command string argument, or:\n *\tcmd << endmarker\n *\t  {script}\n *\tendmarker\n * Returns a pointer to allocated memory with {script} or NULL.\n */\n    char_u *\nscript_get(exarg_T *eap UNUSED, char_u *cmd UNUSED)\n{\n#ifdef FEAT_EVAL\n    list_T\t*l;\n    listitem_T\t*li;\n    char_u\t*s;\n    garray_T\tga;\n\n    if (cmd[0] != '<' || cmd[1] != '<' || eap->getline == NULL)\n\treturn NULL;\n    cmd += 2;\n\n    l = heredoc_get(eap, cmd, TRUE, FALSE);\n    if (l == NULL)\n\treturn NULL;\n\n    ga_init2(&ga, 1, 0x400);\n\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\ts = tv_get_string(&li->li_tv);\n\tga_concat(&ga, s);\n\tga_append(&ga, '\\n');\n    }\n    ga_append(&ga, NUL);\n\n    list_free(l);\n    return (char_u *)ga.ga_data;\n#else\n    return NULL;\n#endif\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * This function is used by f_input() and f_inputdialog() functions. The third\n * argument to f_input() specifies the type of completion to use at the\n * prompt. The third argument to f_inputdialog() specifies the value to return\n * when the user cancels the prompt.\n */\n    void\nget_user_input(\n    typval_T\t*argvars,\n    typval_T\t*rettv,\n    int\t\tinputdialog,\n    int\t\tsecret)\n{\n    char_u\t*prompt;\n    char_u\t*p = NULL;\n    int\t\tc;\n    char_u\tbuf[NUMBUFLEN];\n    int\t\tcmd_silent_save = cmd_silent;\n    char_u\t*defstr = (char_u *)\"\";\n    int\t\txp_type = EXPAND_NOTHING;\n    char_u\t*xp_arg = NULL;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n    if (input_busy)\n\treturn;  // this doesn't work recursively.\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_string_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    prompt = tv_get_string_chk(&argvars[0]);\n\n#ifdef NO_CONSOLE_INPUT\n    // While starting up, there is no place to enter text. When running tests\n    // with --not-a-term we assume feedkeys() will be used.\n    if (no_console_input() && !is_not_a_term())\n\treturn;\n#endif\n\n    cmd_silent = FALSE;\t\t// Want to see the prompt.\n    if (prompt != NULL)\n    {\n\t// Only the part of the message after the last NL is considered as\n\t// prompt for the command line\n\tp = vim_strrchr(prompt, '\\n');\n\tif (p == NULL)\n\t    p = prompt;\n\telse\n\t{\n\t    ++p;\n\t    c = *p;\n\t    *p = NUL;\n\t    msg_start();\n\t    msg_clr_eos();\n\t    msg_puts_attr((char *)prompt, get_echo_attr());\n\t    msg_didout = FALSE;\n\t    msg_starthere();\n\t    *p = c;\n\t}\n\tcmdline_row = msg_row;\n\n\tif (argvars[1].v_type != VAR_UNKNOWN)\n\t{\n\t    defstr = tv_get_string_buf_chk(&argvars[1], buf);\n\t    if (defstr != NULL)\n\t\tstuffReadbuffSpec(defstr);\n\n\t    if (!inputdialog && argvars[2].v_type != VAR_UNKNOWN)\n\t    {\n\t\tchar_u\t*xp_name;\n\t\tint\txp_namelen;\n\t\tlong\targt = 0;\n\n\t\t// input() with a third argument: completion\n\t\trettv->vval.v_string = NULL;\n\n\t\txp_name = tv_get_string_buf_chk(&argvars[2], buf);\n\t\tif (xp_name == NULL)\n\t\t    return;\n\n\t\txp_namelen = (int)STRLEN(xp_name);\n\n\t\tif (parse_compl_arg(xp_name, xp_namelen, &xp_type, &argt,\n\t\t\t\t\t\t\t     &xp_arg) == FAIL)\n\t\t    return;\n\t    }\n\t}\n\n\tif (defstr != NULL)\n\t{\n\t    int save_ex_normal_busy = ex_normal_busy;\n\t    int save_vgetc_busy = vgetc_busy;\n\t    int save_input_busy = input_busy;\n\n\t    input_busy |= vgetc_busy;\n\t    ex_normal_busy = 0;\n\t    vgetc_busy = 0;\n\t    rettv->vval.v_string =\n\t\tgetcmdline_prompt(secret ? NUL : '@', p, get_echo_attr(),\n\t\t\t\t\t\t\t      xp_type, xp_arg);\n\t    ex_normal_busy = save_ex_normal_busy;\n\t    vgetc_busy = save_vgetc_busy;\n\t    input_busy = save_input_busy;\n\t}\n\tif (inputdialog && rettv->vval.v_string == NULL\n\t\t&& argvars[1].v_type != VAR_UNKNOWN\n\t\t&& argvars[2].v_type != VAR_UNKNOWN)\n\t    rettv->vval.v_string = vim_strsave(tv_get_string_buf(\n\t\t\t\t\t\t\t   &argvars[2], buf));\n\n\tvim_free(xp_arg);\n\n\t// since the user typed this, no need to wait for return\n\tneed_wait_return = FALSE;\n\tmsg_didout = FALSE;\n    }\n    cmd_silent = cmd_silent_save;\n}\n#endif\n", "\" Tests for editing the command line.\n\nsource check.vim\nCheckFeature cmdwin\n\nsource screendump.vim\n\nfunc Test_getcmdwintype()\n  call feedkeys(\"q/:let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal('/', a)\n\n  call feedkeys(\"q?:let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal('?', a)\n\n  call feedkeys(\"q::let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal(':', a)\n\n  call feedkeys(\":\\<C-F>:let a = getcmdwintype()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal(':', a)\n\n  call assert_equal('', getcmdwintype())\nendfunc\n\nfunc Test_getcmdwin_autocmd()\n  let s:seq = []\n  augroup CmdWin\n  au WinEnter * call add(s:seq, 'WinEnter ' .. win_getid())\n  au WinLeave * call add(s:seq, 'WinLeave ' .. win_getid())\n  au BufEnter * call add(s:seq, 'BufEnter ' .. bufnr())\n  au BufLeave * call add(s:seq, 'BufLeave ' .. bufnr())\n  au CmdWinEnter * call add(s:seq, 'CmdWinEnter ' .. win_getid())\n  au CmdWinLeave * call add(s:seq, 'CmdWinLeave ' .. win_getid())\n\n  let org_winid = win_getid()\n  let org_bufnr = bufnr()\n  call feedkeys(\"q::let a = getcmdwintype()\\<CR>:let s:cmd_winid = win_getid()\\<CR>:let s:cmd_bufnr = bufnr()\\<CR>:q\\<CR>\", 'x!')\n  call assert_equal(':', a)\n  call assert_equal([\n\t\\ 'WinLeave ' .. org_winid,\n\t\\ 'WinEnter ' .. s:cmd_winid,\n\t\\ 'BufLeave ' .. org_bufnr,\n\t\\ 'BufEnter ' .. s:cmd_bufnr,\n\t\\ 'CmdWinEnter ' .. s:cmd_winid,\n\t\\ 'CmdWinLeave ' .. s:cmd_winid,\n\t\\ 'BufLeave ' .. s:cmd_bufnr,\n\t\\ 'WinLeave ' .. s:cmd_winid,\n\t\\ 'WinEnter ' .. org_winid,\n\t\\ 'BufEnter ' .. org_bufnr,\n\t\\ ], s:seq)\n\n  au!\n  augroup END\nendfunc\n\nfunc Test_cmdwin_bug()\n  let winid = win_getid()\n  sp\n  try\n    call feedkeys(\"q::call win_gotoid(\" .. winid .. \")\\<CR>:q\\<CR>\", 'x!')\n  catch /^Vim\\%((\\a\\+)\\)\\=:E11/\n  endtry\n  bw!\nendfunc\n\nfunc Test_cmdwin_restore()\n  CheckScreendump\n\n  let lines =<< trim [SCRIPT]\n    augroup vimHints | au! | augroup END\n    call setline(1, range(30))\n    2split\n  [SCRIPT]\n  call writefile(lines, 'XTest_restore', 'D')\n\n  let buf = RunVimInTerminal('-S XTest_restore', {'rows': 12})\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \"q:\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_restore_1', {})\n\n  \" normal restore\n  call term_sendkeys(buf, \":q\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_restore_2', {})\n\n  \" restore after setting 'lines' with one window\n  call term_sendkeys(buf, \":close\\<CR>\")\n  call term_sendkeys(buf, \"q:\")\n  call term_sendkeys(buf, \":set lines=18\\<CR>\")\n  call term_sendkeys(buf, \":q\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_restore_3', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_cmdwin_no_terminal()\n  CheckFeature terminal\n  CheckNotMSWindows\n\n  let buf = RunVimInTerminal('', {'rows': 12})\n  call TermWait(buf, 50)\n  call term_sendkeys(buf, \":set cmdheight=2\\<CR>\")\n  call term_sendkeys(buf, \"q:\")\n  call term_sendkeys(buf, \":let buf = term_start(['/bin/echo'], #{hidden: 1})\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_no_terminal', {})\n  call term_sendkeys(buf, \":q\\<CR>\")\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_cmdwin_feedkeys()\n  \" This should not generate E488\n  call feedkeys(\"q:\\<CR>\", 'x')\n  \" Using feedkeys with q: only should automatically close the cmd window\n  call feedkeys('q:', 'xt')\n  call assert_equal(1, winnr('$'))\n  call assert_equal('', getcmdwintype())\nendfunc\n\n\" Tests for the issues fixed in 7.4.441.\n\" When 'cedit' is set to Ctrl-C, opening the command window hangs Vim\nfunc Test_cmdwin_cedit()\n  exe \"set cedit=\\<C-c>\"\n  normal! :\n  call assert_equal(1, winnr('$'))\n\n  let g:cmd_wintype = ''\n  func CmdWinType()\n      let g:cmd_wintype = getcmdwintype()\n      let g:wintype = win_gettype()\n      return ''\n  endfunc\n\n  call feedkeys(\"\\<C-c>a\\<C-R>=CmdWinType()\\<CR>\\<CR>\")\n  echo input('')\n  call assert_equal('@', g:cmd_wintype)\n  call assert_equal('command', g:wintype)\n\n  set cedit&vim\n  delfunc CmdWinType\nendfunc\n\n\" Test for CmdwinEnter autocmd\nfunc Test_cmdwin_autocmd()\n  augroup CmdWin\n    au!\n    autocmd BufLeave * if &buftype == '' | update | endif\n    autocmd CmdwinEnter * startinsert\n  augroup END\n\n  call assert_fails('call feedkeys(\"q:xyz\\<CR>\", \"xt\")', 'E492:')\n  call assert_equal('xyz', @:)\n\n  augroup CmdWin\n    au!\n  augroup END\n  augroup! CmdWin\nendfunc\n\nfunc Test_cmdwin_jump_to_win()\n  call assert_fails('call feedkeys(\"q:\\<C-W>\\<C-W>\\<CR>\", \"xt\")', 'E11:')\n  new\n  set modified\n  call assert_fails('call feedkeys(\"q/:qall\\<CR>\", \"xt\")', ['E37:', 'E162:'])\n  close!\n  call feedkeys(\"q/:close\\<CR>\", \"xt\")\n  call assert_equal(1, winnr('$'))\n  call feedkeys(\"q/:exit\\<CR>\", \"xt\")\n  call assert_equal(1, winnr('$'))\n\n  \" opening command window twice should fail\n  call assert_beeps('call feedkeys(\"q:q:\\<CR>\\<CR>\", \"xt\")')\n  call assert_equal(1, winnr('$'))\nendfunc\n\nfunc Test_cmdwin_tabpage()\n  tabedit\n  call assert_fails(\"silent norm q/g\t:I\\<Esc>\", 'E11:')\n  tabclose!\nendfunc\n\nfunc Test_cmdwin_interrupted()\n  CheckScreendump\n\n  \" aborting the :smile output caused the cmdline window to use the current\n  \" buffer.\n  let lines =<< trim [SCRIPT]\n    au WinNew * smile\n  [SCRIPT]\n  call writefile(lines, 'XTest_cmdwin', 'D')\n\n  let buf = RunVimInTerminal('-S XTest_cmdwin', {'rows': 18})\n  \" open cmdwin\n  call term_sendkeys(buf, \"q:\")\n  call WaitForAssert({-> assert_match('-- More --', term_getline(buf, 18))})\n  \" quit more prompt for :smile command\n  call term_sendkeys(buf, \"q\")\n  call WaitForAssert({-> assert_match('^$', term_getline(buf, 18))})\n  \" execute a simple command\n  call term_sendkeys(buf, \"aecho 'done'\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_cmdwin_interrupted', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\n\" Test for recursively getting multiple command line inputs\nfunc Test_cmdwin_multi_input()\n  call feedkeys(\":\\<C-R>=input('P: ')\\<CR>\\\"cyan\\<CR>\\<CR>\", 'xt')\n  call assert_equal('\"cyan', @:)\nendfunc\n\n\" Test for normal mode commands not supported in the cmd window\nfunc Test_cmdwin_blocked_commands()\n  call assert_fails('call feedkeys(\"q:\\<C-T>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-]>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-^>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:Q\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:Z\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<F1>\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>s\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>v\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>^\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>n\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>z\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>o\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>w\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>j\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>k\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>h\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>l\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>T\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>x\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>r\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>R\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>K\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>}\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>]\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>f\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>d\\<CR>\", \"xt\")', 'E11:')\n  call assert_fails('call feedkeys(\"q:\\<C-W>g\\<CR>\", \"xt\")', 'E11:')\nendfunc\n\n\" Close the Cmd-line window in insert mode using CTRL-C\nfunc Test_cmdwin_insert_mode_close()\n  %bw!\n  let s = ''\n  exe \"normal q:a\\<C-C>let s='Hello'\\<CR>\"\n  call assert_equal('Hello', s)\n  call assert_equal(1, winnr('$'))\nendfunc\n\nfunc Test_cmdwin_ex_mode_with_modifier()\n  \" this was accessing memory after allocated text in Ex mode\n  new\n  call setline(1, ['some', 'text', 'lines'])\n  silent! call feedkeys(\"gQnormal vq:atopleft\\<C-V>\\<CR>\\<CR>\", 'xt')\n  bwipe!\nendfunc\n\nfunc s:ComplInCmdwin_GlobalCompletion(a, l, p)\n  return 'global'\nendfunc\n\nfunc s:ComplInCmdwin_LocalCompletion(a, l, p)\n  return 'local'\nendfunc\n\nfunc Test_compl_in_cmdwin()\n  set wildmenu wildchar=<Tab>\n  com! -nargs=1 -complete=command GetInput let input = <q-args>\n  com! -buffer TestCommand echo 'TestCommand'\n  let w:test_winvar = 'winvar'\n  let b:test_bufvar = 'bufvar'\n\n  \" User-defined commands\n  let input = ''\n  call feedkeys(\"q:iGetInput T\\<C-x>\\<C-v>\\<CR>\", 'tx!')\n  call assert_equal('TestCommand', input)\n\n  let input = ''\n  call feedkeys(\"q::GetInput T\\<Tab>\\<CR>:q\\<CR>\", 'tx!')\n  call assert_equal('T', input)\n\n\n  com! -nargs=1 -complete=var GetInput let input = <q-args>\n  \" Window-local variables\n  let input = ''\n  call feedkeys(\"q:iGetInput w:test_\\<C-x>\\<C-v>\\<CR>\", 'tx!')\n  call assert_equal('w:test_winvar', input)\n\n  let input = ''\n  call feedkeys(\"q::GetInput w:test_\\<Tab>\\<CR>:q\\<CR>\", 'tx!')\n  call assert_equal('w:test_', input)\n\n  \" Buffer-local variables\n  let input = ''\n  call feedkeys(\"q:iGetInput b:test_\\<C-x>\\<C-v>\\<CR>\", 'tx!')\n  call assert_equal('b:test_bufvar', input)\n\n  let input = ''\n  call feedkeys(\"q::GetInput b:test_\\<Tab>\\<CR>:q\\<CR>\", 'tx!')\n  call assert_equal('b:test_', input)\n\n\n  \" Argument completion of buffer-local command\n  func s:ComplInCmdwin_GlobalCompletionList(a, l, p)\n    return ['global']\n  endfunc\n\n  func s:ComplInCmdwin_LocalCompletionList(a, l, p)\n    return ['local']\n  endfunc\n\n  func s:ComplInCmdwin_CheckCompletion(arg)\n    call assert_equal('local', a:arg)\n  endfunc\n\n  com! -nargs=1 -complete=custom,<SID>ComplInCmdwin_GlobalCompletion\n       \\ TestCommand call s:ComplInCmdwin_CheckCompletion(<q-args>)\n  com! -buffer -nargs=1 -complete=custom,<SID>ComplInCmdwin_LocalCompletion\n       \\ TestCommand call s:ComplInCmdwin_CheckCompletion(<q-args>)\n  call feedkeys(\"q:iTestCommand \\<Tab>\\<CR>\", 'tx!')\n\n  com! -nargs=1 -complete=customlist,<SID>ComplInCmdwin_GlobalCompletionList\n       \\ TestCommand call s:ComplInCmdwin_CheckCompletion(<q-args>)\n  com! -buffer -nargs=1 -complete=customlist,<SID>ComplInCmdwin_LocalCompletionList\n       \\ TestCommand call s:ComplInCmdwin_CheckCompletion(<q-args>)\n\n  call feedkeys(\"q:iTestCommand \\<Tab>\\<CR>\", 'tx!')\n\n  func! s:ComplInCmdwin_CheckCompletion(arg)\n    call assert_equal('global', a:arg)\n  endfunc\n  new\n  call feedkeys(\"q:iTestCommand \\<Tab>\\<CR>\", 'tx!')\n  quit\n\n  delfunc s:ComplInCmdwin_GlobalCompletion\n  delfunc s:ComplInCmdwin_LocalCompletion\n  delfunc s:ComplInCmdwin_GlobalCompletionList\n  delfunc s:ComplInCmdwin_LocalCompletionList\n  delfunc s:ComplInCmdwin_CheckCompletion\n\n  delcom -buffer TestCommand\n  delcom TestCommand\n  delcom GetInput\n  unlet w:test_winvar\n  unlet b:test_bufvar\n  set wildmenu& wildchar&\nendfunc\n\nfunc Test_cmdwin_ctrl_bsl()\n  \" Using CTRL-\\ CTRL-N in cmd window should close the window\n  call feedkeys(\"q:\\<C-\\>\\<C-N>\", 'xt')\n  call assert_equal('', getcmdwintype())\nendfunc\n\nfunc Test_cant_open_cmdwin_in_cmdwin()\n  try\n    call feedkeys(\"q:q::q\\<CR>\", \"x!\")\n  catch\n    let caught = v:exception\n  endtry\n  call assert_match('E1292:', caught)\nendfunc\n\nfunc Test_cmdwin_virtual_edit()\n  enew!\n  set ve=all cpo+=$\n  silent normal q/s\n\n  set ve= cpo-=$\nendfunc\n\n\" Check that a :normal command can be used to stop Visual mode without side\n\" effects.\nfunc Test_normal_escape()\n  call feedkeys(\"q:i\\\" foo\\<Esc>:normal! \\<C-V>\\<Esc>\\<CR>:\\\" bar\\<CR>\", 'ntx')\n  call assert_equal('\" bar', @:)\nendfunc\n\n\" This was using a pointer to a freed buffer\nfunc Test_cmdwin_freed_buffer_ptr()\n  au BufEnter * next 0| file \u000b\n  edit 0\n  silent! norm q/\n\n  au! BufEnter\n  bwipe!\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/ex_getln.c", "src/testdir/test_cmdwin.vim", "src/version.c"], "buggy_code_start_loc": [1589, 380, 705], "buggy_code_end_loc": [2548, 380, 705], "fixing_code_start_loc": [1590, 381, 706], "fixing_code_end_loc": [2552, 392, 708], "type": "CWE-416", "message": "Use After Free in GitHub repository vim/vim prior to 9.0.0490.", "other": {"cve": {"id": "CVE-2022-3235", "sourceIdentifier": "security@huntr.dev", "published": "2022-09-18T20:15:09.303", "lastModified": "2023-05-03T12:16:17.083", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Use After Free in GitHub repository vim/vim prior to 9.0.0490."}, {"lang": "es", "value": "Un Uso de Memoria Previamente Liberada en el repositorio GitHub vim/vim versiones anteriores a 9.0.0490"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0490", "matchCriteriaId": "D2E7CDCF-DEE9-4021-B811-36D5DC888C44"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/1c3dd8ddcba63c1af5112e567215b3cec2de11d0", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/96d5f7a0-a834-4571-b73b-0fe523b941af", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00032.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4QI7AETXBHPC7SGA77Q7O5IEGULWYET7/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GTBVD4J2SKVSWK4VBN5JP5OEVK6GDS3N/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LSSEWQLK55MCNT4Z2IIJEJYEI5HLCODI/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/1c3dd8ddcba63c1af5112e567215b3cec2de11d0"}}