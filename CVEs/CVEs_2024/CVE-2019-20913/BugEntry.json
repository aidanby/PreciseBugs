{"buggy_code": ["/* -*- c -*- */\n/*****************************************************************************/\n/*  LibreDWG - free implementation of the DWG file format                    */\n/*                                                                           */\n/*  Copyright (C) 2018-2019 Free Software Foundation, Inc.                   */\n/*                                                                           */\n/*  This library is free software, licensed under the terms of the GNU       */\n/*  General Public License as published by the Free Software Foundation,     */\n/*  either version 3 of the License, or (at your option) any later version.  */\n/*  You should have received a copy of the GNU General Public License        */\n/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */\n/*****************************************************************************/\n\n/*\n * classes.inc: the dynamic class dispatcher\n * for all types > 500\n * written by Reini Urban\n */\n\n/**\n * Variable-typed classes and its stability\n */\n\n#ifndef ACTION\n# error ACTION define missing: decode, encode, dxf, indxf, print, free, ...\n#endif\n\n#define _XSTR(s) _STR(s)\n#define _STR(s)  #s\n\n#define WARN_UNHANDLED_CLASS \\\n      LOG_WARN (\"Unhandled Class %s %d %s (0x%x%s) %u/%lX\", is_entity ? \"entity\" : \"object\",\\\n               klass->number, klass->dxfname, klass->proxyflag,\\\n               klass->wasazombie ? \" was proxy\" : \"\",\\\n               obj->index, obj->handle.value)\n#define WARN_UNSTABLE_CLASS \\\n      LOG_WARN (\"Unstable Class %s %d %s (0x%x%s) %u/%lX\", is_entity ? \"entity\" : \"object\",\\\n               klass->number, klass->dxfname, klass->proxyflag,\\\n               klass->wasazombie ? \" was proxy\" : \"\",\\\n               obj->index, obj->handle.value)\n#if defined(IS_FREE) || defined(IS_PRINT)\n# undef WARN_UNSTABLE_CLASS\n# undef WARN_UNHANDLED_CLASS\n# define WARN_UNSTABLE_CLASS\n# define WARN_UNHANDLED_CLASS\n#endif\n\n#define DISALLOW_DXF(action, _name) \\\n  (strEQc (_STR(action), \"dxf\")) ? DWG_ERR_NOTYETSUPPORTED :\n#define ALLOW_DXF(action, _name)\n\n#ifdef DEBUG_CLASSES\n# define DEBUGGING_DXF(action, name)                 ALLOW_DXF(action, name)\n# define DEBUGGING_CLASS(action, name)               UNSTABLE_CLASS(action, name)\n# define DEBUGGING_CLASS_DXF(action, name, _dxfname) UNSTABLE_CLASS_DXF(action, name, _dxfname)\n#else\n# define DEBUGGING_DXF(action, name)                 DISALLOW_DXF(action, name)\n# define DEBUGGING_CLASS(action, name)               UNHANDLED_CLASS(action, name)\n# define DEBUGGING_CLASS_DXF(action, name, _dxfname) UNHANDLED_CLASS_DXF(action, name, _dxfname)\n#endif\n\n//#define _DWG_FUNC_N(action,name) dwg_ ## action ## _ ## name\n//#define DWG_FUNC_N(action,name) _DWG_FUNC_N(action,name)\n\n#define STABLE_CLASS(action, _name) \\\n  if (klass->dxfname && strEQc (klass->dxfname, #_name)) \\\n    { \\\n      if (strEQc (_STR(action), \"decode\") || !memcmp (_STR(action), \"in\", 2)) { \\\n        obj->name = (char*) #_name; \\\n        obj->dxfname = (char*) #_name; \\\n        obj->fixedtype = DWG_TYPE_##_name; \\\n      } \\\n      return DWG_FUNC_N(action,_name) (dat, obj); \\\n    }\n#define STABLE_CLASS_DXF(action, _name, _dxfname) \\\n  if (klass->dxfname && strEQc (klass->dxfname, #_dxfname)) \\\n    { \\\n      if (strEQc (_STR(action), \"decode\") || !memcmp (_STR(action), \"in\", 2)) { \\\n        obj->name = (char*) #_name; \\\n        obj->dxfname = (char*) #_dxfname; \\\n        obj->fixedtype = DWG_TYPE_##_name; \\\n      } \\\n      return DWG_FUNC_N(action,_name) (dat, obj); \\\n    }\n#define STABLE_CLASS_CPP(action, _name, _cppname) \\\n  if (klass->cppname && strEQc (klass->cppname, #_name)) \\\n    { \\\n      if (strEQc (_STR(action), \"decode\") || !memcmp (_STR(action), \"in\", 2)) { \\\n        obj->name = (char*) #_name; \\\n        obj->dxfname = (char*) #_name; \\\n        obj->fixedtype = DWG_TYPE_##_name; \\\n      } \\\n      return DWG_FUNC_N(action,_name) (dat, obj); \\\n    }\n#define UNSTABLE_CLASS(action, _name) \\\n  if (klass->dxfname && strEQc (klass->dxfname, #_name)) \\\n    { \\\n      WARN_UNSTABLE_CLASS; \\\n      if (strEQc (_STR(action), \"decode\") || !memcmp (_STR(action), \"in\", 2)) { \\\n        obj->name = (char*) #_name; \\\n        obj->dxfname = (char*) #_name; \\\n        obj->fixedtype = DWG_TYPE_##_name; \\\n      } \\\n      return DEBUGGING_DXF(action, name) DWG_FUNC_N(action,_name) (dat, obj); \\\n    }\n#define UNSTABLE_CLASS_DXF(action, _name, _dxfname) \\\n  if (klass->dxfname && strEQc (klass->dxfname, #_dxfname)) \\\n    { \\\n      WARN_UNSTABLE_CLASS; \\\n      if (strEQc (_STR(action), \"decode\") || !memcmp (_STR(action), \"in\", 2)) { \\\n        obj->name = (char*) #_name; \\\n        obj->dxfname = (char*) #_dxfname; \\\n        obj->fixedtype = DWG_TYPE_##_name; \\\n      } \\\n      return DEBUGGING_DXF(action, name) DWG_FUNC_N(action,_name) (dat, obj); \\\n    }\n#define UNSTABLE_CLASS_CPP(action, _name, _cppname) \\\n  if (klass->cppname && strEQc (klass->cppname, #_cppname)) \\\n    { \\\n      WARN_UNSTABLE_CLASS; \\\n      if (strEQc (_STR(action), \"decode\") || !memcmp (_STR(action), \"in\", 2)) { \\\n        obj->name = (char*) #_name; \\\n        obj->dxfname = (char*) #_name; \\\n        obj->fixedtype = DWG_TYPE_##_name; \\\n      } \\\n      return DEBUGGING_DXF(action, name) DWG_FUNC_N(action,_name)(dat, obj); \\\n    }\n#define UNHANDLED_CLASS(action, _name) \\\n  if (klass->dxfname && strEQc (klass->dxfname, #_name)) \\\n    { \\\n      WARN_UNHANDLED_CLASS; \\\n      if (strEQc (_STR(action), \"decode\") || !memcmp (_STR(action), \"in\", 2)) { \\\n        obj->name = (char*) #_name; \\\n        obj->dxfname = (char*) #_name; \\\n        /*obj->fixedtype = DWG_TYPE_##_name; */ \\\n      } \\\n      /* return dwg_##action_##_name(dat, obj); */ \\\n      return DWG_ERR_UNHANDLEDCLASS; \\\n    }\n#define UNHANDLED_CLASS_DXF(action, _name, _dxfname) \\\n  if (strEQc (klass->dxfname, #_dxfname)) \\\n    { \\\n      WARN_UNHANDLED_CLASS; \\\n      if (strEQc (_STR(action), \"decode\") || !memcmp (_STR(action), \"in\", 2)) { \\\n        obj->name = (char*) #_name; \\\n        obj->dxfname = (char*) #_dxfname; \\\n        /*obj->fixedtype = DWG_TYPE_##_name; */ \\\n      } \\\n      /* return dwg_##action_##name(dat, obj); */ \\\n      return DWG_ERR_UNHANDLEDCLASS; \\\n    }\n\n  /* Entities */\n  STABLE_CLASS    (ACTION, CAMERA)    /*ent, not persistent in a DWG */\n  STABLE_CLASS    (ACTION, IMAGE)     /*ent*/\n  STABLE_CLASS    (ACTION, OLE2FRAME) /*ent (also fixed) */\n  STABLE_CLASS_DXF(ACTION, UNDERLAY, PDFUNDERLAY)\n  STABLE_CLASS_DXF(ACTION, UNDERLAY, DGNUNDERLAY)\n  STABLE_CLASS_DXF(ACTION, UNDERLAY, DWFUNDERLAY)\n  STABLE_CLASS    (ACTION, WIPEOUT)   /*ent*/\n\n  /* Objects */\n  STABLE_CLASS    (ACTION, DICTIONARYVAR)\n  STABLE_CLASS_DXF(ACTION, DICTIONARYWDFLT, ACDBDICTIONARYWDFLT)\n  STABLE_CLASS    (ACTION, FIELD)\n  STABLE_CLASS    (ACTION, FIELDLIST)\n  STABLE_CLASS    (ACTION, GROUP)\n  STABLE_CLASS    (ACTION, HATCH)\n  STABLE_CLASS    (ACTION, IDBUFFER)\n  STABLE_CLASS    (ACTION, IMAGEDEF)\n  STABLE_CLASS    (ACTION, IMAGEDEF_REACTOR)\n  STABLE_CLASS    (ACTION, LAYER_INDEX)\n  STABLE_CLASS    (ACTION, LAYOUT)\n  STABLE_CLASS    (ACTION, LWPOLYLINE)\n  STABLE_CLASS    (ACTION, MLEADERSTYLE)\n  STABLE_CLASS    (ACTION, OBJECTCONTEXTDATA)\n  STABLE_CLASS_CPP(ACTION, OBJECTCONTEXTDATA, AcDbObjectContextData)\n  STABLE_CLASS_DXF(ACTION, PLACEHOLDER, ACDBPLACEHOLDER)\n  STABLE_CLASS    (ACTION, RASTERVARIABLES)\n  STABLE_CLASS    (ACTION, SCALE)\n  STABLE_CLASS    (ACTION, SORTENTSTABLE)\n  STABLE_CLASS    (ACTION, SPATIAL_FILTER)\n  STABLE_CLASS    (ACTION, SPATIAL_INDEX)\n  STABLE_CLASS    (ACTION, UNDERLAY)              /* ent DGN DWF PDF */\n  STABLE_CLASS    (ACTION, UNDERLAYDEFINITION) //only tested pdf, but very simple\n  STABLE_CLASS_DXF(ACTION, UNDERLAYDEFINITION, PDFDEFINITION)\n  STABLE_CLASS_DXF(ACTION, UNDERLAYDEFINITION, DGNDEFINITION)\n  STABLE_CLASS_DXF(ACTION, UNDERLAYDEFINITION, DWFDEFINITION)\n  STABLE_CLASS    (ACTION, WIPEOUTVARIABLES)\n  STABLE_CLASS    (ACTION, XRECORD)\n\n  // unstable/undertested.\n  // not enough coverage, but assumed mostly ok. field names may change.\n  // DXF output skipped\n  UNSTABLE_CLASS     (ACTION, MULTILEADER)  /* ent */\n  UNSTABLE_CLASS_DXF (ACTION, ASSOCDEPENDENCY, ACDBASSOCDEPENDENCY)\n  UNSTABLE_CLASS_DXF (ACTION, ASSOCPLANESURFACEACTIONBODY, ACDBASSOCPLANESURFACEACTIONBODY)\n  UNSTABLE_CLASS     (ACTION, DIMASSOC)\n  UNSTABLE_CLASS     (ACTION, DBCOLOR)\n  UNSTABLE_CLASS_DXF (ACTION, DYNAMICBLOCKPURGEPREVENTER, ACDB_DYNAMICBLOCKPURGEPREVENTER_VERSION)\n  UNSTABLE_CLASS     (ACTION, GEODATA)\n  UNSTABLE_CLASS     (ACTION, HELIX)             /*ent */\n  UNSTABLE_CLASS     (ACTION, LIGHT)             /*ent */\n  UNSTABLE_CLASS     (ACTION, OBJECT_PTR)\n  UNSTABLE_CLASS_CPP (ACTION, OBJECT_PTR, CAseDLPNTableRecord)\n  UNSTABLE_CLASS_DXF (ACTION, PROXY_OBJECT, PROXY)\n  UNSTABLE_CLASS_DXF (ACTION, PERSSUBENTMANAGER, ACDBPERSSUBENTMANAGER)\n  UNSTABLE_CLASS     (ACTION, VISUALSTYLE)\n  UNSTABLE_CLASS     (ACTION, TABLESTYLE)        // pre-r2010 only\n\n  // coverage exists, but broken and being worked on. needs -DDEBUG_CLASSES. See also\n  // examples/unknown with all the unknown blobs of these.\n  // PROXY_ENTITY has a fixed type\n  // DXF output skipped, but some INDXF are done.\n  DEBUGGING_CLASS     (ACTION, GEOPOSITIONMARKER) /*ent, yet unsorted. no coverage */\n  DEBUGGING_CLASS     (ACTION, PLANESURFACE)      /*ent */\n  DEBUGGING_CLASS     (ACTION, EXTRUDEDSURFACE)   /*ent */\n  DEBUGGING_CLASS     (ACTION, LOFTEDSURFACE)     /*ent */\n  DEBUGGING_CLASS     (ACTION, REVOLVEDSURFACE)   /*ent */\n  DEBUGGING_CLASS     (ACTION, SWEPTSURFACE)      /*ent */\n  DEBUGGING_CLASS_DXF (ACTION, TABLE, ACAD_TABLE) /*ent, r2010+ needs subclassing */\n  DEBUGGING_CLASS     (ACTION, ARC_DIMENSION) //ent\n  DEBUGGING_CLASS     (ACTION, TABLECONTENT) //wrong values\n  DEBUGGING_CLASS     (ACTION, TABLEGEOMETRY) //wrong geom_data\n  DEBUGGING_CLASS     (ACTION, CELLSTYLEMAP) //broken\n  DEBUGGING_CLASS     (ACTION, MATERIAL)     //working on\n  DEBUGGING_CLASS     (ACTION, PLOTSETTINGS) //yet unsorted\n  DEBUGGING_CLASS     (ACTION, SUN)          //90%\n  DEBUGGING_CLASS     (ACTION, SUNSTUDY)     //almost\n  DEBUGGING_CLASS     (ACTION, VBA_PROJECT)  //Has its own section?\n  DEBUGGING_CLASS     (ACTION, ACSH_SWEEP_CLASS) //SWEEPOPTIONS?\n  DEBUGGING_CLASS     (ACTION, GEOMAPIMAGE)  // LiveMap image overlay\n  DEBUGGING_CLASS_DXF (ACTION, NAVISWORKSMODELDEF, ACDBNAVISWORKSMODELDEF)\n  DEBUGGING_CLASS_DXF (ACTION, ASSOCACTION, ACDBASSOCACTION)\n  DEBUGGING_CLASS_DXF (ACTION, ASSOCNETWORK, ACDBASSOCNETWORK) /* very close */\n  DEBUGGING_CLASS_DXF (ACTION, ASSOCALIGNEDDIMACTIONBODY, ACDBASSOCALIGNEDDIMACTIONBODY)\n  DEBUGGING_CLASS_DXF (ACTION, ASSOCOSNAPPOINTREFACTIONPARAM, ACDBASSOCOSNAPPOINTREFACTIONPARAM)\n  DEBUGGING_CLASS_DXF (ACTION, ASSOCPERSSUBENTMANAGER, ACDBASSOCPERSSUBENTMANAGER)\n  DEBUGGING_CLASS_DXF (ACTION, ASSOC2DCONSTRAINTGROUP, ACDBASSOC2DCONSTRAINTGROUP)\n  DEBUGGING_CLASS_DXF (ACTION, EVALUATION_GRAPH, ACAD_EVALUATION_GRAPH) /* almost */\n  DEBUGGING_CLASS     (ACTION, MESH)\n  DEBUGGING_CLASS     (ACTION, RENDERENVIRONMENT) //no coverage\n  DEBUGGING_CLASS     (ACTION, RENDERGLOBAL)      //no coverage\n\n  // unimplemented, passed through. coverage exists mostly, but documentation not.\n  // DXF output skipped\n  UNHANDLED_CLASS     (ACTION, ACSH_HISTORY_CLASS)\n  UNHANDLED_CLASS     (ACTION, ARCALIGNEDTEXT)\n  UNHANDLED_CLASS_DXF (ACTION, ASSOCGEOMDEPENDENCY, ACDBASSOCGEOMDEPENDENCY)\n  UNHANDLED_CLASS_DXF (ACTION, ASSOCOSNAPPOINTREFACTIONPARAM, ACDBASSOCOSNAPPOINTREFACTIONPARAM)\n  UNHANDLED_CLASS_DXF (ACTION, ASSOCVERTEXACTIONPARAM, ACDBASSOCVERTEXACTIONPARAM)\n  UNHANDLED_CLASS     (ACTION, DATATABLE)\n  UNHANDLED_CLASS_DXF (ACTION, DETAILVIEWSTYLE, ACDBDETAILVIEWSTYLE)\n  UNHANDLED_CLASS_DXF (ACTION, DOCUMENTOPTIONS, CSACDOCUMENTOPTIONS)\n  UNHANDLED_CLASS     (ACTION, LAYER_FILTER)\n  UNHANDLED_CLASS     (ACTION, LAYOUTPRINTCONFIG)\n  UNHANDLED_CLASS_DXF (ACTION, LEADEROBJECTCONTEXTDATA, ACDB_LEADEROBJECTCONTEXTDATA_CLASS)\n  UNHANDLED_CLASS     (ACTION, LIGHTLIST)\n  UNHANDLED_CLASS     (ACTION, NPOCOLLECTION)\n  UNHANDLED_CLASS_DXF (ACTION, POINTCLOUD, ACDBPOINTCLOUD)\n  UNHANDLED_CLASS     (ACTION, MENTALRAYRENDERSETTINGS) //no coverage\n  UNHANDLED_CLASS     (ACTION, RAPIDRTRENDERENVIRONMENT) //no coverage\n  UNHANDLED_CLASS     (ACTION, RAPIDRTRENDERSETTINGS) //no coverage\n  UNHANDLED_CLASS     (ACTION, RTEXT)\n  UNHANDLED_CLASS_DXF (ACTION, SECTIONVIEWSTYLE, ACDBSECTIONVIEWSTYLE)\n  UNHANDLED_CLASS_DXF (ACTION, XREFPANELOBJECT, EXACXREFPANELOBJECT)\n  UNHANDLED_CLASS_DXF (ACTION, ANNOTSCALEOBJECTCONTEXTDATA, ACDB_MLEADEROBJECTCONTEXTDATA_CLASS)\n  UNHANDLED_CLASS_DXF (ACTION, ANNOTSCALEOBJECTCONTEXTDATA, ACDB_MTEXTOBJECTCONTEXTDATA_CLASS)\n\n/* Missing DXF names:\n  ACSH_BOX_CLASS\n  ACAD_PROXY_ENTITY  ACDBPOINTCLOUDEX  ARRAY\n  ATTDYNBLOCKREF\n  ATTBLOCKREF  ATTDYNBLOCKREF  BLOCKREF  CENTERMARK CENTERLINE\n  DYNBLOCKREF XREF\n  SECTIONOBJECT\n*/\n", "/*****************************************************************************/\n/*  LibreDWG - free implementation of the DWG file format                    */\n/*                                                                           */\n/*  Copyright (C) 2009-2019 Free Software Foundation, Inc.                   */\n/*                                                                           */\n/*  This library is free software, licensed under the terms of the GNU       */\n/*  General Public License as published by the Free Software Foundation,     */\n/*  either version 3 of the License, or (at your option) any later version.  */\n/*  You should have received a copy of the GNU General Public License        */\n/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */\n/*****************************************************************************/\n\n/*\n * dec_macros.h: decoding macros (for encode, print, free in the C files)\n * written by Felipe Castro\n * modified by Felipe Corr\u00eaa da Silva Sances\n * modified by Rodrigo Rodrigues da Silva\n * modified by Reini Urban\n * modified by Denis Pruchkovsky\n */\n\n#ifdef HAVE_CTYPE_H\n#  include <ctype.h>\n#endif\n\n#define ACTION decode\n#define IS_DECODER\n\n#define VALUE(value, type, dxf)                                               \\\n  LOG_TRACE (FORMAT_##type \" [\" #type \" %d]\\n\", value, dxf)\n#define VALUE_RC(value, dxf) VALUE (value, RC, dxf)\n#define VALUE_RS(value, dxf) VALUE (value, RS, dxf)\n#define VALUE_RL(value, dxf) VALUE (value, RL, dxf)\n#define VALUE_RD(value, dxf) VALUE (value, RD, dxf)\n\n#define FIELDG(nam, type, dxf)                                                \\\n  {                                                                           \\\n    _obj->nam = bit_read_##type (dat);                                        \\\n    FIELD_G_TRACE (nam, type, dxf);                                           \\\n  }\n\n#define FIELD(nam, type)                                                      \\\n  {                                                                           \\\n    _obj->nam = bit_read_##type (dat);                                        \\\n    FIELD_TRACE (nam, type);                                                  \\\n  }\n#define SUB_FIELD(o, nam, type, dxf)                                          \\\n  {                                                                           \\\n    _obj->o.nam = bit_read_##type (dat);                                      \\\n    FIELD_G_TRACE (o.nam, type, dxf);                                         \\\n  }\n\n#define FIELD_CAST(nam, type, cast, dxf)                                      \\\n  {                                                                           \\\n    _obj->nam = (BITCODE_##cast)bit_read_##type (dat);                        \\\n    FIELD_G_TRACE (nam, cast, dxf);                                           \\\n  }\n\n#define FIELD_G_TRACE(nam, type, dxfgroup)                                    \\\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \\\n    {                                                                         \\\n      char *s1 = strrplc (#nam, \"[rcount1]\", \"[%d]\");                         \\\n      if (s1)                                                                 \\\n        {                                                                     \\\n          char *s2 = strrplc (s1, \"[rcount2]\", \"[%d]\");                       \\\n          if (s2)                                                             \\\n            {                                                                 \\\n              GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \\\n              LOG_TRACE (strcat (s2, \": \" FORMAT_##type \" [\" #type \" %d]\\n\"), \\\n                         rcount1, rcount2, _obj->nam, dxfgroup);              \\\n              GCC46_DIAG_RESTORE                                              \\\n              free (s2);                                                      \\\n              free (s1);                                                      \\\n            }                                                                 \\\n          else                                                                \\\n            {                                                                 \\\n              GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \\\n              LOG_TRACE (strcat (s1, \": \" FORMAT_##type \" [\" #type \" %d]\\n\"), \\\n                         rcount1, _obj->nam, dxfgroup);                       \\\n              GCC46_DIAG_RESTORE                                              \\\n              free (s1);                                                      \\\n            }                                                                 \\\n        }                                                                     \\\n      else                                                                    \\\n        LOG_TRACE (#nam \": \" FORMAT_##type \" [\" #type \" %d]\\n\", _obj->nam,    \\\n                   dxfgroup)                                                  \\\n    }\n#define FIELD_TRACE(nam, type)                                                \\\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \\\n    {                                                                         \\\n      char *s1 = strrplc (#nam, \"[rcount1]\", \"[%d]\");                         \\\n      if (s1)                                                                 \\\n        {                                                                     \\\n          char *s2 = strrplc (s1, \"[rcount2]\", \"[%d]\");                       \\\n          if (s2)                                                             \\\n            {                                                                 \\\n              GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \\\n              LOG_TRACE (strcat (s2, \": \" FORMAT_##type \" \" #type \"\\n\"),      \\\n                         rcount1, rcount2, _obj->nam)                         \\\n              GCC46_DIAG_RESTORE                                              \\\n              free (s2);                                                      \\\n              free (s1);                                                      \\\n            }                                                                 \\\n          else                                                                \\\n            {                                                                 \\\n              GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \\\n              LOG_TRACE (strcat (s1, \": \" FORMAT_##type \" \" #type \"\\n\"),      \\\n                         rcount1, _obj->nam)                                  \\\n              GCC46_DIAG_RESTORE                                              \\\n              free (s1);                                                      \\\n            }                                                                 \\\n        }                                                                     \\\n      else                                                                    \\\n        LOG_TRACE (#nam \": \" FORMAT_##type \" [\" #type \"]\\n\", _obj->nam)       \\\n    }\n#define LOG_TF(level, var, len)                                               \\\n  {                                                                           \\\n    int _i;                                                                   \\\n    for (_i = 0; _i < (len); _i++)                                            \\\n      {                                                                       \\\n        LOG (level, \"%02x\", (unsigned char)((char *)var)[_i]);                \\\n      }                                                                       \\\n    LOG (level, \"\\n\");                                                        \\\n    if (DWG_LOGLEVEL >= DWG_LOGLEVEL_INSANE)                                  \\\n      {                                                                       \\\n        for (_i = 0; _i < (len); _i++)                                        \\\n          {                                                                   \\\n            unsigned char c = ((unsigned char *)var)[_i];                     \\\n            LOG_INSANE (\"%-2c\", isprint (c) ? c : ' ');                       \\\n          }                                                                   \\\n        LOG_INSANE (\"\\n\");                                                    \\\n      }                                                                       \\\n  }\n#define LOG_TRACE_TF(var, len) LOG_TF (TRACE, var, len)\n#define LOG_INSANE_TF(var, len) LOG_TF (INSANE, var, len)\n#define FIELD_2PT_TRACE(nam, type, dxf)                                       \\\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \\\n    {                                                                         \\\n      char *s1 = strrplc (#nam, \"[rcount1]\", \"[%d]\");                         \\\n      if (s1)                                                                 \\\n        {                                                                     \\\n          char *s2 = strrplc (s1, \"[rcount2]\", \"[%d]\");                       \\\n          if (s2)                                                             \\\n            {                                                                 \\\n              GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \\\n              LOG_TRACE (strcat (s2, \": (\" FORMAT_BD \", \" FORMAT_BD           \\\n                                     \") [\" #type \" %d]\\n\"),                   \\\n                         rcount1, rcount2, _obj->nam.x, _obj->nam.y, dxf)     \\\n              GCC46_DIAG_RESTORE                                              \\\n              free (s2);                                                      \\\n              free (s1);                                                      \\\n            }                                                                 \\\n          else                                                                \\\n            {                                                                 \\\n              GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \\\n              LOG_TRACE (strcat (s1, \": (\" FORMAT_BD \", \" FORMAT_BD           \\\n                                     \") [\" #type \" %d]\\n\"),                   \\\n                         rcount1, _obj->nam.x, _obj->nam.y, dxf)              \\\n              GCC46_DIAG_RESTORE                                              \\\n              free (s1);                                                      \\\n            }                                                                 \\\n        }                                                                     \\\n      else                                                                    \\\n        LOG_TRACE (#nam \": (\" FORMAT_BD \", \" FORMAT_BD \") [\" #type \" %d]\\n\",  \\\n                   _obj->nam.x, _obj->nam.y, dxf)                             \\\n    }\n#define FIELD_3PT_TRACE(nam, type, dxf)                                       \\\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \\\n    {                                                                         \\\n      char *s1 = strrplc (#nam, \"[rcount1]\", \"[%d]\");                         \\\n      if (s1)                                                                 \\\n        {                                                                     \\\n          char *s2 = strrplc (s1, \"[rcount2]\", \"[%d]\");                       \\\n          if (s2)                                                             \\\n            {                                                                 \\\n              GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \\\n              LOG_TRACE (strcat (s2, \": (\" FORMAT_BD \", \" FORMAT_BD           \\\n                                     \", \" FORMAT_BD \") [\" #type \" %d]\\n\"),    \\\n                         rcount1, rcount2, _obj->nam.x, _obj->nam.y,          \\\n                         _obj->nam.z, dxf)                                    \\\n              GCC46_DIAG_RESTORE                                              \\\n              free (s2);                                                      \\\n              free (s1);                                                      \\\n            }                                                                 \\\n          else                                                                \\\n            {                                                                 \\\n              GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \\\n              LOG_TRACE (strcat (s1, \": (\" FORMAT_BD \", \" FORMAT_BD           \\\n                                     \", \" FORMAT_BD \") [\" #type \" %d]\\n\"),    \\\n                         rcount1, _obj->nam.x, _obj->nam.y, _obj->nam.z, dxf) \\\n              GCC46_DIAG_RESTORE                                              \\\n              free (s1);                                                      \\\n            }                                                                 \\\n        }                                                                     \\\n      else                                                                    \\\n        LOG_TRACE (#nam \": (\" FORMAT_BD \", \" FORMAT_BD \", \" FORMAT_BD         \\\n                        \") [\" #type \" %d]\\n\",                                 \\\n                   _obj->nam.x, _obj->nam.y, _obj->nam.z, dxf)                \\\n    }\n\n#define FIELD_VALUE(nam) _obj->nam\n\n#define ANYCODE -1\n#define VALUE_HANDLE(ref, nam, code, dxf)                                     \\\n  {                                                                           \\\n    unsigned long pos = bit_position (hdl_dat);                               \\\n    if (code >= 0)                                                            \\\n      ref = dwg_decode_handleref_with_code (hdl_dat, obj, dwg, code);         \\\n    else                                                                      \\\n      ref = dwg_decode_handleref (hdl_dat, obj, dwg);                         \\\n    if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                   \\\n      {                                                                       \\\n        if (ref)                                                              \\\n          {                                                                   \\\n            LOG_TRACE (#nam \": \" FORMAT_REF \" [H %d]\", ARGS_REF (ref), dxf);  \\\n            if (dwg_ref_object_silent (dwg, ref)                              \\\n                && DWG_LOGLEVEL > DWG_LOGLEVEL_TRACE)                         \\\n              {                                                               \\\n                const char *u8 = dwg_ref_tblname (dwg, ref);                  \\\n                HANDLER (OUTPUT, \" => %s %s\", dwg_ref_objname (dwg, ref), u8);\\\n                if (dwg->header.version >= R_2007 && u8 && *u8)               \\\n                  free ((void*)u8);                                           \\\n              }                                                               \\\n          }                                                                   \\\n        else                                                                  \\\n          {                                                                   \\\n            LOG_TRACE (#nam \": NULL %d [H %d]\", code, dxf);                   \\\n          }                                                                   \\\n        LOG_INSANE (\" @%lu.%u\", pos / 8, (unsigned)(pos % 8));                \\\n        LOG_TRACE (\"\\n\");                                                     \\\n      }                                                                       \\\n  }\n#define FIELD_HANDLE(nam, code, dxf) VALUE_HANDLE (_obj->nam, nam, code, dxf)\n#define SUB_FIELD_HANDLE(o, nam, code, dxf)                                   \\\n  VALUE_HANDLE (_obj->o.nam, o.nam, code, dxf)\n\n#define VALUE_HANDLE_N(ref, nam, vcount, code, dxf)                           \\\n  {                                                                           \\\n    unsigned long pos = bit_position (hdl_dat);                               \\\n    if (code >= 0)                                                            \\\n      ref = dwg_decode_handleref_with_code (hdl_dat, obj, dwg, code);         \\\n    else                                                                      \\\n      ref = dwg_decode_handleref (hdl_dat, obj, dwg);                         \\\n    if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                   \\\n      {                                                                       \\\n        if (ref)                                                              \\\n          {                                                                   \\\n            LOG_TRACE (#nam \"[%d]: \" FORMAT_REF \" [H* %d]\", (int)vcount,      \\\n                       ARGS_REF (ref), dxf);                                  \\\n            if (dwg_ref_object_silent (dwg, ref)                              \\\n                && DWG_LOGLEVEL > DWG_LOGLEVEL_TRACE)                         \\\n              {                                                               \\\n                const char *u8 = dwg_ref_tblname (dwg, ref);                  \\\n                HANDLER (OUTPUT, \" => %s %s\", dwg_ref_objname (dwg, ref), u8);\\\n                if (dwg->header.version >= R_2007 && u8 && *u8)               \\\n                  free ((void*)u8);                                           \\\n              }                                                               \\\n          }                                                                   \\\n        else                                                                  \\\n          {                                                                   \\\n            LOG_TRACE (#nam \"[%d]: NULL %d [H* %d]\", (int)vcount, code, dxf); \\\n          }                                                                   \\\n        LOG_INSANE (\" @%lu.%u\", pos / 8, (unsigned)(pos % 8));                \\\n        LOG_TRACE (\"\\n\");                                                     \\\n      }                                                                       \\\n  }\n#define FIELD_HANDLE_N(nam, vcount, code, dxf)                                \\\n  VALUE_HANDLE_N (_obj->nam, nam, vcount, code, dxf)\n\n#define FIELD_DATAHANDLE(nam, code, dxf)                                      \\\n  {                                                                           \\\n    _obj->nam = dwg_decode_handleref (dat, obj, dwg);                         \\\n    if (_obj->nam)                                                            \\\n      {                                                                       \\\n        LOG_TRACE (#nam \": \" FORMAT_H \" [H %d]\\n\",                            \\\n                   ARGS_H (_obj->nam->handleref), dxf);                       \\\n      }                                                                       \\\n  }\n\n#define FIELD_B(nam, dxf) FIELDG (nam, B, dxf)\n#define FIELD_BB(nam, dxf) FIELDG (nam, BB, dxf)\n#define FIELD_3B(nam, dxf) FIELDG (nam, 3B, dxf)\n#define FIELD_BS(nam, dxf) FIELDG (nam, BS, dxf)\n#define FIELD_BL(nam, dxf) FIELDG (nam, BL, dxf)\n#define FIELD_BLL(nam, dxf) FIELDG (nam, BLL, dxf)\n#define FIELD_BD(nam, dxf)                                                    \\\n  {                                                                           \\\n    _obj->nam = bit_read_BD (dat);                                            \\\n    if (bit_isnan (_obj->nam))                                                \\\n      {                                                                       \\\n        FIELD_G_TRACE (nam, BD, dxf);                                         \\\n        LOG_ERROR (\"Invalid BD \" #nam);                                       \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n    if (dxf >= 50 && dxf < 54)                                                \\\n      {                                                                       \\\n        LOG_TRACE (#nam \": \" FORMAT_BD \" [BD %d]  %g\u00ba\\n\", _obj->nam, dxf,     \\\n                   rad2deg (_obj->nam));                                      \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        FIELD_G_TRACE (nam, BD, dxf);                                         \\\n      }                                                                       \\\n  }\n#define FIELD_BLx(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam = bit_read_BL (dat);                                            \\\n    LOG_TRACE (#nam \": 0x%x [BLx %d]\\n\", (uint32_t)_obj->nam, dxf);           \\\n  }\n#define FIELD_RLx(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam = bit_read_RL (dat);                                            \\\n    LOG_TRACE (#nam \": 0x%x [RLx %d]\\n\", (uint32_t)_obj->nam, dxf);           \\\n  }\n#define FIELD_BSx(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam = bit_read_BS (dat);                                            \\\n    LOG_TRACE (#nam \": 0x%x [BSx %d]\\n\", _obj->nam, dxf);                     \\\n  }\n#define FIELD_BSd(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam = bit_read_BS (dat);                                            \\\n    LOG_TRACE (#nam \": \" FORMAT_BSd \" [BSd %d]\\n\", _obj->nam, dxf);           \\\n  }\n#define SUB_FIELD_BSd(o, nam, dxf)                                            \\\n  {                                                                           \\\n    _obj->o.nam = (BITCODE_BSd)bit_read_BS (dat);                             \\\n    LOG_TRACE (#o \".\" #nam \": \" FORMAT_BSd \" [BSd %d]\\n\", _obj->o.nam, dxf);  \\\n  }\n#define FIELD_BLd(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam = bit_read_BL (dat);                                            \\\n    LOG_TRACE (#nam \": \" FORMAT_BLd \" [BLd %d]\\n\", _obj->nam, dxf);           \\\n  }\n#define FIELD_RLd(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam = bit_read_RL (dat);                                            \\\n    LOG_TRACE (#nam \": \" FORMAT_RLd \" [RLd %d]\\n\", _obj->nam, dxf);           \\\n  }\n#define FIELD_RC(nam, dxf) FIELDG (nam, RC, dxf)\n#define FIELD_RCu(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam = bit_read_RC (dat);                                            \\\n    LOG_TRACE (#nam \": %u [RC %d]\\n\", (unsigned)((unsigned char)_obj->nam),   \\\n               dxf);                                                          \\\n  }\n#define FIELD_RCd(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam = bit_read_RC (dat);                                            \\\n    LOG_TRACE (#nam \": %d [RC %d]\\n\", (int)((signed char)_obj->nam), dxf);    \\\n  }\n#define FIELD_RS(nam, dxf) FIELDG (nam, RS, dxf)\n#define FIELD_RSx(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam = bit_read_RS (dat);                                            \\\n    LOG_TRACE (#nam \": \" FORMAT_RSx \" [RSx %d]\\n\", _obj->nam, dxf);           \\\n  }\n#define FIELD_RD(nam, dxf)                                                    \\\n  {                                                                           \\\n    FIELDG (nam, RD, dxf);                                                    \\\n    if (bit_isnan (_obj->nam))                                                \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid RD \" #nam);                                       \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n  }\n#define FIELD_RL(nam, dxf) FIELDG (nam, RL, dxf)\n#define FIELD_RLL(nam, dxf) FIELDG (nam, RLL, dxf)\n#define FIELD_MC(nam, dxf) FIELDG (nam, MC, dxf)\n#define FIELD_MS(nam, dxf) FIELDG (nam, MS, dxf)\n/* preR13 we have no obj->address and obj->size yet, skip VECTOR_CHKCOUNT */\n// clang-format off\n#define FIELD_TF(nam, len, dxf)                                               \\\n  {                                                                           \\\n    SINCE (R_13) { _obj->nam = NULL; VECTOR_CHKCOUNT (nam, TF, len, dat) }    \\\n    _obj->nam = bit_read_TF (dat, (int)len);                                  \\\n    LOG_TRACE (#nam \": \\\"%s\\\" [TF %lu \" #dxf \"]\\n\", _obj->nam, (unsigned long)len); \\\n    LOG_INSANE_TF (FIELD_VALUE (nam), (int)len);                              \\\n  }\n#define FIELD_TFF(nam, len, dxf)                                              \\\n  {                                                                           \\\n    SINCE (R_13) { VECTOR_CHKCOUNT (nam, TF, len, dat) }                      \\\n    bit_read_fixed (dat, _obj->nam, (int)len);                                \\\n    LOG_TRACE (#nam \": \\\"%s\\\" [TFF %d \" #dxf \"]\\n\", _obj->nam, (int)len);     \\\n    LOG_INSANE_TF (FIELD_VALUE (nam), (int)len);                              \\\n  }\n// clang-format on\n#define FIELD_TV(nam, dxf) FIELDG (nam, TV, dxf)\n#define FIELD_TU(nam, dxf)                                                    \\\n  {                                                                           \\\n    _obj->nam = (BITCODE_TU)bit_read_TU (str_dat);                            \\\n    LOG_TRACE_TU (#nam, (BITCODE_TU)FIELD_VALUE (nam), dxf);                  \\\n  }\n#define FIELD_T(nam, dxf)                                                     \\\n  {                                                                           \\\n    if (dat->version < R_2007)                                                \\\n      {                                                                       \\\n        FIELD_TV (nam, dxf)                                                   \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        if (!obj || obj->has_strings) /* header_vars */                       \\\n          {                                                                   \\\n            _obj->nam = (BITCODE_T)bit_read_TU (str_dat);                     \\\n            LOG_TRACE_TU (#nam, (BITCODE_TU)FIELD_VALUE (nam), dxf);          \\\n          }                                                                   \\\n        else                                                                  \\\n          {                                                                   \\\n            LOG_TRACE_TU (#nam, L\"\", dxf);                                    \\\n          }                                                                   \\\n      }                                                                       \\\n  }\n#define FIELD_BT(nam, dxf) FIELDG (nam, BT, dxf)\n#define FIELD_4BITS(nam, dxf)                                                 \\\n  {                                                                           \\\n    int _b = _obj->nam = bit_read_4BITS (dat);                                \\\n    LOG_TRACE (#nam \": b%d%d%d%d [4BITS %d]\\n\", _b & 8, _b & 4, _b & 2,       \\\n               _b & 1, dxf);                                                  \\\n  }\n\n#define FIELD_BE(nam, dxf)                                                    \\\n  {                                                                           \\\n    bit_read_BE (dat, &_obj->nam.x, &_obj->nam.y, &_obj->nam.z);              \\\n    if (_obj->nam.z != 1.0)                                                   \\\n        LOG_TRACE (#nam \": (%f, %f, %f) [BE %d]\\n\", _obj->nam.x, _obj->nam.y, \\\n                   _obj->nam.z, dxf);                                         \\\n  }\n#define FIELD_DD(nam, _default, dxf)                                          \\\n  {                                                                           \\\n    FIELD_VALUE (nam) = bit_read_DD (dat, _default);                          \\\n    if (bit_isnan (_obj->nam))                                                \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid DD \" #nam);                                       \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n  }\n#define FIELD_2DD(nam, d1, d2, dxf)                                           \\\n  {                                                                           \\\n    FIELD_DD (nam.x, d1, dxf);                                                \\\n    FIELD_DD (nam.y, d2, dxf + 10);                                           \\\n    FIELD_2PT_TRACE (nam, 2DD, dxf);                                           \\\n  }\n#define FIELD_3DD(nam, def, dxf)                                              \\\n  {                                                                           \\\n    FIELD_DD (nam.x, FIELD_VALUE (def.x), dxf);                               \\\n    FIELD_DD (nam.y, FIELD_VALUE (def.y), dxf + 10);                          \\\n    FIELD_DD (nam.z, FIELD_VALUE (def.z), dxf + 20);                          \\\n    FIELD_3PT_TRACE (nam, 3DD, dxf);                                           \\\n  }\n#define FIELD_3RD(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam.x = bit_read_RD (dat);                                          \\\n    _obj->nam.y = bit_read_RD (dat);                                          \\\n    _obj->nam.z = bit_read_RD (dat);                                          \\\n    if (bit_isnan (_obj->nam.x) || bit_isnan (_obj->nam.y)                    \\\n        || bit_isnan (_obj->nam.z))                                           \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid 3RD \" #nam);                                      \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n    FIELD_3PT_TRACE (nam, 3RD, dxf);                                           \\\n  }\n#define FIELD_3BD(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam.x = bit_read_BD (dat);                                          \\\n    _obj->nam.y = bit_read_BD (dat);                                          \\\n    _obj->nam.z = bit_read_BD (dat);                                          \\\n    if (bit_isnan (_obj->nam.x) || bit_isnan (_obj->nam.y)                    \\\n        || bit_isnan (_obj->nam.z))                                           \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid 3BD \" #nam);                                      \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n    FIELD_3PT_TRACE (nam, 3BD, dxf);                                           \\\n  }\n#define FIELD_2RD(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam.x = bit_read_RD (dat);                                          \\\n    _obj->nam.y = bit_read_RD (dat);                                          \\\n    if (bit_isnan (_obj->nam.x) || bit_isnan (_obj->nam.y))                   \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid 2RD \" #nam);                                      \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n    FIELD_2PT_TRACE (nam, 2RD, dxf);                                           \\\n  }\n#define FIELD_2BD(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam.x = bit_read_BD (dat);                                          \\\n    _obj->nam.y = bit_read_BD (dat);                                          \\\n    if (bit_isnan (_obj->nam.x) || bit_isnan (_obj->nam.y))                   \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid 2BD \" #nam);                                      \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n    FIELD_2PT_TRACE (nam, 2BD, dxf);                                           \\\n  }\n#define FIELD_2BD_1(nam, dxf)                                                 \\\n  {                                                                           \\\n    _obj->nam.x = bit_read_BD (dat);                                          \\\n    _obj->nam.y = bit_read_BD (dat);                                          \\\n    if (bit_isnan (_obj->nam.x) || bit_isnan (_obj->nam.y))                   \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid 2BD_1 \" #nam);                                    \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n    FIELD_2PT_TRACE (nam, 2BD_1, dxf);                                           \\\n  }\n// FIELDG(nam.x, BD, dxf); FIELDG(nam.y, BD, dxf+1);\n#define FIELD_3BD_1(nam, dxf)                                                 \\\n  {                                                                           \\\n    _obj->nam.x = bit_read_BD (dat);                                          \\\n    _obj->nam.y = bit_read_BD (dat);                                          \\\n    _obj->nam.z = bit_read_BD (dat);                                          \\\n    if (bit_isnan (_obj->nam.x) || bit_isnan (_obj->nam.y)                    \\\n        || bit_isnan (_obj->nam.z))                                           \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid 3BD_1 \" #nam);                                    \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n    FIELD_3PT_TRACE (nam, 3BD_1, dxf);                                           \\\n  }\n//    FIELDG(nam.x, BD, dxf); FIELDG(nam.y, BD, dxf+1);\n//    FIELDG(nam.z, BD, dxf+2); }\n#define FIELD_3DPOINT(nam, dxf) FIELD_3BD (nam, dxf)\n#define FIELD_3DVECTOR(nam, dxf) FIELD_3BD_1 (nam, dxf)\n#define FIELD_TIMEBLL(nam, dxf)                                               \\\n  {                                                                           \\\n    _obj->nam = bit_read_TIMEBLL (dat);                                       \\\n    LOG_TRACE (#nam \": %.8f  (\" FORMAT_BL \", \" FORMAT_BL \") [TIMEBLL %d]\\n\",  \\\n               _obj->nam.value, _obj->nam.days, _obj->nam.ms, dxf);           \\\n  }\n#define FIELD_TIMERLL(nam, dxf)                                               \\\n  {                                                                           \\\n    _obj->nam = bit_read_TIMERLL (dat);                                       \\\n    LOG_TRACE (#nam \": %.8f  (\" FORMAT_RL \", \" FORMAT_RL \") [TIMERLL %d]\\n\",  \\\n               _obj->nam.value, _obj->nam.days, _obj->nam.ms, dxf);           \\\n  }\n#define FIELD_CMC(color, dxf1, dxf2)                                          \\\n  {                                                                           \\\n    bit_read_CMC (dat, &_obj->color);                                         \\\n    LOG_TRACE (#color \".index: %d [CMC.BS %d]\\n\", _obj->color.index, dxf1);   \\\n    if (dat->version >= R_2004)                                               \\\n      {                                                                       \\\n        LOG_TRACE (#color \".rgb: 0x%06x [CMC.BL %d]\\n\",                       \\\n                   (unsigned)_obj->color.rgb, dxf2);                          \\\n        LOG_TRACE (#color \".flag: 0x%x [CMC.RC]\\n\",                           \\\n                   (unsigned)_obj->color.flag);                               \\\n        if (_obj->color.flag & 1)                                             \\\n          LOG_TRACE (#color \".name: %s [CMC.TV]\\n\", _obj->color.name);        \\\n        if (_obj->color.flag & 2)                                             \\\n          LOG_TRACE (#color \".bookname: %s [CMC.TV]\\n\",                       \\\n                     _obj->color.book_name);                                  \\\n      }                                                                       \\\n  }\n#define SUB_FIELD_CMC(o, color, dxf1, dxf2)                                   \\\n  {                                                                           \\\n    bit_read_CMC (dat, &_obj->o.color);                                       \\\n    LOG_TRACE (#o \".\" #color \".index: %d [CMC.BS %d]\\n\", _obj->o.color.index, dxf1); \\\n    if (dat->version >= R_2004)                                               \\\n      {                                                                       \\\n        LOG_TRACE (#o \".\" #color \".rgb: 0x%06x [CMC.BL %d]\\n\",                       \\\n                   (unsigned)_obj->o.color.rgb, dxf2);                        \\\n        LOG_TRACE (#o \".\" #color \".flag: 0x%x [CMC.RC]\\n\",                           \\\n                   (unsigned)_obj->o.color.flag);                             \\\n        if (_obj->o.color.flag & 1)                                           \\\n          LOG_TRACE (#o \".\" #color \".name: %s [CMC.TV]\\n\", _obj->o.color.name);      \\\n        if (_obj->o.color.flag & 2)                                           \\\n          LOG_TRACE (#o \".\" #color \".bookname: %s [CMC.TV]\\n\",                       \\\n                     _obj->o.color.book_name);                                \\\n      }                                                                       \\\n  }\n#define FIELD_ENC(color, dxf1, dxf2)                                          \\\n  {                                                                           \\\n    bit_read_ENC (dat, hdl_dat, str_dat, &_obj->color);                       \\\n    LOG_TRACE (#color \".index: %d [ENC.BS %d]\\n\", _obj->color.index, dxf1);   \\\n    if (dat->version >= R_2004)                                               \\\n      {                                                                       \\\n        if (_obj->color.flag)                                                 \\\n          LOG_TRACE (#color \".flag: 0x%x\\n\", (unsigned)_obj->color.flag);     \\\n        if (_obj->color.flag & 0x20)                                          \\\n          LOG_TRACE (#color \".alpha: %d [ENC.BL %d]\\n\",                       \\\n                     (int)_obj->color.alpha, dxf2 + 20);                      \\\n        if (_obj->color.flag & 0x80)                                          \\\n          LOG_TRACE (#color \".rgb: 0x%06x [ENC.BL %d]\\n\",                     \\\n                     (unsigned)_obj->color.rgb, dxf2);                        \\\n        if (_obj->color.flag & 0x40 && _obj->color.handle)                    \\\n          LOG_TRACE (#color \".handle: %X [ENC.H %d]\\n\",                       \\\n                     _obj->color.handle->handleref.value, dxf2 + 10);         \\\n      }                                                                       \\\n  }\n#define SUB_FIELD_ENC(o, color, dxf1, dxf2)                                   \\\n  {                                                                           \\\n    bit_read_ENC (dat, hdl_dat, str_dat, &_obj->o.color);                     \\\n    LOG_TRACE (#o \".\" #color \".index: %d [ENC.BS %d]\\n\", _obj->o.color.index, dxf1); \\\n    if (dat->version >= R_2004)                                               \\\n      {                                                                       \\\n        if (_obj->o.color.flag)                                               \\\n          LOG_TRACE (#o \".\" #color \".flag: 0x%x\\n\", (unsigned)_obj->o.color.flag);   \\\n        if (_obj->o.color.flag & 0x20)                                        \\\n          LOG_TRACE (#o \".\" #color \".alpha: %d [ENC.BL %d]\\n\",                       \\\n                     (unsigned)_obj->o.color.alpha, dxf2 + 20);               \\\n        if (_obj->o.color.flag & 0x80)                                        \\\n          LOG_TRACE (#o \".\" #color \".rgb: 0x%06x [ENC.BL %d]\\n\",                     \\\n                     (unsigned)_obj->o.color.rgb, dxf2);                      \\\n        if (_obj->o.color.flag & 0x40 && _obj->o.color.handle)                \\\n          LOG_TRACE (#o \".\" #color \".handle: %lX [ENC.H %d]\\n\",                      \\\n                     _obj->o.color.handle->handleref.value, dxf2 + 10);       \\\n      }                                                                       \\\n  }\n\n#undef DEBUG_POS\n#undef DEBUG_HERE\n#undef DEBUG_POS_OBJ\n#undef DEBUG_HERE_OBJ\n#define DEBUG_POS_OBJ                                                         \\\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \\\n    {                                                                         \\\n      LOG_TRACE (\"DEBUG_POS @%u.%u (%lu) %lu\\n\", (unsigned int)dat->byte,     \\\n                 dat->bit, bit_position (dat),                                \\\n                 obj ? bit_position (dat) - obj->address * 8 : 0);            \\\n    }\n#define DEBUG_POS                                                             \\\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \\\n    {                                                                         \\\n      LOG_TRACE (\"DEBUG_POS @%u.%u (%lu)\\n\", (unsigned int)dat->byte,         \\\n                 dat->bit, bit_position (dat));                               \\\n    }\n#define _DEBUG_HERE                                                           \\\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \\\n    {                                                                         \\\n      Bit_Chain here = *dat;                                                  \\\n      int oldloglevel = loglevel;                                             \\\n      char *tmp;                                                              \\\n      BITCODE_BB bb = 0;                                                      \\\n      BITCODE_RS rs;                                                          \\\n      BITCODE_RL rl;                                                          \\\n      double bd;                                                              \\\n      Dwg_Handle hdl;                                                         \\\n      tmp = bit_read_TF (dat, 24);                                            \\\n      if (DWG_LOGLEVEL >= DWG_LOGLEVEL_INSANE)                                \\\n        {                                                                     \\\n          bit_fprint_bits (stderr, (unsigned char *)tmp, 68);                 \\\n          fprintf (stderr, \"\\n\");                                             \\\n        }                                                                     \\\n      LOG_TRACE_TF (tmp, 24);                                                 \\\n      free (tmp);                                                             \\\n      SINCE (R_13)                                                            \\\n      {                                                                       \\\n        *dat = here;                                                          \\\n        LOG_TRACE (\"  B  :\" FORMAT_B \"\\t\", bit_read_B (dat));                 \\\n        *dat = here;                                                          \\\n        bb = bit_read_BB (dat) & 0x3;                                         \\\n        LOG_TRACE (\"  BB :\" FORMAT_BB \"\\n\", bb);                              \\\n      }                                                                       \\\n      *dat = here;                                                            \\\n      rs = bit_read_RS (dat);                                                 \\\n      LOG_TRACE (\"  RS :\" FORMAT_RS \" / 0x%04x (16)\\n\", rs, rs);              \\\n      SINCE (R_13)                                                            \\\n      {                                                                       \\\n        *dat = here;                                                          \\\n        rs = bit_read_BS (dat);                                               \\\n        LOG_TRACE (\"  BS :\" FORMAT_BS \" / 0x%04x (%ld)\\t\", rs, rs,            \\\n                   bit_position (dat) - bit_position (&here));                \\\n      }                                                                       \\\n      SINCE (R_2007)                                                          \\\n      {                                                                       \\\n        *dat = here;                                                          \\\n        rs = bit_read_MS (dat);                                               \\\n        LOG_TRACE (\"  MS :\" FORMAT_RS \" / 0x%04x (%ld)\\n\", rs, rs,            \\\n                   bit_position (dat) - bit_position (&here));                \\\n      }                                                                       \\\n      else LOG_TRACE (\"\\n\");                                                  \\\n      *dat = here;                                                            \\\n      rl = bit_read_RL (dat);                                                 \\\n      LOG_TRACE (\"  RL :\" FORMAT_RL \" / 0x%08x (32)\\n\", rl, rl);              \\\n      *dat = here;                                                            \\\n      LOG_TRACE (\"  RD :\" FORMAT_RD \" (64)\\n\", bit_read_RD (dat));            \\\n      *dat = here;                                                            \\\n      SINCE (R_13)                                                            \\\n      {                                                                       \\\n        if (bb != 3)                                                          \\\n          {                                                                   \\\n            rl = bit_read_BL (dat);                                           \\\n            LOG_TRACE (\"  BL :\" FORMAT_BL \" / 0x%08x (%ld)\\n\", rl, rl,        \\\n                       bit_position (dat) - bit_position (&here));            \\\n            *dat = here;                                                      \\\n            bd = bit_read_BD (dat);                                           \\\n            LOG_TRACE (\"  BD :\" FORMAT_BD \" (%ld)\\n\", bd,                     \\\n                       bit_position (dat) - bit_position (&here));            \\\n            *dat = here;                                                      \\\n          }                                                                   \\\n      }                                                                       \\\n      if ((dat->chain[dat->byte] & 0xf) <= 4)                                 \\\n        {                                                                     \\\n          loglevel = 0;                                                       \\\n          if (!bit_read_H (dat, &hdl))                                        \\\n            {                                                                 \\\n              LOG_TRACE (\"  H : \" FORMAT_H \" (%ld)\\n\", ARGS_H (hdl),          \\\n                         bit_position (dat) - bit_position (&here));          \\\n            }                                                                 \\\n          loglevel = oldloglevel;                                             \\\n        }                                                                     \\\n      *dat = here;                                                            \\\n    }\n#define DEBUG_HERE_OBJ                                                        \\\n  DEBUG_POS_OBJ                                                               \\\n  _DEBUG_HERE\n#define DEBUG_HERE                                                            \\\n  DEBUG_POS                                                                   \\\n  _DEBUG_HERE\n\n// check for overflow into next object (invalid num_elems)\n#define AVAIL_BITS(dat)                                                       \\\n  (obj ? (long long)((obj->size * 8) - bit_position (dat) + 20) : 0xff00LL)\n#define TYPE_MAXELEMSIZE(type) dwg_bits_size[BITS_##type]\n#define VECTOR_CHKCOUNT(nam, type, size, dat)                                 \\\n  if ((long long)(size) > AVAIL_BITS (dat) ||                                 \\\n      (long long)((size)*TYPE_MAXELEMSIZE (type)) > AVAIL_BITS (dat))         \\\n    {                                                                         \\\n      LOG_ERROR (\"Invalid \" #nam \" size %ld. Need min. %u bits for \" #type    \\\n                 \", have %lld for %s.\",                                       \\\n                 (long)(size), (unsigned)(size)*TYPE_MAXELEMSIZE (type),      \\\n                 AVAIL_BITS (dat), SAFEDXFNAME);                              \\\n      if (_obj->nam) free (_obj->nam);                                        \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }\n#define VECTOR_CHKCOUNT_LV(nam, type, size, dat)                              \\\n  if ((long long)(size) > AVAIL_BITS (dat) ||                                 \\\n      (long long)((size)*TYPE_MAXELEMSIZE (type)) > AVAIL_BITS (dat))         \\\n    {                                                                         \\\n      LOG_ERROR (\"Invalid \" #nam \" size %ld. Need min. %u bits for \" #type    \\\n                 \", have %lld for %s.\",                                       \\\n                 (long)(size), (unsigned)(size)*TYPE_MAXELEMSIZE (type),      \\\n                 AVAIL_BITS (dat), SAFEDXFNAME);                              \\\n      if (_obj->nam) free (_obj->nam);                                        \\\n      size = 0;                                                               \\\n      /* return DWG_ERR_VALUEOUTOFBOUNDS; */                                  \\\n    }\n#define _VECTOR_CHKCOUNT(nam, size, maxelemsize, dat)                         \\\n  if ((long long)(size) > AVAIL_BITS (dat) ||                                 \\\n      (long long)((size) * (maxelemsize)) > AVAIL_BITS (dat))                 \\\n    {                                                                         \\\n      LOG_ERROR (\"Invalid \" #nam                                              \\\n                 \" size %ld. Need min. %u bits, have %lld for %s.\",           \\\n                 (long)(size), (unsigned)(size) * (maxelemsize),              \\\n                 AVAIL_BITS (dat), SAFEDXFNAME);                              \\\n      size = 0;                                                               \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }\n#define HANDLE_VECTOR_CHKCOUNT(nam, size)                                     \\\n  _VECTOR_CHKCOUNT (nam, size, TYPE_MAXELEMSIZE(HANDLE), hdl_dat)\n\n// FIELD_VECTOR_N(name, type, size):\n// reads data of the type indicated by 'type' 'size' times and stores\n// it all in the vector called 'name'.\n#define FIELD_VECTOR_N(name, type, size, dxf)                                 \\\n  if (size > 0)                                                               \\\n    {                                                                         \\\n      VECTOR_CHKCOUNT (name, type, size, dat)                                 \\\n      _obj->name = (BITCODE_##type *)calloc (size, sizeof (BITCODE_##type));  \\\n      for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \\\n        {                                                                     \\\n          _obj->name[vcount] = bit_read_##type (dat);                         \\\n          LOG_INSANE (#name \"[%ld]: \" FORMAT_##type \"\\n\", (long)vcount,       \\\n                      _obj->name[vcount])                                     \\\n        }                                                                     \\\n    }\n#define FIELD_VECTOR_T(name, size, dxf)                                       \\\n  if (_obj->size > 0)                                                         \\\n    {                                                                         \\\n      _VECTOR_CHKCOUNT (name, _obj->size, dat->version >= R_2007 ? 18 : 2,    \\\n                        dat)                                                  \\\n      _obj->name = calloc (_obj->size, sizeof (char *));                      \\\n      for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)             \\\n        {                                                                     \\\n          PRE (R_2007)                                                        \\\n          {                                                                   \\\n            _obj->name[vcount] = bit_read_TV (dat);                           \\\n            LOG_TRACE (#name \"[%ld]: %s\\n\", (long)vcount, _obj->name[vcount]) \\\n          }                                                                   \\\n          LATER_VERSIONS                                                      \\\n          {                                                                   \\\n            _obj->name[vcount] = (char *)bit_read_TU (dat);                   \\\n            LOG_TRACE_TU_I (#name, vcount, _obj->name[vcount], dxf)           \\\n          }                                                                   \\\n        }                                                                     \\\n    }\n#define FIELD_VECTOR_N1(name, type, size, dxf)                                \\\n  if (size > 0)                                                               \\\n    {                                                                         \\\n      int _dxf = dxf;                                                         \\\n      VECTOR_CHKCOUNT (name, type, size, dat)                                 \\\n      _obj->name = (BITCODE_##type *)calloc (size, sizeof (BITCODE_##type));  \\\n      for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \\\n        {                                                                     \\\n          _obj->name[vcount] = bit_read_##type (dat);                         \\\n          LOG_INSANE (#name \"[%ld]: \" FORMAT_##type \" [\" #type \" %d]\\n\",      \\\n                      (long)vcount, _obj->name[vcount], _dxf++)               \\\n        }                                                                     \\\n    }\n\n#define FIELD_VECTOR(name, type, size, dxf)                                   \\\n  FIELD_VECTOR_N (name, type, _obj->size, dxf)\n\n#define FIELD_2RD_VECTOR(name, size, dxf)                                     \\\n  VECTOR_CHKCOUNT_LV (name, 2RD, _obj->size, dat)                             \\\n  if (_obj->size > 0)                                                         \\\n    {                                                                         \\\n      _obj->name = (BITCODE_2RD *)calloc (_obj->size, sizeof (BITCODE_2RD));  \\\n      for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)             \\\n        {                                                                     \\\n          FIELD_2RD (name[vcount], dxf);                                      \\\n        }                                                                     \\\n    }                                                                         \\\n  else                                                                        \\\n    return DWG_ERR_VALUEOUTOFBOUNDS;\n\n#define FIELD_2DD_VECTOR(name, size, dxf)                                     \\\n  VECTOR_CHKCOUNT_LV (name, 2DD, _obj->size, dat)                             \\\n  if (_obj->size > 0)                                                         \\\n    {                                                                         \\\n      _obj->name = (BITCODE_2RD *)calloc (_obj->size, sizeof (BITCODE_2RD));  \\\n      FIELD_2RD (name[0], dxf);                                               \\\n      for (vcount = 1; vcount < (BITCODE_BL)_obj->size; vcount++)             \\\n        {                                                                     \\\n          FIELD_DD (name[vcount].x, FIELD_VALUE (name[vcount - 1].x), dxf);   \\\n          FIELD_DD (name[vcount].y, FIELD_VALUE (name[vcount - 1].y),         \\\n                    dxf + 10);                                                \\\n          LOG_TRACE (#name \"[%ld]: (\" FORMAT_BD \", \" FORMAT_BD \") [DD %d]\\n\", \\\n                     (long)vcount, _obj->name[vcount].x,                      \\\n                     _obj->name[vcount].y, dxf)                               \\\n        }                                                                     \\\n    }                                                                         \\\n  else                                                                        \\\n    return DWG_ERR_VALUEOUTOFBOUNDS;\n\n#define FIELD_3DPOINT_VECTOR(name, size, dxf)                                 \\\n  VECTOR_CHKCOUNT_LV (name, 3BD, _obj->size, dat)                             \\\n  if (_obj->size > 0)                                                         \\\n    {                                                                         \\\n      _obj->name                                                              \\\n          = (BITCODE_3DPOINT *)calloc (_obj->size, sizeof (BITCODE_3DPOINT)); \\\n      for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)             \\\n        {                                                                     \\\n          FIELD_3DPOINT (name[vcount], dxf);                                  \\\n        }                                                                     \\\n    }                                                                         \\\n  else                                                                        \\\n    return DWG_ERR_VALUEOUTOFBOUNDS;\n\n// shortest handle: 8 bit\n#define HANDLE_VECTOR_N(nam, size, code, dxf)                                 \\\n  if (size > 0)                                                               \\\n    {                                                                         \\\n      FIELD_VALUE (nam) = (BITCODE_H *)calloc (size, sizeof (BITCODE_H));     \\\n      for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \\\n        {                                                                     \\\n          FIELD_HANDLE_N (nam[vcount], vcount, code, dxf);                    \\\n        }                                                                     \\\n    }\n\n#define HANDLE_VECTOR(nam, sizefield, code, dxf)                              \\\n  VECTOR_CHKCOUNT_LV (nam, HANDLE, FIELD_VALUE (sizefield), hdl_dat)          \\\n  HANDLE_VECTOR_N (nam, FIELD_VALUE (sizefield), code, dxf)\n\n// count 1 bytes, until non-1 bytes or a terminating zero\n#define FIELD_NUM_INSERTS(num_inserts, type, dxf)                             \\\n  FIELD_VALUE (num_inserts) = 0;                                              \\\n  vcount = 0;                                                                 \\\n  while ((vcount = (BITCODE_RC)bit_read_RC (dat)))                            \\\n    {                                                                         \\\n      FIELD_VALUE (num_inserts)++;                                            \\\n      LOG_INSANE (\"num_inserts [RC \" FORMAT_RL \"]: %d\\n\",                     \\\n                  FIELD_VALUE (num_inserts), (unsigned char)vcount)           \\\n      if (vcount != 1)                                                        \\\n        {                                                                     \\\n          LOG_WARN (\"num_inserts [RC \" FORMAT_RL \"]: %d != 1\",                \\\n                    FIELD_VALUE (num_inserts), (unsigned char)vcount)         \\\n          bit_advance_position (dat, -8);                                     \\\n          break;                                                              \\\n        }                                                                     \\\n    }                                                                         \\\n  LOG_TRACE (\"num_inserts: %d [RC* 0]\\n\", FIELD_VALUE (num_inserts))\n\n#define FIELD_XDATA(name, size)                                               \\\n  _obj->name = dwg_decode_xdata (dat, _obj, _obj->size)\n\n#define REACTORS(code)                                                        \\\n  if (obj->tio.object->num_reactors > 0)                                      \\\n    {                                                                         \\\n      HANDLE_VECTOR_CHKCOUNT (reactors, obj->tio.object->num_reactors)        \\\n      obj->tio.object->reactors                                               \\\n          = calloc (obj->tio.object->num_reactors, sizeof (BITCODE_H));       \\\n      for (vcount = 0; vcount < obj->tio.object->num_reactors; vcount++)      \\\n        {                                                                     \\\n          VALUE_HANDLE_N (obj->tio.object->reactors[vcount], reactors,        \\\n                          vcount, code, 330);                                 \\\n        }                                                                     \\\n    }\n\n#define ENT_REACTORS(code)                                                    \\\n  if (_ent->num_reactors > 0)                                                 \\\n    {                                                                         \\\n      HANDLE_VECTOR_CHKCOUNT (reactors, _ent->num_reactors)                   \\\n      _ent->reactors = calloc (_ent->num_reactors, sizeof (BITCODE_H));       \\\n      for (vcount = 0; vcount < _ent->num_reactors; vcount++)                 \\\n        {                                                                     \\\n          VALUE_HANDLE_N (_ent->reactors[vcount], reactors, vcount, code,     \\\n                          330);                                               \\\n        }                                                                     \\\n    }\n\n#define XDICOBJHANDLE(code)                                                   \\\n  SINCE (R_2004)                                                              \\\n  {                                                                           \\\n    if (!obj->tio.object->xdic_missing_flag)                                  \\\n      {                                                                       \\\n        VALUE_HANDLE (obj->tio.object->xdicobjhandle, xdicobjhandle, code,    \\\n                      360);                                                   \\\n        if (!obj->tio.object->xdicobjhandle)                                  \\\n          obj->tio.object->xdic_missing_flag = 1;                             \\\n      }                                                                       \\\n  }                                                                           \\\n  else                                                                        \\\n  {                                                                           \\\n    SINCE (R_13)                                                              \\\n    {                                                                         \\\n      VALUE_HANDLE (obj->tio.object->xdicobjhandle, xdicobjhandle, code,      \\\n                    360);                                                     \\\n    }                                                                         \\\n  }\n\n#define ENT_XDICOBJHANDLE(code)                                               \\\n  SINCE (R_2004)                                                              \\\n  {                                                                           \\\n    if (!_ent->xdic_missing_flag)                                             \\\n      {                                                                       \\\n        VALUE_HANDLE (_ent->xdicobjhandle, xdicobjhandle, code, 360);         \\\n      }                                                                       \\\n  }                                                                           \\\n  else                                                                        \\\n  {                                                                           \\\n    SINCE (R_13)                                                              \\\n    {                                                                         \\\n      VALUE_HANDLE (_ent->xdicobjhandle, xdicobjhandle, code, 360);           \\\n    }                                                                         \\\n  }\n\n#define SECTION_STRING_STREAM                                                 \\\n  {                                                                           \\\n    Bit_Chain sav_dat = *dat;                                                 \\\n    dat = str_dat;\n\n// TODO: unused\n#define START_STRING_STREAM                                                   \\\n  obj->has_strings = bit_read_B (dat);                                        \\\n  if (obj->has_strings)                                                       \\\n    {                                                                         \\\n      Bit_Chain sav_dat = *dat;                                               \\\n      obj_string_stream (dat, obj, dat);\n\n#define END_STRING_STREAM                                                     \\\n  *dat = sav_dat;                                                             \\\n  }\n/* just checking. skip the has_strings bit. hdl_dat is already set */\n#define START_HANDLE_STREAM                                                   \\\n  if (dat->version >= R_2007)                                                 \\\n    {                                                                         \\\n      vcount = 1 + bit_position (dat);                                        \\\n      if (obj->hdlpos != (unsigned long)vcount)                               \\\n        {                                                                     \\\n          LOG_HANDLE (\" handle stream: %+ld @%lu.%u %s (@%lu.%u \"             \\\n                      \" @%lu.%u)\\n\",                                          \\\n                      (long)obj->hdlpos - (long)vcount, dat->byte, dat->bit,  \\\n                      ((long)obj->hdlpos - (long)vcount) >= 8                 \\\n                          ? \"MISSING\"                                         \\\n                          : ((long)obj->hdlpos < (long)vcount) ? \"OVERSHOOT\"  \\\n                                                               : \"\",          \\\n                      obj->hdlpos / 8, (unsigned)obj->hdlpos % 8,             \\\n                      hdl_dat->byte, hdl_dat->bit);                           \\\n          bit_set_position (dat, obj->hdlpos);                                \\\n        }                                                                     \\\n    }\n\n#define REPEAT_CHKCOUNT(name, times, type)                                    \\\n  if (AVAIL_BITS (dat) < 0)                                                   \\\n    {                                                                         \\\n      LOG_ERROR (\"Invalid \" #name \" in %s. No bytes left.\\n\", SAFEDXFNAME);   \\\n      if (_obj->name) { free (_obj->name); _obj->name = NULL; }               \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }                                                                         \\\n  LOG_INSANE (\"REPEAT_CHKCOUNT %s.\" #name \" x %ld: %lld > %lld?\\n\",           \\\n              SAFEDXFNAME, (long)times, (long long)((times) * sizeof (type)), \\\n              AVAIL_BITS (dat));                                              \\\n  if ((long long)((times) * sizeof (type)) > AVAIL_BITS (dat))                \\\n    {                                                                         \\\n      LOG_ERROR (\"Invalid %s.\" #name \" x %ld\\n\", SAFEDXFNAME, (long)times);   \\\n      if (_obj->name) { free (_obj->name); _obj->name = NULL; }               \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }\n#define REPEAT_CHKCOUNT_LVAL(name, times, type)                               \\\n  if (AVAIL_BITS (dat) < 0)                                                   \\\n    {                                                                         \\\n      LOG_ERROR (\"Invalid %s.\" #name \". No bytes left.\\n\", SAFEDXFNAME);      \\\n      times = 0;                                                              \\\n      if (_obj->name) { free (_obj->name); _obj->name = NULL; }               \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }                                                                         \\\n  LOG_INSANE (\"REPEAT_CHKCOUNT_LVAL %s.\" #name \" x %ld: %lld > %lld?\\n\",      \\\n              SAFEDXFNAME, (long)times, (long long)((times) * sizeof (type)), \\\n              AVAIL_BITS (dat));                                              \\\n  if ((long long)((times) * sizeof (type)) > AVAIL_BITS (dat))                \\\n    {                                                                         \\\n      LOG_ERROR (\"Invalid %s.\" #name \" x %ld\\n\", SAFEDXFNAME, (long)times);   \\\n      times = 0;                                                              \\\n      if (_obj->name) { free (_obj->name); _obj->name = NULL; }               \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }\n\n/* REPEAT names:\n  _ adds idx\n  C does no checks\n  N does constant times (else _obj->times)\n  F does not calloc/free\n*/\n\n// unchecked with constant times\n#define REPEAT_CN(times, name, type)                                          \\\n  if (times > 0)                                                              \\\n    _obj->name = (type *)calloc (times, sizeof (type));                       \\\n  for (rcount1 = 0; rcount1 < (BITCODE_BL)times; rcount1++)\n// checked with constant times\n#define REPEAT_N(times, name, type)                                           \\\n  REPEAT_CHKCOUNT (name, times, type)                                         \\\n  if (times > 0)                                                              \\\n    _obj->name = (type *)calloc (times, sizeof (type));                       \\\n  for (rcount1 = 0; rcount1 < (BITCODE_BL)times; rcount1++)\n\n// checked with var. times\n#define _REPEAT(times, name, type, idx)                                       \\\n  REPEAT_CHKCOUNT_LVAL (name, _obj->times, type)                              \\\n  if (_obj->times > 0)                                                        \\\n    _obj->name = (type *)calloc (_obj->times, sizeof (type));                 \\\n  for (rcount##idx = 0; rcount##idx < (BITCODE_BL)_obj->times; rcount##idx++)\n// unchecked with var. times\n#define _REPEAT_C(times, name, type, idx)                                     \\\n  if (_obj->times > 0)                                                        \\\n    _obj->name = (type *)calloc (_obj->times, sizeof (type));                 \\\n  for (rcount##idx = 0; rcount##idx < (BITCODE_BL)_obj->times; rcount##idx++)\n// unchecked with constant times\n#define _REPEAT_CN(times, name, type, idx)                                    \\\n  if (times > 0)                                                              \\\n    _obj->name = (type *)calloc (times, sizeof (type));                       \\\n  if (_obj->name)                                                             \\\n    for (rcount##idx = 0; rcount##idx < (BITCODE_BL)times; rcount##idx++)\n// not allocating versions unchecked: _REPEAT_CNF\n// not allocating versions checked: _REPEAT_NF\n\n#define REPEAT(times, name, type) _REPEAT (times, name, type, 1)\n#define REPEAT2(times, name, type) _REPEAT (times, name, type, 2)\n#define REPEAT3(times, name, type) _REPEAT (times, name, type, 3)\n#define REPEAT4(times, name, type) _REPEAT (times, name, type, 4)\n\n#define REPEAT_C(times, name, type) _REPEAT_C (times, name, type, 1)\n#define REPEAT2_C(times, name, type) _REPEAT_C (times, name, type, 2)\n#define REPEAT3_C(times, name, type) _REPEAT_C (times, name, type, 3)\n#define REPEAT4_C(times, name, type) _REPEAT_C (times, name, type, 4)\n\n#define COMMON_ENTITY_HANDLE_DATA                                             \\\n  SINCE (R_13)                                                                \\\n  {                                                                           \\\n    START_HANDLE_STREAM;                                                      \\\n    PRE (R_2007)                                                              \\\n    {                                                                         \\\n      error |= dwg_decode_common_entity_handle_data (dat, hdl_dat, obj);      \\\n    }                                                                         \\\n  }\n\n/** Add the empty entity or object with its three structs to the DWG.\n    All fields are zero'd. TODO: some are initialized with default values, as\n    defined in dwg.spec.\n    Returns 0 or DWG_ERR_OUTOFMEM.\n*/\n\n#define DWG_ENTITY(token)                                                     \\\n  EXPORT int dwg_add_##token (Dwg_Object *obj)                                \\\n  {                                                                           \\\n    Dwg_Object_Entity *_ent;                                                  \\\n    Dwg_Entity_##token *_obj;                                                 \\\n    LOG_INFO (\"Add entity \" #token \" \")                                       \\\n    obj->parent->num_entities++;                                              \\\n    obj->supertype = DWG_SUPERTYPE_ENTITY;                                    \\\n    if (!(int)obj->fixedtype)                                                 \\\n      {                                                                       \\\n        obj->fixedtype = DWG_TYPE_##token;                                    \\\n      }                                                                       \\\n    if (!obj->dxfname)                                                        \\\n      {                                                                       \\\n        if (strlen (#token) > 3 && !memcmp (#token, \"_3D\", 3))                \\\n          obj->name = obj->dxfname = (char *)&#token[1];                      \\\n        else                                                                  \\\n          obj->name = obj->dxfname = (char *)#token;                          \\\n      }                                                                       \\\n    else if (!obj->name)                                                      \\\n      {                                                                       \\\n        if (strlen (#token) > 3 && !memcmp (#token, \"_3D\", 3))                \\\n          obj->name = (char *)&#token[1];                                     \\\n        else                                                                  \\\n          obj->name = (char *)#token;                                         \\\n      }                                                                       \\\n    _ent = obj->tio.entity = calloc (1, sizeof (Dwg_Object_Entity));          \\\n    if (!_ent)                                                                \\\n      return DWG_ERR_OUTOFMEM;                                                \\\n    _ent->tio.token = calloc (1, sizeof (Dwg_Entity_##token));                \\\n    if (!_ent->tio.token)                                                     \\\n      return DWG_ERR_OUTOFMEM;                                                \\\n    _ent->dwg = obj->parent;                                                  \\\n    _ent->objid = obj->index; /* obj ptr itself might move */                 \\\n    _ent->tio.token->parent = obj->tio.entity;                                \\\n    return 0;                                                                 \\\n  }                                                                           \\\n                                                                              \\\n  static int dwg_decode_##token##_private (                                   \\\n      Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,                 \\\n      Dwg_Object *restrict obj);                                              \\\n                                                                              \\\n  /**Call dwg_add_##token and write the fields from the bitstream dat to the  \\\n   * entity or object. */                                                     \\\n  static int dwg_decode_##token (Bit_Chain *restrict dat,                     \\\n                                 Dwg_Object *restrict obj)                    \\\n  {                                                                           \\\n    int error = dwg_add_##token (obj);                                        \\\n    if (error)                                                                \\\n      return error;                                                           \\\n    SINCE (R_2007)                                                            \\\n      {                                                                       \\\n        Bit_Chain obj_dat, str_dat, hdl_dat;                                  \\\n        obj_dat = *dat;                                                       \\\n        hdl_dat = *dat;                                                       \\\n        str_dat = *dat;                                                       \\\n        error = dwg_decode_##token##_private (&obj_dat, &hdl_dat,             \\\n                                              &str_dat, obj);                 \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        error = dwg_decode_##token##_private (dat, dat, dat, obj);            \\\n      }                                                                       \\\n    return error;                                                             \\\n  }                                                                           \\\n                                                                              \\\n  GCC30_DIAG_IGNORE (-Wformat-nonliteral)                                     \\\n  static int dwg_decode_##token##_private (                                   \\\n      Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,                 \\\n      Dwg_Object *restrict obj)                                               \\\n  {                                                                           \\\n    BITCODE_BL vcount, rcount3, rcount4;                                      \\\n    int error;                                                                \\\n    Dwg_Entity_##token *ent, *_obj;                                           \\\n    Dwg_Object_Entity *_ent;                                                  \\\n    Dwg_Data *dwg = obj->parent;                                              \\\n    LOG_INFO (\"Decode entity \" #token \"\\n\")                                   \\\n    _ent = obj->tio.entity;                                                   \\\n    ent = obj->tio.entity->tio.token;                                         \\\n    _obj = ent;                                                               \\\n    _ent->dwg = dwg;                                                          \\\n    _ent->objid = obj->index; /* obj ptr itself might move */                 \\\n    _obj->parent = obj->tio.entity;                                           \\\n    SINCE (R_13) { error = dwg_decode_entity (dat, hdl_dat, str_dat, _ent); } \\\n    else { error = decode_entity_preR13 (dat, obj, _ent); }                   \\\n    if (error >= DWG_ERR_CRITICAL)                                            \\\n      return error;\n\n// Does size include the CRC?\n#define DWG_ENTITY_END                                                        \\\n  {                                                                           \\\n    unsigned long pos = obj_stream_position (dat, hdl_dat, str_dat);          \\\n    int64_t padding = (obj->size * 8) - pos;                                  \\\n    SINCE (R_2007) bit_set_position (dat, pos);                               \\\n    if (padding)                                                              \\\n      LOG_HANDLE (\" padding: %+ld %s\\n\", (long)padding,                       \\\n                  padding >= 8 ? \"MISSING\"                                    \\\n                               : (padding < 0) ? \"OVERSHOOT\" : \"\");           \\\n  }                                                                           \\\n  return error & ~DWG_ERR_UNHANDLEDCLASS;                                     \\\n  }\n\n#define DWG_OBJECT(token)                                                     \\\n  EXPORT int dwg_add_##token (Dwg_Object *obj)                                \\\n  {                                                                           \\\n    Dwg_Object_##token *_obj;                                                 \\\n    LOG_INFO (\"Add object \" #token \" \")                                       \\\n    obj->supertype = DWG_SUPERTYPE_OBJECT;                                    \\\n    obj->tio.object = calloc (1, sizeof (Dwg_Object_Object));                 \\\n    if (!obj->tio.object)                                                     \\\n      return DWG_ERR_OUTOFMEM;                                                \\\n    _obj = obj->tio.object->tio.token                                         \\\n        = calloc (1, sizeof (Dwg_Object_##token));                            \\\n    if (!_obj)                                                                \\\n      {                                                                       \\\n        free (obj->tio.object);                                               \\\n        obj->tio.object = NULL;                                               \\\n        obj->fixedtype = DWG_TYPE_FREED;                                      \\\n        return DWG_ERR_OUTOFMEM;                                              \\\n      }                                                                       \\\n    if (!(int)obj->fixedtype)                                                 \\\n      {                                                                       \\\n        obj->fixedtype = DWG_TYPE_##token;                                    \\\n        obj->name = (char *)#token;                                           \\\n      }                                                                       \\\n    if (!obj->dxfname)                                                        \\\n      {                                                                       \\\n        if (!strcmp (#token, \"PLACEHOLDER\"))                                  \\\n          obj->dxfname = (char *)\"ACDBPLACEHOLDER\";                           \\\n        else                                                                  \\\n          obj->dxfname = (char *)#token;                                      \\\n      }                                                                       \\\n    _obj->parent = obj->tio.object;                                           \\\n    obj->tio.object->dwg = obj->parent;                                       \\\n    obj->tio.object->objid = obj->index; /* obj ptr itself might move */      \\\n    return 0;                                                                 \\\n  }                                                                           \\\n  static int dwg_decode_##token##_private (                                   \\\n      Bit_Chain *obj_dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,             \\\n      Dwg_Object *restrict obj);                                              \\\n                                                                              \\\n  static int dwg_decode_##token (Bit_Chain *restrict dat,                     \\\n                                 Dwg_Object *restrict obj)                    \\\n  {                                                                           \\\n    int error = dwg_add_##token (obj);                                        \\\n    if (error)                                                                \\\n      return error;                                                           \\\n    SINCE (R_2007)                                                            \\\n    {                                                                         \\\n      Bit_Chain obj_dat, str_dat, hdl_dat;                                    \\\n      obj_dat = *dat;                                                         \\\n      hdl_dat = *dat;                                                         \\\n      str_dat = *dat;                                                         \\\n      error                                                                   \\\n          = dwg_decode_##token##_private (&obj_dat, &hdl_dat, &str_dat, obj); \\\n    }                                                                         \\\n    else { error = dwg_decode_##token##_private (dat, dat, dat, obj); }       \\\n    return error;                                                             \\\n  }                                                                           \\\n                                                                              \\\n  GCC30_DIAG_IGNORE (-Wformat-nonliteral)                                     \\\n  static int dwg_decode_##token##_private (                                   \\\n      Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,                 \\\n      Dwg_Object *restrict obj)                                               \\\n  {                                                                           \\\n    BITCODE_BL vcount, rcount3, rcount4;                                      \\\n    int error;                                                                \\\n    Dwg_Object_##token *_obj;                                                 \\\n    Dwg_Data *dwg = obj->parent;                                              \\\n    LOG_INFO (\"Decode object \" #token \"\\n\")                                   \\\n    if (strNE (#token, \"TABLECONTENT\") || obj->fixedtype != DWG_TYPE_TABLE)   \\\n      {                                                                       \\\n        _obj = obj->tio.object->tio.token;                                    \\\n        error = dwg_decode_object (dat, hdl_dat, str_dat, obj->tio.object);   \\\n        if (error >= DWG_ERR_CRITICAL)                                        \\\n          return error;                                                       \\\n      }\n\n#define DWG_OBJECT_END DWG_ENTITY_END\n"], "fixing_code": ["/* -*- c -*- */\n/*****************************************************************************/\n/*  LibreDWG - free implementation of the DWG file format                    */\n/*                                                                           */\n/*  Copyright (C) 2018-2019 Free Software Foundation, Inc.                   */\n/*                                                                           */\n/*  This library is free software, licensed under the terms of the GNU       */\n/*  General Public License as published by the Free Software Foundation,     */\n/*  either version 3 of the License, or (at your option) any later version.  */\n/*  You should have received a copy of the GNU General Public License        */\n/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */\n/*****************************************************************************/\n\n/*\n * classes.inc: the dynamic class dispatcher\n * for all types > 500\n * written by Reini Urban\n */\n\n/**\n * Variable-typed classes and its stability\n */\n\n#ifndef ACTION\n# error ACTION define missing: decode, encode, dxf, indxf, print, free, ...\n#endif\n\n#define _XSTR(s) _STR(s)\n#define _STR(s)  #s\n\n#define WARN_UNHANDLED_CLASS \\\n      LOG_WARN (\"Unhandled Class %s %d %s (0x%x%s) %u/%lX\", is_entity ? \"entity\" : \"object\",\\\n               klass->number, klass->dxfname, klass->proxyflag,\\\n               klass->wasazombie ? \" was proxy\" : \"\",\\\n               obj->index, obj->handle.value)\n#define WARN_UNSTABLE_CLASS \\\n      LOG_WARN (\"Unstable Class %s %d %s (0x%x%s) %u/%lX\", is_entity ? \"entity\" : \"object\",\\\n               klass->number, klass->dxfname, klass->proxyflag,\\\n               klass->wasazombie ? \" was proxy\" : \"\",\\\n               obj->index, obj->handle.value)\n#if defined(IS_FREE) || defined(IS_PRINT)\n# undef WARN_UNSTABLE_CLASS\n# undef WARN_UNHANDLED_CLASS\n# define WARN_UNSTABLE_CLASS\n# define WARN_UNHANDLED_CLASS\n#endif\n\n#define DISALLOW_DXF(action, _name) \\\n  (strEQc (_STR(action), \"dxf\")) ? DWG_ERR_NOTYETSUPPORTED :\n#define ALLOW_DXF(action, _name)\n\n#ifdef DEBUG_CLASSES\n# define DEBUGGING_DXF(action, name)                 ALLOW_DXF(action, name)\n# define DEBUGGING_CLASS(action, name)               UNSTABLE_CLASS(action, name)\n# define DEBUGGING_CLASS_DXF(action, name, _dxfname) UNSTABLE_CLASS_DXF(action, name, _dxfname)\n# define DEBUGGING_CLASS_CPP(action, name, _cppname) UNSTABLE_CLASS_CPP(action, name, _cppname)\n#else\n# define DEBUGGING_DXF(action, name)                 DISALLOW_DXF(action, name)\n# define DEBUGGING_CLASS(action, name)               UNHANDLED_CLASS(action, name)\n# define DEBUGGING_CLASS_DXF(action, name, _dxfname) UNHANDLED_CLASS_DXF(action, name, _dxfname)\n# define DEBUGGING_CLASS_CPP(action, name, _cppname) UNHANDLED_CLASS_CPP(action, name, _cppname)\n#endif\n\n//#define _DWG_FUNC_N(action,name) dwg_ ## action ## _ ## name\n//#define DWG_FUNC_N(action,name) _DWG_FUNC_N(action,name)\n\n#define STABLE_CLASS(action, _name) \\\n  if (klass->dxfname && strEQc (klass->dxfname, #_name)) \\\n    { \\\n      if (strEQc (_STR(action), \"decode\") || !memcmp (_STR(action), \"in\", 2)) { \\\n        obj->name = (char*) #_name; \\\n        obj->dxfname = (char*) #_name; \\\n        obj->fixedtype = DWG_TYPE_##_name; \\\n      } \\\n      return DWG_FUNC_N(action,_name) (dat, obj); \\\n    }\n#define STABLE_CLASS_DXF(action, _name, _dxfname) \\\n  if (klass->dxfname && strEQc (klass->dxfname, #_dxfname)) \\\n    { \\\n      if (strEQc (_STR(action), \"decode\") || !memcmp (_STR(action), \"in\", 2)) { \\\n        obj->name = (char*) #_name; \\\n        obj->dxfname = (char*) #_dxfname; \\\n        obj->fixedtype = DWG_TYPE_##_name; \\\n      } \\\n      return DWG_FUNC_N(action,_name) (dat, obj); \\\n    }\n#define STABLE_CLASS_CPP(action, _name, _cppname) \\\n  if (klass->cppname && strEQc (klass->cppname, #_name)) \\\n    { \\\n      if (strEQc (_STR(action), \"decode\") || !memcmp (_STR(action), \"in\", 2)) { \\\n        obj->name = (char*) #_name; \\\n        obj->dxfname = (char*) #_name; \\\n        obj->fixedtype = DWG_TYPE_##_name; \\\n      } \\\n      return DWG_FUNC_N(action,_name) (dat, obj); \\\n    }\n#define UNSTABLE_CLASS(action, _name) \\\n  if (klass->dxfname && strEQc (klass->dxfname, #_name)) \\\n    { \\\n      WARN_UNSTABLE_CLASS; \\\n      if (strEQc (_STR(action), \"decode\") || !memcmp (_STR(action), \"in\", 2)) { \\\n        obj->name = (char*) #_name; \\\n        obj->dxfname = (char*) #_name; \\\n        obj->fixedtype = DWG_TYPE_##_name; \\\n      } \\\n      return DEBUGGING_DXF(action, name) DWG_FUNC_N(action,_name) (dat, obj); \\\n    }\n#define UNSTABLE_CLASS_DXF(action, _name, _dxfname) \\\n  if (klass->dxfname && strEQc (klass->dxfname, #_dxfname)) \\\n    { \\\n      WARN_UNSTABLE_CLASS; \\\n      if (strEQc (_STR(action), \"decode\") || !memcmp (_STR(action), \"in\", 2)) { \\\n        obj->name = (char*) #_name; \\\n        obj->dxfname = (char*) #_dxfname; \\\n        obj->fixedtype = DWG_TYPE_##_name; \\\n      } \\\n      return DEBUGGING_DXF(action, name) DWG_FUNC_N(action,_name) (dat, obj); \\\n    }\n#define UNSTABLE_CLASS_CPP(action, _name, _cppname) \\\n  if (klass->cppname && strEQc (klass->cppname, #_cppname)) \\\n    { \\\n      WARN_UNSTABLE_CLASS; \\\n      if (strEQc (_STR(action), \"decode\") || !memcmp (_STR(action), \"in\", 2)) { \\\n        obj->name = (char*) #_name; \\\n        obj->dxfname = (char*) #_name; \\\n        obj->fixedtype = DWG_TYPE_##_name; \\\n      } \\\n      return DEBUGGING_DXF(action, name) DWG_FUNC_N(action,_name) (dat, obj); \\\n    }\n#define UNHANDLED_CLASS(action, _name) \\\n  if (klass->dxfname && strEQc (klass->dxfname, #_name)) \\\n    { \\\n      WARN_UNHANDLED_CLASS; \\\n      if (strEQc (_STR(action), \"decode\") || !memcmp (_STR(action), \"in\", 2)) { \\\n        obj->name = (char*) #_name; \\\n        obj->dxfname = (char*) #_name; \\\n      } \\\n      return DWG_ERR_UNHANDLEDCLASS; \\\n    }\n#define UNHANDLED_CLASS_DXF(action, _name, _dxfname) \\\n  if (strEQc (klass->dxfname, #_dxfname)) \\\n    { \\\n      WARN_UNHANDLED_CLASS; \\\n      if (strEQc (_STR(action), \"decode\") || !memcmp (_STR(action), \"in\", 2)) { \\\n        obj->name = (char*) #_name; \\\n        obj->dxfname = (char*) #_dxfname; \\\n      } \\\n      return DWG_ERR_UNHANDLEDCLASS; \\\n    }\n#define UNHANDLED_CLASS_CPP(action, _name, _cppname) \\\n  if (klass->cppname && strEQc (klass->cppname, #_cppname)) \\\n    { \\\n      WARN_UNHANDLED_CLASS; \\\n      if (strEQc (_STR(action), \"decode\") || !memcmp (_STR(action), \"in\", 2)) { \\\n        obj->name = (char*) #_name; \\\n        obj->dxfname = (char*) #_name; \\\n      } \\\n      return DWG_ERR_UNHANDLEDCLASS; \\\n    }\n\n  /* Entities */\n  STABLE_CLASS    (ACTION, CAMERA)    /*ent, not persistent in a DWG */\n  STABLE_CLASS    (ACTION, IMAGE)     /*ent*/\n  STABLE_CLASS    (ACTION, OLE2FRAME) /*ent (also fixed) */\n  STABLE_CLASS_DXF(ACTION, UNDERLAY, PDFUNDERLAY)\n  STABLE_CLASS_DXF(ACTION, UNDERLAY, DGNUNDERLAY)\n  STABLE_CLASS_DXF(ACTION, UNDERLAY, DWFUNDERLAY)\n  STABLE_CLASS    (ACTION, WIPEOUT)   /*ent*/\n\n  /* Objects */\n  STABLE_CLASS    (ACTION, DICTIONARYVAR)\n  STABLE_CLASS_DXF(ACTION, DICTIONARYWDFLT, ACDBDICTIONARYWDFLT)\n  STABLE_CLASS    (ACTION, FIELD)\n  STABLE_CLASS    (ACTION, FIELDLIST)\n  STABLE_CLASS    (ACTION, GROUP)\n  STABLE_CLASS    (ACTION, HATCH)\n  STABLE_CLASS    (ACTION, IDBUFFER)\n  STABLE_CLASS    (ACTION, IMAGEDEF)\n  STABLE_CLASS    (ACTION, IMAGEDEF_REACTOR)\n  STABLE_CLASS    (ACTION, LAYER_INDEX)\n  STABLE_CLASS    (ACTION, LAYOUT) // TODO bottom_margin nan\n  STABLE_CLASS    (ACTION, LWPOLYLINE)\n  STABLE_CLASS    (ACTION, MLEADERSTYLE) // TODO block_rotation nan\n  STABLE_CLASS    (ACTION, OBJECTCONTEXTDATA)\n  STABLE_CLASS_CPP(ACTION, OBJECTCONTEXTDATA, AcDbObjectContextData)\n  STABLE_CLASS_DXF(ACTION, PLACEHOLDER, ACDBPLACEHOLDER)\n  STABLE_CLASS    (ACTION, RASTERVARIABLES)\n  STABLE_CLASS    (ACTION, SCALE)\n  STABLE_CLASS    (ACTION, SORTENTSTABLE)\n  STABLE_CLASS    (ACTION, SPATIAL_FILTER)\n  STABLE_CLASS    (ACTION, SPATIAL_INDEX)\n  STABLE_CLASS    (ACTION, UNDERLAY)              /* ent DGN DWF PDF */\n  STABLE_CLASS    (ACTION, UNDERLAYDEFINITION) //only tested pdf, but very simple\n  STABLE_CLASS_DXF(ACTION, UNDERLAYDEFINITION, PDFDEFINITION)\n  STABLE_CLASS_DXF(ACTION, UNDERLAYDEFINITION, DGNDEFINITION)\n  STABLE_CLASS_DXF(ACTION, UNDERLAYDEFINITION, DWFDEFINITION)\n  STABLE_CLASS    (ACTION, WIPEOUTVARIABLES)\n  STABLE_CLASS    (ACTION, XRECORD)\n\n  // unstable/undertested.\n  // not enough coverage, but assumed mostly ok. field names may change.\n  // DXF output skipped\n  UNSTABLE_CLASS     (ACTION, MULTILEADER)  /* ent */\n  UNSTABLE_CLASS_DXF (ACTION, ASSOCDEPENDENCY, ACDBASSOCDEPENDENCY)\n  UNSTABLE_CLASS_DXF (ACTION, ASSOCPLANESURFACEACTIONBODY, ACDBASSOCPLANESURFACEACTIONBODY)\n  UNSTABLE_CLASS     (ACTION, DIMASSOC)\n  UNSTABLE_CLASS     (ACTION, DBCOLOR)\n  UNSTABLE_CLASS_DXF (ACTION, DYNAMICBLOCKPURGEPREVENTER, ACDB_DYNAMICBLOCKPURGEPREVENTER_VERSION)\n  UNSTABLE_CLASS     (ACTION, GEODATA)\n  UNSTABLE_CLASS     (ACTION, HELIX)             /*ent */\n  UNSTABLE_CLASS     (ACTION, LIGHT)             /*ent */\n  UNSTABLE_CLASS     (ACTION, OBJECT_PTR)\n  UNSTABLE_CLASS_CPP (ACTION, OBJECT_PTR, CAseDLPNTableRecord)\n  UNSTABLE_CLASS_DXF (ACTION, PROXY_OBJECT, PROXY)\n  UNSTABLE_CLASS_DXF (ACTION, PERSSUBENTMANAGER, ACDBPERSSUBENTMANAGER)\n  UNSTABLE_CLASS     (ACTION, VISUALSTYLE)\n  UNSTABLE_CLASS     (ACTION, TABLESTYLE)        // pre-r2010 only\n\n  // coverage exists, but broken and being worked on. needs -DDEBUG_CLASSES. See also\n  // examples/unknown with all the unknown blobs of these.\n  // PROXY_ENTITY has a fixed type\n  // DXF output skipped, but some INDXF are done.\n  DEBUGGING_CLASS     (ACTION, GEOPOSITIONMARKER) /*ent, yet unsorted. no coverage */\n  DEBUGGING_CLASS     (ACTION, PLANESURFACE)      /*ent */\n  DEBUGGING_CLASS     (ACTION, EXTRUDEDSURFACE)   /*ent */\n  DEBUGGING_CLASS     (ACTION, LOFTEDSURFACE)     /*ent */\n  DEBUGGING_CLASS     (ACTION, REVOLVEDSURFACE)   /*ent */\n  DEBUGGING_CLASS     (ACTION, SWEPTSURFACE)      /*ent */\n  DEBUGGING_CLASS_DXF (ACTION, TABLE, ACAD_TABLE) /*ent, r2010+ needs subclassing */\n  DEBUGGING_CLASS     (ACTION, ARC_DIMENSION)     /*ent */\n  DEBUGGING_CLASS_CPP (ACTION, TABLECONTENT, AcDbTableContent)\n  DEBUGGING_CLASS     (ACTION, TABLEGEOMETRY) //wrong geom_data\n  DEBUGGING_CLASS     (ACTION, CELLSTYLEMAP) //broken\n  DEBUGGING_CLASS     (ACTION, MATERIAL)     //working on\n  DEBUGGING_CLASS     (ACTION, PLOTSETTINGS) //yet unsorted\n  DEBUGGING_CLASS     (ACTION, SUN)          //90%\n  DEBUGGING_CLASS     (ACTION, SUNSTUDY)     //almost\n  DEBUGGING_CLASS     (ACTION, VBA_PROJECT)  //Has its own section?\n  DEBUGGING_CLASS     (ACTION, ACSH_SWEEP_CLASS) //SWEEPOPTIONS?\n  DEBUGGING_CLASS     (ACTION, GEOMAPIMAGE)  // LiveMap image overlay\n  DEBUGGING_CLASS_DXF (ACTION, NAVISWORKSMODELDEF, ACDBNAVISWORKSMODELDEF)\n  DEBUGGING_CLASS_DXF (ACTION, ASSOCACTION, ACDBASSOCACTION)\n  DEBUGGING_CLASS_DXF (ACTION, ASSOCNETWORK, ACDBASSOCNETWORK) /* very close */\n  DEBUGGING_CLASS_DXF (ACTION, ASSOCALIGNEDDIMACTIONBODY, ACDBASSOCALIGNEDDIMACTIONBODY)\n  DEBUGGING_CLASS_DXF (ACTION, ASSOCOSNAPPOINTREFACTIONPARAM, ACDBASSOCOSNAPPOINTREFACTIONPARAM)\n  DEBUGGING_CLASS_DXF (ACTION, ASSOCPERSSUBENTMANAGER, ACDBASSOCPERSSUBENTMANAGER)\n  DEBUGGING_CLASS_DXF (ACTION, ASSOC2DCONSTRAINTGROUP, ACDBASSOC2DCONSTRAINTGROUP)\n  DEBUGGING_CLASS_DXF (ACTION, EVALUATION_GRAPH, ACAD_EVALUATION_GRAPH) /* almost */\n  DEBUGGING_CLASS     (ACTION, MESH)\n  DEBUGGING_CLASS     (ACTION, RENDERENVIRONMENT) //no coverage\n  DEBUGGING_CLASS     (ACTION, RENDERGLOBAL)      //no coverage\n\n  // unimplemented, passed through. coverage exists mostly, but documentation not.\n  // DXF output skipped\n  UNHANDLED_CLASS     (ACTION, ACSH_HISTORY_CLASS)\n  UNHANDLED_CLASS     (ACTION, ARCALIGNEDTEXT)\n  UNHANDLED_CLASS_DXF (ACTION, ASSOCGEOMDEPENDENCY, ACDBASSOCGEOMDEPENDENCY)\n  UNHANDLED_CLASS_DXF (ACTION, ASSOCOSNAPPOINTREFACTIONPARAM, ACDBASSOCOSNAPPOINTREFACTIONPARAM)\n  UNHANDLED_CLASS_DXF (ACTION, ASSOCVERTEXACTIONPARAM, ACDBASSOCVERTEXACTIONPARAM)\n  UNHANDLED_CLASS     (ACTION, DATATABLE)\n  UNHANDLED_CLASS_DXF (ACTION, DETAILVIEWSTYLE, ACDBDETAILVIEWSTYLE)\n  UNHANDLED_CLASS_DXF (ACTION, DOCUMENTOPTIONS, CSACDOCUMENTOPTIONS)\n  UNHANDLED_CLASS     (ACTION, LAYER_FILTER)\n  UNHANDLED_CLASS     (ACTION, LAYOUTPRINTCONFIG)\n  UNHANDLED_CLASS_DXF (ACTION, LEADEROBJECTCONTEXTDATA, ACDB_LEADEROBJECTCONTEXTDATA_CLASS)\n  UNHANDLED_CLASS     (ACTION, LIGHTLIST)\n  UNHANDLED_CLASS     (ACTION, NPOCOLLECTION)\n  UNHANDLED_CLASS_DXF (ACTION, POINTCLOUD, ACDBPOINTCLOUD)\n  UNHANDLED_CLASS     (ACTION, MENTALRAYRENDERSETTINGS) //no coverage\n  UNHANDLED_CLASS     (ACTION, RAPIDRTRENDERENVIRONMENT) //no coverage\n  UNHANDLED_CLASS     (ACTION, RAPIDRTRENDERSETTINGS) //no coverage\n  UNHANDLED_CLASS     (ACTION, RTEXT)\n  UNHANDLED_CLASS_DXF (ACTION, SECTIONVIEWSTYLE, ACDBSECTIONVIEWSTYLE)\n  UNHANDLED_CLASS_DXF (ACTION, XREFPANELOBJECT, EXACXREFPANELOBJECT)\n  UNHANDLED_CLASS_DXF (ACTION, ANNOTSCALEOBJECTCONTEXTDATA, ACDB_MLEADEROBJECTCONTEXTDATA_CLASS)\n  UNHANDLED_CLASS_DXF (ACTION, ANNOTSCALEOBJECTCONTEXTDATA, ACDB_MTEXTOBJECTCONTEXTDATA_CLASS)\n\n/* Missing DXF names:\n  ACSH_BOX_CLASS\n  ACAD_PROXY_ENTITY  ACDBPOINTCLOUDEX  ARRAY\n  ATTDYNBLOCKREF\n  ATTBLOCKREF  ATTDYNBLOCKREF  BLOCKREF  CENTERMARK CENTERLINE\n  DYNBLOCKREF XREF\n  SECTIONOBJECT\n*/\n", "/*****************************************************************************/\n/*  LibreDWG - free implementation of the DWG file format                    */\n/*                                                                           */\n/*  Copyright (C) 2009-2019 Free Software Foundation, Inc.                   */\n/*                                                                           */\n/*  This library is free software, licensed under the terms of the GNU       */\n/*  General Public License as published by the Free Software Foundation,     */\n/*  either version 3 of the License, or (at your option) any later version.  */\n/*  You should have received a copy of the GNU General Public License        */\n/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */\n/*****************************************************************************/\n\n/*\n * dec_macros.h: decoding macros (for encode, print, free in the C files)\n * written by Felipe Castro\n * modified by Felipe Corr\u00eaa da Silva Sances\n * modified by Rodrigo Rodrigues da Silva\n * modified by Reini Urban\n * modified by Denis Pruchkovsky\n */\n\n#ifdef HAVE_CTYPE_H\n#  include <ctype.h>\n#endif\n\n#define ACTION decode\n#define IS_DECODER\n\n#define VALUE(value, type, dxf)                                               \\\n  LOG_TRACE (FORMAT_##type \" [\" #type \" %d]\\n\", value, dxf)\n#define VALUE_RC(value, dxf) VALUE (value, RC, dxf)\n#define VALUE_RS(value, dxf) VALUE (value, RS, dxf)\n#define VALUE_RL(value, dxf) VALUE (value, RL, dxf)\n#define VALUE_RD(value, dxf) VALUE (value, RD, dxf)\n\n#define FIELDG(nam, type, dxf)                                                \\\n  {                                                                           \\\n    _obj->nam = bit_read_##type (dat);                                        \\\n    FIELD_G_TRACE (nam, type, dxf);                                           \\\n  }\n\n#define FIELD(nam, type)                                                      \\\n  {                                                                           \\\n    _obj->nam = bit_read_##type (dat);                                        \\\n    FIELD_TRACE (nam, type);                                                  \\\n  }\n#define SUB_FIELD(o, nam, type, dxf)                                          \\\n  {                                                                           \\\n    _obj->o.nam = bit_read_##type (dat);                                      \\\n    FIELD_G_TRACE (o.nam, type, dxf);                                         \\\n  }\n\n#define FIELD_CAST(nam, type, cast, dxf)                                      \\\n  {                                                                           \\\n    _obj->nam = (BITCODE_##cast)bit_read_##type (dat);                        \\\n    FIELD_G_TRACE (nam, cast, dxf);                                           \\\n  }\n\n#define FIELD_G_TRACE(nam, type, dxfgroup)                                    \\\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \\\n    {                                                                         \\\n      char *s1 = strrplc (#nam, \"[rcount1]\", \"[%d]\");                         \\\n      if (s1)                                                                 \\\n        {                                                                     \\\n          char *s2 = strrplc (s1, \"[rcount2]\", \"[%d]\");                       \\\n          if (s2)                                                             \\\n            {                                                                 \\\n              GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \\\n              LOG_TRACE (strcat (s2, \": \" FORMAT_##type \" [\" #type \" %d]\\n\"), \\\n                         rcount1, rcount2, _obj->nam, dxfgroup);              \\\n              GCC46_DIAG_RESTORE                                              \\\n              free (s2);                                                      \\\n              free (s1);                                                      \\\n            }                                                                 \\\n          else                                                                \\\n            {                                                                 \\\n              GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \\\n              LOG_TRACE (strcat (s1, \": \" FORMAT_##type \" [\" #type \" %d]\\n\"), \\\n                         rcount1, _obj->nam, dxfgroup);                       \\\n              GCC46_DIAG_RESTORE                                              \\\n              free (s1);                                                      \\\n            }                                                                 \\\n        }                                                                     \\\n      else                                                                    \\\n        LOG_TRACE (#nam \": \" FORMAT_##type \" [\" #type \" %d]\\n\", _obj->nam,    \\\n                   dxfgroup)                                                  \\\n    }\n#define FIELD_TRACE(nam, type)                                                \\\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \\\n    {                                                                         \\\n      char *s1 = strrplc (#nam, \"[rcount1]\", \"[%d]\");                         \\\n      if (s1)                                                                 \\\n        {                                                                     \\\n          char *s2 = strrplc (s1, \"[rcount2]\", \"[%d]\");                       \\\n          if (s2)                                                             \\\n            {                                                                 \\\n              GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \\\n              LOG_TRACE (strcat (s2, \": \" FORMAT_##type \" \" #type \"\\n\"),      \\\n                         rcount1, rcount2, _obj->nam)                         \\\n              GCC46_DIAG_RESTORE                                              \\\n              free (s2);                                                      \\\n              free (s1);                                                      \\\n            }                                                                 \\\n          else                                                                \\\n            {                                                                 \\\n              GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \\\n              LOG_TRACE (strcat (s1, \": \" FORMAT_##type \" \" #type \"\\n\"),      \\\n                         rcount1, _obj->nam)                                  \\\n              GCC46_DIAG_RESTORE                                              \\\n              free (s1);                                                      \\\n            }                                                                 \\\n        }                                                                     \\\n      else                                                                    \\\n        LOG_TRACE (#nam \": \" FORMAT_##type \" [\" #type \"]\\n\", _obj->nam)       \\\n    }\n#define LOG_TF(level, var, len)                                               \\\n  {                                                                           \\\n    int _i;                                                                   \\\n    for (_i = 0; _i < (len); _i++)                                            \\\n      {                                                                       \\\n        LOG (level, \"%02x\", (unsigned char)((char *)var)[_i]);                \\\n      }                                                                       \\\n    LOG (level, \"\\n\");                                                        \\\n    if (DWG_LOGLEVEL >= DWG_LOGLEVEL_INSANE)                                  \\\n      {                                                                       \\\n        for (_i = 0; _i < (len); _i++)                                        \\\n          {                                                                   \\\n            unsigned char c = ((unsigned char *)var)[_i];                     \\\n            LOG_INSANE (\"%-2c\", isprint (c) ? c : ' ');                       \\\n          }                                                                   \\\n        LOG_INSANE (\"\\n\");                                                    \\\n      }                                                                       \\\n  }\n#define LOG_TRACE_TF(var, len) LOG_TF (TRACE, var, len)\n#define LOG_INSANE_TF(var, len) LOG_TF (INSANE, var, len)\n#define FIELD_2PT_TRACE(nam, type, dxf)                                       \\\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \\\n    {                                                                         \\\n      char *s1 = strrplc (#nam, \"[rcount1]\", \"[%d]\");                         \\\n      if (s1)                                                                 \\\n        {                                                                     \\\n          char *s2 = strrplc (s1, \"[rcount2]\", \"[%d]\");                       \\\n          if (s2)                                                             \\\n            {                                                                 \\\n              GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \\\n              LOG_TRACE (strcat (s2, \": (\" FORMAT_BD \", \" FORMAT_BD           \\\n                                     \") [\" #type \" %d]\\n\"),                   \\\n                         rcount1, rcount2, _obj->nam.x, _obj->nam.y, dxf)     \\\n              GCC46_DIAG_RESTORE                                              \\\n              free (s2);                                                      \\\n              free (s1);                                                      \\\n            }                                                                 \\\n          else                                                                \\\n            {                                                                 \\\n              GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \\\n              LOG_TRACE (strcat (s1, \": (\" FORMAT_BD \", \" FORMAT_BD           \\\n                                     \") [\" #type \" %d]\\n\"),                   \\\n                         rcount1, _obj->nam.x, _obj->nam.y, dxf)              \\\n              GCC46_DIAG_RESTORE                                              \\\n              free (s1);                                                      \\\n            }                                                                 \\\n        }                                                                     \\\n      else                                                                    \\\n        LOG_TRACE (#nam \": (\" FORMAT_BD \", \" FORMAT_BD \") [\" #type \" %d]\\n\",  \\\n                   _obj->nam.x, _obj->nam.y, dxf)                             \\\n    }\n#define FIELD_3PT_TRACE(nam, type, dxf)                                       \\\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \\\n    {                                                                         \\\n      char *s1 = strrplc (#nam, \"[rcount1]\", \"[%d]\");                         \\\n      if (s1)                                                                 \\\n        {                                                                     \\\n          char *s2 = strrplc (s1, \"[rcount2]\", \"[%d]\");                       \\\n          if (s2)                                                             \\\n            {                                                                 \\\n              GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \\\n              LOG_TRACE (strcat (s2, \": (\" FORMAT_BD \", \" FORMAT_BD           \\\n                                     \", \" FORMAT_BD \") [\" #type \" %d]\\n\"),    \\\n                         rcount1, rcount2, _obj->nam.x, _obj->nam.y,          \\\n                         _obj->nam.z, dxf)                                    \\\n              GCC46_DIAG_RESTORE                                              \\\n              free (s2);                                                      \\\n              free (s1);                                                      \\\n            }                                                                 \\\n          else                                                                \\\n            {                                                                 \\\n              GCC46_DIAG_IGNORE (-Wformat-nonliteral)                       \\\n              LOG_TRACE (strcat (s1, \": (\" FORMAT_BD \", \" FORMAT_BD           \\\n                                     \", \" FORMAT_BD \") [\" #type \" %d]\\n\"),    \\\n                         rcount1, _obj->nam.x, _obj->nam.y, _obj->nam.z, dxf) \\\n              GCC46_DIAG_RESTORE                                              \\\n              free (s1);                                                      \\\n            }                                                                 \\\n        }                                                                     \\\n      else                                                                    \\\n        LOG_TRACE (#nam \": (\" FORMAT_BD \", \" FORMAT_BD \", \" FORMAT_BD         \\\n                        \") [\" #type \" %d]\\n\",                                 \\\n                   _obj->nam.x, _obj->nam.y, _obj->nam.z, dxf)                \\\n    }\n\n#define FIELD_VALUE(nam) _obj->nam\n\n#define ANYCODE -1\n#define VALUE_HANDLE(ref, nam, code, dxf)                                     \\\n  {                                                                           \\\n    unsigned long pos = bit_position (hdl_dat);                               \\\n    if (code >= 0)                                                            \\\n      ref = dwg_decode_handleref_with_code (hdl_dat, obj, dwg, code);         \\\n    else                                                                      \\\n      ref = dwg_decode_handleref (hdl_dat, obj, dwg);                         \\\n    if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                   \\\n      {                                                                       \\\n        if (ref)                                                              \\\n          {                                                                   \\\n            LOG_TRACE (#nam \": \" FORMAT_REF \" [H %d]\", ARGS_REF (ref), dxf);  \\\n            if (dwg_ref_object_silent (dwg, ref)                              \\\n                && DWG_LOGLEVEL > DWG_LOGLEVEL_TRACE)                         \\\n              {                                                               \\\n                const char *u8 = dwg_ref_tblname (dwg, ref);                  \\\n                HANDLER (OUTPUT, \" => %s %s\", dwg_ref_objname (dwg, ref), u8);\\\n                if (dwg->header.version >= R_2007 && u8 && *u8)               \\\n                  free ((void*)u8);                                           \\\n              }                                                               \\\n          }                                                                   \\\n        else                                                                  \\\n          {                                                                   \\\n            LOG_TRACE (#nam \": NULL %d [H %d]\", code, dxf);                   \\\n          }                                                                   \\\n        LOG_INSANE (\" @%lu.%u\", pos / 8, (unsigned)(pos % 8));                \\\n        LOG_TRACE (\"\\n\");                                                     \\\n      }                                                                       \\\n  }\n#define FIELD_HANDLE(nam, code, dxf) VALUE_HANDLE (_obj->nam, nam, code, dxf)\n#define SUB_FIELD_HANDLE(o, nam, code, dxf)                                   \\\n  VALUE_HANDLE (_obj->o.nam, o.nam, code, dxf)\n\n#define VALUE_HANDLE_N(ref, nam, vcount, code, dxf)                           \\\n  {                                                                           \\\n    unsigned long pos = bit_position (hdl_dat);                               \\\n    if (code >= 0)                                                            \\\n      ref = dwg_decode_handleref_with_code (hdl_dat, obj, dwg, code);         \\\n    else                                                                      \\\n      ref = dwg_decode_handleref (hdl_dat, obj, dwg);                         \\\n    if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                   \\\n      {                                                                       \\\n        if (ref)                                                              \\\n          {                                                                   \\\n            LOG_TRACE (#nam \"[%d]: \" FORMAT_REF \" [H* %d]\", (int)vcount,      \\\n                       ARGS_REF (ref), dxf);                                  \\\n            if (dwg_ref_object_silent (dwg, ref)                              \\\n                && DWG_LOGLEVEL > DWG_LOGLEVEL_TRACE)                         \\\n              {                                                               \\\n                const char *u8 = dwg_ref_tblname (dwg, ref);                  \\\n                HANDLER (OUTPUT, \" => %s %s\", dwg_ref_objname (dwg, ref), u8);\\\n                if (dwg->header.version >= R_2007 && u8 && *u8)               \\\n                  free ((void*)u8);                                           \\\n              }                                                               \\\n          }                                                                   \\\n        else                                                                  \\\n          {                                                                   \\\n            LOG_TRACE (#nam \"[%d]: NULL %d [H* %d]\", (int)vcount, code, dxf); \\\n          }                                                                   \\\n        LOG_INSANE (\" @%lu.%u\", pos / 8, (unsigned)(pos % 8));                \\\n        LOG_TRACE (\"\\n\");                                                     \\\n      }                                                                       \\\n  }\n#define FIELD_HANDLE_N(nam, vcount, code, dxf)                                \\\n  VALUE_HANDLE_N (_obj->nam, nam, vcount, code, dxf)\n\n#define FIELD_DATAHANDLE(nam, code, dxf)                                      \\\n  {                                                                           \\\n    _obj->nam = dwg_decode_handleref (dat, obj, dwg);                         \\\n    if (_obj->nam)                                                            \\\n      {                                                                       \\\n        LOG_TRACE (#nam \": \" FORMAT_H \" [H %d]\\n\",                            \\\n                   ARGS_H (_obj->nam->handleref), dxf);                       \\\n      }                                                                       \\\n  }\n\n#define FIELD_B(nam, dxf) FIELDG (nam, B, dxf)\n#define FIELD_BB(nam, dxf) FIELDG (nam, BB, dxf)\n#define FIELD_3B(nam, dxf) FIELDG (nam, 3B, dxf)\n#define FIELD_BS(nam, dxf) FIELDG (nam, BS, dxf)\n#define FIELD_BL(nam, dxf) FIELDG (nam, BL, dxf)\n#define FIELD_BLL(nam, dxf) FIELDG (nam, BLL, dxf)\n#define FIELD_BD(nam, dxf)                                                    \\\n  {                                                                           \\\n    _obj->nam = bit_read_BD (dat);                                            \\\n    if (bit_isnan (_obj->nam))                                                \\\n      {                                                                       \\\n        FIELD_G_TRACE (nam, BD, dxf);                                         \\\n        LOG_ERROR (\"Invalid BD \" #nam);                                       \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n    if (dxf >= 50 && dxf < 54)                                                \\\n      {                                                                       \\\n        LOG_TRACE (#nam \": \" FORMAT_BD \" [BD %d]  %g\u00ba\\n\", _obj->nam, dxf,     \\\n                   rad2deg (_obj->nam));                                      \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        FIELD_G_TRACE (nam, BD, dxf);                                         \\\n      }                                                                       \\\n  }\n#define FIELD_BLx(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam = bit_read_BL (dat);                                            \\\n    LOG_TRACE (#nam \": 0x%x [BLx %d]\\n\", (uint32_t)_obj->nam, dxf);           \\\n  }\n#define FIELD_RLx(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam = bit_read_RL (dat);                                            \\\n    LOG_TRACE (#nam \": 0x%x [RLx %d]\\n\", (uint32_t)_obj->nam, dxf);           \\\n  }\n#define FIELD_BSx(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam = bit_read_BS (dat);                                            \\\n    LOG_TRACE (#nam \": 0x%x [BSx %d]\\n\", _obj->nam, dxf);                     \\\n  }\n#define FIELD_BSd(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam = bit_read_BS (dat);                                            \\\n    LOG_TRACE (#nam \": \" FORMAT_BSd \" [BSd %d]\\n\", _obj->nam, dxf);           \\\n  }\n#define SUB_FIELD_BSd(o, nam, dxf)                                            \\\n  {                                                                           \\\n    _obj->o.nam = (BITCODE_BSd)bit_read_BS (dat);                             \\\n    LOG_TRACE (#o \".\" #nam \": \" FORMAT_BSd \" [BSd %d]\\n\", _obj->o.nam, dxf);  \\\n  }\n#define FIELD_BLd(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam = bit_read_BL (dat);                                            \\\n    LOG_TRACE (#nam \": \" FORMAT_BLd \" [BLd %d]\\n\", _obj->nam, dxf);           \\\n  }\n#define FIELD_RLd(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam = bit_read_RL (dat);                                            \\\n    LOG_TRACE (#nam \": \" FORMAT_RLd \" [RLd %d]\\n\", _obj->nam, dxf);           \\\n  }\n#define FIELD_RC(nam, dxf) FIELDG (nam, RC, dxf)\n#define FIELD_RCu(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam = bit_read_RC (dat);                                            \\\n    LOG_TRACE (#nam \": %u [RC %d]\\n\", (unsigned)((unsigned char)_obj->nam),   \\\n               dxf);                                                          \\\n  }\n#define FIELD_RCd(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam = bit_read_RC (dat);                                            \\\n    LOG_TRACE (#nam \": %d [RC %d]\\n\", (int)((signed char)_obj->nam), dxf);    \\\n  }\n#define FIELD_RS(nam, dxf) FIELDG (nam, RS, dxf)\n#define FIELD_RSx(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam = bit_read_RS (dat);                                            \\\n    LOG_TRACE (#nam \": \" FORMAT_RSx \" [RSx %d]\\n\", _obj->nam, dxf);           \\\n  }\n#define FIELD_RD(nam, dxf)                                                    \\\n  {                                                                           \\\n    FIELDG (nam, RD, dxf);                                                    \\\n    if (bit_isnan (_obj->nam))                                                \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid RD \" #nam);                                       \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n  }\n#define FIELD_RL(nam, dxf) FIELDG (nam, RL, dxf)\n#define FIELD_RLL(nam, dxf) FIELDG (nam, RLL, dxf)\n#define FIELD_MC(nam, dxf) FIELDG (nam, MC, dxf)\n#define FIELD_MS(nam, dxf) FIELDG (nam, MS, dxf)\n/* preR13 we have no obj->address and obj->size yet, skip VECTOR_CHKCOUNT */\n// clang-format off\n#define FIELD_TF(nam, len, dxf)                                               \\\n  {                                                                           \\\n    SINCE (R_13) { _obj->nam = NULL; VECTOR_CHKCOUNT (nam, TF, len, dat) }    \\\n    _obj->nam = bit_read_TF (dat, (int)len);                                  \\\n    LOG_TRACE (#nam \": \\\"%s\\\" [TF %lu \" #dxf \"]\\n\", _obj->nam, (unsigned long)len); \\\n    LOG_INSANE_TF (FIELD_VALUE (nam), (int)len);                              \\\n  }\n#define FIELD_TFF(nam, len, dxf)                                              \\\n  {                                                                           \\\n    SINCE (R_13) { VECTOR_CHKCOUNT (nam, TF, len, dat) }                      \\\n    bit_read_fixed (dat, _obj->nam, (int)len);                                \\\n    LOG_TRACE (#nam \": \\\"%s\\\" [TFF %d \" #dxf \"]\\n\", _obj->nam, (int)len);     \\\n    LOG_INSANE_TF (FIELD_VALUE (nam), (int)len);                              \\\n  }\n// clang-format on\n#define FIELD_TV(nam, dxf) FIELDG (nam, TV, dxf)\n#define FIELD_TU(nam, dxf)                                                    \\\n  {                                                                           \\\n    _obj->nam = (BITCODE_TU)bit_read_TU (str_dat);                            \\\n    LOG_TRACE_TU (#nam, (BITCODE_TU)FIELD_VALUE (nam), dxf);                  \\\n  }\n#define FIELD_T(nam, dxf)                                                     \\\n  {                                                                           \\\n    if (dat->version < R_2007)                                                \\\n      {                                                                       \\\n        FIELD_TV (nam, dxf)                                                   \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        if (!obj || obj->has_strings) /* header_vars */                       \\\n          {                                                                   \\\n            _obj->nam = (BITCODE_T)bit_read_TU (str_dat);                     \\\n            LOG_TRACE_TU (#nam, (BITCODE_TU)FIELD_VALUE (nam), dxf);          \\\n          }                                                                   \\\n        else                                                                  \\\n          {                                                                   \\\n            LOG_TRACE_TU (#nam, L\"\", dxf);                                    \\\n          }                                                                   \\\n      }                                                                       \\\n  }\n#define FIELD_BT(nam, dxf) FIELDG (nam, BT, dxf)\n#define FIELD_4BITS(nam, dxf)                                                 \\\n  {                                                                           \\\n    int _b = _obj->nam = bit_read_4BITS (dat);                                \\\n    LOG_TRACE (#nam \": b%d%d%d%d [4BITS %d]\\n\", _b & 8, _b & 4, _b & 2,       \\\n               _b & 1, dxf);                                                  \\\n  }\n\n#define FIELD_BE(nam, dxf)                                                    \\\n  {                                                                           \\\n    bit_read_BE (dat, &_obj->nam.x, &_obj->nam.y, &_obj->nam.z);              \\\n    if (_obj->nam.z != 1.0)                                                   \\\n        LOG_TRACE (#nam \": (%f, %f, %f) [BE %d]\\n\", _obj->nam.x, _obj->nam.y, \\\n                   _obj->nam.z, dxf);                                         \\\n  }\n#define FIELD_DD(nam, _default, dxf)                                          \\\n  {                                                                           \\\n    FIELD_VALUE (nam) = bit_read_DD (dat, _default);                          \\\n    if (bit_isnan (_obj->nam))                                                \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid DD \" #nam);                                       \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n  }\n#define FIELD_2DD(nam, d1, d2, dxf)                                           \\\n  {                                                                           \\\n    FIELD_DD (nam.x, d1, dxf);                                                \\\n    FIELD_DD (nam.y, d2, dxf + 10);                                           \\\n    FIELD_2PT_TRACE (nam, 2DD, dxf);                                           \\\n  }\n#define FIELD_3DD(nam, def, dxf)                                              \\\n  {                                                                           \\\n    FIELD_DD (nam.x, FIELD_VALUE (def.x), dxf);                               \\\n    FIELD_DD (nam.y, FIELD_VALUE (def.y), dxf + 10);                          \\\n    FIELD_DD (nam.z, FIELD_VALUE (def.z), dxf + 20);                          \\\n    FIELD_3PT_TRACE (nam, 3DD, dxf);                                           \\\n  }\n#define FIELD_3RD(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam.x = bit_read_RD (dat);                                          \\\n    _obj->nam.y = bit_read_RD (dat);                                          \\\n    _obj->nam.z = bit_read_RD (dat);                                          \\\n    if (bit_isnan (_obj->nam.x) || bit_isnan (_obj->nam.y)                    \\\n        || bit_isnan (_obj->nam.z))                                           \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid 3RD \" #nam);                                      \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n    FIELD_3PT_TRACE (nam, 3RD, dxf);                                           \\\n  }\n#define FIELD_3BD(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam.x = bit_read_BD (dat);                                          \\\n    _obj->nam.y = bit_read_BD (dat);                                          \\\n    _obj->nam.z = bit_read_BD (dat);                                          \\\n    if (bit_isnan (_obj->nam.x) || bit_isnan (_obj->nam.y)                    \\\n        || bit_isnan (_obj->nam.z))                                           \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid 3BD \" #nam);                                      \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n    FIELD_3PT_TRACE (nam, 3BD, dxf);                                           \\\n  }\n#define FIELD_2RD(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam.x = bit_read_RD (dat);                                          \\\n    _obj->nam.y = bit_read_RD (dat);                                          \\\n    if (bit_isnan (_obj->nam.x) || bit_isnan (_obj->nam.y))                   \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid 2RD \" #nam);                                      \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n    FIELD_2PT_TRACE (nam, 2RD, dxf);                                           \\\n  }\n#define FIELD_2BD(nam, dxf)                                                   \\\n  {                                                                           \\\n    _obj->nam.x = bit_read_BD (dat);                                          \\\n    _obj->nam.y = bit_read_BD (dat);                                          \\\n    if (bit_isnan (_obj->nam.x) || bit_isnan (_obj->nam.y))                   \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid 2BD \" #nam);                                      \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n    FIELD_2PT_TRACE (nam, 2BD, dxf);                                           \\\n  }\n#define FIELD_2BD_1(nam, dxf)                                                 \\\n  {                                                                           \\\n    _obj->nam.x = bit_read_BD (dat);                                          \\\n    _obj->nam.y = bit_read_BD (dat);                                          \\\n    if (bit_isnan (_obj->nam.x) || bit_isnan (_obj->nam.y))                   \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid 2BD_1 \" #nam);                                    \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n    FIELD_2PT_TRACE (nam, 2BD_1, dxf);                                           \\\n  }\n// FIELDG(nam.x, BD, dxf); FIELDG(nam.y, BD, dxf+1);\n#define FIELD_3BD_1(nam, dxf)                                                 \\\n  {                                                                           \\\n    _obj->nam.x = bit_read_BD (dat);                                          \\\n    _obj->nam.y = bit_read_BD (dat);                                          \\\n    _obj->nam.z = bit_read_BD (dat);                                          \\\n    if (bit_isnan (_obj->nam.x) || bit_isnan (_obj->nam.y)                    \\\n        || bit_isnan (_obj->nam.z))                                           \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid 3BD_1 \" #nam);                                    \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n    FIELD_3PT_TRACE (nam, 3BD_1, dxf);                                           \\\n  }\n//    FIELDG(nam.x, BD, dxf); FIELDG(nam.y, BD, dxf+1);\n//    FIELDG(nam.z, BD, dxf+2); }\n#define FIELD_3DPOINT(nam, dxf) FIELD_3BD (nam, dxf)\n#define FIELD_3DVECTOR(nam, dxf) FIELD_3BD_1 (nam, dxf)\n#define FIELD_TIMEBLL(nam, dxf)                                               \\\n  {                                                                           \\\n    _obj->nam = bit_read_TIMEBLL (dat);                                       \\\n    LOG_TRACE (#nam \": %.8f  (\" FORMAT_BL \", \" FORMAT_BL \") [TIMEBLL %d]\\n\",  \\\n               _obj->nam.value, _obj->nam.days, _obj->nam.ms, dxf);           \\\n  }\n#define FIELD_TIMERLL(nam, dxf)                                               \\\n  {                                                                           \\\n    _obj->nam = bit_read_TIMERLL (dat);                                       \\\n    LOG_TRACE (#nam \": %.8f  (\" FORMAT_RL \", \" FORMAT_RL \") [TIMERLL %d]\\n\",  \\\n               _obj->nam.value, _obj->nam.days, _obj->nam.ms, dxf);           \\\n  }\n#define FIELD_CMC(color, dxf1, dxf2)                                          \\\n  {                                                                           \\\n    bit_read_CMC (dat, &_obj->color);                                         \\\n    LOG_TRACE (#color \".index: %d [CMC.BS %d]\\n\", _obj->color.index, dxf1);   \\\n    if (dat->version >= R_2004)                                               \\\n      {                                                                       \\\n        LOG_TRACE (#color \".rgb: 0x%06x [CMC.BL %d]\\n\",                       \\\n                   (unsigned)_obj->color.rgb, dxf2);                          \\\n        LOG_TRACE (#color \".flag: 0x%x [CMC.RC]\\n\",                           \\\n                   (unsigned)_obj->color.flag);                               \\\n        if (_obj->color.flag & 1)                                             \\\n          LOG_TRACE (#color \".name: %s [CMC.TV]\\n\", _obj->color.name);        \\\n        if (_obj->color.flag & 2)                                             \\\n          LOG_TRACE (#color \".bookname: %s [CMC.TV]\\n\",                       \\\n                     _obj->color.book_name);                                  \\\n      }                                                                       \\\n  }\n#define SUB_FIELD_CMC(o, color, dxf1, dxf2)                                   \\\n  {                                                                           \\\n    bit_read_CMC (dat, &_obj->o.color);                                       \\\n    LOG_TRACE (#o \".\" #color \".index: %d [CMC.BS %d]\\n\", _obj->o.color.index, dxf1); \\\n    if (dat->version >= R_2004)                                               \\\n      {                                                                       \\\n        LOG_TRACE (#o \".\" #color \".rgb: 0x%06x [CMC.BL %d]\\n\",                       \\\n                   (unsigned)_obj->o.color.rgb, dxf2);                        \\\n        LOG_TRACE (#o \".\" #color \".flag: 0x%x [CMC.RC]\\n\",                           \\\n                   (unsigned)_obj->o.color.flag);                             \\\n        if (_obj->o.color.flag & 1)                                           \\\n          LOG_TRACE (#o \".\" #color \".name: %s [CMC.TV]\\n\", _obj->o.color.name);      \\\n        if (_obj->o.color.flag & 2)                                           \\\n          LOG_TRACE (#o \".\" #color \".bookname: %s [CMC.TV]\\n\",                       \\\n                     _obj->o.color.book_name);                                \\\n      }                                                                       \\\n  }\n#define FIELD_ENC(color, dxf1, dxf2)                                          \\\n  {                                                                           \\\n    bit_read_ENC (dat, hdl_dat, str_dat, &_obj->color);                       \\\n    LOG_TRACE (#color \".index: %d [ENC.BS %d]\\n\", _obj->color.index, dxf1);   \\\n    if (dat->version >= R_2004)                                               \\\n      {                                                                       \\\n        if (_obj->color.flag)                                                 \\\n          LOG_TRACE (#color \".flag: 0x%x\\n\", (unsigned)_obj->color.flag);     \\\n        if (_obj->color.flag & 0x20)                                          \\\n          LOG_TRACE (#color \".alpha: %d [ENC.BL %d]\\n\",                       \\\n                     (int)_obj->color.alpha, dxf2 + 20);                      \\\n        if (_obj->color.flag & 0x80)                                          \\\n          LOG_TRACE (#color \".rgb: 0x%06x [ENC.BL %d]\\n\",                     \\\n                     (unsigned)_obj->color.rgb, dxf2);                        \\\n        if (_obj->color.flag & 0x40 && _obj->color.handle)                    \\\n          LOG_TRACE (#color \".handle: %X [ENC.H %d]\\n\",                       \\\n                     _obj->color.handle->handleref.value, dxf2 + 10);         \\\n      }                                                                       \\\n  }\n#define SUB_FIELD_ENC(o, color, dxf1, dxf2)                                   \\\n  {                                                                           \\\n    bit_read_ENC (dat, hdl_dat, str_dat, &_obj->o.color);                     \\\n    LOG_TRACE (#o \".\" #color \".index: %d [ENC.BS %d]\\n\", _obj->o.color.index, dxf1); \\\n    if (dat->version >= R_2004)                                               \\\n      {                                                                       \\\n        if (_obj->o.color.flag)                                               \\\n          LOG_TRACE (#o \".\" #color \".flag: 0x%x\\n\", (unsigned)_obj->o.color.flag);   \\\n        if (_obj->o.color.flag & 0x20)                                        \\\n          LOG_TRACE (#o \".\" #color \".alpha: %d [ENC.BL %d]\\n\",                       \\\n                     (unsigned)_obj->o.color.alpha, dxf2 + 20);               \\\n        if (_obj->o.color.flag & 0x80)                                        \\\n          LOG_TRACE (#o \".\" #color \".rgb: 0x%06x [ENC.BL %d]\\n\",                     \\\n                     (unsigned)_obj->o.color.rgb, dxf2);                      \\\n        if (_obj->o.color.flag & 0x40 && _obj->o.color.handle)                \\\n          LOG_TRACE (#o \".\" #color \".handle: %lX [ENC.H %d]\\n\",                      \\\n                     _obj->o.color.handle->handleref.value, dxf2 + 10);       \\\n      }                                                                       \\\n  }\n\n#undef DEBUG_POS\n#undef DEBUG_HERE\n#undef DEBUG_POS_OBJ\n#undef DEBUG_HERE_OBJ\n#define DEBUG_POS_OBJ                                                         \\\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \\\n    {                                                                         \\\n      LOG_TRACE (\"DEBUG_POS @%u.%u (%lu) %lu\\n\", (unsigned int)dat->byte,     \\\n                 dat->bit, bit_position (dat),                                \\\n                 obj ? bit_position (dat) - obj->address * 8 : 0);            \\\n    }\n#define DEBUG_POS                                                             \\\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \\\n    {                                                                         \\\n      LOG_TRACE (\"DEBUG_POS @%u.%u (%lu)\\n\", (unsigned int)dat->byte,         \\\n                 dat->bit, bit_position (dat));                               \\\n    }\n#define _DEBUG_HERE                                                           \\\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \\\n    {                                                                         \\\n      Bit_Chain here = *dat;                                                  \\\n      int oldloglevel = loglevel;                                             \\\n      char *tmp;                                                              \\\n      BITCODE_BB bb = 0;                                                      \\\n      BITCODE_RS rs;                                                          \\\n      BITCODE_RL rl;                                                          \\\n      double bd;                                                              \\\n      Dwg_Handle hdl;                                                         \\\n      tmp = bit_read_TF (dat, 24);                                            \\\n      if (DWG_LOGLEVEL >= DWG_LOGLEVEL_INSANE)                                \\\n        {                                                                     \\\n          bit_fprint_bits (stderr, (unsigned char *)tmp, 68);                 \\\n          fprintf (stderr, \"\\n\");                                             \\\n        }                                                                     \\\n      LOG_TRACE_TF (tmp, 24);                                                 \\\n      free (tmp);                                                             \\\n      SINCE (R_13)                                                            \\\n      {                                                                       \\\n        *dat = here;                                                          \\\n        LOG_TRACE (\"  B  :\" FORMAT_B \"\\t\", bit_read_B (dat));                 \\\n        *dat = here;                                                          \\\n        bb = bit_read_BB (dat) & 0x3;                                         \\\n        LOG_TRACE (\"  BB :\" FORMAT_BB \"\\n\", bb);                              \\\n      }                                                                       \\\n      *dat = here;                                                            \\\n      rs = bit_read_RS (dat);                                                 \\\n      LOG_TRACE (\"  RS :\" FORMAT_RS \" / 0x%04x (16)\\n\", rs, rs);              \\\n      SINCE (R_13)                                                            \\\n      {                                                                       \\\n        *dat = here;                                                          \\\n        rs = bit_read_BS (dat);                                               \\\n        LOG_TRACE (\"  BS :\" FORMAT_BS \" / 0x%04x (%ld)\\t\", rs, rs,            \\\n                   bit_position (dat) - bit_position (&here));                \\\n      }                                                                       \\\n      SINCE (R_2007)                                                          \\\n      {                                                                       \\\n        *dat = here;                                                          \\\n        rs = bit_read_MS (dat);                                               \\\n        LOG_TRACE (\"  MS :\" FORMAT_RS \" / 0x%04x (%ld)\\n\", rs, rs,            \\\n                   bit_position (dat) - bit_position (&here));                \\\n      }                                                                       \\\n      else LOG_TRACE (\"\\n\");                                                  \\\n      *dat = here;                                                            \\\n      rl = bit_read_RL (dat);                                                 \\\n      LOG_TRACE (\"  RL :\" FORMAT_RL \" / 0x%08x (32)\\n\", rl, rl);              \\\n      *dat = here;                                                            \\\n      LOG_TRACE (\"  RD :\" FORMAT_RD \" (64)\\n\", bit_read_RD (dat));            \\\n      *dat = here;                                                            \\\n      SINCE (R_13)                                                            \\\n      {                                                                       \\\n        if (bb != 3)                                                          \\\n          {                                                                   \\\n            rl = bit_read_BL (dat);                                           \\\n            LOG_TRACE (\"  BL :\" FORMAT_BL \" / 0x%08x (%ld)\\n\", rl, rl,        \\\n                       bit_position (dat) - bit_position (&here));            \\\n            *dat = here;                                                      \\\n            bd = bit_read_BD (dat);                                           \\\n            LOG_TRACE (\"  BD :\" FORMAT_BD \" (%ld)\\n\", bd,                     \\\n                       bit_position (dat) - bit_position (&here));            \\\n            *dat = here;                                                      \\\n          }                                                                   \\\n      }                                                                       \\\n      if ((dat->chain[dat->byte] & 0xf) <= 4)                                 \\\n        {                                                                     \\\n          loglevel = 0;                                                       \\\n          if (!bit_read_H (dat, &hdl))                                        \\\n            {                                                                 \\\n              LOG_TRACE (\"  H : \" FORMAT_H \" (%ld)\\n\", ARGS_H (hdl),          \\\n                         bit_position (dat) - bit_position (&here));          \\\n            }                                                                 \\\n          loglevel = oldloglevel;                                             \\\n        }                                                                     \\\n      *dat = here;                                                            \\\n    }\n#define DEBUG_HERE_OBJ                                                        \\\n  DEBUG_POS_OBJ                                                               \\\n  _DEBUG_HERE\n#define DEBUG_HERE                                                            \\\n  DEBUG_POS                                                                   \\\n  _DEBUG_HERE\n\n// check for overflow into next object (invalid num_elems)\n#define AVAIL_BITS(dat)                                                       \\\n  (obj ? (long long)((obj->size * 8) - bit_position (dat) + 20) : 0xff00LL)\n#define TYPE_MAXELEMSIZE(type) dwg_bits_size[BITS_##type]\n#define VECTOR_CHKCOUNT(nam, type, size, dat)                                 \\\n  if ((long long)(size) > AVAIL_BITS (dat) ||                                 \\\n      (long long)((size)*TYPE_MAXELEMSIZE (type)) > AVAIL_BITS (dat))         \\\n    {                                                                         \\\n      LOG_ERROR (\"Invalid \" #nam \" size %ld. Need min. %u bits for \" #type    \\\n                 \", have %lld for %s.\",                                       \\\n                 (long)(size), (unsigned)(size)*TYPE_MAXELEMSIZE (type),      \\\n                 AVAIL_BITS (dat), SAFEDXFNAME);                              \\\n      if (_obj->nam) free (_obj->nam);                                        \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }\n#define VECTOR_CHKCOUNT_LV(nam, type, size, dat)                              \\\n  if ((long long)(size) > AVAIL_BITS (dat) ||                                 \\\n      (long long)((size)*TYPE_MAXELEMSIZE (type)) > AVAIL_BITS (dat))         \\\n    {                                                                         \\\n      LOG_ERROR (\"Invalid \" #nam \" size %ld. Need min. %u bits for \" #type    \\\n                 \", have %lld for %s.\",                                       \\\n                 (long)(size), (unsigned)(size)*TYPE_MAXELEMSIZE (type),      \\\n                 AVAIL_BITS (dat), SAFEDXFNAME);                              \\\n      if (_obj->nam) free (_obj->nam);                                        \\\n      size = 0;                                                               \\\n      /* return DWG_ERR_VALUEOUTOFBOUNDS; */                                  \\\n    }\n#define _VECTOR_CHKCOUNT(nam, size, maxelemsize, dat)                         \\\n  if ((long long)(size) > AVAIL_BITS (dat) ||                                 \\\n      (long long)((size) * (maxelemsize)) > AVAIL_BITS (dat))                 \\\n    {                                                                         \\\n      LOG_ERROR (\"Invalid \" #nam                                              \\\n                 \" size %ld. Need min. %u bits, have %lld for %s.\",           \\\n                 (long)(size), (unsigned)(size) * (maxelemsize),              \\\n                 AVAIL_BITS (dat), SAFEDXFNAME);                              \\\n      size = 0;                                                               \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }\n#define HANDLE_VECTOR_CHKCOUNT(nam, size)                                     \\\n  _VECTOR_CHKCOUNT (nam, size, TYPE_MAXELEMSIZE(HANDLE), hdl_dat)\n\n// FIELD_VECTOR_N(name, type, size):\n// reads data of the type indicated by 'type' 'size' times and stores\n// it all in the vector called 'name'.\n#define FIELD_VECTOR_N(name, type, size, dxf)                                 \\\n  if (size > 0)                                                               \\\n    {                                                                         \\\n      VECTOR_CHKCOUNT (name, type, size, dat)                                 \\\n      _obj->name = (BITCODE_##type *)calloc (size, sizeof (BITCODE_##type));  \\\n      for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \\\n        {                                                                     \\\n          _obj->name[vcount] = bit_read_##type (dat);                         \\\n          LOG_INSANE (#name \"[%ld]: \" FORMAT_##type \"\\n\", (long)vcount,       \\\n                      _obj->name[vcount])                                     \\\n        }                                                                     \\\n    }\n#define FIELD_VECTOR_T(name, size, dxf)                                       \\\n  if (_obj->size > 0)                                                         \\\n    {                                                                         \\\n      _VECTOR_CHKCOUNT (name, _obj->size, dat->version >= R_2007 ? 18 : 2,    \\\n                        dat)                                                  \\\n      _obj->name = calloc (_obj->size, sizeof (char *));                      \\\n      for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)             \\\n        {                                                                     \\\n          PRE (R_2007)                                                        \\\n          {                                                                   \\\n            _obj->name[vcount] = bit_read_TV (dat);                           \\\n            LOG_TRACE (#name \"[%ld]: %s\\n\", (long)vcount, _obj->name[vcount]) \\\n          }                                                                   \\\n          LATER_VERSIONS                                                      \\\n          {                                                                   \\\n            _obj->name[vcount] = (char *)bit_read_TU (dat);                   \\\n            LOG_TRACE_TU_I (#name, vcount, _obj->name[vcount], dxf)           \\\n          }                                                                   \\\n        }                                                                     \\\n    }\n#define FIELD_VECTOR_N1(name, type, size, dxf)                                \\\n  if (size > 0)                                                               \\\n    {                                                                         \\\n      int _dxf = dxf;                                                         \\\n      VECTOR_CHKCOUNT (name, type, size, dat)                                 \\\n      _obj->name = (BITCODE_##type *)calloc (size, sizeof (BITCODE_##type));  \\\n      for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \\\n        {                                                                     \\\n          _obj->name[vcount] = bit_read_##type (dat);                         \\\n          LOG_INSANE (#name \"[%ld]: \" FORMAT_##type \" [\" #type \" %d]\\n\",      \\\n                      (long)vcount, _obj->name[vcount], _dxf++)               \\\n        }                                                                     \\\n    }\n\n#define FIELD_VECTOR(name, type, size, dxf)                                   \\\n  FIELD_VECTOR_N (name, type, _obj->size, dxf)\n\n#define FIELD_2RD_VECTOR(name, size, dxf)                                     \\\n  VECTOR_CHKCOUNT_LV (name, 2RD, _obj->size, dat)                             \\\n  if (_obj->size > 0)                                                         \\\n    {                                                                         \\\n      _obj->name = (BITCODE_2RD *)calloc (_obj->size, sizeof (BITCODE_2RD));  \\\n      for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)             \\\n        {                                                                     \\\n          FIELD_2RD (name[vcount], dxf);                                      \\\n        }                                                                     \\\n    }                                                                         \\\n  else                                                                        \\\n    return DWG_ERR_VALUEOUTOFBOUNDS;\n\n#define FIELD_2DD_VECTOR(name, size, dxf)                                     \\\n  VECTOR_CHKCOUNT_LV (name, 2DD, _obj->size, dat)                             \\\n  if (_obj->size > 0)                                                         \\\n    {                                                                         \\\n      _obj->name = (BITCODE_2RD *)calloc (_obj->size, sizeof (BITCODE_2RD));  \\\n      FIELD_2RD (name[0], dxf);                                               \\\n      for (vcount = 1; vcount < (BITCODE_BL)_obj->size; vcount++)             \\\n        {                                                                     \\\n          FIELD_DD (name[vcount].x, FIELD_VALUE (name[vcount - 1].x), dxf);   \\\n          FIELD_DD (name[vcount].y, FIELD_VALUE (name[vcount - 1].y),         \\\n                    dxf + 10);                                                \\\n          LOG_TRACE (#name \"[%ld]: (\" FORMAT_BD \", \" FORMAT_BD \") [DD %d]\\n\", \\\n                     (long)vcount, _obj->name[vcount].x,                      \\\n                     _obj->name[vcount].y, dxf)                               \\\n        }                                                                     \\\n    }                                                                         \\\n  else                                                                        \\\n    return DWG_ERR_VALUEOUTOFBOUNDS;\n\n#define FIELD_3DPOINT_VECTOR(name, size, dxf)                                 \\\n  VECTOR_CHKCOUNT_LV (name, 3BD, _obj->size, dat)                             \\\n  if (_obj->size > 0)                                                         \\\n    {                                                                         \\\n      _obj->name                                                              \\\n          = (BITCODE_3DPOINT *)calloc (_obj->size, sizeof (BITCODE_3DPOINT)); \\\n      for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)             \\\n        {                                                                     \\\n          FIELD_3DPOINT (name[vcount], dxf);                                  \\\n        }                                                                     \\\n    }                                                                         \\\n  else                                                                        \\\n    return DWG_ERR_VALUEOUTOFBOUNDS;\n\n// shortest handle: 8 bit\n#define HANDLE_VECTOR_N(nam, size, code, dxf)                                 \\\n  if (size > 0)                                                               \\\n    {                                                                         \\\n      FIELD_VALUE (nam) = (BITCODE_H *)calloc (size, sizeof (BITCODE_H));     \\\n      for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \\\n        {                                                                     \\\n          FIELD_HANDLE_N (nam[vcount], vcount, code, dxf);                    \\\n        }                                                                     \\\n    }\n\n#define HANDLE_VECTOR(nam, sizefield, code, dxf)                              \\\n  VECTOR_CHKCOUNT_LV (nam, HANDLE, FIELD_VALUE (sizefield), hdl_dat)          \\\n  HANDLE_VECTOR_N (nam, FIELD_VALUE (sizefield), code, dxf)\n\n// count 1 bytes, until non-1 bytes or a terminating zero\n#define FIELD_NUM_INSERTS(num_inserts, type, dxf)                             \\\n  FIELD_VALUE (num_inserts) = 0;                                              \\\n  vcount = 0;                                                                 \\\n  while ((vcount = (BITCODE_RC)bit_read_RC (dat)))                            \\\n    {                                                                         \\\n      FIELD_VALUE (num_inserts)++;                                            \\\n      LOG_INSANE (\"num_inserts [RC \" FORMAT_RL \"]: %d\\n\",                     \\\n                  FIELD_VALUE (num_inserts), (unsigned char)vcount)           \\\n      if (vcount != 1)                                                        \\\n        {                                                                     \\\n          LOG_WARN (\"num_inserts [RC \" FORMAT_RL \"]: %d != 1\",                \\\n                    FIELD_VALUE (num_inserts), (unsigned char)vcount)         \\\n          bit_advance_position (dat, -8);                                     \\\n          break;                                                              \\\n        }                                                                     \\\n    }                                                                         \\\n  LOG_TRACE (\"num_inserts: %d [RC* 0]\\n\", FIELD_VALUE (num_inserts))\n\n#define FIELD_XDATA(name, size)                                               \\\n  _obj->name = dwg_decode_xdata (dat, _obj, _obj->size)\n\n#define REACTORS(code)                                                        \\\n  if (obj->tio.object->num_reactors > 0)                                      \\\n    {                                                                         \\\n      HANDLE_VECTOR_CHKCOUNT (reactors, obj->tio.object->num_reactors)        \\\n      obj->tio.object->reactors                                               \\\n          = calloc (obj->tio.object->num_reactors, sizeof (BITCODE_H));       \\\n      for (vcount = 0; vcount < obj->tio.object->num_reactors; vcount++)      \\\n        {                                                                     \\\n          VALUE_HANDLE_N (obj->tio.object->reactors[vcount], reactors,        \\\n                          vcount, code, 330);                                 \\\n        }                                                                     \\\n    }\n\n#define ENT_REACTORS(code)                                                    \\\n  if (_ent->num_reactors > 0)                                                 \\\n    {                                                                         \\\n      HANDLE_VECTOR_CHKCOUNT (reactors, _ent->num_reactors)                   \\\n      _ent->reactors = calloc (_ent->num_reactors, sizeof (BITCODE_H));       \\\n      for (vcount = 0; vcount < _ent->num_reactors; vcount++)                 \\\n        {                                                                     \\\n          VALUE_HANDLE_N (_ent->reactors[vcount], reactors, vcount, code,     \\\n                          330);                                               \\\n        }                                                                     \\\n    }\n\n#define XDICOBJHANDLE(code)                                                   \\\n  SINCE (R_2004)                                                              \\\n  {                                                                           \\\n    if (!obj->tio.object->xdic_missing_flag)                                  \\\n      {                                                                       \\\n        VALUE_HANDLE (obj->tio.object->xdicobjhandle, xdicobjhandle, code,    \\\n                      360);                                                   \\\n        if (!obj->tio.object->xdicobjhandle)                                  \\\n          obj->tio.object->xdic_missing_flag = 1;                             \\\n      }                                                                       \\\n  }                                                                           \\\n  else                                                                        \\\n  {                                                                           \\\n    SINCE (R_13)                                                              \\\n    {                                                                         \\\n      VALUE_HANDLE (obj->tio.object->xdicobjhandle, xdicobjhandle, code,      \\\n                    360);                                                     \\\n    }                                                                         \\\n  }\n\n#define ENT_XDICOBJHANDLE(code)                                               \\\n  SINCE (R_2004)                                                              \\\n  {                                                                           \\\n    if (!_ent->xdic_missing_flag)                                             \\\n      {                                                                       \\\n        VALUE_HANDLE (_ent->xdicobjhandle, xdicobjhandle, code, 360);         \\\n      }                                                                       \\\n  }                                                                           \\\n  else                                                                        \\\n  {                                                                           \\\n    SINCE (R_13)                                                              \\\n    {                                                                         \\\n      VALUE_HANDLE (_ent->xdicobjhandle, xdicobjhandle, code, 360);           \\\n    }                                                                         \\\n  }\n\n#define SECTION_STRING_STREAM                                                 \\\n  {                                                                           \\\n    Bit_Chain sav_dat = *dat;                                                 \\\n    dat = str_dat;\n\n// TODO: unused\n#define START_STRING_STREAM                                                   \\\n  obj->has_strings = bit_read_B (dat);                                        \\\n  if (obj->has_strings)                                                       \\\n    {                                                                         \\\n      Bit_Chain sav_dat = *dat;                                               \\\n      obj_string_stream (dat, obj, dat);\n\n#define END_STRING_STREAM                                                     \\\n  *dat = sav_dat;                                                             \\\n  }\n/* just checking. skip the has_strings bit. hdl_dat is already set */\n#define START_HANDLE_STREAM                                                   \\\n  if (dat->version >= R_2007)                                                 \\\n    {                                                                         \\\n      vcount = 1 + bit_position (dat);                                        \\\n      if (obj->hdlpos != (unsigned long)vcount)                               \\\n        {                                                                     \\\n          LOG_HANDLE (\" handle stream: %+ld @%lu.%u %s (@%lu.%u \"             \\\n                      \" @%lu.%u)\\n\",                                          \\\n                      (long)obj->hdlpos - (long)vcount, dat->byte, dat->bit,  \\\n                      ((long)obj->hdlpos - (long)vcount) >= 8                 \\\n                          ? \"MISSING\"                                         \\\n                          : ((long)obj->hdlpos < (long)vcount) ? \"OVERSHOOT\"  \\\n                                                               : \"\",          \\\n                      obj->hdlpos / 8, (unsigned)obj->hdlpos % 8,             \\\n                      hdl_dat->byte, hdl_dat->bit);                           \\\n          bit_set_position (dat, obj->hdlpos);                                \\\n        }                                                                     \\\n    }\n\n#define REPEAT_CHKCOUNT(name, times, type)                                    \\\n  if (AVAIL_BITS (dat) < 0)                                                   \\\n    {                                                                         \\\n      LOG_ERROR (\"Invalid \" #name \" in %s. No bytes left.\\n\", SAFEDXFNAME);   \\\n      if (_obj->name) { free (_obj->name); _obj->name = NULL; }               \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }                                                                         \\\n  LOG_INSANE (\"REPEAT_CHKCOUNT %s.\" #name \" x %ld: %lld > %lld?\\n\",           \\\n              SAFEDXFNAME, (long)times, (long long)((times) * sizeof (type)), \\\n              AVAIL_BITS (dat));                                              \\\n  if ((long long)((times) * sizeof (type)) > AVAIL_BITS (dat))                \\\n    {                                                                         \\\n      LOG_ERROR (\"Invalid %s.\" #name \" x %ld\\n\", SAFEDXFNAME, (long)times);   \\\n      if (_obj->name) { free (_obj->name); _obj->name = NULL; }               \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }\n#define REPEAT_CHKCOUNT_LVAL(name, times, type)                               \\\n  if (AVAIL_BITS (dat) < 0)                                                   \\\n    {                                                                         \\\n      LOG_ERROR (\"Invalid %s.\" #name \". No bytes left.\\n\", SAFEDXFNAME);      \\\n      times = 0;                                                              \\\n      if (_obj->name) { free (_obj->name); _obj->name = NULL; }               \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }                                                                         \\\n  LOG_INSANE (\"REPEAT_CHKCOUNT_LVAL %s.\" #name \" x %ld: %lld > %lld?\\n\",      \\\n              SAFEDXFNAME, (long)times, (long long)((times) * sizeof (type)), \\\n              AVAIL_BITS (dat));                                              \\\n  if ((long long)((times) * sizeof (type)) > AVAIL_BITS (dat))                \\\n    {                                                                         \\\n      LOG_ERROR (\"Invalid %s.\" #name \" x %ld\\n\", SAFEDXFNAME, (long)times);   \\\n      times = 0;                                                              \\\n      if (_obj->name) { free (_obj->name); _obj->name = NULL; }               \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }\n\n/* REPEAT names:\n  _ adds idx\n  C does no checks\n  N does constant times (else _obj->times)\n  F does not calloc/free\n*/\n\n// unchecked with constant times\n#define REPEAT_CN(times, name, type)                                          \\\n  if (times > 0)                                                              \\\n    _obj->name = (type *)calloc (times, sizeof (type));                       \\\n  for (rcount1 = 0; rcount1 < (BITCODE_BL)times; rcount1++)\n// checked with constant times\n#define REPEAT_N(times, name, type)                                           \\\n  REPEAT_CHKCOUNT (name, times, type)                                         \\\n  if (times > 0)                                                              \\\n    _obj->name = (type *)calloc (times, sizeof (type));                       \\\n  for (rcount1 = 0; rcount1 < (BITCODE_BL)times; rcount1++)\n\n// checked with var. times\n#define _REPEAT(times, name, type, idx)                                       \\\n  REPEAT_CHKCOUNT_LVAL (name, _obj->times, type)                              \\\n  if (_obj->times > 0)                                                        \\\n    _obj->name = (type *)calloc (_obj->times, sizeof (type));                 \\\n  for (rcount##idx = 0; rcount##idx < (BITCODE_BL)_obj->times; rcount##idx++)\n// unchecked with var. times\n#define _REPEAT_C(times, name, type, idx)                                     \\\n  if (_obj->times > 0)                                                        \\\n    _obj->name = (type *)calloc (_obj->times, sizeof (type));                 \\\n  for (rcount##idx = 0; rcount##idx < (BITCODE_BL)_obj->times; rcount##idx++)\n// unchecked with constant times\n#define _REPEAT_CN(times, name, type, idx)                                    \\\n  if (times > 0)                                                              \\\n    _obj->name = (type *)calloc (times, sizeof (type));                       \\\n  if (_obj->name)                                                             \\\n    for (rcount##idx = 0; rcount##idx < (BITCODE_BL)times; rcount##idx++)\n// not allocating versions unchecked: _REPEAT_CNF\n// not allocating versions checked: _REPEAT_NF\n\n#define REPEAT(times, name, type) _REPEAT (times, name, type, 1)\n#define REPEAT2(times, name, type) _REPEAT (times, name, type, 2)\n#define REPEAT3(times, name, type) _REPEAT (times, name, type, 3)\n#define REPEAT4(times, name, type) _REPEAT (times, name, type, 4)\n\n#define REPEAT_C(times, name, type) _REPEAT_C (times, name, type, 1)\n#define REPEAT2_C(times, name, type) _REPEAT_C (times, name, type, 2)\n#define REPEAT3_C(times, name, type) _REPEAT_C (times, name, type, 3)\n#define REPEAT4_C(times, name, type) _REPEAT_C (times, name, type, 4)\n\n#define COMMON_ENTITY_HANDLE_DATA                                             \\\n  SINCE (R_13)                                                                \\\n  {                                                                           \\\n    START_HANDLE_STREAM;                                                      \\\n    PRE (R_2007)                                                              \\\n    {                                                                         \\\n      error |= dwg_decode_common_entity_handle_data (dat, hdl_dat, obj);      \\\n    }                                                                         \\\n  }\n\n/** Add the empty entity or object with its three structs to the DWG.\n    All fields are zero'd. TODO: some are initialized with default values, as\n    defined in dwg.spec.\n    Returns 0 or DWG_ERR_OUTOFMEM.\n*/\n\n#define DWG_ENTITY(token)                                                     \\\n  EXPORT int dwg_add_##token (Dwg_Object *obj)                                \\\n  {                                                                           \\\n    Dwg_Object_Entity *_ent;                                                  \\\n    Dwg_Entity_##token *_obj;                                                 \\\n    LOG_INFO (\"Add entity \" #token \" \")                                       \\\n    obj->parent->num_entities++;                                              \\\n    obj->supertype = DWG_SUPERTYPE_ENTITY;                                    \\\n    if (!(int)obj->fixedtype)                                                 \\\n      {                                                                       \\\n        obj->fixedtype = DWG_TYPE_##token;                                    \\\n      }                                                                       \\\n    if (!obj->dxfname)                                                        \\\n      {                                                                       \\\n        if (strlen (#token) > 3 && !memcmp (#token, \"_3D\", 3))                \\\n          obj->name = obj->dxfname = (char *)&#token[1];                      \\\n        else                                                                  \\\n          obj->name = obj->dxfname = (char *)#token;                          \\\n      }                                                                       \\\n    else if (!obj->name)                                                      \\\n      {                                                                       \\\n        if (strlen (#token) > 3 && !memcmp (#token, \"_3D\", 3))                \\\n          obj->name = (char *)&#token[1];                                     \\\n        else                                                                  \\\n          obj->name = (char *)#token;                                         \\\n      }                                                                       \\\n    _ent = obj->tio.entity = calloc (1, sizeof (Dwg_Object_Entity));          \\\n    if (!_ent)                                                                \\\n      return DWG_ERR_OUTOFMEM;                                                \\\n    _ent->tio.token = calloc (1, sizeof (Dwg_Entity_##token));                \\\n    if (!_ent->tio.token)                                                     \\\n      return DWG_ERR_OUTOFMEM;                                                \\\n    _ent->dwg = obj->parent;                                                  \\\n    _ent->objid = obj->index; /* obj ptr itself might move */                 \\\n    _ent->tio.token->parent = obj->tio.entity;                                \\\n    return 0;                                                                 \\\n  }                                                                           \\\n                                                                              \\\n  static int dwg_decode_##token##_private (                                   \\\n      Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,                 \\\n      Dwg_Object *restrict obj);                                              \\\n                                                                              \\\n  /**Call dwg_add_##token and write the fields from the bitstream dat to the  \\\n   * entity or object. */                                                     \\\n  static int dwg_decode_##token (Bit_Chain *restrict dat,                     \\\n                                 Dwg_Object *restrict obj)                    \\\n  {                                                                           \\\n    int error = dwg_add_##token (obj);                                        \\\n    if (error)                                                                \\\n      return error;                                                           \\\n    SINCE (R_2007)                                                            \\\n      {                                                                       \\\n        Bit_Chain obj_dat, str_dat, hdl_dat;                                  \\\n        obj_dat = *dat;                                                       \\\n        hdl_dat = *dat;                                                       \\\n        str_dat = *dat;                                                       \\\n        error = dwg_decode_##token##_private (&obj_dat, &hdl_dat,             \\\n                                              &str_dat, obj);                 \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        error = dwg_decode_##token##_private (dat, dat, dat, obj);            \\\n      }                                                                       \\\n    return error;                                                             \\\n  }                                                                           \\\n                                                                              \\\n  GCC30_DIAG_IGNORE (-Wformat-nonliteral)                                     \\\n  static int dwg_decode_##token##_private (                                   \\\n      Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,                 \\\n      Dwg_Object *restrict obj)                                               \\\n  {                                                                           \\\n    BITCODE_BL vcount, rcount3, rcount4;                                      \\\n    int error;                                                                \\\n    Dwg_Entity_##token *ent, *_obj;                                           \\\n    Dwg_Object_Entity *_ent;                                                  \\\n    Dwg_Data *dwg = obj->parent;                                              \\\n    LOG_INFO (\"Decode entity \" #token \"\\n\")                                   \\\n    _ent = obj->tio.entity;                                                   \\\n    ent = obj->tio.entity->tio.token;                                         \\\n    _obj = ent;                                                               \\\n    _ent->dwg = dwg;                                                          \\\n    _ent->objid = obj->index; /* obj ptr itself might move */                 \\\n    _obj->parent = obj->tio.entity;                                           \\\n    SINCE (R_13) { error = dwg_decode_entity (dat, hdl_dat, str_dat, _ent); } \\\n    else { error = decode_entity_preR13 (dat, obj, _ent); }                   \\\n    if (error >= DWG_ERR_CRITICAL)                                            \\\n      return error;\n\n// Does size include the CRC?\n#define DWG_ENTITY_END                                                        \\\n  {                                                                           \\\n    unsigned long pos = obj_stream_position (dat, hdl_dat, str_dat);          \\\n    int64_t padding = (obj->size * 8) - pos;                                  \\\n    SINCE (R_2007) bit_set_position (dat, pos);                               \\\n    if (padding)                                                              \\\n      LOG_HANDLE (\" padding: %+ld %s\\n\", (long)padding,                       \\\n                  padding >= 8 ? \"MISSING\"                                    \\\n                               : (padding < 0) ? \"OVERSHOOT\" : \"\");           \\\n  }                                                                           \\\n  return error & ~DWG_ERR_UNHANDLEDCLASS;                                     \\\n  }\n\n#define DWG_OBJECT(token)                                                     \\\n  EXPORT int dwg_add_##token (Dwg_Object *obj)                                \\\n  {                                                                           \\\n    Dwg_Object_##token *_obj;                                                 \\\n    LOG_INFO (\"Add object \" #token \" \")                                       \\\n    obj->supertype = DWG_SUPERTYPE_OBJECT;                                    \\\n    obj->tio.object = calloc (1, sizeof (Dwg_Object_Object));                 \\\n    if (!obj->tio.object)                                                     \\\n      return DWG_ERR_OUTOFMEM;                                                \\\n    _obj = obj->tio.object->tio.token                                         \\\n        = calloc (1, sizeof (Dwg_Object_##token));                            \\\n    if (!_obj)                                                                \\\n      {                                                                       \\\n        free (obj->tio.object);                                               \\\n        obj->tio.object = NULL;                                               \\\n        obj->fixedtype = DWG_TYPE_FREED;                                      \\\n        return DWG_ERR_OUTOFMEM;                                              \\\n      }                                                                       \\\n    if (!(int)obj->fixedtype)                                                 \\\n      {                                                                       \\\n        obj->fixedtype = DWG_TYPE_##token;                                    \\\n        obj->name = (char *)#token;                                           \\\n      }                                                                       \\\n    if (!obj->dxfname)                                                        \\\n      {                                                                       \\\n        if (!strcmp (#token, \"PLACEHOLDER\"))                                  \\\n          obj->dxfname = (char *)\"ACDBPLACEHOLDER\";                           \\\n        else                                                                  \\\n          obj->dxfname = (char *)#token;                                      \\\n      }                                                                       \\\n    _obj->parent = obj->tio.object;                                           \\\n    obj->tio.object->dwg = obj->parent;                                       \\\n    obj->tio.object->objid = obj->index; /* obj ptr itself might move */      \\\n    return 0;                                                                 \\\n  }                                                                           \\\n  static int dwg_decode_##token##_private (                                   \\\n      Bit_Chain *obj_dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,             \\\n      Dwg_Object *restrict obj);                                              \\\n                                                                              \\\n  static int dwg_decode_##token (Bit_Chain *restrict dat,                     \\\n                                 Dwg_Object *restrict obj)                    \\\n  {                                                                           \\\n    int error = dwg_add_##token (obj);                                        \\\n    if (error)                                                                \\\n      return error;                                                           \\\n    SINCE (R_2007)                                                            \\\n    {                                                                         \\\n      Bit_Chain obj_dat, str_dat, hdl_dat;                                    \\\n      obj_dat = *dat;                                                         \\\n      hdl_dat = *dat;                                                         \\\n      str_dat = *dat;                                                         \\\n      error = dwg_decode_##token##_private (&obj_dat, &hdl_dat, &str_dat,     \\\n                                            obj);                             \\\n    }                                                                         \\\n    else { error = dwg_decode_##token##_private (dat, dat, dat, obj); }       \\\n    return error;                                                             \\\n  }                                                                           \\\n                                                                              \\\n  GCC30_DIAG_IGNORE (-Wformat-nonliteral)                                     \\\n  static int dwg_decode_##token##_private (                                   \\\n      Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,                 \\\n      Dwg_Object *restrict obj)                                               \\\n  {                                                                           \\\n    BITCODE_BL vcount, rcount3, rcount4;                                      \\\n    int error;                                                                \\\n    Dwg_Object_##token *_obj;                                                 \\\n    Dwg_Data *dwg = obj->parent;                                              \\\n    LOG_INFO (\"Decode object \" #token \"\\n\")                                   \\\n    if (strNE (#token, \"TABLECONTENT\") || obj->fixedtype != DWG_TYPE_TABLE)   \\\n      {                                                                       \\\n        _obj = obj->tio.object->tio.token;                                    \\\n        error = dwg_decode_object (dat, hdl_dat, str_dat, obj->tio.object);   \\\n        if (error >= DWG_ERR_CRITICAL)                                        \\\n          return error;                                                       \\\n      }\n\n#define DWG_OBJECT_END DWG_ENTITY_END\n"], "filenames": ["src/classes.inc", "src/dec_macros.h"], "buggy_code_start_loc": [55, 1239], "buggy_code_end_loc": [224, 1241], "fixing_code_start_loc": [56, 1239], "fixing_code_end_loc": [232, 1241], "type": "CWE-125", "message": "An issue was discovered in GNU LibreDWG through 0.9.3. Crafted input will lead to a heap-based buffer over-read in dwg_encode_entity in common_entity_data.spec.", "other": {"cve": {"id": "CVE-2019-20913", "sourceIdentifier": "cve@mitre.org", "published": "2020-07-16T18:15:13.503", "lastModified": "2020-07-22T18:18:57.273", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in GNU LibreDWG through 0.9.3. Crafted input will lead to a heap-based buffer over-read in dwg_encode_entity in common_entity_data.spec."}, {"lang": "es", "value": "Se detect\u00f3 un problema en GNU LibreDWG versiones hasta 0.9.3. Una entrada dise\u00f1ada conllevar\u00e1 a una sobre lectura del b\u00fafer en la regi\u00f3n heap de la memoria en la funci\u00f3n dwg_encode_entity en el archivo common_entity_data.spec"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gnu:libredwg:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.9.3", "matchCriteriaId": "28E3A7DE-65A0-4A6B-BF63-00F627CF17CB"}]}]}], "references": [{"url": "https://github.com/LibreDWG/libredwg/commit/3f503dd294efc63a59608d8a16058c41d44ba13a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibreDWG/libredwg/issues/178", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibreDWG/libredwg/commit/3f503dd294efc63a59608d8a16058c41d44ba13a"}}