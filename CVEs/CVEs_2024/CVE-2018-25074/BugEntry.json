{"buggy_code": ["var INVALID_ESCAPES = /[^\\\\]\\\\[^.*+?^${}()|[\\]\\\\bBcdDfnrsStvwWxu0-9]/;\nvar validators = require('./'),\n\tformats = {\n\t\t'date-time': /^\\d{4}-(0[0-9]{1}|1[0-2]{1})-[0-9]{2}[t ]\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?([zZ]|[+-]\\d{2}:\\d{2})$/i,\n\t\t'date': /^\\d{4}-(0[0-9]{1}|1[0-2]{1})-[0-9]{2}$/,\n\t\t'time': /^\\d{2}:\\d{2}:\\d{2}$/,\n\t\t'color': /^(#[0-9a-f]{3}|#[0-9a-f]{6}|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)$/i,\n\t\t'style': /^(?:\\s*-?[_A-Z]+[_A-Z0-9-]*:[^\\n\\r\\f;]+;)*\\s*-?[_A-Z]+[_A-Z0-9-]*:[^\\n\\r\\f;]+;?\\s*$/i,\n\t\t'phone': /^(?:(?:\\(?(?:00|\\+)(?:[1-4]\\d\\d|[1-9]\\d?)\\)?)?[\\-\\.\\ \\\\\\/]?)?(?:(?:\\(?\\d{1,}\\)?[\\-\\.\\ \\\\\\/]?){0,})(?:[\\-\\.\\ \\\\\\/]?(?:#|ext\\.?|extension|x)[\\-\\.\\ \\\\\\/]?(?:\\d+))?$/i,\n\t\t'uri': /^(?:([a-z0-9+.-]+:\\/\\/)((?:(?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)(:(?:\\d*))?(\\/(?:[a-z0-9-._~!$&'()*+,;=:@\\/]|%[0-9A-F]{2})*)?|([a-z0-9+.-]+:)(\\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})+(?:[a-z0-9-._~!$&'()*+,;=:@\\/]|%[0-9A-F]{2})*)?)(\\?(?:[a-z0-9-._~!$&'()*+,;=:\\/?@]|%[0-9A-F]{2})*)?(#(?:[a-z0-9-._~!$&'()*+,;=:\\/?@]|%[0-9A-F]{2})*)?$/i,\n\t\t'email': /^[A-Z0-9._%+-]+@(?:[A-Z0-9-]+\\.)+[A-Z]{2,}$/i,\n\t\t'ipv4': /^(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])$/,\n\t\t'ipv6': /^\\s*((([0-9A-F]{1,4}:){7}([0-9A-F]{1,4}|:))|(([0-9A-F]{1,4}:){6}(:[0-9A-F]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-F]{1,4}:){5}(((:[0-9A-F]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-F]{1,4}:){4}(((:[0-9A-F]{1,4}){1,3})|((:[0-9A-F]{1,4})((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-F]{1,4}:){3}(((:[0-9A-F]{1,4}){1,4})|((:[0-9A-F]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-F]{1,4}:){2}(((:[0-9A-F]{1,4}){1,5})|((:[0-9A-F]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-F]{1,4}:){1}(((:[0-9A-F]{1,4}){1,6})|((:[0-9A-F]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-F]{1,4}){1,7})|((:[0-9A-F]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/i,\n\n\t\t// hostname regex from: http://stackoverflow.com/a/1420225/5628\n\t\t'hostname': /^(?=.{1,255}$)[0-9A-Z](?:(?:[0-9A-Z]|-){0,61}[0-9A-Z])?(?:\\.[0-9A-Z](?:(?:[0-9A-Z]|-){0,61}[0-9A-Z])?)*\\.?$/i,\n\n\t\t'utc-millisec': function(subject) {\n\t\t\tvar parsed = parseInt(subject, 10);\n\t\t\treturn !isNaN(parsed) && parsed.toString() === subject.toString();\n\t\t},\n\t\t'regex': function (subject) {\n\t\t\tif(INVALID_ESCAPES.test(subject)) return false;\n\t\t\ttry {\n\t\t\t\tnew RegExp(subject);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch(e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t};\n\n// aliases\nformats['host-name'] = formats.hostname;\nformats['ip-address'] = formats.ipv4;\n\n\nfunction getType(subject) {\n\tvar type = typeof subject;\n\n\tif(type === 'object') {\n\t\tif(subject === null) return 'null';\n\t\tif(Array.isArray(subject)) return 'array';\n\t}\n\n\tif(type === 'number' && subject === Math.round(subject)) return 'integer';\n\n\treturn type;\n}\n\nfunction format(context, subject, schema) {\n\tvar fmt = schema.format,\n\t\tvalidator = formats[fmt];\n\n\tif(!validator)\n\t\tthrow new Error('Invalid schema: unknown format (' + fmt + ')');\n\n\tvar valid = validator.test ? validator.test(subject) : validator(subject);\n\tif(!valid) {\n\t\tcontext.addError('Failed \"format\" criteria (' + fmt + ')', subject, schema);\n\t}\n\n\treturn valid;\n}\n\nfunction validateTypes(context, subject, type, validTypes) {\n\tvar i = validTypes.length,\n\t\tvalidType, valid;\n\twhile(i--) {\n\t\tvalidType = validTypes[i];\n\n\t\tif(validType === 'any') return true;\n\n\t\tif(typeof validType === 'object') {\n\t\t\tvalid = context.silently(function() {\n\t\t\t\treturn validateBase(context, subject, validType);\n\t\t\t}); // jshint ignore:line\n\t\t\tif(valid) return true;\n\t\t\telse continue;\n\t\t}\n\n\t\tif(!(validType in validators.types))\n\t\t\tthrow new Error('Invalid schema: invalid type (' + validType + ')');\n\n\t\tif(validType === 'number' && type === 'integer') return true;\n\n\t\tif(type === validType) return true;\n\t}\n\n\treturn false;\n}\n\nfunction allOf(context, subject, schema) {\n\tvar schemas = schema.allOf;\n\n\tif(!Array.isArray(schemas))\n\t\tthrow new Error('Invalid schema: \"allOf\" value must be an array');\n\n\tvar i = schemas.length,\n\t\tinvalidCount = 0;\n\twhile(i--) {\n\t\tif(!validateBase(context, subject, schemas[i])) {\n\t\t\tinvalidCount += 1;\n\t\t}\n\t}\n\n\tif(invalidCount === 0) return true;\n\n\tcontext.addError('Failed \"allOf\" criteria', subject, schemas);\n\treturn false;\n}\n\nfunction anyOf(context, subject, schema) {\n\tvar schemas = schema.anyOf;\n\n\tif(!Array.isArray(schemas))\n\t\tthrow new Error('Invalid schema: \"anyOf\" value must be an array');\n\n\tvar matched = context.silently(function() {\n\t\tvar i = schemas.length;\n\t\twhile(i--) {\n\t\t\tif(validateBase(context, subject, schemas[i])) return true;\n\t\t}\n\t\treturn false;\n\t});\n\n\tif(matched) return true;\n\n\tcontext.addError('Failed \"anyOf\" criteria', subject, schemas);\n\treturn false;\n}\n\nfunction oneOf(context, subject, schema) {\n\tvar schemas = schema.oneOf;\n\n\tif(!Array.isArray(schemas))\n\t\tthrow new Error('Invalid schema: \"oneOf\" value must be an array');\n\n\tvar i = schemas.length,\n\t\tvalidCount = 0;\n\tcontext.silently(function() {\n\t\twhile(i--) {\n\t\t\tif(validateBase(context, subject, schemas[i])) validCount += 1;\n\t\t}\n\t});\n\n\tif(validCount === 1) return true;\n\n\tcontext.addError('Failed \"oneOf\" criteria', subject, schemas);\n\treturn false;\n}\n\nfunction not(context, subject, schema) {\n\tvar badSchema = schema.not,\n\t\tvalid = context.silently(function() {\n\t\t\treturn !validateBase(context, subject, badSchema);\n\t\t});\n\n\tif(valid) return true;\n\n\tcontext.addError('Failed \"not\" criteria', subject, schema);\n\treturn false;\n}\n\nfunction disallow(context, subject, schema, type) {\n\tvar invalidTypes = Array.isArray(schema.disallow) ? schema.disallow : [ schema.disallow ],\n\t\tvalid = !validateTypes(context, subject, type, invalidTypes);\n\n\tif(!valid) {\n\t\tcontext.addError('Failed \"disallow\" criteria: expecting ' + invalidTypes.join(' or ') + ', found ' + type, subject, schema);\n\t}\n\n\treturn valid;\n}\n\nfunction validateExtends(context, subject, schema) {\n\tvar schemas = Array.isArray(schema[\"extends\"]) ? schema[\"extends\"] : [ schema[\"extends\"] ];\n\n\tvar i = schemas.length,\n\t\tinvalidCount = 0;\n\twhile(i--) {\n\t\tif(!validateBase(context, subject, schemas[i])) {\n\t\t\tinvalidCount += 1;\n\t\t}\n\t}\n\n\treturn invalidCount === 0;\n}\n\nfunction validateEnum(context, subject, schema) {\n\tvar values = schema['enum'];\n\n\tif(!Array.isArray(values))\n\t\tthrow new Error('Invalid schema: \"enum\" value must be an array');\n\n\tvar i = values.length;\n\twhile(i--) {\n\t\tif(validators.deepEqual(subject, values[i])) return true;\n\t}\n\n\tcontext.addError('Failed \"enum\" criteria', subject, values);\n\treturn false;\n}\n\nfunction validateType(context, subject, schema, type) {\n\tvar validTypes = Array.isArray(schema.type) ? schema.type : [ schema.type ],\n\t\tvalid = validateTypes(context, subject, type, validTypes);\n\n\tif(!valid) {\n\t\tcontext.addError('Failed \"type\" criteria: expecting ' + validTypes.join(' or ') + ', found ' + type, subject, schema);\n\t}\n\n\treturn valid;\n}\n\nfunction typeValidations(context, subject, schema, type) {\n\treturn validators.types[type](context, subject, schema);\n}\n\nfunction pathFromIds(ids) {\n\treturn ids.map(function(id) {\n\t\tvar lastSlash = id.lastIndexOf(\"/\");\n\t\tif(lastSlash === -1) return id;\n\t\treturn id.substr(0, lastSlash + 1);\n\t}).join('');\n}\n\nfunction $ref(context, subject, schema) {\n\tvar absolute = /^(#|\\/)/.test(schema.$ref),\n\t\tref = absolute ? schema.$ref : pathFromIds(context.id) + schema.$ref,\n\t\trefSchema = context.refs.get(ref, context.schema),\n\t\tctx = context;\n\n\tif(schema.$ref[0] !== '#') {\n\t\tctx = context.subcontext(context.refs.get(ref, context.schema, true));\n\t}\n\n\tvar valid = validateBase(ctx, subject, refSchema);\n\n\tcontext.cleanSubject = ctx.cleanSubject;\n\n\treturn valid;\n}\n\n\n\nfunction validateBase(context, subject, schema) {\n\tif(schema.$ref) {\n\t\treturn $ref(context, subject, schema);\n\t}\n\n\tif(schema.id) context.id.push(schema.id);\n\n\tvar valid = context.runValidations([\n\t\t[ 'type' in schema, validateType ],\n\t\t[ 'disallow' in schema, disallow ],\n\t\t[ 'enum' in schema, validateEnum ],\n\t\t[ true, typeValidations ],\n\t\t[ 'format' in schema, format ],\n\t\t[ 'extends' in schema, validateExtends ],\n\t\t[ 'allOf' in schema, allOf ],\n\t\t[ 'anyOf' in schema, anyOf ],\n\t\t[ 'oneOf' in schema, oneOf ],\n\t\t[ 'not' in schema, not ]\n\t], subject, schema, getType(subject));\n\n\tif(schema.id) context.id.pop();\n\n\treturn valid;\n}\n\nmodule.exports = validateBase;\n"], "fixing_code": ["var INVALID_ESCAPES = /[^\\\\]\\\\[^.*+?^${}()|[\\]\\\\bBcdDfnrsStvwWxu0-9]/;\nvar validators = require('./'),\n\tformats = {\n\t\t'date-time': /^\\d{4}-(0[0-9]{1}|1[0-2]{1})-[0-9]{2}[t ]\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?([zZ]|[+-]\\d{2}:\\d{2})$/i,\n\t\t'date': /^\\d{4}-(0[0-9]{1}|1[0-2]{1})-[0-9]{2}$/,\n\t\t'time': /^\\d{2}:\\d{2}:\\d{2}$/,\n\t\t'color': /^(#[0-9a-f]{3}|#[0-9a-f]{6}|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)$/i,\n\t\t'style': /^(?:\\s*-?[_A-Z]+[_A-Z0-9-]*:[^\\n\\r\\f;]+;)*\\s*-?[_A-Z]+[_A-Z0-9-]*:[^\\n\\r\\f;]+;?\\s*$/i,\n\t\t'phone': /^(?:(?:\\(?(?:00|\\+)(?:[1-4]\\d\\d|[1-9]\\d?)\\)?)?[\\-\\.\\ \\\\\\/]?)?(?:(?:\\(?\\d{1,}\\)?[\\-\\.\\ \\\\\\/]?){0,})(?:[\\-\\.\\ \\\\\\/]?(?:#|ext\\.?|extension|x)[\\-\\.\\ \\\\\\/]?(?:\\d+))?$/i,\n\t\t'uri': /^(?:([a-z0-9+.-]+:\\/\\/)((?:(?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)(:(?:\\d*))?(\\/(?:[a-z0-9-._~!$&'()*+,;=:@\\/]|%[0-9A-F]{2})*)?|([a-z0-9+.-]+:)(\\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})(?:[a-z0-9-._~!$&'()*+,;=:@\\/]|%[0-9A-F]{2})*)?)(\\?(?:[a-z0-9-._~!$&'()*+,;=:\\/?@]|%[0-9A-F]{2})*)?(#(?:[a-z0-9-._~!$&'()*+,;=:\\/?@]|%[0-9A-F]{2})*)?$/i,\n\t\t'email': /^[A-Z0-9._%+-]+@(?:[A-Z0-9-]+\\.)+[A-Z]{2,}$/i,\n\t\t'ipv4': /^(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])$/,\n\t\t'ipv6': /^\\s*((([0-9A-F]{1,4}:){7}([0-9A-F]{1,4}|:))|(([0-9A-F]{1,4}:){6}(:[0-9A-F]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-F]{1,4}:){5}(((:[0-9A-F]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-F]{1,4}:){4}(((:[0-9A-F]{1,4}){1,3})|((:[0-9A-F]{1,4})((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-F]{1,4}:){3}(((:[0-9A-F]{1,4}){1,4})|((:[0-9A-F]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-F]{1,4}:){2}(((:[0-9A-F]{1,4}){1,5})|((:[0-9A-F]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-F]{1,4}:){1}(((:[0-9A-F]{1,4}){1,6})|((:[0-9A-F]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-F]{1,4}){1,7})|((:[0-9A-F]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/i,\n\n\t\t// hostname regex from: http://stackoverflow.com/a/1420225/5628\n\t\t'hostname': /^(?=.{1,255}$)[0-9A-Z](?:(?:[0-9A-Z]|-){0,61}[0-9A-Z])?(?:\\.[0-9A-Z](?:(?:[0-9A-Z]|-){0,61}[0-9A-Z])?)*\\.?$/i,\n\n\t\t'utc-millisec': function(subject) {\n\t\t\tvar parsed = parseInt(subject, 10);\n\t\t\treturn !isNaN(parsed) && parsed.toString() === subject.toString();\n\t\t},\n\t\t'regex': function (subject) {\n\t\t\tif(INVALID_ESCAPES.test(subject)) return false;\n\t\t\ttry {\n\t\t\t\tnew RegExp(subject);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch(e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t};\n\n// aliases\nformats['host-name'] = formats.hostname;\nformats['ip-address'] = formats.ipv4;\n\n\nfunction getType(subject) {\n\tvar type = typeof subject;\n\n\tif(type === 'object') {\n\t\tif(subject === null) return 'null';\n\t\tif(Array.isArray(subject)) return 'array';\n\t}\n\n\tif(type === 'number' && subject === Math.round(subject)) return 'integer';\n\n\treturn type;\n}\n\nfunction format(context, subject, schema) {\n\tvar fmt = schema.format,\n\t\tvalidator = formats[fmt];\n\n\tif(!validator)\n\t\tthrow new Error('Invalid schema: unknown format (' + fmt + ')');\n\n\tvar valid = validator.test ? validator.test(subject) : validator(subject);\n\tif(!valid) {\n\t\tcontext.addError('Failed \"format\" criteria (' + fmt + ')', subject, schema);\n\t}\n\n\treturn valid;\n}\n\nfunction validateTypes(context, subject, type, validTypes) {\n\tvar i = validTypes.length,\n\t\tvalidType, valid;\n\twhile(i--) {\n\t\tvalidType = validTypes[i];\n\n\t\tif(validType === 'any') return true;\n\n\t\tif(typeof validType === 'object') {\n\t\t\tvalid = context.silently(function() {\n\t\t\t\treturn validateBase(context, subject, validType);\n\t\t\t}); // jshint ignore:line\n\t\t\tif(valid) return true;\n\t\t\telse continue;\n\t\t}\n\n\t\tif(!(validType in validators.types))\n\t\t\tthrow new Error('Invalid schema: invalid type (' + validType + ')');\n\n\t\tif(validType === 'number' && type === 'integer') return true;\n\n\t\tif(type === validType) return true;\n\t}\n\n\treturn false;\n}\n\nfunction allOf(context, subject, schema) {\n\tvar schemas = schema.allOf;\n\n\tif(!Array.isArray(schemas))\n\t\tthrow new Error('Invalid schema: \"allOf\" value must be an array');\n\n\tvar i = schemas.length,\n\t\tinvalidCount = 0;\n\twhile(i--) {\n\t\tif(!validateBase(context, subject, schemas[i])) {\n\t\t\tinvalidCount += 1;\n\t\t}\n\t}\n\n\tif(invalidCount === 0) return true;\n\n\tcontext.addError('Failed \"allOf\" criteria', subject, schemas);\n\treturn false;\n}\n\nfunction anyOf(context, subject, schema) {\n\tvar schemas = schema.anyOf;\n\n\tif(!Array.isArray(schemas))\n\t\tthrow new Error('Invalid schema: \"anyOf\" value must be an array');\n\n\tvar matched = context.silently(function() {\n\t\tvar i = schemas.length;\n\t\twhile(i--) {\n\t\t\tif(validateBase(context, subject, schemas[i])) return true;\n\t\t}\n\t\treturn false;\n\t});\n\n\tif(matched) return true;\n\n\tcontext.addError('Failed \"anyOf\" criteria', subject, schemas);\n\treturn false;\n}\n\nfunction oneOf(context, subject, schema) {\n\tvar schemas = schema.oneOf;\n\n\tif(!Array.isArray(schemas))\n\t\tthrow new Error('Invalid schema: \"oneOf\" value must be an array');\n\n\tvar i = schemas.length,\n\t\tvalidCount = 0;\n\tcontext.silently(function() {\n\t\twhile(i--) {\n\t\t\tif(validateBase(context, subject, schemas[i])) validCount += 1;\n\t\t}\n\t});\n\n\tif(validCount === 1) return true;\n\n\tcontext.addError('Failed \"oneOf\" criteria', subject, schemas);\n\treturn false;\n}\n\nfunction not(context, subject, schema) {\n\tvar badSchema = schema.not,\n\t\tvalid = context.silently(function() {\n\t\t\treturn !validateBase(context, subject, badSchema);\n\t\t});\n\n\tif(valid) return true;\n\n\tcontext.addError('Failed \"not\" criteria', subject, schema);\n\treturn false;\n}\n\nfunction disallow(context, subject, schema, type) {\n\tvar invalidTypes = Array.isArray(schema.disallow) ? schema.disallow : [ schema.disallow ],\n\t\tvalid = !validateTypes(context, subject, type, invalidTypes);\n\n\tif(!valid) {\n\t\tcontext.addError('Failed \"disallow\" criteria: expecting ' + invalidTypes.join(' or ') + ', found ' + type, subject, schema);\n\t}\n\n\treturn valid;\n}\n\nfunction validateExtends(context, subject, schema) {\n\tvar schemas = Array.isArray(schema[\"extends\"]) ? schema[\"extends\"] : [ schema[\"extends\"] ];\n\n\tvar i = schemas.length,\n\t\tinvalidCount = 0;\n\twhile(i--) {\n\t\tif(!validateBase(context, subject, schemas[i])) {\n\t\t\tinvalidCount += 1;\n\t\t}\n\t}\n\n\treturn invalidCount === 0;\n}\n\nfunction validateEnum(context, subject, schema) {\n\tvar values = schema['enum'];\n\n\tif(!Array.isArray(values))\n\t\tthrow new Error('Invalid schema: \"enum\" value must be an array');\n\n\tvar i = values.length;\n\twhile(i--) {\n\t\tif(validators.deepEqual(subject, values[i])) return true;\n\t}\n\n\tcontext.addError('Failed \"enum\" criteria', subject, values);\n\treturn false;\n}\n\nfunction validateType(context, subject, schema, type) {\n\tvar validTypes = Array.isArray(schema.type) ? schema.type : [ schema.type ],\n\t\tvalid = validateTypes(context, subject, type, validTypes);\n\n\tif(!valid) {\n\t\tcontext.addError('Failed \"type\" criteria: expecting ' + validTypes.join(' or ') + ', found ' + type, subject, schema);\n\t}\n\n\treturn valid;\n}\n\nfunction typeValidations(context, subject, schema, type) {\n\treturn validators.types[type](context, subject, schema);\n}\n\nfunction pathFromIds(ids) {\n\treturn ids.map(function(id) {\n\t\tvar lastSlash = id.lastIndexOf(\"/\");\n\t\tif(lastSlash === -1) return id;\n\t\treturn id.substr(0, lastSlash + 1);\n\t}).join('');\n}\n\nfunction $ref(context, subject, schema) {\n\tvar absolute = /^(#|\\/)/.test(schema.$ref),\n\t\tref = absolute ? schema.$ref : pathFromIds(context.id) + schema.$ref,\n\t\trefSchema = context.refs.get(ref, context.schema),\n\t\tctx = context;\n\n\tif(schema.$ref[0] !== '#') {\n\t\tctx = context.subcontext(context.refs.get(ref, context.schema, true));\n\t}\n\n\tvar valid = validateBase(ctx, subject, refSchema);\n\n\tcontext.cleanSubject = ctx.cleanSubject;\n\n\treturn valid;\n}\n\n\n\nfunction validateBase(context, subject, schema) {\n\tif(schema.$ref) {\n\t\treturn $ref(context, subject, schema);\n\t}\n\n\tif(schema.id) context.id.push(schema.id);\n\n\tvar valid = context.runValidations([\n\t\t[ 'type' in schema, validateType ],\n\t\t[ 'disallow' in schema, disallow ],\n\t\t[ 'enum' in schema, validateEnum ],\n\t\t[ true, typeValidations ],\n\t\t[ 'format' in schema, format ],\n\t\t[ 'extends' in schema, validateExtends ],\n\t\t[ 'allOf' in schema, allOf ],\n\t\t[ 'anyOf' in schema, anyOf ],\n\t\t[ 'oneOf' in schema, oneOf ],\n\t\t[ 'not' in schema, not ]\n\t], subject, schema, getType(subject));\n\n\tif(schema.id) context.id.pop();\n\n\treturn valid;\n}\n\nmodule.exports = validateBase;\n"], "filenames": ["validators/base.js"], "buggy_code_start_loc": [10], "buggy_code_end_loc": [11], "fixing_code_start_loc": [10], "fixing_code_end_loc": [11], "type": "CWE-1333", "message": "A vulnerability was found in Prestaul skeemas and classified as problematic. This issue affects some unknown processing of the file validators/base.js. The manipulation of the argument uri leads to inefficient regular expression complexity. The name of the patch is 65e94eda62dc8dc148ab3e59aa2ccc086ac448fd. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-218003.", "other": {"cve": {"id": "CVE-2018-25074", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-11T15:15:09.097", "lastModified": "2023-01-19T14:31:01.753", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in Prestaul skeemas and classified as problematic. This issue affects some unknown processing of the file validators/base.js. The manipulation of the argument uri leads to inefficient regular expression complexity. The name of the patch is 65e94eda62dc8dc148ab3e59aa2ccc086ac448fd. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-218003."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:M/Au:S/C:N/I:N/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.3}, "baseSeverity": "LOW", "exploitabilityScore": 4.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1333"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:skeemas_project:skeemas:*:*:*:*:*:*:*:*", "versionEndExcluding": "2018-02-22", "matchCriteriaId": "A0B71645-F13E-4193-9136-AED7AA7303BE"}]}]}], "references": [{"url": "https://github.com/Prestaul/skeemas/commit/65e94eda62dc8dc148ab3e59aa2ccc086ac448fd", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.218003", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.218003", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Prestaul/skeemas/commit/65e94eda62dc8dc148ab3e59aa2ccc086ac448fd"}}